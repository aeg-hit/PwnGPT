
Elf32_Sym struc ; (sizeof=0x10, align=0x4, mappedto_1)
                        ; XREF: LOAD:080481CC/r
                        ; LOAD:080481DC/r ...
st_name dd ?            ; offset (0804824C)
st_value dd ?           ; offset (00000000)
st_size dd ?
st_info db ?
st_other db ?
st_shndx dw ?
Elf32_Sym ends


Elf32_Rel struc ; (sizeof=0x8, align=0x4, copyof_2)
                        ; XREF: LOAD:080482DC/r
                        ; LOAD:080482E4/r ...
r_offset dd ?
r_info dd ?
Elf32_Rel ends


Elf32_Dyn struc ; (sizeof=0x8, align=0x4, copyof_4)
                        ; XREF: LOAD:_DYNAMIC/r
                        ; LOAD:08049F1C/r ...
d_tag dd ?
d_un Elf32_Dyn::$A263394DDF3EC2D4B1B8448EDD30E249 ?
Elf32_Dyn ends


Elf32_Dyn::$A263394DDF3EC2D4B1B8448EDD30E249 union ; (sizeof=0x4, align=0x4, copyof_3)
                        ; XREF: Elf32_Dyn/r
d_val dd ?
d_ptr dd ?
Elf32_Dyn::$A263394DDF3EC2D4B1B8448EDD30E249 ends


Elf32_Verneed struc ; (sizeof=0x10, align=0x4, mappedto_5)
                        ; XREF: LOAD:080482BC/r
vn_version dw ?
vn_cnt dw ?
vn_file dd ?            ; offset (0804824C)
vn_aux dd ?
vn_next dd ?
Elf32_Verneed ends


Elf32_Vernaux struc ; (sizeof=0x10, align=0x4, mappedto_6)
                        ; XREF: LOAD:080482CC/r
vna_hash dd ?
vna_flags dw ?
vna_other dw ?
vna_name dd ?           ; offset (0804824C)
vna_next dd ?
Elf32_Vernaux ends


;
; +-------------------------------------------------------------------------+
; |      This file was generated by The Interactive Disassembler (IDA)      |
; |           Copyright (c) 2023 Hex-Rays, <support@hex-rays.com>           |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : 2118297743321632D4A22A9C60E488D9B0AE481582E9C814F3B04928F0D01AFA
; Input MD5    : B6910492C56085D5C9D25AEAF07A6C3E
; Input CRC32  : 64A719A2

; File Name   : D:\project\LLM4CTF\pwn\integer\int-2\int2
; Format      : ELF for Intel 386 (Executable)
; Imagebase   : 8048000
; Interpreter '/lib/ld-linux.so.2'
; Needed Library 'libc.so.6'
;
; Source File : 'crtstuff.c'
; Source File : 'int_overflow.c'
; Source File : 'crtstuff.c'

.686p
.mmx
.model flat
.intel_syntax noprefix


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment mempage public 'CODE' use32
assume cs:LOAD
;org 8048000h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
dword_8048000 dd 464C457Fh ; File format: \x7FELF
db 1                    ; File class: 32-bit
db 1                    ; Data encoding: little-endian
db 1                    ; File version
db 0                    ; OS/ABI: UNIX System V ABI
db 0                    ; ABI Version
db 7 dup(0)             ; Padding
dw 2                    ; File type: Executable
dw 3                    ; Machine: Intel 386
dd 1                    ; File version
dd offset _start        ; Entry point
dd 34h                  ; PHT file offset
dd 17F8h                ; SHT file offset
dd 0                    ; Processor-specific flags
dw 34h                  ; ELF header size
dw 20h                  ; PHT entry size
dw 9                    ; Number of entries in PHT
dw 28h                  ; SHT entry size
dw 1Eh                  ; Number of entries in SHT
dw 1Dh                  ; SHT entry index for string table
; ELF32 Program Header
; PHT Entry 0
dword_8048034 dd 6      ; Type: PHDR
dd 34h                  ; File offset
dd offset dword_8048034 ; Virtual address
dd 8048034h             ; Physical address
dd 120h                 ; Size in file image
dd 120h                 ; Size in memory image
dd 4                    ; Flags
dd 4                    ; Alignment
; PHT Entry 1
dd 3                    ; Type: INTERP
dd 154h                 ; File offset
dd offset aLibLdLinuxSo2 ; Virtual address
dd 8048154h             ; Physical address
dd 13h                  ; Size in file image
dd 13h                  ; Size in memory image
dd 4                    ; Flags
dd 1                    ; Alignment
; PHT Entry 2
dd 1                    ; Type: LOAD
dd 0                    ; File offset
dd offset dword_8048000 ; Virtual address
dd 8048000h             ; Physical address
dd 814h                 ; Size in file image
dd 814h                 ; Size in memory image
dd 5                    ; Flags
dd 1000h                ; Alignment
; PHT Entry 3
dd 1                    ; Type: LOAD
dd 0F0Ch                ; File offset
dd offset __frame_dummy_init_array_entry ; Virtual address
dd 8049F0Ch             ; Physical address
dd 11Ch                 ; Size in file image
dd 348h                 ; Size in memory image
dd 6                    ; Flags
dd 1000h                ; Alignment
; PHT Entry 4
dd 2                    ; Type: DYNAMIC
dd 0F14h                ; File offset
dd offset _DYNAMIC      ; Virtual address
dd 8049F14h             ; Physical address
dd 0E8h                 ; Size in file image
dd 0E8h                 ; Size in memory image
dd 6                    ; Flags
dd 4                    ; Alignment
; PHT Entry 5
dd 4                    ; Type: NOTE
dd 168h                 ; File offset
dd offset dword_8048168 ; Virtual address
dd 8048168h             ; Physical address
dd 44h                  ; Size in file image
dd 44h                  ; Size in memory image
dd 4                    ; Flags
dd 4                    ; Alignment
; PHT Entry 6
dd 6474E550h            ; Type: EH_FRAME
dd 684h                 ; File offset
dd offset __GNU_EH_FRAME_HDR ; Virtual address
dd 8048684h             ; Physical address
dd 4Ch                  ; Size in file image
dd 4Ch                  ; Size in memory image
dd 4                    ; Flags
dd 4                    ; Alignment
; PHT Entry 7
dd 6474E551h            ; Type: STACK
dd 0                    ; File offset
dd 0                    ; Virtual address
dd 0                    ; Physical address
dd 0                    ; Size in file image
dd 0                    ; Size in memory image
dd 7                    ; Flags
dd 10h                  ; Alignment
; PHT Entry 8
dd 6474E552h            ; Type: RO-AFTER
dd 0F0Ch                ; File offset
dd offset __frame_dummy_init_array_entry ; Virtual address
dd 8049F0Ch             ; Physical address
dd 0F4h                 ; Size in file image
dd 0F4h                 ; Size in memory image
dd 4                    ; Flags
dd 1                    ; Alignment
aLibLdLinuxSo2 db '/lib/ld-linux.so.2',0
align 4
; ELF Note Entry
dword_8048168 dd 4      ; Name Size
dd 10h                  ; Desc Size
dd 1                    ; Type: NT_GNU_ABI_TAG
aGnu db 'GNU',0         ; Name
dd 0, 3, 2, 0           ; ABI: Linux 3.2.0
; ELF Note Entry
dd 4                    ; Name Size
dd 14h                  ; Desc Size
dd 3                    ; Type: NT_GNU_BUILD_ID
aGnu_0 db 'GNU',0       ; Name
db 0B1h, 42h, 80h, 12h, 0A2h, 42h, 9Fh, 2 ; Desc
db 8Ah, 4Eh, 0CAh, 94h, 0A9h, 0B3h, 0ACh
db 25h, 0DCh, 7Eh, 88h, 0CFh
; ELF GNU Hash Table
elf_gnu_hash_nbuckets dd 2
elf_gnu_hash_symbias dd 7
elf_gnu_hash_bitmask_nwords dd 1
elf_gnu_hash_shift dd 5
elf_gnu_hash_indexes dd 20002000h
elf_gnu_hash_bucket dd 0, 7
elf_gnu_hash_chain dd 0C0E34BADh
; ELF Symbol Table
Elf32_Sym <0>
Elf32_Sym <offset aGets - offset byte_804824C,\ ; "gets"
           0, 0, 12h, 0, 0>
Elf32_Sym <offset aStrcpy - offset byte_804824C,\ ; "strcpy"
           0, 0, 12h, 0, 0>
Elf32_Sym <offset aPuts - offset byte_804824C,\ ; "puts"
           0, 0, 12h, 0, 0>
Elf32_Sym <offset aGmonStart - offset byte_804824C,\ ; "__gmon_start__"
           0, 0, 20h, 0, 0>
Elf32_Sym <offset aStrlen - offset byte_804824C,\ ; "strlen"
           0, 0, 12h, 0, 0>
Elf32_Sym <offset aLibcStartMain - offset byte_804824C,\ ; "__libc_start_main"
           0, 0, 12h, 0, 0>
Elf32_Sym <offset aIoStdinUsed - offset byte_804824C,\ ; "_IO_stdin_used"
           offset _IO_stdin_used, 4, \
           11h, 0, 10h>
; ELF String Table
byte_804824C db 0
aLibcSo6 db 'libc.so.6',0
aIoStdinUsed db '_IO_stdin_used',0
aGets db 'gets',0
aStrcpy db 'strcpy',0
aPuts db 'puts',0
aStrlen db 'strlen',0
aLibcStartMain db '__libc_start_main',0
aGlibc20 db 'GLIBC_2.0',0
aGmonStart db '__gmon_start__',0
align 2
; ELF GNU Symbol Version Table
dw 0
dw 2                    ; gets@@GLIBC_2.0
dw 2                    ; strcpy@@GLIBC_2.0
dw 2                    ; puts@@GLIBC_2.0
dw 0                    ; local  symbol: __gmon_start__
dw 2                    ; strlen@@GLIBC_2.0
dw 2                    ; __libc_start_main@@GLIBC_2.0
dw 1                    ; global symbol: _IO_stdin_used
dw 0
; ELF GNU Symbol Version Requirements
Elf32_Verneed <1, 1, \  ; "libc.so.6"
               offset aLibcSo6 - offset byte_804824C,\
               10h, 0>
Elf32_Vernaux <0D696910h, 0, 2, \ ; "GLIBC_2.0"
               offset aGlibc20 - offset byte_804824C,\
               0>
; ELF REL Relocation Table
Elf32_Rel <8049FFCh, 406h> ; R_386_GLOB_DAT __gmon_start__
; ELF JMPREL Relocation Table
Elf32_Rel <804A00Ch, 107h> ; R_386_JMP_SLOT gets
Elf32_Rel <804A010h, 207h> ; R_386_JMP_SLOT strcpy
Elf32_Rel <804A014h, 307h> ; R_386_JMP_SLOT puts
Elf32_Rel <804A018h, 507h> ; R_386_JMP_SLOT strlen
Elf32_Rel <804A01Ch, 607h> ; R_386_JMP_SLOT __libc_start_main
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_init segment dword public 'CODE' use32
assume cs:_init
;org 804830Ch
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _init_proc
_init_proc proc near
push    ebx             ; _init
sub     esp, 8
call    __x86_get_pc_thunk_bx
add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)
mov     eax, ds:(__gmon_start___ptr - 804A000h)[ebx]
test    eax, eax
jz      short loc_804832A
call    __gmon_start__

loc_804832A:
add     esp, 8
pop     ebx
retn
_init_proc endp

_init ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment mempage public 'CODE' use32
assume cs:LOAD
;org 804832Fh
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 10h
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_plt segment para public 'CODE' use32
assume cs:_plt
;org 8048330h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



sub_8048330 proc near
; __unwind {
push    ds:dword_804A004
jmp     ds:dword_804A008
sub_8048330 endp

align 10h
; [00000006 BYTES: COLLAPSED FUNCTION _gets. PRESS CTRL-NUMPAD+ TO EXPAND]
push    0
jmp     sub_8048330
; [00000006 BYTES: COLLAPSED FUNCTION _strcpy. PRESS CTRL-NUMPAD+ TO EXPAND]
push    8
jmp     sub_8048330
; [00000006 BYTES: COLLAPSED FUNCTION _puts. PRESS CTRL-NUMPAD+ TO EXPAND]
push    10h
jmp     sub_8048330
; [00000006 BYTES: COLLAPSED FUNCTION _strlen. PRESS CTRL-NUMPAD+ TO EXPAND]
push    18h
jmp     sub_8048330
; [00000006 BYTES: COLLAPSED FUNCTION ___libc_start_main. PRESS CTRL-NUMPAD+ TO EXPAND]
push    20h ; ' '
jmp     sub_8048330
; } // starts at 8048330
_plt ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_plt_got segment qword public 'CODE' use32
assume cs:_plt_got
;org 8048390h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; [00000006 BYTES: COLLAPSED FUNCTION __gmon_start__. PRESS CTRL-NUMPAD+ TO EXPAND]
align 4
; } // starts at 8048390
_plt_got ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment mempage public 'CODE' use32
assume cs:LOAD
;org 8048398h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 10h
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_text segment para public 'CODE' use32
assume cs:_text
;org 80483A0h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing


; Attributes: noreturn fuzzy-sp

public _start
_start proc near
xor     ebp, ebp
pop     esi
mov     ecx, esp
and     esp, 0FFFFFFF0h
push    eax
push    esp             ; stack_end
push    edx             ; rtld_fini
call    sub_80483D3
add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)
lea     eax, (__libc_csu_fini - 804A000h)[ebx]
push    eax             ; fini
lea     eax, (__libc_csu_init - 804A000h)[ebx]
push    eax             ; init
push    ecx             ; ubp_av
push    esi             ; argc
mov     eax, offset main
push    eax             ; main
call    ___libc_start_main
hlt
_start endp




sub_80483D3 proc near
mov     ebx, [esp+0]
retn
sub_80483D3 endp

align 10h



public _dl_relocate_static_pie
_dl_relocate_static_pie proc near
; __unwind {
rep retn
; } // starts at 80483E0
_dl_relocate_static_pie endp

align 10h



public __x86_get_pc_thunk_bx
__x86_get_pc_thunk_bx proc near
mov     ebx, [esp+0]
retn
__x86_get_pc_thunk_bx endp

align 10h



deregister_tm_clones proc near
mov     eax, offset __bss_start
cmp     eax, offset __bss_start
jz      short locret_8048430
mov     eax, 0
test    eax, eax
jz      short locret_8048430
push    ebp
mov     ebp, esp
sub     esp, 14h
push    offset __bss_start
call    eax
add     esp, 10h
leave
retn
align 10h

locret_8048430:
rep retn
deregister_tm_clones endp

align 10h



register_tm_clones proc near
mov     eax, offset __bss_start
sub     eax, offset __bss_start
sar     eax, 2
mov     edx, eax
shr     edx, 1Fh
add     eax, edx
sar     eax, 1
jz      short locret_8048478
mov     edx, 0
test    edx, edx
jz      short locret_8048478
push    ebp
mov     ebp, esp
sub     esp, 10h
push    eax
push    offset __bss_start
call    edx
add     esp, 10h
leave
retn
align 8

locret_8048478:
rep retn
register_tm_clones endp

align 10h



__do_global_dtors_aux proc near
cmp     ds:completed_7283, 0
jnz     short locret_80484A0
push    ebp
mov     ebp, esp
sub     esp, 8
call    deregister_tm_clones
mov     ds:completed_7283, 1
leave
retn
align 10h

locret_80484A0:
rep retn
__do_global_dtors_aux endp

align 10h


; Attributes: bp-based frame

frame_dummy proc near
push    ebp
mov     ebp, esp
pop     ebp
jmp     short register_tm_clones
frame_dummy endp



; Attributes: bp-based frame

; int __cdecl check(int, char *src)
public check
check proc near

var_C= byte ptr -0Ch
var_4= dword ptr -4
arg_0= dword ptr  8
src= dword ptr  0Ch

; __unwind {
push    ebp
mov     ebp, esp
push    ebx
sub     esp, 14h
call    __x86_get_pc_thunk_bx
add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)
mov     eax, [ebp+arg_0]
mov     [ebp+var_C], al
cmp     [ebp+var_C], 3
jbe     short loc_8048503
cmp     [ebp+var_C], 8
ja      short loc_8048503
sub     esp, 0Ch
lea     eax, (aGood - 804A000h)[ebx] ; "good!"
push    eax             ; s
call    _puts
add     esp, 10h
sub     esp, 8
push    [ebp+src]       ; src
mov     eax, offset passwd_buf
push    eax             ; dest
call    _strcpy
add     esp, 10h
jmp     short loc_8048515

loc_8048503:
sub     esp, 0Ch
lea     eax, (aBad - 804A000h)[ebx] ; "bad!"
push    eax             ; s
call    _puts
add     esp, 10h

loc_8048515:
nop
mov     ebx, [ebp+var_4]
leave
retn
; } // starts at 80484B6
check endp



; Attributes: bp-based frame

public validate_passwd
validate_passwd proc near

s= byte ptr -3Bh
var_9= byte ptr -9
var_4= dword ptr -4

; __unwind {
push    ebp
mov     ebp, esp
push    ebx
sub     esp, 44h
call    __x86_get_pc_thunk_bx
add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)
sub     esp, 0Ch
lea     eax, [ebp+s]
push    eax             ; s
call    _gets
add     esp, 10h
sub     esp, 0Ch
lea     eax, [ebp+s]
push    eax             ; s
call    _strlen
add     esp, 10h
mov     [ebp+var_9], al
movzx   eax, [ebp+var_9]
sub     esp, 8
lea     edx, [ebp+s]
push    edx             ; src
push    eax             ; int
call    check
add     esp, 10h
nop
mov     ebx, [ebp+var_4]
leave
retn
; } // starts at 804851B
validate_passwd endp



; Attributes: bp-based frame fuzzy-sp

; int __cdecl main(int argc, const char **argv, const char **envp)
public main
main proc near

argc= dword ptr  8
argv= dword ptr  0Ch
envp= dword ptr  10h

; __unwind {
lea     ecx, [esp+4]
and     esp, 0FFFFFFF0h
push    dword ptr [ecx-4]
push    ebp
mov     ebp, esp
push    ebx
push    ecx
call    __x86_get_pc_thunk_bx
add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)
sub     esp, 0Ch
lea     eax, (aWelcomeToMocsc - 804A000h)[ebx] ; "##### Welcome to MOCSCTF #####"
push    eax             ; s
call    _puts
add     esp, 10h
sub     esp, 0Ch
lea     eax, (aPlzInputYourPa - 804A000h)[ebx] ; "Plz input your passwd:"
push    eax             ; s
call    _puts
add     esp, 10h
call    validate_passwd
mov     eax, 0
lea     esp, [ebp-8]
pop     ecx
pop     ebx
pop     ebp
lea     esp, [ecx-4]
retn
; } // starts at 8048568
main endp

align 10h



public __libc_csu_init
__libc_csu_init proc near

arg_0= dword ptr  4
arg_4= dword ptr  8
arg_8= dword ptr  0Ch

; __unwind {
push    ebp
push    edi
push    esi
push    ebx
call    __x86_get_pc_thunk_bx
add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)
sub     esp, 0Ch
mov     ebp, [esp+1Ch+arg_8]
lea     esi, (__do_global_dtors_aux_fini_array_entry - 804A000h)[ebx]
call    _init_proc
lea     eax, (__frame_dummy_init_array_entry - 804A000h)[ebx]
sub     esi, eax
sar     esi, 2
test    esi, esi
jz      short loc_8048615
xor     edi, edi
lea     esi, [esi+0]

loc_80485F8:
sub     esp, 4
push    ebp
push    [esp+24h+arg_4]
push    [esp+28h+arg_0]
call    ds:(__frame_dummy_init_array_entry - 804A000h)[ebx+edi*4]
add     edi, 1
add     esp, 10h
cmp     esi, edi
jnz     short loc_80485F8

loc_8048615:
add     esp, 0Ch
pop     ebx
pop     esi
pop     edi
pop     ebp
retn
; } // starts at 80485C0
__libc_csu_init endp

align 10h



public __libc_csu_fini
__libc_csu_fini proc near
; __unwind {
rep retn
; } // starts at 8048620
__libc_csu_fini endp

_text ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment mempage public 'CODE' use32
assume cs:LOAD
;org 8048622h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 4
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_fini segment dword public 'CODE' use32
assume cs:_fini
;org 8048624h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _term_proc
_term_proc proc near
push    ebx             ; _fini
sub     esp, 8
call    __x86_get_pc_thunk_bx
add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)
add     esp, 8
pop     ebx
retn
_term_proc endp

_fini ends


; Segment type: Pure data
; Segment permissions: Read
_rodata segment dword public 'CONST' use32
assume cs:_rodata
;org 8048638h
public _fp_hw
_fp_hw db    3
db    0
db    0
db    0
public _IO_stdin_used
_IO_stdin_used db    1
db    0
db    2
db    0
aGood db 'good!',0
aBad db 'bad!',0
align 4
aWelcomeToMocsc db '##### Welcome to MOCSCTF #####',0
aPlzInputYourPa db 'Plz input your passwd:',0
_rodata ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment mempage public 'CODE' use32
assume cs:LOAD
;org 8048682h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 4
LOAD ends


; Segment type: Pure data
; Segment permissions: Read
_eh_frame_hdr segment dword public 'CONST' use32
assume cs:_eh_frame_hdr
;org 8048684h
__GNU_EH_FRAME_HDR db    1
db  1Bh
db    3
db  3Bh ; ;
db  48h ; H
db    0
db    0
db    0
db    8
db    0
db    0
db    0
db 0ACh
db 0FCh
db 0FFh
db 0FFh
db  78h ; x
db    0
db    0
db    0
db  0Ch
db 0FDh
db 0FFh
db 0FFh
db  9Ch
db    0
db    0
db    0
db  5Ch ; \
db 0FDh
db 0FFh
db 0FFh
db  64h ; d
db    0
db    0
db    0
db  32h ; 2
db 0FEh
db 0FFh
db 0FFh
db 0B0h
db    0
db    0
db    0
db  97h
db 0FEh
db 0FFh
db 0FFh
db 0D4h
db    0
db    0
db    0
db 0E4h
db 0FEh
db 0FFh
db 0FFh
db 0F8h
db    0
db    0
db    0
db  3Ch ; <
db 0FFh
db 0FFh
db 0FFh
db  2Ch ; ,
db    1
db    0
db    0
db  9Ch
db 0FFh
db 0FFh
db 0FFh
db  78h ; x
db    1
db    0
db    0
_eh_frame_hdr ends


; Segment type: Pure data
; Segment permissions: Read
_eh_frame segment dword public 'CONST' use32
assume cs:_eh_frame
;org 80486D0h
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah ; z
db  52h ; R
db    0
db    1
db  7Ch ; |
db    8
db    1
db  1Bh
db  0Ch
db    4
db    4
db  88h
db    1
db    0
db    0
db  10h
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db 0F0h
db 0FCh
db 0FFh
db 0FFh
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  20h
db    0
db    0
db    0
db  30h ; 0
db    0
db    0
db    0
db  2Ch ; ,
db 0FCh
db 0FFh
db 0FFh
db  60h ; `
db    0
db    0
db    0
db    0
db  0Eh
db    8
db  46h ; F
db  0Eh
db  0Ch
db  4Ah ; J
db  0Fh
db  0Bh
db  74h ; t
db    4
db  78h ; x
db    0
db  3Fh ; ?
db  1Ah
db  3Bh ; ;
db  2Ah ; *
db  32h ; 2
db  24h ; $
db  22h ; "
db  10h
db    0
db    0
db    0
db  54h ; T
db    0
db    0
db    0
db  68h ; h
db 0FCh
db 0FFh
db 0FFh
db    8
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  20h
db    0
db    0
db    0
db  68h ; h
db    0
db    0
db    0
db  7Ah ; z
db 0FDh
db 0FFh
db 0FFh
db  65h ; e
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db    8
db  85h
db    2
db  42h ; B
db  0Dh
db    5
db  44h ; D
db  83h
db    3
db    2
db  5Dh ; ]
db 0C5h
db 0C3h
db  0Ch
db    4
db    4
db    0
db  20h
db    0
db    0
db    0
db  8Ch
db    0
db    0
db    0
db 0BBh
db 0FDh
db 0FFh
db 0FFh
db  4Dh ; M
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db    8
db  85h
db    2
db  42h ; B
db  0Dh
db    5
db  44h ; D
db  83h
db    3
db    2
db  45h ; E
db 0C5h
db 0C3h
db  0Ch
db    4
db    4
db    0
db  30h ; 0
db    0
db    0
db    0
db 0B0h
db    0
db    0
db    0
db 0E4h
db 0FDh
db 0FFh
db 0FFh
db  52h ; R
db    0
db    0
db    0
db    0
db  44h ; D
db  0Ch
db    1
db    0
db  47h ; G
db  10h
db    5
db    2
db  75h ; u
db    0
db  44h ; D
db  0Fh
db    3
db  75h ; u
db  78h ; x
db    6
db  10h
db    3
db    2
db  75h ; u
db  7Ch ; |
db  7Dh ; }
db 0C1h
db  0Ch
db    1
db    0
db  41h ; A
db 0C3h
db  41h ; A
db 0C5h
db  43h ; C
db  0Ch
db    4
db    4
db    0
db  48h ; H
db    0
db    0
db    0
db 0E4h
db    0
db    0
db    0
db    8
db 0FEh
db 0FFh
db 0FFh
db  5Dh ; ]
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db    8
db  85h
db    2
db  41h ; A
db  0Eh
db  0Ch
db  87h
db    3
db  41h ; A
db  0Eh
db  10h
db  86h
db    4
db  41h ; A
db  0Eh
db  14h
db  83h
db    5
db  4Eh ; N
db  0Eh
db  20h
db  69h ; i
db  0Eh
db  24h ; $
db  41h ; A
db  0Eh
db  28h ; (
db  44h ; D
db  0Eh
db  2Ch ; ,
db  44h ; D
db  0Eh
db  30h ; 0
db  4Dh ; M
db  0Eh
db  20h
db  47h ; G
db  0Eh
db  14h
db  41h ; A
db 0C3h
db  0Eh
db  10h
db  41h ; A
db 0C6h
db  0Eh
db  0Ch
db  41h ; A
db 0C7h
db  0Eh
db    8
db  41h ; A
db 0C5h
db  0Eh
db    4
db    0
db    0
db  10h
db    0
db    0
db    0
db  30h ; 0
db    1
db    0
db    0
db  1Ch
db 0FEh
db 0FFh
db 0FFh
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
__FRAME_END__ db    0
db    0
db    0
db    0
_eh_frame ends

; ELF Initialization Function Table

; Segment type: Pure data
; Segment permissions: Read/Write
_init_array segment dword public 'DATA' use32
assume cs:_init_array
;org 8049F0Ch
__frame_dummy_init_array_entry dd offset frame_dummy ; Alternative name is '__init_array_start'
_init_array ends

; ELF Termination Function Table

; Segment type: Pure data
; Segment permissions: Read/Write
_fini_array segment dword public 'DATA' use32
assume cs:_fini_array
;org 8049F10h
__do_global_dtors_aux_fini_array_entry dd offset __do_global_dtors_aux ; Alternative name is '__init_array_end'
_fini_array ends

; ELF Dynamic Information

; Segment type: Pure data
; Segment permissions: Read/Write
LOAD segment mempage public 'DATA' use32
assume cs:LOAD
;org 8049F14h
_DYNAMIC Elf32_Dyn <1, <1>> ; DT_NEEDED libc.so.6
Elf32_Dyn <0Ch, <804830Ch>> ; DT_INIT
Elf32_Dyn <0Dh, <8048624h>> ; DT_FINI
Elf32_Dyn <19h, <8049F0Ch>> ; DT_INIT_ARRAY
Elf32_Dyn <1Bh, <4>>    ; DT_INIT_ARRAYSZ
Elf32_Dyn <1Ah, <8049F10h>> ; DT_FINI_ARRAY
Elf32_Dyn <1Ch, <4>>    ; DT_FINI_ARRAYSZ
Elf32_Dyn <6FFFFEF5h, <80481ACh>> ; DT_GNU_HASH
Elf32_Dyn <5, <804824Ch>> ; DT_STRTAB
Elf32_Dyn <6, <80481CCh>> ; DT_SYMTAB
Elf32_Dyn <0Ah, <5Dh>>  ; DT_STRSZ
Elf32_Dyn <0Bh, <10h>>  ; DT_SYMENT
Elf32_Dyn <15h, <0>>    ; DT_DEBUG
Elf32_Dyn <3, <804A000h>> ; DT_PLTGOT
Elf32_Dyn <2, <28h>>    ; DT_PLTRELSZ
Elf32_Dyn <14h, <11h>>  ; DT_PLTREL
Elf32_Dyn <17h, <80482E4h>> ; DT_JMPREL
Elf32_Dyn <11h, <80482DCh>> ; DT_REL
Elf32_Dyn <12h, <8>>    ; DT_RELSZ
Elf32_Dyn <13h, <8>>    ; DT_RELENT
Elf32_Dyn <6FFFFFFEh, <80482BCh>> ; DT_VERNEED
Elf32_Dyn <6FFFFFFFh, <1>> ; DT_VERNEEDNUM
Elf32_Dyn <6FFFFFF0h, <80482AAh>> ; DT_VERSYM
Elf32_Dyn <0>           ; DT_NULL
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
LOAD ends


; Segment type: Pure data
; Segment permissions: Read/Write
_got segment dword public 'DATA' use32
assume cs:_got
;org 8049FFCh
__gmon_start___ptr dd offset __imp___gmon_start__
_got ends


; Segment type: Pure data
; Segment permissions: Read/Write
_got_plt segment dword public 'DATA' use32
assume cs:_got_plt
;org 804A000h
_GLOBAL_OFFSET_TABLE_ dd offset _DYNAMIC
dword_804A004 dd 0
dword_804A008 dd 0
off_804A00C dd offset gets
off_804A010 dd offset strcpy
off_804A014 dd offset puts
off_804A018 dd offset strlen
off_804A01C dd offset __libc_start_main
_got_plt ends


; Segment type: Pure data
; Segment permissions: Read/Write
_data segment dword public 'DATA' use32
assume cs:_data
;org 804A020h
public __data_start ; weak
__data_start db    0    ; Alternative name is '__data_start'
                        ; data_start
db    0
db    0
db    0
public __dso_handle
__dso_handle db    0
db    0
db    0
db    0
_data ends


; Segment type: Pure data
; Segment permissions: Read/Write
LOAD segment mempage public 'DATA' use32
assume cs:LOAD
;org 804A028h
public __bss_start
__bss_start db    ? ;   ; Alternative name is '_edata'
                        ; __TMC_END__
                        ; _edata
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
db    ? ;
LOAD ends


; Segment type: Uninitialized
; Segment permissions: Read/Write
_bss segment align_32 public 'BSS' use32
assume cs:_bss
;org 804A040h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
completed_7283 db ?
align 20h
public passwd_buf
; char passwd_buf[500]
passwd_buf db 1F4h dup(?)
_bss ends


; Segment type: Zero-length
_prgend segment byte public '' use32
_end label byte
_prgend ends


; Segment type: Externs
; extern
; char *gets(char *s)
extrn gets:near
; char *strcpy(char *dest, const char *src)
extrn strcpy:near
; int puts(const char *s)
extrn puts:near
; size_t strlen(const char *s)
extrn strlen:near
; int __cdecl _libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)
extrn __libc_start_main:near
extrn __imp___gmon_start__:near ; weak


end _start
