/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
int __cdecl j_strcpy(_DWORD, _DWORD); // weak
int __cdecl j_strnlen(_DWORD, _DWORD); // weak
int __cdecl j_memmove(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_rawmemchr(_DWORD, _DWORD); // weak
int __cdecl j_wcslen(_DWORD); // weak
int __cdecl j_strrchr(_DWORD, _DWORD); // weak
int __cdecl j_stpcpy(_DWORD, _DWORD); // weak
int __cdecl j_memchr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_strcasecmp_l(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_memset(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_strcmp(_DWORD, _DWORD); // weak
int __cdecl j_strcspn(_DWORD, _DWORD); // weak
int __cdecl j_strncasecmp_l(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_strchr(_DWORD, _DWORD); // weak
// int __usercall backtrace_and_maps@<eax>(int a1@<eax>, char a2@<dl>, int a3@<ecx>, long double a4@<st0>);
void __noreturn detach_arena_part_2(void); // weak
void __noreturn oom(void); // weak
// const char *__usercall fini@<eax>(long double a1@<st0>);
int init_cacheinfo();
// void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>);
void _x86_get_pc_thunk_bx();
int deregister_tm_clones();
int register_tm_clones();
// int (__usercall *__usercall _do_global_dtors_aux@<eax>(long double a1@<st0>))@<eax>(long double a1@<st0>, _DWORD *a2);
int frame_dummy();
void __cdecl get_flag(int a1, int a2);
int __cdecl main(int argc, const char **argv, const char **envp);
// void __usercall __noreturn generic_start_main(int (__cdecl *a1)(int, void **, int, char *)@<eax>, int a2@<edx>, void **a3@<ecx>, long double a4@<st0>, void (__cdecl *a5)(int, void **, int, int), void (__cdecl *a6)(void *), void (__cdecl *lpfunc)(void *), int a8);
// __int16 __usercall get_common_indeces_constprop_1@<ax>(unsigned int _EAX@<eax>, int *a2@<edx>, unsigned int *a3@<ecx>, unsigned int *a4);
int __cdecl _libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __usercall check_one_fd@<eax>(int a1@<eax>, int a2@<edx>);
int _libc_check_standard_fds();
// int __usercall _libc_setup_tls@<eax>(long double a1@<st0>, int a2, unsigned int a3);
int dl_tls_setup();
// int __usercall _pthread_initialize_minimal@<eax>(long double a1@<st0>);
void _libc_csu_init(void); // idb
void _libc_csu_fini(void); // idb
// void __usercall __noreturn _assert_fail_base(long double a1@<st0>, unsigned int a2, int a3, int a4, int a5, void *a6);
// void __usercall __noreturn _assert_fail(long double a1@<st0>, int a2, int a3, int a4, void *a5);
// unsigned int __usercall dcgettext@<eax>(long double a1@<st0>, char *a2, unsigned __int8 *a3, unsigned int a4);
// int __usercall plural_eval@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>);
// unsigned int __userpurge plural_lookup@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
int __cdecl transcmp(_DWORD *a1, _DWORD *a2);
// int __userpurge nl_find_msg@<eax>(int *a1@<eax>, int a2@<edx>, unsigned __int8 *a3@<ecx>, int a4, unsigned int *a5);
// unsigned int __usercall _dcigettext@<eax>(long double a1@<st0>, char *a2, unsigned __int8 *a3, char *a4, int a5, int a6, unsigned int a7);
// int *__userpurge nl_find_domain@<eax>(_BYTE *a1@<eax>, unsigned __int8 *a2@<edx>, _BYTE *a3@<ecx>, long double a4@<st0>, int a5);
// _DWORD *__usercall nl_load_domain@<eax>(int *a1@<eax>, int a2@<edx>);
int __cdecl alias_compare(_DWORD *a1, _DWORD *a2);
// int __usercall read_alias_file@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>, long double a3@<st0>);
// int __usercall nl_expand_alias@<eax>(long double a1@<st0>, int a2);
_DWORD *__cdecl nl_make_l10nflist(_DWORD *a1, _BYTE *a2, unsigned int a3, int a4, _BYTE *a5, _BYTE *a6, _BYTE *a7, _BYTE *a8, _BYTE *a9, _BYTE *a10, int a11);
unsigned __int8 *__cdecl nl_normalize_codeset(unsigned __int8 *a1, int a2);
int __cdecl nl_explode_name(unsigned __int8 *a1, unsigned __int8 **a2, _DWORD *a3, unsigned __int8 **a4, _DWORD *a5, unsigned __int8 **a6);
// _DWORD *__usercall _gettext_free_exp@<eax>(_DWORD *result@<eax>);
// _DWORD *__usercall new_exp@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
int __cdecl _gettextparse(char **a1);
// int __usercall _gettext_extract_plural@<eax>(int result@<eax>, _DWORD *a2@<edx>, int *a3@<ecx>);
unsigned int __cdecl _hash_string(unsigned __int8 *a1);
int setjmp(jmp_buf env);
// void __usercall __noreturn abort(long double a1@<st0>);
// _BYTE *__usercall msort_with_tmp_part_0@<eax>(unsigned int *a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>);
// unsigned int __usercall qsort_r@<eax>(long double a1@<st0>, char *a2, unsigned int a3, unsigned int a4, int (__cdecl *a5)(char *, char *, int), int a6);
// unsigned int __usercall qsort@<eax>(long double a1@<st0>, char *a2, unsigned int a3, unsigned int a4, int (__cdecl *a5)(char *, char *, int));
int __cdecl getenv(_BYTE *a1);
// void __usercall __noreturn _run_exit_handlers(long double a1@<st0>, int status, _DWORD **a3, char a4);
// void __usercall __noreturn exit(long double a1@<st0>, int status);
// _DWORD *__usercall _new_exitfn@<eax>(long double a1@<st0>, _DWORD *a2);
// int __usercall _internal_atexit@<eax>(long double a1@<st0>, int a2, int a3, int a4, _DWORD *a5);
int __cdecl _cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle);
int __cdecl _strtoul_internal(char *a1, char **a2, int a3, int a4);
int __cdecl strtoul(char *a1, char **a2, int a3);
int __cdecl ___strtoul_l_internal(char *a1, char **a2, int a3, int a4, int a5);
int __cdecl strtoul_l(char *a1, char **a2, int a3, int a4);
unsigned int __cdecl _correctly_grouped_prefixmb(unsigned int a1, unsigned int a2, _BYTE *a3, char *a4);
// int __usercall printf@<eax>(long double a1@<st0>, unsigned int a2, ...);
// int __usercall asprintf@<eax>(long double a1@<st0>, _DWORD *a2, unsigned int a3, ...);
// int __usercall _fxprintf@<eax>(long double a1@<st0>, int *a2, _BYTE *a3, long double a4, ...);
int __cdecl fclose(int *a1);
int __cdecl fflush(_DWORD *a1);
int __cdecl _fopen_maybe_mmap(int a1);
int __cdecl _fopen_internal(int a1, _BYTE *a2, int a3);
int __cdecl fopen(int a1, _BYTE *a2);
_BYTE *__cdecl gets(_BYTE *a1);
int __cdecl putchar(char a1);
// int __usercall adjust_wide_data@<eax>(_DWORD *a1@<eax>, unsigned __int8 a2@<dl>);
// int __usercall IO_wfile_underflow@<eax>(long double a1@<st0>, int *a2);
// __int64 __usercall IO_wfile_seekoff@<edx:eax>(long double a1@<st0>, int a2, __int64 a3, int a4, int a5);
// int __usercall IO_wfile_underflow_mmap@<eax>(long double a1@<st0>, _DWORD *a2);
// int __usercall IO_wfile_underflow_maybe_mmap@<eax>(long double a1@<st0>, unsigned int *a2);
int __cdecl IO_wdo_write(_DWORD *a1, int a2, int a3);
// int __usercall IO_wfile_overflow@<eax>(long double a1@<st0>, int *a2, int a3);
// int __usercall IO_wfile_sync@<eax>(long double a1@<st0>, _DWORD *a2);
unsigned int __cdecl IO_wfile_xsputn(_DWORD *a1, int *a2, unsigned int a3);
int __cdecl getc(int *a1);
// int __usercall vasprintf@<eax>(long double a1@<st0>, _DWORD *a2, unsigned int a3, char *a4);
int fcloseall(void); // weak
// unsigned int **__usercall _libc_message@<eax>(long double a1@<st0>, int a2, unsigned int *a3, ...);
// void __usercall __noreturn _libc_fatal(long double a1@<st0>, const char *a2, ...);
// int (__usercall *__usercall IO_vtable_check@<eax>(long double a1@<st0>))@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5, int a6);
_BYTE *__cdecl fgets_unlocked(_BYTE *a1, int a2, int *a3);
// int __usercall IO_file_seekoff_maybe_mmap@<eax>(long double a1@<st0>, _DWORD *a2, int a3, int a4, int a5);
unsigned int __fastcall IO_file_close(int a1);
// unsigned int *__usercall IO_new_file_setbuf@<eax>(long double a1@<st0>, unsigned int *a2, char *a3, int a4);
// unsigned int *__usercall IO_file_setbuf_mmap@<eax>(long double a1@<st0>, unsigned int *a2, char *a3, int a4);
// int __usercall new_do_write@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>);
// int __usercall IO_new_file_underflow@<eax>(long double a1@<st0>, int *a2);
// __int64 __usercall IO_new_file_seekoff@<edx:eax>(long double a1@<st0>, int a2, __int64 a3, int a4, int a5);
unsigned int __cdecl IO_file_close_mmap(int a1);
// int __usercall mmap_remap_check@<eax>(_DWORD *a1@<eax>, long double a2@<st0>);
__int64 __cdecl IO_file_seek(int a1, int a2, int a3);
int __cdecl IO_file_sync_mmap(int a1);
// unsigned int __usercall decide_maybe_mmap@<eax>(unsigned int *a1@<eax>, long double a2@<st0>);
// int __usercall IO_file_underflow_maybe_mmap@<eax>(long double a1@<st0>, unsigned int *a2);
// int __usercall IO_file_xsgetn_maybe_mmap@<eax>(long double a1@<st0>, unsigned int *a2, int a3, int a4);
unsigned int __cdecl IO_file_stat(int a1, int a2);
int __cdecl IO_new_file_write(int a1, int a2, int a3);
// int __usercall IO_file_xsgetn_mmap@<eax>(long double a1@<st0>, _DWORD *a2, _BYTE *a3, unsigned int a4);
// unsigned int __usercall IO_file_xsgetn@<eax>(long double a1@<st0>, int a2, _BYTE *a3, unsigned int a4);
// int __usercall IO_file_seekoff_mmap@<eax>(long double a1@<st0>, _DWORD *a2, __int64 a3, int a4, int a5);
// int __usercall IO_file_underflow_mmap@<eax>(long double a1@<st0>, _DWORD *a2);
unsigned int __cdecl IO_file_read(int a1, int a2, int a3);
// int __usercall IO_new_file_xsputn@<eax>(long double a1@<st0>, _DWORD *a2, _BYTE *a3, unsigned int a4);
int __cdecl IO_new_file_init_internal(int *a1);
int __cdecl IO_new_file_init(int *a1);
int __cdecl IO_file_open(int a1, int a2, int a3, int a4, __int16 a5, int a6);
// unsigned int *__usercall IO_new_file_attach@<eax>(long double a1@<st0>, unsigned int *a2, unsigned int a3);
int __cdecl IO_new_do_write(int a1, unsigned int a2, int a3);
int __cdecl IO_new_file_close_it(int a1);
int __cdecl IO_new_file_fopen(_DWORD *a1, int a2, _BYTE *a3, int a4);
// _DWORD *__usercall IO_new_file_finish@<eax>(long double a1@<st0>, int *a2);
// int __usercall IO_new_file_overflow@<eax>(long double a1@<st0>, int *a2, int a3);
// int __usercall IO_new_file_sync@<eax>(long double a1@<st0>, _DWORD *a2);
// int __usercall save_for_backup@<eax>(_DWORD *a1@<eax>, int a2@<edx>);
int flush_cleanup();
// int __usercall IO_un_link_part_2@<eax>(int *a1@<eax>);
int __cdecl IO_un_link(int *a1);
int __cdecl IO_link_in(int *a1);
int __cdecl IO_least_marker(int a1, int a2);
_DWORD *__cdecl IO_switch_to_main_get_area(_DWORD *a1);
_DWORD *__cdecl IO_switch_to_backup_area(_DWORD *a1);
int __cdecl IO_switch_to_get_mode(int *a1);
int __cdecl IO_free_backup_area(int *a1);
int __cdecl _overflow(int a1, int a2);
int __cdecl _underflow(int *a1);
int __cdecl _uflow(int *a1);
unsigned int __cdecl IO_setb(unsigned int *a1, unsigned int a2, unsigned int a3, int a4);
// void __usercall IO_doallocbuf(long double a1@<st0>, int *a2);
int IO_default_underflow();
// int __usercall IO_default_uflow@<eax>(long double a1@<st0>, int a2);
// unsigned int __usercall IO_default_xsputn@<eax>(long double a1@<st0>, _DWORD *a2, unsigned __int8 *a3, unsigned int a4);
int __cdecl IO_sgetn(int a1, int a2, int a3);
unsigned int __cdecl IO_default_xsgetn(int *a1, _BYTE *a2, unsigned int a3);
// unsigned int *__usercall IO_default_setbuf@<eax>(long double a1@<st0>, unsigned int *a2, char *a3, int a4);
// int __usercall IO_default_seekpos@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5);
// int __usercall IO_default_doallocate@<eax>(long double a1@<st0>, unsigned int *a2);
int __cdecl IO_init(int a1, int a2);
_DWORD *__cdecl IO_old_init(int a1, int a2);
int __cdecl IO_no_init(int a1, int a2, int a3, _DWORD *a4, int a5);
int IO_default_sync();
// _DWORD *__usercall IO_default_finish@<eax>(long double a1@<st0>, int *a2);
__int64 IO_default_seekoff();
int __cdecl IO_sputbackc(_DWORD *a1, int a2);
// int __usercall IO_sungetc@<eax>(long double a1@<st0>, _DWORD *a2);
int __cdecl IO_adjust_column(int a1, unsigned int a2, int a3);
// int __usercall IO_flush_all_lockp@<eax>(long double a1@<st0>, int a2);
// int __usercall IO_cleanup@<eax>(long double a1@<st0>);
int IO_flush_all();
// int __usercall flushlbf@<eax>(long double a1@<st0>);
int __cdecl IO_init_marker(int *a1, int *a2);
_DWORD *__cdecl IO_remove_marker(_DWORD *a1);
int __cdecl IO_marker_difference(int a1, int a2);
int __cdecl IO_marker_delta(int a1);
int __cdecl IO_seekmark(int *a1, int a2);
int __cdecl IO_unsave_markers(int *a1);
// int __usercall IO_default_pbackfail@<eax>(long double a1@<st0>, int *a2, int a3);
__int64 IO_default_seek();
int IO_default_stat();
int IO_default_read();
int IO_default_write();
int IO_default_showmanyc();
int *IO_iter_begin();
int IO_iter_end();
int __cdecl IO_iter_next(int a1);
int __cdecl IO_iter_file(int a1);
void IO_list_lock();
int IO_list_unlock();
void IO_list_resetlock();
int __cdecl IO_str_underflow(int *a1);
int __cdecl IO_str_overflow(int a1, int a2);
// int __usercall enlarge_userbuf@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, long double a4@<st0>, int a5);
// int __usercall IO_str_seekoff@<eax>(long double a1@<st0>, int *a2, __int64 a3, int a4, int a5);
// int __usercall IO_str_pbackfail@<eax>(long double a1@<st0>, int *a2, int a3);
// _DWORD *__usercall IO_str_finish@<eax>(long double a1@<st0>, int a2);
unsigned int __cdecl IO_str_init_static_internal(unsigned int *a1, unsigned int a2, int a3, unsigned int a4);
unsigned int __cdecl IO_str_init_static(unsigned int *a1, unsigned int a2, int a3, unsigned int a4);
unsigned int __cdecl IO_str_init_readonly(unsigned int *a1, unsigned int a2, int a3);
unsigned int __cdecl IO_str_count(_DWORD *a1);
// int *__usercall malloc_init_state@<eax>(int *result@<eax>);
// int __usercall mem2mem_check@<eax>(int result@<eax>, unsigned int a2@<edx>);
// unsigned int __usercall mem2chunk_check@<eax>(int a1@<eax>, char **a2@<edx>);
// void __usercall __noreturn _malloc_assert(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, long double a4@<st0>, void *a5);
// int __usercall new_heap@<eax>(unsigned int a1@<eax>, int a2@<edx>);
// int *__usercall mremap_chunk@<eax>(int *result@<eax>, int a2@<edx>);
// int __usercall systrim_isra_0@<eax>(unsigned int a1@<eax>, int *a2@<edx>, _DWORD *a3@<ecx>);
unsigned int get_free_list();
// int __usercall malloc_printerr@<eax>(char a1@<al>, const char *a2@<edx>, unsigned int a3@<ecx>, int a4);
int top_check();
// int *__usercall malloc_consolidate@<eax>(int *a1@<eax>);
// unsigned int __usercall int_mallinfo@<eax>(int *a1@<eax>, _DWORD *a2@<edx>);
// _DWORD *__usercall munmap_chunk@<eax>(_DWORD *result@<eax>, long double a2@<st0>);
// int __usercall int_free@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>);
// int __usercall sysmalloc@<eax>(unsigned int a1@<eax>, int *a2@<edx>);
// int __usercall int_malloc@<eax>(int *a1@<eax>, unsigned int a2@<edx>);
// _DWORD *__usercall int_memalign@<eax>(int *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>);
int __cdecl malloc_check(unsigned int a1);
int __cdecl memalign_check(unsigned int a1, unsigned int a2);
void __cdecl free_check(unsigned int a1);
// unsigned int __usercall int_realloc@<eax>(int *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, unsigned int a4);
int __cdecl realloc_check(_BYTE *a1, unsigned int a2);
// int *__usercall arena_get2_part_4@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>);
// int *__usercall arena_get_retry@<eax>(int *a1@<eax>);
__int32 _malloc_fork_lock_parent();
int _malloc_fork_unlock_parent();
int *_malloc_fork_unlock_child();
int _malloc_check_init();
int __cdecl malloc_set_state(_DWORD *a1);
// int __usercall malloc@<eax>(long double a1@<st0>, unsigned int a2);
// _DWORD *__usercall malloc_get_state@<eax>(long double a1@<st0>);
// int __usercall mid_memalign@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>);
// _DWORD *__usercall free@<eax>(long double a1@<st0>, int a2);
int __cdecl realloc(_BYTE *a1, unsigned int a2);
int __cdecl memalign(unsigned int a1, unsigned int a2);
int __cdecl calloc(unsigned int a1, unsigned int a2);
int __cdecl malloc_usable_size(unsigned int a1);
int __cdecl mallopt(int a1, int a2);
int ptmalloc_init_part_7();
int __cdecl malloc_hook_ini(int a1);
int __cdecl realloc_hook_ini(int a1, int a2);
int __cdecl memalign_hook_ini(int a1, int a2);
int __cdecl valloc(unsigned int a1);
int __cdecl pvalloc(unsigned int a1);
// int __usercall malloc_trim@<eax>(long double a1@<st0>, unsigned int a2);
_DWORD *__stdcall mallinfo(_DWORD *a1);
// int *__usercall malloc_stats@<eax>(long double a1@<st0>);
// int __usercall _malloc_info_part_9@<eax>(_DWORD *a1@<eax>, long double a2@<st0>);
int __cdecl posix_memalign(int *a1, unsigned int a2, unsigned int a3);
// int __usercall malloc_info@<eax>(long double a1@<st0>, int a2, _DWORD *a3);
int __cdecl _default_morecore(int a1);
const __m128i *(__cdecl *strchr())(const __m128i *a1, unsigned int a2);
unsigned int *__cdecl _strchr_ia32(unsigned int *a1, int a2);
int (__cdecl *strcmp())(const __m128i *a1, const __m128i *a2);
int __cdecl _strcmp_ia32(char *a1, _BYTE *a2);
unsigned int (__cdecl *strcpy())(unsigned int a1, unsigned int a2);
void __cdecl _strcpy_ia32(int a1, char a2);
_BYTE *(__cdecl *strcspn())(int a1, __m128i *a2);
_BYTE *__cdecl _strcspn_ia32(int a1, _BYTE *a2);
_BYTE *__cdecl strdup(_BYTE *a1);
int __cdecl strlen(_BYTE *a1);
// unsigned int __usercall critical_factorization@<eax>(int a1@<eax>, unsigned int a2@<edx>, int *a3@<ecx>);
// int __usercall two_way_long_needle@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, unsigned int a4);
int __cdecl strstr(char *a1, char *a2);
int (__cdecl *memchr())(const __m128i *a1, unsigned int a2, unsigned int a3);
_BYTE *__cdecl _memchr_ia32(_BYTE *a1, int a2, unsigned int a3);
int (__cdecl *memcmp())(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl _memcmp_ia32(unsigned int *a1, unsigned int *a2, int a3);
unsigned int (__usercall *memmove())@<eax>(const __m128i *a1@<esi>, unsigned int a2, _DWORD *a3, unsigned int a4);
_BYTE *__cdecl _memmove_ia32(_BYTE *a1, _BYTE *a2, unsigned int a3);
int (__cdecl *memset())(int a1, unsigned __int8 a2, unsigned int a3);
unsigned __int8 *__cdecl _memset_ia32(unsigned __int8 *a1, unsigned __int8 a2, unsigned int a3);
_WORD *__cdecl mempcpy(_BYTE *a1, _BYTE *a2, unsigned int a3);
unsigned int (__cdecl *stpcpy())(unsigned int a1, unsigned int a2);
void __cdecl _stpcpy_ia32(int a1, char a2);
int (__cdecl *strcasecmp_l())(char *a1, unsigned __int8 *a2, int a3);
_BYTE *__cdecl memcpy(_BYTE *a1, _BYTE *a2, unsigned int a3);
int (__cdecl *rawmemchr())(const __m128i *a1, unsigned int a2);
_BYTE *__cdecl _rawmemchr_ia32(_BYTE *a1, int a2);
unsigned int *__cdecl strchrnul(unsigned int *a1, int a2);
int __cdecl _memset_sse2(int a1, unsigned __int8 a2, unsigned int a3);
// __m128i *__usercall _memmove_chk_ssse3@<eax>(const __m128i *a1@<edi>, long double fst7_0@<st0>, __m128i *a2, __m128i *a3, unsigned int a4, unsigned int a6);
// __m128i *__usercall _memmove_ssse3@<eax>(const __m128i *a1@<edi>, __m128i *a2, __m128i *a3, unsigned int a4);
// unsigned int __usercall _memmove_chk_ssse3_rep@<eax>(const __m128i *a1@<esi>, long double fst7_0@<st0>, unsigned int a2, _DWORD *a3, unsigned int a4, unsigned int a6);
// unsigned int __usercall _memmove_ssse3_rep@<eax>(const __m128i *a1@<esi>, unsigned int a2, _DWORD *a3, unsigned int a4);
int __cdecl _memset_sse2_rep(int a1, unsigned __int8 a2, unsigned int a3);
int __cdecl _strcmp_ssse3(int a1, int a2);
int __cdecl _strcmp_sse4_2(const __m128i *a1, const __m128i *a2);
int __cdecl strncmp(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl _memcmp_ssse3(const __m128i *a1, const __m128i *a2, unsigned int a3);
int __cdecl _memcmp_sse4_2(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
unsigned int __cdecl _strcpy_ssse3(unsigned int a1, unsigned int a2);
unsigned int __cdecl _stpcpy_ssse3(unsigned int a1, unsigned int a2);
int __cdecl _strcpy_sse2(int a1, unsigned int a2);
char *__cdecl _stpcpy_sse2(int a1, unsigned int a2);
const __m128i *__cdecl _strchr_sse2(const __m128i *a1, unsigned int a2);
char *__cdecl _strchr_sse2_bsf(const __m128i *a1, unsigned int a2);
const __m128i *__cdecl _memchr_sse2(const __m128i *a1, unsigned int a2, unsigned int a3);
int __cdecl _memchr_sse2_bsf(const __m128i *a1, unsigned int a2, unsigned int a3);
const __m128i *__cdecl _rawmemchr_sse2(const __m128i *a1, unsigned int a2);
int __cdecl _rawmemchr_sse2_bsf(const __m128i *a1, unsigned int a2);
int __cdecl _strcasecmp_l_nonascii(char *a1, unsigned __int8 *a2, int a3);
int __cdecl _strcasecmp_ssse3(char *a1, unsigned __int8 *a2);
int __cdecl _strcasecmp_l_ssse3(char *a1, unsigned __int8 *a2, int a3);
int __cdecl _strcasecmp_sse4_2(char *a1, unsigned __int8 *a2);
int __cdecl _strcasecmp_l_sse4_2(char *a1, unsigned __int8 *a2, int a3);
// __m128i *__usercall _memmove_chk_sse2_unaligned@<eax>(int a1@<ebx>, long double fst7_0@<st0>, __m128i *a2, const __m128i *a3, unsigned int a4, unsigned int a6);
// __m128i *__usercall _memmove_sse2_unaligned@<eax>(int a1@<ebx>, __m128i *a2, const __m128i *a3, unsigned int a4);
_BYTE *__cdecl _strcspn_sse42(int a1, __m128i *a2);
// int __usercall intel_check_word@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, _BYTE *a4);
// int __usercall handle_intel@<eax>(int a1@<eax>, unsigned int a2@<edx>);
// int __usercall handle_amd@<eax>(int a1@<eax>);
int __cdecl _cache_sysconf(int a1);
_WORD *__cdecl wmempcpy(_BYTE *a1, _BYTE *a2, int a3);
// int __usercall nl_cleanup_ctype@<eax>(int result@<eax>);
int __cdecl _wcsmbs_getfct(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int *a3);
// int __usercall _wcsmbs_load_conv@<eax>(_DWORD *a1@<eax>);
// _DWORD *__usercall _wcsmbs_clone_conv@<eax>(void **a1@<eax>);
// int __usercall _wcsmbs_named_conv@<eax>(int *a1@<eax>, int a2@<edx>);
void exit(int status);
// int __usercall _sysconf_check_spec@<eax>(_BYTE *a1@<eax>);
// int __usercall sysconf@<eax>(char *a1@<ecx>, long double a2@<st0>, int a3);
unsigned int __fastcall sched_yield(int a1);
int _get_child_max();
unsigned int __cdecl _xstat64(int a1, int a2, int a3);
unsigned int __cdecl _fxstat64(int a1, int a2, int a3);
int __cdecl open(int a1, int a2, int a3);
unsigned int __cdecl _open_nocancel(int a1, int a2);
int __cdecl read(int a1, int a2, int a3);
unsigned int __cdecl _read_nocancel(int a1, int a2);
int __cdecl write(int a1, int a2, int a3);
unsigned int __cdecl _write_nocancel(int a1, int a2);
unsigned int __cdecl _fcntl_nocancel(int a1, int a2);
int __cdecl fcntl(int a1, int a2);
_BYTE *__cdecl getcwd(_BYTE *a1, unsigned int a2);
unsigned int __cdecl getrlimit(int a1, int a2);
int __cdecl sbrk(int a1);
int getpagesize();
int getdtablesize();
unsigned int __cdecl mmap(int a1, int a2, int a3, int a4, int a5, __int16 a6);
unsigned int __cdecl mmap64(int a1, int a2, int a3, int a4, int a5, __int64 a6);
unsigned int __cdecl munmap(int a1, int a2);
unsigned int __cdecl mprotect(int a1, int a2);
unsigned int __cdecl madvise(int a1, int a2);
// int __usercall trecurse@<eax>(int a1@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3@<ecx>);
// _DWORD *__usercall tdestroy_recurse@<eax>(_DWORD *a1@<eax>, long double (__cdecl *a2)(_DWORD)@<edx>, int a3@<ecx>);
// int __usercall maybe_split_for_insert_isra_0@<eax>(int result@<eax>, int *a2@<edx>, int *a3@<ecx>, int a4, int a5, int a6);
int __cdecl tsearch(int a1, int *a2, int (__cdecl *a3)(int, _DWORD));
_DWORD *__cdecl tfind(int a1, _DWORD *a2, int (__cdecl *a3)(int, _DWORD));
// _BYTE *__usercall tdelete@<eax>(long double a1@<st0>, int a2, int *a3, int (__cdecl *a4)(int, _DWORD));
int __cdecl twalk(int a1, int (__cdecl *a2)(int, int, int));
_DWORD *__cdecl tdestroy(_DWORD *a1, long double (__cdecl *a2)(_DWORD));
// unsigned int __usercall next_line@<eax>(unsigned int a1@<edx>, unsigned int *a2@<ecx>, long double a3@<st0>, int *a4, int a5);
// unsigned int __usercall sysinfo_mempages@<eax>(int a1@<eax>, unsigned int a2@<edx>);
// int __usercall get_nprocs@<eax>(int a1@<ecx>, long double a2@<st0>);
int get_nprocs_conf();
unsigned int __fastcall get_phys_pages(int a1);
unsigned int __fastcall get_avphys_pages(int a1);
int _getclktck();
void __cdecl _init_misc(int a1, void **a2);
__int64 __cdecl lseek64(int a1, int a2, int a3);
unsigned int __cdecl mremap(int a1, int a2);
unsigned int __fastcall sysinfo(int a1);
_BOOL4 __cdecl _libc_alloca_cutoff(unsigned int a1);
// __int32 __usercall _lll_lock_wait_private@<eax>(int a1@<eax>, volatile __int32 *a2@<ecx>);
// int __usercall _lll_unlock_wake_private@<eax>(_DWORD *a1@<eax>);
int _libc_enable_asynccancel();
// unsigned int __usercall _libc_disable_asynccancel@<eax>(unsigned int result@<eax>);
int __cdecl backtrace_helper(int a1, _DWORD *a2);
// int __usercall backtrace@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl backtrace_symbols_fd(int a1, int a2, int a3);
// void __usercall __noreturn _chk_fail(long double a1@<st0>);
// void __usercall __noreturn _fortify_fail(const char *a1@<eax>, long double a2@<st0>);
int dl_debug_state(void); // weak
// _DWORD *__usercall dl_debug_initialize@<eax>(int a1@<eax>, int a2@<edx>);
void dl_sysinfo_int80();
// int __usercall dl_aux_init@<eax>(int result@<eax>);
// int __usercall dl_non_dynamic_init@<eax>(long double a1@<st0>);
// int __userpurge dl_addr@<eax>(unsigned int a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
// int __usercall dl_addr_inside_object@<eax>(int a1@<eax>, int a2@<edx>);
int __fastcall _libc_init_secure(int a1);
int __fastcall dl_discover_osversion(int a1);
// unsigned int __usercall _libc_init_first@<eax>(int a1@<ecx>, long double a2@<st0>, int a3, void **a4, int a5);
// void __usercall __noreturn dl_start(long double a1@<st0>);
// int __usercall _syscall_error@<eax>(int a1@<eax>);
// int __userpurge _gconv_open@<eax>(_BYTE *a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int a4);
// int __userpurge _gconv@<eax>(int *a1@<eax>, int *a2@<edx>, unsigned int a3@<ecx>, int *a4, int a5, _DWORD *a6);
// int __usercall _gconv_close@<eax>(int *a1@<eax>, long double a2@<st0>);
int __cdecl _gconv_alias_compare(_DWORD *a1, _DWORD *a2);
int __cdecl derivation_compare(_DWORD *a1, _DWORD *a2);
int _gconv_get_modules_db();
int _gconv_get_alias_db();
// int __usercall _gconv_release_step@<eax>(int *a1@<eax>);
// int __userpurge find_derivation@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, _BYTE *a4, _DWORD *a5, unsigned int *a6);
// int __usercall _gconv_compare_alias@<eax>(unsigned __int8 *a1@<eax>, unsigned __int8 *a2@<edx>);
// int __userpurge _gconv_find_transform@<eax>(unsigned __int8 *a1@<eax>, unsigned __int8 *a2@<edx>, _DWORD *a3@<ecx>, int *a4, char a5);
// int __usercall _gconv_close_transform@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall insert_module@<eax>(int result@<eax>, int a2@<edx>);
// int __userpurge add_module@<eax>(char *a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>, int a4, int a5, int a6);
// int __usercall detect_conflict@<eax>(int a1@<eax>);
// int __usercall add_alias2_isra_0_part_1@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>);
__int32 _gconv_get_path();
int _gconv_read_conf();
// int __usercall _gconv_get_builtin_trans@<eax>(int a1@<eax>, _DWORD *a2@<edx>);
int __cdecl _gconv_btwoc_ascii(int a1, char a2);
// int __usercall _gconv_transform_internal_ucs4@<eax>(long double a1@<st0>, int a2, int a3, unsigned int *a4, unsigned int a5, unsigned int *a6, int a7, int a8, int a9);
// int __usercall _gconv_transform_ucs4_internal@<eax>(long double a1@<st0>, int a2, int a3, unsigned int **a4, unsigned int *a5, int **a6, _DWORD *a7, int a8, int a9);
// int __usercall _gconv_transform_internal_ucs4le@<eax>(long double a1@<st0>, int a2, int a3, _DWORD *a4, _BYTE *a5, char **a6, int a7, int a8, int a9);
// int __usercall _gconv_transform_ucs4le_internal@<eax>(long double a1@<st0>, int a2, int a3, unsigned int *a4, unsigned int a5, _BYTE **a6, _DWORD *a7, int a8, int a9);
// int __usercall _gconv_transform_ascii_internal@<eax>(long double a1@<st0>, int a2, unsigned int *a3, int *a4, int a5, unsigned int *a6, _DWORD *a7, int a8, int a9);
// int __usercall _gconv_transform_internal_ascii@<eax>(long double a1@<st0>, _DWORD *a2, unsigned int **a3, int *a4, unsigned int *a5, unsigned int **a6, _DWORD *a7, int a8, int a9);
// int __usercall _gconv_transform_internal_utf8@<eax>(long double a1@<st0>, _DWORD *a2, unsigned int **a3, int *a4, unsigned int *a5, unsigned int **a6, _DWORD *a7, int a8, int a9);
// int __usercall _gconv_transform_utf8_internal@<eax>(long double a1@<st0>, int a2, int a3, unsigned int *a4, unsigned int a5, unsigned int **a6, _DWORD *a7, int a8, int a9);
// int __usercall _gconv_transform_ucs2_internal@<eax>(long double a1@<st0>, int a2, int a3, unsigned int *a4, unsigned int a5, char **a6, _DWORD *a7, int a8, int a9);
// int __usercall _gconv_transform_internal_ucs2@<eax>(long double a1@<st0>, _DWORD *a2, unsigned int **a3, int *a4, unsigned int a5, unsigned int **a6, _DWORD *a7, int a8, int a9);
// int __usercall _gconv_transform_ucs2reverse_internal@<eax>(long double a1@<st0>, int a2, int a3, unsigned int *a4, unsigned int a5, char **a6, _DWORD *a7, int a8, int a9);
// int __usercall _gconv_transform_internal_ucs2reverse@<eax>(long double a1@<st0>, _DWORD *a2, unsigned int **a3, int *a4, unsigned int a5, unsigned int **a6, _DWORD *a7, int a8, int a9);
int __cdecl _gconv_transliterate(_DWORD *a1, int a2, int a3, unsigned int **a4, unsigned int a5, int *a6, _DWORD *a7);
// int __usercall find_module_idx@<eax>(unsigned __int8 *a1@<eax>, _DWORD *a2@<edx>);
// int __usercall find_module@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, int **a3@<ecx>);
int _gconv_get_cache();
int _gconv_load_cache();
// int __usercall _gconv_compare_alias_cache@<eax>(unsigned __int8 *a1@<eax>, unsigned __int8 *a2@<edx>, _DWORD *a3@<ecx>);
// int __userpurge _gconv_lookup_cache@<eax>(unsigned __int8 *a1@<eax>, unsigned __int8 *a2@<edx>, _DWORD *a3@<ecx>, int *a4, char a5);
// int __usercall _gconv_release_cache@<eax>(int result@<eax>);
int __cdecl known_compare(_DWORD *a1, _DWORD *a2);
// int __usercall do_release_shlib@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int *a4, int a5);
// int *__usercall _gconv_find_shlib@<eax>(_BYTE *a1@<eax>, int a2@<ebp>, unsigned int a3@<esi>);
// int __usercall _gconv_release_shlib@<eax>(int a1@<eax>);
// _BYTE *__usercall new_composite_name@<eax>(int a1@<eax>, _DWORD *a2@<edx>, long double a3@<st0>);
// int __usercall setlocale@<eax>(long double a1@<st0>, unsigned int a2, _BYTE *a3);
// _BYTE *__usercall strip@<eax>(_BYTE *a1@<eax>, char *a2@<edx>, int a3@<ebx>);
// void **__userpurge nl_find_locale@<eax>(char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, long double a4@<st0>, char *a5);
// _DWORD *__usercall nl_remove_locale@<eax>(_DWORD *result@<eax>, int *a2@<edx>, long double a3@<st0>);
// _DWORD *__usercall nl_intern_locale_data@<eax>(int a1@<eax>, _DWORD *a2@<edx>, unsigned int a3@<ecx>, long double a4@<st0>);
// _DWORD *__usercall nl_load_locale@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>);
// _DWORD *__usercall nl_unload_locale@<eax>(int *a1@<eax>, long double a2@<st0>);
int __cdecl rangecmp(_DWORD *a1, _DWORD *a2);
// int __usercall nl_load_locale_from_archive@<eax>(int a1@<eax>, _DWORD *a2@<edx>, char *a3@<ecx>, long double a4@<st0>);
char *nl_postload_ctype();
int __cdecl _current_locale_name(int a1);
unsigned int _ctype_b_loc();
unsigned int _ctype_toupper_loc();
unsigned int _ctype_tolower_loc();
unsigned int _ctype_init();
unsigned int __cdecl _setfpucw(unsigned int a1);
int raise();
int _restore_rt(); // weak
int __cdecl _libc_sigaction(int a1, int *a2, _DWORD *a3);
int __cdecl sigaction(int a1, int *a2, _DWORD *a3);
unsigned int __cdecl sigprocmask(int a1, _BYTE *a2);
unsigned int __cdecl quicksort(char *a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(char *, char *, int), int a5);
// int __usercall _add_to_environ@<eax>(long double a1@<st0>, unsigned __int8 *a2, _BYTE *a3, int a4, int a5);
// int __usercall setenv@<eax>(long double a1@<st0>, unsigned __int8 *a2, _BYTE *a3, int a4);
int __cdecl unsetenv(unsigned __int8 *a1);
// int __usercall clearenv@<eax>(long double a1@<st0>);
int __cdecl secure_getenv(_BYTE *a1);
int __cdecl _strtol_internal(char *a1, char **a2, int a3, int a4);
int __cdecl strtol(char *a1, char **a2, int a3);
int __cdecl ___strtol_l_internal(char *a1, char **a2, int a3, int a4, int a5);
int __cdecl strtol_l(char *a1, char **a2, int a3, int a4);
char *__cdecl itoa_word(unsigned int a1, char *a2, unsigned int a3, int a4);
_BYTE *__cdecl itoa(unsigned __int64 a1, _BYTE *a2, unsigned int a3, int a4);
char *__cdecl fitoa_word(unsigned int a1, _BYTE *a2, unsigned int a3, int a4);
char *__cdecl fitoa(unsigned __int64 a1, _BYTE *a2, unsigned int a3, int a4);
// int __usercall read_int@<eax>(_DWORD *a1@<eax>);
// int __userpurge group_number@<eax>(_BYTE *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, _BYTE *a4);
// _BYTE *__usercall i18n_number_rewrite@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall IO_helper_overflow@<eax>(long double a1@<st0>, _DWORD *a2, unsigned __int8 a3);
// int __usercall printf_positional@<eax>(_DWORD *a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>, long double a4@<st0>, int a5, long double **a6, int a7, unsigned int a8, unsigned __int8 *a9, _BYTE *a10, signed int a11, _BYTE *a12, _BYTE *a13);
// int __usercall vfprintf@<eax>(long double a1@<st0>, int a2, unsigned int a3, char *a4);
// int __usercall buffered_vfprintf@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall hack_digit@<eax>(int a1@<eax>);
// _BYTE *__usercall i18n_number_rewrite_0@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall _guess_grouping_part_0@<eax>(unsigned int a1@<eax>, unsigned __int8 *a2@<edx>);
int __cdecl _printf_fp_l(_DWORD *a1, _DWORD *a2, int a3, long double **a4);
int __cdecl _printf_fp(_DWORD *a1, int a2, long double **a3);
int __cdecl _guess_grouping(unsigned int a1, unsigned __int8 *a2);
int __cdecl register_printf_specifier(unsigned int a1, int a2, int a3);
int __cdecl _printf_fphex(_DWORD *a1, int a2, double **a3);
// int __usercall register_printf_modifier@<eax>(long double a1@<st0>, char *a2);
int __cdecl _handle_registered_modifier_mb(unsigned __int8 **a1, int a2);
int __cdecl _handle_registered_modifier_wc(_DWORD *a1, int a2);
int __cdecl register_printf_type(int a1);
// int __usercall fprintf@<eax>(long double a1@<st0>, int a2, unsigned int a3, ...);
// int __usercall read_int_0@<eax>(_DWORD *a1@<eax>);
// _BYTE *__userpurge group_number_0@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>, char *a3@<ecx>, int a4);
// _BYTE *__usercall i18n_number_rewrite_1@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall IO_helper_overflow_0@<eax>(long double a1@<st0>, _DWORD *a2, int a3);
// int __usercall printf_positional_0@<eax>(_DWORD *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, long double a4@<st0>, int a5, long double **a6, unsigned int a7, unsigned int a8, _DWORD *a9, _BYTE *a10, signed int a11, char *a12, int a13);
// int __usercall vfwprintf@<eax>(long double a1@<st0>, int a2, int *a3, long double *a4);
// int __usercall buffered_vfprintf_0@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>);
int __cdecl funlockfile(int a1);
// int __usercall read_int_1@<eax>(_DWORD *a1@<eax>);
int __cdecl _parse_one_specmb(unsigned __int8 *a1, int a2, int a3, unsigned int *a4);
// int __usercall read_int_2@<eax>(_DWORD *a1@<eax>);
int __cdecl _parse_one_specwc(_DWORD *a1, int a2, int a3, unsigned int *a4);
// int __usercall IO_file_doallocate@<eax>(long double a1@<st0>, unsigned int *a2);
// int __usercall fputs@<eax>(long double a1@<st0>, _BYTE *a2, _DWORD *a3);
// int __usercall IO_wfile_doallocate@<eax>(long double a1@<st0>, unsigned int *a2);
// int __usercall fwrite@<eax>(long double a1@<st0>, int a2, unsigned int a3, int a4, _DWORD *a5);
int __cdecl getdelim(int *a1, unsigned int *a2, int a3, int *a4);
_BYTE *__cdecl IO_getline_info(int *a1, _BYTE *a2, unsigned int a3, int a4, int a5, _DWORD *a6);
_BYTE *__cdecl IO_getline(int *a1, _BYTE *a2, unsigned int a3, int a4, int a5);
int __cdecl IO_padn(int a1, int a2, int a3);
int __cdecl IO_wpadn(int a1, int a2, int a3);
// int __usercall save_for_wbackup@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>);
int __cdecl IO_least_wmarker(int a1, int a2);
_DWORD *__cdecl IO_switch_to_main_wget_area(_DWORD *a1);
_DWORD *__cdecl IO_switch_to_wbackup_area(_DWORD *a1);
unsigned int __cdecl IO_wsetb(int a1, int a2, int a3, int a4);
// int __usercall IO_wdefault_pbackfail@<eax>(long double a1@<st0>, int *a2, int a3);
// int __usercall IO_wdefault_finish@<eax>(long double a1@<st0>, int a2);
// int __usercall IO_wdefault_uflow@<eax>(long double a1@<st0>, int a2);
int __cdecl _woverflow(_DWORD *a1, int a2);
unsigned int __cdecl IO_wdefault_xsputn(_DWORD *a1, int *a2, unsigned int a3);
unsigned int __cdecl IO_wdoallocbuf(int a1);
// int __usercall IO_wdefault_doallocate@<eax>(long double a1@<st0>, int a2);
int __cdecl IO_switch_to_wget_mode(int *a1);
_DWORD *__cdecl IO_free_wbackup_area(int *a1);
// int __usercall _wuflow@<eax>(long double a1@<st0>, int *a2);
// int __usercall _wunderflow@<eax>(long double a1@<st0>, int *a2);
// unsigned int __usercall IO_wdefault_xsgetn@<eax>(long double a1@<st0>, int *a2, _WORD *a3, unsigned int a4);
// int __usercall IO_sputbackwc@<eax>(long double a1@<st0>, _DWORD *a2, int a3);
// int __usercall IO_sungetwc@<eax>(long double a1@<st0>, _DWORD *a2);
int __cdecl IO_adjust_wcolumn(int a1, unsigned int a2, int a3);
int __cdecl IO_init_wmarker(int *a1, int *a2);
int __cdecl IO_wmarker_delta(int a1);
int __cdecl IO_seekwmark(int *a1, int a2);
int *__cdecl IO_unsave_wmarkers(int *a1);
int __cdecl do_encoding(int a1);
int do_always_noconv();
int __cdecl do_max_length(int a1);
int __cdecl do_in(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8);
int __cdecl do_unshift(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl do_out(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8);
int __cdecl do_length(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl IO_fwide(_DWORD *a1, int a2);
int __cdecl _libc_scratch_buffer_grow_preserve(int a1);
// _BYTE *__usercall strndup@<eax>(long double a1@<st0>, _BYTE *a2, int a3);
// unsigned int __usercall strerror_r@<eax>(long double a1@<st0>, signed int a2, _BYTE *a3, unsigned int a4);
int (__cdecl *strnlen())(_BYTE *a1, int a2);
const __m128i *(__usercall *strrchr())@<eax>(const __m128i *a1@<esi>, const __m128i *a2, unsigned int a3);
unsigned int *__cdecl _strrchr_ia32(unsigned int *a1, int a2);
// unsigned int __usercall critical_factorization_0@<eax>(int a1@<eax>, unsigned int a2@<edx>, int *a3@<ecx>);
// int __usercall two_way_long_needle_0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, unsigned int a4);
int __cdecl memmem(int a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4);
// int __usercall argz_create_sep@<eax>(long double a1@<st0>, char *a2, int a3, unsigned int *a4, int *a5);
int __cdecl argz_add_sep(int *a1, _DWORD *a2, char *a3, int a4);
// const __m128i *__usercall _strrchr_sse2@<eax>(const __m128i *a1@<esi>, const __m128i *a2, unsigned int a3);
// int __usercall _strrchr_sse2_bsf@<eax>(const __m128i *a1@<esi>, const __m128i *a2, unsigned int a3);
int __cdecl _strnlen_sse2(_BYTE *a1, unsigned int a2);
int __cdecl _strnlen_ia32(_BYTE *a1, int a2);
int __cdecl _strcasecmp_nonascii(char *a1, unsigned __int8 *a2);
int (__cdecl *wcslen())(_DWORD *a1);
_BYTE *__cdecl wmemcpy(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl wmemmove(int a1, int a2, int a3);
_DWORD *__cdecl wmemset(_DWORD *a1, int a2, unsigned int a3);
int __cdecl btowc(int a1);
int __cdecl wcrtomb(char *a1, int a2, void *a3);
int __cdecl mbsrtowcs(int a1, _BYTE **a2, int a3, void *a4);
int __cdecl wcsrtombs(int a1, int *a2, int a3, int *a4);
int __cdecl wcsnlen(_DWORD *a1, int a2);
int *__cdecl wcschrnul(int *a1, int a2);
int __cdecl _mbsrtowcs_l(int a1, _BYTE **a2, int a3, int a4, _DWORD **a5);
unsigned int __cdecl _wcslen_sse2(_DWORD *a1);
int __cdecl _wcslen_ia32(_DWORD *a1);
__int64 __fastcall time(int a1);
// unsigned int __usercall compute_offset@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>);
// int __usercall compute_change@<eax>(int result@<eax>, int a2@<edx>);
unsigned int update_vars();
// int __usercall _tzstring_len@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>);
// int __usercall parse_tzname@<eax>(char **a1@<eax>, int a2@<edx>);
// int __usercall parse_offset@<eax>(char **a1@<eax>, int a2@<edx>, long double a3@<st0>);
// bool __usercall parse_rule@<al>(char **a1@<eax>, int a2@<edx>, long double a3@<st0>);
int __cdecl _tzstring(_BYTE *a1);
// unsigned int __usercall _tzset_parse_tz@<eax>(long double a1@<st0>, _BYTE *a2);
// int __usercall tzset_internal@<eax>(int result@<eax>, int a2@<edx>, long double a3@<st0>);
// int __usercall _tzname_max@<eax>(long double a1@<st0>);
// int __usercall _tz_compute@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>);
// int __usercall tzset@<eax>(long double a1@<st0>);
// int *__usercall _tz_convert@<eax>(long double a1@<st0>, int *a2, int a3, int *a4);
int __cdecl _tzfile_read(char *a1, unsigned int a2, _DWORD *a3);
_BYTE *__cdecl _tzfile_default(_BYTE *a1, _BYTE *a2, int a3, int a4);
// int __usercall _tzfile_compute@<eax>(long double a1@<st0>, int a2, int a3, int *a4, int *a5, int *a6);
// int *__userpurge _alloc_dir@<eax>(int a1@<eax>, char a2@<dl>, int a3@<ecx>, int a4);
// int *__usercall opendir_tail@<eax>(int a1@<eax>);
int *__fastcall _opendirat(int a1, _BYTE *a2);
int *__cdecl opendir(_BYTE *a1);
unsigned int __cdecl closedir(int a1);
int __cdecl readdir(int a1);
int __cdecl rewinddir(int a1);
int __fastcall _getdents(int a1, unsigned int a2);
int __cdecl readdir64(int a1);
int *__cdecl fdopendir(int a1);
unsigned int __fastcall uname(int a1);
__int64 __fastcall getuid(int a1);
__int64 __fastcall geteuid(int a1);
__int64 __fastcall getgid(int a1);
__int64 __fastcall getegid(int a1);
unsigned int __cdecl _lxstat64(int a1, int a2, int a3);
int __cdecl _fxstatat64(int a1, int a2, int a3);
unsigned int __cdecl lseek(int a1, int a2);
unsigned int __cdecl access(int a1, int a2);
int __cdecl close(int a1);
unsigned int __fastcall _close_nocancel(int a1);
_BOOL4 __cdecl isatty(int a1);
int __cdecl tcgetattr(int a1, int a2);
int __cdecl brk(unsigned int a1);
int __cdecl writev(int a1, int a2, int a3);
unsigned int __cdecl _writev_nocancel(int a1, int a2);
int __cdecl wctrans(int a1);
unsigned int __cdecl towctrans(unsigned int a1, _DWORD *a2);
int __cdecl _readonly_area(unsigned int a1, unsigned int a2);
// int __usercall is_dst@<eax>(int a1@<eax>, char *a2@<edx>, _BYTE *a3@<ecx>, int a4, int a5);
// int __usercall is_trusted_path_normalize@<eax>(char *a1@<eax>, int a2@<edx>);
// _BYTE *__usercall add_name_to_object@<eax>(int a1@<eax>, _BYTE *a2@<edx>, long double a3@<st0>);
// void __usercall __noreturn lose_isra_5(signed int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, long double a4@<st0>, int a5, int a6, const char *a7, int a8);
// int __usercall open_verify_constprop_7@<eax>(_BYTE *a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, long double a4@<st0>, _BYTE *a5, int a6);
// int __usercall open_path@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, long double a4@<st0>, int *a5, _DWORD *a6, int a7, int a8, int a9, _BYTE *a10);
// int __usercall dl_map_object_from_fd_constprop_8@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>, _BYTE *a5, int a6, char a7, int a8, int a9, int a10);
// int __usercall add_path_isra_4_constprop_9@<eax>(int result@<eax>, int *a2@<edx>);
int __cdecl dl_dst_count(int a1, int a2);
char *__cdecl dl_dst_substitute(int a1, _BYTE *a2, char *a3, int a4);
// char *__usercall expand_dynamic_string_token@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// _DWORD *__usercall fillin_rpath@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<edx>, char *a3@<ecx>, long double a4@<st0>, int a5, int a6, _BYTE *a7, int a8);
// int __usercall cache_rpath_part_6@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, long double a4@<st0>, int a5);
// _DWORD *__usercall dl_init_paths@<eax>(_BYTE *a1@<eax>, long double a2@<st0>);
// int __userpurge dl_map_object@<eax>(int *a1@<eax>, char *a2@<edx>, char a3@<cl>, long double a4@<st0>, int a5, unsigned int a6, int a7);
// int __usercall dl_rtld_di_serinfo@<eax>(int a1@<eax>, _DWORD *a2@<edx>, char a3@<cl>, long double a4@<st0>);
// int __usercall check_match@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, char a4, unsigned __int8 a5, int a6, int a7, int a8, int a9, _DWORD *a10, _DWORD *a11);
// int __usercall do_lookup_x@<eax>(unsigned __int8 *a1@<eax>, unsigned int a2@<edx>, unsigned int *a3@<ecx>, int a4, int *a5, int *a6, int a7, _DWORD *a8, char a9, int a10, int a11, unsigned int a12);
// int __userpurge dl_lookup_symbol_x@<eax>(unsigned __int8 *a1@<eax>, unsigned int a2@<edx>, int *a3@<ecx>, long double a4@<st0>, int **a5, const char **a6, int a7, int a8, int a9);
// _DWORD *__usercall dl_setup_hash@<eax>(_DWORD *result@<eax>);
// int __usercall dl_add_to_namespace_list@<eax>(int a1@<eax>, int a2@<edx>);
// int __userpurge dl_new_object@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, char a3@<cl>, int a4, char a5, int a6);
// int __usercall dl_try_allocate_static_tls@<eax>(int a1@<eax>);
// int __usercall dl_allocate_static_tls@<eax>(int a1@<eax>, long double a2@<st0>);
int __cdecl dl_nothread_init_static_tls(int a1);
// _DWORD *__usercall dl_protect_relro@<eax>(_DWORD *result@<eax>, long double a2@<st0>);
// void __usercall __noreturn dl_reloc_bad_type(int a1@<eax>, unsigned __int8 a2@<dl>, int a3@<ecx>, long double a4@<st0>);
// void __usercall dl_relocate_object(long double a1@<st0>, int a2, int **a3, int a4, int a5);
// _DWORD *__userpurge dl_important_hwcaps@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, long double a4@<st0>, _DWORD *a5);
// void __usercall __noreturn dl_signal_error(signed int a1@<eax>, _BYTE *a2@<edx>, const char *a3@<ecx>, long double a4@<st0>, const char *a5);
// int __userpurge dl_signal_cerror@<eax>(signed int a1@<eax>, char *a2@<edx>, const char *a3@<ecx>, long double a4@<st0>, const char *a5);
// int __userpurge dl_catch_error@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _BYTE *a3@<ecx>, int a4@<ebp>, int a5@<edi>, int a6@<esi>, void (__cdecl *a7)(int), int a8);
// int __usercall dl_receive_error@<eax>(int (__cdecl *a1)(_DWORD, _DWORD, _DWORD)@<eax>, int (__cdecl *a2)(int)@<edx>, int a3@<ecx>);
// __int64 __usercall dl_debug_vdprintf@<edx:eax>(int a1@<eax>, int a2@<edx>, char *a3@<ecx>, int *a4);
// int __usercall dl_sysdep_read_whole_file@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>);
__int64 dl_debug_printf(char *a1, ...);
__int64 dl_debug_printf_c(char *a1, ...);
__int64 dl_dprintf(int a1, char *a2, ...);
// int __usercall dl_name_match_p@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall dl_higher_prime_number@<eax>(unsigned int a1@<eax>);
// int __usercall allocate_dtv@<eax>(int a1@<eax>);
unsigned int dl_next_tls_modid();
int dl_count_modids();
// int __usercall dl_get_tls_static_info@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>);
int dl_allocate_tls_storage();
// int __usercall dl_allocate_tls_init@<eax>(int a1@<eax>);
// int __usercall dl_allocate_tls@<eax>(int a1@<eax>);
// int __usercall dl_deallocate_tls@<eax>(int a1@<eax>, int a2@<edx>);
int __cdecl dl_tls_get_addr_soft(int a1);
// int __usercall dl_add_to_slotinfo@<eax>(long double a1@<st0>, unsigned int a2);
int dl_get_origin();
int __cdecl dl_scope_free(int a1);
// unsigned int __usercall dl_make_stack_executable@<eax>(_DWORD *a1@<eax>);
// int __usercall add_to_global@<eax>(int a1@<eax>, long double a2@<st0>);
// _DWORD *__usercall dl_find_dso_for_object@<eax>(unsigned int a1@<eax>);
// int __usercall dl_open@<eax>(int a1@<edi>, long double a2@<st0>, _BYTE *a3, int a4, int a5, int a6, int a7, int a8, int a9);
__int64 __cdecl dl_show_scope(_DWORD *a1, int a2);
// _DWORD *__usercall dl_open_worker@<eax>(long double a1@<st0>, int a2);
// int __usercall remove_slotinfo@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, unsigned __int8 a4);
// _DWORD *__usercall dl_close_worker@<eax>(long double a1@<st0>, int a2, char a3);
// void __usercall dl_close(long double a1@<st0>, int a2);
// void __userpurge __spoils<ecx,st0> dl_runtime_resolve(long double a1@<st0>, int a2, int a3, int a4);
// void __userpurge __spoils<edx,ecx,st0,xmm0> dl_runtime_profile(unsigned int a1@<edx>, unsigned int a2@<ecx>, long double a3@<st1>, long double a4@<st0>, __int64 _XMM0_8@<xmm0>, __int64 _XMM1_8@<xmm1>, int a7, int a8, char a9, int a10, int a11);
// int __usercall dl_cache_libcmp@<eax>(char *a1@<eax>, char *a2@<edx>);
// _BYTE *__usercall dl_load_cache_lookup@<eax>(char *a1@<eax>);
unsigned int dl_unload_cache();
// int __usercall dl_tlsdesc_resolve_early_return_p@<eax>(int (__usercall **a1)@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)@<eax>, int (__usercall *a2)@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)@<edx>);
// int __usercall dl_tlsdesc_resolve_abs_plus_addend_fixup@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>);
// int __usercall dl_tlsdesc_resolve_rel_fixup@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, long double a4@<st0>);
// int __usercall dl_tlsdesc_resolve_rela_fixup@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, long double a4@<st0>);
// char *__usercall dl_tlsdesc_resolve_hold_fixup@<eax>(char **a1@<eax>, int a2@<ecx>);
// unsigned int __usercall dl_unmap@<eax>(int a1@<eax>);
// int __usercall dl_tlsdesc_return@<eax>(int a1@<eax>);
// unsigned int __usercall dl_tlsdesc_undefweak@<eax>(int a1@<eax>);
// int __usercall dl_tlsdesc_resolve_abs_plus_addend@<eax>(int (__fastcall **a1)(int, int)@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, long double a5@<st0>);
// int __usercall dl_tlsdesc_resolve_rel@<eax>(int (__fastcall **a1)(int, int)@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, long double a5@<st0>);
// int __usercall dl_tlsdesc_resolve_rela@<eax>(int (__fastcall **a1)(int, int)@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, long double a5@<st0>);
// int __usercall dl_tlsdesc_resolve_hold@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>);
void __cdecl dl_mcount_wrapper(int a1);
void __cdecl dl_mcount_wrapper_check(int a1);
// int __usercall do_dlopen@<eax>(int a1@<edi>, long double a2@<st0>, int a3);
// int __usercall dlerror_run@<eax>(void (__cdecl *a1)(int)@<eax>, int a2@<edx>, int a3@<ebp>, int a4@<edi>, int a5@<esi>);
// int __usercall _libc_dlsym@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5);
// int __usercall _libc_dlclose@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4);
// int __usercall do_dlsym_private@<eax>(long double a1@<st0>, int a2);
// int __usercall do_dlsym@<eax>(long double a1@<st0>, _DWORD *a2);
int do_dlclose(); // weak
// int __usercall _libc_dlsym_private@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5);
// int __usercall _libc_dlopen_mode@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5);
// _DWORD *__usercall _libc_register_dl_open_hook@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4);
unsigned int dl_initial_error_catch_tsd();
// int __usercall _sigsetjmp@<eax>(int ebx0@<ebx>, int ebp0@<ebp>, int a3@<edi>, int a4@<esi>, int a1, _BOOL4 a2);
int __cdecl _sigjmp_save(int a1, _BOOL4 a2);
void _longjmp(struct __jmp_buf_tag env[1], int val);
int __cdecl _mpn_cmp(int a1, int a2, int a3);
int __cdecl _mpn_divrem(int a1, int a2, _DWORD *a3, int a4, unsigned int *a5, int a6);
int __cdecl _mpn_lshift(_DWORD *a1, int a2, int a3, char a4);
int __cdecl _mpn_rshift(int a1, unsigned int *a2, int a3, char a4);
int __cdecl _mpn_mul(_DWORD *a1, unsigned int *a2, int a3, unsigned int *a4, int a5);
int __cdecl _mpn_mul_1(int a1, int a2, int a3, unsigned int a4);
int __cdecl _mpn_impn_mul_n_basecase(int a1, _DWORD *a2, unsigned int *a3, int a4);
int __cdecl _mpn_impn_mul_n(_DWORD *a1, unsigned int *a2, unsigned int *a3, int a4, _DWORD *a5);
int __cdecl _mpn_impn_sqr_n_basecase(int a1, unsigned int *a2, int a3);
int __cdecl _mpn_impn_sqr_n(unsigned int *a1, unsigned int *a2, int a3, _DWORD *a4);
int __cdecl _mpn_mul_n(unsigned int *a1, unsigned int *a2, unsigned int *a3, int a4);
_BOOL4 __cdecl _mpn_sub_n(_DWORD *a1, unsigned int *a2, _DWORD *a3, unsigned int a4);
int __cdecl _mpn_submul_1(int a1, int a2, int a3, unsigned int a4);
int __cdecl _mpn_extract_double(unsigned int *a1, int a2, int *a3, unsigned int *a4, unsigned int a5, unsigned int a6);
int __cdecl _mpn_extract_long_double(int a1, int a2, unsigned int *a3, int *a4, long double a5);
_DWORD *__cdecl itowa(unsigned __int64 a1, _DWORD *a2, unsigned int a3, int a4);
// int __usercall sscanf@<eax>(long double a1@<st0>, unsigned int a2, unsigned int a3, ...);
// int __usercall vsscanf@<eax>(long double a1@<st0>, unsigned int a2, unsigned int a3, long double **a4);
int __cdecl fileno_unlocked(_DWORD *a1);
int __cdecl fseek(int *a1, int a2, unsigned int a3);
int __cdecl ftello(int *a1);
int __cdecl fread_unlocked(int a1, unsigned int a2, int a3, int a4);
int init();
// int __usercall _dlerror@<eax>(long double a1@<st0>);
// const char *__usercall check_free_isra_0@<eax>(const char *result@<eax>, long double a2@<st0>);
int __cdecl free_key_mem(int a1);
// _BOOL4 __usercall dlerror_run@<eax>(void (__cdecl *a1)(int)@<eax>, int a2@<edx>, int a3@<ebp>);
// _DWORD *__usercall _libc_register_dlfcn_hook@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4);
int __cdecl _dladdr(unsigned int a1, _DWORD *a2);
int __cdecl _dladdr1(unsigned int a1, _DWORD *a2, _DWORD *a3, int a4);
// int *__usercall dlinfo_doit@<eax>(long double a1@<st0>, int *a2);
// int __usercall _dlinfo@<eax>(int a1@<ebp>, int a2, int a3, int a4, int a5);
// int __usercall dlmopen_doit@<eax>(int a1@<edi>, long double a2@<st0>, _DWORD *a3);
// int __usercall _dlmopen@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5, int a6, int a7);
// unsigned int __usercall strerror@<eax>(long double a1@<st0>, signed int a2);
_BYTE *__cdecl strsep(_BYTE **a1, char *a2);
int __cdecl _offtime(_DWORD *a1, int a2, int *a3);
// int *__usercall localtime_r@<eax>(long double a1@<st0>, int *a2, int *a3);
// int *__usercall localtime@<eax>(long double a1@<st0>, int *a2);
// int __usercall ranged_convert@<eax>(int (__cdecl *a1)(int *, int)@<eax>, int *a2@<edx>, int a3@<ecx>);
// int __usercall guess_time_tm_isra_0@<eax>(unsigned __int64 a1@<edx:eax>, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8);
int __cdecl _mktime_internal(int *a1, int (__cdecl *a2)(int *, int), int *a3);
// int __usercall timelocal@<eax>(long double a1@<st0>, int *a2);
unsigned int __fastcall _getdents64(int a1, int a2);
int __fastcall getpid(int a1);
// int __usercall dl_build_local_scope@<eax>(_DWORD *a1@<eax>, int a2@<edx>);
// int __usercall openaux@<eax>(long double a1@<st0>, int a2);
// int __userpurge dl_map_object_deps@<eax>(int a1@<eax>, int *a2@<edx>, unsigned int a3@<ecx>, long double a4@<st0>, int a5, int a6);
// int (*__usercall dl_fixup@<eax>(unsigned int a1@<eax>, int a2@<edx>, long double a3@<st0>))(void);
// int (*__userpurge dl_profile_fixup@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, long double a4@<st0>, int a5, _DWORD *a6))(void);
_DWORD __stdcall dl_call_pltexit(_DWORD); // weak
// int __usercall call_init_part_0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
// int __userpurge dl_init@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
// _DWORD *__userpurge dl_sort_fini@<eax>(_DWORD *result@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
// int __usercall dl_fini@<eax>(long double a1@<st0>);
// int __userpurge match_symbol@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>, const char *a5, _DWORD *a6, int a7, int a8);
// int __usercall dl_check_map_versions@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>);
// int __usercall dl_check_all_versions@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>);
// int __usercall dl_start_profile@<eax>(long double a1@<st0>);
void __cdecl dl_mcount(int a1, int a2);
_BOOL4 __cdecl _mpn_add_n(_DWORD *a1, _DWORD *a2, _DWORD *a3, unsigned int a4);
int __cdecl _mpn_addmul_1(int a1, int a2, int a3, unsigned int a4);
// int __usercall char_buffer_add_slow@<eax>(int result@<eax>, char a2@<dl>);
// int __usercall IO_vfscanf_internal@<eax>(long double a1@<st0>, int a2, unsigned int a3, long double **a4, _DWORD *a5);
// int __usercall vfscanf@<eax>(long double a1@<st0>, int a2, unsigned int a3, long double **a4);
int __cdecl IO_seekoff_unlocked(int *a1, __int64 a2, unsigned int a3, int a4);
int __cdecl IO_seekoff(int *a1, __int64 a2, unsigned int a3, int a4);
// int __usercall dlopen_doit@<eax>(int a1@<edi>, long double a2@<st0>, int a3);
// int __usercall _dlopen@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5, int a6);
int dlclose_doit(); // weak
// int __usercall _dlclose@<eax>(int a1@<ebp>, int a2);
// int (*__usercall dlsym_doit@<eax>(long double a1@<st0>, int a2))(void);
// int __usercall _dlsym@<eax>(int a1@<ebp>, int a2, int a3, int a4);
// int (*__usercall dlvsym_doit@<eax>(long double a1@<st0>, int a2))(void);
// int __usercall _dlvsym@<eax>(int a1@<ebp>, int a2, int a3, int a4, int a5);
int __cdecl _libc_scratch_buffer_set_array_size(int *a1, unsigned int a2, int a3);
_BYTE *__cdecl strpbrk(int a1, _BYTE *a2);
int __cdecl mbrlen(_BYTE *a1, int a2, _DWORD *a3);
int __cdecl mbrtowc(char *a1, _BYTE *a2, int a3, _DWORD *a4);
unsigned int __cdecl _profil_counter(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16);
int __cdecl profil(int a1, unsigned int a2, int a3, int a4);
int _profile_frequency();
// int __usercall call_dl_lookup@<eax>(long double a1@<st0>, int a2);
// int (*__userpurge do_sym@<eax>(unsigned int a1@<eax>, unsigned __int8 *a2@<edx>, unsigned int a3@<ecx>, long double a4@<st0>, const char **a5, int a6))(void);
// int (*__userpurge dl_vsym@<eax>(unsigned int a1@<eax>, unsigned __int8 *a2@<edx>, unsigned __int8 *a3@<ecx>, long double a4@<st0>, unsigned int a5))(void);
// int (*__usercall dl_sym@<eax>(unsigned int a1@<eax>, unsigned __int8 *a2@<edx>, unsigned int a3@<ecx>, long double a4@<st0>))(void);
__int64 __cdecl _strtoll_internal(unsigned __int8 *a1, _DWORD *a2, int a3, int a4);
__int64 __cdecl strtoq(unsigned __int8 *a1, _DWORD *a2, int a3);
int __cdecl _strtoull_internal(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4);
int __cdecl strtouq(unsigned __int8 *a1, unsigned __int8 **a2, int a3);
__int64 __cdecl ___strtoll_l_internal(unsigned __int8 *a1, _DWORD *a2, int a3, int a4, int a5);
__int64 __cdecl strtoll_l(unsigned __int8 *a1, _DWORD *a2, int a3, int a4);
int __cdecl ___strtoull_l_internal(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4, int a5);
int __cdecl strtoull_l(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4);
void __cdecl _strtof_internal(unsigned int, _DWORD *, int);
void __cdecl strtof(unsigned int a1, _DWORD *a2);
void __cdecl _strtod_internal(unsigned int, _DWORD *, int);
void __cdecl strtod(unsigned int a1, _DWORD *a2);
void __cdecl _strtold_internal(unsigned int, _DWORD *, int);
void __cdecl strtold(unsigned int a1, _DWORD *a2);
// int __usercall round_away@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4, int a5);
// long double __usercall round_and_return@<st0>(unsigned int *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4, unsigned int a5, char a6, int a7);
// char *__usercall str_to_mpn_isra_0@<eax>(char *a1@<eax>, int a2@<edx>, int *a3@<ecx>, int *a4, unsigned int *a5, int a6, _BYTE *a7);
long double __cdecl ___strtof_l_internal(unsigned int a1, _DWORD *a2, int a3, _DWORD *a4);
void __cdecl strtof_l(unsigned int a1, _DWORD *a2, _DWORD *a3);
// int __usercall round_away_0@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4, int a5);
// long double __usercall round_and_return_0@<st0>(unsigned int *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4, unsigned int a5, char a6, int a7);
// char *__usercall str_to_mpn_isra_0_0@<eax>(char *a1@<eax>, int a2@<edx>, int *a3@<ecx>, int *a4, unsigned int *a5, int a6, _BYTE *a7);
long double __cdecl ___strtod_l_internal(unsigned int a1, _DWORD *a2, int a3, _DWORD *a4);
void __cdecl strtod_l(unsigned int a1, _DWORD *a2, _DWORD *a3);
// int __usercall round_away_1@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4, int a5);
// long double __usercall round_and_return_1@<st0>(unsigned int *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4, unsigned int a5, char a6, int a7);
// char *__usercall str_to_mpn_isra_0_1@<eax>(char *a1@<eax>, int a2@<edx>, int *a3@<ecx>, int *a4, unsigned int *a5, int a6, _BYTE *a7);
long double __cdecl ___strtold_l_internal(unsigned int a1, _DWORD *a2, int a3, _DWORD *a4);
void __cdecl strtold_l(unsigned int a1, _DWORD *a2, _DWORD *a3);
// long double __usercall _strtof_nan@<st0>(unsigned __int8 *a1@<eax>, unsigned __int8 **a2@<edx>, char a3@<cl>);
// long double __usercall _strtod_nan@<st0>(unsigned __int8 *a1@<eax>, unsigned __int8 **a2@<edx>, char a3@<cl>);
// long double __usercall _strtold_nan@<st0>(unsigned __int8 *a1@<eax>, unsigned __int8 **a2@<edx>, char a3@<cl>);
long double __cdecl _mpn_construct_float(_DWORD *a1, char a2, unsigned __int8 a3);
long double __cdecl _mpn_construct_double(_DWORD *a1, __int16 a2, unsigned __int8 a3);
long double __cdecl _mpn_construct_long_double(_QWORD *a1, __int16 a2, char a3);
int (__cdecl *strncasecmp_l())(char *a1, unsigned __int8 *a2, int a3, int a4);
int __cdecl _strncasecmp_l_nonascii(char *a1, unsigned __int8 *a2, int a3, int a4);
int __cdecl _strncasecmp_ssse3(char *a1, unsigned __int8 *a2, int a3);
int __cdecl _strncasecmp_l_ssse3(char *a1, unsigned __int8 *a2, int a3, int a4);
int __cdecl _strncasecmp_sse4_2(char *a1, unsigned __int8 *a2, int a3);
int __cdecl _strncasecmp_l_sse4_2(char *a1, unsigned __int8 *a2, int a3, int a4);
unsigned int __cdecl setitimer(int a1, int a2);
int __cdecl _strncasecmp_nonascii(char *a1, unsigned __int8 *a2, int a3);
// unsigned int *__usercall read_encoded_value_with_base@<eax>(char a1@<al>, unsigned __int16 *a2@<edx>, unsigned __int16 *a3@<ecx>, unsigned int *a4);
// int __usercall base_of_encoded_value@<eax>(char a1@<al>, _DWORD *a2@<edx>, int a3@<ecx>);
// unsigned int __usercall execute_cfa_program@<eax>(unsigned int result@<eax>, unsigned int a2@<edx>, _DWORD *a3@<ecx>, unsigned int a4);
int *init_dwarf_reg_size_table();
// int __usercall uw_frame_state_for@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, long double a3@<st0>);
// int __usercall execute_stack_op@<eax>(char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4);
// int __usercall uw_update_context_1@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall uw_init_context_1@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>);
// int __usercall uw_update_context@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall Unwind_RaiseException_Phase2@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, long double a3@<st0>);
// int __usercall Unwind_ForcedUnwind_Phase2@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, long double a3@<st0>);
// int __usercall uw_install_context_1@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>);
int __cdecl Unwind_GetGR(int a1, int a2);
int __cdecl Unwind_GetCFA(int a1);
// int __usercall Unwind_SetGR@<eax>(long double a1@<st0>, int a2, int a3, int a4);
int __cdecl Unwind_GetIP(int a1);
int __cdecl Unwind_GetIPInfo(int a1, _DWORD *a2);
int __cdecl Unwind_SetIP(int a1, int a2);
int __cdecl Unwind_GetLanguageSpecificData(int a1);
int __cdecl Unwind_GetRegionStart(int a1);
// int __usercall Unwind_FindEnclosingFunction@<eax>(unsigned int a1@<ecx>, long double a2@<st0>, int a3);
int __cdecl Unwind_GetDataRelBase(int a1);
int __cdecl Unwind_GetTextRelBase(int a1);
// int __usercall _frame_state_for@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl Unwind_DebugHook(_DWORD, _DWORD);
// int __usercall Unwind_RaiseException@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>, _DWORD *a4);
// int __usercall Unwind_ForcedUnwind@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>, _DWORD *a4, int a5, int a6);
// void __usercall __noreturn Unwind_Resume(int a1@<eax>, int a2@<edx>, long double a3@<st0>, _DWORD *a4);
// void __usercall __noreturn Unwind_Resume_or_Rethrow(int a1@<eax>, int a2@<edx>, long double a3@<st0>, _DWORD *a4);
int (__cdecl *__cdecl Unwind_DeleteException(int a1))(int, int);
// int __usercall Unwind_Backtrace@<eax>(long double a1@<st0>, int (__cdecl *a2)(_DWORD *, int), int a3);
void *_x86_get_pc_thunk_ax();
void _x86_get_pc_thunk_si();
void _x86_get_pc_thunk_di();
void _x86_get_pc_thunk_bp();
int __cdecl fde_unencoded_compare(int a1, int a2, int a3);
// int __usercall frame_downheap@<eax>(int result@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3@<ecx>, int a4, int a5);
// int __usercall frame_heapsort@<eax>(int result@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3@<ecx>);
// int __usercall size_of_encoded_value@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall base_from_object@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>);
// int __usercall base_from_cb_data@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>);
// unsigned int *__usercall read_encoded_value_with_base_0@<eax>(char a1@<al>, unsigned __int16 *a2@<edx>, unsigned __int16 *a3@<ecx>, unsigned int *a4);
int __cdecl fde_single_encoding_compare(int a1, int a2, int a3);
// int __usercall get_cie_encoding@<eax>(_BYTE *a1@<eax>);
// int __usercall linear_search_fdes@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
int __cdecl Unwind_IteratePhdrCallback(int a1, unsigned int a2, int *a3);
int __cdecl fde_mixed_encoding_compare(int a1, int a2, int a3);
// int __usercall classify_object_over_fdes@<eax>(int a1@<eax>, _DWORD *a2@<edx>);
// unsigned int *__usercall add_fdes@<eax>(int a1@<eax>, int *a2@<edx>, int a3@<ecx>);
// int __usercall search_object@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, long double a4@<st0>);
// int __usercall _register_frame_info_part_4@<eax>(int a1@<eax>, _DWORD *a2@<edx>);
int __cdecl _register_frame_info_bases(_DWORD *a1, _DWORD *a2, int a3, int a4);
int __cdecl _register_frame_info(_DWORD *a1, _DWORD *a2);
// int __usercall _register_frame@<eax>(long double a1@<st0>, int *a2);
int __cdecl _register_frame_info_table_bases(int a1, _DWORD *a2, int a3, int a4);
int __cdecl _register_frame_info_table(int a1, _DWORD *a2);
// int __usercall _register_frame_table@<eax>(long double a1@<st0>, int a2);
// int __usercall _deregister_frame_info_bases@<eax>(long double a1@<st0>, _DWORD *a2);
// _DWORD *__usercall _deregister_frame@<eax>(long double a1@<st0>, _DWORD *a2);
// int __usercall Unwind_Find_FDE@<eax>(unsigned int a1@<ecx>, long double a2@<st0>, unsigned int a3, _DWORD *a4);
// int __usercall base_of_encoded_value_0@<eax>(char a1@<al>, int a2@<edx>, long double a3@<st0>);
// unsigned int *__usercall read_encoded_value_with_base_1@<eax>(char a1@<al>, unsigned __int16 *a2@<edx>, unsigned __int16 *a3@<ecx>, long double a4@<st0>, unsigned int *a5);
// int __usercall _gcc_personality_v0@<eax>(long double a1@<st0>, int a2, char a3, int a4, int a5, int a6, int a7);
int __cdecl dl_iterate_phdr(int (__cdecl *a1)(int *, int, int), int a2);
// int *__usercall free_mem@<eax>(long double a1@<st0>);
// void __usercall nl_finddomain_subfreeres(long double a1@<st0>);
// _DWORD *__usercall nl_unload_domain@<eax>(int *a1@<eax>, long double a2@<st0>);
// _DWORD *__usercall buffer_free@<eax>(long double a1@<st0>);
// _DWORD *__usercall free_derivation@<eax>(long double a1@<st0>, int a2);
// _DWORD *__usercall free_modules_db@<eax>(_DWORD *a1@<eax>, long double a2@<st0>);
// _DWORD *__usercall free_mem_0@<eax>(long double a1@<st0>);
// _DWORD *__usercall free_mem_1@<eax>(long double a1@<st0>);
// _DWORD *__usercall free_mem_2@<eax>(long double a1@<st0>);
// _DWORD *__usercall do_release_all@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, long double a4@<st0>, int a5);
_DWORD *free_mem_3();
// void **__usercall free_category@<eax>(void **result@<eax>, void **a2@<edx>, void **a3@<ecx>, long double a4@<st0>);
// int __usercall nl_locale_subfreeres@<eax>(long double a1@<st0>);
// int __usercall nl_archive_subfreeres@<eax>(long double a1@<st0>);
// _DWORD *__usercall free_mem_4@<eax>(long double a1@<st0>);
// void __usercall free_mem_5(long double a1@<st0>);
// _DWORD *__usercall free_mem_6@<eax>(long double a1@<st0>);
// int __usercall free_slotinfo@<eax>(int *a1@<eax>, long double a2@<st0>);
// _DWORD *__usercall free_mem_7@<eax>(long double a1@<st0>);
// int __usercall arena_thread_freeres@<eax>(long double a1@<st0>);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

int dword_8048000 = 1179403647; // weak
int (**off_8048114)() = &off_80EB044; // weak
_UNKNOWN _restore; // weak
char yycheck[64] =
{
  '\x01',
  '\n',
  '\v',
  '\x04',
  '\r',
  '\x0E',
  '\b',
  '\t',
  '\0',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\t',
  '\x19',
  '\a',
  '\b',
  '\t',
  '\x0F',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\xFF',
  '\xFF',
  '\f',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char yytable[55] =
{
  '\a',
  '\x01',
  '\x02',
  '\b',
  '\x03',
  '\x04',
  '\x0F',
  '\x10',
  '\t',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x10',
  '\x1A',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\x19',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\r',
  '\x0E',
  '\x0F',
  '\x10'
}; // weak
char yypgoto[5] = { '\xF6', '\xF6', '\xFF', '\0', '\0' }; // weak
char yypact[27] =
{
  '\xF7',
  '\xF7',
  '\xF6',
  '\xF6',
  '\xF7',
  '\b',
  '$',
  '\xF6',
  '\r',
  '\xF6',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF6',
  '\x1A',
  ')',
  '-',
  '\x12',
  '\xFE',
  '\x0E',
  '\xF6',
  '\xF7',
  '$'
}; // weak
char yydefgoto[5] = { '\xFF', '\x05', '\x06', '\0', '\0' }; // weak
char yydefact[] = { '\0' }; // weak
char yyr2[16] =
{
  '\0',
  '\x02',
  '\x01',
  '\x05',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x02',
  '\x01',
  '\x01',
  '\x03',
  '\0',
  '\0'
}; // weak
char yyr1[24] =
{
  '\0',
  '\x10',
  '\x11',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char yytranslate[263] =
{
  '\0',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\n',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x05',
  '\x02',
  '\x0E',
  '\x0F',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\f',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x03',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\r',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x04',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x02',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\v'
}; // weak
_UNKNOWN _gettext_germanic_plural; // weak
__int128 xmmword_80BE5A0 = 0x40404040404040404040404040404040LL; // weak
__int128 xmmword_80BE5B0 = 0x5B5B5B5B5B5B5B5B5B5B5B5B5B5B5B5BLL; // weak
__int128 xmmword_80BE5C0 = 0x20202020202020202020202020202020LL; // weak
char intel_02_known[544] =
{
  '\x06',
  '\x04',
  ' ',
  '\0',
  '\0',
  ' ',
  '\0',
  '\0',
  '\b',
  '\x04',
  ' ',
  '\0',
  '\0',
  '@',
  '\0',
  '\0',
  '\t',
  '\x04',
  ' ',
  '\0',
  '\0',
  '\x80',
  '\0',
  '\0',
  '\n',
  '\x02',
  ' ',
  '\x03',
  '\0',
  ' ',
  '\0',
  '\0',
  '\f',
  '\x04',
  ' ',
  '\x03',
  '\0',
  '@',
  '\0',
  '\0',
  '\r',
  '\x04',
  '@',
  '\x03',
  '\0',
  '@',
  '\0',
  '\0',
  '\x0E',
  '\x06',
  '@',
  '\x03',
  '\0',
  '`',
  '\0',
  '\0',
  '!',
  '\b',
  '@',
  '\x06',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\"',
  '\x04',
  '@',
  '\t',
  '\0',
  '\0',
  '\b',
  '\0',
  '#',
  '\b',
  '@',
  '\t',
  '\0',
  '\0',
  '\x10',
  '\0',
  '%',
  '\b',
  '@',
  '\t',
  '\0',
  '\0',
  ' ',
  '\0',
  ')',
  '\b',
  '@',
  '\t',
  '\0',
  '\0',
  '@',
  '\0',
  ',',
  '\b',
  '@',
  '\x03',
  '\0',
  '\x80',
  '\0',
  '\0',
  '0',
  '\b',
  '@',
  '\0',
  '\0',
  '\x80',
  '\0',
  '\0',
  '9',
  '\x04',
  '@',
  '\x06',
  '\0',
  '\0',
  '\x02',
  '\0',
  ':',
  '\x06',
  '@',
  '\x06',
  '\0',
  '\0',
  '\x03',
  '\0',
  ';',
  '\x02',
  '@',
  '\x06',
  '\0',
  '\0',
  '\x02',
  '\0',
  '<',
  '\x04',
  '@',
  '\x06',
  '\0',
  '\0',
  '\x04',
  '\0',
  '=',
  '\x06',
  '@',
  '\x06',
  '\0',
  '\0',
  '\x06',
  '\0',
  '>',
  '\x04',
  '@',
  '\x06',
  '\0',
  '\0',
  '\b',
  '\0',
  '?',
  '\x02',
  '@',
  '\x06',
  '\0',
  '\0',
  '\x04',
  '\0',
  'A',
  '\x04',
  ' ',
  '\x06',
  '\0',
  '\0',
  '\x02',
  '\0',
  'B',
  '\x04',
  ' ',
  '\x06',
  '\0',
  '\0',
  '\x04',
  '\0',
  'C',
  '\x04',
  ' ',
  '\x06',
  '\0',
  '\0',
  '\b',
  '\0',
  'D',
  '\x04',
  ' ',
  '\x06',
  '\0',
  '\0',
  '\x10',
  '\0',
  'E',
  '\x04',
  ' ',
  '\x06',
  '\0',
  '\0',
  ' ',
  '\0',
  'F',
  '\x04',
  '@',
  '\t',
  '\0',
  '\0',
  '@',
  '\0',
  'G',
  '\b',
  '@',
  '\t',
  '\0',
  '\0',
  '\x80',
  '\0',
  'H',
  '\f',
  '@',
  '\x06',
  '\0',
  '\0',
  '0',
  '\0',
  'I',
  '\x10',
  '@',
  '\x06',
  '\0',
  '\0',
  '@',
  '\0',
  'J',
  '\f',
  '@',
  '\t',
  '\0',
  '\0',
  '`',
  '\0',
  'K',
  '\x10',
  '@',
  '\t',
  '\0',
  '\0',
  '\x80',
  '\0',
  'L',
  '\f',
  '@',
  '\t',
  '\0',
  '\0',
  '\xC0',
  '\0',
  'M',
  '\x10',
  '@',
  '\t',
  '\0',
  '\0',
  '\0',
  '\x01',
  'N',
  '\x18',
  '@',
  '\x06',
  '\0',
  '\0',
  '`',
  '\0',
  '`',
  '\b',
  '@',
  '\x03',
  '\0',
  '@',
  '\0',
  '\0',
  'f',
  '\x04',
  '@',
  '\x03',
  '\0',
  ' ',
  '\0',
  '\0',
  'g',
  '\x04',
  '@',
  '\x03',
  '\0',
  '@',
  '\0',
  '\0',
  'h',
  '\x04',
  '@',
  '\x03',
  '\0',
  '\x80',
  '\0',
  '\0',
  'x',
  '\b',
  '@',
  '\x06',
  '\0',
  '\0',
  '\x10',
  '\0',
  'y',
  '\b',
  '@',
  '\x06',
  '\0',
  '\0',
  '\x02',
  '\0',
  'z',
  '\b',
  '@',
  '\x06',
  '\0',
  '\0',
  '\x04',
  '\0',
  '{',
  '\b',
  '@',
  '\x06',
  '\0',
  '\0',
  '\b',
  '\0',
  '|',
  '\b',
  '@',
  '\x06',
  '\0',
  '\0',
  '\x10',
  '\0',
  '}',
  '\b',
  '@',
  '\x06',
  '\0',
  '\0',
  ' ',
  '\0',
  '\x7F',
  '\x02',
  '@',
  '\x06',
  '\0',
  '\0',
  '\b',
  '\0',
  '\x80',
  '\b',
  '@',
  '\x06',
  '\0',
  '\0',
  '\b',
  '\0',
  '\x82',
  '\b',
  ' ',
  '\x06',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\x83',
  '\b',
  ' ',
  '\x06',
  '\0',
  '\0',
  '\b',
  '\0',
  '\x84',
  '\b',
  ' ',
  '\x06',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\x85',
  '\b',
  ' ',
  '\x06',
  '\0',
  '\0',
  ' ',
  '\0',
  '\x86',
  '\x04',
  '@',
  '\x06',
  '\0',
  '\0',
  '\b',
  '\0',
  '\x87',
  '\b',
  '@',
  '\x06',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\xD0',
  '\x04',
  '@',
  '\t',
  '\0',
  '\0',
  '\b',
  '\0',
  '\xD1',
  '\x04',
  '@',
  '\t',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\xD2',
  '\x04',
  '@',
  '\t',
  '\0',
  '\0',
  ' ',
  '\0',
  '\xD6',
  '\b',
  '@',
  '\t',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\xD7',
  '\b',
  '@',
  '\t',
  '\0',
  '\0',
  ' ',
  '\0',
  '\xD8',
  '\b',
  '@',
  '\t',
  '\0',
  '\0',
  '@',
  '\0',
  '\xDC',
  '\f',
  '@',
  '\t',
  '\0',
  '\0',
  ' ',
  '\0',
  '\xDD',
  '\f',
  '@',
  '\t',
  '\0',
  '\0',
  '@',
  '\0',
  '\xDE',
  '\f',
  '@',
  '\t',
  '\0',
  '\0',
  '\x80',
  '\0',
  '\xE2',
  '\x10',
  '@',
  '\t',
  '\0',
  '\0',
  ' ',
  '\0',
  '\xE3',
  '\x10',
  '@',
  '\t',
  '\0',
  '\0',
  '@',
  '\0',
  '\xE4',
  '\x10',
  '@',
  '\t',
  '\0',
  '\0',
  '\x80',
  '\0',
  '\xEA',
  '\x18',
  '@',
  '\t',
  '\0',
  '\0',
  '\xC0',
  '\0',
  '\xEB',
  '\x18',
  '@',
  '\t',
  '\0',
  '\0',
  ' ',
  '\x01',
  '\xEC',
  '\x18',
  '@',
  '\t',
  '\0',
  '\0',
  '\x80',
  '\x01'
}; // weak
void *_wcsmbs_gconv_fcts_c = &to_wc; // weak
_UNKNOWN unk_80BEE28; // weak
_UNKNOWN unk_80BEE29; // weak
unsigned __int8 byte_80BF1CA[2] = { 0u, 0u }; // weak
unsigned __int8 byte_80BF3A0[7] = { 77u, 65u, 76u, 76u, 79u, 67u, 95u }; // weak
_UNKNOWN empty_path_elem; // weak
char *map_0 = "=INTERNAL->ucs4"; // weak
int (__cdecl *off_80BFBC4)(int, int, int, int, int, int, int, int) = &_gconv_transform_internal_ucs4; // weak
int dword_80BFBC8[] = { 0 }; // weak
char byte_80BFBCC[] = { '\x04' }; // weak
char byte_80BFBCD[] = { '\x04' }; // weak
char byte_80BFBCE[] = { '\x04' }; // weak
char byte_80BFBCF[] = { '\x04' }; // weak
char _PRETTY_FUNCTION___9358[32] = "__gconv_transform_internal_ucs4"; // weak
int dword_80C023C[] = { 0 }; // weak
int (*nl_category_postload[12])() =
{
  &nl_postload_ctype,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // weak
char byte_80C0273[] = { '\0' }; // weak
char nl_category_name_sizes[15] =
{
  '\b',
  '\n',
  '\a',
  '\n',
  '\v',
  '\v',
  '\x06',
  '\b',
  '\a',
  '\n',
  '\f',
  '\x0E',
  '\x11',
  '\0',
  '\0'
}; // weak
char byte_80C0283[] = { '\0' }; // weak
char nl_category_name_idxs[28] =
{
  '\v',
  ' ',
  '+',
  '\0',
  '\x14',
  '3',
  '\0',
  '?',
  'H',
  'P',
  '[',
  'h',
  'w',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char nl_category_names[11] = "LC_COLLATE"; // weak
int dword_80C033C[] = { 0 }; // weak
int nl_current_used[13] = { 2, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
unsigned __int8 slashdot_9272[4] = { 47u, 46u, 46u, 47u }; // weak
int codeset_idx_9315[16] = { 14, 5, 110, 18, 45, 4, 0, 2, 6, 12, 4, 1, 15, 0, 0, 0 }; // weak
void **nl_C[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
void *nl_value_types = &nl_value_type_LC_CTYPE; // weak
int nl_category_num_items[13] = { 86, 6, 111, 19, 46, 5, 0, 3, 7, 13, 5, 2, 16 }; // weak
void *nl_C_LC_CTYPE = &nl_C_name; // weak
int dword_80C1540[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // weak
_DWORD dword_80C1B40[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // weak
_BYTE byte_80C2440[512] =
{
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  3,
  32,
  2,
  32,
  2,
  32,
  2,
  32,
  2,
  32,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  1,
  96,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
void **nl_C_locobj[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
_UNKNOWN unk_80CC700; // weak
char byte_80CC77E[2] = { '\xFF', '\xFF' }; // weak
char _strtol_ul_rem_tab[] = { '\x01' }; // weak
int dword_80CC7B8[] = { 0 }; // weak
int _strtol_ul_max_tab[6] = { 2147483647, 1431655765, 1073741823, 858993459, 715827882, 613566756 }; // weak
_DWORD itoa_base_table[112] =
{
  257,
  7936,
  2147483648,
  256,
  5120,
  -808182895,
  513,
  3841,
  1073741824,
  512,
  3329,
  1220703125,
  512,
  3072,
  -2118184960,
  769,
  2817,
  1977326743,
  769,
  2561,
  1073741824,
  256,
  2560,
  -808182895,
  768,
  2306,
  1000000000,
  768,
  2304,
  -1937019605,
  768,
  2051,
  429981696,
  512,
  2050,
  815730721,
  1025,
  2049,
  1475789056,
  768,
  2048,
  -1732076671,
  1025,
  1795,
  268435456,
  1024,
  1795,
  410338673,
  512,
  1794,
  612220032,
  1281,
  1794,
  893871739,
  1024,
  1793,
  1280000000,
  1281,
  1793,
  1801088541,
  1024,
  1792,
  -1800609408,
  1024,
  1792,
  -890141849,
  1024,
  1540,
  191102976,
  768,
  1540,
  244140625,
  768,
  1539,
  308915776,
  1281,
  1539,
  387420489,
  1281,
  1539,
  481890304,
  1024,
  1538,
  594823321,
  1024,
  1538,
  729000000,
  1281,
  1538,
  887503681,
  1281,
  1537,
  1073741824,
  768,
  1537,
  1291467969,
  1280,
  1537,
  1544804416,
  1537,
  1537,
  1838265625,
  768,
  1536,
  -2118184960,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
char itoa_lower_digits[37] = "0123456789abcdefghijklmnopqrstuvwxyz"; // weak
_UNKNOWN unk_80CCF9B; // weak
_UNKNOWN unk_80CCFA3; // weak
_UNKNOWN unk_80CCFA7; // weak
_UNKNOWN unk_80CCFAC; // weak
_UNKNOWN unk_80CCFDC; // weak
_BYTE byte_80CCFEC[28] =
{
  48,
  0,
  0,
  0,
  46,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_UNKNOWN unk_80CD074; // weak
_UNKNOWN zeroes; // weak
_UNKNOWN _libio_codecvt; // weak
__int128 __m128i_shift_right = 0xF0E0D0C0B0A09080706050403020100LL; // weak
_UNKNOWN unk_80CDC5F; // weak
_UNKNOWN nl_C_name; // weak
_UNKNOWN unk_80CDC63; // weak
_UNKNOWN unk_80CDC90; // weak
_UNKNOWN curwd_9710; // weak
_BYTE byte_80CDC92[2] = { 47, 0 }; // weak
char aLib32[6] = "lib32"; // weak
_UNKNOWN expected_note_9894; // weak
_UNKNOWN expected2_9887; // weak
_UNKNOWN expected_9888; // weak
_UNKNOWN unk_80CE4A5; // weak
_UNKNOWN system_dirs_len; // weak
_UNKNOWN unk_80CE4BC; // weak
_UNKNOWN dummy_bucket_10000; // weak
void *nl_C_LC_MONETARY = &nl_C_name; // weak
void *nl_C_LC_NUMERIC = &nl_C_name; // weak
_UNKNOWN unk_80CF9AE; // weak
_BYTE byte_80CFAB1[1231] =
{
  0,
  2,
  0,
  37,
  97,
  32,
  37,
  98,
  32,
  37,
  101,
  32,
  37,
  72,
  58,
  37,
  77,
  58,
  37,
  83,
  32,
  37,
  90,
  32,
  37,
  89,
  0,
  83,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  110,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  77,
  0,
  0,
  0,
  111,
  0,
  0,
  0,
  110,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  84,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  87,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  100,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  84,
  0,
  0,
  0,
  104,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  70,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  105,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  83,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  116,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  83,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  110,
  0,
  0,
  0,
  100,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  121,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  77,
  0,
  0,
  0,
  111,
  0,
  0,
  0,
  110,
  0,
  0,
  0,
  100,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  121,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  84,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  115,
  0,
  0,
  0,
  100,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  121,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  87,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  100,
  0,
  0,
  0,
  110,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  115,
  0,
  0,
  0,
  100,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  121,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  84,
  0,
  0,
  0,
  104,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  115,
  0,
  0,
  0,
  100,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  121,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  70,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  105,
  0,
  0,
  0,
  100,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  121,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  83,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  116,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  100,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  121,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  74,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  110,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  70,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  77,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  65,
  0,
  0,
  0,
  112,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  77,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  121,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  74,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  110,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  74,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  108,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  65,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  103,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  83,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  112,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  79,
  0,
  0,
  0,
  99,
  0,
  0,
  0,
  116,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  78,
  0,
  0,
  0,
  111,
  0,
  0,
  0,
  118,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  68,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  99,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  74,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  110,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  121,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  70,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  121,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  77,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  99,
  0,
  0,
  0,
  104,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  65,
  0,
  0,
  0,
  112,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  105,
  0,
  0,
  0,
  108,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  74,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  110,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  74,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  108,
  0,
  0,
  0,
  121,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  65,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  103,
  0,
  0,
  0,
  117,
  0,
  0,
  0,
  115,
  0,
  0,
  0,
  116,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  83,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  112,
  0,
  0,
  0,
  116,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  109,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  79,
  0,
  0,
  0,
  99,
  0,
  0,
  0,
  116,
  0,
  0,
  0,
  111,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  78,
  0,
  0,
  0,
  111,
  0,
  0,
  0,
  118,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  109,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  68,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  99,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  109,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  114,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  65,
  0,
  0,
  0,
  77,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  80,
  0,
  0,
  0,
  77,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  32,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  32,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  32,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  72,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  77,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  83,
  0,
  0,
  0,
  32,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  89,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  109,
  0,
  0,
  0,
  47,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  100,
  0,
  0,
  0,
  47,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  121,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  72,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  77,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  83,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  73,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  77,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  83,
  0,
  0,
  0,
  32,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  112,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  97,
  0,
  0,
  0,
  32,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  98,
  0,
  0,
  0,
  32,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  101,
  0,
  0,
  0,
  32,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  72,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  77,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  83,
  0,
  0,
  0,
  32,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  90,
  0,
  0,
  0,
  32,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  89,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_DWORD fpioconst_pow10[4] = { 0, 3, 4, 0 }; // weak
_UNKNOWN unk_80D0AD0; // weak
_UNKNOWN unk_80D0B90; // weak
_UNKNOWN _tens; // weak
unsigned int dword_80D0BC8[3438] =
{
  10u,
  0u,
  0u,
  100u,
  0u,
  0u,
  10000u,
  0u,
  0u,
  100000000u,
  0u,
  0u,
  1874919424u,
  2328306u,
  0u,
  0u,
  0u,
  2242703233u,
  762134875u,
  1262u,
  0u,
  0u,
  0u,
  0u,
  3211403009u,
  1849224548u,
  3668416493u,
  3913284084u,
  1593091u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  781532673u,
  64985353u,
  253049085u,
  594863151u,
  3553621484u,
  3288652808u,
  3167596762u,
  2788392729u,
  3911132675u,
  590u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2553183233u,
  3201533787u,
  3638140786u,
  303378311u,
  1809731782u,
  3477761648u,
  3583367183u,
  649228654u,
  2915460784u,
  487929380u,
  1011012442u,
  1677677582u,
  3428152256u,
  1710878487u,
  1438394610u,
  2161952759u,
  4100910556u,
  1608314830u,
  349175u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  4234999809u,
  2012377703u,
  2408924892u,
  1570150255u,
  3090844311u,
  3273530073u,
  1187251475u,
  2498123591u,
  3364452033u,
  1148564857u,
  687371067u,
  2854068671u,
  1883165473u,
  505794538u,
  2988060450u,
  3159489326u,
  2531348317u,
  3215191468u,
  849106862u,
  3892080979u,
  3288073877u,
  2242451748u,
  4183778142u,
  2995818208u,
  2477501924u,
  325481258u,
  2487842652u,
  1774082830u,
  1933815724u,
  2962865281u,
  1168579910u,
  2724829000u,
  2360374019u,
  2315984659u,
  2360052375u,
  3251779801u,
  1664357844u,
  28u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  689565697u,
  4116392818u,
  1853628763u,
  516071302u,
  2568769159u,
  365238920u,
  336250165u,
  1283268122u,
  3425490969u,
  248595470u,
  2305176814u,
  2111925499u,
  507770399u,
  2681111421u,
  589114268u,
  591287751u,
  1708941527u,
  4098957707u,
  475844916u,
  3378731398u,
  2452339615u,
  2817037361u,
  2678008327u,
  1656645978u,
  2383430340u,
  73103988u,
  448667107u,
  2329420453u,
  3124020241u,
  3625235717u,
  3208634035u,
  2412059158u,
  2981664444u,
  4117622508u,
  838560765u,
  3069470027u,
  270153238u,
  1802868219u,
  3692709886u,
  2161737865u,
  2159912357u,
  2585798786u,
  837488486u,
  4237238160u,
  2540319504u,
  3798629246u,
  3748148874u,
  1021550776u,
  2386715342u,
  1973637538u,
  1823520457u,
  1146713475u,
  833971519u,
  3277251466u,
  905620390u,
  26278816u,
  2680483154u,
  2294040859u,
  373297482u,
  5996609u,
  4109575006u,
  512575049u,
  917036550u,
  1942311753u,
  2816916778u,
  3248920332u,
  1192784020u,
  3537586671u,
  2456567643u,
  2925660628u,
  759380297u,
  888447942u,
  3559939476u,
  3654687237u,
  805u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  322166785u,
  3809044581u,
  2994556223u,
  1239584207u,
  3962455841u,
  4001882964u,
  3053876612u,
  915114683u,
  2783289745u,
  785739093u,
  4253185907u,
  3931164994u,
  1370983858u,
  2553556126u,
  3360742076u,
  2255410929u,
  422849554u,
  2457422215u,
  3539495362u,
  1720790602u,
  1908931983u,
  1470596141u,
  592794347u,
  4219465164u,
  4085652704u,
  941661409u,
  2534650953u,
  885063988u,
  2355909854u,
  2812815516u,
  767256131u,
  3821757683u,
  2155151105u,
  3817418473u,
  281116564u,
  2834395026u,
  2821201622u,
  2524625843u,
  1511330880u,
  2572352493u,
  330571332u,
  2951088579u,
  2730271766u,
  4044456479u,
  4212286644u,
  2444937588u,
  3603420843u,
  2387148597u,
  1142537539u,
  3299235429u,
  1751012624u,
  861228086u,
  2873722519u,
  230498814u,
  1023297821u,
  2553128038u,
  3421129895u,
  2651917435u,
  2042981258u,
  1606787143u,
  2228751918u,
  447345732u,
  1930371132u,
  1784132011u,
  3612538790u,
  2275925090u,
  2487567871u,
  1080427616u,
  2009179183u,
  3383506781u,
  3899054063u,
  1950782960u,
  2168622213u,
  2717674390u,
  3616636027u,
  2079341593u,
  1530129217u,
  1461057425u,
  2406264415u,
  3674671357u,
  2972036238u,
  2019354295u,
  1455849819u,
  1866918619u,
  1324269294u,
  424891864u,
  2722422332u,
  2641594816u,
  1400249021u,
  3482963993u,
  3734946379u,
  225889849u,
  1891545473u,
  777383150u,
  3589824633u,
  4117601611u,
  4220028667u,
  334453379u,
  1083130821u,
  1060342180u,
  4208163139u,
  1489826908u,
  4163762246u,
  1096580926u,
  689301528u,
  2336054516u,
  1782865703u,
  4175148410u,
  3398369392u,
  2329412588u,
  3001580596u,
  59740741u,
  3202189932u,
  3351895776u,
  246185302u,
  718535188u,
  3772647488u,
  4151666556u,
  4055698133u,
  2461934110u,
  2281316281u,
  3466396836u,
  3536023465u,
  1064267812u,
  2955456354u,
  2423805422u,
  3627960790u,
  1325057500u,
  3876919979u,
  2009959531u,
  175455101u,
  184092852u,
  2358785571u,
  3842977831u,
  2485266289u,
  487121622u,
  4159252710u,
  4075707558u,
  459389244u,
  300652075u,
  2521346588u,
  3458976673u,
  888631636u,
  2076098096u,
  3844514585u,
  2363697580u,
  3729421522u,
  3051115477u,
  649395u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  711442433u,
  3564261005u,
  2399042279u,
  4170849936u,
  4010295575u,
  1423987028u,
  330414929u,
  1349249065u,
  4213813618u,
  3852031822u,
  4040843590u,
  2154565331u,
  3094013374u,
  1159028371u,
  3227065538u,
  2115927092u,
  2085102554u,
  488590542u,
  2609619432u,
  3602898805u,
  3812736528u,
  3269439096u,
  23816114u,
  253984538u,
  1035905997u,
  2942969204u,
  3400787671u,
  338562688u,
  1637191975u,
  740509713u,
  2264962817u,
  3410753922u,
  4162231428u,
  2282041228u,
  1759373012u,
  3155367777u,
  4278913285u,
  1420532801u,
  1981002276u,
  438054990u,
  1006507643u,
  1142697287u,
  1332538012u,
  2029019521u,
  3949305784u,
  818392641u,
  2491288846u,
  2716584663u,
  3648886102u,
  556814413u,
  444795339u,
  4071412999u,
  1066321706u,
  4253169466u,
  2510832316u,
  672091442u,
  4083256000u,
  2165985028u,
  1841538484u,
  3549854235u,
  364431512u,
  3707648143u,
  1162785440u,
  2268641545u,
  281340310u,
  735693841u,
  848809228u,
  1700785200u,
  2919703985u,
  4094234344u,
  58530286u,
  965505005u,
  1000010347u,
  3381961808u,
  3040089923u,
  1973852082u,
  2890971585u,
  1019960210u,
  4292895237u,
  2821887841u,
  3756675650u,
  3951282907u,
  3885870583u,
  1008791145u,
  503998487u,
  1881258362u,
  1949332730u,
  392996726u,
  2012973814u,
  3970014187u,
  2461725150u,
  2942547730u,
  3728066699u,
  2766901132u,
  3778532841u,
  1085564064u,
  2278673896u,
  1116879805u,
  3448726271u,
  774279411u,
  157211670u,
  1506320155u,
  531168605u,
  1362654525u,
  956967721u,
  2148871960u,
  769186085u,
  4186232894u,
  2055679604u,
  3248365487u,
  3981268013u,
  3975787984u,
  2489510517u,
  3309046495u,
  212771124u,
  933418041u,
  3371839114u,
  562115198u,
  1853601831u,
  757336096u,
  1354633440u,
  1486083256u,
  2872126393u,
  522920738u,
  1141587749u,
  3210903262u,
  1926940553u,
  3054024853u,
  2021162538u,
  2262742000u,
  1877899947u,
  3147002868u,
  669840763u,
  4158174590u,
  4238502559u,
  1023731922u,
  3386840011u,
  829588074u,
  3449720188u,
  2835142880u,
  2999162007u,
  813056473u,
  482949569u,
  638108879u,
  3067201471u,
  1026714238u,
  4004452838u,
  2383667807u,
  3999477803u,
  771648919u,
  630660440u,
  3827121348u,
  176185980u,
  2878191002u,
  2666149832u,
  3909811063u,
  2429163983u,
  2665690412u,
  907266128u,
  4269332098u,
  2022665808u,
  1527122180u,
  3072053668u,
  1072477492u,
  3006022924u,
  549664855u,
  2800340954u,
  37352654u,
  1212772743u,
  2711280533u,
  3029527946u,
  2511120040u,
  1305308377u,
  3474662224u,
  4226330922u,
  442988428u,
  954940108u,
  3274548099u,
  4212288177u,
  2688499880u,
  3982226758u,
  3922609956u,
  1279948029u,
  1939943640u,
  3650489901u,
  2733364929u,
  2494263275u,
  1864579964u,
  1225941120u,
  2390465139u,
  1267503249u,
  3533240729u,
  904410805u,
  2842550015u,
  2517736241u,
  1796069820u,
  3335274381u,
  673539835u,
  1924694759u,
  3598098235u,
  2792633405u,
  16535707u,
  3703535497u,
  3592841791u,
  2929082877u,
  1317622811u,
  294990855u,
  1396706563u,
  2383271770u,
  3853857605u,
  277813677u,
  277580220u,
  1101318484u,
  3761974115u,
  1132150143u,
  2544692622u,
  3419825776u,
  743770306u,
  1695464553u,
  1548693232u,
  2421159615u,
  2575672031u,
  2678971806u,
  1591267897u,
  626546738u,
  3823443129u,
  267710932u,
  1455435162u,
  2353985540u,
  3248523795u,
  335348168u,
  3872552561u,
  2814522612u,
  2634118860u,
  3503767026u,
  1301019273u,
  1414467789u,
  722985138u,
  3070909565u,
  4253482569u,
  3744939841u,
  558142907u,
  2229819389u,
  13833173u,
  77003966u,
  2763671364u,
  3905603970u,
  2931990126u,
  2280419384u,
  1879090457u,
  2934846267u,
  4284933164u,
  2331863845u,
  62191163u,
  3178861020u,
  1522063815u,
  785672270u,
  1215568492u,
  2936443917u,
  802972489u,
  2956820173u,
  3916732783u,
  2893572089u,
  1391232801u,
  3168640330u,
  2396859648u,
  894950918u,
  1103583736u,
  961991865u,
  2807302642u,
  305977505u,
  3054505899u,
  1048256994u,
  781017659u,
  2459278754u,
  3164823415u,
  537658277u,
  905753687u,
  464963300u,
  4149131560u,
  1029507924u,
  2278300961u,
  1231291503u,
  414073408u,
  3630740085u,
  2345841814u,
  475358196u,
  3258243317u,
  4167625072u,
  4178911231u,
  2927355042u,
  655438830u,
  3138378018u,
  623200562u,
  2785714112u,
  273403236u,
  807993669u,
  98u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1691320321u,
  2671006246u,
  1682531301u,
  2072858707u,
  1240508969u,
  3108358191u,
  1125119096u,
  2470144952u,
  1610099978u,
  1690632660u,
  1941696884u,
  2663506355u,
  1006364675u,
  3909158537u,
  4147711374u,
  1072663936u,
  4078768933u,
  745751659u,
  4123687570u,
  471458681u,
  655028926u,
  4113407388u,
  3945524552u,
  985625313u,
  1254424514u,
  2127508744u,
  570530434u,
  945388122u,
  3194649404u,
  2589065070u,
  2731705399u,
  202030749u,
  2090780394u,
  3348662271u,
  1481754777u,
  1130635472u,
  4025144705u,
  1924486271u,
  2578567861u,
  125491448u,
  1558036315u,
  994248173u,
  3817216711u,
  763950077u,
  1030439870u,
  959586474u,
  3845661701u,
  483795093u,
  1637944470u,
  2275463649u,
  3398804829u,
  1758016486u,
  2665513698u,
  2004912571u,
  1094885097u,
  4223064276u,
  3307819021u,
  651121777u,
  1757003305u,
  3603542336u,
  129917786u,
  2215974994u,
  3042386306u,
  2205352757u,
  3944939700u,
  3710987569u,
  97967515u,
  1217242524u,
  930630949u,
  3660328512u,
  1787663098u,
  1784141600u,
  2500542892u,
  4034561586u,
  3444961378u,
  785043562u,
  3869499367u,
  885623728u,
  2625011087u,
  3053789617u,
  1965731793u,
  3900511934u,
  2648823592u,
  3851062028u,
  3321968688u,
  799195417u,
  1011847510u,
  1369129160u,
  1348009103u,
  2876796955u,
  2915408967u,
  3305284948u,
  263399535u,
  1715990604u,
  2645821294u,
  1587844552u,
  2624912049u,
  3035631499u,
  2306636348u,
  3499275462u,
  675152704u,
  854794152u,
  4004972748u,
  1739996642u,
  1333476491u,
  4012621867u,
  3658792931u,
  3297985728u,
  2864481726u,
  3066357406u,
  785287846u,
  1671499798u,
  433044045u,
  1919608025u,
  264833858u,
  3999983367u,
  1116778570u,
  1301982149u,
  4213901070u,
  4081649357u,
  536169226u,
  1389008649u,
  188923873u,
  373495152u,
  2551132278u,
  1800758715u,
  3951840330u,
  2632334454u,
  3118778225u,
  1034046547u,
  1862428410u,
  3037609062u,
  1994608505u,
  29051798u,
  2571685694u,
  264151332u,
  2260643090u,
  2717535964u,
  3508441116u,
  3283713017u,
  1903365635u,
  923575694u,
  1219598101u,
  2288281570u,
  3676533911u,
  1014136356u,
  555142354u,
  2389170030u,
  4185108175u,
  884862419u,
  836141292u,
  2957159173u,
  1997444768u,
  4233903127u,
  2876184692u,
  3089125070u,
  1480848293u,
  1097600237u,
  299700527u,
  2507669891u,
  2982628312u,
  2114881043u,
  2529576251u,
  2812279824u,
  2987750993u,
  4241938954u,
  2204775591u,
  1037094060u,
  829315638u,
  1231047149u,
  52608178u,
  3735136637u,
  3455232602u,
  962039123u,
  488286513u,
  50685385u,
  3516451821u,
  843975207u,
  1572355722u,
  675489076u,
  2428445672u,
  1555117248u,
  3708476086u,
  10375249u,
  4172112346u,
  2117510871u,
  2227658327u,
  3187664554u,
  3050656558u,
  328034318u,
  3179601324u,
  1247769761u,
  3439263953u,
  1431538938u,
  2962525068u,
  1213366289u,
  3813013550u,
  2651093719u,
  1860661503u,
  3933716208u,
  264320617u,
  789980519u,
  2257856172u,
  102000748u,
  977269860u,
  1113845122u,
  3008928583u,
  1461738106u,
  557786285u,
  2926560363u,
  1038106190u,
  3643478847u,
  828004507u,
  457818698u,
  1933056971u,
  373408056u,
  2076808229u,
  3160935130u,
  2781854874u,
  2519636100u,
  177606000u,
  4237103862u,
  3977834316u,
  1621936232u,
  2599050516u,
  319893558u,
  3343370366u,
  765044144u,
  976657331u,
  7026264u,
  294277429u,
  3829376742u,
  3029627280u,
  2705178718u,
  3614653880u,
  230519152u,
  3288033233u,
  293525479u,
  3805751881u,
  3227511198u,
  2520308544u,
  3648103003u,
  1111086184u,
  437622105u,
  2232033852u,
  3239146386u,
  584244184u,
  1450926016u,
  2462430443u,
  3226534010u,
  298582169u,
  4214576928u,
  1762099469u,
  964985185u,
  1585788148u,
  1641127666u,
  787006566u,
  2315956284u,
  3258232694u,
  2275058964u,
  2541003317u,
  1508235863u,
  2613339827u,
  4080647514u,
  1152057965u,
  3149266279u,
  731345410u,
  914737650u,
  65395712u,
  1884566942u,
  1379520432u,
  2611027720u,
  4163073378u,
  2619704967u,
  2746552541u,
  1388822415u,
  3005141199u,
  843440249u,
  4288674003u,
  3136174279u,
  4051522914u,
  4144149433u,
  3427566947u,
  3419023197u,
  3758479825u,
  3893877676u,
  96899594u,
  1657725776u,
  253618880u,
  434129337u,
  1499045748u,
  2996992534u,
  4036042074u,
  2110713869u,
  906222950u,
  928326225u,
  2541827893u,
  1604330202u,
  226792470u,
  4022228930u,
  815850898u,
  1466012310u,
  3377712199u,
  292769859u,
  2822055597u,
  3225701344u,
  3052947004u,
  385831222u,
  705324593u,
  4030158636u,
  3540280538u,
  2982120874u,
  2136414455u,
  255762046u,
  3852783591u,
  3262064164u,
  2358991588u,
  3756586117u,
  4143612643u,
  3326743817u,
  2897365738u,
  807711264u,
  3719310016u,
  3721264861u,
  3627337076u,
  944539331u,
  3640975513u,
  3712525681u,
  1162911839u,
  2008243316u,
  2179489649u,
  2867584109u,
  261861553u,
  3570253908u,
  2062868357u,
  2220328623u,
  3857004679u,
  3744109002u,
  4138041873u,
  1451860932u,
  2364975637u,
  2802161722u,
  2680106834u,
  753401584u,
  1223182946u,
  1245401957u,
  4163377735u,
  3565815922u,
  2216942838u,
  4036140094u,
  71979081u,
  3924559643u,
  400477238u,
  551750683u,
  1174153235u,
  859969898u,
  1185921017u,
  1711399735u,
  812991545u,
  4051735761u,
  3549118738u,
  1631653329u,
  3631835958u,
  3648867800u,
  1206500363u,
  2155893137u,
  361030362u,
  3454286017u,
  2505909489u,
  1083595169u,
  453595313u,
  1510564703u,
  1706163902u,
  1632924345u,
  1381875722u,
  1661526119u,
  1082778324u,
  3571910052u,
  1140625929u,
  851544870u,
  1145546234u,
  2938573139u,
  907528924u,
  1304752338u,
  1764668294u,
  1788942063u,
  1700368828u,
  104979467u,
  1413911959u,
  3327497828u,
  1956384744u,
  1272712474u,
  2815637534u,
  3307809377u,
  1320574940u,
  1111968962u,
  4073107827u,
  434096622u,
  169451929u,
  3201183459u,
  3331028877u,
  2852366972u,
  3369830128u,
  2924794558u,
  3106537952u,
  3739481231u,
  1612955817u,
  4138608722u,
  2721281595u,
  2755775390u,
  843505117u,
  982234295u,
  1157276611u,
  814674632u,
  4246504726u,
  3532006708u,
  992340967u,
  1647538031u,
  204696133u,
  193866982u,
  3899126129u,
  300851698u,
  1379496684u,
  1759463683u,
  1354782756u,
  1374637239u,
  3410883240u,
  1073406229u,
  3038431791u,
  1053909855u,
  3607043270u,
  173719711u,
  3733903830u,
  171820911u,
  1573050589u,
  932781534u,
  4183534770u,
  2158849555u,
  372245998u,
  3573073830u,
  841339264u,
  2759200520u,
  1610547277u,
  2603293319u,
  3890906486u,
  1557138278u,
  3964109906u,
  677238797u,
  537994297u,
  1124184993u,
  4287078344u,
  4207654540u,
  2943022776u,
  2977947524u,
  3255359985u,
  4098397558u,
  2274666217u,
  2915862060u,
  243524940u,
  2467726756u,
  2869020032u,
  507521339u,
  3403121914u,
  522051455u,
  1803903108u,
  3471254194u,
  473535371u,
  1948602036u,
  3352095732u,
  3116527002u,
  1795743673u,
  775867940u,
  2551469548u,
  3757442064u,
  3162525227u,
  3765412747u,
  3040105484u,
  1927625810u,
  48214767u,
  2997207130u,
  1342349989u,
  2536583992u,
  1501320191u,
  3592287317u,
  887432730u,
  967585477u,
  3334212779u,
  948663609u,
  1064513472u,
  15386372u,
  2465931737u,
  3230242590u,
  3036652803u,
  2063155087u,
  1927500726u,
  2821790499u,
  2187774383u,
  501520074u,
  3688568496u,
  3606711121u,
  2576459247u,
  3176542345u,
  378322447u,
  156541411u,
  1400607301u,
  1406179107u,
  677848877u,
  2253753529u,
  193196070u,
  4207435024u,
  4166396241u,
  509467541u,
  2906024136u,
  1221753746u,
  3375413222u,
  431327897u,
  2749265123u,
  2848827671u,
  3412997614u,
  2051920238u,
  1283516885u,
  1300498239u,
  1957256104u,
  2634010560u,
  3531900395u,
  360276850u,
  1461184973u,
  2012063967u,
  2873572430u,
  2914608609u,
  4289554777u,
  1539331673u,
  1859532928u,
  4213441063u,
  538215691u,
  3512720863u,
  4258743698u,
  3040408445u,
  982396546u,
  343095663u,
  4138069496u,
  1021581857u,
  214185242u,
  1968079460u,
  2864275059u,
  3347192726u,
  4096783459u,
  3259169450u,
  3707808869u,
  142485006u,
  399610869u,
  230556456u,
  2219467721u,
  4191227798u,
  2242548189u,
  3136366572u,
  179755707u,
  3464881829u,
  452317775u,
  3887426070u,
  3446430233u,
  1473370015u,
  1576807208u,
  3964523248u,
  419325089u,
  2373067114u,
  1596072055u,
  1928415752u,
  3635452689u,
  1005598891u,
  3335462724u,
  3290848636u,
  3669078247u,
  1178176812u,
  2110774376u,
  3068593619u,
  1253036518u,
  908857731u,
  3631223047u,
  4138506423u,
  2903592318u,
  3596915748u,
  3289036113u,
  3721512676u,
  2704409359u,
  3386016968u,
  3676268074u,
  2185259502u,
  1096257611u,
  3360076717u,
  3548676554u,
  170167319u,
  3360064287u,
  3899940843u,
  9640u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  161415169u,
  1102407805u,
  3422362478u,
  2356538979u,
  1259937002u,
  3612513965u,
  596957194u,
  515234459u,
  413140205u,
  1551498969u,
  937668636u,
  3982991800u,
  2027530004u,
  706360533u,
  2411626253u,
  1797076246u,
  3850126314u,
  2810336897u,
  3357356776u,
  3555137249u,
  1485179648u,
  2799254885u,
  2199231639u,
  18031407u,
  3591512681u,
  1931592608u,
  3194655475u,
  3394021843u,
  3521279653u,
  3236254051u,
  2958628310u,
  2071623873u,
  263064740u,
  1654906699u,
  145484911u,
  318967057u,
  3561370506u,
  1625082098u,
  1594216917u,
  635566582u,
  77859822u,
  2139910419u,
  2297724608u,
  1486878106u,
  814495329u,
  3931138209u,
  2516258959u,
  115899903u,
  358213441u,
  3570707420u,
  31494884u,
  3994456188u,
  1518041318u,
  3879381963u,
  342603744u,
  2906073225u,
  1332429765u,
  4249484317u,
  254408073u,
  3547566675u,
  3295959638u,
  3802987714u,
  3613182919u,
  3989837517u,
  2891604960u,
  4018326739u,
  3008514414u,
  735756228u,
  1530725377u,
  28318079u,
  2917756220u,
  702096701u,
  431930810u,
  1942317851u,
  626948901u,
  522944286u,
  2775205246u,
  1654245430u,
  1550044280u,
  2731177158u,
  1552285331u,
  3998686186u,
  1351492961u,
  766898640u,
  2986206889u,
  2847439769u,
  1337526839u,
  4146466567u,
  4284007933u,
  1458470551u,
  3132750406u,
  1122433486u,
  2021748595u,
  460771943u,
  4256352040u,
  1164333468u,
  2920799629u,
  3119950175u,
  483734433u,
  1729498602u,
  341003180u,
  4242077945u,
  4092760093u,
  1888165642u,
  2284389947u,
  2488771039u,
  2408000161u,
  918262581u,
  3043437582u,
  3632910601u,
  2126920298u,
  2469422706u,
  968283223u,
  2184817512u,
  4012778758u,
  3188554271u,
  1112651317u,
  100029730u,
  250658133u,
  52979857u,
  742569572u,
  2551577516u,
  1193268753u,
  2169386908u,
  2111321245u,
  2762103770u,
  2558965836u,
  28959645u,
  1518133666u,
  2922499017u,
  2261810994u,
  2213515183u,
  3060489078u,
  1481052127u,
  2530581363u,
  1365346441u,
  3695185143u,
  4237168582u,
  2942908016u,
  161517142u,
  2440265190u,
  1962312417u,
  235115071u,
  2139800941u,
  1946210260u,
  2382750874u,
  1290529340u,
  944640356u,
  3001302412u,
  3037388894u,
  252395225u,
  2751488291u,
  1678995767u,
  1318721844u,
  88097024u,
  3647085542u,
  2468979285u,
  1546944187u,
  1976298267u,
  3867423851u,
  2215636565u,
  3127547731u,
  4097324790u,
  1615879035u,
  860525176u,
  4251797341u,
  1572423521u,
  645100970u,
  3239108960u,
  38759779u,
  784950800u,
  2845527065u,
  3105212916u,
  864877968u,
  4029589574u,
  3118799369u,
  2928840625u,
  4209188232u,
  440252193u,
  2222316838u,
  1466517661u,
  2060764167u,
  172616176u,
  887256520u,
  1023892867u,
  493031754u,
  1923703829u,
  1805183303u,
  491785055u,
  3574586422u,
  337531013u,
  2272596597u,
  3884202036u,
  578322590u,
  2975617774u,
  2491083474u,
  4275796738u,
  1368897348u,
  1692441512u,
  2286538918u,
  599698053u,
  300726547u,
  259970663u,
  1570261064u,
  2674078186u,
  1484951785u,
  2722981073u,
  2114578917u,
  844701747u,
  61145567u,
  667054246u,
  3141400376u,
  1014782576u,
  1099989820u,
  2102131188u,
  2162546843u,
  2818335124u,
  4210013795u,
  1659185993u,
  3551964621u,
  2157332220u,
  523040570u,
  3076910415u,
  1394494459u,
  2462909938u,
  2937246118u,
  586035443u,
  953815156u,
  3982772155u,
  443700744u,
  2951881427u,
  2050781012u,
  3165100630u,
  2064551186u,
  474374341u,
  1848956667u,
  1866996383u,
  4271753628u,
  4169718658u,
  3628637856u,
  2226438394u,
  3235816065u,
  2541389187u,
  2922440839u,
  2350693612u,
  491276491u,
  249614647u,
  3490820348u,
  2494954825u,
  1200455124u,
  1030222567u,
  2896913069u,
  179627562u,
  503086581u,
  3526247763u,
  2265648757u,
  1236774913u,
  460570477u,
  310411261u,
  3701409591u,
  1866356818u,
  3236098640u,
  2481335882u,
  1301718362u,
  3251691909u,
  2208376539u,
  420188539u,
  4022325315u,
  3353286249u,
  2401613533u,
  543353545u,
  1198266278u,
  3412128376u,
  625345411u,
  243657110u,
  3666609598u,
  1869056564u,
  1763729972u,
  4120635689u,
  424130202u,
  247439643u,
  2432533282u,
  365029823u,
  3600396780u,
  3002086463u,
  1879166978u,
  3480677034u,
  3229059765u,
  1366551976u,
  3081767138u,
  1308681414u,
  1348288333u,
  2581410842u,
  480071186u,
  1341876600u,
  1196187285u,
  1855760093u,
  3659135288u,
  3806176992u,
  2564567438u,
  3661979220u,
  1063761974u,
  568596508u,
  2843646564u,
  504886869u,
  1383729339u,
  387111969u,
  1747546797u,
  4379222u,
  3435048433u,
  3393813398u,
  2250152416u,
  227190149u,
  4004574800u,
  3703817178u,
  1349187454u,
  1575720808u,
  2090688702u,
  3923343543u,
  934510229u,
  2007829396u,
  1114931061u,
  129909444u,
  1834996478u,
  1284267433u,
  227525245u,
  254792975u,
  214917155u,
  1532364095u,
  990970301u,
  1456687366u,
  3237923367u,
  1979883856u,
  3297283492u,
  1100660308u,
  1456539187u,
  3345031405u,
  2377204003u,
  3059148405u,
  1948159862u,
  3533158734u,
  2529062689u,
  912409501u,
  2604703271u,
  1713788749u,
  905967914u,
  3210052101u,
  1776297017u,
  3194501303u,
  1677786444u,
  2685363402u,
  525014410u,
  2652918446u,
  80520536u,
  4217300638u,
  1490707532u,
  2532470303u,
  2326893569u,
  3202474347u,
  3985373448u,
  791153060u,
  3574311851u,
  1851258854u,
  1795852585u,
  4147471409u,
  3041545468u,
  2585594564u,
  1872746187u,
  2204892152u,
  994243689u,
  2345869609u,
  1074862955u,
  2082967473u,
  3007699285u,
  4280275336u,
  3542929724u,
  4159453856u,
  931788690u,
  2876276644u,
  1299817663u,
  3013774571u,
  3653389710u,
  1899289308u,
  115534654u,
  3619704694u,
  3011106833u,
  725290684u,
  2358574131u,
  2727039915u,
  3228327169u,
  3640673066u,
  2146079178u,
  1831907336u,
  1686396680u,
  2037338953u,
  4259604605u,
  4169727591u,
  3758386262u,
  2923962743u,
  3466119953u,
  2220428358u,
  535512064u,
  1847304859u,
  4281275921u,
  4148117148u,
  827968140u,
  881088792u,
  1458629958u,
  3083930674u,
  3651234305u,
  1079746193u,
  1022246436u,
  2268718246u,
  716412596u,
  1058764913u,
  159604221u,
  2356824223u,
  361936714u,
  98532481u,
  244137783u,
  2787111539u,
  1756534306u,
  631034679u,
  1140819110u,
  2177863657u,
  1450104963u,
  1212317638u,
  902272040u,
  3486710617u,
  2843643019u,
  1963634392u,
  853396003u,
  2860583151u,
  2533097465u,
  2714778026u,
  3821925768u,
  1206353408u,
  3446357979u,
  3878328960u,
  2589073746u,
  3986711171u,
  4011283984u,
  2792411041u,
  866117316u,
  771486702u,
  3268932923u,
  2460241447u,
  3427263664u,
  3751940796u,
  3595535305u,
  2575193205u,
  3037927871u,
  2684347801u,
  532858806u,
  4015392231u,
  2200005085u,
  4273389134u,
  3214024136u,
  1623063325u,
  1920311181u,
  893841312u,
  34532333u,
  3400220004u,
  3676349182u,
  3121748214u,
  2998283229u,
  822210544u,
  2413714682u,
  775000595u,
  2770408658u,
  2280566079u,
  3741888989u,
  2771940930u,
  1953445072u,
  3614197828u,
  1287914263u,
  3841362377u,
  3084345457u,
  1608561826u,
  1847359765u,
  3352575827u,
  1056669041u,
  109959430u,
  900161375u,
  1697478512u,
  1963935239u,
  1688298860u,
  918736782u,
  558724491u,
  2471030675u,
  3825568120u,
  2524231667u,
  274139915u,
  3187325583u,
  3471875543u,
  2838177311u,
  119284150u,
  3421222943u,
  4096257388u,
  1143114966u,
  1709535183u,
  1345766496u,
  2912001519u,
  3439166603u,
  1641109670u,
  1965546659u,
  1290994777u,
  1350914165u,
  2802711817u,
  893449642u,
  894925531u,
  3048881486u,
  896756815u,
  3455805599u,
  4025023106u,
  2544569802u,
  1371353075u,
  2007498396u,
  822576236u,
  1029802881u,
  3165099940u,
  4234057297u,
  3806367676u,
  4159207711u,
  1999576256u,
  2084728733u,
  148205448u,
  8438699u,
  233743971u,
  3872681670u,
  2110410423u,
  1801985437u,
  3657855755u,
  1257300210u,
  59503720u,
  1376351331u,
  3390690050u,
  3154754458u,
  2857742001u,
  1038959667u,
  4068030650u,
  1045133413u,
  673803239u,
  2130273044u,
  2048742860u,
  3742067527u,
  3454081106u,
  3470632381u,
  4027190963u,
  1925847691u,
  1380038002u,
  2952986060u,
  4287142067u,
  3297216610u,
  3018347378u,
  3209415209u,
  2116022085u,
  4074254729u,
  257173423u,
  1021287941u,
  1975183493u,
  4133226156u,
  2624694016u,
  2736021164u,
  3731077810u,
  1982159807u,
  1853979622u,
  1282069456u,
  632002869u,
  3915313912u,
  298649946u,
  3578755294u,
  2684464766u,
  3011681739u,
  1522342077u,
  418094238u,
  2913191172u,
  3823326572u,
  3545528746u,
  1368501343u,
  572006828u,
  3369195987u,
  825920593u,
  143409096u,
  3242631780u,
  2975116269u,
  2457164741u,
  882819219u,
  4182424151u,
  1104513132u,
  173725874u,
  917219659u,
  2285528920u,
  2846696095u,
  1566836378u,
  88479535u,
  57072150u,
  3279982244u,
  186065923u,
  1894818357u,
  4202786406u,
  1338947623u,
  2791297002u,
  377181909u,
  4264271794u,
  4274219981u,
  2823572681u,
  3449172495u,
  1041401220u,
  166570168u,
  2448205093u,
  2127028603u,
  3158687452u,
  3242210036u,
  2615576999u,
  783420352u,
  4292812540u,
  351241055u,
  3331746905u,
  3447164376u,
  1609240379u,
  601126677u,
  3595274184u,
  1461888336u,
  1653092760u,
  827988619u,
  1687033830u,
  1266589050u,
  732183848u,
  1741343364u,
  1948189592u,
  1852178777u,
  1041686953u,
  1037974597u,
  2772326062u,
  3354069743u,
  1060762430u,
  2020941171u,
  1166110200u,
  1650946295u,
  3407336077u,
  2426308596u,
  2477288122u,
  3252482856u,
  438193378u,
  3633696834u,
  3119963497u,
  3137399541u,
  2898491015u,
  3395327352u,
  1531514169u,
  4172836172u,
  4067655408u,
  960601965u,
  1764129728u,
  1917995523u,
  1857052868u,
  3686801043u,
  688928177u,
  2207796564u,
  4134776197u,
  3767319584u,
  531777813u,
  1481114534u,
  3780885719u,
  1082711477u,
  3569493314u,
  739771418u,
  2769515217u,
  2998561204u,
  580462655u,
  3440493206u,
  635229939u,
  2891243299u,
  614704478u,
  2011262493u,
  3016573275u,
  3114108352u,
  1232859079u,
  3910227171u,
  1936051595u,
  3041984682u,
  249993707u,
  4228458406u,
  4021515486u,
  2328537360u,
  2209615421u,
  3661561862u,
  2240848009u,
  3335396213u,
  1425473312u,
  4255315955u,
  3534444790u,
  3497409389u,
  1823417621u,
  622420525u,
  3278979159u,
  2556650383u,
  3925916495u,
  166349389u,
  3869108589u,
  1795292767u,
  2516672933u,
  1386099436u,
  4163242729u,
  27492074u,
  1769014647u,
  1520464239u,
  3409949146u,
  1113652954u,
  2738861968u,
  1979789173u,
  616621502u,
  319752622u,
  780346332u,
  1552862070u,
  399216402u,
  1075535708u,
  1594516448u,
  1205949962u,
  3696732038u,
  3994253268u,
  579763941u,
  178427065u,
  2930165044u,
  1437662767u,
  2452435338u,
  4043880306u,
  4049329654u,
  3753285378u,
  3443755598u,
  2430720870u,
  1481434273u,
  1452209867u,
  1776639901u,
  1839429306u,
  1554432265u,
  1170727572u,
  3380065257u,
  3478875148u,
  493438105u,
  297043886u,
  3481483692u,
  3165899886u,
  1354246368u,
  74125425u,
  1459875085u,
  744577350u,
  1913460240u,
  2835930064u,
  1949023795u,
  583038690u,
  1217817190u,
  487387044u,
  501121439u,
  1611879103u,
  3107392569u,
  2777009226u,
  3951394708u,
  1513058822u,
  1068395352u,
  1238175519u,
  2028337981u,
  462017654u,
  1961485915u,
  3984757851u,
  3075368067u,
  692176089u,
  2114484940u,
  1448876252u,
  436859621u,
  3209481533u,
  3540314487u,
  2770494237u,
  1629697934u,
  1159139483u,
  3085183066u,
  1274127622u,
  1649935298u,
  1748071160u,
  3360584532u,
  1066019601u,
  2110860169u,
  3980526737u,
  2355727115u,
  2555640727u,
  2519824251u,
  3063407049u,
  1594003205u,
  1359184144u,
  2421551189u,
  820139491u,
  3805331894u,
  3113234974u,
  2835215569u,
  4283285828u,
  1377448022u,
  344562144u,
  2819693670u,
  2848548946u,
  2170025224u,
  1262045844u,
  2698792433u,
  2498506387u,
  1852504662u,
  2411889527u,
  4147116548u,
  3291813999u,
  4178872503u,
  2365816687u,
  2828659742u,
  1215657767u,
  1090631186u,
  3100587901u,
  2779074152u,
  3025601897u,
  717594784u,
  104701181u,
  2085637236u,
  4054157388u,
  177936725u,
  2366345663u,
  3858138671u,
  2046776161u,
  248763279u,
  3338482171u,
  2682335687u,
  2243544648u,
  2414604980u,
  2390222955u,
  2569775118u,
  1447205254u,
  1749583770u,
  1619844517u,
  1041043566u,
  1967861774u,
  622855542u,
  2949978459u,
  1563929305u,
  3894348089u,
  3758766350u,
  3740181002u,
  4127125694u,
  3050639701u,
  1848103283u,
  2658331599u,
  3078023544u,
  3110533050u,
  156369464u,
  1919714312u,
  860351429u,
  1708975522u,
  1053262647u,
  2358433600u,
  1021174782u,
  852159635u,
  3523443118u,
  1092347921u,
  1098212736u,
  1928993725u,
  2837521843u,
  2227449604u,
  3712935422u,
  975540780u,
  2521065555u,
  1236089824u,
  679491181u,
  478419710u,
  4058026009u,
  4220542945u,
  2756816217u,
  1000984777u,
  1457204892u,
  2753829362u,
  3911313312u,
  1016741029u,
  2911806325u,
  3469201553u,
  2579347776u,
  1199502735u,
  2320053191u,
  2992212877u,
  4117077495u,
  3484163612u,
  866092872u,
  3802155691u,
  3777146943u,
  1169977143u,
  3388926768u,
  2624957088u,
  3241940814u,
  245389405u,
  3696802740u,
  982957402u,
  539300994u,
  1014657357u,
  1768462315u,
  1824013163u,
  2742936582u,
  994667359u,
  937909610u,
  940430210u,
  236605756u,
  3659987657u,
  4064641892u,
  313902826u,
  2043584071u,
  535952575u,
  3195825798u,
  1504094138u,
  2372990229u,
  2490766419u,
  1795482661u,
  2271805362u,
  480637989u,
  1067353095u,
  996413828u,
  1603233622u,
  1655809445u,
  1455169824u,
  3521501800u,
  401799704u,
  2362334765u,
  2713492486u,
  2385055665u,
  2301489583u,
  2903554248u,
  3023983895u,
  3495523337u,
  1141359503u,
  1241648513u,
  4272540086u,
  3638618070u,
  3585256185u,
  3730742080u,
  3661950282u,
  1171701569u,
  2276080800u,
  3324842748u,
  1191750856u,
  270609958u,
  219293695u,
  4276836162u,
  1570776400u,
  3597035751u,
  492234209u,
  851580396u,
  2921204719u,
  2131004286u,
  1489037602u,
  720012825u,
  1478826668u,
  3152086053u,
  2717820214u,
  773690983u,
  3526617981u,
  3477298187u,
  2959686759u,
  1641617642u,
  2420034032u,
  3603228844u,
  251336584u,
  2953416539u,
  386521208u,
  1007858526u,
  1064100279u,
  2712928084u,
  2324659643u,
  929074538u,
  1944606270u,
  2738029888u,
  1692403529u,
  3955215033u,
  2371660537u,
  1002994814u,
  3987914132u,
  586741293u,
  3864452803u,
  3311940130u,
  1728845350u,
  2483592831u,
  1110922287u,
  1204982848u,
  801432880u,
  2216248350u,
  2334690732u,
  2140292601u,
  2813310185u,
  2316657933u,
  137027319u,
  822406937u,
  71066334u,
  184499653u,
  2127365685u,
  3890743947u,
  3764391853u,
  1301184972u,
  2179724512u,
  4119323407u,
  2067213047u,
  764382368u,
  3739294831u,
  3546434332u,
  4172137510u,
  3399347181u,
  1545789007u,
  909440888u,
  4209186923u,
  2901980565u,
  3619661663u,
  3986198u,
  3154001142u,
  2955135824u,
  3306182049u,
  6541309u,
  2475072119u,
  1373643476u,
  4224641808u,
  1367819646u,
  278785993u,
  1731760856u,
  3778870754u,
  3567923826u,
  3231482164u,
  3213471067u,
  52893723u,
  156311239u,
  2854336050u,
  3622248838u,
  3826812341u,
  1181826972u,
  1228744585u,
  327599398u,
  3587320412u,
  3472744388u,
  3478726684u,
  2459385510u,
  1321092086u,
  3938829997u,
  1827965309u,
  3645932192u,
  2194560554u,
  686156221u,
  685306075u,
  3723521665u,
  1887109478u,
  2108571392u,
  4227167594u,
  56247936u,
  1326530818u,
  3887745843u,
  1368456927u,
  275412372u,
  3857824841u,
  2867047783u,
  3617695590u,
  68086129u,
  2434834964u,
  4095062900u,
  517769194u,
  397063228u,
  3333251965u,
  2287491265u,
  3640853447u,
  3218388747u,
  1073015566u,
  877304456u,
  3625904688u,
  2509395014u,
  1524560108u,
  2880828903u,
  549181635u,
  3250728142u,
  3868476002u,
  3316439843u,
  2147631137u,
  573752885u,
  2494762113u,
  1441822280u,
  2018941645u,
  2526472761u,
  1305916712u,
  473832256u,
  3730330547u,
  2318153337u,
  1857398744u,
  1455270042u,
  2409427094u,
  4255673691u,
  1686226919u,
  1353099221u,
  364885085u,
  1335513985u,
  3226981469u,
  1336999972u,
  2684395264u,
  1578934493u,
  2890010484u,
  3485153469u,
  4040467989u,
  431948568u,
  238743428u,
  3409804064u,
  376184382u,
  1478963165u,
  1006292895u,
  3237334598u,
  1671509288u,
  3931759411u,
  2686503564u,
  2866614635u,
  1035688509u,
  3847372615u,
  1954502122u,
  153229086u,
  1691689211u,
  1819319940u,
  130979099u,
  905823234u,
  1963518829u,
  3298142458u,
  2966494265u,
  2167487845u,
  1464106736u,
  2813730342u,
  4146266611u,
  3137954581u,
  1168353221u,
  2835588171u,
  4403080u,
  419961223u,
  3947764582u,
  3145426621u,
  1831096689u,
  3728835317u,
  227130635u,
  2280971884u,
  4144859744u,
  2592572763u,
  144864329u,
  1254584842u,
  3566616599u,
  2967068076u,
  1303595148u,
  4265180484u,
  3497751643u,
  427674491u,
  1855805053u,
  3820554258u,
  2437152497u,
  3118465708u,
  291502445u,
  4127859201u,
  1533135304u,
  162245423u,
  2974434471u,
  211917939u,
  2218555799u,
  3819551718u,
  1581236620u,
  201589998u,
  1984820637u,
  2567881410u,
  1255193148u,
  99139087u,
  3852035197u,
  3248305757u,
  1292642704u,
  3853113772u,
  3061884717u,
  1289938397u,
  1835795047u,
  117031515u,
  3177216224u,
  3053247617u,
  3611490881u,
  3435930521u,
  3331435968u,
  559601708u,
  3933450435u,
  2769413552u,
  4103725222u,
  1407351472u,
  3645128866u,
  1198859553u,
  2590914116u,
  2870032136u,
  2408263709u,
  92947107u
}; // weak
_UNKNOWN itowa_upper_digits; // weak
int itowa_lower_digits[36] =
{
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122
}; // weak
const char *const sys_errlist[] = { "Success" };
int sys_nerr = 135; // weak
__int16 word_80D51BE[] = { 0 }; // weak
__int16 _mon_yday[13] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 }; // weak
_UNKNOWN unk_80D51DA; // weak
char byte_80D5C3E[] = { '\0' }; // weak
char _strtol_ull_rem_tab[] = { '\x01' }; // weak
int _strtol_ull_max_tab[] = { -1 }; // weak
int dword_80D5C84[69] =
{
  2147483647,
  1431655765,
  1431655765,
  -1,
  1073741823,
  858993459,
  858993459,
  -1431655766,
  715827882,
  -1840700270,
  613566756,
  -1,
  536870911,
  1908874353,
  477218588,
  -1717986919,
  429496729,
  1561806289,
  390451572,
  1431655765,
  357913941,
  -1321528399,
  330382099,
  1227133513,
  306783378,
  286331153,
  286331153,
  -1,
  268435455,
  252645135,
  252645135,
  954437176,
  238609294,
  1356305461,
  226050910,
  -858993460,
  214748364,
  818089008,
  204522252,
  780903144,
  195225786,
  -2054114794,
  186737708,
  -1431655766,
  178956970,
  -687194768,
  171798691,
  -660764200,
  165191049,
  -795364315,
  159072862,
  613566756,
  153391689,
  -1925330168,
  148102320,
  -2004318072,
  143165576,
  554189328,
  138547332,
  -1,
  134217727,
  520602096,
  130150524,
  -2021161081,
  126322567,
  1349846864,
  122713351,
  477218588,
  119304647
}; // weak
int nbits_11204[16] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4 }; // weak
int nbits_11199[16] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4 }; // weak
_UNKNOWN unk_80D6140; // weak
int nbits_11199_0[16] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4 }; // weak
int tens_in_limb[10] = { 0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 }; // weak
_UNKNOWN _start___libc_IO_vtables; // weak
_UNKNOWN IO_wfile_jumps_mmap; // weak
_UNKNOWN IO_wfile_jumps; // weak
_UNKNOWN IO_file_jumps_maybe_mmap; // weak
_UNKNOWN IO_file_jumps_mmap; // weak
_UNKNOWN IO_file_jumps; // weak
_UNKNOWN IO_str_jumps; // weak
_UNKNOWN IO_helper_jumps; // weak
_UNKNOWN IO_helper_jumps_0; // weak
int (*_start___libc_atexit[2])() = { &IO_cleanup, &arena_thread_freeres }; // weak
int (*_stop___libc_atexit)() = &arena_thread_freeres; // weak
_DWORD _EH_FRAME_BEGIN__[19235] =
{
  20,
  0,
  5405185,
  17333249,
  67374107,
  392,
  164,
  28,
  -581900,
  633,
  135151872,
  239141510,
  1124303628,
  2063749134,
  1163136522,
  239425550,
  1611547996,
  1711409989,
  1163660810,
  189095950,
  1544424042,
  1163923013,
  1410231563,
  1113067074,
  239361038,
  1343113312,
  1179913793,
  239360014,
  1611547740,
  1213206088,
  239227918,
  1544438360,
  1214254660,
  240472078,
  1477330516,
  1146883652,
  239558670,
  1544440912,
  1214254661,
  241389582,
  1477330516,
  1146883652,
  239689742,
  235553616,
  1611546972,
  175835973,
  239426574,
  738656,
  56,
  196,
  -581428,
  296,
  135152384,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  178455045,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  68,
  256,
  -581184,
  781,
  135151872,
  239141511,
  1124304396,
  75698190,
  35655237,
  1277431400,
  176037902,
  239739918,
  739133736,
  1362103876,
  604929803,
  1864371794,
  241050638,
  32,
  92,
  328,
  -580472,
  184,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1743894523,
  -1676786175,
  -1609678591,
  -1878112255,
  235554817,
  247677204,
  247873808,
  247939340,
  247808264,
  34291972,
  26480194,
  26742341,
  27004481,
  27266626,
  26218056,
  20,
  424,
  -580376,
  48,
  269370112,
  265832,
  92,
  448,
  -580352,
  514,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  1544452354,
  1801457238,
  173232142,
  241325070,
  1544438872,
  39849537,
  1196428880,
  239426574,
  34294112,
  1091833501,
  1091571395,
  1091309254,
  1091047111,
  265925,
  16,
  544,
  -579920,
  86,
  0,
  28,
  564,
  -579844,
  19,
  403587840,
  1159466562,
  239607822,
  4,
  88,
  596,
  -579844,
  145,
  135151872,
  239469189,
  1191413516,
  75894798,
  -2095837631,
  806241797,
  1093930590,
  239155214,
  1074676028,
  1932529226,
  239154190,
  1007567160,
  1245711937,
  239874062,
  247677204,
  247873808,
  247939340,
  247808264,
  4,
  28,
  688,
  -579776,
  53,
  135151872,
  240190083,
  135159056,
  68076353,
  176,
  720,
  -579744,
  294,
  135151872,
  239141510,
  1208189708,
  239804430,
  739131944,
  1160777282,
  241573902,
  739132712,
  1093668420,
  239154190,
  1007567928,
  1094716996,
  239158286,
  1276003400,
  1213206085,
  239804430,
  672023588,
  1110183493,
  239480846,
  806241836,
  1093406298,
  239216654,
  806240812,
  1110707778,
  239155214,
  1074676284,
  1361055304,
  239150094,
  739132456,
  1345326657,
  239411214,
  672022820,
  1093406274,
  239611918,
  739132192,
  1211108932,
  239476750,
  672023076,
  1110183493,
  239611918,
  32,
  44,
  900,
  -579620,
  43,
  336478976,
  1159204418,
  239410190,
  470697504,
  1142951492,
  239346702,
  739132456,
  3149377,
  40,
  948,
  -579620,
  30,
  403587840,
  1109134916,
  239214606,
  672023076,
  1143737924,
  239611918,
  4,
  104,
  992,
  -579632,
  374,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537806597,
  235554818,
  247677716,
  247873808,
  247939340,
  247808264,
  1644906244,
  1142165002,
  1125125827,
  1091309254,
  1091047111,
  1157893829,
  235561739,
  247677716,
  247874320,
  247939340,
  247808264,
  738564,
  52,
  1100,
  -579356,
  69,
  135151872,
  239141511,
  1124304396,
  75698190,
  1108872806,
  239148046,
  269372192,
  202294087,
  135185985,
  68077377,
  76,
  1156,
  -112500,
  175,
  135151872,
  239272579,
  470704144,
  1210060353,
  239276046,
  537805596,
  1393561174,
  239148046,
  269371424,
  1159204419,
  239475726,
  269372704,
  1092357717,
  240001038,
  135153936,
  68076353,
  76,
  1236,
  -579412,
  125,
  135151872,
  239141510,
  1124303628,
  241111054,
  470696216,
  1210060353,
  239538190,
  470696472,
  1210060354,
  239538190,
  470696728,
  1210060355,
  172822542,
  -1019147250,
  -968816626,
  189465614,
  60,
  1316,
  -579364,
  2545,
  135151872,
  222429829,
  59196933,
  92472454,
  167857411,
  1103512003,
  214254023,
  189203460,
  167892995,
  1103512003,
  214254023,
  189072388,
  76,
  1380,
  -576868,
  1942,
  135151872,
  222429829,
  59196933,
  92472454,
  167989507,
  1103512003,
  214254023,
  188941316,
  -1022695678,
  -951990717,
  67945793,
  34292740,
  1103301335,
  1103577542,
  67374277,
  2881,
  248,
  1460,
  -574996,
  577,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1343114245,
  1163660871,
  239427598,
  1544438608,
  1214254657,
  239424526,
  1544438104,
  1113591362,
  239232014,
  1812873832,
  1114639937,
  239170574,
  2081309048,
  25169477,
  1297092173,
  239426574,
  1343112544,
  336464473,
  269402947,
  202294849,
  135186241,
  68076865,
  1325534022,
  239164430,
  1343114336,
  1096552011,
  239624206,
  1477334352,
  1163660869,
  239427598,
  1745765732,
  1097600581,
  239890446,
  1544444240,
  1163923013,
  239816718,
  1611546972,
  1163136584,
  239163406,
  1611547740,
  1147407940,
  239364110,
  1879983212,
  1098124868,
  239171598,
  -2146548356,
  1343113217,
  1163660877,
  239624206,
  1544445264,
  1214254657,
  240013326,
  1611547740,
  5246536,
  48,
  1712,
  -112880,
  72,
  135151872,
  239141510,
  1124303628,
  241635342,
  537805340,
  1192234576,
  -1019147250,
  -968816626,
  1038,
  44,
  1764,
  -574708,
  5761,
  135151872,
  222429829,
  59196165,
  92472454,
  167928835,
  1103512003,
  214254023,
  188941316,
  140,
  1812,
  -112900,
  227,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  537805573,
  1143737981,
  239808526,
  739134240,
  1211108929,
  239738894,
  806241068,
  1243614797,
  239152142,
  537806896,
  1126960707,
  239808526,
  739133216,
  1211108931,
  239280142,
  806240556,
  1091833416,
  1091571395,
  1091309254,
  1091047111,
  1191448261,
  92479502,
  75891333,
  239272839,
  739132200,
  1211108931,
  8206,
  28,
  1956,
  -569124,
  29,
  336478976,
  1175981637,
  239475726,
  68044832,
  60,
  1988,
  -569124,
  1112,
  135151872,
  222626437,
  59198469,
  92472454,
  167951619,
  1103512003,
  214254023,
  189137924,
  -1023312893,
  -951990719,
  67945793,
  4,
  76,
  2052,
  -568068,
  331,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806242309,
  873357826,
  1194856005,
  239352846,
  806242368,
  235572738,
  247677716,
  247873808,
  247939340,
  247808264,
  737540,
  368,
  2132,
  -567812,
  1258,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1007567621,
  1212157508,
  240726030,
  1074676796,
  1395658315,
  239352846,
  806243136,
  1144786516,
  239812622,
  1007572016,
  1262489156,
  239284238,
  1074677308,
  1294995035,
  239350798,
  1007567928,
  1212157505,
  240529422,
  1074676028,
  1697648202,
  239810574,
  1074676028,
  1966083656,
  239547406,
  1007567928,
  1379929665,
  240594958,
  1007567160,
  1212157505,
  1073885198,
  239352846,
  806243904,
  37490255,
  1212157505,
  241053710,
  1074676796,
  36703822,
  1144786518,
  240009230,
  174195248,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188941326,
  1110969928,
  239156238,
  806242368,
  1144786513,
  239616014,
  940459316,
  1144786500,
  239353870,
  1208894532,
  1145835076,
  239161358,
  1477329236,
  1146883649,
  239624206,
  239469104,
  1007568696,
  1212157505,
  239808526,
  1007568696,
  1212157505,
  239808526,
  1007568696,
  1212157505,
  240005134,
  1007568696,
  1212157505,
  239742990,
  1074676028,
  1160777288,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  1007576331,
  1212157506,
  241709070,
  1074676540,
  3149384,
  88,
  2504,
  -566920,
  274,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  1007569922,
  1212157508,
  1543647246,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  1007567627,
  1279266372,
  175190030,
  239221774,
  737856,
  108,
  2596,
  -566724,
  549,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  234948099,
  1007567672,
  1312820801,
  239939598,
  1007567160,
  1212157511,
  1577201678,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1208225477,
  940467979,
  1094454850,
  239747086,
  1007571504,
  1279266371,
  12302,
  40,
  2708,
  -566276,
  74,
  135152896,
  239403651,
  470701072,
  1210060353,
  -1019148274,
  239600654,
  164624,
  120,
  2752,
  -566240,
  170,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806242053,
  1111232105,
  239616014,
  235563824,
  247677204,
  247873808,
  247939340,
  247808264,
  1460355332,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  1007567627,
  1212157506,
  239874062,
  247677204,
  247873808,
  247939340,
  247808264,
  4,
  136,
  2876,
  -566188,
  2091,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  -2146548219,
  19268362,
  1091210254,
  1208651790,
  1175093262,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1225002693,
  245957131,
  240257676,
  239602320,
  240061056,
  239340164,
  239143560,
  239143564,
  240388752,
  239143556,
  239340168,
  239733388,
  239864464,
  240323200,
  239143564,
  239602320,
  2688,
  108,
  3016,
  -564232,
  204,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241541,
  1194856011,
  239156238,
  1007568448,
  1161301569,
  239156238,
  806242880,
  873349634,
  1161301570,
  239156238,
  806242368,
  1262227020,
  239616014,
  235559216,
  247677204,
  247873808,
  247939340,
  247808264,
  737540,
  32,
  3128,
  -564136,
  62,
  135151872,
  239272582,
  2013496076,
  1091047107,
  265926,
  16,
  3164,
  -564108,
  54,
  0,
  112,
  3184,
  -564064,
  556,
  135151872,
  239927943,
  -1862139232,
  1476568078,
  1090693134,
  1107471374,
  1292021774,
  1208131598,
  1275243534,
  1292021774,
  33726478,
  44830280,
  45092418,
  44043855,
  -1542555390,
  -1475460606,
  -1408351998,
  -1341242878,
  -1609675518,
  -1408341758,
  -1341240318,
  -1609675518,
  -1408348926,
  -1341240318,
  2,
  204,
  3300,
  -563620,
  808,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074677509,
  1141815042,
  1112018500,
  239225870,
  1074678096,
  1145310846,
  239159310,
  1343112268,
  37752396,
  1212419667,
  239552526,
  1343112268,
  1091833416,
  1091571395,
  1091309254,
  1091047111,
  1174671045,
  92487694,
  75891333,
  241697671,
  1208893764,
  1095503425,
  239620110,
  1141790016,
  1095241284,
  239160334,
  1074678096,
  1195642443,
  239159310,
  1343111500,
  1413484108,
  239551502,
  1276002632,
  1313869377,
  1241661454,
  239354894,
  1276002632,
  1229983297,
  1291993102,
  239354894,
  1276002632,
  1229983297,
  16398,
  60,
  3508,
  -563012,
  728,
  135151872,
  222429829,
  59196933,
  92472454,
  167880195,
  1103512003,
  214254023,
  189137924,
  1103301212,
  1103577542,
  67374277,
  2889,
  36,
  3572,
  -562340,
  30,
  470696704,
  1142951490,
  239346702,
  739132456,
  1211108932,
  1038,
  100,
  3612,
  -562348,
  204,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1007567621,
  1312820805,
  1124216846,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1157893829,
  873362699,
  1094192708,
  239156238,
  806242368,
  1158942296,
  1091571395,
  1091309254,
  1091047111,
  265925,
  80,
  3716,
  -562244,
  281,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  537805573,
  235570690,
  806240556,
  239471437,
  739133480,
  1328549441,
  240132110,
  739132968,
  1328549443,
  241508366,
  806240556,
  2100808,
  28,
  3800,
  -562040,
  21,
  269370112,
  1108610626,
  239409166,
  537805852,
  88,
  3832,
  -562040,
  298,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  537806853,
  235588610,
  247677716,
  247873808,
  247939340,
  247808264,
  1225474308,
  239413262,
  806240812,
  1545604680,
  1109659146,
  239413262,
  806241580,
  2885,
  28,
  3924,
  -561828,
  69,
  470696704,
  1210060356,
  174985230,
  188810254,
  28,
  3956,
  -561780,
  70,
  470696704,
  1210060357,
  174985230,
  188810254,
  36,
  3988,
  -561732,
  36,
  470696704,
  1142951496,
  239346702,
  739132456,
  1211108932,
  1038,
  36,
  4028,
  -561724,
  34,
  470696704,
  1109397064,
  239346702,
  739132456,
  1211108932,
  1038,
  112,
  4068,
  -561716,
  1203,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676997,
  167877635,
  -1019145202,
  -968683506,
  -952038386,
  -985593842,
  189072398,
  336464465,
  269402947,
  202294849,
  135186241,
  68076865,
  1526926145,
  1095503361,
  239620110,
  17695552,
  239158286,
  1276002632,
  1280314949,
  16398,
  36,
  4184,
  -560616,
  30,
  470696704,
  1109397060,
  239346702,
  739132456,
  1211108932,
  1038,
  140,
  4224,
  -560624,
  769,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  1145835087,
  239620110,
  184091200,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  167857667,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189137934,
  235555586,
  247677204,
  247873808,
  247939340,
  247808264,
  1460357380,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  32,
  4368,
  -559984,
  30,
  269370112,
  1091833415,
  239343630,
  537806364,
  265800,
  32,
  4404,
  -559988,
  28,
  269370112,
  1091833415,
  239343630,
  537805852,
  265800,
  60,
  4440,
  -559992,
  175,
  135151872,
  222429829,
  59196933,
  92472454,
  -1022726654,
  -951990719,
  67945793,
  1426802180,
  -968768758,
  -985544895,
  1090782220,
  11,
  28,
  0,
  1280342529,
  2080440402,
  -1610610936,
  527284,
  67374107,
  392,
  52,
  36,
  -559912,
  524,
  244829188,
  135151880,
  222429829,
  59196933,
  92472454,
  -1022693886,
  -951990719,
  67945793,
  34293252,
  1060449,
  64,
  92,
  -559440,
  285,
  244834052,
  135151880,
  222429829,
  59130373,
  779617411,
  172229136,
  1103512003,
  67374277,
  1073875781,
  173277230,
  1103512003,
  67374277,
  2885,
  16,
  4660,
  -559220,
  54,
  0,
  100,
  4680,
  -559176,
  204,
  135151872,
  239272579,
  537806108,
  1494224456,
  239606798,
  604913952,
  1109921346,
  239152142,
  470698032,
  1210060363,
  239341582,
  403588116,
  1092357700,
  239607822,
  235557392,
  247677704,
  1745568516,
  1124601354,
  1157893827,
  470697739,
  1377832513,
  4110,
  28,
  4784,
  -559072,
  22,
  336478976,
  1142427202,
  239344654,
  68044832,
  56,
  316,
  -559072,
  355,
  244837892,
  135151880,
  222429829,
  59196933,
  92472454,
  539925250,
  -1022733054,
  -951990719,
  67945793,
  1410024452,
  4142,
  52,
  376,
  -558764,
  254,
  244841732,
  135151880,
  222429829,
  59196933,
  92472454,
  -1022716158,
  -951990719,
  67945793,
  1342915844,
  4142,
  92,
  4932,
  -558564,
  165,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1007568133,
  1178603076,
  174665742,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189137934,
  1127485025,
  239286286,
  1074676028,
  1094979139,
  239159310,
  1343111500,
  3149382,
  100,
  528,
  -558484,
  1563,
  244845572,
  135151880,
  222429829,
  59196933,
  92472454,
  167948803,
  1103512003,
  214254023,
  188875780,
  -1022699518,
  -951990719,
  67945793,
  1795900676,
  -968768758,
  -985544895,
  1107559436,
  183304715,
  1103512003,
  214254023,
  189268996,
  34614888,
  11976,
  432,
  5132,
  -557020,
  2462,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1341241851,
  239796737,
  239141308,
  239731136,
  173343152,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189203470,
  -1207014654,
  -1139915519,
  -1072807679,
  -1341241855,
  -1139913727,
  -1072807679,
  -1341239807,
  -1274128895,
  -1207024639,
  -1139915775,
  -1072807679,
  -1341240831,
  172622337,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189203470,
  234947331,
  239141300,
  239141304,
  239141308,
  239993280,
  1224868272,
  1090630670,
  1090631694,
  1090632718,
  1157742606,
  33665038,
  29101729,
  29363777,
  28315206,
  -1274105854,
  -1207025151,
  -1139916287,
  -1072807679,
  -1341240831,
  -1139900927,
  -1072807679,
  -1341241855,
  248054273,
  239141308,
  240058816,
  239272368,
  239141308,
  239796672,
  1526923696,
  28577281,
  28839489,
  29101633,
  29363777,
  28315206,
  -1274112766,
  -1207025151,
  -1139916287,
  -1072807679,
  -1341240831,
  239927809,
  240583100,
  239272384,
  239272388,
  239141320,
  239141324,
  241697232,
  1761739184,
  1476508686,
  1124188174,
  1124189198,
  1157744654,
  1090636814,
  1644285966,
  1375842318,
  1459731470,
  1627504654,
  1157738510,
  1191293966,
  1090631694,
  1157741582,
  1157742606,
  1090634766,
  1157744654,
  1090636814,
  1174523918,
  1258401806,
  1090632718,
  1325514766,
  1543614478,
  1090632718,
  1208074254,
  110606,
  140,
  5568,
  -554992,
  283,
  135151872,
  239141511,
  1090749964,
  75698190,
  35655235,
  1126436421,
  239347726,
  806241580,
  1093930563,
  239155214,
  1074676028,
  1595936330,
  1091571210,
  1175195331,
  1091047110,
  1107562183,
  235554059,
  247677200,
  247873804,
  247939336,
  1124812804,
  239152142,
  537807408,
  269355630,
  202294086,
  135185985,
  68077377,
  239733572,
  806240556,
  1126174286,
  239152142,
  537808432,
  44,
  5712,
  -554848,
  54,
  135151872,
  239272579,
  537806108,
  1209011784,
  1174933002,
  1090784963,
  135156491,
  68076353,
  136,
  5760,
  -554832,
  369,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  1129582197,
  239163406,
  1611546972,
  1884294728,
  239162382,
  1544438104,
  1163923013,
  239363086,
  1812874344,
  1248857669,
  239817742,
  1544438104,
  1214254657,
  -2013114354,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  235561739,
  247677716,
  247873808,
  247939340,
  247808264,
  737540,
  212,
  5900,
  -554588,
  640,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  336464483,
  269402945,
  202294849,
  135186241,
  68076865,
  -1493038270,
  239481870,
  1007567160,
  1212157505,
  172830734,
  -1018817522,
  -968814578,
  -952038386,
  -985593842,
  188941326,
  336464465,
  269402945,
  202294849,
  135186241,
  68076865,
  240192331,
  940461108,
  1094454849,
  239616014,
  873355824,
  1094192710,
  239156238,
  806242368,
  1127485032,
  239155214,
  1074676028,
  1529876040,
  239285262,
  1007567160,
  1212157505,
  242036750,
  1074676028,
  1915752014,
  239285262,
  1007567160,
  1212157505,
  240005134,
  1074676028,
  3149405,
  144,
  6116,
  -554164,
  354,
  135151872,
  239141511,
  1090749964,
  75698190,
  1629490755,
  239346702,
  739131688,
  1211108929,
  172761102,
  -1018818546,
  -968815602,
  -952039410,
  189203470,
  269355618,
  202294081,
  135185987,
  68077377,
  239471433,
  806240556,
  1864371782,
  239150094,
  739131688,
  1244663361,
  241180686,
  672023332,
  1093406273,
  239611918,
  739141664,
  1127222861,
  239285262,
  1007567160,
  1228934721,
  8206,
  108,
  6264,
  -553944,
  381,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241029,
  873371650,
  1094192708,
  239156238,
  806242368,
  336464455,
  269402945,
  202294849,
  135186241,
  68076865,
  239405894,
  940458292,
  1094454849,
  239616014,
  242418224,
  940458292,
  1144786497,
  239878158,
  48,
  48,
  1876,
  -553672,
  218,
  244851204,
  135151880,
  222429829,
  59130373,
  -2029910909,
  -968768758,
  67945793,
  1141588484,
  4142,
  192,
  6428,
  -553500,
  319,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -871479803,
  -804370175,
  -1072805887,
  -871476479,
  -804371455,
  -737263103,
  -670154239,
  -603044607,
  -535935743,
  -1072803071,
  -1005698815,
  -938589695,
  -871481087,
  -804372223,
  -1005690111,
  -938588415,
  -871479551,
  -804372223,
  -1072805887,
  -938579967,
  -871481087,
  -804371455,
  -1072805887,
  235556865,
  247677716,
  247873808,
  247939340,
  247808264,
  1124811524,
  1090636814,
  1208078350,
  1291960334,
  1090634766,
  1090635790,
  1090636814,
  1375850510,
  1426178062,
  1140968462,
  1208078350,
  114702,
  16,
  6624,
  -553376,
  5,
  0,
  92,
  6644,
  -590484,
  284,
  135155712,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  -1207024123,
  -1139916278,
  -1072806646,
  -1341241334,
  -1274122230,
  -1207025398,
  -1139916534,
  -1072806134,
  -1341235958,
  244777482,
  247677204,
  247873808,
  247939340,
  247808264,
  4,
  44,
  6740,
  -553476,
  597,
  135151872,
  222429829,
  59197701,
  92472454,
  167867907,
  1103512003,
  214254023,
  188810244,
  36,
  6788,
  -552916,
  37,
  135151872,
  239272579,
  336482064,
  1159204417,
  239213582,
  269371424,
  20,
  6828,
  -552908,
  24,
  470699520,
  2100805,
  80,
  6852,
  -552900,
  148,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  1277955674,
  239415310,
  940458292,
  1094454849,
  239616014,
  235563552,
  247677716,
  247873808,
  247939340,
  247808264,
  738052,
  76,
  6936,
  -552824,
  108,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  537806853,
  1092882018,
  239151118,
  806240556,
  1293946438,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  11,
  32,
  7016,
  -552792,
  38,
  135151872,
  173671043,
  1157893827,
  247677195,
  4,
  40,
  7052,
  -552780,
  57,
  135151872,
  239272579,
  403589140,
  1092357700,
  239607822,
  135159312,
  68076353,
  52,
  7096,
  -552760,
  108,
  135151872,
  239272579,
  403595028,
  1092357700,
  239607822,
  235559952,
  247677704,
  1510686980,
  -1019148274,
  1038,
  104,
  7152,
  -552704,
  376,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241541,
  1093930622,
  239155214,
  1074676028,
  1932529224,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  873364747,
  1094192706,
  239156238,
  806242880,
  1144262256,
  239155214,
  1074676028,
  3149387,
  84,
  2760,
  -552428,
  695,
  244855044,
  135151880,
  222429829,
  59196933,
  92472454,
  167854083,
  1103512003,
  214254023,
  189006852,
  1103301191,
  1103577542,
  67374277,
  -1946023098,
  -968768758,
  -985544895,
  1090782220,
  271476747,
  3037186,
  276,
  7348,
  -551812,
  1840,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1609677307,
  240124417,
  239141292,
  239600048,
  1375863200,
  1157736462,
  1090628622,
  1174515726,
  1258397710,
  1090628622,
  1308733454,
  1442947086,
  1140958222,
  1140959246,
  1090628622,
  1241624590,
  1862377486,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1225002693,
  239206923,
  239141292,
  240058800,
  239272352,
  239141292,
  239600048,
  704840096,
  27528705,
  27790913,
  28053057,
  28315201,
  27266638,
  -1542567678,
  -1475460863,
  -1408351999,
  -1341243135,
  -1609677567,
  173474305,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189465614,
  -1542536446,
  -1475460607,
  -1408351743,
  -1341243135,
  -1609676287,
  251462145,
  239272356,
  239272360,
  239141292,
  239468976,
  -704511584,
  1107403790,
  1107404814,
  1090628622,
  1241624590,
  106510,
  48,
  7628,
  -550252,
  81,
  135151872,
  239272579,
  470699288,
  1679822401,
  172625934,
  -1019148274,
  189203470,
  1091046979,
  265923,
  152,
  7680,
  -550208,
  670,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1609676795,
  -1475452159,
  -1408350975,
  -1341243135,
  -1609677311,
  -1475453183,
  -1408350207,
  -1341243135,
  -1609676031,
  172687873,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  -1542521086,
  -1475460863,
  -1408351999,
  -1341242623,
  -1609674495,
  239075841,
  239534500,
  239141288,
  239141292,
  239600048,
  1073873312,
  1258399758,
  1090628622,
  1543614478,
  106510,
  16,
  7836,
  -549692,
  16,
  0,
  60,
  7856,
  -549696,
  106,
  135151872,
  239141511,
  1090749964,
  75698190,
  1175719505,
  239147022,
  537805596,
  1628442190,
  202294026,
  135185985,
  68077377,
  2881,
  168,
  7920,
  -549648,
  420,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1878113019,
  -1743887615,
  -1676786431,
  -1609678591,
  -1878112767,
  235568129,
  247677204,
  247873808,
  247939340,
  247808264,
  1779124228,
  1107399694,
  1107400718,
  1124178958,
  1107402766,
  1107403790,
  1090627598,
  1107405838,
  1208070158,
  1224839182,
  1140954126,
  1140955150,
  1124178958,
  1342283790,
  1258393614,
  1090623502,
  1090624526,
  1442947086,
  1996591118,
  1090622478,
  1090623502,
  1090624526,
  1308729358,
  102414,
  52,
  8092,
  -549388,
  83,
  135151872,
  239141510,
  1124303628,
  175181838,
  -1019147250,
  -968816626,
  189269006,
  1091309135,
  1091047107,
  265926,
  60,
  8148,
  -549348,
  87,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  235553026,
  247677204,
  247873808,
  247939340,
  247808264,
  738308,
  28,
  8212,
  -549316,
  25,
  336478976,
  1192758852,
  239213582,
  68044832,
  76,
  8244,
  -549316,
  172,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  1092882020,
  239151118,
  806241068,
  35655240,
  336464479,
  269402945,
  202294849,
  135186241,
  68076865,
  2885,
  104,
  8324,
  -549220,
  237,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235556610,
  247677204,
  247873808,
  247939340,
  247808264,
  1124812292,
  239154190,
  1007567160,
  1530924609,
  240857102,
  940458292,
  1128009281,
  239943694,
  873358640,
  1094192708,
  239156238,
  806241856,
  164,
  8432,
  -549088,
  554,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  873379074,
  1144524353,
  239156238,
  806241856,
  873352962,
  1094192705,
  239352846,
  806243136,
  336464457,
  269402945,
  202294849,
  135186243,
  68076865,
  242944841,
  1074676028,
  1328549448,
  239285262,
  1007567160,
  1329598020,
  239677454,
  1074676028,
  1345326664,
  1091833354,
  1091571395,
  1124863686,
  1091047111,
  1174671045,
  1007577611,
  1312820801,
  239284238,
  1074676028,
  3149384,
  100,
  8600,
  -548696,
  313,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  873357058,
  1094192705,
  239156238,
  806242880,
  235553538,
  247678228,
  247873808,
  247939340,
  247808264,
  1678459396,
  1125387786,
  1125125827,
  1091309254,
  1091047111,
  1141116613,
  11,
  56,
  8704,
  -548480,
  113,
  135151872,
  239141510,
  1124303628,
  173150222,
  -1019147250,
  -968816626,
  189203470,
  235554306,
  247677196,
  247873800,
  737796,
  56,
  8764,
  -548412,
  79,
  135151872,
  239141510,
  1644397324,
  135185162,
  68077121,
  173411147,
  1091047107,
  1090784966,
  247677195,
  247873800,
  4,
  104,
  8824,
  -548392,
  394,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  537805573,
  604914178,
  1093144129,
  239283214,
  537809200,
  336464465,
  269402945,
  202294849,
  135186241,
  68076865,
  241634122,
  739131944,
  1177554497,
  241770510,
  672023332,
  1093406273,
  239611918,
  32,
  32,
  8932,
  -548100,
  46,
  135151872,
  239272579,
  537811228,
  1091046991,
  265923,
  32,
  8968,
  -548088,
  46,
  135151872,
  239272579,
  537811228,
  1091046991,
  265923,
  100,
  9004,
  -548076,
  298,
  135151872,
  239141511,
  1090749964,
  75698190,
  1142165090,
  239605774,
  537805852,
  1896877640,
  239148046,
  269371424,
  247663171,
  247873804,
  247939336,
  1644905476,
  239211534,
  470696472,
  1243614785,
  174460942,
  1091309251,
  1091047110,
  1191448263,
  11,
  104,
  9108,
  -547876,
  151,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  739135746,
  1110445634,
  239219726,
  1007567416,
  1245711937,
  172761102,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188941326,
  336464457,
  269402947,
  202294849,
  135186241,
  68076865,
  2881,
  28,
  9216,
  -547824,
  44,
  135151872,
  239403651,
  135160848,
  68076353,
  132,
  9248,
  -547808,
  391,
  135151872,
  239141511,
  1090749964,
  75698190,
  1125912167,
  239607822,
  470703632,
  1210060353,
  239210510,
  403587604,
  1092357698,
  239804430,
  336489232,
  1108872770,
  239148046,
  269384224,
  247663203,
  247873804,
  247939336,
  1594573572,
  239148046,
  269370912,
  1276382807,
  239147022,
  537805084,
  1443892808,
  239277070,
  470696216,
  1210060353,
  4110,
  208,
  9384,
  -547544,
  1155,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  235553538,
  247677204,
  247873808,
  247939340,
  247808264,
  34292228,
  1180175943,
  239164430,
  1678656864,
  1147670081,
  239365134,
  1343114352,
  1213730379,
  239164430,
  1343113312,
  1113067090,
  239164430,
  1343118176,
  1096027723,
  239163406,
  1611547996,
  38800974,
  1146883830,
  239624206,
  183763536,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188875790,
  1544472834,
  1180700228,
  239361038,
  1343114592,
  1197215350,
  239820814,
  235555408,
  1477330260,
  1163660869,
  189095950,
  1163136581,
  239425550,
  1611547996,
  80,
  9596,
  -546588,
  151,
  135151872,
  239141510,
  1124303628,
  240586766,
  403590164,
  1092357697,
  239607822,
  470705168,
  1176505921,
  172953614,
  -1019147250,
  -968816626,
  189400078,
  1125387849,
  239147022,
  537805084,
  1052232,
  140,
  9680,
  -546512,
  510,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  235559170,
  247677204,
  247873808,
  247939340,
  247808264,
  34292740,
  1126436449,
  239151118,
  806240556,
  1797262920,
  239870990,
  739131688,
  1211108929,
  241115150,
  672023332,
  1093406273,
  239611918,
  739139616,
  1328549444,
  1157767182,
  239152142,
  537808176,
  1126436445,
  239151118,
  806240556,
  2100808,
  104,
  9824,
  -546144,
  223,
  135151872,
  239141511,
  1090749964,
  75698190,
  1276382815,
  239147022,
  537805084,
  2014318152,
  239211534,
  470696216,
  1243614785,
  173871118,
  1091309251,
  1091047110,
  1124339399,
  336478987,
  1092095555,
  239148046,
  269371424,
  247663196,
  247875084,
  247939336,
  738564,
  40,
  9932,
  -120780,
  56,
  135151872,
  239272579,
  470701840,
  1260392003,
  239931406,
  247677192,
  4,
  164,
  9976,
  -546072,
  464,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074676997,
  235565826,
  247677204,
  247873808,
  247939340,
  247808264,
  1309361668,
  239422478,
  1074678864,
  1162088035,
  239355918,
  1343111500,
  1195380296,
  239160334,
  1074682448,
  1094979163,
  239159310,
  1343111500,
  1749028431,
  239420430,
  1276004168,
  1448087105,
  239420430,
  1276002632,
  1313869377,
  240074766,
  1208895556,
  1095503429,
  239620110,
  1208893764,
  1095503428,
  239816718,
  64,
  16,
  10144,
  -545776,
  108,
  0,
  88,
  10164,
  -545684,
  538,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806242821,
  1110707787,
  239417358,
  1074677052,
  53481032,
  940441918,
  1161563714,
  239616014,
  235553584,
  247677204,
  247873808,
  247939340,
  247808264,
  739076,
  16,
  10256,
  -545232,
  18,
  0,
  80,
  10276,
  -545220,
  465,
  135151872,
  239141511,
  1090749964,
  75698190,
  1646267971,
  239215630,
  739132712,
  1211108933,
  352526350,
  1109921281,
  239414286,
  537806896,
  269355587,
  202294081,
  135185985,
  68077377,
  2890,
  16,
  10360,
  -544824,
  40,
  0,
  16,
  10380,
  -544796,
  38,
  0,
  24,
  10400,
  -544768,
  40,
  135151872,
  -1016724861,
  1038,
  52,
  10428,
  -544748,
  135,
  135151872,
  239141510,
  1124303628,
  241897486,
  470696472,
  1176505921,
  175116302,
  -1019147250,
  -968816626,
  189072398,
  40,
  10484,
  -544660,
  85,
  135151872,
  239272579,
  470705424,
  1562381889,
  -1019148274,
  239600654,
  164624,
  56,
  10528,
  -544608,
  93,
  135151872,
  239141511,
  1090749964,
  75698190,
  247663227,
  247874572,
  247939336,
  1309361412,
  1141640899,
  1091047110,
  265927,
  88,
  10588,
  -544572,
  266,
  135151872,
  239141510,
  1124303628,
  1979846670,
  1091309066,
  1091047107,
  1124339398,
  235554827,
  247678476,
  247873800,
  1728790788,
  1091309066,
  1091047107,
  1191448262,
  470696715,
  1210060353,
  241307662,
  537805084,
  1052232,
  88,
  10680,
  -544392,
  266,
  135151872,
  239141510,
  1124303628,
  1912737806,
  1091309066,
  1091047107,
  1191448262,
  235554827,
  247678476,
  247873800,
  1913340164,
  239148046,
  269371424,
  202246737,
  135185217,
  68077121,
  239274818,
  537805084,
  1052232,
  40,
  10772,
  -544212,
  80,
  135151872,
  239272579,
  235566352,
  247677192,
  1124812292,
  239148046,
  269371936,
  76,
  10816,
  -544176,
  151,
  135151872,
  239141511,
  1090749964,
  75698190,
  247663180,
  247873804,
  247939336,
  1695237892,
  239148046,
  269370912,
  247663204,
  247873804,
  247939336,
  1393247748,
  239148046,
  269371936,
  16,
  10896,
  -544096,
  6,
  0,
  52,
  10916,
  -544100,
  87,
  135151872,
  239141510,
  1292075788,
  240717838,
  537805084,
  1410338374,
  1091309066,
  1091047107,
  1258557126,
  11,
  108,
  10972,
  -544060,
  234,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  940473858,
  1094454852,
  239484942,
  873354032,
  1094192705,
  239287310,
  806242368,
  336464487,
  269402945,
  202294851,
  135186241,
  68076865,
  239274819,
  247677716,
  247873808,
  247939340,
  247808264,
  4,
  60,
  11084,
  -543932,
  87,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  537806853,
  336464496,
  269402945,
  202294849,
  135186241,
  68076865,
  2891,
  84,
  11148,
  -543900,
  141,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  739135234,
  1211108929,
  172761102,
  -1019145202,
  -968814578,
  -951907314,
  -985593842,
  189203470,
  1092881987,
  239151118,
  806240556,
  2100813,
  80,
  11236,
  -543844,
  228,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  537806853,
  1093406309,
  239480846,
  174195232,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189072398,
  1093406298,
  239742990,
  32,
  84,
  11320,
  -543688,
  87,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  537806853,
  1143737953,
  239218702,
  940458292,
  1094454849,
  239484942,
  247677204,
  247873808,
  247939340,
  247808264,
  537807620,
  42272131,
  59180166,
  68,
  11408,
  -543680,
  107,
  135151872,
  239141510,
  1124303628,
  239676430,
  537806896,
  202246758,
  135185222,
  68077121,
  239536965,
  806240556,
  1260392008,
  -1018819570,
  -968816626,
  1038,
  16,
  11480,
  -543640,
  169,
  0,
  16,
  11500,
  -543484,
  5,
  0,
  16,
  11520,
  -543488,
  149,
  0,
  32,
  11540,
  -543348,
  280,
  135151872,
  50528899,
  247663105,
  1326138372,
  265923,
  16,
  11576,
  -543096,
  3,
  0,
  60,
  11596,
  -543100,
  132,
  135151872,
  239272579,
  470709008,
  1327500865,
  172494862,
  -1019148274,
  189269006,
  135137859,
  68076355,
  239274826,
  537805084,
  1052246,
  16,
  11660,
  -543020,
  11,
  0,
  52,
  11680,
  -543024,
  111,
  135151872,
  239141510,
  1124303628,
  242556942,
  739131688,
  1177554497,
  172695566,
  -1019147250,
  -968816626,
  188810254,
  68,
  11736,
  -542968,
  103,
  135151872,
  239141510,
  1124303628,
  173805582,
  -1019147250,
  -968816626,
  189072398,
  1108872799,
  239148046,
  269370912,
  202246728,
  135185217,
  68077121,
  2886,
  32,
  11808,
  -542928,
  63,
  135151872,
  175243907,
  1157893827,
  247678475,
  4,
  100,
  11844,
  -542900,
  660,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  1111756392,
  239421454,
  1343112524,
  37752392,
  1112018687,
  239160334,
  1074677328,
  1208912130,
  1162612290,
  239620110,
  235553600,
  247677716,
  247873808,
  247939340,
  247808264,
  738308,
  96,
  11948,
  -542332,
  362,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1007569413,
  1379929666,
  1711419406,
  239219726,
  1007567416,
  1228934721,
  239480846,
  940458548,
  1094454850,
  239616014,
  174981680,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189072398,
  24,
  12048,
  -542064,
  14,
  470696704,
  1210060354,
  1038,
  100,
  12076,
  -542076,
  554,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  1074676485,
  1111756363,
  239421454,
  1343112524,
  54529608,
  1208877393,
  1095503426,
  239489038,
  240779840,
  1276002888,
  1213206085,
  172179470,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189465614,
  64,
  12180,
  -541620,
  96,
  135151872,
  239141510,
  1124303628,
  174788622,
  -1019147250,
  -968816626,
  189137934,
  202246737,
  135185217,
  68077121,
  239274821,
  537805084,
  1052234,
  16,
  12248,
  -541592,
  46,
  0,
  16,
  12268,
  -541564,
  15,
  0,
  16,
  12288,
  -541568,
  47,
  0,
  44,
  12308,
  -541540,
  136,
  135151872,
  239141510,
  33784588,
  247663168,
  247873800,
  2114667780,
  1091047107,
  265926,
  16,
  12356,
  -541444,
  42,
  0,
  92,
  12376,
  -541416,
  311,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  336464489,
  269402945,
  202294849,
  135186241,
  68076865,
  240192324,
  1074678332,
  1395658314,
  239547406,
  1007567160,
  1480592963,
  2013409294,
  239418382,
  806242368,
  16,
  12472,
  -541192,
  11,
  0,
  16,
  12492,
  -541196,
  6,
  0,
  16,
  12512,
  -541200,
  6,
  0,
  16,
  12532,
  -541204,
  3,
  0,
  16,
  12552,
  -541208,
  6,
  0,
  16,
  12572,
  -541212,
  2,
  0,
  16,
  12592,
  -541216,
  6,
  0,
  16,
  12612,
  -541220,
  3,
  0,
  16,
  12632,
  -541224,
  8,
  0,
  16,
  12652,
  -541228,
  5,
  0,
  16,
  12672,
  -541232,
  67,
  0,
  16,
  12692,
  -541172,
  52,
  0,
  16,
  12712,
  -541128,
  31,
  0,
  36,
  12732,
  -541116,
  87,
  135151872,
  239141510,
  1879278348,
  135185162,
  68077121,
  2885,
  136,
  12772,
  -541060,
  378,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  336464473,
  269402945,
  202294849,
  135186241,
  68076865,
  1409420100,
  239156238,
  806242624,
  1093930581,
  239155214,
  1074677052,
  1412435545,
  239547406,
  1007567416,
  1195380289,
  239158286,
  1276002632,
  1330646593,
  1493315598,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  188,
  12912,
  -540816,
  432,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  336464479,
  269402947,
  202294849,
  135186241,
  68076865,
  240126788,
  1343116620,
  1396706889,
  239158286,
  1276002632,
  1481641537,
  240009230,
  1208895300,
  1095503425,
  239620110,
  240583232,
  1208894276,
  1095503426,
  239620110,
  235555648,
  247677716,
  247874320,
  247939340,
  247808264,
  2131444996,
  1162087946,
  239421454,
  1343112524,
  239799114,
  1208894788,
  1095503426,
  239620110,
  235554112,
  247677204,
  247873808,
  247939340,
  247808264,
  738308,
  148,
  13104,
  -540576,
  531,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235567106,
  247677716,
  247873808,
  247939340,
  247808264,
  1443580676,
  1158942218,
  1091571395,
  1091309254,
  1091047111,
  1107562181,
  235565323,
  247678228,
  247873808,
  247939340,
  247808264,
  34293508,
  336464489,
  269402945,
  202294858,
  135186241,
  68076865,
  1392642890,
  239483918,
  806242880,
  1144786528,
  240140302,
  48,
  16,
  13256,
  -540184,
  38,
  0,
  40,
  13276,
  -540156,
  61,
  135151872,
  239272579,
  470700816,
  1226837569,
  240521230,
  247677192,
  4,
  88,
  13320,
  -540136,
  123,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  1109921367,
  239152142,
  537806896,
  1092881988,
  239151118,
  806240556,
  1663045192,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  16,
  13412,
  -540100,
  23,
  0,
  40,
  13432,
  -540088,
  43,
  135151872,
  239600259,
  336480784,
  1142427206,
  239148046,
  135154464,
  68076353,
  16,
  13476,
  -540084,
  18,
  0,
  32,
  13496,
  -540072,
  80,
  135151872,
  174719619,
  1241779907,
  247682059,
  4,
  56,
  13532,
  -540028,
  132,
  135152896,
  239338117,
  1090750220,
  75894798,
  -2095837631,
  403590405,
  336487938,
  269402945,
  202294849,
  135186241,
  68076865,
  84,
  13592,
  -539944,
  498,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  470696709,
  235594242,
  247677716,
  247873808,
  247939340,
  247808264,
  34291972,
  336464477,
  269402947,
  202294849,
  135186241,
  68076865,
  2885,
  76,
  13680,
  -539520,
  97,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  739117670,
  1093668417,
  239154190,
  1007567160,
  1094716993,
  239485966,
  1276003656,
  1213206082,
  239479822,
  739888,
  180,
  13760,
  -539488,
  408,
  135152384,
  239141511,
  1191413260,
  75698190,
  1108872812,
  239213582,
  604914976,
  1160252994,
  239152142,
  269371440,
  1108610651,
  239147022,
  537805084,
  1360006728,
  202294026,
  135185985,
  68077377,
  239274822,
  470697240,
  1210060353,
  239276046,
  470696472,
  1159728706,
  239215630,
  739132712,
  1211108930,
  242159630,
  470696728,
  1210060353,
  242880526,
  470696216,
  1310723649,
  239603726,
  470696472,
  1159728706,
  239215630,
  739132712,
  1211108930,
  241045518,
  470697240,
  1210060353,
  4110,
  132,
  13944,
  -539256,
  292,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  1092882041,
  239151118,
  806240556,
  35655240,
  336464459,
  269402947,
  202294849,
  135186241,
  68076865,
  172165956,
  -1019014130,
  -968683506,
  -952038386,
  -985593842,
  189072398,
  739117639,
  1244663375,
  235553547,
  806244140,
  172165962,
  240069646,
  1124813360,
  240069646,
  48,
  88,
  14080,
  -539088,
  166,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  336464482,
  269402945,
  202294849,
  135186241,
  68076865,
  239274819,
  1074677308,
  1328549453,
  239156238,
  806242624,
  1111232084,
  239681550,
  48,
  20,
  14172,
  -122844,
  158,
  243597824,
  537808668,
  20,
  14196,
  -597752,
  28,
  470696704,
  2100815,
  52,
  14220,
  -539052,
  239,
  135151872,
  239141510,
  1124303628,
  -1006497778,
  1124863498,
  1091047107,
  1090784966,
  235553547,
  537808668,
  2890,
  108,
  14276,
  -538868,
  191,
  135151872,
  239141510,
  1157858060,
  174796814,
  -1019147250,
  -968816626,
  189006862,
  1110707787,
  239679502,
  1074676028,
  1815088712,
  239352846,
  1141784896,
  1162350145,
  239160334,
  806242384,
  202246723,
  135185217,
  68077121,
  239274820,
  940459060,
  1094454853,
  239616014,
  48,
  92,
  14388,
  -538788,
  277,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  1328287344,
  1174548494,
  175382542,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189006862,
  336464499,
  269402947,
  202294849,
  135186241,
  68076865,
  2881,
  108,
  14484,
  -538596,
  752,
  135155456,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  234982915,
  1343114060,
  1212157517,
  239815694,
  1074679120,
  336486658,
  269402945,
  202294849,
  135186241,
  68076865,
  -2092954042,
  -2046655227,
  1124304644,
  239815694,
  1074679120,
  1313607283,
  239947790,
  64,
  84,
  14596,
  -537956,
  268,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235586818,
  247677204,
  247873808,
  247939340,
  247808264,
  1678459140,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  84,
  14684,
  -537772,
  168,
  135151872,
  239141510,
  1124303628,
  1124208654,
  239147022,
  537805084,
  1125125704,
  1091309066,
  1091047107,
  1225002694,
  235555595,
  247677196,
  247873800,
  1124811524,
  239737870,
  269372704,
  1327238725,
  8206,
  300,
  14772,
  -537684,
  2777,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1343112453,
  1544480002,
  1214254662,
  172183566,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189465614,
  235014915,
  1544439128,
  1214254657,
  -704425970,
  1112804865,
  239360014,
  1611548508,
  38800968,
  1264324191,
  239951886,
  235556688,
  247677204,
  247873808,
  247939340,
  247808264,
  51069444,
  1410203958,
  1096289857,
  239361038,
  1343113312,
  1410254338,
  1096289857,
  239361038,
  1343113312,
  1213992520,
  239951886,
  1544442448,
  1298140744,
  242765838,
  1611549532,
  1951403600,
  239228942,
  1611547228,
  1113853506,
  239364110,
  1879984492,
  38800968,
  1544424090,
  1247809103,
  235553547,
  1611550556,
  172165962,
  240081934,
  1124813408,
  1331432970,
  189423630,
  1213992515,
  240148494,
  235554896,
  1611550556,
  1610746698,
  239819790,
  1343115616,
  1544424008,
  1247809103,
  235562507,
  1611550556,
  2890,
  296,
  15076,
  -535204,
  2120,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1343111941,
  167852803,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189269006,
  1544424027,
  1314917967,
  247923211,
  1477330004,
  1096552009,
  239624206,
  239206992,
  1544438360,
  1113591362,
  239232014,
  1812873576,
  1215303234,
  -1207807986,
  239164430,
  1343115616,
  235588354,
  247677716,
  247873808,
  247939340,
  247808264,
  34294532,
  1113067124,
  239229966,
  1678656096,
  1097338434,
  239496206,
  1343114352,
  1544470018,
  1298140737,
  -620605426,
  239229966,
  1343114592,
  1544459010,
  1499467340,
  241258510,
  1611547228,
  1213206093,
  1331432970,
  189423630,
  1544424003,
  1247809103,
  235553547,
  1611550556,
  239143754,
  1477329236,
  1113329218,
  239230990,
  1745764964,
  1114377793,
  239628302,
  1410223952,
  1113067073,
  239229966,
  1678656096,
  1097338434,
  239234062,
  1343113328,
  1331433041,
  24590,
  216,
  15376,
  -533376,
  2654,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  167945987,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189006862,
  2081325826,
  25169481,
  40898128,
  1182011069,
  239171598,
  -2146549380,
  1879984129,
  167957507,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  1232866919,
  1208057870,
  -1358794738,
  1333530122,
  1241612302,
  242024971,
  -2146547588,
  1879985409,
  2081294920,
  25169487,
  1593969482,
  1333530122,
  1241612302,
  235553547,
  -2146545796,
  1879788033,
  1333530122,
  1241612302,
  2081312011,
  25169480,
  40898125,
  1216089679,
  1342275598,
  242315278,
  -2146547588,
  1879986177,
  96,
  15596,
  -530940,
  435,
  135154176,
  239141509,
  1141081868,
  75894798,
  -2095837631,
  806243333,
  235596034,
  247677204,
  247873808,
  247939340,
  247808264,
  34293508,
  1142165090,
  1091571395,
  1091309254,
  1091047111,
  1459883717,
  92483598,
  75891333,
  239731591,
  1074679612,
  40,
  15696,
  -530592,
  147,
  135151872,
  239272579,
  174785040,
  -1018886130,
  189531150,
  1124601423,
  265923,
  72,
  15740,
  -530476,
  301,
  135151872,
  239141510,
  1124303628,
  -1946021874,
  1158417930,
  1091047107,
  1225002694,
  172950027,
  -1019147250,
  -968816626,
  189727758,
  202246735,
  135185219,
  68077121,
  2885,
  52,
  15816,
  -530248,
  236,
  135151872,
  239272579,
  175374864,
  -1019148274,
  189203470,
  135137890,
  68076355,
  242158411,
  247678984,
  4,
  176,
  15872,
  -530064,
  970,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241541,
  235571714,
  247677716,
  247873808,
  247939340,
  247808264,
  51070212,
  235536696,
  247677716,
  247873808,
  247939340,
  247808264,
  34292228,
  1228672592,
  239747086,
  235554096,
  247677204,
  247873808,
  247939340,
  247808264,
  1443578884,
  239154190,
  1007567160,
  1212157505,
  -1979568114,
  239614990,
  806245440,
  1262227016,
  239943694,
  235565360,
  1074679612,
  172165962,
  240073742,
  1410026048,
  240073742,
  64,
  152,
  16052,
  -529268,
  579,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  167845123,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189269006,
  1263275596,
  239882254,
  235564096,
  247677716,
  247873808,
  247939340,
  247808264,
  1124813572,
  239224846,
  1343111500,
  2134904392,
  239354894,
  1276002632,
  1330646595,
  240074766,
  1276002888,
  1213206081,
  239943694,
  1343114316,
  1095503435,
  239224846,
  1343111500,
  4197960,
  96,
  16208,
  -528832,
  1021,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241541,
  167870467,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  336464499,
  269402949,
  202294849,
  135186241,
  68076865,
  -217904315,
  1007553025,
  1245711951,
  11,
  40,
  16308,
  -527908,
  163,
  241238528,
  1157792520,
  174788622,
  -1019148274,
  188810254,
  1208487491,
  265923,
  32,
  16352,
  -527776,
  109,
  135154176,
  239272582,
  33784588,
  135185245,
  68077121,
  16,
  16388,
  -527700,
  86,
  0,
  28,
  16408,
  -527624,
  135,
  135155456,
  1677853315,
  1275334339,
  42141710,
  16,
  16440,
  -527512,
  75,
  0,
  48,
  16460,
  -527452,
  215,
  135151872,
  239141510,
  33784588,
  247663230,
  247873800,
  2047559428,
  135185162,
  68077121,
  2885,
  76,
  16512,
  -527280,
  314,
  135151872,
  239141510,
  1124303628,
  -2097016818,
  1124863498,
  1091047107,
  1141116614,
  240321035,
  470696984,
  1159728705,
  172298254,
  -1019016178,
  -968816626,
  189400078,
  1327238753,
  8206,
  40,
  16592,
  -527040,
  447,
  135151872,
  239272579,
  537806108,
  51383880,
  235536808,
  247677192,
  737540,
  108,
  16636,
  -526636,
  510,
  135151872,
  239796871,
  1090749964,
  75698190,
  -1022711038,
  -968684530,
  -952039410,
  189006862,
  470729474,
  1210060353,
  172167182,
  1124863683,
  1091047110,
  1157893831,
  336478987,
  1092095553,
  239148046,
  269370656,
  247663171,
  247874316,
  247939336,
  1846232580,
  1327238666,
  189407246,
  48,
  16748,
  -526236,
  162,
  269370112,
  68029044,
  175573833,
  189334542,
  1142427203,
  239148046,
  269370656,
  68028995,
  2888,
  248,
  16800,
  -526112,
  784,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235584514,
  247677716,
  247873808,
  247939340,
  247808264,
  1963673348,
  239614990,
  806251840,
  1007553139,
  1413484111,
  1007578891,
  1329598027,
  239742990,
  1074676028,
  1496321608,
  239154190,
  1007567160,
  1212157505,
  172306446,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189203470,
  1144262211,
  239155214,
  1074676028,
  1160777285,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1191448261,
  1007572491,
  1212157505,
  240201742,
  940459060,
  1094454849,
  240074766,
  1007576624,
  1212157507,
  239939598,
  1074676028,
  1362103880,
  239350798,
  1007567160,
  1430261313,
  240070670,
  247677204,
  247873808,
  247939340,
  247808264,
  4,
  16,
  17052,
  -525580,
  16,
  0,
  136,
  17072,
  -525584,
  819,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  167837699,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188941326,
  234955523,
  1007567928,
  1161825857,
  239808526,
  940458292,
  1094454850,
  239616014,
  873353008,
  1110969921,
  239156238,
  806242368,
  1007553119,
  1396706895,
  873349899,
  1110969921,
  239156238,
  806242368,
  1007573762,
  4197967,
  136,
  17212,
  -524892,
  323,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  336464502,
  269402948,
  202294849,
  135186241,
  68076865,
  173083460,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188941326,
  336464451,
  269402948,
  202294849,
  135186241,
  68076865,
  172165958,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189203470,
  1007593730,
  1296043590,
  12302,
  44,
  17352,
  -524696,
  410,
  135151872,
  239141510,
  1124303628,
  -1694363634,
  1124863498,
  1091047107,
  1141116614,
  11,
  396,
  17400,
  -524328,
  821,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  672032770,
  1093406277,
  239611918,
  235565856,
  247677204,
  247873808,
  247939340,
  247808264,
  1124811780,
  239347726,
  806240812,
  1847594574,
  239215630,
  739132712,
  1211108929,
  239804430,
  672023076,
  1093406277,
  239611918,
  604916512,
  1109921349,
  239152142,
  739132976,
  1093144129,
  239217678,
  537806896,
  1109659227,
  239413262,
  806240556,
  1260392008,
  239412238,
  739131944,
  1177554497,
  239152142,
  739131688,
  1211108930,
  240459790,
  672023076,
  1093406277,
  239611918,
  604916512,
  1160252994,
  239152142,
  537806896,
  1159990859,
  239216654,
  806240556,
  1093406278,
  239151118,
  806240812,
  1579159112,
  239215630,
  739132712,
  1211108929,
  239804430,
  672023076,
  1093406277,
  239611918,
  604916512,
  1109921349,
  239152142,
  739132976,
  1093144129,
  239217678,
  537806896,
  1159990859,
  239413262,
  806240556,
  35655240,
  1159990852,
  239216654,
  806240556,
  1093406278,
  239151118,
  806240812,
  1210060360,
  239412238,
  739131944,
  1177554497,
  239152142,
  739131688,
  1211108930,
  239607822,
  672023844,
  1093406274,
  239480846,
  672022828,
  1110183489,
  239611918,
  32,
  40,
  17800,
  -523896,
  66,
  135151872,
  239272579,
  235560464,
  247677192,
  1275809028,
  -1019148274,
  1038,
  40,
  17844,
  -523860,
  71,
  135151872,
  239141510,
  1124303628,
  175116302,
  -1019147250,
  -968816626,
  189334542,
  28,
  17888,
  -523824,
  81,
  537805568,
  68029027,
  240913226,
  4,
  24,
  17920,
  -523760,
  55,
  537805568,
  68029017,
  2892,
  60,
  17948,
  -523724,
  95,
  135153152,
  239141511,
  1090749964,
  75698190,
  247663210,
  247873804,
  247939336,
  1326140420,
  202294026,
  135185985,
  68077377,
  2887,
  96,
  18012,
  -523692,
  596,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235568642,
  247677204,
  247873808,
  247939340,
  247808264,
  34291972,
  1145310913,
  239159310,
  1343111500,
  37752392,
  1275988590,
  1246760527,
  235553547,
  1343115084,
  2890,
  60,
  18112,
  -523184,
  218,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  235585026,
  247677716,
  247873808,
  247939340,
  247808264,
  738564,
  168,
  18176,
  -523024,
  394,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  1678668546,
  1164447297,
  239496206,
  1678657648,
  1164447300,
  239496206,
  1678657648,
  1164447300,
  239496206,
  1611559280,
  1113853522,
  239233038,
  1879983468,
  1097076296,
  239429646,
  1879983724,
  1147407944,
  239429646,
  1879983724,
  1180962376,
  239429646,
  1879983724,
  1180962376,
  239429646,
  1879983724,
  1091833428,
  1091571395,
  1091309254,
  1091047111,
  1258557125,
  92495886,
  75891333,
  903,
  312,
  18348,
  -522796,
  1029,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -2146548219,
  -2012326894,
  -1945222126,
  -1878113006,
  -2146547694,
  240124434,
  239407748,
  239407752,
  239342220,
  242815632,
  -1996287360,
  310906369,
  311168577,
  311430723,
  311692867,
  311955010,
  312217157,
  312479297,
  310382152,
  310644342,
  310906433,
  311168577,
  311430724,
  311692868,
  311955012,
  312217157,
  312479301,
  310382152,
  310644318,
  310906435,
  311168581,
  311430721,
  310382166,
  310906435,
  311168580,
  311430725,
  310382172,
  310644304,
  310906436,
  311168580,
  311430724,
  311692870,
  311955014,
  312217156,
  312479300,
  312741444,
  313003588,
  313265733,
  313527876,
  1125387851,
  1091571395,
  1091309254,
  1091047111,
  1157893829,
  -2095939570,
  -2046655227,
  1828947716,
  1091733518,
  1192397838,
  1192398862,
  1192399886,
  1158846478,
  1142070286,
  1209180174,
  1259503630,
  1091732494,
  1158842382,
  1142066190,
  1427279886,
  1212430,
  40,
  18664,
  -522072,
  98,
  135151872,
  239600259,
  235555856,
  247677192,
  2064337412,
  -1018820594,
  1038,
  16,
  18708,
  -522004,
  29,
  0,
  24,
  18728,
  -521992,
  27,
  470696704,
  1394609732,
  1038,
  16,
  18756,
  -521988,
  43,
  0,
  76,
  18776,
  -521960,
  446,
  934144,
  1090589505,
  323027475,
  118573571,
  290652794,
  51477254,
  2097484156,
  318844163,
  323077380,
  323076869,
  323077638,
  323077895,
  2047283459,
  293275153,
  85031939,
  125,
  16,
  18856,
  -521592,
  55,
  0,
  16,
  18876,
  -521548,
  37,
  0,
  16,
  18896,
  -521520,
  55,
  0,
  44,
  18916,
  -521476,
  139,
  135151872,
  1091309121,
  -2025582578,
  59130882,
  33850186,
  -1022620045,
  -972550591,
  -956035519,
  16,
  18964,
  -521380,
  25,
  0,
  244,
  18984,
  -521368,
  174,
  135154432,
  1091309121,
  239144974,
  403587348,
  1092357697,
  239149070,
  672022820,
  1093406273,
  239153166,
  940458292,
  1094454849,
  239157262,
  1208893764,
  1095503425,
  239161358,
  1477329236,
  1096552001,
  239165454,
  1745764708,
  1097600577,
  239169550,
  2014200180,
  1098649153,
  1090617358,
  1090618382,
  1090619406,
  1090620430,
  1090621454,
  1090622478,
  1090623502,
  1090624526,
  1090625550,
  1090626574,
  1090627598,
  1090628622,
  1090629646,
  1090630670,
  1090631694,
  1090632718,
  1090633742,
  1090634766,
  1090635790,
  1090636814,
  1090637838,
  1090638862,
  1090639886,
  1090640910,
  1090641934,
  1090642958,
  1090643982,
  1107422222,
  1107423246,
  1107424270,
  1107425294,
  1107426318,
  1107460110,
  33719310,
  265819,
  64,
  19232,
  -521440,
  60,
  135151872,
  239141510,
  1124303628,
  239410190,
  269374240,
  1091833415,
  239147022,
  537805084,
  1125125704,
  1091309066,
  1091047107,
  1141116614,
  11,
  16,
  19300,
  -521444,
  187,
  0,
  60,
  19320,
  -521272,
  349,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  604916229,
  235584258,
  247677204,
  247873808,
  247939340,
  247808264,
  738820,
  148,
  19384,
  -520984,
  939,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  -535934971,
  240845320,
  239798500,
  239143144,
  239143148,
  239601904,
  1342310624,
  1158210574,
  1107879950,
  1158212622,
  1208545294,
  50913294,
  -468844136,
  -401717496,
  -334609912,
  -267500280,
  -535934968,
  180683272,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189203470,
  336464484,
  269402947,
  202294849,
  135186241,
  68076865,
  2881,
  168,
  19536,
  -520192,
  1070,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  1745771522,
  1147932229,
  239628302,
  1812887648,
  1282412099,
  172187662,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  1164185193,
  239429646,
  1879982444,
  39849546,
  336464498,
  269402947,
  202294849,
  135186241,
  68076865,
  240388935,
  1745765732,
  1097600584,
  239628302,
  239338080,
  1745766244,
  1164709442,
  239628302,
  17105760,
  239887374,
  1812873832,
  1215303239,
  24590,
  16,
  19708,
  -519292,
  45,
  0,
  36,
  19728,
  -519264,
  411,
  135151872,
  -2029253055,
  42355715,
  234982147,
  239191816,
  50692,
  16,
  19768,
  -518888,
  43,
  0,
  116,
  19788,
  -518860,
  723,
  135151872,
  240845443,
  239190788,
  1174569736,
  1103299598,
  42141710,
  1108086339,
  -1979579514,
  1137051662,
  1103299598,
  59116558,
  1879179907,
  1137051662,
  1103299598,
  59116558,
  2063729283,
  1137051662,
  1103299598,
  59116558,
  -2013134205,
  1137051662,
  1103299598,
  59116558,
  -1694367101,
  1103497230,
  12780558,
  16,
  19908,
  -518244,
  73,
  0,
  44,
  19928,
  -518184,
  88,
  135151872,
  1174570824,
  1476527625,
  68044230,
  135152071,
  101253767,
  1187406850,
  13042702,
  16,
  19976,
  -518136,
  43,
  0,
  24,
  19996,
  -518108,
  67,
  135152128,
  1862436689,
  13042702,
  28,
  20024,
  -518056,
  34,
  118048256,
  101271040,
  1120359170,
  198,
  16,
  20056,
  -518040,
  55,
  0,
  44,
  20076,
  -517996,
  143,
  135151872,
  1091309121,
  -2025582578,
  59130882,
  33850186,
  -1022620041,
  -972550591,
  -956035519,
  16,
  20124,
  -517900,
  55,
  0,
  16,
  20144,
  -517856,
  101,
  0,
  16,
  20164,
  -517764,
  45,
  0,
  24,
  20184,
  -517736,
  198,
  135151872,
  -1006501241,
  13042702,
  24,
  20212,
  -517556,
  351,
  135151872,
  1560478343,
  -956035583,
  36,
  20240,
  -517232,
  1543,
  17892096,
  42141710,
  -1023144369,
  135191298,
  -1543372157,
  12780558,
  16,
  20280,
  -515720,
  14,
  0,
  368,
  20300,
  -515724,
  8137,
  239403520,
  33720072,
  -956035381,
  -2029515193,
  68046850,
  42730439,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  -1342045817,
  1204224014,
  25625614,
  950786,
  68044743,
  240583047,
  -1794914560,
  -2029777403,
  941569,
  51643335,
  25625614,
  939522,
  68044743,
  391,
  16,
  20672,
  -507952,
  14,
  0,
  284,
  20692,
  -507956,
  4273,
  239403520,
  1174570760,
  59116558,
  246874634,
  239191560,
  189253380,
  250544650,
  239191560,
  189253380,
  16909066,
  1103497230,
  1204225038,
  240454155,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  63374350,
  168493434,
  -972550552,
  -956035513,
  168549122,
  -972550548,
  -956035519,
  234972163,
  33719816,
  -972812708,
  -2046292409,
  2,
  44,
  20980,
  -503956,
  1335,
  17892096,
  42403854,
  -2096361919,
  135155203,
  242811587,
  240109316,
  1761773320,
  13042702,
  44,
  21028,
  -502660,
  5229,
  18154240,
  42141710,
  -2029253055,
  269369603,
  1543701638,
  -972288494,
  -955773375,
  -1023144383,
  36,
  21076,
  -497476,
  651,
  18350848,
  42403854,
  -2046030271,
  242680323,
  239191560,
  50948,
  44,
  21116,
  -496860,
  176,
  135151872,
  239141511,
  1090749964,
  75698190,
  247704066,
  247873804,
  247939336,
  4,
  608,
  21164,
  -496732,
  5803,
  135157504,
  239665795,
  242336516,
  1090683656,
  59116558,
  -2028990911,
  134416900,
  -955511295,
  -972550591,
  34212677,
  -955511152,
  -972550591,
  34212677,
  -955511208,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511140,
  -972550591,
  34212677,
  -955511211,
  -972550591,
  -1023144383,
  1275726657,
  1103563790,
  1103497230,
  1103299598,
  239929867,
  239191820,
  239191560,
  188859140,
  202263818,
  135152071,
  68043206,
  168509891,
  -955511219,
  -972550591,
  -1023144383,
  1292503873,
  1103563790,
  1103497230,
  1103299598,
  239929867,
  239191820,
  239191560,
  188859140,
  202263818,
  135152071,
  68043206,
  168509891,
  -955511171,
  -972550591,
  -1023144383,
  -2096624063,
  39977730,
  1103299598,
  42141710,
  68074498,
  135152067,
  -1174273405,
  1103299598,
  42141710,
  68066562,
  135152067,
  241828483,
  49924,
  220,
  21776,
  -491536,
  2945,
  135161344,
  1778516611,
  1254294542,
  42141710,
  -1023144377,
  -2096624016,
  248316418,
  239190788,
  33719048,
  -1023144312,
  -2096624063,
  244974082,
  239190788,
  33719048,
  -1023144275,
  -2096624063,
  243073538,
  239190788,
  33719048,
  -1023144324,
  -2096624063,
  243925506,
  239190788,
  33719048,
  -1023144291,
  -2096624063,
  243728898,
  239190788,
  33719048,
  -1023144308,
  -2096624063,
  244974082,
  239190788,
  33719048,
  -1023144275,
  -2096624063,
  244777474,
  239190788,
  33719048,
  -1023144292,
  -2096624063,
  246022658,
  239190788,
  33719048,
  -1023144259,
  -2096624063,
  243991042,
  239190788,
  1929544456,
  1103299598,
  42141710,
  -1023144346,
  180,
  22000,
  -488800,
  6219,
  245891584,
  1124239112,
  59116558,
  236202499,
  242402824,
  239191812,
  1929545480,
  1103561742,
  42403854,
  68044034,
  135152071,
  242811527,
  239191812,
  1258456840,
  1103561742,
  42403854,
  -956035503,
  -2029515199,
  68048130,
  135152071,
  239927943,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035507,
  -2029515199,
  68047618,
  135152071,
  241238663,
  239191812,
  1560446728,
  1103561742,
  42403854,
  -956035485,
  -2029515199,
  68050690,
  135152071,
  241107591,
  239191812,
  235046664,
  50948,
  180,
  22184,
  -482760,
  6252,
  245891584,
  1124239112,
  59116558,
  236202499,
  242468360,
  239191812,
  1929545480,
  1103561742,
  42403854,
  68044034,
  135152071,
  242811527,
  239191812,
  1241679624,
  1103561742,
  42403854,
  -956035502,
  -2029515199,
  68048130,
  135152071,
  240976519,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035491,
  -2029515199,
  68047618,
  135152071,
  241238663,
  239191812,
  1560446728,
  1103561742,
  42403854,
  -956035485,
  -2029515199,
  68050690,
  135152071,
  241107591,
  239191812,
  235046664,
  50948,
  180,
  22368,
  -476688,
  1509,
  245891584,
  1090684680,
  58919950,
  234998787,
  1224917768,
  1103561742,
  42403854,
  68048130,
  135152071,
  240255623,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035499,
  -2029515199,
  68044546,
  135152071,
  240452231,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035507,
  -2029515199,
  68048130,
  135152071,
  241238663,
  239191812,
  1560446728,
  1103561742,
  42403854,
  -956035489,
  -2029515199,
  68051202,
  135152071,
  241107591,
  239191812,
  1594001160,
  1103561742,
  42403854,
  13042702,
  180,
  22552,
  -475352,
  1542,
  245891584,
  1090684680,
  58919950,
  234998787,
  1241694984,
  1103561742,
  42403854,
  68048130,
  135152071,
  240190087,
  239191812,
  1375897352,
  1103561742,
  42403854,
  -956035499,
  -2029515199,
  68048642,
  135152071,
  240452231,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035491,
  -2029515199,
  68048130,
  135152071,
  241238663,
  239191812,
  1560446728,
  1103561742,
  42403854,
  -956035489,
  -2029515199,
  68051202,
  135152071,
  241107591,
  239191812,
  1594001160,
  1103561742,
  42403854,
  13042702,
  216,
  22736,
  -473984,
  980,
  135151872,
  1610809991,
  -956035583,
  -2029515199,
  239403522,
  239191812,
  33720072,
  -956035492,
  -2029515199,
  239403522,
  239191812,
  33720072,
  -956035515,
  -2029515199,
  240255490,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035504,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046338,
  135152071,
  647,
  48,
  22956,
  -473212,
  260,
  135151872,
  1476526727,
  1103561742,
  42403854,
  68067330,
  135152071,
  239600263,
  239191812,
  165640,
  328,
  23008,
  -472992,
  1380,
  135151872,
  402850439,
  -956035582,
  -2029515199,
  68051458,
  135152071,
  241762951,
  239191812,
  1744996104,
  1103561742,
  42403854,
  68057858,
  135152071,
  239534727,
  239191812,
  1342342920,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  243204743,
  239191812,
  1879213832,
  1103561742,
  42403854,
  -956035463,
  -2029515199,
  68052994,
  135152071,
  239731335,
  239191812,
  1493337864,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  239796871,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  239665799,
  239191812,
  165640,
  148,
  23340,
  -471932,
  836,
  240517632,
  1560446728,
  1321665550,
  42403854,
  -956035478,
  -2029515199,
  23593730,
  1103561742,
  42403854,
  68054530,
  135152071,
  242549383,
  239191812,
  1308788488,
  1103561742,
  42403854,
  -956035507,
  -2029515199,
  68047106,
  135152071,
  240059015,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035500,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1124239112,
  1103561742,
  42403854,
  16,
  23492,
  -471236,
  787,
  0,
  16,
  23512,
  -470456,
  531,
  0,
  56,
  23532,
  -469932,
  80,
  135151872,
  239141511,
  1090749964,
  75698190,
  -1022737918,
  -968815602,
  -952039410,
  188810254,
  202294085,
  135185985,
  68077377,
  16,
  23592,
  -469912,
  26,
  0,
  48,
  23612,
  -469900,
  9408,
  248447488,
  1090684680,
  59116558,
  51383874,
  202252867,
  -972550591,
  -956035519,
  234988803,
  0,
  16,
  23664,
  -460544,
  26,
  0,
  52,
  23684,
  -460532,
  1190,
  135157504,
  67306119,
  -2046030334,
  249758211,
  239191560,
  239388420,
  239978240,
  1241614084,
  1187446798,
  25625614,
  16,
  23740,
  -459388,
  14,
  0,
  112,
  23760,
  -459392,
  1906,
  135151872,
  -519961981,
  59116558,
  -2028990911,
  336478468,
  -1610480253,
  46338062,
  -2045505979,
  269374469,
  241828550,
  -771570932,
  75894798,
  -2028728767,
  403587333,
  -1425930621,
  46339086,
  -955249042,
  -972288447,
  -1022882239,
  -2096361919,
  241041923,
  -603733240,
  -1023144446,
  -2096624063,
  2,
  104,
  23876,
  -457588,
  314,
  135151872,
  239141511,
  1090749964,
  75698190,
  -1022728446,
  -968684530,
  -952039410,
  188875790,
  247663169,
  247873804,
  247939336,
  1191922948,
  202294026,
  135185985,
  68077381,
  -2063463613,
  202294026,
  135185987,
  68077377,
  -1017967801,
  -968815602,
  -952039410,
  1038,
  136,
  23984,
  -457376,
  731,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235595522,
  247677204,
  247873808,
  247939340,
  247808264,
  51070468,
  235536686,
  247679508,
  247873808,
  247939340,
  247808264,
  1695236356,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  173015563,
  239416334,
  1007568184,
  1161825861,
  873350411,
  1161301573,
  239418382,
  64,
  92,
  24124,
  -456780,
  245,
  135154176,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074677765,
  1129057884,
  239882254,
  1276005184,
  1280314949,
  239812622,
  1343112012,
  1195380304,
  239291406,
  1074679888,
  336483330,
  269402945,
  202294849,
  135186241,
  68076865,
  56,
  24220,
  -456620,
  497,
  135151872,
  239141510,
  1241744140,
  1224871950,
  1091309066,
  1091047107,
  1225002694,
  24969995,
  239408142,
  470697240,
  2100805,
  16,
  24280,
  -456168,
  51,
  0,
  60,
  24300,
  -607772,
  1087,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  336464486,
  269402945,
  202294849,
  135186241,
  68076865,
  2881,
  16,
  24364,
  -456188,
  10,
  0,
  40,
  24384,
  -456192,
  63,
  135151872,
  239272579,
  470707472,
  1210060353,
  239276046,
  247677192,
  4,
  48,
  24428,
  -456172,
  86,
  672023296,
  1160515138,
  240201742,
  604914472,
  1495273025,
  1208225290,
  235556107,
  1158365956,
  1038,
  44,
  24480,
  -456128,
  464,
  135151872,
  222429829,
  59196165,
  92472454,
  167853827,
  1103512003,
  214254023,
  188810244,
  44,
  24528,
  -455712,
  107,
  135151872,
  239141510,
  1157858060,
  1090654222,
  1091309066,
  1091047107,
  1174671046,
  11,
  84,
  24576,
  -455648,
  113,
  135151872,
  239141510,
  1241744140,
  239145998,
  470696216,
  1210060357,
  239865870,
  403587348,
  1092357701,
  239935502,
  235555088,
  247677196,
  247873800,
  1124813316,
  1175195146,
  1091047107,
  1174671046,
  11,
  44,
  24664,
  -455592,
  215,
  135151872,
  222429829,
  59196165,
  92472454,
  -1022707966,
  -951990719,
  67945793,
  739332,
  176,
  24712,
  -455416,
  1878,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  235600898,
  247678484,
  247875088,
  247939340,
  247808264,
  1124812548,
  239168526,
  1611548784,
  336464451,
  269402945,
  202294849,
  135186241,
  68076865,
  240585541,
  1745764964,
  1097600581,
  240152590,
  235566176,
  247678484,
  247873808,
  247939340,
  247808264,
  1124811780,
  239429646,
  1879982700,
  1868566090,
  239429646,
  1879982700,
  56626760,
  235537076,
  247677204,
  247873808,
  247939340,
  247808264,
  738564,
  16,
  24892,
  -453708,
  23,
  0,
  28,
  24912,
  -453696,
  31,
  672023296,
  1110183493,
  240398350,
  4,
  32,
  24944,
  -453696,
  38,
  135151872,
  173736579,
  1141116611,
  247677195,
  4,
  32,
  24980,
  -453684,
  38,
  135151872,
  173736579,
  1141116611,
  247677195,
  4,
  40,
  25016,
  -453672,
  99,
  135154432,
  240648835,
  240304900,
  202260744,
  240649091,
  239715080,
  4,
  40,
  25060,
  -453604,
  99,
  135154432,
  240648835,
  240304900,
  202260744,
  240649091,
  239715080,
  4,
  40,
  25104,
  -453536,
  99,
  135154432,
  240648835,
  240304900,
  202260744,
  240649091,
  239715080,
  4,
  40,
  25148,
  -453468,
  58,
  135151872,
  239600259,
  235559952,
  247677192,
  1208699396,
  -1019148274,
  1038,
  40,
  25192,
  -453448,
  146,
  135151872,
  239141510,
  1124303628,
  174923790,
  -1019016178,
  -968816626,
  189400078,
  468,
  25236,
  -453332,
  1867,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -535935483,
  -334598399,
  -267501311,
  -535933951,
  235557377,
  247677716,
  247873808,
  247939340,
  247808264,
  34292228,
  336464451,
  269402947,
  202294849,
  135186241,
  68076865,
  173280071,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189137934,
  32247399,
  32509505,
  31460938,
  31985225,
  32247361,
  32509505,
  31460936,
  -468824318,
  -401714175,
  -334609151,
  -267501055,
  -535934975,
  -468823295,
  -401713151,
  -334609151,
  -267501055,
  -535934975,
  244187649,
  239403492,
  239141352,
  239206892,
  239600112,
  240058848,
  239141356,
  239600112,
  240320992,
  240386540,
  239600112,
  242876896,
  239600108,
  239600112,
  1174536672,
  1224862734,
  1157754894,
  1090647054,
  1090648078,
  1107426318,
  1208123406,
  33677326,
  31723150,
  31985217,
  32247370,
  32509505,
  31460936,
  31723115,
  31985217,
  32247361,
  32509508,
  31460940,
  31723099,
  31985217,
  32247364,
  32509505,
  31460959,
  32247421,
  32509505,
  31460936,
  31723111,
  31985219,
  32247361,
  32509505,
  31460936,
  -334608382,
  -267500799,
  -535934975,
  172491265,
  1107420174,
  1157752846,
  1157753870,
  1208086542,
  -334601973,
  -267501311,
  -535934975,
  239534593,
  239469036,
  239600112,
  239862240,
  239141356,
  241172976,
  1375863264,
  1090645006,
  1208086542,
  33677326,
  31723087,
  31985217,
  32247361,
  32509505,
  31460940,
  16,
  25708,
  -451932,
  35,
  0,
  72,
  25728,
  -451904,
  155,
  135151872,
  239141510,
  1124303628,
  175968270,
  -1019016178,
  -968816626,
  189400078,
  1109134915,
  239607822,
  470701584,
  1210060355,
  172429326,
  -1019016178,
  -968816626,
  189203470,
  28,
  25804,
  -451820,
  36,
  269372928,
  1108610629,
  239409166,
  537806108,
  28,
  25836,
  -451804,
  31,
  672023296,
  1110183493,
  240398350,
  4,
  68,
  25868,
  -451804,
  78,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1022724347,
  -968814578,
  -952038386,
  -985593842,
  188875790,
  269402950,
  202294849,
  135186241,
  68076865,
  80,
  25940,
  -451796,
  137,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806242053,
  235561218,
  247677204,
  247873808,
  247939340,
  247808264,
  1208698884,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  1038,
  16,
  26024,
  -451736,
  35,
  0,
  24,
  26044,
  -451708,
  37,
  135151872,
  240648835,
  49924,
  24,
  26072,
  -451688,
  37,
  135151872,
  240648835,
  49924,
  104,
  26100,
  -451668,
  117,
  135151872,
  239141511,
  1124304396,
  75698190,
  1091833422,
  239212558,
  537805084,
  1360006728,
  239145998,
  470696472,
  1210060353,
  240193550,
  403587348,
  1092357698,
  239411214,
  -1022738160,
  -968815602,
  -952039410,
  189203470,
  1091833418,
  239212558,
  537805084,
  1052229,
  44,
  26208,
  -451648,
  56,
  135151872,
  239141510,
  1191412492,
  240979982,
  537805340,
  1091309133,
  1091047107,
  265926,
  60,
  26256,
  -451632,
  291,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  470696709,
  235581954,
  247677204,
  247873808,
  247939340,
  247808264,
  738052,
  164,
  26320,
  -451392,
  342,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  940465666,
  1144786498,
  239550478,
  873352496,
  1161301572,
  239156238,
  806244416,
  1111232091,
  239616014,
  873361200,
  1094192710,
  239156238,
  806243392,
  336464453,
  269402945,
  202294849,
  135186241,
  68076865,
  239274822,
  1074676284,
  1630539336,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1174671045,
  235553547,
  247677716,
  247873808,
  247939340,
  247808264,
  737540,
  68,
  26488,
  -451208,
  70,
  135151872,
  239141511,
  1090749964,
  75698190,
  1108872792,
  239148046,
  269370656,
  247663190,
  247874316,
  247939336,
  1124811524,
  1091309251,
  1091047110,
  265927,
  60,
  26560,
  -451200,
  1038,
  135151872,
  222429829,
  59197701,
  92472454,
  -1022722302,
  -951990719,
  67945793,
  51069444,
  -1022754324,
  -951990717,
  67945793,
  739076,
  16,
  26624,
  -450224,
  34,
  0,
  16,
  26644,
  -450196,
  26,
  0,
  132,
  26664,
  -450184,
  419,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  873349893,
  1110969941,
  239156238,
  806242368,
  336464478,
  269402947,
  202294849,
  135186241,
  68076865,
  240585539,
  940458292,
  1161563713,
  241909774,
  873354800,
  1110969935,
  239156238,
  806242368,
  873354242,
  1110969921,
  239156238,
  806243648,
  235559682,
  940458548,
  1161563717,
  189087758,
  40,
  26800,
  -449888,
  79,
  135151872,
  239141510,
  1191412492,
  1124208654,
  -1019147250,
  -968816626,
  1038,
  60,
  26844,
  -449852,
  727,
  135151872,
  222429829,
  59196933,
  92472454,
  167903747,
  1103512003,
  214254023,
  188810244,
  1103301207,
  1103577542,
  67374277,
  2881,
  108,
  26908,
  -449180,
  159,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1007567621,
  1212157509,
  240070670,
  1074676028,
  1580207688,
  239416334,
  1007568184,
  1212157505,
  240529422,
  1074676028,
  1194331720,
  239156238,
  806242368,
  336464451,
  269402947,
  202294849,
  135186241,
  68076865,
  2881,
  24,
  27020,
  -449132,
  29,
  1544438528,
  1348472389,
  1038,
  24,
  27048,
  -449128,
  29,
  1544438528,
  1348472389,
  1038,
  16,
  27076,
  -449124,
  16,
  0,
  52,
  27096,
  -449128,
  60,
  135151872,
  239141510,
  1124303628,
  240193550,
  470696472,
  1260392001,
  240455694,
  247677196,
  247873800,
  4,
  52,
  27152,
  -449120,
  71,
  135151872,
  239141511,
  1174636044,
  75698190,
  1897926211,
  1091571210,
  1091309251,
  1091047110,
  1090784967,
  11,
  40,
  27208,
  -449096,
  49,
  135151872,
  239141511,
  1090749964,
  75698190,
  -1022620064,
  -972550591,
  -956035519,
  16,
  27252,
  -449076,
  31,
  0,
  16,
  27272,
  -449064,
  54,
  0,
  40,
  27292,
  -449020,
  44,
  135151872,
  1091309121,
  42078222,
  75891587,
  -972288410,
  -1022882239,
  -1039921599,
  40,
  27336,
  -449016,
  36,
  135151872,
  1091309121,
  42143758,
  75629441,
  -1039397282,
  -1056436671,
  -1023144383,
  16,
  27380,
  -449012,
  86,
  269383424,
  76,
  27400,
  -448936,
  161,
  135152896,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537807365,
  1091833446,
  1091571395,
  1091309254,
  1091047111,
  1141116613,
  92479502,
  75891333,
  1459749767,
  239414286,
  48,
  40,
  27480,
  -448840,
  99,
  135151872,
  222429829,
  59196933,
  92472454,
  1103320578,
  1103577542,
  67374277,
  60,
  27524,
  -448772,
  205,
  135151872,
  222429829,
  59196933,
  92472454,
  -1022712830,
  -951990719,
  67945793,
  1175144452,
  -968768758,
  -985544895,
  1191445516,
  11,
  160,
  27588,
  -448628,
  652,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1341241851,
  239206913,
  239141308,
  239600064,
  241369520,
  239403452,
  240255424,
  1744961968,
  1107407886,
  1157740558,
  1090632718,
  1845608462,
  1627500558,
  1107407886,
  1157740558,
  1124187150,
  1828831246,
  1140962318,
  1157740558,
  1191296014,
  1208074254,
  1275179022,
  1157741582,
  1291960334,
  1124187150,
  1744941070,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1174671045,
  11,
  16,
  27752,
  -448136,
  13,
  269370112,
  44,
  27772,
  -448140,
  47,
  135151872,
  239141510,
  1241744140,
  240193550,
  403587348,
  1109134917,
  239607822,
  16,
  16,
  27820,
  -448140,
  2,
  0,
  16,
  27840,
  -448144,
  81,
  0,
  16,
  27860,
  -448068,
  3,
  0,
  68,
  27880,
  -448072,
  951,
  135155712,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1745765125,
  235018499,
  247677204,
  247873808,
  247939340,
  247808264,
  1745765636,
  42272131,
  59180166,
  320,
  27952,
  -447184,
  2021,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  1346113124,
  239616014,
  873359408,
  1110969929,
  239221774,
  873350464,
  53481029,
  1007551292,
  1396706884,
  240005134,
  940458292,
  1094454849,
  239616014,
  1007579696,
  37752394,
  2033192576,
  239156238,
  1007568448,
  1110969921,
  239156238,
  806243136,
  1110969931,
  239418382,
  806242368,
  1161563741,
  239616014,
  873353264,
  1094192706,
  239156238,
  806242368,
  1094454896,
  239616014,
  172622384,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189269006,
  167846659,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  1161563715,
  239616014,
  940463664,
  1161563713,
  240009230,
  235557168,
  940458548,
  1161563717,
  189087758,
  940444227,
  1111232069,
  189874190,
  873335365,
  1161301573,
  239418382,
  1158366528,
  1161039370,
  239417358,
  1074677052,
  172297029,
  239219726,
  1007568184,
  1161825861,
  873350411,
  1161301570,
  239418382,
  64,
  80,
  28276,
  -445476,
  754,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1343113221,
  1163660879,
  239427598,
  27132752,
  239426574,
  1343112544,
  336464451,
  269402947,
  202294849,
  135186241,
  68076865,
  2883,
  56,
  28360,
  -444792,
  86,
  135151872,
  239141511,
  1090749964,
  75698190,
  -1022738430,
  -968487922,
  -952039410,
  189137934,
  202294081,
  135185987,
  68077377,
  32,
  28420,
  -444756,
  77,
  135155968,
  239272579,
  235560464,
  247677192,
  738564,
  116,
  28456,
  -444712,
  248,
  135151872,
  239141511,
  1090749964,
  75698190,
  65801798,
  66063941,
  65015368,
  235561474,
  247677200,
  247873804,
  247939336,
  1342914820,
  1175457290,
  1124863683,
  1091047110,
  1241779911,
  -401718517,
  -334609917,
  -267500285,
  -535934973,
  -468825853,
  -401718781,
  -334609149,
  -267501309,
  -535932413,
  3,
  68,
  28576,
  -444576,
  136,
  135153152,
  239141511,
  1124304396,
  75698190,
  336478210,
  1092095553,
  239148046,
  269371424,
  247663169,
  247873804,
  247939336,
  1561020420,
  239148046,
  269371424,
  16,
  28648,
  -444504,
  8,
  269370112,
  16,
  28668,
  -444508,
  17,
  0,
  44,
  28688,
  -444496,
  1190,
  135151872,
  222429829,
  59196165,
  92472454,
  167861507,
  1103512003,
  214254023,
  189400068,
  164,
  28736,
  -443344,
  459,
  135154176,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241541,
  1007594754,
  1195380289,
  239223822,
  1276003400,
  1146097218,
  239162382,
  1544438872,
  1163923011,
  241119246,
  247677204,
  247873808,
  247939340,
  247808264,
  806247172,
  42272131,
  59180166,
  1094454855,
  239616014,
  873351472,
  1194856012,
  239221774,
  1141785152,
  1095241282,
  239291406,
  806241616,
  235555074,
  940458548,
  1161563717,
  189087758,
  1110707781,
  239417358,
  1074677052,
  84,
  28904,
  -443048,
  94,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  537806341,
  1093406293,
  239611918,
  247678228,
  247873808,
  247939340,
  247808264,
  537808388,
  42272131,
  59180166,
  1093406282,
  239611918,
  32,
  16,
  28992,
  -443040,
  25,
  0,
  100,
  29012,
  -139796,
  183,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  1261178486,
  240332814,
  739135264,
  1177554499,
  239741966,
  739132976,
  1211108931,
  172433422,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189072398,
  1159990853,
  239413262,
  806241580,
  48,
  29116,
  -139708,
  81,
  135151872,
  239141510,
  1157858060,
  242552846,
  537805084,
  1192234570,
  -1019147250,
  -968816626,
  1038,
  44,
  29168,
  -139664,
  83,
  269370112,
  1159204438,
  239148046,
  269371424,
  1159204442,
  239148046,
  269371424,
  265795,
  60,
  29216,
  -443232,
  62,
  135151872,
  239141510,
  1124303628,
  239736846,
  537805340,
  1427115592,
  1091309066,
  1091047107,
  1208225478,
  202261259,
  135185217,
  68077121,
  16,
  29280,
  -443232,
  6,
  0,
  16,
  29300,
  -443236,
  6,
  0,
  64,
  29320,
  -443240,
  112,
  135151872,
  239141510,
  1157858060,
  240979982,
  537807644,
  1309675087,
  1091309066,
  1091047107,
  1107562182,
  336481291,
  1159204421,
  239410190,
  32,
  60,
  29388,
  -443196,
  2508,
  135151872,
  222429829,
  59196165,
  92472454,
  168216323,
  1103512003,
  214254023,
  188941316,
  167866883,
  1103512003,
  214254023,
  188941316,
  136,
  29452,
  -440748,
  236,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806243333,
  1161301579,
  239418382,
  806241600,
  336464472,
  269402945,
  202294849,
  135186241,
  68076865,
  239536970,
  940459316,
  1161563717,
  239616014,
  873354544,
  1161301573,
  239156238,
  806242368,
  1094192721,
  239156238,
  806242368,
  336464451,
  269402945,
  202294849,
  135186241,
  68076865,
  2888,
  208,
  29592,
  -440648,
  645,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074678789,
  1162350155,
  239422478,
  1074677072,
  1212681833,
  239356942,
  1208895312,
  1094979142,
  174342158,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189203470,
  1162088021,
  239421454,
  1343112524,
  1480592972,
  239420430,
  1276003656,
  1213206081,
  240861198,
  1208895556,
  1095503425,
  239423502,
  1074684996,
  336464466,
  269402945,
  202294851,
  135186241,
  68076865,
  2130840391,
  239159310,
  1343111500,
  1329598024,
  239159310,
  1343111500,
  1463815756,
  239159310,
  1343111500,
  1396706888,
  239159310,
  1343111500,
  4197964,
  56,
  29804,
  -440204,
  132,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  537807877,
  336489218,
  269402947,
  202294849,
  135186241,
  68076865,
  24,
  29864,
  -140264,
  30,
  470700800,
  1210060353,
  1038,
  132,
  29892,
  -440148,
  216,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806242309,
  1127747151,
  239156238,
  806242368,
  336464474,
  269402945,
  202294849,
  135186241,
  68076865,
  239274825,
  1007567672,
  1212157505,
  239546382,
  1007567672,
  1212157507,
  241774606,
  1074676028,
  1345326664,
  240270350,
  806242368,
  1091833411,
  1091571395,
  1091309254,
  1091047111,
  265925,
  44,
  30028,
  -440060,
  755,
  135151872,
  222429829,
  59196165,
  92472454,
  -1022726398,
  -951990719,
  67945793,
  739332,
  64,
  30076,
  -439340,
  83,
  135151872,
  239141510,
  1124303628,
  240979982,
  470696472,
  1210060353,
  173019150,
  -1019016178,
  -968816626,
  189203470,
  1175195203,
  1091047107,
  265926,
  100,
  30144,
  -439312,
  106,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837629,
  739133957,
  1211108929,
  239869966,
  672022820,
  1126960705,
  239611918,
  672025636,
  1093406277,
  239611918,
  739134240,
  1211108929,
  239280142,
  247677204,
  247873808,
  247939340,
  247808264,
  4,
  44,
  30248,
  -439304,
  847,
  135151872,
  222888581,
  59196933,
  92472454,
  -1022735358,
  -951990719,
  67945793,
  737540,
  44,
  30296,
  -438504,
  978,
  135151872,
  222429829,
  59196933,
  92472454,
  167915523,
  1103512003,
  214254023,
  189006852,
  68,
  30344,
  -437560,
  179,
  135151872,
  239272583,
  1174636044,
  75698190,
  403573332,
  1092357697,
  239607822,
  336482576,
  1159204418,
  239410190,
  34294560,
  202294109,
  135185988,
  68077377,
  16,
  30416,
  -437440,
  18,
  0,
  196,
  30436,
  -437428,
  863,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  234980355,
  1611549020,
  1113853513,
  239364110,
  1879982700,
  1165233729,
  239368206,
  -2146548612,
  1343112449,
  235574530,
  247677716,
  247873808,
  247939340,
  247808264,
  1510688004,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  239337995,
  1611547996,
  1097076297,
  239364110,
  1879982700,
  1114902082,
  239368206,
  -2146548612,
  1343112449,
  1410206319,
  1163398725,
  239426574,
  1158366560,
  1163136522,
  239425550,
  1611547996,
  239864645,
  1477330260,
  1163660869,
  24590,
  184,
  30636,
  -436764,
  1131,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167903491,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188875790,
  1231818348,
  239890446,
  2014200436,
  1115426375,
  1090617358,
  1157727246,
  1140951054,
  1140952078,
  1157730318,
  318988302,
  1164709377,
  239890446,
  2014200180,
  1115426375,
  1107394574,
  1107395598,
  1140951054,
  1140952078,
  1157730318,
  1879203854,
  1164185098,
  239429646,
  1879983468,
  172297029,
  239428622,
  1812874600,
  1164971589,
  1678658571,
  1164447301,
  239430670,
  112,
  212,
  30824,
  -435816,
  919,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  1410243074,
  1096289866,
  239164430,
  1343113312,
  1544438530,
  1231031881,
  239232014,
  1812874344,
  1164971586,
  239694862,
  2081309816,
  25169476,
  38800965,
  336464548,
  269402947,
  202294849,
  135186241,
  68076865,
  173804361,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189137934,
  1544479490,
  1231031877,
  239166478,
  1812874344,
  1114639938,
  239236110,
  2081309816,
  25169476,
  2035289669,
  1163136522,
  239425550,
  1611547996,
  172297029,
  239424526,
  1544439128,
  1163923013,
  1410223115,
  1163398725,
  239426574,
  96,
  188,
  31040,
  -435104,
  1104,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  167899395,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188875790,
  1230769772,
  239689742,
  1745764964,
  1114377796,
  239169550,
  2014201204,
  1148980804,
  1157726222,
  318984206,
  1163660801,
  239689742,
  1745764708,
  1114377796,
  239235086,
  2014200436,
  1148980804,
  1157726222,
  1476546574,
  1163136522,
  239425550,
  1611547996,
  172297029,
  239424526,
  1544439128,
  1163923013,
  235554059,
  1477330260,
  1163660869,
  189095950,
  1163136588,
  239425550,
  1611547996,
  192,
  31232,
  -434192,
  747,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  167853571,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189203470,
  1230769778,
  239689742,
  1745764964,
  1114377796,
  239169550,
  2014201204,
  1148980804,
  1157726222,
  1191333902,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1174671045,
  235564043,
  247677204,
  247873808,
  247939340,
  247808264,
  34291972,
  1163660869,
  239689742,
  1745764708,
  1114377796,
  239235086,
  2014200436,
  1148980804,
  1224835086,
  175001614,
  239424526,
  1544439128,
  1163923013,
  11,
  336,
  31428,
  -433636,
  1907,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167847427,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189203470,
  1231818353,
  239890446,
  2014200436,
  1115426375,
  1090617358,
  1157727246,
  1140951054,
  1140952078,
  1157730318,
  -2029821938,
  1147407874,
  239429646,
  1879982444,
  1182010949,
  239171598,
  -2146548612,
  1611549697,
  235562242,
  247677204,
  247873808,
  247939340,
  247808264,
  1896562948,
  239430670,
  1947094128,
  1199050305,
  239238158,
  239206784,
  239206788,
  239337864,
  239337868,
  239665552,
  249823840,
  1745767012,
  1097600581,
  239431694,
  2014200180,
  1148980801,
  1275166734,
  -1862115314,
  1164185098,
  239429646,
  1879983468,
  172297029,
  239428622,
  1812874600,
  1164971589,
  235554059,
  1745765732,
  1164709445,
  189100046,
  1678641733,
  1164447301,
  239430670,
  1158366576,
  1164185098,
  239429646,
  1879983468,
  172297029,
  239428622,
  1812874600,
  1164971589,
  235554059,
  1745765732,
  1164709445,
  189100046,
  1164185157,
  239429646,
  1879983468,
  400,
  31768,
  -432056,
  2699,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167849475,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189203470,
  1231818356,
  239890446,
  2014200436,
  1115426375,
  1090617358,
  1157727246,
  1140951054,
  1140952078,
  1157730318,
  973299726,
  1678641667,
  1164447301,
  239430670,
  2047559024,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  1812885771,
  1282412101,
  239170574,
  2081310584,
  25169474,
  25431618,
  25693762,
  25955908,
  26218052,
  56626761,
  1678639391,
  1164447300,
  239168526,
  1947092336,
  1098387014,
  239369230,
  239862144,
  22741856,
  239363086,
  1812874600,
  1164971585,
  239498254,
  2081309048,
  25169476,
  39849544,
  1197739620,
  239429646,
  1879982444,
  1148456521,
  239171598,
  -2146548612,
  1611549697,
  235571458,
  1745765732,
  1164709445,
  189100046,
  1678641733,
  1164447301,
  239430670,
  1326138736,
  1164185098,
  239429646,
  1879983468,
  172297029,
  239428622,
  1812874600,
  1164971589,
  235554059,
  1745765732,
  1164709445,
  189100046,
  1678641733,
  1164447301,
  239430670,
  1158366576,
  1164185098,
  239429646,
  1879983468,
  172297029,
  239428622,
  1812874600,
  1164971589,
  235554059,
  1745765732,
  1164709445,
  189100046,
  328,
  32172,
  -429756,
  3596,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  235026691,
  -2146546820,
  -2079437823,
  -2012331519,
  -1945221375,
  -1878113791,
  -1811005183,
  -1743895295,
  -1676786687,
  -1609677823,
  1879983361,
  167853315,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189400078,
  167854083,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189006862,
  167880195,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  2081325314,
  25169477,
  25431628,
  25693761,
  25955911,
  26218050,
  26480194,
  26742338,
  27004484,
  27266628,
  40898121,
  1947077250,
  1165495877,
  239434766,
  189071744,
  1947077224,
  1165495877,
  239434766,
  189071744,
  167930371,
  239432718,
  2081310072,
  25169477,
  721619781,
  1947077121,
  1165495877,
  239434766,
  189071744,
  1947077224,
  1165495877,
  239434766,
  189071744,
  1947077198,
  1165495877,
  239434766,
  189530496,
  1947077216,
  1165495877,
  239434766,
  189071744,
  1947077216,
  1165495877,
  239434766,
  189071744,
  236,
  32504,
  -426488,
  1416,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167865859,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189203470,
  1231818360,
  239890446,
  2014200436,
  1115426375,
  1090617358,
  1157727246,
  1140951054,
  1140952078,
  1157730318,
  973299726,
  336464386,
  269402945,
  202294849,
  135186241,
  68076865,
  242289473,
  1879983468,
  1098124876,
  239564814,
  -2146549124,
  -2079440383,
  -2012331519,
  -1945222143,
  -1878113279,
  1611548929,
  235570434,
  1745765732,
  1164709445,
  189100046,
  1678641733,
  1164447301,
  239430670,
  1158366576,
  1164185098,
  239429646,
  1879983468,
  172297029,
  239428622,
  1812874600,
  1164971589,
  1678656779,
  1164447301,
  239430670,
  112,
  340,
  32744,
  -425304,
  2087,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167851523,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189203470,
  1231818359,
  239890446,
  2014200436,
  1115426375,
  1090617358,
  1157727246,
  1140951054,
  1140952078,
  1157730318,
  -1056743410,
  1147407874,
  239429646,
  1879982444,
  1182010949,
  239368206,
  -2146548612,
  1611549697,
  235563778,
  247677204,
  247873808,
  247939340,
  247808264,
  1896562948,
  239430670,
  1947094128,
  1199050305,
  239238158,
  239206784,
  239206788,
  239337864,
  239337868,
  239665552,
  17105760,
  239625230,
  1812875112,
  1164971585,
  239170574,
  2081309048,
  25169476,
  39849548,
  1678641805,
  1164447301,
  239430670,
  1158366576,
  1164185098,
  239429646,
  1879983468,
  172297029,
  239428622,
  1812874600,
  1164971589,
  235554059,
  1745765732,
  1164709445,
  189100046,
  235553538,
  1745765732,
  1164709445,
  189100046,
  1678641733,
  1164447301,
  239430670,
  1158366576,
  1164185098,
  239429646,
  1879983468,
  239405893,
  1745765732,
  1164709445,
  28686,
  236,
  33088,
  -423552,
  1360,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167862787,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  1215041141,
  239890446,
  2014200436,
  1115426375,
  1090617358,
  1157727246,
  1140951054,
  1140952078,
  1224839182,
  503537678,
  336464386,
  269402950,
  202294851,
  135186241,
  68076865,
  241896257,
  1879983468,
  1098124876,
  239564814,
  -2146549124,
  -2079440383,
  -2012331519,
  -1945222143,
  -1878113279,
  1611547905,
  235568130,
  1745765732,
  1164709445,
  189100046,
  1678641733,
  1164447301,
  239430670,
  1158366576,
  1164185098,
  239429646,
  1879983468,
  172297029,
  239428622,
  1812874600,
  1164971589,
  1678656779,
  1164447301,
  239430670,
  112,
  340,
  33328,
  -422432,
  2068,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167853571,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189203470,
  1231818359,
  239890446,
  2014200436,
  1115426375,
  1090617358,
  1157727246,
  1140951054,
  1140952078,
  1157730318,
  -1056743410,
  1147407874,
  239429646,
  1879982444,
  1182010949,
  239368206,
  -2146548612,
  1611549697,
  235563778,
  247677204,
  247873808,
  247939340,
  247808264,
  1896562948,
  239430670,
  1947094128,
  1199050305,
  239238158,
  239206784,
  239206788,
  239337864,
  239337868,
  239665552,
  17040224,
  239625230,
  1812875112,
  1164971585,
  239170574,
  2081309048,
  25169476,
  39849548,
  1678641801,
  1164447301,
  239430670,
  1158366576,
  1164185098,
  239429646,
  1879983468,
  172297029,
  239428622,
  1812874600,
  1164971589,
  235554059,
  1745765732,
  1164709445,
  189100046,
  1678641773,
  1164447301,
  239430670,
  1158366576,
  1164185098,
  239429646,
  1879983468,
  172297029,
  239428622,
  1812874600,
  1164971589,
  1678656779,
  1164447301,
  239430670,
  112,
  184,
  33672,
  -420696,
  1007,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167871491,
  -1018817522,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  336464479,
  269402945,
  202294849,
  135186241,
  68076865,
  1778518856,
  239561742,
  1947092848,
  1115164226,
  239434766,
  239141248,
  239403396,
  239534472,
  239534476,
  239403408,
  181142112,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  1265372775,
  239562766,
  2014200436,
  1165758018,
  1140949006,
  1157727246,
  1191282702,
  1191283726,
  1157730318,
  24590,
  96,
  33860,
  -419876,
  234,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1276003077,
  38800991,
  1614810691,
  239683598,
  1343112268,
  1564479048,
  1175719434,
  1091571395,
  1091309254,
  1091047111,
  1141116613,
  336485643,
  269402945,
  202294849,
  135186241,
  68076865,
  56,
  33960,
  -419736,
  221,
  135151872,
  222429829,
  59196165,
  92472454,
  -1022706686,
  -951990719,
  67945793,
  1225476868,
  1103512003,
  214254023,
  1028,
  48,
  34020,
  -144388,
  69,
  269370112,
  1175981653,
  239148046,
  269371424,
  68028995,
  239274822,
  537806364,
  1125125704,
  1038,
  16,
  34072,
  -419624,
  6,
  0,
  180,
  34092,
  -419628,
  479,
  135151872,
  239141511,
  1090749964,
  75698190,
  1165758019,
  1208057870,
  242905102,
  2014201204,
  1115426369,
  1208057870,
  240676878,
  2081310584,
  25169473,
  25431618,
  25693762,
  25955905,
  26218050,
  40898120,
  1182273136,
  239172622,
  239600000,
  235557488,
  247677200,
  247873804,
  247939336,
  1124812804,
  239172622,
  240255360,
  2081311600,
  25169473,
  1651510856,
  239432718,
  2081309048,
  25169473,
  1215303240,
  239500302,
  240255360,
  235556464,
  247678480,
  247873804,
  247939336,
  739076,
  76,
  34276,
  -419332,
  102,
  135154176,
  239141511,
  1124304396,
  75698190,
  1344278087,
  239151118,
  806240556,
  1193283144,
  1091571210,
  1091309251,
  1091047110,
  1191448263,
  269376523,
  202294081,
  135185985,
  68077377,
  120,
  34356,
  -419300,
  996,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343113221,
  235555074,
  247677716,
  247873808,
  247939340,
  247808264,
  34292996,
  1113329310,
  239624206,
  249299536,
  1611547740,
  1783631436,
  239229966,
  1343113312,
  1544472322,
  1348472390,
  -1392357362,
  239295502,
  1343113312,
  1096552011,
  239624206,
  80,
  24,
  34480,
  -418416,
  24,
  470699264,
  1210060353,
  1038,
  16,
  34508,
  -418412,
  25,
  0,
  40,
  34528,
  -144816,
  40,
  135151872,
  239272579,
  470699536,
  1210060353,
  239538190,
  247677192,
  4,
  28,
  34572,
  -144812,
  33,
  403587840,
  1176243781,
  240263182,
  4,
  64,
  34604,
  -418476,
  141,
  135151872,
  239272579,
  235556880,
  247677192,
  1846233860,
  239148046,
  269371424,
  135137866,
  68076353,
  240192326,
  403588372,
  1159466565,
  8206,
  216,
  34672,
  -418400,
  466,
  135151872,
  239141511,
  1090749964,
  75698190,
  1227099715,
  239413262,
  806241580,
  1814040136,
  239413262,
  806240812,
  1310723656,
  239413262,
  806240556,
  1310723656,
  239413262,
  806241068,
  1093406281,
  239413262,
  806241068,
  2132807246,
  1125125642,
  1091309251,
  1091047110,
  1174671047,
  235559435,
  247677712,
  247873804,
  247939336,
  1191921924,
  239152142,
  537810224,
  1143213644,
  239151118,
  806240556,
  1428426312,
  239413262,
  806240556,
  1260392008,
  239152142,
  537806896,
  269355587,
  202294085,
  135185985,
  68077377,
  239274817,
  739134760,
  1211108934,
  239738894,
  672023076,
  1160515141,
  12302,
  28,
  34892,
  -418140,
  28,
  403587840,
  1176243786,
  239607822,
  4,
  208,
  34924,
  -418140,
  479,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806242821,
  1094454882,
  240205838,
  940465968,
  1094454849,
  239616014,
  239469104,
  1007569976,
  1212157505,
  239546382,
  1007568184,
  1212157505,
  172961806,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189137934,
  1094454851,
  239616014,
  940471600,
  1094454854,
  239878158,
  940458300,
  1094454849,
  239616014,
  235565872,
  247677716,
  247873808,
  247939340,
  247808264,
  1175144452,
  239156238,
  806242368,
  1093930567,
  239155214,
  1074676028,
  1160777288,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  60,
  35136,
  -145328,
  146,
  135152384,
  239272583,
  1090749964,
  75698190,
  1092357758,
  240328718,
  470703888,
  1344278082,
  -1018884082,
  -968815602,
  -952039410,
  1038,
  528,
  35200,
  -417936,
  1578,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1609677307,
  -1408341247,
  -1341242111,
  -1609677567,
  -1475459583,
  -1408350207,
  -1341243135,
  -1609676799,
  -1408348159,
  -1341242111,
  -1609675775,
  235554305,
  247677716,
  247873808,
  247939340,
  247808264,
  1393247492,
  1157737486,
  1208070158,
  1963040782,
  1191291918,
  1291956238,
  1124183054,
  1711382542,
  1090628622,
  1275179022,
  33660942,
  28053074,
  28315201,
  27266632,
  28053082,
  28315201,
  27266632,
  28053081,
  28315205,
  27266629,
  28053059,
  28315204,
  27266636,
  336464454,
  269402945,
  202294851,
  135186241,
  68076865,
  240388937,
  239206824,
  239141292,
  239600048,
  1073873312,
  1191291918,
  1291956238,
  1191291918,
  1795268622,
  1090627598,
  1090628622,
  1208070158,
  1191288846,
  1090628622,
  1275179022,
  2030149646,
  1090628622,
  1208070158,
  1459724302,
  1157737486,
  1157738510,
  1124179982,
  1140960270,
  1174515726,
  1140960270,
  1208070158,
  1560387598,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1174671045,
  -1542564597,
  -1475458815,
  -1408351743,
  -1341243135,
  -1609676799,
  -1408345599,
  -1341241599,
  -1609676799,
  -1542567935,
  -1475459839,
  -1408351999,
  -1341243135,
  -1609676799,
  -1408349183,
  -1341243135,
  -1609675775,
  -1475454719,
  -1408351743,
  -1341243135,
  -1609676799,
  239534593,
  239141284,
  239468968,
  239141292,
  239600048,
  240255392,
  239206824,
  239141292,
  239600048,
  241303968,
  239403436,
  239403440,
  239403424,
  239468972,
  239927728,
  241172896,
  239141292,
  239600048,
  -1526595168,
  1090628622,
  1208070158,
  1593942030,
  1090628622,
  1208070158,
  33660942,
  28053067,
  28315207,
  27266629,
  32,
  35732,
  -145764,
  450,
  269371392,
  234987267,
  537805084,
  1125125714,
  1038,
  68,
  35768,
  -416920,
  227,
  135154688,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  470696709,
  235573762,
  247677204,
  247873808,
  247939340,
  247808264,
  1661683716,
  -977075186,
  51142,
  72,
  35840,
  -416752,
  1454,
  135151872,
  222429829,
  59196165,
  92472454,
  -1022697982,
  -951990719,
  67945793,
  34294020,
  1103301252,
  1103577542,
  67374277,
  173738825,
  1103512003,
  214254023,
  189400068,
  16,
  35916,
  -415372,
  66,
  0,
  116,
  35936,
  -415312,
  534,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  1007567618,
  1245711942,
  172437518,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189465614,
  336464463,
  269402947,
  202294849,
  135186241,
  68076865,
  1526860619,
  239156238,
  806243648,
  234948867,
  940459316,
  1161563717,
  16398,
  60,
  36056,
  -414888,
  721,
  135151872,
  222757509,
  59196165,
  92472454,
  -1022701566,
  -951990719,
  67945793,
  1896563204,
  -968768758,
  -985544895,
  1141113868,
  11,
  72,
  36120,
  -414216,
  115,
  135151872,
  239403651,
  470703376,
  1210060354,
  239276046,
  537805084,
  1091046984,
  1174671043,
  42143758,
  1125649987,
  239279118,
  269372192,
  1125912143,
  239804430,
  16,
  16,
  36196,
  -414164,
  13,
  0,
  60,
  36216,
  -414168,
  2703,
  135151872,
  222429829,
  59197701,
  92472454,
  -1022728190,
  -951990719,
  67945793,
  51071236,
  -1022754007,
  -951990719,
  67945793,
  738308,
  108,
  36280,
  -145848,
  246,
  135151872,
  239141511,
  1191413260,
  75698190,
  1159466570,
  239935502,
  470706960,
  1210060353,
  239603726,
  537805084,
  1628442186,
  239474702,
  537806364,
  1292897880,
  239278094,
  537805340,
  1158680146,
  202294026,
  135185985,
  68077377,
  239405889,
  403588372,
  1159466565,
  8206,
  32,
  36392,
  -411640,
  101,
  135153408,
  175833731,
  1174671043,
  247684107,
  4,
  16,
  36428,
  -411564,
  17,
  0,
  16,
  36448,
  -411552,
  13,
  0,
  16,
  36468,
  -411556,
  13,
  0,
  16,
  36488,
  -411560,
  13,
  0,
  16,
  36508,
  -411564,
  64,
  0,
  32,
  36528,
  -411520,
  117,
  135151872,
  239272579,
  242156056,
  247677192,
  4,
  60,
  36564,
  -411428,
  185,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  -1609674235,
  176882178,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189006862,
  80,
  36628,
  -411284,
  296,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  -1072806395,
  182190594,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189006862,
  1091833459,
  1091571395,
  1091309254,
  1091047111,
  265925,
  32,
  36712,
  -411064,
  43,
  135151872,
  172819075,
  1241779907,
  247681547,
  4,
  68,
  36748,
  -411052,
  132,
  135151872,
  239141511,
  1090749964,
  75698190,
  26218051,
  235553026,
  247677200,
  247873804,
  247939336,
  1879787012,
  -1019146226,
  -968815602,
  -952039410,
  1038,
  208,
  36820,
  -410980,
  1252,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -804370939,
  244580866,
  239928020,
  239141592,
  239272668,
  239403744,
  239796944,
  239141588,
  239141592,
  239338204,
  239403744,
  241763024,
  239141588,
  239141592,
  239338204,
  239403744,
  240714448,
  239141588,
  239141592,
  239141596,
  239403744,
  -821951792,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  240124427,
  239141588,
  239141592,
  239141596,
  239403744,
  -1308491056,
  1191367694,
  1090705422,
  1090706446,
  1157816334,
  50515982,
  -737279676,
  -670154494,
  -603044862,
  -535936766,
  -804371198,
  2,
  44,
  37032,
  -409928,
  801,
  135151872,
  222429829,
  59196933,
  92472454,
  167851523,
  1103512003,
  214254023,
  189137924,
  68,
  37080,
  -409160,
  86,
  135151872,
  239272579,
  403591184,
  1092357698,
  239607822,
  336480272,
  1142427202,
  239148046,
  269371424,
  135137859,
  68076353,
  240061254,
  247678472,
  4,
  116,
  37152,
  -409136,
  249,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  1109921368,
  239152142,
  537806896,
  1093406285,
  239611918,
  604929056,
  1093144129,
  239152142,
  537806896,
  336464502,
  269402947,
  202294849,
  135186241,
  68076865,
  241634117,
  247678484,
  247873808,
  247939340,
  247808264,
  4,
  28,
  37272,
  -409000,
  127,
  269370112,
  1092357754,
  240263182,
  68054544,
  28,
  37304,
  -146616,
  41,
  269370112,
  1159204424,
  239475726,
  68047392,
  16,
  37336,
  -408936,
  19,
  0,
  36,
  37356,
  -408924,
  36,
  470696704,
  1142951496,
  239346702,
  739132456,
  1211108932,
  1038,
  36,
  37396,
  -408916,
  34,
  470696704,
  1109397064,
  239346702,
  739132456,
  1211108932,
  1038,
  112,
  37436,
  -408908,
  1284,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676997,
  167888899,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  235584770,
  247677204,
  247873808,
  247940620,
  247808264,
  34291972,
  1095503535,
  239620110,
  17630016,
  239158286,
  1276002632,
  1280314949,
  16398,
  36,
  37552,
  -407728,
  30,
  470696704,
  1109397060,
  239346702,
  739132456,
  1211108932,
  1038,
  88,
  37592,
  -407736,
  219,
  135151872,
  239141511,
  1174636044,
  75698190,
  -1022736382,
  -968815602,
  -952039410,
  189137934,
  247663200,
  247873804,
  247939336,
  1611351556,
  202294026,
  135185985,
  68077377,
  -1016067258,
  -968815602,
  -952039410,
  1038,
  84,
  37684,
  -407604,
  516,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806242309,
  167853059,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189006862,
  336464488,
  269402945,
  202294849,
  135186241,
  68076865,
  2884,
  56,
  37772,
  -407164,
  92,
  135151872,
  239141510,
  1124303628,
  239606798,
  604914720,
  1143475781,
  239610894,
  235565852,
  247677196,
  247873800,
  737540,
  60,
  37832,
  -407128,
  100,
  135151872,
  239141510,
  1124303628,
  239612942,
  1007567928,
  1145048645,
  239354894,
  806242376,
  202246775,
  135185217,
  68077121,
  2881,
  52,
  37896,
  -407080,
  95,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  -1018166779,
  -968683506,
  -952038386,
  -985593842,
  1038,
  60,
  37952,
  -407040,
  290,
  135151872,
  222429829,
  59196165,
  92472454,
  1103301229,
  1103577542,
  67374277,
  -721286326,
  -968768758,
  -985544895,
  1124336652,
  11,
  44,
  38016,
  -406800,
  557,
  135151872,
  222429829,
  59196165,
  92472454,
  -1022707710,
  -951990719,
  67945793,
  739076,
  112,
  38064,
  -406288,
  215,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  873349122,
  1094192705,
  239156238,
  806243136,
  1127485003,
  239351822,
  1074676028,
  1513098827,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1191448261,
  235563019,
  247677204,
  247873808,
  247939340,
  247808264,
  740356,
  44,
  38180,
  -406180,
  9214,
  135151872,
  222429829,
  59197701,
  92472454,
  168219395,
  1103512003,
  214254023,
  189137924,
  76,
  38228,
  -397012,
  9413,
  135151872,
  222429829,
  59197701,
  92472454,
  167841027,
  1103512003,
  214254023,
  189006852,
  -1022710526,
  -951990719,
  67945793,
  34293764,
  1103301194,
  1103577542,
  67374277,
  2891,
  140,
  38308,
  -387668,
  478,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -267500027,
  241107521,
  239878644,
  239157752,
  239419900,
  239616640,
  239944176,
  239157748,
  239419896,
  239419900,
  239616640,
  1124221424,
  1094841358,
  1094842382,
  1094843406,
  1178763278,
  1497493518,
  1111619598,
  1161952270,
  1212317710,
  1178726414,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1157893829,
  11,
  144,
  38452,
  -387332,
  280,
  135151872,
  239141511,
  1090749964,
  75698190,
  1091833454,
  239147022,
  537805084,
  1443892808,
  202294026,
  135185985,
  68077377,
  239274820,
  470696216,
  1092619843,
  239281166,
  739131944,
  1311772227,
  1241649166,
  202294026,
  135185985,
  68077377,
  240192326,
  403587348,
  1092357697,
  239804430,
  -1022737136,
  -968815602,
  -952039410,
  188875790,
  247663193,
  247873804,
  247939336,
  738564,
  44,
  38600,
  -387192,
  557,
  135151872,
  222429829,
  59196165,
  92472454,
  -1022707710,
  -951990719,
  67945793,
  739076,
  44,
  38648,
  -386680,
  70,
  135151872,
  239141510,
  1845723916,
  135185162,
  68077121,
  -1018426553,
  -968816626,
  1038,
  76,
  38696,
  -386648,
  8449,
  135151872,
  222429829,
  59197701,
  92472454,
  168322563,
  1103512003,
  214254023,
  189465604,
  -1022730750,
  -951990719,
  67945793,
  51070724,
  -1022754485,
  -951990719,
  67945793,
  739844,
  32,
  38776,
  -378264,
  32,
  269370112,
  1142165065,
  239278094,
  537805852,
  265800,
  16,
  38812,
  -378268,
  35,
  0,
  44,
  38832,
  -378240,
  202,
  135151872,
  239272579,
  175571472,
  -1019017202,
  188875790,
  1108872771,
  239410190,
  269371424,
  16,
  38880,
  -378080,
  5,
  0,
  972,
  38900,
  -378084,
  5707,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1072806395,
  20579074,
  1090700302,
  1107478542,
  1090702350,
  1208143886,
  33734670,
  46403253,
  46665284,
  46927426,
  47189569,
  46141000,
  336464466,
  269402947,
  202294849,
  135186241,
  68076865,
  755174212,
  46927361,
  47189593,
  47451714,
  47713875,
  47976001,
  48238145,
  46927436,
  47189587,
  47451714,
  47713860,
  47976001,
  48238145,
  46141011,
  234981123,
  239207108,
  239403720,
  239141580,
  239862480,
  -2130574656,
  1141033998,
  1208143886,
  2013446158,
  1090700302,
  1107478542,
  1090702350,
  1208143886,
  33734670,
  46403290,
  46665281,
  46927426,
  47189569,
  46141000,
  234955267,
  239141576,
  239141580,
  239600336,
  241828544,
  240714444,
  239207120,
  239862484,
  239141592,
  239141596,
  239862496,
  240190156,
  239207120,
  239600340,
  239141592,
  239141596,
  240059104,
  -1023278400,
  1090700302,
  1107478542,
  1090702350,
  1208143886,
  33734670,
  46403152,
  46665284,
  46927426,
  47189569,
  46141000,
  46665288,
  46927425,
  47189569,
  46141000,
  336464463,
  269402952,
  202294849,
  135186241,
  68076865,
  1661078342,
  1090701326,
  1090702350,
  1208143886,
  1711456270,
  1090701326,
  1090702350,
  1208143886,
  50511886,
  -938606266,
  -871480830,
  -804371454,
  -1072805886,
  -938584574,
  -871480830,
  -804370430,
  -1072805886,
  -938585598,
  -871480318,
  -804372222,
  -1072805886,
  20644610,
  1141033998,
  1208143886,
  33734670,
  46665283,
  46927425,
  47189569,
  46141000,
  -938603945,
  -871480830,
  51071746,
  -938606318,
  -871481086,
  -804372222,
  -1072805886,
  242680322,
  239141576,
  239141580,
  239600336,
  -150863168,
  1090701326,
  1090702350,
  1208143886,
  1426243598,
  46665226,
  46927426,
  172165963,
  1107478542,
  1258474510,
  -1005684981,
  -938589950,
  -871481086,
  -804372222,
  -1072805886,
  240714242,
  239338180,
  239207112,
  239141580,
  239600336,
  1124205248,
  1107478542,
  1090702350,
  1208143886,
  1745010702,
  1141032974,
  1090702350,
  1208143886,
  1577238542,
  1141031950,
  1107478542,
  1090702350,
  1208143886,
  1409466382,
  1174587406,
  1090702350,
  1208143886,
  1577238542,
  1141031950,
  1107478542,
  1090702350,
  1208143886,
  1157808142,
  1141033998,
  1208143886,
  1476575246,
  46665226,
  46927426,
  1946356549,
  46665217,
  46927426,
  47189569,
  46141000,
  46665302,
  46927426,
  47189569,
  46141000,
  46665314,
  46927428,
  47189569,
  46141000,
  46403150,
  46665284,
  46927426,
  47189569,
  46141000,
  46665288,
  46927430,
  47189569,
  46141000,
  46403194,
  46665284,
  46927425,
  47189569,
  46141000,
  46665288,
  46927425,
  47189569,
  46141000,
  46665294,
  46927425,
  47189569,
  46141000,
  46665322,
  46927426,
  47189569,
  46141000,
  -938603954,
  -871480830,
  1779123458,
  1141032974,
  1090702350,
  1208143886,
  1644347406,
  46665226,
  46927426,
  172165954,
  1107478542,
  1157811214,
  235556875,
  239141572,
  239207112,
  189072076,
  -1005712827,
  -938588926,
  -871480062,
  -804371198,
  738562,
  52,
  39876,
  -149140,
  85,
  135154432,
  239141510,
  1157858060,
  240390158,
  537805084,
  1511001672,
  239148046,
  202262560,
  135185217,
  68077121,
  96,
  39932,
  -373404,
  346,
  135151872,
  239141511,
  1090749964,
  75698190,
  470710530,
  1210060356,
  240455694,
  403590420,
  1142689368,
  240132110,
  -1022728688,
  -968684530,
  -952039410,
  189269006,
  247663186,
  247874316,
  247939336,
  1124811012,
  239212558,
  537806108,
  1052232,
  80,
  40032,
  -373152,
  236,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  672023301,
  235588354,
  247677204,
  247873808,
  247939340,
  247808264,
  1259028740,
  -1018817522,
  -968814578,
  -952038386,
  -985593842,
  1038,
  80,
  40116,
  -372996,
  220,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  604914437,
  235584258,
  247677204,
  247873808,
  247939340,
  247808264,
  1259028740,
  -1018817522,
  -968814578,
  -952038386,
  -985593842,
  1038,
  36,
  40200,
  -372856,
  179,
  269370112,
  235566594,
  1124812548,
  239212558,
  537806108,
  1052232,
  32,
  40240,
  -372704,
  28,
  269370112,
  1091833415,
  239343630,
  537805852,
  265800,
  72,
  40276,
  -372708,
  158,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  172360197,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  -1018559989,
  -968814578,
  -952038386,
  -985593842,
  1038,
  44,
  40352,
  -372624,
  242,
  135151872,
  222429829,
  59196165,
  92472454,
  1103301204,
  1103577542,
  67374277,
  2883,
  44,
  40400,
  -372416,
  295,
  135151872,
  222429829,
  59196165,
  92472454,
  -1022706942,
  -951990719,
  67945793,
  738308,
  112,
  40448,
  -372160,
  215,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  873350658,
  1094192705,
  239156238,
  806242624,
  1144262228,
  239351822,
  1074676028,
  1479544395,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  235561739,
  247677204,
  247873808,
  247939340,
  247808264,
  739588,
  44,
  40564,
  -372052,
  9704,
  135151872,
  222429829,
  59197701,
  92472454,
  168219395,
  1103512003,
  214254023,
  189137924,
  76,
  40612,
  -362388,
  9583,
  135151872,
  222429829,
  59197701,
  92472454,
  167848195,
  1103512003,
  214254023,
  189268996,
  -1022705150,
  -951990719,
  67945793,
  1695238916,
  -968768758,
  -985544895,
  1208222732,
  11,
  196,
  40692,
  -352884,
  513,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  -1475458555,
  239207043,
  1090683820,
  42184718,
  -2086662584,
  241762818,
  1325564836,
  42182670,
  -2085876159,
  -1341243134,
  239600259,
  1292010400,
  42181646,
  -2086138303,
  -1408350974,
  239403651,
  1208124336,
  42180622,
  -1542567934,
  239141507,
  1090683816,
  42183694,
  -2085614015,
  -1609677310,
  240714371,
  1107461032,
  42183694,
  -2085614011,
  -1609676798,
  172360323,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189137934,
  235572738,
  247678484,
  247874320,
  247939340,
  247808264,
  739076,
  16,
  40892,
  -352556,
  45,
  0,
  52,
  40912,
  -352528,
  95,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  -1018166779,
  -968683506,
  -952038386,
  -985593842,
  1038,
  124,
  40968,
  -352488,
  1480,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  235061507,
  739132712,
  1211108929,
  172498958,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189137934,
  235566594,
  247677204,
  247874320,
  247939340,
  247808264,
  34292740,
  1093144313,
  239414286,
  537806896,
  604927746,
  1109921348,
  239152142,
  537806128,
  72,
  41096,
  -351128,
  158,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  172360197,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  -1018559989,
  -968814578,
  -952038386,
  -985593842,
  1038,
  128,
  41172,
  -351044,
  1497,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  234995971,
  672023588,
  1093406274,
  239415310,
  23331616,
  239413262,
  806240556,
  1210060360,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1174671045,
  235565579,
  247677204,
  247874320,
  247939340,
  247808264,
  51070980,
  672006430,
  1160515137,
  239611918,
  32,
  128,
  41304,
  -349672,
  299,
  135151872,
  239141511,
  1090749964,
  75698190,
  1852837443,
  239433742,
  -2146549380,
  1879983617,
  1098649183,
  1208057870,
  239628302,
  2014200180,
  1098649153,
  1208057870,
  172519438,
  -1019146226,
  -968815602,
  -952039410,
  189400078,
  1182535235,
  1208057870,
  172453902,
  -1018818546,
  -968815602,
  -952039410,
  189269006,
  2081315074,
  25169478,
  7343688,
  56,
  36936,
  -349500,
  305,
  244862980,
  135151880,
  222429829,
  59196933,
  92472454,
  271485698,
  -1022737406,
  -951990719,
  67945793,
  1342915844,
  46,
  88,
  41496,
  -349240,
  121,
  135151872,
  239141510,
  1124303628,
  241242126,
  537806876,
  1209011784,
  239145998,
  470696216,
  1210060353,
  172494862,
  -1019147250,
  -968816626,
  189072398,
  202246723,
  135185222,
  68077121,
  239274822,
  537805084,
  1052235,
  68,
  37088,
  -349204,
  393,
  244866820,
  135151880,
  222429829,
  59196933,
  92472454,
  -1022709758,
  -951990719,
  67945793,
  1896563716,
  175837230,
  1103513027,
  214254023,
  189072388,
  11856,
  68,
  37160,
  -348876,
  746,
  244870660,
  135151880,
  222429829,
  59196933,
  92472454,
  -1022713598,
  -951990719,
  67945793,
  1393246980,
  -968768758,
  -985544895,
  1241777164,
  784859659,
  16,
  148,
  41732,
  -348196,
  367,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  873349378,
  1144524353,
  239156238,
  806243392,
  1127485003,
  239155214,
  1074676028,
  1395658317,
  239156238,
  806242368,
  336464486,
  269402945,
  202294849,
  135186241,
  68076865,
  241830723,
  940458292,
  1094454849,
  239878158,
  235555376,
  247677204,
  247873808,
  247939340,
  247808264,
  34291972,
  1144524363,
  239156238,
  806242368,
  40,
  41884,
  -347980,
  34,
  403587840,
  1142689346,
  239345678,
  672023588,
  1143737924,
  239611918,
  4,
  92,
  41928,
  -347976,
  231,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  1074676485,
  1141788418,
  1095241282,
  239160334,
  1074677328,
  1141792258,
  1095241281,
  239160334,
  1074677328,
  336464453,
  269402947,
  202294849,
  135186241,
  68076865,
  2881,
  92,
  42024,
  -347832,
  231,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  1879982853,
  1947094786,
  1098387010,
  239172622,
  239468928,
  241042032,
  2014200180,
  1098649153,
  1174503438,
  172322830,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  164,
  42120,
  -347688,
  526,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074676997,
  235574018,
  247677204,
  247873808,
  247939340,
  247808264,
  1191921156,
  239619086,
  1074678352,
  1145310813,
  239618062,
  1343111500,
  1312820808,
  239291406,
  1074683984,
  1141770831,
  1212681799,
  239553550,
  1779125584,
  1279528458,
  239618062,
  1343113036,
  1296305739,
  239159310,
  1343113036,
  239668050,
  1208894276,
  1095503432,
  239620110,
  1208894532,
  1095503428,
  239620110,
  64,
  16,
  42288,
  -347328,
  48,
  0,
  16,
  42308,
  -347300,
  40,
  0,
  24,
  42328,
  -347272,
  42,
  135151872,
  -1016593789,
  1038,
  40,
  42356,
  -347252,
  84,
  135151872,
  239272579,
  235567632,
  247677192,
  1124811012,
  239148046,
  269372960,
  120,
  42400,
  -347200,
  387,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235555586,
  247678484,
  247873808,
  247939340,
  247808264,
  2081113348,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1208225477,
  1007569419,
  1212157524,
  240070670,
  940458804,
  1094454856,
  239681550,
  1074676540,
  1882197590,
  239418382,
  806242368,
  52,
  42524,
  -346924,
  127,
  135151872,
  239272579,
  470709008,
  1327500867,
  172429326,
  -1019148274,
  189727758,
  1092357699,
  239804430,
  16,
  52,
  42580,
  -346852,
  87,
  135151872,
  239141510,
  1292075788,
  240717838,
  537805084,
  1494224454,
  1124863498,
  1091047107,
  1141116614,
  11,
  68,
  42636,
  -346812,
  101,
  135151872,
  239141511,
  1090749964,
  75698190,
  247663220,
  247874572,
  247939336,
  1124811780,
  239212558,
  537805084,
  1343229512,
  1141640899,
  1091047110,
  265927,
  108,
  42708,
  -346772,
  234,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  940462594,
  1195118146,
  239616014,
  239469104,
  940458292,
  1094454849,
  239616014,
  235559984,
  247677204,
  247873808,
  247939852,
  247808264,
  1124811524,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  1038,
  64,
  42820,
  -346644,
  90,
  135151872,
  239272579,
  235557136,
  247677192,
  1208699396,
  239541262,
  269370912,
  1091833429,
  239147022,
  537805084,
  1125125704,
  -1019148274,
  1038,
  48,
  42888,
  -346616,
  65,
  470696704,
  1210060357,
  239865870,
  403587348,
  1142689345,
  239607822,
  235554832,
  1208698372,
  1038,
  52,
  42940,
  -346588,
  111,
  135151872,
  239141510,
  1124303628,
  175509518,
  -1019147250,
  -968816626,
  188941326,
  1209536083,
  239148046,
  269370912,
  40,
  42996,
  -346532,
  104,
  135151872,
  239272579,
  470708240,
  1612713537,
  -1019148274,
  239731726,
  164624,
  112,
  43040,
  -346464,
  292,
  135151872,
  239141510,
  1124303628,
  1812074510,
  1175195146,
  1091047107,
  1208225478,
  403587851,
  1092357698,
  239607822,
  403591952,
  1092357698,
  239607822,
  470699792,
  1210060353,
  240521230,
  537805084,
  1712328264,
  1091309066,
  1091047107,
  1157893830,
  235555339,
  247677196,
  247873800,
  737540,
  112,
  43156,
  -346276,
  292,
  135151872,
  239141510,
  1124303628,
  1275203598,
  1175195146,
  1091047107,
  1208225478,
  403587851,
  1092357698,
  239607822,
  403590928,
  1092357698,
  239607822,
  470698768,
  1210060353,
  175968270,
  -1019147250,
  -968816626,
  189072398,
  1092357706,
  239607822,
  235562512,
  247677196,
  247873800,
  737796,
  84,
  43272,
  -346088,
  212,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  1007567362,
  1212157508,
  172765198,
  -1019145202,
  -968814578,
  -951907314,
  -985593842,
  189334542,
  1093930616,
  239155214,
  1074676028,
  3149397,
  56,
  43360,
  -345952,
  103,
  135151872,
  239141511,
  1090749964,
  75698190,
  1092095606,
  239148046,
  269370912,
  247663177,
  247873804,
  247939336,
  738308,
  52,
  43420,
  -345900,
  103,
  135151872,
  239141510,
  1124303628,
  174133262,
  -1019147250,
  -968816626,
  189269006,
  1108872799,
  239148046,
  269370912,
  32,
  43476,
  -345844,
  66,
  135151872,
  175243907,
  1157893827,
  247679243,
  4,
  64,
  43512,
  -345800,
  112,
  135151872,
  239141510,
  1124303628,
  175116302,
  -1019147250,
  -968816626,
  189334542,
  202246740,
  135185217,
  68077121,
  239274826,
  537805084,
  1052234,
  16,
  43580,
  -345756,
  58,
  0,
  44,
  43600,
  -345712,
  168,
  135151872,
  239141510,
  33784588,
  247663177,
  247873800,
  34292740,
  135185238,
  68077121,
  16,
  43648,
  -345584,
  42,
  0,
  16,
  43668,
  -345556,
  38,
  0,
  16,
  43688,
  -345528,
  3,
  0,
  16,
  43708,
  -345532,
  11,
  0,
  116,
  43728,
  -345536,
  181,
  135151872,
  239141511,
  1090749964,
  75698190,
  2048921155,
  239152142,
  873350960,
  1161301570,
  239221774,
  1141785664,
  1145572933,
  239160334,
  537809744,
  269355609,
  202294086,
  135185985,
  68077377,
  172165957,
  -1018818546,
  -968815602,
  -952039410,
  189072398,
  1125125703,
  1091309251,
  1091047110,
  265927,
  116,
  43848,
  -345464,
  157,
  135151872,
  239141511,
  1090749964,
  75698190,
  1914703427,
  239152142,
  873350960,
  1161301570,
  239418382,
  1141785152,
  1095241282,
  239160334,
  537807952,
  269355606,
  202294086,
  135185985,
  68077377,
  172165956,
  -1018818546,
  -968815602,
  -952039410,
  189072398,
  1125125703,
  1091309251,
  1091047110,
  265927,
  116,
  43968,
  -345424,
  181,
  135151872,
  239141511,
  1090749964,
  75698190,
  2048921155,
  239152142,
  873350960,
  1161301570,
  239221774,
  1141785664,
  1145572933,
  239160334,
  537809744,
  269355609,
  202294086,
  135185985,
  68077377,
  172165957,
  -1018818546,
  -968815602,
  -952039410,
  189072398,
  1125125703,
  1091309251,
  1091047110,
  265927,
  40,
  44088,
  -345352,
  121,
  135151872,
  222429829,
  59196933,
  92472454,
  1103326210,
  1103577542,
  67374277,
  88,
  44132,
  -345268,
  367,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  167846659,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189269006,
  1141770832,
  1162350146,
  239422478,
  1158366544,
  239223822,
  1276003656,
  5246533,
  104,
  44224,
  -344992,
  168,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  1094192730,
  239156238,
  806242368,
  336464467,
  269402945,
  202294849,
  135186241,
  68076865,
  240061254,
  1074676028,
  1311772241,
  239156238,
  806242880,
  1161039433,
  239155214,
  1074676028,
  3149388,
  64,
  44332,
  -344924,
  63,
  135151872,
  239141510,
  1124303628,
  239605774,
  537805084,
  1192234581,
  239408142,
  470696216,
  1210060353,
  239276046,
  247677196,
  247873800,
  4,
  196,
  44400,
  -344928,
  327,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  1111756394,
  239159310,
  1343112524,
  1128271432,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1208225477,
  1141785355,
  1162350148,
  239422478,
  1074680400,
  1111756361,
  239421454,
  1343111500,
  1245974088,
  239159310,
  1343112268,
  1732251208,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1107562181,
  1141785355,
  1162350146,
  239422478,
  1074680400,
  1111756361,
  239421454,
  1343111500,
  1245974088,
  239159310,
  1343112268,
  1447038536,
  239158286,
  1276002632,
  1213206081,
  16398,
  16,
  44600,
  -344792,
  25,
  0,
  16,
  44620,
  -344780,
  43,
  0,
  36,
  44640,
  -344752,
  441,
  135151872,
  239141511,
  59131404,
  234991363,
  239191560,
  50948,
  60,
  44680,
  -344344,
  349,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  604916229,
  235584258,
  247677204,
  247873808,
  247939340,
  247808264,
  738820,
  108,
  44744,
  -344056,
  860,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -535934971,
  242024968,
  239732964,
  239143144,
  239143148,
  239601904,
  1812138208,
  336464385,
  269402945,
  202294849,
  135186241,
  68076865,
  50531139,
  336464385,
  269402945,
  202294849,
  135186243,
  68076865,
  2881,
  148,
  44856,
  -343304,
  771,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  1097076334,
  239364110,
  1879982444,
  39849544,
  1231294017,
  239167502,
  1879982444,
  56626760,
  235536646,
  247677204,
  247873808,
  247939340,
  247808264,
  1124811012,
  239430670,
  1611548784,
  336464451,
  269402945,
  202294849,
  135186241,
  68076865,
  -285078719,
  1091833354,
  1091571395,
  1124863686,
  1091047111,
  1090784965,
  11,
  104,
  45008,
  -342672,
  208,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  739132165,
  1261440585,
  239869966,
  806240556,
  35655244,
  1093406283,
  239874062,
  235557152,
  247677716,
  247873808,
  247939340,
  247808264,
  1628128516,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  1038,
  80,
  45116,
  -342572,
  173,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  739132165,
  1261440589,
  239738894,
  739133736,
  1211108930,
  1593974798,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1191448261,
  11,
  688,
  45200,
  -342480,
  1583,
  135151872,
  1275200135,
  59116558,
  -2096099775,
  202261508,
  -1022882106,
  -2046030249,
  269369603,
  239666307,
  135185932,
  202276803,
  239141766,
  1141146384,
  247860238,
  240304904,
  1090749964,
  75698190,
  202276610,
  135152067,
  202261958,
  269353859,
  239207558,
  239190796,
  239322632,
  239191812,
  235046664,
  235111180,
  33850896,
  -1022620074,
  -972550591,
  -2096361915,
  -2045768189,
  202274052,
  135152067,
  202261958,
  269353859,
  242287750,
  239190796,
  239453704,
  235111180,
  1929676304,
  1103301646,
  1170606094,
  58919950,
  75894798,
  -1022620083,
  -972550591,
  -2096361915,
  -2045768189,
  202263044,
  135152067,
  202261958,
  269353859,
  239731846,
  239190796,
  239453704,
  235111180,
  1241810448,
  1103301646,
  1170606094,
  58919950,
  75894798,
  -1022620086,
  -972550591,
  -2096361918,
  -2045768189,
  202263812,
  135152067,
  202261190,
  269353859,
  240059526,
  239190796,
  239257096,
  235111180,
  1292142096,
  1103301646,
  1120274446,
  58919950,
  75894798,
  -1022620083,
  -972550591,
  -2096361918,
  -2045768189,
  202263812,
  135152067,
  202261190,
  269353859,
  239928454,
  239190796,
  239257096,
  235111180,
  1292142096,
  1103301646,
  1791363086,
  1103561742,
  42403854,
  -956035484,
  -2029515199,
  68053250,
  135152071,
  241697415,
  239191812,
  1141016328,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1308788488,
  1103561742,
  42403854,
  68043266,
  135152071,
  242352775,
  239191812,
  1979877128,
  1103561742,
  42403854,
  -956035464,
  -2029515199,
  68047362,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  2,
  172,
  45892,
  -341588,
  486,
  135154432,
  1107427975,
  59116558,
  -2096099775,
  202262276,
  -1022882106,
  -956035482,
  -2029515199,
  202262786,
  239141766,
  1292141328,
  247860238,
  243254024,
  1090749964,
  75698190,
  -972288444,
  1724057614,
  1103561742,
  42403854,
  -2046030265,
  269369603,
  -2080242557,
  1103301646,
  1153828878,
  1103561742,
  42403854,
  58919950,
  75894798,
  -1022620046,
  -972550591,
  -956035511,
  -2029515199,
  68044290,
  135152071,
  202244743,
  269353859,
  239928454,
  239190796,
  239191560,
  50948,
  344,
  46068,
  -341268,
  1771,
  135152896,
  -469564793,
  -956035582,
  42403854,
  -956035482,
  42403854,
  -956035481,
  42403854,
  -956035479,
  42403854,
  68052994,
  -2029515065,
  68058626,
  -2029515065,
  68055810,
  -2029515065,
  68056834,
  -2029515065,
  68053250,
  -2029515065,
  68048130,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68045826,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68045826,
  -2029515065,
  241041922,
  135186180,
  1493303943,
  247923726,
  33720072,
  -956035504,
  42403854,
  -956035468,
  42403854,
  -956035500,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  48,
  46416,
  -339840,
  153,
  135151872,
  239141510,
  33784588,
  247663226,
  247873800,
  1208697604,
  135185162,
  68077121,
  2881,
  56,
  46468,
  -339732,
  80,
  135151872,
  239141511,
  1090749964,
  75698190,
  -1022737918,
  -968815602,
  -952039410,
  188810254,
  202294085,
  135185985,
  68077377,
  16,
  46528,
  -339712,
  25,
  0,
  16,
  46548,
  -339700,
  10,
  0,
  16,
  46568,
  -339704,
  10,
  0,
  32,
  46588,
  -339708,
  96,
  135151872,
  239141510,
  33784588,
  135185244,
  68077121,
  124,
  46624,
  -339648,
  353,
  135151872,
  239141511,
  1090749964,
  75698190,
  37752387,
  1145835095,
  239489038,
  1208893772,
  1112280641,
  239423502,
  235553600,
  247677200,
  247873804,
  247939336,
  1124813316,
  1175457290,
  1091309251,
  1091047110,
  1157893831,
  241435147,
  1343111500,
  1112804935,
  239425550,
  1611547228,
  1097076296,
  239429646,
  1879982700,
  4197962,
  152,
  46752,
  -339408,
  393,
  135151872,
  239141511,
  1174636044,
  75698190,
  38800963,
  1096552052,
  239558670,
  1745764964,
  1114377797,
  239235086,
  2014200436,
  1132203589,
  1157726222,
  175394830,
  -1018818546,
  -968815602,
  -952039410,
  188941326,
  1163660871,
  239558670,
  1745764964,
  1114377797,
  239628302,
  2014201204,
  1132203589,
  1157726222,
  173297678,
  239227918,
  1544439128,
  1247809093,
  235554571,
  247677200,
  247874316,
  247939336,
  738308,
  36,
  46908,
  -339164,
  48,
  470696704,
  1092619863,
  239346702,
  739132456,
  1211108932,
  1038,
  240,
  46948,
  -339156,
  637,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  -535935483,
  242156034,
  239534824,
  239141612,
  241697520,
  239207156,
  239403768,
  239207164,
  239403904,
  239534980,
  239403912,
  239141772,
  239666064,
  174523104,
  1157817358,
  1157818382,
  1157819406,
  1208152078,
  235560715,
  247677716,
  247873808,
  247939340,
  247808264,
  2097892100,
  1124264974,
  1275260942,
  2063785998,
  49024522,
  49286721,
  49548871,
  49811010,
  50073157,
  58723906,
  58986052,
  59248197,
  59510341,
  59772481,
  48238153,
  48500325,
  48762434,
  49024581,
  49286725,
  174459727,
  1107485710,
  1157818382,
  1157819406,
  1157820430,
  -468826869,
  -401718782,
  -334609150,
  -267500286,
  2,
  44,
  47192,
  -338760,
  130,
  135151872,
  1845625475,
  68076298,
  172165953,
  1090784963,
  -1022736885,
  188810254,
  68076358,
  16,
  47240,
  -338664,
  31,
  0,
  240,
  47260,
  -338652,
  779,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -535935483,
  247464450,
  239141608,
  239141612,
  240321264,
  239207156,
  239338232,
  239207164,
  239141760,
  239338372,
  239338376,
  239338380,
  239403920,
  -1325268256,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1208225477,
  -334609141,
  -267500286,
  -535934974,
  240452098,
  239141612,
  239534832,
  239207156,
  239338232,
  239207164,
  239338368,
  239141764,
  239338376,
  239338380,
  239666064,
  1778516704,
  48500234,
  48762434,
  49024581,
  49286725,
  172297029,
  1157817358,
  1157818382,
  1157819406,
  1157820430,
  235554059,
  239403748,
  239403752,
  239403756,
  189072112,
  48500293,
  48762437,
  49024581,
  49286725,
  16,
  47504,
  -338112,
  502,
  0,
  60,
  47524,
  -337620,
  110,
  135151872,
  1275200131,
  68076298,
  172165955,
  1157893827,
  -1022737653,
  188810254,
  247663171,
  1175142660,
  68076298,
  -1018819775,
  1038,
  24,
  47588,
  -337572,
  18,
  135151872,
  -1018166653,
  1038,
  24,
  47616,
  -337568,
  44,
  135152640,
  -1016790397,
  1038,
  84,
  47644,
  -337548,
  709,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241541,
  167889923,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189072398,
  336464475,
  269402945,
  202294849,
  135186241,
  68076865,
  2881,
  44,
  47732,
  -336916,
  108,
  135151872,
  239141510,
  1157858060,
  242031630,
  269376800,
  1091309144,
  1091047107,
  265926,
  144,
  47780,
  -336852,
  215,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241029,
  1144262245,
  239155214,
  1074676796,
  1345326664,
  239156238,
  806242368,
  1244925516,
  239351822,
  1074676028,
  1160777293,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  1007568395,
  1212157505,
  239874062,
  940460596,
  1094454852,
  239616014,
  235556400,
  247677716,
  247873808,
  247939340,
  247808264,
  737540,
  48,
  47928,
  -157096,
  74,
  135151872,
  239272579,
  470700304,
  1310723649,
  239669262,
  537806364,
  1292897864,
  -1019148274,
  1038,
  80,
  47980,
  -336828,
  185,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  537805573,
  235576322,
  247677204,
  247875088,
  247939340,
  247808264,
  1124811012,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  1038,
  88,
  48064,
  -336720,
  262,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241541,
  1161039485,
  239155214,
  1074677052,
  1162088001,
  239421454,
  1343111500,
  1915752008,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  11,
  148,
  48156,
  -336540,
  660,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241541,
  1110707828,
  239417358,
  1074676028,
  1647316556,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1191448261,
  177406475,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189334542,
  873361666,
  1094192712,
  239418382,
  1141784896,
  1162350149,
  239160334,
  806243408,
  1429737084,
  239549454,
  1141787968,
  1162350145,
  239160334,
  806242384,
  32,
  48308,
  -336020,
  27,
  135151872,
  239272579,
  537806108,
  1158155848,
  265923,
  56,
  48344,
  -336024,
  278,
  135151872,
  240321159,
  235567632,
  247939336,
  34291972,
  1175719515,
  239474702,
  537806364,
  1192234573,
  239475726,
  269373984,
  176,
  48404,
  -335796,
  621,
  135155968,
  239141511,
  1124304396,
  75698190,
  1159466573,
  239607822,
  239600144,
  470696216,
  1210060353,
  239800334,
  537810204,
  1192496720,
  239212558,
  537805084,
  34606670,
  247663178,
  247873804,
  247939336,
  1124813572,
  240458766,
  336480288,
  1108872775,
  239148046,
  269372704,
  1092357728,
  239607822,
  -1022738160,
  -968815602,
  -952039410,
  189072398,
  1427902029,
  240394254,
  403588884,
  1159466562,
  240001038,
  470700304,
  1210060377,
  239539214,
  470696472,
  1310723653,
  4110,
  20,
  48584,
  -335352,
  90,
  269370112,
  68048386,
  44,
  48608,
  -335280,
  129,
  135151872,
  239141511,
  1124304396,
  75698190,
  -1022728958,
  -968815602,
  -952039410,
  189006862,
  20,
  48656,
  -335184,
  120,
  269370112,
  68056066,
  136,
  48680,
  -335080,
  347,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  873357826,
  1110969923,
  239156238,
  806242368,
  873350402,
  1161301569,
  239156238,
  806242368,
  336464461,
  269402947,
  202294849,
  135186241,
  68076865,
  239274818,
  1074676540,
  1162088005,
  239159310,
  1343111756,
  1747979848,
  1158942218,
  1091571395,
  1091309254,
  1091047111,
  1157893829,
  11,
  700,
  48820,
  -334868,
  2677,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -535935483,
  -334597375,
  -267501311,
  -334608895,
  -267500031,
  -535932415,
  235554305,
  247677204,
  247873808,
  247939340,
  247808264,
  1493912068,
  1157752846,
  1090645006,
  1208086542,
  1275191310,
  1157753870,
  1208086542,
  1409409038,
  1090642958,
  1157752846,
  1157753870,
  1208086542,
  1442963470,
  1157751822,
  1090643982,
  1107422222,
  1208086542,
  1845616654,
  1157752846,
  1090645006,
  1208086542,
  1291968526,
  1090645006,
  1208086542,
  1157751822,
  1090643982,
  1107422222,
  1208086542,
  1258414094,
  1174531086,
  33681422,
  32771651,
  33033794,
  33295938,
  41946704,
  31460936,
  31723084,
  31985218,
  32247365,
  32509505,
  31460936,
  -334568190,
  -267499519,
  -535934975,
  240714241,
  239337956,
  239206888,
  239141356,
  239600112,
  1124205024,
  1090645006,
  1275195406,
  1526849550,
  1107420174,
  1157752846,
  1090645006,
  1208086542,
  1191305230,
  1107420174,
  1157752846,
  1090645006,
  1208086542,
  1258414094,
  1157752846,
  1090645006,
  1208086542,
  33677326,
  32247416,
  32509518,
  31460936,
  31723114,
  31985218,
  32247362,
  32509508,
  31460936,
  -468813822,
  -401718015,
  -334609919,
  -267500031,
  -535934975,
  -468820991,
  -401718783,
  -334609919,
  -267500543,
  -535934975,
  -468819967,
  -401718783,
  -334609919,
  -267500543,
  -535934975,
  240189953,
  239141356,
  239600112,
  239600096,
  239141356,
  239600112,
  240779744,
  239141356,
  239600112,
  -2130574880,
  1090645006,
  1241640974,
  1409409038,
  1325526030,
  1208086542,
  1157750798,
  1090645006,
  1208086542,
  1426186254,
  1107420174,
  1107421198,
  1090645006,
  1208086542,
  1241636878,
  1107420174,
  1157752846,
  1090645006,
  1208086542,
  1392631822,
  1661068302,
  1359079438,
  1090645006,
  1208086542,
  1258414094,
  1090645006,
  1208086542,
  33677326,
  32247360,
  32509505,
  31460936,
  32247399,
  32509505,
  31460936,
  -468823550,
  -401719039,
  -334609919,
  -267501311,
  -535934975,
  -334608639,
  -267500031,
  -535931647,
  -334608383,
  -267501311,
  -535934975,
  -334607359,
  -267499775,
  -535932671,
  239862273,
  239469036,
  239600112,
  1543635424,
  31723018,
  31985221,
  32247365,
  32509509,
  2885,
  132,
  49524,
  -332884,
  509,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1544438533,
  1180700228,
  239950862,
  1410223456,
  1096289869,
  239426574,
  1343114848,
  1146359384,
  239360014,
  1611547740,
  1096027720,
  239360014,
  1611546972,
  55578214,
  235536706,
  247677204,
  247873808,
  247939340,
  247808264,
  1292583172,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  1038,
  208,
  49660,
  -332508,
  1521,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  739153154,
  1211108964,
  1191321614,
  239545358,
  537809200,
  672033794,
  1261178443,
  239611918,
  173867552,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189137934,
  739164162,
  1211108935,
  242425870,
  806242092,
  35655246,
  1177292493,
  239611918,
  240124448,
  806240556,
  1143213640,
  239216654,
  806241580,
  35655240,
  1093406283,
  242364430,
  243335712,
  806242092,
  1545604691,
  1159990794,
  239413262,
  806241580,
  172297029,
  239412238,
  739132712,
  1160777285,
  604914955,
  1160252997,
  239414286,
  48,
  92,
  49872,
  -331184,
  234,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  537806085,
  739131906,
  1211108929,
  175185934,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188941326,
  1109659203,
  239216654,
  806240556,
  1394609736,
  239741966,
  537806896,
  80,
  49968,
  -331040,
  115,
  135152896,
  239141510,
  1157858060,
  239432718,
  2081309048,
  25169474,
  1500515912,
  239434766,
  239731072,
  1879982972,
  202246723,
  135185217,
  68077121,
  240782149,
  247677708,
  247873800,
  4,
  36,
  50052,
  -330996,
  71,
  135153152,
  240190083,
  135155728,
  68076353,
  -2096099752,
  2,
  44,
  50092,
  -330956,
  79,
  135151872,
  239272579,
  235561744,
  247677192,
  1326139396,
  1124601354,
  1174671043,
  11,
  52,
  50140,
  -330924,
  91,
  135151872,
  239272579,
  470698768,
  1394609731,
  172625934,
  -1019148274,
  189269006,
  135137859,
  68076353,
  2892,
  60,
  50196,
  -330884,
  180,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  537806853,
  235574530,
  247677716,
  247873808,
  247939340,
  247808264,
  737540,
  40,
  50260,
  -330756,
  109,
  135151872,
  239731331,
  403595028,
  1109134914,
  243081230,
  247677192,
  4,
  80,
  50304,
  -330688,
  139,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806243845,
  1178340984,
  239616014,
  940459060,
  1094454852,
  239616014,
  235557424,
  247677204,
  247873808,
  247939340,
  247808264,
  737540,
  60,
  50388,
  -330628,
  180,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  537806853,
  235574530,
  247677716,
  247873808,
  247939340,
  247808264,
  737540,
  96,
  50452,
  -330500,
  144,
  135151872,
  239141510,
  1124303628,
  239694862,
  2081309048,
  25169474,
  1466961480,
  239237134,
  -2146549380,
  1879984129,
  1165758034,
  1191280654,
  239303694,
  235553648,
  247677196,
  247873800,
  1326139140,
  1124863498,
  1091047107,
  1157893830,
  11,
  16,
  50552,
  -330456,
  31,
  0,
  16,
  50572,
  -330444,
  12,
  0,
  16,
  50592,
  -330448,
  12,
  0,
  16,
  50612,
  -330452,
  12,
  0,
  16,
  50632,
  -330456,
  12,
  0,
  32,
  50652,
  -330460,
  38,
  135151872,
  173736579,
  1141116611,
  247677195,
  4,
  56,
  50688,
  -330448,
  77,
  135151872,
  239141510,
  1778615052,
  135185162,
  68077121,
  172034891,
  1091047107,
  1308888774,
  247677707,
  247873800,
  4,
  24,
  50748,
  -330428,
  37,
  135151872,
  240648835,
  49924,
  16,
  50776,
  -330408,
  35,
  0,
  28,
  50796,
  -330380,
  88,
  50950656,
  1103319298,
  239601678,
  4,
  28,
  50828,
  -330316,
  29,
  1477329664,
  1146883653,
  239951886,
  4,
  56,
  50860,
  -330316,
  161,
  135151872,
  239141510,
  1292075788,
  241844238,
  1208904772,
  1095503429,
  239620110,
  235559744,
  247677708,
  247873800,
  738820,
  32,
  50920,
  -330200,
  43,
  135151872,
  173736579,
  1141116611,
  247677195,
  4,
  40,
  50956,
  -330188,
  99,
  135154432,
  240648835,
  240304900,
  202260744,
  240649091,
  239715080,
  4,
  104,
  51000,
  -330120,
  114,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  1160253028,
  239152142,
  537806896,
  1093144140,
  239152142,
  537806896,
  336464462,
  269402945,
  202294849,
  135186241,
  68076865,
  239274823,
  247677716,
  247873808,
  247939340,
  247808264,
  4,
  32,
  51108,
  -330100,
  69,
  135151872,
  239141510,
  33784588,
  135185217,
  68077121,
  132,
  51144,
  -330056,
  393,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  940458757,
  1161563725,
  239747086,
  239403568,
  940458548,
  1161563717,
  239616014,
  873351984,
  1161301570,
  239352846,
  806243904,
  1110707804,
  239417358,
  1074676028,
  36703820,
  1094454899,
  239484942,
  1074676796,
  1278217800,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1241779909,
  11,
  44,
  51280,
  -329792,
  227,
  135151872,
  239141511,
  1124304396,
  75698190,
  -1022716414,
  -968815602,
  -952039410,
  188941326,
  64,
  51328,
  -329600,
  376,
  135153920,
  222429829,
  59196933,
  92472454,
  -1022701566,
  -951990719,
  67945793,
  1745568772,
  -1023146996,
  1221052101,
  -2096626420,
  -2046655227,
  231172,
  148,
  51396,
  -329284,
  214,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537806085,
  1109921371,
  239152142,
  537806896,
  336464455,
  269402945,
  202294849,
  135186241,
  68076865,
  239274822,
  806240556,
  1277169238,
  239150094,
  739131688,
  1211108929,
  173416462,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  739117635,
  1244663369,
  1124805646,
  239152142,
  537809712,
  1159990857,
  239413262,
  806241580,
  80,
  51548,
  -329212,
  119,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  537806085,
  1093406288,
  239611918,
  739136032,
  1211108929,
  239280142,
  806240556,
  1143737926,
  239611918,
  739136288,
  1194331720,
  11278,
  60,
  51632,
  -329168,
  1218,
  135151872,
  222429829,
  59196165,
  92472454,
  167900931,
  1103512003,
  214254023,
  189268996,
  -1022695934,
  -951990719,
  67945793,
  739076,
  60,
  51696,
  -328000,
  1406,
  135151872,
  222429829,
  59197701,
  92472454,
  167893251,
  1103512003,
  214254023,
  189268996,
  -1022735358,
  -951990719,
  67945793,
  737540,
  44,
  51760,
  -326656,
  3862,
  135151872,
  222429829,
  59196165,
  92472454,
  -1022690558,
  -951990719,
  67945793,
  738308,
  84,
  51808,
  -322832,
  173,
  135154176,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  537806597,
  604915970,
  1126698564,
  239152142,
  537806896,
  1091833433,
  1091571395,
  1091309254,
  1091047111,
  1225002693,
  92479502,
  75891333,
  903,
  104,
  51896,
  -322744,
  145,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241541,
  1093930590,
  240203790,
  806240564,
  1093930564,
  240203790,
  806240564,
  1093930564,
  240203790,
  806240564,
  1144524366,
  239156238,
  806242368,
  1125387847,
  1091571395,
  1091309254,
  1091047111,
  265925,
  132,
  52004,
  -322692,
  593,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  873361922,
  1278742084,
  239285262,
  175374896,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189006862,
  1144262210,
  240793614,
  806240564,
  1144262216,
  240334862,
  806240564,
  1094192734,
  239156238,
  806243904,
  235584258,
  247677204,
  247873808,
  247939340,
  247808264,
  737540,
  144,
  52140,
  -322220,
  260,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  940459781,
  1094454850,
  239616014,
  1007568688,
  1212157505,
  172175374,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  1094192707,
  239156238,
  806242368,
  1094454857,
  240140302,
  1007572016,
  1212157505,
  239546382,
  1074684732,
  1227886152,
  239154190,
  1007567160,
  1212157505,
  242626574,
  940459316,
  1161563717,
  16398,
  188,
  52288,
  -322096,
  845,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074676485,
  1145572954,
  239422478,
  1074677840,
  1129057883,
  239620110,
  244646464,
  1208893764,
  1095503427,
  239620110,
  1276016960,
  1213206081,
  241123342,
  1343112268,
  1329598024,
  240405518,
  1074677840,
  1145310807,
  239355918,
  1343111500,
  37752396,
  1145310809,
  239355918,
  1343112012,
  37752396,
  1094979209,
  239355918,
  1343111500,
  1900023368,
  239160334,
  1074677840,
  336464467,
  269402947,
  202294849,
  135186241,
  68076865,
  241240897,
  1343114316,
  4984389,
  168,
  52480,
  -321440,
  449,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241029,
  1128009325,
  239616014,
  1007582512,
  1212157505,
  239808526,
  940459060,
  1111232070,
  240599054,
  235555888,
  247678484,
  247873808,
  247939340,
  247808264,
  1225475588,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  1007567627,
  1212157505,
  172699662,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189072398,
  1007589890,
  1212157505,
  172503054,
  239418382,
  1007569472,
  11,
  60,
  52652,
  -321148,
  619,
  135151872,
  222757509,
  59196933,
  92472454,
  167860995,
  1103512003,
  214254023,
  188810244,
  -1022711038,
  -951990719,
  67945793,
  737540,
  652,
  52716,
  -320588,
  1952,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -804370939,
  243728900,
  239338712,
  239142108,
  239600864,
  173671632,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189400078,
  81530493,
  81792577,
  82054721,
  82316871,
  82579009,
  82841153,
  80744008,
  81268314,
  81530434,
  81792577,
  80744008,
  81268334,
  81530434,
  81792581,
  80744017,
  81268320,
  81530445,
  81792581,
  82054727,
  82316870,
  82579009,
  82841158,
  80744008,
  336464456,
  269402947,
  202294849,
  135186241,
  68076865,
  239274819,
  239142108,
  239600864,
  1107428560,
  1157945358,
  1107614734,
  1090838542,
  1157948430,
  1157949454,
  1157950478,
  1426386958,
  1694814222,
  1157945358,
  1107614734,
  1090838542,
  1157948430,
  1157949454,
  1090841614,
  1426386958,
  33869838,
  81530458,
  81792577,
  80744008,
  81006157,
  81268297,
  81530439,
  81792577,
  81006153,
  80744005,
  81530492,
  81792577,
  80744008,
  -603059629,
  -535934716,
  -603044092,
  242420484,
  239404248,
  239207644,
  239142112,
  239404260,
  239404264,
  239142124,
  240452848,
  242877648,
  239863004,
  239731936,
  1661076688,
  1107613710,
  1191500814,
  1359273998,
  1359269902,
  1141169166,
  1208279054,
  1443155982,
  1090837518,
  1208279054,
  1812254734,
  1157945358,
  1107614734,
  1090838542,
  1157948430,
  1157949454,
  1157950478,
  1426386958,
  33869838,
  81268315,
  81530439,
  81792578,
  82054721,
  82316869,
  82579013,
  82841153,
  80744021,
  -603059625,
  -535933948,
  -603044604,
  240192260,
  239535316,
  239142104,
  239404252,
  239600864,
  239862992,
  239404252,
  239600864,
  174785744,
  1157945358,
  1107614734,
  1174724622,
  1157948430,
  1157949454,
  1157950478,
  1157951502,
  -603045109,
  -535933948,
  -804369916,
  -737254140,
  -670154492,
  -603044604,
  -535935740,
  -804370428,
  239469060,
  239863004,
  239863008,
  173147344,
  1157944334,
  1157945358,
  1157946382,
  1157947406,
  235554059,
  239404244,
  239404248,
  239404252,
  189072608,
  81530435,
  81792577,
  81530458,
  88,
  53372,
  -319292,
  480,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074676997,
  235570434,
  247677204,
  247873808,
  247939340,
  247808264,
  34292740,
  1347161779,
  239751182,
  1276010048,
  1246760528,
  240533518,
  1343115340,
  4197962,
  120,
  53464,
  -318904,
  343,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  940463362,
  1195118145,
  239616014,
  172818992,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  235554306,
  247677716,
  247873808,
  247939340,
  247808264,
  1124811780,
  239220750,
  1074676284,
  1680870984,
  239416334,
  1007568184,
  4197957,
  300,
  53588,
  -318676,
  2578,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  167848707,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189269006,
  1098124876,
  239368206,
  -2146548356,
  1879984129,
  1947105282,
  1131941445,
  239565838,
  239141248,
  239403396,
  239141256,
  239141260,
  240779664,
  17630064,
  239500302,
  239403392,
  235556976,
  247678996,
  247873808,
  247939340,
  247808264,
  1477133828,
  239500302,
  239600000,
  244515440,
  2081309816,
  25169475,
  40898120,
  1266421312,
  1208057870,
  503541774,
  1199050241,
  240090126,
  239600000,
  244777584,
  2014201972,
  1199312451,
  1090617358,
  1157727246,
  1191282702,
  1191283726,
  1510051854,
  1409445902,
  239302670,
  -2146549124,
  1879985153,
  2081338882,
  25169481,
  40898167,
  1199050406,
  240090126,
  239600000,
  246612592,
  2081309304,
  25169474,
  40898124,
  1266421396,
  1208057870,
  239300622,
  2081310072,
  25169474,
  44,
  53892,
  -316388,
  2512,
  135151872,
  222429829,
  59196165,
  92472454,
  167852291,
  1103512003,
  214254023,
  189137924,
  64,
  53940,
  -313924,
  158,
  135154432,
  239141511,
  1090749964,
  75698190,
  202294134,
  135185985,
  68077377,
  269369346,
  59114627,
  239403655,
  403588372,
  1159466565,
  8206,
  60,
  54008,
  -313832,
  152,
  135151872,
  239141510,
  1275298572,
  239538190,
  537806108,
  34606661,
  1159466590,
  239411214,
  235553552,
  247677196,
  247873800,
  738308,
  172,
  54072,
  -313736,
  725,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1007567621,
  1178603085,
  239156238,
  1007571000,
  1212157505,
  240529422,
  940464436,
  1094454849,
  240271374,
  248840752,
  1074676796,
  1764757064,
  239613966,
  1074676028,
  1613762120,
  239155214,
  1074676028,
  1261440584,
  239418382,
  806243648,
  336464457,
  269402947,
  202294849,
  135186241,
  68076865,
  243206982,
  1007567416,
  1212157505,
  240201742,
  940459060,
  1094454852,
  239616014,
  240255536,
  1074676796,
  3149384,
  80,
  54248,
  -313176,
  174,
  135155200,
  239141511,
  1090749964,
  75698190,
  -1022727166,
  -968815602,
  -952039410,
  188875790,
  1092357699,
  239673358,
  -1022737648,
  -968815602,
  -952039410,
  189137934,
  202294081,
  135185990,
  68077377,
  40,
  54332,
  -313084,
  49,
  135151872,
  239403651,
  235558160,
  247677192,
  1124811012,
  239737870,
  470697760,
  52,
  54376,
  -313064,
  65,
  135151872,
  239731331,
  403591444,
  1226575430,
  239607822,
  403587348,
  1092357698,
  239607822,
  247677192,
  4,
  64,
  54432,
  -313040,
  92,
  135151872,
  239141510,
  1124303628,
  241373198,
  403588628,
  1092357697,
  239607822,
  235554576,
  247677196,
  247873800,
  1259028740,
  239737870,
  470697248,
  40,
  54500,
  -313012,
  79,
  135151872,
  239141511,
  1141081612,
  75698190,
  1094192717,
  239418382,
  1007580736,
  44,
  54544,
  -312976,
  7060,
  135151872,
  222429829,
  59197701,
  92472454,
  168050691,
  1103512003,
  214254023,
  188810244,
  60,
  54592,
  -305952,
  1954,
  135151872,
  222429829,
  59196165,
  92472454,
  167980803,
  1103512003,
  214254023,
  189268996,
  167964931,
  1103512003,
  214254023,
  188941316,
  180,
  54656,
  -304048,
  349,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  -1341240059,
  -1139903224,
  -1072807672,
  -1139915256,
  -1072806904,
  -1341235192,
  -1274131704,
  -1207024376,
  -1139915768,
  -1072807672,
  -1274131448,
  -1207025400,
  -1139916536,
  -1072807672,
  -1341239288,
  235557640,
  239536312,
  239143100,
  189073600,
  235557634,
  239143100,
  239143104,
  239339716,
  239143112,
  239143116,
  239143120,
  239143124,
  239405272,
  239208668,
  239601888,
  239208636,
  189073600,
  146017861,
  146280005,
  146542149,
  146804289,
  145755725,
  96,
  54840,
  -303880,
  131,
  135151872,
  239141511,
  1090749964,
  75698190,
  1562381891,
  239150094,
  739131688,
  1160777281,
  172171278,
  -1019146226,
  -968815602,
  -952039410,
  189203470,
  1093406299,
  239153166,
  940458292,
  1228672581,
  239616014,
  739135776,
  1160777281,
  11278,
  68,
  54940,
  -303836,
  184,
  135151872,
  239469187,
  242549216,
  239600104,
  239403500,
  239600112,
  239534560,
  239534572,
  239731184,
  174916064,
  -1019148274,
  189334542,
  1091046996,
  265923,
  64,
  55012,
  -303716,
  75,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241029,
  1530662481,
  240205838,
  247677204,
  247873808,
  247939340,
  247808264,
  4,
  44,
  55080,
  -303704,
  1052,
  135151872,
  222429829,
  59196165,
  92472454,
  167905283,
  1103512003,
  214254023,
  189203460,
  132,
  55128,
  -302696,
  136,
  135151872,
  239141511,
  1124304396,
  75698190,
  1165495877,
  239172622,
  239600000,
  1947092848,
  1098387015,
  239238158,
  239600000,
  2081314416,
  25169473,
  1164971592,
  1091571210,
  1091309251,
  1091047110,
  1208225479,
  235553547,
  247678992,
  247873804,
  247939336,
  1124811524,
  239237134,
  -2146549380,
  -2079440383,
  -2012331775,
  -1945222911,
  -1878113791,
  1879984129,
  28,
  55264,
  -302688,
  34,
  269370112,
  1092357708,
  240197646,
  4,
  28,
  55296,
  -302672,
  34,
  269370112,
  1092357708,
  240197646,
  4,
  28,
  55328,
  -302656,
  30,
  269370112,
  1092357705,
  240132110,
  4,
  72,
  55360,
  -302656,
  88,
  135151872,
  239141510,
  1191412492,
  239278094,
  537805084,
  1561333320,
  239212558,
  537805084,
  1192234568,
  1175195146,
  1091047107,
  1157893830,
  202261259,
  135185219,
  68077121,
  36,
  55436,
  -302636,
  105,
  135151872,
  239469190,
  33784588,
  247663179,
  247873800,
  738564,
  52,
  55476,
  -302564,
  60,
  135151872,
  239141510,
  1157858060,
  239605774,
  537806620,
  1360006728,
  1091309066,
  1091047107,
  1191448262,
  11,
  24,
  55532,
  -639060,
  27,
  403587840,
  1109134917,
  8206,
  88,
  55560,
  -302584,
  201,
  135160064,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  235554050,
  672023076,
  1160515141,
  189280270,
  336464494,
  269402945,
  202294849,
  135186241,
  68076865,
  239405889,
  672023076,
  1160515141,
  12302,
  24,
  55652,
  -302468,
  74,
  135158784,
  -1016397181,
  1038,
  16,
  55680,
  -302416,
  16,
  0,
  76,
  55700,
  -302420,
  134,
  135151872,
  239141511,
  1124303628,
  239544334,
  806241836,
  35655240,
  202246722,
  135185217,
  68077377,
  172165954,
  -1019016178,
  -952039410,
  189334542,
  1093406279,
  239611918,
  32,
  216,
  55780,
  -302356,
  702,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  234951939,
  1208894276,
  1196166726,
  239620110,
  1208893764,
  1095503426,
  239620110,
  235567424,
  1208894788,
  1162612293,
  189288462,
  336464465,
  269402945,
  202294849,
  135186241,
  68076865,
  241371969,
  1276002632,
  1213206088,
  240533518,
  1208896068,
  1095503426,
  240734222,
  235556160,
  1208894788,
  1162612293,
  189091854,
  1141770821,
  1162350149,
  239422478,
  1158366544,
  1162087946,
  239421454,
  1343112524,
  172297029,
  239420430,
  1276003656,
  1162874437,
  1276004875,
  1213206081,
  240140302,
  1208893764,
  1095503429,
  239620110,
  64,
  28,
  56000,
  -301872,
  37,
  269370112,
  68029004,
  239602505,
  4,
  84,
  56032,
  -301856,
  126,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  537806597,
  1093406308,
  239808526,
  739135264,
  1211108932,
  240066574,
  806242092,
  1126174280,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  1038,
  56,
  56120,
  -301816,
  103,
  135151872,
  239141511,
  1090749964,
  75698190,
  247663208,
  247873804,
  247940872,
  1779123460,
  1124863683,
  1091047110,
  265927,
  92,
  56180,
  -301764,
  197,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  336464510,
  269402945,
  202294849,
  135186241,
  68076865,
  239536967,
  806241580,
  1830817352,
  1159990794,
  239413262,
  806241580,
  239274821,
  806243372,
  2887249,
  180,
  56276,
  -301652,
  347,
  135151872,
  239141511,
  1174636044,
  75698190,
  547360336,
  -1408348158,
  -1341242848,
  -1609676768,
  -1408343264,
  -1341243104,
  -1609673440,
  -1542567648,
  -1475460832,
  -1408351968,
  -1341243104,
  -1609676000,
  235562528,
  247677712,
  247873804,
  247939336,
  1175143172,
  1209011722,
  1091309251,
  1091047110,
  1090784967,
  -1408347893,
  -1341243104,
  -1609676768,
  -1542566624,
  -1475460064,
  -1408351968,
  -1341243104,
  -1609676768,
  235555616,
  247677200,
  247873804,
  247939336,
  1158365444,
  1109435406,
  1159768078,
  1159769102,
  2142222,
  68,
  56460,
  -301484,
  205,
  135151872,
  239272579,
  470699536,
  1210060356,
  172167182,
  -1019017202,
  189006862,
  1176243838,
  239738894,
  470699536,
  1210060357,
  241569806,
  537807132,
  1052232,
  72,
  56532,
  -301348,
  106,
  135151872,
  239141510,
  1124303628,
  240717838,
  403588628,
  1092357699,
  239607822,
  235557904,
  247677196,
  247873800,
  1124813316,
  1175195146,
  1091047107,
  1174671046,
  11,
  156,
  56608,
  -301312,
  573,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241541,
  1007576834,
  1212157528,
  240267278,
  940459060,
  1161563714,
  239878158,
  174260784,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189137934,
  1127484998,
  239286286,
  1074677052,
  1865420360,
  240401422,
  806242368,
  1144262224,
  239351822,
  1074676028,
  1194331739,
  239352846,
  806244672,
  1110969947,
  239221774,
  806243392,
  1195118179,
  239878158,
  60,
  56,
  56768,
  -300896,
  128,
  135151872,
  239141510,
  1124303628,
  1560416270,
  1124863498,
  1091047107,
  1090784966,
  336479499,
  1159204421,
  239410190,
  32,
  44,
  56828,
  -300828,
  643,
  135151872,
  222429829,
  59196933,
  92472454,
  -1022702078,
  -951990719,
  67945793,
  738820,
  116,
  56876,
  -300220,
  298,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  1093930603,
  239155214,
  1074677052,
  1815088718,
  239482894,
  1074677052,
  1882197582,
  239351822,
  1074677052,
  1261440590,
  239614990,
  806245184,
  336464470,
  269402945,
  202294849,
  135186241,
  68076865,
  239274821,
  1074677052,
  3149384,
  44,
  56996,
  -300036,
  2005,
  135151872,
  222429829,
  59196933,
  92472454,
  167966979,
  1103512003,
  214254023,
  188810244,
  116,
  57044,
  -298068,
  265,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537807109,
  1143737951,
  239742990,
  235567904,
  247677716,
  247873808,
  247939340,
  247808264,
  1913341188,
  1175719434,
  1091571395,
  1091309254,
  1091047111,
  1157893829,
  235561483,
  672023076,
  1160515141,
  189083662,
  1109659205,
  239413262,
  806241580,
  44,
  57164,
  -297916,
  3237,
  135151872,
  222429829,
  59196933,
  92472454,
  -1022736382,
  -951990719,
  67945793,
  737540,
  88,
  57212,
  -294716,
  157,
  135151872,
  239272579,
  470704912,
  1159728709,
  239276046,
  470696472,
  1293946433,
  172953614,
  -1019148274,
  189531150,
  135137868,
  68076353,
  172362563,
  239541262,
  470697760,
  336479499,
  1159204421,
  239410190,
  32,
  28,
  57304,
  -294648,
  30,
  202260480,
  1091571265,
  239145998,
  336481816,
  84,
  57336,
  -294650,
  207,
  202260992,
  1158680129,
  239145998,
  470696216,
  1159728705,
  240134158,
  604918060,
  1092619848,
  239934478,
  159597348,
  -2027418045,
  739131658,
  223480710,
  1137068291,
  67981255,
  239321924,
  1410227280,
  527983,
  144,
  57424,
  -294528,
  282,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  470696709,
  235581186,
  247677204,
  247874320,
  247939340,
  247808264,
  1779123204,
  1091833354,
  1091571395,
  1091309254,
  1124601543,
  1090784965,
  235553547,
  247678484,
  247873808,
  247939340,
  247808264,
  1124811012,
  1175719434,
  1125125827,
  1091309254,
  1091047111,
  1090784965,
  336478987,
  269402950,
  202294849,
  135186241,
  68076865,
  60,
  57572,
  -294388,
  1592,
  135151872,
  222429829,
  59196933,
  92472454,
  167851267,
  1103512003,
  214254023,
  189203460,
  167912195,
  1103512003,
  214254023,
  188810244,
  28,
  57636,
  -292852,
  45,
  403591936,
  1092357702,
  240263182,
  4,
  60,
  57668,
  -292836,
  106,
  135151872,
  239141510,
  1124303628,
  173416462,
  -1019147250,
  -968816626,
  188941326,
  1160515150,
  239415310,
  739138080,
  1160777285,
  8206,
  52,
  57732,
  -292788,
  95,
  135151872,
  239272583,
  1090749964,
  75698190,
  1159466617,
  239411214,
  -1022738160,
  -968815602,
  -952039410,
  189072398,
  92,
  57788,
  -292748,
  286,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074677509,
  1276012546,
  1162874437,
  172179470,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189006862,
  1179389557,
  239226894,
  1477329492,
  1180438081,
  239820814,
  1074677580,
  92,
  57884,
  -292556,
  302,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074677509,
  1276014850,
  1162874437,
  172179470,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188941326,
  1145835130,
  239226894,
  1477330004,
  1180438081,
  239689742,
  1074677580,
  44,
  57980,
  -292348,
  72,
  269370112,
  68029007,
  239864646,
  537806108,
  1276120645,
  239410190,
  269370656,
  265795,
  28,
  58028,
  -292316,
  28,
  403587840,
  1092357711,
  239607822,
  4,
  16,
  58060,
  -292316,
  4,
  0,
  16,
  58080,
  -292332,
  23,
  0,
  32,
  58100,
  -292329,
  26,
  135153152,
  1091309121,
  239996942,
  135151884,
  265793,
  32,
  58136,
  -292339,
  32,
  135154688,
  1091309121,
  239996942,
  135151884,
  265793,
  32,
  58172,
  -292343,
  32,
  135154688,
  1091309121,
  239996942,
  135151884,
  265793,
  32,
  58208,
  -292347,
  32,
  135154688,
  1091309121,
  239996942,
  135151884,
  265793,
  28,
  58244,
  -292340,
  20,
  403587840,
  1142689348,
  239607822,
  4,
  28,
  58276,
  -292340,
  30,
  403590144,
  1142689348,
  239607822,
  4,
  52,
  58308,
  -292340,
  49,
  135151872,
  239272579,
  403589652,
  1176243782,
  239214606,
  672023332,
  1110183491,
  239808526,
  247677192,
  4,
  52,
  58364,
  -292332,
  90,
  940458752,
  1094454857,
  240205838,
  873349944,
  1294995009,
  1090784778,
  1007572491,
  1212157508,
  239546382,
  4,
  28,
  58420,
  -292292,
  78,
  537805568,
  68029043,
  239930186,
  4,
  16,
  58452,
  -292244,
  14,
  0,
  60,
  58472,
  -167560,
  118,
  135153408,
  239141510,
  1208189708,
  242556942,
  806240556,
  1310723656,
  1091309066,
  1091047107,
  1107562182,
  202261259,
  135185219,
  68077121,
  56,
  58536,
  -292312,
  87,
  135151872,
  239141510,
  1124303628,
  242560014,
  873349680,
  1161301570,
  239483918,
  739132736,
  1091309126,
  1091047107,
  265926,
  56,
  58596,
  -292276,
  53,
  135151872,
  239141510,
  1124303628,
  240458766,
  604914208,
  1210584642,
  239152142,
  470697264,
  1091309126,
  1091047107,
  265926,
  16,
  58656,
  -292272,
  5,
  0,
  88,
  58676,
  -167636,
  285,
  135151872,
  239141510,
  1124303628,
  240521230,
  537805596,
  34606664,
  1092357709,
  239607822,
  470712080,
  1210060363,
  172167182,
  -1019147250,
  -968816626,
  189072398,
  1176243779,
  239607822,
  470703376,
  1377832515,
  4110,
  28,
  58768,
  -292368,
  78,
  537805568,
  68029043,
  239930186,
  4,
  40,
  58800,
  -292320,
  99,
  537805568,
  1160253036,
  239348750,
  537806896,
  1143737933,
  239874062,
  68044064,
  28,
  58844,
  -292252,
  34,
  403587840,
  1142689349,
  239607822,
  68046096,
  16,
  58876,
  -292236,
  12,
  0,
  16,
  58896,
  -292240,
  53,
  0,
  44,
  58916,
  -292196,
  53,
  135151872,
  239272579,
  336482832,
  1108872769,
  239213582,
  269371424,
  1124601422,
  265923,
  40,
  58964,
  -292180,
  49,
  810496,
  34081024,
  -2097085431,
  2131104000,
  293472017,
  -1018462971,
  12961734,
  44,
  59008,
  -292160,
  69,
  135151872,
  239141510,
  1963164428,
  135185162,
  68077121,
  -1019016376,
  -968816626,
  1038,
  168,
  59056,
  -292128,
  982,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  234949891,
  1477330004,
  1096552004,
  239624206,
  1410222672,
  1146621508,
  239164430,
  1343113312,
  235568386,
  247677204,
  247873808,
  247939340,
  247808264,
  34291972,
  336464589,
  269402945,
  202294849,
  135186241,
  68076865,
  -821949627,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  1410231307,
  1146621512,
  239164430,
  1343113312,
  1146359372,
  239163406,
  1611546972,
  5246536,
  64,
  59228,
  -291308,
  87,
  135151872,
  1091309121,
  -2025582578,
  59130882,
  168067918,
  1762922057,
  239144974,
  239190796,
  239191560,
  188860164,
  -1022620091,
  -972550591,
  -956035519,
  64,
  59296,
  -291280,
  87,
  135151872,
  1091309121,
  -2025582578,
  59130882,
  168067924,
  1662258761,
  239144974,
  239190796,
  239191560,
  188860164,
  -1022620091,
  -972550591,
  -956035519,
  60,
  59364,
  -291252,
  794,
  135151872,
  222429829,
  59196933,
  92472454,
  -1022708222,
  -951990719,
  67945793,
  34293252,
  1103301230,
  1103577542,
  67374277,
  2887,
  56,
  59428,
  -290516,
  57,
  135151872,
  1091309121,
  239144974,
  42419220,
  1208190532,
  -2058746493,
  269375236,
  202260931,
  135152069,
  68043206,
  199,
  104,
  59488,
  -290512,
  248,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  1092882008,
  239347726,
  806240556,
  1679822408,
  239150094,
  739132456,
  1211108929,
  241246222,
  672023588,
  1093406276,
  239808526,
  235555616,
  247677204,
  247873808,
  247939340,
  247808264,
  738564,
  400,
  59596,
  -290364,
  962,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  1095503458,
  239161358,
  1477330004,
  1096552004,
  239624206,
  1141787200,
  1145572929,
  239160334,
  1410223952,
  1146621508,
  239164430,
  1074678880,
  336464454,
  269402945,
  202294849,
  135186241,
  68076865,
  1073875782,
  239160334,
  1410220368,
  1096289857,
  239164430,
  1074677856,
  1094979139,
  239355918,
  1343111500,
  1228934728,
  239354894,
  1276002632,
  1213206081,
  239812622,
  1208893764,
  1162612292,
  239620110,
  1141789504,
  1095241284,
  239160334,
  1074679120,
  1145310794,
  239159310,
  1343111500,
  2084572744,
  239158286,
  1276003656,
  1280314945,
  240140302,
  1208893764,
  1095503429,
  240275470,
  1141787200,
  1145572932,
  239160334,
  1074677840,
  1094979140,
  239421454,
  1343111500,
  37752392,
  1162088024,
  239421454,
  1343111500,
  37752392,
  1094979184,
  239159310,
  1343111500,
  1296043592,
  239354894,
  1276003400,
  1213206081,
  239681550,
  1343113036,
  1146359361,
  239163406,
  1611546972,
  1245711944,
  239553550,
  1410220368,
  1146621508,
  239164430,
  1074677856,
  1094979152,
  239421454,
  1343111500,
  1413484112,
  239354894,
  1276003400,
  1213206081,
  239681550,
  1208893764,
  1095503428,
  239620110,
  64,
  104,
  60000,
  -289792,
  212,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  1093930580,
  239155214,
  1074676028,
  1664093768,
  239154190,
  1007567160,
  1212157505,
  241315854,
  940458292,
  1094454849,
  239616014,
  235555376,
  247677204,
  247873808,
  247939340,
  247808264,
  737540,
  336,
  60108,
  -289676,
  856,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  1094979168,
  239355918,
  1343111500,
  1379929672,
  239158286,
  1276003400,
  1263537729,
  239358990,
  1544438872,
  1281363521,
  172376078,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189334542,
  1094979185,
  239159310,
  1343111500,
  1128271432,
  239158286,
  1276003400,
  1213206084,
  239681550,
  1208894532,
  1095503428,
  239620110,
  1141787712,
  1095241281,
  239160334,
  1074677840,
  1178865269,
  239421454,
  1343111500,
  1096027736,
  239163406,
  1611546972,
  1413484114,
  239158286,
  1276003400,
  1213206081,
  239878158,
  1208893764,
  1095503429,
  239620110,
  241304128,
  1208894788,
  1095503429,
  239620110,
  241304128,
  1208893764,
  1095503425,
  239620110,
  1141787968,
  1145572929,
  239160334,
  1074677840,
  1094979154,
  239355918,
  1343111500,
  1447038536,
  239158286,
  1276002632,
  1213206081,
  239550478,
  1208894532,
  1095503428,
  239620110,
  1141787200,
  1162350150,
  239160334,
  1410226256,
  1096289857,
  239164430,
  1074680416,
  44,
  60448,
  -289152,
  163,
  135151872,
  222429829,
  58934277,
  -1010496901,
  1174668300,
  -1022733813,
  67374277,
  2886,
  36,
  60496,
  -289024,
  144,
  135151872,
  1141640769,
  -2042363257,
  243532291,
  239191560,
  50948,
  52,
  60536,
  -288920,
  60,
  135151872,
  1091309121,
  239144974,
  -2046654700,
  -2096855805,
  269382661,
  202260931,
  135152069,
  68043206,
  199,
  92,
  60592,
  -288912,
  248,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  176161285,
  1091571395,
  1091309254,
  1091047111,
  1225002693,
  -1022735861,
  -968486898,
  -952038386,
  -985593842,
  189137934,
  247663220,
  247873808,
  247939340,
  247808264,
  737540,
  124,
  60688,
  -288752,
  274,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235568386,
  247677204,
  247875088,
  247939340,
  247808264,
  1594573572,
  1175719434,
  1091571395,
  1091309254,
  1091047111,
  1208225477,
  235564811,
  247677204,
  247873808,
  247939340,
  247808264,
  1342915844,
  -1019145202,
  -968486898,
  -952038386,
  -985593842,
  1038,
  84,
  60816,
  -288592,
  513,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  940460037,
  167860995,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189072398,
  336464479,
  269402945,
  202294849,
  135186241,
  68076865,
  2885,
  32,
  60904,
  -288152,
  28,
  269370112,
  1091833415,
  239343630,
  537805852,
  265800,
  88,
  60940,
  -288156,
  97,
  135151872,
  239469187,
  239731132,
  239206848,
  239206852,
  239403464,
  239403468,
  240320976,
  239206832,
  239206836,
  239534520,
  239141308,
  239534528,
  239534532,
  239534536,
  239141324,
  239796688,
  247677192,
  4,
  16,
  61032,
  -288136,
  42,
  0,
  48,
  56552,
  -288108,
  219,
  244874756,
  135151880,
  222429829,
  59130373,
  1342309507,
  1224876078,
  -968768758,
  67945793,
  737540,
  68,
  56604,
  -287936,
  416,
  244878340,
  135151880,
  222429829,
  59196933,
  92472454,
  539905282,
  -1022733566,
  -951990719,
  67945793,
  34292740,
  1103301227,
  1103577542,
  67374277,
  2882,
  56,
  61176,
  -287592,
  86,
  135151872,
  239272579,
  235556880,
  247677704,
  1124813060,
  239145998,
  470696984,
  1210060356,
  172822542,
  -1018886130,
  189400078,
  28,
  61236,
  -287556,
  59,
  403590144,
  1159466565,
  239607822,
  68047120,
  192,
  61268,
  -287524,
  497,
  135151872,
  239141511,
  1174636044,
  75698190,
  1394609731,
  239413262,
  806241580,
  1344278085,
  239479822,
  537806896,
  1093406315,
  239611918,
  235556384,
  247677200,
  247873804,
  247939336,
  1426802692,
  239543310,
  739131688,
  1462767173,
  239154190,
  1007568184,
  1212157509,
  175185934,
  -1019146226,
  -968815602,
  -952039410,
  189269006,
  1160253033,
  239414286,
  537806128,
  1093406315,
  239611918,
  672023588,
  1160515139,
  239677454,
  672024876,
  1093406278,
  239349774,
  940458292,
  1161563717,
  239616014,
  739138336,
  1211108929,
  8206,
  48,
  61464,
  -287208,
  44,
  135152896,
  239141511,
  1325630988,
  239538190,
  537805084,
  1125125704,
  -968815602,
  -952039410,
  1038,
  52,
  61516,
  -287212,
  58,
  135151872,
  239272579,
  470699792,
  1293946433,
  239538190,
  470696472,
  1159728710,
  239276046,
  247677192,
  4,
  128,
  61572,
  -287204,
  379,
  135151872,
  239141511,
  1208190476,
  75698190,
  1159204425,
  239410190,
  269372192,
  1192758883,
  239344654,
  403588384,
  1259605574,
  172429326,
  1091309251,
  1091047110,
  1258557127,
  403595019,
  1159466565,
  239411214,
  470709776,
  1210060358,
  240193550,
  470696472,
  1210060354,
  240521230,
  470696216,
  1159728710,
  240259086,
  537805084,
  1052232,
  16,
  61704,
  -645192,
  10,
  0,
  28,
  61724,
  -286972,
  34,
  403587840,
  1142689349,
  239607822,
  68046096,
  28,
  61756,
  -286956,
  24,
  470696704,
  1293946436,
  239279118,
  4,
  60,
  61788,
  -286956,
  89,
  269370112,
  1109134929,
  240066574,
  269370140,
  68028995,
  239274821,
  537805340,
  1125912145,
  172167182,
  189006862,
  1142689347,
  8206,
  124,
  61852,
  -286924,
  235,
  135151872,
  239272579,
  235566096,
  247677192,
  1259030276,
  1091046922,
  1141116611,
  235554827,
  247677192,
  1175144196,
  1124601354,
  1191448259,
  235554315,
  247678472,
  1124813828,
  239474702,
  537805596,
  1125125704,
  1091046922,
  1208225475,
  235557899,
  247677192,
  1124811524,
  1226575370,
  239542286,
  1124812060,
  239148046,
  269371424,
  20,
  61980,
  -286812,
  60,
  537805568,
  265843,
  68,
  62004,
  -286772,
  99,
  135151872,
  239272579,
  336487184,
  1175981638,
  239475726,
  604914208,
  1093144131,
  239152142,
  135154480,
  68076353,
  -2096099775,
  470696706,
  1243614793,
  7182,
  36,
  62076,
  -286732,
  90,
  806241024,
  1144786551,
  239484942,
  1074676796,
  1160777292,
  1038,
  100,
  62116,
  -286676,
  126,
  135151872,
  239141511,
  1090749964,
  75698190,
  1108610631,
  239212558,
  537805084,
  1158680136,
  202294026,
  135185985,
  68077377,
  240651074,
  403588372,
  1092357697,
  239607822,
  470697232,
  1210060357,
  240062478,
  403587604,
  1159466565,
  239607822,
  16,
  80,
  62220,
  -286652,
  132,
  135151872,
  239141510,
  1124303628,
  241045518,
  470696216,
  1210060353,
  172953614,
  -1019016178,
  -968816626,
  189269006,
  202246740,
  135185219,
  68077121,
  239274824,
  470696216,
  1210060356,
  4110,
  60,
  62304,
  -286592,
  743,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  537805573,
  167940355,
  -1019145202,
  -968486898,
  -952038386,
  -985593842,
  189400078,
  28,
  62368,
  -285904,
  22,
  336478976,
  1108872772,
  239344654,
  68044832,
  28,
  62400,
  -285904,
  23,
  336478976,
  1108872773,
  239344654,
  68044832,
  92,
  62432,
  -285904,
  168,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  940459269,
  1094454853,
  239419406,
  235554608,
  247677204,
  247873808,
  247939340,
  247808264,
  1728792324,
  239417358,
  1074676540,
  1664093776,
  239286286,
  1074676028,
  3149385,
  104,
  62528,
  -285824,
  347,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  672023813,
  167838211,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  336464482,
  269402945,
  202294849,
  135186241,
  68076865,
  240520010,
  247677204,
  247873808,
  247939340,
  247808264,
  4,
  216,
  62636,
  -285580,
  1302,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  -1072806395,
  245236225,
  239206852,
  239337928,
  239337932,
  239600080,
  -1610415680,
  29625857,
  29888065,
  30150209,
  30412353,
  30674500,
  30936644,
  31198788,
  31460932,
  29363792,
  -938566398,
  -871480063,
  -804371199,
  -1072805375,
  174129665,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189269006,
  336464454,
  269402950,
  202294849,
  135186241,
  68076865,
  239209281,
  239206852,
  239337928,
  239337932,
  239927760,
  -788397632,
  1157743630,
  1140967438,
  1090636814,
  1140969486,
  1140970510,
  1140971534,
  1140972558,
  1342300174,
  114702,
  32,
  62856,
  -284488,
  34,
  269370112,
  1158942280,
  239409166,
  537805852,
  265800,
  44,
  62892,
  -284476,
  39,
  135151872,
  239272582,
  1493402380,
  135185162,
  68077121,
  -1019147454,
  -968816626,
  1038,
  16,
  62940,
  -284476,
  50,
  0,
  44,
  62960,
  -284432,
  104,
  135151872,
  239272583,
  1141081612,
  75698190,
  247683586,
  247874572,
  247939336,
  4,
  40,
  63008,
  -284368,
  56,
  135151872,
  239600259,
  403593492,
  1125912131,
  239607822,
  135153172,
  68076353,
  44,
  63052,
  -284348,
  3903,
  135151872,
  222429829,
  59196165,
  92472454,
  168434435,
  1103512003,
  214254023,
  189531140,
  96,
  63100,
  -280492,
  405,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676997,
  1276023042,
  1095765572,
  239227918,
  1544438104,
  1231031880,
  239815694,
  235566400,
  247677204,
  247873808,
  247939340,
  247808264,
  34294020,
  1111756420,
  239421454,
  1343112524,
  108,
  63200,
  -280176,
  487,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  1276028674,
  1095765570,
  239227918,
  1544438104,
  1264586312,
  239815694,
  1208908352,
  1145835079,
  239620110,
  235553600,
  247677716,
  247873808,
  247939340,
  247808264,
  34293764,
  1162088099,
  239421454,
  1343112524,
  16,
  63312,
  -279792,
  3,
  0,
  100,
  63332,
  -279796,
  262,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806242053,
  1228148341,
  239155214,
  1074676028,
  1697648203,
  239350798,
  1007567160,
  1178603073,
  172765198,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189334542,
  1094192735,
  239418382,
  806243136,
  104,
  63436,
  -279628,
  298,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241541,
  1007576066,
  1279266374,
  172634126,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188941326,
  1144262265,
  239155214,
  1074676028,
  1429212742,
  239352846,
  806243392,
  1094192734,
  239418382,
  806242368,
  56,
  63544,
  -279432,
  558,
  135154176,
  222429829,
  59196165,
  92472454,
  -1023313917,
  -951990719,
  67945793,
  84690436,
  -2063236344,
  -2029746686,
  3,
  44,
  63604,
  -278932,
  647,
  135151872,
  222429829,
  59196933,
  92472454,
  167889923,
  1103512003,
  214254023,
  189268996,
  60,
  63652,
  -278324,
  879,
  135151872,
  222429829,
  59196165,
  92472454,
  167837955,
  1103512003,
  214254023,
  189137924,
  1103301225,
  1103577542,
  67374277,
  2884,
  76,
  63716,
  -277508,
  1069,
  135151872,
  222429829,
  59196933,
  92472454,
  167917315,
  1103512003,
  214254023,
  188810244,
  167841795,
  1103512003,
  214254023,
  188810244,
  1103301228,
  1103577542,
  67374277,
  2881,
  60,
  63796,
  -276516,
  86,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537805573,
  235553794,
  247677716,
  247873808,
  247939340,
  247808264,
  737540,
  44,
  63860,
  -276484,
  1927,
  135151872,
  222429829,
  59197701,
  92472454,
  167939331,
  1103512003,
  214254023,
  189006852,
  68,
  63908,
  -274596,
  526,
  135155456,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  873349893,
  234985987,
  247677204,
  247873808,
  247939340,
  247808264,
  873351172,
  42272131,
  59180166,
  36,
  63980,
  -274140,
  144,
  135151872,
  1141640769,
  -2042363257,
  243532291,
  239191560,
  50948,
  56,
  64020,
  -274036,
  60,
  135151872,
  1091309121,
  239144974,
  42419220,
  1208190532,
  -2058746493,
  269376004,
  202260931,
  135152069,
  68043206,
  199,
  60,
  64080,
  -274032,
  87,
  135153408,
  239141511,
  1124304396,
  75698190,
  1176243787,
  239607822,
  247683856,
  247873804,
  247939336,
  269371140,
  59114627,
  647,
  60,
  64144,
  -274000,
  25298,
  135151872,
  222429829,
  59197701,
  92472454,
  167950595,
  1103512003,
  214254023,
  189268996,
  167886595,
  1103512003,
  214254023,
  189137924,
  32,
  64208,
  -248752,
  26,
  269370112,
  1142165058,
  239343630,
  537805852,
  265800,
  104,
  64244,
  -248756,
  335,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  1007568898,
  1212157505,
  1124216846,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1225002693,
  1007581195,
  1212157505,
  1258434574,
  1175719434,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  52,
  59852,
  -248528,
  227,
  244881924,
  135151880,
  222429829,
  59196933,
  92472454,
  539908354,
  -1022737662,
  -951990719,
  67945793,
  737540,
  72,
  64408,
  -248344,
  108,
  135151872,
  239272579,
  336486928,
  1175981638,
  239475726,
  604914208,
  1093144131,
  239152142,
  135154480,
  68076353,
  -2096099775,
  336478466,
  1159204418,
  239410190,
  470700832,
  36,
  64484,
  -248308,
  79,
  537805568,
  1143737964,
  239480846,
  806241324,
  1159728716,
  1038,
  16,
  64524,
  -248268,
  5,
  0,
  20,
  64544,
  -248272,
  31,
  269370112,
  265814,
  28,
  64568,
  -248264,
  29,
  135151872,
  239272579,
  135157520,
  68076353,
  48,
  64600,
  -248264,
  102,
  135151872,
  239272579,
  739140384,
  1160777285,
  241442830,
  806241580,
  1126174277,
  -1019017202,
  1038,
  36,
  64652,
  -248204,
  32,
  135151872,
  239272579,
  537808156,
  1176243783,
  -1019148274,
  1038,
  48,
  64692,
  -248212,
  113,
  135151872,
  239272579,
  1007578160,
  1161825861,
  241577998,
  1074677052,
  1127222853,
  -1019017202,
  1038,
  88,
  64744,
  -248136,
  171,
  135151872,
  239141511,
  1090749964,
  75698190,
  1092357750,
  239607822,
  -1022732272,
  -968815602,
  -952039410,
  189006862,
  1092357718,
  239607822,
  470696720,
  1210060353,
  172953614,
  1091309251,
  1091047110,
  1141116615,
  11,
  244,
  64836,
  -248052,
  178,
  135154432,
  1091309121,
  239144974,
  403587348,
  1092357697,
  239149070,
  672022820,
  1093406273,
  239153166,
  940458292,
  1094454849,
  239157262,
  1208893764,
  1095503425,
  239161358,
  1477329236,
  1096552001,
  239165454,
  1745764708,
  1097600577,
  239169550,
  2014200180,
  1098649153,
  1090617358,
  1090618382,
  1090619406,
  1090620430,
  1090621454,
  1090622478,
  1090623502,
  1090624526,
  1090625550,
  1090626574,
  1090627598,
  1090628622,
  1090629646,
  1090630670,
  1090631694,
  1090632718,
  1090633742,
  1090634766,
  1090635790,
  1090636814,
  1090637838,
  1090638862,
  1090639886,
  1090640910,
  1090641934,
  1090642958,
  1090643982,
  1107422222,
  1107423246,
  1107424270,
  1107425294,
  1107426318,
  1107460110,
  33719310,
  265819,
  32,
  65084,
  -248108,
  37,
  269370112,
  1142165071,
  239343630,
  537805340,
  265800,
  152,
  65120,
  -248096,
  423,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  235557122,
  247677204,
  247873808,
  247939340,
  247808264,
  34292740,
  1812859476,
  1198526017,
  239236110,
  2081310072,
  25169474,
  25431617,
  25693765,
  25955909,
  26218054,
  1365249605,
  239232014,
  1812874600,
  1215303237,
  172556811,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  1678657026,
  1164447298,
  239430670,
  112,
  16,
  65276,
  -247820,
  49,
  0,
  164,
  65296,
  -247776,
  363,
  135151872,
  239469187,
  240845232,
  239206836,
  239403448,
  239206844,
  239600064,
  239796656,
  239206836,
  239403448,
  239206844,
  239600064,
  1761739184,
  1157739534,
  1090631694,
  1107409934,
  1208074254,
  1593946126,
  1543615502,
  1157740558,
  1107409934,
  1208074254,
  1174515726,
  1091046922,
  1090784963,
  -1274130677,
  -1207025151,
  -1139915519,
  -1072807423,
  -1341241343,
  -1274132735,
  -1207022591,
  -1139915519,
  -1072807423,
  -1341241343,
  235554305,
  247677192,
  737540,
  16,
  65464,
  -247576,
  6,
  0,
  48,
  65484,
  -247580,
  44,
  135151872,
  239272579,
  537808412,
  1109659203,
  239282190,
  806241836,
  1159466565,
  -1019148274,
  1038,
  44,
  65536,
  -247584,
  605,
  135151872,
  222429829,
  59196165,
  92472454,
  -1022723070,
  -951990719,
  67945793,
  740100,
  56,
  65584,
  -247024,
  151,
  135151872,
  239141511,
  1124304396,
  75698190,
  36179525,
  1160515190,
  239677454,
  269370152,
  202294081,
  135185985,
  68077377,
  28,
  65644,
  -246924,
  16,
  403587840,
  1109134914,
  239411214,
  68043544,
  36,
  65676,
  -246940,
  36,
  470696704,
  1142951496,
  239346702,
  739132456,
  1211108932,
  1038,
  36,
  65716,
  -246932,
  34,
  470696704,
  1109397064,
  239346702,
  739132456,
  1211108932,
  1038,
  36,
  65756,
  -246924,
  36,
  470696704,
  1142951496,
  239346702,
  739132456,
  1211108932,
  1038,
  36,
  65796,
  -246916,
  34,
  470696704,
  1109397064,
  239346702,
  739132456,
  1211108932,
  1038,
  132,
  65836,
  -246908,
  1770,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1611547397,
  167905795,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189334542,
  235576066,
  247679764,
  247873808,
  247939340,
  247808264,
  51069188,
  235537046,
  247677204,
  247874320,
  247939340,
  247808264,
  1191919876,
  239168526,
  1611548784,
  1678683138,
  1097338433,
  239430670,
  1611549808,
  36,
  65972,
  -245268,
  30,
  470696704,
  1109397060,
  239346702,
  739132456,
  1211108932,
  1038,
  112,
  66012,
  -245276,
  1581,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1611547397,
  167880195,
  -1019145202,
  -968683506,
  -952038386,
  -985593842,
  189465614,
  336464467,
  269402945,
  202294849,
  135186241,
  68076865,
  -352122039,
  1097600514,
  239628302,
  247136864,
  1745764708,
  1164709441,
  239890446,
  96,
  36,
  66128,
  -243808,
  30,
  470696704,
  1109397060,
  239346702,
  739132456,
  1211108932,
  1038,
  32,
  66168,
  -243816,
  32,
  269370112,
  1142165064,
  239343630,
  537805852,
  265800,
  32,
  66204,
  -243820,
  30,
  269370112,
  1108610632,
  239343630,
  537805852,
  265800,
  32,
  66240,
  -243824,
  32,
  269370112,
  1142165064,
  239343630,
  537805852,
  265800,
  32,
  66276,
  -243828,
  30,
  269370112,
  1108610632,
  239343630,
  537805852,
  265800,
  32,
  66312,
  -243832,
  32,
  269370112,
  1142165064,
  239343630,
  537805852,
  265800,
  32,
  66348,
  -243836,
  30,
  269370112,
  1108610632,
  239343630,
  537805852,
  265800,
  80,
  66384,
  -243840,
  122,
  135151872,
  239141510,
  1124303628,
  174526478,
  -1019147250,
  -968816626,
  188875790,
  202246735,
  135185217,
  68077121,
  173214535,
  -1019147250,
  -968816626,
  188941326,
  1091309143,
  1091047107,
  265926,
  148,
  66468,
  -243796,
  991,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074677509,
  235564802,
  247677204,
  247873808,
  247939340,
  247808264,
  34293764,
  1111756412,
  239159310,
  1343111500,
  54529616,
  1208877342,
  1095503425,
  240144398,
  1141786432,
  1095241284,
  239160334,
  1074677840,
  1208924930,
  1095503432,
  240144398,
  1141787200,
  1095241282,
  239160334,
  1074678864,
  1141790466,
  1145572930,
  239160334,
  1074681680,
  156,
  66620,
  -242956,
  783,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241541,
  873387010,
  1094192708,
  239156238,
  806243392,
  235599106,
  247677716,
  247873808,
  247939340,
  247808264,
  1946895876,
  239350798,
  1007567160,
  1312820801,
  175386638,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  235558402,
  940459316,
  1161563717,
  189087758,
  873335365,
  1161301573,
  239418382,
  1158366528,
  239416334,
  1007568184,
  4197957,
  1252,
  66780,
  -242332,
  8940,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1609677307,
  -1408340222,
  -1341242110,
  -1609676798,
  24118018,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  235558923,
  247677204,
  247873808,
  247939340,
  247808264,
  34293508,
  44306042,
  44568132,
  44830273,
  45092417,
  44043848,
  235572226,
  247677204,
  247874320,
  247939340,
  247808264,
  51069188,
  -1542585436,
  -1475460606,
  -1408351998,
  -1341243134,
  -1609676798,
  -1542561278,
  -1475460606,
  -1408351230,
  -1341242366,
  -1609676798,
  180617730,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189334542,
  167903491,
  1157800974,
  1157801998,
  1157803022,
  1208135694,
  242483723,
  239338148,
  239141544,
  239141548,
  239600304,
  -972946784,
  1107469326,
  1141024782,
  1141025806,
  1208135694,
  1443012622,
  1107469326,
  1157801998,
  1090694158,
  1208135694,
  1526898702,
  1107469326,
  1157801998,
  1141025806,
  1208135694,
  33726478,
  44306061,
  44568130,
  44830277,
  45092417,
  44043848,
  167880707,
  1157800974,
  1157801998,
  1157803022,
  1174581262,
  -1542561013,
  -1475460606,
  -1408351998,
  -1341243134,
  -1609676798,
  235559938,
  239403684,
  239403688,
  239403692,
  189137584,
  44306030,
  44568130,
  44830273,
  45092417,
  44043848,
  234955779,
  240386724,
  239141544,
  239141548,
  239862448,
  240779936,
  239141548,
  239338160,
  239600308,
  239731384,
  239338172,
  239796928,
  1073873568,
  1141023758,
  1157801998,
  1157803022,
  1694674958,
  1241686030,
  1141023758,
  1157801998,
  1090694158,
  1174581262,
  1141027854,
  1157806094,
  1090698254,
  1208139790,
  33726478,
  44306041,
  44568130,
  44830281,
  45092417,
  44043855,
  44306047,
  44568129,
  44830273,
  45092420,
  44043852,
  234952707,
  239207076,
  239141544,
  239338156,
  240124592,
  1594032800,
  44305921,
  44568132,
  44830277,
  45092421,
  44043872,
  -1408335358,
  -1341243134,
  -1274132478,
  -1207025406,
  -1139915774,
  -1072806910,
  -1609676798,
  241369602,
  239141548,
  239338160,
  239141556,
  239600312,
  239338172,
  239600320,
  242483872,
  239141540,
  239600296,
  239338156,
  239600304,
  1375863456,
  1107469326,
  1157801998,
  1090694158,
  1275244558,
  33726478,
  44306140,
  44568132,
  44830276,
  45092421,
  44043848,
  44305995,
  44568132,
  44830273,
  45092417,
  44043848,
  235601154,
  239600292,
  189334184,
  -1542564606,
  -1475460606,
  -1408351998,
  -1341243134,
  -1609672958,
  249299458,
  239600292,
  239141544,
  239338156,
  239862448,
  1191314080,
  1107469326,
  1090693134,
  1090694158,
  1459793934,
  1761779726,
  44305930,
  44568130,
  44830274,
  1493371724,
  44305921,
  44568132,
  44830273,
  45092420,
  44043860,
  -1542583684,
  -1475460606,
  -1408351486,
  -1341243134,
  -1609676030,
  -1542561022,
  -1475459838,
  -1408350974,
  -1341242110,
  34294530,
  44305992,
  44568129,
  44830276,
  45092434,
  44043852,
  44305998,
  44568130,
  44830276,
  45092420,
  44043857,
  234965507,
  239207076,
  239141544,
  239141548,
  240583344,
  -654179680,
  1107469326,
  1090693134,
  1090694158,
  1208135694,
  33726478,
  44306047,
  44568138,
  44830276,
  45092417,
  44043848,
  -1542566142,
  -1475460094,
  -1408351230,
  -1341242366,
  -1609676798,
  20251394,
  1208132622,
  1141024782,
  1090694158,
  1208135694,
  1577230350,
  1090692110,
  1141024782,
  1141025806,
  1208135694,
  1241686030,
  44305930,
  44568133,
  44830277,
  45092421,
  172297029,
  1157800974,
  1157801998,
  1157803022,
  1157804046,
  235554059,
  239403684,
  239403688,
  239403692,
  189072048,
  -1542583728,
  -1475459838,
  -1408350974,
  -1341242110,
  1829455106,
  44305930,
  44568133,
  44830277,
  45092421,
  172297029,
  1157800974,
  1157801998,
  1157803022,
  1157804046,
  235554059,
  239403684,
  239403688,
  239403692,
  189072048,
  -1542583739,
  -1475459838,
  -1408350974,
  -1341242110,
  1661682946,
  44305930,
  44568133,
  44830277,
  45092421,
  172297029,
  1157800974,
  1157801998,
  1157803022,
  1157804046,
  11,
  32,
  68036,
  -234644,
  26,
  269370112,
  1108610628,
  239343630,
  537805852,
  265800,
  80,
  68072,
  -234648,
  122,
  135151872,
  239141510,
  1124303628,
  174526478,
  -1019147250,
  -968816626,
  188875790,
  202246735,
  135185217,
  68077121,
  173214535,
  -1019147250,
  -968816626,
  188941326,
  1091309143,
  1091047107,
  265926,
  164,
  68156,
  -234604,
  1180,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074677509,
  235565570,
  247677204,
  247873808,
  247939340,
  247808264,
  34292996,
  1111756401,
  239159310,
  1343111500,
  54529608,
  1208877419,
  1095503428,
  240144398,
  1141786432,
  1095241284,
  239160334,
  1074677840,
  1208940034,
  1414270536,
  239882254,
  1141792320,
  1095241282,
  239160334,
  1074678352,
  1141792258,
  1145572930,
  239160334,
  1074682704,
  1162088021,
  239159310,
  1343111500,
  4197962,
  156,
  68324,
  -233588,
  783,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241541,
  873387010,
  1094192708,
  239156238,
  806243392,
  235599106,
  247677716,
  247873808,
  247939340,
  247808264,
  1946895876,
  239350798,
  1007567160,
  1312820801,
  175386638,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  235558402,
  940459316,
  1161563717,
  189087758,
  873335365,
  1161301573,
  239418382,
  1158366528,
  239416334,
  1007568184,
  4197957,
  1324,
  68484,
  -232964,
  9138,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1072806395,
  -871469304,
  -804371192,
  -1072805880,
  24118024,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  235558923,
  247677204,
  247873808,
  247939340,
  247808264,
  34291972,
  147066489,
  147328580,
  147590721,
  147852865,
  146804296,
  235568386,
  247677204,
  247874320,
  247939340,
  247808264,
  51069188,
  -1005714499,
  -938589688,
  -871481080,
  -804372216,
  -1072805880,
  -1005690360,
  -938589688,
  -871480312,
  -804371448,
  -1072805880,
  181469704,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  167914243,
  1158202382,
  1158203406,
  1158204430,
  1309200398,
  241828363,
  239339716,
  239143112,
  239143116,
  239601872,
  -1023276864,
  1107870734,
  1141426190,
  1141427214,
  1208537102,
  1443414030,
  1107870734,
  1158203406,
  1091095566,
  1208537102,
  1527300110,
  1107870734,
  1158203406,
  1141427214,
  1208537102,
  34127886,
  147066439,
  147328578,
  147590725,
  147852865,
  146804296,
  167868163,
  1158202382,
  1158203406,
  1158204430,
  1242091534,
  18744075,
  1107870734,
  1091094542,
  1091095566,
  1208537102,
  1544077326,
  147066378,
  147328581,
  147590725,
  147852869,
  241371979,
  239208644,
  239143112,
  239143116,
  239601872,
  1443039424,
  147066369,
  147328596,
  147590721,
  147852865,
  146804300,
  147590746,
  147852865,
  148115012,
  148377160,
  148639306,
  148901444,
  146804299,
  -1005698814,
  -938589176,
  -871480056,
  -804371192,
  -1072798456,
  -1005696504,
  -938589176,
  -871480056,
  -804372216,
  -737262072,
  -670152952,
  -603044600,
  -535936760,
  -1072805880,
  244974088,
  239208644,
  239143112,
  239143116,
  240060624,
  218302656,
  147066369,
  147328578,
  147590725,
  147852865,
  146804314,
  147066468,
  147328586,
  147590721,
  147852868,
  146804300,
  336464454,
  269402945,
  202294849,
  135186241,
  68076865,
  553847617,
  147066369,
  147328578,
  147590722,
  147852868,
  146804311,
  -1005655550,
  -938589688,
  -871481080,
  -804372216,
  -1072801272,
  235559432,
  189532356,
  147066470,
  147328577,
  147590728,
  147852868,
  146804296,
  234964739,
  239339716,
  239339720,
  239405260,
  239601872,
  239995072,
  239339716,
  239143112,
  239143116,
  239601872,
  -654178112,
  1107870734,
  1091094542,
  1091095566,
  1510526990,
  34127886,
  -1005712824,
  1493913096,
  1174979598,
  1158203406,
  1158204430,
  1577635854,
  34127886,
  147590779,
  147852865,
  148115016,
  148377153,
  148639300,
  148901444,
  146804296,
  -871474686,
  -804371448,
  -737262584,
  -670154488,
  -603042296,
  -535935992,
  -1072805880,
  182125064,
  1091093518,
  1141426190,
  1158204430,
  175243787,
  1107870734,
  1124648974,
  1091095566,
  1258868750,
  1544077326,
  1158202382,
  1158203406,
  1158204430,
  1309200398,
  16843531,
  147066378,
  147328578,
  147590721,
  -1308488891,
  1107870734,
  1091094542,
  1091095566,
  1208537102,
  34127886,
  147066453,
  147328577,
  147590724,
  147852888,
  146804312,
  147066459,
  147328578,
  147590724,
  147852868,
  146804305,
  147066481,
  147328586,
  147590724,
  147852865,
  146804296,
  147066464,
  147328580,
  147590724,
  147852868,
  146804296,
  147066476,
  147328578,
  147590728,
  147852865,
  146804300,
  234989571,
  239208644,
  239601864,
  239601868,
  240584912,
  1258424512,
  147066378,
  147328581,
  147590725,
  147852869,
  172886853,
  1158202382,
  1158203406,
  1158204430,
  1158205454,
  235562763,
  239405252,
  239405256,
  239405260,
  189073616,
  -1005712827,
  -938588920,
  -871480056,
  -804371192,
  1158366472,
  147066378,
  147328581,
  147590725,
  147852869,
  241896261,
  239143108,
  239339720,
  239339724,
  239601872,
  172624064,
  1158202382,
  1158203406,
  1158204430,
  1158205454,
  235565323,
  239405252,
  239405256,
  239405260,
  189073616,
  -1005712827,
  -938588920,
  -871480056,
  -804371192,
  1158366472,
  147066378,
  147328581,
  147590725,
  147852869,
  239930181,
  239143108,
  239339720,
  240453836,
  239864016,
  241830080,
  239929540,
  239339720,
  239143116,
  239601872,
  172886208,
  1158202382,
  1158203406,
  1158204430,
  1158205454,
  235554059,
  239405252,
  239405256,
  239405260,
  189073616,
  147066454,
  147328581,
  147590725,
  147852869,
  32,
  69812,
  -225140,
  26,
  269370112,
  1108610628,
  239343630,
  537805852,
  265800,
  80,
  69848,
  -225144,
  122,
  135151872,
  239141510,
  1124303628,
  174526478,
  -1019147250,
  -968816626,
  188875790,
  202246735,
  135185217,
  68077121,
  173214535,
  -1019147250,
  -968816626,
  188941326,
  1091309143,
  1091047107,
  265926,
  232,
  69932,
  -225100,
  1182,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074677509,
  235564034,
  247677204,
  247873808,
  247939340,
  247808264,
  34292484,
  1111756401,
  239159310,
  1343111500,
  2084572744,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  172032523,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189465614,
  336464457,
  269402945,
  202294849,
  135186241,
  68076865,
  -436073661,
  239355918,
  1343111500,
  1195380304,
  239354894,
  1276002632,
  1213206081,
  240599054,
  1208894020,
  1095503428,
  240865294,
  248971840,
  1276004424,
  1280314959,
  240926734,
  1208894020,
  1095503425,
  239751182,
  241435200,
  1208894788,
  1095503425,
  239751182,
  64,
  156,
  70168,
  -224152,
  783,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241541,
  873387010,
  1094192708,
  239156238,
  806243392,
  235599106,
  247677716,
  247873808,
  247939340,
  247808264,
  1946895876,
  239350798,
  1007567160,
  1312820801,
  175583246,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  235557634,
  940459316,
  1161563717,
  189087758,
  873335365,
  1161301573,
  239418382,
  1158366528,
  239416334,
  1007568184,
  4197957,
  1284,
  70328,
  -223528,
  8983,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1072806395,
  -871469204,
  -804371092,
  -1072805780,
  24118124,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  235558923,
  247677204,
  247873808,
  247939340,
  247808264,
  34291972,
  1824788089,
  1825050180,
  1825312321,
  1825574465,
  1824525896,
  235568386,
  247677204,
  247874320,
  247939340,
  247808264,
  51069188,
  -1005714507,
  -938589588,
  -871480980,
  -804372116,
  -1072805780,
  -1005690260,
  -938589588,
  -871480212,
  -804371348,
  -1072805780,
  180945516,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  167929859,
  1164755982,
  1164757006,
  1164758030,
  1231867918,
  -1005688309,
  -938589076,
  -871480980,
  -804372116,
  -1072805780,
  247661164,
  239234244,
  239365320,
  239365324,
  239627472,
  240544960,
  239234244,
  239430856,
  239168716,
  239627472,
  240872640,
  239234244,
  239430856,
  239365324,
  239627472,
  -1979552576,
  1114424334,
  1164757006,
  1097649166,
  1215090702,
  57458702,
  235536697,
  239430852,
  239430856,
  239430860,
  189099216,
  234954499,
  239234244,
  239168712,
  239168716,
  239627472,
  173829312,
  1164755982,
  1164757006,
  1164758030,
  1248645134,
  -1005683445,
  -938589588,
  -871480980,
  -804372116,
  -1072805780,
  21693292,
  1416414222,
  1097648142,
  1097649166,
  1282199566,
  1517076494,
  1097649166,
  1147981838,
  1215091726,
  1248647182,
  1147984910,
  1265426446,
  40681486,
  1824788033,
  1825050180,
  1825312325,
  1825574469,
  1824525925,
  1824788042,
  1825050180,
  1825312325,
  1825574465,
  1825836614,
  1826098759,
  1826360901,
  1826623041,
  1824525896,
  -1005676030,
  -938589588,
  -871480980,
  -804372116,
  -1072803988,
  17695596,
  1114424334,
  1164757006,
  1097649166,
  1517080590,
  1684848654,
  1248642062,
  1097648142,
  1147980814,
  1282199566,
  1181532174,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  18940683,
  1114424334,
  1114425358,
  1147980814,
  1466748942,
  40681486,
  1824788202,
  1825050178,
  1825312321,
  1825574465,
  1824525914,
  -1005712806,
  1712016492,
  1097647118,
  1215088654,
  1147980814,
  1215090702,
  57458702,
  -1005715137,
  -938589076,
  -871480212,
  -804371092,
  -1072805780,
  -1005695380,
  -938589076,
  -871480980,
  -804372116,
  -1072805780,
  249102956,
  239234244,
  239168712,
  239168716,
  240807120,
  1208118464,
  1824787978,
  240716622,
  239496388,
  239430856,
  239430860,
  240938192,
  2097310912,
  1097649166,
  1248645134,
  1097651214,
  1147983886,
  1147984910,
  1215094798,
  40681486,
  1825312348,
  1825574468,
  1825836612,
  1826098753,
  1826360910,
  1826623044,
  1824525896,
  235593474,
  239168708,
  239365320,
  189099212,
  235588098,
  239234244,
  239299784,
  239168716,
  239824080,
  240938176,
  239430852,
  239430856,
  239430860,
  189689040,
  235579394,
  239234244,
  239168712,
  189099212,
  1824788074,
  1825050178,
  1825312321,
  1825574465,
  1824525896,
  -1005683710,
  -938589844,
  -871480212,
  -804366996,
  -1072804756,
  -1005692052,
  -938589588,
  -871480212,
  -804371348,
  -1072803476,
  247530092,
  239365316,
  239365320,
  239365324,
  239627472,
  117664960,
  1824787969,
  1825050178,
  1825312328,
  1825574465,
  1824525900,
  1824788058,
  1825050186,
  1825312324,
  1825574465,
  1824525896,
  -1005681150,
  -938589588,
  -871479188,
  -804370324,
  -1072801940,
  235563116,
  239430852,
  239430856,
  239430860,
  189099216,
  -1005712812,
  -938588820,
  -871479956,
  -804371092,
  1158366572,
  1824787978,
  1825050181,
  1825312325,
  1825574469,
  172297029,
  1164755982,
  1164757006,
  1164758030,
  1164759054,
  -1005684981,
  -938588052,
  -871480212,
  -804372116,
  -1072805780,
  172753516,
  1164755982,
  1164757006,
  1164758030,
  1164759054,
  235554059,
  239430852,
  239430856,
  239430860,
  189099216,
  1824788042,
  1825050177,
  1825312324,
  1825574468,
  1824525896,
  -1005712818,
  -938588820,
  -871479956,
  -804371092,
  1158366572,
  1824787978,
  1825050181,
  1825312325,
  1825574469,
  173083461,
  1164755982,
  1164757006,
  1164758030,
  1164759054,
  235554059,
  239430852,
  239430856,
  239430860,
  189099216,
  1824788083,
  1825050181,
  1825312325,
  1825574469,
  32,
  71616,
  -215824,
  26,
  269370112,
  1108610628,
  239343630,
  537805852,
  265800,
  72,
  71652,
  -215828,
  143,
  135151872,
  239141511,
  1124304396,
  75698190,
  2033192519,
  1091571210,
  1091309251,
  1091047110,
  1090784967,
  1007567627,
  1111494213,
  239223822,
  1276003656,
  1213206081,
  12302,
  80,
  71728,
  -215760,
  144,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074677509,
  336464504,
  269402945,
  202294849,
  135186241,
  68076865,
  239274817,
  1343112524,
  1112804930,
  239425550,
  1611546972,
  4197960,
  72,
  71812,
  -215700,
  161,
  135151872,
  239141511,
  1124304396,
  75698190,
  2033192519,
  1091571210,
  1091309251,
  1091047110,
  1090784967,
  1007567627,
  1111494213,
  239223822,
  1276003656,
  1213206081,
  12302,
  20,
  71888,
  -215600,
  51,
  135152384,
  265839,
  40,
  71912,
  -215560,
  97,
  135151872,
  239141510,
  1157858060,
  1459755022,
  -1019147250,
  -968816626,
  1038,
  20,
  71956,
  -215492,
  79,
  537805568,
  68045570,
  16,
  71980,
  -215436,
  55,
  0,
  72,
  72000,
  -215392,
  105,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  172753413,
  1125125827,
  1091309254,
  1091047111,
  1258557125,
  247677707,
  247874320,
  247939340,
  247808264,
  4,
  16,
  72076,
  -215356,
  26,
  0,
  192,
  72096,
  -215344,
  11056,
  135157504,
  -771620219,
  59182094,
  -2045768127,
  336478724,
  622396170,
  239144974,
  239191564,
  1694680840,
  1153762318,
  42272782,
  -989589920,
  -2063069616,
  68051458,
  135155397,
  241304197,
  240043268,
  1644332296,
  1321534478,
  42272782,
  -989589918,
  -2063069618,
  68051458,
  135155397,
  241304197,
  240043268,
  33719560,
  -989589913,
  -2063069623,
  68045826,
  -989852095,
  239274819,
  202260752,
  135152070,
  68043207,
  135154373,
  239141509,
  50562572,
  135135934,
  68043206,
  135155909,
  202244741,
  239993734,
  239191560,
  50436,
  16,
  72292,
  -204484,
  26,
  0,
  84,
  72312,
  -204472,
  1379,
  135157504,
  239141509,
  50562828,
  269353569,
  34210950,
  -972288279,
  -955773375,
  -989589951,
  239143756,
  239322636,
  239191816,
  239846660,
  235046152,
  1241745164,
  1103562766,
  1170539534,
  42272782,
  59182094,
  24,
  72400,
  -203168,
  37,
  135151872,
  240648835,
  49924,
  72,
  72428,
  -203148,
  105,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  172753413,
  1125125827,
  1091309254,
  1091047111,
  1258557125,
  247677707,
  247874320,
  247939340,
  247808264,
  4,
  60,
  72504,
  -203112,
  362,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235566850,
  247677204,
  247873808,
  247939340,
  247808264,
  738820,
  60,
  72568,
  -202808,
  472,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235570946,
  247677204,
  247873808,
  247939340,
  247808264,
  738820,
  80,
  72632,
  -202392,
  347,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806243845,
  235557122,
  247677716,
  247873808,
  247939340,
  247808264,
  34292996,
  1125388004,
  1091571395,
  1091309254,
  1091047111,
  265925,
  60,
  72716,
  -202124,
  104,
  135151872,
  239993475,
  235560720,
  247677192,
  1124811012,
  1124601354,
  1241779907,
  235558411,
  247677192,
  1175144708,
  -1019148274,
  1038,
  44,
  72780,
  -202076,
  2051,
  135151872,
  222429829,
  59195909,
  -2091842426,
  180355589,
  1103512003,
  214254023,
  189203460,
  16,
  72828,
  -200060,
  123,
  0,
  164,
  72848,
  -199952,
  1371,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  1343115269,
  1096289906,
  240016398,
  1343115360,
  1549536854,
  240017422,
  21889872,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1141116613,
  1544446475,
  1348472393,
  241848334,
  1611547484,
  38800985,
  1130106491,
  240279566,
  235554128,
  247677204,
  247873808,
  247939340,
  247808264,
  1863009796,
  1175719434,
  1091571395,
  1091309254,
  1091047111,
  1208225477,
  245236235,
  1611548508,
  5246550,
  76,
  73016,
  -198744,
  1920,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -804367611,
  177799682,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189006862,
  -603018750,
  -535934718,
  -804368894,
  2,
  100,
  73096,
  -196904,
  986,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  -804368123,
  245367297,
  239403484,
  240124384,
  302186960,
  336464385,
  269402945,
  202294849,
  135186241,
  68076865,
  241830731,
  239665628,
  239862240,
  1258422736,
  1224858638,
  1275191310,
  118798,
  80,
  73200,
  -196016,
  355,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  -2146546683,
  240321026,
  239141512,
  239534732,
  239600272,
  1560412800,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1241779909,
  11,
  60,
  73284,
  -195732,
  104,
  135151872,
  239141511,
  1124304396,
  75698190,
  247663226,
  247874572,
  247939336,
  1359692804,
  202294026,
  135185992,
  68077377,
  2881,
  92,
  73348,
  -195684,
  157,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -267496699,
  -133275391,
  -66173951,
  -2146549503,
  -2079440126,
  -2012331518,
  -1945222910,
  -1878113790,
  -267500286,
  172294657,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  160,
  73444,
  -195620,
  190,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -267499003,
  -200387327,
  -133283583,
  -66174719,
  -2146549503,
  -2079440126,
  -2012331518,
  -1945222654,
  -1878113790,
  -267499262,
  -133279231,
  -66174719,
  -2146549503,
  -2079440126,
  -2012331518,
  -1945222654,
  -1878113790,
  -267500286,
  -200379135,
  -133283583,
  -66174719,
  -2146549503,
  -2079440126,
  -2012331518,
  -1945222654,
  -1878113790,
  -267499262,
  336483073,
  269402947,
  202294849,
  135186241,
  68076865,
  104,
  73608,
  -195592,
  419,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074679301,
  167856131,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188875790,
  336464457,
  269402945,
  202294849,
  135186241,
  68076865,
  174525249,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  44,
  73716,
  -195268,
  81,
  135151872,
  239993475,
  235562256,
  247677192,
  1242254084,
  1091046922,
  1090784963,
  11,
  16,
  73764,
  -195220,
  8,
  0,
  44,
  73784,
  -195224,
  88,
  135151872,
  239993475,
  235563280,
  247677192,
  1359693572,
  1091046922,
  1090784963,
  11,
  16,
  73832,
  -195176,
  8,
  0,
  16,
  73852,
  -195180,
  20,
  0,
  16,
  73872,
  -195168,
  12,
  0,
  16,
  73892,
  -195172,
  8,
  0,
  16,
  73912,
  -195176,
  8,
  0,
  40,
  73932,
  -195180,
  60,
  135151872,
  239993475,
  739132712,
  1211108936,
  172695566,
  -1019148274,
  189269006,
  16,
  73976,
  -195160,
  8,
  0,
  16,
  73996,
  -195164,
  8,
  0,
  80,
  74016,
  -195168,
  220,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  -535934203,
  179765762,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  1125387846,
  1091571395,
  1091309254,
  1091047111,
  265925,
  16,
  74100,
  -195028,
  1,
  0,
  68,
  74120,
  -195032,
  293,
  135151872,
  222429829,
  59196421,
  92472454,
  -2142239102,
  175571463,
  -1010382907,
  1107559436,
  -1022734581,
  214288326,
  188810244,
  -943357438,
  -1060977722,
  262412,
  56,
  74192,
  -194800,
  153,
  135151872,
  222429829,
  59196421,
  92472454,
  -2142239102,
  172360199,
  -1010382907,
  1090782220,
  -943359989,
  -1060977722,
  262412,
  44,
  74252,
  -194700,
  176,
  135151872,
  222429829,
  59196421,
  92472454,
  -2142239102,
  -980024825,
  -1027356985,
  67177664,
  56,
  74300,
  -194572,
  198,
  135151872,
  222429829,
  59196677,
  92472454,
  125830786,
  -989169662,
  214156999,
  189268996,
  -959986309,
  213959363,
  1025,
  32,
  74360,
  -194424,
  29,
  269370112,
  1092095566,
  239213582,
  269370656,
  265795,
  40,
  74396,
  -194428,
  114,
  135151872,
  222429829,
  59196165,
  92472454,
  1103325186,
  1103577542,
  67374277,
  16,
  74440,
  -194358,
  4,
  0,
  16,
  74460,
  -194374,
  4,
  0,
  16,
  74480,
  -194390,
  4,
  0,
  16,
  74500,
  -194406,
  4,
  0,
  16,
  74520,
  -194408,
  31,
  0,
  88,
  74540,
  -194396,
  185,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  1110707822,
  239220750,
  1074676796,
  1865420361,
  239875086,
  1007567416,
  1228934724,
  173223950,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189334542,
  80,
  74632,
  -194296,
  143,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241797,
  1161301607,
  239156238,
  806244160,
  1261964897,
  239221774,
  806243392,
  1091833416,
  1091571395,
  1091309254,
  1091047111,
  265925,
  60,
  74716,
  -194236,
  111,
  135151872,
  239993475,
  235561488,
  247677192,
  1191921156,
  1174933002,
  1258557123,
  235555595,
  247678472,
  1124812548,
  -1019017202,
  1038,
  48,
  74780,
  -194188,
  88,
  135151872,
  239993475,
  235558672,
  247677192,
  1460357380,
  1124601354,
  1174671043,
  135153163,
  68076353,
  48,
  74832,
  -194144,
  88,
  135151872,
  239993475,
  235558672,
  247677192,
  1460357380,
  1124601354,
  1174671043,
  135153163,
  68076353,
  80,
  74884,
  -194100,
  347,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806243845,
  235557122,
  247677716,
  247873808,
  247939340,
  247808264,
  34292996,
  1125388004,
  1091571395,
  1091309254,
  1091047111,
  265925,
  60,
  74968,
  -193832,
  120,
  135151872,
  239141511,
  1090749964,
  75698190,
  1629490755,
  239741966,
  739134512,
  1731202640,
  -1019146226,
  -968815602,
  -952039410,
  1038,
  84,
  75032,
  -193768,
  280,
  135151872,
  239141511,
  1141081612,
  75698190,
  1093406288,
  239874062,
  235558944,
  247677200,
  247873804,
  247939336,
  34292228,
  1093406337,
  240332814,
  235555616,
  247677200,
  247873804,
  247939336,
  738564,
  96,
  75120,
  -193568,
  322,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1343112965,
  1544465666,
  1331695177,
  239492110,
  1343116896,
  336464508,
  269402947,
  202294849,
  135186241,
  68076865,
  239274824,
  247677716,
  247873808,
  247939340,
  247808264,
  4,
  124,
  75220,
  -193332,
  1344,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611549957,
  167911171,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  189006862,
  1812878338,
  1349520968,
  1862426638,
  239823886,
  1611550832,
  336464469,
  269402947,
  202294849,
  135186241,
  68076865,
  -1493038265,
  239561742,
  1611550832,
  1812916226,
  1349520974,
  24590,
  68,
  75348,
  -192116,
  137,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  1211895398,
  241254414,
  1074677820,
  1091833446,
  1091571395,
  1091309254,
  1091047111,
  265925,
  92,
  75420,
  -192044,
  334,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  1276026882,
  1397755465,
  1258438670,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1174671045,
  235562763,
  247677204,
  247873808,
  247939340,
  247808264,
  737540,
  68,
  75516,
  -191804,
  268,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074676997,
  1276027650,
  1481641545,
  242761742,
  247677204,
  247873808,
  247939340,
  247808264,
  4,
  200,
  75588,
  -191604,
  1715,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1611550213,
  235569154,
  247677716,
  247873808,
  247939340,
  247808264,
  34293252,
  336464573,
  269402949,
  202294849,
  135186241,
  68076865,
  -1375597759,
  239692814,
  1812875376,
  1383075396,
  1359110158,
  239627278,
  1611551344,
  1215041099,
  239890446,
  18613088,
  239232014,
  1812874088,
  1164971585,
  173891598,
  -1018883058,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  1812885250,
  1366298186,
  239496206,
  1611551344,
  234950659,
  1745765476,
  1147932228,
  239693838,
  1812888416,
  1282412100,
  24590,
  68,
  75792,
  -190080,
  131,
  135151872,
  239141511,
  1090749964,
  75698190,
  470697218,
  1595936323,
  172036110,
  1091309251,
  1091047110,
  1124339399,
  247680267,
  247873804,
  247940104,
  4,
  68,
  75864,
  -190008,
  147,
  135151872,
  239141511,
  1090749964,
  75698190,
  470701826,
  1595936321,
  172036110,
  1091309251,
  1091047110,
  1124339399,
  247681035,
  247873804,
  247939336,
  4,
  16,
  75936,
  -189920,
  29,
  0,
  60,
  75956,
  -189908,
  56,
  135151872,
  239141510,
  1308853004,
  172822542,
  -1019147250,
  -968816626,
  188810254,
  1109134915,
  239607822,
  247678220,
  247873800,
  4,
  68,
  76020,
  -189908,
  139,
  135151872,
  239141511,
  1090749964,
  75698190,
  470699522,
  1595936321,
  172036110,
  1091309251,
  1091047110,
  1141116615,
  247681035,
  247873804,
  247939336,
  4,
  32,
  76092,
  -189836,
  24,
  269370112,
  1108610626,
  239343630,
  537805852,
  265800,
  48,
  76128,
  -189840,
  44,
  135151872,
  239993475,
  537805340,
  1108348488,
  239211534,
  470696216,
  1210060356,
  -1019148274,
  1038,
  108,
  76180,
  -189844,
  276,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  537808389,
  1093406314,
  239611918,
  241762848,
  806240556,
  1193283144,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1141116613,
  235559691,
  247677716,
  247873808,
  247939340,
  247808264,
  1175144196,
  239414286,
  537806896,
  16,
  76292,
  -189668,
  5,
  0,
  40,
  76312,
  -189672,
  50,
  135151872,
  239993475,
  470699280,
  1344278081,
  239276046,
  247677192,
  4,
  108,
  76356,
  -189652,
  497,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343114757,
  1096552027,
  239624206,
  239206992,
  1611546972,
  1934626376,
  239623182,
  1343116384,
  336464454,
  269402947,
  202294849,
  135186241,
  68076865,
  -2080240831,
  239164430,
  1343113312,
  1700269647,
  239557646,
  1343113312,
  88,
  76468,
  -189252,
  137,
  135151872,
  239993475,
  470703120,
  1210060353,
  172167182,
  -1019148274,
  189269006,
  135137859,
  68076355,
  240323402,
  537805084,
  1125125704,
  1091046922,
  1208225475,
  470696715,
  1210060353,
  239276046,
  247677192,
  4,
  80,
  76560,
  -189200,
  347,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806243845,
  235557122,
  247677716,
  247873808,
  247939340,
  247808264,
  34292996,
  1125388004,
  1091571395,
  1091309254,
  1091047111,
  265925,
  188,
  76644,
  -188932,
  648,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611549957,
  336464475,
  269402945,
  202294849,
  135186241,
  68076865,
  172624712,
  -1018817522,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  1198263875,
  240021518,
  1812878176,
  1215303239,
  241459214,
  1879983980,
  39849548,
  1231556199,
  239561742,
  1611549808,
  1812873474,
  1366298181,
  239886350,
  1879984236,
  1281363537,
  239627278,
  1611549296,
  1678662146,
  1114115652,
  239561742,
  1678659184,
  1114115650,
  239561742,
  1812874864,
  1097338433,
  239561742,
  1611548784,
  104,
  76836,
  -188468,
  284,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  1611547397,
  1164709455,
  239431694,
  1678667360,
  1114115649,
  239168526,
  1611548528,
  1812886018,
  1282412097,
  241000462,
  1879983468,
  1197477445,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1191448261,
  11
}; // weak
int (*_frame_dummy_init_array_entry[4])() = { &frame_dummy, &init_cacheinfo, &_do_global_dtors_aux, &fini }; // weak
int (*funcs_8049550[3])() = { &init_cacheinfo, &_do_global_dtors_aux, &fini }; // weak
int (*_do_global_dtors_aux_fini_array_entry[2])() = { &_do_global_dtors_aux, &fini }; // weak
_UNKNOWN _JCR_LIST__; // weak
int dyn_temp_9507[] = { 0 }; // weak
int dword_80EAF84 = 0; // weak
int dl_random = 0; // weak
int _libc_stack_end = 0; // weak
int _libc_enable_secure = 1; // weak
int rtld_search_dirs = 0; // weak
int dword_80EAFD4 = 0; // weak
int max_capstrlen = 0; // weak
int ncapstr = 0; // weak
int capstr = 0; // weak
int env_path_list = 0; // weak
int dword_80EAFE8 = 0; // weak
int _stack_prot = 16777216; // weak
int GLOBAL_OFFSET_TABLE_ = 0; // weak
int (*off_80EB044)() = &strchr; // weak
int dl_tls_static_size = 2048; // weak
char *nl_current_default_domain = "messages"; // weak
void *_exit_funcs = &initial; // weak
int *IO_list_all = &IO_2_1_stderr_; // weak
int dword_80EB090 = 0; // weak
int dword_80EB094 = 0; // weak
int dword_80EB098 = 0; // weak
int IO_2_1_stderr_ = -72540026; // weak
int dword_80EB0A4 = 0; // weak
int dword_80EB0A8 = 0; // weak
int dword_80EB0AC = 0; // weak
int dword_80EB0B0 = 0; // weak
int dword_80EB0B4 = 0; // weak
char byte_80EB0B8[] = { '\0' }; // weak
char byte_80EB0B9[] = { '\0' }; // weak
char byte_80EB0BA[] = { '\0' }; // weak
char byte_80EB0BB[] = { '\0' }; // weak
int dword_80EB0BC = 0; // weak
int *stderr = &IO_2_1_stderr_; // weak
void *stdout = &IO_2_1_stdout_; // weak
void *stdin = &IO_2_1_stdin_; // weak
int may_shrink_heap_8236 = -1; // weak
int _libc_malloc_initialized = -1; // weak
int narenas = 1; // weak
int check_action = 3; // weak
int (__cdecl *_memalign_hook)(_DWORD, _DWORD, _DWORD) = &memalign_hook_ini; // weak
int (__cdecl *_realloc_hook)(int, int) = &realloc_hook_ini; // weak
int (__cdecl *_malloc_hook)(int) = &malloc_hook_ini; // weak
int mp_ = 131072; // weak
int dword_80EB4E4 = 131072; // weak
int dword_80EB4E8 = 131072; // weak
int dword_80EB4EC = 2; // weak
int dword_80EB4F0 = 0; // weak
int dword_80EB4F4 = 0; // weak
int dword_80EB4F8 = 65536; // weak
int dword_80EB4FC = 0; // weak
int dword_80EB500 = 0; // weak
int dword_80EB504 = 0; // weak
int dword_80EB508 = 0; // weak
int dword_80EB50C = 0; // weak
int main_arena = 0; // weak
int dword_80EB524 = 0; // weak
int dword_80EB550 = 0; // weak
int *off_80EB960 = &main_arena; // weak
int dword_80EB96C = 0; // weak
int dword_80EB970 = 0; // weak
int (__cdecl *_morecore)(_DWORD) = &_default_morecore; // weak
int _x86_raw_shared_cache_size = 1048576; // weak
int _x86_raw_shared_cache_size_half = 524288; // weak
int _x86_shared_cache_size = 1048576; // weak
int _x86_shared_cache_size_half = 524288; // weak
int _x86_raw_data_cache_size = 32768; // weak
int _x86_raw_data_cache_size_half = 16384; // weak
int _x86_data_cache_size = 32768; // weak
int _x86_data_cache_size_half = 16384; // weak
int cached_result_10203 = -1; // weak
void *program_invocation_short_name = &byte_80CFAB1; // weak
void *program_invocation_name = &byte_80CFAB1; // weak
__int64 (__fastcall *dl_sysinfo)(_DWORD) = &dl_sysinfo_int80; // weak
int (*dl_make_stack_executable_hook)(void) = &dl_make_stack_executable; // weak
int dl_stack_flags = 7; // weak
__int16 dl_fpu_control = 895; // weak
int dl_correct_cache_id = 3; // weak
int dl_debug_fd = 2; // weak
int dl_pagesize = 4096; // weak
int (__cdecl *dl_init_static_tls)(_DWORD) = &dl_nothread_init_static_tls; // weak
void **dl_initial_searchlist = &_compound_literal_3; // weak
int dword_80EBA14 = 1; // weak
__int64 dl_load_adds = 1LL; // weak
int dl_nns = 1; // weak
void *dl_ns = &dl_main_map; // weak
int dword_80EBA44[] = { 1 }; // weak
void ***off_80EBA48 = &off_80EBBFC; // weak
int dword_80EBA4C[] = { 0 }; // weak
_UNKNOWN unk_80EBA50; // weak
int dword_80EBA68[] = { 0 }; // weak
int dword_80EBA6C[] = { 0 }; // weak
int dword_80EBA70[] = { 0 }; // weak
int dword_80EBA74[] = { 0 }; // weak
int dword_80EBBF0 = 0; // weak
__int16 word_80EBBF8 = 0; // weak
int dword_80EBC48 = 0; // weak
int dl_use_load_bias = -2; // weak
int _libc_multiple_libcs = 1; // weak
char *builtin_modules[2] = { "INTERNAL", "ISO-10646/UCS4/" }; // weak
int dword_80EBE9C[] = { 0 }; // weak
void **nl_global_locale[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
char (*off_80EBED4)[512] = &byte_80C2440; // weak
int off_80EBED8 = 135009600; // weak
int (*off_80EBEDC)[256] = &dword_80C1B40; // weak
void *off_80EBEE0 = &nl_C_name; // weak
void *off_80EBEF8 = &nl_C_name; // weak
__int16 _fpu_control = 895; // weak
int pa_next_type = 8; // weak
void *tzname = &unk_80CDC63; // weak
void *off_80EBF20 = &unk_80CDC63; // weak
int (__cdecl *dl_open_hook[2])(int, int) = { &_libc_dlopen_mode, &_libc_dlsym }; // weak
int (*dl_error_catch_tsd)(void) = &dl_initial_error_catch_tsd; // weak
int (__cdecl *dlfcn_hooks)(int, int, int) = &_dlopen; // weak
char edata; // weak
_UNKNOWN unk_80EBF83; // weak
_DWORD object_6066[7]; // weak
int static_slotinfo; // weak
int dword_80EBFB4; // weak
int output_charset_cache_9803; // weak
int output_charset_cached_9804; // weak
int freemem_size_9752; // weak
int freemem_9751; // weak
int lock_9743; // weak
int transmem_list; // weak
int root; // weak
int nl_loaded_domains; // weak
int lock_9614; // weak
int dword_80EC248; // weak
int dword_80EC24C; // weak
int locale_alias_path_9109; // weak
int maxmap; // weak
int nmap; // weak
int string_space_max; // weak
int string_space_act; // weak
int lock; // weak
int _abort_msg; // weak
int lock_0; // weak
int dword_80EC270; // weak
int dword_80EC274; // weak
int stage; // weak
int phys_pages_7835; // weak
int pagesize_7836; // weak
int lock_1; // weak
int freeres_list; // weak
char dealloc_buffers; // weak
int run_fp; // weak
int IO_list_all_stamp; // weak
int list_all_lock; // weak
int dword_80EC4C0; // weak
int dword_80EC4C4; // weak
int (*_after_morecore_hook)(void); // weak
int (__cdecl *_free_hook)(_DWORD, _DWORD); // weak
int next_to_use_10602; // weak
int narenas_limit_10628; // weak
int disallow_malloc_check; // weak
int using_malloc_checking; // weak
int aligned_heap_area; // weak
int list_lock; // weak
int free_list; // weak
int free_list_lock; // weak
int perturb_byte; // weak
int global_max_fast; // weak
int dumped_main_arena_end; // weak
int dumped_main_arena_start; // weak
int environ; // weak
int timestamp_10204; // weak
__int64 dl_hwcap_mask; // weak
__int64 dl_hwcap2; // weak
__int64 dl_hwcap; // weak
int dl_x86_cpu_features; // weak
int dword_80EC564; // weak
int dword_80EC568; // weak
_UNKNOWN unk_80EC56C; // weak
char byte_80EC56E; // weak
int dword_80EC570; // weak
_UNKNOWN unk_80EC574; // weak
char byte_80EC575[2]; // weak
char byte_80EC577; // weak
int dword_80EC578; // weak
int dword_80EC57C; // weak
int dword_80EC580; // weak
int dword_80EC584; // weak
int dword_80EC588; // weak
int dword_80EC58C; // weak
int dword_80EC590; // weak
int dword_80EC594; // weak
int dword_80EC598; // weak
int dword_80EC59C; // weak
int dword_80EC5A0; // weak
int once_0; // weak
int known_derivations; // weak
int modcounter_11232; // weak
int lock_11252; // weak
int cache_malloced; // weak
int cache_size; // weak
int gconv_cache; // weak
int release_handle; // weak
int loaded; // weak
int archloaded; // weak
__int64 archive_stat; // weak
__int64 qword_80EC64C; // weak
int dword_80EC668; // weak
__int64 qword_80EC678; // weak
int headmap; // weak
int dword_80EC688; // weak
int dword_80EC68C; // weak
int archmapped; // weak
int last_environ; // weak
int known_values; // weak
int envlock; // weak
int lock_2; // weak
int next_bit; // weak
int lock_3; // weak
int lock_4; // weak
_UNKNOWN state; // weak
_UNKNOWN state_0; // weak
_UNKNOWN state_1; // weak
int timezone; // weak
int daylight; // weak
int is_initialized_8856; // weak
int old_tz; // weak
int tzstring_list; // weak
int tz_rules[]; // weak
int dword_80EC704[]; // weak
__int16 word_80EC708; // weak
__int16 word_80EC70A[]; // weak
__int16 word_80EC70C[]; // weak
int dword_80EC710[]; // weak
int dword_80EC714[]; // weak
int dword_80EC718; // weak
int dword_80EC71C[]; // weak
int dword_80EC720; // weak
int dword_80EC734; // weak
int dword_80EC738; // weak
int tzset_lock; // weak
int tzspec; // weak
int leaps; // weak
int num_leaps; // weak
int rule_dstoff; // weak
int rule_stdoff; // weak
int zone_names; // weak
int types; // weak
int num_types; // weak
int type_idxs; // weak
int num_transitions; // weak
int tzfile_mtime; // weak
__int64 tzfile_ino; // weak
__int64 tzfile_dev; // weak
int _curbrk; // weak
int max_dirnamelen; // weak
int (__cdecl *receiver)(_DWORD, _DWORD, _DWORD); // weak
int dl_close_state_10451; // weak
int cachesize; // weak
int cache_new; // weak
int cache; // weak
int once; // weak
int static_buf; // weak
_UNKNOWN last_result; // weak
int dword_80EC7C0; // weak
int localtime_offset; // weak
int log_hashfraction; // weak
int textsize; // weak
int lowpc; // weak
int fromidx; // weak
int fromlimit; // weak
int froms; // weak
int tos; // weak
int narcsp; // weak
int narcs; // weak
int running; // weak
int data; // weak
_UNKNOWN internal; // weak
_UNKNOWN state_2; // weak
int oact_7766[35]; // weak
_UNKNOWN otimer_7767; // weak
int pc_scale; // weak
int pc_offset; // weak
int nsamples; // weak
int samples; // weak
char dwarf_reg_size_table[]; // weak
char byte_80EC8D1; // weak
char byte_80EC8D2; // weak
char byte_80EC8D3; // weak
char byte_80EC8D4; // weak
char byte_80EC8D5; // weak
char byte_80EC8D6; // weak
char byte_80EC8D7; // weak
char byte_80EC8D8; // weak
char byte_80EC8D9; // weak
char byte_80EC8DB; // weak
char byte_80EC8DC; // weak
char byte_80EC8DD; // weak
char byte_80EC8DE; // weak
char byte_80EC8DF; // weak
char byte_80EC8E0; // weak
int frame_hdr_cache_head; // weak
int seen_objects; // weak
int unseen_objects; // weak
int dl_tls_static_used; // weak
int dl_tls_static_align; // weak
int dl_tls_max_dtv_idx; // weak
int dl_static_dtv; // weak
_UNKNOWN unk_80ECA28; // weak
int dword_80ECA30; // weak
char byte_80ECA34; // weak
int dl_tls_dtv_slotinfo_list; // weak
char dl_tls_dtv_gaps; // weak
int dl_tls_generation; // weak
int dl_tls_static_nelem; // weak
int nl_domain_bindings; // weak
int nl_msg_cat_cntr; // weak
__int64 _new_exitfn_called; // weak
int _x86_shared_non_temporal_threshold; // weak
_UNKNOWN r_debug; // weak
int dword_80ECC54; // weak
int dl_profile_output; // weak
int dl_platformlen; // weak
int dl_debug_mask; // weak
int (*dl_wait_lookup_done)(void); // weak
int dl_profile; // weak
__int64 dl_cpuclock_offset; // weak
int dl_bind_not; // weak
int dl_auxv; // weak
int dl_platform; // weak
int dl_lazy; // weak
int dl_sysinfo_map; // weak
int dl_inhibit_cache; // weak
int dl_phdr; // weak
int dl_scope_free_list; // weak
int dl_origin_path; // weak
int dl_clktck; // weak
int dl_dynamic_weak; // weak
int dl_sysinfo_dso; // weak
int dl_init_all_dirs; // weak
int dl_verbose; // weak
int dl_phnum; // weak
int dl_profile_map; // weak
int dl_initfirst; // weak
int dl_all_dirs; // weak
int dl_osversion; // weak
int dl_inhibit_rpath; // weak
int _libc_enable_secure_decided; // weak
int _libc_argc; // weak
int _libc_argv; // weak
int _gconv_modules_db; // weak
int _gconv_lock; // weak
int _gconv_alias_db; // weak
int _gconv_path_envvar; // weak
int _gconv_max_path_elem_len; // weak
int _gconv_path_elem; // weak
int nl_locale_file_list[13]; // weak
int _printf_function_table; // weak
int _printf_modifier_table; // weak
int _tzname_cur_max; // weak
int _use_tzfile; // weak
int tmbuf[11]; // weak
int map; // weak
int string_space; // weak
int _printf_arginfo_table; // weak
int _printf_va_arg_table; // weak
int transitions; // weak
int buf; // weak


//----- (0804818C) --------------------------------------------------------
int init_proc()
{
  return 0;
}

//----- (080482A0) --------------------------------------------------------
int __usercall backtrace_and_maps@<eax>(int a1@<eax>, char a2@<dl>, int a3@<ecx>, long double a4@<st0>)
{
  bool v4; // cc
  int result; // eax
  int v7; // esi
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  int v12; // ecx
  int v13; // edx
  __int64 v14; // rax
  unsigned int v15; // [esp+0h] [ebp-520h]
  char v16[4]; // [esp+4h] [ebp-51Ch] BYREF
  char v17[252]; // [esp+8h] [ebp-518h] BYREF
  char v18[1052]; // [esp+104h] [ebp-41Ch] BYREF

  v4 = a1 <= 1;
  result = a1 - 1;
  if ( !v4 )
  {
    if ( a2 )
    {
      result = backtrace(a4, (int)v16, 64);
      v7 = result;
      if ( result > 2 )
      {
        v8 = dl_sysinfo("======= Backtrace: =========\n");
        if ( v8 > 0xFFFFF000 )
          _syscall_error(v8);
        backtrace_symbols_fd((int)v17, v7 - 1, a3);
        v9 = dl_sysinfo("======= Memory map: ========\n");
        if ( v9 > 0xFFFFF000 )
          _syscall_error(v9);
        v10 = dl_sysinfo(0);
        if ( v10 > 0xFFFFF000 )
          _syscall_error(v10);
        do
        {
          v11 = dl_sysinfo(v18);
          v13 = v11;
          if ( v11 > 0xFFFFF000 )
            v13 = _syscall_error(v11);
          if ( v13 <= 0 )
            break;
          v14 = dl_sysinfo(v18);
          if ( (unsigned int)v14 > 0xFFFFF000 )
          {
            v15 = HIDWORD(v14);
            v14 = __PAIR64__(v15, _syscall_error(v14));
          }
        }
        while ( (_DWORD)v14 == HIDWORD(v14) );
        return dl_sysinfo(v12);
      }
    }
  }
  return result;
}
// 80483AB: variable 'v12' is possibly undefined
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80482A0: using guessed type char var_51C[4];
// 80482A0: using guessed type char var_518[252];

//----- (080483BC) --------------------------------------------------------
void __noreturn detach_arena_part_2()
{
  _malloc_assert("detach_arena");
}
// 80483BC: using guessed type void __noreturn detach_arena_part_2();
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);

//----- (080483D8) --------------------------------------------------------
void __noreturn oom()
{
  dl_dprintf(2, "cannot allocate memory for thread-local data: ABORT\n");
  exit(127);
}
// 80483D8: using guessed type void __noreturn oom();

//----- (08048400) --------------------------------------------------------
const char *__usercall fini@<eax>(long double a1@<st0>)
{
  return check_free_isra_0((const char *)dword_80EC7C0, a1);
}
// 80EC7C0: using guessed type int dword_80EC7C0;

//----- (08048410) --------------------------------------------------------
int init_cacheinfo()
{
  signed int v0; // edi
  int result; // eax
  int v2; // ebp
  int v3; // edi
  int v4; // ebx
  int v5; // ecx
  int v6; // ebp
  int v7; // edi
  int v8; // esi
  int v14; // ecx
  unsigned int v15; // ecx
  int v16; // eax
  int v17; // esi
  unsigned int v28; // ebx
  bool v34; // al
  int v35; // ecx
  int v36; // ebp
  int v37; // esi
  int v38; // edi
  int v44; // ecx
  unsigned int v45; // ecx
  unsigned int v46; // ecx
  int v47; // eax
  unsigned int v48; // ecx
  int v49; // [esp+4h] [ebp-38h]
  int v50; // [esp+8h] [ebp-34h]
  int v51; // [esp+Ch] [ebp-30h]
  bool v52; // [esp+13h] [ebp-29h]
  int v53; // [esp+14h] [ebp-28h]
  int v54; // [esp+1Ch] [ebp-20h]

  if ( dl_x86_cpu_features != 1 )
  {
    if ( dl_x86_cpu_features != 2 )
      goto LABEL_3;
    v2 = handle_amd(188);
    v3 = handle_amd(191);
    v17 = handle_amd(194);
    _EAX = 0x80000000;
    __asm { cpuid }
    if ( v17 <= 0 )
      goto LABEL_28;
    if ( _EAX <= 0x80000007 )
    {
      _EAX = 1;
      __asm { cpuid }
      if ( (_EDX & 0x10000000) == 0 )
        goto LABEL_36;
      v28 = BYTE2(_EBX);
      if ( !v28 )
      {
        v3 += v17;
        goto LABEL_28;
      }
    }
    else
    {
      _EAX = -2147483640;
      __asm { cpuid }
      v28 = 1 << ((unsigned __int16)_ECX >> 12);
    }
    v17 /= v28;
LABEL_36:
    v3 += v17;
    goto LABEL_28;
  }
  v2 = handle_intel(188, dword_80EC564);
  v49 = handle_intel(191, dword_80EC564);
  v3 = handle_intel(194, dword_80EC564);
  if ( v3 <= 0 )
  {
    v3 = v49;
    v50 = -1;
    v53 = 2;
  }
  else
  {
    v50 = 0;
    v53 = 3;
  }
  if ( (byte_80EC577 & 0x10) == 0 )
    goto LABEL_28;
  if ( dword_80EC564 <= 3 )
  {
    v51 = 0;
    v52 = 1;
LABEL_20:
    v15 = (unsigned __int8)byte_80EC56E;
    goto LABEL_21;
  }
  v4 = 3;
  if ( v50 )
  {
    v4 = 1;
    v50 = -1;
  }
  v54 = v2;
  v5 = 0;
  v6 = v3;
  v51 = 0;
  v52 = 1;
  v7 = v4;
  while ( 1 )
  {
    v8 = v5 + 1;
    _EAX = 4;
    __asm { cpuid }
    if ( (_EAX & 0x1F) == 0 )
    {
      v3 = v6;
      v2 = v54;
      goto LABEL_20;
    }
    v14 = (unsigned __int8)_EAX >> 5;
    if ( v14 == 2 )
      break;
    if ( v14 == 3 && (v7 & 2) != 0 )
    {
      v7 &= ~2u;
      v50 = (_EAX >> 14) & 0x3FF;
      v52 = (_EDX & 2) != 0;
      goto LABEL_17;
    }
LABEL_18:
    v5 = v8;
  }
  if ( (v7 & 1) == 0 )
    goto LABEL_18;
  v7 &= ~1u;
  v51 = (_EAX >> 14) & 0x3FF;
LABEL_17:
  if ( v7 )
    goto LABEL_18;
  v3 = v6;
  v2 = v54;
  if ( dword_80EC564 <= 10 )
    goto LABEL_61;
  v34 = 1;
  if ( v50 <= 0 )
    v34 = v51 > 0 && v53 == 2;
  v35 = 0;
  v36 = v3;
  v37 = (v51 > 0 && v53 == 3) | (2 * v34);
LABEL_44:
  while ( v37 )
  {
    v38 = v35 + 1;
    _EAX = 11;
    __asm { cpuid }
    v44 = _ECX & 0xFF00;
    if ( !(_BYTE)_EBX || !v44 )
      break;
    if ( v44 == 256 )
    {
      if ( (v37 & 1) != 0 )
      {
        _BitScanReverse(&v46, v51);
        v47 = -1 << (v46 + 1);
        v37 &= ~1u;
        v35 = v38;
        v51 = ((unsigned __int8)_EBX - 1) & ~v47;
        goto LABEL_44;
      }
LABEL_49:
      v35 = v38;
      goto LABEL_44;
    }
    if ( v44 != 512 || (v37 & 2) == 0 )
      goto LABEL_49;
    if ( v53 == 2 )
    {
      _BitScanReverse(&v48, v51);
      v51 = ((unsigned __int8)_EBX - 1) & ~(-1 << (v48 + 1));
    }
    else
    {
      _BitScanReverse(&v45, v50);
      v50 = ((unsigned __int8)_EBX - 1) & ~(-1 << (v45 + 1));
    }
    v37 &= ~2u;
    v35 = v38;
  }
  v3 = v36;
  v2 = v54;
LABEL_61:
  v51 -= (v51 == 0) - 1;
  if ( v50 > 0 )
  {
    if ( v53 == 2 )
      goto LABEL_63;
    v15 = v50 + 1;
    goto LABEL_21;
  }
  if ( v53 != 2 )
  {
    v15 = -1;
    if ( v50 )
      goto LABEL_21;
    goto LABEL_24;
  }
LABEL_63:
  if ( v51 )
  {
    v15 = v51;
    if ( (unsigned int)v51 <= 2 || dword_80EC598 != 6 )
      goto LABEL_21;
    if ( dword_80EC59C != 77 )
    {
      if ( (unsigned int)dword_80EC59C > 0x4D )
      {
        if ( dword_80EC59C != 90 && dword_80EC59C != 93 )
          goto LABEL_21;
      }
      else if ( dword_80EC59C != 55 && dword_80EC59C != 74 )
      {
        goto LABEL_21;
      }
    }
    v15 = 2;
LABEL_21:
    if ( v3 > 0 && v15 )
      v3 /= v15;
LABEL_24:
    if ( !v52 )
    {
      if ( v51 )
        v49 /= v51;
LABEL_27:
      v3 += v49;
    }
  }
  else if ( !v52 )
  {
    goto LABEL_27;
  }
LABEL_28:
  if ( v2 > 0 )
  {
    _x86_raw_data_cache_size = v2;
    _x86_data_cache_size = v2 & 0xFFFFFF00;
    _x86_raw_data_cache_size_half = v2 >> 1;
    _x86_data_cache_size_half = (int)(v2 & 0xFFFFFF00) >> 1;
  }
  if ( v3 > 0 )
  {
    v16 = v3;
    _x86_raw_shared_cache_size = v3;
    v0 = v3 & 0xFFFFFF00;
    _x86_shared_cache_size = v0;
    _x86_raw_shared_cache_size_half = v16 >> 1;
    _x86_shared_cache_size_half = v0 >> 1;
    goto LABEL_4;
  }
LABEL_3:
  v0 = _x86_shared_cache_size;
LABEL_4:
  result = 6 * v0;
  _x86_shared_non_temporal_threshold = 6 * v0;
  return result;
}
// 80EB978: using guessed type int _x86_raw_shared_cache_size;
// 80EB97C: using guessed type int _x86_raw_shared_cache_size_half;
// 80EB980: using guessed type int _x86_shared_cache_size;
// 80EB984: using guessed type int _x86_shared_cache_size_half;
// 80EB988: using guessed type int _x86_raw_data_cache_size;
// 80EB98C: using guessed type int _x86_raw_data_cache_size_half;
// 80EB990: using guessed type int _x86_data_cache_size;
// 80EB994: using guessed type int _x86_data_cache_size_half;
// 80EC560: using guessed type int dl_x86_cpu_features;
// 80EC564: using guessed type int dword_80EC564;
// 80EC56E: using guessed type char byte_80EC56E;
// 80EC577: using guessed type char byte_80EC577;
// 80EC598: using guessed type int dword_80EC598;
// 80EC59C: using guessed type int dword_80EC59C;
// 80ECC40: using guessed type int _x86_shared_non_temporal_threshold;

//----- (0804884F) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  _libc_start_main((int (__cdecl *)(int, char **, char **))main, v2, &retaddr, _libc_csu_init, _libc_csu_fini, a2, &v3);
}
// 8048852: positive sp value 4 has been found

//----- (08048880) --------------------------------------------------------
void _x86_get_pc_thunk_bx()
{
  ;
}

//----- (08048890) --------------------------------------------------------
int deregister_tm_clones()
{
  int result; // eax

  result = &unk_80EBF83 - (_UNKNOWN *)&edata;
  if ( (unsigned int)(&unk_80EBF83 - (_UNKNOWN *)&edata) > 6 )
    return 0;
  return result;
}
// 8048890: could not find valid save-restore pair for ebp
// 80EBF80: using guessed type char edata;

//----- (080488C0) --------------------------------------------------------
int register_tm_clones()
{
  return 0;
}
// 80488C0: could not find valid save-restore pair for ebp

//----- (08048900) --------------------------------------------------------
int (__usercall *__usercall _do_global_dtors_aux@<eax>(long double a1@<st0>))@<eax>(long double a1@<st0>, _DWORD *a2)
{
  int (__usercall *result)@<eax>(long double@<st0>, _DWORD *); // eax

  if ( !edata )
  {
    deregister_tm_clones();
    result = _deregister_frame_info_bases;
    if ( _deregister_frame_info_bases )
      result = (int (__usercall *)@<eax>(long double@<st0>, _DWORD *))_deregister_frame_info_bases(
                                                                        a1,
                                                                        _EH_FRAME_BEGIN__);
    edata = 1;
  }
  return result;
}
// 8048900: could not find valid save-restore pair for ebp
// 80D6B3C: using guessed type _DWORD _EH_FRAME_BEGIN__[19235];
// 80EBF80: using guessed type char edata;

//----- (08048940) --------------------------------------------------------
int frame_dummy()
{
  if ( _register_frame_info_bases )
    _register_frame_info_bases(_EH_FRAME_BEGIN__, object_6066, 0, (int)&GLOBAL_OFFSET_TABLE_);
  return register_tm_clones();
}
// 80D6B3C: using guessed type _DWORD _EH_FRAME_BEGIN__[19235];
// 80EB000: using guessed type int GLOBAL_OFFSET_TABLE_;
// 80EBF84: using guessed type _DWORD object_6066[7];

//----- (080489A0) --------------------------------------------------------
void __cdecl get_flag(int a1, int a2)
{
  int v2; // esi
  unsigned __int8 v3; // al
  int v4; // ecx
  unsigned __int8 v5; // al

  if ( a1 == 814536271 && a2 == 425138641 )
  {
    v2 = fopen("flag.txt", "rt");
    v3 = getc(v2);
    if ( v3 != 255 )
    {
      v4 = (char)v3;
      do
      {
        putchar(v4);
        v5 = getc(v2);
        v4 = (char)v5;
      }
      while ( v5 != 255 );
    }
    fclose(v2);
  }
}
// 804F1D0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 804F610: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 804F7A0: using guessed type _DWORD __cdecl putchar(_DWORD);
// 8051160: using guessed type _DWORD __cdecl getc(_DWORD);

//----- (08048A20) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  long double v3; // fst7
  char v5[56]; // [esp+4h] [ebp-38h] BYREF

  printf(v3, (unsigned int)"Qual a palavrinha magica? ");
  gets(v5);
  return 0;
}
// 8048A2A: variable 'v3' is possibly undefined
// 8048A20: using guessed type char var_38[56];

//----- (08048A50) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __usercall __noreturn generic_start_main(
        int (__cdecl *a1)(int, void **, int, char *)@<eax>,
        int a2@<edx>,
        void **a3@<ecx>,
        long double a4@<st0>,
        void (__cdecl *a5)(int, void **, int, int),
        void (__cdecl *a6)(void *),
        void (__cdecl *lpfunc)(void *),
        int a8)
{
  int v8; // eax
  int v9; // ecx
  int (**v10)(); // esi
  int (***v11)(); // ebx
  int v12; // eax
  int v13; // ecx
  unsigned int v14; // eax
  int v15; // edx
  int v16; // eax
  int v17; // ecx
  char v21[28]; // [esp+14h] [ebp-38h] BYREF
  unsigned int v22; // [esp+30h] [ebp-1Ch]
  unsigned int v23; // [esp+34h] [ebp-18h]

  _libc_multiple_libcs = 0;
  _libc_stack_end = a8;
  v8 = (int)&a3[a2 + 1];
  environ = v8;
  do
    v8 += 4;
  while ( *(_DWORD *)(v8 - 4) );
  dl_aux_init(v8);
  if ( !dl_phdr && &dword_8048000 )
  {
    dl_phdr = 134512692;
    dl_phnum = 6;
  }
  if ( !_libc_multiple_libcs )
  {
    v12 = dl_discover_osversion(v9);
    if ( v12 < 0 )
      _libc_fatal(a4, "FATAL: cannot determine kernel version\n");
    if ( !dl_osversion || dl_osversion > (unsigned int)v12 )
      dl_osversion = v12;
    if ( v12 <= 132639 )
      _libc_fatal(a4, "FATAL: kernel too old\n");
  }
  if ( &off_8048114 < (int (***)())init_proc )
  {
    v10 = &off_80EB044;
    v11 = &off_8048114;
    while ( 1 )
    {
      v11 += 2;
      *v10 = (int (*)())(*v10)();
      if ( v11 >= (int (***)())init_proc )
        break;
      v10 = *v11;
      if ( *((_BYTE *)v11 + 4) != 42 )
        _libc_fatal(a4, "unexpected reloc type in static binary");
    }
  }
  _pthread_initialize_minimal(a4);
  v14 = *(_DWORD *)dl_random;
  LOBYTE(v14) = 0;
  __writegsdword(0x14u, v14);
  __writegsdword(0x18u, *(_DWORD *)(dl_random + 4));
  if ( lpfunc )
    _cxa_atexit(lpfunc, 0, 0);
  _libc_init_first(v13, a4, a2, a3, environ);
  if ( a6 )
    _cxa_atexit(a6, 0, 0);
  if ( _libc_enable_secure )
    _libc_check_standard_fds();
  if ( a5 )
    a5(a2, a3, environ, v15);
  dl_debug_initialize(0, 0);
  if ( setjmp((struct __jmp_buf_tag *)v21) )
  {
    MEMORY[0]();
    if ( _InterlockedDecrement(0) )
    {
      while ( 1 )
        dl_sysinfo(v17);
    }
    v16 = 0;
  }
  else
  {
    v22 = __readgsdword(0x80u);
    v23 = __readgsdword(0x7Cu);
    __writegsdword(0x80u, (unsigned int)v21);
    v16 = a1(a2, a3, environ, v21);
  }
  exit(a4, v16);
}
// 8048A8D: write access to const memory at 80EAFC8 has been detected
// 8048B54: variable 'v9' is possibly undefined
// 8048BD4: variable 'v13' is possibly undefined
// 8048C17: variable 'v15' is possibly undefined
// 8048CAA: variable 'v17' is possibly undefined
// 8048000: using guessed type int dword_8048000;
// 8048114: using guessed type int (**off_8048114)();
// 80EAFC0: using guessed type int dl_random;
// 80EAFC8: using guessed type int _libc_stack_end;
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80EB044: using guessed type int (*off_80EB044)();
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EBD10: using guessed type int _libc_multiple_libcs;
// 80EC524: using guessed type int environ;
// 80ECC90: using guessed type int dl_phdr;
// 80ECCB0: using guessed type int dl_phnum;
// 80ECCC0: using guessed type int dl_osversion;

//----- (08048CD0) --------------------------------------------------------
__int16 __usercall get_common_indeces_constprop_1@<ax>(
        unsigned int _EAX@<eax>,
        int *a2@<edx>,
        unsigned int *a3@<ecx>,
        unsigned int *a4)
{
  _DWORD *v4; // esi
  int v15; // ecx

  if ( _EAX )
  {
    v4 = (_DWORD *)_EAX;
    _EAX = 1;
    __asm { cpuid }
    unk_80EC574 = _EDX;
    dword_80EC570 = _ECX;
    unk_80EC56C = _EBX;
    dword_80EC568 = _EAX;
    *v4 = (_EAX >> 8) & 0xF;
    *a2 = (unsigned __int8)_EAX >> 4;
    *a3 = (_EAX >> 12) & 0xF0;
    *a4 = _EAX & 0xF;
    if ( *v4 == 15 )
    {
      *v4 = (unsigned __int8)(_EAX >> 20) + 15;
      _EAX = *a3;
      *a2 += *a3;
    }
  }
  if ( dword_80EC564 > 6 )
  {
    _EAX = 7;
    __asm { cpuid }
    dword_80EC578 = _EAX;
    dword_80EC57C = _EBX;
    dword_80EC580 = _ECX;
    dword_80EC584 = _EDX;
  }
  if ( (dword_80EC570 & 0x8000000) != 0 )
  {
    __asm { xgetbv }
    if ( (_EAX & 6) == 6 )
    {
      if ( (dword_80EC570 & 0x10000000) != 0 )
        dword_80EC5A0 |= 0x40u;
      if ( (dword_80EC57C & 0x20) != 0 )
        dword_80EC5A0 |= 0x400u;
      _EAX &= 0xE0u;
      if ( _EAX == 224 && (dword_80EC57C & 0x10000) != 0 )
      {
        _EAX = dword_80EC5A0;
        v15 = dword_80EC5A0;
        BYTE1(_EAX) = BYTE1(dword_80EC5A0) | 0x10;
        if ( (dword_80EC57C & 0x20000) != 0 )
        {
          BYTE1(v15) = BYTE1(dword_80EC5A0) | 0x30;
          _EAX = v15;
        }
        dword_80EC5A0 = _EAX;
      }
      if ( (dword_80EC570 & 0x1000) != 0 )
        dword_80EC5A0 |= 0x80u;
    }
  }
  return _EAX;
}
// 80EC564: using guessed type int dword_80EC564;
// 80EC568: using guessed type int dword_80EC568;
// 80EC570: using guessed type int dword_80EC570;
// 80EC578: using guessed type int dword_80EC578;
// 80EC57C: using guessed type int dword_80EC57C;
// 80EC580: using guessed type int dword_80EC580;
// 80EC584: using guessed type int dword_80EC584;
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (08048E00) --------------------------------------------------------
int __cdecl __noreturn _libc_start_main(
        int (__cdecl *main)(int, char **, char **),
        int argc,
        char **ubp_av,
        void (*init)(void),
        void (*fini)(void),
        void (*rtld_fini)(void),
        void *stack_end)
{
  long double v7; // fst7
  int v13; // ecx
  int v14; // edx
  int v15; // eax
  int v26; // eax
  unsigned int v27; // edx
  int v28; // eax
  int v29; // [esp+0h] [ebp-1Ch] BYREF
  unsigned int v30; // [esp+4h] [ebp-18h] BYREF
  unsigned int v31; // [esp+8h] [ebp-14h] BYREF
  unsigned int v32[4]; // [esp+Ch] [ebp-10h] BYREF

  _EAX = 0;
  __asm { cpuid }
  dword_80EC564 = _EAX;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  if ( _ECX != 1818588270 || _EBX != 1970169159 || _EDX != 1231384169 )
  {
    if ( _ECX == 1145913699 && _EBX == 1752462657 && _EDX == 1769238117 )
    {
      get_common_indeces_constprop_1((unsigned int)&v29, (int *)&v30, v32, &v31);
      _EAX = 0x80000000;
      __asm { cpuid }
      if ( _EAX > 0x80000000 )
      {
        _EAX = -2147483647;
        __asm { cpuid }
        dword_80EC588 = _EAX;
        dword_80EC58C = _EBX;
        dword_80EC590 = _ECX;
        dword_80EC594 = _EDX;
      }
      v26 = dword_80EC5A0;
      if ( (dword_80EC5A0 & 0x40) != 0 && (dword_80EC590 & 0x10000) != 0 )
      {
        BYTE1(v26) = BYTE1(dword_80EC5A0) | 1;
        dword_80EC5A0 = v26;
      }
      v13 = v30;
      if ( v29 == 21 && v30 - 96 <= 0x1F )
        dword_80EC5A0 |= 0x12u;
      v14 = 2;
    }
    else
    {
      get_common_indeces_constprop_1(0, 0, 0, 0);
      v13 = v30;
      v14 = 3;
    }
    goto LABEL_6;
  }
  get_common_indeces_constprop_1((unsigned int)&v29, (int *)&v30, v32, &v31);
  if ( v29 != 6 )
  {
    v15 = dword_80EC5A0;
LABEL_21:
    if ( (v15 & 0x400) != 0 )
    {
      BYTE1(v15) |= 8u;
      dword_80EC5A0 = v15;
    }
    v14 = 1;
    v13 = v30;
LABEL_6:
    if ( (byte_80EC575[0] & 1) != 0 )
      dword_80EC5A0 |= 0x4000u;
    if ( byte_80EC575[0] < 0 )
      dword_80EC5A0 |= 0x8000u;
    if ( v14 != 1 || v29 != 6 )
      goto LABEL_11;
    if ( v13 != 63 )
    {
      if ( v13 == 60 )
      {
        if ( v31 <= 3 )
          goto LABEL_32;
        goto LABEL_11;
      }
      if ( (unsigned int)(v13 - 69) <= 1 )
        goto LABEL_31;
      if ( v13 == 61 )
      {
        if ( v31 > 4 )
          goto LABEL_11;
LABEL_32:
        dword_80EC57C &= 0xFFFFF7EF;
        goto LABEL_11;
      }
      if ( v13 == 71 )
      {
LABEL_31:
        if ( v31 > 1 )
          goto LABEL_11;
        goto LABEL_32;
      }
      if ( v13 != 86 )
        goto LABEL_11;
    }
    if ( v31 <= 2 )
      goto LABEL_32;
LABEL_11:
    dword_80EC59C = v13;
    dl_x86_cpu_features = v14;
    dword_80EC598 = v29;
    generic_start_main(
      (int (__cdecl *)(int, void **, int, char *))main,
      argc,
      (void **)ubp_av,
      v7,
      (void (__cdecl *)(int, void **, int, int))init,
      (void (__cdecl *)(void *))fini,
      (void (__cdecl *)(void *))rtld_fini,
      (int)stack_end);
  }
  v27 = v30 + v32[0];
  v30 += v32[0];
  if ( v30 <= 0x2F )
  {
    if ( v27 >= 0x2E )
      goto LABEL_58;
    if ( v27 > 0x1F )
    {
      if ( v27 == 38 )
        goto LABEL_43;
      if ( v27 == 44 || v27 == 37 )
      {
LABEL_58:
        v15 = dword_80EC5A0 | 0x40031;
        dword_80EC5A0 |= 0x40031u;
        goto LABEL_21;
      }
    }
    else
    {
      if ( v27 >= 0x1E || v27 == 26 )
        goto LABEL_58;
      if ( v27 == 28 )
      {
LABEL_43:
        v15 = dword_80EC5A0 | 4;
        dword_80EC5A0 |= 4u;
        goto LABEL_21;
      }
    }
LABEL_57:
    v15 = dword_80EC5A0;
    if ( (dword_80EC570 & 0x10000000) == 0 )
      goto LABEL_21;
    goto LABEL_58;
  }
  if ( v27 == 87 )
  {
    v28 = dword_80EC5A0 | 0x20000;
    goto LABEL_53;
  }
  if ( v27 <= 0x57 )
  {
    if ( v27 != 74 )
    {
      if ( v27 <= 0x4A )
      {
        v28 = dword_80EC5A0;
        if ( v27 != 55 )
          goto LABEL_57;
        goto LABEL_53;
      }
      if ( v27 - 76 > 1 )
        goto LABEL_57;
    }
    v28 = dword_80EC5A0;
    goto LABEL_53;
  }
  v28 = dword_80EC5A0;
  if ( v27 > 0x5D )
  {
    if ( v27 != 95 )
      goto LABEL_57;
  }
  else if ( v27 < 0x5C && v27 != 90 )
  {
    goto LABEL_57;
  }
LABEL_53:
  v15 = v28 | 0x40230;
  dword_80EC5A0 = v15;
  goto LABEL_21;
}
// 8048EDF: variable 'v7' is possibly undefined
// 80EC560: using guessed type int dl_x86_cpu_features;
// 80EC564: using guessed type int dword_80EC564;
// 80EC570: using guessed type int dword_80EC570;
// 80EC57C: using guessed type int dword_80EC57C;
// 80EC588: using guessed type int dword_80EC588;
// 80EC58C: using guessed type int dword_80EC58C;
// 80EC590: using guessed type int dword_80EC590;
// 80EC594: using guessed type int dword_80EC594;
// 80EC598: using guessed type int dword_80EC598;
// 80EC59C: using guessed type int dword_80EC59C;
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (08049110) --------------------------------------------------------
int __usercall check_one_fd@<eax>(int a1@<eax>, int a2@<edx>)
{
  int result; // eax
  int v4; // edi
  unsigned int v5; // eax
  char v7[16]; // [esp+18h] [ebp-7Ch] BYREF
  int v8; // [esp+28h] [ebp-6Ch]
  __int64 v9; // [esp+38h] [ebp-5Ch]

  result = fcntl(a1, 1);
  if ( result == -1 )
  {
    result = -24;
    if ( __readgsdword(0xFFFFFFE8) == 9 )
    {
      if ( (a2 & 3) == 1 )
        v4 = 263;
      else
        v4 = 259;
      v5 = dl_sysinfo(a2);
      if ( v5 > 0xFFFFF000 )
        v5 = _syscall_error(v5);
      if ( a1 != v5 || _fxstat64(3, a1, (int)v7) || (v8 & 0xF000) != 0x2000 || (result = v9 ^ v4, v9 != v4) )
        __halt();
    }
  }
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 8049110: using guessed type char var_7C[16];

//----- (080491D0) --------------------------------------------------------
int _libc_check_standard_fds()
{
  check_one_fd(0, 131073);
  check_one_fd(1, 0x20000);
  return check_one_fd(2, 0x20000);
}

//----- (08049200) --------------------------------------------------------
int __usercall _libc_setup_tls@<eax>(long double a1@<st0>, int a2, unsigned int a3)
{
  _DWORD *v3; // eax
  unsigned int v4; // esi
  unsigned int v5; // edx
  unsigned int v6; // ebp
  unsigned int v7; // ebx
  int v8; // eax
  _DWORD *v9; // edi
  unsigned int v10; // ecx
  unsigned int v11; // eax
  _DWORD *v12; // ebx
  __int64 (__fastcall *v13)(_DWORD); // eax
  int v14; // ecx
  int result; // eax
  unsigned int v16; // [esp+Ch] [ebp-40h]
  int v17; // [esp+10h] [ebp-3Ch]
  unsigned int v18; // [esp+14h] [ebp-38h]
  _BYTE *v19; // [esp+18h] [ebp-34h]
  int v20; // [esp+1Ch] [ebp-30h]

  v3 = (_DWORD *)dl_phdr;
  v4 = a3;
  if ( dl_phdr && (v5 = dl_phdr + 32 * dl_phnum, dl_phdr < v5) )
  {
    while ( *v3 != 7 )
    {
      v3 += 8;
      if ( (unsigned int)v3 >= v5 )
        goto LABEL_9;
    }
    v6 = v3[7];
    v16 = v3[5];
    if ( a3 < v6 )
      v4 = v3[7];
    v18 = v3[4];
    v19 = (_BYTE *)v3[2];
  }
  else
  {
LABEL_9:
    v6 = 0;
    v19 = 0;
    v18 = 0;
    v16 = 0;
  }
  v7 = v4 * ((v4 + v16 + dl_tls_static_size - 1) / v4);
  v8 = sbrk(v7 + v4 + a2);
  dl_static_dtv = 62;
  v9 = dl_ns;
  v10 = 1;
  v17 = -v4 & (v8 + v4 - 1);
  v11 = v16;
  if ( v6 )
  {
    v11 = v16 + v6 - 1;
    v10 = v6;
  }
  byte_80ECA34 = 1;
  v20 = v11 / v10 * v10;
  *((_DWORD *)dl_ns + 144) = v20;
  dword_80ECA30 = v17 + v7 - v20;
  memcpy((_BYTE *)dword_80ECA30, v19, v18);
  v12 = (_DWORD *)(v17 + v7);
  v13 = dl_sysinfo;
  v12[1] = &unk_80ECA28;
  *v12 = v12;
  v12[2] = v12;
  v12[4] = v13;
  if ( (unsigned int)dl_sysinfo(v14) )
    _libc_fatal(a1, "set_thread_area failed when setting up thread-local storage\n");
  v9[142] = v6;
  v9[145] = 1;
  dword_80EBFB4 = (int)v9;
  static_slotinfo = 64;
  v9[139] = v19;
  v9[141] = v16;
  dl_tls_max_dtv_idx = 1;
  dl_tls_dtv_slotinfo_list = (int)&static_slotinfo;
  v9[140] = v18;
  dl_tls_static_used = v20;
  dl_tls_static_nelem = 1;
  dl_tls_static_size = ((v20 + dl_tls_static_size + 63) & 0xFFFFFFC0) + 1216;
  result = 64;
  if ( v4 < 0x40 )
    v4 = 64;
  dl_tls_static_align = v4;
  return result;
}
// 8049342: variable 'v14' is possibly undefined
// 80EB068: using guessed type int dl_tls_static_size;
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EBA40: using guessed type void *dl_ns;
// 80EBFA0: using guessed type int static_slotinfo;
// 80EBFB4: using guessed type int dword_80EBFB4;
// 80ECA00: using guessed type int dl_tls_static_used;
// 80ECA04: using guessed type int dl_tls_static_align;
// 80ECA08: using guessed type int dl_tls_max_dtv_idx;
// 80ECA20: using guessed type int dl_static_dtv;
// 80ECA30: using guessed type int dword_80ECA30;
// 80ECA34: using guessed type char byte_80ECA34;
// 80ECC20: using guessed type int dl_tls_dtv_slotinfo_list;
// 80ECC2C: using guessed type int dl_tls_static_nelem;
// 80ECC90: using guessed type int dl_phdr;
// 80ECCB0: using guessed type int dl_phnum;

//----- (08049410) --------------------------------------------------------
int dl_tls_setup()
{
  static_slotinfo = 64;
  dl_tls_max_dtv_idx = 1;
  dl_tls_dtv_slotinfo_list = (int)&static_slotinfo;
  dl_tls_static_used = 1216;
  dl_tls_static_align = 64;
  dl_tls_static_nelem = 1;
  dl_tls_static_size = ((dl_tls_static_size + 1279) & 0xFFFFFFC0) + 1216;
  return 0;
}
// 80EB068: using guessed type int dl_tls_static_size;
// 80EBFA0: using guessed type int static_slotinfo;
// 80ECA00: using guessed type int dl_tls_static_used;
// 80ECA04: using guessed type int dl_tls_static_align;
// 80ECA08: using guessed type int dl_tls_max_dtv_idx;
// 80ECC20: using guessed type int dl_tls_dtv_slotinfo_list;
// 80ECC2C: using guessed type int dl_tls_static_nelem;

//----- (08049470) --------------------------------------------------------
int __usercall _pthread_initialize_minimal@<eax>(long double a1@<st0>)
{
  return _libc_setup_tls(a1, 1216, 0x40u);
}

//----- (08049490) --------------------------------------------------------
void _libc_csu_init(void)
{
  int v0; // ebp

  init_proc();
  v0 = 0;
  if ( _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry )
  {
    do
      _frame_dummy_init_array_entry[v0++]();
    while ( _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry != v0 );
  }
}
// 80EAF6C: using guessed type int (*_frame_dummy_init_array_entry[4])();
// 80EAF74: using guessed type int (*_do_global_dtors_aux_fini_array_entry[2])();

//----- (08049530) --------------------------------------------------------
void _libc_csu_fini(void)
{
  int i; // ebx

  for ( i = (&_JCR_LIST__ - (_UNKNOWN *)_do_global_dtors_aux_fini_array_entry) >> 2; i; --i )
    funcs_8049550[i]();
  term_proc();
}
// 80EAF70: using guessed type int (*funcs_8049550[3])();
// 80EAF74: using guessed type int (*_do_global_dtors_aux_fini_array_entry[2])();

//----- (08049570) --------------------------------------------------------
void __usercall __noreturn _assert_fail_base(long double a1@<st0>, unsigned int a2, int a3, int a4, int a5, void *a6)
{
  void *v6; // ebx
  char *v7; // ecx
  char *v8; // eax
  _DWORD *v9; // eax
  __int32 v10; // ebx
  int *v11; // eax
  int v12; // ecx
  long double v13; // [esp-8h] [ebp-24h]
  int v14; // [esp+8h] [ebp-14h] BYREF
  int v15[4]; // [esp+Ch] [ebp-10h] BYREF

  v6 = a6;
  v7 = ": ";
  if ( !a6 )
  {
    v7 = (char *)&unk_80CFAB1;
    v6 = &unk_80CFAB1;
  }
  v8 = ": ";
  if ( !*(_BYTE *)program_invocation_short_name )
    v8 = (char *)&unk_80CFAB1;
  if ( asprintf(a1, &v14, a2, program_invocation_short_name, v8, a4, a5, v6, v7, a3, v15) < 0 )
  {
    write(2, (int)"Unexpected error.\n", 18);
  }
  else
  {
    LODWORD(v13) = v14;
    _fxprintf(a1, 0, "%s", v13);
    fflush(stderr);
    v15[0] = -dl_pagesize & (dl_pagesize + v15[0]);
    v9 = (_DWORD *)mmap(0, v15[0], 3, 34, -1, 0);
    v10 = (__int32)v9;
    if ( v9 != (_DWORD *)-1 )
    {
      *v9 = v15[0];
      j_strcpy(v9 + 1, v14);
      v11 = (int *)_InterlockedExchange(&_abort_msg, v10);
      if ( v11 )
        munmap((int)v11, *v11);
    }
    free(v14);
  }
  abort(v12);
}
// 80495F0: variable 'v13' is possibly undefined
// 8049671: variable 'v12' is possibly undefined
// 80481B0: using guessed type int __cdecl j_strcpy(_DWORD, _DWORD);
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EB4B4: using guessed type int *stderr;
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80EBA08: using guessed type int dl_pagesize;
// 80EC268: using guessed type int _abort_msg;
// 8049570: using guessed type int var_10[4];

//----- (080496A0) --------------------------------------------------------
void __usercall __noreturn _assert_fail(long double a1@<st0>, int a2, int a3, int a4, void *a5)
{
  unsigned int v5; // eax

  v5 = dcgettext(a1, "libc", "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", 5u);
  _assert_fail_base(a1, v5, a2, a3, a4, a5);
}

//----- (080496D0) --------------------------------------------------------
unsigned int __usercall dcgettext@<eax>(long double a1@<st0>, char *a2, unsigned __int8 *a3, unsigned int a4)
{
  return _dcigettext(a1, a2, a3, 0, 0, 0, a4);
}

//----- (080496F0) --------------------------------------------------------
int __usercall plural_eval@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int *v3; // ebx
  int v5; // edx
  bool v6; // cc
  int v7; // ecx
  int v9; // eax
  int v10; // ecx
  int v11; // ebp
  unsigned int v12; // edi
  int v13; // ecx
  int v14; // eax
  unsigned int v15; // eax

  v3 = a1;
  v5 = *a1;
  v6 = *a1 <= 1;
  if ( *a1 == 1 )
    return plural_eval(a3, a2) == 0;
  while ( !v6 )
  {
    if ( v5 == 2 )
    {
      v9 = plural_eval(a3, a2);
      v11 = v3[1];
      v12 = v9;
      if ( v11 == 15 )
      {
        v13 = 1;
        if ( !v9 )
          goto LABEL_18;
      }
      else
      {
        if ( v11 != 14 )
        {
          v15 = plural_eval(v10, a2);
          switch ( v11 )
          {
            case 3:
              return v15 * v12;
            case 4:
              return v12 / v15;
            case 5:
              return v12 % v15;
            case 6:
              return v12 + v15;
            case 7:
              return v12 - v15;
            case 8:
              return v12 < v15;
            case 9:
              return v12 > v15;
            case 10:
              return v12 <= v15;
            case 11:
              return v12 >= v15;
            case 12:
              LOBYTE(v13) = v12 == v15;
              return (unsigned __int8)v13;
            case 13:
              return v12 != v15;
            default:
              return 0;
          }
        }
        v13 = 0;
        if ( !v9 )
          return (unsigned __int8)v13;
LABEL_18:
        LOBYTE(v13) = plural_eval(v13, a2) != 0;
      }
      return (unsigned __int8)v13;
    }
    if ( v5 != 3 )
      return 0;
    v3 = (int *)v3[(plural_eval(a3, a2) == 0) + 3];
    v5 = *v3;
    v6 = *v3 <= 1;
    if ( *v3 == 1 )
      return plural_eval(a3, a2) == 0;
  }
  if ( v5 )
    return 0;
  v14 = v3[1];
  v7 = a2;
  if ( !v14 )
    return v7;
  if ( v14 == 1 )
    return v3[2];
  return 0;
}
// 8049717: variable 'a3' is possibly undefined
// 80497D8: variable 'v10' is possibly undefined

//----- (08049870) --------------------------------------------------------
unsigned int __userpurge plural_lookup@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  int v5; // ebx
  unsigned int v6; // eax
  unsigned int v7; // edi
  unsigned int result; // eax

  v5 = *(_DWORD *)(a1 + 8);
  v6 = plural_eval(*(int **)(v5 + 96), a2, a3);
  if ( v6 >= *(_DWORD *)(v5 + 100) )
    return a3;
  v7 = v6;
  result = a3;
  while ( --v7 != -1 )
  {
    result = j_rawmemchr(result, 0) + 1;
    if ( result >= a3 + a4 )
      return a3;
  }
  return result;
}
// 80481E0: using guessed type int __cdecl j_rawmemchr(_DWORD, _DWORD);

//----- (080498C0) --------------------------------------------------------
int __cdecl transcmp(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // edx
  _DWORD *v3; // eax
  int result; // eax

  if ( a2[4] )
    v2 = a2 + 7;
  else
    v2 = (_DWORD *)a2[7];
  if ( a1[4] )
    v3 = a1 + 7;
  else
    v3 = (_DWORD *)a1[7];
  result = j_strcmp(v3, v2);
  if ( !result )
  {
    result = j_strcmp(*a1, *a2);
    if ( !result )
    {
      result = j_strcmp(a1[2], a2[2]);
      if ( !result )
        return a1[1] - a2[1];
    }
  }
  return result;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);

//----- (08049940) --------------------------------------------------------
int __userpurge nl_find_msg@<eax>(int *a1@<eax>, int a2@<edx>, unsigned __int8 *a3@<ecx>, int a4, unsigned int *a5)
{
  int v5; // ecx
  _BYTE *v6; // edi
  int v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // ecx
  unsigned int v11; // ebx
  char *v12; // edx
  char *v13; // edx
  unsigned int *v14; // eax
  int v15; // ecx
  unsigned __int32 v16; // eax
  int v17; // eax
  char *v18; // eax
  unsigned int v19; // esi
  unsigned int v20; // esi
  unsigned int *v21; // eax
  int v23; // eax
  int v24; // edx
  unsigned int *v25; // ecx
  int v26; // edx
  int v27; // ecx
  int v28; // edi
  _DWORD *v29; // esi
  _BYTE *v30; // ebx
  int v31; // eax
  _DWORD *v32; // eax
  unsigned __int8 *v33; // edi
  unsigned int v34; // eax
  int v35; // edx
  char *v36; // ebx
  unsigned int v37; // edi
  _BYTE *v38; // eax
  int v39; // ecx
  int v40; // ebx
  unsigned int v41; // eax
  int v42; // eax
  unsigned int *v43; // eax
  unsigned __int8 *v44; // edx
  unsigned int v45; // eax
  _DWORD *v46; // edx
  int v47; // ebx
  _BYTE *v48; // edi
  char *v49; // ebx
  bool v51; // zf
  unsigned int v52; // edx
  int v53; // ebx
  int *v54; // esi
  int *v55; // eax
  int v56; // eax
  int v57; // edx
  _BYTE *v58; // eax
  bool v60; // zf
  _BYTE *v61; // edx
  char *v62; // eax
  _BYTE *v63; // edx
  char *msg; // eax
  int v65; // eax
  _BYTE *v66; // ebx
  unsigned int v67; // eax
  void *v68; // esp
  unsigned int v69; // ebx
  char *i; // eax
  char v71; // dl
  char *v72; // ecx
  int v73; // edx
  void *v74; // esp
  char *v75; // eax
  unsigned int v76; // ebx
  char *j; // eax
  char v78; // dl
  char *v79; // ecx
  void *v80; // esp
  char *v81; // edx
  int v82; // eax
  _BYTE *v83; // eax
  int v84; // eax
  char *v85; // eax
  int v86; // edx
  int v87; // eax
  _BYTE *v88; // edi
  unsigned int v89; // esi
  char *v90; // ecx
  unsigned int v91; // eax
  int v92; // ecx
  int v93; // eax
  _BYTE *v94; // edi
  _BYTE *v95; // [esp-Ch] [ebp-64h]
  char v96[4]; // [esp+0h] [ebp-58h] BYREF
  int v97; // [esp+4h] [ebp-54h]
  int v98; // [esp+8h] [ebp-50h]
  int *v99; // [esp+Ch] [ebp-4Ch]
  char *v100; // [esp+10h] [ebp-48h]
  char *v101; // [esp+14h] [ebp-44h]
  unsigned int v102; // [esp+18h] [ebp-40h]
  _BYTE *v103; // [esp+1Ch] [ebp-3Ch]
  unsigned int v104; // [esp+20h] [ebp-38h]
  char *v105; // [esp+24h] [ebp-34h]
  unsigned __int8 *v106; // [esp+28h] [ebp-30h]
  unsigned int v107; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *v108; // [esp+34h] [ebp-24h] BYREF
  _DWORD *v109; // [esp+38h] [ebp-20h] BYREF
  _DWORD v110[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  v106 = a3;
  v5 = a1[1];
  v99 = a1;
  v98 = a2;
  if ( v5 <= 0 )
    nl_load_domain(a1, a2);
  v6 = (_BYTE *)v99[2];
  if ( !v6 )
    return 0;
  v7 = *((_DWORD *)v6 + 12);
  v8 = *((_DWORD *)v6 + 5);
  v107 = v8;
  if ( v7 )
  {
    v104 = strlen(v106);
    v9 = _hash_string(v106);
    v10 = *((_DWORD *)v6 + 11);
    v11 = v9 % v10;
    v12 = (char *)*((_DWORD *)v6 + 13);
    v103 = (_BYTE *)(v9 % (v10 - 2) + 1);
    v105 = v12;
    v102 = v10 - (_DWORD)v103;
    v13 = (char *)*((_DWORD *)v6 + 12);
    v101 = &v103[-v10];
    while ( 1 )
    {
      v19 = *(_DWORD *)&v13[4 * v11];
      if ( v105 )
        v19 = _byteswap_ulong(v19);
      if ( !v19 )
        return 0;
      v20 = v19 - 1;
      if ( v107 > v20 )
      {
        v14 = (unsigned int *)(*((_DWORD *)v6 + 6) + 8 * v20);
        if ( *((_DWORD *)v6 + 3) )
        {
          if ( v104 > _byteswap_ulong(*v14) )
            goto LABEL_11;
          v15 = *(_DWORD *)v6;
          v16 = _byteswap_ulong(v14[1]);
        }
        else
        {
          if ( v104 > *v14 )
            goto LABEL_11;
          v15 = *(_DWORD *)v6;
          v16 = v14[1];
        }
        v100 = v13;
        v17 = j_strcmp(v106, v15 + v16);
      }
      else
      {
        v21 = (unsigned int *)(*((_DWORD *)v6 + 9) + 8 * (v20 - v107));
        if ( v104 >= *v21 )
          goto LABEL_11;
        v100 = v13;
        v17 = j_strcmp(v106, v21[1]);
      }
      v13 = v100;
      if ( !v17 )
        goto LABEL_29;
LABEL_11:
      v18 = &v101[v11];
      if ( v11 < v102 )
        v18 = &v103[v11];
      v11 = (unsigned int)v18;
    }
  }
  v35 = (int)v6;
  v36 = 0;
  v37 = v8;
  while ( 1 )
  {
    if ( v37 <= (unsigned int)v36 )
      return 0;
    v38 = *(_BYTE **)v35;
    v39 = *(_DWORD *)(v35 + 24);
    v105 = v36;
    v102 = v35;
    v103 = v38;
    v40 = v39;
    v104 = *(_DWORD *)(v35 + 12);
    while ( 1 )
    {
      v20 = (unsigned int)&v105[v37] >> 1;
      v41 = *(_DWORD *)(v40 + 8 * v20 + 4);
      if ( v104 )
        v41 = _byteswap_ulong(v41);
      v42 = j_strcmp(v106, &v103[v41]);
      if ( v42 >= 0 )
        break;
      v37 = (unsigned int)&v105[v37] >> 1;
      if ( (unsigned int)v105 >= v20 )
        return 0;
    }
    v35 = v102;
    if ( !v42 )
      break;
    v36 = (char *)(v20 + 1);
  }
  v6 = (_BYTE *)v102;
LABEL_29:
  if ( v20 >= v107 )
  {
    v43 = (unsigned int *)(*((_DWORD *)v6 + 10) + 8 * (v20 - v107));
    v44 = (unsigned __int8 *)v43[1];
    v45 = *v43;
    v106 = v44;
    v104 = v45;
  }
  else
  {
    v23 = *(_DWORD *)v6;
    v24 = *((_DWORD *)v6 + 7);
    if ( *((_DWORD *)v6 + 3) )
    {
      v25 = (unsigned int *)(v24 + 8 * v20);
      v106 = (unsigned __int8 *)(_byteswap_ulong(v25[1]) + v23);
      v104 = _byteswap_ulong(*v25) + 1;
      if ( !a4 )
        goto LABEL_56;
      goto LABEL_32;
    }
    v46 = (_DWORD *)(v24 + 8 * v20);
    v106 = (unsigned __int8 *)(v46[1] + v23);
    v104 = *v46 + 1;
  }
  if ( !a4 )
    goto LABEL_56;
LABEL_32:
  if ( !v98 || (v105 = *(char **)(v98 + 8)) == 0 )
  {
    v49 = (char *)output_charset_cache_9803;
    if ( !output_charset_cached_9804 )
    {
      v58 = (_BYTE *)getenv("OUTPUT_CHARSET");
      if ( v58 && *v58 )
      {
        v103 = v58;
        v105 = (char *)(strlen(v58) + 1);
        v85 = (char *)malloc(v105);
        v49 = v85;
        if ( v85 )
          memcpy(v85, v103, (unsigned int)v105);
        output_charset_cache_9803 = (int)v49;
      }
      else
      {
        v49 = (char *)output_charset_cache_9803;
      }
      output_charset_cached_9804 = 1;
    }
    v105 = v49;
    if ( !v49 )
      v105 = *(char **)(*(_DWORD *)__readgsdword(0xFFFFFFD8) + 92);
  }
  v26 = *((_DWORD *)v6 + 15);
  if ( v26 )
  {
    v27 = *((_DWORD *)v6 + 14);
    v103 = (_BYTE *)v20;
    v102 = (unsigned int)v6;
    v28 = v26;
    v29 = (_DWORD *)(v27 + 12 * v26 - 12);
    while ( 1 )
    {
      --v28;
      v30 = v29;
      if ( !j_strcmp(*v29, v105) )
        break;
      v29 -= 3;
      if ( !v28 )
      {
        v20 = (unsigned int)v103;
        v6 = (_BYTE *)v102;
        goto LABEL_59;
      }
    }
    v20 = (unsigned int)v103;
    v6 = (_BYTE *)v102;
    v103 = v30;
    v102 = 0;
  }
  else
  {
LABEL_59:
    v103 = 0;
    v102 = 0;
    v47 = *((_DWORD *)v6 + 15);
    if ( v47 )
    {
      v103 = (_BYTE *)*((_DWORD *)v6 + 14);
      v100 = v6;
      v101 = (char *)v20;
      v97 = v47;
      v48 = &v103[12 * v47 - 12];
      while ( 1 )
      {
        --v47;
        if ( !j_strcmp(*(_DWORD *)v48, v105) )
          break;
        v48 -= 12;
        if ( !v47 )
        {
          v20 = (unsigned int)v101;
          v6 = v100;
          v47 = v97;
          goto LABEL_105;
        }
      }
      v103 = v48;
      v20 = (unsigned int)v101;
      v6 = v100;
    }
    else
    {
      v103 = (_BYTE *)*((_DWORD *)v6 + 14);
LABEL_105:
      if ( v103 )
        v61 = (_BYTE *)realloc(v103, 4 * (3 * v47 + 3));
      else
        v61 = (_BYTE *)malloc(4 * (3 * v47 + 3));
      if ( !v61 || (*((_DWORD *)v6 + 14) = v61, v103 = v61, (v62 = strdup(v105)) == 0) )
      {
        if ( v102 )
        {
          MEMORY[0](v6 + 64);
          return -1;
        }
        return -1;
      }
      v105 = v62;
      v63 = &v103[12 * v47];
      v103 = v63;
      *(_DWORD *)v63 = v62;
      *((_DWORD *)v63 + 1) = -1;
      msg = (char *)nl_find_msg(0, v110);
      if ( msg == (char *)-1 )
        return -1;
      if ( msg )
      {
        v65 = strstr(msg, "charset=");
        if ( v65 )
        {
          v66 = (_BYTE *)(v65 + 8);
          v67 = j_strcspn(v65 + 8, " \t\n");
          v68 = alloca(v67 + 16);
          v95 = v66;
          v69 = 0;
          v101 = v96;
          *(_BYTE *)mempcpy(v96, v95, v67) = 0;
          for ( i = v105; ; ++i )
          {
            v71 = *i;
            if ( !*i )
              break;
            v69 += v71 == 47;
          }
          v72 = v105;
          v73 = *v105;
          v74 = alloca(i - v105 + 26);
          v75 = v96;
          v100 = v96;
          if ( (_BYTE)v73 )
          {
            v99 = (int *)v69;
            do
            {
              ++v75;
              ++v72;
              *(v75 - 1) = dword_80C1B40[v73];
              v73 = *v72;
            }
            while ( (_BYTE)v73 );
            v69 = (unsigned int)v99;
          }
          else
          {
            v75 = v100;
          }
          if ( v69 <= 1 )
          {
            *v75 = 47;
            if ( v69 )
            {
              ++v75;
            }
            else
            {
              v75[1] = 47;
              v75 = (char *)mempcpy(v75 + 2, "TRANSLIT", 8u);
            }
          }
          *v75 = 0;
          v76 = 0;
          for ( j = v101; ; ++j )
          {
            v78 = *j;
            if ( !*j )
              break;
            v76 += v78 == 47;
          }
          v79 = v101;
          v80 = alloca(j - v101 + 18);
          v81 = v96;
          v101 = v96;
          v82 = *v79;
          if ( (_BYTE)v82 )
          {
            v99 = (int *)v76;
            do
            {
              ++v81;
              ++v79;
              *(v81 - 1) = dword_80C1B40[v82];
              v82 = *v79;
            }
            while ( (_BYTE)v82 );
            v76 = (unsigned int)v99;
          }
          else
          {
            v81 = v101;
          }
          if ( v76 <= 1 )
          {
            *v81 = 47;
            if ( v76 )
            {
              ++v81;
            }
            else
            {
              v81[1] = 47;
              v81 += 2;
            }
          }
          v83 = v103;
          *v81 = 0;
          v84 = _gconv_open(v100, (int)v101, (_DWORD *)v83 + 1, 1);
          if ( v84 )
          {
            if ( v84 != -1 )
            {
              if ( v102 )
                MEMORY[0](v6 + 64);
              free(v105);
              return 0;
            }
            *((_DWORD *)v103 + 1) = -1;
          }
        }
      }
      *((_DWORD *)v103 + 2) = 0;
      ++*((_DWORD *)v6 + 15);
    }
    if ( v102 )
      MEMORY[0](v6 + 64);
  }
  if ( *((_DWORD *)v103 + 1) == -1 )
    goto LABEL_56;
  v31 = *((_DWORD *)v103 + 2);
  if ( v31 )
  {
LABEL_41:
    if ( v31 != -1 )
    {
      v32 = *(_DWORD **)(v31 + 4 * v20);
      if ( v32 )
        goto LABEL_43;
      _ECX = 1;
      v51 = __readgsdword(0xCu) == 0;
      if ( !v51 )
        __asm { lock }
      __asm { cmpxchg ds:lock_9743, ecx }
      if ( !v51 )
        _lll_lock_wait_private(0, &lock_9743);
      goto LABEL_79;
    }
    return -1;
  }
  _ECX = 1;
  v60 = __readgsdword(0xCu) == 0;
  if ( !v60 )
    __asm { lock }
  __asm { cmpxchg ds:lock_9743, ecx }
  if ( !v60 )
    _lll_lock_wait_private(0, &lock_9743);
  if ( *((_DWORD *)v103 + 2) )
  {
LABEL_99:
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --lock_9743 )
      _lll_unlock_wake_private(&lock_9743);
    v31 = *((_DWORD *)v103 + 2);
    goto LABEL_41;
  }
  v93 = calloc(*((_DWORD *)v6 + 8) + v107, 4u);
  v94 = v103;
  *((_DWORD *)v103 + 2) = v93;
  if ( !v93 )
  {
    *((_DWORD *)v94 + 2) = -1;
    goto LABEL_99;
  }
LABEL_79:
  v52 = freemem_size_9752;
  v53 = 0;
  v107 = v20;
  v108 = v106;
  v109 = (_DWORD *)(freemem_9751 + 4);
  while ( 1 )
  {
    if ( v52 <= 3 )
      goto LABEL_80;
    v56 = _gconv(*((int **)v103 + 1), (int *)&v108, (unsigned int)&v108[v104], (int *)&v109, (int)v109 + v52 - 4, v110);
    if ( (v56 & 0xFFFFFFFB) == 0 )
      break;
    if ( v56 != 5 )
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --lock_9743 )
        _lll_unlock_wake_private(&lock_9743);
      return 0;
    }
    v108 = v106;
LABEL_80:
    if ( v53 )
    {
      ++v53;
      v54 = (int *)transmem_list;
      freemem_size_9752 = 4080 * v53;
      v55 = (int *)realloc((_BYTE *)transmem_list, 4080 * v53);
      if ( !v55 )
      {
        transmem_list = *v54;
        free(v54);
LABEL_70:
        freemem_9751 = 0;
        freemem_size_9752 = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --lock_9743 )
          _lll_unlock_wake_private(&lock_9743);
        return -1;
      }
      v52 = 4080 * v53 - 4;
      transmem_list = (int)v55;
    }
    else
    {
      freemem_size_9752 = 4080;
      v55 = (int *)malloc(4080);
      if ( !v55 )
        goto LABEL_70;
      v57 = transmem_list;
      v53 = 1;
      transmem_list = (int)v55;
      *v55 = v57;
      v52 = 4076;
    }
    freemem_size_9752 = v52;
    v109 = v55 + 2;
    freemem_9751 = (int)(v55 + 1);
  }
  v86 = (int)v109;
  v87 = freemem_9751;
  v88 = v103;
  v89 = v107;
  v90 = (char *)v109 - freemem_9751;
  *(_DWORD *)freemem_9751 = (char *)v109 - freemem_9751 - 4;
  *(_DWORD *)(*((_DWORD *)v88 + 2) + 4 * v89) = v87;
  v91 = (freemem_size_9752 - (_DWORD)v90) & 0xFFFFFFFC;
  v92 = ((_BYTE)freemem_size_9752 - (_BYTE)v90) & 3;
  freemem_size_9752 = v91;
  freemem_9751 = v92 + v86;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --lock_9743 )
    _lll_unlock_wake_private(&lock_9743);
  v32 = *(_DWORD **)(*((_DWORD *)v88 + 2) + 4 * v89);
LABEL_43:
  v33 = (unsigned __int8 *)(v32 + 1);
  v34 = *v32;
  v106 = v33;
  v104 = v34;
LABEL_56:
  *a5 = v104;
  return (int)v106;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 8048270: using guessed type int __cdecl j_strcspn(_DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80C1B40: using guessed type _DWORD dword_80C1B40[256];
// 80EC1E0: using guessed type int output_charset_cache_9803;
// 80EC1E4: using guessed type int output_charset_cached_9804;
// 80EC1E8: using guessed type int freemem_size_9752;
// 80EC1EC: using guessed type int freemem_9751;
// 80EC1F0: using guessed type int lock_9743;
// 80EC1F4: using guessed type int transmem_list;
// 8049940: using guessed type _DWORD var_1C[7];
// 8049940: using guessed type char anonymous_0[4];

//----- (0804A340) --------------------------------------------------------
unsigned int __usercall _dcigettext@<eax>(
        long double a1@<st0>,
        char *a2,
        unsigned __int8 *a3,
        char *a4,
        int a5,
        int a6,
        unsigned int a7)
{
  int *v7; // edx
  _DWORD *v8; // ebx
  int v9; // eax
  char *v10; // eax
  bool v11; // zf
  unsigned int v12; // edi
  int v13; // esi
  void *v14; // esp
  int v15; // eax
  int v16; // esi
  char *v17; // eax
  char *v18; // ebx
  _BYTE *v19; // esi
  int v20; // edi
  void *v21; // esp
  int v22; // eax
  void *v23; // esp
  char v24; // al
  char *v25; // eax
  int v26; // edi
  int *domain; // eax
  int v28; // esi
  int msg; // eax
  char *v30; // ecx
  char *v32; // eax
  char *v33; // edx
  int *v34; // eax
  int v35; // edi
  int v36; // ebx
  int v37; // eax
  _BYTE *v38; // ebx
  int v39; // eax
  void *v40; // esp
  int v41; // ecx
  _BYTE *v42; // esi
  int v43; // eax
  void *v44; // esp
  int *v45; // eax
  int v46; // edx
  unsigned int v47; // edi
  int v48; // eax
  char **v49; // ebx
  int v50; // edi
  char *v51; // edi
  char *v52; // eax
  char *v53; // ecx
  char ***v54; // edi
  _BYTE v55[12]; // [esp+0h] [ebp-78h] BYREF
  char *v56; // [esp+Ch] [ebp-6Ch]
  int v57; // [esp+10h] [ebp-68h]
  char *v58; // [esp+14h] [ebp-64h]
  unsigned int v59; // [esp+18h] [ebp-60h]
  int **v60; // [esp+1Ch] [ebp-5Ch]
  _BYTE *v61; // [esp+20h] [ebp-58h]
  _DWORD *v62; // [esp+24h] [ebp-54h]
  char *v63; // [esp+28h] [ebp-50h]
  char *v64; // [esp+2Ch] [ebp-4Ch]
  int v65; // [esp+3Ch] [ebp-3Ch] BYREF
  char *v66; // [esp+40h] [ebp-38h] BYREF
  unsigned int v67; // [esp+44h] [ebp-34h]
  char *v68; // [esp+48h] [ebp-30h]
  int v69; // [esp+50h] [ebp-28h]
  unsigned __int8 *v70; // [esp+5Ch] [ebp-1Ch]

  if ( !a3 )
    return 0;
  if ( a7 > 0xC || a7 == 6 )
    goto LABEL_30;
  v59 = __readgsdword(0xFFFFFFE8);
  v69 = 0;
  if ( a2 )
  {
    v70 = a3;
    v66 = a2;
    v67 = a7;
    v38 = (_BYTE *)_current_locale_name(a7);
    v39 = strlen(v38);
    v40 = alloca(v39 + 16);
    v58 = memcpy(v55, v38, v39 + 1);
  }
  else
  {
    a2 = nl_current_default_domain;
    v70 = a3;
    v66 = nl_current_default_domain;
    v67 = a7;
    v42 = (_BYTE *)_current_locale_name(a7);
    v43 = strlen(v42);
    v44 = alloca(v43 + 16);
    v58 = memcpy(v55, v42, v43 + 1);
  }
  v68 = v58;
  v60 = (int **)tfind((int)&v66, &root, (int (__cdecl *)(int, _DWORD))transcmp);
  if ( v60 )
  {
    v7 = *v60;
    if ( (*v60)[3] == nl_msg_cat_cntr )
    {
      v41 = v7[5];
      if ( a5 )
        v41 = plural_lookup(v7[4], a6, v41, v7[6]);
      __writegsdword(0xFFFFFFE8, v59);
      return v41;
    }
  }
  v62 = (_DWORD *)nl_domain_bindings;
  if ( !nl_domain_bindings )
    goto LABEL_55;
  v8 = (_DWORD *)nl_domain_bindings;
  while ( 1 )
  {
    v9 = j_strcmp(a2, v8 + 3);
    if ( !v9 )
      break;
    if ( v9 < 0 )
    {
      v62 = 0;
LABEL_55:
      v63 = "/usr/share/locale";
      goto LABEL_18;
    }
    v8 = (_DWORD *)*v8;
    if ( !v8 )
    {
      v62 = 0;
      v63 = "/usr/share/locale";
LABEL_18:
      v16 = (unsigned __int8)nl_category_name_idxs[a7];
      v17 = (char *)_current_locale_name(a7);
      v18 = v17;
      v19 = (_BYTE *)(v16 + 135004832);
      if ( *v17 != 67 || v17[1] )
      {
        v32 = (char *)getenv("LANGUAGE");
        if ( v32 )
        {
          if ( *v32 )
            v18 = v32;
        }
      }
      v20 = strlen(a2);
      v57 = v20;
      v21 = alloca(v20 + strlen(v19) + 20);
      v61 = v55;
      v22 = j_stpcpy(v55, v19);
      *(_WORD *)v22 = 47;
      *(_DWORD *)mempcpy((_BYTE *)(v22 + 1), a2, v20) = 7302446;
      v23 = alloca(strlen(v18) + 16);
      v64 = v55;
LABEL_21:
      while ( 2 )
      {
        while ( 2 )
        {
          while ( 1 )
          {
            v24 = *v18;
            if ( *v18 != 58 )
              break;
            ++v18;
          }
          if ( !v24 )
          {
            v25 = v64;
            *v64 = 67;
            v25[1] = 0;
            goto LABEL_24;
          }
          v33 = v64;
          do
          {
            ++v33;
            ++v18;
            *(v33 - 1) = v24;
            v24 = *v18;
          }
          while ( *v18 && v24 != 58 );
          *v33 = 0;
          if ( _libc_enable_secure && j_strchr(v64, 47) )
            continue;
          break;
        }
        if ( *v64 == 67 )
        {
LABEL_24:
          if ( !v64[1] )
            goto LABEL_29;
        }
        if ( !strcmp(v64, "POSIX") )
          goto LABEL_29;
        v26 = (int)v62;
        domain = nl_find_domain(v63, (unsigned __int8 *)v64, v61, a1, (int)v62);
        v28 = (int)domain;
        if ( domain )
        {
          msg = nl_find_msg(domain, v26, a3, 1, (unsigned int *)&v65);
          if ( msg )
          {
            v30 = (char *)msg;
            if ( msg == -1 )
              goto LABEL_29;
LABEL_62:
            if ( v60 )
            {
              v45 = *v60;
              v45[3] = nl_msg_cat_cntr;
              v46 = v65;
              v45[4] = v28;
              v45[5] = (int)v30;
              v45[6] = v46;
            }
            else
            {
              v64 = v30;
              v47 = strlen(a3) + 1;
              v62 = (_DWORD *)strlen(v58);
              v48 = malloc((char *)v62 + v57 + v47 + 30);
              v49 = (char **)v48;
              v30 = v64;
              if ( v48 )
              {
                v63 = v64;
                v64 = (char *)mempcpy((_BYTE *)(v48 + 28), a3, v47);
                v50 = v57 + 1;
                memcpy(v64, a2, v57 + 1);
                v51 = &v64[v50];
                memcpy(v51, v58, (unsigned int)v62 + 1);
                v52 = v64;
                v53 = v63;
                v49[2] = v51;
                v49[4] = (char *)v28;
                *v49 = v52;
                v49[5] = v53;
                v49[1] = (char *)a7;
                v49[3] = (char *)nl_msg_cat_cntr;
                v49[6] = (char *)v65;
                v64 = v53;
                v54 = (char ***)tsearch((int)v49, &root, (int (__cdecl *)(int, _DWORD))transcmp);
                v30 = v64;
                if ( !v54 || v49 != *v54 )
                {
                  free(v49);
                  v30 = v64;
                }
              }
            }
            __writegsdword(0xFFFFFFE8, v59);
            if ( a5 )
              return plural_lookup(v28, a6, (int)v30, v65);
            return (unsigned int)v30;
          }
          v34 = *(int **)(v28 + 16);
          if ( v34 )
          {
            v56 = v18;
            v35 = 0;
            v36 = (int)v62;
            while ( 1 )
            {
              v37 = nl_find_msg(v34, v36, a3, 1, (unsigned int *)&v65);
              if ( v37 == -1 )
                goto LABEL_29;
              if ( v37 )
              {
                v28 = *(_DWORD *)(v28 + 4 * v35 + 16);
                v30 = (char *)v37;
                goto LABEL_62;
              }
              ++v35;
              v34 = *(int **)(v28 + 4 * v35 + 16);
              if ( !v34 )
              {
                v18 = v56;
                goto LABEL_21;
              }
            }
          }
        }
        continue;
      }
    }
  }
  v10 = (char *)v8[1];
  v62 = v8;
  v11 = *v10 == 47;
  v63 = v10;
  if ( v11 )
    goto LABEL_18;
  v12 = 4098;
  v13 = strlen(v63) + 1;
  while ( 1 )
  {
    v14 = alloca(v12 + v13 + 15);
    __writegsdword(0xFFFFFFE8, 0);
    if ( getcwd(v55, v12) )
    {
      v15 = j_rawmemchr(v55, 0) + 1;
      *(_BYTE *)(v15 - 1) = 47;
      j_strcpy(v15, v63);
      v63 = v55;
      goto LABEL_18;
    }
    if ( __readgsdword(0xFFFFFFE8) != 34 )
      break;
    v12 += (v12 >> 1) + 32;
  }
LABEL_29:
  __writegsdword(0xFFFFFFE8, v59);
LABEL_30:
  if ( a6 != 1 )
  {
    v30 = a4;
    if ( a5 )
      return (unsigned int)v30;
  }
  return (unsigned int)a3;
}
// 80481B0: using guessed type int __cdecl j_strcpy(_DWORD, _DWORD);
// 80481E0: using guessed type int __cdecl j_rawmemchr(_DWORD, _DWORD);
// 8048210: using guessed type int __cdecl j_stpcpy(_DWORD, _DWORD);
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80EB06C: using guessed type char *nl_current_default_domain;
// 80EC1F8: using guessed type int root;
// 80ECC30: using guessed type int nl_domain_bindings;
// 80ECC34: using guessed type int nl_msg_cat_cntr;

//----- (0804AAE0) --------------------------------------------------------
int *__userpurge nl_find_domain@<eax>(
        _BYTE *a1@<eax>,
        unsigned __int8 *a2@<edx>,
        _BYTE *a3@<ecx>,
        long double a4@<st0>,
        int a5)
{
  int v8; // eax
  int *l10nflist; // eax
  int *v10; // ebp
  int *v12; // eax
  int **v13; // ebx
  _BYTE *v14; // eax
  int v15; // eax
  int *v16; // eax
  int **v17; // ebx
  int v18; // [esp+4h] [ebp-48h]
  _BYTE *v19; // [esp+Ch] [ebp-40h]
  unsigned __int8 *v20; // [esp+1Ch] [ebp-30h] BYREF
  _BYTE *v21; // [esp+20h] [ebp-2Ch] BYREF
  unsigned __int8 *v22; // [esp+24h] [ebp-28h] BYREF
  _BYTE *v23; // [esp+28h] [ebp-24h] BYREF
  unsigned __int8 *v24; // [esp+2Ch] [ebp-20h] BYREF

  v8 = strlen(a1);
  l10nflist = nl_make_l10nflist(&nl_loaded_domains, a1, v8 + 1, 0, a2, 0, 0, 0, 0, a3, 0);
  v10 = l10nflist;
  if ( l10nflist )
  {
    if ( l10nflist[1] <= 0 )
      nl_load_domain(l10nflist, a5);
    if ( !v10[2] )
    {
      v12 = (int *)v10[4];
      if ( v12 )
      {
        v13 = (int **)(v10 + 4);
        do
        {
          if ( v12[1] <= 0 )
            nl_load_domain(v12, a5);
          if ( (*v13)[2] )
            break;
          v12 = *++v13;
        }
        while ( *v13 );
      }
    }
  }
  else
  {
    v14 = (_BYTE *)nl_expand_alias(a4, (int)a2);
    v19 = v14;
    if ( !v14 || (a2 = strdup(v14)) != 0 )
    {
      v18 = nl_explode_name(a2, &v20, &v21, &v22, &v23, &v24);
      if ( v18 != -1 )
      {
        v15 = strlen(a1);
        v10 = nl_make_l10nflist(&nl_loaded_domains, a1, v15 + 1, v18, v20, v22, v23, v24, v21, a3, 1);
        if ( v10 )
        {
          if ( v10[1] <= 0 )
            nl_load_domain(v10, a5);
          if ( !v10[2] )
          {
            v16 = (int *)v10[4];
            if ( v16 )
            {
              v17 = (int **)(v10 + 4);
              do
              {
                if ( v16[1] <= 0 )
                  nl_load_domain(v16, a5);
                if ( (*v17)[2] )
                  break;
                v16 = *++v17;
              }
              while ( *v17 );
            }
          }
          if ( v19 )
            free(a2);
        }
        if ( (v18 & 1) != 0 )
          free(v24);
      }
    }
  }
  return v10;
}
// 804AC87: conditional instruction was optimized away because %var_44.4==0
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EC240: using guessed type int nl_loaded_domains;

//----- (0804AD30) --------------------------------------------------------
_DWORD *__usercall nl_load_domain@<eax>(int *a1@<eax>, int a2@<edx>)
{
  unsigned int v3; // esi
  bool v5; // zf
  int v6; // esi
  _DWORD *result; // eax
  int v8; // ebx
  int v9; // ebx
  _BYTE *v10; // ecx
  int v11; // ecx
  _BYTE *v12; // esi
  unsigned __int8 v13; // bl
  unsigned int v14; // ecx
  unsigned int v15; // eax
  _DWORD *v16; // eax
  _BYTE *v17; // ecx
  unsigned __int32 v18; // ecx
  _DWORD *v19; // eax
  _BYTE *v20; // ecx
  _BYTE *v21; // ecx
  _DWORD *v22; // eax
  unsigned int v23; // eax
  void *v24; // esp
  unsigned int v25; // ecx
  _BYTE *v26; // edi
  int v27; // esi
  unsigned __int32 v28; // edx
  _BYTE *v29; // eax
  char *v30; // edx
  int v31; // eax
  _DWORD *v32; // eax
  _DWORD *v33; // ebx
  int msg; // eax
  char v35; // dl
  _DWORD *v36; // eax
  unsigned int v37; // edx
  void *v38; // esp
  unsigned __int32 v39; // eax
  _BYTE *v40; // eax
  unsigned int v41; // edx
  _BYTE *v42; // edx
  bool v43; // al
  unsigned int *v44; // edi
  int i; // eax
  int v46; // esi
  unsigned int v47; // eax
  _BYTE *v48; // eax
  int v49; // eax
  int v50; // ebx
  int v51; // eax
  _BYTE *v52; // edi
  int v53; // esi
  unsigned int v54; // edx
  char *v55; // edx
  bool v56; // al
  char *j; // edx
  unsigned int v58; // eax
  unsigned int *v59; // ebx
  unsigned __int32 v60; // eax
  unsigned __int32 *v61; // ebx
  int v62; // esi
  int v63; // edi
  int v64; // eax
  _BYTE *v65; // eax
  int v66; // ebx
  int v67; // ecx
  unsigned int v68; // edx
  int v69; // edi
  unsigned int v70; // eax
  unsigned int v71; // esi
  unsigned int v72; // ecx
  unsigned int v73; // ebx
  int v74; // esi
  unsigned int v75; // eax
  int *v76; // eax
  int v77; // edx
  _DWORD *v78; // eax
  int v79; // ebx
  _BYTE *v80; // eax
  __int64 v81; // rax
  int v82; // edx
  int v83; // edx
  unsigned int *v84; // ebx
  unsigned __int32 v85; // esi
  int v86; // eax
  char v87; // bl
  char v88; // bl
  _BYTE *v89; // [esp-10h] [ebp-F8h]
  int *v90; // [esp+0h] [ebp-E8h] BYREF
  unsigned __int32 *v91; // [esp+4h] [ebp-E4h]
  int v92; // [esp+8h] [ebp-E0h]
  unsigned __int32 *v93; // [esp+Ch] [ebp-DCh]
  int v94; // [esp+10h] [ebp-D8h]
  int v95; // [esp+14h] [ebp-D4h]
  int v96; // [esp+18h] [ebp-D0h]
  unsigned __int32 *v97; // [esp+1Ch] [ebp-CCh]
  int *v98; // [esp+20h] [ebp-C8h]
  _BYTE *v99; // [esp+24h] [ebp-C4h]
  int v100; // [esp+28h] [ebp-C0h]
  int v101; // [esp+2Ch] [ebp-BCh]
  int *v102; // [esp+30h] [ebp-B8h]
  unsigned int v103; // [esp+34h] [ebp-B4h]
  _BYTE *v104; // [esp+38h] [ebp-B0h]
  int *v105; // [esp+3Ch] [ebp-ACh]
  unsigned int v106; // [esp+40h] [ebp-A8h]
  int v107; // [esp+44h] [ebp-A4h]
  _DWORD *v108; // [esp+48h] [ebp-A0h]
  unsigned int v109; // [esp+4Ch] [ebp-9Ch]
  unsigned int v110; // [esp+50h] [ebp-98h]
  int v111; // [esp+54h] [ebp-94h]
  _DWORD *v112; // [esp+58h] [ebp-90h]
  int v113; // [esp+5Ch] [ebp-8Ch]
  int v114[2]; // [esp+68h] [ebp-80h] BYREF
  char v115[44]; // [esp+70h] [ebp-78h] BYREF
  _DWORD *v116; // [esp+9Ch] [ebp-4Ch]
  int v117; // [esp+A0h] [ebp-48h]

  v3 = __readgsdword(8u);
  if ( v3 != dword_80EC24C )
  {
    _ECX = 1;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg ds:lock_9614, ecx }
    if ( !v5 )
      _lll_lock_wait_private(0, &lock_9614);
    dword_80EC24C = v3;
  }
  v6 = dword_80EC248 + 1;
  result = (_DWORD *)a1[1];
  ++dword_80EC248;
  if ( result )
    goto LABEL_29;
  v8 = *a1;
  v111 = a2;
  a1[1] = -1;
  a1[2] = 0;
  if ( !v8 )
    goto LABEL_28;
  result = (_DWORD *)dl_sysinfo(0);
  v9 = (int)result;
  if ( (unsigned int)result > 0xFFFFF000 )
  {
    result = (_DWORD *)_syscall_error((int)result);
    v9 = (int)result;
  }
  if ( v9 == -1 )
    goto LABEL_27;
  v110 = _fxstat64(3, v9, (int)v115);
  if ( v110 )
    goto LABEL_26;
  v112 = v116;
  v10 = v116;
  v108 = v116;
  v113 = v117;
  if ( v117 || (unsigned int)v116 <= 0x2F )
    goto LABEL_26;
  v12 = (_BYTE *)mmap(0, (int)v112, 1, 2, v9, 0);
  if ( v12 != (_BYTE *)-1 )
  {
    dl_sysinfo(v11);
    v13 = *(_DWORD *)v12 != -1794895138;
    if ( *(_DWORD *)v12 != -569244523 && *(_DWORD *)v12 != -1794895138 )
    {
      result = (_DWORD *)munmap((int)v12, (int)v112);
      goto LABEL_27;
    }
    v110 = 1;
    goto LABEL_19;
  }
  v80 = (_BYTE *)malloc(v112);
  v12 = v80;
  if ( !v80 )
  {
LABEL_26:
    result = (_DWORD *)dl_sysinfo(v10);
    goto LABEL_27;
  }
  v10 = v80;
  do
  {
    v81 = dl_sysinfo(v10);
    if ( (unsigned int)v81 > 0xFFFFF000 )
    {
      v109 = (unsigned int)v10;
      v112 = (_DWORD *)HIDWORD(v81);
      v81 = __PAIR64__((unsigned int)v112, _syscall_error(v81));
      v10 = (_BYTE *)v109;
    }
    if ( (int)v81 <= 0 )
    {
      if ( (_DWORD)v81 != -1 || __readgsdword(0xFFFFFFE8) != 4 )
        goto LABEL_26;
    }
    else
    {
      v10 += v81;
      HIDWORD(v81) -= v81;
    }
  }
  while ( HIDWORD(v81) );
  dl_sysinfo(v10);
  v13 = *(_DWORD *)v12 != -1794895138;
  if ( *(_DWORD *)v12 != -569244523 && *(_DWORD *)v12 != -1794895138 )
  {
    result = (_DWORD *)free(v12);
    goto LABEL_27;
  }
LABEL_19:
  result = (_DWORD *)malloc(104);
  v112 = result;
  if ( !result )
    goto LABEL_27;
  v14 = v110;
  a1[2] = (int)result;
  *result = v12;
  result[3] = v13;
  result[4] = 0;
  result[1] = v14;
  result[2] = v108;
  v15 = *((_DWORD *)v12 + 1);
  if ( v13 )
  {
    v109 = _byteswap_ulong(v15);
    if ( v109 <= 0x1FFFF )
    {
      v16 = v112;
      v112[5] = _byteswap_ulong(*((_DWORD *)v12 + 2));
      v16[6] = &v12[_byteswap_ulong(*((_DWORD *)v12 + 3))];
      v16[7] = &v12[_byteswap_ulong(*((_DWORD *)v12 + 4))];
      v17 = (_BYTE *)_byteswap_ulong(*((_DWORD *)v12 + 5));
      v104 = v17;
      v16[11] = v17;
      if ( (unsigned int)v17 > 2 )
      {
        v18 = _byteswap_ulong(*((_DWORD *)v12 + 6));
        goto LABEL_38;
      }
LABEL_77:
      v5 = (_WORD)v109 == 0;
      v36 = v112;
      v112[12] = 0;
      v36[13] = v13;
      if ( !v5 )
        goto LABEL_78;
      goto LABEL_58;
    }
LABEL_54:
    v31 = 0;
    goto LABEL_55;
  }
  v109 = *((_DWORD *)v12 + 1);
  if ( v15 > 0x1FFFF )
    goto LABEL_54;
  v19 = v112;
  v112[5] = *((_DWORD *)v12 + 2);
  v19[6] = &v12[*((_DWORD *)v12 + 3)];
  v19[7] = &v12[*((_DWORD *)v12 + 4)];
  v104 = (_BYTE *)*((_DWORD *)v12 + 5);
  v20 = v104;
  v19[11] = v104;
  if ( (unsigned int)v20 <= 2 )
    goto LABEL_77;
  v18 = *((_DWORD *)v12 + 6);
LABEL_38:
  v21 = &v12[v18];
  v5 = (_WORD)v109 == 0;
  v22 = v112;
  v112[12] = v21;
  v22[13] = v13;
  if ( v5 )
    goto LABEL_58;
  if ( !v21 )
    goto LABEL_157;
  v23 = *((_DWORD *)v12 + 9);
  if ( v13 )
  {
    v103 = _byteswap_ulong(v23);
    if ( !v103 )
      goto LABEL_58;
    v109 = _byteswap_ulong(*((_DWORD *)v12 + 7));
    v106 = (unsigned int)&v12[_byteswap_ulong(*((_DWORD *)v12 + 8))];
    v24 = alloca(4 * v109 + 15);
    v105 = (int *)&v90;
    if ( !v109 )
      goto LABEL_161;
  }
  else
  {
    v103 = *((_DWORD *)v12 + 9);
    if ( !v23 )
      goto LABEL_58;
    v37 = (unsigned int)&v12[*((_DWORD *)v12 + 8)];
    v109 = *((_DWORD *)v12 + 7);
    v106 = v37;
    v38 = alloca(4 * v109 + 15);
    v105 = (int *)&v90;
    if ( !v109 )
      goto LABEL_82;
  }
  v102 = a1;
  v25 = 0;
  v26 = v12;
  LOBYTE(v107) = v13;
  v27 = (int)v105;
  do
  {
    if ( (_BYTE)v107 )
    {
      v28 = _byteswap_ulong(*(_DWORD *)(v106 + 8 * v25));
      v29 = &v26[_byteswap_ulong(*(_DWORD *)(v106 + 8 * v25 + 4))];
    }
    else
    {
      v28 = *(_DWORD *)(v106 + 8 * v25);
      v29 = &v26[*(_DWORD *)(v106 + 8 * v25 + 4)];
    }
    if ( !v28 || v29[v28 - 1] )
    {
      v12 = v26;
      a1 = v102;
      goto LABEL_157;
    }
    if ( *v29 == 80 )
    {
      v30 = 0;
      if ( v29[1] == 82 && v29[2] == 73 )
      {
        LOBYTE(v101) = v29[3];
        LOBYTE(v100) = (_BYTE)v101 == 105 || (_BYTE)v101 == 100;
        LOBYTE(v98) = (_BYTE)v101 == 111;
        LOBYTE(v99) = (_BYTE)v101 == 111 || (_BYTE)v101 == 117;
        if ( (v101 & 0xDF) == 88 || (unsigned __int8)v99 | (unsigned __int8)v100 )
        {
          v35 = v29[4];
          switch ( v35 )
          {
            case '8':
              if ( v29[5] )
              {
                v30 = 0;
              }
              else if ( (_BYTE)v101 == 100 )
              {
                v30 = "d";
              }
              else if ( (_BYTE)v100 )
              {
                v30 = "i";
              }
              else if ( (_BYTE)v101 == 111 )
              {
                v30 = "o";
              }
              else if ( (_BYTE)v99 )
              {
                v30 = (char *)&unk_80CF9AE;
              }
              else if ( (_BYTE)v101 == 120 )
              {
                v30 = "x";
              }
              else
              {
                if ( (_BYTE)v101 != 88 )
                  goto LABEL_215;
                v30 = "X";
              }
              break;
            case '1':
              v30 = 0;
              if ( v29[5] == 54 && !v29[6] )
              {
                if ( (_BYTE)v101 == 100 )
                {
                  v30 = "d";
                }
                else if ( (_BYTE)v100 )
                {
                  v30 = "i";
                }
                else if ( (_BYTE)v101 == 111 )
                {
                  v30 = "o";
                }
                else if ( (_BYTE)v99 )
                {
                  v30 = (char *)&unk_80CF9AE;
                }
                else if ( (_BYTE)v101 == 120 )
                {
                  v30 = "x";
                }
                else
                {
                  if ( (_BYTE)v101 != 88 )
                    goto LABEL_215;
                  v30 = "X";
                }
              }
              break;
            case '3':
              v30 = 0;
              if ( v29[5] == 50 && !v29[6] )
              {
                if ( (_BYTE)v101 == 100 )
                {
                  v30 = "d";
                }
                else if ( (_BYTE)v100 )
                {
                  v30 = "i";
                }
                else if ( (_BYTE)v101 == 111 )
                {
                  v30 = "o";
                }
                else if ( (_BYTE)v99 )
                {
                  v30 = (char *)&unk_80CF9AE;
                }
                else if ( (_BYTE)v101 == 120 )
                {
                  v30 = "x";
                }
                else
                {
                  if ( (_BYTE)v101 != 88 )
                    goto LABEL_215;
                  v30 = "X";
                }
              }
              break;
            case '6':
              v30 = 0;
              if ( v29[5] == 52 && !v29[6] )
              {
                if ( (_BYTE)v101 == 100 )
                {
                  v30 = "lld";
                }
                else if ( (_BYTE)v100 )
                {
                  v30 = "lli";
                }
                else if ( (_BYTE)v101 == 111 )
                {
                  v30 = "llo";
                }
                else if ( (_BYTE)v99 )
                {
                  v30 = "llu";
                }
                else if ( (_BYTE)v101 == 120 )
                {
                  v30 = "llx";
                }
                else
                {
                  if ( (_BYTE)v101 != 88 )
                    goto LABEL_215;
                  v30 = "llX";
                }
              }
              break;
            case 'L':
              v30 = 0;
              if ( v29[5] == 69 && v29[6] == 65 && v29[7] == 83 && v29[8] == 84 )
              {
                v87 = v29[9];
                if ( v87 == 56 )
                {
                  if ( v29[10] )
                  {
                    v30 = 0;
                  }
                  else if ( (_BYTE)v101 == 100 )
                  {
                    v30 = "d";
                  }
                  else if ( (_BYTE)v100 )
                  {
                    v30 = "i";
                  }
                  else if ( (_BYTE)v101 == 111 )
                  {
                    v30 = "o";
                  }
                  else if ( (_BYTE)v99 )
                  {
                    v30 = (char *)&unk_80CF9AE;
                  }
                  else if ( (_BYTE)v101 == 120 )
                  {
                    v30 = "x";
                  }
                  else
                  {
                    if ( (_BYTE)v101 != 88 )
                      goto LABEL_215;
                    v30 = "X";
                  }
                }
                else
                {
                  v30 = 0;
                  if ( v87 == 49 )
                  {
                    if ( v29[10] == 54 && !v29[11] )
                    {
                      if ( (_BYTE)v101 == 100 )
                      {
                        v30 = "d";
                      }
                      else if ( (_BYTE)v100 )
                      {
                        v30 = "i";
                      }
                      else if ( (_BYTE)v101 == 111 )
                      {
                        v30 = "o";
                      }
                      else if ( (_BYTE)v99 )
                      {
                        v30 = (char *)&unk_80CF9AE;
                      }
                      else if ( (_BYTE)v101 == 120 )
                      {
                        v30 = "x";
                      }
                      else
                      {
                        if ( (_BYTE)v101 != 88 )
                          goto LABEL_215;
                        v30 = "X";
                      }
                    }
                  }
                  else if ( v87 == 51 )
                  {
                    if ( v29[10] == 50 && !v29[11] )
                    {
                      if ( (_BYTE)v101 == 100 )
                      {
                        v30 = "d";
                      }
                      else if ( (_BYTE)v100 )
                      {
                        v30 = "i";
                      }
                      else if ( (_BYTE)v101 == 111 )
                      {
                        v30 = "o";
                      }
                      else if ( (_BYTE)v99 )
                      {
                        v30 = (char *)&unk_80CF9AE;
                      }
                      else if ( (_BYTE)v101 == 120 )
                      {
                        v30 = "x";
                      }
                      else
                      {
                        if ( (_BYTE)v101 != 88 )
                          goto LABEL_215;
                        v30 = "X";
                      }
                    }
                  }
                  else if ( v87 == 54 && v29[10] == 52 && !v29[11] )
                  {
                    if ( (_BYTE)v101 == 100 )
                    {
                      v30 = "lld";
                    }
                    else if ( (_BYTE)v100 )
                    {
                      v30 = "lli";
                    }
                    else if ( (_BYTE)v101 == 111 )
                    {
                      v30 = "llo";
                    }
                    else if ( (_BYTE)v99 )
                    {
                      v30 = "llu";
                    }
                    else if ( (_BYTE)v101 == 120 )
                    {
                      v30 = "llx";
                    }
                    else
                    {
                      if ( (_BYTE)v101 != 88 )
                        goto LABEL_215;
                      v30 = "llX";
                    }
                  }
                }
              }
              break;
            case 'F':
              v30 = 0;
              if ( v29[5] == 65 && v29[6] == 83 && v29[7] == 84 )
              {
                v88 = v29[8];
                if ( v88 == 56 )
                {
                  if ( v29[9] )
                  {
                    v30 = 0;
                  }
                  else if ( (_BYTE)v101 == 100 )
                  {
                    v30 = "d";
                  }
                  else if ( (_BYTE)v100 )
                  {
                    v30 = "i";
                  }
                  else if ( (_BYTE)v101 == 111 )
                  {
                    v30 = "o";
                  }
                  else if ( (_BYTE)v99 )
                  {
                    v30 = (char *)&unk_80CF9AE;
                  }
                  else if ( (_BYTE)v101 == 120 )
                  {
                    v30 = "x";
                  }
                  else
                  {
                    if ( (_BYTE)v101 != 88 )
                      goto LABEL_215;
                    v30 = "X";
                  }
                }
                else
                {
                  v30 = 0;
                  if ( v88 == 49 )
                  {
                    if ( v29[9] == 54 && !v29[10] )
                    {
                      if ( (_BYTE)v101 == 100 )
                      {
                        v30 = "d";
                      }
                      else if ( (_BYTE)v100 )
                      {
                        v30 = "i";
                      }
                      else if ( (_BYTE)v101 == 111 )
                      {
                        v30 = "o";
                      }
                      else if ( (_BYTE)v99 )
                      {
                        v30 = (char *)&unk_80CF9AE;
                      }
                      else if ( (_BYTE)v101 == 120 )
                      {
                        v30 = "x";
                      }
                      else
                      {
                        if ( (_BYTE)v101 != 88 )
                          goto LABEL_215;
                        v30 = "X";
                      }
                    }
                  }
                  else if ( v88 == 51 )
                  {
                    if ( v29[9] == 50 && !v29[10] )
                    {
                      if ( (_BYTE)v101 == 100 )
                      {
                        v30 = "d";
                      }
                      else if ( (_BYTE)v100 )
                      {
                        v30 = "i";
                      }
                      else if ( (_BYTE)v101 == 111 )
                      {
                        v30 = "o";
                      }
                      else if ( (_BYTE)v99 )
                      {
                        v30 = (char *)&unk_80CF9AE;
                      }
                      else if ( (_BYTE)v101 == 120 )
                      {
                        v30 = "x";
                      }
                      else
                      {
                        if ( (_BYTE)v101 != 88 )
                          goto LABEL_215;
                        v30 = "X";
                      }
                    }
                  }
                  else if ( v88 == 54 && v29[9] == 52 && !v29[10] )
                  {
                    if ( (_BYTE)v101 == 100 )
                    {
                      v30 = "lld";
                    }
                    else if ( (_BYTE)v100 )
                    {
                      v30 = "lli";
                    }
                    else if ( (_BYTE)v101 == 111 )
                    {
                      v30 = "llo";
                    }
                    else if ( (_BYTE)v99 )
                    {
                      v30 = "llu";
                    }
                    else if ( (_BYTE)v101 == 120 )
                    {
                      v30 = "llx";
                    }
                    else
                    {
                      if ( (_BYTE)v101 != 88 )
                        goto LABEL_215;
                      v30 = "llX";
                    }
                  }
                }
              }
              break;
            case 'M':
              v30 = 0;
              if ( v29[5] == 65 && v29[6] == 88 )
              {
                if ( v29[7] )
                {
                  v30 = 0;
                }
                else if ( (_BYTE)v101 == 100 )
                {
                  v30 = "lld";
                }
                else if ( (_BYTE)v100 )
                {
                  v30 = "lli";
                }
                else if ( (_BYTE)v101 == 111 )
                {
                  v30 = "llo";
                }
                else if ( (_BYTE)v99 )
                {
                  v30 = "llu";
                }
                else if ( (_BYTE)v101 == 120 )
                {
                  v30 = "llx";
                }
                else
                {
                  if ( (_BYTE)v101 != 88 )
                    goto LABEL_215;
                  v30 = "llX";
                }
              }
              break;
            default:
              v5 = v35 == 80;
              v30 = 0;
              if ( v5 && v29[5] == 84 && v29[6] == 82 )
              {
                if ( v29[7] )
                {
                  v30 = 0;
                }
                else if ( (_BYTE)v101 == 100 )
                {
                  v30 = "d";
                }
                else if ( (_BYTE)v100 )
                {
                  v30 = "i";
                }
                else if ( (_BYTE)v101 == 111 )
                {
                  v30 = "o";
                }
                else if ( (_BYTE)v99 )
                {
                  v30 = (char *)&unk_80CF9AE;
                }
                else if ( (_BYTE)v101 == 120 )
                {
                  v30 = "x";
                }
                else
                {
                  if ( (_BYTE)v101 != 88 )
                    goto LABEL_215;
                  v30 = "X";
                }
              }
              break;
          }
        }
      }
    }
    else if ( *v29 == 73 )
    {
      v30 = 0;
      if ( !v29[1] )
        v30 = "I";
    }
    else
    {
      v30 = 0;
    }
    *(_DWORD *)(v27 + 4 * v25++) = v30;
  }
  while ( v109 > v25 );
  v13 = v107;
  v12 = v26;
  a1 = v102;
  if ( (_BYTE)v107 )
  {
LABEL_161:
    v99 = &v12[_byteswap_ulong(*((_DWORD *)v12 + 10))];
    v39 = _byteswap_ulong(*((_DWORD *)v12 + 11));
    goto LABEL_83;
  }
LABEL_82:
  v99 = &v12[*((_DWORD *)v12 + 10)];
  v39 = *((_DWORD *)v12 + 11);
LABEL_83:
  v106 = 0;
  v101 = 0;
  v102 = (int *)&v12[v39];
  v40 = v104;
  v98 = a1;
  v104 = v12;
  v97 = (unsigned __int32 *)(4 * (_DWORD)v40);
  v100 = 4 * (_DWORD)v40;
  do
  {
    v107 = 0;
    do
    {
      if ( v13 )
      {
        if ( v107 )
          v41 = v102[v106];
        else
          v41 = *(_DWORD *)&v99[4 * v106];
        v42 = &v104[_byteswap_ulong(v41)];
        v43 = *((_DWORD *)v42 + 2) != -1;
      }
      else
      {
        if ( v107 )
          v82 = v102[v106];
        else
          v82 = *(_DWORD *)&v99[4 * v106];
        v42 = &v104[v82];
        v43 = *((_DWORD *)v42 + 2) != -1;
      }
      if ( v43 )
      {
        v44 = (unsigned int *)(v42 + 4);
        for ( i = 0; ; i = v46 + strlen(v48) )
        {
          if ( v13 )
          {
            v46 = i + _byteswap_ulong(*v44);
            v47 = _byteswap_ulong(v44[1]);
          }
          else
          {
            v46 = *v44 + i;
            v47 = v44[1];
          }
          if ( v47 == -1 )
            break;
          if ( v109 <= v47 )
          {
            v12 = v104;
            a1 = v98;
            v31 = v112[4];
            goto LABEL_55;
          }
          v48 = (_BYTE *)v105[v47];
          if ( !v48 )
            goto LABEL_101;
          v44 += 2;
        }
      }
      else
      {
        v46 = 0;
      }
      v49 = v107;
      v114[v107] = v46;
      v107 = v49 + 1;
    }
    while ( v49 != 1 );
    ++v101;
    v100 += v114[0] + v114[1];
LABEL_101:
    ++v106;
  }
  while ( v106 < v103 );
  v12 = v104;
  a1 = v98;
  if ( !v101 )
  {
LABEL_58:
    v32 = v112;
    v112[8] = 0;
    v32[9] = 0;
    v32[10] = 0;
    goto LABEL_59;
  }
  v96 = malloc(v100 + 16 * v101);
  if ( !v96 )
    goto LABEL_157;
  v50 = v96;
  v90 = a1;
  v95 = 0;
  v106 = 0;
  v51 = 8 * v101;
  v98 = (int *)v12;
  v112[4] = v96;
  v92 = v51 + v50;
  v94 = v51 + v50 + v51;
  v52 = (char *)v97 + v94;
  do
  {
    v25 = 0;
    v53 = v112[3];
    do
    {
      if ( v53 )
      {
        if ( v25 )
          v54 = v102[v106];
        else
          v54 = *(_DWORD *)&v99[4 * v106];
        v55 = (char *)v98 + _byteswap_ulong(v54);
        v56 = *((_DWORD *)v55 + 2) != -1;
      }
      else
      {
        if ( v25 )
          v83 = v102[v106];
        else
          v83 = *(_DWORD *)&v99[4 * v106];
        v55 = (char *)v98 + v83;
        v56 = *((_DWORD *)v55 + 2) != -1;
      }
      if ( v56 )
      {
        for ( j = v55 + 4; ; j += 8 )
        {
          v58 = *((_DWORD *)j + 1);
          if ( v53 )
            v58 = _byteswap_ulong(v58);
          if ( v58 == -1 )
            break;
          if ( !v105[v58] )
            goto LABEL_127;
        }
      }
      ++v25;
    }
    while ( v25 != 2 );
    v100 = 0;
    v107 = v53;
    v93 = (unsigned __int32 *)(8 * v95 + v96);
    v91 = (unsigned __int32 *)(v92 + 8 * v95);
    while ( 1 )
    {
      if ( v107 )
      {
        if ( v100 )
        {
          v59 = (unsigned int *)((char *)v98 + _byteswap_ulong(v102[v106]));
          v25 = (unsigned int)v98 + _byteswap_ulong(*v59);
          v104 = (_BYTE *)v25;
          v97 = v91;
        }
        else
        {
          v59 = (unsigned int *)((char *)v98 + _byteswap_ulong(*(_DWORD *)&v99[4 * v106]));
          v25 = (unsigned int)v98 + _byteswap_ulong(*v59);
          v104 = (_BYTE *)v25;
          v97 = v93;
        }
        if ( v59[2] == -1 )
        {
          v60 = _byteswap_ulong(v59[1]);
LABEL_124:
          v61 = v97;
          *v97 = v60;
          v61[1] = (unsigned __int32)v104;
          goto LABEL_125;
        }
      }
      else
      {
        v25 = v106;
        if ( v100 )
        {
          v59 = (unsigned int *)((char *)v98 + v102[v106]);
          v104 = (char *)v98 + *v59;
          v97 = v91;
        }
        else
        {
          v59 = (unsigned int *)((char *)v98 + *(_DWORD *)&v99[4 * v106]);
          v104 = (char *)v98 + *v59;
          v97 = v93;
        }
        if ( v59[2] == -1 )
        {
          v60 = v59[1];
          goto LABEL_124;
        }
      }
      v84 = v59 + 1;
      v97[1] = (unsigned __int32)v52;
      while ( 1 )
      {
        if ( v107 )
        {
          v25 = _byteswap_ulong(*v84);
          v85 = _byteswap_ulong(v84[1]);
        }
        else
        {
          v85 = v84[1];
          v25 = *v84;
        }
        if ( v25 )
        {
          v109 = v25;
          memcpy(v52, v104, v25);
          v25 = v109;
          v104 += v109;
          v52 += v109;
        }
        if ( v85 == -1 )
          break;
        v84 += 2;
        v109 = v105[v85];
        v86 = strlen((_BYTE *)v109);
        v89 = v52;
        v52 += v86;
        memcpy(v89, (_BYTE *)v109, v86);
      }
      *v97 = (unsigned __int32)&v52[-v97[1]];
LABEL_125:
      if ( ++v100 == 2 )
        break;
      v107 = v112[3];
    }
    ++v95;
LABEL_127:
    ++v106;
  }
  while ( v106 < v103 );
  v62 = (int)v98;
  v63 = (int)v90;
  if ( v101 != v95 )
LABEL_215:
    abort(v25);
  v64 = v112[11];
  if ( v64 )
  {
    v107 = (int)v98;
    v109 = 4 * v64;
    v65 = 0;
    v66 = v112[13];
    v67 = v112[12];
    do
    {
      v68 = *(_DWORD *)&v65[v67];
      if ( v66 )
        v68 = _byteswap_ulong(v68);
      *(_DWORD *)&v65[v94] = v68;
      v65 += 4;
    }
    while ( (_BYTE *)v109 != v65 );
    v62 = v107;
  }
  v105 = (int *)v63;
  v69 = v94;
  v107 = 0;
  v106 = v62;
  do
  {
    v70 = _hash_string(*(unsigned __int8 **)(v96 + 8 * v107 + 4));
    v71 = v112[11];
    v72 = v70 % v71;
    v73 = v70 % (v71 - 2) + 1;
    v109 = v71 - v73;
    v74 = v73 - v71;
    while ( 1 )
    {
      v76 = (int *)(v69 + 4 * v72);
      if ( !*v76 )
        break;
      v75 = v72 + v74;
      if ( v72 < v109 )
        v75 = v72 + v73;
      v72 = v75;
    }
    v77 = v107 + v112[5] + 1;
    v5 = v101 == ++v107;
    *v76 = v77;
  }
  while ( !v5 );
  v78 = v112;
  v12 = (_BYTE *)v106;
  a1 = v105;
  v112[8] = v101;
  v79 = v96;
  v78[13] = 0;
  v78[9] = v79;
  v78[10] = v92;
  v78[12] = v94;
LABEL_59:
  v33 = v112;
  v112[14] = 0;
  v33[15] = 0;
  msg = nl_find_msg(0, v114);
  if ( msg != -1 )
  {
    result = (_DWORD *)_gettext_extract_plural(msg, v112 + 24, v112 + 25);
    goto LABEL_27;
  }
LABEL_157:
  v36 = v112;
LABEL_78:
  v31 = v36[4];
LABEL_55:
  free(v31);
  if ( v110 )
    munmap((int)v12, (int)v108);
  else
    free(v12);
  result = (_DWORD *)free(v112);
  a1[2] = 0;
LABEL_27:
  v6 = dword_80EC248;
LABEL_28:
  a1[1] = 1;
LABEL_29:
  dword_80EC248 = v6 - 1;
  if ( v6 == 1 )
  {
    dword_80EC24C = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --lock_9614 )
      return (_DWORD *)_lll_unlock_wake_private(&lock_9614);
  }
  return result;
}
// 804AD94: variable 'a2' is possibly undefined
// 804AE5E: variable 'v11' is possibly undefined
// 804AF4D: variable 'v10' is possibly undefined
// 8049940: using guessed type _DWORD __stdcall nl_find_msg(_DWORD, _DWORD);
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EC244: using guessed type int lock_9614;
// 80EC248: using guessed type int dword_80EC248;
// 80EC24C: using guessed type int dword_80EC24C;
// 804AD30: using guessed type char var_78[44];

//----- (0804C3C0) --------------------------------------------------------
int __cdecl alias_compare(_DWORD *a1, _DWORD *a2)
{
  return j_strcasecmp_l(*a1, *a2, nl_C_locobj);
}
// 8048240: using guessed type int __cdecl j_strcasecmp_l(_DWORD, _DWORD, _DWORD);
// 80CC680: using guessed type void **nl_C_locobj[6];

//----- (0804C3E0) --------------------------------------------------------
int __usercall read_alias_file@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>, long double a3@<st0>)
{
  void *v3; // esp
  _WORD *v4; // eax
  int *v5; // eax
  int *v6; // edi
  int v7; // eax
  int v8; // edx
  char *v9; // esi
  _WORD *v10; // eax
  char v11; // dl
  int v12; // edx
  unsigned __int8 *v13; // ebx
  unsigned __int8 *v14; // edx
  int v15; // ecx
  char v16; // dl
  unsigned __int8 v17; // dl
  _BYTE *v18; // ecx
  int v19; // edx
  int v20; // ecx
  _DWORD *v21; // edi
  int v22; // ecx
  _BYTE *v23; // eax
  _BYTE *v24; // edx
  int *v26; // ebx
  int v27; // edx
  int v28; // edi
  int v29; // eax
  int v30; // edi
  unsigned int v31; // eax
  int v32; // eax
  int v33; // edi
  int v34; // edx
  _DWORD *v35; // eax
  int v36; // [esp+0h] [ebp-1D8h] BYREF
  int v37; // [esp+4h] [ebp-1D4h]
  int v38; // [esp+8h] [ebp-1D0h]
  int v39; // [esp+Ch] [ebp-1CCh]
  unsigned int v40; // [esp+10h] [ebp-1C8h]
  int v41; // [esp+14h] [ebp-1C4h]
  int v42; // [esp+18h] [ebp-1C0h]
  unsigned int v43; // [esp+1Ch] [ebp-1BCh]
  unsigned int v44; // [esp+20h] [ebp-1B8h]
  int v45; // [esp+24h] [ebp-1B4h]
  int v46; // [esp+28h] [ebp-1B0h]
  int *v47; // [esp+2Ch] [ebp-1ACh]
  char v48[424]; // [esp+30h] [ebp-1A8h] BYREF

  v3 = alloca(a2 + 29);
  v4 = mempcpy(&v36, a1, a2);
  mempcpy(v4, "/locale.alias", 0xEu);
  v5 = (int *)fopen((int)&v36, "rce");
  v6 = v5;
  v47 = v5;
  if ( !v5 )
    return 0;
  v7 = *v5;
  v8 = v7;
  BYTE1(v8) = BYTE1(v7) | 0x80;
  *v6 = v8;
  if ( (v7 & 0x10) != 0 )
  {
    fclose(v47);
    return 0;
  }
  v39 = 0;
  while ( fgets_unlocked(v48, 400, v47) )
  {
    v9 = v48;
    v46 = j_strchr(v48, 10);
    v10 = (_WORD *)__readgsdword(0xFFFFFFF8);
    v11 = v48[0];
    if ( (v10[(unsigned __int8)v48[0]] & 0x2000) != 0 )
    {
      do
        v11 = *++v9;
      while ( (v10[(unsigned __int8)*v9] & 0x2000) != 0 );
    }
    if ( !v11 || v11 == 35 )
      goto LABEL_26;
    v12 = (unsigned __int8)v9[1];
    v13 = (unsigned __int8 *)(v9 + 1);
    if ( (_BYTE)v12 )
    {
      while ( (v10[v12] & 0x2000) == 0 )
      {
        v12 = *++v13;
        if ( !(_BYTE)v12 )
          goto LABEL_31;
      }
      v14 = v13++;
      v15 = v14[1];
      *v14 = 0;
      v16 = v15;
      if ( (v10[v15] & 0x2000) != 0 )
      {
        do
LABEL_14:
          v16 = *++v13;
        while ( (v10[*v13] & 0x2000) != 0 );
      }
      if ( v16 )
      {
        v17 = v13[1];
        v18 = v13 + 1;
        if ( v17 )
        {
          while ( (v10[v17] & 0x2000) == 0 )
          {
            v17 = *++v18;
            if ( !*v18 )
              goto LABEL_22;
          }
          *v18 = 0;
          if ( v17 == 10 )
            v18[1] = 10;
        }
LABEL_22:
        v45 = nmap;
        if ( nmap >= (unsigned int)maxmap )
        {
          if ( maxmap )
          {
            v30 = 2 * maxmap;
            v31 = 16 * maxmap;
          }
          else
          {
            v31 = 800;
            v30 = 100;
          }
          v32 = realloc((_BYTE *)map, v31);
          if ( !v32 )
            break;
          map = v32;
          maxmap = v30;
        }
        v44 = strlen(v9) + 1;
        v43 = strlen(v13) + 1;
        v42 = string_space_act;
        v41 = string_space_act + v44;
        v40 = string_space_act + v44 + v43;
        if ( v40 > string_space_max )
        {
          v27 = v43 + v44;
          if ( v43 + v44 < 0x400 )
            v27 = 1024;
          v28 = string_space;
          v38 = v27 + string_space_max;
          v29 = realloc((_BYTE *)string_space, v27 + string_space_max);
          v19 = v29;
          if ( !v29 )
            break;
          v20 = map;
          if ( v28 != v29 && v45 )
          {
            v36 = v29;
            v33 = v29 - v28;
            v37 = map + 8 * v45;
            v34 = v37;
            v35 = (_DWORD *)map;
            do
            {
              *v35 += v33;
              v35[1] += v33;
              v35 += 2;
            }
            while ( v35 != (_DWORD *)v34 );
            v19 = v36;
          }
          string_space = v19;
          string_space_max = v38;
        }
        else
        {
          v19 = string_space;
          v20 = map;
        }
        v21 = (_DWORD *)(v20 + 8 * v45);
        v22 = v42;
        v42 = v19;
        v23 = memcpy((_BYTE *)(v19 + v22), v9, v44);
        v24 = (_BYTE *)(v41 + v42);
        *v21 = v23;
        v21[1] = memcpy(v24, v13, v43);
        ++v39;
        string_space_act = v40;
        nmap = v45 + 1;
      }
LABEL_26:
      if ( !v46 )
        goto LABEL_33;
      goto LABEL_27;
    }
LABEL_31:
    if ( (*v10 & 0x2000) != 0 )
      goto LABEL_14;
    if ( !v46 )
    {
LABEL_33:
      v26 = v47;
      while ( fgets_unlocked(v48, 400, v26) && !j_strchr(v48, 10) )
        ;
    }
LABEL_27:
    if ( (*(_BYTE *)v47 & 0x10) != 0 )
      break;
  }
  fclose(v47);
  if ( v39 )
    qsort(a3, (char *)map, nmap, 8u, (int (__cdecl *)(char *, char *, int))alias_compare);
  return v39;
}
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 80EC254: using guessed type int maxmap;
// 80EC258: using guessed type int nmap;
// 80EC25C: using guessed type int string_space_max;
// 80EC260: using guessed type int string_space_act;
// 80ECD8C: using guessed type int map;
// 80ECD90: using guessed type int string_space;

//----- (0804C840) --------------------------------------------------------
int __usercall nl_expand_alias@<eax>(long double a1@<st0>, int a2)
{
  bool v3; // zf
  unsigned int v4; // ebp
  unsigned int v5; // edi
  unsigned int v6; // esi
  _DWORD *v7; // ebx
  int v8; // eax
  int v9; // edi
  char v10; // cl
  _BYTE *v11; // edx
  _BYTE *v12; // eax
  char v13; // cl
  _BYTE *i; // edx
  int v15; // edx
  int v17; // [esp+Ch] [ebp-20h]

  _ECX = 1;
  v3 = __readgsdword(0xCu) == 0;
  if ( !v3 )
    __asm { lock }
  __asm { cmpxchg ds:lock, ecx }
  if ( !v3 )
    _lll_lock_wait_private(0, &lock);
  if ( !locale_alias_path_9109 )
    locale_alias_path_9109 = (int)"/usr/share/locale";
LABEL_7:
  v4 = nmap;
  if ( !nmap )
    goto LABEL_13;
  v5 = 0;
  v17 = map;
  do
  {
    while ( 1 )
    {
      v6 = (v4 + v5) >> 1;
      v7 = (_DWORD *)(v17 + 8 * v6);
      v8 = j_strcasecmp_l(a2, *v7, nl_C_locobj);
      if ( v8 < 0 )
        break;
      if ( !v8 )
      {
        v15 = v7[1];
        goto LABEL_25;
      }
      v5 = v6 + 1;
      if ( v4 <= v6 + 1 )
        goto LABEL_13;
    }
    v4 = (v4 + v5) >> 1;
  }
  while ( v6 > v5 );
LABEL_13:
  while ( 1 )
  {
    v9 = locale_alias_path_9109;
    v10 = *(_BYTE *)locale_alias_path_9109;
    if ( !*(_BYTE *)locale_alias_path_9109 )
      break;
    while ( 1 )
    {
      v11 = (_BYTE *)(v9 + 1);
      v12 = (_BYTE *)v9;
      if ( v10 == 58 )
      {
        do
        {
          v12 = v11++;
          v13 = *(v11 - 1);
        }
        while ( v13 == 58 );
        if ( !v13 )
        {
LABEL_23:
          locale_alias_path_9109 = (int)v12;
          goto LABEL_24;
        }
      }
      for ( i = v12 + 1; ; ++i )
      {
        v10 = *i;
        v9 = (int)i;
        if ( !*i || v10 == 58 )
          break;
      }
      if ( i > v12 )
        break;
      v12 = i;
      if ( !v10 )
        goto LABEL_23;
    }
    locale_alias_path_9109 = (int)i;
    if ( read_alias_file(v12, i - v12, a1) )
      goto LABEL_7;
  }
LABEL_24:
  v15 = 0;
LABEL_25:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --lock )
    _lll_unlock_wake_private(&lock);
  return v15;
}
// 804C956: variable 'v15' is possibly undefined
// 8048240: using guessed type int __cdecl j_strcasecmp_l(_DWORD, _DWORD, _DWORD);
// 80CC680: using guessed type void **nl_C_locobj[6];
// 80EC250: using guessed type int locale_alias_path_9109;
// 80EC258: using guessed type int nmap;
// 80EC264: using guessed type int lock;
// 80ECD8C: using guessed type int map;

//----- (0804C990) --------------------------------------------------------
_DWORD *__cdecl nl_make_l10nflist(
        _DWORD *a1,
        _BYTE *a2,
        unsigned int a3,
        int a4,
        _BYTE *a5,
        _BYTE *a6,
        _BYTE *a7,
        _BYTE *a8,
        _BYTE *a9,
        _BYTE *a10,
        int a11)
{
  int v11; // edi
  int v12; // esi
  unsigned int v13; // ebx
  int v14; // edi
  unsigned int v15; // ebx
  int v16; // esi
  unsigned int v17; // edi
  int v18; // ebx
  _BYTE *v19; // eax
  _BYTE *v20; // edi
  unsigned int v21; // ebx
  _BYTE *v22; // esi
  int v23; // eax
  _BYTE *v24; // eax
  _BYTE *v25; // eax
  _DWORD *v26; // esi
  _DWORD *v27; // ebx
  int v28; // eax
  unsigned int v29; // ebx
  int v30; // esi
  _BYTE *v31; // ebp
  int v32; // eax
  signed int v33; // edx
  _DWORD *v34; // eax
  _DWORD *v35; // esi
  unsigned int v36; // ebp
  _BYTE *v37; // edi
  int v38; // eax
  _BOOL4 v39; // eax
  unsigned int v40; // ebx
  _BYTE *v41; // ebp
  int v42; // edi
  int v43; // eax
  int v44; // edi
  int v45; // ebx
  _BYTE *v46; // ebp
  int v48; // eax
  int v49; // eax
  _DWORD *v50; // eax
  _DWORD *v51; // [esp+10h] [ebp-2Ch]
  unsigned int v52; // [esp+10h] [ebp-2Ch]
  _DWORD *v53; // [esp+14h] [ebp-28h]
  int v54; // [esp+1Ch] [ebp-20h]

  v11 = strlen(a5);
  if ( (a4 & 4) != 0 )
    v12 = strlen(a6) + 1;
  else
    v12 = 0;
  v13 = v11 + a3 + 2;
  v14 = 0;
  if ( (a4 & 2) != 0 )
    v14 = strlen(a7) + 1;
  v15 = v12 + v13;
  v16 = 0;
  if ( (a4 & 1) != 0 )
    v16 = strlen(a8) + 1;
  v17 = v15 + v14;
  v18 = 0;
  if ( (a4 & 8) != 0 )
    v18 = strlen(a9) + 1;
  v54 = strlen(a10);
  v19 = (_BYTE *)malloc(v54 + v16 + v17 + v18);
  v20 = v19;
  if ( !v19 )
    return 0;
  memcpy(v19, a2, a3);
  if ( a3 )
  {
    v21 = a3;
    v22 = v20;
    while ( 1 )
    {
      v23 = strlen(v22);
      v21 += ~v23;
      if ( !v21 )
        break;
      v24 = &v22[v23];
      v22 = v24 + 1;
      *v24 = 58;
    }
  }
  v20[a3 - 1] = 47;
  v25 = (_BYTE *)j_stpcpy(&v20[a3], a5);
  if ( (a4 & 4) != 0 )
  {
    *v25 = 95;
    v25 = (_BYTE *)j_stpcpy(v25 + 1, a6);
  }
  if ( (a4 & 2) != 0 )
  {
    *v25 = 46;
    v25 = (_BYTE *)j_stpcpy(v25 + 1, a7);
  }
  if ( (a4 & 1) != 0 )
  {
    *v25 = 46;
    v25 = (_BYTE *)j_stpcpy(v25 + 1, a8);
  }
  if ( (a4 & 8) != 0 )
  {
    *v25 = 64;
    v25 = (_BYTE *)j_stpcpy(v25 + 1, a9);
  }
  *v25 = 47;
  memcpy(v25 + 1, a10, v54 + 1);
  v53 = (_DWORD *)*a1;
  if ( *a1 )
  {
    v26 = (_DWORD *)*a1;
    v27 = 0;
    while ( 1 )
    {
      if ( *v26 )
      {
        v28 = j_strcmp(*v26, v20);
        if ( !v28 )
          goto LABEL_61;
        if ( v28 < 0 )
        {
LABEL_29:
          v51 = v27;
          goto LABEL_30;
        }
        v27 = v26;
      }
      v26 = (_DWORD *)v26[3];
      if ( !v26 )
        goto LABEL_29;
    }
  }
  v51 = 0;
LABEL_30:
  if ( a11 )
  {
    v29 = a3;
    v30 = 0;
    v31 = a2;
    if ( a3 )
    {
      do
      {
        ++v30;
        v32 = strlen(v31);
        v31 += v32 + 1;
        v29 += ~v32;
      }
      while ( v29 );
      v33 = (a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555);
      v34 = (_DWORD *)malloc(
                        4
                      * (v30 << ((((v33 & 0x33)
                                 + ((v33 >> 2) & 0x33)
                                 + ((int)((v33 & 0x3333) + ((v33 >> 2) & 0xFFFFF333)) >> 4)) & 0xF)
                               + (((unsigned __int16)((v33 & 0x3333)
                                                    + ((v33 >> 2) & 0xF333)
                                                    + ((int)((v33 & 0x3333) + ((v33 >> 2) & 0xFFFFF333)) >> 4)) >> 8) & 0xF)))
                      + 20);
      v35 = v34;
      if ( v34 )
      {
        *v34 = v20;
        v36 = a3;
        v37 = a2;
        do
        {
          ++v29;
          v38 = strlen(v37);
          v37 += v38 + 1;
          v36 += ~v38;
        }
        while ( v36 );
        v39 = 1;
        if ( v29 == 1 )
          v39 = (a4 & 3) == 3;
        goto LABEL_38;
      }
    }
    else
    {
      v50 = (_DWORD *)malloc(20);
      v35 = v50;
      if ( v50 )
      {
        *v50 = v20;
        v39 = 1;
LABEL_38:
        v35[1] = v39;
        v35[2] = 0;
        if ( v51 )
        {
          v35[3] = v51[3];
          v51[3] = v35;
        }
        else
        {
          v35[3] = v53;
          *a1 = v35;
        }
        if ( a3 )
        {
          v40 = a3;
          v41 = a2;
          v42 = 0;
          do
          {
            ++v42;
            v43 = strlen(v41);
            v41 += v43 + 1;
            v40 += ~v43;
          }
          while ( v40 );
          v44 = a4 - (v42 == 1);
        }
        else
        {
          v44 = a4;
        }
        if ( v44 >= 0 )
        {
          v45 = 0;
          v52 = (unsigned int)&a2[a3];
LABEL_47:
          while ( 1 )
          {
            v46 = 0;
            if ( (v44 & ~a4) == 0 )
              break;
            if ( --v44 == -1 )
              goto LABEL_49;
          }
          while ( 1 )
          {
            if ( v46 )
            {
              if ( (unsigned int)v46 >= v52 || (v48 = j_rawmemchr(v46, 0), v48 + 1 >= v52) || v48 == -1 )
              {
LABEL_46:
                if ( --v44 == -1 )
                  goto LABEL_49;
                goto LABEL_47;
              }
              v46 = (_BYTE *)(v48 + 1);
            }
            else
            {
              if ( !a3 )
                goto LABEL_46;
              v46 = a2;
            }
            ++v45;
            v49 = strlen(v46);
            v35[v45 + 3] = nl_make_l10nflist(a1, v46, v49 + 1, v44, a5, a6, a7, a8, a9, a10, 1);
          }
        }
        v45 = 0;
LABEL_49:
        v35[v45 + 4] = 0;
        return v35;
      }
    }
    v35 = 0;
    free(v20);
    return v35;
  }
  v26 = 0;
LABEL_61:
  free(v20);
  return v26;
}
// 80481E0: using guessed type int __cdecl j_rawmemchr(_DWORD, _DWORD);
// 8048210: using guessed type int __cdecl j_stpcpy(_DWORD, _DWORD);
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0804CE80) --------------------------------------------------------
unsigned __int8 *__cdecl nl_normalize_codeset(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *v2; // eax
  int v3; // ebx
  int v4; // ecx
  unsigned __int8 *v5; // esi
  int v6; // edx
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // edx
  int v10; // eax
  unsigned __int8 v11; // cl
  _DWORD *v13; // eax
  unsigned __int8 *v14; // [esp+Ch] [ebp-20h]

  if ( a2 )
  {
    v2 = a1;
    v3 = 1;
    v4 = 0;
    v5 = &a1[a2];
    do
    {
      v6 = *v2;
      if ( (byte_80C2440[2 * v6] & 8) != 0 )
      {
        ++v4;
        if ( (unsigned int)(v6 - 48) >= 0xA )
          v3 = 0;
      }
      ++v2;
    }
    while ( v5 != v2 );
    if ( !v3 )
    {
      v7 = (unsigned __int8 *)malloc(v4 + 1);
      v8 = v7;
      if ( v7 )
      {
        v14 = v7;
LABEL_10:
        v9 = a1;
        while ( 1 )
        {
          while ( 1 )
          {
            v10 = *v9;
            v11 = *v9;
            if ( (byte_80C2440[2 * v10 + 1] & 4) == 0 )
              break;
            *v8++ = dword_80C1540[v10];
LABEL_12:
            if ( v5 == ++v9 )
              goto LABEL_16;
          }
          if ( (unsigned int)(v10 - 48) > 9 )
            goto LABEL_12;
          ++v9;
          *v8++ = v11;
          if ( v5 == v9 )
            goto LABEL_16;
        }
      }
      return 0;
    }
    v13 = (_DWORD *)malloc(v4 + 4);
  }
  else
  {
    v13 = (_DWORD *)malloc(4);
  }
  v14 = (unsigned __int8 *)v13;
  if ( v13 )
  {
    *v13 = 7304041;
    v8 = (unsigned __int8 *)v13 + 3;
    if ( a2 )
    {
      v5 = &a1[a2];
      goto LABEL_10;
    }
LABEL_16:
    *v8 = 0;
  }
  return v14;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80C1540: using guessed type int dword_80C1540[256];
// 80C2440: using guessed type _BYTE byte_80C2440[512];

//----- (0804CFA0) --------------------------------------------------------
int __cdecl nl_explode_name(
        unsigned __int8 *a1,
        unsigned __int8 **a2,
        _DWORD *a3,
        unsigned __int8 **a4,
        _DWORD *a5,
        unsigned __int8 **a6)
{
  unsigned __int8 **v6; // edx
  unsigned __int8 v7; // al
  unsigned __int8 *v8; // ebx
  unsigned __int8 v9; // al
  unsigned __int8 *v10; // ecx
  unsigned __int8 *v11; // ebx
  int v12; // esi
  unsigned __int8 *v13; // ecx
  _BYTE *i; // edi
  unsigned __int8 *v15; // ecx
  int v16; // eax
  unsigned __int8 *v18; // [esp+8h] [ebp-24h]

  v6 = a4;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  *a2 = a1;
  v7 = *a1;
  if ( (*a1 & 0xBF) == 0 || v7 == 95 || v7 == 46 )
  {
LABEL_38:
    v12 = 0;
    v11 = (unsigned __int8 *)j_rawmemchr(a1, 0);
    v6 = a4;
    v9 = *v11;
  }
  else
  {
    v8 = a1;
    while ( 1 )
    {
      v9 = v8[1];
      v10 = v8 + 1;
      if ( !v9 || v9 == 95 )
        break;
      ++v8;
      if ( v9 == 64 || v9 == 46 )
      {
        if ( a1 == v10 )
          goto LABEL_38;
LABEL_26:
        v12 = 0;
        v11 = v10;
        if ( v9 != 46 )
          goto LABEL_27;
        goto LABEL_16;
      }
    }
    if ( a1 == v10 )
      goto LABEL_38;
    if ( v9 != 95 )
      goto LABEL_26;
    v11 = v8 + 2;
    *v10 = 0;
    *a4 = v11;
    v9 = v10[1];
    if ( (v9 & 0xBF) != 0 )
    {
      do
      {
        if ( v9 == 46 )
          break;
        v9 = *++v11;
      }
      while ( (*v11 & 0xBF) != 0 );
    }
    v12 = 4;
    if ( v9 != 46 )
      goto LABEL_27;
LABEL_16:
    v13 = v11 + 1;
    *v11 = 0;
    *a5 = v11 + 1;
    v9 = v11[1];
    if ( (v9 & 0xBF) == 0 )
    {
      v12 |= 2u;
      ++v11;
      goto LABEL_27;
    }
    for ( i = v11 + 1; ; ++i )
    {
      v11 = i + 1;
      if ( (i[1] & 0xBF) == 0 )
        break;
    }
    if ( v13 == v11 )
    {
      v12 |= 2u;
      goto LABEL_27;
    }
    v15 = nl_normalize_codeset(v13, v11 - v13);
    *a6 = v15;
    if ( !v15 )
      return -1;
    v18 = v15;
    v16 = j_strcmp(*a5, v15);
    v6 = a4;
    if ( v16 )
    {
      v12 |= 3u;
    }
    else
    {
      v12 |= 2u;
      free(v18);
      v6 = a4;
    }
    v9 = i[1];
  }
LABEL_27:
  if ( v9 == 64 )
  {
    *v11 = 0;
    *a3 = v11 + 1;
    if ( v11[1] )
      v12 |= 8u;
  }
  if ( *v6 && !**v6 )
    v12 &= ~4u;
  if ( *a5 && !*(_BYTE *)*a5 )
    return v12 & 0xFFFFFFFD;
  return v12;
}
// 80481E0: using guessed type int __cdecl j_rawmemchr(_DWORD, _DWORD);
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0804D1D0) --------------------------------------------------------
_DWORD *__usercall _gettext_free_exp@<eax>(_DWORD *result@<eax>)
{
  _DWORD *v1; // ebx
  int v2; // eax

  if ( result )
  {
    v1 = result;
    v2 = *result;
    if ( v2 != 2 )
    {
      if ( v2 != 3 )
      {
        if ( v2 != 1 )
          return (_DWORD *)free(v1);
LABEL_9:
        _gettext_free_exp();
        return (_DWORD *)free(v1);
      }
      _gettext_free_exp();
    }
    _gettext_free_exp();
    goto LABEL_9;
  }
  return result;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0804D220) --------------------------------------------------------
_DWORD *__usercall new_exp@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v5; // ebx
  _DWORD *v6; // edx
  int v8; // eax
  _DWORD *result; // eax
  int i; // ebx
  _DWORD *v11; // [esp+Ch] [ebp-20h]

  v5 = a1 - 1;
  if ( a1 - 1 < 0 )
  {
    result = (_DWORD *)malloc(20);
    if ( result )
    {
      *result = a1;
      result[1] = a2;
      return result;
    }
    return 0;
  }
  v6 = *(_DWORD **)(a3 + 4 * v5);
  if ( !v6 )
    goto LABEL_11;
  v8 = a1 - 1;
  while ( --v8 != -1 )
  {
    if ( !*(_DWORD *)(a3 + 4 * v8) )
      goto LABEL_11;
  }
  v11 = *(_DWORD **)(a3 + 4 * v5);
  result = (_DWORD *)malloc(20);
  v6 = v11;
  if ( !result )
  {
LABEL_11:
    while ( 1 )
    {
      --v5;
      _gettext_free_exp(v6);
      if ( v5 == -1 )
        break;
      v6 = *(_DWORD **)(a3 + 4 * v5);
    }
    return 0;
  }
  *result = a1;
  result[1] = a2;
  result[v5 + 2] = v11;
  for ( i = v5 - 1; i != -1; --i )
    result[i + 2] = *(_DWORD *)(a3 + 4 * i);
  return result;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);

//----- (0804D2D0) --------------------------------------------------------
int __cdecl _gettextparse(char **a1)
{
  __int16 *v1; // ebx
  char *v2; // ebp
  __int16 *v3; // edi
  int v4; // esi
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // eax
  unsigned int v9; // eax
  __int16 *v10; // eax
  __int16 *v11; // ebp
  int v12; // ebx
  int v14; // eax
  int v15; // edx
  _DWORD *v16; // eax
  int v17; // edx
  int v18; // eax
  int v19; // ecx
  unsigned int v20; // esi
  int v21; // ebp
  int v22; // edx
  __int16 *v23; // eax
  unsigned int v24; // ebx
  unsigned int v25; // ebp
  char *v26; // ecx
  __int16 *v27; // edx
  char *v28; // ecx
  char v29; // dl
  char v30; // dl
  _DWORD *v31; // eax
  _DWORD *v32; // eax
  int v33; // eax
  int v34; // edx
  _DWORD *v35; // eax
  int v36; // eax
  int v37; // eax
  int v38; // ecx
  int v39; // ecx
  int v40; // edx
  char *v41; // ebx
  char *v42; // edx
  int v43; // [esp+4h] [ebp-4F8h]
  int v44; // [esp+8h] [ebp-4F4h]
  _DWORD *v45; // [esp+8h] [ebp-4F4h]
  int v46; // [esp+8h] [ebp-4F4h]
  char *v47; // [esp+8h] [ebp-4F4h]
  unsigned int v48; // [esp+Ch] [ebp-4F0h]
  char *v49; // [esp+10h] [ebp-4ECh]
  int v50; // [esp+14h] [ebp-4E8h]
  __int16 *v51; // [esp+18h] [ebp-4E4h]
  char v52; // [esp+18h] [ebp-4E4h]
  __int16 *v53; // [esp+18h] [ebp-4E4h]
  int v54; // [esp+1Ch] [ebp-4E0h]
  int v55; // [esp+24h] [ebp-4D8h] BYREF
  int v56; // [esp+28h] [ebp-4D4h]
  int v57; // [esp+2Ch] [ebp-4D0h]
  __int16 v58[200]; // [esp+30h] [ebp-4CCh] BYREF
  char v59[828]; // [esp+1C0h] [ebp-33Ch] BYREF

  v1 = v58;
  v58[0] = 0;
  v50 = 0;
  v43 = -2;
  v49 = v59;
  v2 = v59;
  v48 = 200;
  v3 = v58;
  v4 = 0;
  while ( 1 )
  {
    v5 = yypact[v4];
    if ( v5 != -10 )
    {
      if ( v43 == -2 )
      {
        v28 = *a1;
        v29 = **a1;
        v52 = v29;
        if ( v29 )
        {
          if ( v29 == 32 || v29 == 9 )
          {
            do
            {
              v30 = *++v28;
              if ( !*v28 )
                goto LABEL_54;
            }
            while ( v30 == 32 || v30 == 9 );
            v52 = *v28;
          }
          v47 = v28 + 1;
          v43 = v52;
          switch ( v52 )
          {
            case 0:
            case 10:
            case 59:
              break;
            case 33:
              if ( v28[1] == 61 )
              {
                v44 = 6;
                v54 = 13;
                v43 = 258;
                *a1 = v28 + 2;
              }
              else
              {
                v44 = 10;
                v43 = 33;
                *a1 = v28 + 1;
              }
              goto LABEL_6;
            case 37:
              v44 = 9;
              v54 = 5;
              v43 = 261;
              *a1 = v28 + 1;
              goto LABEL_6;
            case 38:
            case 124:
              if ( v52 != v28[1] )
                goto LABEL_72;
              v47 = v28 + 2;
LABEL_85:
              *a1 = v47;
              goto LABEL_4;
            case 40:
            case 41:
            case 58:
            case 63:
            case 110:
              goto LABEL_85;
            case 42:
              v44 = 9;
              v54 = 3;
              v43 = 261;
              *a1 = v28 + 1;
              goto LABEL_6;
            case 43:
              v44 = 8;
              v54 = 6;
              v43 = 260;
              *a1 = v28 + 1;
              goto LABEL_6;
            case 45:
              v44 = 8;
              v54 = 7;
              v43 = 260;
              *a1 = v28 + 1;
              goto LABEL_6;
            case 47:
              v44 = 9;
              v54 = 4;
              v43 = 261;
              *a1 = v28 + 1;
              goto LABEL_6;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              v39 = v28[1];
              v54 = v52 - 48;
              if ( (unsigned __int8)(v39 - 48) <= 9u )
              {
                v53 = v1;
                v40 = v54;
                v41 = v47;
                do
                {
                  ++v41;
                  v40 = v39 + 10 * v40 - 48;
                  v39 = *v41;
                }
                while ( (unsigned __int8)(v39 - 48) <= 9u );
                v47 = v41;
                v1 = v53;
                v54 = v40;
              }
              v42 = v47;
              v44 = 11;
              v43 = 262;
              *a1 = v42;
              goto LABEL_6;
            case 60:
              v44 = 7;
              if ( v28[1] == 61 )
              {
                v54 = 10;
                v43 = 259;
                *a1 = v28 + 2;
              }
              else
              {
                v54 = 8;
                v43 = 259;
                *a1 = v28 + 1;
              }
              goto LABEL_6;
            case 61:
              if ( v28[1] != 61 )
                goto LABEL_72;
              v44 = 6;
              v54 = 12;
              v43 = 258;
              *a1 = v28 + 2;
              goto LABEL_6;
            case 62:
              v44 = 7;
              if ( v28[1] == 61 )
              {
                v54 = 11;
                v43 = 259;
                *a1 = v28 + 2;
              }
              else
              {
                v54 = 9;
                v43 = 259;
                *a1 = v28 + 1;
              }
              goto LABEL_6;
            default:
LABEL_72:
              v44 = 1;
              v43 = 256;
              *a1 = v28 + 1;
              goto LABEL_6;
          }
        }
LABEL_54:
        v44 = 0;
        v43 = 0;
        *a1 = v28;
      }
      else
      {
LABEL_4:
        if ( v43 <= 0 )
        {
          v44 = 0;
          v43 = 0;
        }
        else
        {
          v44 = (unsigned __int8)yytranslate[v43];
        }
      }
LABEL_6:
      v6 = v5 + v44;
      if ( (unsigned int)(v5 + v44) <= 0x36 && v44 == yycheck[v6] )
      {
        v4 = (unsigned __int8)yytable[v6];
        if ( yytable[v6] )
        {
          v43 = -2;
          v2 += 4;
          v50 = (v50 == 0) + v50 - 1;
          *(_DWORD *)v2 = v54;
          v10 = v1;
          goto LABEL_30;
        }
        v17 = -16;
        v19 = 0;
        v45 = (_DWORD *)*((_DWORD *)v2 + 1);
        v18 = 0;
        goto LABEL_27;
      }
    }
    v7 = (unsigned __int8)yydefact[v4];
    if ( yydefact[v4] )
    {
      v8 = (unsigned __int8)yyr2[v7];
      v45 = *(_DWORD **)&v2[4 * (1 - v8)];
      switch ( (char)v7 )
      {
        case 2:
          if ( !*(_DWORD *)v2 )
            goto LABEL_20;
          v4 = -10;
          v17 = 1;
          a1[1] = *(char **)v2;
          v18 = -1;
          v19 = -4;
          goto LABEL_27;
        case 3:
          v33 = *(_DWORD *)v2;
          v4 = -1;
          v34 = *((_DWORD *)v2 - 2);
          v55 = *((_DWORD *)v2 - 4);
          v57 = v33;
          v56 = v34;
          v35 = new_exp(3, 16, (int)&v55);
          v17 = 2;
          v45 = v35;
          v19 = -20;
          v18 = -5;
          goto LABEL_27;
        case 4:
          v36 = *(_DWORD *)v2;
          v55 = *((_DWORD *)v2 - 2);
          v56 = v36;
          v15 = 15;
          goto LABEL_25;
        case 5:
          v37 = *(_DWORD *)v2;
          v55 = *((_DWORD *)v2 - 2);
          v56 = v37;
          v15 = 14;
          goto LABEL_25;
        case 6:
        case 7:
        case 8:
        case 9:
          v14 = *(_DWORD *)v2;
          v15 = *((_DWORD *)v2 - 1);
          v55 = *((_DWORD *)v2 - 2);
          v56 = v14;
LABEL_25:
          v16 = new_exp(2, v15, (int)&v55);
          break;
        case 10:
          v4 = -1;
          v55 = *(_DWORD *)v2;
          v31 = new_exp(1, 2, (int)&v55);
          v17 = 2;
          v45 = v31;
          v19 = -8;
          v18 = -2;
          goto LABEL_27;
        case 11:
          v4 = -1;
          v45 = new_exp(0, 0, 0);
          v17 = 2;
          v18 = -1;
          v19 = -4;
          goto LABEL_27;
        case 12:
          v32 = new_exp(0, 1, 0);
          v45 = v32;
          v4 = -1;
          v17 = 2;
          if ( v32 )
            v32[2] = *(_DWORD *)v2;
          v18 = -1;
          v19 = -4;
          goto LABEL_27;
        case 13:
          v16 = (_DWORD *)*((_DWORD *)v2 - 1);
          break;
        default:
          v38 = 4 * v8;
          v18 = -1 * v8;
          v19 = -v38;
          v17 = (unsigned __int8)yyr1[v7] - 16;
          v4 = yypgoto[v17];
          goto LABEL_27;
      }
      v45 = v16;
      v4 = -1;
      v17 = 2;
      v18 = -3;
      v19 = -12;
LABEL_27:
      v10 = &v1[v18];
      v2 += v19 + 4;
      *(_DWORD *)v2 = v45;
      v20 = *v10 + v4;
      if ( v20 <= 0x36 && *v10 == yycheck[v20] )
        v4 = (unsigned __int8)yytable[v20];
      else
        v4 = yydefgoto[v17];
      goto LABEL_30;
    }
    if ( v50 == 3 )
    {
      if ( v43 > 0 )
      {
        v43 = -2;
        goto LABEL_14;
      }
      if ( !v43 )
      {
LABEL_20:
        v11 = v3;
        v12 = 1;
        goto LABEL_21;
      }
    }
LABEL_14:
    while ( 1 )
    {
      if ( v5 != -10 )
      {
        v9 = v5 + 1;
        if ( v9 <= 0x36 && yycheck[v9] == 1 )
        {
          v4 = (unsigned __int8)yytable[v9];
          if ( yytable[v9] )
            break;
        }
      }
      if ( v1 == v3 )
        goto LABEL_20;
      --v1;
      v2 -= 4;
      v5 = yypact[*v1];
    }
    v2 += 4;
    v50 = 3;
    *(_DWORD *)v2 = v54;
    v10 = v1;
LABEL_30:
    v1 = v10 + 1;
    v10[1] = v4;
    if ( v10 + 1 >= &v3[v48 - 1] )
      break;
LABEL_39:
    if ( v4 == 9 )
    {
      v11 = v3;
      v12 = 0;
      goto LABEL_21;
    }
  }
  v21 = v1 - v3 + 1;
  if ( v48 > 0x270F )
    goto LABEL_91;
  v22 = 10000;
  if ( 2 * v48 <= 0x2710 )
    v22 = 2 * v48;
  v48 = v22;
  v46 = 2 * v22;
  v23 = (__int16 *)malloc(6 * v22 + 3);
  if ( !v23 )
  {
LABEL_91:
    v11 = v3;
    v12 = 2;
    goto LABEL_21;
  }
  v24 = v21;
  v25 = 4 * v21;
  v51 = v23;
  memcpy(v23, v3, v24 * 2);
  memcpy((_BYTE *)v51 + ((v46 + 3) & 0xFFFFFFFC), v49, v25);
  v26 = (char *)v51 + ((v46 + 3) & 0xFFFFFFFC);
  v27 = v51;
  if ( v3 != v58 )
  {
    free(v3);
    v27 = v51;
    v26 = (char *)v51 + ((v46 + 3) & 0xFFFFFFFC);
  }
  v1 = &v27[v24 - 1];
  v2 = &v26[v25 - 4];
  if ( v1 < &v27[v46 / 2u - 1] )
  {
    v49 = v26;
    v3 = v27;
    goto LABEL_39;
  }
  v11 = v27;
  v12 = 1;
LABEL_21:
  if ( v11 != v58 )
    free(v11);
  return v12;
}
// 804D3E4: variable 'v54' is possibly undefined
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0804DB00) --------------------------------------------------------
int __usercall _gettext_extract_plural@<eax>(int result@<eax>, _DWORD *a2@<edx>, int *a3@<ecx>)
{
  char *v5; // ebp
  int v6; // esi
  char *v7; // ebp
  unsigned int v8; // edx
  char *v9; // [esp+4h] [ebp-28h] BYREF
  char *v10; // [esp+8h] [ebp-24h] BYREF
  int v11; // [esp+Ch] [ebp-20h]

  if ( !result )
    goto LABEL_11;
  v5 = (char *)result;
  v6 = strstr((char *)result, "plural=");
  result = strstr(v5, "nplurals=");
  if ( !v6 )
    goto LABEL_11;
  if ( !result )
    goto LABEL_11;
  v7 = (char *)(result + 9);
  result = *(unsigned __int8 *)(result + 9);
  if ( !(_BYTE)result )
    goto LABEL_11;
  v8 = __readgsdword(0xFFFFFFF8);
  while ( (*(_BYTE *)(v8 + 2 * (unsigned __int8)result + 1) & 0x20) != 0 )
  {
    result = (unsigned __int8)*++v7;
    if ( !(_BYTE)result )
      goto LABEL_11;
  }
  result -= 48;
  if ( (unsigned __int8)result <= 9u
    && (result = strtoul(v7, &v9, 10), v9 != v7)
    && (*a3 = result, v10 = (char *)(v6 + 7), (result = _gettextparse(&v10)) == 0) )
  {
    result = v11;
    *a2 = v11;
  }
  else
  {
LABEL_11:
    *a2 = &_gettext_germanic_plural;
    *a3 = 2;
  }
  return result;
}

//----- (0804DBD0) --------------------------------------------------------
unsigned int __cdecl _hash_string(unsigned __int8 *a1)
{
  unsigned int result; // eax
  int v3; // edx

  result = 0;
  while ( 1 )
  {
    v3 = *a1;
    if ( !(_BYTE)v3 )
      break;
    ++a1;
    result = v3 + 16 * result;
    if ( (result & 0xF0000000) != 0 )
      result = result & 0xFFFFFFF ^ ((result & 0xF0000000) >> 24);
  }
  return result;
}

//----- (0804DC10) --------------------------------------------------------
int setjmp(jmp_buf env)
{
  int v1; // ebx
  int v2; // ebp
  int v3; // edi
  int v4; // esi
  int result; // eax
  struct __jmp_buf_tag *__attribute__((__org_typedef(jmp_buf))) v6; // edx
  unsigned int retaddr; // [esp+0h] [ebp+0h]

  result = 0;
  v6 = env;
  env->__jmpbuf[0] = v1;
  v6->__jmpbuf[1] = v4;
  v6->__jmpbuf[2] = v3;
  v6->__jmpbuf[4] = __ROL4__(__readgsdword(0x18u) ^ (unsigned int)&env, 9);
  v6->__jmpbuf[5] = __ROL4__(__readgsdword(0x18u) ^ retaddr, 9);
  v6->__jmpbuf[3] = v2;
  v6->__mask_was_saved = 0;
  return result;
}
// 804DC16: variable 'v1' is possibly undefined
// 804DC18: variable 'v4' is possibly undefined
// 804DC1B: variable 'v3' is possibly undefined
// 804DC3F: variable 'v2' is possibly undefined

//----- (0804DC50) --------------------------------------------------------
void __usercall __noreturn abort(long double a1@<st0>)
{
  unsigned int v1; // edx
  bool v3; // zf
  int v4; // eax
  unsigned int v5; // edx
  bool v7; // zf
  int *v8; // eax
  int v9[32]; // [esp+4h] [ebp-118h] BYREF
  int v10[38]; // [esp+84h] [ebp-98h] BYREF

  v1 = __readgsdword(8u);
  if ( v1 != dword_80EC274 )
  {
    _ECX = 1;
    v3 = __readgsdword(0xCu) == 0;
    if ( !v3 )
      __asm { lock }
    __asm { cmpxchg ds:lock_0, ecx }
    if ( !v3 )
      _lll_lock_wait_private(0, &lock_0);
    dword_80EC274 = v1;
  }
  v4 = stage;
  ++dword_80EC270;
  if ( stage )
  {
    if ( stage != 1 )
      goto LABEL_9;
  }
  else
  {
    stage = 1;
    memset(v9, 0, sizeof(v9));
    v9[0] = 32;
    sigprocmask(1, v9);
    v4 = stage;
    if ( stage != 1 )
    {
LABEL_9:
      if ( v4 != 2 )
        goto LABEL_10;
      goto LABEL_18;
    }
  }
  stage = 2;
  IO_flush_all_lockp(a1, 0);
  v4 = stage;
  if ( stage != 2 )
  {
LABEL_10:
    if ( v4 != 3 )
    {
      if ( v4 != 4 )
        goto LABEL_12;
      goto LABEL_33;
    }
LABEL_30:
    stage = 4;
    memset(v10, 0, 0x8Cu);
    v8 = &v10[32];
    do
      *v8-- = -1;
    while ( v8 != v10 );
    v10[33] = 0;
    sigaction(6, v8, 0);
    v4 = stage;
    if ( stage != 4 )
    {
LABEL_12:
      if ( v4 != 5 )
        goto LABEL_13;
      goto LABEL_34;
    }
LABEL_33:
    stage = 5;
    fcloseall();
    v4 = stage;
    if ( stage != 5 )
    {
LABEL_13:
      if ( v4 != 6 )
        goto LABEL_14;
      goto LABEL_35;
    }
LABEL_34:
    stage = 6;
    raise();
    v4 = stage;
    if ( stage != 6 )
    {
LABEL_14:
      if ( v4 != 7 )
        __halt();
      stage = 8;
      exit(127);
    }
LABEL_35:
    __halt();
  }
LABEL_18:
  v3 = dword_80EC270-- == 1;
  stage = 0;
  if ( v3 )
  {
    dword_80EC274 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --lock_0 )
      _lll_unlock_wake_private(&lock_0);
  }
  raise();
  v5 = __readgsdword(8u);
  if ( v5 != dword_80EC274 )
  {
    _ECX = 1;
    v7 = __readgsdword(0xCu) == 0;
    if ( !v7 )
      __asm { lock }
    __asm { cmpxchg ds:lock_0, ecx }
    if ( !v7 )
      _lll_lock_wait_private(0, &lock_0);
    dword_80EC274 = v5;
  }
  ++dword_80EC270;
  goto LABEL_30;
}
// 804DC8C: variable 'v1' is possibly undefined
// 804DDBF: variable 'v5' is possibly undefined
// 8051380: using guessed type int fcloseall(void);
// 80EC26C: using guessed type int lock_0;
// 80EC270: using guessed type int dword_80EC270;
// 80EC274: using guessed type int dword_80EC274;
// 80EC278: using guessed type int stage;

//----- (0804DE80) --------------------------------------------------------
_BYTE *__usercall msort_with_tmp_part_0@<eax>(unsigned int *a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>)
{
  unsigned int v3; // edi
  unsigned int v4; // esi
  _DWORD *v5; // ebx
  _BYTE *v6; // edx
  unsigned int v7; // eax
  _DWORD *v8; // edi
  unsigned int v9; // ebp
  _QWORD *v10; // esi
  int v11; // eax
  unsigned int v12; // edi
  _DWORD *v13; // ebp
  _BYTE *i; // ebx
  _BYTE *v15; // esi
  _BYTE *v16; // eax
  _BYTE *v17; // ebp
  _WORD *v19; // eax
  _WORD *v20; // eax
  int v21; // eax
  __int64 v22; // xmm1_8
  int (__cdecl *v23)(_DWORD *, _DWORD *, unsigned int); // [esp+0h] [ebp-3Ch]
  unsigned int v24; // [esp+4h] [ebp-38h]
  unsigned int v25; // [esp+8h] [ebp-34h]
  unsigned int v26; // [esp+Ch] [ebp-30h]
  _BYTE *v27; // [esp+Ch] [ebp-30h]
  _BYTE *v28; // [esp+Ch] [ebp-30h]
  unsigned int v30; // [esp+14h] [ebp-28h]

  v3 = a3 >> 1;
  v4 = a3 - (a3 >> 1);
  v5 = &a2[(a3 >> 1) * *a1];
  if ( a3 >> 1 > 1 )
    msort_with_tmp_part_0(v3);
  if ( v4 > 1 )
    msort_with_tmp_part_0(v4);
  v6 = (_BYTE *)a1[4];
  v25 = *a1;
  v23 = (int (__cdecl *)(_DWORD *, _DWORD *, unsigned int))a1[2];
  v7 = a1[1];
  v24 = a1[3];
  if ( v7 == 1 )
  {
    if ( v4 && v3 )
    {
      v26 = v3;
      v8 = a2;
      v9 = v4;
      v10 = (_QWORD *)a1[4];
      do
      {
        if ( v23(v8, v5, v24) > 0 )
        {
          --v9;
          *v10 = *(_QWORD *)v5;
          v5 += 2;
        }
        else
        {
          v22 = *(_QWORD *)v8;
          --v26;
          v8 += 2;
          *v10 = v22;
        }
        ++v10;
      }
      while ( v26 && v9 );
      goto LABEL_51;
    }
LABEL_52:
    v17 = a2;
    goto LABEL_25;
  }
  if ( v7 )
  {
    if ( v7 == 2 )
    {
      v30 = v3;
      v12 = v4;
      v27 = a2;
      v13 = v5;
      for ( i = (_BYTE *)a1[4]; v30; i = v15 )
      {
        if ( !v12 )
          break;
        v15 = &i[v25];
        if ( v23(v27, v13, v24) <= 0 )
        {
          --v30;
          v16 = v27;
          v27 += v25;
        }
        else
        {
          v16 = v13;
          --v12;
          v13 = (_DWORD *)((char *)v13 + v25);
        }
        for ( ; v15 > i; *((_DWORD *)i - 1) = *((_DWORD *)v16 - 1) )
        {
          v16 += 4;
          i += 4;
        }
      }
      v4 = v12;
      v17 = v27;
      v3 = v30;
      v6 = i;
    }
    else
    {
      if ( v7 == 3 )
      {
        if ( v4 && v3 )
        {
          v26 = v3;
          v8 = a2;
          v9 = v4;
          v10 = (_QWORD *)a1[4];
          do
          {
            if ( v23((_DWORD *)*v8, (_DWORD *)*v5, v24) > 0 )
            {
              v11 = *v5;
              --v9;
              ++v5;
            }
            else
            {
              v11 = *v8;
              --v26;
              ++v8;
            }
            *(_DWORD *)v10 = v11;
            v10 = (_QWORD *)((char *)v10 + 4);
          }
          while ( v26 && v9 );
LABEL_51:
          v6 = v10;
          v4 = v9;
          v17 = v8;
          v3 = v26;
          goto LABEL_25;
        }
        goto LABEL_52;
      }
      v17 = a2;
LABEL_30:
      if ( v3 )
      {
        while ( v4 )
        {
          v28 = v6;
          if ( v23(v17, v5, v24) <= 0 )
          {
            --v3;
            v20 = mempcpy(v28, v17, v25);
            v17 += v25;
            v6 = v20;
            goto LABEL_30;
          }
          --v4;
          v19 = mempcpy(v28, v5, v25);
          v5 = (_DWORD *)((char *)v5 + v25);
          v6 = v19;
        }
      }
    }
  }
  else
  {
    v17 = a2;
    if ( v3 && v4 )
    {
      v26 = v3;
      v8 = a2;
      v9 = v4;
      v10 = (_QWORD *)a1[4];
      do
      {
        if ( v23(v8, v5, v24) > 0 )
        {
          v21 = *v5;
          --v9;
          ++v5;
        }
        else
        {
          v21 = *v8;
          --v26;
          ++v8;
        }
        *(_DWORD *)v10 = v21;
        v10 = (_QWORD *)((char *)v10 + 4);
      }
      while ( v26 && v9 );
      goto LABEL_51;
    }
  }
LABEL_25:
  if ( v3 )
    memcpy(v6, v17, v25 * v3);
  return memcpy(a2, (_BYTE *)a1[4], v25 * (a3 - v4));
}
// 804E09B: conditional instruction was optimized away because edi.4!=0

//----- (0804E1B0) --------------------------------------------------------
unsigned int __usercall qsort_r@<eax>(
        long double a1@<st0>,
        char *a2,
        unsigned int a3,
        unsigned int a4,
        int (__cdecl *a5)(char *, char *, int),
        int a6)
{
  unsigned int v6; // esi
  unsigned int v7; // ecx
  unsigned int v8; // ebx
  int v9; // eax
  int *v10; // eax
  int *v11; // esi
  int *v12; // ebx
  char *v13; // edx
  int *v14; // edx
  int *v15; // edi
  _BYTE *v16; // ebx
  _BYTE *v17; // esi
  _BYTE *v18; // ecx
  int *v19; // edx
  void *v21; // esp
  int v22; // eax
  char *v23; // ecx
  int v24; // edx
  int v25; // [esp+0h] [ebp-58h] BYREF
  int v26; // [esp+Ch] [ebp-4Ch]
  int *v27; // [esp+10h] [ebp-48h]
  unsigned int v28; // [esp+14h] [ebp-44h]
  _BYTE *v29; // [esp+18h] [ebp-40h]
  unsigned int v30; // [esp+1Ch] [ebp-3Ch]
  unsigned int v31; // [esp+2Ch] [ebp-2Ch] BYREF
  int v32; // [esp+30h] [ebp-28h]
  int (__cdecl *v33)(char *, char *, int); // [esp+34h] [ebp-24h]
  int v34; // [esp+38h] [ebp-20h]
  int *v35; // [esp+3Ch] [ebp-1Ch]

  v6 = a4 + 8 * a3;
  if ( a4 <= 0x20 )
    v6 = a4 * a3;
  if ( v6 <= 0x3FF )
  {
    v26 = 0;
    v21 = alloca(v6 + 15);
    v35 = &v25;
  }
  else
  {
    v7 = pagesize_7836;
    if ( !pagesize_7836 )
    {
      v22 = sysconf(0, a1, 85);
      v24 = 0x1FFFFFFF;
      if ( v22 != -1 )
        v24 = v22 / 4;
      phys_pages_7835 = v24;
      pagesize_7836 = sysconf(v23, a1, 30);
      v7 = pagesize_7836;
    }
    if ( v6 / v7 > phys_pages_7835 )
      return quicksort(a2, a3, a4, a5, a6);
    v8 = __readgsdword(0xFFFFFFE8);
    v9 = malloc(v6);
    v26 = v9;
    __writegsdword(0xFFFFFFE8, v8);
    if ( !v9 )
      return quicksort(a2, a3, a4, a5, a6);
    v35 = (int *)v9;
  }
  v31 = a4;
  v32 = 4;
  v33 = a5;
  v34 = a6;
  if ( a4 > 0x20 )
  {
    v10 = &v35[a3];
    v11 = v10;
    v12 = &v10[a3];
    v27 = v12;
    if ( v10 >= v12 )
    {
      v14 = &v35[a3];
    }
    else
    {
      v13 = a2;
      do
      {
        *v10++ = (int)v13;
        v13 += a4;
      }
      while ( v12 > v10 );
      v14 = &v35[a3];
    }
    v31 = 4;
    v32 = 3;
    if ( a3 <= 1 )
    {
      if ( !a3 )
        return free(v26);
    }
    else
    {
      msort_with_tmp_part_0(&v31, v14, a3);
    }
    v15 = v11;
    v28 = 0;
    v29 = a2;
    do
    {
      v16 = v29;
      v17 = (_BYTE *)v15[v28];
      if ( v17 != v29 )
      {
        memcpy(v27, v29, a4);
        v18 = v16;
        v30 = v28;
        while ( 1 )
        {
          v15[v30] = (int)v18;
          memcpy(v18, v17, a4);
          v19 = &v15[(v17 - a2) / a4];
          v30 = (v17 - a2) / a4;
          v18 = v17;
          if ( (_BYTE *)*v19 == v29 )
            break;
          v17 = (_BYTE *)*v19;
        }
        *v19 = (int)v17;
        memcpy(v17, v27, a4);
      }
      ++v28;
      v29 += a4;
    }
    while ( a3 != v28 );
    return free(v26);
  }
  if ( (a4 & 3) == 0 && ((unsigned __int8)a2 & 3) == 0 )
  {
    if ( a4 == 4 )
    {
      v32 = 0;
    }
    else if ( a4 != 8 || ((unsigned __int8)a2 & 7) != 0 )
    {
      v32 = 2;
    }
    else
    {
      v32 = 1;
    }
  }
  if ( a3 <= 1 )
    return free(v26);
  msort_with_tmp_part_0(&v31, a2, a3);
  return free(v26);
}
// 804E43B: variable 'v23' is possibly undefined
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EC27C: using guessed type int phys_pages_7835;
// 80EC280: using guessed type int pagesize_7836;

//----- (0804E490) --------------------------------------------------------
unsigned int __usercall qsort@<eax>(
        long double a1@<st0>,
        char *a2,
        unsigned int a3,
        unsigned int a4,
        int (__cdecl *a5)(char *, char *, int))
{
  return qsort_r(a1, a2, a3, a4, a5, 0);
}

//----- (0804E4B0) --------------------------------------------------------
int __cdecl getenv(_BYTE *a1)
{
  _DWORD *v1; // ebp
  int v2; // ebx
  __int16 v3; // ax
  __int16 v5; // di
  int v6; // [esp+18h] [ebp-20h]

  v1 = (_DWORD *)environ;
  v6 = strlen(a1);
  if ( !environ || !*a1 )
    return 0;
  if ( a1[1] )
  {
    v2 = *(_DWORD *)environ;
    v5 = *(_WORD *)a1;
    if ( *(_DWORD *)environ )
    {
      while ( v5 != *(_WORD *)v2 || strncmp((unsigned __int8 *)(v2 + 2), a1 + 2, v6 - 2) || *(_BYTE *)(v2 + v6) != 61 )
      {
        v2 = *++v1;
        if ( !*v1 )
          return v2;
      }
      v2 += v6 + 1;
    }
  }
  else
  {
    v2 = *(_DWORD *)environ;
    HIBYTE(v3) = 61;
    if ( *(_DWORD *)environ )
    {
      while ( 1 )
      {
        LOBYTE(v3) = *a1;
        if ( v3 == *(_WORD *)v2 )
          break;
        v2 = *++v1;
        if ( !*v1 )
          return v2;
      }
      v2 += 2;
    }
  }
  return v2;
}
// 80EC524: using guessed type int environ;

//----- (0804E580) --------------------------------------------------------
void __usercall __noreturn _run_exit_handlers(long double a1@<st0>, int status, _DWORD **a3, char a4)
{
  _DWORD *v4; // edi
  int v5; // eax
  int *v6; // ecx
  int v7; // edx
  bool v8; // zf
  void (**v9)(void); // esi

  while ( 1 )
  {
    v4 = *a3;
    if ( !*a3 )
    {
LABEL_8:
      if ( a4 && _start___libc_atexit < &_stop___libc_atexit )
      {
        v9 = (void (**)(void))_start___libc_atexit;
        do
          (*v9++)();
        while ( v9 < (void (**)(void))&_stop___libc_atexit );
      }
      exit(status);
    }
LABEL_2:
    while ( 1 )
    {
      v5 = v4[1];
      v6 = &v4[4 * v5 - 2];
      if ( !v5 )
        break;
      while ( 1 )
      {
        v7 = *v6;
        v4[1] = --v5;
        if ( v7 == 3 )
          break;
        if ( v7 == 4 )
        {
          ((void (__cdecl *)(_DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v4[4 * v5 + 3], 9)))(v4[4 * v5 + 4], status);
          goto LABEL_2;
        }
        if ( v7 == 2 )
        {
          ((void (__cdecl *)(int, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v4[4 * v5 + 3], 9)))(status, v4[4 * v5 + 4]);
          goto LABEL_2;
        }
        v6 -= 4;
        if ( !v5 )
          goto LABEL_7;
      }
      ((void (*)(void))(__readgsdword(0x18u) ^ __ROR4__(v4[4 * v5 + 3], 9)))();
    }
LABEL_7:
    v8 = *v4 == 0;
    *a3 = (_DWORD *)*v4;
    if ( v8 )
      goto LABEL_8;
    free(a1, (int)v4);
  }
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 80D6B38: using guessed type int (*_stop___libc_atexit)();

//----- (0804E6A0) --------------------------------------------------------
void __usercall __noreturn exit(long double a1@<st0>, int status)
{
  _run_exit_handlers(a1, status, (_DWORD **)&_exit_funcs, 1);
}
// 80EB070: using guessed type void *_exit_funcs;

//----- (0804E6C0) --------------------------------------------------------
_DWORD *__usercall _new_exitfn@<eax>(long double a1@<st0>, _DWORD *a2)
{
  bool v3; // zf
  _DWORD *v4; // esi
  _DWORD *v5; // edi
  _DWORD *v6; // ebx
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  _DWORD *v10; // eax
  _DWORD *v11; // ecx
  _DWORD *v13; // eax

  _ECX = 1;
  v3 = __readgsdword(0xCu) == 0;
  if ( !v3 )
    __asm { lock }
  __asm { cmpxchg ds:lock_1, ecx }
  if ( !v3 )
    _lll_lock_wait_private(0, &lock_1);
  v4 = (_DWORD *)*a2;
  v5 = 0;
  v6 = (_DWORD *)*a2;
  if ( !*a2 )
    _assert_fail(a1, (int)"l != NULL", (int)"cxa_atexit.c", 100, "__new_exitfn");
  while ( 1 )
  {
    v7 = v6[1];
    if ( !v7 )
      goto LABEL_12;
    v8 = v7 - 1;
    if ( v6[4 * v7 - 2] )
      break;
    v9 = (int)&v6[4 * v7 - 6];
    while ( v8 )
    {
      v9 -= 16;
      if ( *(_DWORD *)(v9 + 16) )
        goto LABEL_15;
      --v8;
    }
LABEL_12:
    v10 = (_DWORD *)*v6;
    v6[1] = 0;
    v5 = v6;
    if ( !v10 )
      goto LABEL_26;
    v6 = v10;
  }
  v8 = v6[1];
LABEL_15:
  if ( v8 != 32 )
  {
    v6[1] = v8 + 1;
    v11 = &v6[4 * v8 + 2];
LABEL_17:
    *v11 = 1;
    ++_new_exitfn_called;
    goto LABEL_18;
  }
  v6 = v5;
  if ( v5 )
  {
LABEL_26:
    v11 = v6 + 2;
    v6[1] = 1;
    goto LABEL_17;
  }
  v13 = (_DWORD *)calloc(1u, 0x208u);
  v6 = v13;
  if ( v13 )
  {
    *v13 = v4;
    *a2 = v13;
    goto LABEL_26;
  }
  v11 = 0;
LABEL_18:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --lock_1 )
    _lll_unlock_wake_private(&lock_1);
  return v11;
}
// 804E79A: variable 'v11' is possibly undefined
// 80EC4A8: using guessed type int lock_1;
// 80ECC38: using guessed type __int64 _new_exitfn_called;

//----- (0804E7F0) --------------------------------------------------------
int __usercall _internal_atexit@<eax>(long double a1@<st0>, int a2, int a3, int a4, _DWORD *a5)
{
  _DWORD *v5; // eax

  v5 = _new_exitfn(a1, a5);
  if ( !v5 )
    return -1;
  v5[1] = __ROL4__(__readgsdword(0x18u) ^ a2, 9);
  v5[2] = a3;
  v5[3] = a4;
  *v5 = 4;
  return 0;
}

//----- (0804E840) --------------------------------------------------------
int __cdecl _cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle)
{
  long double v3; // fst7
  _DWORD *v4; // eax

  v4 = _new_exitfn(v3, &_exit_funcs);
  if ( !v4 )
    return -1;
  v4[1] = __ROL4__(__readgsdword(0x18u) ^ (unsigned int)lpfunc, 9);
  v4[2] = obj;
  v4[3] = lpdso_handle;
  *v4 = 4;
  return 0;
}
// 804E848: variable 'v3' is possibly undefined
// 80EB070: using guessed type void *_exit_funcs;

//----- (0804E890) --------------------------------------------------------
int __cdecl _strtoul_internal(char *a1, char **a2, int a3, int a4)
{
  return ___strtoul_l_internal(a1, a2, a3, a4, __readgsdword(0xFFFFFFDC));
}

//----- (0804E8C0) --------------------------------------------------------
int __cdecl strtoul(char *a1, char **a2, int a3)
{
  return ___strtoul_l_internal(a1, a2, a3, 0, __readgsdword(0xFFFFFFDC));
}

//----- (0804E8F0) --------------------------------------------------------
int __cdecl ___strtoul_l_internal(char *a1, char **a2, int a3, int a4, int a5)
{
  _BYTE *v5; // esi
  int v6; // ecx
  char v7; // al
  char *v8; // edx
  unsigned __int8 v9; // cl
  int v10; // edi
  int v11; // eax
  int v12; // eax
  char *v13; // ebx
  unsigned int v14; // ebp
  int v15; // edx
  int v16; // edx
  int v17; // ecx
  char *v18; // edx
  int v20; // ebp
  int v21; // eax
  int v22; // edx
  int v23; // ebx
  int v24; // ecx
  int v25; // eax
  char *v26; // edx
  int v27; // eax
  char *v28; // [esp+4h] [ebp-38h]
  unsigned int v29; // [esp+8h] [ebp-34h]
  unsigned __int8 v30; // [esp+8h] [ebp-34h]
  char *v31; // [esp+Ch] [ebp-30h]
  char *v32; // [esp+Ch] [ebp-30h]
  int v33; // [esp+10h] [ebp-2Ch]
  unsigned __int8 v34; // [esp+1Bh] [ebp-21h]
  int v35; // [esp+1Ch] [ebp-20h]

  v5 = 0;
  v28 = 0;
  if ( a4 )
  {
    v22 = *(_DWORD *)(a5 + 4);
    v28 = *(char **)(v22 + 44);
    if ( (unsigned __int8)(*v28 - 1) > 0x7Du )
    {
      v28 = 0;
    }
    else
    {
      v5 = *(_BYTE **)(v22 + 40);
      if ( !*v5 )
      {
        v28 = 0;
        v5 = 0;
      }
    }
  }
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    v20 = 0;
    __writegsdword(0xFFFFFFE8, 0x16u);
    return v20;
  }
  v6 = *(_DWORD *)(a5 + 52);
  v31 = a1;
  v7 = *a1;
  if ( (*(_BYTE *)(v6 + 2 * *a1 + 1) & 0x20) != 0 )
  {
    v8 = a1;
    do
      v7 = *++v8;
    while ( (*(_BYTE *)(v6 + 2 * *v8 + 1) & 0x20) != 0 );
    v31 = v8;
  }
  if ( !v7 )
  {
    v13 = a1;
LABEL_62:
    if ( !a2 )
      return 0;
    if ( v13 - a1 > 1 && dword_80C1B40[*(v13 - 1)] == 88 && *(v13 - 2) == 48 )
    {
      v20 = 0;
      *a2 = v13 - 1;
    }
    else
    {
      v20 = 0;
      *a2 = a1;
    }
    return v20;
  }
  if ( v7 == 45 )
  {
    v32 = v31 + 1;
    v35 = 1;
  }
  else
  {
    v35 = 0;
    v32 = &v31[v7 == 43];
  }
  v9 = *v32;
  if ( *v32 != 48 )
  {
    if ( !a3 )
      goto LABEL_36;
    goto LABEL_13;
  }
  if ( (a3 & 0xFFFFFFEF) != 0 )
    goto LABEL_13;
  if ( dword_80C1B40[v32[1]] == 88 )
  {
    a3 = 16;
    v10 = 0;
    v28 = 0;
    v9 = v32[2];
    v32 += 2;
    v11 = 14;
    goto LABEL_15;
  }
  if ( a3 )
  {
LABEL_13:
    if ( a3 != 10 )
    {
      v10 = 0;
      v28 = 0;
      v11 = a3 - 2;
      goto LABEL_15;
    }
LABEL_36:
    if ( v28 )
    {
      v30 = *v32;
      v23 = strlen(v5);
      v10 = v23;
      if ( !v23 )
      {
LABEL_61:
        v13 = v32;
        goto LABEL_62;
      }
      v24 = v30;
      if ( v30 == *v5 )
      {
        v25 = 0;
        do
        {
          if ( v23 == ++v25 )
            goto LABEL_61;
        }
        while ( v5[v25] == v32[v25] );
        v24 = v30;
      }
      if ( (_BYTE)v24 )
      {
        v26 = v32;
        while ( 1 )
        {
          if ( (unsigned __int8)(v24 - 48) > 9u )
          {
            if ( *v5 == *v26 )
            {
              v27 = 0;
              while ( v23 != ++v27 )
              {
                if ( v5[v27] != v26[v27] )
                {
                  v24 = (unsigned __int8)v24;
                  goto LABEL_82;
                }
              }
            }
            else
            {
LABEL_82:
              if ( (byte_80C2440[2 * v24 + 1] & 4) == 0 || (int)dword_80C1B40[v24] > 64 )
                goto LABEL_80;
            }
          }
          v24 = (unsigned __int8)*++v26;
          if ( !(_BYTE)v24 )
            goto LABEL_80;
        }
      }
      v26 = v32;
LABEL_80:
      v28 = (char *)_correctly_grouped_prefixmb((unsigned int)v32, (unsigned int)v26, v5, v28);
      v9 = *v32;
      v11 = 8;
      a3 = 10;
    }
    else
    {
      v11 = 8;
      a3 = 10;
      v10 = 0;
    }
LABEL_15:
    v29 = _strtol_ul_max_tab[v11];
    v34 = _strtol_ul_rem_tab[v11];
    v12 = v9;
    if ( v9 && v28 != v32 )
      goto LABEL_17;
    goto LABEL_61;
  }
  a3 = 8;
  v10 = 0;
  v28 = 0;
  v29 = 0x1FFFFFFF;
  v34 = 7;
  v12 = 48;
LABEL_17:
  v13 = v32;
  v33 = 0;
  v14 = 0;
  do
  {
    LOBYTE(v15) = v12 - 48;
    if ( (unsigned __int8)(v12 - 48) > 9u )
    {
      if ( v10 )
      {
        if ( *v5 == *v13 )
        {
          v16 = 0;
          while ( 1 )
          {
            v17 = v16 + 1;
            if ( v16 + 1 == v10 )
              break;
            if ( v5[++v16] != v13[v17] )
              goto LABEL_46;
          }
          v18 = &v13[v16];
          goto LABEL_25;
        }
LABEL_46:
        if ( (byte_80C2440[2 * v12 + 1] & 4) == 0 )
          break;
        v15 = dword_80C1B40[v12] - 55;
      }
      else
      {
        if ( (byte_80C2440[2 * v12 + 1] & 4) == 0 )
          break;
        v15 = dword_80C1B40[v12] - 55;
      }
    }
    v21 = (unsigned __int8)v15;
    if ( (unsigned __int8)v15 >= a3 )
      break;
    if ( v14 > v29 || (unsigned __int8)v15 > v34 && v14 == v29 )
    {
      v18 = v13;
      v33 = 1;
    }
    else
    {
      v18 = v13;
      v14 = v21 + a3 * v14;
    }
LABEL_25:
    v13 = v18 + 1;
    v12 = (unsigned __int8)v18[1];
  }
  while ( v18 + 1 != v28 && (_BYTE)v12 );
  if ( v13 == v32 )
    goto LABEL_62;
  if ( a2 )
    *a2 = v13;
  if ( v33 )
  {
    v20 = -1;
    __writegsdword(0xFFFFFFE8, 0x22u);
    return v20;
  }
  if ( v35 )
    return -v14;
  return v14;
}
// 80C1B40: using guessed type _DWORD dword_80C1B40[256];
// 80C2440: using guessed type _BYTE byte_80C2440[512];
// 80CC7C0: using guessed type int _strtol_ul_max_tab[6];

//----- (0804EDB0) --------------------------------------------------------
int __cdecl strtoul_l(char *a1, char **a2, int a3, int a4)
{
  return ___strtoul_l_internal(a1, a2, a3, 0, a4);
}

//----- (0804EDD0) --------------------------------------------------------
unsigned int __cdecl _correctly_grouped_prefixmb(unsigned int a1, unsigned int a2, _BYTE *a3, char *a4)
{
  int v4; // eax
  unsigned int v5; // edi
  unsigned int i; // ebp
  char v7; // si
  char v8; // al
  unsigned int v9; // ecx
  char *v10; // eax
  char v11; // bl
  char v12; // dl
  int v13; // eax
  unsigned int v14; // ecx
  unsigned int result; // eax
  char *v16; // ebx
  char v17; // al
  unsigned int v18; // ebp
  unsigned int v19; // ecx
  char *v20; // eax
  char v21; // bl
  char v22; // dl
  unsigned int v23; // ebp
  unsigned int v24; // ecx
  char *v25; // eax
  char v26; // bl
  char v27; // dl
  signed int v28; // eax
  unsigned int v29; // [esp+8h] [ebp-34h]
  unsigned int v30; // [esp+Ch] [ebp-30h]
  char v31; // [esp+13h] [ebp-29h]
  char *v32; // [esp+14h] [ebp-28h]
  int v33; // [esp+18h] [ebp-24h]
  unsigned int v34; // [esp+1Ch] [ebp-20h]

  if ( !a4 )
    return a2;
  v4 = strlen(a3);
  if ( a2 > a1 )
  {
    v33 = v4 - 1;
    v34 = a2;
    v29 = a1 - 1;
    v5 = a2 - 1;
    if ( a1 <= a2 - 1 )
    {
      while ( 1 )
      {
        for ( i = a2 + v33; ; --i )
        {
          v7 = *(_BYTE *)(i - 1);
          if ( v7 == *a3 )
          {
            v8 = a3[1];
            if ( !v8 )
              goto LABEL_12;
            if ( v8 == *(_BYTE *)(i - 2) )
              break;
          }
LABEL_5:
          if ( --v5 == v29 )
            return v34;
        }
        v9 = i;
        v10 = a3 + 2;
        while ( 1 )
        {
          v12 = *v10;
          if ( !*v10 )
            break;
          v11 = *(_BYTE *)(v9 - 3);
          ++v10;
          --v9;
          if ( v12 != v11 )
            goto LABEL_5;
        }
LABEL_12:
        if ( a1 > v5 )
          return v34;
        v13 = *a4 + 1;
        if ( a2 - v5 == v13 )
          break;
        v14 = v5 + v13;
        if ( (int)(a2 - v5) <= v13 )
          v14 = v5;
        a2 = v14;
LABEL_17:
        if ( a1 >= a2 )
          goto LABEL_47;
LABEL_18:
        v34 = a2;
        v5 = a2 - 1;
        if ( a1 > a2 - 1 )
          return v34;
      }
      v30 = v5 - 1;
      a2 = v5 - 1;
      v32 = a4;
      v16 = a4;
      v31 = a4[1];
      if ( v31 )
      {
LABEL_21:
        v32 = v16 + 1;
        v17 = v31;
        if ( v31 != 127 )
          goto LABEL_22;
      }
      else
      {
        while ( 2 )
        {
          v31 = *v32;
          v17 = *v32;
          if ( *v32 != 127 )
          {
LABEL_22:
            if ( v17 >= 0 )
            {
              if ( a1 > v30 )
                return v34;
              v18 = v5 + v33;
              v5 = v30;
              while ( v7 )
              {
                if ( v7 == *(_BYTE *)(v18 - 1) )
                {
                  v19 = v18;
                  v20 = a3 + 1;
                  do
                  {
                    v22 = *v20;
                    if ( !*v20 )
                      goto LABEL_30;
                    v21 = *(_BYTE *)(v19 - 2);
                    ++v20;
                    --v19;
                  }
                  while ( v22 == v21 );
                }
                --v5;
                --v18;
                if ( v5 == v29 )
                {
                  v28 = v30 - v29;
                  goto LABEL_45;
                }
              }
LABEL_30:
              if ( a1 <= v5 )
              {
                if ( v30 - v5 != v31 )
                  goto LABEL_17;
LABEL_32:
                v16 = v32;
                v30 = v5 - 1;
                v31 = v32[1];
                if ( v31 )
                  goto LABEL_21;
                continue;
              }
              v28 = v30 - v5;
LABEL_45:
              if ( v31 >= v28 )
                return v34;
              if ( a1 < a2 )
                goto LABEL_18;
              goto LABEL_47;
            }
          }
          break;
        }
      }
      if ( a1 > v30 )
        return v34;
      v23 = v5 + v33;
      v5 = v30;
      while ( v7 )
      {
        if ( v7 == *(_BYTE *)(v23 - 1) )
        {
          v24 = v23;
          v25 = a3 + 1;
          do
          {
            v27 = *v25;
            if ( !*v25 )
              goto LABEL_41;
            v26 = *(_BYTE *)(v24 - 2);
            ++v25;
            --v24;
          }
          while ( v27 == v26 );
        }
        --v5;
        --v23;
        if ( v5 == v29 )
          return v34;
      }
LABEL_41:
      if ( a1 <= v5 )
        goto LABEL_32;
      return v34;
    }
    return v34;
  }
LABEL_47:
  result = a2;
  if ( a1 >= a2 )
    return a1;
  return result;
}

//----- (0804F0E0) --------------------------------------------------------
int __usercall printf@<eax>(long double a1@<st0>, unsigned int a2, ...)
{
  va_list va; // [esp+14h] [ebp+8h] BYREF

  va_start(va, a2);
  return vfprintf(a1, (int)stdout, a2, (char *)va);
}
// 80EB4B8: using guessed type void *stdout;

//----- (0804F100) --------------------------------------------------------
int __usercall asprintf@<eax>(long double a1@<st0>, _DWORD *a2, unsigned int a3, ...)
{
  va_list va; // [esp+18h] [ebp+Ch] BYREF

  va_start(va, a3);
  return vasprintf(a1, a2, a3, (char *)va);
}

//----- (0804F120) --------------------------------------------------------
int __usercall _fxprintf@<eax>(long double a1@<st0>, int *a2, _BYTE *a3, long double a4, ...)
{
  int *v4; // esi
  int v5; // eax
  void *v6; // esp
  int v7; // ecx
  int v8; // edx
  int v10[10]; // [esp+0h] [ebp-28h] BYREF
  va_list va; // [esp+44h] [ebp+1Ch]

  va_start(va, a4);
  v4 = a2;
  if ( !a2 )
    v4 = stderr;
  if ( v4[26] <= 0 )
    return vfprintf(a1, (int)v4, (unsigned int)a3, (char *)&a4);
  v10[3] = (int)v10;
  v5 = strlen(a3) + 1;
  v6 = alloca(4 * v5 + 3);
  if ( v5 )
  {
    v7 = (char)*a3;
    if ( (v7 & 0x80u) != 0 )
LABEL_11:
      _assert_fail("isascii (fmt[i])", "fxprintf.c", 44, "__fxprintf");
    v8 = 0;
    while ( 1 )
    {
      v10[v8++] = v7;
      if ( v5 == v8 )
        break;
      v7 = (char)a3[v8];
      if ( (v7 & 0x80u) != 0 )
        goto LABEL_11;
    }
  }
  return vfwprintf(a1, (int)v4, v10, &a4);
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EB4B4: using guessed type int *stderr;

//----- (0804F1D0) --------------------------------------------------------
int __cdecl fclose(int *a1)
{
  int v1; // eax
  int v2; // edx
  int v3; // esi
  _DWORD *v4; // edx
  int v5; // edi
  int v6; // edi
  bool v8; // zf
  unsigned int v11; // esi
  bool v13; // zf

  v1 = *a1;
  if ( (*a1 & 0x2000) != 0 )
  {
    IO_un_link(a1);
    v1 = *a1;
    if ( (BYTE1(*a1) & 0x80u) != 0 )
      goto LABEL_30;
  }
  else
  {
    v2 = *a1 & 0x8000;
    if ( (v1 & 0x8000) != 0 )
      goto LABEL_3;
  }
  _EDX = a1[18];
  v11 = __readgsdword(8u);
  if ( v11 != *(_DWORD *)(_EDX + 8) )
  {
    _ECX = 1;
    v13 = __readgsdword(0xCu) == 0;
    if ( !v13 )
      __asm { lock }
    __asm { cmpxchg [edx], ecx }
    if ( !v13 )
      _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
    _EDX = a1[18];
    v1 = *a1;
    *(_DWORD *)(_EDX + 8) = v11;
  }
  ++*(_DWORD *)(_EDX + 4);
LABEL_30:
  v2 = v1 & 0x8000;
  if ( (v1 & 0x2000) != 0 )
  {
    v3 = IO_new_file_close_it((int)a1);
    v2 = *a1 & 0x8000;
    goto LABEL_4;
  }
LABEL_3:
  v3 = v1 << 26 >> 31;
LABEL_4:
  if ( !v2 )
  {
    v4 = (_DWORD *)a1[18];
    v8 = v4[1]-- == 1;
    if ( v8 )
    {
      v4[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v8 = (*v4)-- == 1;
      if ( !v8 )
        _lll_unlock_wake_private(v4);
    }
  }
  v5 = a1[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v5
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check();
  (*(void (__cdecl **)(int *, _DWORD))(v5 + 8))(a1, 0);
  if ( a1[26] <= 0 )
  {
    if ( a1[9] )
      IO_free_backup_area(a1);
  }
  else
  {
    v6 = a1[21];
    _ECX = 1;
    v8 = __readgsdword(0xCu) == 0;
    if ( !v8 )
      __asm { lock }
    __asm { cmpxchg ds:__gconv_lock, ecx }
    if ( !v8 )
      _lll_lock_wait_private(0, &_gconv_lock);
    _gconv_release_step(*(int **)(v6 + 36));
    _gconv_release_step(*(int **)(v6 + 76));
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --_gconv_lock )
      _lll_unlock_wake_private(&_gconv_lock);
  }
  if ( a1 != stdin && a1 != stdout && a1 != stderr )
    free(a1);
  return v3;
}
// 8051620: using guessed type int IO_vtable_check(void);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 80EB4B4: using guessed type int *stderr;
// 80EB4B8: using guessed type void *stdout;
// 80EB4BC: using guessed type void *stdin;
// 80ECCD8: using guessed type int _gconv_lock;

//----- (0804F3E0) --------------------------------------------------------
int __cdecl fflush(_DWORD *a1)
{
  int v2; // esi
  int v3; // edx
  _DWORD *v4; // ecx
  unsigned int v7; // esi
  bool v8; // zf

  if ( !a1 )
    return IO_flush_all();
  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v7 = __readgsdword(8u);
    if ( v7 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v8 = __readgsdword(0xCu) == 0;
      if ( !v8 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v8 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v7;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v2 = a1[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(_ECX);
  v3 = -((*(int (__cdecl **)(_DWORD *))(v2 + 48))(a1) != 0);
  if ( (*a1 & 0x8000) == 0 )
  {
    v4 = (_DWORD *)a1[18];
    v8 = v4[1]-- == 1;
    if ( v8 )
    {
      v4[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v8 = (*v4)-- == 1;
      if ( !v8 )
        _lll_unlock_wake_private(v4);
    }
  }
  return v3;
}
// 804F4A8: variable '_ECX' is possibly undefined
// 804F45E: variable 'v3' is possibly undefined
// 8051620: using guessed type int __fastcall IO_vtable_check(_DWORD);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0804F500) --------------------------------------------------------
int __cdecl _fopen_maybe_mmap(int a1)
{
  int result; // eax
  void *v2; // edx

  result = a1;
  if ( (*(_BYTE *)(a1 + 60) & 1) != 0 && (*(_BYTE *)a1 & 8) != 0 )
  {
    v2 = &_start___libc_IO_vtables;
    if ( *(int *)(a1 + 104) <= 0 )
      v2 = &IO_file_jumps_maybe_mmap;
    *(_DWORD *)(a1 + 148) = v2;
    *(_DWORD *)(*(_DWORD *)(a1 + 88) + 176) = &_start___libc_IO_vtables;
  }
  return result;
}

//----- (0804F540) --------------------------------------------------------
int __cdecl _fopen_internal(int a1, _BYTE *a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // ebx
  _DWORD *v6; // eax
  void *v8; // eax
  int v9; // [esp+0h] [ebp-1Ch]

  v3 = malloc(344);
  if ( !v3 )
    return 0;
  v4 = v3 + 152;
  v5 = v3;
  v6 = (_DWORD *)(v3 + 164);
  *(v6 - 23) = v4;
  IO_no_init(v5, 0, 0, v6, (int)&IO_wfile_jumps);
  *(_DWORD *)(v5 + 148) = &IO_file_jumps;
  IO_new_file_init_internal((int *)v5);
  if ( !IO_new_file_fopen((_DWORD *)v5, a1, a2, a3) )
  {
    IO_un_link((int *)v5);
    v9 = v5;
    v5 = 0;
    free(v9);
    return v5;
  }
  if ( (*(_BYTE *)(v5 + 60) & 1) == 0 || (*(_BYTE *)v5 & 8) == 0 )
    return v5;
  v8 = &_start___libc_IO_vtables;
  if ( *(int *)(v5 + 104) <= 0 )
    v8 = &IO_file_jumps_maybe_mmap;
  *(_DWORD *)(v5 + 148) = v8;
  *(_DWORD *)(*(_DWORD *)(v5 + 88) + 176) = &_start___libc_IO_vtables;
  return v5;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0804F610) --------------------------------------------------------
int __cdecl fopen(int a1, _BYTE *a2)
{
  return _fopen_internal(a1, a2, 1);
}

//----- (0804F630) --------------------------------------------------------
_BYTE *__cdecl gets(_BYTE *a1)
{
  _DWORD *v1; // esi
  _BYTE *v2; // ebx
  int *v3; // ecx
  unsigned int v5; // edi
  bool v7; // zf
  unsigned __int8 *v8; // eax
  int v9; // eax
  char v10; // di
  int v11; // edi
  _BYTE *v12; // eax
  _DWORD *v13; // edx

  v1 = stdin;
  v2 = a1;
  v3 = (int *)stdin;
  if ( (*(_DWORD *)stdin & 0x8000) == 0 )
  {
    _EDX = *((_DWORD *)stdin + 18);
    v5 = __readgsdword(8u);
    if ( v5 == *(_DWORD *)(_EDX + 8) )
    {
      v3 = (int *)stdin;
    }
    else
    {
      _ECX = 1;
      v7 = __readgsdword(0xCu) == 0;
      if ( !v7 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v7 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
      _EDX = v1[18];
      v3 = (int *)stdin;
      *(_DWORD *)(_EDX + 8) = v5;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v8 = (unsigned __int8 *)v3[1];
  if ( (unsigned int)v8 >= v3[2] )
  {
    v9 = _uflow(v3);
    if ( v9 == -1 )
      goto LABEL_25;
  }
  else
  {
    v3[1] = (int)(v8 + 1);
    v9 = *v8;
  }
  if ( v9 == 10 )
  {
    v12 = 0;
    goto LABEL_14;
  }
  v10 = *(_DWORD *)stdin;
  *(_DWORD *)stdin &= ~0x20u;
  *a1 = v9;
  v11 = v10 & 0x20;
  v12 = IO_getline((int *)stdin, a1 + 1, 0x7FFFFFFFu, 10, 0) + 1;
  if ( (*(_DWORD *)stdin & 0x20) != 0 )
  {
LABEL_25:
    v2 = 0;
    goto LABEL_15;
  }
  *(_DWORD *)stdin |= v11;
LABEL_14:
  v12[(_DWORD)a1] = 0;
LABEL_15:
  if ( (*v1 & 0x8000) == 0 )
  {
    v13 = (_DWORD *)v1[18];
    v7 = v13[1]-- == 1;
    if ( v7 )
    {
      v13[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v7 = (*v13)-- == 1;
      if ( !v7 )
        _lll_unlock_wake_private(v13);
    }
  }
  return v2;
}
// 80EB4BC: using guessed type void *stdin;

//----- (0804F7A0) --------------------------------------------------------
int __cdecl putchar(char a1)
{
  _DWORD *v1; // ebx
  int v2; // edx
  _DWORD *v3; // ecx
  unsigned int v5; // edi
  bool v7; // zf
  _BYTE *v8; // eax
  _DWORD *v9; // ecx

  v1 = stdout;
  LOBYTE(v2) = a1;
  v3 = stdout;
  if ( (*(_DWORD *)stdout & 0x8000) == 0 )
  {
    _ESI = *((_DWORD *)stdout + 18);
    v5 = __readgsdword(8u);
    if ( v5 == *(_DWORD *)(_ESI + 8) )
    {
      v3 = stdout;
    }
    else
    {
      _ECX = 1;
      v7 = __readgsdword(0xCu) == 0;
      if ( !v7 )
        __asm { lock }
      __asm { cmpxchg [esi], ecx }
      if ( !v7 )
        _lll_lock_wait_private(0, (volatile __int32 *)_ESI);
      _ESI = v1[18];
      v3 = stdout;
      *(_DWORD *)(_ESI + 8) = v5;
    }
    ++*(_DWORD *)(_ESI + 4);
  }
  v8 = (_BYTE *)v3[5];
  if ( (unsigned int)v8 >= v3[6] )
  {
    v2 = _overflow((int)v3, (unsigned __int8)v2);
  }
  else
  {
    v3[5] = v8 + 1;
    *v8 = v2;
    v2 = (unsigned __int8)v2;
  }
  if ( (*v1 & 0x8000) == 0 )
  {
    v9 = (_DWORD *)v1[18];
    v7 = v9[1]-- == 1;
    if ( v7 )
    {
      v9[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v7 = (*v9)-- == 1;
      if ( !v7 )
        _lll_unlock_wake_private(v9);
    }
  }
  return v2;
}
// 804F806: variable 'v2' is possibly undefined
// 80EB4B8: using guessed type void *stdout;

//----- (0804F8A0) --------------------------------------------------------
int __usercall adjust_wide_data@<eax>(_DWORD *a1@<eax>, unsigned __int8 a2@<dl>)
{
  int v4; // edi
  int v5; // esi
  int *v6; // ecx
  int v7; // eax
  int v9; // ebp
  _DWORD *v10; // ecx
  int v11; // edx
  int v12; // eax
  int v13[8]; // [esp+18h] [ebp-20h] BYREF

  v4 = a1[21];
  v5 = (*(int (__cdecl **)(int))(v4 + 16))(v4);
  if ( a2 >= (unsigned __int8)(v5 > 0) )
  {
    v9 = a1[3];
    v13[0] = v9;
    while ( 1 )
    {
      v10 = (_DWORD *)a1[22];
      v11 = v10[12];
      v10[13] = v10[11];
      v10[14] = v11;
      v12 = (*(int (__cdecl **)(int, _DWORD *, int, _DWORD, int *, _DWORD, _DWORD, _DWORD *))(v4 + 12))(
              v4,
              v10 + 11,
              v9,
              a1[1],
              v13,
              v10[2],
              v10[7],
              v10 + 1);
      if ( v12 == 2 )
        break;
      if ( v12 != 1 )
      {
        v6 = (int *)a1[22];
        v7 = v6[1];
        goto LABEL_3;
      }
      v9 = a1[3];
    }
    *a1 |= 0x20u;
    return -1;
  }
  else
  {
    v6 = (int *)a1[22];
    v7 = v6[1] + 4 * ((a1[1] - a1[3]) / v5);
    v6[1] = v7;
LABEL_3:
    *v6 = v7;
    return 0;
  }
}
// 804F8A0: using guessed type int var_20[8];

//----- (0804F950) --------------------------------------------------------
int __usercall IO_wfile_underflow@<eax>(long double a1@<st0>, int *a2)
{
  int *v2; // ecx
  int v3; // eax
  unsigned int v4; // ebx
  unsigned int v5; // esi
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // ebx
  int v9; // edx
  _DWORD *v10; // ecx
  unsigned int v12; // edi
  bool v14; // zf
  int v15; // edi
  _DWORD *v16; // eax
  int v17; // edx
  int v18; // ebx
  int v19; // eax
  unsigned int v20; // esi
  int v21; // eax
  _DWORD *v22; // ecx
  int v23; // edx
  _BYTE *v24; // eax
  int v25; // eax
  int *v26; // edx
  int *v27; // ecx
  unsigned int v28; // ebx
  _BYTE *v29; // eax
  int v31; // esi
  int v32; // eax
  _BYTE *v33; // ebx
  _WORD *v34; // eax
  int v35; // ecx
  int v36; // eax
  int v37; // edx
  int v38; // eax
  _DWORD *v39; // edx
  _DWORD *v40; // ecx
  int v41; // eax
  int v42; // ecx
  int v43; // edx
  _DWORD *v44; // edx
  _DWORD *v45; // edx
  int v46; // edi
  int v47; // eax
  int v48; // edx
  unsigned int v49; // [esp+Ch] [ebp-4Ch]
  __int64 v50; // [esp+10h] [ebp-48h]
  int v51; // [esp+18h] [ebp-40h]
  int v52; // [esp+1Ch] [ebp-3Ch]
  int v53; // [esp+1Ch] [ebp-3Ch]
  int v54; // [esp+1Ch] [ebp-3Ch]
  int *v55; // [esp+2Ch] [ebp-2Ch] BYREF
  int v56[10]; // [esp+30h] [ebp-28h] BYREF

  if ( (*a2 & 4) == 0 )
  {
    v2 = (int *)a2[22];
    v3 = *v2;
    if ( *v2 < (unsigned int)v2[1] )
      return *(_DWORD *)v3;
    v51 = a2[21];
    v4 = a2[1];
    v5 = a2[2];
    if ( v4 < v5 )
    {
      v36 = v2[11];
      v37 = v2[12];
      v56[0] = a2[1];
      v2[13] = v36;
      v38 = v2[6];
      v2[14] = v37;
      v39 = v2 + 1;
      v40 = v2 + 11;
      *(v40 - 11) = v38;
      *(v40 - 9) = v38;
      v41 = (*(int (__cdecl **)(int, _DWORD *, unsigned int, unsigned int, int *, int, _DWORD, _DWORD *))(v51 + 12))(
              v51,
              v40,
              v4,
              v5,
              v56,
              v38,
              *(v40 - 4),
              v39);
      v42 = v56[0];
      v43 = a2[1];
      a2[1] = v56[0];
      a2[3] = v43;
      v44 = (_DWORD *)a2[22];
      if ( *v44 < v44[1] )
        return *(_DWORD *)*v44;
      if ( v41 == 2 )
      {
LABEL_52:
        __writegsdword(0xFFFFFFE8, 0x54u);
        *a2 |= 0x20u;
        return -1;
      }
      j_memmove(a2[7], v42, a2[2] - v42);
      v6 = a2[7];
      v48 = v6 + a2[2] - a2[1];
      a2[3] = v6;
      a2[1] = v6;
      a2[2] = v48;
    }
    else
    {
      v6 = a2[7];
      a2[2] = v6;
      a2[1] = v6;
      a2[3] = v6;
    }
    if ( !v6 )
    {
      if ( a2[9] )
      {
        free(a1, a2[9]);
        *a2 &= ~0x100u;
      }
      IO_doallocbuf(a1, a2);
      v6 = a2[7];
      a2[2] = v6;
      a2[1] = v6;
      a2[3] = v6;
    }
    a2[6] = v6;
    a2[5] = v6;
    a2[4] = v6;
    v7 = a2[22];
    if ( !*(_DWORD *)(v7 + 24) )
    {
      v47 = *(_DWORD *)(v7 + 32);
      if ( v47 )
      {
        free(a1, v47);
        *a2 &= ~0x100u;
      }
      IO_wdoallocbuf((int)a2);
    }
    if ( (*a2 & 0x202) == 0 )
      goto LABEL_18;
    v8 = stdout;
    v9 = *(_DWORD *)stdout;
    v10 = stdout;
    if ( (*(_DWORD *)stdout & 0x8000) == 0 )
    {
      _ESI = *((_DWORD *)stdout + 18);
      v12 = __readgsdword(8u);
      if ( v12 == *(_DWORD *)(_ESI + 8) )
      {
        v10 = stdout;
      }
      else
      {
        _ECX = 1;
        v14 = __readgsdword(0xCu) == 0;
        if ( !v14 )
          __asm { lock }
        __asm { cmpxchg [esi], ecx }
        if ( !v14 )
          _lll_lock_wait_private(0, (volatile __int32 *)_ESI);
        v10 = stdout;
        _ESI = v8[18];
        v9 = *(_DWORD *)stdout;
        *(_DWORD *)(_ESI + 8) = v12;
      }
      ++*(_DWORD *)(_ESI + 4);
    }
    if ( (v9 & 0x288) == 640 )
    {
      v46 = v10[37];
      if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v46
                                                                                            - (_DWORD)&_start___libc_IO_vtables) )
      {
        IO_vtable_check(a1);
        v10 = stdout;
      }
      (*(void (__cdecl **)(_DWORD *, int))(v46 + 12))(v10, -1);
    }
    if ( (*v8 & 0x8000) == 0 && (v45 = (_DWORD *)v8[18], v14 = v45[1] == 1, --v45[1], v14) )
    {
      v45[2] = 0;
      v49 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v14 = (*v45)-- == 1;
      if ( !v14 )
        _lll_unlock_wake_private(v45);
    }
    else
    {
LABEL_18:
      v49 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
    }
    v15 = 0;
    IO_switch_to_get_mode(a2);
    v16 = (_DWORD *)a2[22];
    v17 = v16[6];
    *v16 = v17;
    v16[2] = v17;
    v16[1] = v17;
    v16[5] = v17;
    v16[4] = v17;
    v16[3] = v17;
    while ( 1 )
    {
      v18 = a2[37];
      if ( v18 - (int)&_start___libc_IO_vtables >= v49 )
        IO_vtable_check(a1);
      v19 = (*(int (__cdecl **)(int *, int, int))(v18 + 56))(a2, a2[2], a2[8] - a2[2]);
      v20 = v19;
      if ( v19 <= 0 )
      {
        if ( !v19 && !v15 )
        {
          *a2 |= 0x10u;
          a2[19] = -1;
          a2[20] = -1;
          return -1;
        }
        *a2 |= 0x20u;
        if ( v15 )
        {
          __writegsdword(0xFFFFFFE8, 0x54u);
          return -1;
        }
        return -1;
      }
      v21 = v19 + a2[2];
      HIDWORD(v50) = a2[20];
      a2[2] = v21;
      v52 = v21;
      LODWORD(v50) = a2[19];
      if ( v50 != -1 )
        *(_QWORD *)(a2 + 19) = (int)v20 + v50;
      v22 = (_DWORD *)a2[22];
      v23 = v22[12];
      v22[13] = v22[11];
      v22[14] = v23;
      v24 = (_BYTE *)a2[1];
      a2[3] = (int)v24;
      if ( v15 )
      {
        if ( 16 - v15 <= v20 )
          v20 = 16 - v15;
        v33 = (char *)v56 + v15;
        v15 += v20;
        v34 = mempcpy(v33, v24, v20);
        v25 = (*(int (__cdecl **)(int, int, int *, _WORD *, int **, _DWORD, _DWORD, int))(v51 + 12))(
                v51,
                a2[22] + 44,
                v56,
                v34,
                &v55,
                *(_DWORD *)(a2[22] + 4),
                *(_DWORD *)(a2[22] + 28),
                a2[22] + 4);
        if ( v15 )
        {
          v26 = v55;
          v35 = (char *)v55 - v33;
          if ( (char *)v55 - v33 < 0 )
            v35 = 0;
          a2[1] += v35;
          v27 = (int *)a2[22];
          if ( v27[1] != v27[6] )
          {
LABEL_49:
            v3 = *v27;
            return *(_DWORD *)v3;
          }
          goto LABEL_28;
        }
      }
      else
      {
        v25 = (*(int (__cdecl **)(int, _DWORD *, _BYTE *, int, int **, _DWORD, _DWORD, _DWORD *))(v51 + 12))(
                v51,
                v22 + 11,
                v24,
                v52,
                &v55,
                v22[1],
                v22[7],
                v22 + 1);
      }
      v26 = v55;
      v27 = (int *)a2[22];
      a2[1] = (int)v55;
      v15 = 0;
      if ( v27[1] != v27[6] )
        goto LABEL_49;
LABEL_28:
      if ( v25 == 2 )
        goto LABEL_52;
      if ( v25 != 1 )
        _assert_fail(a1, (int)"status == __codecvt_partial", (int)"wfileops.c", 309, "_IO_wfile_underflow");
      if ( v15 )
      {
        if ( v26 != v56 )
        {
          v15 -= (char *)v26 - (char *)v56;
          j_memmove(v56, v26, v15);
        }
        if ( v15 == 16 )
          goto LABEL_52;
        v28 = a2[3];
LABEL_34:
        a2[2] = v28;
        a2[1] = v28;
      }
      else
      {
        v28 = a2[3];
        v29 = (_BYTE *)a2[1];
        if ( v28 >= (unsigned int)v29 )
        {
          v53 = a2[2];
          v15 = v53 - (_DWORD)v29;
          if ( (unsigned int)(v53 - (_DWORD)v29) > 0xF )
            goto LABEL_52;
          memcpy(v56, v29, v53 - (_DWORD)v29);
          goto LABEL_34;
        }
        v54 = a2[2];
        v31 = v54 - (_DWORD)v29;
        j_memmove(v28, v29, v54 - (_DWORD)v29);
        v32 = a2[3];
        a2[2] -= v31;
        a2[1] = v32;
      }
    }
  }
  *a2 |= 0x20u;
  __writegsdword(0xFFFFFFE8, 9u);
  return -1;
}
// 80481D0: using guessed type int __cdecl j_memmove(_DWORD, _DWORD, _DWORD);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 80EB4B8: using guessed type void *stdout;

//----- (0804FF70) --------------------------------------------------------
__int64 __usercall IO_wfile_seekoff@<edx:eax>(long double a1@<st0>, int a2, __int64 a3, int a4, int a5)
{
  int *v5; // eax
  unsigned int v6; // edx
  unsigned int v7; // ecx
  bool v8; // zf
  __int64 result; // rax
  int v10; // esi
  unsigned int v11; // ebx
  int v12; // esi
  int v13; // ecx
  _DWORD *v14; // ecx
  int v15; // ebx
  __int64 v16; // rax
  __int64 v17; // rcx
  int v18; // eax
  int v19; // edi
  unsigned int v20; // esi
  int v21; // edi
  int v22; // eax
  int v23; // esi
  int v24; // ecx
  int v25; // eax
  int v26; // eax
  int v27; // esi
  int v28; // edx
  int v29; // eax
  int v30; // ecx
  int v31; // edx
  _DWORD *v32; // eax
  int v33; // edx
  int v34; // ebx
  int v35; // eax
  int v36; // edx
  unsigned int v37; // edi
  int v38; // ebx
  __int64 v39; // rax
  int v40; // ebx
  int v41; // esi
  int v42; // eax
  __int64 v43; // rax
  int v44; // eax
  int v45; // eax
  _DWORD *v46; // eax
  int v47; // edx
  int v48; // esi
  int v49; // edi
  int v50; // eax
  int v51; // eax
  _DWORD *v52; // eax
  int v53; // edx
  int v54; // edx
  int v55; // eax
  int v56; // ebx
  int v57; // ebx
  _DWORD *v58; // eax
  int v59; // edx
  int v60; // esi
  int v61; // eax
  int v62; // edx
  int v63; // ecx
  int v64; // edx
  int v65; // eax
  int v66; // edi
  int v67; // eax
  __int64 v68; // xmm1_8
  int v69; // ebx
  int v70; // edi
  __int64 v71; // [esp+0h] [ebp-ACh]
  unsigned int v72; // [esp+0h] [ebp-ACh]
  unsigned __int64 v73; // [esp+0h] [ebp-ACh]
  __int64 v74; // [esp+8h] [ebp-A4h]
  int v75; // [esp+8h] [ebp-A4h]
  int v76; // [esp+14h] [ebp-98h]
  int v77; // [esp+14h] [ebp-98h]
  int v78; // [esp+14h] [ebp-98h]
  int v79; // [esp+18h] [ebp-94h]
  __int64 v80; // [esp+18h] [ebp-94h]
  int v81; // [esp+18h] [ebp-94h]
  int v82; // [esp+18h] [ebp-94h]
  int v83; // [esp+18h] [ebp-94h]
  int v84; // [esp+28h] [ebp-84h] BYREF
  int v85; // [esp+2Ch] [ebp-80h] BYREF
  __int64 v86[2]; // [esp+30h] [ebp-7Ch] BYREF
  int v87; // [esp+40h] [ebp-6Ch]
  __int64 v88; // [esp+5Ch] [ebp-50h]

  v71 = a3;
  v5 = *(int **)(a2 + 88);
  if ( !a5 )
  {
    if ( v5[6] )
    {
      v36 = *(_DWORD *)a2;
      v37 = v5[4];
      v72 = v5[3];
      v75 = *(_DWORD *)a2 & 0x1000;
      if ( v37 > v72 && (*(_DWORD *)a2 & 0x1000) != 0 )
      {
        v38 = *(_DWORD *)(a2 + 148);
        if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v38
                                                                                              - (_DWORD)&_start___libc_IO_vtables) )
          IO_vtable_check(a1);
        v39 = ((__int64 (__cdecl *)(int, _DWORD, _DWORD, int))*(_DWORD *)(v38 + 64))(a2, 0, 0, 2);
        if ( v39 == -1 )
          return -1LL;
        *(_QWORD *)(a2 + 76) = v39;
        v5 = *(int **)(a2 + 88);
        v36 = *(_DWORD *)a2;
      }
      if ( (v36 & 0x100) != 0 )
      {
        if ( *v5 < (unsigned int)v5[1] )
        {
LABEL_60:
          __writegsdword(0xFFFFFFE8, 0x16u);
          return -1LL;
        }
        v40 = v5[8];
        v77 = v40;
        v81 = v5[10];
      }
      else
      {
        v40 = v5[2];
        v77 = *v5;
        v81 = v5[1];
      }
      v41 = *(_DWORD *)(a2 + 84);
      v42 = (*(int (__cdecl **)(int))(v41 + 16))(v41);
      if ( v37 > v72 )
      {
        if ( v42 <= 0 )
        {
          v66 = *(_DWORD *)(a2 + 88);
          v83 = *(_DWORD *)(v66 + 16);
          v78 = *(_DWORD *)(v66 + 12);
          v67 = malloc(a1, v83 - v78);
          v68 = *(_QWORD *)(v66 + 52);
          v84 = v67;
          v86[0] = v68;
          v69 = v67;
          v85 = v78;
          if ( (*(int (__cdecl **)(int, __int64 *, int, int, int *, int, int, int *))(v41 + 4))(
                 v41,
                 v86,
                 v78,
                 v83,
                 &v85,
                 v67,
                 v67 + v83 - v78,
                 &v84) )
          {
            free(a1, v69);
            return 0xFFFFFFFFLL;
          }
          v48 = v84 - v69;
          v70 = v84 - v69;
          free(a1, v69);
          v49 = v70 >> 31;
        }
        else
        {
          v48 = v42 * ((*(_DWORD *)(*(_DWORD *)(a2 + 88) + 16) - *(_DWORD *)(*(_DWORD *)(a2 + 88) + 12)) >> 2);
          v49 = v48 >> 31;
        }
        v50 = *(_DWORD *)(a2 + 20);
        if ( v75 )
          v51 = v50 - *(_DWORD *)(a2 + 16);
        else
          v51 = v50 - *(_DWORD *)(a2 + 8);
        v73 = v51 + __PAIR64__(v49, v48);
      }
      else if ( v42 <= 0 )
      {
        v86[0] = *(_QWORD *)(*(_DWORD *)(a2 + 88) + 52);
        v65 = (*(int (__cdecl **)(int, __int64 *, _DWORD, _DWORD, int))(v41 + 24))(
                v41,
                v86,
                *(_DWORD *)(a2 + 12),
                *(_DWORD *)(a2 + 8),
                (v77 - v40) >> 2);
        LODWORD(v73) = v65 - (*(_DWORD *)(a2 + 8) - *(_DWORD *)(a2 + 12));
        HIDWORD(v73) = -((v65 != *(_DWORD *)(a2 + 8) - *(_DWORD *)(a2 + 12))
                       + ((*(_DWORD *)(a2 + 8) - *(_DWORD *)(a2 + 12) - v65) >> 31));
      }
      else
      {
        v73 = -(__int64)(v42 * ((v81 - v77) >> 2)) - (*(_DWORD *)(a2 + 8) - *(_DWORD *)(a2 + 4));
      }
    }
    else
    {
      v73 = 0LL;
    }
    v43 = *(_QWORD *)(a2 + 76);
    if ( v43 == -1 )
    {
      v57 = *(_DWORD *)(a2 + 148);
      if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v57
                                                                                            - (_DWORD)&_start___libc_IO_vtables) )
        IO_vtable_check(a1);
      v43 = ((__int64 (__cdecl *)(int, _DWORD, _DWORD, int))*(_DWORD *)(v57 + 64))(a2, 0, 0, 1);
      if ( v43 == -1 )
        return -1LL;
    }
    result = v73 + v43;
    if ( result >= 0 )
      return result;
    goto LABEL_60;
  }
  if ( v5[2] == v5[1] )
  {
    v7 = v5[3];
    v6 = v5[4];
    if ( v7 == v6 )
    {
      v76 = 1;
LABEL_9:
      if ( (*(_DWORD *)a2 & 0x800) == 0 )
        goto LABEL_10;
      goto LABEL_5;
    }
  }
  else
  {
    v6 = v5[4];
    v7 = v5[3];
  }
  v76 = 0;
  if ( v7 >= v6 )
    goto LABEL_9;
LABEL_5:
  v8 = IO_switch_to_wget_mode((int *)a2) == 0;
  result = 0xFFFFFFFFLL;
  if ( !v8 )
    return result;
  v5 = *(int **)(a2 + 88);
LABEL_10:
  if ( !v5[6] )
  {
    v44 = v5[2];
    if ( v44 )
    {
      free(a1, v44);
      *(_DWORD *)a2 &= ~0x100u;
    }
    IO_doallocbuf(a1, (int *)a2);
    v45 = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a2 + 20) = v45;
    *(_DWORD *)(a2 + 16) = v45;
    *(_DWORD *)(a2 + 24) = v45;
    *(_DWORD *)(a2 + 12) = v45;
    *(_DWORD *)(a2 + 4) = v45;
    *(_DWORD *)(a2 + 8) = v45;
    v46 = *(_DWORD **)(a2 + 88);
    v47 = v46[6];
    v46[4] = v47;
    v46[3] = v47;
    v46[5] = v47;
    v46[2] = v47;
    *v46 = v47;
    v46[1] = v47;
  }
  if ( a4 == 1 )
  {
    v34 = *(_DWORD *)(a2 + 84);
    v35 = (*(int (__cdecl **)(int))(v34 + 16))(v34);
    if ( v35 <= 0 )
    {
      v58 = *(_DWORD **)(a2 + 88);
      v59 = *v58 - v58[2];
      v58 += 11;
      v60 = v58[2];
      v58[1] = v58[3];
      *v58 = v60;
      v61 = (*(int (__cdecl **)(int, _DWORD *, _DWORD, _DWORD, int))(v34 + 24))(
              v34,
              v58,
              *(_DWORD *)(a2 + 12),
              *(_DWORD *)(a2 + 8),
              v59 >> 2);
      v62 = *(_DWORD *)(a2 + 12);
      v63 = v62 + v61;
      v64 = *(_DWORD *)(a2 + 8) - v62;
      *(_DWORD *)(a2 + 4) = v63;
      v71 = a3 - (v64 - v61);
      *(_DWORD *)(*(_DWORD *)(a2 + 88) + 4) = **(_DWORD **)(a2 + 88);
    }
    else
    {
      v71 = a3
          - ((*(_DWORD *)(*(_DWORD *)(a2 + 88) + 4) - **(_DWORD **)(a2 + 88)) >> 2) * v35
          - (*(_DWORD *)(a2 + 8)
           - *(_DWORD *)(a2 + 4));
    }
    v16 = *(_QWORD *)(a2 + 76);
    if ( v16 == -1 )
      goto LABEL_40;
    a4 = 0;
    v71 += v16;
  }
  else
  {
    if ( a4 == 2 )
    {
      v10 = *(_DWORD *)(a2 + 148);
      v11 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
      if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v10
                                                                                            - (_DWORD)&_start___libc_IO_vtables) )
        IO_vtable_check(a1);
      if ( (*(int (__cdecl **)(int, __int64 *))(v10 + 72))(a2, v86) || (v87 & 0xF000) != 0x8000 )
        goto LABEL_16;
      v71 = v88 + a3;
      a4 = 0;
    }
    v16 = *(_QWORD *)(a2 + 76);
    if ( v16 == -1 )
      goto LABEL_63;
  }
  if ( *(_DWORD *)(a2 + 12) )
  {
    if ( (*(_DWORD *)a2 & 0x100) == 0 )
    {
      v79 = *(_DWORD *)(a2 + 28);
      v17 = v16 - (*(_DWORD *)(a2 + 8) - v79);
      if ( v17 <= v71 && v16 > v71 )
      {
        *(_DWORD *)(a2 + 12) = v79;
        *(_DWORD *)(a2 + 20) = v79;
        *(_DWORD *)(a2 + 16) = v79;
        *(_DWORD *)(a2 + 24) = v79;
        *(_DWORD *)(a2 + 4) = v79 + v71 - v17;
        v52 = *(_DWORD **)(a2 + 88);
        v53 = v52[6];
        v52[2] = v53;
        *v52 = v53;
        v52[1] = v53;
        v52[4] = v53;
        v52[3] = v53;
        v52[5] = v53;
        if ( !adjust_wide_data((_DWORD *)a2, 0) )
        {
          v54 = *(_DWORD *)(a2 + 80);
          *(_DWORD *)a2 &= ~0x10u;
          v55 = *(_DWORD *)(a2 + 76);
          if ( v54 >= 0 )
          {
            v56 = *(_DWORD *)(a2 + 148);
            if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v56
                                                                                                  - (_DWORD)&_start___libc_IO_vtables) )
            {
              IO_vtable_check(a1);
              v55 = *(_DWORD *)(a2 + 76);
              v54 = *(_DWORD *)(a2 + 80);
            }
            (*(void (__cdecl **)(int, int, int, _DWORD))(v56 + 64))(a2, v55, v54, 0);
          }
          return v71;
        }
        goto LABEL_40;
      }
    }
    if ( (*(_DWORD *)a2 & 4) == 0 )
      goto LABEL_27;
    goto LABEL_40;
  }
LABEL_63:
  if ( (*(_DWORD *)a2 & 4) == 0 )
  {
LABEL_27:
    v18 = *(_DWORD *)(a2 + 32);
    v19 = *(_DWORD *)(a2 + 28) - v18;
    v20 = v71 & v19;
    v21 = HIDWORD(v71) & (v19 >> 31);
    v74 = v71 - __PAIR64__(v21, v20);
    if ( (__int64)(v71 - __PAIR64__(v21, v20)) > v18 - *(_DWORD *)(a2 + 28) )
    {
      v21 = HIDWORD(v71);
      v20 = v71;
      v74 = 0LL;
    }
    v22 = *(_DWORD *)(a2 + 148);
    v11 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v22
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
    {
      v82 = *(_DWORD *)(a2 + 148);
      IO_vtable_check(a1);
      v22 = v82;
    }
    v80 = ((__int64 (__cdecl *)(int, unsigned int, int, _DWORD))*(_DWORD *)(v22 + 64))(a2, v20, v21, 0);
    if ( v80 >= 0 )
    {
      if ( v74 )
      {
        v23 = *(_DWORD *)(a2 + 148);
        if ( v11 <= v23 - (int)&_start___libc_IO_vtables )
          IO_vtable_check(a1);
        if ( v76 )
        {
          v25 = v74;
          v24 = *(_DWORD *)(a2 + 28);
        }
        else
        {
          v24 = *(_DWORD *)(a2 + 28);
          v25 = *(_DWORD *)(a2 + 32) - v24;
        }
        v26 = (*(int (__cdecl **)(int, int, int))(v23 + 56))(a2, v24, v25);
        v27 = v26;
        if ( v74 > v26 )
        {
          a4 = 1;
          if ( v26 == -1 )
            v71 = v74;
          else
            v71 = v74 - v26;
          goto LABEL_16;
        }
        v28 = v26;
      }
      else
      {
        v28 = 0;
        v27 = 0;
      }
      v29 = *(_DWORD *)(a2 + 28);
      *(_DWORD *)(a2 + 12) = v29;
      *(_DWORD *)(a2 + 20) = v29;
      v30 = v29 + v74;
      *(_DWORD *)(a2 + 16) = v29;
      *(_DWORD *)(a2 + 24) = v29;
      v31 = v29 + v28;
      v32 = *(_DWORD **)(a2 + 88);
      *(_DWORD *)(a2 + 8) = v31;
      *(_DWORD *)(a2 + 4) = v30;
      v33 = v32[6];
      v32[2] = v33;
      *v32 = v33;
      v32[1] = v33;
      v32[4] = v33;
      v32[3] = v33;
      v32[5] = v33;
      if ( !adjust_wide_data((_DWORD *)a2, 1u) )
      {
        result = v71;
        *(_DWORD *)a2 &= ~0x10u;
        *(_QWORD *)(a2 + 76) = v80 + v27;
        return result;
      }
      goto LABEL_16;
    }
    return -1LL;
  }
LABEL_40:
  v11 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
LABEL_16:
  IO_unsave_markers((int *)a2);
  v12 = *(_DWORD *)(a2 + 148);
  if ( v12 - (int)&_start___libc_IO_vtables >= v11 )
    IO_vtable_check(a1);
  result = ((__int64 (__cdecl *)(int, _DWORD, _DWORD, int))*(_DWORD *)(v12 + 64))(a2, v71, HIDWORD(v71), a4);
  if ( result != -1 )
  {
    v13 = *(_DWORD *)(a2 + 28);
    *(_DWORD *)a2 &= ~0x10u;
    *(_QWORD *)(a2 + 76) = result;
    *(_DWORD *)(a2 + 12) = v13;
    *(_DWORD *)(a2 + 4) = v13;
    *(_DWORD *)(a2 + 8) = v13;
    *(_DWORD *)(a2 + 20) = v13;
    *(_DWORD *)(a2 + 16) = v13;
    *(_DWORD *)(a2 + 24) = v13;
    v14 = *(_DWORD **)(a2 + 88);
    v15 = v14[6];
    v14[2] = v15;
    *v14 = v15;
    v14[1] = v15;
    v14[4] = v15;
    v14[3] = v15;
    v14[5] = v15;
  }
  return result;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08050910) --------------------------------------------------------
int __usercall IO_wfile_underflow_mmap@<eax>(long double a1@<st0>, _DWORD *a2)
{
  int *v2; // eax
  int v3; // edx
  unsigned int v4; // ecx
  int v5; // esi
  int v6; // edx
  __int64 v7; // xmm0_8
  int *v8; // eax
  int result; // eax
  int v10; // edx
  int v11; // eax
  unsigned int v12[4]; // [esp+Ch] [ebp-10h] BYREF

  if ( (*a2 & 4) != 0 )
  {
    *a2 |= 0x20u;
    __writegsdword(0xFFFFFFE8, 9u);
    return -1;
  }
  v2 = (int *)a2[22];
  v3 = *v2;
  if ( *v2 < (unsigned int)v2[1] )
    return *(_DWORD *)v3;
  v4 = a2[1];
  v5 = a2[21];
  if ( v4 < a2[2] )
  {
LABEL_4:
    v6 = v2[6];
    v12[0] = v4;
    if ( !v6 )
    {
      v11 = v2[8];
      if ( v11 )
      {
        free(a1, v11);
        *a2 &= ~0x100u;
      }
      IO_wdoallocbuf((int)a2);
      v2 = (int *)a2[22];
      v4 = a2[1];
      v6 = v2[6];
    }
    v7 = *(_QWORD *)(v2 + 11);
    *v2 = v6;
    v2[2] = v6;
    *(_QWORD *)(v2 + 13) = v7;
    (*(void (__cdecl **)(int, int *, unsigned int, _DWORD, unsigned int *, int, int, int *))(v5 + 12))(
      v5,
      v2 + 11,
      v4,
      a2[2],
      v12,
      v6,
      v2[7],
      v2 + 1);
    a2[1] = v12[0];
    v8 = (int *)a2[22];
    v3 = *v8;
    if ( *v8 >= (unsigned int)v8[1] )
    {
      __writegsdword(0xFFFFFFE8, 0x54u);
      *a2 |= 0x20u;
      return -1;
    }
    return *(_DWORD *)v3;
  }
  v10 = IO_file_underflow_mmap(a1, a2);
  result = -1;
  if ( v10 != -1 )
  {
    v4 = a2[1];
    v2 = (int *)a2[22];
    goto LABEL_4;
  }
  return result;
}
// 8050910: using guessed type unsigned int var_10[4];

//----- (08050A30) --------------------------------------------------------
int __usercall IO_wfile_underflow_maybe_mmap@<eax>(long double a1@<st0>, unsigned int *a2)
{
  if ( IO_file_underflow_maybe_mmap(a1, a2) == -1 )
    return -1;
  else
    return (*(int (__cdecl **)(unsigned int *))(*(_DWORD *)(a2[22] + 176) + 16))(a2);
}

//----- (08050A70) --------------------------------------------------------
int __cdecl IO_wdo_write(_DWORD *a1, int a2, int a3)
{
  int v3; // edi
  char *v5; // esi
  char *v6; // eax
  char *v7; // ecx
  char *v8; // edx
  int result; // eax
  _DWORD *v10; // edx
  bool v11; // zf
  int v12; // ecx
  int v13; // ecx
  int v14; // [esp+4h] [ebp-48h]
  char *v15; // [esp+8h] [ebp-44h]
  int v16; // [esp+Ch] [ebp-40h]
  int v17; // [esp+18h] [ebp-34h] BYREF
  char *v18; // [esp+1Ch] [ebp-30h]
  char v19[16]; // [esp+20h] [ebp-2Ch] BYREF
  char v20; // [esp+30h] [ebp-1Ch] BYREF

  v3 = a3;
  if ( a3 )
  {
    v5 = (char *)a1[4];
    v16 = a1[21];
    v6 = (char *)a1[5];
    if ( (char *)a1[6] != v6 || v6 == v5 )
      goto LABEL_13;
    if ( IO_new_do_write((int)a1, (unsigned int)v5, v6 - v5) == -1 )
    {
      return -1;
    }
    else
    {
      v6 = (char *)a1[5];
      v5 = (char *)a1[4];
LABEL_13:
      while ( 1 )
      {
        v8 = v5;
        if ( (unsigned int)(v6 - v5) <= 0xF )
        {
          v6 = v19;
          v7 = &v20;
          v18 = v19;
          v8 = v19;
          v5 = v19;
        }
        else
        {
          v18 = v6;
          v7 = (char *)a1[8];
        }
        v15 = v8;
        v14 = (*(int (__cdecl **)(int, int, int, int, int *, char *, char *))(v16 + 4))(
                v16,
                a1[22] + 44,
                a2,
                a2 + 4 * v3,
                &v17,
                v6,
                v7);
        result = IO_new_do_write((int)a1, (unsigned int)v5, v18 - v15);
        if ( result == -1 )
          break;
        v3 -= (v17 - a2) >> 2;
        if ( v14 && (v14 != 1 || (unsigned int)(v17 - a2 + 3) <= 6) )
        {
          v10 = (_DWORD *)a1[22];
          result = -(v3 != 0);
          v11 = (*a1 & 0x202) == 0;
          v12 = v10[6];
          v10[2] = v12;
          *v10 = v12;
          v10[1] = v12;
          v10[4] = v12;
          v10[3] = v12;
          if ( !v11 )
            goto LABEL_17;
          goto LABEL_16;
        }
        if ( !v3 )
          goto LABEL_19;
        v6 = (char *)a1[5];
        v5 = (char *)a1[4];
        a2 = v17;
      }
    }
  }
  else
  {
LABEL_19:
    v10 = (_DWORD *)a1[22];
    v13 = v10[6];
    result = *a1 & 0x202;
    v10[2] = v13;
    *v10 = v13;
    v10[1] = v13;
    v10[4] = v13;
    v10[3] = v13;
    if ( result )
    {
      v10[5] = v13;
      return 0;
    }
    else
    {
LABEL_16:
      v12 = v10[7];
LABEL_17:
      v10[5] = v12;
    }
  }
  return result;
}

//----- (08050BF0) --------------------------------------------------------
int __usercall IO_wfile_overflow@<eax>(long double a1@<st0>, int *a2, int a3)
{
  int v3; // eax
  int *v5; // edx
  int v6; // ecx
  int v7; // esi
  int v8; // edi
  int v9; // esi
  int *v10; // eax
  _DWORD *v11; // edx
  bool v13; // al
  int v14; // edi
  int v15; // eax
  int v16; // [esp+8h] [ebp-24h]
  int v17; // [esp+Ch] [ebp-20h]

  v3 = *a2;
  if ( (*a2 & 8) != 0 )
  {
    *a2 = v3 | 0x20;
    __writegsdword(0xFFFFFFE8, 9u);
    return -1;
  }
  if ( (v3 & 0x800) == 0 )
  {
    v5 = (int *)a2[22];
    if ( v5[3] )
    {
      v6 = *v5;
      v16 = v5[7];
      if ( *v5 == v16 )
      {
        v8 = a2[7];
        v7 = v5[6];
        v16 = *v5;
        a2[2] = v8;
        v17 = v8;
        v6 = v7;
        *v5 = v7;
        v5[1] = v7;
      }
      else
      {
        v7 = v5[1];
        v8 = a2[1];
        v17 = a2[2];
      }
    }
    else
    {
      IO_wdoallocbuf((int)a2);
      v5 = (int *)a2[22];
      v14 = a2[4];
      v6 = v5[6];
      v5[2] = v6;
      *v5 = v6;
      v5[1] = v6;
      if ( v14 )
      {
        v8 = a2[1];
        v7 = v6;
        v16 = v5[7];
        v17 = a2[2];
        v3 = *a2;
      }
      else
      {
        IO_doallocbuf(a1, a2);
        v5 = (int *)a2[22];
        v8 = a2[7];
        v15 = v5[7];
        a2[2] = v8;
        v6 = *v5;
        v7 = v5[1];
        v16 = v15;
        v3 = *a2;
        v17 = v8;
      }
    }
    *v5 = v7;
    v5[2] = v7;
    v9 = a2[8];
    v5[4] = v6;
    v5[3] = v6;
    v5[5] = v16;
    a2[6] = v9;
    a2[5] = v8;
    a2[4] = v8;
    a2[1] = v17;
    a2[3] = v17;
    *a2 = v3 | 0x800;
    if ( (v3 & 0x202) != 0 )
      v5[5] = v6;
  }
  if ( a3 == -1 )
  {
    if ( a2[26] <= 0 )
      return IO_new_do_write((int)a2, a2[4], a2[5] - a2[4]);
    else
      return IO_wdo_write(a2, *(_DWORD *)(a2[22] + 12), (*(_DWORD *)(a2[22] + 16) - *(_DWORD *)(a2[22] + 12)) >> 2);
  }
  else
  {
    v10 = (int *)a2[22];
    v11 = (_DWORD *)v10[4];
    if ( v11 == (_DWORD *)v10[7] )
    {
      if ( a2[26] <= 0 )
        v13 = IO_new_do_write((int)a2, a2[4], a2[5] - a2[4]) == -1;
      else
        v13 = IO_wdo_write(a2, v10[3], ((int)v11 - v10[3]) >> 2) == -1;
      if ( v13 )
        return -1;
      v10 = (int *)a2[22];
      v11 = (_DWORD *)v10[4];
    }
    v10[4] = (int)(v11 + 1);
    *v11 = a3;
    if ( ((*a2 & 2) != 0 || (*a2 & 0x200) != 0 && a3 == 10)
      && (a2[26] <= 0
        ? IO_new_do_write((int)a2, a2[4], a2[5] - a2[4]) == -1
        : IO_wdo_write(a2, v10[3], ((int)v11 - v10[3] + 4) >> 2) == -1) )
    {
      return -1;
    }
    return a3;
  }
}

//----- (08050E70) --------------------------------------------------------
int __usercall IO_wfile_sync@<eax>(long double a1@<st0>, _DWORD *a2)
{
  _DWORD *v2; // edx
  unsigned int v3; // eax
  unsigned int v4; // ecx
  bool v5; // al
  int v7; // esi
  int v8; // edi
  int v9; // eax
  int v10; // eax
  int v11; // esi
  _QWORD *v12; // eax
  __int64 v13; // xmm0_8
  int v14; // eax
  int v15; // edx
  int v16; // ecx
  int v17; // edx
  int v18; // [esp+Ch] [ebp-10h]

  v2 = (_DWORD *)a2[22];
  v3 = v2[4];
  v4 = v2[3];
  if ( v3 > v4 )
  {
    if ( (int)a2[26] <= 0 )
      v5 = IO_new_do_write((int)a2, a2[4], a2[5] - a2[4]) != 0;
    else
      v5 = IO_wdo_write(a2, v4, (int)(v3 - v4) >> 2) != 0;
    if ( v5 )
      return -1;
    v2 = (_DWORD *)a2[22];
  }
  v7 = (*v2 - v2[1]) >> 2;
  if ( v7 )
  {
    v8 = a2[21];
    v9 = (*(int (__cdecl **)(int))(v8 + 16))(v8);
    if ( v9 <= 0 )
    {
      v12 = (_QWORD *)a2[22];
      v13 = *(_QWORD *)((char *)v12 + 52);
      v12 = (_QWORD *)((char *)v12 + 44);
      *v12 = v13;
      v14 = (*(int (__cdecl **)(int, _QWORD *, _DWORD, _DWORD, int))(v8 + 24))(v8, v12, a2[3], a2[2], v7);
      v15 = a2[3];
      v16 = v15 + v14;
      v17 = v15 - a2[2];
      a2[1] = v16;
      v10 = v17 + v14;
    }
    else
    {
      v10 = v7 * v9;
    }
    v11 = a2[37];
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v11
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
    {
      v18 = v10;
      IO_vtable_check(a1);
      v10 = v18;
    }
    if ( ((__int64 (__cdecl *)(_DWORD *, int, int, int))*(_DWORD *)(v11 + 64))(a2, v10, v10 >> 31, 1) == -1 )
    {
      if ( __readgsdword(0xFFFFFFE8) != 29 )
        return -1;
    }
    else
    {
      *(_DWORD *)(a2[22] + 4) = *(_DWORD *)a2[22];
      a2[2] = a2[1];
    }
  }
  a2[19] = -1;
  a2[20] = -1;
  return 0;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08050FE0) --------------------------------------------------------
unsigned int __cdecl IO_wfile_xsputn(_DWORD *a1, int *a2, unsigned int a3)
{
  unsigned int result; // eax
  int *v4; // esi
  _DWORD *v5; // edx
  _BYTE *v6; // ecx
  unsigned int v7; // ebx
  int v8; // eax
  unsigned int v9; // ebx
  int v10; // edx
  int v11; // eax
  int v12; // edx
  int *v13; // eax
  int *v14; // eax
  int v15; // [esp+8h] [ebp-24h]
  int v16; // [esp+Ch] [ebp-20h]
  int *v17; // [esp+Ch] [ebp-20h]

  result = 0;
  v4 = a2;
  if ( !a3 )
    return result;
  v5 = (_DWORD *)a1[22];
  v6 = (_BYTE *)v5[4];
  if ( (*a1 & 0xA00) == 2560 )
  {
    v15 = 0;
    v7 = (v5[7] - (int)v6) >> 2;
    if ( a3 <= v7 )
    {
      v13 = &a2[a3];
      if ( a2 < v13 )
      {
        v17 = v13 - 1;
        if ( *(v13 - 1) != 10 )
        {
          v14 = v13 - 1;
          do
          {
            if ( a2 >= v14 )
            {
              v15 = 0;
              goto LABEL_4;
            }
            --v14;
          }
          while ( *v14 != 10 );
          v17 = v14;
        }
        v15 = 1;
        v7 = v17 - a2 + 1;
      }
    }
  }
  else
  {
    v15 = 0;
    v7 = (v5[5] - (int)v6) >> 2;
  }
LABEL_4:
  if ( v7 )
  {
    if ( a3 <= v7 )
      v7 = a3;
    v8 = 0;
    if ( v7 > 0x14 )
    {
      v4 = &a2[v7];
      v16 = a1[22];
      *(_DWORD *)(v16 + 16) = wmempcpy(v6, a2, v7);
    }
    else
    {
      do
      {
        *(_DWORD *)&v6[4 * v8] = a2[v8];
        ++v8;
      }
      while ( v8 != v7 );
      v4 = &a2[v7];
      v5[4] = &v6[4 * v7];
    }
    v9 = a3 - v7;
    if ( !v9 )
      goto LABEL_11;
  }
  else
  {
    v9 = a3;
  }
  v9 -= IO_wdefault_xsputn(a1, v4, v9);
LABEL_11:
  if ( v15 )
  {
    v10 = a1[22];
    v11 = *(_DWORD *)(v10 + 16);
    v12 = *(_DWORD *)(v10 + 12);
    if ( v11 != v12 )
      IO_wdo_write(a1, v12, (v11 - v12) >> 2);
  }
  return a3 - v9;
}

//----- (08051160) --------------------------------------------------------
int __cdecl getc(int *a1)
{
  unsigned int v2; // esi
  bool v4; // zf
  unsigned __int8 *v5; // eax
  int v6; // ecx
  _DWORD *v7; // edx

  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v2 = __readgsdword(8u);
    if ( v2 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v4 = __readgsdword(0xCu) == 0;
      if ( !v4 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v4 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v2;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v5 = (unsigned __int8 *)a1[1];
  if ( (unsigned int)v5 >= a1[2] )
  {
    v6 = _uflow(a1);
  }
  else
  {
    a1[1] = (int)(v5 + 1);
    v6 = *v5;
  }
  if ( (*a1 & 0x8000) == 0 )
  {
    v7 = (_DWORD *)a1[18];
    v4 = v7[1]-- == 1;
    if ( v4 )
    {
      v7[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v4 = (*v7)-- == 1;
      if ( !v4 )
        _lll_unlock_wake_private(v7);
    }
  }
  return v6;
}
// 80511E9: variable 'v6' is possibly undefined

//----- (08051240) --------------------------------------------------------
int __usercall vasprintf@<eax>(long double a1@<st0>, _DWORD *a2, unsigned int a3, char *a4)
{
  unsigned int v4; // eax
  unsigned int v5; // ebx
  int v6; // ebx
  unsigned int v7; // edi
  unsigned int v8; // ebp
  _BYTE *v9; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // ebp
  unsigned int v13[4]; // [esp+10h] [ebp-BCh] BYREF
  int v14; // [esp+20h] [ebp-ACh]
  int v15; // [esp+24h] [ebp-A8h]
  int v16; // [esp+28h] [ebp-A4h]
  _BYTE *v17; // [esp+2Ch] [ebp-A0h]
  int v18; // [esp+58h] [ebp-74h]
  void *v19; // [esp+A4h] [ebp-28h]
  _DWORD (__cdecl *v20)(_DWORD); // [esp+A8h] [ebp-24h]
  _DWORD (__cdecl *v21)(_DWORD); // [esp+ACh] [ebp-20h]

  v4 = malloc(100);
  if ( !v4 )
    return -1;
  v18 = 0;
  v5 = v4;
  IO_no_init((int)v13, 0x8000, -1, 0, 0);
  v19 = &IO_str_jumps;
  IO_str_init_static_internal(v13, v5, 100, v5);
  v13[0] &= ~1u;
  v20 = malloc;
  v21 = free;
  v6 = vfprintf(a1, (int)v13, a3, a4);
  if ( v6 < 0 )
  {
    free(v17);
    return v6;
  }
  v7 = v15 - v14;
  v8 = v15 - v14 + 1;
  if ( v8 < (unsigned int)(v16 - v14) >> 1 && (v11 = (_BYTE *)malloc(v15 - v14 + 1), (*a2 = v11) != 0) )
  {
    v12 = v17;
    memcpy(v11, v17, v7);
    free(v12);
    v9 = (_BYTE *)*a2;
    if ( !*a2 )
      goto LABEL_9;
  }
  else
  {
    v9 = (_BYTE *)realloc(v17, v8);
    *a2 = v9;
    if ( !v9 )
    {
LABEL_9:
      v9 = v17;
      *a2 = v17;
    }
  }
  v9[v7] = 0;
  return v6;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08051390) --------------------------------------------------------
unsigned int **__usercall _libc_message@<eax>(long double a1@<st0>, int a2, unsigned int *a3, ...)
{
  unsigned int *v3; // esi
  _BYTE *v4; // eax
  unsigned int v5; // eax
  char v6; // bl
  int *v7; // edi
  char v8; // dl
  unsigned int *v9; // eax
  int v10; // ecx
  unsigned int *v11; // eax
  int v12; // edx
  void *v13; // esp
  unsigned int *v14; // eax
  int v15; // esi
  int v16; // ecx
  int v17; // ecx
  unsigned int **result; // eax
  unsigned int **v19; // ebx
  bool v20; // dl
  int v21; // esi
  _DWORD *v22; // eax
  unsigned int **v23; // edi
  unsigned int **v24; // esi
  int v25; // ebx
  _WORD *v26; // eax
  __int32 v27; // edi
  int *v28; // edi
  int v29; // ecx
  _BYTE *v30; // [esp-20h] [ebp-64h]
  unsigned int v31; // [esp-1Ch] [ebp-60h] BYREF
  _DWORD v32[11]; // [esp-14h] [ebp-58h] BYREF
  _DWORD *v33; // [esp+18h] [ebp-2Ch]
  unsigned int **v34; // [esp+1Ch] [ebp-28h]
  int v35; // [esp+20h] [ebp-24h]
  unsigned int *v36; // [esp+24h] [ebp-20h]
  int v37; // [esp+28h] [ebp-1Ch]
  va_list va; // [esp+54h] [ebp+10h] BYREF

  va_start(va, a3);
  va_copy(v34, va);
  v3 = a3;
  v4 = (_BYTE *)secure_getenv("LIBC_FATAL_STDERR_");
  if ( v4 && *v4 )
    goto LABEL_24;
  v5 = dl_sysinfo(2306);
  v35 = v5;
  if ( v5 > 0xFFFFF000 )
    v35 = _syscall_error(v5);
  if ( v35 == -1 )
  {
LABEL_24:
    v6 = *(_BYTE *)a3;
    v7 = 0;
    v35 = 2;
    v37 = 0;
    if ( v6 )
      goto LABEL_7;
LABEL_25:
    result = (unsigned int **)a2;
    if ( !a2 )
      return result;
    v20 = 0;
LABEL_33:
    backtrace_and_maps(a2, v20, v35, a1);
    abort(v29);
  }
  v6 = *(_BYTE *)a3;
  v7 = 0;
  v37 = 0;
  if ( !v6 )
    goto LABEL_25;
LABEL_7:
  while ( 1 )
  {
    v8 = v6;
    v9 = v3;
    do
    {
      if ( v8 == 37 && *((_BYTE *)v9 + 1) == 115 )
        break;
      v9 = strchrnul((unsigned int *)((char *)v9 + 1), 37);
      v8 = *(_BYTE *)v9;
    }
    while ( *(_BYTE *)v9 );
    if ( v6 == 37 && *((_BYTE *)v3 + 1) == 115 )
    {
      v3 = (unsigned int *)((char *)v3 + 2);
      v11 = *v34++;
      v36 = v11;
      v10 = strlen(v11);
    }
    else
    {
      v36 = v3;
      v10 = (char *)v9 - (char *)v3;
      v3 = v9;
    }
    v32[0] = v36;
    v32[1] = v10;
    v32[2] = v7;
    v6 = *(_BYTE *)v3;
    if ( !*(_BYTE *)v3 )
      break;
    ++v37;
    v7 = v32;
  }
  v34 = (unsigned int **)(v37 + 1);
  v12 = 0;
  v13 = alloca(8 * (v37 + 1) + 15);
  v33 = v32;
  v14 = &v32[2 * v37];
  v15 = (int)v36;
  while ( 1 )
  {
    v14[1] = v10;
    *v14 = v15;
    v14 -= 2;
    v16 = v12 + v10;
    v12 = v16;
    if ( &v31 == v14 )
      break;
    v15 = *v7;
    v10 = v7[1];
    v7 = (int *)v7[2];
  }
  v37 = v16;
  v17 = (int)v33;
  do
    result = (unsigned int **)dl_sysinfo(v17);
  while ( result == (unsigned int **)-4 );
  v19 = result;
  if ( a2 )
  {
    v21 = (dl_pagesize + v37) & -dl_pagesize;
    v22 = (_DWORD *)mmap(0, v21, 3, 34, -1, 0);
    if ( v22 != (_DWORD *)-1 )
    {
      *v22 = v21;
      v36 = v22;
      v23 = 0;
      v24 = v34;
      v34 = v19;
      v25 = (int)v33;
      v26 = v22 + 1;
      do
      {
        v31 = *(_DWORD *)(v25 + 8 * (_DWORD)v23 + 4);
        v30 = *(_BYTE **)(v25 + 8 * (_DWORD)v23);
        v23 = (unsigned int **)((char *)v23 + 1);
        v26 = mempcpy(v26, v30, v31);
      }
      while ( v24 != v23 );
      v27 = (__int32)v36;
      v19 = v34;
      *(_BYTE *)v26 = 0;
      v28 = (int *)_InterlockedExchange(&_abort_msg, v27);
      if ( v28 )
        munmap((int)v28, *v28);
    }
    v20 = v37 == (_DWORD)v19;
    goto LABEL_33;
  }
  return result;
}
// 80514FA: variable 'v17' is possibly undefined
// 80515CF: variable 'v29' is possibly undefined
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EBA08: using guessed type int dl_pagesize;
// 80EC268: using guessed type int _abort_msg;

//----- (080515F0) --------------------------------------------------------
void __usercall __noreturn _libc_fatal(long double a1@<st0>, const char *a2, ...)
{
  while ( 1 )
    _libc_message(a1, 1, (unsigned int *)"%s", a2);
}

//----- (08051620) --------------------------------------------------------
int (__usercall *__usercall IO_vtable_check@<eax>(
        long double a1@<st0>))@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5, int a6)
{
  int (__usercall *result)@<eax>(int@<ebp>, int@<edi>, int@<esi>, int, int, int); // eax

  result = _dlopen;
  if ( !_dlopen )
    _libc_fatal(a1, "Fatal error: glibc detected an invalid stdio handle\n");
  return result;
}

//----- (08051640) --------------------------------------------------------
_BYTE *__cdecl fgets_unlocked(_BYTE *a1, int a2, int *a3)
{
  char v3; // si
  int v4; // esi
  _BYTE *v5; // eax
  _BYTE *v6; // ecx
  int v7; // edx

  if ( a2 <= 0 )
    return 0;
  if ( a2 == 1 )
  {
    *a1 = 0;
    return a1;
  }
  else
  {
    v3 = *a3;
    *a3 &= ~0x20u;
    v4 = v3 & 0x20;
    v5 = IO_getline(a3, a1, a2 - 1, 10, 1);
    v6 = 0;
    v7 = *a3;
    if ( v5 )
    {
      if ( (v7 & 0x20) == 0 || (v6 = 0, __readgsdword(0xFFFFFFE8) == 11) )
      {
        v5[(_DWORD)a1] = 0;
        v6 = a1;
        v7 = *a3;
      }
    }
    *a3 = v7 | v4;
  }
  return v6;
}

//----- (080516E0) --------------------------------------------------------
int __usercall IO_file_seekoff_maybe_mmap@<eax>(long double a1@<st0>, _DWORD *a2, int a3, int a4, int a5)
{
  int v5; // ebp
  int result; // eax
  int v7; // edx

  v5 = a2[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v5
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  result = (*(int (__cdecl **)(_DWORD *, int, int, int))(v5 + 64))(a2, a3, a4, a5);
  if ( v7 < 0 )
    return -1;
  a2[19] = result;
  a2[20] = v7;
  return result;
}
// 805171E: variable 'v7' is possibly undefined
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08051750) --------------------------------------------------------
unsigned int __fastcall IO_file_close(int a1)
{
  unsigned int result; // eax

  result = dl_sysinfo(a1);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08051780) --------------------------------------------------------
unsigned int *__usercall IO_new_file_setbuf@<eax>(long double a1@<st0>, unsigned int *a2, char *a3, int a4)
{
  unsigned int *result; // eax
  unsigned int v5; // eax

  result = IO_default_setbuf(a1, a2, a3, a4);
  if ( result )
  {
    v5 = a2[7];
    a2[6] = v5;
    a2[5] = v5;
    a2[4] = v5;
    a2[3] = v5;
    a2[1] = v5;
    a2[2] = v5;
    return a2;
  }
  return result;
}

//----- (080517C0) --------------------------------------------------------
unsigned int *__usercall IO_file_setbuf_mmap@<eax>(long double a1@<st0>, unsigned int *a2, char *a3, int a4)
{
  unsigned int v4; // eax
  unsigned int *result; // eax
  unsigned int v6; // eax
  unsigned int v7; // edx

  v4 = a2[22];
  a2[37] = (unsigned int)&IO_file_jumps;
  *(_DWORD *)(v4 + 176) = &IO_wfile_jumps;
  result = IO_default_setbuf(a1, a2, a3, a4);
  if ( result )
  {
    v6 = a2[7];
    a2[6] = v6;
    a2[5] = v6;
    a2[4] = v6;
    a2[3] = v6;
    a2[1] = v6;
    a2[2] = v6;
    return a2;
  }
  else
  {
    v7 = a2[22];
    a2[37] = (unsigned int)&IO_file_jumps_mmap;
    *(_DWORD *)(v7 + 176) = &IO_wfile_jumps_mmap;
  }
  return result;
}

//----- (08051830) --------------------------------------------------------
int __usercall new_do_write@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)
{
  int v5; // esi
  int v6; // esi
  int v7; // eax
  int v8; // edx
  int v9; // eax
  int v11; // edx
  int v12; // eax
  int v13; // esi
  __int64 v14; // rax
  unsigned int v15; // [esp+8h] [ebp-24h]
  int v16; // [esp+8h] [ebp-24h]
  int v17; // [esp+Ch] [ebp-20h]
  int v18; // [esp+Ch] [ebp-20h]

  if ( (*(_DWORD *)a1 & 0x1000) != 0 )
  {
    *(_DWORD *)(a1 + 76) = -1;
    *(_DWORD *)(a1 + 80) = -1;
    v15 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
  }
  else
  {
    v11 = *(_DWORD *)(a1 + 8);
    v12 = *(_DWORD *)(a1 + 16);
    if ( v11 == v12 )
    {
      v15 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
    }
    else
    {
      v13 = *(_DWORD *)(a1 + 148);
      v15 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
      if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v13
                                                                                            - (_DWORD)&_start___libc_IO_vtables) )
      {
        v18 = a3;
        IO_vtable_check();
        v12 = *(_DWORD *)(a1 + 16);
        v11 = *(_DWORD *)(a1 + 8);
        a3 = v18;
      }
      v17 = a3;
      v14 = ((__int64 (__cdecl *)(int, int, int, int))*(_DWORD *)(v13 + 64))(a1, v12 - v11, (v12 - v11) >> 31, 1);
      if ( v14 == -1 )
        return 0;
      *(_QWORD *)(a1 + 76) = v14;
      a3 = v17;
    }
  }
  v5 = *(_DWORD *)(a1 + 148);
  if ( v5 - (int)&_start___libc_IO_vtables >= v15 )
  {
    v16 = a3;
    IO_vtable_check();
    a3 = v16;
  }
  v6 = (*(int (__cdecl **)(int, unsigned int, int))(v5 + 60))(a1, a2, a3);
  v7 = *(unsigned __int16 *)(a1 + 68);
  if ( v6 && (_WORD)v7 )
    *(_WORD *)(a1 + 68) = IO_adjust_column(v7 - 1, a2, v6) + 1;
  v8 = *(_DWORD *)(a1 + 104);
  v9 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 12) = v9;
  *(_DWORD *)(a1 + 4) = v9;
  *(_DWORD *)(a1 + 8) = v9;
  *(_DWORD *)(a1 + 20) = v9;
  *(_DWORD *)(a1 + 16) = v9;
  if ( v8 > 0 || (*(_DWORD *)a1 & 0x202) == 0 )
    v9 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 24) = v9;
  return v6;
}
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (080519B0) --------------------------------------------------------
int __usercall IO_new_file_underflow@<eax>(long double a1@<st0>, int *a2)
{
  int v2; // eax
  unsigned __int8 *v3; // edx
  _DWORD *v4; // esi
  int v5; // edx
  _DWORD *v6; // ecx
  bool v9; // zf
  _DWORD *v10; // edx
  unsigned int v11; // edi
  int v12; // esi
  int v13; // eax
  int v14; // eax
  __int64 v15; // rdi
  unsigned int v17; // [esp+8h] [ebp-20h]
  int v18; // [esp+8h] [ebp-20h]

  v2 = *a2;
  if ( (*a2 & 4) != 0 )
  {
    *a2 = v2 | 0x20;
    __writegsdword(0xFFFFFFE8, 9u);
    return -1;
  }
  else
  {
    v3 = (unsigned __int8 *)a2[1];
    if ( (unsigned int)v3 < a2[2] )
    {
      return *v3;
    }
    else
    {
      if ( !a2[7] )
      {
        if ( a2[9] )
        {
          free(a1, a2[9]);
          *a2 &= ~0x100u;
        }
        IO_doallocbuf(a1, a2);
        v2 = *a2;
      }
      if ( (v2 & 0x202) == 0 )
        goto LABEL_16;
      v4 = stdout;
      v5 = *(_DWORD *)stdout;
      v6 = stdout;
      if ( (*(_DWORD *)stdout & 0x8000) == 0 )
      {
        _EDI = *((_DWORD *)stdout + 18);
        v17 = __readgsdword(8u);
        if ( v17 == *(_DWORD *)(_EDI + 8) )
        {
          v6 = stdout;
        }
        else
        {
          _ECX = 1;
          v9 = __readgsdword(0xCu) == 0;
          if ( !v9 )
            __asm { lock }
          __asm { cmpxchg [edi], ecx }
          if ( !v9 )
            _lll_lock_wait_private(0, (volatile __int32 *)_EDI);
          _EDI = v4[18];
          *(_DWORD *)(_EDI + 8) = v17;
          v6 = stdout;
          v5 = *(_DWORD *)stdout;
        }
        ++*(_DWORD *)(_EDI + 4);
      }
      if ( (v5 & 0x288) == 640 )
      {
        v18 = v6[37];
        if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v18
                                                                                              - (_DWORD)&_start___libc_IO_vtables) )
        {
          IO_vtable_check(a1);
          v6 = stdout;
        }
        (*(void (__cdecl **)(_DWORD *, int))(v18 + 12))(v6, -1);
      }
      if ( (*v4 & 0x8000) == 0 && (v10 = (_DWORD *)v4[18], v9 = v10[1] == 1, --v10[1], v9) )
      {
        v11 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
        v10[2] = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v9 = (*v10)-- == 1;
        if ( !v9 )
          _lll_unlock_wake_private(v10);
      }
      else
      {
LABEL_16:
        v11 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
      }
      IO_switch_to_get_mode(a2);
      v12 = a2[37];
      v13 = a2[7];
      a2[1] = v13;
      a2[3] = v13;
      a2[2] = v13;
      a2[6] = v13;
      a2[5] = v13;
      a2[4] = v13;
      if ( v12 - (int)&_start___libc_IO_vtables >= v11 )
      {
        IO_vtable_check(a1);
        v13 = a2[7];
      }
      v14 = (*(int (__cdecl **)(int *, int, int))(v12 + 56))(a2, v13, a2[8] - v13);
      if ( v14 <= 0 )
      {
        if ( v14 )
          *a2 |= 0x20u;
        else
          *a2 |= 0x10u;
        a2[19] = -1;
        a2[20] = -1;
        return -1;
      }
      else
      {
        LODWORD(v15) = a2[20];
        HIDWORD(v15) = a2[19];
        a2[2] += v14;
        if ( v15 != -1 )
          *(_QWORD *)(a2 + 19) = __PAIR64__(v15, HIDWORD(v15)) + v14;
        return *(unsigned __int8 *)a2[1];
      }
    }
  }
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 80EB4B8: using guessed type void *stdout;

//----- (08051C70) --------------------------------------------------------
__int64 __usercall IO_new_file_seekoff@<edx:eax>(long double a1@<st0>, int a2, __int64 a3, int a4, int a5)
{
  unsigned int v5; // eax
  unsigned int v6; // edx
  int v7; // edi
  unsigned int v8; // esi
  int v9; // edi
  __int64 result; // rax
  int v11; // ecx
  int v12; // eax
  __int64 v13; // rdi
  signed __int64 v14; // rax
  int v15; // ecx
  __int64 v16; // rax
  int v17; // ebx
  int v18; // ebx
  int v19; // ecx
  int v20; // eax
  int v21; // eax
  __int64 v22; // rcx
  int v23; // edx
  unsigned int v24; // edi
  int v25; // ecx
  int v26; // esi
  __int64 v27; // rax
  int v28; // ebx
  int v29; // esi
  int v30; // esi
  int v31; // ebx
  __int64 v32; // [esp+0h] [ebp-9Ch]
  unsigned int v33; // [esp+0h] [ebp-9Ch]
  __int64 v34; // [esp+0h] [ebp-9Ch]
  int v35; // [esp+8h] [ebp-94h]
  __int64 v36; // [esp+8h] [ebp-94h]
  int v37; // [esp+8h] [ebp-94h]
  int v38; // [esp+8h] [ebp-94h]
  int v39; // [esp+14h] [ebp-88h]
  int v40; // [esp+18h] [ebp-84h]
  __int64 v41; // [esp+18h] [ebp-84h]
  __int64 v42; // [esp+18h] [ebp-84h]
  char v43[16]; // [esp+20h] [ebp-7Ch] BYREF
  int v44; // [esp+30h] [ebp-6Ch]
  __int64 v45; // [esp+4Ch] [ebp-50h]

  v32 = a3;
  if ( !a5 )
  {
    if ( *(_DWORD *)(a2 + 28) )
    {
      v24 = *(_DWORD *)(a2 + 16);
      v33 = *(_DWORD *)(a2 + 20);
      v25 = *(_DWORD *)a2 & 0x1000;
      if ( v33 > v24 && v25 )
      {
        v26 = *(_DWORD *)(a2 + 148);
        if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v26
                                                                                              - (_DWORD)&_start___libc_IO_vtables) )
        {
          v38 = *(_DWORD *)a2 & 0x1000;
          IO_vtable_check(a1);
          v25 = v38;
        }
        v37 = v25;
        v27 = ((__int64 (__cdecl *)(int, _DWORD, _DWORD, int))*(_DWORD *)(v26 + 64))(a2, 0, 0, 2);
        v25 = v37;
        if ( v27 == -1 )
          return -1LL;
        *(_QWORD *)(a2 + 76) = v27;
      }
      else
      {
        v27 = *(_QWORD *)(a2 + 76);
      }
      if ( v33 > v24 )
      {
        v29 = *(_DWORD *)(a2 + 20);
        if ( v25 )
          v30 = v29 - *(_DWORD *)(a2 + 16);
        else
          v30 = v29 - *(_DWORD *)(a2 + 8);
        v34 = v30;
      }
      else
      {
        LODWORD(v34) = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 8);
        HIDWORD(v34) = -((*(_DWORD *)(a2 + 4) != *(_DWORD *)(a2 + 8))
                       + ((*(_DWORD *)(a2 + 8) - *(_DWORD *)(a2 + 4)) >> 31));
      }
    }
    else
    {
      v27 = *(_QWORD *)(a2 + 76);
      v34 = 0LL;
    }
    if ( v27 == -1 )
    {
      v31 = *(_DWORD *)(a2 + 148);
      if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v31
                                                                                            - (_DWORD)&_start___libc_IO_vtables) )
        IO_vtable_check(a1);
      v27 = ((__int64 (__cdecl *)(int, _DWORD, _DWORD, int))*(_DWORD *)(v31 + 64))(a2, 0, 0, 1);
      if ( v27 == -1 )
        return -1LL;
    }
    result = v34 + v27;
    if ( result >= 0 )
      return result;
    goto LABEL_59;
  }
  if ( *(_DWORD *)(a2 + 12) != *(_DWORD *)(a2 + 8) )
  {
    v5 = *(_DWORD *)(a2 + 20);
    v6 = *(_DWORD *)(a2 + 16);
    goto LABEL_4;
  }
  v6 = *(_DWORD *)(a2 + 16);
  v5 = *(_DWORD *)(a2 + 20);
  if ( v6 != v5 )
  {
LABEL_4:
    v39 = 0;
    if ( v6 < v5 )
      goto LABEL_5;
    goto LABEL_19;
  }
  v39 = 1;
LABEL_19:
  if ( (*(_DWORD *)a2 & 0x800) == 0 )
  {
    if ( *(_DWORD *)(a2 + 28) )
      goto LABEL_7;
    goto LABEL_21;
  }
LABEL_5:
  if ( IO_switch_to_get_mode((int *)a2) )
    return -1LL;
  if ( *(_DWORD *)(a2 + 28) )
  {
LABEL_7:
    if ( a4 != 1 )
      goto LABEL_8;
    goto LABEL_24;
  }
LABEL_21:
  if ( *(_DWORD *)(a2 + 12) )
  {
    free(a1, *(_DWORD *)(a2 + 12));
    *(_DWORD *)a2 &= ~0x100u;
  }
  IO_doallocbuf(a1, (int *)a2);
  v12 = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a2 + 20) = v12;
  *(_DWORD *)(a2 + 16) = v12;
  *(_DWORD *)(a2 + 24) = v12;
  *(_DWORD *)(a2 + 12) = v12;
  *(_DWORD *)(a2 + 4) = v12;
  *(_DWORD *)(a2 + 8) = v12;
  if ( a4 == 1 )
  {
LABEL_24:
    LODWORD(v13) = *(_DWORD *)(a2 + 80);
    HIDWORD(v13) = *(_DWORD *)(a2 + 76);
    v32 = a3 - (*(_DWORD *)(a2 + 8) - *(_DWORD *)(a2 + 4));
    if ( v13 == -1 )
      goto LABEL_47;
    v32 += __PAIR64__(v13, HIDWORD(v13));
    if ( v32 >= 0 )
    {
      a4 = 0;
      goto LABEL_27;
    }
LABEL_59:
    __writegsdword(0xFFFFFFE8, 0x16u);
    return -1LL;
  }
LABEL_8:
  if ( a4 == 2 )
  {
    v7 = *(_DWORD *)(a2 + 148);
    v8 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v7
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
      IO_vtable_check(a1);
    if ( (*(int (__cdecl **)(int, char *))(v7 + 72))(a2, v43) || (v44 & 0xF000) != 0x8000 )
      goto LABEL_12;
    v32 = v45 + a3;
    a4 = 0;
  }
  LODWORD(v13) = *(_DWORD *)(a2 + 80);
  HIDWORD(v13) = *(_DWORD *)(a2 + 76);
  if ( *(_QWORD *)(a2 + 76) == -1LL )
  {
    if ( (*(_DWORD *)a2 & 4) != 0 )
      goto LABEL_47;
LABEL_31:
    v15 = *(_DWORD *)(a2 + 32);
    v16 = v32 & (*(_DWORD *)(a2 + 28) - v15);
    v36 = v32 - v16;
    if ( v32 - v16 > v15 - *(_DWORD *)(a2 + 28) )
    {
      v16 = v32;
      v36 = 0LL;
    }
    v17 = *(_DWORD *)(a2 + 148);
    v8 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v17
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
    {
      v42 = v16;
      IO_vtable_check(a1);
      v16 = v42;
    }
    v41 = ((__int64 (__cdecl *)(int, _DWORD, _DWORD, _DWORD))*(_DWORD *)(v17 + 64))(a2, v16, HIDWORD(v16), 0);
    if ( v41 >= 0 )
    {
      if ( v36 )
      {
        v18 = *(_DWORD *)(a2 + 148);
        if ( v8 <= v18 - (int)&_start___libc_IO_vtables )
          IO_vtable_check(a1);
        if ( v39 )
        {
          v20 = v36;
          v19 = *(_DWORD *)(a2 + 28);
        }
        else
        {
          v19 = *(_DWORD *)(a2 + 28);
          v20 = *(_DWORD *)(a2 + 32) - v19;
        }
        v21 = (*(int (__cdecl **)(int, int, int))(v18 + 56))(a2, v19, v20);
        v22 = v21;
        if ( v36 > v21 )
        {
          a4 = 1;
          if ( v21 == -1 )
            v32 = v36;
          else
            v32 = v36 - v21;
          goto LABEL_12;
        }
      }
      else
      {
        v22 = 0LL;
        v21 = 0;
      }
      v23 = *(_DWORD *)(a2 + 28);
      *(_DWORD *)(a2 + 12) = v23;
      *(_DWORD *)(a2 + 8) = v23 + v21;
      *(_DWORD *)(a2 + 20) = v23;
      *(_DWORD *)(a2 + 16) = v23;
      *(_DWORD *)(a2 + 24) = v23;
      *(_DWORD *)(a2 + 4) = v23 + v36;
      *(_DWORD *)(a2 + 76) = v22 + v41;
      *(_DWORD *)a2 &= ~0x10u;
      *(_DWORD *)(a2 + 80) = (unsigned __int64)(v22 + v41) >> 32;
      return v32;
    }
    return -1LL;
  }
LABEL_27:
  v35 = *(_DWORD *)a2;
  if ( !*(_DWORD *)(a2 + 12)
    || (*(_DWORD *)a2 & 0x100) != 0
    || (v40 = *(_DWORD *)(a2 + 28),
        v14 = __PAIR64__(v13, HIDWORD(v13)) - (*(_DWORD *)(a2 + 8) - v40),
        v14 > v32 || __SPAIR64__(v13, HIDWORD(v13)) <= v32) )
  {
    if ( (v35 & 4) == 0 )
      goto LABEL_31;
LABEL_47:
    v8 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
LABEL_12:
    IO_unsave_markers((int *)a2);
    v9 = *(_DWORD *)(a2 + 148);
    if ( v9 - (int)&_start___libc_IO_vtables >= v8 )
      IO_vtable_check(a1);
    result = ((__int64 (__cdecl *)(int, _DWORD, _DWORD, int))*(_DWORD *)(v9 + 64))(a2, v32, HIDWORD(v32), a4);
    if ( result != -1 )
    {
      v11 = *(_DWORD *)(a2 + 28);
      *(_DWORD *)a2 &= ~0x10u;
      *(_QWORD *)(a2 + 76) = result;
      *(_DWORD *)(a2 + 12) = v11;
      *(_DWORD *)(a2 + 4) = v11;
      *(_DWORD *)(a2 + 8) = v11;
      *(_DWORD *)(a2 + 20) = v11;
      *(_DWORD *)(a2 + 16) = v11;
      *(_DWORD *)(a2 + 24) = v11;
    }
    return result;
  }
  *(_DWORD *)(a2 + 12) = v40;
  *(_DWORD *)(a2 + 20) = v40;
  *(_DWORD *)(a2 + 16) = v40;
  *(_DWORD *)(a2 + 24) = v40;
  *(_DWORD *)(a2 + 4) = v40 + v32 - v14;
  *(_DWORD *)a2 = v35 & 0xFFFFFFEF;
  if ( (int)v13 < 0 )
    return v32;
  v28 = *(_DWORD *)(a2 + 148);
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v28
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  (*(void (__cdecl **)(int, _DWORD, _DWORD, _DWORD))(v28 + 64))(a2, *(_DWORD *)(a2 + 76), *(_DWORD *)(a2 + 80), 0);
  return v32;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 8051C70: using guessed type char var_7C[16];

//----- (080523A0) --------------------------------------------------------
unsigned int __cdecl IO_file_close_mmap(int a1)
{
  int v1; // ecx
  unsigned int result; // eax

  munmap(*(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28));
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  result = dl_sysinfo(v1);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80523CD: variable 'v1' is possibly undefined
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08052400) --------------------------------------------------------
int __usercall mmap_remap_check@<eax>(_DWORD *a1@<eax>, long double a2@<st0>)
{
  int v3; // esi
  int v4; // ebp
  int v5; // eax
  bool v6; // cc
  void *v7; // eax
  int v9; // esi
  int v10; // ecx
  unsigned int v11; // eax
  unsigned int v12; // edx
  int v13; // esi
  unsigned int v14; // edx
  unsigned int v15; // ecx
  __int64 v16; // rax
  int v17; // edi
  __int64 v18; // rdi
  int v19; // edx
  int v20; // [esp-10h] [ebp-ACh]
  signed __int64 v21; // [esp+8h] [ebp-94h]
  __int64 v22; // [esp+10h] [ebp-8Ch]
  int v23; // [esp+10h] [ebp-8Ch]
  unsigned int v24; // [esp+1Ch] [ebp-80h]
  char v25[16]; // [esp+20h] [ebp-7Ch] BYREF
  int v26; // [esp+30h] [ebp-6Ch]
  __int64 v27; // [esp+4Ch] [ebp-50h]

  v3 = a1[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v3
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a2);
  v4 = (*(int (__cdecl **)(_DWORD *, char *))(v3 + 72))(a1, v25);
  if ( !v4 && (v26 & 0xF000) == 0x8000 )
  {
    v9 = v27;
    if ( v27 <= 0xFFFFF )
    {
      if ( v27 )
      {
        v10 = getpagesize();
        v22 = (v9 + v10 - 1) & (unsigned int)-v10;
        v11 = a1[7];
        v24 = v11;
        v12 = -v10 & (v10 + a1[8] + ~v11);
        if ( (unsigned int)v22 < v12 )
        {
          munmap((-v10 & (v9 - 1 + v10)) + v11, v12 - (-v10 & (v9 - 1 + v10)));
          v24 = a1[7];
          v11 = v24;
          v23 = v24 + v27;
          a1[8] = v24 + v27;
LABEL_14:
          v13 = a1[2] - a1[1];
          v14 = a1[19];
          v15 = a1[20];
          a1[3] = v11;
          v21 = __PAIR64__(v15, v14) - v13;
          *(_QWORD *)(a1 + 19) = v21;
          if ( v21 >= (int)(v23 - v24) )
          {
            a1[1] = v23;
            a1[2] = v23;
          }
          else
          {
            a1[1] = v21 + v11;
            v20 = a1[14];
            a1[2] = v23;
            v16 = lseek64(v20, v23 - v24, (int)(v23 - v24) >> 31);
            v17 = a1[8] - a1[7];
            HIDWORD(v18) = v16 ^ v17;
            LODWORD(v18) = HIDWORD(v16) ^ (v17 >> 31);
            if ( v18 )
              *a1 |= 0x20u;
            else
              *(_QWORD *)(a1 + 19) = v16;
          }
          return v4;
        }
        if ( v22 <= v12 )
        {
          v23 = v11 + v9;
          a1[8] = v11 + v9;
          goto LABEL_14;
        }
        v11 = mremap(v11, v12);
        if ( v11 != -1 )
        {
          v19 = v27;
          a1[7] = v11;
          v24 = v11;
          v23 = v11 + v19;
          a1[8] = v11 + v19;
          goto LABEL_14;
        }
      }
    }
  }
  v4 = 1;
  munmap(a1[7], a1[8] - a1[7]);
  v5 = a1[26];
  a1[8] = 0;
  a1[7] = 0;
  a1[3] = 0;
  a1[1] = 0;
  v6 = v5 <= 0;
  v7 = &IO_wfile_jumps;
  a1[2] = 0;
  if ( v6 )
    v7 = &IO_file_jumps;
  a1[37] = v7;
  *(_DWORD *)(a1[22] + 176) = &IO_wfile_jumps;
  return v4;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 8052400: using guessed type char var_7C[16];

//----- (080526A0) --------------------------------------------------------
__int64 __cdecl IO_file_seek(int a1, int a2, int a3)
{
  return lseek64(*(_DWORD *)(a1 + 56), a2, a3);
}

//----- (080526B0) --------------------------------------------------------
int __cdecl IO_file_sync_mmap(int a1)
{
  int v1; // ecx
  __int64 v2; // rax
  __int64 v3; // rcx
  int v4; // eax

  v1 = *(_DWORD *)(a1 + 4);
  if ( v1 == *(_DWORD *)(a1 + 8) )
  {
    v3 = v1 - *(_DWORD *)(a1 + 28);
    goto LABEL_3;
  }
  v2 = lseek64(*(_DWORD *)(a1 + 56), v1 - *(_DWORD *)(a1 + 28), (v1 - *(_DWORD *)(a1 + 28)) >> 31);
  v3 = *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 28);
  if ( (int)v3 == (unsigned __int64)v2 )
  {
LABEL_3:
    v4 = *(_DWORD *)(a1 + 12);
    *(_QWORD *)(a1 + 76) = v3;
    *(_DWORD *)(a1 + 4) = v4;
    *(_DWORD *)(a1 + 8) = v4;
    return 0;
  }
  *(_DWORD *)a1 |= 0x20u;
  return -1;
}

//----- (08052720) --------------------------------------------------------
unsigned int __usercall decide_maybe_mmap@<eax>(unsigned int *a1@<eax>, long double a2@<st0>)
{
  unsigned int v3; // esi
  void *v4; // eax
  unsigned int result; // eax
  unsigned int v6; // ecx
  unsigned int v7; // esi
  unsigned int v8; // ebp
  __int64 v9; // rax
  __int64 v10; // rdi
  int v11; // edx
  unsigned int v12; // eax
  unsigned int v13; // ebp
  unsigned int v14; // eax
  void *v15; // eax
  char v16[16]; // [esp+10h] [ebp-7Ch] BYREF
  int v17; // [esp+20h] [ebp-6Ch]
  __int64 v18; // [esp+3Ch] [ebp-50h]

  v3 = a1[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= v3 - (unsigned int)&_start___libc_IO_vtables )
    IO_vtable_check(a2);
  if ( (*(int (__cdecl **)(unsigned int *, char *))(v3 + 72))(a1, v16) )
    goto LABEL_5;
  if ( (v17 & 0xF000) != 0x8000 )
    goto LABEL_5;
  if ( v18 > 0xFFFFF )
    goto LABEL_5;
  if ( !v18 )
    goto LABEL_5;
  v6 = a1[20];
  v7 = a1[19];
  if ( v18 < __SPAIR64__(v6, v7) && (v7 & v6) != -1 )
    goto LABEL_5;
  v8 = mmap64(0, v18, 1, 1, a1[14], 0LL);
  if ( v8 == -1 )
    goto LABEL_5;
  v9 = lseek64(a1[14], v18, SHIDWORD(v18));
  if ( v18 != v9 )
  {
    munmap(v8, v18);
    a1[19] = -1;
    a1[20] = -1;
LABEL_5:
    v4 = &IO_wfile_jumps;
    if ( (int)a1[26] <= 0 )
      v4 = &IO_file_jumps;
    a1[37] = (unsigned int)v4;
    result = a1[22];
    *(_DWORD *)(result + 176) = &IO_wfile_jumps;
    return result;
  }
  IO_setb(a1, v8, v8 + v18, 0);
  LODWORD(v10) = a1[20];
  HIDWORD(v10) = a1[19];
  v11 = a1[26];
  a1[3] = v8;
  v12 = 0;
  if ( v10 != -1 )
    v12 = a1[19];
  a1[1] = v8 + v12;
  v13 = v18 + v8;
  a1[19] = v18;
  v14 = HIDWORD(v18);
  a1[2] = v13;
  a1[20] = v14;
  v15 = &IO_wfile_jumps_mmap;
  if ( v11 <= 0 )
    v15 = &IO_file_jumps_mmap;
  a1[37] = (unsigned int)v15;
  result = a1[22];
  *(_DWORD *)(result + 176) = &IO_wfile_jumps_mmap;
  return result;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 8052720: using guessed type char var_7C[16];

//----- (080528D0) --------------------------------------------------------
int __usercall IO_file_underflow_maybe_mmap@<eax>(long double a1@<st0>, unsigned int *a2)
{
  unsigned int v2; // esi

  decide_maybe_mmap(a2, a1);
  v2 = a2[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= v2 - (unsigned int)&_start___libc_IO_vtables )
    IO_vtable_check(a1);
  return (*(int (__cdecl **)(unsigned int *))(v2 + 16))(a2);
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08052930) --------------------------------------------------------
int __usercall IO_file_xsgetn_maybe_mmap@<eax>(long double a1@<st0>, unsigned int *a2, int a3, int a4)
{
  unsigned int v4; // ebp

  decide_maybe_mmap(a2, a1);
  v4 = a2[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= v4 - (unsigned int)&_start___libc_IO_vtables )
    IO_vtable_check(a1);
  return (*(int (__cdecl **)(unsigned int *, int, int))(v4 + 32))(a2, a3, a4);
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08052990) --------------------------------------------------------
unsigned int __cdecl IO_file_stat(int a1, int a2)
{
  return _fxstat64(3, *(_DWORD *)(a1 + 56), a2);
}

//----- (080529B0) --------------------------------------------------------
int __cdecl IO_new_file_write(int a1, int a2, int a3)
{
  int v4; // edi
  int v5; // eax
  int result; // eax

  if ( a3 > 0 )
  {
    v4 = a3;
    while ( 1 )
    {
      if ( (*(_BYTE *)(a1 + 60) & 2) != 0 )
      {
        v5 = dl_sysinfo(a2);
        if ( (unsigned int)v5 > 0xFFFFF000 )
        {
          v5 = _syscall_error(v5);
          if ( v5 < 0 )
          {
LABEL_9:
            *(_DWORD *)a1 |= 0x20u;
            result = a3 - v4;
            goto LABEL_10;
          }
          goto LABEL_5;
        }
      }
      else
      {
        v5 = write(*(_DWORD *)(a1 + 56), a2, v4);
      }
      if ( v5 < 0 )
        goto LABEL_9;
LABEL_5:
      v4 -= v5;
      a2 += v5;
      if ( v4 <= 0 )
      {
        result = a3 - v4;
        goto LABEL_10;
      }
    }
  }
  result = 0;
LABEL_10:
  if ( *(int *)(a1 + 80) >= 0 )
    *(_QWORD *)(a1 + 76) += result;
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08052A60) --------------------------------------------------------
int __usercall IO_file_xsgetn_mmap@<eax>(long double a1@<st0>, _DWORD *a2, _BYTE *a3, unsigned int a4)
{
  _BYTE *v4; // edi
  _BYTE *v5; // edx
  unsigned int v6; // ebx
  int v7; // eax
  _WORD *v9; // eax
  int v10; // edi
  _BYTE *v11; // [esp+1Ch] [ebp-20h]
  _WORD *v12; // [esp+1Ch] [ebp-20h]

  v4 = (_BYTE *)a2[1];
  v5 = a3;
  v6 = a2[2] - (_DWORD)v4;
  if ( v6 >= a4 )
    goto LABEL_6;
  if ( (*a2 & 0x100) != 0 )
  {
    a4 -= v6;
    v12 = mempcpy(a3, v4, a2[2] - (_DWORD)v4);
    IO_switch_to_main_get_area(a2);
    v4 = (_BYTE *)a2[1];
    v5 = v12;
    v6 = a2[2] - (_DWORD)v4;
    if ( a4 <= v6 )
      goto LABEL_9;
  }
  v11 = v5;
  v7 = mmap_remap_check(a2, a1);
  v5 = v11;
  if ( !v7 )
  {
    v4 = (_BYTE *)a2[1];
    v6 = a2[2] - (_DWORD)v4;
    if ( a4 > v6 )
      *a2 |= 0x10u;
LABEL_6:
    if ( !v6 )
      return v5 - a3;
LABEL_9:
    if ( a4 <= v6 )
      v6 = a4;
    v9 = mempcpy(v5, v4, v6);
    a2[1] = &v4[v6];
    v5 = v9;
    return v5 - a3;
  }
  v10 = a2[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v10
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  return v11 - a3 + (*(int (__cdecl **)(_DWORD *, _BYTE *, unsigned int))(v10 + 32))(a2, a3, a4);
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08052B50) --------------------------------------------------------
unsigned int __usercall IO_file_xsgetn@<eax>(long double a1@<st0>, int a2, _BYTE *a3, unsigned int a4)
{
  _BYTE *v4; // eax
  unsigned int v5; // ebp
  unsigned int v6; // esi
  int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // esi
  int v10; // edi
  int v11; // eax
  _WORD *v13; // eax

  if ( !*(_DWORD *)(a2 + 28) )
  {
    if ( *(_DWORD *)(a2 + 36) )
    {
      free(a1, *(_DWORD *)(a2 + 36));
      *(_DWORD *)a2 &= ~0x100u;
    }
    IO_doallocbuf(a1, (int *)a2);
  }
  if ( a4 )
  {
    v4 = *(_BYTE **)(a2 + 4);
    v5 = a4;
    v6 = *(_DWORD *)(a2 + 8) - (_DWORD)v4;
    if ( a4 > v6 )
    {
      while ( 1 )
      {
        if ( v6 )
        {
          v5 -= v6;
          v13 = mempcpy(a3, v4, v6);
          *(_DWORD *)(a2 + 4) += v6;
          a3 = v13;
        }
        if ( (*(_DWORD *)a2 & 0x100) != 0 )
        {
          IO_switch_to_main_get_area((_DWORD *)a2);
          goto LABEL_16;
        }
        v7 = *(_DWORD *)(a2 + 28);
        if ( !v7 )
          break;
        v8 = *(_DWORD *)(a2 + 32) - v7;
        if ( v5 < v8 )
        {
          if ( _underflow((int *)a2) == -1 )
            return a4 - v5;
          goto LABEL_16;
        }
        *(_DWORD *)(a2 + 12) = v7;
        *(_DWORD *)(a2 + 4) = v7;
        *(_DWORD *)(a2 + 8) = v7;
        *(_DWORD *)(a2 + 20) = v7;
        *(_DWORD *)(a2 + 16) = v7;
        *(_DWORD *)(a2 + 24) = v7;
        if ( v8 <= 0x7F )
          goto LABEL_22;
        v9 = v5 - v5 % v8;
LABEL_11:
        v10 = *(_DWORD *)(a2 + 148);
        if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v10
                                                                                              - (_DWORD)&_start___libc_IO_vtables) )
          IO_vtable_check(a1);
        v11 = (*(int (__cdecl **)(int, _BYTE *, unsigned int))(v10 + 56))(a2, a3, v9);
        if ( v11 <= 0 )
        {
          if ( v11 )
            *(_DWORD *)a2 |= 0x20u;
          else
            *(_DWORD *)a2 |= 0x10u;
          return a4 - v5;
        }
        v5 -= v11;
        a3 += v11;
        if ( *(_QWORD *)(a2 + 76) != -1LL )
          *(_QWORD *)(a2 + 76) += v11;
LABEL_16:
        if ( !v5 )
          goto LABEL_19;
        v4 = *(_BYTE **)(a2 + 4);
        v6 = *(_DWORD *)(a2 + 8) - (_DWORD)v4;
        if ( v6 >= v5 )
          goto LABEL_18;
      }
      *(_DWORD *)(a2 + 12) = 0;
      *(_DWORD *)(a2 + 4) = 0;
      *(_DWORD *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 20) = 0;
      *(_DWORD *)(a2 + 16) = 0;
      *(_DWORD *)(a2 + 24) = 0;
LABEL_22:
      v9 = v5;
      goto LABEL_11;
    }
LABEL_18:
    memcpy(a3, v4, v5);
    *(_DWORD *)(a2 + 4) += v5;
  }
LABEL_19:
  v5 = 0;
  return a4 - v5;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08052D80) --------------------------------------------------------
int __usercall IO_file_seekoff_mmap@<eax>(long double a1@<st0>, _DWORD *a2, __int64 a3, int a4, int a5)
{
  int v5; // edi
  int v6; // esi
  int v7; // ebp
  __int64 v8; // kr10_8
  int v9; // ecx
  int v11; // ecx
  int v12; // [esp+Ch] [ebp-20h]

  v5 = HIDWORD(a3);
  v6 = a3;
  if ( !a5 )
    return a2[19] - (a2[2] - a2[1]);
  if ( a4 == 1 )
  {
    v5 = (unsigned __int64)(a2[1] - a2[3] + a3) >> 32;
    v6 = a2[1] - a2[3] + a3;
  }
  else if ( a4 == 2 )
  {
    v5 = (unsigned __int64)(a2[8] - a2[7] + a3) >> 32;
    v6 = a2[8] - a2[7] + a3;
  }
  if ( v5 < 0 )
  {
    v6 = -1;
    __writegsdword(0xFFFFFFE8, 0x16u);
  }
  else
  {
    v7 = a2[37];
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v7
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
      IO_vtable_check(a1);
    v8 = ((__int64 (__cdecl *)(_DWORD *, int, int, _DWORD))*(_DWORD *)(v7 + 64))(a2, v6, v5, 0);
    if ( v8 < 0 )
    {
      return -1;
    }
    else
    {
      v9 = a2[7];
      v12 = a2[8];
      a2[3] = v9;
      if ( __SPAIR64__(v5, v6) > v12 - v9 )
      {
        a2[1] = v12;
        a2[2] = v12;
      }
      else
      {
        v11 = v6 + v9;
        a2[1] = v11;
        a2[2] = v11;
      }
      *a2 &= ~0x10u;
      *(_QWORD *)(a2 + 19) = v8;
    }
  }
  return v6;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08052EC0) --------------------------------------------------------
int __usercall IO_file_underflow_mmap@<eax>(long double a1@<st0>, _DWORD *a2)
{
  unsigned __int8 *v2; // eax
  int v4; // esi

  v2 = (unsigned __int8 *)a2[1];
  if ( (unsigned int)v2 < a2[2] )
    return *v2;
  if ( mmap_remap_check(a2, a1) )
  {
    v4 = a2[37];
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v4
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
      IO_vtable_check(a1);
    return (*(int (__cdecl **)(_DWORD *))(v4 + 16))(a2);
  }
  else
  {
    v2 = (unsigned __int8 *)a2[1];
    if ( (unsigned int)v2 < a2[2] )
      return *v2;
    *a2 |= 0x10u;
    return -1;
  }
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08052F40) --------------------------------------------------------
unsigned int __cdecl IO_file_read(int a1, int a2, int a3)
{
  unsigned int result; // eax

  if ( (*(_BYTE *)(a1 + 60) & 2) == 0 )
    return read(*(_DWORD *)(a1 + 56), a2, a3);
  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08052F90) --------------------------------------------------------
int __usercall IO_new_file_xsputn@<eax>(long double a1@<st0>, _DWORD *a2, _BYTE *a3, unsigned int a4)
{
  int result; // eax
  unsigned int v5; // esi
  unsigned int v6; // eax
  _BYTE *v7; // edx
  unsigned int v8; // ecx
  int v9; // ebp
  unsigned int v10; // edi
  unsigned int v11; // edi
  int v12; // ebp
  unsigned int v13; // ecx
  int v14; // edx
  unsigned int v15; // ebp
  _BYTE *v16; // edi
  _BYTE *v17; // eax
  unsigned int v18; // eax
  int v19; // eax

  result = 0;
  v5 = (unsigned int)a3;
  if ( !a4 )
    return result;
  if ( (*a2 & 0xA00) == 2560 )
  {
    v7 = (_BYTE *)a2[5];
    v8 = a2[8] - (_DWORD)v7;
    if ( a4 <= v8 )
    {
      v16 = &a3[a4];
      if ( a3 < &a3[a4] )
      {
        v17 = v16 - 1;
        if ( *(v16 - 1) == 10 )
        {
LABEL_34:
          v19 = v17 - a3;
          v9 = 1;
          v11 = a4;
          v8 = v19 + 1;
          if ( v19 == -1 )
            goto LABEL_10;
          goto LABEL_7;
        }
        while ( a3 != v17 )
        {
          if ( *--v17 == 10 )
            goto LABEL_34;
        }
      }
LABEL_6:
      v9 = 0;
LABEL_7:
      if ( a4 <= v8 )
        v8 = a4;
      v10 = v8;
      v5 = (unsigned int)&a3[v8];
      a2[5] = mempcpy(v7, a3, v8);
      v11 = a4 - v10;
LABEL_10:
      if ( !(v11 + v9) )
        return a4 - v11;
      goto LABEL_14;
    }
  }
  else
  {
    v6 = a2[6];
    v7 = (_BYTE *)a2[5];
    if ( v6 <= (unsigned int)v7 )
      goto LABEL_13;
    v8 = v6 - (_DWORD)v7;
  }
  if ( v8 )
    goto LABEL_6;
LABEL_13:
  v11 = a4;
LABEL_14:
  v12 = a2[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v12
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  result = (*(int (__cdecl **)(_DWORD *, int))(v12 + 12))(a2, -1);
  if ( result != -1 )
  {
    v13 = a2[8] - a2[7];
    v14 = 0;
    if ( v13 > 0x7F )
      v14 = v11 % v13;
    v15 = v11 - v14;
    if ( v11 == v14 || (v18 = new_do_write((int)a2, v5, v11 - v14), v11 -= v18, v15 <= v18) )
    {
      if ( v11 )
        v11 -= IO_default_xsputn(a1, a2, (unsigned __int8 *)(v15 + v5), v11);
    }
    return a4 - v11;
  }
  if ( v11 )
    return a4 - v11;
  return result;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08053120) --------------------------------------------------------
int __cdecl IO_new_file_init_internal(int *a1)
{
  int result; // eax

  *a1 |= 0x240Cu;
  a1[19] = -1;
  a1[20] = -1;
  result = IO_link_in(a1);
  a1[14] = -1;
  return result;
}

//----- (08053150) --------------------------------------------------------
int __cdecl IO_new_file_init(int *a1)
{
  int result; // eax

  *a1 |= 0x240Cu;
  a1[19] = -1;
  a1[20] = -1;
  result = IO_link_in(a1);
  a1[14] = -1;
  return result;
}

//----- (08053180) --------------------------------------------------------
int __cdecl IO_file_open(int a1, int a2, int a3, int a4, __int16 a5, int a6)
{
  int v6; // ebx
  int v7; // edx
  int v9; // edi
  __int64 v10; // rax
  unsigned int v11; // eax
  unsigned int v12; // eax

  if ( (*(_BYTE *)(a1 + 60) & 2) != 0 )
  {
    v12 = dl_sysinfo(a3 | ((unsigned __int8)(a6 == 0) << 15));
    v6 = v12;
    if ( v12 > 0xFFFFF000 )
      v6 = _syscall_error(v12);
  }
  else
  {
    v6 = open(a2, a3 | ((a6 == 0) << 15), a4);
  }
  if ( v6 < 0 )
    return 0;
  v7 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 56) = v6;
  *(_DWORD *)a1 = a5 & 0x100C | v7 & 0xFFFFEFF3;
  if ( (a5 & 0x1004) != 4100 )
    goto LABEL_5;
  v9 = *(_DWORD *)(a1 + 148);
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v9
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check();
  v10 = ~((__int64 (__cdecl *)(int, _DWORD, _DWORD, int))*(_DWORD *)(v9 + 64))(a1, 0, 0, 2);
  if ( v10 || __readgsdword(0xFFFFFFE8) == 29 )
  {
LABEL_5:
    IO_link_in((int *)a1);
    return a1;
  }
  v11 = dl_sysinfo((unsigned int)v10 | HIDWORD(v10));
  if ( v11 <= 0xFFFFF000 )
    return 0;
  _syscall_error(v11);
  return 0;
}
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080532B0) --------------------------------------------------------
unsigned int *__usercall IO_new_file_attach@<eax>(long double a1@<st0>, unsigned int *a2, unsigned int a3)
{
  unsigned int v3; // ebp
  unsigned int v4; // edi

  if ( a2[14] != -1 )
    return 0;
  v3 = a2[37];
  a2[19] = -1;
  a2[20] = -1;
  a2[14] = a3;
  v4 = __readgsdword(0xFFFFFFE8);
  *a2 = *a2 & 0xFFFFFFB3 | 0x40;
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= v3 - (unsigned int)&_start___libc_IO_vtables )
    IO_vtable_check(a1);
  if ( ((__int64 (__cdecl *)(unsigned int *, _DWORD, _DWORD, int, int))*(_DWORD *)(v3 + 36))(a2, 0, 0, 1, 3) == -1
    && __readgsdword(0xFFFFFFE8) != 29 )
  {
    return 0;
  }
  __writegsdword(0xFFFFFFE8, v4);
  return a2;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08053350) --------------------------------------------------------
int __cdecl IO_new_do_write(int a1, unsigned int a2, int a3)
{
  int result; // eax

  result = 0;
  if ( a3 )
    return -(a3 != new_do_write(a1, a2, a3));
  return result;
}

//----- (08053380) --------------------------------------------------------
int __cdecl IO_new_file_close_it(int a1)
{
  int v1; // esi
  int v2; // edi
  _DWORD *v3; // eax
  int v5; // esi

  v1 = *(_DWORD *)(a1 + 56);
  if ( v1 != -1 )
  {
    v2 = 0;
    if ( (*(_DWORD *)a1 & 0x808) == 2048 )
    {
      if ( *(int *)(a1 + 104) <= 0 )
        v2 = IO_new_do_write(a1, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16));
      else
        v2 = IO_wdo_write(
               (_DWORD *)a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 88) + 12),
               (*(_DWORD *)(*(_DWORD *)(a1 + 88) + 16) - *(_DWORD *)(*(_DWORD *)(a1 + 88) + 12)) >> 2);
    }
    v1 = 0;
    IO_unsave_markers((int *)a1);
    if ( (*(_BYTE *)(a1 + 60) & 0x20) == 0 )
    {
      v5 = *(_DWORD *)(a1 + 148);
      if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v5
                                                                                            - (_DWORD)&_start___libc_IO_vtables) )
        IO_vtable_check();
      v1 = (*(int (__cdecl **)(int))(v5 + 68))(a1);
    }
    if ( *(int *)(a1 + 104) > 0 )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 88) + 32) )
        IO_free_wbackup_area((int *)a1);
      IO_wsetb(a1, 0, 0, 0);
      v3 = *(_DWORD **)(a1 + 88);
      v3[2] = 0;
      *v3 = 0;
      v3[1] = 0;
      v3[4] = 0;
      v3[3] = 0;
      v3[5] = 0;
    }
    IO_setb((unsigned int *)a1, 0, 0, 0);
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    IO_un_link((int *)a1);
    *(_DWORD *)a1 = -72539124;
    *(_DWORD *)(a1 + 56) = -1;
    *(_DWORD *)(a1 + 76) = -1;
    if ( !v1 )
      v1 = v2;
    *(_DWORD *)(a1 + 80) = -1;
  }
  return v1;
}
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08053510) --------------------------------------------------------
int __cdecl IO_new_file_fopen(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  _BYTE *v4; // eax
  char v5; // dl
  __int16 v7; // di
  int v8; // ebp
  int v9; // ecx
  _BYTE *v10; // ebx
  char v11; // dl
  int v12; // eax
  _BYTE *v13; // ebx
  char *v14; // esi
  int v15; // edx
  char v16; // al
  char *v17; // ecx
  int v18; // edi
  char *v19; // ebx
  _BYTE *v20; // eax
  int v21; // eax
  int v22; // edx
  _DWORD *v23; // eax
  int v24; // edx
  int v25; // eax
  _DWORD *v26; // eax
  int v27; // edx
  int v28; // ecx
  int v29; // edx
  int v30; // ecx
  unsigned int v31; // esi
  char *v32; // [esp+1Ch] [ebp-40h]
  int v33; // [esp+20h] [ebp-3Ch]
  char *v34; // [esp+24h] [ebp-38h]
  int v35; // [esp+28h] [ebp-34h]
  int v36; // [esp+2Ch] [ebp-30h]
  int v37[11]; // [esp+30h] [ebp-2Ch] BYREF

  v4 = a3;
  if ( a1[14] != -1 )
    return 0;
  v5 = *a3;
  if ( *a3 == 114 )
  {
    v7 = 8;
    v8 = 0;
    v9 = 0;
  }
  else if ( v5 == 119 )
  {
    v7 = 4;
    v8 = 1;
    v9 = 576;
  }
  else
  {
    if ( v5 != 97 )
    {
      __writegsdword(0xFFFFFFE8, 0x16u);
      return 0;
    }
    v7 = 4100;
    v8 = 1;
    v9 = 1088;
  }
  v10 = a3;
  do
  {
    v11 = *++v4;
    if ( *v4 == 99 )
    {
      a1[15] |= 2u;
    }
    else if ( v11 > 99 )
    {
      switch ( v11 )
      {
        case 'm':
          a1[15] |= 1u;
          break;
        case 'x':
          LOBYTE(v9) = v9 | 0x80;
LABEL_41:
          v10 = v4;
          break;
        case 'e':
          v9 |= 0x80000u;
          a1[15] |= 0x40u;
          break;
      }
    }
    else
    {
      switch ( v11 )
      {
        case 43:
          v7 &= 0x1000u;
          v10 = v4;
          v8 = 2;
          break;
        case 98:
          goto LABEL_41;
        case 0:
          goto LABEL_16;
      }
    }
  }
  while ( v4 != a3 + 6 );
LABEL_16:
  v33 = IO_file_open((int)a1, a2, v8 | v9, 438, v7, a4);
  if ( !v33 )
    return 0;
  v12 = strstr(v10 + 1, ",ccs=");
  v36 = v12;
  if ( !v12 )
    return v33;
  v13 = (_BYTE *)(v12 + 5);
  v14 = (char *)strchrnul((unsigned int *)(v12 + 5), 44) - v12 - 5;
  v34 = (char *)malloc(v14 + 3);
  if ( !v34 )
  {
    v31 = __readgsdword(0xFFFFFFE8);
    IO_new_file_close_it((int)a1);
    __writegsdword(0xFFFFFFE8, v31);
    return 0;
  }
  *(_BYTE *)mempcpy(v34, v13, (unsigned int)v14) = 0;
  v16 = *v34;
  if ( *v34 )
  {
    v17 = v34;
    v35 = 0;
    v32 = v34;
    do
    {
      while ( 1 )
      {
        LOBYTE(v15) = v16 == 58;
        v18 = v15;
        LOBYTE(v15) = v16 == 95;
        v15 |= v18;
        if ( !((unsigned __int8)v15 | ((unsigned __int8)(v16 - 44) <= 2u)) && (byte_80C2440[2 * v16] & 8) == 0 )
          break;
        ++v17;
        *v32++ = dword_80C1B40[v16];
        v16 = *v17;
        if ( !*v17 )
          goto LABEL_26;
      }
      if ( v16 == 47 )
      {
        if ( ++v35 == 3 )
        {
          v19 = v32;
          goto LABEL_29;
        }
        *v32++ = 47;
      }
      v16 = *++v17;
    }
    while ( *v17 );
LABEL_26:
    v19 = v32;
    if ( v35 > 1 )
      goto LABEL_29;
    v20 = v32 + 1;
    *v32 = 47;
    if ( v35 )
    {
      v19 = v32 + 1;
      goto LABEL_29;
    }
  }
  else
  {
    *v34 = 47;
    v20 = v34 + 1;
  }
  v19 = v20 + 1;
  *v20 = 47;
LABEL_29:
  *v19 = 0;
  if ( !v34[2] )
  {
    v21 = 0;
    do
    {
      v22 = dword_80C1B40[*(char *)(v36 + v21 + 5)];
      v34[v21++] = v22;
    }
    while ( (_BYTE)v22 );
  }
  if ( _wcsmbs_named_conv(v37, (int)v34) )
  {
    IO_new_file_close_it((int)a1);
    free(v34);
    __writegsdword(0xFFFFFFE8, 0x16u);
    return 0;
  }
  free(v34);
  if ( v37[1] != 1 )
    _assert_fail("fcts.towc_nsteps == 1", 134990472, 391, "_IO_new_file_fopen");
  if ( v37[3] != 1 )
    _assert_fail("fcts.tomb_nsteps == 1", 134990472, 392, "_IO_new_file_fopen");
  v23 = (_DWORD *)a1[22];
  v24 = v23[1];
  v23[11] = 0;
  v23[12] = 0;
  *v23 = v24;
  v23[4] = v23[3];
  v25 = a1[22];
  *(_DWORD *)(v25 + 52) = 0;
  *(_DWORD *)(v25 + 56) = 0;
  v26 = (_DWORD *)a1[22];
  a1[21] = v26 + 15;
  v27 = v37[0];
  qmemcpy(v26 + 15, &_libio_codecvt, 0x70u);
  v26[23] = 1;
  v26[24] = v27;
  v26[28] = 0;
  v26[29] = 1;
  v26[27] = 1;
  v28 = *(_DWORD *)(v33 + 88);
  v26[33] = 1;
  v26[38] = 0;
  v29 = v28 + 44;
  v30 = v37[2];
  v26[30] = v29;
  v26[34] = v30;
  v26[39] = 1;
  v26[37] = 9;
  v26[40] = v29;
  a1[37] = v26[44];
  *(_DWORD *)(v33 + 104) = 1;
  return v33;
}
// 805368A: variable 'v15' is possibly undefined
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80C1B40: using guessed type _DWORD dword_80C1B40[256];
// 80C2440: using guessed type _BYTE byte_80C2440[512];

//----- (080539A0) --------------------------------------------------------
_DWORD *__usercall IO_new_file_finish@<eax>(long double a1@<st0>, int *a2)
{
  int v2; // esi

  if ( a2[14] != -1 )
  {
    if ( a2[26] <= 0 )
      IO_new_do_write((int)a2, a2[4], a2[5] - a2[4]);
    else
      IO_wdo_write(a2, *(_DWORD *)(a2[22] + 12), (*(_DWORD *)(a2[22] + 16) - *(_DWORD *)(a2[22] + 12)) >> 2);
    if ( (*(_BYTE *)a2 & 0x40) == 0 )
    {
      v2 = a2[37];
      if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                            - (_DWORD)&_start___libc_IO_vtables) )
        IO_vtable_check(a1);
      (*(void (__cdecl **)(int *))(v2 + 68))(a2);
    }
  }
  return IO_default_finish(a1, a2);
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08053A40) --------------------------------------------------------
int __usercall IO_new_file_overflow@<eax>(long double a1@<st0>, int *a2, int a3)
{
  int v3; // eax
  _BYTE *v4; // edx
  _BYTE *v6; // ecx
  _BYTE *v7; // edi
  int v8; // ecx
  int v9; // ecx
  bool v10; // al
  unsigned int v11; // edi
  int v12; // eax

  v3 = *a2;
  if ( (*a2 & 8) != 0 )
  {
    *a2 = v3 | 0x20;
    __writegsdword(0xFFFFFFE8, 9u);
    return -1;
  }
  if ( (v3 & 0x800) == 0 )
  {
    if ( a2[4] )
    {
      v4 = (_BYTE *)a2[1];
LABEL_13:
      if ( (v3 & 0x100) != 0 )
      {
        v11 = a2[2] - (_DWORD)v4;
        IO_free_backup_area(a2);
        v12 = a2[7] - a2[3];
        if ( v11 < a2[3] - a2[7] )
          v12 = -v11;
        v4 = (_BYTE *)(v12 + a2[3]);
        v3 = *a2;
        a2[3] = (int)v4;
        a2[1] = (int)v4;
      }
      v6 = (_BYTE *)a2[8];
      if ( v6 == v4 )
      {
        v4 = (_BYTE *)a2[7];
        a2[2] = (int)v4;
        v7 = v4;
      }
      else
      {
        v7 = (_BYTE *)a2[2];
      }
      a2[6] = (int)v6;
      v8 = v3;
      a2[5] = (int)v4;
      BYTE1(v8) = BYTE1(v3) | 8;
      a2[4] = (int)v4;
      a2[1] = (int)v7;
      *a2 = v8;
      v9 = a2[26];
      a2[3] = (int)v7;
      if ( v9 <= 0 && (v3 & 0x202) != 0 )
        a2[6] = (int)v4;
      goto LABEL_5;
    }
LABEL_31:
    IO_doallocbuf(a1, a2);
    v4 = (_BYTE *)a2[7];
    v3 = *a2;
    a2[3] = (int)v4;
    a2[1] = (int)v4;
    a2[2] = (int)v4;
    goto LABEL_13;
  }
  if ( !a2[4] )
    goto LABEL_31;
  v4 = (_BYTE *)a2[5];
LABEL_5:
  if ( a3 != -1 )
  {
    if ( v4 == (_BYTE *)a2[8] )
    {
      if ( a2[26] <= 0 )
        v10 = IO_new_do_write((int)a2, a2[4], (int)&v4[-a2[4]]) == -1;
      else
        v10 = IO_wdo_write(a2, *(_DWORD *)(a2[22] + 12), (*(_DWORD *)(a2[22] + 16) - *(_DWORD *)(a2[22] + 12)) >> 2) == -1;
      if ( v10 )
        return -1;
      v4 = (_BYTE *)a2[5];
    }
    a2[5] = (int)(v4 + 1);
    *v4 = a3;
    if ( (*a2 & 2) == 0 && ((*a2 & 0x200) == 0 || a3 != 10) || IO_new_do_write((int)a2, a2[4], a2[5] - a2[4]) != -1 )
      return (unsigned __int8)a3;
    return -1;
  }
  return IO_new_do_write((int)a2, a2[4], (int)&v4[-a2[4]]);
}

//----- (08053C40) --------------------------------------------------------
int __usercall IO_new_file_sync@<eax>(long double a1@<st0>, _DWORD *a2)
{
  unsigned int v2; // eax
  unsigned int v3; // edx
  bool v4; // al
  int v5; // edi
  int v6; // esi

  v2 = a2[5];
  v3 = a2[4];
  if ( v2 <= v3
    || ((int)a2[26] <= 0
      ? (v4 = IO_new_do_write((int)a2, v3, v2 - v3) != 0)
      : (v4 = IO_wdo_write(a2, *(_DWORD *)(a2[22] + 12), (*(_DWORD *)(a2[22] + 16) - *(_DWORD *)(a2[22] + 12)) >> 2) != 0),
        !v4) )
  {
    v5 = a2[1] - a2[2];
    if ( !v5 )
    {
LABEL_10:
      a2[19] = -1;
      a2[20] = -1;
      return 0;
    }
    v6 = a2[37];
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v6
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
      IO_vtable_check(a1);
    if ( ((__int64 (__cdecl *)(_DWORD *, int, int, int))*(_DWORD *)(v6 + 64))(a2, v5, v5 >> 31, 1) != -1 )
    {
      a2[2] = a2[1];
      goto LABEL_10;
    }
    if ( __readgsdword(0xFFFFFFE8) == 29 )
      goto LABEL_10;
  }
  return -1;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08053D20) --------------------------------------------------------
int __usercall save_for_backup@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  _BYTE *v3; // eax
  signed int v4; // esi
  _DWORD *v5; // eax
  int v6; // ebx
  _DWORD *v7; // edx
  int v8; // ecx
  unsigned int v9; // edx
  int v10; // ecx
  unsigned int v11; // ebp
  unsigned int v12; // ebp
  int v14; // ecx
  _WORD *v15; // eax
  _BYTE *v17; // [esp+8h] [ebp-34h]
  int v18; // [esp+Ch] [ebp-30h]
  int v19; // [esp+10h] [ebp-2Ch]
  unsigned int v20; // [esp+14h] [ebp-28h]
  int v21; // [esp+1Ch] [ebp-20h]

  v3 = (_BYTE *)a1[3];
  v4 = a2 - (_DWORD)v3;
  v17 = v3;
  v5 = (_DWORD *)a1[12];
  if ( !v5 )
  {
    v10 = a1[9];
    v18 = a1[11];
    v11 = v18 - v10;
    if ( v4 >= 0 )
    {
LABEL_9:
      v12 = v10 + v11;
      goto LABEL_10;
    }
    v6 = v4;
LABEL_20:
    j_memmove(v11 + v10, v6 + v18, -v6);
    memcpy((_BYTE *)(a1[9] + v11 - v6), (_BYTE *)a1[3], a2 - a1[3]);
    v12 = a1[9] + v11;
    v4 = a2 - a1[3];
    v5 = (_DWORD *)a1[12];
    goto LABEL_10;
  }
  v6 = v4;
  v7 = (_DWORD *)a1[12];
  do
  {
    v8 = v7[2];
    v7 = (_DWORD *)*v7;
    if ( v6 > v8 )
      v6 = v8;
  }
  while ( v7 );
  v9 = v4 - v6;
  v18 = a1[11];
  v10 = a1[9];
  if ( v4 - v6 <= (unsigned int)(v18 - v10) )
  {
    v11 = v18 - v10 - v9;
    if ( v6 >= 0 )
    {
      if ( v9 )
      {
        memcpy((_BYTE *)(v18 - v9), &v17[v6], v9);
        v12 = a1[9] + v11;
        v4 = a2 - a1[3];
        v5 = (_DWORD *)a1[12];
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    goto LABEL_20;
  }
  v21 = a1[9];
  v20 = v9 + 100;
  v19 = malloc(v9 + 100);
  if ( !v19 )
    return -1;
  v12 = v19 + 100;
  if ( v6 < 0 )
  {
    v15 = mempcpy((_BYTE *)(v19 + 100), (_BYTE *)(v18 + v6), -v6);
    mempcpy(v15, v17, v4);
    v14 = a1[9];
  }
  else
  {
    memcpy((_BYTE *)(v19 + 100), &v17[v6], v4 - v6);
    v14 = v21;
  }
  free(v14);
  v4 = a2 - a1[3];
  a1[9] = v19;
  a1[11] = v20 + v19;
  v5 = (_DWORD *)a1[12];
LABEL_10:
  for ( a1[10] = v12; v5; v5 = (_DWORD *)*v5 )
    v5[2] -= v4;
  return 0;
}
// 80481D0: using guessed type int __cdecl j_memmove(_DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08053EF0) --------------------------------------------------------
int flush_cleanup()
{
  int result; // eax
  _DWORD *v1; // edx
  bool v2; // zf

  result = run_fp;
  if ( run_fp )
  {
    if ( (*(_DWORD *)run_fp & 0x8000) == 0 )
    {
      v1 = *(_DWORD **)(run_fp + 72);
      v2 = v1[1]-- == 1;
      if ( v2 )
      {
        v1[2] = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v2 = (*v1)-- == 1;
        if ( !v2 )
          result = _lll_unlock_wake_private(v1);
      }
    }
  }
  if ( !--dword_80EC4C0 )
  {
    dword_80EC4C4 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      return _lll_unlock_wake_private(&list_all_lock);
  }
  return result;
}
// 80EC4B4: using guessed type int run_fp;
// 80EC4BC: using guessed type int list_all_lock;
// 80EC4C0: using guessed type int dword_80EC4C0;
// 80EC4C4: using guessed type int dword_80EC4C4;

//----- (08053F60) --------------------------------------------------------
int __usercall IO_un_link_part_2@<eax>(int *a1@<eax>)
{
  unsigned int v2; // edx
  bool v4; // zf
  int v5; // ecx
  int v6; // edx
  int result; // eax
  unsigned int v9; // edi
  bool v11; // zf
  __int16 v12; // ax
  int *v13; // ebp
  int *v14; // edi
  int *v15; // edx
  _DWORD *v16; // ecx
  int v17; // edx
  int *v18; // edx
  int *v19; // edi

  v2 = __readgsdword(8u);
  if ( v2 != dword_80EC4C4 )
  {
    _ECX = 1;
    v4 = __readgsdword(0xCu) == 0;
    if ( !v4 )
      __asm { lock }
    __asm { cmpxchg ds:list_all_lock, ecx }
    if ( !v4 )
      _lll_lock_wait_private(0, &list_all_lock);
    dword_80EC4C4 = v2;
  }
  v5 = *a1;
  run_fp = (int)a1;
  v6 = dword_80EC4C0 + 1;
  result = v5 & 0x8000;
  ++dword_80EC4C0;
  if ( (v5 & 0x8000) != 0 )
  {
    v13 = IO_list_all;
    if ( !IO_list_all )
    {
      LOBYTE(v5) = v5 & 0x7F;
      *a1 = v5;
      goto LABEL_24;
    }
    goto LABEL_15;
  }
  _EDX = a1[18];
  v9 = __readgsdword(8u);
  if ( v9 != *(_DWORD *)(_EDX + 8) )
  {
    _ECX = 1;
    v11 = __readgsdword(0xCu) == 0;
    if ( !v11 )
      __asm { lock }
    __asm { cmpxchg [edx], ecx }
    if ( !v11 )
      _lll_lock_wait_private(result, (volatile __int32 *)_EDX);
    v5 = *a1;
    _EDX = a1[18];
    v12 = *a1;
    *(_DWORD *)(_EDX + 8) = v9;
    result = v12 & 0x8000;
  }
  v13 = IO_list_all;
  ++*(_DWORD *)(_EDX + 4);
  if ( v13 )
  {
LABEL_15:
    if ( a1 == v13 )
    {
      v18 = (int *)a1[13];
      ++IO_list_all_stamp;
      IO_list_all = v18;
    }
    else
    {
      v14 = (int *)v13[13];
      if ( v14 )
      {
        if ( a1 == v14 )
        {
          v19 = v13 + 13;
LABEL_38:
          v17 = a1[13];
          ++IO_list_all_stamp;
          *v19 = v17;
        }
        else
        {
          while ( 1 )
          {
            v15 = (int *)v14[13];
            if ( !v15 )
              break;
            if ( a1 == v15 )
            {
              v19 = v14 + 13;
              goto LABEL_38;
            }
            v14 = (int *)v14[13];
          }
        }
      }
    }
  }
  LOBYTE(v5) = v5 & 0x7F;
  *a1 = v5;
  if ( !result )
  {
    v16 = (_DWORD *)a1[18];
    result = v16[1] - 1;
    v4 = v16[1] == 1;
    v16[1] = result;
    v6 = dword_80EC4C0;
    if ( !v4 )
      goto LABEL_24;
    v16[2] = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v4 = (*v16)-- == 1;
    if ( !v4 )
      result = _lll_unlock_wake_private(v16);
  }
  v6 = dword_80EC4C0;
LABEL_24:
  run_fp = 0;
  dword_80EC4C0 = v6 - 1;
  if ( v6 == 1 )
  {
    dword_80EC4C4 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      return _lll_unlock_wake_private(&list_all_lock);
  }
  return result;
}
// 8053FC2: variable 'v2' is possibly undefined
// 80EB080: using guessed type int *IO_list_all;
// 80EC4B4: using guessed type int run_fp;
// 80EC4B8: using guessed type int IO_list_all_stamp;
// 80EC4BC: using guessed type int list_all_lock;
// 80EC4C0: using guessed type int dword_80EC4C0;
// 80EC4C4: using guessed type int dword_80EC4C4;

//----- (08054180) --------------------------------------------------------
int __cdecl IO_un_link(int *a1)
{
  int result; // eax

  result = (int)a1;
  if ( *(char *)a1 < 0 )
    return IO_un_link_part_2(a1);
  return result;
}

//----- (080541A0) --------------------------------------------------------
int __cdecl IO_link_in(int *a1)
{
  int result; // eax
  unsigned int v2; // edx
  bool v4; // zf
  int v5; // eax
  int v6; // edx
  unsigned int v8; // edx
  bool v10; // zf
  int v11; // eax
  int *v12; // edx

  result = *a1;
  if ( (*a1 & 0x80u) != 0 )
    return result;
  LOBYTE(result) = result | 0x80;
  *a1 = result;
  v2 = __readgsdword(8u);
  if ( v2 != dword_80EC4C4 )
  {
    _ECX = 1;
    v4 = __readgsdword(0xCu) == 0;
    if ( !v4 )
      __asm { lock }
    __asm { cmpxchg ds:list_all_lock, ecx }
    if ( !v4 )
      _lll_lock_wait_private(0, &list_all_lock);
    dword_80EC4C4 = v2;
  }
  v5 = *a1;
  run_fp = (int)a1;
  v6 = dword_80EC4C0 + 1;
  result = v5 & 0x8000;
  ++dword_80EC4C0;
  if ( result )
  {
    result = (int)IO_list_all;
    ++IO_list_all_stamp;
    IO_list_all = a1;
    a1[13] = result;
  }
  else
  {
    _EDI = a1[18];
    v8 = __readgsdword(8u);
    if ( v8 != *(_DWORD *)(_EDI + 8) )
    {
      _ECX = 1;
      v10 = __readgsdword(0xCu) == 0;
      if ( !v10 )
        __asm { lock }
      __asm { cmpxchg [edi], ecx }
      if ( !v10 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDI);
      _EDI = a1[18];
      v11 = *a1;
      *(_DWORD *)(_EDI + 8) = v8;
      result = v11 & 0x8000;
    }
    v12 = IO_list_all;
    ++*(_DWORD *)(_EDI + 4);
    ++IO_list_all_stamp;
    IO_list_all = a1;
    a1[13] = (int)v12;
    if ( !result )
    {
      result = *(_DWORD *)(_EDI + 4) - 1;
      v4 = *(_DWORD *)(_EDI + 4) == 1;
      *(_DWORD *)(_EDI + 4) = result;
      v6 = dword_80EC4C0;
      if ( !v4 )
        goto LABEL_17;
      *(_DWORD *)(_EDI + 8) = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v4 = (*(_DWORD *)_EDI)-- == 1;
      if ( !v4 )
        result = _lll_unlock_wake_private((_DWORD *)_EDI);
    }
    v6 = dword_80EC4C0;
  }
LABEL_17:
  run_fp = 0;
  dword_80EC4C0 = v6 - 1;
  if ( v6 == 1 )
  {
    dword_80EC4C4 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      return _lll_unlock_wake_private(&list_all_lock);
  }
  return result;
}
// 8054211: variable 'v2' is possibly undefined
// 8054269: variable 'v8' is possibly undefined
// 80EB080: using guessed type int *IO_list_all;
// 80EC4B4: using guessed type int run_fp;
// 80EC4B8: using guessed type int IO_list_all_stamp;
// 80EC4BC: using guessed type int list_all_lock;
// 80EC4C0: using guessed type int dword_80EC4C0;
// 80EC4C4: using guessed type int dword_80EC4C4;

//----- (08054380) --------------------------------------------------------
int __cdecl IO_least_marker(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // edx
  int v4; // ecx

  result = a2 - *(_DWORD *)(a1 + 12);
  v3 = *(_DWORD **)(a1 + 48);
  while ( v3 )
  {
    v4 = v3[2];
    v3 = (_DWORD *)*v3;
    if ( result > v4 )
      result = v4;
  }
  return result;
}

//----- (080543B0) --------------------------------------------------------
_DWORD *__cdecl IO_switch_to_main_get_area(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // edx
  int v3; // ecx
  int v4; // edx

  result = a1;
  v2 = a1[2];
  v3 = a1[11];
  *a1 &= ~0x100u;
  a1[2] = v3;
  a1[11] = v2;
  v4 = a1[9];
  a1[9] = a1[3];
  a1[3] = v4;
  a1[1] = v4;
  return result;
}

//----- (080543E0) --------------------------------------------------------
_DWORD *__cdecl IO_switch_to_backup_area(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // ebx
  int v5; // ecx

  result = a1;
  v2 = a1[2];
  v3 = a1[11];
  v4 = a1[9];
  *a1 |= 0x100u;
  a1[11] = v2;
  v5 = a1[3];
  a1[2] = v3;
  a1[3] = v4;
  a1[9] = v5;
  a1[1] = v3;
  return result;
}

//----- (08054410) --------------------------------------------------------
int __cdecl IO_switch_to_get_mode(int *a1)
{
  unsigned int v1; // eax
  int v2; // esi
  int result; // eax
  int v4; // edx
  bool v5; // cf

  v1 = a1[5];
  if ( v1 <= a1[4] )
  {
LABEL_6:
    v4 = *a1;
    if ( (*a1 & 0x100) != 0 )
    {
      a1[3] = a1[10];
    }
    else
    {
      v5 = a1[2] < v1;
      a1[3] = a1[7];
      if ( v5 )
        a1[2] = v1;
    }
    BYTE1(v4) &= ~8u;
    a1[1] = v1;
    a1[6] = v1;
    a1[4] = v1;
    *a1 = v4;
    return 0;
  }
  v2 = a1[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check();
  result = (*(int (__cdecl **)(int *, int))(v2 + 12))(a1, -1);
  if ( result != -1 )
  {
    v1 = a1[5];
    goto LABEL_6;
  }
  return result;
}
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (080544A0) --------------------------------------------------------
int __cdecl IO_free_backup_area(int *a1)
{
  int v1; // eax
  int v2; // edx
  int v3; // eax
  int v4; // eax
  int result; // eax

  v1 = *a1;
  if ( (*a1 & 0x100) != 0 )
  {
    BYTE1(v1) &= ~1u;
    v2 = a1[9];
    *a1 = v1;
    v3 = a1[11];
    a1[1] = v2;
    a1[2] = v3;
    v4 = a1[3];
    a1[3] = v2;
  }
  else
  {
    v4 = a1[9];
  }
  result = free(v4);
  a1[9] = 0;
  a1[11] = 0;
  a1[10] = 0;
  return result;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08054500) --------------------------------------------------------
int __cdecl _overflow(int a1, int a2)
{
  int v2; // esi

  if ( !*(_DWORD *)(a1 + 104) )
    *(_DWORD *)(a1 + 104) = -1;
  v2 = *(_DWORD *)(a1 + 148);
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int, int))(v2 + 12))(a1, a2);
}
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08054560) --------------------------------------------------------
int __cdecl _underflow(int *a1)
{
  int v1; // eax
  unsigned __int8 *v2; // eax
  unsigned int v3; // edx
  int v4; // eax
  int v5; // esi
  unsigned int v7; // ecx
  int v8; // edx

  v1 = a1[26];
  if ( v1 )
  {
    if ( v1 != -1 )
      return -1;
  }
  else
  {
    a1[26] = -1;
  }
  if ( (*a1 & 0x800) != 0 && IO_switch_to_get_mode(a1) == -1 )
    return -1;
  v2 = (unsigned __int8 *)a1[1];
  v3 = a1[2];
  if ( (unsigned int)v2 < v3 )
    return *v2;
  v4 = *a1;
  if ( (*a1 & 0x100) != 0 )
  {
    BYTE1(v4) &= ~1u;
    v7 = a1[11];
    a1[11] = v3;
    *a1 = v4;
    v2 = (unsigned __int8 *)a1[9];
    v8 = a1[3];
    a1[2] = v7;
    a1[3] = (int)v2;
    a1[1] = (int)v2;
    a1[9] = v8;
    if ( v7 > (unsigned int)v2 )
      return *v2;
  }
  if ( !a1[12] )
  {
    if ( a1[9] )
      IO_free_backup_area(a1);
    goto LABEL_8;
  }
  if ( save_for_backup(a1, a1[2]) )
    return -1;
LABEL_8:
  v5 = a1[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v5
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int *))(v5 + 16))(a1);
}
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08054670) --------------------------------------------------------
int __cdecl _uflow(int *a1)
{
  int v1; // eax
  unsigned __int8 *v2; // eax
  unsigned int v3; // edx
  int v4; // eax
  int v5; // esi
  unsigned int v7; // ecx
  int v8; // edx
  int v9; // edx

  v1 = a1[26];
  if ( v1 )
  {
    if ( v1 != -1 )
      return -1;
  }
  else
  {
    a1[26] = -1;
  }
  if ( (*a1 & 0x800) != 0 && IO_switch_to_get_mode(a1) == -1 )
    return -1;
  v2 = (unsigned __int8 *)a1[1];
  v3 = a1[2];
  if ( (unsigned int)v2 < v3 )
    goto LABEL_17;
  v4 = *a1;
  if ( (*a1 & 0x100) == 0 )
  {
    if ( a1[12] )
      goto LABEL_7;
LABEL_15:
    if ( a1[9] )
      IO_free_backup_area(a1);
    goto LABEL_8;
  }
  BYTE1(v4) &= ~1u;
  v7 = a1[11];
  a1[11] = v3;
  *a1 = v4;
  v2 = (unsigned __int8 *)a1[9];
  v8 = a1[3];
  a1[2] = v7;
  a1[3] = (int)v2;
  a1[9] = v8;
  if ( v7 > (unsigned int)v2 )
  {
LABEL_17:
    a1[1] = (int)(v2 + 1);
    return *v2;
  }
  v9 = a1[12];
  a1[1] = (int)v2;
  if ( !v9 )
    goto LABEL_15;
LABEL_7:
  if ( save_for_backup(a1, a1[2]) )
    return -1;
LABEL_8:
  v5 = a1[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v5
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int *))(v5 + 20))(a1);
}
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08054780) --------------------------------------------------------
unsigned int __cdecl IO_setb(unsigned int *a1, unsigned int a2, unsigned int a3, int a4)
{
  unsigned int v4; // eax
  unsigned int v5; // edx
  unsigned int result; // eax
  int v7; // edx

  v4 = *a1;
  if ( a1[7] && (v4 & 1) == 0 )
  {
    free(a1[7]);
    v4 = *a1;
  }
  a1[7] = a2;
  a1[8] = a3;
  v5 = v4;
  result = v4 & 0xFFFFFFFE;
  v7 = v5 | 1;
  if ( !a4 )
    result = v7;
  *a1 = result;
  return result;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (080547D0) --------------------------------------------------------
void __usercall IO_doallocbuf(long double a1@<st0>, int *a2)
{
  int v2; // eax
  int v3; // esi
  _DWORD *v4; // edi
  char *v5; // esi

  if ( a2[7] )
    return;
  v2 = *a2;
  if ( (*a2 & 2) != 0 && a2[26] <= 0 )
  {
    v4 = a2 + 18;
    v5 = (char *)a2 + 71;
LABEL_10:
    a2[7] = (int)v5;
    a2[8] = (int)v4;
    *a2 = v2 | 1;
    return;
  }
  v3 = a2[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v3
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  if ( (*(int (__cdecl **)(int *))(v3 + 52))(a2) == -1 )
  {
    v4 = a2 + 18;
    v5 = (char *)a2 + 71;
    v2 = *a2;
    if ( a2[7] )
    {
      if ( (v2 & 1) == 0 )
      {
        free(a1, a2[7]);
        v2 = *a2;
      }
    }
    goto LABEL_10;
  }
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08054870) --------------------------------------------------------
int IO_default_underflow()
{
  return -1;
}

//----- (08054880) --------------------------------------------------------
int __usercall IO_default_uflow@<eax>(long double a1@<st0>, int a2)
{
  int v2; // esi
  int result; // eax
  unsigned __int8 *v4; // eax

  v2 = *(_DWORD *)(a2 + 148);
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  result = (*(int (__cdecl **)(int))(v2 + 16))(a2);
  if ( result != -1 )
  {
    v4 = *(unsigned __int8 **)(a2 + 4);
    *(_DWORD *)(a2 + 4) = v4 + 1;
    return *v4;
  }
  return result;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (080548E0) --------------------------------------------------------
unsigned int __usercall IO_default_xsputn@<eax>(long double a1@<st0>, _DWORD *a2, unsigned __int8 *a3, unsigned int a4)
{
  unsigned int i; // esi
  _BYTE *v6; // ecx
  unsigned int v7; // edi
  unsigned int v8; // edi
  int j; // eax
  int v10; // eax
  _BYTE *v12; // [esp-Ch] [ebp-38h]
  int v13; // [esp+Ch] [ebp-20h]

  if ( !a4 )
    return 0;
  for ( i = a4; ; --i )
  {
    v6 = (_BYTE *)a2[5];
    v7 = a2[6];
    if ( (unsigned int)v6 < v7 )
    {
      v8 = v7 - (_DWORD)v6;
      if ( i <= v8 )
        v8 = i;
      if ( v8 > 0x14 )
      {
        v12 = a3;
        a3 += v8;
        a2[5] = mempcpy(v6, v12, v8);
      }
      else if ( v8 )
      {
        for ( j = 0; j != v8; ++j )
          v6[j] = a3[j];
        a3 += v8;
        a2[5] = &v6[v8];
      }
      i -= v8;
    }
    if ( !i )
      break;
    v10 = a2[37];
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v10
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
    {
      v13 = a2[37];
      IO_vtable_check(a1);
      v10 = v13;
    }
    if ( (*(int (__cdecl **)(_DWORD *, _DWORD))(v10 + 12))(a2, *a3) == -1 )
      break;
    ++a3;
  }
  return a4 - i;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (080549D0) --------------------------------------------------------
int __cdecl IO_sgetn(int a1, int a2, int a3)
{
  int v3; // ebx

  v3 = *(_DWORD *)(a1 + 148);
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v3
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int, int, int))(v3 + 32))(a1, a2, a3);
}
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08054A30) --------------------------------------------------------
unsigned int __cdecl IO_default_xsgetn(int *a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v4; // ebp
  _BYTE *v5; // ecx
  unsigned int v6; // ebx
  unsigned int v7; // ebx
  int i; // eax
  _WORD *v10; // eax

  v4 = a3;
  do
  {
    v5 = (_BYTE *)a1[1];
    v6 = a1[2];
    if ( (unsigned int)v5 < v6 )
    {
      v7 = v6 - (_DWORD)v5;
      if ( v4 <= v7 )
        v7 = v4;
      if ( v7 > 0x14 )
      {
        v10 = mempcpy(a2, v5, v7);
        a1[1] += v7;
        a2 = v10;
      }
      else if ( v7 )
      {
        for ( i = 0; i != v7; ++i )
          a2[i] = v5[i];
        a2 += v7;
        a1[1] = (int)&v5[v7];
      }
      v4 -= v7;
    }
  }
  while ( v4 && _underflow(a1) != -1 );
  return a3 - v4;
}

//----- (08054AC0) --------------------------------------------------------
unsigned int *__usercall IO_default_setbuf@<eax>(long double a1@<st0>, unsigned int *a2, char *a3, int a4)
{
  char *v4; // edi
  unsigned int v5; // ebp
  unsigned int v6; // edx
  unsigned int v7; // eax
  int v8; // ecx
  unsigned int v9; // eax
  char *v10; // esi
  unsigned int *result; // eax

  v4 = a3;
  v5 = a2[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= v5 - (unsigned int)&_start___libc_IO_vtables )
    IO_vtable_check(a1);
  if ( (*(int (__cdecl **)(unsigned int *))(v5 + 48))(a2) != -1 )
  {
    v6 = *a2;
    v7 = *a2;
    if ( a3 && a4 )
    {
      v8 = a2[7];
      v9 = v7 & 0xFFFFFFFD;
      v10 = &a3[a4];
      *a2 = v9;
      if ( !v8 || (v6 & 1) != 0 )
        goto LABEL_8;
    }
    else
    {
      v8 = a2[7];
      v9 = v7 | 2;
      v10 = (char *)(a2 + 18);
      *a2 = v9;
      v4 = (char *)a2 + 71;
      if ( !v8 || (v6 & 1) != 0 )
        goto LABEL_8;
    }
    free(a1, v8);
    v9 = *a2;
LABEL_8:
    a2[7] = (unsigned int)v4;
    a2[8] = (unsigned int)v10;
    *a2 = v9 | 1;
    a2[6] = 0;
    result = a2;
    a2[5] = 0;
    a2[4] = 0;
    a2[2] = 0;
    a2[1] = 0;
    a2[3] = 0;
    return result;
  }
  return 0;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08054BB0) --------------------------------------------------------
int __usercall IO_default_seekpos@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5)
{
  int v5; // ebx

  v5 = *(_DWORD *)(a2 + 148);
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v5
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  return (*(int (__cdecl **)(int, int, int, _DWORD, int))(v5 + 36))(a2, a3, a4, 0, a5);
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08054C10) --------------------------------------------------------
int __usercall IO_default_doallocate@<eax>(long double a1@<st0>, unsigned int *a2)
{
  int v2; // eax
  int v3; // ecx
  int v4; // esi
  unsigned int v5; // edx
  int v7; // [esp+18h] [ebp-10h]

  v2 = malloc(a1, 0x2000u);
  if ( !v2 )
    return -1;
  v3 = a2[7];
  v4 = v2 + 0x2000;
  v5 = *a2;
  if ( v3 )
  {
    if ( (v5 & 1) == 0 )
    {
      v7 = v2;
      free(a1, v3);
      v5 = *a2;
      v2 = v7;
    }
  }
  a2[7] = v2;
  a2[8] = v4;
  *a2 = v5 & 0xFFFFFFFE;
  return 1;
}

//----- (08054C80) --------------------------------------------------------
int __cdecl IO_init(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // edx

  result = a1;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)a1 = a2 | 0xFBAD0000;
  *(_DWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 68) = 0;
  v3 = *(_DWORD **)(a1 + 72);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  if ( v3 )
  {
    *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
  }
  *(_DWORD *)(a1 + 104) = -1;
  *(_DWORD *)(a1 + 88) = -1;
  *(_DWORD *)(a1 + 92) = 0;
  return result;
}

//----- (08054D40) --------------------------------------------------------
_DWORD *__cdecl IO_old_init(int a1, int a2)
{
  _DWORD *result; // eax

  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)a1 = a2 | 0xFBAD0000;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 68) = 0;
  result = *(_DWORD **)(a1 + 72);
  if ( result )
  {
    *result = 0;
    result[1] = 0;
    result[2] = 0;
  }
  return result;
}

//----- (08054DE0) --------------------------------------------------------
int __cdecl IO_no_init(int a1, int a2, int a3, _DWORD *a4, int a5)
{
  int result; // eax
  _DWORD *v6; // ecx

  result = a1;
  *(_DWORD *)a1 = a2 | 0xFBAD0000;
  *(_DWORD *)(a1 + 60) = 0;
  *(_WORD *)(a1 + 68) = 0;
  v6 = *(_DWORD **)(a1 + 72);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  if ( v6 )
  {
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
  }
  *(_DWORD *)(a1 + 104) = a3;
  if ( a3 < 0 )
  {
    *(_DWORD *)(a1 + 88) = -1;
  }
  else
  {
    *(_DWORD *)(a1 + 88) = a4;
    a4[6] = 0;
    a4[7] = 0;
    a4[2] = 0;
    *a4 = 0;
    a4[1] = 0;
    a4[3] = 0;
    a4[4] = 0;
    a4[5] = 0;
    a4[8] = 0;
    a4[9] = 0;
    a4[10] = 0;
    a4[44] = a5;
  }
  *(_DWORD *)(a1 + 92) = 0;
  return result;
}

//----- (08054F00) --------------------------------------------------------
int IO_default_sync()
{
  return 0;
}

//----- (08054F10) --------------------------------------------------------
_DWORD *__usercall IO_default_finish@<eax>(long double a1@<st0>, int *a2)
{
  _DWORD *i; // edx
  _DWORD *result; // eax

  if ( a2[7] && (*(_BYTE *)a2 & 1) == 0 )
  {
    free(a1, a2[7]);
    a2[8] = 0;
    a2[7] = 0;
  }
  for ( i = (_DWORD *)a2[12]; i; i = (_DWORD *)*i )
    i[1] = 0;
  result = (_DWORD *)a2[9];
  if ( result )
  {
    result = free(a1, a2[9]);
    a2[9] = 0;
  }
  if ( *(char *)a2 < 0 )
    return (_DWORD *)IO_un_link_part_2(a2);
  return result;
}

//----- (08054FA0) --------------------------------------------------------
__int64 IO_default_seekoff()
{
  return -1LL;
}

//----- (08054FB0) --------------------------------------------------------
int __cdecl IO_sputbackc(_DWORD *a1, int a2)
{
  int v2; // eax
  unsigned int v3; // edx
  int v4; // esi
  int result; // eax

  v2 = a2;
  v3 = a1[1];
  if ( v3 > a1[3] && *(_BYTE *)(v3 - 1) == (_BYTE)a2 )
  {
    result = (unsigned __int8)a2;
    a1[1] = v3 - 1;
LABEL_6:
    *a1 &= ~0x10u;
    return result;
  }
  v4 = a1[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v4
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
  {
    IO_vtable_check();
    v2 = a2;
  }
  result = (*(int (__cdecl **)(_DWORD *, int))(v4 + 24))(a1, v2);
  if ( result != -1 )
    goto LABEL_6;
  return result;
}
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08055020) --------------------------------------------------------
int __usercall IO_sungetc@<eax>(long double a1@<st0>, _DWORD *a2)
{
  unsigned int v2; // eax
  int result; // eax
  int v4; // esi

  v2 = a2[1];
  if ( v2 > a2[3] )
  {
    a2[1] = v2 - 1;
    result = *(unsigned __int8 *)(v2 - 1);
LABEL_3:
    *a2 &= ~0x10u;
    return result;
  }
  v4 = a2[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v4
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  result = (*(int (__cdecl **)(_DWORD *, int))(v4 + 24))(a2, -1);
  if ( result != -1 )
    goto LABEL_3;
  return result;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08055090) --------------------------------------------------------
int __cdecl IO_adjust_column(int a1, unsigned int a2, int a3)
{
  int v3; // eax
  int v4; // edx

  v3 = a2 + a3;
  if ( a2 >= a2 + a3 )
    return a3 + a1;
  v4 = v3 - 1;
  if ( *(_BYTE *)(v3 - 1) != 10 )
  {
    while ( a2 != v4 )
    {
      if ( *(_BYTE *)--v4 == 10 )
        return v3 - v4 - 1;
    }
    return a3 + a1;
  }
  return v3 - v4 - 1;
}

//----- (080550D0) --------------------------------------------------------
int __usercall IO_flush_all_lockp@<eax>(long double a1@<st0>, int a2)
{
  unsigned int v2; // edx
  bool v4; // zf
  int *v5; // ebx
  int v6; // ebp
  int v7; // eax
  int v8; // edi
  bool v11; // zf
  int v12; // edx
  _DWORD *v13; // edx
  unsigned int v15; // [esp+4h] [ebp-38h]
  int v16; // [esp+Ch] [ebp-30h]
  int (*v17)(); // [esp+10h] [ebp-2Ch]
  int v18; // [esp+14h] [ebp-28h]

  if ( a2 )
  {
    v17 = flush_cleanup;
    v18 = 0;
    v2 = __readgsdword(8u);
    if ( v2 != dword_80EC4C4 )
    {
      _ECX = 1;
      v4 = __readgsdword(0xCu) == 0;
      if ( !v4 )
        __asm { lock }
      __asm { cmpxchg ds:list_all_lock, ecx }
      if ( !v4 )
        _lll_lock_wait_private(0, &list_all_lock);
      dword_80EC4C4 = v2;
    }
    v5 = IO_list_all;
    v6 = IO_list_all_stamp;
    v7 = ++dword_80EC4C0;
    if ( !IO_list_all )
    {
      v8 = 0;
      goto LABEL_36;
    }
  }
  else
  {
    v5 = IO_list_all;
    v6 = IO_list_all_stamp;
    if ( !IO_list_all )
      return 0;
  }
  v8 = 0;
  v15 = __readgsdword(8u);
  do
  {
    while ( 1 )
    {
      run_fp = (int)v5;
      if ( a2 && (*v5 & 0x8000) == 0 )
      {
        _EDX = v5[18];
        if ( v15 != *(_DWORD *)(_EDX + 8) )
        {
          _ECX = 1;
          v11 = __readgsdword(0xCu) == 0;
          if ( !v11 )
            __asm { lock }
          __asm { cmpxchg [edx], ecx }
          if ( !v11 )
            _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
          _EDX = v5[18];
          *(_DWORD *)(_EDX + 8) = v15;
        }
        ++*(_DWORD *)(_EDX + 4);
      }
      if ( v5[26] <= 0 )
      {
        if ( v5[5] <= (unsigned int)v5[4] )
          goto LABEL_26;
      }
      else if ( *(_DWORD *)(v5[22] + 16) <= *(_DWORD *)(v5[22] + 12) )
      {
        goto LABEL_26;
      }
      v12 = v5[37];
      if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v12
                                                                                            - (_DWORD)&_start___libc_IO_vtables) )
      {
        v16 = v5[37];
        IO_vtable_check(a1);
        v12 = v16;
      }
      if ( (*(int (__cdecl **)(int *, int))(v12 + 12))(v5, -1) == -1 )
        v8 = -1;
LABEL_26:
      if ( a2 )
      {
        if ( (*v5 & 0x8000) == 0 )
        {
          v13 = (_DWORD *)v5[18];
          v4 = v13[1]-- == 1;
          if ( v4 )
          {
            v13[2] = 0;
            if ( __readgsdword(0xCu) )
              __asm { lock }
            v4 = (*v13)-- == 1;
            if ( !v4 )
              _lll_unlock_wake_private(v13);
          }
        }
      }
      run_fp = 0;
      if ( v6 == IO_list_all_stamp )
        break;
      v5 = IO_list_all;
      v6 = IO_list_all_stamp;
      if ( !IO_list_all )
        goto LABEL_35;
    }
    v5 = (int *)v5[13];
    v6 = IO_list_all_stamp;
  }
  while ( v5 );
LABEL_35:
  v7 = dword_80EC4C0;
  if ( a2 )
  {
LABEL_36:
    dword_80EC4C0 = v7 - 1;
    if ( v7 == 1 )
    {
      dword_80EC4C4 = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --list_all_lock )
        _lll_unlock_wake_private(&list_all_lock);
    }
  }
  return v8;
}
// 805529F: conditional instruction was optimized away because %var_34.4==0
// 8055148: variable 'v2' is possibly undefined
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 80EB080: using guessed type int *IO_list_all;
// 80EC4B4: using guessed type int run_fp;
// 80EC4B8: using guessed type int IO_list_all_stamp;
// 80EC4BC: using guessed type int list_all_lock;
// 80EC4C0: using guessed type int dword_80EC4C0;
// 80EC4C4: using guessed type int dword_80EC4C4;

//----- (08055370) --------------------------------------------------------
int __usercall IO_cleanup@<eax>(long double a1@<st0>)
{
  unsigned int v1; // edi
  int v2; // eax
  int *v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // esi
  _DWORD *v10; // edx
  bool v11; // zf
  int i; // [esp+18h] [ebp-20h]

  v1 = __readgsdword(8u);
  v2 = IO_flush_all_lockp(a1, 0);
  v3 = IO_list_all;
  for ( i = v2; v3; v3 = (int *)v3[13] )
  {
    if ( (*v3 & 2) == 0 && v3[26] )
    {
      _ESI = 1;
      _ECX = v3[18];
      if ( _ECX )
      {
        if ( v1 == *(_DWORD *)(_ECX + 8) )
        {
          ++*(_DWORD *)(_ECX + 4);
        }
        else
        {
          if ( __readgsdword(0xCu) )
            __asm { lock }
          __asm { cmpxchg [ecx], esi }
          v4 = v3[18];
          *(_DWORD *)(v4 + 8) = v1;
          *(_DWORD *)(v4 + 4) = 1;
        }
      }
      if ( !dealloc_buffers && (*v3 & 1) == 0 )
      {
        *v3 |= 1u;
        v5 = freeres_list;
        freeres_list = (int)v3;
        v3[23] = v5;
        v3[24] = v3[7];
      }
      v6 = v3[37];
      if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v6
                                                                                            - (_DWORD)&_start___libc_IO_vtables) )
        IO_vtable_check(a1);
      (*(void (__cdecl **)(int *, _DWORD, _DWORD))(v6 + 44))(v3, 0, 0);
      if ( v3[26] > 0 )
        IO_wsetb((int)v3, 0, 0, 0);
      v10 = (_DWORD *)v3[18];
      if ( v10 )
      {
        v11 = v10[1]-- == 1;
        if ( v11 )
        {
          v10[2] = 0;
          if ( __readgsdword(0xCu) )
            __asm { lock }
          v11 = (*v10)-- == 1;
          if ( !v11 )
            _lll_unlock_wake_private(v10);
        }
      }
    }
    v3[26] = -1;
  }
  return i;
}
// 805541C: conditional instruction was optimized away because ebp.4==0
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 80EB080: using guessed type int *IO_list_all;
// 80EC4AC: using guessed type int freeres_list;
// 80EC4B0: using guessed type char dealloc_buffers;

//----- (080554E0) --------------------------------------------------------
int IO_flush_all()
{
  return IO_flush_all_lockp(1);
}
// 80550D0: using guessed type _DWORD __cdecl IO_flush_all_lockp(_DWORD);

//----- (080554F0) --------------------------------------------------------
int __usercall flushlbf@<eax>(long double a1@<st0>)
{
  unsigned int v1; // edx
  bool v3; // zf
  int *v4; // ebx
  int v5; // ecx
  int v6; // eax
  int v7; // esi
  unsigned int v8; // ebp
  bool v11; // zf
  int v12; // eax
  _DWORD *v13; // edx
  int v14; // edx
  int v15; // eax
  int v16; // eax
  int v18; // [esp+Ch] [ebp-30h]

  v1 = __readgsdword(8u);
  if ( v1 != dword_80EC4C4 )
  {
    _ECX = 1;
    v3 = __readgsdword(0xCu) == 0;
    if ( !v3 )
      __asm { lock }
    __asm { cmpxchg ds:list_all_lock, ecx }
    if ( !v3 )
      _lll_lock_wait_private(0, &list_all_lock);
    dword_80EC4C4 = v1;
  }
  v4 = IO_list_all;
  v5 = IO_list_all_stamp;
  v6 = ++dword_80EC4C0;
  v7 = IO_list_all_stamp;
  if ( IO_list_all )
  {
    v8 = __readgsdword(8u);
    while ( 1 )
    {
      v14 = *v4;
      run_fp = (int)v4;
      v15 = v14 & 0x8000;
      if ( (v14 & 0x8000) != 0 )
        break;
      _EDX = v4[18];
      if ( v8 != *(_DWORD *)(_EDX + 8) )
      {
        _ECX = 1;
        v11 = __readgsdword(0xCu) == 0;
        if ( !v11 )
          __asm { lock }
        __asm { cmpxchg [edx], ecx }
        if ( !v11 )
          _lll_lock_wait_private(v15, (volatile __int32 *)_EDX);
        _EDX = v4[18];
        *(_DWORD *)(_EDX + 8) = v8;
      }
      v12 = *v4;
      ++*(_DWORD *)(_EDX + 4);
      if ( (v12 & 0x208) == 512 )
        goto LABEL_27;
LABEL_16:
      if ( (*v4 & 0x8000) != 0 )
        goto LABEL_22;
      v13 = (_DWORD *)v4[18];
      v5 = IO_list_all_stamp;
      v3 = v13[1]-- == 1;
      if ( v3 )
      {
        v13[2] = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v3 = (*v13)-- == 1;
        if ( !v3 )
          _lll_unlock_wake_private(v13);
LABEL_22:
        v5 = IO_list_all_stamp;
      }
LABEL_23:
      run_fp = 0;
      if ( v5 == v7 )
      {
        v4 = (int *)v4[13];
        v7 = v5;
        if ( !v4 )
        {
LABEL_31:
          v6 = dword_80EC4C0;
          goto LABEL_32;
        }
      }
      else
      {
        v4 = IO_list_all;
        v7 = v5;
        if ( !IO_list_all )
          goto LABEL_31;
      }
    }
    if ( (v14 & 0x208) != 512 )
      goto LABEL_23;
LABEL_27:
    v16 = v4[37];
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v16
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
    {
      v18 = v4[37];
      IO_vtable_check(a1);
      v16 = v18;
    }
    (*(void (__cdecl **)(int *, int))(v16 + 12))(v4, -1);
    goto LABEL_16;
  }
LABEL_32:
  dword_80EC4C0 = v6 - 1;
  if ( v6 == 1 )
  {
    dword_80EC4C4 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      _lll_unlock_wake_private(&list_all_lock);
  }
  return 0;
}
// 8055550: variable 'v1' is possibly undefined
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 80EB080: using guessed type int *IO_list_all;
// 80EC4B4: using guessed type int run_fp;
// 80EC4B8: using guessed type int IO_list_all_stamp;
// 80EC4BC: using guessed type int list_all_lock;
// 80EC4C0: using guessed type int dword_80EC4C0;
// 80EC4C4: using guessed type int dword_80EC4C4;

//----- (08055720) --------------------------------------------------------
int __cdecl IO_init_marker(int *a1, int *a2)
{
  int v2; // eax
  bool v3; // zf
  int v4; // eax
  int result; // eax

  v2 = *a2;
  a1[1] = (int)a2;
  if ( (v2 & 0x800) != 0 )
  {
    IO_switch_to_get_mode(a2);
    v2 = *a2;
  }
  v3 = (v2 & 0x100) == 0;
  v4 = a2[1];
  if ( v3 )
    a1[2] = v4 - a2[3];
  else
    a1[2] = v4 - a2[2];
  result = a2[12];
  *a1 = result;
  a2[12] = (int)a1;
  return result;
}

//----- (08055780) --------------------------------------------------------
_DWORD *__cdecl IO_remove_marker(_DWORD *a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // edx

  result = (_DWORD *)a1[1];
  v2 = (_DWORD *)result[12];
  if ( v2 )
  {
    if ( a1 == v2 )
    {
      v2 = result + 12;
LABEL_8:
      result = (_DWORD *)*a1;
      *v2 = *a1;
    }
    else
    {
      while ( 1 )
      {
        result = (_DWORD *)*v2;
        if ( !*v2 )
          break;
        if ( a1 == result )
          goto LABEL_8;
        v2 = (_DWORD *)*v2;
      }
    }
  }
  return result;
}

//----- (080557B0) --------------------------------------------------------
int __cdecl IO_marker_difference(int a1, int a2)
{
  return *(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8);
}

//----- (080557C0) --------------------------------------------------------
int __cdecl IO_marker_delta(int a1)
{
  _DWORD *v1; // eax
  int v2; // edx
  int v3; // edx

  v1 = *(_DWORD **)(a1 + 4);
  if ( !v1 )
    return -1;
  v2 = v1[1];
  if ( (*v1 & 0x100) != 0 )
    v3 = v2 - v1[2];
  else
    v3 = v2 - v1[3];
  return *(_DWORD *)(a1 + 8) - v3;
}

//----- (080557F0) --------------------------------------------------------
int __cdecl IO_seekmark(int *a1, int a2)
{
  int *v2; // eax
  int v3; // ecx
  int v4; // edx
  int v5; // ebx
  int v6; // edx
  int v7; // ebx
  int v8; // edx
  int v10; // ebx
  int v11; // esi
  int v12; // ebx

  v2 = *(int **)(a2 + 4);
  if ( v2 != a1 )
    return -1;
  v3 = *(_DWORD *)(a2 + 8);
  v4 = *v2;
  if ( v3 < 0 )
  {
    if ( (v4 & 0x100) != 0 )
    {
      v8 = v2[2];
    }
    else
    {
      v10 = v2[2];
      BYTE1(v4) |= 1u;
      v11 = v2[9];
      *v2 = v4;
      v8 = v2[11];
      v2[11] = v10;
      v12 = v2[3];
      v2[2] = v8;
      v2[3] = v11;
      v2[9] = v12;
    }
  }
  else if ( (v4 & 0x100) != 0 )
  {
    BYTE1(v4) &= ~1u;
    v5 = v2[11];
    *v2 = v4;
    v6 = v2[2];
    v2[2] = v5;
    v7 = v2[3];
    v2[11] = v6;
    v8 = v2[9];
    v2[9] = v7;
    v2[3] = v8;
  }
  else
  {
    v8 = v2[3];
  }
  v2[1] = v3 + v8;
  return 0;
}

//----- (08055880) --------------------------------------------------------
int __cdecl IO_unsave_markers(int *a1)
{
  int result; // eax

  result = (int)a1;
  if ( a1[12] )
    a1[12] = 0;
  if ( a1[9] )
    return IO_free_backup_area(a1);
  return result;
}

//----- (080558B0) --------------------------------------------------------
int __usercall IO_default_pbackfail@<eax>(long double a1@<st0>, int *a2, int a3)
{
  _BYTE *v3; // edi
  _BYTE *v4; // ebp
  int v6; // edx
  int v7; // edi
  int v8; // eax
  unsigned int v9; // ecx
  _BYTE *v10; // ecx
  int v11; // eax
  int v12; // edx
  unsigned int v13; // [esp+18h] [ebp-24h]
  int v14; // [esp+18h] [ebp-24h]
  int v15; // [esp+1Ch] [ebp-20h]

  v3 = (_BYTE *)a2[1];
  v4 = (_BYTE *)a2[3];
  if ( v3 <= v4 )
  {
    v6 = *a2;
    if ( (*a2 & 0x100) != 0 )
    {
      v13 = a2[2] - (_DWORD)v4;
      v7 = 2 * v13;
      v8 = malloc(a1, 2 * v13);
      if ( v8 )
      {
        v9 = v13;
        v15 = 2 * v13;
        v14 = v8;
        v3 = (_BYTE *)(v8 + v7 - v9);
        memcpy(v3, v4, v9);
        free(a1, (int)v4);
        a2[10] = (int)v3;
        a2[3] = v14;
        a2[2] = v14 + v15;
        goto LABEL_3;
      }
      return -1;
    }
    v11 = a2[9];
    if ( v11 )
    {
      v10 = (_BYTE *)a2[1];
      v3 = (_BYTE *)a2[11];
      goto LABEL_14;
    }
    goto LABEL_16;
  }
  if ( (*a2 & 0x100) != 0 )
  {
LABEL_3:
    a2[1] = (int)(v3 - 1);
    *(v3 - 1) = a3;
    return (unsigned __int8)a3;
  }
  if ( (unsigned __int8)*(v3 - 1) == a3 )
  {
    a2[1] = (int)(v3 - 1);
    return (unsigned __int8)a3;
  }
  if ( !a2[9] )
  {
LABEL_16:
    v11 = malloc(a1, 0x80u);
    if ( v11 )
    {
      v10 = v3;
      v6 = *a2;
      a2[10] = v11 + 128;
      v3 = (_BYTE *)(v11 + 128);
      goto LABEL_14;
    }
    return -1;
  }
  if ( !save_for_backup(a2, a2[1]) )
  {
    v10 = (_BYTE *)a2[1];
    v6 = *a2;
    v3 = (_BYTE *)a2[11];
    v11 = a2[9];
LABEL_14:
    BYTE1(v6) |= 1u;
    a2[3] = v11;
    a2[9] = (int)v10;
    *a2 = v6;
    v12 = a2[2];
    a2[2] = (int)v3;
    a2[11] = v12;
    goto LABEL_3;
  }
  return -1;
}

//----- (080559F0) --------------------------------------------------------
__int64 IO_default_seek()
{
  return -1LL;
}

//----- (08055A00) --------------------------------------------------------
int IO_default_stat()
{
  return -1;
}

//----- (08055A10) --------------------------------------------------------
int IO_default_read()
{
  return -1;
}

//----- (08055A20) --------------------------------------------------------
int IO_default_write()
{
  return 0;
}

//----- (08055A30) --------------------------------------------------------
int IO_default_showmanyc()
{
  return -1;
}

//----- (08055A50) --------------------------------------------------------
int *IO_iter_begin()
{
  return IO_list_all;
}
// 80EB080: using guessed type int *IO_list_all;

//----- (08055A60) --------------------------------------------------------
int IO_iter_end()
{
  return 0;
}

//----- (08055A70) --------------------------------------------------------
int __cdecl IO_iter_next(int a1)
{
  return *(_DWORD *)(a1 + 52);
}

//----- (08055A80) --------------------------------------------------------
int __cdecl IO_iter_file(int a1)
{
  return a1;
}

//----- (08055A90) --------------------------------------------------------
void IO_list_lock()
{
  unsigned int v0; // edx
  bool v2; // zf

  v0 = __readgsdword(8u);
  if ( v0 != dword_80EC4C4 )
  {
    _ECX = 1;
    v2 = __readgsdword(0xCu) == 0;
    if ( !v2 )
      __asm { lock }
    __asm { cmpxchg ds:list_all_lock, ecx }
    if ( !v2 )
      _lll_lock_wait_private(0, &list_all_lock);
    dword_80EC4C4 = v0;
  }
  ++dword_80EC4C0;
}
// 8055AC5: variable 'v0' is possibly undefined
// 80EC4BC: using guessed type int list_all_lock;
// 80EC4C0: using guessed type int dword_80EC4C0;
// 80EC4C4: using guessed type int dword_80EC4C4;

//----- (08055AE0) --------------------------------------------------------
int IO_list_unlock()
{
  int result; // eax

  if ( !--dword_80EC4C0 )
  {
    dword_80EC4C4 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      return _lll_unlock_wake_private(&list_all_lock);
  }
  return result;
}
// 80EC4BC: using guessed type int list_all_lock;
// 80EC4C0: using guessed type int dword_80EC4C0;
// 80EC4C4: using guessed type int dword_80EC4C4;

//----- (08055B20) --------------------------------------------------------
void IO_list_resetlock()
{
  list_all_lock = 0;
  dword_80EC4C0 = 0;
  dword_80EC4C4 = 0;
}
// 80EC4BC: using guessed type int list_all_lock;
// 80EC4C0: using guessed type int dword_80EC4C0;
// 80EC4C4: using guessed type int dword_80EC4C4;

//----- (08055B40) --------------------------------------------------------
int __cdecl IO_str_underflow(int *a1)
{
  unsigned __int8 *v1; // edx
  unsigned __int8 *v2; // ecx
  int v3; // ebx

  v1 = (unsigned __int8 *)a1[5];
  v2 = (unsigned __int8 *)a1[2];
  if ( v1 > v2 )
  {
    a1[2] = (int)v1;
    v2 = v1;
  }
  v3 = *a1;
  if ( (*a1 & 0xC00) == 3072 )
  {
    BYTE1(v3) &= ~8u;
    a1[1] = (int)v1;
    *a1 = v3;
    a1[5] = a1[6];
  }
  else
  {
    v1 = (unsigned __int8 *)a1[1];
  }
  if ( v1 >= v2 )
    return -1;
  else
    return *v1;
}

//----- (08055BA0) --------------------------------------------------------
int __cdecl IO_str_overflow(int a1, int a2)
{
  unsigned int v2; // eax
  int result; // eax
  _BYTE *v4; // ebp
  unsigned int v5; // edi
  unsigned int v6; // ebp
  _BYTE *v7; // eax
  unsigned int v8; // esi
  _BYTE *v9; // edx
  int v10; // eax
  int v11; // ebp
  int v12; // eax
  int v13; // eax
  _BYTE *v14; // [esp+1Ch] [ebp-20h]
  _BYTE *v15; // [esp+1Ch] [ebp-20h]

  v2 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 8) != 0 )
    return -(a2 != -1);
  if ( (*(_DWORD *)a1 & 0xC00) == 1024 )
  {
    BYTE1(v2) |= 8u;
    v4 = *(_BYTE **)(a1 + 4);
    *(_DWORD *)a1 = v2;
    v13 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v4;
    *(_DWORD *)(a1 + 4) = v13;
  }
  else
  {
    v4 = *(_BYTE **)(a1 + 20);
  }
  v5 = *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28);
  if ( __PAIR64__((unsigned int)&v4[-*(_DWORD *)(a1 + 16)], a2 + 1) >= __PAIR64__(v5, 1) )
  {
    if ( (*(_BYTE *)a1 & 1) != 0 )
      return -1;
    v6 = 2 * v5 + 100;
    v14 = *(_BYTE **)(a1 + 28);
    if ( v5 > v6 )
      return -1;
    v7 = (_BYTE *)(*(int (__cdecl **)(unsigned int))(a1 + 152))(2 * v5 + 100);
    v8 = (unsigned int)v7;
    if ( !v7 )
      return -1;
    v9 = v14;
    if ( v14 )
    {
      memcpy(v7, v14, v5);
      (*(void (__cdecl **)(_BYTE *))(a1 + 156))(v14);
      v9 = v14;
      *(_DWORD *)(a1 + 28) = 0;
    }
    v15 = v9;
    j_memset(v8 + v5, 0, v6 - v5);
    IO_setb((unsigned int *)a1, v8, v8 + v6, 1);
    v10 = *(_DWORD *)(a1 + 12);
    v11 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 16) = v8;
    *(_DWORD *)(a1 + 12) = v8 + v10 - (_DWORD)v15;
    v12 = *(_DWORD *)(a1 + 4);
    v4 = (_BYTE *)(v8 + v11 - (_DWORD)v15);
    *(_DWORD *)(a1 + 20) = v4;
    *(_DWORD *)(a1 + 4) = v8 + v12 - (_DWORD)v15;
    *(_DWORD *)(a1 + 8) = v8 + *(_DWORD *)(a1 + 8) - (_DWORD)v15;
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 32);
  }
  if ( a2 != -1 )
  {
    *(_DWORD *)(a1 + 20) = v4 + 1;
    *v4 = a2;
    v4 = *(_BYTE **)(a1 + 20);
  }
  result = a2;
  if ( *(_DWORD *)(a1 + 8) < (unsigned int)v4 )
    *(_DWORD *)(a1 + 8) = v4;
  return result;
}
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);

//----- (08055D20) --------------------------------------------------------
int __usercall enlarge_userbuf@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, long double a4@<st0>, int a5)
{
  _BYTE *v5; // ebp
  int v6; // esi
  _BYTE *v9; // edi
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v14; // [esp+20h] [ebp-2Ch]
  int v15; // [esp+24h] [ebp-28h]
  int v16; // [esp+28h] [ebp-24h]

  v5 = *(_BYTE **)(a1 + 28);
  if ( *(_DWORD *)(a1 + 32) - (int)v5 >= a2 )
    return 0;
  v6 = *(_DWORD *)a1 & 1;
  if ( v6 )
    return 1;
  v14 = *(_DWORD *)(a1 + 24);
  v15 = *(_DWORD *)(a1 + 16);
  v16 = a2 + 100;
  v9 = (_BYTE *)(*(int (__cdecl **)(int))(a1 + 152))(a2 + 100);
  if ( !v9 )
    return 1;
  if ( v5 )
  {
    memcpy(v9, v5, *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28));
    (*(void (__cdecl **)(_BYTE *))(a1 + 156))(v5);
    *(_DWORD *)(a1 + 28) = 0;
  }
  IO_setb((unsigned int *)a1, (unsigned int)v9, (unsigned int)&v9[v16], 1);
  v10 = v14 - v15;
  if ( a5 )
  {
    v11 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 12) = v9;
    *(_DWORD *)(a1 + 16) = &v9[v11 - (_DWORD)v5];
    *(_DWORD *)(a1 + 20) = &v9[*(_DWORD *)(a1 + 20) - (_DWORD)v5];
    *(_DWORD *)(a1 + 24) = &v9[*(_DWORD *)(a1 + 24) - (_DWORD)v5];
    *(_DWORD *)(a1 + 4) = &v9[*(_DWORD *)(a1 + 4) - (_DWORD)v5];
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32);
    if ( __SPAIR64__(a3, a2) >= v10 )
    {
      j_memset(&v9[v10], 0, a2 - v10);
      return v6;
    }
LABEL_13:
    _assert_fail(a4, (int)"offset >= oldend", (int)"strops.c", 224, "enlarge_userbuf");
  }
  v12 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 16) = v9;
  *(_DWORD *)(a1 + 12) = &v9[v12 - (_DWORD)v5];
  *(_DWORD *)(a1 + 4) = &v9[*(_DWORD *)(a1 + 4) - (_DWORD)v5];
  *(_DWORD *)(a1 + 8) = &v9[*(_DWORD *)(a1 + 8) - (_DWORD)v5];
  *(_DWORD *)(a1 + 20) = &v9[*(_DWORD *)(a1 + 20) - (_DWORD)v5];
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 32);
  if ( __SPAIR64__(a3, a2) < v10 )
    goto LABEL_13;
  j_memset(&v9[v10], 0, a2 - v10);
  return 0;
}
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);

//----- (08055ED0) --------------------------------------------------------
int __usercall IO_str_seekoff@<eax>(long double a1@<st0>, int *a2, __int64 a3, int a4, int a5)
{
  char v5; // si
  int v6; // eax
  unsigned int v7; // ebp
  int v8; // ebp
  signed int v9; // edi
  int v10; // esi
  unsigned int v13; // ebp
  int v14; // ecx
  int v15; // esi
  int v16; // eax
  unsigned int v17; // ebp
  __int64 v18; // [esp+8h] [ebp-24h]

  v5 = a5;
  v18 = a3;
  if ( !a5 )
  {
    v6 = *a2;
    if ( (*a2 & 0x400) == 0 )
    {
      if ( (v6 & 8) == 0 )
        return a2[5] - a2[4];
      return a2[1] - a2[3];
    }
    if ( (v6 & 0x800) != 0 )
    {
      v7 = a2[5];
      if ( a2[2] >= v7 )
        v7 = a2[2];
      v8 = v7 - a2[3];
LABEL_7:
      if ( a4 == 1 )
      {
        v9 = (unsigned __int64)(v18 + a2[5] - a2[4]) >> 32;
        v10 = v18 + a2[5] - a2[4];
      }
      else if ( a4 == 2 )
      {
        v9 = (unsigned __int64)(v18 + v8) >> 32;
        v10 = v18 + v8;
      }
      else
      {
        v9 = HIDWORD(v18);
        v10 = v18;
      }
      if ( v9 >= 0 && (v8 >= v10 || !enlarge_userbuf((int)a2, v10, v9, a1, 0)) )
      {
        a2[5] = v10 + a2[4];
        return v10;
      }
      return -1;
    }
    v17 = a2[2];
    v5 = 1;
    if ( a2[5] >= v17 )
      v17 = a2[5];
    v14 = a2[3];
    v8 = v17 - v14;
LABEL_25:
    if ( a4 == 1 )
    {
      v18 = a2[1] - v14 + a3;
    }
    else if ( a4 == 2 )
    {
      v18 = v8 + a3;
    }
    if ( v18 >= 0 )
    {
      if ( v8 >= (int)v18 )
      {
LABEL_30:
        a2[1] = v14 + v18;
        a2[2] = v8 + v14;
        v16 = v5 & 2;
        v15 = v18;
        goto LABEL_20;
      }
      if ( !enlarge_userbuf((int)a2, v18, HIDWORD(v18), a1, 1) )
      {
        v14 = a2[3];
        goto LABEL_30;
      }
    }
    return -1;
  }
  v13 = a2[5];
  if ( a2[2] >= v13 )
    v13 = a2[2];
  v14 = a2[3];
  v8 = v13 - v14;
  if ( (a5 & 1) != 0 )
    goto LABEL_25;
  v15 = -1;
  v16 = a5 & 2;
LABEL_20:
  if ( v16 )
    goto LABEL_7;
  return v15;
}

//----- (080560F0) --------------------------------------------------------
int __usercall IO_str_pbackfail@<eax>(long double a1@<st0>, int *a2, int a3)
{
  if ( (*(_BYTE *)a2 & 8) != 0 && a3 != -1 )
    return -1;
  else
    return IO_default_pbackfail(a1, a2, a3);
}

//----- (08056120) --------------------------------------------------------
_DWORD *__usercall IO_str_finish@<eax>(long double a1@<st0>, int a2)
{
  if ( *(_DWORD *)(a2 + 28) && (*(_BYTE *)a2 & 1) == 0 )
    (*(void (__cdecl **)(_DWORD))(a2 + 156))(*(_DWORD *)(a2 + 28));
  *(_DWORD *)(a2 + 28) = 0;
  return IO_default_finish(a1, (int *)a2);
}

//----- (08056160) --------------------------------------------------------
unsigned int __cdecl IO_str_init_static_internal(unsigned int *a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4; // esi
  unsigned int result; // eax

  if ( a3 )
  {
    v4 = a2 + a3;
    if ( a2 >= a2 + a3 )
      v4 = -1;
  }
  else
  {
    v4 = j_rawmemchr(a2, 0);
  }
  result = IO_setb(a1, a2, v4, 0);
  a1[4] = a2;
  a1[3] = a2;
  a1[1] = a2;
  if ( a4 )
  {
    a1[5] = a4;
    a1[6] = v4;
    a1[2] = a4;
  }
  else
  {
    a1[5] = a2;
    a1[6] = a2;
    a1[2] = v4;
  }
  a1[38] = 0;
  return result;
}
// 80481E0: using guessed type int __cdecl j_rawmemchr(_DWORD, _DWORD);

//----- (080561E0) --------------------------------------------------------
unsigned int __cdecl IO_str_init_static(unsigned int *a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4; // eax

  v4 = a3;
  if ( a3 < 0 )
    v4 = -1;
  return IO_str_init_static_internal(a1, a2, v4, a4);
}

//----- (08056200) --------------------------------------------------------
unsigned int __cdecl IO_str_init_readonly(unsigned int *a1, unsigned int a2, int a3)
{
  int v3; // eax
  unsigned int result; // eax

  v3 = a3;
  if ( a3 < 0 )
    v3 = -1;
  result = IO_str_init_static_internal(a1, a2, v3, 0);
  *a1 |= 8u;
  return result;
}

//----- (08056230) --------------------------------------------------------
unsigned int __cdecl IO_str_count(_DWORD *a1)
{
  unsigned int v1; // eax

  v1 = a1[5];
  if ( a1[2] >= v1 )
    v1 = a1[2];
  return v1 - a1[3];
}

//----- (08056250) --------------------------------------------------------
int *__usercall malloc_init_state@<eax>(int *result@<eax>)
{
  int *v1; // ebx
  int *v2; // edx
  int v3; // edx
  int v4; // edx

  v1 = result + 12;
  v2 = result + 12;
  do
  {
    v2[3] = (int)v2;
    v2[2] = (int)v2;
    v2 += 2;
  }
  while ( result + 266 != v2 );
  if ( result == &main_arena )
  {
    v4 = dword_80EB524;
    result[12] = (int)v1;
    global_max_fast = 64;
    result[1] = v4 | 1;
  }
  else
  {
    v3 = result[1];
    result[12] = (int)v1;
    result[1] = v3 | 3;
  }
  return result;
}
// 80EB520: using guessed type int main_arena;
// 80EB524: using guessed type int dword_80EB524;
// 80EC518: using guessed type int global_max_fast;

//----- (080562A0) --------------------------------------------------------
int __usercall mem2mem_check@<eax>(int result@<eax>, unsigned int a2@<edx>)
{
  int v2; // esi
  unsigned int v3; // ebx
  bool v4; // zf
  unsigned int v5; // ecx
  unsigned int v6; // edi
  int v7; // esi
  unsigned int v8; // ebx
  unsigned int i; // ebx
  int v10; // ecx
  char v11; // [esp+1h] [ebp-11h]

  if ( result )
  {
    v2 = *(_DWORD *)(result - 4);
    v3 = ((unsigned int)(result - 8) >> 11) ^ ((unsigned int)(result - 8) >> 3);
    if ( (_BYTE)v3 == 1 )
      LOBYTE(v3) = 2;
    v11 = v3;
    v4 = (v2 & 2) == 0;
    v5 = v2 & 0xFFFFFFF8;
    v6 = (v2 & 0xFFFFFFF8) - 8;
    v7 = (unsigned __int8)v3;
    v8 = v5 - 4;
    if ( !v4 )
      v8 = v6;
    for ( i = v8 - 1; a2 < i; i -= v10 )
    {
      v10 = i - a2;
      if ( i - a2 > 0xFF )
        v10 = 255;
      if ( v10 == v7 )
        v10 = v7 - 1;
      *(_BYTE *)(result + i) = v10;
    }
    *(_BYTE *)(result + a2) = v11;
  }
  return result;
}

//----- (08056330) --------------------------------------------------------
unsigned int __usercall mem2chunk_check@<eax>(int a1@<eax>, char **a2@<edx>)
{
  unsigned int v2; // ebx
  int v3; // esi
  unsigned int v4; // ecx
  unsigned int v5; // edx
  unsigned int v6; // edi
  char *v7; // esi
  int v8; // eax
  char v9; // dl
  int v11; // ebp
  unsigned int v12; // edi
  int v13; // eax
  int v14; // eax
  unsigned int v15; // esi

  if ( (a1 & 7) != 0 )
    return 0;
  v2 = a1 - 8;
  v3 = *(_DWORD *)(a1 - 4);
  v4 = ((unsigned int)(a1 - 8) >> 3) ^ ((unsigned int)(a1 - 8) >> 11);
  v5 = v3 & 0xFFFFFFF8;
  if ( (_BYTE)v4 == 1 )
    LOBYTE(v4) = 2;
  if ( (v3 & 2) != 0 )
  {
    v11 = a1 & (dl_pagesize - 1);
    if ( ((v11 - 8) & 0xFFFFFFF7) != 0
      && (unsigned int)(v11 - 1) <= 0x1FFE
      && ((v11 - 32) & 0xFFFFFFDF) != 0
      && ((v11 - 128) & 0xFFFFFF7F) != 0
      && ((v11 - 512) & 0xFFFFFDFF) != 0
      && ((v11 - 2048) & 0xFFFFF7FF) != 0
      || (v3 & 3) != 2
      || (((v2 - *(_DWORD *)(a1 - 8)) | (v5 + *(_DWORD *)(a1 - 8))) & (dl_pagesize - 1)) != 0 )
    {
      return 0;
    }
    v12 = v5 - 1;
    v7 = (char *)(v2 + v5 - 1);
    v13 = (unsigned __int8)*v7;
    v9 = *v7;
    if ( v13 != (unsigned __int8)v4 )
    {
      if ( !*v7 || v12 < v13 + 8 )
        return 0;
      while ( 1 )
      {
        v12 -= v13;
        v7 = (char *)(v2 + v12);
        v13 = *(unsigned __int8 *)(v2 + v12);
        v9 = *(_BYTE *)(v2 + v12);
        if ( v13 == (unsigned __int8)v4 )
          break;
        if ( !*(_BYTE *)(v2 + v12) || v13 + 8 > v12 )
          return 0;
      }
    }
  }
  else
  {
    if ( (dword_80EB524 & 2) == 0 && (v2 < dword_80EB50C || v2 + v5 >= dword_80EB96C + dword_80EB50C) )
      return 0;
    if ( v5 <= 0xF || (*(_BYTE *)(v2 + v5 + 4) & 1) == 0 )
      return 0;
    if ( (v3 & 1) == 0 )
    {
      v14 = *(_DWORD *)(a1 - 8);
      if ( (v14 & 7) != 0 )
        return 0;
      v15 = v2 - v14;
      if ( (dword_80EB524 & 2) == 0 && v15 < dword_80EB50C )
        return 0;
      if ( v14 != (*(_DWORD *)(v15 + 4) & 0xFFFFFFF8) )
        return 0;
    }
    v6 = v5 + 3;
    v7 = (char *)(v2 + v5 + 3);
    v8 = (unsigned __int8)*v7;
    v9 = *v7;
    if ( (unsigned __int8)v4 != v8 )
    {
      if ( !*v7 || v6 < v8 + 8 )
        return 0;
      while ( 1 )
      {
        v6 -= v8;
        v7 = (char *)(v2 + v6);
        v8 = *(unsigned __int8 *)(v2 + v6);
        v9 = *(_BYTE *)(v2 + v6);
        if ( v8 == (unsigned __int8)v4 )
          break;
        if ( !*(_BYTE *)(v2 + v6) || v8 + 8 > v6 )
          return 0;
      }
    }
  }
  *v7 = ~v9;
  if ( a2 )
  {
    *a2 = v7;
    return v2;
  }
  return v2;
}
// 80EB50C: using guessed type int dword_80EB50C;
// 80EB524: using guessed type int dword_80EB524;
// 80EB96C: using guessed type int dword_80EB96C;
// 80EBA08: using guessed type int dl_pagesize;

//----- (08056530) --------------------------------------------------------
void __usercall __noreturn _malloc_assert(
        int a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        long double a4@<st0>,
        void *a5)
{
  void *v5; // esi
  char *v6; // edi
  char *v7; // ebx
  long double v8; // [esp-28h] [ebp-44h]

  v5 = a5;
  if ( a5 )
  {
    v6 = ": ";
  }
  else
  {
    v6 = (char *)&unk_80CFAB1;
    v5 = &unk_80CFAB1;
  }
  v7 = ": ";
  if ( !*(_BYTE *)program_invocation_short_name )
    v7 = (char *)&unk_80CFAB1;
  *(_QWORD *)((char *)&v8 + 4) = __PAIR64__(a2, (unsigned int)v7);
  LODWORD(v8) = program_invocation_short_name;
  _fxprintf(a4, 0, "%s%s%s:%u: %s%sAssertion `%s' failed.\n", v8, a3, v5, v6, a1);
  fflush(stderr);
  abort(a4);
}
// 80EB4B4: using guessed type int *stderr;
// 80EB99C: using guessed type void *program_invocation_short_name;

//----- (080565A0) --------------------------------------------------------
int __usercall new_heap@<eax>(unsigned int a1@<eax>, int a2@<edx>)
{
  unsigned int v2; // edx
  int v3; // esi
  int v4; // eax
  int v5; // ebx
  int v7; // eax
  int v8; // edi
  int v9; // edx
  unsigned int v10; // eax

  v2 = a1 + a2;
  if ( v2 <= 0x7FFF )
  {
    v2 = 0x8000;
  }
  else if ( v2 > 0x100000 )
  {
    v2 = 0x100000;
    if ( a1 > 0x100000 )
      return 0;
  }
  v3 = (v2 + dl_pagesize - 1) & -dl_pagesize;
  if ( aligned_heap_area )
  {
    v4 = mmap(aligned_heap_area, 0x100000, 0, 16418, -1, 0);
    v5 = v4;
    aligned_heap_area = 0;
    if ( v4 != -1 )
    {
      if ( (v4 & 0xFFFFF) == 0 )
        goto LABEL_6;
      munmap(v4, 0x100000);
    }
  }
  v7 = mmap(0, 0x200000, 0, 16418, -1, 0);
  if ( v7 != -1 )
  {
    v5 = (v7 + 0xFFFFF) & 0xFFF00000;
    v8 = v5 - v7;
    if ( v5 == v7 )
    {
      v9 = v5 + 0x100000;
      aligned_heap_area = v5 + 0x100000;
    }
    else
    {
      munmap(v7, v8);
      v9 = v5 + 0x100000;
    }
    munmap(v9, 0x100000 - v8);
LABEL_6:
    if ( !mprotect(v5, v3) )
    {
      *(_DWORD *)(v5 + 8) = v3;
      *(_DWORD *)(v5 + 12) = v3;
      return v5;
    }
    goto LABEL_19;
  }
  v10 = mmap(0, 0x100000, 0, 16418, -1, 0);
  v5 = v10;
  if ( v10 == -1 )
    return 0;
  if ( (v10 & 0xFFFFF) == 0 )
    goto LABEL_6;
LABEL_19:
  munmap(v5, 0x100000);
  return 0;
}
// 80EBA08: using guessed type int dl_pagesize;
// 80EC504: using guessed type int aligned_heap_area;

//----- (08056740) --------------------------------------------------------
int *__usercall mremap_chunk@<eax>(int *result@<eax>, int a2@<edx>)
{
  int v2; // esi
  unsigned int v3; // ebp
  int v4; // edi
  int v5; // ebx
  unsigned int v6; // eax
  _DWORD *v7; // edx
  unsigned __int32 v8; // ebx
  int v9; // ett

  v2 = *result;
  v3 = result[1] & 0xFFFFFFF8;
  if ( (result[1] & 2) == 0 )
    _malloc_assert("mremap_chunk");
  v4 = v2 + v3;
  if ( ((v2 + v3) & (dl_pagesize - 1)) != 0 )
    _malloc_assert("mremap_chunk");
  v5 = (v2 + dl_pagesize + a2 + 3) & -dl_pagesize;
  if ( v4 != v5 )
  {
    v6 = mremap((int)result - v2, v2 + v3);
    if ( v6 == -1 )
      return 0;
    v7 = (_DWORD *)(v6 + v2);
    if ( (((_BYTE)v6 + (_BYTE)v2) & 7) != 0 )
      _malloc_assert("mremap_chunk");
    if ( v2 != *v7 )
      _malloc_assert("mremap_chunk");
    v7[1] = (v5 - v2) | 2;
    v8 = _InterlockedExchangeAdd(&dword_80EB504, v5 - v3 - v2) + v5 - v4;
    do
    {
      if ( v8 <= dword_80EB508 )
        break;
      v9 = dword_80EB508;
    }
    while ( v9 != _InterlockedCompareExchange(&dword_80EB508, v8, dword_80EB508) );
    return v7;
  }
  return result;
}
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80EB504: using guessed type int dword_80EB504;
// 80EB508: using guessed type int dword_80EB508;
// 80EBA08: using guessed type int dl_pagesize;

//----- (08056870) --------------------------------------------------------
int __usercall systrim_isra_0@<eax>(unsigned int a1@<eax>, int *a2@<edx>, _DWORD *a3@<ecx>)
{
  unsigned int v3; // esi
  int v4; // ebx
  int v8; // edx
  int v9; // edx
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // [esp+Ch] [ebp-20h]
  int v14; // [esp+Ch] [ebp-20h]

  v3 = *(_DWORD *)(*a2 + 4) & 0xFFFFFFF8;
  if ( v3 - 17 <= a1 )
    return 0;
  v4 = -dl_pagesize & (v3 - 17 - a1);
  if ( !v4 )
    return 0;
  v8 = _morecore(0);
  if ( v8 != v3 + *a2 )
    return 0;
  v13 = v8;
  _morecore(-v4);
  v9 = v13;
  if ( _after_morecore_hook )
  {
    ((void (*)(void))_after_morecore_hook)();
    v9 = v13;
  }
  v14 = v9;
  v10 = _morecore(0);
  if ( !v10 )
    return 0;
  v11 = v14 - v10;
  if ( v14 == v10 )
    return 0;
  v12 = *a2;
  *a3 -= v11;
  *(_DWORD *)(v12 + 4) = (v3 - v11) | 1;
  return 1;
}
// 80EB974: using guessed type int (__cdecl *_morecore)(_DWORD);
// 80EBA08: using guessed type int dl_pagesize;
// 80EC4EC: using guessed type int _after_morecore_hook;

//----- (08056920) --------------------------------------------------------
unsigned int get_free_list()
{
  unsigned int v1; // esi
  bool v3; // zf
  int v4; // eax
  bool v6; // zf

  _EDX = free_list;
  v1 = __readgsdword(0xFFFFFFEC);
  if ( free_list )
  {
    _ECX = 1;
    v3 = __readgsdword(0xCu) == 0;
    if ( !v3 )
      __asm { lock }
    __asm { cmpxchg ds:free_list_lock, ecx }
    if ( !v3 )
      _lll_lock_wait_private(0, &free_list_lock);
    _EDX = free_list;
    if ( free_list )
    {
      free_list = *(_DWORD *)(free_list + 1092);
      if ( *(_DWORD *)(_EDX + 1096) )
        _malloc_assert("get_free_list");
      *(_DWORD *)(_EDX + 1096) = 1;
      if ( v1 )
      {
        v4 = *(_DWORD *)(v1 + 1096);
        if ( !v4 )
          detach_arena_part_2();
        *(_DWORD *)(v1 + 1096) = v4 - 1;
      }
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --free_list_lock )
      _lll_unlock_wake_private(&free_list_lock);
    if ( _EDX )
    {
      _ECX = 1;
      v6 = __readgsdword(0xCu) == 0;
      if ( !v6 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v6 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
      __writegsdword(0xFFFFFFEC, _EDX);
    }
  }
  return _EDX;
}
// 80569C3: variable '_EDX' is possibly undefined
// 80483BC: using guessed type void __noreturn detach_arena_part_2(void);
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80EC50C: using guessed type int free_list;
// 80EC510: using guessed type int free_list_lock;

//----- (08056A10) --------------------------------------------------------
int __usercall malloc_printerr@<eax>(char a1@<al>, const char *a2@<edx>, unsigned int a3@<ecx>, int a4)
{
  int result; // eax
  char *v6; // eax
  const char *v7; // ecx
  char v9[8]; // [esp+17h] [ebp-15h] BYREF
  char v10[13]; // [esp+1Fh] [ebp-Dh] BYREF

  if ( a4 )
    *(_DWORD *)(a4 + 4) |= 4u;
  result = a1 & 5;
  if ( result == 5 )
    return _libc_message(a1 & 2, "%s\n", a2);
  if ( (a1 & 1) != 0 )
  {
    v10[0] = 0;
    v6 = itoa_word(a3, v10, 0x10u, 0);
    if ( v6 > v9 )
    {
      do
        *--v6 = 48;
      while ( v6 != v9 );
      v6 = v9;
    }
    v7 = *(const char **)_libc_argv;
    if ( !*(_DWORD *)_libc_argv )
      v7 = "<unknown>";
    return _libc_message(a1 & 2, "*** Error in `%s': %s: 0x%s ***\n", v7, a2, v6);
  }
  else if ( (a1 & 2) != 0 )
  {
    abort(a3);
  }
  return result;
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 8051390: using guessed type _DWORD _libc_message(_DWORD, _DWORD, ...);
// 80ECCD0: using guessed type int _libc_argv;
// 8056A10: using guessed type char var_D[13];

//----- (08056AD0) --------------------------------------------------------
int top_check()
{
  int v0; // ebx
  int v1; // eax
  unsigned int v2; // edx
  int v3; // eax
  int v4; // edi
  int v5; // esi
  int v6; // ebx
  int v7; // ebp
  int result; // eax

  v0 = dl_pagesize;
  if ( (int *)dword_80EB550 == &dword_80EB550 )
    return 0;
  v1 = *(_DWORD *)(dword_80EB550 + 4);
  if ( (v1 & 2) != 0
    || (v2 = v1 & 0xFFFFFFF8, (v1 & 0xFFFFFFF8) <= 0xF)
    || (v1 & 1) == 0
    || (result = 0, (dword_80EB524 & 2) == 0) && dword_80EB550 + v2 != dword_80EB50C + dword_80EB96C )
  {
    malloc_printerr(check_action, "malloc: top chunk is corrupt", dword_80EB550, (int)&main_arena);
    v3 = _morecore(0);
    v4 = v3;
    v5 = v3 & 7;
    if ( (v3 & 7) != 0 )
      v5 = 8 - v5;
    v6 = v5 + dword_80EB4E4 + 16 + v0 - ((v0 - 1) & (v3 + v5 + dword_80EB4E4 + 16));
    v7 = _morecore(v6);
    if ( v7 )
    {
      if ( _after_morecore_hook )
        _after_morecore_hook();
      result = 0;
      dword_80EB550 = v5 + v4;
      dword_80EB96C = v6 + v7 - dword_80EB50C;
      *(_DWORD *)(v5 + v4 + 4) = (v6 - v5) | 1;
    }
    else
    {
      __writegsdword(0xFFFFFFE8, 0xCu);
      return -1;
    }
  }
  return result;
}
// 80EB4CC: using guessed type int check_action;
// 80EB4E4: using guessed type int dword_80EB4E4;
// 80EB50C: using guessed type int dword_80EB50C;
// 80EB520: using guessed type int main_arena;
// 80EB524: using guessed type int dword_80EB524;
// 80EB550: using guessed type int dword_80EB550;
// 80EB96C: using guessed type int dword_80EB96C;
// 80EB974: using guessed type int (__cdecl *_morecore)(_DWORD);
// 80EBA08: using guessed type int dl_pagesize;
// 80EC4EC: using guessed type int (*_after_morecore_hook)(void);

//----- (08056BF0) --------------------------------------------------------
int *__usercall malloc_consolidate@<eax>(int *a1@<eax>)
{
  int *v1; // ebp
  unsigned int v2; // ebx
  _DWORD *v3; // edi
  int v4; // eax
  bool v5; // cc
  _DWORD *v6; // eax
  int v7; // eax
  _DWORD *v8; // esi
  unsigned int v9; // edi
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int *result; // eax
  _DWORD *v14; // edx
  int *v16; // [esp+4h] [ebp-30h]
  _DWORD *v17; // [esp+8h] [ebp-2Ch]
  int *v18; // [esp+Ch] [ebp-28h]
  volatile __int32 *v19; // [esp+10h] [ebp-24h]
  volatile __int32 *v20; // [esp+14h] [ebp-20h]

  if ( global_max_fast )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    a1[1] |= 1u;
    v18 = a1 + 12;
    v19 = a1 + 2;
    v20 = a1 + 11;
    while ( 1 )
    {
      v1 = (int *)_InterlockedExchange(v19, 0);
      if ( v1 )
        break;
LABEL_23:
      result = (int *)(v19 + 1);
      if ( v19 == v20 )
        return result;
      ++v19;
    }
    while ( 1 )
    {
      v16 = (int *)v1[2];
      v2 = v1[1] & 0xFFFFFFFA;
      v8 = (int *)((char *)v1 + v2);
      v9 = *(int *)((char *)v1 + v2 + 4) & 0xFFFFFFF8;
      if ( (v1[1] & 1) == 0 )
      {
        v10 = *v1;
        v1 = (int *)((char *)v1 - *v1);
        v2 += v10;
        v17 = (_DWORD *)v1[2];
        v11 = v1[3];
        if ( v1 == (int *)v17[3] && v1 == *(int **)(v11 + 8) )
        {
          v5 = (unsigned int)v1[1] <= 0x1FF;
          v17[3] = v11;
          *(_DWORD *)(v11 + 8) = v17;
          if ( v5 )
            goto LABEL_19;
          v12 = v1[4];
          if ( !v12 )
            goto LABEL_19;
          if ( v1 == *(int **)(v12 + 20) && v1 == *(int **)(v1[5] + 16) )
          {
            v14 = v17;
            if ( !v17[4] )
              goto LABEL_38;
          }
          else
          {
            malloc_printerr(check_action, "corrupted double-linked list (not small)", (unsigned int)v1, (int)a1);
            v14 = v17;
            v12 = v1[4];
            if ( !v17[4] )
            {
LABEL_38:
              if ( v1 == (int *)v12 )
              {
                v14[5] = v14;
                v14[4] = v14;
              }
              else
              {
                v17[4] = v12;
                v17[5] = v1[5];
                *(_DWORD *)(v1[4] + 20) = v17;
                *(_DWORD *)(v1[5] + 16) = v17;
              }
              goto LABEL_19;
            }
          }
          *(_DWORD *)(v12 + 20) = v1[5];
          *(_DWORD *)(v1[5] + 16) = v12;
        }
        else
        {
          malloc_printerr(check_action, "corrupted double-linked list", (unsigned int)v1, (int)a1);
        }
      }
LABEL_19:
      if ( v8 == (_DWORD *)a1[12] )
      {
        v1[1] = (v9 + v2) | 1;
        a1[12] = (int)v1;
        v1 = v16;
        if ( !v16 )
          goto LABEL_23;
      }
      else
      {
        if ( (*((_BYTE *)v8 + v9 + 4) & 1) != 0 )
        {
          v8[1] &= ~1u;
        }
        else
        {
          v2 += v9;
          v3 = (_DWORD *)v8[2];
          v4 = v8[3];
          if ( v8 == (_DWORD *)v3[3] && v8 == *(_DWORD **)(v4 + 8) )
          {
            v5 = v8[1] <= 0x1FFu;
            v3[3] = v4;
            *(_DWORD *)(v4 + 8) = v3;
            if ( !v5 )
            {
              v6 = (_DWORD *)v8[4];
              if ( v6 )
              {
                if ( v8 == (_DWORD *)v6[5] && v8 == *(_DWORD **)(v8[5] + 16) )
                {
                  if ( v3[4] )
                    goto LABEL_34;
                }
                else
                {
                  malloc_printerr(check_action, "corrupted double-linked list (not small)", (unsigned int)v8, (int)a1);
                  v6 = (_DWORD *)v8[4];
                  if ( v3[4] )
                  {
LABEL_34:
                    v6[5] = v8[5];
                    *(_DWORD *)(v8[5] + 16) = v6;
                    goto LABEL_11;
                  }
                }
                if ( v8 == v6 )
                {
                  v3[5] = v3;
                  v3[4] = v3;
                }
                else
                {
                  v3[4] = v6;
                  v3[5] = v8[5];
                  *(_DWORD *)(v8[4] + 20) = v3;
                  *(_DWORD *)(v8[5] + 16) = v3;
                }
              }
            }
          }
          else
          {
            malloc_printerr(check_action, "corrupted double-linked list", (unsigned int)v8, (int)a1);
          }
        }
LABEL_11:
        v7 = a1[14];
        a1[14] = (int)v1;
        *(_DWORD *)(v7 + 12) = v1;
        if ( v2 > 0x1FF )
        {
          v1[4] = 0;
          v1[5] = 0;
        }
        v1[2] = v7;
        v1[1] = v2 | 1;
        v1[3] = (int)v18;
        *(int *)((char *)v1 + v2) = v2;
        v1 = v16;
        if ( !v16 )
          goto LABEL_23;
      }
    }
  }
  return malloc_init_state(a1);
}
// 80EB4CC: using guessed type int check_action;
// 80EC518: using guessed type int global_max_fast;

//----- (08056EE0) --------------------------------------------------------
unsigned int __usercall int_mallinfo@<eax>(int *a1@<eax>, _DWORD *a2@<edx>)
{
  int v2; // eax
  int v3; // ebp
  int v4; // edi
  int *v5; // esi
  int i; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // ebx
  int *j; // eax
  int v11; // edx
  unsigned int result; // eax
  int v13; // eax
  int v16; // [esp+8h] [ebp-24h]

  v2 = a1[12];
  if ( !v2 )
  {
    malloc_consolidate(a1);
    v2 = a1[12];
  }
  v3 = 0;
  v4 = 0;
  v16 = *(_DWORD *)(v2 + 4);
  v5 = a1 + 2;
  do
  {
    for ( i = *v5; i; v4 += v7 & 0xFFFFFFF8 )
    {
      v7 = *(_DWORD *)(i + 4);
      i = *(_DWORD *)(i + 8);
      ++v3;
    }
    ++v5;
  }
  while ( a1 + 12 != v5 );
  v8 = (v16 & 0xFFFFFFF8) + v4;
  v9 = 1;
  do
  {
    for ( j = (int *)v5[3]; v5 != j; v8 += v11 & 0xFFFFFFF8 )
    {
      v11 = j[1];
      j = (int *)j[3];
      ++v9;
    }
    v5 += 2;
  }
  while ( a1 + 266 != v5 );
  a2[1] += v9;
  a2[2] += v3;
  a2[8] += v8;
  result = a1[275];
  *a2 += result;
  a2[6] += v4;
  a2[7] += result - v8;
  if ( a1 == &main_arena )
  {
    a2[3] = dword_80EB4F4;
    v13 = dword_80EB504;
    a2[5] = 0;
    a2[4] = v13;
    result = v16 & 0xFFFFFFF8;
    a2[9] = v16 & 0xFFFFFFF8;
  }
  return result;
}
// 80EB4F4: using guessed type int dword_80EB4F4;
// 80EB504: using guessed type int dword_80EB504;
// 80EB520: using guessed type int main_arena;

//----- (08056FF0) --------------------------------------------------------
_DWORD *__usercall munmap_chunk@<eax>(_DWORD *result@<eax>, long double a2@<st0>)
{
  int v2; // ebx
  int v3; // edx

  if ( (result[1] & 2) == 0 )
    _malloc_assert((int)"chunk_is_mmapped (p)", (unsigned int)"malloc.c", 2838, a2, "munmap_chunk");
  if ( (unsigned int)result < dumped_main_arena_start || (unsigned int)result >= dumped_main_arena_end )
  {
    v2 = (int)result - *result;
    v3 = *result + (result[1] & 0xFFFFFFF8);
    if ( ((v3 | v2) & (dl_pagesize - 1)) != 0 )
    {
      return (_DWORD *)malloc_printerr(check_action, "munmap_chunk(): invalid pointer", (unsigned int)(result + 2), 0);
    }
    else
    {
      _InterlockedDecrement(&dword_80EB4F4);
      _InterlockedAdd(&dword_80EB504, -v3);
      return (_DWORD *)munmap(v2, v3);
    }
  }
  return result;
}
// 80EB4CC: using guessed type int check_action;
// 80EB4F4: using guessed type int dword_80EB4F4;
// 80EB504: using guessed type int dword_80EB504;
// 80EBA08: using guessed type int dl_pagesize;
// 80EC51C: using guessed type int dumped_main_arena_end;
// 80EC520: using guessed type int dumped_main_arena_start;

//----- (080570A0) --------------------------------------------------------
int __usercall int_free@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)
{
  int v5; // eax
  unsigned int v6; // esi
  unsigned int v7; // ecx
  const char *v8; // edx
  char *v9; // edx
  unsigned int v10; // eax
  unsigned int v11; // esi
  unsigned int v12; // eax
  int *v14; // edx
  int v15; // edi
  bool v16; // cl
  int result; // eax
  int *v18; // eax
  _DWORD *v19; // edi
  unsigned int v20; // eax
  int v21; // eax
  int v22; // eax
  bool v23; // cc
  int v24; // eax
  int v25; // eax
  int v26; // eax
  unsigned int v27; // esi
  int v28; // ecx
  _DWORD *v29; // edi
  int v30; // eax
  int v31; // edx
  int v32; // eax
  _DWORD *v33; // edx
  int v34; // ebp
  _DWORD *v35; // ebp
  int v36; // eax
  int v37; // eax
  int v38; // ebx
  int v39; // ebx
  int v40; // edx
  unsigned int v41; // eax
  unsigned int v42; // ebx
  bool v44; // zf
  unsigned int v45; // ebx
  int v46; // ecx
  bool v47; // al
  bool v49; // zf
  unsigned int v50; // eax
  int v51; // eax
  unsigned int v52; // eax
  int v53; // ebx
  int v54; // eax
  int v55; // ecx
  unsigned int v56; // [esp+0h] [ebp-4Ch]
  int v57; // [esp+0h] [ebp-4Ch]
  unsigned int v58; // [esp+0h] [ebp-4Ch]
  _DWORD *v60; // [esp+8h] [ebp-44h]
  _DWORD *v61; // [esp+8h] [ebp-44h]
  int v62; // [esp+8h] [ebp-44h]
  int v63; // [esp+8h] [ebp-44h]
  unsigned int v64; // [esp+Ch] [ebp-40h]
  unsigned int v65; // [esp+Ch] [ebp-40h]
  unsigned int v66; // [esp+Ch] [ebp-40h]
  bool v67; // [esp+Ch] [ebp-40h]
  int v68; // [esp+10h] [ebp-3Ch]
  int v69; // [esp+10h] [ebp-3Ch]
  int v70; // [esp+14h] [ebp-38h]
  unsigned int v71; // [esp+18h] [ebp-34h]
  char v72[29]; // [esp+2Fh] [ebp-1Dh] BYREF

  _EBP = a1;
  _EBX = (int *)a2;
  v5 = *(_DWORD *)(a2 + 4);
  v6 = v5 & 0xFFFFFFF8;
  if ( a2 > -(v5 & 0xFFFFFFF8) || (a2 & 7) != 0 )
  {
    v7 = a2 + 8;
    v8 = "free(): invalid pointer";
    return malloc_printerr(check_action, v8, v7, _EBP);
  }
  v7 = a2 + 8;
  v8 = "free(): invalid size";
  if ( v6 <= 0xF )
    return malloc_printerr(check_action, v8, v7, _EBP);
  if ( v6 > global_max_fast )
  {
    if ( (v5 & 2) != 0 )
      return munmap_chunk(v7, "free(): invalid size");
    if ( a3 )
    {
      v18 = *(int **)(_EBP + 48);
      v19 = (int *)((char *)_EBX + v6);
      if ( _EBX == v18 )
      {
        v7 = (unsigned int)(_EBX + 2);
        v8 = "double free or corruption (top)";
        return malloc_printerr(check_action, v8, v7, _EBP);
      }
      v70 = 0;
    }
    else
    {
      _ECX = 1;
      v44 = __readgsdword(0xCu) == 0;
      if ( !v44 )
        __asm { lock }
      __asm { cmpxchg [ebp+0], ecx }
      if ( !v44 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EBP);
      v18 = *(int **)(_EBP + 48);
      v19 = (int *)((char *)_EBX + v6);
      if ( _EBX == v18 )
      {
        v8 = "double free or corruption (top)";
        goto LABEL_125;
      }
      v70 = 1;
    }
    if ( (*(_BYTE *)(_EBP + 4) & 2) == 0 && v19 >= (int *)((char *)v18 + (v18[1] & 0xFFFFFFF8)) )
    {
      v8 = "double free or corruption (out)";
      goto LABEL_123;
    }
    v20 = v19[1];
    if ( (v20 & 1) == 0 )
    {
      v8 = "double free or corruption (!prev)";
      goto LABEL_123;
    }
    v56 = v20 & 0xFFFFFFF8;
    if ( v20 <= 8 || (v20 & 0xFFFFFFF8) >= *(_DWORD *)(_EBP + 1100) )
    {
      v8 = "free(): invalid next size (normal)";
LABEL_123:
      if ( a3 || !v70 )
      {
LABEL_129:
        v7 = (unsigned int)(_EBX + 2);
        return malloc_printerr(check_action, v8, v7, _EBP);
      }
LABEL_125:
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v44 = (*(_DWORD *)_EBP)-- == 1;
      if ( !v44 )
        _lll_unlock_wake_private((_DWORD *)_EBP);
      goto LABEL_129;
    }
    if ( perturb_byte )
      j_memset(_EBX + 2, perturb_byte, v6 - 8);
    if ( (_EBX[1] & 1) == 0 )
    {
      v21 = *_EBX;
      _EBX = (int *)((char *)_EBX - *_EBX);
      v6 += v21;
      v60 = (_DWORD *)_EBX[2];
      v22 = _EBX[3];
      if ( _EBX == (int *)v60[3] && _EBX == *(int **)(v22 + 8) )
      {
        v23 = (unsigned int)_EBX[1] <= 0x1FF;
        v60[3] = v22;
        *(_DWORD *)(v22 + 8) = v60;
        if ( !v23 )
        {
          v24 = _EBX[4];
          if ( v24 )
          {
            if ( _EBX != *(int **)(v24 + 20) || _EBX != *(int **)(_EBX[5] + 16) )
            {
              malloc_printerr(check_action, "corrupted double-linked list (not small)", (unsigned int)_EBX, _EBP);
              v24 = _EBX[4];
            }
            if ( v60[4] )
            {
              *(_DWORD *)(v24 + 20) = _EBX[5];
              *(_DWORD *)(_EBX[5] + 16) = v24;
            }
            else if ( _EBX == (int *)v24 )
            {
              v60[5] = v60;
              v60[4] = v60;
            }
            else
            {
              v60[4] = v24;
              v60[5] = _EBX[5];
              *(_DWORD *)(_EBX[4] + 20) = v60;
              *(_DWORD *)(_EBX[5] + 16) = v60;
            }
          }
        }
      }
      else
      {
        malloc_printerr(check_action, "corrupted double-linked list", (unsigned int)_EBX, _EBP);
      }
    }
    if ( *(_DWORD **)(_EBP + 48) == v19 )
    {
      v6 += v56;
      result = v6 | 1;
      _EBX[1] = v6 | 1;
      *(_DWORD *)(_EBP + 48) = _EBX;
    }
    else
    {
      if ( (*((_BYTE *)v19 + v56 + 4) & 1) != 0 )
      {
        v19[1] &= ~1u;
      }
      else
      {
        v61 = (_DWORD *)v19[2];
        v25 = v19[3];
        v65 = v61[3];
        if ( (_DWORD *)v65 == v19 && v19 == *(_DWORD **)(v25 + 8) )
        {
          v23 = v19[1] <= 0x1FFu;
          v61[3] = v25;
          *(_DWORD *)(v25 + 8) = v61;
          if ( !v23 )
          {
            v51 = v19[4];
            if ( v51 )
            {
              if ( v19 != *(_DWORD **)(v51 + 20) || v19 != *(_DWORD **)(v19[5] + 16) )
              {
                malloc_printerr(check_action, "corrupted double-linked list (not small)", v65, _EBP);
                v51 = *(_DWORD *)(v65 + 16);
              }
              if ( v61[4] )
              {
                *(_DWORD *)(v51 + 20) = *(_DWORD *)(v65 + 20);
                *(_DWORD *)(*(_DWORD *)(v65 + 20) + 16) = v51;
              }
              else if ( v65 == v51 )
              {
                v61[5] = v61;
                v61[4] = v61;
              }
              else
              {
                v61[4] = v51;
                v61[5] = *(_DWORD *)(v65 + 20);
                *(_DWORD *)(*(_DWORD *)(v65 + 16) + 20) = v61;
                *(_DWORD *)(*(_DWORD *)(v65 + 20) + 16) = v61;
              }
            }
          }
        }
        else
        {
          malloc_printerr(check_action, "corrupted double-linked list", (unsigned int)v19, _EBP);
        }
        v6 += v56;
      }
      v26 = *(_DWORD *)(_EBP + 56);
      if ( _EBP + 48 != *(_DWORD *)(v26 + 12) )
      {
        v8 = "free(): corrupted unsorted chunks";
        goto LABEL_123;
      }
      _EBX[2] = v26;
      _EBX[3] = _EBP + 48;
      if ( v6 > 0x1FF )
      {
        _EBX[4] = 0;
        _EBX[5] = 0;
      }
      *(_DWORD *)(_EBP + 56) = _EBX;
      *(_DWORD *)(v26 + 12) = _EBX;
      result = v6 | 1;
      _EBX[1] = v6 | 1;
      *(int *)((char *)_EBX + v6) = v6;
    }
    if ( v6 > 0xFFFF )
    {
      if ( (*(_BYTE *)(_EBP + 4) & 1) == 0 )
        malloc_consolidate((int *)_EBP);
      if ( (int *)_EBP == &main_arena )
      {
        result = *(_DWORD *)(dword_80EB550 + 4) & 0xFFFFFFF8;
        if ( result >= (unsigned int)mp_ )
          result = systrim_isra_0(dword_80EB4E4, &dword_80EB550, &dword_80EB96C);
        goto LABEL_91;
      }
      v27 = *(_DWORD *)(_EBP + 48);
      v28 = v27 & 0xFFF00000;
      if ( _EBP != *(_DWORD *)(v27 & 0xFFF00000) )
        _malloc_assert("_int_free");
      v71 = dword_80EB4E4;
      v62 = dl_pagesize;
      result = v28 + 16;
      v68 = v28 + 16;
      if ( v28 + 16 == v27 )
      {
        v29 = *(_DWORD **)((*(_DWORD *)(_EBP + 48) & 0xFFF00000) + 4);
        v30 = v29[2];
        v31 = v30 - 8;
        v32 = ((_BYTE)v29 + (_BYTE)v30 - 8) & 7;
        v33 = (_DWORD *)((char *)v29 + v31 - v32);
        if ( v33[1] != 1 )
LABEL_167:
          _malloc_assert("heap_trim");
        v57 = _EBP;
        v34 = v29[2];
        v66 = dword_80EB4E4 + dl_pagesize + 16;
        while ( 1 )
        {
          v27 = (unsigned int)v33 - *v33;
          v40 = *(_DWORD *)(v27 + 4);
          v41 = v40 & 0xFFFFFFF8 | v32;
          v42 = v41 + 8;
          if ( v41 + 7 > 0x1E )
            _malloc_assert("heap_trim");
          if ( (v40 & 1) == 0 )
            v42 += *(_DWORD *)v27;
          if ( v42 - 1 > 0xFFFFE )
            _malloc_assert("heap_trim");
          if ( v42 - v34 + 0x100000 < v66 )
          {
            result = v68;
            _EBP = v57;
            v29 = (_DWORD *)v28;
            v38 = *(_DWORD *)(v68 + 4);
            v27 = v68;
            goto LABEL_82;
          }
          *(_DWORD *)(v57 + 1100) -= *(_DWORD *)(v28 + 8);
          if ( aligned_heap_area == v28 + 0x100000 )
            aligned_heap_area = 0;
          munmap(v28, 0x100000);
          if ( (*(_BYTE *)(v27 + 4) & 1) == 0 )
          {
            v27 -= *(_DWORD *)v27;
            v35 = *(_DWORD **)(v27 + 8);
            v36 = *(_DWORD *)(v27 + 12);
            if ( v27 == v35[3] && v27 == *(_DWORD *)(v36 + 8) )
            {
              v23 = *(_DWORD *)(v27 + 4) <= 0x1FFu;
              v35[3] = v36;
              *(_DWORD *)(v36 + 8) = v35;
              if ( !v23 )
              {
                v37 = *(_DWORD *)(v27 + 16);
                if ( v37 )
                {
                  if ( v27 != *(_DWORD *)(v37 + 20) || v27 != *(_DWORD *)(*(_DWORD *)(v27 + 20) + 16) )
                  {
                    malloc_printerr(check_action, "corrupted double-linked list (not small)", v27, v57);
                    v37 = *(_DWORD *)(v27 + 16);
                  }
                  if ( v35[4] )
                  {
                    *(_DWORD *)(v37 + 20) = *(_DWORD *)(v27 + 20);
                    *(_DWORD *)(*(_DWORD *)(v27 + 20) + 16) = v37;
                  }
                  else if ( v27 == v37 )
                  {
                    v35[5] = v35;
                    v35[4] = v35;
                  }
                  else
                  {
                    v35[4] = v37;
                    v35[5] = *(_DWORD *)(v27 + 20);
                    *(_DWORD *)(*(_DWORD *)(v27 + 16) + 20) = v35;
                    *(_DWORD *)(*(_DWORD *)(v27 + 20) + 16) = v35;
                  }
                }
              }
            }
            else
            {
              malloc_printerr(check_action, "corrupted double-linked list", v27, v57);
            }
          }
          if ( ((v62 - 1) & (v27 + v42)) != 0 )
            _malloc_assert("heap_trim");
          if ( (_DWORD *)(v27 + v42) != (_DWORD *)((char *)v29 + v29[2]) )
            _malloc_assert("heap_trim");
          v38 = v42 | 1;
          *(_DWORD *)(v57 + 48) = v27;
          result = (int)(v29 + 4);
          *(_DWORD *)(v27 + 4) = v38;
          if ( (_DWORD *)v27 != v29 + 4 )
            break;
          v39 = v29[1];
          v28 = (int)v29;
          v68 = v27;
          v34 = *(_DWORD *)(v39 + 8);
          v32 = ((_BYTE)v39 + (_BYTE)v34 - 8) & 7;
          v33 = (_DWORD *)(v39 + v34 - 8 - v32);
          if ( v33[1] != 1 )
            goto LABEL_167;
          v29 = (_DWORD *)v29[1];
        }
        _EBP = v57;
      }
      else
      {
        v38 = *(_DWORD *)(v27 + 4);
        v29 = (_DWORD *)(*(_DWORD *)(_EBP + 48) & 0xFFF00000);
      }
LABEL_82:
      v45 = v38 & 0xFFFFFFF8;
      v58 = v45;
      if ( mp_ > v45 )
        goto LABEL_91;
      v46 = v45 - 17;
      result = (v45 - 17) >> 31;
      v67 = v46 < 0 || v71 >= v46;
      if ( v67 )
        goto LABEL_91;
      result = -v62 & (v46 - v71);
      v63 = result;
      if ( !result )
        goto LABEL_91;
      result = v29[2] - result;
      v69 = result;
      if ( result <= 15 )
        goto LABEL_91;
      if ( may_shrink_heap_8236 < 0 )
      {
        may_shrink_heap_8236 = _libc_enable_secure;
        if ( !_libc_enable_secure )
        {
          v52 = dl_sysinfo(0x80000);
          v53 = v52;
          if ( v52 > 0xFFFFF000 )
            v53 = _syscall_error(v52);
          if ( v53 >= 0 )
          {
            v54 = dl_sysinfo(v72);
            if ( (unsigned int)v54 > 0xFFFFF000 )
              v54 = _syscall_error(v54);
            if ( v54 > 0 )
              v67 = v72[0] == 50;
            may_shrink_heap_8236 = v67;
            dl_sysinfo(v55);
          }
        }
        v47 = may_shrink_heap_8236 != 0;
      }
      else
      {
        v47 = may_shrink_heap_8236 != 0;
      }
      if ( !v47 )
      {
        madvise((int)v29 + v69, v63);
LABEL_90:
        v29[2] = v69;
        result = v63;
        *(_DWORD *)(_EBP + 1100) -= v63;
        *(_DWORD *)(v27 + 4) = (v58 - v63) | 1;
        goto LABEL_91;
      }
      result = mmap((int)v29 + v69, v63, 0, 50, -1, 0);
      if ( result != -1 )
      {
        v29[3] = v69;
        goto LABEL_90;
      }
    }
LABEL_91:
    if ( !a3 )
    {
      result = v70;
      if ( !v70 )
        _malloc_assert("_int_free");
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v44 = (*(_DWORD *)_EBP)-- == 1;
      if ( !v44 )
        return _lll_unlock_wake_private((_DWORD *)_EBP);
    }
    return result;
  }
  v9 = (char *)_EBX + v6;
  v10 = *(int *)((char *)_EBX + v6 + 4);
  if ( v10 > 8 && (v10 & 0xFFFFFFF8) < *(_DWORD *)(_EBP + 1100) )
    goto LABEL_7;
  if ( a3 )
  {
    v7 = (unsigned int)(_EBX + 2);
    v8 = "free(): invalid next size (fast)";
    return malloc_printerr(check_action, v8, v7, _EBP);
  }
  _ECX = 1;
  v49 = __readgsdword(0xCu) == 0;
  if ( !v49 )
    __asm { lock }
  __asm { cmpxchg [ebp+0], ecx }
  if ( !v49 )
    _lll_lock_wait_private(0, (volatile __int32 *)_EBP);
  v50 = *((_DWORD *)v9 + 1);
  if ( v50 <= 8 || (v50 & 0xFFFFFFF8) >= *(_DWORD *)(_EBP + 1100) )
  {
    v8 = "free(): invalid next size (fast)";
    goto LABEL_125;
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v44 = (*(_DWORD *)_EBP)-- == 1;
  if ( !v44 )
    _lll_unlock_wake_private((_DWORD *)_EBP);
LABEL_7:
  if ( perturb_byte )
    j_memset(_EBX + 2, perturb_byte, v6 - 8);
  if ( __readgsdword(0xCu) )
    __asm { lock }
  *(_DWORD *)(_EBP + 4) &= ~1u;
  v11 = v6 >> 3;
  v12 = v11 - 2;
  _ESI = _EBP + 4 * v11;
  v14 = *(int **)(_EBP + 4 * v12 + 8);
  v64 = v12;
  if ( _EBX == v14 )
  {
    v7 = (unsigned int)(_EBX + 2);
    v8 = "double free or corruption (fasttop)";
    return malloc_printerr(check_action, v8, v7, _EBP);
  }
  v15 = -1;
  v16 = a3 != 0 && v14 != 0;
  if ( v16 )
    v15 = ((unsigned int)v14[1] >> 3) - 2;
  _EBX[2] = (int)v14;
  result = (int)v14;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  __asm { cmpxchg [esi], ebx }
  if ( v15 != v64 && v16 )
  {
    v7 = (unsigned int)(_EBX + 2);
    v8 = "invalid fastbin entry (free)";
    return malloc_printerr(check_action, v8, v7, _EBP);
  }
  return result;
}
// 8057196: variable 'v8' is possibly undefined
// 805769A: variable 'v9' is possibly undefined
// 80579C1: variable 'v55' is possibly undefined
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 8056FF0: using guessed type int __fastcall munmap_chunk(_DWORD, _DWORD);
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80EB4C0: using guessed type int may_shrink_heap_8236;
// 80EB4CC: using guessed type int check_action;
// 80EB4E0: using guessed type int mp_;
// 80EB4E4: using guessed type int dword_80EB4E4;
// 80EB520: using guessed type int main_arena;
// 80EB550: using guessed type int dword_80EB550;
// 80EB96C: using guessed type int dword_80EB96C;
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EBA08: using guessed type int dl_pagesize;
// 80EC504: using guessed type int aligned_heap_area;
// 80EC514: using guessed type int perturb_byte;
// 80EC518: using guessed type int global_max_fast;
// 80570A0: using guessed type char var_1D[29];

//----- (08057B80) --------------------------------------------------------
int __usercall sysmalloc@<eax>(unsigned int a1@<eax>, int *a2@<edx>)
{
  unsigned int v4; // ebp
  int v5; // eax
  unsigned int v6; // edi
  bool v7; // cl
  unsigned int v8; // ebx
  int v9; // edx
  unsigned int v10; // ecx
  unsigned int v11; // eax
  unsigned int v12; // edi
  unsigned int v13; // eax
  int v14; // ecx
  int v15; // ebp
  unsigned int v16; // edx
  unsigned int v17; // eax
  unsigned int v19; // ebx
  int **v20; // eax
  int v21; // edx
  int *v22; // ebx
  unsigned int v23; // ebp
  unsigned int v24; // ebx
  unsigned int v25; // eax
  unsigned int *v26; // ebp
  unsigned int v27; // eax
  signed __int32 v28; // edx
  int v29; // ett
  unsigned __int32 v30; // ebx
  int v31; // ett
  int v32; // eax
  int v33; // edx
  unsigned int v34; // ebx
  unsigned int v35; // edx
  bool v36; // zf
  int v37; // eax
  int v38; // edx
  unsigned int v39; // ebp
  int v40; // ebx
  int v41; // ecx
  unsigned int v42; // eax
  unsigned int v43; // [esp+8h] [ebp-44h]
  unsigned int v44; // [esp+8h] [ebp-44h]
  int v45; // [esp+Ch] [ebp-40h]
  int v46; // [esp+Ch] [ebp-40h]
  int v47; // [esp+Ch] [ebp-40h]
  unsigned int v48; // [esp+Ch] [ebp-40h]
  unsigned int v49; // [esp+10h] [ebp-3Ch]
  int v50; // [esp+14h] [ebp-38h]
  unsigned int v51; // [esp+14h] [ebp-38h]
  unsigned int v52; // [esp+14h] [ebp-38h]
  char v53; // [esp+18h] [ebp-34h]
  unsigned int v54; // [esp+18h] [ebp-34h]
  int v55; // [esp+1Ch] [ebp-30h]
  unsigned int v56; // [esp+1Ch] [ebp-30h]
  unsigned int v57; // [esp+20h] [ebp-2Ch]
  bool v58; // [esp+20h] [ebp-2Ch]
  char v59; // [esp+20h] [ebp-2Ch]
  bool v60; // [esp+20h] [ebp-2Ch]
  int v61; // [esp+24h] [ebp-28h]
  bool v62; // [esp+24h] [ebp-28h]
  int v63; // [esp+28h] [ebp-24h]
  int v64; // [esp+2Ch] [ebp-20h]

  v45 = dl_pagesize;
  if ( a2 )
  {
    if ( dword_80EB4E8 > a1 || dword_80EB4F4 >= dword_80EB4F8 )
    {
      v53 = 0;
LABEL_4:
      v43 = a1;
      v55 = v45 + a1 + 3;
      while ( 1 )
      {
        v4 = a2[12];
        v5 = *(_DWORD *)(v4 + 4);
        v6 = v5 & 0xFFFFFFF8;
        v7 = (v5 & 0xFFFFFFF8) != 0;
        if ( ((int *)v4 != a2 + 12 || v6) && (v6 <= 0xF || (v5 & 1) == 0 || ((v45 - 1) & (v4 + (v5 & 0xFFFFFFF8))) != 0) )
          _malloc_assert("sysmalloc");
        v49 = v43 + 16;
        if ( v6 >= v43 + 16 )
          _malloc_assert("sysmalloc");
        if ( a2 == &main_arena )
          break;
        v8 = v4 & 0xFFF00000;
        if ( (int)(v49 - v6) > 0 )
        {
          v9 = *(_DWORD *)((v4 & 0xFFF00000) + 8);
          v10 = ((v49 - v6 + dl_pagesize - 1) & -dl_pagesize) + v9;
          if ( v10 <= 0x100000 )
          {
            v11 = *(_DWORD *)((v4 & 0xFFF00000) + 0xC);
            if ( v10 <= v11 )
            {
              v12 = v43;
              v13 = v10;
              v50 = a2[12];
              v14 = v50;
LABEL_13:
              v15 = a2[275];
              *(_DWORD *)(v8 + 8) = v13;
              v16 = v13 + v15 - v9;
              a2[275] = v16;
              *(_DWORD *)(v50 + 4) = (v13 + v8 - v50) | 1;
              goto LABEL_14;
            }
            v61 = *(_DWORD *)((v4 & 0xFFF00000) + 8);
            v57 = ((v49 - v6 + dl_pagesize - 1) & -dl_pagesize) + v9;
            if ( !mprotect(v8 + v11, v10 - v11) )
            {
              v50 = v4;
              v9 = v61;
              v12 = v43;
              v13 = v57;
              *(_DWORD *)((v4 & 0xFFF00000) + 0xC) = v57;
              v14 = a2[12];
              goto LABEL_13;
            }
          }
        }
        v20 = (int **)new_heap(v43 + 32, dword_80EB4E4);
        if ( v20 )
        {
          v20[1] = (int *)v8;
          v21 = a2[275];
          v14 = (int)(v20 + 4);
          v22 = v20[2];
          v51 = v4;
          v23 = v6;
          *v20 = a2;
          a2[12] = (int)(v20 + 4);
          v12 = v43;
          v16 = (unsigned int)v22 + v21;
          a2[275] = v16;
          v20[5] = (int *)((unsigned int)(v22 - 4) | 1);
          v24 = v23 - 8;
          v25 = v23 - 16;
          v26 = (unsigned int *)(v23 - 8 + v51);
          v26[1] = 1;
          if ( v25 > 0xF )
          {
            *(_DWORD *)(v51 + v25 + 4) = 9;
            *v26 = 8;
            *(_DWORD *)(v51 + 4) = v25 | 5;
            int_free((int)a2, v51, 1);
            v16 = a2[275];
            v14 = a2[12];
          }
          else
          {
            *(_DWORD *)(v51 + 4) = v24 | 1;
            *v26 = v24;
          }
          goto LABEL_14;
        }
        if ( v53 )
        {
          v12 = v43;
          v16 = a2[275];
          v14 = a2[12];
          goto LABEL_14;
        }
        v19 = v55 & -v45;
        if ( v43 < v19 )
        {
          v27 = mmap(0, v55 & -v45, 3, 34, -1, 0);
          if ( v27 != -1 )
            goto LABEL_32;
        }
        v53 = 1;
      }
      v54 = *(_DWORD *)(v4 + 4) & 0xFFFFFFF8;
      v12 = v43;
      v52 = a2[12];
      v56 = v4 + (v5 & 0xFFFFFFF8);
      v32 = v43 + dword_80EB4E4 + 16;
      if ( (dword_80EB524 & 2) != 0 )
      {
        v64 = -v45;
        v63 = v45 - 1;
        v33 = -v45 & (v45 - 1 + v32);
        v34 = v33;
        if ( v33 <= 0 )
          goto LABEL_57;
      }
      else
      {
        v64 = -v45;
        v63 = v45 - 1;
        v33 = -v45 & (v45 - 1 + v32 - (*(_DWORD *)(v4 + 4) & 0xFFFFFFF8));
        v34 = v33;
        if ( v33 <= 0 )
        {
LABEL_88:
          v34 = v64 & (v33 + v63 + v54);
          goto LABEL_57;
        }
      }
      v58 = v7;
      v46 = v33;
      v44 = _morecore(v33);
      v33 = v46;
      v7 = v58;
      if ( v44 )
      {
        v59 = 1;
        v47 = 0;
        if ( _after_morecore_hook )
        {
          v62 = v7;
          _after_morecore_hook();
          v7 = v62;
        }
        goto LABEL_45;
      }
      if ( (dword_80EB524 & 2) == 0 )
        goto LABEL_88;
LABEL_57:
      v35 = v34;
      if ( v34 <= 0xFFFFF )
      {
        v35 = 0x100000;
        v34 = 0x100000;
      }
      if ( v12 >= v35
        || (v60 = v7, v48 = v35, v44 = mmap(0, v35, 3, 34, -1, 0), v7 = v60, v44 == -1)
        || (dword_80EB524 |= 2u, !v44) )
      {
LABEL_77:
        v16 = dword_80EB96C;
LABEL_78:
        v14 = dword_80EB550;
        goto LABEL_14;
      }
      v36 = v44 + v48 == 0;
      v47 = v44 + v48;
      v59 = v36;
LABEL_45:
      if ( !dword_80EB50C )
        dword_80EB50C = v44;
      v16 = v34 + dword_80EB96C;
      dword_80EB96C += v34;
      if ( v56 == v44 && v59 )
      {
        *(_DWORD *)(v4 + 4) = (v34 + v54) | 1;
        v14 = dword_80EB550;
        goto LABEL_14;
      }
      if ( (dword_80EB524 & 2) != 0 )
      {
        if ( (v44 & 7) != 0 )
          _malloc_assert("sysmalloc");
        v40 = 0;
        v41 = 0;
        if ( v47 )
          goto LABEL_74;
        v47 = _morecore(0);
        v39 = v44;
      }
      else
      {
        if ( v56 > v44 && v7 )
        {
          malloc_printerr(3, "break adjusted to free malloc space", v44, (int)&main_arena);
          v16 = dword_80EB96C;
          v14 = dword_80EB550;
LABEL_14:
          if ( a2[276] < v16 )
            a2[276] = v16;
          v17 = *(_DWORD *)(v14 + 4) & 0xFFFFFFF8;
          if ( v49 <= v17 )
          {
            a2[12] = v14 + v12;
            *(_DWORD *)(v14 + 4) = (4 * (a2 != &main_arena)) | v12 | 1;
            *(_DWORD *)(v14 + v12 + 4) = (v17 - v12) | 1;
            return v14 + 8;
          }
          __writegsdword(0xFFFFFFE8, 0xCu);
          return 0;
        }
        if ( v54 )
          dword_80EB96C = v44 - v56 + v16;
        v37 = v44 & 7;
        if ( (v44 & 7) != 0 )
        {
          v38 = 8 - v37;
          v39 = 8 - v37 + v44;
        }
        else
        {
          v38 = 0;
          v39 = v44;
        }
        v40 = (v64 & (v44 + v54 + v38 + v34 + v63)) - (v44 + v34);
        if ( v40 < 0 )
          _malloc_assert("sysmalloc");
        v47 = _morecore(v40);
        v41 = v40;
        if ( v47 )
        {
          if ( _after_morecore_hook )
          {
            _after_morecore_hook();
            v16 = dword_80EB96C;
            v44 = v39;
            v41 = v40;
          }
          else
          {
            v16 = dword_80EB96C;
            v44 = v39;
          }
LABEL_74:
          v16 += v40;
          dword_80EB550 = v44;
          *(_DWORD *)(v44 + 4) = (v41 + v47 - v44) | 1;
          dword_80EB96C = v16;
          if ( v54 )
          {
            v42 = v54 - 16;
            *(_DWORD *)(v52 + 4) = (v54 - 16) | 1;
            *(_DWORD *)(v52 + v42 + 4) = 9;
            v14 = v44;
            *(_DWORD *)(v52 + v42 + 12) = 9;
            if ( v54 - 16 <= 0xF )
              goto LABEL_14;
            int_free((int)&main_arena, v52, 1);
            goto LABEL_77;
          }
          v14 = v44;
          goto LABEL_14;
        }
        v47 = _morecore(0);
      }
      v16 = dword_80EB96C;
      if ( !v47 )
        goto LABEL_78;
      v44 = v39;
      v40 = 0;
      v41 = 0;
      goto LABEL_74;
    }
    v19 = -dl_pagesize & (dl_pagesize + a1 + 3);
    if ( a1 >= v19 || (v27 = mmap(0, -dl_pagesize & (dl_pagesize + a1 + 3), 3, 34, -1, 0), v27 == -1) )
    {
      v53 = 1;
      goto LABEL_4;
    }
  }
  else
  {
    v19 = -dl_pagesize & (dl_pagesize + a1 + 3);
    if ( v19 <= a1 )
      return 0;
    v27 = mmap(0, -dl_pagesize & (dl_pagesize + a1 + 3), 3, 34, -1, 0);
    if ( v27 == -1 )
      return 0;
  }
LABEL_32:
  if ( (((_BYTE)v27 + 8) & 7) != 0 )
    _malloc_assert("sysmalloc");
  *(_DWORD *)(v27 + 4) = v19 | 2;
  v28 = _InterlockedIncrement(&dword_80EB4F4);
  do
  {
    if ( v28 <= dword_80EB4FC )
      break;
    v29 = dword_80EB4FC;
  }
  while ( v29 != _InterlockedCompareExchange(&dword_80EB4FC, v28, dword_80EB4FC) );
  v30 = _InterlockedExchangeAdd(&dword_80EB504, v19) + v19;
  do
  {
    if ( v30 <= dword_80EB508 )
      break;
    v31 = dword_80EB508;
  }
  while ( v31 != _InterlockedCompareExchange(&dword_80EB508, v30, dword_80EB508) );
  return v27 + 8;
}
// 80EC4EC: invalid function type '?' has been ignored
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80EB4E4: using guessed type int dword_80EB4E4;
// 80EB4E8: using guessed type int dword_80EB4E8;
// 80EB4F4: using guessed type int dword_80EB4F4;
// 80EB4F8: using guessed type int dword_80EB4F8;
// 80EB4FC: using guessed type int dword_80EB4FC;
// 80EB504: using guessed type int dword_80EB504;
// 80EB508: using guessed type int dword_80EB508;
// 80EB50C: using guessed type int dword_80EB50C;
// 80EB520: using guessed type int main_arena;
// 80EB524: using guessed type int dword_80EB524;
// 80EB550: using guessed type int dword_80EB550;
// 80EB96C: using guessed type int dword_80EB96C;
// 80EB974: using guessed type int (__cdecl *_morecore)(_DWORD);
// 80EBA08: using guessed type int dl_pagesize;
// 80EC4EC: using guessed type int (*_after_morecore_hook)(void);

//----- (080583D0) --------------------------------------------------------
int __usercall int_malloc@<eax>(int *a1@<eax>, unsigned int a2@<edx>)
{
  unsigned int v3; // eax
  unsigned int v4; // edx
  bool v5; // cf
  unsigned int v6; // eax
  int *j; // ebx
  int v10; // edx
  int *v11; // esi
  int v12; // edi
  bool v13; // zf
  unsigned int v14; // edx
  int v15; // esi
  unsigned int v16; // edx
  unsigned int v17; // eax
  int v18; // ecx
  int *v19; // ecx
  int *v20; // eax
  unsigned int v21; // edx
  unsigned int v22; // ecx
  int v23; // edx
  int v24; // eax
  int v25; // ebx
  unsigned int v27; // eax
  unsigned int v28; // ecx
  int v29; // edx
  unsigned int v30; // eax
  unsigned int v31; // ecx
  _DWORD *v32; // eax
  unsigned int v33; // eax
  unsigned int v34; // eax
  int v35; // edx
  unsigned int v36; // eax
  unsigned int v37; // edi
  unsigned int i; // esi
  unsigned int v39; // ecx
  unsigned int v40; // eax
  int v41; // eax
  int *v42; // edx
  unsigned int v43; // edi
  _DWORD *v44; // esi
  int v45; // eax
  bool v46; // cc
  int v47; // eax
  int v48; // edx
  _DWORD *v49; // eax
  const char *v50; // edx
  unsigned int v51; // edx
  _DWORD *v52; // esi
  int v53; // eax
  int v54; // eax
  int v55; // edx
  int v56; // eax
  int *v57; // [esp+8h] [ebp-64h]
  unsigned int v58; // [esp+Ch] [ebp-60h]
  int v59; // [esp+10h] [ebp-5Ch]
  unsigned int v60; // [esp+10h] [ebp-5Ch]
  int v61; // [esp+14h] [ebp-58h]
  int v62; // [esp+18h] [ebp-54h]
  unsigned int v64; // [esp+20h] [ebp-4Ch]

  if ( a2 > 0xFFFFFFDF )
  {
    __writegsdword(0xFFFFFFE8, 0xCu);
    return 0;
  }
  v3 = a2 + 11;
  v4 = (a2 + 11) & 0xFFFFFFF8;
  v5 = v3 < 0x10;
  v6 = 16;
  if ( !v5 )
    v6 = v4;
  v58 = v6;
  if ( !a1 )
  {
    v25 = sysmalloc(v6, 0);
    if ( v25 )
    {
LABEL_110:
      v24 = perturb_byte;
      if ( perturb_byte )
        goto LABEL_59;
      return v25;
    }
    return 0;
  }
  if ( v6 <= global_max_fast )
  {
    _ECX = &a1[v6 >> 3];
    j = (int *)a1[v6 >> 3];
    if ( j )
    {
      _EDI = j[2];
      if ( __readgsdword(0xCu) )
        __asm { lock }
      __asm { cmpxchg [ecx], edi }
      if ( (v6 >> 3) - 2 == ((unsigned int)j[1] >> 3) - 2 )
        goto LABEL_39;
      v50 = "malloc(): memory corruption (fast)";
      goto LABEL_113;
    }
  }
  if ( v6 <= 0x1FF )
  {
    v62 = v6 >> 3;
    j = (int *)a1[2 * (v6 >> 3) + 13];
    if ( &a1[2 * (v6 >> 3) + 10] == j )
      goto LABEL_21;
    if ( j )
    {
      v10 = j[3];
      if ( j == *(int **)(v10 + 8) )
      {
        *(int *)((char *)j + v6 + 4) |= 1u;
        a1[2 * (v6 >> 3) + 13] = v10;
        *(_DWORD *)(v10 + 8) = &a1[2 * (v6 >> 3) + 10];
        if ( a1 == &main_arena )
          goto LABEL_39;
        goto LABEL_15;
      }
      v50 = "malloc(): smallbin double linked list corrupted";
LABEL_113:
      malloc_printerr(check_action, v50, (unsigned int)(j + 2), (int)a1);
      return 0;
    }
    goto LABEL_20;
  }
  if ( v6 >> 6 <= 0x26 )
  {
    v62 = (v6 >> 6) + 56;
  }
  else if ( v6 >> 9 > 0x14 )
  {
    if ( v6 >> 12 <= 0xA )
    {
      v62 = (v6 >> 12) + 110;
    }
    else if ( v6 >> 15 > 4 )
    {
      v56 = 126;
      if ( v58 >> 18 <= 2 )
        v56 = (v58 >> 18) + 124;
      v62 = v56;
    }
    else
    {
      v62 = (v6 >> 15) + 119;
    }
  }
  else
  {
    v62 = (v6 >> 9) + 91;
  }
  if ( (a1[1] & 1) == 0 )
LABEL_20:
    malloc_consolidate(a1);
LABEL_21:
  v57 = a1 + 12;
  v64 = v58 + 16;
LABEL_22:
  v61 = 10000;
  while ( 1 )
  {
    j = (int *)a1[15];
    if ( j == v57 )
    {
LABEL_65:
      if ( v58 <= 0x1FF || (v42 = (int *)a1[2 * v62 + 12], v42 == &a1[2 * v62 + 10]) || v58 > v42[1] )
      {
        v35 = (int)&a1[2 * v62 + 12];
        v36 = 1 << (v62 + 1);
        v37 = (unsigned int)(v62 + 1) >> 5;
        for ( i = a1[v37 + 268]; ; a1[v37 + 268] = i )
        {
          if ( v36 > i || !v36 )
          {
            while ( ++v37 != 4 )
            {
              i = a1[v37 + 268];
              if ( i )
              {
                v35 = (int)&a1[64 * v37 + 10];
                v36 = 1;
                goto LABEL_71;
              }
            }
            j = (int *)a1[12];
            v40 = j[1] & 0xFFFFFFF8;
            if ( v40 >= v64 )
            {
              a1[12] = (int)j + v58;
              j[1] = (4 * (a1 != &main_arena)) | v58 | 1;
              *(int *)((char *)j + v58 + 4) = (v40 - v58) | 1;
              goto LABEL_39;
            }
            if ( (a1[1] & 1) == 0 )
            {
              malloc_consolidate(a1);
              v62 = v58 >> 3;
              if ( v58 > 0x1FF )
              {
                v62 = (v58 >> 6) + 56;
                if ( v58 >> 6 > 0x26 )
                {
                  v62 = (v58 >> 9) + 91;
                  if ( v58 >> 9 > 0x14 )
                  {
                    v62 = (v58 >> 12) + 110;
                    if ( v58 >> 12 > 0xA )
                    {
                      v62 = (v58 >> 15) + 119;
                      if ( v58 >> 15 > 4 )
                      {
                        v41 = 126;
                        if ( v58 >> 18 <= 2 )
                          v41 = (v58 >> 18) + 124;
                        v62 = v41;
                      }
                    }
                  }
                }
              }
              goto LABEL_22;
            }
            v25 = sysmalloc(v58, a1);
            if ( v25 )
              goto LABEL_110;
            return 0;
          }
LABEL_71:
          while ( (i & v36) == 0 )
          {
            v35 += 8;
            v36 *= 2;
            if ( !v36 )
              _malloc_assert("_int_malloc");
          }
          j = *(int **)(v35 + 12);
          if ( (int *)v35 != j )
            break;
          v39 = v36;
          v35 += 8;
          v36 *= 2;
          i &= ~v39;
        }
        v51 = j[1];
        v43 = v51 & 0xFFFFFFF8;
        if ( v58 > (v51 & 0xFFFFFFF8) )
          _malloc_assert("_int_malloc");
        v52 = (_DWORD *)j[2];
        v60 = v43 - v58;
        v53 = j[3];
        if ( j == (int *)v52[3] && j == *(int **)(v53 + 8) )
        {
          v52[3] = v53;
          *(_DWORD *)(v53 + 8) = v52;
          if ( v51 > 0x1FF )
          {
            v54 = j[4];
            if ( v54 )
            {
              if ( j != *(int **)(v54 + 20) || j != *(int **)(j[5] + 16) )
              {
                malloc_printerr(check_action, "corrupted double-linked list (not small)", (unsigned int)j, (int)a1);
                v54 = j[4];
              }
              if ( v52[4] )
              {
                *(_DWORD *)(v54 + 20) = j[5];
                *(_DWORD *)(j[5] + 16) = v54;
              }
              else if ( j == (int *)v54 )
              {
                v52[5] = v52;
                v52[4] = v52;
              }
              else
              {
                v52[4] = v54;
                v52[5] = j[5];
                *(_DWORD *)(j[4] + 20) = v52;
                *(_DWORD *)(j[5] + 16) = v52;
              }
            }
          }
        }
        else
        {
          malloc_printerr(check_action, "corrupted double-linked list", (unsigned int)j, (int)a1);
        }
        if ( v60 <= 0xF )
          goto LABEL_125;
        v55 = a1[14];
        if ( *(int **)(v55 + 12) != v57 )
        {
          v50 = "malloc(): corrupted unsorted chunks 2";
          goto LABEL_113;
        }
        v49 = (int *)((char *)j + v58);
        v49[3] = v57;
        v49[2] = v55;
        a1[14] = (int)j + v58;
        *(_DWORD *)(v55 + 12) = (char *)j + v58;
        if ( v58 <= 0x1FF )
          a1[13] = (int)v49;
        if ( v60 <= 0x1FF )
          goto LABEL_106;
      }
      else
      {
        for ( j = (int *)v42[5]; ; j = (int *)j[5] )
        {
          v43 = j[1] & 0xFFFFFFF8;
          if ( v58 <= v43 )
            break;
        }
        v44 = (_DWORD *)j[2];
        if ( (int *)a1[2 * v62 + 13] != j && j[1] == v44[1] )
        {
          j = (int *)j[2];
          v44 = (_DWORD *)v44[2];
        }
        v60 = v43 - v58;
        v45 = j[3];
        if ( j == (int *)v44[3] && j == *(int **)(v45 + 8) )
        {
          v46 = (unsigned int)j[1] <= 0x1FF;
          v44[3] = v45;
          *(_DWORD *)(v45 + 8) = v44;
          if ( !v46 )
          {
            v47 = j[4];
            if ( v47 )
            {
              if ( j != *(int **)(v47 + 20) || j != *(int **)(j[5] + 16) )
              {
                malloc_printerr(check_action, "corrupted double-linked list (not small)", (unsigned int)j, (int)a1);
                v47 = j[4];
              }
              if ( v44[4] )
              {
                *(_DWORD *)(v47 + 20) = j[5];
                *(_DWORD *)(j[5] + 16) = v47;
              }
              else if ( j == (int *)v47 )
              {
                v44[5] = v44;
                v44[4] = v44;
              }
              else
              {
                v44[4] = v47;
                v44[5] = j[5];
                *(_DWORD *)(j[4] + 20) = v44;
                *(_DWORD *)(j[5] + 16) = v44;
              }
            }
          }
        }
        else
        {
          malloc_printerr(check_action, "corrupted double-linked list", (unsigned int)j, (int)a1);
        }
        if ( v60 <= 0xF )
        {
LABEL_125:
          *(int *)((char *)j + v43 + 4) |= 1u;
          if ( a1 == &main_arena )
            goto LABEL_39;
LABEL_15:
          j[1] |= 4u;
          goto LABEL_39;
        }
        v48 = a1[14];
        v49 = (int *)((char *)j + v58);
        if ( *(int **)(v48 + 12) != v57 )
        {
          v50 = "malloc(): corrupted unsorted chunks";
          goto LABEL_113;
        }
        v49[3] = v57;
        v49[2] = v48;
        a1[14] = (int)v49;
        *(_DWORD *)(v48 + 12) = v49;
        if ( v60 <= 0x1FF )
        {
LABEL_106:
          j[1] = (4 * (a1 != &main_arena)) | v58 | 1;
          v49[1] = v60 | 1;
          *(int *)((char *)j + v43) = v60;
          goto LABEL_39;
        }
      }
      v49[4] = 0;
      v49[5] = 0;
      goto LABEL_106;
    }
    v14 = j[1];
    v15 = j[3];
    if ( v14 <= 8 || v14 > a1[275] )
    {
      malloc_printerr(check_action, "malloc(): memory corruption", (unsigned int)(j + 2), (int)a1);
      v14 = j[1];
    }
    v16 = v14 & 0xFFFFFFF8;
    if ( v58 <= 0x1FF && (int *)v15 == v57 && j == (int *)a1[13] && v16 > v64 )
      break;
    a1[15] = v15;
    *(_DWORD *)(v15 + 8) = v57;
    if ( v58 == v16 )
    {
      *(int *)((char *)j + v58 + 4) |= 1u;
      if ( a1 != &main_arena )
        j[1] |= 4u;
LABEL_39:
      v24 = perturb_byte;
      v25 = (int)(j + 2);
      if ( perturb_byte )
        goto LABEL_59;
      return v25;
    }
    if ( v16 > 0x1FF )
    {
      v17 = v16 >> 6;
      if ( v16 >> 6 > 0x26 )
      {
        v27 = v16 >> 9;
        if ( v16 >> 9 > 0x14 )
        {
          v30 = v16 >> 12;
          if ( v16 >> 12 > 0xA )
          {
            v33 = v16 >> 15;
            if ( v16 >> 15 > 4 )
            {
              v34 = v16 >> 18;
              if ( v16 >> 18 > 2 )
              {
                v18 = 1056;
                v59 = 126;
              }
              else
              {
                v18 = 8 * v34 + 1040;
                v59 = v34 + 124;
              }
            }
            else
            {
              v18 = 8 * v33 + 1000;
              v59 = v33 + 119;
            }
          }
          else
          {
            v18 = 8 * v30 + 928;
            v59 = v30 + 110;
          }
          goto LABEL_34;
        }
        v19 = &a1[2 * v27 + 194];
        v59 = v27 + 91;
        v20 = (int *)*v19;
        v11 = v19 - 2;
        if ( v19 - 2 != (int *)*v19 )
        {
LABEL_35:
          v12 = v19[1];
          v21 = v16 | 1;
          v22 = *(_DWORD *)(v12 + 4);
          if ( (v22 & 4) != 0 )
            _malloc_assert("_int_malloc");
          if ( v21 >= v22 )
          {
            v28 = v20[1];
            if ( (v28 & 4) != 0 )
              _malloc_assert("_int_malloc");
            while ( v21 < v28 )
            {
              v20 = (int *)v20[4];
              v28 = v20[1];
              if ( (v28 & 4) != 0 )
                _malloc_assert("_int_malloc");
            }
            if ( v21 == v28 )
            {
              v11 = (int *)v20[2];
            }
            else
            {
              v29 = v20[5];
              j[4] = (int)v20;
              v11 = v20;
              j[5] = v29;
              v20[5] = (int)j;
              *(_DWORD *)(j[5] + 16) = j;
            }
            v12 = v11[3];
          }
          else
          {
            v23 = v20[5];
            j[4] = (int)v20;
            j[5] = v23;
            *(_DWORD *)(v23 + 16) = j;
            v20[5] = (int)j;
          }
          goto LABEL_24;
        }
      }
      else
      {
        v18 = 8 * v17 + 496;
        v59 = v17 + 56;
LABEL_34:
        v19 = (int *)((char *)a1 + v18);
        v20 = (int *)*v19;
        v11 = v19 - 2;
        if ( v19 - 2 != (int *)*v19 )
          goto LABEL_35;
      }
      j[5] = (int)j;
      j[4] = (int)j;
      v12 = (int)v11;
      goto LABEL_24;
    }
    v59 = v16 >> 3;
    v11 = (int *)a1[2 * (v16 >> 3) + 12];
    v12 = (int)&a1[2 * (v16 >> 3) + 10];
LABEL_24:
    a1[(v59 >> 5) + 268] |= 1 << v59;
    v13 = v61-- == 1;
    j[3] = v12;
    j[2] = (int)v11;
    v11[3] = (int)j;
    *(_DWORD *)(v12 + 8) = j;
    if ( v13 )
      goto LABEL_65;
  }
  v31 = v16 - v58;
  v32 = (int *)((char *)j + v58);
  a1[14] = (int)j + v58;
  a1[15] = (int)j + v58;
  a1[13] = (int)j + v58;
  v32[2] = v57;
  v32[3] = v57;
  if ( v16 - v58 > 0x1FF )
  {
    v32[4] = 0;
    v32[5] = 0;
  }
  v25 = (int)(j + 2);
  *(_DWORD *)(v25 - 4) = (4 * (a1 != &main_arena)) | v58 | 1;
  v32[1] = v31 | 1;
  *(_DWORD *)(v25 + v16 - 8) = v31;
  v24 = perturb_byte;
  if ( perturb_byte )
  {
LABEL_59:
    LOBYTE(v24) = ~(_BYTE)v24;
    j_memset(v25, v24, a2);
  }
  return v25;
}
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80EB4CC: using guessed type int check_action;
// 80EB520: using guessed type int main_arena;
// 80EC514: using guessed type int perturb_byte;
// 80EC518: using guessed type int global_max_fast;

//----- (08058E30) --------------------------------------------------------
_DWORD *__usercall int_memalign@<eax>(int *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>)
{
  unsigned int v3; // ecx
  unsigned int v4; // esi
  unsigned int v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // ebp
  int v9; // eax
  _DWORD *v10; // edi
  unsigned int v11; // eax
  int v12; // edx
  _DWORD *v13; // ebx
  int v14; // eax
  unsigned int v16; // eax
  unsigned int v18; // [esp+8h] [ebp-20h]

  if ( a3 > 0xFFFFFFDF )
  {
    __writegsdword(0xFFFFFFE8, 0xCu);
    return 0;
  }
  v3 = a3 + 11;
  v4 = v3 & 0xFFFFFFF8;
  if ( v3 < 0x10 )
    v4 = 16;
  v6 = int_malloc(a1, v4 + a2 + 16);
  v7 = v6;
  if ( !v6 )
    return 0;
  v8 = v6 - 8;
  if ( v6 % a2 )
  {
    v9 = (-a2 & (v6 + a2 - 1)) - 8;
    v10 = (_DWORD *)(v9 + a2);
    if ( v9 - v8 > 0xF )
      v10 = (_DWORD *)((-a2 & (v7 + a2 - 1)) - 8);
    v11 = (unsigned int)v10 - v8;
    v18 = (*(_DWORD *)(v7 - 4) & 0xFFFFFFF8) - ((_DWORD)v10 - v8);
    if ( (*(_DWORD *)(v7 - 4) & 2) != 0 )
    {
      *v10 = *(_DWORD *)(v7 - 8) + v11;
      v10[1] = v18 | 2;
      return v10 + 2;
    }
    v12 = 4;
    if ( a1 == &main_arena )
      v12 = 0;
    v10[1] = v12 | v18 | 1;
    *(_DWORD *)((char *)v10 + v18 + 4) |= 1u;
    *(_DWORD *)(v7 - 4) = v12 | *(_DWORD *)(v7 - 4) & 7 | v11;
    int_free((int)a1, v8, 1);
    if ( v4 > v18 || (unsigned int)(v10 + 2) % a2 )
      _malloc_assert("_int_memalign");
    v8 = (unsigned int)v10;
    v13 = v10 + 2;
    v14 = v10[1];
    if ( (v14 & 2) != 0 )
      return v13;
    goto LABEL_17;
  }
  v14 = *(_DWORD *)(v8 + 4);
  v13 = (_DWORD *)v7;
  if ( (v14 & 2) == 0 )
  {
LABEL_17:
    v16 = v14 & 0xFFFFFFF8;
    if ( v16 > v4 + 16 )
    {
      *(_DWORD *)(v8 + v4 + 4) = (4 * (a1 != &main_arena)) | (v16 - v4) | 1;
      *(_DWORD *)(v8 + 4) = *(_DWORD *)(v8 + 4) & 7 | v4;
      int_free((int)a1, v8 + v4, 1);
    }
  }
  return v13;
}
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80EB520: using guessed type int main_arena;

//----- (08058FF0) --------------------------------------------------------
int __cdecl malloc_check(unsigned int a1)
{
  bool v2; // zf
  int v3; // eax
  int v4; // ecx

  if ( a1 == -1 )
  {
    __writegsdword(0xFFFFFFE8, 0xCu);
    return 0;
  }
  else
  {
    _ECX = 1;
    v2 = __readgsdword(0xCu) == 0;
    if ( !v2 )
      __asm { lock }
    __asm { cmpxchg main_arena, ecx }
    if ( !v2 )
      _lll_lock_wait_private(0, &main_arena);
    v3 = top_check();
    v4 = 0;
    if ( v3 >= 0 )
      v4 = int_malloc(&main_arena, a1 + 1);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --main_arena )
      _lll_unlock_wake_private(&main_arena);
    return mem2mem_check(v4, a1);
  }
}
// 8059064: variable 'v4' is possibly undefined
// 80EB520: using guessed type int main_arena;

//----- (08059090) --------------------------------------------------------
int __cdecl memalign_check(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // ebx
  bool v4; // zf
  int v5; // eax
  _DWORD *v6; // ecx

  if ( a1 <= 8 )
    return malloc_check(a2);
  if ( a1 > 0xF )
  {
    if ( a1 > 0x80000000 )
    {
      __writegsdword(0xFFFFFFE8, 0x16u);
      return 0;
    }
    if ( a2 <= -17 - a1 )
    {
      if ( (a1 & (a1 - 1)) != 0 )
      {
        v2 = 16;
        if ( a1 != 16 )
        {
          do
            v2 *= 2;
          while ( a1 > v2 );
        }
      }
      else
      {
        v2 = a1;
      }
      goto LABEL_5;
    }
LABEL_25:
    __writegsdword(0xFFFFFFE8, 0xCu);
    return 0;
  }
  if ( a2 > 0xFFFFFFDF )
    goto LABEL_25;
  v2 = 16;
LABEL_5:
  _ECX = 1;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg main_arena, ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, &main_arena);
  v5 = top_check();
  v6 = 0;
  if ( v5 >= 0 )
    v6 = int_memalign(&main_arena, v2, a2 + 1);
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
    _lll_unlock_wake_private(&main_arena);
  return mem2mem_check((int)v6, a2);
}
// 8059127: variable 'v6' is possibly undefined
// 80EB520: using guessed type int main_arena;

//----- (080591C0) --------------------------------------------------------
void __cdecl free_check(unsigned int a1)
{
  bool v2; // zf
  unsigned int v3; // eax
  int v4; // ecx
  unsigned int v5; // edx

  if ( a1 )
  {
    _ECX = 1;
    v2 = __readgsdword(0xCu) == 0;
    if ( !v2 )
      __asm { lock }
    __asm { cmpxchg main_arena, ecx }
    if ( !v2 )
      _lll_lock_wait_private(0, &main_arena);
    v3 = mem2chunk_check(a1, 0);
    v5 = v3;
    if ( v3 )
    {
      if ( (*(_BYTE *)(v3 + 4) & 2) != 0 )
      {
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --main_arena )
          _lll_unlock_wake_private(&main_arena);
        munmap_chunk(v4, v5);
      }
      else
      {
        int_free((int)&main_arena, v3, 1);
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --main_arena )
          _lll_unlock_wake_private(&main_arena);
      }
    }
    else
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --main_arena )
        _lll_unlock_wake_private(&main_arena);
      malloc_printerr(check_action, "free(): invalid pointer", a1, (int)&main_arena);
    }
  }
}
// 8059265: variable 'v4' is possibly undefined
// 8059265: variable 'v5' is possibly undefined
// 8056FF0: using guessed type int __fastcall munmap_chunk(_DWORD, _DWORD);
// 80EB4CC: using guessed type int check_action;
// 80EB520: using guessed type int main_arena;

//----- (080592B0) --------------------------------------------------------
unsigned int __usercall int_realloc@<eax>(int *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, unsigned int a4)
{
  unsigned int v6; // eax
  _DWORD *v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // edx
  int v10; // edx
  int v11; // edi
  int v13; // edx
  int v14; // edx
  int v15; // eax
  unsigned int v16; // eax
  int v17; // edi
  unsigned int v18; // edx
  const char *v19; // edx
  unsigned int v20; // edi
  int v21; // eax
  int v22; // edx
  unsigned int v23; // ebp
  unsigned int v24; // [esp+0h] [ebp-2Ch]
  unsigned int v25; // [esp+0h] [ebp-2Ch]
  int v26; // [esp+4h] [ebp-28h]
  int v27; // [esp+8h] [ebp-24h]
  _DWORD *v28; // [esp+Ch] [ebp-20h]

  v6 = *(_DWORD *)(a2 + 4);
  LOBYTE(v26) = v6;
  if ( v6 <= 8 || a1[275] <= a3 )
  {
    v19 = "realloc(): invalid old size";
LABEL_38:
    malloc_printerr(check_action, v19, a2 + 8, (int)a1);
    return 0;
  }
  v27 = v6 & 2;
  if ( (v6 & 2) != 0 )
    _malloc_assert("_int_realloc");
  v7 = (_DWORD *)(a2 + a3);
  v8 = *(_DWORD *)(a2 + a3 + 4);
  v9 = v8 & 0xFFFFFFF8;
  if ( a1[275] <= (v8 & 0xFFFFFFF8) || v8 <= 8 )
  {
    v19 = "realloc(): invalid next size";
    goto LABEL_38;
  }
  if ( a3 >= a4 )
  {
LABEL_7:
    if ( a3 - a4 > 0xF )
    {
      v17 = 4;
      v18 = a2 + a4;
      if ( a1 == &main_arena )
        v17 = v27;
      *(_DWORD *)(a2 + 4) = v17 | a4 | v26 & 7;
      *(_DWORD *)(v18 + 4) = v17 | (a3 - a4) | 1;
      v7[1] |= 1u;
      int_free((int)a1, v18, 1);
    }
    else
    {
      v10 = 4;
      if ( a1 == &main_arena )
        v10 = v27;
      *(_DWORD *)(a2 + 4) = v10 | v26 & 7 | a3;
      v7[1] |= 1u;
    }
    return a2 + 8;
  }
  if ( v7 == (_DWORD *)a1[12] )
  {
    v20 = a3 + v9;
    if ( a3 + v9 >= a4 + 16 )
    {
      v21 = v6 & 7;
      v22 = 4;
      if ( a1 == &main_arena )
        v22 = v27;
      *(_DWORD *)(a2 + 4) = v22 | a4 | v21;
      a1[12] = a2 + a4;
      v23 = v20 - a4;
      v11 = a2 + 8;
      *(_DWORD *)(a2 + a4 + 4) = v23 | 1;
      return v11;
    }
  }
  else if ( (*((_BYTE *)v7 + v9 + 4) & 1) == 0 )
  {
    v24 = a3 + v9;
    if ( a4 <= a3 + v9 )
    {
      v13 = v7[3];
      v28 = (_DWORD *)v7[2];
      if ( v7 == (_DWORD *)v28[3] && v7 == *(_DWORD **)(v13 + 8) )
      {
        v28[3] = v13;
        *(_DWORD *)(v13 + 8) = v28;
        if ( v8 > 0x1FF )
        {
          v14 = v7[4];
          if ( v14 )
          {
            if ( v7 != *(_DWORD **)(v14 + 20) || v7 != *(_DWORD **)(v7[5] + 16) )
            {
              malloc_printerr(check_action, "corrupted double-linked list (not small)", (unsigned int)v7, (int)a1);
              v14 = v7[4];
              v6 = *(_DWORD *)(a2 + 4);
            }
            if ( v28[4] )
            {
              LOBYTE(v26) = v6;
              *(_DWORD *)(v14 + 20) = v7[5];
              *(_DWORD *)(v7[5] + 16) = v14;
            }
            else
            {
              LOBYTE(v26) = v6;
              if ( v7 == (_DWORD *)v14 )
              {
                v28[5] = v28;
                v28[4] = v28;
              }
              else
              {
                v28[4] = v14;
                v28[5] = v7[5];
                *(_DWORD *)(v7[4] + 20) = v28;
                *(_DWORD *)(v7[5] + 16) = v28;
              }
            }
          }
        }
      }
      else
      {
        malloc_printerr(check_action, "corrupted double-linked list", (unsigned int)v7, (int)a1);
        v26 = *(_DWORD *)(a2 + 4);
      }
      v7 = (_DWORD *)(a2 + v24);
      a3 = v24;
      goto LABEL_7;
    }
  }
  v25 = a3;
  v15 = int_malloc(a1, a4 - 7);
  v11 = v15;
  if ( !v15 )
    return v11;
  if ( v7 == (_DWORD *)(v15 - 8) )
  {
    a3 = (*(_DWORD *)(v15 - 4) & 0xFFFFFFF8) + v25;
    if ( a4 > a3 )
      _malloc_assert("_int_realloc");
    v7 = (_DWORD *)(a2 + a3);
    v26 = *(_DWORD *)(a2 + 4);
    goto LABEL_7;
  }
  v16 = (v25 - 4) >> 2;
  if ( v16 <= 2 )
    _malloc_assert("_int_realloc");
  if ( v16 > 9 )
  {
    memcpy((_BYTE *)v11, (_BYTE *)(a2 + 8), v25 - 4);
  }
  else
  {
    *(_DWORD *)v11 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(v11 + 4) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(v11 + 8) = *(_DWORD *)(a2 + 16);
    if ( v16 > 4 )
    {
      *(_DWORD *)(v11 + 12) = *(_DWORD *)(a2 + 20);
      *(_DWORD *)(v11 + 16) = *(_DWORD *)(a2 + 24);
      if ( v16 > 6 )
      {
        *(_DWORD *)(v11 + 20) = *(_DWORD *)(a2 + 28);
        *(_DWORD *)(v11 + 24) = *(_DWORD *)(a2 + 32);
        if ( v16 == 9 )
        {
          *(_DWORD *)(v11 + 28) = *(_DWORD *)(a2 + 36);
          *(_DWORD *)(v11 + 32) = *(_DWORD *)(a2 + 40);
        }
      }
    }
  }
  int_free((int)a1, a2, 1);
  return v11;
}
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80EB4CC: using guessed type int check_action;
// 80EB520: using guessed type int main_arena;

//----- (08059680) --------------------------------------------------------
int __cdecl realloc_check(_BYTE *a1, unsigned int a2)
{
  int v2; // esi
  bool v4; // zf
  int *v5; // ebp
  unsigned int v7; // eax
  int v8; // edx
  bool v9; // zf
  int *v10; // eax
  _BYTE *v12; // ebx
  int v13; // edx
  int v14; // ecx
  unsigned int v15; // [esp+4h] [ebp-38h]
  unsigned int v16; // [esp+8h] [ebp-34h]
  char *v17; // [esp+1Ch] [ebp-20h] BYREF

  v2 = (int)a1;
  if ( a2 == -1 )
    goto LABEL_32;
  if ( !a1 )
    return malloc_check(a2);
  if ( !a2 )
  {
    free_check((unsigned int)a1);
    return 0;
  }
  _ECX = 1;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg main_arena, ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, &main_arena);
  v5 = (int *)mem2chunk_check((int)a1, &v17);
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
    _lll_unlock_wake_private(&main_arena);
  if ( !v5 )
  {
    malloc_printerr(check_action, "realloc(): invalid pointer", (unsigned int)a1, (int)&main_arena);
    return malloc_check(a2);
  }
  v15 = v5[1] & 0xFFFFFFF8;
  if ( a2 + 1 > 0xFFFFFFDF )
  {
LABEL_32:
    __writegsdword(0xFFFFFFE8, 0xCu);
    return 0;
  }
  _ECX = 1;
  v7 = 16;
  if ( a2 + 12 >= 0x10 )
    v7 = (a2 + 12) & 0xFFFFFFF8;
  v8 = v7;
  v16 = v7;
  v9 = __readgsdword(0xCu) == 0;
  if ( !v9 )
    __asm { lock }
  __asm { cmpxchg main_arena, ecx }
  if ( !v9 )
    _lll_lock_wait_private(0, &main_arena);
  if ( (v5[1] & 2) != 0 )
  {
    v10 = mremap_chunk(v5, v8);
    if ( !v10 )
    {
      if ( v16 <= v15 - 4 )
        goto LABEL_24;
      if ( top_check() >= 0 )
      {
        v12 = (_BYTE *)int_malloc(&main_arena, a2 + 1);
        if ( v12 )
        {
          v2 = (int)v12;
          memcpy(v12, a1, v15 - 8);
          munmap_chunk(v14, v13);
          goto LABEL_24;
        }
      }
      goto LABEL_31;
    }
    v2 = (int)(v10 + 2);
  }
  else
  {
    if ( top_check() < 0 )
      goto LABEL_31;
    v2 = int_realloc(&main_arena, (unsigned int)v5, v15, v16);
  }
  if ( !v2 )
  {
LABEL_31:
    v2 = 0;
    *v17 = ~*v17;
  }
LABEL_24:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
    _lll_unlock_wake_private(&main_arena);
  return mem2mem_check(v2, a2);
}
// 8059765: variable 'v8' is possibly undefined
// 805986C: variable 'v14' is possibly undefined
// 805986C: variable 'v13' is possibly undefined
// 8056FF0: using guessed type int __fastcall munmap_chunk(_DWORD, _DWORD);
// 80EB4CC: using guessed type int check_action;
// 80EB520: using guessed type int main_arena;

//----- (080598D0) --------------------------------------------------------
int *__usercall arena_get2_part_4@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>)
{
  int v4; // eax
  unsigned int v5; // ecx
  bool v10; // zf
  unsigned int v12; // edx
  bool v13; // zf
  int v14; // eax
  int v15; // edx
  int *v16; // eax
  int v17; // eax
  int nprocs; // eax
  int *v21; // eax
  int v22; // eax
  _DWORD *v23; // esi
  int v24; // edx
  int v25; // eax
  int v26; // edx
  unsigned int v28; // edi
  bool v29; // zf
  bool v31; // zf
  int v32; // eax
  bool v34; // zf
  int v35; // [esp+Ch] [ebp-20h]

  v4 = narenas_limit_10628;
  if ( narenas_limit_10628 )
    goto LABEL_4;
  v4 = dword_80EB4F0;
  if ( dword_80EB4F0 )
  {
LABEL_3:
    narenas_limit_10628 = v4;
LABEL_4:
    v5 = narenas;
    goto LABEL_5;
  }
  v5 = narenas;
  if ( dword_80EB4EC < (unsigned int)narenas )
  {
    v35 = a2;
    nprocs = get_nprocs(narenas, a3);
    a2 = v35;
    if ( nprocs > 0 )
    {
      v4 = 2 * nprocs;
      goto LABEL_3;
    }
    narenas_limit_10628 = 4;
    v5 = narenas;
    v4 = 4;
  }
LABEL_5:
  if ( v4 - 1 >= v5 )
  {
    _ESI = v5 + 1;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    __asm { cmpxchg narenas, esi }
    v22 = new_heap(a1 + 1132, dword_80EB4E4);
    v23 = (_DWORD *)v22;
    if ( !v22 )
    {
      v23 = (_DWORD *)new_heap(0x46Cu, dword_80EB4E4);
      if ( !v23 )
        goto LABEL_92;
    }
    _EBX = v23 + 4;
    *v23 = v23 + 4;
    malloc_init_state(v23 + 4);
    v24 = (int)(v23 + 281);
    v25 = v23[2];
    v23[278] = 1;
    v23[280] = v25;
    v23[279] = v25;
    if ( (((_BYTE)v23 + 108) & 7) != 0 )
      v24 = (int)v23 - (((_BYTE)v23 + 108) & 7) + 1132;
    v23[16] = v24;
    *(_DWORD *)(v24 + 4) = ((unsigned int)v23 + v25 - v24) | 1;
    v26 = 1;
    v23[4] = 0;
    _ECX = 1;
    v28 = __readgsdword(0xFFFFFFEC);
    __writegsdword(0xFFFFFFEC, (unsigned int)_EBX);
    v29 = __readgsdword(0xCu) == 0;
    if ( !v29 )
      __asm { lock }
    __asm { cmpxchg ds:list_lock, ecx }
    if ( !v29 )
      _lll_lock_wait_private(0, &list_lock);
    v23[276] = off_80EB960;
    off_80EB960 = v23 + 4;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_lock )
      _lll_unlock_wake_private(&list_lock);
    _ECX = v26;
    v31 = __readgsdword(0xCu) == 0;
    if ( !v31 )
      __asm { lock }
    __asm { cmpxchg ds:free_list_lock, ecx }
    if ( !v31 )
      _lll_lock_wait_private(0, &free_list_lock);
    if ( v28 )
    {
      v32 = *(_DWORD *)(v28 + 1096);
      if ( !v32 )
        goto LABEL_89;
      *(_DWORD *)(v28 + 1096) = v32 - 1;
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --free_list_lock )
      _lll_unlock_wake_private(&free_list_lock);
    _ECX = 1;
    v34 = __readgsdword(0xCu) == 0;
    if ( !v34 )
      __asm { lock }
    __asm { cmpxchg [ebx], ecx }
    if ( !v34 )
      _lll_lock_wait_private(0, v23 + 4);
    if ( v23 == (_DWORD *)-16 )
    {
LABEL_92:
      if ( __readgsdword(0xCu) )
        __asm { lock }
      --narenas;
      return 0;
    }
    return _EBX;
  }
  _EBX = (int *)next_to_use_10602;
  if ( !next_to_use_10602 )
  {
    next_to_use_10602 = (int)&main_arena;
    _EBX = &main_arena;
  }
  _ECX = 1;
  do
  {
    if ( (_EBX[1] & 4) == 0 )
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      __asm { cmpxchg [ebx], ecx }
      goto LABEL_25;
    }
    _EBX = (int *)_EBX[272];
  }
  while ( _EBX != (int *)next_to_use_10602 );
  if ( (int *)a2 == _EBX )
    _EBX = *(int **)(a2 + 1088);
  _ESI = _EBX;
  while ( 2 )
  {
    if ( (_ESI[1] & 4) == 0 && (int *)a2 != _ESI )
    {
      _ECX = 1;
      v10 = __readgsdword(0xCu) == 0;
      if ( !v10 )
        __asm { lock }
      __asm { cmpxchg [esi], ecx }
      if ( !v10 )
        _lll_lock_wait_private(0, _ESI);
      _EBX = _ESI;
LABEL_25:
      _ECX = 1;
      v12 = __readgsdword(0xFFFFFFEC);
      v13 = __readgsdword(0xCu) == 0;
      if ( !v13 )
        __asm { lock }
      __asm { cmpxchg ds:free_list_lock, ecx }
      if ( !v13 )
        _lll_lock_wait_private(0, &free_list_lock);
      if ( !v12 )
        goto LABEL_32;
      v14 = *(_DWORD *)(v12 + 1096);
      if ( v14 )
      {
        *(_DWORD *)(v12 + 1096) = v14 - 1;
LABEL_32:
        v15 = free_list;
        if ( free_list )
        {
          if ( *(_DWORD *)(free_list + 1096) )
LABEL_86:
            _malloc_assert("remove_from_free_list");
          if ( _EBX == (int *)free_list )
          {
            v21 = &free_list;
LABEL_51:
            *v21 = *(_DWORD *)(v15 + 1092);
          }
          else
          {
            while ( 1 )
            {
              v16 = *(int **)(v15 + 1092);
              if ( !v16 )
                break;
              if ( v16[274] )
                goto LABEL_86;
              if ( _EBX == v16 )
              {
                v21 = (int *)(v15 + 1092);
                v15 = (int)_EBX;
                goto LABEL_51;
              }
              v15 = *(_DWORD *)(v15 + 1092);
            }
          }
        }
        ++_EBX[274];
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --free_list_lock )
          _lll_unlock_wake_private(&free_list_lock);
        v17 = _EBX[272];
        __writegsdword(0xFFFFFFEC, (unsigned int)_EBX);
        next_to_use_10602 = v17;
        return _EBX;
      }
LABEL_89:
      detach_arena_part_2();
    }
    _ESI = (int *)_ESI[272];
    if ( _ESI != _EBX )
      continue;
    return 0;
  }
}
// 8059938: conditional instruction was optimized away because eax.4==0
// 80599C1: variable 'v12' is possibly undefined
// 8059BF6: variable 'v26' is possibly undefined
// 80483BC: using guessed type void __noreturn detach_arena_part_2(void);
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80EB4C8: using guessed type int narenas;
// 80EB4E4: using guessed type int dword_80EB4E4;
// 80EB4EC: using guessed type int dword_80EB4EC;
// 80EB4F0: using guessed type int dword_80EB4F0;
// 80EB520: using guessed type int main_arena;
// 80EB960: using guessed type int *off_80EB960;
// 80EC4F4: using guessed type int next_to_use_10602;
// 80EC4F8: using guessed type int narenas_limit_10628;
// 80EC508: using guessed type int list_lock;
// 80EC50C: using guessed type int free_list;
// 80EC510: using guessed type int free_list_lock;

//----- (08059CD0) --------------------------------------------------------
int *__usercall arena_get_retry@<eax>(int *a1@<eax>)
{
  bool v2; // zf
  int *result; // eax

  if ( a1 == &main_arena )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --main_arena )
      _lll_unlock_wake_private(&main_arena);
    result = (int *)get_free_list();
    if ( !result )
      return (int *)arena_get2_part_4();
  }
  else
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v2 = (*a1)-- == 1;
    if ( !v2 )
      _lll_unlock_wake_private(a1);
    if ( (dword_80EB524 & 4) != 0 )
    {
      return 0;
    }
    else
    {
      _ECX = 1;
      v2 = __readgsdword(0xCu) == 0;
      if ( !v2 )
        __asm { lock }
      __asm { cmpxchg main_arena, ecx }
      if ( !v2 )
        _lll_lock_wait_private(dword_80EB524 & 4, &main_arena);
      return &main_arena;
    }
  }
  return result;
}
// 80598D0: using guessed type int arena_get2_part_4(void);
// 80EB520: using guessed type int main_arena;
// 80EB524: using guessed type int dword_80EB524;

//----- (08059D80) --------------------------------------------------------
__int32 _malloc_fork_lock_parent()
{
  __int32 result; // eax
  bool v2; // zf
  bool v5; // zf

  result = _libc_malloc_initialized;
  if ( _libc_malloc_initialized > 0 )
  {
    _ECX = 1;
    v2 = __readgsdword(0xCu) == 0;
    if ( !v2 )
      __asm { lock }
    __asm { cmpxchg ds:list_lock, ecx }
    if ( !v2 )
      _lll_lock_wait_private(0, &list_lock);
    _EDX = &main_arena;
    do
    {
      result = 0;
      _ECX = 1;
      v5 = __readgsdword(0xCu) == 0;
      if ( !v5 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v5 )
        result = _lll_lock_wait_private(0, _EDX);
      _EDX = (int *)_EDX[272];
    }
    while ( _EDX != &main_arena );
  }
  return result;
}
// 8059DDB: variable '_EDX' is possibly undefined
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EB520: using guessed type int main_arena;
// 80EC508: using guessed type int list_lock;

//----- (08059DF0) --------------------------------------------------------
int _malloc_fork_unlock_parent()
{
  int result; // eax
  int *v1; // edx

  result = _libc_malloc_initialized;
  if ( _libc_malloc_initialized > 0 )
  {
    v1 = &main_arena;
    do
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( (*v1)-- != 1 )
        result = _lll_unlock_wake_private(v1);
      v1 = (int *)v1[272];
    }
    while ( v1 != &main_arena );
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_lock )
      return _lll_unlock_wake_private(&list_lock);
  }
  return result;
}
// 8059E17: variable 'v1' is possibly undefined
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EB520: using guessed type int main_arena;
// 80EC508: using guessed type int list_lock;

//----- (08059E50) --------------------------------------------------------
int *_malloc_fork_unlock_child()
{
  int *result; // eax
  unsigned int v1; // ecx
  char v2; // bl
  int v3; // edx

  result = (int *)_libc_malloc_initialized;
  if ( _libc_malloc_initialized > 0 )
  {
    free_list_lock = 0;
    v1 = __readgsdword(0xFFFFFFEC);
    if ( v1 )
      *(_DWORD *)(v1 + 1096) = 1;
    free_list = 0;
    v2 = 0;
    v3 = 0;
    result = &main_arena;
    do
    {
      *result = 0;
      if ( result != (int *)v1 )
      {
        result[273] = v3;
        result[274] = 0;
        v3 = (int)result;
        v2 = 1;
      }
      result = (int *)result[272];
    }
    while ( result != &main_arena );
    if ( v2 )
      free_list = v3;
    list_lock = 0;
  }
  return result;
}
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EB520: using guessed type int main_arena;
// 80EC508: using guessed type int list_lock;
// 80EC50C: using guessed type int free_list;
// 80EC510: using guessed type int free_list_lock;

//----- (08059EE0) --------------------------------------------------------
int _malloc_check_init()
{
  int result; // eax

  result = disallow_malloc_check;
  if ( disallow_malloc_check )
  {
    disallow_malloc_check = 0;
  }
  else
  {
    using_malloc_checking = 1;
    _malloc_hook = (int (__cdecl *)(int))malloc_check;
    _free_hook = (int (__cdecl *)(_DWORD, _DWORD))free_check;
    _realloc_hook = (int (__cdecl *)(int, int))realloc_check;
    _memalign_hook = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))memalign_check;
  }
  return result;
}
// 80EB4D0: using guessed type int (__cdecl *_memalign_hook)(_DWORD, _DWORD, _DWORD);
// 80EB4D4: using guessed type int (__cdecl *_realloc_hook)(int, int);
// 80EB4D8: using guessed type int (__cdecl *_malloc_hook)(int);
// 80EC4F0: using guessed type int (__cdecl *_free_hook)(_DWORD, _DWORD);
// 80EC4FC: using guessed type int disallow_malloc_check;
// 80EC500: using guessed type int using_malloc_checking;

//----- (08059F30) --------------------------------------------------------
int __cdecl malloc_set_state(_DWORD *a1)
{
  unsigned int v1; // ebx
  int v2; // edx
  unsigned int v3; // edx
  _DWORD *v4; // eax
  unsigned int v6; // esi
  _DWORD *v7; // eax
  unsigned int v8; // edx
  unsigned int v9; // ecx

  if ( *a1 != 1145849153 )
    return -1;
  if ( (int)a1[1] >= 0 && (a1[1] & 0xFFFFFF00) != 0 )
    return -2;
  v1 = a1[260];
  v2 = a1[261];
  _malloc_hook = 0;
  _realloc_hook = 0;
  _free_hook = 0;
  _memalign_hook[0] = 0;
  v3 = v1 + v2;
  using_malloc_checking = 0;
  if ( v1 >= v3 )
    return 0;
  v4 = (_DWORD *)v1;
  while ( !*v4 )
  {
    if ( v3 <= (unsigned int)++v4 )
      return 0;
  }
  v6 = a1[4];
  v7 = v4 - 1;
  if ( (unsigned int)v7 < v6 )
  {
    do
    {
      v8 = v7[1] & 0xFFFFFFF8;
      v9 = (unsigned int)v7 + v8;
      if ( (*((_BYTE *)v7 + v8 + 4) & 1) != 0 )
        v7[1] = v8 | 2;
      v7 = (_DWORD *)((char *)v7 + v8);
    }
    while ( v6 > v9 );
  }
  dumped_main_arena_start = v1;
  dumped_main_arena_end = v6;
  return 0;
}
// 80EB4D0: using guessed type int (__cdecl *_memalign_hook[2])(int, int);
// 80EB4D4: using guessed type int (__cdecl *_realloc_hook)(int, int);
// 80EB4D8: using guessed type int (__cdecl *_malloc_hook)(int);
// 80EC4F0: using guessed type int _free_hook;
// 80EC500: using guessed type int using_malloc_checking;
// 80EC51C: using guessed type int dumped_main_arena_end;
// 80EC520: using guessed type int dumped_main_arena_start;

//----- (0805A010) --------------------------------------------------------
int __usercall malloc@<eax>(long double a1@<st0>, unsigned int a2)
{
  int *free_list; // eax
  int v4; // edx
  int v5; // eax
  int *v6; // ecx
  bool v9; // zf

  if ( _malloc_hook )
    return _malloc_hook(a2);
  _EBX = (int *)__readgsdword(0xFFFFFFEC);
  if ( _EBX && (_EBX[1] & 4) == 0 )
  {
    _ECX = 1;
    v9 = __readgsdword(0xCu) == 0;
    if ( !v9 )
      __asm { lock }
    __asm { cmpxchg [ebx], ecx }
    if ( !v9 )
      _lll_lock_wait_private(0, _EBX);
    v4 = int_malloc(_EBX, a2);
    if ( v4 )
      goto LABEL_6;
    goto LABEL_21;
  }
  free_list = (int *)get_free_list();
  _EBX = free_list;
  if ( free_list )
  {
    v4 = int_malloc(free_list, a2);
    if ( v4 )
    {
LABEL_6:
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v9 = (*_EBX)-- == 1;
      if ( !v9 )
        _lll_unlock_wake_private(_EBX);
      goto LABEL_10;
    }
    goto LABEL_21;
  }
  _EBX = arena_get2_part_4(a2, 0, a1);
  v4 = int_malloc(_EBX, a2);
  if ( !v4 && _EBX )
  {
LABEL_21:
    _EBX = arena_get_retry(_EBX);
    v4 = int_malloc(_EBX, a2);
  }
  if ( _EBX )
    goto LABEL_6;
LABEL_10:
  if ( v4 )
  {
    v5 = *(_DWORD *)(v4 - 4);
    if ( (v5 & 2) == 0 )
    {
      v6 = &main_arena;
      if ( (v5 & 4) != 0 )
        v6 = *(int **)((v4 - 8) & 0xFFF00000);
      if ( v6 != _EBX )
        _malloc_assert("__libc_malloc");
    }
  }
  return v4;
}
// 805A071: variable 'v4' is possibly undefined
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80EB4D8: using guessed type int (__cdecl *_malloc_hook)(int);
// 80EB520: using guessed type int main_arena;

//----- (0805A150) --------------------------------------------------------
_DWORD *__usercall malloc_get_state@<eax>(long double a1@<st0>)
{
  int v1; // eax
  _DWORD *v2; // ebx
  bool v4; // zf
  int v5; // eax
  int *v6; // ecx
  int v7; // edx
  int v8; // eax
  int *v9; // eax
  int v10; // eax

  v1 = malloc(a1, 0x458u);
  if ( !v1 )
    return 0;
  v2 = (_DWORD *)v1;
  _ECX = 1;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg main_arena, ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, &main_arena);
  malloc_consolidate(&main_arena);
  v5 = dword_80EB550;
  *v2 = 1145849153;
  v6 = &dword_80EB550;
  v2[1] = 5;
  v2[2] = 0;
  v7 = 2;
  v2[3] = 0;
  v2[5] = 0;
  v2[4] = v5;
  do
  {
    while ( 1 )
    {
      v9 = (int *)v6[2];
      if ( v6 == v9 )
        break;
      v2[2 * v7 + 2] = v9;
      v8 = v6[3];
      v6 += 2;
      v2[2 * v7++ + 3] = v8;
      if ( v7 == 129 )
        goto LABEL_10;
    }
    v2[2 * v7 + 3] = 0;
    v2[2 * v7++ + 2] = 0;
    v6 += 2;
  }
  while ( v7 != 129 );
LABEL_10:
  v2[260] = dword_80EB50C;
  v2[261] = dword_80EB96C;
  v2[262] = mp_;
  v2[263] = dword_80EB4E4;
  v2[264] = dword_80EB4F8;
  v2[265] = dword_80EB4E8;
  v2[266] = check_action;
  v10 = dword_80EB970;
  v2[268] = 0;
  v2[267] = v10;
  v2[269] = dword_80EB4F4;
  v2[270] = dword_80EB4FC;
  v2[271] = dword_80EB504;
  v2[272] = dword_80EB508;
  v2[273] = using_malloc_checking;
  v2[274] = global_max_fast;
  v2[275] = dword_80EB4EC;
  v2[276] = dword_80EB4F0;
  v2[277] = narenas;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
    _lll_unlock_wake_private(&main_arena);
  return v2;
}
// 80EB4C8: using guessed type int narenas;
// 80EB4CC: using guessed type int check_action;
// 80EB4E0: using guessed type int mp_;
// 80EB4E4: using guessed type int dword_80EB4E4;
// 80EB4E8: using guessed type int dword_80EB4E8;
// 80EB4EC: using guessed type int dword_80EB4EC;
// 80EB4F0: using guessed type int dword_80EB4F0;
// 80EB4F4: using guessed type int dword_80EB4F4;
// 80EB4F8: using guessed type int dword_80EB4F8;
// 80EB4FC: using guessed type int dword_80EB4FC;
// 80EB504: using guessed type int dword_80EB504;
// 80EB508: using guessed type int dword_80EB508;
// 80EB50C: using guessed type int dword_80EB50C;
// 80EB520: using guessed type int main_arena;
// 80EB550: using guessed type int dword_80EB550;
// 80EB96C: using guessed type int dword_80EB96C;
// 80EB970: using guessed type int dword_80EB970;
// 80EC500: using guessed type int using_malloc_checking;
// 80EC518: using guessed type int global_max_fast;

//----- (0805A310) --------------------------------------------------------
int __usercall mid_memalign@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)
{
  unsigned int v4; // ebx
  bool v7; // zf
  _DWORD *v8; // edx
  int v9; // eax
  int *v10; // ecx

  if ( _memalign_hook )
    return _memalign_hook(a1, a2, a3);
  if ( a1 > 8 )
  {
    if ( a1 <= 0xF )
    {
      v4 = 16;
      goto LABEL_5;
    }
    if ( a1 > 0x80000000 )
    {
      v8 = 0;
      __writegsdword(0xFFFFFFE8, 0x16u);
    }
    else
    {
      if ( a2 <= -17 - a1 )
      {
        if ( (a1 & (a1 - 1)) != 0 )
        {
          v4 = 16;
          if ( a1 != 16 )
          {
            do
              v4 *= 2;
            while ( a1 > v4 );
          }
        }
        else
        {
          v4 = a1;
        }
LABEL_5:
        _ESI = (int *)__readgsdword(0xFFFFFFEC);
        if ( !_ESI || (_ESI[1] & 4) != 0 )
        {
          _ESI = (int *)get_free_list();
          if ( !_ESI )
          {
            _ESI = (int *)arena_get2_part_4();
            v8 = int_memalign(_ESI, v4, a2);
            if ( v8 || !_ESI )
            {
LABEL_32:
              if ( !_ESI )
              {
LABEL_16:
                if ( v8 )
                {
                  v9 = *(v8 - 1);
                  if ( (v9 & 2) == 0 )
                  {
                    v10 = &main_arena;
                    if ( (v9 & 4) != 0 )
                      v10 = *(int **)((unsigned int)(v8 - 2) & 0xFFF00000);
                    if ( v10 != _ESI )
                      _malloc_assert("_mid_memalign");
                  }
                }
                return (int)v8;
              }
LABEL_12:
              if ( __readgsdword(0xCu) )
                __asm { lock }
              v7 = (*_ESI)-- == 1;
              if ( !v7 )
                _lll_unlock_wake_private(_ESI);
              goto LABEL_16;
            }
LABEL_31:
            _ESI = arena_get_retry(_ESI);
            v8 = int_memalign(_ESI, v4, a2);
            goto LABEL_32;
          }
        }
        else
        {
          _ECX = 1;
          v7 = __readgsdword(0xCu) == 0;
          if ( !v7 )
            __asm { lock }
          __asm { cmpxchg [esi], ecx }
          if ( !v7 )
            _lll_lock_wait_private(0, _ESI);
        }
        v8 = int_memalign(_ESI, v4, a2);
        if ( v8 )
          goto LABEL_12;
        goto LABEL_31;
      }
      v8 = 0;
      __writegsdword(0xFFFFFFE8, 0xCu);
    }
    return (int)v8;
  }
  return malloc(a2);
}
// 80EB4D0: invalid function type '?' has been ignored
// 805A338: conditional instruction was optimized away because edx.4==0
// 805A3A9: variable 'v8' is possibly undefined
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80598D0: using guessed type int arena_get2_part_4(void);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80EB4D0: using guessed type int (__cdecl *_memalign_hook)(_DWORD, _DWORD, _DWORD);
// 80EB520: using guessed type int main_arena;

//----- (0805A510) --------------------------------------------------------
_DWORD *__usercall free@<eax>(long double a1@<st0>, int a2)
{
  _DWORD *result; // eax
  unsigned int v3; // edx
  unsigned int v4; // ecx
  int *v5; // eax
  void *retaddr; // [esp+Ch] [ebp+0h]

  result = _free_hook;
  if ( _free_hook )
    return (_DWORD *)_free_hook(a2, retaddr);
  if ( a2 )
  {
    v3 = a2 - 8;
    v4 = *(_DWORD *)(a2 - 4);
    if ( (v4 & 2) != 0 )
    {
      if ( !dword_80EB500
        && v4 > dword_80EB4E8
        && v4 <= 0x80000
        && (v3 < dumped_main_arena_start || v3 >= dumped_main_arena_end) )
      {
        dword_80EB4E8 = v4 & 0xFFFF8;
        mp_ = 2 * (v4 & 0xFFFFFFF8);
      }
      return munmap_chunk((_DWORD *)v3, a1);
    }
    else
    {
      v5 = &main_arena;
      if ( (v4 & 4) != 0 )
        v5 = *(int **)(v3 & 0xFFF00000);
      return (_DWORD *)int_free((int)v5, v3, 0);
    }
  }
  return result;
}
// 80EC4F0: invalid function type '?' has been ignored
// 805A574: mask 0xFFFFFFF8 is shortened because ecx.4 <= 0x80000
// 80EB4E0: using guessed type int mp_;
// 80EB4E8: using guessed type int dword_80EB4E8;
// 80EB500: using guessed type int dword_80EB500;
// 80EB520: using guessed type int main_arena;
// 80EC4F0: using guessed type int (__cdecl *_free_hook)(_DWORD, _DWORD);
// 80EC51C: using guessed type int dumped_main_arena_end;
// 80EC520: using guessed type int dumped_main_arena_start;

//----- (0805A5C0) --------------------------------------------------------
int __cdecl realloc(_BYTE *a1, unsigned int a2)
{
  unsigned int v2; // edi
  int v3; // edx
  unsigned int v4; // ebx
  int v5; // edx
  int *v6; // eax
  _BYTE *v7; // ebp
  bool v11; // zf
  int v12; // eax
  int *v13; // edx
  int v14; // edx
  int v15; // ecx
  unsigned int v16; // [esp+4h] [ebp-28h]
  volatile __int32 *v17; // [esp+8h] [ebp-24h]
  unsigned int v18; // [esp+Ch] [ebp-20h]

  v2 = a2;
  if ( _realloc_hook )
    return _realloc_hook((int)a1, a2);
  if ( !a2 && a1 )
  {
    v7 = 0;
    free(a1);
    return (int)v7;
  }
  if ( !a1 )
    return malloc(a2);
  v3 = *((_DWORD *)a1 - 1);
  v4 = (unsigned int)(a1 - 8);
  v16 = v3 & 0xFFFFFFF8;
  if ( (v3 & 2) != 0 )
  {
    v17 = 0;
  }
  else if ( (v3 & 4) != 0 )
  {
    v17 = *(volatile __int32 **)(v4 & 0xFFF00000);
  }
  else
  {
    v17 = &main_arena;
  }
  if ( (-v16 < v4 || (v4 & 7) != 0) && (v4 < dumped_main_arena_start || v4 >= dumped_main_arena_end) )
  {
    v7 = 0;
    malloc_printerr(check_action, "realloc(): invalid pointer", (unsigned int)a1, (int)v17);
    return (int)v7;
  }
  if ( a2 > 0xFFFFFFDF )
  {
    v7 = 0;
    __writegsdword(0xFFFFFFE8, 0xCu);
    return (int)v7;
  }
  v5 = 16;
  if ( a2 + 11 >= 0x10 )
    v5 = (a2 + 11) & 0xFFFFFFF8;
  v18 = v5;
  if ( (*((_DWORD *)a1 - 1) & 2) == 0 )
  {
    _ECX = 1;
    _EBP = v17;
    v11 = __readgsdword(0xCu) == 0;
    if ( !v11 )
      __asm { lock }
    __asm { cmpxchg [ebp+0], ecx }
    if ( !v11 )
      _lll_lock_wait_private(0, v17);
    v7 = (_BYTE *)int_realloc((int *)v17, (unsigned int)(a1 - 8), v16, v18);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v11 = (*v17)-- == 1;
    if ( !v11 )
      _lll_unlock_wake_private(v17);
    if ( v7 )
    {
      v12 = *((_DWORD *)v7 - 1);
      if ( (v12 & 2) == 0 )
      {
        v13 = &main_arena;
        if ( (v12 & 4) != 0 )
          v13 = *(int **)((unsigned int)(v7 - 8) & 0xFFF00000);
        if ( v17 != v13 )
          _malloc_assert("__libc_realloc");
      }
    }
    else
    {
      v7 = (_BYTE *)malloc(a2);
      if ( v7 )
      {
        memcpy(v7, a1, v16 - 4);
        int_free((int)v17, (unsigned int)(a1 - 8), 0);
      }
    }
    return (int)v7;
  }
  if ( v4 < dumped_main_arena_start || v4 >= dumped_main_arena_end )
  {
    v6 = mremap_chunk((int *)a1 - 2, v5);
    v7 = v6 + 2;
    if ( !v6 )
    {
      v7 = a1;
      if ( v18 > v16 - 4 )
      {
        v7 = (_BYTE *)malloc(a2);
        if ( v7 )
        {
          memcpy(v7, a1, v16 - 8);
          munmap_chunk(v15, v14);
        }
      }
    }
    return (int)v7;
  }
  v7 = (_BYTE *)malloc(a2);
  if ( !v7 )
    return (int)v7;
  if ( v16 - 4 <= a2 )
    v2 = v16 - 4;
  memcpy(v7, a1, v2);
  return (int)v7;
}
// 805A83D: variable 'v15' is possibly undefined
// 805A83D: variable 'v14' is possibly undefined
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 8056FF0: using guessed type int __fastcall munmap_chunk(_DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EB4CC: using guessed type int check_action;
// 80EB4D4: using guessed type int (__cdecl *_realloc_hook)(int, int);
// 80EB520: using guessed type int main_arena;
// 80EC51C: using guessed type int dumped_main_arena_end;
// 80EC520: using guessed type int dumped_main_arena_start;

//----- (0805A8D0) --------------------------------------------------------
int __cdecl memalign(unsigned int a1, unsigned int a2)
{
  int retaddr; // [esp+0h] [ebp+0h]

  return mid_memalign(a1, a2, retaddr);
}

//----- (0805A8E0) --------------------------------------------------------
int __cdecl calloc(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // ebp
  int v4; // ecx
  unsigned int v5; // edi
  int v6; // eax
  _DWORD *v7; // esi
  _DWORD *v8; // ecx
  int v9; // eax
  int v10; // eax
  bool v13; // zf
  unsigned int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // edx
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // [esp+Ch] [ebp-20h]
  _DWORD *v22; // [esp+Ch] [ebp-20h]
  int v23; // [esp+Ch] [ebp-20h]

  v2 = a2 * a1;
  if ( (a2 | a1) > 0xFFFF && a2 && a1 != v2 / a2 )
  {
    v7 = 0;
    __writegsdword(0xFFFFFFE8, 0xCu);
    return (int)v7;
  }
  if ( _malloc_hook )
  {
    v19 = _malloc_hook(a2 * a1);
    if ( v19 )
      return j_memset(v19, 0, v2);
    return 0;
  }
  _EBX = (int *)__readgsdword(0xFFFFFFEC);
  if ( _EBX && (_EBX[1] & 4) == 0 )
  {
    _ECX = 1;
    v13 = __readgsdword(0xCu) == 0;
    if ( !v13 )
      __asm { lock }
    __asm { cmpxchg [ebx], ecx }
    if ( !v13 )
      _lll_lock_wait_private(0, _EBX);
LABEL_8:
    v4 = _EBX[12];
    v5 = *(_DWORD *)(v4 + 4) & 0xFFFFFFF8;
    if ( _EBX == &main_arena )
    {
      v23 = _EBX[12];
      v17 = int_malloc(&main_arena, v2);
      v7 = (_DWORD *)v17;
      v8 = (_DWORD *)v23;
      if ( v17 )
      {
        v18 = *(_DWORD *)(v17 - 4);
        if ( (v18 & 2) == 0 && (v18 & 4) != 0 )
        {
LABEL_14:
          if ( *(int **)((unsigned int)(v7 - 2) & 0xFFF00000) == _EBX )
          {
            if ( !_EBX )
              goto LABEL_21;
            goto LABEL_16;
          }
LABEL_50:
          _malloc_assert("__libc_calloc");
        }
        goto LABEL_16;
      }
    }
    else
    {
      v21 = _EBX[12];
      if ( v5 < *(_DWORD *)((v4 & 0xFFF00000) + 0xC) + (v4 & 0xFFF00000) - v4 )
        v5 = *(_DWORD *)((v4 & 0xFFF00000) + 0xC) + (v4 & 0xFFF00000) - v4;
      v6 = int_malloc(_EBX, v2);
      v7 = (_DWORD *)v6;
      v8 = (_DWORD *)v21;
      if ( v6 )
      {
        v9 = *(_DWORD *)(v6 - 4);
        if ( (v9 & 2) == 0 )
          goto LABEL_13;
LABEL_16:
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v13 = (*_EBX)-- == 1;
        if ( !v13 )
          _lll_unlock_wake_private(_EBX);
LABEL_20:
        if ( v7 )
          goto LABEL_21;
        return 0;
      }
    }
    v22 = v8;
    _EBX = arena_get_retry(_EBX);
    v7 = (_DWORD *)int_malloc(_EBX, v2);
    v8 = v22;
    if ( !_EBX )
      goto LABEL_20;
    goto LABEL_16;
  }
  _EBX = (int *)get_free_list();
  if ( _EBX )
    goto LABEL_8;
  _EBX = (int *)arena_get2_part_4();
  if ( _EBX )
    goto LABEL_8;
  v20 = int_malloc(0, v2);
  v7 = (_DWORD *)v20;
  if ( !v20 )
    return 0;
  v9 = *(_DWORD *)(v20 - 4);
  v5 = v9 & 2;
  if ( (v9 & 2) == 0 )
  {
    v8 = 0;
LABEL_13:
    if ( (v9 & 4) == 0 )
      goto LABEL_50;
    goto LABEL_14;
  }
  v5 = 0;
  v8 = 0;
LABEL_21:
  v10 = *(v7 - 1);
  if ( (v10 & 2) != 0 )
  {
    if ( perturb_byte )
      return j_memset(v7, 0, v2);
  }
  else
  {
    v14 = v10 & 0xFFFFFFF8;
    if ( !perturb_byte && v8 == v7 - 2 && v14 > v5 )
      v14 = v5;
    v15 = v14 - 4;
    v16 = v15 >> 2;
    if ( v15 >> 2 <= 2 )
      _malloc_assert("__libc_calloc");
    if ( v16 > 9 )
    {
      j_memset(v7, 0, v15);
    }
    else
    {
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
      if ( v16 > 4 )
      {
        v7[3] = 0;
        v7[4] = 0;
        if ( v16 > 6 )
        {
          v7[5] = 0;
          v7[6] = 0;
          if ( v16 == 9 )
          {
            v7[7] = 0;
            v7[8] = 0;
          }
        }
      }
    }
  }
  return (int)v7;
}
// 805AA2A: variable 'v8' is possibly undefined
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);
// 8056530: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80598D0: using guessed type int arena_get2_part_4(void);
// 80EB4D8: using guessed type int (__cdecl *_malloc_hook)(int);
// 80EB520: using guessed type int main_arena;
// 80EC514: using guessed type int perturb_byte;

//----- (0805AC20) --------------------------------------------------------
int __cdecl malloc_usable_size(unsigned int a1)
{
  unsigned int v1; // ecx
  unsigned int v2; // ebx
  int v3; // edx
  int result; // eax
  unsigned int v5; // eax
  unsigned int v6; // edx
  int v7; // ebp
  int v8; // edi
  int v9; // edx
  unsigned int v10; // eax
  int *v11; // eax
  unsigned int v12; // [esp+8h] [ebp-24h]

  v1 = a1;
  if ( !a1 )
    return 0;
  v2 = a1 - 8;
  if ( using_malloc_checking == 1 )
  {
    v7 = *(_DWORD *)(a1 - 4);
    v8 = (v2 >> 11) ^ (v2 >> 3);
    if ( ((unsigned __int8)(v2 >> 11) ^ (unsigned __int8)(v2 >> 3)) == 1 )
      LOBYTE(v8) = 2;
    v9 = *(unsigned __int8 *)(a1 + (v7 & 0xFFFFFFF8) + 4 * ((v7 & 2) == 0) - 1 - 8);
    v12 = (v7 & 0xFFFFFFF8) + 4 * ((v7 & 2) == 0) - 1;
    if ( (_BYTE)v9 == (_BYTE)v8 )
    {
      return v12 - 8;
    }
    else
    {
      if ( (_BYTE)v9 && v12 >= v9 + 8 )
      {
        v10 = (v7 & 0xFFFFFFF8) + 4 * ((v7 & 2) == 0) - 1;
        do
        {
          v10 -= v9;
          v9 = *(unsigned __int8 *)(v2 + v10);
          if ( (_BYTE)v9 == (_BYTE)v8 )
          {
            v12 = v10;
            return v12 - 8;
          }
        }
        while ( (_BYTE)v9 && v9 + 8 <= v10 );
        v1 = a1;
      }
      v11 = 0;
      if ( (v7 & 2) == 0 )
      {
        v11 = &main_arena;
        if ( (v7 & 4) != 0 )
          v11 = *(int **)(v2 & 0xFFF00000);
      }
      malloc_printerr(check_action, "malloc_check_get_size: memory corruption", v1, (int)v11);
      return 0;
    }
  }
  else
  {
    v3 = *(_DWORD *)(a1 - 4);
    result = v3 & 2;
    if ( (v3 & 2) != 0 )
    {
      v5 = v3 & 0xFFFFFFF8;
      if ( v2 < dumped_main_arena_start || v2 >= dumped_main_arena_end )
        return v5 - 8;
      else
        return v5 - 4;
    }
    else
    {
      v6 = v3 & 0xFFFFFFF8;
      if ( (*(_BYTE *)(v2 + v6 + 4) & 1) != 0 )
        return v6 - 4;
    }
  }
  return result;
}
// 80EB4CC: using guessed type int check_action;
// 80EB520: using guessed type int main_arena;
// 80EC500: using guessed type int using_malloc_checking;
// 80EC51C: using guessed type int dumped_main_arena_end;
// 80EC520: using guessed type int dumped_main_arena_start;

//----- (0805AD70) --------------------------------------------------------
int __cdecl mallopt(int a1, int a2)
{
  bool v3; // zf
  int v4; // edx
  unsigned int v5; // eax

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_7();
  _ECX = 1;
  v3 = __readgsdword(0xCu) == 0;
  if ( !v3 )
    __asm { lock }
  __asm { cmpxchg main_arena, ecx }
  if ( !v3 )
    _lll_lock_wait_private(0, &main_arena);
  malloc_consolidate(&main_arena);
  switch ( a1 )
  {
    case -8:
      if ( a2 <= 0 )
        goto LABEL_28;
      dword_80EB4F0 = a2;
      v4 = 1;
      break;
    case -7:
      v4 = 1;
      if ( a2 > 0 )
        dword_80EB4EC = a2;
      break;
    case -6:
      perturb_byte = a2;
      v4 = 1;
      break;
    case -5:
      check_action = a2;
      v4 = 1;
      break;
    case -4:
      dword_80EB4F8 = a2;
      dword_80EB500 = 1;
      v4 = 1;
      break;
    case -3:
      v4 = 0;
      if ( (unsigned int)a2 <= 0x80000 )
      {
        dword_80EB4E8 = a2;
        dword_80EB500 = 1;
        v4 = 1;
      }
      break;
    case -2:
      dword_80EB4E4 = a2;
      dword_80EB500 = 1;
      v4 = 1;
      break;
    case -1:
      mp_ = a2;
      dword_80EB500 = 1;
      v4 = 1;
      break;
    case 1:
      v4 = 0;
      if ( (unsigned int)a2 <= 0x50 )
      {
        v5 = (a2 + 4) & 0xFFFFFFF8;
        if ( !a2 )
          v5 = 8;
        v4 = a1;
        global_max_fast = v5;
      }
      break;
    default:
LABEL_28:
      v4 = 1;
      break;
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
    _lll_unlock_wake_private(&main_arena);
  return v4;
}
// 805AE10: variable 'v4' is possibly undefined
// 805AF10: using guessed type int ptmalloc_init_part_7(void);
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EB4CC: using guessed type int check_action;
// 80EB4E0: using guessed type int mp_;
// 80EB4E4: using guessed type int dword_80EB4E4;
// 80EB4E8: using guessed type int dword_80EB4E8;
// 80EB4EC: using guessed type int dword_80EB4EC;
// 80EB4F0: using guessed type int dword_80EB4F0;
// 80EB4F8: using guessed type int dword_80EB4F8;
// 80EB500: using guessed type int dword_80EB500;
// 80EB520: using guessed type int main_arena;
// 80EC514: using guessed type int perturb_byte;
// 80EC518: using guessed type int global_max_fast;

//----- (0805AF10) --------------------------------------------------------
int ptmalloc_init_part_7()
{
  char **v0; // esi
  int result; // eax
  bool v2; // zf
  char *v3; // edi
  char *v4; // ebx
  _BYTE *v5; // ebp
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  char *v10; // ebx
  int v11; // eax
  int v12; // eax
  int v13; // eax

  v0 = (char **)environ;
  result = -20;
  _libc_malloc_initialized = 0;
  v2 = environ == 0;
  __writegsdword(0xFFFFFFEC, (unsigned int)&main_arena);
  if ( !v2 )
  {
    v3 = 0;
    while ( 1 )
    {
      v4 = *v0;
      if ( !*v0 )
        break;
      if ( *v4 == 77 && v4[1] == 65 && v4[2] == 76 && v4[3] == 76 && v4[4] == 79 && v4[5] == 67 && v4[6] == 95 )
      {
        ++v0;
        v5 = v4 + 7;
        if ( v4 == (char *)-7 )
          break;
        result = j_strcspn(v4 + 7, "=");
        if ( v4[result + 7] == 61 )
        {
          result -= 6;
          switch ( result )
          {
            case 0:
              v10 = v4 + 14;
              result = j_memcmp(v5, "CHECK_", 6);
              if ( !result )
                v3 = v10;
              break;
            case 2:
              result = _libc_enable_secure;
              if ( !_libc_enable_secure )
              {
                if ( !j_memcmp(v4 + 7, "TOP_PAD_", 8) )
                {
                  v11 = strtol(v4 + 16, 0, 10);
                  result = mallopt(-2, v11);
                }
                else
                {
                  result = j_memcmp(v4 + 7, "PERTURB_", 8);
                  if ( !result )
                  {
                    v9 = strtol(v4 + 16, 0, 10);
                    result = mallopt(-6, v9);
                  }
                }
              }
              break;
            case 3:
              result = _libc_enable_secure;
              if ( !_libc_enable_secure )
              {
                if ( !j_memcmp(v4 + 7, "MMAP_MAX_", 9) )
                {
                  v13 = strtol(v4 + 17, 0, 10);
                  result = mallopt(-4, v13);
                }
                else
                {
                  result = j_memcmp(v4 + 7, "ARENA_MAX", 9);
                  if ( !result )
                  {
                    v8 = strtol(v4 + 17, 0, 10);
                    result = mallopt(-8, v8);
                  }
                }
              }
              break;
            case 4:
              result = _libc_enable_secure;
              if ( !_libc_enable_secure )
              {
                result = j_memcmp(v4 + 7, "ARENA_TEST", 10);
                if ( !result )
                {
                  v7 = strtol(v4 + 18, 0, 10);
                  result = mallopt(-7, v7);
                }
              }
              break;
            case 9:
              if ( !_libc_enable_secure )
              {
                if ( !j_memcmp(v4 + 7, "TRIM_THRESHOLD_", 15) )
                {
                  v12 = strtol(v4 + 23, 0, 10);
                  result = mallopt(-1, v12);
                }
                else
                {
                  result = j_memcmp(v4 + 7, "MMAP_THRESHOLD_", 15);
                  if ( !result )
                  {
                    v6 = strtol(v4 + 23, 0, 10);
                    result = mallopt(-3, v6);
                  }
                }
              }
              break;
            default:
              continue;
          }
        }
      }
      else
      {
        ++v0;
      }
    }
    if ( v3 )
    {
      result = *v3;
      if ( (_BYTE)result )
      {
        result = mallopt(-5, result - 48);
        if ( check_action )
        {
          result = disallow_malloc_check;
          if ( disallow_malloc_check )
          {
            disallow_malloc_check = 0;
          }
          else
          {
            using_malloc_checking = 1;
            _malloc_hook = (int (__cdecl *)(int))malloc_check;
            _free_hook = (int)free_check;
            _realloc_hook = (int (__cdecl *)(int, int))realloc_check;
            _memalign_hook[0] = (int (__cdecl *)(int, int))memalign_check;
          }
        }
      }
    }
  }
  _libc_malloc_initialized = 1;
  return result;
}
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 8048270: using guessed type int __cdecl j_strcspn(_DWORD, _DWORD);
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EB4CC: using guessed type int check_action;
// 80EB4D0: using guessed type int (__cdecl *_memalign_hook[2])(int, int);
// 80EB4D4: using guessed type int (__cdecl *_realloc_hook)(int, int);
// 80EB4D8: using guessed type int (__cdecl *_malloc_hook)(int);
// 80EB520: using guessed type int main_arena;
// 80EC4F0: using guessed type int _free_hook;
// 80EC4FC: using guessed type int disallow_malloc_check;
// 80EC500: using guessed type int using_malloc_checking;
// 80EC524: using guessed type int environ;

//----- (0805B250) --------------------------------------------------------
int __cdecl malloc_hook_ini(int a1)
{
  _malloc_hook = 0;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_7();
  return malloc(a1);
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EB4D8: using guessed type int (__cdecl *_malloc_hook)(int);

//----- (0805B2A0) --------------------------------------------------------
int __cdecl realloc_hook_ini(int a1, int a2)
{
  _malloc_hook = 0;
  _realloc_hook = 0;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_7();
  return realloc(a1, a2);
}
// 805A5C0: using guessed type _DWORD __cdecl realloc(_DWORD, _DWORD);
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EB4D4: using guessed type int (__cdecl *_realloc_hook)(int, int);
// 80EB4D8: using guessed type int (__cdecl *_malloc_hook)(int);

//----- (0805B2F0) --------------------------------------------------------
int __cdecl memalign_hook_ini(int a1, int a2)
{
  void *retaddr; // [esp+1Ch] [ebp+0h]

  _memalign_hook[0] = 0;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_7();
  return mid_memalign(retaddr, a2);
}
// 805A310: using guessed type int __fastcall mid_memalign(_DWORD, _DWORD);
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EB4D0: using guessed type int (__cdecl *_memalign_hook[2])(int, int);

//----- (0805B350) --------------------------------------------------------
int __cdecl valloc(unsigned int a1)
{
  unsigned int v1; // edx
  int retaddr; // [esp+1Ch] [ebp+0h]

  v1 = a1;
  if ( _libc_malloc_initialized < 0 )
  {
    ptmalloc_init_part_7();
    v1 = a1;
  }
  return mid_memalign(dl_pagesize, v1, retaddr);
}
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EBA08: using guessed type int dl_pagesize;

//----- (0805B390) --------------------------------------------------------
int __cdecl pvalloc(unsigned int a1)
{
  int retaddr; // [esp+Ch] [ebp+0h]

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_7();
  if ( a1 <= -17 - 2 * dl_pagesize )
    return mid_memalign(dl_pagesize, (dl_pagesize + a1 - 1) & -dl_pagesize, retaddr);
  __writegsdword(0xFFFFFFE8, 0xCu);
  return 0;
}
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EBA08: using guessed type int dl_pagesize;

//----- (0805B3F0) --------------------------------------------------------
int __usercall malloc_trim@<eax>(long double a1@<st0>, unsigned int a2)
{
  bool v4; // zf
  int v5; // eax
  int *v6; // edi
  int v8; // ebp
  int *v9; // edi
  int *v10; // ebx
  unsigned int v11; // esi
  unsigned int v12; // eax
  unsigned int v13; // edx
  unsigned int v14; // eax
  int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // [esp+4h] [ebp-38h]
  int v18; // [esp+8h] [ebp-34h]
  int v19; // [esp+Ch] [ebp-30h]
  signed int v20; // [esp+10h] [ebp-2Ch]
  int v21; // [esp+14h] [ebp-28h]
  int *v22; // [esp+18h] [ebp-24h]
  int v23; // [esp+1Ch] [ebp-20h]

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_7();
  v22 = &main_arena;
  v23 = 0;
  do
  {
    _ECX = 1;
    _EDI = v22;
    v4 = __readgsdword(0xCu) == 0;
    if ( !v4 )
      __asm { lock }
    __asm { cmpxchg [edi], ecx }
    if ( !v4 )
      _lll_lock_wait_private(0, v22);
    v5 = 0;
    if ( (v22[1] & 4) == 0 )
    {
      malloc_consolidate(v22);
      v21 = dl_pagesize;
      if ( (unsigned int)dl_pagesize > 0x1FF )
      {
        if ( (unsigned int)dl_pagesize >> 6 > 0x26 )
        {
          if ( (unsigned int)dl_pagesize >> 9 <= 0x14 )
          {
            v20 = ((unsigned int)dl_pagesize >> 9) + 91;
          }
          else if ( (unsigned int)dl_pagesize >> 12 > 0xA )
          {
            if ( (unsigned int)dl_pagesize >> 15 > 4 )
            {
              v16 = 126;
              if ( (unsigned int)dl_pagesize >> 18 <= 2 )
                v16 = ((unsigned int)dl_pagesize >> 18) + 124;
              v20 = v16;
            }
            else
            {
              v20 = ((unsigned int)dl_pagesize >> 15) + 119;
            }
          }
          else
          {
            v20 = ((unsigned int)dl_pagesize >> 12) + 110;
          }
        }
        else
        {
          v20 = ((unsigned int)dl_pagesize >> 6) + 56;
        }
      }
      else
      {
        v20 = (unsigned int)dl_pagesize >> 3;
      }
      v19 = 0;
      v18 = 1;
      v8 = -dl_pagesize;
      v17 = dl_pagesize - 1;
      v9 = v22 + 12;
      do
      {
        if ( v18 == 1 || v20 <= v18 )
        {
          v10 = (int *)v9[3];
          if ( v9 != v10 )
          {
            v11 = v21 + 23;
            do
            {
              v12 = v10[1] & 0xFFFFFFF8;
              if ( v12 > v11 )
              {
                v13 = v8 & ((unsigned int)v10 + v11);
                if ( v13 < (unsigned int)(v10 + 6) )
                  _malloc_assert(
                    (int)"(char *) chunk2mem (p) + 4 * SIZE_SZ <= paligned_mem",
                    (unsigned int)"malloc.c",
                    4556,
                    a1,
                    "mtrim");
                if ( v13 >= (unsigned int)v10 + v12 )
                  _malloc_assert((int)"(char *) p + size > paligned_mem", (unsigned int)"malloc.c", 4557, a1, "mtrim");
                v14 = v12 - (v13 - (_DWORD)v10);
                if ( v17 < v14 )
                {
                  madvise(v8 & ((unsigned int)v10 + v11), v8 & v14);
                  v19 = 1;
                }
              }
              v10 = (int *)v10[3];
            }
            while ( v9 != v10 );
          }
        }
        ++v18;
        v9 += 2;
      }
      while ( v18 != 128 );
      v15 = 0;
      if ( v22 == &main_arena )
        v15 = systrim_isra_0(a2, &dword_80EB550, &dword_80EB96C);
      v5 = v19 | v15;
    }
    v23 |= v5;
    v6 = v22;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v4 = (*v22)-- == 1;
    if ( !v4 )
      _lll_unlock_wake_private(v22);
    v22 = (int *)v22[272];
  }
  while ( (int *)v6[272] != &main_arena );
  return v23;
}
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EB520: using guessed type int main_arena;
// 80EB550: using guessed type int dword_80EB550;
// 80EB96C: using guessed type int dword_80EB96C;
// 80EBA08: using guessed type int dl_pagesize;

//----- (0805B650) --------------------------------------------------------
_DWORD *__stdcall mallinfo(_DWORD *a1)
{
  bool v3; // zf
  int v5[17]; // [esp+8h] [ebp-44h] BYREF

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_7();
  _EBX = &main_arena;
  memset(v5, 0, 0x28u);
  do
  {
    _ECX = 1;
    v3 = __readgsdword(0xCu) == 0;
    if ( !v3 )
      __asm { lock }
    __asm { cmpxchg [ebx], ecx }
    if ( !v3 )
      _lll_lock_wait_private(0, _EBX);
    int_mallinfo(_EBX, v5);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v3 = (*_EBX)-- == 1;
    if ( !v3 )
      _lll_unlock_wake_private(_EBX);
    _EBX = (int *)_EBX[272];
  }
  while ( _EBX != &main_arena );
  *a1 = v5[0];
  a1[1] = v5[1];
  a1[2] = v5[2];
  a1[3] = v5[3];
  a1[4] = v5[4];
  a1[5] = v5[5];
  a1[6] = v5[6];
  a1[7] = v5[7];
  a1[8] = v5[8];
  a1[9] = v5[9];
  return a1;
}
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EB520: using guessed type int main_arena;

//----- (0805B730) --------------------------------------------------------
int *__usercall malloc_stats@<eax>(long double a1@<st0>)
{
  int v1; // ebp
  int v3; // esi
  bool v5; // zf
  int *result; // eax
  int v7; // [esp+8h] [ebp-54h]
  int v8; // [esp+Ch] [ebp-50h]
  int v9[17]; // [esp+18h] [ebp-44h] BYREF

  v1 = dword_80EB504;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_7();
  v7 = v1;
  _EBX = &main_arena;
  v8 = stderr[15];
  v3 = 0;
  stderr[15] = v8 | 2;
  while ( 1 )
  {
    memset(v9, 0, 0x28u);
    _ECX = 1;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg [ebx], ecx }
    if ( !v5 )
      _lll_lock_wait_private(0, _EBX);
    int_mallinfo(_EBX, v9);
    fprintf(a1, (int)stderr, (unsigned int)"Arena %d:\n", v3);
    fprintf(a1, (int)stderr, (unsigned int)"system bytes     = %10u\n", v9[0]);
    fprintf(a1, (int)stderr, (unsigned int)"in use bytes     = %10u\n", v9[7]);
    v1 += v9[0];
    v7 += v9[7];
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v5 = (*_EBX)-- == 1;
    if ( !v5 )
      _lll_unlock_wake_private(_EBX);
    _EBX = (int *)_EBX[272];
    if ( _EBX == &main_arena )
      break;
    ++v3;
  }
  fwrite(a1, (int)"Total (incl. mmap):\n", 1u, 20, stderr);
  fprintf(a1, (int)stderr, (unsigned int)"system bytes     = %10u\n", v1);
  fprintf(a1, (int)stderr, (unsigned int)"in use bytes     = %10u\n", v7);
  fprintf(a1, (int)stderr, (unsigned int)"max mmap regions = %10u\n", dword_80EB4FC);
  fprintf(a1, (int)stderr, (unsigned int)"max mmap bytes   = %10lu\n", dword_80EB508);
  result = stderr;
  stderr[15] |= v8;
  return result;
}
// 80EB4B4: using guessed type int *stderr;
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EB4FC: using guessed type int dword_80EB4FC;
// 80EB504: using guessed type int dword_80EB504;
// 80EB508: using guessed type int dword_80EB508;
// 80EB520: using guessed type int main_arena;

//----- (0805B8C0) --------------------------------------------------------
int __usercall _malloc_info_part_9@<eax>(_DWORD *a1@<eax>, long double a2@<st0>)
{
  int v2; // eax
  bool v5; // zf
  int *v6; // ebx
  int v7; // ecx
  int v8; // esi
  size_t *v9; // ebp
  int v10; // eax
  size_t v11; // edx
  unsigned int v12; // edi
  int v13; // edx
  int *v14; // edx
  int v15; // esi
  unsigned int v16; // ebx
  size_t v17; // edi
  size_t v18; // ecx
  unsigned int v19; // eax
  size_t v20; // ebx
  int v21; // esi
  char *v22; // edi
  unsigned int v23; // ebx
  size_t v25; // [esp+8h] [ebp-8F4h]
  int *v26; // [esp+Ch] [ebp-8F0h]
  int v27; // [esp+14h] [ebp-8E8h]
  int *v29; // [esp+1Ch] [ebp-8E0h]
  int v30; // [esp+20h] [ebp-8DCh]
  int v31; // [esp+24h] [ebp-8D8h]
  int v32; // [esp+28h] [ebp-8D4h]
  int v33; // [esp+2Ch] [ebp-8D0h]
  int v34; // [esp+30h] [ebp-8CCh]
  int v35; // [esp+34h] [ebp-8C8h]
  int v36; // [esp+38h] [ebp-8C4h]
  int v37; // [esp+3Ch] [ebp-8C0h]
  int v38; // [esp+40h] [ebp-8BCh]
  int v39; // [esp+44h] [ebp-8B8h]
  int v40; // [esp+48h] [ebp-8B4h]
  char v41[160]; // [esp+50h] [ebp-8ACh] BYREF
  size_t v42[3]; // [esp+F0h] [ebp-80Ch] BYREF
  size_t v43; // [esp+FCh] [ebp-800h]
  char v44; // [esp+8E0h] [ebp-1Ch] BYREF

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_7();
  fputs(a2, "<malloc version=\"1\">\n", a1);
  v29 = &main_arena;
  v31 = 0;
  v30 = 0;
  v37 = 0;
  v2 = 0;
  v36 = 0;
  v33 = 0;
  v35 = 0;
  v32 = 0;
  v34 = 0;
  do
  {
    v40 = v2 + 1;
    fprintf(a2, (int)a1, (unsigned int)"<heap nr=\"%d\">\n<sizes>\n", v2);
    _ECX = 1;
    _EDI = v29;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg [edi], ecx }
    if ( !v5 )
      _lll_lock_wait_private(0, v29);
    v6 = v29 + 2;
    v7 = 0;
    v8 = 0;
    v9 = (size_t *)v41;
    do
    {
      v10 = *v6;
      if ( *v6 )
      {
        v11 = 0;
        v12 = *(_DWORD *)(v10 + 4) & 0xFFFFFFF8;
        do
        {
          v10 = *(_DWORD *)(v10 + 8);
          ++v11;
        }
        while ( v10 );
        v7 += v11;
        v9[1] = v12;
        v9[3] = v11;
        v8 += v11 * v12;
        *v9 = v12 - 7;
      }
      else
      {
        v9[3] = 0;
        v9[1] = 0;
        v11 = 0;
        *v9 = 0;
      }
      v13 = v9[1] * v11;
      v9 += 4;
      ++v6;
      *(v9 - 2) = v13;
    }
    while ( v9 != v42 );
    v38 = v7;
    v39 = v8;
    v25 = 0;
    v27 = 0;
    v26 = v29 + 12;
    do
    {
      *v9 = -1;
      v9[3] = 0;
      v9[2] = 0;
      v9[1] = 0;
      v14 = (int *)v26[2];
      if ( !v14 || v26 == v14 )
        goto LABEL_41;
      v15 = 1;
      v16 = -1;
      v17 = 0;
      v18 = 0;
      while ( 1 )
      {
        v19 = v14[1];
        v14 = (int *)v14[2];
        v17 += v19;
        if ( v16 > v19 )
          v16 = v19;
        if ( v18 < v19 )
          v18 = v19;
        if ( v26 == v14 )
          break;
        ++v15;
      }
      v9[3] = v15;
      v9[2] = v17;
      *v9 = v16;
      v9[1] = v18;
      if ( !v15 )
      {
LABEL_41:
        *v9 = 0;
        v15 = 0;
      }
      v20 = v9[2] + v25;
      v9 += 4;
      v27 += v15;
      v26 += 2;
      v25 = v20;
    }
    while ( v9 != (size_t *)&v44 );
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v5 = (*v29)-- == 1;
    if ( !v5 )
      _lll_unlock_wake_private(v29);
    v21 = 0;
    v32 += v38;
    v33 += v39;
    v34 += v27;
    v35 += v20;
    v22 = v41;
    do
    {
      if ( v21 != 10 && *((_DWORD *)v22 + 3) )
        fprintf(
          a2,
          (int)a1,
          (unsigned int)"\t\t\t\t\t\t\t        <size from=\"%zu\" to=\"%zu\" total=\"%zu\" count=\"%zu\"/>\n",
          *(_DWORD *)v22,
          *((_DWORD *)v22 + 1),
          *((_DWORD *)v22 + 2),
          *((_DWORD *)v22 + 3));
      ++v21;
      v22 += 16;
    }
    while ( v21 != 137 );
    if ( v43 )
      fprintf(
        a2,
        (int)a1,
        (unsigned int)"  <unsorted from=\"%zu\" to=\"%zu\" total=\"%zu\" count=\"%zu\"/>\n",
        v42[0],
        v42[1],
        v42[2],
        v43);
    v36 += v29[275];
    v37 += v29[276];
    fprintf(
      a2,
      (int)a1,
      (unsigned int)"</sizes>\n"
                    "<total type=\"fast\" count=\"%zu\" size=\"%zu\"/>\n"
                    "<total type=\"rest\" count=\"%zu\" size=\"%zu\"/>\n"
                    "<system type=\"current\" size=\"%zu\"/>\n"
                    "<system type=\"max\" size=\"%zu\"/>\n",
      v38,
      v39,
      v27,
      v20,
      v29[275],
      v29[276]);
    if ( v29 == &main_arena )
    {
      fprintf(
        a2,
        (int)a1,
        (unsigned int)"<aspace type=\"total\" size=\"%zu\"/>\n<aspace type=\"mprotect\" size=\"%zu\"/>\n",
        dword_80EB96C,
        dword_80EB96C);
      v30 += dword_80EB96C;
      v31 += dword_80EB96C;
    }
    else
    {
      v23 = v29[12] & 0xFFF00000;
      fprintf(
        a2,
        (int)a1,
        (unsigned int)"<aspace type=\"total\" size=\"%zu\"/>\n<aspace type=\"mprotect\" size=\"%zu\"/>\n",
        *(_DWORD *)(v23 + 8),
        *(_DWORD *)(v23 + 0xC));
      v30 += *(_DWORD *)(v23 + 8);
      v31 += *(_DWORD *)(v23 + 12);
    }
    fputs(a2, "</heap>\n", a1);
    v29 = (int *)v29[272];
    v2 = v40;
  }
  while ( v29 != &main_arena );
  fprintf(
    a2,
    (int)a1,
    (unsigned int)"<total type=\"fast\" count=\"%zu\" size=\"%zu\"/>\n"
                  "<total type=\"rest\" count=\"%zu\" size=\"%zu\"/>\n"
                  "<total type=\"mmap\" count=\"%d\" size=\"%zu\"/>\n"
                  "<system type=\"current\" size=\"%zu\"/>\n"
                  "<system type=\"max\" size=\"%zu\"/>\n"
                  "<aspace type=\"total\" size=\"%zu\"/>\n"
                  "<aspace type=\"mprotect\" size=\"%zu\"/>\n"
                  "</malloc>\n",
    v32,
    v33,
    v34,
    v35,
    dword_80EB4F4,
    dword_80EB504,
    v36,
    v37,
    v30,
    v31);
  return 0;
}
// 80EB4C4: using guessed type int _libc_malloc_initialized;
// 80EB4F4: using guessed type int dword_80EB4F4;
// 80EB504: using guessed type int dword_80EB504;
// 80EB520: using guessed type int main_arena;
// 80EB96C: using guessed type int dword_80EB96C;

//----- (0805BCD0) --------------------------------------------------------
int __cdecl posix_memalign(int *a1, unsigned int a2, unsigned int a3)
{
  int result; // eax
  int v4; // edx
  int retaddr; // [esp+Ch] [ebp+0h]

  result = 22;
  if ( (a2 & 3) == 0 )
  {
    if ( ((a2 >> 2) & ((a2 >> 2) - 1)) != 0 || !a2 )
    {
      return 22;
    }
    else
    {
      v4 = mid_memalign(a2, a3, retaddr);
      result = 12;
      if ( v4 )
      {
        *a1 = v4;
        return 0;
      }
    }
  }
  return result;
}

//----- (0805BD40) --------------------------------------------------------
int __usercall malloc_info@<eax>(long double a1@<st0>, int a2, _DWORD *a3)
{
  if ( a2 )
    return 22;
  else
    return _malloc_info_part_9(a3, a1);
}

//----- (0805BD60) --------------------------------------------------------
int __cdecl _default_morecore(int a1)
{
  int result; // eax

  result = sbrk(a1);
  if ( result == -1 )
    return 0;
  return result;
}

//----- (0805BD80) --------------------------------------------------------
const __m128i *(__cdecl *strchr())(const __m128i *a1, unsigned int a2)
{
  const __m128i *(__cdecl *result)(const __m128i *, unsigned int); // eax

  result = (const __m128i *(__cdecl *)(const __m128i *, unsigned int))_strchr_ia32;
  if ( (unk_80EC574 & 0x4000000) != 0 )
  {
    result = (const __m128i *(__cdecl *)(const __m128i *, unsigned int))_strchr_sse2_bsf;
    if ( (dword_80EC5A0 & 4) != 0 )
      return _strchr_sse2;
  }
  return result;
}
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (0805BDB0) --------------------------------------------------------
unsigned int *__cdecl _strchr_ia32(unsigned int *a1, int a2)
{
  unsigned int *result; // eax
  int v3; // edx
  unsigned __int16 v4; // cx
  int v5; // edx
  char v6; // cl
  unsigned int v7; // ecx
  int v8; // ebp
  int v9; // ebp
  unsigned int v10; // ebx
  unsigned int v11; // ecx

  result = a1;
  v3 = a2;
  BYTE1(v3) = a2;
  LOBYTE(v4) = a2;
  HIBYTE(v4) = a2;
  v5 = v4 | (v3 << 16);
  if ( ((unsigned __int8)a1 & 3) == 0 )
  {
LABEL_11:
    v7 = *result;
    v8 = *result - 16843009;
    while ( 1 )
    {
      v9 = v7 ^ v8;
      ++result;
      if ( v7 < 0x1010101 || (v9 | 0xFEFEFEFF) != -1 )
        break;
      v10 = v5 ^ v7;
      v7 = *result;
      if ( v10 < 0x1010101 || (v10 ^ (v10 - 16843009) | 0xFEFEFEFF) != -1 )
      {
LABEL_28:
        --result;
        if ( (_BYTE)v10 )
        {
          result = (unsigned int *)((char *)result + 1);
          if ( BYTE1(v10) )
          {
            result = (unsigned int *)((char *)result + 1);
            if ( BYTE2(v10) )
              return (unsigned int *)((char *)result + 1);
          }
        }
        return result;
      }
      ++result;
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v10 = v5 ^ v7;
      v7 = *result;
      if ( v10 < 0x1010101 || (v10 ^ (v10 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_28;
      ++result;
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v10 = v5 ^ v7;
      v7 = *result;
      if ( v10 < 0x1010101 || (v10 ^ (v10 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_28;
      ++result;
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v10 = v5 ^ v7;
      v7 = *result;
      if ( v10 >= 0x1010101 )
      {
        v8 = v7 - 16843009;
        if ( (v10 ^ (v10 - 16843009) | 0xFEFEFEFF) == -1 )
          continue;
      }
      goto LABEL_28;
    }
    --result;
    if ( (_BYTE)v7 == (_BYTE)v5 )
      return result;
    if ( (_BYTE)v7 )
    {
      result = (unsigned int *)((char *)result + 1);
      if ( BYTE1(v7) == (_BYTE)v5 )
        return result;
      if ( BYTE1(v7) )
      {
        v11 = HIWORD(v7);
        result = (unsigned int *)((char *)result + 1);
        if ( (_BYTE)v11 == (_BYTE)v5 )
          return result;
        if ( (_BYTE)v11 )
        {
          result = (unsigned int *)((char *)result + 1);
          if ( BYTE1(v11) == (_BYTE)v5 )
            return result;
        }
      }
    }
    return 0;
  }
  if ( __SETP__((unsigned __int8)a1 & 3, 0) )
    goto LABEL_8;
  if ( *(_BYTE *)a1 != (unsigned __int8)v5 )
  {
    if ( !*(_BYTE *)a1 )
      return 0;
    v6 = *((_BYTE *)a1 + 1);
    result = (unsigned int *)((char *)a1 + 1);
    if ( (_BYTE)v5 != v6 )
    {
      if ( !v6 )
        return 0;
      result = (unsigned int *)((char *)a1 + 2);
      if ( ((unsigned __int8)a1 & 3) != 1 )
        goto LABEL_11;
LABEL_8:
      if ( (_BYTE)v5 != *(_BYTE *)result )
      {
        if ( *(_BYTE *)result )
        {
          result = (unsigned int *)((char *)result + 1);
          goto LABEL_11;
        }
        return 0;
      }
    }
  }
  return result;
}

//----- (0805BF70) --------------------------------------------------------
int (__cdecl *strcmp())(const __m128i *a1, const __m128i *a2)
{
  int (__cdecl *result)(const __m128i *, const __m128i *); // eax

  result = (int (__cdecl *)(const __m128i *, const __m128i *))_strcmp_ia32;
  if ( (dword_80EC570 & 0x200) != 0 )
  {
    result = (int (__cdecl *)(const __m128i *, const __m128i *))_strcmp_ssse3;
    if ( (dword_80EC570 & 0x100000) != 0 && (dword_80EC5A0 & 0x200) == 0 )
      return _strcmp_sse4_2;
  }
  return result;
}
// 80EC570: using guessed type int dword_80EC570;
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (0805BFB0) --------------------------------------------------------
int __cdecl _strcmp_ia32(char *a1, _BYTE *a2)
{
  char v4; // al
  int result; // eax

  while ( 1 )
  {
    v4 = *a1;
    if ( *a1 != *a2 )
      break;
    ++a1;
    ++a2;
    if ( !v4 )
      return 0;
  }
  result = 1;
  if ( (unsigned __int8)*a1 < *a2 )
    return -1;
  return result;
}

//----- (0805BFE0) --------------------------------------------------------
unsigned int (__cdecl *strcpy())(unsigned int a1, unsigned int a2)
{
  unsigned int (__cdecl *result)(unsigned int, unsigned int); // eax

  result = (unsigned int (__cdecl *)(unsigned int, unsigned int))_strcpy_ia32;
  if ( (unk_80EC574 & 0x4000000) != 0 )
  {
    result = (unsigned int (__cdecl *)(unsigned int, unsigned int))_strcpy_sse2;
    if ( (dword_80EC5A0 & 0x10) == 0 && (dword_80EC570 & 0x200) != 0 )
      return _strcpy_ssse3;
  }
  return result;
}
// 80EC570: using guessed type int dword_80EC570;
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (0805C020) --------------------------------------------------------
void __cdecl _strcpy_ia32(int a1, char a2)
{
  __asm { jmp     ecx }
}
// 805C03F: unbalanced stack, ignored a potential tail call

//----- (0805C0B0) --------------------------------------------------------
_BYTE *(__cdecl *strcspn())(int a1, __m128i *a2)
{
  _BYTE *(__cdecl *result)(int, __m128i *); // eax

  result = (_BYTE *(__cdecl *)(int, __m128i *))_strcspn_ia32;
  if ( (dword_80EC570 & 0x100000) != 0 )
    return _strcspn_sse42;
  return result;
}
// 80EC570: using guessed type int dword_80EC570;

//----- (0805C0D0) --------------------------------------------------------
_BYTE *__cdecl _strcspn_ia32(int a1, _BYTE *a2)
{
  int v3; // ecx
  _BYTE *v4; // eax
  char v6[256]; // [esp+0h] [ebp-100h] BYREF

  v3 = 0;
  memset(v6, 0, sizeof(v6));
  do
  {
    if ( !*a2 )
      break;
    LOBYTE(v3) = *a2;
    v6[v3] = *a2;
    LOBYTE(v3) = a2[1];
    if ( !(_BYTE)v3 )
      break;
    v6[v3] = v3;
    LOBYTE(v3) = a2[2];
    if ( !(_BYTE)v3 )
      break;
    v6[v3] = v3;
    LOBYTE(v3) = a2[3];
    a2 += 4;
    v6[v3] = v3;
  }
  while ( (_BYTE)v3 );
  v4 = (_BYTE *)(a1 - 4);
  while ( 1 )
  {
    v4 += 4;
    LOBYTE(v3) = *v4;
    if ( v6[v3] == *v4 )
      return &v4[-a1];
    LOBYTE(v3) = v4[1];
    if ( v6[v3] == (_BYTE)v3 )
      goto LABEL_13;
    LOBYTE(v3) = v4[2];
    if ( v6[v3] == (_BYTE)v3 )
      goto LABEL_12;
    LOBYTE(v3) = v4[3];
    if ( v6[v3] == (_BYTE)v3 )
    {
      ++v4;
LABEL_12:
      ++v4;
LABEL_13:
      ++v4;
      return &v4[-a1];
    }
  }
}
// 805C0D0: using guessed type char var_100[256];

//----- (0805C180) --------------------------------------------------------
_BYTE *__cdecl strdup(_BYTE *a1)
{
  unsigned int v1; // ebx
  _BYTE *v2; // eax

  v1 = strlen(a1) + 1;
  v2 = (_BYTE *)malloc(v1);
  if ( v2 )
    return memcpy(v2, a1, v1);
  else
    return 0;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);

//----- (0805C1C0) --------------------------------------------------------
int __cdecl strlen(_BYTE *a1)
{
  _BYTE *v1; // eax
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  bool v5; // cf
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  int v16; // edx
  int v17; // ecx

  v1 = a1;
  v2 = (unsigned __int8)a1 & 3;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( __SETP__((unsigned __int8)a1 & 3, 0) )
      goto LABEL_6;
    if ( *a1 == BYTE1(v2) )
      return v1 - a1;
    v1 = a1 + 1;
    if ( a1[1] == BYTE1(v2) )
      return v1 - a1;
    v1 = a1 + 2;
    v2 ^= 2u;
    if ( v2 )
    {
LABEL_6:
      if ( *v1 == BYTE1(v2) )
        return v1 - a1;
      ++v1;
      v2 = 0;
    }
  }
  do
  {
    v3 = *(_DWORD *)v1;
    v1 += 4;
    v4 = v2 - v3;
    v5 = __CFADD__(v3, -16843009);
    v6 = v3 - 16843009;
    v7 = v4 - 1;
    if ( !v5 )
      break;
    if ( ((v6 ^ v7) & 0x1010100) != 0 )
      break;
    v8 = *(_DWORD *)v1;
    v1 += 4;
    v9 = -v8;
    v5 = __CFADD__(v8, -16843009);
    v6 = v8 - 16843009;
    v10 = v9 - 1;
    if ( !v5 )
      break;
    if ( ((v6 ^ v10) & 0x1010100) != 0 )
      break;
    v11 = *(_DWORD *)v1;
    v1 += 4;
    v12 = -v11;
    v5 = __CFADD__(v11, -16843009);
    v6 = v11 - 16843009;
    v13 = v12 - 1;
    if ( !v5 )
      break;
    if ( ((v6 ^ v13) & 0x1010100) != 0 )
      break;
    v14 = *(_DWORD *)v1;
    v1 += 4;
    v15 = -v14;
    v5 = __CFADD__(v14, -16843009);
    v6 = v14 - 16843009;
    v16 = v15 - 1;
    if ( !v5 )
      break;
    v2 = (v6 ^ v16) & 0x1010100;
  }
  while ( !v2 );
  v1 -= 4;
  v17 = v6 + 16843009;
  if ( (_BYTE)v17 )
  {
    ++v1;
    if ( BYTE1(v17) )
    {
      ++v1;
      if ( BYTE2(v17) )
        ++v1;
    }
  }
  return v1 - a1;
}

//----- (0805C280) --------------------------------------------------------
unsigned int __usercall critical_factorization@<eax>(int a1@<eax>, unsigned int a2@<edx>, int *a3@<ecx>)
{
  int v3; // ebp
  int v4; // esi
  int v5; // ecx
  int v6; // edx
  unsigned __int8 v7; // bl
  int v8; // ecx
  int v9; // edi
  int v10; // edx
  unsigned __int8 v11; // bl
  unsigned int result; // eax
  unsigned int v13; // edi
  int v14; // [esp+0h] [ebp-20h]
  int v15; // [esp+0h] [ebp-20h]
  int v17; // [esp+8h] [ebp-18h]

  v3 = 1;
  v4 = -1;
  v5 = 1;
  v14 = 0;
  while ( 1 )
  {
    v6 = v14 + v5;
    if ( v14 + v5 >= a2 )
      break;
    while ( 1 )
    {
      v7 = *(_BYTE *)(a1 + v4 + v5);
      if ( *(_BYTE *)(a1 + v6) >= v7 )
        break;
      v14 = v6;
      v5 = 1;
      v3 = v6 - v4;
      if ( ++v6 >= a2 )
        goto LABEL_5;
    }
    if ( *(_BYTE *)(a1 + v6) == v7 )
    {
      if ( v5 == v3 )
      {
        v14 = v6;
        v5 = 1;
      }
      else
      {
        ++v5;
      }
    }
    else
    {
      v3 = 1;
      v4 = v14;
      v5 = 1;
      ++v14;
    }
  }
LABEL_5:
  v17 = 1;
  v8 = 1;
  v15 = 0;
  *a3 = v3;
  v9 = -1;
  while ( 1 )
  {
    v10 = v15 + v8;
    if ( a2 <= v15 + v8 )
      break;
    while ( 1 )
    {
      v11 = *(_BYTE *)(a1 + v9 + v8);
      if ( *(_BYTE *)(a1 + v10) <= v11 )
        break;
      v15 = v10;
      v17 = v10 - v9;
      v8 = 1;
      if ( a2 <= ++v10 )
        goto LABEL_9;
    }
    if ( *(_BYTE *)(a1 + v10) == v11 )
    {
      if ( v8 == v17 )
      {
        v15 = v10;
        v8 = 1;
      }
      else
      {
        ++v8;
      }
    }
    else
    {
      v17 = 1;
      v8 = 1;
      v9 = v15++;
    }
  }
LABEL_9:
  result = v4 + 1;
  v13 = v9 + 1;
  if ( v13 >= v4 + 1 )
  {
    *a3 = v17;
    return v13;
  }
  return result;
}

//----- (0805C3E0) --------------------------------------------------------
int __usercall two_way_long_needle@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, unsigned int a4)
{
  char *v6; // eax
  int v7; // eax
  unsigned __int8 *v8; // edx
  int v9; // ecx
  unsigned int v10; // ebx
  int v11; // ebp
  int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // edx
  unsigned int v16; // eax
  int v17; // ebp
  int v18; // ebx
  int v19; // eax
  int v20; // eax
  char v21; // dl
  int v24; // [esp+10h] [ebp-44Ch]
  unsigned int v25; // [esp+14h] [ebp-448h]
  unsigned int v26; // [esp+18h] [ebp-444h]
  unsigned int v27; // [esp+1Ch] [ebp-440h]
  unsigned int v28; // [esp+20h] [ebp-43Ch]
  _BYTE *v29; // [esp+24h] [ebp-438h]
  unsigned int v30; // [esp+3Ch] [ebp-420h] BYREF
  int v31[256]; // [esp+40h] [ebp-41Ch] BYREF
  char v32; // [esp+440h] [ebp-1Ch] BYREF

  v26 = critical_factorization(a3, a4, (int *)&v30);
  v6 = (char *)v31;
  do
  {
    *(_DWORD *)v6 = a4;
    v6 += 4;
  }
  while ( &v32 != v6 );
  v7 = a4 - 1;
  v8 = (unsigned __int8 *)a3;
  if ( a4 )
  {
    do
    {
      v9 = *v8++;
      v31[v9] = v7--;
    }
    while ( v7 != -1 );
  }
  v27 = v30;
  if ( !j_memcmp(a3, a3 + v30, v26) )
  {
    v25 = 0;
    v24 = 0;
    v10 = a4 - 1;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v11 = a4 + v24;
          v12 = j_memchr(a1 + a2, 0, a4 + v24 - a2);
          if ( !(a4 + v24) || v12 )
            return 0;
          v13 = v31[*(unsigned __int8 *)(a1 + v11 - 1)];
          if ( !v13 )
            break;
          if ( v27 > v13 )
          {
            if ( v25 )
              v13 = a4 - v27;
          }
          v24 += v13;
          v25 = 0;
          a2 = v11;
        }
        v14 = v26;
        if ( v25 >= v26 )
          v14 = v25;
        if ( v14 < v10 )
          break;
LABEL_21:
        v15 = v26 - 1;
        if ( v25 >= v26 )
        {
          v15 = v26;
        }
        else if ( *(_BYTE *)(a1 + v26 - 1 + v24) == *(_BYTE *)(a3 + v26 - 1) )
        {
          while ( v15 - 1 != v25 - 1 && *(_BYTE *)(a3 + v15 - 1) == *(_BYTE *)(v15 + a1 + v24 - 1) )
            --v15;
        }
        else
        {
          v15 = v26;
        }
        if ( v25 + 1 > v15 )
          return v24 + a1;
        v24 += v27;
        a2 = v11;
        v25 = a4 - v27;
      }
      if ( *(_BYTE *)(a1 + v24 + v14) == *(_BYTE *)(a3 + v14) )
      {
        while ( ++v14 < v10 )
        {
          if ( *(_BYTE *)(a3 + v14) != *(_BYTE *)(a1 + v24 + v14) )
            goto LABEL_29;
        }
        goto LABEL_21;
      }
LABEL_29:
      a2 = a4 + v24;
      v25 = 0;
      v24 += 1 - v26 + v14;
    }
  }
  v16 = a4 - v26;
  if ( a4 - v26 < v26 )
    v16 = v26;
  v17 = 0;
  v28 = v16 + 1;
  v29 = (_BYTE *)(a3 + v26 - 1);
  while ( 1 )
  {
    v18 = v17 + a4;
    if ( j_memchr(a1 + a2, 0, v17 + a4 - a2) || !v18 )
      return 0;
    v19 = v31[*(unsigned __int8 *)(a1 + v18 - 1)];
    if ( v19 )
      goto LABEL_48;
    if ( v26 >= a4 - 1 )
      goto LABEL_41;
    if ( *(_BYTE *)(a3 + v26) == *(_BYTE *)(v17 + v26 + a1) )
    {
      v19 = v26;
      while ( ++v19 < a4 - 1 )
      {
        if ( *(_BYTE *)(a3 + v19) != *(_BYTE *)(v17 + a1 + v19) )
          goto LABEL_47;
      }
LABEL_41:
      if ( !v26 )
        return v17 + a1;
      if ( *v29 == *(_BYTE *)(a1 + v17 + v26 - 1) )
      {
        v20 = -1;
        while ( -v26 != v20 )
        {
          v21 = v29[v20--];
          if ( v21 != *(_BYTE *)(a1 + v17 + v26 + v20) )
          {
            v18 = v17 + a4;
            goto LABEL_50;
          }
        }
        return v17 + a1;
      }
LABEL_50:
      v17 += v28;
      a2 = v18;
    }
    else
    {
      v19 = v26;
LABEL_47:
      v17 += 1 - v26;
LABEL_48:
      v17 += v19;
      a2 = v18;
    }
  }
}
// 8048220: using guessed type int __cdecl j_memchr(_DWORD, _DWORD, _DWORD);
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 805C3E0: using guessed type int var_41C[256];

//----- (0805C790) --------------------------------------------------------
int __cdecl strstr(char *a1, char *a2)
{
  char v2; // al
  char v3; // dl
  char *v4; // ebx
  char *v5; // ebp
  char v6; // si
  int result; // eax
  unsigned int v8; // esi
  unsigned int v9; // ecx
  unsigned int v10; // ebp
  char *v11; // ecx
  int v12; // edx
  char *v13; // edx
  unsigned int v14; // eax
  char *v15; // edi
  char v16; // cl
  char *v17; // eax
  int v18; // edi
  int v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // edx
  unsigned int v22; // eax
  unsigned int v23; // ebp
  int v24; // eax
  char v25; // cl
  char *v26; // edx
  char *v27; // ebx
  char v28; // dl
  int v29; // eax
  char v30; // cl
  char v31; // [esp+0h] [ebp-5Ch]
  unsigned int i; // [esp+0h] [ebp-5Ch]
  unsigned int v33; // [esp+4h] [ebp-58h]
  unsigned int v34; // [esp+8h] [ebp-54h]
  int v35; // [esp+8h] [ebp-54h]
  unsigned int v36; // [esp+Ch] [ebp-50h]
  unsigned int v37; // [esp+Ch] [ebp-50h]
  unsigned int v38; // [esp+10h] [ebp-4Ch]
  unsigned int v39; // [esp+14h] [ebp-48h]
  int v40; // [esp+14h] [ebp-48h]
  char *v41; // [esp+18h] [ebp-44h]
  unsigned int v42; // [esp+24h] [ebp-38h]
  int v43[8]; // [esp+3Ch] [ebp-20h] BYREF

  v2 = *a1;
  if ( *a1 )
  {
    v3 = *a2;
    if ( !*a2 )
      return (int)a1;
    v4 = a2;
    v5 = a1;
    v6 = 1;
    while ( 1 )
    {
      ++v5;
      ++v4;
      v6 &= v2 == v3;
      v2 = *v5;
      if ( !*v5 )
        break;
      v3 = *v4;
      if ( !*v4 )
        goto LABEL_7;
    }
  }
  else
  {
    v4 = a2;
    v6 = 1;
  }
  if ( *v4 )
    return 0;
LABEL_7:
  result = (int)a1;
  if ( v6 )
    return result;
  v8 = v4 - a2;
  v9 = j_strchr(a1 + 1, *a2);
  v33 = v9;
  if ( !v9 )
    return 0;
  if ( v8 == 1 )
    return v9;
  v10 = 1;
  if ( v9 <= (unsigned int)&a1[v8] )
    v10 = (unsigned int)&a1[v8 - v9];
  if ( v8 > 0x1F )
    return two_way_long_needle(v9, v10, (int)a2, v8);
  v38 = critical_factorization((int)a2, v8, v43);
  v40 = v43[0];
  if ( !j_memcmp(a2, &a2[v43[0]], v38) )
  {
    v34 = 0;
    v18 = 0;
    while ( 1 )
    {
      v37 = v8 + v18;
      v19 = j_memchr(v33 + v10, 0, v8 + v18 - v10);
      if ( !(v8 + v18) || v19 )
        return 0;
      v20 = v34;
      if ( v38 >= v34 )
        v20 = v38;
      if ( v8 > v20 )
      {
        if ( *(_BYTE *)(v33 + v20 + v18) != a2[v20] )
        {
LABEL_44:
          v34 = 0;
          v18 += v20 + 1 - v38;
          goto LABEL_43;
        }
        while ( v8 != ++v20 )
        {
          if ( a2[v20] != *(_BYTE *)(v33 + v18 + v20) )
            goto LABEL_44;
        }
      }
      if ( v38 > v34 && a2[v38 - 1] == *(_BYTE *)(v33 + v18 + v38 - 1) )
      {
        for ( i = v38 - 1; i - 1 != v34 - 1 && a2[i - 1] == *(_BYTE *)(i + v33 + v18 - 1); --i )
          ;
        v21 = i;
      }
      else
      {
        v21 = v38;
      }
      if ( v34 + 1 > v21 )
        return v18 + v33;
      v18 += v40;
      v34 = v8 - v40;
LABEL_43:
      v10 = v37;
    }
  }
  v11 = &a2[v38];
  v41 = (char *)(v38 + v33);
  v39 = v38 + 1;
  if ( v38 + 1 <= v10 )
  {
LABEL_18:
    v13 = (char *)(v38 + v33);
    v36 = v10;
    v31 = *v11;
    v14 = v8 - v38;
    if ( v8 - v38 < v38 )
      v14 = v38;
    v42 = v14 + 1;
    v15 = &a2[v38 - 1];
    v16 = *v41;
    v17 = v41 + 1;
    if ( v31 == *v41 )
      goto LABEL_52;
LABEL_21:
    if ( !v16 )
      return 0;
    while ( 1 )
    {
      v13 = v17;
      v16 = *v17++;
      if ( v31 != v16 )
        goto LABEL_21;
LABEL_52:
      v35 = v17 - v41 - 1;
      v22 = v38 + 1;
      if ( v8 > v39 )
      {
        v25 = v13[1];
        if ( a2[v39] != v25 )
        {
          v22 = v38 + 1;
LABEL_46:
          if ( !v25 )
            return 0;
          v23 = v22 + 1 - v38 + v35;
          goto LABEL_48;
        }
        v26 = &v13[-v38];
        while ( v8 > ++v22 )
        {
          v25 = v26[v22];
          if ( a2[v22] != v25 )
            goto LABEL_46;
        }
      }
      v27 = (char *)(v33 + v38 - 1 + v35);
      if ( !v38 )
        return v35 + v33;
      v28 = *v27;
      if ( *v15 == *v27 )
      {
        v29 = -1;
        while ( v29 != -v38 )
        {
          v30 = v15[v29--];
          v28 = *(_BYTE *)(v33 + v38 + v35 + v29);
          if ( v30 != v28 )
            goto LABEL_63;
        }
        return v35 + v33;
      }
LABEL_63:
      if ( !v28 )
        return 0;
      v23 = v42 + v35;
LABEL_48:
      v24 = j_memchr(v36 + v33, 0, v8 + v23 - v36);
      if ( !(v8 + v23) || v24 )
        return 0;
      v36 = v8 + v23;
      v17 = (char *)(v33 + v23 + v38);
    }
  }
  v12 = j_memchr(v33 + v10, 0, 1 - v10 + v38);
  result = 0;
  if ( !v12 )
  {
    v10 = v38 + 1;
    v11 = &a2[v38];
    goto LABEL_18;
  }
  return result;
}
// 8048220: using guessed type int __cdecl j_memchr(_DWORD, _DWORD, _DWORD);
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 805C790: using guessed type int var_20[8];

//----- (0805CBC0) --------------------------------------------------------
int (__cdecl *memchr())(const __m128i *a1, unsigned int a2, unsigned int a3)
{
  if ( (unk_80EC574 & 0x4000000) == 0 )
    return (int (__cdecl *)(const __m128i *, unsigned int, unsigned int))_memchr_ia32;
  if ( (dword_80EC5A0 & 4) != 0 )
    return (int (__cdecl *)(const __m128i *, unsigned int, unsigned int))_memchr_sse2;
  return _memchr_sse2_bsf;
}
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (0805CBF0) --------------------------------------------------------
_BYTE *__cdecl _memchr_ia32(_BYTE *a1, int a2, unsigned int a3)
{
  _BYTE *result; // eax
  int v4; // edx
  unsigned int v5; // esi
  __int16 v6; // cx
  unsigned int v7; // ecx
  bool v8; // cf
  int v9; // esi
  int v10; // esi

  result = a1;
  v4 = a2;
  v5 = a3;
  if ( a3 < 4 )
  {
LABEL_31:
    v9 = v5 & 3;
    if ( !v9 )
      return 0;
    if ( *result != (_BYTE)v4 )
    {
      ++result;
      v10 = v9 - 1;
      if ( !v10 )
        return 0;
      if ( *result != (_BYTE)v4 )
      {
        ++result;
        if ( v10 == 1 || *result != (_BYTE)v4 )
          return 0;
      }
    }
  }
  else
  {
    BYTE1(v4) = a2;
    v6 = v4;
    v4 <<= 16;
    LOWORD(v4) = v6;
    if ( ((unsigned __int8)a1 & 3) == 0 )
      goto LABEL_20;
    if ( *a1 != (_BYTE)v6 )
    {
      result = a1 + 1;
      v5 = a3 - 1;
      if ( ((unsigned __int8)result & 3) != 0 )
      {
        if ( *result != (_BYTE)v6 )
        {
          result = a1 + 2;
          v5 = a3 - 2;
          if ( ((unsigned __int8)result & 3) == 0 )
            goto LABEL_20;
          if ( *result != (_BYTE)v6 )
          {
            result = a1 + 3;
            v5 = a3 - 3;
            goto LABEL_20;
          }
        }
      }
      else
      {
LABEL_20:
        while ( 1 )
        {
          v8 = v5 < 0x10;
          v5 -= 16;
          if ( v8 )
            break;
          v7 = v4 ^ *(_DWORD *)result;
          if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
            goto LABEL_41;
          v7 = v4 ^ *((_DWORD *)result + 1);
          if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
            goto LABEL_40;
          v7 = v4 ^ *((_DWORD *)result + 2);
          if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
            goto LABEL_39;
          v7 = v4 ^ *((_DWORD *)result + 3);
          if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
          {
            result += 4;
LABEL_39:
            result += 4;
LABEL_40:
            result += 4;
            goto LABEL_41;
          }
          result += 16;
        }
        if ( v5 < 0xFFFFFFF4 )
          goto LABEL_31;
        v7 = v4 ^ *(_DWORD *)result;
        if ( v7 >= 0x1010101 && (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) == -1 )
        {
          result += 4;
          if ( v5 < 0xFFFFFFF8 )
            goto LABEL_31;
          v7 = v4 ^ *(_DWORD *)result;
          if ( v7 >= 0x1010101 && (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) == -1 )
          {
            result += 4;
            if ( v5 < 0xFFFFFFFC )
              goto LABEL_31;
            v7 = v4 ^ *(_DWORD *)result;
            if ( v7 >= 0x1010101 && (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) == -1 )
            {
              result += 4;
              goto LABEL_31;
            }
          }
        }
LABEL_41:
        if ( (_BYTE)v7 )
        {
          ++result;
          if ( BYTE1(v7) )
          {
            ++result;
            if ( (v7 & 0xFF0000) != 0 )
              ++result;
          }
        }
      }
    }
  }
  return result;
}
// 805CC23: conditional instruction was optimized away because %arg_8.4>=4u
// 805CC3B: conditional instruction was optimized away because %arg_8.4>=4u

//----- (0805CD90) --------------------------------------------------------
int (__cdecl *memcmp())(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  int (__cdecl *result)(unsigned __int8 *, unsigned __int8 *, unsigned int); // eax

  result = (int (__cdecl *)(unsigned __int8 *, unsigned __int8 *, unsigned int))_memcmp_ia32;
  if ( (dword_80EC570 & 0x200) != 0 )
  {
    result = (int (__cdecl *)(unsigned __int8 *, unsigned __int8 *, unsigned int))_memcmp_ssse3;
    if ( (dword_80EC570 & 0x100000) != 0 )
      return _memcmp_sse4_2;
  }
  return result;
}
// 80EC570: using guessed type int dword_80EC570;

//----- (0805CDC0) --------------------------------------------------------
int __cdecl _memcmp_ia32(unsigned int *a1, unsigned int *a2, int a3)
{
  unsigned int *v3; // edx
  int v4; // ecx
  int result; // eax
  unsigned int *v6; // esi
  char *v7; // edx
  char *v8; // esi
  unsigned int v9; // eax
  unsigned int v10; // ecx
  unsigned __int8 v11; // al
  bool v12; // cf
  unsigned int v13; // eax
  unsigned int v14; // ecx
  unsigned int v15; // eax
  unsigned int v16; // ecx
  unsigned __int8 v17; // al
  unsigned int v18; // eax
  unsigned int v19; // ecx

  v3 = a2;
  v4 = a3;
  if ( a3 == 1 )
  {
    if ( *(_BYTE *)a1 == *(_BYTE *)a2 )
      return 0;
    return -(*(_BYTE *)a1 < *(_BYTE *)a2) - ((*(_BYTE *)a1 < *(_BYTE *)a2) - 1);
  }
  else
  {
    if ( a3 < 1 )
      return 0;
    v6 = a1;
    if ( a3 < 32 )
    {
      v7 = (char *)a2 + a3;
      v8 = (char *)a1 + a3;
      switch ( a3 )
      {
        case 0:
          return 0;
        case 1:
          goto LABEL_23;
        case 2:
          goto LABEL_32;
        case 3:
          goto LABEL_42;
        case 4:
          goto LABEL_14;
        case 5:
          goto LABEL_22;
        case 6:
          goto LABEL_31;
        case 7:
          goto LABEL_41;
        case 8:
          goto LABEL_13;
        case 9:
          goto LABEL_21;
        case 10:
          goto LABEL_30;
        case 11:
          goto LABEL_40;
        case 12:
          goto LABEL_12;
        case 13:
          goto LABEL_20;
        case 14:
          goto LABEL_29;
        case 15:
          goto LABEL_39;
        case 16:
          goto LABEL_11;
        case 17:
          goto LABEL_19;
        case 18:
          goto LABEL_28;
        case 19:
          goto LABEL_38;
        case 20:
          goto LABEL_10;
        case 21:
          goto LABEL_18;
        case 22:
          goto LABEL_27;
        case 23:
          goto LABEL_37;
        case 24:
          goto LABEL_9;
        case 25:
          goto LABEL_17;
        case 26:
          goto LABEL_26;
        case 27:
          goto LABEL_36;
        case 28:
          goto LABEL_8;
        case 29:
          goto LABEL_16;
        case 30:
          goto LABEL_25;
        case 31:
          goto LABEL_35;
      }
    }
    do
    {
      v4 -= 32;
      v9 = *v6;
      if ( *v6 != *v3 )
        goto LABEL_63;
      v9 = v6[1];
      if ( v9 != v3[1] )
        goto LABEL_62;
      v9 = v6[2];
      if ( v9 != v3[2] )
        goto LABEL_61;
      v9 = v6[3];
      if ( v9 != v3[3] )
        goto LABEL_60;
      v9 = v6[4];
      if ( v9 != v3[4] )
        goto LABEL_59;
      v9 = v6[5];
      if ( v9 != v3[5] )
        goto LABEL_58;
      v9 = v6[6];
      if ( v9 != v3[6] )
        goto LABEL_57;
      v9 = v6[7];
      if ( v9 != v3[7] )
      {
        ++v3;
LABEL_57:
        ++v3;
LABEL_58:
        ++v3;
LABEL_59:
        ++v3;
LABEL_60:
        ++v3;
LABEL_61:
        ++v3;
LABEL_62:
        ++v3;
LABEL_63:
        v10 = *v3;
LABEL_64:
        v12 = (unsigned __int8)v9 < (unsigned __int8)v10;
        if ( (_BYTE)v9 == (_BYTE)v10 )
        {
          v12 = BYTE1(v9) < BYTE1(v10);
          if ( BYTE1(v9) == BYTE1(v10) )
          {
            v18 = HIWORD(v9);
            v19 = HIWORD(v10);
            v12 = (unsigned __int8)v18 < (unsigned __int8)v19;
            if ( (_BYTE)v18 == (_BYTE)v19 )
              v12 = v18 < v19;
          }
        }
        return -v12 - (v12 - 1);
      }
      v6 += 8;
      v3 += 8;
    }
    while ( v4 >= 32 );
    v7 = (char *)v3 + v4;
    v8 = (char *)v6 + v4;
    switch ( v4 )
    {
      case 0:
        return 0;
      case 1:
        goto LABEL_23;
      case 2:
        goto LABEL_32;
      case 3:
        goto LABEL_42;
      case 4:
        goto LABEL_14;
      case 5:
        goto LABEL_22;
      case 6:
        goto LABEL_31;
      case 7:
        goto LABEL_41;
      case 8:
        goto LABEL_13;
      case 9:
        goto LABEL_21;
      case 10:
        goto LABEL_30;
      case 11:
        goto LABEL_40;
      case 12:
        goto LABEL_12;
      case 13:
        goto LABEL_20;
      case 14:
        goto LABEL_29;
      case 15:
        goto LABEL_39;
      case 16:
        goto LABEL_11;
      case 17:
        goto LABEL_19;
      case 18:
        goto LABEL_28;
      case 19:
        goto LABEL_38;
      case 20:
        goto LABEL_10;
      case 21:
        goto LABEL_18;
      case 22:
        goto LABEL_27;
      case 23:
        goto LABEL_37;
      case 24:
        goto LABEL_9;
      case 25:
        goto LABEL_17;
      case 26:
        goto LABEL_26;
      case 27:
        goto LABEL_36;
      case 28:
LABEL_8:
        v9 = *((_DWORD *)v8 - 7);
        v10 = *((_DWORD *)v7 - 7);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_9:
        v9 = *((_DWORD *)v8 - 6);
        v10 = *((_DWORD *)v7 - 6);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_10:
        v9 = *((_DWORD *)v8 - 5);
        v10 = *((_DWORD *)v7 - 5);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_11:
        v9 = *((_DWORD *)v8 - 4);
        v10 = *((_DWORD *)v7 - 4);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_12:
        v9 = *((_DWORD *)v8 - 3);
        v10 = *((_DWORD *)v7 - 3);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_13:
        v9 = *((_DWORD *)v8 - 2);
        v10 = *((_DWORD *)v7 - 2);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_14:
        v9 = *((_DWORD *)v8 - 1);
        v10 = *((_DWORD *)v7 - 1);
        if ( v9 != v10 )
          goto LABEL_64;
        return 0;
      case 29:
LABEL_16:
        v9 = *(_DWORD *)(v8 - 29);
        v10 = *(_DWORD *)(v7 - 29);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_17:
        v9 = *(_DWORD *)(v8 - 25);
        v10 = *(_DWORD *)(v7 - 25);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_18:
        v9 = *(_DWORD *)(v8 - 21);
        v10 = *(_DWORD *)(v7 - 21);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_19:
        v9 = *(_DWORD *)(v8 - 17);
        v10 = *(_DWORD *)(v7 - 17);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_20:
        v9 = *(_DWORD *)(v8 - 13);
        v10 = *(_DWORD *)(v7 - 13);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_21:
        v9 = *(_DWORD *)(v8 - 9);
        v10 = *(_DWORD *)(v7 - 9);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_22:
        v9 = *(_DWORD *)(v8 - 5);
        v10 = *(_DWORD *)(v7 - 5);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_23:
        v11 = *(v8 - 1);
        v12 = v11 < (unsigned __int8)*(v7 - 1);
        if ( v11 != *(v7 - 1) )
          return -v12 - (v12 - 1);
        result = 0;
        break;
      case 30:
LABEL_25:
        v9 = *(_DWORD *)(v8 - 30);
        v10 = *(_DWORD *)(v7 - 30);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_26:
        v9 = *(_DWORD *)(v8 - 26);
        v10 = *(_DWORD *)(v7 - 26);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_27:
        v9 = *(_DWORD *)(v8 - 22);
        v10 = *(_DWORD *)(v7 - 22);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_28:
        v9 = *(_DWORD *)(v8 - 18);
        v10 = *(_DWORD *)(v7 - 18);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_29:
        v9 = *(_DWORD *)(v8 - 14);
        v10 = *(_DWORD *)(v7 - 14);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_30:
        v9 = *(_DWORD *)(v8 - 10);
        v10 = *(_DWORD *)(v7 - 10);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_31:
        v9 = *(_DWORD *)(v8 - 6);
        v10 = *(_DWORD *)(v7 - 6);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_32:
        v13 = *((unsigned __int16 *)v8 - 1);
        v14 = *((unsigned __int16 *)v7 - 1);
        v12 = (unsigned __int8)v13 < (unsigned __int8)v14;
        if ( (_BYTE)v13 != (_BYTE)v14 )
          return -v12 - (v12 - 1);
        v12 = v13 < v14;
        if ( v13 != v14 )
          return -v12 - (v12 - 1);
        result = 0;
        break;
      case 31:
LABEL_35:
        v9 = *(_DWORD *)(v8 - 31);
        v10 = *(_DWORD *)(v7 - 31);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_36:
        v9 = *(_DWORD *)(v8 - 27);
        v10 = *(_DWORD *)(v7 - 27);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_37:
        v9 = *(_DWORD *)(v8 - 23);
        v10 = *(_DWORD *)(v7 - 23);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_38:
        v9 = *(_DWORD *)(v8 - 19);
        v10 = *(_DWORD *)(v7 - 19);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_39:
        v9 = *(_DWORD *)(v8 - 15);
        v10 = *(_DWORD *)(v7 - 15);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_40:
        v9 = *(_DWORD *)(v8 - 11);
        v10 = *(_DWORD *)(v7 - 11);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_41:
        v9 = *(_DWORD *)(v8 - 7);
        v10 = *(_DWORD *)(v7 - 7);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_42:
        v15 = *(unsigned __int16 *)(v8 - 3);
        v16 = *(unsigned __int16 *)(v7 - 3);
        v12 = (unsigned __int8)v15 < (unsigned __int8)v16;
        if ( (_BYTE)v15 != (_BYTE)v16 )
          return -v12 - (v12 - 1);
        v12 = v15 < v16;
        if ( v15 != v16 )
          return -v12 - (v12 - 1);
        v17 = *(v8 - 1);
        v12 = v17 < (unsigned __int8)*(v7 - 1);
        if ( v17 != *(v7 - 1) )
          return -v12 - (v12 - 1);
        result = 0;
        break;
    }
  }
  return result;
}

//----- (0805D0A0) --------------------------------------------------------
unsigned int (__usercall *memmove())@<eax>(const __m128i *a1@<esi>, unsigned int a2, _DWORD *a3, unsigned int a4)
{
  unsigned int (__usercall *result)@<eax>(const __m128i *@<esi>, unsigned int, _DWORD *, unsigned int); // eax

  result = (unsigned int (__usercall *)@<eax>(const __m128i *@<esi>, unsigned int, _DWORD *, unsigned int))_memmove_ia32;
  if ( (unk_80EC574 & 0x4000000) != 0 )
  {
    result = (unsigned int (__usercall *)@<eax>(const __m128i *@<esi>, unsigned int, _DWORD *, unsigned int))_memmove_sse2_unaligned;
    if ( (dword_80EC5A0 & 0x10) == 0 && (dword_80EC570 & 0x200) != 0 )
    {
      result = (unsigned int (__usercall *)@<eax>(const __m128i *@<esi>, unsigned int, _DWORD *, unsigned int))_memmove_ssse3;
      if ( (dword_80EC5A0 & 1) != 0 )
        return _memmove_ssse3_rep;
    }
  }
  return result;
}
// 80EC570: using guessed type int dword_80EC570;
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (0805D0F0) --------------------------------------------------------
_BYTE *__cdecl _memmove_ia32(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  _WORD *v3; // edi
  _WORD *v4; // esi
  _BYTE *v6; // edi
  _BYTE *v7; // esi
  _WORD *v8; // edi
  _WORD *v9; // esi

  v3 = a1;
  v4 = a2;
  if ( a3 > a1 - a2 )
  {
    v6 = &a1[a3 - 1];
    v7 = &a2[a3 - 1];
    if ( a3 & 1 )
    {
      *v6 = *v7;
      v7 = &a2[a3 - 2];
      v6 = &a1[a3 - 2];
    }
    v8 = v6 - 1;
    v9 = v7 - 1;
    if ( (a3 & 2) != 0 )
      *v8++ = *v9++;
    qmemcpy(v8 - 1, v9 - 1, 4 * (a3 >> 2));
    return a1;
  }
  else
  {
    if ( a3 & 1 )
    {
      *a1 = *a2;
      v4 = a2 + 1;
      v3 = a1 + 1;
    }
    if ( (a3 & 2) != 0 )
      *v3++ = *v4++;
    qmemcpy(v3, v4, 4 * (a3 >> 2));
    return a1;
  }
}

//----- (0805D150) --------------------------------------------------------
int (__cdecl *memset())(int a1, unsigned __int8 a2, unsigned int a3)
{
  int (__cdecl *result)(int, unsigned __int8, unsigned int); // eax

  result = (int (__cdecl *)(int, unsigned __int8, unsigned int))_memset_ia32;
  if ( (unk_80EC574 & 0x4000000) != 0 )
  {
    result = _memset_sse2;
    if ( (dword_80EC5A0 & 1) != 0 )
      return _memset_sse2_rep;
  }
  return result;
}
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (0805D180) --------------------------------------------------------
unsigned __int8 *__cdecl _memset_ia32(unsigned __int8 *a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int v3; // ecx
  unsigned __int8 *v4; // edi
  int v5; // edx
  char v6; // dl
  unsigned int v7; // ecx

  v3 = a3;
  if ( a3 )
  {
    v4 = a1;
    v5 = (unsigned __int8)a1 & 3;
    if ( ((unsigned __int8)a1 & 3) == 0 )
    {
LABEL_8:
      v6 = v3;
      v7 = v3 >> 2;
      memset32(v4, 16843009 * a2, v7);
      memset(&v4[4 * v7], a2, v6 & 3);
      return a1;
    }
    if ( __SETP__(v5, 0) || (*a1 = a2, v4 = a1 + 1, v3 = a3 - 1, a3 != 1) )
    {
      *v4++ = a2;
      if ( --v3 )
      {
        if ( v5 == 1 )
        {
          *v4++ = a2;
          --v3;
        }
        goto LABEL_8;
      }
    }
  }
  return a1;
}

//----- (0805D1D0) --------------------------------------------------------
_WORD *__cdecl mempcpy(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  _WORD *v3; // edi
  _WORD *v4; // esi
  unsigned int v5; // ecx

  v3 = a1;
  v4 = a2;
  if ( a3 & 1 )
  {
    *a1 = *a2;
    v4 = a2 + 1;
    v3 = a1 + 1;
  }
  v5 = a3 >> 2;
  if ( (a3 & 2) != 0 )
    *v3++ = *v4++;
  qmemcpy(v3, v4, 4 * v5);
  return &v3[2 * v5];
}

//----- (0805D200) --------------------------------------------------------
unsigned int (__cdecl *stpcpy())(unsigned int a1, unsigned int a2)
{
  unsigned int (__cdecl *result)(unsigned int, unsigned int); // eax

  result = (unsigned int (__cdecl *)(unsigned int, unsigned int))_stpcpy_ia32;
  if ( (unk_80EC574 & 0x4000000) != 0 )
  {
    result = (unsigned int (__cdecl *)(unsigned int, unsigned int))_stpcpy_sse2;
    if ( (dword_80EC5A0 & 0x10) == 0 && (dword_80EC570 & 0x200) != 0 )
      return _stpcpy_ssse3;
  }
  return result;
}
// 80EC570: using guessed type int dword_80EC570;
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (0805D240) --------------------------------------------------------
void __cdecl _stpcpy_ia32(int a1, char a2)
{
  __asm { jmp     ecx }
}
// 805D25F: unbalanced stack, ignored a potential tail call

//----- (0805D2D0) --------------------------------------------------------
int (__cdecl *strcasecmp_l())(char *a1, unsigned __int8 *a2, int a3)
{
  int (__cdecl *result)(char *, unsigned __int8 *, int); // eax

  result = _strcasecmp_l_nonascii;
  if ( (dword_80EC570 & 0x200) != 0 )
  {
    result = _strcasecmp_l_ssse3;
    if ( (dword_80EC570 & 0x100000) != 0 && (dword_80EC5A0 & 0x200) == 0 )
      return _strcasecmp_l_sse4_2;
  }
  return result;
}
// 80EC570: using guessed type int dword_80EC570;
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (0805D310) --------------------------------------------------------
_BYTE *__cdecl memcpy(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  _WORD *v3; // edi
  _WORD *v4; // esi
  unsigned int v5; // ecx

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( (((unsigned __int8)a2 ^ (unsigned __int8)a1) & 3) != 0 || a3 <= 3 )
  {
    if ( a3 & 1 )
    {
      *a1 = *a2;
      v4 = a2 + 1;
      v3 = a1 + 1;
    }
    if ( (a3 & 2) != 0 )
      *v3++ = *v4++;
    qmemcpy(v3, v4, 4 * (a3 >> 2));
  }
  else
  {
    if ( ((unsigned __int8)a2 & 3) != 0 )
    {
      *a1 = *a2;
      v4 = a2 + 1;
      v3 = a1 + 1;
      v5 = a3 - 1;
      if ( ((unsigned int)(a2 + 1) & 3) != 0 )
      {
        *(_BYTE *)v3 = *(_BYTE *)v4;
        v4 = a2 + 2;
        v3 = a1 + 2;
        v5 = a3 - 2;
        if ( ((unsigned int)(a2 + 2) & 3) != 0 )
        {
          *(_BYTE *)v3 = *(_BYTE *)v4;
          v4 = a2 + 3;
          v3 = a1 + 3;
          v5 = a3 - 3;
        }
      }
    }
    qmemcpy(v3, v4, v5);
  }
  return a1;
}

//----- (0805D380) --------------------------------------------------------
int (__cdecl *rawmemchr())(const __m128i *a1, unsigned int a2)
{
  if ( (unk_80EC574 & 0x4000000) == 0 )
    return (int (__cdecl *)(const __m128i *, unsigned int))_rawmemchr_ia32;
  if ( (dword_80EC5A0 & 4) != 0 )
    return (int (__cdecl *)(const __m128i *, unsigned int))_rawmemchr_sse2;
  return _rawmemchr_sse2_bsf;
}
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (0805D3B0) --------------------------------------------------------
_BYTE *__cdecl _rawmemchr_ia32(_BYTE *a1, int a2)
{
  _BYTE *result; // eax
  int v3; // edx
  __int16 v4; // cx
  int v5; // edx
  unsigned int v6; // ecx

  result = a1;
  v3 = a2;
  BYTE1(v3) = a2;
  v4 = v3;
  v5 = v3 << 16;
  LOWORD(v5) = v4;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( *a1 != (_BYTE)v4 )
    {
      result = a1 + 1;
      if ( (((_BYTE)a1 + 1) & 3) == 0 )
        goto LABEL_8;
      if ( *result != (_BYTE)v4 )
      {
        result = a1 + 2;
        if ( (((_BYTE)a1 + 2) & 3) == 0 )
          goto LABEL_8;
        if ( *result != (_BYTE)v4 )
        {
          result = a1 + 3;
          goto LABEL_8;
        }
      }
    }
  }
  else
  {
LABEL_8:
    while ( 1 )
    {
      v6 = v5 ^ *(_DWORD *)result;
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v6 = v5 ^ *((_DWORD *)result + 1);
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_19;
      v6 = v5 ^ *((_DWORD *)result + 2);
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_18;
      v6 = v5 ^ *((_DWORD *)result + 3);
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
      {
        result += 4;
LABEL_18:
        result += 4;
LABEL_19:
        result += 4;
        break;
      }
      result += 16;
    }
    if ( (_BYTE)v6 )
    {
      ++result;
      if ( BYTE1(v6) )
      {
        ++result;
        if ( (v6 & 0xFF0000) != 0 )
          ++result;
      }
    }
  }
  return result;
}

//----- (0805D480) --------------------------------------------------------
unsigned int *__cdecl strchrnul(unsigned int *a1, int a2)
{
  unsigned int *result; // eax
  int v3; // edx
  __int16 v4; // cx
  int v5; // edx
  unsigned int v6; // ecx
  unsigned int v7; // ecx

  result = a1;
  v3 = a2;
  BYTE1(v3) = a2;
  v4 = v3;
  v5 = v3 << 16;
  LOWORD(v5) = v4;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( (_BYTE)v4 != *(_BYTE *)a1 && *(_BYTE *)a1 )
    {
      result = (unsigned int *)((char *)a1 + 1);
      if ( (((_BYTE)a1 + 1) & 3) == 0 )
        goto LABEL_12;
      if ( (_BYTE)v4 != *(_BYTE *)result && *(_BYTE *)result )
      {
        result = (unsigned int *)((char *)a1 + 2);
        if ( (((_BYTE)a1 + 2) & 3) == 0 )
          goto LABEL_12;
        if ( (_BYTE)v4 != *(_BYTE *)result && *(_BYTE *)result )
        {
          result = (unsigned int *)((char *)a1 + 3);
          goto LABEL_12;
        }
      }
    }
  }
  else
  {
LABEL_12:
    while ( 1 )
    {
      v6 = v5 ^ *result;
      if ( v6 < 0x1010101 )
        break;
      if ( (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v6 = *result;
      if ( *result < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v6 = v5 ^ result[1];
      if ( v6 < 0x1010101 )
        goto LABEL_30;
      if ( (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_30;
      v6 = result[1];
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_30;
      v6 = v5 ^ result[2];
      if ( v6 < 0x1010101 )
        goto LABEL_29;
      if ( (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_29;
      v6 = result[2];
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_29;
      v6 = v5 ^ result[3];
      if ( v6 < 0x1010101
        || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1
        || (v6 = result[3], v6 < 0x1010101)
        || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
      {
        ++result;
LABEL_29:
        ++result;
LABEL_30:
        ++result;
        break;
      }
      result += 4;
    }
    if ( (_BYTE)v6 )
    {
      if ( (_BYTE)v6 != (_BYTE)v5 )
      {
        result = (unsigned int *)((char *)result + 1);
        if ( BYTE1(v6) )
        {
          if ( BYTE1(v6) != (_BYTE)v5 )
          {
            result = (unsigned int *)((char *)result + 1);
            v7 = HIWORD(v6);
            if ( (_BYTE)v7 )
            {
              if ( (_BYTE)v7 != (_BYTE)v5 )
                return (unsigned int *)((char *)result + 1);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0805D5E0) --------------------------------------------------------
int __cdecl _memset_sse2(int a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax
  unsigned int v6; // edx
  int result; // eax
  __m128i v8; // xmm0
  __m128i *v9; // edx
  unsigned int v10; // ebx
  unsigned int v11; // ecx
  bool v12; // cf
  unsigned int v13; // ecx
  unsigned int v14; // ecx

  v3 = a3;
  v4 = a2;
  BYTE1(v4) = a2;
  v5 = v4 | (v4 << 16);
  v6 = a3 + a1;
  switch ( a3 )
  {
    case 0u:
      goto LABEL_9;
    case 1u:
      goto LABEL_17;
    case 2u:
      goto LABEL_25;
    case 3u:
      goto LABEL_33;
    case 4u:
      goto LABEL_8;
    case 5u:
      goto LABEL_16;
    case 6u:
      goto LABEL_24;
    case 7u:
      goto LABEL_32;
    case 8u:
      goto LABEL_7;
    case 9u:
      goto LABEL_15;
    case 0xAu:
      goto LABEL_23;
    case 0xBu:
      goto LABEL_31;
    case 0xCu:
      goto LABEL_6;
    case 0xDu:
      goto LABEL_14;
    case 0xEu:
      goto LABEL_22;
    case 0xFu:
      goto LABEL_30;
    case 0x10u:
      goto LABEL_5;
    case 0x11u:
      goto LABEL_13;
    case 0x12u:
      goto LABEL_21;
    case 0x13u:
      goto LABEL_29;
    case 0x14u:
      goto LABEL_4;
    case 0x15u:
      goto LABEL_12;
    case 0x16u:
      goto LABEL_20;
    case 0x17u:
      goto LABEL_28;
    case 0x18u:
      goto LABEL_3;
    case 0x19u:
      goto LABEL_11;
    case 0x1Au:
      goto LABEL_19;
    case 0x1Bu:
      goto LABEL_27;
    case 0x1Cu:
      *(_DWORD *)(v6 - 28) = v5;
LABEL_3:
      *(_DWORD *)(v6 - 24) = v5;
LABEL_4:
      *(_DWORD *)(v6 - 20) = v5;
LABEL_5:
      *(_DWORD *)(v6 - 16) = v5;
LABEL_6:
      *(_DWORD *)(v6 - 12) = v5;
LABEL_7:
      *(_DWORD *)(v6 - 8) = v5;
LABEL_8:
      *(_DWORD *)(v6 - 4) = v5;
LABEL_9:
      result = a1;
      break;
    case 0x1Du:
      *(_DWORD *)(v6 - 29) = v5;
LABEL_11:
      *(_DWORD *)(v6 - 25) = v5;
LABEL_12:
      *(_DWORD *)(v6 - 21) = v5;
LABEL_13:
      *(_DWORD *)(v6 - 17) = v5;
LABEL_14:
      *(_DWORD *)(v6 - 13) = v5;
LABEL_15:
      *(_DWORD *)(v6 - 9) = v5;
LABEL_16:
      *(_DWORD *)(v6 - 5) = v5;
LABEL_17:
      *(_BYTE *)(v6 - 1) = v5;
      result = a1;
      break;
    case 0x1Eu:
      *(_DWORD *)(v6 - 30) = v5;
LABEL_19:
      *(_DWORD *)(v6 - 26) = v5;
LABEL_20:
      *(_DWORD *)(v6 - 22) = v5;
LABEL_21:
      *(_DWORD *)(v6 - 18) = v5;
LABEL_22:
      *(_DWORD *)(v6 - 14) = v5;
LABEL_23:
      *(_DWORD *)(v6 - 10) = v5;
LABEL_24:
      *(_DWORD *)(v6 - 6) = v5;
LABEL_25:
      *(_WORD *)(v6 - 2) = v5;
      result = a1;
      break;
    case 0x1Fu:
      *(_DWORD *)(v6 - 31) = v5;
LABEL_27:
      *(_DWORD *)(v6 - 27) = v5;
LABEL_28:
      *(_DWORD *)(v6 - 23) = v5;
LABEL_29:
      *(_DWORD *)(v6 - 19) = v5;
LABEL_30:
      *(_DWORD *)(v6 - 15) = v5;
LABEL_31:
      *(_DWORD *)(v6 - 11) = v5;
LABEL_32:
      *(_DWORD *)(v6 - 7) = v5;
LABEL_33:
      *(_WORD *)(v6 - 3) = v5;
      *(_BYTE *)(v6 - 1) = v5;
      result = a1;
      break;
    default:
      v8 = _mm_shuffle_epi32(_mm_cvtsi32_si128(v5), 0);
      if ( (v6 & 0xF) != 0 )
      {
        *(__m128i *)v6 = v8;
        v6 = (v6 & 0xFFFFFFF0) + 16;
        v3 = a3 + a1 - v6 + a3;
        v5 = _mm_cvtsi128_si32(v8);
      }
      v9 = (__m128i *)(v3 + v6);
      switch ( v3 )
      {
        case 0u:
          goto LABEL_56;
        case 1u:
          goto LABEL_64;
        case 2u:
          goto LABEL_72;
        case 3u:
          goto LABEL_80;
        case 4u:
          goto LABEL_88;
        case 5u:
          goto LABEL_96;
        case 6u:
          goto LABEL_104;
        case 7u:
          goto LABEL_112;
        case 8u:
          goto LABEL_120;
        case 9u:
          goto LABEL_128;
        case 0xAu:
          goto LABEL_136;
        case 0xBu:
          goto LABEL_144;
        case 0xCu:
          goto LABEL_152;
        case 0xDu:
          goto LABEL_160;
        case 0xEu:
          goto LABEL_168;
        case 0xFu:
          goto LABEL_176;
        case 0x10u:
          goto LABEL_55;
        case 0x11u:
          goto LABEL_63;
        case 0x12u:
          goto LABEL_71;
        case 0x13u:
          goto LABEL_79;
        case 0x14u:
          goto LABEL_87;
        case 0x15u:
          goto LABEL_95;
        case 0x16u:
          goto LABEL_103;
        case 0x17u:
          goto LABEL_111;
        case 0x18u:
          goto LABEL_119;
        case 0x19u:
          goto LABEL_127;
        case 0x1Au:
          goto LABEL_135;
        case 0x1Bu:
          goto LABEL_143;
        case 0x1Cu:
          goto LABEL_151;
        case 0x1Du:
          goto LABEL_159;
        case 0x1Eu:
          goto LABEL_167;
        case 0x1Fu:
          goto LABEL_175;
        case 0x20u:
          goto LABEL_54;
        case 0x21u:
          goto LABEL_62;
        case 0x22u:
          goto LABEL_70;
        case 0x23u:
          goto LABEL_78;
        case 0x24u:
          goto LABEL_86;
        case 0x25u:
          goto LABEL_94;
        case 0x26u:
          goto LABEL_102;
        case 0x27u:
          goto LABEL_110;
        case 0x28u:
          goto LABEL_118;
        case 0x29u:
          goto LABEL_126;
        case 0x2Au:
          goto LABEL_134;
        case 0x2Bu:
          goto LABEL_142;
        case 0x2Cu:
          goto LABEL_150;
        case 0x2Du:
          goto LABEL_158;
        case 0x2Eu:
          goto LABEL_166;
        case 0x2Fu:
          goto LABEL_174;
        case 0x30u:
          goto LABEL_53;
        case 0x31u:
          goto LABEL_61;
        case 0x32u:
          goto LABEL_69;
        case 0x33u:
          goto LABEL_77;
        case 0x34u:
          goto LABEL_85;
        case 0x35u:
          goto LABEL_93;
        case 0x36u:
          goto LABEL_101;
        case 0x37u:
          goto LABEL_109;
        case 0x38u:
          goto LABEL_117;
        case 0x39u:
          goto LABEL_125;
        case 0x3Au:
          goto LABEL_133;
        case 0x3Bu:
          goto LABEL_141;
        case 0x3Cu:
          goto LABEL_149;
        case 0x3Du:
          goto LABEL_157;
        case 0x3Eu:
          goto LABEL_165;
        case 0x3Fu:
          goto LABEL_173;
        case 0x40u:
          goto LABEL_52;
        case 0x41u:
          goto LABEL_60;
        case 0x42u:
          goto LABEL_68;
        case 0x43u:
          goto LABEL_76;
        case 0x44u:
          goto LABEL_84;
        case 0x45u:
          goto LABEL_92;
        case 0x46u:
          goto LABEL_100;
        case 0x47u:
          goto LABEL_108;
        case 0x48u:
          goto LABEL_116;
        case 0x49u:
          goto LABEL_124;
        case 0x4Au:
          goto LABEL_132;
        case 0x4Bu:
          goto LABEL_140;
        case 0x4Cu:
          goto LABEL_148;
        case 0x4Du:
          goto LABEL_156;
        case 0x4Eu:
          goto LABEL_164;
        case 0x4Fu:
          goto LABEL_172;
        case 0x50u:
          goto LABEL_51;
        case 0x51u:
          goto LABEL_59;
        case 0x52u:
          goto LABEL_67;
        case 0x53u:
          goto LABEL_75;
        case 0x54u:
          goto LABEL_83;
        case 0x55u:
          goto LABEL_91;
        case 0x56u:
          goto LABEL_99;
        case 0x57u:
          goto LABEL_107;
        case 0x58u:
          goto LABEL_115;
        case 0x59u:
          goto LABEL_123;
        case 0x5Au:
          goto LABEL_131;
        case 0x5Bu:
          goto LABEL_139;
        case 0x5Cu:
          goto LABEL_147;
        case 0x5Du:
          goto LABEL_155;
        case 0x5Eu:
          goto LABEL_163;
        case 0x5Fu:
          goto LABEL_171;
        case 0x60u:
          goto LABEL_50;
        case 0x61u:
          goto LABEL_58;
        case 0x62u:
          goto LABEL_66;
        case 0x63u:
          goto LABEL_74;
        case 0x64u:
          goto LABEL_82;
        case 0x65u:
          goto LABEL_90;
        case 0x66u:
          goto LABEL_98;
        case 0x67u:
          goto LABEL_106;
        case 0x68u:
          goto LABEL_114;
        case 0x69u:
          goto LABEL_122;
        case 0x6Au:
          goto LABEL_130;
        case 0x6Bu:
          goto LABEL_138;
        case 0x6Cu:
          goto LABEL_146;
        case 0x6Du:
          goto LABEL_154;
        case 0x6Eu:
          goto LABEL_162;
        case 0x6Fu:
          goto LABEL_170;
        case 0x70u:
LABEL_49:
          v9[-7] = v8;
LABEL_50:
          v9[-6] = v8;
LABEL_51:
          v9[-5] = v8;
LABEL_52:
          v9[-4] = v8;
LABEL_53:
          v9[-3] = v8;
LABEL_54:
          v9[-2] = v8;
LABEL_55:
          v9[-1] = v8;
LABEL_56:
          result = a1;
          break;
        case 0x71u:
LABEL_57:
          *(__m128i *)((char *)v9 - 113) = v8;
LABEL_58:
          *(__m128i *)((char *)v9 - 97) = v8;
LABEL_59:
          *(__m128i *)((char *)v9 - 81) = v8;
LABEL_60:
          *(__m128i *)((char *)v9 - 65) = v8;
LABEL_61:
          *(__m128i *)((char *)v9 - 49) = v8;
LABEL_62:
          *(__m128i *)((char *)v9 - 33) = v8;
LABEL_63:
          *(__m128i *)((char *)v9 - 17) = v8;
LABEL_64:
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x72u:
LABEL_65:
          *(__m128i *)((char *)v9 - 114) = v8;
LABEL_66:
          *(__m128i *)((char *)v9 - 98) = v8;
LABEL_67:
          *(__m128i *)((char *)v9 - 82) = v8;
LABEL_68:
          *(__m128i *)((char *)v9 - 66) = v8;
LABEL_69:
          *(__m128i *)((char *)v9 - 50) = v8;
LABEL_70:
          *(__m128i *)((char *)v9 - 34) = v8;
LABEL_71:
          *(__m128i *)((char *)v9 - 18) = v8;
LABEL_72:
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x73u:
LABEL_73:
          *(__m128i *)((char *)v9 - 115) = v8;
LABEL_74:
          *(__m128i *)((char *)v9 - 99) = v8;
LABEL_75:
          *(__m128i *)((char *)v9 - 83) = v8;
LABEL_76:
          *(__m128i *)((char *)v9 - 67) = v8;
LABEL_77:
          *(__m128i *)((char *)v9 - 51) = v8;
LABEL_78:
          *(__m128i *)((char *)v9 - 35) = v8;
LABEL_79:
          *(__m128i *)((char *)v9 - 19) = v8;
LABEL_80:
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x74u:
LABEL_81:
          *(__m128i *)((char *)v9 - 116) = v8;
LABEL_82:
          *(__m128i *)((char *)v9 - 100) = v8;
LABEL_83:
          *(__m128i *)((char *)v9 - 84) = v8;
LABEL_84:
          *(__m128i *)((char *)v9 - 68) = v8;
LABEL_85:
          *(__m128i *)((char *)v9 - 52) = v8;
LABEL_86:
          *(__m128i *)((char *)v9 - 36) = v8;
LABEL_87:
          *(__m128i *)((char *)v9 - 20) = v8;
LABEL_88:
          v9[-1].m128i_i32[3] = v5;
          result = a1;
          break;
        case 0x75u:
LABEL_89:
          *(__m128i *)((char *)v9 - 117) = v8;
LABEL_90:
          *(__m128i *)((char *)v9 - 101) = v8;
LABEL_91:
          *(__m128i *)((char *)v9 - 85) = v8;
LABEL_92:
          *(__m128i *)((char *)v9 - 69) = v8;
LABEL_93:
          *(__m128i *)((char *)v9 - 53) = v8;
LABEL_94:
          *(__m128i *)((char *)v9 - 37) = v8;
LABEL_95:
          *(__m128i *)((char *)v9 - 21) = v8;
LABEL_96:
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 3) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x76u:
LABEL_97:
          *(__m128i *)((char *)v9 - 118) = v8;
LABEL_98:
          *(__m128i *)((char *)v9 - 102) = v8;
LABEL_99:
          *(__m128i *)((char *)v9 - 86) = v8;
LABEL_100:
          *(__m128i *)((char *)v9 - 70) = v8;
LABEL_101:
          *(__m128i *)((char *)v9 - 54) = v8;
LABEL_102:
          *(__m128i *)((char *)v9 - 38) = v8;
LABEL_103:
          *(__m128i *)((char *)v9 - 22) = v8;
LABEL_104:
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 2) = v5;
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x77u:
LABEL_105:
          *(__m128i *)((char *)v9 - 119) = v8;
LABEL_106:
          *(__m128i *)((char *)v9 - 103) = v8;
LABEL_107:
          *(__m128i *)((char *)v9 - 87) = v8;
LABEL_108:
          *(__m128i *)((char *)v9 - 71) = v8;
LABEL_109:
          *(__m128i *)((char *)v9 - 55) = v8;
LABEL_110:
          *(__m128i *)((char *)v9 - 39) = v8;
LABEL_111:
          *(__m128i *)((char *)v9 - 23) = v8;
LABEL_112:
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 1) = v5;
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x78u:
LABEL_113:
          *(__m128i *)((char *)v9 - 120) = v8;
LABEL_114:
          *(__m128i *)((char *)v9 - 104) = v8;
LABEL_115:
          *(__m128i *)((char *)v9 - 88) = v8;
LABEL_116:
          *(__m128i *)((char *)v9 - 72) = v8;
LABEL_117:
          *(__m128i *)((char *)v9 - 56) = v8;
LABEL_118:
          *(__m128i *)((char *)v9 - 40) = v8;
LABEL_119:
          *(__m128i *)((char *)v9 - 24) = v8;
LABEL_120:
          v9[-1].m128i_i64[1] = v8.m128i_i64[0];
          result = a1;
          break;
        case 0x79u:
LABEL_121:
          *(__m128i *)((char *)v9 - 121) = v8;
LABEL_122:
          *(__m128i *)((char *)v9 - 105) = v8;
LABEL_123:
          *(__m128i *)((char *)v9 - 89) = v8;
LABEL_124:
          *(__m128i *)((char *)v9 - 73) = v8;
LABEL_125:
          *(__m128i *)((char *)v9 - 57) = v8;
LABEL_126:
          *(__m128i *)((char *)v9 - 41) = v8;
LABEL_127:
          *(__m128i *)((char *)v9 - 25) = v8;
LABEL_128:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 7) = v8.m128i_i64[0];
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x7Au:
LABEL_129:
          *(__m128i *)((char *)v9 - 122) = v8;
LABEL_130:
          *(__m128i *)((char *)v9 - 106) = v8;
LABEL_131:
          *(__m128i *)((char *)v9 - 90) = v8;
LABEL_132:
          *(__m128i *)((char *)v9 - 74) = v8;
LABEL_133:
          *(__m128i *)((char *)v9 - 58) = v8;
LABEL_134:
          *(__m128i *)((char *)v9 - 42) = v8;
LABEL_135:
          *(__m128i *)((char *)v9 - 26) = v8;
LABEL_136:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 6) = v8.m128i_i64[0];
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x7Bu:
LABEL_137:
          *(__m128i *)((char *)v9 - 123) = v8;
LABEL_138:
          *(__m128i *)((char *)v9 - 107) = v8;
LABEL_139:
          *(__m128i *)((char *)v9 - 91) = v8;
LABEL_140:
          *(__m128i *)((char *)v9 - 75) = v8;
LABEL_141:
          *(__m128i *)((char *)v9 - 59) = v8;
LABEL_142:
          *(__m128i *)((char *)v9 - 43) = v8;
LABEL_143:
          *(__m128i *)((char *)v9 - 27) = v8;
LABEL_144:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 5) = v8.m128i_i64[0];
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x7Cu:
LABEL_145:
          *(__m128i *)((char *)v9 - 124) = v8;
LABEL_146:
          *(__m128i *)((char *)v9 - 108) = v8;
LABEL_147:
          *(__m128i *)((char *)v9 - 92) = v8;
LABEL_148:
          *(__m128i *)((char *)v9 - 76) = v8;
LABEL_149:
          *(__m128i *)((char *)v9 - 60) = v8;
LABEL_150:
          *(__m128i *)((char *)v9 - 44) = v8;
LABEL_151:
          *(__m128i *)((char *)v9 - 28) = v8;
LABEL_152:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 4) = v8.m128i_i64[0];
          v9[-1].m128i_i32[3] = v5;
          result = a1;
          break;
        case 0x7Du:
LABEL_153:
          *(__m128i *)((char *)v9 - 125) = v8;
LABEL_154:
          *(__m128i *)((char *)v9 - 109) = v8;
LABEL_155:
          *(__m128i *)((char *)v9 - 93) = v8;
LABEL_156:
          *(__m128i *)((char *)v9 - 77) = v8;
LABEL_157:
          *(__m128i *)((char *)v9 - 61) = v8;
LABEL_158:
          *(__m128i *)((char *)v9 - 45) = v8;
LABEL_159:
          *(__m128i *)((char *)v9 - 29) = v8;
LABEL_160:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 3) = v8.m128i_i64[0];
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 3) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x7Eu:
LABEL_161:
          *(__m128i *)((char *)v9 - 126) = v8;
LABEL_162:
          *(__m128i *)((char *)v9 - 110) = v8;
LABEL_163:
          *(__m128i *)((char *)v9 - 94) = v8;
LABEL_164:
          *(__m128i *)((char *)v9 - 78) = v8;
LABEL_165:
          *(__m128i *)((char *)v9 - 62) = v8;
LABEL_166:
          *(__m128i *)((char *)v9 - 46) = v8;
LABEL_167:
          *(__m128i *)((char *)v9 - 30) = v8;
LABEL_168:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 2) = v8.m128i_i64[0];
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 2) = v5;
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x7Fu:
LABEL_169:
          *(__m128i *)((char *)v9 - 127) = v8;
LABEL_170:
          *(__m128i *)((char *)v9 - 111) = v8;
LABEL_171:
          *(__m128i *)((char *)v9 - 95) = v8;
LABEL_172:
          *(__m128i *)((char *)v9 - 79) = v8;
LABEL_173:
          *(__m128i *)((char *)v9 - 63) = v8;
LABEL_174:
          *(__m128i *)((char *)v9 - 47) = v8;
LABEL_175:
          *(__m128i *)((char *)v9 - 31) = v8;
LABEL_176:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 1) = v8.m128i_i64[0];
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 1) = v5;
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        default:
          v10 = _x86_shared_cache_size;
          if ( v3 < _x86_shared_cache_size )
          {
            if ( v3 < _x86_data_cache_size )
            {
              v11 = v3 - 128;
              do
              {
                v12 = v11 < 0x80;
                v11 -= 128;
                *v9 = v8;
                v9[1] = v8;
                v9[2] = v8;
                v9[3] = v8;
                v9[4] = v8;
                v9[5] = v8;
                v9[6] = v8;
                v9[7] = v8;
                v9 += 8;
                if ( v12 )
                  break;
                v12 = v11 < 0x80;
                v11 -= 128;
                *v9 = v8;
                v9[1] = v8;
                v9[2] = v8;
                v9[3] = v8;
                v9[4] = v8;
                v9[5] = v8;
                v9[6] = v8;
                v9[7] = v8;
                v9 += 8;
              }
              while ( !v12 );
              v13 = v11 + 128;
              v9 = (__m128i *)((char *)v9 + v13);
              switch ( v13 )
              {
                case 0u:
                  goto LABEL_56;
                case 1u:
                  goto LABEL_64;
                case 2u:
                  goto LABEL_72;
                case 3u:
                  goto LABEL_80;
                case 4u:
                  goto LABEL_88;
                case 5u:
                  goto LABEL_96;
                case 6u:
                  goto LABEL_104;
                case 7u:
                  goto LABEL_112;
                case 8u:
                  goto LABEL_120;
                case 9u:
                  goto LABEL_128;
                case 0xAu:
                  goto LABEL_136;
                case 0xBu:
                  goto LABEL_144;
                case 0xCu:
                  goto LABEL_152;
                case 0xDu:
                  goto LABEL_160;
                case 0xEu:
                  goto LABEL_168;
                case 0xFu:
                  goto LABEL_176;
                case 0x10u:
                  goto LABEL_55;
                case 0x11u:
                  goto LABEL_63;
                case 0x12u:
                  goto LABEL_71;
                case 0x13u:
                  goto LABEL_79;
                case 0x14u:
                  goto LABEL_87;
                case 0x15u:
                  goto LABEL_95;
                case 0x16u:
                  goto LABEL_103;
                case 0x17u:
                  goto LABEL_111;
                case 0x18u:
                  goto LABEL_119;
                case 0x19u:
                  goto LABEL_127;
                case 0x1Au:
                  goto LABEL_135;
                case 0x1Bu:
                  goto LABEL_143;
                case 0x1Cu:
                  goto LABEL_151;
                case 0x1Du:
                  goto LABEL_159;
                case 0x1Eu:
                  goto LABEL_167;
                case 0x1Fu:
                  goto LABEL_175;
                case 0x20u:
                  goto LABEL_54;
                case 0x21u:
                  goto LABEL_62;
                case 0x22u:
                  goto LABEL_70;
                case 0x23u:
                  goto LABEL_78;
                case 0x24u:
                  goto LABEL_86;
                case 0x25u:
                  goto LABEL_94;
                case 0x26u:
                  goto LABEL_102;
                case 0x27u:
                  goto LABEL_110;
                case 0x28u:
                  goto LABEL_118;
                case 0x29u:
                  goto LABEL_126;
                case 0x2Au:
                  goto LABEL_134;
                case 0x2Bu:
                  goto LABEL_142;
                case 0x2Cu:
                  goto LABEL_150;
                case 0x2Du:
                  goto LABEL_158;
                case 0x2Eu:
                  goto LABEL_166;
                case 0x2Fu:
                  goto LABEL_174;
                case 0x30u:
                  goto LABEL_53;
                case 0x31u:
                  goto LABEL_61;
                case 0x32u:
                  goto LABEL_69;
                case 0x33u:
                  goto LABEL_77;
                case 0x34u:
                  goto LABEL_85;
                case 0x35u:
                  goto LABEL_93;
                case 0x36u:
                  goto LABEL_101;
                case 0x37u:
                  goto LABEL_109;
                case 0x38u:
                  goto LABEL_117;
                case 0x39u:
                  goto LABEL_125;
                case 0x3Au:
                  goto LABEL_133;
                case 0x3Bu:
                  goto LABEL_141;
                case 0x3Cu:
                  goto LABEL_149;
                case 0x3Du:
                  goto LABEL_157;
                case 0x3Eu:
                  goto LABEL_165;
                case 0x3Fu:
                  goto LABEL_173;
                case 0x40u:
                  goto LABEL_52;
                case 0x41u:
                  goto LABEL_60;
                case 0x42u:
                  goto LABEL_68;
                case 0x43u:
                  goto LABEL_76;
                case 0x44u:
                  goto LABEL_84;
                case 0x45u:
                  goto LABEL_92;
                case 0x46u:
                  goto LABEL_100;
                case 0x47u:
                  goto LABEL_108;
                case 0x48u:
                  goto LABEL_116;
                case 0x49u:
                  goto LABEL_124;
                case 0x4Au:
                  goto LABEL_132;
                case 0x4Bu:
                  goto LABEL_140;
                case 0x4Cu:
                  goto LABEL_148;
                case 0x4Du:
                  goto LABEL_156;
                case 0x4Eu:
                  goto LABEL_164;
                case 0x4Fu:
                  goto LABEL_172;
                case 0x50u:
                  goto LABEL_51;
                case 0x51u:
                  goto LABEL_59;
                case 0x52u:
                  goto LABEL_67;
                case 0x53u:
                  goto LABEL_75;
                case 0x54u:
                  goto LABEL_83;
                case 0x55u:
                  goto LABEL_91;
                case 0x56u:
                  goto LABEL_99;
                case 0x57u:
                  goto LABEL_107;
                case 0x58u:
                  goto LABEL_115;
                case 0x59u:
                  goto LABEL_123;
                case 0x5Au:
                  goto LABEL_131;
                case 0x5Bu:
                  goto LABEL_139;
                case 0x5Cu:
                  goto LABEL_147;
                case 0x5Du:
                  goto LABEL_155;
                case 0x5Eu:
                  goto LABEL_163;
                case 0x5Fu:
                  goto LABEL_171;
                case 0x60u:
                  goto LABEL_50;
                case 0x61u:
                  goto LABEL_58;
                case 0x62u:
                  goto LABEL_66;
                case 0x63u:
                  goto LABEL_74;
                case 0x64u:
                  goto LABEL_82;
                case 0x65u:
                  goto LABEL_90;
                case 0x66u:
                  goto LABEL_98;
                case 0x67u:
                  goto LABEL_106;
                case 0x68u:
                  goto LABEL_114;
                case 0x69u:
                  goto LABEL_122;
                case 0x6Au:
                  goto LABEL_130;
                case 0x6Bu:
                  goto LABEL_138;
                case 0x6Cu:
                  goto LABEL_146;
                case 0x6Du:
                  goto LABEL_154;
                case 0x6Eu:
                  goto LABEL_162;
                case 0x6Fu:
                  goto LABEL_170;
                case 0x70u:
                  goto LABEL_49;
                case 0x71u:
                  goto LABEL_57;
                case 0x72u:
                  goto LABEL_65;
                case 0x73u:
                  goto LABEL_73;
                case 0x74u:
                  goto LABEL_81;
                case 0x75u:
                  goto LABEL_89;
                case 0x76u:
                  goto LABEL_97;
                case 0x77u:
                  goto LABEL_105;
                case 0x78u:
                  goto LABEL_113;
                case 0x79u:
                  goto LABEL_121;
                case 0x7Au:
                  goto LABEL_129;
                case 0x7Bu:
                  goto LABEL_137;
                case 0x7Cu:
                  goto LABEL_145;
                case 0x7Du:
                  goto LABEL_153;
                case 0x7Eu:
                  goto LABEL_161;
                case 0x7Fu:
                  goto LABEL_169;
              }
            }
            while ( 2 )
            {
              _mm_prefetch(v9[56].m128i_i8, 1);
              _mm_prefetch(v9[60].m128i_i8, 1);
              v3 -= 128;
              *v9 = v8;
              v9[1] = v8;
              v9[2] = v8;
              v9[3] = v8;
              v9[4] = v8;
              v9[5] = v8;
              v9[6] = v8;
              v9[7] = v8;
              v9 = (__m128i *)((char *)v9 + v3 + 128);
              switch ( v3 )
              {
                case 0u:
                  goto LABEL_56;
                case 1u:
                  goto LABEL_64;
                case 2u:
                  goto LABEL_72;
                case 3u:
                  goto LABEL_80;
                case 4u:
                  goto LABEL_88;
                case 5u:
                  goto LABEL_96;
                case 6u:
                  goto LABEL_104;
                case 7u:
                  goto LABEL_112;
                case 8u:
                  goto LABEL_120;
                case 9u:
                  goto LABEL_128;
                case 0xAu:
                  goto LABEL_136;
                case 0xBu:
                  goto LABEL_144;
                case 0xCu:
                  goto LABEL_152;
                case 0xDu:
                  goto LABEL_160;
                case 0xEu:
                  goto LABEL_168;
                case 0xFu:
                  goto LABEL_176;
                case 0x10u:
                  goto LABEL_55;
                case 0x11u:
                  goto LABEL_63;
                case 0x12u:
                  goto LABEL_71;
                case 0x13u:
                  goto LABEL_79;
                case 0x14u:
                  goto LABEL_87;
                case 0x15u:
                  goto LABEL_95;
                case 0x16u:
                  goto LABEL_103;
                case 0x17u:
                  goto LABEL_111;
                case 0x18u:
                  goto LABEL_119;
                case 0x19u:
                  goto LABEL_127;
                case 0x1Au:
                  goto LABEL_135;
                case 0x1Bu:
                  goto LABEL_143;
                case 0x1Cu:
                  goto LABEL_151;
                case 0x1Du:
                  goto LABEL_159;
                case 0x1Eu:
                  goto LABEL_167;
                case 0x1Fu:
                  goto LABEL_175;
                case 0x20u:
                  goto LABEL_54;
                case 0x21u:
                  goto LABEL_62;
                case 0x22u:
                  goto LABEL_70;
                case 0x23u:
                  goto LABEL_78;
                case 0x24u:
                  goto LABEL_86;
                case 0x25u:
                  goto LABEL_94;
                case 0x26u:
                  goto LABEL_102;
                case 0x27u:
                  goto LABEL_110;
                case 0x28u:
                  goto LABEL_118;
                case 0x29u:
                  goto LABEL_126;
                case 0x2Au:
                  goto LABEL_134;
                case 0x2Bu:
                  goto LABEL_142;
                case 0x2Cu:
                  goto LABEL_150;
                case 0x2Du:
                  goto LABEL_158;
                case 0x2Eu:
                  goto LABEL_166;
                case 0x2Fu:
                  goto LABEL_174;
                case 0x30u:
                  goto LABEL_53;
                case 0x31u:
                  goto LABEL_61;
                case 0x32u:
                  goto LABEL_69;
                case 0x33u:
                  goto LABEL_77;
                case 0x34u:
                  goto LABEL_85;
                case 0x35u:
                  goto LABEL_93;
                case 0x36u:
                  goto LABEL_101;
                case 0x37u:
                  goto LABEL_109;
                case 0x38u:
                  goto LABEL_117;
                case 0x39u:
                  goto LABEL_125;
                case 0x3Au:
                  goto LABEL_133;
                case 0x3Bu:
                  goto LABEL_141;
                case 0x3Cu:
                  goto LABEL_149;
                case 0x3Du:
                  goto LABEL_157;
                case 0x3Eu:
                  goto LABEL_165;
                case 0x3Fu:
                  goto LABEL_173;
                case 0x40u:
                  goto LABEL_52;
                case 0x41u:
                  goto LABEL_60;
                case 0x42u:
                  goto LABEL_68;
                case 0x43u:
                  goto LABEL_76;
                case 0x44u:
                  goto LABEL_84;
                case 0x45u:
                  goto LABEL_92;
                case 0x46u:
                  goto LABEL_100;
                case 0x47u:
                  goto LABEL_108;
                case 0x48u:
                  goto LABEL_116;
                case 0x49u:
                  goto LABEL_124;
                case 0x4Au:
                  goto LABEL_132;
                case 0x4Bu:
                  goto LABEL_140;
                case 0x4Cu:
                  goto LABEL_148;
                case 0x4Du:
                  goto LABEL_156;
                case 0x4Eu:
                  goto LABEL_164;
                case 0x4Fu:
                  goto LABEL_172;
                case 0x50u:
                  goto LABEL_51;
                case 0x51u:
                  goto LABEL_59;
                case 0x52u:
                  goto LABEL_67;
                case 0x53u:
                  goto LABEL_75;
                case 0x54u:
                  goto LABEL_83;
                case 0x55u:
                  goto LABEL_91;
                case 0x56u:
                  goto LABEL_99;
                case 0x57u:
                  goto LABEL_107;
                case 0x58u:
                  goto LABEL_115;
                case 0x59u:
                  goto LABEL_123;
                case 0x5Au:
                  goto LABEL_131;
                case 0x5Bu:
                  goto LABEL_139;
                case 0x5Cu:
                  goto LABEL_147;
                case 0x5Du:
                  goto LABEL_155;
                case 0x5Eu:
                  goto LABEL_163;
                case 0x5Fu:
                  goto LABEL_171;
                case 0x60u:
                  goto LABEL_50;
                case 0x61u:
                  goto LABEL_58;
                case 0x62u:
                  goto LABEL_66;
                case 0x63u:
                  goto LABEL_74;
                case 0x64u:
                  goto LABEL_82;
                case 0x65u:
                  goto LABEL_90;
                case 0x66u:
                  goto LABEL_98;
                case 0x67u:
                  goto LABEL_106;
                case 0x68u:
                  goto LABEL_114;
                case 0x69u:
                  goto LABEL_122;
                case 0x6Au:
                  goto LABEL_130;
                case 0x6Bu:
                  goto LABEL_138;
                case 0x6Cu:
                  goto LABEL_146;
                case 0x6Du:
                  goto LABEL_154;
                case 0x6Eu:
                  goto LABEL_162;
                case 0x6Fu:
                  goto LABEL_170;
                case 0x70u:
                  goto LABEL_49;
                case 0x71u:
                  goto LABEL_57;
                case 0x72u:
                  goto LABEL_65;
                case 0x73u:
                  goto LABEL_73;
                case 0x74u:
                  goto LABEL_81;
                case 0x75u:
                  goto LABEL_89;
                case 0x76u:
                  goto LABEL_97;
                case 0x77u:
                  goto LABEL_105;
                case 0x78u:
                  goto LABEL_113;
                case 0x79u:
                  goto LABEL_121;
                case 0x7Au:
                  goto LABEL_129;
                case 0x7Bu:
                  goto LABEL_137;
                case 0x7Cu:
                  goto LABEL_145;
                case 0x7Du:
                  goto LABEL_153;
                case 0x7Eu:
                  goto LABEL_161;
                case 0x7Fu:
                  goto LABEL_169;
                default:
                  continue;
              }
            }
          }
          v14 = v3 - _x86_shared_cache_size;
          do
          {
            _mm_prefetch(v9[60].m128i_i8, 1);
            _mm_prefetch(v9[56].m128i_i8, 1);
            v10 -= 128;
            *v9 = v8;
            v9[1] = v8;
            v9[2] = v8;
            v9[3] = v8;
            v9[4] = v8;
            v9[5] = v8;
            v9[6] = v8;
            v9[7] = v8;
            v9 += 8;
          }
          while ( v10 >= 0x80 );
          if ( v14 >= 0x80 )
          {
LABEL_47:
            v14 -= 128;
            _mm_stream_si128(v9, v8);
            _mm_stream_si128(v9 + 1, v8);
            _mm_stream_si128(v9 + 2, v8);
            _mm_stream_si128(v9 + 3, v8);
            _mm_stream_si128(v9 + 4, v8);
            _mm_stream_si128(v9 + 5, v8);
            _mm_stream_si128(v9 + 6, v8);
            _mm_stream_si128(v9 + 7, v8);
            v9 += 8;
            _mm_sfence();
          }
          v9 = (__m128i *)((char *)v9 + v14);
          switch ( v14 )
          {
            case 0u:
              goto LABEL_56;
            case 1u:
              goto LABEL_64;
            case 2u:
              goto LABEL_72;
            case 3u:
              goto LABEL_80;
            case 4u:
              goto LABEL_88;
            case 5u:
              goto LABEL_96;
            case 6u:
              goto LABEL_104;
            case 7u:
              goto LABEL_112;
            case 8u:
              goto LABEL_120;
            case 9u:
              goto LABEL_128;
            case 0xAu:
              goto LABEL_136;
            case 0xBu:
              goto LABEL_144;
            case 0xCu:
              goto LABEL_152;
            case 0xDu:
              goto LABEL_160;
            case 0xEu:
              goto LABEL_168;
            case 0xFu:
              goto LABEL_176;
            case 0x10u:
              goto LABEL_55;
            case 0x11u:
              goto LABEL_63;
            case 0x12u:
              goto LABEL_71;
            case 0x13u:
              goto LABEL_79;
            case 0x14u:
              goto LABEL_87;
            case 0x15u:
              goto LABEL_95;
            case 0x16u:
              goto LABEL_103;
            case 0x17u:
              goto LABEL_111;
            case 0x18u:
              goto LABEL_119;
            case 0x19u:
              goto LABEL_127;
            case 0x1Au:
              goto LABEL_135;
            case 0x1Bu:
              goto LABEL_143;
            case 0x1Cu:
              goto LABEL_151;
            case 0x1Du:
              goto LABEL_159;
            case 0x1Eu:
              goto LABEL_167;
            case 0x1Fu:
              goto LABEL_175;
            case 0x20u:
              goto LABEL_54;
            case 0x21u:
              goto LABEL_62;
            case 0x22u:
              goto LABEL_70;
            case 0x23u:
              goto LABEL_78;
            case 0x24u:
              goto LABEL_86;
            case 0x25u:
              goto LABEL_94;
            case 0x26u:
              goto LABEL_102;
            case 0x27u:
              goto LABEL_110;
            case 0x28u:
              goto LABEL_118;
            case 0x29u:
              goto LABEL_126;
            case 0x2Au:
              goto LABEL_134;
            case 0x2Bu:
              goto LABEL_142;
            case 0x2Cu:
              goto LABEL_150;
            case 0x2Du:
              goto LABEL_158;
            case 0x2Eu:
              goto LABEL_166;
            case 0x2Fu:
              goto LABEL_174;
            case 0x30u:
              goto LABEL_53;
            case 0x31u:
              goto LABEL_61;
            case 0x32u:
              goto LABEL_69;
            case 0x33u:
              goto LABEL_77;
            case 0x34u:
              goto LABEL_85;
            case 0x35u:
              goto LABEL_93;
            case 0x36u:
              goto LABEL_101;
            case 0x37u:
              goto LABEL_109;
            case 0x38u:
              goto LABEL_117;
            case 0x39u:
              goto LABEL_125;
            case 0x3Au:
              goto LABEL_133;
            case 0x3Bu:
              goto LABEL_141;
            case 0x3Cu:
              goto LABEL_149;
            case 0x3Du:
              goto LABEL_157;
            case 0x3Eu:
              goto LABEL_165;
            case 0x3Fu:
              goto LABEL_173;
            case 0x40u:
              goto LABEL_52;
            case 0x41u:
              goto LABEL_60;
            case 0x42u:
              goto LABEL_68;
            case 0x43u:
              goto LABEL_76;
            case 0x44u:
              goto LABEL_84;
            case 0x45u:
              goto LABEL_92;
            case 0x46u:
              goto LABEL_100;
            case 0x47u:
              goto LABEL_108;
            case 0x48u:
              goto LABEL_116;
            case 0x49u:
              goto LABEL_124;
            case 0x4Au:
              goto LABEL_132;
            case 0x4Bu:
              goto LABEL_140;
            case 0x4Cu:
              goto LABEL_148;
            case 0x4Du:
              goto LABEL_156;
            case 0x4Eu:
              goto LABEL_164;
            case 0x4Fu:
              goto LABEL_172;
            case 0x50u:
              goto LABEL_51;
            case 0x51u:
              goto LABEL_59;
            case 0x52u:
              goto LABEL_67;
            case 0x53u:
              goto LABEL_75;
            case 0x54u:
              goto LABEL_83;
            case 0x55u:
              goto LABEL_91;
            case 0x56u:
              goto LABEL_99;
            case 0x57u:
              goto LABEL_107;
            case 0x58u:
              goto LABEL_115;
            case 0x59u:
              goto LABEL_123;
            case 0x5Au:
              goto LABEL_131;
            case 0x5Bu:
              goto LABEL_139;
            case 0x5Cu:
              goto LABEL_147;
            case 0x5Du:
              goto LABEL_155;
            case 0x5Eu:
              goto LABEL_163;
            case 0x5Fu:
              goto LABEL_171;
            case 0x60u:
              goto LABEL_50;
            case 0x61u:
              goto LABEL_58;
            case 0x62u:
              goto LABEL_66;
            case 0x63u:
              goto LABEL_74;
            case 0x64u:
              goto LABEL_82;
            case 0x65u:
              goto LABEL_90;
            case 0x66u:
              goto LABEL_98;
            case 0x67u:
              goto LABEL_106;
            case 0x68u:
              goto LABEL_114;
            case 0x69u:
              goto LABEL_122;
            case 0x6Au:
              goto LABEL_130;
            case 0x6Bu:
              goto LABEL_138;
            case 0x6Cu:
              goto LABEL_146;
            case 0x6Du:
              goto LABEL_154;
            case 0x6Eu:
              goto LABEL_162;
            case 0x6Fu:
              goto LABEL_170;
            case 0x70u:
              goto LABEL_49;
            case 0x71u:
              goto LABEL_57;
            case 0x72u:
              goto LABEL_65;
            case 0x73u:
              goto LABEL_73;
            case 0x74u:
              goto LABEL_81;
            case 0x75u:
              goto LABEL_89;
            case 0x76u:
              goto LABEL_97;
            case 0x77u:
              goto LABEL_105;
            case 0x78u:
              goto LABEL_113;
            case 0x79u:
              goto LABEL_121;
            case 0x7Au:
              goto LABEL_129;
            case 0x7Bu:
              goto LABEL_137;
            case 0x7Cu:
              goto LABEL_145;
            case 0x7Du:
              goto LABEL_153;
            case 0x7Eu:
              goto LABEL_161;
            case 0x7Fu:
              goto LABEL_169;
            default:
              goto LABEL_47;
          }
      }
      break;
  }
  return result;
}
// 80EB980: using guessed type int _x86_shared_cache_size;
// 80EB990: using guessed type int _x86_data_cache_size;

//----- (0805DBF0) --------------------------------------------------------
__m128i *__usercall _memmove_chk_ssse3@<eax>(
        const __m128i *a1@<edi>,
        long double fst7_0@<st0>,
        __m128i *a2,
        __m128i *a3,
        unsigned int a4,
        unsigned int a6)
{
  if ( a6 < a4 )
    _chk_fail(fst7_0);
  return _memmove_ssse3(a1, a2, a3, a4);
}

//----- (0805DC00) --------------------------------------------------------
__m128i *__usercall _memmove_ssse3@<eax>(const __m128i *a1@<edi>, __m128i *a2, __m128i *a3, unsigned int a4)
{
  unsigned int v4; // ecx
  __int64 *v5; // eax
  __m128i *v6; // edx
  unsigned int v7; // edx
  const __m128i *v8; // eax
  __m128i v9; // xmm0
  unsigned int v10; // edx
  __int8 *v11; // edi
  unsigned int v12; // ecx
  const __m128i *v13; // eax
  unsigned int v14; // ecx
  __m128i v15; // xmm1
  bool v16; // cf
  unsigned int v17; // ecx
  int v18; // edi
  __m128i v19; // xmm1
  __m128i v20; // xmm1
  __m128i v21; // xmm1
  unsigned int v22; // ecx
  unsigned int v23; // edi
  unsigned int v24; // ecx
  __m128i v25; // xmm0
  __m128i v26; // xmm1
  __m128i v27; // xmm2
  __m128i v28; // xmm3
  __m128i v29; // xmm4
  __m128i v30; // xmm5
  __m128i v31; // xmm6
  __m128i v32; // xmm7
  char v33; // cc
  unsigned int v34; // ecx
  __m128i v35; // xmm1
  __m128i v36; // xmm0
  __m128i v37; // xmm1
  __m128i v38; // xmm0
  __m128i v39; // xmm1
  __m128i v40; // xmm0
  __m128i v41; // xmm0
  __m128i v42; // xmm1
  __m128i v43; // xmm2
  __m128i v44; // xmm3
  __m128i v45; // xmm4
  __m128i v46; // xmm5
  __m128i v47; // xmm6
  __m128i v48; // xmm7
  unsigned int v49; // ecx
  __m128i v50; // xmm1
  __m128i v51; // xmm0
  __m128i v52; // xmm1
  __m128i v53; // xmm0
  __m128i v54; // xmm1
  __m128i v55; // xmm0
  __m128i v56; // xmm1
  unsigned int v57; // ecx
  __m128i v58; // xmm2
  __m128i v59; // xmm3
  __m128i v60; // xmm4
  __m128i v61; // xmm7
  __m128i v62; // xmm5
  __m128i v63; // xmm4
  __m128i v64; // xmm3
  __m128i v65; // xmm2
  unsigned int v66; // ecx
  __m128i v67; // xmm2
  __m128i v68; // xmm3
  unsigned int v69; // ecx
  __int8 *v70; // eax
  int v71; // edi
  __m128i si128; // xmm2
  __m128i v73; // xmm4
  __m128i v74; // xmm2
  unsigned int v75; // ecx
  int v76; // edi
  __m128i v77; // xmm1
  unsigned int v78; // ecx
  __m128i v79; // xmm2
  __m128i v80; // xmm3
  __m128i v81; // xmm4
  __m128i v82; // xmm7
  __m128i v83; // xmm5
  __m128i v84; // xmm4
  __m128i v85; // xmm3
  __m128i v86; // xmm2
  __m128i v87; // xmm2
  __m128i v88; // xmm3
  unsigned int v89; // ecx
  __int8 *v90; // eax
  int v91; // edi
  __m128i v92; // xmm2
  __m128i v93; // xmm4
  __m128i v94; // xmm2
  unsigned int v95; // ecx
  int v96; // edi
  __m128i v97; // xmm1
  unsigned int v98; // ecx
  __m128i v99; // xmm2
  __m128i v100; // xmm3
  __m128i v101; // xmm4
  __m128i v102; // xmm7
  __m128i v103; // xmm5
  __m128i v104; // xmm4
  __m128i v105; // xmm3
  __m128i v106; // xmm2
  __m128i v107; // xmm2
  __m128i v108; // xmm3
  unsigned int v109; // ecx
  __int8 *v110; // eax
  int v111; // edi
  __m128i v112; // xmm2
  __m128i v113; // xmm4
  __m128i v114; // xmm2
  unsigned int v115; // ecx
  int v116; // edi
  __m128i v117; // xmm1
  unsigned int v118; // ecx
  __m128i v119; // xmm2
  __m128i v120; // xmm3
  __m128i v121; // xmm4
  __m128i v122; // xmm7
  __m128i v123; // xmm5
  __m128i v124; // xmm4
  __m128i v125; // xmm3
  __m128i v126; // xmm2
  __m128i v127; // xmm2
  __m128i v128; // xmm3
  unsigned int v129; // ecx
  __int8 *v130; // eax
  int v131; // edi
  __m128i v132; // xmm2
  __m128i v133; // xmm4
  __m128i v134; // xmm2
  unsigned int v135; // ecx
  int v136; // edi
  __m128i v137; // xmm1
  unsigned int v138; // ecx
  __m128i v139; // xmm2
  __m128i v140; // xmm3
  __m128i v141; // xmm4
  __m128i v142; // xmm7
  __m128i v143; // xmm5
  __m128i v144; // xmm4
  __m128i v145; // xmm3
  __m128i v146; // xmm2
  __m128i v147; // xmm2
  __m128i v148; // xmm3
  unsigned int v149; // ecx
  __int8 *v150; // eax
  int v151; // edi
  __m128i v152; // xmm2
  __m128i v153; // xmm4
  __m128i v154; // xmm2
  unsigned int v155; // ecx
  int v156; // edi
  __m128i v157; // xmm1
  unsigned int v158; // ecx
  __m128i v159; // xmm2
  __m128i v160; // xmm3
  __m128i v161; // xmm4
  __m128i v162; // xmm7
  __m128i v163; // xmm5
  __m128i v164; // xmm4
  __m128i v165; // xmm3
  __m128i v166; // xmm2
  __m128i v167; // xmm2
  __m128i v168; // xmm3
  unsigned int v169; // ecx
  __int8 *v170; // eax
  int v171; // edi
  __m128i v172; // xmm2
  __m128i v173; // xmm4
  __m128i v174; // xmm2
  unsigned int v175; // ecx
  int v176; // edi
  __m128i v177; // xmm1
  unsigned int v178; // ecx
  __m128i v179; // xmm2
  __m128i v180; // xmm3
  __m128i v181; // xmm4
  __m128i v182; // xmm7
  __m128i v183; // xmm5
  __m128i v184; // xmm4
  __m128i v185; // xmm3
  __m128i v186; // xmm2
  __m128i v187; // xmm2
  __m128i v188; // xmm3
  unsigned int v189; // ecx
  __int8 *v190; // eax
  int v191; // edi
  __m128i v192; // xmm2
  __m128i v193; // xmm4
  __m128i v194; // xmm2
  unsigned int v195; // ecx
  int v196; // edi
  __m128i v197; // xmm1
  unsigned int v198; // ecx
  __m128i v199; // xmm2
  __m128i v200; // xmm3
  __m128i v201; // xmm4
  __m128i v202; // xmm7
  __m128i v203; // xmm5
  __m128i v204; // xmm4
  __m128i v205; // xmm3
  __m128i v206; // xmm2
  __m128i v207; // xmm2
  __m128i v208; // xmm3
  unsigned int v209; // ecx
  __int8 *v210; // eax
  int v211; // edi
  __m128i v212; // xmm2
  __m128i v213; // xmm4
  __m128i v214; // xmm2
  unsigned int v215; // ecx
  int v216; // edi
  __m128i v217; // xmm1
  unsigned int v218; // ecx
  __m128i v219; // xmm2
  __m128i v220; // xmm3
  __m128i v221; // xmm4
  __m128i v222; // xmm7
  __m128i v223; // xmm5
  __m128i v224; // xmm4
  __m128i v225; // xmm3
  __m128i v226; // xmm2
  __m128i v227; // xmm2
  __m128i v228; // xmm3
  unsigned int v229; // ecx
  __int8 *v230; // eax
  int v231; // edi
  __m128i v232; // xmm2
  __m128i v233; // xmm4
  __m128i v234; // xmm2
  unsigned int v235; // ecx
  int v236; // edi
  __m128i v237; // xmm1
  unsigned int v238; // ecx
  __m128i v239; // xmm2
  __m128i v240; // xmm3
  __m128i v241; // xmm4
  __m128i v242; // xmm7
  __m128i v243; // xmm5
  __m128i v244; // xmm4
  __m128i v245; // xmm3
  __m128i v246; // xmm2
  __m128i v247; // xmm2
  __m128i v248; // xmm3
  unsigned int v249; // ecx
  __int8 *v250; // eax
  int v251; // edi
  __m128i v252; // xmm2
  __m128i v253; // xmm4
  __m128i v254; // xmm2
  unsigned int v255; // ecx
  int v256; // edi
  __m128i v257; // xmm1
  unsigned int v258; // ecx
  __m128i v259; // xmm2
  __m128i v260; // xmm3
  __m128i v261; // xmm4
  __m128i v262; // xmm7
  __m128i v263; // xmm5
  __m128i v264; // xmm4
  __m128i v265; // xmm3
  __m128i v266; // xmm2
  __m128i v267; // xmm2
  __m128i v268; // xmm3
  unsigned int v269; // ecx
  __int8 *v270; // eax
  int v271; // edi
  __m128i v272; // xmm2
  __m128i v273; // xmm4
  __m128i v274; // xmm2
  unsigned int v275; // ecx
  int v276; // edi
  __m128i v277; // xmm1
  unsigned int v278; // ecx
  __m128i v279; // xmm2
  __m128i v280; // xmm3
  __m128i v281; // xmm4
  __m128i v282; // xmm7
  __m128i v283; // xmm5
  __m128i v284; // xmm4
  __m128i v285; // xmm3
  __m128i v286; // xmm2
  __m128i v287; // xmm2
  __m128i v288; // xmm3
  unsigned int v289; // ecx
  __int8 *v290; // eax
  int v291; // edi
  __m128i v292; // xmm2
  __m128i v293; // xmm4
  __m128i v294; // xmm2
  unsigned int v295; // ecx
  int v296; // edi
  __m128i v297; // xmm1
  unsigned int v298; // ecx
  __m128i v299; // xmm2
  __m128i v300; // xmm3
  __m128i v301; // xmm4
  __m128i v302; // xmm7
  __m128i v303; // xmm5
  __m128i v304; // xmm4
  __m128i v305; // xmm3
  __m128i v306; // xmm2
  __m128i v307; // xmm2
  __m128i v308; // xmm3
  unsigned int v309; // ecx
  __int8 *v310; // eax
  int v311; // edi
  __m128i v312; // xmm2
  __m128i v313; // xmm4
  __m128i v314; // xmm2
  unsigned int v315; // ecx
  int v316; // edi
  __m128i v317; // xmm1
  unsigned int v318; // ecx
  __m128i v319; // xmm2
  __m128i v320; // xmm3
  __m128i v321; // xmm4
  __m128i v322; // xmm7
  __m128i v323; // xmm5
  __m128i v324; // xmm4
  __m128i v325; // xmm3
  __m128i v326; // xmm2
  __m128i v327; // xmm2
  __m128i v328; // xmm3
  unsigned int v329; // ecx
  __int8 *v330; // eax
  int v331; // edi
  __m128i v332; // xmm2
  __m128i v333; // xmm4
  __m128i v334; // xmm2
  unsigned int v335; // ecx
  int v336; // edi
  __m128i v337; // xmm1
  unsigned int v338; // ecx
  __m128i v339; // xmm2
  __m128i v340; // xmm3
  __m128i v341; // xmm4
  __m128i v342; // xmm7
  __m128i v343; // xmm5
  __m128i v344; // xmm4
  __m128i v345; // xmm3
  __m128i v346; // xmm2
  __m128i v347; // xmm2
  __m128i v348; // xmm3
  unsigned int v349; // ecx
  __int8 *v350; // eax
  int v351; // edi
  __m128i v352; // xmm2
  __m128i v353; // xmm4
  __m128i v354; // xmm2
  unsigned int v355; // ecx
  int v356; // edi
  unsigned int v357; // ecx
  __m128i *result; // eax
  __int32 v359; // ecx
  __int32 v360; // eax
  __int16 v361; // cx
  __int8 v362; // al
  __int32 v363; // ecx
  __int32 v364; // eax
  __int16 v365; // cx
  __int8 v366; // al
  __int16 v367; // cx
  __int8 v368; // al
  __int16 v369; // cx
  __int8 v370; // al
  __int16 v371; // cx
  __int8 v372; // al
  __m128i v373; // xmm1
  const __m128i *v374; // eax
  __m128i *v375; // edx
  int v376; // ecx
  __m128i v377; // xmm0
  __m128i v378; // xmm1
  __m128i v379; // xmm2
  __m128i v380; // xmm3
  __m128i v381; // xmm4
  __m128i v382; // xmm5
  __m128i v383; // xmm6
  __m128i v384; // xmm7
  int v385; // ecx
  __m128i v386; // xmm0
  __m128i v387; // xmm1
  __m128i v388; // xmm2
  __m128i v389; // xmm3
  __m128i v390; // xmm0
  __m128i v391; // xmm1
  const __m128i *v392; // [esp-4h] [ebp-4h]

  v4 = a4;
  v5 = (__int64 *)a3;
  v6 = a2;
  if ( a2 < a3 )
    goto LABEL_5;
  if ( a2 == a3 )
    return a2;
  if ( a4 >= 0x20 )
  {
    v5 = (__int64 *)a3;
    if ( a2 >= (__m128i *)&a3->m128i_i8[a4] )
    {
LABEL_5:
      v7 = (unsigned int)a2->m128i_u32 + a4;
      v8 = (const __m128i *)((char *)v5 + a4);
      switch ( a4 )
      {
        case 0u:
          return a2;
        case 1u:
          goto LABEL_191;
        case 2u:
          goto LABEL_203;
        case 3u:
          goto LABEL_214;
        case 4u:
          goto LABEL_173;
        case 5u:
LABEL_180:
          v359 = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
          v360 = v8[-1].m128i_i32[3];
          *(_DWORD *)(v7 - 5) = v359;
          *(_DWORD *)(v7 - 4) = v360;
          return a2;
        case 6u:
          goto LABEL_197;
        case 7u:
          goto LABEL_248;
        case 8u:
          goto LABEL_178;
        case 9u:
          goto LABEL_190;
        case 0xAu:
          goto LABEL_202;
        case 0xBu:
          goto LABEL_213;
        case 0xCu:
          goto LABEL_172;
        case 0xDu:
          goto LABEL_185;
        case 0xEu:
          goto LABEL_196;
        case 0xFu:
          goto LABEL_208;
        case 0x10u:
          goto LABEL_177;
        case 0x11u:
          goto LABEL_189;
        case 0x12u:
          goto LABEL_201;
        case 0x13u:
          goto LABEL_212;
        case 0x14u:
          goto LABEL_171;
        case 0x15u:
          goto LABEL_184;
        case 0x16u:
          goto LABEL_195;
        case 0x17u:
          goto LABEL_207;
        case 0x18u:
          goto LABEL_176;
        case 0x19u:
          goto LABEL_188;
        case 0x1Au:
          goto LABEL_200;
        case 0x1Bu:
          goto LABEL_211;
        case 0x1Cu:
          goto LABEL_170;
        case 0x1Du:
          goto LABEL_183;
        case 0x1Eu:
          goto LABEL_194;
        case 0x1Fu:
          goto LABEL_206;
        case 0x20u:
          goto LABEL_175;
        case 0x21u:
          goto LABEL_187;
        case 0x22u:
          goto LABEL_199;
        case 0x23u:
          goto LABEL_210;
        case 0x24u:
          goto LABEL_169;
        case 0x25u:
          goto LABEL_182;
        case 0x26u:
          goto LABEL_193;
        case 0x27u:
          goto LABEL_205;
        case 0x28u:
LABEL_174:
          *(_QWORD *)(v7 - 40) = v8[-3].m128i_i64[1];
LABEL_175:
          *(_QWORD *)(v7 - 32) = v8[-2].m128i_i64[0];
LABEL_176:
          *(_QWORD *)(v7 - 24) = v8[-2].m128i_i64[1];
LABEL_177:
          *(_QWORD *)(v7 - 16) = v8[-1].m128i_i64[0];
LABEL_178:
          *(_QWORD *)(v7 - 8) = v8[-1].m128i_i64[1];
          return a2;
        case 0x29u:
LABEL_186:
          *(_QWORD *)(v7 - 41) = *(__int64 *)((char *)v8[-3].m128i_i64 + 7);
LABEL_187:
          *(_QWORD *)(v7 - 33) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 7);
LABEL_188:
          *(_QWORD *)(v7 - 25) = *(__int64 *)((char *)v8[-2].m128i_i64 + 7);
LABEL_189:
          *(_QWORD *)(v7 - 17) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 7);
LABEL_190:
          *(_QWORD *)(v7 - 9) = *(__int64 *)((char *)v8[-1].m128i_i64 + 7);
LABEL_191:
          *(_BYTE *)(v7 - 1) = v8[-1].m128i_i8[15];
          return a2;
        case 0x2Au:
LABEL_198:
          *(_QWORD *)(v7 - 42) = *(__int64 *)((char *)v8[-3].m128i_i64 + 6);
LABEL_199:
          *(_QWORD *)(v7 - 34) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 6);
LABEL_200:
          *(_QWORD *)(v7 - 26) = *(__int64 *)((char *)v8[-2].m128i_i64 + 6);
LABEL_201:
          *(_QWORD *)(v7 - 18) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 6);
LABEL_202:
          *(_QWORD *)(v7 - 10) = *(__int64 *)((char *)v8[-1].m128i_i64 + 6);
LABEL_203:
          *(_WORD *)(v7 - 2) = v8[-1].m128i_i16[7];
          return a2;
        case 0x2Bu:
LABEL_209:
          *(_QWORD *)(v7 - 43) = *(__int64 *)((char *)v8[-3].m128i_i64 + 5);
LABEL_210:
          *(_QWORD *)(v7 - 35) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 5);
LABEL_211:
          *(_QWORD *)(v7 - 27) = *(__int64 *)((char *)v8[-2].m128i_i64 + 5);
LABEL_212:
          *(_QWORD *)(v7 - 19) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 5);
LABEL_213:
          *(_QWORD *)(v7 - 11) = *(__int64 *)((char *)v8[-1].m128i_i64 + 5);
LABEL_214:
          v361 = *(__int16 *)((char *)&v8[-1].m128i_i16[6] + 1);
          v362 = v8[-1].m128i_i8[15];
          *(_WORD *)(v7 - 3) = v361;
          *(_BYTE *)(v7 - 1) = v362;
          return a2;
        case 0x2Cu:
LABEL_168:
          *(_QWORD *)(v7 - 44) = *(__int64 *)((char *)v8[-3].m128i_i64 + 4);
LABEL_169:
          *(_QWORD *)(v7 - 36) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 4);
LABEL_170:
          *(_QWORD *)(v7 - 28) = *(__int64 *)((char *)v8[-2].m128i_i64 + 4);
LABEL_171:
          *(_QWORD *)(v7 - 20) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 4);
LABEL_172:
          *(_QWORD *)(v7 - 12) = *(__int64 *)((char *)v8[-1].m128i_i64 + 4);
LABEL_173:
          *(_DWORD *)(v7 - 4) = v8[-1].m128i_i32[3];
          return a2;
        case 0x2Du:
LABEL_181:
          *(_QWORD *)(v7 - 45) = *(__int64 *)((char *)v8[-3].m128i_i64 + 3);
LABEL_182:
          *(_QWORD *)(v7 - 37) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 3);
LABEL_183:
          *(_QWORD *)(v7 - 29) = *(__int64 *)((char *)v8[-2].m128i_i64 + 3);
LABEL_184:
          *(_QWORD *)(v7 - 21) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 3);
LABEL_185:
          *(_QWORD *)(v7 - 13) = *(__int64 *)((char *)v8[-1].m128i_i64 + 3);
          *(_DWORD *)(v7 - 5) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
          *(_BYTE *)(v7 - 1) = v8[-1].m128i_i8[15];
          return a2;
        case 0x2Eu:
LABEL_192:
          *(_QWORD *)(v7 - 46) = *(__int64 *)((char *)v8[-3].m128i_i64 + 2);
LABEL_193:
          *(_QWORD *)(v7 - 38) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 2);
LABEL_194:
          *(_QWORD *)(v7 - 30) = *(__int64 *)((char *)v8[-2].m128i_i64 + 2);
LABEL_195:
          *(_QWORD *)(v7 - 22) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 2);
LABEL_196:
          *(_QWORD *)(v7 - 14) = *(__int64 *)((char *)v8[-1].m128i_i64 + 2);
LABEL_197:
          *(_DWORD *)(v7 - 6) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 2);
          *(_WORD *)(v7 - 2) = v8[-1].m128i_i16[7];
          return a2;
        case 0x2Fu:
LABEL_204:
          *(_QWORD *)(v7 - 47) = *(__int64 *)((char *)v8[-3].m128i_i64 + 1);
LABEL_205:
          *(_QWORD *)(v7 - 39) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 1);
LABEL_206:
          *(_QWORD *)(v7 - 31) = *(__int64 *)((char *)v8[-2].m128i_i64 + 1);
LABEL_207:
          *(_QWORD *)(v7 - 23) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 1);
LABEL_208:
          *(_QWORD *)(v7 - 15) = *(__int64 *)((char *)v8[-1].m128i_i64 + 1);
LABEL_248:
          *(_DWORD *)(v7 - 7) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 1);
          v365 = *(__int16 *)((char *)&v8[-1].m128i_i16[6] + 1);
          v366 = v8[-1].m128i_i8[15];
          *(_WORD *)(v7 - 3) = v365;
          *(_BYTE *)(v7 - 1) = v366;
          return a2;
        default:
          v9 = _mm_loadu_si128(v8);
          v10 = (v7 & 0xFFFFFFF0) + 16;
          v11 = &a2->m128i_i8[a4 - v10];
          v12 = (unsigned int)&v11[a4];
          v13 = (const __m128i *)((char *)v8 - v11);
          if ( (unsigned int)&v11[a4] >= _x86_shared_cache_size_half )
          {
            v373 = _mm_loadu_si128(v13);
            *a2 = v9;
            v374 = v13 + 1;
            _mm_stream_si128((__m128i *)v10, v373);
            v375 = (__m128i *)(v10 + 16);
            v376 = v12 - 144;
            do
            {
              v377 = _mm_loadu_si128(v374);
              v378 = _mm_loadu_si128(v374 + 1);
              v379 = _mm_loadu_si128(v374 + 2);
              v380 = _mm_loadu_si128(v374 + 3);
              v381 = _mm_loadu_si128(v374 + 4);
              v382 = _mm_loadu_si128(v374 + 5);
              v383 = _mm_loadu_si128(v374 + 6);
              v384 = _mm_loadu_si128(v374 + 7);
              v374 += 8;
              v16 = (unsigned int)v376 < 0x80;
              v376 -= 128;
              _mm_stream_si128(v375, v377);
              _mm_stream_si128(v375 + 1, v378);
              _mm_stream_si128(v375 + 2, v379);
              _mm_stream_si128(v375 + 3, v380);
              _mm_stream_si128(v375 + 4, v381);
              _mm_stream_si128(v375 + 5, v382);
              _mm_stream_si128(v375 + 6, v383);
              _mm_stream_si128(v375 + 7, v384);
              v375 += 8;
            }
            while ( !v16 );
            v33 = v376 < -64;
            v385 = v376 + 128;
            if ( !v33 )
            {
              v386 = _mm_loadu_si128(v374);
              v387 = _mm_loadu_si128(v374 + 1);
              v388 = _mm_loadu_si128(v374 + 2);
              v389 = _mm_loadu_si128(v374 + 3);
              v374 += 4;
              _mm_stream_si128(v375, v386);
              _mm_stream_si128(v375 + 1, v387);
              _mm_stream_si128(v375 + 2, v388);
              _mm_stream_si128(v375 + 3, v389);
              v375 += 4;
              v385 -= 64;
            }
            while ( 2 )
            {
              v7 = (unsigned int)v375->m128i_u32 + v385;
              v8 = (const __m128i *)((char *)v374 + v385);
              _mm_sfence();
              switch ( v385 )
              {
                case 0:
                  return a2;
                case 1:
                  goto LABEL_191;
                case 2:
                  goto LABEL_203;
                case 3:
                  goto LABEL_214;
                case 4:
                  goto LABEL_173;
                case 5:
                  goto LABEL_180;
                case 6:
                  goto LABEL_197;
                case 7:
                  goto LABEL_248;
                case 8:
                  goto LABEL_178;
                case 9:
                  goto LABEL_190;
                case 10:
                  goto LABEL_202;
                case 11:
                  goto LABEL_213;
                case 12:
                  goto LABEL_172;
                case 13:
                  goto LABEL_185;
                case 14:
                  goto LABEL_196;
                case 15:
                  goto LABEL_208;
                case 16:
                  goto LABEL_177;
                case 17:
                  goto LABEL_189;
                case 18:
                  goto LABEL_201;
                case 19:
                  goto LABEL_212;
                case 20:
                  goto LABEL_171;
                case 21:
                  goto LABEL_184;
                case 22:
                  goto LABEL_195;
                case 23:
                  goto LABEL_207;
                case 24:
                  goto LABEL_176;
                case 25:
                  goto LABEL_188;
                case 26:
                  goto LABEL_200;
                case 27:
                  goto LABEL_211;
                case 28:
                  goto LABEL_170;
                case 29:
                  goto LABEL_183;
                case 30:
                  goto LABEL_194;
                case 31:
                  goto LABEL_206;
                default:
                  v390 = _mm_loadu_si128(v8);
                  v391 = _mm_loadu_si128(v8 + 1);
                  v374 = v8 + 2;
                  _mm_stream_si128((__m128i *)v7, v390);
                  _mm_stream_si128((__m128i *)(v7 + 16), v391);
                  v375 = (__m128i *)(v7 + 32);
                  v385 -= 32;
                  continue;
              }
            }
          }
          if ( ((unsigned __int8)v13 & 0xF) != 0 )
          {
            switch ( (unsigned __int8)v13 & 0xF )
            {
              case 0:
                break;
              case 1:
                v56 = *(const __m128i *)((char *)v13 - 1);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v69 = v12 - 32;
                  v70 = &v13[-1].m128i_i8[15];
                  v71 = 0;
                  do
                  {
                    si128 = _mm_load_si128((const __m128i *)&v70[v71 + 16]);
                    v16 = v69 < 0x20;
                    v69 -= 32;
                    v73 = _mm_load_si128((const __m128i *)&v70[v71 + 32]);
                    v71 += 32;
                    *(__m128i *)(v10 + v71 - 32) = _mm_alignr_epi8(si128, v56, 1);
                    *(__m128i *)(v10 + v71 - 16) = _mm_alignr_epi8(v73, si128, 1);
                    if ( v16 )
                      break;
                    v74 = _mm_load_si128((const __m128i *)&v70[v71 + 16]);
                    v16 = v69 < 0x20;
                    v69 -= 32;
                    v56 = _mm_load_si128((const __m128i *)&v70[v71 + 32]);
                    v71 += 32;
                    *(__m128i *)(v10 + v71 - 32) = _mm_alignr_epi8(v74, v73, 1);
                    *(__m128i *)(v10 + v71 - 16) = _mm_alignr_epi8(v56, v74, 1);
                  }
                  while ( !v16 );
                  v75 = v69 + 32;
                  v76 = v75 + v71;
                  v7 = v76 + v10;
                  v8 = (const __m128i *)&v70[v76 + 1];
                  switch ( v75 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v57 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v58 = *(const __m128i *)((char *)v13 + 15);
                  v59 = *(const __m128i *)((char *)v13 + 31);
                  v60 = *(const __m128i *)((char *)v13 + 47);
                  v61 = *(const __m128i *)((char *)v13 + 63);
                  v62 = _mm_alignr_epi8(v61, v60, 1);
                  v63 = _mm_alignr_epi8(v60, v59, 1);
                  *(__m128i *)(v10 + 48) = v62;
                  v64 = _mm_alignr_epi8(v59, v58, 1);
                  v13 += 4;
                  v65 = _mm_alignr_epi8(v58, v56, 1);
                  *(__m128i *)(v10 + 32) = v63;
                  *(__m128i *)(v10 + 16) = v64;
                  v56 = v61;
                  *(__m128i *)v10 = v65;
                  v10 += 64;
                  v33 = v57 <= 0x40;
                  v57 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v57 + 32) < 0) ^ __OFADD__(32, v57) | (v57 == -32);
                v66 = v57 + 32;
                if ( !v33 )
                {
                  v67 = *(const __m128i *)((char *)v13 + 15);
                  v68 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 31), v67, 1);
                  *(__m128i *)v10 = _mm_alignr_epi8(v67, v61, 1);
                  *(__m128i *)(v10 + 16) = v68;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 2:
                v77 = *(const __m128i *)((char *)v13 - 2);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v89 = v12 - 32;
                  v90 = &v13[-1].m128i_i8[14];
                  v91 = 0;
                  do
                  {
                    v92 = _mm_load_si128((const __m128i *)&v90[v91 + 16]);
                    v16 = v89 < 0x20;
                    v89 -= 32;
                    v93 = _mm_load_si128((const __m128i *)&v90[v91 + 32]);
                    v91 += 32;
                    *(__m128i *)(v10 + v91 - 32) = _mm_alignr_epi8(v92, v77, 2);
                    *(__m128i *)(v10 + v91 - 16) = _mm_alignr_epi8(v93, v92, 2);
                    if ( v16 )
                      break;
                    v94 = _mm_load_si128((const __m128i *)&v90[v91 + 16]);
                    v16 = v89 < 0x20;
                    v89 -= 32;
                    v77 = _mm_load_si128((const __m128i *)&v90[v91 + 32]);
                    v91 += 32;
                    *(__m128i *)(v10 + v91 - 32) = _mm_alignr_epi8(v94, v93, 2);
                    *(__m128i *)(v10 + v91 - 16) = _mm_alignr_epi8(v77, v94, 2);
                  }
                  while ( !v16 );
                  v95 = v89 + 32;
                  v96 = v95 + v91;
                  v7 = v96 + v10;
                  v8 = (const __m128i *)&v90[v96 + 2];
                  switch ( v95 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v78 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v79 = *(const __m128i *)((char *)v13 + 14);
                  v80 = *(const __m128i *)((char *)v13 + 30);
                  v81 = *(const __m128i *)((char *)v13 + 46);
                  v82 = *(const __m128i *)((char *)v13 + 62);
                  v83 = _mm_alignr_epi8(v82, v81, 2);
                  v84 = _mm_alignr_epi8(v81, v80, 2);
                  *(__m128i *)(v10 + 48) = v83;
                  v85 = _mm_alignr_epi8(v80, v79, 2);
                  v13 += 4;
                  v86 = _mm_alignr_epi8(v79, v77, 2);
                  *(__m128i *)(v10 + 32) = v84;
                  *(__m128i *)(v10 + 16) = v85;
                  v77 = v82;
                  *(__m128i *)v10 = v86;
                  v10 += 64;
                  v33 = v78 <= 0x40;
                  v78 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v78 + 32) < 0) ^ __OFADD__(32, v78) | (v78 == -32);
                v66 = v78 + 32;
                if ( !v33 )
                {
                  v87 = *(const __m128i *)((char *)v13 + 14);
                  v88 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 30), v87, 2);
                  *(__m128i *)v10 = _mm_alignr_epi8(v87, v82, 2);
                  *(__m128i *)(v10 + 16) = v88;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 3:
                v97 = *(const __m128i *)((char *)v13 - 3);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v109 = v12 - 32;
                  v110 = &v13[-1].m128i_i8[13];
                  v111 = 0;
                  do
                  {
                    v112 = _mm_load_si128((const __m128i *)&v110[v111 + 16]);
                    v16 = v109 < 0x20;
                    v109 -= 32;
                    v113 = _mm_load_si128((const __m128i *)&v110[v111 + 32]);
                    v111 += 32;
                    *(__m128i *)(v10 + v111 - 32) = _mm_alignr_epi8(v112, v97, 3);
                    *(__m128i *)(v10 + v111 - 16) = _mm_alignr_epi8(v113, v112, 3);
                    if ( v16 )
                      break;
                    v114 = _mm_load_si128((const __m128i *)&v110[v111 + 16]);
                    v16 = v109 < 0x20;
                    v109 -= 32;
                    v97 = _mm_load_si128((const __m128i *)&v110[v111 + 32]);
                    v111 += 32;
                    *(__m128i *)(v10 + v111 - 32) = _mm_alignr_epi8(v114, v113, 3);
                    *(__m128i *)(v10 + v111 - 16) = _mm_alignr_epi8(v97, v114, 3);
                  }
                  while ( !v16 );
                  v115 = v109 + 32;
                  v116 = v115 + v111;
                  v7 = v116 + v10;
                  v8 = (const __m128i *)&v110[v116 + 3];
                  switch ( v115 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v98 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v99 = *(const __m128i *)((char *)v13 + 13);
                  v100 = *(const __m128i *)((char *)v13 + 29);
                  v101 = *(const __m128i *)((char *)v13 + 45);
                  v102 = *(const __m128i *)((char *)v13 + 61);
                  v103 = _mm_alignr_epi8(v102, v101, 3);
                  v104 = _mm_alignr_epi8(v101, v100, 3);
                  *(__m128i *)(v10 + 48) = v103;
                  v105 = _mm_alignr_epi8(v100, v99, 3);
                  v13 += 4;
                  v106 = _mm_alignr_epi8(v99, v97, 3);
                  *(__m128i *)(v10 + 32) = v104;
                  *(__m128i *)(v10 + 16) = v105;
                  v97 = v102;
                  *(__m128i *)v10 = v106;
                  v10 += 64;
                  v33 = v98 <= 0x40;
                  v98 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v98 + 32) < 0) ^ __OFADD__(32, v98) | (v98 == -32);
                v66 = v98 + 32;
                if ( !v33 )
                {
                  v107 = *(const __m128i *)((char *)v13 + 13);
                  v108 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 29), v107, 3);
                  *(__m128i *)v10 = _mm_alignr_epi8(v107, v102, 3);
                  *(__m128i *)(v10 + 16) = v108;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 4:
                v117 = *(const __m128i *)((char *)v13 - 4);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v129 = v12 - 32;
                  v130 = &v13[-1].m128i_i8[12];
                  v131 = 0;
                  do
                  {
                    v132 = _mm_load_si128((const __m128i *)&v130[v131 + 16]);
                    v16 = v129 < 0x20;
                    v129 -= 32;
                    v133 = _mm_load_si128((const __m128i *)&v130[v131 + 32]);
                    v131 += 32;
                    *(__m128i *)(v10 + v131 - 32) = _mm_alignr_epi8(v132, v117, 4);
                    *(__m128i *)(v10 + v131 - 16) = _mm_alignr_epi8(v133, v132, 4);
                    if ( v16 )
                      break;
                    v134 = _mm_load_si128((const __m128i *)&v130[v131 + 16]);
                    v16 = v129 < 0x20;
                    v129 -= 32;
                    v117 = _mm_load_si128((const __m128i *)&v130[v131 + 32]);
                    v131 += 32;
                    *(__m128i *)(v10 + v131 - 32) = _mm_alignr_epi8(v134, v133, 4);
                    *(__m128i *)(v10 + v131 - 16) = _mm_alignr_epi8(v117, v134, 4);
                  }
                  while ( !v16 );
                  v135 = v129 + 32;
                  v136 = v135 + v131;
                  v7 = v136 + v10;
                  v8 = (const __m128i *)&v130[v136 + 4];
                  switch ( v135 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v118 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v119 = *(const __m128i *)((char *)v13 + 12);
                  v120 = *(const __m128i *)((char *)v13 + 28);
                  v121 = *(const __m128i *)((char *)v13 + 44);
                  v122 = *(const __m128i *)((char *)v13 + 60);
                  v123 = _mm_alignr_epi8(v122, v121, 4);
                  v124 = _mm_alignr_epi8(v121, v120, 4);
                  *(__m128i *)(v10 + 48) = v123;
                  v125 = _mm_alignr_epi8(v120, v119, 4);
                  v13 += 4;
                  v126 = _mm_alignr_epi8(v119, v117, 4);
                  *(__m128i *)(v10 + 32) = v124;
                  *(__m128i *)(v10 + 16) = v125;
                  v117 = v122;
                  *(__m128i *)v10 = v126;
                  v10 += 64;
                  v33 = v118 <= 0x40;
                  v118 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v118 + 32) < 0) ^ __OFADD__(32, v118) | (v118 == -32);
                v66 = v118 + 32;
                if ( !v33 )
                {
                  v127 = *(const __m128i *)((char *)v13 + 12);
                  v128 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 28), v127, 4);
                  *(__m128i *)v10 = _mm_alignr_epi8(v127, v122, 4);
                  *(__m128i *)(v10 + 16) = v128;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 5:
                v137 = *(const __m128i *)((char *)v13 - 5);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v149 = v12 - 32;
                  v150 = &v13[-1].m128i_i8[11];
                  v151 = 0;
                  do
                  {
                    v152 = _mm_load_si128((const __m128i *)&v150[v151 + 16]);
                    v16 = v149 < 0x20;
                    v149 -= 32;
                    v153 = _mm_load_si128((const __m128i *)&v150[v151 + 32]);
                    v151 += 32;
                    *(__m128i *)(v10 + v151 - 32) = _mm_alignr_epi8(v152, v137, 5);
                    *(__m128i *)(v10 + v151 - 16) = _mm_alignr_epi8(v153, v152, 5);
                    if ( v16 )
                      break;
                    v154 = _mm_load_si128((const __m128i *)&v150[v151 + 16]);
                    v16 = v149 < 0x20;
                    v149 -= 32;
                    v137 = _mm_load_si128((const __m128i *)&v150[v151 + 32]);
                    v151 += 32;
                    *(__m128i *)(v10 + v151 - 32) = _mm_alignr_epi8(v154, v153, 5);
                    *(__m128i *)(v10 + v151 - 16) = _mm_alignr_epi8(v137, v154, 5);
                  }
                  while ( !v16 );
                  v155 = v149 + 32;
                  v156 = v155 + v151;
                  v7 = v156 + v10;
                  v8 = (const __m128i *)&v150[v156 + 5];
                  switch ( v155 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v138 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v139 = *(const __m128i *)((char *)v13 + 11);
                  v140 = *(const __m128i *)((char *)v13 + 27);
                  v141 = *(const __m128i *)((char *)v13 + 43);
                  v142 = *(const __m128i *)((char *)v13 + 59);
                  v143 = _mm_alignr_epi8(v142, v141, 5);
                  v144 = _mm_alignr_epi8(v141, v140, 5);
                  *(__m128i *)(v10 + 48) = v143;
                  v145 = _mm_alignr_epi8(v140, v139, 5);
                  v13 += 4;
                  v146 = _mm_alignr_epi8(v139, v137, 5);
                  *(__m128i *)(v10 + 32) = v144;
                  *(__m128i *)(v10 + 16) = v145;
                  v137 = v142;
                  *(__m128i *)v10 = v146;
                  v10 += 64;
                  v33 = v138 <= 0x40;
                  v138 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v138 + 32) < 0) ^ __OFADD__(32, v138) | (v138 == -32);
                v66 = v138 + 32;
                if ( !v33 )
                {
                  v147 = *(const __m128i *)((char *)v13 + 11);
                  v148 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 27), v147, 5);
                  *(__m128i *)v10 = _mm_alignr_epi8(v147, v142, 5);
                  *(__m128i *)(v10 + 16) = v148;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 6:
                v157 = *(const __m128i *)((char *)v13 - 6);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v169 = v12 - 32;
                  v170 = &v13[-1].m128i_i8[10];
                  v171 = 0;
                  do
                  {
                    v172 = _mm_load_si128((const __m128i *)&v170[v171 + 16]);
                    v16 = v169 < 0x20;
                    v169 -= 32;
                    v173 = _mm_load_si128((const __m128i *)&v170[v171 + 32]);
                    v171 += 32;
                    *(__m128i *)(v10 + v171 - 32) = _mm_alignr_epi8(v172, v157, 6);
                    *(__m128i *)(v10 + v171 - 16) = _mm_alignr_epi8(v173, v172, 6);
                    if ( v16 )
                      break;
                    v174 = _mm_load_si128((const __m128i *)&v170[v171 + 16]);
                    v16 = v169 < 0x20;
                    v169 -= 32;
                    v157 = _mm_load_si128((const __m128i *)&v170[v171 + 32]);
                    v171 += 32;
                    *(__m128i *)(v10 + v171 - 32) = _mm_alignr_epi8(v174, v173, 6);
                    *(__m128i *)(v10 + v171 - 16) = _mm_alignr_epi8(v157, v174, 6);
                  }
                  while ( !v16 );
                  v175 = v169 + 32;
                  v176 = v175 + v171;
                  v7 = v176 + v10;
                  v8 = (const __m128i *)&v170[v176 + 6];
                  switch ( v175 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v158 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v159 = *(const __m128i *)((char *)v13 + 10);
                  v160 = *(const __m128i *)((char *)v13 + 26);
                  v161 = *(const __m128i *)((char *)v13 + 42);
                  v162 = *(const __m128i *)((char *)v13 + 58);
                  v163 = _mm_alignr_epi8(v162, v161, 6);
                  v164 = _mm_alignr_epi8(v161, v160, 6);
                  *(__m128i *)(v10 + 48) = v163;
                  v165 = _mm_alignr_epi8(v160, v159, 6);
                  v13 += 4;
                  v166 = _mm_alignr_epi8(v159, v157, 6);
                  *(__m128i *)(v10 + 32) = v164;
                  *(__m128i *)(v10 + 16) = v165;
                  v157 = v162;
                  *(__m128i *)v10 = v166;
                  v10 += 64;
                  v33 = v158 <= 0x40;
                  v158 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v158 + 32) < 0) ^ __OFADD__(32, v158) | (v158 == -32);
                v66 = v158 + 32;
                if ( !v33 )
                {
                  v167 = *(const __m128i *)((char *)v13 + 10);
                  v168 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 26), v167, 6);
                  *(__m128i *)v10 = _mm_alignr_epi8(v167, v162, 6);
                  *(__m128i *)(v10 + 16) = v168;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 7:
                v177 = *(const __m128i *)((char *)v13 - 7);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v189 = v12 - 32;
                  v190 = &v13[-1].m128i_i8[9];
                  v191 = 0;
                  do
                  {
                    v192 = _mm_load_si128((const __m128i *)&v190[v191 + 16]);
                    v16 = v189 < 0x20;
                    v189 -= 32;
                    v193 = _mm_load_si128((const __m128i *)&v190[v191 + 32]);
                    v191 += 32;
                    *(__m128i *)(v10 + v191 - 32) = _mm_alignr_epi8(v192, v177, 7);
                    *(__m128i *)(v10 + v191 - 16) = _mm_alignr_epi8(v193, v192, 7);
                    if ( v16 )
                      break;
                    v194 = _mm_load_si128((const __m128i *)&v190[v191 + 16]);
                    v16 = v189 < 0x20;
                    v189 -= 32;
                    v177 = _mm_load_si128((const __m128i *)&v190[v191 + 32]);
                    v191 += 32;
                    *(__m128i *)(v10 + v191 - 32) = _mm_alignr_epi8(v194, v193, 7);
                    *(__m128i *)(v10 + v191 - 16) = _mm_alignr_epi8(v177, v194, 7);
                  }
                  while ( !v16 );
                  v195 = v189 + 32;
                  v196 = v195 + v191;
                  v7 = v196 + v10;
                  v8 = (const __m128i *)&v190[v196 + 7];
                  switch ( v195 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v178 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v179 = *(const __m128i *)((char *)v13 + 9);
                  v180 = *(const __m128i *)((char *)v13 + 25);
                  v181 = *(const __m128i *)((char *)v13 + 41);
                  v182 = *(const __m128i *)((char *)v13 + 57);
                  v183 = _mm_alignr_epi8(v182, v181, 7);
                  v184 = _mm_alignr_epi8(v181, v180, 7);
                  *(__m128i *)(v10 + 48) = v183;
                  v185 = _mm_alignr_epi8(v180, v179, 7);
                  v13 += 4;
                  v186 = _mm_alignr_epi8(v179, v177, 7);
                  *(__m128i *)(v10 + 32) = v184;
                  *(__m128i *)(v10 + 16) = v185;
                  v177 = v182;
                  *(__m128i *)v10 = v186;
                  v10 += 64;
                  v33 = v178 <= 0x40;
                  v178 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v178 + 32) < 0) ^ __OFADD__(32, v178) | (v178 == -32);
                v66 = v178 + 32;
                if ( !v33 )
                {
                  v187 = *(const __m128i *)((char *)v13 + 9);
                  v188 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 25), v187, 7);
                  *(__m128i *)v10 = _mm_alignr_epi8(v187, v182, 7);
                  *(__m128i *)(v10 + 16) = v188;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 8:
                v197 = *(const __m128i *)((char *)v13 - 8);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v209 = v12 - 32;
                  v210 = &v13[-1].m128i_i8[8];
                  v211 = 0;
                  do
                  {
                    v212 = _mm_load_si128((const __m128i *)&v210[v211 + 16]);
                    v16 = v209 < 0x20;
                    v209 -= 32;
                    v213 = _mm_load_si128((const __m128i *)&v210[v211 + 32]);
                    v211 += 32;
                    *(__m128i *)(v10 + v211 - 32) = _mm_alignr_epi8(v212, v197, 8);
                    *(__m128i *)(v10 + v211 - 16) = _mm_alignr_epi8(v213, v212, 8);
                    if ( v16 )
                      break;
                    v214 = _mm_load_si128((const __m128i *)&v210[v211 + 16]);
                    v16 = v209 < 0x20;
                    v209 -= 32;
                    v197 = _mm_load_si128((const __m128i *)&v210[v211 + 32]);
                    v211 += 32;
                    *(__m128i *)(v10 + v211 - 32) = _mm_alignr_epi8(v214, v213, 8);
                    *(__m128i *)(v10 + v211 - 16) = _mm_alignr_epi8(v197, v214, 8);
                  }
                  while ( !v16 );
                  v215 = v209 + 32;
                  v216 = v215 + v211;
                  v7 = v216 + v10;
                  v8 = (const __m128i *)&v210[v216 + 8];
                  switch ( v215 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v198 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v199 = *(const __m128i *)((char *)v13 + 8);
                  v200 = *(const __m128i *)((char *)v13 + 24);
                  v201 = *(const __m128i *)((char *)v13 + 40);
                  v202 = *(const __m128i *)((char *)v13 + 56);
                  v203 = _mm_alignr_epi8(v202, v201, 8);
                  v204 = _mm_alignr_epi8(v201, v200, 8);
                  *(__m128i *)(v10 + 48) = v203;
                  v205 = _mm_alignr_epi8(v200, v199, 8);
                  v13 += 4;
                  v206 = _mm_alignr_epi8(v199, v197, 8);
                  *(__m128i *)(v10 + 32) = v204;
                  *(__m128i *)(v10 + 16) = v205;
                  v197 = v202;
                  *(__m128i *)v10 = v206;
                  v10 += 64;
                  v33 = v198 <= 0x40;
                  v198 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v198 + 32) < 0) ^ __OFADD__(32, v198) | (v198 == -32);
                v66 = v198 + 32;
                if ( !v33 )
                {
                  v207 = *(const __m128i *)((char *)v13 + 8);
                  v208 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 24), v207, 8);
                  *(__m128i *)v10 = _mm_alignr_epi8(v207, v202, 8);
                  *(__m128i *)(v10 + 16) = v208;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 9:
                v217 = *(const __m128i *)((char *)v13 - 9);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v229 = v12 - 32;
                  v230 = &v13[-1].m128i_i8[7];
                  v231 = 0;
                  do
                  {
                    v232 = _mm_load_si128((const __m128i *)&v230[v231 + 16]);
                    v16 = v229 < 0x20;
                    v229 -= 32;
                    v233 = _mm_load_si128((const __m128i *)&v230[v231 + 32]);
                    v231 += 32;
                    *(__m128i *)(v10 + v231 - 32) = _mm_alignr_epi8(v232, v217, 9);
                    *(__m128i *)(v10 + v231 - 16) = _mm_alignr_epi8(v233, v232, 9);
                    if ( v16 )
                      break;
                    v234 = _mm_load_si128((const __m128i *)&v230[v231 + 16]);
                    v16 = v229 < 0x20;
                    v229 -= 32;
                    v217 = _mm_load_si128((const __m128i *)&v230[v231 + 32]);
                    v231 += 32;
                    *(__m128i *)(v10 + v231 - 32) = _mm_alignr_epi8(v234, v233, 9);
                    *(__m128i *)(v10 + v231 - 16) = _mm_alignr_epi8(v217, v234, 9);
                  }
                  while ( !v16 );
                  v235 = v229 + 32;
                  v236 = v235 + v231;
                  v7 = v236 + v10;
                  v8 = (const __m128i *)&v230[v236 + 9];
                  switch ( v235 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v218 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v219 = *(const __m128i *)((char *)v13 + 7);
                  v220 = *(const __m128i *)((char *)v13 + 23);
                  v221 = *(const __m128i *)((char *)v13 + 39);
                  v222 = *(const __m128i *)((char *)v13 + 55);
                  v223 = _mm_alignr_epi8(v222, v221, 9);
                  v224 = _mm_alignr_epi8(v221, v220, 9);
                  *(__m128i *)(v10 + 48) = v223;
                  v225 = _mm_alignr_epi8(v220, v219, 9);
                  v13 += 4;
                  v226 = _mm_alignr_epi8(v219, v217, 9);
                  *(__m128i *)(v10 + 32) = v224;
                  *(__m128i *)(v10 + 16) = v225;
                  v217 = v222;
                  *(__m128i *)v10 = v226;
                  v10 += 64;
                  v33 = v218 <= 0x40;
                  v218 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v218 + 32) < 0) ^ __OFADD__(32, v218) | (v218 == -32);
                v66 = v218 + 32;
                if ( !v33 )
                {
                  v227 = *(const __m128i *)((char *)v13 + 7);
                  v228 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 23), v227, 9);
                  *(__m128i *)v10 = _mm_alignr_epi8(v227, v222, 9);
                  *(__m128i *)(v10 + 16) = v228;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 0xA:
                v237 = *(const __m128i *)((char *)v13 - 10);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v249 = v12 - 32;
                  v250 = &v13[-1].m128i_i8[6];
                  v251 = 0;
                  do
                  {
                    v252 = _mm_load_si128((const __m128i *)&v250[v251 + 16]);
                    v16 = v249 < 0x20;
                    v249 -= 32;
                    v253 = _mm_load_si128((const __m128i *)&v250[v251 + 32]);
                    v251 += 32;
                    *(__m128i *)(v10 + v251 - 32) = _mm_alignr_epi8(v252, v237, 10);
                    *(__m128i *)(v10 + v251 - 16) = _mm_alignr_epi8(v253, v252, 10);
                    if ( v16 )
                      break;
                    v254 = _mm_load_si128((const __m128i *)&v250[v251 + 16]);
                    v16 = v249 < 0x20;
                    v249 -= 32;
                    v237 = _mm_load_si128((const __m128i *)&v250[v251 + 32]);
                    v251 += 32;
                    *(__m128i *)(v10 + v251 - 32) = _mm_alignr_epi8(v254, v253, 10);
                    *(__m128i *)(v10 + v251 - 16) = _mm_alignr_epi8(v237, v254, 10);
                  }
                  while ( !v16 );
                  v255 = v249 + 32;
                  v256 = v255 + v251;
                  v7 = v256 + v10;
                  v8 = (const __m128i *)&v250[v256 + 10];
                  switch ( v255 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v238 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v239 = *(const __m128i *)((char *)v13 + 6);
                  v240 = *(const __m128i *)((char *)v13 + 22);
                  v241 = *(const __m128i *)((char *)v13 + 38);
                  v242 = *(const __m128i *)((char *)v13 + 54);
                  v243 = _mm_alignr_epi8(v242, v241, 10);
                  v244 = _mm_alignr_epi8(v241, v240, 10);
                  *(__m128i *)(v10 + 48) = v243;
                  v245 = _mm_alignr_epi8(v240, v239, 10);
                  v13 += 4;
                  v246 = _mm_alignr_epi8(v239, v237, 10);
                  *(__m128i *)(v10 + 32) = v244;
                  *(__m128i *)(v10 + 16) = v245;
                  v237 = v242;
                  *(__m128i *)v10 = v246;
                  v10 += 64;
                  v33 = v238 <= 0x40;
                  v238 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v238 + 32) < 0) ^ __OFADD__(32, v238) | (v238 == -32);
                v66 = v238 + 32;
                if ( !v33 )
                {
                  v247 = *(const __m128i *)((char *)v13 + 6);
                  v248 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 22), v247, 10);
                  *(__m128i *)v10 = _mm_alignr_epi8(v247, v242, 10);
                  *(__m128i *)(v10 + 16) = v248;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 0xB:
                v257 = *(const __m128i *)((char *)v13 - 11);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v269 = v12 - 32;
                  v270 = &v13[-1].m128i_i8[5];
                  v271 = 0;
                  do
                  {
                    v272 = _mm_load_si128((const __m128i *)&v270[v271 + 16]);
                    v16 = v269 < 0x20;
                    v269 -= 32;
                    v273 = _mm_load_si128((const __m128i *)&v270[v271 + 32]);
                    v271 += 32;
                    *(__m128i *)(v10 + v271 - 32) = _mm_alignr_epi8(v272, v257, 11);
                    *(__m128i *)(v10 + v271 - 16) = _mm_alignr_epi8(v273, v272, 11);
                    if ( v16 )
                      break;
                    v274 = _mm_load_si128((const __m128i *)&v270[v271 + 16]);
                    v16 = v269 < 0x20;
                    v269 -= 32;
                    v257 = _mm_load_si128((const __m128i *)&v270[v271 + 32]);
                    v271 += 32;
                    *(__m128i *)(v10 + v271 - 32) = _mm_alignr_epi8(v274, v273, 11);
                    *(__m128i *)(v10 + v271 - 16) = _mm_alignr_epi8(v257, v274, 11);
                  }
                  while ( !v16 );
                  v275 = v269 + 32;
                  v276 = v275 + v271;
                  v7 = v276 + v10;
                  v8 = (const __m128i *)&v270[v276 + 11];
                  switch ( v275 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v258 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v259 = *(const __m128i *)((char *)v13 + 5);
                  v260 = *(const __m128i *)((char *)v13 + 21);
                  v261 = *(const __m128i *)((char *)v13 + 37);
                  v262 = *(const __m128i *)((char *)v13 + 53);
                  v263 = _mm_alignr_epi8(v262, v261, 11);
                  v264 = _mm_alignr_epi8(v261, v260, 11);
                  *(__m128i *)(v10 + 48) = v263;
                  v265 = _mm_alignr_epi8(v260, v259, 11);
                  v13 += 4;
                  v266 = _mm_alignr_epi8(v259, v257, 11);
                  *(__m128i *)(v10 + 32) = v264;
                  *(__m128i *)(v10 + 16) = v265;
                  v257 = v262;
                  *(__m128i *)v10 = v266;
                  v10 += 64;
                  v33 = v258 <= 0x40;
                  v258 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v258 + 32) < 0) ^ __OFADD__(32, v258) | (v258 == -32);
                v66 = v258 + 32;
                if ( !v33 )
                {
                  v267 = *(const __m128i *)((char *)v13 + 5);
                  v268 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 21), v267, 11);
                  *(__m128i *)v10 = _mm_alignr_epi8(v267, v262, 11);
                  *(__m128i *)(v10 + 16) = v268;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 0xC:
                v277 = *(const __m128i *)((char *)v13 - 12);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v289 = v12 - 32;
                  v290 = &v13[-1].m128i_i8[4];
                  v291 = 0;
                  do
                  {
                    v292 = _mm_load_si128((const __m128i *)&v290[v291 + 16]);
                    v16 = v289 < 0x20;
                    v289 -= 32;
                    v293 = _mm_load_si128((const __m128i *)&v290[v291 + 32]);
                    v291 += 32;
                    *(__m128i *)(v10 + v291 - 32) = _mm_alignr_epi8(v292, v277, 12);
                    *(__m128i *)(v10 + v291 - 16) = _mm_alignr_epi8(v293, v292, 12);
                    if ( v16 )
                      break;
                    v294 = _mm_load_si128((const __m128i *)&v290[v291 + 16]);
                    v16 = v289 < 0x20;
                    v289 -= 32;
                    v277 = _mm_load_si128((const __m128i *)&v290[v291 + 32]);
                    v291 += 32;
                    *(__m128i *)(v10 + v291 - 32) = _mm_alignr_epi8(v294, v293, 12);
                    *(__m128i *)(v10 + v291 - 16) = _mm_alignr_epi8(v277, v294, 12);
                  }
                  while ( !v16 );
                  v295 = v289 + 32;
                  v296 = v295 + v291;
                  v7 = v296 + v10;
                  v8 = (const __m128i *)&v290[v296 + 12];
                  switch ( v295 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v278 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v279 = *(const __m128i *)((char *)v13 + 4);
                  v280 = *(const __m128i *)((char *)v13 + 20);
                  v281 = *(const __m128i *)((char *)v13 + 36);
                  v282 = *(const __m128i *)((char *)v13 + 52);
                  v283 = _mm_alignr_epi8(v282, v281, 12);
                  v284 = _mm_alignr_epi8(v281, v280, 12);
                  *(__m128i *)(v10 + 48) = v283;
                  v285 = _mm_alignr_epi8(v280, v279, 12);
                  v13 += 4;
                  v286 = _mm_alignr_epi8(v279, v277, 12);
                  *(__m128i *)(v10 + 32) = v284;
                  *(__m128i *)(v10 + 16) = v285;
                  v277 = v282;
                  *(__m128i *)v10 = v286;
                  v10 += 64;
                  v33 = v278 <= 0x40;
                  v278 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v278 + 32) < 0) ^ __OFADD__(32, v278) | (v278 == -32);
                v66 = v278 + 32;
                if ( !v33 )
                {
                  v287 = *(const __m128i *)((char *)v13 + 4);
                  v288 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 20), v287, 12);
                  *(__m128i *)v10 = _mm_alignr_epi8(v287, v282, 12);
                  *(__m128i *)(v10 + 16) = v288;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 0xD:
                v297 = *(const __m128i *)((char *)v13 - 13);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v309 = v12 - 32;
                  v310 = &v13[-1].m128i_i8[3];
                  v311 = 0;
                  do
                  {
                    v312 = _mm_load_si128((const __m128i *)&v310[v311 + 16]);
                    v16 = v309 < 0x20;
                    v309 -= 32;
                    v313 = _mm_load_si128((const __m128i *)&v310[v311 + 32]);
                    v311 += 32;
                    *(__m128i *)(v10 + v311 - 32) = _mm_alignr_epi8(v312, v297, 13);
                    *(__m128i *)(v10 + v311 - 16) = _mm_alignr_epi8(v313, v312, 13);
                    if ( v16 )
                      break;
                    v314 = _mm_load_si128((const __m128i *)&v310[v311 + 16]);
                    v16 = v309 < 0x20;
                    v309 -= 32;
                    v297 = _mm_load_si128((const __m128i *)&v310[v311 + 32]);
                    v311 += 32;
                    *(__m128i *)(v10 + v311 - 32) = _mm_alignr_epi8(v314, v313, 13);
                    *(__m128i *)(v10 + v311 - 16) = _mm_alignr_epi8(v297, v314, 13);
                  }
                  while ( !v16 );
                  v315 = v309 + 32;
                  v316 = v315 + v311;
                  v7 = v316 + v10;
                  v8 = (const __m128i *)&v310[v316 + 13];
                  switch ( v315 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v298 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v299 = *(const __m128i *)((char *)v13 + 3);
                  v300 = *(const __m128i *)((char *)v13 + 19);
                  v301 = *(const __m128i *)((char *)v13 + 35);
                  v302 = *(const __m128i *)((char *)v13 + 51);
                  v303 = _mm_alignr_epi8(v302, v301, 13);
                  v304 = _mm_alignr_epi8(v301, v300, 13);
                  *(__m128i *)(v10 + 48) = v303;
                  v305 = _mm_alignr_epi8(v300, v299, 13);
                  v13 += 4;
                  v306 = _mm_alignr_epi8(v299, v297, 13);
                  *(__m128i *)(v10 + 32) = v304;
                  *(__m128i *)(v10 + 16) = v305;
                  v297 = v302;
                  *(__m128i *)v10 = v306;
                  v10 += 64;
                  v33 = v298 <= 0x40;
                  v298 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v298 + 32) < 0) ^ __OFADD__(32, v298) | (v298 == -32);
                v66 = v298 + 32;
                if ( !v33 )
                {
                  v307 = *(const __m128i *)((char *)v13 + 3);
                  v308 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 19), v307, 13);
                  *(__m128i *)v10 = _mm_alignr_epi8(v307, v302, 13);
                  *(__m128i *)(v10 + 16) = v308;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 0xE:
                v317 = *(const __m128i *)((char *)v13 - 14);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v329 = v12 - 32;
                  v330 = &v13[-1].m128i_i8[2];
                  v331 = 0;
                  do
                  {
                    v332 = _mm_load_si128((const __m128i *)&v330[v331 + 16]);
                    v16 = v329 < 0x20;
                    v329 -= 32;
                    v333 = _mm_load_si128((const __m128i *)&v330[v331 + 32]);
                    v331 += 32;
                    *(__m128i *)(v10 + v331 - 32) = _mm_alignr_epi8(v332, v317, 14);
                    *(__m128i *)(v10 + v331 - 16) = _mm_alignr_epi8(v333, v332, 14);
                    if ( v16 )
                      break;
                    v334 = _mm_load_si128((const __m128i *)&v330[v331 + 16]);
                    v16 = v329 < 0x20;
                    v329 -= 32;
                    v317 = _mm_load_si128((const __m128i *)&v330[v331 + 32]);
                    v331 += 32;
                    *(__m128i *)(v10 + v331 - 32) = _mm_alignr_epi8(v334, v333, 14);
                    *(__m128i *)(v10 + v331 - 16) = _mm_alignr_epi8(v317, v334, 14);
                  }
                  while ( !v16 );
                  v335 = v329 + 32;
                  v336 = v335 + v331;
                  v7 = v336 + v10;
                  v8 = (const __m128i *)&v330[v336 + 14];
                  switch ( v335 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v318 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v319 = *(const __m128i *)((char *)v13 + 2);
                  v320 = *(const __m128i *)((char *)v13 + 18);
                  v321 = *(const __m128i *)((char *)v13 + 34);
                  v322 = *(const __m128i *)((char *)v13 + 50);
                  v323 = _mm_alignr_epi8(v322, v321, 14);
                  v324 = _mm_alignr_epi8(v321, v320, 14);
                  *(__m128i *)(v10 + 48) = v323;
                  v325 = _mm_alignr_epi8(v320, v319, 14);
                  v13 += 4;
                  v326 = _mm_alignr_epi8(v319, v317, 14);
                  *(__m128i *)(v10 + 32) = v324;
                  *(__m128i *)(v10 + 16) = v325;
                  v317 = v322;
                  *(__m128i *)v10 = v326;
                  v10 += 64;
                  v33 = v318 <= 0x40;
                  v318 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v318 + 32) < 0) ^ __OFADD__(32, v318) | (v318 == -32);
                v66 = v318 + 32;
                if ( !v33 )
                {
                  v327 = *(const __m128i *)((char *)v13 + 2);
                  v328 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 18), v327, 14);
                  *(__m128i *)v10 = _mm_alignr_epi8(v327, v322, 14);
                  *(__m128i *)(v10 + 16) = v328;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                goto LABEL_167;
              case 0xF:
                v337 = *(const __m128i *)((char *)v13 - 15);
                *a2 = v9;
                if ( v12 < _x86_data_cache_size_half )
                {
                  v349 = v12 - 32;
                  v350 = &v13[-1].m128i_i8[1];
                  v351 = 0;
                  do
                  {
                    v352 = _mm_load_si128((const __m128i *)&v350[v351 + 16]);
                    v16 = v349 < 0x20;
                    v349 -= 32;
                    v353 = _mm_load_si128((const __m128i *)&v350[v351 + 32]);
                    v351 += 32;
                    *(__m128i *)(v10 + v351 - 32) = _mm_alignr_epi8(v352, v337, 15);
                    *(__m128i *)(v10 + v351 - 16) = _mm_alignr_epi8(v353, v352, 15);
                    if ( v16 )
                      break;
                    v354 = _mm_load_si128((const __m128i *)&v350[v351 + 16]);
                    v16 = v349 < 0x20;
                    v349 -= 32;
                    v337 = _mm_load_si128((const __m128i *)&v350[v351 + 32]);
                    v351 += 32;
                    *(__m128i *)(v10 + v351 - 32) = _mm_alignr_epi8(v354, v353, 15);
                    *(__m128i *)(v10 + v351 - 16) = _mm_alignr_epi8(v337, v354, 15);
                  }
                  while ( !v16 );
                  v355 = v349 + 32;
                  v356 = v355 + v351;
                  v7 = v356 + v10;
                  v8 = (const __m128i *)&v350[v356 + 15];
                  switch ( v355 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
                v338 = v12 - 64;
                do
                {
                  _mm_prefetch(v13[28].m128i_i8, 1);
                  _mm_prefetch((const char *)(v10 + 448), 1);
                  v339 = *(const __m128i *)((char *)v13 + 1);
                  v340 = *(const __m128i *)((char *)v13 + 17);
                  v341 = *(const __m128i *)((char *)v13 + 33);
                  v342 = *(const __m128i *)((char *)v13 + 49);
                  v343 = _mm_alignr_epi8(v342, v341, 15);
                  v344 = _mm_alignr_epi8(v341, v340, 15);
                  *(__m128i *)(v10 + 48) = v343;
                  v345 = _mm_alignr_epi8(v340, v339, 15);
                  v13 += 4;
                  v346 = _mm_alignr_epi8(v339, v337, 15);
                  *(__m128i *)(v10 + 32) = v344;
                  *(__m128i *)(v10 + 16) = v345;
                  v337 = v342;
                  *(__m128i *)v10 = v346;
                  v10 += 64;
                  v33 = v338 <= 0x40;
                  v338 -= 64;
                }
                while ( !v33 );
                v33 = ((int)(v338 + 32) < 0) ^ __OFADD__(32, v338) | (v338 == -32);
                v66 = v338 + 32;
                if ( !v33 )
                {
                  v347 = *(const __m128i *)((char *)v13 + 1);
                  v348 = _mm_alignr_epi8(*(const __m128i *)((char *)v13 + 17), v347, 15);
                  *(__m128i *)v10 = _mm_alignr_epi8(v347, v342, 15);
                  *(__m128i *)(v10 + 16) = v348;
                  v7 = v10 + v66 + 32;
                  v8 = (const __m128i *)((char *)v13 + v66 + 32);
                  switch ( v66 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_191;
                    case 2u:
                      goto LABEL_203;
                    case 3u:
                      goto LABEL_214;
                    case 4u:
                      goto LABEL_173;
                    case 5u:
                      goto LABEL_180;
                    case 6u:
                      goto LABEL_197;
                    case 7u:
                      goto LABEL_248;
                    case 8u:
                      goto LABEL_178;
                    case 9u:
                      goto LABEL_190;
                    case 0xAu:
                      goto LABEL_202;
                    case 0xBu:
                      goto LABEL_213;
                    case 0xCu:
                      goto LABEL_172;
                    case 0xDu:
                      goto LABEL_185;
                    case 0xEu:
                      goto LABEL_196;
                    case 0xFu:
                      goto LABEL_208;
                    case 0x10u:
                      goto LABEL_177;
                    case 0x11u:
                      goto LABEL_189;
                    case 0x12u:
                      goto LABEL_201;
                    case 0x13u:
                      goto LABEL_212;
                    case 0x14u:
                      goto LABEL_171;
                    case 0x15u:
                      goto LABEL_184;
                    case 0x16u:
                      goto LABEL_195;
                    case 0x17u:
                      goto LABEL_207;
                    case 0x18u:
                      goto LABEL_176;
                    case 0x19u:
                      goto LABEL_188;
                    case 0x1Au:
                      goto LABEL_200;
                    case 0x1Bu:
                      goto LABEL_211;
                    case 0x1Cu:
                      goto LABEL_170;
                    case 0x1Du:
                      goto LABEL_183;
                    case 0x1Eu:
                      goto LABEL_194;
                    case 0x1Fu:
                      goto LABEL_206;
                    case 0x20u:
                      goto LABEL_175;
                    case 0x21u:
                      goto LABEL_187;
                    case 0x22u:
                      goto LABEL_199;
                    case 0x23u:
                      goto LABEL_210;
                    case 0x24u:
                      goto LABEL_169;
                    case 0x25u:
                      goto LABEL_182;
                    case 0x26u:
                      goto LABEL_193;
                    case 0x27u:
                      goto LABEL_205;
                    case 0x28u:
                      goto LABEL_174;
                    case 0x29u:
                      goto LABEL_186;
                    case 0x2Au:
                      goto LABEL_198;
                    case 0x2Bu:
                      goto LABEL_209;
                    case 0x2Cu:
                      goto LABEL_168;
                    case 0x2Du:
                      goto LABEL_181;
                    case 0x2Eu:
                      goto LABEL_192;
                    case 0x2Fu:
                      goto LABEL_204;
                  }
                }
LABEL_167:
                v357 = v66 + 32;
                v7 = v10 + v357;
                v8 = (const __m128i *)((char *)v13 + v357);
                switch ( v357 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_191;
                  case 2u:
                    goto LABEL_203;
                  case 3u:
                    goto LABEL_214;
                  case 4u:
                    goto LABEL_173;
                  case 5u:
                    goto LABEL_180;
                  case 6u:
                    goto LABEL_197;
                  case 7u:
                    goto LABEL_248;
                  case 8u:
                    goto LABEL_178;
                  case 9u:
                    goto LABEL_190;
                  case 0xAu:
                    goto LABEL_202;
                  case 0xBu:
                    goto LABEL_213;
                  case 0xCu:
                    goto LABEL_172;
                  case 0xDu:
                    goto LABEL_185;
                  case 0xEu:
                    goto LABEL_196;
                  case 0xFu:
                    goto LABEL_208;
                  case 0x10u:
                    goto LABEL_177;
                  case 0x11u:
                    goto LABEL_189;
                  case 0x12u:
                    goto LABEL_201;
                  case 0x13u:
                    goto LABEL_212;
                  case 0x14u:
                    goto LABEL_171;
                  case 0x15u:
                    goto LABEL_184;
                  case 0x16u:
                    goto LABEL_195;
                  case 0x17u:
                    goto LABEL_207;
                  case 0x18u:
                    goto LABEL_176;
                  case 0x19u:
                    goto LABEL_188;
                  case 0x1Au:
                    goto LABEL_200;
                  case 0x1Bu:
                    goto LABEL_211;
                  case 0x1Cu:
                    goto LABEL_170;
                  case 0x1Du:
                    goto LABEL_183;
                  case 0x1Eu:
                    goto LABEL_194;
                  case 0x1Fu:
                    goto LABEL_206;
                  case 0x20u:
                    goto LABEL_175;
                  case 0x21u:
                    goto LABEL_187;
                  case 0x22u:
                    goto LABEL_199;
                  case 0x23u:
                    goto LABEL_210;
                  case 0x24u:
                    goto LABEL_169;
                  case 0x25u:
                    goto LABEL_182;
                  case 0x26u:
                    goto LABEL_193;
                  case 0x27u:
                    goto LABEL_205;
                  case 0x28u:
                    goto LABEL_174;
                  case 0x29u:
                    goto LABEL_186;
                  case 0x2Au:
                    goto LABEL_198;
                  case 0x2Bu:
                    goto LABEL_209;
                  case 0x2Cu:
                    goto LABEL_168;
                  case 0x2Du:
                    goto LABEL_181;
                  case 0x2Eu:
                    goto LABEL_192;
                  case 0x2Fu:
                    goto LABEL_204;
                }
            }
          }
          *a2 = v9;
          if ( v12 <= 0x7F )
          {
            v14 = v12 - 32;
            v15 = _mm_load_si128(v13 + 1);
            v16 = v14 < 0x20;
            v17 = v14 - 32;
            *(__m128i *)v10 = _mm_load_si128(v13);
            *(__m128i *)(v10 + 16) = v15;
            v18 = 32;
            if ( !v16 )
            {
              v19 = _mm_load_si128(v13 + 3);
              v16 = v17 < 0x20;
              v17 -= 32;
              *(__m128i *)(v10 + 32) = _mm_load_si128(v13 + 2);
              *(__m128i *)(v10 + 48) = v19;
              v18 = 64;
              if ( !v16 )
              {
                v20 = _mm_load_si128(v13 + 5);
                v16 = v17 < 0x20;
                v17 -= 32;
                *(__m128i *)(v10 + 64) = _mm_load_si128(v13 + 4);
                *(__m128i *)(v10 + 80) = v20;
                v18 = 96;
                if ( !v16 )
                {
                  v21 = _mm_load_si128(v13 + 7);
                  v17 -= 32;
                  *(__m128i *)(v10 + 96) = _mm_load_si128(v13 + 6);
                  *(__m128i *)(v10 + 112) = v21;
                  v18 = 128;
                }
              }
            }
            v22 = v17 + 32;
            v23 = v22 + v18;
            v7 = v23 + v10;
            v8 = (const __m128i *)((char *)v13 + v23);
            switch ( v22 )
            {
              case 0u:
                goto LABEL_218;
              case 1u:
                goto LABEL_230;
              case 2u:
                goto LABEL_242;
              case 3u:
                goto LABEL_254;
              case 4u:
                goto LABEL_260;
              case 5u:
                goto LABEL_221;
              case 6u:
                goto LABEL_236;
              case 7u:
                goto LABEL_248;
              case 8u:
                goto LABEL_217;
              case 9u:
                goto LABEL_229;
              case 0xAu:
                goto LABEL_241;
              case 0xBu:
                goto LABEL_253;
              case 0xCu:
                goto LABEL_259;
              case 0xDu:
                goto LABEL_224;
              case 0xEu:
                goto LABEL_235;
              case 0xFu:
                goto LABEL_247;
              case 0x10u:
                goto LABEL_220;
              case 0x11u:
                goto LABEL_232;
              case 0x12u:
                goto LABEL_244;
              case 0x13u:
                goto LABEL_256;
              case 0x14u:
                goto LABEL_262;
              case 0x15u:
                goto LABEL_226;
              case 0x16u:
                goto LABEL_238;
              case 0x17u:
                goto LABEL_250;
              case 0x18u:
                goto LABEL_216;
              case 0x19u:
                goto LABEL_228;
              case 0x1Au:
                goto LABEL_240;
              case 0x1Bu:
                goto LABEL_252;
              case 0x1Cu:
                goto LABEL_258;
              case 0x1Du:
                goto LABEL_223;
              case 0x1Eu:
                goto LABEL_234;
              case 0x1Fu:
                goto LABEL_246;
              case 0x20u:
                *(__m128i *)(v7 - 32) = _mm_load_si128(v8 - 2);
LABEL_220:
                *(__m128i *)(v7 - 16) = _mm_load_si128(v8 - 1);
                return a2;
              case 0x21u:
                *(__m128i *)(v7 - 33) = _mm_load_si128((const __m128i *)((char *)v8 - 33));
LABEL_232:
                *(__m128i *)(v7 - 17) = _mm_load_si128((const __m128i *)((char *)v8 - 17));
                *(_BYTE *)(v7 - 1) = v8[-1].m128i_i8[15];
                return a2;
              case 0x22u:
                *(__m128i *)(v7 - 34) = _mm_load_si128((const __m128i *)((char *)v8 - 34));
LABEL_244:
                *(__m128i *)(v7 - 18) = _mm_load_si128((const __m128i *)((char *)v8 - 18));
                *(_WORD *)(v7 - 2) = v8[-1].m128i_i16[7];
                return a2;
              case 0x23u:
                *(__m128i *)(v7 - 35) = _mm_load_si128((const __m128i *)((char *)v8 - 35));
LABEL_256:
                *(__m128i *)(v7 - 19) = _mm_load_si128((const __m128i *)((char *)v8 - 19));
                v371 = *(__int16 *)((char *)&v8[-1].m128i_i16[6] + 1);
                v372 = v8[-1].m128i_i8[15];
                *(_WORD *)(v7 - 3) = v371;
                *(_BYTE *)(v7 - 1) = v372;
                return a2;
              case 0x24u:
                *(__m128i *)(v7 - 36) = _mm_load_si128((const __m128i *)((char *)v8 - 36));
LABEL_262:
                *(__m128i *)(v7 - 20) = _mm_load_si128((const __m128i *)((char *)v8 - 20));
                *(_DWORD *)(v7 - 4) = v8[-1].m128i_i32[3];
                return a2;
              case 0x25u:
                *(__m128i *)(v7 - 37) = _mm_load_si128((const __m128i *)((char *)v8 - 37));
LABEL_226:
                *(__m128i *)(v7 - 21) = _mm_load_si128((const __m128i *)((char *)v8 - 21));
                *(_DWORD *)(v7 - 5) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
                *(_BYTE *)(v7 - 1) = v8[-1].m128i_i8[15];
                return a2;
              case 0x26u:
                *(__m128i *)(v7 - 38) = _mm_load_si128((const __m128i *)((char *)v8 - 38));
LABEL_238:
                *(__m128i *)(v7 - 22) = _mm_load_si128((const __m128i *)((char *)v8 - 22));
                *(_DWORD *)(v7 - 6) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 2);
                *(_WORD *)(v7 - 2) = v8[-1].m128i_i16[7];
                return a2;
              case 0x27u:
                *(__m128i *)(v7 - 39) = _mm_load_si128((const __m128i *)((char *)v8 - 39));
LABEL_250:
                *(__m128i *)(v7 - 23) = _mm_load_si128((const __m128i *)((char *)v8 - 23));
                *(_DWORD *)(v7 - 7) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 1);
                v367 = *(__int16 *)((char *)&v8[-1].m128i_i16[6] + 1);
                v368 = v8[-1].m128i_i8[15];
                *(_WORD *)(v7 - 3) = v367;
                *(_BYTE *)(v7 - 1) = v368;
                return a2;
              case 0x28u:
                *(__m128i *)(v7 - 40) = _mm_load_si128((const __m128i *)((char *)v8 - 40));
LABEL_216:
                *(__m128i *)(v7 - 24) = _mm_load_si128((const __m128i *)((char *)v8 - 24));
                goto LABEL_217;
              case 0x29u:
                *(__m128i *)(v7 - 41) = _mm_load_si128((const __m128i *)((char *)v8 - 41));
LABEL_228:
                *(__m128i *)(v7 - 25) = _mm_load_si128((const __m128i *)((char *)v8 - 25));
                goto LABEL_229;
              case 0x2Au:
                *(__m128i *)(v7 - 42) = _mm_load_si128((const __m128i *)((char *)v8 - 42));
LABEL_240:
                *(__m128i *)(v7 - 26) = _mm_load_si128((const __m128i *)((char *)v8 - 26));
                goto LABEL_241;
              case 0x2Bu:
                *(__m128i *)(v7 - 43) = _mm_load_si128((const __m128i *)((char *)v8 - 43));
LABEL_252:
                *(__m128i *)(v7 - 27) = _mm_load_si128((const __m128i *)((char *)v8 - 27));
                goto LABEL_253;
              case 0x2Cu:
                *(__m128i *)(v7 - 44) = _mm_load_si128((const __m128i *)((char *)v8 - 44));
LABEL_258:
                *(__m128i *)(v7 - 28) = _mm_load_si128((const __m128i *)((char *)v8 - 28));
                goto LABEL_259;
              case 0x2Du:
                *(__m128i *)(v7 - 45) = _mm_load_si128((const __m128i *)((char *)v8 - 45));
LABEL_223:
                *(__m128i *)(v7 - 29) = _mm_load_si128((const __m128i *)((char *)v8 - 29));
                goto LABEL_224;
              case 0x2Eu:
                *(__m128i *)(v7 - 46) = _mm_load_si128((const __m128i *)((char *)v8 - 46));
LABEL_234:
                *(__m128i *)(v7 - 30) = _mm_load_si128((const __m128i *)((char *)v8 - 30));
                goto LABEL_235;
              case 0x2Fu:
                *(__m128i *)(v7 - 47) = _mm_load_si128((const __m128i *)((char *)v8 - 47));
LABEL_246:
                *(__m128i *)(v7 - 31) = _mm_load_si128((const __m128i *)((char *)v8 - 31));
                goto LABEL_247;
            }
          }
          v16 = v12 < _x86_data_cache_size_half;
          v24 = v12 - 128;
          if ( v16 )
          {
            do
            {
              v25 = _mm_load_si128(v13);
              v26 = _mm_load_si128(v13 + 1);
              v27 = _mm_load_si128(v13 + 2);
              v28 = _mm_load_si128(v13 + 3);
              v29 = _mm_load_si128(v13 + 4);
              v30 = _mm_load_si128(v13 + 5);
              v31 = _mm_load_si128(v13 + 6);
              v32 = _mm_load_si128(v13 + 7);
              v13 += 8;
              v16 = v24 < 0x80;
              v24 -= 128;
              *(__m128i *)v10 = v25;
              *(__m128i *)(v10 + 16) = v26;
              *(__m128i *)(v10 + 32) = v27;
              *(__m128i *)(v10 + 48) = v28;
              *(__m128i *)(v10 + 64) = v29;
              *(__m128i *)(v10 + 80) = v30;
              *(__m128i *)(v10 + 96) = v31;
              *(__m128i *)(v10 + 112) = v32;
              v10 += 128;
            }
            while ( !v16 );
            v33 = (int)v24 < -64;
            v34 = v24 + 128;
            if ( !v33 )
            {
              v34 -= 64;
              v35 = _mm_load_si128(v13 + 1);
              *(__m128i *)v10 = _mm_load_si128(v13);
              *(__m128i *)(v10 + 16) = v35;
              v36 = _mm_load_si128(v13 + 2);
              v37 = _mm_load_si128(v13 + 3);
              v13 += 4;
              *(__m128i *)(v10 + 32) = v36;
              *(__m128i *)(v10 + 48) = v37;
              v10 += 64;
            }
            if ( v34 >= 0x20 )
            {
              v38 = _mm_load_si128(v13);
              v34 -= 32;
              v39 = _mm_load_si128(v13 + 1);
              v13 += 2;
              *(__m128i *)v10 = v38;
              *(__m128i *)(v10 + 16) = v39;
              v10 += 32;
            }
            while ( 2 )
            {
              v7 = v34 + v10;
              v8 = (const __m128i *)((char *)v13 + v34);
              switch ( v34 )
              {
                case 0u:
                  return a2;
                case 1u:
                  goto LABEL_191;
                case 2u:
                  goto LABEL_203;
                case 3u:
                  goto LABEL_214;
                case 4u:
                  goto LABEL_173;
                case 5u:
                  goto LABEL_180;
                case 6u:
                  goto LABEL_197;
                case 7u:
                  goto LABEL_248;
                case 8u:
                  goto LABEL_178;
                case 9u:
                  goto LABEL_190;
                case 0xAu:
                  goto LABEL_202;
                case 0xBu:
                  goto LABEL_213;
                case 0xCu:
                  goto LABEL_172;
                case 0xDu:
                  goto LABEL_185;
                case 0xEu:
                  goto LABEL_196;
                case 0xFu:
                  goto LABEL_208;
                default:
                  v34 -= 16;
                  v40 = _mm_load_si128(v8);
                  v13 = v8 + 1;
                  *(__m128i *)v7 = v40;
                  v10 = v7 + 16;
                  continue;
              }
            }
          }
          do
          {
            _mm_prefetch(v13[28].m128i_i8, 1);
            _mm_prefetch(v13[40].m128i_i8, 1);
            _mm_prefetch((const char *)(v10 + 448), 1);
            v41 = _mm_load_si128(v13);
            v42 = _mm_load_si128(v13 + 1);
            v43 = _mm_load_si128(v13 + 2);
            v44 = _mm_load_si128(v13 + 3);
            v45 = _mm_load_si128(v13 + 4);
            v46 = _mm_load_si128(v13 + 5);
            v47 = _mm_load_si128(v13 + 6);
            v48 = _mm_load_si128(v13 + 7);
            v13 += 8;
            v16 = v24 < 0x80;
            v24 -= 128;
            *(__m128i *)v10 = v41;
            *(__m128i *)(v10 + 16) = v42;
            *(__m128i *)(v10 + 32) = v43;
            *(__m128i *)(v10 + 48) = v44;
            *(__m128i *)(v10 + 64) = v45;
            *(__m128i *)(v10 + 80) = v46;
            *(__m128i *)(v10 + 96) = v47;
            *(__m128i *)(v10 + 112) = v48;
            v10 += 128;
          }
          while ( !v16 );
          v33 = (int)v24 < -64;
          v49 = v24 + 128;
          if ( !v33 )
          {
            v49 -= 64;
            v50 = _mm_load_si128(v13 + 1);
            *(__m128i *)v10 = _mm_load_si128(v13);
            *(__m128i *)(v10 + 16) = v50;
            v51 = _mm_load_si128(v13 + 2);
            v52 = _mm_load_si128(v13 + 3);
            v13 += 4;
            *(__m128i *)(v10 + 32) = v51;
            *(__m128i *)(v10 + 48) = v52;
            v10 += 64;
          }
          if ( v49 >= 0x20 )
          {
            v53 = _mm_load_si128(v13);
            v49 -= 32;
            v54 = _mm_load_si128(v13 + 1);
            v13 += 2;
            *(__m128i *)v10 = v53;
            *(__m128i *)(v10 + 16) = v54;
            v10 += 32;
          }
          while ( 2 )
          {
            v7 = v49 + v10;
            v8 = (const __m128i *)((char *)v13 + v49);
            switch ( v49 )
            {
              case 0u:
                goto LABEL_218;
              case 1u:
                goto LABEL_230;
              case 2u:
                goto LABEL_242;
              case 3u:
                goto LABEL_254;
              case 4u:
                goto LABEL_260;
              case 5u:
LABEL_221:
                v363 = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
                v364 = v8[-1].m128i_i32[3];
                *(_DWORD *)(v7 - 5) = v363;
                *(_DWORD *)(v7 - 4) = v364;
                return a2;
              case 6u:
                goto LABEL_236;
              case 7u:
                goto LABEL_248;
              case 8u:
LABEL_217:
                *(_QWORD *)(v7 - 8) = v8[-1].m128i_i64[1];
LABEL_218:
                result = a2;
                break;
              case 9u:
LABEL_229:
                *(_QWORD *)(v7 - 9) = *(__int64 *)((char *)v8[-1].m128i_i64 + 7);
LABEL_230:
                *(_BYTE *)(v7 - 1) = v8[-1].m128i_i8[15];
                result = a2;
                break;
              case 0xAu:
LABEL_241:
                *(_QWORD *)(v7 - 10) = *(__int64 *)((char *)v8[-1].m128i_i64 + 6);
LABEL_242:
                *(_WORD *)(v7 - 2) = v8[-1].m128i_i16[7];
                result = a2;
                break;
              case 0xBu:
LABEL_253:
                *(_QWORD *)(v7 - 11) = *(__int64 *)((char *)v8[-1].m128i_i64 + 5);
LABEL_254:
                v369 = *(__int16 *)((char *)&v8[-1].m128i_i16[6] + 1);
                v370 = v8[-1].m128i_i8[15];
                *(_WORD *)(v7 - 3) = v369;
                *(_BYTE *)(v7 - 1) = v370;
                result = a2;
                break;
              case 0xCu:
LABEL_259:
                *(_QWORD *)(v7 - 12) = *(__int64 *)((char *)v8[-1].m128i_i64 + 4);
LABEL_260:
                *(_DWORD *)(v7 - 4) = v8[-1].m128i_i32[3];
                result = a2;
                break;
              case 0xDu:
LABEL_224:
                *(_QWORD *)(v7 - 13) = *(__int64 *)((char *)v8[-1].m128i_i64 + 3);
                *(_DWORD *)(v7 - 5) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
                *(_BYTE *)(v7 - 1) = v8[-1].m128i_i8[15];
                result = a2;
                break;
              case 0xEu:
LABEL_235:
                *(_QWORD *)(v7 - 14) = *(__int64 *)((char *)v8[-1].m128i_i64 + 2);
LABEL_236:
                *(_DWORD *)(v7 - 6) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 2);
                *(_WORD *)(v7 - 2) = v8[-1].m128i_i16[7];
                result = a2;
                break;
              case 0xFu:
LABEL_247:
                *(_QWORD *)(v7 - 15) = *(__int64 *)((char *)v8[-1].m128i_i64 + 1);
                goto LABEL_248;
              default:
                v49 -= 16;
                v55 = _mm_load_si128(v8);
                v13 = v8 + 1;
                *(__m128i *)v7 = v55;
                v10 = v7 + 16;
                continue;
            }
            return result;
          }
      }
    }
    v392 = a1;
    v6 = (__m128i *)((char *)a2 + a4);
    a1 = (__m128i *)((char *)a3 + a4);
    if ( (((unsigned int)a2->m128i_u32 + a4) & 3) != 0 )
    {
      if ( ((unsigned __int8)v6 & 1) == 0
        || (a1 = (const __m128i *)((char *)a1 - 1),
            v4 = a4 - 1,
            v6 = (__m128i *)((char *)v6 - 1),
            v6->m128i_i8[0] = a1->m128i_i8[0],
            ((unsigned __int8)v6 & 2) != 0) )
      {
        a1 = (const __m128i *)((char *)a1 - 2);
        v4 -= 2;
        v6 = (__m128i *)((char *)v6 - 2);
        v6->m128i_i16[0] = a1->m128i_i16[0];
      }
    }
    if ( v4 >= 0x40 )
    {
      if ( ((unsigned __int8)v6 & 0xF) != 0 )
      {
        a1 = (const __m128i *)((char *)a1 - 4);
        v4 -= 4;
        v6 = (__m128i *)((char *)v6 - 4);
        v6->m128i_i32[0] = a1->m128i_i32[0];
        if ( ((unsigned __int8)v6 & 0xF) != 0 )
        {
          a1 = (const __m128i *)((char *)a1 - 4);
          v4 -= 4;
          v6 = (__m128i *)((char *)v6 - 4);
          v6->m128i_i32[0] = a1->m128i_i32[0];
          if ( ((unsigned __int8)v6 & 0xF) != 0 )
          {
            a1 = (const __m128i *)((char *)a1 - 4);
            v4 -= 4;
            v6 = (__m128i *)((char *)v6 - 4);
            v6->m128i_i32[0] = a1->m128i_i32[0];
          }
        }
      }
      if ( v4 < 0x40 )
      {
LABEL_305:
        v4 -= 32;
        v6[-1].m128i_i64[1] = a1[-1].m128i_i64[1];
        v6[-1].m128i_i64[0] = a1[-1].m128i_i64[0];
        v6[-2].m128i_i64[1] = a1[-2].m128i_i64[1];
        v6[-2].m128i_i64[0] = a1[-2].m128i_i64[0];
        v6 -= 2;
        a1 -= 2;
      }
      else
      {
        do
        {
          a1 -= 4;
          v4 -= 64;
          v6 -= 4;
          v6[3] = _mm_loadu_si128(a1 + 3);
          v6[2] = _mm_loadu_si128(a1 + 2);
          v6[1] = _mm_loadu_si128(a1 + 1);
          *v6 = _mm_loadu_si128(a1);
        }
        while ( v4 >= 0x40 );
      }
    }
    v6 = (__m128i *)((char *)v6 - v4);
    v5 = (__int64 *)((char *)a1->m128i_i64 - v4);
    a1 = v392;
  }
  switch ( v4 )
  {
    case 0u:
      goto LABEL_274;
    case 1u:
      goto LABEL_282;
    case 2u:
      goto LABEL_293;
    case 3u:
      goto LABEL_301;
    case 4u:
      goto LABEL_273;
    case 5u:
      goto LABEL_281;
    case 6u:
      goto LABEL_289;
    case 7u:
      goto LABEL_297;
    case 8u:
      goto LABEL_277;
    case 9u:
      goto LABEL_285;
    case 0xAu:
      goto LABEL_292;
    case 0xBu:
      goto LABEL_300;
    case 0xCu:
      goto LABEL_272;
    case 0xDu:
      goto LABEL_280;
    case 0xEu:
      goto LABEL_288;
    case 0xFu:
      goto LABEL_296;
    case 0x10u:
      goto LABEL_276;
    case 0x11u:
      goto LABEL_284;
    case 0x12u:
      goto LABEL_291;
    case 0x13u:
      goto LABEL_299;
    case 0x14u:
      goto LABEL_271;
    case 0x15u:
      goto LABEL_279;
    case 0x16u:
      goto LABEL_287;
    case 0x17u:
      goto LABEL_295;
    case 0x18u:
      v6[1].m128i_i64[0] = v5[2];
LABEL_276:
      v6->m128i_i64[1] = v5[1];
LABEL_277:
      v6->m128i_i64[0] = *v5;
      result = a2;
      break;
    case 0x19u:
      *(__int64 *)((char *)v6[1].m128i_i64 + 1) = *(__int64 *)((char *)v5 + 17);
LABEL_284:
      *(__int64 *)((char *)&v6->m128i_i64[1] + 1) = *(__int64 *)((char *)v5 + 9);
LABEL_285:
      *(__int64 *)((char *)v6->m128i_i64 + 1) = *(__int64 *)((char *)v5 + 1);
      v6->m128i_i8[0] = *(_BYTE *)v5;
      result = a2;
      break;
    case 0x1Au:
      *(__int64 *)((char *)v6[1].m128i_i64 + 2) = *(__int64 *)((char *)v5 + 18);
LABEL_291:
      *(__int64 *)((char *)&v6->m128i_i64[1] + 2) = *(__int64 *)((char *)v5 + 10);
LABEL_292:
      *(__int64 *)((char *)v6->m128i_i64 + 2) = *(__int64 *)((char *)v5 + 2);
LABEL_293:
      v6->m128i_i16[0] = *(_WORD *)v5;
      result = a2;
      break;
    case 0x1Bu:
      *(__int64 *)((char *)v6[1].m128i_i64 + 3) = *(__int64 *)((char *)v5 + 19);
LABEL_299:
      *(__int64 *)((char *)&v6->m128i_i64[1] + 3) = *(__int64 *)((char *)v5 + 11);
LABEL_300:
      *(__int64 *)((char *)v6->m128i_i64 + 3) = *(__int64 *)((char *)v5 + 3);
LABEL_301:
      *(__int16 *)((char *)v6->m128i_i16 + 1) = *(_WORD *)((char *)v5 + 1);
      v6->m128i_i8[0] = *(_BYTE *)v5;
      result = a2;
      break;
    case 0x1Cu:
      *(__int64 *)((char *)v6[1].m128i_i64 + 4) = *(__int64 *)((char *)v5 + 20);
LABEL_271:
      *(__int64 *)((char *)&v6->m128i_i64[1] + 4) = *(__int64 *)((char *)v5 + 12);
LABEL_272:
      *(__int64 *)((char *)v6->m128i_i64 + 4) = *(__int64 *)((char *)v5 + 4);
LABEL_273:
      v6->m128i_i32[0] = *(_DWORD *)v5;
LABEL_274:
      result = a2;
      break;
    case 0x1Du:
      *(__int64 *)((char *)v6[1].m128i_i64 + 5) = *(__int64 *)((char *)v5 + 21);
LABEL_279:
      *(__int64 *)((char *)&v6->m128i_i64[1] + 5) = *(__int64 *)((char *)v5 + 13);
LABEL_280:
      *(__int64 *)((char *)v6->m128i_i64 + 5) = *(__int64 *)((char *)v5 + 5);
LABEL_281:
      *(__int32 *)((char *)v6->m128i_i32 + 1) = *(_DWORD *)((char *)v5 + 1);
LABEL_282:
      v6->m128i_i8[0] = *(_BYTE *)v5;
      result = a2;
      break;
    case 0x1Eu:
      *(__int64 *)((char *)v6[1].m128i_i64 + 6) = *(__int64 *)((char *)v5 + 22);
LABEL_287:
      *(__int64 *)((char *)&v6->m128i_i64[1] + 6) = *(__int64 *)((char *)v5 + 14);
LABEL_288:
      *(__int64 *)((char *)v6->m128i_i64 + 6) = *(__int64 *)((char *)v5 + 6);
LABEL_289:
      *(__int32 *)((char *)v6->m128i_i32 + 2) = *(_DWORD *)((char *)v5 + 2);
      v6->m128i_i16[0] = *(_WORD *)v5;
      result = a2;
      break;
    case 0x1Fu:
      *(__int64 *)((char *)v6[1].m128i_i64 + 7) = *(__int64 *)((char *)v5 + 23);
LABEL_295:
      *(__int64 *)((char *)&v6->m128i_i64[1] + 7) = *(__int64 *)((char *)v5 + 15);
LABEL_296:
      *(__int64 *)((char *)v6->m128i_i64 + 7) = *(__int64 *)((char *)v5 + 7);
LABEL_297:
      *(__int32 *)((char *)v6->m128i_i32 + 3) = *(_DWORD *)((char *)v5 + 3);
      *(__int16 *)((char *)v6->m128i_i16 + 1) = *(_WORD *)((char *)v5 + 1);
      v6->m128i_i8[0] = *(_BYTE *)v5;
      result = a2;
      break;
    default:
      goto LABEL_305;
  }
  return result;
}
// 805FB03: conditional instruction was optimized away because %arg_8.4>=20u
// 805FAF6: variable 'v392' is possibly undefined
// 80EB984: using guessed type int _x86_shared_cache_size_half;
// 80EB994: using guessed type int _x86_data_cache_size_half;

//----- (0805FBD0) --------------------------------------------------------
unsigned int __usercall _memmove_chk_ssse3_rep@<eax>(
        const __m128i *a1@<esi>,
        long double fst7_0@<st0>,
        unsigned int a2,
        _DWORD *a3,
        unsigned int a4,
        unsigned int a6)
{
  if ( a6 < a4 )
    _chk_fail(fst7_0);
  return _memmove_ssse3_rep(a1, a2, a3, a4);
}

//----- (0805FBE0) --------------------------------------------------------
unsigned int __usercall _memmove_ssse3_rep@<eax>(const __m128i *a1@<esi>, unsigned int a2, _DWORD *a3, unsigned int a4)
{
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  unsigned int v6; // edx
  __m128i *v7; // edx
  const __m128i *v8; // eax
  __m128i v9; // xmm0
  __m128i *v10; // edx
  __m128i *v11; // esi
  unsigned int v12; // edi
  unsigned int v13; // ecx
  const __m128i *v14; // eax
  unsigned int v15; // ecx
  __m128i v16; // xmm1
  bool v17; // cf
  unsigned int v18; // ecx
  int v19; // edi
  __m128i v20; // xmm1
  __m128i v21; // xmm1
  __m128i v22; // xmm1
  unsigned int v23; // ecx
  unsigned int v24; // edi
  unsigned int v25; // ecx
  __m128i v26; // xmm0
  __m128i v27; // xmm1
  __m128i v28; // xmm2
  __m128i v29; // xmm3
  __m128i v30; // xmm4
  __m128i v31; // xmm5
  __m128i v32; // xmm6
  __m128i v33; // xmm7
  unsigned int v34; // ecx
  __m128i v35; // xmm1
  __m128i v36; // xmm0
  __m128i v37; // xmm1
  __m128i v38; // xmm0
  __m128i v39; // xmm1
  __m128i v40; // xmm0
  unsigned int v41; // ecx
  __m128i v42; // xmm0
  __m128i v43; // xmm1
  __m128i v44; // xmm2
  __m128i v45; // xmm3
  __m128i v46; // xmm4
  __m128i v47; // xmm5
  __m128i v48; // xmm6
  __m128i v49; // xmm7
  unsigned int v50; // ecx
  __m128i v51; // xmm1
  __m128i v52; // xmm0
  __m128i v53; // xmm1
  __m128i v54; // xmm0
  __m128i v55; // xmm1
  __m128i v56; // xmm0
  __m128i *v57; // eax
  __m128i v58; // xmm1
  int v59; // edi
  unsigned int v60; // ecx
  __m128i si128; // xmm2
  __m128i v62; // xmm4
  __m128i v63; // xmm2
  unsigned int v64; // ecx
  unsigned int v65; // edi
  __m128i *v66; // eax
  __m128i v67; // xmm1
  int v68; // edi
  unsigned int v69; // ecx
  __m128i v70; // xmm2
  __m128i v71; // xmm4
  __m128i v72; // xmm2
  unsigned int v73; // ecx
  unsigned int v74; // edi
  __m128i *v75; // eax
  __m128i v76; // xmm1
  int v77; // edi
  unsigned int v78; // ecx
  __m128i v79; // xmm2
  __m128i v80; // xmm4
  __m128i v81; // xmm2
  unsigned int v82; // ecx
  unsigned int v83; // edi
  __m128i *v84; // eax
  __m128i v85; // xmm1
  int v86; // edi
  unsigned int v87; // ecx
  __m128i v88; // xmm2
  __m128i v89; // xmm4
  __m128i v90; // xmm2
  unsigned int v91; // ecx
  unsigned int v92; // edi
  __m128i *v93; // eax
  __m128i v94; // xmm1
  int v95; // edi
  unsigned int v96; // ecx
  __m128i v97; // xmm2
  __m128i v98; // xmm4
  __m128i v99; // xmm2
  unsigned int v100; // ecx
  unsigned int v101; // edi
  __m128i *v102; // eax
  __m128i v103; // xmm1
  int v104; // edi
  unsigned int v105; // ecx
  __m128i v106; // xmm2
  __m128i v107; // xmm4
  __m128i v108; // xmm2
  unsigned int v109; // ecx
  unsigned int v110; // edi
  __m128i *v111; // eax
  __m128i v112; // xmm1
  int v113; // edi
  unsigned int v114; // ecx
  __m128i v115; // xmm2
  __m128i v116; // xmm4
  __m128i v117; // xmm2
  unsigned int v118; // ecx
  unsigned int v119; // edi
  __m128i *v120; // eax
  __m128i v121; // xmm1
  int v122; // edi
  unsigned int v123; // ecx
  __m128i v124; // xmm2
  __m128i v125; // xmm4
  __m128i v126; // xmm2
  unsigned int v127; // ecx
  unsigned int v128; // edi
  __m128i *v129; // eax
  __m128i v130; // xmm1
  int v131; // edi
  unsigned int v132; // ecx
  __m128i v133; // xmm2
  __m128i v134; // xmm4
  __m128i v135; // xmm2
  unsigned int v136; // ecx
  unsigned int v137; // edi
  __m128i *v138; // eax
  __m128i v139; // xmm1
  int v140; // edi
  unsigned int v141; // ecx
  __m128i v142; // xmm2
  __m128i v143; // xmm4
  __m128i v144; // xmm2
  unsigned int v145; // ecx
  unsigned int v146; // edi
  __m128i *v147; // eax
  __m128i v148; // xmm1
  int v149; // edi
  unsigned int v150; // ecx
  __m128i v151; // xmm2
  __m128i v152; // xmm4
  __m128i v153; // xmm2
  unsigned int v154; // ecx
  unsigned int v155; // edi
  __m128i *v156; // eax
  __m128i v157; // xmm1
  int v158; // edi
  unsigned int v159; // ecx
  __m128i v160; // xmm2
  __m128i v161; // xmm4
  __m128i v162; // xmm2
  unsigned int v163; // ecx
  unsigned int v164; // edi
  __m128i *v165; // eax
  __m128i v166; // xmm1
  int v167; // edi
  unsigned int v168; // ecx
  __m128i v169; // xmm2
  __m128i v170; // xmm4
  __m128i v171; // xmm2
  unsigned int v172; // ecx
  unsigned int v173; // edi
  __m128i *v174; // eax
  __m128i v175; // xmm1
  int v176; // edi
  unsigned int v177; // ecx
  __m128i v178; // xmm2
  __m128i v179; // xmm4
  __m128i v180; // xmm2
  unsigned int v181; // ecx
  unsigned int v182; // edi
  __m128i *v183; // eax
  __m128i v184; // xmm1
  int v185; // edi
  unsigned int v186; // ecx
  __m128i v187; // xmm2
  __m128i v188; // xmm4
  __m128i v189; // xmm2
  unsigned int v190; // ecx
  unsigned int v191; // edi
  unsigned int result; // eax
  __int32 v193; // ecx
  __int32 v194; // eax
  __int16 v195; // cx
  __int8 v196; // al
  __m128i v197; // xmm1
  unsigned int v198; // ecx
  __m128i v199; // xmm0
  __m128i v200; // xmm1
  __m128i v201; // xmm2
  __m128i v202; // xmm3
  __m128i v203; // xmm4
  __m128i v204; // xmm5
  __m128i v205; // xmm6
  __m128i v206; // xmm7
  unsigned int v207; // ecx
  __m128i v208; // xmm0
  __m128i v209; // xmm1
  __m128i v210; // xmm2
  __m128i v211; // xmm3
  __m128i v212; // xmm0
  __m128i v213; // xmm1
  __m128i *v214; // edi
  char v215; // dl
  unsigned int v216; // ecx
  unsigned int v217; // edx
  __int8 *v218; // edi
  __int8 *v219; // esi
  const __m128i *v220; // [esp-4h] [ebp-4h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( a2 < (unsigned int)a3 )
    goto LABEL_5;
  if ( (_DWORD *)a2 == a3 )
    return a2;
  if ( a4 >= 0x30 )
  {
    v5 = a3;
    if ( a2 >= (unsigned int)a3 + a4 )
    {
LABEL_5:
      v7 = (__m128i *)(a4 + a2);
      v8 = (const __m128i *)((char *)v5 + a4);
      switch ( a4 )
      {
        case 0u:
          return a2;
        case 1u:
          goto LABEL_118;
        case 2u:
          goto LABEL_130;
        case 3u:
          goto LABEL_142;
        case 4u:
          goto LABEL_105;
        case 5u:
LABEL_107:
          v193 = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
          v194 = v8[-1].m128i_i32[3];
          *(__int32 *)((char *)&v7[-1].m128i_i32[2] + 3) = v193;
          v7[-1].m128i_i32[3] = v194;
          return a2;
        case 6u:
          goto LABEL_129;
        case 7u:
          goto LABEL_141;
        case 8u:
          goto LABEL_104;
        case 9u:
          goto LABEL_117;
        case 0xAu:
          goto LABEL_128;
        case 0xBu:
          goto LABEL_140;
        case 0xCu:
          goto LABEL_103;
        case 0xDu:
          goto LABEL_116;
        case 0xEu:
          goto LABEL_127;
        case 0xFu:
          goto LABEL_139;
        case 0x10u:
          goto LABEL_102;
        case 0x11u:
          goto LABEL_115;
        case 0x12u:
          goto LABEL_126;
        case 0x13u:
          goto LABEL_138;
        case 0x14u:
          goto LABEL_101;
        case 0x15u:
          goto LABEL_114;
        case 0x16u:
          goto LABEL_125;
        case 0x17u:
          goto LABEL_137;
        case 0x18u:
          goto LABEL_100;
        case 0x19u:
          goto LABEL_113;
        case 0x1Au:
          goto LABEL_124;
        case 0x1Bu:
          goto LABEL_136;
        case 0x1Cu:
          goto LABEL_99;
        case 0x1Du:
          goto LABEL_112;
        case 0x1Eu:
          goto LABEL_123;
        case 0x1Fu:
          goto LABEL_135;
        case 0x20u:
          goto LABEL_98;
        case 0x21u:
          goto LABEL_111;
        case 0x22u:
          goto LABEL_122;
        case 0x23u:
          goto LABEL_134;
        case 0x24u:
          goto LABEL_97;
        case 0x25u:
          goto LABEL_110;
        case 0x26u:
          goto LABEL_121;
        case 0x27u:
          goto LABEL_133;
        case 0x28u:
          goto LABEL_96;
        case 0x29u:
          goto LABEL_109;
        case 0x2Au:
          goto LABEL_120;
        case 0x2Bu:
          goto LABEL_132;
        case 0x2Cu:
LABEL_95:
          v7[-3].m128i_i32[1] = v8[-3].m128i_i32[1];
LABEL_96:
          v7[-3].m128i_i32[2] = v8[-3].m128i_i32[2];
LABEL_97:
          v7[-3].m128i_i32[3] = v8[-3].m128i_i32[3];
LABEL_98:
          v7[-2].m128i_i32[0] = v8[-2].m128i_i32[0];
LABEL_99:
          v7[-2].m128i_i32[1] = v8[-2].m128i_i32[1];
LABEL_100:
          v7[-2].m128i_i32[2] = v8[-2].m128i_i32[2];
LABEL_101:
          v7[-2].m128i_i32[3] = v8[-2].m128i_i32[3];
LABEL_102:
          v7[-1].m128i_i32[0] = v8[-1].m128i_i32[0];
LABEL_103:
          v7[-1].m128i_i32[1] = v8[-1].m128i_i32[1];
LABEL_104:
          v7[-1].m128i_i32[2] = v8[-1].m128i_i32[2];
LABEL_105:
          v7[-1].m128i_i32[3] = v8[-1].m128i_i32[3];
          return a2;
        case 0x2Du:
LABEL_108:
          *(__int32 *)((char *)v7[-3].m128i_i32 + 3) = *(__int32 *)((char *)v8[-3].m128i_i32 + 3);
LABEL_109:
          *(__int32 *)((char *)&v7[-3].m128i_i32[1] + 3) = *(__int32 *)((char *)&v8[-3].m128i_i32[1] + 3);
LABEL_110:
          *(__int32 *)((char *)&v7[-3].m128i_i32[2] + 3) = *(__int32 *)((char *)&v8[-3].m128i_i32[2] + 3);
LABEL_111:
          *(__int32 *)((char *)&v7[-3].m128i_i32[3] + 3) = *(__int32 *)((char *)&v8[-3].m128i_i32[3] + 3);
LABEL_112:
          *(__int32 *)((char *)v7[-2].m128i_i32 + 3) = *(__int32 *)((char *)v8[-2].m128i_i32 + 3);
LABEL_113:
          *(__int32 *)((char *)&v7[-2].m128i_i32[1] + 3) = *(__int32 *)((char *)&v8[-2].m128i_i32[1] + 3);
LABEL_114:
          *(__int32 *)((char *)&v7[-2].m128i_i32[2] + 3) = *(__int32 *)((char *)&v8[-2].m128i_i32[2] + 3);
LABEL_115:
          *(__int32 *)((char *)&v7[-2].m128i_i32[3] + 3) = *(__int32 *)((char *)&v8[-2].m128i_i32[3] + 3);
LABEL_116:
          *(__int32 *)((char *)v7[-1].m128i_i32 + 3) = *(__int32 *)((char *)v8[-1].m128i_i32 + 3);
LABEL_117:
          *(__int32 *)((char *)&v7[-1].m128i_i32[1] + 3) = *(__int32 *)((char *)&v8[-1].m128i_i32[1] + 3);
          *(__int32 *)((char *)&v7[-1].m128i_i32[2] + 3) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
LABEL_118:
          v7[-1].m128i_i8[15] = v8[-1].m128i_i8[15];
          return a2;
        case 0x2Eu:
LABEL_119:
          *(__int32 *)((char *)v7[-3].m128i_i32 + 2) = *(__int32 *)((char *)v8[-3].m128i_i32 + 2);
LABEL_120:
          *(__int32 *)((char *)&v7[-3].m128i_i32[1] + 2) = *(__int32 *)((char *)&v8[-3].m128i_i32[1] + 2);
LABEL_121:
          *(__int32 *)((char *)&v7[-3].m128i_i32[2] + 2) = *(__int32 *)((char *)&v8[-3].m128i_i32[2] + 2);
LABEL_122:
          *(__int32 *)((char *)&v7[-3].m128i_i32[3] + 2) = *(__int32 *)((char *)&v8[-3].m128i_i32[3] + 2);
LABEL_123:
          *(__int32 *)((char *)v7[-2].m128i_i32 + 2) = *(__int32 *)((char *)v8[-2].m128i_i32 + 2);
LABEL_124:
          *(__int32 *)((char *)&v7[-2].m128i_i32[1] + 2) = *(__int32 *)((char *)&v8[-2].m128i_i32[1] + 2);
LABEL_125:
          *(__int32 *)((char *)&v7[-2].m128i_i32[2] + 2) = *(__int32 *)((char *)&v8[-2].m128i_i32[2] + 2);
LABEL_126:
          *(__int32 *)((char *)&v7[-2].m128i_i32[3] + 2) = *(__int32 *)((char *)&v8[-2].m128i_i32[3] + 2);
LABEL_127:
          *(__int32 *)((char *)v7[-1].m128i_i32 + 2) = *(__int32 *)((char *)v8[-1].m128i_i32 + 2);
LABEL_128:
          *(__int32 *)((char *)&v7[-1].m128i_i32[1] + 2) = *(__int32 *)((char *)&v8[-1].m128i_i32[1] + 2);
LABEL_129:
          *(__int32 *)((char *)&v7[-1].m128i_i32[2] + 2) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 2);
LABEL_130:
          v7[-1].m128i_i16[7] = v8[-1].m128i_i16[7];
          return a2;
        case 0x2Fu:
LABEL_131:
          *(__int32 *)((char *)v7[-3].m128i_i32 + 1) = *(__int32 *)((char *)v8[-3].m128i_i32 + 1);
LABEL_132:
          *(__int32 *)((char *)&v7[-3].m128i_i32[1] + 1) = *(__int32 *)((char *)&v8[-3].m128i_i32[1] + 1);
LABEL_133:
          *(__int32 *)((char *)&v7[-3].m128i_i32[2] + 1) = *(__int32 *)((char *)&v8[-3].m128i_i32[2] + 1);
LABEL_134:
          *(__int32 *)((char *)&v7[-3].m128i_i32[3] + 1) = *(__int32 *)((char *)&v8[-3].m128i_i32[3] + 1);
LABEL_135:
          *(__int32 *)((char *)v7[-2].m128i_i32 + 1) = *(__int32 *)((char *)v8[-2].m128i_i32 + 1);
LABEL_136:
          *(__int32 *)((char *)&v7[-2].m128i_i32[1] + 1) = *(__int32 *)((char *)&v8[-2].m128i_i32[1] + 1);
LABEL_137:
          *(__int32 *)((char *)&v7[-2].m128i_i32[2] + 1) = *(__int32 *)((char *)&v8[-2].m128i_i32[2] + 1);
LABEL_138:
          *(__int32 *)((char *)&v7[-2].m128i_i32[3] + 1) = *(__int32 *)((char *)&v8[-2].m128i_i32[3] + 1);
LABEL_139:
          *(__int32 *)((char *)v7[-1].m128i_i32 + 1) = *(__int32 *)((char *)v8[-1].m128i_i32 + 1);
LABEL_140:
          *(__int32 *)((char *)&v7[-1].m128i_i32[1] + 1) = *(__int32 *)((char *)&v8[-1].m128i_i32[1] + 1);
LABEL_141:
          *(__int32 *)((char *)&v7[-1].m128i_i32[2] + 1) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 1);
LABEL_142:
          v195 = *(__int16 *)((char *)&v8[-1].m128i_i16[6] + 1);
          v196 = v8[-1].m128i_i8[15];
          *(__int16 *)((char *)&v7[-1].m128i_i16[6] + 1) = v195;
          v7[-1].m128i_i8[15] = v196;
          return a2;
        default:
          v9 = _mm_loadu_si128(v8);
          v10 = (__m128i *)(((unsigned int)v7 & 0xFFFFFFF0) + 16);
          v11 = (__m128i *)(a4 + a2);
          v12 = a4 + a2 - (_DWORD)v10;
          v13 = v12 + a4;
          v14 = (const __m128i *)((char *)v8 - v12);
          if ( v12 + a4 >= _x86_shared_cache_size_half )
          {
            v197 = _mm_loadu_si128(v14);
            *v11 = v9;
            _mm_stream_si128(v10, v197);
            ++v14;
            ++v10;
            v13 -= 16;
            if ( (_BYTE)v10 != (_BYTE)v14 )
            {
              v198 = v13 - 128;
              do
              {
                _mm_prefetch(v14[28].m128i_i8, 0);
                _mm_prefetch(v14[40].m128i_i8, 0);
                v199 = _mm_loadu_si128(v14);
                v200 = _mm_loadu_si128(v14 + 1);
                v201 = _mm_loadu_si128(v14 + 2);
                v202 = _mm_loadu_si128(v14 + 3);
                v203 = _mm_loadu_si128(v14 + 4);
                v204 = _mm_loadu_si128(v14 + 5);
                v205 = _mm_loadu_si128(v14 + 6);
                v206 = _mm_loadu_si128(v14 + 7);
                v14 += 8;
                _mm_lfence();
                v17 = v198 < 0x80;
                v198 -= 128;
                _mm_stream_si128(v10, v199);
                _mm_stream_si128(v10 + 1, v200);
                _mm_stream_si128(v10 + 2, v201);
                _mm_stream_si128(v10 + 3, v202);
                _mm_stream_si128(v10 + 4, v203);
                _mm_stream_si128(v10 + 5, v204);
                _mm_stream_si128(v10 + 6, v205);
                _mm_stream_si128(v10 + 7, v206);
                v10 += 8;
              }
              while ( !v17 );
              v207 = v198 + 128;
              if ( v207 >= 0x40 )
              {
                v208 = _mm_loadu_si128(v14);
                v209 = _mm_loadu_si128(v14 + 1);
                v210 = _mm_loadu_si128(v14 + 2);
                v211 = _mm_loadu_si128(v14 + 3);
                v14 += 4;
                _mm_stream_si128(v10, v208);
                _mm_stream_si128(v10 + 1, v209);
                _mm_stream_si128(v10 + 2, v210);
                _mm_stream_si128(v10 + 3, v211);
                v10 += 4;
                v207 -= 64;
              }
              while ( 2 )
              {
                v7 = (__m128i *)((char *)v10 + v207);
                v8 = (const __m128i *)((char *)v14 + v207);
                _mm_sfence();
                switch ( v207 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_118;
                  case 2u:
                    goto LABEL_130;
                  case 3u:
                    goto LABEL_142;
                  case 4u:
                    goto LABEL_105;
                  case 5u:
                    goto LABEL_107;
                  case 6u:
                    goto LABEL_129;
                  case 7u:
                    goto LABEL_141;
                  case 8u:
                    goto LABEL_104;
                  case 9u:
                    goto LABEL_117;
                  case 0xAu:
                    goto LABEL_128;
                  case 0xBu:
                    goto LABEL_140;
                  case 0xCu:
                    goto LABEL_103;
                  case 0xDu:
                    goto LABEL_116;
                  case 0xEu:
                    goto LABEL_127;
                  case 0xFu:
                    goto LABEL_139;
                  case 0x10u:
                    goto LABEL_102;
                  case 0x11u:
                    goto LABEL_115;
                  case 0x12u:
                    goto LABEL_126;
                  case 0x13u:
                    goto LABEL_138;
                  case 0x14u:
                    goto LABEL_101;
                  case 0x15u:
                    goto LABEL_114;
                  case 0x16u:
                    goto LABEL_125;
                  case 0x17u:
                    goto LABEL_137;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_113;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_136;
                  case 0x1Cu:
                    goto LABEL_99;
                  case 0x1Du:
                    goto LABEL_112;
                  case 0x1Eu:
                    goto LABEL_123;
                  case 0x1Fu:
                    goto LABEL_135;
                  default:
                    v212 = _mm_loadu_si128(v8);
                    v213 = _mm_loadu_si128(v8 + 1);
                    v14 = v8 + 2;
                    _mm_stream_si128(v7, v212);
                    _mm_stream_si128(v7 + 1, v213);
                    v10 = v7 + 2;
                    v207 -= 32;
                    continue;
                }
              }
            }
          }
          else
          {
            if ( ((unsigned __int8)v14 & 0xF) != 0 )
            {
              switch ( (unsigned __int8)v14 & 0xF )
              {
                case 0:
                  break;
                case 1:
                  v57 = (__m128i *)&v14[-1].m128i_i8[15];
                  v58 = *v57;
                  v59 = 0;
                  v60 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    si128 = _mm_load_si128(&v57[v59 + 1]);
                    v17 = v60 < 0x20;
                    v60 -= 32;
                    v62 = _mm_load_si128(&v57[v59 + 2]);
                    v59 += 2;
                    v10[v59 - 2] = _mm_alignr_epi8(si128, v58, 1);
                    v10[v59 - 1] = _mm_alignr_epi8(v62, si128, 1);
                    if ( v17 )
                      break;
                    v63 = _mm_load_si128(&v57[v59 + 1]);
                    v17 = v60 < 0x20;
                    v60 -= 32;
                    v58 = _mm_load_si128(&v57[v59 + 2]);
                    v59 += 2;
                    v10[v59 - 2] = _mm_alignr_epi8(v63, v62, 1);
                    v10[v59 - 1] = _mm_alignr_epi8(v58, v63, 1);
                  }
                  while ( !v17 );
                  v64 = v60 + 32;
                  v65 = v64 + v59 * 16;
                  v7 = (__m128i *)((char *)v10 + v65);
                  v8 = (const __m128i *)&v57->m128i_i8[v65 + 1];
                  switch ( v64 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 2:
                  v66 = (__m128i *)&v14[-1].m128i_i8[14];
                  v67 = *v66;
                  v68 = 0;
                  v69 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v70 = _mm_load_si128(&v66[v68 + 1]);
                    v17 = v69 < 0x20;
                    v69 -= 32;
                    v71 = _mm_load_si128(&v66[v68 + 2]);
                    v68 += 2;
                    v10[v68 - 2] = _mm_alignr_epi8(v70, v67, 2);
                    v10[v68 - 1] = _mm_alignr_epi8(v71, v70, 2);
                    if ( v17 )
                      break;
                    v72 = _mm_load_si128(&v66[v68 + 1]);
                    v17 = v69 < 0x20;
                    v69 -= 32;
                    v67 = _mm_load_si128(&v66[v68 + 2]);
                    v68 += 2;
                    v10[v68 - 2] = _mm_alignr_epi8(v72, v71, 2);
                    v10[v68 - 1] = _mm_alignr_epi8(v67, v72, 2);
                  }
                  while ( !v17 );
                  v73 = v69 + 32;
                  v74 = v73 + v68 * 16;
                  v7 = (__m128i *)((char *)v10 + v74);
                  v8 = (const __m128i *)&v66->m128i_i8[v74 + 2];
                  switch ( v73 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 3:
                  v75 = (__m128i *)&v14[-1].m128i_i8[13];
                  v76 = *v75;
                  v77 = 0;
                  v78 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v79 = _mm_load_si128(&v75[v77 + 1]);
                    v17 = v78 < 0x20;
                    v78 -= 32;
                    v80 = _mm_load_si128(&v75[v77 + 2]);
                    v77 += 2;
                    v10[v77 - 2] = _mm_alignr_epi8(v79, v76, 3);
                    v10[v77 - 1] = _mm_alignr_epi8(v80, v79, 3);
                    if ( v17 )
                      break;
                    v81 = _mm_load_si128(&v75[v77 + 1]);
                    v17 = v78 < 0x20;
                    v78 -= 32;
                    v76 = _mm_load_si128(&v75[v77 + 2]);
                    v77 += 2;
                    v10[v77 - 2] = _mm_alignr_epi8(v81, v80, 3);
                    v10[v77 - 1] = _mm_alignr_epi8(v76, v81, 3);
                  }
                  while ( !v17 );
                  v82 = v78 + 32;
                  v83 = v82 + v77 * 16;
                  v7 = (__m128i *)((char *)v10 + v83);
                  v8 = (const __m128i *)&v75->m128i_i8[v83 + 3];
                  switch ( v82 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 4:
                  v84 = (__m128i *)&v14[-1].m128i_i8[12];
                  v85 = *v84;
                  v86 = 0;
                  v87 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v88 = _mm_load_si128(&v84[v86 + 1]);
                    v17 = v87 < 0x20;
                    v87 -= 32;
                    v89 = _mm_load_si128(&v84[v86 + 2]);
                    v86 += 2;
                    v10[v86 - 2] = _mm_alignr_epi8(v88, v85, 4);
                    v10[v86 - 1] = _mm_alignr_epi8(v89, v88, 4);
                    if ( v17 )
                      break;
                    v90 = _mm_load_si128(&v84[v86 + 1]);
                    v17 = v87 < 0x20;
                    v87 -= 32;
                    v85 = _mm_load_si128(&v84[v86 + 2]);
                    v86 += 2;
                    v10[v86 - 2] = _mm_alignr_epi8(v90, v89, 4);
                    v10[v86 - 1] = _mm_alignr_epi8(v85, v90, 4);
                  }
                  while ( !v17 );
                  v91 = v87 + 32;
                  v92 = v91 + v86 * 16;
                  v7 = (__m128i *)((char *)v10 + v92);
                  v8 = (const __m128i *)&v84->m128i_i8[v92 + 4];
                  switch ( v91 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 5:
                  v93 = (__m128i *)&v14[-1].m128i_i8[11];
                  v94 = *v93;
                  v95 = 0;
                  v96 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v97 = _mm_load_si128(&v93[v95 + 1]);
                    v17 = v96 < 0x20;
                    v96 -= 32;
                    v98 = _mm_load_si128(&v93[v95 + 2]);
                    v95 += 2;
                    v10[v95 - 2] = _mm_alignr_epi8(v97, v94, 5);
                    v10[v95 - 1] = _mm_alignr_epi8(v98, v97, 5);
                    if ( v17 )
                      break;
                    v99 = _mm_load_si128(&v93[v95 + 1]);
                    v17 = v96 < 0x20;
                    v96 -= 32;
                    v94 = _mm_load_si128(&v93[v95 + 2]);
                    v95 += 2;
                    v10[v95 - 2] = _mm_alignr_epi8(v99, v98, 5);
                    v10[v95 - 1] = _mm_alignr_epi8(v94, v99, 5);
                  }
                  while ( !v17 );
                  v100 = v96 + 32;
                  v101 = v100 + v95 * 16;
                  v7 = (__m128i *)((char *)v10 + v101);
                  v8 = (const __m128i *)&v93->m128i_i8[v101 + 5];
                  switch ( v100 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 6:
                  v102 = (__m128i *)&v14[-1].m128i_i8[10];
                  v103 = *v102;
                  v104 = 0;
                  v105 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v106 = _mm_load_si128(&v102[v104 + 1]);
                    v17 = v105 < 0x20;
                    v105 -= 32;
                    v107 = _mm_load_si128(&v102[v104 + 2]);
                    v104 += 2;
                    v10[v104 - 2] = _mm_alignr_epi8(v106, v103, 6);
                    v10[v104 - 1] = _mm_alignr_epi8(v107, v106, 6);
                    if ( v17 )
                      break;
                    v108 = _mm_load_si128(&v102[v104 + 1]);
                    v17 = v105 < 0x20;
                    v105 -= 32;
                    v103 = _mm_load_si128(&v102[v104 + 2]);
                    v104 += 2;
                    v10[v104 - 2] = _mm_alignr_epi8(v108, v107, 6);
                    v10[v104 - 1] = _mm_alignr_epi8(v103, v108, 6);
                  }
                  while ( !v17 );
                  v109 = v105 + 32;
                  v110 = v109 + v104 * 16;
                  v7 = (__m128i *)((char *)v10 + v110);
                  v8 = (const __m128i *)&v102->m128i_i8[v110 + 6];
                  switch ( v109 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 7:
                  v111 = (__m128i *)&v14[-1].m128i_i8[9];
                  v112 = *v111;
                  v113 = 0;
                  v114 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v115 = _mm_load_si128(&v111[v113 + 1]);
                    v17 = v114 < 0x20;
                    v114 -= 32;
                    v116 = _mm_load_si128(&v111[v113 + 2]);
                    v113 += 2;
                    v10[v113 - 2] = _mm_alignr_epi8(v115, v112, 7);
                    v10[v113 - 1] = _mm_alignr_epi8(v116, v115, 7);
                    if ( v17 )
                      break;
                    v117 = _mm_load_si128(&v111[v113 + 1]);
                    v17 = v114 < 0x20;
                    v114 -= 32;
                    v112 = _mm_load_si128(&v111[v113 + 2]);
                    v113 += 2;
                    v10[v113 - 2] = _mm_alignr_epi8(v117, v116, 7);
                    v10[v113 - 1] = _mm_alignr_epi8(v112, v117, 7);
                  }
                  while ( !v17 );
                  v118 = v114 + 32;
                  v119 = v118 + v113 * 16;
                  v7 = (__m128i *)((char *)v10 + v119);
                  v8 = (const __m128i *)&v111->m128i_i8[v119 + 7];
                  switch ( v118 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 8:
                  v120 = (__m128i *)&v14[-1].m128i_i8[8];
                  v121 = *v120;
                  v122 = 0;
                  v123 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v124 = _mm_load_si128(&v120[v122 + 1]);
                    v17 = v123 < 0x20;
                    v123 -= 32;
                    v125 = _mm_load_si128(&v120[v122 + 2]);
                    v122 += 2;
                    v10[v122 - 2] = _mm_alignr_epi8(v124, v121, 8);
                    v10[v122 - 1] = _mm_alignr_epi8(v125, v124, 8);
                    if ( v17 )
                      break;
                    v126 = _mm_load_si128(&v120[v122 + 1]);
                    v17 = v123 < 0x20;
                    v123 -= 32;
                    v121 = _mm_load_si128(&v120[v122 + 2]);
                    v122 += 2;
                    v10[v122 - 2] = _mm_alignr_epi8(v126, v125, 8);
                    v10[v122 - 1] = _mm_alignr_epi8(v121, v126, 8);
                  }
                  while ( !v17 );
                  v127 = v123 + 32;
                  v128 = v127 + v122 * 16;
                  v7 = (__m128i *)((char *)v10 + v128);
                  v8 = (const __m128i *)&v120->m128i_i8[v128 + 8];
                  switch ( v127 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 9:
                  v129 = (__m128i *)&v14[-1].m128i_i8[7];
                  v130 = *v129;
                  v131 = 0;
                  v132 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v133 = _mm_load_si128(&v129[v131 + 1]);
                    v17 = v132 < 0x20;
                    v132 -= 32;
                    v134 = _mm_load_si128(&v129[v131 + 2]);
                    v131 += 2;
                    v10[v131 - 2] = _mm_alignr_epi8(v133, v130, 9);
                    v10[v131 - 1] = _mm_alignr_epi8(v134, v133, 9);
                    if ( v17 )
                      break;
                    v135 = _mm_load_si128(&v129[v131 + 1]);
                    v17 = v132 < 0x20;
                    v132 -= 32;
                    v130 = _mm_load_si128(&v129[v131 + 2]);
                    v131 += 2;
                    v10[v131 - 2] = _mm_alignr_epi8(v135, v134, 9);
                    v10[v131 - 1] = _mm_alignr_epi8(v130, v135, 9);
                  }
                  while ( !v17 );
                  v136 = v132 + 32;
                  v137 = v136 + v131 * 16;
                  v7 = (__m128i *)((char *)v10 + v137);
                  v8 = (const __m128i *)&v129->m128i_i8[v137 + 9];
                  switch ( v136 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 0xA:
                  v138 = (__m128i *)&v14[-1].m128i_i8[6];
                  v139 = *v138;
                  v140 = 0;
                  v141 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v142 = _mm_load_si128(&v138[v140 + 1]);
                    v17 = v141 < 0x20;
                    v141 -= 32;
                    v143 = _mm_load_si128(&v138[v140 + 2]);
                    v140 += 2;
                    v10[v140 - 2] = _mm_alignr_epi8(v142, v139, 10);
                    v10[v140 - 1] = _mm_alignr_epi8(v143, v142, 10);
                    if ( v17 )
                      break;
                    v144 = _mm_load_si128(&v138[v140 + 1]);
                    v17 = v141 < 0x20;
                    v141 -= 32;
                    v139 = _mm_load_si128(&v138[v140 + 2]);
                    v140 += 2;
                    v10[v140 - 2] = _mm_alignr_epi8(v144, v143, 10);
                    v10[v140 - 1] = _mm_alignr_epi8(v139, v144, 10);
                  }
                  while ( !v17 );
                  v145 = v141 + 32;
                  v146 = v145 + v140 * 16;
                  v7 = (__m128i *)((char *)v10 + v146);
                  v8 = (const __m128i *)&v138->m128i_i8[v146 + 10];
                  switch ( v145 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 0xB:
                  v147 = (__m128i *)&v14[-1].m128i_i8[5];
                  v148 = *v147;
                  v149 = 0;
                  v150 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v151 = _mm_load_si128(&v147[v149 + 1]);
                    v17 = v150 < 0x20;
                    v150 -= 32;
                    v152 = _mm_load_si128(&v147[v149 + 2]);
                    v149 += 2;
                    v10[v149 - 2] = _mm_alignr_epi8(v151, v148, 11);
                    v10[v149 - 1] = _mm_alignr_epi8(v152, v151, 11);
                    if ( v17 )
                      break;
                    v153 = _mm_load_si128(&v147[v149 + 1]);
                    v17 = v150 < 0x20;
                    v150 -= 32;
                    v148 = _mm_load_si128(&v147[v149 + 2]);
                    v149 += 2;
                    v10[v149 - 2] = _mm_alignr_epi8(v153, v152, 11);
                    v10[v149 - 1] = _mm_alignr_epi8(v148, v153, 11);
                  }
                  while ( !v17 );
                  v154 = v150 + 32;
                  v155 = v154 + v149 * 16;
                  v7 = (__m128i *)((char *)v10 + v155);
                  v8 = (const __m128i *)&v147->m128i_i8[v155 + 11];
                  switch ( v154 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 0xC:
                  v156 = (__m128i *)&v14[-1].m128i_i8[4];
                  v157 = *v156;
                  v158 = 0;
                  v159 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v160 = _mm_load_si128(&v156[v158 + 1]);
                    v17 = v159 < 0x20;
                    v159 -= 32;
                    v161 = _mm_load_si128(&v156[v158 + 2]);
                    v158 += 2;
                    v10[v158 - 2] = _mm_alignr_epi8(v160, v157, 12);
                    v10[v158 - 1] = _mm_alignr_epi8(v161, v160, 12);
                    if ( v17 )
                      break;
                    v162 = _mm_load_si128(&v156[v158 + 1]);
                    v17 = v159 < 0x20;
                    v159 -= 32;
                    v157 = _mm_load_si128(&v156[v158 + 2]);
                    v158 += 2;
                    v10[v158 - 2] = _mm_alignr_epi8(v162, v161, 12);
                    v10[v158 - 1] = _mm_alignr_epi8(v157, v162, 12);
                  }
                  while ( !v17 );
                  v163 = v159 + 32;
                  v164 = v163 + v158 * 16;
                  v7 = (__m128i *)((char *)v10 + v164);
                  v8 = (const __m128i *)&v156->m128i_i8[v164 + 12];
                  switch ( v163 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 0xD:
                  v165 = (__m128i *)&v14[-1].m128i_i8[3];
                  v166 = *v165;
                  v167 = 0;
                  v168 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v169 = _mm_load_si128(&v165[v167 + 1]);
                    v17 = v168 < 0x20;
                    v168 -= 32;
                    v170 = _mm_load_si128(&v165[v167 + 2]);
                    v167 += 2;
                    v10[v167 - 2] = _mm_alignr_epi8(v169, v166, 13);
                    v10[v167 - 1] = _mm_alignr_epi8(v170, v169, 13);
                    if ( v17 )
                      break;
                    v171 = _mm_load_si128(&v165[v167 + 1]);
                    v17 = v168 < 0x20;
                    v168 -= 32;
                    v166 = _mm_load_si128(&v165[v167 + 2]);
                    v167 += 2;
                    v10[v167 - 2] = _mm_alignr_epi8(v171, v170, 13);
                    v10[v167 - 1] = _mm_alignr_epi8(v166, v171, 13);
                  }
                  while ( !v17 );
                  v172 = v168 + 32;
                  v173 = v172 + v167 * 16;
                  v7 = (__m128i *)((char *)v10 + v173);
                  v8 = (const __m128i *)&v165->m128i_i8[v173 + 13];
                  switch ( v172 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 0xE:
                  v174 = (__m128i *)&v14[-1].m128i_i8[2];
                  v175 = *v174;
                  v176 = 0;
                  v177 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v178 = _mm_load_si128(&v174[v176 + 1]);
                    v17 = v177 < 0x20;
                    v177 -= 32;
                    v179 = _mm_load_si128(&v174[v176 + 2]);
                    v176 += 2;
                    v10[v176 - 2] = _mm_alignr_epi8(v178, v175, 14);
                    v10[v176 - 1] = _mm_alignr_epi8(v179, v178, 14);
                    if ( v17 )
                      break;
                    v180 = _mm_load_si128(&v174[v176 + 1]);
                    v17 = v177 < 0x20;
                    v177 -= 32;
                    v175 = _mm_load_si128(&v174[v176 + 2]);
                    v176 += 2;
                    v10[v176 - 2] = _mm_alignr_epi8(v180, v179, 14);
                    v10[v176 - 1] = _mm_alignr_epi8(v175, v180, 14);
                  }
                  while ( !v17 );
                  v181 = v177 + 32;
                  v182 = v181 + v176 * 16;
                  v7 = (__m128i *)((char *)v10 + v182);
                  v8 = (const __m128i *)&v174->m128i_i8[v182 + 14];
                  switch ( v181 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 0xF:
                  v183 = (__m128i *)&v14[-1].m128i_i8[1];
                  v184 = *v183;
                  v185 = 0;
                  v186 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v187 = _mm_load_si128(&v183[v185 + 1]);
                    v17 = v186 < 0x20;
                    v186 -= 32;
                    v188 = _mm_load_si128(&v183[v185 + 2]);
                    v185 += 2;
                    v10[v185 - 2] = _mm_alignr_epi8(v187, v184, 15);
                    v10[v185 - 1] = _mm_alignr_epi8(v188, v187, 15);
                    if ( v17 )
                      break;
                    v189 = _mm_load_si128(&v183[v185 + 1]);
                    v17 = v186 < 0x20;
                    v186 -= 32;
                    v184 = _mm_load_si128(&v183[v185 + 2]);
                    v185 += 2;
                    v10[v185 - 2] = _mm_alignr_epi8(v189, v188, 15);
                    v10[v185 - 1] = _mm_alignr_epi8(v184, v189, 15);
                  }
                  while ( !v17 );
                  v190 = v186 + 32;
                  v191 = v190 + v185 * 16;
                  v7 = (__m128i *)((char *)v10 + v191);
                  v8 = (const __m128i *)&v183->m128i_i8[v191 + 15];
                  switch ( v190 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
              }
            }
            *v11 = v9;
            if ( v13 <= 0x7F )
            {
              v15 = v13 - 32;
              v16 = _mm_load_si128(v14 + 1);
              v17 = v15 < 0x20;
              v18 = v15 - 32;
              *v10 = _mm_load_si128(v14);
              v10[1] = v16;
              v19 = 32;
              if ( !v17 )
              {
                v20 = _mm_load_si128(v14 + 3);
                v17 = v18 < 0x20;
                v18 -= 32;
                v10[2] = _mm_load_si128(v14 + 2);
                v10[3] = v20;
                v19 = 64;
                if ( !v17 )
                {
                  v21 = _mm_load_si128(v14 + 5);
                  v17 = v18 < 0x20;
                  v18 -= 32;
                  v10[4] = _mm_load_si128(v14 + 4);
                  v10[5] = v21;
                  v19 = 96;
                  if ( !v17 )
                  {
                    v22 = _mm_load_si128(v14 + 7);
                    v18 -= 32;
                    v10[6] = _mm_load_si128(v14 + 6);
                    v10[7] = v22;
                    v19 = 128;
                  }
                }
              }
              v23 = v18 + 32;
              v24 = v23 + v19;
              v7 = (__m128i *)((char *)v10 + v24);
              v8 = (const __m128i *)((char *)v14 + v24);
              switch ( v23 )
              {
                case 0u:
                  return a2;
                case 1u:
                  goto LABEL_118;
                case 2u:
                  goto LABEL_130;
                case 3u:
                  goto LABEL_142;
                case 4u:
                  goto LABEL_105;
                case 5u:
                  goto LABEL_107;
                case 6u:
                  goto LABEL_129;
                case 7u:
                  goto LABEL_141;
                case 8u:
                  goto LABEL_104;
                case 9u:
                  goto LABEL_117;
                case 0xAu:
                  goto LABEL_128;
                case 0xBu:
                  goto LABEL_140;
                case 0xCu:
                  goto LABEL_103;
                case 0xDu:
                  goto LABEL_116;
                case 0xEu:
                  goto LABEL_127;
                case 0xFu:
                  goto LABEL_139;
                case 0x10u:
                  goto LABEL_102;
                case 0x11u:
                  goto LABEL_115;
                case 0x12u:
                  goto LABEL_126;
                case 0x13u:
                  goto LABEL_138;
                case 0x14u:
                  goto LABEL_101;
                case 0x15u:
                  goto LABEL_114;
                case 0x16u:
                  goto LABEL_125;
                case 0x17u:
                  goto LABEL_137;
                case 0x18u:
                  goto LABEL_100;
                case 0x19u:
                  goto LABEL_113;
                case 0x1Au:
                  goto LABEL_124;
                case 0x1Bu:
                  goto LABEL_136;
                case 0x1Cu:
                  goto LABEL_99;
                case 0x1Du:
                  goto LABEL_112;
                case 0x1Eu:
                  goto LABEL_123;
                case 0x1Fu:
                  goto LABEL_135;
                case 0x20u:
                  goto LABEL_98;
                case 0x21u:
                  goto LABEL_111;
                case 0x22u:
                  goto LABEL_122;
                case 0x23u:
                  goto LABEL_134;
                case 0x24u:
                  goto LABEL_97;
                case 0x25u:
                  goto LABEL_110;
                case 0x26u:
                  goto LABEL_121;
                case 0x27u:
                  goto LABEL_133;
                case 0x28u:
                  goto LABEL_96;
                case 0x29u:
                  goto LABEL_109;
                case 0x2Au:
                  goto LABEL_120;
                case 0x2Bu:
                  goto LABEL_132;
                case 0x2Cu:
                  goto LABEL_95;
                case 0x2Du:
                  goto LABEL_108;
                case 0x2Eu:
                  goto LABEL_119;
                case 0x2Fu:
                  goto LABEL_131;
              }
            }
            if ( v13 < _x86_data_cache_size_half - ((unsigned int)_x86_data_cache_size_half >> 3) )
            {
              v25 = v13 - 128;
              do
              {
                v26 = _mm_load_si128(v14);
                v27 = v14[1];
                v28 = v14[2];
                v29 = v14[3];
                v30 = v14[4];
                v31 = v14[5];
                v32 = v14[6];
                v33 = v14[7];
                v14 += 8;
                v17 = v25 < 0x80;
                v25 -= 128;
                *v10 = v26;
                v10[1] = v27;
                v10[2] = v28;
                v10[3] = v29;
                v10[4] = v30;
                v10[5] = v31;
                v10[6] = v32;
                v10[7] = v33;
                v10 += 8;
              }
              while ( !v17 );
              v34 = v25 + 128;
              if ( v34 >= 0x40 )
              {
                v34 -= 64;
                v35 = _mm_load_si128(v14 + 1);
                *v10 = _mm_load_si128(v14);
                v10[1] = v35;
                v36 = _mm_load_si128(v14 + 2);
                v37 = _mm_load_si128(v14 + 3);
                v14 += 4;
                v10[2] = v36;
                v10[3] = v37;
                v10 += 4;
              }
              if ( v34 >= 0x20 )
              {
                v38 = _mm_load_si128(v14);
                v34 -= 32;
                v39 = _mm_load_si128(v14 + 1);
                v14 += 2;
                *v10 = v38;
                v10[1] = v39;
                v10 += 2;
              }
              while ( 2 )
              {
                v7 = (__m128i *)((char *)v10 + v34);
                v8 = (const __m128i *)((char *)v14 + v34);
                switch ( v34 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_118;
                  case 2u:
                    goto LABEL_130;
                  case 3u:
                    goto LABEL_142;
                  case 4u:
                    goto LABEL_105;
                  case 5u:
                    goto LABEL_107;
                  case 6u:
                    goto LABEL_129;
                  case 7u:
                    goto LABEL_141;
                  case 8u:
                    goto LABEL_104;
                  case 9u:
                    goto LABEL_117;
                  case 0xAu:
                    goto LABEL_128;
                  case 0xBu:
                    goto LABEL_140;
                  case 0xCu:
                    goto LABEL_103;
                  case 0xDu:
                    goto LABEL_116;
                  case 0xEu:
                    goto LABEL_127;
                  case 0xFu:
                    goto LABEL_139;
                  default:
                    v34 -= 16;
                    v40 = _mm_load_si128(v8);
                    v14 = v8 + 1;
                    *v7 = v40;
                    v10 = v7 + 1;
                    continue;
                }
              }
            }
            if ( (_BYTE)v10 != (_BYTE)v14 )
            {
              v41 = v13 - 128;
              do
              {
                _mm_prefetch(v14[28].m128i_i8, 0);
                _mm_prefetch(v14[40].m128i_i8, 0);
                _mm_prefetch(v10[28].m128i_i8, 0);
                _mm_prefetch(v10[40].m128i_i8, 0);
                v42 = _mm_load_si128(v14);
                v43 = v14[1];
                v44 = v14[2];
                v45 = v14[3];
                v46 = v14[4];
                v47 = v14[5];
                v48 = v14[6];
                v49 = v14[7];
                v14 += 8;
                v17 = v41 < 0x80;
                v41 -= 128;
                *v10 = v42;
                v10[1] = v43;
                v10[2] = v44;
                v10[3] = v45;
                v10[4] = v46;
                v10[5] = v47;
                v10[6] = v48;
                v10[7] = v49;
                v10 += 8;
              }
              while ( !v17 );
              v50 = v41 + 128;
              if ( v50 >= 0x40 )
              {
                v50 -= 64;
                v51 = _mm_load_si128(v14 + 1);
                *v10 = _mm_load_si128(v14);
                v10[1] = v51;
                v52 = _mm_load_si128(v14 + 2);
                v53 = _mm_load_si128(v14 + 3);
                v14 += 4;
                v10[2] = v52;
                v10[3] = v53;
                v10 += 4;
              }
              if ( v50 >= 0x20 )
              {
                v54 = _mm_load_si128(v14);
                v50 -= 32;
                v55 = _mm_load_si128(v14 + 1);
                v14 += 2;
                *v10 = v54;
                v10[1] = v55;
                v10 += 2;
              }
              while ( 2 )
              {
                v7 = (__m128i *)((char *)v10 + v50);
                v8 = (const __m128i *)((char *)v14 + v50);
                switch ( v50 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_118;
                  case 2u:
                    goto LABEL_130;
                  case 3u:
                    goto LABEL_142;
                  case 4u:
                    goto LABEL_105;
                  case 5u:
                    goto LABEL_107;
                  case 6u:
                    goto LABEL_129;
                  case 7u:
                    goto LABEL_141;
                  case 8u:
                    goto LABEL_104;
                  case 9u:
                    goto LABEL_117;
                  case 0xAu:
                    goto LABEL_128;
                  case 0xBu:
                    goto LABEL_140;
                  case 0xCu:
                    goto LABEL_103;
                  case 0xDu:
                    goto LABEL_116;
                  case 0xEu:
                    goto LABEL_127;
                  case 0xFu:
                    goto LABEL_139;
                  default:
                    v50 -= 16;
                    v56 = _mm_load_si128(v8);
                    v14 = v8 + 1;
                    *v7 = v56;
                    v10 = v7 + 1;
                    continue;
                }
              }
            }
          }
          v214 = v10;
          v215 = v13;
          v216 = v13 >> 2;
          v217 = v215 & 3;
          qmemcpy(v214, v14, 4 * v216);
          v219 = &v14->m128i_i8[4 * v216];
          v218 = &v214->m128i_i8[4 * v216];
          if ( v217 )
          {
            if ( v217 < 2 || (*(_WORD *)v218 = *(_WORD *)v219, v219 += 2, v218 += 2, v217 != 2) )
              *v218 = *v219;
          }
          return a2;
      }
    }
    v220 = a1;
    v6 = a4 + a2;
    a1 = (const __m128i *)((char *)a3 + a4);
    if ( ((a4 + a2) & 3) != 0 )
    {
      if ( (v6 & 1) == 0
        || (a1 = (const __m128i *)((char *)a1 - 1), v4 = a4 - 1, --v6, *(_BYTE *)v6 = a1->m128i_i8[0], (v6 & 2) != 0) )
      {
        a1 = (const __m128i *)((char *)a1 - 2);
        v4 -= 2;
        v6 -= 2;
        *(_WORD *)v6 = a1->m128i_i16[0];
      }
    }
    if ( v4 >= 0x40 )
    {
      if ( (v6 & 0xF) != 0 )
      {
        a1 = (const __m128i *)((char *)a1 - 4);
        v4 -= 4;
        v6 -= 4;
        *(_DWORD *)v6 = a1->m128i_i32[0];
        if ( (v6 & 0xF) != 0 )
        {
          a1 = (const __m128i *)((char *)a1 - 4);
          v4 -= 4;
          v6 -= 4;
          *(_DWORD *)v6 = a1->m128i_i32[0];
          if ( (v6 & 0xF) != 0 )
          {
            a1 = (const __m128i *)((char *)a1 - 4);
            v4 -= 4;
            v6 -= 4;
            *(_DWORD *)v6 = a1->m128i_i32[0];
          }
        }
      }
      if ( v4 < 0x40 )
      {
LABEL_191:
        v4 -= 32;
        *(_DWORD *)(v6 - 4) = a1[-1].m128i_i32[3];
        *(_DWORD *)(v6 - 8) = a1[-1].m128i_i32[2];
        *(_DWORD *)(v6 - 12) = a1[-1].m128i_i32[1];
        *(_DWORD *)(v6 - 16) = a1[-1].m128i_i32[0];
        *(_DWORD *)(v6 - 20) = a1[-2].m128i_i32[3];
        *(_DWORD *)(v6 - 24) = a1[-2].m128i_i32[2];
        *(_DWORD *)(v6 - 28) = a1[-2].m128i_i32[1];
        *(_DWORD *)(v6 - 32) = a1[-2].m128i_i32[0];
        v6 -= 32;
        a1 -= 2;
      }
      else
      {
        do
        {
          a1 -= 4;
          v4 -= 64;
          v6 -= 64;
          *(__m128i *)(v6 + 48) = _mm_loadu_si128(a1 + 3);
          *(__m128i *)(v6 + 32) = _mm_loadu_si128(a1 + 2);
          *(__m128i *)(v6 + 16) = _mm_loadu_si128(a1 + 1);
          *(__m128i *)v6 = _mm_loadu_si128(a1);
        }
        while ( v4 >= 0x40 );
      }
    }
    v6 -= v4;
    v5 = (__int32 *)((char *)a1->m128i_i32 - v4);
    a1 = v220;
  }
  switch ( v4 )
  {
    case 0u:
      goto LABEL_163;
    case 1u:
      goto LABEL_171;
    case 2u:
      goto LABEL_179;
    case 3u:
      goto LABEL_187;
    case 4u:
      goto LABEL_162;
    case 5u:
      goto LABEL_170;
    case 6u:
      goto LABEL_178;
    case 7u:
      goto LABEL_186;
    case 8u:
      goto LABEL_161;
    case 9u:
      goto LABEL_169;
    case 0xAu:
      goto LABEL_177;
    case 0xBu:
      goto LABEL_185;
    case 0xCu:
      goto LABEL_160;
    case 0xDu:
      goto LABEL_168;
    case 0xEu:
      goto LABEL_176;
    case 0xFu:
      goto LABEL_184;
    case 0x10u:
      goto LABEL_159;
    case 0x11u:
      goto LABEL_167;
    case 0x12u:
      goto LABEL_175;
    case 0x13u:
      goto LABEL_183;
    case 0x14u:
      goto LABEL_158;
    case 0x15u:
      goto LABEL_166;
    case 0x16u:
      goto LABEL_174;
    case 0x17u:
      goto LABEL_182;
    case 0x18u:
      goto LABEL_157;
    case 0x19u:
      goto LABEL_165;
    case 0x1Au:
      goto LABEL_173;
    case 0x1Bu:
      goto LABEL_181;
    case 0x1Cu:
      *(_DWORD *)(v6 + 24) = v5[6];
LABEL_157:
      *(_DWORD *)(v6 + 20) = v5[5];
LABEL_158:
      *(_DWORD *)(v6 + 16) = v5[4];
LABEL_159:
      *(_DWORD *)(v6 + 12) = v5[3];
LABEL_160:
      *(_DWORD *)(v6 + 8) = v5[2];
LABEL_161:
      *(_DWORD *)(v6 + 4) = v5[1];
LABEL_162:
      *(_DWORD *)v6 = *v5;
LABEL_163:
      result = a2;
      break;
    case 0x1Du:
      *(_DWORD *)(v6 + 25) = *(_DWORD *)((char *)v5 + 25);
LABEL_165:
      *(_DWORD *)(v6 + 21) = *(_DWORD *)((char *)v5 + 21);
LABEL_166:
      *(_DWORD *)(v6 + 17) = *(_DWORD *)((char *)v5 + 17);
LABEL_167:
      *(_DWORD *)(v6 + 13) = *(_DWORD *)((char *)v5 + 13);
LABEL_168:
      *(_DWORD *)(v6 + 9) = *(_DWORD *)((char *)v5 + 9);
LABEL_169:
      *(_DWORD *)(v6 + 5) = *(_DWORD *)((char *)v5 + 5);
LABEL_170:
      *(_DWORD *)(v6 + 1) = *(_DWORD *)((char *)v5 + 1);
LABEL_171:
      *(_BYTE *)v6 = *(_BYTE *)v5;
      result = a2;
      break;
    case 0x1Eu:
      *(_DWORD *)(v6 + 26) = *(_DWORD *)((char *)v5 + 26);
LABEL_173:
      *(_DWORD *)(v6 + 22) = *(_DWORD *)((char *)v5 + 22);
LABEL_174:
      *(_DWORD *)(v6 + 18) = *(_DWORD *)((char *)v5 + 18);
LABEL_175:
      *(_DWORD *)(v6 + 14) = *(_DWORD *)((char *)v5 + 14);
LABEL_176:
      *(_DWORD *)(v6 + 10) = *(_DWORD *)((char *)v5 + 10);
LABEL_177:
      *(_DWORD *)(v6 + 6) = *(_DWORD *)((char *)v5 + 6);
LABEL_178:
      *(_DWORD *)(v6 + 2) = *(_DWORD *)((char *)v5 + 2);
LABEL_179:
      *(_WORD *)v6 = *(_WORD *)v5;
      result = a2;
      break;
    case 0x1Fu:
      *(_DWORD *)(v6 + 27) = *(_DWORD *)((char *)v5 + 27);
LABEL_181:
      *(_DWORD *)(v6 + 23) = *(_DWORD *)((char *)v5 + 23);
LABEL_182:
      *(_DWORD *)(v6 + 19) = *(_DWORD *)((char *)v5 + 19);
LABEL_183:
      *(_DWORD *)(v6 + 15) = *(_DWORD *)((char *)v5 + 15);
LABEL_184:
      *(_DWORD *)(v6 + 11) = *(_DWORD *)((char *)v5 + 11);
LABEL_185:
      *(_DWORD *)(v6 + 7) = *(_DWORD *)((char *)v5 + 7);
LABEL_186:
      *(_DWORD *)(v6 + 3) = *(_DWORD *)((char *)v5 + 3);
LABEL_187:
      *(_WORD *)(v6 + 1) = *(_WORD *)((char *)v5 + 1);
      *(_BYTE *)v6 = *(_BYTE *)v5;
      result = a2;
      break;
    default:
      goto LABEL_191;
  }
  return result;
}
// 8060BD3: conditional instruction was optimized away because %arg_8.4>=30u
// 8060BBC: variable 'v220' is possibly undefined
// 80EB984: using guessed type int _x86_shared_cache_size_half;
// 80EB994: using guessed type int _x86_data_cache_size_half;

//----- (08060CA0) --------------------------------------------------------
int __cdecl _memset_sse2_rep(int a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax
  unsigned int v6; // edx
  int result; // eax
  __m128i v8; // xmm0
  __m128i *v9; // edx
  unsigned int v10; // ecx
  bool v11; // cf
  unsigned int v12; // ecx
  __m128i *v13; // edi
  char v14; // dl
  unsigned int v15; // ecx
  unsigned int v16; // edx
  char *v17; // edi

  v3 = a3;
  v4 = a2;
  BYTE1(v4) = a2;
  v5 = v4 | (v4 << 16);
  v6 = a3 + a1;
  switch ( a3 )
  {
    case 0u:
      goto LABEL_9;
    case 1u:
      goto LABEL_17;
    case 2u:
      goto LABEL_25;
    case 3u:
      goto LABEL_33;
    case 4u:
      goto LABEL_8;
    case 5u:
      goto LABEL_16;
    case 6u:
      goto LABEL_24;
    case 7u:
      goto LABEL_32;
    case 8u:
      goto LABEL_7;
    case 9u:
      goto LABEL_15;
    case 0xAu:
      goto LABEL_23;
    case 0xBu:
      goto LABEL_31;
    case 0xCu:
      goto LABEL_6;
    case 0xDu:
      goto LABEL_14;
    case 0xEu:
      goto LABEL_22;
    case 0xFu:
      goto LABEL_30;
    case 0x10u:
      goto LABEL_5;
    case 0x11u:
      goto LABEL_13;
    case 0x12u:
      goto LABEL_21;
    case 0x13u:
      goto LABEL_29;
    case 0x14u:
      goto LABEL_4;
    case 0x15u:
      goto LABEL_12;
    case 0x16u:
      goto LABEL_20;
    case 0x17u:
      goto LABEL_28;
    case 0x18u:
      goto LABEL_3;
    case 0x19u:
      goto LABEL_11;
    case 0x1Au:
      goto LABEL_19;
    case 0x1Bu:
      goto LABEL_27;
    case 0x1Cu:
      *(_DWORD *)(v6 - 28) = v5;
LABEL_3:
      *(_DWORD *)(v6 - 24) = v5;
LABEL_4:
      *(_DWORD *)(v6 - 20) = v5;
LABEL_5:
      *(_DWORD *)(v6 - 16) = v5;
LABEL_6:
      *(_DWORD *)(v6 - 12) = v5;
LABEL_7:
      *(_DWORD *)(v6 - 8) = v5;
LABEL_8:
      *(_DWORD *)(v6 - 4) = v5;
LABEL_9:
      result = a1;
      break;
    case 0x1Du:
      *(_DWORD *)(v6 - 29) = v5;
LABEL_11:
      *(_DWORD *)(v6 - 25) = v5;
LABEL_12:
      *(_DWORD *)(v6 - 21) = v5;
LABEL_13:
      *(_DWORD *)(v6 - 17) = v5;
LABEL_14:
      *(_DWORD *)(v6 - 13) = v5;
LABEL_15:
      *(_DWORD *)(v6 - 9) = v5;
LABEL_16:
      *(_DWORD *)(v6 - 5) = v5;
LABEL_17:
      *(_BYTE *)(v6 - 1) = v5;
      result = a1;
      break;
    case 0x1Eu:
      *(_DWORD *)(v6 - 30) = v5;
LABEL_19:
      *(_DWORD *)(v6 - 26) = v5;
LABEL_20:
      *(_DWORD *)(v6 - 22) = v5;
LABEL_21:
      *(_DWORD *)(v6 - 18) = v5;
LABEL_22:
      *(_DWORD *)(v6 - 14) = v5;
LABEL_23:
      *(_DWORD *)(v6 - 10) = v5;
LABEL_24:
      *(_DWORD *)(v6 - 6) = v5;
LABEL_25:
      *(_WORD *)(v6 - 2) = v5;
      result = a1;
      break;
    case 0x1Fu:
      *(_DWORD *)(v6 - 31) = v5;
LABEL_27:
      *(_DWORD *)(v6 - 27) = v5;
LABEL_28:
      *(_DWORD *)(v6 - 23) = v5;
LABEL_29:
      *(_DWORD *)(v6 - 19) = v5;
LABEL_30:
      *(_DWORD *)(v6 - 15) = v5;
LABEL_31:
      *(_DWORD *)(v6 - 11) = v5;
LABEL_32:
      *(_DWORD *)(v6 - 7) = v5;
LABEL_33:
      *(_WORD *)(v6 - 3) = v5;
      *(_BYTE *)(v6 - 1) = v5;
      result = a1;
      break;
    default:
      v8 = _mm_shuffle_epi32(_mm_cvtsi32_si128(v5), 0);
      if ( (v6 & 0xF) != 0 )
      {
        *(__m128i *)v6 = v8;
        v6 = (v6 & 0xFFFFFFF0) + 16;
        v3 = a3 + a1 - v6 + a3;
        v5 = _mm_cvtsi128_si32(v8);
      }
      v9 = (__m128i *)(v3 + v6);
      switch ( v3 )
      {
        case 0u:
          goto LABEL_54;
        case 1u:
          goto LABEL_62;
        case 2u:
          goto LABEL_70;
        case 3u:
          goto LABEL_78;
        case 4u:
          goto LABEL_86;
        case 5u:
          goto LABEL_94;
        case 6u:
          goto LABEL_102;
        case 7u:
          goto LABEL_110;
        case 8u:
          goto LABEL_118;
        case 9u:
          goto LABEL_126;
        case 0xAu:
          goto LABEL_134;
        case 0xBu:
          goto LABEL_142;
        case 0xCu:
          goto LABEL_150;
        case 0xDu:
          goto LABEL_158;
        case 0xEu:
          goto LABEL_166;
        case 0xFu:
          goto LABEL_174;
        case 0x10u:
          goto LABEL_53;
        case 0x11u:
          goto LABEL_61;
        case 0x12u:
          goto LABEL_69;
        case 0x13u:
          goto LABEL_77;
        case 0x14u:
          goto LABEL_85;
        case 0x15u:
          goto LABEL_93;
        case 0x16u:
          goto LABEL_101;
        case 0x17u:
          goto LABEL_109;
        case 0x18u:
          goto LABEL_117;
        case 0x19u:
          goto LABEL_125;
        case 0x1Au:
          goto LABEL_133;
        case 0x1Bu:
          goto LABEL_141;
        case 0x1Cu:
          goto LABEL_149;
        case 0x1Du:
          goto LABEL_157;
        case 0x1Eu:
          goto LABEL_165;
        case 0x1Fu:
          goto LABEL_173;
        case 0x20u:
          goto LABEL_52;
        case 0x21u:
          goto LABEL_60;
        case 0x22u:
          goto LABEL_68;
        case 0x23u:
          goto LABEL_76;
        case 0x24u:
          goto LABEL_84;
        case 0x25u:
          goto LABEL_92;
        case 0x26u:
          goto LABEL_100;
        case 0x27u:
          goto LABEL_108;
        case 0x28u:
          goto LABEL_116;
        case 0x29u:
          goto LABEL_124;
        case 0x2Au:
          goto LABEL_132;
        case 0x2Bu:
          goto LABEL_140;
        case 0x2Cu:
          goto LABEL_148;
        case 0x2Du:
          goto LABEL_156;
        case 0x2Eu:
          goto LABEL_164;
        case 0x2Fu:
          goto LABEL_172;
        case 0x30u:
          goto LABEL_51;
        case 0x31u:
          goto LABEL_59;
        case 0x32u:
          goto LABEL_67;
        case 0x33u:
          goto LABEL_75;
        case 0x34u:
          goto LABEL_83;
        case 0x35u:
          goto LABEL_91;
        case 0x36u:
          goto LABEL_99;
        case 0x37u:
          goto LABEL_107;
        case 0x38u:
          goto LABEL_115;
        case 0x39u:
          goto LABEL_123;
        case 0x3Au:
          goto LABEL_131;
        case 0x3Bu:
          goto LABEL_139;
        case 0x3Cu:
          goto LABEL_147;
        case 0x3Du:
          goto LABEL_155;
        case 0x3Eu:
          goto LABEL_163;
        case 0x3Fu:
          goto LABEL_171;
        case 0x40u:
          goto LABEL_50;
        case 0x41u:
          goto LABEL_58;
        case 0x42u:
          goto LABEL_66;
        case 0x43u:
          goto LABEL_74;
        case 0x44u:
          goto LABEL_82;
        case 0x45u:
          goto LABEL_90;
        case 0x46u:
          goto LABEL_98;
        case 0x47u:
          goto LABEL_106;
        case 0x48u:
          goto LABEL_114;
        case 0x49u:
          goto LABEL_122;
        case 0x4Au:
          goto LABEL_130;
        case 0x4Bu:
          goto LABEL_138;
        case 0x4Cu:
          goto LABEL_146;
        case 0x4Du:
          goto LABEL_154;
        case 0x4Eu:
          goto LABEL_162;
        case 0x4Fu:
          goto LABEL_170;
        case 0x50u:
          goto LABEL_49;
        case 0x51u:
          goto LABEL_57;
        case 0x52u:
          goto LABEL_65;
        case 0x53u:
          goto LABEL_73;
        case 0x54u:
          goto LABEL_81;
        case 0x55u:
          goto LABEL_89;
        case 0x56u:
          goto LABEL_97;
        case 0x57u:
          goto LABEL_105;
        case 0x58u:
          goto LABEL_113;
        case 0x59u:
          goto LABEL_121;
        case 0x5Au:
          goto LABEL_129;
        case 0x5Bu:
          goto LABEL_137;
        case 0x5Cu:
          goto LABEL_145;
        case 0x5Du:
          goto LABEL_153;
        case 0x5Eu:
          goto LABEL_161;
        case 0x5Fu:
          goto LABEL_169;
        case 0x60u:
          goto LABEL_48;
        case 0x61u:
          goto LABEL_56;
        case 0x62u:
          goto LABEL_64;
        case 0x63u:
          goto LABEL_72;
        case 0x64u:
          goto LABEL_80;
        case 0x65u:
          goto LABEL_88;
        case 0x66u:
          goto LABEL_96;
        case 0x67u:
          goto LABEL_104;
        case 0x68u:
          goto LABEL_112;
        case 0x69u:
          goto LABEL_120;
        case 0x6Au:
          goto LABEL_128;
        case 0x6Bu:
          goto LABEL_136;
        case 0x6Cu:
          goto LABEL_144;
        case 0x6Du:
          goto LABEL_152;
        case 0x6Eu:
          goto LABEL_160;
        case 0x6Fu:
          goto LABEL_168;
        case 0x70u:
LABEL_47:
          v9[-7] = v8;
LABEL_48:
          v9[-6] = v8;
LABEL_49:
          v9[-5] = v8;
LABEL_50:
          v9[-4] = v8;
LABEL_51:
          v9[-3] = v8;
LABEL_52:
          v9[-2] = v8;
LABEL_53:
          v9[-1] = v8;
LABEL_54:
          result = a1;
          break;
        case 0x71u:
LABEL_55:
          *(__m128i *)((char *)v9 - 113) = v8;
LABEL_56:
          *(__m128i *)((char *)v9 - 97) = v8;
LABEL_57:
          *(__m128i *)((char *)v9 - 81) = v8;
LABEL_58:
          *(__m128i *)((char *)v9 - 65) = v8;
LABEL_59:
          *(__m128i *)((char *)v9 - 49) = v8;
LABEL_60:
          *(__m128i *)((char *)v9 - 33) = v8;
LABEL_61:
          *(__m128i *)((char *)v9 - 17) = v8;
LABEL_62:
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x72u:
LABEL_63:
          *(__m128i *)((char *)v9 - 114) = v8;
LABEL_64:
          *(__m128i *)((char *)v9 - 98) = v8;
LABEL_65:
          *(__m128i *)((char *)v9 - 82) = v8;
LABEL_66:
          *(__m128i *)((char *)v9 - 66) = v8;
LABEL_67:
          *(__m128i *)((char *)v9 - 50) = v8;
LABEL_68:
          *(__m128i *)((char *)v9 - 34) = v8;
LABEL_69:
          *(__m128i *)((char *)v9 - 18) = v8;
LABEL_70:
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x73u:
LABEL_71:
          *(__m128i *)((char *)v9 - 115) = v8;
LABEL_72:
          *(__m128i *)((char *)v9 - 99) = v8;
LABEL_73:
          *(__m128i *)((char *)v9 - 83) = v8;
LABEL_74:
          *(__m128i *)((char *)v9 - 67) = v8;
LABEL_75:
          *(__m128i *)((char *)v9 - 51) = v8;
LABEL_76:
          *(__m128i *)((char *)v9 - 35) = v8;
LABEL_77:
          *(__m128i *)((char *)v9 - 19) = v8;
LABEL_78:
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x74u:
LABEL_79:
          *(__m128i *)((char *)v9 - 116) = v8;
LABEL_80:
          *(__m128i *)((char *)v9 - 100) = v8;
LABEL_81:
          *(__m128i *)((char *)v9 - 84) = v8;
LABEL_82:
          *(__m128i *)((char *)v9 - 68) = v8;
LABEL_83:
          *(__m128i *)((char *)v9 - 52) = v8;
LABEL_84:
          *(__m128i *)((char *)v9 - 36) = v8;
LABEL_85:
          *(__m128i *)((char *)v9 - 20) = v8;
LABEL_86:
          v9[-1].m128i_i32[3] = v5;
          result = a1;
          break;
        case 0x75u:
LABEL_87:
          *(__m128i *)((char *)v9 - 117) = v8;
LABEL_88:
          *(__m128i *)((char *)v9 - 101) = v8;
LABEL_89:
          *(__m128i *)((char *)v9 - 85) = v8;
LABEL_90:
          *(__m128i *)((char *)v9 - 69) = v8;
LABEL_91:
          *(__m128i *)((char *)v9 - 53) = v8;
LABEL_92:
          *(__m128i *)((char *)v9 - 37) = v8;
LABEL_93:
          *(__m128i *)((char *)v9 - 21) = v8;
LABEL_94:
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 3) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x76u:
LABEL_95:
          *(__m128i *)((char *)v9 - 118) = v8;
LABEL_96:
          *(__m128i *)((char *)v9 - 102) = v8;
LABEL_97:
          *(__m128i *)((char *)v9 - 86) = v8;
LABEL_98:
          *(__m128i *)((char *)v9 - 70) = v8;
LABEL_99:
          *(__m128i *)((char *)v9 - 54) = v8;
LABEL_100:
          *(__m128i *)((char *)v9 - 38) = v8;
LABEL_101:
          *(__m128i *)((char *)v9 - 22) = v8;
LABEL_102:
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 2) = v5;
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x77u:
LABEL_103:
          *(__m128i *)((char *)v9 - 119) = v8;
LABEL_104:
          *(__m128i *)((char *)v9 - 103) = v8;
LABEL_105:
          *(__m128i *)((char *)v9 - 87) = v8;
LABEL_106:
          *(__m128i *)((char *)v9 - 71) = v8;
LABEL_107:
          *(__m128i *)((char *)v9 - 55) = v8;
LABEL_108:
          *(__m128i *)((char *)v9 - 39) = v8;
LABEL_109:
          *(__m128i *)((char *)v9 - 23) = v8;
LABEL_110:
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 1) = v5;
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x78u:
LABEL_111:
          *(__m128i *)((char *)v9 - 120) = v8;
LABEL_112:
          *(__m128i *)((char *)v9 - 104) = v8;
LABEL_113:
          *(__m128i *)((char *)v9 - 88) = v8;
LABEL_114:
          *(__m128i *)((char *)v9 - 72) = v8;
LABEL_115:
          *(__m128i *)((char *)v9 - 56) = v8;
LABEL_116:
          *(__m128i *)((char *)v9 - 40) = v8;
LABEL_117:
          *(__m128i *)((char *)v9 - 24) = v8;
LABEL_118:
          v9[-1].m128i_i64[1] = v8.m128i_i64[0];
          result = a1;
          break;
        case 0x79u:
LABEL_119:
          *(__m128i *)((char *)v9 - 121) = v8;
LABEL_120:
          *(__m128i *)((char *)v9 - 105) = v8;
LABEL_121:
          *(__m128i *)((char *)v9 - 89) = v8;
LABEL_122:
          *(__m128i *)((char *)v9 - 73) = v8;
LABEL_123:
          *(__m128i *)((char *)v9 - 57) = v8;
LABEL_124:
          *(__m128i *)((char *)v9 - 41) = v8;
LABEL_125:
          *(__m128i *)((char *)v9 - 25) = v8;
LABEL_126:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 7) = v8.m128i_i64[0];
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x7Au:
LABEL_127:
          *(__m128i *)((char *)v9 - 122) = v8;
LABEL_128:
          *(__m128i *)((char *)v9 - 106) = v8;
LABEL_129:
          *(__m128i *)((char *)v9 - 90) = v8;
LABEL_130:
          *(__m128i *)((char *)v9 - 74) = v8;
LABEL_131:
          *(__m128i *)((char *)v9 - 58) = v8;
LABEL_132:
          *(__m128i *)((char *)v9 - 42) = v8;
LABEL_133:
          *(__m128i *)((char *)v9 - 26) = v8;
LABEL_134:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 6) = v8.m128i_i64[0];
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x7Bu:
LABEL_135:
          *(__m128i *)((char *)v9 - 123) = v8;
LABEL_136:
          *(__m128i *)((char *)v9 - 107) = v8;
LABEL_137:
          *(__m128i *)((char *)v9 - 91) = v8;
LABEL_138:
          *(__m128i *)((char *)v9 - 75) = v8;
LABEL_139:
          *(__m128i *)((char *)v9 - 59) = v8;
LABEL_140:
          *(__m128i *)((char *)v9 - 43) = v8;
LABEL_141:
          *(__m128i *)((char *)v9 - 27) = v8;
LABEL_142:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 5) = v8.m128i_i64[0];
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x7Cu:
LABEL_143:
          *(__m128i *)((char *)v9 - 124) = v8;
LABEL_144:
          *(__m128i *)((char *)v9 - 108) = v8;
LABEL_145:
          *(__m128i *)((char *)v9 - 92) = v8;
LABEL_146:
          *(__m128i *)((char *)v9 - 76) = v8;
LABEL_147:
          *(__m128i *)((char *)v9 - 60) = v8;
LABEL_148:
          *(__m128i *)((char *)v9 - 44) = v8;
LABEL_149:
          *(__m128i *)((char *)v9 - 28) = v8;
LABEL_150:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 4) = v8.m128i_i64[0];
          v9[-1].m128i_i32[3] = v5;
          result = a1;
          break;
        case 0x7Du:
LABEL_151:
          *(__m128i *)((char *)v9 - 125) = v8;
LABEL_152:
          *(__m128i *)((char *)v9 - 109) = v8;
LABEL_153:
          *(__m128i *)((char *)v9 - 93) = v8;
LABEL_154:
          *(__m128i *)((char *)v9 - 77) = v8;
LABEL_155:
          *(__m128i *)((char *)v9 - 61) = v8;
LABEL_156:
          *(__m128i *)((char *)v9 - 45) = v8;
LABEL_157:
          *(__m128i *)((char *)v9 - 29) = v8;
LABEL_158:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 3) = v8.m128i_i64[0];
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 3) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x7Eu:
LABEL_159:
          *(__m128i *)((char *)v9 - 126) = v8;
LABEL_160:
          *(__m128i *)((char *)v9 - 110) = v8;
LABEL_161:
          *(__m128i *)((char *)v9 - 94) = v8;
LABEL_162:
          *(__m128i *)((char *)v9 - 78) = v8;
LABEL_163:
          *(__m128i *)((char *)v9 - 62) = v8;
LABEL_164:
          *(__m128i *)((char *)v9 - 46) = v8;
LABEL_165:
          *(__m128i *)((char *)v9 - 30) = v8;
LABEL_166:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 2) = v8.m128i_i64[0];
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 2) = v5;
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x7Fu:
LABEL_167:
          *(__m128i *)((char *)v9 - 127) = v8;
LABEL_168:
          *(__m128i *)((char *)v9 - 111) = v8;
LABEL_169:
          *(__m128i *)((char *)v9 - 95) = v8;
LABEL_170:
          *(__m128i *)((char *)v9 - 79) = v8;
LABEL_171:
          *(__m128i *)((char *)v9 - 63) = v8;
LABEL_172:
          *(__m128i *)((char *)v9 - 47) = v8;
LABEL_173:
          *(__m128i *)((char *)v9 - 31) = v8;
LABEL_174:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 1) = v8.m128i_i64[0];
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 1) = v5;
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        default:
          if ( v3 < _x86_data_cache_size - ((unsigned int)_x86_data_cache_size >> 4) )
          {
            v10 = v3 - 128;
            do
            {
              v11 = v10 < 0x80;
              v10 -= 128;
              *v9 = v8;
              v9[1] = v8;
              v9[2] = v8;
              v9[3] = v8;
              v9[4] = v8;
              v9[5] = v8;
              v9[6] = v8;
              v9[7] = v8;
              v9 += 8;
              if ( v11 )
                break;
              v11 = v10 < 0x80;
              v10 -= 128;
              *v9 = v8;
              v9[1] = v8;
              v9[2] = v8;
              v9[3] = v8;
              v9[4] = v8;
              v9[5] = v8;
              v9[6] = v8;
              v9[7] = v8;
              v9 += 8;
            }
            while ( !v11 );
            v12 = v10 + 128;
            v9 = (__m128i *)((char *)v9 + v12);
            switch ( v12 )
            {
              case 0u:
                goto LABEL_54;
              case 1u:
                goto LABEL_62;
              case 2u:
                goto LABEL_70;
              case 3u:
                goto LABEL_78;
              case 4u:
                goto LABEL_86;
              case 5u:
                goto LABEL_94;
              case 6u:
                goto LABEL_102;
              case 7u:
                goto LABEL_110;
              case 8u:
                goto LABEL_118;
              case 9u:
                goto LABEL_126;
              case 0xAu:
                goto LABEL_134;
              case 0xBu:
                goto LABEL_142;
              case 0xCu:
                goto LABEL_150;
              case 0xDu:
                goto LABEL_158;
              case 0xEu:
                goto LABEL_166;
              case 0xFu:
                goto LABEL_174;
              case 0x10u:
                goto LABEL_53;
              case 0x11u:
                goto LABEL_61;
              case 0x12u:
                goto LABEL_69;
              case 0x13u:
                goto LABEL_77;
              case 0x14u:
                goto LABEL_85;
              case 0x15u:
                goto LABEL_93;
              case 0x16u:
                goto LABEL_101;
              case 0x17u:
                goto LABEL_109;
              case 0x18u:
                goto LABEL_117;
              case 0x19u:
                goto LABEL_125;
              case 0x1Au:
                goto LABEL_133;
              case 0x1Bu:
                goto LABEL_141;
              case 0x1Cu:
                goto LABEL_149;
              case 0x1Du:
                goto LABEL_157;
              case 0x1Eu:
                goto LABEL_165;
              case 0x1Fu:
                goto LABEL_173;
              case 0x20u:
                goto LABEL_52;
              case 0x21u:
                goto LABEL_60;
              case 0x22u:
                goto LABEL_68;
              case 0x23u:
                goto LABEL_76;
              case 0x24u:
                goto LABEL_84;
              case 0x25u:
                goto LABEL_92;
              case 0x26u:
                goto LABEL_100;
              case 0x27u:
                goto LABEL_108;
              case 0x28u:
                goto LABEL_116;
              case 0x29u:
                goto LABEL_124;
              case 0x2Au:
                goto LABEL_132;
              case 0x2Bu:
                goto LABEL_140;
              case 0x2Cu:
                goto LABEL_148;
              case 0x2Du:
                goto LABEL_156;
              case 0x2Eu:
                goto LABEL_164;
              case 0x2Fu:
                goto LABEL_172;
              case 0x30u:
                goto LABEL_51;
              case 0x31u:
                goto LABEL_59;
              case 0x32u:
                goto LABEL_67;
              case 0x33u:
                goto LABEL_75;
              case 0x34u:
                goto LABEL_83;
              case 0x35u:
                goto LABEL_91;
              case 0x36u:
                goto LABEL_99;
              case 0x37u:
                goto LABEL_107;
              case 0x38u:
                goto LABEL_115;
              case 0x39u:
                goto LABEL_123;
              case 0x3Au:
                goto LABEL_131;
              case 0x3Bu:
                goto LABEL_139;
              case 0x3Cu:
                goto LABEL_147;
              case 0x3Du:
                goto LABEL_155;
              case 0x3Eu:
                goto LABEL_163;
              case 0x3Fu:
                goto LABEL_171;
              case 0x40u:
                goto LABEL_50;
              case 0x41u:
                goto LABEL_58;
              case 0x42u:
                goto LABEL_66;
              case 0x43u:
                goto LABEL_74;
              case 0x44u:
                goto LABEL_82;
              case 0x45u:
                goto LABEL_90;
              case 0x46u:
                goto LABEL_98;
              case 0x47u:
                goto LABEL_106;
              case 0x48u:
                goto LABEL_114;
              case 0x49u:
                goto LABEL_122;
              case 0x4Au:
                goto LABEL_130;
              case 0x4Bu:
                goto LABEL_138;
              case 0x4Cu:
                goto LABEL_146;
              case 0x4Du:
                goto LABEL_154;
              case 0x4Eu:
                goto LABEL_162;
              case 0x4Fu:
                goto LABEL_170;
              case 0x50u:
                goto LABEL_49;
              case 0x51u:
                goto LABEL_57;
              case 0x52u:
                goto LABEL_65;
              case 0x53u:
                goto LABEL_73;
              case 0x54u:
                goto LABEL_81;
              case 0x55u:
                goto LABEL_89;
              case 0x56u:
                goto LABEL_97;
              case 0x57u:
                goto LABEL_105;
              case 0x58u:
                goto LABEL_113;
              case 0x59u:
                goto LABEL_121;
              case 0x5Au:
                goto LABEL_129;
              case 0x5Bu:
                goto LABEL_137;
              case 0x5Cu:
                goto LABEL_145;
              case 0x5Du:
                goto LABEL_153;
              case 0x5Eu:
                goto LABEL_161;
              case 0x5Fu:
                goto LABEL_169;
              case 0x60u:
                goto LABEL_48;
              case 0x61u:
                goto LABEL_56;
              case 0x62u:
                goto LABEL_64;
              case 0x63u:
                goto LABEL_72;
              case 0x64u:
                goto LABEL_80;
              case 0x65u:
                goto LABEL_88;
              case 0x66u:
                goto LABEL_96;
              case 0x67u:
                goto LABEL_104;
              case 0x68u:
                goto LABEL_112;
              case 0x69u:
                goto LABEL_120;
              case 0x6Au:
                goto LABEL_128;
              case 0x6Bu:
                goto LABEL_136;
              case 0x6Cu:
                goto LABEL_144;
              case 0x6Du:
                goto LABEL_152;
              case 0x6Eu:
                goto LABEL_160;
              case 0x6Fu:
                goto LABEL_168;
              case 0x70u:
                goto LABEL_47;
              case 0x71u:
                goto LABEL_55;
              case 0x72u:
                goto LABEL_63;
              case 0x73u:
                goto LABEL_71;
              case 0x74u:
                goto LABEL_79;
              case 0x75u:
                goto LABEL_87;
              case 0x76u:
                goto LABEL_95;
              case 0x77u:
                goto LABEL_103;
              case 0x78u:
                goto LABEL_111;
              case 0x79u:
                goto LABEL_119;
              case 0x7Au:
                goto LABEL_127;
              case 0x7Bu:
                goto LABEL_135;
              case 0x7Cu:
                goto LABEL_143;
              case 0x7Du:
                goto LABEL_151;
              case 0x7Eu:
                goto LABEL_159;
              case 0x7Fu:
                goto LABEL_167;
            }
          }
          v13 = v9;
          v14 = v3;
          v15 = v3 >> 2;
          v16 = v14 & 3;
          memset32(v13, v5, v15);
          v17 = &v13->m128i_i8[4 * v15];
          if ( v16 )
          {
            if ( v16 < 2 || (*(_WORD *)v17 = v5, v17 += 2, v16 != 2) )
              *v17 = v5;
          }
          result = a1;
          break;
      }
      break;
  }
  return result;
}
// 80EB990: using guessed type int _x86_data_cache_size;

//----- (080611E0) --------------------------------------------------------
int __cdecl _strcmp_ssse3(int a1, int a2)
{
  char v2; // cc
  unsigned __int8 v3; // cl
  unsigned __int8 v4; // cl
  unsigned __int8 v5; // cl
  unsigned __int8 v6; // cl
  unsigned __int8 v7; // cl
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // cl
  int v10; // edx
  int v11; // eax
  __m128i v12; // xmm1
  __m128i v13; // xmm2
  int v14; // ecx
  unsigned int v15; // ecx
  unsigned int v16; // edi
  const __m128i *v17; // eax
  const __m128i *v18; // edx
  char v19; // bl
  const __m128i *v20; // et0
  unsigned int v21; // et1
  int v22; // edi
  bool v23; // zf
  __m128i si128; // xmm1
  unsigned int v25; // edi
  int v26; // esi
  int v27; // edi
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  __m128i v30; // xmm1
  unsigned int v31; // edi
  __m128i v32; // xmm3
  __m128i v33; // xmm0
  int v34; // edi
  __m128i v35; // xmm1
  __m128i v36; // xmm4
  __m128i v37; // xmm1
  __m128i v38; // xmm4
  __m128i v39; // xmm0
  __m128i v40; // xmm1
  __m128i v41; // xmm0
  __m128i v42; // xmm3
  __m128i v43; // xmm1
  unsigned int v44; // edi
  __m128i v45; // xmm3
  __m128i v46; // xmm0
  int v47; // edi
  __m128i v48; // xmm1
  __m128i v49; // xmm4
  __m128i v50; // xmm1
  __m128i v51; // xmm4
  __m128i v52; // xmm0
  __m128i v53; // xmm1
  unsigned int v54; // edi
  __m128i v55; // xmm3
  __m128i v56; // xmm0
  int v57; // edi
  __m128i v58; // xmm1
  __m128i v59; // xmm4
  __m128i v60; // xmm1
  __m128i v61; // xmm4
  __m128i v62; // xmm0
  __m128i v63; // xmm1
  unsigned int v64; // edi
  __m128i v65; // xmm3
  __m128i v66; // xmm0
  int v67; // edi
  __m128i v68; // xmm1
  __m128i v69; // xmm4
  __m128i v70; // xmm1
  __m128i v71; // xmm4
  __m128i v72; // xmm0
  __m128i v73; // xmm1
  unsigned int v74; // edi
  __m128i v75; // xmm3
  __m128i v76; // xmm0
  int v77; // edi
  __m128i v78; // xmm1
  __m128i v79; // xmm4
  __m128i v80; // xmm1
  __m128i v81; // xmm4
  __m128i v82; // xmm0
  __m128i v83; // xmm1
  unsigned int v84; // edi
  __m128i v85; // xmm3
  __m128i v86; // xmm0
  int v87; // edi
  __m128i v88; // xmm1
  __m128i v89; // xmm4
  __m128i v90; // xmm1
  __m128i v91; // xmm4
  __m128i v92; // xmm0
  __m128i v93; // xmm1
  unsigned int v94; // edi
  __m128i v95; // xmm3
  __m128i v96; // xmm0
  int v97; // edi
  __m128i v98; // xmm1
  __m128i v99; // xmm4
  __m128i v100; // xmm1
  __m128i v101; // xmm4
  __m128i v102; // xmm0
  __m128i v103; // xmm1
  unsigned int v104; // edi
  __m128i v105; // xmm3
  __m128i v106; // xmm0
  int v107; // edi
  __m128i v108; // xmm1
  __m128i v109; // xmm4
  __m128i v110; // xmm1
  __m128i v111; // xmm4
  __m128i v112; // xmm0
  __m128i v113; // xmm1
  unsigned int v114; // edi
  __m128i v115; // xmm3
  __m128i v116; // xmm0
  int v117; // edi
  __m128i v118; // xmm1
  __m128i v119; // xmm4
  __m128i v120; // xmm1
  __m128i v121; // xmm4
  __m128i v122; // xmm0
  __m128i v123; // xmm1
  unsigned int v124; // edi
  __m128i v125; // xmm3
  __m128i v126; // xmm0
  int v127; // edi
  __m128i v128; // xmm1
  __m128i v129; // xmm4
  __m128i v130; // xmm1
  __m128i v131; // xmm4
  __m128i v132; // xmm0
  __m128i v133; // xmm1
  unsigned int v134; // edi
  __m128i v135; // xmm3
  __m128i v136; // xmm0
  int v137; // edi
  __m128i v138; // xmm1
  __m128i v139; // xmm4
  __m128i v140; // xmm1
  __m128i v141; // xmm4
  __m128i v142; // xmm0
  __m128i v143; // xmm1
  unsigned int v144; // edi
  __m128i v145; // xmm3
  __m128i v146; // xmm0
  int v147; // edi
  __m128i v148; // xmm1
  __m128i v149; // xmm4
  __m128i v150; // xmm1
  __m128i v151; // xmm4
  __m128i v152; // xmm0
  __m128i v153; // xmm1
  unsigned int v154; // edi
  __m128i v155; // xmm3
  __m128i v156; // xmm0
  int v157; // edi
  __m128i v158; // xmm1
  __m128i v159; // xmm4
  __m128i v160; // xmm1
  __m128i v161; // xmm4
  __m128i v162; // xmm0
  __m128i v163; // xmm1
  unsigned int v164; // edi
  __m128i v165; // xmm3
  __m128i v166; // xmm0
  int v167; // edi
  __m128i v168; // xmm1
  __m128i v169; // xmm4
  __m128i v170; // xmm1
  __m128i v171; // xmm4
  __m128i v172; // xmm0
  __m128i v173; // xmm1
  unsigned int v174; // edi
  __m128i v175; // xmm3
  __m128i v176; // xmm0
  int v177; // edi
  __m128i v178; // xmm1
  __m128i v179; // xmm4
  __m128i v180; // xmm1
  __m128i v181; // xmm4
  __m128i v182; // xmm0
  int v183; // et2
  int result; // eax

  v2 = *(_BYTE *)a1 <= *(_BYTE *)a2;
  if ( *(_BYTE *)a1 != *(_BYTE *)a2 )
    goto LABEL_223;
  if ( !*(_BYTE *)a2 )
    return 0;
  v3 = *(_BYTE *)(a2 + 1);
  v2 = *(_BYTE *)(a1 + 1) <= v3;
  if ( *(_BYTE *)(a1 + 1) != v3 )
    goto LABEL_223;
  if ( !*(_BYTE *)(a2 + 1) )
    return 0;
  v4 = *(_BYTE *)(a2 + 2);
  v2 = *(_BYTE *)(a1 + 2) <= v4;
  if ( *(_BYTE *)(a1 + 2) != v4 )
    goto LABEL_223;
  if ( !*(_BYTE *)(a2 + 2) )
    return 0;
  v5 = *(_BYTE *)(a2 + 3);
  v2 = *(_BYTE *)(a1 + 3) <= v5;
  if ( *(_BYTE *)(a1 + 3) != v5 )
    goto LABEL_223;
  if ( !*(_BYTE *)(a2 + 3) )
    return 0;
  v6 = *(_BYTE *)(a2 + 4);
  v2 = *(_BYTE *)(a1 + 4) <= v6;
  if ( *(_BYTE *)(a1 + 4) != v6 )
    goto LABEL_223;
  if ( !*(_BYTE *)(a2 + 4) )
    return 0;
  v7 = *(_BYTE *)(a2 + 5);
  v2 = *(_BYTE *)(a1 + 5) <= v7;
  if ( *(_BYTE *)(a1 + 5) != v7 )
    goto LABEL_223;
  if ( !*(_BYTE *)(a2 + 5) )
    return 0;
  v8 = *(_BYTE *)(a2 + 6);
  v2 = *(_BYTE *)(a1 + 6) <= v8;
  if ( *(_BYTE *)(a1 + 6) != v8 )
    goto LABEL_223;
  if ( !*(_BYTE *)(a2 + 6) )
    return 0;
  v9 = *(_BYTE *)(a2 + 7);
  v2 = *(_BYTE *)(a1 + 7) <= v9;
  if ( *(_BYTE *)(a1 + 7) != v9 )
  {
LABEL_223:
    result = 1;
    if ( v2 )
      return -1;
    return result;
  }
  if ( !*(_BYTE *)(a2 + 7) )
    return 0;
  v10 = a1 + 8;
  v11 = a2 + 8;
  if ( (((_WORD)a1 + 8) & 0xFFFu) <= 0xFF0 && (v11 & 0xFFFu) <= 0xFF0 )
  {
    v12.m128i_i64[0] = *(__int64 *)v11;
    v13.m128i_i64[0] = *(__int64 *)v10;
    v12.m128i_i64[1] = *(__int64 *)(a2 + 16);
    v13.m128i_i64[1] = *(__int64 *)(a1 + 16);
    v14 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v12, v13), _mm_cmpeq_epi8((__m128i)0LL, v12))) - 0xFFFF;
    if ( v14 )
      goto LABEL_199;
    v11 = a2 + 24;
    v10 = a1 + 24;
  }
  v15 = v11 & 0xF;
  v16 = v10 & 0xF;
  v17 = (const __m128i *)(v15 ^ v11);
  v18 = (const __m128i *)(v16 ^ v10);
  v19 = 0;
  if ( v15 == v16 )
  {
LABEL_40:
    si128 = _mm_load_si128(v17);
    v25 = (unsigned int)_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(si128, *v18), _mm_cmpeq_epi8((__m128i)0LL, si128))) >> v15;
    v26 = (0xFFFFu >> v15) - v25;
    v23 = 0xFFFFu >> v15 == v25;
    v27 = v15;
    if ( v23 )
    {
      v19 = 16;
      v15 = 16;
      v28 = 0LL;
      while ( 1 )
      {
        v29 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
        v28 = _mm_cmpeq_epi8(v28, v29);
        v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v29, *(const __m128i *)((char *)v18 + v15)), v28)) - 0xFFFF;
        if ( v26 )
          break;
        v15 += 16;
      }
      goto LABEL_195;
    }
    goto LABEL_196;
  }
  if ( v15 <= v16 )
  {
    v19 = 32;
    v20 = v17;
    v17 = v18;
    v18 = v20;
    v21 = v15;
    v15 = v16;
    v16 = v21;
  }
  v22 = v16 + 15 - v15;
  v23 = v22 == 8;
  if ( v22 <= 8 )
    goto LABEL_31;
  if ( v22 != 14 )
  {
    if ( v22 != 13 )
    {
      if ( v22 != 12 )
      {
        if ( v22 != 11 )
        {
          if ( v22 != 10 )
          {
            v23 = v22 == 9;
            if ( v22 != 9 )
            {
LABEL_31:
              if ( !v23 )
              {
                if ( v22 != 7 )
                {
                  if ( v22 != 6 )
                  {
                    if ( v22 != 5 )
                    {
                      if ( v22 != 4 )
                      {
                        if ( v22 != 3 )
                        {
                          if ( v22 != 2 )
                          {
                            if ( v22 != 1 )
                            {
                              if ( v22 )
                                goto LABEL_40;
                              v30 = _mm_load_si128(v17);
                              v31 = (unsigned int)_mm_movemask_epi8(
                                                    _mm_sub_epi8(
                                                      _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 15), v30),
                                                      _mm_cmpeq_epi8((__m128i)0LL, v30))) >> v15;
                              v26 = (0xFFFFu >> v15) - v31;
                              v23 = 0xFFFFu >> v15 == v31;
                              v27 = v15 - 15;
                              if ( !v23 )
                                goto LABEL_196;
                              v32 = _mm_load_si128(v18);
                              v33 = 0LL;
                              v15 = 16;
                              v19 |= 1u;
                              v34 = (((_WORD)v18 + 1) & 0xFFF) - 4096;
                              while ( 1 )
                              {
                                v2 = (v34 + 16 < 0) ^ __OFADD__(16, v34) | (v34 == -16);
                                v34 += 16;
                                if ( !v2 )
                                  goto LABEL_51;
                                while ( 1 )
                                {
                                  v35 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                                  v36 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                                  v33 = _mm_cmpeq_epi8(v33, v35);
                                  v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v35, _mm_alignr_epi8(v36, v32, 1)), v33))
                                      - 0xFFFF;
                                  if ( v26 )
                                    goto LABEL_195;
                                  v15 += 16;
                                  v32 = v36;
                                  v2 = (v34 + 16 < 0) ^ __OFADD__(16, v34) | (v34 == -16);
                                  v34 += 16;
                                  if ( v2 )
                                    break;
LABEL_51:
                                  v39 = _mm_cmpeq_epi8(v33, v32);
                                  if ( (_mm_movemask_epi8(v39) & 0xFFFE) != 0 )
                                  {
                                    v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                                    v41 = _mm_srli_si128(v39, 1);
                                    v42 = _mm_srli_si128(v32, 1);
                                    goto LABEL_194;
                                  }
                                  v33 = 0LL;
                                  v34 -= 4096;
                                }
                                v37 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                                v38 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                                v33 = _mm_cmpeq_epi8(v33, v37);
                                v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v37, _mm_alignr_epi8(v38, v32, 1)), v33))
                                    - 0xFFFF;
                                if ( v26 )
                                  goto LABEL_195;
                                v15 += 16;
                                v32 = v38;
                              }
                            }
                            v43 = _mm_load_si128(v17);
                            v44 = (unsigned int)_mm_movemask_epi8(
                                                  _mm_sub_epi8(
                                                    _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 14), v43),
                                                    _mm_cmpeq_epi8((__m128i)0LL, v43))) >> v15;
                            v26 = (0xFFFFu >> v15) - v44;
                            v23 = 0xFFFFu >> v15 == v44;
                            v27 = v15 - 14;
                            if ( !v23 )
                              goto LABEL_196;
                            v45 = _mm_load_si128(v18);
                            v46 = 0LL;
                            v15 = 16;
                            v19 |= 2u;
                            v47 = (((_WORD)v18 + 2) & 0xFFF) - 4096;
                            while ( 1 )
                            {
                              v2 = (v47 + 16 < 0) ^ __OFADD__(16, v47) | (v47 == -16);
                              v47 += 16;
                              if ( !v2 )
                                goto LABEL_61;
                              while ( 1 )
                              {
                                v48 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                                v49 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                                v46 = _mm_cmpeq_epi8(v46, v48);
                                v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v48, _mm_alignr_epi8(v49, v45, 2)), v46))
                                    - 0xFFFF;
                                if ( v26 )
                                  goto LABEL_195;
                                v15 += 16;
                                v45 = v49;
                                v2 = (v47 + 16 < 0) ^ __OFADD__(16, v47) | (v47 == -16);
                                v47 += 16;
                                if ( v2 )
                                  break;
LABEL_61:
                                v52 = _mm_cmpeq_epi8(v46, v45);
                                if ( (_mm_movemask_epi8(v52) & 0xFFFC) != 0 )
                                {
                                  v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                                  v41 = _mm_srli_si128(v52, 2);
                                  v42 = _mm_srli_si128(v45, 2);
                                  goto LABEL_194;
                                }
                                v46 = 0LL;
                                v47 -= 4096;
                              }
                              v50 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                              v51 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                              v46 = _mm_cmpeq_epi8(v46, v50);
                              v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v50, _mm_alignr_epi8(v51, v45, 2)), v46))
                                  - 0xFFFF;
                              if ( v26 )
                                goto LABEL_195;
                              v15 += 16;
                              v45 = v51;
                            }
                          }
                          v53 = _mm_load_si128(v17);
                          v54 = (unsigned int)_mm_movemask_epi8(
                                                _mm_sub_epi8(
                                                  _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 13), v53),
                                                  _mm_cmpeq_epi8((__m128i)0LL, v53))) >> v15;
                          v26 = (0xFFFFu >> v15) - v54;
                          v23 = 0xFFFFu >> v15 == v54;
                          v27 = v15 - 13;
                          if ( !v23 )
                            goto LABEL_196;
                          v55 = _mm_load_si128(v18);
                          v56 = 0LL;
                          v15 = 16;
                          v19 |= 3u;
                          v57 = (((_WORD)v18 + 3) & 0xFFF) - 4096;
                          while ( 1 )
                          {
                            v2 = (v57 + 16 < 0) ^ __OFADD__(16, v57) | (v57 == -16);
                            v57 += 16;
                            if ( !v2 )
                              goto LABEL_71;
                            while ( 1 )
                            {
                              v58 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                              v59 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                              v56 = _mm_cmpeq_epi8(v56, v58);
                              v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v58, _mm_alignr_epi8(v59, v55, 3)), v56))
                                  - 0xFFFF;
                              if ( v26 )
                                goto LABEL_195;
                              v15 += 16;
                              v55 = v59;
                              v2 = (v57 + 16 < 0) ^ __OFADD__(16, v57) | (v57 == -16);
                              v57 += 16;
                              if ( v2 )
                                break;
LABEL_71:
                              v62 = _mm_cmpeq_epi8(v56, v55);
                              if ( (_mm_movemask_epi8(v62) & 0xFFF8) != 0 )
                              {
                                v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                                v41 = _mm_srli_si128(v62, 3);
                                v42 = _mm_srli_si128(v55, 3);
                                goto LABEL_194;
                              }
                              v56 = 0LL;
                              v57 -= 4096;
                            }
                            v60 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                            v61 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                            v56 = _mm_cmpeq_epi8(v56, v60);
                            v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v60, _mm_alignr_epi8(v61, v55, 3)), v56))
                                - 0xFFFF;
                            if ( v26 )
                              goto LABEL_195;
                            v15 += 16;
                            v55 = v61;
                          }
                        }
                        v63 = _mm_load_si128(v17);
                        v64 = (unsigned int)_mm_movemask_epi8(
                                              _mm_sub_epi8(
                                                _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 12), v63),
                                                _mm_cmpeq_epi8((__m128i)0LL, v63))) >> v15;
                        v26 = (0xFFFFu >> v15) - v64;
                        v23 = 0xFFFFu >> v15 == v64;
                        v27 = v15 - 12;
                        if ( !v23 )
                          goto LABEL_196;
                        v65 = _mm_load_si128(v18);
                        v66 = 0LL;
                        v15 = 16;
                        v19 |= 4u;
                        v67 = (((_WORD)v18 + 4) & 0xFFF) - 4096;
                        while ( 1 )
                        {
                          v2 = (v67 + 16 < 0) ^ __OFADD__(16, v67) | (v67 == -16);
                          v67 += 16;
                          if ( !v2 )
                            goto LABEL_81;
                          while ( 1 )
                          {
                            v68 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                            v69 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                            v66 = _mm_cmpeq_epi8(v66, v68);
                            v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v68, _mm_alignr_epi8(v69, v65, 4)), v66))
                                - 0xFFFF;
                            if ( v26 )
                              goto LABEL_195;
                            v15 += 16;
                            v65 = v69;
                            v2 = (v67 + 16 < 0) ^ __OFADD__(16, v67) | (v67 == -16);
                            v67 += 16;
                            if ( v2 )
                              break;
LABEL_81:
                            v72 = _mm_cmpeq_epi8(v66, v65);
                            if ( (_mm_movemask_epi8(v72) & 0xFFF0) != 0 )
                            {
                              v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                              v41 = _mm_srli_si128(v72, 4);
                              v42 = _mm_srli_si128(v65, 4);
                              goto LABEL_194;
                            }
                            v66 = 0LL;
                            v67 -= 4096;
                          }
                          v70 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                          v71 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                          v66 = _mm_cmpeq_epi8(v66, v70);
                          v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v70, _mm_alignr_epi8(v71, v65, 4)), v66))
                              - 0xFFFF;
                          if ( v26 )
                            goto LABEL_195;
                          v15 += 16;
                          v65 = v71;
                        }
                      }
                      v73 = _mm_load_si128(v17);
                      v74 = (unsigned int)_mm_movemask_epi8(
                                            _mm_sub_epi8(
                                              _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 11), v73),
                                              _mm_cmpeq_epi8((__m128i)0LL, v73))) >> v15;
                      v26 = (0xFFFFu >> v15) - v74;
                      v23 = 0xFFFFu >> v15 == v74;
                      v27 = v15 - 11;
                      if ( !v23 )
                        goto LABEL_196;
                      v75 = _mm_load_si128(v18);
                      v76 = 0LL;
                      v15 = 16;
                      v19 |= 5u;
                      v77 = (((_WORD)v18 + 5) & 0xFFF) - 4096;
                      while ( 1 )
                      {
                        v2 = (v77 + 16 < 0) ^ __OFADD__(16, v77) | (v77 == -16);
                        v77 += 16;
                        if ( !v2 )
                          goto LABEL_91;
                        while ( 1 )
                        {
                          v78 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                          v79 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                          v76 = _mm_cmpeq_epi8(v76, v78);
                          v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v78, _mm_alignr_epi8(v79, v75, 5)), v76))
                              - 0xFFFF;
                          if ( v26 )
                            goto LABEL_195;
                          v15 += 16;
                          v75 = v79;
                          v2 = (v77 + 16 < 0) ^ __OFADD__(16, v77) | (v77 == -16);
                          v77 += 16;
                          if ( v2 )
                            break;
LABEL_91:
                          v82 = _mm_cmpeq_epi8(v76, v75);
                          if ( (_mm_movemask_epi8(v82) & 0xFFE0) != 0 )
                          {
                            v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                            v41 = _mm_srli_si128(v82, 5);
                            v42 = _mm_srli_si128(v75, 5);
                            goto LABEL_194;
                          }
                          v76 = 0LL;
                          v77 -= 4096;
                        }
                        v80 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                        v81 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                        v76 = _mm_cmpeq_epi8(v76, v80);
                        v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v80, _mm_alignr_epi8(v81, v75, 5)), v76))
                            - 0xFFFF;
                        if ( v26 )
                          goto LABEL_195;
                        v15 += 16;
                        v75 = v81;
                      }
                    }
                    v83 = _mm_load_si128(v17);
                    v84 = (unsigned int)_mm_movemask_epi8(
                                          _mm_sub_epi8(
                                            _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 10), v83),
                                            _mm_cmpeq_epi8((__m128i)0LL, v83))) >> v15;
                    v26 = (0xFFFFu >> v15) - v84;
                    v23 = 0xFFFFu >> v15 == v84;
                    v27 = v15 - 10;
                    if ( !v23 )
                      goto LABEL_196;
                    v85 = _mm_load_si128(v18);
                    v86 = 0LL;
                    v15 = 16;
                    v19 |= 6u;
                    v87 = (((_WORD)v18 + 6) & 0xFFF) - 4096;
                    while ( 1 )
                    {
                      v2 = (v87 + 16 < 0) ^ __OFADD__(16, v87) | (v87 == -16);
                      v87 += 16;
                      if ( !v2 )
                        goto LABEL_101;
                      while ( 1 )
                      {
                        v88 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                        v89 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                        v86 = _mm_cmpeq_epi8(v86, v88);
                        v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v88, _mm_alignr_epi8(v89, v85, 6)), v86))
                            - 0xFFFF;
                        if ( v26 )
                          goto LABEL_195;
                        v15 += 16;
                        v85 = v89;
                        v2 = (v87 + 16 < 0) ^ __OFADD__(16, v87) | (v87 == -16);
                        v87 += 16;
                        if ( v2 )
                          break;
LABEL_101:
                        v92 = _mm_cmpeq_epi8(v86, v85);
                        if ( (_mm_movemask_epi8(v92) & 0xFFC0) != 0 )
                        {
                          v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                          v41 = _mm_srli_si128(v92, 6);
                          v42 = _mm_srli_si128(v85, 6);
                          goto LABEL_194;
                        }
                        v86 = 0LL;
                        v87 -= 4096;
                      }
                      v90 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                      v91 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                      v86 = _mm_cmpeq_epi8(v86, v90);
                      v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v90, _mm_alignr_epi8(v91, v85, 6)), v86))
                          - 0xFFFF;
                      if ( v26 )
                        goto LABEL_195;
                      v15 += 16;
                      v85 = v91;
                    }
                  }
                  v93 = _mm_load_si128(v17);
                  v94 = (unsigned int)_mm_movemask_epi8(
                                        _mm_sub_epi8(
                                          _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 9), v93),
                                          _mm_cmpeq_epi8((__m128i)0LL, v93))) >> v15;
                  v26 = (0xFFFFu >> v15) - v94;
                  v23 = 0xFFFFu >> v15 == v94;
                  v27 = v15 - 9;
                  if ( !v23 )
                    goto LABEL_196;
                  v95 = _mm_load_si128(v18);
                  v96 = 0LL;
                  v15 = 16;
                  v19 |= 7u;
                  v97 = (((_WORD)v18 + 8) & 0xFFF) - 4096;
                  while ( 1 )
                  {
                    v2 = (v97 + 16 < 0) ^ __OFADD__(16, v97) | (v97 == -16);
                    v97 += 16;
                    if ( !v2 )
                      goto LABEL_111;
                    while ( 1 )
                    {
                      v98 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                      v99 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                      v96 = _mm_cmpeq_epi8(v96, v98);
                      v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v98, _mm_alignr_epi8(v99, v95, 7)), v96))
                          - 0xFFFF;
                      if ( v26 )
                        goto LABEL_195;
                      v15 += 16;
                      v95 = v99;
                      v2 = (v97 + 16 < 0) ^ __OFADD__(16, v97) | (v97 == -16);
                      v97 += 16;
                      if ( v2 )
                        break;
LABEL_111:
                      v102 = _mm_cmpeq_epi8(v96, v95);
                      if ( (_mm_movemask_epi8(v102) & 0xFF80) != 0 )
                      {
                        v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                        v41 = _mm_srli_si128(v102, 7);
                        v42 = _mm_srli_si128(v95, 7);
                        goto LABEL_194;
                      }
                      v96 = 0LL;
                      v97 -= 4096;
                    }
                    v100 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                    v101 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                    v96 = _mm_cmpeq_epi8(v96, v100);
                    v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v100, _mm_alignr_epi8(v101, v95, 7)), v96))
                        - 0xFFFF;
                    if ( v26 )
                      goto LABEL_195;
                    v15 += 16;
                    v95 = v101;
                  }
                }
                v103 = _mm_load_si128(v17);
                v104 = (unsigned int)_mm_movemask_epi8(
                                       _mm_sub_epi8(
                                         _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 8), v103),
                                         _mm_cmpeq_epi8((__m128i)0LL, v103))) >> v15;
                v26 = (0xFFFFu >> v15) - v104;
                v23 = 0xFFFFu >> v15 == v104;
                v27 = v15 - 8;
                if ( !v23 )
                  goto LABEL_196;
                v105 = _mm_load_si128(v18);
                v106 = 0LL;
                v15 = 16;
                v19 |= 8u;
                v107 = (((_WORD)v18 + 8) & 0xFFF) - 4096;
                while ( 1 )
                {
                  v2 = (v107 + 16 < 0) ^ __OFADD__(16, v107) | (v107 == -16);
                  v107 += 16;
                  if ( !v2 )
                    goto LABEL_121;
                  while ( 1 )
                  {
                    v108 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                    v109 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                    v106 = _mm_cmpeq_epi8(v106, v108);
                    v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v108, _mm_alignr_epi8(v109, v105, 8)), v106))
                        - 0xFFFF;
                    if ( v26 )
                      goto LABEL_195;
                    v15 += 16;
                    v105 = v109;
                    v2 = (v107 + 16 < 0) ^ __OFADD__(16, v107) | (v107 == -16);
                    v107 += 16;
                    if ( v2 )
                      break;
LABEL_121:
                    v112 = _mm_cmpeq_epi8(v106, v105);
                    if ( (_mm_movemask_epi8(v112) & 0xFF00) != 0 )
                    {
                      v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                      v41 = _mm_srli_si128(v112, 8);
                      v42 = _mm_srli_si128(v105, 8);
                      goto LABEL_194;
                    }
                    v106 = 0LL;
                    v107 -= 4096;
                  }
                  v110 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                  v111 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                  v106 = _mm_cmpeq_epi8(v106, v110);
                  v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v110, _mm_alignr_epi8(v111, v105, 8)), v106))
                      - 0xFFFF;
                  if ( v26 )
                    goto LABEL_195;
                  v15 += 16;
                  v105 = v111;
                }
              }
              v113 = _mm_load_si128(v17);
              v114 = (unsigned int)_mm_movemask_epi8(
                                     _mm_sub_epi8(
                                       _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 7), v113),
                                       _mm_cmpeq_epi8((__m128i)0LL, v113))) >> v15;
              v26 = (0xFFFFu >> v15) - v114;
              v23 = 0xFFFFu >> v15 == v114;
              v27 = v15 - 7;
              if ( !v23 )
                goto LABEL_196;
              v115 = _mm_load_si128(v18);
              v116 = 0LL;
              v15 = 16;
              v19 |= 9u;
              v117 = (((_WORD)v18 + 9) & 0xFFF) - 4096;
              while ( 1 )
              {
                v2 = (v117 + 16 < 0) ^ __OFADD__(16, v117) | (v117 == -16);
                v117 += 16;
                if ( !v2 )
                  goto LABEL_131;
                while ( 1 )
                {
                  v118 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                  v119 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                  v116 = _mm_cmpeq_epi8(v116, v118);
                  v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v118, _mm_alignr_epi8(v119, v115, 9)), v116))
                      - 0xFFFF;
                  if ( v26 )
                    goto LABEL_195;
                  v15 += 16;
                  v115 = v119;
                  v2 = (v117 + 16 < 0) ^ __OFADD__(16, v117) | (v117 == -16);
                  v117 += 16;
                  if ( v2 )
                    break;
LABEL_131:
                  v122 = _mm_cmpeq_epi8(v116, v115);
                  if ( (_mm_movemask_epi8(v122) & 0xFE00) != 0 )
                  {
                    v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                    v41 = _mm_srli_si128(v122, 9);
                    v42 = _mm_srli_si128(v115, 9);
                    goto LABEL_194;
                  }
                  v116 = 0LL;
                  v117 -= 4096;
                }
                v120 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                v121 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                v116 = _mm_cmpeq_epi8(v116, v120);
                v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v120, _mm_alignr_epi8(v121, v115, 9)), v116))
                    - 0xFFFF;
                if ( v26 )
                  goto LABEL_195;
                v15 += 16;
                v115 = v121;
              }
            }
            v123 = _mm_load_si128(v17);
            v124 = (unsigned int)_mm_movemask_epi8(
                                   _mm_sub_epi8(
                                     _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 6), v123),
                                     _mm_cmpeq_epi8((__m128i)0LL, v123))) >> v15;
            v26 = (0xFFFFu >> v15) - v124;
            v23 = 0xFFFFu >> v15 == v124;
            v27 = v15 - 6;
            if ( !v23 )
              goto LABEL_196;
            v125 = _mm_load_si128(v18);
            v126 = 0LL;
            v15 = 16;
            v19 |= 0xAu;
            v127 = (((_WORD)v18 + 10) & 0xFFF) - 4096;
            while ( 1 )
            {
              v2 = (v127 + 16 < 0) ^ __OFADD__(16, v127) | (v127 == -16);
              v127 += 16;
              if ( !v2 )
                goto LABEL_141;
              while ( 1 )
              {
                v128 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                v129 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                v126 = _mm_cmpeq_epi8(v126, v128);
                v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v128, _mm_alignr_epi8(v129, v125, 10)), v126))
                    - 0xFFFF;
                if ( v26 )
                  goto LABEL_195;
                v15 += 16;
                v125 = v129;
                v2 = (v127 + 16 < 0) ^ __OFADD__(16, v127) | (v127 == -16);
                v127 += 16;
                if ( v2 )
                  break;
LABEL_141:
                v132 = _mm_cmpeq_epi8(v126, v125);
                if ( (_mm_movemask_epi8(v132) & 0xFC00) != 0 )
                {
                  v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                  v41 = _mm_srli_si128(v132, 10);
                  v42 = _mm_srli_si128(v125, 10);
                  goto LABEL_194;
                }
                v126 = 0LL;
                v127 -= 4096;
              }
              v130 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
              v131 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
              v126 = _mm_cmpeq_epi8(v126, v130);
              v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v130, _mm_alignr_epi8(v131, v125, 10)), v126))
                  - 0xFFFF;
              if ( v26 )
                goto LABEL_195;
              v15 += 16;
              v125 = v131;
            }
          }
          v133 = _mm_load_si128(v17);
          v134 = (unsigned int)_mm_movemask_epi8(
                                 _mm_sub_epi8(
                                   _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 5), v133),
                                   _mm_cmpeq_epi8((__m128i)0LL, v133))) >> v15;
          v26 = (0xFFFFu >> v15) - v134;
          v23 = 0xFFFFu >> v15 == v134;
          v27 = v15 - 5;
          if ( !v23 )
            goto LABEL_196;
          v135 = _mm_load_si128(v18);
          v136 = 0LL;
          v15 = 16;
          v19 |= 0xBu;
          v137 = (((_WORD)v18 + 11) & 0xFFF) - 4096;
          while ( 1 )
          {
            v2 = (v137 + 16 < 0) ^ __OFADD__(16, v137) | (v137 == -16);
            v137 += 16;
            if ( !v2 )
              goto LABEL_151;
            while ( 1 )
            {
              v138 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
              v139 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
              v136 = _mm_cmpeq_epi8(v136, v138);
              v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v138, _mm_alignr_epi8(v139, v135, 11)), v136))
                  - 0xFFFF;
              if ( v26 )
                goto LABEL_195;
              v15 += 16;
              v135 = v139;
              v2 = (v137 + 16 < 0) ^ __OFADD__(16, v137) | (v137 == -16);
              v137 += 16;
              if ( v2 )
                break;
LABEL_151:
              v142 = _mm_cmpeq_epi8(v136, v135);
              if ( (_mm_movemask_epi8(v142) & 0xF800) != 0 )
              {
                v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                v41 = _mm_srli_si128(v142, 11);
                v42 = _mm_srli_si128(v135, 11);
                goto LABEL_194;
              }
              v136 = 0LL;
              v137 -= 4096;
            }
            v140 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
            v141 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
            v136 = _mm_cmpeq_epi8(v136, v140);
            v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v140, _mm_alignr_epi8(v141, v135, 11)), v136)) - 0xFFFF;
            if ( v26 )
              goto LABEL_195;
            v15 += 16;
            v135 = v141;
          }
        }
        v143 = _mm_load_si128(v17);
        v144 = (unsigned int)_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 4), v143),
                                 _mm_cmpeq_epi8((__m128i)0LL, v143))) >> v15;
        v26 = (0xFFFFu >> v15) - v144;
        v23 = 0xFFFFu >> v15 == v144;
        v27 = v15 - 4;
        if ( !v23 )
          goto LABEL_196;
        v145 = _mm_load_si128(v18);
        v146 = 0LL;
        v15 = 16;
        v19 |= 0xCu;
        v147 = (((_WORD)v18 + 12) & 0xFFF) - 4096;
        while ( 1 )
        {
          v2 = (v147 + 16 < 0) ^ __OFADD__(16, v147) | (v147 == -16);
          v147 += 16;
          if ( !v2 )
            goto LABEL_161;
          while ( 1 )
          {
            v148 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
            v149 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
            v146 = _mm_cmpeq_epi8(v146, v148);
            v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v148, _mm_alignr_epi8(v149, v145, 12)), v146)) - 0xFFFF;
            if ( v26 )
              goto LABEL_195;
            v15 += 16;
            v145 = v149;
            v2 = (v147 + 16 < 0) ^ __OFADD__(16, v147) | (v147 == -16);
            v147 += 16;
            if ( v2 )
              break;
LABEL_161:
            v152 = _mm_cmpeq_epi8(v146, v145);
            if ( (_mm_movemask_epi8(v152) & 0xF000) != 0 )
            {
              v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
              v41 = _mm_srli_si128(v152, 12);
              v42 = _mm_srli_si128(v145, 12);
              goto LABEL_194;
            }
            v146 = 0LL;
            v147 -= 4096;
          }
          v150 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
          v151 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
          v146 = _mm_cmpeq_epi8(v146, v150);
          v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v150, _mm_alignr_epi8(v151, v145, 12)), v146)) - 0xFFFF;
          if ( v26 )
            goto LABEL_195;
          v15 += 16;
          v145 = v151;
        }
      }
      v153 = _mm_load_si128(v17);
      v154 = (unsigned int)_mm_movemask_epi8(
                             _mm_sub_epi8(
                               _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 3), v153),
                               _mm_cmpeq_epi8((__m128i)0LL, v153))) >> v15;
      v26 = (0xFFFFu >> v15) - v154;
      v23 = 0xFFFFu >> v15 == v154;
      v27 = v15 - 3;
      if ( !v23 )
        goto LABEL_196;
      v155 = _mm_load_si128(v18);
      v156 = 0LL;
      v15 = 16;
      v19 |= 0xDu;
      v157 = (((_WORD)v18 + 13) & 0xFFF) - 4096;
      while ( 1 )
      {
        v2 = (v157 + 16 < 0) ^ __OFADD__(16, v157) | (v157 == -16);
        v157 += 16;
        if ( !v2 )
          goto LABEL_171;
        while ( 1 )
        {
          v158 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
          v159 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
          v156 = _mm_cmpeq_epi8(v156, v158);
          v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v158, _mm_alignr_epi8(v159, v155, 13)), v156)) - 0xFFFF;
          if ( v26 )
            goto LABEL_195;
          v15 += 16;
          v155 = v159;
          v2 = (v157 + 16 < 0) ^ __OFADD__(16, v157) | (v157 == -16);
          v157 += 16;
          if ( v2 )
            break;
LABEL_171:
          v162 = _mm_cmpeq_epi8(v156, v155);
          if ( (_mm_movemask_epi8(v162) & 0xE000) != 0 )
          {
            v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
            v41 = _mm_srli_si128(v162, 13);
            v42 = _mm_srli_si128(v155, 13);
            goto LABEL_194;
          }
          v156 = 0LL;
          v157 -= 4096;
        }
        v160 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
        v161 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
        v156 = _mm_cmpeq_epi8(v156, v160);
        v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v160, _mm_alignr_epi8(v161, v155, 13)), v156)) - 0xFFFF;
        if ( v26 )
          goto LABEL_195;
        v15 += 16;
        v155 = v161;
      }
    }
    v163 = _mm_load_si128(v17);
    v164 = (unsigned int)_mm_movemask_epi8(
                           _mm_sub_epi8(
                             _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 2), v163),
                             _mm_cmpeq_epi8((__m128i)0LL, v163))) >> v15;
    v26 = (0xFFFFu >> v15) - v164;
    v23 = 0xFFFFu >> v15 == v164;
    v27 = v15 - 2;
    if ( !v23 )
      goto LABEL_196;
    v165 = _mm_load_si128(v18);
    v166 = 0LL;
    v15 = 16;
    v19 |= 0xEu;
    v167 = (((_WORD)v18 + 14) & 0xFFF) - 4096;
    while ( 1 )
    {
      v2 = (v167 + 16 < 0) ^ __OFADD__(16, v167) | (v167 == -16);
      v167 += 16;
      if ( !v2 )
        goto LABEL_181;
      while ( 1 )
      {
        v168 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
        v169 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
        v166 = _mm_cmpeq_epi8(v166, v168);
        v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v168, _mm_alignr_epi8(v169, v165, 14)), v166)) - 0xFFFF;
        if ( v26 )
          goto LABEL_195;
        v15 += 16;
        v165 = v169;
        v2 = (v167 + 16 < 0) ^ __OFADD__(16, v167) | (v167 == -16);
        v167 += 16;
        if ( v2 )
          break;
LABEL_181:
        v172 = _mm_cmpeq_epi8(v166, v165);
        if ( (_mm_movemask_epi8(v172) & 0xC000) != 0 )
        {
          v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
          v41 = _mm_srli_si128(v172, 14);
          v42 = _mm_srli_si128(v165, 14);
          goto LABEL_194;
        }
        v166 = 0LL;
        v167 -= 4096;
      }
      v170 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
      v171 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
      v166 = _mm_cmpeq_epi8(v166, v170);
      v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v170, _mm_alignr_epi8(v171, v165, 14)), v166)) - 0xFFFF;
      if ( v26 )
        goto LABEL_195;
      v15 += 16;
      v165 = v171;
    }
  }
  v173 = _mm_load_si128(v17);
  v174 = (unsigned int)_mm_movemask_epi8(
                         _mm_sub_epi8(
                           _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 1), v173),
                           _mm_cmpeq_epi8((__m128i)0LL, v173))) >> v15;
  v26 = (0xFFFFu >> v15) - v174;
  v23 = 0xFFFFu >> v15 == v174;
  v27 = v15 - 1;
  if ( !v23 )
    goto LABEL_196;
  v175 = _mm_load_si128(v18);
  v176 = 0LL;
  v15 = 16;
  v19 |= 0xFu;
  v177 = (((_WORD)v18 + 15) & 0xFFF) - 4096;
LABEL_186:
  v2 = (v177 + 16 < 0) ^ __OFADD__(16, v177) | (v177 == -16);
  v177 += 16;
  if ( !v2 )
    goto LABEL_191;
  while ( 1 )
  {
    v178 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
    v179 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
    v176 = _mm_cmpeq_epi8(v176, v178);
    v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v178, _mm_alignr_epi8(v179, v175, 15)), v176)) - 0xFFFF;
    if ( v26 )
      goto LABEL_195;
    v15 += 16;
    v175 = v179;
    v2 = (v177 + 16 < 0) ^ __OFADD__(16, v177) | (v177 == -16);
    v177 += 16;
    if ( v2 )
    {
      v180 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
      v181 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
      v176 = _mm_cmpeq_epi8(v176, v180);
      v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v180, _mm_alignr_epi8(v181, v175, 15)), v176)) - 0xFFFF;
      if ( v26 )
        goto LABEL_195;
      v15 += 16;
      v175 = v181;
      goto LABEL_186;
    }
LABEL_191:
    v182 = _mm_cmpeq_epi8(v176, v175);
    if ( (_mm_movemask_epi8(v182) & 0x8000) != 0 )
      break;
    v176 = 0LL;
    v177 -= 4096;
  }
  v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
  v41 = _mm_srli_si128(v182, 15);
  v42 = _mm_srli_si128(v175, 15);
LABEL_194:
  v26 = ~_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v40, v42), v41));
LABEL_195:
  v27 = (v19 & 0x1F) + v15 - 16;
LABEL_196:
  v10 = (int)v18->m128i_i32 + v27;
  v11 = (int)v17->m128i_i32 + v15;
  if ( (v19 & 0x20) != 0 )
  {
    v183 = v11;
    v11 = v10;
    v10 = v183;
  }
  LOWORD(v14) = v26;
LABEL_199:
  if ( (_BYTE)v14 )
  {
    if ( (v14 & 1) == 0 )
    {
      if ( (v14 & 2) == 0 )
      {
        if ( (v14 & 4) == 0 )
        {
          if ( (v14 & 8) == 0 )
          {
            if ( (v14 & 0x10) == 0 )
            {
              if ( (v14 & 0x20) == 0 )
              {
                if ( (v14 & 0x40) == 0 )
                  return *(unsigned __int8 *)(v10 + 7) - *(unsigned __int8 *)(v11 + 7);
                return *(unsigned __int8 *)(v10 + 6) - *(unsigned __int8 *)(v11 + 6);
              }
              return *(unsigned __int8 *)(v10 + 5) - *(unsigned __int8 *)(v11 + 5);
            }
            return *(unsigned __int8 *)(v10 + 4) - *(unsigned __int8 *)(v11 + 4);
          }
          return *(unsigned __int8 *)(v10 + 3) - *(unsigned __int8 *)(v11 + 3);
        }
        return *(unsigned __int8 *)(v10 + 2) - *(unsigned __int8 *)(v11 + 2);
      }
      return *(unsigned __int8 *)(v10 + 1) - *(unsigned __int8 *)(v11 + 1);
    }
    return *(unsigned __int8 *)v10 - *(unsigned __int8 *)v11;
  }
  v11 += 8;
  v10 += 8;
  if ( (v14 & 0x100) != 0 )
    return *(unsigned __int8 *)v10 - *(unsigned __int8 *)v11;
  if ( (v14 & 0x200) != 0 )
    return *(unsigned __int8 *)(v10 + 1) - *(unsigned __int8 *)(v11 + 1);
  if ( (v14 & 0x400) != 0 )
    return *(unsigned __int8 *)(v10 + 2) - *(unsigned __int8 *)(v11 + 2);
  if ( (v14 & 0x800) != 0 )
    return *(unsigned __int8 *)(v10 + 3) - *(unsigned __int8 *)(v11 + 3);
  if ( (v14 & 0x1000) != 0 )
    return *(unsigned __int8 *)(v10 + 4) - *(unsigned __int8 *)(v11 + 4);
  if ( (v14 & 0x2000) != 0 )
    return *(unsigned __int8 *)(v10 + 5) - *(unsigned __int8 *)(v11 + 5);
  if ( (v14 & 0x4000) != 0 )
    return *(unsigned __int8 *)(v10 + 6) - *(unsigned __int8 *)(v11 + 6);
  return *(unsigned __int8 *)(v10 + 7) - *(unsigned __int8 *)(v11 + 7);
}

//----- (08062650) --------------------------------------------------------
int __cdecl _strcmp_sse4_2(const __m128i *a1, const __m128i *a2)
{
  const __m128i *v2; // edx
  const __m128i *v3; // eax
  __m128i v4; // xmm2
  int v5; // ecx
  char v6; // cc
  unsigned __int8 v7; // cl
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // cl
  unsigned __int8 v10; // cl
  unsigned __int8 v11; // cl
  unsigned __int8 v12; // cl
  unsigned __int8 v13; // cl
  __int32 *v14; // edi
  __int32 *v15; // esi
  int result; // eax
  int v17; // ecx
  int v18; // edx
  int v19; // edi
  int v20; // esi
  __m128i v21; // xmm2
  __m128i v22; // xmm1
  bool v23; // cf
  int v24; // ecx
  int v25; // ecx
  __int32 v26; // ecx
  __int32 v27; // ecx
  unsigned __int8 v28; // cl
  unsigned __int8 v29; // cl
  unsigned __int8 v30; // cl
  unsigned __int8 v31; // cl
  unsigned __int8 v32; // cl
  unsigned __int8 v33; // cl
  unsigned __int8 v34; // cl

  v2 = a1;
  v3 = a2;
  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFF0 )
  {
    v4 = _mm_loadu_si128(a1);
    if ( ((unsigned __int16)a2 & 0xFFFu) <= 0xFF0 )
    {
      v5 = _mm_cvtsi128_si32(v4);
      if ( v5 == a2->m128i_i32[0] )
      {
        if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(a2), v4))
          && _mm_testc_si128((__m128i)0LL, _mm_cmpeq_epi8(v4, (__m128i)0LL)) )
        {
          v2 = a1 + 1;
          v3 = a2 + 1;
          goto LABEL_7;
        }
        v23 = __CFADD__(v5, -16843009);
        v25 = v5 - 16843009;
        if ( v23 && (a1->m128i_i32[0] ^ v25 | 0xFEFEFEFF) == -1 )
        {
          v26 = a1->m128i_i32[1];
          if ( v26 != a2->m128i_i32[1] )
            goto LABEL_54;
          v23 = __CFADD__(v26, -16843009);
          v27 = v26 - 16843009;
          if ( !v23 || (a1->m128i_i32[1] ^ v27 | 0xFEFEFEFF) != -1 )
            goto LABEL_54;
          v2 = (const __m128i *)&a1->m128i_i8[8];
          v3 = (const __m128i *)&a2->m128i_i8[8];
        }
      }
      v6 = v2->m128i_i8[0] <= (unsigned int)v3->m128i_i8[0];
      if ( v2->m128i_i8[0] != v3->m128i_i8[0] )
        goto LABEL_37;
      if ( !v3->m128i_i8[0] )
        return 0;
      v28 = v3->m128i_u8[1];
      v6 = (unsigned int)v2->m128i_i8[1] <= v28;
      if ( v2->m128i_i8[1] != v28 )
        goto LABEL_37;
      if ( !v3->m128i_i8[1] )
        return 0;
      v29 = v3->m128i_u8[2];
      v6 = (unsigned int)v2->m128i_i8[2] <= v29;
      if ( v2->m128i_i8[2] != v29 )
        goto LABEL_37;
      if ( !v3->m128i_i8[2] )
        return 0;
      v30 = v3->m128i_u8[3];
      v6 = (unsigned int)v2->m128i_i8[3] <= v30;
      if ( v2->m128i_i8[3] != v30 )
        goto LABEL_37;
      if ( !v3->m128i_i8[3] )
        return 0;
LABEL_54:
      v31 = v3->m128i_u8[4];
      v6 = (unsigned int)v2->m128i_i8[4] <= v31;
      if ( v2->m128i_i8[4] == v31 )
      {
        if ( !v3->m128i_i8[4] )
          return 0;
        v32 = v3->m128i_u8[5];
        v6 = (unsigned int)v2->m128i_i8[5] <= v32;
        if ( v2->m128i_i8[5] == v32 )
        {
          if ( !v3->m128i_i8[5] )
            return 0;
          v33 = v3->m128i_u8[6];
          v6 = (unsigned int)v2->m128i_i8[6] <= v33;
          if ( v2->m128i_i8[6] == v33 )
          {
            if ( !v3->m128i_i8[6] )
              return 0;
            v34 = v3->m128i_u8[7];
            v6 = (unsigned int)v2->m128i_i8[7] <= v34;
            if ( v2->m128i_i8[7] == v34 )
              return 0;
          }
        }
      }
      goto LABEL_37;
    }
  }
LABEL_7:
  v6 = v2->m128i_i8[0] <= (unsigned int)v3->m128i_i8[0];
  if ( v2->m128i_i8[0] != v3->m128i_i8[0] )
    goto LABEL_37;
  if ( !v3->m128i_i8[0] )
    return 0;
  v7 = v3->m128i_u8[1];
  v6 = (unsigned int)v2->m128i_i8[1] <= v7;
  if ( v2->m128i_i8[1] != v7 )
    goto LABEL_37;
  if ( !v3->m128i_i8[1] )
    return 0;
  v8 = v3->m128i_u8[2];
  v6 = (unsigned int)v2->m128i_i8[2] <= v8;
  if ( v2->m128i_i8[2] != v8 )
    goto LABEL_37;
  if ( !v3->m128i_i8[2] )
    return 0;
  v9 = v3->m128i_u8[3];
  v6 = (unsigned int)v2->m128i_i8[3] <= v9;
  if ( v2->m128i_i8[3] != v9 )
    goto LABEL_37;
  if ( !v3->m128i_i8[3] )
    return 0;
  v10 = v3->m128i_u8[4];
  v6 = (unsigned int)v2->m128i_i8[4] <= v10;
  if ( v2->m128i_i8[4] != v10 )
    goto LABEL_37;
  if ( !v3->m128i_i8[4] )
    return 0;
  v11 = v3->m128i_u8[5];
  v6 = (unsigned int)v2->m128i_i8[5] <= v11;
  if ( v2->m128i_i8[5] != v11 )
    goto LABEL_37;
  if ( !v3->m128i_i8[5] )
    return 0;
  v12 = v3->m128i_u8[6];
  v6 = (unsigned int)v2->m128i_i8[6] <= v12;
  if ( v2->m128i_i8[6] != v12 )
    goto LABEL_37;
  if ( !v3->m128i_i8[6] )
    return 0;
  v13 = v3->m128i_u8[7];
  v6 = (unsigned int)v2->m128i_i8[7] <= v13;
  if ( v2->m128i_i8[7] != v13 )
  {
LABEL_37:
    result = 1;
    if ( v6 )
      return -1;
    return result;
  }
  if ( !v3->m128i_i8[7] )
    return 0;
  v14 = &v2->m128i_i32[2];
  v15 = &v3->m128i_i32[2];
  result = 0;
LABEL_24:
  v17 = (unsigned __int16)v15 & 0xFFF;
  if ( v17 < ((unsigned __int16)v14 & 0xFFF) )
    v17 = (unsigned __int16)v14 & 0xFFF;
  v18 = v17 - 4080;
  v19 = (int)v14 - v17 + 4080;
  v20 = (int)v15 - v17 + 4080;
  if ( v17 - 4080 > 0 )
  {
LABEL_29:
    while ( 1 )
    {
      result = *(unsigned __int8 *)(v19 + v18) - *(unsigned __int8 *)(v20 + v18);
      if ( result || !*(_BYTE *)(v20 + v18) )
        break;
      if ( ++v18 > 15 )
      {
        v14 = (__int32 *)(v18 + v19);
        v15 = (__int32 *)(v18 + v20);
        goto LABEL_24;
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v21 = _mm_loadu_si128((const __m128i *)(v20 + v18));
      v22 = _mm_loadu_si128((const __m128i *)(v19 + v18));
      v24 = _mm_cmpistri(v22, v21, 26);
      v23 = _mm_cmpistrc(v22, v21, 26);
      if ( v23 | _mm_cmpistrz(v22, v21, 26) )
        break;
      v6 = (v18 + 16 < 0) ^ __OFADD__(16, v18) | (v18 == -16);
      v18 += 16;
      if ( !v6 )
        goto LABEL_29;
    }
    if ( v23 )
      return *(unsigned __int8 *)(v19 + v24 + v18) - *(unsigned __int8 *)(v20 + v24 + v18);
  }
  return result;
}

//----- (080628E0) --------------------------------------------------------
int __cdecl strncmp(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  int v3; // edi
  unsigned __int8 *v4; // edx
  int v6; // eax
  unsigned __int8 v7; // bl
  int v8; // esi

  v3 = a3;
  v4 = a1;
  if ( a3 <= 3 )
  {
    v7 = 0;
    v6 = 0;
LABEL_13:
    if ( v3 )
    {
      v6 = *v4;
      v7 = *a2;
      if ( (_BYTE)v6 )
      {
        if ( v7 == (_BYTE)v6 )
        {
          v8 = 1;
          do
          {
            if ( v3 == v8 )
              break;
            v6 = v4[v8];
            v7 = a2[v8++];
            if ( !(_BYTE)v6 )
              break;
          }
          while ( (_BYTE)v6 == v7 );
        }
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v6 = *v4;
      v7 = *a2;
      if ( !(_BYTE)v6 )
        break;
      if ( (_BYTE)v6 != v7 )
        break;
      v6 = v4[1];
      v7 = a2[1];
      if ( !(_BYTE)v6 )
        break;
      if ( (_BYTE)v6 != v7 )
        break;
      v6 = v4[2];
      v7 = a2[2];
      if ( !(_BYTE)v6 )
        break;
      if ( (_BYTE)v6 != v7 )
        break;
      v4 += 4;
      v6 = *(v4 - 1);
      a2 += 4;
      v7 = *(a2 - 1);
      if ( !(_BYTE)v6 || (_BYTE)v6 != v7 )
        break;
      if ( &a1[a3 & 0xFFFFFFFC] == v4 )
      {
        v3 = a3 & 3;
        goto LABEL_13;
      }
    }
  }
  return v6 - v7;
}

//----- (08062990) --------------------------------------------------------
int __cdecl _memcmp_ssse3(const __m128i *a1, const __m128i *a2, unsigned int a3)
{
  unsigned int v3; // ecx
  int v4; // edx
  __int8 *v5; // eax
  int result; // eax
  unsigned int v7; // edi
  int v8; // edx
  const __m128i *v9; // esi
  int v10; // edx
  __m128i *v11; // esi
  unsigned int v12; // ecx
  unsigned int v13; // edx
  int v14; // eax
  __m128i v15; // xmm1
  int v16; // edx
  __m128i v17; // xmm0
  __m128i v18; // xmm2
  unsigned __int64 v19; // kr00_8
  __m128i v20; // xmm2
  bool v21; // cf
  __m128i v22; // xmm2
  int v23; // edx
  __m128i v24; // xmm0
  __m128i v25; // xmm3
  int v26; // kr08_4
  int v27; // edx
  __m128i v28; // xmm3
  __m128i v29; // xmm3
  __m128i v30; // xmm2
  int v31; // edx
  __m128i v32; // xmm0
  __m128i v33; // xmm3
  int v34; // kr10_4
  int v35; // edx
  __m128i v36; // xmm3
  __m128i v37; // xmm3
  __m128i v38; // xmm2
  int v39; // edx
  __m128i v40; // xmm0
  __m128i v41; // xmm3
  int v42; // kr18_4
  int v43; // edx
  __m128i v44; // xmm3
  __m128i v45; // xmm3
  __m128i v46; // xmm2
  int v47; // edx
  __m128i v48; // xmm0
  __m128i v49; // xmm3
  int v50; // kr20_4
  int v51; // edx
  __m128i v52; // xmm3
  __m128i v53; // xmm3
  __m128i v54; // xmm2
  int v55; // edx
  __m128i v56; // xmm0
  __m128i v57; // xmm3
  int v58; // kr28_4
  int v59; // edx
  __m128i v60; // xmm3
  __m128i v61; // xmm3
  __m128i v62; // xmm2
  int v63; // edx
  __m128i v64; // xmm0
  __m128i v65; // xmm3
  int v66; // kr30_4
  int v67; // edx
  __m128i v68; // xmm3
  __m128i v69; // xmm3
  __m128i v70; // xmm2
  int v71; // edx
  __m128i v72; // xmm0
  __m128i v73; // xmm3
  int v74; // kr38_4
  int v75; // edx
  __m128i v76; // xmm3
  __m128i v77; // xmm3
  __m128i si128; // xmm2
  int v79; // edx
  __m128i v80; // xmm0
  __m128i v81; // xmm3
  int v82; // kr40_4
  int v83; // edx
  __m128i v84; // xmm3
  __m128i v85; // xmm3
  __m128i v86; // xmm2
  int v87; // edx
  __m128i v88; // xmm0
  __m128i v89; // xmm3
  int v90; // kr48_4
  int v91; // edx
  __m128i v92; // xmm3
  __m128i v93; // xmm3
  __m128i v94; // xmm2
  int v95; // edx
  __m128i v96; // xmm0
  __m128i v97; // xmm3
  int v98; // kr50_4
  int v99; // edx
  __m128i v100; // xmm3
  __m128i v101; // xmm3
  __m128i v102; // xmm2
  int v103; // edx
  __m128i v104; // xmm0
  __m128i v105; // xmm3
  int v106; // kr58_4
  int v107; // edx
  __m128i v108; // xmm3
  __m128i v109; // xmm3
  __m128i v110; // xmm2
  int v111; // edx
  __m128i v112; // xmm0
  __m128i v113; // xmm3
  int v114; // kr60_4
  int v115; // edx
  __m128i v116; // xmm3
  __m128i v117; // xmm3
  __m128i v118; // xmm2
  int v119; // edx
  __m128i v120; // xmm0
  __m128i v121; // xmm3
  int v122; // kr68_4
  int v123; // edx
  __m128i v124; // xmm3
  __m128i v125; // xmm3
  __m128i v126; // xmm2
  int v127; // edx
  __m128i v128; // xmm0
  __m128i v129; // xmm3
  int v130; // kr70_4
  int v131; // edx
  __m128i v132; // xmm3
  __m128i v133; // xmm3
  __m128i v134; // xmm2
  int v135; // edx
  __m128i v136; // xmm0
  __m128i v137; // xmm3
  int v138; // kr78_4
  int v139; // edx
  __m128i v140; // xmm3
  __m128i v141; // xmm3
  int v142; // ebx
  unsigned int v143; // ecx
  unsigned int v144; // ebx
  unsigned __int8 v145; // cl
  bool v146; // cc
  __int16 v147; // cx
  __int16 v148; // bx
  unsigned __int16 v149; // cx
  unsigned __int16 v150; // bx
  unsigned __int8 v151; // al
  bool v152; // zf
  unsigned int v153; // ecx
  unsigned int v154; // ebx

  v3 = a3;
  if ( a3 >= 0x30 )
  {
    v7 = (unsigned int)&a1[1];
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), _mm_loadu_si128(a2))) - 0xFFFF;
    v9 = a2 + 1;
    if ( v8 )
      goto LABEL_192;
    v10 = v7 & 0xF;
    v7 ^= v10;
    v11 = (__m128i *)((char *)v9 - v10);
    v12 = v10 + a3;
    v13 = (unsigned __int8)v11 & 0xF;
    if ( ((unsigned __int8)v11 & 0xF) == 0 )
      goto LABEL_29;
    v11 = (__m128i *)(v13 ^ (unsigned int)v11);
    if ( v13 >= 8 )
    {
      switch ( v13 )
      {
        case 8u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 8;
          if ( v21 )
          {
            si128 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(si128, *v11, 8), *(__m128i *)v7);
            v79 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), si128, 8), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v79 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[2] + v3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v80 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 8), *(__m128i *)v7);
            v81 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 8), *(__m128i *)(v7 + 16));
            do
            {
              v83 = _mm_movemask_epi8(_mm_and_si128(v81, v80));
              v15 = v80;
              v84 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 8);
              v82 = v3 - 32;
              v8 = (__PAIR64__(v83, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v80 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 8), *(__m128i *)(v7 + 32));
              v11 += 2;
              v81 = _mm_cmpeq_epi8(v84, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v85 = _mm_and_si128(v81, v80);
            if ( v82 < 0 )
            {
              ++v8;
              v3 = v82 + 32;
            }
            if ( !v8 )
            {
              v15 = v80;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v85) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[2] + v3;
                goto LABEL_252;
              }
            }
          }
          break;
        case 9u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 9;
          if ( v21 )
          {
            v86 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v86, *v11, 9), *(__m128i *)v7);
            v87 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v86, 9), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v87 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[2] + v3 + 1;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v88 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 9), *(__m128i *)v7);
            v89 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 9), *(__m128i *)(v7 + 16));
            do
            {
              v91 = _mm_movemask_epi8(_mm_and_si128(v89, v88));
              v15 = v88;
              v92 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 9);
              v90 = v3 - 32;
              v8 = (__PAIR64__(v91, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v88 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 9), *(__m128i *)(v7 + 32));
              v11 += 2;
              v89 = _mm_cmpeq_epi8(v92, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v93 = _mm_and_si128(v89, v88);
            if ( v90 < 0 )
            {
              ++v8;
              v3 = v90 + 32;
            }
            if ( !v8 )
            {
              v15 = v88;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v93) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[2] + v3 + 1;
                goto LABEL_252;
              }
            }
          }
          break;
        case 0xAu:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 10;
          if ( v21 )
          {
            v94 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v94, *v11, 10), *(__m128i *)v7);
            v95 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v94, 10), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v95 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[2] + v3 + 2;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v96 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 10), *(__m128i *)v7);
            v97 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 10), *(__m128i *)(v7 + 16));
            do
            {
              v99 = _mm_movemask_epi8(_mm_and_si128(v97, v96));
              v15 = v96;
              v100 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 10);
              v98 = v3 - 32;
              v8 = (__PAIR64__(v99, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v96 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 10), *(__m128i *)(v7 + 32));
              v11 += 2;
              v97 = _mm_cmpeq_epi8(v100, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v101 = _mm_and_si128(v97, v96);
            if ( v98 < 0 )
            {
              ++v8;
              v3 = v98 + 32;
            }
            if ( !v8 )
            {
              v15 = v96;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v101) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[2] + v3 + 2;
                goto LABEL_252;
              }
            }
          }
          break;
        case 0xBu:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 11;
          if ( v21 )
          {
            v102 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v102, *v11, 11), *(__m128i *)v7);
            v103 = _mm_movemask_epi8(
                     _mm_and_si128(
                       _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v102, 11), *(__m128i *)(v7 + 16)),
                       v15));
            v7 += 32;
            v11 += 2;
            v8 = v103 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[2] + v3 + 3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v104 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 11), *(__m128i *)v7);
            v105 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 11), *(__m128i *)(v7 + 16));
            do
            {
              v107 = _mm_movemask_epi8(_mm_and_si128(v105, v104));
              v15 = v104;
              v108 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 11);
              v106 = v3 - 32;
              v8 = (__PAIR64__(v107, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v104 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 11), *(__m128i *)(v7 + 32));
              v11 += 2;
              v105 = _mm_cmpeq_epi8(v108, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v109 = _mm_and_si128(v105, v104);
            if ( v106 < 0 )
            {
              ++v8;
              v3 = v106 + 32;
            }
            if ( !v8 )
            {
              v15 = v104;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v109) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[2] + v3 + 3;
                goto LABEL_252;
              }
            }
          }
          break;
        case 0xCu:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 12;
          if ( v21 )
          {
            v110 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v110, *v11, 12), *(__m128i *)v7);
            v111 = _mm_movemask_epi8(
                     _mm_and_si128(
                       _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v110, 12), *(__m128i *)(v7 + 16)),
                       v15));
            v7 += 32;
            v11 += 2;
            v8 = v111 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[3] + v3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v112 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 12), *(__m128i *)v7);
            v113 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 12), *(__m128i *)(v7 + 16));
            do
            {
              v115 = _mm_movemask_epi8(_mm_and_si128(v113, v112));
              v15 = v112;
              v116 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 12);
              v114 = v3 - 32;
              v8 = (__PAIR64__(v115, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v112 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 12), *(__m128i *)(v7 + 32));
              v11 += 2;
              v113 = _mm_cmpeq_epi8(v116, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v117 = _mm_and_si128(v113, v112);
            if ( v114 < 0 )
            {
              ++v8;
              v3 = v114 + 32;
            }
            if ( !v8 )
            {
              v15 = v112;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v117) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[3] + v3;
                goto LABEL_252;
              }
            }
          }
          break;
        case 0xDu:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 13;
          if ( v21 )
          {
            v118 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v118, *v11, 13), *(__m128i *)v7);
            v119 = _mm_movemask_epi8(
                     _mm_and_si128(
                       _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v118, 13), *(__m128i *)(v7 + 16)),
                       v15));
            v7 += 32;
            v11 += 2;
            v8 = v119 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[3] + v3 + 1;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v120 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 13), *(__m128i *)v7);
            v121 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 13), *(__m128i *)(v7 + 16));
            do
            {
              v123 = _mm_movemask_epi8(_mm_and_si128(v121, v120));
              v15 = v120;
              v124 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 13);
              v122 = v3 - 32;
              v8 = (__PAIR64__(v123, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v120 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 13), *(__m128i *)(v7 + 32));
              v11 += 2;
              v121 = _mm_cmpeq_epi8(v124, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v125 = _mm_and_si128(v121, v120);
            if ( v122 < 0 )
            {
              ++v8;
              v3 = v122 + 32;
            }
            if ( !v8 )
            {
              v15 = v120;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v125) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[3] + v3 + 1;
                goto LABEL_252;
              }
            }
          }
          break;
        case 0xEu:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 14;
          if ( v21 )
          {
            v126 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v126, *v11, 14), *(__m128i *)v7);
            v127 = _mm_movemask_epi8(
                     _mm_and_si128(
                       _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v126, 14), *(__m128i *)(v7 + 16)),
                       v15));
            v7 += 32;
            v11 += 2;
            v8 = v127 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[3] + v3 + 2;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v128 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 14), *(__m128i *)v7);
            v129 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 14), *(__m128i *)(v7 + 16));
            do
            {
              v131 = _mm_movemask_epi8(_mm_and_si128(v129, v128));
              v15 = v128;
              v132 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 14);
              v130 = v3 - 32;
              v8 = (__PAIR64__(v131, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v128 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 14), *(__m128i *)(v7 + 32));
              v11 += 2;
              v129 = _mm_cmpeq_epi8(v132, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v133 = _mm_and_si128(v129, v128);
            if ( v130 < 0 )
            {
              ++v8;
              v3 = v130 + 32;
            }
            if ( !v8 )
            {
              v15 = v128;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v133) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[3] + v3 + 2;
                goto LABEL_252;
              }
            }
          }
          break;
        default:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = v13;
          if ( v21 )
          {
            v134 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v134, *v11, 15), *(__m128i *)v7);
            v135 = _mm_movemask_epi8(
                     _mm_and_si128(
                       _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v134, 15), *(__m128i *)(v7 + 16)),
                       v15));
            v7 += 32;
            v11 += 2;
            v8 = v135 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[3] + v3 + 3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v136 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 15), *(__m128i *)v7);
            v137 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 15), *(__m128i *)(v7 + 16));
            do
            {
              v139 = _mm_movemask_epi8(_mm_and_si128(v137, v136));
              v15 = v136;
              v140 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 15);
              v138 = v3 - 32;
              v8 = (__PAIR64__(v139, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v136 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 15), *(__m128i *)(v7 + 32));
              v11 += 2;
              v137 = _mm_cmpeq_epi8(v140, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v141 = _mm_and_si128(v137, v136);
            if ( v138 < 0 )
            {
              ++v8;
              v3 = v138 + 32;
            }
            if ( !v8 )
            {
              v15 = v136;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v141) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[3] + v3 + 3;
                goto LABEL_252;
              }
            }
          }
          break;
      }
      goto LABEL_189;
    }
    if ( v13 )
    {
      switch ( v13 )
      {
        case 1u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 1;
          if ( v21 )
          {
            v22 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v22, *v11, 1), *(__m128i *)v7);
            v23 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v22, 1), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v23 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)v11->m128i_i32 + v3 + 1;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v24 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 1), *(__m128i *)v7);
            v25 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 1), *(__m128i *)(v7 + 16));
            do
            {
              v27 = _mm_movemask_epi8(_mm_and_si128(v25, v24));
              v15 = v24;
              v28 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 1);
              v26 = v3 - 32;
              v8 = (__PAIR64__(v27, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v24 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 1), *(__m128i *)(v7 + 32));
              v11 += 2;
              v25 = _mm_cmpeq_epi8(v28, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v29 = _mm_and_si128(v25, v24);
            if ( v26 < 0 )
            {
              ++v8;
              v3 = v26 + 32;
            }
            if ( !v8 )
            {
              v15 = v24;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v29) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)v11->m128i_i32 + v3 + 1;
                goto LABEL_252;
              }
            }
          }
          break;
        case 2u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 2;
          if ( v21 )
          {
            v30 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v30, *v11, 2), *(__m128i *)v7);
            v31 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v30, 2), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v31 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)v11->m128i_i32 + v3 + 2;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v32 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 2), *(__m128i *)v7);
            v33 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 2), *(__m128i *)(v7 + 16));
            do
            {
              v35 = _mm_movemask_epi8(_mm_and_si128(v33, v32));
              v15 = v32;
              v36 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 2);
              v34 = v3 - 32;
              v8 = (__PAIR64__(v35, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v32 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 2), *(__m128i *)(v7 + 32));
              v11 += 2;
              v33 = _mm_cmpeq_epi8(v36, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v37 = _mm_and_si128(v33, v32);
            if ( v34 < 0 )
            {
              ++v8;
              v3 = v34 + 32;
            }
            if ( !v8 )
            {
              v15 = v32;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v37) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)v11->m128i_i32 + v3 + 2;
                goto LABEL_252;
              }
            }
          }
          break;
        case 3u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 3;
          if ( v21 )
          {
            v38 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v38, *v11, 3), *(__m128i *)v7);
            v39 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v38, 3), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v39 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)v11->m128i_i32 + v3 + 3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v40 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 3), *(__m128i *)v7);
            v41 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 3), *(__m128i *)(v7 + 16));
            do
            {
              v43 = _mm_movemask_epi8(_mm_and_si128(v41, v40));
              v15 = v40;
              v44 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 3);
              v42 = v3 - 32;
              v8 = (__PAIR64__(v43, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v40 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 3), *(__m128i *)(v7 + 32));
              v11 += 2;
              v41 = _mm_cmpeq_epi8(v44, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v45 = _mm_and_si128(v41, v40);
            if ( v42 < 0 )
            {
              ++v8;
              v3 = v42 + 32;
            }
            if ( !v8 )
            {
              v15 = v40;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v45) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)v11->m128i_i32 + v3 + 3;
                goto LABEL_252;
              }
            }
          }
          break;
        case 4u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 4;
          if ( v21 )
          {
            v46 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v46, *v11, 4), *(__m128i *)v7);
            v47 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v46, 4), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v47 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[1] + v3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v48 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 4), *(__m128i *)v7);
            v49 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 4), *(__m128i *)(v7 + 16));
            do
            {
              v51 = _mm_movemask_epi8(_mm_and_si128(v49, v48));
              v15 = v48;
              v52 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 4);
              v50 = v3 - 32;
              v8 = (__PAIR64__(v51, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v48 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 4), *(__m128i *)(v7 + 32));
              v11 += 2;
              v49 = _mm_cmpeq_epi8(v52, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v53 = _mm_and_si128(v49, v48);
            if ( v50 < 0 )
            {
              ++v8;
              v3 = v50 + 32;
            }
            if ( !v8 )
            {
              v15 = v48;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v53) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[1] + v3;
                goto LABEL_252;
              }
            }
          }
          break;
        case 5u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 5;
          if ( v21 )
          {
            v54 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v54, *v11, 5), *(__m128i *)v7);
            v55 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v54, 5), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v55 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[1] + v3 + 1;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v56 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 5), *(__m128i *)v7);
            v57 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 5), *(__m128i *)(v7 + 16));
            do
            {
              v59 = _mm_movemask_epi8(_mm_and_si128(v57, v56));
              v15 = v56;
              v60 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 5);
              v58 = v3 - 32;
              v8 = (__PAIR64__(v59, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v56 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 5), *(__m128i *)(v7 + 32));
              v11 += 2;
              v57 = _mm_cmpeq_epi8(v60, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v61 = _mm_and_si128(v57, v56);
            if ( v58 < 0 )
            {
              ++v8;
              v3 = v58 + 32;
            }
            if ( !v8 )
            {
              v15 = v56;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v61) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[1] + v3 + 1;
                goto LABEL_252;
              }
            }
          }
          break;
        case 6u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 6;
          if ( v21 )
          {
            v62 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v62, *v11, 6), *(__m128i *)v7);
            v63 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v62, 6), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v63 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[1] + v3 + 2;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v64 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 6), *(__m128i *)v7);
            v65 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 6), *(__m128i *)(v7 + 16));
            do
            {
              v67 = _mm_movemask_epi8(_mm_and_si128(v65, v64));
              v15 = v64;
              v68 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 6);
              v66 = v3 - 32;
              v8 = (__PAIR64__(v67, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v64 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 6), *(__m128i *)(v7 + 32));
              v11 += 2;
              v65 = _mm_cmpeq_epi8(v68, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v69 = _mm_and_si128(v65, v64);
            if ( v66 < 0 )
            {
              ++v8;
              v3 = v66 + 32;
            }
            if ( !v8 )
            {
              v15 = v64;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v69) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[1] + v3 + 2;
                goto LABEL_252;
              }
            }
          }
          break;
        default:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = v13;
          if ( v21 )
          {
            v70 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v70, *v11, 7), *(__m128i *)v7);
            v71 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v70, 7), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v71 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[1] + v3 + 3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v72 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 7), *(__m128i *)v7);
            v73 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 7), *(__m128i *)(v7 + 16));
            do
            {
              v75 = _mm_movemask_epi8(_mm_and_si128(v73, v72));
              v15 = v72;
              v76 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 7);
              v74 = v3 - 32;
              v8 = (__PAIR64__(v75, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v72 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 7), *(__m128i *)(v7 + 32));
              v11 += 2;
              v73 = _mm_cmpeq_epi8(v76, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v77 = _mm_and_si128(v73, v72);
            if ( v74 < 0 )
            {
              ++v8;
              v3 = v74 + 32;
            }
            if ( !v8 )
            {
              v15 = v72;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v77) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[1] + v3 + 3;
                goto LABEL_252;
              }
            }
          }
          break;
      }
    }
    else
    {
LABEL_29:
      if ( v12 >= 0x50 )
      {
        v14 = 0;
        v17 = _mm_cmpeq_epi8(_mm_load_si128(v11), *(__m128i *)v7);
        v3 = v12 - 80;
        v18 = _mm_cmpeq_epi8(_mm_load_si128(v11 + 1), *(__m128i *)(v7 + 16));
        do
        {
          v15 = v17;
          v19 = __PAIR64__(_mm_movemask_epi8(_mm_and_si128(v18, v17)), v3) - 0xFFFF00000020LL;
          v8 = HIDWORD(v19);
          v3 = v19;
          v17 = _mm_cmpeq_epi8(_mm_load_si128(v11 + 2), *(__m128i *)(v7 + 32));
          v18 = _mm_cmpeq_epi8(_mm_load_si128(v11 + 3), *(__m128i *)(v7 + 48));
          v7 += 32;
          v11 += 2;
        }
        while ( !HIDWORD(v19) );
        v20 = _mm_and_si128(v18, v17);
        if ( (v19 & 0x80000000) != 0LL )
        {
          v8 = HIDWORD(v19) + 1;
          v3 = v19 + 32;
        }
        if ( !v8 )
        {
          v15 = v17;
          v7 += 32;
          v11 += 2;
          v8 = _mm_movemask_epi8(v20) - 0xFFFF;
          if ( !v8 )
          {
            v5 = (__int8 *)(v3 + v7);
            v4 = (int)v11->m128i_i32 + v3;
            goto LABEL_252;
          }
        }
      }
      else
      {
        v3 = v12 - 48;
        v14 = 0;
        v15 = _mm_cmpeq_epi8(*v11, *(__m128i *)v7);
        v16 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(v11[1], *(__m128i *)(v7 + 16)), v15));
        v7 += 32;
        v11 += 2;
        v8 = v16 - 0xFFFF;
        if ( !v8 )
        {
          v5 = (__int8 *)(v3 + v7);
          v4 = (int)v11->m128i_i32 + v3;
          goto LABEL_252;
        }
      }
    }
LABEL_189:
    v142 = _mm_movemask_epi8(v15) - 0xFFFF;
    if ( v142 )
    {
      --v11;
      v7 -= 16;
      LOWORD(v8) = v142;
    }
    v9 = (__m128i *)((char *)v11 + v14);
LABEL_192:
    if ( (_BYTE)v8 )
    {
      if ( (v8 & 1) == 0 )
      {
        if ( (v8 & 2) == 0 )
        {
          if ( (v8 & 4) == 0 )
          {
            if ( (v8 & 8) == 0 )
            {
              if ( (v8 & 0x10) == 0 )
              {
                if ( (v8 & 0x20) == 0 )
                {
                  if ( (v8 & 0x40) == 0 )
                    return *(unsigned __int8 *)(v7 - 9) - v9[-1].m128i_u8[7];
                  return *(unsigned __int8 *)(v7 - 10) - v9[-1].m128i_u8[6];
                }
                return *(unsigned __int8 *)(v7 - 11) - v9[-1].m128i_u8[5];
              }
              return *(unsigned __int8 *)(v7 - 12) - v9[-1].m128i_u8[4];
            }
            return *(unsigned __int8 *)(v7 - 13) - v9[-1].m128i_u8[3];
          }
          return *(unsigned __int8 *)(v7 - 14) - v9[-1].m128i_u8[2];
        }
        return *(unsigned __int8 *)(v7 - 15) - v9[-1].m128i_u8[1];
      }
    }
    else
    {
      v7 += 8;
      v9 = (const __m128i *)((char *)v9 + 8);
      if ( (v8 & 0x100) == 0 )
      {
        if ( (v8 & 0x200) == 0 )
        {
          if ( (v8 & 0x400) == 0 )
          {
            if ( (v8 & 0x800) == 0 )
            {
              if ( (v8 & 0x1000) == 0 )
              {
                if ( (v8 & 0x2000) == 0 )
                {
                  if ( (v8 & 0x4000) == 0 )
                    return *(unsigned __int8 *)(v7 - 9) - v9[-1].m128i_u8[7];
                  return *(unsigned __int8 *)(v7 - 10) - v9[-1].m128i_u8[6];
                }
                return *(unsigned __int8 *)(v7 - 11) - v9[-1].m128i_u8[5];
              }
              return *(unsigned __int8 *)(v7 - 12) - v9[-1].m128i_u8[4];
            }
            return *(unsigned __int8 *)(v7 - 13) - v9[-1].m128i_u8[3];
          }
          return *(unsigned __int8 *)(v7 - 14) - v9[-1].m128i_u8[2];
        }
        return *(unsigned __int8 *)(v7 - 15) - v9[-1].m128i_u8[1];
      }
    }
    return *(unsigned __int8 *)(v7 - 16) - v9[-1].m128i_u8[0];
  }
  if ( a3 <= 1 )
  {
    if ( !a3 || a1->m128i_i8[0] == a2->m128i_i8[0] )
      return 0;
    result = 1;
    if ( a1->m128i_i8[0] <= (unsigned int)a2->m128i_i8[0] )
      return -1;
    return result;
  }
  v4 = (int)a2->m128i_i32 + a3;
  v5 = &a1->m128i_i8[a3];
LABEL_252:
  if ( v3 >= 8 )
  {
    if ( v3 < 0x10 )
    {
      switch ( v3 )
      {
        case 8u:
LABEL_276:
          v143 = *((_DWORD *)v5 - 2);
          v144 = *(_DWORD *)(v4 - 8);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_277;
        case 9u:
LABEL_288:
          v143 = *(_DWORD *)(v5 - 9);
          v144 = *(_DWORD *)(v4 - 9);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_289;
        case 0xAu:
LABEL_301:
          v143 = *(_DWORD *)(v5 - 10);
          v144 = *(_DWORD *)(v4 - 10);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_302:
          v143 = *(_DWORD *)(v5 - 6);
          v144 = *(_DWORD *)(v4 - 6);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_303;
        case 0xBu:
LABEL_315:
          v143 = *(_DWORD *)(v5 - 11);
          v144 = *(_DWORD *)(v4 - 11);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_316;
      }
      if ( v3 != 12 )
      {
        if ( v3 != 13 )
        {
          if ( v3 != 14 )
          {
LABEL_314:
            v143 = *(_DWORD *)(v5 - 15);
            v144 = *(_DWORD *)(v4 - 15);
            if ( v143 != v144 )
              goto LABEL_321;
            goto LABEL_315;
          }
          goto LABEL_300;
        }
        goto LABEL_287;
      }
LABEL_275:
      v143 = *((_DWORD *)v5 - 3);
      v144 = *(_DWORD *)(v4 - 12);
      if ( v143 != v144 )
        goto LABEL_321;
      goto LABEL_276;
    }
    if ( v3 < 0x18 )
    {
      switch ( v3 )
      {
        case 0x10u:
LABEL_274:
          v143 = *((_DWORD *)v5 - 4);
          v144 = *(_DWORD *)(v4 - 16);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_275;
        case 0x11u:
LABEL_286:
          v143 = *(_DWORD *)(v5 - 17);
          v144 = *(_DWORD *)(v4 - 17);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_287:
          v143 = *(_DWORD *)(v5 - 13);
          v144 = *(_DWORD *)(v4 - 13);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_288;
        case 0x12u:
LABEL_299:
          v143 = *(_DWORD *)(v5 - 18);
          v144 = *(_DWORD *)(v4 - 18);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_300:
          v143 = *(_DWORD *)(v5 - 14);
          v144 = *(_DWORD *)(v4 - 14);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_301;
        case 0x13u:
LABEL_313:
          v143 = *(_DWORD *)(v5 - 19);
          v144 = *(_DWORD *)(v4 - 19);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_314;
      }
      if ( v3 != 20 )
      {
        if ( v3 != 21 )
        {
          if ( v3 != 22 )
          {
LABEL_312:
            v143 = *(_DWORD *)(v5 - 23);
            v144 = *(_DWORD *)(v4 - 23);
            if ( v143 != v144 )
              goto LABEL_321;
            goto LABEL_313;
          }
          goto LABEL_298;
        }
        goto LABEL_285;
      }
LABEL_273:
      v143 = *((_DWORD *)v5 - 5);
      v144 = *(_DWORD *)(v4 - 20);
      if ( v143 != v144 )
        goto LABEL_321;
      goto LABEL_274;
    }
    if ( v3 < 0x20 )
    {
      switch ( v3 )
      {
        case 0x18u:
LABEL_272:
          v143 = *((_DWORD *)v5 - 6);
          v144 = *(_DWORD *)(v4 - 24);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_273;
        case 0x19u:
LABEL_284:
          v143 = *(_DWORD *)(v5 - 25);
          v144 = *(_DWORD *)(v4 - 25);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_285:
          v143 = *(_DWORD *)(v5 - 21);
          v144 = *(_DWORD *)(v4 - 21);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_286;
        case 0x1Au:
LABEL_297:
          v143 = *(_DWORD *)(v5 - 26);
          v144 = *(_DWORD *)(v4 - 26);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_298:
          v143 = *(_DWORD *)(v5 - 22);
          v144 = *(_DWORD *)(v4 - 22);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_299;
        case 0x1Bu:
LABEL_311:
          v143 = *(_DWORD *)(v5 - 27);
          v144 = *(_DWORD *)(v4 - 27);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_312;
      }
      if ( v3 != 28 )
      {
        if ( v3 != 29 )
        {
          if ( v3 != 30 )
          {
LABEL_310:
            v143 = *(_DWORD *)(v5 - 31);
            v144 = *(_DWORD *)(v4 - 31);
            if ( v143 != v144 )
              goto LABEL_321;
            goto LABEL_311;
          }
          goto LABEL_296;
        }
        goto LABEL_283;
      }
LABEL_271:
      v143 = *((_DWORD *)v5 - 7);
      v144 = *(_DWORD *)(v4 - 28);
      if ( v143 != v144 )
        goto LABEL_321;
      goto LABEL_272;
    }
    if ( v3 < 0x28 )
    {
      switch ( v3 )
      {
        case ' ':
LABEL_270:
          v143 = *((_DWORD *)v5 - 8);
          v144 = *(_DWORD *)(v4 - 32);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_271;
        case '!':
LABEL_282:
          v143 = *(_DWORD *)(v5 - 33);
          v144 = *(_DWORD *)(v4 - 33);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_283:
          v143 = *(_DWORD *)(v5 - 29);
          v144 = *(_DWORD *)(v4 - 29);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_284;
        case '"':
LABEL_295:
          v143 = *(_DWORD *)(v5 - 34);
          v144 = *(_DWORD *)(v4 - 34);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_296:
          v143 = *(_DWORD *)(v5 - 30);
          v144 = *(_DWORD *)(v4 - 30);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_297;
        case '#':
LABEL_309:
          v143 = *(_DWORD *)(v5 - 35);
          v144 = *(_DWORD *)(v4 - 35);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_310;
      }
      if ( v3 != 36 )
      {
        if ( v3 != 37 )
        {
          if ( v3 != 38 )
          {
LABEL_308:
            v143 = *(_DWORD *)(v5 - 39);
            v144 = *(_DWORD *)(v4 - 39);
            if ( v143 != v144 )
              goto LABEL_321;
            goto LABEL_309;
          }
          goto LABEL_294;
        }
        goto LABEL_281;
      }
LABEL_269:
      v143 = *((_DWORD *)v5 - 9);
      v144 = *(_DWORD *)(v4 - 36);
      if ( v143 != v144 )
        goto LABEL_321;
      goto LABEL_270;
    }
    if ( v3 != 40 )
    {
      switch ( v3 )
      {
        case ')':
          goto LABEL_280;
        case '*':
          goto LABEL_293;
        case '+':
LABEL_307:
          v143 = *(_DWORD *)(v5 - 43);
          v144 = *(_DWORD *)(v4 - 43);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_308;
      }
      if ( v3 != 44 )
      {
        if ( v3 != 45 )
        {
          if ( v3 != 46 )
          {
            v143 = *(_DWORD *)(v5 - 47);
            v144 = *(_DWORD *)(v4 - 47);
            if ( v143 != v144 )
              goto LABEL_321;
            goto LABEL_307;
          }
          v143 = *(_DWORD *)(v5 - 46);
          v144 = *(_DWORD *)(v4 - 46);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_293:
          v143 = *(_DWORD *)(v5 - 42);
          v144 = *(_DWORD *)(v4 - 42);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_294:
          v143 = *(_DWORD *)(v5 - 38);
          v144 = *(_DWORD *)(v4 - 38);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_295;
        }
        v143 = *(_DWORD *)(v5 - 45);
        v144 = *(_DWORD *)(v4 - 45);
        if ( v143 != v144 )
          goto LABEL_321;
LABEL_280:
        v143 = *(_DWORD *)(v5 - 41);
        v144 = *(_DWORD *)(v4 - 41);
        if ( v143 != v144 )
          goto LABEL_321;
LABEL_281:
        v143 = *(_DWORD *)(v5 - 37);
        v144 = *(_DWORD *)(v4 - 37);
        if ( v143 != v144 )
          goto LABEL_321;
        goto LABEL_282;
      }
      v143 = *((_DWORD *)v5 - 11);
      v144 = *(_DWORD *)(v4 - 44);
      if ( v143 != v144 )
        goto LABEL_321;
    }
    v143 = *((_DWORD *)v5 - 10);
    v144 = *(_DWORD *)(v4 - 40);
    if ( v143 != v144 )
      goto LABEL_321;
    goto LABEL_269;
  }
  if ( v3 != 2 )
  {
    if ( v3 == 3 )
    {
LABEL_317:
      v149 = *(_WORD *)(v5 - 3);
      v150 = *(_WORD *)(v4 - 3);
      v146 = (unsigned __int8)v149 <= (unsigned __int8)v150;
      if ( (_BYTE)v149 == (_BYTE)v150 )
      {
        v146 = v149 <= v150;
        if ( v149 == v150 )
        {
          v151 = *(v5 - 1);
          v152 = v151 == *(_BYTE *)(v4 - 1);
          v146 = v151 <= *(_BYTE *)(v4 - 1);
          result = 0;
          if ( v152 )
            return result;
        }
      }
LABEL_325:
      result = 1;
      if ( v146 )
        return -1;
      return result;
    }
    if ( v3 != 4 )
    {
      if ( v3 != 5 )
      {
        if ( v3 != 6 )
        {
LABEL_316:
          v143 = *(_DWORD *)(v5 - 7);
          v144 = *(_DWORD *)(v4 - 7);
          if ( v143 == v144 )
            goto LABEL_317;
LABEL_321:
          v146 = (unsigned __int8)v143 <= (unsigned __int8)v144;
          if ( (_BYTE)v143 == (_BYTE)v144 )
          {
            v146 = (unsigned __int16)v143 <= (unsigned __int16)v144;
            if ( (_WORD)v143 == (_WORD)v144 )
            {
              v153 = HIWORD(v143);
              v154 = HIWORD(v144);
              v146 = (unsigned __int8)v153 <= (unsigned __int8)v154;
              if ( (_BYTE)v153 == (_BYTE)v154 )
                v146 = (unsigned __int16)v153 <= (unsigned __int16)v154;
            }
          }
          goto LABEL_325;
        }
        goto LABEL_302;
      }
LABEL_289:
      v143 = *(_DWORD *)(v5 - 5);
      v144 = *(_DWORD *)(v4 - 5);
      if ( v143 == v144 )
      {
        v145 = *(v5 - 1);
        v146 = v145 <= *(_BYTE *)(v4 - 1);
        result = 0;
        if ( v145 == *(_BYTE *)(v4 - 1) )
          return result;
        goto LABEL_325;
      }
      goto LABEL_321;
    }
LABEL_277:
    v143 = *((_DWORD *)v5 - 1);
    v144 = *(_DWORD *)(v4 - 4);
    result = 0;
    if ( v143 == v144 )
      return result;
    goto LABEL_321;
  }
LABEL_303:
  v147 = *((_WORD *)v5 - 1);
  v148 = *(_WORD *)(v4 - 2);
  v146 = (unsigned __int8)v147 <= (unsigned __int8)v148;
  if ( (_BYTE)v147 != (_BYTE)v148 )
    goto LABEL_325;
  v146 = HIBYTE(v147) <= HIBYTE(v148);
  result = 0;
  if ( HIBYTE(v147) != HIBYTE(v148) )
    goto LABEL_325;
  return result;
}

//----- (08064040) --------------------------------------------------------
int __cdecl _memcmp_sse4_2(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  const __m128i *v3; // edx
  const __m128i *v4; // eax
  bool v5; // cc
  unsigned __int8 v6; // bl
  unsigned __int8 v7; // bl
  unsigned __int8 v8; // bl
  unsigned __int8 v9; // bl
  unsigned __int8 v10; // bl
  unsigned __int8 v11; // bl
  int result; // eax
  int v13; // ecx
  unsigned int v14; // ebx
  bool v15; // cf
  unsigned __int32 v16; // ecx
  unsigned __int32 v17; // ebx
  int v18; // ebx
  unsigned __int8 v19; // cl
  bool v20; // cc
  __int16 v21; // cx
  __int16 v22; // bx
  unsigned __int16 v23; // cx
  unsigned __int16 v24; // bx
  unsigned __int8 v25; // al
  bool v26; // zf
  unsigned __int8 v27; // cl
  __int16 v28; // cx
  __int16 v29; // bx
  unsigned __int16 v30; // cx
  unsigned __int16 v31; // bx
  unsigned __int8 v32; // al
  unsigned __int8 v33; // cl
  __int16 v34; // cx
  __int16 v35; // bx
  unsigned __int16 v36; // cx
  unsigned __int16 v37; // bx
  unsigned __int8 v38; // al
  unsigned __int8 v39; // cl
  __int16 v40; // cx
  __int16 v41; // bx
  unsigned __int16 v42; // cx
  unsigned __int16 v43; // bx
  unsigned __int8 v44; // al
  unsigned __int32 *v45; // eax
  unsigned __int32 *v46; // edx
  unsigned __int32 v47; // ecx
  unsigned __int32 v48; // ebx

  if ( a3 <= 1 )
  {
    if ( a3 )
      return *a1 - *a2;
    else
      return 0;
  }
  else if ( a3 < 8 )
  {
    v5 = *a1 <= *a2;
    if ( *a1 != *a2 )
      goto LABEL_16;
    v6 = a1[1];
    v5 = v6 <= a2[1];
    if ( v6 != a2[1] )
      goto LABEL_16;
    if ( a3 == 2 )
      return 0;
    v7 = a1[2];
    v5 = v7 <= a2[2];
    if ( v7 != a2[2] )
      goto LABEL_16;
    if ( a3 == 3 )
      return 0;
    v8 = a1[3];
    v5 = v8 <= a2[3];
    if ( v8 != a2[3] )
      goto LABEL_16;
    if ( a3 == 4 )
      return 0;
    v9 = a1[4];
    v5 = v9 <= a2[4];
    if ( v9 == a2[4]
      && (a3 == 5
       || (v10 = a1[5], v5 = v10 <= a2[5], v10 == a2[5]) && (a3 == 6 || (v11 = a1[6], v5 = v11 <= a2[6], v11 == a2[6]))) )
    {
      return 0;
    }
    else
    {
LABEL_16:
      result = 1;
      if ( v5 )
        return -1;
    }
  }
  else
  {
    v3 = (const __m128i *)&a2[a3];
    v4 = (const __m128i *)&a1[a3];
    switch ( a3 )
    {
      case 0u:
        return 0;
      case 1u:
        goto LABEL_64;
      case 2u:
        goto LABEL_53;
      case 3u:
        goto LABEL_62;
      case 4u:
        goto LABEL_37;
      case 5u:
        goto LABEL_44;
      case 6u:
        goto LABEL_52;
      case 7u:
        goto LABEL_61;
      case 8u:
        goto LABEL_36;
      case 9u:
        goto LABEL_43;
      case 0xAu:
        goto LABEL_51;
      case 0xBu:
        goto LABEL_60;
      case 0xCu:
        goto LABEL_35;
      case 0xDu:
        goto LABEL_42;
      case 0xEu:
        goto LABEL_50;
      case 0xFu:
        goto LABEL_59;
      case 0x10u:
        goto LABEL_34;
      case 0x11u:
        goto LABEL_41;
      case 0x12u:
        goto LABEL_49;
      case 0x13u:
        goto LABEL_58;
      case 0x14u:
        goto LABEL_68;
      case 0x15u:
        goto LABEL_73;
      case 0x16u:
        goto LABEL_79;
      case 0x17u:
        goto LABEL_86;
      case 0x18u:
        goto LABEL_94;
      case 0x19u:
        goto LABEL_100;
      case 0x1Au:
        goto LABEL_107;
      case 0x1Bu:
        goto LABEL_115;
      case 0x1Cu:
        goto LABEL_124;
      case 0x1Du:
        goto LABEL_131;
      case 0x1Eu:
        goto LABEL_139;
      case 0x1Fu:
        goto LABEL_148;
      case 0x20u:
        goto LABEL_158;
      case 0x21u:
        goto LABEL_40;
      case 0x22u:
        goto LABEL_48;
      case 0x23u:
        goto LABEL_57;
      case 0x24u:
        goto LABEL_67;
      case 0x25u:
        goto LABEL_72;
      case 0x26u:
        goto LABEL_78;
      case 0x27u:
        goto LABEL_85;
      case 0x28u:
        goto LABEL_93;
      case 0x29u:
        goto LABEL_99;
      case 0x2Au:
        goto LABEL_106;
      case 0x2Bu:
        goto LABEL_114;
      case 0x2Cu:
        goto LABEL_123;
      case 0x2Du:
        goto LABEL_130;
      case 0x2Eu:
        goto LABEL_138;
      case 0x2Fu:
        goto LABEL_147;
      case 0x30u:
        goto LABEL_157;
      case 0x31u:
LABEL_39:
        v18 = -49;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 49)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 49)))) )
          goto LABEL_164;
LABEL_40:
        v18 = -33;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 33)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 33)))) )
          goto LABEL_164;
LABEL_41:
        v16 = *(unsigned __int32 *)((char *)&v4[-2].m128i_u32[3] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-2].m128i_u32[3] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_42:
        v16 = *(unsigned __int32 *)((char *)v4[-1].m128i_u32 + 3);
        v17 = *(unsigned __int32 *)((char *)v3[-1].m128i_u32 + 3);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_43:
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_44:
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v19 = v4[-1].m128i_u8[15];
        v20 = v19 <= (unsigned int)v3[-1].m128i_i8[15];
        result = 0;
        if ( v19 == v3[-1].m128i_i8[15] )
          return result;
        goto LABEL_172;
      case 0x32u:
LABEL_47:
        v18 = -50;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 50)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 50)))) )
          goto LABEL_164;
LABEL_48:
        v18 = -34;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 34)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 34)))) )
          goto LABEL_164;
LABEL_49:
        v16 = *(unsigned __int32 *)((char *)&v4[-2].m128i_u32[3] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-2].m128i_u32[3] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_50:
        v16 = *(unsigned __int32 *)((char *)v4[-1].m128i_u32 + 2);
        v17 = *(unsigned __int32 *)((char *)v3[-1].m128i_u32 + 2);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_51:
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_52:
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_53:
        v21 = v4[-1].m128i_i16[7];
        v22 = v3[-1].m128i_i16[7];
        v20 = (unsigned __int8)v21 <= (unsigned __int8)v22;
        if ( (_BYTE)v21 == (_BYTE)v22 )
        {
          v20 = HIBYTE(v21) <= HIBYTE(v22);
          result = 0;
          if ( HIBYTE(v21) == HIBYTE(v22) )
            return result;
        }
        goto LABEL_172;
      case 0x33u:
LABEL_56:
        v18 = -51;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 51)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 51)))) )
          goto LABEL_164;
LABEL_57:
        v18 = -35;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 35)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 35)))) )
          goto LABEL_164;
LABEL_58:
        v16 = *(unsigned __int32 *)((char *)&v4[-2].m128i_u32[3] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-2].m128i_u32[3] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_59:
        v16 = *(unsigned __int32 *)((char *)v4[-1].m128i_u32 + 1);
        v17 = *(unsigned __int32 *)((char *)v3[-1].m128i_u32 + 1);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_60:
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_61:
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_62:
        v23 = *(unsigned __int16 *)((char *)&v4[-1].m128i_u16[6] + 1);
        v24 = *(unsigned __int16 *)((char *)&v3[-1].m128i_u16[6] + 1);
        v20 = (unsigned __int8)v23 <= (unsigned __int8)v24;
        if ( (_BYTE)v23 != (_BYTE)v24 )
          goto LABEL_172;
        v20 = v23 <= v24;
        if ( v23 != v24 )
          goto LABEL_172;
LABEL_64:
        v25 = v4[-1].m128i_u8[15];
        v26 = v25 == v3[-1].m128i_i8[15];
        v20 = v25 <= (unsigned int)v3[-1].m128i_i8[15];
        result = 0;
        if ( v26 )
          return result;
        goto LABEL_172;
      case 0x34u:
LABEL_66:
        v18 = -52;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 52)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 52)))) )
          goto LABEL_164;
LABEL_67:
        v18 = -36;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 36)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 36)))) )
          goto LABEL_164;
LABEL_68:
        v18 = -20;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 20)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 20)))) )
          goto LABEL_164;
        v16 = v4[-1].m128i_u32[3];
        v17 = v3[-1].m128i_u32[3];
        result = 0;
        if ( v16 == v17 )
          return result;
        goto LABEL_168;
      case 0x35u:
LABEL_71:
        v18 = -53;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 53)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 53)))) )
          goto LABEL_164;
LABEL_72:
        v18 = -37;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 37)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 37)))) )
          goto LABEL_164;
LABEL_73:
        v18 = -21;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 21)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 21)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v27 = v4[-1].m128i_u8[15];
        v20 = v27 <= (unsigned int)v3[-1].m128i_i8[15];
        result = 0;
        if ( v27 == v3[-1].m128i_i8[15] )
          return result;
        goto LABEL_172;
      case 0x36u:
LABEL_77:
        v18 = -54;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 54)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 54)))) )
          goto LABEL_164;
LABEL_78:
        v18 = -38;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 38)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 38)))) )
          goto LABEL_164;
LABEL_79:
        v18 = -22;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 22)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 22)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
        v28 = v4[-1].m128i_i16[7];
        v29 = v3[-1].m128i_i16[7];
        v20 = (unsigned __int8)v28 <= (unsigned __int8)v29;
        if ( (_BYTE)v28 == (_BYTE)v29 )
        {
          v20 = HIBYTE(v28) <= HIBYTE(v29);
          result = 0;
          if ( HIBYTE(v28) == HIBYTE(v29) )
            return result;
        }
        goto LABEL_172;
      case 0x37u:
LABEL_84:
        v18 = -55;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 55)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 55)))) )
          goto LABEL_164;
LABEL_85:
        v18 = -39;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 39)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 39)))) )
          goto LABEL_164;
LABEL_86:
        v18 = -23;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 23)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 23)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
        v30 = *(unsigned __int16 *)((char *)&v4[-1].m128i_u16[6] + 1);
        v31 = *(unsigned __int16 *)((char *)&v3[-1].m128i_u16[6] + 1);
        v20 = (unsigned __int8)v30 <= (unsigned __int8)v31;
        if ( (_BYTE)v30 == (_BYTE)v31 )
        {
          v20 = v30 <= v31;
          if ( v30 == v31 )
          {
            v32 = v4[-1].m128i_u8[15];
            v26 = v32 == v3[-1].m128i_i8[15];
            v20 = v32 <= (unsigned int)v3[-1].m128i_i8[15];
            result = 0;
            if ( v26 )
              return result;
          }
        }
        goto LABEL_172;
      case 0x38u:
LABEL_92:
        v18 = -56;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 56)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 56)))) )
          goto LABEL_164;
LABEL_93:
        v18 = -40;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 40)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 40)))) )
          goto LABEL_164;
LABEL_94:
        v18 = -24;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 24)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 24)))) )
          goto LABEL_164;
        v16 = v4[-1].m128i_u32[2];
        v17 = v3[-1].m128i_u32[2];
        if ( v16 == v17 )
        {
          v16 = v4[-1].m128i_u32[3];
          v17 = v3[-1].m128i_u32[3];
          result = 0;
          if ( v16 == v17 )
            return result;
        }
        goto LABEL_168;
      case 0x39u:
LABEL_98:
        v18 = -57;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 57)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 57)))) )
          goto LABEL_164;
LABEL_99:
        v18 = -41;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 41)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 41)))) )
          goto LABEL_164;
LABEL_100:
        v18 = -25;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 25)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 25)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v33 = v4[-1].m128i_u8[15];
        v20 = v33 <= (unsigned int)v3[-1].m128i_i8[15];
        result = 0;
        if ( v33 == v3[-1].m128i_i8[15] )
          return result;
        goto LABEL_172;
      case 0x3Au:
LABEL_105:
        v18 = -58;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 58)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 58)))) )
          goto LABEL_164;
LABEL_106:
        v18 = -42;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 42)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 42)))) )
          goto LABEL_164;
LABEL_107:
        v18 = -26;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 26)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 26)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
        v34 = v4[-1].m128i_i16[7];
        v35 = v3[-1].m128i_i16[7];
        v20 = (unsigned __int8)v34 <= (unsigned __int8)v35;
        if ( (_BYTE)v34 == (_BYTE)v35 )
        {
          v20 = HIBYTE(v34) <= HIBYTE(v35);
          result = 0;
          if ( HIBYTE(v34) == HIBYTE(v35) )
            return result;
        }
        goto LABEL_172;
      case 0x3Bu:
LABEL_113:
        v18 = -59;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 59)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 59)))) )
          goto LABEL_164;
LABEL_114:
        v18 = -43;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 43)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 43)))) )
          goto LABEL_164;
LABEL_115:
        v18 = -27;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 27)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 27)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
        v36 = *(unsigned __int16 *)((char *)&v4[-1].m128i_u16[6] + 1);
        v37 = *(unsigned __int16 *)((char *)&v3[-1].m128i_u16[6] + 1);
        v20 = (unsigned __int8)v36 <= (unsigned __int8)v37;
        if ( (_BYTE)v36 == (_BYTE)v37 )
        {
          v20 = v36 <= v37;
          if ( v36 == v37 )
          {
            v38 = v4[-1].m128i_u8[15];
            v26 = v38 == v3[-1].m128i_i8[15];
            v20 = v38 <= (unsigned int)v3[-1].m128i_i8[15];
            result = 0;
            if ( v26 )
              return result;
          }
        }
        goto LABEL_172;
      case 0x3Cu:
LABEL_122:
        v18 = -60;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 60)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 60)))) )
          goto LABEL_164;
LABEL_123:
        v18 = -44;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 44)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 44)))) )
          goto LABEL_164;
LABEL_124:
        v18 = -28;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 28)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 28)))) )
          goto LABEL_164;
        v16 = v4[-1].m128i_u32[1];
        v17 = v3[-1].m128i_u32[1];
        if ( v16 == v17 )
        {
          v16 = v4[-1].m128i_u32[2];
          v17 = v3[-1].m128i_u32[2];
          if ( v16 == v17 )
          {
            v16 = v4[-1].m128i_u32[3];
            v17 = v3[-1].m128i_u32[3];
            result = 0;
            if ( v16 == v17 )
              return result;
          }
        }
        goto LABEL_168;
      case 0x3Du:
LABEL_129:
        v18 = -61;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 61)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 61)))) )
          goto LABEL_164;
LABEL_130:
        v18 = -45;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 45)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 45)))) )
          goto LABEL_164;
LABEL_131:
        v18 = -29;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 29)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 29)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)v4[-1].m128i_u32 + 3);
        v17 = *(unsigned __int32 *)((char *)v3[-1].m128i_u32 + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v39 = v4[-1].m128i_u8[15];
        v20 = v39 <= (unsigned int)v3[-1].m128i_i8[15];
        result = 0;
        if ( v39 == v3[-1].m128i_i8[15] )
          return result;
        goto LABEL_172;
      case 0x3Eu:
LABEL_137:
        v18 = -62;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 62)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 62)))) )
          goto LABEL_164;
LABEL_138:
        v18 = -46;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 46)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 46)))) )
          goto LABEL_164;
LABEL_139:
        v18 = -30;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 30)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 30)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)v4[-1].m128i_u32 + 2);
        v17 = *(unsigned __int32 *)((char *)v3[-1].m128i_u32 + 2);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
        v40 = v4[-1].m128i_i16[7];
        v41 = v3[-1].m128i_i16[7];
        v20 = (unsigned __int8)v40 <= (unsigned __int8)v41;
        if ( (_BYTE)v40 == (_BYTE)v41 )
        {
          v20 = HIBYTE(v40) <= HIBYTE(v41);
          result = 0;
          if ( HIBYTE(v40) == HIBYTE(v41) )
            return result;
        }
        goto LABEL_172;
      case 0x3Fu:
LABEL_146:
        v18 = -63;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 63)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 63)))) )
          goto LABEL_164;
LABEL_147:
        v18 = -47;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 47)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 47)))) )
          goto LABEL_164;
LABEL_148:
        v18 = -31;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 31)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 31)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)v4[-1].m128i_u32 + 1);
        v17 = *(unsigned __int32 *)((char *)v3[-1].m128i_u32 + 1);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
        v42 = *(unsigned __int16 *)((char *)&v4[-1].m128i_u16[6] + 1);
        v43 = *(unsigned __int16 *)((char *)&v3[-1].m128i_u16[6] + 1);
        v20 = (unsigned __int8)v42 <= (unsigned __int8)v43;
        if ( (_BYTE)v42 == (_BYTE)v43 )
        {
          v20 = v42 <= v43;
          if ( v42 == v43 )
          {
            v44 = v4[-1].m128i_u8[15];
            v26 = v44 == v3[-1].m128i_i8[15];
            v20 = v44 <= (unsigned int)v3[-1].m128i_i8[15];
            result = 0;
            if ( v26 )
              return result;
          }
        }
        goto LABEL_172;
      case 0x40u:
LABEL_156:
        v18 = -64;
        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3 - 4), _mm_loadu_si128(v4 - 4))) )
          goto LABEL_164;
LABEL_157:
        v18 = -48;
        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3 - 3), _mm_loadu_si128(v4 - 3))) )
          goto LABEL_164;
LABEL_158:
        v18 = -32;
        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3 - 2), _mm_loadu_si128(v4 - 2))) )
        {
LABEL_164:
          v45 = (unsigned __int32 *)((char *)v4->m128i_u32 + v18);
          v46 = (unsigned __int32 *)((char *)v3->m128i_u32 + v18);
          v16 = *v45;
          v17 = *v46;
          if ( *v45 == *v46 )
          {
            v16 = v45[1];
            v17 = v46[1];
            if ( v16 == v17 )
            {
              v16 = v45[2];
              v17 = v46[2];
              if ( v16 == v17 )
              {
                v16 = v45[3];
                v17 = v46[3];
                result = 0;
                if ( v16 == v17 )
                  return result;
              }
            }
          }
          goto LABEL_168;
        }
        v16 = v4[-1].m128i_u32[0];
        v17 = v3[-1].m128i_u32[0];
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = v4[-1].m128i_u32[1];
        v17 = v3[-1].m128i_u32[1];
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = v4[-1].m128i_u32[2];
        v17 = v3[-1].m128i_u32[2];
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = v4[-1].m128i_u32[3];
        v17 = v3[-1].m128i_u32[3];
        result = 0;
        if ( v16 != v17 )
          goto LABEL_168;
        return result;
      default:
        v13 = 64;
        v14 = a3 - 64;
        break;
    }
    while ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3), _mm_loadu_si128(v4))) )
    {
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3 + 1), _mm_loadu_si128(v4 + 1))) )
        goto LABEL_31;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3 + 2), _mm_loadu_si128(v4 + 2))) )
        goto LABEL_32;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3 + 3), _mm_loadu_si128(v4 + 3))) )
        goto LABEL_33;
      v4 += 4;
      v3 += 4;
      v15 = v14 < 0x40;
      v14 -= 64;
      if ( v15 )
      {
        v3 = (const __m128i *)((char *)v3 + v14 + 64);
        v4 = (const __m128i *)((char *)v4 + v14 + 64);
        switch ( v14 )
        {
          case 0xFFFFFFC0:
            return 0;
          case 0xFFFFFFC1:
            goto LABEL_64;
          case 0xFFFFFFC2:
            goto LABEL_53;
          case 0xFFFFFFC3:
            goto LABEL_62;
          case 0xFFFFFFC4:
            goto LABEL_37;
          case 0xFFFFFFC5:
            goto LABEL_44;
          case 0xFFFFFFC6:
            goto LABEL_52;
          case 0xFFFFFFC7:
            goto LABEL_61;
          case 0xFFFFFFC8:
            goto LABEL_36;
          case 0xFFFFFFC9:
            goto LABEL_43;
          case 0xFFFFFFCA:
            goto LABEL_51;
          case 0xFFFFFFCB:
            goto LABEL_60;
          case 0xFFFFFFCC:
            goto LABEL_35;
          case 0xFFFFFFCD:
            goto LABEL_42;
          case 0xFFFFFFCE:
            goto LABEL_50;
          case 0xFFFFFFCF:
            goto LABEL_59;
          case 0xFFFFFFD0:
            goto LABEL_34;
          case 0xFFFFFFD1:
            goto LABEL_41;
          case 0xFFFFFFD2:
            goto LABEL_49;
          case 0xFFFFFFD3:
            goto LABEL_58;
          case 0xFFFFFFD4:
            goto LABEL_68;
          case 0xFFFFFFD5:
            goto LABEL_73;
          case 0xFFFFFFD6:
            goto LABEL_79;
          case 0xFFFFFFD7:
            goto LABEL_86;
          case 0xFFFFFFD8:
            goto LABEL_94;
          case 0xFFFFFFD9:
            goto LABEL_100;
          case 0xFFFFFFDA:
            goto LABEL_107;
          case 0xFFFFFFDB:
            goto LABEL_115;
          case 0xFFFFFFDC:
            goto LABEL_124;
          case 0xFFFFFFDD:
            goto LABEL_131;
          case 0xFFFFFFDE:
            goto LABEL_139;
          case 0xFFFFFFDF:
            goto LABEL_148;
          case 0xFFFFFFE0:
            goto LABEL_158;
          case 0xFFFFFFE1:
            goto LABEL_40;
          case 0xFFFFFFE2:
            goto LABEL_48;
          case 0xFFFFFFE3:
            goto LABEL_57;
          case 0xFFFFFFE4:
            goto LABEL_67;
          case 0xFFFFFFE5:
            goto LABEL_72;
          case 0xFFFFFFE6:
            goto LABEL_78;
          case 0xFFFFFFE7:
            goto LABEL_85;
          case 0xFFFFFFE8:
            goto LABEL_93;
          case 0xFFFFFFE9:
            goto LABEL_99;
          case 0xFFFFFFEA:
            goto LABEL_106;
          case 0xFFFFFFEB:
            goto LABEL_114;
          case 0xFFFFFFEC:
            goto LABEL_123;
          case 0xFFFFFFED:
            goto LABEL_130;
          case 0xFFFFFFEE:
            goto LABEL_138;
          case 0xFFFFFFEF:
            goto LABEL_147;
          case 0xFFFFFFF0:
            goto LABEL_157;
          case 0xFFFFFFF1:
            goto LABEL_39;
          case 0xFFFFFFF2:
            goto LABEL_47;
          case 0xFFFFFFF3:
            goto LABEL_56;
          case 0xFFFFFFF4:
            goto LABEL_66;
          case 0xFFFFFFF5:
            goto LABEL_71;
          case 0xFFFFFFF6:
            goto LABEL_77;
          case 0xFFFFFFF7:
            goto LABEL_84;
          case 0xFFFFFFF8:
            goto LABEL_92;
          case 0xFFFFFFF9:
            goto LABEL_98;
          case 0xFFFFFFFA:
            goto LABEL_105;
          case 0xFFFFFFFB:
            goto LABEL_113;
          case 0xFFFFFFFC:
            goto LABEL_122;
          case 0xFFFFFFFD:
            goto LABEL_129;
          case 0xFFFFFFFE:
            goto LABEL_137;
          case 0xFFFFFFFF:
            goto LABEL_146;
          case 0u:
            goto LABEL_156;
        }
      }
    }
    v13 = 48;
LABEL_31:
    v13 -= 16;
LABEL_32:
    v13 -= 16;
LABEL_33:
    v3 = (const __m128i *)((char *)v3 + v13);
    v4 = (const __m128i *)((char *)v4 + v13);
LABEL_34:
    v16 = v4[-1].m128i_u32[0];
    v17 = v3[-1].m128i_u32[0];
    if ( v16 == v17 )
    {
LABEL_35:
      v16 = v4[-1].m128i_u32[1];
      v17 = v3[-1].m128i_u32[1];
      if ( v16 == v17 )
      {
LABEL_36:
        v16 = v4[-1].m128i_u32[2];
        v17 = v3[-1].m128i_u32[2];
        if ( v16 == v17 )
        {
LABEL_37:
          v16 = v4[-1].m128i_u32[3];
          v17 = v3[-1].m128i_u32[3];
          result = 0;
          if ( v16 == v17 )
            return result;
        }
      }
    }
LABEL_168:
    v20 = (unsigned __int8)v16 <= (unsigned __int8)v17;
    if ( (_BYTE)v16 == (_BYTE)v17 )
    {
      v20 = (unsigned __int16)v16 <= (unsigned __int16)v17;
      if ( (_WORD)v16 == (_WORD)v17 )
      {
        v47 = HIWORD(v16);
        v48 = HIWORD(v17);
        v20 = (unsigned __int8)v47 <= (unsigned __int8)v48;
        if ( (_BYTE)v47 == (_BYTE)v48 )
          v20 = (unsigned __int16)v47 <= (unsigned __int16)v48;
      }
    }
LABEL_172:
    result = 1;
    if ( v20 )
      return -1;
  }
  return result;
}
// 8064040: could not find valid save-restore pair for ebx

//----- (08064BD0) --------------------------------------------------------
unsigned int __cdecl _strcpy_ssse3(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // edx
  unsigned int v3; // ecx
  __m128i *v4; // esi
  __m128i v5; // xmm0
  int v6; // eax
  int v7; // esi
  unsigned int v8; // eax
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  __m128i v11; // xmm3
  __m128i v12; // xmm0
  __m128i v13; // xmm4
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  __m128i v18; // xmm0
  __m128i v19; // xmm3
  __m128i v20; // xmm0
  __m128i v21; // xmm4
  __m128i v22; // xmm5
  __m128i v23; // xmm6
  __m128i v24; // xmm7
  __m128i v25; // xmm3
  __m128i v26; // xmm0
  __m128i v27; // xmm0
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  __m128i v30; // xmm2
  __m128i v31; // xmm0
  __m128i v32; // xmm3
  __m128i v33; // xmm2
  __m128i v34; // xmm1
  __m128i v35; // xmm2
  __m128i v36; // xmm0
  __m128i v37; // xmm3
  __m128i v38; // xmm2
  __m128i v39; // xmm1
  __m128i v40; // xmm0
  __m128i v41; // xmm3
  __m128i v42; // xmm2
  unsigned int v43; // eax
  unsigned int v44; // ecx
  unsigned int v45; // eax
  __m128i v46; // xmm3
  __m128i v47; // xmm4
  __m128i v48; // xmm5
  int v49; // eax
  __m128i v50; // xmm7
  __m128i v51; // xmm5
  __m128i v52; // xmm4
  __m128i v53; // xmm3
  __m128i v54; // xmm2
  __m128i v55; // xmm1
  __m128i v56; // xmm2
  __m128i v57; // xmm0
  __m128i v58; // xmm3
  __m128i v59; // xmm2
  __m128i v60; // xmm1
  __m128i v61; // xmm2
  __m128i v62; // xmm0
  __m128i v63; // xmm3
  __m128i v64; // xmm2
  __m128i v65; // xmm1
  __m128i v66; // xmm0
  __m128i v67; // xmm3
  __m128i v68; // xmm2
  unsigned int v69; // eax
  unsigned int v70; // ecx
  unsigned int v71; // eax
  __m128i v72; // xmm3
  __m128i v73; // xmm4
  __m128i v74; // xmm5
  int v75; // eax
  __m128i v76; // xmm7
  __m128i v77; // xmm5
  __m128i v78; // xmm4
  __m128i v79; // xmm3
  __m128i v80; // xmm2
  double v81; // xmm1_8
  __m128i v82; // xmm1
  __m128i v83; // xmm2
  __m128i v84; // xmm0
  __m128i v85; // xmm3
  __m128i v86; // xmm2
  __m128i v87; // xmm1
  __m128i v88; // xmm2
  __m128i v89; // xmm0
  __m128i v90; // xmm3
  __m128i v91; // xmm2
  __m128i v92; // xmm1
  __m128i v93; // xmm0
  __m128i v94; // xmm3
  __m128i v95; // xmm2
  unsigned int v96; // eax
  unsigned int v97; // ecx
  unsigned int v98; // eax
  __m128i v99; // xmm3
  __m128i v100; // xmm4
  __m128i v101; // xmm5
  int v102; // eax
  __m128i v103; // xmm7
  __m128i v104; // xmm5
  __m128i v105; // xmm4
  __m128i v106; // xmm3
  __m128i v107; // xmm2
  double v108; // xmm1_8
  __m128i v109; // xmm1
  __m128i v110; // xmm2
  __m128i v111; // xmm0
  __m128i v112; // xmm3
  __m128i v113; // xmm2
  __m128i v114; // xmm1
  __m128i v115; // xmm2
  __m128i v116; // xmm0
  __m128i v117; // xmm3
  __m128i v118; // xmm2
  __m128i v119; // xmm1
  __m128i v120; // xmm0
  __m128i v121; // xmm3
  __m128i v122; // xmm2
  unsigned int v123; // eax
  unsigned int v124; // ecx
  unsigned int v125; // eax
  __m128i v126; // xmm3
  __m128i v127; // xmm4
  __m128i v128; // xmm5
  int v129; // eax
  __m128i v130; // xmm7
  __m128i v131; // xmm5
  __m128i v132; // xmm4
  __m128i v133; // xmm3
  __m128i v134; // xmm2
  int v135; // esi
  __m128i v136; // xmm1
  __m128i v137; // xmm2
  __m128i v138; // xmm0
  __m128i v139; // xmm3
  __m128i v140; // xmm2
  __m128i v141; // xmm1
  __m128i v142; // xmm2
  __m128i v143; // xmm0
  __m128i v144; // xmm3
  __m128i v145; // xmm2
  __m128i v146; // xmm1
  __m128i v147; // xmm0
  __m128i v148; // xmm3
  __m128i v149; // xmm2
  unsigned int v150; // eax
  unsigned int v151; // ecx
  unsigned int v152; // eax
  __m128i v153; // xmm3
  __m128i v154; // xmm4
  __m128i v155; // xmm5
  int v156; // eax
  __m128i v157; // xmm7
  __m128i v158; // xmm5
  __m128i v159; // xmm4
  __m128i v160; // xmm3
  __m128i v161; // xmm2
  int v162; // esi
  __m128i v163; // xmm1
  __m128i v164; // xmm2
  __m128i v165; // xmm0
  __m128i v166; // xmm3
  __m128i v167; // xmm2
  __m128i v168; // xmm1
  __m128i v169; // xmm2
  __m128i v170; // xmm0
  __m128i v171; // xmm3
  __m128i v172; // xmm2
  __m128i v173; // xmm1
  __m128i v174; // xmm0
  __m128i v175; // xmm3
  __m128i v176; // xmm2
  unsigned int v177; // eax
  unsigned int v178; // ecx
  unsigned int v179; // eax
  __m128i v180; // xmm3
  __m128i v181; // xmm4
  __m128i v182; // xmm5
  int v183; // eax
  __m128i v184; // xmm7
  __m128i v185; // xmm5
  __m128i v186; // xmm4
  __m128i v187; // xmm3
  __m128i v188; // xmm2
  int v189; // esi
  __m128i v190; // xmm1
  __m128i v191; // xmm2
  __m128i v192; // xmm0
  __m128i v193; // xmm3
  __m128i v194; // xmm2
  __m128i v195; // xmm1
  __m128i v196; // xmm2
  __m128i v197; // xmm0
  __m128i v198; // xmm3
  __m128i v199; // xmm2
  __m128i v200; // xmm1
  __m128i v201; // xmm0
  __m128i v202; // xmm3
  __m128i v203; // xmm2
  unsigned int v204; // eax
  unsigned int v205; // ecx
  unsigned int v206; // eax
  __m128i v207; // xmm3
  __m128i v208; // xmm4
  __m128i v209; // xmm5
  int v210; // eax
  __m128i v211; // xmm7
  __m128i v212; // xmm5
  __m128i v213; // xmm4
  __m128i v214; // xmm3
  __m128i v215; // xmm2
  int v216; // esi
  __m128i v217; // xmm1
  __m128i v218; // xmm2
  __m128i v219; // xmm0
  __m128i v220; // xmm3
  __m128i v221; // xmm2
  __m128i v222; // xmm1
  __m128i v223; // xmm2
  __m128i v224; // xmm0
  __m128i v225; // xmm3
  __m128i v226; // xmm2
  __m128i v227; // xmm1
  __m128i v228; // xmm0
  __m128i v229; // xmm3
  __m128i v230; // xmm2
  unsigned int v231; // eax
  unsigned int v232; // ecx
  unsigned int v233; // eax
  __m128i v234; // xmm3
  __m128i v235; // xmm4
  __m128i v236; // xmm5
  int v237; // eax
  __m128i v238; // xmm7
  __m128i v239; // xmm5
  __m128i v240; // xmm4
  __m128i v241; // xmm3
  __m128i v242; // xmm2
  __m128i v243; // xmm1
  __m128i v244; // xmm2
  __m128i v245; // xmm0
  __m128i v246; // xmm3
  __m128i v247; // xmm2
  __m128i v248; // xmm1
  __m128i v249; // xmm2
  __m128i v250; // xmm0
  __m128i v251; // xmm3
  __m128i v252; // xmm2
  __m128i v253; // xmm1
  __m128i v254; // xmm0
  __m128i v255; // xmm3
  __m128i v256; // xmm2
  unsigned int v257; // eax
  unsigned int v258; // ecx
  unsigned int v259; // eax
  __m128i v260; // xmm3
  __m128i v261; // xmm4
  __m128i v262; // xmm5
  int v263; // eax
  __m128i v264; // xmm7
  __m128i v265; // xmm5
  __m128i v266; // xmm4
  __m128i v267; // xmm3
  __m128i v268; // xmm2
  __m128i v269; // xmm1
  __m128i v270; // xmm2
  __m128i v271; // xmm0
  __m128i v272; // xmm3
  __m128i v273; // xmm2
  __m128i v274; // xmm1
  __m128i v275; // xmm2
  __m128i v276; // xmm0
  __m128i v277; // xmm3
  __m128i v278; // xmm2
  __m128i v279; // xmm1
  __m128i v280; // xmm0
  __m128i v281; // xmm3
  __m128i v282; // xmm2
  unsigned int v283; // eax
  unsigned int v284; // ecx
  unsigned int v285; // eax
  __m128i v286; // xmm3
  __m128i v287; // xmm4
  __m128i v288; // xmm5
  int v289; // eax
  __m128i v290; // xmm7
  __m128i v291; // xmm5
  __m128i v292; // xmm4
  __m128i v293; // xmm3
  __m128i v294; // xmm2
  __m128i v295; // xmm1
  __m128i v296; // xmm2
  __m128i v297; // xmm0
  __m128i v298; // xmm3
  __m128i v299; // xmm2
  __m128i v300; // xmm1
  __m128i v301; // xmm2
  __m128i v302; // xmm0
  __m128i v303; // xmm3
  __m128i v304; // xmm2
  __m128i v305; // xmm1
  __m128i v306; // xmm0
  __m128i v307; // xmm3
  __m128i v308; // xmm2
  unsigned int v309; // eax
  unsigned int v310; // ecx
  unsigned int v311; // eax
  __m128i v312; // xmm3
  __m128i v313; // xmm4
  __m128i v314; // xmm5
  int v315; // eax
  __m128i v316; // xmm7
  __m128i v317; // xmm5
  __m128i v318; // xmm4
  __m128i v319; // xmm3
  __m128i v320; // xmm2
  __m128i v321; // xmm1
  __m128i v322; // xmm2
  __m128i v323; // xmm0
  __m128i v324; // xmm3
  __m128i v325; // xmm2
  __m128i v326; // xmm1
  __m128i v327; // xmm2
  __m128i v328; // xmm0
  __m128i v329; // xmm3
  __m128i v330; // xmm2
  __m128i v331; // xmm1
  __m128i v332; // xmm0
  __m128i v333; // xmm3
  __m128i v334; // xmm2
  unsigned int v335; // eax
  unsigned int v336; // ecx
  unsigned int v337; // eax
  __m128i v338; // xmm3
  __m128i v339; // xmm4
  __m128i v340; // xmm5
  int v341; // eax
  __m128i v342; // xmm7
  __m128i v343; // xmm5
  __m128i v344; // xmm4
  __m128i v345; // xmm3
  __m128i v346; // xmm2
  __m128i v347; // xmm1
  __m128i v348; // xmm2
  __m128i v349; // xmm0
  __m128i v350; // xmm3
  __m128i v351; // xmm2
  __m128i v352; // xmm1
  __m128i v353; // xmm2
  __m128i v354; // xmm0
  __m128i v355; // xmm3
  __m128i v356; // xmm2
  __m128i v357; // xmm1
  __m128i v358; // xmm0
  __m128i v359; // xmm3
  __m128i v360; // xmm2
  unsigned int v361; // eax
  unsigned int v362; // ecx
  unsigned int v363; // eax
  __m128i v364; // xmm3
  __m128i v365; // xmm4
  __m128i v366; // xmm5
  int v367; // eax
  __m128i v368; // xmm7
  __m128i v369; // xmm5
  __m128i v370; // xmm4
  __m128i v371; // xmm3
  __m128i v372; // xmm2
  __m128i v373; // xmm1
  __m128i v374; // xmm2
  __m128i v375; // xmm0
  __m128i v376; // xmm3
  __m128i v377; // xmm2
  __m128i v378; // xmm1
  __m128i v379; // xmm2
  __m128i v380; // xmm0
  __m128i v381; // xmm3
  __m128i v382; // xmm2
  __m128i v383; // xmm1
  __m128i v384; // xmm0
  __m128i v385; // xmm3
  __m128i v386; // xmm2
  unsigned int v387; // eax
  unsigned int v388; // ecx
  unsigned int v389; // eax
  __m128i v390; // xmm3
  __m128i v391; // xmm4
  __m128i v392; // xmm5
  int v393; // eax
  __m128i v394; // xmm7
  __m128i v395; // xmm5
  __m128i v396; // xmm4
  __m128i v397; // xmm3
  __m128i v398; // xmm2
  __m128i v399; // xmm1
  __m128i v400; // xmm2
  __m128i v401; // xmm0
  __m128i v402; // xmm3
  __m128i v403; // xmm2
  __m128i v404; // xmm1
  __m128i v405; // xmm2
  __m128i v406; // xmm0
  __m128i v407; // xmm3
  __m128i v408; // xmm2
  __m128i v409; // xmm1
  __m128i v410; // xmm0
  __m128i v411; // xmm3
  __m128i v412; // xmm2
  unsigned int v413; // eax
  unsigned int v414; // ecx
  unsigned int v415; // eax
  __m128i v416; // xmm3
  __m128i v417; // xmm4
  __m128i v418; // xmm5
  int v419; // eax
  __m128i v420; // xmm7
  __m128i v421; // xmm5
  __m128i v422; // xmm4
  __m128i v423; // xmm3
  __m128i v424; // xmm2
  unsigned int v425; // edx
  unsigned int v426; // ecx
  int v428; // eax
  char v429; // al
  __int16 v430; // ax
  int v431; // eax
  double v432; // xmm1_8
  double v433; // xmm1_8
  double v434; // xmm1_8
  char v435; // al
  __int16 v436; // ax
  int v437; // eax
  int v438; // eax
  double v439; // xmm1_8
  double v440; // xmm1_8
  double v441; // xmm1_8

  v2 = a1;
  v3 = a2;
  if ( *(_BYTE *)a2 )
  {
    if ( *(_BYTE *)(a2 + 1) )
    {
      if ( *(_BYTE *)(a2 + 2) )
      {
        if ( *(_BYTE *)(a2 + 3) )
        {
          if ( *(_BYTE *)(a2 + 4) )
          {
            if ( *(_BYTE *)(a2 + 5) )
            {
              if ( *(_BYTE *)(a2 + 6) )
              {
                if ( *(_BYTE *)(a2 + 7) )
                {
                  if ( *(_BYTE *)(a2 + 8) )
                  {
                    if ( *(_BYTE *)(a2 + 9) )
                    {
                      if ( *(_BYTE *)(a2 + 10) )
                      {
                        if ( *(_BYTE *)(a2 + 11) )
                        {
                          if ( *(_BYTE *)(a2 + 12) )
                          {
                            if ( *(_BYTE *)(a2 + 13) )
                            {
                              if ( *(_BYTE *)(a2 + 14) )
                              {
                                if ( *(_BYTE *)(a2 + 15) )
                                {
                                  v4 = (__m128i *)((a2 + 16) & 0xFFFFFFF0);
                                  *(double *)a1 = *(double *)a2;
                                  v5 = _mm_cmpeq_epi8((__m128i)0LL, *v4);
                                  *(double *)(a1 + 8) = *(double *)(a2 + 8);
                                  v6 = _mm_movemask_epi8(v5);
                                  v7 = (int)v4->m128i_i32 - a2;
                                  if ( !v6 )
                                  {
                                    v2 = (a1 + 16) & 0xFFFFFFF0;
                                    v3 = a2 - (a1 - v2);
                                    v8 = v3 & 0xF;
                                    if ( (v3 & 0xF) != 0 )
                                    {
                                      if ( v8 >= 8 )
                                      {
                                        switch ( v8 )
                                        {
                                          case 8u:
                                            v217 = *(__m128i *)(v3 - 8);
                                            v218 = *(__m128i *)(v3 + 8);
                                            while ( 1 )
                                            {
                                              v219 = _mm_cmpeq_epi8(v5, v218);
                                              v6 = _mm_movemask_epi8(v219);
                                              v220 = v218;
                                              if ( v6 )
                                                break;
                                              v221 = _mm_alignr_epi8(v218, v217, 8);
                                              v222 = v220;
                                              *(__m128i *)v2 = v221;
                                              v223 = *(__m128i *)(v3 + 24);
                                              v224 = _mm_cmpeq_epi8(v219, v223);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v224);
                                              v3 += 16;
                                              v225 = v223;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v223, v222, 8);
                                              v226 = *(__m128i *)(v3 + 24);
                                              v227 = v225;
                                              v228 = _mm_cmpeq_epi8(v224, v226);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v228);
                                              v3 += 16;
                                              v229 = v226;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v226, v227, 8);
                                              v230 = *(__m128i *)(v3 + 24);
                                              v5 = _mm_cmpeq_epi8(v228, v230);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v230, v229, 8);
                                              v231 = v3 + 24;
                                              v232 = (v3 + 24) & 0xFFFFFFC0;
                                              v233 = v231 - v232;
                                              v3 = v232 - 8;
                                              v2 = v2 + 16 - v233;
                                              v217 = *(__m128i *)(v3 - 8);
                                              while ( 1 )
                                              {
                                                v218 = *(__m128i *)(v3 + 8);
                                                v234 = *(__m128i *)(v3 + 24);
                                                v235 = *(__m128i *)(v3 + 40);
                                                v236 = *(__m128i *)(v3 + 56);
                                                v237 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v235, v236),
                                                             _mm_min_epu8(v234, v218)),
                                                           v5));
                                                v238 = v236;
                                                v239 = _mm_alignr_epi8(v236, v235, 8);
                                                v240 = _mm_alignr_epi8(v235, v234, 8);
                                                if ( v237 )
                                                  break;
                                                v241 = _mm_alignr_epi8(v234, v218, 8);
                                                v3 += 64;
                                                v242 = _mm_alignr_epi8(v218, v217, 8);
                                                v217 = v238;
                                                *(__m128i *)(v2 + 48) = v239;
                                                *(__m128i *)(v2 + 32) = v240;
                                                *(__m128i *)(v2 + 16) = v241;
                                                *(__m128i *)v2 = v242;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)v2 = *(double *)v3;
                                            v7 = 8;
                                            break;
                                          case 9u:
                                            v243 = *(__m128i *)(v3 - 9);
                                            v244 = *(__m128i *)(v3 + 7);
                                            while ( 1 )
                                            {
                                              v245 = _mm_cmpeq_epi8(v5, v244);
                                              v6 = _mm_movemask_epi8(v245);
                                              v246 = v244;
                                              if ( v6 )
                                                break;
                                              v247 = _mm_alignr_epi8(v244, v243, 9);
                                              v248 = v246;
                                              *(__m128i *)v2 = v247;
                                              v249 = *(__m128i *)(v3 + 23);
                                              v250 = _mm_cmpeq_epi8(v245, v249);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v250);
                                              v3 += 16;
                                              v251 = v249;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v249, v248, 9);
                                              v252 = *(__m128i *)(v3 + 23);
                                              v253 = v251;
                                              v254 = _mm_cmpeq_epi8(v250, v252);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v254);
                                              v3 += 16;
                                              v255 = v252;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v252, v253, 9);
                                              v256 = *(__m128i *)(v3 + 23);
                                              v5 = _mm_cmpeq_epi8(v254, v256);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v256, v255, 9);
                                              v257 = v3 + 23;
                                              v258 = (v3 + 23) & 0xFFFFFFC0;
                                              v259 = v257 - v258;
                                              v3 = v258 - 7;
                                              v2 = v2 + 16 - v259;
                                              v243 = *(__m128i *)(v3 - 9);
                                              while ( 1 )
                                              {
                                                v244 = *(__m128i *)(v3 + 7);
                                                v260 = *(__m128i *)(v3 + 23);
                                                v261 = *(__m128i *)(v3 + 39);
                                                v262 = *(__m128i *)(v3 + 55);
                                                v263 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v261, v262),
                                                             _mm_min_epu8(v260, v244)),
                                                           v5));
                                                v264 = v262;
                                                v265 = _mm_alignr_epi8(v262, v261, 9);
                                                v266 = _mm_alignr_epi8(v261, v260, 9);
                                                if ( v263 )
                                                  break;
                                                v267 = _mm_alignr_epi8(v260, v244, 9);
                                                v3 += 64;
                                                v268 = _mm_alignr_epi8(v244, v243, 9);
                                                v243 = v264;
                                                *(__m128i *)(v2 + 48) = v265;
                                                *(__m128i *)(v2 + 32) = v266;
                                                *(__m128i *)(v2 + 16) = v267;
                                                *(__m128i *)v2 = v268;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)(v2 - 1) = *(double *)(v3 - 1);
                                            v7 = 7;
                                            break;
                                          case 0xAu:
                                            v269 = *(__m128i *)(v3 - 10);
                                            v270 = *(__m128i *)(v3 + 6);
                                            while ( 1 )
                                            {
                                              v271 = _mm_cmpeq_epi8(v5, v270);
                                              v6 = _mm_movemask_epi8(v271);
                                              v272 = v270;
                                              if ( v6 )
                                                break;
                                              v273 = _mm_alignr_epi8(v270, v269, 10);
                                              v274 = v272;
                                              *(__m128i *)v2 = v273;
                                              v275 = *(__m128i *)(v3 + 22);
                                              v276 = _mm_cmpeq_epi8(v271, v275);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v276);
                                              v3 += 16;
                                              v277 = v275;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v275, v274, 10);
                                              v278 = *(__m128i *)(v3 + 22);
                                              v279 = v277;
                                              v280 = _mm_cmpeq_epi8(v276, v278);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v280);
                                              v3 += 16;
                                              v281 = v278;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v278, v279, 10);
                                              v282 = *(__m128i *)(v3 + 22);
                                              v5 = _mm_cmpeq_epi8(v280, v282);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v282, v281, 10);
                                              v283 = v3 + 22;
                                              v284 = (v3 + 22) & 0xFFFFFFC0;
                                              v285 = v283 - v284;
                                              v3 = v284 - 6;
                                              v2 = v2 + 16 - v285;
                                              v269 = *(__m128i *)(v3 - 10);
                                              while ( 1 )
                                              {
                                                v270 = *(__m128i *)(v3 + 6);
                                                v286 = *(__m128i *)(v3 + 22);
                                                v287 = *(__m128i *)(v3 + 38);
                                                v288 = *(__m128i *)(v3 + 54);
                                                v289 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v287, v288),
                                                             _mm_min_epu8(v286, v270)),
                                                           v5));
                                                v290 = v288;
                                                v291 = _mm_alignr_epi8(v288, v287, 10);
                                                v292 = _mm_alignr_epi8(v287, v286, 10);
                                                if ( v289 )
                                                  break;
                                                v293 = _mm_alignr_epi8(v286, v270, 10);
                                                v3 += 64;
                                                v294 = _mm_alignr_epi8(v270, v269, 10);
                                                v269 = v290;
                                                *(__m128i *)(v2 + 48) = v291;
                                                *(__m128i *)(v2 + 32) = v292;
                                                *(__m128i *)(v2 + 16) = v293;
                                                *(__m128i *)v2 = v294;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)(v2 - 2) = *(double *)(v3 - 2);
                                            v7 = 6;
                                            break;
                                          case 0xBu:
                                            v295 = *(__m128i *)(v3 - 11);
                                            v296 = *(__m128i *)(v3 + 5);
                                            while ( 1 )
                                            {
                                              v297 = _mm_cmpeq_epi8(v5, v296);
                                              v6 = _mm_movemask_epi8(v297);
                                              v298 = v296;
                                              if ( v6 )
                                                break;
                                              v299 = _mm_alignr_epi8(v296, v295, 11);
                                              v300 = v298;
                                              *(__m128i *)v2 = v299;
                                              v301 = *(__m128i *)(v3 + 21);
                                              v302 = _mm_cmpeq_epi8(v297, v301);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v302);
                                              v3 += 16;
                                              v303 = v301;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v301, v300, 11);
                                              v304 = *(__m128i *)(v3 + 21);
                                              v305 = v303;
                                              v306 = _mm_cmpeq_epi8(v302, v304);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v306);
                                              v3 += 16;
                                              v307 = v304;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v304, v305, 11);
                                              v308 = *(__m128i *)(v3 + 21);
                                              v5 = _mm_cmpeq_epi8(v306, v308);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v308, v307, 11);
                                              v309 = v3 + 21;
                                              v310 = (v3 + 21) & 0xFFFFFFC0;
                                              v311 = v309 - v310;
                                              v3 = v310 - 5;
                                              v2 = v2 + 16 - v311;
                                              v295 = *(__m128i *)(v3 - 11);
                                              while ( 1 )
                                              {
                                                v296 = *(__m128i *)(v3 + 5);
                                                v312 = *(__m128i *)(v3 + 21);
                                                v313 = *(__m128i *)(v3 + 37);
                                                v314 = *(__m128i *)(v3 + 53);
                                                v315 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v313, v314),
                                                             _mm_min_epu8(v312, v296)),
                                                           v5));
                                                v316 = v314;
                                                v317 = _mm_alignr_epi8(v314, v313, 11);
                                                v318 = _mm_alignr_epi8(v313, v312, 11);
                                                if ( v315 )
                                                  break;
                                                v319 = _mm_alignr_epi8(v312, v296, 11);
                                                v3 += 64;
                                                v320 = _mm_alignr_epi8(v296, v295, 11);
                                                v295 = v316;
                                                *(__m128i *)(v2 + 48) = v317;
                                                *(__m128i *)(v2 + 32) = v318;
                                                *(__m128i *)(v2 + 16) = v319;
                                                *(__m128i *)v2 = v320;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)(v2 - 3) = *(double *)(v3 - 3);
                                            v7 = 5;
                                            break;
                                          case 0xCu:
                                            v321 = *(__m128i *)(v3 - 12);
                                            v322 = *(__m128i *)(v3 + 4);
                                            while ( 1 )
                                            {
                                              v323 = _mm_cmpeq_epi8(v5, v322);
                                              v6 = _mm_movemask_epi8(v323);
                                              v324 = v322;
                                              if ( v6 )
                                                break;
                                              v325 = _mm_alignr_epi8(v322, v321, 12);
                                              v326 = v324;
                                              *(__m128i *)v2 = v325;
                                              v327 = *(__m128i *)(v3 + 20);
                                              v328 = _mm_cmpeq_epi8(v323, v327);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v328);
                                              v3 += 16;
                                              v329 = v327;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v327, v326, 12);
                                              v330 = *(__m128i *)(v3 + 20);
                                              v331 = v329;
                                              v332 = _mm_cmpeq_epi8(v328, v330);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v332);
                                              v3 += 16;
                                              v333 = v330;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v330, v331, 12);
                                              v334 = *(__m128i *)(v3 + 20);
                                              v5 = _mm_cmpeq_epi8(v332, v334);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v334, v333, 12);
                                              v335 = v3 + 20;
                                              v336 = (v3 + 20) & 0xFFFFFFC0;
                                              v337 = v335 - v336;
                                              v3 = v336 - 4;
                                              v2 = v2 + 16 - v337;
                                              v321 = *(__m128i *)(v3 - 12);
                                              while ( 1 )
                                              {
                                                v322 = *(__m128i *)(v3 + 4);
                                                v338 = *(__m128i *)(v3 + 20);
                                                v339 = *(__m128i *)(v3 + 36);
                                                v340 = *(__m128i *)(v3 + 52);
                                                v341 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v339, v340),
                                                             _mm_min_epu8(v338, v322)),
                                                           v5));
                                                v342 = v340;
                                                v343 = _mm_alignr_epi8(v340, v339, 12);
                                                v344 = _mm_alignr_epi8(v339, v338, 12);
                                                if ( v341 )
                                                  break;
                                                v345 = _mm_alignr_epi8(v338, v322, 12);
                                                v3 += 64;
                                                v346 = _mm_alignr_epi8(v322, v321, 12);
                                                v321 = v342;
                                                *(__m128i *)(v2 + 48) = v343;
                                                *(__m128i *)(v2 + 32) = v344;
                                                *(__m128i *)(v2 + 16) = v345;
                                                *(__m128i *)v2 = v346;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)v2 = *(_DWORD *)v3;
                                            v7 = 4;
                                            break;
                                          case 0xDu:
                                            v347 = *(__m128i *)(v3 - 13);
                                            v348 = *(__m128i *)(v3 + 3);
                                            while ( 1 )
                                            {
                                              v349 = _mm_cmpeq_epi8(v5, v348);
                                              v6 = _mm_movemask_epi8(v349);
                                              v350 = v348;
                                              if ( v6 )
                                                break;
                                              v351 = _mm_alignr_epi8(v348, v347, 13);
                                              v352 = v350;
                                              *(__m128i *)v2 = v351;
                                              v353 = *(__m128i *)(v3 + 19);
                                              v354 = _mm_cmpeq_epi8(v349, v353);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v354);
                                              v3 += 16;
                                              v355 = v353;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v353, v352, 13);
                                              v356 = *(__m128i *)(v3 + 19);
                                              v357 = v355;
                                              v358 = _mm_cmpeq_epi8(v354, v356);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v358);
                                              v3 += 16;
                                              v359 = v356;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v356, v357, 13);
                                              v360 = *(__m128i *)(v3 + 19);
                                              v5 = _mm_cmpeq_epi8(v358, v360);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v360, v359, 13);
                                              v361 = v3 + 19;
                                              v362 = (v3 + 19) & 0xFFFFFFC0;
                                              v363 = v361 - v362;
                                              v3 = v362 - 3;
                                              v2 = v2 + 16 - v363;
                                              v347 = *(__m128i *)(v3 - 13);
                                              while ( 1 )
                                              {
                                                v348 = *(__m128i *)(v3 + 3);
                                                v364 = *(__m128i *)(v3 + 19);
                                                v365 = *(__m128i *)(v3 + 35);
                                                v366 = *(__m128i *)(v3 + 51);
                                                v367 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v365, v366),
                                                             _mm_min_epu8(v364, v348)),
                                                           v5));
                                                v368 = v366;
                                                v369 = _mm_alignr_epi8(v366, v365, 13);
                                                v370 = _mm_alignr_epi8(v365, v364, 13);
                                                if ( v367 )
                                                  break;
                                                v371 = _mm_alignr_epi8(v364, v348, 13);
                                                v3 += 64;
                                                v372 = _mm_alignr_epi8(v348, v347, 13);
                                                v347 = v368;
                                                *(__m128i *)(v2 + 48) = v369;
                                                *(__m128i *)(v2 + 32) = v370;
                                                *(__m128i *)(v2 + 16) = v371;
                                                *(__m128i *)v2 = v372;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)(v2 - 1) = *(_DWORD *)(v3 - 1);
                                            v7 = 3;
                                            break;
                                          case 0xEu:
                                            v373 = *(__m128i *)(v3 - 14);
                                            v374 = *(__m128i *)(v3 + 2);
                                            while ( 1 )
                                            {
                                              v375 = _mm_cmpeq_epi8(v5, v374);
                                              v6 = _mm_movemask_epi8(v375);
                                              v376 = v374;
                                              if ( v6 )
                                                break;
                                              v377 = _mm_alignr_epi8(v374, v373, 14);
                                              v378 = v376;
                                              *(__m128i *)v2 = v377;
                                              v379 = *(__m128i *)(v3 + 18);
                                              v380 = _mm_cmpeq_epi8(v375, v379);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v380);
                                              v3 += 16;
                                              v381 = v379;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v379, v378, 14);
                                              v382 = *(__m128i *)(v3 + 18);
                                              v383 = v381;
                                              v384 = _mm_cmpeq_epi8(v380, v382);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v384);
                                              v3 += 16;
                                              v385 = v382;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v382, v383, 14);
                                              v386 = *(__m128i *)(v3 + 18);
                                              v5 = _mm_cmpeq_epi8(v384, v386);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v386, v385, 14);
                                              v387 = v3 + 18;
                                              v388 = (v3 + 18) & 0xFFFFFFC0;
                                              v389 = v387 - v388;
                                              v3 = v388 - 2;
                                              v2 = v2 + 16 - v389;
                                              v373 = *(__m128i *)(v3 - 14);
                                              while ( 1 )
                                              {
                                                v374 = *(__m128i *)(v3 + 2);
                                                v390 = *(__m128i *)(v3 + 18);
                                                v391 = *(__m128i *)(v3 + 34);
                                                v392 = *(__m128i *)(v3 + 50);
                                                v393 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v391, v392),
                                                             _mm_min_epu8(v390, v374)),
                                                           v5));
                                                v394 = v392;
                                                v395 = _mm_alignr_epi8(v392, v391, 14);
                                                v396 = _mm_alignr_epi8(v391, v390, 14);
                                                if ( v393 )
                                                  break;
                                                v397 = _mm_alignr_epi8(v390, v374, 14);
                                                v3 += 64;
                                                v398 = _mm_alignr_epi8(v374, v373, 14);
                                                v373 = v394;
                                                *(__m128i *)(v2 + 48) = v395;
                                                *(__m128i *)(v2 + 32) = v396;
                                                *(__m128i *)(v2 + 16) = v397;
                                                *(__m128i *)v2 = v398;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)(v2 - 2) = *(_DWORD *)(v3 - 2);
                                            v7 = 2;
                                            break;
                                          default:
                                            v399 = *(__m128i *)(v3 - 15);
                                            v400 = *(__m128i *)(v3 + 1);
                                            while ( 1 )
                                            {
                                              v401 = _mm_cmpeq_epi8(v5, v400);
                                              v6 = _mm_movemask_epi8(v401);
                                              v402 = v400;
                                              if ( v6 )
                                                break;
                                              v403 = _mm_alignr_epi8(v400, v399, 15);
                                              v404 = v402;
                                              *(__m128i *)v2 = v403;
                                              v405 = *(__m128i *)(v3 + 17);
                                              v406 = _mm_cmpeq_epi8(v401, v405);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v406);
                                              v3 += 16;
                                              v407 = v405;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v405, v404, 15);
                                              v408 = *(__m128i *)(v3 + 17);
                                              v409 = v407;
                                              v410 = _mm_cmpeq_epi8(v406, v408);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v410);
                                              v3 += 16;
                                              v411 = v408;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v408, v409, 15);
                                              v412 = *(__m128i *)(v3 + 17);
                                              v5 = _mm_cmpeq_epi8(v410, v412);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v412, v411, 15);
                                              v413 = v3 + 17;
                                              v414 = (v3 + 17) & 0xFFFFFFC0;
                                              v415 = v413 - v414;
                                              v3 = v414 - 1;
                                              v2 = v2 + 16 - v415;
                                              v399 = *(__m128i *)(v3 - 15);
                                              while ( 1 )
                                              {
                                                v400 = *(__m128i *)(v3 + 1);
                                                v416 = *(__m128i *)(v3 + 17);
                                                v417 = *(__m128i *)(v3 + 33);
                                                v418 = *(__m128i *)(v3 + 49);
                                                v419 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v417, v418),
                                                             _mm_min_epu8(v416, v400)),
                                                           v5));
                                                v420 = v418;
                                                v421 = _mm_alignr_epi8(v418, v417, 15);
                                                v422 = _mm_alignr_epi8(v417, v416, 15);
                                                if ( v419 )
                                                  break;
                                                v423 = _mm_alignr_epi8(v416, v400, 15);
                                                v3 += 64;
                                                v424 = _mm_alignr_epi8(v400, v399, 15);
                                                v399 = v420;
                                                *(__m128i *)(v2 + 48) = v421;
                                                *(__m128i *)(v2 + 32) = v422;
                                                *(__m128i *)(v2 + 16) = v423;
                                                *(__m128i *)v2 = v424;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)(v2 - 3) = *(_DWORD *)(v3 - 3);
                                            v7 = 1;
                                            break;
                                        }
                                      }
                                      else
                                      {
                                        switch ( v8 )
                                        {
                                          case 1u:
                                            v29 = *(__m128i *)(v3 - 1);
                                            v30 = *(__m128i *)(v3 + 15);
                                            while ( 1 )
                                            {
                                              v31 = _mm_cmpeq_epi8(v5, v30);
                                              v6 = _mm_movemask_epi8(v31);
                                              v32 = v30;
                                              if ( v6 )
                                                break;
                                              v33 = _mm_alignr_epi8(v30, v29, 1);
                                              v34 = v32;
                                              *(__m128i *)v2 = v33;
                                              v35 = *(__m128i *)(v3 + 31);
                                              v36 = _mm_cmpeq_epi8(v31, v35);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v36);
                                              v3 += 16;
                                              v37 = v35;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v35, v34, 1);
                                              v38 = *(__m128i *)(v3 + 31);
                                              v39 = v37;
                                              v40 = _mm_cmpeq_epi8(v36, v38);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v40);
                                              v3 += 16;
                                              v41 = v38;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v38, v39, 1);
                                              v42 = *(__m128i *)(v3 + 31);
                                              v5 = _mm_cmpeq_epi8(v40, v42);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v42, v41, 1);
                                              v43 = v3 + 31;
                                              v44 = (v3 + 31) & 0xFFFFFFC0;
                                              v45 = v43 - v44;
                                              v3 = v44 - 15;
                                              v2 = v2 + 16 - v45;
                                              v29 = *(__m128i *)(v3 - 1);
                                              while ( 1 )
                                              {
                                                v30 = *(__m128i *)(v3 + 15);
                                                v46 = *(__m128i *)(v3 + 31);
                                                v47 = *(__m128i *)(v3 + 47);
                                                v48 = *(__m128i *)(v3 + 63);
                                                v49 = _mm_movemask_epi8(
                                                        _mm_cmpeq_epi8(
                                                          _mm_min_epu8(_mm_min_epu8(v47, v48), _mm_min_epu8(v46, v30)),
                                                          v5));
                                                v50 = v48;
                                                v51 = _mm_alignr_epi8(v48, v47, 1);
                                                v52 = _mm_alignr_epi8(v47, v46, 1);
                                                if ( v49 )
                                                  break;
                                                v53 = _mm_alignr_epi8(v46, v30, 1);
                                                v3 += 64;
                                                v54 = _mm_alignr_epi8(v30, v29, 1);
                                                v29 = v50;
                                                *(__m128i *)(v2 + 48) = v51;
                                                *(__m128i *)(v2 + 32) = v52;
                                                *(__m128i *)(v2 + 16) = v53;
                                                *(__m128i *)v2 = v54;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)v2 = *(double *)v3;
                                            *(double *)(v2 + 7) = *(double *)(v3 + 7);
                                            v7 = 15;
                                            break;
                                          case 2u:
                                            v55 = *(__m128i *)(v3 - 2);
                                            v56 = *(__m128i *)(v3 + 14);
                                            while ( 1 )
                                            {
                                              v57 = _mm_cmpeq_epi8(v5, v56);
                                              v6 = _mm_movemask_epi8(v57);
                                              v58 = v56;
                                              if ( v6 )
                                                break;
                                              v59 = _mm_alignr_epi8(v56, v55, 2);
                                              v60 = v58;
                                              *(__m128i *)v2 = v59;
                                              v61 = *(__m128i *)(v3 + 30);
                                              v62 = _mm_cmpeq_epi8(v57, v61);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v62);
                                              v3 += 16;
                                              v63 = v61;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v61, v60, 2);
                                              v64 = *(__m128i *)(v3 + 30);
                                              v65 = v63;
                                              v66 = _mm_cmpeq_epi8(v62, v64);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v66);
                                              v3 += 16;
                                              v67 = v64;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v64, v65, 2);
                                              v68 = *(__m128i *)(v3 + 30);
                                              v5 = _mm_cmpeq_epi8(v66, v68);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v68, v67, 2);
                                              v69 = v3 + 30;
                                              v70 = (v3 + 30) & 0xFFFFFFC0;
                                              v71 = v69 - v70;
                                              v3 = v70 - 14;
                                              v2 = v2 + 16 - v71;
                                              v55 = *(__m128i *)(v3 - 2);
                                              while ( 1 )
                                              {
                                                v56 = *(__m128i *)(v3 + 14);
                                                v72 = *(__m128i *)(v3 + 30);
                                                v73 = *(__m128i *)(v3 + 46);
                                                v74 = *(__m128i *)(v3 + 62);
                                                v75 = _mm_movemask_epi8(
                                                        _mm_cmpeq_epi8(
                                                          _mm_min_epu8(_mm_min_epu8(v73, v74), _mm_min_epu8(v72, v56)),
                                                          v5));
                                                v76 = v74;
                                                v77 = _mm_alignr_epi8(v74, v73, 2);
                                                v78 = _mm_alignr_epi8(v73, v72, 2);
                                                if ( v75 )
                                                  break;
                                                v79 = _mm_alignr_epi8(v72, v56, 2);
                                                v3 += 64;
                                                v80 = _mm_alignr_epi8(v56, v55, 2);
                                                v55 = v76;
                                                *(__m128i *)(v2 + 48) = v77;
                                                *(__m128i *)(v2 + 32) = v78;
                                                *(__m128i *)(v2 + 16) = v79;
                                                *(__m128i *)v2 = v80;
                                                v2 += 64;
                                              }
                                            }
                                            v81 = *(double *)(v3 + 6);
                                            *(double *)v2 = *(double *)v3;
                                            *(double *)(v2 + 6) = v81;
                                            v7 = 14;
                                            break;
                                          case 3u:
                                            v82 = *(__m128i *)(v3 - 3);
                                            v83 = *(__m128i *)(v3 + 13);
                                            while ( 1 )
                                            {
                                              v84 = _mm_cmpeq_epi8(v5, v83);
                                              v6 = _mm_movemask_epi8(v84);
                                              v85 = v83;
                                              if ( v6 )
                                                break;
                                              v86 = _mm_alignr_epi8(v83, v82, 3);
                                              v87 = v85;
                                              *(__m128i *)v2 = v86;
                                              v88 = *(__m128i *)(v3 + 29);
                                              v89 = _mm_cmpeq_epi8(v84, v88);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v89);
                                              v3 += 16;
                                              v90 = v88;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v88, v87, 3);
                                              v91 = *(__m128i *)(v3 + 29);
                                              v92 = v90;
                                              v93 = _mm_cmpeq_epi8(v89, v91);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v93);
                                              v3 += 16;
                                              v94 = v91;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v91, v92, 3);
                                              v95 = *(__m128i *)(v3 + 29);
                                              v5 = _mm_cmpeq_epi8(v93, v95);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v95, v94, 3);
                                              v96 = v3 + 29;
                                              v97 = (v3 + 29) & 0xFFFFFFC0;
                                              v98 = v96 - v97;
                                              v3 = v97 - 13;
                                              v2 = v2 + 16 - v98;
                                              v82 = *(__m128i *)(v3 - 3);
                                              while ( 1 )
                                              {
                                                v83 = *(__m128i *)(v3 + 13);
                                                v99 = *(__m128i *)(v3 + 29);
                                                v100 = *(__m128i *)(v3 + 45);
                                                v101 = *(__m128i *)(v3 + 61);
                                                v102 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v100, v101),
                                                             _mm_min_epu8(v99, v83)),
                                                           v5));
                                                v103 = v101;
                                                v104 = _mm_alignr_epi8(v101, v100, 3);
                                                v105 = _mm_alignr_epi8(v100, v99, 3);
                                                if ( v102 )
                                                  break;
                                                v106 = _mm_alignr_epi8(v99, v83, 3);
                                                v3 += 64;
                                                v107 = _mm_alignr_epi8(v83, v82, 3);
                                                v82 = v103;
                                                *(__m128i *)(v2 + 48) = v104;
                                                *(__m128i *)(v2 + 32) = v105;
                                                *(__m128i *)(v2 + 16) = v106;
                                                *(__m128i *)v2 = v107;
                                                v2 += 64;
                                              }
                                            }
                                            v108 = *(double *)(v3 + 5);
                                            *(double *)v2 = *(double *)v3;
                                            *(double *)(v2 + 5) = v108;
                                            v7 = 13;
                                            break;
                                          case 4u:
                                            v109 = *(__m128i *)(v3 - 4);
                                            v110 = *(__m128i *)(v3 + 12);
                                            while ( 1 )
                                            {
                                              v111 = _mm_cmpeq_epi8(v5, v110);
                                              v6 = _mm_movemask_epi8(v111);
                                              v112 = v110;
                                              if ( v6 )
                                                break;
                                              v113 = _mm_alignr_epi8(v110, v109, 4);
                                              v114 = v112;
                                              *(__m128i *)v2 = v113;
                                              v115 = *(__m128i *)(v3 + 28);
                                              v116 = _mm_cmpeq_epi8(v111, v115);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v116);
                                              v3 += 16;
                                              v117 = v115;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v115, v114, 4);
                                              v118 = *(__m128i *)(v3 + 28);
                                              v119 = v117;
                                              v120 = _mm_cmpeq_epi8(v116, v118);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v120);
                                              v3 += 16;
                                              v121 = v118;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v118, v119, 4);
                                              v122 = *(__m128i *)(v3 + 28);
                                              v5 = _mm_cmpeq_epi8(v120, v122);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v122, v121, 4);
                                              v123 = v3 + 28;
                                              v124 = (v3 + 28) & 0xFFFFFFC0;
                                              v125 = v123 - v124;
                                              v3 = v124 - 12;
                                              v2 = v2 + 16 - v125;
                                              v109 = *(__m128i *)(v3 - 4);
                                              while ( 1 )
                                              {
                                                v110 = *(__m128i *)(v3 + 12);
                                                v126 = *(__m128i *)(v3 + 28);
                                                v127 = *(__m128i *)(v3 + 44);
                                                v128 = *(__m128i *)(v3 + 60);
                                                v129 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v127, v128),
                                                             _mm_min_epu8(v126, v110)),
                                                           v5));
                                                v130 = v128;
                                                v131 = _mm_alignr_epi8(v128, v127, 4);
                                                v132 = _mm_alignr_epi8(v127, v126, 4);
                                                if ( v129 )
                                                  break;
                                                v133 = _mm_alignr_epi8(v126, v110, 4);
                                                v3 += 64;
                                                v134 = _mm_alignr_epi8(v110, v109, 4);
                                                v109 = v130;
                                                *(__m128i *)(v2 + 48) = v131;
                                                *(__m128i *)(v2 + 32) = v132;
                                                *(__m128i *)(v2 + 16) = v133;
                                                *(__m128i *)v2 = v134;
                                                v2 += 64;
                                              }
                                            }
                                            v135 = *(_DWORD *)(v3 + 8);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 8) = v135;
                                            v7 = 12;
                                            break;
                                          case 5u:
                                            v136 = *(__m128i *)(v3 - 5);
                                            v137 = *(__m128i *)(v3 + 11);
                                            while ( 1 )
                                            {
                                              v138 = _mm_cmpeq_epi8(v5, v137);
                                              v6 = _mm_movemask_epi8(v138);
                                              v139 = v137;
                                              if ( v6 )
                                                break;
                                              v140 = _mm_alignr_epi8(v137, v136, 5);
                                              v141 = v139;
                                              *(__m128i *)v2 = v140;
                                              v142 = *(__m128i *)(v3 + 27);
                                              v143 = _mm_cmpeq_epi8(v138, v142);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v143);
                                              v3 += 16;
                                              v144 = v142;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v142, v141, 5);
                                              v145 = *(__m128i *)(v3 + 27);
                                              v146 = v144;
                                              v147 = _mm_cmpeq_epi8(v143, v145);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v147);
                                              v3 += 16;
                                              v148 = v145;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v145, v146, 5);
                                              v149 = *(__m128i *)(v3 + 27);
                                              v5 = _mm_cmpeq_epi8(v147, v149);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v149, v148, 5);
                                              v150 = v3 + 27;
                                              v151 = (v3 + 27) & 0xFFFFFFC0;
                                              v152 = v150 - v151;
                                              v3 = v151 - 11;
                                              v2 = v2 + 16 - v152;
                                              v136 = *(__m128i *)(v3 - 5);
                                              while ( 1 )
                                              {
                                                v137 = *(__m128i *)(v3 + 11);
                                                v153 = *(__m128i *)(v3 + 27);
                                                v154 = *(__m128i *)(v3 + 43);
                                                v155 = *(__m128i *)(v3 + 59);
                                                v156 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v154, v155),
                                                             _mm_min_epu8(v153, v137)),
                                                           v5));
                                                v157 = v155;
                                                v158 = _mm_alignr_epi8(v155, v154, 5);
                                                v159 = _mm_alignr_epi8(v154, v153, 5);
                                                if ( v156 )
                                                  break;
                                                v160 = _mm_alignr_epi8(v153, v137, 5);
                                                v3 += 64;
                                                v161 = _mm_alignr_epi8(v137, v136, 5);
                                                v136 = v157;
                                                *(__m128i *)(v2 + 48) = v158;
                                                *(__m128i *)(v2 + 32) = v159;
                                                *(__m128i *)(v2 + 16) = v160;
                                                *(__m128i *)v2 = v161;
                                                v2 += 64;
                                              }
                                            }
                                            v162 = *(_DWORD *)(v3 + 7);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 7) = v162;
                                            v7 = 11;
                                            break;
                                          case 6u:
                                            v163 = *(__m128i *)(v3 - 6);
                                            v164 = *(__m128i *)(v3 + 10);
                                            while ( 1 )
                                            {
                                              v165 = _mm_cmpeq_epi8(v5, v164);
                                              v6 = _mm_movemask_epi8(v165);
                                              v166 = v164;
                                              if ( v6 )
                                                break;
                                              v167 = _mm_alignr_epi8(v164, v163, 6);
                                              v168 = v166;
                                              *(__m128i *)v2 = v167;
                                              v169 = *(__m128i *)(v3 + 26);
                                              v170 = _mm_cmpeq_epi8(v165, v169);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v170);
                                              v3 += 16;
                                              v171 = v169;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v169, v168, 6);
                                              v172 = *(__m128i *)(v3 + 26);
                                              v173 = v171;
                                              v174 = _mm_cmpeq_epi8(v170, v172);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v174);
                                              v3 += 16;
                                              v175 = v172;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v172, v173, 6);
                                              v176 = *(__m128i *)(v3 + 26);
                                              v5 = _mm_cmpeq_epi8(v174, v176);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v176, v175, 6);
                                              v177 = v3 + 26;
                                              v178 = (v3 + 26) & 0xFFFFFFC0;
                                              v179 = v177 - v178;
                                              v3 = v178 - 10;
                                              v2 = v2 + 16 - v179;
                                              v163 = *(__m128i *)(v3 - 6);
                                              while ( 1 )
                                              {
                                                v164 = *(__m128i *)(v3 + 10);
                                                v180 = *(__m128i *)(v3 + 26);
                                                v181 = *(__m128i *)(v3 + 42);
                                                v182 = *(__m128i *)(v3 + 58);
                                                v183 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v181, v182),
                                                             _mm_min_epu8(v180, v164)),
                                                           v5));
                                                v184 = v182;
                                                v185 = _mm_alignr_epi8(v182, v181, 6);
                                                v186 = _mm_alignr_epi8(v181, v180, 6);
                                                if ( v183 )
                                                  break;
                                                v187 = _mm_alignr_epi8(v180, v164, 6);
                                                v3 += 64;
                                                v188 = _mm_alignr_epi8(v164, v163, 6);
                                                v163 = v184;
                                                *(__m128i *)(v2 + 48) = v185;
                                                *(__m128i *)(v2 + 32) = v186;
                                                *(__m128i *)(v2 + 16) = v187;
                                                *(__m128i *)v2 = v188;
                                                v2 += 64;
                                              }
                                            }
                                            v189 = *(_DWORD *)(v3 + 6);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 6) = v189;
                                            v7 = 10;
                                            break;
                                          default:
                                            v190 = *(__m128i *)(v3 - 7);
                                            v191 = *(__m128i *)(v3 + 9);
                                            while ( 1 )
                                            {
                                              v192 = _mm_cmpeq_epi8(v5, v191);
                                              v6 = _mm_movemask_epi8(v192);
                                              v193 = v191;
                                              if ( v6 )
                                                break;
                                              v194 = _mm_alignr_epi8(v191, v190, 7);
                                              v195 = v193;
                                              *(__m128i *)v2 = v194;
                                              v196 = *(__m128i *)(v3 + 25);
                                              v197 = _mm_cmpeq_epi8(v192, v196);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v197);
                                              v3 += 16;
                                              v198 = v196;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v196, v195, 7);
                                              v199 = *(__m128i *)(v3 + 25);
                                              v200 = v198;
                                              v201 = _mm_cmpeq_epi8(v197, v199);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v201);
                                              v3 += 16;
                                              v202 = v199;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v199, v200, 7);
                                              v203 = *(__m128i *)(v3 + 25);
                                              v5 = _mm_cmpeq_epi8(v201, v203);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v203, v202, 7);
                                              v204 = v3 + 25;
                                              v205 = (v3 + 25) & 0xFFFFFFC0;
                                              v206 = v204 - v205;
                                              v3 = v205 - 9;
                                              v2 = v2 + 16 - v206;
                                              v190 = *(__m128i *)(v3 - 7);
                                              while ( 1 )
                                              {
                                                v191 = *(__m128i *)(v3 + 9);
                                                v207 = *(__m128i *)(v3 + 25);
                                                v208 = *(__m128i *)(v3 + 41);
                                                v209 = *(__m128i *)(v3 + 57);
                                                v210 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v208, v209),
                                                             _mm_min_epu8(v207, v191)),
                                                           v5));
                                                v211 = v209;
                                                v212 = _mm_alignr_epi8(v209, v208, 7);
                                                v213 = _mm_alignr_epi8(v208, v207, 7);
                                                if ( v210 )
                                                  break;
                                                v214 = _mm_alignr_epi8(v207, v191, 7);
                                                v3 += 64;
                                                v215 = _mm_alignr_epi8(v191, v190, 7);
                                                v190 = v211;
                                                *(__m128i *)(v2 + 48) = v212;
                                                *(__m128i *)(v2 + 32) = v213;
                                                *(__m128i *)(v2 + 16) = v214;
                                                *(__m128i *)v2 = v215;
                                                v2 += 64;
                                              }
                                            }
                                            v216 = *(_DWORD *)(v3 + 5);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 5) = v216;
                                            v7 = 9;
                                            break;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      v9 = *(__m128i *)(v3 + 16);
                                      *(_OWORD *)v2 = *(_OWORD *)v3;
                                      v10 = _mm_cmpeq_epi8(v5, v9);
                                      v6 = _mm_movemask_epi8(v10);
                                      v7 = 16;
                                      if ( !v6 )
                                      {
                                        v11 = *(__m128i *)(v3 + 32);
                                        *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x10) = v9;
                                        v12 = _mm_cmpeq_epi8(v10, v11);
                                        v6 = _mm_movemask_epi8(v12);
                                        v7 = 32;
                                        if ( !v6 )
                                        {
                                          v13 = *(__m128i *)(v3 + 48);
                                          *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x20) = v11;
                                          v14 = _mm_cmpeq_epi8(v12, v13);
                                          v6 = _mm_movemask_epi8(v14);
                                          v7 = 48;
                                          if ( !v6 )
                                          {
                                            v15 = *(__m128i *)(v3 + 64);
                                            *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x30) = v13;
                                            v16 = _mm_cmpeq_epi8(v14, v15);
                                            v6 = _mm_movemask_epi8(v16);
                                            v7 = 64;
                                            if ( !v6 )
                                            {
                                              v17 = *(__m128i *)(v3 + 80);
                                              *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x40) = v15;
                                              v18 = _mm_cmpeq_epi8(v16, v17);
                                              v6 = _mm_movemask_epi8(v18);
                                              v7 = 80;
                                              if ( !v6 )
                                              {
                                                v19 = *(__m128i *)(v3 + 96);
                                                *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x50) = v17;
                                                v20 = _mm_cmpeq_epi8(v18, v19);
                                                v6 = _mm_movemask_epi8(v20);
                                                v7 = 96;
                                                if ( !v6 )
                                                {
                                                  *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x60) = v19;
                                                  v3 = (v3 + 112) & 0xFFFFFFC0;
                                                  v2 = v3 - (a2 - a1);
                                                  v7 = -64;
                                                  while ( 1 )
                                                  {
                                                    v21 = *(__m128i *)v3;
                                                    v22 = *(__m128i *)(v3 + 16);
                                                    v23 = *(__m128i *)(v3 + 32);
                                                    v24 = *(__m128i *)(v3 + 48);
                                                    v2 += 64;
                                                    v25 = _mm_cmpeq_epi8(
                                                            _mm_min_epu8(
                                                              _mm_min_epu8(v23, v24),
                                                              _mm_min_epu8(*(__m128i *)v3, v22)),
                                                            v20);
                                                    v3 += 64;
                                                    if ( _mm_movemask_epi8(v25) )
                                                      break;
                                                    *(__m128i *)(v2 - 64) = v21;
                                                    *(__m128i *)(v2 - 48) = v22;
                                                    *(__m128i *)(v2 - 32) = v23;
                                                    *(__m128i *)(v2 - 16) = v24;
                                                  }
                                                  v26 = _mm_cmpeq_epi8(v20, v21);
                                                  v6 = _mm_movemask_epi8(v26);
                                                  if ( !v6 )
                                                  {
                                                    v27 = _mm_cmpeq_epi8(v26, v22);
                                                    v6 = _mm_movemask_epi8(v27);
                                                    *(__m128i *)(v2 - 64) = v21;
                                                    v7 = -48;
                                                    if ( !v6 )
                                                    {
                                                      v28 = _mm_cmpeq_epi8(v27, v23);
                                                      v6 = _mm_movemask_epi8(v28);
                                                      *(__m128i *)(v2 - 48) = v22;
                                                      v7 = -32;
                                                      if ( !v6 )
                                                      {
                                                        *(__m128i *)(v2 - 32) = v23;
                                                        LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v28, v24));
                                                        v7 = -16;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  v425 = v7 + v2;
                                  v426 = v7 + v3;
                                  if ( (_BYTE)v6 )
                                  {
                                    if ( (v6 & 0xF) != 0 )
                                    {
                                      if ( (v6 & 1) != 0 )
                                      {
                                        *(_BYTE *)v425 = *(_BYTE *)v426;
                                        return a1;
                                      }
                                      else if ( (v6 & 2) != 0 )
                                      {
                                        *(_WORD *)v425 = *(_WORD *)v426;
                                        return a1;
                                      }
                                      else
                                      {
                                        if ( (v6 & 4) != 0 )
                                        {
                                          *(_WORD *)v425 = *(_WORD *)v426;
                                          *(_BYTE *)(v425 + 2) = *(_BYTE *)(v426 + 2);
                                        }
                                        else
                                        {
                                          *(_DWORD *)v425 = *(_DWORD *)v426;
                                        }
                                        return a1;
                                      }
                                    }
                                    else if ( (v6 & 0x10) != 0 )
                                    {
                                      *(_DWORD *)v425 = *(_DWORD *)v426;
                                      *(_BYTE *)(v425 + 4) = *(_BYTE *)(v426 + 4);
                                      return a1;
                                    }
                                    else if ( (v6 & 0x20) != 0 )
                                    {
                                      *(_DWORD *)v425 = *(_DWORD *)v426;
                                      *(_WORD *)(v425 + 4) = *(_WORD *)(v426 + 4);
                                      return a1;
                                    }
                                    else
                                    {
                                      if ( (v6 & 0x40) != 0 )
                                      {
                                        *(_DWORD *)v425 = *(_DWORD *)v426;
                                        *(_DWORD *)(v425 + 3) = *(_DWORD *)(v426 + 3);
                                      }
                                      else
                                      {
                                        *(double *)v425 = *(double *)v426;
                                      }
                                      return a1;
                                    }
                                  }
                                  else if ( (v6 & 0xF00) != 0 )
                                  {
                                    if ( (v6 & 0x100) != 0 )
                                    {
                                      v429 = *(_BYTE *)(v426 + 8);
                                      *(double *)v425 = *(double *)v426;
                                      *(_BYTE *)(v425 + 8) = v429;
                                      return a1;
                                    }
                                    else if ( (v6 & 0x200) != 0 )
                                    {
                                      v430 = *(_WORD *)(v426 + 8);
                                      *(double *)v425 = *(double *)v426;
                                      *(_WORD *)(v425 + 8) = v430;
                                      return a1;
                                    }
                                    else
                                    {
                                      if ( (v6 & 0x400) != 0 )
                                      {
                                        v431 = *(_DWORD *)(v426 + 7);
                                        *(double *)v425 = *(double *)v426;
                                        *(_DWORD *)(v425 + 7) = v431;
                                      }
                                      else
                                      {
                                        v428 = *(_DWORD *)(v426 + 8);
                                        *(double *)v425 = *(double *)v426;
                                        *(_DWORD *)(v425 + 8) = v428;
                                      }
                                      return a1;
                                    }
                                  }
                                  else if ( (v6 & 0x1000) != 0 )
                                  {
                                    v432 = *(double *)(v426 + 5);
                                    *(double *)v425 = *(double *)v426;
                                    *(double *)(v425 + 5) = v432;
                                    return a1;
                                  }
                                  else if ( (v6 & 0x2000) != 0 )
                                  {
                                    v433 = *(double *)(v426 + 6);
                                    *(double *)v425 = *(double *)v426;
                                    *(double *)(v425 + 6) = v433;
                                    return a1;
                                  }
                                  else
                                  {
                                    if ( (v6 & 0x4000) != 0 )
                                    {
                                      v434 = *(double *)(v426 + 7);
                                      *(double *)v425 = *(double *)v426;
                                      *(double *)(v425 + 7) = v434;
                                    }
                                    else
                                    {
                                      *(__m128i *)v425 = _mm_loadu_si128((const __m128i *)v426);
                                    }
                                    return a1;
                                  }
                                }
                                else
                                {
                                  *(__m128i *)a1 = _mm_loadu_si128((const __m128i *)a2);
                                  return a1;
                                }
                              }
                              else
                              {
                                v441 = *(double *)(a2 + 7);
                                *(double *)a1 = *(double *)a2;
                                *(double *)(a1 + 7) = v441;
                                return a1;
                              }
                            }
                            else
                            {
                              v440 = *(double *)(a2 + 6);
                              *(double *)a1 = *(double *)a2;
                              *(double *)(a1 + 6) = v440;
                              return a1;
                            }
                          }
                          else
                          {
                            v439 = *(double *)(a2 + 5);
                            *(double *)a1 = *(double *)a2;
                            *(double *)(a1 + 5) = v439;
                            return a1;
                          }
                        }
                        else
                        {
                          v438 = *(_DWORD *)(a2 + 8);
                          *(double *)a1 = *(double *)a2;
                          *(_DWORD *)(a1 + 8) = v438;
                          return a1;
                        }
                      }
                      else
                      {
                        v437 = *(_DWORD *)(a2 + 7);
                        *(double *)a1 = *(double *)a2;
                        *(_DWORD *)(a1 + 7) = v437;
                        return a1;
                      }
                    }
                    else
                    {
                      v436 = *(_WORD *)(a2 + 8);
                      *(double *)a1 = *(double *)a2;
                      *(_WORD *)(a1 + 8) = v436;
                      return a1;
                    }
                  }
                  else
                  {
                    v435 = *(_BYTE *)(a2 + 8);
                    *(double *)a1 = *(double *)a2;
                    *(_BYTE *)(a1 + 8) = v435;
                    return a1;
                  }
                }
                else
                {
                  *(double *)a1 = *(double *)a2;
                  return a1;
                }
              }
              else
              {
                *(_DWORD *)a1 = *(_DWORD *)a2;
                *(_DWORD *)(a1 + 3) = *(_DWORD *)(a2 + 3);
                return a1;
              }
            }
            else
            {
              *(_DWORD *)a1 = *(_DWORD *)a2;
              *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
              return a1;
            }
          }
          else
          {
            *(_DWORD *)a1 = *(_DWORD *)a2;
            *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
            return a1;
          }
        }
        else
        {
          *(_DWORD *)a1 = *(_DWORD *)a2;
          return a1;
        }
      }
      else
      {
        *(_WORD *)a1 = *(_WORD *)a2;
        *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
        return a1;
      }
    }
    else
    {
      *(_WORD *)a1 = *(_WORD *)a2;
      return a1;
    }
  }
  else
  {
    *(_BYTE *)a1 = *(_BYTE *)a2;
    return a1;
  }
}

//----- (08066420) --------------------------------------------------------
unsigned int __cdecl _stpcpy_ssse3(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // edx
  unsigned int v3; // ecx
  __m128i *v4; // esi
  __m128i v5; // xmm0
  int v6; // eax
  int v7; // esi
  unsigned int v8; // eax
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  __m128i v11; // xmm3
  __m128i v12; // xmm0
  __m128i v13; // xmm4
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  __m128i v18; // xmm0
  __m128i v19; // xmm3
  __m128i v20; // xmm0
  __m128i v21; // xmm4
  __m128i v22; // xmm5
  __m128i v23; // xmm6
  __m128i v24; // xmm7
  __m128i v25; // xmm3
  __m128i v26; // xmm0
  __m128i v27; // xmm0
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  __m128i v30; // xmm2
  __m128i v31; // xmm0
  __m128i v32; // xmm3
  __m128i v33; // xmm2
  __m128i v34; // xmm1
  __m128i v35; // xmm2
  __m128i v36; // xmm0
  __m128i v37; // xmm3
  __m128i v38; // xmm2
  __m128i v39; // xmm1
  __m128i v40; // xmm0
  __m128i v41; // xmm3
  __m128i v42; // xmm2
  unsigned int v43; // eax
  unsigned int v44; // ecx
  unsigned int v45; // eax
  __m128i v46; // xmm3
  __m128i v47; // xmm4
  __m128i v48; // xmm5
  int v49; // eax
  __m128i v50; // xmm7
  __m128i v51; // xmm5
  __m128i v52; // xmm4
  __m128i v53; // xmm3
  __m128i v54; // xmm2
  __m128i v55; // xmm1
  __m128i v56; // xmm2
  __m128i v57; // xmm0
  __m128i v58; // xmm3
  __m128i v59; // xmm2
  __m128i v60; // xmm1
  __m128i v61; // xmm2
  __m128i v62; // xmm0
  __m128i v63; // xmm3
  __m128i v64; // xmm2
  __m128i v65; // xmm1
  __m128i v66; // xmm0
  __m128i v67; // xmm3
  __m128i v68; // xmm2
  unsigned int v69; // eax
  unsigned int v70; // ecx
  unsigned int v71; // eax
  __m128i v72; // xmm3
  __m128i v73; // xmm4
  __m128i v74; // xmm5
  int v75; // eax
  __m128i v76; // xmm7
  __m128i v77; // xmm5
  __m128i v78; // xmm4
  __m128i v79; // xmm3
  __m128i v80; // xmm2
  double v81; // xmm1_8
  __m128i v82; // xmm1
  __m128i v83; // xmm2
  __m128i v84; // xmm0
  __m128i v85; // xmm3
  __m128i v86; // xmm2
  __m128i v87; // xmm1
  __m128i v88; // xmm2
  __m128i v89; // xmm0
  __m128i v90; // xmm3
  __m128i v91; // xmm2
  __m128i v92; // xmm1
  __m128i v93; // xmm0
  __m128i v94; // xmm3
  __m128i v95; // xmm2
  unsigned int v96; // eax
  unsigned int v97; // ecx
  unsigned int v98; // eax
  __m128i v99; // xmm3
  __m128i v100; // xmm4
  __m128i v101; // xmm5
  int v102; // eax
  __m128i v103; // xmm7
  __m128i v104; // xmm5
  __m128i v105; // xmm4
  __m128i v106; // xmm3
  __m128i v107; // xmm2
  double v108; // xmm1_8
  __m128i v109; // xmm1
  __m128i v110; // xmm2
  __m128i v111; // xmm0
  __m128i v112; // xmm3
  __m128i v113; // xmm2
  __m128i v114; // xmm1
  __m128i v115; // xmm2
  __m128i v116; // xmm0
  __m128i v117; // xmm3
  __m128i v118; // xmm2
  __m128i v119; // xmm1
  __m128i v120; // xmm0
  __m128i v121; // xmm3
  __m128i v122; // xmm2
  unsigned int v123; // eax
  unsigned int v124; // ecx
  unsigned int v125; // eax
  __m128i v126; // xmm3
  __m128i v127; // xmm4
  __m128i v128; // xmm5
  int v129; // eax
  __m128i v130; // xmm7
  __m128i v131; // xmm5
  __m128i v132; // xmm4
  __m128i v133; // xmm3
  __m128i v134; // xmm2
  int v135; // esi
  __m128i v136; // xmm1
  __m128i v137; // xmm2
  __m128i v138; // xmm0
  __m128i v139; // xmm3
  __m128i v140; // xmm2
  __m128i v141; // xmm1
  __m128i v142; // xmm2
  __m128i v143; // xmm0
  __m128i v144; // xmm3
  __m128i v145; // xmm2
  __m128i v146; // xmm1
  __m128i v147; // xmm0
  __m128i v148; // xmm3
  __m128i v149; // xmm2
  unsigned int v150; // eax
  unsigned int v151; // ecx
  unsigned int v152; // eax
  __m128i v153; // xmm3
  __m128i v154; // xmm4
  __m128i v155; // xmm5
  int v156; // eax
  __m128i v157; // xmm7
  __m128i v158; // xmm5
  __m128i v159; // xmm4
  __m128i v160; // xmm3
  __m128i v161; // xmm2
  int v162; // esi
  __m128i v163; // xmm1
  __m128i v164; // xmm2
  __m128i v165; // xmm0
  __m128i v166; // xmm3
  __m128i v167; // xmm2
  __m128i v168; // xmm1
  __m128i v169; // xmm2
  __m128i v170; // xmm0
  __m128i v171; // xmm3
  __m128i v172; // xmm2
  __m128i v173; // xmm1
  __m128i v174; // xmm0
  __m128i v175; // xmm3
  __m128i v176; // xmm2
  unsigned int v177; // eax
  unsigned int v178; // ecx
  unsigned int v179; // eax
  __m128i v180; // xmm3
  __m128i v181; // xmm4
  __m128i v182; // xmm5
  int v183; // eax
  __m128i v184; // xmm7
  __m128i v185; // xmm5
  __m128i v186; // xmm4
  __m128i v187; // xmm3
  __m128i v188; // xmm2
  int v189; // esi
  __m128i v190; // xmm1
  __m128i v191; // xmm2
  __m128i v192; // xmm0
  __m128i v193; // xmm3
  __m128i v194; // xmm2
  __m128i v195; // xmm1
  __m128i v196; // xmm2
  __m128i v197; // xmm0
  __m128i v198; // xmm3
  __m128i v199; // xmm2
  __m128i v200; // xmm1
  __m128i v201; // xmm0
  __m128i v202; // xmm3
  __m128i v203; // xmm2
  unsigned int v204; // eax
  unsigned int v205; // ecx
  unsigned int v206; // eax
  __m128i v207; // xmm3
  __m128i v208; // xmm4
  __m128i v209; // xmm5
  int v210; // eax
  __m128i v211; // xmm7
  __m128i v212; // xmm5
  __m128i v213; // xmm4
  __m128i v214; // xmm3
  __m128i v215; // xmm2
  int v216; // esi
  __m128i v217; // xmm1
  __m128i v218; // xmm2
  __m128i v219; // xmm0
  __m128i v220; // xmm3
  __m128i v221; // xmm2
  __m128i v222; // xmm1
  __m128i v223; // xmm2
  __m128i v224; // xmm0
  __m128i v225; // xmm3
  __m128i v226; // xmm2
  __m128i v227; // xmm1
  __m128i v228; // xmm0
  __m128i v229; // xmm3
  __m128i v230; // xmm2
  unsigned int v231; // eax
  unsigned int v232; // ecx
  unsigned int v233; // eax
  __m128i v234; // xmm3
  __m128i v235; // xmm4
  __m128i v236; // xmm5
  int v237; // eax
  __m128i v238; // xmm7
  __m128i v239; // xmm5
  __m128i v240; // xmm4
  __m128i v241; // xmm3
  __m128i v242; // xmm2
  __m128i v243; // xmm1
  __m128i v244; // xmm2
  __m128i v245; // xmm0
  __m128i v246; // xmm3
  __m128i v247; // xmm2
  __m128i v248; // xmm1
  __m128i v249; // xmm2
  __m128i v250; // xmm0
  __m128i v251; // xmm3
  __m128i v252; // xmm2
  __m128i v253; // xmm1
  __m128i v254; // xmm0
  __m128i v255; // xmm3
  __m128i v256; // xmm2
  unsigned int v257; // eax
  unsigned int v258; // ecx
  unsigned int v259; // eax
  __m128i v260; // xmm3
  __m128i v261; // xmm4
  __m128i v262; // xmm5
  int v263; // eax
  __m128i v264; // xmm7
  __m128i v265; // xmm5
  __m128i v266; // xmm4
  __m128i v267; // xmm3
  __m128i v268; // xmm2
  __m128i v269; // xmm1
  __m128i v270; // xmm2
  __m128i v271; // xmm0
  __m128i v272; // xmm3
  __m128i v273; // xmm2
  __m128i v274; // xmm1
  __m128i v275; // xmm2
  __m128i v276; // xmm0
  __m128i v277; // xmm3
  __m128i v278; // xmm2
  __m128i v279; // xmm1
  __m128i v280; // xmm0
  __m128i v281; // xmm3
  __m128i v282; // xmm2
  unsigned int v283; // eax
  unsigned int v284; // ecx
  unsigned int v285; // eax
  __m128i v286; // xmm3
  __m128i v287; // xmm4
  __m128i v288; // xmm5
  int v289; // eax
  __m128i v290; // xmm7
  __m128i v291; // xmm5
  __m128i v292; // xmm4
  __m128i v293; // xmm3
  __m128i v294; // xmm2
  __m128i v295; // xmm1
  __m128i v296; // xmm2
  __m128i v297; // xmm0
  __m128i v298; // xmm3
  __m128i v299; // xmm2
  __m128i v300; // xmm1
  __m128i v301; // xmm2
  __m128i v302; // xmm0
  __m128i v303; // xmm3
  __m128i v304; // xmm2
  __m128i v305; // xmm1
  __m128i v306; // xmm0
  __m128i v307; // xmm3
  __m128i v308; // xmm2
  unsigned int v309; // eax
  unsigned int v310; // ecx
  unsigned int v311; // eax
  __m128i v312; // xmm3
  __m128i v313; // xmm4
  __m128i v314; // xmm5
  int v315; // eax
  __m128i v316; // xmm7
  __m128i v317; // xmm5
  __m128i v318; // xmm4
  __m128i v319; // xmm3
  __m128i v320; // xmm2
  __m128i v321; // xmm1
  __m128i v322; // xmm2
  __m128i v323; // xmm0
  __m128i v324; // xmm3
  __m128i v325; // xmm2
  __m128i v326; // xmm1
  __m128i v327; // xmm2
  __m128i v328; // xmm0
  __m128i v329; // xmm3
  __m128i v330; // xmm2
  __m128i v331; // xmm1
  __m128i v332; // xmm0
  __m128i v333; // xmm3
  __m128i v334; // xmm2
  unsigned int v335; // eax
  unsigned int v336; // ecx
  unsigned int v337; // eax
  __m128i v338; // xmm3
  __m128i v339; // xmm4
  __m128i v340; // xmm5
  int v341; // eax
  __m128i v342; // xmm7
  __m128i v343; // xmm5
  __m128i v344; // xmm4
  __m128i v345; // xmm3
  __m128i v346; // xmm2
  __m128i v347; // xmm1
  __m128i v348; // xmm2
  __m128i v349; // xmm0
  __m128i v350; // xmm3
  __m128i v351; // xmm2
  __m128i v352; // xmm1
  __m128i v353; // xmm2
  __m128i v354; // xmm0
  __m128i v355; // xmm3
  __m128i v356; // xmm2
  __m128i v357; // xmm1
  __m128i v358; // xmm0
  __m128i v359; // xmm3
  __m128i v360; // xmm2
  unsigned int v361; // eax
  unsigned int v362; // ecx
  unsigned int v363; // eax
  __m128i v364; // xmm3
  __m128i v365; // xmm4
  __m128i v366; // xmm5
  int v367; // eax
  __m128i v368; // xmm7
  __m128i v369; // xmm5
  __m128i v370; // xmm4
  __m128i v371; // xmm3
  __m128i v372; // xmm2
  __m128i v373; // xmm1
  __m128i v374; // xmm2
  __m128i v375; // xmm0
  __m128i v376; // xmm3
  __m128i v377; // xmm2
  __m128i v378; // xmm1
  __m128i v379; // xmm2
  __m128i v380; // xmm0
  __m128i v381; // xmm3
  __m128i v382; // xmm2
  __m128i v383; // xmm1
  __m128i v384; // xmm0
  __m128i v385; // xmm3
  __m128i v386; // xmm2
  unsigned int v387; // eax
  unsigned int v388; // ecx
  unsigned int v389; // eax
  __m128i v390; // xmm3
  __m128i v391; // xmm4
  __m128i v392; // xmm5
  int v393; // eax
  __m128i v394; // xmm7
  __m128i v395; // xmm5
  __m128i v396; // xmm4
  __m128i v397; // xmm3
  __m128i v398; // xmm2
  __m128i v399; // xmm1
  __m128i v400; // xmm2
  __m128i v401; // xmm0
  __m128i v402; // xmm3
  __m128i v403; // xmm2
  __m128i v404; // xmm1
  __m128i v405; // xmm2
  __m128i v406; // xmm0
  __m128i v407; // xmm3
  __m128i v408; // xmm2
  __m128i v409; // xmm1
  __m128i v410; // xmm0
  __m128i v411; // xmm3
  __m128i v412; // xmm2
  unsigned int v413; // eax
  unsigned int v414; // ecx
  unsigned int v415; // eax
  __m128i v416; // xmm3
  __m128i v417; // xmm4
  __m128i v418; // xmm5
  int v419; // eax
  __m128i v420; // xmm7
  __m128i v421; // xmm5
  __m128i v422; // xmm4
  __m128i v423; // xmm3
  __m128i v424; // xmm2
  unsigned int v425; // edx
  unsigned int v426; // ecx
  int v428; // eax
  char v429; // al
  __int16 v430; // ax
  int v431; // eax
  double v432; // xmm1_8
  double v433; // xmm1_8
  double v434; // xmm1_8
  char v435; // al
  __int16 v436; // ax
  int v437; // eax
  int v438; // eax
  double v439; // xmm1_8
  double v440; // xmm1_8
  double v441; // xmm1_8

  v2 = a1;
  v3 = a2;
  if ( *(_BYTE *)a2 )
  {
    if ( *(_BYTE *)(a2 + 1) )
    {
      if ( *(_BYTE *)(a2 + 2) )
      {
        if ( *(_BYTE *)(a2 + 3) )
        {
          if ( *(_BYTE *)(a2 + 4) )
          {
            if ( *(_BYTE *)(a2 + 5) )
            {
              if ( *(_BYTE *)(a2 + 6) )
              {
                if ( *(_BYTE *)(a2 + 7) )
                {
                  if ( *(_BYTE *)(a2 + 8) )
                  {
                    if ( *(_BYTE *)(a2 + 9) )
                    {
                      if ( *(_BYTE *)(a2 + 10) )
                      {
                        if ( *(_BYTE *)(a2 + 11) )
                        {
                          if ( *(_BYTE *)(a2 + 12) )
                          {
                            if ( *(_BYTE *)(a2 + 13) )
                            {
                              if ( *(_BYTE *)(a2 + 14) )
                              {
                                if ( *(_BYTE *)(a2 + 15) )
                                {
                                  v4 = (__m128i *)((a2 + 16) & 0xFFFFFFF0);
                                  *(double *)a1 = *(double *)a2;
                                  v5 = _mm_cmpeq_epi8((__m128i)0LL, *v4);
                                  *(double *)(a1 + 8) = *(double *)(a2 + 8);
                                  v6 = _mm_movemask_epi8(v5);
                                  v7 = (int)v4->m128i_i32 - a2;
                                  if ( !v6 )
                                  {
                                    v2 = (a1 + 16) & 0xFFFFFFF0;
                                    v3 = a2 - (a1 - v2);
                                    v8 = v3 & 0xF;
                                    if ( (v3 & 0xF) != 0 )
                                    {
                                      if ( v8 >= 8 )
                                      {
                                        switch ( v8 )
                                        {
                                          case 8u:
                                            v217 = *(__m128i *)(v3 - 8);
                                            v218 = *(__m128i *)(v3 + 8);
                                            while ( 1 )
                                            {
                                              v219 = _mm_cmpeq_epi8(v5, v218);
                                              v6 = _mm_movemask_epi8(v219);
                                              v220 = v218;
                                              if ( v6 )
                                                break;
                                              v221 = _mm_alignr_epi8(v218, v217, 8);
                                              v222 = v220;
                                              *(__m128i *)v2 = v221;
                                              v223 = *(__m128i *)(v3 + 24);
                                              v224 = _mm_cmpeq_epi8(v219, v223);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v224);
                                              v3 += 16;
                                              v225 = v223;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v223, v222, 8);
                                              v226 = *(__m128i *)(v3 + 24);
                                              v227 = v225;
                                              v228 = _mm_cmpeq_epi8(v224, v226);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v228);
                                              v3 += 16;
                                              v229 = v226;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v226, v227, 8);
                                              v230 = *(__m128i *)(v3 + 24);
                                              v5 = _mm_cmpeq_epi8(v228, v230);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v230, v229, 8);
                                              v231 = v3 + 24;
                                              v232 = (v3 + 24) & 0xFFFFFFC0;
                                              v233 = v231 - v232;
                                              v3 = v232 - 8;
                                              v2 = v2 + 16 - v233;
                                              v217 = *(__m128i *)(v3 - 8);
                                              while ( 1 )
                                              {
                                                v218 = *(__m128i *)(v3 + 8);
                                                v234 = *(__m128i *)(v3 + 24);
                                                v235 = *(__m128i *)(v3 + 40);
                                                v236 = *(__m128i *)(v3 + 56);
                                                v237 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v235, v236),
                                                             _mm_min_epu8(v234, v218)),
                                                           v5));
                                                v238 = v236;
                                                v239 = _mm_alignr_epi8(v236, v235, 8);
                                                v240 = _mm_alignr_epi8(v235, v234, 8);
                                                if ( v237 )
                                                  break;
                                                v241 = _mm_alignr_epi8(v234, v218, 8);
                                                v3 += 64;
                                                v242 = _mm_alignr_epi8(v218, v217, 8);
                                                v217 = v238;
                                                *(__m128i *)(v2 + 48) = v239;
                                                *(__m128i *)(v2 + 32) = v240;
                                                *(__m128i *)(v2 + 16) = v241;
                                                *(__m128i *)v2 = v242;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)v2 = *(double *)v3;
                                            v7 = 8;
                                            break;
                                          case 9u:
                                            v243 = *(__m128i *)(v3 - 9);
                                            v244 = *(__m128i *)(v3 + 7);
                                            while ( 1 )
                                            {
                                              v245 = _mm_cmpeq_epi8(v5, v244);
                                              v6 = _mm_movemask_epi8(v245);
                                              v246 = v244;
                                              if ( v6 )
                                                break;
                                              v247 = _mm_alignr_epi8(v244, v243, 9);
                                              v248 = v246;
                                              *(__m128i *)v2 = v247;
                                              v249 = *(__m128i *)(v3 + 23);
                                              v250 = _mm_cmpeq_epi8(v245, v249);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v250);
                                              v3 += 16;
                                              v251 = v249;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v249, v248, 9);
                                              v252 = *(__m128i *)(v3 + 23);
                                              v253 = v251;
                                              v254 = _mm_cmpeq_epi8(v250, v252);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v254);
                                              v3 += 16;
                                              v255 = v252;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v252, v253, 9);
                                              v256 = *(__m128i *)(v3 + 23);
                                              v5 = _mm_cmpeq_epi8(v254, v256);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v256, v255, 9);
                                              v257 = v3 + 23;
                                              v258 = (v3 + 23) & 0xFFFFFFC0;
                                              v259 = v257 - v258;
                                              v3 = v258 - 7;
                                              v2 = v2 + 16 - v259;
                                              v243 = *(__m128i *)(v3 - 9);
                                              while ( 1 )
                                              {
                                                v244 = *(__m128i *)(v3 + 7);
                                                v260 = *(__m128i *)(v3 + 23);
                                                v261 = *(__m128i *)(v3 + 39);
                                                v262 = *(__m128i *)(v3 + 55);
                                                v263 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v261, v262),
                                                             _mm_min_epu8(v260, v244)),
                                                           v5));
                                                v264 = v262;
                                                v265 = _mm_alignr_epi8(v262, v261, 9);
                                                v266 = _mm_alignr_epi8(v261, v260, 9);
                                                if ( v263 )
                                                  break;
                                                v267 = _mm_alignr_epi8(v260, v244, 9);
                                                v3 += 64;
                                                v268 = _mm_alignr_epi8(v244, v243, 9);
                                                v243 = v264;
                                                *(__m128i *)(v2 + 48) = v265;
                                                *(__m128i *)(v2 + 32) = v266;
                                                *(__m128i *)(v2 + 16) = v267;
                                                *(__m128i *)v2 = v268;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)(v2 - 1) = *(double *)(v3 - 1);
                                            v7 = 7;
                                            break;
                                          case 0xAu:
                                            v269 = *(__m128i *)(v3 - 10);
                                            v270 = *(__m128i *)(v3 + 6);
                                            while ( 1 )
                                            {
                                              v271 = _mm_cmpeq_epi8(v5, v270);
                                              v6 = _mm_movemask_epi8(v271);
                                              v272 = v270;
                                              if ( v6 )
                                                break;
                                              v273 = _mm_alignr_epi8(v270, v269, 10);
                                              v274 = v272;
                                              *(__m128i *)v2 = v273;
                                              v275 = *(__m128i *)(v3 + 22);
                                              v276 = _mm_cmpeq_epi8(v271, v275);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v276);
                                              v3 += 16;
                                              v277 = v275;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v275, v274, 10);
                                              v278 = *(__m128i *)(v3 + 22);
                                              v279 = v277;
                                              v280 = _mm_cmpeq_epi8(v276, v278);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v280);
                                              v3 += 16;
                                              v281 = v278;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v278, v279, 10);
                                              v282 = *(__m128i *)(v3 + 22);
                                              v5 = _mm_cmpeq_epi8(v280, v282);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v282, v281, 10);
                                              v283 = v3 + 22;
                                              v284 = (v3 + 22) & 0xFFFFFFC0;
                                              v285 = v283 - v284;
                                              v3 = v284 - 6;
                                              v2 = v2 + 16 - v285;
                                              v269 = *(__m128i *)(v3 - 10);
                                              while ( 1 )
                                              {
                                                v270 = *(__m128i *)(v3 + 6);
                                                v286 = *(__m128i *)(v3 + 22);
                                                v287 = *(__m128i *)(v3 + 38);
                                                v288 = *(__m128i *)(v3 + 54);
                                                v289 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v287, v288),
                                                             _mm_min_epu8(v286, v270)),
                                                           v5));
                                                v290 = v288;
                                                v291 = _mm_alignr_epi8(v288, v287, 10);
                                                v292 = _mm_alignr_epi8(v287, v286, 10);
                                                if ( v289 )
                                                  break;
                                                v293 = _mm_alignr_epi8(v286, v270, 10);
                                                v3 += 64;
                                                v294 = _mm_alignr_epi8(v270, v269, 10);
                                                v269 = v290;
                                                *(__m128i *)(v2 + 48) = v291;
                                                *(__m128i *)(v2 + 32) = v292;
                                                *(__m128i *)(v2 + 16) = v293;
                                                *(__m128i *)v2 = v294;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)(v2 - 2) = *(double *)(v3 - 2);
                                            v7 = 6;
                                            break;
                                          case 0xBu:
                                            v295 = *(__m128i *)(v3 - 11);
                                            v296 = *(__m128i *)(v3 + 5);
                                            while ( 1 )
                                            {
                                              v297 = _mm_cmpeq_epi8(v5, v296);
                                              v6 = _mm_movemask_epi8(v297);
                                              v298 = v296;
                                              if ( v6 )
                                                break;
                                              v299 = _mm_alignr_epi8(v296, v295, 11);
                                              v300 = v298;
                                              *(__m128i *)v2 = v299;
                                              v301 = *(__m128i *)(v3 + 21);
                                              v302 = _mm_cmpeq_epi8(v297, v301);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v302);
                                              v3 += 16;
                                              v303 = v301;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v301, v300, 11);
                                              v304 = *(__m128i *)(v3 + 21);
                                              v305 = v303;
                                              v306 = _mm_cmpeq_epi8(v302, v304);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v306);
                                              v3 += 16;
                                              v307 = v304;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v304, v305, 11);
                                              v308 = *(__m128i *)(v3 + 21);
                                              v5 = _mm_cmpeq_epi8(v306, v308);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v308, v307, 11);
                                              v309 = v3 + 21;
                                              v310 = (v3 + 21) & 0xFFFFFFC0;
                                              v311 = v309 - v310;
                                              v3 = v310 - 5;
                                              v2 = v2 + 16 - v311;
                                              v295 = *(__m128i *)(v3 - 11);
                                              while ( 1 )
                                              {
                                                v296 = *(__m128i *)(v3 + 5);
                                                v312 = *(__m128i *)(v3 + 21);
                                                v313 = *(__m128i *)(v3 + 37);
                                                v314 = *(__m128i *)(v3 + 53);
                                                v315 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v313, v314),
                                                             _mm_min_epu8(v312, v296)),
                                                           v5));
                                                v316 = v314;
                                                v317 = _mm_alignr_epi8(v314, v313, 11);
                                                v318 = _mm_alignr_epi8(v313, v312, 11);
                                                if ( v315 )
                                                  break;
                                                v319 = _mm_alignr_epi8(v312, v296, 11);
                                                v3 += 64;
                                                v320 = _mm_alignr_epi8(v296, v295, 11);
                                                v295 = v316;
                                                *(__m128i *)(v2 + 48) = v317;
                                                *(__m128i *)(v2 + 32) = v318;
                                                *(__m128i *)(v2 + 16) = v319;
                                                *(__m128i *)v2 = v320;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)(v2 - 3) = *(double *)(v3 - 3);
                                            v7 = 5;
                                            break;
                                          case 0xCu:
                                            v321 = *(__m128i *)(v3 - 12);
                                            v322 = *(__m128i *)(v3 + 4);
                                            while ( 1 )
                                            {
                                              v323 = _mm_cmpeq_epi8(v5, v322);
                                              v6 = _mm_movemask_epi8(v323);
                                              v324 = v322;
                                              if ( v6 )
                                                break;
                                              v325 = _mm_alignr_epi8(v322, v321, 12);
                                              v326 = v324;
                                              *(__m128i *)v2 = v325;
                                              v327 = *(__m128i *)(v3 + 20);
                                              v328 = _mm_cmpeq_epi8(v323, v327);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v328);
                                              v3 += 16;
                                              v329 = v327;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v327, v326, 12);
                                              v330 = *(__m128i *)(v3 + 20);
                                              v331 = v329;
                                              v332 = _mm_cmpeq_epi8(v328, v330);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v332);
                                              v3 += 16;
                                              v333 = v330;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v330, v331, 12);
                                              v334 = *(__m128i *)(v3 + 20);
                                              v5 = _mm_cmpeq_epi8(v332, v334);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v334, v333, 12);
                                              v335 = v3 + 20;
                                              v336 = (v3 + 20) & 0xFFFFFFC0;
                                              v337 = v335 - v336;
                                              v3 = v336 - 4;
                                              v2 = v2 + 16 - v337;
                                              v321 = *(__m128i *)(v3 - 12);
                                              while ( 1 )
                                              {
                                                v322 = *(__m128i *)(v3 + 4);
                                                v338 = *(__m128i *)(v3 + 20);
                                                v339 = *(__m128i *)(v3 + 36);
                                                v340 = *(__m128i *)(v3 + 52);
                                                v341 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v339, v340),
                                                             _mm_min_epu8(v338, v322)),
                                                           v5));
                                                v342 = v340;
                                                v343 = _mm_alignr_epi8(v340, v339, 12);
                                                v344 = _mm_alignr_epi8(v339, v338, 12);
                                                if ( v341 )
                                                  break;
                                                v345 = _mm_alignr_epi8(v338, v322, 12);
                                                v3 += 64;
                                                v346 = _mm_alignr_epi8(v322, v321, 12);
                                                v321 = v342;
                                                *(__m128i *)(v2 + 48) = v343;
                                                *(__m128i *)(v2 + 32) = v344;
                                                *(__m128i *)(v2 + 16) = v345;
                                                *(__m128i *)v2 = v346;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)v2 = *(_DWORD *)v3;
                                            v7 = 4;
                                            break;
                                          case 0xDu:
                                            v347 = *(__m128i *)(v3 - 13);
                                            v348 = *(__m128i *)(v3 + 3);
                                            while ( 1 )
                                            {
                                              v349 = _mm_cmpeq_epi8(v5, v348);
                                              v6 = _mm_movemask_epi8(v349);
                                              v350 = v348;
                                              if ( v6 )
                                                break;
                                              v351 = _mm_alignr_epi8(v348, v347, 13);
                                              v352 = v350;
                                              *(__m128i *)v2 = v351;
                                              v353 = *(__m128i *)(v3 + 19);
                                              v354 = _mm_cmpeq_epi8(v349, v353);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v354);
                                              v3 += 16;
                                              v355 = v353;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v353, v352, 13);
                                              v356 = *(__m128i *)(v3 + 19);
                                              v357 = v355;
                                              v358 = _mm_cmpeq_epi8(v354, v356);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v358);
                                              v3 += 16;
                                              v359 = v356;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v356, v357, 13);
                                              v360 = *(__m128i *)(v3 + 19);
                                              v5 = _mm_cmpeq_epi8(v358, v360);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v360, v359, 13);
                                              v361 = v3 + 19;
                                              v362 = (v3 + 19) & 0xFFFFFFC0;
                                              v363 = v361 - v362;
                                              v3 = v362 - 3;
                                              v2 = v2 + 16 - v363;
                                              v347 = *(__m128i *)(v3 - 13);
                                              while ( 1 )
                                              {
                                                v348 = *(__m128i *)(v3 + 3);
                                                v364 = *(__m128i *)(v3 + 19);
                                                v365 = *(__m128i *)(v3 + 35);
                                                v366 = *(__m128i *)(v3 + 51);
                                                v367 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v365, v366),
                                                             _mm_min_epu8(v364, v348)),
                                                           v5));
                                                v368 = v366;
                                                v369 = _mm_alignr_epi8(v366, v365, 13);
                                                v370 = _mm_alignr_epi8(v365, v364, 13);
                                                if ( v367 )
                                                  break;
                                                v371 = _mm_alignr_epi8(v364, v348, 13);
                                                v3 += 64;
                                                v372 = _mm_alignr_epi8(v348, v347, 13);
                                                v347 = v368;
                                                *(__m128i *)(v2 + 48) = v369;
                                                *(__m128i *)(v2 + 32) = v370;
                                                *(__m128i *)(v2 + 16) = v371;
                                                *(__m128i *)v2 = v372;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)(v2 - 1) = *(_DWORD *)(v3 - 1);
                                            v7 = 3;
                                            break;
                                          case 0xEu:
                                            v373 = *(__m128i *)(v3 - 14);
                                            v374 = *(__m128i *)(v3 + 2);
                                            while ( 1 )
                                            {
                                              v375 = _mm_cmpeq_epi8(v5, v374);
                                              v6 = _mm_movemask_epi8(v375);
                                              v376 = v374;
                                              if ( v6 )
                                                break;
                                              v377 = _mm_alignr_epi8(v374, v373, 14);
                                              v378 = v376;
                                              *(__m128i *)v2 = v377;
                                              v379 = *(__m128i *)(v3 + 18);
                                              v380 = _mm_cmpeq_epi8(v375, v379);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v380);
                                              v3 += 16;
                                              v381 = v379;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v379, v378, 14);
                                              v382 = *(__m128i *)(v3 + 18);
                                              v383 = v381;
                                              v384 = _mm_cmpeq_epi8(v380, v382);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v384);
                                              v3 += 16;
                                              v385 = v382;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v382, v383, 14);
                                              v386 = *(__m128i *)(v3 + 18);
                                              v5 = _mm_cmpeq_epi8(v384, v386);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v386, v385, 14);
                                              v387 = v3 + 18;
                                              v388 = (v3 + 18) & 0xFFFFFFC0;
                                              v389 = v387 - v388;
                                              v3 = v388 - 2;
                                              v2 = v2 + 16 - v389;
                                              v373 = *(__m128i *)(v3 - 14);
                                              while ( 1 )
                                              {
                                                v374 = *(__m128i *)(v3 + 2);
                                                v390 = *(__m128i *)(v3 + 18);
                                                v391 = *(__m128i *)(v3 + 34);
                                                v392 = *(__m128i *)(v3 + 50);
                                                v393 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v391, v392),
                                                             _mm_min_epu8(v390, v374)),
                                                           v5));
                                                v394 = v392;
                                                v395 = _mm_alignr_epi8(v392, v391, 14);
                                                v396 = _mm_alignr_epi8(v391, v390, 14);
                                                if ( v393 )
                                                  break;
                                                v397 = _mm_alignr_epi8(v390, v374, 14);
                                                v3 += 64;
                                                v398 = _mm_alignr_epi8(v374, v373, 14);
                                                v373 = v394;
                                                *(__m128i *)(v2 + 48) = v395;
                                                *(__m128i *)(v2 + 32) = v396;
                                                *(__m128i *)(v2 + 16) = v397;
                                                *(__m128i *)v2 = v398;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)(v2 - 2) = *(_DWORD *)(v3 - 2);
                                            v7 = 2;
                                            break;
                                          default:
                                            v399 = *(__m128i *)(v3 - 15);
                                            v400 = *(__m128i *)(v3 + 1);
                                            while ( 1 )
                                            {
                                              v401 = _mm_cmpeq_epi8(v5, v400);
                                              v6 = _mm_movemask_epi8(v401);
                                              v402 = v400;
                                              if ( v6 )
                                                break;
                                              v403 = _mm_alignr_epi8(v400, v399, 15);
                                              v404 = v402;
                                              *(__m128i *)v2 = v403;
                                              v405 = *(__m128i *)(v3 + 17);
                                              v406 = _mm_cmpeq_epi8(v401, v405);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v406);
                                              v3 += 16;
                                              v407 = v405;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v405, v404, 15);
                                              v408 = *(__m128i *)(v3 + 17);
                                              v409 = v407;
                                              v410 = _mm_cmpeq_epi8(v406, v408);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v410);
                                              v3 += 16;
                                              v411 = v408;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v408, v409, 15);
                                              v412 = *(__m128i *)(v3 + 17);
                                              v5 = _mm_cmpeq_epi8(v410, v412);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v412, v411, 15);
                                              v413 = v3 + 17;
                                              v414 = (v3 + 17) & 0xFFFFFFC0;
                                              v415 = v413 - v414;
                                              v3 = v414 - 1;
                                              v2 = v2 + 16 - v415;
                                              v399 = *(__m128i *)(v3 - 15);
                                              while ( 1 )
                                              {
                                                v400 = *(__m128i *)(v3 + 1);
                                                v416 = *(__m128i *)(v3 + 17);
                                                v417 = *(__m128i *)(v3 + 33);
                                                v418 = *(__m128i *)(v3 + 49);
                                                v419 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v417, v418),
                                                             _mm_min_epu8(v416, v400)),
                                                           v5));
                                                v420 = v418;
                                                v421 = _mm_alignr_epi8(v418, v417, 15);
                                                v422 = _mm_alignr_epi8(v417, v416, 15);
                                                if ( v419 )
                                                  break;
                                                v423 = _mm_alignr_epi8(v416, v400, 15);
                                                v3 += 64;
                                                v424 = _mm_alignr_epi8(v400, v399, 15);
                                                v399 = v420;
                                                *(__m128i *)(v2 + 48) = v421;
                                                *(__m128i *)(v2 + 32) = v422;
                                                *(__m128i *)(v2 + 16) = v423;
                                                *(__m128i *)v2 = v424;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)(v2 - 3) = *(_DWORD *)(v3 - 3);
                                            v7 = 1;
                                            break;
                                        }
                                      }
                                      else
                                      {
                                        switch ( v8 )
                                        {
                                          case 1u:
                                            v29 = *(__m128i *)(v3 - 1);
                                            v30 = *(__m128i *)(v3 + 15);
                                            while ( 1 )
                                            {
                                              v31 = _mm_cmpeq_epi8(v5, v30);
                                              v6 = _mm_movemask_epi8(v31);
                                              v32 = v30;
                                              if ( v6 )
                                                break;
                                              v33 = _mm_alignr_epi8(v30, v29, 1);
                                              v34 = v32;
                                              *(__m128i *)v2 = v33;
                                              v35 = *(__m128i *)(v3 + 31);
                                              v36 = _mm_cmpeq_epi8(v31, v35);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v36);
                                              v3 += 16;
                                              v37 = v35;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v35, v34, 1);
                                              v38 = *(__m128i *)(v3 + 31);
                                              v39 = v37;
                                              v40 = _mm_cmpeq_epi8(v36, v38);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v40);
                                              v3 += 16;
                                              v41 = v38;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v38, v39, 1);
                                              v42 = *(__m128i *)(v3 + 31);
                                              v5 = _mm_cmpeq_epi8(v40, v42);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v42, v41, 1);
                                              v43 = v3 + 31;
                                              v44 = (v3 + 31) & 0xFFFFFFC0;
                                              v45 = v43 - v44;
                                              v3 = v44 - 15;
                                              v2 = v2 + 16 - v45;
                                              v29 = *(__m128i *)(v3 - 1);
                                              while ( 1 )
                                              {
                                                v30 = *(__m128i *)(v3 + 15);
                                                v46 = *(__m128i *)(v3 + 31);
                                                v47 = *(__m128i *)(v3 + 47);
                                                v48 = *(__m128i *)(v3 + 63);
                                                v49 = _mm_movemask_epi8(
                                                        _mm_cmpeq_epi8(
                                                          _mm_min_epu8(_mm_min_epu8(v47, v48), _mm_min_epu8(v46, v30)),
                                                          v5));
                                                v50 = v48;
                                                v51 = _mm_alignr_epi8(v48, v47, 1);
                                                v52 = _mm_alignr_epi8(v47, v46, 1);
                                                if ( v49 )
                                                  break;
                                                v53 = _mm_alignr_epi8(v46, v30, 1);
                                                v3 += 64;
                                                v54 = _mm_alignr_epi8(v30, v29, 1);
                                                v29 = v50;
                                                *(__m128i *)(v2 + 48) = v51;
                                                *(__m128i *)(v2 + 32) = v52;
                                                *(__m128i *)(v2 + 16) = v53;
                                                *(__m128i *)v2 = v54;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)v2 = *(double *)v3;
                                            *(double *)(v2 + 7) = *(double *)(v3 + 7);
                                            v7 = 15;
                                            break;
                                          case 2u:
                                            v55 = *(__m128i *)(v3 - 2);
                                            v56 = *(__m128i *)(v3 + 14);
                                            while ( 1 )
                                            {
                                              v57 = _mm_cmpeq_epi8(v5, v56);
                                              v6 = _mm_movemask_epi8(v57);
                                              v58 = v56;
                                              if ( v6 )
                                                break;
                                              v59 = _mm_alignr_epi8(v56, v55, 2);
                                              v60 = v58;
                                              *(__m128i *)v2 = v59;
                                              v61 = *(__m128i *)(v3 + 30);
                                              v62 = _mm_cmpeq_epi8(v57, v61);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v62);
                                              v3 += 16;
                                              v63 = v61;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v61, v60, 2);
                                              v64 = *(__m128i *)(v3 + 30);
                                              v65 = v63;
                                              v66 = _mm_cmpeq_epi8(v62, v64);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v66);
                                              v3 += 16;
                                              v67 = v64;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v64, v65, 2);
                                              v68 = *(__m128i *)(v3 + 30);
                                              v5 = _mm_cmpeq_epi8(v66, v68);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v68, v67, 2);
                                              v69 = v3 + 30;
                                              v70 = (v3 + 30) & 0xFFFFFFC0;
                                              v71 = v69 - v70;
                                              v3 = v70 - 14;
                                              v2 = v2 + 16 - v71;
                                              v55 = *(__m128i *)(v3 - 2);
                                              while ( 1 )
                                              {
                                                v56 = *(__m128i *)(v3 + 14);
                                                v72 = *(__m128i *)(v3 + 30);
                                                v73 = *(__m128i *)(v3 + 46);
                                                v74 = *(__m128i *)(v3 + 62);
                                                v75 = _mm_movemask_epi8(
                                                        _mm_cmpeq_epi8(
                                                          _mm_min_epu8(_mm_min_epu8(v73, v74), _mm_min_epu8(v72, v56)),
                                                          v5));
                                                v76 = v74;
                                                v77 = _mm_alignr_epi8(v74, v73, 2);
                                                v78 = _mm_alignr_epi8(v73, v72, 2);
                                                if ( v75 )
                                                  break;
                                                v79 = _mm_alignr_epi8(v72, v56, 2);
                                                v3 += 64;
                                                v80 = _mm_alignr_epi8(v56, v55, 2);
                                                v55 = v76;
                                                *(__m128i *)(v2 + 48) = v77;
                                                *(__m128i *)(v2 + 32) = v78;
                                                *(__m128i *)(v2 + 16) = v79;
                                                *(__m128i *)v2 = v80;
                                                v2 += 64;
                                              }
                                            }
                                            v81 = *(double *)(v3 + 6);
                                            *(double *)v2 = *(double *)v3;
                                            *(double *)(v2 + 6) = v81;
                                            v7 = 14;
                                            break;
                                          case 3u:
                                            v82 = *(__m128i *)(v3 - 3);
                                            v83 = *(__m128i *)(v3 + 13);
                                            while ( 1 )
                                            {
                                              v84 = _mm_cmpeq_epi8(v5, v83);
                                              v6 = _mm_movemask_epi8(v84);
                                              v85 = v83;
                                              if ( v6 )
                                                break;
                                              v86 = _mm_alignr_epi8(v83, v82, 3);
                                              v87 = v85;
                                              *(__m128i *)v2 = v86;
                                              v88 = *(__m128i *)(v3 + 29);
                                              v89 = _mm_cmpeq_epi8(v84, v88);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v89);
                                              v3 += 16;
                                              v90 = v88;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v88, v87, 3);
                                              v91 = *(__m128i *)(v3 + 29);
                                              v92 = v90;
                                              v93 = _mm_cmpeq_epi8(v89, v91);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v93);
                                              v3 += 16;
                                              v94 = v91;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v91, v92, 3);
                                              v95 = *(__m128i *)(v3 + 29);
                                              v5 = _mm_cmpeq_epi8(v93, v95);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v95, v94, 3);
                                              v96 = v3 + 29;
                                              v97 = (v3 + 29) & 0xFFFFFFC0;
                                              v98 = v96 - v97;
                                              v3 = v97 - 13;
                                              v2 = v2 + 16 - v98;
                                              v82 = *(__m128i *)(v3 - 3);
                                              while ( 1 )
                                              {
                                                v83 = *(__m128i *)(v3 + 13);
                                                v99 = *(__m128i *)(v3 + 29);
                                                v100 = *(__m128i *)(v3 + 45);
                                                v101 = *(__m128i *)(v3 + 61);
                                                v102 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v100, v101),
                                                             _mm_min_epu8(v99, v83)),
                                                           v5));
                                                v103 = v101;
                                                v104 = _mm_alignr_epi8(v101, v100, 3);
                                                v105 = _mm_alignr_epi8(v100, v99, 3);
                                                if ( v102 )
                                                  break;
                                                v106 = _mm_alignr_epi8(v99, v83, 3);
                                                v3 += 64;
                                                v107 = _mm_alignr_epi8(v83, v82, 3);
                                                v82 = v103;
                                                *(__m128i *)(v2 + 48) = v104;
                                                *(__m128i *)(v2 + 32) = v105;
                                                *(__m128i *)(v2 + 16) = v106;
                                                *(__m128i *)v2 = v107;
                                                v2 += 64;
                                              }
                                            }
                                            v108 = *(double *)(v3 + 5);
                                            *(double *)v2 = *(double *)v3;
                                            *(double *)(v2 + 5) = v108;
                                            v7 = 13;
                                            break;
                                          case 4u:
                                            v109 = *(__m128i *)(v3 - 4);
                                            v110 = *(__m128i *)(v3 + 12);
                                            while ( 1 )
                                            {
                                              v111 = _mm_cmpeq_epi8(v5, v110);
                                              v6 = _mm_movemask_epi8(v111);
                                              v112 = v110;
                                              if ( v6 )
                                                break;
                                              v113 = _mm_alignr_epi8(v110, v109, 4);
                                              v114 = v112;
                                              *(__m128i *)v2 = v113;
                                              v115 = *(__m128i *)(v3 + 28);
                                              v116 = _mm_cmpeq_epi8(v111, v115);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v116);
                                              v3 += 16;
                                              v117 = v115;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v115, v114, 4);
                                              v118 = *(__m128i *)(v3 + 28);
                                              v119 = v117;
                                              v120 = _mm_cmpeq_epi8(v116, v118);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v120);
                                              v3 += 16;
                                              v121 = v118;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v118, v119, 4);
                                              v122 = *(__m128i *)(v3 + 28);
                                              v5 = _mm_cmpeq_epi8(v120, v122);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v122, v121, 4);
                                              v123 = v3 + 28;
                                              v124 = (v3 + 28) & 0xFFFFFFC0;
                                              v125 = v123 - v124;
                                              v3 = v124 - 12;
                                              v2 = v2 + 16 - v125;
                                              v109 = *(__m128i *)(v3 - 4);
                                              while ( 1 )
                                              {
                                                v110 = *(__m128i *)(v3 + 12);
                                                v126 = *(__m128i *)(v3 + 28);
                                                v127 = *(__m128i *)(v3 + 44);
                                                v128 = *(__m128i *)(v3 + 60);
                                                v129 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v127, v128),
                                                             _mm_min_epu8(v126, v110)),
                                                           v5));
                                                v130 = v128;
                                                v131 = _mm_alignr_epi8(v128, v127, 4);
                                                v132 = _mm_alignr_epi8(v127, v126, 4);
                                                if ( v129 )
                                                  break;
                                                v133 = _mm_alignr_epi8(v126, v110, 4);
                                                v3 += 64;
                                                v134 = _mm_alignr_epi8(v110, v109, 4);
                                                v109 = v130;
                                                *(__m128i *)(v2 + 48) = v131;
                                                *(__m128i *)(v2 + 32) = v132;
                                                *(__m128i *)(v2 + 16) = v133;
                                                *(__m128i *)v2 = v134;
                                                v2 += 64;
                                              }
                                            }
                                            v135 = *(_DWORD *)(v3 + 8);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 8) = v135;
                                            v7 = 12;
                                            break;
                                          case 5u:
                                            v136 = *(__m128i *)(v3 - 5);
                                            v137 = *(__m128i *)(v3 + 11);
                                            while ( 1 )
                                            {
                                              v138 = _mm_cmpeq_epi8(v5, v137);
                                              v6 = _mm_movemask_epi8(v138);
                                              v139 = v137;
                                              if ( v6 )
                                                break;
                                              v140 = _mm_alignr_epi8(v137, v136, 5);
                                              v141 = v139;
                                              *(__m128i *)v2 = v140;
                                              v142 = *(__m128i *)(v3 + 27);
                                              v143 = _mm_cmpeq_epi8(v138, v142);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v143);
                                              v3 += 16;
                                              v144 = v142;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v142, v141, 5);
                                              v145 = *(__m128i *)(v3 + 27);
                                              v146 = v144;
                                              v147 = _mm_cmpeq_epi8(v143, v145);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v147);
                                              v3 += 16;
                                              v148 = v145;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v145, v146, 5);
                                              v149 = *(__m128i *)(v3 + 27);
                                              v5 = _mm_cmpeq_epi8(v147, v149);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v149, v148, 5);
                                              v150 = v3 + 27;
                                              v151 = (v3 + 27) & 0xFFFFFFC0;
                                              v152 = v150 - v151;
                                              v3 = v151 - 11;
                                              v2 = v2 + 16 - v152;
                                              v136 = *(__m128i *)(v3 - 5);
                                              while ( 1 )
                                              {
                                                v137 = *(__m128i *)(v3 + 11);
                                                v153 = *(__m128i *)(v3 + 27);
                                                v154 = *(__m128i *)(v3 + 43);
                                                v155 = *(__m128i *)(v3 + 59);
                                                v156 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v154, v155),
                                                             _mm_min_epu8(v153, v137)),
                                                           v5));
                                                v157 = v155;
                                                v158 = _mm_alignr_epi8(v155, v154, 5);
                                                v159 = _mm_alignr_epi8(v154, v153, 5);
                                                if ( v156 )
                                                  break;
                                                v160 = _mm_alignr_epi8(v153, v137, 5);
                                                v3 += 64;
                                                v161 = _mm_alignr_epi8(v137, v136, 5);
                                                v136 = v157;
                                                *(__m128i *)(v2 + 48) = v158;
                                                *(__m128i *)(v2 + 32) = v159;
                                                *(__m128i *)(v2 + 16) = v160;
                                                *(__m128i *)v2 = v161;
                                                v2 += 64;
                                              }
                                            }
                                            v162 = *(_DWORD *)(v3 + 7);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 7) = v162;
                                            v7 = 11;
                                            break;
                                          case 6u:
                                            v163 = *(__m128i *)(v3 - 6);
                                            v164 = *(__m128i *)(v3 + 10);
                                            while ( 1 )
                                            {
                                              v165 = _mm_cmpeq_epi8(v5, v164);
                                              v6 = _mm_movemask_epi8(v165);
                                              v166 = v164;
                                              if ( v6 )
                                                break;
                                              v167 = _mm_alignr_epi8(v164, v163, 6);
                                              v168 = v166;
                                              *(__m128i *)v2 = v167;
                                              v169 = *(__m128i *)(v3 + 26);
                                              v170 = _mm_cmpeq_epi8(v165, v169);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v170);
                                              v3 += 16;
                                              v171 = v169;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v169, v168, 6);
                                              v172 = *(__m128i *)(v3 + 26);
                                              v173 = v171;
                                              v174 = _mm_cmpeq_epi8(v170, v172);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v174);
                                              v3 += 16;
                                              v175 = v172;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v172, v173, 6);
                                              v176 = *(__m128i *)(v3 + 26);
                                              v5 = _mm_cmpeq_epi8(v174, v176);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v176, v175, 6);
                                              v177 = v3 + 26;
                                              v178 = (v3 + 26) & 0xFFFFFFC0;
                                              v179 = v177 - v178;
                                              v3 = v178 - 10;
                                              v2 = v2 + 16 - v179;
                                              v163 = *(__m128i *)(v3 - 6);
                                              while ( 1 )
                                              {
                                                v164 = *(__m128i *)(v3 + 10);
                                                v180 = *(__m128i *)(v3 + 26);
                                                v181 = *(__m128i *)(v3 + 42);
                                                v182 = *(__m128i *)(v3 + 58);
                                                v183 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v181, v182),
                                                             _mm_min_epu8(v180, v164)),
                                                           v5));
                                                v184 = v182;
                                                v185 = _mm_alignr_epi8(v182, v181, 6);
                                                v186 = _mm_alignr_epi8(v181, v180, 6);
                                                if ( v183 )
                                                  break;
                                                v187 = _mm_alignr_epi8(v180, v164, 6);
                                                v3 += 64;
                                                v188 = _mm_alignr_epi8(v164, v163, 6);
                                                v163 = v184;
                                                *(__m128i *)(v2 + 48) = v185;
                                                *(__m128i *)(v2 + 32) = v186;
                                                *(__m128i *)(v2 + 16) = v187;
                                                *(__m128i *)v2 = v188;
                                                v2 += 64;
                                              }
                                            }
                                            v189 = *(_DWORD *)(v3 + 6);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 6) = v189;
                                            v7 = 10;
                                            break;
                                          default:
                                            v190 = *(__m128i *)(v3 - 7);
                                            v191 = *(__m128i *)(v3 + 9);
                                            while ( 1 )
                                            {
                                              v192 = _mm_cmpeq_epi8(v5, v191);
                                              v6 = _mm_movemask_epi8(v192);
                                              v193 = v191;
                                              if ( v6 )
                                                break;
                                              v194 = _mm_alignr_epi8(v191, v190, 7);
                                              v195 = v193;
                                              *(__m128i *)v2 = v194;
                                              v196 = *(__m128i *)(v3 + 25);
                                              v197 = _mm_cmpeq_epi8(v192, v196);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v197);
                                              v3 += 16;
                                              v198 = v196;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v196, v195, 7);
                                              v199 = *(__m128i *)(v3 + 25);
                                              v200 = v198;
                                              v201 = _mm_cmpeq_epi8(v197, v199);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v201);
                                              v3 += 16;
                                              v202 = v199;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v199, v200, 7);
                                              v203 = *(__m128i *)(v3 + 25);
                                              v5 = _mm_cmpeq_epi8(v201, v203);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v203, v202, 7);
                                              v204 = v3 + 25;
                                              v205 = (v3 + 25) & 0xFFFFFFC0;
                                              v206 = v204 - v205;
                                              v3 = v205 - 9;
                                              v2 = v2 + 16 - v206;
                                              v190 = *(__m128i *)(v3 - 7);
                                              while ( 1 )
                                              {
                                                v191 = *(__m128i *)(v3 + 9);
                                                v207 = *(__m128i *)(v3 + 25);
                                                v208 = *(__m128i *)(v3 + 41);
                                                v209 = *(__m128i *)(v3 + 57);
                                                v210 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v208, v209),
                                                             _mm_min_epu8(v207, v191)),
                                                           v5));
                                                v211 = v209;
                                                v212 = _mm_alignr_epi8(v209, v208, 7);
                                                v213 = _mm_alignr_epi8(v208, v207, 7);
                                                if ( v210 )
                                                  break;
                                                v214 = _mm_alignr_epi8(v207, v191, 7);
                                                v3 += 64;
                                                v215 = _mm_alignr_epi8(v191, v190, 7);
                                                v190 = v211;
                                                *(__m128i *)(v2 + 48) = v212;
                                                *(__m128i *)(v2 + 32) = v213;
                                                *(__m128i *)(v2 + 16) = v214;
                                                *(__m128i *)v2 = v215;
                                                v2 += 64;
                                              }
                                            }
                                            v216 = *(_DWORD *)(v3 + 5);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 5) = v216;
                                            v7 = 9;
                                            break;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      v9 = *(__m128i *)(v3 + 16);
                                      *(_OWORD *)v2 = *(_OWORD *)v3;
                                      v10 = _mm_cmpeq_epi8(v5, v9);
                                      v6 = _mm_movemask_epi8(v10);
                                      v7 = 16;
                                      if ( !v6 )
                                      {
                                        v11 = *(__m128i *)(v3 + 32);
                                        *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x10) = v9;
                                        v12 = _mm_cmpeq_epi8(v10, v11);
                                        v6 = _mm_movemask_epi8(v12);
                                        v7 = 32;
                                        if ( !v6 )
                                        {
                                          v13 = *(__m128i *)(v3 + 48);
                                          *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x20) = v11;
                                          v14 = _mm_cmpeq_epi8(v12, v13);
                                          v6 = _mm_movemask_epi8(v14);
                                          v7 = 48;
                                          if ( !v6 )
                                          {
                                            v15 = *(__m128i *)(v3 + 64);
                                            *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x30) = v13;
                                            v16 = _mm_cmpeq_epi8(v14, v15);
                                            v6 = _mm_movemask_epi8(v16);
                                            v7 = 64;
                                            if ( !v6 )
                                            {
                                              v17 = *(__m128i *)(v3 + 80);
                                              *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x40) = v15;
                                              v18 = _mm_cmpeq_epi8(v16, v17);
                                              v6 = _mm_movemask_epi8(v18);
                                              v7 = 80;
                                              if ( !v6 )
                                              {
                                                v19 = *(__m128i *)(v3 + 96);
                                                *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x50) = v17;
                                                v20 = _mm_cmpeq_epi8(v18, v19);
                                                v6 = _mm_movemask_epi8(v20);
                                                v7 = 96;
                                                if ( !v6 )
                                                {
                                                  *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x60) = v19;
                                                  v3 = (v3 + 112) & 0xFFFFFFC0;
                                                  v2 = v3 - (a2 - a1);
                                                  v7 = -64;
                                                  while ( 1 )
                                                  {
                                                    v21 = *(__m128i *)v3;
                                                    v22 = *(__m128i *)(v3 + 16);
                                                    v23 = *(__m128i *)(v3 + 32);
                                                    v24 = *(__m128i *)(v3 + 48);
                                                    v2 += 64;
                                                    v25 = _mm_cmpeq_epi8(
                                                            _mm_min_epu8(
                                                              _mm_min_epu8(v23, v24),
                                                              _mm_min_epu8(*(__m128i *)v3, v22)),
                                                            v20);
                                                    v3 += 64;
                                                    if ( _mm_movemask_epi8(v25) )
                                                      break;
                                                    *(__m128i *)(v2 - 64) = v21;
                                                    *(__m128i *)(v2 - 48) = v22;
                                                    *(__m128i *)(v2 - 32) = v23;
                                                    *(__m128i *)(v2 - 16) = v24;
                                                  }
                                                  v26 = _mm_cmpeq_epi8(v20, v21);
                                                  v6 = _mm_movemask_epi8(v26);
                                                  if ( !v6 )
                                                  {
                                                    v27 = _mm_cmpeq_epi8(v26, v22);
                                                    v6 = _mm_movemask_epi8(v27);
                                                    *(__m128i *)(v2 - 64) = v21;
                                                    v7 = -48;
                                                    if ( !v6 )
                                                    {
                                                      v28 = _mm_cmpeq_epi8(v27, v23);
                                                      v6 = _mm_movemask_epi8(v28);
                                                      *(__m128i *)(v2 - 48) = v22;
                                                      v7 = -32;
                                                      if ( !v6 )
                                                      {
                                                        *(__m128i *)(v2 - 32) = v23;
                                                        LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v28, v24));
                                                        v7 = -16;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  v425 = v7 + v2;
                                  v426 = v7 + v3;
                                  if ( (_BYTE)v6 )
                                  {
                                    if ( (v6 & 0xF) != 0 )
                                    {
                                      if ( (v6 & 1) != 0 )
                                      {
                                        *(_BYTE *)v425 = *(_BYTE *)v426;
                                        return v425;
                                      }
                                      else if ( (v6 & 2) != 0 )
                                      {
                                        *(_WORD *)v425 = *(_WORD *)v426;
                                        return v425 + 1;
                                      }
                                      else if ( (v6 & 4) != 0 )
                                      {
                                        *(_WORD *)v425 = *(_WORD *)v426;
                                        *(_BYTE *)(v425 + 2) = *(_BYTE *)(v426 + 2);
                                        return v425 + 2;
                                      }
                                      else
                                      {
                                        *(_DWORD *)v425 = *(_DWORD *)v426;
                                        return v425 + 3;
                                      }
                                    }
                                    else if ( (v6 & 0x10) != 0 )
                                    {
                                      *(_DWORD *)v425 = *(_DWORD *)v426;
                                      *(_BYTE *)(v425 + 4) = *(_BYTE *)(v426 + 4);
                                      return v425 + 4;
                                    }
                                    else if ( (v6 & 0x20) != 0 )
                                    {
                                      *(_DWORD *)v425 = *(_DWORD *)v426;
                                      *(_WORD *)(v425 + 4) = *(_WORD *)(v426 + 4);
                                      return v425 + 5;
                                    }
                                    else if ( (v6 & 0x40) != 0 )
                                    {
                                      *(_DWORD *)v425 = *(_DWORD *)v426;
                                      *(_DWORD *)(v425 + 3) = *(_DWORD *)(v426 + 3);
                                      return v425 + 6;
                                    }
                                    else
                                    {
                                      *(double *)v425 = *(double *)v426;
                                      return v425 + 7;
                                    }
                                  }
                                  else if ( (v6 & 0xF00) != 0 )
                                  {
                                    if ( (v6 & 0x100) != 0 )
                                    {
                                      v429 = *(_BYTE *)(v426 + 8);
                                      *(double *)v425 = *(double *)v426;
                                      *(_BYTE *)(v425 + 8) = v429;
                                      return v425 + 8;
                                    }
                                    else if ( (v6 & 0x200) != 0 )
                                    {
                                      v430 = *(_WORD *)(v426 + 8);
                                      *(double *)v425 = *(double *)v426;
                                      *(_WORD *)(v425 + 8) = v430;
                                      return v425 + 9;
                                    }
                                    else if ( (v6 & 0x400) != 0 )
                                    {
                                      v431 = *(_DWORD *)(v426 + 7);
                                      *(double *)v425 = *(double *)v426;
                                      *(_DWORD *)(v425 + 7) = v431;
                                      return v425 + 10;
                                    }
                                    else
                                    {
                                      v428 = *(_DWORD *)(v426 + 8);
                                      *(double *)v425 = *(double *)v426;
                                      *(_DWORD *)(v425 + 8) = v428;
                                      return v425 + 11;
                                    }
                                  }
                                  else if ( (v6 & 0x1000) != 0 )
                                  {
                                    v432 = *(double *)(v426 + 5);
                                    *(double *)v425 = *(double *)v426;
                                    *(double *)(v425 + 5) = v432;
                                    return v425 + 12;
                                  }
                                  else if ( (v6 & 0x2000) != 0 )
                                  {
                                    v433 = *(double *)(v426 + 6);
                                    *(double *)v425 = *(double *)v426;
                                    *(double *)(v425 + 6) = v433;
                                    return v425 + 13;
                                  }
                                  else if ( (v6 & 0x4000) != 0 )
                                  {
                                    v434 = *(double *)(v426 + 7);
                                    *(double *)v425 = *(double *)v426;
                                    *(double *)(v425 + 7) = v434;
                                    return v425 + 14;
                                  }
                                  else
                                  {
                                    *(__m128i *)v425 = _mm_loadu_si128((const __m128i *)v426);
                                    return v425 + 15;
                                  }
                                }
                                else
                                {
                                  *(__m128i *)a1 = _mm_loadu_si128((const __m128i *)a2);
                                  return a1 + 15;
                                }
                              }
                              else
                              {
                                v441 = *(double *)(a2 + 7);
                                *(double *)a1 = *(double *)a2;
                                *(double *)(a1 + 7) = v441;
                                return a1 + 14;
                              }
                            }
                            else
                            {
                              v440 = *(double *)(a2 + 6);
                              *(double *)a1 = *(double *)a2;
                              *(double *)(a1 + 6) = v440;
                              return a1 + 13;
                            }
                          }
                          else
                          {
                            v439 = *(double *)(a2 + 5);
                            *(double *)a1 = *(double *)a2;
                            *(double *)(a1 + 5) = v439;
                            return a1 + 12;
                          }
                        }
                        else
                        {
                          v438 = *(_DWORD *)(a2 + 8);
                          *(double *)a1 = *(double *)a2;
                          *(_DWORD *)(a1 + 8) = v438;
                          return a1 + 11;
                        }
                      }
                      else
                      {
                        v437 = *(_DWORD *)(a2 + 7);
                        *(double *)a1 = *(double *)a2;
                        *(_DWORD *)(a1 + 7) = v437;
                        return a1 + 10;
                      }
                    }
                    else
                    {
                      v436 = *(_WORD *)(a2 + 8);
                      *(double *)a1 = *(double *)a2;
                      *(_WORD *)(a1 + 8) = v436;
                      return a1 + 9;
                    }
                  }
                  else
                  {
                    v435 = *(_BYTE *)(a2 + 8);
                    *(double *)a1 = *(double *)a2;
                    *(_BYTE *)(a1 + 8) = v435;
                    return a1 + 8;
                  }
                }
                else
                {
                  *(double *)a1 = *(double *)a2;
                  return a1 + 7;
                }
              }
              else
              {
                *(_DWORD *)a1 = *(_DWORD *)a2;
                *(_DWORD *)(a1 + 3) = *(_DWORD *)(a2 + 3);
                return a1 + 6;
              }
            }
            else
            {
              *(_DWORD *)a1 = *(_DWORD *)a2;
              *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
              return a1 + 5;
            }
          }
          else
          {
            *(_DWORD *)a1 = *(_DWORD *)a2;
            *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
            return a1 + 4;
          }
        }
        else
        {
          *(_DWORD *)a1 = *(_DWORD *)a2;
          return a1 + 3;
        }
      }
      else
      {
        *(_WORD *)a1 = *(_WORD *)a2;
        *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
        return a1 + 2;
      }
    }
    else
    {
      *(_WORD *)a1 = *(_WORD *)a2;
      return a1 + 1;
    }
  }
  else
  {
    *(_BYTE *)a1 = *(_BYTE *)a2;
    return a1;
  }
}

//----- (08067C90) --------------------------------------------------------
int __cdecl _strcpy_sse2(int a1, unsigned int a2)
{
  __m128i *v2; // edx
  unsigned int v3; // ecx
  __m128i *v4; // ebx
  __m128i v5; // xmm0
  int v6; // eax
  int v7; // ebx
  __m128i v8; // xmm2
  __m128i v9; // xmm0
  __m128i v10; // xmm3
  __m128i v11; // xmm0
  __m128i v12; // xmm4
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  __m128i v15; // xmm0
  __m128i v16; // xmm2
  __m128i v17; // xmm0
  __m128i v18; // xmm3
  __m128i v19; // xmm0
  unsigned int v20; // ecx
  __m128i *v21; // edx
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm6
  __m128i v25; // xmm7
  __m128i v26; // xmm2
  __m128i v27; // xmm3
  __m128i v28; // xmm0
  __m128i v29; // xmm0
  __m128i v30; // xmm0
  __int8 *v31; // edx
  unsigned int v32; // ecx

  v2 = (__m128i *)a1;
  v3 = a2;
  if ( *(_BYTE *)a2 )
  {
    if ( *(_BYTE *)(a2 + 1) )
    {
      if ( *(_BYTE *)(a2 + 2) )
      {
        if ( *(_BYTE *)(a2 + 3) )
        {
          if ( *(_BYTE *)(a2 + 4) )
          {
            if ( *(_BYTE *)(a2 + 5) )
            {
              if ( *(_BYTE *)(a2 + 6) )
              {
                if ( *(_BYTE *)(a2 + 7) )
                {
                  if ( *(_BYTE *)(a2 + 8) )
                  {
                    if ( *(_BYTE *)(a2 + 9) )
                    {
                      if ( *(_BYTE *)(a2 + 10) )
                      {
                        if ( *(_BYTE *)(a2 + 11) )
                        {
                          if ( *(_BYTE *)(a2 + 12) )
                          {
                            if ( *(_BYTE *)(a2 + 13) )
                            {
                              if ( *(_BYTE *)(a2 + 14) )
                              {
                                if ( *(_BYTE *)(a2 + 15) )
                                {
                                  v4 = (__m128i *)((a2 + 16) & 0xFFFFFFF0);
                                  *(__m128i *)a1 = _mm_loadu_si128((const __m128i *)a2);
                                  v5 = _mm_cmpeq_epi8((__m128i)0LL, *v4);
                                  v6 = _mm_movemask_epi8(v5);
                                  v7 = (int)v4->m128i_i32 - a2;
                                  if ( !v6 )
                                  {
                                    v3 = (a2 + 16) & 0xFFFFFFF0;
                                    v2 = (__m128i *)(a1 - (a2 - v3));
                                    v8 = *(__m128i *)(v3 + 0x10);
                                    *v2 = _mm_load_si128((const __m128i *)v3);
                                    v9 = _mm_cmpeq_epi8(v5, v8);
                                    v6 = _mm_movemask_epi8(v9);
                                    v7 = 16;
                                    if ( !v6 )
                                    {
                                      v10 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x20);
                                      v2[1] = v8;
                                      v11 = _mm_cmpeq_epi8(v9, v10);
                                      v6 = _mm_movemask_epi8(v11);
                                      v7 = 32;
                                      if ( !v6 )
                                      {
                                        v12 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x30);
                                        v2[2] = v10;
                                        v13 = _mm_cmpeq_epi8(v11, v12);
                                        v6 = _mm_movemask_epi8(v13);
                                        v7 = 48;
                                        if ( !v6 )
                                        {
                                          v14 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x40);
                                          v2[3] = v12;
                                          v15 = _mm_cmpeq_epi8(v13, v14);
                                          v6 = _mm_movemask_epi8(v15);
                                          v7 = 64;
                                          if ( !v6 )
                                          {
                                            v16 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x50);
                                            v2[4] = v14;
                                            v17 = _mm_cmpeq_epi8(v15, v16);
                                            v6 = _mm_movemask_epi8(v17);
                                            v7 = 80;
                                            if ( !v6 )
                                            {
                                              v18 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x60);
                                              v2[5] = v16;
                                              v19 = _mm_cmpeq_epi8(v17, v18);
                                              v6 = _mm_movemask_epi8(v19);
                                              v7 = 96;
                                              if ( !v6 )
                                              {
                                                v2[6] = v18;
                                                v20 = (v3 + 112) & 0xFFFFFFC0;
                                                v21 = (__m128i *)((char *)v2 - (((a2 + 16) & 0xFFFFFFF0) - v20));
                                                v22 = *(__m128i *)v20;
                                                v23 = *(__m128i *)(v20 + 16);
                                                v24 = *(__m128i *)(v20 + 32);
                                                v25 = *(__m128i *)(v20 + 48);
                                                v26 = _mm_min_epu8(*(__m128i *)v20, v23);
                                                v3 = v20 + 64;
                                                v2 = v21 + 4;
                                                if ( !_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v24, v25), v26), v19)) )
                                                {
                                                  do
                                                  {
                                                    v2[-4] = v22;
                                                    v22 = *(__m128i *)v3;
                                                    v2[-3] = v23;
                                                    v23 = *(__m128i *)(v3 + 16);
                                                    v27 = *(__m128i *)(v3 + 32);
                                                    v2[-2] = v24;
                                                    v24 = v27;
                                                    v2[-1] = v25;
                                                    v25 = *(__m128i *)(v3 + 48);
                                                    v19 = _mm_cmpeq_epi8(
                                                            v19,
                                                            _mm_min_epu8(_mm_min_epu8(v27, v25), _mm_min_epu8(v22, v23)));
                                                    v2 += 4;
                                                    v3 += 64;
                                                  }
                                                  while ( !_mm_movemask_epi8(v19) );
                                                }
                                                v7 = -64;
                                                v28 = _mm_cmpeq_epi8((__m128i)0LL, v22);
                                                v6 = _mm_movemask_epi8(v28);
                                                if ( !v6 )
                                                {
                                                  v29 = _mm_cmpeq_epi8(v28, v23);
                                                  v6 = _mm_movemask_epi8(v29);
                                                  v2[-4] = v22;
                                                  v7 = -48;
                                                  if ( !v6 )
                                                  {
                                                    v30 = _mm_cmpeq_epi8(v29, v24);
                                                    v6 = _mm_movemask_epi8(v30);
                                                    v2[-3] = v23;
                                                    v7 = -32;
                                                    if ( !v6 )
                                                    {
                                                      v2[-2] = v24;
                                                      LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v30, v25));
                                                      v7 = -16;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  v31 = &v2->m128i_i8[v7];
                                  v32 = v7 + v3;
                                  if ( (_BYTE)v6 )
                                  {
                                    if ( (v6 & 1) != 0 )
                                    {
                                      *v31 = *(_BYTE *)v32;
                                      return a1;
                                    }
                                    else if ( (v6 & 2) != 0 )
                                    {
                                      *(_WORD *)v31 = *(_WORD *)v32;
                                      return a1;
                                    }
                                    else if ( (v6 & 4) != 0 )
                                    {
                                      *(_WORD *)v31 = *(_WORD *)v32;
                                      v31[2] = *(_BYTE *)(v32 + 2);
                                      return a1;
                                    }
                                    else if ( (v6 & 8) != 0 )
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      return a1;
                                    }
                                    else if ( (v6 & 0x10) != 0 )
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      v31[4] = *(_BYTE *)(v32 + 4);
                                      return a1;
                                    }
                                    else if ( (v6 & 0x20) != 0 )
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      *((_WORD *)v31 + 2) = *(_WORD *)(v32 + 4);
                                      return a1;
                                    }
                                    else
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      if ( (v6 & 0x40) != 0 )
                                        *(_DWORD *)(v31 + 3) = *(_DWORD *)(v32 + 3);
                                      else
                                        *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                      return a1;
                                    }
                                  }
                                  else if ( (v6 & 0x100) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    v31[8] = *(_BYTE *)(v32 + 8);
                                    return a1;
                                  }
                                  else if ( (v6 & 0x200) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    *((_WORD *)v31 + 4) = *(_WORD *)(v32 + 8);
                                    return a1;
                                  }
                                  else if ( (v6 & 0x400) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    *(_DWORD *)(v31 + 7) = *(_DWORD *)(v32 + 7);
                                    return a1;
                                  }
                                  else if ( (v6 & 0x800) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    *((_DWORD *)v31 + 2) = *(_DWORD *)(v32 + 8);
                                    return a1;
                                  }
                                  else if ( (v6 & 0x1000) != 0 )
                                  {
                                    *(double *)v31 = *(double *)v32;
                                    *(double *)(v31 + 5) = *(double *)(v32 + 5);
                                    return a1;
                                  }
                                  else if ( (v6 & 0x2000) != 0 )
                                  {
                                    *(double *)v31 = *(double *)v32;
                                    *(double *)(v31 + 6) = *(double *)(v32 + 6);
                                    return a1;
                                  }
                                  else
                                  {
                                    *(double *)v31 = *(double *)v32;
                                    if ( (v6 & 0x4000) != 0 )
                                      *(double *)(v31 + 7) = *(double *)(v32 + 7);
                                    else
                                      *((double *)v31 + 1) = *(double *)(v32 + 8);
                                    return a1;
                                  }
                                }
                                else
                                {
                                  *(double *)a1 = *(double *)a2;
                                  *(double *)(a1 + 8) = *(double *)(a2 + 8);
                                  return a1;
                                }
                              }
                              else
                              {
                                *(double *)a1 = *(double *)a2;
                                *(double *)(a1 + 7) = *(double *)(a2 + 7);
                                return a1;
                              }
                            }
                            else
                            {
                              *(double *)a1 = *(double *)a2;
                              *(double *)(a1 + 6) = *(double *)(a2 + 6);
                              return a1;
                            }
                          }
                          else
                          {
                            *(double *)a1 = *(double *)a2;
                            *(double *)(a1 + 5) = *(double *)(a2 + 5);
                            return a1;
                          }
                        }
                        else
                        {
                          *(_DWORD *)a1 = *(_DWORD *)a2;
                          *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
                          return a1;
                        }
                      }
                      else
                      {
                        *(_DWORD *)a1 = *(_DWORD *)a2;
                        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                        *(_DWORD *)(a1 + 7) = *(_DWORD *)(a2 + 7);
                        return a1;
                      }
                    }
                    else
                    {
                      *(_DWORD *)a1 = *(_DWORD *)a2;
                      *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                      *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
                      return a1;
                    }
                  }
                  else
                  {
                    *(_DWORD *)a1 = *(_DWORD *)a2;
                    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                    *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
                    return a1;
                  }
                }
                else
                {
                  *(_DWORD *)a1 = *(_DWORD *)a2;
                  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                  return a1;
                }
              }
              else
              {
                *(_DWORD *)a1 = *(_DWORD *)a2;
                *(_DWORD *)(a1 + 3) = *(_DWORD *)(a2 + 3);
                return a1;
              }
            }
            else
            {
              *(_DWORD *)a1 = *(_DWORD *)a2;
              *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
              return a1;
            }
          }
          else
          {
            *(_DWORD *)a1 = *(_DWORD *)a2;
            *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
            return a1;
          }
        }
        else
        {
          *(_DWORD *)a1 = *(_DWORD *)a2;
          return a1;
        }
      }
      else
      {
        *(_WORD *)a1 = *(_WORD *)a2;
        *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
        return a1;
      }
    }
    else
    {
      *(_WORD *)a1 = *(_WORD *)a2;
      return a1;
    }
  }
  else
  {
    *(_BYTE *)a1 = *(_BYTE *)a2;
    return a1;
  }
}

//----- (08068280) --------------------------------------------------------
char *__cdecl _stpcpy_sse2(int a1, unsigned int a2)
{
  __m128i *v2; // edx
  unsigned int v3; // ecx
  __m128i *v4; // ebx
  __m128i v5; // xmm0
  int v6; // eax
  int v7; // ebx
  __m128i v8; // xmm2
  __m128i v9; // xmm0
  __m128i v10; // xmm3
  __m128i v11; // xmm0
  __m128i v12; // xmm4
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  __m128i v15; // xmm0
  __m128i v16; // xmm2
  __m128i v17; // xmm0
  __m128i v18; // xmm3
  __m128i v19; // xmm0
  unsigned int v20; // ecx
  __m128i *v21; // edx
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm6
  __m128i v25; // xmm7
  __m128i v26; // xmm2
  __m128i v27; // xmm3
  __m128i v28; // xmm0
  __m128i v29; // xmm0
  __m128i v30; // xmm0
  __int8 *v31; // edx
  unsigned int v32; // ecx

  v2 = (__m128i *)a1;
  v3 = a2;
  if ( *(_BYTE *)a2 )
  {
    if ( *(_BYTE *)(a2 + 1) )
    {
      if ( *(_BYTE *)(a2 + 2) )
      {
        if ( *(_BYTE *)(a2 + 3) )
        {
          if ( *(_BYTE *)(a2 + 4) )
          {
            if ( *(_BYTE *)(a2 + 5) )
            {
              if ( *(_BYTE *)(a2 + 6) )
              {
                if ( *(_BYTE *)(a2 + 7) )
                {
                  if ( *(_BYTE *)(a2 + 8) )
                  {
                    if ( *(_BYTE *)(a2 + 9) )
                    {
                      if ( *(_BYTE *)(a2 + 10) )
                      {
                        if ( *(_BYTE *)(a2 + 11) )
                        {
                          if ( *(_BYTE *)(a2 + 12) )
                          {
                            if ( *(_BYTE *)(a2 + 13) )
                            {
                              if ( *(_BYTE *)(a2 + 14) )
                              {
                                if ( *(_BYTE *)(a2 + 15) )
                                {
                                  v4 = (__m128i *)((a2 + 16) & 0xFFFFFFF0);
                                  *(__m128i *)a1 = _mm_loadu_si128((const __m128i *)a2);
                                  v5 = _mm_cmpeq_epi8((__m128i)0LL, *v4);
                                  v6 = _mm_movemask_epi8(v5);
                                  v7 = (int)v4->m128i_i32 - a2;
                                  if ( !v6 )
                                  {
                                    v3 = (a2 + 16) & 0xFFFFFFF0;
                                    v2 = (__m128i *)(a1 - (a2 - v3));
                                    v8 = *(__m128i *)(v3 + 0x10);
                                    *v2 = _mm_load_si128((const __m128i *)v3);
                                    v9 = _mm_cmpeq_epi8(v5, v8);
                                    v6 = _mm_movemask_epi8(v9);
                                    v7 = 16;
                                    if ( !v6 )
                                    {
                                      v10 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x20);
                                      v2[1] = v8;
                                      v11 = _mm_cmpeq_epi8(v9, v10);
                                      v6 = _mm_movemask_epi8(v11);
                                      v7 = 32;
                                      if ( !v6 )
                                      {
                                        v12 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x30);
                                        v2[2] = v10;
                                        v13 = _mm_cmpeq_epi8(v11, v12);
                                        v6 = _mm_movemask_epi8(v13);
                                        v7 = 48;
                                        if ( !v6 )
                                        {
                                          v14 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x40);
                                          v2[3] = v12;
                                          v15 = _mm_cmpeq_epi8(v13, v14);
                                          v6 = _mm_movemask_epi8(v15);
                                          v7 = 64;
                                          if ( !v6 )
                                          {
                                            v16 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x50);
                                            v2[4] = v14;
                                            v17 = _mm_cmpeq_epi8(v15, v16);
                                            v6 = _mm_movemask_epi8(v17);
                                            v7 = 80;
                                            if ( !v6 )
                                            {
                                              v18 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x60);
                                              v2[5] = v16;
                                              v19 = _mm_cmpeq_epi8(v17, v18);
                                              v6 = _mm_movemask_epi8(v19);
                                              v7 = 96;
                                              if ( !v6 )
                                              {
                                                v2[6] = v18;
                                                v20 = (v3 + 112) & 0xFFFFFFC0;
                                                v21 = (__m128i *)((char *)v2 - (((a2 + 16) & 0xFFFFFFF0) - v20));
                                                v22 = *(__m128i *)v20;
                                                v23 = *(__m128i *)(v20 + 16);
                                                v24 = *(__m128i *)(v20 + 32);
                                                v25 = *(__m128i *)(v20 + 48);
                                                v26 = _mm_min_epu8(*(__m128i *)v20, v23);
                                                v3 = v20 + 64;
                                                v2 = v21 + 4;
                                                if ( !_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v24, v25), v26), v19)) )
                                                {
                                                  do
                                                  {
                                                    v2[-4] = v22;
                                                    v22 = *(__m128i *)v3;
                                                    v2[-3] = v23;
                                                    v23 = *(__m128i *)(v3 + 16);
                                                    v27 = *(__m128i *)(v3 + 32);
                                                    v2[-2] = v24;
                                                    v24 = v27;
                                                    v2[-1] = v25;
                                                    v25 = *(__m128i *)(v3 + 48);
                                                    v19 = _mm_cmpeq_epi8(
                                                            v19,
                                                            _mm_min_epu8(_mm_min_epu8(v27, v25), _mm_min_epu8(v22, v23)));
                                                    v2 += 4;
                                                    v3 += 64;
                                                  }
                                                  while ( !_mm_movemask_epi8(v19) );
                                                }
                                                v7 = -64;
                                                v28 = _mm_cmpeq_epi8((__m128i)0LL, v22);
                                                v6 = _mm_movemask_epi8(v28);
                                                if ( !v6 )
                                                {
                                                  v29 = _mm_cmpeq_epi8(v28, v23);
                                                  v6 = _mm_movemask_epi8(v29);
                                                  v2[-4] = v22;
                                                  v7 = -48;
                                                  if ( !v6 )
                                                  {
                                                    v30 = _mm_cmpeq_epi8(v29, v24);
                                                    v6 = _mm_movemask_epi8(v30);
                                                    v2[-3] = v23;
                                                    v7 = -32;
                                                    if ( !v6 )
                                                    {
                                                      v2[-2] = v24;
                                                      LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v30, v25));
                                                      v7 = -16;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  v31 = &v2->m128i_i8[v7];
                                  v32 = v7 + v3;
                                  if ( (_BYTE)v6 )
                                  {
                                    if ( (v6 & 1) != 0 )
                                    {
                                      *v31 = *(_BYTE *)v32;
                                      return v31;
                                    }
                                    else if ( (v6 & 2) != 0 )
                                    {
                                      *(_WORD *)v31 = *(_WORD *)v32;
                                      return v31 + 1;
                                    }
                                    else if ( (v6 & 4) != 0 )
                                    {
                                      *(_WORD *)v31 = *(_WORD *)v32;
                                      v31[2] = *(_BYTE *)(v32 + 2);
                                      return v31 + 2;
                                    }
                                    else if ( (v6 & 8) != 0 )
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      return v31 + 3;
                                    }
                                    else if ( (v6 & 0x10) != 0 )
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      v31[4] = *(_BYTE *)(v32 + 4);
                                      return v31 + 4;
                                    }
                                    else if ( (v6 & 0x20) != 0 )
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      *((_WORD *)v31 + 2) = *(_WORD *)(v32 + 4);
                                      return v31 + 5;
                                    }
                                    else
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      if ( (v6 & 0x40) != 0 )
                                      {
                                        *(_DWORD *)(v31 + 3) = *(_DWORD *)(v32 + 3);
                                        return v31 + 6;
                                      }
                                      else
                                      {
                                        *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                        return v31 + 7;
                                      }
                                    }
                                  }
                                  else if ( (v6 & 0x100) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    v31[8] = *(_BYTE *)(v32 + 8);
                                    return v31 + 8;
                                  }
                                  else if ( (v6 & 0x200) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    *((_WORD *)v31 + 4) = *(_WORD *)(v32 + 8);
                                    return v31 + 9;
                                  }
                                  else if ( (v6 & 0x400) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    *(_DWORD *)(v31 + 7) = *(_DWORD *)(v32 + 7);
                                    return v31 + 10;
                                  }
                                  else if ( (v6 & 0x800) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    *((_DWORD *)v31 + 2) = *(_DWORD *)(v32 + 8);
                                    return v31 + 11;
                                  }
                                  else if ( (v6 & 0x1000) != 0 )
                                  {
                                    *(double *)v31 = *(double *)v32;
                                    *(double *)(v31 + 5) = *(double *)(v32 + 5);
                                    return v31 + 12;
                                  }
                                  else if ( (v6 & 0x2000) != 0 )
                                  {
                                    *(double *)v31 = *(double *)v32;
                                    *(double *)(v31 + 6) = *(double *)(v32 + 6);
                                    return v31 + 13;
                                  }
                                  else
                                  {
                                    *(double *)v31 = *(double *)v32;
                                    if ( (v6 & 0x4000) != 0 )
                                    {
                                      *(double *)(v31 + 7) = *(double *)(v32 + 7);
                                      return v31 + 14;
                                    }
                                    else
                                    {
                                      *((double *)v31 + 1) = *(double *)(v32 + 8);
                                      return v31 + 15;
                                    }
                                  }
                                }
                                else
                                {
                                  *(double *)a1 = *(double *)a2;
                                  *(double *)(a1 + 8) = *(double *)(a2 + 8);
                                  return (char *)(a1 + 15);
                                }
                              }
                              else
                              {
                                *(double *)a1 = *(double *)a2;
                                *(double *)(a1 + 7) = *(double *)(a2 + 7);
                                return (char *)(a1 + 14);
                              }
                            }
                            else
                            {
                              *(double *)a1 = *(double *)a2;
                              *(double *)(a1 + 6) = *(double *)(a2 + 6);
                              return (char *)(a1 + 13);
                            }
                          }
                          else
                          {
                            *(double *)a1 = *(double *)a2;
                            *(double *)(a1 + 5) = *(double *)(a2 + 5);
                            return (char *)(a1 + 12);
                          }
                        }
                        else
                        {
                          *(_DWORD *)a1 = *(_DWORD *)a2;
                          *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
                          return (char *)(a1 + 11);
                        }
                      }
                      else
                      {
                        *(_DWORD *)a1 = *(_DWORD *)a2;
                        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                        *(_DWORD *)(a1 + 7) = *(_DWORD *)(a2 + 7);
                        return (char *)(a1 + 10);
                      }
                    }
                    else
                    {
                      *(_DWORD *)a1 = *(_DWORD *)a2;
                      *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                      *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
                      return (char *)(a1 + 9);
                    }
                  }
                  else
                  {
                    *(_DWORD *)a1 = *(_DWORD *)a2;
                    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                    *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
                    return (char *)(a1 + 8);
                  }
                }
                else
                {
                  *(_DWORD *)a1 = *(_DWORD *)a2;
                  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                  return (char *)(a1 + 7);
                }
              }
              else
              {
                *(_DWORD *)a1 = *(_DWORD *)a2;
                *(_DWORD *)(a1 + 3) = *(_DWORD *)(a2 + 3);
                return (char *)(a1 + 6);
              }
            }
            else
            {
              *(_DWORD *)a1 = *(_DWORD *)a2;
              *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
              return (char *)(a1 + 5);
            }
          }
          else
          {
            *(_DWORD *)a1 = *(_DWORD *)a2;
            *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
            return (char *)(a1 + 4);
          }
        }
        else
        {
          *(_DWORD *)a1 = *(_DWORD *)a2;
          return (char *)(a1 + 3);
        }
      }
      else
      {
        *(_WORD *)a1 = *(_WORD *)a2;
        *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
        return (char *)(a1 + 2);
      }
    }
    else
    {
      *(_WORD *)a1 = *(_WORD *)a2;
      return (char *)(a1 + 1);
    }
  }
  else
  {
    *(_BYTE *)a1 = *(_BYTE *)a2;
    return (char *)a1;
  }
}

//----- (08068890) --------------------------------------------------------
const __m128i *__cdecl _strchr_sse2(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm2
  const __m128i *v4; // edi
  __m128i v5; // xmm1
  int v6; // ecx
  __m128i v7; // xmm1
  unsigned int v8; // edi
  __m128i v9; // xmm0
  int v10; // edx
  int v11; // eax
  __m128i si128; // xmm0
  __m128i v13; // xmm2
  __m128i v14; // xmm0
  __m128i v15; // xmm2
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  __m128i v18; // xmm0

  v2 = _mm_cvtsi32_si128(a2);
  v3 = 0LL;
  v4 = a1;
  v5 = _mm_unpacklo_epi8(v2, v2);
  v6 = (unsigned __int8)a1 & 0xF;
  v7 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v5, v5), 0);
  if ( ((unsigned __int8)a1 & 0xF) == 0 )
  {
LABEL_7:
    while ( 1 )
    {
      si128 = _mm_load_si128(v4);
      v13 = _mm_cmpeq_epi8(v3, si128);
      v10 = _mm_movemask_epi8(v13);
      v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(si128, v7));
      if ( v11 )
        break;
      if ( v10 )
        return 0;
      v14 = _mm_load_si128(++v4);
      v15 = _mm_cmpeq_epi8(v13, v14);
      v10 = _mm_movemask_epi8(v15);
      v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(v14, v7));
      if ( v11 )
        break;
      if ( v10 )
        return 0;
      v16 = _mm_load_si128(++v4);
      v17 = _mm_cmpeq_epi8(v15, v16);
      v10 = _mm_movemask_epi8(v17);
      v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(v16, v7));
      if ( v11 )
        break;
      if ( v10 )
        return 0;
      v18 = _mm_load_si128(++v4);
      v3 = _mm_cmpeq_epi8(v17, v18);
      v10 = _mm_movemask_epi8(v3);
      v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(v18, v7));
      if ( v11 )
        break;
      if ( v10 )
        return 0;
      ++v4;
    }
    if ( v10 )
      goto LABEL_17;
LABEL_51:
    if ( (_BYTE)v11 )
    {
      if ( (v11 & 1) == 0 )
      {
        if ( (v11 & 2) == 0 )
        {
          if ( (v11 & 4) == 0 )
          {
            if ( (v11 & 8) != 0 )
              return (const __m128i *)&v4->m128i_i8[3];
            if ( (v11 & 0x10) == 0 )
            {
              if ( (v11 & 0x20) == 0 )
              {
                if ( (v11 & 0x40) == 0 )
                  return (const __m128i *)&v4->m128i_i8[7];
                return (const __m128i *)&v4->m128i_i8[6];
              }
              return (const __m128i *)&v4->m128i_i8[5];
            }
            return (const __m128i *)&v4->m128i_i8[4];
          }
          return (const __m128i *)&v4->m128i_i8[2];
        }
        return (const __m128i *)&v4->m128i_i8[1];
      }
      return v4;
    }
    if ( (v11 & 0x100) == 0 )
    {
      if ( (v11 & 0x200) == 0 )
      {
        if ( (v11 & 0x400) == 0 )
        {
          if ( (v11 & 0x800) != 0 )
            return (const __m128i *)&v4->m128i_i8[11];
          if ( (v11 & 0x1000) == 0 )
          {
            if ( (v11 & 0x2000) == 0 )
            {
              if ( (v11 & 0x4000) == 0 )
                return (const __m128i *)&v4->m128i_i8[15];
              return (const __m128i *)&v4->m128i_i8[14];
            }
            return (const __m128i *)&v4->m128i_i8[13];
          }
          return (const __m128i *)&v4->m128i_i8[12];
        }
        return (const __m128i *)&v4->m128i_i8[10];
      }
      return (const __m128i *)&v4->m128i_i8[9];
    }
    return (const __m128i *)&v4->m128i_i8[8];
  }
  v8 = (unsigned int)a1 & 0xFFFFFFF0;
  v9 = _mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0));
  v10 = _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v9)) >> v6;
  v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(v9, v7)) >> v6;
  if ( !v11 )
  {
    if ( !v10 )
    {
      v3 = 0LL;
      v4 = (const __m128i *)(v8 + 16);
      goto LABEL_7;
    }
    return 0;
  }
  v4 = (const __m128i *)(v6 + v8);
  if ( !v10 )
    goto LABEL_51;
LABEL_17:
  if ( !(_BYTE)v11 )
  {
    if ( (_BYTE)v10 )
      return 0;
    if ( (v11 & 0xF00) == 0 )
    {
      if ( (v10 & 0xF00) != 0 )
        return 0;
      if ( (v11 & 0x1000) == 0 )
      {
        if ( (v10 & 0x1000) != 0 )
          return 0;
        if ( (v11 & 0x2000) == 0 )
        {
          if ( (v10 & 0x2000) != 0 )
            return 0;
          if ( (v11 & 0x4000) == 0 )
          {
            if ( (v10 & 0x4000) == 0 )
              return (const __m128i *)&v4->m128i_i8[15];
            return 0;
          }
          return (const __m128i *)&v4->m128i_i8[14];
        }
        return (const __m128i *)&v4->m128i_i8[13];
      }
      return (const __m128i *)&v4->m128i_i8[12];
    }
    if ( (v11 & 0x100) == 0 )
    {
      if ( (v10 & 0x100) != 0 )
        return 0;
      if ( (v11 & 0x200) == 0 )
      {
        if ( (v10 & 0x200) != 0 )
          return 0;
        if ( (v11 & 0x400) == 0 )
        {
          if ( (v10 & 0x400) == 0 )
            return (const __m128i *)&v4->m128i_i8[11];
          return 0;
        }
        return (const __m128i *)&v4->m128i_i8[10];
      }
      return (const __m128i *)&v4->m128i_i8[9];
    }
    return (const __m128i *)&v4->m128i_i8[8];
  }
  if ( (v11 & 0xF) != 0 )
  {
    if ( (v11 & 1) == 0 )
    {
      if ( (v10 & 1) != 0 )
        return 0;
      if ( (v11 & 2) == 0 )
      {
        if ( (v10 & 2) != 0 )
          return 0;
        if ( (v11 & 4) == 0 )
        {
          if ( (v10 & 4) == 0 )
            return (const __m128i *)&v4->m128i_i8[3];
          return 0;
        }
        return (const __m128i *)&v4->m128i_i8[2];
      }
      return (const __m128i *)&v4->m128i_i8[1];
    }
    return v4;
  }
  if ( (v10 & 0xF) != 0 )
    return 0;
  if ( (v11 & 0x10) != 0 )
    return (const __m128i *)&v4->m128i_i8[4];
  if ( (v10 & 0x10) != 0 )
    return 0;
  if ( (v11 & 0x20) != 0 )
    return (const __m128i *)&v4->m128i_i8[5];
  if ( (v10 & 0x20) == 0 )
  {
    if ( (v11 & 0x40) == 0 )
    {
      if ( (v10 & 0x40) == 0 )
        return (const __m128i *)&v4->m128i_i8[7];
      return 0;
    }
    return (const __m128i *)&v4->m128i_i8[6];
  }
  return 0;
}

//----- (08068C70) --------------------------------------------------------
char *__cdecl _strchr_sse2_bsf(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm2
  const __m128i *v4; // edi
  __m128i v5; // xmm1
  int v6; // ecx
  __m128i v7; // xmm1
  unsigned int v8; // edi
  __m128i v9; // xmm0
  unsigned int v10; // edx
  unsigned int v11; // eax
  __m128i si128; // xmm0
  unsigned int v14; // eax
  __m128i v15; // xmm0
  __m128i v16; // xmm0
  __m128i v17; // xmm0
  unsigned int v18; // edx
  unsigned int v19; // ecx

  v2 = _mm_cvtsi32_si128(a2);
  v3 = 0LL;
  v4 = a1;
  v5 = _mm_unpacklo_epi8(v2, v2);
  v6 = (unsigned __int8)a1 & 0xF;
  v7 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v5, v5), 0);
  if ( ((unsigned __int8)a1 & 0xF) == 0 )
  {
    do
    {
LABEL_8:
      si128 = _mm_load_si128(v4);
      v3 = _mm_cmpeq_epi8(v3, si128);
      ++v4;
      v14 = _mm_movemask_epi8(_mm_cmpeq_epi8(si128, v7));
      if ( v14 | _mm_movemask_epi8(v3) )
        break;
      v15 = _mm_load_si128(v4);
      v3 = _mm_cmpeq_epi8(v3, v15);
      ++v4;
      v14 = _mm_movemask_epi8(_mm_cmpeq_epi8(v15, v7));
      if ( v14 | _mm_movemask_epi8(v3) )
        break;
      v16 = _mm_load_si128(v4);
      v3 = _mm_cmpeq_epi8(v3, v16);
      ++v4;
      v14 = _mm_movemask_epi8(_mm_cmpeq_epi8(v16, v7));
      if ( v14 | _mm_movemask_epi8(v3) )
        break;
      v17 = _mm_load_si128(v4);
      v3 = _mm_cmpeq_epi8(v3, v17);
      ++v4;
      v14 = _mm_movemask_epi8(_mm_cmpeq_epi8(v17, v7));
    }
    while ( !(v14 | _mm_movemask_epi8(v3)) );
    v18 = _mm_movemask_epi8(v3);
    if ( v14 )
    {
      _BitScanForward(&v14, v14);
      if ( !v18 )
        return (char *)&v4[-1] + v14;
      _BitScanForward(&v19, v18);
      if ( v14 <= v19 )
        return (char *)&v4[-1] + v14;
    }
    return 0;
  }
  v8 = (unsigned int)a1 & 0xFFFFFFF0;
  v9 = _mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0));
  v10 = _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v9)) >> v6;
  v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(v9, v7)) >> v6;
  if ( v11 )
  {
    _BitScanForward(&v11, v11);
    if ( !v10 )
      return (char *)(v6 + v8 + v11);
    _BitScanForward(&v10, v10);
    if ( v11 <= v10 )
      return (char *)(v6 + v8 + v11);
    return 0;
  }
  if ( !v10 )
  {
    v3 = 0LL;
    v4 = (const __m128i *)(v8 + 16);
    goto LABEL_8;
  }
  return 0;
}

//----- (08068D80) --------------------------------------------------------
const __m128i *__cdecl _memchr_sse2(const __m128i *a1, unsigned int a2, unsigned int a3)
{
  __m128i v3; // xmm1
  unsigned int v4; // edx
  __m128i v5; // xmm1
  const __m128i *v6; // edi
  __m128i v7; // xmm1
  int v8; // eax
  const __m128i *v9; // edi
  int v10; // edx
  int v11; // ecx
  bool v12; // cc
  unsigned int v13; // edx
  int v14; // ecx
  int v15; // eax
  unsigned int v16; // edi
  char v17; // cl
  __m128i v18; // xmm0
  __m128i v19; // xmm2
  __m128i v20; // xmm4
  const __m128i *v21; // edi
  unsigned int v23; // edx

  v3 = _mm_cvtsi32_si128(a2);
  v4 = a3;
  if ( !a3 )
    return 0;
  v5 = _mm_unpacklo_epi8(v3, v3);
  v6 = a1;
  v7 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v5, v5), 0);
  if ( ((unsigned __int8)a1 & 0x3Fu) > 0x30 )
  {
    v11 = (unsigned __int8)a1 & 0xF;
    v9 = (const __m128i *)((unsigned int)a1 & 0xFFFFFFF0);
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0)), v7)) >> v11;
    if ( v8 )
    {
LABEL_66:
      v6 = (const __m128i *)((char *)v9 + v11);
LABEL_67:
      if ( (_BYTE)v8 )
      {
        if ( (v8 & 0xF) != 0 )
        {
          if ( (v8 & 1) != 0 )
            return v6;
          if ( (v8 & 2) != 0 )
          {
            if ( v4 >= 2 )
              return (const __m128i *)&v6->m128i_i8[1];
          }
          else if ( (v8 & 4) != 0 )
          {
            if ( v4 >= 3 )
              return (const __m128i *)&v6->m128i_i8[2];
          }
          else if ( v4 >= 4 )
          {
            return (const __m128i *)&v6->m128i_i8[3];
          }
        }
        else if ( (v8 & 0x10) != 0 )
        {
          if ( v4 >= 5 )
            return (const __m128i *)&v6->m128i_i8[4];
        }
        else if ( (v8 & 0x20) != 0 )
        {
          if ( v4 >= 6 )
            return (const __m128i *)&v6->m128i_i8[5];
        }
        else if ( (v8 & 0x40) != 0 )
        {
          if ( v4 >= 7 )
            return (const __m128i *)&v6->m128i_i8[6];
        }
        else if ( v4 >= 8 )
        {
          return (const __m128i *)&v6->m128i_i8[7];
        }
      }
      else if ( (v8 & 0xF00) != 0 )
      {
        if ( (v8 & 0x100) != 0 )
        {
          if ( v4 >= 9 )
            return (const __m128i *)&v6->m128i_i8[8];
        }
        else if ( (v8 & 0x200) != 0 )
        {
          if ( v4 >= 0xA )
            return (const __m128i *)&v6->m128i_i8[9];
        }
        else if ( (v8 & 0x400) != 0 )
        {
          if ( v4 >= 0xB )
            return (const __m128i *)&v6->m128i_i8[10];
        }
        else if ( v4 >= 0xC )
        {
          return (const __m128i *)&v6->m128i_i8[11];
        }
      }
      else if ( (v8 & 0x1000) != 0 )
      {
        if ( v4 >= 0xD )
          return (const __m128i *)&v6->m128i_i8[12];
      }
      else if ( (v8 & 0x2000) != 0 )
      {
        if ( v4 >= 0xE )
          return (const __m128i *)&v6->m128i_i8[13];
      }
      else if ( (v8 & 0x4000) != 0 )
      {
        if ( v4 >= 0xF )
          return (const __m128i *)&v6->m128i_i8[14];
      }
      else if ( v4 >= 0x10 )
      {
        return (const __m128i *)&v6->m128i_i8[15];
      }
      return 0;
    }
    v10 = v11 + a3 - 16;
    if ( (v10 < 0) ^ __OFADD__(v11, a3 - 16) | (v10 == 0) )
      return 0;
    ++v9;
  }
  else
  {
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v7));
    if ( v8 )
      goto LABEL_67;
    if ( a3 <= 0x10 )
      return 0;
    v9 = (const __m128i *)((unsigned int)&a1[1] & 0xFFFFFFF0);
    v10 = ((unsigned __int8)a1 & 0xF) + a3 - 16;
  }
  v12 = (unsigned int)v10 <= 0x40;
  v13 = v10 - 64;
  if ( v12 )
  {
LABEL_45:
    v23 = v13 + 64;
    v11 = 0;
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9), v7));
    if ( v8 )
      goto LABEL_65;
    if ( v23 <= 0x10 )
      return 0;
    v11 = 16;
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 1), v7));
    if ( v8 )
      goto LABEL_65;
    if ( v23 <= 0x20 )
      return 0;
    v11 = 32;
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v7));
    if ( v8 )
    {
LABEL_65:
      v4 = v23 - v11;
      goto LABEL_66;
    }
    if ( v23 > 0x30 )
    {
      v11 = 48;
      v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(v7, v9[3]));
      if ( !v8 )
        return 0;
      goto LABEL_65;
    }
    return 0;
  }
  v14 = 0;
  v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9), v7));
  if ( !v15 )
  {
    v14 = 1;
    v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 1), v7));
    if ( !v15 )
    {
      v14 = 2;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v7));
      if ( !v15 )
      {
        v14 = 3;
        v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 3), v7));
        if ( !v15 )
        {
          v9 += 4;
          v12 = v13 <= 0x40;
          v13 -= 64;
          if ( v12 )
            goto LABEL_45;
          v14 = 0;
          v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9), v7));
          if ( !v15 )
          {
            v14 = 1;
            v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 1), v7));
            if ( !v15 )
            {
              v14 = 2;
              v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v7));
              if ( !v15 )
              {
                v14 = 3;
                v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 3), v7));
                if ( !v15 )
                {
                  v16 = (unsigned int)&v9[4];
                  v17 = v16;
                  v9 = (const __m128i *)(v16 & 0xFFFFFFC0);
                  v13 += v17 & 0x3F;
                  while ( 1 )
                  {
                    v12 = v13 <= 0x40;
                    v13 -= 64;
                    if ( v12 )
                      goto LABEL_45;
                    v18 = _mm_cmpeq_epi8(_mm_load_si128(v9), v7);
                    v19 = _mm_cmpeq_epi8(_mm_load_si128(v9 + 1), v7);
                    v20 = _mm_max_epu8(
                            _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 3), v7), v19),
                            _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v7), v18));
                    v9 += 4;
                    if ( _mm_movemask_epi8(v20) )
                    {
                      v9 -= 4;
                      v15 = _mm_movemask_epi8(v18);
                      v14 = 0;
                      if ( !v15 )
                      {
                        v15 = _mm_movemask_epi8(v19);
                        v14 = 1;
                        if ( !v15 )
                        {
                          v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v7));
                          v14 = 2;
                          if ( !v15 )
                          {
                            LOWORD(v15) = _mm_movemask_epi8(_mm_cmpeq_epi8(v7, v9[3]));
                            v14 = 3;
                          }
                        }
                      }
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v21 = &v9[v14];
  if ( (_BYTE)v15 )
  {
    if ( (v15 & 0xF) != 0 )
    {
      if ( (v15 & 1) != 0 )
      {
        return v21;
      }
      else if ( (v15 & 2) != 0 )
      {
        return (const __m128i *)&v21->m128i_i8[1];
      }
      else if ( (v15 & 4) != 0 )
      {
        return (const __m128i *)&v21->m128i_i8[2];
      }
      else
      {
        return (const __m128i *)&v21->m128i_i8[3];
      }
    }
    else if ( (v15 & 0x10) != 0 )
    {
      return (const __m128i *)&v21->m128i_i8[4];
    }
    else if ( (v15 & 0x20) != 0 )
    {
      return (const __m128i *)&v21->m128i_i8[5];
    }
    else if ( (v15 & 0x40) != 0 )
    {
      return (const __m128i *)&v21->m128i_i8[6];
    }
    else
    {
      return (const __m128i *)&v21->m128i_i8[7];
    }
  }
  else if ( (v15 & 0xF00) != 0 )
  {
    if ( (v15 & 0x100) != 0 )
    {
      return (const __m128i *)&v21->m128i_i8[8];
    }
    else if ( (v15 & 0x200) != 0 )
    {
      return (const __m128i *)&v21->m128i_i8[9];
    }
    else if ( (v15 & 0x400) != 0 )
    {
      return (const __m128i *)&v21->m128i_i8[10];
    }
    else
    {
      return (const __m128i *)&v21->m128i_i8[11];
    }
  }
  else if ( (v15 & 0x1000) != 0 )
  {
    return (const __m128i *)&v21->m128i_i8[12];
  }
  else if ( (v15 & 0x2000) != 0 )
  {
    return (const __m128i *)&v21->m128i_i8[13];
  }
  else if ( (v15 & 0x4000) != 0 )
  {
    return (const __m128i *)&v21->m128i_i8[14];
  }
  else
  {
    return (const __m128i *)&v21->m128i_i8[15];
  }
}

//----- (080692F0) --------------------------------------------------------
int __cdecl _memchr_sse2_bsf(const __m128i *a1, unsigned int a2, unsigned int a3)
{
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  __m128i v5; // xmm1
  unsigned int v6; // ecx
  const __m128i *v8; // edi
  int v9; // edx
  int v10; // ecx
  unsigned int v11; // edi
  unsigned int v12; // eax
  bool v13; // cc
  unsigned int v14; // edx
  unsigned int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // eax
  __m128i v18; // xmm4
  unsigned int v19; // eax
  char v20; // cl
  __m128i v21; // xmm0
  __m128i v22; // xmm2
  int v23; // eax
  __m128i v24; // xmm3
  __m128i v25; // xmm1
  unsigned int v26; // eax
  unsigned int v27; // edx
  unsigned int v28; // eax
  unsigned int v29; // eax
  unsigned int v30; // eax
  unsigned int v31; // eax

  v3 = _mm_cvtsi32_si128(a2);
  if ( !a3 )
    return 0;
  v4 = _mm_unpacklo_epi8(v3, v3);
  v5 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v4, v4), 0);
  if ( ((unsigned __int8)a1 & 0x3Fu) <= 0x30 )
  {
    v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v5));
    if ( v6 )
    {
      _BitScanForward(&v6, v6);
      if ( a3 > v6 )
        return (int)a1 + v6;
      return 0;
    }
    if ( a3 > 0x10 )
    {
      v8 = (const __m128i *)((unsigned int)&a1[1] & 0xFFFFFFF0);
      v9 = ((unsigned __int8)a1 & 0xF) + a3 - 16;
      goto LABEL_14;
    }
    return 0;
  }
  v10 = (unsigned __int8)a1 & 0xF;
  v11 = (unsigned int)a1 & 0xFFFFFFF0;
  v12 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0)), v5)) >> v10;
  if ( v12 )
  {
    _BitScanForward(&v12, v12);
    if ( a3 > v12 )
      return v10 + v11 + v12;
    return 0;
  }
  v9 = v10 + a3 - 16;
  if ( !((v9 < 0) ^ __OFADD__(v10, a3 - 16) | (v9 == 0)) )
  {
    v8 = (const __m128i *)(v11 + 16);
LABEL_14:
    v13 = (unsigned int)v9 <= 0x40;
    v14 = v9 - 64;
    if ( v13 )
      goto LABEL_32;
    v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8), v5));
    if ( v15 )
      goto LABEL_44;
    v16 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 1), v5));
    if ( v16 )
      goto LABEL_45;
    v17 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 2), v5));
    if ( !v17 )
    {
      v18 = _mm_cmpeq_epi8(_mm_load_si128(v8 + 3), v5);
      v8 += 4;
      v19 = _mm_movemask_epi8(v18);
      if ( v19 )
        goto LABEL_43;
      if ( ((unsigned __int8)v8 & 0x3F) == 0 )
        goto LABEL_26;
      v13 = v14 <= 0x40;
      v14 -= 64;
      if ( v13 )
        goto LABEL_32;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8), v5));
      if ( v15 )
        goto LABEL_44;
      v16 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 1), v5));
      if ( v16 )
        goto LABEL_45;
      v17 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 2), v5));
      if ( !v17 )
      {
        v19 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 3), v5));
        v8 += 4;
        if ( !v19 )
        {
          v20 = (char)v8;
          v8 = (const __m128i *)((unsigned int)v8 & 0xFFFFFFC0);
          v14 += v20 & 0x3F;
LABEL_26:
          while ( 1 )
          {
            v13 = v14 <= 0x40;
            v14 -= 64;
            if ( v13 )
              break;
            v21 = _mm_cmpeq_epi8(_mm_load_si128(v8), v5);
            v22 = _mm_cmpeq_epi8(_mm_load_si128(v8 + 1), v5);
            v23 = _mm_movemask_epi8(
                    _mm_max_epu8(
                      _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 3), v5), v22),
                      _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 2), v5), v21)));
            v8 += 4;
            if ( v23 )
            {
              v8 -= 4;
              v15 = _mm_movemask_epi8(v21);
              if ( v15 )
                goto LABEL_44;
              v16 = _mm_movemask_epi8(v22);
              if ( v16 )
                goto LABEL_45;
              v24 = _mm_cmpeq_epi8(_mm_load_si128(v8 + 2), v5);
              v25 = _mm_cmpeq_epi8(v5, v8[3]);
              v17 = _mm_movemask_epi8(v24);
              if ( v17 )
                goto LABEL_46;
              _BitScanForward(&v26, _mm_movemask_epi8(v25));
              return (int)&v8[3] + v26;
            }
          }
LABEL_32:
          v27 = v14 + 64;
          if ( v27 <= 0x20 )
          {
            v30 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8), v5));
            if ( v30 )
            {
              _BitScanForward(&v30, v30);
              if ( v27 > v30 )
                return (int)v8 + v30;
            }
            else if ( v27 > 0x10 )
            {
              v31 = _mm_movemask_epi8(_mm_cmpeq_epi8(v5, v8[1]));
              if ( !v31 )
                return 0;
              _BitScanForward(&v31, v31);
              if ( v27 - 16 > v31 )
                return (int)&v8[1] + v31;
            }
            return 0;
          }
          v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8), v5));
          if ( !v15 )
          {
            v16 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 1), v5));
            if ( !v16 )
            {
              v28 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 2), v5));
              if ( v28 )
              {
                _BitScanForward(&v28, v28);
                if ( v27 - 32 > v28 )
                  return (int)&v8[2] + v28;
              }
              else if ( v27 > 0x30 )
              {
                v29 = _mm_movemask_epi8(_mm_cmpeq_epi8(v5, v8[3]));
                if ( !v29 )
                  return 0;
                _BitScanForward(&v29, v29);
                if ( v27 - 48 > v29 )
                  return (int)&v8[3] + v29;
              }
              return 0;
            }
LABEL_45:
            _BitScanForward(&v16, v16);
            return (int)&v8[1] + v16;
          }
LABEL_44:
          _BitScanForward(&v15, v15);
          return (int)v8 + v15;
        }
LABEL_43:
        _BitScanForward(&v19, v19);
        return (int)&v8[-1] + v19;
      }
    }
LABEL_46:
    _BitScanForward(&v17, v17);
    return (int)&v8[2] + v17;
  }
  return 0;
}

//----- (08069640) --------------------------------------------------------
const __m128i *__cdecl _rawmemchr_sse2(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  const __m128i *v4; // edx
  __m128i v5; // xmm1
  int v6; // eax
  const __m128i *v7; // edx
  int v8; // ecx
  const __m128i *v9; // edx
  __m128i v10; // xmm0
  __m128i v11; // xmm2
  __m128i v12; // xmm4

  v2 = _mm_cvtsi32_si128(a2);
  v3 = _mm_unpacklo_epi8(v2, v2);
  v4 = a1;
  v5 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v3, v3), 0);
  if ( ((unsigned __int8)a1 & 0x3Fu) <= 0x30 )
  {
    v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v5));
    if ( v6 )
      goto LABEL_21;
    v7 = (const __m128i *)((unsigned int)&a1[1] & 0xFFFFFFF0);
    goto LABEL_6;
  }
  v8 = (unsigned __int8)a1 & 0xF;
  v7 = (const __m128i *)((unsigned int)a1 & 0xFFFFFFF0);
  v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0)), v5)) >> v8;
  if ( !v6 )
  {
    ++v7;
LABEL_6:
    v8 = 0;
    v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7), v5));
    if ( !v6 )
    {
      v8 = 16;
      v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 1), v5));
      if ( !v6 )
      {
        v8 = 32;
        v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v5));
        if ( !v6 )
        {
          v8 = 48;
          v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 3), v5));
          if ( !v6 )
          {
            v7 += 4;
            v8 = 0;
            v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7), v5));
            if ( !v6 )
            {
              v8 = 16;
              v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 1), v5));
              if ( !v6 )
              {
                v8 = 32;
                v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v5));
                if ( !v6 )
                {
                  v8 = 48;
                  v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 3), v5));
                  if ( !v6 )
                  {
                    v9 = (const __m128i *)((unsigned int)&v7[4] & 0xFFFFFFC0);
                    do
                    {
                      v10 = _mm_cmpeq_epi8(_mm_load_si128(v9), v5);
                      v11 = _mm_cmpeq_epi8(_mm_load_si128(v9 + 1), v5);
                      v12 = _mm_max_epu8(
                              _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 3), v5), v11),
                              _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v5), v10));
                      v9 += 4;
                    }
                    while ( !_mm_movemask_epi8(v12) );
                    v7 = v9 - 4;
                    v6 = _mm_movemask_epi8(v10);
                    v8 = 0;
                    if ( !v6 )
                    {
                      v6 = _mm_movemask_epi8(v11);
                      v8 = 16;
                      if ( !v6 )
                      {
                        v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v5));
                        v8 = 32;
                        if ( !v6 )
                        {
                          LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v5, v7[3]));
                          v8 = 48;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v4 = (const __m128i *)((char *)v7 + v8);
LABEL_21:
  if ( (_BYTE)v6 )
  {
    if ( (v6 & 0xF) != 0 )
    {
      if ( (v6 & 1) != 0 )
      {
        return v4;
      }
      else if ( (v6 & 2) != 0 )
      {
        return (const __m128i *)&v4->m128i_i8[1];
      }
      else if ( (v6 & 4) != 0 )
      {
        return (const __m128i *)&v4->m128i_i8[2];
      }
      else
      {
        return (const __m128i *)&v4->m128i_i8[3];
      }
    }
    else if ( (v6 & 0x10) != 0 )
    {
      return (const __m128i *)&v4->m128i_i8[4];
    }
    else if ( (v6 & 0x20) != 0 )
    {
      return (const __m128i *)&v4->m128i_i8[5];
    }
    else if ( (v6 & 0x40) != 0 )
    {
      return (const __m128i *)&v4->m128i_i8[6];
    }
    else
    {
      return (const __m128i *)&v4->m128i_i8[7];
    }
  }
  else if ( (v6 & 0xF00) != 0 )
  {
    if ( (v6 & 0x100) != 0 )
    {
      return (const __m128i *)&v4->m128i_i8[8];
    }
    else if ( (v6 & 0x200) != 0 )
    {
      return (const __m128i *)&v4->m128i_i8[9];
    }
    else if ( (v6 & 0x400) != 0 )
    {
      return (const __m128i *)&v4->m128i_i8[10];
    }
    else
    {
      return (const __m128i *)&v4->m128i_i8[11];
    }
  }
  else if ( (v6 & 0x1000) != 0 )
  {
    return (const __m128i *)&v4->m128i_i8[12];
  }
  else if ( (v6 & 0x2000) != 0 )
  {
    return (const __m128i *)&v4->m128i_i8[13];
  }
  else if ( (v6 & 0x4000) != 0 )
  {
    return (const __m128i *)&v4->m128i_i8[14];
  }
  else
  {
    return (const __m128i *)&v4->m128i_i8[15];
  }
}

//----- (08069960) --------------------------------------------------------
int __cdecl _rawmemchr_sse2_bsf(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  unsigned int v5; // ecx
  const __m128i *v7; // edx
  int v8; // ecx
  unsigned int v9; // edx
  int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  __m128i v14; // xmm4
  unsigned int v15; // eax
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  int v18; // eax
  __m128i v19; // xmm3
  __m128i v20; // xmm1
  unsigned int v21; // eax

  v2 = _mm_cvtsi32_si128(a2);
  v3 = _mm_unpacklo_epi8(v2, v2);
  v4 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v3, v3), 0);
  if ( ((unsigned __int8)a1 & 0x3Fu) > 0x30 )
  {
    v8 = (unsigned __int8)a1 & 0xF;
    v9 = (unsigned int)a1 & 0xFFFFFFF0;
    v10 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0)), v4)) >> v8;
    if ( v10 )
    {
      _BitScanForward((unsigned int *)&v10, v10);
      return v8 + v9 + v10;
    }
    v7 = (const __m128i *)(v9 + 16);
  }
  else
  {
    v5 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v4));
    if ( v5 )
    {
      _BitScanForward(&v5, v5);
      return (int)a1 + v5;
    }
    v7 = (const __m128i *)((unsigned int)&a1[1] & 0xFFFFFFF0);
  }
  v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7), v4));
  if ( v11 )
    goto LABEL_24;
  v12 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 1), v4));
  if ( v12 )
    goto LABEL_25;
  v13 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v4));
  if ( !v13 )
  {
    v14 = _mm_cmpeq_epi8(_mm_load_si128(v7 + 3), v4);
    v7 += 4;
    v15 = _mm_movemask_epi8(v14);
    if ( v15 )
      goto LABEL_23;
    if ( ((unsigned __int8)v7 & 0x3F) == 0 )
      goto LABEL_18;
    v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7), v4));
    if ( v11 )
      goto LABEL_24;
    v12 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 1), v4));
    if ( v12 )
      goto LABEL_25;
    v13 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v4));
    if ( !v13 )
    {
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 3), v4));
      v7 += 4;
      if ( !v15 )
      {
        v7 = (const __m128i *)((unsigned int)v7 & 0xFFFFFFC0);
        do
        {
LABEL_18:
          v16 = _mm_cmpeq_epi8(_mm_load_si128(v7), v4);
          v17 = _mm_cmpeq_epi8(_mm_load_si128(v7 + 1), v4);
          v18 = _mm_movemask_epi8(
                  _mm_max_epu8(
                    _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 3), v4), v17),
                    _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v4), v16)));
          v7 += 4;
        }
        while ( !v18 );
        v7 -= 4;
        v11 = _mm_movemask_epi8(v16);
        if ( !v11 )
        {
          v12 = _mm_movemask_epi8(v17);
          if ( !v12 )
          {
            v19 = _mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v4);
            v20 = _mm_cmpeq_epi8(v4, v7[3]);
            v13 = _mm_movemask_epi8(v19);
            if ( !v13 )
            {
              _BitScanForward(&v21, _mm_movemask_epi8(v20));
              return (int)&v7[3] + v21;
            }
            goto LABEL_26;
          }
LABEL_25:
          _BitScanForward(&v12, v12);
          return (int)&v7[1] + v12;
        }
LABEL_24:
        _BitScanForward(&v11, v11);
        return (int)v7 + v11;
      }
LABEL_23:
      _BitScanForward(&v15, v15);
      return (int)&v7[-1] + v15;
    }
  }
LABEL_26:
  _BitScanForward(&v13, v13);
  return (int)&v7[2] + v13;
}

//----- (08069B80) --------------------------------------------------------
int __cdecl _strcasecmp_l_nonascii(char *a1, unsigned __int8 *a2, int a3)
{
  char *v3; // ecx
  unsigned __int8 *v4; // edx
  char v5; // di
  int v6; // esi

  v3 = a1;
  v4 = a2;
  if ( a1 == (char *)a2 )
    return 0;
  do
  {
    v5 = *v3;
    v6 = *(_DWORD *)(*(_DWORD *)(a3 + 56) + 4 * (unsigned __int8)*v3) - *(_DWORD *)(*(_DWORD *)(a3 + 56) + 4 * *v4++);
    if ( v6 )
      break;
    ++v3;
  }
  while ( v5 );
  return v6;
}

//----- (08069BD0) --------------------------------------------------------
int __cdecl _strcasecmp_ssse3(char *a1, unsigned __int8 *a2)
{
  if ( (*(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFDC) + 320) & 1) == 0 )
    JUMPOUT(0x8069C06);
  return _strcasecmp_nonascii(a1, a2);
}
// 8069BE8: control flows out of bounds to 8069C06

//----- (08069BF0) --------------------------------------------------------
int __cdecl _strcasecmp_l_ssse3(char *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // edx
  unsigned __int8 *v4; // eax
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __m128i v7; // xmm1
  int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // edi
  const __m128i *v11; // eax
  const __m128i *v12; // edx
  const __m128i *v13; // et0
  unsigned int v14; // et1
  int v15; // edi
  bool v16; // zf
  __m128i si128; // xmm1
  __m128i v18; // xmm2
  unsigned int v19; // edi
  int v20; // esi
  int v21; // edi
  __m128i v22; // xmm0
  __m128i v23; // xmm1
  __m128i v24; // xmm2
  __m128i v25; // xmm1
  __m128i v26; // xmm1
  __m128i v27; // xmm2
  unsigned int v28; // edi
  __m128i v29; // xmm3
  __m128i v30; // xmm0
  int v31; // edi
  char v32; // cc
  __m128i v33; // xmm1
  __m128i v34; // xmm4
  __m128i v35; // xmm2
  __m128i v36; // xmm1
  __m128i v37; // xmm1
  __m128i v38; // xmm4
  __m128i v39; // xmm2
  __m128i v40; // xmm1
  __m128i v41; // xmm0
  __m128i v42; // xmm1
  __m128i v43; // xmm0
  __m128i v44; // xmm3
  __m128i v45; // xmm1
  __m128i v46; // xmm2
  unsigned int v47; // edi
  __m128i v48; // xmm3
  __m128i v49; // xmm0
  int v50; // edi
  __m128i v51; // xmm1
  __m128i v52; // xmm4
  __m128i v53; // xmm2
  __m128i v54; // xmm1
  __m128i v55; // xmm1
  __m128i v56; // xmm4
  __m128i v57; // xmm2
  __m128i v58; // xmm1
  __m128i v59; // xmm0
  __m128i v60; // xmm1
  __m128i v61; // xmm2
  unsigned int v62; // edi
  __m128i v63; // xmm3
  __m128i v64; // xmm0
  int v65; // edi
  __m128i v66; // xmm1
  __m128i v67; // xmm4
  __m128i v68; // xmm2
  __m128i v69; // xmm1
  __m128i v70; // xmm1
  __m128i v71; // xmm4
  __m128i v72; // xmm2
  __m128i v73; // xmm1
  __m128i v74; // xmm0
  __m128i v75; // xmm1
  __m128i v76; // xmm2
  unsigned int v77; // edi
  __m128i v78; // xmm3
  __m128i v79; // xmm0
  int v80; // edi
  __m128i v81; // xmm1
  __m128i v82; // xmm4
  __m128i v83; // xmm2
  __m128i v84; // xmm1
  __m128i v85; // xmm1
  __m128i v86; // xmm4
  __m128i v87; // xmm2
  __m128i v88; // xmm1
  __m128i v89; // xmm0
  __m128i v90; // xmm1
  __m128i v91; // xmm2
  unsigned int v92; // edi
  __m128i v93; // xmm3
  __m128i v94; // xmm0
  int v95; // edi
  __m128i v96; // xmm1
  __m128i v97; // xmm4
  __m128i v98; // xmm2
  __m128i v99; // xmm1
  __m128i v100; // xmm1
  __m128i v101; // xmm4
  __m128i v102; // xmm2
  __m128i v103; // xmm1
  __m128i v104; // xmm0
  __m128i v105; // xmm1
  __m128i v106; // xmm2
  unsigned int v107; // edi
  __m128i v108; // xmm3
  __m128i v109; // xmm0
  int v110; // edi
  __m128i v111; // xmm1
  __m128i v112; // xmm4
  __m128i v113; // xmm2
  __m128i v114; // xmm1
  __m128i v115; // xmm1
  __m128i v116; // xmm4
  __m128i v117; // xmm2
  __m128i v118; // xmm1
  __m128i v119; // xmm0
  __m128i v120; // xmm1
  __m128i v121; // xmm2
  unsigned int v122; // edi
  __m128i v123; // xmm3
  __m128i v124; // xmm0
  int v125; // edi
  __m128i v126; // xmm1
  __m128i v127; // xmm4
  __m128i v128; // xmm2
  __m128i v129; // xmm1
  __m128i v130; // xmm1
  __m128i v131; // xmm4
  __m128i v132; // xmm2
  __m128i v133; // xmm1
  __m128i v134; // xmm0
  __m128i v135; // xmm1
  __m128i v136; // xmm2
  unsigned int v137; // edi
  __m128i v138; // xmm3
  __m128i v139; // xmm0
  int v140; // edi
  __m128i v141; // xmm1
  __m128i v142; // xmm4
  __m128i v143; // xmm2
  __m128i v144; // xmm1
  __m128i v145; // xmm1
  __m128i v146; // xmm4
  __m128i v147; // xmm2
  __m128i v148; // xmm1
  __m128i v149; // xmm0
  __m128i v150; // xmm1
  __m128i v151; // xmm2
  unsigned int v152; // edi
  __m128i v153; // xmm3
  __m128i v154; // xmm0
  int v155; // edi
  __m128i v156; // xmm1
  __m128i v157; // xmm4
  __m128i v158; // xmm2
  __m128i v159; // xmm1
  __m128i v160; // xmm1
  __m128i v161; // xmm4
  __m128i v162; // xmm2
  __m128i v163; // xmm1
  __m128i v164; // xmm0
  __m128i v165; // xmm1
  __m128i v166; // xmm2
  unsigned int v167; // edi
  __m128i v168; // xmm3
  __m128i v169; // xmm0
  int v170; // edi
  __m128i v171; // xmm1
  __m128i v172; // xmm4
  __m128i v173; // xmm2
  __m128i v174; // xmm1
  __m128i v175; // xmm1
  __m128i v176; // xmm4
  __m128i v177; // xmm2
  __m128i v178; // xmm1
  __m128i v179; // xmm0
  __m128i v180; // xmm1
  __m128i v181; // xmm2
  unsigned int v182; // edi
  __m128i v183; // xmm3
  __m128i v184; // xmm0
  int v185; // edi
  __m128i v186; // xmm1
  __m128i v187; // xmm4
  __m128i v188; // xmm2
  __m128i v189; // xmm1
  __m128i v190; // xmm1
  __m128i v191; // xmm4
  __m128i v192; // xmm2
  __m128i v193; // xmm1
  __m128i v194; // xmm0
  __m128i v195; // xmm1
  __m128i v196; // xmm2
  unsigned int v197; // edi
  __m128i v198; // xmm3
  __m128i v199; // xmm0
  int v200; // edi
  __m128i v201; // xmm1
  __m128i v202; // xmm4
  __m128i v203; // xmm2
  __m128i v204; // xmm1
  __m128i v205; // xmm1
  __m128i v206; // xmm4
  __m128i v207; // xmm2
  __m128i v208; // xmm1
  __m128i v209; // xmm0
  __m128i v210; // xmm1
  __m128i v211; // xmm2
  unsigned int v212; // edi
  __m128i v213; // xmm3
  __m128i v214; // xmm0
  int v215; // edi
  __m128i v216; // xmm1
  __m128i v217; // xmm4
  __m128i v218; // xmm2
  __m128i v219; // xmm1
  __m128i v220; // xmm1
  __m128i v221; // xmm4
  __m128i v222; // xmm2
  __m128i v223; // xmm1
  __m128i v224; // xmm0
  __m128i v225; // xmm1
  __m128i v226; // xmm2
  unsigned int v227; // edi
  __m128i v228; // xmm3
  __m128i v229; // xmm0
  int v230; // edi
  __m128i v231; // xmm1
  __m128i v232; // xmm4
  __m128i v233; // xmm2
  __m128i v234; // xmm1
  __m128i v235; // xmm1
  __m128i v236; // xmm4
  __m128i v237; // xmm2
  __m128i v238; // xmm1
  __m128i v239; // xmm0
  __m128i v240; // xmm1
  __m128i v241; // xmm2
  unsigned int v242; // edi
  __m128i v243; // xmm3
  __m128i v244; // xmm0
  int v245; // edi
  __m128i v246; // xmm1
  __m128i v247; // xmm4
  __m128i v248; // xmm2
  __m128i v249; // xmm1
  __m128i v250; // xmm1
  __m128i v251; // xmm4
  __m128i v252; // xmm2
  __m128i v253; // xmm1
  __m128i v254; // xmm0
  unsigned __int8 *v255; // et2
  char v257; // [esp+0h] [ebp-Ch]

  if ( (*(_DWORD *)(*(_DWORD *)a3 + 320) & 1) != 0 )
    return _strcasecmp_nonascii(a1, a2);
  v3 = (unsigned __int8 *)a1;
  v4 = a2;
  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFF0 && ((unsigned __int16)a2 & 0xFFFu) <= 0xFF0 )
  {
    v5.m128i_i64[0] = *(__int64 *)a2;
    v6.m128i_i64[0] = *(__int64 *)a1;
    v5.m128i_i64[1] = *((__int64 *)a2 + 1);
    v6.m128i_i64[1] = *((__int64 *)a1 + 1);
    v7 = _mm_or_si128(
           v5,
           _mm_and_si128(
             _mm_and_si128(
               _mm_cmpgt_epi8(v5, (__m128i)xmmword_80BE5A0),
               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v5)),
             (__m128i)xmmword_80BE5C0));
    v8 = _mm_movemask_epi8(
           _mm_sub_epi8(
             _mm_cmpeq_epi8(
               v7,
               _mm_or_si128(
                 v6,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v6, (__m128i)xmmword_80BE5A0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v6)),
                   (__m128i)xmmword_80BE5C0))),
             _mm_cmpeq_epi8((__m128i)0LL, v7)))
       - 0xFFFF;
    if ( v8 )
      goto LABEL_184;
    v4 = a2 + 16;
    v3 = (unsigned __int8 *)(a1 + 16);
  }
  v257 = 0;
  v9 = (unsigned __int8)v4 & 0xF;
  v10 = (unsigned __int8)v3 & 0xF;
  v11 = (const __m128i *)(v9 ^ (unsigned int)v4);
  v12 = (const __m128i *)(v10 ^ (unsigned int)v3);
  if ( v9 == v10 )
  {
LABEL_25:
    si128 = _mm_load_si128(v11);
    v18 = _mm_load_si128(v12);
    v19 = (unsigned int)_mm_movemask_epi8(
                          _mm_sub_epi8(
                            _mm_cmpeq_epi8(
                              _mm_or_si128(
                                si128,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(si128, (__m128i)xmmword_80BE5A0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), si128)),
                                  (__m128i)xmmword_80BE5C0)),
                              _mm_or_si128(
                                v18,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(v18, (__m128i)xmmword_80BE5A0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v18)),
                                  (__m128i)xmmword_80BE5C0))),
                            _mm_cmpeq_epi8((__m128i)0LL, si128))) >> v9;
    v20 = (0xFFFFu >> v9) - v19;
    v16 = 0xFFFFu >> v9 == v19;
    v21 = v9;
    if ( v16 )
    {
      v257 = 16;
      v9 = 16;
      v22 = 0LL;
      while ( 1 )
      {
        v23 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
        v24 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
        v25 = _mm_or_si128(
                v23,
                _mm_and_si128(
                  _mm_and_si128(
                    _mm_cmpgt_epi8(v23, (__m128i)xmmword_80BE5A0),
                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v23)),
                  (__m128i)xmmword_80BE5C0));
        v22 = _mm_cmpeq_epi8(v22, v25);
        v20 = _mm_movemask_epi8(
                _mm_sub_epi8(
                  _mm_cmpeq_epi8(
                    v25,
                    _mm_or_si128(
                      v24,
                      _mm_and_si128(
                        _mm_and_si128(
                          _mm_cmpgt_epi8(v24, (__m128i)xmmword_80BE5A0),
                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v24)),
                        (__m128i)xmmword_80BE5C0))),
                  v22))
            - 0xFFFF;
        if ( v20 )
          break;
        v9 += 16;
      }
      goto LABEL_180;
    }
    goto LABEL_181;
  }
  if ( v9 <= v10 )
  {
    v257 = 32;
    v13 = v11;
    v11 = v12;
    v12 = v13;
    v14 = v9;
    v9 = v10;
    v10 = v14;
  }
  v15 = v10 + 15 - v9;
  v16 = v15 == 8;
  if ( v15 <= 8 )
    goto LABEL_16;
  if ( v15 != 14 )
  {
    if ( v15 != 13 )
    {
      if ( v15 != 12 )
      {
        if ( v15 != 11 )
        {
          if ( v15 != 10 )
          {
            v16 = v15 == 9;
            if ( v15 != 9 )
            {
LABEL_16:
              if ( !v16 )
              {
                if ( v15 != 7 )
                {
                  if ( v15 != 6 )
                  {
                    if ( v15 != 5 )
                    {
                      if ( v15 != 4 )
                      {
                        if ( v15 != 3 )
                        {
                          if ( v15 != 2 )
                          {
                            if ( v15 != 1 )
                            {
                              if ( v15 )
                                goto LABEL_25;
                              v26 = _mm_load_si128(v11);
                              v27 = _mm_slli_si128(_mm_load_si128(v12), 15);
                              v28 = (unsigned int)_mm_movemask_epi8(
                                                    _mm_sub_epi8(
                                                      _mm_cmpeq_epi8(
                                                        _mm_or_si128(
                                                          v27,
                                                          _mm_and_si128(
                                                            _mm_and_si128(
                                                              _mm_cmpgt_epi8(v27, (__m128i)xmmword_80BE5A0),
                                                              _mm_cmpgt_epi8(
                                                                _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                                v27)),
                                                            (__m128i)xmmword_80BE5C0)),
                                                        _mm_or_si128(
                                                          v26,
                                                          _mm_and_si128(
                                                            _mm_and_si128(
                                                              _mm_cmpgt_epi8(v26, (__m128i)xmmword_80BE5A0),
                                                              _mm_cmpgt_epi8(
                                                                _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                                v26)),
                                                            (__m128i)xmmword_80BE5C0))),
                                                      _mm_cmpeq_epi8((__m128i)0LL, v26))) >> v9;
                              v20 = (0xFFFFu >> v9) - v28;
                              v16 = 0xFFFFu >> v9 == v28;
                              v21 = v9 - 15;
                              if ( !v16 )
                                goto LABEL_181;
                              v29 = _mm_load_si128(v12);
                              v30 = 0LL;
                              v9 = 16;
                              v257 |= 1u;
                              v31 = (((_WORD)v12 + 1) & 0xFFF) - 4096;
                              while ( 1 )
                              {
                                v32 = (v31 + 16 < 0) ^ __OFADD__(16, v31) | (v31 == -16);
                                v31 += 16;
                                if ( !v32 )
                                  goto LABEL_36;
                                while ( 1 )
                                {
                                  v33 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                                  v34 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                                  v35 = _mm_alignr_epi8(v34, v29, 1);
                                  v36 = _mm_or_si128(
                                          v33,
                                          _mm_and_si128(
                                            _mm_and_si128(
                                              _mm_cmpgt_epi8(v33, (__m128i)xmmword_80BE5A0),
                                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v33)),
                                            (__m128i)xmmword_80BE5C0));
                                  v30 = _mm_cmpeq_epi8(v30, v36);
                                  v20 = _mm_movemask_epi8(
                                          _mm_sub_epi8(
                                            _mm_cmpeq_epi8(
                                              v36,
                                              _mm_or_si128(
                                                v35,
                                                _mm_and_si128(
                                                  _mm_and_si128(
                                                    _mm_cmpgt_epi8(v35, (__m128i)xmmword_80BE5A0),
                                                    _mm_cmpgt_epi8(
                                                      _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                      v35)),
                                                  (__m128i)xmmword_80BE5C0))),
                                            v30))
                                      - 0xFFFF;
                                  if ( v20 )
                                    goto LABEL_180;
                                  v9 += 16;
                                  v29 = v34;
                                  v32 = (v31 + 16 < 0) ^ __OFADD__(16, v31) | (v31 == -16);
                                  v31 += 16;
                                  if ( v32 )
                                    break;
LABEL_36:
                                  v41 = _mm_cmpeq_epi8(v30, v29);
                                  if ( (_mm_movemask_epi8(v41) & 0xFFFE) != 0 )
                                  {
                                    v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                                    v43 = _mm_srli_si128(v41, 1);
                                    v44 = _mm_srli_si128(v29, 1);
                                    goto LABEL_179;
                                  }
                                  v30 = 0LL;
                                  v31 -= 4096;
                                }
                                v37 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                                v38 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                                v39 = _mm_alignr_epi8(v38, v29, 1);
                                v40 = _mm_or_si128(
                                        v37,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v37, (__m128i)xmmword_80BE5A0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v37)),
                                          (__m128i)xmmword_80BE5C0));
                                v30 = _mm_cmpeq_epi8(v30, v40);
                                v20 = _mm_movemask_epi8(
                                        _mm_sub_epi8(
                                          _mm_cmpeq_epi8(
                                            v40,
                                            _mm_or_si128(
                                              v39,
                                              _mm_and_si128(
                                                _mm_and_si128(
                                                  _mm_cmpgt_epi8(v39, (__m128i)xmmword_80BE5A0),
                                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v39)),
                                                (__m128i)xmmword_80BE5C0))),
                                          v30))
                                    - 0xFFFF;
                                if ( v20 )
                                  goto LABEL_180;
                                v9 += 16;
                                v29 = v38;
                              }
                            }
                            v45 = _mm_load_si128(v11);
                            v46 = _mm_slli_si128(_mm_load_si128(v12), 14);
                            v47 = (unsigned int)_mm_movemask_epi8(
                                                  _mm_sub_epi8(
                                                    _mm_cmpeq_epi8(
                                                      _mm_or_si128(
                                                        v46,
                                                        _mm_and_si128(
                                                          _mm_and_si128(
                                                            _mm_cmpgt_epi8(v46, (__m128i)xmmword_80BE5A0),
                                                            _mm_cmpgt_epi8(
                                                              _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                              v46)),
                                                          (__m128i)xmmword_80BE5C0)),
                                                      _mm_or_si128(
                                                        v45,
                                                        _mm_and_si128(
                                                          _mm_and_si128(
                                                            _mm_cmpgt_epi8(v45, (__m128i)xmmword_80BE5A0),
                                                            _mm_cmpgt_epi8(
                                                              _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                              v45)),
                                                          (__m128i)xmmword_80BE5C0))),
                                                    _mm_cmpeq_epi8((__m128i)0LL, v45))) >> v9;
                            v20 = (0xFFFFu >> v9) - v47;
                            v16 = 0xFFFFu >> v9 == v47;
                            v21 = v9 - 14;
                            if ( !v16 )
                              goto LABEL_181;
                            v48 = _mm_load_si128(v12);
                            v49 = 0LL;
                            v9 = 16;
                            v257 |= 2u;
                            v50 = (((_WORD)v12 + 2) & 0xFFF) - 4096;
                            while ( 1 )
                            {
                              v32 = (v50 + 16 < 0) ^ __OFADD__(16, v50) | (v50 == -16);
                              v50 += 16;
                              if ( !v32 )
                                goto LABEL_46;
                              while ( 1 )
                              {
                                v51 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                                v52 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                                v53 = _mm_alignr_epi8(v52, v48, 2);
                                v54 = _mm_or_si128(
                                        v51,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v51, (__m128i)xmmword_80BE5A0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v51)),
                                          (__m128i)xmmword_80BE5C0));
                                v49 = _mm_cmpeq_epi8(v49, v54);
                                v20 = _mm_movemask_epi8(
                                        _mm_sub_epi8(
                                          _mm_cmpeq_epi8(
                                            v54,
                                            _mm_or_si128(
                                              v53,
                                              _mm_and_si128(
                                                _mm_and_si128(
                                                  _mm_cmpgt_epi8(v53, (__m128i)xmmword_80BE5A0),
                                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v53)),
                                                (__m128i)xmmword_80BE5C0))),
                                          v49))
                                    - 0xFFFF;
                                if ( v20 )
                                  goto LABEL_180;
                                v9 += 16;
                                v48 = v52;
                                v32 = (v50 + 16 < 0) ^ __OFADD__(16, v50) | (v50 == -16);
                                v50 += 16;
                                if ( v32 )
                                  break;
LABEL_46:
                                v59 = _mm_cmpeq_epi8(v49, v48);
                                if ( (_mm_movemask_epi8(v59) & 0xFFFC) != 0 )
                                {
                                  v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                                  v43 = _mm_srli_si128(v59, 2);
                                  v44 = _mm_srli_si128(v48, 2);
                                  goto LABEL_179;
                                }
                                v49 = 0LL;
                                v50 -= 4096;
                              }
                              v55 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                              v56 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                              v57 = _mm_alignr_epi8(v56, v48, 2);
                              v58 = _mm_or_si128(
                                      v55,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v55, (__m128i)xmmword_80BE5A0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v55)),
                                        (__m128i)xmmword_80BE5C0));
                              v49 = _mm_cmpeq_epi8(v49, v58);
                              v20 = _mm_movemask_epi8(
                                      _mm_sub_epi8(
                                        _mm_cmpeq_epi8(
                                          v58,
                                          _mm_or_si128(
                                            v57,
                                            _mm_and_si128(
                                              _mm_and_si128(
                                                _mm_cmpgt_epi8(v57, (__m128i)xmmword_80BE5A0),
                                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v57)),
                                              (__m128i)xmmword_80BE5C0))),
                                        v49))
                                  - 0xFFFF;
                              if ( v20 )
                                goto LABEL_180;
                              v9 += 16;
                              v48 = v56;
                            }
                          }
                          v60 = _mm_load_si128(v11);
                          v61 = _mm_slli_si128(_mm_load_si128(v12), 13);
                          v62 = (unsigned int)_mm_movemask_epi8(
                                                _mm_sub_epi8(
                                                  _mm_cmpeq_epi8(
                                                    _mm_or_si128(
                                                      v61,
                                                      _mm_and_si128(
                                                        _mm_and_si128(
                                                          _mm_cmpgt_epi8(v61, (__m128i)xmmword_80BE5A0),
                                                          _mm_cmpgt_epi8(
                                                            _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                            v61)),
                                                        (__m128i)xmmword_80BE5C0)),
                                                    _mm_or_si128(
                                                      v60,
                                                      _mm_and_si128(
                                                        _mm_and_si128(
                                                          _mm_cmpgt_epi8(v60, (__m128i)xmmword_80BE5A0),
                                                          _mm_cmpgt_epi8(
                                                            _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                            v60)),
                                                        (__m128i)xmmword_80BE5C0))),
                                                  _mm_cmpeq_epi8((__m128i)0LL, v60))) >> v9;
                          v20 = (0xFFFFu >> v9) - v62;
                          v16 = 0xFFFFu >> v9 == v62;
                          v21 = v9 - 13;
                          if ( !v16 )
                            goto LABEL_181;
                          v63 = _mm_load_si128(v12);
                          v64 = 0LL;
                          v9 = 16;
                          v257 |= 3u;
                          v65 = (((_WORD)v12 + 3) & 0xFFF) - 4096;
                          while ( 1 )
                          {
                            v32 = (v65 + 16 < 0) ^ __OFADD__(16, v65) | (v65 == -16);
                            v65 += 16;
                            if ( !v32 )
                              goto LABEL_56;
                            while ( 1 )
                            {
                              v66 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                              v67 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                              v68 = _mm_alignr_epi8(v67, v63, 3);
                              v69 = _mm_or_si128(
                                      v66,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v66, (__m128i)xmmword_80BE5A0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v66)),
                                        (__m128i)xmmword_80BE5C0));
                              v64 = _mm_cmpeq_epi8(v64, v69);
                              v20 = _mm_movemask_epi8(
                                      _mm_sub_epi8(
                                        _mm_cmpeq_epi8(
                                          v69,
                                          _mm_or_si128(
                                            v68,
                                            _mm_and_si128(
                                              _mm_and_si128(
                                                _mm_cmpgt_epi8(v68, (__m128i)xmmword_80BE5A0),
                                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v68)),
                                              (__m128i)xmmword_80BE5C0))),
                                        v64))
                                  - 0xFFFF;
                              if ( v20 )
                                goto LABEL_180;
                              v9 += 16;
                              v63 = v67;
                              v32 = (v65 + 16 < 0) ^ __OFADD__(16, v65) | (v65 == -16);
                              v65 += 16;
                              if ( v32 )
                                break;
LABEL_56:
                              v74 = _mm_cmpeq_epi8(v64, v63);
                              if ( (_mm_movemask_epi8(v74) & 0xFFF8) != 0 )
                              {
                                v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                                v43 = _mm_srli_si128(v74, 3);
                                v44 = _mm_srli_si128(v63, 3);
                                goto LABEL_179;
                              }
                              v64 = 0LL;
                              v65 -= 4096;
                            }
                            v70 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                            v71 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                            v72 = _mm_alignr_epi8(v71, v63, 3);
                            v73 = _mm_or_si128(
                                    v70,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v70, (__m128i)xmmword_80BE5A0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v70)),
                                      (__m128i)xmmword_80BE5C0));
                            v64 = _mm_cmpeq_epi8(v64, v73);
                            v20 = _mm_movemask_epi8(
                                    _mm_sub_epi8(
                                      _mm_cmpeq_epi8(
                                        v73,
                                        _mm_or_si128(
                                          v72,
                                          _mm_and_si128(
                                            _mm_and_si128(
                                              _mm_cmpgt_epi8(v72, (__m128i)xmmword_80BE5A0),
                                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v72)),
                                            (__m128i)xmmword_80BE5C0))),
                                      v64))
                                - 0xFFFF;
                            if ( v20 )
                              goto LABEL_180;
                            v9 += 16;
                            v63 = v71;
                          }
                        }
                        v75 = _mm_load_si128(v11);
                        v76 = _mm_slli_si128(_mm_load_si128(v12), 12);
                        v77 = (unsigned int)_mm_movemask_epi8(
                                              _mm_sub_epi8(
                                                _mm_cmpeq_epi8(
                                                  _mm_or_si128(
                                                    v76,
                                                    _mm_and_si128(
                                                      _mm_and_si128(
                                                        _mm_cmpgt_epi8(v76, (__m128i)xmmword_80BE5A0),
                                                        _mm_cmpgt_epi8(
                                                          _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                          v76)),
                                                      (__m128i)xmmword_80BE5C0)),
                                                  _mm_or_si128(
                                                    v75,
                                                    _mm_and_si128(
                                                      _mm_and_si128(
                                                        _mm_cmpgt_epi8(v75, (__m128i)xmmword_80BE5A0),
                                                        _mm_cmpgt_epi8(
                                                          _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                          v75)),
                                                      (__m128i)xmmword_80BE5C0))),
                                                _mm_cmpeq_epi8((__m128i)0LL, v75))) >> v9;
                        v20 = (0xFFFFu >> v9) - v77;
                        v16 = 0xFFFFu >> v9 == v77;
                        v21 = v9 - 12;
                        if ( !v16 )
                          goto LABEL_181;
                        v78 = _mm_load_si128(v12);
                        v79 = 0LL;
                        v9 = 16;
                        v257 |= 4u;
                        v80 = (((_WORD)v12 + 4) & 0xFFF) - 4096;
                        while ( 1 )
                        {
                          v32 = (v80 + 16 < 0) ^ __OFADD__(16, v80) | (v80 == -16);
                          v80 += 16;
                          if ( !v32 )
                            goto LABEL_66;
                          while ( 1 )
                          {
                            v81 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                            v82 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                            v83 = _mm_alignr_epi8(v82, v78, 4);
                            v84 = _mm_or_si128(
                                    v81,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v81, (__m128i)xmmword_80BE5A0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v81)),
                                      (__m128i)xmmword_80BE5C0));
                            v79 = _mm_cmpeq_epi8(v79, v84);
                            v20 = _mm_movemask_epi8(
                                    _mm_sub_epi8(
                                      _mm_cmpeq_epi8(
                                        v84,
                                        _mm_or_si128(
                                          v83,
                                          _mm_and_si128(
                                            _mm_and_si128(
                                              _mm_cmpgt_epi8(v83, (__m128i)xmmword_80BE5A0),
                                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v83)),
                                            (__m128i)xmmword_80BE5C0))),
                                      v79))
                                - 0xFFFF;
                            if ( v20 )
                              goto LABEL_180;
                            v9 += 16;
                            v78 = v82;
                            v32 = (v80 + 16 < 0) ^ __OFADD__(16, v80) | (v80 == -16);
                            v80 += 16;
                            if ( v32 )
                              break;
LABEL_66:
                            v89 = _mm_cmpeq_epi8(v79, v78);
                            if ( (_mm_movemask_epi8(v89) & 0xFFF0) != 0 )
                            {
                              v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                              v43 = _mm_srli_si128(v89, 4);
                              v44 = _mm_srli_si128(v78, 4);
                              goto LABEL_179;
                            }
                            v79 = 0LL;
                            v80 -= 4096;
                          }
                          v85 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                          v86 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                          v87 = _mm_alignr_epi8(v86, v78, 4);
                          v88 = _mm_or_si128(
                                  v85,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v85, (__m128i)xmmword_80BE5A0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v85)),
                                    (__m128i)xmmword_80BE5C0));
                          v79 = _mm_cmpeq_epi8(v79, v88);
                          v20 = _mm_movemask_epi8(
                                  _mm_sub_epi8(
                                    _mm_cmpeq_epi8(
                                      v88,
                                      _mm_or_si128(
                                        v87,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v87, (__m128i)xmmword_80BE5A0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v87)),
                                          (__m128i)xmmword_80BE5C0))),
                                    v79))
                              - 0xFFFF;
                          if ( v20 )
                            goto LABEL_180;
                          v9 += 16;
                          v78 = v86;
                        }
                      }
                      v90 = _mm_load_si128(v11);
                      v91 = _mm_slli_si128(_mm_load_si128(v12), 11);
                      v92 = (unsigned int)_mm_movemask_epi8(
                                            _mm_sub_epi8(
                                              _mm_cmpeq_epi8(
                                                _mm_or_si128(
                                                  v91,
                                                  _mm_and_si128(
                                                    _mm_and_si128(
                                                      _mm_cmpgt_epi8(v91, (__m128i)xmmword_80BE5A0),
                                                      _mm_cmpgt_epi8(
                                                        _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                        v91)),
                                                    (__m128i)xmmword_80BE5C0)),
                                                _mm_or_si128(
                                                  v90,
                                                  _mm_and_si128(
                                                    _mm_and_si128(
                                                      _mm_cmpgt_epi8(v90, (__m128i)xmmword_80BE5A0),
                                                      _mm_cmpgt_epi8(
                                                        _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                        v90)),
                                                    (__m128i)xmmword_80BE5C0))),
                                              _mm_cmpeq_epi8((__m128i)0LL, v90))) >> v9;
                      v20 = (0xFFFFu >> v9) - v92;
                      v16 = 0xFFFFu >> v9 == v92;
                      v21 = v9 - 11;
                      if ( !v16 )
                        goto LABEL_181;
                      v93 = _mm_load_si128(v12);
                      v94 = 0LL;
                      v9 = 16;
                      v257 |= 5u;
                      v95 = (((_WORD)v12 + 5) & 0xFFF) - 4096;
                      while ( 1 )
                      {
                        v32 = (v95 + 16 < 0) ^ __OFADD__(16, v95) | (v95 == -16);
                        v95 += 16;
                        if ( !v32 )
                          goto LABEL_76;
                        while ( 1 )
                        {
                          v96 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                          v97 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                          v98 = _mm_alignr_epi8(v97, v93, 5);
                          v99 = _mm_or_si128(
                                  v96,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v96, (__m128i)xmmword_80BE5A0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v96)),
                                    (__m128i)xmmword_80BE5C0));
                          v94 = _mm_cmpeq_epi8(v94, v99);
                          v20 = _mm_movemask_epi8(
                                  _mm_sub_epi8(
                                    _mm_cmpeq_epi8(
                                      v99,
                                      _mm_or_si128(
                                        v98,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v98, (__m128i)xmmword_80BE5A0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v98)),
                                          (__m128i)xmmword_80BE5C0))),
                                    v94))
                              - 0xFFFF;
                          if ( v20 )
                            goto LABEL_180;
                          v9 += 16;
                          v93 = v97;
                          v32 = (v95 + 16 < 0) ^ __OFADD__(16, v95) | (v95 == -16);
                          v95 += 16;
                          if ( v32 )
                            break;
LABEL_76:
                          v104 = _mm_cmpeq_epi8(v94, v93);
                          if ( (_mm_movemask_epi8(v104) & 0xFFE0) != 0 )
                          {
                            v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                            v43 = _mm_srli_si128(v104, 5);
                            v44 = _mm_srli_si128(v93, 5);
                            goto LABEL_179;
                          }
                          v94 = 0LL;
                          v95 -= 4096;
                        }
                        v100 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                        v101 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                        v102 = _mm_alignr_epi8(v101, v93, 5);
                        v103 = _mm_or_si128(
                                 v100,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v100, (__m128i)xmmword_80BE5A0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v100)),
                                   (__m128i)xmmword_80BE5C0));
                        v94 = _mm_cmpeq_epi8(v94, v103);
                        v20 = _mm_movemask_epi8(
                                _mm_sub_epi8(
                                  _mm_cmpeq_epi8(
                                    v103,
                                    _mm_or_si128(
                                      v102,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v102, (__m128i)xmmword_80BE5A0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v102)),
                                        (__m128i)xmmword_80BE5C0))),
                                  v94))
                            - 0xFFFF;
                        if ( v20 )
                          goto LABEL_180;
                        v9 += 16;
                        v93 = v101;
                      }
                    }
                    v105 = _mm_load_si128(v11);
                    v106 = _mm_slli_si128(_mm_load_si128(v12), 10);
                    v107 = (unsigned int)_mm_movemask_epi8(
                                           _mm_sub_epi8(
                                             _mm_cmpeq_epi8(
                                               _mm_or_si128(
                                                 v106,
                                                 _mm_and_si128(
                                                   _mm_and_si128(
                                                     _mm_cmpgt_epi8(v106, (__m128i)xmmword_80BE5A0),
                                                     _mm_cmpgt_epi8(
                                                       _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                       v106)),
                                                   (__m128i)xmmword_80BE5C0)),
                                               _mm_or_si128(
                                                 v105,
                                                 _mm_and_si128(
                                                   _mm_and_si128(
                                                     _mm_cmpgt_epi8(v105, (__m128i)xmmword_80BE5A0),
                                                     _mm_cmpgt_epi8(
                                                       _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                       v105)),
                                                   (__m128i)xmmword_80BE5C0))),
                                             _mm_cmpeq_epi8((__m128i)0LL, v105))) >> v9;
                    v20 = (0xFFFFu >> v9) - v107;
                    v16 = 0xFFFFu >> v9 == v107;
                    v21 = v9 - 10;
                    if ( !v16 )
                      goto LABEL_181;
                    v108 = _mm_load_si128(v12);
                    v109 = 0LL;
                    v9 = 16;
                    v257 |= 6u;
                    v110 = (((_WORD)v12 + 6) & 0xFFF) - 4096;
                    while ( 1 )
                    {
                      v32 = (v110 + 16 < 0) ^ __OFADD__(16, v110) | (v110 == -16);
                      v110 += 16;
                      if ( !v32 )
                        goto LABEL_86;
                      while ( 1 )
                      {
                        v111 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                        v112 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                        v113 = _mm_alignr_epi8(v112, v108, 6);
                        v114 = _mm_or_si128(
                                 v111,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v111, (__m128i)xmmword_80BE5A0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v111)),
                                   (__m128i)xmmword_80BE5C0));
                        v109 = _mm_cmpeq_epi8(v109, v114);
                        v20 = _mm_movemask_epi8(
                                _mm_sub_epi8(
                                  _mm_cmpeq_epi8(
                                    v114,
                                    _mm_or_si128(
                                      v113,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v113, (__m128i)xmmword_80BE5A0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v113)),
                                        (__m128i)xmmword_80BE5C0))),
                                  v109))
                            - 0xFFFF;
                        if ( v20 )
                          goto LABEL_180;
                        v9 += 16;
                        v108 = v112;
                        v32 = (v110 + 16 < 0) ^ __OFADD__(16, v110) | (v110 == -16);
                        v110 += 16;
                        if ( v32 )
                          break;
LABEL_86:
                        v119 = _mm_cmpeq_epi8(v109, v108);
                        if ( (_mm_movemask_epi8(v119) & 0xFFC0) != 0 )
                        {
                          v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                          v43 = _mm_srli_si128(v119, 6);
                          v44 = _mm_srli_si128(v108, 6);
                          goto LABEL_179;
                        }
                        v109 = 0LL;
                        v110 -= 4096;
                      }
                      v115 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                      v116 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                      v117 = _mm_alignr_epi8(v116, v108, 6);
                      v118 = _mm_or_si128(
                               v115,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v115, (__m128i)xmmword_80BE5A0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v115)),
                                 (__m128i)xmmword_80BE5C0));
                      v109 = _mm_cmpeq_epi8(v109, v118);
                      v20 = _mm_movemask_epi8(
                              _mm_sub_epi8(
                                _mm_cmpeq_epi8(
                                  v118,
                                  _mm_or_si128(
                                    v117,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v117, (__m128i)xmmword_80BE5A0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v117)),
                                      (__m128i)xmmword_80BE5C0))),
                                v109))
                          - 0xFFFF;
                      if ( v20 )
                        goto LABEL_180;
                      v9 += 16;
                      v108 = v116;
                    }
                  }
                  v120 = _mm_load_si128(v11);
                  v121 = _mm_slli_si128(_mm_load_si128(v12), 9);
                  v122 = (unsigned int)_mm_movemask_epi8(
                                         _mm_sub_epi8(
                                           _mm_cmpeq_epi8(
                                             _mm_or_si128(
                                               v121,
                                               _mm_and_si128(
                                                 _mm_and_si128(
                                                   _mm_cmpgt_epi8(v121, (__m128i)xmmword_80BE5A0),
                                                   _mm_cmpgt_epi8(
                                                     _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                     v121)),
                                                 (__m128i)xmmword_80BE5C0)),
                                             _mm_or_si128(
                                               v120,
                                               _mm_and_si128(
                                                 _mm_and_si128(
                                                   _mm_cmpgt_epi8(v120, (__m128i)xmmword_80BE5A0),
                                                   _mm_cmpgt_epi8(
                                                     _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                     v120)),
                                                 (__m128i)xmmword_80BE5C0))),
                                           _mm_cmpeq_epi8((__m128i)0LL, v120))) >> v9;
                  v20 = (0xFFFFu >> v9) - v122;
                  v16 = 0xFFFFu >> v9 == v122;
                  v21 = v9 - 9;
                  if ( !v16 )
                    goto LABEL_181;
                  v123 = _mm_load_si128(v12);
                  v124 = 0LL;
                  v9 = 16;
                  v257 |= 7u;
                  v125 = (((_WORD)v12 + 8) & 0xFFF) - 4096;
                  while ( 1 )
                  {
                    v32 = (v125 + 16 < 0) ^ __OFADD__(16, v125) | (v125 == -16);
                    v125 += 16;
                    if ( !v32 )
                      goto LABEL_96;
                    while ( 1 )
                    {
                      v126 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                      v127 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                      v128 = _mm_alignr_epi8(v127, v123, 7);
                      v129 = _mm_or_si128(
                               v126,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v126, (__m128i)xmmword_80BE5A0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v126)),
                                 (__m128i)xmmword_80BE5C0));
                      v124 = _mm_cmpeq_epi8(v124, v129);
                      v20 = _mm_movemask_epi8(
                              _mm_sub_epi8(
                                _mm_cmpeq_epi8(
                                  v129,
                                  _mm_or_si128(
                                    v128,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v128, (__m128i)xmmword_80BE5A0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v128)),
                                      (__m128i)xmmword_80BE5C0))),
                                v124))
                          - 0xFFFF;
                      if ( v20 )
                        goto LABEL_180;
                      v9 += 16;
                      v123 = v127;
                      v32 = (v125 + 16 < 0) ^ __OFADD__(16, v125) | (v125 == -16);
                      v125 += 16;
                      if ( v32 )
                        break;
LABEL_96:
                      v134 = _mm_cmpeq_epi8(v124, v123);
                      if ( (_mm_movemask_epi8(v134) & 0xFF80) != 0 )
                      {
                        v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                        v43 = _mm_srli_si128(v134, 7);
                        v44 = _mm_srli_si128(v123, 7);
                        goto LABEL_179;
                      }
                      v124 = 0LL;
                      v125 -= 4096;
                    }
                    v130 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                    v131 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                    v132 = _mm_alignr_epi8(v131, v123, 7);
                    v133 = _mm_or_si128(
                             v130,
                             _mm_and_si128(
                               _mm_and_si128(
                                 _mm_cmpgt_epi8(v130, (__m128i)xmmword_80BE5A0),
                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v130)),
                               (__m128i)xmmword_80BE5C0));
                    v124 = _mm_cmpeq_epi8(v124, v133);
                    v20 = _mm_movemask_epi8(
                            _mm_sub_epi8(
                              _mm_cmpeq_epi8(
                                v133,
                                _mm_or_si128(
                                  v132,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v132, (__m128i)xmmword_80BE5A0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v132)),
                                    (__m128i)xmmword_80BE5C0))),
                              v124))
                        - 0xFFFF;
                    if ( v20 )
                      goto LABEL_180;
                    v9 += 16;
                    v123 = v131;
                  }
                }
                v135 = _mm_load_si128(v11);
                v136 = _mm_slli_si128(_mm_load_si128(v12), 8);
                v137 = (unsigned int)_mm_movemask_epi8(
                                       _mm_sub_epi8(
                                         _mm_cmpeq_epi8(
                                           _mm_or_si128(
                                             v136,
                                             _mm_and_si128(
                                               _mm_and_si128(
                                                 _mm_cmpgt_epi8(v136, (__m128i)xmmword_80BE5A0),
                                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v136)),
                                               (__m128i)xmmword_80BE5C0)),
                                           _mm_or_si128(
                                             v135,
                                             _mm_and_si128(
                                               _mm_and_si128(
                                                 _mm_cmpgt_epi8(v135, (__m128i)xmmword_80BE5A0),
                                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v135)),
                                               (__m128i)xmmword_80BE5C0))),
                                         _mm_cmpeq_epi8((__m128i)0LL, v135))) >> v9;
                v20 = (0xFFFFu >> v9) - v137;
                v16 = 0xFFFFu >> v9 == v137;
                v21 = v9 - 8;
                if ( !v16 )
                  goto LABEL_181;
                v138 = _mm_load_si128(v12);
                v139 = 0LL;
                v9 = 16;
                v257 |= 8u;
                v140 = (((_WORD)v12 + 8) & 0xFFF) - 4096;
                while ( 1 )
                {
                  v32 = (v140 + 16 < 0) ^ __OFADD__(16, v140) | (v140 == -16);
                  v140 += 16;
                  if ( !v32 )
                    goto LABEL_106;
                  while ( 1 )
                  {
                    v141 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                    v142 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                    v143 = _mm_alignr_epi8(v142, v138, 8);
                    v144 = _mm_or_si128(
                             v141,
                             _mm_and_si128(
                               _mm_and_si128(
                                 _mm_cmpgt_epi8(v141, (__m128i)xmmword_80BE5A0),
                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v141)),
                               (__m128i)xmmword_80BE5C0));
                    v139 = _mm_cmpeq_epi8(v139, v144);
                    v20 = _mm_movemask_epi8(
                            _mm_sub_epi8(
                              _mm_cmpeq_epi8(
                                v144,
                                _mm_or_si128(
                                  v143,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v143, (__m128i)xmmword_80BE5A0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v143)),
                                    (__m128i)xmmword_80BE5C0))),
                              v139))
                        - 0xFFFF;
                    if ( v20 )
                      goto LABEL_180;
                    v9 += 16;
                    v138 = v142;
                    v32 = (v140 + 16 < 0) ^ __OFADD__(16, v140) | (v140 == -16);
                    v140 += 16;
                    if ( v32 )
                      break;
LABEL_106:
                    v149 = _mm_cmpeq_epi8(v139, v138);
                    if ( (_mm_movemask_epi8(v149) & 0xFF00) != 0 )
                    {
                      v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                      v43 = _mm_srli_si128(v149, 8);
                      v44 = _mm_srli_si128(v138, 8);
                      goto LABEL_179;
                    }
                    v139 = 0LL;
                    v140 -= 4096;
                  }
                  v145 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                  v146 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                  v147 = _mm_alignr_epi8(v146, v138, 8);
                  v148 = _mm_or_si128(
                           v145,
                           _mm_and_si128(
                             _mm_and_si128(
                               _mm_cmpgt_epi8(v145, (__m128i)xmmword_80BE5A0),
                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v145)),
                             (__m128i)xmmword_80BE5C0));
                  v139 = _mm_cmpeq_epi8(v139, v148);
                  v20 = _mm_movemask_epi8(
                          _mm_sub_epi8(
                            _mm_cmpeq_epi8(
                              v148,
                              _mm_or_si128(
                                v147,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(v147, (__m128i)xmmword_80BE5A0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v147)),
                                  (__m128i)xmmword_80BE5C0))),
                            v139))
                      - 0xFFFF;
                  if ( v20 )
                    goto LABEL_180;
                  v9 += 16;
                  v138 = v146;
                }
              }
              v150 = _mm_load_si128(v11);
              v151 = _mm_slli_si128(_mm_load_si128(v12), 7);
              v152 = (unsigned int)_mm_movemask_epi8(
                                     _mm_sub_epi8(
                                       _mm_cmpeq_epi8(
                                         _mm_or_si128(
                                           v151,
                                           _mm_and_si128(
                                             _mm_and_si128(
                                               _mm_cmpgt_epi8(v151, (__m128i)xmmword_80BE5A0),
                                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v151)),
                                             (__m128i)xmmword_80BE5C0)),
                                         _mm_or_si128(
                                           v150,
                                           _mm_and_si128(
                                             _mm_and_si128(
                                               _mm_cmpgt_epi8(v150, (__m128i)xmmword_80BE5A0),
                                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v150)),
                                             (__m128i)xmmword_80BE5C0))),
                                       _mm_cmpeq_epi8((__m128i)0LL, v150))) >> v9;
              v20 = (0xFFFFu >> v9) - v152;
              v16 = 0xFFFFu >> v9 == v152;
              v21 = v9 - 7;
              if ( !v16 )
                goto LABEL_181;
              v153 = _mm_load_si128(v12);
              v154 = 0LL;
              v9 = 16;
              v257 |= 9u;
              v155 = (((_WORD)v12 + 9) & 0xFFF) - 4096;
              while ( 1 )
              {
                v32 = (v155 + 16 < 0) ^ __OFADD__(16, v155) | (v155 == -16);
                v155 += 16;
                if ( !v32 )
                  goto LABEL_116;
                while ( 1 )
                {
                  v156 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                  v157 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                  v158 = _mm_alignr_epi8(v157, v153, 9);
                  v159 = _mm_or_si128(
                           v156,
                           _mm_and_si128(
                             _mm_and_si128(
                               _mm_cmpgt_epi8(v156, (__m128i)xmmword_80BE5A0),
                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v156)),
                             (__m128i)xmmword_80BE5C0));
                  v154 = _mm_cmpeq_epi8(v154, v159);
                  v20 = _mm_movemask_epi8(
                          _mm_sub_epi8(
                            _mm_cmpeq_epi8(
                              v159,
                              _mm_or_si128(
                                v158,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(v158, (__m128i)xmmword_80BE5A0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v158)),
                                  (__m128i)xmmword_80BE5C0))),
                            v154))
                      - 0xFFFF;
                  if ( v20 )
                    goto LABEL_180;
                  v9 += 16;
                  v153 = v157;
                  v32 = (v155 + 16 < 0) ^ __OFADD__(16, v155) | (v155 == -16);
                  v155 += 16;
                  if ( v32 )
                    break;
LABEL_116:
                  v164 = _mm_cmpeq_epi8(v154, v153);
                  if ( (_mm_movemask_epi8(v164) & 0xFE00) != 0 )
                  {
                    v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                    v43 = _mm_srli_si128(v164, 9);
                    v44 = _mm_srli_si128(v153, 9);
                    goto LABEL_179;
                  }
                  v154 = 0LL;
                  v155 -= 4096;
                }
                v160 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                v161 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                v162 = _mm_alignr_epi8(v161, v153, 9);
                v163 = _mm_or_si128(
                         v160,
                         _mm_and_si128(
                           _mm_and_si128(
                             _mm_cmpgt_epi8(v160, (__m128i)xmmword_80BE5A0),
                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v160)),
                           (__m128i)xmmword_80BE5C0));
                v154 = _mm_cmpeq_epi8(v154, v163);
                v20 = _mm_movemask_epi8(
                        _mm_sub_epi8(
                          _mm_cmpeq_epi8(
                            v163,
                            _mm_or_si128(
                              v162,
                              _mm_and_si128(
                                _mm_and_si128(
                                  _mm_cmpgt_epi8(v162, (__m128i)xmmword_80BE5A0),
                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v162)),
                                (__m128i)xmmword_80BE5C0))),
                          v154))
                    - 0xFFFF;
                if ( v20 )
                  goto LABEL_180;
                v9 += 16;
                v153 = v161;
              }
            }
            v165 = _mm_load_si128(v11);
            v166 = _mm_slli_si128(_mm_load_si128(v12), 6);
            v167 = (unsigned int)_mm_movemask_epi8(
                                   _mm_sub_epi8(
                                     _mm_cmpeq_epi8(
                                       _mm_or_si128(
                                         v166,
                                         _mm_and_si128(
                                           _mm_and_si128(
                                             _mm_cmpgt_epi8(v166, (__m128i)xmmword_80BE5A0),
                                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v166)),
                                           (__m128i)xmmword_80BE5C0)),
                                       _mm_or_si128(
                                         v165,
                                         _mm_and_si128(
                                           _mm_and_si128(
                                             _mm_cmpgt_epi8(v165, (__m128i)xmmword_80BE5A0),
                                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v165)),
                                           (__m128i)xmmword_80BE5C0))),
                                     _mm_cmpeq_epi8((__m128i)0LL, v165))) >> v9;
            v20 = (0xFFFFu >> v9) - v167;
            v16 = 0xFFFFu >> v9 == v167;
            v21 = v9 - 6;
            if ( !v16 )
              goto LABEL_181;
            v168 = _mm_load_si128(v12);
            v169 = 0LL;
            v9 = 16;
            v257 |= 0xAu;
            v170 = (((_WORD)v12 + 10) & 0xFFF) - 4096;
            while ( 1 )
            {
              v32 = (v170 + 16 < 0) ^ __OFADD__(16, v170) | (v170 == -16);
              v170 += 16;
              if ( !v32 )
                goto LABEL_126;
              while ( 1 )
              {
                v171 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                v172 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                v173 = _mm_alignr_epi8(v172, v168, 10);
                v174 = _mm_or_si128(
                         v171,
                         _mm_and_si128(
                           _mm_and_si128(
                             _mm_cmpgt_epi8(v171, (__m128i)xmmword_80BE5A0),
                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v171)),
                           (__m128i)xmmword_80BE5C0));
                v169 = _mm_cmpeq_epi8(v169, v174);
                v20 = _mm_movemask_epi8(
                        _mm_sub_epi8(
                          _mm_cmpeq_epi8(
                            v174,
                            _mm_or_si128(
                              v173,
                              _mm_and_si128(
                                _mm_and_si128(
                                  _mm_cmpgt_epi8(v173, (__m128i)xmmword_80BE5A0),
                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v173)),
                                (__m128i)xmmword_80BE5C0))),
                          v169))
                    - 0xFFFF;
                if ( v20 )
                  goto LABEL_180;
                v9 += 16;
                v168 = v172;
                v32 = (v170 + 16 < 0) ^ __OFADD__(16, v170) | (v170 == -16);
                v170 += 16;
                if ( v32 )
                  break;
LABEL_126:
                v179 = _mm_cmpeq_epi8(v169, v168);
                if ( (_mm_movemask_epi8(v179) & 0xFC00) != 0 )
                {
                  v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                  v43 = _mm_srli_si128(v179, 10);
                  v44 = _mm_srli_si128(v168, 10);
                  goto LABEL_179;
                }
                v169 = 0LL;
                v170 -= 4096;
              }
              v175 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
              v176 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
              v177 = _mm_alignr_epi8(v176, v168, 10);
              v178 = _mm_or_si128(
                       v175,
                       _mm_and_si128(
                         _mm_and_si128(
                           _mm_cmpgt_epi8(v175, (__m128i)xmmword_80BE5A0),
                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v175)),
                         (__m128i)xmmword_80BE5C0));
              v169 = _mm_cmpeq_epi8(v169, v178);
              v20 = _mm_movemask_epi8(
                      _mm_sub_epi8(
                        _mm_cmpeq_epi8(
                          v178,
                          _mm_or_si128(
                            v177,
                            _mm_and_si128(
                              _mm_and_si128(
                                _mm_cmpgt_epi8(v177, (__m128i)xmmword_80BE5A0),
                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v177)),
                              (__m128i)xmmword_80BE5C0))),
                        v169))
                  - 0xFFFF;
              if ( v20 )
                goto LABEL_180;
              v9 += 16;
              v168 = v176;
            }
          }
          v180 = _mm_load_si128(v11);
          v181 = _mm_slli_si128(_mm_load_si128(v12), 5);
          v182 = (unsigned int)_mm_movemask_epi8(
                                 _mm_sub_epi8(
                                   _mm_cmpeq_epi8(
                                     _mm_or_si128(
                                       v181,
                                       _mm_and_si128(
                                         _mm_and_si128(
                                           _mm_cmpgt_epi8(v181, (__m128i)xmmword_80BE5A0),
                                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v181)),
                                         (__m128i)xmmword_80BE5C0)),
                                     _mm_or_si128(
                                       v180,
                                       _mm_and_si128(
                                         _mm_and_si128(
                                           _mm_cmpgt_epi8(v180, (__m128i)xmmword_80BE5A0),
                                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v180)),
                                         (__m128i)xmmword_80BE5C0))),
                                   _mm_cmpeq_epi8((__m128i)0LL, v180))) >> v9;
          v20 = (0xFFFFu >> v9) - v182;
          v16 = 0xFFFFu >> v9 == v182;
          v21 = v9 - 5;
          if ( !v16 )
            goto LABEL_181;
          v183 = _mm_load_si128(v12);
          v184 = 0LL;
          v9 = 16;
          v257 |= 0xBu;
          v185 = (((_WORD)v12 + 11) & 0xFFF) - 4096;
          while ( 1 )
          {
            v32 = (v185 + 16 < 0) ^ __OFADD__(16, v185) | (v185 == -16);
            v185 += 16;
            if ( !v32 )
              goto LABEL_136;
            while ( 1 )
            {
              v186 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
              v187 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
              v188 = _mm_alignr_epi8(v187, v183, 11);
              v189 = _mm_or_si128(
                       v186,
                       _mm_and_si128(
                         _mm_and_si128(
                           _mm_cmpgt_epi8(v186, (__m128i)xmmword_80BE5A0),
                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v186)),
                         (__m128i)xmmword_80BE5C0));
              v184 = _mm_cmpeq_epi8(v184, v189);
              v20 = _mm_movemask_epi8(
                      _mm_sub_epi8(
                        _mm_cmpeq_epi8(
                          v189,
                          _mm_or_si128(
                            v188,
                            _mm_and_si128(
                              _mm_and_si128(
                                _mm_cmpgt_epi8(v188, (__m128i)xmmword_80BE5A0),
                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v188)),
                              (__m128i)xmmword_80BE5C0))),
                        v184))
                  - 0xFFFF;
              if ( v20 )
                goto LABEL_180;
              v9 += 16;
              v183 = v187;
              v32 = (v185 + 16 < 0) ^ __OFADD__(16, v185) | (v185 == -16);
              v185 += 16;
              if ( v32 )
                break;
LABEL_136:
              v194 = _mm_cmpeq_epi8(v184, v183);
              if ( (_mm_movemask_epi8(v194) & 0xF800) != 0 )
              {
                v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                v43 = _mm_srli_si128(v194, 11);
                v44 = _mm_srli_si128(v183, 11);
                goto LABEL_179;
              }
              v184 = 0LL;
              v185 -= 4096;
            }
            v190 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
            v191 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
            v192 = _mm_alignr_epi8(v191, v183, 11);
            v193 = _mm_or_si128(
                     v190,
                     _mm_and_si128(
                       _mm_and_si128(
                         _mm_cmpgt_epi8(v190, (__m128i)xmmword_80BE5A0),
                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v190)),
                       (__m128i)xmmword_80BE5C0));
            v184 = _mm_cmpeq_epi8(v184, v193);
            v20 = _mm_movemask_epi8(
                    _mm_sub_epi8(
                      _mm_cmpeq_epi8(
                        v193,
                        _mm_or_si128(
                          v192,
                          _mm_and_si128(
                            _mm_and_si128(
                              _mm_cmpgt_epi8(v192, (__m128i)xmmword_80BE5A0),
                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v192)),
                            (__m128i)xmmword_80BE5C0))),
                      v184))
                - 0xFFFF;
            if ( v20 )
              goto LABEL_180;
            v9 += 16;
            v183 = v191;
          }
        }
        v195 = _mm_load_si128(v11);
        v196 = _mm_slli_si128(_mm_load_si128(v12), 4);
        v197 = (unsigned int)_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(
                                   _mm_or_si128(
                                     v196,
                                     _mm_and_si128(
                                       _mm_and_si128(
                                         _mm_cmpgt_epi8(v196, (__m128i)xmmword_80BE5A0),
                                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v196)),
                                       (__m128i)xmmword_80BE5C0)),
                                   _mm_or_si128(
                                     v195,
                                     _mm_and_si128(
                                       _mm_and_si128(
                                         _mm_cmpgt_epi8(v195, (__m128i)xmmword_80BE5A0),
                                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v195)),
                                       (__m128i)xmmword_80BE5C0))),
                                 _mm_cmpeq_epi8((__m128i)0LL, v195))) >> v9;
        v20 = (0xFFFFu >> v9) - v197;
        v16 = 0xFFFFu >> v9 == v197;
        v21 = v9 - 4;
        if ( !v16 )
          goto LABEL_181;
        v198 = _mm_load_si128(v12);
        v199 = 0LL;
        v9 = 16;
        v257 |= 0xCu;
        v200 = (((_WORD)v12 + 12) & 0xFFF) - 4096;
        while ( 1 )
        {
          v32 = (v200 + 16 < 0) ^ __OFADD__(16, v200) | (v200 == -16);
          v200 += 16;
          if ( !v32 )
            goto LABEL_146;
          while ( 1 )
          {
            v201 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
            v202 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
            v203 = _mm_alignr_epi8(v202, v198, 12);
            v204 = _mm_or_si128(
                     v201,
                     _mm_and_si128(
                       _mm_and_si128(
                         _mm_cmpgt_epi8(v201, (__m128i)xmmword_80BE5A0),
                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v201)),
                       (__m128i)xmmword_80BE5C0));
            v199 = _mm_cmpeq_epi8(v199, v204);
            v20 = _mm_movemask_epi8(
                    _mm_sub_epi8(
                      _mm_cmpeq_epi8(
                        v204,
                        _mm_or_si128(
                          v203,
                          _mm_and_si128(
                            _mm_and_si128(
                              _mm_cmpgt_epi8(v203, (__m128i)xmmword_80BE5A0),
                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v203)),
                            (__m128i)xmmword_80BE5C0))),
                      v199))
                - 0xFFFF;
            if ( v20 )
              goto LABEL_180;
            v9 += 16;
            v198 = v202;
            v32 = (v200 + 16 < 0) ^ __OFADD__(16, v200) | (v200 == -16);
            v200 += 16;
            if ( v32 )
              break;
LABEL_146:
            v209 = _mm_cmpeq_epi8(v199, v198);
            if ( (_mm_movemask_epi8(v209) & 0xF000) != 0 )
            {
              v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
              v43 = _mm_srli_si128(v209, 12);
              v44 = _mm_srli_si128(v198, 12);
              goto LABEL_179;
            }
            v199 = 0LL;
            v200 -= 4096;
          }
          v205 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
          v206 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
          v207 = _mm_alignr_epi8(v206, v198, 12);
          v208 = _mm_or_si128(
                   v205,
                   _mm_and_si128(
                     _mm_and_si128(
                       _mm_cmpgt_epi8(v205, (__m128i)xmmword_80BE5A0),
                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v205)),
                     (__m128i)xmmword_80BE5C0));
          v199 = _mm_cmpeq_epi8(v199, v208);
          v20 = _mm_movemask_epi8(
                  _mm_sub_epi8(
                    _mm_cmpeq_epi8(
                      v208,
                      _mm_or_si128(
                        v207,
                        _mm_and_si128(
                          _mm_and_si128(
                            _mm_cmpgt_epi8(v207, (__m128i)xmmword_80BE5A0),
                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v207)),
                          (__m128i)xmmword_80BE5C0))),
                    v199))
              - 0xFFFF;
          if ( v20 )
            goto LABEL_180;
          v9 += 16;
          v198 = v206;
        }
      }
      v210 = _mm_load_si128(v11);
      v211 = _mm_slli_si128(_mm_load_si128(v12), 3);
      v212 = (unsigned int)_mm_movemask_epi8(
                             _mm_sub_epi8(
                               _mm_cmpeq_epi8(
                                 _mm_or_si128(
                                   v211,
                                   _mm_and_si128(
                                     _mm_and_si128(
                                       _mm_cmpgt_epi8(v211, (__m128i)xmmword_80BE5A0),
                                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v211)),
                                     (__m128i)xmmword_80BE5C0)),
                                 _mm_or_si128(
                                   v210,
                                   _mm_and_si128(
                                     _mm_and_si128(
                                       _mm_cmpgt_epi8(v210, (__m128i)xmmword_80BE5A0),
                                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v210)),
                                     (__m128i)xmmword_80BE5C0))),
                               _mm_cmpeq_epi8((__m128i)0LL, v210))) >> v9;
      v20 = (0xFFFFu >> v9) - v212;
      v16 = 0xFFFFu >> v9 == v212;
      v21 = v9 - 3;
      if ( !v16 )
        goto LABEL_181;
      v213 = _mm_load_si128(v12);
      v214 = 0LL;
      v9 = 16;
      v257 |= 0xDu;
      v215 = (((_WORD)v12 + 13) & 0xFFF) - 4096;
      while ( 1 )
      {
        v32 = (v215 + 16 < 0) ^ __OFADD__(16, v215) | (v215 == -16);
        v215 += 16;
        if ( !v32 )
          goto LABEL_156;
        while ( 1 )
        {
          v216 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
          v217 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
          v218 = _mm_alignr_epi8(v217, v213, 13);
          v219 = _mm_or_si128(
                   v216,
                   _mm_and_si128(
                     _mm_and_si128(
                       _mm_cmpgt_epi8(v216, (__m128i)xmmword_80BE5A0),
                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v216)),
                     (__m128i)xmmword_80BE5C0));
          v214 = _mm_cmpeq_epi8(v214, v219);
          v20 = _mm_movemask_epi8(
                  _mm_sub_epi8(
                    _mm_cmpeq_epi8(
                      v219,
                      _mm_or_si128(
                        v218,
                        _mm_and_si128(
                          _mm_and_si128(
                            _mm_cmpgt_epi8(v218, (__m128i)xmmword_80BE5A0),
                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v218)),
                          (__m128i)xmmword_80BE5C0))),
                    v214))
              - 0xFFFF;
          if ( v20 )
            goto LABEL_180;
          v9 += 16;
          v213 = v217;
          v32 = (v215 + 16 < 0) ^ __OFADD__(16, v215) | (v215 == -16);
          v215 += 16;
          if ( v32 )
            break;
LABEL_156:
          v224 = _mm_cmpeq_epi8(v214, v213);
          if ( (_mm_movemask_epi8(v224) & 0xE000) != 0 )
          {
            v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
            v43 = _mm_srli_si128(v224, 13);
            v44 = _mm_srli_si128(v213, 13);
            goto LABEL_179;
          }
          v214 = 0LL;
          v215 -= 4096;
        }
        v220 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
        v221 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
        v222 = _mm_alignr_epi8(v221, v213, 13);
        v223 = _mm_or_si128(
                 v220,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v220, (__m128i)xmmword_80BE5A0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v220)),
                   (__m128i)xmmword_80BE5C0));
        v214 = _mm_cmpeq_epi8(v214, v223);
        v20 = _mm_movemask_epi8(
                _mm_sub_epi8(
                  _mm_cmpeq_epi8(
                    v223,
                    _mm_or_si128(
                      v222,
                      _mm_and_si128(
                        _mm_and_si128(
                          _mm_cmpgt_epi8(v222, (__m128i)xmmword_80BE5A0),
                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v222)),
                        (__m128i)xmmword_80BE5C0))),
                  v214))
            - 0xFFFF;
        if ( v20 )
          goto LABEL_180;
        v9 += 16;
        v213 = v221;
      }
    }
    v225 = _mm_load_si128(v11);
    v226 = _mm_slli_si128(_mm_load_si128(v12), 2);
    v227 = (unsigned int)_mm_movemask_epi8(
                           _mm_sub_epi8(
                             _mm_cmpeq_epi8(
                               _mm_or_si128(
                                 v226,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v226, (__m128i)xmmword_80BE5A0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v226)),
                                   (__m128i)xmmword_80BE5C0)),
                               _mm_or_si128(
                                 v225,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v225, (__m128i)xmmword_80BE5A0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v225)),
                                   (__m128i)xmmword_80BE5C0))),
                             _mm_cmpeq_epi8((__m128i)0LL, v225))) >> v9;
    v20 = (0xFFFFu >> v9) - v227;
    v16 = 0xFFFFu >> v9 == v227;
    v21 = v9 - 2;
    if ( !v16 )
      goto LABEL_181;
    v228 = _mm_load_si128(v12);
    v229 = 0LL;
    v9 = 16;
    v257 |= 0xEu;
    v230 = (((_WORD)v12 + 14) & 0xFFF) - 4096;
    while ( 1 )
    {
      v32 = (v230 + 16 < 0) ^ __OFADD__(16, v230) | (v230 == -16);
      v230 += 16;
      if ( !v32 )
        goto LABEL_166;
      while ( 1 )
      {
        v231 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
        v232 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
        v233 = _mm_alignr_epi8(v232, v228, 14);
        v234 = _mm_or_si128(
                 v231,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v231, (__m128i)xmmword_80BE5A0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v231)),
                   (__m128i)xmmword_80BE5C0));
        v229 = _mm_cmpeq_epi8(v229, v234);
        v20 = _mm_movemask_epi8(
                _mm_sub_epi8(
                  _mm_cmpeq_epi8(
                    v234,
                    _mm_or_si128(
                      v233,
                      _mm_and_si128(
                        _mm_and_si128(
                          _mm_cmpgt_epi8(v233, (__m128i)xmmword_80BE5A0),
                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v233)),
                        (__m128i)xmmword_80BE5C0))),
                  v229))
            - 0xFFFF;
        if ( v20 )
          goto LABEL_180;
        v9 += 16;
        v228 = v232;
        v32 = (v230 + 16 < 0) ^ __OFADD__(16, v230) | (v230 == -16);
        v230 += 16;
        if ( v32 )
          break;
LABEL_166:
        v239 = _mm_cmpeq_epi8(v229, v228);
        if ( (_mm_movemask_epi8(v239) & 0xC000) != 0 )
        {
          v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
          v43 = _mm_srli_si128(v239, 14);
          v44 = _mm_srli_si128(v228, 14);
          goto LABEL_179;
        }
        v229 = 0LL;
        v230 -= 4096;
      }
      v235 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
      v236 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
      v237 = _mm_alignr_epi8(v236, v228, 14);
      v238 = _mm_or_si128(
               v235,
               _mm_and_si128(
                 _mm_and_si128(
                   _mm_cmpgt_epi8(v235, (__m128i)xmmword_80BE5A0),
                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v235)),
                 (__m128i)xmmword_80BE5C0));
      v229 = _mm_cmpeq_epi8(v229, v238);
      v20 = _mm_movemask_epi8(
              _mm_sub_epi8(
                _mm_cmpeq_epi8(
                  v238,
                  _mm_or_si128(
                    v237,
                    _mm_and_si128(
                      _mm_and_si128(
                        _mm_cmpgt_epi8(v237, (__m128i)xmmword_80BE5A0),
                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v237)),
                      (__m128i)xmmword_80BE5C0))),
                v229))
          - 0xFFFF;
      if ( v20 )
        goto LABEL_180;
      v9 += 16;
      v228 = v236;
    }
  }
  v240 = _mm_load_si128(v11);
  v241 = _mm_slli_si128(_mm_load_si128(v12), 1);
  v242 = (unsigned int)_mm_movemask_epi8(
                         _mm_sub_epi8(
                           _mm_cmpeq_epi8(
                             _mm_or_si128(
                               v241,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v241, (__m128i)xmmword_80BE5A0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v241)),
                                 (__m128i)xmmword_80BE5C0)),
                             _mm_or_si128(
                               v240,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v240, (__m128i)xmmword_80BE5A0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v240)),
                                 (__m128i)xmmword_80BE5C0))),
                           _mm_cmpeq_epi8((__m128i)0LL, v240))) >> v9;
  v20 = (0xFFFFu >> v9) - v242;
  v16 = 0xFFFFu >> v9 == v242;
  v21 = v9 - 1;
  if ( !v16 )
    goto LABEL_181;
  v243 = _mm_load_si128(v12);
  v244 = 0LL;
  v9 = 16;
  v257 |= 0xFu;
  v245 = (((_WORD)v12 + 15) & 0xFFF) - 4096;
LABEL_171:
  v32 = (v245 + 16 < 0) ^ __OFADD__(16, v245) | (v245 == -16);
  v245 += 16;
  if ( !v32 )
    goto LABEL_176;
  while ( 1 )
  {
    v246 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
    v247 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
    v248 = _mm_alignr_epi8(v247, v243, 15);
    v249 = _mm_or_si128(
             v246,
             _mm_and_si128(
               _mm_and_si128(
                 _mm_cmpgt_epi8(v246, (__m128i)xmmword_80BE5A0),
                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v246)),
               (__m128i)xmmword_80BE5C0));
    v244 = _mm_cmpeq_epi8(v244, v249);
    v20 = _mm_movemask_epi8(
            _mm_sub_epi8(
              _mm_cmpeq_epi8(
                v249,
                _mm_or_si128(
                  v248,
                  _mm_and_si128(
                    _mm_and_si128(
                      _mm_cmpgt_epi8(v248, (__m128i)xmmword_80BE5A0),
                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v248)),
                    (__m128i)xmmword_80BE5C0))),
              v244))
        - 0xFFFF;
    if ( v20 )
      goto LABEL_180;
    v9 += 16;
    v243 = v247;
    v32 = (v245 + 16 < 0) ^ __OFADD__(16, v245) | (v245 == -16);
    v245 += 16;
    if ( v32 )
    {
      v250 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
      v251 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
      v252 = _mm_alignr_epi8(v251, v243, 15);
      v253 = _mm_or_si128(
               v250,
               _mm_and_si128(
                 _mm_and_si128(
                   _mm_cmpgt_epi8(v250, (__m128i)xmmword_80BE5A0),
                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v250)),
                 (__m128i)xmmword_80BE5C0));
      v244 = _mm_cmpeq_epi8(v244, v253);
      v20 = _mm_movemask_epi8(
              _mm_sub_epi8(
                _mm_cmpeq_epi8(
                  v253,
                  _mm_or_si128(
                    v252,
                    _mm_and_si128(
                      _mm_and_si128(
                        _mm_cmpgt_epi8(v252, (__m128i)xmmword_80BE5A0),
                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v252)),
                      (__m128i)xmmword_80BE5C0))),
                v244))
          - 0xFFFF;
      if ( v20 )
        goto LABEL_180;
      v9 += 16;
      v243 = v251;
      goto LABEL_171;
    }
LABEL_176:
    v254 = _mm_cmpeq_epi8(v244, v243);
    if ( (_mm_movemask_epi8(v254) & 0x8000) != 0 )
      break;
    v244 = 0LL;
    v245 -= 4096;
  }
  v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
  v43 = _mm_srli_si128(v254, 15);
  v44 = _mm_srli_si128(v243, 15);
LABEL_179:
  v20 = ~_mm_movemask_epi8(
           _mm_sub_epi8(
             _mm_cmpeq_epi8(
               _mm_or_si128(
                 v42,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v42, (__m128i)xmmword_80BE5A0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v42)),
                   (__m128i)xmmword_80BE5C0)),
               _mm_or_si128(
                 v44,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v44, (__m128i)xmmword_80BE5A0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v44)),
                   (__m128i)xmmword_80BE5C0))),
             v43));
LABEL_180:
  v21 = (v257 & 0x1F) + v9 - 16;
LABEL_181:
  v3 = &v12->m128i_u8[v21];
  v4 = &v11->m128i_u8[v9];
  if ( (v257 & 0x20) != 0 )
  {
    v255 = v4;
    v4 = v3;
    v3 = v255;
  }
  LOWORD(v8) = v20;
LABEL_184:
  if ( (_BYTE)v8 )
  {
    if ( (v8 & 1) == 0 )
    {
      if ( (v8 & 2) == 0 )
      {
        if ( (v8 & 4) == 0 )
        {
          if ( (v8 & 8) == 0 )
          {
            if ( (v8 & 0x10) == 0 )
            {
              if ( (v8 & 0x20) == 0 )
              {
                if ( (v8 & 0x40) == 0 )
                  return dword_80C1540[v3[7]] - dword_80C1540[v4[7]];
                return dword_80C1540[v3[6]] - dword_80C1540[v4[6]];
              }
              return dword_80C1540[v3[5]] - dword_80C1540[v4[5]];
            }
            return dword_80C1540[v3[4]] - dword_80C1540[v4[4]];
          }
          return dword_80C1540[v3[3]] - dword_80C1540[v4[3]];
        }
        return dword_80C1540[v3[2]] - dword_80C1540[v4[2]];
      }
      return dword_80C1540[v3[1]] - dword_80C1540[v4[1]];
    }
    return dword_80C1540[*v3] - dword_80C1540[*v4];
  }
  v4 += 8;
  v3 += 8;
  if ( (v8 & 0x100) != 0 )
    return dword_80C1540[*v3] - dword_80C1540[*v4];
  if ( (v8 & 0x200) != 0 )
    return dword_80C1540[v3[1]] - dword_80C1540[v4[1]];
  if ( (v8 & 0x400) != 0 )
    return dword_80C1540[v3[2]] - dword_80C1540[v4[2]];
  if ( (v8 & 0x800) != 0 )
    return dword_80C1540[v3[3]] - dword_80C1540[v4[3]];
  if ( (v8 & 0x1000) != 0 )
    return dword_80C1540[v3[4]] - dword_80C1540[v4[4]];
  if ( (v8 & 0x2000) != 0 )
    return dword_80C1540[v3[5]] - dword_80C1540[v4[5]];
  if ( (v8 & 0x4000) != 0 )
    return dword_80C1540[v3[6]] - dword_80C1540[v4[6]];
  return dword_80C1540[v3[7]] - dword_80C1540[v4[7]];
}
// 80BE5A0: using guessed type __int128 xmmword_80BE5A0;
// 80BE5B0: using guessed type __int128 xmmword_80BE5B0;
// 80BE5C0: using guessed type __int128 xmmword_80BE5C0;
// 80C1540: using guessed type int dword_80C1540[256];

//----- (0806C0B0) --------------------------------------------------------
int __cdecl _strcasecmp_sse4_2(char *a1, unsigned __int8 *a2)
{
  if ( (*(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFDC) + 320) & 1) == 0 )
    JUMPOUT(0x806C0E6);
  return _strcasecmp_nonascii(a1, a2);
}
// 806C0C8: control flows out of bounds to 806C0E6

//----- (0806C0D0) --------------------------------------------------------
int __cdecl _strcasecmp_l_sse4_2(char *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // edx
  unsigned __int8 *v4; // eax
  __m128i v5; // xmm2
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm1
  int v9; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // edi
  char v12; // cc
  unsigned int v13; // ecx
  unsigned int v14; // edi
  unsigned int v15; // ecx
  unsigned int v16; // edi
  unsigned int v17; // ecx
  unsigned int v18; // edi
  unsigned int v19; // ecx
  unsigned int v20; // edi
  unsigned int v21; // ecx
  unsigned int v22; // edi
  unsigned int v23; // ecx
  unsigned int v24; // edi
  unsigned int v25; // ecx
  unsigned int v26; // edi
  unsigned __int8 *v27; // edi
  unsigned __int8 *v28; // esi
  int result; // eax
  int v30; // ecx
  int v31; // edx
  unsigned __int8 *v32; // edi
  unsigned __int8 *v33; // esi
  __m128i v34; // xmm2
  __m128i v35; // xmm1
  __m128i v36; // xmm2
  __m128i v37; // xmm1
  bool v38; // cf
  int v39; // ecx
  int v40; // ecx
  int v41; // ecx
  int v42; // ecx
  int v43; // edi
  int v44; // ecx
  unsigned int v45; // ecx
  unsigned int v46; // edi
  unsigned int v47; // ecx
  unsigned int v48; // edi
  unsigned int v49; // ecx
  unsigned int v50; // edi
  unsigned int v51; // ecx
  unsigned int v52; // edi
  unsigned int v53; // ecx
  unsigned int v54; // edi
  unsigned int v55; // ecx
  unsigned int v56; // edi
  unsigned int v57; // ecx
  unsigned int v58; // edi
  unsigned int v59; // ecx
  unsigned int v60; // edi

  if ( (*(_DWORD *)(*(_DWORD *)a3 + 320) & 1) != 0 )
    return _strcasecmp_nonascii(a1, a2);
  v3 = (unsigned __int8 *)a1;
  v4 = a2;
  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFF0 )
  {
    v5 = _mm_loadu_si128((const __m128i *)a1);
    if ( ((unsigned __int16)a2 & 0xFFFu) <= 0xFF0 )
    {
      v6 = _mm_loadu_si128((const __m128i *)a2);
      v7 = _mm_or_si128(
             v5,
             _mm_and_si128(
               _mm_and_si128(
                 _mm_cmpgt_epi8(v5, (__m128i)xmmword_80BE5A0),
                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v5)),
               (__m128i)xmmword_80BE5C0));
      v8 = _mm_or_si128(
             v6,
             _mm_and_si128(
               _mm_and_si128(
                 _mm_cmpgt_epi8(v6, (__m128i)xmmword_80BE5A0),
                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v6)),
               (__m128i)xmmword_80BE5C0));
      v9 = _mm_cvtsi128_si32(v7);
      if ( v9 == _mm_cvtsi128_si32(v8) )
      {
        if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(v8, v7))
          && _mm_testc_si128((__m128i)0LL, _mm_cmpeq_epi8(v7, (__m128i)0LL)) )
        {
          v3 = (unsigned __int8 *)(a1 + 16);
          v4 = a2 + 16;
          goto LABEL_8;
        }
        v38 = __CFADD__(v9, -16843009);
        v41 = v9 - 16843009;
        if ( v38 && (_mm_cvtsi128_si32(v7) ^ v41 | 0xFEFEFEFF) == -1 )
        {
          v42 = _mm_cvtsi128_si32(_mm_srli_si128(v7, 4));
          v43 = v42;
          if ( v42 != _mm_cvtsi128_si32(_mm_srli_si128(v8, 4)) )
            goto LABEL_55;
          v38 = __CFADD__(v42, -16843009);
          v44 = v42 - 16843009;
          if ( !v38 || (v43 ^ v44 | 0xFEFEFEFF) != -1 )
            goto LABEL_55;
          v3 = (unsigned __int8 *)(a1 + 8);
          v4 = a2 + 8;
        }
      }
      v45 = dword_80C1540[*v4];
      v46 = dword_80C1540[*v3];
      v12 = v46 <= v45;
      if ( v46 != v45 )
        goto LABEL_38;
      if ( !v45 )
        return 0;
      v47 = dword_80C1540[v4[1]];
      v48 = dword_80C1540[v3[1]];
      v12 = v48 <= v47;
      if ( v48 != v47 )
        goto LABEL_38;
      if ( !v47 )
        return 0;
      v49 = dword_80C1540[v4[2]];
      v50 = dword_80C1540[v3[2]];
      v12 = v50 <= v49;
      if ( v50 != v49 )
        goto LABEL_38;
      if ( !v49 )
        return 0;
      v51 = dword_80C1540[v4[3]];
      v52 = dword_80C1540[v3[3]];
      v12 = v52 <= v51;
      if ( v52 != v51 )
        goto LABEL_38;
      if ( !v51 )
        return 0;
LABEL_55:
      v53 = dword_80C1540[v4[4]];
      v54 = dword_80C1540[v3[4]];
      v12 = v54 <= v53;
      if ( v54 == v53 )
      {
        if ( !v53 )
          return 0;
        v55 = dword_80C1540[v4[5]];
        v56 = dword_80C1540[v3[5]];
        v12 = v56 <= v55;
        if ( v56 == v55 )
        {
          if ( !v55 )
            return 0;
          v57 = dword_80C1540[v4[6]];
          v58 = dword_80C1540[v3[6]];
          v12 = v58 <= v57;
          if ( v58 == v57 )
          {
            if ( !v57 )
              return 0;
            v59 = dword_80C1540[v4[7]];
            v60 = dword_80C1540[v3[7]];
            v12 = v60 <= v59;
            if ( v60 == v59 )
              return 0;
          }
        }
      }
      goto LABEL_38;
    }
  }
LABEL_8:
  v10 = dword_80C1540[*v4];
  v11 = dword_80C1540[*v3];
  v12 = v11 <= v10;
  if ( v11 != v10 )
    goto LABEL_38;
  if ( !v10 )
    return 0;
  v13 = dword_80C1540[v4[1]];
  v14 = dword_80C1540[v3[1]];
  v12 = v14 <= v13;
  if ( v14 != v13 )
    goto LABEL_38;
  if ( !v13 )
    return 0;
  v15 = dword_80C1540[v4[2]];
  v16 = dword_80C1540[v3[2]];
  v12 = v16 <= v15;
  if ( v16 != v15 )
    goto LABEL_38;
  if ( !v15 )
    return 0;
  v17 = dword_80C1540[v4[3]];
  v18 = dword_80C1540[v3[3]];
  v12 = v18 <= v17;
  if ( v18 != v17 )
    goto LABEL_38;
  if ( !v17 )
    return 0;
  v19 = dword_80C1540[v4[4]];
  v20 = dword_80C1540[v3[4]];
  v12 = v20 <= v19;
  if ( v20 != v19 )
    goto LABEL_38;
  if ( !v19 )
    return 0;
  v21 = dword_80C1540[v4[5]];
  v22 = dword_80C1540[v3[5]];
  v12 = v22 <= v21;
  if ( v22 != v21 )
    goto LABEL_38;
  if ( !v21 )
    return 0;
  v23 = dword_80C1540[v4[6]];
  v24 = dword_80C1540[v3[6]];
  v12 = v24 <= v23;
  if ( v24 != v23 )
    goto LABEL_38;
  if ( !v23 )
    return 0;
  v25 = dword_80C1540[v4[7]];
  v26 = dword_80C1540[v3[7]];
  v12 = v26 <= v25;
  if ( v26 != v25 )
  {
LABEL_38:
    result = 1;
    if ( v12 )
      return -1;
    return result;
  }
  if ( !v25 )
    return 0;
  v27 = v3 + 8;
  v28 = v4 + 8;
  result = 0;
LABEL_25:
  v30 = (unsigned __int16)v28 & 0xFFF;
  if ( v30 < ((unsigned __int16)v27 & 0xFFF) )
    v30 = (unsigned __int16)v27 & 0xFFF;
  v31 = v30 - 4080;
  v32 = &v27[-v30 + 4080];
  v33 = &v28[-v30 + 4080];
  if ( v30 - 4080 > 0 )
  {
LABEL_30:
    while ( 1 )
    {
      v40 = dword_80C1540[v33[v31]];
      result = dword_80C1540[v32[v31]] - v40;
      if ( result || !v40 )
        break;
      if ( ++v31 > 15 )
      {
        v27 = &v32[v31];
        v28 = &v33[v31];
        goto LABEL_25;
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v34 = _mm_loadu_si128((const __m128i *)&v33[v31]);
      v35 = _mm_loadu_si128((const __m128i *)&v32[v31]);
      v36 = _mm_or_si128(
              v34,
              _mm_and_si128(
                _mm_and_si128(
                  _mm_cmpgt_epi8(v34, (__m128i)xmmword_80BE5A0),
                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v34)),
                (__m128i)xmmword_80BE5C0));
      v37 = _mm_or_si128(
              v35,
              _mm_and_si128(
                _mm_and_si128(
                  _mm_cmpgt_epi8(v35, (__m128i)xmmword_80BE5A0),
                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v35)),
                (__m128i)xmmword_80BE5C0));
      v39 = _mm_cmpistri(v37, v36, 26);
      v38 = _mm_cmpistrc(v37, v36, 26);
      if ( v38 | _mm_cmpistrz(v37, v36, 26) )
        break;
      v12 = (v31 + 16 < 0) ^ __OFADD__(16, v31) | (v31 == -16);
      v31 += 16;
      if ( !v12 )
        goto LABEL_30;
    }
    if ( v38 )
      return dword_80C1540[v32[v39 + v31]] - dword_80C1540[v33[v39 + v31]];
  }
  return result;
}
// 80BE5A0: using guessed type __int128 xmmword_80BE5A0;
// 80BE5B0: using guessed type __int128 xmmword_80BE5B0;
// 80BE5C0: using guessed type __int128 xmmword_80BE5C0;
// 80C1540: using guessed type int dword_80C1540[256];

//----- (0806C580) --------------------------------------------------------
__m128i *__usercall _memmove_chk_sse2_unaligned@<eax>(
        int a1@<ebx>,
        long double fst7_0@<st0>,
        __m128i *a2,
        const __m128i *a3,
        unsigned int a4,
        unsigned int a6)
{
  if ( a6 < a4 )
    _chk_fail(fst7_0);
  return _memmove_sse2_unaligned(a1, a2, a3, a4);
}

//----- (0806C590) --------------------------------------------------------
__m128i *__usercall _memmove_sse2_unaligned@<eax>(int a1@<ebx>, __m128i *a2, const __m128i *a3, unsigned int a4)
{
  unsigned int v4; // ecx
  const __m128i *v5; // eax
  __m128i v6; // xmm1
  __m128i v7; // xmm1
  __m128i v8; // xmm2
  __m128i v9; // xmm3
  __m128i v10; // xmm1
  __m128i v11; // xmm2
  __m128i v12; // xmm3
  __m128i v13; // xmm4
  __m128i v14; // xmm5
  __m128i v15; // xmm6
  __m128i v16; // xmm7
  __m128i v17; // xmm4
  __m128i v18; // xmm5
  __m128i v19; // xmm6
  __m128i v20; // xmm7
  __m128i *v21; // esi
  unsigned int v22; // ecx
  const __m128i *v23; // eax
  unsigned int v24; // ebx
  __m128i v25; // xmm1
  __m128i v26; // xmm2
  __m128i v27; // xmm3
  __int8 v28; // al
  __int16 v29; // ax
  __int32 v30; // esi
  __int32 v31; // eax
  __m128i v32; // xmm1
  __m128i v33; // xmm2
  __m128i v34; // xmm3
  __m128i v35; // xmm4
  __m128i v36; // xmm5
  __m128i v37; // xmm6
  __m128i v38; // xmm7
  __m128i *v39; // esi
  __m128i *v40; // ecx
  const __m128i *v41; // eax
  unsigned int v42; // ebx
  __m128i v43; // xmm1
  __m128i v44; // xmm2
  __m128i v45; // xmm3
  __int8 v46; // al
  __int16 v47; // ax
  __int32 v48; // eax
  __int64 v49; // xmm1_8
  __m128i v51; // xmm1
  __m128i v52; // xmm2
  __m128i v53; // xmm3
  __m128i v54; // xmm1
  __m128i v55; // xmm1
  __m128i v56; // xmm1
  __m128i v57; // xmm2
  __m128i v58; // xmm3
  unsigned int v59; // ebx
  char *v60; // eax
  unsigned int v61; // ecx
  unsigned int i; // ecx
  __m128i v63; // xmm1
  __m128i v64; // xmm2
  __m128i v65; // xmm3
  __m128i v66; // xmm1
  __m128i v67; // xmm2
  __m128i v68; // xmm3
  __m128i v69; // xmm4
  __m128i v70; // xmm5
  __m128i v71; // xmm6
  __m128i v72; // xmm7
  __m128i v73; // xmm1
  __m128i v74; // xmm2
  __m128i v75; // xmm3
  __m128i v76; // xmm1
  __m128i v77; // xmm2
  __m128i v78; // xmm3
  __m128i v79; // xmm4
  __m128i v80; // xmm5
  __m128i v81; // xmm6
  __m128i v82; // xmm7
  __m128i v83; // xmm1
  __m128i v84; // xmm2
  __m128i v85; // xmm3
  __m128i v86; // xmm4
  __m128i v87; // xmm5
  __m128i v88; // xmm6
  __m128i v89; // xmm7
  __m128i *v90; // ebx
  unsigned int v91; // ecx
  char *v92; // eax
  __m128i v93; // xmm1
  __m128i v94; // xmm2
  __m128i v95; // xmm3
  __m128i v96; // xmm4
  __m128i v97; // xmm5
  __m128i v98; // xmm6
  __m128i v99; // xmm7
  __int64 v100; // xmm1_8
  __m128i v101; // [esp+0h] [ebp-20h] BYREF
  int v102; // [esp+10h] [ebp-10h]

  v4 = a4;
  v5 = a3;
  if ( (int)a3 <= (int)a2 )
  {
    if ( a4 <= 0x10 )
    {
      while ( (v4 & 0x18) != 0 )
      {
        v30 = *(__int32 *)((char *)&a3->m128i_i32[-2] + v4);
        *(__int32 *)((char *)&a2->m128i_i32[-1] + v4) = *(__int32 *)((char *)&a3->m128i_i32[-1] + v4);
        *(__int32 *)((char *)&a2->m128i_i32[-2] + v4) = v30;
        v4 -= 8;
      }
      if ( (v4 & 4) != 0 )
      {
        v31 = *(__int32 *)((char *)&a3->m128i_i32[-1] + v4);
        a2->m128i_i32[0] = a3->m128i_i32[0];
        *(__int32 *)((char *)&a2->m128i_i32[-1] + v4) = v31;
      }
      else if ( v4 )
      {
        if ( (v4 & 2) != 0 )
        {
          v29 = a3->m128i_i16[0];
          *(__int16 *)((char *)&a2->m128i_i16[-1] + v4) = *(__int16 *)((char *)&a3->m128i_i16[-1] + v4);
          a2->m128i_i16[0] = v29;
        }
        else
        {
          v28 = a3->m128i_i8[0];
          a2->m128i_i8[v4 - 1] = a3->m128i_i8[v4 - 1];
          a2->m128i_i8[0] = v28;
        }
      }
      return a2;
    }
    if ( (int)a4 <= 32 )
      goto LABEL_4;
    if ( (int)a4 <= 64 )
    {
LABEL_6:
      v7 = _mm_loadu_si128(a3 + 1);
      v8 = _mm_loadu_si128((const __m128i *)((char *)a3 + a4 - 16));
      v9 = _mm_loadu_si128((const __m128i *)((char *)a3 + a4 - 32));
      *a2 = _mm_loadu_si128(a3);
      a2[1] = v7;
      *(__m128i *)((char *)&a2[-1] + v4) = v8;
      *(__m128i *)((char *)&a2[-2] + v4) = v9;
      return a2;
    }
    if ( (int)a4 <= 128 )
    {
LABEL_8:
      v10 = _mm_loadu_si128(a3 + 1);
      v11 = _mm_loadu_si128(a3 + 2);
      v12 = _mm_loadu_si128(a3 + 3);
      v13 = _mm_loadu_si128((const __m128i *)((char *)a3 + a4 - 64));
      v14 = _mm_loadu_si128((const __m128i *)((char *)a3 + a4 - 48));
      v15 = _mm_loadu_si128((const __m128i *)((char *)a3 + a4 - 32));
      v16 = _mm_loadu_si128((const __m128i *)((char *)a3 + a4 - 16));
      *a2 = _mm_loadu_si128(a3);
      a2[1] = v10;
      a2[2] = v11;
      a2[3] = v12;
      *(__m128i *)((char *)&a2[-4] + v4) = v13;
      *(__m128i *)((char *)&a2[-3] + v4) = v14;
      *(__m128i *)((char *)&a2[-2] + v4) = v15;
      *(__m128i *)((char *)&a2[-1] + v4) = v16;
      return a2;
    }
    v5 = a3;
    if ( (int)((int)a3->m128i_i32 + a4) > (int)a2 )
    {
      v102 = a1;
      v17 = _mm_loadu_si128(a3);
      v18 = _mm_loadu_si128(a3 + 1);
      v19 = _mm_loadu_si128(a3 + 2);
      v20 = _mm_loadu_si128(a3 + 3);
      v21 = (__m128i *)((char *)a2 + a4);
      v101 = _mm_loadu_si128((const __m128i *)((char *)a3 + a4 - 16));
      v22 = ((unsigned int)a2->m128i_u32 + a4) & 0xFFFFFFF0;
      v23 = (const __m128i *)((char *)a3 + v22 - (_DWORD)a2);
      v24 = (v22 - (unsigned int)a2) >> 6;
      if ( a4 >= _x86_shared_cache_size_half )
      {
        do
        {
          v32 = _mm_loadu_si128(v23 - 3);
          v33 = _mm_loadu_si128(v23 - 2);
          v34 = _mm_loadu_si128(v23 - 1);
          _mm_stream_si128((__m128i *)(v22 - 64), _mm_loadu_si128(v23 - 4));
          v23 -= 4;
          _mm_stream_si128((__m128i *)(v22 - 48), v32);
          _mm_stream_si128((__m128i *)(v22 - 32), v33);
          _mm_stream_si128((__m128i *)(v22 - 16), v34);
          v22 -= 64;
          --v24;
        }
        while ( v24 );
        _mm_sfence();
        v21[-1] = _mm_loadu_si128(&v101);
        *a2 = v17;
        a2[1] = v18;
        a2[2] = v19;
        a2[3] = v20;
      }
      else
      {
        do
        {
          _mm_prefetch(v23[-8].m128i_i8, 1);
          v25 = _mm_loadu_si128(v23 - 3);
          v26 = _mm_loadu_si128(v23 - 2);
          v27 = _mm_loadu_si128(v23 - 1);
          *(__m128i *)(v22 - 64) = _mm_loadu_si128(v23 - 4);
          v23 -= 4;
          *(__m128i *)(v22 - 48) = v25;
          *(__m128i *)(v22 - 32) = v26;
          *(__m128i *)(v22 - 16) = v27;
          v22 -= 64;
          --v24;
        }
        while ( v24 );
        v21[-1] = _mm_loadu_si128(&v101);
        *a2 = v17;
        a2[1] = v18;
        a2[2] = v19;
        a2[3] = v20;
      }
      return a2;
    }
LABEL_42:
    if ( v4 <= 0x10 )
    {
      if ( (v4 & 0x18) != 0 )
      {
        v100 = *(__int64 *)((char *)&v5->m128i_i64[-1] + v4);
        a2->m128i_i64[0] = v5->m128i_i64[0];
        *(__int64 *)((char *)&a2->m128i_i64[-1] + v4) = v100;
      }
      else if ( (v4 & 4) != 0 )
      {
        a2->m128i_i32[0] = v5->m128i_i32[0];
        *(__int32 *)((char *)&a2->m128i_i32[-1] + v4) = *(__int32 *)((char *)&v5->m128i_i32[-1] + v4);
      }
      else if ( v4 )
      {
        a2->m128i_i8[0] = v5->m128i_i8[0];
        if ( (v4 & 2) != 0 )
          *(__int16 *)((char *)&a2->m128i_i16[-1] + v4) = *(__int16 *)((char *)&v5->m128i_i16[-1] + v4);
      }
    }
    else if ( v4 >= _x86_shared_cache_size_half )
    {
      v76 = _mm_loadu_si128(v5 + 1);
      v77 = _mm_loadu_si128(v5 + 2);
      v78 = _mm_loadu_si128(v5 + 3);
      v79 = _mm_loadu_si128((const __m128i *)((char *)v5 + v4 - 64));
      v80 = _mm_loadu_si128((const __m128i *)((char *)v5 + v4 - 48));
      v81 = _mm_loadu_si128((const __m128i *)((char *)v5 + v4 - 32));
      v82 = _mm_loadu_si128((const __m128i *)((char *)v5 + v4 - 16));
      *a2 = _mm_loadu_si128(v5);
      a2[1] = v76;
      a2[2] = v77;
      a2[3] = v78;
      *(__m128i *)((char *)&a2[-4] + v4) = v79;
      *(__m128i *)((char *)&a2[-3] + v4) = v80;
      *(__m128i *)((char *)&a2[-2] + v4) = v81;
      *(__m128i *)((char *)&a2[-1] + v4) = v82;
      v83 = _mm_loadu_si128(v5 + 5);
      v84 = _mm_loadu_si128(v5 + 6);
      v85 = _mm_loadu_si128(v5 + 7);
      v86 = _mm_loadu_si128((const __m128i *)((char *)v5 + v4 - 128));
      v87 = _mm_loadu_si128((const __m128i *)((char *)v5 + v4 - 112));
      v88 = _mm_loadu_si128((const __m128i *)((char *)v5 + v4 - 96));
      v89 = _mm_loadu_si128((const __m128i *)((char *)v5 + v4 - 80));
      a2[4] = _mm_loadu_si128(v5 + 4);
      a2[5] = v83;
      a2[6] = v84;
      a2[7] = v85;
      *(__m128i *)((char *)&a2[-8] + v4) = v86;
      *(__m128i *)((char *)&a2[-7] + v4) = v87;
      *(__m128i *)((char *)&a2[-6] + v4) = v88;
      *(__m128i *)((char *)&a2[-5] + v4) = v89;
      v90 = (__m128i *)((unsigned int)&a2[8] & 0xFFFFFF80);
      v91 = ((unsigned int)a2->m128i_u32 + v4) & 0xFFFFFF80;
      v92 = (char *)((char *)v5 - (char *)a2);
      do
      {
        v93 = _mm_loadu_si128((const __m128i *)&v92[(_DWORD)v90 + 16]);
        v94 = _mm_loadu_si128((const __m128i *)&v92[(_DWORD)v90 + 32]);
        v95 = _mm_loadu_si128((const __m128i *)&v92[(_DWORD)v90 + 48]);
        v96 = _mm_loadu_si128((const __m128i *)&v92[(_DWORD)v90 + 64]);
        v97 = _mm_loadu_si128((const __m128i *)&v92[(_DWORD)v90 + 80]);
        v98 = _mm_loadu_si128((const __m128i *)&v92[(_DWORD)v90 + 96]);
        v99 = _mm_loadu_si128((const __m128i *)&v92[(_DWORD)v90 + 112]);
        _mm_stream_si128(v90, _mm_loadu_si128((const __m128i *)&v92[(_DWORD)v90]));
        _mm_stream_si128(v90 + 1, v93);
        _mm_stream_si128(v90 + 2, v94);
        _mm_stream_si128(v90 + 3, v95);
        _mm_stream_si128(v90 + 4, v96);
        _mm_stream_si128(v90 + 5, v97);
        _mm_stream_si128(v90 + 6, v98);
        _mm_stream_si128(v90 + 7, v99);
        v90 += 8;
      }
      while ( (__m128i *)v91 != v90 );
      _mm_sfence();
    }
    else
    {
      v54 = _mm_loadu_si128((const __m128i *)((char *)v5 + v4 - 16));
      *a2 = _mm_loadu_si128(v5);
      *(__m128i *)((char *)&a2[-1] + v4) = v54;
      if ( v4 > 0x20 )
      {
        v55 = _mm_loadu_si128((const __m128i *)((char *)v5 + v4 - 32));
        a2[1] = _mm_loadu_si128(v5 + 1);
        *(__m128i *)((char *)&a2[-2] + v4) = v55;
        if ( v4 > 0x40 )
        {
          v56 = _mm_loadu_si128(v5 + 3);
          v57 = _mm_loadu_si128((const __m128i *)((char *)v5 + v4 - 48));
          v58 = _mm_loadu_si128((const __m128i *)((char *)v5 + v4 - 64));
          a2[2] = _mm_loadu_si128(v5 + 2);
          a2[3] = v56;
          *(__m128i *)((char *)&a2[-3] + v4) = v57;
          *(__m128i *)((char *)&a2[-4] + v4) = v58;
          if ( v4 > 0x80 )
          {
            v59 = (unsigned int)&a2[4] & 0xFFFFFFC0;
            v60 = (char *)((char *)v5 - (char *)a2);
            v61 = (((unsigned int)a2->m128i_u32 + v4) & 0xFFFFFFC0) - 64;
            if ( v61 == v59 )
            {
              v73 = _mm_loadu_si128((const __m128i *)&v60[v59 + 16]);
              v74 = _mm_loadu_si128((const __m128i *)&v60[v59 + 32]);
              v75 = _mm_loadu_si128((const __m128i *)&v60[v59 + 48]);
              *(__m128i *)v59 = _mm_loadu_si128((const __m128i *)&v60[v59]);
              *(__m128i *)(((unsigned int)&a2[4] & 0xFFFFFFC0) + 0x10) = v73;
              *(__m128i *)(((unsigned int)&a2[4] & 0xFFFFFFC0) + 0x20) = v74;
              *(__m128i *)(((unsigned int)&a2[4] & 0xFFFFFFC0) + 0x30) = v75;
            }
            else
            {
              for ( i = v61 - 64; i != v59; v59 += 64 )
              {
                _mm_prefetch(&v60[v59 + 128], 1);
                v63 = _mm_loadu_si128((const __m128i *)&v60[v59 + 16]);
                v64 = _mm_loadu_si128((const __m128i *)&v60[v59 + 32]);
                v65 = _mm_loadu_si128((const __m128i *)&v60[v59 + 48]);
                *(__m128i *)v59 = _mm_loadu_si128((const __m128i *)&v60[v59]);
                *(__m128i *)(v59 + 16) = v63;
                *(__m128i *)(v59 + 32) = v64;
                *(__m128i *)(v59 + 48) = v65;
              }
              v66 = _mm_loadu_si128((const __m128i *)&v60[v59 + 16]);
              v67 = _mm_loadu_si128((const __m128i *)&v60[v59 + 32]);
              v68 = _mm_loadu_si128((const __m128i *)&v60[v59 + 48]);
              v69 = _mm_loadu_si128((const __m128i *)&v60[v59 + 64]);
              v70 = _mm_loadu_si128((const __m128i *)&v60[v59 + 80]);
              v71 = _mm_loadu_si128((const __m128i *)&v60[v59 + 96]);
              v72 = _mm_loadu_si128((const __m128i *)&v60[v59 + 112]);
              *(__m128i *)v59 = _mm_loadu_si128((const __m128i *)&v60[v59]);
              *(__m128i *)(v59 + 16) = v66;
              *(__m128i *)(v59 + 32) = v67;
              *(__m128i *)(v59 + 48) = v68;
              *(__m128i *)(v59 + 64) = v69;
              *(__m128i *)(v59 + 80) = v70;
              *(__m128i *)(v59 + 96) = v71;
              *(__m128i *)(v59 + 112) = v72;
            }
          }
        }
      }
    }
    return a2;
  }
  v4 = a4;
  if ( (int)((int)a2->m128i_i32 + a4) <= (int)a3 )
    goto LABEL_42;
  if ( a4 <= 0x10 )
  {
    if ( (a4 & 0x18) != 0 )
    {
      v49 = *(__int64 *)((char *)&a3->m128i_i64[-1] + a4);
      a2->m128i_i64[0] = a3->m128i_i64[0];
      *(__int64 *)((char *)&a2->m128i_i64[-1] + a4) = v49;
    }
    else if ( (a4 & 4) != 0 )
    {
      v48 = *(__int32 *)((char *)&a3->m128i_i32[-1] + a4);
      a2->m128i_i32[0] = a3->m128i_i32[0];
      *(__int32 *)((char *)&a2->m128i_i32[-1] + a4) = v48;
    }
    else if ( a4 )
    {
      if ( (a4 & 2) != 0 )
      {
        v47 = a3->m128i_i16[0];
        *(__int16 *)((char *)&a2->m128i_i16[-1] + a4) = *(__int16 *)((char *)&a3->m128i_i16[-1] + a4);
        a2->m128i_i16[0] = v47;
      }
      else
      {
        v46 = a3->m128i_i8[0];
        a2->m128i_i8[a4 - 1] = a3->m128i_i8[a4 - 1];
        a2->m128i_i8[0] = v46;
      }
    }
    return a2;
  }
  if ( a4 > 0x20 )
  {
    if ( a4 <= 0x40 )
      goto LABEL_6;
    if ( a4 <= 0x80 )
      goto LABEL_8;
    v102 = a1;
    v35 = _mm_loadu_si128((const __m128i *)((char *)a3 + a4 - 16));
    v36 = _mm_loadu_si128((const __m128i *)((char *)a3 + a4 - 32));
    v37 = _mm_loadu_si128((const __m128i *)((char *)a3 + a4 - 48));
    v38 = _mm_loadu_si128((const __m128i *)((char *)a3 + a4 - 64));
    v39 = (__m128i *)((char *)a2 + a4);
    v101 = _mm_loadu_si128(a3);
    v40 = (__m128i *)((unsigned int)&a2[1] & 0xFFFFFFF0);
    v41 = (const __m128i *)((char *)a3 + (char *)v40 - (char *)a2);
    v42 = (unsigned int)(&a2->m128i_i8[a4] - (__int8 *)v40) >> 6;
    if ( a4 >= _x86_shared_cache_size_half )
    {
      do
      {
        v51 = _mm_loadu_si128(v41 + 1);
        v52 = _mm_loadu_si128(v41 + 2);
        v53 = _mm_loadu_si128(v41 + 3);
        _mm_stream_si128(v40, _mm_loadu_si128(v41));
        v41 += 4;
        _mm_stream_si128(v40 + 1, v51);
        _mm_stream_si128(v40 + 2, v52);
        _mm_stream_si128(v40 + 3, v53);
        v40 += 4;
        --v42;
      }
      while ( v42 );
      _mm_sfence();
      *a2 = _mm_loadu_si128(&v101);
      v39[-1] = v35;
      v39[-2] = v36;
      v39[-3] = v37;
      v39[-4] = v38;
    }
    else
    {
      do
      {
        _mm_prefetch(v41[8].m128i_i8, 1);
        v43 = _mm_loadu_si128(v41 + 1);
        v44 = _mm_loadu_si128(v41 + 2);
        v45 = _mm_loadu_si128(v41 + 3);
        *v40 = _mm_loadu_si128(v41);
        v41 += 4;
        v40[1] = v43;
        v40[2] = v44;
        v40[3] = v45;
        v40 += 4;
        --v42;
      }
      while ( v42 );
      *a2 = _mm_loadu_si128(&v101);
      v39[-1] = v35;
      v39[-2] = v36;
      v39[-3] = v37;
      v39[-4] = v38;
    }
    return a2;
  }
LABEL_4:
  v6 = _mm_loadu_si128((const __m128i *)((char *)a3 + a4 - 16));
  *a2 = _mm_loadu_si128(a3);
  *(__m128i *)((char *)&a2[-1] + v4) = v6;
  return a2;
}
// 80EB984: using guessed type int _x86_shared_cache_size_half;

//----- (0806CD10) --------------------------------------------------------
_BYTE *__cdecl _strcspn_sse42(int a1, __m128i *a2)
{
  const __m128i *v2; // eax
  int v3; // ebx
  __m128i v4; // xmm1
  int v5; // ebx
  __m128i v6; // xmm3
  int v7; // esi
  int v8; // ecx
  __m128i si128; // xmm0
  int v11; // ecx
  __m128i v12; // xmm2
  int v13; // ecx

  v2 = (const __m128i *)a1;
  if ( !a2->m128i_i8[0] )
    return (_BYTE *)strlen((_BYTE *)a1);
  v3 = (unsigned __int8)a2 & 0xF;
  if ( ((unsigned __int8)a2 & 0xF) != 0 )
  {
    v4 = _mm_shuffle_epi8(
           _mm_load_si128((const __m128i *)((unsigned int)a2 & 0xFFFFFFF0)),
           _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + v3)));
    if ( 16 - v3 == _mm_cmpistri(v4, v4, 58) )
    {
      si128 = _mm_load_si128((const __m128i *)(((unsigned int)a2 & 0xFFFFFFF0) + 16));
      v11 = _mm_cmpistri(si128, si128, 58);
      if ( v11 + 16 - v3 > 16 )
        return _strcspn_ia32(a1, a2);
      if ( v11 )
        v4 = _mm_loadu_si128(a2);
    }
  }
  else
  {
    v4 = _mm_load_si128(a2);
    if ( _mm_cmpistri(v4, v4, 58) == 16 && a2[1].m128i_i8[0] )
      return _strcspn_ia32(a1, a2);
  }
  v5 = a1 & 0xF;
  if ( (a1 & 0xF) != 0 )
  {
    v12 = _mm_shuffle_epi8(
            _mm_load_si128((const __m128i *)(a1 & 0xFFFFFFF0)),
            _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + v5)));
    v13 = _mm_cmpistri(v4, v12, 2);
    if ( _mm_cmpistrc(v4, v12, 2) )
      return (_BYTE *)v13;
    v13 = _mm_cmpistri(v12, v12, 58);
    v2 = (const __m128i *)((a1 & 0xFFFFFFF0) + 16);
    if ( 16 - v5 > v13 )
      return (_BYTE *)v13;
  }
  while ( 1 )
  {
    v6 = _mm_load_si128(v2);
    v7 = _mm_cmpistri(v4, v6, 2);
    v8 = _mm_cmpistrz(v4, v6, 2);
    if ( _mm_cmpistrc(v4, v6, 2) )
      return (char *)v2 + v7 - a1;
    if ( v8 )
      break;
    ++v2;
  }
  return (char *)v2 + _mm_cmpistri(v6, v6, 58) - a1;
}
// 80CDA80: using guessed type __int128 __m128i_shift_right;

//----- (0806CE50) --------------------------------------------------------
int __usercall intel_check_word@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, _BYTE *a4)
{
  unsigned int v4; // edi
  int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // ebp
  unsigned int v8; // eax
  bool v9; // cf
  char *v10; // ecx
  unsigned int v17; // ebp
  int v18; // ebx
  int v19; // eax
  int v20; // edi
  int v26; // edx
  int v27; // eax
  int v28; // eax
  int v29; // [esp+0h] [ebp-2Ch]
  int v31; // [esp+4h] [ebp-28h]
  int v32; // [esp+8h] [ebp-24h]
  bool v33; // [esp+Ch] [ebp-20h]

  v29 = a1;
  if ( a2 < 0 )
    return 0;
  v4 = a2;
  v5 = 3 * ((a1 - 185) / 3);
  if ( !a2 )
    return 0;
  v33 = dword_80EC59C == 6 && dword_80EC598 == 15;
  while ( 1 )
  {
    if ( (unsigned __int8)v4 == 64 )
    {
      *a4 = 1;
      if ( v5 == 9 )
        return 0;
      goto LABEL_18;
    }
    if ( (unsigned __int8)v4 == 255 )
      break;
    if ( (unsigned __int8)v4 == 73 && v5 == 9 && v33 )
    {
      v29 -= 3;
      v5 = 6;
    }
    v6 = 0;
    v7 = 68;
    while ( 1 )
    {
      v8 = (v7 + v6) >> 1;
      v9 = (unsigned __int8)v4 < (unsigned __int8)intel_02_known[8 * v8];
      v10 = &intel_02_known[8 * v8];
      if ( (_BYTE)v4 == *v10 )
        break;
      while ( v9 )
      {
        v7 = v8;
        if ( v8 <= v6 )
          goto LABEL_18;
        v8 = (v6 + v8) >> 1;
        v9 = (unsigned __int8)v4 < (unsigned __int8)intel_02_known[8 * v8];
        v10 = &intel_02_known[8 * v8];
        if ( (_BYTE)v4 == *v10 )
          goto LABEL_15;
      }
      v6 = v8 + 1;
      if ( v8 + 1 >= v7 )
        goto LABEL_18;
    }
LABEL_15:
    if ( v5 == (unsigned __int8)v10[3] )
    {
      v28 = v29 - 185 - v5;
      if ( v29 - 185 == v5 )
        return *((_DWORD *)v10 + 1);
      if ( v28 == 1 )
        return (unsigned __int8)v10[1];
      if ( v28 != 2 )
        _assert_fail("offset == 2", "../sysdeps/x86/cacheinfo.c", 241, "intel_check_word");
      return (unsigned __int8)v10[2];
    }
    if ( v10[3] == 6 )
      *a3 = 1;
LABEL_18:
    v4 >>= 8;
    if ( !v4 )
      return 0;
  }
  _EAX = 4;
  __asm { cpuid }
  v17 = _EBX;
  v32 = _ECX;
  v18 = _EAX & 0x1F;
  if ( (_EAX & 0x1F) == 0 )
    return 0;
  v19 = (unsigned __int8)_EAX >> 5;
  if ( (v18 != 1 || v5 != 3 || v19 != 1) && (v18 != 2 || v5 != 0 || v19 != 1) )
  {
    v31 = v17;
    v20 = 0;
    do
    {
      if ( v19 == 2 && v5 == 6 || v19 == 3 && v5 == 9 || v19 == 4 && v5 == 12 )
        break;
      ++v20;
      _EAX = 4;
      __asm { cpuid }
      v31 = _EBX;
      v32 = _ECX;
      v26 = _EAX & 0x1F;
      if ( (_EAX & 0x1F) == 0 )
        return 0;
      v19 = (unsigned __int8)_EAX >> 5;
      if ( v26 == 1 && v5 == 3 && v19 == 1 )
        break;
    }
    while ( v26 != 2 || v5 != 0 || v19 != 1 );
    v17 = v31;
  }
  v27 = v29 - 185 - v5;
  if ( v29 - 185 == v5 )
    return ((v17 & 0xFFF) + 1) * ((v17 >> 22) + 1) * (v32 + 1) * (((v17 >> 12) & 0x3FF) + 1);
  if ( v27 == 1 )
    return (v17 >> 22) + 1;
  if ( v27 != 2 )
    _assert_fail("offset == 2", "../sysdeps/x86/cacheinfo.c", 193, "intel_check_word");
  return (v17 & 0xFFF) + 1;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EC598: using guessed type int dword_80EC598;
// 80EC59C: using guessed type int dword_80EC59C;

//----- (0806D130) --------------------------------------------------------
int __usercall handle_intel@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  unsigned int v3; // edi
  int result; // eax
  int v10; // edx
  int v11; // [esp+0h] [ebp-38h]
  int v12; // [esp+4h] [ebp-34h]
  unsigned int v13; // [esp+8h] [ebp-30h]
  char v14; // [esp+1Ah] [ebp-1Eh] BYREF
  char v15[29]; // [esp+1Bh] [ebp-1Dh] BYREF

  if ( a2 <= 1 )
    return -1;
  v3 = 1;
  v14 = 0;
  v15[0] = 0;
  v13 = 1;
  while ( 1 )
  {
    _EAX = 2;
    __asm { cpuid }
    v12 = _EDX;
    v11 = _ECX;
    v10 = _EAX;
    if ( v3 == 1 )
    {
      LOBYTE(v10) = 0;
      v13 = (unsigned __int8)_EAX;
    }
    result = intel_check_word(a1, v10, v15, &v14);
    if ( result )
      break;
    result = intel_check_word(a1, _EBX, v15, &v14);
    if ( result )
      break;
    result = intel_check_word(a1, v11, v15, &v14);
    if ( result )
      break;
    result = intel_check_word(a1, v12, v15, &v14);
    if ( result )
      break;
    if ( v13 <= v3 )
    {
      if ( (unsigned int)(a1 - 191) <= 5 )
      {
        if ( v14 )
          return -1;
      }
      return result;
    }
    ++v3;
  }
  return result;
}

//----- (0806D230) --------------------------------------------------------
int __usercall handle_amd@<eax>(int a1@<eax>)
{
  int result; // eax
  unsigned int v13; // ecx
  int v14; // edx
  bool v15; // zf
  int v16; // ecx

  _EAX = 0x80000000;
  __asm { cpuid }
  if ( a1 > 196 || (unsigned int)(a1 > 190) - 2147483643 > _EAX )
    return 0;
  _EAX = (a1 > 190) - 2147483643;
  __asm { cpuid }
  if ( a1 <= 187 )
  {
    a1 += 3;
    _ECX = _EDX;
  }
  switch ( a1 )
  {
    case 188:
      result = (_ECX >> 14) & 0x3FC00;
      break;
    case 189:
      v13 = HIWORD(_ECX);
      v14 = (unsigned __int8)v13;
      v15 = (unsigned __int8)v13 == 255;
      v16 = (4 * v13) & 0x3FC00;
      result = v14;
      if ( v15 )
        result = v16;
      break;
    case 190:
      result = (unsigned __int8)_ECX;
      break;
    case 191:
      result = 0;
      if ( (_ECX & 0xF000) != 0 )
        result = (_ECX >> 6) & 0x3FFFC00;
      break;
    case 192:
      switch ( (unsigned __int16)_ECX >> 12 )
      {
        case 0:
        case 1:
        case 2:
        case 4:
          result = (unsigned __int16)_ECX >> 12;
          break;
        case 3:
        case 5:
        case 7:
        case 9:
          return 0;
        case 6:
          goto LABEL_27;
        case 8:
          goto LABEL_29;
        case 10:
          goto LABEL_28;
        case 11:
          goto LABEL_33;
        case 12:
          goto LABEL_32;
        case 13:
          goto LABEL_31;
        case 14:
          goto LABEL_30;
        case 15:
          result = ((_ECX >> 6) & 0x3FFFC00) / (unsigned __int8)_ECX;
          break;
      }
      break;
    case 193:
      result = 0;
      if ( (_ECX & 0xF000) != 0 )
        result = (unsigned __int8)_ECX;
      break;
    case 194:
      result = (2 * _EDX) & 0x7FF80000;
      if ( (_EDX & 0xF000) == 0 )
        result = 0;
      break;
    case 195:
      switch ( (unsigned __int16)_EDX >> 12 )
      {
        case 0:
        case 1:
        case 2:
        case 4:
          result = (unsigned __int16)_EDX >> 12;
          break;
        case 3:
        case 5:
        case 7:
        case 9:
          return 0;
        case 6:
LABEL_27:
          result = 8;
          break;
        case 8:
LABEL_29:
          result = 16;
          break;
        case 10:
LABEL_28:
          result = 32;
          break;
        case 11:
LABEL_33:
          result = 48;
          break;
        case 12:
LABEL_32:
          result = 64;
          break;
        case 13:
LABEL_31:
          result = 96;
          break;
        case 14:
LABEL_30:
          result = 128;
          break;
        case 15:
          result = ((2 * _EDX) & 0x7FF80000) / (unsigned __int8)_EDX;
          break;
      }
      break;
    case 196:
      result = (unsigned __int8)_EDX;
      if ( (_EDX & 0xF000) == 0 )
        result = 0;
      break;
    default:
      _assert_fail("! \"cannot happen\"", "../sysdeps/x86/cacheinfo.c", 428, "handle_amd");
  }
  return result;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0806D430) --------------------------------------------------------
int __cdecl _cache_sysconf(int a1)
{
  if ( dl_x86_cpu_features == 1 )
    return handle_intel(a1, dword_80EC564);
  if ( dl_x86_cpu_features == 2 )
    return handle_amd(a1);
  return 0;
}
// 80EC560: using guessed type int dl_x86_cpu_features;
// 80EC564: using guessed type int dword_80EC564;

//----- (0806D470) --------------------------------------------------------
_WORD *__cdecl wmempcpy(_BYTE *a1, _BYTE *a2, int a3)
{
  return mempcpy(a1, a2, 4 * a3);
}

//----- (0806D480) --------------------------------------------------------
int __usercall nl_cleanup_ctype@<eax>(int result@<eax>)
{
  int *v1; // ebx

  v1 = *(int **)(result + 20);
  if ( v1 )
  {
    *(_DWORD *)(result + 20) = 0;
    *(_DWORD *)(result + 16) = 0;
    _gconv_close_transform(v1[2], v1[3]);
    _gconv_close_transform(*v1, v1[1]);
    return free(v1);
  }
  return result;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0806D4C0) --------------------------------------------------------
int __cdecl _wcsmbs_getfct(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int *a3)
{
  unsigned int v4; // [esp+10h] [ebp-14h] BYREF
  int v5[4]; // [esp+14h] [ebp-10h] BYREF

  if ( _gconv_find_transform(a1, a2, v5, (int *)&v4, 0) )
    return 0;
  if ( v4 <= 1 )
  {
    *a3 = v4;
    return v5[0];
  }
  else
  {
    _gconv_close_transform(v5[0], v4);
    return 0;
  }
}
// 806D4C0: using guessed type int var_10[4];

//----- (0806D520) --------------------------------------------------------
int __usercall _wcsmbs_load_conv@<eax>(_DWORD *a1@<eax>)
{
  int v2; // esi
  char *v3; // ecx
  bool v4; // cf
  const char *v5; // eax
  unsigned int v6; // esi
  char *i; // eax
  char v8; // dl
  int v9; // edx
  void *v10; // esp
  _BYTE *v11; // eax
  int *v12; // edi
  unsigned __int8 *v13; // esi
  int v14; // eax
  int v15; // eax
  int *v16; // eax
  unsigned int v18; // edx
  char *v19; // [esp+0h] [ebp-28h] BYREF
  unsigned int v20; // [esp+4h] [ebp-24h]
  char **v21; // [esp+8h] [ebp-20h]
  int *v22; // [esp+Ch] [ebp-1Ch]

  if ( !a1[5] )
  {
    v22 = (int *)calloc(1u, 0x10u);
    if ( v22 )
    {
      v2 = a1[7];
      v3 = (char *)a1[23];
      v4 = v2 == 0;
      v20 = v2 != 0 ? 8 : 0;
      v5 = "TRANSLIT";
      if ( !v2 )
        v5 = (const char *)&unk_80CFAB1;
      v6 = 0;
      v19 = (char *)v5;
      for ( i = v3; ; ++i )
      {
        v8 = *i;
        if ( !*i )
          break;
        v6 += v8 == 47;
      }
      v9 = *v3;
      v10 = alloca((v4 ? 3 : 11) + i - v3 + 15);
      v11 = &v19;
      v21 = &v19;
      if ( (_BYTE)v9 )
      {
        do
        {
          ++v11;
          ++v3;
          *(v11 - 1) = dword_80C1B40[v9];
          v9 = *v3;
        }
        while ( (_BYTE)v9 );
      }
      else
      {
        v11 = v21;
      }
      if ( v6 <= 1 )
      {
        *v11 = 47;
        if ( v6 )
        {
          ++v11;
        }
        else
        {
          v18 = v20;
          v11[1] = 47;
          v11 += 2;
          if ( v18 )
            v11 = mempcpy(v11, v19, v20);
        }
      }
      v12 = v22;
      v13 = (unsigned __int8 *)v21;
      *v11 = 0;
      v14 = _wcsmbs_getfct("INTERNAL", v13, (unsigned int *)v12 + 1);
      *v12 = v14;
      if ( v14 )
      {
        v15 = _wcsmbs_getfct(v13, "INTERNAL", (unsigned int *)v12 + 3);
        v12[2] = v15;
        if ( v15 )
        {
LABEL_13:
          v16 = v22;
          a1[4] = nl_cleanup_ctype;
          a1[5] = v16;
          return 0;
        }
        if ( *v22 )
          _gconv_close_transform(*v22, v22[1]);
      }
      else if ( v22[2] )
      {
        goto LABEL_13;
      }
      free(v22);
    }
    a1[5] = &_wcsmbs_gconv_fcts_c;
  }
  return 0;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80BE940: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80C1B40: using guessed type _DWORD dword_80C1B40[256];

//----- (0806D6F0) --------------------------------------------------------
_DWORD *__usercall _wcsmbs_clone_conv@<eax>(void **a1@<eax>)
{
  unsigned int v2; // eax
  void **v3; // esi
  void **v4; // eax
  _DWORD *v5; // edx
  bool v6; // zf
  _DWORD *result; // eax

  v2 = __readgsdword(0xFFFFFFD8);
  v3 = *(void ***)v2;
  v4 = *(void ***)(*(_DWORD *)v2 + 20);
  if ( !v4 )
  {
    if ( v3 == &nl_C_LC_CTYPE )
    {
      v4 = &_wcsmbs_gconv_fcts_c;
    }
    else
    {
      _wcsmbs_load_conv(v3);
      v4 = (void **)v3[5];
    }
  }
  v5 = *v4;
  *a1 = *v4;
  a1[1] = v4[1];
  a1[2] = v4[2];
  v6 = *v5 == 0;
  a1[3] = v4[3];
  if ( !v6 )
    ++v5[2];
  result = a1[2];
  if ( *result )
    ++result[2];
  return result;
}
// 80BE940: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80C0B60: using guessed type void *nl_C_LC_CTYPE;

//----- (0806D760) --------------------------------------------------------
int __usercall _wcsmbs_named_conv@<eax>(int *a1@<eax>, int a2@<edx>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  v4 = _wcsmbs_getfct("INTERNAL", a2, a1 + 1);
  *a1 = v4;
  if ( !v4 )
    return 1;
  v5 = _wcsmbs_getfct(a2, "INTERNAL", a1 + 3);
  a1[2] = v5;
  result = 0;
  if ( !v5 )
  {
    _gconv_close_transform(*a1, a1[1]);
    return 1;
  }
  return result;
}
// 806D4C0: using guessed type _DWORD __cdecl _wcsmbs_getfct(_DWORD, _DWORD, _DWORD);

//----- (0806D7D1) --------------------------------------------------------
void __noreturn exit(int status)
{
  int v1; // eax

  ((void (__cdecl *)())dl_sysinfo)();
  v1 = sys_exit(status);
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806D7F0) --------------------------------------------------------
int __usercall _sysconf_check_spec@<eax>(_BYTE *a1@<eax>)
{
  char *v2; // eax
  char *v3; // ebx
  int v4; // ecx
  int v5; // eax
  unsigned int v6; // esi
  void *v7; // esp
  _BYTE *v8; // eax
  int result; // eax
  unsigned int v10; // [esp+4h] [ebp-90h]
  _BYTE v11[8]; // [esp+Ch] [ebp-88h] BYREF
  _BYTE *v12; // [esp+14h] [ebp-80h]
  unsigned int v13; // [esp+18h] [ebp-7Ch]
  char v14[120]; // [esp+1Ch] [ebp-78h] BYREF

  v13 = __readgsdword(0xFFFFFFE8);
  v2 = (char *)secure_getenv("GETCONF_DIR");
  if ( v2 )
  {
    v3 = v2;
    v4 = strlen(v2);
  }
  else
  {
    v4 = 16;
    v3 = "/usr/lib/getconf";
  }
  v12 = (_BYTE *)v4;
  v5 = strlen(a1);
  v6 = v5 + 1;
  v7 = alloca((int)&v12[v5 + 11]);
  v10 = (unsigned int)v12;
  v12 = v11;
  v8 = mempcpy(v11, v3, v10);
  qmemcpy(v8, "/POSIX_V6_", 10);
  memcpy(v8 + 10, a1, v6);
  result = ((int)_xstat64(3, (int)v12, (int)v14) >> 31) | 1;
  __writegsdword(0xFFFFFFE8, v13);
  return result;
}
// 806D7F0: using guessed type char var_78[120];

//----- (0806D8D0) --------------------------------------------------------
int __usercall sysconf@<eax>(char *a1@<ecx>, long double a2@<st0>, int a3)
{
  unsigned int v3; // eax
  int v4; // ebx
  int *v5; // ecx
  unsigned int v6; // eax
  int v7; // ebp
  int v8; // eax
  int result; // eax
  unsigned int v10; // edx
  int v11; // edx
  char *v12; // [esp+8h] [ebp-54h]
  int *v13; // [esp+Ch] [ebp-50h]
  char *v14; // [esp+1Ch] [ebp-40h] BYREF
  int v15[15]; // [esp+20h] [ebp-3Ch] BYREF

  if ( (unsigned int)(a3 - 185) <= 0xE )
    return _cache_sysconf(a3);
  if ( a3 == 34 )
  {
    if ( !getrlimit(11, (int)v15) )
      return v15[0];
  }
  else
  {
    if ( a3 > 34 )
    {
      if ( a3 >= 138 )
      {
        if ( a3 <= 139 )
          return 200809;
        if ( a3 == 149 )
          return (unsigned int)dl_sysinfo(v15) > 0xFFFFF000 ? -1 : 0x31069;
      }
      goto LABEL_24;
    }
    if ( !a3 )
    {
      v10 = getrlimit(3, (int)v15);
      result = 0x20000;
      if ( !v10 && v15[0] >= 0x80000u )
        return (unsigned int)v15[0] >> 2;
      return result;
    }
    if ( a3 != 3 )
    {
LABEL_24:
      switch ( a3 )
      {
        case 0:
        case 23:
        case 24:
        case 27:
        case 32:
        case 34:
        case 35:
        case 49:
        case 50:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 61:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 76:
        case 97:
        case 116:
        case 117:
        case 134:
        case 135:
        case 136:
        case 138:
        case 139:
        case 140:
        case 141:
        case 142:
        case 143:
        case 144:
        case 145:
        case 146:
        case 147:
        case 148:
        case 149:
        case 150:
        case 151:
        case 152:
        case 156:
        case 158:
        case 160:
        case 161:
        case 162:
        case 163:
        case 165:
        case 166:
        case 167:
        case 168:
        case 169:
        case 170:
        case 171:
        case 172:
        case 173:
        case 174:
        case 175:
        case 181:
        case 182:
        case 183:
        case 184:
        case 242:
        case 243:
        case 244:
        case 245:
        case 246:
          result = -1;
          break;
        case 1:
          result = _get_child_max();
          break;
        case 2:
          result = _getclktck();
          break;
        case 3:
          result = 0x10000;
          break;
        case 4:
          result = getdtablesize();
          break;
        case 5:
          result = 16;
          break;
        case 6:
          v11 = _tzname_max(a2);
          result = 6;
          if ( v11 > 6 )
            result = _tzname_max(a2);
          break;
        case 7:
          result = 1;
          break;
        case 8:
          result = 1;
          break;
        case 9:
          result = 200809;
          break;
        case 10:
          result = 200809;
          break;
        case 11:
          result = 200809;
          break;
        case 12:
          result = 200809;
          break;
        case 13:
          result = 200809;
          break;
        case 14:
          result = 200809;
          break;
        case 15:
          result = 200809;
          break;
        case 16:
          result = 200809;
          break;
        case 17:
          result = 200809;
          break;
        case 18:
          result = 200809;
          break;
        case 19:
          result = 200809;
          break;
        case 20:
          result = 200809;
          break;
        case 21:
          result = 200809;
          break;
        case 22:
          result = 200809;
          break;
        case 25:
          result = 20;
          break;
        case 26:
          result = 0x7FFFFFFF;
          break;
        case 28:
          result = 0x8000;
          break;
        case 29:
          result = 200809;
          break;
        case 30:
          result = getpagesize();
          break;
        case 31:
          result = 32;
          break;
        case 33:
          result = 0x7FFFFFFF;
          break;
        case 36:
          result = 99;
          break;
        case 37:
          result = 2048;
          break;
        case 38:
          result = 99;
          break;
        case 39:
          result = 1000;
          break;
        case 40:
          result = 255;
          break;
        case 42:
          result = 32;
          break;
        case 43:
          result = 2048;
          break;
        case 44:
          result = 0x7FFF;
          break;
        case 45:
          result = 2048;
          break;
        case 46:
          result = 200809;
          break;
        case 47:
          result = 200809;
          break;
        case 48:
          result = 200809;
          break;
        case 51:
          result = 200809;
          break;
        case 52:
          result = 200809;
          break;
        case 60:
          result = 1024;
          break;
        case 67:
          result = 200809;
          break;
        case 68:
          result = 200809;
          break;
        case 69:
          result = 1024;
          break;
        case 70:
          result = 1024;
          break;
        case 71:
          result = 256;
          break;
        case 72:
          result = 32;
          break;
        case 73:
          result = 4;
          break;
        case 74:
          result = 1024;
          break;
        case 75:
          result = 0x4000;
          break;
        case 77:
          result = 200809;
          break;
        case 78:
          result = 200809;
          break;
        case 79:
          result = 200809;
          break;
        case 80:
          result = 200809;
          break;
        case 81:
          result = 200809;
          break;
        case 82:
          result = 200809;
          break;
        case 83:
          result = get_nprocs_conf();
          break;
        case 84:
          result = get_nprocs();
          break;
        case 85:
          result = get_phys_pages((int)a1);
          break;
        case 86:
          result = get_avphys_pages((int)a1);
          break;
        case 87:
          result = 0x7FFFFFFF;
          break;
        case 88:
          result = 0x2000;
          break;
        case 89:
          result = 700;
          break;
        case 90:
          result = 4;
          break;
        case 91:
          result = 1;
          break;
        case 92:
          result = 1;
          break;
        case 93:
          result = 1;
          break;
        case 94:
          result = 1;
          break;
        case 95:
          result = 200809;
          break;
        case 96:
          result = 200809;
          break;
        case 98:
          result = 1;
          break;
        case 99:
          result = 1;
          break;
        case 100:
          result = 1;
          break;
        case 101:
          result = 8;
          break;
        case 102:
          result = 127;
          break;
        case 103:
          result = -128;
          break;
        case 104:
          result = 0x7FFFFFFF;
          break;
        case 105:
          result = 0x80000000;
          break;
        case 106:
          result = 32;
          break;
        case 107:
          result = 32;
          break;
        case 108:
          result = 16;
          break;
        case 109:
          result = 20;
          break;
        case 110:
          result = 0x7FFF;
          break;
        case 111:
          result = 127;
          break;
        case 112:
          result = -128;
          break;
        case 113:
          result = 0x7FFF;
          break;
        case 114:
          result = -32768;
          break;
        case 115:
          result = 255;
          break;
        case 118:
          result = 0xFFFF;
          break;
        case 119:
          result = 4096;
          break;
        case 120:
          result = 2048;
          break;
        case 121:
          result = 0x7FFFFFFF;
          break;
        case 122:
          result = 0x7FFFFFFF;
          break;
        case 123:
          result = 0x7FFFFFFF;
          break;
        case 124:
          result = 0x7FFFFFFF;
          break;
        case 125:
          result = 1;
          break;
        case 126:
          result = 1;
          break;
        case 127:
        case 178:
        case 239:
          result = _sysconf_check_spec("LP64_OFF64");
          break;
        case 128:
        case 179:
        case 240:
          result = _sysconf_check_spec("LPBIG_OFFBIG");
          break;
        case 129:
          result = 1;
          break;
        case 130:
          result = 1;
          break;
        case 131:
          result = 1;
          break;
        case 132:
          result = 200809;
          break;
        case 133:
          result = 200809;
          break;
        case 137:
          result = 200809;
          break;
        case 153:
          result = 200809;
          break;
        case 154:
          result = 200809;
          break;
        case 155:
          result = 1;
          break;
        case 157:
          result = 1;
          break;
        case 159:
          result = 200809;
          break;
        case 164:
          result = 200809;
          break;
        case 176:
          result = 1;
          break;
        case 177:
          result = 1;
          break;
        case 180:
          result = 64;
          break;
        case 235:
          result = 200809;
          break;
        case 236:
          result = 200809;
          break;
        case 237:
          result = 1;
          break;
        case 238:
          result = 1;
          break;
        default:
          __writegsdword(0xFFFFFFE8, 0x16u);
          result = -1;
          break;
      }
      return result;
    }
  }
  v3 = dl_sysinfo(0);
  v4 = v3;
  if ( v3 > 0xFFFFF000 )
    v4 = _syscall_error(v3);
  if ( v4 == -1 )
    goto LABEL_24;
  v5 = v15;
  do
  {
    v6 = dl_sysinfo(v5);
    v7 = v6;
    if ( v6 > 0xFFFFF000 )
    {
      v13 = v5;
      v8 = _syscall_error(v6);
      v5 = v13;
      v7 = v8;
    }
  }
  while ( v7 == -1 && __readgsdword(0xFFFFFFE8) == 4 );
  dl_sysinfo(v5);
  if ( v7 <= 0 )
    goto LABEL_24;
  *((_BYTE *)v15 + v7) = 0;
  v12 = a1;
  result = strtol(a1, &v14, 10);
  a1 = v12;
  if ( v14 == v12 || *v14 && *v14 != 10 )
    goto LABEL_24;
  return result;
}
// 806D962: variable 'v5' is possibly undefined
// 806DA1F: variable 'a1' is possibly undefined
// 806F6E0: using guessed type int get_nprocs(void);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806E030) --------------------------------------------------------
unsigned int __fastcall sched_yield(int a1)
{
  unsigned int result; // eax

  result = dl_sysinfo(a1);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806E050) --------------------------------------------------------
int _get_child_max()
{
  bool v0; // zf
  int result; // eax
  int v2[5]; // [esp+10h] [ebp-14h] BYREF

  v0 = getrlimit(6, (int)v2) == 0;
  result = -1;
  if ( v0 )
    return v2[0];
  return result;
}
// 806E050: using guessed type int var_14[5];

//----- (0806E070) --------------------------------------------------------
unsigned int __cdecl _xstat64(int a1, int a2, int a3)
{
  unsigned int result; // eax

  result = dl_sysinfo(a3);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806E0A0) --------------------------------------------------------
unsigned int __cdecl _fxstat64(int a1, int a2, int a3)
{
  unsigned int result; // eax

  result = dl_sysinfo(a3);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806E0D0) --------------------------------------------------------
int __cdecl open(int a1, int a2, int a3)
{
  int result; // eax
  __int32 v4; // eax
  unsigned int v5; // [esp+0h] [ebp-4h] BYREF

  if ( !__readgsdword(0xCu) )
    return _open_nocancel(a1, a2, a3);
  v5 = _libc_enable_asynccancel();
  v4 = dl_sysinfo(a2);
  _libc_disable_asynccancel(_InterlockedExchange((volatile __int32 *)&v5, v4));
  result = v5;
  if ( v5 >= 0xFFFFF001 )
    return _syscall_error(v5);
  return result;
}
// 806E0DA: using guessed type _DWORD __cdecl _open_nocancel(_DWORD, _DWORD, _DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806E0DA) --------------------------------------------------------
unsigned int __cdecl _open_nocancel(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806E140) --------------------------------------------------------
int __cdecl read(int a1, int a2, int a3)
{
  int result; // eax
  __int32 v4; // eax
  unsigned int v5; // [esp+0h] [ebp-4h] BYREF

  if ( !__readgsdword(0xCu) )
    return _read_nocancel(a1, a2, a3);
  v5 = _libc_enable_asynccancel();
  v4 = dl_sysinfo(a2);
  _libc_disable_asynccancel(_InterlockedExchange((volatile __int32 *)&v5, v4));
  result = v5;
  if ( v5 >= 0xFFFFF001 )
    return _syscall_error(v5);
  return result;
}
// 806E14A: using guessed type _DWORD __cdecl _read_nocancel(_DWORD, _DWORD, _DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806E14A) --------------------------------------------------------
unsigned int __cdecl _read_nocancel(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806E1B0) --------------------------------------------------------
int __cdecl write(int a1, int a2, int a3)
{
  int result; // eax
  __int32 v4; // eax
  unsigned int v5; // [esp+0h] [ebp-4h] BYREF

  if ( !__readgsdword(0xCu) )
    return _write_nocancel(a1, a2, a3);
  v5 = _libc_enable_asynccancel();
  v4 = dl_sysinfo(a2);
  _libc_disable_asynccancel(_InterlockedExchange((volatile __int32 *)&v5, v4));
  result = v5;
  if ( v5 >= 0xFFFFF001 )
    return _syscall_error(v5);
  return result;
}
// 806E1BA: using guessed type _DWORD __cdecl _write_nocancel(_DWORD, _DWORD, _DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806E1BA) --------------------------------------------------------
unsigned int __cdecl _write_nocancel(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806E220) --------------------------------------------------------
unsigned int __cdecl _fcntl_nocancel(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806E260) --------------------------------------------------------
int __cdecl fcntl(int a1, int a2)
{
  unsigned int v2; // eax
  int v3; // ebx
  int v5; // esi
  unsigned int v6; // eax

  if ( (a2 == 7 || a2 == 14) && __readgsdword(0xCu) )
  {
    v5 = _libc_enable_asynccancel();
    v6 = dl_sysinfo(a2);
    v3 = v6;
    if ( v6 > 0xFFFFF000 )
      v3 = _syscall_error(v6);
    _libc_disable_asynccancel(v5);
  }
  else
  {
    v2 = dl_sysinfo(a2);
    v3 = v2;
    if ( v2 > 0xFFFFF000 )
      return _syscall_error(v2);
  }
  return v3;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806E300) --------------------------------------------------------
_BYTE *__cdecl getcwd(_BYTE *a1, unsigned int a2)
{
  int v2; // esi
  int v3; // eax
  int v4; // ecx
  _BYTE *v5; // ebp
  int v7; // eax
  _BYTE *v8; // ebx
  int v9; // ecx
  int v10; // edi
  __m128i v11; // xmm1
  __m128i v12; // xmm1
  int *v13; // esi
  unsigned int v14; // eax
  int v15; // ebx
  char v16; // di
  __m128i v17; // xmm2
  int v18; // ebp
  int v19; // eax
  __m128i v20; // xmm0
  unsigned int v21; // kr04_4
  unsigned int v22; // ebp
  unsigned int v23; // eax
  int v24; // edi
  int v25; // eax
  _BYTE *v26; // edx
  _BYTE *v27; // ecx
  int v28; // eax
  _BYTE *v29; // edi
  __m128i v30; // xmm3
  __m128i v31; // xmm4
  __m128i v32; // xmm3
  unsigned int v33; // ebx
  __int64 v34; // rax
  _BYTE *v35; // eax
  _BYTE *v36; // [esp+0h] [ebp-ECh]
  int v37; // [esp+18h] [ebp-D4h]
  unsigned int v38; // [esp+18h] [ebp-D4h]
  int v39; // [esp+18h] [ebp-D4h]
  int v40; // [esp+18h] [ebp-D4h]
  int v41; // [esp+1Ch] [ebp-D0h]
  int v42; // [esp+1Ch] [ebp-D0h]
  _BYTE *v43; // [esp+1Ch] [ebp-D0h]
  __m128i v44; // [esp+20h] [ebp-CCh] BYREF
  char *v45; // [esp+30h] [ebp-BCh]
  bool v46; // [esp+36h] [ebp-B6h]
  char v47; // [esp+37h] [ebp-B5h]
  _BYTE *v48; // [esp+38h] [ebp-B4h]
  unsigned int v49; // [esp+3Ch] [ebp-B0h]
  __m128i v50; // [esp+40h] [ebp-ACh] BYREF
  __m128i v51; // [esp+50h] [ebp-9Ch] BYREF
  _BYTE *v52; // [esp+60h] [ebp-8Ch]
  _BYTE *v53; // [esp+64h] [ebp-88h]
  int v54; // [esp+68h] [ebp-84h]
  int v55; // [esp+6Ch] [ebp-80h]
  __m128i v56; // [esp+70h] [ebp-7Ch] BYREF
  int v57; // [esp+80h] [ebp-6Ch]
  __int64 v58; // [esp+C8h] [ebp-24h]

  v2 = (int)a1;
  if ( !a2 )
  {
    if ( a1 )
      goto LABEL_18;
    v3 = getpagesize();
    v4 = 4096;
    if ( v3 >= 4096 )
      v4 = v3;
    goto LABEL_5;
  }
  v4 = a2;
  if ( !a1 )
  {
LABEL_5:
    v37 = v4;
    v5 = (_BYTE *)malloc(v4);
    v4 = v37;
    if ( !v5 )
      return 0;
    goto LABEL_9;
  }
  v5 = a1;
LABEL_9:
  v7 = dl_sysinfo(v4);
  if ( (unsigned int)v7 > 0xFFFFF000 )
    v7 = _syscall_error(v7);
  if ( v7 >= 0 )
  {
    if ( !a1 && !a2 )
      v2 = realloc(v5, v7);
    if ( v2 )
      return (_BYTE *)v2;
    return v5;
  }
  v38 = __readgsdword(0xFFFFFFE8);
  if ( v38 != 36 )
  {
    if ( v38 == 34 && !a1 && !a2 )
      _assert_fail(
        "errno != ERANGE || buf != NULL || size != 0",
        "../sysdeps/unix/sysv/linux/getcwd.c",
        121,
        "__getcwd");
    if ( a1 )
      return 0;
    v36 = v5;
    v5 = 0;
    free(v36);
    return v5;
  }
  v46 = a1 == 0;
  if ( !a2 && !a1 )
  {
    free(v5);
    v38 = __readgsdword(0xFFFFFFE8);
    v5 = (_BYTE *)malloc(4097);
    if ( !v5 )
    {
      v48 = 0;
LABEL_82:
      if ( a2 && v46 )
        free(v48);
      return 0;
    }
    v49 = 4097;
    v48 = 0;
LABEL_27:
    v8 = &v5[v49];
    *(v8 - 1) = 0;
    v53 = v8 - 1;
    if ( (_lxstat64(3, (int)&unk_80BEE29, (int)&v56) & 0x80000000) != 0
      || (v10 = v58,
          v44.m128i_i64[0] = v56.m128i_i64[0],
          v41 = v58,
          (_lxstat64(3, (int)&unk_80CDC92, (int)&v56) & 0x80000000) != 0) )
    {
      v47 = 0;
    }
    else
    {
      v11 = _mm_load_si128(&v44);
      v50.m128i_i64[0] = v56.m128i_i64[0];
      v12 = _mm_xor_si128(v11, v50);
      v54 = v58;
      v47 = (v10 != (_DWORD)v58) | ((_mm_cvtsi128_si32(_mm_srli_epi64(v12, 0x20u)) | _mm_cvtsi128_si32(v12)) != 0);
      if ( !v47 )
      {
LABEL_58:
        if ( v53 == &v5[v49 - 1] )
        {
          v35 = v53;
          *(v53 - 1) = 47;
          v53 = v35 - 1;
        }
        v33 = v8 - v53;
        j_memmove(v5, v53, v33);
        if ( !a2 )
          v48 = (_BYTE *)realloc(v5, v33);
        if ( v48 )
          v5 = v48;
        __writegsdword(0xFFFFFFE8, v38);
        return v5;
      }
      v13 = 0;
      v52 = v5;
      while ( 2 )
      {
        v14 = dl_sysinfo(&unk_80BEE28);
        v15 = v14;
        if ( v14 > 0xFFFFF000 )
          v15 = _syscall_error(v14);
        if ( v15 < 0 )
        {
          v5 = v52;
          HIDWORD(v34) = __readgsdword(0xFFFFFFE8);
          if ( !v13 )
            goto LABEL_79;
LABEL_75:
          v47 = 0;
LABEL_76:
          v39 = HIDWORD(v34);
          closedir((int)v13);
          HIDWORD(v34) = v39;
          goto LABEL_77;
        }
        if ( (_fxstat64(3, v15, (int)&v56) & 0x80000000) != 0 )
        {
          v5 = v52;
          HIDWORD(v34) = __readgsdword(0xFFFFFFE8);
          if ( !v13 )
            goto LABEL_78;
          goto LABEL_76;
        }
        if ( !v13 || !closedir((int)v13) )
        {
          v51.m128i_i64[0] = v56.m128i_i64[0];
          v55 = v58;
          v13 = fdopendir(v15);
          if ( v13 )
          {
            v16 = v47;
            v17 = _mm_xor_si128(_mm_load_si128(&v51), v44);
            v18 = _mm_cvtsi128_si32(_mm_srli_epi64(v17, 0x20u)) | _mm_cvtsi128_si32(v17);
            while ( 1 )
            {
              while ( 1 )
              {
                do
                {
                  while ( 1 )
                  {
                    __writegsdword(0xFFFFFFE8, 0);
                    v19 = readdir((int)v13);
                    if ( v19 )
                      break;
                    HIDWORD(v34) = __readgsdword(0xFFFFFFE8);
                    if ( HIDWORD(v34) )
                    {
                      v5 = v52;
                      goto LABEL_75;
                    }
                    if ( !v16 )
                    {
                      v5 = v52;
                      HIDWORD(v34) = 2;
                      __writegsdword(0xFFFFFFE8, 2u);
                      goto LABEL_75;
                    }
                    v16 = 0;
                    rewinddir((int)v13);
                  }
                }
                while ( (*(_BYTE *)(v19 + 10) & 0xFB) != 0
                     || *(_BYTE *)(v19 + 11) == 46 && (!*(_BYTE *)(v19 + 12) || *(_WORD *)(v19 + 12) == 46) );
                if ( ((unsigned __int8)v16 & (v18 == 0)) == 0 || *(_DWORD *)v19 == v41 )
                  break;
                v16 &= v18 == 0;
              }
              v45 = (char *)(v19 + 11);
              if ( _fxstatat64(3, v15, v19 + 11) >= 0 && (v57 & 0xF000) == 0x4000 )
              {
                v20 = _mm_xor_si128(_mm_loadl_epi64(&v56), v44);
                if ( !(_mm_cvtsi128_si32(v20) | _mm_cvtsi128_si32(_mm_srli_epi64(v20, 0x20u))) && v58 == v41 )
                  break;
              }
            }
            v21 = strlen(v45) + 1;
            v22 = v21 - 1;
            v42 = v53 - v52;
            if ( v21 - 1 < v53 - v52 )
              goto LABEL_55;
            if ( a2 )
            {
              v5 = v52;
              HIDWORD(v34) = 34;
              __writegsdword(0xFFFFFFE8, 0x22u);
            }
            else
            {
              v23 = v49;
              if ( v49 < v22 )
                v23 = v21 - 1;
              v24 = 2 * v23;
              v25 = realloc(v52, 2 * v23);
              v26 = (_BYTE *)v25;
              if ( v25 )
              {
                v27 = (_BYTE *)(&v52[v49] - v53);
                v44.m128i_i32[0] = v25 + v24 - (_DWORD)v27;
                v28 = v42;
                v43 = v26;
                v53 = memcpy(&v26[v24 - (_DWORD)v27], &v26[v28], (unsigned int)v27);
                v49 = v24;
                v52 = v43;
LABEL_55:
                v29 = &v53[-v22];
                v41 = v55;
                memcpy(&v53[-v22], v45, v22);
                v30 = _mm_load_si128(&v50);
                *(v29 - 1) = 47;
                v31 = _mm_loadl_epi64(&v51);
                v53 = v29 - 1;
                v32 = _mm_xor_si128(v30, v31);
                v44 = v31;
                if ( (v54 != v41) | ((_mm_cvtsi128_si32(_mm_srli_epi64(v32, 0x20u)) | _mm_cvtsi128_si32(v32)) != 0) )
                  continue;
                v5 = v52;
                if ( !closedir((int)v13) )
                {
                  v8 = &v5[v49];
                  goto LABEL_58;
                }
                v47 = 0;
                goto LABEL_88;
              }
              v5 = v52;
              HIDWORD(v34) = __readgsdword(0xFFFFFFE8);
            }
            goto LABEL_75;
          }
        }
        break;
      }
      v5 = v52;
    }
LABEL_88:
    HIDWORD(v34) = __readgsdword(0xFFFFFFE8);
LABEL_77:
    if ( !v47 )
    {
LABEL_79:
      if ( !v48 )
      {
        v40 = HIDWORD(v34);
        free(v5);
        HIDWORD(v34) = v40;
      }
      __writegsdword(0xFFFFFFE8, HIDWORD(v34));
      goto LABEL_82;
    }
LABEL_78:
    v34 = dl_sysinfo(v9);
    goto LABEL_79;
  }
  if ( a2 )
  {
    v48 = v5;
    v49 = a2;
    goto LABEL_27;
  }
LABEL_18:
  __writegsdword(0xFFFFFFE8, 0x16u);
  return 0;
}
// 806E8D2: variable 'v9' is possibly undefined
// 80481D0: using guessed type int __cdecl j_memmove(_DWORD, _DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806EA50) --------------------------------------------------------
unsigned int __cdecl getrlimit(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806EA80) --------------------------------------------------------
int __cdecl sbrk(int a1)
{
  unsigned int v1; // ebx
  bool v2; // al
  int v4; // eax

  v1 = _curbrk;
  if ( !_curbrk || _libc_multiple_libcs )
  {
    v4 = brk(0);
    v1 = _curbrk;
    if ( v4 < 0 )
      return -1;
  }
  if ( !a1 )
    return v1;
  if ( a1 <= 0 )
    v2 = v1 < -a1;
  else
    v2 = __CFADD__(a1, v1);
  if ( v2 )
  {
    __writegsdword(0xFFFFFFE8, 0xCu);
    return -1;
  }
  if ( brk(v1 + a1) < 0 )
    return -1;
  return v1;
}
// 80EBD10: using guessed type int _libc_multiple_libcs;
// 80EC788: using guessed type int _curbrk;

//----- (0806EB20) --------------------------------------------------------
int getpagesize()
{
  int result; // eax

  result = dl_pagesize;
  if ( !dl_pagesize )
    _assert_fail("GLRO(dl_pagesize) != 0", "../sysdeps/unix/sysv/linux/getpagesize.c", 28, "__getpagesize");
  return result;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EBA08: using guessed type int dl_pagesize;

//----- (0806EB50) --------------------------------------------------------
int getdtablesize()
{
  bool v0; // sf
  int result; // eax
  int v2[5]; // [esp+10h] [ebp-14h] BYREF

  v0 = (getrlimit(7, (int)v2) & 0x80000000) != 0;
  result = 256;
  if ( !v0 )
    return v2[0];
  return result;
}
// 806EB50: using guessed type int var_14[5];

//----- (0806EB70) --------------------------------------------------------
unsigned int __cdecl mmap(int a1, int a2, int a3, int a4, int a5, __int16 a6)
{
  unsigned int result; // eax

  if ( (a6 & 0xFFF) != 0 )
  {
    result = -22;
    return _syscall_error(result);
  }
  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type int (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806EBC0) --------------------------------------------------------
unsigned int __cdecl mmap64(int a1, int a2, int a3, int a4, int a5, __int64 a6)
{
  unsigned int result; // eax

  if ( (a6 & 0xFFF) != 0 )
  {
    result = -22;
    return _syscall_error(result);
  }
  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806EC50) --------------------------------------------------------
unsigned int __cdecl munmap(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806EC80) --------------------------------------------------------
unsigned int __cdecl mprotect(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806ECB0) --------------------------------------------------------
unsigned int __cdecl madvise(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806ECE0) --------------------------------------------------------
int __usercall trecurse@<eax>(int a1@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3@<ecx>)
{
  if ( !*(_DWORD *)(a1 + 4) && !*(_DWORD *)(a1 + 8) )
    return a2(a1, 3, a3);
  a2(a1, 0, a3);
  if ( *(_DWORD *)(a1 + 4) )
    trecurse(a3 + 1, a2);
  a2(a1, 1, a3);
  if ( *(_DWORD *)(a1 + 8) )
    trecurse(a3 + 1, a2);
  return a2(a1, 2, a3);
}

//----- (0806ED60) --------------------------------------------------------
_DWORD *__usercall tdestroy_recurse@<eax>(_DWORD *a1@<eax>, long double (__cdecl *a2)(_DWORD)@<edx>, int a3@<ecx>)
{
  long double v5; // fst7

  if ( a1[1] )
    ((void (*)(void))tdestroy_recurse)();
  if ( a1[2] )
    tdestroy_recurse(a3, a2);
  v5 = a2(*a1);
  return free(v5, (int)a1);
}
// 806ED7E: variable 'a3' is possibly undefined

//----- (0806EDA0) --------------------------------------------------------
int __usercall maybe_split_for_insert_isra_0@<eax>(
        int result@<eax>,
        int *a2@<edx>,
        int *a3@<ecx>,
        int a4,
        int a5,
        int a6)
{
  int v6; // ebx
  int v7; // esi
  int v8; // ebx
  int v9; // edx
  int v10; // esi
  char v11; // [esp+7h] [ebp-11h]

  if ( a6 == 1 )
  {
    v6 = *(_DWORD *)(result + 8);
    *(_BYTE *)(result + 12) |= 1u;
    if ( !v6 )
      goto LABEL_8;
  }
  else
  {
    v6 = *(_DWORD *)(result + 8);
    if ( !v6 )
      return result;
    v7 = *(_DWORD *)(result + 4);
    if ( !v7 || (*(_BYTE *)(v6 + 12) & 1) == 0 || (*(_BYTE *)(v7 + 12) & 1) == 0 )
      return result;
    *(_BYTE *)(result + 12) |= 1u;
  }
  *(_BYTE *)(v6 + 12) &= ~1u;
LABEL_8:
  v8 = *(_DWORD *)(result + 4);
  if ( v8 )
    *(_BYTE *)(v8 + 12) &= ~1u;
  if ( a2 )
  {
    v9 = *a2;
    v11 = *(_BYTE *)(v9 + 12);
    if ( (v11 & 1) != 0 )
    {
      v10 = *a3;
      if ( a4 > 0 == a5 > 0 )
      {
        *a3 = v9;
        *(_BYTE *)(v9 + 12) &= ~1u;
        *(_BYTE *)(v10 + 12) |= 1u;
        if ( a4 < 0 )
        {
          result = *(_DWORD *)(v9 + 8);
          *(_DWORD *)(v10 + 4) = result;
          *(_DWORD *)(v9 + 8) = v10;
        }
        else
        {
          result = *(_DWORD *)(v9 + 4);
          *(_DWORD *)(v10 + 8) = result;
          *(_DWORD *)(v9 + 4) = v10;
        }
      }
      else
      {
        *(_BYTE *)(v9 + 12) = v11 | 1;
        *(_BYTE *)(v10 + 12) |= 1u;
        *(_BYTE *)(result + 12) &= ~1u;
        if ( a4 < 0 )
        {
          *(_DWORD *)(v9 + 4) = *(_DWORD *)(result + 8);
          *(_DWORD *)(result + 8) = v9;
          *(_DWORD *)(v10 + 8) = *(_DWORD *)(result + 4);
          *(_DWORD *)(result + 4) = v10;
        }
        else
        {
          *(_DWORD *)(v9 + 8) = *(_DWORD *)(result + 4);
          *(_DWORD *)(result + 4) = v9;
          *(_DWORD *)(v10 + 4) = *(_DWORD *)(result + 8);
          *(_DWORD *)(result + 8) = v10;
        }
        *a3 = result;
      }
    }
  }
  return result;
}

//----- (0806EED0) --------------------------------------------------------
int __cdecl tsearch(int a1, int *a2, int (__cdecl *a3)(int, _DWORD))
{
  int *v3; // esi
  int v4; // edx
  int v5; // ebp
  int *v6; // ecx
  int *v7; // eax
  int v8; // ebx
  int v9; // edi
  int result; // eax
  int *v11; // [esp+4h] [ebp-28h]
  int *v12; // [esp+8h] [ebp-24h]
  int *v13; // [esp+8h] [ebp-24h]
  int v14; // [esp+Ch] [ebp-20h]

  v3 = a2;
  if ( !a2 )
    return 0;
  if ( *a2 )
  {
    *(_BYTE *)(*a2 + 12) &= ~1u;
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v11 = 0;
    while ( 1 )
    {
      v8 = *v3;
      if ( !*v3 )
        break;
      v14 = v4;
      v12 = v6;
      v9 = a3(a1, *(_DWORD *)v8);
      if ( !v9 )
        return v8;
      maybe_split_for_insert_isra_0(*v3, v11, v12, v5, v14, 0);
      if ( v9 >= 0 )
      {
        v7 = (int *)(v8 + 8);
        v6 = v11;
        v4 = v5;
        if ( !*(_DWORD *)(v8 + 8) )
          goto LABEL_10;
      }
      else
      {
        v7 = (int *)(v8 + 4);
        v6 = v11;
        v4 = v5;
        if ( !*(_DWORD *)(v8 + 4) )
        {
LABEL_10:
          v13 = v7;
          v8 = malloc(16);
          if ( !v8 )
            return 0;
          *v13 = v8;
          *(_BYTE *)(v8 + 12) |= 1u;
          *(_DWORD *)v8 = a1;
          *(_DWORD *)(v8 + 8) = 0;
          *(_DWORD *)(v8 + 4) = 0;
          if ( v3 != v13 )
          {
            maybe_split_for_insert_isra_0(*v13, v3, v11, v9, v5, 1);
            return v8;
          }
          return v8;
        }
      }
      v11 = v3;
      v5 = v9;
      v3 = v7;
    }
  }
  result = malloc(16);
  if ( result )
  {
    *v3 = result;
    *(_BYTE *)(result + 12) |= 1u;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 4) = 0;
    *(_DWORD *)result = a1;
  }
  return result;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);

//----- (0806F030) --------------------------------------------------------
_DWORD *__cdecl tfind(int a1, _DWORD *a2, int (__cdecl *a3)(int, _DWORD))
{
  _DWORD *v3; // ebx
  int v4; // eax
  _DWORD *v5; // edx
  _DWORD *v6; // ebx

  v3 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      v6 = (_DWORD *)*v3;
      if ( !v6 )
        break;
      v4 = a3(a1, *v6);
      if ( !v4 )
        return v6;
      v5 = v6 + 1;
      v3 = v6 + 2;
      if ( v4 < 0 )
        v3 = v5;
    }
  }
  return 0;
}

//----- (0806F080) --------------------------------------------------------
_BYTE *__usercall tdelete@<eax>(long double a1@<st0>, int a2, int *a3, int (__cdecl *a4)(int, _DWORD))
{
  int *v4; // esi
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  int v7; // ebx
  _DWORD *v8; // edi
  int v9; // eax
  int v10; // edx
  int v11; // edi
  void *v13; // esp
  _DWORD *v14; // eax
  _BYTE *v15; // ecx
  int v16; // edi
  int v17; // edx
  unsigned int v18; // edi
  int v19; // ecx
  int v20; // edx
  int v21; // esi
  int v22; // edx
  void *v23; // esp
  _DWORD *v24; // eax
  int v25; // eax
  int v26; // ebx
  int v27; // edi
  int v28; // esi
  _BYTE *v29; // ecx
  int v30; // edx
  int v31; // eax
  char v32; // bl
  int v33; // esi
  int v34; // edi
  _DWORD *v35; // eax
  int v36; // ebx
  int v37; // ebx
  char v38; // al
  _BYTE *v39; // eax
  int v40; // eax
  int v41; // esi
  int v42; // edi
  _DWORD *v43; // edi
  _DWORD *v44; // eax
  int v45; // eax
  _BYTE v46[184]; // [esp+0h] [ebp-E8h] BYREF
  _BYTE *v47; // [esp+B8h] [ebp-30h]
  int v48; // [esp+BCh] [ebp-2Ch]
  _DWORD *v49; // [esp+C0h] [ebp-28h]
  _DWORD *v50; // [esp+C4h] [ebp-24h]
  int v51; // [esp+C8h] [ebp-20h]
  _BYTE *v52; // [esp+CCh] [ebp-1Ch]

  v4 = a3;
  v52 = v46;
  if ( !a3 )
    return 0;
  v5 = (_DWORD *)*a3;
  if ( !*a3 )
    return 0;
  v6 = (_DWORD *)*a3;
  v7 = 0;
  v51 = 40;
  v8 = v5;
  while ( 1 )
  {
    v9 = a4(a2, *v6);
    v10 = v9;
    if ( !v9 )
      break;
    if ( v51 == v7 )
    {
      v51 += 20;
      v11 = 4 * v7;
      v50 = (_DWORD *)v9;
      v13 = alloca(4 * v51 + 15);
      v52 = memcpy(v46, v52, 4 * v7);
      v10 = (int)v50;
    }
    else
    {
      v11 = 4 * v7;
    }
    ++v7;
    *(_DWORD *)&v52[v11] = v4;
    v8 = (_DWORD *)*v4;
    if ( v10 >= 0 )
    {
      v4 = v8 + 2;
      if ( !v8[2] )
        return 0;
    }
    else
    {
      v4 = v8 + 1;
      if ( !v8[1] )
        return 0;
    }
    v6 = (_DWORD *)*v4;
  }
  v14 = (_DWORD *)*v4;
  v15 = v8;
  v16 = *(_DWORD *)(*v4 + 4);
  v17 = *(_DWORD *)(*v4 + 8);
  v49 = (_DWORD *)*v4;
  v50 = (_DWORD *)v17;
  if ( v16 && v17 )
  {
    v47 = v15;
    v18 = 4 * v7;
    v19 = (int)(v14 + 2);
    v20 = (int)v4;
    v21 = (int)v50;
    while ( 1 )
    {
      if ( v51 == v7 )
      {
        v51 += 20;
        v48 = v20;
        v50 = (_DWORD *)v19;
        v23 = alloca(4 * v51 + 15);
        v52 = memcpy(v46, v52, v18);
        v20 = v48;
        v19 = (int)v50;
      }
      ++v7;
      *(_DWORD *)&v52[v18] = v20;
      v18 += 4;
      if ( !*(_DWORD *)(v21 + 4) )
        break;
      v22 = v21 + 4;
      v21 = *(_DWORD *)(v21 + 4);
      v50 = (_DWORD *)v22;
      v20 = v19;
      v19 = (int)v50;
    }
    v15 = v47;
    v16 = *(_DWORD *)(v21 + 8);
    v50 = (_DWORD *)v21;
  }
  else
  {
    if ( !v16 )
      v16 = (int)v50;
    if ( !v7 )
    {
      v24 = v49;
      *v4 = v16;
      v50 = v24;
      goto LABEL_24;
    }
    v50 = v49;
  }
  v45 = **(_DWORD **)&v52[4 * v7 - 4];
  if ( *(_DWORD **)(v45 + 8) == v50 )
    *(_DWORD *)(v45 + 8) = v16;
  else
    *(_DWORD *)(v45 + 4) = v16;
LABEL_24:
  if ( v49 != v50 )
    *v49 = *v50;
  if ( (v50[3] & 1) != 0 )
    goto LABEL_39;
  if ( !v7 )
  {
    if ( !v16 )
      goto LABEL_39;
LABEL_47:
    *(_BYTE *)(v16 + 12) &= ~1u;
    goto LABEL_39;
  }
  v25 = v7;
  v51 = (int)v15;
  v26 = v16;
  v27 = v25;
  while ( 1 )
  {
    if ( v26 && (*(_BYTE *)(v26 + 12) & 1) != 0 )
    {
LABEL_46:
      v15 = (_BYTE *)v51;
      v16 = v26;
      goto LABEL_47;
    }
    v28 = 4 * (v27 + 0x3FFFFFFF);
    v29 = *(_BYTE **)&v52[v28];
    v30 = *(_DWORD *)v29;
    v31 = *(_DWORD *)(*(_DWORD *)v29 + 4);
    if ( v26 == v31 )
      break;
    v32 = *(_BYTE *)(v31 + 12);
    if ( (v32 & 1) != 0 )
    {
      ++v27;
      *(_BYTE *)(v31 + 12) = v32 & 0xFE;
      *(_BYTE *)(v30 + 12) |= 1u;
      *(_DWORD *)(v30 + 4) = *(_DWORD *)(v31 + 8);
      *(_DWORD *)(v31 + 8) = v30;
      *(_DWORD *)v29 = v31;
      v29 = (_BYTE *)(v31 + 8);
      *(_DWORD *)&v52[v28 + 4] = v31 + 8;
      v31 = *(_DWORD *)(v30 + 4);
    }
    v33 = *(_DWORD *)(v31 + 8);
    if ( v33 && (*(_BYTE *)(v33 + 12) & 1) != 0 )
    {
      v34 = *(_DWORD *)(v31 + 4);
      v52 = v29;
      v15 = (_BYTE *)v51;
      if ( !v34 || (*(_BYTE *)(v34 + 12) & 1) == 0 )
      {
        *(_BYTE *)(v33 + 12) = *(_BYTE *)(v30 + 12) & 1 | *(_BYTE *)(v33 + 12) & 0xFE;
        *(_DWORD *)(v30 + 4) = *(_DWORD *)(v33 + 8);
        *(_DWORD *)(v31 + 8) = *(_DWORD *)(v33 + 4);
        *(_DWORD *)(v33 + 4) = v31;
        v35 = v52;
        *(_DWORD *)(v33 + 8) = v30;
        *v35 = v33;
        *(_BYTE *)(v30 + 12) &= ~1u;
        goto LABEL_39;
      }
      goto LABEL_43;
    }
    v36 = *(_DWORD *)(v31 + 4);
    if ( v36 && (*(_BYTE *)(v36 + 12) & 1) != 0 )
    {
      v52 = v29;
      v15 = (_BYTE *)v51;
      v34 = v36;
LABEL_43:
      LOBYTE(v51) = *(_BYTE *)(v30 + 12) & 1;
      *(_BYTE *)(v31 + 12) = v51 | *(_BYTE *)(v31 + 12) & 0xFE;
      *(_BYTE *)(v30 + 12) &= ~1u;
      *(_BYTE *)(v34 + 12) &= ~1u;
      *(_DWORD *)(v30 + 4) = v33;
      *(_DWORD *)(v31 + 8) = v30;
      *(_DWORD *)v52 = v31;
      goto LABEL_39;
    }
    *(_BYTE *)(v31 + 12) |= 1u;
LABEL_45:
    --v27;
    v26 = v30;
    if ( !v27 )
      goto LABEL_46;
  }
  v37 = *(_DWORD *)(v30 + 8);
  v38 = *(_BYTE *)(v37 + 12);
  if ( (v38 & 1) != 0 )
  {
    ++v27;
    *(_BYTE *)(v37 + 12) = v38 & 0xFE;
    *(_BYTE *)(v30 + 12) |= 1u;
    *(_DWORD *)(v30 + 8) = *(_DWORD *)(v37 + 4);
    v39 = v52;
    *(_DWORD *)(v37 + 4) = v30;
    *(_DWORD *)v29 = v37;
    v29 = (_BYTE *)(v37 + 4);
    v37 = *(_DWORD *)(v30 + 8);
    *(_DWORD *)&v39[v28 + 4] = v29;
  }
  v40 = *(_DWORD *)(v37 + 4);
  if ( !v40 || (*(_BYTE *)(v40 + 12) & 1) == 0 )
  {
    v41 = *(_DWORD *)(v37 + 8);
    if ( v41 && (*(_BYTE *)(v41 + 12) & 1) != 0 )
    {
      v52 = v29;
      v15 = (_BYTE *)v51;
      v42 = v37;
      goto LABEL_58;
    }
    *(_BYTE *)(v37 + 12) |= 1u;
    goto LABEL_45;
  }
  v41 = *(_DWORD *)(v37 + 8);
  v52 = v29;
  v42 = v37;
  v15 = (_BYTE *)v51;
  if ( !v41 || (*(_BYTE *)(v41 + 12) & 1) == 0 )
  {
    *(_BYTE *)(v40 + 12) = *(_BYTE *)(v30 + 12) & 1 | *(_BYTE *)(v40 + 12) & 0xFE;
    *(_DWORD *)(v30 + 8) = *(_DWORD *)(v40 + 4);
    *(_DWORD *)(v37 + 4) = *(_DWORD *)(v40 + 8);
    *(_DWORD *)(v40 + 8) = v37;
    v43 = v52;
    *(_DWORD *)(v40 + 4) = v30;
    *v43 = v40;
    *(_BYTE *)(v30 + 12) &= ~1u;
    goto LABEL_39;
  }
LABEL_58:
  LOBYTE(v51) = *(_BYTE *)(v30 + 12) & 1;
  *(_BYTE *)(v42 + 12) = v51 | *(_BYTE *)(v42 + 12) & 0xFE;
  *(_BYTE *)(v30 + 12) &= ~1u;
  *(_BYTE *)(v41 + 12) &= ~1u;
  *(_DWORD *)(v30 + 8) = v40;
  v44 = v52;
  *(_DWORD *)(v42 + 4) = v30;
  *v44 = v42;
LABEL_39:
  v52 = v15;
  free(a1, (int)v50);
  return v52;
}

//----- (0806F490) --------------------------------------------------------
int __cdecl twalk(int a1, int (__cdecl *a2)(int, int, int))
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    if ( a2 )
      return trecurse(a1, a2, 0);
  }
  return result;
}

//----- (0806F4C0) --------------------------------------------------------
_DWORD *__cdecl tdestroy(_DWORD *a1, long double (__cdecl *a2)(_DWORD))
{
  int v2; // ecx
  _DWORD *result; // eax

  result = a1;
  if ( a1 )
    return tdestroy_recurse(a1, a2, v2);
  return result;
}
// 806F4CC: variable 'v2' is possibly undefined

//----- (0806F4E0) --------------------------------------------------------
unsigned int __usercall next_line@<eax>(
        unsigned int a1@<edx>,
        unsigned int *a2@<ecx>,
        long double a3@<st0>,
        int *a4,
        int a5)
{
  unsigned int v6; // ebp
  int v7; // esi
  int v8; // ebx
  int v9; // eax
  unsigned int v10; // eax
  int v12; // eax
  int v13; // eax
  unsigned int v14; // ebx
  int v15; // ebp
  _BYTE *v16; // ebx
  unsigned int v17; // eax
  int v18; // esi
  int v20; // [esp+Ch] [ebp-24h]

  v6 = *a2;
  v7 = *a4;
  v8 = *a4 - *a2;
  v9 = j_memchr(v6, 10, *a4 - v6);
  if ( !v9 )
  {
    if ( v6 != a1 && v7 == a5 )
    {
      j_memmove(a1, v6, v8);
      *a4 = a1 + *a4 - *a2;
      *a2 = a1;
      v12 = dl_sysinfo(*a4);
      if ( (unsigned int)v12 > 0xFFFFF000 )
        v12 = _syscall_error(v12);
      if ( v12 < 0 )
        return 0;
      v13 = *a4 + v12;
      *a4 = v13;
      v6 = *a2;
      v20 = v13;
      v14 = v6;
      v9 = j_memchr(v6, 10, v13 - v6);
      if ( v9 )
      {
LABEL_21:
        v6 = v14;
        goto LABEL_2;
      }
      if ( v7 == v20 )
      {
        v15 = a1 + (int)(3 * (v20 - a1)) / 4;
        while ( 1 )
        {
          *a4 = v15;
          v17 = dl_sysinfo(v15);
          v18 = v17;
          if ( v17 > 0xFFFFF000 )
            v18 = _syscall_error(v17);
          if ( v18 < 0 )
            return 0;
          v16 = (_BYTE *)*a4;
          v9 = j_memchr(*a4, 10, v18);
          *v16 = 10;
          v7 = *a4 + v18;
          *a4 = v7;
          if ( v9 )
          {
            v14 = *a2;
            goto LABEL_21;
          }
          if ( v20 != v7 )
          {
            v6 = *a2;
            goto LABEL_7;
          }
        }
      }
      v7 = v20;
    }
LABEL_7:
    v9 = v7 - 1;
  }
LABEL_2:
  v10 = v9 + 1;
  *a2 = v10;
  if ( v10 > *a4 )
    _assert_fail(a3, (int)"*cp <= *re", (int)"../sysdeps/unix/sysv/linux/getsysstats.c", 119, "next_line");
  if ( v6 == *a4 )
    return 0;
  return v6;
}
// 80481D0: using guessed type int __cdecl j_memmove(_DWORD, _DWORD, _DWORD);
// 8048220: using guessed type int __cdecl j_memchr(_DWORD, _DWORD, _DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806F690) --------------------------------------------------------
unsigned int __usercall sysinfo_mempages@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  unsigned int v4; // ecx
  unsigned int result; // eax

  v4 = getpagesize();
  if ( v4 > 1 && a2 > 1 )
  {
    do
    {
      a2 >>= 1;
      v4 >>= 1;
    }
    while ( a2 > 1 && v4 > 1 );
  }
  result = a2 * a1;
  if ( v4 > 1 )
  {
    do
    {
      v4 >>= 1;
      result >>= 1;
    }
    while ( v4 != 1 );
  }
  return result;
}

//----- (0806F6E0) --------------------------------------------------------
int __usercall get_nprocs@<eax>(int a1@<ecx>, long double a2@<st0>)
{
  unsigned int v2; // eax
  void *v3; // esp
  int *v4; // eax
  unsigned int line; // eax
  char *v6; // ecx
  char *i; // edi
  int v8; // eax
  char *v9; // edx
  int v10; // ebx
  unsigned int v11; // ebx
  char *v12; // edi
  unsigned int v13; // eax
  int v14; // ebx
  unsigned int *v15; // ebx
  char *v16; // edi
  int v17; // ecx
  _BYTE *v18; // esi
  bool v19; // zf
  unsigned int v20; // eax
  unsigned int v22; // eax
  int v23; // ebx
  const void *v24; // eax
  _BYTE v25[8]; // [esp+Ch] [ebp-48h] BYREF
  int v26; // [esp+14h] [ebp-40h]
  int v27; // [esp+18h] [ebp-3Ch]
  int *v28; // [esp+1Ch] [ebp-38h]
  _BYTE *v29; // [esp+20h] [ebp-34h]
  _BYTE *v30; // [esp+24h] [ebp-30h]
  int v31; // [esp+28h] [ebp-2Ch]
  _BYTE *v32; // [esp+30h] [ebp-24h] BYREF
  char *v33; // [esp+34h] [ebp-20h] BYREF
  char *v34[7]; // [esp+38h] [ebp-1Ch] BYREF

  v26 = time(a1);
  if ( v26 != timestamp_10204 || (v31 = cached_result_10203, cached_result_10203 < 0) )
  {
    v2 = !_libc_alloca_cutoff(0x2000u) ? 0xFFFFE200 : 0;
    v3 = alloca(v2 + 8208);
    v29 = v25;
    v30 = &v25[v2 + 0x2000];
    v32 = v30;
    v33 = v30;
    v4 = (int *)dl_sysinfo(0x80000);
    v28 = v4;
    if ( (unsigned int)v4 > 0xFFFFF000 )
      v28 = (int *)_syscall_error((int)v4);
    if ( v28 != (int *)-1 )
    {
      line = next_line((unsigned int)v29, (unsigned int *)&v32, a2, (int *)&v33, (int)v30);
      v31 = 0;
      if ( line )
      {
        for ( i = (char *)line; ; i = v9 )
        {
          v8 = strtoul(i, v34, 10);
          v9 = v34[0];
          v10 = v8;
          if ( i == v34[0] )
            break;
          if ( *v34[0] == 45 )
          {
            v12 = v34[0] + 1;
            v8 = strtoul(v34[0] + 1, v34, 10);
            v9 = v34[0];
            if ( v12 == v34[0] )
              break;
          }
          v6 = v33;
          v31 = v8 + v31 - v10 + 1;
          if ( v33 <= v9 )
            goto LABEL_16;
          v11 = __readgsdword(0xFFFFFFF8);
          while ( (*(_BYTE *)(v11 + 2 * *v9 + 1) & 0x20) != 0 )
          {
            if ( v33 == ++v9 )
              goto LABEL_16;
          }
        }
        v31 = 0;
      }
LABEL_16:
      dl_sysinfo(v6);
      if ( v31 > 0 )
        goto LABEL_28;
    }
    v32 = v30;
    v33 = v30;
    v13 = dl_sysinfo(0x80000);
    v14 = v13;
    if ( v13 > 0xFFFFF000 )
      v14 = _syscall_error(v13);
    if ( v14 == -1 )
    {
      v22 = dl_sysinfo(0x80000);
      v23 = v22;
      if ( v22 > 0xFFFFF000 )
        v23 = _syscall_error(v22);
      v31 = 1;
      if ( v23 == -1 )
        goto LABEL_28;
      v27 = v23;
      v15 = 0;
      v31 = (int)&v32;
      v28 = (int *)&v33;
      while ( 1 )
      {
        v24 = (const void *)next_line((unsigned int)v29, (unsigned int *)v31, a2, v28, (int)v30);
        if ( !v24 )
          break;
        v15 = (unsigned int *)((char *)v15 + (memcmp(v24, "processor", 9u) == 0));
      }
    }
    else
    {
      v27 = v14;
      v15 = 0;
      v31 = (int)&v32;
      v28 = (int *)&v33;
      while ( 1 )
      {
        v20 = next_line((unsigned int)v29, (unsigned int *)v31, a2, v28, (int)v30);
        v19 = v20 == 0;
        if ( !v20 )
          break;
        v16 = "cpu";
        v17 = 3;
        v18 = (_BYTE *)v20;
        do
        {
          if ( !v17 )
            break;
          v19 = *v18++ == (unsigned __int8)*v16++;
          --v17;
        }
        while ( v19 );
        if ( !v19 )
          break;
        v15 = (unsigned int *)((char *)v15 + ((unsigned int)(*(char *)(v20 + 3) - 48) < 0xA));
      }
    }
    v31 = (int)v15;
    dl_sysinfo(v17);
LABEL_28:
    cached_result_10203 = v31;
    timestamp_10204 = v26;
    return v31;
  }
  return v31;
}
// 806F828: variable 'v6' is possibly undefined
// 806F8CE: variable 'v17' is possibly undefined
// 80EB998: using guessed type int cached_result_10203;
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EC528: using guessed type int timestamp_10204;

//----- (0806F9C0) --------------------------------------------------------
int get_nprocs_conf()
{
  int *v0; // eax
  int v1; // ebx
  int v2; // ebp
  _BYTE *v3; // eax
  char *v4; // esi
  char *v6; // [esp+18h] [ebp-20h] BYREF

  v0 = opendir("/sys/devices/system/cpu");
  if ( !v0 )
    return get_nprocs();
  v1 = (int)v0;
  v2 = 0;
  while ( 1 )
  {
    v3 = (_BYTE *)readdir64(v1);
    if ( !v3 )
      break;
    while ( v3[18] == 4 )
    {
      if ( memcmp(v3 + 19, "cpu", 3u) )
        break;
      v4 = v3 + 22;
      if ( strtoul(v3 + 22, &v6, 10) == -1 || v4 == v6 )
        break;
      v2 += *v6 == 0;
      v3 = (_BYTE *)readdir64(v1);
      if ( !v3 )
        goto LABEL_9;
    }
  }
LABEL_9:
  closedir(v1);
  return v2;
}
// 806F6E0: using guessed type int get_nprocs(void);

//----- (0806FA60) --------------------------------------------------------
unsigned int __fastcall get_phys_pages(int a1)
{
  int v2; // [esp+1Ch] [ebp-3Ch]
  unsigned int v3; // [esp+40h] [ebp-18h]

  sysinfo(a1);
  return sysinfo_mempages(v2, v3);
}
// 806FA78: variable 'v2' is possibly undefined
// 806FA78: variable 'v3' is possibly undefined

//----- (0806FA80) --------------------------------------------------------
unsigned int __fastcall get_avphys_pages(int a1)
{
  int v2; // [esp+20h] [ebp-38h]
  unsigned int v3; // [esp+40h] [ebp-18h]

  sysinfo(a1);
  return sysinfo_mempages(v2, v3);
}
// 806FA98: variable 'v2' is possibly undefined
// 806FA98: variable 'v3' is possibly undefined

//----- (0806FAA0) --------------------------------------------------------
int _getclktck()
{
  int result; // eax

  result = dl_clktck;
  if ( !dl_clktck )
    return 100;
  return result;
}
// 80ECC9C: using guessed type int dl_clktck;

//----- (0806FAB0) --------------------------------------------------------
void __cdecl _init_misc(int a1, void **a2)
{
  void *v2; // esi
  int v3; // eax

  if ( a2 )
  {
    v2 = *a2;
    if ( *a2 )
    {
      v3 = j_strrchr(v2, 47);
      if ( v3 )
        v2 = (void *)(v3 + 1);
      program_invocation_short_name = v2;
      program_invocation_name = *a2;
    }
  }
}
// 8048200: using guessed type int __cdecl j_strrchr(_DWORD, _DWORD);
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80EB9A0: using guessed type void *program_invocation_name;

//----- (0806FAF0) --------------------------------------------------------
__int64 __cdecl lseek64(int a1, int a2, int a3)
{
  __int64 result; // rax
  __int64 v4; // [esp+8h] [ebp-14h]

  LODWORD(result) = dl_sysinfo(a3);
  if ( (unsigned int)result > 0xFFFFF000 )
    LODWORD(result) = _syscall_error(result);
  result = (int)result;
  if ( !(_DWORD)result )
    return v4;
  return result;
}
// 806FB21: variable 'v4' is possibly undefined
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806FB40) --------------------------------------------------------
unsigned int __cdecl mremap(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806FB80) --------------------------------------------------------
unsigned int __fastcall sysinfo(int a1)
{
  unsigned int result; // eax

  result = dl_sysinfo(a1);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806FBA0) --------------------------------------------------------
_BOOL4 __cdecl _libc_alloca_cutoff(unsigned int a1)
{
  unsigned int v1; // edx

  v1 = 0x10000;
  if ( (__readgsdword(0x274u) >> 2) - 1 <= 0xFFFF )
  {
    v1 = __readgsdword(0x274u) >> 2;
    if ( !v1 )
      v1 = 0x40000;
  }
  return v1 >= a1;
}

//----- (0806FBE0) --------------------------------------------------------
__int32 __usercall _lll_lock_wait_private@<eax>(int a1@<eax>, volatile __int32 *a2@<ecx>)
{
  __int32 v2; // edx
  int v4; // ecx
  __int32 result; // eax

  v2 = 2;
  v4 = 128;
  if ( a1 != 2 )
    goto LABEL_3;
  do
  {
    dl_sysinfo(v4);
LABEL_3:
    result = _InterlockedExchange(a2, v2);
  }
  while ( result );
  return result;
}
// 80EB9F0: invalid function type '?' has been ignored
// 806FBFA: variable 'v4' is possibly undefined
// 806FC02: variable 'v2' is possibly undefined
// 80EB9F0: using guessed type int (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806FC10) --------------------------------------------------------
int __usercall _lll_unlock_wake_private@<eax>(_DWORD *a1@<eax>)
{
  *a1 = 0;
  return dl_sysinfo(129);
}
// 80EB9F0: using guessed type int (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806FC40) --------------------------------------------------------
int _libc_enable_asynccancel()
{
  signed __int32 i; // edx
  signed __int32 v1; // eax

  for ( i = __readgsdword(0x84u); ; i = v1 )
  {
    if ( i == (i | 2) )
      return i;
    v1 = _InterlockedCompareExchange(MK_FP(__GS__, 132), i | 2, i);
    if ( i == v1 )
      break;
  }
  if ( (i & 0xFFFFFFB9 | 2) != 10 )
    return i;
  __writegsdword(0x228u, 0xFFFFFFFF);
  _InterlockedOr(MK_FP(__GS__, 132), 0x10u);
  MEMORY[0]();
  return _libc_disable_asynccancel();
}
// 806FCA0: using guessed type int _libc_disable_asynccancel(void);

//----- (0806FCA0) --------------------------------------------------------
unsigned int __usercall _libc_disable_asynccancel@<eax>(unsigned int result@<eax>)
{
  signed __int32 i; // ecx
  unsigned int v2; // eax

  if ( (result & 2) == 0 )
  {
    for ( i = __readgsdword(0x84u); ; i = result )
    {
      result = _InterlockedCompareExchange(MK_FP(__GS__, 132), i & 0xFFFFFFFD, i);
      if ( i == result )
        break;
    }
    if ( (i & 0xC) == 4 )
    {
      do
      {
        v2 = dl_sysinfo(128);
        if ( v2 > 0xFFFFF000 && (v2 < 0xFFFFFFF5 && v2 != 0 || ((1 << (v2 + 11)) & 0x881) == 0) )
          _libc_fatal("The futex facility returned an unexpected error code.");
        result = __readgsdword(0x84u) & 0xC;
      }
      while ( result == 4 );
    }
  }
  return result;
}
// 80515F0: using guessed type void __cdecl __noreturn _libc_fatal(_DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0806FD50) --------------------------------------------------------
int __cdecl backtrace_helper(int a1, _DWORD *a2)
{
  int v2; // eax
  int *v3; // edi
  int v4; // edx
  bool v5; // zf
  int result; // eax

  v2 = a2[1];
  if ( v2 != -1 )
  {
    v3 = (int *)(*a2 + 4 * v2);
    *v3 = Unwind_GetIP(a1);
    v2 = a2[1];
  }
  v4 = v2 + 1;
  v5 = v2 + 1 == a2[2];
  result = 5;
  a2[1] = v4;
  if ( !v5 )
  {
    a2[3] = Unwind_GetGR(a1, 5);
    a2[4] = Unwind_GetCFA(a1);
    return 0;
  }
  return result;
}

//----- (0806FDC0) --------------------------------------------------------
int __usercall backtrace@<eax>(long double a1@<st0>, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // edx
  int v5; // ecx
  unsigned int v6; // [esp+Ch] [ebp-3Ch]
  int v7; // [esp+1Ch] [ebp-2Ch] BYREF
  int v8; // [esp+20h] [ebp-28h]
  int v9; // [esp+24h] [ebp-24h]
  unsigned int v10; // [esp+28h] [ebp-20h]
  unsigned int v11; // [esp+2Ch] [ebp-1Ch]

  v10 = 0;
  v11 = 0;
  v8 = -1;
  v7 = a2;
  v9 = a3;
  if ( a3 <= 0 )
    return 0;
  Unwind_Backtrace(a1, (int (__cdecl *)(_DWORD *, int))backtrace_helper, (int)&v7);
  result = v8;
  if ( v8 > 1 && !*(_DWORD *)(v7 + 4 * v8 - 4) )
    return v8 - 1;
  if ( a3 > v8 )
  {
    v4 = v10;
    if ( v10 >= v11 && v10 <= _libc_stack_end && (v10 & 3) == 0 )
    {
      v5 = v8 + 1;
      v6 = v11;
      do
      {
        result = v5;
        *(_DWORD *)(a2 + 4 * v5 - 4) = *(_DWORD *)(v4 + 4);
        v4 = *(_DWORD *)v4;
        if ( a3 == v5 )
          break;
        if ( v4 < v6 )
          break;
        if ( _libc_stack_end < v4 )
          break;
        ++v5;
      }
      while ( (v4 & 3) == 0 );
    }
    if ( result == -1 )
      return 0;
  }
  return result;
}
// 80EAFC8: using guessed type int _libc_stack_end;

//----- (0806FE90) --------------------------------------------------------
int __cdecl backtrace_symbols_fd(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // ebp
  int v5; // edi
  int v6; // esi
  int v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // eax
  char *v10; // eax
  int v11; // edx
  char *v12; // eax
  int v13; // eax
  unsigned int v14; // [esp-10h] [ebp-BCh]
  int v15; // [esp+8h] [ebp-A4h]
  int v16; // [esp+Ch] [ebp-A0h]
  int v17; // [esp+Ch] [ebp-A0h]
  unsigned int v18; // [esp+10h] [ebp-9Ch]
  int v19; // [esp+10h] [ebp-9Ch]
  int v20; // [esp+18h] [ebp-94h]
  int v21; // [esp+1Ch] [ebp-90h]
  int *v22; // [esp+24h] [ebp-88h] BYREF
  char v23[8]; // [esp+30h] [ebp-7Ch] BYREF
  char v24[8]; // [esp+38h] [ebp-74h] BYREF
  _BYTE *v25; // [esp+40h] [ebp-6Ch]
  int v26; // [esp+44h] [ebp-68h]
  _BYTE *v27; // [esp+48h] [ebp-64h] BYREF
  int v28; // [esp+4Ch] [ebp-60h]
  const char *v29; // [esp+50h] [ebp-5Ch]
  int v30; // [esp+54h] [ebp-58h]
  _BYTE *v31; // [esp+58h] [ebp-54h]
  int v32; // [esp+5Ch] [ebp-50h]

  result = a2;
  if ( a2 > 0 )
  {
    v4 = 0;
    do
    {
      if ( dl_addr(*(_DWORD *)(a1 + 4 * v4), v24, &v22, 0) && *(_DWORD *)v24 && **(_BYTE **)v24 )
      {
        v27 = *(_BYTE **)v24;
        v28 = strlen(*(_BYTE **)v24);
        if ( v25 )
        {
          v29 = "(";
          v30 = 1;
          v31 = v25;
          v5 = 7;
          v6 = 6;
          v32 = strlen(v25);
          v15 = 9;
          v7 = 8;
          v21 = 5;
          v20 = 4;
          v16 = 3;
          v18 = v26;
LABEL_7:
          v8 = *(_DWORD *)(a1 + 4 * v4);
          if ( v8 < v18 )
          {
            (&v27)[2 * v16] = "-0x";
            v9 = v18 - v8;
          }
          else
          {
            (&v27)[2 * v16] = "+0x";
            v9 = v8 - v18;
          }
          v19 = v7;
          *(&v28 + 2 * v16) = 3;
          v10 = itoa_word(v9, v24, 0x10u, 0);
          (&v27)[2 * v20] = v10;
          *(&v28 + 2 * v20) = v24 - v10;
          (&v27)[2 * v21] = ")";
          *(&v28 + 2 * v21) = 1;
          v11 = v19;
          goto LABEL_10;
        }
        v13 = *v22;
        if ( *v22 )
        {
          v29 = "(";
          v30 = 1;
          v7 = 7;
          v18 = v13;
          v26 = v13;
          v5 = 6;
          v15 = 8;
          v6 = 5;
          v21 = 4;
          v20 = 3;
          v16 = 2;
          goto LABEL_7;
        }
        v15 = 4;
        v11 = 3;
        v5 = 2;
        v6 = 1;
      }
      else
      {
        v15 = 3;
        v11 = 2;
        v5 = 1;
        v6 = 0;
      }
LABEL_10:
      v17 = v11;
      (&v27)[2 * v6] = "[0x";
      *(&v28 + 2 * v6) = 3;
      v14 = *(_DWORD *)(a1 + 4 * v4++);
      v12 = itoa_word(v14, v23, 0x10u, 0);
      (&v27)[2 * v5] = v12;
      *(&v28 + 2 * v5) = v23 - v12;
      (&v27)[2 * v17] = "]\n";
      *(&v28 + 2 * v17) = 2;
      result = writev(a3, (int)&v27, v15);
    }
    while ( a2 != v4 );
  }
  return result;
}
// 806FE90: using guessed type char var_74[8];

//----- (08070120) --------------------------------------------------------
void __usercall __noreturn _chk_fail(long double a1@<st0>)
{
  _fortify_fail("buffer overflow detected", a1);
}

//----- (08070130) --------------------------------------------------------
void __usercall __noreturn _fortify_fail(const char *a1@<eax>, long double a2@<st0>)
{
  const char *v3; // eax

  while ( 1 )
  {
    v3 = *(const char **)_libc_argv;
    if ( !*(_DWORD *)_libc_argv )
      v3 = "<unknown>";
    _libc_message(a2, 2, (unsigned int *)"*** %s ***: %s terminated\n", a1, v3);
  }
}
// 80ECCD0: using guessed type int _libc_argv;

//----- (08070170) --------------------------------------------------------
_DWORD *__usercall dl_debug_initialize@<eax>(int a1@<eax>, int a2@<edx>)
{
  _DWORD *v2; // ecx
  int v3; // eax

  v2 = &r_debug;
  if ( a2 )
    v2 = (_DWORD *)(76 * a2 + 135182968);
  if ( !v2[1] )
  {
    *v2 = 1;
    if ( !a1 )
      a1 = dword_80ECC54;
    goto LABEL_6;
  }
  if ( a1 )
  {
    *v2 = 1;
LABEL_6:
    v2[4] = a1;
    v3 = (int)*(&dl_ns + 19 * a2);
    v2[2] = dl_debug_state;
    v2[1] = v3;
  }
  return v2;
}
// 8070160: using guessed type int dl_debug_state();
// 80EBA40: using guessed type void *dl_ns;
// 80ECC54: using guessed type int dword_80ECC54;

//----- (080701D0) --------------------------------------------------------
void dl_sysinfo_int80()
{
  __asm { int     80h; LINUX - }
}

//----- (080701E0) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __usercall dl_aux_init@<eax>(int result@<eax>)
{
  int v1; // edx
  int v2; // ecx
  int v3; // esi
  int v4; // [esp+0h] [ebp-60h]
  int v5; // [esp+4h] [ebp-5Ch]
  int v6; // [esp+8h] [ebp-58h]
  int v7; // [esp+Ch] [ebp-54h]
  unsigned __int8 v8; // [esp+11h] [ebp-4Fh]
  char v9; // [esp+12h] [ebp-4Eh]
  char v10; // [esp+13h] [ebp-4Dh]
  int v11; // [esp+14h] [ebp-4Ch]
  int v12; // [esp+18h] [ebp-48h]
  __int64 v13; // [esp+1Ch] [ebp-44h]
  __int64 v14; // [esp+24h] [ebp-3Ch]
  char v15; // [esp+2Ch] [ebp-34h]
  char v16; // [esp+2Dh] [ebp-33h]
  char v17; // [esp+2Eh] [ebp-32h]
  char v18; // [esp+2Fh] [ebp-31h]
  int (*v19)(); // [esp+30h] [ebp-30h]
  unsigned __int16 v20; // [esp+34h] [ebp-2Ch]
  char v21; // [esp+36h] [ebp-2Ah]
  char v22; // [esp+37h] [ebp-29h]
  int v23; // [esp+38h] [ebp-28h]
  int v24; // [esp+3Ch] [ebp-24h]
  int v25; // [esp+40h] [ebp-20h]
  char v26; // [esp+44h] [ebp-1Ch]
  char v27; // [esp+45h] [ebp-1Bh]
  char v28; // [esp+46h] [ebp-1Ah]
  char v29; // [esp+47h] [ebp-19h]
  int v30; // [esp+48h] [ebp-18h]

  v1 = *(_DWORD *)result;
  dl_auxv = result;
  if ( v1 )
  {
    v23 = dl_sysinfo_dso;
    v19 = dl_sysinfo[0];
    v24 = _libc_enable_secure;
    v14 = dl_hwcap2;
    v25 = _libc_enable_secure_decided;
    v6 = dl_clktck;
    v20 = dl_fpu_control;
    v30 = dl_pagesize;
    v2 = 0;
    v12 = dl_platform;
    v3 = 0;
    v11 = dl_phnum;
    v13 = dl_hwcap;
    v29 = 0;
    v28 = 0;
    v27 = 0;
    v26 = 0;
    v22 = 0;
    v7 = dl_phdr;
    v21 = 0;
    v4 = 0;
    v18 = 0;
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v10 = 0;
    v9 = 0;
    v8 = 0;
    v5 = dl_random;
    do
    {
      switch ( v1 )
      {
        case 3:
          v10 = 1;
          v7 = *(_DWORD *)(result + 4);
          break;
        case 5:
          v15 = 1;
          v11 = *(_DWORD *)(result + 4);
          break;
        case 6:
          if ( *(_DWORD *)(result + 4) )
          {
            v30 = *(_DWORD *)(result + 4);
            v8 = 1;
          }
          break;
        case 11:
          v3 ^= *(_DWORD *)(result + 4);
          v2 |= 1u;
          break;
        case 12:
          v3 ^= *(_DWORD *)(result + 4);
          v2 |= 2u;
          break;
        case 13:
          v2 |= 4u;
          v4 ^= *(_DWORD *)(result + 4);
          break;
        case 14:
          v2 |= 8u;
          v4 ^= *(_DWORD *)(result + 4);
          break;
        case 15:
          v16 = 1;
          v12 = *(_DWORD *)(result + 4);
          break;
        case 16:
          v17 = 1;
          v13 = *(unsigned int *)(result + 4);
          break;
        case 17:
          v9 = 1;
          v6 = *(_DWORD *)(result + 4);
          break;
        case 18:
          v21 = 1;
          v20 = *(_WORD *)(result + 4);
          break;
        case 23:
          v28 = 1;
          v25 = 1;
          v27 = 1;
          v24 = *(_DWORD *)(result + 4);
          v2 = -1;
          break;
        case 25:
          v29 = 1;
          v5 = *(_DWORD *)(result + 4);
          break;
        case 26:
          v18 = 1;
          v14 = *(unsigned int *)(result + 4);
          break;
        case 32:
          v22 = 1;
          v19 = *(int (**)())(result + 4);
          break;
        case 33:
          v26 = 1;
          v23 = *(_DWORD *)(result + 4);
          break;
        default:
          break;
      }
      result += 8;
      v1 = *(_DWORD *)result;
    }
    while ( *(_DWORD *)result );
    result = v8;
    if ( v8 )
    {
      result = v30;
      dl_pagesize = v30;
    }
    if ( v9 )
    {
      result = v6;
      dl_clktck = v6;
    }
    if ( v10 )
    {
      result = v7;
      dl_phdr = v7;
    }
    if ( v15 )
    {
      result = v11;
      dl_phnum = v11;
    }
    if ( v16 )
    {
      result = v12;
      dl_platform = v12;
    }
    if ( v17 )
      dl_hwcap = v13;
    if ( v18 )
      dl_hwcap2 = v14;
    if ( v21 )
    {
      result = v20;
      dl_fpu_control = v20;
    }
    if ( v22 )
    {
      result = (int)v19;
      dl_sysinfo[0] = v19;
    }
    if ( v26 )
    {
      result = v23;
      dl_sysinfo_dso = v23;
    }
    if ( v27 )
    {
      result = v24;
      _libc_enable_secure = v24;
    }
    if ( v28 )
    {
      result = v25;
      _libc_enable_secure_decided = v25;
    }
    if ( v29 )
      dl_random = v5;
    if ( v2 == 15 )
    {
      _libc_enable_secure_decided = 1;
      result = v4 != 0 || v3 != 0;
      _libc_enable_secure = (unsigned __int8)result;
    }
  }
  return result;
}
// 80703C7: write access to const memory at 80EAFCC has been detected
// 80703E3: write access to const memory at 80EAFC0 has been detected
// 8070407: write access to const memory at 80EAFCC has been detected
// 80EAFC0: using guessed type int dl_random;
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80EB9F0: using guessed type int (*dl_sysinfo[2])();
// 80EB9FC: using guessed type __int16 dl_fpu_control;
// 80EBA08: using guessed type int dl_pagesize;
// 80EC548: using guessed type __int64 dl_hwcap2;
// 80EC550: using guessed type __int64 dl_hwcap;
// 80ECC7C: using guessed type int dl_auxv;
// 80ECC80: using guessed type int dl_platform;
// 80ECC90: using guessed type int dl_phdr;
// 80ECC9C: using guessed type int dl_clktck;
// 80ECCA4: using guessed type int dl_sysinfo_dso;
// 80ECCB0: using guessed type int dl_phnum;
// 80ECCC8: using guessed type int _libc_enable_secure_decided;

//----- (080705A0) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __usercall dl_non_dynamic_init@<eax>(long double a1@<st0>)
{
  _BYTE *v1; // eax
  int v2; // ebx
  int v3; // ecx
  int v4; // esi
  int v5; // edi
  int v6; // eax
  int v7; // edx
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  unsigned int *v11; // edx
  unsigned int v12; // eax
  int v13; // edi
  unsigned int v14; // esi
  int *v15; // eax
  int v16; // edi
  int v17; // edx
  int v18; // eax
  int *v19; // edx
  int *v20; // esi
  int *v21; // edx
  int *v22; // esi
  int *v23; // edx
  int *v24; // esi
  int *v25; // edx
  int *v26; // esi
  int *v27; // edx
  int *v28; // esi
  int *v29; // edx
  int *v30; // esi
  int *v31; // edx
  int *v32; // esi
  int *v33; // edx
  int *v34; // esi
  int v35; // eax
  int v36; // eax
  int v37; // edx
  int v38; // eax
  int v39; // eax
  bool v40; // zf
  int v41; // eax
  _DWORD *v42; // eax
  int v43; // eax
  _BYTE *v44; // esi
  unsigned int v45; // edi
  _BYTE *v46; // eax
  _DWORD *v47; // ebp
  _BYTE *v48; // eax
  _BYTE *v49; // eax
  _BYTE *v50; // eax
  _BYTE *v51; // eax
  _BYTE *v52; // eax
  _BYTE *v53; // eax
  int v54; // eax
  const char *v55; // edx
  unsigned __int8 *v56; // ebx
  char *v57; // ebx
  int v58; // ebp
  int i; // esi
  unsigned int v60; // eax
  int result; // eax
  int v62; // ecx
  int v63; // edx
  int v64; // edx
  unsigned int v65; // edx
  char v66; // bl
  char *v67; // [esp+1Ch] [ebp-20h] BYREF

  dword_80EBC48 = dl_get_origin();
  dword_80EBBF0 = dl_phdr;
  word_80EBBF8 = dl_phnum;
  dl_cpuclock_offset = __rdtsc();
  v1 = (_BYTE *)getenv("LD_WARN");
  if ( !v1 )
    v1 = byte_80CFAB1;
  dl_verbose = *v1 != 0;
  if ( dl_sysinfo_dso )
  {
    v2 = dl_new_object(byte_80CFAB1, byte_80CFAB1, 1, 0, 0, 0);
    if ( v2 )
    {
      v3 = dl_sysinfo_dso;
      v4 = 0;
      v5 = *(unsigned __int16 *)(dl_sysinfo_dso + 44);
      v6 = dl_sysinfo_dso + *(_DWORD *)(dl_sysinfo_dso + 28);
      *(_DWORD *)(v2 + 336) = v6;
      *(_WORD *)(v2 + 344) = v5;
      if ( v5 )
      {
        do
        {
          while ( 1 )
          {
            v7 = *(_DWORD *)v6;
            if ( *(_DWORD *)v6 != 2 )
              break;
            v8 = *(_DWORD *)(v6 + 8);
            ++v4;
            v6 += 32;
            *(_DWORD *)(v2 + 8) = v8;
            *(_WORD *)(v2 + 346) = *(_DWORD *)(v6 - 12) >> 3;
            if ( v4 == v5 )
              goto LABEL_12;
          }
          if ( v7 == 1 )
          {
            v64 = *(_DWORD *)(v6 + 8);
            if ( !*(_DWORD *)v2 )
              *(_DWORD *)v2 = v64;
            v65 = *(_DWORD *)(v6 + 20) + v64;
            if ( v65 >= *(_DWORD *)(v2 + 432) )
              *(_DWORD *)(v2 + 432) = v65;
            if ( (*(_BYTE *)(v6 + 24) & 1) != 0 && v65 >= *(_DWORD *)(v2 + 436) )
              *(_DWORD *)(v2 + 436) = v65;
          }
          else if ( v7 == 7 )
          {
            _assert_fail(a1, (int)"ph->p_type != PT_TLS", (int)"setup-vdso.h", 61, "setup_vdso");
          }
          ++v4;
          v6 += 32;
        }
        while ( v4 != v5 );
      }
LABEL_12:
      *(_DWORD *)(v2 + 428) = v3;
      v9 = v3 - *(_DWORD *)v2;
      v10 = *(_DWORD *)(v2 + 8);
      *(_DWORD *)(v2 + 432) += v9;
      *(_DWORD *)(v2 + 436) += v9;
      v11 = (unsigned int *)(v9 + v10);
      *(_DWORD *)v2 = v9;
      *(_DWORD *)(v2 + 8) = v11;
      if ( !v11 )
        goto LABEL_61;
      v12 = *v11;
      v13 = v2 + 32;
      if ( !*v11 )
      {
LABEL_22:
        if ( v9 )
        {
          v15 = *(int **)(v2 + 48);
          if ( v15 )
          {
            v16 = v15[1];
            v17 = *v15;
            v18 = 1;
            *(_DWORD *)(v2 + 48) = dyn_temp_9507;
            dyn_temp_9507[0] = v17;
            dword_80EAF84 = v9 + v16;
          }
          else
          {
            v18 = 0;
          }
          v19 = *(int **)(v2 + 44);
          if ( v19 )
          {
            v20 = &dyn_temp_9507[2 * v18];
            *v20 = *v19;
            ++v18;
            v20[1] = v9 + v19[1];
            *(_DWORD *)(v2 + 44) = v20;
          }
          v21 = *(int **)(v2 + 52);
          if ( v21 )
          {
            v22 = &dyn_temp_9507[2 * v18];
            *v22 = *v21;
            ++v18;
            v22[1] = v9 + v21[1];
            *(_DWORD *)(v2 + 52) = v22;
          }
          v23 = *(int **)(v2 + 56);
          if ( v23 )
          {
            v24 = &dyn_temp_9507[2 * v18];
            *v24 = *v23;
            ++v18;
            v24[1] = v9 + v23[1];
            *(_DWORD *)(v2 + 56) = v24;
          }
          v25 = *(int **)(v2 + 60);
          if ( v25 )
          {
            v26 = &dyn_temp_9507[2 * v18];
            *v26 = *v25;
            ++v18;
            v26[1] = v9 + v25[1];
            *(_DWORD *)(v2 + 60) = v26;
          }
          v27 = *(int **)(v2 + 100);
          if ( v27 )
          {
            v28 = &dyn_temp_9507[2 * v18];
            *v28 = *v27;
            ++v18;
            v28[1] = v9 + v27[1];
            *(_DWORD *)(v2 + 100) = v28;
          }
          v29 = *(int **)(v2 + 124);
          if ( v29 )
          {
            v30 = &dyn_temp_9507[2 * v18];
            *v30 = *v29;
            ++v18;
            v30[1] = v9 + v29[1];
            *(_DWORD *)(v2 + 124) = v30;
          }
          v31 = *(int **)(v2 + 228);
          if ( v31 )
          {
            v32 = &dyn_temp_9507[2 * v18];
            *v32 = *v31;
            ++v18;
            v32[1] = v9 + v31[1];
            *(_DWORD *)(v2 + 228) = v32;
          }
          v33 = *(int **)(v2 + 332);
          if ( v33 )
          {
            v34 = &dyn_temp_9507[2 * v18];
            *v34 = *v33;
            v34[1] = v33[1] + v9;
            *(_DWORD *)(v2 + 332) = v34;
            if ( v18 == 8 )
              _assert_fail(a1, (int)"cnt <= DL_RO_DYN_TEMP_CNT", (int)"get-dynamic-info.h", 113, "elf_get_dynamic_info");
          }
        }
        v35 = *(_DWORD *)(v2 + 112);
        if ( v35 )
        {
          v36 = *(_DWORD *)(v35 + 4);
          if ( v36 != 17 && v36 != 7 )
            _assert_fail(
              a1,
              (int)"info[DT_PLTREL]->d_un.d_val == DT_REL || info[DT_PLTREL]->d_un.d_val == DT_RELA",
              (int)"get-dynamic-info.h",
              124,
              "elf_get_dynamic_info");
        }
        if ( *(_DWORD *)(v2 + 60) && *(_DWORD *)(*(_DWORD *)(v2 + 68) + 4) != 12 )
          _assert_fail(
            a1,
            (int)"info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela))",
            (int)"get-dynamic-info.h",
            129,
            "elf_get_dynamic_info");
        if ( *(_DWORD *)(v2 + 100) && *(_DWORD *)(*(_DWORD *)(v2 + 108) + 4) != 8 )
          _assert_fail(
            a1,
            (int)"info[DT_RELENT]->d_un.d_val == sizeof (ElfW(Rel))",
            (int)"get-dynamic-info.h",
            133,
            "elf_get_dynamic_info");
        v37 = *(_DWORD *)(v2 + 152);
        if ( v37 )
        {
          v38 = *(_DWORD *)(v37 + 4);
          *(_DWORD *)(v2 + 520) = v38;
          if ( (v38 & 2) != 0 )
            *(_DWORD *)(v2 + 96) = v37;
          if ( (v38 & 4) != 0 )
            *(_DWORD *)(v2 + 120) = v37;
          if ( (v38 & 8) != 0 )
            *(_DWORD *)(v2 + 128) = v37;
        }
        v39 = *(_DWORD *)(v2 + 184);
        if ( v39 )
        {
          v40 = (dl_debug_mask & 0x40) == 0;
          v41 = *(_DWORD *)(v39 + 4);
          *(_DWORD *)(v2 + 516) = v41;
          if ( !v40 && (v41 & 0xFFFFF716) != 0 )
          {
            dl_debug_printf("\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\n", v41 & 0xFFFFF716);
            v41 = *(_DWORD *)(v2 + 516);
          }
          if ( (v41 & 1) != 0 )
            *(_DWORD *)(v2 + 128) = *(_DWORD *)(v2 + 184);
        }
        if ( *(_DWORD *)(v2 + 148) )
          *(_DWORD *)(v2 + 92) = 0;
LABEL_61:
        dl_setup_hash((_DWORD *)v2);
        v42 = *(_DWORD **)(v2 + 464);
        *(_BYTE *)(v2 + 404) |= 4u;
        *(_DWORD *)(v2 + 508) = 1;
        v42[1] = 1;
        *v42 = v2 + 20;
        v43 = *(_DWORD *)(v2 + 88);
        if ( v43 )
        {
          v44 = (_BYTE *)(*(_DWORD *)(*(_DWORD *)(v2 + 52) + 4) + *(_DWORD *)(v43 + 4));
          v45 = strlen(v44) + 1;
          v46 = (_BYTE *)malloc(a1, v45);
          if ( !v46 )
          {
            dl_dprintf(2, "out of memory\n");
            exit(127);
          }
          v47 = *(_DWORD **)(v2 + 28);
          v48 = memcpy(v46, v44, v45);
          *(_DWORD *)(v2 + 4) = v48;
          *v47 = v48;
        }
        dl_add_to_namespace_list(v2, 0);
        dl_nns = 1;
        dl_sysinfo_map = v2;
        if ( (char *)dl_sysinfo == (char *)dl_sysinfo_int80 )
          dl_sysinfo = (__int64 (__fastcall *)(_DWORD))(*(_DWORD *)(dl_sysinfo_dso + 24) + *(_DWORD *)v2);
        goto LABEL_66;
      }
      while ( 1 )
      {
        if ( v12 <= 0x21 )
          goto LABEL_16;
        if ( 1879048191 - v12 <= 0xF )
        {
          v12 = 1879048225 - v12;
LABEL_16:
          *(_DWORD *)(v13 + 4 * v12) = v11;
LABEL_17:
          v11 += 2;
          v12 = *v11;
          if ( !*v11 )
            goto LABEL_22;
        }
        else
        {
          v14 = (int)(2 * v12) >> 1;
          if ( v14 <= 0xFFFFFFFC )
          {
            if ( 1879047679 - v12 <= 0xB )
            {
              *(_DWORD *)(v13 - 4 * v12 - 1073743664) = v11;
            }
            else if ( 1879047935 - v12 <= 0xA )
            {
              *(_DWORD *)(v13 - 4 * v12 - 1073742592) = v11;
            }
            goto LABEL_17;
          }
          *(_DWORD *)(v13 + 4 * ~v14 + 200) = v11;
          v11 += 2;
          v12 = *v11;
          if ( !*v11 )
            goto LABEL_22;
        }
      }
    }
  }
LABEL_66:
  v49 = (_BYTE *)getenv("LD_LIBRARY_PATH");
  dl_init_paths(v49, a1);
  dl_init_all_dirs = dl_all_dirs;
  v50 = (_BYTE *)getenv("LD_BIND_NOW");
  if ( !v50 )
    v50 = byte_80CFAB1;
  dl_lazy = *v50 == 0;
  v51 = (_BYTE *)getenv("LD_BIND_NOT");
  if ( !v51 )
    v51 = byte_80CFAB1;
  dl_bind_not = *v51 != 0;
  v52 = (_BYTE *)getenv("LD_DYNAMIC_WEAK");
  if ( !v52 )
    v52 = byte_80CFAB1;
  dl_dynamic_weak = *v52 == 0;
  v53 = (_BYTE *)getenv("LD_PROFILE_OUTPUT");
  dl_profile_output = (int)v53;
  if ( v53 && *v53 )
  {
    v54 = _libc_enable_secure;
  }
  else
  {
    v54 = _libc_enable_secure;
    v55 = "/var/profile";
    if ( !_libc_enable_secure )
      v55 = "/var/tmp";
    dl_profile_output = (int)v55;
  }
  if ( v54 )
  {
    v56 = "GCONV_PATH";
    do
    {
      unsetenv(v56);
      v56 = (unsigned __int8 *)(j_rawmemchr(v56, 0) + 1);
    }
    while ( v56 < byte_80BF1CA );
    if ( access((int)"/etc/suid-debug", 0) )
      unsetenv(byte_80BF3A0);
  }
  if ( dl_platform && !*(_BYTE *)dl_platform )
    dl_platform = 0;
  v57 = (char *)getenv("LD_ASSUME_KERNEL");
  if ( v57 )
  {
    v58 = 0;
    for ( i = 0; ; ++i )
    {
      v60 = _strtoul_internal(v57, &v67, 0, 0);
      if ( v60 > 0xFE || v67 == v57 )
        break;
      if ( i == 2 )
      {
        v58 |= v60;
LABEL_91:
        if ( v58 )
          dl_osversion = v58;
        break;
      }
      v66 = *v67;
      if ( *v67 && v66 != 46 )
        break;
      v58 |= v60 << (-8 * i + 16);
      if ( !v66 )
        goto LABEL_91;
      v57 = v67 + 1;
    }
  }
  result = dl_platform;
  if ( dl_platform )
  {
    result = strlen((_BYTE *)dl_platform);
    dl_platformlen = result;
  }
  v62 = dl_phdr;
  if ( dl_phdr && dl_phnum )
  {
    v63 = 0;
    result = dl_phdr + 32;
    if ( *(_DWORD *)dl_phdr == 1685382481 )
    {
LABEL_118:
      result = *(_DWORD *)(v62 + 24);
      dl_stack_flags = result;
    }
    else
    {
      while ( ++v63 != dl_phnum )
      {
        v62 = result;
        result += 32;
        if ( *(_DWORD *)(result - 32) == 1685382481 )
          goto LABEL_118;
      }
    }
  }
  return result;
}
// 807073E: write access to const memory at 80EAF80 has been detected
// 8070744: write access to const memory at 80EAF84 has been detected
// 80481E0: using guessed type int __cdecl j_rawmemchr(_DWORD, _DWORD);
// 80BF1CA: using guessed type unsigned __int8 byte_80BF1CA[2];
// 80BF3A0: using guessed type unsigned __int8 byte_80BF3A0[7];
// 80CFAB1: using guessed type _BYTE byte_80CFAB1[1231];
// 80EAF80: using guessed type int dyn_temp_9507[];
// 80EAF84: using guessed type int dword_80EAF84;
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EB9F8: using guessed type int dl_stack_flags;
// 80EBA28: using guessed type int dl_nns;
// 80EBBF0: using guessed type int dword_80EBBF0;
// 80EBBF8: using guessed type __int16 word_80EBBF8;
// 80EBC48: using guessed type int dword_80EBC48;
// 80ECC58: using guessed type int dl_profile_output;
// 80ECC5C: using guessed type int dl_platformlen;
// 80ECC60: using guessed type int dl_debug_mask;
// 80ECC70: using guessed type __int64 dl_cpuclock_offset;
// 80ECC78: using guessed type int dl_bind_not;
// 80ECC80: using guessed type int dl_platform;
// 80ECC84: using guessed type int dl_lazy;
// 80ECC88: using guessed type int dl_sysinfo_map;
// 80ECC90: using guessed type int dl_phdr;
// 80ECCA0: using guessed type int dl_dynamic_weak;
// 80ECCA4: using guessed type int dl_sysinfo_dso;
// 80ECCA8: using guessed type int dl_init_all_dirs;
// 80ECCAC: using guessed type int dl_verbose;
// 80ECCB0: using guessed type int dl_phnum;
// 80ECCBC: using guessed type int dl_all_dirs;
// 80ECCC0: using guessed type int dl_osversion;

//----- (08070D90) --------------------------------------------------------
int __userpurge dl_addr@<eax>(unsigned int a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  _DWORD *dso_for_object; // eax
  _BYTE *v6; // edx
  int v7; // ecx
  unsigned int v8; // edx
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  unsigned int v12; // edx
  int v13; // ebx
  __int16 v14; // bx
  unsigned int v15; // esi
  _DWORD *v16; // eax
  int v17; // ebx
  int v19; // ecx
  unsigned int v20; // edi
  unsigned int v21; // ecx
  unsigned int v22; // ebx
  int v23; // esi
  _DWORD *v24; // ecx
  int *v25; // [esp+Ch] [ebp-40h]
  _DWORD *v26; // [esp+10h] [ebp-3Ch]
  _DWORD *v27; // [esp+14h] [ebp-38h]
  int *v28; // [esp+18h] [ebp-34h]
  unsigned int v29; // [esp+1Ch] [ebp-30h]
  unsigned int v30; // [esp+20h] [ebp-2Ch]
  int v33; // [esp+2Ch] [ebp-20h]

  dso_for_object = dl_find_dso_for_object(a1);
  if ( !dso_for_object )
    return 0;
  v6 = (_BYTE *)dso_for_object[1];
  v7 = dso_for_object[107];
  *a2 = v6;
  a2[1] = v7;
  if ( !*v6 && (dso_for_object[101] & 3) == 0 )
    *a2 = program_invocation_short_name;
  v29 = *(_DWORD *)(dso_for_object[14] + 4);
  v8 = v29;
  v33 = *(_DWORD *)(dso_for_object[13] + 4);
  v30 = *(_DWORD *)(dso_for_object[18] + 4);
  if ( !dso_for_object[83] )
  {
    v19 = dso_for_object[12];
    if ( v19 )
      v20 = v29 + 16 * *(_DWORD *)(*(_DWORD *)(v19 + 4) + 4);
    else
      v20 = *(_DWORD *)(dso_for_object[13] + 4);
    v27 = 0;
    if ( v29 >= v20 )
      goto LABEL_26;
    while ( 1 )
    {
      if ( (unsigned __int8)((*(_BYTE *)(v8 + 12) >> 4) - 1) > 1u
        || (*(_BYTE *)(v8 + 13) & 3u) - 1 <= 1
        || (*(_BYTE *)(v8 + 12) & 0xF) == 6 )
      {
        goto LABEL_38;
      }
      v21 = *(_DWORD *)(v8 + 4);
      if ( !*(_WORD *)(v8 + 14) )
        break;
      v22 = v21 + *dso_for_object;
      if ( a1 < v22 )
        goto LABEL_38;
      v23 = *(_DWORD *)(v8 + 8);
      if ( v23 )
        goto LABEL_47;
      if ( a1 == v22 )
      {
LABEL_48:
        if ( !v27 || v27[1] < v21 )
        {
          v24 = v27;
          if ( v30 > *(_DWORD *)v8 )
            v24 = (_DWORD *)v8;
          v27 = v24;
        }
      }
LABEL_38:
      v8 += 16;
      if ( v8 >= v20 )
        goto LABEL_26;
    }
    if ( !v21 )
      goto LABEL_38;
    v22 = v21 + *dso_for_object;
    if ( a1 < v22 )
      goto LABEL_38;
    if ( a1 == v22 )
      goto LABEL_48;
    v23 = *(_DWORD *)(v8 + 8);
LABEL_47:
    if ( a1 < v23 + v22 )
      goto LABEL_48;
    goto LABEL_38;
  }
  v9 = dso_for_object[94];
  if ( !v9 )
  {
    v27 = 0;
    goto LABEL_26;
  }
  v27 = 0;
  v25 = (int *)dso_for_object[98];
  v28 = &v25[v9];
  do
  {
    v10 = *v25;
    if ( !*v25 )
      goto LABEL_25;
    v26 = dso_for_object;
    v11 = dso_for_object[99] + 4 * v10;
    v12 = v29 + 16 * v10;
    do
    {
      while ( 1 )
      {
        v14 = *(_WORD *)(v12 + 14);
        if ( !v14 && !*(_DWORD *)(v12 + 4) )
          goto LABEL_10;
        if ( (*(_BYTE *)(v12 + 12) & 0xF) == 6 )
          goto LABEL_10;
        v15 = *v26 + *(_DWORD *)(v12 + 4);
        if ( a1 < v15 )
          goto LABEL_10;
        if ( v14 )
          break;
        if ( a1 == v15 )
          goto LABEL_19;
        v13 = *(_DWORD *)(v12 + 8);
LABEL_18:
        if ( a1 < v13 + v15 )
          goto LABEL_19;
LABEL_10:
        v11 += 4;
        v12 += 16;
        if ( (*(_BYTE *)(v11 - 4) & 1) != 0 )
          goto LABEL_24;
      }
      v13 = *(_DWORD *)(v12 + 8);
      if ( v13 )
        goto LABEL_18;
      if ( a1 != v15 )
        goto LABEL_10;
LABEL_19:
      if ( v27 && *(_DWORD *)(v12 + 4) <= v27[1] )
        goto LABEL_10;
      v16 = v27;
      if ( v30 > *(_DWORD *)v12 )
        v16 = (_DWORD *)v12;
      v11 += 4;
      v12 += 16;
      v27 = v16;
    }
    while ( (*(_BYTE *)(v11 - 4) & 1) == 0 );
LABEL_24:
    dso_for_object = v26;
LABEL_25:
    ++v25;
  }
  while ( v25 != v28 );
LABEL_26:
  if ( a3 )
    *a3 = dso_for_object;
  if ( a4 )
    *a4 = v27;
  v17 = 1;
  if ( v27 )
  {
    a2[2] = *v27 + v33;
    a2[3] = *dso_for_object + v27[1];
  }
  else
  {
    a2[2] = 0;
    a2[3] = 0;
  }
  return v17;
}
// 80EB99C: using guessed type void *program_invocation_short_name;

//----- (08071090) --------------------------------------------------------
int __usercall dl_addr_inside_object@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // edx
  int v3; // ecx
  int v4; // ebx
  _DWORD *v5; // esi

  v2 = a2 - *(_DWORD *)a1;
  v3 = *(unsigned __int16 *)(a1 + 344) - 1;
  v4 = 32 * v3;
  while ( v3 != -1 )
  {
    v5 = (_DWORD *)(v4 + *(_DWORD *)(a1 + 336));
    if ( *v5 == 1 && (unsigned int)(v2 - v5[2]) < v5[5] )
      return 1;
    v4 -= 32;
    --v3;
  }
  return 0;
}

//----- (080710F0) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __fastcall _libc_init_secure(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // ecx
  int v4; // ecx
  _BOOL4 v5; // edx
  int v6; // ebx
  int v7; // ecx

  result = _libc_enable_secure_decided;
  if ( !_libc_enable_secure_decided )
  {
    v2 = geteuid(a1);
    result = getuid(v3);
    v5 = 1;
    if ( v2 == result )
    {
      v6 = getegid(v4);
      result = getgid(v7);
      v5 = v6 != result;
    }
    _libc_enable_secure = v5;
  }
  return result;
}
// 8071119: write access to const memory at 80EAFCC has been detected
// 807110B: variable 'v3' is possibly undefined
// 8071128: variable 'v4' is possibly undefined
// 807112F: variable 'v7' is possibly undefined
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80ECCC8: using guessed type int _libc_enable_secure_decided;

//----- (08071140) --------------------------------------------------------
int __fastcall dl_discover_osversion(int a1)
{
  char *v1; // ebx
  int v2; // edi
  int result; // eax
  int v4; // ecx
  int v5; // edx
  char *v6; // esi
  int i; // ecx
  int v8; // eax
  int v9; // edi
  int v10; // esi
  int v11; // [esp+8h] [ebp-1E4h]
  char v12[64]; // [esp+1Ah] [ebp-1D2h] BYREF
  char v13; // [esp+DCh] [ebp-110h] BYREF

  v1 = &v13;
  if ( uname(a1) )
  {
    v8 = open((int)"/proc/sys/kernel/osrelease", 0, v11);
    v9 = v8;
    if ( v8 < 0 )
      return -1;
    v1 = v12;
    v10 = read(v8, (int)v12, 64);
    close(v9);
    if ( v10 <= 0 )
      return -1;
    if ( v10 > 63 )
      v10 = 63;
    v12[v10] = 0;
  }
  v2 = 0;
  result = 0;
  while ( 1 )
  {
    v4 = *v1;
    if ( (unsigned __int8)(v4 - 48) > 9u )
      break;
    v5 = v1[1];
    v6 = v1 + 1;
    for ( i = v4 - 48; (unsigned __int8)(v5 - 48) <= 9u; v5 = *v6 )
    {
      ++v6;
      i = v5 + 10 * i - 48;
    }
    ++v2;
    v1 = v6 + 1;
    result = i | (result << 8);
    if ( (_BYTE)v5 != 46 )
    {
      if ( v2 == 3 )
        return result;
      break;
    }
    if ( v2 == 3 )
      return result;
  }
  result <<= 8 * (3 - v2);
  return result;
}
// 80711EA: variable 'v11' is possibly undefined
// 8071140: using guessed type char var_1D2[64];

//----- (08071240) --------------------------------------------------------
unsigned int __usercall _libc_init_first@<eax>(int a1@<ecx>, long double a2@<st0>, int a3, void **a4, int a5)
{
  _libc_multiple_libcs = 0;
  if ( _fpu_control != dl_fpu_control )
    _setfpucw((unsigned __int16)_fpu_control);
  _libc_argc = a3;
  _libc_argv = (int)a4;
  environ = a5;
  _libc_init_secure(a1);
  dl_non_dynamic_init(a2);
  _init_misc(a3, a4);
  return _ctype_init();
}
// 807127D: variable 'a1' is possibly undefined
// 80EB9FC: using guessed type __int16 dl_fpu_control;
// 80EBD10: using guessed type int _libc_multiple_libcs;
// 80EBF14: using guessed type __int16 _fpu_control;
// 80EC524: using guessed type int environ;
// 80ECCCC: using guessed type int _libc_argc;
// 80ECCD0: using guessed type int _libc_argv;

//----- (080712D0) --------------------------------------------------------
void __usercall __noreturn dl_start(long double a1@<st0>)
{
  abort(a1);
}

//----- (080712E0) --------------------------------------------------------
int __usercall _syscall_error@<eax>(int a1@<eax>)
{
  __writegsdword(0xFFFFFFE8, -a1);
  return -1;
}

//----- (08071300) --------------------------------------------------------
int __userpurge _gconv_open@<eax>(_BYTE *a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int a4)
{
  _BYTE *v4; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  _BYTE *v9; // esi
  int v10; // eax
  void *v11; // esp
  _BYTE *v12; // edi
  int v13; // eax
  void *v14; // esp
  int v16; // ebx
  _DWORD *v17; // ecx
  _DWORD *v18; // edi
  int v19; // edx
  int v20; // eax
  _DWORD *v21; // esi
  int v22; // edi
  unsigned int v23; // ebx
  int v24; // ecx
  int v25; // eax
  unsigned int v26; // edx
  bool v27; // zf
  int v28; // eax
  unsigned int v29; // edx
  _BYTE *v30; // edi
  unsigned int v31; // edx
  void *v32; // esp
  int v33; // eax
  void *v34; // esp
  char *v35; // edi
  char i; // al
  char *v37; // esi
  char v38; // al
  char *v39; // eax
  char v40; // dl
  unsigned int v41; // edi
  _DWORD *v42; // esi
  _BYTE *v43; // edi
  unsigned int v44; // eax
  void *v45; // esp
  int v46; // eax
  int v47; // [esp-8h] [ebp-68h]
  _BYTE v48[12]; // [esp+8h] [ebp-58h] BYREF
  _DWORD *v49; // [esp+14h] [ebp-4Ch]
  int transform; // [esp+18h] [ebp-48h]
  _DWORD *v51; // [esp+1Ch] [ebp-44h]
  int v52; // [esp+20h] [ebp-40h]
  int v53; // [esp+24h] [ebp-3Ch]
  unsigned int v54; // [esp+28h] [ebp-38h]
  _BYTE *v55; // [esp+2Ch] [ebp-34h]
  int v56; // [esp+30h] [ebp-30h]
  unsigned int v57; // [esp+34h] [ebp-2Ch]
  int v58; // [esp+40h] [ebp-20h]
  unsigned int v59[7]; // [esp+44h] [ebp-1Ch] BYREF

  v4 = a1;
  v55 = (_BYTE *)a2;
  v49 = a3;
  v5 = j_strchr(a1, 47);
  if ( !v5 )
    goto LABEL_31;
  v6 = j_strchr(v5 + 1, 47);
  LOBYTE(v56) = 0;
  v57 = 0;
  if ( !v6 || !*(_BYTE *)(v6 + 1) )
    goto LABEL_4;
  v30 = (_BYTE *)(v6 + 1);
  v31 = v6 + 1 - (_DWORD)v4;
  v32 = alloca(v31 + 16);
  v48[v31] = 0;
  v4 = memcpy(v48, v4, v31);
  v33 = strlen(v30);
  v34 = alloca(v33 + 16);
  v35 = memcpy(v48, v30, v33 + 1);
  for ( i = *v35; *v35 == 44; i = *v35 )
    ++v35;
  v37 = v35 + 1;
  if ( !i )
  {
LABEL_31:
    LOBYTE(v56) = 0;
    v57 = 0;
    goto LABEL_4;
  }
  while ( 1 )
  {
    v38 = *v37;
    if ( !*v37 )
      break;
    ++v37;
    if ( v38 == 44 )
    {
      *(v37 - 1) = 0;
      break;
    }
  }
  LOBYTE(v56) = 0;
  v57 = 0;
  while ( 1 )
  {
LABEL_35:
    if ( j_strcasecmp_l(v35, "TRANSLIT", nl_C_locobj) )
    {
      v27 = j_strcasecmp_l(v35, "IGNORE", nl_C_locobj) == 0;
      v46 = 2;
      if ( !v27 )
        v46 = v57;
      v57 = v46;
    }
    else
    {
      LOBYTE(v56) = 1;
    }
    while ( *v37 == 44 )
      ++v37;
    if ( !*v37 )
      break;
    v39 = v37 + 1;
    do
    {
      v40 = *v39;
      if ( !*v39 )
      {
        v35 = v37;
        v37 = v39;
        goto LABEL_35;
      }
      ++v39;
    }
    while ( v40 != 44 );
    v35 = v37;
    *(v39 - 1) = 0;
    v37 = v39;
  }
LABEL_4:
  v7 = j_strchr(v55, 47);
  if ( v7 )
  {
    v8 = j_strchr(v7 + 1, 47);
    if ( v8 )
    {
      if ( *(_BYTE *)(v8 + 1) )
      {
        v43 = v55;
        v44 = v8 + 1 - (_DWORD)v55;
        v45 = alloca(v44 + 16);
        v48[v44] = 0;
        v55 = memcpy(v48, v43, v44);
      }
    }
  }
  if ( *v4 == 47 && v4[1] == 47 && !v4[2] )
  {
    v9 = *(_BYTE **)(*(_DWORD *)__readgsdword(0xFFFFFFD8) + 92);
    v10 = strlen(v9);
    v11 = alloca(v10 + 18);
    strcpy((char *)mempcpy(v48, v9, v10), "//");
  }
  if ( *v55 == 47 && v55[1] == 47 && !v55[2] )
  {
    v12 = *(_BYTE **)(*(_DWORD *)__readgsdword(0xFFFFFFD8) + 92);
    v13 = strlen(v12);
    v14 = alloca(v13 + 18);
    strcpy((char *)mempcpy(v48, v12, v13), "//");
    v55 = v48;
  }
  transform = _gconv_find_transform(v59, a4);
  v51 = 0;
  if ( !transform )
  {
    v55 = (_BYTE *)v59[0];
    v16 = 32 * v59[0];
    v17 = (_DWORD *)malloc(32 * v59[0] + 8);
    v51 = v17;
    v18 = v17;
    v19 = (int)v55;
    if ( v17 )
    {
      v20 = v58;
      *v17 = v55;
      v17[1] = v20;
      j_memset(v17 + 2, 0, v16);
      if ( !v55 )
        goto LABEL_17;
      v21 = v18 + 8;
      v22 = 0;
      v23 = 0;
      while ( 1 )
      {
        v27 = (_BYTE)v56 == 0;
        *(v21 - 1) = v21;
        v54 = v23 + 1;
        if ( !v27 )
        {
          v28 = j_strcasecmp_l(*(_DWORD *)(v58 + v22 + 12), "INTERNAL", nl_C_locobj);
          v29 = v57 | 8;
          if ( v28 )
            v29 = v57;
          v57 = v29;
        }
        v55 = (_BYTE *)v59[0];
        if ( v23 >= v59[0] - 1 )
        {
          v51[8 * v23 + 4] = v57 | 1;
          goto LABEL_17;
        }
        *(v21 - 4) = v57;
        v24 = 8160 * *(_DWORD *)(v58 + v22 + 48);
        v52 = v58;
        v53 = v24;
        v25 = malloc(v24);
        *(v21 - 6) = v25;
        v26 = (unsigned int)v55;
        if ( !v25 )
          break;
        v23 = v54;
        v21 += 8;
        v22 += 60;
        *(v21 - 13) = v53 + v25;
        if ( v26 <= v23 )
          goto LABEL_17;
      }
      v41 = v23 - 1;
      v42 = &v51[8 * v23];
      v57 = __readgsdword(0xFFFFFFE8);
      if ( v23 )
      {
        do
        {
          v47 = *(v42 - 6);
          --v41;
          v42 -= 8;
          free(v47);
        }
        while ( v41 != -1 );
        v26 = v59[0];
        v52 = v58;
      }
      v56 = v26;
      free(v51);
      v19 = v56;
    }
    else
    {
      v57 = __readgsdword(0xFFFFFFE8);
      v52 = v58;
    }
    _gconv_close_transform(v52, v19);
    transform = 3;
    v51 = 0;
    __writegsdword(0xFFFFFFE8, v57);
  }
LABEL_17:
  *v49 = v51;
  return transform;
}
// 8048240: using guessed type int __cdecl j_strcasecmp_l(_DWORD, _DWORD, _DWORD);
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 8072590: using guessed type _DWORD __stdcall _gconv_find_transform(_DWORD, _DWORD);
// 80CC680: using guessed type void **nl_C_locobj[6];
// 8071300: using guessed type unsigned int var_1C[7];

//----- (080717B0) --------------------------------------------------------
int __userpurge _gconv@<eax>(int *a1@<eax>, int *a2@<edx>, unsigned int a3@<ecx>, int *a4, int a5, _DWORD *a6)
{
  int v8; // eax
  unsigned int v9; // edx
  int v10; // ecx
  int *v11; // esi
  _DWORD *v12; // eax
  int (__cdecl *v13)(int, int *, int *, unsigned int, _DWORD, _DWORD *, int, _DWORD); // esi
  int v14; // ebp
  int result; // eax
  _DWORD *v16; // ebx
  unsigned int v17; // ecx
  unsigned int v19; // [esp+0h] [ebp-28h]
  int *v20; // [esp+8h] [ebp-20h]

  if ( a1 == (int *)-1 )
    return 8;
  v8 = *a1;
  v9 = v8 - 1;
  if ( !a6 )
    _assert_fail("irreversible != NULL", "gconv.c", 44, "__gconv");
  *a6 = 0;
  if ( a4 )
    v10 = *a4;
  else
    v10 = 0;
  v11 = &a1[8 * v8];
  *(v11 - 6) = v10;
  v20 = v11;
  *(v11 - 5) = a5;
  v12 = (_DWORD *)a1[1];
  v13 = (int (__cdecl *)(int, int *, int *, unsigned int, _DWORD, _DWORD *, int, _DWORD))v12[5];
  if ( *v12 )
    v13 = (int (__cdecl *)(int, int *, int *, unsigned int, _DWORD, _DWORD *, int, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v13, 9));
  if ( a2 )
  {
    v14 = *a2;
    if ( *a2 )
    {
      if ( !a4 || !*a4 )
        _assert_fail("outbuf != NULL && *outbuf != NULL", "gconv.c", 74, "__gconv");
      while ( 1 )
      {
        dl_mcount_wrapper_check((int)v13);
        result = v13(a1[1], a1 + 2, a2, a3, 0, a6, 0, 0);
        if ( result != 4 || *a2 == v14 || a3 < *a2 + *(_DWORD *)(a1[1] + 36) )
          break;
        v14 = *a2;
      }
LABEL_16:
      if ( *a4 )
        *a4 = *(v20 - 6);
      return result;
    }
  }
  v19 = v9;
  dl_mcount_wrapper_check((int)v13);
  result = v13(a1[1], a1 + 2, 0, 0, 0, a6, (*(v20 - 6) == 0) + 1, 0);
  if ( !result )
  {
    v16 = a1 + 5;
    v17 = 0;
    do
    {
      ++v17;
      *v16 = 0;
      v16 += 8;
    }
    while ( v19 >= v17 );
  }
  if ( a4 )
    goto LABEL_16;
  return result;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08071980) --------------------------------------------------------
int __usercall _gconv_close@<eax>(int *a1@<eax>, long double a2@<st0>)
{
  int *v3; // ebx
  int v4; // esi
  int v5; // edi

  v3 = a1 + 10;
  v4 = a1[1];
  v5 = *a1;
  while ( (*(_BYTE *)(v3 - 6) & 1) == 0 )
  {
    if ( *(v3 - 8) )
    {
      free(a2, *(v3 - 8));
      if ( (*(_BYTE *)(v3 - 6) & 1) != 0 )
        break;
    }
    v3 += 8;
  }
  free(a2, (int)a1);
  return _gconv_close_transform(v4, v5);
}

//----- (080719E0) --------------------------------------------------------
int __cdecl _gconv_alias_compare(_DWORD *a1, _DWORD *a2)
{
  return j_strcmp(*a1, *a2);
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);

//----- (08071A00) --------------------------------------------------------
int __cdecl derivation_compare(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  result = j_strcmp(*a1, *a2);
  if ( !result )
    return j_strcmp(a1[1], a2[1]);
  return result;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);

//----- (08071A40) --------------------------------------------------------
int _gconv_get_modules_db()
{
  return _gconv_modules_db;
}
// 80ECCD4: using guessed type int _gconv_modules_db;

//----- (08071A50) --------------------------------------------------------
int _gconv_get_alias_db()
{
  return _gconv_alias_db;
}
// 80ECCDC: using guessed type int _gconv_alias_db;

//----- (08071A60) --------------------------------------------------------
int __usercall _gconv_release_step@<eax>(int *a1@<eax>)
{
  int result; // eax
  int v3; // ecx
  int v4; // esi
  void (__cdecl *v5)(int *); // esi

  result = *a1;
  if ( result )
  {
    v3 = a1[2];
    a1[2] = v3 - 1;
    if ( v3 == 1 )
    {
      v4 = a1[8];
      if ( v4 )
      {
        v5 = (void (__cdecl *)(int *))(__readgsdword(0x18u) ^ __ROR4__(v4, 9));
        dl_mcount_wrapper_check((int)v5);
        v5(a1);
        result = *a1;
      }
      result = _gconv_release_shlib(result);
      *a1 = 0;
    }
  }
  else
  {
    result = a1[8];
    if ( result )
      _assert_fail("step->__end_fct == NULL", "gconv_db.c", 234, "__gconv_release_step");
  }
  return result;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08071AD0) --------------------------------------------------------
int __userpurge find_derivation@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        _BYTE *a3@<ecx>,
        _BYTE *a4,
        _DWORD *a5,
        unsigned int *a6)
{
  _BYTE *v6; // edi
  int *v8; // eax
  int v9; // eax
  _DWORD *v10; // ebx
  unsigned int v11; // eax
  unsigned int v12; // esi
  int **k; // edi
  int *v14; // eax
  int v15; // ecx
  int v16; // ebx
  int v17; // eax
  void (__cdecl *v18)(int **); // ebx
  int *v19; // eax
  int *v20; // eax
  int *v21; // eax
  int v22; // esi
  _DWORD *v23; // edi
  int v24; // ebx
  int v25; // eax
  _DWORD *v26; // eax
  _BYTE *v27; // ebx
  int (__cdecl *v28)(_DWORD); // eax
  _DWORD *v29; // esi
  _DWORD *v30; // esi
  bool v31; // zf
  int (__cdecl *v32)(_DWORD); // eax
  _DWORD *v33; // eax
  bool v34; // cc
  int v35; // eax
  _DWORD *v36; // eax
  _DWORD *v37; // esi
  int v38; // eax
  int v39; // edx
  int v40; // ebx
  int v41; // ecx
  int j; // eax
  _DWORD *v43; // eax
  int v44; // esi
  int v45; // edi
  int v46; // ebx
  int v47; // edx
  int v48; // ecx
  int v49; // edx
  int v50; // eax
  int v51; // edi
  int v52; // eax
  _DWORD *i; // edi
  unsigned int v54; // esi
  int (__cdecl *v55)(_DWORD); // eax
  _DWORD *v56; // ecx
  unsigned int v57; // esi
  int **v58; // ebx
  _DWORD *v59; // eax
  int v60; // eax
  _BYTE *v61; // eax
  int *shlib; // eax
  _DWORD *v63; // ecx
  int v64; // edx
  int v65; // edx
  int v66; // eax
  _DWORD *v67; // eax
  _DWORD *v68; // ecx
  int *v69; // eax
  int v70; // edx
  unsigned int v71; // ebx
  int v72; // eax
  _DWORD *v73; // edi
  int (__cdecl *v74)(_DWORD); // edx
  _BYTE *v75; // eax
  _WORD *v76; // eax
  int (__cdecl *v77)(_DWORD); // eax
  int v78; // eax
  int *v80; // eax
  unsigned int v81; // edi
  _DWORD *v82; // edx
  int *v83; // esi
  _DWORD *v84; // ebx
  int *v85; // eax
  char *v86; // edi
  int *v87; // ebx
  char *v88; // esi
  int *v89; // eax
  _BYTE *v90; // eax
  _BYTE *v91; // [esp-90h] [ebp-E8h] BYREF
  int v92; // [esp-8Ch] [ebp-E4h]
  int (__cdecl *v93)(_DWORD); // [esp-88h] [ebp-E0h]
  int (__cdecl *v94)(_DWORD); // [esp-84h] [ebp-DCh]
  _DWORD *v95; // [esp-80h] [ebp-D8h]
  _DWORD *v96; // [esp-7Ch] [ebp-D4h]
  int v97; // [esp-78h] [ebp-D0h] BYREF
  _BYTE *v98; // [esp-70h] [ebp-C8h]
  _DWORD v99[6]; // [esp-60h] [ebp-B8h] BYREF
  int v100; // [esp-48h] [ebp-A0h] BYREF
  _BYTE *v101; // [esp-30h] [ebp-88h] BYREF
  int v102; // [esp-2Ch] [ebp-84h]
  int v103; // [esp-28h] [ebp-80h]
  int v104; // [esp-24h] [ebp-7Ch]
  int v105; // [esp-20h] [ebp-78h]
  int v106; // [esp-1Ch] [ebp-74h]
  _DWORD *v107; // [esp-18h] [ebp-70h] BYREF
  int *v108; // [esp+4h] [ebp-54h]
  _DWORD *v109; // [esp+8h] [ebp-50h]
  int v110; // [esp+Ch] [ebp-4Ch]
  _BYTE *v111; // [esp+10h] [ebp-48h]
  int v112; // [esp+14h] [ebp-44h]
  int v113; // [esp+18h] [ebp-40h]
  _DWORD *v114; // [esp+1Ch] [ebp-3Ch]
  int v115; // [esp+20h] [ebp-38h]
  int (__cdecl *v116)(_DWORD); // [esp+24h] [ebp-34h]
  _DWORD *v117; // [esp+28h] [ebp-30h]
  int (__cdecl *v118)(_DWORD); // [esp+2Ch] [ebp-2Ch]
  _BYTE *v119; // [esp+30h] [ebp-28h] BYREF
  _BYTE *v120; // [esp+34h] [ebp-24h]
  int v121; // [esp+38h] [ebp-20h]
  int v122; // [esp+3Ch] [ebp-1Ch]
  int savedregs; // [esp+58h] [ebp+0h] BYREF

  v6 = (_BYTE *)a2;
  v112 = a1;
  if ( !a2 )
    v6 = (_BYTE *)a1;
  v110 = a2;
  v111 = v6;
  if ( !a4 )
  {
    v119 = a3;
    v121 = 0;
    v122 = 0;
    v120 = v111;
    v8 = tfind((int)&v119, &known_derivations, (int (__cdecl *)(int, _DWORD))derivation_compare);
    if ( v8 )
      goto LABEL_5;
    v101 = a3;
    v109 = &v101;
    v102 = strlen(a3);
    v104 = 0;
    v103 = 0;
    v105 = 0;
    v106 = 0;
    v107 = 0;
    v108 = (int *)&v107;
    a4 = a3;
    goto LABEL_17;
  }
  v121 = 0;
  v122 = 0;
  v119 = a4;
  v120 = v111;
  v8 = tfind((int)&v119, &known_derivations, (int (__cdecl *)(int, _DWORD))derivation_compare);
  if ( !v8 )
  {
    v101 = a4;
    v109 = &v101;
    v102 = strlen(a4);
    v104 = 0;
    v103 = 0;
    v105 = 0;
    v106 = 0;
    v107 = 0;
    v99[0] = a3;
    v99[1] = strlen(a3);
    memset(&v99[2], 0, 16);
    v100 = 0;
    v107 = v99;
    v108 = &v100;
LABEL_17:
    v113 = 0x7FFFFFFF;
    v115 = 0x7FFFFFFF;
    v114 = 0;
    v22 = 0;
    v117 = v109;
    while ( 1 )
    {
      if ( v22 > v115 )
        goto LABEL_26;
      if ( v22 != v115 || v117[2] < v113 )
        break;
      v117 = (_DWORD *)v117[6];
      v26 = v117;
      if ( !v117 )
      {
LABEL_78:
        if ( !v114 )
        {
          v118 = 0;
          v54 = 0;
          v70 = 1;
          *a5 = 0;
          *a6 = 0;
          goto LABEL_104;
        }
        v50 = v114[6];
        if ( v50 )
        {
          v51 = v114[3];
          if ( *(_DWORD *)(v50 + 12) >= v51 )
          {
            if ( *(_DWORD *)(v50 + 12) == v51 )
            {
              if ( *(_DWORD *)(v50 + 8) >= v114[2] )
                v50 = (int)v114;
              v114 = (_DWORD *)v50;
            }
          }
          else
          {
            v114 = (_DWORD *)v114[6];
          }
        }
        v52 = v114[5];
        if ( v52 )
        {
          for ( i = 0; ; i = (_DWORD *)((char *)i + 1) )
          {
            v52 = *(_DWORD *)(v52 + 20);
            v54 = (unsigned int)i + 1;
            if ( !v52 )
              break;
          }
          v55 = (int (__cdecl *)(_DWORD))malloc(60 * v54);
          v118 = v55;
          if ( v55 )
          {
            *a6 = v54;
            if ( i == (_DWORD *)-1 )
            {
LABEL_103:
              v70 = 0;
              *a5 = v118;
LABEL_104:
              v116 = (int (__cdecl *)(_DWORD))v70;
              v71 = strlen(a4) + 1;
              v117 = (_DWORD *)(strlen(v111) + 1);
              v72 = malloc((char *)v117 + v71 + 16);
              v73 = (_DWORD *)v72;
              v74 = v116;
              if ( v72 )
              {
                v75 = (_BYTE *)(v72 + 16);
                *v73 = v75;
                v76 = mempcpy(v75, a4, v71);
                v73[1] = memcpy(v76, v111, (unsigned int)v117);
                v77 = v118;
                v73[3] = v54;
                v73[2] = v77;
                v78 = tsearch((int)v73, &known_derivations, (int (__cdecl *)(int, _DWORD))derivation_compare);
                v74 = v116;
                if ( !v78 )
                {
                  v118 = v116;
                  free(v73);
                  return (int)v118;
                }
              }
              return (int)v74;
            }
            v56 = (_DWORD *)((char *)i + 1);
            v115 = 0;
            v113 = 0;
            v57 = (unsigned int)v114;
            v58 = (int **)((char *)v55 + 60 * (_DWORD)i);
            while ( 2 )
            {
              if ( i )
              {
                v58[3] = **(int ***)(v57 + 20);
              }
              else
              {
                v117 = v56;
                v90 = strdup(a4);
                v113 = (int)v90;
                *((_DWORD *)v118 + 3) = v90;
                v56 = v117;
                if ( !v90 )
                {
                  v81 = 1;
LABEL_110:
                  v82 = 0;
                  if ( *a6 <= v81 )
                  {
                    v54 = 0;
                    free(v118);
                    free(v113);
                    free(v115);
                    v118 = 0;
                    v70 = 1;
                    *a6 = 0;
                    *a5 = 0;
                    goto LABEL_104;
                  }
LABEL_117:
                  v83 = (int *)((char *)v118 + 60 * v81);
                  v84 = v82;
                  do
                  {
                    v85 = v83;
                    ++v81;
                    v83 += 15;
                    _gconv_release_step(v85);
                  }
                  while ( v81 < *a6 );
                  v117 = v84;
                  v54 = 0;
                  free(v118);
                  free(v113);
                  free(v115);
                  v70 = (int)v117;
                  v118 = 0;
                  *a6 = 0;
                  *a5 = 0;
                  if ( !v70 )
                    v70 = 1;
                  goto LABEL_104;
                }
              }
              if ( (_DWORD *)*a6 == v56 )
              {
                v98 = *(_BYTE **)v57;
                v117 = v56;
                v80 = (int *)strdup(v98);
                v115 = (int)v80;
                v58[4] = v80;
                v56 = v117;
                if ( !v80 )
                {
LABEL_109:
                  v81 = (unsigned int)i + 1;
                  goto LABEL_110;
                }
              }
              else
              {
                v58[4] = (int *)*((_DWORD *)v118 + 15 * (_DWORD)v56 + 3);
              }
              v60 = *(_DWORD *)(v57 + 16);
              v58[2] = (int *)1;
              v58[14] = 0;
              v61 = *(_BYTE **)(v60 + 16);
              if ( *v61 == 47 )
              {
                v117 = v56;
                shlib = _gconv_find_shlib(v61, (int)&savedregs, v57);
                v63 = v117;
                if ( !shlib )
                  goto LABEL_109;
                v64 = *shlib;
                *v58 = shlib;
                v117 = v63;
                v58[1] = (int *)v64;
                v58[5] = (int *)shlib[3];
                v65 = shlib[4];
                v66 = shlib[5];
                v58[6] = 0;
                v58[7] = (int *)v65;
                v58[8] = (int *)v66;
                if ( v65 )
                {
                  v116 = (int (__cdecl *)(_DWORD))(__readgsdword(0x18u) ^ __ROR4__(v65, 9));
                  dl_mcount_wrapper_check((int)v116);
                  v67 = (_DWORD *)v116(v58);
                  v68 = v117;
                  if ( v67 )
                  {
                    v82 = v67;
                    *((_DWORD *)v118 + 15 * ((_DWORD)v117 - 2) + 8) = 0;
                    v81 = (unsigned int)v68 - 1;
                    if ( (unsigned int)v68 - 1 >= *a6 )
                    {
                      v117 = v67;
                      v54 = 0;
                      free(v118);
                      free(v113);
                      free(v115);
                      v118 = 0;
                      v70 = (int)v117;
                      *a6 = 0;
                      *a5 = 0;
                      goto LABEL_104;
                    }
                    goto LABEL_117;
                  }
                  v69 = v58[6];
                  if ( v69 )
                  {
                    v58 -= 15;
                    v58[21] = (int *)__ROL4__(__readgsdword(0x18u) ^ (unsigned int)v69, 9);
                    v57 = *(_DWORD *)(v57 + 20);
                    v59 = (_DWORD *)((char *)i - 1);
                    v56 = i;
                    if ( !i )
                    {
LABEL_102:
                      v54 = *a6;
                      goto LABEL_103;
                    }
                    goto LABEL_91;
                  }
                }
              }
              else
              {
                _gconv_get_builtin_trans((int)v61, v58);
              }
              v58 -= 15;
              v57 = *(_DWORD *)(v57 + 20);
              v59 = (_DWORD *)((char *)i - 1);
              v56 = i;
              if ( !i )
                goto LABEL_102;
LABEL_91:
              i = v59;
              continue;
            }
          }
        }
        else
        {
          v118 = (int (__cdecl *)(_DWORD))malloc(0);
          if ( v118 )
          {
            v54 = 0;
            *a6 = 0;
            goto LABEL_103;
          }
        }
        v118 = 0;
        v54 = 0;
        v70 = 3;
        *a6 = 0;
        *a5 = 0;
        goto LABEL_104;
      }
LABEL_27:
      v22 = v26[3];
    }
    v23 = (_DWORD *)_gconv_modules_db;
    if ( _gconv_modules_db )
    {
      v24 = *v117;
      while ( 1 )
      {
        v25 = j_strcmp(v24, *v23);
        if ( !v25 )
          break;
        if ( v25 >= 0 )
        {
          v23 = (_DWORD *)v23[7];
          if ( !v23 )
            goto LABEL_26;
        }
        else
        {
          v23 = (_DWORD *)v23[5];
          if ( !v23 )
            goto LABEL_26;
        }
      }
      while ( 2 )
      {
        v27 = (_BYTE *)v23[1];
        if ( *v27 == 45 && !v27[1] )
          v27 = v111;
        v28 = (int (__cdecl *)(_DWORD))(v23[3] + v117[2]);
        v118 = (int (__cdecl *)(_DWORD))(v23[2] + v22);
        v116 = v28;
        if ( j_strcmp(v27, v112) && (!v110 || j_strcmp(v27, v110)) )
        {
          if ( v115 > (int)v118 || (int (__cdecl *)(_DWORD))v115 == v118 && v113 > (int)v116 )
          {
            v29 = v109;
            while ( j_strcmp(v27, *v29) )
            {
              v29 = (_DWORD *)v29[6];
              if ( !v29 )
              {
                v91 = v27;
                v92 = strlen(v27);
                v95 = v23;
                v97 = 0;
                v94 = v118;
                v93 = v116;
                v96 = v117;
                *v108 = (int)&v91;
                v108 = &v97;
                goto LABEL_28;
              }
            }
            if ( (int)v118 < v29[3] || v118 == (int (__cdecl *)(_DWORD))v29[3] && (int)v116 < v29[2] )
            {
              v36 = v117;
              v29[4] = v23;
              v29[5] = v36;
              v37 = v109;
              do
              {
                v38 = v37[4];
                if ( v38 )
                {
                  v39 = v37[5];
                  v40 = *(_DWORD *)(v38 + 8);
                  v41 = *(_DWORD *)(v38 + 12);
                  for ( j = *(_DWORD *)(v39 + 16); j; j = *(_DWORD *)(v39 + 16) )
                  {
                    v39 = *(_DWORD *)(v39 + 20);
                    v40 += *(_DWORD *)(j + 8);
                    v41 += *(_DWORD *)(j + 12);
                  }
                  v37[3] = v40;
                  v37[2] = v41;
                }
                v37 = (_DWORD *)v37[6];
              }
              while ( v37 );
              v43 = v114;
              if ( v114 )
              {
                v118 = (int (__cdecl *)(_DWORD))v23;
                v44 = v115;
                v45 = v113;
                do
                {
                  while ( 1 )
                  {
                    v46 = v43[4];
                    v47 = v43[5];
                    v48 = *(_DWORD *)(v46 + 8) + *(_DWORD *)(v47 + 12);
                    v49 = *(_DWORD *)(v46 + 12) + *(_DWORD *)(v47 + 8);
                    v43[3] = v48;
                    v43[2] = v49;
                    if ( v48 >= v44 )
                      break;
                    v43 = (_DWORD *)v43[6];
                    v45 = v49;
                    v44 = v48;
                    if ( !v43 )
                      goto LABEL_75;
                  }
                  if ( v49 < v45 && v48 == v44 )
                    v45 = v49;
                  v43 = (_DWORD *)v43[6];
                }
                while ( v43 );
LABEL_75:
                v113 = v45;
                v115 = v44;
                v23 = v118;
              }
            }
          }
          goto LABEL_28;
        }
        if ( v114 )
        {
          v30 = v114;
          while ( j_strcmp(v27, *v30) )
          {
            v30 = (_DWORD *)v30[6];
            if ( !v30 )
              goto LABEL_57;
          }
          if ( (int)v118 < v30[3] || v118 == (int (__cdecl *)(_DWORD))v30[3] && (int)v116 < v30[2] )
          {
            v33 = v117;
            v31 = v115 == (_DWORD)v118;
            v34 = v115 <= (int)v118;
            v30[4] = v23;
            v30[5] = v33;
            v30[3] = v118;
            v30[2] = v116;
            if ( !v34 )
            {
LABEL_56:
              v113 = (int)v116;
              v115 = (int)v118;
LABEL_28:
              v23 = (_DWORD *)v23[6];
              if ( !v23 )
                goto LABEL_26;
              v22 = v117[3];
              continue;
            }
LABEL_50:
            if ( v31 )
            {
              v32 = v116;
              if ( v113 <= (int)v116 )
                v32 = (int (__cdecl *)(_DWORD))v113;
              v113 = (int)v32;
            }
            goto LABEL_28;
          }
        }
        else
        {
LABEL_57:
          v91 = v27;
          v92 = strlen(v27);
          v95 = v23;
          v94 = v118;
          v93 = v116;
          v96 = v117;
          v35 = (int)v114;
          v114 = &v91;
          v97 = v35;
        }
        break;
      }
      v31 = v115 == (_DWORD)v118;
      if ( v115 > (int)v118 )
        goto LABEL_56;
      goto LABEL_50;
    }
LABEL_26:
    v117 = (_DWORD *)v117[6];
    v26 = v117;
    if ( !v117 )
      goto LABEL_78;
    goto LABEL_27;
  }
LABEL_5:
  v9 = *v8;
  v10 = *(_DWORD **)(v9 + 8);
  v11 = *(_DWORD *)(v9 + 12);
  *a5 = v10;
  v12 = v11;
  v118 = (int (__cdecl *)(_DWORD))v11;
  v117 = v10;
  *a6 = v11;
  for ( k = (int **)&v10[15 * v11 - 15]; ; k -= 15 )
  {
    if ( !v12 )
      return 0;
    v20 = k[2];
    k[2] = (int *)((char *)v20 + 1);
    if ( !v20 )
      break;
LABEL_11:
    --v12;
  }
  v21 = k[1];
  if ( !v21 )
  {
    v16 = (int)k[7];
LABEL_8:
    if ( v16 )
    {
      v18 = (void (__cdecl *)(int **))(__readgsdword(0x18u) ^ __ROR4__(v16, 9));
      dl_mcount_wrapper_check((int)v18);
      v18(k);
      v19 = k[6];
      if ( v19 )
        k[6] = (int *)__ROL4__(__readgsdword(0x18u) ^ (unsigned int)v19, 9);
    }
    goto LABEL_11;
  }
  v14 = _gconv_find_shlib(v21, (int)&savedregs, v12);
  *k = v14;
  if ( v14 )
  {
    v15 = v14[3];
    v16 = v14[4];
    v17 = v14[5];
    k[6] = 0;
    k[5] = (int *)v15;
    k[7] = (int *)v16;
    k[8] = (int *)v17;
    goto LABEL_8;
  }
  k[2] = (int *)((char *)k[2] - 1);
  if ( (unsigned int)v118 > v12 )
  {
    v86 = 0;
    v87 = &v117[15 * v12];
    v88 = (char *)v118 - v12;
    do
    {
      v89 = v87;
      ++v86;
      v87 += 15;
      _gconv_release_step(v89);
    }
    while ( v88 != v86 );
  }
  return 1;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EC5AC: using guessed type int known_derivations;
// 80ECCD4: using guessed type int _gconv_modules_db;

//----- (080724A0) --------------------------------------------------------
int __usercall _gconv_compare_alias@<eax>(unsigned __int8 *a1@<eax>, unsigned __int8 *a2@<edx>)
{
  _DWORD *v5; // eax
  unsigned __int8 *v6; // edi
  _DWORD *v7; // eax
  unsigned __int8 *v8; // eax
  int v9; // [esp+4h] [ebp-28h] BYREF
  int v10[9]; // [esp+8h] [ebp-24h] BYREF

  if ( !once_0 )
  {
    _gconv_read_conf();
    once_0 |= 2u;
  }
  if ( !_gconv_compare_alias_cache(a1, a2, &v9) )
    return v9;
  v10[0] = (int)a2;
  v5 = tfind((int)v10, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
  if ( v5 )
  {
    v6 = *(unsigned __int8 **)(*v5 + 4);
    if ( !v6 )
      v6 = a2;
  }
  else
  {
    v6 = a2;
  }
  v10[0] = (int)a1;
  v7 = tfind((int)v10, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
  if ( v7 )
  {
    v8 = *(unsigned __int8 **)(*v7 + 4);
    if ( !v8 )
      v8 = a1;
  }
  else
  {
    v8 = a1;
  }
  return j_strcmp(v8, v6);
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80EC5A8: using guessed type int once_0;
// 80ECCDC: using guessed type int _gconv_alias_db;

//----- (08072590) --------------------------------------------------------
int __userpurge _gconv_find_transform@<eax>(
        unsigned __int8 *a1@<eax>,
        unsigned __int8 *a2@<edx>,
        _DWORD *a3@<ecx>,
        int *a4,
        char a5)
{
  bool v9; // zf
  int derivation; // edx
  _DWORD *v12; // eax
  _BYTE *v13; // ebp
  _DWORD *v14; // eax
  int v15; // edx
  int v16; // eax
  int v17; // eax
  int v18; // [esp+Ch] [ebp-30h]
  int v19; // [esp+Ch] [ebp-30h]
  int v20[9]; // [esp+18h] [ebp-24h] BYREF

  if ( !once_0 )
  {
    _gconv_read_conf();
    once_0 |= 2u;
  }
  _ECX = 1;
  v9 = __readgsdword(0xCu) == 0;
  if ( !v9 )
    __asm { lock }
  __asm { cmpxchg ds:__gconv_lock, ecx }
  if ( !v9 )
    _lll_lock_wait_private(0, &_gconv_lock);
  derivation = _gconv_lookup_cache(a1, a2, a3, a4, a5);
  if ( derivation != 2 )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --_gconv_lock )
      _lll_unlock_wake_private(&_gconv_lock);
    return derivation;
  }
  if ( !_gconv_modules_db )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --_gconv_lock )
      _lll_unlock_wake_private(&_gconv_lock);
    return 1;
  }
  v20[0] = (int)a2;
  v12 = tfind((int)v20, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
  if ( v12 )
    v13 = *(_BYTE **)(*v12 + 4);
  else
    v13 = 0;
  v20[0] = (int)a1;
  v14 = tfind((int)v20, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
  if ( v14 )
    v15 = *(_DWORD *)(*v14 + 4);
  else
    v15 = 0;
  if ( (a5 & 1) != 0 )
  {
    v18 = v15;
    if ( !j_strcmp(a1, a2) )
      goto LABEL_47;
    v15 = v18;
    if ( v18 )
    {
      v16 = j_strcmp(v18, a2);
      v15 = v18;
      if ( !v16 )
        goto LABEL_47;
    }
    if ( v13 )
    {
      v19 = v15;
      if ( !j_strcmp(a1, v13) || (v15 = v19) != 0 && (v17 = j_strcmp(v19, v13), v15 = v19, !v17) )
      {
LABEL_47:
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --_gconv_lock )
          _lll_unlock_wake_private(&_gconv_lock);
        return -1;
      }
    }
  }
  derivation = find_derivation((int)a1, v15, a2, v13, a3, (unsigned int *)a4);
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --_gconv_lock )
    _lll_unlock_wake_private(&_gconv_lock);
  if ( derivation )
    return derivation;
  return *a3 == 0;
}
// 8072623: variable 'derivation' is possibly undefined
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80EC5A8: using guessed type int once_0;
// 80ECCD4: using guessed type int _gconv_modules_db;
// 80ECCD8: using guessed type int _gconv_lock;
// 80ECCDC: using guessed type int _gconv_alias_db;

//----- (08072820) --------------------------------------------------------
int __usercall _gconv_close_transform@<eax>(int a1@<eax>, int a2@<edx>)
{
  bool v4; // zf
  int v5; // ebx
  int v6; // esi
  int *v7; // eax

  _ECX = 1;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg ds:__gconv_lock, ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, &_gconv_lock);
  if ( a2 )
  {
    v5 = a2 - 1;
    v6 = a1 + 60 * a2 - 60;
    do
    {
      v7 = (int *)v6;
      --v5;
      v6 -= 60;
      _gconv_release_step(v7);
    }
    while ( v5 != -1 );
  }
  _gconv_release_cache(a1);
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --_gconv_lock )
    _lll_unlock_wake_private(&_gconv_lock);
  return 0;
}
// 8072853: variable 'a2' is possibly undefined
// 80ECCD8: using guessed type int _gconv_lock;

//----- (080728B0) --------------------------------------------------------
int __usercall insert_module@<eax>(int result@<eax>, int a2@<edx>)
{
  _DWORD *v2; // edi
  int *v3; // ebx
  int v4; // esi
  _DWORD *v5; // ebp
  int v6; // eax

  v2 = (_DWORD *)result;
  v3 = &_gconv_modules_db;
  while ( 1 )
  {
    v5 = (_DWORD *)*v3;
    if ( !*v3 )
    {
LABEL_6:
      *v3 = (int)v2;
      return result;
    }
    v4 = *v2;
    result = j_strcmp(*v2, *v5);
    if ( !result )
      break;
    v3 = v5 + 5;
    if ( result >= 0 )
      v3 = v5 + 7;
  }
  while ( 1 )
  {
    if ( !result )
    {
      result = j_strcmp(v2[1], v5[1]);
      if ( !result )
        break;
    }
    v3 = v5 + 6;
    v5 = (_DWORD *)v5[6];
    if ( !v5 )
      goto LABEL_6;
    result = j_strcmp(v4, *v5);
  }
  v6 = v5[2];
  if ( v2[2] < v6 || v2[2] == v6 && v2[3] < v5[3] )
  {
    v2[5] = v5[5];
    v2[7] = v5[7];
    v2[6] = v5[6];
    *v3 = (int)v2;
    return free(v5);
  }
  else
  {
    result = a2;
    if ( a2 )
      return free(v2);
  }
  return result;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80ECCD4: using guessed type int _gconv_modules_db;

//----- (08072990) --------------------------------------------------------
int __userpurge add_module@<eax>(char *a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>, int a4, int a5, int a6)
{
  char *v6; // edi
  int v7; // esi
  int v8; // eax
  int result; // eax
  _BYTE *v10; // ebx
  int v11; // esi
  char *v12; // ebx
  int v13; // eax
  _BYTE *i; // edi
  _BYTE *v15; // esi
  _BYTE *v16; // eax
  _BYTE *v17; // edi
  char v18; // al
  _BYTE *v19; // ecx
  char *j; // esi
  _BYTE *v21; // ebx
  int v22; // ecx
  bool v23; // zf
  unsigned int v24; // eax
  int v25; // esi
  unsigned int v26; // eax
  void *v27; // esp
  _DWORD *v28; // ebx
  _BYTE *v29; // eax
  _WORD *v30; // eax
  char *v31; // edi
  _BYTE *v32; // edx
  _WORD *v33; // eax
  int v34; // ecx
  unsigned int v35; // edx
  _WORD *v36; // eax
  int v37; // eax
  _BYTE v38[4]; // [esp+0h] [ebp-48h] BYREF
  char *v39; // [esp+4h] [ebp-44h]
  _BYTE *v40; // [esp+8h] [ebp-40h]
  _BYTE *v41; // [esp+Ch] [ebp-3Ch]
  _BYTE *v42; // [esp+10h] [ebp-38h]
  char *v43; // [esp+14h] [ebp-34h]
  unsigned int v44; // [esp+18h] [ebp-30h]
  int v45; // [esp+1Ch] [ebp-2Ch]
  char *v46[8]; // [esp+28h] [ebp-20h] BYREF

  v6 = a1;
  v7 = (unsigned __int8)*a1;
  v42 = a2;
  v44 = a3;
  v8 = (char)v7;
  if ( (byte_80C2440[2 * (char)v7 + 1] & 0x20) != 0 )
  {
    do
      v8 = *++v6;
    while ( (byte_80C2440[2 * v8 + 1] & 0x20) != 0 );
    v7 = *v6;
  }
  v45 = v8;
  result = v7;
  v10 = v6;
  if ( (_BYTE)v7 )
  {
    result = v45;
    while ( 1 )
    {
      *v10 = dword_80C1B40[result];
      result = (char)v10[1];
      if ( !(_BYTE)result )
        break;
      if ( (byte_80C2440[2 * result + 1] & 0x20) != 0 )
      {
        v10[1] = 0;
        v11 = (unsigned __int8)v10[2];
        v12 = v10 + 2;
        v43 = v12;
        v13 = (char)v11;
        if ( (byte_80C2440[2 * (char)v11 + 1] & 0x20) != 0 )
        {
          do
            v11 = *++v12;
          while ( (byte_80C2440[2 * v11 + 1] & 0x20) != 0 );
          v45 = *v12;
          v13 = v11;
        }
        v41 = (_BYTE *)v13;
        v45 = (int)v43;
        result = v11;
        if ( (_BYTE)v11 )
        {
          result = (int)v41;
          v41 = v6;
          for ( i = (_BYTE *)v45; ; ++i )
          {
            v15 = i + 1;
            ++v12;
            *i = dword_80C1B40[result];
            result = *v12;
            if ( !(_BYTE)result )
              break;
            if ( (byte_80C2440[2 * result + 1] & 0x20) != 0 )
            {
              v16 = i;
              v17 = v41;
              *v15 = 0;
              v45 = (int)(v16 + 2);
              do
                v18 = *++v12;
              while ( (byte_80C2440[2 * *v12 + 1] & 0x20) != 0 );
              v19 = (_BYTE *)v45;
              if ( v18 )
              {
                v41 = v15;
                v40 = v17;
                for ( j = (char *)v45; ; ++j )
                {
                  v19 = j + 1;
                  ++v12;
                  *j = v18;
                  v18 = *v12;
                  if ( !*v12 )
                  {
                    v15 = v41;
                    v17 = v40;
                    goto LABEL_27;
                  }
                  if ( (byte_80C2440[2 * v18 + 1] & 0x20) != 0 )
                    break;
                }
                *v19 = 0;
                v39 = j;
                v15 = v41;
                v17 = v40;
                v37 = strtol(v12, v46, 10);
                v22 = v37;
                if ( v46[0] == v12 || v37 <= 0 )
                  v22 = 1;
                v21 = v39 + 2;
              }
              else
              {
LABEL_27:
                v21 = v19 + 1;
                *v19 = 0;
                v22 = 1;
              }
              result = (unsigned __int8)v15[1];
              if ( (_BYTE)result )
              {
                v23 = (_BYTE)result == 47;
                v24 = 0;
                if ( !v23 )
                  v24 = v44;
                v25 = 3;
                v44 = v24;
                v40 = &v21[-v45];
                if ( (int)&v21[-v45] > 3 )
                {
                  v41 = (_BYTE *)v22;
                  v25 = strcmp(v21 - 4, ".so");
                  if ( v25 )
                    v25 = 3;
                }
                v41 = (_BYTE *)v22;
                v39 = (char *)(v43 - v17);
                v26 = j_strnlen(v17, v43 - v17);
                v27 = alloca(v26 + 16);
                v38[v26] = 0;
                v46[0] = memcpy(v38, v17, v26);
                result = (int)tfind((int)v46, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
                if ( !result )
                {
                  result = calloc(1u, v25 + v44 + v21 - v17 + 32);
                  v28 = (_DWORD *)result;
                  if ( result )
                  {
                    v29 = (_BYTE *)(result + 32);
                    *v28 = v29;
                    v30 = mempcpy(v29, v17, (unsigned int)v39);
                    v31 = v43;
                    v32 = (_BYTE *)v45;
                    v28[1] = v30;
                    v33 = mempcpy(v30, v31, v32 - v31);
                    v34 = (int)v41;
                    v28[4] = v33;
                    v28[3] = a6;
                    v35 = v44;
                    v28[2] = v34;
                    if ( v35 )
                      v33 = mempcpy(v33, v42, v44);
                    v36 = mempcpy(v33, (_BYTE *)v45, (unsigned int)v40);
                    if ( v25 )
                      *(_DWORD *)((char *)v36 - 1) = 7303982;
                    return insert_module((int)v28, 1);
                  }
                }
              }
              return result;
            }
          }
        }
        return result;
      }
      ++v10;
    }
  }
  return result;
}
// 80481C0: using guessed type int __cdecl j_strnlen(_DWORD, _DWORD);
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 80C1B40: using guessed type _DWORD dword_80C1B40[256];
// 80C2440: using guessed type _BYTE byte_80C2440[512];
// 80ECCDC: using guessed type int _gconv_alias_db;

//----- (08072C90) --------------------------------------------------------
int __usercall detect_conflict@<eax>(int a1@<eax>)
{
  _DWORD *v1; // ebx
  int v3; // eax

  v1 = (_DWORD *)_gconv_modules_db;
  if ( !_gconv_modules_db )
    return 0;
  while ( 1 )
  {
    v3 = j_strcmp(a1, *v1);
    if ( !v3 )
      break;
    if ( v3 >= 0 )
    {
      v1 = (_DWORD *)v1[7];
      if ( !v1 )
        return 0;
    }
    else
    {
      v1 = (_DWORD *)v1[5];
      if ( !v1 )
        return 0;
    }
  }
  return 1;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80ECCD4: using guessed type int _gconv_modules_db;

//----- (08072CF0) --------------------------------------------------------
int __usercall add_alias2_isra_0_part_1@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v4; // esi
  int result; // eax
  _DWORD *v7; // ebx
  _BYTE *v8; // eax

  v4 = a3 - (_DWORD)a1;
  result = malloc(a3 - (_DWORD)a1 + 8);
  if ( result )
  {
    v7 = (_DWORD *)result;
    v8 = memcpy((_BYTE *)(result + 8), a1, v4);
    *v7 = v8;
    v7[1] = &v8[a2 - (_DWORD)a1];
    result = tsearch((int)v7, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
    if ( !result || v7 != *(_DWORD **)result )
      return free(v7);
  }
  return result;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80ECCDC: using guessed type int _gconv_alias_db;

//----- (08072D60) --------------------------------------------------------
__int32 _gconv_get_path()
{
  __int32 result; // eax
  bool v2; // zf
  int v3; // eax
  void *v4; // esp
  _WORD *v5; // eax
  _WORD *v6; // eax
  _BYTE *v7; // eax
  char *v8; // edx
  int v9; // esi
  int v10; // edx
  int v11; // edi
  int v12; // ecx
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  int v16; // ecx
  _DWORD *v17; // esi
  char *v18; // edx
  char i; // al
  char *v20; // ebx
  char v21; // al
  _BYTE *j; // ecx
  int v23; // edi
  _WORD *v24; // eax
  _BYTE *v25; // eax
  _BYTE *v26; // edx
  unsigned int v27; // eax
  bool v28; // cc
  char v29; // al
  char *v30; // eax
  char v31; // dl
  _DWORD *v32; // eax
  char v33[32]; // [esp-20h] [ebp-58h] BYREF
  _BYTE v34[12]; // [esp+0h] [ebp-38h] BYREF
  char *v35; // [esp+Ch] [ebp-2Ch]
  int v36; // [esp+10h] [ebp-28h]
  int v37; // [esp+14h] [ebp-24h]
  int v38; // [esp+18h] [ebp-20h]
  _BYTE *v39; // [esp+1Ch] [ebp-1Ch]

  result = 0;
  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg ds:lock_11252, ecx }
  if ( !v2 )
    result = _lll_lock_wait_private(0, &lock_11252);
  if ( !_gconv_path_elem )
  {
    if ( _gconv_path_envvar )
    {
      v3 = strlen((_BYTE *)_gconv_path_envvar);
      v38 = v3 + 18;
      v4 = alloca(v3 + 33);
      v5 = mempcpy(v34, (_BYTE *)_gconv_path_envvar, v3);
      v6 = mempcpy(v5, ":", 1u);
      mempcpy(v6, "/usr/lib32/gconv", 0x11u);
      v7 = getcwd(0, 0);
      v39 = v7;
      if ( v7 )
      {
        v37 = strlen(v7);
        v36 = v37 + 1;
        v8 = v34;
      }
      else
      {
        v8 = v34;
        v36 = 1;
        v37 = 0;
      }
    }
    else
    {
      v36 = 1;
      v37 = 0;
      v39 = 0;
      v38 = 17;
      v8 = v33;
      strcpy(v33, "/usr/lib32/gconv");
    }
    v35 = v8;
    v9 = j_strchr(v8, 58);
    v10 = (int)v35;
    if ( v9 )
    {
      v11 = 1;
      v12 = 0;
      v13 = (int)v35;
      while ( 1 )
      {
        v11 += v9 != v12 + 1;
        v14 = j_strchr(v9 + 1, 58);
        v12 = v9;
        if ( !v14 )
          break;
        v9 = v14;
      }
      v15 = 8 * v11 + 8;
      v10 = v13;
      v16 = v36 * (v11 - 1);
    }
    else
    {
      v16 = 0;
      v11 = 1;
      v15 = 16;
    }
    v36 = v10;
    v17 = (_DWORD *)malloc(v38 + v11 + v16 + v15);
    if ( v17 )
    {
      v18 = (char *)v36;
      _gconv_max_path_elem_len = 0;
      for ( i = *(_BYTE *)v36; *v18 == 58; i = *v18 )
        ++v18;
      v20 = v18 + 1;
      if ( !i )
        _assert_fail("elem != NULL", "gconv_conf.c", 500, "__gconv_get_path");
      while ( 1 )
      {
        v21 = *v20;
        if ( !*v20 )
          break;
        ++v20;
        if ( v21 == 58 )
        {
          *(v20 - 1) = 0;
          break;
        }
      }
      j = &v17[2 * v11 + 2];
      v23 = 0;
      while ( 1 )
      {
LABEL_27:
        v2 = *v18 == 47;
        v17[2 * v23] = j;
        if ( !v2 )
        {
          if ( !v39 )
            _assert_fail("cwd != NULL", "gconv_conf.c", 506, "__gconv_get_path");
          v38 = (int)v18;
          v24 = mempcpy(j, v39, v37);
          v18 = (char *)v38;
          j = (char *)v24 + 1;
          *(_BYTE *)v24 = 47;
        }
        v25 = (_BYTE *)j_stpcpy(j, v18);
        v26 = v25;
        if ( *(v25 - 1) != 47 )
        {
          v26 = v25 + 1;
          *v25 = 47;
        }
        v27 = (unsigned int)&v26[-v17[2 * v23]];
        v28 = v27 <= _gconv_max_path_elem_len;
        v17[2 * v23 + 1] = v27;
        if ( !v28 )
          _gconv_max_path_elem_len = v27;
        *v26 = 0;
        v29 = *v20;
        ++v23;
        for ( j = v26 + 1; *v20 == 58; v29 = *v20 )
          ++v20;
        if ( !v29 )
          break;
        v30 = v20 + 1;
        do
        {
          v31 = *v30;
          if ( !*v30 )
          {
            v18 = v20;
            v20 = v30;
            goto LABEL_27;
          }
          ++v30;
        }
        while ( v31 != 58 );
        v18 = v20;
        *(v30 - 1) = 0;
        v20 = v30;
      }
      v32 = &v17[2 * v23];
      *v32 = 0;
      v32[1] = 0;
    }
    else
    {
      v17 = &empty_path_elem;
    }
    _gconv_path_elem = (int)v17;
    result = free(v39);
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --lock_11252 )
    return _lll_unlock_wake_private(&lock_11252);
  return result;
}
// 8048210: using guessed type int __cdecl j_stpcpy(_DWORD, _DWORD);
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EC5B4: using guessed type int lock_11252;
// 80ECCE0: using guessed type int _gconv_path_envvar;
// 80ECCE4: using guessed type int _gconv_max_path_elem_len;
// 80ECCE8: using guessed type int _gconv_path_elem;

//----- (080730B0) --------------------------------------------------------
int _gconv_read_conf()
{
  int v0; // eax
  _BYTE *v1; // ecx
  void *v2; // esp
  _WORD *v3; // eax
  int *v4; // eax
  int *v5; // ecx
  int v6; // eax
  int v7; // ebx
  char *v8; // esi
  char *v9; // eax
  int v10; // eax
  char *v11; // ebx
  int v12; // eax
  _BYTE *v13; // edi
  void ***v14; // esi
  char *v15; // ebx
  int v16; // esi
  int result; // eax
  int v18; // eax
  char i; // cl
  char *v20; // edx
  _BYTE *v21; // ecx
  char *v22; // edx
  int j; // eax
  char v24; // cl
  int v25; // eax
  _BYTE *k; // ebx
  _BYTE *v27; // ecx
  char *v28; // ebx
  char *v29; // edx
  int v30; // [esp-8h] [ebp-70h]
  _BYTE v31[12]; // [esp+0h] [ebp-68h] BYREF
  unsigned int v32; // [esp+Ch] [ebp-5Ch]
  char *v33; // [esp+10h] [ebp-58h]
  int v34; // [esp+14h] [ebp-54h]
  _BYTE *v35; // [esp+18h] [ebp-50h]
  unsigned int v36; // [esp+1Ch] [ebp-4Ch]
  _BYTE *v37; // [esp+20h] [ebp-48h]
  int v38; // [esp+24h] [ebp-44h]
  _BYTE *v39; // [esp+28h] [ebp-40h]
  int *v40; // [esp+2Ch] [ebp-3Ch]
  int v41; // [esp+3Ch] [ebp-2Ch] BYREF
  int v42; // [esp+40h] [ebp-28h] BYREF
  char *v43; // [esp+44h] [ebp-24h] BYREF
  unsigned int v44[8]; // [esp+48h] [ebp-20h] BYREF

  v41 = 0;
  v42 = 0;
  v32 = __readgsdword(0xFFFFFFE8);
  if ( _gconv_load_cache() )
  {
    v0 = _gconv_path_elem;
    if ( !_gconv_path_elem )
    {
      _gconv_get_path();
      v0 = _gconv_path_elem;
    }
    v1 = *(_BYTE **)v0;
    v38 = 8;
    v39 = v1;
    if ( v1 )
    {
      do
      {
        v36 = *(_DWORD *)(v0 + 4);
        v2 = alloca(v36 + 29);
        v3 = mempcpy(v31, v39, v36);
        mempcpy(v3, "gconv-modules", 0xEu);
        v4 = (int *)fopen((int)v31, "rce");
        v40 = v4;
        v43 = 0;
        v44[0] = 0;
        v5 = v4;
        if ( v4 )
        {
          v6 = *v4;
          v37 = (_BYTE *)v6;
          BYTE1(v6) |= 0x80u;
          *v5 = v6;
          if ( (v6 & 0x10) == 0 )
          {
            do
            {
              v7 = getdelim((int *)&v43, v44, 10, v40);
              if ( v7 < 0 )
                break;
              v8 = v43;
              v9 = (char *)j_strchr(v43, 35);
              if ( v9 )
              {
                *v9 = 0;
              }
              else
              {
                v29 = &v8[v7 - 1];
                if ( *v29 == 10 )
                  *v29 = 0;
              }
              while ( (byte_80C2440[2 * *v8 + 1] & 0x20) != 0 )
                ++v8;
              if ( v9 != v8 )
              {
                v10 = *v8;
                if ( (_BYTE)v10 )
                {
                  if ( (byte_80C2440[2 * v10 + 1] & 0x20) == 0 )
                  {
                    v11 = v8;
                    do
                      v12 = *++v11;
                    while ( (_BYTE)v12 && (byte_80C2440[2 * v12 + 1] & 0x20) == 0 );
                    if ( v11 - v8 == 5 )
                    {
                      if ( !j_memcmp(v8, "alias", 5) )
                      {
                        v18 = *v11;
                        for ( i = *v11; (byte_80C2440[2 * v18 + 1] & 0x20) != 0; i = *v11 )
                          v18 = *++v11;
                        v20 = v11;
                        if ( i )
                        {
                          while ( 1 )
                          {
                            v21 = v20 + 1;
                            *v20 = dword_80C1B40[v18];
                            v18 = v20[1];
                            if ( !(_BYTE)v18 )
                              break;
                            if ( (byte_80C2440[2 * v18 + 1] & 0x20) != 0 )
                            {
                              *v21 = 0;
                              v22 = v20 + 2;
                              v37 = v22;
                              v24 = v21[1];
                              for ( j = v24; (byte_80C2440[2 * j + 1] & 0x20) != 0; v24 = *v22 )
                                j = *++v22;
                              v34 = j;
                              v35 = v37;
                              if ( v24 )
                              {
                                v33 = v11;
                                v25 = v34;
                                for ( k = v35; ; ++k )
                                {
                                  v27 = k + 1;
                                  ++v22;
                                  *k = dword_80C1B40[v25];
                                  v25 = *v22;
                                  if ( !(_BYTE)v25 || (byte_80C2440[2 * v25 + 1] & 0x20) != 0 )
                                    break;
                                }
                                v35 = k;
                                v28 = v33;
                                if ( v37 != v27 )
                                {
                                  *v27 = 0;
                                  if ( !detect_conflict((int)v28) )
                                    add_alias2_isra_0_part_1(v28, (int)v37, (int)(v35 + 2));
                                }
                              }
                              break;
                            }
                            ++v20;
                          }
                        }
                      }
                    }
                    else if ( v11 - v8 == 6 && !j_memcmp(v8, "module", 6) )
                    {
                      v30 = modcounter_11232++;
                      add_module(v11, v39, v36, (int)&v41, (int)&v42, v30);
                    }
                  }
                }
              }
            }
            while ( (*v40 & 0x10) == 0 );
          }
          free(v43);
          fclose(v40);
        }
        v0 = v38 + _gconv_path_elem;
        v13 = *(_BYTE **)(v38 + _gconv_path_elem);
        v38 += 8;
        v39 = v13;
      }
      while ( v13 );
    }
    v14 = (void ***)builtin_modules;
    do
    {
      v44[0] = (unsigned int)*v14;
      if ( !tfind((int)v44, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare) )
        insert_module((int)v14, 0);
      v14 += 8;
    }
    while ( nl_global_locale != v14 );
    v15 = "UCS4//";
    do
    {
      v40 = (int *)(j_rawmemchr(v15, 0) + 1);
      v16 = j_rawmemchr(v40, 0);
      if ( !detect_conflict((int)v15) )
        add_alias2_isra_0_part_1(v15, (int)v40, v16 + 1);
      v15 = (char *)(v16 + 1);
    }
    while ( *(_BYTE *)(v16 + 1) );
  }
  result = -24;
  __writegsdword(0xFFFFFFE8, v32);
  return result;
}
// 80481E0: using guessed type int __cdecl j_rawmemchr(_DWORD, _DWORD);
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80C1B40: using guessed type _DWORD dword_80C1B40[256];
// 80C2440: using guessed type _BYTE byte_80C2440[512];
// 80EBD20: using guessed type char *builtin_modules[2];
// 80EBEA0: using guessed type void **nl_global_locale[6];
// 80EC5B0: using guessed type int modcounter_11232;
// 80ECCDC: using guessed type int _gconv_alias_db;
// 80ECCE8: using guessed type int _gconv_path_elem;

//----- (08073490) --------------------------------------------------------
int __usercall _gconv_get_builtin_trans@<eax>(int a1@<eax>, _DWORD *a2@<edx>)
{
  const char *v3; // eax
  int v5; // ebx
  unsigned int v6; // ebx
  int v7; // eax
  int result; // eax

  v3 = "=INTERNAL->ucs4";
  v5 = 0;
  while ( j_strcmp(a1, v3) )
  {
    if ( ++v5 == 12 )
      _assert_fail("cnt < sizeof (map) / sizeof (map[0])", "gconv_builtin.c", 71, "__gconv_get_builtin_trans");
    v3 = (&map_0)[4 * v5];
  }
  v6 = 16 * v5;
  a2[7] = 0;
  a2[8] = 0;
  v7 = *(int *)((char *)&off_80BFBC4 + v6);
  *a2 = 0;
  a2[1] = 0;
  a2[13] = 0;
  a2[5] = v7;
  a2[6] = dword_80BFBC8[v6 / 4];
  a2[9] = byte_80BFBCC[v6];
  a2[10] = byte_80BFBCD[v6];
  a2[11] = byte_80BFBCE[v6];
  result = byte_80BFBCF[v6];
  a2[12] = result;
  return result;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80BFBC0: using guessed type char *map_0;
// 80BFBC4: using guessed type int (__cdecl *off_80BFBC4)(int, int, int, int, int, int, int, int);
// 80BFBC8: using guessed type int dword_80BFBC8[];

//----- (08073550) --------------------------------------------------------
int __cdecl _gconv_btwoc_ascii(int a1, char a2)
{
  int result; // eax

  result = (unsigned __int8)a2;
  if ( a2 < 0 )
    return -1;
  return result;
}

//----- (08073570) --------------------------------------------------------
int __usercall _gconv_transform_internal_ucs4@<eax>(
        long double a1@<st0>,
        int a2,
        int a3,
        unsigned int *a4,
        unsigned int a5,
        unsigned int *a6,
        int a7,
        int a8,
        int a9)
{
  unsigned int v9; // ebp
  unsigned int *v10; // ecx
  unsigned int v11; // ebx
  unsigned int v12; // edx
  unsigned int v13; // eax
  unsigned int v14; // ebx
  signed int v15; // eax
  int v16; // ecx
  int v17; // eax
  int v18; // ecx
  unsigned int v19; // edi
  int v20; // ebx
  int v21; // eax
  int v22; // eax
  unsigned int v23; // ebp
  int v24; // ecx
  int v25; // ebx
  unsigned int v26; // eax
  _DWORD *v28; // eax
  unsigned int v29; // edx
  unsigned int v30; // [esp+Ch] [ebp-40h]
  int (__cdecl *v31)(int, int, unsigned int *, unsigned int, _DWORD, int, int, int); // [esp+10h] [ebp-3Ch]
  int v32; // [esp+14h] [ebp-38h]
  int v33; // [esp+18h] [ebp-34h]
  unsigned int v34; // [esp+1Ch] [ebp-30h]
  unsigned int v35[8]; // [esp+2Ch] [ebp-20h] BYREF

  v31 = 0;
  v32 = a2 + 60;
  v33 = a3 + 32;
  if ( (*(_BYTE *)(a3 + 8) & 1) == 0 )
  {
    v31 = *(int (__cdecl **)(int, int, unsigned int *, unsigned int, _DWORD, int, int, int))(a2 + 80);
    if ( *(_DWORD *)(a2 + 60) )
      v31 = (int (__cdecl *)(int, int, unsigned int *, unsigned int, _DWORD, int, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a2 + 80), 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 415, "__gconv_transform_internal_ucs4");
    v28 = *(_DWORD **)(a3 + 20);
    v20 = 0;
    *v28 = 0;
    v28[1] = 0;
    if ( (*(_BYTE *)(a3 + 8) & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v31);
      return v31(v32, v33, 0, 0, 0, a7, a8, a9);
    }
    return v20;
  }
  if ( a6 )
    v9 = *a6;
  else
    v9 = *(_DWORD *)a3;
  v30 = *(_DWORD *)(a3 + 4);
  if ( a9 )
  {
    v10 = *(unsigned int **)(a3 + 20);
    v11 = *v10;
    v12 = *v10 & 7;
    if ( v12 )
    {
      if ( a6 )
        _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 559, "__gconv_transform_internal_ucs4");
      v13 = *a4;
      if ( a5 > *a4 )
      {
        if ( v12 > 3 )
          goto LABEL_17;
        v34 = *v10;
        while ( 1 )
        {
          ++v13;
          ++v12;
          *a4 = v13;
          *((_BYTE *)v10 + v12 + 3) = *(_BYTE *)(v13 - 1);
          if ( a5 == v13 )
            break;
          if ( v12 == 4 )
            goto LABEL_17;
        }
        v11 = v34;
      }
      if ( v12 <= 3 )
      {
        v29 = v11 & 0xFFFFFFF8 | v12;
        v20 = 7;
        *v10 = v29;
        return v20;
      }
LABEL_17:
      v9 += 4;
      *(_BYTE *)(v9 - 4) = *((_BYTE *)v10 + 7);
      *(_BYTE *)(v9 - 3) = *((_BYTE *)v10 + 6);
      *(_BYTE *)(v9 - 2) = *((_BYTE *)v10 + 5);
      *(_BYTE *)(v9 - 1) = *((_BYTE *)v10 + 4);
      *v10 &= 0xFFFFFFF8;
      goto LABEL_18;
    }
  }
  while ( 1 )
  {
LABEL_18:
    v14 = *a4;
    v15 = a5 - *a4;
    if ( (int)(v30 - v9) <= v15 )
      v15 = v30 - v9;
    v16 = v15 / 4;
    if ( v15 / 4 )
    {
      v17 = 0;
      do
      {
        *(_DWORD *)(v9 + 4 * v17) = _byteswap_ulong(*(_DWORD *)(v14 + 4 * v17));
        ++v17;
      }
      while ( v16 != v17 );
      v18 = 4 * v16;
      v19 = v9 + v18;
      v14 += v18;
    }
    else
    {
      v19 = v9;
    }
    *a4 = v14;
    if ( a5 == v14 )
    {
      v20 = 4;
      if ( a6 )
      {
LABEL_43:
        *a6 = v19;
        return v20;
      }
    }
    else
    {
      v20 = v30 < v19 + 4 ? 5 : 7;
      if ( a6 )
        goto LABEL_43;
    }
    ++*(_DWORD *)(a3 + 12);
    if ( (*(_BYTE *)(a3 + 8) & 1) != 0 )
    {
      *(_DWORD *)a3 = v19;
      goto LABEL_34;
    }
    if ( v9 >= v19 )
      goto LABEL_34;
    v35[0] = *(_DWORD *)a3;
    dl_mcount_wrapper_check((int)v31);
    v21 = v31(v32, v33, v35, v19, 0, a7, 0, a9);
    if ( v21 != 4 )
      break;
    if ( v20 != 5 )
      goto LABEL_34;
LABEL_32:
    v9 = *(_DWORD *)a3;
  }
  if ( v35[0] != v19 )
    *a4 -= v19 - v35[0];
  if ( !v21 )
    goto LABEL_32;
  v20 = v21;
LABEL_34:
  if ( v20 == 7 && a9 )
  {
    if ( (int)(a5 - *a4) > 3 )
      _assert_fail(a1, (int)"inend - *inptrp < 4", (int)"../iconv/skeleton.c", 777, "__gconv_transform_internal_ucs4");
    v22 = *a4;
    v23 = *a4;
    if ( a5 <= *a4 )
    {
      v26 = 0;
    }
    else
    {
      do
      {
        v24 = v22++;
        v25 = *(_DWORD *)(a3 + 20);
        *a4 = v22;
        *(_BYTE *)(v25 + v24 - v23 + 4) = *(_BYTE *)(v22 - 1);
      }
      while ( a5 != v22 );
      v26 = a5 - v23;
    }
    v20 = 7;
    **(_DWORD **)(a3 + 20) = **(_DWORD **)(a3 + 20) & 0xFFFFFFF8 | v26;
  }
  return v20;
}
// 8073570: using guessed type unsigned int var_20[8];

//----- (080738D0) --------------------------------------------------------
int __usercall _gconv_transform_ucs4_internal@<eax>(
        long double a1@<st0>,
        int a2,
        int a3,
        unsigned int **a4,
        unsigned int *a5,
        int **a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  int v9; // ebp
  unsigned int v10; // eax
  int *v11; // eax
  unsigned int *v12; // ecx
  unsigned int v13; // esi
  unsigned int v14; // edx
  unsigned int *v15; // ebx
  unsigned int *v16; // eax
  int *v17; // ebx
  unsigned int *v18; // edx
  signed int v19; // eax
  int v20; // esi
  int v21; // ecx
  int v22; // ebp
  int v23; // eax
  int v24; // esi
  int v26; // eax
  unsigned int *v27; // eax
  unsigned int *v28; // ebp
  unsigned int *v29; // ecx
  int v30; // ebx
  int v31; // eax
  _DWORD *v32; // eax
  unsigned int v33; // eax
  int *v34; // [esp+8h] [ebp-54h]
  unsigned int v35; // [esp+Ch] [ebp-50h]
  int *v36; // [esp+10h] [ebp-4Ch]
  int (__cdecl *v37)(int, int, int **, int *, _DWORD, _DWORD *, int, int); // [esp+14h] [ebp-48h]
  int v38; // [esp+18h] [ebp-44h]
  int v39; // [esp+1Ch] [ebp-40h]
  unsigned int *v40; // [esp+20h] [ebp-3Ch]
  unsigned int v41; // [esp+24h] [ebp-38h]
  int v42; // [esp+38h] [ebp-24h] BYREF
  int *v43; // [esp+3Ch] [ebp-20h] BYREF

  v37 = 0;
  v9 = *(_DWORD *)(a3 + 8);
  v38 = a2 + 60;
  v39 = a3 + 32;
  if ( (v9 & 1) == 0 )
  {
    v37 = *(int (__cdecl **)(int, int, int **, int *, _DWORD, _DWORD *, int, int))(a2 + 80);
    if ( *(_DWORD *)(a2 + 60) )
      v37 = (int (__cdecl *)(int, int, int **, int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a2 + 80), 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 415, "__gconv_transform_ucs4_internal");
    v32 = *(_DWORD **)(a3 + 20);
    v24 = 0;
    *v32 = 0;
    v32[1] = 0;
    if ( (*(_BYTE *)(a3 + 8) & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v37);
      return v37(v38, v39, 0, 0, 0, a7, a8, a9);
    }
    return v24;
  }
  if ( a6 )
    v34 = *a6;
  else
    v34 = *(int **)a3;
  v10 = *(_DWORD *)(a3 + 4);
  v42 = 0;
  v35 = v10;
  v11 = 0;
  if ( a7 )
    v11 = &v42;
  v36 = v11;
  if ( !a9 || (v12 = *(unsigned int **)(a3 + 20), v13 = *v12, (v41 = *v12 & 7) == 0) )
  {
    while ( 1 )
    {
LABEL_22:
      v17 = v34;
      v18 = *a4;
      v19 = (char *)a5 - (char *)*a4;
      if ( (int)(v35 - (_DWORD)v34) <= v19 )
        v19 = v35 - (_DWORD)v34;
      v20 = v19 / 4;
      if ( v19 / 4 )
      {
        v21 = 0;
        v22 = v9 & 2;
        while ( 1 )
        {
          while ( 1 )
          {
            v23 = _byteswap_ulong(*v18);
            if ( v23 < 0 )
              break;
            ++v21;
            *v17 = v23;
            ++v18;
            ++v17;
            if ( v20 == v21 )
              goto LABEL_31;
          }
          if ( !v36 )
            break;
          if ( !v22 )
          {
            v24 = 6;
            *a4 = v18;
            goto LABEL_36;
          }
          ++v21;
          ++*v36;
          ++v18;
          if ( v20 == v21 )
            goto LABEL_31;
        }
        v17 = v34;
        v24 = 6;
      }
      else
      {
        v17 = v34;
LABEL_31:
        *a4 = v18;
        if ( v18 != a5 )
        {
          v24 = v35 < (unsigned int)(v17 + 1) ? 5 : 7;
          if ( a6 )
            goto LABEL_33;
          goto LABEL_37;
        }
        v24 = 4;
      }
LABEL_36:
      if ( a6 )
      {
LABEL_33:
        *a6 = v17;
        return v24;
      }
LABEL_37:
      ++*(_DWORD *)(a3 + 12);
      if ( (*(_BYTE *)(a3 + 8) & 1) != 0 )
      {
        *(_DWORD *)a3 = v17;
        *a7 += v42;
        goto LABEL_45;
      }
      if ( v34 >= v17 )
        goto LABEL_45;
      v43 = *(int **)a3;
      dl_mcount_wrapper_check((int)v37);
      v26 = v37(v38, v39, &v43, v17, 0, a7, 0, a9);
      if ( v26 == 4 )
      {
        if ( v24 != 5 )
          goto LABEL_45;
      }
      else
      {
        if ( v43 != v17 )
          *a4 = (unsigned int *)((char *)*a4 - ((char *)v17 - (char *)v43));
        if ( v26 )
        {
          v24 = v26;
LABEL_45:
          if ( v24 == 7 && a9 )
          {
            if ( (char *)a5 - (char *)*a4 > 3 )
              _assert_fail(
                a1,
                (int)"inend - *inptrp < 4",
                (int)"../iconv/skeleton.c",
                777,
                "__gconv_transform_ucs4_internal");
            v27 = *a4;
            v28 = *a4;
            if ( a5 <= *a4 )
            {
              v31 = 0;
            }
            else
            {
              do
              {
                v29 = v27;
                v27 = (unsigned int *)((char *)v27 + 1);
                v30 = *(_DWORD *)(a3 + 20);
                *a4 = v27;
                *(_BYTE *)(v30 + (char *)v29 - (char *)v28 + 4) = *((_BYTE *)v27 - 1);
              }
              while ( a5 != v27 );
              v31 = (char *)a5 - (char *)v28;
            }
            **(_DWORD **)(a3 + 20) = **(_DWORD **)(a3 + 20) & 0xFFFFFFF8 | v31;
          }
          return v24;
        }
      }
      v9 = *(_DWORD *)(a3 + 8);
      v34 = *(int **)a3;
    }
  }
  if ( a6 )
    _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 559, "__gconv_transform_ucs4_internal");
  v14 = *v12 & 7;
  v15 = *a4;
  if ( a5 > *a4 )
  {
    if ( v41 > 3 )
    {
      v14 = *v12 & 7;
LABEL_19:
      if ( *((_BYTE *)v12 + 4) > 0x80u )
      {
        if ( (v9 & 2) == 0 )
        {
          v24 = 6;
          *a4 = (unsigned int *)((char *)v15 + v41 - v14);
          return v24;
        }
      }
      else
      {
        *(_BYTE *)v34 = *((_BYTE *)v12 + 7);
        *((_BYTE *)v34 + 1) = *((_BYTE *)v12 + 6);
        *((_BYTE *)v34 + 2) = *((_BYTE *)v12 + 5);
        *((_BYTE *)v34++ + 3) = *((_BYTE *)v12 + 4);
        v13 = *v12;
      }
      v9 = *(_DWORD *)(a3 + 8);
      *v12 = v13 & 0xFFFFFFF8;
      goto LABEL_22;
    }
    v16 = (unsigned int *)((char *)v15 + 1);
    while ( 1 )
    {
      *a4 = v16;
      ++v14;
      v40 = v16;
      *((_BYTE *)v12 + v14 + 3) = *((_BYTE *)v16 - 1);
      if ( a5 == v16 )
        break;
      v16 = (unsigned int *)((char *)v16 + 1);
      if ( v14 == 4 )
      {
        v15 = v40;
        goto LABEL_19;
      }
    }
    v15 = v16;
  }
  if ( v14 > 3 )
    goto LABEL_19;
  v33 = v13;
  v24 = 7;
  *v12 = v33 & 0xFFFFFFF8 | v14;
  return v24;
}

//----- (08073D40) --------------------------------------------------------
int __usercall _gconv_transform_internal_ucs4le@<eax>(
        long double a1@<st0>,
        int a2,
        int a3,
        _DWORD *a4,
        _BYTE *a5,
        char **a6,
        int a7,
        int a8,
        int a9)
{
  int v9; // ebx
  char *v10; // edi
  _BYTE *v11; // edx
  int v12; // ecx
  int v13; // eax
  unsigned int v14; // eax
  char *v15; // ecx
  int v16; // esi
  int v17; // eax
  int v18; // edx
  _BYTE *v19; // eax
  _BYTE *v20; // ecx
  int v21; // esi
  int v22; // eax
  unsigned int *v24; // ecx
  unsigned int v25; // esi
  unsigned int v26; // edx
  _BYTE *v27; // eax
  _DWORD *v28; // eax
  char *v29; // [esp+Ch] [ebp-40h]
  _BYTE *v30; // [esp+Ch] [ebp-40h]
  unsigned int v31; // [esp+Ch] [ebp-40h]
  unsigned int v32; // [esp+10h] [ebp-3Ch]
  int (__cdecl *v33)(int, int, char **, char *, _DWORD, int, int, int); // [esp+14h] [ebp-38h]
  int v34; // [esp+18h] [ebp-34h]
  int v35; // [esp+1Ch] [ebp-30h]
  char *v36; // [esp+2Ch] [ebp-20h] BYREF

  v9 = a3;
  v33 = 0;
  v34 = a2 + 60;
  v35 = a3 + 32;
  if ( (*(_BYTE *)(a3 + 8) & 1) == 0 )
  {
    v33 = *(int (__cdecl **)(int, int, char **, char *, _DWORD, int, int, int))(a2 + 80);
    if ( *(_DWORD *)(a2 + 60) )
      v33 = (int (__cdecl *)(int, int, char **, char *, _DWORD, int, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a2 + 80), 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 415, "__gconv_transform_internal_ucs4le");
    v28 = *(_DWORD **)(a3 + 20);
    v18 = 0;
    *v28 = 0;
    v28[1] = 0;
    if ( (*(_BYTE *)(a3 + 8) & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v33);
      return v33(v34, v35, 0, 0, 0, a7, a8, a9);
    }
    return v18;
  }
  if ( a6 )
    v10 = *a6;
  else
    v10 = *(char **)a3;
  v32 = *(_DWORD *)(a3 + 4);
  if ( a9 )
  {
    v24 = *(unsigned int **)(a3 + 20);
    v25 = *v24;
    v26 = *v24 & 7;
    if ( v26 )
    {
      if ( a6 )
        _assert_fail(
          a1,
          (int)"outbufstart == NULL",
          (int)"../iconv/skeleton.c",
          559,
          "__gconv_transform_internal_ucs4le");
      v27 = (_BYTE *)*a4;
      if ( (unsigned int)a5 > *a4 )
      {
        if ( v26 > 3 )
          goto LABEL_43;
        v31 = *v24;
        while ( 1 )
        {
          ++v27;
          ++v26;
          *a4 = v27;
          *((_BYTE *)v24 + v26 + 3) = *(v27 - 1);
          if ( a5 == v27 )
            break;
          if ( v26 == 4 )
          {
            v9 = a3;
            goto LABEL_43;
          }
        }
        v25 = v31;
        v9 = a3;
      }
      if ( v26 <= 3 )
      {
        *v24 = v25 & 0xFFFFFFF8 | v26;
        return 7;
      }
LABEL_43:
      v10 += 4;
      *(v10 - 4) = *((_BYTE *)v24 + 4);
      *(v10 - 3) = *((_BYTE *)v24 + 5);
      *(v10 - 2) = *((_BYTE *)v24 + 6);
      *(v10 - 1) = *((_BYTE *)v24 + 7);
      *v24 &= 0xFFFFFFF8;
      goto LABEL_8;
    }
  }
  while ( 1 )
  {
LABEL_8:
    v11 = (_BYTE *)*a4;
    v12 = (int)&a5[-*a4];
    if ( (int)(v32 - (_DWORD)v10) <= v12 )
      v12 = v32 - (_DWORD)v10;
    v13 = v12 + 3;
    if ( v12 >= 0 )
      v13 = v12;
    v14 = v13 & 0xFFFFFFFC;
    *a4 = &v11[v14];
    v15 = (char *)mempcpy(v10, v11, v14);
    if ( a5 == (_BYTE *)*a4 )
    {
      v16 = 4;
      if ( a6 )
      {
LABEL_33:
        *a6 = v15;
        return v16;
      }
    }
    else
    {
      v16 = v32 < (unsigned int)(v15 + 4) ? 5 : 7;
      if ( a6 )
        goto LABEL_33;
    }
    ++*(_DWORD *)(v9 + 12);
    if ( (*(_BYTE *)(v9 + 8) & 1) != 0 )
    {
      v18 = v16;
      *(_DWORD *)v9 = v15;
      goto LABEL_23;
    }
    v29 = v15;
    if ( v15 <= v10 )
      goto LABEL_22;
    v36 = *(char **)v9;
    dl_mcount_wrapper_check((int)v33);
    v17 = v33(v34, v35, &v36, v29, 0, a7, 0, a9);
    if ( v17 != 4 )
      break;
    if ( v16 != 5 )
    {
LABEL_22:
      v18 = v16;
      goto LABEL_23;
    }
LABEL_20:
    v10 = *(char **)v9;
  }
  if ( v36 != v29 )
    *a4 -= v29 - v36;
  if ( !v17 )
    goto LABEL_20;
  v18 = v17;
LABEL_23:
  if ( v18 == 7 && a9 )
  {
    if ( (int)&a5[-*a4] > 3 )
      _assert_fail(a1, (int)"inend - *inptrp < 4", (int)"../iconv/skeleton.c", 777, "__gconv_transform_internal_ucs4le");
    v19 = (_BYTE *)*a4;
    if ( (unsigned int)a5 <= *a4 )
    {
      v22 = 0;
    }
    else
    {
      v30 = (_BYTE *)*a4;
      do
      {
        v20 = v19++;
        v21 = *(_DWORD *)(v9 + 20);
        *a4 = v19;
        *(_BYTE *)(v21 + v20 - v30 + 4) = *(v19 - 1);
      }
      while ( a5 != v19 );
      v22 = a5 - v30;
    }
    v18 = 7;
    **(_DWORD **)(v9 + 20) = **(_DWORD **)(v9 + 20) & 0xFFFFFFF8 | v22;
  }
  return v18;
}

//----- (080740E0) --------------------------------------------------------
int __usercall _gconv_transform_ucs4le_internal@<eax>(
        long double a1@<st0>,
        int a2,
        int a3,
        unsigned int *a4,
        unsigned int a5,
        _BYTE **a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  int v9; // ebp
  unsigned int v10; // eax
  int *v11; // eax
  unsigned int *v12; // ecx
  unsigned int v13; // ebx
  unsigned int v14; // edx
  int *v15; // eax
  _DWORD *v16; // ebx
  int *v17; // eax
  signed int v18; // edx
  int v19; // esi
  int v20; // edx
  int v21; // ebp
  int v22; // esi
  int v24; // eax
  unsigned int v25; // eax
  unsigned int v26; // ebp
  unsigned int v27; // ecx
  int v28; // ebx
  unsigned int v29; // eax
  _DWORD *v30; // eax
  _BYTE *v31; // [esp+4h] [ebp-48h]
  int *v32; // [esp+8h] [ebp-44h]
  unsigned int v33; // [esp+Ch] [ebp-40h]
  int (__cdecl *v34)(int, int, int *, _DWORD *, _DWORD, _DWORD *, int, int); // [esp+10h] [ebp-3Ch]
  int v35; // [esp+14h] [ebp-38h]
  int v36; // [esp+18h] [ebp-34h]
  unsigned int v37; // [esp+1Ch] [ebp-30h]
  int v38; // [esp+28h] [ebp-24h] BYREF
  int v39[8]; // [esp+2Ch] [ebp-20h] BYREF

  v34 = 0;
  v9 = *(_DWORD *)(a3 + 8);
  v35 = a2 + 60;
  v36 = a3 + 32;
  if ( (v9 & 1) == 0 )
  {
    v34 = *(int (__cdecl **)(int, int, int *, _DWORD *, _DWORD, _DWORD *, int, int))(a2 + 80);
    if ( *(_DWORD *)(a2 + 60) )
      v34 = (int (__cdecl *)(int, int, int *, _DWORD *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a2 + 80), 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 415, "__gconv_transform_ucs4le_internal");
    v30 = *(_DWORD **)(a3 + 20);
    v22 = 0;
    *v30 = 0;
    v30[1] = 0;
    if ( (*(_BYTE *)(a3 + 8) & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v34);
      return v34(v35, v36, 0, 0, 0, a7, a8, a9);
    }
    return v22;
  }
  if ( a6 )
    v31 = *a6;
  else
    v31 = *(_BYTE **)a3;
  v10 = *(_DWORD *)(a3 + 4);
  v38 = 0;
  v33 = v10;
  v11 = 0;
  if ( a7 )
    v11 = &v38;
  v32 = v11;
  if ( a9 )
  {
    v12 = *(unsigned int **)(a3 + 20);
    v13 = *v12;
    v14 = *v12 & 7;
    if ( v14 )
    {
      if ( a6 )
        _assert_fail(
          a1,
          (int)"outbufstart == NULL",
          (int)"../iconv/skeleton.c",
          559,
          "__gconv_transform_ucs4le_internal");
      v15 = (int *)*a4;
      if ( a5 > *a4 )
      {
        if ( v14 > 3 )
        {
LABEL_19:
          if ( *((_BYTE *)v12 + 7) > 0x80u )
            goto LABEL_65;
          goto LABEL_20;
        }
        v37 = *v12;
        while ( 1 )
        {
          v15 = (int *)((char *)v15 + 1);
          ++v14;
          *a4 = (unsigned int)v15;
          *((_BYTE *)v12 + v14 + 3) = *((_BYTE *)v15 - 1);
          if ( (int *)a5 == v15 )
            break;
          if ( v14 == 4 )
          {
            v13 = v37;
            if ( *((_BYTE *)v12 + 7) > 0x80u )
            {
LABEL_65:
              if ( (v9 & 2) == 0 )
                return 6;
LABEL_21:
              v9 = *(_DWORD *)(a3 + 8);
              *v12 = v13 & 0xFFFFFFF8;
              goto LABEL_22;
            }
LABEL_20:
            *v31 = *((_BYTE *)v12 + 4);
            v31[1] = *((_BYTE *)v12 + 5);
            v31[2] = *((_BYTE *)v12 + 6);
            v31[3] = *((_BYTE *)v12 + 7);
            v13 = *v12;
            v31 += 4;
            goto LABEL_21;
          }
        }
        v13 = v37;
      }
      if ( v14 <= 3 )
      {
        v22 = 7;
        *v12 = v13 & 0xFFFFFFF8 | v14;
        return v22;
      }
      goto LABEL_19;
    }
  }
  while ( 1 )
  {
LABEL_22:
    v16 = v31;
    v17 = (int *)*a4;
    v18 = a5 - *a4;
    if ( (int)(v33 - (_DWORD)v31) <= v18 )
      v18 = v33 - (_DWORD)v31;
    v19 = v18 / 4;
    if ( v18 / 4 )
    {
      v20 = 0;
      v21 = v9 & 2;
      while ( 1 )
      {
        while ( *v17 >= 0 )
        {
          ++v20;
          *v16++ = *v17++;
          if ( v19 == v20 )
            goto LABEL_31;
        }
        if ( !v32 )
          break;
        if ( !v21 )
        {
          *a4 = (unsigned int)v17;
          v22 = 6;
          goto LABEL_38;
        }
        ++v20;
        ++*v32;
        ++v17;
        if ( v19 == v20 )
          goto LABEL_31;
      }
      v16 = v31;
      v22 = 6;
LABEL_38:
      if ( a6 )
        goto LABEL_35;
      goto LABEL_39;
    }
    v16 = v31;
LABEL_31:
    *a4 = (unsigned int)v17;
    if ( v17 == (int *)a5 )
    {
      v22 = 4;
      goto LABEL_38;
    }
    if ( a5 < (unsigned int)(v17 + 1) )
    {
      v22 = 7;
      goto LABEL_38;
    }
    if ( v33 >= (unsigned int)(v16 + 1) )
      _assert_fail(a1, (int)"*outptrp + 4 > outend", (int)"gconv_simple.c", 660, "ucs4le_internal_loop");
    v22 = 5;
    if ( a6 )
    {
LABEL_35:
      *a6 = v16;
      return v22;
    }
LABEL_39:
    ++*(_DWORD *)(a3 + 12);
    if ( (*(_BYTE *)(a3 + 8) & 1) != 0 )
    {
      *(_DWORD *)a3 = v16;
      *a7 += v38;
      goto LABEL_47;
    }
    if ( v31 >= (_BYTE *)v16 )
      goto LABEL_47;
    v39[0] = *(_DWORD *)a3;
    dl_mcount_wrapper_check((int)v34);
    v24 = v34(v35, v36, v39, v16, 0, a7, 0, a9);
    if ( v24 != 4 )
      break;
    if ( v22 != 5 )
      goto LABEL_47;
LABEL_45:
    v9 = *(_DWORD *)(a3 + 8);
    v31 = *(_BYTE **)a3;
  }
  if ( (_DWORD *)v39[0] != v16 )
    *a4 -= (unsigned int)v16 - v39[0];
  if ( !v24 )
    goto LABEL_45;
  v22 = v24;
LABEL_47:
  if ( a9 && v22 == 7 )
  {
    if ( (int)(a5 - *a4) > 3 )
      _assert_fail(a1, (int)"inend - *inptrp < 4", (int)"../iconv/skeleton.c", 777, "__gconv_transform_ucs4le_internal");
    v25 = *a4;
    v26 = *a4;
    if ( a5 <= *a4 )
    {
      v29 = 0;
    }
    else
    {
      do
      {
        v27 = v25++;
        v28 = *(_DWORD *)(a3 + 20);
        *a4 = v25;
        *(_BYTE *)(v28 + v27 - v26 + 4) = *(_BYTE *)(v25 - 1);
      }
      while ( a5 != v25 );
      v29 = a5 - v26;
    }
    **(_DWORD **)(a3 + 20) = **(_DWORD **)(a3 + 20) & 0xFFFFFFF8 | v29;
  }
  return v22;
}
// 80740E0: using guessed type int var_20[8];

//----- (08074530) --------------------------------------------------------
int __usercall _gconv_transform_ascii_internal@<eax>(
        long double a1@<st0>,
        int a2,
        unsigned int *a3,
        int *a4,
        int a5,
        unsigned int *a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  unsigned int v9; // edi
  unsigned int v10; // eax
  int *v11; // eax
  int v12; // esi
  _DWORD *v13; // ecx
  int v14; // eax
  _DWORD *v15; // ebx
  int v16; // edx
  int v17; // edi
  int v19; // eax
  _DWORD *v20; // eax
  unsigned int v21; // [esp+0h] [ebp-4Ch]
  unsigned int v22; // [esp+4h] [ebp-48h]
  int v23; // [esp+8h] [ebp-44h]
  int v24; // [esp+Ch] [ebp-40h]
  int (__cdecl *v25)(int, _DWORD *, int *, _DWORD *, _DWORD, _DWORD *, int, int); // [esp+10h] [ebp-3Ch]
  int v26; // [esp+14h] [ebp-38h]
  _DWORD *v27; // [esp+18h] [ebp-34h]
  int *v28; // [esp+1Ch] [ebp-30h]
  int v29; // [esp+28h] [ebp-24h] BYREF
  int v30[8]; // [esp+2Ch] [ebp-20h] BYREF

  v25 = 0;
  v26 = a2 + 60;
  v27 = a3 + 8;
  v9 = a3[2];
  if ( (v9 & 1) == 0 )
  {
    v25 = *(int (__cdecl **)(int, _DWORD *, int *, _DWORD *, _DWORD, _DWORD *, int, int))(a2 + 80);
    if ( *(_DWORD *)(a2 + 60) )
      v25 = (int (__cdecl *)(int, _DWORD *, int *, _DWORD *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a2 + 80), 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 415, "__gconv_transform_ascii_internal");
    v20 = (_DWORD *)a3[5];
    v23 = 0;
    *v20 = 0;
    v20[1] = 0;
    if ( (a3[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v25);
      return v25(v26, v27, 0, 0, 0, a7, a8, a9);
    }
    return v23;
  }
  if ( a6 )
    v22 = *a6;
  else
    v22 = *a3;
  v10 = a3[1];
  v29 = 0;
  v21 = v10;
  v11 = 0;
  if ( a7 )
    v11 = &v29;
  v28 = v11;
  while ( 1 )
  {
    v12 = *a4;
    if ( *a4 != a5 )
      break;
    v12 = a5;
    v15 = (_DWORD *)v22;
    v23 = 4;
LABEL_23:
    *a4 = v12;
    if ( a6 )
      goto LABEL_20;
LABEL_24:
    ++a3[3];
    if ( (a3[2] & 1) != 0 )
    {
      *a3 = (unsigned int)v15;
      *a7 += v29;
      return v23;
    }
    if ( (unsigned int)v15 <= v22 )
      return v23;
    v30[0] = *a3;
    dl_mcount_wrapper_check((int)v25);
    v19 = v25(v26, v27, v30, v15, 0, a7, 0, a9);
    if ( v19 == 4 )
    {
      if ( v23 != 5 )
        return v23;
    }
    else
    {
      if ( v15 != (_DWORD *)v30[0] )
        *a4 -= ((int)v15 - v30[0]) / 4;
      if ( v19 )
        return v19;
    }
    v9 = a3[2];
    v22 = *a3;
  }
  v13 = (_DWORD *)(v22 + 4);
  if ( v21 < v22 + 4 )
  {
    v15 = (_DWORD *)v22;
    v23 = 5;
    goto LABEL_23;
  }
  v14 = v12 + 1;
  v15 = (_DWORD *)v22;
  v23 = 4;
  v24 = v9 & 2;
  while ( 1 )
  {
    v16 = *(unsigned __int8 *)(v14 - 1);
    v12 = v14 - 1;
    v17 = v14;
    if ( (v16 & 0x80u) != 0 )
      break;
    *v15 = v16;
    v15 = v13;
    if ( a5 == v14 )
      goto LABEL_19;
LABEL_14:
    v13 = v15 + 1;
    ++v14;
    if ( v21 < (unsigned int)(v15 + 1) )
    {
      v12 = v17;
      v23 = 5;
      goto LABEL_23;
    }
  }
  if ( !v28 || !v24 )
  {
    v23 = 6;
    goto LABEL_23;
  }
  ++*v28;
  v23 = 6;
  if ( a5 != v14 )
    goto LABEL_14;
LABEL_19:
  *a4 = a5;
  if ( !a6 )
    goto LABEL_24;
LABEL_20:
  *a6 = (unsigned int)v15;
  return v23;
}
// 8074530: using guessed type int var_20[8];

//----- (08074820) --------------------------------------------------------
int __usercall _gconv_transform_internal_ascii@<eax>(
        long double a1@<st0>,
        _DWORD *a2,
        unsigned int **a3,
        int *a4,
        unsigned int *a5,
        unsigned int **a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  unsigned int *v9; // ebp
  unsigned int *v10; // eax
  unsigned int *v11; // ecx
  int *v12; // edx
  unsigned int *v13; // edx
  unsigned int v14; // ebp
  unsigned int *v15; // ebx
  unsigned int v16; // edx
  int v19; // eax
  unsigned int *v20; // ecx
  unsigned int i; // ebx
  unsigned int *v22; // edx
  char v23; // al
  unsigned int *v24; // ebp
  int v25; // eax
  unsigned int *v26; // edx
  unsigned int *v27; // ebx
  unsigned int v28; // ecx
  int v29; // eax
  int v30; // edx
  unsigned int *v31; // ecx
  unsigned int *v32; // eax
  unsigned int *v33; // eax
  char *v34; // ebx
  char v35; // dl
  signed int v36; // eax
  _DWORD *v37; // eax
  unsigned int *v38; // ecx
  unsigned int v39; // [esp+4h] [ebp-58h]
  int v40; // [esp+4h] [ebp-58h]
  int v41; // [esp+8h] [ebp-54h]
  int v42; // [esp+8h] [ebp-54h]
  int (__cdecl *v43)(_DWORD *, _DWORD *, unsigned int *, unsigned int *, _DWORD, _DWORD *, int, int); // [esp+Ch] [ebp-50h]
  unsigned int *v44; // [esp+10h] [ebp-4Ch]
  int v45; // [esp+10h] [ebp-4Ch]
  _DWORD *v46; // [esp+14h] [ebp-48h]
  _DWORD *v47; // [esp+18h] [ebp-44h]
  int *v48; // [esp+1Ch] [ebp-40h]
  char v49; // [esp+20h] [ebp-3Ch]
  unsigned int v50; // [esp+28h] [ebp-34h]
  char *v51; // [esp+28h] [ebp-34h]
  unsigned int *v52; // [esp+2Ch] [ebp-30h]
  unsigned int *v53; // [esp+2Ch] [ebp-30h]
  int v54; // [esp+30h] [ebp-2Ch] BYREF
  unsigned int *v55; // [esp+34h] [ebp-28h] BYREF
  unsigned int *v56; // [esp+38h] [ebp-24h] BYREF
  unsigned int v57; // [esp+3Ch] [ebp-20h] BYREF
  char v58[28]; // [esp+40h] [ebp-1Ch] BYREF

  v43 = 0;
  v9 = a3[2];
  v46 = a2 + 15;
  v47 = a3 + 8;
  if ( ((unsigned __int8)v9 & 1) == 0 )
  {
    v43 = (int (__cdecl *)(_DWORD *, _DWORD *, unsigned int *, unsigned int *, _DWORD, _DWORD *, int, int))a2[20];
    if ( a2[15] )
      v43 = (int (__cdecl *)(_DWORD *, _DWORD *, unsigned int *, unsigned int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(a2[20], 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 415, "__gconv_transform_internal_ascii");
    v32 = a3[5];
    v41 = 0;
    *v32 = 0;
    v32[1] = 0;
    if ( ((_BYTE)a3[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v43);
      return v43(v46, v47, 0, 0, 0, a7, a8, a9);
    }
    return v41;
  }
  v10 = (unsigned int *)*a4;
  if ( a6 )
    v44 = *a6;
  else
    v44 = *a3;
  v11 = a3[1];
  v12 = 0;
  v54 = 0;
  v39 = (unsigned int)v11;
  if ( a7 )
    v12 = &v54;
  v48 = v12;
  if ( !a9 )
    goto LABEL_10;
  v20 = a3[5];
  v50 = *v20;
  v42 = *v20 & 7;
  if ( !v42 )
    goto LABEL_10;
  if ( a6 )
    _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 559, "__gconv_transform_internal_ascii");
  v55 = v10;
  v56 = v44;
  if ( (unsigned int)v42 > 4 )
    _assert_fail(
      a1,
      (int)"(state->__count & 7) <= sizeof (state->__value)",
      (int)"../iconv/loop.c",
      384,
      "internal_ascii_loop_single");
  for ( i = 0; i != v42; ++i )
    v58[i - 4] = *((_BYTE *)v20 + i + 4);
  if ( a5 < (unsigned int *)((char *)v10 + 4 - v42) )
  {
    *a4 = (int)a5;
    if ( v10 < a5 )
    {
      v33 = (unsigned int *)((char *)v10 + 1);
      v34 = (char *)v20 + i;
      do
      {
        v55 = v33;
        v35 = *((_BYTE *)v33 - 1);
        v33 = (unsigned int *)((char *)v33 + 1);
        (++v34)[3] = v35;
      }
      while ( (unsigned int *)((char *)a5 + 1) != v33 );
    }
    return 7;
  }
  if ( (unsigned int)v44 >= v39 )
    return 5;
  v22 = (unsigned int *)((char *)v10 + 1);
  v49 = (char)v9;
  v52 = v10;
  do
  {
    v55 = v22;
    v23 = *((_BYTE *)v22 - 1);
    ++i;
    v24 = v22;
    v22 = (unsigned int *)((char *)v22 + 1);
    *((_BYTE *)&v56 + i + 3) = v23;
  }
  while ( i <= 3 && a5 > v24 );
  v25 = (int)v52;
  v55 = &v57;
  if ( v57 > 0x7F )
  {
    if ( v57 >> 7 == 7168 )
    {
      v55 = (unsigned int *)v58;
      v26 = (unsigned int *)v58;
      goto LABEL_50;
    }
    if ( v48 )
    {
      v26 = &v57;
      if ( (v49 & 8) != 0 )
      {
        v53 = v20;
        v51 = &v58[i - 4];
        v41 = _gconv_transliterate(a2, (int)a3, v25, &v55, (unsigned int)&v58[i - 4], (int *)&v56, v48);
        v26 = v55;
        v20 = v53;
        if ( v41 != 6 )
        {
          if ( v55 != &v57 )
            goto LABEL_49;
          if ( v41 != 7 )
          {
            if ( v41 )
              return v41;
            goto LABEL_85;
          }
          if ( v51 == v58 )
            _assert_fail(
              a1,
              (int)"inend != &bytebuf[MAX_NEEDED_INPUT]",
              (int)"../iconv/loop.c",
              464,
              "internal_ascii_loop_single");
          v36 = *v53 & 0xFFFFFFF8;
          *a4 += i - (*v53 & 7);
          if ( (int)i <= v36 )
            _assert_fail(
              a1,
              (int)"inend - inptr > (state->__count & ~7)",
              (int)"../iconv/loop.c",
              474,
              "internal_ascii_loop_single");
          if ( i > 4 )
            _assert_fail(
              a1,
              (int)"inend - inptr <= sizeof (state->__value)",
              (int)"../iconv/loop.c",
              475,
              "internal_ascii_loop_single");
          *v53 = v36 | i;
          if ( v51 > (char *)&v57 )
          {
            v37 = v53 + 1;
            v38 = &v57;
            do
            {
              v38 = (unsigned int *)((char *)v38 + 1);
              v37 = (_DWORD *)((char *)v37 + 1);
              v55 = v38;
              *((_BYTE *)v37 - 1) = *((_BYTE *)v38 - 1);
            }
            while ( v51 != (char *)v38 );
          }
          return 7;
        }
      }
      if ( (v49 & 2) != 0 )
      {
        v55 = ++v26;
        ++*v48;
      }
      if ( v26 != &v57 )
        goto LABEL_49;
    }
    return 6;
  }
  v56 = (unsigned int *)((char *)v44 + 1);
  *(_BYTE *)v44 = v57;
  v26 = ++v55;
  if ( v55 != &v57 )
  {
LABEL_49:
    v50 = *v20;
    v42 = *v20 & 7;
LABEL_50:
    if ( (char *)v26 - (char *)&v57 <= v42 )
      _assert_fail(
        a1,
        (int)"inptr - bytebuf > (state->__count & 7)",
        (int)"../iconv/loop.c",
        446,
        "internal_ascii_loop_single");
    v9 = a3[2];
    v10 = (unsigned int *)(*a4 + (char *)v26 - (char *)&v57 - v42);
    *a4 = (int)v10;
    v27 = v56;
    *v20 = v50 & 0xFFFFFFF8;
    v44 = v27;
    goto LABEL_10;
  }
LABEL_85:
  v9 = a3[2];
  v10 = (unsigned int *)*a4;
LABEL_10:
  LOBYTE(v13) = (_BYTE)v9;
  v14 = (unsigned int)v44;
  while ( 1 )
  {
    v56 = v10;
    v57 = v14;
    v15 = (unsigned int *)v14;
    v41 = 4;
    v45 = (unsigned __int8)v13 & 2;
    while ( 2 )
    {
      if ( a5 != v10 )
      {
        while ( 1 )
        {
          if ( a5 < v10 + 1 )
          {
            v41 = 7;
            goto LABEL_21;
          }
          if ( v39 <= (unsigned int)v15 )
          {
            v41 = 5;
            goto LABEL_21;
          }
          v16 = *v10;
          if ( *v10 > 0x7F )
            break;
          v57 = (unsigned int)v15 + 1;
          *(_BYTE *)v15 = v16;
          v15 = (unsigned int *)v57;
          v10 = v56 + 1;
          if ( a5 == ++v56 )
            goto LABEL_17;
        }
        if ( v16 >> 7 == 7168 )
        {
          v56 = ++v10;
          continue;
        }
        if ( v48 )
        {
          if ( ((_BYTE)a3[2] & 8) != 0 )
          {
            v41 = _gconv_transliterate(a2, (int)a3, *a4, &v56, (unsigned int)a5, (int *)&v57, v48);
            v15 = (unsigned int *)v57;
            v10 = v56;
            if ( v41 != 6 )
            {
              if ( v41 != 5 )
                continue;
              goto LABEL_21;
            }
          }
          if ( v45 )
          {
            ++v10;
            v41 = 6;
            v56 = v10;
            ++*v48;
            continue;
          }
        }
        v41 = 6;
LABEL_21:
        *a4 = (int)v10;
        if ( a6 )
          goto LABEL_18;
        goto LABEL_22;
      }
      break;
    }
LABEL_17:
    *a4 = (int)a5;
    if ( a6 )
    {
LABEL_18:
      *a6 = v15;
      return v41;
    }
LABEL_22:
    a3[3] = (unsigned int *)((char *)a3[3] + 1);
    if ( ((_BYTE)a3[2] & 1) != 0 )
    {
      *a3 = v15;
      *a7 += v54;
      goto LABEL_54;
    }
    if ( (unsigned int)v15 <= v14 )
    {
      v19 = v41;
      goto LABEL_27;
    }
    v57 = (unsigned int)*a3;
    dl_mcount_wrapper_check((int)v43);
    v19 = v43(v46, v47, &v57, v15, 0, a7, 0, a9);
    if ( v19 != 4 )
      break;
    v19 = v41;
    if ( v41 != 5 )
      goto LABEL_27;
LABEL_28:
    v13 = a3[2];
    v14 = (unsigned int)*a3;
    v10 = (unsigned int *)*a4;
  }
  if ( v15 != (unsigned int *)v57 )
    *a4 -= 4 * ((_DWORD)v15 - v57);
LABEL_27:
  if ( !v19 )
    goto LABEL_28;
  v41 = v19;
LABEL_54:
  if ( a9 && v41 == 7 )
  {
    if ( (int)a5 - *a4 > 3 )
      _assert_fail(a1, (int)"inend - *inptrp < 4", (int)"../iconv/skeleton.c", 777, "__gconv_transform_internal_ascii");
    v28 = 0;
    v29 = *a4;
    if ( (unsigned int)a5 > *a4 )
    {
      v40 = *a4;
      do
      {
        v30 = v29++;
        v31 = a3[5];
        *a4 = v29;
        *((_BYTE *)v31 + v30 - v40 + 4) = *(_BYTE *)(v29 - 1);
      }
      while ( a5 != (unsigned int *)v29 );
      v28 = (unsigned int)a5 - v40;
    }
    *a3[5] = v28 | *a3[5] & 0xFFFFFFF8;
  }
  return v41;
}
// 8074A95: conditional instruction was optimized away because %var_54.4 is in (1..4)

//----- (08074FA0) --------------------------------------------------------
int __usercall _gconv_transform_internal_utf8@<eax>(
        long double a1@<st0>,
        _DWORD *a2,
        unsigned int **a3,
        int *a4,
        unsigned int *a5,
        unsigned int **a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  unsigned int *v9; // esi
  unsigned int v10; // eax
  int *v11; // eax
  unsigned int *v12; // eax
  unsigned int *v13; // ebx
  int v14; // edx
  bool v15; // zf
  int v17; // esi
  int v18; // ecx
  char v19; // al
  unsigned int *v20; // edx
  unsigned int v21; // eax
  unsigned int i; // ebx
  unsigned int *v23; // eax
  char v24; // dl
  unsigned int *v25; // ecx
  unsigned int *v26; // edx
  unsigned int *v27; // eax
  unsigned int v28; // ebx
  int v29; // eax
  int v30; // ecx
  int v31; // eax
  unsigned int v32; // ecx
  int v33; // eax
  int v34; // ecx
  unsigned int *v35; // ebx
  unsigned int *v36; // edx
  unsigned int *v37; // ebx
  int v38; // eax
  unsigned int *v39; // eax
  int v40; // ecx
  char v41; // dl
  unsigned int *v42; // eax
  char *v43; // ebx
  char v44; // dl
  int v45; // ecx
  unsigned int v46; // ebx
  char v47; // al
  int v48; // eax
  unsigned int *v49; // ecx
  signed int v50; // eax
  _DWORD *v51; // ebp
  unsigned int *v52; // edx
  unsigned int v53; // [esp+4h] [ebp-58h]
  int v54; // [esp+4h] [ebp-58h]
  unsigned int *v55; // [esp+8h] [ebp-54h]
  int v56; // [esp+Ch] [ebp-50h]
  unsigned int *v57; // [esp+Ch] [ebp-50h]
  unsigned int *v58; // [esp+Ch] [ebp-50h]
  unsigned int *v59; // [esp+10h] [ebp-4Ch]
  unsigned int *v60; // [esp+10h] [ebp-4Ch]
  int v61; // [esp+14h] [ebp-48h]
  int (__cdecl *v62)(_DWORD *, _DWORD *, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int); // [esp+18h] [ebp-44h]
  _DWORD *v63; // [esp+1Ch] [ebp-40h]
  _DWORD *v64; // [esp+20h] [ebp-3Ch]
  int *v65; // [esp+24h] [ebp-38h]
  unsigned int *v66; // [esp+2Ch] [ebp-30h]
  int v67; // [esp+30h] [ebp-2Ch] BYREF
  unsigned int *v68; // [esp+34h] [ebp-28h] BYREF
  unsigned int *v69; // [esp+38h] [ebp-24h] BYREF
  unsigned int v70; // [esp+3Ch] [ebp-20h] BYREF
  char v71; // [esp+40h] [ebp-1Ch] BYREF

  v62 = 0;
  v9 = a3[2];
  v63 = a2 + 15;
  v64 = a3 + 8;
  if ( ((unsigned __int8)v9 & 1) == 0 )
  {
    v62 = (int (__cdecl *)(_DWORD *, _DWORD *, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int))a2[20];
    if ( a2[15] )
      v62 = (int (__cdecl *)(_DWORD *, _DWORD *, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(a2[20], 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 415, "__gconv_transform_internal_utf8");
    v39 = a3[5];
    v56 = 0;
    *v39 = 0;
    v39[1] = 0;
    if ( ((_BYTE)a3[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v62);
      return v62(v63, v64, 0, 0, 0, a7, a8, a9);
    }
    return v56;
  }
  v59 = (unsigned int *)*a4;
  if ( a6 )
    v55 = *a6;
  else
    v55 = *a3;
  v10 = (unsigned int)a3[1];
  v67 = 0;
  v53 = v10;
  v11 = 0;
  if ( a7 )
    v11 = &v67;
  v65 = v11;
  if ( !a9 )
    goto LABEL_10;
  v20 = a3[5];
  v21 = *v20 & 7;
  if ( !v21 )
    goto LABEL_10;
  if ( a6 )
    _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 559, "__gconv_transform_internal_utf8");
  v68 = v59;
  v69 = v55;
  if ( v21 > 4 )
    _assert_fail(
      a1,
      (int)"(state->__count & 7) <= sizeof (state->__value)",
      (int)"../iconv/loop.c",
      384,
      "internal_utf8_loop_single");
  for ( i = 0; i != v21; ++i )
    *((_BYTE *)&v70 + i) = *((_BYTE *)v20 + i + 4);
  if ( a5 < (unsigned int *)((char *)v59 + 4 - i) )
  {
    *a4 = (int)a5;
    if ( v59 < a5 )
    {
      v42 = (unsigned int *)((char *)v59 + 1);
      v43 = (char *)v20 + i;
      do
      {
        v68 = v42;
        v44 = *((_BYTE *)v42 - 1);
        v42 = (unsigned int *)((char *)v42 + 1);
        (++v43)[3] = v44;
      }
      while ( (unsigned int *)((char *)a5 + 1) != v42 );
    }
    return 7;
  }
  if ( (unsigned int)v55 >= v53 )
    return 5;
  v58 = v20;
  v23 = (unsigned int *)((char *)v59 + 1);
  do
  {
    v68 = v23;
    v24 = *((_BYTE *)v23 - 1);
    ++i;
    v25 = v23;
    v23 = (unsigned int *)((char *)v23 + 1);
    *((_BYTE *)&v69 + i + 3) = v24;
  }
  while ( i <= 3 && a5 > v25 );
  v26 = v58;
  v68 = &v70;
  if ( v70 <= 0x7F )
  {
    v69 = (unsigned int *)((char *)v55 + 1);
    *(_BYTE *)v55 = v70;
    goto LABEL_53;
  }
  if ( v70 - 55296 <= 0x7FF || (v70 & 0x80000000) != 0 )
  {
    if ( v65 )
    {
      v27 = &v70;
      if ( ((unsigned __int8)v9 & 8) != 0 )
      {
        v66 = v58;
        v56 = _gconv_transliterate(a2, (int)a3, (int)v59, &v68, (unsigned int)&v70 + i, (int *)&v69, v65);
        v49 = (unsigned int *)((char *)&v70 + i);
        v26 = v66;
        v27 = v68;
        if ( v56 != 6 )
        {
          if ( v68 != &v70 )
            goto LABEL_54;
          if ( v56 != 7 )
          {
            if ( v56 )
              return v56;
            goto LABEL_111;
          }
          if ( (char *)&v70 + i == &v71 )
            _assert_fail(
              a1,
              (int)"inend != &bytebuf[MAX_NEEDED_INPUT]",
              (int)"../iconv/loop.c",
              464,
              "internal_utf8_loop_single");
          v50 = *v66 & 0xFFFFFFF8;
          *a4 += i - (*v66 & 7);
          if ( (int)i <= v50 )
            _assert_fail(
              a1,
              (int)"inend - inptr > (state->__count & ~7)",
              (int)"../iconv/loop.c",
              474,
              "internal_utf8_loop_single");
          if ( i > 4 )
            _assert_fail(
              a1,
              (int)"inend - inptr <= sizeof (state->__value)",
              (int)"../iconv/loop.c",
              475,
              "internal_utf8_loop_single");
          *v66 = v50 | i;
          if ( v49 > &v70 )
          {
            v51 = v66 + 1;
            v52 = &v70;
            do
            {
              v52 = (unsigned int *)((char *)v52 + 1);
              v51 = (_DWORD *)((char *)v51 + 1);
              v68 = v52;
              *((_BYTE *)v51 - 1) = *((_BYTE *)v52 - 1);
            }
            while ( v49 != v52 );
          }
          return 7;
        }
      }
      if ( ((unsigned __int8)v9 & 2) != 0 )
      {
        v68 = ++v27;
        ++*v65;
      }
      if ( v27 != &v70 )
        goto LABEL_54;
    }
    return 6;
  }
  if ( (v70 & 0xFFFFF800) != 0 )
  {
    if ( (v70 & 0xFFFF0000) != 0 )
    {
      if ( (v70 & 0xFFE00000) != 0 )
        v45 = ((v70 & 0xFC000000) != 0) + 5;
      else
        v45 = 4;
    }
    else
    {
      v45 = 3;
    }
  }
  else
  {
    v45 = 2;
  }
  if ( v53 < (unsigned int)v55 + v45 )
    return 5;
  v46 = v70;
  *(_BYTE *)v55 = -256 >> v45;
  v69 = (unsigned int *)((char *)v69 + v45);
  do
  {
    v47 = v46;
    --v45;
    v46 >>= 6;
    *((_BYTE *)v55 + v45) = v47 & 0x3F | 0x80;
  }
  while ( v45 != 1 );
  *(_BYTE *)v55 |= v46;
LABEL_53:
  v27 = ++v68;
  if ( v68 != &v70 )
  {
LABEL_54:
    v28 = *v26;
    v29 = (char *)v27 - (char *)&v70;
    v30 = *v26 & 7;
    if ( v29 <= v30 )
      _assert_fail(
        a1,
        (int)"inptr - bytebuf > (state->__count & 7)",
        (int)"../iconv/loop.c",
        446,
        "internal_utf8_loop_single");
    v31 = *a4 + v29 - v30;
    *a4 = v31;
    v59 = (unsigned int *)v31;
    v9 = a3[2];
    v55 = v69;
    *v26 = v28 & 0xFFFFFFF8;
    goto LABEL_10;
  }
LABEL_111:
  v9 = a3[2];
  v59 = (unsigned int *)*a4;
LABEL_10:
  while ( 2 )
  {
    v12 = v59;
    v56 = 4;
    v69 = v59;
    v70 = (unsigned int)v55;
    v13 = v55;
    do
    {
      while ( 1 )
      {
        if ( a5 == v12 )
        {
LABEL_17:
          *a4 = (int)a5;
          if ( !a6 )
            goto LABEL_22;
LABEL_18:
          *a6 = v13;
          return v56;
        }
        while ( 1 )
        {
          if ( a5 < v12 + 1 )
          {
            v56 = 7;
            goto LABEL_21;
          }
          if ( v53 <= (unsigned int)v13 )
            goto LABEL_28;
          v14 = *v12;
          if ( *v12 <= 0x7F )
          {
            v70 = (unsigned int)v13 + 1;
            *(_BYTE *)v13 = v14;
            goto LABEL_16;
          }
          if ( (unsigned int)(v14 - 55296) <= 0x7FF || v14 < 0 )
            break;
          if ( (v14 & 0xFFFFF800) != 0 )
          {
            if ( (v14 & 0xFFFF0000) != 0 )
            {
              if ( (v14 & 0xFFE00000) != 0 )
                v18 = ((v14 & 0xFC000000) != 0) + 5;
              else
                v18 = 4;
            }
            else
            {
              v18 = 3;
            }
          }
          else
          {
            v18 = 2;
          }
          if ( v53 < (unsigned int)v13 + v18 )
          {
LABEL_28:
            v56 = 5;
            goto LABEL_21;
          }
          *(_BYTE *)v13 = -256 >> v18;
          v70 += v18;
          do
          {
            v19 = v14;
            --v18;
            v14 = (unsigned int)v14 >> 6;
            *((_BYTE *)v13 + v18) = v19 & 0x3F | 0x80;
          }
          while ( v18 != 1 );
          *(_BYTE *)v13 |= v14;
LABEL_16:
          v13 = (unsigned int *)v70;
          v12 = v69 + 1;
          v15 = a5 == ++v69;
          if ( v15 )
            goto LABEL_17;
        }
        if ( !v65 )
          goto LABEL_78;
        if ( ((_BYTE)a3[2] & 8) != 0 )
        {
          v56 = _gconv_transliterate(a2, (int)a3, *a4, &v69, (unsigned int)a5, (int *)&v70, v65);
          v13 = (unsigned int *)v70;
          v12 = v69;
          if ( v56 != 6 )
            break;
        }
        if ( ((unsigned __int8)v9 & 2) == 0 )
        {
LABEL_78:
          v56 = 6;
          goto LABEL_21;
        }
        ++v12;
        v56 = 6;
        v69 = v12;
        ++*v65;
      }
    }
    while ( v56 != 5 );
LABEL_21:
    *a4 = (int)v12;
    if ( a6 )
      goto LABEL_18;
LABEL_22:
    a3[3] = (unsigned int *)((char *)a3[3] + 1);
    if ( ((_BYTE)a3[2] & 1) != 0 )
    {
      *a3 = v13;
      *a7 += v67;
      goto LABEL_57;
    }
    if ( v13 <= v55 )
    {
      v17 = v56;
      goto LABEL_26;
    }
    v68 = *a3;
    dl_mcount_wrapper_check((int)v62);
    v17 = v62(v63, v64, &v68, v13, 0, a7, 0, a9);
    if ( v17 == 4 )
    {
      v17 = v56;
      if ( v56 != 5 )
        goto LABEL_26;
      goto LABEL_27;
    }
    v57 = v68;
    if ( v68 == v13 )
      goto LABEL_26;
    *a4 = (int)v59;
    v36 = v59;
    v69 = v59;
    v70 = (unsigned int)v55;
    v37 = v55;
    v61 = (unsigned int)a3[2] & 2;
    while ( 2 )
    {
      while ( 2 )
      {
        if ( a5 == v36 )
        {
LABEL_73:
          v15 = v37 == v68;
          *a4 = (int)v36;
          if ( v15 )
            _assert_fail(
              a1,
              (int)"nstatus == __GCONV_FULL_OUTPUT",
              (int)"../iconv/skeleton.c",
              728,
              "__gconv_transform_internal_utf8");
          goto LABEL_74;
        }
        while ( 2 )
        {
          if ( a5 < v36 + 1 )
            goto LABEL_73;
          if ( v57 <= v37 )
            goto LABEL_83;
          v38 = *v36;
          if ( *v36 <= 0x7F )
          {
            v70 = (unsigned int)v37 + 1;
            *(_BYTE *)v37 = v38;
LABEL_72:
            v37 = (unsigned int *)v70;
            v36 = v69 + 1;
            v15 = a5 == ++v69;
            if ( v15 )
              goto LABEL_73;
            continue;
          }
          break;
        }
        if ( (unsigned int)(v38 - 55296) > 0x7FF && v38 >= 0 )
        {
          if ( (v38 & 0xFFFFF800) != 0 )
          {
            if ( (v38 & 0xFFFF0000) != 0 )
            {
              if ( (v38 & 0xFFE00000) != 0 )
                v40 = ((v38 & 0xFC000000) != 0) + 5;
              else
                v40 = 4;
            }
            else
            {
              v40 = 3;
            }
          }
          else
          {
            v40 = 2;
          }
          if ( v57 < (unsigned int *)((char *)v37 + v40) )
          {
LABEL_83:
            v60 = v36;
            goto LABEL_84;
          }
          *(_BYTE *)v37 = -256 >> v40;
          v70 += v40;
          do
          {
            v41 = v38;
            --v40;
            v38 = (unsigned int)v38 >> 6;
            *((_BYTE *)v37 + v40) = v41 & 0x3F | 0x80;
          }
          while ( v40 != 1 );
          *(_BYTE *)v37 |= v38;
          goto LABEL_72;
        }
        if ( !v65 )
          goto LABEL_73;
        if ( ((_BYTE)a3[2] & 8) == 0 )
          goto LABEL_124;
        v48 = _gconv_transliterate(a2, (int)a3, *a4, &v69, (unsigned int)a5, (int *)&v70, v65);
        if ( v48 == 6 )
        {
          v36 = v69;
          v37 = (unsigned int *)v70;
LABEL_124:
          if ( !v61 )
            goto LABEL_73;
          v69 = ++v36;
          ++*v65;
          continue;
        }
        break;
      }
      if ( v48 != 5 )
      {
        v36 = v69;
        v37 = (unsigned int *)v70;
        continue;
      }
      break;
    }
    v37 = (unsigned int *)v70;
    v60 = v69;
LABEL_84:
    v15 = v37 == v68;
    *a4 = (int)v60;
    if ( !v15 )
LABEL_74:
      _assert_fail(a1, (int)"outbuf == outerr", (int)"../iconv/skeleton.c", 727, "__gconv_transform_internal_utf8");
    if ( v55 == v37 )
      a3[3] = (unsigned int *)((char *)a3[3] - 1);
LABEL_26:
    if ( !v17 )
    {
LABEL_27:
      v9 = a3[2];
      v59 = (unsigned int *)*a4;
      v55 = *a3;
      continue;
    }
    break;
  }
  v56 = v17;
LABEL_57:
  if ( a9 && v56 == 7 )
  {
    if ( (int)a5 - *a4 > 3 )
      _assert_fail(a1, (int)"inend - *inptrp < 4", (int)"../iconv/skeleton.c", 777, "__gconv_transform_internal_utf8");
    v32 = 0;
    v33 = *a4;
    if ( (unsigned int)a5 > *a4 )
    {
      v54 = *a4;
      do
      {
        v34 = v33++;
        v35 = a3[5];
        *a4 = v33;
        *((_BYTE *)v35 + v34 - v54 + 4) = *(_BYTE *)(v33 - 1);
      }
      while ( a5 != (unsigned int *)v33 );
      v32 = (unsigned int)a5 - v54;
    }
    *a3[5] = v32 | *a3[5] & 0xFFFFFFF8;
  }
  return v56;
}
// 807527F: conditional instruction was optimized away because eax.4 is in (1..4)

//----- (08075A30) --------------------------------------------------------
int __usercall _gconv_transform_utf8_internal@<eax>(
        long double a1@<st0>,
        int a2,
        int a3,
        unsigned int *a4,
        unsigned int a5,
        unsigned int **a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  int v9; // ebx
  int *v10; // eax
  unsigned int *v11; // edi
  unsigned int *v12; // esi
  unsigned __int8 *v13; // ebp
  unsigned int v14; // eax
  unsigned __int8 v15; // dl
  unsigned int v16; // ebx
  unsigned __int8 v17; // dl
  int v18; // ebp
  unsigned int v19; // esi
  int *v20; // ebp
  unsigned int v21; // edi
  int v22; // edx
  int v23; // eax
  int v24; // esi
  char v25; // cl
  char *v26; // edx
  char v27; // bl
  int v29; // ecx
  int v30; // esi
  unsigned int v31; // edx
  unsigned int v32; // eax
  unsigned int v33; // eax
  int v34; // edi
  unsigned int v35; // ecx
  unsigned int *v36; // ebp
  char v37; // dl
  int v38; // edx
  unsigned __int8 *v39; // edx
  unsigned __int8 *v40; // eax
  unsigned int *v41; // edi
  unsigned __int8 *v42; // edx
  unsigned int *v43; // ebp
  unsigned int v44; // eax
  unsigned __int8 v45; // cl
  unsigned int v46; // ebx
  unsigned __int8 v47; // cl
  unsigned int *v48; // edi
  _DWORD *v49; // eax
  unsigned __int8 *v50; // ecx
  unsigned __int8 *v51; // eax
  int v52; // ebx
  unsigned int v53; // edx
  int v54; // ecx
  char v55; // al
  _BYTE *v56; // ecx
  char *v57; // ebp
  char *v58; // eax
  int v59; // ecx
  bool v60; // cf
  int v61; // edx
  int v62; // ecx
  int v63; // eax
  int *v64; // ebp
  int *v65; // esi
  char v66; // bl
  int *v67; // esi
  _BYTE *v68; // eax
  int v69; // eax
  unsigned int v70; // [esp+4h] [ebp-68h]
  unsigned int v71; // [esp+4h] [ebp-68h]
  unsigned int *v72; // [esp+8h] [ebp-64h]
  int v73; // [esp+Ch] [ebp-60h]
  int *v74; // [esp+Ch] [ebp-60h]
  unsigned int v75; // [esp+Ch] [ebp-60h]
  unsigned __int8 *v76; // [esp+10h] [ebp-5Ch]
  int v77; // [esp+10h] [ebp-5Ch]
  unsigned int v78; // [esp+14h] [ebp-58h]
  int v79; // [esp+14h] [ebp-58h]
  int v80; // [esp+14h] [ebp-58h]
  int v81; // [esp+18h] [ebp-54h]
  int *v82; // [esp+18h] [ebp-54h]
  int v83; // [esp+18h] [ebp-54h]
  int (__cdecl *v84)(int, int, unsigned int *, unsigned int *, _DWORD, _DWORD *, int, int); // [esp+1Ch] [ebp-50h]
  int v85; // [esp+20h] [ebp-4Ch]
  unsigned int v86; // [esp+20h] [ebp-4Ch]
  int v87; // [esp+24h] [ebp-48h]
  int v88; // [esp+28h] [ebp-44h]
  int *v89; // [esp+2Ch] [ebp-40h]
  unsigned int v90; // [esp+30h] [ebp-3Ch]
  char *v91; // [esp+34h] [ebp-38h]
  int v92; // [esp+38h] [ebp-34h]
  unsigned int v93; // [esp+3Ch] [ebp-30h]
  int v94; // [esp+44h] [ebp-28h] BYREF
  unsigned int v95; // [esp+48h] [ebp-24h] BYREF
  char v96; // [esp+4Eh] [ebp-1Eh] BYREF

  v84 = 0;
  v87 = a2 + 60;
  v9 = *(_DWORD *)(a3 + 8);
  v88 = a3 + 32;
  if ( (v9 & 1) == 0 )
  {
    v84 = *(int (__cdecl **)(int, int, unsigned int *, unsigned int *, _DWORD, _DWORD *, int, int))(a2 + 80);
    if ( *(_DWORD *)(a2 + 60) )
      v84 = (int (__cdecl *)(int, int, unsigned int *, unsigned int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a2 + 80), 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 415, "__gconv_transform_utf8_internal");
    v73 = 0;
    v49 = *(_DWORD **)(a3 + 20);
    *v49 = 0;
    v49[1] = 0;
    if ( (*(_BYTE *)(a3 + 8) & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v84);
      return v84(v87, v88, 0, 0, 0, a7, a8, a9);
    }
    return v73;
  }
  v76 = (unsigned __int8 *)*a4;
  if ( a6 )
    v72 = *a6;
  else
    v72 = *(unsigned int **)a3;
  v94 = 0;
  v70 = *(_DWORD *)(a3 + 4);
  v10 = 0;
  if ( a7 )
    v10 = &v94;
  v89 = v10;
  if ( !a9 || (v29 = **(_DWORD **)(a3 + 20), v74 = *(int **)(a3 + 20), v79 = v29 & 7, (v29 & 7) == 0) )
  {
    while ( 1 )
    {
LABEL_10:
      if ( (unsigned __int8 *)a5 != v76 )
      {
        v11 = v72;
        v12 = v72 + 1;
        if ( v70 < (unsigned int)(v72 + 1) )
        {
          v13 = v76;
          v11 = v72;
          v73 = 5;
          goto LABEL_31;
        }
        v13 = v76;
        v73 = 4;
        v81 = v9 & 2;
        while ( 1 )
        {
          v14 = *v13;
          v15 = *v13;
          if ( v14 <= 0x7F )
          {
            ++v13;
LABEL_14:
            *v11 = v14;
            v11 = v12;
            if ( (unsigned __int8 *)a5 == v13 )
            {
LABEL_27:
              v13 = (unsigned __int8 *)a5;
              goto LABEL_31;
            }
            goto LABEL_15;
          }
          if ( v14 - 194 > 0x1D )
          {
            if ( (v15 & 0xF0) == 0xE0 )
            {
              v78 = 3;
              v14 = v15 & 0xF;
            }
            else if ( (v15 & 0xF8) == 0xF0 )
            {
              v78 = 4;
              v14 = v15 & 7;
            }
            else if ( (v15 & 0xFC) == 0xF8 )
            {
              v78 = 5;
              v14 = v15 & 3;
            }
            else
            {
              if ( (v15 & 0xFE) != 0xFC )
              {
                v68 = v13 + 1;
                v16 = 0;
                do
                {
                  ++v16;
                  if ( a5 <= (unsigned int)v68 )
                    break;
                  if ( (*v68 & 0xC0) != 0x80 )
                    break;
                  ++v68;
                }
                while ( v16 != 5 );
                goto LABEL_24;
              }
              v78 = 6;
              v14 = v15 & 1;
            }
          }
          else
          {
            v78 = 2;
            v14 = v15 & 0x1F;
          }
          v16 = 1;
          if ( a5 < (unsigned int)&v13[v78] )
          {
            v39 = v13 + 1;
            if ( a5 <= (unsigned int)(v13 + 1) )
              goto LABEL_76;
            if ( (v13[1] & 0xC0) == 0x80 )
            {
              v40 = v13 + 2;
              while ( 1 )
              {
                v39 = v40;
                v16 = v40 - v13;
                if ( v40 == (unsigned __int8 *)a5 )
                  break;
                ++v40;
                if ( (*v39 & 0xC0) != 0x80 )
                  goto LABEL_24;
              }
LABEL_76:
              if ( v39 == (unsigned __int8 *)a5 )
              {
                v73 = 7;
                goto LABEL_31;
              }
            }
          }
          else
          {
            while ( 1 )
            {
              v17 = v13[v16];
              if ( (v17 & 0xC0) != 0x80 )
                break;
              ++v16;
              v14 = v17 & 0x3F | (v14 << 6);
              if ( v78 == v16 )
                goto LABEL_22;
            }
            if ( v78 > v16 )
              goto LABEL_24;
LABEL_22:
            if ( (v78 == 2 || v14 >> (5 * v78 - 4)) && v14 - 55296 > 0x7FF )
            {
              v13 += v78;
              goto LABEL_14;
            }
          }
LABEL_24:
          if ( !v89 || !v81 )
          {
            v73 = 6;
            goto LABEL_31;
          }
          v13 += v16;
          ++*v89;
          v73 = 6;
          if ( (unsigned __int8 *)a5 == v13 )
            goto LABEL_27;
LABEL_15:
          v12 = v11 + 1;
          if ( v70 < (unsigned int)(v11 + 1) )
          {
            v73 = 5;
            goto LABEL_31;
          }
        }
      }
      v13 = (unsigned __int8 *)a5;
      v11 = v72;
      v73 = 4;
LABEL_31:
      *a4 = (unsigned int)v13;
      if ( a6 )
      {
        *a6 = v11;
        return v73;
      }
      ++*(_DWORD *)(a3 + 12);
      if ( (*(_BYTE *)(a3 + 8) & 1) != 0 )
      {
        *(_DWORD *)a3 = v11;
        *a7 += v94;
        goto LABEL_44;
      }
      if ( v11 <= v72 )
        goto LABEL_44;
      v95 = *(_DWORD *)a3;
      dl_mcount_wrapper_check((int)v84);
      v18 = v84(v87, v88, &v95, v11, 0, a7, 0, a9);
      if ( v18 == 4 )
      {
        if ( v73 != 5 )
          goto LABEL_44;
      }
      else
      {
        v19 = v95;
        if ( (unsigned int *)v95 == v11 )
          goto LABEL_36;
        *a4 = (unsigned int)v76;
        if ( (unsigned __int8 *)a5 == v76 )
        {
          if ( (unsigned int *)v19 == v72 )
            goto LABEL_118;
          goto LABEL_113;
        }
        v41 = v72 + 1;
        if ( v19 >= (unsigned int)(v72 + 1) )
        {
          v80 = v18;
          v42 = v76;
          v83 = *(_DWORD *)(a3 + 8) & 2;
          v43 = v72;
          while ( 1 )
          {
            v44 = *v42;
            v45 = *v42;
            if ( v44 <= 0x7F )
            {
              ++v42;
            }
            else
            {
              if ( v44 - 194 > 0x1D )
              {
                if ( (v45 & 0xF0) == 0xE0 )
                {
                  v75 = 3;
                  v44 = v45 & 0xF;
                }
                else if ( (v45 & 0xF8) == 0xF0 )
                {
                  v75 = 4;
                  v44 = v45 & 7;
                }
                else if ( (v45 & 0xFC) == 0xF8 )
                {
                  v75 = 5;
                  v44 = v45 & 3;
                }
                else
                {
                  if ( (v45 & 0xFE) != 0xFC )
                  {
                    v56 = v42 + 1;
                    v52 = 0;
                    do
                    {
                      ++v52;
                      if ( a5 <= (unsigned int)v56 )
                        break;
                      if ( (*v56 & 0xC0) != 0x80 )
                        break;
                      ++v56;
                    }
                    while ( v52 != 5 );
LABEL_154:
                    v77 = v52;
                    goto LABEL_110;
                  }
                  v75 = 6;
                  v44 = v45 & 1;
                }
              }
              else
              {
                v75 = 2;
                v44 = v45 & 0x1F;
              }
              v77 = 1;
              if ( a5 < (unsigned int)&v42[v75] )
              {
                v50 = v42 + 1;
                if ( a5 > (unsigned int)(v42 + 1) )
                {
                  if ( (v42[1] & 0xC0) != 0x80 )
                  {
LABEL_110:
                    if ( !v89 || !v83 )
                    {
                      *a4 = (unsigned int)v42;
                      if ( (unsigned int *)v19 != v43 )
                        goto LABEL_113;
LABEL_118:
                      _assert_fail(
                        a1,
                        (int)"nstatus == __GCONV_FULL_OUTPUT",
                        (int)"../iconv/skeleton.c",
                        728,
                        "__gconv_transform_utf8_internal");
                    }
                    v42 += v77;
                    ++*v89;
                    goto LABEL_83;
                  }
                  v51 = v42 + 2;
                  while ( 1 )
                  {
                    v50 = v51;
                    v52 = v51 - v42;
                    if ( v51 == (unsigned __int8 *)a5 )
                      break;
                    ++v51;
                    if ( (*v50 & 0xC0) != 0x80 )
                      goto LABEL_154;
                  }
                  v77 = v51 - v42;
                }
                if ( (unsigned __int8 *)a5 == v50 )
                {
                  *a4 = (unsigned int)v42;
                  if ( (unsigned int *)v19 == v43 )
                    goto LABEL_118;
LABEL_113:
                  _assert_fail(
                    a1,
                    (int)"outbuf == outerr",
                    (int)"../iconv/skeleton.c",
                    727,
                    "__gconv_transform_utf8_internal");
                }
                goto LABEL_110;
              }
              v46 = 1;
              while ( 1 )
              {
                v47 = v42[v46];
                if ( (v47 & 0xC0) != 0x80 )
                  break;
                ++v46;
                v44 = v47 & 0x3F | (v44 << 6);
                if ( v75 == v46 )
                {
                  v77 = v46;
                  goto LABEL_93;
                }
              }
              v77 = v46;
              if ( v75 > v46 )
                goto LABEL_110;
LABEL_93:
              if ( v75 != 2 && !(v44 >> (5 * v75 - 4)) || v44 - 55296 <= 0x7FF )
                goto LABEL_110;
              v42 += v75;
            }
            *v43 = v44;
            v43 = v41;
LABEL_83:
            if ( (unsigned __int8 *)a5 == v42 )
            {
              *a4 = a5;
              if ( (unsigned int *)v19 == v43 )
                goto LABEL_118;
              goto LABEL_113;
            }
            v41 = v43 + 1;
            if ( v19 < (unsigned int)(v43 + 1) )
            {
              v48 = v43;
              v18 = v80;
              *a4 = (unsigned int)v42;
              if ( (unsigned int *)v19 != v48 )
                goto LABEL_113;
              if ( (unsigned int *)v19 == v72 )
                goto LABEL_122;
              goto LABEL_36;
            }
          }
        }
        if ( (unsigned int *)v19 != v72 )
          goto LABEL_113;
LABEL_122:
        --*(_DWORD *)(a3 + 12);
LABEL_36:
        if ( v18 )
        {
          v73 = v18;
LABEL_44:
          if ( v73 == 7 && a9 )
          {
            v20 = *(int **)(a3 + 20);
            v21 = *a4;
            v22 = *(unsigned __int8 *)*a4;
            v71 = a5 - *a4;
            *v20 = v71;
            if ( (unsigned int)(v22 - 192) <= 1 )
              _assert_fail(
                a1,
                (int)"ch != 0xc0 && ch != 0xc1",
                (int)"../iconv/skeleton.c",
                773,
                "__gconv_transform_utf8_internal");
            if ( (unsigned int)(v22 - 194) > 0x1D )
            {
              if ( (v22 & 0xF0) == 0xE0 )
              {
                v23 = v22 & 0xF;
                v24 = 768;
                v25 = 2;
              }
              else if ( (v22 & 0xF8) == 0xF0 )
              {
                v23 = v22 & 7;
                v24 = 1024;
                v25 = 3;
              }
              else if ( (v22 & 0xFC) == 0xF8 )
              {
                v23 = v22 & 3;
                v24 = 1280;
                v25 = 4;
              }
              else
              {
                v23 = v22 & 1;
                v24 = 1536;
                v25 = 5;
              }
            }
            else
            {
              v23 = v22 & 0x1F;
              v24 = 512;
              v25 = 1;
            }
            v26 = (char *)(v21 + 1);
            *a4 = v21 + 1;
            if ( a5 > v21 + 1 )
            {
              do
              {
                v27 = *v26++;
                *a4 = (unsigned int)v26;
                v23 = v27 & 0x3F | (v23 << 6);
              }
              while ( (char *)a5 != v26 );
              v25 += v21 - a5 + 1;
            }
            *v20 = v71 | v24;
            v20[1] = v23 << (6 * v25);
          }
          return v73;
        }
      }
      v76 = (unsigned __int8 *)*a4;
      v9 = *(_DWORD *)(a3 + 8);
      v72 = *(unsigned int **)a3;
    }
  }
  if ( a6 )
    _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 559, "__gconv_transform_utf8_internal");
  v30 = (unsigned __int8)v29;
  v31 = v74[1];
  v32 = v29 >> 8;
  LOBYTE(v95) = _PRETTY_FUNCTION___9358[(v29 >> 8) + 30];
  do
  {
    if ( (unsigned __int8)v29 > --v32 )
      *((_BYTE *)&v95 + v32) = v31 & 0x3F | 0x80;
    v31 >>= 6;
  }
  while ( v32 > 1 );
  LOBYTE(v95) = v31 | v95;
  if ( v70 >= (unsigned int)(v72 + 1) )
  {
    v33 = (unsigned int)v76;
    while ( 1 )
    {
      ++v33;
      v34 = v30 + 1;
      *((_BYTE *)&v94 + v30 + 4) = *(_BYTE *)(v33 - 1);
      if ( a5 <= v33 || (unsigned int)(v30 + 1) > 5 )
        break;
      ++v30;
    }
    v35 = (unsigned __int8)v95;
    v36 = v72 + 1;
    v82 = (int *)((char *)&v95 + 1);
    v37 = v95;
    if ( (unsigned __int8)v95 <= 0x7Fu )
      goto LABEL_65;
    v91 = (char *)&v95 + v34;
    v93 = (unsigned __int8)v95 - 194;
    if ( v93 > 0x1D )
    {
      if ( (v95 & 0xF0) == 0xE0 )
      {
        v90 = 3;
        v85 = v95 & 0xF;
      }
      else if ( (v95 & 0xF8) == 0xF0 )
      {
        v90 = 4;
        v85 = v95 & 7;
      }
      else if ( (v95 & 0xFC) == 0xF8 )
      {
        v90 = 5;
        v85 = v95 & 3;
      }
      else
      {
        if ( (v95 & 0xFE) != 0xFC )
        {
          v69 = 0;
          do
            ++v69;
          while ( v91 > (char *)&v95 + v69 && (*((_BYTE *)&v95 + v69) & 0xC0) == 0x80 && v69 != 5 );
          v92 = v69;
          goto LABEL_139;
        }
        v90 = 6;
        v85 = v95 & 1;
      }
    }
    else
    {
      v90 = 2;
      v85 = v95 & 0x1F;
    }
    v92 = 1;
    v82 = (int *)((char *)&v95 + v90);
    if ( v91 >= (char *)&v95 + v90 )
    {
      v53 = 1;
      v54 = v85;
      do
      {
        v55 = *((_BYTE *)&v95 + v53);
        if ( (v55 & 0xC0) != 0x80 )
        {
          v92 = v53;
          v86 = v54;
          if ( v90 <= v53 )
            goto LABEL_156;
          goto LABEL_139;
        }
        ++v53;
        v54 = v55 & 0x3F | (v54 << 6);
      }
      while ( v90 != v53 );
      v92 = v53;
      v86 = v54;
LABEL_156:
      if ( v90 == 2 || v86 >> (5 * v90 - 4) )
      {
        v35 = v86;
        if ( v86 - 55296 > 0x7FF )
        {
LABEL_65:
          *v72 = v35;
          if ( v82 == (int *)&v95 )
          {
            v9 = *(_DWORD *)(a3 + 8);
            goto LABEL_10;
          }
          goto LABEL_66;
        }
      }
      goto LABEL_139;
    }
    if ( v91 > (char *)&v95 + 1 )
    {
      v57 = (char *)&v95 + 2;
      if ( (BYTE1(v95) & 0xC0) != 0x80 )
        goto LABEL_139;
      while ( 1 )
      {
        ++v92;
        v58 = v57;
        if ( v91 <= v57 )
          break;
        ++v57;
        if ( (*v58 & 0xC0) != 0x80 )
          goto LABEL_139;
      }
      if ( v91 != v57 )
        goto LABEL_139;
      if ( v91 == &v96 )
        _assert_fail(
          a1,
          (int)"inend != &bytebuf[MAX_NEEDED_INPUT]",
          (int)"../iconv/loop.c",
          464,
          "utf8_internal_loop_single");
LABEL_173:
      v60 = (unsigned __int8)v95 == 192;
      v59 = (unsigned __int8)v95 - 192;
      *a4 = (unsigned int)&v76[v34 - v79];
      *v74 = v34;
      if ( v60 || v59 == 1 )
        _assert_fail(a1, (int)"ch != 0xc0 && ch != 0xc1", (int)"../iconv/loop.c", 470, "utf8_internal_loop_single");
      if ( v93 > 0x1D )
      {
        if ( (v37 & 0xF0) == 0xE0 )
        {
          v61 = v37 & 0xF;
          v62 = 768;
          v63 = 2;
        }
        else if ( (v37 & 0xF8) == 0xF0 )
        {
          v61 = v37 & 7;
          v62 = 1024;
          v63 = 3;
        }
        else if ( (v37 & 0xFC) == 0xF8 )
        {
          v61 = v37 & 3;
          v62 = 1280;
          v63 = 4;
        }
        else
        {
          v61 = v37 & 1;
          v62 = 1536;
          v63 = 5;
        }
      }
      else
      {
        v61 = v37 & 0x1F;
        v62 = 512;
        v63 = 1;
      }
      if ( v91 > (char *)&v95 + 1 )
      {
        v64 = (int *)&v95;
        v65 = (int *)((char *)&v95 + v30);
        do
        {
          v66 = *((_BYTE *)v64 + 1);
          v64 = (int *)((char *)v64 + 1);
          v61 = v66 & 0x3F | (v61 << 6);
        }
        while ( v64 != v65 );
        v63 += (char *)&v95 + 1 - v91;
      }
      v67 = v74;
      v73 = 7;
      *v67 = v34 | v62;
      v67[1] = v61 << (6 * v63);
      return v73;
    }
    if ( v91 == (char *)&v95 + 1 )
      goto LABEL_173;
LABEL_139:
    if ( v89 )
    {
      if ( (v9 & 2) != 0 )
      {
        ++*v89;
        v82 = (int *)((char *)&v95 + v92);
        if ( (unsigned int *)((char *)&v95 + v92) != &v95 )
        {
          v36 = v72;
LABEL_66:
          v38 = *v74 & 7;
          if ( (char *)v82 - (char *)&v95 <= v38 )
            _assert_fail(
              a1,
              (int)"inptr - bytebuf > (state->__count & 7)",
              (int)"../iconv/loop.c",
              446,
              "utf8_internal_loop_single");
          v76 += (char *)v82 - (char *)&v95 - v38;
          v72 = v36;
          *a4 = (unsigned int)v76;
          *v74 = 0;
          v9 = *(_DWORD *)(a3 + 8);
          goto LABEL_10;
        }
      }
    }
    return 6;
  }
  return 5;
}

//----- (08076840) --------------------------------------------------------
int __usercall _gconv_transform_ucs2_internal@<eax>(
        long double a1@<st0>,
        int a2,
        int a3,
        unsigned int *a4,
        unsigned int a5,
        char **a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  int v9; // esi
  unsigned int v10; // edx
  unsigned int v11; // eax
  int *v12; // eax
  unsigned int v13; // eax
  char *v14; // ebx
  char *v15; // ecx
  int v16; // edx
  int v18; // eax
  unsigned int v19; // ecx
  unsigned int v20; // eax
  unsigned int v21; // edx
  int v22; // ecx
  unsigned int *v23; // ebx
  int v24; // ecx
  int v25; // eax
  unsigned int v26; // eax
  bool v27; // cf
  _DWORD *v28; // eax
  int v29; // eax
  int v30; // ebx
  unsigned int v31; // [esp+8h] [ebp-54h]
  unsigned int v32; // [esp+8h] [ebp-54h]
  char *v33; // [esp+Ch] [ebp-50h]
  int v34; // [esp+10h] [ebp-4Ch]
  int v35; // [esp+10h] [ebp-4Ch]
  int (__cdecl *v36)(int, int, char **, char *, _DWORD, _DWORD *, int, int); // [esp+14h] [ebp-48h]
  unsigned int v37; // [esp+18h] [ebp-44h]
  int v38; // [esp+1Ch] [ebp-40h]
  int v39; // [esp+20h] [ebp-3Ch]
  int *v40; // [esp+24h] [ebp-38h]
  int v41; // [esp+38h] [ebp-24h] BYREF
  char *v42; // [esp+3Ch] [ebp-20h] BYREF

  v36 = 0;
  v9 = *(_DWORD *)(a3 + 8);
  v38 = a2 + 60;
  v39 = a3 + 32;
  if ( (v9 & 1) == 0 )
  {
    v36 = *(int (__cdecl **)(int, int, char **, char *, _DWORD, _DWORD *, int, int))(a2 + 80);
    if ( *(_DWORD *)(a2 + 60) )
      v36 = (int (__cdecl *)(int, int, char **, char *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a2 + 80), 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 415, "__gconv_transform_ucs2_internal");
    v28 = *(_DWORD **)(a3 + 20);
    v34 = 0;
    *v28 = 0;
    v28[1] = 0;
    if ( (*(_BYTE *)(a3 + 8) & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v36);
      return v36(v38, v39, 0, 0, 0, a7, a8, a9);
    }
    return v34;
  }
  v10 = *a4;
  if ( a6 )
    v33 = *a6;
  else
    v33 = *(char **)a3;
  v11 = *(_DWORD *)(a3 + 4);
  v41 = 0;
  v31 = v11;
  v12 = 0;
  if ( a7 )
    v12 = &v41;
  v40 = v12;
  if ( a9 )
  {
    v23 = *(unsigned int **)(a3 + 20);
    v37 = *v23;
    v35 = *v23 & 7;
    if ( v35 )
    {
      if ( a6 )
        _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 559, "__gconv_transform_ucs2_internal");
      v24 = *v23 & 7;
      if ( (unsigned int)v35 > 4 )
        _assert_fail(
          a1,
          (int)"(state->__count & 7) <= sizeof (state->__value)",
          (int)"../iconv/loop.c",
          384,
          "ucs2_internal_loop_single");
      LOBYTE(v42) = *((_BYTE *)v23 + 4);
      v25 = 1;
      if ( v35 != 1 )
      {
        v24 = 2;
        BYTE1(v42) = *((_BYTE *)v23 + 5);
        v25 = 0;
      }
      if ( a5 < v10 + v25 )
      {
        *a4 = a5;
        if ( v10 < a5 )
        {
          v29 = 0;
          v30 = (int)v23 + v24;
          do
          {
            *(_BYTE *)(v30 + v29 + 4) = *(_BYTE *)(v10 + v29);
            ++v29;
          }
          while ( v29 != a5 - v10 );
        }
        return 7;
      }
      if ( v31 < (unsigned int)(v33 + 4) )
        return 5;
      v26 = v10;
      do
      {
        ++v26;
        v27 = v24++ == -1;
        *((_BYTE *)&v41 + v24 + 3) = *(_BYTE *)(v26 - 1);
      }
      while ( (v27 || v24 == 1) && a5 > v26 );
      if ( (unsigned __int16)((_WORD)v42 + 10240) <= 0x7FFu )
      {
        if ( !v40 || (v9 & 2) == 0 )
          return 6;
        ++*v40;
      }
      else
      {
        *(_DWORD *)v33 = (unsigned __int16)v42;
        v37 = *v23;
        v35 = *v23 & 7;
        v33 += 4;
      }
      if ( v35 > 1 )
        _assert_fail(
          a1,
          (int)"inptr - bytebuf > (state->__count & 7)",
          (int)"../iconv/loop.c",
          446,
          "ucs2_internal_loop_single");
      v9 = *(_DWORD *)(a3 + 8);
      v10 = v10 - v35 + 2;
      *a4 = v10;
      *v23 = v37 & 0xFFFFFFF8;
    }
  }
  while ( a5 == v10 )
  {
    v14 = v33;
    v13 = a5;
    v34 = 4;
LABEL_26:
    *a4 = v13;
    if ( a6 )
      goto LABEL_23;
LABEL_27:
    ++*(_DWORD *)(a3 + 12);
    if ( (*(_BYTE *)(a3 + 8) & 1) != 0 )
    {
      *(_DWORD *)a3 = v14;
      *a7 += v41;
LABEL_36:
      if ( v34 == 7 && a9 )
      {
        if ( (int)(a5 - *a4) > 3 )
          _assert_fail(
            a1,
            (int)"inend - *inptrp < 4",
            (int)"../iconv/skeleton.c",
            777,
            "__gconv_transform_ucs2_internal");
        v19 = 0;
        v20 = *a4;
        if ( a5 > *a4 )
        {
          v32 = *a4;
          do
          {
            v21 = v20++;
            v22 = *(_DWORD *)(a3 + 20);
            *a4 = v20;
            *(_BYTE *)(v22 + v21 - v32 + 4) = *(_BYTE *)(v20 - 1);
          }
          while ( a5 != v20 );
          v19 = a5 - v32;
        }
        **(_DWORD **)(a3 + 20) = v19 | **(_DWORD **)(a3 + 20) & 0xFFFFFFF8;
      }
      return v34;
    }
    if ( v14 <= v33 )
      goto LABEL_36;
    v42 = *(char **)a3;
    dl_mcount_wrapper_check((int)v36);
    v18 = v36(v38, v39, &v42, v14, 0, a7, 0, a9);
    if ( v18 == 4 )
    {
      if ( v34 != 5 )
        goto LABEL_36;
    }
    else
    {
      if ( v14 != v42 )
        *a4 -= (v14 - v42) / 2;
      if ( v18 )
      {
        v34 = v18;
        goto LABEL_36;
      }
    }
    v9 = *(_DWORD *)(a3 + 8);
    v10 = *a4;
    v33 = *(char **)a3;
  }
  v13 = v10 + 2;
  v14 = v33;
  if ( a5 < v10 + 2 )
  {
    v13 = v10;
    v34 = 7;
    goto LABEL_26;
  }
  v15 = v33 + 4;
  if ( v31 < (unsigned int)(v33 + 4) )
  {
    v14 = v33;
    v13 = v10;
    v34 = 5;
    goto LABEL_26;
  }
  v34 = 4;
  while ( 1 )
  {
    v16 = *(unsigned __int16 *)(v13 - 2);
    if ( (unsigned __int16)(v16 + 10240) <= 0x7FFu )
      break;
    *(_DWORD *)v14 = v16;
    v14 = v15;
    if ( v13 == a5 )
      goto LABEL_22;
LABEL_16:
    if ( a5 < v13 + 2 )
    {
      v34 = 7;
      goto LABEL_26;
    }
    v15 = v14 + 4;
    if ( v31 < (unsigned int)(v14 + 4) )
    {
      v34 = 5;
      goto LABEL_26;
    }
    v13 += 2;
  }
  if ( !v40 || (v9 & 2) == 0 )
  {
    v13 -= 2;
    v34 = 6;
    goto LABEL_26;
  }
  ++*v40;
  v34 = 6;
  if ( v13 != a5 )
    goto LABEL_16;
LABEL_22:
  *a4 = v13;
  if ( !a6 )
    goto LABEL_27;
LABEL_23:
  *a6 = v14;
  return v34;
}
// 8076B40: conditional instruction was optimized away because %var_4C.4 is in (1..4)

//----- (08076DD0) --------------------------------------------------------
int __usercall _gconv_transform_internal_ucs2@<eax>(
        long double a1@<st0>,
        _DWORD *a2,
        unsigned int **a3,
        int *a4,
        unsigned int a5,
        unsigned int **a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  unsigned int *v9; // esi
  unsigned int *v10; // eax
  unsigned int v11; // ebx
  int *v12; // edx
  unsigned int *v13; // ebx
  unsigned int *v14; // edx
  unsigned int v15; // ecx
  int v17; // eax
  unsigned int i; // ebx
  unsigned int *v19; // edx
  char v20; // al
  unsigned int *v21; // ecx
  unsigned int *v22; // eax
  int v23; // eax
  unsigned int v24; // ecx
  int v25; // eax
  int v26; // edx
  unsigned int *v27; // ecx
  unsigned int *v28; // eax
  char *v29; // ebx
  unsigned int *v30; // eax
  char v31; // dl
  unsigned int *v32; // ecx
  signed int v33; // eax
  _DWORD *v34; // esi
  unsigned int v35; // [esp+4h] [ebp-58h]
  int v36; // [esp+4h] [ebp-58h]
  int v37; // [esp+8h] [ebp-54h]
  int v38; // [esp+8h] [ebp-54h]
  unsigned int *v39; // [esp+Ch] [ebp-50h]
  unsigned int *v40; // [esp+10h] [ebp-4Ch]
  int (__cdecl *v41)(_DWORD *, _DWORD *, unsigned int *, unsigned int *, _DWORD, _DWORD *, int, int); // [esp+14h] [ebp-48h]
  _DWORD *v42; // [esp+18h] [ebp-44h]
  _DWORD *v43; // [esp+1Ch] [ebp-40h]
  int *v44; // [esp+20h] [ebp-3Ch]
  unsigned int v45; // [esp+24h] [ebp-38h]
  char *v46; // [esp+24h] [ebp-38h]
  int v47; // [esp+2Ch] [ebp-30h]
  int v48; // [esp+30h] [ebp-2Ch] BYREF
  unsigned int *v49; // [esp+34h] [ebp-28h] BYREF
  unsigned int *v50; // [esp+38h] [ebp-24h] BYREF
  unsigned int v51; // [esp+3Ch] [ebp-20h] BYREF
  char v52[28]; // [esp+40h] [ebp-1Ch] BYREF

  v41 = 0;
  v9 = a3[2];
  v42 = a2 + 15;
  v43 = a3 + 8;
  if ( ((unsigned __int8)v9 & 1) == 0 )
  {
    v41 = (int (__cdecl *)(_DWORD *, _DWORD *, unsigned int *, unsigned int *, _DWORD, _DWORD *, int, int))a2[20];
    if ( a2[15] )
      v41 = (int (__cdecl *)(_DWORD *, _DWORD *, unsigned int *, unsigned int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(a2[20], 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 415, "__gconv_transform_internal_ucs2");
    v28 = a3[5];
    v37 = 0;
    *v28 = 0;
    v28[1] = 0;
    if ( ((_BYTE)a3[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v41);
      return v41(v42, v43, 0, 0, 0, a7, a8, a9);
    }
    return v37;
  }
  v10 = (unsigned int *)*a4;
  if ( a6 )
    v39 = *a6;
  else
    v39 = *a3;
  v11 = (unsigned int)a3[1];
  v12 = 0;
  v48 = 0;
  v35 = v11;
  if ( a7 )
    v12 = &v48;
  v44 = v12;
  if ( !a9 )
    goto LABEL_10;
  v40 = a3[5];
  v45 = *v40;
  v38 = *v40 & 7;
  if ( !v38 )
    goto LABEL_10;
  if ( a6 )
    _assert_fail(a1, (int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 559, "__gconv_transform_internal_ucs2");
  v49 = v10;
  v50 = v39;
  if ( (unsigned int)v38 > 4 )
    _assert_fail(
      a1,
      (int)"(state->__count & 7) <= sizeof (state->__value)",
      (int)"../iconv/loop.c",
      384,
      "internal_ucs2_loop_single");
  for ( i = 0; i != v38; ++i )
    v52[i - 4] = *((_BYTE *)v40 + i + 4);
  if ( a5 < (unsigned int)v10 + 4 - v38 )
  {
    *a4 = a5;
    if ( (unsigned int)v10 < a5 )
    {
      v29 = (char *)v40 + i;
      v30 = (unsigned int *)((char *)v10 + 1);
      do
      {
        v49 = v30;
        v31 = *((_BYTE *)v30 - 1);
        v30 = (unsigned int *)((char *)v30 + 1);
        (++v29)[3] = v31;
      }
      while ( (unsigned int *)(a5 + 1) != v30 );
    }
    return 7;
  }
  if ( v35 < (unsigned int)v39 + 2 )
    return 5;
  v19 = (unsigned int *)((char *)v10 + 1);
  v47 = (int)v10;
  do
  {
    v49 = v19;
    v20 = *((_BYTE *)v19 - 1);
    ++i;
    v21 = v19;
    v19 = (unsigned int *)((char *)v19 + 1);
    *((_BYTE *)&v50 + i + 3) = v20;
  }
  while ( i <= 3 && a5 > (unsigned int)v21 );
  v49 = &v51;
  if ( v51 <= 0xFFFF )
  {
    if ( v51 - 55296 > 0x7FF )
    {
      *(_WORD *)v39 = v51;
      v50 = (unsigned int *)((char *)v39 + 2);
LABEL_53:
      v49 = (unsigned int *)v52;
LABEL_54:
      v22 = (unsigned int *)v52;
LABEL_55:
      v23 = (char *)v22 - (char *)&v51;
      if ( v38 >= v23 )
        _assert_fail(
          a1,
          (int)"inptr - bytebuf > (state->__count & 7)",
          (int)"../iconv/loop.c",
          446,
          "internal_ucs2_loop_single");
      v10 = (unsigned int *)(*a4 + v23 - v38);
      v39 = v50;
      *a4 = (int)v10;
      *v40 = v45 & 0xFFFFFFF8;
      v9 = a3[2];
      goto LABEL_10;
    }
    if ( v44 && ((unsigned __int8)v9 & 2) != 0 )
    {
      ++*v44;
      v49 = (unsigned int *)v52;
      v45 = *v40;
      v38 = *v40 & 7;
      goto LABEL_54;
    }
    return 6;
  }
  if ( v51 >> 7 == 7168 )
    goto LABEL_53;
  if ( !v44 )
    return 6;
  if ( ((unsigned __int8)v9 & 8) == 0 )
  {
    if ( ((unsigned __int8)v9 & 2) == 0 )
      return 6;
    v22 = &v51;
    goto LABEL_92;
  }
  v46 = &v52[i - 4];
  v37 = _gconv_transliterate(a2, (int)a3, v47, &v49, (unsigned int)&v52[i - 4], (int *)&v50, v44);
  v32 = &v51;
  v22 = v49;
  if ( v37 == 6 )
  {
    if ( ((unsigned __int8)v9 & 2) == 0 )
    {
LABEL_93:
      if ( v22 != &v51 )
      {
        v45 = *v40;
        v38 = *v40 & 7;
        goto LABEL_55;
      }
      return 6;
    }
LABEL_92:
    v49 = ++v22;
    ++*v44;
    goto LABEL_93;
  }
  if ( v49 != &v51 )
  {
    v45 = *v40;
    v38 = *v40 & 7;
    goto LABEL_55;
  }
  if ( v37 == 7 )
  {
    if ( v46 == v52 )
      _assert_fail(
        a1,
        (int)"inend != &bytebuf[MAX_NEEDED_INPUT]",
        (int)"../iconv/loop.c",
        464,
        "internal_ucs2_loop_single");
    v33 = *v40 & 0xFFFFFFF8;
    *a4 += i - (*v40 & 7);
    if ( (int)i <= v33 )
      _assert_fail(
        a1,
        (int)"inend - inptr > (state->__count & ~7)",
        (int)"../iconv/loop.c",
        474,
        "internal_ucs2_loop_single");
    if ( i > 4 )
      _assert_fail(
        a1,
        (int)"inend - inptr <= sizeof (state->__value)",
        (int)"../iconv/loop.c",
        475,
        "internal_ucs2_loop_single");
    *v40 = v33 | i;
    if ( v46 > (char *)&v51 )
    {
      v34 = v40 + 1;
      do
      {
        v32 = (unsigned int *)((char *)v32 + 1);
        v34 = (_DWORD *)((char *)v34 + 1);
        v49 = v32;
        *((_BYTE *)v34 - 1) = *((_BYTE *)v32 - 1);
      }
      while ( v46 != (char *)v32 );
    }
    return 7;
  }
  if ( v37 )
    return v37;
  v9 = a3[2];
  v10 = (unsigned int *)*a4;
  while ( 1 )
  {
LABEL_10:
    v50 = v10;
    v37 = 4;
    v51 = (unsigned int)v39;
    v13 = v39;
LABEL_11:
    while ( 2 )
    {
      if ( (unsigned int *)a5 == v10 )
      {
LABEL_17:
        *a4 = a5;
        if ( a6 )
        {
LABEL_18:
          *a6 = v13;
          return v37;
        }
      }
      else
      {
        while ( 1 )
        {
          v14 = v10 + 1;
          if ( a5 < (unsigned int)(v10 + 1) )
          {
            v37 = 7;
            goto LABEL_21;
          }
          if ( v35 < (unsigned int)v13 + 2 )
          {
            v37 = 5;
            goto LABEL_21;
          }
          v15 = *v10;
          if ( *v10 > 0xFFFF )
            break;
          if ( v15 - 55296 <= 0x7FF )
          {
            if ( v44 && ((unsigned __int8)v9 & 2) != 0 )
            {
              v50 = v10 + 1;
              ++*v44;
              ++v10;
              v37 = 6;
              goto LABEL_11;
            }
LABEL_34:
            v37 = 6;
            goto LABEL_21;
          }
          ++v10;
          *(_WORD *)v13 = v15;
          v51 = (unsigned int)v13 + 2;
          v50 = v14;
          v13 = (unsigned int *)((char *)v13 + 2);
          if ( (unsigned int *)a5 == v14 )
            goto LABEL_17;
        }
        if ( v15 >> 7 == 7168 )
        {
          v50 = ++v10;
          continue;
        }
        if ( !v44 )
          goto LABEL_34;
        if ( ((_BYTE)a3[2] & 8) == 0 )
          goto LABEL_33;
        v37 = _gconv_transliterate(a2, (int)a3, *a4, &v50, a5, (int *)&v51, v44);
        if ( v37 == 6 )
        {
          v10 = v50;
          v13 = (unsigned int *)v51;
LABEL_33:
          if ( ((unsigned __int8)v9 & 2) != 0 )
          {
            ++v10;
            v37 = 6;
            v50 = v10;
            ++*v44;
            continue;
          }
          goto LABEL_34;
        }
        if ( v37 != 5 )
        {
          v10 = v50;
          v13 = (unsigned int *)v51;
          continue;
        }
        v10 = v50;
        v13 = (unsigned int *)v51;
LABEL_21:
        *a4 = (int)v10;
        if ( a6 )
          goto LABEL_18;
      }
      break;
    }
    a3[3] = (unsigned int *)((char *)a3[3] + 1);
    if ( ((_BYTE)a3[2] & 1) != 0 )
    {
      *a3 = v13;
      *a7 += v48;
      goto LABEL_58;
    }
    if ( v39 >= v13 )
    {
      v17 = v37;
      goto LABEL_27;
    }
    v51 = (unsigned int)*a3;
    dl_mcount_wrapper_check((int)v41);
    v17 = v41(v42, v43, &v51, v13, 0, a7, 0, a9);
    if ( v17 != 4 )
      break;
    v17 = v37;
    if ( v37 != 5 )
      goto LABEL_27;
LABEL_28:
    v9 = a3[2];
    v10 = (unsigned int *)*a4;
    v39 = *a3;
  }
  if ( (unsigned int *)v51 != v13 )
    *a4 -= 2 * ((_DWORD)v13 - v51);
LABEL_27:
  if ( !v17 )
    goto LABEL_28;
  v37 = v17;
LABEL_58:
  if ( a9 && v37 == 7 )
  {
    if ( (int)(a5 - *a4) > 3 )
      _assert_fail(a1, (int)"inend - *inptrp < 4", (int)"../iconv/skeleton.c", 777, "__gconv_transform_internal_ucs2");
    v24 = 0;
    v25 = *a4;
    if ( a5 > *a4 )
    {
      v36 = *a4;
      do
      {
        v26 = v25++;
        v27 = a3[5];
        *a4 = v25;
        *((_BYTE *)v27 + v26 - v36 + 4) = *(_BYTE *)(v25 - 1);
      }
      while ( a5 != v25 );
      v24 = a5 - v36;
    }
    *a3[5] = v24 | *a3[5] & 0xFFFFFFF8;
  }
  return v37;
}
// 80770AF: conditional instruction was optimized away because %var_54.4 is in (1..4)

//----- (08077600) --------------------------------------------------------
int __usercall _gconv_transform_ucs2reverse_internal@<eax>(
        long double a1@<st0>,
        int a2,
        int a3,
        unsigned int *a4,
        unsigned int a5,
        char **a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  int v9; // esi
  unsigned int v10; // eax
  unsigned int v11; // ecx
  int *v12; // edx
  unsigned int v13; // edx
  char *v14; // ebx
  char *v15; // ecx
  unsigned __int16 v16; // ax
  int v17; // esi
  int v19; // eax
  unsigned int v20; // ecx
  unsigned int v21; // eax
  unsigned int v22; // edx
  int v23; // ecx
  unsigned int *v24; // ebx
  int v25; // ecx
  int v26; // edx
  unsigned int v27; // edx
  bool v28; // cf
  unsigned __int16 v29; // dx
  _DWORD *v30; // eax
  int v31; // edx
  int v32; // ebx
  unsigned int v33; // [esp+8h] [ebp-54h]
  unsigned int v34; // [esp+8h] [ebp-54h]
  char *v35; // [esp+Ch] [ebp-50h]
  int (__cdecl *v36)(int, int, char **, char *, _DWORD, _DWORD *, int, int); // [esp+10h] [ebp-4Ch]
  int v37; // [esp+14h] [ebp-48h]
  int v38; // [esp+18h] [ebp-44h]
  int v39; // [esp+1Ch] [ebp-40h]
  int *v40; // [esp+20h] [ebp-3Ch]
  unsigned int v41; // [esp+24h] [ebp-38h]
  int v42; // [esp+38h] [ebp-24h] BYREF
  char *v43; // [esp+3Ch] [ebp-20h] BYREF

  v36 = 0;
  v9 = *(_DWORD *)(a3 + 8);
  v38 = a2 + 60;
  v39 = a3 + 32;
  if ( (v9 & 1) == 0 )
  {
    v36 = *(int (__cdecl **)(int, int, char **, char *, _DWORD, _DWORD *, int, int))(a2 + 80);
    if ( *(_DWORD *)(a2 + 60) )
      v36 = (int (__cdecl *)(int, int, char **, char *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a2 + 80), 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(
        a1,
        (int)"outbufstart == NULL",
        (int)"../iconv/skeleton.c",
        415,
        "__gconv_transform_ucs2reverse_internal");
    v30 = *(_DWORD **)(a3 + 20);
    v17 = 0;
    *v30 = 0;
    v30[1] = 0;
    if ( (*(_BYTE *)(a3 + 8) & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v36);
      return v36(v38, v39, 0, 0, 0, a7, a8, a9);
    }
    return v17;
  }
  v10 = *a4;
  if ( a6 )
    v35 = *a6;
  else
    v35 = *(char **)a3;
  v11 = *(_DWORD *)(a3 + 4);
  v12 = 0;
  v42 = 0;
  v33 = v11;
  if ( a7 )
    v12 = &v42;
  v40 = v12;
  if ( a9 )
  {
    v24 = *(unsigned int **)(a3 + 20);
    v41 = *v24;
    v37 = *v24 & 7;
    if ( v37 )
    {
      if ( a6 )
        _assert_fail(
          a1,
          (int)"outbufstart == NULL",
          (int)"../iconv/skeleton.c",
          559,
          "__gconv_transform_ucs2reverse_internal");
      v25 = *v24 & 7;
      if ( (unsigned int)v37 > 4 )
        _assert_fail(
          a1,
          (int)"(state->__count & 7) <= sizeof (state->__value)",
          (int)"../iconv/loop.c",
          384,
          "ucs2reverse_internal_loop_single");
      LOBYTE(v43) = *((_BYTE *)v24 + 4);
      v26 = 1;
      if ( v37 != 1 )
      {
        v25 = 2;
        BYTE1(v43) = *((_BYTE *)v24 + 5);
        v26 = 0;
      }
      if ( a5 < v10 + v26 )
      {
        *a4 = a5;
        if ( v10 < a5 )
        {
          v31 = 0;
          v32 = (int)v24 + v25;
          do
          {
            *(_BYTE *)(v32 + v31 + 4) = *(_BYTE *)(v10 + v31);
            ++v31;
          }
          while ( v31 != a5 - v10 );
        }
        return 7;
      }
      if ( v33 < (unsigned int)(v35 + 4) )
        return 5;
      v27 = v10;
      do
      {
        ++v27;
        v28 = v25++ == -1;
        *((_BYTE *)&v42 + v25 + 3) = *(_BYTE *)(v27 - 1);
      }
      while ( (v28 || v25 == 1) && a5 > v27 );
      v29 = __ROR2__((_WORD)v43, 8);
      if ( (unsigned __int16)(v29 + 10240) <= 0x7FFu )
      {
        if ( !v40 || (v9 & 2) == 0 )
          return 6;
        ++*v40;
      }
      else
      {
        *(_DWORD *)v35 = v29;
        v41 = *v24;
        v37 = *v24 & 7;
        v35 += 4;
      }
      if ( v37 > 1 )
        _assert_fail(
          a1,
          (int)"inptr - bytebuf > (state->__count & 7)",
          (int)"../iconv/loop.c",
          446,
          "ucs2reverse_internal_loop_single");
      v10 = v10 - v37 + 2;
      *a4 = v10;
      *v24 = v41 & 0xFFFFFFF8;
      v9 = *(_DWORD *)(a3 + 8);
    }
  }
  while ( a5 == v10 )
  {
    v14 = v35;
    v13 = a5;
    v17 = 4;
LABEL_25:
    *a4 = v13;
    if ( a6 )
      goto LABEL_22;
LABEL_26:
    ++*(_DWORD *)(a3 + 12);
    if ( (*(_BYTE *)(a3 + 8) & 1) != 0 )
    {
      *(_DWORD *)a3 = v14;
      *a7 += v42;
LABEL_35:
      if ( v17 == 7 && a9 )
      {
        if ( (int)(a5 - *a4) > 3 )
          _assert_fail(
            a1,
            (int)"inend - *inptrp < 4",
            (int)"../iconv/skeleton.c",
            777,
            "__gconv_transform_ucs2reverse_internal");
        v20 = 0;
        v21 = *a4;
        if ( a5 > *a4 )
        {
          v34 = *a4;
          do
          {
            v22 = v21++;
            v23 = *(_DWORD *)(a3 + 20);
            *a4 = v21;
            *(_BYTE *)(v23 + v22 - v34 + 4) = *(_BYTE *)(v21 - 1);
          }
          while ( a5 != v21 );
          v20 = a5 - v34;
        }
        **(_DWORD **)(a3 + 20) = v20 | **(_DWORD **)(a3 + 20) & 0xFFFFFFF8;
      }
      return v17;
    }
    if ( v14 <= v35 )
      goto LABEL_35;
    v43 = *(char **)a3;
    dl_mcount_wrapper_check((int)v36);
    v19 = v36(v38, v39, &v43, v14, 0, a7, 0, a9);
    if ( v19 == 4 )
    {
      if ( v17 != 5 )
        goto LABEL_35;
    }
    else
    {
      if ( v14 != v43 )
        *a4 -= (v14 - v43) / 2;
      if ( v19 )
      {
        v17 = v19;
        goto LABEL_35;
      }
    }
    v9 = *(_DWORD *)(a3 + 8);
    v10 = *a4;
    v35 = *(char **)a3;
  }
  v13 = v10 + 2;
  v14 = v35;
  if ( a5 < v10 + 2 )
  {
    v13 = v10;
    v17 = 7;
    goto LABEL_25;
  }
  v15 = v35 + 4;
  if ( v33 < (unsigned int)(v35 + 4) )
  {
    v14 = v35;
    v13 = v10;
    v17 = 5;
    goto LABEL_25;
  }
  while ( 1 )
  {
    v16 = __ROR2__(*(_WORD *)(v13 - 2), 8);
    if ( (unsigned __int16)(v16 + 10240) <= 0x7FFu )
      break;
    *(_DWORD *)v14 = v16;
    v14 = v15;
    if ( v13 == a5 )
      goto LABEL_21;
LABEL_15:
    if ( a5 < v13 + 2 )
    {
      v17 = 7;
      goto LABEL_25;
    }
    v15 = v14 + 4;
    if ( v33 < (unsigned int)(v14 + 4) )
    {
      v17 = 5;
      goto LABEL_25;
    }
    v13 += 2;
  }
  if ( !v40 || (v9 & 2) == 0 )
  {
    v13 -= 2;
    v17 = 6;
    goto LABEL_25;
  }
  ++*v40;
  if ( v13 != a5 )
    goto LABEL_15;
LABEL_21:
  v17 = 4;
  *a4 = v13;
  if ( !a6 )
    goto LABEL_26;
LABEL_22:
  *a6 = v14;
  return v17;
}
// 80778D8: conditional instruction was optimized away because %var_48.4 is in (1..4)

//----- (08077B50) --------------------------------------------------------
int __usercall _gconv_transform_internal_ucs2reverse@<eax>(
        long double a1@<st0>,
        _DWORD *a2,
        unsigned int **a3,
        int *a4,
        unsigned int a5,
        unsigned int **a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  unsigned int *v9; // esi
  unsigned int *v10; // edx
  unsigned int v11; // eax
  int *v12; // eax
  unsigned int *v13; // ebx
  unsigned int *v14; // ecx
  unsigned int v15; // eax
  int v17; // eax
  unsigned int i; // ebx
  unsigned int *v19; // eax
  char v20; // dl
  unsigned int *v21; // ecx
  unsigned int *v22; // edx
  int v23; // edx
  unsigned int v24; // ecx
  int v25; // eax
  int v26; // ecx
  unsigned int *v27; // ebx
  unsigned int *v28; // eax
  char *v29; // ebx
  unsigned int *v30; // edx
  char v31; // al
  unsigned int *v32; // ecx
  signed int v33; // eax
  _DWORD *v34; // esi
  unsigned int v35; // [esp+4h] [ebp-58h]
  int v36; // [esp+4h] [ebp-58h]
  unsigned int *v37; // [esp+8h] [ebp-54h]
  int v38; // [esp+Ch] [ebp-50h]
  int v39; // [esp+Ch] [ebp-50h]
  unsigned int *v40; // [esp+10h] [ebp-4Ch]
  int (__cdecl *v41)(_DWORD *, _DWORD *, unsigned int *, unsigned int *, _DWORD, _DWORD *, int, int); // [esp+14h] [ebp-48h]
  _DWORD *v42; // [esp+18h] [ebp-44h]
  _DWORD *v43; // [esp+1Ch] [ebp-40h]
  int *v44; // [esp+20h] [ebp-3Ch]
  unsigned int v45; // [esp+24h] [ebp-38h]
  char *v46; // [esp+24h] [ebp-38h]
  int v47; // [esp+2Ch] [ebp-30h]
  int v48; // [esp+30h] [ebp-2Ch] BYREF
  unsigned int *v49; // [esp+34h] [ebp-28h] BYREF
  unsigned int *v50; // [esp+38h] [ebp-24h] BYREF
  unsigned int v51; // [esp+3Ch] [ebp-20h] BYREF
  char v52[28]; // [esp+40h] [ebp-1Ch] BYREF

  v41 = 0;
  v9 = a3[2];
  v42 = a2 + 15;
  v43 = a3 + 8;
  if ( ((unsigned __int8)v9 & 1) == 0 )
  {
    v41 = (int (__cdecl *)(_DWORD *, _DWORD *, unsigned int *, unsigned int *, _DWORD, _DWORD *, int, int))a2[20];
    if ( a2[15] )
      v41 = (int (__cdecl *)(_DWORD *, _DWORD *, unsigned int *, unsigned int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(a2[20], 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(
        a1,
        (int)"outbufstart == NULL",
        (int)"../iconv/skeleton.c",
        415,
        "__gconv_transform_internal_ucs2reverse");
    v28 = a3[5];
    v38 = 0;
    *v28 = 0;
    v28[1] = 0;
    if ( ((_BYTE)a3[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v41);
      return v41(v42, v43, 0, 0, 0, a7, a8, a9);
    }
    return v38;
  }
  v10 = (unsigned int *)*a4;
  if ( a6 )
    v37 = *a6;
  else
    v37 = *a3;
  v11 = (unsigned int)a3[1];
  v48 = 0;
  v35 = v11;
  v12 = 0;
  if ( a7 )
    v12 = &v48;
  v44 = v12;
  if ( !a9 )
    goto LABEL_10;
  v40 = a3[5];
  v45 = *v40;
  v39 = *v40 & 7;
  if ( !v39 )
    goto LABEL_10;
  if ( a6 )
    _assert_fail(
      a1,
      (int)"outbufstart == NULL",
      (int)"../iconv/skeleton.c",
      559,
      "__gconv_transform_internal_ucs2reverse");
  v49 = v10;
  v50 = v37;
  if ( (unsigned int)v39 > 4 )
    _assert_fail(
      a1,
      (int)"(state->__count & 7) <= sizeof (state->__value)",
      (int)"../iconv/loop.c",
      384,
      "internal_ucs2reverse_loop_single");
  for ( i = 0; i != v39; ++i )
    v52[i - 4] = *((_BYTE *)v40 + i + 4);
  if ( a5 < (unsigned int)v10 + 4 - v39 )
  {
    *a4 = a5;
    if ( (unsigned int)v10 < a5 )
    {
      v29 = (char *)v40 + i;
      v30 = (unsigned int *)((char *)v10 + 1);
      do
      {
        v49 = v30;
        v31 = *((_BYTE *)v30 - 1);
        v30 = (unsigned int *)((char *)v30 + 1);
        (++v29)[3] = v31;
      }
      while ( (unsigned int *)(a5 + 1) != v30 );
    }
    return 7;
  }
  if ( v35 < (unsigned int)v37 + 2 )
    return 5;
  v19 = (unsigned int *)((char *)v10 + 1);
  v47 = (int)v10;
  do
  {
    v49 = v19;
    v20 = *((_BYTE *)v19 - 1);
    ++i;
    v21 = v19;
    v19 = (unsigned int *)((char *)v19 + 1);
    *((_BYTE *)&v50 + i + 3) = v20;
  }
  while ( i <= 3 && a5 > (unsigned int)v21 );
  v49 = &v51;
  if ( v51 <= 0xFFFF )
  {
    if ( v51 - 55296 > 0x7FF )
    {
      *(_WORD *)v37 = __ROR2__(v51, 8);
      v50 = (unsigned int *)((char *)v37 + 2);
LABEL_53:
      v49 = (unsigned int *)v52;
LABEL_54:
      v22 = (unsigned int *)v52;
LABEL_55:
      v23 = (char *)v22 - (char *)&v51;
      if ( v23 <= v39 )
        _assert_fail(
          a1,
          (int)"inptr - bytebuf > (state->__count & 7)",
          (int)"../iconv/loop.c",
          446,
          "internal_ucs2reverse_loop_single");
      v9 = a3[2];
      v10 = (unsigned int *)(*a4 + v23 - v39);
      *a4 = (int)v10;
      v37 = v50;
      *v40 = v45 & 0xFFFFFFF8;
      goto LABEL_10;
    }
    if ( v44 && ((unsigned __int8)v9 & 2) != 0 )
    {
      ++*v44;
      v49 = (unsigned int *)v52;
      v45 = *v40;
      v39 = *v40 & 7;
      goto LABEL_54;
    }
    return 6;
  }
  if ( v51 >> 7 == 7168 )
    goto LABEL_53;
  if ( !v44 )
    return 6;
  if ( ((unsigned __int8)v9 & 8) == 0 )
  {
    if ( ((unsigned __int8)v9 & 2) == 0 )
      return 6;
    v22 = &v51;
    goto LABEL_92;
  }
  v46 = &v52[i - 4];
  v38 = _gconv_transliterate(a2, (int)a3, v47, &v49, (unsigned int)&v52[i - 4], (int *)&v50, v44);
  v22 = v49;
  v32 = &v51;
  if ( v38 == 6 )
  {
    if ( ((unsigned __int8)v9 & 2) == 0 )
    {
LABEL_93:
      if ( v22 == &v51 )
        return 6;
LABEL_94:
      v45 = *v40;
      v39 = *v40 & 7;
      goto LABEL_55;
    }
LABEL_92:
    v49 = ++v22;
    ++*v44;
    goto LABEL_93;
  }
  if ( v49 != &v51 )
    goto LABEL_94;
  if ( v38 == 7 )
  {
    if ( v46 == v52 )
      _assert_fail(
        a1,
        (int)"inend != &bytebuf[MAX_NEEDED_INPUT]",
        (int)"../iconv/loop.c",
        464,
        "internal_ucs2reverse_loop_single");
    v33 = *v40 & 0xFFFFFFF8;
    *a4 += i - (*v40 & 7);
    if ( (int)i <= v33 )
      _assert_fail(
        a1,
        (int)"inend - inptr > (state->__count & ~7)",
        (int)"../iconv/loop.c",
        474,
        "internal_ucs2reverse_loop_single");
    if ( i > 4 )
      _assert_fail(
        a1,
        (int)"inend - inptr <= sizeof (state->__value)",
        (int)"../iconv/loop.c",
        475,
        "internal_ucs2reverse_loop_single");
    *v40 = v33 | i;
    if ( v46 > (char *)&v51 )
    {
      v34 = v40 + 1;
      do
      {
        v32 = (unsigned int *)((char *)v32 + 1);
        v34 = (_DWORD *)((char *)v34 + 1);
        v49 = v32;
        *((_BYTE *)v34 - 1) = *((_BYTE *)v32 - 1);
      }
      while ( v46 != (char *)v32 );
    }
    return 7;
  }
  if ( v38 )
    return v38;
  v9 = a3[2];
  v10 = (unsigned int *)*a4;
  while ( 1 )
  {
LABEL_10:
    v50 = v10;
    v38 = 4;
    v51 = (unsigned int)v37;
    v13 = v37;
LABEL_11:
    while ( 2 )
    {
      if ( (unsigned int *)a5 == v10 )
      {
LABEL_17:
        *a4 = a5;
        if ( a6 )
        {
LABEL_18:
          *a6 = v13;
          return v38;
        }
      }
      else
      {
        while ( 1 )
        {
          v14 = v10 + 1;
          if ( a5 < (unsigned int)(v10 + 1) )
          {
            v38 = 7;
            goto LABEL_21;
          }
          if ( v35 < (unsigned int)v13 + 2 )
          {
            v38 = 5;
            goto LABEL_21;
          }
          v15 = *v10;
          if ( *v10 > 0xFFFF )
            break;
          if ( v15 - 55296 <= 0x7FF )
          {
            if ( v44 && ((unsigned __int8)v9 & 2) != 0 )
            {
              v50 = v10 + 1;
              ++*v44;
              ++v10;
              goto LABEL_11;
            }
LABEL_34:
            v38 = 6;
            goto LABEL_21;
          }
          ++v10;
          *(_WORD *)v13 = __ROR2__(v15, 8);
          v51 = (unsigned int)v13 + 2;
          v50 = v14;
          v13 = (unsigned int *)((char *)v13 + 2);
          if ( (unsigned int *)a5 == v14 )
            goto LABEL_17;
        }
        if ( v15 >> 7 == 7168 )
        {
          v50 = ++v10;
          continue;
        }
        if ( !v44 )
          goto LABEL_34;
        if ( ((_BYTE)a3[2] & 8) == 0 )
          goto LABEL_33;
        v38 = _gconv_transliterate(a2, (int)a3, *a4, &v50, a5, (int *)&v51, v44);
        if ( v38 == 6 )
        {
          v10 = v50;
          v13 = (unsigned int *)v51;
LABEL_33:
          if ( ((unsigned __int8)v9 & 2) != 0 )
          {
            ++v10;
            v38 = 6;
            v50 = v10;
            ++*v44;
            continue;
          }
          goto LABEL_34;
        }
        if ( v38 != 5 )
        {
          v10 = v50;
          v13 = (unsigned int *)v51;
          continue;
        }
        v10 = v50;
        v13 = (unsigned int *)v51;
LABEL_21:
        *a4 = (int)v10;
        if ( a6 )
          goto LABEL_18;
      }
      break;
    }
    a3[3] = (unsigned int *)((char *)a3[3] + 1);
    if ( ((_BYTE)a3[2] & 1) != 0 )
    {
      *a3 = v13;
      *a7 += v48;
      goto LABEL_58;
    }
    if ( v13 <= v37 )
    {
      v17 = v38;
      goto LABEL_27;
    }
    v51 = (unsigned int)*a3;
    dl_mcount_wrapper_check((int)v41);
    v17 = v41(v42, v43, &v51, v13, 0, a7, 0, a9);
    if ( v17 != 4 )
      break;
    v17 = v38;
    if ( v38 != 5 )
      goto LABEL_27;
LABEL_28:
    v9 = a3[2];
    v10 = (unsigned int *)*a4;
    v37 = *a3;
  }
  if ( (unsigned int *)v51 != v13 )
    *a4 -= 2 * ((_DWORD)v13 - v51);
LABEL_27:
  if ( !v17 )
    goto LABEL_28;
  v38 = v17;
LABEL_58:
  if ( a9 && v38 == 7 )
  {
    if ( (int)(a5 - *a4) > 3 )
      _assert_fail(
        a1,
        (int)"inend - *inptrp < 4",
        (int)"../iconv/skeleton.c",
        777,
        "__gconv_transform_internal_ucs2reverse");
    v24 = 0;
    v25 = *a4;
    if ( a5 > *a4 )
    {
      v36 = *a4;
      do
      {
        v26 = v25++;
        v27 = a3[5];
        *a4 = v25;
        *((_BYTE *)v27 + v26 - v36 + 4) = *(_BYTE *)(v25 - 1);
      }
      while ( a5 != v25 );
      v24 = a5 - v36;
    }
    *a3[5] = v24 | *a3[5] & 0xFFFFFFF8;
  }
  return v38;
}
// 8077E2F: conditional instruction was optimized away because %var_50.4 is in (1..4)

//----- (08078370) --------------------------------------------------------
int __cdecl _gconv_transliterate(_DWORD *a1, int a2, int a3, unsigned int **a4, unsigned int a5, int *a6, _DWORD *a7)
{
  unsigned int *v7; // esi
  _DWORD *v8; // ecx
  int v9; // edi
  int *v10; // edx
  int v11; // eax
  int v12; // edx
  int v13; // ecx
  unsigned int *v14; // edx
  _DWORD *v15; // eax
  int v16; // edi
  unsigned int *v17; // ecx
  unsigned int v18; // ebp
  int v19; // ebx
  int result; // eax
  int v21; // ebx
  int v22; // eax
  int v23; // edx
  int v24; // ecx
  int v25; // eax
  _DWORD *v26; // esi
  int v27; // ebx
  int v28; // edi
  unsigned int v29; // [esp+0h] [ebp-5Ch]
  unsigned int *v30; // [esp+0h] [ebp-5Ch]
  _DWORD *v31; // [esp+4h] [ebp-58h]
  unsigned int v32; // [esp+4h] [ebp-58h]
  int (__cdecl *v33)(_DWORD *, int, int *, _DWORD *, int *, _DWORD, _DWORD, _DWORD); // [esp+8h] [ebp-54h]
  unsigned int v34; // [esp+Ch] [ebp-50h]
  int v35; // [esp+10h] [ebp-4Ch]
  int v36; // [esp+14h] [ebp-48h]
  unsigned int v37; // [esp+18h] [ebp-44h]
  int v38; // [esp+1Ch] [ebp-40h]
  int v39; // [esp+24h] [ebp-38h]
  int v40; // [esp+28h] [ebp-34h]
  unsigned int *v41; // [esp+2Ch] [ebp-30h]
  int v42; // [esp+38h] [ebp-24h] BYREF
  int v43[8]; // [esp+3Ch] [ebp-20h] BYREF

  v7 = *a4;
  v33 = (int (__cdecl *)(_DWORD *, int, int *, _DWORD *, int *, _DWORD, _DWORD, _DWORD))a1[5];
  if ( *a1 )
    v33 = (int (__cdecl *)(_DWORD *, int, int *, _DWORD *, int *, _DWORD, _DWORD, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(a1[5], 9));
  v31 = *(_DWORD **)__readgsdword(0xFFFFFFD8);
  v29 = v31[70];
  if ( !v29 )
  {
    if ( !v31[77] )
    {
      v19 = v31[75];
      if ( !v19 )
        return 6;
LABEL_43:
      v28 = v31[76];
      v42 = v28;
      if ( a5 < (unsigned int)(v7 + 1) )
        return 3 * (v7 != (unsigned int *)a5) + 4;
      goto LABEL_50;
    }
    if ( a5 >= (unsigned int)(v7 + 1) )
    {
      v16 = v31[77];
      v17 = (unsigned int *)v31[78];
      v18 = *v7;
      v30 = *a4;
      goto LABEL_36;
    }
LABEL_21:
    if ( v7 == (unsigned int *)a5 )
      return 4;
    else
      return 7;
  }
  if ( a5 < (unsigned int)(v7 + 1) )
    goto LABEL_21;
  v8 = v31;
  v32 = 0;
  v38 = v8[71];
  v35 = v8[72];
  v39 = v8[73];
  v40 = v8[74];
  v37 = ((a5 + 3 - (unsigned int)(v7 + 1)) >> 2) + 1;
  while ( 2 )
  {
    v9 = 0;
    v34 = (v29 + v32) >> 1;
    v36 = *(_DWORD *)(v38 + 4 * v34);
    v10 = (int *)(v35 + 4 * v36);
    v11 = *v10;
    while ( v7[v9] == v11 )
    {
      v11 = v10[++v9];
      if ( !v11 )
        goto LABEL_26;
      if ( v37 == v9 )
        return 7;
    }
    v12 = 0;
    v13 = 0;
    if ( v9 )
    {
      if ( v11 )
        return 7;
LABEL_26:
      v41 = v7;
      v21 = *(_DWORD *)(v39 + 4 * v34);
      v22 = *(_DWORD *)(v40 + 4 * v21);
      while ( 1 )
      {
        v23 = 4 * v21;
        v24 = v40 + 4 * v21;
        if ( v22 )
        {
          ++v21;
          v25 = v40 + v23 + 4;
          while ( 1 )
          {
            v26 = (_DWORD *)v25;
            v25 += 4;
            if ( !*v26 )
              break;
            ++v21;
          }
        }
        else
        {
          v26 = (_DWORD *)(v40 + 4 * v21);
        }
        v42 = v24;
        v43[0] = *a6;
        dl_mcount_wrapper_check((int)v33);
        result = v33(a1, a2, &v42, v26, v43, 0, 0, 0);
        if ( result != 6 )
          break;
        ++v21;
        v22 = *(_DWORD *)(v40 + 4 * v21);
        if ( !v22 )
        {
          v7 = v41;
          v13 = v9;
          v12 = v9;
          goto LABEL_11;
        }
      }
      if ( result == 4 )
      {
        *a4 += v9;
        ++*a7;
        result = 0;
      }
      else if ( result == 5 )
      {
        return result;
      }
      goto LABEL_47;
    }
LABEL_11:
    v14 = &v7[v12];
    if ( a5 <= (unsigned int)v14 || *(_DWORD *)(v35 + 4 * (v36 + v13)) < *v14 )
      v32 = v34 + 1;
    else
      v29 = (v29 + v32) >> 1;
    if ( v32 < v29 )
      continue;
    break;
  }
  v15 = *(_DWORD **)__readgsdword(0xFFFFFFD8);
  v31 = v15;
  if ( !v15[77] )
    goto LABEL_48;
  v16 = v15[77];
  v17 = (unsigned int *)v15[78];
  v30 = *a4;
  v18 = **a4;
LABEL_36:
  v27 = 0;
  if ( v16 > 0 )
  {
    while ( *v17 <= v18 )
    {
      if ( v17[1] >= v18 && !((v18 - *v17) % v17[2]) )
      {
        *a4 = v30 + 1;
        ++*a7;
        return 0;
      }
      ++v27;
      v17 += 3;
      if ( v27 == v16 )
        goto LABEL_48;
    }
    v19 = v31[75];
    if ( !v19 )
      return 6;
    goto LABEL_43;
  }
LABEL_48:
  v19 = v31[75];
  if ( !v19 )
    return 6;
  v28 = v31[76];
  v42 = v28;
LABEL_50:
  v43[0] = *a6;
  dl_mcount_wrapper_check((int)v33);
  result = v33(a1, a2, &v42, (_DWORD *)(v28 + 4 * v19), v43, 0, 0, 0);
  if ( result != 6 )
  {
    if ( result == 4 )
    {
      ++*a7;
      ++*a4;
      result = 0;
    }
LABEL_47:
    *a6 = v43[0];
  }
  return result;
}

//----- (08078760) --------------------------------------------------------
int __usercall find_module_idx@<eax>(unsigned __int8 *a1@<eax>, _DWORD *a2@<edx>)
{
  int v2; // edi
  unsigned int v3; // eax
  unsigned int v4; // esi
  int v5; // ebx
  unsigned int v6; // ebp
  unsigned int v7; // eax
  unsigned __int16 *v8; // ebx
  unsigned int v9; // edi
  unsigned int i; // esi
  int result; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // [esp+10h] [ebp-38h]
  int v15; // [esp+18h] [ebp-30h]
  int v16; // [esp+1Ch] [ebp-2Ch]
  int v18; // [esp+24h] [ebp-24h]

  v2 = gconv_cache;
  v16 = *(unsigned __int16 *)(gconv_cache + 4);
  v18 = *(unsigned __int16 *)(gconv_cache + 6);
  v3 = _hash_string(a1);
  v4 = *(unsigned __int16 *)(v2 + 8);
  v15 = v2;
  v5 = v3 % v4;
  v6 = v3 % (v4 - 2) + 1;
  v14 = cache_size - *(unsigned __int16 *)(v2 + 4);
LABEL_2:
  v7 = v5 + v6;
  v8 = (unsigned __int16 *)(v15 + v18 + 4 * v5);
  v9 = v4;
  for ( i = v7; ; i += v6 )
  {
    v12 = *v8;
    if ( !(_WORD)v12 )
      return -1;
    if ( v14 > v12 )
    {
      result = j_strcmp(a1, v15 + v16 + v12);
      if ( !result )
        break;
    }
    v8 += 2 * v6;
    if ( v9 <= i )
    {
      v13 = i;
      v4 = v9;
      v5 = v13 - v9;
      goto LABEL_2;
    }
  }
  *a2 = v8[1];
  return result;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80EC5BC: using guessed type int cache_size;
// 80EC5C0: using guessed type int gconv_cache;

//----- (08078850) --------------------------------------------------------
int __usercall find_module@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, int **a3@<ecx>)
{
  int v6; // eax
  unsigned int v7; // ecx
  void *v8; // esp
  _WORD *v9; // eax
  int *shlib; // eax
  int v11; // edx
  int v12; // esi
  int v13; // eax
  int result; // eax
  int (__cdecl *v15)(int **); // esi
  int *v16; // edx
  _BYTE v17[12]; // [esp+Ch] [ebp-28h] BYREF
  int v18; // [esp+18h] [ebp-1Ch]
  int savedregs; // [esp+34h] [ebp+0h] BYREF

  v18 = strlen(a1);
  v6 = strlen(a2);
  v7 = v18;
  v18 = v6 + 1;
  v8 = alloca(v6 + 1 + v7);
  v9 = mempcpy(v17, a1, v7);
  memcpy(v9, a2, v18);
  shlib = _gconv_find_shlib(v17, (int)&savedregs, (unsigned int)a2);
  *a3 = shlib;
  if ( !shlib )
    return 1;
  v11 = shlib[3];
  v12 = shlib[4];
  v13 = shlib[5];
  a3[1] = 0;
  a3[6] = 0;
  a3[14] = 0;
  a3[5] = (int *)v11;
  a3[7] = (int *)v12;
  a3[8] = (int *)v13;
  result = 0;
  if ( v12 )
  {
    v15 = (int (__cdecl *)(int **))(__readgsdword(0x18u) ^ __ROR4__(v12, 9));
    dl_mcount_wrapper_check((int)v15);
    result = v15(a3);
    v16 = a3[6];
    if ( v16 )
      a3[6] = (int *)__ROL4__(__readgsdword(0x18u) ^ (unsigned int)v16, 9);
  }
  return result;
}

//----- (08078930) --------------------------------------------------------
int _gconv_get_cache()
{
  return gconv_cache;
}
// 80EC5C0: using guessed type int gconv_cache;

//----- (08078940) --------------------------------------------------------
int _gconv_load_cache()
{
  unsigned int v0; // eax
  int v1; // ebx
  int v2; // ecx
  int v3; // ecx
  unsigned int v4; // ebx
  int v5; // eax
  int result; // eax
  int v7; // esi
  int v8; // eax
  unsigned int v9; // edi
  int v10; // eax
  char v11[44]; // [esp+Ch] [ebp-6Ch] BYREF
  unsigned int v12; // [esp+38h] [ebp-40h]

  _gconv_path_envvar = getenv("GCONV_PATH");
  if ( _gconv_path_envvar )
    return -1;
  v0 = dl_sysinfo(0);
  v1 = v0;
  if ( v0 > 0xFFFFF000 )
    v1 = _syscall_error(v0);
  if ( v1 == -1 )
    return -1;
  if ( (_fxstat64(3, v1, (int)v11) & 0x80000000) != 0 || v12 <= 0xF )
    goto LABEL_27;
  cache_size = v12;
  gconv_cache = mmap(0, v12, 1, 1, v1, 0);
  if ( gconv_cache != -1 )
    goto LABEL_8;
  v7 = cache_size;
  v8 = malloc(cache_size);
  gconv_cache = v8;
  if ( !v8 )
  {
LABEL_27:
    dl_sysinfo(v2);
    return -1;
  }
  v9 = 0;
  while ( 1 )
  {
    v10 = read(v1, v9 + v8, v7 - v9);
    if ( v10 == -1 )
    {
      free(gconv_cache);
      gconv_cache = 0;
      goto LABEL_27;
    }
    v7 = cache_size;
    v9 += v10;
    if ( v9 >= cache_size )
      break;
    v8 = gconv_cache;
  }
  cache_malloced = 1;
LABEL_8:
  dl_sysinfo(v3);
  if ( *(_DWORD *)gconv_cache != 536937252
    || *(unsigned __int16 *)(gconv_cache + 4) >= (unsigned int)cache_size
    || (v4 = *(unsigned __int16 *)(gconv_cache + 6), cache_size <= v4)
    || (v5 = *(unsigned __int16 *)(gconv_cache + 8), !(_WORD)v5)
    || cache_size < v4 + 4 * v5
    || cache_size <= (unsigned int)*(unsigned __int16 *)(gconv_cache + 10)
    || (result = 0, cache_size < (unsigned int)*(unsigned __int16 *)(gconv_cache + 12)) )
  {
    if ( cache_malloced )
    {
      free(gconv_cache);
      cache_malloced = 0;
    }
    else
    {
      munmap(gconv_cache, cache_size);
    }
    gconv_cache = 0;
    return -1;
  }
  return result;
}
// 80789DF: variable 'v3' is possibly undefined
// 8078AE8: variable 'v2' is possibly undefined
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EC5B8: using guessed type int cache_malloced;
// 80EC5BC: using guessed type int cache_size;
// 80EC5C0: using guessed type int gconv_cache;
// 80ECCE0: using guessed type int _gconv_path_envvar;
// 8078940: using guessed type char var_6C[44];

//----- (08078B20) --------------------------------------------------------
int __usercall _gconv_compare_alias_cache@<eax>(unsigned __int8 *a1@<eax>, unsigned __int8 *a2@<edx>, _DWORD *a3@<ecx>)
{
  int result; // eax
  int v7; // [esp+0h] [ebp-14h] BYREF
  int v8[4]; // [esp+4h] [ebp-10h] BYREF

  if ( !gconv_cache )
    return -1;
  if ( find_module_idx(a1, &v7) || (result = find_module_idx(a2, v8)) != 0 )
  {
    *a3 = j_strcmp(a1, a2);
    return 0;
  }
  else
  {
    *a3 = v7 - v8[0];
  }
  return result;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80EC5C0: using guessed type int gconv_cache;
// 8078B20: using guessed type int var_10[4];

//----- (08078B90) --------------------------------------------------------
int __userpurge _gconv_lookup_cache@<eax>(
        unsigned __int8 *a1@<eax>,
        unsigned __int8 *a2@<edx>,
        _DWORD *a3@<ecx>,
        int *a4,
        char a5)
{
  int module_idx; // esi
  int v6; // ebx
  int v8; // edi
  int v9; // ebp
  int v11; // eax
  int v12; // edx
  int v13; // ebp
  int v14; // ecx
  unsigned __int16 *v15; // edi
  int v16; // eax
  int v17; // eax
  int v18; // ebx
  int v19; // eax
  _BYTE *v20; // eax
  int module; // eax
  int v22; // edi
  int **v23; // ecx
  int v24; // eax
  _BYTE *v25; // eax
  int v26; // ebp
  int v27; // eax
  unsigned __int16 *v28; // ebx
  int v29; // eax
  int v30; // eax
  int v31; // ebp
  unsigned __int16 *v32; // edi
  int v33; // esi
  int v34; // eax
  int v35; // eax
  int v36; // eax
  _BYTE *v37; // eax
  int v39; // [esp+0h] [ebp-4Ch]
  int v40; // [esp+4h] [ebp-48h]
  int v41; // [esp+4h] [ebp-48h]
  int v42; // [esp+8h] [ebp-44h]
  int v43; // [esp+Ch] [ebp-40h]
  unsigned __int16 *v44; // [esp+10h] [ebp-3Ch]
  int v45; // [esp+14h] [ebp-38h]
  unsigned __int16 *v46; // [esp+1Ch] [ebp-30h]
  int v47; // [esp+28h] [ebp-24h] BYREF
  int v48[8]; // [esp+2Ch] [ebp-20h] BYREF

  module_idx = 2;
  v6 = gconv_cache;
  if ( !gconv_cache )
    return module_idx;
  v8 = *(unsigned __int16 *)(gconv_cache + 4);
  v9 = *(unsigned __int16 *)(gconv_cache + 10);
  if ( find_module_idx(a2, &v47) )
    return 1;
  if ( 4 * (3 * v47 + 3) + (unsigned int)*(unsigned __int16 *)(v6 + 10) > cache_size )
    return 1;
  v40 = 4 * (3 * v47 + 3);
  module_idx = find_module_idx(a1, v48);
  if ( module_idx )
    return 1;
  v11 = 4 * (3 * v48[0] + 3);
  if ( v11 + (unsigned int)*(unsigned __int16 *)(v6 + 10) > cache_size )
    return 1;
  v12 = v6 + v9;
  v13 = v47;
  v14 = v40;
  v43 = v12;
  v44 = (unsigned __int16 *)(v12 + v11 - 12);
  if ( (a5 & 1) != 0 && v48[0] == v47 )
    return -1;
  v41 = v6 + v8;
  v15 = (unsigned __int16 *)(v12 + v14 - 12);
  if ( v48[0] && v47 )
  {
    v16 = v15[5];
    if ( (_WORD)v16 )
    {
      v28 = (unsigned __int16 *)(gconv_cache + *(unsigned __int16 *)(v6 + 12) + v16 - 1);
      v29 = *v28;
      if ( (_WORD)v29 )
      {
        if ( v48[0] == v28[3 * v29 - 2] )
        {
LABEL_39:
          *a4 = v29;
          v45 = malloc(60 * v29);
          *a3 = v45;
          if ( v45 )
          {
            v30 = *v15;
            v46 = v15;
            v31 = v45;
            v42 = 0;
            v32 = v28 + 1;
            v33 = v41 + v30;
            do
            {
              v34 = *v32;
              *(_DWORD *)(v31 + 12) = v33;
              v35 = *(unsigned __int16 *)(v43 + 12 * v34);
              *(_DWORD *)(v31 + 8) = 1;
              *(_DWORD *)(v31 + 56) = 0;
              v33 = v35 + v41;
              v36 = v32[1];
              *(_DWORD *)(v31 + 16) = v33;
              v37 = (_BYTE *)(v41 + v36);
              if ( *v37 )
              {
                if ( find_module(v37, (_BYTE *)(v41 + v32[2]), (int **)v31) )
                {
                  v15 = v46;
                  module_idx = 0;
                  free(v45);
                  v13 = v47;
                  goto LABEL_24;
                }
              }
              else
              {
                _gconv_get_builtin_trans(v41 + v32[2], (_DWORD *)v31);
              }
              ++v42;
              v31 += 60;
              v32 += 3;
            }
            while ( v42 < *v28 );
            return 0;
          }
          return 3;
        }
        while ( 1 )
        {
          v28 += 3 * v29 + 1;
          v29 = *v28;
          if ( !(_WORD)v29 )
            break;
          if ( v48[0] == v28[3 * v29 - 2] )
            goto LABEL_39;
        }
      }
    }
  }
  else
  {
LABEL_24:
    if ( !v13 )
    {
      if ( !v48[0] )
        return 1;
LABEL_26:
      if ( v44[4] )
      {
        v27 = malloc(120);
        v18 = v27;
        if ( v27 )
        {
          *a3 = v27;
          *a4 = 0;
          if ( !v13 )
            goto LABEL_19;
          goto LABEL_16;
        }
        return 3;
      }
      return 1;
    }
  }
  if ( !v15[2] )
    return 1;
  if ( v48[0] )
    goto LABEL_26;
  v17 = malloc(120);
  v18 = v17;
  if ( !v17 )
    return 3;
  *a3 = v17;
  *a4 = 0;
LABEL_16:
  v19 = *v15;
  *(_DWORD *)(v18 + 16) = "INTERNAL";
  *(_DWORD *)(v18 + 8) = 1;
  *(_DWORD *)(v18 + 56) = 0;
  *(_DWORD *)(v18 + 12) = v41 + v19;
  v20 = (_BYTE *)(v41 + v15[3]);
  if ( *v20 )
  {
    module = find_module(v20, (_BYTE *)(v41 + v15[4]), (int **)v18);
    if ( module )
    {
      v39 = module;
      free(v18);
      return v39;
    }
  }
  else
  {
    _gconv_get_builtin_trans(v41 + v15[4], (_DWORD *)v18);
  }
  ++*a4;
LABEL_19:
  if ( v48[0] )
  {
    v22 = *a4;
    v23 = (int **)(v18 + 60 * *a4);
    v23[4] = (int *)(v41 + *v44);
    v24 = v44[1];
    v23[3] = (int *)"INTERNAL";
    v23[2] = (int *)1;
    v23[14] = 0;
    v25 = (_BYTE *)(v41 + v24);
    if ( !*v25 )
    {
      _gconv_get_builtin_trans(v41 + v44[2], v23);
      goto LABEL_22;
    }
    v26 = find_module(v25, (_BYTE *)(v41 + v44[2]), v23);
    if ( !v26 )
    {
LABEL_22:
      ++*a4;
      return module_idx;
    }
    if ( v22 )
      _gconv_release_step((int *)v18);
    module_idx = v26;
    free(v18);
  }
  return module_idx;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EC5BC: using guessed type int cache_size;
// 80EC5C0: using guessed type int gconv_cache;
// 8078B90: using guessed type int var_20[8];

//----- (08078F80) --------------------------------------------------------
int __usercall _gconv_release_cache@<eax>(int result@<eax>)
{
  if ( gconv_cache )
    return free(result);
  return result;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EC5C0: using guessed type int gconv_cache;

//----- (08078FA0) --------------------------------------------------------
int __cdecl known_compare(_DWORD *a1, _DWORD *a2)
{
  return j_strcmp(*a1, *a2);
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);

//----- (08078FC0) --------------------------------------------------------
int __usercall do_release_shlib@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int *a4, int a5)
{
  int result; // eax
  int v6; // ebx

  result = a5;
  if ( !a5 || a5 == 3 )
  {
    v6 = *a4;
    result = *(_DWORD *)(*a4 + 4);
    if ( *a4 == release_handle )
    {
      if ( result <= 0 )
        _assert_fail("obj->counter > 0", "gconv_dl.c", 173, "do_release_shlib");
      *(_DWORD *)(v6 + 4) = --result;
    }
    else if ( (unsigned int)result >= 0xFFFFFFFE || result == 0 )
    {
      *(_DWORD *)(v6 + 4) = --result;
      if ( result == -3 )
      {
        result = *(_DWORD *)(v6 + 8);
        if ( result )
        {
          result = _libc_dlclose(a1, a2, a3, *(_DWORD *)(v6 + 8));
          *(_DWORD *)(v6 + 8) = 0;
        }
      }
    }
  }
  return result;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EC5C4: using guessed type int release_handle;

//----- (08079050) --------------------------------------------------------
int *__usercall _gconv_find_shlib@<eax>(_BYTE *a1@<eax>, int a2@<ebp>, unsigned int a3@<esi>)
{
  int **v3; // eax
  int *v4; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v11; // edx
  bool v12; // cc
  int v13; // eax
  _BYTE *v14; // edi
  int v15; // esi
  int v16; // eax
  int v17; // [esp+4h] [ebp-28h]
  _BYTE *v18; // [esp+1Ch] [ebp-10h] BYREF

  v18 = a1;
  v3 = (int **)tfind((int)&v18, &loaded, (int (__cdecl *)(int, _DWORD))known_compare);
  if ( v3 )
  {
    v4 = *v3;
    if ( !*v3 )
      return 0;
  }
  else
  {
    v14 = v18;
    v15 = strlen(v18);
    v16 = malloc(v15 + 25);
    v4 = (int *)v16;
    if ( !v16 )
      return 0;
    a3 = v15 + 1;
    *(_DWORD *)v16 = memcpy((_BYTE *)(v16 + 24), v14, a3);
    v4[1] = -3;
    v4[2] = 0;
    if ( !tsearch((int)v4, &loaded, (int (__cdecl *)(int, _DWORD))known_compare) )
    {
      free(v4);
      return 0;
    }
  }
  v5 = v4[1];
  if ( v5 >= -2 )
  {
    if ( v4[2] )
    {
      v11 = v5 + 1;
      v12 = v5 <= 0;
      v13 = 1;
      if ( !v12 )
        v13 = v11;
      v4[1] = v13;
    }
    return v4;
  }
  if ( v4[2] )
    _assert_fail("found->handle == NULL", "gconv_dl.c", 115, "__gconv_find_shlib");
  v6 = _libc_dlopen_mode(a2, 0, a3, *v4, -2147483647);
  v4[2] = v6;
  if ( !v6 )
    return 0;
  v7 = _libc_dlsym(a2, 0, a3, v6, (int)"gconv");
  v4[3] = v7;
  if ( !v7 )
  {
    release_handle = (int)v4;
    v4 = 0;
    twalk(loaded, (int (__cdecl *)(int, int, int))do_release_shlib);
    return v4;
  }
  v4[4] = _libc_dlsym(a2, 0, a3, v4[2], (int)"gconv_init");
  v4[5] = _libc_dlsym(a2, 0, v17, v4[2], (int)"gconv_end");
  v4[3] = __ROL4__(__readgsdword(0x18u) ^ v4[3], 9);
  v8 = v4[4];
  if ( v8 )
    v4[4] = __ROL4__(__readgsdword(0x18u) ^ v8, 9);
  v9 = v4[5];
  if ( v9 )
    v4[5] = __ROL4__(__readgsdword(0x18u) ^ v9, 9);
  v4[1] = 1;
  return v4;
}
// 80790F0: variable 'v17' is possibly undefined
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EC5C4: using guessed type int release_handle;
// 80EC5C8: using guessed type int loaded;

//----- (08079230) --------------------------------------------------------
int __usercall _gconv_release_shlib@<eax>(int a1@<eax>)
{
  release_handle = a1;
  return twalk(loaded, (int (__cdecl *)(int, int, int))do_release_shlib);
}
// 80EC5C4: using guessed type int release_handle;
// 80EC5C8: using guessed type int loaded;

//----- (08079250) --------------------------------------------------------
_BYTE *__usercall new_composite_name@<eax>(int a1@<eax>, _DWORD *a2@<edx>, long double a3@<st0>)
{
  unsigned int v4; // esi
  int v5; // ebx
  _BYTE *v6; // ebp
  int v7; // ecx
  int v8; // eax
  void *v9; // ebx
  _BYTE *v10; // esi
  int v12; // eax
  _BYTE *v13; // edx
  int v14; // esi
  int (*v15)[256]; // ebx
  _BYTE *v16; // eax
  _BYTE *v17; // eax
  _BYTE *v18; // eax
  _BOOL4 v19; // [esp+4h] [ebp-28h]
  int v20; // [esp+4h] [ebp-28h]
  int v22; // [esp+Ch] [ebp-20h]
  int v23; // [esp+Ch] [ebp-20h]

  v4 = 0;
  v5 = 1;
  v19 = 1;
  while ( 1 )
  {
    if ( v5 != 7 )
    {
      if ( a1 == 6 )
      {
        v6 = (_BYTE *)a2[v5 - 1];
      }
      else if ( a1 == v5 - 1 )
      {
        v6 = (_BYTE *)*a2;
      }
      else
      {
        v6 = *(&off_80EBEDC + v5);
      }
      v7 = strlen(v6);
      v4 += v7 + (unsigned __int8)byte_80C0273[v5] + 2;
      if ( v19 && v6 != (_BYTE *)*a2 )
      {
        v22 = v7;
        v8 = j_strcmp(v6, *a2);
        v7 = v22;
        v19 = v8 == 0;
      }
      if ( v5 == 13 )
        break;
    }
    ++v5;
  }
  v23 = v7;
  if ( v19 )
  {
    v9 = &nl_C_name;
    v10 = (_BYTE *)*a2;
    if ( !j_strcmp(*a2, &nl_C_name) || !j_strcmp(v10, "POSIX") )
      return v9;
    v18 = (_BYTE *)malloc(a3, v23 + 1);
    if ( v18 )
      return memcpy(v18, v10, v23 + 1);
    return 0;
  }
  v12 = malloc(a3, v4);
  if ( !v12 )
    return 0;
  v13 = (_BYTE *)v12;
  v14 = 1;
  v20 = v12;
  while ( 1 )
  {
    if ( v14 != 7 )
    {
      if ( a1 == 6 )
        v15 = (int (*)[256])a2[v14 - 1];
      else
        v15 = a1 == v14 - 1 ? (int (*)[256])*a2 : *(&off_80EBEDC + v14);
      v16 = (_BYTE *)j_stpcpy(v13, (unsigned __int8)byte_80C0283[v14] + 135004832);
      *v16 = 61;
      v17 = (_BYTE *)j_stpcpy(v16 + 1, v15);
      v13 = v17 + 1;
      *v17 = 59;
      if ( v14 == 13 )
        break;
    }
    ++v14;
  }
  *v17 = 0;
  return (_BYTE *)v20;
}
// 8048210: using guessed type int __cdecl j_stpcpy(_DWORD, _DWORD);
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80EBEDC: using guessed type int (*off_80EBEDC)[256];

//----- (08079430) --------------------------------------------------------
int __usercall setlocale@<eax>(long double a1@<st0>, unsigned int a2, _BYTE *a3)
{
  _BYTE *v3; // ebx
  unsigned int v4; // ebp
  void **v5; // esi
  char *v7; // eax
  int v8; // eax
  int v9; // eax
  void **locale; // eax
  void **v11; // esi
  _BYTE *v12; // ebx
  void (__cdecl *v13)(); // eax
  void **v14; // esi
  void **v15; // eax
  int v16; // ebx
  int v17; // edi
  int v18; // eax
  void **v19; // eax
  _BYTE *v20; // esi
  int v21; // ebp
  _BYTE *v22; // eax
  int (*v23)[256]; // eax
  _BYTE *v24; // eax
  _BYTE *v25; // edi
  int v26; // eax
  int v27; // ebx
  int v28; // esi
  int v29; // ebp
  _BYTE *v30; // eax
  int j; // ebx
  void (*v32)(void); // eax
  int (*v33)[256]; // edi
  int (*v34)[256]; // eax
  int i; // eax
  int v36; // [esp+8h] [ebp-94h]
  int v37; // [esp+8h] [ebp-94h]
  int v38; // [esp+Ch] [ebp-90h]
  char *v39; // [esp+10h] [ebp-8Ch] BYREF
  unsigned int v40; // [esp+14h] [ebp-88h] BYREF
  int v41[13]; // [esp+18h] [ebp-84h] BYREF
  int v42[20]; // [esp+4Ch] [ebp-50h] BYREF

  v3 = a3;
  if ( a2 > 0xC )
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    return 0;
  }
  else
  {
    if ( !a3 )
      return (int)*(&off_80EBEE0 + a2);
    v4 = a2 + 16;
    v5 = nl_global_locale[a2 + 16];
    if ( !j_strcmp(a3, v5) )
      return (int)v5;
    v39 = 0;
    v40 = 0;
    v7 = (char *)getenv("LOCPATH");
    if ( v7
      && *v7
      && (argz_create_sep(a1, v7, 58, (unsigned int *)&v39, (int *)&v40)
       || argz_add_sep((int *)&v39, &v40, "/usr/lib/locale", 58)) )
    {
      return 0;
    }
    v8 = 1;
    if ( a2 != 6 )
    {
      v9 = nl_current_used[a2];
      v42[0] = (int)a3;
      v36 = v9;
      if ( v9 )
      {
        locale = nl_find_locale(v39, v40, a2, a1, (char *)v42);
        v11 = locale;
        if ( !locale )
          goto LABEL_73;
        if ( locale[6] != (void *)-1 )
          locale[6] = (void *)-1;
        v3 = (_BYTE *)v42[0];
      }
      else
      {
        v11 = 0;
      }
      if ( v3 == (_BYTE *)&nl_C_name || (v42[0] = (int)strdup(v3)) != 0 )
      {
        v12 = new_composite_name(a2, v42, a1);
        if ( v12 )
        {
          if ( v36 )
          {
            v13 = (void (__cdecl *)())nl_category_postload[a2];
            nl_global_locale[a2] = v11;
            if ( v13 )
              v13();
          }
          v14 = (void **)v42[0];
          v15 = nl_global_locale[v4];
          if ( (void **)v42[0] != v15 )
          {
            if ( v15 != (void **)&nl_C_name )
              free(a1, (int)nl_global_locale[v4]);
            nl_global_locale[v4] = v14;
          }
          if ( v12 != off_80EBEF8 )
          {
            if ( off_80EBEF8 != &nl_C_name )
              free(a1, (int)off_80EBEF8);
            off_80EBEF8 = v12;
          }
          ++nl_msg_cat_cntr;
          goto LABEL_28;
        }
        if ( (_UNKNOWN *)v42[0] != &nl_C_name )
          free(a1, v42[0]);
      }
LABEL_73:
      v42[0] = 0;
LABEL_28:
      free(a1, (int)v39);
      return v42[0];
    }
    while ( 1 )
    {
      if ( v8 != 7 )
      {
        v41[v8 - 1] = (int)a3;
        if ( v8 == 13 )
          break;
      }
      ++v8;
    }
    v37 = j_strchr(a3, 59);
    if ( !v37 )
      goto LABEL_33;
    v24 = strdup(a3);
    v37 = (int)v24;
    if ( !v24 )
      return 0;
    v25 = v24;
LABEL_61:
    v26 = j_strchr(v25, 61);
    v38 = v26;
    if ( v26 )
    {
      v27 = 1;
      v28 = 0;
      v29 = v26 - (_DWORD)v25;
      while ( 1 )
      {
        if ( v28 != 6 )
        {
          if ( (unsigned __int8)nl_category_name_sizes[v28] == v29
            && !j_memcmp(v25, (unsigned __int8)nl_category_name_idxs[v28] + 135004832, v29) )
          {
            v41[v28] = v38 + 1;
            v30 = (_BYTE *)j_strchr(v38 + 1, 59);
            if ( !v30 )
              break;
            *v30 = 0;
            v25 = v30 + 1;
            goto LABEL_61;
          }
          if ( v27 == 13 )
          {
LABEL_70:
            v5 = 0;
            free(a1, v37);
            __writegsdword(0xFFFFFFE8, 0x16u);
            return (int)v5;
          }
        }
        ++v28;
        ++v27;
      }
    }
    for ( i = 1; ; ++i )
    {
      if ( i != 7 )
      {
        if ( a3 == (_BYTE *)v41[i - 1] )
          goto LABEL_70;
        if ( i == 13 )
          break;
      }
    }
LABEL_33:
    v16 = 12;
    v17 = 13;
    while ( 1 )
    {
      v19 = nl_find_locale(v39, v40, v16, a1, (char *)&v41[v16]);
      v42[v16] = (int)v19;
      if ( v19 )
      {
        if ( v19[6] != (void *)-1 )
          v19[6] = (void *)-1;
        v20 = (_BYTE *)v41[v16];
        if ( v20 != (_BYTE *)&nl_C_name )
        {
          v21 = (int)*(&off_80EBEE0 + v16);
          if ( !j_strcmp(v20, v21) )
          {
            v41[v16] = v21;
          }
          else
          {
            v22 = strdup(v20);
            v41[v16] = (int)v22;
            if ( !v22 )
              goto LABEL_45;
          }
        }
      }
      else if ( (_UNKNOWN *)v41[v16] != &nl_C_name )
      {
LABEL_45:
        if ( v16 >= 0 )
          goto LABEL_46;
        goto LABEL_78;
      }
      v18 = v16 - 1;
      if ( v16 <= 0 )
        break;
      if ( v16 == 7 )
      {
        v16 = 6;
        v18 = 5;
      }
      v17 = v16;
      v16 = v18;
    }
    v17 = v16;
    if ( v18 >= 0 )
    {
      while ( 1 )
      {
        do
LABEL_47:
          ++v17;
        while ( v17 == 7 );
        v23 = (int (*)[256])v41[v17 - 1];
        if ( v23 == (int (*)[256])&nl_C_name || v23 == *(&off_80EBEDC + v17) )
          goto LABEL_46;
        free(a1, v41[v17 - 1]);
        if ( v17 == 13 )
          goto LABEL_51;
      }
    }
LABEL_78:
    v5 = (void **)new_composite_name(6, v41, a1);
    if ( v5 )
    {
      for ( j = 1; ; ++j )
      {
        if ( j != 7 )
        {
          if ( dword_80C033C[j] )
          {
            dword_80EBE9C[j] = v41[j + 12];
            v32 = (void (*)(void))dword_80C023C[j];
            if ( v32 )
              v32();
          }
          v33 = (int (*)[256])v41[j - 1];
          v34 = *(&off_80EBEDC + j);
          if ( v33 != v34 )
          {
            if ( v34 != (int (*)[256])&nl_C_name )
              free(a1, (int)*(&off_80EBEDC + j));
            *(&off_80EBEDC + j) = v33;
          }
          if ( j == 13 )
            break;
        }
      }
      if ( v5 != off_80EBEF8 )
      {
        if ( off_80EBEF8 != &nl_C_name )
          free(a1, (int)off_80EBEF8);
        off_80EBEF8 = v5;
      }
      ++nl_msg_cat_cntr;
      goto LABEL_52;
    }
LABEL_46:
    if ( v17 != 13 )
      goto LABEL_47;
LABEL_51:
    v5 = 0;
LABEL_52:
    free(a1, (int)v39);
    free(a1, v37);
    return (int)v5;
  }
}
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 80C023C: using guessed type int dword_80C023C[];
// 80C0240: using guessed type int (*nl_category_postload[12])();
// 80C033C: using guessed type int dword_80C033C[];
// 80C0340: using guessed type int nl_current_used[13];
// 80EBE9C: using guessed type int dword_80EBE9C[];
// 80EBEA0: using guessed type void **nl_global_locale[6];
// 80EBEDC: using guessed type int (*off_80EBEDC)[256];
// 80EBEE0: using guessed type void *off_80EBEE0;
// 80EBEF8: using guessed type void *off_80EBEF8;
// 80ECC34: using guessed type int nl_msg_cat_cntr;

//----- (08079A60) --------------------------------------------------------
_BYTE *__usercall strip@<eax>(_BYTE *a1@<eax>, char *a2@<edx>, int a3@<ebx>)
{
  char v3; // cl
  int v4; // edi
  _BYTE *result; // eax
  _BYTE *v6; // edx
  _BYTE *v7; // [esp+0h] [ebp-18h]
  int v8; // [esp+4h] [ebp-14h]

  v3 = *a2;
  if ( *a2 )
  {
    v8 = 0;
    v7 = a1;
    do
    {
      while ( 1 )
      {
        LOBYTE(a3) = v3 == 58;
        v4 = a3;
        LOBYTE(a3) = v3 == 95;
        a3 |= v4;
        if ( !((unsigned __int8)a3 | ((unsigned __int8)(v3 - 44) <= 2u)) && (byte_80C2440[2 * v3] & 8) == 0 )
          break;
        ++a2;
        *v7 = dword_80C1B40[v3];
        v3 = *a2;
        ++v7;
        if ( !*a2 )
          goto LABEL_8;
      }
      if ( v3 == 47 )
      {
        ++v8;
        result = v7;
        if ( v8 == 3 )
          goto LABEL_11;
        *v7++ = 47;
      }
      v3 = *++a2;
    }
    while ( *a2 );
LABEL_8:
    result = v7;
    if ( v8 <= 1 )
    {
      *v7 = 47;
      if ( v8 )
      {
        result = v7 + 1;
      }
      else
      {
        result = v7 + 2;
        v7[1] = 47;
      }
    }
LABEL_11:
    *result = 0;
  }
  else
  {
    v6 = a1 + 1;
    *a1 = 47;
    result = a1 + 2;
    *v6 = 47;
    *result = 0;
  }
  return result;
}
// 80C1B40: using guessed type _DWORD dword_80C1B40[256];
// 80C2440: using guessed type _BYTE byte_80C2440[512];

//----- (08079B50) --------------------------------------------------------
void **__userpurge nl_find_locale@<eax>(
        char *a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        long double a4@<st0>,
        char *a5)
{
  _BYTE *v7; // ebx
  unsigned int v8; // eax
  int v9; // eax
  void **result; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  _BYTE *v14; // ebx
  int v15; // eax
  void *v16; // esp
  unsigned __int8 *v17; // eax
  unsigned int v18; // eax
  int v19; // ebx
  _DWORD *l10nflist; // ecx
  char v21; // dl
  _DWORD *v22; // ebx
  char *v23; // ebx
  void *v24; // esp
  void *v25; // esp
  unsigned int v26; // ecx
  unsigned __int8 *v27; // eax
  int v28; // edx
  unsigned __int8 *v29; // eax
  int v30; // edx
  bool v31; // zf
  unsigned int v32; // edx
  char *v33; // ecx
  int v34; // eax
  int v35; // eax
  _BYTE *v36; // edx
  unsigned __int8 v37[4]; // [esp+0h] [ebp-48h] BYREF
  char *v38; // [esp+4h] [ebp-44h]
  unsigned int v39; // [esp+8h] [ebp-40h]
  unsigned int v40; // [esp+Ch] [ebp-3Ch]
  _BYTE *v41; // [esp+18h] [ebp-30h] BYREF
  unsigned __int8 *v42; // [esp+1Ch] [ebp-2Ch] BYREF
  _BYTE *v43; // [esp+20h] [ebp-28h] BYREF
  unsigned __int8 *v44; // [esp+24h] [ebp-24h] BYREF
  char *v45; // [esp+28h] [ebp-20h] BYREF
  unsigned __int8 *v46; // [esp+2Ch] [ebp-1Ch] BYREF

  v39 = a2;
  v7 = *(_BYTE **)a5;
  v41 = v7;
  if ( !*v7 )
  {
    v11 = (_BYTE *)getenv("LC_ALL");
    v41 = v11;
    if ( v11 && *v11
      || (v12 = (_BYTE *)getenv((_BYTE *)((unsigned __int8)nl_category_name_idxs[a3] + 135004832)), (v41 = v12) != 0)
      && *v12 )
    {
      v13 = v41;
    }
    else
    {
      v13 = (_BYTE *)getenv("LANG");
      v41 = v13;
      if ( !v13 )
        goto LABEL_21;
    }
    if ( *v13 )
    {
      v7 = v41;
      goto LABEL_2;
    }
LABEL_21:
    *(_DWORD *)a5 = &nl_C_name;
    return nl_C[a3];
  }
LABEL_2:
  if ( !j_strcmp(v7, &nl_C_name) || !j_strcmp(v7, "POSIX") )
    goto LABEL_21;
  v8 = strlen(v7);
  if ( v8 > 0xFF )
    goto LABEL_23;
  v40 = v8;
  if ( memmem((int)v7, v8, slashdot_9272, 4u) )
    goto LABEL_23;
  if ( v40 == 2 )
  {
    if ( *v7 == 46 )
    {
      if ( v7[1] == 46 || j_memchr(v7, 47, 2) )
        goto LABEL_23;
      goto LABEL_11;
    }
  }
  else if ( v40 > 2
         && (*v7 == 46 && v7[1] == 46 && v7[2] == 47 || v7[v40 - 3] == 47 && v7[v40 - 2] == 46 && v7[v40 - 1] == 46) )
  {
    goto LABEL_23;
  }
  if ( j_memchr(v7, 47, v40) && *v7 != 47 )
  {
LABEL_23:
    __writegsdword(0xFFFFFFE8, 0x16u);
    return 0;
  }
LABEL_11:
  v9 = (int)v41;
  *(_DWORD *)a5 = v41;
  if ( a1 )
  {
    v14 = (_BYTE *)nl_expand_alias(a4, v9);
    v41 = v14;
    goto LABEL_30;
  }
  result = (void **)nl_load_locale_from_archive(a3, a5, a5, a4);
  if ( result )
    return result;
  v41 = (_BYTE *)nl_expand_alias(a4, *(_DWORD *)a5);
  if ( v41 )
  {
    result = (void **)nl_load_locale_from_archive(a3, &v41, v33, a4);
    if ( result )
      return result;
    v14 = v41;
    v39 = 16;
    a1 = "/usr/lib/locale";
LABEL_30:
    if ( v14 )
      goto LABEL_31;
    goto LABEL_59;
  }
  v39 = 16;
  a1 = "/usr/lib/locale";
LABEL_59:
  v14 = *(_BYTE **)a5;
  v41 = *(_BYTE **)a5;
LABEL_31:
  v15 = strlen(v14);
  v16 = alloca(v15 + 16);
  v17 = memcpy(v37, v14, v15 + 1);
  v18 = nl_explode_name(v17, &v42, &v43, &v44, &v45, &v46);
  if ( v18 == -1 )
    return 0;
  v19 = (unsigned __int8)nl_category_name_idxs[a3];
  v40 = v18;
  v38 = &nl_category_names[v19];
  l10nflist = nl_make_l10nflist(
                &nl_locale_file_list[a3],
                a1,
                v39,
                v18,
                v42,
                v44,
                v45,
                v46,
                v43,
                &nl_category_names[v19],
                0);
  v21 = v40;
  if ( !l10nflist )
  {
    l10nflist = nl_make_l10nflist(&nl_locale_file_list[a3], a1, v39, v40, v42, v44, v45, v46, v43, v38, 1);
    v21 = v40;
    if ( !l10nflist )
      return 0;
  }
  if ( (v21 & 1) != 0 )
  {
    v40 = (unsigned int)l10nflist;
    free(a4, (int)v46);
    l10nflist = (_DWORD *)v40;
  }
  if ( !l10nflist[1] )
  {
    v40 = (unsigned int)l10nflist;
    nl_load_locale((int)l10nflist, a3, a4);
    l10nflist = (_DWORD *)v40;
  }
  v22 = (_DWORD *)l10nflist[2];
  if ( !v22 )
  {
    v34 = l10nflist[4];
    if ( v34 )
    {
      do
      {
        if ( !*(_DWORD *)(v34 + 4) )
        {
          v40 = (unsigned int)l10nflist;
          nl_load_locale(v34, a3, a4);
          l10nflist = (_DWORD *)v40;
        }
        v34 = l10nflist[(_DWORD)v22 + 4];
        if ( *(_DWORD *)(v34 + 8) )
          break;
        v22 = (_DWORD *)((char *)v22 + 1);
        v34 = l10nflist[(_DWORD)v22 + 4];
      }
      while ( v34 );
    }
    else
    {
      v22 = 0;
    }
    l10nflist[4] = v34;
    l10nflist = (_DWORD *)l10nflist[(_DWORD)v22 + 4];
    if ( !l10nflist )
      return 0;
    v22 = (_DWORD *)l10nflist[2];
  }
  if ( v45 )
  {
    v23 = (char *)v22[codeset_idx_9315[a3] + 9];
    if ( !v23 )
      _assert_fail(a4, (int)"locale_codeset != NULL", (int)"findlocale.c", 287, "_nl_find_locale");
    v40 = (unsigned int)l10nflist;
    v24 = alloca(strlen(v23) + 18);
    strip(v37, v23, (int)v23);
    v25 = alloca(strlen(v45) + 18);
    strip(v37, v45, (int)v37);
    v26 = v40;
    v27 = v37;
    do
    {
      v28 = dword_80C1B40[(char)*v27++];
      *(v27 - 1) = v28;
    }
    while ( (_BYTE)v28 );
    v29 = v37;
    do
    {
      v30 = dword_80C1B40[(char)*v29++];
      *(v29 - 1) = v30;
    }
    while ( (_BYTE)v30 );
    v40 = v26;
    if ( _gconv_compare_alias(v37, v37) )
      return 0;
    l10nflist = (_DWORD *)v40;
    v22 = *(_DWORD **)(v40 + 8);
  }
  if ( !*v22 )
  {
    v40 = (unsigned int)l10nflist;
    v35 = j_strrchr(*l10nflist, 47);
    v36 = (_BYTE *)(v35 - 1);
    if ( *(_BYTE *)(v35 - 2) != 47 )
    {
      do
        --v36;
      while ( *(v36 - 1) != 47 );
    }
    *v22 = strndup(a4, v36, v35 - (_DWORD)v36);
    l10nflist = (_DWORD *)v40;
  }
  if ( v43 )
  {
    v40 = (unsigned int)l10nflist;
    v31 = j_strcasecmp_l(v43, "TRANSLIT", nl_C_locobj) == 0;
    result = *(void ***)(v40 + 8);
    if ( v31 )
      result[7] = (void *)1;
  }
  else
  {
    result = (void **)l10nflist[2];
  }
  v32 = (unsigned int)result[6];
  if ( v32 <= 0xFFFFFFFD )
    result[6] = (void *)(v32 + 1);
  return result;
}
// 8079F3C: variable 'v33' is possibly undefined
// 8048200: using guessed type int __cdecl j_strrchr(_DWORD, _DWORD);
// 8048220: using guessed type int __cdecl j_memchr(_DWORD, _DWORD, _DWORD);
// 8048240: using guessed type int __cdecl j_strcasecmp_l(_DWORD, _DWORD, _DWORD);
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80C03A4: using guessed type unsigned __int8 slashdot_9272[4];
// 80C03E0: using guessed type int codeset_idx_9315[16];
// 80C0420: using guessed type void **nl_C[6];
// 80C1B40: using guessed type _DWORD dword_80C1B40[256];
// 80CC680: using guessed type void **nl_C_locobj[6];
// 80ECD00: using guessed type int nl_locale_file_list[13];
// 8079B50: using guessed type unsigned __int8 anonymous_0[4];

//----- (0807A100) --------------------------------------------------------
_DWORD *__usercall nl_remove_locale@<eax>(_DWORD *result@<eax>, int *a2@<edx>, long double a3@<st0>)
{
  _DWORD *i; // ecx

  if ( a2[6]-- == 1 )
  {
    if ( a2[3] != 2 )
    {
      for ( i = (_DWORD *)nl_locale_file_list[(_DWORD)result]; a2 != (int *)i[2]; i = (_DWORD *)i[3] )
        ;
      i[1] = 0;
      i[2] = 0;
    }
    return nl_unload_locale(a2, a3);
  }
  return result;
}
// 80ECD00: using guessed type int nl_locale_file_list[13];

//----- (0807A150) --------------------------------------------------------
_DWORD *__usercall nl_intern_locale_data@<eax>(
        int a1@<eax>,
        _DWORD *a2@<edx>,
        unsigned int a3@<ecx>,
        long double a4@<st0>)
{
  int v5; // ebx
  unsigned int v6; // ebp
  _DWORD *result; // eax
  unsigned int v10; // ecx
  unsigned int v11; // edx

  if ( a3 <= 7 )
    goto LABEL_10;
  v5 = 537202711;
  if ( a1 != 3 )
  {
    v5 = a1 ^ 0x20031115;
    if ( !a1 )
      v5 = 537462560;
  }
  if ( v5 == *a2 && (v6 = a2[1], v6 >= nl_category_num_items[a1]) && a3 > 4 * v6 + 8 )
  {
    result = (_DWORD *)malloc(a4, 4 * v6 + 36);
    if ( result )
    {
      result[1] = a2;
      result[2] = a3;
      result[5] = 0;
      result[4] = 0;
      result[6] = 0;
      result[7] = 0;
      result[8] = v6;
      if ( v6 )
      {
        v10 = a2[2];
        v11 = 0;
        if ( a3 >= v10 )
        {
          while ( 2 )
          {
            switch ( a1 )
            {
              case 1:
                if ( v11 > 5 )
                  break;
                goto LABEL_17;
              case 2:
                if ( v11 > 0x6E )
                  break;
                goto LABEL_17;
              case 3:
                if ( v11 > 0x12 )
                  break;
                goto LABEL_17;
              case 4:
                if ( v11 > 0x2D )
                  break;
                goto LABEL_17;
              case 5:
              case 10:
                if ( v11 > 4 )
                  break;
                goto LABEL_17;
              case 7:
                if ( v11 > 2 )
                  break;
                goto LABEL_17;
              case 8:
                if ( v11 > 6 )
                  break;
                goto LABEL_17;
              case 9:
                if ( v11 > 0xC )
                  break;
                goto LABEL_17;
              case 11:
                if ( v11 > 1 )
                  break;
                goto LABEL_17;
              case 12:
                if ( v11 > 0xF )
                  break;
                goto LABEL_17;
              default:
                if ( a1 )
                  _assert_fail(a4, (int)"category == LC_CTYPE", (int)"loadlocale.c", 141, "_nl_intern_locale_data");
                if ( v11 > 0x47 )
                  goto LABEL_18;
LABEL_17:
                if ( *((_DWORD *)*(&nl_value_types + a1) + v11) == 5 )
                {
                  if ( (v10 & 3) != 0 )
                    break;
                  result[v11 + 9] = *(_DWORD *)((char *)a2 + v10);
                }
                else
                {
LABEL_18:
                  result[v11 + 9] = (char *)a2 + v10;
                }
                if ( v6 == ++v11 )
                  return result;
                v10 = a2[v11 + 2];
                if ( a3 < v10 )
                  break;
                continue;
            }
            break;
          }
        }
        free(a4, (int)result);
        __writegsdword(0xFFFFFFE8, 0x16u);
        return 0;
      }
    }
  }
  else
  {
LABEL_10:
    __writegsdword(0xFFFFFFE8, 0x16u);
    return 0;
  }
  return result;
}
// 80C04C0: using guessed type void *nl_value_types;
// 80C09E0: using guessed type int nl_category_num_items[13];

//----- (0807A370) --------------------------------------------------------
_DWORD *__usercall nl_load_locale@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>)
{
  _DWORD *result; // eax
  int v5; // ebx
  int v6; // ecx
  unsigned int v7; // ecx
  _DWORD *v8; // edi
  unsigned int v9; // edx
  int v10; // eax
  int v11; // ebx
  void *v12; // esp
  _WORD *v13; // eax
  _WORD *v14; // eax
  int v15; // eax
  _BYTE *v16; // ecx
  __int64 v17; // rax
  _BYTE *v18; // ecx
  _BYTE *v19; // [esp+0h] [ebp-88h] BYREF
  char *v20; // [esp+4h] [ebp-84h]
  unsigned int v21; // [esp+8h] [ebp-80h]
  int v22; // [esp+Ch] [ebp-7Ch]
  char v23[16]; // [esp+10h] [ebp-78h] BYREF
  int v24; // [esp+20h] [ebp-68h]
  char *v25; // [esp+3Ch] [ebp-4Ch]

  *(_DWORD *)(a1 + 4) = 1;
  *(_DWORD *)(a1 + 8) = 0;
  v22 = a2;
  result = (_DWORD *)dl_sysinfo(0x80000);
  v5 = (int)result;
  if ( (unsigned int)result > 0xFFFFF000 )
  {
    result = (_DWORD *)_syscall_error((int)result);
    v5 = (int)result;
  }
  if ( v5 >= 0 )
  {
    if ( (_fxstat64(3, v5, (int)v23) & 0x80000000) != 0 )
      return (_DWORD *)dl_sysinfo(v6);
    if ( (v24 & 0xF000) != 0x4000 )
    {
LABEL_6:
      v21 = __readgsdword(0xFFFFFFE8);
      v8 = (_DWORD *)mmap(0, (int)v25, 1, 2, v5, 0);
      if ( v8 != (_DWORD *)-1 )
      {
        v21 = 1;
        goto LABEL_8;
      }
      if ( __readgsdword(0xFFFFFFE8) != 38 )
      {
        v21 = 1;
        v8 = 0;
LABEL_8:
        result = (_DWORD *)dl_sysinfo(v7);
        if ( v8 )
        {
          result = nl_intern_locale_data(v22, v8, (unsigned int)v25, a3);
          if ( result )
          {
            v9 = v21;
            *result = 0;
            result[3] = v9;
            *(_DWORD *)(a1 + 8) = result;
          }
          else if ( v21 == 1 )
          {
            return (_DWORD *)munmap((int)v8, (int)v25);
          }
        }
        return result;
      }
      v20 = v25;
      v15 = malloc(a3, (unsigned int)v25);
      v8 = (_DWORD *)v15;
      if ( !v15 )
      {
LABEL_31:
        v21 = 0;
        goto LABEL_8;
      }
      v16 = (_BYTE *)v15;
      if ( (int)v20 <= 0 )
      {
LABEL_30:
        v7 = v21;
        __writegsdword(0xFFFFFFE8, v21);
        goto LABEL_31;
      }
      while ( 1 )
      {
        v17 = dl_sysinfo(v16);
        if ( (unsigned int)v17 > 0xFFFFF000 )
        {
          v19 = v18;
          v20 = (char *)HIDWORD(v17);
          LODWORD(v17) = _syscall_error(v17);
          v18 = v19;
          HIDWORD(v17) = v20;
        }
        if ( (int)v17 <= 0 )
          break;
        v16 = &v18[v17];
        if ( HIDWORD(v17) - (int)v17 <= 0 )
          goto LABEL_30;
      }
      v22 = v17;
      free(a3, (int)v8);
      if ( !v22 )
        __writegsdword(0xFFFFFFE8, 0x16u);
      return (_DWORD *)dl_sysinfo(v6);
    }
    dl_sysinfo(v6);
    v19 = *(_BYTE **)a1;
    v10 = strlen(v19);
    v11 = (unsigned __int8)nl_category_name_sizes[v22];
    v12 = alloca(v10 + v11 + 21);
    v21 = (unsigned int)&v19;
    v20 = &nl_category_names[(unsigned __int8)nl_category_name_idxs[v22]];
    v13 = mempcpy(&v19, v19, v10);
    v14 = mempcpy(v13, "/SYS_", 5u);
    mempcpy(v14, v20, v11 + 1);
    result = (_DWORD *)dl_sysinfo(0x80000);
    v5 = (int)result;
    if ( (unsigned int)result > 0xFFFFF000 )
    {
      result = (_DWORD *)_syscall_error((int)result);
      v5 = (int)result;
    }
    if ( v5 >= 0 )
    {
      if ( (_fxstat64(3, v5, (int)v23) & 0x80000000) != 0 )
        return (_DWORD *)dl_sysinfo(v6);
      goto LABEL_6;
    }
  }
  return result;
}
// 807A419: variable 'v7' is possibly undefined
// 807A477: variable 'v6' is possibly undefined
// 807A5B2: variable 'v18' is possibly undefined
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0807A650) --------------------------------------------------------
_DWORD *__usercall nl_unload_locale@<eax>(int *a1@<eax>, long double a2@<st0>)
{
  void (*v3)(void); // edx
  int v4; // eax

  v3 = (void (*)(void))a1[4];
  if ( v3 )
    v3();
  v4 = a1[3];
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      munmap(a1[1], a1[2]);
      v4 = a1[3];
    }
  }
  else
  {
    free(a2, a1[1]);
    v4 = a1[3];
  }
  if ( v4 != 2 )
    free(a2, *a1);
  return free(a2, (int)a1);
}

//----- (0807A6D0) --------------------------------------------------------
int __cdecl rangecmp(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0807A6E0) --------------------------------------------------------
int __usercall nl_load_locale_from_archive@<eax>(int a1@<eax>, _DWORD *a2@<edx>, char *a3@<ecx>, long double a4@<st0>)
{
  _BYTE *v4; // esi
  int v5; // eax
  _DWORD *v6; // ebx
  _BYTE *v7; // edi
  int v9; // eax
  int v10; // eax
  unsigned int v11; // edi
  unsigned __int8 *v12; // edx
  unsigned __int8 *v13; // eax
  int v14; // ecx
  unsigned int v15; // eax
  int v16; // ebx
  unsigned int v17; // ecx
  unsigned int v18; // edx
  int v19; // eax
  unsigned int v20; // edi
  _BYTE *v21; // edx
  unsigned int v22; // esi
  signed int v23; // eax
  _DWORD *v24; // ebx
  unsigned int v25; // edi
  signed int i; // ecx
  int v27; // eax
  int v28; // eax
  int v29; // ebx
  _BYTE *v30; // ebx
  unsigned int v31; // esi
  int v32; // ecx
  int j; // edx
  unsigned int v34; // eax
  int v35; // edi
  int *v36; // esi
  unsigned int v37; // eax
  int v38; // ecx
  unsigned int v39; // ebx
  int v40; // edi
  unsigned int v41; // edx
  int k; // edi
  _BYTE *v43; // ebx
  unsigned int v44; // ecx
  int *v45; // edx
  unsigned int v46; // eax
  unsigned int v47; // eax
  _BYTE *v48; // ecx
  signed int v49; // eax
  unsigned __int8 *v50; // ebx
  unsigned int v51; // edi
  unsigned __int8 *v52; // eax
  int v53; // eax
  _BYTE *v54; // edx
  unsigned int v55; // ebx
  void *v56; // esp
  _WORD *v57; // eax
  _WORD *v58; // eax
  unsigned int v59; // eax
  unsigned int v60; // edi
  unsigned int v61; // eax
  int v62; // ebx
  int v63; // eax
  int v64; // edx
  int v65; // eax
  int v66; // ecx
  unsigned int *v67; // edi
  unsigned int v68; // eax
  unsigned int v69; // ebx
  int v70; // ecx
  int v71; // eax
  int v72; // edx
  int v73; // eax
  int v74; // edx
  int v75; // edx
  unsigned int v76; // eax
  unsigned int v77; // esi
  bool v78; // cc
  int *v79; // ebx
  _BYTE *v80; // eax
  int v81; // eax
  int v82; // edi
  int v83; // esi
  _DWORD *v84; // eax
  int v85; // edx
  unsigned int v86; // ebx
  int v87; // eax
  int v88; // edx
  _BYTE *v89; // eax
  _BYTE *v90; // [esp+0h] [ebp-1F4h]
  __int64 v91; // [esp+0h] [ebp-1F4h]
  _BYTE *v92; // [esp+4h] [ebp-1F0h]
  _BYTE v93[8]; // [esp+Ch] [ebp-1E8h] BYREF
  int v94; // [esp+14h] [ebp-1E0h]
  unsigned int v95; // [esp+18h] [ebp-1DCh]
  int *v96; // [esp+1Ch] [ebp-1D8h]
  int v97; // [esp+20h] [ebp-1D4h]
  int v98; // [esp+24h] [ebp-1D0h]
  int v99; // [esp+28h] [ebp-1CCh]
  int v100; // [esp+2Ch] [ebp-1C8h]
  _BYTE **v101; // [esp+30h] [ebp-1C4h]
  int v102; // [esp+34h] [ebp-1C0h]
  int v103; // [esp+38h] [ebp-1BCh]
  _BYTE *v104; // [esp+3Ch] [ebp-1B8h]
  signed int v105; // [esp+40h] [ebp-1B4h]
  int v106; // [esp+44h] [ebp-1B0h]
  int v107; // [esp+48h] [ebp-1ACh]
  __int64 v108[9]; // [esp+54h] [ebp-1A0h] BYREF
  int v109; // [esp+9Ch] [ebp-158h]
  __int64 v110; // [esp+ACh] [ebp-148h]
  int v111[26]; // [esp+B4h] [ebp-140h]
  int v112[54]; // [esp+11Ch] [ebp-D8h] BYREF

  v4 = (_BYTE *)*a2;
  v100 = a1;
  v101 = (_BYTE **)a2;
  v5 = sysconf(a3, a4, 30);
  v6 = (_DWORD *)archloaded;
  v102 = v5;
  if ( archloaded )
  {
    while ( 1 )
    {
      v7 = (_BYTE *)v6[1];
      if ( v4 == v7 || !j_strcmp(v4, v6[1]) )
        break;
      v6 = (_DWORD *)*v6;
      if ( !v6 )
        goto LABEL_7;
    }
    *v101 = v7;
    return v6[v100 + 2];
  }
LABEL_7:
  v9 = j_strchr(v4, 46);
  if ( v9 && (*(_BYTE *)(v9 + 1) & 0xBF) != 0 )
  {
    v50 = (unsigned __int8 *)(v9 + 1);
    v107 = (int)strchrnul((unsigned int *)(v9 + 1), 64);
    v51 = v107 - (_DWORD)v50;
    v52 = nl_normalize_codeset(v50, v107 - (_DWORD)v50);
    if ( !v52 )
      return 0;
    v106 = (int)v52;
    v53 = strncmp(v52, v50, v51);
    v54 = (_BYTE *)v106;
    if ( v53 || *(_BYTE *)(v106 + v51) )
    {
      v104 = (_BYTE *)v106;
      v55 = v50 - v4;
      v106 = strlen((_BYTE *)v106);
      v105 = strlen((_BYTE *)v107) + 1;
      v56 = alloca(v105 + v55 + v106 + 15);
      v90 = v4;
      v4 = v93;
      v57 = mempcpy(v93, v90, v55);
      v92 = (_BYTE *)v106;
      v106 = (int)v104;
      v58 = mempcpy(v57, v104, (unsigned int)v92);
      memcpy(v58, (_BYTE *)v107, v105);
      v54 = (_BYTE *)v106;
    }
    free(a4, (int)v54);
  }
  if ( archmapped )
  {
    v104 = (_BYTE *)headmap;
    if ( headmap )
    {
LABEL_11:
      v99 = -1;
      goto LABEL_12;
    }
    return 0;
  }
  archmapped = (int)&headmap;
  v59 = dl_sysinfo(557056);
  v99 = v59;
  if ( v59 > 0xFFFFF000 )
    v99 = _syscall_error(v59);
  if ( v99 < 0 )
    return 0;
  if ( _fxstat64(3, v99, (int)&archive_stat) == -1 )
    goto LABEL_46;
  v60 = qword_80EC64C;
  if ( qword_80EC64C > 0x200000 )
    v60 = 0x200000;
  v107 = v60;
  v61 = mmap64(0, v60, 1, 2, v99, 0LL);
  v104 = (_BYTE *)v61;
  v48 = (_BYTE *)v61;
  if ( v61 == -1 )
    goto LABEL_46;
  v62 = *(_DWORD *)(v61 + 32) + 108 * *(_DWORD *)(v61 + 36);
  v63 = *(_DWORD *)(v61 + 8) + 12 * *(_DWORD *)(v61 + 16);
  v64 = (int)v48;
  if ( v63 >= v62 )
    v62 = v63;
  v65 = *((_DWORD *)v48 + 5) + *((_DWORD *)v48 + 6);
  v48 = (_BYTE *)v107;
  if ( v62 < v65 )
    v62 = v65;
  if ( v60 < v62 )
  {
    munmap(v64, v60);
    if ( (unsigned int)v62 <= qword_80EC64C )
    {
      v107 = (v102 + v62 - 1) & -v102;
      v104 = (_BYTE *)mmap64(0, v107, 1, 2, v99, 0LL);
      if ( v104 != (_BYTE *)-1 )
      {
        v48 = (_BYTE *)v107;
        if ( (unsigned int)v107 >= qword_80EC64C )
          goto LABEL_67;
        dword_80EC688 = v107;
        headmap = (int)v104;
        if ( v104 )
        {
LABEL_12:
          v10 = strlen(v4);
          v11 = v10;
          if ( v10 )
          {
            v12 = &v4[v10];
            v13 = v4;
            do
            {
              v14 = *v13++;
              v11 = v14 + __ROL4__(v11, 9);
            }
            while ( v12 != v13 );
            if ( !v11 )
              v11 = -1;
          }
          else
          {
            v11 = -1;
          }
          v15 = *((_DWORD *)v104 + 4);
          v98 = *((_DWORD *)v104 + 2);
          if ( v15 )
          {
            v106 = v15;
            v103 = (int)v4;
            v16 = v11 % v15;
            v17 = v11;
            v18 = v11 % (v15 - 2) + 1;
            v19 = 3 * v18;
            v20 = v18;
            v21 = (_BYTE *)v106;
            v107 = 4 * v19;
LABEL_19:
            v22 = v16 + v20;
            v23 = v20;
            v24 = &v104[12 * v16 + v98];
            v25 = v17;
            for ( i = v23; ; v22 += i )
            {
              v27 = v24[1];
              if ( !v27 )
                break;
              if ( *v24 == v25 )
              {
                v105 = i;
                v106 = (int)v21;
                v28 = j_strcmp(v103, &v104[v27]);
                v21 = (_BYTE *)v106;
                i = v105;
                if ( !v28 )
                {
                  v29 = v24[2];
                  v103 = 0;
                  if ( !v29 )
                    break;
                  v30 = &v104[v29];
                  v31 = 0;
                  v32 = 1;
                  for ( j = 0; ; ++j )
                  {
                    if ( j != 6 )
                    {
                      v34 = v31++;
                      v34 *= 16;
                      *(int *)((char *)v112 + v34) = *(_DWORD *)&v30[8 * j + 4];
                      v35 = *(_DWORD *)&v30[8 * v32];
                      *(int *)((char *)&v112[2] + v34) = j;
                      *(int *)((char *)&v112[3] + v34) = 0;
                      *(int *)((char *)&v112[1] + v34) = v35;
                      if ( v32 == 13 )
                        break;
                    }
                    ++v32;
                  }
                  v105 = v31;
                  qsort(a4, (char *)v112, v31, 0x10u, (int (__cdecl *)(char *, char *, int))rangecmp);
                  v97 = archmapped;
                  v106 = archmapped;
                  v104 = (_BYTE *)(v102 - 1);
                  v94 = (v102 - 1) & v102;
                  do
                  {
                    v36 = (int *)v97;
                    if ( !v97 )
                    {
                      v36 = 0;
                      v98 = v106;
LABEL_38:
                      if ( v94 )
                        _assert_fail(
                          a4,
                          (int)"powerof2 (ps)",
                          (int)"loadarchive.c",
                          377,
                          "_nl_load_locale_from_archive");
                      v107 = qword_80EC64C;
                      v43 = (_BYTE *)v103;
                      v44 = v112[4 * v103];
                      v97 = v44;
                      v106 = -v102;
                      v45 = &v112[4 * v103];
                      v96 = v45;
                      while ( 1 )
                      {
                        v47 = v44 + v45[1];
                        if ( v107 < v47 )
                          goto LABEL_45;
                        v46 = v106 & (unsigned int)&v104[v47];
                        if ( (!v36 || v44 < v36[1]) && v105 > (int)++v43 )
                        {
                          v44 = v45[4];
                          v45 += 4;
                          if ( v44 < v46 + v102 )
                            continue;
                        }
                        v107 = (int)v43;
                        v95 = v46;
                        v67 = (unsigned int *)v96;
                        if ( v99 == -1 )
                        {
                          v68 = dl_sysinfo(557056);
                          v99 = v68;
                          if ( v68 > 0xFFFFF000 )
                            v99 = _syscall_error(v68);
                          if ( v99 == -1 )
                            return 0;
                          if ( (_fxstat64(3, v99, (int)v108) & 0x80000000) != 0
                            || qword_80EC64C != *(__int64 *)((char *)&v108[5] + 4)
                            || v109 != dword_80EC668
                            || archive_stat != v108[0]
                            || qword_80EC678 != v110 )
                          {
                            goto LABEL_45;
                          }
                        }
                        v69 = v106 & v97;
                        v91 = v106 & (unsigned int)v97;
                        v97 = v95 - (v106 & v97);
                        v96 = (int *)mmap64(0, v97, 1, 2, v99, v91);
                        if ( v96 == (int *)-1 )
                          goto LABEL_45;
                        v106 = malloc(a4, 0x10u);
                        v70 = (int)v96;
                        if ( !v106 )
                        {
                          munmap((int)v96, v97);
                          goto LABEL_45;
                        }
                        v71 = v106;
                        v72 = v97;
                        *(_DWORD *)v106 = v96;
                        *(_DWORD *)(v71 + 4) = v69;
                        *(_DWORD *)(v71 + 8) = v72;
                        v97 = *(_DWORD *)(v98 + 12);
                        if ( (int *)v97 != v36 )
                          _assert_fail(
                            a4,
                            (int)"last->next == mapped",
                            (int)"loadarchive.c",
                            435,
                            "_nl_load_locale_from_archive");
                        v73 = v106;
                        v74 = v98;
                        *(_DWORD *)(v106 + 12) = v36;
                        *(_DWORD *)(v74 + 12) = v73;
                        v75 = v103;
                        do
                        {
                          v76 = *v67;
                          if ( v69 > *v67 )
                            _assert_fail(
                              a4,
                              (int)"ranges[cnt].from >= from",
                              (int)"loadarchive.c",
                              443,
                              "_nl_load_locale_from_archive");
                          v77 = v67[2];
                          ++v75;
                          v67 += 4;
                          v111[2 * v77] = v70 + v76 - v69;
                          v78 = v107 <= v75;
                          v111[2 * v77 + 1] = *(v67 - 3);
                        }
                        while ( !v78 );
                        v103 = v75;
                        goto LABEL_85;
                      }
                    }
                    v37 = *(_DWORD *)(v97 + 4);
                    v38 = *(_DWORD *)(v97 + 8);
                    v98 = v97;
                    v39 = v112[4 * v103];
                    v40 = v112[4 * v103 + 1];
                    v41 = v40 + v39;
                    if ( v40 + v39 < v37 + v38 )
                    {
                      v98 = v106;
                    }
                    else
                    {
                      v107 = v112[4 * v103 + 1];
                      for ( k = v98; ; k = *(_DWORD *)(k + 12) )
                      {
                        v36 = *(int **)(k + 12);
                        if ( !v36 )
                        {
                          v98 = k;
                          goto LABEL_38;
                        }
                        v37 = v36[1];
                        if ( v37 + v36[2] > v41 )
                          break;
                      }
                      v98 = k;
                      v40 = v107;
                    }
                    if ( v37 > v39 )
                      goto LABEL_38;
                    v70 = v103;
                    v86 = v39 - v37;
                    v87 = *v36;
                    v97 = (int)v36;
                    v88 = v112[4 * v103 + 2];
                    v111[2 * v88] = v86 + v87;
                    v89 = (_BYTE *)v98;
                    v111[2 * v88 + 1] = v40;
                    v103 = v70 + 1;
                    v106 = (int)v89;
LABEL_85:
                    ;
                  }
                  while ( v103 < v105 );
                  if ( v99 >= 0 )
                    dl_sysinfo(v70);
                  v79 = (int *)malloc(a4, 0x3Cu);
                  if ( !v79 )
                    return 0;
                  v80 = strdup(*v101);
                  v79[1] = (int)v80;
                  if ( !v80 )
                  {
                    free(a4, (int)v79);
                    return 0;
                  }
                  v81 = archloaded;
                  v82 = 1;
                  archloaded = (int)v79;
                  v83 = 0;
                  *v79 = v81;
                  while ( 1 )
                  {
                    if ( v83 != 6 )
                    {
                      v84 = nl_intern_locale_data(v83, (_DWORD *)v111[2 * v83], v111[2 * v83 + 1], a4);
                      v79[v83 + 2] = (int)v84;
                      if ( v84 )
                      {
                        v85 = v79[1];
                        v84[3] = 2;
                        v84[6] = -1;
                        *v84 = v85;
                      }
                      if ( v82 == 13 )
                        break;
                    }
                    ++v83;
                    ++v82;
                  }
                  *v101 = (_BYTE *)v79[1];
                  return v79[v100 + 2];
                }
              }
              v24 = (_DWORD *)((char *)v24 + v107);
              if ( (unsigned int)v21 <= v22 )
              {
                v49 = i;
                v17 = v25;
                v16 = v22 - (_DWORD)v21;
                v20 = v49;
                goto LABEL_19;
              }
            }
          }
LABEL_45:
          v48 = (_BYTE *)v99;
          if ( v99 >= 0 )
            goto LABEL_46;
          return 0;
        }
      }
    }
LABEL_46:
    dl_sysinfo(v48);
    return 0;
  }
  if ( v60 < qword_80EC64C )
  {
    dword_80EC688 = v60;
    headmap = (int)v104;
    goto LABEL_12;
  }
LABEL_67:
  dl_sysinfo(v48);
  dword_80EC688 = v66;
  headmap = (int)v104;
  if ( v104 )
    goto LABEL_11;
  return 0;
}
// 807AA7D: variable 'v48' is possibly undefined
// 807ACAD: variable 'v66' is possibly undefined
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EC600: using guessed type int archloaded;
// 80EC620: using guessed type __int64 archive_stat;
// 80EC64C: using guessed type __int64 qword_80EC64C;
// 80EC668: using guessed type int dword_80EC668;
// 80EC678: using guessed type __int64 qword_80EC678;
// 80EC680: using guessed type int headmap;
// 80EC688: using guessed type int dword_80EC688;
// 80EC690: using guessed type int archmapped;

//----- (0807B170) --------------------------------------------------------
char *nl_postload_ctype()
{
  char (*v0)[512]; // ecx
  char *result; // eax
  int (*v2)[256]; // edx
  bool v3; // zf

  v0 = (char (*)[512])((char *)nl_global_locale[0][9] + 256);
  off_80EBED4 = v0;
  result = (char *)nl_global_locale[0][12] + 512;
  off_80EBED8 = (int)result;
  v2 = (int (*)[256])((char *)nl_global_locale[0][10] + 512);
  v3 = __readgsdword(0xFFFFFFDC) == (_DWORD)nl_global_locale;
  off_80EBEDC = v2;
  if ( v3 )
  {
    __writegsdword(0xFFFFFFF8, (unsigned int)v0);
    __writegsdword(0xFFFFFFF4, (unsigned int)v2);
    __writegsdword(0xFFFFFFF0, (unsigned int)result);
  }
  return result;
}
// 80EBEA0: using guessed type void **nl_global_locale[6];
// 80EBED4: using guessed type char (*off_80EBED4)[512];
// 80EBED8: using guessed type int off_80EBED8;
// 80EBEDC: using guessed type int (*off_80EBEDC)[256];

//----- (0807B1E0) --------------------------------------------------------
int __cdecl _current_locale_name(int a1)
{
  return *(_DWORD *)(__readgsdword(0xFFFFFFDC) + 4 * a1 + 64);
}

//----- (0807B200) --------------------------------------------------------
unsigned int _ctype_b_loc()
{
  return __readgsdword(0) - 8;
}

//----- (0807B210) --------------------------------------------------------
unsigned int _ctype_toupper_loc()
{
  return __readgsdword(0) - 12;
}

//----- (0807B220) --------------------------------------------------------
unsigned int _ctype_tolower_loc()
{
  return __readgsdword(0) - 16;
}

//----- (0807B230) --------------------------------------------------------
unsigned int _ctype_init()
{
  _DWORD *v0; // eax
  int v1; // edx
  int v2; // eax
  unsigned int result; // eax

  v0 = *(_DWORD **)__readgsdword(0xFFFFFFD8);
  __writegsdword(0xFFFFFFF8, v0[9] + 256);
  v1 = v0[10];
  v2 = v0[12];
  __writegsdword(0xFFFFFFF4, v1 + 512);
  result = v2 + 512;
  __writegsdword(0xFFFFFFF0, result);
  return result;
}

//----- (0807B270) --------------------------------------------------------
unsigned int __cdecl _setfpucw(unsigned int a1)
{
  unsigned int result; // eax

  result = a1;
  if ( (dl_hwcap & 0x2000000) != 0 )
  {
    result = _mm_getcsr() & 0xFFFF817F | (8 * (_WORD)a1) & 0x6000 | ((_WORD)a1 << 7) & 0x1E80;
    _mm_setcsr(result);
  }
  return result;
}
// 80EC550: using guessed type __int64 dl_hwcap;

//----- (0807B2F0) --------------------------------------------------------
int raise()
{
  int v0; // ecx
  int v1; // ecx
  int v2; // eax
  unsigned int v3; // eax
  int v4; // edi
  int v6; // [esp+0h] [ebp-11Ch] BYREF
  int v7[39]; // [esp+80h] [ebp-9Ch] BYREF

  qmemcpy(v7, &unk_80CC700, 0x80u);
  v7[0] = 0x7FFFFFFF;
  v7[1] = -2;
  dl_sysinfo(v7);
  dl_sysinfo(v0);
  v2 = dl_sysinfo(v1);
  v3 = dl_sysinfo(v2);
  v4 = v3;
  if ( v3 > 0xFFFFF000 )
    v4 = _syscall_error(v3);
  dl_sysinfo(&v6);
  return v4;
}
// 807B347: variable 'v0' is possibly undefined
// 807B354: variable 'v1' is possibly undefined
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0807B3C0) --------------------------------------------------------
int __cdecl _libc_sigaction(int a1, int *a2, _DWORD *a3)
{
  int *v3; // ecx
  int v4; // eax
  int result; // eax
  int v6; // edx
  bool v7; // zf
  int (*v8)(); // eax
  int v9; // [esp+8h] [ebp-134h] BYREF
  int v10; // [esp+Ch] [ebp-130h]
  int (*v11)(); // [esp+10h] [ebp-12Ch]
  char v12[128]; // [esp+14h] [ebp-128h] BYREF
  int v13; // [esp+94h] [ebp-A8h]
  int v14; // [esp+98h] [ebp-A4h]
  int v15; // [esp+9Ch] [ebp-A0h]
  int v16[39]; // [esp+A0h] [ebp-9Ch] BYREF

  v3 = 0;
  if ( a2 )
  {
    v9 = *a2;
    v4 = a2[33];
    qmemcpy(v12, a2 + 1, sizeof(v12));
    v10 = v4;
    if ( !dl_sysinfo_dso )
    {
      v6 = v4 | 0x4000000;
      v7 = (v4 & 4) == 0;
      v8 = _restore_rt;
      v10 = v6;
      if ( v7 )
        v8 = (int (*)())&_restore;
      v11 = v8;
    }
    v3 = &v9;
  }
  result = dl_sysinfo(v3);
  if ( (unsigned int)result > 0xFFFFF000 )
    return _syscall_error(result);
  if ( a3 )
  {
    if ( result >= 0 )
    {
      *a3 = v13;
      a3[1] = v16[0];
      a3[32] = v16[31];
      qmemcpy(
        (void *)((unsigned int)(a3 + 2) & 0xFFFFFFFC),
        (const void *)((char *)v16 - ((char *)a3 - ((unsigned int)(a3 + 2) & 0xFFFFFFFC) + 4)),
        4 * (((unsigned int)a3 - ((unsigned int)(a3 + 2) & 0xFFFFFFFC) + 132) >> 2));
      a3[33] = v14;
      a3[34] = v15;
    }
  }
  return result;
}
// 807B3B0: using guessed type int _restore_rt();
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80ECCA4: using guessed type int dl_sysinfo_dso;

//----- (0807B4F0) --------------------------------------------------------
int __cdecl sigaction(int a1, int *a2, _DWORD *a3)
{
  if ( (unsigned int)(a1 - 32) > 1 )
    return _libc_sigaction(a1, a2, a3);
  __writegsdword(0xFFFFFFE8, 0x16u);
  return -1;
}

//----- (0807B520) --------------------------------------------------------
unsigned int __cdecl sigprocmask(int a1, _BYTE *a2)
{
  int v2; // edx
  int *v3; // ecx
  unsigned int result; // eax
  int v5[35]; // [esp+0h] [ebp-8Ch] BYREF

  if ( a2 )
  {
    v2 = *(_DWORD *)a2;
    if ( *(int *)a2 < 0 || (a2[4] & 1) != 0 )
    {
      qmemcpy(v5, a2, 0x80u);
      v3 = v5;
      v5[0] = v2 & 0x7FFFFFFF;
      v5[1] &= ~1u;
    }
    else
    {
      v3 = (int *)a2;
    }
  }
  else
  {
    v3 = 0;
  }
  result = dl_sysinfo(v3);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0807B5B0) --------------------------------------------------------
unsigned int __cdecl quicksort(
        char *a1,
        unsigned int a2,
        unsigned int a3,
        int (__cdecl *a4)(char *, char *, int),
        int a5)
{
  unsigned int result; // eax
  char *v6; // esi
  char *v7; // ebx
  char *v8; // eax
  char *v9; // edx
  char v10; // cl
  char v11; // bl
  int v12; // eax
  unsigned int v13; // esi
  char *v14; // esi
  unsigned int v15; // eax
  char *v16; // ebx
  char *v17; // esi
  char *v18; // eax
  char *v19; // ecx
  char v20; // dl
  char v21; // bl
  int i; // eax
  unsigned int v23; // ebx
  char *v24; // ebp
  char *v25; // eax
  char *v26; // edx
  char *v27; // edx
  char *v28; // eax
  char *v29; // edx
  char *v30; // eax
  char v31; // cl
  char v32; // bl
  char *v33; // edx
  char *v34; // eax
  char v35; // cl
  char v36; // bl
  char *v37; // edx
  char *v38; // eax
  char v39; // cl
  char v40; // bl
  char *v41; // esi
  unsigned int v42; // [esp+8h] [ebp-144h]
  char *v43; // [esp+8h] [ebp-144h]
  char v44; // [esp+Ch] [ebp-140h]
  char *v45; // [esp+Ch] [ebp-140h]
  char *v46; // [esp+10h] [ebp-13Ch]
  char *v47; // [esp+14h] [ebp-138h]
  char *v48; // [esp+18h] [ebp-134h]
  unsigned int v49; // [esp+18h] [ebp-134h]
  char *v50; // [esp+1Ch] [ebp-130h]
  unsigned int v51; // [esp+1Ch] [ebp-130h]
  char *v52; // [esp+20h] [ebp-12Ch]
  char *v53; // [esp+24h] [ebp-128h]
  unsigned int v54; // [esp+28h] [ebp-124h]
  int v55[2]; // [esp+30h] [ebp-11Ch] BYREF
  char v56; // [esp+38h] [ebp-114h] BYREF

  result = a2;
  if ( a2 )
  {
    v54 = 4 * a3;
    if ( a2 > 4 )
    {
      v55[0] = 0;
      v55[1] = 0;
      v50 = &a1[a3 * (a2 - 1)];
      v52 = a1;
      v53 = &v56;
      while ( 1 )
      {
        v6 = &v52[a3 * (((v50 - v52) / a3) >> 1)];
        if ( a4(v6, v52, a5) < 0 )
        {
          v37 = v52;
          v38 = &v52[a3 * (((v50 - v52) / a3) >> 1)];
          do
          {
            v39 = *v38;
            v40 = *v37;
            ++v38;
            ++v37;
            *(v38 - 1) = v40;
            *(v37 - 1) = v39;
          }
          while ( v38 != &v6[a3] );
        }
        if ( a4(v50, v6, a5) < 0 )
        {
          v29 = v50;
          v30 = &v52[a3 * (((v50 - v52) / a3) >> 1)];
          v45 = &v6[a3];
          do
          {
            v31 = *v30;
            v32 = *v29;
            ++v30;
            ++v29;
            *(v30 - 1) = v32;
            *(v29 - 1) = v31;
          }
          while ( v30 != v45 );
          if ( a4(v6, v52, a5) < 0 )
          {
            v33 = v52;
            v34 = &v52[a3 * (((v50 - v52) / a3) >> 1)];
            do
            {
              v35 = *v34;
              v36 = *v33;
              ++v34;
              ++v33;
              *(v34 - 1) = v36;
              *(v33 - 1) = v35;
            }
            while ( v34 != v45 );
          }
        }
        v7 = &v50[-a3];
        v46 = &v52[a3];
        while ( 1 )
        {
          while ( a4(v46, v6, a5) < 0 )
            v46 += a3;
          while ( a4(v6, v7, a5) < 0 )
            v7 -= a3;
          v8 = v46;
          if ( v46 < v7 )
          {
            v48 = v7;
            v9 = v7;
            do
            {
              v10 = *v8;
              v11 = *v9;
              ++v8;
              ++v9;
              *(v8 - 1) = v11;
              *(v9 - 1) = v10;
            }
            while ( v8 != &v46[a3] );
            if ( v46 == v6 )
            {
              v6 = v48;
            }
            else if ( v48 == v6 )
            {
              v6 = v46;
            }
            v7 = &v48[-a3];
            v46 += a3;
            goto LABEL_18;
          }
          if ( v46 == v7 )
            break;
LABEL_18:
          if ( v46 > v7 )
          {
            v12 = v7 - v52;
            v13 = 4 * a3;
            if ( v54 < v7 - v52 )
              goto LABEL_52;
            goto LABEL_20;
          }
        }
        v7 -= a3;
        v46 += a3;
        v13 = 4 * a3;
        v12 = v7 - v52;
        if ( v54 < v7 - v52 )
        {
LABEL_52:
          if ( v54 >= v50 - v46 )
          {
            v50 = v7;
          }
          else
          {
            if ( v12 <= v50 - v46 )
            {
              v28 = v53 + 8;
              *(_DWORD *)v53 = v46;
              v41 = v50;
              v50 = v7;
              *((_DWORD *)v53 + 1) = v41;
            }
            else
            {
              v27 = v52;
              *((_DWORD *)v53 + 1) = v7;
              v28 = v53 + 8;
              v52 = v46;
              *(_DWORD *)v53 = v27;
            }
            v53 = v28;
          }
          goto LABEL_22;
        }
LABEL_20:
        v52 = v46;
        if ( v13 >= v50 - v46 )
        {
          v52 = (char *)*((_DWORD *)v53 - 2);
          v14 = (char *)*((_DWORD *)v53 - 1);
          v53 -= 8;
          v50 = v14;
        }
LABEL_22:
        if ( v53 <= (char *)v55 )
        {
          v49 = (unsigned int)&a1[a3 * (a2 - 1)];
          goto LABEL_26;
        }
      }
    }
    v49 = (unsigned int)&a1[a3 * (a2 - 1)];
LABEL_26:
    v15 = (unsigned int)&a1[v54];
    if ( v49 < (unsigned int)&a1[v54] )
      v15 = v49;
    v16 = &a1[a3];
    v17 = a1;
    v42 = v15;
    if ( v15 >= (unsigned int)&a1[a3] )
    {
      do
      {
        if ( a4(v16, v17, a5) < 0 )
          v17 = v16;
        v16 += a3;
      }
      while ( v42 >= (unsigned int)v16 );
      v16 = &a1[a3];
      if ( v17 != a1 )
      {
        v18 = a1;
        v19 = &v17[a3];
        do
        {
          v20 = *v17;
          v21 = *v18;
          ++v17;
          ++v18;
          *(v17 - 1) = v21;
          *(v18 - 1) = v20;
        }
        while ( v17 != v19 );
        v16 = &a1[a3];
      }
    }
    v51 = a3 - 1;
    while ( 1 )
    {
      result = (unsigned int)&v16[a3];
      v47 = &v16[a3];
      if ( (unsigned int)&v16[a3] > v49 )
        break;
      for ( i = a4(v47, v16, a5); i < 0; i = a4(v47, v16, a5) )
        v16 -= a3;
      v23 = (unsigned int)&v16[a3];
      if ( v47 != (char *)v23 )
      {
        v24 = &v47[v51];
        if ( !__CFADD__(v51, v47) )
        {
          v43 = v47 - 1;
          do
          {
            v44 = *v24;
            v25 = v43;
            if ( v23 > (unsigned int)v43 )
            {
              v25 = v24;
            }
            else
            {
              v26 = v24;
              while ( 1 )
              {
                *v26 = *v25;
                v26 -= a3;
                if ( v23 > (unsigned int)&v25[-a3] )
                  break;
                v25 -= a3;
              }
            }
            --v24;
            --v43;
            *v25 = v44;
          }
          while ( v24 != v47 - 1 );
        }
      }
      v16 = v47;
    }
  }
  return result;
}
// 807B5B0: too many cbuild loops

//----- (0807BAA0) --------------------------------------------------------
int __usercall _add_to_environ@<eax>(long double a1@<st0>, unsigned __int8 *a2, _BYTE *a3, int a4, int a5)
{
  bool v6; // zf
  unsigned __int8 *v7; // esi
  unsigned __int8 **v8; // edi
  unsigned int v9; // ebx
  unsigned int v10; // edx
  unsigned int v11; // eax
  int v12; // ebx
  _BYTE *v13; // esi
  unsigned int v14; // edx
  int *v15; // ebx
  int v16; // eax
  int v18; // esi
  unsigned int v19; // eax
  unsigned int v20; // edi
  unsigned int v21; // edx
  void *v22; // esp
  _WORD *v23; // eax
  _WORD *v24; // eax
  int *v25; // eax
  _BYTE *v26; // eax
  int v27; // esi
  _BOOL4 v28; // eax
  _BYTE *v29; // eax
  _WORD *v30; // eax
  _WORD *v31; // eax
  int *v32; // eax
  int v33; // edi
  char v34[4]; // [esp+Ch] [ebp-28h] BYREF
  unsigned int v35; // [esp+10h] [ebp-24h]
  unsigned int v36; // [esp+14h] [ebp-20h]
  int v37; // [esp+18h] [ebp-1Ch]

  v37 = strlen(a2);
  if ( !a4 )
    v35 = strlen(a3) + 1;
  _ECX = 1;
  v6 = __readgsdword(0xCu) == 0;
  if ( !v6 )
    __asm { lock }
  __asm { cmpxchg ds:envlock, ecx }
  if ( !v6 )
    _lll_lock_wait_private(0, &envlock);
  if ( environ && (v7 = *(unsigned __int8 **)environ) != 0 )
  {
    v8 = (unsigned __int8 **)environ;
    v9 = 0;
    while ( strncmp(v7, a2, v37) || v7[v37] != 61 )
    {
      v7 = *++v8;
      if ( !*v8 )
      {
        v10 = v9 + 1;
        v11 = 4 * v9 + 12;
        goto LABEL_15;
      }
      ++v9;
    }
    v19 = v9;
    v15 = (int *)v8;
    v20 = v19;
    v16 = *v15;
    if ( *v15 )
      goto LABEL_19;
    v11 = 4 * v20 + 8;
    v10 = v20;
  }
  else
  {
    v11 = 8;
    v10 = 0;
  }
LABEL_15:
  v12 = last_environ;
  v36 = v10;
  v13 = (_BYTE *)realloc((_BYTE *)last_environ, v11);
  v14 = v36;
  if ( !v13 )
    goto LABEL_37;
  if ( v12 != environ )
  {
    memcpy(v13, (_BYTE *)environ, 4 * v36);
    v14 = v36;
  }
  v15 = (int *)&v13[4 * v36];
  last_environ = (int)v13;
  *v15 = 0;
  *(_DWORD *)&v13[4 * v14 + 4] = 0;
  v16 = *v15;
  environ = (int)v13;
LABEL_19:
  if ( v16 && !a5 )
    goto LABEL_21;
  v18 = a4;
  if ( a4 )
    goto LABEL_27;
  v21 = v35 + v37 + 1;
  if ( v21 <= 0x1000 || (v36 = v35 + v37 + 1, v28 = _libc_alloca_cutoff(v36), v21 = v36, v28) )
  {
    v36 = v21;
    v22 = alloca(v21 + 15);
    v23 = mempcpy(v34, a2, v37);
    v24 = mempcpy(v23, "=", 1u);
    mempcpy(v24, a3, v35);
    v25 = tfind((int)v34, &known_values, j_strcmp);
    if ( v25 )
    {
      v18 = *v25;
      if ( *v25 )
      {
LABEL_27:
        *v15 = v18;
LABEL_21:
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --envlock )
          _lll_unlock_wake_private(&envlock);
        return 0;
      }
    }
    v37 = v36;
    v26 = (_BYTE *)malloc(a1, v36);
    v27 = (int)v26;
    if ( v26 )
    {
      memcpy(v26, v34, v37);
LABEL_35:
      tsearch(v27, &known_values, j_strcmp);
      *v15 = v27;
      goto LABEL_21;
    }
  }
  else
  {
    v29 = (_BYTE *)malloc(a1, v36);
    v27 = (int)v29;
    if ( v29 )
    {
      v30 = mempcpy(v29, a2, v37);
      v31 = mempcpy(v30, "=", 1u);
      mempcpy(v31, a3, v35);
      v32 = tfind(v27, &known_values, j_strcmp);
      if ( v32 )
      {
        v33 = *v32;
        if ( *v32 )
        {
          free(a1, v27);
          *v15 = v33;
          goto LABEL_21;
        }
      }
      goto LABEL_35;
    }
  }
LABEL_37:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --envlock )
    _lll_unlock_wake_private(&envlock);
  return -1;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80EC524: using guessed type int environ;
// 80EC694: using guessed type int last_environ;
// 80EC698: using guessed type int known_values;
// 80EC69C: using guessed type int envlock;
// 807BAA0: using guessed type char anonymous_0[4];

//----- (0807BDD0) --------------------------------------------------------
int __usercall setenv@<eax>(long double a1@<st0>, unsigned __int8 *a2, _BYTE *a3, int a4)
{
  if ( a2 && *a2 && !j_strchr(a2, 61) )
    return _add_to_environ(a1, a2, a3, 0, a4);
  __writegsdword(0xFFFFFFE8, 0x16u);
  return -1;
}
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);

//----- (0807BE30) --------------------------------------------------------
int __cdecl unsetenv(unsigned __int8 *a1)
{
  int v1; // esi
  bool v3; // zf
  unsigned __int8 **v4; // ebp
  unsigned __int8 *v5; // edi
  unsigned __int8 **v7; // eax
  unsigned __int8 *v8; // edx

  if ( a1 && *a1 && !j_strchr(a1, 61) )
  {
    v1 = strlen(a1);
    _ECX = 1;
    v3 = __readgsdword(0xCu) == 0;
    if ( !v3 )
      __asm { lock }
    __asm { cmpxchg ds:envlock, ecx }
    if ( !v3 )
      _lll_lock_wait_private(0, &envlock);
    v4 = (unsigned __int8 **)environ;
    if ( environ )
    {
      while ( 1 )
      {
        v5 = *v4;
        if ( !*v4 )
          break;
        while ( strncmp(v5, a1, v1) || v5[v1] != 61 )
        {
          v5 = *++v4;
          if ( !*v4 )
            goto LABEL_13;
        }
        v7 = v4;
        do
        {
          v8 = v7[1];
          *v7++ = v8;
        }
        while ( v8 );
      }
    }
LABEL_13:
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --envlock )
      _lll_unlock_wake_private(&envlock);
    return 0;
  }
  else
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    return -1;
  }
}
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 80EC524: using guessed type int environ;
// 80EC69C: using guessed type int envlock;

//----- (0807BF30) --------------------------------------------------------
int __usercall clearenv@<eax>(long double a1@<st0>)
{
  bool v2; // zf

  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg ds:envlock, ecx }
  if ( !v2 )
    _lll_lock_wait_private(0, &envlock);
  if ( last_environ == environ && environ )
  {
    free(a1, environ);
    last_environ = 0;
  }
  environ = 0;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --envlock )
    _lll_unlock_wake_private(&envlock);
  return 0;
}
// 80EC524: using guessed type int environ;
// 80EC694: using guessed type int last_environ;
// 80EC69C: using guessed type int envlock;

//----- (0807BFB0) --------------------------------------------------------
int __cdecl secure_getenv(_BYTE *a1)
{
  if ( _libc_enable_secure )
    return 0;
  else
    return getenv(a1);
}
// 80EAFCC: using guessed type int _libc_enable_secure;

//----- (0807BFD0) --------------------------------------------------------
int __cdecl _strtol_internal(char *a1, char **a2, int a3, int a4)
{
  return ___strtol_l_internal(a1, a2, a3, a4, __readgsdword(0xFFFFFFDC));
}

//----- (0807C000) --------------------------------------------------------
int __cdecl strtol(char *a1, char **a2, int a3)
{
  return ___strtol_l_internal(a1, a2, a3, 0, __readgsdword(0xFFFFFFDC));
}

//----- (0807C030) --------------------------------------------------------
int __cdecl ___strtol_l_internal(char *a1, char **a2, int a3, int a4, int a5)
{
  _BYTE *v5; // esi
  int v6; // ecx
  char v7; // al
  char *v8; // edx
  unsigned __int8 v9; // cl
  int v10; // edi
  int v11; // eax
  char *v12; // ebx
  int v13; // ebp
  int v14; // edx
  int v15; // edx
  int v16; // ecx
  char *v17; // edx
  int result; // eax
  int v19; // eax
  int v20; // edx
  int v21; // ebx
  int v22; // ecx
  int v23; // eax
  char *v24; // edx
  int v25; // eax
  char *v26; // [esp+4h] [ebp-38h]
  unsigned int v27; // [esp+8h] [ebp-34h]
  unsigned __int8 v28; // [esp+8h] [ebp-34h]
  char *v29; // [esp+Ch] [ebp-30h]
  char *v30; // [esp+Ch] [ebp-30h]
  int v31; // [esp+10h] [ebp-2Ch]
  unsigned __int8 v32; // [esp+1Bh] [ebp-21h]
  int v33; // [esp+1Ch] [ebp-20h]

  v5 = 0;
  v26 = 0;
  if ( a4 )
  {
    v20 = *(_DWORD *)(a5 + 4);
    v26 = *(char **)(v20 + 44);
    if ( (unsigned __int8)(*v26 - 1) > 0x7Du )
    {
      v26 = 0;
    }
    else
    {
      v5 = *(_BYTE **)(v20 + 40);
      if ( !*v5 )
      {
        v26 = 0;
        v5 = 0;
      }
    }
  }
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    return 0;
  }
  v6 = *(_DWORD *)(a5 + 52);
  v29 = a1;
  v7 = *a1;
  if ( (*(_BYTE *)(v6 + 2 * *a1 + 1) & 0x20) != 0 )
  {
    v8 = a1;
    do
      v7 = *++v8;
    while ( (*(_BYTE *)(v6 + 2 * *v8 + 1) & 0x20) != 0 );
    v29 = v8;
  }
  if ( !v7 )
  {
    v12 = a1;
LABEL_63:
    if ( !a2 )
      return 0;
    if ( v12 - a1 > 1 && dword_80C1B40[*(v12 - 1)] == 88 && *(v12 - 2) == 48 )
    {
      *a2 = v12 - 1;
      return 0;
    }
    else
    {
      *a2 = a1;
      return 0;
    }
  }
  if ( v7 == 45 )
  {
    v30 = v29 + 1;
    v33 = 1;
  }
  else
  {
    v33 = 0;
    v30 = &v29[v7 == 43];
  }
  v9 = *v30;
  if ( *v30 != 48 )
  {
    if ( !a3 )
      goto LABEL_36;
    goto LABEL_13;
  }
  if ( (a3 & 0xFFFFFFEF) != 0 )
    goto LABEL_13;
  if ( dword_80C1B40[v30[1]] == 88 )
  {
    v32 = 15;
    v10 = 0;
    v27 = 0xFFFFFFF;
    a3 = 16;
    v26 = 0;
    v9 = v30[2];
    v30 += 2;
    goto LABEL_15;
  }
  if ( a3 )
  {
LABEL_13:
    if ( a3 != 10 )
    {
      v10 = 0;
      v26 = 0;
      v27 = dword_80CC7B8[a3];
      v32 = byte_80CC77E[a3];
      goto LABEL_15;
    }
LABEL_36:
    if ( v26 )
    {
      v28 = *v30;
      v21 = strlen(v5);
      v10 = v21;
      if ( !v21 )
      {
LABEL_62:
        v12 = v30;
        goto LABEL_63;
      }
      v22 = v28;
      if ( v28 == *v5 )
      {
        v23 = 0;
        do
        {
          if ( v21 == ++v23 )
            goto LABEL_62;
        }
        while ( v5[v23] == v30[v23] );
        v22 = v28;
      }
      if ( (_BYTE)v22 )
      {
        v24 = v30;
        while ( 1 )
        {
          if ( (unsigned __int8)(v22 - 48) > 9u )
          {
            if ( *v24 == *v5 )
            {
              v25 = 0;
              while ( v21 != ++v25 )
              {
                if ( v5[v25] != v24[v25] )
                {
                  v22 = (unsigned __int8)v22;
                  goto LABEL_84;
                }
              }
            }
            else
            {
LABEL_84:
              if ( (byte_80C2440[2 * v22 + 1] & 4) == 0 || (int)dword_80C1B40[v22] > 64 )
                goto LABEL_82;
            }
          }
          v22 = (unsigned __int8)*++v24;
          if ( !(_BYTE)v22 )
            goto LABEL_82;
        }
      }
      v24 = v30;
LABEL_82:
      v26 = (char *)_correctly_grouped_prefixmb((unsigned int)v30, (unsigned int)v24, v5, v26);
      v9 = *v30;
      v32 = 5;
      v27 = 429496729;
      a3 = 10;
    }
    else
    {
      v32 = 5;
      v27 = 429496729;
      v10 = 0;
      a3 = 10;
    }
LABEL_15:
    v11 = v9;
    if ( v9 && v26 != v30 )
      goto LABEL_17;
    goto LABEL_62;
  }
  a3 = 8;
  v27 = 0x1FFFFFFF;
  v11 = 48;
  v32 = 7;
  v10 = 0;
  v26 = 0;
LABEL_17:
  v12 = v30;
  v31 = 0;
  v13 = 0;
  do
  {
    LOBYTE(v14) = v11 - 48;
    if ( (unsigned __int8)(v11 - 48) > 9u )
    {
      if ( v10 )
      {
        if ( *v5 == *v12 )
        {
          v15 = 0;
          while ( 1 )
          {
            v16 = v15 + 1;
            if ( v15 + 1 == v10 )
              break;
            if ( v5[++v15] != v12[v16] )
              goto LABEL_46;
          }
          v17 = &v12[v15];
          goto LABEL_25;
        }
LABEL_46:
        if ( (byte_80C2440[2 * v11 + 1] & 4) == 0 )
          break;
        v14 = dword_80C1B40[v11] - 55;
      }
      else
      {
        if ( (byte_80C2440[2 * v11 + 1] & 4) == 0 )
          break;
        v14 = dword_80C1B40[v11] - 55;
      }
    }
    v19 = (unsigned __int8)v14;
    if ( (unsigned __int8)v14 >= a3 )
      break;
    if ( v13 > v27 || (unsigned __int8)v14 > v32 && v13 == v27 )
    {
      v17 = v12;
      v31 = 1;
    }
    else
    {
      v17 = v12;
      v13 = v19 + a3 * v13;
    }
LABEL_25:
    v12 = v17 + 1;
    v11 = (unsigned __int8)v17[1];
  }
  while ( v17 + 1 != v26 && (_BYTE)v11 );
  if ( v12 == v30 )
    goto LABEL_63;
  if ( a2 )
    *a2 = v12;
  if ( v31 )
  {
    __writegsdword(0xFFFFFFE8, 0x22u);
    return v33 + 0x7FFFFFFF;
  }
  else if ( v33 )
  {
    result = -v13;
    if ( (unsigned int)v13 > 0x80000000 )
    {
      __writegsdword(0xFFFFFFE8, 0x22u);
      return 0x80000000;
    }
  }
  else if ( v13 < 0 )
  {
    __writegsdword(0xFFFFFFE8, 0x22u);
    return 0x7FFFFFFF;
  }
  else
  {
    return v13;
  }
  return result;
}
// 80C1B40: using guessed type _DWORD dword_80C1B40[256];
// 80C2440: using guessed type _BYTE byte_80C2440[512];
// 80CC7B8: using guessed type int dword_80CC7B8[];

//----- (0807C540) --------------------------------------------------------
int __cdecl strtol_l(char *a1, char **a2, int a3, int a4)
{
  return ___strtol_l_internal(a1, a2, a3, 0, a4);
}

//----- (0807C560) --------------------------------------------------------
char *__cdecl itoa_word(unsigned int a1, char *a2, unsigned int a3, int a4)
{
  const char *v4; // esi
  char *v6; // ebx
  char v7; // dl
  bool v8; // zf
  char *v10; // ebx
  char v11; // al
  char *v12; // ebx
  char v13; // al
  char *v14; // ebx
  char v15; // al

  v4 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZto_outpunct";
  if ( !a4 )
    v4 = "0123456789abcdefghijklmnopqrstuvwxyz";
  if ( a3 == 10 )
  {
    v14 = a2;
    do
    {
      --v14;
      v15 = v4[a1 % 0xA];
      a1 /= 0xAu;
      *v14 = v15;
    }
    while ( a1 );
    return v14;
  }
  else if ( a3 == 16 )
  {
    v12 = a2;
    do
    {
      v13 = a1;
      a1 >>= 4;
      *--v12 = v4[v13 & 0xF];
    }
    while ( a1 );
    return v12;
  }
  else
  {
    v6 = a2;
    if ( a3 == 8 )
    {
      v10 = a2;
      do
      {
        v11 = a1;
        a1 >>= 3;
        *--v10 = v4[v11 & 7];
      }
      while ( a1 );
      return v10;
    }
    else
    {
      do
      {
        --v6;
        v7 = v4[a1 % a3];
        v8 = a1 / a3 == 0;
        a1 /= a3;
        *v6 = v7;
      }
      while ( !v8 );
      return v6;
    }
  }
}

//----- (0807C640) --------------------------------------------------------
_BYTE *__cdecl itoa(unsigned __int64 a1, _BYTE *a2, unsigned int a3, int a4)
{
  const char *v4; // esi
  unsigned int v5; // edx
  unsigned int v6; // ecx
  _BYTE *result; // eax
  char v8; // bl
  unsigned int v9; // ebx
  unsigned int v10; // eax
  int v11; // edx
  int *v12; // ebp
  _BYTE *v13; // ecx
  int i; // ebx
  int v15; // et2
  int v16; // eax
  _BYTE *v17; // ebx
  char v18; // bl
  char v19; // bl
  char v20; // dl
  char v21; // cl
  unsigned int v22; // ebp
  unsigned int v23; // eax
  unsigned __int64 v24; // rtt
  unsigned __int64 v25; // rt2
  char *v26; // [esp+0h] [ebp-2Ch]
  char *v27; // [esp+0h] [ebp-2Ch]
  unsigned int v28; // [esp+4h] [ebp-28h]
  int v29; // [esp+Ch] [ebp-20h] BYREF
  unsigned int v30; // [esp+10h] [ebp-1Ch] BYREF
  unsigned int v31; // [esp+14h] [ebp-18h]

  v4 = "0123456789abcdefghijklmnopqrstuvwxyz";
  v5 = HIDWORD(a1);
  v6 = a1;
  if ( a4 )
    v4 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZto_outpunct";
  if ( a3 == 8 )
  {
    result = a2;
    if ( HIDWORD(a1) )
    {
      do
      {
        v18 = v6;
        --result;
        v6 >>= 3;
        *result = v4[v18 & 7];
      }
      while ( a2 - 10 != result );
      v6 |= (4 * BYTE4(a1)) & 4;
      if ( HIDWORD(a1) >> 1 )
      {
        v19 = v4[v6];
        v6 = HIDWORD(a1) >> 1;
        *(result - 1) = v19;
        result = a2 - 11;
      }
    }
    do
    {
      v20 = v6;
      v6 >>= 3;
      *--result = v4[v20 & 7];
    }
    while ( v6 );
  }
  else if ( a3 == 16 )
  {
    if ( HIDWORD(a1) )
    {
      result = a2;
      do
      {
        v8 = v6;
        --result;
        v6 >>= 4;
        *result = v4[v8 & 0xF];
      }
      while ( a2 - 8 != result );
    }
    else
    {
      result = a2;
      v5 = a1;
    }
    do
    {
      v21 = v5;
      v5 >>= 4;
      *--result = v4[v21 & 0xF];
    }
    while ( v5 );
  }
  else
  {
    v9 = a3 - 2;
    if ( HIDWORD(a1) )
    {
      v22 = itoa_base_table[3 * v9 + 2];
      v27 = (char *)&itoa_base_table[3 * v9];
      if ( HIDWORD(a1) < v22 )
      {
        v29 = a1 / v22;
        v30 = a1 % v22;
        v10 = v30;
        v11 = 2;
      }
      else
      {
        v28 = HIDWORD(a1) / v22;
        LODWORD(v24) = a1;
        HIDWORD(v24) = HIDWORD(a1) % v22;
        v23 = v24 / v22;
        v31 = v24 % v22;
        v25 = __PAIR64__(HIDWORD(a1) / v22, v23) % *((unsigned int *)v27 + 2);
        v29 = __PAIR64__(HIDWORD(a1) / v22, v23) / *((unsigned int *)v27 + 2);
        v30 = v25;
        v10 = v31;
        v11 = 3;
      }
    }
    else
    {
      v10 = a1;
      v29 = a1;
      v11 = 1;
    }
    v12 = &v29 + v11;
    v13 = a2;
    v26 = (char *)&itoa_base_table[3 * v9];
    while ( 1 )
    {
      for ( i = 0; v10; *v13 = v4[v15] )
      {
        --v13;
        ++i;
        v15 = v10 % a3;
        v10 /= a3;
      }
      if ( &v30 == (unsigned int *)v12 )
        break;
      v16 = v26[5];
      if ( v16 > i )
      {
        v17 = &v13[i - v16];
        do
          *--v13 = 48;
        while ( v17 != v13 );
      }
      v10 = *(v12 - 2);
      --v12;
    }
    if ( a2 == v13 )
    {
      result = a2 - 1;
      *(a2 - 1) = 48;
    }
    else
    {
      return v13;
    }
  }
  return result;
}
// 80CC860: using guessed type _DWORD itoa_base_table[112];

//----- (0807C850) --------------------------------------------------------
char *__cdecl fitoa_word(unsigned int a1, _BYTE *a2, unsigned int a3, int a4)
{
  char *v4; // eax
  char *v5; // edx
  _BYTE *v6; // ecx
  char v8; // [esp+10h] [ebp-8h] BYREF
  char v9[7]; // [esp+11h] [ebp-7h] BYREF

  v4 = itoa_word(a1, &v8, a3, a4);
  if ( v4 >= &v8 )
    return a2;
  v5 = v4;
  v6 = a2;
  do
    *v6++ = *v5++;
  while ( v5 != &v8 );
  return &a2[v9 - (v4 + 1)];
}
// 807C850: using guessed type char var_7[7];

//----- (0807C8B0) --------------------------------------------------------
char *__cdecl fitoa(unsigned __int64 a1, _BYTE *a2, unsigned int a3, int a4)
{
  char *v4; // eax
  char *v5; // edx
  _BYTE *v6; // ecx
  char v8; // [esp+24h] [ebp-Ch] BYREF
  char v9[11]; // [esp+25h] [ebp-Bh] BYREF

  v4 = itoa(a1, &v8, a3, a4);
  if ( v4 >= &v8 )
    return a2;
  v5 = v4;
  v6 = a2;
  do
    *v6++ = *v5++;
  while ( v5 != &v8 );
  return &a2[v9 - (v4 + 1)];
}
// 807C8B0: using guessed type char var_B[11];

//----- (0807C920) --------------------------------------------------------
int __usercall read_int@<eax>(_DWORD *a1@<eax>)
{
  unsigned __int8 *v1; // ebx
  int v2; // ecx
  int v3; // ebp
  unsigned int v4; // edx

  v1 = (unsigned __int8 *)(*a1 + 1);
  v2 = *(unsigned __int8 *)*a1 - 48;
  while ( 1 )
  {
    *a1 = v1;
    v4 = *v1 - 48;
    if ( v4 > 9 )
      break;
    if ( v2 >= 0 )
    {
      if ( v2 <= 214748364 )
      {
        v3 = 10 * v2;
        v2 = 10 * v2 + v4;
        if ( v3 > (int)(0x7FFFFFFF - v4) )
          v2 = -1;
      }
      else
      {
        v2 = -1;
      }
    }
    ++v1;
  }
  return v2;
}

//----- (0807C980) --------------------------------------------------------
int __userpurge group_number@<eax>(_BYTE *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, _BYTE *a4)
{
  char *v7; // ecx
  int v8; // esi
  unsigned int v9; // edx
  void *v10; // esp
  int *v11; // eax
  int v12; // edx
  int v13; // ecx
  int v14; // esi
  char v15; // dl
  unsigned int v16; // ecx
  int *v17; // [esp+Ch] [ebp-28h] BYREF
  int v18; // [esp+10h] [ebp-24h]
  char *v19; // [esp+14h] [ebp-20h]
  int *v20; // [esp+18h] [ebp-1Ch]

  v20 = (int *)a2;
  v18 = strlen(a4);
  if ( (unsigned __int8)(*a3 - 1) > 0x7Du )
    return (int)a1;
  v7 = a3 + 1;
  v8 = (char)*a3;
  v17 = v20;
  v9 = (char *)v20 - a1;
  v19 = v7;
  v10 = alloca((char *)v20 - a1 + 15);
  v20 = (int *)&v17;
  v11 = (int *)mempcpy(&v17, a1, v9);
  v12 = (int)v17;
  if ( v20 >= v11 )
    return (int)v17;
  while ( 1 )
  {
    while ( 1 )
    {
      v11 = (int *)((char *)v11 - 1);
      --v8;
      a1 = (_BYTE *)(v12 - 1);
      *(_BYTE *)(v12 - 1) = *(_BYTE *)v11;
      if ( !v8 )
        break;
      if ( v20 >= v11 )
        return (int)a1;
      --v12;
    }
    v13 = (int)v20;
    if ( v20 >= v11 )
      return (int)a1;
    v14 = v18;
    do
      *--a1 = a4[--v14];
    while ( v14 > 0 );
    v20 = (int *)v13;
    v15 = *v19;
    if ( *v19 == 127 || v15 < 0 )
      break;
    if ( v15 )
    {
      v8 = v15;
      ++v19;
      v12 = (int)a1;
    }
    else
    {
      v12 = (int)a1;
      v8 = *(v19 - 1);
    }
  }
  v16 = (unsigned int)v20;
  do
  {
    v11 = (int *)((char *)v11 - 1);
    *--a1 = *(_BYTE *)v11;
  }
  while ( v16 < (unsigned int)v11 );
  return (int)a1;
}

//----- (0807CAB0) --------------------------------------------------------
_BYTE *__usercall i18n_number_rewrite@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v6; // eax
  unsigned int v7; // edi
  unsigned int v8; // edx
  void *v9; // esp
  int *v10; // ecx
  char *v11; // eax
  unsigned int v12; // ecx
  char *v13; // ebx
  int v14; // eax
  _BYTE *v16; // edi
  int v17; // eax
  int v18; // edx
  __int16 *v19; // edi
  int v20; // eax
  int v21; // edx
  _BOOL4 v22; // eax
  int v23; // eax
  int v24; // ecx
  int v25; // eax
  int v26; // [esp+Ch] [ebp-58h] BYREF
  int v27; // [esp+10h] [ebp-54h]
  unsigned int v28; // [esp+14h] [ebp-50h]
  _DWORD *v29; // [esp+18h] [ebp-4Ch]
  int v30; // [esp+20h] [ebp-44h] BYREF
  int v31; // [esp+24h] [ebp-40h]
  __int16 v32[8]; // [esp+2Ah] [ebp-3Ah] BYREF
  __int16 v33[20]; // [esp+3Bh] [ebp-29h] BYREF

  v29 = (_DWORD *)wctrans(135056004);
  v28 = towctrans(0x2Eu, v29);
  v6 = towctrans(0x2Cu, v29);
  if ( v29 )
  {
    v26 = v6;
    v30 = 0;
    v31 = 0;
    v23 = wcrtomb((char *)v32, v28, &v30);
    v24 = v26;
    if ( v23 == -1 )
      v32[0] = 46;
    else
      *((_BYTE *)v32 + v23) = 0;
    v30 = 0;
    v31 = 0;
    v25 = wcrtomb((char *)v33, v24, &v30);
    if ( v25 == -1 )
      v33[0] = 44;
    else
      *((_BYTE *)v33 + v25) = 0;
  }
  v7 = a2 - (_DWORD)a1;
  v8 = v7;
  if ( v7 <= 0x1000 || (v28 = v7, v22 = _libc_alloca_cutoff(v7), v8 = v7, v22) )
  {
    v27 = 1;
    v9 = alloca(v8 + 15);
    v10 = &v26;
  }
  else
  {
    v28 = v7;
    v10 = (int *)malloc(v7);
    if ( !v10 )
      return a1;
    v27 = 0;
    v8 = v28;
  }
  v28 = (unsigned int)v10;
  v11 = (char *)mempcpy(v10, a1, v8);
  v12 = v28;
  v13 = v11;
LABEL_5:
  while ( v12 <= (unsigned int)--v13 )
  {
    while ( 1 )
    {
      v14 = *v13;
      if ( (unsigned __int8)(v14 - 48) <= 9u )
        break;
      if ( v29 && (v14 & 0xFD) == 44 )
      {
        v19 = v33;
        v28 = v12;
        if ( (_BYTE)v14 == 46 )
          v19 = v32;
        v20 = strlen(v19);
        a3 -= v20;
        v21 = v20 - 1;
        v12 = v28;
        if ( v20 )
        {
          do
          {
            *(_BYTE *)(a3 + v21) = *((_BYTE *)v19 + v21);
            --v21;
          }
          while ( v21 != -1 );
        }
        goto LABEL_5;
      }
      --v13;
      *(_BYTE *)--a3 = v14;
      if ( v12 > (unsigned int)v13 )
        goto LABEL_9;
    }
    v28 = v12;
    v16 = *(_BYTE **)(*(_DWORD *)__readgsdword(0xFFFFFFD8) + 4 * v14 + 8);
    v17 = strlen(v16);
    a3 -= v17;
    v18 = v17 - 1;
    v12 = v28;
    if ( v17 )
    {
      do
      {
        *(_BYTE *)(a3 + v18) = v16[v18];
        --v18;
      }
      while ( v18 != -1 );
    }
  }
LABEL_9:
  if ( !v27 )
    free(v12);
  return (_BYTE *)a3;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0807CCE0) --------------------------------------------------------
int __usercall IO_helper_overflow@<eax>(long double a1@<st0>, _DWORD *a2, unsigned __int8 a3)
{
  unsigned __int8 *v3; // edx
  _BYTE *v4; // eax
  _BYTE *v5; // edi
  int v6; // ecx
  int v7; // ebp
  int v8; // ebp
  int v10; // [esp+Ch] [ebp-20h]

  v3 = (unsigned __int8 *)a2[5];
  v4 = (_BYTE *)a2[4];
  v5 = (_BYTE *)(v3 - v4);
  if ( v3 != v4 )
  {
    v6 = a2[38];
    v7 = *(_DWORD *)(v6 + 148);
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v7
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
    {
      v10 = a2[38];
      IO_vtable_check(a1);
      v4 = (_BYTE *)a2[4];
      v6 = v10;
    }
    v8 = (*(int (__cdecl **)(int, _BYTE *, _BYTE *))(v7 + 28))(v6, v4, v5);
    if ( (unsigned int)(v8 - 1) > 0xFFFFFFFD )
      return -1;
    j_memmove(a2[4], a2[4] + v8, &v5[-v8]);
    v3 = (unsigned __int8 *)(a2[5] - v8);
    a2[5] = v3;
  }
  if ( a2[6] <= (unsigned int)v3 )
    return _overflow((int)a2, a3);
  a2[5] = v3 + 1;
  *v3 = a3;
  return a3;
}
// 80481D0: using guessed type int __cdecl j_memmove(_DWORD, _DWORD, _DWORD);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0807CDC0) --------------------------------------------------------
int __usercall printf_positional@<eax>(
        _DWORD *a1@<eax>,
        _BYTE *a2@<edx>,
        int a3@<ecx>,
        long double a4@<st0>,
        int a5,
        long double **a6,
        int a7,
        unsigned int a8,
        unsigned __int8 *a9,
        _BYTE *a10,
        signed int a11,
        _BYTE *a12,
        _BYTE *a13)
{
  unsigned __int8 *v13; // ecx
  unsigned int v14; // edi
  unsigned int v15; // ebx
  int v16; // esi
  int v17; // eax
  _BYTE *v18; // eax
  int v19; // ebx
  void *v20; // esp
  int *v21; // ecx
  _DWORD *v22; // ebx
  int v23; // esi
  int *v24; // edi
  int v25; // ecx
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // edx
  long double *v30; // esi
  unsigned int v31; // ebx
  int v32; // eax
  int v33; // edi
  unsigned __int8 v34; // dl
  char v35; // cl
  int v36; // eax
  _BYTE *v37; // eax
  int v38; // eax
  int v39; // eax
  int v40; // eax
  int v41; // eax
  int v42; // eax
  unsigned int v43; // esi
  void *v44; // esp
  int v45; // eax
  int (__cdecl *v46)(_DWORD *, int, char *); // eax
  int v47; // edx
  void *v48; // esp
  char *v49; // ecx
  int v50; // ebx
  char *v51; // edx
  char *v52; // eax
  int v53; // eax
  int v54; // ecx
  int v55; // ebx
  int v56; // eax
  int v57; // ebx
  long double *v58; // eax
  int v59; // edx
  long double *v61; // eax
  int v62; // edx
  int v63; // eax
  int v64; // eax
  int v65; // esi
  char v66; // dl
  int v67; // eax
  _BYTE *v68; // eax
  _BYTE *v69; // eax
  unsigned __int8 *v70; // eax
  unsigned int v71; // ebx
  int v72; // eax
  int v73; // eax
  int v74; // eax
  void *v75; // esp
  int v76; // eax
  unsigned int v77; // ebx
  int v78; // ecx
  int v79; // eax
  int v80; // edx
  int v81; // eax
  unsigned int v82; // eax
  signed int v83; // esi
  char *v84; // edx
  int v85; // edx
  int v86; // ebx
  char v87; // al
  int v88; // ebx
  _BYTE *v89; // eax
  _DWORD *v90; // ecx
  _BYTE *v91; // eax
  unsigned __int8 *v92; // eax
  int v93; // ebx
  int v94; // ebx
  _BYTE *v95; // eax
  int v96; // edx
  void *v97; // esp
  char *v98; // eax
  char *v99; // ecx
  char *v100; // edx
  _BYTE *v101; // eax
  char v102; // al
  _BYTE *v103; // eax
  _BYTE *v104; // eax
  _BYTE *v105; // eax
  _BYTE *v106; // eax
  unsigned int v107; // eax
  _BYTE *v108; // eax
  char *v109; // ebx
  _DWORD *v110; // edi
  _BYTE *v111; // eax
  char v112; // dl
  char *v113; // esi
  int v114; // edx
  bool v115; // zf
  unsigned int v116; // ebx
  int v117; // ebx
  int *v118; // eax
  int v119; // eax
  _QWORD *v120; // eax
  bool v121; // si
  _BYTE *v122; // eax
  unsigned int v123; // eax
  int v124; // esi
  _BYTE *v125; // edx
  int v126; // edx
  int *v127; // ebx
  char *v128; // eax
  int v129; // esi
  int v130; // eax
  char *v131; // edx
  void *v132; // esp
  int v133; // eax
  int v134; // ebx
  _BYTE *v135; // eax
  int *v136; // ebx
  _BYTE *v137; // eax
  int v138; // esi
  _BYTE *v139; // eax
  _BYTE *v140; // eax
  int v141; // ebx
  int v142; // eax
  _BYTE *v143; // eax
  _BYTE *v144; // eax
  _BYTE *v145; // eax
  void *v146; // esp
  _BYTE *v147; // eax
  char *v148; // edx
  int v149; // eax
  int v150; // edx
  int v151; // ebx
  __int64 v152; // rax
  char *v153; // ebx
  _DWORD *v154; // edi
  _BYTE *v155; // eax
  char v156; // dl
  _BYTE *v157; // eax
  _BYTE *v158; // eax
  int v159; // eax
  int v160; // eax
  int v161; // edx
  int v162; // ebx
  void *v163; // esp
  _BOOL4 v164; // eax
  _DWORD *v165; // [esp-10h] [ebp-4B8h]
  int v166; // [esp-Ch] [ebp-4B4h]
  char v167[8]; // [esp+0h] [ebp-4A8h] BYREF
  int v168; // [esp+8h] [ebp-4A0h]
  int *v169; // [esp+Ch] [ebp-49Ch]
  unsigned int v170; // [esp+10h] [ebp-498h]
  char v171; // [esp+17h] [ebp-491h]
  int v172; // [esp+18h] [ebp-490h]
  unsigned int v173; // [esp+1Ch] [ebp-48Ch]
  int v174; // [esp+20h] [ebp-488h]
  int v175; // [esp+24h] [ebp-484h]
  unsigned __int64 v176; // [esp+28h] [ebp-480h]
  unsigned int v177; // [esp+30h] [ebp-478h]
  bool v178; // [esp+34h] [ebp-474h]
  unsigned __int8 v179; // [esp+35h] [ebp-473h]
  bool v180; // [esp+36h] [ebp-472h]
  unsigned __int8 v181; // [esp+37h] [ebp-471h]
  int v182; // [esp+38h] [ebp-470h]
  unsigned int v183; // [esp+3Ch] [ebp-46Ch]
  int v184; // [esp+40h] [ebp-468h]
  _BYTE *v185; // [esp+44h] [ebp-464h]
  int v186; // [esp+48h] [ebp-460h]
  int v187; // [esp+4Ch] [ebp-45Ch]
  char *v188; // [esp+50h] [ebp-458h]
  int v189; // [esp+54h] [ebp-454h]
  int v190; // [esp+58h] [ebp-450h]
  char *v191; // [esp+5Ch] [ebp-44Ch]
  _DWORD *v192; // [esp+60h] [ebp-448h]
  unsigned int v193; // [esp+64h] [ebp-444h]
  int v194; // [esp+68h] [ebp-440h]
  int v195; // [esp+6Ch] [ebp-43Ch]
  _BYTE *v196; // [esp+74h] [ebp-434h] BYREF
  long double *v197; // [esp+78h] [ebp-430h] BYREF
  double *v198; // [esp+7Ch] [ebp-42Ch] BYREF
  int v199; // [esp+80h] [ebp-428h]
  char *v200; // [esp+88h] [ebp-420h] BYREF
  unsigned int v201; // [esp+8Ch] [ebp-41Ch]
  char v202[1048]; // [esp+90h] [ebp-418h] BYREF

  v192 = a1;
  v186 = a3;
  v185 = a2;
  v13 = a9;
  v201 = 1024;
  v200 = v202;
  v196 = 0;
  if ( a12 == (_BYTE *)-1 )
  {
    v67 = *(_DWORD *)__readgsdword(0xFFFFFFE4);
    a12 = *(_BYTE **)(v67 + 44);
    a13 = *(_BYTE **)(v67 + 40);
    if ( !*a12 || *a12 == 127 )
      a12 = 0;
  }
  v14 = 0;
  if ( *a9 )
  {
    v15 = 0;
    v194 = 19;
    v195 = (int)v202;
    while ( 1 )
    {
      v16 = v195 + 52 * v14++;
      v17 = _parse_one_specmb(v13, v15, v16, (unsigned int *)&v196);
      v13 = *(unsigned __int8 **)(v16 + 24);
      v15 += v17;
      if ( !*v13 )
        break;
      if ( v194 == v14 )
      {
        v193 = *(_DWORD *)(v16 + 24);
        if ( !(unsigned __int8)_libc_scratch_buffer_grow_preserve((int)&v200) )
          goto LABEL_86;
        v13 = (unsigned __int8 *)v193;
        v195 = (int)v200;
        v194 = v201 / 0x34;
      }
    }
    v18 = (_BYTE *)v15;
    if ( (unsigned int)v196 >= v15 )
      v18 = v196;
    v193 = (unsigned int)v18;
    if ( (unsigned int)v18 > 0x6666666 )
    {
      __writegsdword(0xFFFFFFE8, 0x4Bu);
      goto LABEL_86;
    }
    v19 = 20 * v193;
    if ( 20 * v193 > 0x1000 && !_libc_alloca_cutoff(20 * v193) )
    {
      v64 = malloc(20 * v193);
      v187 = v64;
      if ( !v64 )
        goto LABEL_86;
      v188 = (char *)v64;
      goto LABEL_13;
    }
  }
  else
  {
    v19 = 0;
    v193 = 0;
    v195 = (int)v202;
  }
  v187 = 0;
  v20 = alloca(v19 + 15);
  v188 = v167;
LABEL_13:
  v191 = &v188[12 * v193];
  v166 = (int)(v192[15] << 29) >> 31;
  v194 = (int)&v191[4 * v193];
  j_memset(v194, v166, 4 * v193);
  v21 = (int *)v194;
  if ( !v14 )
  {
    if ( v193 )
      goto LABEL_25;
LABEL_73:
    v57 = a7;
    if ( !v187 )
      goto LABEL_87;
    v191 = 0;
LABEL_75:
    free(v187);
    goto LABEL_132;
  }
  v194 = v14;
  v22 = (_DWORD *)v195;
  v23 = 0;
  v24 = v21;
  do
  {
    while ( 1 )
    {
      v26 = v22[8];
      if ( v26 != -1 )
        v24[v26] = 0;
      v27 = v22[7];
      if ( v27 != -1 )
        v24[v27] = 0;
      v28 = v22[11];
      if ( !v28 )
        goto LABEL_16;
      if ( v28 != 1 )
        break;
      v25 = (int)v191;
      v24[v22[9]] = v22[10];
      *(_DWORD *)(v25 + 4 * v22[9]) = v22[12];
LABEL_16:
      ++v23;
      v22 += 13;
      if ( v23 == v194 )
        goto LABEL_24;
    }
    v29 = v22[9];
    ++v23;
    v190 = v22[2];
    v189 = _printf_arginfo_table;
    v165 = v22;
    v22 += 13;
    (*(void (__cdecl **)(_DWORD *, int, int *, char *))(_printf_arginfo_table + 4 * v190))(
      v165,
      v28,
      &v24[v29],
      &v191[4 * v29]);
  }
  while ( v23 != v194 );
LABEL_24:
  v21 = v24;
  v14 = v194;
  if ( !v193 )
    goto LABEL_38;
LABEL_25:
  v194 = v14;
  v30 = (long double *)v188;
  v31 = 0;
  while ( 1 )
  {
LABEL_26:
    v32 = v21[v31];
    if ( v32 <= 5 )
    {
      if ( v32 < 0 )
      {
        if ( v32 == -1 )
        {
          if ( (v192[15] & 4) == 0 )
            _assert_fail("s->_flags2 & _IO_FLAGS2_FORTIFY", "vfprintf.c", 1897, "printf_positional");
          _libc_fatal("*** invalid %N$ use detected ***\n");
        }
        goto LABEL_82;
      }
      goto LABEL_76;
    }
    if ( v32 == 256 )
    {
      v61 = *a6;
      *a6 = (long double *)((char *)*a6 + 8);
      v62 = *((_DWORD *)v61 + 1);
      v63 = *(_DWORD *)v61;
      *((_DWORD *)v30 + 1) = v62;
      *(_DWORD *)v30 = v63;
      goto LABEL_77;
    }
    if ( v32 <= 256 )
      break;
    if ( v32 == 512 || v32 == 1024 )
      goto LABEL_76;
    if ( v32 != 263 )
      goto LABEL_82;
    ++v31;
    ++v30;
    a4 = *(*a6)++;
    *(v30 - 1) = a4;
    if ( v193 <= v31 )
      goto LABEL_37;
  }
  if ( v32 <= 7 )
  {
    a4 = *(double *)*a6;
    *a6 = (long double *)((char *)*a6 + 8);
    *(double *)v30 = a4;
    goto LABEL_77;
  }
LABEL_82:
  if ( (v32 & 0x800) != 0 )
  {
LABEL_76:
    v58 = *a6;
    *a6 = (long double *)((char *)*a6 + 4);
    *(_DWORD *)v30 = *(_DWORD *)v58;
    goto LABEL_77;
  }
  v59 = _printf_va_arg_table;
  if ( _printf_va_arg_table && *(_DWORD *)(_printf_va_arg_table + 4 * v32 - 32) )
  {
    v189 = (int)v21;
    v132 = alloca(*(_DWORD *)&v191[4 * v31] + 15);
    v190 = (int)v167;
    *(_DWORD *)v30 = v167;
    (*(void (__cdecl **)(int, long double **))(v59 + 4 * v21[v31] - 32))(v190, a6);
    v21 = (int *)v189;
  }
  else
  {
    a4 = 0.0;
    *v30 = 0.0;
  }
LABEL_77:
  ++v31;
  ++v30;
  if ( v193 > v31 )
    goto LABEL_26;
LABEL_37:
  v14 = v194;
LABEL_38:
  if ( a8 >= v14 )
    goto LABEL_73;
  v170 = v14;
  v169 = (int *)(a10 + 1000);
  v33 = 52 * a8 + v195;
  v173 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
  while ( 2 )
  {
    v34 = *(_BYTE *)(v33 + 12);
    v195 = *(_DWORD *)v33;
    LOBYTE(v184) = (v34 & 8) != 0;
    LOBYTE(v183) = (v34 & 0x10) != 0;
    v190 = (v34 & 0x20) != 0;
    LOBYTE(v182) = (v34 & 0x40) != 0;
    v171 = v34 >> 7;
    v172 = v34 >> 7;
    v181 = v34 & 1;
    LOBYTE(v177) = (v34 & 2) != 0;
    v35 = *(_BYTE *)(v33 + 13);
    v178 = (v35 & 8) != 0;
    v36 = *(_DWORD *)(v33 + 16);
    LOBYTE(v176) = (v35 & 2) != 0;
    v175 = v36;
    v37 = *(_BYTE **)(v33 + 8);
    v180 = (v34 & 4) != 0;
    v193 = (unsigned int)v37;
    v179 = (unsigned __int8)v37;
    v38 = *(_DWORD *)(v33 + 32);
    if ( v38 == -1 )
    {
      v194 = *(_DWORD *)(v33 + 4);
    }
    else
    {
      v39 = *(_DWORD *)&v188[12 * v38];
      v194 = v39;
      if ( v39 < 0 )
      {
        v194 = -v194;
        v190 = 1;
        v39 = v194;
        *(_BYTE *)(v33 + 12) = v34 | 0x20;
      }
      *(_DWORD *)(v33 + 4) = v39;
    }
    v40 = *(_DWORD *)(v33 + 28);
    if ( v40 != -1 )
    {
      v41 = *(_DWORD *)&v188[12 * v40];
      v195 = v41;
      if ( v41 < 0 )
      {
        *(_DWORD *)v33 = -1;
        v195 = -1;
      }
      else
      {
        *(_DWORD *)v33 = v41;
      }
    }
    v42 = v194;
    if ( v194 < v195 )
      v42 = v195;
    if ( v42 <= 968 )
    {
      v191 = 0;
      v189 = (int)v169;
    }
    else
    {
      v43 = v42 + 32;
      if ( v42 + 32 <= 4096 || _libc_alloca_cutoff(v43) )
      {
        v191 = 0;
        v44 = alloca(v43 + 15);
        v45 = v195 + 32;
        if ( v194 >= v195 )
          v45 = v194 + 32;
        v189 = (int)&v167[v45];
      }
      else
      {
        v191 = (char *)malloc(v43);
        if ( !v191 )
          goto LABEL_135;
        v133 = v194 + 32;
        if ( v194 < v195 )
          v133 = v195 + 32;
        v189 = (int)&v191[v133];
      }
    }
    if ( _printf_function_table )
    {
      v46 = *(int (__cdecl **)(_DWORD *, int, char *))(_printf_function_table + 4 * (char)v193);
      v174 = (char)v193;
      if ( v46 )
      {
        v47 = *(_DWORD *)(v33 + 44);
        v48 = alloca(4 * v47 + 15);
        if ( v47 )
        {
          v49 = &v167[4 * v47];
          v50 = v195;
          v51 = &v188[12 * *(_DWORD *)(v33 + 36)];
          v52 = v167;
          do
          {
            *(_DWORD *)v52 = v51;
            v52 += 4;
            v51 += 12;
          }
          while ( v49 != v52 );
          v195 = v50;
          v46 = *(int (__cdecl **)(_DWORD *, int, char *))(_printf_function_table + 4 * v174);
        }
        v53 = v46(v192, v33, v167);
        if ( v53 != -2 )
        {
          if ( v53 < 0 )
            goto LABEL_131;
          if ( (unsigned int)a7 > 0x7FFFFFFE )
            _assert_fail("(unsigned int) done < (unsigned int) INT_MAX", "vfprintf.c", 2020, "printf_positional");
LABEL_63:
          if ( v53 > (unsigned int)(0x7FFFFFFF - a7) )
            goto LABEL_130;
          a7 += v53;
          goto LABEL_65;
        }
      }
    }
    v54 = (unsigned __int8)v177;
    v65 = (unsigned __int8)v176;
    v66 = v180;
    v168 = (unsigned __int8)v184;
    v174 = (unsigned __int8)v183;
    v182 = (unsigned __int8)v182;
    v183 = v181;
    v181 = v175;
    switch ( (char)v193 )
    {
      case '%':
        v95 = (_BYTE *)v192[5];
        if ( (unsigned int)v95 >= v192[6] )
        {
          if ( _overflow((int)v192, 37) == -1 )
            goto LABEL_131;
        }
        else
        {
          v192[5] = v95 + 1;
          *v95 = 37;
        }
        if ( a7 == 0x7FFFFFFF )
          goto LABEL_131;
        ++a7;
        goto LABEL_65;
      case 'A':
      case 'a':
        v198 = (double *)&v188[12 * *(_DWORD *)(v33 + 36)];
        v53 = _printf_fphex(v192, v33, &v198);
        if ( v53 < 0 )
          goto LABEL_131;
        goto LABEL_298;
      case 'C':
        goto LABEL_139;
      case 'E':
      case 'F':
      case 'G':
      case 'e':
      case 'f':
      case 'g':
        v197 = (long double *)&v188[12 * *(_DWORD *)(v33 + 36)];
        v53 = _printf_fp(v192, v33, &v197);
        if ( v53 < 0 )
          goto LABEL_131;
LABEL_298:
        if ( (unsigned int)a7 > 0x7FFFFFFE )
          goto LABEL_299;
        goto LABEL_63;
      case 'S':
      case 's':
        v113 = *(char **)&v188[12 * *(_DWORD *)(v33 + 36)];
        goto LABEL_246;
      case 'X':
      case 'x':
        v177 = 16;
        goto LABEL_159;
      case 'c':
        if ( !v180 )
        {
          v71 = v194 - 1;
          v121 = v194 - 1 > 0;
          if ( !v190 && v194 - 1 > 0 )
          {
            if ( v71 != IO_padn((int)v192, 32, v194 - 1) )
              goto LABEL_131;
            if ( (unsigned int)a7 > 0x7FFFFFFE )
              goto LABEL_491;
            if ( v71 > 0x7FFFFFFF - a7 )
              goto LABEL_130;
            a7 += v71;
          }
          v195 = *(_DWORD *)&v188[12 * *(_DWORD *)(v33 + 36)];
          v122 = (_BYTE *)v192[5];
          if ( (unsigned int)v122 >= v192[6] )
          {
            if ( _overflow((int)v192, (unsigned __int8)v195) == -1 )
              goto LABEL_131;
          }
          else
          {
            v192[5] = v122 + 1;
            *v122 = v195;
          }
          if ( a7 == 0x7FFFFFFF )
            goto LABEL_131;
          v54 = v190;
          ++a7;
          if ( v190 && v121 )
          {
            if ( v71 != IO_padn((int)v192, 32, v71) )
              goto LABEL_131;
            if ( (unsigned int)a7 > 0x7FFFFFFE )
LABEL_491:
              _assert_fail("(unsigned int) done < (unsigned int) INT_MAX", "vfprintf.c", 2028, "printf_positional");
            if ( v71 > 0x7FFFFFFF - a7 )
              goto LABEL_130;
            goto LABEL_292;
          }
          goto LABEL_65;
        }
LABEL_139:
        v193 = (unsigned int)v167;
        v74 = *(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFD8) + 88);
        v198 = 0;
        v199 = 0;
        v75 = alloca(v74);
        v76 = wcrtomb(v167, *(_DWORD *)&v188[12 * *(_DWORD *)(v33 + 36)], &v198);
        v77 = v76;
        if ( v76 == -1 )
          goto LABEL_131;
        v78 = v194 - v76;
        LOBYTE(v195) = v194 - v76 > 0;
        if ( !v190 && (_BYTE)v195 )
        {
          v194 -= v76;
          v79 = IO_padn((int)v192, 32, v78);
          v78 = v194;
          if ( v194 != v79 )
            goto LABEL_131;
          if ( (unsigned int)a7 > 0x7FFFFFFE )
            goto LABEL_491;
          if ( v194 > (unsigned int)(0x7FFFFFFF - a7) )
            goto LABEL_394;
          a7 += v194;
        }
        if ( a7 < 0 )
          goto LABEL_485;
        v80 = v192[37];
        if ( v173 <= v80 - (int)&_start___libc_IO_vtables )
        {
          v189 = v192[37];
          v194 = v78;
          IO_vtable_check(v78);
          v80 = v189;
          v78 = v194;
        }
        v194 = v78;
        if ( v77 != (*(int (__cdecl **)(_DWORD *, char *, unsigned int))(v80 + 28))(v192, v167, v77) )
          goto LABEL_131;
        if ( v77 > 0x7FFFFFFF - a7 )
          goto LABEL_394;
        a7 += v77;
        if ( !v190 || !(_BYTE)v195 )
        {
LABEL_65:
          if ( v191 )
            free(v191);
          if ( a7 < 0 )
            _assert_fail("(size_t) done <= (size_t) INT_MAX", "vfprintf.c", 2067, "printf_positional");
          v55 = v192[37];
          if ( v173 <= v55 - (int)&_start___libc_IO_vtables )
            IO_vtable_check(v54);
          v56 = (*(int (__cdecl **)(_DWORD *, _DWORD, int))(v55 + 28))(
                  v192,
                  *(_DWORD *)(v33 + 20),
                  *(_DWORD *)(v33 + 24) - *(_DWORD *)(v33 + 20));
          if ( v56 != *(_DWORD *)(v33 + 24) - *(_DWORD *)(v33 + 20) )
            goto LABEL_135;
          if ( v56 > 0x7FFFFFFF - a7 )
          {
            __writegsdword(0xFFFFFFE8, 0x4Bu);
LABEL_135:
            if ( v187 )
            {
              v191 = 0;
              v57 = -1;
              goto LABEL_75;
            }
LABEL_86:
            v57 = -1;
            goto LABEL_87;
          }
          ++a8;
          a7 += v56;
          v33 += 52;
          if ( a8 >= v170 )
            goto LABEL_73;
          continue;
        }
        v195 = v194;
        v81 = IO_padn((int)v192, 32, v194);
        v54 = v195;
        if ( v195 != v81 )
          goto LABEL_131;
        if ( (unsigned int)a7 > 0x7FFFFFFE )
          goto LABEL_491;
        if ( v195 <= (unsigned int)(0x7FFFFFFF - a7) )
        {
          a7 += v195;
          goto LABEL_65;
        }
LABEL_394:
        __writegsdword(0xFFFFFFE8, 0x4Bu);
LABEL_131:
        v57 = -1;
        if ( v187 )
          goto LABEL_75;
LABEL_132:
        if ( v191 )
          free(v191);
LABEL_87:
        if ( v200 != v202 )
          free(v200);
        return v57;
      case 'd':
      case 'i':
        if ( v183 )
        {
          v148 = &v188[12 * *(_DWORD *)(v33 + 36)];
          v177 = 10;
          v149 = *(_DWORD *)v148;
          v150 = *((_DWORD *)v148 + 1);
          v183 = (unsigned int)v150 >> 31;
          v151 = v150 >> 31;
          LODWORD(v152) = (v150 >> 31) ^ v149;
          HIDWORD(v152) = (v150 >> 31) ^ v150;
          v176 = v152 - __PAIR64__(v151, v151);
          goto LABEL_322;
        }
        if ( (_BYTE)v176 )
        {
          v123 = v188[12 * *(_DWORD *)(v33 + 36)];
        }
        else if ( (_BYTE)v177 )
        {
          v123 = *(__int16 *)&v188[12 * *(_DWORD *)(v33 + 36)];
        }
        else
        {
          v123 = *(_DWORD *)&v188[12 * *(_DWORD *)(v33 + 36)];
        }
        v177 = 10;
        v183 = v123 >> 31;
        v82 = abs32(v123);
        v184 = v82;
        goto LABEL_162;
      case 'm':
        v113 = (char *)strerror_r(a4, a11, a10, 0x3E8u);
        v66 = 0;
LABEL_246:
        if ( v113 )
        {
          if ( (v66 & 1) != 0 || (_BYTE)v193 == 83 )
          {
            v197 = (long double *)v113;
            v198 = 0;
            v199 = 0;
            v189 = (int)&v198;
            if ( v195 >= 0 )
              goto LABEL_378;
            v161 = wcsrtombs(0, (int *)&v197, 0, (int *)v189);
            if ( v161 == -1 )
              goto LABEL_131;
            v193 = (unsigned int)v198;
            if ( v198 )
              _assert_fail("__mbsinit (&mbstate)", "vfprintf.c", 2028, "printf_positional");
            v162 = v161 + 1;
            v197 = (long double *)v113;
            if ( (unsigned int)(v161 + 1) <= 0x1000
              || (v195 = v161, v164 = _libc_alloca_cutoff(v161 + 1), v161 = v195, v164) )
            {
              v163 = alloca(v162 + 15);
              v113 = v167;
            }
            else
            {
              v113 = (char *)malloc(v162);
              if ( !v113 )
                goto LABEL_131;
              v193 = 1;
              v161 = v195;
            }
            v195 = v161;
            wcsrtombs((int)v113, (int *)&v197, v162, (int *)v189);
            v114 = v195;
          }
          else
          {
            if ( v195 != -1 )
              goto LABEL_250;
            v114 = strlen(v113);
            v193 = 0;
          }
        }
        else
        {
          v193 = 0;
          if ( v195 == -1 || v195 > 5 )
          {
            v114 = 6;
            v113 = "(null)";
          }
          else
          {
            v114 = 0;
            v113 = (char *)&unk_80CFAB1;
          }
        }
        goto LABEL_251;
      case 'n':
        if ( (v192[15] & 4) != 0 )
        {
          if ( !v186 )
          {
            v195 = (unsigned __int8)v177;
            v160 = strlen(v185);
            v186 = _readonly_area((unsigned int)v185, v160 + 1);
            v54 = v195;
          }
          if ( v186 < 0 )
            _libc_fatal("*** %n in writable segment detected ***\n", (_DWORD *)v166);
        }
        v120 = *(_QWORD **)&v188[12 * *(_DWORD *)(v33 + 36)];
        if ( v183 )
        {
          *v120 = a7;
        }
        else if ( v65 )
        {
          *(_BYTE *)v120 = a7;
        }
        else if ( v54 )
        {
          *(_WORD *)v120 = a7;
        }
        else
        {
          *(_DWORD *)v120 = a7;
        }
        goto LABEL_65;
      case 'o':
        v177 = 8;
        goto LABEL_159;
      case 'p':
        v82 = *(_DWORD *)&v188[12 * *(_DWORD *)(v33 + 36)];
        if ( v82 )
        {
          v184 = *(_DWORD *)&v188[12 * *(_DWORD *)(v33 + 36)];
          v179 = 120;
          v172 = 0;
          v168 = 1;
          v177 = 16;
          v183 = 0;
          goto LABEL_162;
        }
        v159 = 5;
        v113 = "(nil)";
        if ( v195 >= 5 )
          v159 = v195;
        v195 = v159;
        if ( (_BYTE)v193 == 83 )
        {
          v197 = (long double *)"(nil)";
          v198 = 0;
          v199 = 0;
          v189 = (int)&v198;
LABEL_378:
          if ( v195 <= 4096 || _libc_alloca_cutoff(v195) )
          {
            v193 = 0;
            v146 = alloca(v195 + 15);
            v113 = v167;
          }
          else
          {
            v113 = (char *)malloc(v195);
            if ( !v113 )
              goto LABEL_131;
            v193 = 1;
          }
          v114 = wcsrtombs((int)v113, (int *)&v197, v195, (int *)v189);
          if ( v114 == -1 )
            goto LABEL_131;
        }
        else
        {
LABEL_250:
          v114 = j_strnlen(v113, v195);
          v193 = 0;
        }
LABEL_251:
        v115 = v194 == v114;
        v195 = v194 - v114;
        if ( v194 - v114 < 0 )
        {
          if ( a7 < 0 )
LABEL_485:
            _assert_fail("(size_t) done <= (size_t) INT_MAX", "vfprintf.c", 2028, "printf_positional");
          v141 = v192[37];
          if ( v173 <= v141 - (int)&_start___libc_IO_vtables )
          {
            v195 = v114;
            ((void (*)(void))IO_vtable_check)();
            v114 = v195;
          }
          v195 = v114;
          v142 = (*(int (__cdecl **)(_DWORD *, char *, int))(v141 + 28))(v192, v113, v114);
          if ( v195 != v142 )
            goto LABEL_131;
          if ( v195 > (unsigned int)(0x7FFFFFFF - a7) )
            goto LABEL_130;
          a7 += v195;
        }
        else
        {
          LOBYTE(v194) = v194 != v114;
          if ( !v190 && !v115 )
          {
            v116 = v195;
            v189 = v114;
            if ( v116 != IO_padn((int)v192, 32, v195) )
              goto LABEL_131;
            if ( (unsigned int)a7 > 0x7FFFFFFE )
              goto LABEL_491;
            if ( v116 > 0x7FFFFFFF - a7 )
              goto LABEL_130;
            a7 += v116;
            v114 = v189;
          }
          if ( a7 < 0 )
            goto LABEL_485;
          v117 = v192[37];
          if ( v173 <= v117 - (int)&_start___libc_IO_vtables )
          {
            v189 = v114;
            ((void (*)(void))IO_vtable_check)();
            v114 = v189;
          }
          v189 = v114;
          v118 = (int *)(*(int (__cdecl **)(_DWORD *, char *, int))(v117 + 28))(v192, v113, v114);
          if ( (int *)v189 != v118 )
            goto LABEL_131;
          if ( v189 > (unsigned int)(0x7FFFFFFF - a7) )
            goto LABEL_130;
          a7 += v189;
          if ( v190 && (_BYTE)v194 )
          {
            v119 = IO_padn((int)v192, 32, v195);
            if ( v195 != v119 )
              goto LABEL_131;
            if ( (unsigned int)a7 > 0x7FFFFFFE )
              goto LABEL_491;
            if ( v195 > (unsigned int)(0x7FFFFFFF - a7) )
              goto LABEL_130;
            a7 += v195;
          }
          if ( v193 )
            free(v113);
        }
        goto LABEL_65;
      case 'u':
        v177 = 10;
LABEL_159:
        if ( !v183 )
        {
          if ( (_BYTE)v176 )
          {
            v82 = (unsigned __int8)v188[12 * *(_DWORD *)(v33 + 36)];
            v182 = 0;
            v174 = 0;
            v184 = v82;
          }
          else
          {
            if ( v54 )
              v82 = *(unsigned __int16 *)&v188[12 * *(_DWORD *)(v33 + 36)];
            else
              v82 = *(_DWORD *)&v188[12 * *(_DWORD *)(v33 + 36)];
            v182 = 0;
            v174 = 0;
            v184 = v82;
          }
LABEL_162:
          if ( v195 < 0 )
          {
            v195 = 1;
          }
          else
          {
            if ( !v195 && !v82 )
            {
              if ( v177 != 8 || (v168 & 1) == 0 )
              {
                v83 = 0;
                v181 = 32;
                v193 = v189;
                goto LABEL_305;
              }
              v83 = 1;
              v181 = 32;
              v168 = 1;
              v177 = 8;
              v84 = (char *)(v189 - 1);
              *v84 = 48;
              v193 = (unsigned int)v84;
LABEL_168:
              if ( v195 > v83 )
              {
                v85 = v195;
                v195 -= v83;
                if ( !v190 )
                {
                  v86 = v194 - v85;
                  if ( !v184 )
                    goto LABEL_175;
                  v87 = v168 & 1;
                  goto LABEL_172;
                }
                goto LABEL_101;
              }
LABEL_305:
              if ( v184 )
              {
                v87 = v168 & 1;
                if ( v177 == 8 && v87 )
                {
                  v124 = v189;
                  v125 = (_BYTE *)v193;
                  *(_BYTE *)(v193 - 1) = 48;
                  v83 = v124 - (_DWORD)--v125;
                  v193 = (unsigned int)v125;
                }
                v54 = v190;
                v126 = 0;
                if ( v195 - v83 >= 0 )
                  v126 = v195 - v83;
                v195 = v126;
                if ( !v190 )
                {
                  v86 = v194 - (v83 + v195);
LABEL_172:
                  if ( v177 == 16 && v87 )
                    v86 -= 2;
LABEL_175:
                  v88 = ((v182 | v174 | v183) == 0) + v86 - 1;
                  if ( v181 == 32 )
                  {
                    if ( v88 > 0 )
                    {
                      if ( v88 != IO_padn((int)v192, 32, v88) )
                        goto LABEL_131;
                      if ( (unsigned int)a7 > 0x7FFFFFFE )
LABEL_299:
                        _assert_fail(
                          "(unsigned int) done < (unsigned int) INT_MAX",
                          "vfprintf.c",
                          2027,
                          "printf_positional");
                      if ( v88 > (unsigned int)(0x7FFFFFFF - a7) )
                        goto LABEL_130;
                      a7 += v88;
                      v88 = 0;
                    }
                    else
                    {
                      v88 = 0;
                    }
                  }
                  if ( v183 )
                  {
                    v89 = (_BYTE *)v192[5];
                    if ( (unsigned int)v89 < v192[6] )
                    {
                      v90 = v192;
                      v192[5] = v89 + 1;
                      *v89 = 45;
LABEL_179:
                      if ( a7 == 0x7FFFFFFF )
                        goto LABEL_131;
                      ++a7;
                      goto LABEL_181;
                    }
                    v166 = 45;
                  }
                  else if ( v182 )
                  {
                    v139 = (_BYTE *)v192[5];
                    if ( (unsigned int)v139 < v192[6] )
                    {
                      v90 = v192;
                      v192[5] = v139 + 1;
                      *v139 = 43;
                      goto LABEL_179;
                    }
                    v166 = 43;
                  }
                  else
                  {
                    v90 = (_DWORD *)v174;
                    if ( !v174 )
                    {
LABEL_181:
                      if ( v184 && v177 == 16 && (v168 & 1) != 0 )
                      {
                        v91 = (_BYTE *)v192[5];
                        if ( (unsigned int)v91 >= v192[6] )
                        {
                          if ( _overflow((int)v192, 48) == -1 )
                            goto LABEL_131;
                        }
                        else
                        {
                          v192[5] = v91 + 1;
                          *v91 = 48;
                        }
                        if ( a7 == 0x7FFFFFFF )
                          goto LABEL_131;
                        v92 = (unsigned __int8 *)v192[5];
                        if ( (unsigned int)v92 >= v192[6] )
                        {
                          if ( _overflow((int)v192, v179) == -1 )
                            goto LABEL_131;
                        }
                        else
                        {
                          v90 = v192;
                          v192[5] = v92 + 1;
                          *v92 = v179;
                        }
                        if ( a7 == 2147483646 )
                          goto LABEL_131;
                        a7 += 2;
                      }
                      v93 = v195 + v88;
                      if ( v93 > 0 )
                      {
                        if ( v93 != IO_padn((int)v192, 48, v93) )
                          goto LABEL_131;
                        if ( (unsigned int)a7 > 0x7FFFFFFE )
                          goto LABEL_299;
                        if ( v93 > (unsigned int)(0x7FFFFFFF - a7) )
                          goto LABEL_130;
                        a7 += v93;
                      }
                      if ( a7 < 0 )
LABEL_489:
                        _assert_fail("(size_t) done <= (size_t) INT_MAX", "vfprintf.c", 2027, "printf_positional");
                      v94 = v192[37];
                      if ( v173 <= v94 - (int)&_start___libc_IO_vtables )
                        IO_vtable_check(v90);
                      if ( v83 != (*(int (__cdecl **)(_DWORD *, unsigned int, signed int))(v94 + 28))(v192, v193, v83) )
                        goto LABEL_131;
                      if ( 0x7FFFFFFF - a7 < v83 )
                        goto LABEL_130;
LABEL_201:
                      a7 += v83;
                      goto LABEL_65;
                    }
                    v144 = (_BYTE *)v192[5];
                    if ( (unsigned int)v144 < v192[6] )
                    {
                      v90 = v192;
                      v192[5] = v144 + 1;
                      *v144 = 32;
                      goto LABEL_179;
                    }
                    v166 = 32;
                  }
                  if ( _overflow((int)v192, v166) == -1 )
                    goto LABEL_131;
                  goto LABEL_179;
                }
              }
              else
              {
                v134 = v195 - v83;
                if ( v195 - v83 < 0 )
                  v134 = v184;
                v195 = v134;
                if ( !v190 )
                {
                  v86 = v194 - (v83 + v195);
                  goto LABEL_175;
                }
              }
LABEL_101:
              if ( v183 )
              {
                v68 = (_BYTE *)v192[5];
                if ( (unsigned int)v68 < v192[6] )
                {
                  v192[5] = v68 + 1;
                  *v68 = 45;
LABEL_104:
                  if ( a7 == 0x7FFFFFFF )
                    goto LABEL_131;
                  ++a7;
                  --v194;
LABEL_106:
                  if ( v184 && v177 == 16 && (v168 & 1) != 0 )
                  {
                    v69 = (_BYTE *)v192[5];
                    if ( (unsigned int)v69 >= v192[6] )
                    {
                      if ( _overflow((int)v192, 48) == -1 )
                        goto LABEL_131;
                    }
                    else
                    {
                      v192[5] = v69 + 1;
                      *v69 = 48;
                    }
                    if ( a7 == 0x7FFFFFFF )
                      goto LABEL_131;
                    v70 = (unsigned __int8 *)v192[5];
                    if ( (unsigned int)v70 >= v192[6] )
                    {
                      if ( _overflow((int)v192, v179) == -1 )
                        goto LABEL_131;
                    }
                    else
                    {
                      v192[5] = v70 + 1;
                      *v70 = v179;
                    }
                    if ( a7 == 2147483646 )
                      goto LABEL_131;
                    a7 += 2;
                    v194 -= 2;
                  }
                  v71 = v194 - (v83 + v195);
                  if ( v195 )
                  {
                    v72 = IO_padn((int)v192, 48, v195);
                    if ( v195 != v72 )
                      goto LABEL_131;
                    if ( (unsigned int)a7 > 0x7FFFFFFE )
                      goto LABEL_299;
                    if ( v195 > (unsigned int)(0x7FFFFFFF - a7) )
                      goto LABEL_130;
                    a7 += v195;
                  }
                  if ( a7 < 0 )
                    goto LABEL_489;
                  v73 = v192[37];
                  if ( v173 <= v73 - (int)&_start___libc_IO_vtables )
                  {
                    v195 = v192[37];
                    IO_vtable_check(v54);
                    v73 = v195;
                  }
                  if ( v83 != (*(int (__cdecl **)(_DWORD *, unsigned int, signed int))(v73 + 28))(v192, v193, v83) )
                    goto LABEL_131;
                  v195 = 0x7FFFFFFF;
                  if ( 0x7FFFFFFF - a7 < v83 )
                    goto LABEL_130;
                  a7 += v83;
                  if ( (int)v71 > 0 )
                  {
                    if ( v71 != IO_padn((int)v192, 32, v71) )
                      goto LABEL_131;
                    if ( (unsigned int)a7 > 0x7FFFFFFE )
                      goto LABEL_299;
                    if ( v71 > v195 - a7 )
                      goto LABEL_130;
LABEL_292:
                    a7 += v71;
                    goto LABEL_65;
                  }
                  goto LABEL_65;
                }
                v166 = 45;
              }
              else if ( v182 )
              {
                v135 = (_BYTE *)v192[5];
                if ( (unsigned int)v135 < v192[6] )
                {
                  v192[5] = v135 + 1;
                  *v135 = 43;
                  goto LABEL_104;
                }
                v166 = 43;
              }
              else
              {
                if ( !v174 )
                  goto LABEL_106;
                v140 = (_BYTE *)v192[5];
                if ( (unsigned int)v140 < v192[6] )
                {
                  v192[5] = v140 + 1;
                  *v140 = 32;
                  goto LABEL_104;
                }
                v166 = 32;
              }
              if ( _overflow((int)v192, v166) == -1 )
                goto LABEL_131;
              goto LABEL_104;
            }
            v181 = 32;
          }
          v127 = (int *)v189;
          v128 = itoa_word(v82, (char *)v189, v177, v179 == 88);
          v54 = (int)a12;
          v193 = (unsigned int)v128;
          if ( a12 && v172 )
            v193 = group_number(v128, (int)v127, a12, a13);
          v129 = v189;
          if ( v177 == 10 && v178 )
          {
            v143 = i18n_number_rewrite((_BYTE *)v193, v189, v189);
            v177 = 10;
            v193 = (unsigned int)v143;
            v83 = v129 - (_DWORD)v143;
          }
          else
          {
            v83 = v189 - v193;
          }
          goto LABEL_168;
        }
        v130 = *(_DWORD *)(v33 + 36);
        v182 = 0;
        v174 = 0;
        v183 = 0;
        v176 = *(_QWORD *)&v188[12 * v130];
LABEL_322:
        if ( v195 < 0 )
        {
          v195 = 1;
        }
        else
        {
          if ( !v195 && !v176 )
          {
            if ( v177 == 8 && (_BYTE)v184 )
            {
              v83 = 1;
              v181 = 32;
              v131 = (char *)(v189 - 1);
              *v131 = 48;
              v193 = (unsigned int)v131;
            }
            else
            {
              v83 = 0;
              v181 = 32;
              v193 = v189;
            }
LABEL_328:
            v184 = v176 != 0;
            goto LABEL_168;
          }
          v181 = 32;
        }
        v136 = (int *)v189;
        v137 = itoa(v176, (_BYTE *)v189, v177, (_BYTE)v193 == 88);
        v193 = (unsigned int)v137;
        if ( a12 && v171 )
          v193 = group_number(v137, (int)v136, a12, a13);
        v138 = v189;
        if ( v177 == 10 && v178 )
        {
          v193 = (unsigned int)i18n_number_rewrite((_BYTE *)v193, v189, v189);
          v83 = v138 - v193;
        }
        else
        {
          v83 = v189 - v193;
        }
        goto LABEL_328;
      default:
        v96 = *(_DWORD *)(v33 + 44);
        v97 = alloca(4 * v96 + 15);
        v98 = v167;
        if ( v96 )
        {
          v99 = &v167[4 * v96];
          v100 = &v188[12 * *(_DWORD *)(v33 + 36)];
          do
          {
            *(_DWORD *)v98 = v100;
            v98 += 4;
            v100 += 12;
          }
          while ( v98 != v99 );
        }
        v101 = (_BYTE *)v192[5];
        if ( (unsigned int)v101 >= v192[6] )
        {
          if ( _overflow((int)v192, 37) == -1 )
            goto LABEL_131;
        }
        else
        {
          v192[5] = v101 + 1;
          *v101 = 37;
        }
        v102 = *(_BYTE *)(v33 + 12);
        if ( (v102 & 8) != 0 )
        {
          v103 = (_BYTE *)v192[5];
          if ( (unsigned int)v103 >= v192[6] )
          {
            if ( _overflow((int)v192, 35) == -1 )
              goto LABEL_131;
          }
          else
          {
            v192[5] = v103 + 1;
            *v103 = 35;
          }
          v102 = *(_BYTE *)(v33 + 12);
          v83 = 2;
        }
        else
        {
          v83 = 1;
        }
        if ( v102 >= 0 )
          goto LABEL_217;
        v158 = (_BYTE *)v192[5];
        if ( (unsigned int)v158 >= v192[6] )
        {
          if ( _overflow((int)v192, 39) == -1 )
            goto LABEL_131;
        }
        else
        {
          v192[5] = v158 + 1;
          *v158 = 39;
        }
        ++v83;
        v102 = *(_BYTE *)(v33 + 12);
LABEL_217:
        if ( (v102 & 0x40) != 0 )
        {
          v104 = (_BYTE *)v192[5];
          if ( (unsigned int)v104 < v192[6] )
          {
            v192[5] = v104 + 1;
            *v104 = 43;
LABEL_220:
            v102 = *(_BYTE *)(v33 + 12);
            ++v83;
            goto LABEL_221;
          }
          v166 = 43;
        }
        else
        {
          if ( (v102 & 0x10) == 0 )
          {
LABEL_221:
            if ( (v102 & 0x20) != 0 )
            {
              v105 = (_BYTE *)v192[5];
              if ( (unsigned int)v105 >= v192[6] )
              {
                if ( _overflow((int)v192, 45) == -1 )
                  goto LABEL_131;
              }
              else
              {
                v192[5] = v105 + 1;
                *v105 = 45;
              }
              ++v83;
            }
            if ( *(_DWORD *)(v33 + 16) == 48 )
            {
              v157 = (_BYTE *)v192[5];
              if ( (unsigned int)v157 >= v192[6] )
              {
                if ( _overflow((int)v192, 48) == -1 )
                  goto LABEL_131;
              }
              else
              {
                v192[5] = v157 + 1;
                *v157 = 48;
              }
              ++v83;
            }
            if ( (*(_BYTE *)(v33 + 13) & 8) != 0 )
            {
              v106 = (_BYTE *)v192[5];
              if ( (unsigned int)v106 >= v192[6] )
              {
                if ( _overflow((int)v192, 73) == -1 )
                  goto LABEL_131;
              }
              else
              {
                v192[5] = v106 + 1;
                *v106 = 73;
              }
              ++v83;
            }
            v107 = *(_DWORD *)(v33 + 4);
            if ( v107 )
            {
              v195 = (int)&v200;
              v153 = itoa_word(v107, (char *)&v200, 0xAu, 0);
              if ( (unsigned int)v153 < v195 )
              {
                v194 = v33;
                v154 = v192;
                do
                {
                  ++v153;
                  v155 = (_BYTE *)v154[5];
                  v156 = *(v153 - 1);
                  if ( (unsigned int)v155 < v154[6] )
                  {
                    v154[5] = v155 + 1;
                    *v155 = v156;
                  }
                  else if ( _overflow((int)v154, (unsigned __int8)*(v153 - 1)) == -1 )
                  {
                    goto LABEL_131;
                  }
                  if ( v83 == 0x7FFFFFFF )
                    goto LABEL_131;
                  ++v83;
                }
                while ( v153 != (char *)v195 );
                v33 = v194;
              }
            }
            if ( *(_DWORD *)v33 != -1 )
            {
              v108 = (_BYTE *)v192[5];
              if ( (unsigned int)v108 >= v192[6] )
              {
                if ( _overflow((int)v192, 46) == -1 )
                  goto LABEL_131;
              }
              else
              {
                v192[5] = v108 + 1;
                *v108 = 46;
              }
              if ( v83 == 0x7FFFFFFF )
                goto LABEL_131;
              ++v83;
              v195 = (int)&v200;
              v109 = itoa_word(*(_DWORD *)v33, (char *)&v200, 0xAu, 0);
              if ( (unsigned int)v109 < v195 )
              {
                v194 = v33;
                v110 = v192;
                do
                {
                  ++v109;
                  v111 = (_BYTE *)v110[5];
                  v112 = *(v109 - 1);
                  if ( (unsigned int)v111 < v110[6] )
                  {
                    v110[5] = v111 + 1;
                    *v111 = v112;
                  }
                  else if ( _overflow((int)v110, (unsigned __int8)*(v109 - 1)) == -1 )
                  {
                    goto LABEL_131;
                  }
                  if ( v83 == 0x7FFFFFFF )
                    goto LABEL_131;
                  ++v83;
                }
                while ( v109 != (char *)v195 );
                v33 = v194;
              }
            }
            v54 = *(_DWORD *)(v33 + 8);
            if ( v54 )
            {
              v147 = (_BYTE *)v192[5];
              if ( (unsigned int)v147 >= v192[6] )
              {
                if ( _overflow((int)v192, (unsigned __int8)v54) == -1 )
                  goto LABEL_131;
              }
              else
              {
                v192[5] = v147 + 1;
                *v147 = v54;
              }
              if ( v83 == 0x7FFFFFFF )
                goto LABEL_131;
              ++v83;
            }
            if ( (unsigned int)a7 > 0x7FFFFFFE )
              _assert_fail("(unsigned int) done < (unsigned int) INT_MAX", "vfprintf.c", 2055, "printf_positional");
            if ( v83 > (unsigned int)(0x7FFFFFFF - a7) )
            {
LABEL_130:
              __writegsdword(0xFFFFFFE8, 0x4Bu);
              goto LABEL_131;
            }
            goto LABEL_201;
          }
          v145 = (_BYTE *)v192[5];
          if ( (unsigned int)v145 < v192[6] )
          {
            v192[5] = v145 + 1;
            *v145 = 32;
            goto LABEL_220;
          }
          v166 = 32;
        }
        if ( _overflow((int)v192, v166) == -1 )
          goto LABEL_131;
        goto LABEL_220;
    }
  }
}
// 807E3D3: variable 'v54' is possibly undefined
// 807EC08: variable 'v90' is possibly undefined
// 80481C0: using guessed type int __cdecl j_strnlen(_DWORD, _DWORD);
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80515F0: using guessed type void __noreturn _libc_fatal(const char *, ...);
// 8051620: using guessed type int __fastcall IO_vtable_check(_DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 80ECD34: using guessed type int _printf_function_table;
// 80ECD94: using guessed type int _printf_arginfo_table;
// 80ECD98: using guessed type int _printf_va_arg_table;

//----- (0807F1C0) --------------------------------------------------------
int __usercall vfprintf@<eax>(long double a1@<st0>, int a2, unsigned int a3, char *a4)
{
  int v4; // eax
  int v5; // esi
  int v6; // edi
  unsigned int v7; // eax
  _DWORD *v8; // edx
  int result; // eax
  unsigned int v11; // esi
  bool v13; // zf
  char *v14; // edx
  int v15; // eax
  int v16; // edi
  char v17; // kr00_1
  int v18; // ecx
  int v19; // eax
  void *v20; // esp
  int v21; // eax
  unsigned int v22; // edi
  int v23; // edx
  int v24; // ecx
  int v25; // eax
  int v26; // eax
  unsigned int v27; // edi
  unsigned int *v28; // edi
  unsigned __int8 *v29; // eax
  int v30; // edx
  int v31; // eax
  unsigned int v32; // edi
  int v33; // edx
  _BYTE *v34; // eax
  _BYTE *v35; // eax
  int v36; // eax
  unsigned int v37; // ecx
  unsigned int v38; // esi
  unsigned int v39; // eax
  int v40; // edi
  int v41; // edx
  char *v42; // edx
  _BYTE *v43; // ecx
  char *v44; // ecx
  int v45; // eax
  unsigned int v46; // ecx
  _BYTE *v47; // eax
  _BYTE *v48; // eax
  _BYTE *v49; // eax
  unsigned int v50; // edi
  int v51; // edi
  int v52; // eax
  char v53; // di
  int v54; // eax
  int v55; // edx
  void *v56; // esp
  int v57; // edi
  void *v58; // esp
  unsigned __int8 v59; // al
  int v60; // edx
  int v61; // eax
  char *v62; // esi
  unsigned int v63; // edi
  bool v64; // zf
  int v65; // eax
  int v66; // eax
  unsigned int v67; // edi
  int v68; // eax
  _QWORD *v69; // eax
  _BYTE *v70; // eax
  _BYTE *v71; // eax
  _BYTE *v72; // eax
  char *v73; // esi
  int v74; // eax
  int v75; // eax
  unsigned int v76; // esi
  char *v77; // eax
  int v78; // eax
  _BYTE *v79; // eax
  _BYTE *v80; // eax
  unsigned __int64 v81; // rax
  int v82; // edi
  int v83; // edi
  _BYTE *v84; // eax
  _BYTE *v85; // eax
  _BYTE *v86; // eax
  int v87; // ecx
  void *v88; // esp
  int v89; // edx
  unsigned int v90; // esi
  int v91; // edi
  int v92; // eax
  int v93; // eax
  int v94; // edi
  void *v95; // esp
  _BOOL4 v96; // eax
  int v97; // eax
  _BYTE *v98; // edi
  _BYTE *v99; // esi
  char v100; // al
  _BYTE *v101; // edi
  int v102; // eax
  int v103; // eax
  int v104; // edx
  void *v105; // esp
  int v106; // eax
  int v107; // eax
  int v108; // eax
  int v109; // eax
  _BOOL4 v110; // eax
  _BOOL4 v111; // eax
  _BOOL4 v112; // eax
  int v113; // [esp-Ch] [ebp-4C4h]
  _BYTE *v114; // [esp-8h] [ebp-4C0h]
  int v115; // [esp-4h] [ebp-4BCh]
  char v116[12]; // [esp+0h] [ebp-4B8h] BYREF
  int v117; // [esp+Ch] [ebp-4ACh]
  unsigned __int64 v118; // [esp+10h] [ebp-4A8h]
  int v119; // [esp+18h] [ebp-4A0h]
  _BYTE *v120; // [esp+1Ch] [ebp-49Ch]
  int v121; // [esp+20h] [ebp-498h]
  int v122; // [esp+24h] [ebp-494h]
  int v123; // [esp+28h] [ebp-490h]
  int v124; // [esp+2Ch] [ebp-48Ch]
  int v125; // [esp+30h] [ebp-488h]
  int v126; // [esp+34h] [ebp-484h]
  int v127; // [esp+38h] [ebp-480h]
  char *v128; // [esp+3Ch] [ebp-47Ch]
  char *v129; // [esp+40h] [ebp-478h]
  int v130; // [esp+44h] [ebp-474h]
  int v131; // [esp+48h] [ebp-470h]
  int v132; // [esp+4Ch] [ebp-46Ch]
  int v133; // [esp+50h] [ebp-468h]
  unsigned __int8 *v134; // [esp+54h] [ebp-464h]
  int v135; // [esp+58h] [ebp-460h]
  unsigned int v136; // [esp+5Ch] [ebp-45Ch]
  unsigned __int8 *v137; // [esp+60h] [ebp-458h]
  signed int v138; // [esp+64h] [ebp-454h]
  int v139; // [esp+68h] [ebp-450h]
  unsigned int v140; // [esp+6Ch] [ebp-44Ch]
  unsigned __int8 *v141; // [esp+78h] [ebp-440h] BYREF
  long double *v142; // [esp+7Ch] [ebp-43Ch] BYREF
  long double *v143; // [esp+80h] [ebp-438h] BYREF
  long double *v144; // [esp+84h] [ebp-434h] BYREF
  long double v145; // [esp+88h] [ebp-430h] BYREF
  int v146[4]; // [esp+94h] [ebp-424h] BYREF
  unsigned __int8 *v147; // [esp+A4h] [ebp-414h] BYREF
  int v148; // [esp+A8h] [ebp-410h]
  int v149; // [esp+ACh] [ebp-40Ch]
  int v150; // [esp+B0h] [ebp-408h]
  int v151; // [esp+B4h] [ebp-404h]
  char v152[1000]; // [esp+B8h] [ebp-400h] BYREF
  char v153[24]; // [esp+4A0h] [ebp-18h] BYREF

  v138 = __readgsdword(0xFFFFFFE8);
  v4 = *(_DWORD *)(a2 + 104);
  if ( v4 )
  {
    if ( v4 != -1 )
      return -1;
  }
  else
  {
    *(_DWORD *)(a2 + 104) = -1;
  }
  v5 = *(_DWORD *)a2;
  if ( (*(_DWORD *)a2 & 8) != 0 )
  {
    v140 = -1;
    *(_DWORD *)a2 = v5 | 0x20;
    __writegsdword(0xFFFFFFE8, 9u);
    return v140;
  }
  if ( !a3 )
  {
    v140 = -1;
    __writegsdword(0xFFFFFFE8, 0x16u);
    return v140;
  }
  v6 = *(_DWORD *)a2 & 2;
  if ( (v5 & 2) != 0 )
  {
    result = buffered_vfprintf((_DWORD *)a2, a3, (int)a4);
    v140 = result;
    return result;
  }
  v142 = (long double *)a4;
  v137 = (unsigned __int8 *)strchrnul((unsigned int *)a3, 37);
  v141 = v137;
  v139 = v5 & 0x8000;
  if ( (v5 & 0x8000) != 0 )
  {
    v139 = 0;
  }
  else
  {
    v146[0] = (int)funlockfile;
    v146[1] = a2;
    _EDX = *(_DWORD *)(a2 + 72);
    v11 = __readgsdword(8u);
    if ( v11 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v13 = __readgsdword(0xCu) == 0;
      if ( !v13 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v13 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
      _EDX = *(_DWORD *)(a2 + 72);
      *(_DWORD *)(_EDX + 8) = v11;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v7 = *(_DWORD *)(a2 + 148);
  v136 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= v7 - (unsigned int)&_start___libc_IO_vtables )
  {
    v140 = v7;
    IO_vtable_check((char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables);
    v7 = v140;
  }
  v140 = (unsigned int)&v137[-a3];
  if ( &v137[-a3] != (unsigned __int8 *)(*(int (__cdecl **)(int, unsigned int, unsigned __int8 *))(v7 + 28))(
                                          a2,
                                          a3,
                                          &v137[-a3]) )
    goto LABEL_11;
  v14 = (char *)v141;
  if ( *v141 )
  {
    if ( _printf_function_table || _printf_modifier_table || _printf_va_arg_table )
    {
      v119 = 0;
      v123 = -1;
      v120 = 0;
    }
    else
    {
      v119 = 0;
      v121 = 0;
      v123 = -1;
      v120 = 0;
      while ( 2 )
      {
        v141 = (unsigned __int8 *)(v14 + 1);
        v15 = (unsigned __int8)v14[1];
        LOBYTE(v14) = v15 - 32;
        LOBYTE(v134) = v15;
        v16 = v15;
LABEL_38:
        v17 = (char)v14;
        v14 = v153;
        v117 = 0;
        v132 = 0;
        v131 = 0;
        v18 = 0;
        LODWORD(v118) = 0;
        v125 = 0;
        v122 = 0;
        v127 = 0;
        v130 = 0;
        v126 = 0;
        v124 = 0;
        LOBYTE(v129) = 32;
        v133 = -1;
        v128 = v153;
        v135 = 0;
        switch ( v17 )
        {
          case 0:
LABEL_150:
            while ( 2 )
            {
              LOBYTE(v134) = *++v141;
              v126 = 1;
              switch ( (char)v134 )
              {
                case ' ':
                  continue;
                case '#':
                  goto LABEL_153;
                case '%':
                  goto LABEL_87;
                case '\'':
                  goto LABEL_157;
                case '*':
                  goto LABEL_160;
                case '+':
                  goto LABEL_151;
                case '-':
                  goto LABEL_152;
                case '.':
                  goto LABEL_185;
                case '0':
                  goto LABEL_154;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  goto LABEL_176;
                case 'A':
                case 'a':
                  goto LABEL_214;
                case 'C':
                  goto LABEL_43;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_231;
                case 'I':
                  goto LABEL_159;
                case 'L':
                case 'j':
                case 'q':
                  goto LABEL_39;
                case 'S':
                case 's':
                  goto LABEL_188;
                case 'X':
                case 'x':
                  goto LABEL_222;
                case 'Z':
                case 't':
                case 'z':
                  goto LABEL_40;
                case 'c':
                  goto LABEL_71;
                case 'd':
                case 'i':
                  goto LABEL_91;
                case 'h':
                  goto LABEL_183;
                case 'l':
                  goto LABEL_182;
                case 'm':
                  goto LABEL_230;
                case 'n':
                  goto LABEL_223;
                case 'o':
                  goto LABEL_149;
                case 'p':
                  goto LABEL_220;
                case 'u':
                  goto LABEL_143;
                default:
                  goto LABEL_172;
              }
            }
          case 1:
          case 2:
          case 4:
          case 6:
          case 8:
          case 9:
          case 12:
          case 15:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
          case 32:
          case 34:
          case 36:
          case 40:
          case 42:
          case 43:
          case 45:
          case 46:
          case 47:
          case 48:
          case 49:
          case 50:
          case 52:
          case 53:
          case 54:
          case 55:
          case 57:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 66:
          case 75:
          case 82:
          case 86:
          case 87:
          case 89:
LABEL_172:
            if ( (_BYTE)v134 )
              goto LABEL_332;
            __writegsdword(0xFFFFFFE8, 0x16u);
            goto LABEL_174;
          case 3:
LABEL_153:
            while ( 2 )
            {
              LOBYTE(v134) = *++v141;
              v16 = (unsigned __int8)v134;
              v124 = 1;
              switch ( (char)v134 )
              {
                case ' ':
                  goto LABEL_150;
                case '#':
                  continue;
                case '%':
                  goto LABEL_87;
                case '\'':
                  goto LABEL_157;
                case '*':
                  goto LABEL_160;
                case '+':
                  goto LABEL_151;
                case '-':
                  goto LABEL_152;
                case '.':
                  goto LABEL_185;
                case '0':
                  goto LABEL_154;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  goto LABEL_176;
                case 'A':
                case 'a':
                  goto LABEL_214;
                case 'C':
                  goto LABEL_43;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_231;
                case 'I':
                  goto LABEL_159;
                case 'L':
                case 'j':
                case 'q':
                  goto LABEL_39;
                case 'S':
                case 's':
                  goto LABEL_188;
                case 'X':
                case 'x':
                  goto LABEL_222;
                case 'Z':
                case 't':
                case 'z':
                  goto LABEL_40;
                case 'c':
                  goto LABEL_71;
                case 'd':
                case 'i':
                  goto LABEL_91;
                case 'h':
                  goto LABEL_183;
                case 'l':
                  goto LABEL_182;
                case 'm':
                  goto LABEL_230;
                case 'n':
                  goto LABEL_223;
                case 'o':
                  goto LABEL_149;
                case 'p':
                  goto LABEL_220;
                case 'u':
                  goto LABEL_143;
                default:
                  goto LABEL_172;
              }
            }
          case 5:
LABEL_87:
            v35 = *(_BYTE **)(a2 + 20);
            if ( (unsigned int)v35 >= *(_DWORD *)(a2 + 24) )
            {
              v115 = v16;
              v114 = (_BYTE *)v16;
              if ( _overflow(a2, 37) == -1 )
                goto LABEL_174;
            }
            else
            {
              *(_DWORD *)(a2 + 20) = v35 + 1;
              *v35 = 37;
            }
            if ( v140 == 0x7FFFFFFF )
              goto LABEL_174;
            ++v140;
            goto LABEL_62;
          case 7:
LABEL_157:
            while ( 2 )
            {
              if ( v123 == -1 )
              {
                v97 = *(_DWORD *)__readgsdword(0xFFFFFFE4);
                v98 = *(_BYTE **)(v97 + 40);
                v99 = *(_BYTE **)(v97 + 44);
                v100 = *v99;
                v120 = v98;
                if ( !v100 || v100 == 127 )
                {
                  v123 = 0;
                }
                else
                {
                  v13 = *v98 == 0;
                  v101 = 0;
                  if ( !v13 )
                    v101 = v99;
                  v123 = (int)v101;
                }
              }
              LOBYTE(v134) = *++v141;
              v16 = (unsigned __int8)v134;
              v122 = 1;
              switch ( (char)v134 )
              {
                case ' ':
                  goto LABEL_150;
                case '#':
                  goto LABEL_153;
                case '%':
                  goto LABEL_87;
                case '\'':
                  continue;
                case '*':
                  goto LABEL_160;
                case '+':
                  goto LABEL_151;
                case '-':
                  goto LABEL_152;
                case '.':
                  goto LABEL_185;
                case '0':
                  goto LABEL_154;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  goto LABEL_176;
                case 'A':
                case 'a':
                  goto LABEL_214;
                case 'C':
                  goto LABEL_43;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_231;
                case 'I':
                  goto LABEL_159;
                case 'L':
                case 'j':
                case 'q':
                  goto LABEL_39;
                case 'S':
                case 's':
                  goto LABEL_188;
                case 'X':
                case 'x':
                  goto LABEL_222;
                case 'Z':
                case 't':
                case 'z':
                  goto LABEL_40;
                case 'c':
                  goto LABEL_71;
                case 'd':
                case 'i':
                  goto LABEL_91;
                case 'h':
                  goto LABEL_183;
                case 'l':
                  goto LABEL_182;
                case 'm':
                  goto LABEL_230;
                case 'n':
                  goto LABEL_223;
                case 'o':
                  goto LABEL_149;
                case 'p':
                  goto LABEL_220;
                case 'u':
                  goto LABEL_143;
                default:
                  goto LABEL_172;
              }
            }
          case 10:
LABEL_160:
            v147 = ++v141;
            if ( (unsigned int)*v141 - 48 > 9 )
              goto LABEL_164;
            v134 = 0;
            v54 = read_int(&v147);
            v18 = (int)v134;
            if ( v54 == -1 )
              goto LABEL_283;
            if ( v54 && *v147 == 36 )
              goto LABEL_332;
LABEL_164:
            v55 = (int)(a4 + 4);
            v132 = *(_DWORD *)a4;
            if ( v132 < 0 )
            {
              v132 = -v132;
              LOBYTE(v129) = 32;
              v130 = 1;
            }
            if ( v132 > 2147483614 )
              goto LABEL_283;
            if ( v132 <= 967 )
              goto LABEL_170;
            v16 = v132 + 32;
            if ( (unsigned int)(v132 + 32) <= 0x1000
              || (v128 = (char *)v18,
                  v134 = (unsigned __int8 *)(a4 + 4),
                  v110 = _libc_alloca_cutoff(v132 + 32),
                  v55 = (int)v134,
                  v18 = (int)v128,
                  v110) )
            {
              v56 = alloca(v16 + 15);
              v128 = &v116[v16];
LABEL_170:
              LOBYTE(v134) = *v141;
              a4 = (char *)v55;
              switch ( (char)v134 )
              {
                case ' ':
                case '!':
                case '"':
                case '#':
                case '$':
                case '&':
                case '\'':
                case '(':
                case ')':
                case '*':
                case '+':
                case ',':
                case '-':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'B':
                case 'D':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'Y':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case '`':
                case 'b':
                case 'k':
                case 'r':
                case 'v':
                case 'w':
                case 'y':
                  goto LABEL_172;
                case '%':
                  goto LABEL_87;
                case '.':
                  goto LABEL_185;
                case 'A':
                case 'a':
                  goto LABEL_214;
                case 'C':
                  goto LABEL_43;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_231;
                case 'L':
                case 'j':
                case 'q':
                  goto LABEL_39;
                case 'S':
                case 's':
                  goto LABEL_188;
                case 'X':
                case 'x':
                  goto LABEL_222;
                case 'Z':
                case 't':
                case 'z':
                  goto LABEL_40;
                case 'c':
                  goto LABEL_71;
                case 'd':
                case 'i':
                  goto LABEL_91;
                case 'h':
                  goto LABEL_183;
                case 'l':
                  goto LABEL_182;
                case 'm':
                  goto LABEL_230;
                case 'n':
                  goto LABEL_223;
                case 'o':
                  goto LABEL_149;
                case 'p':
                  goto LABEL_220;
                case 'u':
                  goto LABEL_143;
                default:
                  a4 = (char *)v55;
                  goto LABEL_172;
              }
            }
            v135 = malloc(v16);
            v55 = (int)v134;
            v18 = (int)v128;
            if ( v135 )
            {
              v16 += v135;
              v128 = (char *)v16;
              goto LABEL_170;
            }
            goto LABEL_11;
          case 11:
LABEL_151:
            while ( 2 )
            {
              LOBYTE(v134) = *++v141;
              v16 = (unsigned __int8)v134;
              v127 = 1;
              switch ( (char)v134 )
              {
                case ' ':
                  goto LABEL_150;
                case '#':
                  goto LABEL_153;
                case '%':
                  goto LABEL_87;
                case '\'':
                  goto LABEL_157;
                case '*':
                  goto LABEL_160;
                case '+':
                  continue;
                case '-':
                  goto LABEL_152;
                case '.':
                  goto LABEL_185;
                case '0':
                  goto LABEL_154;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  goto LABEL_176;
                case 'A':
                case 'a':
                  goto LABEL_214;
                case 'C':
                  goto LABEL_43;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_231;
                case 'I':
                  goto LABEL_159;
                case 'L':
                case 'j':
                case 'q':
                  goto LABEL_39;
                case 'S':
                case 's':
                  goto LABEL_188;
                case 'X':
                case 'x':
                  goto LABEL_222;
                case 'Z':
                case 't':
                case 'z':
                  goto LABEL_40;
                case 'c':
                  goto LABEL_71;
                case 'd':
                case 'i':
                  goto LABEL_91;
                case 'h':
                  goto LABEL_183;
                case 'l':
                  goto LABEL_182;
                case 'm':
                  goto LABEL_230;
                case 'n':
                  goto LABEL_223;
                case 'o':
                  goto LABEL_149;
                case 'p':
                  goto LABEL_220;
                case 'u':
                  goto LABEL_143;
                default:
                  goto LABEL_172;
              }
            }
          case 13:
LABEL_152:
            while ( 2 )
            {
              LOBYTE(v134) = *++v141;
              v16 = (unsigned __int8)v134;
              LOBYTE(v129) = 32;
              v130 = 1;
              switch ( (char)v134 )
              {
                case ' ':
                  goto LABEL_150;
                case '#':
                  goto LABEL_153;
                case '%':
                  goto LABEL_87;
                case '\'':
                  goto LABEL_157;
                case '*':
                  goto LABEL_160;
                case '+':
                  goto LABEL_151;
                case '-':
                  continue;
                case '.':
                  goto LABEL_185;
                case '0':
                  goto LABEL_154;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  goto LABEL_176;
                case 'A':
                case 'a':
                  goto LABEL_214;
                case 'C':
                  goto LABEL_43;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_231;
                case 'I':
                  goto LABEL_159;
                case 'L':
                case 'j':
                case 'q':
                  goto LABEL_39;
                case 'S':
                case 's':
                  goto LABEL_188;
                case 'X':
                case 'x':
                  goto LABEL_222;
                case 'Z':
                case 't':
                case 'z':
                  goto LABEL_40;
                case 'c':
                  goto LABEL_71;
                case 'd':
                case 'i':
                  goto LABEL_91;
                case 'h':
                  goto LABEL_183;
                case 'l':
                  goto LABEL_182;
                case 'm':
                  goto LABEL_230;
                case 'n':
                  goto LABEL_223;
                case 'o':
                  goto LABEL_149;
                case 'p':
                  goto LABEL_220;
                case 'u':
                  goto LABEL_143;
                default:
                  goto LABEL_172;
              }
            }
          case 14:
LABEL_185:
            v60 = (int)v141++;
            v61 = *v141;
            if ( (_BYTE)v61 != 42 )
            {
              v133 = 0;
              if ( (unsigned int)(unsigned __int8)v61 - 48 > 9 )
              {
LABEL_187:
                v16 = v61;
                LOBYTE(v134) = v61;
                switch ( (char)v61 )
                {
                  case '%':
                    goto LABEL_87;
                  case 'A':
                  case 'a':
                    goto LABEL_214;
                  case 'C':
                    goto LABEL_43;
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'e':
                  case 'f':
                  case 'g':
                    goto LABEL_231;
                  case 'L':
                  case 'j':
                  case 'q':
                    goto LABEL_39;
                  case 'S':
                  case 's':
                    goto LABEL_188;
                  case 'X':
                  case 'x':
                    goto LABEL_222;
                  case 'Z':
                  case 't':
                  case 'z':
                    goto LABEL_40;
                  case 'c':
                    goto LABEL_71;
                  case 'd':
                  case 'i':
                    goto LABEL_91;
                  case 'h':
                    goto LABEL_183;
                  case 'l':
                    goto LABEL_182;
                  case 'm':
                    goto LABEL_230;
                  case 'n':
                    goto LABEL_223;
                  case 'o':
                    goto LABEL_149;
                  case 'p':
                    goto LABEL_220;
                  case 'u':
                    goto LABEL_143;
                  default:
                    goto LABEL_172;
                }
              }
              v134 = (unsigned __int8 *)v18;
              v133 = read_int(&v141);
              v18 = (int)v134;
              if ( v133 == -1 )
                goto LABEL_283;
LABEL_354:
              if ( v132 >= v133 || v133 <= 968 )
                goto LABEL_367;
              if ( v135 )
              {
                v134 = (unsigned __int8 *)v18;
                free(v135);
                v18 = (int)v134;
              }
              if ( v133 > 2147483614 )
              {
LABEL_290:
                __writegsdword(0xFFFFFFE8, 0x4Bu);
              }
              else
              {
                v94 = v133 + 32;
                if ( (unsigned int)(v133 + 32) <= 0x1000
                  || (v135 = v18, v96 = _libc_alloca_cutoff(v133 + 32), v18 = v135, v96) )
                {
                  v135 = 0;
                  v95 = alloca(v94 + 15);
                  v128 = &v116[v94];
                  v61 = *v141;
                  goto LABEL_187;
                }
                v134 = (unsigned __int8 *)v135;
                v135 = malloc(v94);
                v18 = (int)v134;
                if ( v135 )
                {
                  v128 = (char *)(v135 + v94);
LABEL_367:
                  v61 = *v141;
                  goto LABEL_187;
                }
              }
LABEL_11:
              v140 = -1;
              goto LABEL_12;
            }
            v141 = (unsigned __int8 *)(v60 + 2);
            v147 = (unsigned __int8 *)(v60 + 2);
            if ( (unsigned int)*(unsigned __int8 *)(v60 + 2) - 48 > 9 )
              goto LABEL_351;
            v134 = (unsigned __int8 *)v18;
            v92 = read_int(&v147);
            v18 = (int)v134;
            if ( v92 == -1 )
            {
LABEL_283:
              __writegsdword(0xFFFFFFE8, 0x4Bu);
LABEL_174:
              if ( v135 )
                free(v135);
              goto LABEL_11;
            }
            if ( !v92 || *v147 != 36 )
            {
LABEL_351:
              v93 = -1;
              if ( *(int *)a4 >= 0 )
                v93 = *(_DWORD *)a4;
              v133 = v93;
              a4 += 4;
              goto LABEL_354;
            }
LABEL_332:
            v6 = v121;
            if ( v135 )
              free(v135);
            break;
          case 16:
LABEL_154:
            while ( 2 )
            {
              v53 = (char)v129;
              if ( !v130 )
                v53 = 48;
              LOBYTE(v129) = v53;
              LOBYTE(v134) = *++v141;
              v16 = (unsigned __int8)v134;
              switch ( (char)v134 )
              {
                case ' ':
                  goto LABEL_150;
                case '#':
                  goto LABEL_153;
                case '%':
                  goto LABEL_87;
                case '\'':
                  goto LABEL_157;
                case '*':
                  goto LABEL_160;
                case '+':
                  goto LABEL_151;
                case '-':
                  goto LABEL_152;
                case '.':
                  goto LABEL_185;
                case '0':
                  continue;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  goto LABEL_176;
                case 'A':
                case 'a':
                  goto LABEL_214;
                case 'C':
                  goto LABEL_43;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_231;
                case 'I':
                  goto LABEL_159;
                case 'L':
                case 'j':
                case 'q':
                  goto LABEL_39;
                case 'S':
                case 's':
                  goto LABEL_188;
                case 'X':
                case 'x':
                  goto LABEL_222;
                case 'Z':
                case 't':
                case 'z':
                  goto LABEL_40;
                case 'c':
                  goto LABEL_71;
                case 'd':
                case 'i':
                  goto LABEL_91;
                case 'h':
                  goto LABEL_183;
                case 'l':
                  goto LABEL_182;
                case 'm':
                  goto LABEL_230;
                case 'n':
                  goto LABEL_223;
                case 'o':
                  goto LABEL_149;
                case 'p':
                  goto LABEL_220;
                case 'u':
                  goto LABEL_143;
                default:
                  goto LABEL_172;
              }
            }
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
LABEL_176:
            v134 = 0;
            v132 = read_int(&v141);
            v18 = (int)v134;
            if ( (unsigned int)v132 > 0x7FFFFFDE )
              goto LABEL_283;
            if ( v132 <= 967 )
              goto LABEL_180;
            v57 = v132 + 32;
            if ( (unsigned int)(v132 + 32) <= 0x1000 || (v111 = _libc_alloca_cutoff(v132 + 32), v18 = (int)v134, v111) )
            {
              v58 = alloca(v57 + 15);
              v128 = &v116[v57];
            }
            else
            {
              v135 = malloc(v57);
              v18 = (int)v134;
              if ( !v135 )
                goto LABEL_11;
              v128 = (char *)(v135 + v57);
            }
LABEL_180:
            v59 = *v141;
            if ( *v141 != 36 )
            {
              LOBYTE(v134) = *v141;
              v16 = (unsigned __int8)v134;
              switch ( v59 )
              {
                case '%':
                  goto LABEL_87;
                case '.':
                  goto LABEL_185;
                case 'A':
                case 'a':
                  goto LABEL_214;
                case 'C':
                  goto LABEL_43;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_231;
                case 'L':
                case 'j':
                case 'q':
                  goto LABEL_39;
                case 'S':
                case 's':
                  goto LABEL_188;
                case 'X':
                case 'x':
                  goto LABEL_222;
                case 'Z':
                case 't':
                case 'z':
                  goto LABEL_40;
                case 'c':
                  goto LABEL_71;
                case 'd':
                case 'i':
                  goto LABEL_91;
                case 'h':
                  goto LABEL_183;
                case 'l':
                  goto LABEL_182;
                case 'm':
                  goto LABEL_230;
                case 'n':
                  goto LABEL_223;
                case 'o':
                  goto LABEL_149;
                case 'p':
                  goto LABEL_220;
                case 'u':
                  goto LABEL_143;
                default:
                  goto LABEL_172;
              }
            }
            goto LABEL_332;
          case 33:
          case 65:
LABEL_214:
            v147 = (unsigned __int8 *)v133;
            v149 = (char)v134;
            v148 = v132;
            v150 = (unsigned __int8)(((_BYTE)v127 << 6) | (32 * v130) | (16 * v126) | (8 * v124) | (4 * v18) | v125 | (2 * v118) | ((_BYTE)v122 << 7));
            v151 = (unsigned __int8)v129;
            if ( v125 )
            {
              a1 = *(long double *)a4;
              a4 += 12;
              v145 = a1;
            }
            else
            {
              a1 = *(double *)a4;
              a4 += 8;
              *(double *)&v145 = a1;
            }
            v144 = &v145;
            v68 = _printf_fphex((_DWORD *)a2, (int)&v147, (double **)&v144);
            if ( v68 >= 0 )
              goto LABEL_217;
            goto LABEL_174;
          case 35:
            goto LABEL_43;
          case 37:
          case 38:
          case 39:
          case 69:
          case 70:
          case 71:
LABEL_231:
            v147 = (unsigned __int8 *)v133;
            v149 = (char)v134;
            v148 = v132;
            v150 = (unsigned __int8)(((_BYTE)v127 << 6) | (32 * v130) | (16 * v126) | (8 * v124) | (4 * v18) | v125 | (2 * v118) | ((_BYTE)v122 << 7));
            BYTE1(v150) = 8 * v117;
            v151 = (unsigned __int8)v129;
            if ( v125 )
            {
              a1 = *(long double *)a4;
              a4 += 12;
              v145 = a1;
            }
            else
            {
              a1 = *(double *)a4;
              a4 += 8;
              *(double *)&v145 = a1;
            }
            v143 = &v145;
            v68 = _printf_fp((_DWORD *)a2, (int)&v147, &v143);
            if ( v68 < 0 )
              goto LABEL_174;
LABEL_217:
            if ( v140 > 0x7FFFFFFE )
              goto LABEL_419;
            if ( v68 > 0x7FFFFFFF - v140 )
              goto LABEL_283;
            v140 += v68;
            goto LABEL_62;
          case 41:
LABEL_159:
            while ( 2 )
            {
              LOBYTE(v134) = *++v141;
              v16 = (unsigned __int8)v134;
              v117 = 1;
              switch ( (char)v134 )
              {
                case ' ':
                  goto LABEL_150;
                case '#':
                  goto LABEL_153;
                case '%':
                  goto LABEL_87;
                case '\'':
                  goto LABEL_157;
                case '*':
                  goto LABEL_160;
                case '+':
                  goto LABEL_151;
                case '-':
                  goto LABEL_152;
                case '.':
                  goto LABEL_185;
                case '0':
                  goto LABEL_154;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  goto LABEL_176;
                case 'A':
                case 'a':
                  goto LABEL_214;
                case 'C':
                  goto LABEL_43;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_231;
                case 'I':
                  continue;
                case 'L':
                case 'j':
                case 'q':
                  goto LABEL_39;
                case 'S':
                case 's':
                  goto LABEL_188;
                case 'X':
                case 'x':
                  goto LABEL_222;
                case 'Z':
                case 't':
                case 'z':
                  goto LABEL_40;
                case 'c':
                  goto LABEL_71;
                case 'd':
                case 'i':
                  goto LABEL_91;
                case 'h':
                  goto LABEL_183;
                case 'l':
                  goto LABEL_182;
                case 'm':
                  goto LABEL_230;
                case 'n':
                  goto LABEL_223;
                case 'o':
                  goto LABEL_149;
                case 'p':
                  goto LABEL_220;
                case 'u':
                  goto LABEL_143;
                default:
                  goto LABEL_172;
              }
            }
          case 44:
          case 74:
          case 81:
LABEL_39:
            LOBYTE(v134) = *++v141;
            v16 = (unsigned __int8)v134;
            v18 = 1;
            v125 = 1;
            switch ( (char)v134 )
            {
              case '%':
                goto LABEL_87;
              case 'A':
              case 'a':
                goto LABEL_214;
              case 'C':
                goto LABEL_43;
              case 'E':
              case 'F':
              case 'G':
              case 'e':
              case 'f':
              case 'g':
                goto LABEL_231;
              case 'S':
              case 's':
                goto LABEL_188;
              case 'X':
              case 'x':
                goto LABEL_222;
              case 'c':
                goto LABEL_71;
              case 'd':
              case 'i':
                goto LABEL_91;
              case 'm':
                goto LABEL_230;
              case 'n':
                goto LABEL_223;
              case 'o':
                goto LABEL_149;
              case 'p':
                goto LABEL_220;
              case 'u':
                goto LABEL_143;
              default:
                goto LABEL_172;
            }
          case 51:
          case 83:
LABEL_188:
            v62 = *(char **)a4;
            a4 += 4;
            goto LABEL_189;
          case 56:
          case 88:
LABEL_222:
            v38 = 16;
            goto LABEL_144;
          case 58:
          case 84:
          case 90:
LABEL_40:
            LOBYTE(v134) = *++v141;
            v16 = (unsigned __int8)v134;
            v18 = 0;
            v125 = 0;
            switch ( (char)v134 )
            {
              case '%':
                goto LABEL_87;
              case 'A':
              case 'a':
                goto LABEL_214;
              case 'C':
                goto LABEL_43;
              case 'E':
              case 'F':
              case 'G':
              case 'e':
              case 'f':
              case 'g':
                goto LABEL_231;
              case 'S':
              case 's':
                goto LABEL_188;
              case 'X':
              case 'x':
                goto LABEL_222;
              case 'c':
                goto LABEL_71;
              case 'd':
              case 'i':
                goto LABEL_91;
              case 'm':
                goto LABEL_230;
              case 'n':
                goto LABEL_223;
              case 'o':
                goto LABEL_149;
              case 'p':
                goto LABEL_220;
              case 'u':
                goto LABEL_143;
              default:
                goto LABEL_172;
            }
          case 67:
LABEL_71:
            if ( v18 )
            {
LABEL_43:
              v129 = a4 + 4;
              v19 = *(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFD8) + 88);
              v147 = 0;
              v148 = 0;
              v20 = alloca(v19);
              v113 = *(_DWORD *)a4;
              v131 = (int)v116;
              v21 = wcrtomb(v116, v113, &v147);
              v22 = v21;
              if ( v21 == -1 )
                goto LABEL_174;
              v23 = v132 - v21;
              v133 = v132 - v21;
              LOBYTE(v134) = v132 - v21 > 0;
              v24 = v131;
              if ( !v130 && (_BYTE)v134 )
              {
                v132 = v131;
                v25 = IO_padn(a2, 32, v23);
                if ( v133 != v25 )
                  goto LABEL_174;
                if ( v140 > 0x7FFFFFFE )
                  goto LABEL_423;
                v24 = v132;
                if ( v133 > 0x7FFFFFFF - v140 )
                  goto LABEL_338;
                v140 += v133;
              }
              if ( (v140 & 0x80000000) != 0 )
                goto LABEL_421;
              v26 = *(_DWORD *)(a2 + 148);
              if ( v136 <= v26 - (int)&_start___libc_IO_vtables )
              {
                v131 = v24;
                v132 = v26;
                IO_vtable_check(v24);
                v24 = v131;
                v26 = v132;
              }
              if ( v22 != (*(int (__cdecl **)(int, int, unsigned int))(v26 + 28))(a2, v24, v22) )
                goto LABEL_174;
              if ( v22 > 0x7FFFFFFF - v140 )
                goto LABEL_338;
              v140 += v22;
              v132 = 0x7FFFFFFF;
              if ( v130 && (_BYTE)v134 )
              {
                v27 = v133;
                if ( v27 != IO_padn(a2, 32, v133) )
                  goto LABEL_174;
                if ( v140 > 0x7FFFFFFE )
                  goto LABEL_423;
                if ( v27 > v132 - v140 )
                {
LABEL_338:
                  __writegsdword(0xFFFFFFE8, 0x4Bu);
                  goto LABEL_174;
                }
                v140 += v133;
              }
              a4 = v129;
            }
            else
            {
              v32 = v132 - 1;
              LOBYTE(v134) = v132 - 1 > 0;
              if ( !v130 && v132 - 1 > 0 )
              {
                if ( v32 != IO_padn(a2, 32, v132 - 1) )
                  goto LABEL_174;
                if ( v140 > 0x7FFFFFFE )
                  goto LABEL_423;
                if ( v32 > 0x7FFFFFFF - v140 )
                  goto LABEL_283;
                v140 += v32;
              }
              v33 = *(_DWORD *)a4;
              v34 = *(_BYTE **)(a2 + 20);
              if ( (unsigned int)v34 >= *(_DWORD *)(a2 + 24) )
              {
                v115 = *(_DWORD *)(a2 + 20);
                v114 = v34;
                if ( _overflow(a2, (unsigned __int8)v33) == -1 )
                  goto LABEL_174;
              }
              else
              {
                *(_DWORD *)(a2 + 20) = v34 + 1;
                *v34 = v33;
              }
              if ( v140 == 0x7FFFFFFF )
                goto LABEL_174;
              ++v140;
              if ( v130 && (_BYTE)v134 )
              {
                v115 = v130;
                if ( v32 != IO_padn(a2, 32, v32) )
                  goto LABEL_174;
                if ( v140 > 0x7FFFFFFE )
                  goto LABEL_423;
                if ( v32 > 0x7FFFFFFF - v140 )
                  goto LABEL_283;
                v140 += v32;
                a4 += 4;
              }
              else
              {
                a4 += 4;
              }
            }
            goto LABEL_62;
          case 68:
          case 73:
LABEL_91:
            if ( v125 )
            {
              v89 = *((_DWORD *)a4 + 1);
              v90 = *(_DWORD *)a4;
              v131 = (unsigned int)v89 >> 31;
              v91 = v89;
              v89 >>= 31;
              v118 = __PAIR64__(v89 ^ (unsigned int)v91, v89 ^ v90);
              v38 = 10;
              v118 -= __PAIR64__(v89, v89);
              a4 += 8;
              goto LABEL_294;
            }
            if ( v131 )
            {
              v36 = *a4;
              a4 += 4;
            }
            else
            {
              if ( (_DWORD)v118 )
                v36 = *(__int16 *)a4;
              else
                v36 = *(_DWORD *)a4;
              a4 += 4;
            }
            v37 = v36;
            v38 = 10;
            v39 = abs32(v36);
            v131 = v37 >> 31;
            LODWORD(v118) = v39;
            goto LABEL_97;
          case 72:
LABEL_183:
            LOBYTE(v134) = *++v141;
            v16 = (unsigned __int8)v134;
            LODWORD(v118) = 1;
            switch ( (char)v134 )
            {
              case '%':
                goto LABEL_87;
              case 'X':
              case 'x':
                goto LABEL_222;
              case 'd':
              case 'i':
                goto LABEL_91;
              case 'h':
                LOBYTE(v134) = *++v141;
                v16 = (unsigned __int8)v134;
                LODWORD(v118) = 0;
                v131 = 1;
                switch ( (char)v134 )
                {
                  case '%':
                    goto LABEL_87;
                  case 'A':
                  case 'a':
                    goto LABEL_214;
                  case 'C':
                    goto LABEL_43;
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'e':
                  case 'f':
                  case 'g':
                    goto LABEL_231;
                  case 'S':
                  case 's':
                    goto LABEL_188;
                  case 'X':
                  case 'x':
                    goto LABEL_222;
                  case 'c':
                    goto LABEL_71;
                  case 'd':
                  case 'i':
                    goto LABEL_91;
                  case 'm':
                    goto LABEL_230;
                  case 'n':
                    goto LABEL_223;
                  case 'o':
                    goto LABEL_149;
                  case 'p':
                    goto LABEL_220;
                  case 'u':
                    goto LABEL_143;
                  default:
                    goto LABEL_172;
                }
              case 'n':
                goto LABEL_223;
              case 'o':
                goto LABEL_149;
              case 'u':
                goto LABEL_143;
              default:
                goto LABEL_172;
            }
          case 76:
LABEL_182:
            LOBYTE(v134) = *++v141;
            v16 = (unsigned __int8)v134;
            v18 = 1;
            switch ( (char)v134 )
            {
              case '%':
                goto LABEL_87;
              case 'A':
              case 'a':
                goto LABEL_214;
              case 'C':
                goto LABEL_43;
              case 'E':
              case 'F':
              case 'G':
              case 'e':
              case 'f':
              case 'g':
                goto LABEL_231;
              case 'S':
              case 's':
                goto LABEL_188;
              case 'X':
              case 'x':
                goto LABEL_222;
              case 'c':
                goto LABEL_71;
              case 'd':
              case 'i':
                goto LABEL_91;
              case 'l':
                goto LABEL_39;
              case 'm':
                goto LABEL_230;
              case 'n':
                goto LABEL_223;
              case 'o':
                goto LABEL_149;
              case 'p':
                goto LABEL_220;
              case 'u':
                goto LABEL_143;
              default:
                goto LABEL_172;
            }
          case 77:
LABEL_230:
            v62 = (char *)strerror_r(a1, v138, v152, 0x3E8u);
            v18 = 0;
LABEL_189:
            if ( v62 )
            {
              if ( (_BYTE)v134 == 83 || v18 )
                goto LABEL_327;
              if ( v133 != -1 )
                goto LABEL_193;
              v63 = strlen(v62);
              v134 = 0;
            }
            else
            {
              v134 = 0;
              if ( v133 == -1 || v133 > 5 )
              {
                v63 = 6;
                v62 = "(null)";
              }
              else
              {
                v63 = 0;
                v62 = (char *)&unk_80CFAB1;
              }
            }
            goto LABEL_194;
          case 78:
LABEL_223:
            if ( (*(_BYTE *)(a2 + 60) & 4) != 0 && !v119 )
            {
              v115 = 0;
              v114 = 0;
              v119 = _readonly_area(a3, strlen((const char *)a3) + 1);
              if ( v119 < 0 )
                _libc_fatal("*** %n in writable segment detected ***\n", (_DWORD *)v113);
            }
            v69 = *(_QWORD **)a4;
            if ( v125 )
            {
              *v69 = (int)v140;
              a4 += 4;
            }
            else if ( v131 )
            {
              *(_BYTE *)v69 = v140;
              a4 += 4;
            }
            else
            {
              if ( (_DWORD)v118 )
                *(_WORD *)v69 = v140;
              else
                *(_DWORD *)v69 = v140;
              a4 += 4;
            }
            goto LABEL_62;
          case 79:
LABEL_149:
            v38 = 8;
            goto LABEL_144;
          case 80:
LABEL_220:
            v39 = *(_DWORD *)a4;
            if ( *(_DWORD *)a4 )
            {
              LODWORD(v118) = *(_DWORD *)a4;
              a4 += 4;
              v38 = 16;
              v122 = 0;
              v131 = 0;
              LOBYTE(v134) = 120;
              v124 = 1;
              goto LABEL_97;
            }
            a4 += 4;
            v87 = 5;
            v62 = "(nil)";
            if ( v133 >= 5 )
              v87 = v133;
            v133 = v87;
            if ( (_BYTE)v134 == 83 )
            {
LABEL_327:
              LODWORD(v145) = v62;
              v147 = 0;
              v148 = 0;
              if ( v133 < 0 )
              {
                v63 = wcsrtombs(0, (int *)&v145, 0, (int *)&v147);
                if ( v63 == -1 )
                  goto LABEL_174;
                v134 = v147;
                if ( v147 )
                  _assert_fail("__mbsinit (&mbstate)", "vfprintf.c", 1637, "_IO_vfprintf_internal");
                v104 = v63 + 1;
                LODWORD(v145) = v62;
                if ( v63 + 1 <= 0x1000 || (v133 = v63 + 1, v112 = _libc_alloca_cutoff(v63 + 1), v104 = v133, v112) )
                {
                  v105 = alloca(v104 + 15);
                  v62 = v116;
                }
                else
                {
                  v62 = (char *)malloc(v133);
                  if ( !v62 )
                    goto LABEL_174;
                  v134 = (unsigned __int8 *)1;
                  v104 = v133;
                }
                wcsrtombs((int)v62, (int *)&v145, v104, (int *)&v147);
              }
              else
              {
                if ( v133 <= 4096 || _libc_alloca_cutoff(v133) )
                {
                  v134 = 0;
                  v88 = alloca(v133 + 15);
                  v62 = v116;
                }
                else
                {
                  v62 = (char *)malloc(v133);
                  if ( !v62 )
                    goto LABEL_174;
                  v134 = (unsigned __int8 *)1;
                }
                v63 = wcsrtombs((int)v62, (int *)&v145, v133, (int *)&v147);
                if ( v63 == -1 )
                  goto LABEL_174;
              }
            }
            else
            {
LABEL_193:
              v63 = j_strnlen(v62, v133);
              v134 = 0;
            }
LABEL_194:
            v64 = v132 == v63;
            v133 = v132 - v63;
            if ( (int)(v132 - v63) < 0 )
            {
              if ( (v140 & 0x80000000) != 0 )
LABEL_421:
                _assert_fail("(size_t) done <= (size_t) INT_MAX", "vfprintf.c", 1637, "_IO_vfprintf_internal");
              v78 = *(_DWORD *)(a2 + 148);
              if ( v136 <= v78 - (int)&_start___libc_IO_vtables )
              {
                v134 = *(unsigned __int8 **)(a2 + 148);
                IO_vtable_check(v140);
                v78 = (int)v134;
              }
              if ( v63 != (*(int (__cdecl **)(int, char *, unsigned int))(v78 + 28))(a2, v62, v63) )
                goto LABEL_174;
              if ( v63 > 0x7FFFFFFF - v140 )
                goto LABEL_283;
              goto LABEL_267;
            }
            LOBYTE(v132) = v132 != v63;
            if ( !v130 && !v64 )
            {
              v65 = IO_padn(a2, 32, v133);
              if ( v133 != v65 )
                goto LABEL_174;
              if ( v140 > 0x7FFFFFFE )
                goto LABEL_423;
              if ( v133 > 0x7FFFFFFF - v140 )
                goto LABEL_283;
              v18 = v133;
              v140 += v133;
            }
            if ( (v140 & 0x80000000) != 0 )
              goto LABEL_421;
            v66 = *(_DWORD *)(a2 + 148);
            if ( v136 <= v66 - (int)&_start___libc_IO_vtables )
            {
              v131 = *(_DWORD *)(a2 + 148);
              IO_vtable_check(v18);
              v66 = v131;
            }
            if ( v63 != (*(int (__cdecl **)(int, char *, unsigned int))(v66 + 28))(a2, v62, v63) )
              goto LABEL_174;
            if ( v63 > 0x7FFFFFFF - v140 )
              goto LABEL_283;
            v140 += v63;
            v131 = 0x7FFFFFFF;
            if ( v130 && (_BYTE)v132 )
            {
              v67 = v133;
              if ( v67 != IO_padn(a2, 32, v133) )
                goto LABEL_174;
              if ( v140 > 0x7FFFFFFE )
LABEL_423:
                _assert_fail(
                  "(unsigned int) done < (unsigned int) INT_MAX",
                  "vfprintf.c",
                  1637,
                  "_IO_vfprintf_internal");
              if ( v67 > v131 - v140 )
                goto LABEL_283;
              v140 += v133;
            }
            if ( v134 )
              free(v62);
            goto LABEL_62;
          case 85:
LABEL_143:
            v38 = 10;
LABEL_144:
            if ( v125 )
            {
              v81 = *(_QWORD *)a4;
              v127 = 0;
              v126 = 0;
              v131 = 0;
              v118 = v81;
              a4 += 8;
LABEL_294:
              if ( v133 < 0 )
              {
                v133 = 1;
              }
              else
              {
                if ( !v133 )
                {
                  v40 = v118 | HIDWORD(v118);
                  if ( !v118 )
                  {
                    if ( v38 == 8 && v124 )
                    {
                      v41 = 1;
                      LOBYTE(v129) = 32;
                      v40 = (int)(v128 - 1);
                      *(_BYTE *)v40 = 48;
                      v125 = v40;
                    }
                    else
                    {
                      v41 = 0;
                      LOBYTE(v129) = 32;
                      v125 = (int)v128;
                    }
LABEL_300:
                    LODWORD(v118) = v118 != 0;
                    goto LABEL_103;
                  }
                }
                LOBYTE(v129) = 32;
              }
              v84 = itoa(v118, v128, v38, (_BYTE)v134 == 88);
              v125 = (int)v84;
              if ( v122 && v123 )
                v125 = group_number(v84, (int)v128, (_BYTE *)v123, v120);
              v40 = v117;
              if ( v117 && v38 == 10 )
              {
                v40 = (int)v128;
                v125 = (int)i18n_number_rewrite((_BYTE *)v125, (int)v128, (int)v128);
                v41 = v40 - v125;
              }
              else
              {
                v41 = (int)&v128[-v125];
              }
              goto LABEL_300;
            }
            if ( v131 )
            {
              v39 = (unsigned __int8)*a4;
              v127 = 0;
              v126 = 0;
              v131 = 0;
              LODWORD(v118) = v39;
              a4 += 4;
            }
            else
            {
              if ( (_DWORD)v118 )
                v39 = *(unsigned __int16 *)a4;
              else
                v39 = *(_DWORD *)a4;
              LODWORD(v118) = v39;
              v127 = 0;
              v126 = 0;
              a4 += 4;
            }
LABEL_97:
            v40 = v133;
            if ( v133 < 0 )
            {
              v133 = 1;
            }
            else
            {
              if ( !v133 && !v39 )
              {
                if ( v38 == 8 && v124 )
                {
                  v41 = 1;
                  LOBYTE(v129) = 32;
                  v38 = 8;
                  v40 = (int)(v128 - 1);
                  *(_BYTE *)v40 = 48;
                  v125 = v40;
                }
                else
                {
                  v41 = 0;
                  LOBYTE(v129) = 32;
                  v125 = (int)v128;
                }
                goto LABEL_103;
              }
              LOBYTE(v129) = 32;
            }
            v40 = (int)v128;
            v77 = itoa_word(v39, v128, v38, (_BYTE)v134 == 88);
            v125 = (int)v77;
            if ( v122 && v123 )
              v125 = group_number(v77, v40, (_BYTE *)v123, v120);
            if ( v117 && v38 == 10 )
            {
              v40 = (int)v128;
              v38 = 10;
              v125 = (int)i18n_number_rewrite((_BYTE *)v125, (int)v128, (int)v128);
              v41 = v40 - v125;
            }
            else
            {
              v41 = (int)&v128[-v125];
            }
LABEL_103:
            if ( v133 > v41 )
            {
              v40 = v133;
              v128 = (char *)(v133 - v41);
              if ( !v130 )
              {
                v133 = v132 - v133;
                if ( (_DWORD)v118 )
                {
                  LOBYTE(v40) = v124;
                  goto LABEL_112;
                }
LABEL_116:
                v133 = ((v127 | v126 | v131) == 0) + v133 - 1;
                if ( (_BYTE)v129 == 32 )
                {
                  v82 = v133;
                  if ( v133 <= 0 )
                  {
                    v133 = 0;
                  }
                  else
                  {
                    v132 = v41;
                    if ( v82 != IO_padn(a2, 32, v133) )
                      goto LABEL_174;
                    v41 = v132;
                    if ( v140 > 0x7FFFFFFE )
LABEL_419:
                      _assert_fail(
                        "(unsigned int) done < (unsigned int) INT_MAX",
                        "vfprintf.c",
                        1636,
                        "_IO_vfprintf_internal");
                    if ( v133 > 0x7FFFFFFF - v140 )
                      goto LABEL_283;
                    v83 = v133;
                    v133 = 0;
                    v140 += v83;
                  }
                }
                v46 = v131;
                if ( v131 )
                {
                  v47 = *(_BYTE **)(a2 + 20);
                  if ( (unsigned int)v47 < *(_DWORD *)(a2 + 24) )
                  {
                    v46 = (unsigned int)(v47 + 1);
                    *(_DWORD *)(a2 + 20) = v47 + 1;
                    *v47 = 45;
                    goto LABEL_120;
                  }
                  v132 = v41;
                  v115 = (int)v47;
                  v114 = v47;
                  v113 = 45;
LABEL_386:
                  v103 = _overflow(a2, v113);
                  v41 = v132;
                  if ( v103 == -1 )
                    goto LABEL_174;
                  goto LABEL_120;
                }
                if ( v127 )
                {
                  v80 = *(_BYTE **)(a2 + 20);
                  if ( (unsigned int)v80 >= *(_DWORD *)(a2 + 24) )
                  {
                    v132 = v41;
                    v115 = (int)v80;
                    v114 = v80;
                    v113 = 43;
                    goto LABEL_386;
                  }
                  *(_DWORD *)(a2 + 20) = v80 + 1;
                  *v80 = 43;
LABEL_120:
                  if ( v140 == 0x7FFFFFFF )
                    goto LABEL_174;
                  ++v140;
                }
                else if ( v126 )
                {
                  v86 = *(_BYTE **)(a2 + 20);
                  if ( (unsigned int)v86 >= *(_DWORD *)(a2 + 24) )
                  {
                    v132 = v41;
                    v115 = (int)v86;
                    v114 = v86;
                    v113 = 32;
                    goto LABEL_386;
                  }
                  *(_DWORD *)(a2 + 20) = v86 + 1;
                  *v86 = 32;
                  goto LABEL_120;
                }
                if ( (_DWORD)v118 && v124 && v38 == 16 )
                {
                  v48 = *(_BYTE **)(a2 + 20);
                  if ( (unsigned int)v48 >= *(_DWORD *)(a2 + 24) )
                  {
                    v132 = v41;
                    v115 = v46;
                    v114 = (_BYTE *)v46;
                    v109 = _overflow(a2, 48);
                    v41 = v132;
                    if ( v109 == -1 )
                      goto LABEL_174;
                  }
                  else
                  {
                    *(_DWORD *)(a2 + 20) = v48 + 1;
                    *v48 = 48;
                  }
                  if ( v140 == 0x7FFFFFFF )
                    goto LABEL_174;
                  v49 = *(_BYTE **)(a2 + 20);
                  if ( (unsigned int)v49 >= *(_DWORD *)(a2 + 24) )
                  {
                    v132 = v41;
                    v115 = v41;
                    v114 = (_BYTE *)v41;
                    v108 = _overflow(a2, (unsigned __int8)v134);
                    v41 = v132;
                    if ( v108 == -1 )
                      goto LABEL_174;
                  }
                  else
                  {
                    v46 = (unsigned __int8)v134;
                    *(_DWORD *)(a2 + 20) = v49 + 1;
                    *v49 = v46;
                  }
                  if ( v140 == 2147483646 )
                    goto LABEL_174;
                  v140 += 2;
                }
                v50 = (unsigned int)&v128[v133];
                if ( (int)&v128[v133] > 0 )
                {
                  v134 = (unsigned __int8 *)v41;
                  if ( v50 != IO_padn(a2, 48, (int)&v128[v133]) )
                    goto LABEL_174;
                  v46 = v140;
                  if ( v140 > 0x7FFFFFFE )
                    goto LABEL_419;
                  v41 = (int)v134;
                  if ( v50 > 0x7FFFFFFF - v140 )
                    goto LABEL_283;
                  v140 += v50;
                }
                if ( (v140 & 0x80000000) != 0 )
                  goto LABEL_420;
                v51 = *(_DWORD *)(a2 + 148);
                if ( v136 <= v51 - (int)&_start___libc_IO_vtables )
                {
                  v134 = (unsigned __int8 *)v41;
                  IO_vtable_check(v46);
                  v41 = (int)v134;
                }
                v134 = (unsigned __int8 *)v41;
                v52 = (*(int (__cdecl **)(int, int, int))(v51 + 28))(a2, v125, v41);
                if ( v134 != (unsigned __int8 *)v52 )
                  goto LABEL_174;
                if ( (int)(0x7FFFFFFF - v140) < (int)v134 )
                  goto LABEL_283;
                v140 += (unsigned int)v134;
                goto LABEL_62;
              }
            }
            else if ( (_DWORD)v118 )
            {
              v40 = (unsigned __int8)v124;
              if ( v38 == 8 && (_BYTE)v124 )
              {
                v42 = v128;
                v43 = (_BYTE *)(v125 - 1);
                *v43 = 48;
                v41 = v42 - v43;
                v125 = (int)v43;
              }
              v44 = (char *)(v133 - v41);
              if ( v133 - v41 < 0 )
                v44 = 0;
              v128 = v44;
              if ( !v130 )
              {
                v133 = v132 - (_DWORD)&v128[v41];
LABEL_112:
                if ( v38 == 16 )
                {
                  v45 = v133 - 2;
                  if ( !(_BYTE)v40 )
                    v45 = v133;
                  v133 = v45;
                }
                goto LABEL_116;
              }
            }
            else
            {
              if ( !v130 )
              {
                v128 = 0;
                v133 = v132 - v41;
                goto LABEL_116;
              }
              v128 = 0;
            }
            if ( v131 )
            {
              v70 = *(_BYTE **)(a2 + 20);
              if ( (unsigned int)v70 < *(_DWORD *)(a2 + 24) )
              {
                *(_DWORD *)(a2 + 20) = v70 + 1;
                *v70 = 45;
                goto LABEL_241;
              }
              v133 = v41;
              v115 = (int)v70;
              v114 = v70;
              v113 = 45;
            }
            else if ( v127 )
            {
              v79 = *(_BYTE **)(a2 + 20);
              if ( (unsigned int)v79 < *(_DWORD *)(a2 + 24) )
              {
                *(_DWORD *)(a2 + 20) = v79 + 1;
                *v79 = 43;
                goto LABEL_241;
              }
              v133 = v41;
              v115 = (int)v79;
              v114 = v79;
              v113 = 43;
            }
            else
            {
              if ( !v126 )
                goto LABEL_243;
              v85 = *(_BYTE **)(a2 + 20);
              if ( (unsigned int)v85 < *(_DWORD *)(a2 + 24) )
              {
                *(_DWORD *)(a2 + 20) = v85 + 1;
                *v85 = 32;
                goto LABEL_241;
              }
              v133 = v41;
              v115 = v40;
              v114 = (_BYTE *)v40;
              v113 = 32;
            }
            v102 = _overflow(a2, v113);
            v41 = v133;
            if ( v102 == -1 )
              goto LABEL_174;
LABEL_241:
            if ( v140 == 0x7FFFFFFF )
              goto LABEL_174;
            --v132;
            ++v140;
LABEL_243:
            if ( (_DWORD)v118 && v124 && v38 == 16 )
            {
              v71 = *(_BYTE **)(a2 + 20);
              if ( (unsigned int)v71 >= *(_DWORD *)(a2 + 24) )
              {
                v133 = v41;
                v115 = (int)v71;
                v114 = v71;
                v107 = _overflow(a2, 48);
                v41 = v133;
                if ( v107 == -1 )
                  goto LABEL_174;
              }
              else
              {
                *(_DWORD *)(a2 + 20) = v71 + 1;
                *v71 = 48;
              }
              if ( v140 == 0x7FFFFFFF )
                goto LABEL_174;
              v72 = *(_BYTE **)(a2 + 20);
              if ( (unsigned int)v72 >= *(_DWORD *)(a2 + 24) )
              {
                v133 = v41;
                v115 = (int)v72;
                v114 = v72;
                v106 = _overflow(a2, (unsigned __int8)v134);
                v41 = v133;
                if ( v106 == -1 )
                  goto LABEL_174;
              }
              else
              {
                *(_DWORD *)(a2 + 20) = v72 + 1;
                *v72 = (_BYTE)v134;
              }
              if ( v140 == 2147483646 )
                goto LABEL_174;
              v132 -= 2;
              v140 += 2;
            }
            v73 = v128;
            v63 = v132 - (_DWORD)&v128[v41];
            if ( v128 )
            {
              v134 = (unsigned __int8 *)v41;
              if ( (char *)IO_padn(a2, 48, (int)v128) != v73 )
                goto LABEL_174;
              if ( v140 > 0x7FFFFFFE )
                goto LABEL_419;
              v41 = (int)v134;
              if ( (unsigned int)v73 > 0x7FFFFFFF - v140 )
                goto LABEL_283;
              v140 += (unsigned int)v128;
            }
            if ( (v140 & 0x80000000) != 0 )
LABEL_420:
              _assert_fail("(size_t) done <= (size_t) INT_MAX", "vfprintf.c", 1636, "_IO_vfprintf_internal");
            v74 = *(_DWORD *)(a2 + 148);
            if ( v136 <= v74 - (int)&_start___libc_IO_vtables )
            {
              v133 = *(_DWORD *)(a2 + 148);
              v134 = (unsigned __int8 *)v41;
              IO_vtable_check(v74 - (_DWORD)&_start___libc_IO_vtables);
              v74 = v133;
              v41 = (int)v134;
            }
            v134 = (unsigned __int8 *)v41;
            v75 = (*(int (__cdecl **)(int, int, int))(v74 + 28))(a2, v125, v41);
            if ( v134 != (unsigned __int8 *)v75 )
              goto LABEL_174;
            if ( (int)v134 > (int)(0x7FFFFFFF - v140) )
              goto LABEL_283;
            v140 += (unsigned int)v134;
            v134 = (unsigned __int8 *)0x7FFFFFFF;
            v76 = v140;
            if ( (int)v63 > 0 )
            {
              if ( v63 != IO_padn(a2, 32, v63) )
                goto LABEL_174;
              if ( v76 > 0x7FFFFFFE )
                goto LABEL_419;
              if ( v63 > (unsigned int)&v134[-v76] )
                goto LABEL_283;
LABEL_267:
              v140 += v63;
            }
LABEL_62:
            ++v121;
            if ( v135 )
              free(v135);
            v28 = (unsigned int *)(v141 + 1);
            v141 = (unsigned __int8 *)v28;
            v29 = (unsigned __int8 *)strchrnul(v28, 37);
            v141 = v29;
            if ( (v140 & 0x80000000) != 0 )
              _assert_fail("(size_t) done <= (size_t) INT_MAX", "vfprintf.c", 1668, "_IO_vfprintf_internal");
            v30 = *(_DWORD *)(a2 + 148);
            if ( v136 <= v30 - (int)&_start___libc_IO_vtables )
            {
              v135 = *(_DWORD *)(a2 + 148);
              IO_vtable_check(v30 - (_DWORD)&_start___libc_IO_vtables);
              v29 = v141;
              v30 = v135;
            }
            v31 = (*(int (__cdecl **)(int, unsigned int *, int))(v30 + 28))(a2, v28, v29 - (unsigned __int8 *)v28);
            v14 = (char *)v141;
            if ( v31 != v141 - (unsigned __int8 *)v28 )
              goto LABEL_11;
            if ( v31 > (int)(0x7FFFFFFF - v140) )
              goto LABEL_290;
            v13 = *v141 == 0;
            v140 += v31;
            if ( v13 )
              goto LABEL_12;
            continue;
          default:
            goto LABEL_38;
        }
        break;
      }
    }
    v140 = printf_positional(
             (_DWORD *)a2,
             (_BYTE *)a3,
             v119,
             a1,
             (int)a4,
             &v142,
             v140,
             v6,
             v137,
             v152,
             v138,
             (_BYTE *)v123,
             v120);
  }
LABEL_12:
  if ( (*(_DWORD *)a2 & 0x8000) == 0 && (v8 = *(_DWORD **)(a2 + 72), v13 = v8[1] == 1, --v8[1], v13) )
  {
    v8[2] = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v13 = (*v8)-- == 1;
    if ( !v13 )
      _lll_unlock_wake_private(v8);
    if ( !v139 )
      return v140;
  }
  else if ( !v139 )
  {
    return v140;
  }
  MEMORY[0](v146, 0);
  return v140;
}
// 808117E: variable 'v46' is possibly undefined
// 8081206: variable 'v18' is possibly undefined
// 80481C0: using guessed type int __cdecl j_strnlen(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80515F0: using guessed type void __noreturn _libc_fatal(const char *, ...);
// 8051620: using guessed type int __fastcall IO_vtable_check(_DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 80ECD34: using guessed type int _printf_function_table;
// 80ECD38: using guessed type int _printf_modifier_table;
// 80ECD98: using guessed type int _printf_va_arg_table;
// 807F1C0: using guessed type long double var_430;

//----- (08081690) --------------------------------------------------------
int __usercall buffered_vfprintf@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx
  int v5; // edi
  int v6; // edx
  int v7; // esi
  int v8; // ecx
  _DWORD *v10; // edx
  unsigned int v12; // esi
  bool v14; // zf
  int v15; // [esp+Ch] [ebp-20E0h]
  int v16[4]; // [esp+28h] [ebp-20C4h] BYREF
  char *v17; // [esp+38h] [ebp-20B4h]
  char *v18; // [esp+3Ch] [ebp-20B0h]
  char *v19; // [esp+40h] [ebp-20ACh]
  int v20; // [esp+64h] [ebp-2088h]
  int v21; // [esp+70h] [ebp-207Ch]
  int v22; // [esp+90h] [ebp-205Ch]
  void *v23; // [esp+BCh] [ebp-2030h]
  _DWORD *v24; // [esp+C0h] [ebp-202Ch]
  char v25[8192]; // [esp+D0h] [ebp-201Ch] BYREF
  char v26; // [esp+20D0h] [ebp-1Ch] BYREF

  v3 = a1[26];
  if ( v3 )
  {
    v5 = -1;
    if ( v3 != -1 )
      return v5;
  }
  else
  {
    a1[26] = -1;
  }
  v24 = a1;
  v22 = -1;
  v16[0] = -72515580;
  v18 = v25;
  v17 = v25;
  v21 = 0;
  v23 = &IO_helper_jumps;
  v19 = &v26;
  v20 = a1[15];
  v5 = vfprintf(v16, a2, a3);
  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v12 = __readgsdword(8u);
    if ( v12 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v14 = __readgsdword(0xCu) == 0;
      if ( !v14 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v14 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v12;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v6 = (int)v17;
  v7 = v18 - v17;
  if ( v18 - v17 > 0 )
  {
    v8 = a1[37];
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v8
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
    {
      v15 = a1[37];
      IO_vtable_check(v8);
      v6 = (int)v17;
      v8 = v15;
    }
    if ( v7 != (*(int (__cdecl **)(_DWORD *, int, int))(v8 + 28))(a1, v6, v7) )
      v5 = -1;
  }
  if ( (*a1 & 0x8000) == 0 )
  {
    v10 = (_DWORD *)a1[18];
    v14 = v10[1]-- == 1;
    if ( v14 )
    {
      v10[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v14 = (*v10)-- == 1;
      if ( !v14 )
        _lll_unlock_wake_private(v10);
    }
  }
  return v5;
}
// 8051620: using guessed type int __fastcall IO_vtable_check(_DWORD);
// 807F1C0: using guessed type _DWORD __cdecl vfprintf(_DWORD, _DWORD, _DWORD);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 8081690: using guessed type int var_20C4[4];

//----- (08081870) --------------------------------------------------------
int __usercall hack_digit@<eax>(int a1@<eax>)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // esi
  int v6; // eax
  int v7; // edx
  int v8; // ecx
  int v10; // eax
  int *v11; // ecx
  int v12; // esi
  int v13; // ecx
  int v14; // eax
  int v15; // edx
  int *v16; // ebx
  int v17; // esi
  int v18; // edx

  if ( *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)(a1 + 4) == 102 )
    {
      v18 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v18 - 1;
      if ( v18 > 0 )
        return 48;
    }
  }
  v2 = *(_DWORD *)(a1 + 24);
  if ( !v2 )
  {
    v14 = *(_DWORD *)(a1 + 16);
    v15 = *(_DWORD *)(a1 + 12);
    v16 = (int *)(v15 + 4 * v14 - 4);
    v17 = *v16 + 48;
    *v16 = _mpn_mul_1(v15, v15, v14 - 1, 0xAu);
    return v17;
  }
  v3 = *(_DWORD *)(a1 + 16);
  if ( v2 <= v3 )
  {
    v10 = _mpn_divrem(*(_DWORD *)(a1 + 28), 0, *(_DWORD **)(a1 + 12), v3, *(unsigned int **)(a1 + 20), v2);
    v11 = *(int **)(a1 + 28);
    v11[*(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 24)] = v10;
    v3 = *(_DWORD *)(a1 + 24);
    v12 = *v11;
    *(_DWORD *)(a1 + 16) = v3;
    if ( v3 )
    {
      v4 = *(_DWORD *)(a1 + 12);
      v13 = v3 - 1;
      if ( *(_DWORD *)(v4 + 4 * v3 - 4) )
      {
LABEL_18:
        v5 = v12 + 48;
        goto LABEL_6;
      }
      while ( 1 )
      {
        v3 = v13;
        *(_DWORD *)(a1 + 16) = v13;
        if ( !v13 )
          break;
        --v13;
        if ( *(_DWORD *)(v4 + 4 * v13) )
          goto LABEL_18;
      }
    }
    *(_DWORD *)(a1 + 16) = 1;
    return v12 + 48;
  }
  v4 = *(_DWORD *)(a1 + 12);
  v5 = 48;
LABEL_6:
  v6 = _mpn_mul_1(v4, v4, v3, 0xAu);
  if ( v6 )
  {
    v7 = *(_DWORD *)(a1 + 16);
    v8 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = v7 + 1;
    *(_DWORD *)(v8 + 4 * v7) = v6;
  }
  return v5;
}

//----- (08081990) --------------------------------------------------------
_BYTE *__usercall i18n_number_rewrite_0@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v6; // eax
  unsigned int v7; // edi
  unsigned int v8; // edx
  void *v9; // esp
  int *v10; // ecx
  char *v11; // eax
  unsigned int v12; // ecx
  char *v13; // ebx
  int v14; // eax
  _BYTE *v16; // edi
  int v17; // eax
  int v18; // edx
  __int16 *v19; // edi
  int v20; // eax
  int v21; // edx
  _BOOL4 v22; // eax
  int v23; // eax
  int v24; // ecx
  int v25; // eax
  int v26; // [esp+Ch] [ebp-58h] BYREF
  int v27; // [esp+10h] [ebp-54h]
  unsigned int v28; // [esp+14h] [ebp-50h]
  _DWORD *v29; // [esp+18h] [ebp-4Ch]
  int v30; // [esp+20h] [ebp-44h] BYREF
  int v31; // [esp+24h] [ebp-40h]
  __int16 v32[8]; // [esp+2Ah] [ebp-3Ah] BYREF
  __int16 v33[20]; // [esp+3Bh] [ebp-29h] BYREF

  v29 = (_DWORD *)wctrans(135056004);
  v28 = towctrans(0x2Eu, v29);
  v6 = towctrans(0x2Cu, v29);
  if ( v29 )
  {
    v26 = v6;
    v30 = 0;
    v31 = 0;
    v23 = wcrtomb((char *)v32, v28, &v30);
    v24 = v26;
    if ( v23 == -1 )
      v32[0] = 46;
    else
      *((_BYTE *)v32 + v23) = 0;
    v30 = 0;
    v31 = 0;
    v25 = wcrtomb((char *)v33, v24, &v30);
    if ( v25 == -1 )
      v33[0] = 44;
    else
      *((_BYTE *)v33 + v25) = 0;
  }
  v7 = a2 - (_DWORD)a1;
  v8 = v7;
  if ( v7 <= 0x1000 || (v28 = v7, v22 = _libc_alloca_cutoff(v7), v8 = v7, v22) )
  {
    v27 = 1;
    v9 = alloca(v8 + 15);
    v10 = &v26;
  }
  else
  {
    v28 = v7;
    v10 = (int *)malloc(v7);
    if ( !v10 )
      return a1;
    v27 = 0;
    v8 = v28;
  }
  v28 = (unsigned int)v10;
  v11 = (char *)mempcpy(v10, a1, v8);
  v12 = v28;
  v13 = v11;
LABEL_5:
  while ( v12 <= (unsigned int)--v13 )
  {
    while ( 1 )
    {
      v14 = *v13;
      if ( (unsigned __int8)(v14 - 48) <= 9u )
        break;
      if ( v29 && (v14 & 0xFD) == 44 )
      {
        v19 = v33;
        v28 = v12;
        if ( (_BYTE)v14 == 46 )
          v19 = v32;
        v20 = strlen(v19);
        a3 -= v20;
        v21 = v20 - 1;
        v12 = v28;
        if ( v20 )
        {
          do
          {
            *(_BYTE *)(a3 + v21) = *((_BYTE *)v19 + v21);
            --v21;
          }
          while ( v21 != -1 );
        }
        goto LABEL_5;
      }
      --v13;
      *(_BYTE *)--a3 = v14;
      if ( v12 > (unsigned int)v13 )
        goto LABEL_9;
    }
    v28 = v12;
    v16 = *(_BYTE **)(*(_DWORD *)__readgsdword(0xFFFFFFD8) + 4 * v14 + 8);
    v17 = strlen(v16);
    a3 -= v17;
    v18 = v17 - 1;
    v12 = v28;
    if ( v17 )
    {
      do
      {
        *(_BYTE *)(a3 + v18) = v16[v18];
        --v18;
      }
      while ( v18 != -1 );
    }
  }
LABEL_9:
  if ( !v27 )
    free(v12);
  return (_BYTE *)a3;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08081BC0) --------------------------------------------------------
int __usercall _guess_grouping_part_0@<eax>(unsigned int a1@<eax>, unsigned __int8 *a2@<edx>)
{
  int v2; // ebx
  unsigned __int8 v3; // cl
  unsigned int v4; // esi

  v2 = 0;
  v3 = *a2;
  do
  {
    v4 = (char)v3;
    if ( a1 > (char)v3 )
    {
      ++v2;
      a1 -= (char)v3;
      v3 = a2[v2];
      if ( v3 <= 0x7Eu )
        continue;
    }
    return v2;
  }
  while ( v3 );
  return (a1 - 1) / v4 + v2;
}

//----- (08081C10) --------------------------------------------------------
int __cdecl _printf_fp_l(_DWORD *a1, _DWORD *a2, int a3, long double **a4)
{
  char v4; // al
  _DWORD *v5; // ecx
  char v6; // dl
  long double *v7; // eax
  __int16 v8; // fps
  __int16 v10; // ax
  int v11; // eax
  int v12; // ecx
  bool v13; // zf
  char v15; // fps^1
  char v17; // ah
  __int16 v18; // fps
  int v22; // ebx
  int v23; // edx
  void *v24; // esp
  void *v25; // esp
  void *v26; // esp
  int v27; // eax
  int v28; // edx
  int v29; // edx
  int v30; // eax
  unsigned int v31; // ebx
  int v32; // eax
  unsigned __int8 v33; // al
  unsigned __int8 v34; // dl
  int v35; // eax
  unsigned int v36; // ebx
  void *v37; // esp
  int v38; // ebx
  int v39; // esi
  int v40; // eax
  _DWORD *v41; // eax
  unsigned int v42; // edi
  char *v43; // ebx
  int v44; // esi
  int v45; // ecx
  int v46; // eax
  unsigned __int8 *v47; // edi
  int v48; // esi
  char *v49; // ebx
  int v50; // eax
  unsigned __int8 *v51; // edi
  int v52; // eax
  _DWORD *v53; // edx
  int v54; // ecx
  char *v55; // edi
  int v56; // ecx
  int v57; // eax
  _DWORD *v58; // edx
  bool v59; // al
  unsigned __int8 *v60; // edi
  int v61; // eax
  int v62; // eax
  _DWORD *v63; // edx
  int v64; // eax
  _DWORD *v65; // edx
  __int16 v66; // ax
  int v67; // ebx
  _DWORD *v68; // esi
  int v69; // eax
  int i; // ecx
  int v71; // edx
  int v72; // eax
  int v73; // eax
  char v74; // dl
  int v75; // ebx
  int v76; // esi
  int v77; // edx
  unsigned __int8 *v79; // ebx
  unsigned __int8 *v80; // ebx
  unsigned __int8 *v81; // eax
  unsigned __int8 v82; // dl
  unsigned int v83; // eax
  unsigned __int8 *v84; // eax
  int v85; // ecx
  _BYTE *v86; // eax
  _BYTE *v87; // eax
  _BYTE *v88; // eax
  _BYTE *v89; // edi
  unsigned __int8 *v90; // eax
  bool v91; // cf
  _BYTE *v92; // eax
  int v93; // edx
  int v94; // edi
  int v95; // edx
  unsigned int *v96; // eax
  unsigned int *v97; // edx
  int v98; // ecx
  int v99; // eax
  _DWORD *v100; // esi
  char v101; // di
  unsigned int v102; // ebx
  _BYTE *v103; // edx
  int v104; // edx
  int v105; // eax
  int v106; // edx
  bool v107; // al
  int v108; // edx
  char *v109; // ecx
  int v110; // eax
  int v111; // eax
  unsigned int v112; // ecx
  unsigned int *v114; // edi
  unsigned int *v115; // esi
  int v116; // ebx
  unsigned int *v118; // ecx
  unsigned int v119; // esi
  unsigned int v120; // esi
  int v124; // edx
  int v125; // edx
  int v126; // eax
  _DWORD *v127; // edx
  char v128; // al
  int v129; // eax
  int v130; // ebx
  unsigned int v131; // eax
  unsigned __int8 *v132; // eax
  void *v133; // esp
  int *v134; // ebx
  int v135; // ecx
  _BYTE *v136; // eax
  int v137; // esi
  int v138; // edx
  int v139; // eax
  int *v140; // eax
  int v141; // ebx
  char *v142; // edx
  int v143; // ecx
  int v144; // ebx
  unsigned int v145; // edx
  int *v146; // ebx
  int v147; // eax
  int v148; // edx
  int v149; // ebx
  int v150; // eax
  _DWORD *v151; // edx
  unsigned int v152; // esi
  int v154; // eax
  int *v155; // esi
  int v156; // edx
  _BYTE *v157; // ecx
  int v158; // eax
  char *v159; // ecx
  int v160; // eax
  int v161; // eax
  int v162; // esi
  int v163; // eax
  unsigned int v164; // ebx
  int v165; // esi
  unsigned int v166; // edx
  unsigned int v167; // edi
  unsigned int v168; // ebx
  _BYTE *v169; // ecx
  int v170; // eax
  unsigned int *v171; // ecx
  unsigned int v172; // ebx
  unsigned int v173; // esi
  int *v174; // edi
  int *v175; // eax
  int v176; // ecx
  char *v177; // edi
  int v178; // eax
  int v179; // edx
  int v180; // eax
  int v181; // eax
  int v182; // edx
  unsigned int *v183; // edx
  unsigned int v184; // esi
  signed int v185; // ebx
  int v186; // eax
  int v187; // esi
  int *v188; // eax
  int v190; // esi
  unsigned int *v191; // eax
  unsigned int v192; // edi
  int v194; // ebx
  int v195; // ecx
  char v196; // al
  unsigned int v198; // ecx
  int v199; // edx
  unsigned int *v200; // esi
  unsigned int *v201; // ecx
  int v202; // eax
  int v203; // eax
  int v204; // esi
  int v205; // edi
  int v206; // ecx
  unsigned __int8 *v207; // ebx
  int v208; // eax
  int v209; // ecx
  _BYTE *v210; // eax
  int v211; // eax
  _DWORD *v212; // edx
  int v213; // eax
  unsigned __int8 v214; // dl
  unsigned __int8 *v215; // eax
  int v216; // esi
  int v217; // esi
  int v218; // eax
  int v220; // eax
  int v222; // eax
  int v223; // edx
  _DWORD *v224; // edx
  bool v225; // al
  int v226; // ecx
  int v227; // eax
  _BYTE *v228; // eax
  int v230; // eax
  _BYTE *v231; // eax
  int v232; // eax
  int v233; // eax
  int v234; // edx
  bool v235; // al
  unsigned int v236; // esi
  unsigned int v237; // eax
  unsigned int v238; // esi
  unsigned int v239; // esi
  int v240; // ebx
  int v241; // eax
  int v242; // esi
  unsigned int v243; // esi
  _BYTE *v244; // ebx
  int v245; // [esp-Ch] [ebp-C4h]
  _BYTE *v246; // [esp-8h] [ebp-C0h]
  int v247; // [esp-4h] [ebp-BCh]
  int v248; // [esp+0h] [ebp-B8h] BYREF
  int v249; // [esp+4h] [ebp-B4h]
  int v250; // [esp+8h] [ebp-B0h]
  int v251; // [esp+Ch] [ebp-ACh]
  int v252; // [esp+10h] [ebp-A8h]
  int v253; // [esp+14h] [ebp-A4h]
  int v254; // [esp+18h] [ebp-A0h]
  int *v255; // [esp+1Ch] [ebp-9Ch]
  unsigned int v256; // [esp+20h] [ebp-98h]
  unsigned int v257; // [esp+24h] [ebp-94h]
  char *v258; // [esp+28h] [ebp-90h]
  unsigned int *v259; // [esp+2Ch] [ebp-8Ch]
  int v260; // [esp+30h] [ebp-88h]
  _BYTE *v261; // [esp+34h] [ebp-84h]
  unsigned int v262; // [esp+38h] [ebp-80h]
  _BYTE *v263; // [esp+3Ch] [ebp-7Ch]
  int v264; // [esp+40h] [ebp-78h]
  int v265; // [esp+44h] [ebp-74h]
  int *v266; // [esp+48h] [ebp-70h]
  unsigned __int8 *v267; // [esp+4Ch] [ebp-6Ch]
  int v268; // [esp+50h] [ebp-68h]
  int v269; // [esp+54h] [ebp-64h]
  double v270; // [esp+58h] [ebp-60h]
  int v271; // [esp+68h] [ebp-50h] BYREF
  int v272[2]; // [esp+6Ch] [ebp-4Ch] BYREF
  unsigned int v273; // [esp+74h] [ebp-44h] BYREF
  unsigned int v274; // [esp+78h] [ebp-40h]
  int v275; // [esp+7Ch] [ebp-3Ch] BYREF
  int v276; // [esp+80h] [ebp-38h]
  int v277; // [esp+84h] [ebp-34h] BYREF
  unsigned int *v278; // [esp+88h] [ebp-30h]
  int v279; // [esp+8Ch] [ebp-2Ch]
  unsigned int *v280; // [esp+90h] [ebp-28h]
  int v281; // [esp+94h] [ebp-24h]
  unsigned int *v282; // [esp+98h] [ebp-20h]
  int v283; // [esp+9Ch] [ebp-1Ch]

  v271 = 0;
  v275 = 0;
  v4 = *(_BYTE *)(a3 + 13) & 1;
  v268 = (*(_BYTE *)(a3 + 13) & 4) != 0;
  if ( v4 )
  {
    v12 = a2[4];
    v13 = **(_BYTE **)(v12 + 44) == 0;
    v263 = *(_BYTE **)(v12 + 44);
    if ( v13 )
      v263 = *(_BYTE **)(a2[1] + 36);
    v265 = *(_DWORD *)(v12 + 208);
    if ( !v265 )
      v265 = *(_DWORD *)(a2[1] + 48);
    v6 = *(_BYTE *)(a3 + 12);
    if ( v6 >= 0 )
      goto LABEL_3;
    v267 = *(unsigned __int8 **)(v12 + 52);
  }
  else
  {
    v5 = (_DWORD *)a2[1];
    v6 = *(_BYTE *)(a3 + 12);
    v263 = (_BYTE *)v5[9];
    v265 = v5[12];
    if ( v6 >= 0 )
    {
LABEL_3:
      v267 = 0;
      v262 = 0;
      v261 = 0;
      goto LABEL_4;
    }
    v267 = (unsigned __int8 *)v5[11];
  }
  LOBYTE(v269) = *v267;
  if ( (unsigned __int8)(v269 - 1) > 0x7Du )
    goto LABEL_3;
  if ( v268 )
  {
    if ( v4 )
      v83 = *(_DWORD *)(a2[4] + 212);
    else
      v83 = *(_DWORD *)(a2[1] + 52);
    v262 = v83;
    v261 = 0;
    v84 = 0;
    if ( v262 )
      v84 = v267;
    v267 = v84;
  }
  else
  {
    if ( v4 )
      v88 = *(_BYTE **)(a2[4] + 48);
    else
      v88 = *(_BYTE **)(a2[1] + 40);
    v261 = v88;
    v89 = v88;
    v90 = 0;
    if ( *v261 )
      v90 = v267;
    v91 = *v89 == 0;
    v267 = v90;
    v262 = v91 ? 0 : 0xFFFFFFFE;
  }
LABEL_4:
  v7 = *a4;
  if ( (v6 & 1) != 0 )
  {
    _FST7 = *v7;
    __asm { fxam }
    v10 = v8;
    if ( (HIBYTE(v8) & 0x45) != 5 )
    {
      v11 = _mpn_extract_long_double((int)v272, 2, (unsigned int *)&v277, &v271, _FST7);
      v279 = v11;
      v269 = 32 * v11 - 63;
      goto LABEL_15;
    }
LABEL_59:
    v47 = (unsigned __int8 *)&unk_80CCF9B;
    v48 = v10 & 0x200;
    v49 = (char *)&unk_80CCFAC;
    v271 = v48;
    if ( (*(_WORD *)(__readgsdword(0xFFFFFFF8) + 2 * *(_DWORD *)(a3 + 8)) & 0x100) == 0 )
    {
      v47 = (unsigned __int8 *)&unk_80CCFA7;
      v49 = (char *)&unk_80CCFDC;
    }
    v267 = v47;
    v50 = *(_DWORD *)(a3 + 4);
    if ( v48 )
    {
      v51 = (unsigned __int8 *)(v50 - 4);
      LOBYTE(v269) = v50 - 4 > 0;
      if ( (v6 & 0x20) != 0 || !(_BYTE)v269 )
      {
        v48 = 0;
LABEL_68:
        if ( v268 )
        {
          v52 = a1[22];
          if ( v52 )
          {
            v53 = *(_DWORD **)(v52 + 16);
            if ( (unsigned int)v53 < *(_DWORD *)(v52 + 20) )
            {
              *(_DWORD *)(v52 + 16) = v53 + 1;
              *v53 = 45;
LABEL_72:
              ++v48;
              goto LABEL_73;
            }
          }
          v245 = 45;
          goto LABEL_195;
        }
        v85 = (int)a1;
        v87 = (_BYTE *)a1[5];
        if ( (unsigned int)v87 < a1[6] )
        {
          a1[5] = v87 + 1;
          *v87 = 45;
          goto LABEL_72;
        }
        v245 = 45;
        goto LABEL_257;
      }
    }
    else
    {
      if ( (v6 & 0x50) == 0 )
      {
        v51 = (unsigned __int8 *)(v50 - 3);
        LOBYTE(v269) = v50 - 3 > 0;
        if ( (v6 & 0x20) != 0 || !(_BYTE)v269 )
          goto LABEL_86;
        if ( !v268 )
          goto LABEL_65;
        goto LABEL_94;
      }
      v51 = (unsigned __int8 *)(v50 - 4);
      LOBYTE(v269) = v50 - 4 > 0;
      if ( (v6 & 0x20) != 0 || !(_BYTE)v269 )
        goto LABEL_86;
    }
    if ( !v268 )
    {
LABEL_65:
      v48 = IO_padn((int)a1, 32, (int)v51);
LABEL_66:
      if ( (unsigned __int8 *)v48 != v51 )
        return -1;
      v51 = (unsigned __int8 *)v48;
      LOBYTE(v269) = 1;
      if ( v271 )
        goto LABEL_68;
      v6 = *(_BYTE *)(a3 + 12);
LABEL_86:
      if ( (v6 & 0x40) != 0 )
      {
        if ( v268 )
        {
          v62 = a1[22];
          if ( v62 )
          {
            v63 = *(_DWORD **)(v62 + 16);
            if ( (unsigned int)v63 < *(_DWORD *)(v62 + 20) )
            {
              *(_DWORD *)(v62 + 16) = v63 + 1;
              *v63 = 43;
              goto LABEL_72;
            }
          }
          v245 = 43;
          goto LABEL_195;
        }
        v85 = (int)a1;
        v86 = (_BYTE *)a1[5];
        if ( (unsigned int)v86 < a1[6] )
        {
          a1[5] = v86 + 1;
          *v86 = 43;
          goto LABEL_72;
        }
        v245 = 43;
      }
      else
      {
        if ( (v6 & 0x10) == 0 )
        {
LABEL_73:
          v54 = v268;
          v268 = v48 + 3;
          if ( v54 )
          {
            v267 = v51;
            v55 = &v49[-4 * v48];
            do
            {
              v56 = *(_DWORD *)&v55[4 * v48];
              v57 = a1[22];
              if ( v57 && (v58 = *(_DWORD **)(v57 + 16), (unsigned int)v58 < *(_DWORD *)(v57 + 20)) )
              {
                *(_DWORD *)(v57 + 16) = v58 + 1;
                *v58 = v56;
                v59 = v56 == -1;
              }
              else
              {
                v59 = _woverflow(a1, *(_DWORD *)&v55[4 * v48]) == -1;
              }
              if ( v59 )
                return -1;
              ++v48;
            }
            while ( v48 != v268 );
            v60 = v267;
            if ( (*(_BYTE *)(a3 + 12) & 0x20) == 0 || !(_BYTE)v269 )
              return v48;
            v61 = IO_wpadn((int)a1, 32, (int)v267);
          }
          else
          {
            v79 = v267;
            v267 = v51;
            v80 = &v79[-v48];
            do
            {
              v81 = (unsigned __int8 *)a1[5];
              v82 = v80[v48];
              if ( (unsigned int)v81 >= a1[6] )
              {
                if ( _overflow((int)a1, v80[v48]) == -1 )
                  return -1;
              }
              else
              {
                a1[5] = v81 + 1;
                *v81 = v82;
              }
              ++v48;
            }
            while ( v48 != v268 );
            v60 = v267;
            if ( (*(_BYTE *)(a3 + 12) & 0x20) == 0 || !(_BYTE)v269 )
              return v48;
            v61 = IO_padn((int)a1, 32, (int)v267);
          }
          if ( (unsigned __int8 *)v61 != v60 )
            return -1;
          return v61 + v48;
        }
        if ( v268 )
        {
          v64 = a1[22];
          if ( v64 )
          {
            v65 = *(_DWORD **)(v64 + 16);
            if ( (unsigned int)v65 < *(_DWORD *)(v64 + 20) )
            {
              *(_DWORD *)(v64 + 16) = v65 + 1;
              *v65 = 32;
              goto LABEL_72;
            }
          }
          v245 = 32;
LABEL_195:
          v107 = _woverflow(a1, v245) == -1;
          goto LABEL_196;
        }
        v85 = (int)a1;
        v92 = (_BYTE *)a1[5];
        if ( (unsigned int)v92 < a1[6] )
        {
          a1[5] = v92 + 1;
          *v92 = 32;
          goto LABEL_72;
        }
        v245 = 32;
      }
LABEL_257:
      v107 = _overflow(v85, v245) == -1;
LABEL_196:
      if ( v107 )
        return -1;
      goto LABEL_72;
    }
LABEL_94:
    v48 = IO_wpadn((int)a1, 32, (int)v51);
    goto LABEL_66;
  }
  _FST7 = *(double *)v7;
  v270 = _FST7;
  _FST6 = (double)_FST7;
  __asm { fxam }
  v17 = v15;
  if ( (v17 & 0x45) == 5 )
  {
    __asm { fxam }
    v10 = v18;
    goto LABEL_59;
  }
  v11 = _mpn_extract_double(
          (unsigned int *)v272,
          2,
          &v277,
          (unsigned int *)&v271,
          COERCE_UNSIGNED_INT64(_FST7),
          HIDWORD(COERCE_UNSIGNED_INT64(_FST7)));
  v279 = v11;
  v269 = 32 * v11 - 52;
LABEL_15:
  v22 = v277;
  v281 = 0;
  v23 = 16 * ((unsigned int)(4 * ((int)(abs32(v277) + 31) >> 5) + 46) >> 4);
  v24 = alloca(v23);
  v25 = alloca(v23);
  v26 = alloca(v23);
  v278 = (unsigned int *)&v248;
  v282 = (unsigned int *)&v248;
  v280 = (unsigned int *)&v248;
  if ( v277 > 2 )
  {
    v93 = v277 + v269;
    if ( (((_BYTE)v277 + (_BYTE)v269) & 0x1F) != 0 )
    {
      v247 = v93 % 32;
      v246 = (_BYTE *)v11;
      v160 = v93 + 31;
      v245 = (int)v272;
      if ( v93 >= 0 )
        v160 = v277 + v269;
      v161 = _mpn_lshift(&v248 + (v160 >> 5), v245, (int)v246, v247);
      v22 = v277;
      v162 = v161;
      v95 = (v277 + v269) / 32;
      v163 = v95 + v279;
      v279 += v95;
      if ( v162 )
      {
        v279 = v163 + 1;
        v278[v163] = v162;
      }
    }
    else
    {
      v269 = v11 - 1;
      if ( v11 - 1 < 0 )
      {
        v95 = v93 / 32;
      }
      else
      {
        v266 = (int *)v11;
        v94 = v269;
        v95 = v93 / 32;
        do
        {
          *(&v248 + v95 + v94) = v272[v94];
          --v94;
        }
        while ( v94 != -1 );
        v11 = (int)v266;
      }
      v279 = v95 + v11;
    }
    if ( v95 > 0 )
    {
      v96 = v278;
      v97 = &v278[v95];
      do
        *v96++ = 0;
      while ( v97 != v96 );
    }
    v98 = v22;
    v99 = v281;
    v100 = &unk_80D0B90;
    v269 = 0;
    v101 = 12;
    v102 = 0;
    while ( 1 )
    {
      v100 -= 4;
      if ( (int)(v102 + v100[2] - 1) <= v98 )
      {
        if ( v99 )
        {
          v105 = _mpn_mul(v282, v280, v99, &dword_80D0BC8[*v100], v100[1] - 2);
          v106 = v281 + v100[1];
          if ( v105 )
            v104 = v106 - 2;
          else
            v104 = v106 - 3;
          v283 = v104;
        }
        else
        {
          v103 = (char *)&_tens + 4 * *v100;
          v283 = v100[1];
          memcpy(v282, v103, 4 * v283);
          v104 = v283;
        }
        if ( v279 > v104 || v279 == v104 && (v111 = _mpn_cmp((int)v278, (int)v282, v104), v104 = v283, v111 >= 0) )
        {
          v281 = v104;
          memcpy(v280, v282, 4 * v104);
          v99 = v281;
          _BitScanReverse(&v112, v280[v281 - 1]);
          v102 = (v112 ^ 0xFFFFFFE0) + 32 * (v281 - 2);
          v269 |= 1 << v101;
        }
        else
        {
          v99 = v281;
        }
      }
      --v101;
      if ( v100 <= fpioconst_pow10 )
        break;
      v98 = v277;
    }
    v277 = v269;
    if ( v99 <= 0 )
      goto LABEL_18;
    _EDX = *v280;
    v266 = (int *)v280;
    if ( _EDX )
    {
      _BitScanReverse(&v239, v266[v99 - 1]);
      v120 = v239 ^ 0x1F;
      if ( !v120 )
        goto LABEL_18;
      v114 = v278;
      v118 = (unsigned int *)v266;
      v116 = 0;
      v269 = 0;
      v264 = 0;
    }
    else
    {
      v114 = v278;
      if ( *v278 )
      {
        _BitScanReverse(&v238, v266[v99 - 1]);
        v120 = v238 ^ 0x1F;
        if ( !v120 )
          goto LABEL_18;
        _EDX = *v278;
        v118 = (unsigned int *)v266;
        v116 = 0;
        v269 = 0;
        v264 = 0;
LABEL_316:
        __asm { tzcnt   edi, edx }
        v260 = _EDI;
        goto LABEL_223;
      }
      v115 = v280 + 1;
      v116 = 0;
      v260 = v99;
      while ( 1 )
      {
        _EDX = *v115;
        ++v116;
        v118 = v115;
        v269 = v116;
        if ( _EDX )
          break;
        _EDX = v278[v116];
        ++v115;
        if ( _EDX )
        {
          v264 = 4 * v116;
          v99 = v260;
          _BitScanReverse(&v152, v266[v260 - 1]);
          v120 = v152 ^ 0x1F;
          if ( v120 )
            goto LABEL_316;
LABEL_318:
          v154 = v99 - v116;
          if ( v154 > 0 )
          {
            v155 = v266;
            v156 = 0;
            v157 = (char *)v266 + v264;
            do
            {
              v155[v156] = *(_DWORD *)&v157[4 * v156];
              ++v156;
              v154 = v281 - v116;
            }
            while ( v281 - v116 > v156 );
          }
          v281 = v154;
          v125 = v279 - v116;
          if ( v279 - v116 > 0 )
          {
            v158 = 0;
            v159 = (char *)v114 + v264;
            do
            {
              v114[v158] = *(_DWORD *)&v159[4 * v158];
              ++v158;
              v125 = v279 - v116;
            }
            while ( v279 - v116 > v158 );
          }
LABEL_227:
          v279 = v125;
          goto LABEL_18;
        }
      }
      v264 = 4 * v116;
      v99 = v260;
      _BitScanReverse(&v119, v266[v260 - 1]);
      v120 = v119 ^ 0x1F;
      if ( !v120 )
        goto LABEL_318;
    }
    __asm { tzcnt   edx, edx }
    v260 = _EDX;
    if ( *(unsigned int *)((char *)v114 + v264) )
    {
      __asm { tzcnt   edx, edx }
      if ( v260 <= _EDX )
        _EDX = v260;
      v260 = _EDX;
    }
LABEL_223:
    v124 = 32 - v120;
    if ( v116 )
    {
      if ( v260 < v124 )
      {
        v216 = v269;
        v269 = v124;
        v217 = 4 * v216 - 4;
        _mpn_rshift((int)v266, (unsigned int *)((char *)v266 + v217), v99 - (v116 - 1), v124);
        v281 -= v116;
        _mpn_rshift((int)v278, (unsigned int *)((char *)v278 + v217), v279 - (v116 - 1), v269);
        v218 = v279 - (v116 - 1);
        if ( !v278[v218 - 1] )
          v218 = v279 - v116;
        v279 = v218;
        goto LABEL_18;
      }
    }
    else if ( v260 < v124 )
    {
      _mpn_lshift(v266, (int)v266, v99, v120);
      v233 = _mpn_lshift(v278, (int)v278, v279, v120);
      if ( v233 )
      {
        v234 = v279++;
        v278[v234] = v233;
      }
      goto LABEL_18;
    }
    v269 = 32 - v120;
    _mpn_rshift((int)v266, v118, v99 - v116, 32 - v120);
    v281 -= v116 + 1;
    _mpn_rshift((int)v278, (unsigned int *)((char *)v278 + v264), v279 - v116, v269);
    v125 = v279 - v116;
    if ( !v278[v279 - v116 - 1] )
      v125 = v279 - (v116 + 1);
    goto LABEL_227;
  }
  if ( v277 >= 0 )
  {
    v27 = _mpn_lshift(&v248, (int)v272, v11, v269 + v277);
    v28 = v279++;
    v278[v28] = v27;
    v277 = 0;
    goto LABEL_18;
  }
  v177 = (char *)&unk_80D0B90;
  v178 = _mpn_lshift(&v248, (int)v272, v11, v269);
  v179 = v279;
  v264 = 12;
  v257 = 0;
  ++v279;
  v278[v179] = v178;
  v275 = 1;
  v269 = -v277;
  v277 = -v277;
  while ( 1 )
  {
    v177 -= 16;
    if ( *((_DWORD *)v177 + 3) > v269 )
      goto LABEL_360;
    v180 = *((_DWORD *)v177 + 1) - 2;
    v181 = v279 >= v180
         ? _mpn_mul(v282, v278, v279, &dword_80D0BC8[*(_DWORD *)v177], *((_DWORD *)v177 + 1) - 2)
         : _mpn_mul(v282, &dword_80D0BC8[*(_DWORD *)v177], v180, v278, v279);
    v182 = v279 + *((_DWORD *)v177 + 1);
    if ( v181 )
    {
      v260 = v182 - 2;
      v283 = v182 - 2;
    }
    else
    {
      v260 = v182 - 3;
      v283 = v182 - 3;
    }
    v259 = v282;
    v183 = &v282[v260 - 1];
    _BitScanReverse(&v184, *v183);
    v185 = v184 ^ 0x1F;
    v266 = (int *)(v184 ^ 0x1F);
    v186 = v277;
    v187 = 32 * (v260 - v279) + 31 - (v184 ^ 0x1F);
    v269 = v277;
    if ( v187 == v277 + 3 )
    {
      if ( v185 > 28 )
      {
        v273 = -1610612736;
        v274 = 0;
        _mpn_lshift(&v273, (int)&v273, 2, 32 - (_BYTE)v266);
        v186 = v277;
        v269 = v277;
        if ( v187 <= v277 + 2 )
        {
          v260 = v283;
          v259 = v282;
          goto LABEL_351;
        }
        if ( v187 != v277 + 3 )
          goto LABEL_360;
        v260 = v283;
        v183 = &v282[v283 - 1];
        v259 = v282;
        v198 = v274;
      }
      else
      {
        v273 = 0;
        v198 = 10 << (28 - v185);
        v274 = v198;
        if ( v187 <= v277 + 2 )
          goto LABEL_351;
      }
      if ( *v183 >= v198 && (*v183 != v198 || v259[v260 - 2] >= v273) )
      {
        v269 = v186;
        goto LABEL_360;
      }
    }
    else if ( v187 > v277 + 2 )
    {
      goto LABEL_360;
    }
LABEL_351:
    v269 = v186 - v187;
    v277 = v186 - v187;
    v257 |= 1 << v264;
    v188 = (int *)((char *)v266 - (v186 - v187));
    if ( v269 >= 0 )
      v188 = v266;
    v266 = v188;
    _EAX = *v259;
    if ( !*v259 )
    {
      v190 = 0;
      v258 = v177;
      v191 = v259 + 1;
      while ( 1 )
      {
        v192 = (unsigned int)v191++;
        _EDX = *(v191 - 1);
        v194 = v190 + 1;
        v195 = v190 + 1;
        if ( _EDX )
          break;
        ++v190;
      }
      v256 = v192;
      v177 = v258;
      if ( v266 != (int *)31 )
      {
        v196 = 31 - (_BYTE)v266;
        __asm { tzcnt   edx, edx }
        if ( _EDX < 31 - (int)v266 )
        {
          _mpn_rshift((int)v278, &v259[v190], v260 - v190, 31 - (_BYTE)v266);
          v279 = v283 - v190;
          v269 = v277;
          goto LABEL_360;
        }
        v259 = (unsigned int *)v256;
LABEL_457:
        _mpn_rshift((int)v278, v259, v260 - v194, v196);
        v279 = v283 - v194;
        v269 = v277;
        goto LABEL_360;
      }
      goto LABEL_371;
    }
    if ( v266 == (int *)31 )
    {
      v194 = 0;
      v195 = 0;
LABEL_371:
      v199 = v260 - v194;
      if ( v260 - v194 > 0 )
      {
        v200 = v278;
        v201 = &v259[v195];
        v202 = 0;
        do
        {
          v200[v202] = v201[v202];
          ++v202;
          v199 = v283 - v194;
        }
        while ( v283 - v194 > v202 );
      }
      v279 = v199;
      goto LABEL_360;
    }
    v194 = 0;
    __asm { tzcnt   edx, eax }
    v196 = 31 - (_BYTE)v266;
    if ( _EDX >= 31 - (int)v266 )
      goto LABEL_457;
    v230 = _mpn_lshift(v278, (int)v259, v260, (_BYTE)v266 + 1);
    v279 = v283 + 1;
    v278[v283] = v230;
    v269 = v277;
LABEL_360:
    --v264;
    if ( v177 == (char *)&unk_80D0AD0 )
      break;
    if ( v269 <= 0 )
      goto LABEL_362;
  }
  if ( v269 > 0 )
  {
    _mpn_mul_1((int)v282, (int)v278, v279, 0xAu);
    _EBX = v282;
    v220 = 4;
    v283 = v279;
    __asm { tzcnt   ecx, [ebx] }
    if ( v277 <= 4 )
      v220 = v277;
    if ( _ECX >= v220 )
    {
      _mpn_rshift((int)v278, v282, v279, v220);
    }
    else
    {
      v222 = _mpn_lshift(v278, (int)v282, v279, 32 - v220);
      if ( v222 )
      {
        v223 = v283++;
        v278[v223] = v222;
      }
    }
    v257 |= 1u;
    v279 = v283;
  }
LABEL_362:
  v277 = v257;
LABEL_18:
  v253 = *(_DWORD *)(a3 + 4);
  v29 = *(_DWORD *)(a3 + 8);
  v252 = *(_DWORD *)(__readgsdword(0xFFFFFFF0) + 4 * v29);
  if ( (_BYTE)v252 == 101 )
  {
    v276 = v29;
    v31 = *(_DWORD *)a3;
    if ( *(int *)a3 < 0 )
    {
      v256 = 14;
      v31 = 6;
      v139 = 6;
    }
    else
    {
      v256 = v31 + 8;
      v139 = v31;
    }
    goto LABEL_263;
  }
  if ( (_BYTE)v252 == 102 )
  {
    v276 = 102;
    v31 = *(_DWORD *)a3;
    v139 = *(_DWORD *)a3;
    if ( *(int *)a3 < 0 )
    {
      v31 = 6;
      v139 = 6;
    }
    if ( !v275 )
    {
      v264 = v139;
      v258 = (char *)v139;
      v269 = 1;
      v249 = 0x7FFFFFFF;
      v260 = v277 + 1;
      v256 = v277 + v31 + 2;
      goto LABEL_31;
    }
    v256 = v31 + 2;
LABEL_263:
    v264 = v139;
    v258 = (char *)v139;
    v269 = 1;
    v249 = 0x7FFFFFFF;
    v260 = 1;
    goto LABEL_31;
  }
  v30 = 1;
  if ( *(_DWORD *)a3 )
    v30 = *(_DWORD *)a3;
  if ( *(int *)a3 < 0 )
    v30 = 6;
  if ( v275 )
  {
    if ( v277 <= 4 )
    {
      v276 = 102;
      v260 = 0;
      goto LABEL_27;
    }
LABEL_299:
    v31 = v30 - 1;
    v276 = v29 - 2;
    v260 = 1;
    v264 = v30 - 1;
    v256 = v30 + 7;
  }
  else
  {
    if ( v30 <= v277 )
      goto LABEL_299;
    v276 = 102;
    v260 = v277 + 1;
LABEL_27:
    v256 = v30 + 5;
    v264 = v30 - v260;
    v31 = v30 - v260;
  }
  v249 = v30;
  v269 = 0;
  v32 = 0;
  if ( (*(_BYTE *)(a3 + 12) & 8) != 0 )
    v32 = v264;
  v258 = (char *)v32;
LABEL_31:
  if ( v267 )
  {
    v33 = *v267;
    v254 = 0;
    v34 = v33 - 1;
    LOBYTE(v266) = v33;
    v35 = 0;
    if ( v34 <= 0x7Du )
    {
      v35 = _guess_grouping_part_0(v260, v267);
      v254 = v35;
    }
    v256 += v35 + 1;
  }
  else
  {
    v254 = 0;
  }
  if ( v256 > 0x3FFFFFFC || v256 < v31 )
  {
    __writegsdword(0xFFFFFFE8, 0x22u);
    return -1;
  }
  v36 = 4 * v256 + 8;
  if ( v36 <= 0x1000 || _libc_alloca_cutoff(4 * v256 + 8) )
  {
    v250 = 1;
    v37 = alloca(v36 + 15);
    v255 = &v248;
LABEL_39:
    v257 = (unsigned int)(v255 + 2);
    if ( v275 && v276 == 102 )
    {
      v203 = (int)v255;
      v204 = v265;
      --v277;
      v251 = 0;
      v255[2] = 48;
      v42 = v203 + 16;
      *(_DWORD *)(v203 + 12) = v204;
      v266 = &v275;
    }
    else
    {
      if ( v260 <= 0 )
      {
        v41 = (_DWORD *)v257;
        v251 = 0;
        v266 = &v275;
      }
      else
      {
        v38 = (int)v255;
        v39 = 0;
        v266 = &v275;
        do
        {
          ++v39;
          v40 = hack_digit((int)&v275);
          v13 = v260 == v39;
          *(_DWORD *)(v38 + 4 * v39 + 4) = v40;
        }
        while ( !v13 );
        v251 = v39;
        v41 = (_DWORD *)(v257 + 4 * v260);
      }
      if ( (*(_BYTE *)(a3 + 12) & 8) != 0 || (int)v258 > 0 || v264 > 0 && (v279 > 1 || *v278) )
      {
        v42 = (unsigned int)(v41 + 1);
        v269 = 1;
        *v41 = v265;
      }
      else
      {
        v42 = (unsigned int)v41;
        v269 = 1;
      }
    }
    v43 = v258;
    v44 = 0;
    v259 = 0;
    v45 = (int)v258;
    if ( (int)v258 <= 0 )
      goto LABEL_49;
    do
    {
      v46 = hack_digit((int)v266);
      if ( v46 != 48 )
        goto LABEL_57;
LABEL_52:
      if ( !v269 )
      {
        ++v264;
        v269 = 0;
        if ( (int)v258 > 0 )
        {
          v259 = (unsigned int *)((char *)v259 + 1);
          v43 = (char *)v259 + (_DWORD)v258;
        }
        goto LABEL_55;
      }
LABEL_57:
      while ( 1 )
      {
        v269 = 1;
LABEL_55:
        ++v44;
        *(_DWORD *)v42 = v46;
        v42 += 4;
        v45 = (int)v43;
        if ( v44 >= (int)v43 )
          break;
        v46 = hack_digit((int)v266);
        if ( v46 == 48 )
          goto LABEL_52;
      }
LABEL_49:
      ;
    }
    while ( v264 > v44 && (v279 > 1 || *v278) );
    v264 = *(_DWORD *)(v42 - 4);
    if ( v264 == v265 )
      v264 = *(_DWORD *)(v42 - 8);
    v269 = v45;
    v108 = hack_digit((int)v266);
    v109 = (char *)v269;
    LOBYTE(v266) = v108 != 53 && v108 != 48;
    if ( !(_BYTE)v266 )
    {
      v110 = v279;
      if ( v279 == 1 )
      {
        LOBYTE(v266) = *v278 != 0;
      }
      else
      {
        if ( v281 )
        {
LABEL_100:
          LOBYTE(v266) = 1;
          goto LABEL_101;
        }
        v269 = v279;
        if ( v279 )
        {
          while ( !v278[v110 - 1] )
          {
            if ( !--v110 )
              goto LABEL_101;
          }
          goto LABEL_100;
        }
      }
    }
LABEL_101:
    v66 = v273 & 0xC00;
    if ( (v273 & 0xC00) == 1024 )
    {
      if ( !v271 )
        goto LABEL_105;
    }
    else
    {
      if ( (v273 & 0xC00) <= 0x400 )
      {
        if ( v66 )
          goto LABEL_313;
        if ( v108 <= 52 )
          goto LABEL_105;
        if ( (v264 & 1) != 0 )
        {
LABEL_268:
          v140 = (int *)v42;
          if ( v44 <= 0 )
          {
LABEL_280:
            v145 = v257;
            if ( *(v140 - 1) == v265 )
              --v140;
            v146 = v140 - 1;
            if ( (unsigned int)(v140 - 1) >= v257 )
            {
              v147 = *(v140 - 1);
              if ( v147 != 57 )
              {
LABEL_423:
                *v146 = v147 + 1;
                goto LABEL_105;
              }
              while ( 1 )
              {
                *v146-- = 48;
                if ( v145 > (unsigned int)v146 )
                  break;
                v147 = *v146;
                if ( *v146 != 57 )
                  goto LABEL_423;
              }
            }
            if ( v276 == 102 )
            {
              v232 = (int)v255;
              if ( v251 == v249 )
              {
                v240 = v265;
                *v255 = 49;
                *(_DWORD *)(v232 + 4) = v240;
                if ( (*(_BYTE *)(a3 + 12) & 8) != 0 || (v241 = 0, v44 > 0) )
                {
                  v255[v251 + 2] = 48;
                  v241 = v44 + 1;
                }
                v242 = v251;
                ++v277;
                v251 = 1;
                v44 = v241 + v242;
                v276 = (*(_WORD *)(__readgsdword(0xFFFFFFF8) + 2 * *(_DWORD *)(a3 + 8)) & 0x100) == 0 ? 101 : 69;
                v257 = (unsigned int)v255;
              }
              else
              {
                v255[1] = 49;
                ++v251;
                v257 = v232 + 4;
              }
            }
            else
            {
              v148 = v275;
              v255[2] = 49;
              v277 += v148 != 0 ? -1 : 1;
              if ( !v277 )
                v275 = 0;
            }
            if ( v249 < v251 + v44 )
            {
              v149 = v251 + v44 - v249;
              v44 = v249 - v251;
              v42 -= 4 * v149;
            }
LABEL_105:
            if ( v44 > (int)v109 )
            {
              do
              {
                if ( *(_DWORD *)(v42 - 4) != 48 )
                  break;
                --v44;
                v42 -= 4;
              }
              while ( (char *)v44 != v109 );
            }
            if ( !v44 && (*(_BYTE *)(a3 + 12) & 8) == 0 && *(_DWORD *)(v42 - 4) == v265 )
              v42 -= 4;
            if ( v267 )
            {
              if ( v260 == v251 )
              {
                v269 = v260;
              }
              else
              {
                v254 = 0;
                v269 = v251;
                LOBYTE(v266) = *v267;
                if ( (unsigned __int8)((_BYTE)v266 - 1) > 0x7Du )
                  goto LABEL_116;
                v254 = _guess_grouping_part_0(v269, v267);
              }
              if ( v254 )
              {
                v164 = v257;
                v165 = 4 * (v269 + v254);
                wmemmove(v165 + v257, v257 + 4 * v269, (int)(v42 - (v257 + 4 * v269)) >> 2);
                v166 = v164 + v165 - 4;
                v266 = (int *)v42;
                v167 = v269;
                v168 = (char)*v267;
                do
                {
                  v269 = v168;
                  v169 = (_BYTE *)(v257 + 4 * v167);
                  v170 = 0;
                  do
                  {
                    *(_DWORD *)(v166 + 4 * v170) = *(_DWORD *)&v169[4 * v170 - 4];
                    --v170;
                  }
                  while ( -v168 != v170 );
                  v167 -= v269;
                  v171 = (unsigned int *)(v166 - 4 * v269);
                  v166 = (unsigned int)(v171 - 1);
                  *v171 = v262;
                  v168 = (char)v267[1];
                  if ( (unsigned __int8)v168 > 0x7Eu )
                    break;
                  if ( (_BYTE)v168 )
                    ++v267;
                  else
                    v168 = (char)*v267;
                }
                while ( v168 < v167 );
                v269 = v167;
                v172 = v257;
                v173 = v167;
                v174 = v266;
                v175 = (int *)(v257 + 4 * v173 - 4);
                do
                {
                  v176 = *v175;
                  v166 -= 4;
                  --v175;
                  *(_DWORD *)(v166 + 4) = v176;
                }
                while ( v172 < v166 );
                v42 = (unsigned int)&v174[v254];
              }
            }
LABEL_116:
            if ( v276 == 102 )
              goto LABEL_125;
            if ( v275 )
            {
              v67 = v277;
              if ( (_BYTE)v252 == 103 && v277 == 4 )
              {
                v236 = v257;
                wmemcpy((_BYTE *)v257, byte_80CCFEC, 6);
                v237 = v236 + 8;
                *(_DWORD *)(v236 + 4) = v265;
                if ( v42 >= v236 + 8 )
                {
                  v243 = v42;
                  v247 = 4;
                  v42 += 16;
                  wmemset((_DWORD *)(v257 + 24), 48, (int)(v243 - v237) >> 2);
                }
                else
                {
                  v42 += 20;
                }
                goto LABEL_125;
              }
              *(_DWORD *)v42 = v276;
              v68 = (_DWORD *)(v42 + 8);
              v69 = 45;
            }
            else
            {
              v67 = v277;
              v68 = (_DWORD *)(v42 + 8);
              *(_DWORD *)v42 = v276;
              v69 = 43;
            }
            *(_DWORD *)(v42 + 4) = v69;
            if ( v67 <= 9 )
            {
              v68 = (_DWORD *)(v42 + 12);
              *(_DWORD *)(v42 + 8) = 48;
            }
            else
            {
              for ( i = 10; i <= v67; i *= 10 )
                ;
              do
              {
                ++v68;
                i /= 10;
                v71 = v67 % i;
                v72 = v67 / i + 48;
                v67 %= i;
                *(v68 - 1) = v72;
              }
              while ( i > 10 );
              v277 = v71;
            }
            v42 = (unsigned int)(v68 + 1);
            *v68 = v67 + 48;
LABEL_125:
            v73 = v271;
            if ( v271 )
            {
              v74 = *(_BYTE *)(a3 + 12);
            }
            else
            {
              v74 = *(_BYTE *)(a3 + 12);
              if ( (v74 & 0x50) == 0 )
                goto LABEL_128;
            }
            --v253;
LABEL_128:
            v75 = v42 - v257;
            v76 = v253 - ((int)(v42 - v257) >> 2);
            v269 = v76;
            if ( (v74 & 0x20) != 0 || (v77 = *(_DWORD *)(a3 + 16), v76 <= 0) || v77 == 48 )
            {
              v48 = 0;
            }
            else
            {
              if ( v268 )
                v48 = IO_wpadn((int)a1, v77, v76);
              else
                v48 = IO_padn((int)a1, v77, v269);
              v73 = v271;
              if ( v48 != v269 )
                goto LABEL_134;
            }
            if ( v73 )
            {
              if ( v268 )
              {
                v126 = a1[22];
                if ( v126 )
                {
                  v127 = *(_DWORD **)(v126 + 16);
                  if ( (unsigned int)v127 < *(_DWORD *)(v126 + 20) )
                  {
                    *(_DWORD *)(v126 + 16) = v127 + 1;
                    *v127 = 45;
LABEL_234:
                    ++v48;
                    v128 = *(_BYTE *)(a3 + 12);
LABEL_235:
                    if ( (v128 & 0x20) == 0 && *(_DWORD *)(a3 + 16) == 48 && v269 > 0 )
                    {
                      if ( v268 )
                        v129 = IO_wpadn((int)a1, 48, v269);
                      else
                        v129 = IO_padn((int)a1, 48, v269);
                      if ( v129 != v269 )
                        goto LABEL_134;
                      v48 += v269;
                    }
                    if ( v268 )
                    {
                      if ( (*(_BYTE *)(a3 + 13) & 8) != 0 )
                        v267 = i18n_number_rewrite_0(0, 0, 0);
                      else
                        v267 = 0;
                      v205 = v75 >> 2;
                      if ( (unsigned int)(v75 + 3) <= 6 )
                      {
                        if ( !v205 )
                        {
LABEL_462:
                          v266 = 0;
                          goto LABEL_386;
                        }
                        v267 = (unsigned __int8 *)(v257 - 4 * v48);
                        while ( 1 )
                        {
                          v226 = *(_DWORD *)&v267[4 * v48];
                          v227 = a1[22];
                          if ( v227 && (v224 = *(_DWORD **)(v227 + 16), (unsigned int)v224 < *(_DWORD *)(v227 + 20)) )
                          {
                            *(_DWORD *)(v227 + 16) = v224 + 1;
                            *v224 = v226;
                            v225 = v226 == -1;
                          }
                          else
                          {
                            v225 = _woverflow(a1, *(_DWORD *)&v267[4 * v48]) == -1;
                          }
                          if ( v225 )
                            goto LABEL_134;
                          ++v48;
                          if ( !--v205 )
                            goto LABEL_462;
                        }
                      }
                      v266 = 0;
                    }
                    else
                    {
                      v130 = 1;
                      if ( (*(_BYTE *)(a3 + 13) & 8) != 0 )
                        v130 = *(_DWORD *)(*a2 + 88);
                      v267 = (unsigned __int8 *)strlen(v263);
                      if ( v261 )
                      {
                        v264 = strlen(v261);
                        v131 = v264 * v254;
                      }
                      else
                      {
                        v131 = 0;
                        v264 = 0;
                      }
                      v132 = &v267[v256 * v130 + 2 + v131];
                      v260 = (int)v132;
                      if ( v250 )
                      {
                        v133 = alloca(v260 + 15);
                        v266 = &v248;
                      }
                      else
                      {
                        v266 = (int *)malloc(v132);
                        if ( !v266 )
                        {
LABEL_135:
                          v48 = -1;
                          free(v255);
                          return v48;
                        }
                      }
                      if ( v42 <= v257 )
                      {
                        v136 = v266;
                      }
                      else
                      {
                        v134 = (int *)v257;
                        v135 = v262;
                        v136 = v266;
                        v262 = v48;
                        v137 = v265;
                        do
                        {
                          v138 = *v134;
                          if ( *v134 == v137 )
                          {
                            v265 = v135;
                            v136 = mempcpy(v136, v263, (unsigned int)v267);
                            v135 = v265;
                          }
                          else if ( v135 == v138 )
                          {
                            v265 = v135;
                            v136 = mempcpy(v136, v261, v264);
                            v135 = v265;
                          }
                          else
                          {
                            *v136++ = v138;
                          }
                          ++v134;
                        }
                        while ( v42 > (unsigned int)v134 );
                        v48 = v262;
                      }
                      if ( (*(_BYTE *)(a3 + 13) & 8) != 0 )
                      {
                        v244 = (char *)v266 + v260;
                        v267 = i18n_number_rewrite_0(v266, (int)v136, (int)v266 + v260);
                        v136 = v244;
                      }
                      else
                      {
                        v267 = (unsigned __int8 *)v266;
                      }
                      v213 = v136 - v267;
                      v205 = v213;
                      if ( v213 <= 20 )
                      {
                        if ( v213 )
                        {
                          v267 -= v48;
                          do
                          {
                            v214 = v267[v48];
                            v215 = (unsigned __int8 *)a1[5];
                            if ( (unsigned int)v215 < a1[6] )
                            {
                              a1[5] = v215 + 1;
                              *v215 = v214;
                            }
                            else if ( _overflow((int)a1, v267[v48]) == -1 )
                            {
                              goto LABEL_134;
                            }
                            ++v48;
                            --v205;
                          }
                          while ( v205 );
                        }
LABEL_386:
                        if ( !v250 )
                        {
                          free(v266);
                          free(v255);
                        }
                        if ( (*(_BYTE *)(a3 + 12) & 0x20) == 0 || v269 <= 0 )
                          return v48;
                        v208 = v268
                             ? IO_wpadn((int)a1, *(_DWORD *)(a3 + 16), v269)
                             : IO_padn((int)a1, *(_DWORD *)(a3 + 16), v269);
                        v48 += v208;
                        if ( v208 == v269 )
                          return v48;
                        goto LABEL_134;
                      }
                    }
                    v206 = a1[37];
                    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v206 - (_DWORD)&_start___libc_IO_vtables) )
                    {
                      v265 = a1[37];
                      IO_vtable_check();
                      v206 = v265;
                    }
                    v207 = v267;
                    if ( v268 )
                      v207 = (unsigned __int8 *)v257;
                    v48 += v205;
                    if ( (*(int (__cdecl **)(_DWORD *, unsigned __int8 *, int))(v206 + 28))(a1, v207, v205) == v205 )
                      goto LABEL_386;
LABEL_134:
                    if ( v250 )
                      return -1;
                    goto LABEL_135;
                  }
                }
                v245 = 45;
                goto LABEL_474;
              }
              v209 = (int)a1;
              v210 = (_BYTE *)a1[5];
              if ( (unsigned int)v210 < a1[6] )
              {
                a1[5] = v210 + 1;
                *v210 = 45;
                goto LABEL_234;
              }
              v247 = a1[5];
              v246 = v210;
              v245 = 45;
            }
            else
            {
              v128 = *(_BYTE *)(a3 + 12);
              if ( (v128 & 0x40) != 0 )
              {
                if ( v268 )
                {
                  v150 = a1[22];
                  if ( v150 )
                  {
                    v151 = *(_DWORD **)(v150 + 16);
                    if ( (unsigned int)v151 < *(_DWORD *)(v150 + 20) )
                    {
                      *(_DWORD *)(v150 + 16) = v151 + 1;
                      *v151 = 43;
                      goto LABEL_234;
                    }
                  }
                  v247 = a1[22];
                  v246 = (_BYTE *)v150;
                  v245 = 43;
                  goto LABEL_474;
                }
                v209 = (int)a1;
                v228 = (_BYTE *)a1[5];
                if ( (unsigned int)v228 < a1[6] )
                {
                  a1[5] = v228 + 1;
                  *v228 = 43;
                  goto LABEL_234;
                }
                v247 = a1[5];
                v246 = v228;
                v245 = 43;
              }
              else
              {
                if ( (v128 & 0x10) == 0 )
                  goto LABEL_235;
                if ( v268 )
                {
                  v211 = a1[22];
                  if ( v211 )
                  {
                    v212 = *(_DWORD **)(v211 + 16);
                    if ( (unsigned int)v212 < *(_DWORD *)(v211 + 20) )
                    {
                      *(_DWORD *)(v211 + 16) = v212 + 1;
                      *v212 = 32;
                      goto LABEL_234;
                    }
                  }
                  v247 = a1[22];
                  v246 = (_BYTE *)v211;
                  v245 = 32;
LABEL_474:
                  v235 = _woverflow(a1, v245) == -1;
                  goto LABEL_475;
                }
                v209 = (int)a1;
                v231 = (_BYTE *)a1[5];
                if ( (unsigned int)v231 < a1[6] )
                {
                  a1[5] = v231 + 1;
                  *v231 = 32;
                  goto LABEL_234;
                }
                v247 = a1[5];
                v246 = v231;
                v245 = 32;
              }
            }
            v235 = _overflow(v209, v245) == -1;
LABEL_475:
            if ( v235 )
              goto LABEL_134;
            goto LABEL_234;
          }
          v141 = *(_DWORD *)(v42 - 4);
          v140 = (int *)(v42 - 4);
          if ( v141 == v265 )
          {
            v141 = v265;
            v142 = 0;
          }
          else
          {
            v142 = 0;
            if ( v141 != 57 )
            {
LABEL_414:
              if ( (int)v259 <= 0 )
                goto LABEL_278;
              v259 = (unsigned int *)((char *)v259 - 1);
              if ( v258 != v142 )
                goto LABEL_278;
              goto LABEL_277;
            }
            v269 = (int)v109;
            v143 = v265;
            while ( 1 )
            {
              *v140-- = 48;
              v141 = *v140;
              ++v142;
              if ( *v140 == v143 )
                break;
              if ( v141 != 57 )
              {
                v109 = (char *)v269;
                goto LABEL_414;
              }
            }
          }
          if ( v258 != v142 || (int)v259 <= 0 || (v259 = (unsigned int *)((char *)v259 - 1), v141 == v265) )
          {
            if ( (_BYTE)v252 == 103 && v276 == 102 && (*(_BYTE *)(a3 + 12) & 8) != 0 && v255 + 3 == v140 )
            {
              v144 = v255[3];
              if ( v255[2] == 48 )
                v109 = (char *)v259 + (_DWORD)v258 - 1;
              else
                v109 = &v258[(_DWORD)v259];
            }
            else
            {
              v144 = *v140;
              v109 = &v258[(_DWORD)v259];
            }
LABEL_279:
            if ( v265 != v144 )
              goto LABEL_105;
            goto LABEL_280;
          }
LABEL_277:
          v109 = &v258[(_DWORD)v259];
LABEL_278:
          v144 = v141 + 1;
          *v140 = v144;
          goto LABEL_279;
        }
LABEL_267:
        if ( !(_BYTE)v266 )
          goto LABEL_105;
        goto LABEL_268;
      }
      if ( v66 != 2048 )
      {
        if ( v66 == 3072 )
          goto LABEL_105;
LABEL_313:
        abort(v109);
      }
      if ( v271 )
        goto LABEL_105;
    }
    if ( v108 > 52 )
      goto LABEL_268;
    goto LABEL_267;
  }
  v255 = (int *)malloc(v36);
  if ( v255 )
  {
    v250 = 0;
    goto LABEL_39;
  }
  return -1;
}
// 8081D42: variable 'v15' is possibly undefined
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 8051620: using guessed type int IO_vtable_check(void);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80CCFEC: using guessed type _BYTE byte_80CCFEC[28];
// 80D0AC0: using guessed type _DWORD fpioconst_pow10[4];
// 80D0BC8: using guessed type unsigned int dword_80D0BC8[3438];
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08083D20) --------------------------------------------------------
int __cdecl _printf_fp(_DWORD *a1, int a2, long double **a3)
{
  return _printf_fp_l(a1, (_DWORD *)__readgsdword(0xFFFFFFDC), a2, a3);
}

//----- (08083D40) --------------------------------------------------------
int __cdecl _guess_grouping(unsigned int a1, unsigned __int8 *a2)
{
  if ( (unsigned __int8)(*a2 - 1) > 0x7Du )
    return 0;
  else
    return _guess_grouping_part_0(a1, a2);
}

//----- (08083D70) --------------------------------------------------------
int __cdecl register_printf_specifier(unsigned int a1, int a2, int a3)
{
  bool v4; // zf
  int v5; // edx
  int v6; // eax
  int v7; // edx

  if ( a1 > 0xFF )
  {
    v7 = -1;
    __writegsdword(0xFFFFFFE8, 0x16u);
    return v7;
  }
  _ECX = 1;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg ds:lock_2, ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, &lock_2);
  v5 = _printf_function_table;
  if ( _printf_function_table )
  {
    v6 = _printf_arginfo_table;
  }
  else
  {
    v6 = calloc(0x100u, 8u);
    _printf_arginfo_table = v6;
    if ( !v6 )
    {
      v7 = -1;
      goto LABEL_9;
    }
    v5 = v6 + 1024;
    _printf_function_table = v6 + 1024;
  }
  *(_DWORD *)(v5 + 4 * a1) = a2;
  *(_DWORD *)(v6 + 4 * a1) = a3;
  v7 = 0;
LABEL_9:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --lock_2 )
    _lll_unlock_wake_private(&lock_2);
  return v7;
}
// 8083DEB: variable 'v7' is possibly undefined
// 80EC6A0: using guessed type int lock_2;
// 80ECD34: using guessed type int _printf_function_table;
// 80ECD94: using guessed type int _printf_arginfo_table;

//----- (08083E50) --------------------------------------------------------
int __cdecl _printf_fphex(_DWORD *a1, int a2, double **a3)
{
  int v3; // eax
  _BYTE *v4; // edi
  int v5; // eax
  char v6; // dl
  double *v7; // eax
  char v9; // fps^1
  char v11; // ah
  __int16 v12; // fps
  char *v16; // edi
  void *v17; // esi
  int v18; // esi
  int v19; // ebx
  int v20; // eax
  int v21; // eax
  _DWORD *v22; // edx
  char *v23; // esi
  int v24; // eax
  int v25; // ecx
  _DWORD *v26; // edx
  bool v27; // al
  int v28; // eax
  int v30; // eax
  __int16 v31; // fps
  void *v36; // esi
  int v37; // eax
  _DWORD *v38; // edx
  __int64 v39; // rdi
  _BYTE *v40; // edx
  char *v41; // eax
  unsigned int v42; // eax
  unsigned int v43; // eax
  _DWORD *v44; // eax
  char *v45; // esi
  char v46; // dl
  char v47; // bl
  int v48; // eax
  unsigned __int8 v49; // bl
  char v50; // cl
  char v51; // dl
  int v52; // ecx
  unsigned __int8 v53; // dl
  int v54; // eax
  bool v55; // dl
  __int16 v56; // ax
  unsigned int v57; // ebx
  char *v58; // edi
  int v59; // eax
  char v60; // bl
  int v61; // eax
  int v62; // eax
  int v63; // ebx
  int v64; // eax
  _DWORD *v65; // edx
  int v66; // eax
  _DWORD *v67; // edx
  int *v68; // ecx
  bool v69; // al
  int v70; // ebx
  int v71; // eax
  int v72; // eax
  _DWORD *v73; // edx
  bool v74; // al
  int v75; // ebx
  int v76; // eax
  int *v77; // edx
  bool v78; // al
  int v79; // esi
  int v80; // eax
  _DWORD *v81; // edx
  bool v82; // al
  int v83; // ecx
  int v84; // eax
  __int64 v85; // kr00_8
  _DWORD *v86; // eax
  char *v87; // edx
  _DWORD *v88; // ecx
  int v89; // ecx
  char v90; // cl
  unsigned int v91; // eax
  int v92; // edi
  int v93; // esi
  _BYTE *v94; // eax
  char v95; // dl
  int v96; // eax
  _DWORD *v97; // edx
  _BYTE *v98; // eax
  _BYTE *v99; // eax
  _BYTE *v100; // eax
  int v101; // eax
  bool v102; // al
  int v103; // eax
  char v104; // al
  int v105; // eax
  _DWORD *v106; // edx
  _BYTE *v107; // eax
  unsigned __int8 v108; // al
  unsigned __int8 *v109; // edx
  char *v110; // eax
  int v111; // eax
  int v112; // ecx
  _BYTE *v113; // eax
  int v114; // edi
  _BYTE *v115; // esi
  _BYTE *v116; // eax
  char v117; // dl
  _BYTE *v118; // eax
  int v119; // eax
  _DWORD *v120; // edx
  int v121; // esi
  _BYTE *v122; // eax
  int v123; // esi
  _BYTE *v124; // eax
  char *v125; // esi
  char *v126; // edi
  char *v127; // eax
  char v128; // dl
  int v129; // esi
  int v130; // eax
  _BYTE *v131; // edi
  _BYTE *v132; // eax
  char v133; // dl
  int v134; // eax
  int *v135; // edx
  bool v136; // al
  int v137; // eax
  int *v138; // edx
  char *v139; // esi
  _DWORD *v140; // edx
  bool v141; // al
  int v142; // eax
  int v143; // ecx
  int v144; // eax
  int v145; // eax
  unsigned int v146; // ebx
  unsigned int v147; // ebx
  _BYTE *v148; // eax
  int v149; // eax
  _BYTE *v150; // eax
  int v151; // edx
  _BYTE *v152; // eax
  int v153; // ecx
  char v154; // bl
  int v155; // eax
  bool v156; // al
  int v157; // eax
  _BOOL4 v158; // [esp+0h] [ebp-13Ch]
  int v159; // [esp+0h] [ebp-13Ch]
  int v160; // [esp+4h] [ebp-138h]
  bool v161; // [esp+4h] [ebp-138h]
  int v162; // [esp+4h] [ebp-138h]
  char *v163; // [esp+4h] [ebp-138h]
  int v164; // [esp+8h] [ebp-134h]
  int v165; // [esp+8h] [ebp-134h]
  char *v166; // [esp+8h] [ebp-134h]
  char *v167; // [esp+8h] [ebp-134h]
  char *v168; // [esp+8h] [ebp-134h]
  _BYTE *v169; // [esp+Ch] [ebp-130h]
  void *v170; // [esp+Ch] [ebp-130h]
  char *v171; // [esp+Ch] [ebp-130h]
  int v172; // [esp+10h] [ebp-12Ch]
  int v173; // [esp+10h] [ebp-12Ch]
  _BYTE *v174; // [esp+14h] [ebp-128h]
  char *v175; // [esp+14h] [ebp-128h]
  int v176; // [esp+18h] [ebp-124h]
  int v177; // [esp+18h] [ebp-124h]
  char *v178; // [esp+1Ch] [ebp-120h]
  char v179; // [esp+1Ch] [ebp-120h]
  _BOOL4 v180; // [esp+20h] [ebp-11Ch]
  char *v181; // [esp+20h] [ebp-11Ch]
  int v182; // [esp+20h] [ebp-11Ch]
  char *v183; // [esp+24h] [ebp-118h]
  int v184; // [esp+28h] [ebp-114h]
  int v185; // [esp+28h] [ebp-114h]
  unsigned int v186; // [esp+2Ch] [ebp-110h]
  char v187; // [esp+33h] [ebp-109h]
  double v188; // [esp+54h] [ebp-E8h] BYREF
  long double v189; // [esp+60h] [ebp-DCh]
  char v190; // [esp+74h] [ebp-C8h] BYREF
  char v191[16]; // [esp+90h] [ebp-ACh] BYREF
  char v192[76]; // [esp+A0h] [ebp-9Ch] BYREF
  _DWORD v193[12]; // [esp+ECh] [ebp-50h] BYREF
  int v194; // [esp+11Ch] [ebp-20h]
  _DWORD v195[7]; // [esp+120h] [ebp-1Ch] BYREF

  v160 = *(_DWORD *)a2;
  v172 = *(_DWORD *)(a2 + 4);
  v158 = (*(_BYTE *)(a2 + 13) & 4) != 0;
  if ( (*(_BYTE *)(a2 + 13) & 1) != 0 )
  {
    v30 = *(_DWORD *)__readgsdword(0xFFFFFFE0);
    v4 = *(_BYTE **)(v30 + 44);
    v5 = *(_DWORD *)(v30 + 208);
  }
  else
  {
    v3 = *(_DWORD *)__readgsdword(0xFFFFFFE4);
    v4 = *(_BYTE **)(v3 + 36);
    v5 = *(_DWORD *)(v3 + 48);
  }
  v169 = v4;
  v164 = v5;
  if ( !*v4 || !v5 )
    _assert_fail("*decimal != '\\0' && decimalwc != L'\\0'", "../stdio-common/printf_fphex.c", 158, "__printf_fphex");
  v6 = *(_BYTE *)(a2 + 12);
  v7 = *a3;
  if ( (v6 & 1) == 0 )
  {
    _FST7 = *v7;
    v188 = *v7;
    _FST6 = (double)_FST7;
    __asm { fxam }
    v11 = v9;
    if ( (v11 & 0x45) == 5 )
    {
      v16 = (char *)&unk_80CCFAC;
      v17 = &unk_80CCF9B;
      if ( (*(_WORD *)(__readgsdword(0xFFFFFFF8) + 2 * *(_DWORD *)(a2 + 8)) & 0x100) == 0 )
      {
        v17 = &unk_80CCFA7;
        v16 = (char *)&unk_80CCFDC;
      }
      v170 = v17;
      __asm { fxam }
      v18 = v12 & 0x200;
      if ( (v12 & 0x200) != 0 )
        goto LABEL_10;
      goto LABEL_39;
    }
    __asm { fxam }
    v176 = v12 & 0x200;
    LODWORD(v39) = HIDWORD(v188) & 0xFFFFF;
    HIDWORD(v39) = LODWORD(v188);
    v180 = (HIDWORD(v188) & 0xFFFFF | LODWORD(v188)) == 0;
    v183 = (char *)itowa(*(_QWORD *)&v188 & 0xFFFFFFFFFFFFFLL, v195, 0x10u, *(_DWORD *)(a2 + 8) == 65);
    v174 = itoa(__PAIR64__(HIDWORD(v188) & 0xFFFFF, LODWORD(v188)), v192, 0x10u, *(_DWORD *)(a2 + 8) == 65);
    v40 = v174;
    v41 = v183;
    if ( v183 > (char *)v193 )
    {
      do
      {
        v41 -= 4;
        --v40;
        *(_DWORD *)v41 = 48;
        *v40 = 48;
      }
      while ( v41 > (char *)v193 );
      v42 = (unsigned int)&v183[~(unsigned int)v193] >> 2;
      v174 += ~v42;
      v183 += -4 * v42 - 4;
    }
    v187 = ((HIWORD(v188) & 0x7FF0) != 0) + 48;
    v184 = (HIWORD(v188) >> 4) & 0x7FF;
    if ( ((HIWORD(v188) >> 4) & 0x7FF) == 0 )
    {
      if ( v39 )
      {
        v186 = 1022;
        v184 = 1;
LABEL_55:
        if ( v194 == 48 )
        {
          v44 = v195;
          v45 = v192;
          do
          {
            --v44;
            --v45;
          }
          while ( *(v44 - 1) == 48 );
        }
        else
        {
          v45 = v192;
        }
        if ( v160 == -1 )
        {
          v160 = v45 - v174;
          goto LABEL_75;
        }
        if ( v160 >= v45 - v174 )
        {
LABEL_75:
          v57 = v186;
          v178 = itoa_word(v186, (char *)&v188, 0xAu, 0);
          v58 = &v190;
          do
          {
            v58 -= 4;
            v59 = itowa_lower_digits[v57 % 0xA];
            v57 /= 0xAu;
            *(_DWORD *)v58 = v59;
          }
          while ( v57 );
          v60 = *(_BYTE *)(a2 + 12);
          if ( v176 )
            v61 = 4;
          else
            v61 = ((v60 & 0x50) != 0) + 3;
          v181 = (char *)((char *)&v188 - v178);
          v173 = v172 - ((char *)&v188 - v178 + v160 + v61 + 2);
          if ( v160 > 0 || (v60 & 8) != 0 )
          {
            v62 = 1;
            if ( !v158 )
              v62 = strlen(v169);
            v173 -= v62;
          }
          if ( (*(_BYTE *)(a2 + 12) & 0x20) != 0 || *(_DWORD *)(a2 + 16) == 48 || v173 <= 0 )
          {
            v63 = 0;
          }
          else
          {
            if ( v158 )
              v63 = IO_wpadn((int)a1, 32, v173);
            else
              v63 = IO_padn((int)a1, 32, v173);
            if ( v173 != v63 )
              return -1;
          }
          if ( v176 )
          {
            if ( v158 )
            {
              v64 = a1[22];
              if ( v64 )
              {
                v65 = *(_DWORD **)(v64 + 16);
                if ( (unsigned int)v65 < *(_DWORD *)(v64 + 20) )
                {
                  *(_DWORD *)(v64 + 16) = v65 + 1;
                  *v65 = 45;
LABEL_94:
                  ++v63;
                  goto LABEL_95;
                }
              }
              v155 = _woverflow(a1, 45);
              goto LABEL_304;
            }
            v118 = (_BYTE *)a1[5];
            if ( (unsigned int)v118 < a1[6] )
            {
              a1[5] = v118 + 1;
              *v118 = 45;
              goto LABEL_94;
            }
            v157 = _overflow((int)a1, 45);
          }
          else
          {
            v104 = *(_BYTE *)(a2 + 12);
            if ( (v104 & 0x40) != 0 )
            {
              if ( v158 )
              {
                v105 = a1[22];
                if ( v105 )
                {
                  v106 = *(_DWORD **)(v105 + 16);
                  if ( (unsigned int)v106 < *(_DWORD *)(v105 + 20) )
                  {
                    *(_DWORD *)(v105 + 16) = v106 + 1;
                    *v106 = 43;
                    goto LABEL_94;
                  }
                }
                v155 = _woverflow(a1, 43);
                goto LABEL_304;
              }
              v148 = (_BYTE *)a1[5];
              if ( (unsigned int)v148 < a1[6] )
              {
                a1[5] = v148 + 1;
                *v148 = 43;
                goto LABEL_94;
              }
              v157 = _overflow((int)a1, 43);
            }
            else
            {
              if ( (v104 & 0x10) == 0 )
              {
LABEL_95:
                if ( !v158 )
                {
                  v107 = (_BYTE *)a1[5];
                  if ( (unsigned int)v107 >= a1[6] )
                  {
                    if ( _overflow((int)a1, 48) == -1 )
                      return -1;
                    v108 = *(_DWORD *)(a2 + 8) + 23;
                  }
                  else
                  {
                    a1[5] = v107 + 1;
                    *v107 = 48;
                    v108 = *(_DWORD *)(a2 + 8) + 23;
                  }
                  v109 = (unsigned __int8 *)a1[5];
                  if ( (unsigned int)v109 < a1[6] )
                  {
                    v70 = v63 + 2;
                    a1[5] = v109 + 1;
                    *v109 = v108;
                    if ( (*(_BYTE *)(a2 + 12) & 0x20) != 0 || *(_DWORD *)(a2 + 16) != 48 || v173 <= 0 )
                      goto LABEL_192;
                    goto LABEL_310;
                  }
                  v69 = _overflow((int)a1, v108) == -1;
LABEL_101:
                  if ( v69 )
                    return -1;
                  v70 = v63 + 2;
                  if ( (*(_BYTE *)(a2 + 12) & 0x20) != 0 || *(_DWORD *)(a2 + 16) != 48 || v173 <= 0 )
                  {
LABEL_109:
                    if ( v158 )
                    {
                      v72 = a1[22];
                      if ( v72 && (v73 = *(_DWORD **)(v72 + 16), (unsigned int)v73 < *(_DWORD *)(v72 + 20)) )
                      {
                        *(_DWORD *)(v72 + 16) = v73 + 1;
                        *v73 = v187;
                        v74 = v187 == -1;
                      }
                      else
                      {
                        v74 = _woverflow(a1, v187) == -1;
                      }
                      goto LABEL_113;
                    }
LABEL_192:
                    v110 = (char *)a1[5];
                    if ( (unsigned int)v110 < a1[6] )
                    {
                      v75 = v70 + 1;
                      a1[5] = v110 + 1;
                      *v110 = v187;
                      if ( v160 > 0 )
                      {
                        v111 = strlen(v169);
                        if ( !v111 )
                        {
LABEL_226:
                          v129 = v45 - v174;
                          v130 = v160 - v129;
                          if ( v160 <= v129 )
                            v129 = v160;
                          v162 = v130;
                          if ( v129 )
                          {
                            v168 = v58;
                            v131 = &v174[-v75];
                            do
                            {
                              v132 = (_BYTE *)a1[5];
                              v133 = v131[v75];
                              if ( (unsigned int)v132 < a1[6] )
                              {
                                a1[5] = v132 + 1;
                                *v132 = v133;
                              }
                              else if ( _overflow((int)a1, (unsigned __int8)v131[v75]) == -1 )
                              {
                                return -1;
                              }
                              ++v75;
                              --v129;
                            }
                            while ( v129 );
                            v58 = v168;
                          }
                          if ( v162 > 0 )
                          {
                            v149 = IO_padn((int)a1, 48, v162);
LABEL_274:
                            if ( v149 != v162 )
                              return -1;
                            v75 += v149;
LABEL_212:
                            v121 = *(_DWORD *)(a2 + 8) + 15;
                            if ( v158 )
                            {
LABEL_237:
                              v134 = a1[22];
                              if ( v134 && (v135 = *(int **)(v134 + 16), (unsigned int)v135 < *(_DWORD *)(v134 + 20)) )
                              {
                                *(_DWORD *)(v134 + 16) = v135 + 1;
                                *v135 = v121;
                                v136 = v121 == -1;
                              }
                              else
                              {
                                v136 = _woverflow(a1, v121) == -1;
                              }
                              goto LABEL_240;
                            }
LABEL_213:
                            v122 = (_BYTE *)a1[5];
                            if ( (unsigned int)v122 < a1[6] )
                            {
                              a1[5] = v122 + 1;
                              *v122 = v121;
                              v123 = v184 == 0 ? 43 : 45;
                              goto LABEL_215;
                            }
                            v136 = _overflow((int)a1, (unsigned __int8)v121) == -1;
LABEL_240:
                            if ( v136 )
                              return -1;
                            v123 = v184 == 0 ? 43 : 45;
                            if ( v158 )
                            {
                              v137 = a1[22];
                              if ( v137 && (v138 = *(int **)(v137 + 16), (unsigned int)v138 < *(_DWORD *)(v137 + 20)) )
                              {
                                v19 = v75 + 2;
                                *(_DWORD *)(v137 + 16) = v138 + 1;
                                *v138 = v123;
                              }
                              else
                              {
                                if ( _woverflow(a1, v184 == 0 ? 43 : 45) == -1 )
                                  return -1;
                                v19 = v75 + 2;
                              }
                              if ( v181 )
                              {
                                v163 = &v181[v19];
                                v139 = &v58[-4 * v19];
                                do
                                {
                                  v142 = a1[22];
                                  v143 = *(_DWORD *)&v139[4 * v19];
                                  if ( v142
                                    && (v140 = *(_DWORD **)(v142 + 16), (unsigned int)v140 < *(_DWORD *)(v142 + 20)) )
                                  {
                                    *(_DWORD *)(v142 + 16) = v140 + 1;
                                    *v140 = v143;
                                    v141 = v143 == -1;
                                  }
                                  else
                                  {
                                    v141 = _woverflow(a1, *(_DWORD *)&v139[4 * v19]) == -1;
                                  }
                                  if ( v141 )
                                    return -1;
                                }
                                while ( (char *)++v19 != v163 );
                              }
LABEL_255:
                              if ( (*(_BYTE *)(a2 + 12) & 0x20) == 0 )
                                return v19;
                              v144 = *(_DWORD *)(a2 + 16);
                              if ( v144 == 48 || v173 <= 0 )
                                return v19;
                              if ( v158 )
                                v145 = IO_wpadn((int)a1, v144, v173);
                              else
                                v145 = IO_padn((int)a1, v144, v173);
                              if ( v173 == v145 )
                              {
                                v19 += v173;
                                return v19;
                              }
                              return -1;
                            }
LABEL_215:
                            v124 = (_BYTE *)a1[5];
                            if ( (unsigned int)v124 >= a1[6] )
                            {
                              if ( _overflow((int)a1, v123) == -1 )
                                return -1;
                            }
                            else
                            {
                              a1[5] = v124 + 1;
                              *v124 = v123;
                            }
                            v19 = v75 + 2;
                            v125 = &v178[-v19];
                            v126 = &v181[v19];
                            if ( v181 )
                            {
                              while ( 1 )
                              {
                                v127 = (char *)a1[5];
                                v128 = v125[v19];
                                if ( (unsigned int)v127 < a1[6] )
                                {
                                  a1[5] = v127 + 1;
                                  *v127 = v128;
                                }
                                else if ( _overflow((int)a1, (unsigned __int8)v125[v19]) == -1 )
                                {
                                  return -1;
                                }
                                if ( v126 == (char *)++v19 )
                                  goto LABEL_255;
                              }
                            }
                            goto LABEL_255;
                          }
LABEL_322:
                          v121 = *(_DWORD *)(a2 + 8) + 15;
                          goto LABEL_213;
                        }
                        goto LABEL_195;
                      }
LABEL_211:
                      if ( (*(_BYTE *)(a2 + 12) & 8) == 0 )
                        goto LABEL_212;
LABEL_115:
                      if ( v158 )
                      {
                        v76 = a1[22];
                        if ( v76 && (v77 = *(int **)(v76 + 16), (unsigned int)v77 < *(_DWORD *)(v76 + 20)) )
                        {
                          *(_DWORD *)(v76 + 16) = v77 + 1;
                          *v77 = v164;
                          v78 = v164 == -1;
                        }
                        else
                        {
                          v78 = _woverflow(a1, v164) == -1;
                        }
                        if ( v78 )
                          return -1;
                        ++v75;
                        if ( v160 <= 0 )
                          goto LABEL_236;
                        v79 = v45 - v174;
                        v80 = v160 - v79;
                        if ( v160 <= v79 )
                          v79 = v160;
                        v162 = v80;
                        if ( v79 )
                        {
                          v166 = &v183[-4 * v75];
                          while ( 1 )
                          {
                            v83 = *(_DWORD *)&v166[4 * v75];
                            v84 = a1[22];
                            if ( v84 && (v81 = *(_DWORD **)(v84 + 16), (unsigned int)v81 < *(_DWORD *)(v84 + 20)) )
                            {
                              *(_DWORD *)(v84 + 16) = v81 + 1;
                              *v81 = v83;
                              v82 = v83 == -1;
                            }
                            else
                            {
                              v82 = _woverflow(a1, *(_DWORD *)&v166[4 * v75]) == -1;
                            }
                            if ( v82 )
                              return -1;
                            ++v75;
                            if ( !--v79 )
                            {
                              if ( v162 <= 0 )
                                goto LABEL_236;
                              goto LABEL_278;
                            }
                          }
                        }
                        if ( v80 <= 0 )
                        {
LABEL_236:
                          v121 = *(_DWORD *)(a2 + 8) + 15;
                          goto LABEL_237;
                        }
LABEL_278:
                        v149 = IO_wpadn((int)a1, 48, v162);
                        goto LABEL_274;
                      }
                      v111 = strlen(v169);
                      if ( !v111 )
                      {
LABEL_225:
                        if ( v160 <= 0 )
                          goto LABEL_322;
                        goto LABEL_226;
                      }
LABEL_195:
                      v167 = v45;
                      v112 = v75 + v111;
                      v113 = v169;
                      v171 = v58;
                      v114 = v112;
                      v115 = &v113[-v75];
                      do
                      {
                        v116 = (_BYTE *)a1[5];
                        v117 = v115[v75];
                        if ( (unsigned int)v116 < a1[6] )
                        {
                          a1[5] = v116 + 1;
                          *v116 = v117;
                        }
                        else if ( _overflow((int)a1, (unsigned __int8)v115[v75]) == -1 )
                        {
                          return -1;
                        }
                        ++v75;
                      }
                      while ( v75 != v114 );
                      v45 = v167;
                      v58 = v171;
                      goto LABEL_225;
                    }
                    v74 = _overflow((int)a1, (unsigned __int8)v187) == -1;
LABEL_113:
                    if ( v74 )
                      return -1;
                    v75 = v70 + 1;
                    if ( v160 > 0 )
                      goto LABEL_115;
                    goto LABEL_211;
                  }
                  if ( v158 )
                  {
                    v71 = IO_wpadn((int)a1, 48, v173);
LABEL_107:
                    if ( v173 != v71 )
                      return -1;
                    v70 += v173;
                    goto LABEL_109;
                  }
LABEL_310:
                  v71 = IO_padn((int)a1, 48, v173);
                  goto LABEL_107;
                }
                v66 = a1[22];
                if ( v66 && (v67 = *(_DWORD **)(v66 + 16), (unsigned int)v67 < *(_DWORD *)(v66 + 20)) )
                {
                  *(_DWORD *)(v66 + 16) = v67 + 1;
                  *v67 = 48;
                  v177 = *(_DWORD *)(a2 + 8) + 23;
                }
                else
                {
                  if ( _woverflow(a1, 48) == -1 )
                    return -1;
                  v177 = *(_DWORD *)(a2 + 8) + 23;
                  v66 = a1[22];
                  if ( !v66 )
                  {
LABEL_270:
                    v69 = _woverflow(a1, v177) == -1;
                    goto LABEL_101;
                  }
                }
                v68 = *(int **)(v66 + 16);
                if ( (unsigned int)v68 < *(_DWORD *)(v66 + 20) )
                {
                  *(_DWORD *)(v66 + 16) = v68 + 1;
                  *v68 = v177;
                  v69 = v177 == -1;
                  goto LABEL_101;
                }
                goto LABEL_270;
              }
              if ( v158 )
              {
                v119 = a1[22];
                if ( v119 )
                {
                  v120 = *(_DWORD **)(v119 + 16);
                  if ( (unsigned int)v120 < *(_DWORD *)(v119 + 20) )
                  {
                    *(_DWORD *)(v119 + 16) = v120 + 1;
                    *v120 = 32;
                    goto LABEL_94;
                  }
                }
                v155 = _woverflow(a1, 32);
LABEL_304:
                v156 = v155 == -1;
                goto LABEL_305;
              }
              v150 = (_BYTE *)a1[5];
              if ( (unsigned int)v150 < a1[6] )
              {
                a1[5] = v150 + 1;
                *v150 = 32;
                goto LABEL_94;
              }
              v157 = _overflow((int)a1, 32);
            }
          }
          v156 = v157 == -1;
LABEL_305:
          if ( v156 )
            return -1;
          goto LABEL_94;
        }
        if ( v160 <= 0 )
          v46 = v187;
        else
          v46 = v174[v160 - 1];
        v47 = v46 - 55;
        v48 = (char)v174[v160];
        if ( (unsigned __int8)(v46 - 65) > 5u )
        {
          v49 = v46 - 97;
          v50 = v46 - 87;
          v51 = v46 - 48;
          if ( v49 > 5u )
            v50 = v51;
          v47 = v50;
        }
        v52 = v48 - 55;
        if ( (unsigned __int8)(v48 - 65) > 5u )
        {
          v53 = v48 - 97;
          v52 = v48 - 87;
          v54 = v48 - 48;
          if ( v53 > 5u )
            v52 = v54;
        }
        v55 = 1;
        if ( (v52 & 7) == 0 )
          v55 = v45 - v174 > v160 + 1;
        v56 = LOWORD(v189) & 0xC00;
        if ( (LOWORD(v189) & 0xC00) == 1024 )
        {
          if ( !v176 )
            goto LABEL_75;
        }
        else
        {
          if ( (LOWORD(v189) & 0xC00u) <= 0x400 )
          {
            if ( v56 )
              goto LABEL_312;
            if ( v52 <= 7 )
              goto LABEL_75;
            if ( (v47 & 1) != 0 )
              goto LABEL_288;
            goto LABEL_287;
          }
          if ( v56 != 2048 )
          {
            if ( v56 == 3072 )
              goto LABEL_75;
LABEL_312:
            abort(v52);
          }
          if ( v176 )
            goto LABEL_75;
        }
        if ( v52 > 7 )
        {
LABEL_288:
          v151 = v160 - 1;
          if ( v160 - 1 >= 0 )
          {
            v152 = &v174[v151];
            v153 = (char)v174[v151];
            v179 = v174[v151];
            if ( (_BYTE)v153 == 57 )
            {
LABEL_298:
              *(_DWORD *)&v183[4 * v151] = *(_DWORD *)(a2 + 8);
              *v152 = *(_DWORD *)(a2 + 8);
              goto LABEL_75;
            }
            if ( *(int *)(__readgsdword(0xFFFFFFF0) + 4 * v153) <= 101 )
            {
LABEL_300:
              *v152 = v179 + 1;
              ++*(_DWORD *)&v183[4 * v151];
              goto LABEL_75;
            }
            v182 = v160 - 2 - (_DWORD)v152;
            while ( 1 )
            {
              *v152 = 48;
              *(_DWORD *)&v183[4 * v151--] = 48;
              if ( v151 == -1 )
                break;
              v154 = v174[v151];
              v152 = &v152[v182 + (_DWORD)v174];
              if ( v154 == 57 )
                goto LABEL_298;
              if ( *(int *)(__readgsdword(0xFFFFFFF0) + 4 * v154) <= 101 )
              {
                v179 = v174[v151];
                goto LABEL_300;
              }
            }
          }
          if ( v187 == 57 )
          {
            v187 = *(_BYTE *)(a2 + 8);
          }
          else if ( *(int *)(__readgsdword(0xFFFFFFF0) + 4 * v187) > 101 )
          {
            if ( v184 )
            {
              if ( (int)(v186 - 4) <= 0 )
              {
                v187 = 49;
                v184 = 0;
                v186 = 4 - v186;
              }
              else
              {
                v186 -= 4;
                v187 = 49;
              }
            }
            else
            {
              v186 += 4;
              v187 = 49;
            }
          }
          else
          {
            ++v187;
          }
          goto LABEL_75;
        }
LABEL_287:
        if ( !v55 )
          goto LABEL_75;
        goto LABEL_288;
      }
      v186 = 0;
LABEL_178:
      v45 = v174;
      if ( v160 == -1 )
        v160 = 0;
      goto LABEL_75;
    }
    if ( ((HIWORD(v188) >> 4) & 0x7FFu) <= 0x3FE )
    {
      v147 = 1023 - v184;
      v184 = 1;
      v186 = v147;
    }
    else
    {
      v43 = v184 - 1023;
      v184 = 0;
      v186 = v43;
    }
LABEL_54:
    if ( !v180 )
      goto LABEL_55;
    goto LABEL_178;
  }
  _FST7 = *(long double *)v7;
  __asm { fxam }
  if ( (HIBYTE(v31) & 0x45) != 5 )
  {
    v189 = _FST7;
    v176 = v31 & 0x200;
    v85 = *(_QWORD *)&v189;
    v180 = *(_QWORD *)&v189 == 0LL;
    v175 = itoa(*(unsigned __int64 *)&v189, v192, 0x10u, *(_DWORD *)(a2 + 8) == 65);
    v86 = itowa(*(unsigned __int64 *)&v189, v195, 0x10u, *(_DWORD *)(a2 + 8) == 65);
    v87 = v175;
    v88 = v86;
    if ( v175 > v191 )
    {
      do
      {
        --v87;
        --v88;
        *v87 = 48;
        *v88 = 48;
      }
      while ( v87 != v191 );
      v89 = v175 - 1 - v87;
      v175 = v191;
      v86 += -v89 - 1;
    }
    v183 = (char *)(v86 + 1);
    v90 = *v175;
    v174 = v175 + 1;
    v185 = WORD4(v189) & 0x7FFF;
    v187 = v90;
    if ( (WORD4(v189) & 0x7FFF) != 0 )
    {
      if ( (WORD4(v189) & 0x7FFFu) <= 0x4001 )
      {
        v146 = 16386 - v185;
        v184 = 1;
        v186 = v146;
      }
      else
      {
        v91 = v185 - 16386;
        v184 = 0;
        v186 = v91;
      }
    }
    else
    {
      v186 = v85 != 0 ? 0x4001 : 0;
      v184 = v85 != 0;
    }
    goto LABEL_54;
  }
  v16 = (char *)&unk_80CCFAC;
  v36 = &unk_80CCF9B;
  if ( (*(_WORD *)(__readgsdword(0xFFFFFFF8) + 2 * *(_DWORD *)(a2 + 8)) & 0x100) == 0 )
  {
    v36 = &unk_80CCFA7;
    v16 = (char *)&unk_80CCFDC;
  }
  v170 = v36;
  v18 = v31 & 0x200;
  if ( (v31 & 0x200) != 0 )
  {
LABEL_10:
    v19 = v172 - 4;
    v161 = v172 - 4 > 0;
    if ( (v6 & 0x20) != 0 || v172 - 4 <= 0 )
    {
      v165 = v172 - 4;
      v19 = 0;
      goto LABEL_16;
    }
    goto LABEL_12;
  }
LABEL_39:
  if ( (v6 & 0x50) != 0 )
  {
    v165 = v172 - 4;
    v161 = v172 - 4 > 0;
    if ( (v6 & 0x20) != 0 || v172 - 4 <= 0 )
    {
      v19 = 0;
      goto LABEL_43;
    }
    v19 = v172 - 4;
  }
  else
  {
    v19 = v172 - 3;
    v161 = v172 - 3 > 0;
    if ( (v6 & 0x20) != 0 || v172 - 3 <= 0 )
    {
      v165 = v172 - 3;
      v19 = 0;
      goto LABEL_43;
    }
  }
LABEL_12:
  if ( v158 )
    v20 = IO_wpadn((int)a1, 32, v19);
  else
    v20 = IO_padn((int)a1, 32, v19);
  if ( v20 != v19 )
    return -1;
  v165 = v19;
  v161 = 1;
  if ( !v18 )
  {
    v6 = *(_BYTE *)(a2 + 12);
LABEL_43:
    if ( (v6 & 0x40) != 0 )
    {
      if ( v158 )
      {
        v37 = a1[22];
        if ( v37 )
        {
          v38 = *(_DWORD **)(v37 + 16);
          if ( (unsigned int)v38 < *(_DWORD *)(v37 + 20) )
          {
            *(_DWORD *)(v37 + 16) = v38 + 1;
            *v38 = 43;
            goto LABEL_20;
          }
        }
        v101 = _woverflow(a1, 43);
        goto LABEL_170;
      }
      v99 = (_BYTE *)a1[5];
      if ( (unsigned int)v99 < a1[6] )
      {
        a1[5] = v99 + 1;
        *v99 = 43;
        goto LABEL_20;
      }
      v103 = _overflow((int)a1, 43);
    }
    else
    {
      if ( (v6 & 0x10) == 0 )
        goto LABEL_21;
      if ( v158 )
      {
        v96 = a1[22];
        if ( v96 )
        {
          v97 = *(_DWORD **)(v96 + 16);
          if ( (unsigned int)v97 < *(_DWORD *)(v96 + 20) )
          {
            *(_DWORD *)(v96 + 16) = v97 + 1;
            *v97 = 32;
            goto LABEL_20;
          }
        }
        v101 = _woverflow(a1, 32);
        goto LABEL_170;
      }
      v100 = (_BYTE *)a1[5];
      if ( (unsigned int)v100 < a1[6] )
      {
        a1[5] = v100 + 1;
        *v100 = 32;
        goto LABEL_20;
      }
      v103 = _overflow((int)a1, 32);
    }
LABEL_174:
    v102 = v103 == -1;
LABEL_171:
    if ( v102 )
      return -1;
    goto LABEL_20;
  }
LABEL_16:
  if ( !v158 )
  {
    v98 = (_BYTE *)a1[5];
    if ( (unsigned int)v98 < a1[6] )
    {
      a1[5] = v98 + 1;
      *v98 = 45;
      goto LABEL_20;
    }
    v103 = _overflow((int)a1, 45);
    goto LABEL_174;
  }
  v21 = a1[22];
  if ( !v21 || (v22 = *(_DWORD **)(v21 + 16), (unsigned int)v22 >= *(_DWORD *)(v21 + 20)) )
  {
    v101 = _woverflow(a1, 45);
LABEL_170:
    v102 = v101 == -1;
    goto LABEL_171;
  }
  *(_DWORD *)(v21 + 16) = v22 + 1;
  *v22 = 45;
LABEL_20:
  ++v19;
LABEL_21:
  if ( v158 )
  {
    v159 = v19 + 3;
    v23 = &v16[-4 * v19];
    while ( 1 )
    {
      v24 = a1[22];
      v25 = *(_DWORD *)&v23[4 * v19];
      if ( v24 && (v26 = *(_DWORD **)(v24 + 16), (unsigned int)v26 < *(_DWORD *)(v24 + 20)) )
      {
        *(_DWORD *)(v24 + 16) = v26 + 1;
        *v26 = v25;
        v27 = v25 == -1;
      }
      else
      {
        v27 = _woverflow(a1, *(_DWORD *)&v23[4 * v19]) == -1;
      }
      if ( v27 )
        return -1;
      if ( ++v19 == v159 )
      {
        if ( (*(_BYTE *)(a2 + 12) & 0x20) != 0 && v161 )
        {
          v28 = IO_wpadn((int)a1, 32, v165);
          goto LABEL_31;
        }
        return v19;
      }
    }
  }
  v92 = v19 + 3;
  v93 = (int)v170 - v19;
  do
  {
    v94 = (_BYTE *)a1[5];
    v95 = *(_BYTE *)(v93 + v19);
    if ( (unsigned int)v94 >= a1[6] )
    {
      if ( _overflow((int)a1, *(unsigned __int8 *)(v93 + v19)) == -1 )
        return -1;
    }
    else
    {
      a1[5] = v94 + 1;
      *v94 = v95;
    }
    ++v19;
  }
  while ( v19 != v92 );
  if ( (*(_BYTE *)(a2 + 12) & 0x20) == 0 || !v161 )
    return v19;
  v28 = IO_padn((int)a1, 32, v165);
LABEL_31:
  if ( v28 == v165 )
  {
    v19 += v28;
    return v19;
  }
  return -1;
}
// 8083F02: variable 'v9' is possibly undefined
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 80D4220: using guessed type int itowa_lower_digits[36];
// 8083E50: using guessed type _DWORD var_1C[7];
// 8083E50: using guessed type _DWORD var_50[12];

//----- (080854A0) --------------------------------------------------------
int __usercall register_printf_modifier@<eax>(long double a1@<st0>, char *a2)
{
  char *v2; // ebx
  bool v4; // zf
  int v5; // ebx
  int v6; // edi
  int v7; // ecx
  int v8; // edx

  v2 = a2;
  if ( (unsigned int)(*(_DWORD *)a2 - 1) > 0xFE )
  {
LABEL_18:
    __writegsdword(0xFFFFFFE8, 0x16u);
    return -1;
  }
  while ( 1 )
  {
    v2 += 4;
    if ( !*(_DWORD *)v2 )
      break;
    if ( *(_DWORD *)v2 > 0xFFu )
      goto LABEL_18;
  }
  if ( (unsigned int)(next_bit - 16) <= 7 )
  {
    __writegsdword(0xFFFFFFE8, 0x1Cu);
    return -1;
  }
  _ECX = 1;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg ds:lock_3, ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, &lock_3);
  if ( (_printf_modifier_table || (_printf_modifier_table = calloc(0xFFu, 4u)) != 0)
    && (v5 = v2 - a2, (v6 = malloc(a1, v5 + 8)) != 0) )
  {
    v7 = next_bit;
    *(_DWORD *)v6 = *(_DWORD *)(_printf_modifier_table + 4 * (unsigned __int8)*a2);
    next_bit = v7 + 1;
    *(_DWORD *)(v6 + 4) = 1 << v7;
    wmemcpy((_BYTE *)(v6 + 8), a2 + 4, v5 >> 2);
    *(_DWORD *)(_printf_modifier_table + 4 * (unsigned __int8)*a2) = v6;
    v8 = *(_DWORD *)(v6 + 4);
  }
  else
  {
    v8 = -1;
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --lock_3 )
    _lll_unlock_wake_private(&lock_3);
  return v8;
}
// 808559C: variable 'v8' is possibly undefined
// 80EC6A4: using guessed type int next_bit;
// 80EC6A8: using guessed type int lock_3;
// 80ECD38: using guessed type int _printf_modifier_table;

//----- (08085600) --------------------------------------------------------
int __cdecl _handle_registered_modifier_mb(unsigned __int8 **a1, int a2)
{
  int v2; // edi
  _DWORD *v3; // esi
  unsigned __int8 *v4; // ebp
  int v5; // edi
  _DWORD *v6; // ecx
  int v7; // eax
  unsigned __int8 *v8; // edx
  int v9; // eax
  int result; // eax
  unsigned __int8 *v11; // [esp+4h] [ebp-20h]
  int v12; // [esp+8h] [ebp-1Ch]
  int v13; // [esp+Ch] [ebp-18h]
  unsigned __int8 *v14; // [esp+10h] [ebp-14h]

  v2 = (int)*a1;
  v12 = (int)*a1;
  v3 = *(_DWORD **)(_printf_modifier_table + 4 * **a1);
  if ( !v3 )
    return 1;
  v4 = (unsigned __int8 *)(v2 + 1);
  v5 = *(unsigned __int8 *)(v2 + 1);
  v14 = 0;
  v11 = 0;
  v13 = 0;
  do
  {
    v6 = v3 + 2;
    if ( !(_BYTE)v5 )
    {
      v8 = v4;
      goto LABEL_10;
    }
    v7 = v3[2];
    if ( v7 )
    {
      if ( v7 != v5 )
        goto LABEL_13;
      v8 = v4;
      while ( 1 )
      {
        v9 = *++v8;
        ++v6;
        if ( !(_BYTE)v9 )
          break;
        if ( !*v6 )
          goto LABEL_11;
        if ( *v6 != v9 )
          goto LABEL_13;
      }
LABEL_10:
      if ( *v6 )
        goto LABEL_13;
      goto LABEL_11;
    }
    v8 = v4;
LABEL_11:
    if ( (int)&v8[-v12] > (int)v11 )
    {
      v14 = v8;
      v11 = &v8[-v12];
      v13 = v3[1];
    }
LABEL_13:
    v3 = (_DWORD *)*v3;
  }
  while ( v3 );
  result = 1;
  if ( v13 )
  {
    *(_WORD *)(a2 + 14) |= v13;
    *a1 = v14;
    return 0;
  }
  return result;
}
// 80ECD38: using guessed type int _printf_modifier_table;

//----- (080856F0) --------------------------------------------------------
int __cdecl _handle_registered_modifier_wc(_DWORD *a1, int a2)
{
  _DWORD *v2; // ebp
  _DWORD *v3; // esi
  int v4; // edi
  _DWORD *v5; // ebp
  _DWORD *v6; // edx
  int v7; // eax
  _DWORD *v8; // eax
  int result; // eax
  int v10; // [esp+0h] [ebp-20h]
  _DWORD *v11; // [esp+4h] [ebp-1Ch]
  int v12; // [esp+8h] [ebp-18h]
  _DWORD *v13; // [esp+Ch] [ebp-14h]

  v2 = (_DWORD *)*a1;
  v3 = *(_DWORD **)(_printf_modifier_table + 4 * *(_DWORD *)*a1);
  if ( !v3 )
    return 1;
  v4 = v2[1];
  v11 = (_DWORD *)*a1;
  v13 = 0;
  v10 = 0;
  v12 = 0;
  v5 = v2 + 1;
  do
  {
    v6 = v3 + 2;
    if ( !v4 )
    {
      v8 = v5;
      goto LABEL_10;
    }
    v7 = v3[2];
    if ( v7 )
    {
      if ( v4 != v7 )
        goto LABEL_13;
      v8 = v5;
      while ( 1 )
      {
        ++v8;
        ++v6;
        if ( !*v8 )
          break;
        if ( !*v6 )
          goto LABEL_11;
        if ( *v8 != *v6 )
          goto LABEL_13;
      }
LABEL_10:
      if ( *v6 )
        goto LABEL_13;
      goto LABEL_11;
    }
    v8 = v5;
LABEL_11:
    if ( v8 - v11 > v10 )
    {
      v13 = v8;
      v10 = v8 - v11;
      v12 = v3[1];
    }
LABEL_13:
    v3 = (_DWORD *)*v3;
  }
  while ( v3 );
  result = 1;
  if ( v12 )
  {
    *(_WORD *)(a2 + 14) |= v12;
    *a1 = v13;
    return 0;
  }
  return result;
}
// 80ECD38: using guessed type int _printf_modifier_table;

//----- (080857D0) --------------------------------------------------------
int __cdecl register_printf_type(int a1)
{
  bool v2; // zf
  int v3; // edx

  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg ds:lock_4, ecx }
  if ( !v2 )
    _lll_lock_wait_private(0, &lock_4);
  if ( _printf_va_arg_table || (_printf_va_arg_table = calloc(0xF8u, 4u)) != 0 )
  {
    v3 = pa_next_type;
    if ( pa_next_type == 256 )
    {
      v3 = -1;
      __writegsdword(0xFFFFFFE8, 0x1Cu);
    }
    else
    {
      ++pa_next_type;
      *(_DWORD *)(_printf_va_arg_table + 4 * v3 - 32) = a1;
    }
  }
  else
  {
    v3 = -1;
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --lock_4 )
    _lll_unlock_wake_private(&lock_4);
  return v3;
}
// 8085844: variable 'v3' is possibly undefined
// 80EBF18: using guessed type int pa_next_type;
// 80EC6AC: using guessed type int lock_4;
// 80ECD98: using guessed type int _printf_va_arg_table;

//----- (08085890) --------------------------------------------------------
int __usercall fprintf@<eax>(long double a1@<st0>, int a2, unsigned int a3, ...)
{
  va_list va; // [esp+18h] [ebp+Ch] BYREF

  va_start(va, a3);
  return vfprintf(a1, a2, a3, (char *)va);
}

//----- (080858B0) --------------------------------------------------------
int __usercall read_int_0@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v1; // ecx
  int v2; // edx
  _DWORD *v3; // edi
  unsigned int v4; // ebx
  int v5; // edx
  _DWORD *v7; // ebx

  v1 = (_DWORD *)*a1;
  v2 = *(_DWORD *)*a1 - 48;
  while ( 1 )
  {
    v3 = v1 + 1;
    v4 = v1[1] - 48;
    if ( v4 > 9 )
      goto LABEL_9;
    if ( v2 < 0 )
      goto LABEL_7;
    if ( v2 <= 214748364 )
    {
      v5 = 10 * v2;
      if ( v5 <= (int)(0x7FFFFFFF - v4) )
      {
        v2 = v4 + v5;
        goto LABEL_7;
      }
    }
    v7 = v1 + 2;
    if ( (unsigned int)(v1[2] - 48) > 9 )
      break;
    v7 = v1 + 3;
    if ( (unsigned int)(v1[3] - 48) > 9 )
      break;
    v3 = v1 + 4;
    if ( (unsigned int)(v1[4] - 48) > 9 )
    {
      v2 = -1;
LABEL_9:
      *a1 = v3;
      return v2;
    }
    v3 = v1 + 5;
    v2 = -1;
    if ( (unsigned int)(v1[5] - 48) > 9 )
      goto LABEL_9;
LABEL_7:
    v1 = v3;
  }
  *a1 = v7;
  return -1;
}

//----- (08085950) --------------------------------------------------------
_BYTE *__userpurge group_number_0@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>, char *a3@<ecx>, int a4)
{
  _BYTE *v4; // esi
  int v5; // ebx
  int v6; // edi
  void *v7; // esp
  char *v8; // eax
  unsigned int v9; // edx
  char *v10; // ecx
  int v11; // ebx
  char *v12; // ecx
  _BYTE v13[12]; // [esp+0h] [ebp-28h] BYREF
  char *v14; // [esp+Ch] [ebp-1Ch]

  v4 = a2;
  v5 = *a3;
  if ( (unsigned __int8)(v5 - 1) <= 0x7Du )
  {
    v6 = (int)(a3 + 1);
    v7 = alloca(a2 - result + 15);
    v14 = v13;
    v8 = (char *)mempcpy(v13, result, a2 - result);
    v9 = (unsigned int)v14;
    if ( v14 >= v8 )
    {
      return v4;
    }
    else
    {
      v10 = v8 - 4;
      v14 = (char *)v6;
      v11 = v5 - 1;
      result = v4 - 4;
      *((_DWORD *)v4 - 1) = *(_DWORD *)v10;
      if ( v11 )
        goto LABEL_11;
      while ( v9 < (unsigned int)v10 )
      {
        result = v4 - 8;
        *((_DWORD *)v4 - 2) = a4;
        v11 = *v14;
        if ( (unsigned __int8)v11 > 0x7Eu )
        {
          do
          {
            v12 = v10 - 4;
            result -= 4;
            *(_DWORD *)result = *(_DWORD *)v12;
            if ( v9 >= (unsigned int)v12 )
              break;
            v10 = v12 - 4;
            result -= 4;
            *(_DWORD *)result = *(_DWORD *)v10;
          }
          while ( v9 < (unsigned int)v10 );
          return result;
        }
        if ( (_BYTE)v11 )
          ++v14;
        else
          v11 = *(v14 - 1);
        for ( v4 -= 8; ; v4 = result )
        {
          v10 -= 4;
          --v11;
          result = v4 - 4;
          *((_DWORD *)v4 - 1) = *(_DWORD *)v10;
          if ( !v11 )
            break;
LABEL_11:
          if ( v9 >= (unsigned int)v10 )
            return result;
        }
      }
    }
  }
  return result;
}

//----- (08085A50) --------------------------------------------------------
_BYTE *__usercall i18n_number_rewrite_1@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  _BYTE *v3; // edi
  unsigned int v5; // esi
  unsigned int v6; // edx
  void *v7; // esp
  unsigned int *v8; // esi
  unsigned int *v9; // ebx
  unsigned int *v10; // eax
  _DWORD *i; // ecx
  unsigned int v12; // edx
  bool v14; // zf
  _BOOL4 v15; // eax
  _BYTE *v16; // [esp+0h] [ebp-44h]
  int v17; // [esp+Ch] [ebp-38h] BYREF
  unsigned int v18; // [esp+18h] [ebp-2Ch]
  unsigned int v19; // [esp+1Ch] [ebp-28h]
  unsigned int v20; // [esp+20h] [ebp-24h]
  unsigned int v21; // [esp+24h] [ebp-20h]
  _DWORD *v22; // [esp+28h] [ebp-1Ch]

  v3 = a1;
  v5 = a2 - (_DWORD)a1;
  v22 = (_DWORD *)wctrans(135056004);
  v20 = towctrans(0x2Eu, v22);
  v19 = towctrans(0x2Cu, v22);
  v6 = v5;
  if ( v5 <= 0x1000 || (v21 = v5, v15 = _libc_alloca_cutoff(v5), v6 = v5, v15) )
  {
    v21 = 1;
    v7 = alloca(v6 + 15);
    v8 = (unsigned int *)&v17;
  }
  else
  {
    v18 = v5;
    v8 = (unsigned int *)malloc(v5);
    if ( !v8 )
      return v3;
    v21 = 0;
    v6 = v18;
  }
  v9 = (unsigned int *)(a3 - 4);
  v16 = v3;
  v3 = v9 + 1;
  v10 = (unsigned int *)(mempcpy(v8, v16, v6) - 2);
  for ( i = (_DWORD *)__readgsdword(0xFFFFFFD8); v8 <= v10; v3 = v9 + 1 )
  {
    v12 = *v10;
    if ( *v10 - 48 <= 9 )
    {
      *v9 = *(_DWORD *)(*i + 4 * v12 + 48);
    }
    else
    {
      if ( v22 )
      {
        if ( (v12 & 0xFFFFFFFD) == 44 )
        {
          v14 = v12 == 46;
          v12 = v20;
          if ( !v14 )
            v12 = v19;
        }
      }
      *v9 = v12;
    }
    --v10;
    --v9;
  }
  if ( !v21 )
    free(v8);
  return v3;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08085B80) --------------------------------------------------------
int __usercall IO_helper_overflow_0@<eax>(long double a1@<st0>, _DWORD *a2, int a3)
{
  _DWORD *v3; // edx
  int v4; // eax
  int v5; // ebx
  int v6; // ecx
  int v7; // ebp
  int v8; // eax
  int v9; // ebp
  int *v10; // eax
  int v12; // [esp+Ch] [ebp-20h]

  v3 = (_DWORD *)a2[22];
  v4 = v3[3];
  v5 = (v3[4] - v4) >> 2;
  if ( v5 )
  {
    v6 = a2[83];
    v7 = *(_DWORD *)(v6 + 148);
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v7
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
    {
      v12 = a2[83];
      IO_vtable_check(a1);
      v6 = v12;
      v4 = *(_DWORD *)(a2[22] + 12);
    }
    v8 = (*(int (__cdecl **)(int, int, int))(v7 + 28))(v6, v4, v5);
    if ( (unsigned int)(v8 - 1) > 0xFFFFFFFD )
      return -1;
    v9 = 4 * v8;
    wmemmove(*(_DWORD *)(a2[22] + 12), *(_DWORD *)(a2[22] + 12) + 4 * v8, v5 - v8);
    v3 = (_DWORD *)a2[22];
    v3[4] -= v9;
  }
  v10 = (int *)v3[4];
  if ( (unsigned int)v10 >= v3[5] )
    return _woverflow(a2, a3);
  v3[4] = v10 + 1;
  *v10 = a3;
  return a3;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (08085C60) --------------------------------------------------------
int __usercall printf_positional_0@<eax>(
        _DWORD *a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        long double a4@<st0>,
        int a5,
        long double **a6,
        unsigned int a7,
        unsigned int a8,
        _DWORD *a9,
        _BYTE *a10,
        signed int a11,
        char *a12,
        int a13)
{
  _DWORD *v13; // ecx
  unsigned int v14; // ebx
  unsigned int v15; // edi
  int v16; // esi
  int v17; // eax
  int v18; // ebx
  void *v19; // esp
  char *v20; // ecx
  _DWORD *v21; // ebx
  int v22; // edi
  char *v23; // esi
  int v24; // ecx
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // edx
  long double *v29; // esi
  unsigned int v30; // ebx
  int v31; // eax
  int v32; // esi
  unsigned __int8 v33; // dl
  char v34; // cl
  int v35; // eax
  unsigned int v36; // eax
  int v37; // eax
  int v38; // eax
  int v39; // eax
  int v40; // eax
  int v41; // eax
  unsigned int v42; // edi
  void *v43; // esp
  int v44; // eax
  int (__cdecl *v45)(_DWORD *, int, _BYTE *); // eax
  int v46; // edx
  void *v47; // esp
  _BYTE *v48; // ecx
  int v49; // ebx
  long double *v50; // edx
  _DWORD *v51; // eax
  int v52; // eax
  unsigned int v53; // ecx
  int v54; // ebx
  int v55; // eax
  int v56; // ebx
  long double *v57; // eax
  int v58; // edx
  long double *v60; // eax
  int v61; // edx
  int v62; // eax
  int v63; // eax
  int v64; // edx
  void *v65; // esp
  _DWORD *v66; // eax
  _BYTE *v67; // ecx
  long double *v68; // edx
  int v69; // eax
  _DWORD *v70; // edx
  unsigned int v71; // ebx
  _DWORD *v72; // ecx
  char v73; // dl
  int v74; // eax
  _DWORD *v75; // edx
  int v76; // eax
  _DWORD *v77; // edx
  int v78; // eax
  _DWORD *v79; // edx
  char **v80; // ebx
  int v81; // edi
  int v82; // esi
  int *v83; // edx
  int v84; // eax
  int v85; // ebx
  int v86; // edi
  int v87; // eax
  int v88; // eax
  _DWORD *v89; // edx
  int v90; // edx
  _DWORD *v91; // eax
  unsigned int *v92; // ebx
  unsigned int v93; // ebx
  int v94; // ecx
  int v95; // ebx
  int v96; // eax
  unsigned int v97; // edi
  unsigned int v98; // edi
  int v99; // edx
  int v100; // eax
  int v101; // eax
  int v102; // edx
  int v103; // eax
  unsigned int v104; // ecx
  char v105; // al
  int v106; // ecx
  char *v107; // edi
  char *v108; // ebx
  char v109; // dl
  int v110; // eax
  int v111; // eax
  _DWORD *v112; // edx
  int v113; // edx
  _DWORD *v114; // eax
  unsigned int v115; // ebx
  unsigned int *v116; // ecx
  unsigned int v117; // ebx
  int v118; // ebx
  int v119; // eax
  int *v120; // edx
  char *v121; // ebx
  int v122; // eax
  _DWORD *v123; // edx
  int v124; // eax
  unsigned int v125; // ecx
  char *v126; // edx
  unsigned int v127; // ebx
  void *v128; // esp
  _BYTE *v129; // edx
  const char *v130; // edx
  bool v131; // zf
  unsigned int v132; // ebx
  int v133; // ebx
  char *v134; // edx
  unsigned int v135; // edi
  char *v136; // ecx
  bool v137; // sf
  char *v138; // ebx
  int v139; // ebx
  char v140; // al
  int v141; // eax
  char *v142; // ebx
  int v143; // eax
  _DWORD *v144; // edx
  int v145; // eax
  _DWORD *v146; // edx
  char *v147; // ebx
  void *v148; // esp
  int v149; // eax
  int v150; // ebx
  int v151; // eax
  _DWORD *v152; // edx
  char **v153; // ebx
  int v154; // edi
  int v155; // esi
  int *v156; // edx
  int v157; // eax
  int v158; // ebx
  unsigned int v159; // eax
  int v160; // eax
  _DWORD *v161; // edx
  int v162; // eax
  _DWORD *v163; // edx
  int v164; // ebx
  int v165; // ebx
  char v166; // al
  int v167; // eax
  int v168; // edx
  int v169; // ebx
  int v170; // edi
  __int64 v171; // rax
  int v172; // eax
  _DWORD *v173; // edx
  _DWORD *v174; // edx
  char *v175; // ebx
  int v176; // eax
  int v177; // edx
  int v178; // eax
  int v179; // eax
  _DWORD *v180; // edx
  int v181; // eax
  int v182; // eax
  _WORD *v183; // eax
  int v184; // eax
  int v185; // eax
  int v186; // eax
  int v187; // eax
  int v188; // eax
  int v189; // eax
  _DWORD *v190; // [esp-10h] [ebp-4D8h]
  _DWORD *v191; // [esp-Ch] [ebp-4D4h]
  _BYTE v192[12]; // [esp+0h] [ebp-4C8h] BYREF
  int v193; // [esp+Ch] [ebp-4BCh]
  int v194; // [esp+10h] [ebp-4B8h]
  char *v195; // [esp+14h] [ebp-4B4h]
  unsigned int v196; // [esp+18h] [ebp-4B0h]
  unsigned int v197; // [esp+1Ch] [ebp-4ACh]
  bool v198; // [esp+23h] [ebp-4A5h]
  int v199; // [esp+24h] [ebp-4A4h]
  unsigned __int64 v200; // [esp+28h] [ebp-4A0h]
  char v201; // [esp+30h] [ebp-498h]
  bool v202; // [esp+31h] [ebp-497h]
  bool v203; // [esp+32h] [ebp-496h]
  unsigned __int8 v204; // [esp+33h] [ebp-495h]
  unsigned int v205; // [esp+34h] [ebp-494h]
  unsigned int v206; // [esp+38h] [ebp-490h]
  unsigned int v207; // [esp+3Ch] [ebp-48Ch]
  int v208; // [esp+40h] [ebp-488h]
  char *v209; // [esp+44h] [ebp-484h]
  unsigned int v210; // [esp+48h] [ebp-480h]
  int v211; // [esp+4Ch] [ebp-47Ch]
  int v212; // [esp+50h] [ebp-478h]
  long double *v213; // [esp+54h] [ebp-474h]
  int v214; // [esp+58h] [ebp-470h]
  long double *v215; // [esp+5Ch] [ebp-46Ch]
  _DWORD *v216; // [esp+60h] [ebp-468h]
  unsigned int v217; // [esp+64h] [ebp-464h]
  int v218; // [esp+68h] [ebp-460h]
  int v219; // [esp+6Ch] [ebp-45Ch]
  unsigned int v220; // [esp+70h] [ebp-458h] BYREF
  char *v221; // [esp+74h] [ebp-454h] BYREF
  double *v222[12]; // [esp+78h] [ebp-450h] BYREF
  char *v223; // [esp+A8h] [ebp-420h] BYREF
  unsigned int v224; // [esp+ACh] [ebp-41Ch]
  char v225[1048]; // [esp+B0h] [ebp-418h] BYREF

  v216 = a1;
  v211 = a3;
  v210 = a2;
  v13 = a9;
  v224 = 1024;
  v223 = v225;
  v220 = 0;
  if ( a12 == (char *)-1 )
  {
    v87 = *(_DWORD *)__readgsdword(0xFFFFFFE4);
    a12 = *(char **)(v87 + 44);
    a13 = *(_DWORD *)(v87 + 52);
    if ( !*a12 || *a12 == 127 )
      a12 = 0;
  }
  if ( *a9 )
  {
    v14 = 0;
    v15 = 0;
    v218 = 19;
    v219 = (int)v225;
    while ( 1 )
    {
      v16 = v219 + 52 * v15++;
      v17 = _parse_one_specwc(v13, v14, v16, &v220);
      v13 = *(_DWORD **)(v16 + 24);
      v14 += v17;
      if ( !*v13 )
        break;
      if ( v218 == v15 )
      {
        v217 = *(_DWORD *)(v16 + 24);
        if ( !(unsigned __int8)_libc_scratch_buffer_grow_preserve((int)&v223) )
          goto LABEL_87;
        v13 = (_DWORD *)v217;
        v219 = (int)v223;
        v218 = v224 / 0x34;
      }
    }
    if ( v220 >= v14 )
      v14 = v220;
    v217 = v14;
    if ( v14 > 0x6666666 )
    {
      __writegsdword(0xFFFFFFE8, 0x4Bu);
      goto LABEL_87;
    }
    v18 = 20 * v217;
    if ( 20 * v217 > 0x1000 && !_libc_alloca_cutoff(20 * v217) )
    {
      v63 = malloc(20 * v217);
      v212 = v63;
      if ( !v63 )
        goto LABEL_87;
      v213 = (long double *)v63;
      goto LABEL_13;
    }
  }
  else
  {
    v217 = 0;
    v15 = 0;
    v18 = 0;
    v219 = (int)v225;
  }
  v212 = 0;
  v19 = alloca(v18 + 15);
  v213 = (long double *)v192;
LABEL_13:
  v215 = &v213[v217];
  v218 = (int)v215 + 4 * v217;
  j_memset(v218, (int)(v216[15] << 29) >> 31, 4 * v217);
  v20 = (char *)v218;
  if ( !v15 )
  {
    if ( v217 )
      goto LABEL_25;
    goto LABEL_74;
  }
  v218 = v15;
  v21 = (_DWORD *)v219;
  v22 = 0;
  v23 = v20;
  do
  {
    while ( 1 )
    {
      v25 = v21[8];
      if ( v25 != -1 )
        *(_DWORD *)&v23[4 * v25] = 0;
      v26 = v21[7];
      if ( v26 != -1 )
        *(_DWORD *)&v23[4 * v26] = 0;
      v27 = v21[11];
      if ( !v27 )
        goto LABEL_16;
      if ( v27 != 1 )
        break;
      v24 = (int)v215;
      *(_DWORD *)&v23[4 * v21[9]] = v21[10];
      *(_DWORD *)(v24 + 4 * v21[9]) = v21[12];
LABEL_16:
      ++v22;
      v21 += 13;
      if ( v22 == v218 )
        goto LABEL_24;
    }
    v28 = v21[9];
    ++v22;
    v214 = v21[2];
    v190 = v21;
    v21 += 13;
    (*(void (__cdecl **)(_DWORD *, int, char *, _BYTE *))(_printf_arginfo_table + 4 * v214))(
      v190,
      v27,
      &v23[4 * v28],
      (_BYTE *)v215 + 4 * v28);
  }
  while ( v22 != v218 );
LABEL_24:
  v15 = v218;
  v20 = v23;
  if ( !v217 )
    goto LABEL_38;
LABEL_25:
  v218 = v15;
  v29 = v213;
  v30 = 0;
  while ( 1 )
  {
LABEL_26:
    v31 = *(_DWORD *)&v20[4 * v30];
    if ( v31 <= 5 )
    {
      if ( v31 < 0 )
      {
        if ( v31 == -1 )
        {
          if ( (v216[15] & 4) == 0 )
            _assert_fail("s->_flags2 & _IO_FLAGS2_FORTIFY", "vfprintf.c", 1897, "printf_positional");
          _libc_fatal("*** invalid %N$ use detected ***\n");
        }
        goto LABEL_83;
      }
      goto LABEL_77;
    }
    if ( v31 == 256 )
    {
      v60 = *a6;
      *a6 = (long double *)((char *)*a6 + 8);
      v61 = *((_DWORD *)v60 + 1);
      v62 = *(_DWORD *)v60;
      *((_DWORD *)v29 + 1) = v61;
      *(_DWORD *)v29 = v62;
      goto LABEL_78;
    }
    if ( v31 <= 256 )
      break;
    if ( v31 == 512 || v31 == 1024 )
      goto LABEL_77;
    if ( v31 != 263 )
      goto LABEL_83;
    ++v30;
    ++v29;
    a4 = *(*a6)++;
    *(v29 - 1) = a4;
    if ( v30 >= v217 )
      goto LABEL_37;
  }
  if ( v31 <= 7 )
  {
    a4 = *(double *)*a6;
    *a6 = (long double *)((char *)*a6 + 8);
    *(double *)v29 = a4;
    goto LABEL_78;
  }
LABEL_83:
  if ( (v31 & 0x800) != 0 )
  {
LABEL_77:
    v57 = *a6;
    *a6 = (long double *)((char *)*a6 + 4);
    *(_DWORD *)v29 = *(_DWORD *)v57;
    goto LABEL_78;
  }
  v58 = _printf_va_arg_table;
  if ( _printf_va_arg_table && *(_DWORD *)(_printf_va_arg_table + 4 * v31 - 32) )
  {
    v209 = v20;
    v148 = alloca(*((_DWORD *)v215 + v30) + 15);
    *(_DWORD *)v29 = v192;
    v214 = (int)v192;
    (*(void (__cdecl **)(_BYTE *, long double **))(v58 + 4 * *(_DWORD *)&v20[4 * v30] - 32))(v192, a6);
    v20 = v209;
  }
  else
  {
    a4 = 0.0;
    *v29 = 0.0;
  }
LABEL_78:
  ++v30;
  ++v29;
  if ( v30 < v217 )
    goto LABEL_26;
LABEL_37:
  v15 = v218;
LABEL_38:
  if ( v15 <= a8 )
  {
LABEL_74:
    v56 = a7;
    if ( v212 )
    {
      v215 = 0;
      goto LABEL_76;
    }
    goto LABEL_88;
  }
  v197 = v15;
  v195 = a10 + 4000;
  v32 = 52 * a8 + v219;
  v207 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
  while ( 2 )
  {
    v33 = *(_BYTE *)(v32 + 12);
    v219 = *(_DWORD *)v32;
    LOBYTE(v208) = (v33 & 8) != 0;
    LOBYTE(v206) = (v33 & 0x10) != 0;
    v214 = (v33 & 0x20) != 0;
    LOBYTE(v205) = (v33 & 0x40) != 0;
    v201 = v33 >> 7;
    v204 = v33 & 1;
    LOBYTE(v200) = (v33 & 2) != 0;
    v34 = *(_BYTE *)(v32 + 13);
    v198 = (v34 & 8) != 0;
    v35 = *(_DWORD *)(v32 + 16);
    v203 = (v34 & 2) != 0;
    v199 = v35;
    v36 = *(_DWORD *)(v32 + 8);
    v202 = (v33 & 4) != 0;
    v217 = v36;
    v37 = *(_DWORD *)(v32 + 32);
    if ( v37 == -1 )
    {
      v218 = *(_DWORD *)(v32 + 4);
    }
    else
    {
      v38 = LODWORD(v213[v37]);
      v218 = v38;
      if ( v38 < 0 )
      {
        v218 = -v218;
        v214 = 1;
        v38 = v218;
        *(_BYTE *)(v32 + 12) = v33 | 0x20;
      }
      *(_DWORD *)(v32 + 4) = v38;
    }
    v39 = *(_DWORD *)(v32 + 28);
    if ( v39 != -1 )
    {
      v40 = LODWORD(v213[v39]);
      v219 = v40;
      if ( v40 < 0 )
      {
        *(_DWORD *)v32 = -1;
        v219 = -1;
      }
      else
      {
        *(_DWORD *)v32 = v40;
      }
    }
    v41 = v218;
    if ( v218 < v219 )
      v41 = v219;
    if ( v41 <= 968 )
    {
      v215 = 0;
      v209 = v195;
    }
    else
    {
      v42 = 4 * v41 + 128;
      if ( v42 <= 0x1000 || _libc_alloca_cutoff(4 * v41 + 128) )
      {
        v215 = 0;
        v43 = alloca(v42 + 15);
        v44 = 4 * v219 + 128;
        if ( v218 >= v219 )
          v44 = 4 * v218 + 128;
        v209 = &v192[v44];
      }
      else
      {
        v215 = (long double *)malloc(v42);
        if ( !v215 )
          goto LABEL_142;
        v149 = 4 * v218 + 128;
        if ( v218 < v219 )
          v149 = 4 * v219 + 128;
        v209 = (char *)v215 + v149;
      }
    }
    if ( (int)v217 <= 255 )
    {
      if ( _printf_function_table )
      {
        v45 = *(int (__cdecl **)(_DWORD *, int, _BYTE *))(_printf_function_table + 4 * v217);
        v196 = 4 * v217;
        if ( v45 )
        {
          v46 = *(_DWORD *)(v32 + 44);
          v47 = alloca(4 * v46 + 15);
          if ( v46 )
          {
            v48 = &v192[4 * v46];
            v49 = v219;
            v50 = &v213[*(_DWORD *)(v32 + 36)];
            v51 = v192;
            do
              *v51++ = v50++;
            while ( v51 != (_DWORD *)v48 );
            v219 = v49;
            v45 = *(int (__cdecl **)(_DWORD *, int, _BYTE *))(_printf_function_table + v196);
          }
          v52 = v45(v216, v32, v192);
          if ( v52 != -2 )
          {
            if ( v52 < 0 )
              goto LABEL_131;
            if ( a7 > 0x7FFFFFFE )
              _assert_fail("(unsigned int) done < (unsigned int) INT_MAX", "vfprintf.c", 2020, "printf_positional");
LABEL_64:
            if ( v52 > 0x7FFFFFFF - a7 )
              goto LABEL_174;
LABEL_65:
            a7 += v52;
            goto LABEL_66;
          }
        }
      }
    }
    v85 = v203;
    v53 = v202;
    v194 = (unsigned __int8)v206;
    v193 = (unsigned __int8)v208;
    v206 = v204;
    v196 = (unsigned __int8)v205;
    v86 = (unsigned __int8)v200;
    v204 = v199;
    switch ( v217 )
    {
      case '%':
        v122 = v216[22];
        if ( v122 && (v123 = *(_DWORD **)(v122 + 16), (unsigned int)v123 < *(_DWORD *)(v122 + 20)) )
        {
          v53 = (unsigned int)(v123 + 1);
          *(_DWORD *)(v122 + 16) = v123 + 1;
          *v123 = 37;
        }
        else if ( _woverflow(v216, 37) == -1 )
        {
          goto LABEL_131;
        }
        if ( a7 == 0x7FFFFFFF )
          goto LABEL_131;
        ++a7;
        goto LABEL_66;
      case 'A':
      case 'a':
        v222[0] = (double *)&v213[*(_DWORD *)(v32 + 36)];
        v52 = _printf_fphex(v216, v32, v222);
        if ( v52 >= 0 )
          goto LABEL_253;
        goto LABEL_131;
      case 'C':
        goto LABEL_177;
      case 'E':
      case 'F':
      case 'G':
      case 'e':
      case 'f':
      case 'g':
        v221 = (char *)&v213[*(_DWORD *)(v32 + 36)];
        v52 = _printf_fp(v216, v32, (long double **)&v221);
        if ( v52 < 0 )
          goto LABEL_131;
LABEL_253:
        if ( a7 > 0x7FFFFFFE )
          goto LABEL_254;
        goto LABEL_64;
      case 'S':
      case 's':
        v126 = (char *)LODWORD(v213[*(_DWORD *)(v32 + 36)]);
        goto LABEL_282;
      case 'X':
      case 'x':
        v205 = 16;
        goto LABEL_205;
      case 'c':
        if ( v202 )
        {
LABEL_177:
          v98 = v218 - 1;
          LOBYTE(v219) = v218 - 1 > 0;
          if ( !v214 && v218 - 1 > 0 )
          {
            if ( v98 != IO_wpadn((int)v216, 32, v218 - 1) )
              goto LABEL_131;
            if ( a7 > 0x7FFFFFFE )
              goto LABEL_520;
            if ( v98 > 0x7FFFFFFF - a7 )
              goto LABEL_174;
            a7 += v98;
          }
          v99 = LODWORD(v213[*(_DWORD *)(v32 + 36)]);
          v100 = v216[22];
          if ( v100 )
          {
            v53 = *(_DWORD *)(v100 + 16);
            if ( v53 < *(_DWORD *)(v100 + 20) )
            {
              *(_DWORD *)(v100 + 16) = v53 + 4;
              *(_DWORD *)v53 = v99;
              if ( v99 == -1 )
                goto LABEL_131;
              goto LABEL_186;
            }
          }
          v184 = _woverflow(v216, LODWORD(v213[*(_DWORD *)(v32 + 36)]));
        }
        else
        {
          v98 = v218 - 1;
          LOBYTE(v219) = v218 - 1 > 0;
          if ( !v214 && v218 - 1 > 0 )
          {
            if ( v98 != IO_wpadn((int)v216, 32, v218 - 1) )
              goto LABEL_131;
            if ( a7 > 0x7FFFFFFE )
              goto LABEL_520;
            if ( v98 > 0x7FFFFFFF - a7 )
              goto LABEL_174;
            a7 += v98;
          }
          v101 = btowc(LOBYTE(v213[*(_DWORD *)(v32 + 36)]));
          v102 = v216[22];
          if ( v102 )
          {
            v53 = *(_DWORD *)(v102 + 16);
            if ( v53 < *(_DWORD *)(v102 + 20) )
            {
              *(_DWORD *)(v102 + 16) = v53 + 4;
              *(_DWORD *)v53 = v101;
              if ( v101 == -1 )
                goto LABEL_131;
              goto LABEL_186;
            }
          }
          v184 = _woverflow(v216, v101);
        }
        if ( v184 == -1 )
          goto LABEL_131;
LABEL_186:
        if ( a7 == 0x7FFFFFFF )
          goto LABEL_131;
        ++a7;
        if ( !v214 || !(_BYTE)v219 )
          goto LABEL_66;
        if ( v98 != IO_wpadn((int)v216, 32, v98) )
          goto LABEL_131;
        if ( a7 > 0x7FFFFFFE )
          goto LABEL_520;
        goto LABEL_191;
      case 'd':
      case 'i':
        v124 = *(_DWORD *)(v32 + 36);
        if ( v206 )
        {
          v205 = 10;
          v168 = DWORD1(v213[v124]);
          v169 = v168 >> 31;
          v170 = (unsigned int)v168 >> 31;
          LODWORD(v171) = (v168 >> 31) ^ LODWORD(v213[v124]);
          HIDWORD(v171) = (v168 >> 31) ^ v168;
          v206 = v170;
          v200 = v171 - __PAIR64__(v169, v169);
          goto LABEL_333;
        }
        if ( v203 )
        {
          v125 = SLOBYTE(v213[*(_DWORD *)(v32 + 36)]);
        }
        else if ( (_BYTE)v200 )
        {
          v125 = SLOWORD(v213[*(_DWORD *)(v32 + 36)]);
        }
        else
        {
          v125 = LODWORD(v213[*(_DWORD *)(v32 + 36)]);
        }
        v205 = 10;
        v206 = v125 >> 31;
        v104 = abs32(v125);
        LODWORD(v200) = v104;
        goto LABEL_208;
      case 'm':
        v126 = (char *)strerror_r(a4, a11, a10, 0xFA0u);
        v53 = 0;
LABEL_282:
        if ( v126 )
        {
          if ( (v53 & 1) != 0 || v217 == 83 )
          {
            if ( v219 != -1 )
              goto LABEL_370;
            v217 = (unsigned int)v126;
            v98 = j_wcslen(v126);
            v219 = 0;
            v130 = (const char *)v217;
          }
          else
          {
            v221 = v126;
            if ( v219 == -1 )
              v127 = strlen(v126);
            else
              v127 = j_strnlen(v126, v219);
            if ( v127 > 0x3FFFFFFF )
              goto LABEL_174;
            if ( 4 * v127 <= 0x1000 || _libc_alloca_cutoff(4 * v127) )
            {
              v219 = 0;
              v128 = alloca(4 * v127 + 15);
              v129 = v192;
            }
            else
            {
              v129 = (_BYTE *)malloc(4 * v127);
              if ( !v129 )
                goto LABEL_131;
              v219 = 1;
            }
            v217 = (unsigned int)v129;
            v222[0] = 0;
            v222[1] = 0;
            v98 = mbsrtowcs((int)v129, &v221, v127, v222);
            v130 = (const char *)v217;
            if ( v98 == -1 )
              goto LABEL_131;
          }
        }
        else
        {
          v178 = v219;
          v219 = 0;
          if ( v178 == -1 || (v98 = 0, v130 = (const char *)&unk_80CD074, v178 > 5) )
          {
            v98 = 6;
            v130 = "(";
          }
        }
        goto LABEL_291;
      case 'n':
        if ( (v216[15] & 4) != 0 )
        {
          if ( !v211 )
          {
            v219 = v203;
            v186 = j_wcslen(v210);
            v211 = _readonly_area(v210, 4 * v186 + 4);
            v85 = v219;
          }
          v53 = v211;
          if ( v211 < 0 )
            _libc_fatal("*** %n in writable segment detected ***\n", v191);
        }
        if ( v206 )
        {
          *(_QWORD *)LODWORD(v213[*(_DWORD *)(v32 + 36)]) = (int)a7;
        }
        else if ( v85 )
        {
          *(_BYTE *)LODWORD(v213[*(_DWORD *)(v32 + 36)]) = a7;
        }
        else
        {
          v183 = (_WORD *)LODWORD(v213[*(_DWORD *)(v32 + 36)]);
          if ( v86 )
            *v183 = a7;
          else
            *(_DWORD *)v183 = a7;
        }
        goto LABEL_66;
      case 'o':
        v205 = 8;
        goto LABEL_205;
      case 'p':
        v104 = LODWORD(v213[*(_DWORD *)(v32 + 36)]);
        if ( v104 )
        {
          LODWORD(v200) = LODWORD(v213[*(_DWORD *)(v32 + 36)]);
          if ( v219 >= 0 )
          {
            v217 = 120;
            v105 = 0;
            v193 = 1;
            v205 = 16;
            v206 = 0;
            v204 = 32;
            goto LABEL_258;
          }
          v219 = 1;
          v193 = 1;
          v120 = itowa_lower_digits;
          v206 = 0;
          v217 = 120;
          LOBYTE(v208) = 0;
          goto LABEL_326;
        }
        v185 = 5;
        v126 = "(";
        if ( v219 >= 5 )
          v185 = v219;
        v219 = v185;
LABEL_370:
        v217 = (unsigned int)v126;
        v98 = wcsnlen(v126, v219);
        v219 = 0;
        v130 = (const char *)v217;
LABEL_291:
        v131 = v218 == v98;
        v218 -= v98;
        if ( v218 < 0 )
        {
          if ( (a7 & 0x80000000) != 0 )
LABEL_516:
            _assert_fail("(size_t) done <= (size_t) INT_MAX", "vfprintf.c", 2028, "printf_positional");
          v164 = v216[37];
          if ( v207 <= v164 - (int)&_start___libc_IO_vtables )
          {
            v219 = (int)v130;
            IO_vtable_check(v53);
            v130 = (const char *)v219;
          }
          if ( v98 != (*(int (__cdecl **)(_DWORD *, const char *, unsigned int))(v164 + 28))(v216, v130, v98) )
            goto LABEL_131;
LABEL_191:
          if ( v98 > 0x7FFFFFFF - a7 )
            goto LABEL_174;
          goto LABEL_192;
        }
        LOBYTE(v217) = !v131;
        if ( !v214 && !v131 )
        {
          v132 = v218;
          v209 = (char *)v130;
          if ( v132 != IO_wpadn((int)v216, 32, v218) )
            goto LABEL_131;
          if ( a7 > 0x7FFFFFFE )
            goto LABEL_520;
          if ( v132 > 0x7FFFFFFF - a7 )
            goto LABEL_174;
          a7 += v132;
          v130 = v209;
        }
        if ( (a7 & 0x80000000) != 0 )
          goto LABEL_516;
        v133 = v216[37];
        if ( v207 <= v133 - (int)&_start___libc_IO_vtables )
        {
          v209 = (char *)v130;
          IO_vtable_check(a7);
          v130 = v209;
        }
        v209 = (char *)v130;
        if ( v98 != (*(int (__cdecl **)(_DWORD *, const char *, unsigned int))(v133 + 28))(v216, v130, v98) )
          goto LABEL_131;
        if ( v98 > 0x7FFFFFFF - a7 )
          goto LABEL_174;
        a7 += v98;
        v134 = v209;
        if ( v214 && (_BYTE)v217 )
        {
          v135 = v218;
          v217 = (unsigned int)v209;
          if ( v135 != IO_wpadn((int)v216, 32, v218) )
            goto LABEL_131;
          if ( a7 > 0x7FFFFFFE )
LABEL_520:
            _assert_fail("(unsigned int) done < (unsigned int) INT_MAX", "vfprintf.c", 2028, "printf_positional");
          if ( v135 > 0x7FFFFFFF - a7 )
            goto LABEL_174;
          a7 += v135;
          v134 = (char *)v217;
        }
        if ( v219 )
          free(v134);
        goto LABEL_66;
      case 'u':
        v205 = 10;
LABEL_205:
        if ( v206 )
        {
          v141 = *(_DWORD *)(v32 + 36);
          v196 = 0;
          v194 = 0;
          v206 = 0;
          v200 = *(_QWORD *)&v213[v141];
LABEL_333:
          if ( v219 < 0 )
          {
            v219 = 1;
          }
          else
          {
            if ( !v219 && !v200 )
            {
              if ( v205 == 8 && (_BYTE)v208 )
              {
                v106 = 4;
                v208 = 1;
                v204 = 32;
                v107 = v209 - 4;
                *((_DWORD *)v209 - 1) = 48;
              }
              else
              {
                v208 = 0;
                v106 = 0;
                v107 = v209;
                v204 = 32;
              }
LABEL_339:
              LODWORD(v200) = v200 != 0;
              goto LABEL_214;
            }
            v204 = 32;
          }
          v147 = v209;
          v107 = (char *)itowa(v200, v209, v205, v217 == 88);
          if ( a12 && v201 )
            v107 = group_number_0(v107, v147, a12, a13);
          if ( v205 == 10 && v198 )
          {
            v175 = v209;
            v107 = i18n_number_rewrite_1(v107, (int)v209, (int)v209);
            v106 = v175 - v107;
            v208 = (v175 - v107) >> 2;
          }
          else
          {
            v106 = v209 - v107;
            v208 = (v209 - v107) >> 2;
          }
          goto LABEL_339;
        }
        v103 = *(_DWORD *)(v32 + 36);
        if ( v203 )
        {
          v196 = 0;
          v194 = 0;
          LODWORD(v200) = LOBYTE(v213[v103]);
          v104 = v200;
        }
        else
        {
          if ( (_BYTE)v200 )
            v159 = LOWORD(v213[*(_DWORD *)(v32 + 36)]);
          else
            v159 = LODWORD(v213[*(_DWORD *)(v32 + 36)]);
          v196 = 0;
          v194 = 0;
          LODWORD(v200) = v159;
          v104 = v159;
        }
LABEL_208:
        v105 = v201;
        if ( v219 < 0 )
        {
          v219 = 1;
        }
        else
        {
          if ( !v219 && !v104 )
          {
            if ( v205 == 8 && (_BYTE)v208 )
            {
              v106 = 4;
              v208 = 1;
              v204 = 32;
              v193 = 1;
              v205 = 8;
              v107 = v209 - 4;
              *((_DWORD *)v209 - 1) = 48;
              goto LABEL_214;
            }
            v107 = v209;
            v208 = 0;
            v106 = 0;
            v204 = 32;
LABEL_317:
            if ( (_DWORD)v200 )
            {
              v109 = v193 & 1;
              if ( v205 == 8 && v109 )
              {
                v136 = v209;
                *((_DWORD *)v107 - 1) = 48;
                v107 -= 4;
                v106 = v136 - v107;
              }
              v137 = v219 - (v106 >> 2) < 0;
              v219 -= v106 >> 2;
              v138 = 0;
              if ( !v137 )
                v138 = (char *)v219;
              v209 = v138;
              if ( !v214 )
              {
                v208 = v106 >> 2;
                v219 = v218 - (_DWORD)&v209[v106 >> 2];
LABEL_220:
                if ( v205 == 16 )
                {
                  v110 = v219 - 2;
                  if ( !v109 )
                    v110 = v219;
                  v219 = v110;
                }
LABEL_224:
                v219 = ((v196 | v194 | v206) == 0) + v219 - 1;
                if ( v204 == 32 )
                {
                  v158 = v219;
                  if ( v219 > 0 )
                  {
                    if ( v158 != IO_wpadn((int)v216, 32, v219) )
                      goto LABEL_131;
                    if ( a7 > 0x7FFFFFFE )
LABEL_254:
                      _assert_fail(
                        "(unsigned int) done < (unsigned int) INT_MAX",
                        "vfprintf.c",
                        2027,
                        "printf_positional");
                    if ( v219 > 0x7FFFFFFF - a7 )
                      goto LABEL_174;
                    a7 += v219;
                    v219 = 0;
                  }
                  else
                  {
                    v219 = 0;
                  }
                }
                if ( v206 )
                {
                  v111 = v216[22];
                  if ( v111 )
                  {
                    v112 = *(_DWORD **)(v111 + 16);
                    if ( (unsigned int)v112 < *(_DWORD *)(v111 + 20) )
                    {
                      *(_DWORD *)(v111 + 16) = v112 + 1;
                      *v112 = 45;
LABEL_229:
                      if ( a7 == 0x7FFFFFFF )
                        goto LABEL_131;
                      ++a7;
LABEL_231:
                      if ( !(_DWORD)v200 || v205 != 16 || (v193 & 1) == 0 )
                      {
LABEL_241:
                        v117 = (unsigned int)&v209[v219];
                        if ( (int)&v209[v219] > 0 )
                        {
                          if ( v117 != IO_wpadn((int)v216, 48, (int)&v209[v219]) )
                            goto LABEL_131;
                          if ( a7 > 0x7FFFFFFE )
                            goto LABEL_254;
                          if ( v117 > 0x7FFFFFFF - a7 )
                            goto LABEL_174;
                          a7 += v117;
                        }
                        if ( (a7 & 0x80000000) != 0 )
LABEL_518:
                          _assert_fail("(size_t) done <= (size_t) INT_MAX", "vfprintf.c", 2027, "printf_positional");
                        v118 = v216[37];
                        if ( v207 <= v118 - (int)&_start___libc_IO_vtables )
                          IO_vtable_check(a7);
                        v119 = (*(int (__cdecl **)(_DWORD *, char *, int))(v118 + 28))(v216, v107, v208);
                        if ( v208 != v119 )
                          goto LABEL_131;
                        if ( v208 > (int)(0x7FFFFFFF - a7) )
                          goto LABEL_174;
                        a7 += v208;
                        goto LABEL_66;
                      }
                      v113 = v216[22];
                      if ( v113
                        && (v114 = *(_DWORD **)(v113 + 16), v115 = *(_DWORD *)(v113 + 20), (unsigned int)v114 < v115) )
                      {
                        v116 = v114 + 1;
                        *(_DWORD *)(v113 + 16) = v114 + 1;
                        *v114 = 48;
                        if ( a7 == 0x7FFFFFFF )
                          goto LABEL_131;
                      }
                      else
                      {
                        if ( _woverflow(v216, 48) == -1 || a7 == 0x7FFFFFFF )
                          goto LABEL_131;
                        v113 = v216[22];
                        if ( !v113 )
                          goto LABEL_503;
                        v116 = *(unsigned int **)(v113 + 16);
                        v115 = *(_DWORD *)(v113 + 20);
                      }
                      if ( (unsigned int)v116 < v115 )
                      {
                        *(_DWORD *)(v113 + 16) = v116 + 1;
                        v131 = v217 == -1;
                        *v116 = v217;
                        if ( v131 )
                          goto LABEL_131;
LABEL_239:
                        if ( a7 == 2147483646 )
                          goto LABEL_131;
                        a7 += 2;
                        goto LABEL_241;
                      }
LABEL_503:
                      if ( _woverflow(v216, v217) == -1 )
                        goto LABEL_131;
                      goto LABEL_239;
                    }
                  }
                  v182 = _woverflow(v216, 45);
                }
                else if ( v196 )
                {
                  v145 = v216[22];
                  if ( v145 )
                  {
                    v146 = *(_DWORD **)(v145 + 16);
                    if ( (unsigned int)v146 < *(_DWORD *)(v145 + 20) )
                    {
                      *(_DWORD *)(v145 + 16) = v146 + 1;
                      *v146 = 43;
                      goto LABEL_229;
                    }
                  }
                  v182 = _woverflow(v216, 43);
                }
                else
                {
                  if ( !v194 )
                    goto LABEL_231;
                  v162 = v216[22];
                  if ( v162 )
                  {
                    v163 = *(_DWORD **)(v162 + 16);
                    if ( (unsigned int)v163 < *(_DWORD *)(v162 + 20) )
                    {
                      *(_DWORD *)(v162 + 16) = v163 + 1;
                      *v163 = 32;
                      goto LABEL_229;
                    }
                  }
                  v182 = _woverflow(v216, 32);
                }
                if ( v182 == -1 )
                  goto LABEL_131;
                goto LABEL_229;
              }
            }
            else
            {
              v142 = (char *)(v219 - (v106 >> 2));
              if ( (int)v142 < 0 )
                v142 = (char *)v200;
              v209 = v142;
              if ( !v214 )
              {
                v219 = v218 - (_DWORD)&v209[v208];
                goto LABEL_224;
              }
            }
            goto LABEL_144;
          }
          v204 = 32;
        }
        if ( v217 == 88 )
        {
          LOBYTE(v208) = v201 & (a12 != 0);
          v120 = (int *)&itowa_upper_digits;
        }
        else
        {
LABEL_258:
          LOBYTE(v208) = v105 & (a12 != 0);
          v120 = itowa_lower_digits;
        }
        if ( v205 != 10 )
        {
          if ( v205 == 16 )
          {
LABEL_326:
            v107 = v209;
            v139 = v219;
            do
            {
              v140 = v104;
              v104 >>= 4;
              v107 -= 4;
              *(_DWORD *)v107 = v120[v140 & 0xF];
            }
            while ( v104 );
            v219 = v139;
            v205 = 16;
          }
          else
          {
            v107 = v209;
            v165 = v219;
            do
            {
              v166 = v104;
              v104 >>= 3;
              v107 -= 4;
              *(_DWORD *)v107 = v120[v166 & 7];
            }
            while ( v104 );
            v219 = v165;
          }
          if ( !(_BYTE)v208 )
            goto LABEL_330;
          goto LABEL_397;
        }
        v107 = v209;
        do
        {
          v107 -= 4;
          v167 = v120[v104 % 0xA];
          v104 /= 0xAu;
          *(_DWORD *)v107 = v167;
        }
        while ( v104 );
        if ( (_BYTE)v208 )
LABEL_397:
          v107 = group_number_0(v107, v209, a12, a13);
        if ( v205 == 10 && v198 )
        {
          v121 = v209;
          v107 = i18n_number_rewrite_1(v107, (int)v209, (int)v209);
          v205 = 10;
          v106 = v121 - v107;
          v208 = (v121 - v107) >> 2;
          goto LABEL_214;
        }
LABEL_330:
        v106 = v209 - v107;
        v208 = (v209 - v107) >> 2;
LABEL_214:
        if ( v219 <= v208 )
          goto LABEL_317;
        v108 = 0;
        if ( v219 - (v106 >> 2) >= 0 )
          v108 = (char *)(v219 - (v106 >> 2));
        v209 = v108;
        if ( !v214 )
        {
          v219 = v218 - (_DWORD)&v108[v208];
          if ( !(_DWORD)v200 )
            goto LABEL_224;
          v109 = v193 & 1;
          goto LABEL_220;
        }
LABEL_144:
        if ( !v206 )
        {
          if ( v196 )
          {
            v143 = v216[22];
            if ( v143 )
            {
              v144 = *(_DWORD **)(v143 + 16);
              if ( (unsigned int)v144 < *(_DWORD *)(v143 + 20) )
              {
                *(_DWORD *)(v143 + 16) = v144 + 1;
                *v144 = 43;
                goto LABEL_148;
              }
            }
            v219 = v106;
            v181 = _woverflow(v216, 43);
          }
          else
          {
            if ( !v194 )
              goto LABEL_150;
            v160 = v216[22];
            if ( v160 )
            {
              v161 = *(_DWORD **)(v160 + 16);
              if ( (unsigned int)v161 < *(_DWORD *)(v160 + 20) )
              {
                *(_DWORD *)(v160 + 16) = v161 + 1;
                *v161 = 32;
                goto LABEL_148;
              }
            }
            v219 = v106;
            v181 = _woverflow(v216, 32);
          }
LABEL_450:
          v106 = v219;
          if ( v181 == -1 )
            goto LABEL_131;
          goto LABEL_148;
        }
        v88 = v216[22];
        if ( !v88 || (v89 = *(_DWORD **)(v88 + 16), (unsigned int)v89 >= *(_DWORD *)(v88 + 20)) )
        {
          v219 = v106;
          v181 = _woverflow(v216, 45);
          goto LABEL_450;
        }
        *(_DWORD *)(v88 + 16) = v89 + 1;
        *v89 = 45;
LABEL_148:
        if ( a7 == 0x7FFFFFFF )
          goto LABEL_131;
        ++a7;
        --v218;
LABEL_150:
        if ( !(_DWORD)v200 || v205 != 16 || (v193 & 1) == 0 )
          goto LABEL_160;
        v90 = v216[22];
        if ( v90 && (v91 = *(_DWORD **)(v90 + 16), v219 = *(_DWORD *)(v90 + 20), (unsigned int)v91 < v219) )
        {
          v92 = v91 + 1;
          *(_DWORD *)(v90 + 16) = v91 + 1;
          *v91 = 48;
          if ( a7 == 0x7FFFFFFF )
            goto LABEL_131;
        }
        else
        {
          v219 = v106;
          v189 = _woverflow(v216, 48);
          v106 = v219;
          if ( v189 == -1 || a7 == 0x7FFFFFFF )
            goto LABEL_131;
          v90 = v216[22];
          if ( !v90 )
            goto LABEL_492;
          v92 = *(unsigned int **)(v90 + 16);
          v219 = *(_DWORD *)(v90 + 20);
        }
        if ( v219 <= (unsigned int)v92 )
        {
LABEL_492:
          v219 = v106;
          v188 = _woverflow(v216, v217);
          v106 = v219;
          if ( v188 == -1 )
            goto LABEL_131;
          goto LABEL_158;
        }
        *(_DWORD *)(v90 + 16) = v92 + 1;
        v131 = v217 == -1;
        *v92 = v217;
        if ( v131 )
          goto LABEL_131;
LABEL_158:
        if ( a7 == 2147483646 )
          goto LABEL_131;
        a7 += 2;
        v218 -= 2;
LABEL_160:
        v93 = (unsigned int)v209;
        v94 = v106 >> 2;
        v219 = v218 - (_DWORD)&v209[v94];
        if ( v209 )
        {
          v218 = v94;
          if ( v93 != IO_wpadn((int)v216, 48, (int)v209) )
            goto LABEL_131;
          if ( a7 > 0x7FFFFFFE )
            goto LABEL_254;
          if ( v93 > 0x7FFFFFFF - a7 )
            goto LABEL_174;
          a7 += v93;
          v94 = v218;
        }
        if ( (a7 & 0x80000000) != 0 )
          goto LABEL_518;
        v95 = v216[37];
        if ( v207 <= v95 - (int)&_start___libc_IO_vtables )
        {
          v218 = v94;
          IO_vtable_check(v94);
          v94 = v218;
        }
        v218 = v94;
        v96 = (*(int (__cdecl **)(_DWORD *, char *, int))(v95 + 28))(v216, v107, v94);
        v53 = v218;
        if ( v218 != v96 )
          goto LABEL_131;
        if ( v218 > (int)(0x7FFFFFFF - a7) )
          goto LABEL_174;
        v97 = v219;
        a7 += v218;
        if ( v219 > 0 )
        {
          if ( v97 != IO_wpadn((int)v216, 32, v219) )
            goto LABEL_131;
          if ( a7 > 0x7FFFFFFE )
            goto LABEL_254;
          v52 = v97;
          if ( v97 > 0x7FFFFFFF - a7 )
            goto LABEL_174;
          goto LABEL_65;
        }
LABEL_66:
        if ( v215 )
          free(v215);
        if ( (a7 & 0x80000000) != 0 )
          _assert_fail("(size_t) done <= (size_t) INT_MAX", "vfprintf.c", 2067, "printf_positional");
        v54 = v216[37];
        if ( v207 <= v54 - (int)&_start___libc_IO_vtables )
          IO_vtable_check(v53);
        v55 = (*(int (__cdecl **)(_DWORD *, _DWORD, int))(v54 + 28))(
                v216,
                *(_DWORD *)(v32 + 20),
                (*(_DWORD *)(v32 + 24) - *(_DWORD *)(v32 + 20)) >> 2);
        if ( v55 != (*(_DWORD *)(v32 + 24) - *(_DWORD *)(v32 + 20)) >> 2 )
          goto LABEL_142;
        if ( v55 <= (int)(0x7FFFFFFF - a7) )
        {
          ++a8;
          a7 += v55;
          v32 += 52;
          if ( a8 >= v197 )
            goto LABEL_74;
          continue;
        }
        __writegsdword(0xFFFFFFE8, 0x4Bu);
LABEL_142:
        if ( v212 )
        {
          v215 = 0;
          v56 = -1;
          goto LABEL_76;
        }
LABEL_87:
        v56 = -1;
LABEL_88:
        if ( v223 != v225 )
          free(v223);
        return v56;
      default:
        v64 = *(_DWORD *)(v32 + 44);
        v65 = alloca(4 * v64 + 15);
        v66 = v192;
        if ( v64 )
        {
          v67 = &v192[4 * v64];
          v68 = &v213[*(_DWORD *)(v32 + 36)];
          do
            *v66++ = v68++;
          while ( v67 != (_BYTE *)v66 );
        }
        v69 = v216[22];
        if ( v69 && (v70 = *(_DWORD **)(v69 + 16), v71 = *(_DWORD *)(v69 + 20), (unsigned int)v70 < v71) )
        {
          v72 = v70 + 1;
          *(_DWORD *)(v69 + 16) = v70 + 1;
          *v70 = 37;
          v73 = *(_BYTE *)(v32 + 12);
          if ( (v73 & 8) == 0 )
          {
            v218 = 1;
            if ( v73 >= 0 )
              goto LABEL_104;
LABEL_422:
            v174 = *(_DWORD **)(v69 + 16);
            if ( (unsigned int)v174 < *(_DWORD *)(v69 + 20) )
            {
              *(_DWORD *)(v69 + 16) = v174 + 1;
              *v174 = 39;
LABEL_424:
              ++v218;
              v73 = *(_BYTE *)(v32 + 12);
              goto LABEL_104;
            }
LABEL_477:
            if ( _woverflow(v216, 39) == -1 )
              goto LABEL_131;
            goto LABEL_424;
          }
        }
        else
        {
          if ( _woverflow(v216, 37) == -1 )
            goto LABEL_131;
          v73 = *(_BYTE *)(v32 + 12);
          if ( (v73 & 8) == 0 )
          {
            v218 = 1;
            goto LABEL_475;
          }
          v69 = v216[22];
          if ( !v69 )
          {
LABEL_473:
            if ( _woverflow(v216, 35) == -1 )
              goto LABEL_131;
            v73 = *(_BYTE *)(v32 + 12);
            v218 = 2;
LABEL_475:
            if ( v73 < 0 )
            {
              v69 = v216[22];
              if ( !v69 )
                goto LABEL_477;
              goto LABEL_422;
            }
LABEL_104:
            if ( (v73 & 0x40) != 0 )
            {
              v74 = v216[22];
              if ( v74 )
              {
                v75 = *(_DWORD **)(v74 + 16);
                if ( (unsigned int)v75 < *(_DWORD *)(v74 + 20) )
                {
                  *(_DWORD *)(v74 + 16) = v75 + 1;
                  *v75 = 43;
LABEL_108:
                  ++v218;
                  v73 = *(_BYTE *)(v32 + 12);
LABEL_109:
                  if ( (v73 & 0x20) != 0 )
                  {
                    v76 = v216[22];
                    if ( v76 && (v77 = *(_DWORD **)(v76 + 16), (unsigned int)v77 < *(_DWORD *)(v76 + 20)) )
                    {
                      *(_DWORD *)(v76 + 16) = v77 + 1;
                      *v77 = 45;
                    }
                    else if ( _woverflow(v216, 45) == -1 )
                    {
                      goto LABEL_131;
                    }
                    ++v218;
                  }
                  if ( *(_DWORD *)(v32 + 16) == 48 )
                  {
                    v179 = v216[22];
                    if ( v179 && (v180 = *(_DWORD **)(v179 + 16), (unsigned int)v180 < *(_DWORD *)(v179 + 20)) )
                    {
                      *(_DWORD *)(v179 + 16) = v180 + 1;
                      *v180 = 48;
                    }
                    else if ( _woverflow(v216, 48) == -1 )
                    {
                      goto LABEL_131;
                    }
                    ++v218;
                  }
                  if ( (*(_BYTE *)(v32 + 13) & 8) != 0 )
                  {
                    v78 = v216[22];
                    if ( v78 && (v79 = *(_DWORD **)(v78 + 16), (unsigned int)v79 < *(_DWORD *)(v78 + 20)) )
                    {
                      *(_DWORD *)(v78 + 16) = v79 + 1;
                      *v79 = 73;
                    }
                    else if ( _woverflow(v216, 73) == -1 )
                    {
                      goto LABEL_131;
                    }
                    ++v218;
                  }
                  v53 = *(_DWORD *)(v32 + 4);
                  if ( v53 )
                  {
                    v219 = (int)&v223;
                    v80 = &v223;
                    do
                    {
                      --v80;
                      v81 = itowa_lower_digits[v53 % 0xA];
                      v53 /= 0xAu;
                      *v80 = (char *)v81;
                    }
                    while ( v53 );
                    if ( (unsigned int)v80 < v219 )
                    {
                      v217 = v32;
                      v82 = v218;
                      while ( 1 )
                      {
                        ++v80;
                        v84 = v216[22];
                        if ( v84 && (v83 = *(int **)(v84 + 16), (unsigned int)v83 < *(_DWORD *)(v84 + 20)) )
                        {
                          v53 = (unsigned int)(v83 + 1);
                          *(_DWORD *)(v84 + 16) = v83 + 1;
                          *v83 = v81;
                          if ( v81 == -1 )
                            goto LABEL_131;
                        }
                        else if ( _woverflow(v216, v81) == -1 )
                        {
                          goto LABEL_131;
                        }
                        ++v82;
                        if ( (unsigned int)v80 >= v219 )
                          break;
                        v81 = (int)*v80;
                      }
                      v218 = v82;
                      v32 = v217;
                    }
                  }
                  v150 = *(_DWORD *)v32;
                  if ( *(_DWORD *)v32 != -1 )
                  {
                    v151 = v216[22];
                    if ( v151 && (v152 = *(_DWORD **)(v151 + 16), (unsigned int)v152 < *(_DWORD *)(v151 + 20)) )
                    {
                      *(_DWORD *)(v151 + 16) = v152 + 1;
                      *v152 = 46;
                    }
                    else
                    {
                      if ( _woverflow(v216, 46) == -1 )
                        goto LABEL_131;
                      v150 = *(_DWORD *)v32;
                    }
                    ++v218;
                    v53 = v150;
                    v219 = (int)&v223;
                    v153 = &v223;
                    do
                    {
                      --v153;
                      v154 = itowa_lower_digits[v53 % 0xA];
                      v53 /= 0xAu;
                      *v153 = (char *)v154;
                    }
                    while ( v53 );
                    if ( (unsigned int)v153 < v219 )
                    {
                      v217 = v32;
                      v155 = v218;
                      while ( 1 )
                      {
                        ++v153;
                        v157 = v216[22];
                        if ( v157 && (v156 = *(int **)(v157 + 16), (unsigned int)v156 < *(_DWORD *)(v157 + 20)) )
                        {
                          v53 = (unsigned int)(v156 + 1);
                          *(_DWORD *)(v157 + 16) = v156 + 1;
                          *v156 = v154;
                          if ( v154 == -1 )
                            goto LABEL_131;
                        }
                        else if ( _woverflow(v216, v154) == -1 )
                        {
                          goto LABEL_131;
                        }
                        if ( v155 == 0x7FFFFFFF )
                          goto LABEL_131;
                        ++v155;
                        if ( (unsigned int)v153 >= v219 )
                          break;
                        v154 = (int)*v153;
                      }
                      v218 = v155;
                      v32 = v217;
                    }
                  }
                  v176 = *(_DWORD *)(v32 + 8);
                  if ( v176 )
                  {
                    v177 = v216[22];
                    if ( v177 && (v53 = *(_DWORD *)(v177 + 16), v53 < *(_DWORD *)(v177 + 20)) )
                    {
                      *(_DWORD *)(v177 + 16) = v53 + 4;
                      *(_DWORD *)v53 = v176;
                      if ( v176 == -1 )
                        goto LABEL_131;
                    }
                    else if ( _woverflow(v216, *(_DWORD *)(v32 + 8)) == -1 )
                    {
                      goto LABEL_131;
                    }
                    if ( v218 == 0x7FFFFFFF )
                      goto LABEL_131;
                    ++v218;
                  }
                  if ( a7 > 0x7FFFFFFE )
                    _assert_fail(
                      "(unsigned int) done < (unsigned int) INT_MAX",
                      "vfprintf.c",
                      2055,
                      "printf_positional");
                  v98 = v218;
                  if ( v218 > 0x7FFFFFFF - a7 )
                  {
LABEL_174:
                    __writegsdword(0xFFFFFFE8, 0x4Bu);
LABEL_131:
                    v56 = -1;
                    if ( v212 )
LABEL_76:
                      free(v212);
                    if ( v215 )
                      free(v215);
                    goto LABEL_88;
                  }
LABEL_192:
                  a7 += v98;
                  goto LABEL_66;
                }
              }
              v187 = _woverflow(v216, 43);
            }
            else
            {
              if ( (v73 & 0x10) == 0 )
                goto LABEL_109;
              v172 = v216[22];
              if ( v172 )
              {
                v173 = *(_DWORD **)(v172 + 16);
                if ( (unsigned int)v173 < *(_DWORD *)(v172 + 20) )
                {
                  *(_DWORD *)(v172 + 16) = v173 + 1;
                  *v173 = 32;
                  goto LABEL_108;
                }
              }
              v187 = _woverflow(v216, 32);
            }
            if ( v187 == -1 )
              goto LABEL_131;
            goto LABEL_108;
          }
          v72 = *(_DWORD **)(v69 + 16);
          v71 = *(_DWORD *)(v69 + 20);
        }
        if ( v71 > (unsigned int)v72 )
        {
          v218 = 2;
          *(_DWORD *)(v69 + 16) = v72 + 1;
          *v72 = 35;
          v73 = *(_BYTE *)(v32 + 12);
          if ( v73 >= 0 )
            goto LABEL_104;
          goto LABEL_422;
        }
        goto LABEL_473;
    }
  }
}
// 8086EE4: conditional instruction was optimized away because %var_494.4==8
// 8087448: variable 'v53' is possibly undefined
// 80481C0: using guessed type int __cdecl j_strnlen(_DWORD, _DWORD);
// 80481F0: using guessed type int __cdecl j_wcslen(_DWORD);
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80515F0: using guessed type void __noreturn _libc_fatal(const char *, ...);
// 8051620: using guessed type int __fastcall IO_vtable_check(_DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80D4220: using guessed type int itowa_lower_digits[36];
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 80ECD34: using guessed type int _printf_function_table;
// 80ECD94: using guessed type int _printf_arginfo_table;
// 80ECD98: using guessed type int _printf_va_arg_table;

//----- (08088250) --------------------------------------------------------
int __usercall vfwprintf@<eax>(long double a1@<st0>, int a2, int *a3, long double *a4)
{
  int v4; // edi
  int v5; // esi
  unsigned int v7; // edi
  bool v9; // zf
  int v11; // edi
  _DWORD *v12; // edx
  int *v13; // edx
  unsigned int v14; // eax
  char *v15; // edx
  char *v16; // kr00_4
  unsigned int v17; // ecx
  int v18; // edi
  int v19; // eax
  int v20; // eax
  unsigned int v21; // edi
  int v22; // esi
  int v23; // eax
  int *v24; // edx
  unsigned int v25; // esi
  int *v26; // edi
  int *v27; // eax
  unsigned int v28; // ecx
  signed int v29; // eax
  int v30; // esi
  int v31; // eax
  char *v32; // edx
  unsigned int v33; // ecx
  int v34; // edi
  void *v35; // esp
  _BYTE *v36; // edx
  int v37; // ecx
  const char *v38; // edx
  unsigned int v39; // esi
  int v40; // edi
  int v41; // eax
  int v42; // edx
  int v43; // eax
  int v44; // eax
  long double *v45; // esi
  unsigned int v46; // edx
  void *v47; // esp
  int v48; // eax
  _DWORD *v49; // edx
  unsigned int v50; // ecx
  unsigned int v51; // ecx
  int v52; // ecx
  char *v53; // esi
  char v54; // al
  char *v55; // ecx
  _BYTE *v56; // edx
  int v57; // edx
  int v58; // ecx
  int v59; // ecx
  int v60; // eax
  _DWORD *v61; // edx
  int v62; // eax
  _DWORD *v63; // edx
  unsigned int v64; // edi
  _DWORD *v65; // esi
  unsigned int *v66; // edx
  int v67; // eax
  unsigned int v68; // edx
  signed int v69; // esi
  unsigned int v70; // eax
  int v71; // eax
  int v72; // eax
  int v73; // eax
  int v74; // eax
  int v75; // eax
  int v76; // eax
  int v77; // eax
  int v78; // eax
  unsigned int v79; // edx
  void *v80; // esp
  unsigned int v81; // eax
  int v82; // eax
  int v83; // eax
  int v84; // eax
  int *v85; // edx
  unsigned int v86; // eax
  int v87; // eax
  int v88; // edx
  int *v89; // ecx
  int v90; // eax
  _QWORD *v91; // eax
  int v92; // eax
  _DWORD *v93; // edx
  int v94; // eax
  _DWORD *v95; // edx
  unsigned int v96; // edi
  _DWORD *v97; // esi
  unsigned int *v98; // edx
  int v99; // ecx
  unsigned int v100; // esi
  int v101; // edx
  int v102; // eax
  unsigned int v103; // esi
  int v104; // eax
  int *v105; // eax
  int *v106; // esi
  char *v107; // edi
  int *v108; // edx
  int v109; // esi
  char *v110; // edi
  char v111; // al
  int v112; // eax
  _DWORD *v113; // edx
  int v114; // eax
  int v115; // eax
  _DWORD *v116; // edx
  unsigned __int64 v117; // rax
  char *v118; // esi
  int *v119; // edx
  char v120; // al
  char *v121; // edi
  int v122; // eax
  int v123; // eax
  char *v124; // edi
  _BYTE *v125; // esi
  unsigned int v126; // eax
  int v127; // eax
  _DWORD *v128; // edx
  int v129; // eax
  _DWORD *v130; // edx
  int v131; // edi
  int v132; // eax
  __int64 v133; // rax
  int v134; // eax
  int v135; // eax
  unsigned int v136; // edx
  void *v137; // esp
  int v138; // eax
  char *v139; // esi
  _BOOL4 v140; // eax
  int v141; // eax
  int v142; // eax
  int v143; // edx
  int v144; // eax
  int v145; // esi
  int v146; // eax
  int v147; // eax
  int v148; // eax
  int v149; // eax
  int v150; // eax
  _BOOL4 v151; // eax
  _BOOL4 v152; // eax
  _BOOL4 v153; // eax
  int v154; // [esp-4h] [ebp-1074h]
  _DWORD *v155; // [esp-4h] [ebp-1074h]
  _BYTE v156[8]; // [esp+8h] [ebp-1068h] BYREF
  unsigned __int64 v157; // [esp+10h] [ebp-1060h]
  unsigned int v158; // [esp+18h] [ebp-1058h]
  int v159; // [esp+1Ch] [ebp-1054h]
  int v160; // [esp+20h] [ebp-1050h]
  int v161; // [esp+24h] [ebp-104Ch]
  int v162; // [esp+28h] [ebp-1048h]
  int v163; // [esp+2Ch] [ebp-1044h]
  int v164; // [esp+30h] [ebp-1040h]
  int v165; // [esp+34h] [ebp-103Ch]
  int v166; // [esp+38h] [ebp-1038h]
  int v167; // [esp+3Ch] [ebp-1034h]
  int v168; // [esp+40h] [ebp-1030h]
  int v169; // [esp+44h] [ebp-102Ch]
  char *v170; // [esp+48h] [ebp-1028h]
  int v171; // [esp+4Ch] [ebp-1024h]
  unsigned int v172; // [esp+50h] [ebp-1020h]
  int v173; // [esp+54h] [ebp-101Ch]
  int v174; // [esp+58h] [ebp-1018h]
  unsigned int v175; // [esp+5Ch] [ebp-1014h]
  unsigned int v176; // [esp+60h] [ebp-1010h]
  unsigned int v177; // [esp+64h] [ebp-100Ch]
  int *v178; // [esp+68h] [ebp-1008h]
  signed int v179; // [esp+6Ch] [ebp-1004h]
  int v180; // [esp+70h] [ebp-1000h]
  int v181; // [esp+74h] [ebp-FFCh]
  int *v182; // [esp+78h] [ebp-FF8h] BYREF
  long double *v183; // [esp+7Ch] [ebp-FF4h] BYREF
  long double *v184; // [esp+80h] [ebp-FF0h] BYREF
  long double *v185; // [esp+84h] [ebp-FECh] BYREF
  long double v186; // [esp+88h] [ebp-FE8h] BYREF
  int v187[4]; // [esp+94h] [ebp-FDCh] BYREF
  int *v188; // [esp+A4h] [ebp-FCCh] BYREF
  int v189; // [esp+A8h] [ebp-FC8h]
  unsigned int v190; // [esp+ACh] [ebp-FC4h]
  int v191; // [esp+B0h] [ebp-FC0h]
  int v192; // [esp+B4h] [ebp-FBCh]
  char v193[4000]; // [esp+B8h] [ebp-FB8h] BYREF
  char v194[24]; // [esp+1058h] [ebp-18h] BYREF

  v179 = __readgsdword(0xFFFFFFE8);
  if ( IO_fwide((_DWORD *)a2, 1) == 1 )
  {
    if ( (*(_DWORD *)a2 & 8) != 0 )
    {
      *(_DWORD *)a2 |= 0x20u;
      __writegsdword(0xFFFFFFE8, 9u);
    }
    else
    {
      if ( !a3 )
      {
        v181 = -1;
        __writegsdword(0xFFFFFFE8, 0x16u);
        return v181;
      }
      if ( IO_fwide((_DWORD *)a2, 1) == 1 )
      {
        v4 = *(_DWORD *)a2;
        v5 = *(_DWORD *)a2 & 2;
        if ( v5 )
          return buffered_vfprintf_0((_DWORD *)a2, (int)a3, (int)a4);
        v183 = a4;
        v178 = wcschrnul(a3, 37);
        v182 = v178;
        v180 = v4 & 0x8000;
        if ( (v4 & 0x8000) != 0 )
        {
          v180 = 0;
        }
        else
        {
          v187[0] = (int)funlockfile;
          v187[1] = a2;
          _EDX = *(_DWORD *)(a2 + 72);
          v7 = __readgsdword(8u);
          if ( v7 != *(_DWORD *)(_EDX + 8) )
          {
            _ECX = 1;
            v9 = __readgsdword(0xCu) == 0;
            if ( !v9 )
              __asm { lock }
            __asm { cmpxchg [edx], ecx }
            if ( !v9 )
              _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
            _EDX = *(_DWORD *)(a2 + 72);
            *(_DWORD *)(_EDX + 8) = v7;
          }
          ++*(_DWORD *)(_EDX + 4);
        }
        v11 = *(_DWORD *)(a2 + 148);
        v177 = (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables;
        if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v11
                                                                                              - (_DWORD)&_start___libc_IO_vtables) )
          IO_vtable_check((char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables);
        v181 = v178 - a3;
        if ( v181 != (*(int (__cdecl **)(int, int *, int))(v11 + 28))(a2, a3, v181) )
          goto LABEL_20;
        v13 = v182;
        if ( !*v182 )
          goto LABEL_21;
        if ( _printf_function_table || _printf_modifier_table || _printf_va_arg_table )
        {
          v160 = 0;
          v166 = -1;
          v162 = 0;
        }
        else
        {
          v160 = 0;
          v163 = 0;
          v166 = -1;
          v162 = 0;
          while ( 2 )
          {
            v182 = v13 + 1;
            v14 = v13[1];
            v15 = (char *)(v14 - 32);
            v175 = v14;
LABEL_37:
            v16 = v15;
            v15 = v194;
            v159 = 0;
            v173 = 0;
            v172 = 0;
            v17 = 0;
            v161 = 0;
            v18 = 0;
            v164 = 0;
            v168 = 0;
            v171 = 0;
            v167 = 0;
            v165 = 0;
            v169 = 32;
            v174 = -1;
            v170 = v194;
            v176 = 0;
            switch ( (unsigned int)v16 )
            {
              case 0u:
LABEL_177:
                while ( 2 )
                {
                  v71 = v182[1];
                  ++v182;
                  v175 = v71;
                  v167 = 1;
                  switch ( v71 )
                  {
                    case ' ':
                      continue;
                    case '#':
                      goto LABEL_180;
                    case '%':
                      goto LABEL_113;
                    case '\'':
                      goto LABEL_184;
                    case '*':
                      goto LABEL_97;
                    case '+':
                      goto LABEL_178;
                    case '-':
                      goto LABEL_179;
                    case '.':
                      goto LABEL_196;
                    case '0':
                      goto LABEL_181;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                      goto LABEL_187;
                    case 'A':
                    case 'a':
                      goto LABEL_210;
                    case 'C':
                      goto LABEL_42;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_227;
                    case 'I':
                      goto LABEL_186;
                    case 'L':
                    case 'j':
                    case 'q':
                      goto LABEL_38;
                    case 'S':
                    case 's':
                      goto LABEL_67;
                    case 'X':
                    case 'x':
                      goto LABEL_216;
                    case 'Z':
                    case 't':
                    case 'z':
                      goto LABEL_39;
                    case 'c':
                      goto LABEL_199;
                    case 'd':
                    case 'i':
                      goto LABEL_118;
                    case 'h':
                      goto LABEL_194;
                    case 'l':
                      goto LABEL_193;
                    case 'm':
                      goto LABEL_224;
                    case 'n':
                      goto LABEL_217;
                    case 'o':
                      goto LABEL_176;
                    case 'p':
                      goto LABEL_225;
                    case 'u':
                      goto LABEL_170;
                    default:
                      goto LABEL_109;
                  }
                }
              case 1u:
              case 2u:
              case 4u:
              case 6u:
              case 8u:
              case 9u:
              case 0xCu:
              case 0xFu:
              case 0x1Au:
              case 0x1Bu:
              case 0x1Cu:
              case 0x1Du:
              case 0x1Eu:
              case 0x1Fu:
              case 0x20u:
              case 0x22u:
              case 0x24u:
              case 0x28u:
              case 0x2Au:
              case 0x2Bu:
              case 0x2Du:
              case 0x2Eu:
              case 0x2Fu:
              case 0x30u:
              case 0x31u:
              case 0x32u:
              case 0x34u:
              case 0x35u:
              case 0x36u:
              case 0x37u:
              case 0x39u:
              case 0x3Bu:
              case 0x3Cu:
              case 0x3Du:
              case 0x3Eu:
              case 0x3Fu:
              case 0x40u:
              case 0x42u:
              case 0x4Bu:
              case 0x52u:
              case 0x56u:
              case 0x57u:
              case 0x59u:
LABEL_109:
                if ( v175 )
                  goto LABEL_345;
                __writegsdword(0xFFFFFFE8, 0x16u);
                goto LABEL_111;
              case 3u:
LABEL_180:
                while ( 2 )
                {
                  v74 = v182[1];
                  ++v182;
                  v175 = v74;
                  v165 = 1;
                  switch ( v74 )
                  {
                    case ' ':
                      goto LABEL_177;
                    case '#':
                      continue;
                    case '%':
                      goto LABEL_113;
                    case '\'':
                      goto LABEL_184;
                    case '*':
                      goto LABEL_97;
                    case '+':
                      goto LABEL_178;
                    case '-':
                      goto LABEL_179;
                    case '.':
                      goto LABEL_196;
                    case '0':
                      goto LABEL_181;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                      goto LABEL_187;
                    case 'A':
                    case 'a':
                      goto LABEL_210;
                    case 'C':
                      goto LABEL_42;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_227;
                    case 'I':
                      goto LABEL_186;
                    case 'L':
                    case 'j':
                    case 'q':
                      goto LABEL_38;
                    case 'S':
                    case 's':
                      goto LABEL_67;
                    case 'X':
                    case 'x':
                      goto LABEL_216;
                    case 'Z':
                    case 't':
                    case 'z':
                      goto LABEL_39;
                    case 'c':
                      goto LABEL_199;
                    case 'd':
                    case 'i':
                      goto LABEL_118;
                    case 'h':
                      goto LABEL_194;
                    case 'l':
                      goto LABEL_193;
                    case 'm':
                      goto LABEL_224;
                    case 'n':
                      goto LABEL_217;
                    case 'o':
                      goto LABEL_176;
                    case 'p':
                      goto LABEL_225;
                    case 'u':
                      goto LABEL_170;
                    default:
                      goto LABEL_109;
                  }
                }
              case 5u:
LABEL_113:
                v48 = *(_DWORD *)(a2 + 88);
                if ( v48 && (v49 = *(_DWORD **)(v48 + 16), (unsigned int)v49 < *(_DWORD *)(v48 + 20)) )
                {
                  *(_DWORD *)(v48 + 16) = v49 + 1;
                  *v49 = 37;
                }
                else if ( _woverflow((_DWORD *)a2, 37) == -1 )
                {
                  goto LABEL_111;
                }
                if ( v181 == 0x7FFFFFFF )
                  goto LABEL_111;
                ++v181;
                goto LABEL_58;
              case 7u:
LABEL_184:
                while ( 2 )
                {
                  if ( v166 == -1 )
                  {
                    v144 = *(_DWORD *)__readgsdword(0xFFFFFFE4);
                    v145 = *(_DWORD *)(v144 + 52);
                    v166 = *(_DWORD *)(v144 + 44);
                    LOBYTE(v144) = *(_BYTE *)v166;
                    v162 = v145;
                    if ( (_BYTE)v144 == 127 || (_BYTE)v144 == 0 || !v145 )
                      v166 = 0;
                  }
                  v77 = v182[1];
                  ++v182;
                  v175 = v77;
                  v164 = 1;
                  switch ( v77 )
                  {
                    case ' ':
                      goto LABEL_177;
                    case '#':
                      goto LABEL_180;
                    case '%':
                      goto LABEL_113;
                    case '\'':
                      continue;
                    case '*':
                      goto LABEL_97;
                    case '+':
                      goto LABEL_178;
                    case '-':
                      goto LABEL_179;
                    case '.':
                      goto LABEL_196;
                    case '0':
                      goto LABEL_181;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                      goto LABEL_187;
                    case 'A':
                    case 'a':
                      goto LABEL_210;
                    case 'C':
                      goto LABEL_42;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_227;
                    case 'I':
                      goto LABEL_186;
                    case 'L':
                    case 'j':
                    case 'q':
                      goto LABEL_38;
                    case 'S':
                    case 's':
                      goto LABEL_67;
                    case 'X':
                    case 'x':
                      goto LABEL_216;
                    case 'Z':
                    case 't':
                    case 'z':
                      goto LABEL_39;
                    case 'c':
                      goto LABEL_199;
                    case 'd':
                    case 'i':
                      goto LABEL_118;
                    case 'h':
                      goto LABEL_194;
                    case 'l':
                      goto LABEL_193;
                    case 'm':
                      goto LABEL_224;
                    case 'n':
                      goto LABEL_217;
                    case 'o':
                      goto LABEL_176;
                    case 'p':
                      goto LABEL_225;
                    case 'u':
                      goto LABEL_170;
                    default:
                      goto LABEL_109;
                  }
                }
              case 0xAu:
LABEL_97:
                v43 = v182[1];
                v188 = ++v182;
                if ( (unsigned int)(v43 - 48) > 9 )
                  goto LABEL_101;
                v175 = 0;
                v44 = read_int_0(&v188);
                v17 = v175;
                if ( v44 == -1 )
                  goto LABEL_284;
                if ( v44 && *v188 == 36 )
                  goto LABEL_345;
LABEL_101:
                v45 = (long double *)((char *)a4 + 4);
                v173 = *(_DWORD *)a4;
                if ( v173 < 0 )
                {
                  v173 = -v173;
                  v171 = 1;
                  v169 = 32;
                }
                if ( v173 > 536870878 )
                  goto LABEL_284;
                if ( v173 <= 967 )
                  goto LABEL_107;
                v46 = 4 * v173 + 128;
                if ( v46 <= 0x1000
                  || (v170 = (char *)v17,
                      v175 = 4 * v173 + 128,
                      v153 = _libc_alloca_cutoff(v175),
                      v46 = v175,
                      v17 = (unsigned int)v170,
                      v153) )
                {
                  v47 = alloca(v46 + 15);
                  v170 = &v156[v46];
LABEL_107:
                  v175 = *v182;
                  a4 = (long double *)((char *)a4 + 4);
                  switch ( v175 )
                  {
                    case ' ':
                    case '!':
                    case '"':
                    case '#':
                    case '$':
                    case '&':
                    case '\'':
                    case '(':
                    case ')':
                    case '*':
                    case '+':
                    case ',':
                    case '-':
                    case '/':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case ':':
                    case ';':
                    case '<':
                    case '=':
                    case '>':
                    case '?':
                    case '@':
                    case 'B':
                    case 'D':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'Y':
                    case '[':
                    case '\\':
                    case ']':
                    case '^':
                    case '_':
                    case '`':
                    case 'b':
                    case 'k':
                    case 'r':
                    case 'v':
                    case 'w':
                    case 'y':
                      goto LABEL_109;
                    case '%':
                      goto LABEL_113;
                    case '.':
                      goto LABEL_196;
                    case 'A':
                    case 'a':
                      goto LABEL_210;
                    case 'C':
                      goto LABEL_42;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_227;
                    case 'L':
                    case 'j':
                    case 'q':
                      goto LABEL_38;
                    case 'S':
                    case 's':
                      goto LABEL_67;
                    case 'X':
                    case 'x':
                      goto LABEL_216;
                    case 'Z':
                    case 't':
                    case 'z':
                      goto LABEL_39;
                    case 'c':
                      goto LABEL_199;
                    case 'd':
                    case 'i':
                      goto LABEL_118;
                    case 'h':
                      goto LABEL_194;
                    case 'l':
                      goto LABEL_193;
                    case 'm':
                      goto LABEL_224;
                    case 'n':
                      goto LABEL_217;
                    case 'o':
                      goto LABEL_176;
                    case 'p':
                      goto LABEL_225;
                    case 'u':
                      goto LABEL_170;
                    default:
                      a4 = v45;
                      goto LABEL_109;
                  }
                }
                v176 = malloc(v175);
                v17 = (unsigned int)v170;
                if ( v176 )
                {
                  v170 = (char *)(v176 + v175);
                  goto LABEL_107;
                }
                goto LABEL_20;
              case 0xBu:
LABEL_178:
                while ( 2 )
                {
                  v72 = v182[1];
                  ++v182;
                  v175 = v72;
                  v168 = 1;
                  switch ( v72 )
                  {
                    case ' ':
                      goto LABEL_177;
                    case '#':
                      goto LABEL_180;
                    case '%':
                      goto LABEL_113;
                    case '\'':
                      goto LABEL_184;
                    case '*':
                      goto LABEL_97;
                    case '+':
                      continue;
                    case '-':
                      goto LABEL_179;
                    case '.':
                      goto LABEL_196;
                    case '0':
                      goto LABEL_181;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                      goto LABEL_187;
                    case 'A':
                    case 'a':
                      goto LABEL_210;
                    case 'C':
                      goto LABEL_42;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_227;
                    case 'I':
                      goto LABEL_186;
                    case 'L':
                    case 'j':
                    case 'q':
                      goto LABEL_38;
                    case 'S':
                    case 's':
                      goto LABEL_67;
                    case 'X':
                    case 'x':
                      goto LABEL_216;
                    case 'Z':
                    case 't':
                    case 'z':
                      goto LABEL_39;
                    case 'c':
                      goto LABEL_199;
                    case 'd':
                    case 'i':
                      goto LABEL_118;
                    case 'h':
                      goto LABEL_194;
                    case 'l':
                      goto LABEL_193;
                    case 'm':
                      goto LABEL_224;
                    case 'n':
                      goto LABEL_217;
                    case 'o':
                      goto LABEL_176;
                    case 'p':
                      goto LABEL_225;
                    case 'u':
                      goto LABEL_170;
                    default:
                      goto LABEL_109;
                  }
                }
              case 0xDu:
LABEL_179:
                while ( 2 )
                {
                  v73 = v182[1];
                  ++v182;
                  v175 = v73;
                  v171 = 1;
                  v169 = 32;
                  switch ( v73 )
                  {
                    case ' ':
                      goto LABEL_177;
                    case '#':
                      goto LABEL_180;
                    case '%':
                      goto LABEL_113;
                    case '\'':
                      goto LABEL_184;
                    case '*':
                      goto LABEL_97;
                    case '+':
                      goto LABEL_178;
                    case '-':
                      continue;
                    case '.':
                      goto LABEL_196;
                    case '0':
                      goto LABEL_181;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                      goto LABEL_187;
                    case 'A':
                    case 'a':
                      goto LABEL_210;
                    case 'C':
                      goto LABEL_42;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_227;
                    case 'I':
                      goto LABEL_186;
                    case 'L':
                    case 'j':
                    case 'q':
                      goto LABEL_38;
                    case 'S':
                    case 's':
                      goto LABEL_67;
                    case 'X':
                    case 'x':
                      goto LABEL_216;
                    case 'Z':
                    case 't':
                    case 'z':
                      goto LABEL_39;
                    case 'c':
                      goto LABEL_199;
                    case 'd':
                    case 'i':
                      goto LABEL_118;
                    case 'h':
                      goto LABEL_194;
                    case 'l':
                      goto LABEL_193;
                    case 'm':
                      goto LABEL_224;
                    case 'n':
                      goto LABEL_217;
                    case 'o':
                      goto LABEL_176;
                    case 'p':
                      goto LABEL_225;
                    case 'u':
                      goto LABEL_170;
                    default:
                      goto LABEL_109;
                  }
                }
              case 0xEu:
LABEL_196:
                v85 = v182++;
                v86 = *v182;
                if ( *v182 != 42 )
                {
                  v174 = 0;
                  if ( v86 - 48 > 9 )
                  {
LABEL_198:
                    v175 = v86;
                    switch ( v86 )
                    {
                      case '%':
                        goto LABEL_113;
                      case 'A':
                      case 'a':
                        goto LABEL_210;
                      case 'C':
                        goto LABEL_42;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        goto LABEL_227;
                      case 'L':
                      case 'j':
                      case 'q':
                        goto LABEL_38;
                      case 'S':
                      case 's':
                        goto LABEL_67;
                      case 'X':
                      case 'x':
                        goto LABEL_216;
                      case 'Z':
                      case 't':
                      case 'z':
                        goto LABEL_39;
                      case 'c':
                        goto LABEL_199;
                      case 'd':
                      case 'i':
                        goto LABEL_118;
                      case 'h':
                        goto LABEL_194;
                      case 'l':
                        goto LABEL_193;
                      case 'm':
                        goto LABEL_224;
                      case 'n':
                        goto LABEL_217;
                      case 'o':
                        goto LABEL_176;
                      case 'p':
                        goto LABEL_225;
                      case 'u':
                        goto LABEL_170;
                      default:
                        goto LABEL_109;
                    }
                  }
                  v175 = v17;
                  v174 = read_int_0(&v182);
                  v17 = v175;
                  if ( v174 == -1 )
                    goto LABEL_284;
LABEL_365:
                  if ( v173 >= v174 || v174 <= 968 )
                    goto LABEL_383;
                  if ( v176 )
                  {
                    v175 = v17;
                    free(v176);
                    v17 = v175;
                  }
                  if ( v174 > 536870878 )
                  {
LABEL_297:
                    __writegsdword(0xFFFFFFE8, 0x4Bu);
                  }
                  else
                  {
                    v136 = 4 * v174 + 128;
                    if ( v136 <= 0x1000
                      || (v175 = v17,
                          v176 = 4 * v174 + 128,
                          v140 = _libc_alloca_cutoff(v176),
                          v136 = v176,
                          v17 = v175,
                          v140) )
                    {
                      v176 = 0;
                      v137 = alloca(v136 + 15);
                      v170 = &v156[v136];
                      v86 = *v182;
                      goto LABEL_198;
                    }
                    v170 = (char *)v175;
                    v175 = v176;
                    v176 = malloc(v176);
                    v17 = (unsigned int)v170;
                    if ( v176 )
                    {
                      v170 = (char *)(v176 + v175);
LABEL_383:
                      v86 = *v182;
                      goto LABEL_198;
                    }
                  }
LABEL_20:
                  v181 = -1;
LABEL_21:
                  if ( (*(_DWORD *)a2 & 0x8000) == 0 )
                  {
                    v12 = *(_DWORD **)(a2 + 72);
                    v9 = v12[1]-- == 1;
                    if ( v9 )
                    {
                      v12[2] = 0;
                      if ( __readgsdword(0xCu) )
                        __asm { lock }
                      v9 = (*v12)-- == 1;
                      if ( !v9 )
                        _lll_unlock_wake_private(v12);
                    }
                  }
                  if ( v180 )
                  {
                    MEMORY[0](v187, 0);
                    return v181;
                  }
                  return v181;
                }
                v182 = v85 + 2;
                v188 = v85 + 2;
                if ( (unsigned int)(v85[2] - 48) > 9 )
                  goto LABEL_362;
                v175 = v17;
                v134 = read_int_0(&v188);
                v17 = v175;
                if ( v134 == -1 )
                {
LABEL_284:
                  __writegsdword(0xFFFFFFE8, 0x4Bu);
LABEL_111:
                  if ( v176 )
                    free(v176);
                  goto LABEL_20;
                }
                if ( !v134 || *v188 != 36 )
                {
LABEL_362:
                  v135 = -1;
                  if ( *(int *)a4 >= 0 )
                    v135 = *(_DWORD *)a4;
                  v174 = v135;
                  a4 = (long double *)((char *)a4 + 4);
                  goto LABEL_365;
                }
LABEL_345:
                v5 = v163;
                if ( v176 )
                  free(v176);
                break;
              case 0x10u:
LABEL_181:
                while ( 2 )
                {
                  v75 = 48;
                  if ( v171 )
                    v75 = v169;
                  v169 = v75;
                  v76 = v182[1];
                  ++v182;
                  v175 = v76;
                  switch ( v76 )
                  {
                    case ' ':
                      goto LABEL_177;
                    case '#':
                      goto LABEL_180;
                    case '%':
                      goto LABEL_113;
                    case '\'':
                      goto LABEL_184;
                    case '*':
                      goto LABEL_97;
                    case '+':
                      goto LABEL_178;
                    case '-':
                      goto LABEL_179;
                    case '.':
                      goto LABEL_196;
                    case '0':
                      continue;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                      goto LABEL_187;
                    case 'A':
                    case 'a':
                      goto LABEL_210;
                    case 'C':
                      goto LABEL_42;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_227;
                    case 'I':
                      goto LABEL_186;
                    case 'L':
                    case 'j':
                    case 'q':
                      goto LABEL_38;
                    case 'S':
                    case 's':
                      goto LABEL_67;
                    case 'X':
                    case 'x':
                      goto LABEL_216;
                    case 'Z':
                    case 't':
                    case 'z':
                      goto LABEL_39;
                    case 'c':
                      goto LABEL_199;
                    case 'd':
                    case 'i':
                      goto LABEL_118;
                    case 'h':
                      goto LABEL_194;
                    case 'l':
                      goto LABEL_193;
                    case 'm':
                      goto LABEL_224;
                    case 'n':
                      goto LABEL_217;
                    case 'o':
                      goto LABEL_176;
                    case 'p':
                      goto LABEL_225;
                    case 'u':
                      goto LABEL_170;
                    default:
                      goto LABEL_109;
                  }
                }
              case 0x11u:
              case 0x12u:
              case 0x13u:
              case 0x14u:
              case 0x15u:
              case 0x16u:
              case 0x17u:
              case 0x18u:
              case 0x19u:
LABEL_187:
                v175 = 0;
                v173 = read_int_0(&v182);
                v17 = v175;
                if ( (unsigned int)v173 > 0x1FFFFFDE )
                  goto LABEL_284;
                if ( v173 <= 967 )
                  goto LABEL_191;
                v79 = 4 * v173 + 128;
                if ( v79 <= 0x1000
                  || (v170 = (char *)v175,
                      v175 = 4 * v173 + 128,
                      v152 = _libc_alloca_cutoff(v175),
                      v79 = v175,
                      v17 = (unsigned int)v170,
                      v152) )
                {
                  v80 = alloca(v79 + 15);
                  v170 = &v156[v79];
                }
                else
                {
                  v176 = malloc(v175);
                  v17 = (unsigned int)v170;
                  if ( !v176 )
                    goto LABEL_20;
                  v170 = (char *)(v176 + v175);
                }
LABEL_191:
                v81 = *v182;
                if ( *v182 != 36 )
                {
                  v175 = *v182;
                  switch ( v81 )
                  {
                    case '%':
                      goto LABEL_113;
                    case '.':
                      goto LABEL_196;
                    case 'A':
                    case 'a':
                      goto LABEL_210;
                    case 'C':
                      goto LABEL_42;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_227;
                    case 'L':
                    case 'j':
                    case 'q':
                      goto LABEL_38;
                    case 'S':
                    case 's':
                      goto LABEL_67;
                    case 'X':
                    case 'x':
                      goto LABEL_216;
                    case 'Z':
                    case 't':
                    case 'z':
                      goto LABEL_39;
                    case 'c':
                      goto LABEL_199;
                    case 'd':
                    case 'i':
                      goto LABEL_118;
                    case 'h':
                      goto LABEL_194;
                    case 'l':
                      goto LABEL_193;
                    case 'm':
                      goto LABEL_224;
                    case 'n':
                      goto LABEL_217;
                    case 'o':
                      goto LABEL_176;
                    case 'p':
                      goto LABEL_225;
                    case 'u':
                      goto LABEL_170;
                    default:
                      goto LABEL_109;
                  }
                }
                goto LABEL_345;
              case 0x21u:
              case 0x41u:
LABEL_210:
                v191 = 1024;
                v188 = (int *)v174;
                v189 = v173;
                v190 = v175;
                LOBYTE(v191) = ((_BYTE)v168 << 6) | (32 * v171) | (16 * v167) | (8 * v165) | (4 * v17) | v18 | (2 * v161) | ((_BYTE)v164 << 7);
                v192 = v169;
                if ( v18 )
                {
                  a1 = *a4++;
                  v186 = a1;
                }
                else
                {
                  a1 = *(double *)a4;
                  a4 = (long double *)((char *)a4 + 8);
                  *(double *)&v186 = a1;
                }
                v185 = &v186;
                v90 = _printf_fphex((_DWORD *)a2, (int)&v188, (double **)&v185);
                if ( v90 >= 0 )
                  goto LABEL_213;
                goto LABEL_111;
              case 0x23u:
                goto LABEL_42;
              case 0x25u:
              case 0x26u:
              case 0x27u:
              case 0x45u:
              case 0x46u:
              case 0x47u:
LABEL_227:
                v188 = (int *)v174;
                v189 = v173;
                v190 = v175;
                v191 = (unsigned __int8)(((_BYTE)v168 << 6) | (32 * v171) | (16 * v167) | (8 * v165) | (4 * v17) | v18 | (2 * v161) | ((_BYTE)v164 << 7));
                BYTE1(v191) = (8 * v159) | 4;
                v192 = v169;
                if ( v18 )
                {
                  a1 = *a4++;
                  v186 = a1;
                }
                else
                {
                  a1 = *(double *)a4;
                  a4 = (long double *)((char *)a4 + 8);
                  *(double *)&v186 = a1;
                }
                v184 = &v186;
                v90 = _printf_fp((_DWORD *)a2, (int)&v188, &v184);
                if ( v90 < 0 )
                  goto LABEL_111;
LABEL_213:
                if ( (unsigned int)v181 > 0x7FFFFFFE )
                  goto LABEL_431;
                if ( v90 > (unsigned int)(0x7FFFFFFF - v181) )
                  goto LABEL_284;
                v181 += v90;
                goto LABEL_58;
              case 0x29u:
LABEL_186:
                while ( 2 )
                {
                  v78 = v182[1];
                  ++v182;
                  v175 = v78;
                  v159 = 1;
                  switch ( v78 )
                  {
                    case ' ':
                      goto LABEL_177;
                    case '#':
                      goto LABEL_180;
                    case '%':
                      goto LABEL_113;
                    case '\'':
                      goto LABEL_184;
                    case '*':
                      goto LABEL_97;
                    case '+':
                      goto LABEL_178;
                    case '-':
                      goto LABEL_179;
                    case '.':
                      goto LABEL_196;
                    case '0':
                      goto LABEL_181;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                      goto LABEL_187;
                    case 'A':
                    case 'a':
                      goto LABEL_210;
                    case 'C':
                      goto LABEL_42;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_227;
                    case 'I':
                      continue;
                    case 'L':
                    case 'j':
                    case 'q':
                      goto LABEL_38;
                    case 'S':
                    case 's':
                      goto LABEL_67;
                    case 'X':
                    case 'x':
                      goto LABEL_216;
                    case 'Z':
                    case 't':
                    case 'z':
                      goto LABEL_39;
                    case 'c':
                      goto LABEL_199;
                    case 'd':
                    case 'i':
                      goto LABEL_118;
                    case 'h':
                      goto LABEL_194;
                    case 'l':
                      goto LABEL_193;
                    case 'm':
                      goto LABEL_224;
                    case 'n':
                      goto LABEL_217;
                    case 'o':
                      goto LABEL_176;
                    case 'p':
                      goto LABEL_225;
                    case 'u':
                      goto LABEL_170;
                    default:
                      goto LABEL_109;
                  }
                }
              case 0x2Cu:
              case 0x4Au:
              case 0x51u:
LABEL_38:
                v19 = v182[1];
                ++v182;
                v175 = v19;
                v17 = 1;
                v18 = 1;
                switch ( v19 )
                {
                  case '%':
                    goto LABEL_113;
                  case 'A':
                  case 'a':
                    goto LABEL_210;
                  case 'C':
                    goto LABEL_42;
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'e':
                  case 'f':
                  case 'g':
                    goto LABEL_227;
                  case 'S':
                  case 's':
                    goto LABEL_67;
                  case 'X':
                  case 'x':
                    goto LABEL_216;
                  case 'c':
                    goto LABEL_199;
                  case 'd':
                  case 'i':
                    goto LABEL_118;
                  case 'm':
                    goto LABEL_224;
                  case 'n':
                    goto LABEL_217;
                  case 'o':
                    goto LABEL_176;
                  case 'p':
                    goto LABEL_225;
                  case 'u':
                    goto LABEL_170;
                  default:
                    goto LABEL_109;
                }
              case 0x33u:
              case 0x53u:
LABEL_67:
                v32 = *(char **)a4;
                a4 = (long double *)((char *)a4 + 4);
                goto LABEL_68;
              case 0x38u:
              case 0x58u:
LABEL_216:
                v158 = 16;
                goto LABEL_171;
              case 0x3Au:
              case 0x54u:
              case 0x5Au:
LABEL_39:
                v20 = v182[1];
                ++v182;
                v175 = v20;
                v17 = 0;
                v18 = 0;
                switch ( v20 )
                {
                  case '%':
                    goto LABEL_113;
                  case 'A':
                  case 'a':
                    goto LABEL_210;
                  case 'C':
                    goto LABEL_42;
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'e':
                  case 'f':
                  case 'g':
                    goto LABEL_227;
                  case 'S':
                  case 's':
                    goto LABEL_67;
                  case 'X':
                  case 'x':
                    goto LABEL_216;
                  case 'c':
                    goto LABEL_199;
                  case 'd':
                  case 'i':
                    goto LABEL_118;
                  case 'm':
                    goto LABEL_224;
                  case 'n':
                    goto LABEL_217;
                  case 'o':
                    goto LABEL_176;
                  case 'p':
                    goto LABEL_225;
                  case 'u':
                    goto LABEL_170;
                  default:
                    goto LABEL_109;
                }
              case 0x43u:
LABEL_199:
                if ( v17 )
                {
LABEL_42:
                  v21 = v173 - 1;
                  LOBYTE(v175) = v173 - 1 > 0;
                  if ( !v171 && v173 - 1 > 0 )
                  {
                    if ( v21 != IO_wpadn(a2, 32, v173 - 1) )
                      goto LABEL_111;
                    if ( (unsigned int)v181 > 0x7FFFFFFE )
                      goto LABEL_433;
                    if ( v21 > 0x7FFFFFFF - v181 )
                      goto LABEL_284;
                    v181 += v21;
                  }
                  v174 = (int)a4 + 4;
                  v22 = *(_DWORD *)a4;
                  v23 = *(_DWORD *)(a2 + 88);
                  if ( v23 )
                  {
                    v24 = *(int **)(v23 + 16);
                    if ( (unsigned int)v24 < *(_DWORD *)(v23 + 20) )
                    {
                      *(_DWORD *)(v23 + 16) = v24 + 1;
                      *v24 = v22;
                      if ( v22 == -1 )
                        goto LABEL_111;
                      goto LABEL_51;
                    }
                  }
                  v138 = _woverflow((_DWORD *)a2, *(_DWORD *)a4);
                }
                else
                {
                  v21 = v173 - 1;
                  LOBYTE(v175) = v173 - 1 > 0;
                  if ( !v171 && v173 - 1 > 0 )
                  {
                    if ( v21 != IO_wpadn(a2, 32, v173 - 1) )
                      goto LABEL_111;
                    if ( (unsigned int)v181 > 0x7FFFFFFE )
LABEL_433:
                      _assert_fail("(unsigned int) done < (unsigned int) INT_MAX", "vfprintf.c", 1637, "_IO_vfwprintf");
                    if ( v21 > 0x7FFFFFFF - v181 )
                      goto LABEL_284;
                    v181 += v21;
                  }
                  v174 = (int)a4 + 4;
                  v87 = btowc(*(unsigned __int8 *)a4);
                  v88 = *(_DWORD *)(a2 + 88);
                  if ( v88 )
                  {
                    v89 = *(int **)(v88 + 16);
                    if ( (unsigned int)v89 < *(_DWORD *)(v88 + 20) )
                    {
                      *(_DWORD *)(v88 + 16) = v89 + 1;
                      *v89 = v87;
                      if ( v87 == -1 )
                        goto LABEL_111;
                      goto LABEL_51;
                    }
                  }
                  v138 = _woverflow((_DWORD *)a2, v87);
                }
                if ( v138 == -1 )
                  goto LABEL_111;
LABEL_51:
                if ( v181 == 0x7FFFFFFF )
                  goto LABEL_111;
                v25 = ++v181;
                if ( v171 && (_BYTE)v175 )
                {
                  if ( v21 != IO_wpadn(a2, 32, v21) )
                    goto LABEL_111;
                  if ( v25 > 0x7FFFFFFE )
                    goto LABEL_433;
                  if ( v21 > 0x7FFFFFFF - v25 )
                    goto LABEL_284;
                  v181 += v21;
                  a4 = (long double *)v174;
                }
                else
                {
                  a4 = (long double *)v174;
                }
                goto LABEL_58;
              case 0x44u:
              case 0x49u:
LABEL_118:
                if ( v18 )
                {
                  v133 = *(_QWORD *)a4;
                  v158 = 10;
                  v172 = HIDWORD(v133) >> 31;
                  v157 = abs64(v133);
                  a4 = (long double *)((char *)a4 + 8);
                  goto LABEL_300;
                }
                if ( v172 )
                {
                  v50 = *(char *)a4;
                  a4 = (long double *)((char *)a4 + 4);
                }
                else
                {
                  if ( v161 )
                    v50 = *(__int16 *)a4;
                  else
                    v50 = *(_DWORD *)a4;
                  a4 = (long double *)((char *)a4 + 4);
                }
                v158 = 10;
                v172 = v50 >> 31;
                v51 = abs32(v50);
                LODWORD(v157) = v51;
                goto LABEL_124;
              case 0x48u:
LABEL_194:
                v83 = v182[1];
                ++v182;
                v175 = v83;
                v161 = 1;
                switch ( v83 )
                {
                  case '%':
                    goto LABEL_113;
                  case 'X':
                  case 'x':
                    goto LABEL_216;
                  case 'd':
                  case 'i':
                    goto LABEL_118;
                  case 'h':
                    v84 = v182[1];
                    ++v182;
                    v175 = v84;
                    v172 = 1;
                    v161 = 0;
                    switch ( v84 )
                    {
                      case '%':
                        goto LABEL_113;
                      case 'A':
                      case 'a':
                        goto LABEL_210;
                      case 'C':
                        goto LABEL_42;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        goto LABEL_227;
                      case 'S':
                      case 's':
                        goto LABEL_67;
                      case 'X':
                      case 'x':
                        goto LABEL_216;
                      case 'c':
                        goto LABEL_199;
                      case 'd':
                      case 'i':
                        goto LABEL_118;
                      case 'm':
                        goto LABEL_224;
                      case 'n':
                        goto LABEL_217;
                      case 'o':
                        goto LABEL_176;
                      case 'p':
                        goto LABEL_225;
                      case 'u':
                        goto LABEL_170;
                      default:
                        goto LABEL_109;
                    }
                  case 'n':
                    goto LABEL_217;
                  case 'o':
                    goto LABEL_176;
                  case 'u':
                    goto LABEL_170;
                  default:
                    goto LABEL_109;
                }
              case 0x4Cu:
LABEL_193:
                v82 = v182[1];
                ++v182;
                v175 = v82;
                v17 = 1;
                switch ( v82 )
                {
                  case '%':
                    goto LABEL_113;
                  case 'A':
                  case 'a':
                    goto LABEL_210;
                  case 'C':
                    goto LABEL_42;
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'e':
                  case 'f':
                  case 'g':
                    goto LABEL_227;
                  case 'S':
                  case 's':
                    goto LABEL_67;
                  case 'X':
                  case 'x':
                    goto LABEL_216;
                  case 'c':
                    goto LABEL_199;
                  case 'd':
                  case 'i':
                    goto LABEL_118;
                  case 'l':
                    goto LABEL_38;
                  case 'm':
                    goto LABEL_224;
                  case 'n':
                    goto LABEL_217;
                  case 'o':
                    goto LABEL_176;
                  case 'p':
                    goto LABEL_225;
                  case 'u':
                    goto LABEL_170;
                  default:
                    goto LABEL_109;
                }
              case 0x4Du:
LABEL_224:
                v32 = (char *)strerror_r(a1, v179, v193, 0xFA0u);
                v17 = 0;
LABEL_68:
                if ( v32 )
                {
                  if ( v17 || v175 == 83 )
                  {
                    if ( v174 != -1 )
                      goto LABEL_311;
                    v174 = (int)v32;
                    v37 = j_wcslen(v32);
                    v175 = 0;
                    v38 = (const char *)v174;
                  }
                  else
                  {
                    LODWORD(v186) = v32;
                    if ( v174 == -1 )
                      v33 = strlen(v32);
                    else
                      v33 = j_strnlen(v32, v174);
                    if ( v33 > 0x3FFFFFFF )
                      goto LABEL_284;
                    v34 = 4 * v33;
                    if ( 4 * v33 <= 0x1000 || (v175 = v33, v151 = _libc_alloca_cutoff(4 * v33), v33 = v175, v151) )
                    {
                      v175 = 0;
                      v35 = alloca(v34 + 15);
                      v36 = v156;
                    }
                    else
                    {
                      v174 = v175;
                      v36 = (_BYTE *)malloc(v34);
                      if ( !v36 )
                        goto LABEL_111;
                      v175 = 1;
                      v33 = v174;
                    }
                    v174 = (int)v36;
                    v188 = 0;
                    v189 = 0;
                    v37 = mbsrtowcs((int)v36, (_BYTE **)&v186, v33, &v188);
                    v38 = (const char *)v174;
                    if ( v37 == -1 )
                      goto LABEL_111;
                  }
                }
                else
                {
                  v175 = 0;
                  if ( v174 == -1 || (v37 = 0, v38 = (const char *)&unk_80CD074, v174 > 5) )
                  {
                    v37 = 6;
                    v38 = "(";
                  }
                }
                goto LABEL_77;
              case 0x4Eu:
LABEL_217:
                if ( (*(_BYTE *)(a2 + 60) & 4) != 0 && !v160 )
                {
                  v146 = j_wcslen(a3);
                  v160 = _readonly_area((unsigned int)a3, 4 * v146 + 4);
                  if ( v160 < 0 )
                    _libc_fatal("*** %n in writable segment detected ***\n", v155);
                }
                v91 = *(_QWORD **)a4;
                if ( v18 )
                {
                  *v91 = v181;
                  a4 = (long double *)((char *)a4 + 4);
                }
                else if ( v172 )
                {
                  *(_BYTE *)v91 = v181;
                  a4 = (long double *)((char *)a4 + 4);
                }
                else
                {
                  if ( v161 )
                    *(_WORD *)v91 = v181;
                  else
                    *(_DWORD *)v91 = v181;
                  a4 = (long double *)((char *)a4 + 4);
                }
                goto LABEL_58;
              case 0x4Fu:
LABEL_176:
                v158 = 8;
                goto LABEL_171;
              case 0x50u:
LABEL_225:
                v51 = *(_DWORD *)a4;
                if ( *(_DWORD *)a4 )
                {
                  LODWORD(v157) = *(_DWORD *)a4;
                  a4 = (long double *)((char *)a4 + 4);
                  v164 = 0;
                  v165 = 1;
                  v172 = 0;
                  v175 = 120;
                  v158 = 16;
                  goto LABEL_124;
                }
                v143 = 5;
                a4 = (long double *)((char *)a4 + 4);
                if ( v174 >= 5 )
                  v143 = v174;
                v174 = v143;
                v32 = "(";
LABEL_311:
                v154 = v174;
                v174 = (int)v32;
                v37 = wcsnlen(v32, v154);
                v175 = 0;
                v38 = (const char *)v174;
LABEL_77:
                v39 = v173 - v37;
                if ( v173 - v37 < 0 )
                {
                  if ( v181 < 0 )
LABEL_430:
                    _assert_fail("(size_t) done <= (size_t) INT_MAX", "vfprintf.c", 1637, "_IO_vfwprintf");
                  v131 = *(_DWORD *)(a2 + 148);
                  if ( v177 <= v131 - (int)&_start___libc_IO_vtables )
                  {
                    v174 = v37;
                    v175 = (unsigned int)v38;
                    IO_vtable_check(v37);
                    v37 = v174;
                    v38 = (const char *)v175;
                  }
                  v175 = v37;
                  v132 = (*(int (__cdecl **)(int, const char *, int))(v131 + 28))(a2, v38, v37);
                  if ( v175 != v132 )
                    goto LABEL_111;
                  if ( v175 > 0x7FFFFFFF - v181 )
                    goto LABEL_284;
                  v181 += v175;
                }
                else
                {
                  LOBYTE(v174) = v173 != v37;
                  if ( !v171 && v173 != v37 )
                  {
                    v172 = v37;
                    v173 = (int)v38;
                    if ( v39 != IO_wpadn(a2, 32, v39) )
                      goto LABEL_111;
                    if ( (unsigned int)v181 > 0x7FFFFFFE )
                      goto LABEL_433;
                    v37 = v172;
                    v38 = (const char *)v173;
                    if ( v39 > 0x7FFFFFFF - v181 )
                      goto LABEL_284;
                    v181 += v39;
                  }
                  if ( v181 < 0 )
                    goto LABEL_430;
                  v40 = *(_DWORD *)(a2 + 148);
                  if ( v177 <= v40 - (int)&_start___libc_IO_vtables )
                  {
                    v172 = v37;
                    v173 = (int)v38;
                    IO_vtable_check(v37);
                    v37 = v172;
                    v38 = (const char *)v173;
                  }
                  v172 = v37;
                  v173 = (int)v38;
                  v41 = (*(int (__cdecl **)(int, const char *, int))(v40 + 28))(a2, v38, v37);
                  if ( v172 != v41 )
                    goto LABEL_111;
                  v42 = v173;
                  if ( v172 > 0x7FFFFFFF - v181 )
                    goto LABEL_284;
                  v181 += v172;
                  if ( v171 && (_BYTE)v174 )
                  {
                    v174 = v173;
                    if ( v39 != IO_wpadn(a2, 32, v39) )
                      goto LABEL_111;
                    if ( (unsigned int)v181 > 0x7FFFFFFE )
                      goto LABEL_433;
                    v42 = v174;
                    if ( v39 > 0x7FFFFFFF - v181 )
                      goto LABEL_284;
                    v181 += v39;
                  }
                  if ( v175 )
                    free(v42);
                }
                goto LABEL_58;
              case 0x55u:
LABEL_170:
                v158 = 10;
LABEL_171:
                if ( v18 )
                {
                  v117 = *(_QWORD *)a4;
                  v168 = 0;
                  v167 = 0;
                  v172 = 0;
                  v157 = v117;
                  a4 = (long double *)((char *)a4 + 8);
LABEL_300:
                  if ( v174 < 0 )
                  {
                    v174 = 1;
                  }
                  else
                  {
                    if ( !v174 && !v157 )
                    {
                      if ( v158 == 8 && v165 )
                      {
                        v52 = 4;
                        v164 = 1;
                        v169 = 32;
                        v118 = v170 - 4;
                        *(_DWORD *)v118 = 48;
                        v161 = (int)v118;
                      }
                      else
                      {
                        v164 = 0;
                        v52 = 0;
                        v169 = 32;
                        v161 = (int)v170;
                      }
LABEL_306:
                      LODWORD(v157) = v157 != 0;
                      goto LABEL_130;
                    }
                    v169 = 32;
                  }
                  v124 = v170;
                  v125 = itowa(v157, v170, v158, v175 == 88);
                  v161 = (int)v125;
                  if ( v164 && v166 )
                    v161 = (int)group_number_0(v125, v124, (char *)v166, v162);
                  if ( v159 && v158 == 10 )
                  {
                    v139 = v170;
                    v161 = (int)i18n_number_rewrite_1((_BYTE *)v161, (int)v170, (int)v170);
                    v52 = (int)&v139[-v161];
                    v164 = (int)&v139[-v161] >> 2;
                  }
                  else
                  {
                    v52 = (int)&v170[-v161];
                    v164 = (int)&v170[-v161] >> 2;
                  }
                  goto LABEL_306;
                }
                if ( v172 )
                {
                  v126 = *(unsigned __int8 *)a4;
                  v168 = 0;
                  v167 = 0;
                  v172 = 0;
                  LODWORD(v157) = v126;
                  v51 = v126;
                  a4 = (long double *)((char *)a4 + 4);
                }
                else
                {
                  if ( v161 )
                    v70 = *(unsigned __int16 *)a4;
                  else
                    v70 = *(_DWORD *)a4;
                  LODWORD(v157) = v70;
                  v51 = v70;
                  v168 = 0;
                  v167 = 0;
                  a4 = (long double *)((char *)a4 + 4);
                }
LABEL_124:
                if ( v174 < 0 )
                {
                  v174 = 1;
LABEL_269:
                  v105 = (int *)&itowa_upper_digits;
                  if ( v175 != 88 )
                    v105 = itowa_lower_digits;
                  v106 = v105;
                  if ( v158 == 10 )
                  {
                    v121 = v170;
                    do
                    {
                      v121 -= 4;
                      v122 = v106[v51 % 0xA];
                      v51 /= 0xAu;
                      *(_DWORD *)v121 = v122;
                    }
                    while ( v51 );
                    v161 = (int)v121;
                    if ( v164 && v166 )
                      goto LABEL_308;
                  }
                  else
                  {
                    if ( v158 == 16 )
                    {
                      v119 = v105;
                      v109 = v181;
                      v110 = v170;
                      do
                      {
                        v120 = v51;
                        v51 >>= 4;
                        v110 -= 4;
                        *(_DWORD *)v110 = v119[v120 & 0xF];
                      }
                      while ( v51 );
                    }
                    else
                    {
                      v108 = v105;
                      v109 = v181;
                      v110 = v170;
                      do
                      {
                        v111 = v51;
                        v51 >>= 3;
                        v110 -= 4;
                        *(_DWORD *)v110 = v108[v111 & 7];
                      }
                      while ( v51 );
                    }
                    v161 = (int)v110;
                    v181 = v109;
                    if ( !v164 || !v166 )
                    {
LABEL_282:
                      v52 = (int)&v170[-v161];
                      v164 = (int)&v170[-v161] >> 2;
                      goto LABEL_130;
                    }
LABEL_308:
                    v161 = (int)group_number_0((_BYTE *)v161, v170, (char *)v166, v162);
                  }
                  if ( v159 && v158 == 10 )
                  {
                    v107 = v170;
                    v161 = (int)i18n_number_rewrite_1((_BYTE *)v161, (int)v170, (int)v170);
                    v158 = 10;
                    v52 = (int)&v107[-v161];
                    v164 = (int)&v107[-v161] >> 2;
                    goto LABEL_130;
                  }
                  goto LABEL_282;
                }
                if ( v174 || v51 )
                {
                  v169 = 32;
                  goto LABEL_269;
                }
                if ( v158 == 8 && v165 )
                {
                  v52 = 4;
                  v164 = 1;
                  v169 = 32;
                  v158 = 8;
                  v53 = v170 - 4;
                  *(_DWORD *)v53 = 48;
                  v161 = (int)v53;
                }
                else
                {
                  v164 = 0;
                  v52 = 0;
                  v169 = 32;
                  v161 = (int)v170;
                }
LABEL_130:
                if ( v174 > v164 )
                {
                  v104 = v174 - (v52 >> 2);
                  if ( v104 < 0 )
                    v104 = 0;
                  v174 = v104;
                  if ( v171 )
                  {
LABEL_232:
                    if ( v172 )
                    {
                      v92 = *(_DWORD *)(a2 + 88);
                      if ( v92 )
                      {
                        v93 = *(_DWORD **)(v92 + 16);
                        if ( (unsigned int)v93 < *(_DWORD *)(v92 + 20) )
                        {
                          *(_DWORD *)(v92 + 16) = v93 + 1;
                          *v93 = 45;
                          goto LABEL_236;
                        }
                      }
                      v172 = v52;
                      v142 = _woverflow((_DWORD *)a2, 45);
LABEL_388:
                      v52 = v172;
                      if ( v142 == -1 )
                        goto LABEL_111;
                      goto LABEL_236;
                    }
                    if ( v168 )
                    {
                      v112 = *(_DWORD *)(a2 + 88);
                      if ( !v112 || (v113 = *(_DWORD **)(v112 + 16), (unsigned int)v113 >= *(_DWORD *)(v112 + 20)) )
                      {
                        v172 = v52;
                        v142 = _woverflow((_DWORD *)a2, 43);
                        goto LABEL_388;
                      }
                      *(_DWORD *)(v112 + 16) = v113 + 1;
                      *v113 = 43;
LABEL_236:
                      if ( v181 == 0x7FFFFFFF )
                        goto LABEL_111;
                      --v173;
                      ++v181;
                    }
                    else if ( v167 )
                    {
                      v127 = *(_DWORD *)(a2 + 88);
                      if ( !v127 || (v128 = *(_DWORD **)(v127 + 16), (unsigned int)v128 >= *(_DWORD *)(v127 + 20)) )
                      {
                        v172 = v52;
                        v142 = _woverflow((_DWORD *)a2, 32);
                        goto LABEL_388;
                      }
                      *(_DWORD *)(v127 + 16) = v128 + 1;
                      *v128 = 32;
                      goto LABEL_236;
                    }
                    if ( (_DWORD)v157 && v165 && v158 == 16 )
                    {
                      v94 = *(_DWORD *)(a2 + 88);
                      if ( v94
                        && (v95 = *(_DWORD **)(v94 + 16), v96 = *(_DWORD *)(v94 + 20),
                                                          v97 = v95,
                                                          (unsigned int)v95 < v96) )
                      {
                        v9 = v181 == 0x7FFFFFFF;
                        v98 = v95 + 1;
                        *(_DWORD *)(v94 + 16) = v98;
                        *v97 = 48;
                        if ( v9 )
                          goto LABEL_111;
LABEL_244:
                        if ( v96 > (unsigned int)v98 )
                        {
                          *(_DWORD *)(v94 + 16) = v98 + 1;
                          v9 = v175 == -1;
                          *v98 = v175;
                          if ( v9 )
                            goto LABEL_111;
                          goto LABEL_246;
                        }
                      }
                      else
                      {
                        v172 = v52;
                        v147 = _woverflow((_DWORD *)a2, 48);
                        v52 = v172;
                        if ( v147 == -1 || v181 == 0x7FFFFFFF )
                          goto LABEL_111;
                        v94 = *(_DWORD *)(a2 + 88);
                        if ( v94 )
                        {
                          v98 = *(unsigned int **)(v94 + 16);
                          v96 = *(_DWORD *)(v94 + 20);
                          goto LABEL_244;
                        }
                      }
                      v172 = v52;
                      v148 = _woverflow((_DWORD *)a2, v175);
                      v52 = v172;
                      if ( v148 == -1 )
                        goto LABEL_111;
LABEL_246:
                      if ( v181 == 2147483646 )
                        goto LABEL_111;
                      v181 += 2;
                      v173 -= 2;
                    }
                    v99 = v52 >> 2;
                    v100 = v174;
                    v175 = v173 - (v99 + v174);
                    if ( v174 )
                    {
                      v173 = v99;
                      if ( v100 != IO_wpadn(a2, 48, v174) )
                        goto LABEL_111;
                      if ( (unsigned int)v181 > 0x7FFFFFFE )
                        goto LABEL_431;
                      v99 = v173;
                      if ( v100 > 0x7FFFFFFF - v181 )
                        goto LABEL_284;
                      v181 += v174;
                    }
                    if ( v181 < 0 )
LABEL_429:
                      _assert_fail("(size_t) done <= (size_t) INT_MAX", "vfprintf.c", 1636, "_IO_vfwprintf");
                    v101 = *(_DWORD *)(a2 + 148);
                    if ( v177 <= v101 - (int)&_start___libc_IO_vtables )
                    {
                      v173 = v99;
                      v174 = v101;
                      IO_vtable_check(v99);
                      v99 = v173;
                      v101 = v174;
                    }
                    v174 = v99;
                    v102 = (*(int (__cdecl **)(int, int, int))(v101 + 28))(a2, v161, v99);
                    if ( v174 != v102 )
                      goto LABEL_111;
                    if ( v174 > 0x7FFFFFFF - v181 )
                      goto LABEL_284;
                    v103 = v175;
                    v181 += v174;
                    if ( (int)v175 > 0 )
                    {
                      if ( v103 != IO_wpadn(a2, 32, v175) )
                        goto LABEL_111;
                      if ( (unsigned int)v181 > 0x7FFFFFFE )
                        goto LABEL_431;
                      if ( v103 > 0x7FFFFFFF - v181 )
                        goto LABEL_284;
                      v181 += v175;
                    }
                    goto LABEL_58;
                  }
                  v58 = v173 - (v164 + v104);
                  if ( (_DWORD)v157 )
                  {
                    v54 = v165;
LABEL_139:
                    if ( v158 == 16 && v54 )
                      v58 -= 2;
                  }
                }
                else
                {
                  if ( (_DWORD)v157 )
                  {
                    v54 = v165;
                    if ( v158 == 8 && (_BYTE)v165 )
                    {
                      v55 = v170;
                      v56 = (_BYTE *)(v161 - 4);
                      *(_DWORD *)v56 = 48;
                      v52 = v55 - v56;
                      v161 = (int)v56;
                    }
                    v57 = 0;
                    if ( v174 - (v52 >> 2) >= 0 )
                      v57 = v174 - (v52 >> 2);
                    v174 = v57;
                    if ( v171 )
                      goto LABEL_232;
                    v164 = v52 >> 2;
                    v58 = v173 - ((v52 >> 2) + v174);
                    goto LABEL_139;
                  }
                  v114 = v174 - (v52 >> 2);
                  if ( v114 < 0 )
                    v114 = v157;
                  v174 = v114;
                  if ( v171 )
                    goto LABEL_232;
                  v58 = v173 - (v174 + v164);
                }
                v59 = ((v168 | v167 | v172) == 0) + v58 - 1;
                if ( v169 == 32 )
                {
                  if ( v59 <= 0 )
                  {
                    v59 = 0;
                  }
                  else
                  {
                    v173 = v59;
                    v123 = IO_wpadn(a2, 32, v59);
                    if ( v173 != v123 )
                      goto LABEL_111;
                    if ( (unsigned int)v181 > 0x7FFFFFFE )
LABEL_431:
                      _assert_fail("(unsigned int) done < (unsigned int) INT_MAX", "vfprintf.c", 1636, "_IO_vfwprintf");
                    if ( v173 > (unsigned int)(0x7FFFFFFF - v181) )
                      goto LABEL_284;
                    v181 += v173;
                    v59 = 0;
                  }
                }
                if ( v172 )
                {
                  v60 = *(_DWORD *)(a2 + 88);
                  if ( v60 )
                  {
                    v61 = *(_DWORD **)(v60 + 16);
                    if ( (unsigned int)v61 < *(_DWORD *)(v60 + 20) )
                    {
                      *(_DWORD *)(v60 + 16) = v61 + 1;
                      *v61 = 45;
                      goto LABEL_147;
                    }
                  }
                  v173 = v59;
                  v141 = _woverflow((_DWORD *)a2, 45);
                }
                else if ( v168 )
                {
                  v115 = *(_DWORD *)(a2 + 88);
                  if ( v115 )
                  {
                    v116 = *(_DWORD **)(v115 + 16);
                    if ( (unsigned int)v116 < *(_DWORD *)(v115 + 20) )
                    {
                      *(_DWORD *)(v115 + 16) = v116 + 1;
                      *v116 = 43;
                      goto LABEL_147;
                    }
                  }
                  v173 = v59;
                  v141 = _woverflow((_DWORD *)a2, 43);
                }
                else
                {
                  if ( !v167 )
                    goto LABEL_149;
                  v129 = *(_DWORD *)(a2 + 88);
                  if ( v129 )
                  {
                    v130 = *(_DWORD **)(v129 + 16);
                    if ( (unsigned int)v130 < *(_DWORD *)(v129 + 20) )
                    {
                      *(_DWORD *)(v129 + 16) = v130 + 1;
                      *v130 = 32;
                      goto LABEL_147;
                    }
                  }
                  v173 = v59;
                  v141 = _woverflow((_DWORD *)a2, 32);
                }
                v59 = v173;
                if ( v141 == -1 )
                  goto LABEL_111;
LABEL_147:
                if ( v181 == 0x7FFFFFFF )
                  goto LABEL_111;
                ++v181;
LABEL_149:
                if ( !(_DWORD)v157 || !v165 || v158 != 16 )
                  goto LABEL_159;
                v62 = *(_DWORD *)(a2 + 88);
                if ( v62
                  && (v63 = *(_DWORD **)(v62 + 16), v64 = *(_DWORD *)(v62 + 20), v65 = v63, (unsigned int)v63 < v64) )
                {
                  v9 = v181 == 0x7FFFFFFF;
                  v66 = v63 + 1;
                  *(_DWORD *)(v62 + 16) = v66;
                  *v65 = 48;
                  if ( v9 )
                    goto LABEL_111;
                }
                else
                {
                  v173 = v59;
                  v150 = _woverflow((_DWORD *)a2, 48);
                  v59 = v173;
                  if ( v150 == -1 || v181 == 0x7FFFFFFF )
                    goto LABEL_111;
                  v62 = *(_DWORD *)(a2 + 88);
                  if ( !v62 )
                    goto LABEL_409;
                  v66 = *(unsigned int **)(v62 + 16);
                  v64 = *(_DWORD *)(v62 + 20);
                }
                if ( (unsigned int)v66 < v64 )
                {
                  *(_DWORD *)(v62 + 16) = v66 + 1;
                  v9 = v175 == -1;
                  *v66 = v175;
                  if ( v9 )
                    goto LABEL_111;
                  goto LABEL_157;
                }
LABEL_409:
                v173 = v59;
                v149 = _woverflow((_DWORD *)a2, v175);
                v59 = v173;
                if ( v149 == -1 )
                  goto LABEL_111;
LABEL_157:
                if ( v181 == 2147483646 )
                  goto LABEL_111;
                v181 += 2;
LABEL_159:
                if ( v59 + v174 > 0 )
                {
                  v175 = v59 + v174;
                  v67 = IO_wpadn(a2, 48, v59 + v174);
                  if ( v175 != v67 )
                    goto LABEL_111;
                  if ( (unsigned int)v181 > 0x7FFFFFFE )
                    goto LABEL_431;
                  if ( v175 > 0x7FFFFFFF - v181 )
                    goto LABEL_284;
                  v181 += v175;
                }
                if ( v181 < 0 )
                  goto LABEL_429;
                v68 = *(_DWORD *)(a2 + 148);
                if ( v177 <= v68 - (unsigned int)&_start___libc_IO_vtables )
                {
                  v175 = *(_DWORD *)(a2 + 148);
                  IO_vtable_check(v59);
                  v68 = v175;
                }
                v69 = v164;
                if ( v69 != (*(int (__cdecl **)(int, int, int))(v68 + 28))(a2, v161, v164) )
                  goto LABEL_111;
                if ( v69 > 0x7FFFFFFF - v181 )
                  goto LABEL_284;
                v181 += v164;
LABEL_58:
                ++v163;
                if ( v176 )
                  free(v176);
                v26 = ++v182;
                v27 = wcschrnul(v182, 37);
                v182 = v27;
                if ( v181 < 0 )
                  _assert_fail("(size_t) done <= (size_t) INT_MAX", "vfprintf.c", 1668, "_IO_vfwprintf");
                v28 = *(_DWORD *)(a2 + 148);
                if ( v177 <= v28 - (unsigned int)&_start___libc_IO_vtables )
                {
                  v176 = *(_DWORD *)(a2 + 148);
                  IO_vtable_check(v28);
                  v27 = v182;
                  v28 = v176;
                }
                v29 = (*(int (__cdecl **)(int, int *, int))(v28 + 28))(a2, v26, v27 - v26);
                v13 = v182;
                if ( v29 != v182 - v26 )
                  goto LABEL_20;
                if ( v29 > 0x7FFFFFFF - v181 )
                  goto LABEL_297;
                v30 = v29 + v181;
                v31 = *v182;
                v181 = v30;
                if ( !v31 )
                  goto LABEL_21;
                continue;
              default:
                goto LABEL_37;
            }
            break;
          }
        }
        v181 = printf_positional_0(
                 (_DWORD *)a2,
                 (unsigned int)a3,
                 v160,
                 a1,
                 (int)a4,
                 &v183,
                 v181,
                 v5,
                 v178,
                 v193,
                 v179,
                 (char *)v166,
                 v162);
        goto LABEL_21;
      }
    }
  }
  v181 = -1;
  return -1;
}
// 8089973: conditional instruction was optimized away because %var_1058.4==8
// 808A35D: variable 'v59' is possibly undefined
// 808A47E: variable 'v155' is possibly undefined
// 80481C0: using guessed type int __cdecl j_strnlen(_DWORD, _DWORD);
// 80481F0: using guessed type int __cdecl j_wcslen(_DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80515F0: using guessed type void __noreturn _libc_fatal(const char *, ...);
// 8051620: using guessed type int __fastcall IO_vtable_check(_DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80D4220: using guessed type int itowa_lower_digits[36];
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 80ECD34: using guessed type int _printf_function_table;
// 80ECD38: using guessed type int _printf_modifier_table;
// 80ECD98: using guessed type int _printf_va_arg_table;
// 8088250: using guessed type long double var_FE8;

//----- (0808A7C0) --------------------------------------------------------
int __usercall buffered_vfprintf_0@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v6; // edi
  int v7; // edx
  int v8; // esi
  int v9; // ecx
  _DWORD *v11; // edx
  unsigned int v13; // esi
  bool v15; // zf
  int v16; // [esp+14h] [ebp-8190h]
  int v17[22]; // [esp+2Ch] [ebp-8178h] BYREF
  char *v18; // [esp+84h] [ebp-8120h]
  int v19; // [esp+94h] [ebp-8110h]
  void *v20; // [esp+C0h] [ebp-80E4h]
  char v21; // [esp+C4h] [ebp-80E0h] BYREF
  char *v22; // [esp+D0h] [ebp-80D4h]
  char *v23; // [esp+D4h] [ebp-80D0h]
  char *v24; // [esp+D8h] [ebp-80CCh]
  _DWORD *v25; // [esp+178h] [ebp-802Ch]
  char v26[32768]; // [esp+188h] [ebp-801Ch] BYREF
  char v27; // [esp+8188h] [ebp-1Ch] BYREF

  if ( IO_fwide(a1, 1) != 1 )
    return -1;
  v25 = a1;
  v19 = 1;
  v17[0] = -72515580;
  v18 = &v21;
  v17[18] = 0;
  v20 = &IO_helper_jumps_0;
  v23 = v26;
  v22 = v26;
  v24 = &v27;
  v17[15] = a1[15];
  v6 = vfwprintf(v17, a2, a3);
  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v13 = __readgsdword(8u);
    if ( v13 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v15 = __readgsdword(0xCu) == 0;
      if ( !v15 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v15 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v13;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v7 = *((_DWORD *)v18 + 3);
  v8 = (*((_DWORD *)v18 + 4) - v7) >> 2;
  if ( v8 > 0 )
  {
    v9 = a1[37];
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v9
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
    {
      v16 = a1[37];
      IO_vtable_check(v9);
      v9 = v16;
      v7 = *((_DWORD *)v18 + 3);
    }
    if ( v8 != (*(int (__cdecl **)(_DWORD *, int, int))(v9 + 28))(a1, v7, v8) )
      v6 = -1;
  }
  if ( (*a1 & 0x8000) == 0 )
  {
    v11 = (_DWORD *)a1[18];
    v15 = v11[1]-- == 1;
    if ( v15 )
    {
      v11[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v15 = (*v11)-- == 1;
      if ( !v15 )
        _lll_unlock_wake_private(v11);
    }
  }
  return v6;
}
// 8051620: using guessed type int __fastcall IO_vtable_check(_DWORD);
// 8088250: using guessed type _DWORD __cdecl vfwprintf(_DWORD, _DWORD, _DWORD);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0808A9D0) --------------------------------------------------------
int __cdecl funlockfile(int a1)
{
  int result; // eax
  _DWORD *v2; // edx
  bool v3; // zf

  result = a1;
  v2 = *(_DWORD **)(a1 + 72);
  v3 = v2[1]-- == 1;
  if ( v3 )
  {
    v2[2] = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v3 = (*v2)-- == 1;
    if ( !v3 )
      return _lll_unlock_wake_private(v2);
  }
  return result;
}

//----- (0808AA00) --------------------------------------------------------
int __usercall read_int_1@<eax>(_DWORD *a1@<eax>)
{
  unsigned __int8 *v1; // ebx
  int v2; // ecx
  int v3; // ebp
  unsigned int v4; // edx

  v1 = (unsigned __int8 *)(*a1 + 1);
  v2 = *(unsigned __int8 *)*a1 - 48;
  while ( 1 )
  {
    *a1 = v1;
    v4 = *v1 - 48;
    if ( v4 > 9 )
      break;
    if ( v2 >= 0 )
    {
      if ( v2 <= 214748364 )
      {
        v3 = 10 * v2;
        v2 = 10 * v2 + v4;
        if ( v3 > (int)(0x7FFFFFFF - v4) )
          v2 = -1;
      }
      else
      {
        v2 = -1;
      }
    }
    ++v1;
  }
  return v2;
}

//----- (0808AA60) --------------------------------------------------------
int __cdecl _parse_one_specmb(unsigned __int8 *a1, int a2, int a3, unsigned int *a4)
{
  unsigned __int8 *v4; // edi
  int v5; // ebx
  unsigned __int8 *v6; // esi
  int v7; // eax
  int v8; // eax
  int v9; // edi
  int v10; // eax
  unsigned __int8 *v11; // edx
  unsigned __int8 *v12; // eax
  int v13; // eax
  int v14; // edx
  unsigned int v15; // eax
  unsigned __int8 *v16; // edx
  int v17; // eax
  int v18; // eax
  int v19; // eax
  unsigned int *v20; // eax
  int v22; // edx
  char v23; // dl
  unsigned __int8 *v24; // eax
  int v25; // edx
  unsigned int v26; // eax
  unsigned __int8 *v27; // edx
  int v28; // eax
  int v29; // eax
  int (__cdecl *v30)(int, int, int, int); // edx
  int v31; // eax
  unsigned int v32; // eax
  unsigned __int8 *v33; // edx

  v4 = a1;
  v5 = a3;
  v6 = a1 + 1;
  *(_BYTE *)(a3 + 12) &= 7u;
  *(_DWORD *)(v5 + 36) = -1;
  *(_DWORD *)(v5 + 16) = 32;
  a1 = v6;
  *(_BYTE *)(v5 + 13) &= 0xF2u;
  v7 = *v6;
  if ( (unsigned int)(v7 - 48) <= 9 )
  {
    v15 = read_int_1(&a1);
    if ( v15 && (v16 = a1, *a1 == 36) )
    {
      v6 = ++a1;
      if ( v15 != -1 )
      {
        *(_DWORD *)(v5 + 36) = v15 - 1;
        if ( *a4 >= v15 )
          v15 = *a4;
        *a4 = v15;
      }
      LOBYTE(v7) = v16[1];
    }
    else
    {
      a1 = v6;
      LOBYTE(v7) = v4[1];
    }
  }
  while ( 2 )
  {
    switch ( (char)v7 )
    {
      case ' ':
        *(_BYTE *)(v5 + 12) |= 0x10u;
        goto LABEL_4;
      case '#':
        *(_BYTE *)(v5 + 12) |= 8u;
        goto LABEL_4;
      case '\'':
        *(_BYTE *)(v5 + 12) |= 0x80u;
        goto LABEL_4;
      case '+':
        *(_BYTE *)(v5 + 12) |= 0x40u;
        goto LABEL_4;
      case '-':
        *(_BYTE *)(v5 + 12) |= 0x20u;
        goto LABEL_4;
      case '0':
        *(_DWORD *)(v5 + 16) = 48;
        goto LABEL_4;
      case 'I':
        *(_BYTE *)(v5 + 13) |= 8u;
LABEL_4:
        a1 = ++v6;
        LOBYTE(v7) = *v6;
        if ( !*v6 )
          goto LABEL_5;
        continue;
      default:
LABEL_5:
        if ( (*(_BYTE *)(v5 + 12) & 0x20) != 0 )
          *(_DWORD *)(v5 + 16) = 32;
        *(_DWORD *)(v5 + 32) = -1;
        *(_DWORD *)(v5 + 4) = 0;
        v8 = *v6;
        if ( (_BYTE)v8 == 42 )
        {
          a1 = v6 + 1;
          if ( (unsigned int)v6[1] - 48 > 9 )
            goto LABEL_28;
          v26 = read_int_1(&a1);
          if ( v26 )
          {
            v27 = a1;
            if ( *a1 == 36 )
            {
              if ( v26 != -1 )
              {
                *(_DWORD *)(v5 + 32) = v26 - 1;
                if ( *a4 >= v26 )
                  v26 = *a4;
                *a4 = v26;
              }
              a1 = v27 + 1;
            }
          }
          if ( *(int *)(v5 + 32) < 0 )
          {
LABEL_28:
            v18 = a2;
            a1 = ++v6;
            v9 = 1;
            *(_DWORD *)(v5 + 32) = a2;
            a2 = v18 + 1;
          }
          else
          {
            v6 = a1;
            v9 = 0;
          }
        }
        else
        {
          v9 = 0;
          if ( (unsigned int)(v8 - 48) <= 9 )
          {
            v19 = read_int_1(&a1);
            if ( v19 != -1 )
              *(_DWORD *)(v5 + 4) = v19;
            v6 = a1;
          }
        }
        *(_DWORD *)(v5 + 28) = -1;
        *(_DWORD *)v5 = -1;
        if ( *v6 != 46 )
          goto LABEL_10;
        a1 = v6 + 1;
        v17 = v6[1];
        if ( (_BYTE)v17 != 42 )
        {
          if ( (unsigned int)(v17 - 48) > 9 )
          {
            *(_DWORD *)v5 = 0;
            ++v6;
            goto LABEL_10;
          }
          v28 = read_int_1(&a1);
          if ( v28 != -1 )
            *(_DWORD *)v5 = v28;
          goto LABEL_68;
        }
        a1 = v6 + 2;
        if ( (unsigned int)v6[2] - 48 <= 9 )
        {
          v32 = read_int_1(&a1);
          if ( v32 )
          {
            v33 = a1;
            if ( *a1 == 36 )
            {
              if ( v32 != -1 )
              {
                *(_DWORD *)(v5 + 28) = v32 - 1;
                if ( *a4 >= v32 )
                  v32 = *a4;
                *a4 = v32;
              }
              a1 = v33 + 1;
            }
          }
          if ( *(int *)(v5 + 28) >= 0 )
          {
LABEL_68:
            v6 = a1;
            goto LABEL_10;
          }
        }
        v29 = a2;
        ++v9;
        a1 = v6 + 2;
        v6 += 2;
        *(_DWORD *)(v5 + 28) = a2;
        a2 = v29 + 1;
LABEL_10:
        *(_BYTE *)(v5 + 13) &= ~2u;
        *(_BYTE *)(v5 + 12) &= 0xF8u;
        v10 = _printf_modifier_table;
        *(_WORD *)(v5 + 14) = 0;
        if ( !v10 || !*(_DWORD *)(v10 + 4 * *v6) )
          goto LABEL_11;
        if ( _handle_registered_modifier_mb(&a1, v5) )
        {
          v6 = a1;
LABEL_11:
          v11 = v6 + 1;
          a1 = v6 + 1;
          switch ( *v6 )
          {
            case 'L':
            case 'q':
              goto LABEL_33;
            case 'Z':
            case 't':
            case 'z':
              *(_BYTE *)(v5 + 12) &= 0xFAu;
              v12 = v6 + 2;
              break;
            case 'h':
              if ( v6[1] == 104 )
              {
                v11 = v6 + 2;
                *(_BYTE *)(v5 + 13) |= 2u;
                v12 = v6 + 3;
              }
              else
              {
                *(_BYTE *)(v5 + 12) |= 2u;
                v12 = v6 + 2;
              }
              break;
            case 'j':
              *(_BYTE *)(v5 + 12) |= 5u;
              goto LABEL_35;
            case 'l':
              *(_BYTE *)(v5 + 12) |= 4u;
              if ( v6[1] == 108 )
              {
                v11 = v6 + 2;
LABEL_33:
                *(_BYTE *)(v5 + 12) |= 1u;
                v12 = v11 + 1;
              }
              else
              {
LABEL_35:
                v12 = v6 + 2;
              }
              break;
            default:
              v12 = v6 + 1;
              v11 = v6;
              break;
          }
        }
        else
        {
          v11 = a1;
          v12 = a1 + 1;
        }
        a1 = v12;
        v13 = *v11;
        v14 = _printf_function_table;
        *(_DWORD *)(v5 + 48) = -1;
        *(_DWORD *)(v5 + 8) = v13;
        if ( !v14 )
          goto LABEL_20;
        v30 = *(int (__cdecl **)(int, int, int, int))(_printf_arginfo_table + 4 * v13);
        if ( !v30 )
          goto LABEL_20;
        v31 = v30(v5, 1, v5 + 40, v5 + 48);
        v22 = v31;
        *(_DWORD *)(v5 + 44) = v31;
        if ( v31 < 0 )
        {
          v13 = *(_DWORD *)(v5 + 8);
LABEL_20:
          *(_DWORD *)(v5 + 44) = 1;
          switch ( v13 )
          {
            case 'A':
            case 'E':
            case 'F':
            case 'G':
            case 'a':
            case 'e':
            case 'f':
            case 'g':
              v25 = -((*(_BYTE *)(v5 + 12) & 1) == 0);
              LOBYTE(v25) = 0;
              *(_DWORD *)(v5 + 40) = v25 + 263;
              goto LABEL_50;
            case 'C':
              *(_DWORD *)(v5 + 40) = 2;
              goto LABEL_40;
            case 'S':
              *(_DWORD *)(v5 + 40) = 4;
              goto LABEL_40;
            case 'X':
            case 'd':
            case 'i':
            case 'o':
            case 'u':
            case 'x':
              v23 = *(_BYTE *)(v5 + 12);
              if ( (v23 & 1) != 0 )
              {
                *(_DWORD *)(v5 + 40) = 256;
              }
              else if ( (v23 & 4) != 0 )
              {
                *(_DWORD *)(v5 + 40) = 512;
              }
              else if ( (*(_BYTE *)(v5 + 12) & 2) != 0 )
              {
                *(_DWORD *)(v5 + 40) = 1024;
              }
              else
              {
                *(_DWORD *)(v5 + 40) = (*(_BYTE *)(v5 + 13) & 2) != 0;
              }
LABEL_50:
              if ( *(_DWORD *)(v5 + 36) != -1 )
                goto LABEL_51;
              goto LABEL_70;
            case 'c':
              *(_DWORD *)(v5 + 40) = 1;
              goto LABEL_40;
            case 'n':
              *(_DWORD *)(v5 + 40) = 2048;
              goto LABEL_43;
            case 'p':
              *(_DWORD *)(v5 + 40) = 5;
LABEL_43:
              if ( *(_DWORD *)(v5 + 36) != -1 )
                goto LABEL_41;
              v22 = 1;
              goto LABEL_45;
            case 's':
              *(_DWORD *)(v5 + 40) = 3;
LABEL_40:
              if ( *(_DWORD *)(v5 + 36) != -1 )
                goto LABEL_41;
LABEL_70:
              v22 = 1;
              goto LABEL_71;
            default:
              *(_DWORD *)(v5 + 44) = 0;
              goto LABEL_51;
          }
        }
        if ( *(_DWORD *)(v5 + 36) == -1 && v31 )
        {
LABEL_45:
          v13 = *(_DWORD *)(v5 + 8);
LABEL_71:
          v9 += v22;
          *(_DWORD *)(v5 + 36) = a2;
        }
        else
        {
          v13 = *(_DWORD *)(v5 + 8);
        }
LABEL_51:
        if ( v13 )
        {
LABEL_41:
          v20 = (unsigned int *)a1;
          *(_DWORD *)(v5 + 20) = a1;
          *(_DWORD *)(v5 + 24) = strchrnul(v20, 37);
          return v9;
        }
        else
        {
          v24 = a1 - 1;
          *(_DWORD *)(v5 + 24) = a1 - 1;
          *(_DWORD *)(v5 + 20) = v24;
          return v9;
        }
    }
  }
}
// 80ECD34: using guessed type int _printf_function_table;
// 80ECD38: using guessed type int _printf_modifier_table;
// 80ECD94: using guessed type int _printf_arginfo_table;

//----- (0808B030) --------------------------------------------------------
int __usercall read_int_2@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v1; // ecx
  int v2; // edx
  _DWORD *v3; // edi
  unsigned int v4; // ebx
  int v5; // edx
  _DWORD *v7; // ebx

  v1 = (_DWORD *)*a1;
  v2 = *(_DWORD *)*a1 - 48;
  while ( 1 )
  {
    v3 = v1 + 1;
    v4 = v1[1] - 48;
    if ( v4 > 9 )
      goto LABEL_9;
    if ( v2 < 0 )
      goto LABEL_7;
    if ( v2 <= 214748364 )
    {
      v5 = 10 * v2;
      if ( v5 <= (int)(0x7FFFFFFF - v4) )
      {
        v2 = v4 + v5;
        goto LABEL_7;
      }
    }
    v7 = v1 + 2;
    if ( (unsigned int)(v1[2] - 48) > 9 )
      break;
    v7 = v1 + 3;
    if ( (unsigned int)(v1[3] - 48) > 9 )
      break;
    v3 = v1 + 4;
    if ( (unsigned int)(v1[4] - 48) > 9 )
    {
      v2 = -1;
LABEL_9:
      *a1 = v3;
      return v2;
    }
    v3 = v1 + 5;
    v2 = -1;
    if ( (unsigned int)(v1[5] - 48) > 9 )
      goto LABEL_9;
LABEL_7:
    v1 = v3;
  }
  *a1 = v7;
  return -1;
}

//----- (0808B0D0) --------------------------------------------------------
int __cdecl _parse_one_specwc(_DWORD *a1, int a2, int a3, unsigned int *a4)
{
  _DWORD *v4; // edi
  int v5; // ebx
  _DWORD *v6; // esi
  int v7; // eax
  _DWORD *v8; // ecx
  char v9; // dl
  int v10; // edi
  int v11; // edx
  int v12; // eax
  _DWORD *v13; // edx
  int v14; // edx
  int (__cdecl *v15)(int, int, int, int); // edx
  int v16; // eax
  int v17; // edx
  unsigned int v18; // eax
  _DWORD *v19; // edx
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int *v24; // eax
  char v26; // dl
  _DWORD *v27; // eax
  int v28; // edx
  unsigned int v29; // eax
  _DWORD *v30; // edx
  int v31; // eax
  int v32; // eax
  int v33; // eax
  unsigned int *v34; // edi
  unsigned int v35; // eax
  _DWORD *v36; // edx

  v4 = a1;
  v5 = a3;
  v6 = a1 + 1;
  *(_BYTE *)(a3 + 12) &= 7u;
  *(_DWORD *)(v5 + 36) = -1;
  *(_DWORD *)(v5 + 16) = 32;
  a1 = v6;
  *(_BYTE *)(v5 + 13) = *(_BYTE *)(v5 + 13) & 0xF2 | 4;
  v7 = *v6;
  if ( (unsigned int)(*v6 - 48) <= 9 )
  {
    v18 = read_int_2(&a1);
    if ( v18 && (v19 = a1, *a1 == 36) )
    {
      v6 = ++a1;
      if ( v18 != -1 )
      {
        v34 = a4;
        *(_DWORD *)(v5 + 36) = v18 - 1;
        if ( *v34 >= v18 )
          v18 = *v34;
        *v34 = v18;
      }
      v7 = v19[1];
    }
    else
    {
      a1 = v6;
      v7 = v4[1];
    }
  }
  v8 = a1;
  v9 = 0;
  while ( 2 )
  {
    switch ( v7 )
    {
      case ' ':
        *(_BYTE *)(v5 + 12) |= 0x10u;
        goto LABEL_5;
      case '#':
        *(_BYTE *)(v5 + 12) |= 8u;
        goto LABEL_5;
      case '\'':
        *(_BYTE *)(v5 + 12) |= 0x80u;
        goto LABEL_5;
      case '+':
        *(_BYTE *)(v5 + 12) |= 0x40u;
        goto LABEL_5;
      case '-':
        *(_BYTE *)(v5 + 12) |= 0x20u;
        goto LABEL_5;
      case '0':
        *(_DWORD *)(v5 + 16) = 48;
        goto LABEL_5;
      case 'I':
        *(_BYTE *)(v5 + 13) |= 8u;
LABEL_5:
        v7 = *++v6;
        v9 = 1;
        v8 = v6;
        if ( *v6 )
          continue;
        a1 = v6;
LABEL_15:
        if ( (*(_BYTE *)(v5 + 12) & 0x20) != 0 )
          *(_DWORD *)(v5 + 16) = 32;
        *(_DWORD *)(v5 + 32) = -1;
        *(_DWORD *)(v5 + 4) = 0;
        if ( *v6 == 42 )
        {
          v21 = v6[1];
          a1 = v6 + 1;
          if ( (unsigned int)(v21 - 48) > 9 )
            goto LABEL_41;
          v29 = read_int_2(&a1);
          if ( v29 )
          {
            v30 = a1;
            if ( *a1 == 36 )
            {
              if ( v29 != -1 )
              {
                *(_DWORD *)(v5 + 32) = v29 - 1;
                if ( *a4 >= v29 )
                  v29 = *a4;
                *a4 = v29;
              }
              a1 = v30 + 1;
            }
          }
          if ( *(int *)(v5 + 32) < 0 )
          {
LABEL_41:
            v22 = a2;
            a1 = ++v6;
            v10 = 1;
            *(_DWORD *)(v5 + 32) = a2;
            a2 = v22 + 1;
          }
          else
          {
            v6 = a1;
            v10 = 0;
          }
        }
        else
        {
          v10 = 0;
          if ( (unsigned int)(*v6 - 48) <= 9 )
          {
            v23 = read_int_2(&a1);
            if ( v23 != -1 )
              *(_DWORD *)(v5 + 4) = v23;
            v6 = a1;
          }
        }
        *(_DWORD *)(v5 + 28) = -1;
        *(_DWORD *)v5 = -1;
        if ( *v6 != 46 )
          goto LABEL_20;
        v20 = v6[1];
        a1 = v6 + 1;
        if ( v20 != 42 )
        {
          if ( (unsigned int)(v20 - 48) > 9 )
          {
            *(_DWORD *)v5 = 0;
            ++v6;
            goto LABEL_20;
          }
          v31 = read_int_2(&a1);
          if ( v31 != -1 )
            *(_DWORD *)v5 = v31;
          goto LABEL_76;
        }
        v32 = v6[2];
        a1 = v6 + 2;
        if ( (unsigned int)(v32 - 48) <= 9 )
        {
          v35 = read_int_2(&a1);
          if ( v35 )
          {
            v36 = a1;
            if ( *a1 == 36 )
            {
              if ( v35 != -1 )
              {
                *(_DWORD *)(v5 + 28) = v35 - 1;
                if ( *a4 >= v35 )
                  v35 = *a4;
                *a4 = v35;
              }
              a1 = v36 + 1;
            }
          }
          if ( *(int *)(v5 + 28) >= 0 )
          {
LABEL_76:
            v6 = a1;
            goto LABEL_20;
          }
        }
        v33 = a2;
        ++v10;
        a1 = v6 + 2;
        v6 += 2;
        *(_DWORD *)(v5 + 28) = a2;
        a2 = v33 + 1;
LABEL_20:
        *(_BYTE *)(v5 + 13) &= ~2u;
        *(_BYTE *)(v5 + 12) &= 0xF8u;
        v11 = _printf_modifier_table;
        *(_WORD *)(v5 + 14) = 0;
        v12 = *v6;
        if ( !v11 || !*(_DWORD *)(v11 + 4 * v12) )
          goto LABEL_21;
        if ( _handle_registered_modifier_wc(&a1, v5) )
        {
          v6 = a1;
          v12 = *a1;
LABEL_21:
          v13 = v6 + 1;
          a1 = v6 + 1;
          switch ( v12 )
          {
            case 'L':
            case 'q':
              goto LABEL_46;
            case 'Z':
            case 't':
            case 'z':
              *(_BYTE *)(v5 + 12) &= 0xFAu;
              v13 = v6 + 2;
              v12 = v6[1];
              break;
            case 'h':
              if ( v6[1] == 104 )
              {
                *(_BYTE *)(v5 + 13) |= 2u;
                v13 = v6 + 3;
                v12 = v6[2];
              }
              else
              {
                *(_BYTE *)(v5 + 12) |= 2u;
                v13 = v6 + 2;
                v12 = v6[1];
              }
              break;
            case 'j':
              *(_BYTE *)(v5 + 12) |= 5u;
              v13 = v6 + 2;
              v12 = v6[1];
              break;
            case 'l':
              *(_BYTE *)(v5 + 12) |= 4u;
              v13 = v6 + 2;
              v12 = v6[1];
              if ( v12 == 108 )
              {
LABEL_46:
                *(_BYTE *)(v5 + 12) |= 1u;
                v12 = *v13++;
              }
              break;
            default:
              break;
          }
        }
        else
        {
          v13 = a1 + 1;
          v12 = *a1;
        }
        a1 = v13;
        v14 = _printf_function_table;
        *(_DWORD *)(v5 + 8) = v12;
        *(_DWORD *)(v5 + 48) = -1;
        if ( !v14 )
          goto LABEL_32;
        if ( v12 > 255 )
          goto LABEL_32;
        v15 = *(int (__cdecl **)(int, int, int, int))(_printf_arginfo_table + 4 * v12);
        if ( !v15 )
          goto LABEL_32;
        v16 = v15(v5, 1, v5 + 40, v5 + 48);
        v17 = v16;
        *(_DWORD *)(v5 + 44) = v16;
        if ( v16 < 0 )
        {
          v12 = *(_DWORD *)(v5 + 8);
LABEL_32:
          *(_DWORD *)(v5 + 44) = 1;
          switch ( v12 )
          {
            case 'A':
            case 'E':
            case 'F':
            case 'G':
            case 'a':
            case 'e':
            case 'f':
            case 'g':
              v28 = -((*(_BYTE *)(v5 + 12) & 1) == 0);
              LOBYTE(v28) = 0;
              *(_DWORD *)(v5 + 40) = v28 + 263;
              goto LABEL_53;
            case 'C':
              *(_DWORD *)(v5 + 40) = 2;
              goto LABEL_49;
            case 'S':
              *(_DWORD *)(v5 + 40) = 4;
              goto LABEL_49;
            case 'X':
            case 'd':
            case 'i':
            case 'o':
            case 'u':
            case 'x':
              v26 = *(_BYTE *)(v5 + 12);
              if ( (v26 & 1) != 0 )
              {
                *(_DWORD *)(v5 + 40) = 256;
              }
              else if ( (v26 & 4) != 0 )
              {
                *(_DWORD *)(v5 + 40) = 512;
              }
              else if ( (*(_BYTE *)(v5 + 12) & 2) != 0 )
              {
                *(_DWORD *)(v5 + 40) = 1024;
              }
              else
              {
                *(_DWORD *)(v5 + 40) = (*(_BYTE *)(v5 + 13) & 2) != 0;
              }
LABEL_53:
              if ( *(_DWORD *)(v5 + 36) != -1 )
                goto LABEL_54;
              goto LABEL_78;
            case 'c':
              *(_DWORD *)(v5 + 40) = 1;
              goto LABEL_49;
            case 'n':
              *(_DWORD *)(v5 + 40) = 2048;
              goto LABEL_57;
            case 'p':
              *(_DWORD *)(v5 + 40) = 5;
LABEL_57:
              if ( *(_DWORD *)(v5 + 36) != -1 )
                goto LABEL_50;
              v17 = 1;
              goto LABEL_59;
            case 's':
              *(_DWORD *)(v5 + 40) = 3;
LABEL_49:
              if ( *(_DWORD *)(v5 + 36) != -1 )
                goto LABEL_50;
LABEL_78:
              v17 = 1;
              goto LABEL_79;
            default:
              *(_DWORD *)(v5 + 44) = 0;
              goto LABEL_54;
          }
        }
        if ( *(_DWORD *)(v5 + 36) == -1 && v16 )
        {
LABEL_59:
          v12 = *(_DWORD *)(v5 + 8);
LABEL_79:
          v10 += v17;
          *(_DWORD *)(v5 + 36) = a2;
        }
        else
        {
          v12 = *(_DWORD *)(v5 + 8);
        }
LABEL_54:
        if ( v12 )
        {
LABEL_50:
          v24 = a1;
          *(_DWORD *)(v5 + 20) = a1;
          *(_DWORD *)(v5 + 24) = wcschrnul(v24, 37);
          return v10;
        }
        else
        {
          v27 = a1 - 1;
          *(_DWORD *)(v5 + 24) = a1 - 1;
          *(_DWORD *)(v5 + 20) = v27;
          return v10;
        }
      default:
        if ( v9 )
          a1 = v8;
        goto LABEL_15;
    }
  }
}
// 80ECD34: using guessed type int _printf_function_table;
// 80ECD38: using guessed type int _printf_modifier_table;
// 80ECD94: using guessed type int _printf_arginfo_table;

//----- (0808B6B0) --------------------------------------------------------
int __usercall IO_file_doallocate@<eax>(long double a1@<st0>, unsigned int *a2)
{
  unsigned int v2; // ebx
  signed int v3; // ebx
  int v4; // eax
  unsigned int v6; // edi
  _BOOL4 v7; // eax
  char v8[16]; // [esp+0h] [ebp-6Ch] BYREF
  int v9; // [esp+10h] [ebp-5Ch]
  unsigned int v10; // [esp+20h] [ebp-4Ch]
  int v11; // [esp+24h] [ebp-48h]
  int v12; // [esp+34h] [ebp-38h]

  if ( (a2[14] & 0x80000000) != 0 )
    goto LABEL_9;
  v2 = a2[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= v2 - (unsigned int)&_start___libc_IO_vtables )
    IO_vtable_check(a1);
  if ( (*(int (__cdecl **)(unsigned int *, char *))(v2 + 72))(a2, v8) < 0 )
    goto LABEL_9;
  if ( (v9 & 0xF000) != 0x2000
    || ((v10 >> 8) & 0xFFF | v11 & 0xFFFFF000) - 136 > 7
    && (v6 = __readgsdword(0xFFFFFFE8), v7 = isatty(a2[14]), __writegsdword(0xFFFFFFE8, v6), !v7) )
  {
    v3 = v12;
    if ( v12 > 0 )
      goto LABEL_7;
LABEL_9:
    v3 = 0x2000;
    v4 = malloc(a1, 0x2000u);
    if ( v4 )
      goto LABEL_8;
    return -1;
  }
  v3 = v12;
  *a2 |= 0x200u;
  if ( v3 <= 0 )
    goto LABEL_9;
LABEL_7:
  v4 = malloc(a1, v3);
  if ( v4 )
  {
LABEL_8:
    IO_setb(a2, v4, v4 + v3, 1);
    return 1;
  }
  return -1;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();
// 808B6B0: using guessed type char var_6C[16];

//----- (0808B7E0) --------------------------------------------------------
int __usercall fputs@<eax>(long double a1@<st0>, _BYTE *a2, _DWORD *a3)
{
  int v3; // edi
  bool v6; // zf
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  _DWORD *v10; // edx
  unsigned int v12; // [esp+18h] [ebp-1Ch]
  int v13; // [esp+18h] [ebp-1Ch]

  v3 = strlen(a2);
  if ( (*a3 & 0x8000) == 0 )
  {
    _EDX = a3[18];
    v12 = __readgsdword(8u);
    if ( v12 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v6 = __readgsdword(0xCu) == 0;
      if ( !v6 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v6 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
      _EDX = a3[18];
      *(_DWORD *)(_EDX + 8) = v12;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v7 = a3[26];
  if ( v7 )
  {
    if ( v7 != -1 )
    {
LABEL_22:
      v9 = -1;
      goto LABEL_14;
    }
  }
  else
  {
    a3[26] = -1;
  }
  v13 = a3[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v13
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  v8 = (*(int (__cdecl **)(_DWORD *, _BYTE *, int))(v13 + 28))(a3, a2, v3);
  v9 = 1;
  if ( v3 != v8 )
    goto LABEL_22;
LABEL_14:
  if ( (*a3 & 0x8000) == 0 )
  {
    v10 = (_DWORD *)a3[18];
    v6 = v10[1]-- == 1;
    if ( v6 )
    {
      v10[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*v10)-- == 1;
      if ( !v6 )
        _lll_unlock_wake_private(v10);
    }
  }
  return v9;
}
// 808B8B5: variable 'v9' is possibly undefined
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0808B920) --------------------------------------------------------
int __usercall IO_wfile_doallocate@<eax>(long double a1@<st0>, unsigned int *a2)
{
  unsigned int v2; // eax
  unsigned int v3; // eax
  int v4; // ebx
  int v5; // eax

  v2 = a2[7];
  if ( !v2 )
  {
    IO_file_doallocate(a1, a2);
    v2 = a2[7];
  }
  v3 = a2[8] - v2;
  if ( (*(_BYTE *)a2 & 1) != 0 )
    v3 = (v3 + 3) >> 2;
  v4 = 4 * v3;
  v5 = malloc(a1, 4 * v3);
  if ( !v5 )
    return -1;
  IO_wsetb((int)a2, v5, v5 + v4, 1);
  return 1;
}

//----- (0808B9A0) --------------------------------------------------------
int __usercall fwrite@<eax>(long double a1@<st0>, int a2, unsigned int a3, int a4, _DWORD *a5)
{
  int v5; // esi
  bool v8; // zf
  int v9; // eax
  _DWORD *v10; // ecx
  bool v11; // bl
  unsigned int v12; // edx
  int v14; // eax
  unsigned int v15; // [esp+Ch] [ebp-1Ch]
  int v16; // [esp+Ch] [ebp-1Ch]

  v5 = a3 * a4;
  if ( !(a3 * a4) )
    return v5;
  if ( (*a5 & 0x8000) == 0 )
  {
    _EDX = a5[18];
    v15 = __readgsdword(8u);
    if ( v15 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v8 = __readgsdword(0xCu) == 0;
      if ( !v8 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v8 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
      _EDX = a5[18];
      *(_DWORD *)(_EDX + 8) = v15;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v9 = a5[26];
  if ( v9 )
  {
    if ( v9 != -1 )
    {
      if ( (*a5 & 0x8000) != 0 || (v10 = (_DWORD *)a5[18], v8 = v10[1] == 1, --v10[1], !v8) )
      {
        v12 = 0;
        return v12 / a3;
      }
      v11 = 0;
      v12 = 0;
      goto LABEL_15;
    }
  }
  else
  {
    a5[26] = -1;
  }
  v16 = a5[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v16
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  v14 = (*(int (__cdecl **)(_DWORD *, int, int))(v16 + 28))(a5, a2, v5);
  v12 = v14;
  if ( (*a5 & 0x8000) != 0 )
  {
    v11 = v14 == -1;
    goto LABEL_19;
  }
  v10 = (_DWORD *)a5[18];
  v11 = v14 == -1;
  v8 = v10[1]-- == 1;
  if ( !v8 )
    goto LABEL_19;
LABEL_15:
  v10[2] = 0;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v8 = (*v10)-- == 1;
  if ( !v8 )
    _lll_unlock_wake_private(v10);
LABEL_19:
  if ( v5 == v12 || v11 )
    return a4;
  return v12 / a3;
}
// 808BA4A: variable 'v12' is possibly undefined
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0808BB30) --------------------------------------------------------
int __cdecl getdelim(int *a1, unsigned int *a2, int a3, int *a4)
{
  int v4; // ecx
  unsigned int v6; // ebx
  bool v8; // zf
  int v9; // edx
  int v10; // eax
  _BYTE *v12; // eax
  signed int v13; // ebx
  unsigned int v14; // ecx
  unsigned int v15; // edi
  int v16; // eax
  int v17; // edx
  int v18; // [esp+0h] [ebp-28h]
  int v19; // [esp+4h] [ebp-24h]
  _BYTE *v20; // [esp+8h] [ebp-20h]
  int v21; // [esp+8h] [ebp-20h]
  int i; // [esp+Ch] [ebp-1Ch]

  if ( !a1 || !a2 )
  {
    v19 = -1;
    __writegsdword(0xFFFFFFE8, 0x16u);
    return v19;
  }
  v4 = *a4;
  if ( (*a4 & 0x8000) != 0 )
  {
    if ( (v4 & 0x20) != 0 )
      return -1;
    goto LABEL_23;
  }
  _EDX = a4[18];
  v6 = __readgsdword(8u);
  if ( v6 == *(_DWORD *)(_EDX + 8) )
  {
    ++*(_DWORD *)(_EDX + 4);
    if ( (v4 & 0x20) != 0 )
    {
      v19 = -1;
      goto LABEL_13;
    }
LABEL_23:
    if ( !*a1 || !*a2 )
    {
      *a2 = 120;
      v12 = (_BYTE *)malloc(120);
      *a1 = (int)v12;
      if ( !v12 )
      {
LABEL_43:
        v10 = *a4;
        v19 = -1;
        goto LABEL_11;
      }
    }
    v13 = a4[2] - a4[1];
    v20 = (_BYTE *)a4[1];
    if ( v13 <= 0 )
    {
      v19 = _underflow(a4);
      if ( v19 == -1 )
      {
LABEL_42:
        v10 = *a4;
        goto LABEL_11;
      }
      v20 = (_BYTE *)a4[1];
      v13 = a4[2] - (_DWORD)v20;
    }
    for ( i = 0; ; i = v19 )
    {
      v17 = j_memchr(v20, a3, v13);
      if ( v17 )
        v13 = v17 - (_DWORD)v20 + 1;
      if ( v13 >= 0x7FFFFFFF - i )
      {
        v19 = -1;
        __writegsdword(0xFFFFFFE8, 0x4Bu);
        v10 = *a4;
        goto LABEL_11;
      }
      v14 = v13 + i + 1;
      v19 = v13 + i;
      if ( v14 > *a2 )
      {
        v21 = v17;
        if ( 2 * *a2 >= v14 )
          v14 = 2 * *a2;
        v15 = v14;
        v16 = realloc((_BYTE *)*a1, v14);
        v17 = v21;
        if ( !v16 )
          goto LABEL_43;
        *a1 = v16;
        *a2 = v15;
        v20 = (_BYTE *)a4[1];
      }
      else
      {
        v16 = *a1;
      }
      v18 = v17;
      memcpy((_BYTE *)(i + v16), v20, v13);
      a4[1] += v13;
      if ( v18 || _underflow(a4) == -1 )
        break;
      v20 = (_BYTE *)a4[1];
      v13 = a4[2] - (_DWORD)v20;
    }
    *(_BYTE *)(*a1 + v19) = 0;
    goto LABEL_42;
  }
  _ECX = 1;
  v8 = __readgsdword(0xCu) == 0;
  if ( !v8 )
    __asm { lock }
  __asm { cmpxchg [edx], ecx }
  if ( !v8 )
    _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
  v9 = a4[18];
  v10 = *a4;
  ++*(_DWORD *)(v9 + 4);
  *(_DWORD *)(v9 + 8) = v6;
  if ( (v10 & 0x20) == 0 )
    goto LABEL_23;
  v19 = -1;
LABEL_11:
  if ( (v10 & 0x8000) != 0 )
    return v19;
  _EDX = a4[18];
LABEL_13:
  v8 = (*(_DWORD *)(_EDX + 4))-- == 1;
  if ( !v8 )
    return v19;
  *(_DWORD *)(_EDX + 8) = 0;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v8 = (*(_DWORD *)_EDX)-- == 1;
  if ( !v8 )
    _lll_unlock_wake_private((_DWORD *)_EDX);
  return v19;
}
// 8048220: using guessed type int __cdecl j_memchr(_DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);

//----- (0808BE20) --------------------------------------------------------
_BYTE *__cdecl IO_getline_info(int *a1, _BYTE *a2, unsigned int a3, int a4, int a5, _DWORD *a6)
{
  unsigned int v6; // ebp
  _BYTE *v7; // edi
  signed int v8; // ebx
  int v9; // eax
  int v10; // edx
  int v11; // eax
  _BYTE *result; // eax
  _BYTE *v13; // ebp
  _BYTE *v14; // ecx
  _BYTE *v15; // edi
  int v16; // edx
  int v17; // ebp
  unsigned int v18; // ebx
  _BYTE *v19; // ebx
  _BYTE *v20; // [esp-10h] [ebp-3Ch]
  _BYTE *v21; // [esp+Ch] [ebp-20h]
  int v22; // [esp+Ch] [ebp-20h]

  v6 = a3;
  if ( a6 )
    *a6 = 0;
  if ( !a1[26] )
    a1[26] = -1;
  if ( !a3 )
    return 0;
  v7 = a2;
  while ( 1 )
  {
    while ( 1 )
    {
      v10 = a1[1];
      v8 = a1[2] - v10;
      if ( v8 > 0 )
        break;
      v11 = _uflow(a1);
      if ( v11 == -1 )
      {
        if ( a6 )
          *a6 = -1;
        return (_BYTE *)(v7 - a2);
      }
      if ( a4 == v11 )
      {
        if ( a5 <= 0 )
        {
          v19 = v7;
          if ( a5 )
            IO_sputbackc(a1, a4);
        }
        else
        {
          v19 = v7 + 1;
          *v7 = a4;
        }
        return (_BYTE *)(v19 - a2);
      }
      --v6;
      *v7++ = v11;
      if ( !v6 )
        return (_BYTE *)(v7 - a2);
    }
    if ( v8 >= v6 )
      v8 = v6;
    v21 = (_BYTE *)a1[1];
    v9 = j_memchr(v10, a4, v8);
    if ( v9 )
      break;
    v6 -= v8;
    v20 = v7;
    v7 += v8;
    memcpy(v20, v21, v8);
    a1[1] += v8;
    if ( !v6 )
      return (_BYTE *)(v7 - a2);
  }
  v13 = v7;
  v14 = v7;
  v15 = v21;
  v16 = v9;
  v17 = v13 - a2;
  v18 = v9 - (_DWORD)v21;
  if ( a5 >= 0 )
  {
    v16 = v9 + 1;
    v18 -= (a5 == 0) - 1;
  }
  v22 = v16;
  memcpy(v14, v15, v18);
  result = (_BYTE *)(v17 + v18);
  a1[1] = v22;
  return result;
}
// 8048220: using guessed type int __cdecl j_memchr(_DWORD, _DWORD, _DWORD);

//----- (0808BF90) --------------------------------------------------------
_BYTE *__cdecl IO_getline(int *a1, _BYTE *a2, unsigned int a3, int a4, int a5)
{
  return IO_getline_info(a1, a2, a3, a4, a5, 0);
}

//----- (0808BFC0) --------------------------------------------------------
int __cdecl IO_padn(int a1, int a2, int a3)
{
  const char *v3; // ebp
  int v4; // edi
  char *v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // edx
  int v11; // [esp+8h] [ebp-34h]
  int v12; // [esp+Ch] [ebp-30h] BYREF
  char v13; // [esp+10h] [ebp-2Ch] BYREF
  char v14; // [esp+1Fh] [ebp-1Dh] BYREF

  v3 = "                ";
  v4 = a3;
  if ( a2 != 32 )
  {
    v3 = (const char *)&zeroes;
    if ( a2 != 48 )
    {
      v5 = &v14;
      do
        *v5-- = a2;
      while ( (char *)&v12 + 3 != v5 );
      v3 = &v13;
    }
  }
  if ( a3 <= 15 )
  {
    v6 = 0;
LABEL_13:
    if ( v4 > 0 )
    {
      v9 = *(_DWORD *)(a1 + 148);
      if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v9
                                                                                            - (_DWORD)&_start___libc_IO_vtables) )
      {
        v11 = *(_DWORD *)(a1 + 148);
        IO_vtable_check();
        v9 = v11;
      }
      v6 += (*(int (__cdecl **)(int, const char *, int))(v9 + 28))(a1, v3, v4);
    }
  }
  else
  {
    v6 = 0;
    while ( 1 )
    {
      v8 = *(_DWORD *)(a1 + 148);
      if ( v8 - (int)&_start___libc_IO_vtables >= (unsigned int)((char *)_start___libc_atexit
                                                               - (char *)&_start___libc_IO_vtables) )
      {
        v12 = *(_DWORD *)(a1 + 148);
        IO_vtable_check();
        v8 = v12;
      }
      v7 = (*(int (__cdecl **)(int, const char *, int))(v8 + 28))(a1, v3, 16);
      v6 += v7;
      if ( v7 != 16 )
        break;
      v4 -= 16;
      if ( v4 <= 15 )
        goto LABEL_13;
    }
  }
  return v6;
}
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0808C0B0) --------------------------------------------------------
int __cdecl IO_wpadn(int a1, int a2, int a3)
{
  const char *v3; // ebp
  int v4; // edi
  int *v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // edx
  int v11; // [esp+8h] [ebp-64h]
  int v12; // [esp+Ch] [ebp-60h] BYREF
  char v13; // [esp+10h] [ebp-5Ch] BYREF
  char v14; // [esp+4Ch] [ebp-20h] BYREF

  v3 = " ";
  v4 = a3;
  if ( a2 != 32 )
  {
    v3 = "0";
    if ( a2 != 48 )
    {
      v5 = (int *)&v14;
      do
        *v5-- = a2;
      while ( &v12 != v5 );
      v3 = &v13;
    }
  }
  if ( a3 <= 15 )
  {
    v6 = 0;
LABEL_13:
    if ( v4 > 0 )
    {
      v9 = *(_DWORD *)(a1 + 148);
      if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v9
                                                                                            - (_DWORD)&_start___libc_IO_vtables) )
      {
        v11 = *(_DWORD *)(a1 + 148);
        IO_vtable_check();
        v9 = v11;
      }
      v6 += (*(int (__cdecl **)(int, const char *, int))(v9 + 28))(a1, v3, v4);
    }
  }
  else
  {
    v6 = 0;
    while ( 1 )
    {
      v8 = *(_DWORD *)(a1 + 148);
      if ( v8 - (int)&_start___libc_IO_vtables >= (unsigned int)((char *)_start___libc_atexit
                                                               - (char *)&_start___libc_IO_vtables) )
      {
        v12 = *(_DWORD *)(a1 + 148);
        IO_vtable_check();
        v8 = v12;
      }
      v7 = (*(int (__cdecl **)(int, const char *, int))(v8 + 28))(a1, v3, 16);
      v6 += v7;
      if ( v7 != 16 )
        break;
      v4 -= 16;
      if ( v4 <= 15 )
        goto LABEL_13;
    }
  }
  return v6;
}
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0808C1A0) --------------------------------------------------------
int __usercall save_for_wbackup@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>)
{
  _DWORD *v4; // ecx
  int v5; // ebx
  int v6; // edx
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  int v9; // edi
  unsigned int v10; // esi
  int v11; // esi
  _BYTE *v12; // esi
  unsigned int v14; // edi
  int v15; // eax
  int v16; // edx
  int v17; // esi
  _WORD *v18; // eax
  int v19; // [esp+8h] [ebp-34h]
  int v20; // [esp+8h] [ebp-34h]
  int v21; // [esp+8h] [ebp-34h]
  int v22; // [esp+Ch] [ebp-30h]
  int v23; // [esp+Ch] [ebp-30h]
  int v24; // [esp+10h] [ebp-2Ch]
  _BYTE *v26; // [esp+18h] [ebp-24h]
  int v27; // [esp+1Ch] [ebp-20h]

  v4 = *(_DWORD **)(a1 + 88);
  v26 = (_BYTE *)v4[2];
  v5 = (a2 - (int)v26) >> 2;
  v22 = v5;
  v6 = v5;
  v7 = *(_DWORD **)(a1 + 48);
  if ( !v7 )
  {
    v27 = v4[10];
    v24 = v4[8];
    v11 = (v27 - v24) >> 2;
    if ( v5 >= 0 )
      goto LABEL_9;
LABEL_20:
    wmemmove(4 * v11 + v24, v27 + 4 * v5, -v5);
    wmemcpy(
      (_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 88) + 32) + 4 * (v11 - v5)),
      *(_BYTE **)(*(_DWORD *)(a1 + 88) + 8),
      (a2 - *(_DWORD *)(*(_DWORD *)(a1 + 88) + 8)) >> 2);
    v4 = *(_DWORD **)(a1 + 88);
    v12 = (_BYTE *)(v4[8] + 4 * v11);
    goto LABEL_17;
  }
  v8 = v7;
  do
  {
    v9 = v8[2];
    v8 = (_DWORD *)*v8;
    if ( v5 > v9 )
      v5 = v9;
  }
  while ( v8 );
  v27 = v4[10];
  v19 = v22 - v5;
  v24 = v4[8];
  v10 = (v27 - v24) >> 2;
  if ( v22 - v5 > v10 )
  {
    v14 = 4 * v19 + 400;
    v15 = malloc(a3, v14);
    if ( !v15 )
      return -1;
    v12 = (_BYTE *)(v15 + 400);
    if ( v5 < 0 )
    {
      v21 = v15;
      v18 = wmempcpy(v12, (_BYTE *)(v27 + 4 * v5), -v5);
      wmempcpy(v18, v26, v22);
      v16 = v21;
    }
    else
    {
      v23 = v15;
      wmemcpy(v12, &v26[4 * v5], v19);
      v16 = v23;
    }
    v20 = v16;
    free(a3, *(_DWORD *)(*(_DWORD *)(a1 + 88) + 32));
    v4 = *(_DWORD **)(a1 + 88);
    v4[8] = v20;
    v4[10] = v20 + v14;
    goto LABEL_17;
  }
  v11 = v10 - v19;
  if ( v5 < 0 )
    goto LABEL_20;
  if ( v19 )
  {
    v17 = 4 * v11;
    wmemcpy((_BYTE *)(v17 + v24), &v26[4 * v5], v19);
    v4 = *(_DWORD **)(a1 + 88);
    v12 = (_BYTE *)(v4[8] + v17);
LABEL_17:
    v7 = *(_DWORD **)(a1 + 48);
    v6 = (a2 - v4[2]) >> 2;
    goto LABEL_10;
  }
LABEL_9:
  v12 = (_BYTE *)(v24 + 4 * v11);
LABEL_10:
  for ( v4[9] = v12; v7; v7 = (_DWORD *)*v7 )
    v7[2] -= v6;
  return 0;
}

//----- (0808C3B0) --------------------------------------------------------
int __cdecl IO_least_wmarker(int a1, int a2)
{
  _DWORD *v2; // edx
  int result; // eax
  int v4; // ecx

  v2 = *(_DWORD **)(a1 + 48);
  result = (a2 - *(_DWORD *)(*(_DWORD *)(a1 + 88) + 8)) >> 2;
  while ( v2 )
  {
    v4 = v2[2];
    v2 = (_DWORD *)*v2;
    if ( result > v4 )
      result = v4;
  }
  return result;
}

//----- (0808C3E0) --------------------------------------------------------
_DWORD *__cdecl IO_switch_to_main_wget_area(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // ecx

  *a1 &= ~0x100u;
  result = (_DWORD *)a1[22];
  v2 = result[10];
  result[10] = result[1];
  v3 = result[8];
  result[1] = v2;
  v4 = result[2];
  *result = v3;
  result[2] = v3;
  result[8] = v4;
  return result;
}

//----- (0808C410) --------------------------------------------------------
_DWORD *__cdecl IO_switch_to_wbackup_area(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // edx
  int v3; // ebx
  int v4; // ecx

  *a1 |= 0x100u;
  result = (_DWORD *)a1[22];
  v2 = result[10];
  v3 = result[8];
  result[10] = result[1];
  v4 = result[2];
  result[1] = v2;
  *result = v2;
  result[2] = v3;
  result[8] = v4;
  return result;
}

//----- (0808C440) --------------------------------------------------------
unsigned int __cdecl IO_wsetb(int a1, int a2, int a3, int a4)
{
  int v4; // edx
  int v5; // eax
  int v6; // edx
  unsigned int result; // eax

  v4 = *(_DWORD *)(a1 + 88);
  v5 = *(_DWORD *)(a1 + 60);
  if ( *(_DWORD *)(v4 + 24) && (v5 & 8) == 0 )
  {
    free(*(_DWORD *)(v4 + 24));
    v4 = *(_DWORD *)(a1 + 88);
    v5 = *(_DWORD *)(a1 + 60);
  }
  *(_DWORD *)(v4 + 24) = a2;
  *(_DWORD *)(v4 + 28) = a3;
  v6 = v5 | 8;
  result = v5 & 0xFFFFFFF7;
  if ( !a4 )
    result = v6;
  *(_DWORD *)(a1 + 60) = result;
  return result;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0808C4A0) --------------------------------------------------------
int __usercall IO_wdefault_pbackfail@<eax>(long double a1@<st0>, int *a2, int a3)
{
  int *v3; // ebx
  _BYTE *v4; // esi
  unsigned int v5; // edx
  int v6; // edx
  int result; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // edx
  int v11; // ecx
  int v12; // ebx
  int v13; // eax
  int v14; // [esp+4h] [ebp-28h]
  _BYTE *v15; // [esp+8h] [ebp-24h]
  int v16; // [esp+Ch] [ebp-20h]

  v3 = (int *)a2[22];
  v4 = (_BYTE *)*v3;
  v5 = v3[2];
  if ( *v3 <= v5 )
  {
    v8 = *a2;
    if ( (*a2 & 0x100) != 0 )
    {
      v15 = (_BYTE *)v3[2];
      v12 = (int)(v3[1] - v5) >> 2;
      v14 = 8 * v12;
      v13 = malloc(a1, 8 * v12);
      if ( !v13 )
        return -1;
      v16 = v13;
      v4 = (_BYTE *)(v13 + 4 * v12);
      wmemcpy(v4, v15, v12);
      free(a1, *(_DWORD *)(a2[22] + 8));
      v3 = (int *)a2[22];
      v3[2] = v16;
      *v3 = (int)v4;
      v3[9] = (int)v4;
      v3[1] = v14 + v16;
      goto LABEL_11;
    }
    v9 = v3[8];
    if ( v9 )
    {
      v10 = *v3;
      v4 = (_BYTE *)v3[10];
LABEL_10:
      BYTE1(v8) |= 1u;
      *a2 = v8;
      v11 = v3[1];
      v3[2] = v9;
      v3[1] = (int)v4;
      v3[8] = v10;
      *v3 = (int)v4;
      v3[10] = v11;
      goto LABEL_11;
    }
LABEL_15:
    v9 = malloc(a1, 0x200u);
    if ( !v9 )
      return -1;
    v10 = (int)v4;
    v3[8] = v9;
    v3[10] = v9 + 512;
    v3[9] = v9 + 512;
    v4 = (_BYTE *)(v9 + 512);
    v8 = *a2;
    goto LABEL_10;
  }
  if ( (*a2 & 0x100) != 0 )
  {
LABEL_11:
    *v3 = (int)(v4 - 4);
    *((_DWORD *)v4 - 1) = a3;
    return a3;
  }
  v6 = a2[1];
  result = *(char *)(v6 - 1);
  if ( result != a3 )
  {
    if ( v3[8] )
    {
      if ( save_for_wbackup((int)a2, *v3, a1) )
        return -1;
      v3 = (int *)a2[22];
      v8 = *a2;
      v10 = *v3;
      v4 = (_BYTE *)v3[10];
      v9 = v3[8];
      goto LABEL_10;
    }
    goto LABEL_15;
  }
  a2[1] = v6 - 1;
  return result;
}

//----- (0808C630) --------------------------------------------------------
int __usercall IO_wdefault_finish@<eax>(long double a1@<st0>, int a2)
{
  int *v2; // edx
  _DWORD *i; // eax

  v2 = *(int **)(a2 + 88);
  if ( v2[6] && (*(_BYTE *)(a2 + 60) & 8) == 0 )
  {
    free(a1, v2[6]);
    v2 = *(int **)(a2 + 88);
    v2[7] = 0;
    v2[6] = 0;
  }
  for ( i = *(_DWORD **)(a2 + 48); i; i = (_DWORD *)*i )
    i[1] = 0;
  if ( *(_DWORD *)(a2 + 36) )
  {
    free(a1, v2[8]);
    *(_DWORD *)(a2 + 36) = 0;
  }
  return IO_un_link((int *)a2);
}

//----- (0808C6B0) --------------------------------------------------------
int __usercall IO_wdefault_uflow@<eax>(long double a1@<st0>, int a2)
{
  int v2; // esi
  int v3; // eax
  int v4; // edx
  int *v5; // edx
  int v6; // eax

  v2 = *(_DWORD *)(a2 + 148);
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  v3 = (*(int (__cdecl **)(int))(v2 + 16))(a2);
  v4 = -1;
  if ( v3 != -1 )
  {
    v5 = *(int **)(a2 + 88);
    v6 = *v5;
    *v5 += 4;
    return *(_DWORD *)v6;
  }
  return v4;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0808C710) --------------------------------------------------------
int __cdecl _woverflow(_DWORD *a1, int a2)
{
  int v2; // esi

  if ( !a1[26] )
    IO_fwide(a1, 1);
  v2 = a1[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(_DWORD *, int))(v2 + 12))(a1, a2);
}
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0808C780) --------------------------------------------------------
unsigned int __cdecl IO_wdefault_xsputn(_DWORD *a1, int *a2, unsigned int a3)
{
  unsigned int i; // edi
  int v5; // ebp
  int *v6; // eax
  _BYTE *v7; // ecx
  int v8; // ebx
  unsigned int v9; // edx
  int v10; // edx
  unsigned int v11; // eax

  if ( a3 )
  {
    for ( i = a3; ; --i )
    {
      v5 = a1[22];
      v6 = a2;
      v7 = *(_BYTE **)(v5 + 16);
      v8 = (*(_DWORD *)(v5 + 20) - (int)v7) >> 2;
      v9 = v8;
      if ( v8 > 0 )
        break;
LABEL_8:
      if ( i )
      {
        a2 = v6 + 1;
        if ( _woverflow(a1, *v6) != -1 )
          continue;
      }
      return a3 - i;
    }
    if ( i >= v8 )
    {
      if ( v8 <= 20 )
        goto LABEL_12;
    }
    else
    {
      v9 = i;
      if ( i <= 0x14 )
      {
        v8 = 0;
        if ( !i )
        {
LABEL_7:
          i -= v8;
          goto LABEL_8;
        }
        v8 = i;
LABEL_12:
        v10 = 4 * v9;
        v11 = 0;
        do
        {
          *(_DWORD *)&v7[v11] = a2[v11 / 4];
          v11 += 4;
        }
        while ( v10 != v11 );
        v6 = &a2[v10 / 4u];
        *(_DWORD *)(v5 + 16) = &v7[v10];
        goto LABEL_7;
      }
      v8 = i;
    }
    *(_DWORD *)(v5 + 16) = wmempcpy(v7, a2, v8);
    v6 = &a2[v8];
    goto LABEL_7;
  }
  return 0;
}

//----- (0808C870) --------------------------------------------------------
unsigned int __cdecl IO_wdoallocbuf(int a1)
{
  unsigned int result; // eax

  result = *(_DWORD *)(a1 + 88);
  if ( !*(_DWORD *)(result + 24) )
  {
    if ( (*(_BYTE *)a1 & 2) == 0 )
    {
      result = (*(int (__cdecl **)(int))(*(_DWORD *)(result + 176) + 52))(a1);
      if ( result != -1 )
        return result;
      result = *(_DWORD *)(a1 + 88);
    }
    return IO_wsetb(a1, result + 172, result + 176, 0);
  }
  return result;
}

//----- (0808C8D0) --------------------------------------------------------
int __usercall IO_wdefault_doallocate@<eax>(long double a1@<st0>, int a2)
{
  int v2; // eax

  v2 = malloc(a1, 0x2000u);
  if ( !v2 )
    return -1;
  IO_wsetb(a2, v2, v2 + 0x8000, 1);
  return 1;
}

//----- (0808C920) --------------------------------------------------------
int __cdecl IO_switch_to_wget_mode(int *a1)
{
  unsigned int *v1; // eax
  unsigned int v2; // edx
  int v3; // ecx
  bool v4; // cf
  int result; // eax

  v1 = (unsigned int *)a1[22];
  v2 = v1[4];
  if ( v2 > v1[3] )
  {
    result = (*(int (__cdecl **)(int *, int))(v1[44] + 12))(a1, -1);
    if ( result == -1 )
      return result;
    v1 = (unsigned int *)a1[22];
    v2 = v1[4];
  }
  v3 = *a1;
  if ( (*a1 & 0x100) != 0 )
  {
    v1[2] = v1[9];
  }
  else
  {
    v4 = v1[1] < v2;
    v1[2] = v1[6];
    if ( v4 )
      v1[1] = v2;
  }
  BYTE1(v3) &= ~8u;
  *v1 = v2;
  v1[5] = v2;
  v1[3] = v2;
  *a1 = v3;
  return 0;
}

//----- (0808C990) --------------------------------------------------------
_DWORD *__cdecl IO_free_wbackup_area(int *a1)
{
  int v1; // eax
  _DWORD *v2; // eax
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  _DWORD *result; // eax

  v1 = *a1;
  if ( (*a1 & 0x100) != 0 )
  {
    BYTE1(v1) &= ~1u;
    *a1 = v1;
    v2 = (_DWORD *)a1[22];
    v3 = v2[10];
    v2[10] = v2[1];
    v2[1] = v3;
    v4 = v2[2];
    v5 = v2[8];
    v2[8] = v4;
    v2[2] = v5;
    *v2 = v5;
  }
  else
  {
    v4 = *(_DWORD *)(a1[22] + 32);
  }
  free(v4);
  result = (_DWORD *)a1[22];
  result[8] = 0;
  result[10] = 0;
  result[9] = 0;
  return result;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0808CA00) --------------------------------------------------------
int __usercall _wuflow@<eax>(long double a1@<st0>, int *a2)
{
  int v2; // esi
  unsigned int *v3; // eax
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // edx
  unsigned int v7; // esi
  unsigned int v8; // ecx
  int v10; // esi

  v2 = a2[26];
  if ( v2 < 0 )
    return -1;
  if ( v2 )
    goto LABEL_3;
  if ( IO_fwide(a2, 1) != 1 )
    return -1;
  if ( a2[26] )
  {
LABEL_3:
    if ( (*a2 & 0x800) == 0 )
      goto LABEL_4;
  }
  else
  {
    IO_fwide(a2, 1);
    if ( (*a2 & 0x800) == 0 )
      goto LABEL_4;
  }
  if ( IO_switch_to_wget_mode(a2) == -1 )
    return -1;
LABEL_4:
  v3 = (unsigned int *)a2[22];
  v4 = *v3;
  v5 = v3[1];
  if ( *v3 < v5 )
    goto LABEL_21;
  v6 = *a2;
  if ( (*a2 & 0x100) != 0 )
  {
    BYTE1(v6) &= ~1u;
    v7 = v3[10];
    *a2 = v6;
    v4 = v3[8];
    v3[10] = v5;
    v8 = v3[2];
    v3[1] = v7;
    v3[2] = v4;
    v3[8] = v8;
    if ( v7 <= v4 )
    {
      *v3 = v4;
      goto LABEL_8;
    }
LABEL_21:
    *v3 = v4 + 4;
    return *(_DWORD *)v4;
  }
LABEL_8:
  if ( a2[12] )
  {
    if ( save_for_wbackup((int)a2, v3[1], a1) )
      return -1;
  }
  else if ( v3[8] )
  {
    IO_free_wbackup_area(a2);
  }
  v10 = a2[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v10
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  return (*(int (__cdecl **)(int *))(v10 + 20))(a2);
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0808CB30) --------------------------------------------------------
int __usercall _wunderflow@<eax>(long double a1@<st0>, int *a2)
{
  int v2; // esi
  unsigned int *v3; // eax
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // edx
  unsigned int v8; // esi
  unsigned int v9; // ecx
  int v10; // esi

  v2 = a2[26];
  if ( v2 < 0 )
    return -1;
  if ( v2 )
    goto LABEL_3;
  if ( IO_fwide(a2, 1) != 1 )
    return -1;
  if ( a2[26] )
  {
LABEL_3:
    if ( (*a2 & 0x800) == 0 )
      goto LABEL_4;
  }
  else
  {
    IO_fwide(a2, 1);
    if ( (*a2 & 0x800) == 0 )
      goto LABEL_4;
  }
  if ( IO_switch_to_wget_mode(a2) == -1 )
    return -1;
LABEL_4:
  v3 = (unsigned int *)a2[22];
  v4 = *v3;
  v5 = v3[1];
  if ( *v3 < v5 )
    return *(_DWORD *)v4;
  v6 = *a2;
  if ( (*a2 & 0x100) != 0 )
  {
    BYTE1(v6) &= ~1u;
    v8 = v3[10];
    *a2 = v6;
    v4 = v3[8];
    v3[10] = v5;
    v9 = v3[2];
    v3[1] = v8;
    v3[2] = v4;
    *v3 = v4;
    v3[8] = v9;
    if ( v8 > v4 )
      return *(_DWORD *)v4;
  }
  if ( a2[12] )
  {
    if ( save_for_wbackup((int)a2, v3[1], a1) )
      return -1;
  }
  else if ( a2[9] )
  {
    IO_free_wbackup_area(a2);
  }
  v10 = a2[37];
  if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v10
                                                                                        - (_DWORD)&_start___libc_IO_vtables) )
    IO_vtable_check(a1);
  return (*(int (__cdecl **)(int *))(v10 + 16))(a2);
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0808CC60) --------------------------------------------------------
unsigned int __usercall IO_wdefault_xsgetn@<eax>(long double a1@<st0>, int *a2, _WORD *a3, unsigned int a4)
{
  unsigned int v5; // edi
  int v6; // ebp
  _BYTE *v7; // ecx
  int v8; // ebx
  unsigned int v9; // edx
  int v11; // edx
  unsigned int v12; // eax

  v5 = a4;
  do
  {
    v6 = a2[22];
    v7 = *(_BYTE **)v6;
    v8 = (*(_DWORD *)(v6 + 4) - *(_DWORD *)v6) >> 2;
    v9 = v8;
    if ( v8 > 0 )
    {
      if ( v5 >= v8 )
      {
        if ( v8 <= 20 )
          goto LABEL_11;
      }
      else
      {
        v9 = v5;
        if ( v5 <= 0x14 )
        {
          v8 = 0;
          if ( !v5 )
          {
LABEL_6:
            v5 -= v8;
            continue;
          }
          v8 = v5;
LABEL_11:
          v11 = 4 * v9;
          v12 = 0;
          do
          {
            *(_DWORD *)&a3[v12 / 2] = *(_DWORD *)&v7[v12];
            v12 += 4;
          }
          while ( v11 != v12 );
          a3 = (_WORD *)((char *)a3 + v11);
          *(_DWORD *)v6 = &v7[v11];
          goto LABEL_6;
        }
        v8 = v5;
      }
      a3 = wmempcpy(a3, v7, v8);
      *(_DWORD *)a2[22] += 4 * v8;
      goto LABEL_6;
    }
  }
  while ( v5 && _wunderflow(a1, a2) != -1 );
  return a4 - v5;
}

//----- (0808CD40) --------------------------------------------------------
int __usercall IO_sputbackwc@<eax>(long double a1@<st0>, _DWORD *a2, int a3)
{
  int *v3; // eax
  int v4; // edx
  int v5; // edi
  int result; // eax

  v3 = (int *)a2[22];
  v4 = *v3;
  if ( *v3 > (unsigned int)v3[2] && *(_DWORD *)(v4 - 4) == a3 )
  {
    *v3 = v4 - 4;
    result = a3;
  }
  else
  {
    v5 = a2[37];
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v5
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
      IO_vtable_check(a1);
    result = (*(int (__cdecl **)(_DWORD *, int))(v5 + 24))(a2, a3);
  }
  if ( result != -1 )
    *a2 &= ~0x10u;
  return result;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0808CDB0) --------------------------------------------------------
int __usercall IO_sungetwc@<eax>(long double a1@<st0>, _DWORD *a2)
{
  int *v2; // eax
  int v3; // edx
  int result; // eax
  int v5; // esi

  v2 = (int *)a2[22];
  v3 = *v2;
  if ( *v2 <= (unsigned int)v2[2] )
  {
    v5 = a2[37];
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v5
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
      IO_vtable_check(a1);
    result = (*(int (__cdecl **)(_DWORD *, int))(v5 + 24))(a2, -1);
  }
  else
  {
    *v2 = v3 - 4;
    result = *(_DWORD *)(v3 - 4);
  }
  if ( result != -1 )
    *a2 &= ~0x10u;
  return result;
}
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (0808CE20) --------------------------------------------------------
int __cdecl IO_adjust_wcolumn(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax
  _DWORD *v4; // edx

  v3 = a2 + 4 * a3;
  if ( a2 >= v3 )
    return a3 + a1;
  v4 = (_DWORD *)(v3 - 4);
  if ( *(_DWORD *)(v3 - 4) != 10 )
  {
    while ( a2 < (unsigned int)v4 )
    {
      if ( *--v4 == 10 )
        return ((int)(v3 - (_DWORD)v4) >> 2) - 1;
    }
    return a3 + a1;
  }
  return ((int)(v3 - (_DWORD)v4) >> 2) - 1;
}

//----- (0808CE70) --------------------------------------------------------
int __cdecl IO_init_wmarker(int *a1, int *a2)
{
  int v2; // eax
  int *v3; // edx
  bool v4; // zf
  int v5; // eax
  int v6; // eax
  int result; // eax

  v2 = *a2;
  a1[1] = (int)a2;
  if ( (v2 & 0x800) != 0 )
  {
    IO_switch_to_wget_mode(a2);
    v2 = *a2;
  }
  v3 = (int *)a2[22];
  v4 = (v2 & 0x100) == 0;
  v5 = *v3;
  if ( v4 )
    v6 = v5 - v3[2];
  else
    v6 = v5 - v3[1];
  a1[2] = v6 >> 2;
  result = a2[12];
  *a1 = result;
  a2[12] = (int)a1;
  return result;
}

//----- (0808CEE0) --------------------------------------------------------
int __cdecl IO_wmarker_delta(int a1)
{
  _DWORD *v1; // eax
  bool v2; // zf
  int *v3; // eax
  int v4; // edx
  int v5; // edx

  v1 = *(_DWORD **)(a1 + 4);
  if ( !v1 )
    return -1;
  v2 = (*v1 & 0x100) == 0;
  v3 = (int *)v1[22];
  v4 = *v3;
  if ( v2 )
    v5 = v4 - v3[2];
  else
    v5 = v4 - v3[1];
  return *(_DWORD *)(a1 + 8) - (v5 >> 2);
}

//----- (0808CF20) --------------------------------------------------------
int __cdecl IO_seekwmark(int *a1, int a2)
{
  int *v2; // eax
  int v3; // edx
  int v4; // ecx
  _DWORD *v5; // eax
  int v6; // ebx
  int v7; // ecx
  int v8; // ebx
  int v10; // esi
  int v11; // ebx

  v2 = *(int **)(a2 + 4);
  if ( v2 != a1 )
    return -1;
  v3 = *(_DWORD *)(a2 + 8);
  v4 = *v2;
  if ( v3 < 0 )
  {
    if ( (v4 & 0x100) != 0 )
    {
      v5 = (_DWORD *)v2[22];
      v7 = v5[1];
    }
    else
    {
      BYTE1(v4) |= 1u;
      *v2 = v4;
      v5 = (_DWORD *)v2[22];
      v7 = v5[10];
      v10 = v5[8];
      v5[10] = v5[1];
      v11 = v5[2];
      v5[1] = v7;
      v5[2] = v10;
      *v5 = v7;
      v5[8] = v11;
    }
  }
  else if ( (v4 & 0x100) != 0 )
  {
    BYTE1(v4) &= ~1u;
    *v2 = v4;
    v5 = (_DWORD *)v2[22];
    v6 = v5[10];
    v5[10] = v5[1];
    v5[1] = v6;
    v7 = v5[8];
    v8 = v5[2];
    *v5 = v7;
    v5[2] = v7;
    v5[8] = v8;
  }
  else
  {
    v5 = (_DWORD *)v2[22];
    v7 = v5[2];
  }
  *v5 = v7 + 4 * v3;
  return 0;
}

//----- (0808CFD0) --------------------------------------------------------
int *__cdecl IO_unsave_wmarkers(int *a1)
{
  int *result; // eax

  result = a1;
  if ( a1[12] )
    a1[12] = 0;
  if ( a1[9] )
    return IO_free_wbackup_area(a1);
  return result;
}

//----- (0808D000) --------------------------------------------------------
int __cdecl do_encoding(int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  v1 = *(_DWORD **)(a1 + 36);
  result = v1[13];
  if ( result )
    return -1;
  if ( v1[9] == v1[10] )
    return v1[9];
  return result;
}

//----- (0808D030) --------------------------------------------------------
int do_always_noconv()
{
  return 0;
}

//----- (0808D040) --------------------------------------------------------
int __cdecl do_max_length(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 36) + 40);
}

//----- (0808D050) --------------------------------------------------------
int __cdecl do_in(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8)
{
  _DWORD *v8; // edi
  int (__cdecl *v9)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD); // ebx
  int v10; // eax
  char v12[4]; // [esp+8h] [ebp-14h] BYREF
  int v13[4]; // [esp+Ch] [ebp-10h] BYREF

  v13[0] = a3;
  v8 = (_DWORD *)a1[9];
  a1[10] = a6;
  a1[11] = a7;
  a1[15] = a2;
  v9 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))v8[5];
  if ( *v8 )
    v9 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v9, 9));
  dl_mcount_wrapper_check((int)v9);
  v10 = v9(v8, a1 + 10, v13, a4, 0, v12, 0, 0);
  *a5 = v13[0];
  *a8 = a1[10];
  if ( v10 == 4 )
    return 0;
  if ( v10 <= 4 )
  {
    if ( v10 )
      return 2;
    return 0;
  }
  if ( v10 != 5 && v10 != 7 )
    return 2;
  return 1;
}
// 808D050: using guessed type int var_10[4];
// 808D050: using guessed type char var_14[4];

//----- (0808D110) --------------------------------------------------------
int __cdecl do_unshift(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5)
{
  _DWORD *v5; // edi
  int (__cdecl *v6)(_DWORD *, _DWORD *, _DWORD, _DWORD, _DWORD, char *, int, _DWORD); // ebx
  int v7; // eax
  char v9[16]; // [esp+Ch] [ebp-10h] BYREF

  a1[20] = a3;
  v5 = (_DWORD *)a1[19];
  a1[21] = a4;
  a1[25] = a2;
  v6 = (int (__cdecl *)(_DWORD *, _DWORD *, _DWORD, _DWORD, _DWORD, char *, int, _DWORD))v5[5];
  if ( *v5 )
    v6 = (int (__cdecl *)(_DWORD *, _DWORD *, _DWORD, _DWORD, _DWORD, char *, int, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v6, 9));
  dl_mcount_wrapper_check((int)v6);
  v7 = v6(v5, a1 + 20, 0, 0, 0, v9, 1, 0);
  *a5 = a1[20];
  if ( v7 == 4 )
    return 0;
  if ( v7 <= 4 )
  {
    if ( v7 )
      return 2;
    return 0;
  }
  if ( v7 != 5 && v7 != 7 )
    return 2;
  return 1;
}
// 808D110: using guessed type char var_10[16];

//----- (0808D1B0) --------------------------------------------------------
int __cdecl do_out(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8)
{
  _DWORD *v8; // edi
  int (__cdecl *v9)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD); // ebx
  int v10; // eax
  char v12[4]; // [esp+8h] [ebp-14h] BYREF
  int v13[4]; // [esp+Ch] [ebp-10h] BYREF

  v13[0] = a3;
  v8 = (_DWORD *)a1[19];
  a1[20] = a6;
  a1[21] = a7;
  a1[25] = a2;
  v9 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))v8[5];
  if ( *v8 )
    v9 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v9, 9));
  dl_mcount_wrapper_check((int)v9);
  v10 = v9(v8, a1 + 20, v13, a4, 0, v12, 0, 0);
  *a5 = v13[0];
  *a8 = a1[20];
  if ( v10 == 4 )
    return 0;
  if ( v10 <= 4 )
  {
    if ( v10 )
      return 2;
    return 0;
  }
  if ( v10 != 5 && v10 != 7 )
    return 2;
  return 1;
}
// 808D1B0: using guessed type int var_10[4];
// 808D1B0: using guessed type char var_14[4];

//----- (0808D270) --------------------------------------------------------
int __cdecl do_length(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // edi
  void *v6; // esp
  void (__stdcall *v7)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD, int, int, int, int); // ebx
  int v9; // [esp-10h] [ebp-38h]
  int v10; // [esp-Ch] [ebp-34h]
  int v11; // [esp-8h] [ebp-30h]
  int v12; // [esp-4h] [ebp-2Ch]
  _DWORD v13[2]; // [esp+0h] [ebp-28h] BYREF
  int v14; // [esp+8h] [ebp-20h] BYREF
  char v15[28]; // [esp+Ch] [ebp-1Ch] BYREF

  v14 = a3;
  v5 = (_DWORD *)a1[9];
  v6 = alloca(4 * a5 + 3);
  a1[10] = v13;
  a1[11] = &v13[a5];
  a1[15] = a2;
  v7 = (void (__stdcall *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD, int, int, int, int))v5[5];
  if ( *v5 )
    v7 = (void (__stdcall *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD, int, int, int, int))(__readgsdword(0x18u) ^ __ROR4__(v7, 9));
  dl_mcount_wrapper_check((int)v7);
  v7(v5, a1 + 10, &v14, a4, 0, v15, 0, 0, v9, v10, v11, v12);
  return v14 - a3;
}
// 808D2D9: variable 'v9' is possibly undefined
// 808D2D9: variable 'v10' is possibly undefined
// 808D2D9: variable 'v11' is possibly undefined
// 808D2D9: variable 'v12' is possibly undefined
// 808D270: using guessed type char var_1C[28];

//----- (0808D2F0) --------------------------------------------------------
int __cdecl IO_fwide(_DWORD *a1, int a2)
{
  int v2; // esi
  _DWORD *v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  void *v7; // eax
  void *v8; // ecx
  int v9; // eax
  int v10; // eax
  void *v12[11]; // [esp+10h] [ebp-2Ch] BYREF

  v2 = a1[26];
  if ( a2 < 0 )
  {
    if ( v2 )
      return v2;
    v2 = -1;
    goto LABEL_7;
  }
  if ( !v2 && a2 )
  {
    v3 = (_DWORD *)a1[22];
    v4 = v3[1];
    a1[21] = v3 + 15;
    v3[11] = 0;
    *v3 = v4;
    v5 = v3[3];
    v3[12] = 0;
    v3[4] = v5;
    v6 = a1[22];
    *(_DWORD *)(v6 + 52) = 0;
    *(_DWORD *)(v6 + 56) = 0;
    _wcsmbs_clone_conv(v12);
    if ( v12[1] != (void *)1 )
      _assert_fail("fcts.towc_nsteps == 1", "iofwide.c", 125, "_IO_fwide");
    if ( v12[3] != (void *)1 )
      _assert_fail("fcts.tomb_nsteps == 1", "iofwide.c", 126, "_IO_fwide");
    memset(v3 + 15, 0, 0x70u);
    v7 = v12[0];
    v3[23] = 1;
    v2 = 1;
    v3[29] = 1;
    v3[27] = 1;
    v8 = v12[2];
    v3[16] = do_out;
    v3[24] = v7;
    v9 = a1[22];
    v3[33] = 1;
    v3[39] = 1;
    v3[34] = v8;
    v3[37] = 9;
    v3[17] = do_unshift;
    v3[18] = do_in;
    v3[19] = do_encoding;
    v3[20] = do_always_noconv;
    v3[30] = v9 + 44;
    v3[40] = v9 + 44;
    v10 = *(_DWORD *)(v9 + 176);
    v3[21] = do_length;
    v3[22] = do_max_length;
    a1[37] = v10;
LABEL_7:
    a1[26] = v2;
  }
  return v2;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0808D460) --------------------------------------------------------
int __cdecl _libc_scratch_buffer_grow_preserve(int a1)
{
  _BYTE *v1; // edi
  unsigned int v2; // edx
  unsigned int v3; // esi
  int v4; // ecx
  int result; // eax
  _BYTE *v6; // ecx
  unsigned int v7; // [esp-8h] [ebp-34h]
  unsigned int v8; // [esp+Ch] [ebp-20h]
  _BYTE *v9; // [esp+Ch] [ebp-20h]

  v1 = *(_BYTE **)a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = 2 * v2;
  if ( *(_DWORD *)a1 != a1 + 8 )
  {
    if ( v2 > v3 )
    {
      __writegsdword(0xFFFFFFE8, 0xCu);
    }
    else
    {
      v4 = realloc(v1, 2 * v2);
      if ( v4 )
      {
LABEL_4:
        *(_DWORD *)a1 = v4;
        *(_DWORD *)(a1 + 4) = v3;
        return 1;
      }
      v1 = *(_BYTE **)a1;
    }
    free(v1);
    *(_DWORD *)a1 = a1 + 8;
    *(_DWORD *)(a1 + 4) = 1024;
    return 0;
  }
  v8 = *(_DWORD *)(a1 + 4);
  v6 = (_BYTE *)malloc(2 * v2);
  result = 0;
  if ( v6 )
  {
    v7 = v8;
    v9 = v6;
    memcpy(v6, v1, v7);
    v4 = (int)v9;
    goto LABEL_4;
  }
  return result;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0808D510) --------------------------------------------------------
_BYTE *__usercall strndup@<eax>(long double a1@<st0>, _BYTE *a2, int a3)
{
  unsigned int v3; // ebx
  _BYTE *result; // eax

  v3 = j_strnlen(a2, a3);
  result = (_BYTE *)malloc(a1, v3 + 1);
  if ( result )
  {
    result[v3] = 0;
    return memcpy(result, a2, v3);
  }
  return result;
}
// 80481C0: using guessed type int __cdecl j_strnlen(_DWORD, _DWORD);

//----- (0808D550) --------------------------------------------------------
unsigned int __usercall strerror_r@<eax>(long double a1@<st0>, signed int a2, _BYTE *a3, unsigned int a4)
{
  unsigned __int8 *v4; // eax
  _BYTE *v6; // ebp
  unsigned int v7; // edi
  char *v8; // ebx
  unsigned int v9; // eax
  _WORD *v10; // eax
  _BYTE *v11; // edx
  unsigned int v12; // edi
  _WORD *v13; // eax
  _BYTE *v14; // ebp
  unsigned int v15; // eax
  char *v16; // edx
  char v17; // [esp+2Fh] [ebp-1Dh] BYREF
  char v18[28]; // [esp+30h] [ebp-1Ch] BYREF

  if ( a2 < 0 )
  {
    v6 = (_BYTE *)dcgettext(a1, "libc", "Unknown error ", 5u);
    v17 = 0;
    v7 = strlen(v6);
    v8 = itoa_word(-a2, &v17, 0xAu, 0);
    v9 = a4;
    if ( v7 <= a4 )
      v9 = v7;
    v10 = mempcpy(a3, v6, v9);
    v11 = v10;
    if ( v7 >= a4 )
      goto LABEL_9;
    v12 = v7 + 1;
    v13 = (_WORD *)((char *)v10 + 1);
    *v11 = 45;
    if ( v12 >= a4 )
      goto LABEL_9;
    goto LABEL_15;
  }
  if ( a2 < sys_nerr )
  {
    v4 = (unsigned __int8 *)sys_errlist[a2];
    if ( v4 )
      return dcgettext(a1, "libc", v4, 5u);
  }
  v14 = (_BYTE *)dcgettext(a1, "libc", "Unknown error ", 5u);
  v17 = 0;
  v12 = strlen(v14);
  v8 = itoa_word(a2, &v17, 0xAu, 0);
  v15 = a4;
  if ( v12 <= a4 )
    v15 = v12;
  v13 = mempcpy(a3, v14, v15);
  if ( v12 < a4 )
  {
LABEL_15:
    v16 = (char *)(a4 - v12);
    if ( a4 - v12 > v18 - v8 )
      v16 = (char *)(v18 - v8);
    memcpy(v13, v8, (unsigned int)v16);
  }
LABEL_9:
  if ( a4 )
    a3[a4 - 1] = 0;
  return (unsigned int)a3;
}
// 80D511C: using guessed type int sys_nerr;

//----- (0808D6A0) --------------------------------------------------------
int (__cdecl *strnlen())(_BYTE *a1, int a2)
{
  int (__cdecl *result)(_BYTE *, int); // eax

  result = _strnlen_ia32;
  if ( (unk_80EC574 & 0x4000000) != 0 )
    return (int (__cdecl *)(_BYTE *, int))_strnlen_sse2;
  return result;
}

//----- (0808D6C0) --------------------------------------------------------
const __m128i *(__usercall *strrchr())@<eax>(const __m128i *a1@<esi>, const __m128i *a2, unsigned int a3)
{
  const __m128i *(__usercall *result)@<eax>(const __m128i *@<esi>, const __m128i *, unsigned int); // eax

  result = (const __m128i *(__usercall *)@<eax>(const __m128i *@<esi>, const __m128i *, unsigned int))_strrchr_ia32;
  if ( (unk_80EC574 & 0x4000000) != 0 )
  {
    result = (const __m128i *(__usercall *)@<eax>(const __m128i *@<esi>, const __m128i *, unsigned int))_strrchr_sse2_bsf;
    if ( (dword_80EC5A0 & 4) != 0 )
      return _strrchr_sse2;
  }
  return result;
}
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (0808D6F0) --------------------------------------------------------
unsigned int *__cdecl _strrchr_ia32(unsigned int *a1, int a2)
{
  unsigned int *result; // eax
  unsigned int *v3; // esi
  int v4; // ecx
  __int16 v5; // dx
  int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // edx
  unsigned int v9; // edx

  result = 0;
  v3 = a1;
  v4 = a2;
  BYTE1(v4) = a2;
  v5 = v4;
  v6 = v4 << 16;
  LOWORD(v6) = v5;
  if ( ((unsigned __int8)a1 & 3) == 0 )
  {
    while ( 1 )
    {
LABEL_27:
      v7 = *v3;
      if ( *v3 < 0x1010101 || (v7 ^ (*v3 - 16843009) | 0xFEFEFEFF) != -1 )
      {
LABEL_47:
        if ( (_BYTE)v7 == (_BYTE)v6 )
          result = v3;
        if ( (_BYTE)v7 )
        {
          if ( BYTE1(v7) == (_BYTE)v6 )
            result = (unsigned int *)((char *)v3 + 1);
          if ( BYTE1(v7) )
          {
            v9 = HIWORD(v7);
            if ( (_BYTE)v9 == (_BYTE)v6 )
              result = (unsigned int *)((char *)v3 + 2);
            if ( (_BYTE)v9 && BYTE1(v9) == (_BYTE)v6 )
              return (unsigned int *)((char *)v3 + 3);
          }
        }
        return result;
      }
      v8 = v6 ^ v7;
      if ( v8 < 0x1010101 )
      {
        --v3;
LABEL_15:
        --v3;
LABEL_16:
        --v3;
LABEL_17:
        if ( (v8 & 0xFF000000) == 0 )
        {
          result = (unsigned int *)((char *)v3 + 15);
          goto LABEL_26;
        }
        goto LABEL_22;
      }
      if ( (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v7 = v3[1];
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_46;
      v8 = v6 ^ v7;
      if ( v8 < 0x1010101 )
        goto LABEL_15;
      if ( (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_20;
      v7 = v3[2];
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_45;
      v8 = v6 ^ v7;
      if ( v8 < 0x1010101 )
        goto LABEL_16;
      if ( (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) == -1 )
      {
        v7 = v3[3];
        if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        {
          ++v3;
LABEL_45:
          ++v3;
LABEL_46:
          ++v3;
          goto LABEL_47;
        }
        v8 = v6 ^ v7;
        if ( v8 >= 0x1010101 )
        {
          if ( (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) == -1 )
            goto LABEL_26;
          goto LABEL_22;
        }
        goto LABEL_17;
      }
LABEL_21:
      --v3;
LABEL_22:
      if ( (v8 & 0xFF0000) != 0 )
      {
        result = v3 + 3;
        if ( !BYTE1(v8) )
          result = (unsigned int *)((char *)v3 + 13);
      }
      else
      {
        result = (unsigned int *)((char *)v3 + 14);
      }
LABEL_26:
      v3 += 4;
    }
    --v3;
LABEL_20:
    --v3;
    goto LABEL_21;
  }
  if ( (_BYTE)v5 == *(_BYTE *)a1 )
    result = a1;
  if ( *(_BYTE *)a1 )
  {
    v3 = (unsigned int *)((char *)a1 + 1);
    if ( (((unsigned int)a1 + 1) & 3) == 0 )
      goto LABEL_27;
    if ( (_BYTE)v5 == *(_BYTE *)v3 )
      result = (unsigned int *)((char *)a1 + 1);
    if ( *(_BYTE *)v3 )
    {
      v3 = (unsigned int *)((char *)a1 + 2);
      if ( (((unsigned int)a1 + 2) & 3) == 0 )
        goto LABEL_27;
      if ( (_BYTE)v5 == *(_BYTE *)v3 )
        result = (unsigned int *)((char *)a1 + 2);
      if ( *(_BYTE *)v3 )
      {
        v3 = (unsigned int *)((char *)a1 + 3);
        goto LABEL_27;
      }
    }
  }
  return result;
}

//----- (0808D8B0) --------------------------------------------------------
unsigned int __usercall critical_factorization_0@<eax>(int a1@<eax>, unsigned int a2@<edx>, int *a3@<ecx>)
{
  int v3; // ebp
  int v4; // esi
  int v5; // ecx
  int v6; // edx
  unsigned __int8 v7; // bl
  int v8; // ecx
  int v9; // edi
  int v10; // edx
  unsigned __int8 v11; // bl
  unsigned int result; // eax
  unsigned int v13; // edi
  int v14; // [esp+0h] [ebp-20h]
  int v15; // [esp+0h] [ebp-20h]
  int v17; // [esp+8h] [ebp-18h]

  v3 = 1;
  v4 = -1;
  v5 = 1;
  v14 = 0;
  while ( 1 )
  {
    v6 = v14 + v5;
    if ( v14 + v5 >= a2 )
      break;
    while ( 1 )
    {
      v7 = *(_BYTE *)(a1 + v4 + v5);
      if ( *(_BYTE *)(a1 + v6) >= v7 )
        break;
      v14 = v6;
      v5 = 1;
      v3 = v6 - v4;
      if ( ++v6 >= a2 )
        goto LABEL_5;
    }
    if ( *(_BYTE *)(a1 + v6) == v7 )
    {
      if ( v5 == v3 )
      {
        v14 = v6;
        v5 = 1;
      }
      else
      {
        ++v5;
      }
    }
    else
    {
      v3 = 1;
      v4 = v14;
      v5 = 1;
      ++v14;
    }
  }
LABEL_5:
  v17 = 1;
  v8 = 1;
  v15 = 0;
  *a3 = v3;
  v9 = -1;
  while ( 1 )
  {
    v10 = v15 + v8;
    if ( a2 <= v15 + v8 )
      break;
    while ( 1 )
    {
      v11 = *(_BYTE *)(a1 + v9 + v8);
      if ( *(_BYTE *)(a1 + v10) <= v11 )
        break;
      v15 = v10;
      v17 = v10 - v9;
      v8 = 1;
      if ( a2 <= ++v10 )
        goto LABEL_9;
    }
    if ( *(_BYTE *)(a1 + v10) == v11 )
    {
      if ( v8 == v17 )
      {
        v15 = v10;
        v8 = 1;
      }
      else
      {
        ++v8;
      }
    }
    else
    {
      v17 = 1;
      v8 = 1;
      v9 = v15++;
    }
  }
LABEL_9:
  result = v4 + 1;
  v13 = v9 + 1;
  if ( v13 >= v4 + 1 )
  {
    *a3 = v17;
    return v13;
  }
  return result;
}

//----- (0808DA10) --------------------------------------------------------
int __usercall two_way_long_needle_0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, unsigned int a4)
{
  char *v5; // eax
  unsigned int v6; // ebp
  unsigned __int8 *v7; // edx
  int v8; // eax
  int v9; // ecx
  unsigned int v10; // edi
  unsigned int v11; // eax
  int v12; // edx
  unsigned int v13; // eax
  unsigned int v14; // ecx
  unsigned int v16; // eax
  unsigned int v17; // edx
  _BYTE *v18; // edi
  int v19; // eax
  int v20; // eax
  char v21; // cl
  unsigned int v23; // [esp+8h] [ebp-454h]
  unsigned int v25; // [esp+10h] [ebp-44Ch]
  unsigned int v26; // [esp+18h] [ebp-444h]
  unsigned int v27; // [esp+24h] [ebp-438h]
  unsigned int v28; // [esp+3Ch] [ebp-420h] BYREF
  int v29[256]; // [esp+40h] [ebp-41Ch] BYREF
  char v30; // [esp+440h] [ebp-1Ch] BYREF

  v25 = critical_factorization_0(a3, a4, (int *)&v28);
  v5 = (char *)v29;
  do
  {
    *(_DWORD *)v5 = a4;
    v5 += 4;
  }
  while ( v5 != &v30 );
  v6 = a4 - 1;
  v7 = (unsigned __int8 *)a3;
  v8 = a4 - 1;
  if ( a4 )
  {
    do
    {
      v9 = *v7++;
      v29[v9] = v8--;
    }
    while ( v8 != -1 );
  }
  else
  {
    v6 = -1;
  }
  v26 = v28;
  if ( j_memcmp(a3, a3 + v28, v25) )
  {
    v16 = a4 - v25;
    if ( a4 - v25 < v25 )
      v16 = v25;
    v17 = 0;
    v27 = v16 + 1;
    v18 = (_BYTE *)(a3 + v25 - 1);
    while ( 1 )
    {
      v19 = v29[*(unsigned __int8 *)(v6 + a1 + v17)];
      if ( v19 )
        goto LABEL_47;
      if ( v6 > v25 )
      {
        if ( *(_BYTE *)(a3 + v25) != *(_BYTE *)(a1 + v17 + v25) )
        {
          v19 = v25;
LABEL_46:
          v17 += 1 - v25;
LABEL_47:
          v17 += v19;
          goto LABEL_48;
        }
        v19 = v25;
        while ( v6 > ++v19 )
        {
          if ( *(_BYTE *)(a3 + v19) != *(_BYTE *)(v17 + a1 + v19) )
            goto LABEL_46;
        }
      }
      if ( !v25 )
        return v17 + a1;
      if ( *(_BYTE *)(a1 + v25 - 1 + v17) == *v18 )
      {
        v20 = -1;
        while ( -v25 != v20 )
        {
          v21 = v18[v20--];
          if ( v21 != *(_BYTE *)(a1 + v25 + v17 + v20) )
            goto LABEL_50;
        }
        return v17 + a1;
      }
LABEL_50:
      v17 += v27;
LABEL_48:
      if ( a2 - a4 < v17 )
        return 0;
    }
  }
  v23 = 0;
  v10 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v12 = a1 + v10;
      v11 = v29[*(unsigned __int8 *)(a1 + v10 + v6)];
      if ( v11 )
      {
        if ( v23 && v26 > v11 )
          v11 = a4 - v26;
        v10 += v11;
        v23 = 0;
        goto LABEL_11;
      }
      v13 = v23;
      if ( v25 >= v23 )
        v13 = v25;
      if ( v6 <= v13 )
        break;
      if ( *(_BYTE *)(a1 + v10 + v13) == *(_BYTE *)(a3 + v13) )
      {
        while ( v6 > ++v13 )
        {
          if ( *(_BYTE *)(a3 + v13) != *(_BYTE *)(v12 + v13) )
            goto LABEL_29;
        }
        break;
      }
LABEL_29:
      v23 = 0;
      v10 += v13 + 1 - v25;
LABEL_11:
      if ( a2 - a4 < v10 )
        return 0;
    }
    v14 = v25 - 1;
    if ( v25 > v23 && *(_BYTE *)(a3 + v25 - 1) == *(_BYTE *)(a1 + v10 + v25 - 1) )
      break;
    if ( v23 + 1 > v25 )
      return v12;
LABEL_27:
    v10 += v26;
    v23 = a4 - v26;
    if ( a2 - a4 < v10 )
      return 0;
  }
  while ( v14 - 1 != v23 - 1 && *(_BYTE *)(a3 + v14 - 1) == *(_BYTE *)(v14 + a1 + v10 - 1) )
    --v14;
  v12 = a1 + v10;
  if ( v23 + 1 <= v14 )
    goto LABEL_27;
  return v12;
}
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 808DA10: using guessed type int var_41C[256];

//----- (0808DD70) --------------------------------------------------------
int __cdecl memmem(int a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4)
{
  int result; // eax
  unsigned int v5; // edi
  int v6; // ebp
  unsigned int v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // ecx
  _BYTE *v10; // ecx
  unsigned int v11; // eax
  unsigned __int8 *v12; // ebp
  unsigned int v13; // eax
  _BYTE *v14; // ecx
  int v15; // eax
  unsigned __int8 v16; // cl
  unsigned int v17; // [esp+8h] [ebp-54h]
  unsigned int v18; // [esp+Ch] [ebp-50h]
  int v19; // [esp+10h] [ebp-4Ch]
  int v20; // [esp+1Ch] [ebp-40h]
  unsigned int v21; // [esp+20h] [ebp-3Ch]
  int v22[8]; // [esp+3Ch] [ebp-20h] BYREF

  result = a1;
  if ( a4 )
  {
    if ( a4 > a2 )
      return 0;
    if ( a4 > 0x1F )
      return two_way_long_needle_0(a1, a2, (int)a3, a4);
    result = j_memchr(a1, *a3, a2);
    v19 = result;
    if ( !result )
      return 0;
    if ( a4 != 1 )
    {
      v5 = a2 - (result - a1);
      result = 0;
      if ( a4 <= v5 )
      {
        v18 = critical_factorization_0((int)a3, a4, v22);
        v20 = v22[0];
        v6 = v22[0];
        if ( !j_memcmp(a3, &a3[v22[0]], v18) )
        {
          v7 = 0;
          v17 = 0;
          while ( 1 )
          {
            v8 = v18;
            if ( v17 >= v18 )
              v8 = v17;
            if ( a4 > v8 )
            {
              if ( a3[v8] != *(_BYTE *)(v19 + v7 + v8) )
              {
LABEL_45:
                v17 = 0;
                v7 += v8 + 1 - v18;
                goto LABEL_24;
              }
              while ( a4 != ++v8 )
              {
                if ( a3[v8] != *(_BYTE *)(v19 + v7 + v8) )
                  goto LABEL_45;
              }
            }
            v9 = v18 - 1;
            if ( v17 >= v18 )
            {
              v9 = v18;
            }
            else if ( *(_BYTE *)(v19 + v7 + v18 - 1) == a3[v18 - 1] )
            {
              while ( v9 - 1 != v17 - 1 && a3[v9 - 1] == *(_BYTE *)(v9 + v19 + v7 - 1) )
                --v9;
            }
            else
            {
              v9 = v18;
            }
            if ( v17 + 1 > v9 )
              return v7 + v19;
            v7 += v20;
            v17 = a4 - v6;
LABEL_24:
            if ( v5 - a4 < v7 )
              return 0;
          }
        }
        v10 = (_BYTE *)(v18 + v19);
        v11 = a4 - v18;
        if ( a4 - v18 < v18 )
          v11 = v18;
        v7 = 0;
        v21 = v11 + 1;
        v12 = &a3[v18 - 1];
        while ( a3[v18] != *v10 )
        {
          ++v10;
          ++v7;
LABEL_32:
          if ( v5 - a4 < v7 )
            return 0;
        }
        v13 = v18 + 1;
        if ( a4 > v18 + 1 )
        {
          if ( a3[v18 + 1] != v10[1] )
          {
LABEL_46:
            v7 += v13 + 1 - v18;
LABEL_47:
            v10 = (_BYTE *)(v19 + v18 + v7);
            goto LABEL_32;
          }
          v14 = &v10[-v18];
          while ( a4 != ++v13 )
          {
            if ( a3[v13] != v14[v13] )
              goto LABEL_46;
          }
        }
        if ( !v18 )
          return v7 + v19;
        if ( *v12 == *(_BYTE *)(v19 + v18 - 1 + v7) )
        {
          v15 = -1;
          while ( v15 != -v18 )
          {
            v16 = v12[v15--];
            if ( v16 != *(_BYTE *)(v19 + v18 + v7 + v15) )
              goto LABEL_48;
          }
          return v7 + v19;
        }
LABEL_48:
        v7 += v21;
        goto LABEL_47;
      }
    }
  }
  return result;
}
// 8048220: using guessed type int __cdecl j_memchr(_DWORD, _DWORD, _DWORD);
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 808DD70: using guessed type int var_20[8];

//----- (0808E080) --------------------------------------------------------
int __usercall argz_create_sep@<eax>(long double a1@<st0>, char *a2, int a3, unsigned int *a4, int *a5)
{
  char *v5; // ebx
  int v6; // eax
  int v7; // ebp
  unsigned int v8; // eax
  int v9; // edx
  _BYTE *v10; // ecx
  char v11; // dl

  v5 = a2;
  v6 = strlen(a2);
  v7 = v6 + 1;
  if ( (unsigned int)(v6 + 1) <= 1 )
  {
    *a4 = 0;
    *a5 = 0;
    return 0;
  }
  v8 = malloc(a1, v6 + 1);
  v9 = 12;
  *a4 = v8;
  if ( !v8 )
    return v9;
  v10 = (_BYTE *)v8;
  do
  {
    while ( 1 )
    {
      v11 = *v5;
      if ( *v5 == a3 )
        break;
      *v10++ = v11;
LABEL_5:
      ++v5;
      if ( !v11 )
        goto LABEL_10;
    }
    if ( (unsigned int)v10 <= v8 || !*(v10 - 1) )
    {
      --v7;
      goto LABEL_5;
    }
    *v10 = 0;
    ++v5;
    ++v10;
  }
  while ( v11 );
LABEL_10:
  if ( !v7 )
  {
    free(a1, v8);
    *a4 = 0;
  }
  v9 = 0;
  *a5 = v7;
  return v9;
}

//----- (0808E150) --------------------------------------------------------
int __cdecl argz_add_sep(int *a1, _DWORD *a2, char *a3, int a4)
{
  char *v4; // ebx
  unsigned int v5; // ebp
  int v6; // edx
  int v7; // eax
  _BYTE *v8; // ecx
  char v9; // al
  int v10; // edx
  char v11; // al

  v4 = a3;
  v5 = strlen(a3) + 1;
  v6 = 0;
  if ( v5 > 1 )
  {
    v7 = realloc((_BYTE *)*a1, v5 + *a2);
    *a1 = v7;
    v6 = 12;
    if ( v7 )
    {
      v8 = (_BYTE *)(*a2 + v7);
      while ( 1 )
      {
        while ( 1 )
        {
          v10 = *v4;
          v9 = *v4;
          if ( v10 == a4 )
            break;
          *v8 = v10;
          v9 = *v4;
          ++v8;
LABEL_5:
          ++v4;
          if ( !v9 )
            goto LABEL_10;
        }
        if ( (unsigned int)v8 <= *a1 || !*(v8 - 1) )
        {
          --v5;
          goto LABEL_5;
        }
        *v8 = 0;
        v11 = *v4;
        ++v8;
        ++v4;
        if ( !v11 )
        {
LABEL_10:
          v6 = 0;
          *a2 += v5;
          return v6;
        }
      }
    }
  }
  return v6;
}

//----- (0808E200) --------------------------------------------------------
const __m128i *__usercall _strrchr_sse2@<eax>(const __m128i *a1@<esi>, const __m128i *a2, unsigned int a3)
{
  __m128i v3; // xmm1
  __m128i v4; // xmm2
  __m128i v5; // xmm1
  __m128i v6; // xmm1
  __m128i v7; // xmm0
  int v8; // ecx
  unsigned int v9; // eax
  unsigned int v10; // edi
  unsigned int v11; // ebx
  __m128i si128; // xmm0
  unsigned int v13; // edx
  __m128i v14; // xmm0
  __m128i v15; // xmm0
  __m128i v16; // xmm0
  __m128i v17; // xmm0
  int v19; // ecx

  v3 = _mm_cvtsi32_si128(a3);
  v4 = 0LL;
  v5 = _mm_unpacklo_epi8(v3, v3);
  v6 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v5, v5), 0);
  if ( ((unsigned __int8)a2 & 0x3Fu) > 0x30 )
  {
    v8 = (unsigned __int8)a2 & 0xF;
    si128 = _mm_load_si128((const __m128i *)((unsigned int)a2 & 0xFFFFFFF0));
    v13 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, si128)) >> v8;
    v9 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(si128, v6)) >> v8;
    v10 = ((unsigned int)a2 & 0xFFFFFFF0) + 16;
    if ( !v9 )
    {
      if ( !v13 )
      {
        v11 = 0;
        goto LABEL_12;
      }
      return 0;
    }
    if ( !v13 )
    {
      v11 = v9;
      a1 = (const __m128i *)(v10 + v8);
      goto LABEL_12;
    }
    v10 += v8;
    LOWORD(v8) = v13;
  }
  else
  {
    v7 = _mm_loadu_si128(a2);
    v4 = _mm_cmpeq_epi8((__m128i)0LL, v7);
    v8 = _mm_movemask_epi8(v4);
    v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v7, v6));
    v10 = (unsigned int)&a2[1];
    if ( !v9 )
    {
      if ( !v8 )
      {
        v10 &= 0xFFFFFFF0;
        v11 = 0;
        while ( 1 )
        {
          do
          {
LABEL_12:
            v14 = _mm_load_si128((const __m128i *)v10);
            v4 = _mm_cmpeq_epi8(v4, v14);
            v10 += 16;
            v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v14, v6));
            if ( v9 | _mm_movemask_epi8(v4) )
              break;
            v15 = _mm_load_si128((const __m128i *)v10);
            v4 = _mm_cmpeq_epi8(v4, v15);
            v10 += 16;
            v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v15, v6));
            if ( v9 | _mm_movemask_epi8(v4) )
              break;
            v16 = _mm_load_si128((const __m128i *)v10);
            v4 = _mm_cmpeq_epi8(v4, v16);
            v10 += 16;
            v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v16, v6));
            if ( v9 | _mm_movemask_epi8(v4) )
              break;
            v17 = _mm_load_si128((const __m128i *)v10);
            v4 = _mm_cmpeq_epi8(v4, v17);
            v10 += 16;
            v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v17, v6));
          }
          while ( !(v9 | _mm_movemask_epi8(v4)) );
          if ( !v9 )
            break;
          v19 = _mm_movemask_epi8(v4);
          if ( v19 )
          {
            if ( (_BYTE)v19 )
            {
              if ( (v19 & 0xF) != 0 )
              {
                if ( (v19 & 1) != 0 )
                {
                  v9 &= 1u;
                  if ( v9 )
                    goto LABEL_68;
                }
                else if ( (v19 & 2) != 0 )
                {
                  v9 &= 3u;
                  if ( v9 )
                    goto LABEL_68;
                }
                else if ( (v19 & 4) != 0 )
                {
                  v9 &= 7u;
                  if ( v9 )
                    goto LABEL_68;
                }
                else
                {
                  v9 &= 0xFu;
                  if ( v9 )
                    goto LABEL_68;
                }
              }
              else if ( (v19 & 0x10) != 0 )
              {
                v9 &= 0x1Fu;
                if ( v9 )
                  goto LABEL_68;
              }
              else if ( (v19 & 0x20) != 0 )
              {
                v9 &= 0x3Fu;
                if ( v9 )
                  goto LABEL_68;
              }
              else if ( (v19 & 0x40) != 0 )
              {
                v9 &= 0x7Fu;
                if ( v9 )
                  goto LABEL_68;
              }
              else
              {
                LOWORD(v9) = (unsigned __int8)v9;
                if ( (_BYTE)v9 )
                  goto LABEL_68;
              }
            }
            else if ( (v19 & 0xF00) != 0 )
            {
              if ( (v19 & 0x100) != 0 )
              {
                v9 &= 0x1FFu;
                if ( v9 )
                  goto LABEL_68;
              }
              else if ( (v19 & 0x200) != 0 )
              {
                v9 &= 0x3FFu;
                if ( v9 )
                  goto LABEL_68;
              }
              else if ( (v19 & 0x400) != 0 )
              {
                v9 &= 0x7FFu;
                if ( v9 )
                  goto LABEL_68;
              }
              else
              {
                v9 &= 0xFFFu;
                if ( v9 )
                  goto LABEL_68;
              }
            }
            else if ( (v19 & 0x1000) != 0 )
            {
              v9 &= 0x1FFFu;
              if ( v9 )
                goto LABEL_68;
            }
            else if ( (v19 & 0x2000) != 0 )
            {
              v9 &= 0x3FFFu;
              if ( v9 )
                goto LABEL_68;
            }
            else if ( (v19 & 0x4000) != 0 )
            {
              v9 &= 0x7FFFu;
              if ( v9 )
                goto LABEL_68;
            }
            else if ( (_WORD)v9 )
            {
              goto LABEL_68;
            }
            break;
          }
          v11 = v9;
          a1 = (const __m128i *)v10;
        }
        if ( v11 )
        {
          LOWORD(v9) = v11;
          v10 = (unsigned int)a1;
          goto LABEL_68;
        }
        return 0;
      }
      return 0;
    }
    if ( !v8 )
    {
      v11 = v9;
      a1 = a2 + 1;
      v10 &= 0xFFFFFFF0;
      goto LABEL_12;
    }
  }
  if ( (_BYTE)v8 )
  {
    if ( (v8 & 0xF) != 0 )
    {
      if ( (v8 & 1) != 0 )
      {
        v9 &= 1u;
        if ( !v9 )
          return 0;
      }
      else if ( (v8 & 2) != 0 )
      {
        v9 &= 3u;
        if ( !v9 )
          return 0;
      }
      else if ( (v8 & 4) != 0 )
      {
        v9 &= 7u;
        if ( !v9 )
          return 0;
      }
      else
      {
        v9 &= 0xFu;
        if ( !v9 )
          return 0;
      }
    }
    else if ( (v8 & 0x10) != 0 )
    {
      v9 &= 0x1Fu;
      if ( !v9 )
        return 0;
    }
    else if ( (v8 & 0x20) != 0 )
    {
      v9 &= 0x3Fu;
      if ( !v9 )
        return 0;
    }
    else if ( (v8 & 0x40) != 0 )
    {
      v9 &= 0x7Fu;
      if ( !v9 )
        return 0;
    }
    else
    {
      LOWORD(v9) = (unsigned __int8)v9;
      if ( !(_BYTE)v9 )
        return 0;
    }
  }
  else if ( (v8 & 0xF00) != 0 )
  {
    if ( (v8 & 0x100) != 0 )
    {
      v9 &= 0x1FFu;
      if ( !v9 )
        return 0;
    }
    else if ( (v8 & 0x200) != 0 )
    {
      v9 &= 0x3FFu;
      if ( !v9 )
        return 0;
    }
    else if ( (v8 & 0x400) != 0 )
    {
      v9 &= 0x7FFu;
      if ( !v9 )
        return 0;
    }
    else
    {
      v9 &= 0xFFFu;
      if ( !v9 )
        return 0;
    }
  }
  else if ( (v8 & 0x1000) != 0 )
  {
    v9 &= 0x1FFFu;
    if ( !v9 )
      return 0;
  }
  else if ( (v8 & 0x2000) != 0 )
  {
    v9 &= 0x3FFFu;
    if ( !v9 )
      return 0;
  }
  else if ( (v8 & 0x4000) != 0 )
  {
    v9 &= 0x7FFFu;
    if ( !v9 )
      return 0;
  }
  else if ( !(_WORD)v9 )
  {
    return 0;
  }
LABEL_68:
  if ( BYTE1(v9) )
  {
    if ( (v9 & 0xF000) != 0 )
    {
      if ( (v9 & 0x8000) != 0 )
      {
        return (const __m128i *)(v10 - 1);
      }
      else if ( (v9 & 0x4000) != 0 )
      {
        return (const __m128i *)(v10 - 2);
      }
      else if ( (v9 & 0x2000) != 0 )
      {
        return (const __m128i *)(v10 - 3);
      }
      else
      {
        return (const __m128i *)(v10 - 4);
      }
    }
    else if ( (v9 & 0x800) != 0 )
    {
      return (const __m128i *)(v10 - 5);
    }
    else if ( (v9 & 0x400) != 0 )
    {
      return (const __m128i *)(v10 - 6);
    }
    else if ( (v9 & 0x200) != 0 )
    {
      return (const __m128i *)(v10 - 7);
    }
    else
    {
      return (const __m128i *)(v10 - 8);
    }
  }
  else if ( (v9 & 0xF0) != 0 )
  {
    if ( (v9 & 0x80u) != 0 )
    {
      return (const __m128i *)(v10 - 9);
    }
    else if ( (v9 & 0x40) != 0 )
    {
      return (const __m128i *)(v10 - 10);
    }
    else if ( (v9 & 0x20) != 0 )
    {
      return (const __m128i *)(v10 - 11);
    }
    else
    {
      return (const __m128i *)(v10 - 12);
    }
  }
  else if ( (v9 & 8) != 0 )
  {
    return (const __m128i *)(v10 - 13);
  }
  else if ( (v9 & 4) != 0 )
  {
    return (const __m128i *)(v10 - 14);
  }
  else if ( (v9 & 2) != 0 )
  {
    return (const __m128i *)(v10 - 15);
  }
  else
  {
    return (const __m128i *)(v10 - 16);
  }
}

//----- (0808E830) --------------------------------------------------------
int __usercall _strrchr_sse2_bsf@<eax>(const __m128i *a1@<esi>, const __m128i *a2, unsigned int a3)
{
  __m128i v3; // xmm1
  __m128i v4; // xmm2
  __m128i v5; // xmm1
  __m128i v6; // xmm1
  __m128i v7; // xmm0
  unsigned int v8; // edx
  int v9; // eax
  const __m128i *v10; // edi
  unsigned int v11; // ebx
  unsigned int v12; // ecx
  int v13; // eax
  int v15; // ecx
  unsigned int v16; // edi
  __m128i si128; // xmm0
  unsigned int v18; // edx
  unsigned int v19; // eax
  unsigned int v20; // edi
  unsigned int v21; // ecx
  int v22; // eax
  __m128i v23; // xmm0
  int v24; // eax
  __m128i v25; // xmm0
  __m128i v26; // xmm0
  __m128i v27; // xmm0
  unsigned int v28; // eax
  unsigned int v29; // ecx
  int v30; // eax

  v3 = _mm_cvtsi32_si128(a3);
  v4 = 0LL;
  v5 = _mm_unpacklo_epi8(v3, v3);
  v6 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v5, v5), 0);
  if ( ((unsigned __int8)a2 & 0x3Fu) > 0x30 )
  {
    v15 = (unsigned __int8)a2 & 0xF;
    v16 = (unsigned int)a2 & 0xFFFFFFF0;
    si128 = _mm_load_si128((const __m128i *)((unsigned int)a2 & 0xFFFFFFF0));
    v18 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, si128)) >> v15;
    v19 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(si128, v6)) >> v15;
    if ( v19 )
    {
      if ( !v18 )
      {
        v11 = v19;
        v10 = (const __m128i *)(v16 + 16);
        a1 = (const __m128i *)((char *)v10 + v15);
        goto LABEL_16;
      }
      v20 = v15 + v16;
      _BitScanForward(&v21, v18);
      v22 = ((2 << v21) - 1) & v19;
      if ( v22 )
      {
        _BitScanReverse((unsigned int *)&v22, v22);
        return v20 + v22;
      }
    }
    else if ( !v18 )
    {
      v10 = (const __m128i *)(v16 + 16);
      v11 = 0;
      goto LABEL_16;
    }
    return 0;
  }
  v7 = _mm_loadu_si128(a2);
  v4 = _mm_cmpeq_epi8((__m128i)0LL, v7);
  v8 = _mm_movemask_epi8(v4);
  v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v7, v6));
  if ( v9 )
  {
    if ( !v8 )
    {
      v11 = v9;
      a1 = a2 + 1;
      v10 = (const __m128i *)(((unsigned int)a2 & 0xFFFFFFF0) + 16);
      goto LABEL_16;
    }
    _BitScanForward(&v12, v8);
    v13 = ((2 << v12) - 1) & v9;
    if ( v13 )
    {
      _BitScanReverse((unsigned int *)&v13, v13);
      return (int)a2 + v13;
    }
    return 0;
  }
  if ( v8 )
    return 0;
  v10 = (const __m128i *)(((unsigned int)a2 & 0xFFFFFFF0) + 16);
  v11 = 0;
  while ( 1 )
  {
    do
    {
LABEL_16:
      v23 = _mm_load_si128(v10);
      v4 = _mm_cmpeq_epi8(v4, v23);
      ++v10;
      v24 = _mm_movemask_epi8(_mm_cmpeq_epi8(v23, v6));
      if ( v24 | _mm_movemask_epi8(v4) )
        break;
      v25 = _mm_load_si128(v10);
      v4 = _mm_cmpeq_epi8(v4, v25);
      ++v10;
      v24 = _mm_movemask_epi8(_mm_cmpeq_epi8(v25, v6));
      if ( v24 | _mm_movemask_epi8(v4) )
        break;
      v26 = _mm_load_si128(v10);
      v4 = _mm_cmpeq_epi8(v4, v26);
      ++v10;
      v24 = _mm_movemask_epi8(_mm_cmpeq_epi8(v26, v6));
      if ( v24 | _mm_movemask_epi8(v4) )
        break;
      v27 = _mm_load_si128(v10);
      v4 = _mm_cmpeq_epi8(v4, v27);
      ++v10;
      v24 = _mm_movemask_epi8(_mm_cmpeq_epi8(v27, v6));
    }
    while ( !(v24 | _mm_movemask_epi8(v4)) );
    if ( !v24 )
      break;
    v29 = _mm_movemask_epi8(v4);
    if ( v29 )
    {
      _BitScanForward(&v29, v29);
      v30 = ((2 << v29) - 1) & v24;
      if ( v30 )
      {
        _BitScanReverse((unsigned int *)&v30, v30);
        return (int)&v10[-1] + v30;
      }
      break;
    }
    v11 = v24;
    a1 = v10;
  }
  if ( !v11 )
    return 0;
  _BitScanReverse(&v28, v11);
  return (int)&a1[-1] + v28;
}

//----- (0808EA20) --------------------------------------------------------
int __cdecl _strnlen_sse2(_BYTE *a1, unsigned int a2)
{
  int result; // eax
  unsigned int v3; // edi
  bool v4; // cc
  unsigned int v5; // edi
  unsigned int v6; // edi
  _BYTE *v7; // ecx
  unsigned int v8; // eax
  unsigned int v9; // edi
  unsigned int v10; // edi
  __m128i v11; // xmm0
  int v12; // edx
  __m128i v13; // xmm1
  __m128i v14; // xmm2
  __m128i v15; // xmm3
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm2
  __m128i v19; // xmm3
  __m128i v20; // xmm0
  __m128i v21; // xmm1
  __m128i v22; // xmm2
  __m128i v23; // xmm3
  __m128i v24; // xmm3
  __m128i v25; // xmm1
  __m128i v26; // xmm6
  int v27; // edx
  __m128i v28; // xmm3
  __m128i v29; // xmm3
  __m128i v30; // xmm3
  unsigned int v31; // edi
  __m128i v32; // xmm0
  int v33; // edx
  __m128i *v34; // eax
  __m128i v35; // xmm1
  unsigned int v36; // edi
  unsigned int v37; // edi
  unsigned int v38; // edi

  if ( a2 <= 4 )
  {
    result = 0;
    if ( !a2 || !*a1 )
      return result;
    if ( a2 == 1 || !a1[1] )
      goto LABEL_155;
    if ( a2 != 2 && a1[2] )
    {
      if ( a2 != 3 && a1[3] )
        return 4;
      return 3;
    }
LABEL_156:
    result += 2;
    return result;
  }
  result = 0;
  if ( !*a1 )
    return result;
  if ( !a1[1] )
    goto LABEL_155;
  if ( !a1[2] )
    goto LABEL_156;
  if ( !a1[3] )
    return 3;
  v3 = a2 - 8;
  if ( a2 - 4 <= 4 )
  {
    v36 = v3 + 4;
    if ( !a1[4] )
      goto LABEL_158;
    if ( v36 == 1 || !a1[5] )
      goto LABEL_159;
    if ( v36 != 2 && a1[6] )
    {
      if ( v36 != 3 && a1[7] )
        return 8;
      return 7;
    }
LABEL_160:
    result += 6;
    return result;
  }
  if ( !a1[4] )
    goto LABEL_158;
  if ( !a1[5] )
    goto LABEL_159;
  if ( !a1[6] )
    goto LABEL_160;
  if ( !a1[7] )
    return 7;
  v4 = v3 <= 4;
  v5 = a2 - 12;
  if ( v4 )
  {
    v37 = v5 + 4;
    if ( !a1[8] )
      goto LABEL_162;
    if ( v37 == 1 || !a1[9] )
      goto LABEL_163;
    if ( v37 != 2 && a1[10] )
    {
      if ( v37 != 3 && a1[11] )
        return 12;
      return 11;
    }
LABEL_164:
    result += 10;
    return result;
  }
  if ( !a1[8] )
    goto LABEL_162;
  if ( !a1[9] )
    goto LABEL_163;
  if ( !a1[10] )
    goto LABEL_164;
  if ( !a1[11] )
    return 11;
  v4 = v5 <= 4;
  v6 = a2 - 16;
  if ( v4 )
  {
    v38 = v6 + 4;
    if ( !a1[12] )
      goto LABEL_166;
    if ( v38 == 1 || !a1[13] )
      goto LABEL_167;
    if ( v38 == 2 || !a1[14] )
      goto LABEL_168;
    if ( v38 != 3 && a1[15] )
      return 16;
    return 15;
  }
  if ( !a1[12] )
    goto LABEL_166;
  if ( !a1[13] )
    goto LABEL_167;
  if ( !a1[14] )
    goto LABEL_168;
  if ( !a1[15] )
    return 15;
  v7 = a1 + 16;
  v8 = (unsigned int)(a1 + 16) & 0xFFFFFFF0;
  v9 = ((unsigned __int8)a1 & 0xF) + v6;
  v4 = v9 <= 0x40;
  v10 = v9 - 64;
  if ( v4 )
    goto LABEL_68;
  v11 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v11);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v13 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v13);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v14 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v14);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v15 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v15);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v4 = v10 <= 0x40;
  v10 -= 64;
  if ( v4 )
    goto LABEL_68;
  v16 = _mm_cmpeq_epi8(v11, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v16);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v17 = _mm_cmpeq_epi8(v13, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v17);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v18 = _mm_cmpeq_epi8(v14, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v18);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v19 = _mm_cmpeq_epi8(v15, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v19);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v4 = v10 <= 0x40;
  v10 -= 64;
  if ( v4 )
    goto LABEL_68;
  v20 = _mm_cmpeq_epi8(v16, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v20);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v21 = _mm_cmpeq_epi8(v17, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v21);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v22 = _mm_cmpeq_epi8(v18, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v22);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v23 = _mm_cmpeq_epi8(v19, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v23);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v4 = v10 <= 0x40;
  v10 -= 64;
  if ( v4 )
    goto LABEL_68;
  v12 = _mm_movemask_epi8(_mm_cmpeq_epi8(v20, *(__m128i *)v8));
  v8 += 16;
  if ( v12
    || (v12 = _mm_movemask_epi8(_mm_cmpeq_epi8(v21, *(__m128i *)v8)), v8 += 16, v12)
    || (v12 = _mm_movemask_epi8(_mm_cmpeq_epi8(v22, *(__m128i *)v8)), v8 += 16, v12)
    || (v24 = _mm_cmpeq_epi8(v23, *(__m128i *)v8), v12 = _mm_movemask_epi8(v24), v8 += 16, v12) )
  {
LABEL_48:
    result = v8 - (_DWORD)v7;
    if ( (_BYTE)v12 )
    {
      if ( (v12 & 0xF) != 0 )
      {
        if ( (v12 & 1) != 0 )
          return result;
        if ( (v12 & 2) == 0 )
        {
          if ( (v12 & 4) == 0 )
          {
            result += 3;
            return result;
          }
          goto LABEL_156;
        }
LABEL_155:
        ++result;
        return result;
      }
      if ( (v12 & 0x10) == 0 )
      {
        if ( (v12 & 0x20) == 0 )
        {
          if ( (v12 & 0x40) == 0 )
          {
            result += 7;
            return result;
          }
          goto LABEL_160;
        }
LABEL_159:
        result += 5;
        return result;
      }
LABEL_158:
      result += 4;
      return result;
    }
    if ( (v12 & 0xF00) != 0 )
    {
      if ( (v12 & 0x100) == 0 )
      {
        if ( (v12 & 0x200) == 0 )
        {
          if ( (v12 & 0x400) == 0 )
          {
            result += 11;
            return result;
          }
          goto LABEL_164;
        }
LABEL_163:
        result += 9;
        return result;
      }
LABEL_162:
      result += 8;
      return result;
    }
    if ( (v12 & 0x1000) == 0 )
    {
      if ( (v12 & 0x2000) == 0 )
      {
        if ( (v12 & 0x4000) == 0 )
        {
          result += 15;
          return result;
        }
LABEL_168:
        result += 14;
        return result;
      }
LABEL_167:
      result += 13;
      return result;
    }
LABEL_166:
    result += 12;
    return result;
  }
  v10 += v8 & 0x3F;
  v8 &= 0xFFFFFFC0;
  while ( 1 )
  {
    v4 = v10 <= 0x40;
    v10 -= 64;
    if ( v4 )
      break;
    v25 = *(__m128i *)(v8 + 16);
    v26 = *(__m128i *)(v8 + 48);
    v27 = _mm_movemask_epi8(
            _mm_cmpeq_epi8(
              _mm_min_epu8(_mm_min_epu8(*(__m128i *)(v8 + 32), v26), _mm_min_epu8(*(__m128i *)v8, v25)),
              v24));
    v8 += 64;
    if ( v27 )
    {
      v28 = _mm_cmpeq_epi8(v24, *(__m128i *)(v8 - 64));
      v12 = _mm_movemask_epi8(v28);
      v7 = a1 + 64;
      if ( !v12 )
      {
        v29 = _mm_cmpeq_epi8(v28, v25);
        v12 = _mm_movemask_epi8(v29);
        v7 = a1 + 48;
        if ( !v12 )
        {
          v30 = _mm_cmpeq_epi8(v29, *(__m128i *)(v8 - 32));
          v12 = _mm_movemask_epi8(v30);
          v7 = a1 + 32;
          if ( !v12 )
          {
            LOWORD(v12) = _mm_movemask_epi8(_mm_cmpeq_epi8(v30, v26));
            v7 = a1 + 16;
          }
        }
      }
      goto LABEL_48;
    }
  }
LABEL_68:
  v31 = v10 + 64;
  v32 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v8);
  v33 = _mm_movemask_epi8(v32);
  v34 = (__m128i *)(v8 + 16);
  if ( v33 )
    goto LABEL_76;
  v4 = v31 <= 0x10;
  v31 -= 16;
  if ( v4 )
    return a2;
  v35 = _mm_cmpeq_epi8((__m128i)0LL, *v34);
  v33 = _mm_movemask_epi8(v35);
  ++v34;
  if ( v33 )
    goto LABEL_76;
  v4 = v31 <= 0x10;
  v31 -= 16;
  if ( v4 )
    return a2;
  v33 = _mm_movemask_epi8(_mm_cmpeq_epi8(v32, *v34++));
  if ( v33 )
    goto LABEL_76;
  v4 = v31 <= 0x10;
  v31 -= 16;
  if ( v4 )
    return a2;
  v33 = _mm_movemask_epi8(_mm_cmpeq_epi8(v35, *v34++));
  if ( !v33 )
    return a2;
LABEL_76:
  result = (char *)v34 - v7;
  if ( !(_BYTE)v33 )
  {
    if ( (v33 & 0xF00) != 0 )
    {
      if ( (v33 & 0x100) != 0 )
      {
        if ( v31 >= 9 )
        {
          result += 8;
          return result;
        }
      }
      else if ( (v33 & 0x200) != 0 )
      {
        if ( v31 >= 0xA )
        {
          result += 9;
          return result;
        }
      }
      else if ( (v33 & 0x400) != 0 )
      {
        if ( v31 >= 0xB )
        {
          result += 10;
          return result;
        }
      }
      else if ( v31 >= 0xC )
      {
        result += 11;
        return result;
      }
    }
    else if ( (v33 & 0x1000) != 0 )
    {
      if ( v31 >= 0xD )
      {
        result += 12;
        return result;
      }
    }
    else if ( (v33 & 0x2000) != 0 )
    {
      if ( v31 >= 0xE )
      {
        result += 13;
        return result;
      }
    }
    else if ( (v33 & 0x4000) != 0 )
    {
      if ( v31 >= 0xF )
      {
        result += 14;
        return result;
      }
    }
    else if ( v31 >= 0x10 )
    {
      result += 15;
      return result;
    }
    return a2;
  }
  if ( (v33 & 0xF) == 0 )
  {
    if ( (v33 & 0x10) != 0 )
    {
      if ( v31 >= 5 )
      {
        result += 4;
        return result;
      }
    }
    else if ( (v33 & 0x20) != 0 )
    {
      if ( v31 >= 6 )
      {
        result += 5;
        return result;
      }
    }
    else if ( (v33 & 0x40) != 0 )
    {
      if ( v31 >= 7 )
      {
        result += 6;
        return result;
      }
    }
    else if ( v31 >= 8 )
    {
      result += 7;
      return result;
    }
    return a2;
  }
  if ( (v33 & 1) == 0 )
  {
    if ( (v33 & 2) != 0 )
    {
      if ( v31 >= 2 )
      {
        ++result;
        return result;
      }
    }
    else if ( (v33 & 4) != 0 )
    {
      if ( v31 >= 3 )
      {
        result += 2;
        return result;
      }
    }
    else if ( v31 >= 4 )
    {
      result += 3;
      return result;
    }
    return a2;
  }
  return result;
}

//----- (0808F110) --------------------------------------------------------
int __cdecl _strnlen_ia32(_BYTE *a1, int a2)
{
  int result; // eax
  unsigned int v3; // esi
  _BYTE *v4; // eax
  _BYTE *v5; // edx

  result = 0;
  if ( !a2 )
    return result;
  v3 = (unsigned int)&a1[a2];
  if ( __CFADD__(a1, a2) )
    v3 = -1;
  v4 = a1;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( !*a1 )
    {
LABEL_21:
      if ( v3 <= (unsigned int)v4 )
        v4 = (_BYTE *)v3;
      return v4 - a1;
    }
    while ( ((unsigned __int8)++v4 & 3) != 0 )
    {
      if ( !*v4 )
        goto LABEL_21;
    }
  }
  if ( v3 > (unsigned int)v4 )
  {
    while ( 1 )
    {
      v5 = v4 + 4;
      if ( ((*(_DWORD *)v4 - 16843009) & 0x80808080) != 0 )
      {
        if ( !*v4 )
          goto LABEL_17;
        if ( !v4[1] )
        {
          ++v4;
          goto LABEL_17;
        }
        if ( !v4[2] )
        {
          v4 += 2;
          goto LABEL_17;
        }
        if ( !v4[3] )
          break;
      }
      v4 += 4;
      if ( v3 <= (unsigned int)v5 )
      {
        v4 = (_BYTE *)v3;
        goto LABEL_17;
      }
    }
    v4 += 3;
  }
LABEL_17:
  if ( (unsigned int)v4 > v3 )
    v4 = (_BYTE *)v3;
  return v4 - a1;
}

//----- (0808F1B0) --------------------------------------------------------
int __cdecl _strcasecmp_nonascii(char *a1, unsigned __int8 *a2)
{
  char *v2; // ecx
  unsigned __int8 *v3; // edx
  unsigned int v4; // eax
  char v5; // di
  int v6; // esi

  v2 = a1;
  v3 = a2;
  v4 = __readgsdword(0xFFFFFFDC);
  if ( a1 == (char *)a2 )
    return 0;
  do
  {
    v5 = *v2;
    v6 = *(_DWORD *)(*(_DWORD *)(v4 + 56) + 4 * (unsigned __int8)*v2) - *(_DWORD *)(*(_DWORD *)(v4 + 56) + 4 * *v3++);
    if ( v6 )
      break;
    ++v2;
  }
  while ( v5 );
  return v6;
}

//----- (0808F200) --------------------------------------------------------
int (__cdecl *wcslen())(_DWORD *a1)
{
  int (__cdecl *result)(_DWORD *); // eax

  result = _wcslen_ia32;
  if ( (unk_80EC574 & 0x4000000) != 0 )
    return (int (__cdecl *)(_DWORD *))_wcslen_sse2;
  return result;
}

//----- (0808F220) --------------------------------------------------------
_BYTE *__cdecl wmemcpy(_BYTE *a1, _BYTE *a2, int a3)
{
  return memcpy(a1, a2, 4 * a3);
}

//----- (0808F230) --------------------------------------------------------
int __cdecl wmemmove(int a1, int a2, int a3)
{
  return j_memmove(a1, a2, 4 * a3);
}
// 80481D0: using guessed type int __cdecl j_memmove(_DWORD, _DWORD, _DWORD);

//----- (0808F240) --------------------------------------------------------
_DWORD *__cdecl wmemset(_DWORD *a1, int a2, unsigned int a3)
{
  int v3; // esi
  _DWORD *result; // eax
  _DWORD *v5; // edx
  unsigned int v6; // ebx

  v3 = a3;
  result = a1;
  v5 = a1;
  if ( a3 > 3 )
  {
    v6 = a3;
    do
    {
      v6 -= 4;
      *v5 = a2;
      v5[1] = a2;
      v5[2] = a2;
      v5[3] = a2;
      v5 += 4;
    }
    while ( v6 > 3 );
    v3 = a3 & 3;
    v5 = &a1[4 * ((a3 - 4) >> 2) + 4];
  }
  if ( v3 )
  {
    *v5 = a2;
    if ( v3 != 1 )
    {
      v5[1] = a2;
      if ( v3 == 3 )
        v5[2] = a2;
    }
  }
  return result;
}

//----- (0808F2A0) --------------------------------------------------------
int __cdecl btowc(int a1)
{
  int result; // eax
  _DWORD **v2; // eax
  int v3; // esi
  void **v4; // edi
  int (__cdecl *v5)(void *, _DWORD); // esi
  int (__cdecl *v6)(void *, int *, char **, char *, _DWORD, char *, _DWORD, int); // ebx
  int v7; // edx
  char v8; // [esp+3h] [ebp-39h] BYREF
  int v9; // [esp+4h] [ebp-38h] BYREF
  char *v10; // [esp+8h] [ebp-34h] BYREF
  char v11[4]; // [esp+Ch] [ebp-30h] BYREF
  int v12[6]; // [esp+10h] [ebp-2Ch] BYREF
  int v13[5]; // [esp+28h] [ebp-14h] BYREF

  if ( (unsigned int)(a1 + 128) > 0x17F || a1 == -1 )
    return -1;
  result = a1;
  if ( (a1 & 0xFFFFFF80) != 0 )
  {
    v2 = (_DWORD **)__readgsdword(0xFFFFFFD8);
    v3 = (int)*v2;
    v4 = (void **)(*v2)[5];
    if ( !v4 )
    {
      if ( (void **)v3 == &nl_C_LC_CTYPE )
      {
        v4 = &_wcsmbs_gconv_fcts_c;
      }
      else
      {
        _wcsmbs_load_conv(*v2);
        v4 = *(void ***)(v3 + 20);
      }
    }
    v5 = (int (__cdecl *)(void *, _DWORD))*((_DWORD *)*v4 + 6);
    if ( v4[1] == (void *)1 && v5 )
    {
      if ( *(_DWORD *)*v4 )
        v5 = (int (__cdecl *)(void *, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v5, 9));
      dl_mcount_wrapper_check((int)v5);
      return v5(*v4, (unsigned __int8)a1);
    }
    else
    {
      v13[0] = 0;
      v13[1] = 0;
      v8 = a1;
      v12[3] = 0;
      v10 = &v8;
      v12[4] = 1;
      v12[1] = (int)&v10;
      v12[2] = 1;
      v12[0] = (int)&v9;
      v12[5] = (int)v13;
      v6 = (int (__cdecl *)(void *, int *, char **, char *, _DWORD, char *, _DWORD, int))*((_DWORD *)*v4 + 5);
      if ( *(_DWORD *)*v4 )
        v6 = (int (__cdecl *)(void *, int *, char **, char *, _DWORD, char *, _DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v6, 9));
      dl_mcount_wrapper_check((int)v6);
      v7 = v6(*v4, v12, &v10, v10 + 1, 0, v11, 0, 1);
      if ( (unsigned int)(v7 - 4) <= 1 )
        return v9;
      result = -1;
      if ( !v7 )
        return v9;
    }
  }
  return result;
}
// 80BE940: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80C0B60: using guessed type void *nl_C_LC_CTYPE;
// 808F2A0: using guessed type char var_30[4];

//----- (0808F410) --------------------------------------------------------
int __cdecl wcrtomb(char *a1, int a2, void *a3)
{
  void *v3; // eax
  char *v4; // esi
  unsigned int v5; // eax
  void **v6; // ebx
  void **v7; // edi
  _DWORD *v8; // eax
  int (__cdecl *v9)(void *, int *, int **, void **, _DWORD, char *, int, int); // ebx
  int v10; // eax
  _BYTE *v11; // edx
  char v13[4]; // [esp+8h] [ebp-44h] BYREF
  int *v14; // [esp+Ch] [ebp-40h] BYREF
  char v15; // [esp+10h] [ebp-3Ch] BYREF
  int v16[11]; // [esp+20h] [ebp-2Ch] BYREF

  v3 = a3;
  v4 = a1;
  v16[3] = 0;
  v16[4] = 1;
  v16[2] = 1;
  if ( !a3 )
    v3 = &state;
  v16[5] = (int)v3;
  if ( !a1 )
  {
    a2 = 0;
    v4 = &v15;
  }
  v16[0] = (int)v4;
  v5 = __readgsdword(0xFFFFFFD8);
  v6 = *(void ***)v5;
  v7 = *(void ***)(*(_DWORD *)v5 + 20);
  v16[1] = (int)&v4[*(_DWORD *)(*(_DWORD *)v5 + 88)];
  if ( !v7 )
  {
    if ( v6 == &nl_C_LC_CTYPE )
    {
      v7 = &_wcsmbs_gconv_fcts_c;
    }
    else
    {
      _wcsmbs_load_conv(v6);
      v7 = (void **)v6[5];
    }
  }
  v8 = v7[2];
  v9 = (int (__cdecl *)(void *, int *, int **, void **, _DWORD, char *, int, int))v8[5];
  if ( *v8 )
    v9 = (int (__cdecl *)(void *, int *, int **, void **, _DWORD, char *, int, int))(__readgsdword(0x18u) ^ __ROR4__(v9, 9));
  if ( a2 )
  {
    v14 = &a2;
    dl_mcount_wrapper_check((int)v9);
    v10 = v9(v7[2], v16, &v14, &a3, 0, v13, 0, 1);
    if ( (v10 & 0xFFFFFFFB) == 0 )
      goto LABEL_11;
  }
  else
  {
    dl_mcount_wrapper_check((int)v9);
    v10 = v9(v7[2], v16, 0, 0, 0, v13, 1, 1);
    if ( (v10 & 0xFFFFFFFB) == 0 )
    {
      v11 = (_BYTE *)v16[0]++;
      *v11 = 0;
      goto LABEL_11;
    }
  }
  if ( (unsigned int)(v10 - 5) > 2 )
    _assert_fail(
      "status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __GCONV_INCO"
      "MPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
      "wcrtomb.c",
      101,
      "__wcrtomb");
LABEL_11:
  if ( (unsigned int)(v10 - 4) <= 1 || !v10 )
    return v16[0] - (_DWORD)v4;
  __writegsdword(0xFFFFFFE8, 0x54u);
  return -1;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80BE940: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80C0B60: using guessed type void *nl_C_LC_CTYPE;
// 808F410: using guessed type char var_44[4];

//----- (0808F5A0) --------------------------------------------------------
int __cdecl mbsrtowcs(int a1, _BYTE **a2, int a3, void *a4)
{
  void *v4; // eax

  v4 = a4;
  if ( !a4 )
    v4 = &state_0;
  return _mbsrtowcs_l(a1, a2, a3, (int)v4, (_DWORD **)__readgsdword(0xFFFFFFDC));
}

//----- (0808F5D0) --------------------------------------------------------
int __cdecl wcsrtombs(int a1, int *a2, int a3, int *a4)
{
  int *v4; // eax
  unsigned int v5; // eax
  void **v6; // ebx
  void **v7; // eax
  _DWORD *v8; // ebp
  int (__cdecl *v9)(_DWORD *, char **, int *, int, _DWORD, char *, _DWORD, int); // ebx
  _DWORD *v10; // edi
  int v11; // eax
  int v12; // eax
  int v13; // edi
  bool v14; // dl
  unsigned int v15; // eax
  bool v16; // cf
  int v18; // eax
  int v19; // edx
  int v20; // [esp+1Ch] [ebp-150h]
  int v21; // [esp+1Ch] [ebp-150h]
  int v22; // [esp+20h] [ebp-14Ch] BYREF
  char v23[4]; // [esp+24h] [ebp-148h] BYREF
  int v24[2]; // [esp+28h] [ebp-144h] BYREF
  char *v25; // [esp+30h] [ebp-13Ch] BYREF
  char *v26; // [esp+34h] [ebp-138h]
  int v27; // [esp+38h] [ebp-134h]
  int v28; // [esp+3Ch] [ebp-130h]
  int v29; // [esp+40h] [ebp-12Ch]
  int *v30; // [esp+44h] [ebp-128h]
  char v31[256]; // [esp+50h] [ebp-11Ch] BYREF
  char v32; // [esp+150h] [ebp-1Ch] BYREF

  v4 = a4;
  v28 = 0;
  v29 = 1;
  v27 = 1;
  if ( !a4 )
    v4 = (int *)&state_1;
  v30 = v4;
  v5 = __readgsdword(0xFFFFFFD8);
  v6 = *(void ***)v5;
  v7 = *(void ***)(*(_DWORD *)v5 + 20);
  if ( !v7 )
  {
    if ( v6 == &nl_C_LC_CTYPE )
    {
      v7 = &_wcsmbs_gconv_fcts_c;
    }
    else
    {
      _wcsmbs_load_conv(v6);
      v7 = (void **)v6[5];
    }
  }
  v8 = v7[2];
  v9 = (int (__cdecl *)(_DWORD *, char **, int *, int, _DWORD, char *, _DWORD, int))v8[5];
  if ( *v8 )
    v9 = (int (__cdecl *)(_DWORD *, char **, int *, int, _DWORD, char *, _DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v9, 9));
  if ( a1 )
  {
    v10 = (_DWORD *)*a2;
    v11 = wcsnlen((_DWORD *)*a2, a3);
    v25 = (char *)a1;
    v20 = (int)&v10[v11 + 1];
    v26 = (char *)(a1 + a3);
    dl_mcount_wrapper_check((int)v9);
    v12 = v9(v8, &v25, a2, v20, 0, v31, 0, 1);
    v13 = (int)&v25[-a1];
    if ( (v12 & 0xFFFFFFFB) == 0 && !*(v25 - 1) )
    {
      if ( (char *)a1 == v25 )
        _assert_fail("data.__outbuf != (unsigned char *) dst", "wcsrtombs.c", 122, "__wcsrtombs");
      if ( *v30 )
        _assert_fail("__mbsinit (data.__statep)", "wcsrtombs.c", 123, "__wcsrtombs");
      *a2 = 0;
LABEL_19:
      --v13;
    }
  }
  else
  {
    v13 = 0;
    v18 = *a2 + 4 * j_wcslen(*a2) + 4;
    v22 = *a2;
    v21 = v18;
    v19 = v30[1];
    v24[0] = *v30;
    v24[1] = v19;
    v30 = v24;
    v26 = &v32;
    do
    {
      v25 = v31;
      dl_mcount_wrapper_check((int)v9);
      v12 = v9(v8, &v25, &v22, v21, 0, v23, 0, 1);
      v13 += v25 - v31;
    }
    while ( v12 == 5 );
    if ( (v12 & 0xFFFFFFFB) == 0 )
    {
      if ( *(v25 - 1) )
        _assert_fail("data.__outbuf[-1] == '\\0'", "wcsrtombs.c", 94, "__wcsrtombs");
      goto LABEL_19;
    }
  }
  v14 = v12 != 0;
  v16 = v12 == 4;
  v15 = v12 - 4;
  if ( v15 <= 3 )
  {
    if ( v14 && !v16 && v15 != 1 )
    {
      v13 = -1;
      __writegsdword(0xFFFFFFE8, 0x54u);
    }
  }
  else if ( v14 )
  {
    _assert_fail(
      "status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __GCONV_INCO"
      "MPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
      "wcsrtombs.c",
      134,
      "__wcsrtombs");
  }
  return v13;
}
// 80481F0: using guessed type int __cdecl j_wcslen(_DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80BE940: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80C0B60: using guessed type void *nl_C_LC_CTYPE;
// 808F5D0: using guessed type char var_148[4];

//----- (0808F850) --------------------------------------------------------
int __cdecl wcsnlen(_DWORD *a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int result; // eax

  v2 = a2;
  if ( !a2 || !*a1 )
    return 0;
  if ( a2 == 1 || !a1[1] )
    return 1;
  if ( a2 == 2 )
    return 2;
  v3 = 2;
  do
  {
    if ( !a1[v3] )
      break;
    result = v3 + 1;
    if ( v2 == 3 )
      return result;
    if ( !a1[v3 + 1] )
      return result;
    v2 -= 4;
    result = v3 + 2;
    if ( !v2 )
      return result;
    if ( !a1[v3 + 2] )
      return result;
    result = v3 + 3;
    if ( v2 == 1 || !a1[v3 + 3] )
      return result;
    v3 += 4;
  }
  while ( v2 != 2 );
  return v3;
}

//----- (0808F8E0) --------------------------------------------------------
int *__cdecl wcschrnul(int *a1, int a2)
{
  int *result; // eax
  int i; // edx

  result = a1;
  for ( i = *a1; *result != a2; i = *result )
  {
    if ( !i )
      break;
    ++result;
  }
  return result;
}

//----- (0808F900) --------------------------------------------------------
int __cdecl _mbsrtowcs_l(int a1, _BYTE **a2, int a3, int a4, _DWORD **a5)
{
  int v5; // ebx
  int v6; // esi
  void **v7; // eax
  int (__cdecl *v8)(void *, int **, _BYTE **, _BYTE *, _DWORD, char *, _DWORD, int); // edi
  _BYTE *v9; // esi
  int v10; // eax
  char v11; // dl
  int v12; // ebp
  bool v13; // cl
  int v14; // ebp
  int v15; // ebx
  int v17; // edx
  int v18; // eax
  void *v19; // [esp+10h] [ebp-15Ch]
  _BYTE *v20; // [esp+1Ch] [ebp-150h]
  char v21[4]; // [esp+20h] [ebp-14Ch] BYREF
  _BYTE *v22; // [esp+24h] [ebp-148h] BYREF
  int v23[2]; // [esp+28h] [ebp-144h] BYREF
  int *v24; // [esp+30h] [ebp-13Ch] BYREF
  char *v25; // [esp+34h] [ebp-138h]
  int v26; // [esp+38h] [ebp-134h]
  int v27; // [esp+3Ch] [ebp-130h]
  int v28; // [esp+40h] [ebp-12Ch]
  int *v29; // [esp+44h] [ebp-128h]
  int v30[64]; // [esp+50h] [ebp-11Ch] BYREF
  char v31; // [esp+150h] [ebp-1Ch] BYREF

  v5 = a3;
  v27 = 0;
  v28 = 1;
  v26 = 1;
  v29 = (int *)a4;
  v6 = (int)*a5;
  v7 = (void **)(*a5)[5];
  if ( !v7 )
  {
    if ( (void **)v6 == &nl_C_LC_CTYPE )
    {
      v7 = &_wcsmbs_gconv_fcts_c;
    }
    else
    {
      _wcsmbs_load_conv(*a5);
      v7 = *(void ***)(v6 + 20);
    }
  }
  v19 = *v7;
  v8 = (int (__cdecl *)(void *, int **, _BYTE **, _BYTE *, _DWORD, char *, _DWORD, int))*((_DWORD *)*v7 + 5);
  if ( *(_DWORD *)*v7 )
    v8 = (int (__cdecl *)(void *, int **, _BYTE **, _BYTE *, _DWORD, char *, _DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v8, 9));
  if ( !a1 )
  {
    v22 = *a2;
    v15 = 0;
    v20 = &v22[strlen(v22) + 1];
    v17 = v29[1];
    v18 = *v29;
    v25 = &v31;
    v23[0] = v18;
    v23[1] = v17;
    v29 = v23;
    do
    {
      v24 = v30;
      dl_mcount_wrapper_check((int)v8);
      v10 = v8(v19, &v24, &v22, v20, 0, v21, 0, 1);
      v15 += v24 - v30;
    }
    while ( v10 == 5 );
    if ( (v10 & 0xFFFFFFFB) == 0 )
    {
      if ( *(v24 - 1) )
        _assert_fail("((wchar_t *) data.__outbuf)[-1] == L'\\0'", "mbsrtowcs_l.c", 94, "__mbsrtowcs_l");
      --v15;
    }
    v11 = (v10 & 0xFFFFFFFB) != 0;
    v13 = v10 != 0;
    goto LABEL_18;
  }
  v9 = *a2;
  v24 = (int *)a1;
  v30[0] = (int)v9;
  v25 = (char *)(a1 + 4 * a3);
  if ( a3 )
  {
    while ( 1 )
    {
      v9 += j_strnlen(v9, v5) + 1;
      dl_mcount_wrapper_check((int)v8);
      v10 = v8(v19, &v24, (_BYTE **)v30, v9, 0, v21, 0, 1);
      v11 = v10 != 4;
      if ( v10 != 4 && v10 != 7 )
        break;
      if ( v9 == (_BYTE *)v30[0] )
      {
        if ( *(_BYTE *)(v30[0] - 1) )
        {
          v5 = (v25 - (char *)v24) >> 2;
          if ( v5 )
            continue;
        }
      }
      goto LABEL_12;
    }
    v11 = v10 != 4 && v10 != 7;
LABEL_12:
    v12 = (int)v24 - a1;
    *a2 = (_BYTE *)v30[0];
    v13 = 1;
    v14 = v12 >> 2;
    v15 = v14;
    if ( (v10 & 0xFFFFFFFB) == 0 )
    {
      if ( !*(_DWORD *)(a1 + 4 * v14 - 4) )
      {
        if ( !v14 )
          _assert_fail("result > 0", "mbsrtowcs_l.c", 141, "__mbsrtowcs_l");
        if ( *v29 )
          _assert_fail("__mbsinit (data.__statep)", "mbsrtowcs_l.c", 142, "__mbsrtowcs_l");
        v15 = v14 - 1;
        *a2 = 0;
      }
      v13 = v10 != 0;
      v11 &= v10 != 0;
    }
LABEL_18:
    if ( !v11 )
      goto LABEL_20;
    goto LABEL_19;
  }
  v15 = 0;
  v13 = 1;
  v10 = 5;
LABEL_19:
  if ( (unsigned int)(v10 - 5) > 2 )
    _assert_fail(
      "status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __GCONV_INCO"
      "MPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
      "mbsrtowcs_l.c",
      153,
      "__mbsrtowcs_l");
LABEL_20:
  if ( (v10 & 0xFFFFFFFD) != 5 && v13 && v10 != 4 )
  {
    v15 = -1;
    __writegsdword(0xFFFFFFE8, 0x54u);
  }
  return v15;
}
// 80481C0: using guessed type int __cdecl j_strnlen(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80BE940: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80C0B60: using guessed type void *nl_C_LC_CTYPE;
// 808F900: using guessed type char var_14C[4];

//----- (0808FC10) --------------------------------------------------------
unsigned int __cdecl _wcslen_sse2(_DWORD *a1)
{
  char *v1; // ecx
  __m128i *v2; // eax
  int v3; // edx
  __m128i *v4; // eax
  __m128i v5; // xmm3
  __m128i v6; // xmm1
  __m128i v7; // xmm6
  int v8; // edx
  __m128i v9; // xmm3
  __m128i v10; // xmm3
  __m128i v11; // xmm3
  unsigned int result; // eax

  if ( !*a1 )
    return 0;
  if ( !a1[1] )
    return 1;
  if ( !a1[2] )
    return 2;
  if ( !a1[3] )
    return 3;
  if ( !a1[4] )
    return 4;
  if ( !a1[5] )
    return 5;
  if ( !a1[6] )
    return 6;
  if ( !a1[7] )
    return 7;
  v1 = (char *)(a1 + 4);
  v2 = (__m128i *)((unsigned int)(a1 + 8) & 0xFFFFFFF0);
  v3 = _mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *v2));
  v4 = v2 + 1;
  if ( !v3 )
  {
    v3 = _mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *v4++));
    if ( !v3 )
    {
      v3 = _mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *v4++));
      if ( !v3 )
      {
        v5 = _mm_cmpeq_epi32((__m128i)0LL, *v4);
        v3 = _mm_movemask_epi8(v5);
        ++v4;
        if ( !v3 )
        {
          v4 = (__m128i *)((unsigned int)v4 & 0xFFFFFFC0);
          do
          {
            do
            {
              v6 = v4[1];
              v7 = v4[3];
              v8 = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_min_epu8(_mm_min_epu8(v4[2], v7), _mm_min_epu8(*v4, v6)), v5));
              v4 += 4;
            }
            while ( !v8 );
            v9 = _mm_cmpeq_epi32(v5, v4[-4]);
            v3 = _mm_movemask_epi8(v9);
            v1 += 48;
            if ( v3 )
              break;
            v10 = _mm_cmpeq_epi32(v9, v6);
            v3 = _mm_movemask_epi8(v10);
            v1 -= 16;
            if ( v3 )
              break;
            v11 = _mm_cmpeq_epi32(v10, v4[-2]);
            v3 = _mm_movemask_epi8(v11);
            v1 -= 16;
            if ( v3 )
              break;
            v5 = _mm_cmpeq_epi32(v11, v7);
            v3 = _mm_movemask_epi8(v5);
            v1 -= 16;
          }
          while ( !v3 );
        }
      }
    }
  }
  result = (unsigned int)((char *)v4 - v1) >> 2;
  if ( (_BYTE)v3 )
  {
    if ( (v3 & 0xF) == 0 )
      ++result;
  }
  else if ( (v3 & 0xF00) != 0 )
  {
    result += 2;
  }
  else
  {
    result += 3;
  }
  return result;
}

//----- (0808FE10) --------------------------------------------------------
int __cdecl _wcslen_ia32(_DWORD *a1)
{
  int i; // edx
  int result; // eax
  int v3; // edx

  if ( !*a1 )
    return 0;
  if ( !a1[1] )
    return 1;
  if ( !a1[2] )
    return 2;
  for ( i = 0; ; i = result )
  {
    result = i + 3;
    if ( !a1[i + 3] )
      break;
    result = i + 4;
    if ( !a1[i + 4] )
      break;
    if ( !a1[result + 1] )
      return i + 5;
    v3 = i + 6;
    if ( !a1[result + 2] )
      return v3;
  }
  return result;
}

//----- (0808FE80) --------------------------------------------------------
__int64 __fastcall time(int a1)
{
  return dl_sysinfo(a1);
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0808FEA0) --------------------------------------------------------
unsigned int __usercall compute_offset@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>)
{
  int v3; // ecx
  unsigned int v4; // eax

  if ( a3 > 0x18 )
    a3 = 24;
  v3 = 3600 * a3;
  if ( a1 > 0x3B )
    a1 = 59;
  v4 = v3 + a1;
  if ( a2 > 0x3B )
    a2 = 59;
  return 60 * a2 + v4;
}

//----- (0808FED0) --------------------------------------------------------
int __usercall compute_change@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx
  int v4; // esi
  bool v5; // cf
  int v6; // eax
  _BOOL4 v7; // ebp
  int v8; // edx
  int v9; // kr00_4
  int v10; // esi
  int v11; // eax
  bool v12; // sf
  int v13; // edx
  unsigned int v14; // esi
  int v15; // eax
  int v16; // edx
  int v17; // edi
  int v18; // esi
  int v19; // esi
  int v20; // edx
  int v21; // [esp+0h] [ebp-2Ch]
  int v22; // [esp+18h] [ebp-14h]

  v2 = result;
  if ( a2 == -1 )
  {
    result = *(_DWORD *)(result + 4);
    v4 = 0;
    v5 = result == 0;
    if ( result != 1 )
      goto LABEL_6;
LABEL_22:
    v20 = *(unsigned __int16 *)(v2 + 12);
    result = 86400 * (v20 - 1);
    v4 += result;
    if ( (unsigned __int16)v20 > 0x3Bu && (a2 & 3) == 0 )
    {
      result = 100 * (a2 / 100);
      if ( a2 != result || (result = 400 * (a2 / 400), a2 == result) )
        v4 += 86400;
    }
    goto LABEL_20;
  }
  if ( a2 == *(_DWORD *)(result + 28) )
    return result;
  v4 = 0;
  if ( a2 > 1970 )
    v4 = 86400
       * (365 * (a2 - 1970)
        + ((a2 - 1) >> 2)
        - 492
        - ((int)((unsigned __int64)(1374389535LL * (a2 - 1)) >> 32) >> 5)
        + ((int)((unsigned __int64)(1374389535LL * (a2 - 1)) >> 32) >> 7)
        + 15);
  result = *(_DWORD *)(result + 4);
  v5 = result == 0;
  if ( result == 1 )
    goto LABEL_22;
LABEL_6:
  if ( v5 )
  {
    result = 86400 * *(unsigned __int16 *)(v2 + 12);
    v4 += result;
    goto LABEL_20;
  }
  if ( result != 2 )
  {
LABEL_20:
    v19 = v4 - *(_DWORD *)(v2 + 20);
    *(_DWORD *)(v2 + 28) = a2;
    *(_DWORD *)(v2 + 24) = *(_DWORD *)(v2 + 16) + v19;
    return result;
  }
  if ( (a2 & 3) != 0 )
  {
    v6 = 0;
    v7 = 0;
  }
  else if ( a2 == 100 * (a2 / 100) )
  {
    v6 = a2 % 400 == 0 ? 0xD : 0;
    v7 = a2 % 400 == 0;
  }
  else
  {
    v6 = 13;
    v7 = 1;
  }
  v8 = *(unsigned __int16 *)(v2 + 8);
  v22 = (unsigned __int16)word_80D51BE[v8 + v6];
  v21 = 86400 * v22 + v4;
  v9 = a2 - (*(_WORD *)(v2 + 8) < 3u);
  v10 = (v9 % 100
       + (int)(26 * (v8 + 9 - 12 * ((unsigned int)((unsigned __int64)(715827883LL * (v8 + 9)) >> 32) >> 1) + 1) - 2)
       / 10
       + 1
       + v9 % 100 / 4
       + v9 / 400
       - 2 * (v9 / 100))
      % 7;
  v11 = v10 + 7;
  v12 = v10 < 0;
  v13 = v10;
  v14 = *(unsigned __int16 *)(v2 + 10);
  if ( v12 )
    v13 = v11;
  v15 = *(unsigned __int16 *)(v2 + 12) - v13 + (*(unsigned __int16 *)(v2 + 12) - v13 < 0 ? 7 : 0);
  if ( v14 > 1 )
  {
    v16 = v15 + 7;
    v17 = (unsigned __int16)_mon_yday[13 * v7 + *(unsigned __int16 *)(v2 + 8)] - v22;
    if ( v17 > v15 + 7 )
    {
      v18 = v15 + 7 * v14 - 7;
      do
      {
        v15 = v16;
        if ( v18 == v16 )
          break;
        v16 += 7;
      }
      while ( v17 > v16 );
    }
  }
  result = 86400 * v15;
  *(_DWORD *)(v2 + 28) = a2;
  *(_DWORD *)(v2 + 24) = *(_DWORD *)(v2 + 16) + result + v21 - *(_DWORD *)(v2 + 20);
  return result;
}
// 80D51BE: using guessed type __int16 word_80D51BE[];
// 80D51C0: using guessed type __int16 _mon_yday[13];

//----- (080901A0) --------------------------------------------------------
unsigned int update_vars()
{
  unsigned int v0; // ebx
  unsigned int result; // eax
  unsigned int v2; // edx

  off_80EBF20 = (void *)dword_80EC720;
  timezone = -dword_80EC714;
  daylight = dword_80EC734 != dword_80EC714;
  tzname = (void *)tz_rules;
  v0 = strlen((_BYTE *)tz_rules);
  result = strlen((_BYTE *)dword_80EC720);
  v2 = _tzname_cur_max;
  if ( v0 > _tzname_cur_max )
  {
    _tzname_cur_max = v0;
    v2 = v0;
  }
  if ( result > v2 )
    _tzname_cur_max = result;
  return result;
}
// 80EBF1C: using guessed type void *tzname;
// 80EBF20: using guessed type void *off_80EBF20;
// 80EC6E0: using guessed type int timezone;
// 80EC6E4: using guessed type int daylight;
// 80EC700: using guessed type int tz_rules;
// 80EC714: using guessed type int dword_80EC714;
// 80EC720: using guessed type int dword_80EC720;
// 80EC734: using guessed type int dword_80EC734;
// 80ECD3C: using guessed type int _tzname_cur_max;

//----- (08090210) --------------------------------------------------------
int __usercall _tzstring_len@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>)
{
  _DWORD *v3; // ebx
  unsigned int v4; // esi
  unsigned int v5; // eax
  char *v6; // ebp
  int v7; // eax
  int v8; // esi
  int v10; // eax
  int v11; // ebx

  v3 = (_DWORD *)tzstring_list;
  if ( tzstring_list )
  {
    v4 = 8 - a2;
    while ( 1 )
    {
      v5 = v3[1];
      if ( v5 >= a2 )
      {
        v6 = (char *)v3 + v4 + v5;
        if ( !j_memcmp(a1, v6, a2) )
          break;
      }
      if ( !*v3 )
      {
        v7 = malloc(a2 + 9);
        v8 = v7;
        if ( !v7 )
          return 0;
        v6 = (char *)(v7 + 8);
        *(_DWORD *)v7 = 0;
        *(_DWORD *)(v7 + 4) = a2;
        memcpy((_BYTE *)(v7 + 8), a1, a2);
        *(_BYTE *)(v8 + a2 + 8) = 0;
        *v3 = v8;
        return (int)v6;
      }
      v3 = (_DWORD *)*v3;
    }
    return (int)v6;
  }
  v10 = malloc(a2 + 9);
  v11 = v10;
  if ( !v10 )
    return 0;
  *(_DWORD *)(v10 + 4) = a2;
  *(_DWORD *)v10 = 0;
  memcpy((_BYTE *)(v10 + 8), a1, a2);
  *(_BYTE *)(v11 + a2 + 8) = 0;
  tzstring_list = v11;
  return v11 + 8;
}
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80EC6F0: using guessed type int tzstring_list;

//----- (080902F0) --------------------------------------------------------
int __usercall parse_tzname@<eax>(char **a1@<eax>, int a2@<edx>)
{
  char *v3; // esi
  char *v4; // ebx
  unsigned int v5; // ecx
  char *i; // ebx
  char v7; // dl
  int v9; // eax

  v3 = *a1;
  if ( (unsigned __int8)((**a1 & 0xDF) - 65) > 0x19u )
    goto LABEL_5;
  v4 = *a1;
  do
    ++v4;
  while ( (unsigned __int8)((*v4 & 0xDF) - 65) <= 0x19u );
  v5 = v4 - v3;
  if ( (unsigned int)(v4 - v3) <= 2 )
  {
LABEL_5:
    ++v3;
    if ( **a1 != 60 )
      return 0;
    for ( i = v3; ; ++i )
    {
      v7 = *i;
      if ( (unsigned __int8)((*i & 0xDF) - 65) > 0x19u && ((v7 - 43) & 0xFD) != 0 && (unsigned __int8)(v7 - 48) > 9u )
        break;
    }
    v5 = i - v3;
    if ( (unsigned int)(i - v3) <= 2 || v7 != 62 )
      return 0;
    v4 = i + 1;
  }
  v9 = _tzstring_len(v3, v5);
  if ( v9 )
  {
    tz_rules[8 * a2] = v9;
    *a1 = v4;
    return 1;
  }
  return 0;
}
// 80EC700: using guessed type int tz_rules[];

//----- (080903B0) --------------------------------------------------------
int __usercall parse_offset@<eax>(char **a1@<eax>, int a2@<edx>, long double a3@<st0>)
{
  char *v5; // ebx
  bool v6; // zf
  char v7; // dl
  char v8; // cl
  int v9; // ebp
  int result; // eax
  unsigned __int16 v11; // [esp+6h] [ebp-26h] BYREF
  unsigned __int16 v12; // [esp+8h] [ebp-24h] BYREF
  unsigned __int16 v13; // [esp+Ah] [ebp-22h] BYREF
  int v14; // [esp+Ch] [ebp-20h] BYREF

  v5 = *a1;
  v6 = a2 == 0;
  v7 = **a1;
  if ( v6 )
  {
    result = 0;
    if ( !v7 )
      return result;
    v8 = (v7 - 43) & 0xFD;
    if ( !v8 )
      goto LABEL_12;
    if ( (unsigned int)(v7 - 48) > 9 )
      return result;
  }
  else
  {
    v8 = (v7 - 43) & 0xFD;
  }
  v9 = -1;
  if ( !v8 )
  {
LABEL_12:
    ++v5;
    v9 = v7 != 45 ? -1 : 1;
  }
  v14 = 0;
  v12 = 0;
  v13 = 0;
  *a1 = v5;
  if ( sscanf(a3, (unsigned int)v5, (unsigned int)"%hu%n:%hu%n:%hu%n", &v11, &v14, &v12, &v14, &v13, &v14) <= 0 )
  {
    if ( !a2 )
    {
      dword_80EC714[0] = 0;
      return 0;
    }
    dword_80EC734 = dword_80EC714[0] + 3600;
  }
  else
  {
    dword_80EC714[8 * a2] = compute_offset(v13, v12, v11) * v9;
  }
  result = 1;
  *a1 = &v5[v14];
  return result;
}
// 80EC714: using guessed type int dword_80EC714[];
// 80EC734: using guessed type int dword_80EC734;

//----- (080904C0) --------------------------------------------------------
bool __usercall parse_rule@<al>(char **a1@<eax>, int a2@<edx>, long double a3@<st0>)
{
  char *v5; // ebx
  char v6; // al
  unsigned int v7; // eax
  bool result; // al
  unsigned int v9; // edx
  int *v10; // eax
  char v11; // dl
  char v12; // dl
  int v13; // eax
  unsigned int v14; // ebx
  int v15; // ebp
  int *v16; // ebp
  unsigned __int16 v17; // [esp+6h] [ebp-26h] BYREF
  unsigned __int16 v18; // [esp+8h] [ebp-24h] BYREF
  unsigned __int16 v19; // [esp+Ah] [ebp-22h] BYREF
  char *v20; // [esp+Ch] [ebp-20h] BYREF

  v5 = &(*a1)[**a1 == 44];
  v6 = *v5;
  if ( *v5 == 74 )
  {
    ++v5;
    dword_80EC704[8 * a2] = 1;
    if ( (unsigned int)(*v5 - 48) > 9 )
      return 0;
    goto LABEL_4;
  }
  if ( (unsigned int)(v6 - 48) <= 9 )
  {
    dword_80EC704[8 * a2] = 0;
LABEL_4:
    v7 = strtoul(v5, &v20, 10);
    if ( v5 == v20 || v7 > 0x16D || dword_80EC704[8 * a2] == 1 && !v7 )
      return 0;
    v5 = v20;
    word_80EC70C[16 * a2] = v7;
    goto LABEL_15;
  }
  v9 = 32 * a2;
  if ( v6 == 77 )
  {
    dword_80EC704[8 * a2] = 2;
    v16 = &tz_rules[v9 / 4];
    if ( sscanf(
           a3,
           (unsigned int)v5,
           (unsigned int)"M%hu.%hu.%hu%n",
           v9 + 135186184,
           &word_80EC70A[v9 / 2],
           &word_80EC70C[v9 / 2],
           &v20) != 3
      || (unsigned __int16)(*((_WORD *)v16 + 4) - 1) > 0xBu
      || (unsigned __int16)(*((_WORD *)v16 + 5) - 1) > 4u
      || *((_WORD *)v16 + 6) > 6u )
    {
      return 0;
    }
    v5 = &v5[(_DWORD)v20];
  }
  else
  {
    if ( v6 )
      return 0;
    v10 = &tz_rules[v9 / 4];
    tz_rules[v9 / 4 + 1] = 2;
    if ( v9 )
    {
      *((_WORD *)v10 + 4) = 11;
      *((_WORD *)v10 + 5) = 1;
      *((_WORD *)v10 + 6) = 0;
    }
    else
    {
      word_80EC70A[0] = 2;
      word_80EC708 = 3;
      word_80EC70C[0] = 0;
    }
  }
LABEL_15:
  v11 = *v5;
  result = v11 != 44 && v11 != 47 && v11 != 0;
  if ( result )
    return 0;
  if ( v11 != 47 )
  {
    dword_80EC710[8 * a2] = 7200;
LABEL_18:
    result = 1;
    dword_80EC71C[8 * a2] = -1;
    *a1 = v5;
    return result;
  }
  v12 = v5[1];
  if ( v12 )
  {
    v20 = 0;
    v13 = v12 == 45;
    v18 = 0;
    v17 = 2;
    v19 = 0;
    v14 = (unsigned int)&v5[v13 + 1];
    v15 = -v13 | 1;
    sscanf(a3, v14, (unsigned int)"%hu%n:%hu%n:%hu%n", &v17, &v20, &v18, &v20, &v19, &v20);
    v5 = &v20[v14];
    dword_80EC710[8 * a2] = v15 * (3600 * v17 + 60 * v18 + v19);
    goto LABEL_18;
  }
  return result;
}
// 80EC700: using guessed type int tz_rules[];
// 80EC704: using guessed type int dword_80EC704[];
// 80EC708: using guessed type __int16 word_80EC708;
// 80EC70A: using guessed type __int16 word_80EC70A[];
// 80EC70C: using guessed type __int16 word_80EC70C[];
// 80EC710: using guessed type int dword_80EC710[];
// 80EC71C: using guessed type int dword_80EC71C[];

//----- (08090760) --------------------------------------------------------
int __cdecl _tzstring(_BYTE *a1)
{
  int v1; // eax

  v1 = strlen(a1);
  return _tzstring_len(a1, v1);
}

//----- (08090780) --------------------------------------------------------
unsigned int __usercall _tzset_parse_tz@<eax>(long double a1@<st0>, _BYTE *a2)
{
  unsigned int result; // eax

  memset(tz_rules, 0, 0x40u);
  dword_80EC720 = (int)&unk_80CFAB1;
  tz_rules[0] = (int)&unk_80CFAB1;
  if ( !(unsigned __int8)parse_tzname(&a2, 0) || !(unsigned __int8)parse_offset(&a2, 0, a1) )
    return update_vars();
  if ( !*a2 )
  {
    dword_80EC720 = tz_rules[0];
    dword_80EC734 = dword_80EC714[0];
    return update_vars();
  }
  if ( !(unsigned __int8)parse_tzname(&a2, 1)
    || (parse_offset(&a2, 1, a1), *a2) && (*a2 != 44 || a2[1])
    || (_tzfile_default((_BYTE *)tz_rules[0], (_BYTE *)dword_80EC720, dword_80EC714[0], dword_80EC734), !_use_tzfile) )
  {
    if ( parse_rule(&a2, 0, a1) )
      parse_rule(&a2, 1, a1);
    return update_vars();
  }
  result = free(old_tz);
  old_tz = 0;
  return result;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EC6EC: using guessed type int old_tz;
// 80EC700: using guessed type int tz_rules[];
// 80EC714: using guessed type int dword_80EC714[];
// 80EC720: using guessed type int dword_80EC720;
// 80EC734: using guessed type int dword_80EC734;
// 80ECD40: using guessed type int _use_tzfile;

//----- (080908A0) --------------------------------------------------------
int __usercall tzset_internal@<eax>(int result@<eax>, int a2@<edx>, long double a3@<st0>)
{
  char *v4; // eax
  char *v5; // ebx
  int v6; // esi

  if ( is_initialized_8856 && !result )
    return result;
  is_initialized_8856 = 1;
  v4 = (char *)getenv("TZ");
  v5 = v4;
  if ( !v4 && !a2 )
  {
    v5 = "/etc/localtime";
LABEL_6:
    v6 = old_tz;
    if ( !old_tz )
      goto LABEL_12;
LABEL_11:
    result = j_strcmp(v5, v6);
    if ( !result )
      return result;
    goto LABEL_12;
  }
  if ( !v4 )
  {
    v6 = old_tz;
    if ( !old_tz )
    {
      tz_rules[0] = 0;
      dword_80EC720 = 0;
      old_tz = (int)strdup("/etc/localtime");
      result = _tzfile_read("/etc/localtime", 0, 0);
      if ( _use_tzfile )
        return result;
      v5 = "/etc/localtime";
      goto LABEL_16;
    }
    goto LABEL_20;
  }
  if ( !*v4 )
  {
    v6 = old_tz;
    v5 = "Universal";
    if ( !old_tz )
    {
      tz_rules[0] = 0;
      dword_80EC720 = 0;
      old_tz = (int)strdup("Universal");
      _tzfile_read("Universal", 0, 0);
      result = _use_tzfile;
      if ( _use_tzfile )
        return result;
      goto LABEL_16;
    }
    goto LABEL_11;
  }
  if ( *v4 != 58 )
    goto LABEL_6;
  v6 = old_tz;
  v5 = v4 + 1;
  if ( old_tz )
  {
    if ( v4 != (char *)-1 )
      goto LABEL_11;
LABEL_20:
    tz_rules[0] = 0;
    dword_80EC720 = 0;
    free(v6);
    old_tz = (int)strdup("/etc/localtime");
    result = _tzfile_read("/etc/localtime", 0, 0);
    if ( !_use_tzfile )
      goto LABEL_14;
    return result;
  }
  if ( v4 == (char *)-1 )
    goto LABEL_20;
LABEL_12:
  tz_rules[0] = 0;
  dword_80EC720 = 0;
  free(v6);
  old_tz = (int)strdup(v5);
  result = _tzfile_read(v5, 0, 0);
  if ( _use_tzfile )
    return result;
  if ( !*v5 )
  {
LABEL_14:
    memset(tz_rules, 0, 0x40u);
    dword_80EC720 = (int)&unk_80CDC5F;
    tz_rules[0] = (int)&unk_80CDC5F;
    dword_80EC738 = -1;
    dword_80EC718 = -1;
    return update_vars();
  }
LABEL_16:
  if ( !strcmp(v5, "/etc/localtime") )
    goto LABEL_14;
  return _tzset_parse_tz(a3, v5);
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EC6E8: using guessed type int is_initialized_8856;
// 80EC6EC: using guessed type int old_tz;
// 80EC700: using guessed type int tz_rules[];
// 80EC718: using guessed type int dword_80EC718;
// 80EC720: using guessed type int dword_80EC720;
// 80EC738: using guessed type int dword_80EC738;
// 80ECD40: using guessed type int _use_tzfile;

//----- (08090B10) --------------------------------------------------------
int __usercall _tzname_max@<eax>(long double a1@<st0>)
{
  bool v2; // zf

  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg ds:tzset_lock, ecx }
  if ( !v2 )
    _lll_lock_wait_private(0, &tzset_lock);
  tzset_internal(0, 0, a1);
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --tzset_lock )
    _lll_unlock_wake_private(&tzset_lock);
  return _tzname_cur_max;
}
// 80EC740: using guessed type int tzset_lock;
// 80ECD3C: using guessed type int _tzname_cur_max;

//----- (08090B70) --------------------------------------------------------
int __usercall _tz_compute@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)
{
  int result; // eax
  _BOOL4 v7; // eax
  int v8; // edx

  compute_change((int)tz_rules, a2[5] + 1900);
  result = compute_change((int)&dword_80EC720, a2[5] + 1900);
  if ( a3 )
  {
    if ( dword_80EC718 > dword_80EC738 )
      v7 = a1 < dword_80EC738 || a1 >= dword_80EC718;
    else
      v7 = a1 >= dword_80EC718 && a1 < dword_80EC738;
    v8 = (int)*(&tzname + v7);
    a2[8] = v7;
    result = dword_80EC714[8 * v7];
    a2[10] = v8;
    a2[9] = result;
  }
  return result;
}
// 80EBF1C: using guessed type void *tzname;
// 80EC700: using guessed type int tz_rules[];
// 80EC714: using guessed type int dword_80EC714[];
// 80EC718: using guessed type int dword_80EC718;
// 80EC720: using guessed type int dword_80EC720;
// 80EC738: using guessed type int dword_80EC738;

//----- (08090C00) --------------------------------------------------------
int __usercall tzset@<eax>(long double a1@<st0>)
{
  bool v2; // zf
  int result; // eax

  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg ds:tzset_lock, ecx }
  if ( !v2 )
    _lll_lock_wait_private(0, &tzset_lock);
  tzset_internal(1, 1, a1);
  result = _use_tzfile;
  if ( !_use_tzfile )
  {
    tzname = (void *)tz_rules[0];
    result = dword_80EC720;
    off_80EBF20 = (void *)dword_80EC720;
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --tzset_lock )
    return _lll_unlock_wake_private(&tzset_lock);
  return result;
}
// 80EBF1C: using guessed type void *tzname;
// 80EBF20: using guessed type void *off_80EBF20;
// 80EC700: using guessed type int tz_rules[];
// 80EC720: using guessed type int dword_80EC720;
// 80EC740: using guessed type int tzset_lock;
// 80ECD40: using guessed type int _use_tzfile;

//----- (08090C80) --------------------------------------------------------
int *__usercall _tz_convert@<eax>(long double a1@<st0>, int *a2, int a3, int *a4)
{
  bool v5; // zf
  int *v6; // ebx
  int v7; // eax
  int v9; // [esp+8h] [ebp-24h] BYREF
  int v10[8]; // [esp+Ch] [ebp-20h] BYREF

  if ( !a2 )
  {
    v6 = 0;
    __writegsdword(0xFFFFFFE8, 0x16u);
    return v6;
  }
  _ECX = 1;
  v5 = __readgsdword(0xCu) == 0;
  if ( !v5 )
    __asm { lock }
  __asm { cmpxchg ds:tzset_lock, ecx }
  if ( !v5 )
    _lll_lock_wait_private(0, &tzset_lock);
  tzset_internal(a4 == (int *)&tmbuf && a3 != 0, 1, a1);
  if ( _use_tzfile )
  {
    v6 = a4;
    _tzfile_compute(a1, *a2, a3, &v9, v10, a4);
  }
  else
  {
    v6 = 0;
    if ( _offtime(a2, 0, a4) )
    {
      v6 = a4;
      _tz_compute(*a2, a4, a3);
    }
    v9 = 0;
    v10[0] = 0;
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --tzset_lock )
    _lll_unlock_wake_private(&tzset_lock);
  if ( v6 )
  {
    if ( a3 )
    {
      v7 = v6[9];
    }
    else
    {
      v6[8] = 0;
      v6[10] = (int)&unk_80CDC63;
      v7 = 0;
      v6[9] = 0;
    }
    if ( _offtime(a2, v7 - v9, v6) )
    {
      *v6 += v10[0];
      return v6;
    }
  }
  return 0;
}
// 80EC740: using guessed type int tzset_lock;
// 80ECD40: using guessed type int _use_tzfile;
// 8090C80: using guessed type int var_20[8];

//----- (08090DE0) --------------------------------------------------------
int __cdecl _tzfile_read(char *a1, unsigned int a2, _DWORD *a3)
{
  int v3; // esi
  const char *v4; // ebx
  char v5; // al
  int v6; // edx
  int result; // eax
  int v8; // eax
  const char *v9; // eax
  int v10; // eax
  int *v11; // eax
  int *v12; // ebx
  int v13; // eax
  int v14; // edx
  int v15; // eax
  unsigned int v16; // esi
  unsigned __int32 v17; // edi
  unsigned int v18; // eax
  unsigned int v19; // edx
  int v20; // esi
  unsigned int v21; // ecx
  unsigned int v22; // edi
  unsigned int v23; // eax
  int v24; // eax
  int v25; // edi
  int v26; // eax
  unsigned __int8 *v27; // edx
  unsigned int v28; // ecx
  int v29; // ecx
  int v30; // eax
  unsigned int v31; // edi
  unsigned __int8 *v32; // eax
  unsigned int v33; // eax
  unsigned __int8 *v34; // eax
  unsigned int v35; // eax
  int v36; // esi
  bool v37; // cc
  int v38; // edi
  int v39; // esi
  unsigned int i; // esi
  unsigned __int8 *v41; // eax
  int v42; // eax
  unsigned int v43; // eax
  int v44; // ecx
  unsigned int j; // esi
  unsigned __int8 *v46; // eax
  int v47; // eax
  unsigned int v48; // eax
  unsigned int v49; // ebx
  int v50; // eax
  int v51; // eax
  int v52; // esi
  int v53; // eax
  _BYTE *v54; // edi
  unsigned __int8 *v55; // eax
  int v56; // eax
  int v57; // esi
  int v58; // eax
  int v59; // edi
  int v60; // eax
  _BYTE *k; // edx
  int v62; // eax
  int v63; // eax
  char v64; // bl
  int v65; // edx
  int v66; // esi
  int v67; // edi
  int v68; // ecx
  int *v69; // [esp+0h] [ebp-ECh]
  int v70; // [esp+10h] [ebp-DCh]
  unsigned __int32 v71; // [esp+14h] [ebp-D8h]
  unsigned int v72; // [esp+18h] [ebp-D4h]
  int v73; // [esp+1Ch] [ebp-D0h]
  bool v74; // [esp+23h] [ebp-C9h]
  unsigned __int32 v75; // [esp+24h] [ebp-C8h]
  unsigned int v76; // [esp+28h] [ebp-C4h]
  int v77; // [esp+2Ch] [ebp-C0h]
  const char *v78; // [esp+38h] [ebp-B4h] BYREF
  unsigned int v79[2]; // [esp+3Ch] [ebp-B0h] BYREF
  char v80[20]; // [esp+44h] [ebp-A8h] BYREF
  unsigned int v81; // [esp+58h] [ebp-94h]
  unsigned int v82; // [esp+5Ch] [ebp-90h]
  unsigned int v83; // [esp+60h] [ebp-8Ch]
  unsigned int v84; // [esp+64h] [ebp-88h]
  unsigned int v85; // [esp+68h] [ebp-84h]
  unsigned int v86; // [esp+6Ch] [ebp-80h]
  __int64 v87[5]; // [esp+70h] [ebp-7Ch] BYREF
  __int64 v88; // [esp+9Ch] [ebp-50h]
  int v89; // [esp+B8h] [ebp-34h]
  __int64 v90; // [esp+C8h] [ebp-24h]

  v3 = _use_tzfile;
  _use_tzfile = 0;
  v4 = a1;
  v78 = 0;
  if ( !a1 )
  {
    v4 = "/etc/localtime";
    if ( v3 )
      goto LABEL_13;
    goto LABEL_15;
  }
  v5 = *a1;
  if ( !*a1 )
  {
LABEL_3:
    v6 = 0;
LABEL_4:
    free(v6);
    result = free(transitions);
    transitions = 0;
    return result;
  }
  if ( !_libc_enable_secure )
  {
    if ( v5 == 47 )
      goto LABEL_12;
    goto LABEL_8;
  }
  if ( v5 != 47 )
  {
    v8 = strstr(a1, (char *)&unk_80CDC90);
    v6 = 0;
    if ( v8 )
      goto LABEL_4;
LABEL_8:
    v9 = (const char *)getenv("TZDIR");
    if ( v9 )
    {
      if ( !*v9 )
        v9 = "/usr/share/zoneinfo";
    }
    else
    {
      v9 = "/usr/share/zoneinfo";
    }
    v10 = asprintf(&v78, "%s/%s", v9, a1);
    v4 = v78;
    v6 = (int)v78;
    if ( v10 == -1 )
      goto LABEL_4;
    goto LABEL_12;
  }
  if ( strcmp(a1, "/etc/localtime") && j_memcmp(a1, "/usr/share/zoneinfo", 19) || strstr(a1, (char *)&unk_80CDC90) )
    goto LABEL_3;
LABEL_12:
  if ( v3 )
  {
LABEL_13:
    if ( !_xstat64(3, (int)v4, (int)v87) && tzfile_ino == v90 && tzfile_dev == v87[0] && v89 == tzfile_mtime )
      goto LABEL_47;
  }
LABEL_15:
  v11 = (int *)fopen((int)v4, "rce");
  v12 = v11;
  if ( !v11 )
  {
    v6 = (int)v78;
    goto LABEL_4;
  }
  v13 = fileno_unlocked(v11);
  if ( _fxstat64(3, v13, (int)v87) )
    goto LABEL_34;
  free(transitions);
  transitions = 0;
  tzfile_dev = v87[0];
  v14 = HIDWORD(v90);
  LODWORD(tzfile_ino) = v90;
  v15 = v89;
  *v12 |= 0x8000u;
  HIDWORD(tzfile_ino) = v14;
  tzfile_mtime = v15;
  if ( fread_unlocked((int)v80, 0x2Cu, 1, (int)v12) != 1 )
    goto LABEL_34;
  v70 = j_memcmp(v80, "TZif", 4);
  if ( v70 )
    goto LABEL_34;
  v16 = _byteswap_ulong(v85);
  num_types = v16;
  v71 = _byteswap_ulong(v82);
  v17 = _byteswap_ulong(v84);
  num_transitions = v17;
  v75 = _byteswap_ulong(v81);
  v72 = _byteswap_ulong(v86);
  v18 = _byteswap_ulong(v83);
  num_leaps = v18;
  v74 = v17 > 0x33333332 || v16 < v75 || v16 < v71;
  if ( v74 )
    goto LABEL_34;
  v73 = v17;
  v19 = (5 * v17 + 3) & 0xFFFFFFFC;
  if ( ~v19 >> 3 < v16 )
    goto LABEL_34;
  v20 = 8 * v16;
  v76 = (5 * v17 + 3) & 0xFFFFFFFC;
  if ( ~(v19 + v20) < v72 )
    goto LABEL_34;
  v21 = v72 + v19 + v20;
  if ( v21 > 0xFFFFFFFC )
    goto LABEL_34;
  v22 = (v21 + 3) & 0xFFFFFFFC;
  if ( ~v22 >> 3 < v18 )
    goto LABEL_34;
  v77 = 8 * v18;
  v23 = v22 + 8 * v18;
  if ( ~v23 < a2 )
    goto LABEL_34;
  v24 = malloc(a2 + v23);
  transitions = v24;
  if ( !v24 )
    goto LABEL_34;
  v25 = v24 + v22;
  leaps = v25;
  tzspec = 0;
  types = v24 + v76;
  zone_names = v20 + v24 + v76;
  type_idxs = v24 + 4 * v73;
  if ( a2 )
    *a3 = v77 + v25;
  v26 = fread_unlocked(v24, 5u, v73, (int)v12);
  if ( v26 != num_transitions )
    goto LABEL_34;
  if ( v26 )
  {
    if ( *(unsigned __int8 *)type_idxs < (unsigned int)num_types )
    {
      v27 = (unsigned __int8 *)(type_idxs + 1);
      while ( (unsigned __int8 *)(v26 + type_idxs) != v27 )
      {
        v28 = *v27++;
        if ( num_types <= v28 )
          goto LABEL_34;
      }
      v29 = transitions;
      v30 = v26 - 1;
      do
      {
        *(_DWORD *)(v29 + 4 * v30) = _byteswap_ulong(*(_DWORD *)(v29 + 4 * v30));
        --v30;
      }
      while ( v30 != -1 );
      goto LABEL_50;
    }
    goto LABEL_34;
  }
  if ( num_types )
  {
LABEL_50:
    v31 = 0;
    while ( fread_unlocked((int)v79, 1u, 4, (int)v12) == 4 )
    {
      v32 = (unsigned __int8 *)v12[1];
      if ( (unsigned int)v32 >= v12[2] )
      {
        v33 = _uflow(v12);
      }
      else
      {
        v12[1] = (int)(v32 + 1);
        v33 = *v32;
      }
      if ( v33 > 1 )
        break;
      *(_BYTE *)(types + 8 * v31 + 4) = v33;
      v34 = (unsigned __int8 *)v12[1];
      if ( (unsigned int)v34 >= v12[2] )
      {
        v35 = _uflow(v12);
      }
      else
      {
        v12[1] = (int)(v34 + 1);
        v35 = *v34;
      }
      if ( v35 > v72 )
        break;
      v36 = types + 8 * v31++;
      v37 = num_types <= v31;
      *(_BYTE *)(v36 + 5) = v35;
      *(_DWORD *)v36 = _byteswap_ulong(v79[0]);
      if ( v37 )
        goto LABEL_59;
    }
    goto LABEL_34;
  }
LABEL_59:
  if ( fread_unlocked(zone_names, 1u, v72, (int)v12) != v72 )
  {
LABEL_34:
    fclose(v12);
    v6 = (int)v78;
    goto LABEL_4;
  }
  if ( num_leaps )
  {
    v38 = 0;
    while ( fread_unlocked((int)v79, 1u, 4, (int)v12) == 4 )
    {
      v39 = 8 * v38;
      *(_DWORD *)(leaps + 8 * v38) = _byteswap_ulong(v79[0]);
      if ( fread_unlocked((int)v79, 1u, 4, (int)v12) != 4 )
        break;
      v37 = num_leaps <= (unsigned int)++v38;
      *(_DWORD *)(leaps + v39 + 4) = _byteswap_ulong(v79[0]);
      if ( v37 )
        goto LABEL_65;
    }
    goto LABEL_34;
  }
LABEL_65:
  for ( i = 0; i != v71; ++i )
  {
    v41 = (unsigned __int8 *)v12[1];
    if ( (unsigned int)v41 >= v12[2] )
    {
      v42 = _uflow(v12);
      if ( v42 == -1 )
        goto LABEL_34;
    }
    else
    {
      v12[1] = (int)(v41 + 1);
      v42 = *v41;
    }
    *(_BYTE *)(types + 8 * i + 6) = v42 != 0;
  }
  v43 = num_types;
  v44 = types;
  while ( i < v43 )
  {
    ++i;
    *(_BYTE *)(v44 + 8 * i - 2) = 0;
  }
  for ( j = 0; j != v75; ++j )
  {
    v46 = (unsigned __int8 *)v12[1];
    if ( (unsigned int)v46 >= v12[2] )
    {
      v47 = _uflow(v12);
      if ( v47 == -1 )
        goto LABEL_34;
      v44 = types;
    }
    else
    {
      v12[1] = (int)(v46 + 1);
      v47 = *v46;
    }
    *(_BYTE *)(v44 + 8 * j + 7) = v47 != 0;
  }
  v48 = num_types;
  while ( j < v48 )
  {
    ++j;
    *(_BYTE *)(v44 + 8 * j - 1) = 0;
  }
  if ( v80[4] )
  {
    if ( fread_unlocked((int)v80, 0x2Cu, 1, (int)v12) != 1 )
      goto LABEL_34;
    if ( j_memcmp(v80, "TZif", 4) )
      goto LABEL_34;
    if ( fseek(
           v12,
           12 * _byteswap_ulong(v83)
         + 6 * _byteswap_ulong(v85)
         + 9 * _byteswap_ulong(v84)
         + _byteswap_ulong(v81)
         + _byteswap_ulong(v82)
         + _byteswap_ulong(v86),
           1u) )
    {
      goto LABEL_34;
    }
    v51 = ftello(v12);
    if ( v51 < 0 )
      goto LABEL_34;
    if ( v88 < v51 + 2 )
      goto LABEL_34;
    v52 = v88 - v51;
    v53 = v88 - v51 - 1;
    if ( !v53 )
      goto LABEL_34;
    v54 = (_BYTE *)malloc(v53);
    if ( !v54 )
      goto LABEL_34;
    v55 = (unsigned __int8 *)v12[1];
    if ( (unsigned int)v55 >= v12[2] )
    {
      v56 = _uflow(v12);
    }
    else
    {
      v12[1] = (int)(v55 + 1);
      v56 = *v55;
    }
    if ( v56 != 10 || v52 - 2 != fread_unlocked((int)v54, 1u, v52 - 2, (int)v12) )
    {
      free(v54);
      goto LABEL_34;
    }
    v54[v52 - 2] = 0;
    tzspec = _tzstring(v54);
    free(v54);
  }
  if ( tzspec && !*(_BYTE *)tzspec )
    tzspec = 0;
  v69 = v12;
  v49 = 0;
  fclose(v69);
  while ( v49 < num_types )
  {
    v50 = *(unsigned __int8 *)(types + 8 * v49++ + 5);
    _tzstring((_BYTE *)(zone_names + v50));
  }
  tzname = 0;
  off_80EBF20 = 0;
  v57 = num_transitions;
  while ( v57 )
  {
    --v57;
    v58 = types + 8 * *(unsigned __int8 *)(type_idxs + v57);
    v59 = *(unsigned __int8 *)(v58 + 4);
    if ( !*(&tzname + v59) )
    {
      *(&tzname + v59) = (void *)_tzstring((_BYTE *)(zone_names + *(unsigned __int8 *)(v58 + 5)));
      if ( *(&tzname + 1 - v59) )
        break;
    }
  }
  if ( !tzname )
  {
    if ( num_types != 1 )
      _assert_fail("num_types == 1", "tzfile.c", 492, "__tzfile_read");
    tzname = (void *)_tzstring((_BYTE *)zone_names);
  }
  if ( !off_80EBF20 )
    off_80EBF20 = tzname;
  v60 = zone_names;
  do
  {
    for ( k = (_BYTE *)v60; *k; ++k )
      ;
    if ( (unsigned int)&k[-v60] > _tzname_cur_max )
      _tzname_cur_max = (int)&k[-v60];
    v60 = (int)(k + 1);
  }
  while ( (unsigned int)(k + 1) < zone_names + v72 );
  if ( !num_transitions )
  {
    v62 = *(_DWORD *)types;
    rule_dstoff = v62;
    rule_stdoff = v62;
    goto LABEL_129;
  }
  v63 = num_transitions - 1;
  rule_dstoff = 0;
  rule_stdoff = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v67 = 0;
  while ( !v70 )
  {
    v68 = types + 8 * *(unsigned __int8 *)(type_idxs + v63);
    if ( !*(_BYTE *)(v68 + 4) )
    {
      v66 = *(_DWORD *)v68;
      v74 = 1;
      v70 = 1;
      goto LABEL_135;
    }
    if ( v65 )
      goto LABEL_136;
LABEL_145:
    v67 = *(_DWORD *)v68;
    v64 = 1;
    v65 = 1;
LABEL_135:
    if ( (v65 & v70) != 0 )
      goto LABEL_146;
LABEL_136:
    if ( --v63 == -1 )
    {
      if ( v74 )
        rule_stdoff = v66;
      if ( v64 )
        rule_dstoff = v67;
      v62 = rule_stdoff;
      if ( !v65 )
        rule_dstoff = rule_stdoff;
      goto LABEL_129;
    }
  }
  if ( !v65 )
  {
    v68 = types + 8 * *(unsigned __int8 *)(type_idxs + v63);
    if ( !*(_BYTE *)(v68 + 4) )
      goto LABEL_136;
    goto LABEL_145;
  }
LABEL_146:
  if ( v74 )
    rule_stdoff = v66;
  v62 = rule_stdoff;
  if ( v64 )
    rule_dstoff = v67;
LABEL_129:
  daylight = rule_dstoff != v62;
  timezone = -v62;
LABEL_47:
  _use_tzfile = 1;
  return free(v78);
}
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 804F100: using guessed type _DWORD asprintf(_DWORD, _DWORD, ...);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80EBF1C: using guessed type void *tzname;
// 80EBF20: using guessed type void *off_80EBF20;
// 80EC6E0: using guessed type int timezone;
// 80EC6E4: using guessed type int daylight;
// 80EC748: using guessed type int tzspec;
// 80EC74C: using guessed type int leaps;
// 80EC750: using guessed type int num_leaps;
// 80EC754: using guessed type int rule_dstoff;
// 80EC758: using guessed type int rule_stdoff;
// 80EC75C: using guessed type int zone_names;
// 80EC760: using guessed type int types;
// 80EC764: using guessed type int num_types;
// 80EC768: using guessed type int type_idxs;
// 80EC76C: using guessed type int num_transitions;
// 80EC770: using guessed type int tzfile_mtime;
// 80EC778: using guessed type __int64 tzfile_ino;
// 80EC780: using guessed type __int64 tzfile_dev;
// 80ECD3C: using guessed type int _tzname_cur_max;
// 80ECD40: using guessed type int _use_tzfile;
// 80ECD9C: using guessed type int transitions;

//----- (08091860) --------------------------------------------------------
_BYTE *__cdecl _tzfile_default(_BYTE *a1, _BYTE *a2, int a3, int a4)
{
  unsigned int v4; // ebx
  _BYTE *result; // eax
  _WORD *v6; // eax
  int v7; // esi
  int v8; // edi
  _DWORD *v9; // ecx
  _BYTE *v10; // eax
  int v11; // ebp
  _BYTE *v12; // edx
  _BYTE *v13; // edx
  _DWORD *v14; // [esp+14h] [ebp-44h]
  unsigned int v15; // [esp+18h] [ebp-40h]
  int v16; // [esp+20h] [ebp-38h]
  int v17; // [esp+24h] [ebp-34h]
  _BYTE *v18; // [esp+28h] [ebp-30h]
  _BYTE *v19; // [esp+38h] [ebp-20h] BYREF

  v15 = strlen(a1) + 1;
  v4 = strlen(a2) + 1;
  result = (_BYTE *)_tzfile_read("posixrules", v4 + v15, &v19);
  if ( _use_tzfile )
  {
    if ( (unsigned int)num_types <= 1 )
    {
      _use_tzfile = 0;
    }
    else
    {
      v6 = mempcpy(v19, a1, v15);
      mempcpy(v6, a2, v4);
      num_types = 2;
      v7 = types;
      v18 = v19;
      zone_names = (int)v19;
      if ( num_transitions )
      {
        v8 = 0;
        v16 = a3 - rule_stdoff;
        v9 = (_DWORD *)transitions;
        v14 = (_DWORD *)transitions;
        v17 = a4 - rule_dstoff;
        v10 = (_BYTE *)type_idxs;
        v11 = type_idxs + num_transitions;
        do
        {
          v12 = (_BYTE *)(v7 + 8 * (unsigned __int8)*v10);
          *v10 = v12[4];
          if ( !v12[7] )
          {
            if ( !v8 || v12[6] )
              *v9 += v16;
            else
              *v14 += v17;
          }
          ++v10;
          ++v14;
          ++v9;
          v8 = (unsigned __int8)v12[4];
        }
        while ( (_BYTE *)v11 != v10 );
      }
      *(_BYTE *)(v7 + 5) = 0;
      *(_BYTE *)(v7 + 4) = 0;
      *(_BYTE *)(v7 + 12) = 1;
      rule_stdoff = a3;
      rule_dstoff = a4;
      *(_DWORD *)v7 = a3;
      *(_BYTE *)(v7 + 13) = v15;
      *(_DWORD *)(v7 + 8) = a4;
      tzname = a1;
      off_80EBF20 = a2;
      timezone = -a3;
      v13 = v18;
      do
      {
        result = v13;
        if ( *v13 )
        {
          do
            ++result;
          while ( *result );
          if ( _tzname_cur_max < (unsigned int)(result - v13) )
            _tzname_cur_max = result - v13;
        }
        v13 = result + 1;
      }
      while ( result + 1 < &v18[v4 + v15] );
      tzfile_dev = 0LL;
      tzfile_ino = 0LL;
      tzfile_mtime = 0;
    }
  }
  return result;
}
// 80EBF1C: using guessed type void *tzname;
// 80EBF20: using guessed type void *off_80EBF20;
// 80EC6E0: using guessed type int timezone;
// 80EC754: using guessed type int rule_dstoff;
// 80EC758: using guessed type int rule_stdoff;
// 80EC75C: using guessed type int zone_names;
// 80EC760: using guessed type int types;
// 80EC764: using guessed type int num_types;
// 80EC768: using guessed type int type_idxs;
// 80EC76C: using guessed type int num_transitions;
// 80EC770: using guessed type int tzfile_mtime;
// 80EC778: using guessed type __int64 tzfile_ino;
// 80EC780: using guessed type __int64 tzfile_dev;
// 80ECD3C: using guessed type int _tzname_cur_max;
// 80ECD40: using guessed type int _use_tzfile;
// 80ECD9C: using guessed type int transitions;

//----- (08091A60) --------------------------------------------------------
int __usercall _tzfile_compute@<eax>(long double a1@<st0>, int a2, int a3, int *a4, int *a5, int *a6)
{
  int v6; // edi
  int v7; // ebp
  unsigned int v8; // ebx
  unsigned int v9; // edx
  unsigned int v10; // eax
  unsigned int v11; // ebp
  int v12; // eax
  int v13; // esi
  void *v14; // eax
  bool v15; // cf
  int v16; // ecx
  int v17; // edx
  int v18; // eax
  int v19; // esi
  void *v20; // eax
  char *v21; // edi
  int v22; // eax
  int v23; // ebx
  int v24; // edx
  int v25; // edi
  int v26; // ebx
  int result; // eax
  _DWORD *v28; // esi
  unsigned int v29; // eax
  unsigned int v30; // edx
  int v31; // ebp
  unsigned int v32; // ebx
  _BYTE *v33; // esi
  int v34; // eax
  unsigned int v35; // ecx
  int v36; // edx
  _DWORD *v37; // ecx
  int v38; // esi
  int v39; // ecx
  _DWORD *v40; // eax
  int v41; // ecx
  _DWORD *v42; // esi
  int v43; // edi
  int v44; // eax
  int v45; // eax
  void *v46; // eax
  unsigned int v47; // ebx
  int v48; // edx
  char *v49; // ecx

  if ( a3 )
  {
    v6 = num_transitions;
    tzname = 0;
    off_80EBF20 = 0;
    if ( !num_transitions || *(_DWORD *)transitions > a2 )
    {
      v32 = num_types;
      v33 = 0;
      v34 = types;
      v35 = num_types;
      if ( num_types )
      {
        v33 = 0;
        v32 = 0;
        v36 = types;
        if ( *(_BYTE *)(types + 4) )
        {
          while ( 1 )
          {
            if ( !v33 )
            {
              off_80EBF20 = (void *)_tzstring((_BYTE *)(zone_names + *(unsigned __int8 *)(v34 + 5)));
              v35 = num_types;
              v36 = types;
            }
            if ( v35 <= ++v32 )
              break;
            v33 = (_BYTE *)(8 * v32);
            v34 = v36 + 8 * v32;
            if ( !*(_BYTE *)(v34 + 4) )
              goto LABEL_50;
            v33 = off_80EBF20;
          }
          if ( v35 == v32 )
          {
            v34 = v36;
            v33 = 0;
            v32 = 0;
          }
          else
          {
            v33 = (_BYTE *)(8 * v32);
            v34 = v36 + 8 * v32;
          }
        }
      }
LABEL_50:
      v20 = (void *)_tzstring((_BYTE *)(zone_names + *(unsigned __int8 *)(v34 + 5)));
      tzname = v20;
      if ( off_80EBF20 || v32 >= num_types )
      {
        v21 = &v33[types];
      }
      else
      {
        v47 = v32 + 1;
        v21 = &v33[types];
        v48 = types + 8 * v47;
        if ( v33[types + 4] )
        {
          v49 = &v33[types];
LABEL_86:
          off_80EBF20 = (void *)_tzstring((_BYTE *)(zone_names + (unsigned __int8)v49[5]));
          v20 = tzname;
          v21 = &v33[types];
        }
        else
        {
          while ( num_types != v47 )
          {
            v49 = (char *)v48;
            v48 += 8;
            if ( *(_BYTE *)(v48 - 4) )
              goto LABEL_86;
            ++v47;
          }
        }
      }
      goto LABEL_19;
    }
    v7 = *(_DWORD *)(transitions + 4 * num_transitions - 4);
    if ( a2 >= v7 )
    {
      if ( tzspec )
      {
        _tzset_parse_tz(a1, (_BYTE *)tzspec);
        v44 = _offtime(&a2, 0, a6);
        v6 = num_transitions;
        if ( v44 )
        {
          _tz_compute(a2, a6, 1);
          v24 = num_leaps;
          v25 = leaps;
          if ( leaps + 8 * num_leaps == zone_names )
          {
            if ( num_types != 2 )
              _assert_fail(a1, (int)"num_types == 2", (int)"tzfile.c", 706, "__tzfile_compute");
            tzname = (void *)_tzstring((_BYTE *)(leaps + 8 * num_leaps));
            v45 = strlen((_BYTE *)zone_names);
            v46 = (void *)_tzstring((_BYTE *)(zone_names + v45 + 1));
            v24 = num_leaps;
            off_80EBF20 = v46;
            v25 = leaps;
          }
          goto LABEL_25;
        }
      }
      v8 = v6;
      goto LABEL_11;
    }
    v8 = num_transitions - 1;
    v9 = (v7 - a2) / 15778476;
    if ( num_transitions > v9 )
    {
      v29 = num_transitions - v9;
      v30 = num_transitions - v9 - 1;
      v31 = 4 * v30;
      if ( a2 >= *(_DWORD *)(transitions + 4 * v30) )
      {
        v10 = v29 + 9;
        if ( num_transitions <= v10 || a2 < *(_DWORD *)(transitions + v31 + 40) )
        {
          v8 = v30;
          do
            ++v8;
          while ( a2 >= *(_DWORD *)(transitions + 4 * v8) );
          goto LABEL_11;
        }
      }
      else
      {
        if ( v30 <= 9 || a2 >= *(_DWORD *)(transitions + v31 - 40) )
        {
          v8 = v30;
          if ( a2 < *(_DWORD *)(transitions + v31 - 4) )
          {
            do
              --v8;
            while ( a2 < *(_DWORD *)(transitions + 4 * v8 - 4) );
          }
          goto LABEL_11;
        }
        v8 = v29 - 11;
        v10 = 0;
      }
    }
    else
    {
      v10 = 0;
    }
    while ( v8 > v10 + 1 )
    {
      if ( a2 >= *(_DWORD *)(transitions + 4 * ((v8 + v10) >> 1)) )
        v10 = (v8 + v10) >> 1;
      else
        v8 = (v8 + v10) >> 1;
    }
LABEL_11:
    v11 = v8 - 1;
    v12 = types + 8 * *(unsigned __int8 *)(type_idxs + v8 - 1);
    v13 = *(unsigned __int8 *)(v12 + 4);
    v14 = (void *)_tzstring((_BYTE *)(zone_names + *(unsigned __int8 *)(v12 + 5)));
    v15 = v8 < num_transitions;
    *(&tzname + v13) = v14;
    v16 = type_idxs;
    v17 = types;
    if ( v15 )
    {
      do
      {
        v18 = v17 + 8 * *(unsigned __int8 *)(v16 + v8);
        v19 = *(unsigned __int8 *)(v18 + 4);
        if ( !*(&tzname + v19) )
        {
          *(&tzname + v19) = (void *)_tzstring((_BYTE *)(zone_names + *(unsigned __int8 *)(v18 + 5)));
          v16 = type_idxs;
          v17 = types;
          if ( *(&tzname + 1 - v19) )
            break;
        }
        ++v8;
      }
      while ( num_transitions > v8 );
    }
    v20 = tzname;
    if ( !tzname )
    {
      v20 = off_80EBF20;
      tzname = off_80EBF20;
    }
    v21 = (char *)(v17 + 8 * *(unsigned __int8 *)(v16 + v11));
LABEL_19:
    daylight = rule_dstoff != rule_stdoff;
    timezone = -rule_stdoff;
    if ( !v20 )
    {
      if ( num_types != 1 )
        _assert_fail(a1, (int)"num_types == 1", (int)"tzfile.c", 800, "__tzfile_compute");
      tzname = (void *)_tzstring((_BYTE *)zone_names);
    }
    if ( !off_80EBF20 )
      off_80EBF20 = tzname;
    v22 = (unsigned __int8)v21[4];
    v23 = (int)*(&tzname + v22);
    a6[8] = v22;
    if ( j_strcmp(zone_names + (unsigned __int8)v21[5], v23) )
      _assert_fail(
        a1,
        (int)"strcmp (&zone_names[info->idx], __tzname[tp->tm_isdst]) == 0",
        (int)"tzfile.c",
        807,
        "__tzfile_compute");
    a6[10] = v23;
    a6[9] = *(_DWORD *)v21;
  }
  v24 = num_leaps;
  v25 = leaps;
LABEL_25:
  v26 = a2;
  *a4 = 0;
  *a5 = 0;
  result = v25 + 8 * v24 - 8;
  while ( v24 )
  {
    v28 = (_DWORD *)result;
    result -= 8;
    if ( *(_DWORD *)(result + 8) <= v26 )
    {
      result = v28[1];
      *a4 = result;
      if ( v26 == *v28 )
      {
        if ( v24 == 1 )
        {
          result = v28[1];
          if ( result > 0 || result > *(_DWORD *)(v25 - 4) )
          {
            result = (int)a5;
            *a5 = 1;
          }
        }
        else
        {
          v37 = (_DWORD *)(v25 + 8 * v24 - 16);
          v38 = v28[1];
          result = v37[1];
          if ( v38 > result )
          {
            v39 = *v37 + 1;
            *a5 = 1;
            if ( v26 == v39 && v38 == ++result )
            {
              v40 = (_DWORD *)(v25 + 8 * v24 - 24);
              v41 = 2;
              do
              {
                v43 = v41;
                if ( v24 == v41 )
                {
                  result = (int)a5;
                  *a5 = v24;
                  return result;
                }
                v42 = v40;
                if ( v40[2] != *v40 + 1 )
                {
                  result = (int)a5;
                  *a5 = v41;
                  return result;
                }
                ++v41;
                v40 -= 2;
              }
              while ( v42[3] == v42[1] + 1 );
              result = (int)a5;
              *a5 = v43;
            }
          }
        }
      }
      return result;
    }
    --v24;
  }
  return result;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80EBF1C: using guessed type void *tzname;
// 80EBF20: using guessed type void *off_80EBF20;
// 80EC6E0: using guessed type int timezone;
// 80EC6E4: using guessed type int daylight;
// 80EC748: using guessed type int tzspec;
// 80EC74C: using guessed type int leaps;
// 80EC750: using guessed type int num_leaps;
// 80EC754: using guessed type int rule_dstoff;
// 80EC758: using guessed type int rule_stdoff;
// 80EC75C: using guessed type int zone_names;
// 80EC760: using guessed type int types;
// 80EC764: using guessed type int num_types;
// 80EC768: using guessed type int type_idxs;
// 80EC76C: using guessed type int num_transitions;
// 80ECD9C: using guessed type int transitions;

//----- (08092060) --------------------------------------------------------
int *__userpurge _alloc_dir@<eax>(int a1@<eax>, char a2@<dl>, int a3@<ecx>, int a4)
{
  int v6; // eax
  unsigned int v7; // esi
  int *v8; // ecx

  if ( !a2 && (a3 & 0x80000) == 0 && fcntl(a1, 2) < 0 )
    return 0;
  v6 = 32796;
  v7 = 0x8000;
  if ( a4 )
  {
    v7 = 0x8000;
    if ( *(_DWORD *)(a4 + 52) >= 0x8000u )
      v7 = *(_DWORD *)(a4 + 52);
    if ( v7 > 0x100000 )
      v7 = 0x100000;
    v6 = v7 + 28;
  }
  v8 = (int *)malloc(v6);
  if ( !v8 )
  {
    v7 = 0x2000;
    v8 = (int *)malloc(8220);
    if ( !v8 )
    {
      if ( a2 )
      {
        __writegsdword((unsigned __int64)dl_sysinfo(0) >> 32, __readgsdword(0xFFFFFFE8));
        return v8;
      }
      return 0;
    }
  }
  *v8 = a1;
  v8[1] = 0;
  v8[2] = v7;
  v8[3] = 0;
  v8[4] = 0;
  v8[5] = 0;
  v8[6] = 0;
  return v8;
}
// 80920E7: variable 'v8' is possibly undefined
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08092150) --------------------------------------------------------
int *__usercall opendir_tail@<eax>(int a1@<eax>)
{
  int v2; // ecx
  char v4[16]; // [esp+0h] [ebp-6Ch] BYREF
  int v5; // [esp+10h] [ebp-5Ch]

  if ( a1 < 0 )
    return 0;
  if ( (_fxstat64(3, a1, (int)v4) & 0x80000000) == 0 )
  {
    if ( (v5 & 0xF000) == 0x4000 )
      return _alloc_dir(a1, 1, 0, (int)v4);
    __writegsdword(0xFFFFFFE8, 0x14u);
  }
  dl_sysinfo(v2);
  return 0;
}
// 80921B1: variable 'v2' is possibly undefined
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080921D0) --------------------------------------------------------
int *__fastcall _opendirat(int a1, _BYTE *a2)
{
  unsigned int v2; // eax

  if ( *a2 )
  {
    v2 = dl_sysinfo(a2);
    if ( v2 > 0xFFFFF000 )
      v2 = _syscall_error(v2);
    return opendir_tail(v2);
  }
  else
  {
    __writegsdword(0xFFFFFFE8, 2u);
    return 0;
  }
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08092220) --------------------------------------------------------
int *__cdecl opendir(_BYTE *a1)
{
  unsigned int v1; // eax

  if ( *a1 )
  {
    v1 = dl_sysinfo(624640);
    if ( v1 > 0xFFFFF000 )
      v1 = _syscall_error(v1);
    return opendir_tail(v1);
  }
  else
  {
    __writegsdword(0xFFFFFFE8, 2u);
    return 0;
  }
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08092270) --------------------------------------------------------
unsigned int __cdecl closedir(int a1)
{
  int v1; // ecx
  unsigned int result; // eax

  if ( a1 )
  {
    free(a1);
    result = dl_sysinfo(v1);
    if ( result > 0xFFFFF000 )
      return _syscall_error(result);
  }
  else
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    return -1;
  }
  return result;
}
// 809228C: variable 'v1' is possibly undefined
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080922D0) --------------------------------------------------------
int __cdecl readdir(int a1)
{
  unsigned int v3; // ebp
  bool v4; // zf
  unsigned int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // eax

  _ECX = 1;
  _EBX = a1;
  v3 = __readgsdword(0xFFFFFFE8);
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg [ebx+4], ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, (volatile __int32 *)(a1 + 4));
  v5 = *(_DWORD *)(a1 + 16);
  while ( 1 )
  {
    v8 = v5 + 28;
    if ( *(_DWORD *)(a1 + 12) <= v5 )
      break;
LABEL_6:
    v6 = a1 + v8;
    v5 += *(unsigned __int16 *)(v6 + 8);
    v7 = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(a1 + 16) = v5;
    *(_DWORD *)(a1 + 20) = v7;
    if ( *(_DWORD *)v6 )
      goto LABEL_12;
  }
  v9 = _getdents(*(_DWORD *)(a1 + 8), a1 + 28);
  if ( v9 > 0 )
  {
    *(_DWORD *)(a1 + 12) = v9;
    v8 = 28;
    v5 = 0;
    goto LABEL_6;
  }
  if ( !v9 || __readgsdword(0xFFFFFFE8) == 2 )
  {
    __writegsdword(0xFFFFFFE8, v3);
    v6 = 0;
  }
  else
  {
    v6 = 0;
  }
LABEL_12:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v4 = (*(_DWORD *)(a1 + 4))-- == 1;
  if ( !v4 )
    _lll_unlock_wake_private((_DWORD *)(a1 + 4));
  return v6;
}
// 8092373: variable 'v6' is possibly undefined

//----- (08092390) --------------------------------------------------------
int __cdecl rewinddir(int a1)
{
  bool v3; // zf
  int result; // eax

  _ECX = 1;
  _EBX = a1;
  v3 = __readgsdword(0xCu) == 0;
  if ( !v3 )
    __asm { lock }
  __asm { cmpxchg [ebx+4], ecx }
  if ( !v3 )
    _lll_lock_wait_private(0, (volatile __int32 *)(a1 + 4));
  result = lseek(*(_DWORD *)a1, 0);
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v3 = (*(_DWORD *)(a1 + 4))-- == 1;
  if ( !v3 )
    return _lll_unlock_wake_private((_DWORD *)(a1 + 4));
  return result;
}

//----- (08092400) --------------------------------------------------------
int __fastcall _getdents(int a1, unsigned int a2)
{
  unsigned int v2; // esi
  unsigned int v3; // eax
  int v4; // edi
  char v5; // bl
  int v6; // eax
  unsigned int i; // [esp+8h] [ebp-24h]
  int v9; // [esp+Ch] [ebp-20h]

  v2 = a2;
  v3 = dl_sysinfo(a2);
  v9 = v3;
  if ( v3 > 0xFFFFF000 )
    v9 = _syscall_error(v3);
  if ( v9 != -1 )
  {
    for ( i = v2 + v9; i > v2; v2 += v4 )
    {
      v4 = *(unsigned __int16 *)(v2 + 8);
      v5 = *(_BYTE *)(v2 + v4 - 1);
      v6 = strlen((_BYTE *)(v2 + 10));
      j_memmove(v2 + 11, v2 + 10, v6 + 1);
      *(_BYTE *)(v2 + 10) = v5;
    }
  }
  return v9;
}
// 80481D0: using guessed type int __cdecl j_memmove(_DWORD, _DWORD, _DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08092490) --------------------------------------------------------
int __cdecl readdir64(int a1)
{
  unsigned int v3; // ebp
  bool v4; // zf
  unsigned int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  signed int v9; // eax

  _ECX = 1;
  _EBX = a1;
  v3 = __readgsdword(0xFFFFFFE8);
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg [ebx+4], ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, (volatile __int32 *)(a1 + 4));
  v5 = *(_DWORD *)(a1 + 16);
  while ( 1 )
  {
    v8 = v5 + 28;
    if ( *(_DWORD *)(a1 + 12) <= v5 )
      break;
LABEL_6:
    v6 = a1 + v8;
    v5 += *(unsigned __int16 *)(v6 + 16);
    v7 = *(_DWORD *)(v6 + 8);
    *(_DWORD *)(a1 + 16) = v5;
    *(_DWORD *)(a1 + 20) = v7;
    if ( *(_QWORD *)v6 )
      goto LABEL_12;
  }
  v9 = _getdents64(*(_DWORD *)(a1 + 8), a1 + 28);
  if ( v9 > 0 )
  {
    *(_DWORD *)(a1 + 12) = v9;
    v8 = 28;
    v5 = 0;
    goto LABEL_6;
  }
  if ( !v9 || __readgsdword(0xFFFFFFE8) == 2 )
  {
    __writegsdword(0xFFFFFFE8, v3);
    v6 = 0;
  }
  else
  {
    v6 = 0;
  }
LABEL_12:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v4 = (*(_DWORD *)(a1 + 4))-- == 1;
  if ( !v4 )
    _lll_unlock_wake_private((_DWORD *)(a1 + 4));
  return v6;
}
// 8092533: variable 'v6' is possibly undefined

//----- (08092550) --------------------------------------------------------
int *__cdecl fdopendir(int a1)
{
  int v1; // eax
  char v3[16]; // [esp+4h] [ebp-6Ch] BYREF
  int v4; // [esp+14h] [ebp-5Ch]

  if ( (_fxstat64(3, a1, (int)v3) & 0x80000000) != 0 )
    return 0;
  if ( (v4 & 0xF000) != 0x4000 )
  {
    __writegsdword(0xFFFFFFE8, 0x14u);
    return 0;
  }
  v1 = fcntl(a1, 3);
  if ( v1 == -1 )
    return 0;
  if ( (v1 & 3) != 1 )
    return _alloc_dir(a1, 0, v1, (int)v3);
  __writegsdword(0xFFFFFFE8, 0x16u);
  return 0;
}

//----- (080925E0) --------------------------------------------------------
unsigned int __fastcall uname(int a1)
{
  unsigned int result; // eax

  result = dl_sysinfo(a1);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08092600) --------------------------------------------------------
__int64 __fastcall getuid(int a1)
{
  return dl_sysinfo(a1);
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08092610) --------------------------------------------------------
__int64 __fastcall geteuid(int a1)
{
  return dl_sysinfo(a1);
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08092620) --------------------------------------------------------
__int64 __fastcall getgid(int a1)
{
  return dl_sysinfo(a1);
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08092630) --------------------------------------------------------
__int64 __fastcall getegid(int a1)
{
  return dl_sysinfo(a1);
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08092640) --------------------------------------------------------
unsigned int __cdecl _lxstat64(int a1, int a2, int a3)
{
  unsigned int result; // eax

  result = dl_sysinfo(a3);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08092670) --------------------------------------------------------
int __cdecl _fxstatat64(int a1, int a2, int a3)
{
  unsigned int v3; // eax

  if ( a1 != 3 )
    return _syscall_error(-22);
  v3 = dl_sysinfo(a3);
  if ( v3 <= 0xFFFFF000 )
    return 0;
  else
    return _syscall_error(v3);
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080926C0) --------------------------------------------------------
unsigned int __cdecl lseek(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080926F0) --------------------------------------------------------
unsigned int __cdecl access(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08092720) --------------------------------------------------------
int __cdecl close(int a1)
{
  int result; // eax
  int v2; // eax
  unsigned int v3; // ecx
  unsigned int v4; // [esp-4h] [ebp-4h]

  if ( !__readgsdword(0xCu) )
    return _close_nocancel(a1);
  v2 = _libc_enable_asynccancel();
  v4 = dl_sysinfo(v2);
  _libc_disable_asynccancel(v3);
  result = v4;
  if ( v4 >= 0xFFFFF001 )
    return _syscall_error(v4);
  return result;
}
// 8092766: variable 'v3' is possibly undefined
// 809272A: using guessed type _DWORD __cdecl _close_nocancel(_DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0809272A) --------------------------------------------------------
unsigned int __fastcall _close_nocancel(int a1)
{
  unsigned int result; // eax

  result = dl_sysinfo(a1);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08092780) --------------------------------------------------------
_BOOL4 __cdecl isatty(int a1)
{
  char v2[72]; // [esp+Ch] [ebp-48h] BYREF

  return tcgetattr(a1, (int)v2) == 0;
}
// 8092780: using guessed type char var_48[72];

//----- (080927A0) --------------------------------------------------------
int __cdecl tcgetattr(int a1, int a2)
{
  unsigned int v2; // eax
  int v3; // ebx
  _WORD *v4; // eax
  int v6; // [esp+Ch] [ebp-30h]
  int v7; // [esp+10h] [ebp-2Ch]
  int v8; // [esp+14h] [ebp-28h]
  int v9; // [esp+18h] [ebp-24h]
  char v10; // [esp+1Ch] [ebp-20h]
  char v11[31]; // [esp+1Dh] [ebp-1Fh] BYREF

  v2 = dl_sysinfo(21505);
  v3 = v2;
  if ( v2 > 0xFFFFF000 )
    v3 = _syscall_error(v2);
  if ( !v3 )
  {
    *(_DWORD *)a2 = v6;
    *(_DWORD *)(a2 + 12) = v9;
    *(_DWORD *)(a2 + 4) = v7;
    *(_BYTE *)(a2 + 16) = v10;
    *(_DWORD *)(a2 + 8) = v8;
    *(_DWORD *)(a2 + 52) = v8 & 0x100F;
    *(_DWORD *)(a2 + 56) = v8 & 0x100F;
    v4 = mempcpy((_BYTE *)(a2 + 17), v11, 0x13u);
    *(_DWORD *)v4 = 0;
    *((_DWORD *)v4 + 1) = 0;
    *((_DWORD *)v4 + 2) = 0;
    *((_BYTE *)v4 + 12) = 0;
  }
  return v3;
}
// 80927DC: variable 'v6' is possibly undefined
// 80927E3: variable 'v9' is possibly undefined
// 80927EB: variable 'v7' is possibly undefined
// 80927F2: variable 'v10' is possibly undefined
// 80927F5: variable 'v8' is possibly undefined
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80927A0: using guessed type char var_1F[31];

//----- (08092850) --------------------------------------------------------
int __cdecl brk(unsigned int a1)
{
  int v1; // ecx

  _curbrk = dl_sysinfo(v1);
  if ( a1 > _curbrk )
    return _syscall_error(-12);
  else
    return 0;
}
// 809285A: variable 'v1' is possibly undefined
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EC788: using guessed type int _curbrk;

//----- (08092880) --------------------------------------------------------
int __cdecl writev(int a1, int a2, int a3)
{
  int result; // eax
  __int32 v4; // eax
  unsigned int v5; // [esp+0h] [ebp-4h] BYREF

  if ( !__readgsdword(0xCu) )
    return _writev_nocancel(a1, a2, a3);
  v5 = _libc_enable_asynccancel();
  v4 = dl_sysinfo(a2);
  _libc_disable_asynccancel(_InterlockedExchange((volatile __int32 *)&v5, v4));
  result = v5;
  if ( v5 >= 0xFFFFF001 )
    return _syscall_error(v5);
  return result;
}
// 809288A: using guessed type _DWORD __cdecl _writev_nocancel(_DWORD, _DWORD, _DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0809288A) --------------------------------------------------------
unsigned int __cdecl _writev_nocancel(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080928F0) --------------------------------------------------------
int __cdecl wctrans(int a1)
{
  int v1; // ebp
  _BYTE *v2; // ebx
  int v3; // esi

  v1 = *(_DWORD *)__readgsdword(0xFFFFFFD8);
  v2 = *(_BYTE **)(v1 + 80);
  if ( !*v2 )
    return 0;
  v3 = 0;
  while ( j_strcmp(a1, v2) )
  {
    ++v3;
    v2 = (_BYTE *)(j_rawmemchr(v2, 0) + 1);
    if ( !*v2 )
      return 0;
  }
  return *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 108) + v3) + 36);
}
// 80481E0: using guessed type int __cdecl j_rawmemchr(_DWORD, _DWORD);
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);

//----- (08092970) --------------------------------------------------------
unsigned int __cdecl towctrans(unsigned int a1, _DWORD *a2)
{
  unsigned int result; // eax
  unsigned int v3; // ebx
  int v4; // ebx
  int v5; // ecx

  result = a1;
  if ( a2 )
  {
    v3 = a1 >> *a2;
    if ( v3 < a2[1] )
    {
      v4 = a2[v3 + 5];
      if ( v4 )
      {
        v5 = *(_DWORD *)((char *)&a2[(a1 >> a2[2]) & a2[3]] + v4);
        if ( v5 )
          return *(_DWORD *)((char *)&a2[a1 & a2[4]] + v5) + a1;
      }
    }
  }
  return result;
}

//----- (080929C0) --------------------------------------------------------
int __cdecl _readonly_area(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // ebx
  unsigned int v3; // edi
  int *v4; // eax
  int *v5; // esi
  int v6; // eax
  int v7; // edx
  unsigned int v8; // ebp
  char *v9; // eax
  char *v10; // edx
  unsigned int v11; // eax
  char *v12; // edx
  unsigned int v13; // edx
  unsigned int v14; // edx
  unsigned int v16; // eax
  char *v17; // [esp+8h] [ebp-2Ch] BYREF
  unsigned int v18; // [esp+Ch] [ebp-28h] BYREF
  char *v19; // [esp+10h] [ebp-24h] BYREF
  char *v20; // [esp+14h] [ebp-20h] BYREF

  v2 = a2;
  v3 = a2 + a1;
  v4 = (int *)fopen((int)"/proc/self/maps", "rce");
  if ( v4 )
  {
    v5 = v4;
    v6 = *v4;
    v7 = v6;
    BYTE1(v7) = BYTE1(v6) | 0x80;
    *v5 = v7;
    v17 = 0;
    v18 = 0;
    if ( (v6 & 0x10) == 0 )
    {
      do
      {
        if ( getdelim((int *)&v17, &v18, 10, v5) <= 0 )
          break;
        v8 = strtoul(v17, &v19, 16);
        v9 = v19;
        if ( v19 == v17 )
          break;
        v10 = ++v19;
        if ( *v9 != 45 )
          break;
        v11 = strtoul(v10, &v20, 16);
        v12 = v20;
        if ( v20 == v19 )
          break;
        ++v20;
        if ( *v12 != 32 )
          break;
        if ( v3 > v8 && a1 < v11 )
        {
          v20 = v12 + 2;
          if ( v12[1] != 114 )
            break;
          v20 = v12 + 3;
          if ( v12[2] != 45 )
            break;
          if ( a1 >= v8 && v3 <= v11 )
          {
            v2 = 0;
            break;
          }
          if ( v8 <= a1 )
          {
            v2 = a1 + v2 - v11;
          }
          else
          {
            v13 = v2;
            v2 = v8 + v2 - v11;
            v14 = v8 + v13 - v3;
            if ( v3 <= v11 )
              v2 = v14;
          }
          if ( !v2 )
            break;
        }
      }
      while ( (*(_BYTE *)v5 & 0x10) == 0 );
    }
    fclose(v5);
    free(v17);
    if ( !v2 )
      return 1;
  }
  else
  {
    v16 = __readgsdword(0xFFFFFFE8);
    if ( v16 == 2 || v16 == 13 )
      return 1;
  }
  return -1;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08092B50) --------------------------------------------------------
int __usercall is_dst@<eax>(int a1@<eax>, char *a2@<edx>, _BYTE *a3@<ecx>, int a4, int a5)
{
  char v6; // al
  int v7; // ebx
  char v8; // di
  char v9; // al

  v6 = *a2;
  if ( *a2 == 123 )
  {
    v6 = a2[1];
    if ( v6 == *a3 )
    {
      if ( v6 )
      {
        ++a2;
        v8 = 1;
LABEL_4:
        v7 = 0;
        do
        {
          v6 = a2[++v7];
          if ( v6 != a3[v7] )
          {
            if ( !v8 )
              goto LABEL_26;
            goto LABEL_8;
          }
        }
        while ( v6 );
        if ( !v8 )
          goto LABEL_10;
        return 0;
      }
      return 0;
    }
    ++a2;
    v7 = 0;
LABEL_8:
    if ( v6 != 125 )
      return 0;
    --a2;
    v7 += 2;
  }
  else
  {
    v7 = 0;
    if ( v6 == *a3 )
    {
      v8 = 0;
      v7 = 0;
      if ( v6 )
        goto LABEL_4;
    }
    else
    {
LABEL_26:
      if ( v6 && v6 != 47 && (v6 != 58 || !a4) )
        return 0;
    }
  }
LABEL_10:
  if ( !a5 )
    return v7;
  v9 = a2[v7];
  if ( v9 && v9 != 47 && (v9 != 58 || !a4) )
    return 0;
  if ( a2 == (char *)(a1 + 1) )
    return v7;
  if ( !a4 )
    return 0;
  if ( *(a2 - 2) != 58 )
    return 0;
  return v7;
}

//----- (08092C40) --------------------------------------------------------
int __usercall is_trusted_path_normalize@<eax>(char *a1@<eax>, int a2@<edx>)
{
  char v2; // cl
  void *v3; // esp
  int *v4; // edx
  char v5; // bl
  char *v6; // eax
  int v7; // esi
  int *v8; // ebx
  int *v9; // ecx
  const char *v10; // edx
  int v11; // eax
  char v13; // si
  char v14; // si
  bool v15; // zf
  int v16; // [esp-Eh] [ebp-2Ch] BYREF
  int *v17; // [esp-Ah] [ebp-28h]
  const char *v18; // [esp-6h] [ebp-24h]
  unsigned int v19; // [esp-2h] [ebp-20h]

  if ( !a2 )
    return 0;
  v2 = *a1;
  if ( *a1 == 58 )
  {
    v2 = a1[1];
    --a2;
    ++a1;
  }
  v3 = alloca(a2 + 17);
  v4 = &v16;
LABEL_6:
  if ( v2 )
  {
    do
    {
      v5 = a1[1];
      LOBYTE(v19) = v5;
      if ( v2 != 47 )
      {
LABEL_5:
        *(_BYTE *)v4 = v2;
        v2 = v19;
        ++a1;
        v4 = (int *)((char *)v4 + 1);
        goto LABEL_6;
      }
      if ( v5 == 46 )
      {
        v13 = a1[2];
        if ( v13 == 46 )
        {
          v14 = a1[3];
          if ( v14 == 47 || !v14 )
          {
            if ( v4 > &v16 )
            {
              v15 = *((_BYTE *)v4 - 1) == 47;
              v4 = (int *)((char *)v4 - 1);
              if ( !v15 )
              {
                do
                {
                  if ( v4 == &v16 )
                    break;
                  v4 = (int *)((char *)v4 - 1);
                }
                while ( *(_BYTE *)v4 != 47 );
              }
            }
            a1 += 3;
            v2 = v14;
            goto LABEL_6;
          }
        }
        else if ( v13 == 47 || !v13 )
        {
          a1 += 2;
          v2 = v13;
          goto LABEL_6;
        }
      }
      if ( v4 <= &v16 || *((_BYTE *)v4 - 1) != 47 )
        goto LABEL_5;
      v2 = v19;
      ++a1;
    }
    while ( (_BYTE)v19 );
  }
  if ( v4 == &v16 || (v6 = (char *)v4, *((_BYTE *)v4 - 1) != 47) )
  {
    v6 = (char *)v4 + 1;
    *(_BYTE *)v4 = 47;
  }
  v7 = 7;
  v8 = (int *)&system_dirs_len;
  v19 = v6 - (char *)&v16;
  v9 = (int *)&unk_80CE4BC;
  v10 = "/lib32/";
  if ( (unsigned int)(v6 - (char *)&v16) < 7 )
    goto LABEL_17;
  while ( 1 )
  {
    v17 = v9;
    v18 = v10;
    v11 = j_memcmp(v10, &v16, v7);
    v10 = v18;
    v9 = v17;
    if ( !v11 )
      break;
LABEL_17:
    if ( v9 == ++v8 )
      return 0;
    while ( 1 )
    {
      v10 += v7 + 1;
      v7 = *v8;
      if ( *v8 <= v19 )
        break;
      if ( v9 == ++v8 )
        return 0;
    }
  }
  return 1;
}
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);

//----- (08092DC0) --------------------------------------------------------
_BYTE *__usercall add_name_to_object@<eax>(int a1@<eax>, _BYTE *a2@<edx>, long double a3@<st0>)
{
  _DWORD *v4; // ebx
  _BYTE *result; // eax
  int v6; // eax
  unsigned int v7; // ebp
  int v8; // eax
  _DWORD *v9; // edi
  int v10; // eax

  v4 = *(_DWORD **)(a1 + 28);
  if ( !v4 )
  {
    v10 = strlen(a2);
    if ( malloc(v10 + 13) )
      _assert_fail("lastp != NULL", "dl-load.c", 416, "add_name_to_object");
    goto LABEL_9;
  }
  while ( 1 )
  {
    result = (_BYTE *)j_strcmp(a2, *v4);
    if ( !result )
      return result;
    if ( !v4[1] )
      break;
    v4 = (_DWORD *)v4[1];
  }
  v6 = strlen(a2);
  v7 = v6 + 1;
  v8 = malloc(v6 + 13);
  v9 = (_DWORD *)v8;
  if ( !v8 )
LABEL_9:
    dl_signal_error(12, a2, 0, a3, "cannot allocate name record");
  result = memcpy((_BYTE *)(v8 + 12), a2, v7);
  *v9 = result;
  v9[1] = 0;
  v9[2] = 0;
  v4[1] = v9;
  return result;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);

//----- (08092EA0) --------------------------------------------------------
void __usercall __noreturn lose_isra_5(
        signed int a1@<eax>,
        int a2@<edx>,
        _BYTE *a3@<ecx>,
        long double a4@<st0>,
        int a5,
        int a6,
        const char *a7,
        int a8)
{
  if ( a2 != -1 )
    close(a2);
  if ( a6 && *(_DWORD *)(a6 + 424) != -1 )
    free(*(_DWORD *)(a6 + 424));
  free(a6);
  free(a5);
  if ( a8 )
  {
    *(_DWORD *)(a8 + 12) = 0;
    a4 = dl_debug_state();
  }
  dl_signal_error(a1, a3, 0, a4, a7);
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 8070160: using guessed type long double dl_debug_state(void);

//----- (08092F20) --------------------------------------------------------
int __usercall open_verify_constprop_7@<eax>(
        _BYTE *a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        long double a4@<st0>,
        _BYTE *a5,
        int a6)
{
  int v7; // ebx
  int v8; // eax
  unsigned __int8 v9; // al
  signed int v10; // edi
  __int16 v11; // ax
  int v12; // eax
  int v13; // edx
  int v14; // edi
  _DWORD *v15; // ebx
  unsigned int v16; // esi
  int v17; // eax
  _BYTE *v18; // edi
  unsigned int v19; // eax
  const char *v21; // ebx
  void *v22; // esp
  int v23; // eax
  void *v24; // esp
  _BYTE *v25; // esi
  char v26; // al
  bool v27; // dl
  unsigned __int8 v28; // al
  void *v29; // esp
  int v30; // [esp+0h] [ebp-40h]
  _BYTE v31[8]; // [esp+8h] [ebp-38h] BYREF
  int v32; // [esp+10h] [ebp-30h]
  int v33; // [esp+14h] [ebp-2Ch]
  _BYTE *v34; // [esp+18h] [ebp-28h]
  int v35; // [esp+1Ch] [ebp-24h]
  int v36; // [esp+20h] [ebp-20h]
  unsigned int v37; // [esp+24h] [ebp-1Ch]

  v37 = a3;
  v34 = a1;
  v33 = a6;
  v36 = open((int)a1, 0x80000, v30);
  if ( v36 == -1 )
    return v36;
  v7 = 0;
  __writegsdword(0xFFFFFFE8, 0);
  *(_DWORD *)a2 = 0;
  v35 = a2 + 4;
  while ( 1 )
  {
    v8 = read(v36, v35 + v7, 512 - v7);
    if ( v8 <= 0 )
      break;
    v7 = *(_DWORD *)a2 + v8;
    *(_DWORD *)a2 = v7;
    if ( (unsigned int)v7 > 0x33 )
      goto LABEL_5;
  }
  v7 = *(_DWORD *)a2;
LABEL_5:
  if ( v7 <= 51 )
  {
    v21 = "cannot read file data";
    v10 = __readgsdword(0xFFFFFFE8);
    if ( !v10 )
      v21 = "file too short";
    goto LABEL_38;
  }
  if ( j_memcmp(v35, &expected_9888, 8) && j_memcmp(v35, &expected2_9887, 8)
    || (v9 = *(_BYTE *)(a2 + 12)) != 0 && (*(_BYTE *)(a2 + 11) != 3 || v9 > 2u)
    || (v10 = j_memcmp(a2 + 13, &unk_80CE4A5, 7)) != 0 )
  {
    if ( *(_DWORD *)(a2 + 4) == 1179403647 )
    {
      if ( *(_BYTE *)(a2 + 8) != 1 )
      {
        *a5 = 1;
        goto LABEL_44;
      }
      if ( *(_WORD *)(a2 + 22) != 3 )
        goto LABEL_44;
      v10 = 0;
      v21 = "ELF file data encoding not little-endian";
      if ( *(_BYTE *)(a2 + 9) == 1 )
      {
        v21 = "ELF file version ident does not match current one";
        if ( *(_BYTE *)(a2 + 10) == 1 )
        {
          v26 = *(_BYTE *)(a2 + 11);
          v27 = v26 != 3;
          if ( !v26 || (v21 = "ELF file OS ABI invalid", v26 == 3) )
          {
            v28 = *(_BYTE *)(a2 + 12);
            if ( v28 && (v28 > 2u || v27) )
            {
              v10 = 0;
              v21 = "ELF file ABI version invalid";
            }
            else
            {
              v21 = "internal error";
              v10 = j_memcmp(a2 + 13, &unk_80CE4A5, 7);
              if ( v10 )
              {
                v10 = 0;
                v21 = "nonzero padding in e_ident";
              }
            }
          }
        }
      }
    }
    else
    {
      v10 = 0;
      v21 = "invalid ELF header";
    }
LABEL_38:
    if ( (_BYTE)v33 )
    {
      v23 = strlen(v34);
      v24 = alloca(v23 + 16);
      v25 = memcpy(v31, v34, v23 + 1);
      free(v34);
      v34 = v25;
    }
    lose_isra_5(v10, v36, v34, a4, 0, 0, v21, 0);
  }
  if ( *(_DWORD *)(a2 + 24) != 1 )
  {
    v21 = "ELF file version does not match current one";
    goto LABEL_38;
  }
  if ( *(_WORD *)(a2 + 22) != 3 )
    goto LABEL_44;
  v11 = *(_WORD *)(a2 + 20);
  if ( (unsigned __int16)(v11 - 2) > 1u )
  {
    v21 = "only ET_DYN and ET_EXEC can be loaded";
    goto LABEL_38;
  }
  if ( v11 == 2 && (v37 & 0x20000000) == 0 )
  {
    v21 = "cannot dynamically load executable";
    goto LABEL_38;
  }
  if ( *(_WORD *)(a2 + 46) != 32 )
  {
    v21 = "ELF file's phentsize not the expected size";
    goto LABEL_38;
  }
  v12 = *(unsigned __int16 *)(a2 + 48);
  v13 = *(_DWORD *)(a2 + 32);
  v14 = 32 * v12;
  if ( 32 * v12 + v13 > (unsigned int)v7 )
  {
    v22 = alloca((v14 + 30) & 0x3FFFF0);
    v37 = (unsigned int)v31;
    lseek(v36, v13);
    if ( v14 != read(v36, (int)v31, v14) )
    {
LABEL_60:
      v21 = "cannot read file data";
      v10 = __readgsdword(0xFFFFFFE8);
      goto LABEL_38;
    }
    v12 = *(unsigned __int16 *)(a2 + 48);
    v14 = 32 * v12;
  }
  else
  {
    v37 = v35 + v13;
  }
  if ( v37 >= v37 + v14 )
    return v36;
  v15 = (_DWORD *)v37;
  v32 = a2;
  while ( 1 )
  {
    if ( *v15 != 4 )
      goto LABEL_18;
    v16 = v15[4];
    if ( v16 <= 0x1F || v15[7] <= 3u )
      goto LABEL_18;
    v17 = v15[1];
    if ( v16 + v17 <= *(_DWORD *)v32 )
    {
      v18 = (_BYTE *)(v35 + v17);
      goto LABEL_26;
    }
    v29 = alloca(v16 + 15);
    v18 = v31;
    lseek(v36, v17);
    if ( v16 != read(v36, (int)v31, v16) )
      goto LABEL_60;
LABEL_26:
    while ( j_memcmp(v18, &expected_note_9894, 16) )
    {
      v19 = ((*(_DWORD *)v18 + 3) & 0xFFFFFFFC) + ((*((_DWORD *)v18 + 1) + 3) & 0xFFFFFFFC) + 12;
      if ( v19 > v16 - 32 )
        goto LABEL_45;
      v16 -= v19;
      v18 += v19;
    }
    if ( v16 )
      break;
LABEL_45:
    v12 = *(unsigned __int16 *)(v32 + 48);
LABEL_18:
    v15 += 8;
    if ( (unsigned int)v15 >= v37 + 32 * v12 )
      return v36;
  }
  if ( !*((_DWORD *)v18 + 4)
    && (!dl_osversion
     || (unsigned __int8)v18[28] + (((unsigned __int8)v18[24] + ((unsigned __int8)v18[20] << 8)) << 8) <= (unsigned int)dl_osversion) )
  {
    return v36;
  }
LABEL_44:
  close(v36);
  v36 = -1;
  __writegsdword(0xFFFFFFE8, 2u);
  return -1;
}
// 8092F3D: variable 'v30' is possibly undefined
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80ECCC0: using guessed type int dl_osversion;

//----- (080933F0) --------------------------------------------------------
int __usercall open_path@<eax>(
        _BYTE *a1@<eax>,
        unsigned int a2@<edx>,
        unsigned int a3@<ecx>,
        long double a4@<st0>,
        int *a5,
        _DWORD *a6,
        int a7,
        int a8,
        int a9,
        _BYTE *a10)
{
  void *v10; // esp
  int v11; // edi
  int v12; // ebx
  int v13; // esi
  _WORD *v14; // eax
  unsigned int v15; // edx
  int v16; // eax
  _WORD *v17; // eax
  char *v18; // eax
  const char *v19; // edx
  int v20; // eax
  _BYTE *v21; // eax
  _BYTE *v22; // edx
  int v23; // edx
  unsigned int v25; // eax
  int v26; // eax
  int *v27; // ecx
  unsigned int v28; // eax
  const char *v29; // eax
  void *v30; // esp
  int v31; // eax
  char *v32; // esi
  int *v33; // ebx
  int *v34; // eax
  unsigned int v35; // ebx
  int *v36; // edi
  const char *v37; // eax
  char *v38; // eax
  const char *v39; // edx
  int v40; // [esp+0h] [ebp-B8h] BYREF
  int v41; // [esp+4h] [ebp-B4h]
  int *v42; // [esp+8h] [ebp-B0h]
  const char *v43; // [esp+Ch] [ebp-ACh]
  const char *v44; // [esp+10h] [ebp-A8h]
  const char *v45; // [esp+14h] [ebp-A4h]
  int v46; // [esp+18h] [ebp-A0h]
  int *v47; // [esp+1Ch] [ebp-9Ch]
  const char *v48; // [esp+20h] [ebp-98h]
  int v49; // [esp+24h] [ebp-94h]
  unsigned int v50; // [esp+28h] [ebp-90h]
  _BYTE *v51; // [esp+2Ch] [ebp-8Ch]
  unsigned int v52; // [esp+30h] [ebp-88h]
  int *v53; // [esp+34h] [ebp-84h]
  int v54; // [esp+38h] [ebp-80h]
  int *v55; // [esp+3Ch] [ebp-7Ch]
  char v56[16]; // [esp+40h] [ebp-78h] BYREF
  int v57; // [esp+50h] [ebp-68h]

  v47 = (int *)*a5;
  if ( !v47 )
    return -1;
  v51 = a1;
  v50 = a3;
  v52 = a2;
  v46 = 0;
  v48 = 0;
  v10 = alloca(a2 + max_dirnamelen + max_capstrlen + 15);
  v55 = &v40;
  v11 = *v47;
  v49 = a3 & 0x4000000;
  while ( 2 )
  {
    if ( (dl_debug_mask & 1) != 0 )
    {
      v44 = *(const char **)(v11 + 4);
      if ( v48 != v44 )
      {
        v29 = *(const char **)(v11 + 8);
        v42 = &v40;
        v43 = v29;
        v30 = alloca(max_dirnamelen + max_capstrlen);
        v53 = &v40;
        dl_debug_printf(" search path=");
        v31 = *v47;
        if ( *v47 )
        {
          v45 = *(const char **)(v31 + 4);
          if ( v45 == v44 )
          {
            v32 = (char *)v53;
            v33 = v47;
            v54 = 1;
            v41 = v11;
            v48 = (char *)v53 + 1;
            do
            {
              v53 = (int *)mempcpy(v32, *(_BYTE **)(v31 + 12), *(_DWORD *)(v31 + 16));
              if ( ncapstr )
              {
                v34 = v33;
                v35 = 0;
                v36 = v34;
                do
                {
                  if ( *(_DWORD *)(*v36 + 4 * v35 + 20) != 1 )
                  {
                    v37 = (const char *)mempcpy(v53, *(_BYTE **)(capstr + 8 * v35), *(_DWORD *)(capstr + 8 * v35 + 4));
                    if ( v32 == v37 || v37 == v48 && *v32 == 47 )
                      *v37 = 0;
                    else
                      *((_BYTE *)v37 - 1) = 0;
                    v38 = "%s";
                    if ( !v54 )
                      v38 = ":%s";
                    dl_debug_printf_c(v38, v32);
                    v54 = 0;
                  }
                  ++v35;
                }
                while ( v35 < ncapstr );
                v33 = v36;
              }
              v31 = *++v33;
            }
            while ( *v33 && v45 == *(const char **)(v31 + 4) );
            v11 = v41;
          }
        }
        if ( v43 )
        {
          if ( !*v43 )
          {
            v39 = "<main program>";
            if ( program_invocation_short_name )
              v39 = (const char *)program_invocation_short_name;
            v43 = v39;
          }
          dl_debug_printf_c("\t\t(%s from file %s)\n", v44, v43);
        }
        else
        {
          dl_debug_printf_c("\t\t(%s)\n", v44);
        }
        v48 = v44;
      }
    }
    v12 = 1;
    v13 = 0;
    v14 = mempcpy(v55, *(_BYTE **)(v11 + 12), *(_DWORD *)(v11 + 16));
    v15 = ncapstr;
    v54 = (int)v14;
    while ( v15 > v12 - 1 )
    {
      if ( *(_DWORD *)(v11 + 4 * v12 + 16) != 1 )
      {
        v17 = mempcpy((_BYTE *)v54, *(_BYTE **)(capstr + 8 * v12 - 8), *(_DWORD *)(capstr + 8 * v12 - 8 + 4));
        v18 = (char *)mempcpy(v17, v51, v52);
        v53 = (int *)(v18 - (char *)v55);
        if ( (dl_debug_mask & 1) != 0 )
          dl_debug_printf("  trying file=%s\n", (const char *)v55);
        v19 = (const char *)open_verify_constprop_7(v55, a7, v50, a4, a10, 0);
        v20 = *(_DWORD *)(v11 + 4 * v12 + 16);
        if ( v20 )
        {
          v13 |= v20 != 1;
          if ( v19 == (const char *)-1 )
            goto LABEL_9;
          if ( !v49 )
          {
LABEL_18:
            v54 = (int)v19;
            v21 = (_BYTE *)malloc(v53);
            v22 = (_BYTE *)v54;
            *a6 = v21;
            if ( v21 )
            {
              v54 = (int)v22;
              memcpy(v21, v55, (unsigned int)v53);
              return v54;
            }
            close((int)v22);
            return -1;
          }
        }
        else
        {
          if ( v19 == (const char *)-1 )
          {
            if ( a8 && (v26 = 1, (*((_BYTE *)*(&dl_ns + 19 * *(_DWORD *)(a8 + 24)) + 405) & 8) != 0) )
            {
LABEL_32:
              v13 |= v26;
            }
            else
            {
              v27 = v55;
              *((_BYTE *)v53 + (_DWORD)v55 + ~v52) = 0;
              if ( _xstat64(3, (int)v27, (int)v56) || (v57 & 0xF000) != 0x4000 )
              {
                *(_DWORD *)(v11 + 4 * v12 + 16) = 1;
                v26 = 0;
                goto LABEL_32;
              }
              *(_DWORD *)(v11 + 4 * v12 + 16) = 2;
              v13 |= 1u;
            }
LABEL_9:
            v15 = ncapstr;
            goto LABEL_10;
          }
          v16 = v49;
          *(_DWORD *)(v11 + 4 * v12 + 16) = 2;
          v13 = 1;
          if ( !v16 )
            goto LABEL_18;
        }
        if ( !_libc_enable_secure
          || (v45 = v19, v28 = _fxstat64(3, (int)v19, (int)v56), v19 = v45, !v28) && (v57 & 0x800) != 0 )
        {
          if ( v19 != (const char *)-1 )
            goto LABEL_18;
          goto LABEL_9;
        }
        close((int)v45);
        v15 = ncapstr;
        __writegsdword(0xFFFFFFE8, 2u);
      }
LABEL_10:
      ++v12;
    }
    if ( !v13 || (v25 = __readgsdword(0xFFFFFFE8), v25 == 13) || v25 == 2 )
    {
      ++v47;
      v46 |= v13;
      v11 = *v47;
      if ( *v47 )
        continue;
      if ( !v46 )
      {
        if ( a5[1] )
          free(*a5);
        if ( a5 != &rtld_search_dirs && a5 != &env_path_list )
        {
          v23 = -1;
          *a5 = -1;
          return v23;
        }
      }
    }
    return -1;
  }
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80EAFD0: using guessed type int rtld_search_dirs;
// 80EAFD8: using guessed type int max_capstrlen;
// 80EAFDC: using guessed type int ncapstr;
// 80EAFE0: using guessed type int capstr;
// 80EAFE4: using guessed type int env_path_list;
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80EBA40: using guessed type void *dl_ns;
// 80EC78C: using guessed type int max_dirnamelen;
// 80ECC60: using guessed type int dl_debug_mask;

//----- (08093970) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __usercall dl_map_object_from_fd_constprop_8@<eax>(
        _BYTE *a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        long double a4@<st0>,
        _BYTE *a5,
        int a6,
        char a7,
        int a8,
        int a9,
        int a10)
{
  int i; // edi
  int v13; // eax
  int v14; // esi
  int v15; // edx
  int v16; // eax
  int v17; // ebx
  int *v18; // esi
  void *v19; // esp
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // edx
  int v24; // eax
  int v25; // eax
  int v26; // ebx
  int v27; // edx
  int *v28; // eax
  int v29; // ecx
  int v30; // ebx
  int v31; // ecx
  int v32; // ecx
  int v33; // edx
  bool v34; // cc
  char v35; // bl
  int v36; // edx
  int v37; // ebx
  int v38; // esi
  unsigned int v39; // eax
  int v40; // ecx
  int v41; // eax
  bool v42; // zf
  unsigned int *v43; // ebx
  unsigned int v44; // eax
  unsigned int v45; // ecx
  unsigned int v46; // eax
  unsigned int v47; // ecx
  unsigned int v48; // ecx
  unsigned int v49; // eax
  const char *v50; // ebx
  int v51; // eax
  void *v52; // esp
  int v53; // edx
  int v54; // esi
  unsigned int *v55; // edx
  unsigned int v56; // eax
  int j; // ebx
  unsigned int v58; // ecx
  int v59; // eax
  int v60; // eax
  int v61; // eax
  int v62; // eax
  int v63; // eax
  int v64; // eax
  int v65; // eax
  int v66; // eax
  int v67; // eax
  int v68; // eax
  int v69; // eax
  int v70; // edx
  int v71; // eax
  int v72; // eax
  int v73; // eax
  int v74; // edx
  int v75; // eax
  int v76; // eax
  int v77; // eax
  int v78; // edx
  _DWORD *v79; // eax
  int v80; // edx
  int v81; // edx
  __int64 v82; // xmm1_8
  _DWORD *tls; // eax
  int v84; // ecx
  int v85; // eax
  int v86; // ecx
  int v87; // eax
  int v88; // ecx
  unsigned int v89; // eax
  unsigned int v90; // ecx
  unsigned int v91; // eax
  unsigned int v92; // eax
  int v93; // eax
  unsigned int v94; // ebx
  _BYTE *v95; // eax
  _BYTE *v96; // eax
  int v97; // [esp-8h] [ebp-E0h]
  _BYTE v98[3]; // [esp+0h] [ebp-D8h] BYREF
  char v99; // [esp+3h] [ebp-D5h] BYREF
  int v100; // [esp+8h] [ebp-D0h]
  int v101; // [esp+Ch] [ebp-CCh]
  int v102; // [esp+10h] [ebp-C8h]
  _BYTE *v103; // [esp+14h] [ebp-C4h]
  char v104; // [esp+1Bh] [ebp-BDh]
  signed int stack_executable_hook; // [esp+1Ch] [ebp-BCh]
  __int64 v106; // [esp+20h] [ebp-B8h]
  int v107; // [esp+28h] [ebp-B0h]
  int v108; // [esp+2Ch] [ebp-ACh]
  _DWORD *v109; // [esp+30h] [ebp-A8h]
  unsigned int v110; // [esp+34h] [ebp-A4h]
  int v111; // [esp+38h] [ebp-A0h]
  _BYTE *v112; // [esp+3Ch] [ebp-9Ch]
  __int64 v113; // [esp+40h] [ebp-98h]
  int v114; // [esp+48h] [ebp-90h]
  unsigned int *v115; // [esp+4Ch] [ebp-8Ch]
  unsigned int v116; // [esp+50h] [ebp-88h]
  unsigned int v117; // [esp+54h] [ebp-84h]
  int v118; // [esp+58h] [ebp-80h]
  int *v119; // [esp+5Ch] [ebp-7Ch]
  __int64 v120; // [esp+60h] [ebp-78h] BYREF
  int v121; // [esp+68h] [ebp-70h]
  int v122; // [esp+6Ch] [ebp-6Ch]
  __int64 v123; // [esp+B8h] [ebp-20h]

  v111 = a2;
  v112 = a1;
  v107 = a3;
  v109 = dl_debug_initialize(0, a10);
  if ( (_fxstat64(3, a2, (int)&v120) & 0x80000000) != 0 )
  {
    v104 = 0;
    v50 = "cannot stat shared object";
    i = 0;
LABEL_86:
    stack_executable_hook = __readgsdword(0xFFFFFFE8);
    goto LABEL_66;
  }
  v106 = v120;
  v113 = v123;
  for ( i = (int)*(&dl_ns + 19 * a10); i; i = *(_DWORD *)(i + 12) )
  {
    if ( (*(_BYTE *)(i + 405) & 0x20) == 0 && *(_QWORD *)(i + 472) == v106 && *(_QWORD *)(i + 480) == v113 )
    {
      close(v111);
      free(a5);
      add_name_to_object(i, v112, a4);
      return i;
    }
  }
  stack_executable_hook = a8 & 4;
  if ( (a8 & 4) != 0 )
  {
    i = 0;
    free(a5);
    close(v111);
    return i;
  }
  if ( (dl_debug_mask & 0x40) != 0 )
    dl_debug_printf("file=%s [%lu];  generating link map\n", v112, a10);
  v13 = v109[3];
  if ( v13 )
  {
    if ( v13 != 1 )
      _assert_fail("r->r_state == RT_ADD", "dl-load.c", 1003, "_dl_map_object_from_fd");
    v104 = 0;
  }
  else
  {
    v109[3] = 1;
    dl_debug_state();
    v104 = 1;
  }
  i = dl_new_object(a5, v112, a7, a6, a8, a10);
  if ( !i )
  {
    v50 = "cannot create shared object descriptor";
    goto LABEL_86;
  }
  v14 = v107;
  v15 = *(_DWORD *)(v107 + 32);
  *(_DWORD *)(i + 340) = *(_DWORD *)(v107 + 28);
  LOWORD(v101) = *(_WORD *)(v14 + 20);
  v16 = *(unsigned __int16 *)(v14 + 48);
  *(_WORD *)(i + 344) = v16;
  v17 = 32 * v16;
  if ( (unsigned int)(32 * v16 + v15) > *(_DWORD *)v14 )
  {
    v52 = alloca((v17 + 30) & 0x3FFFF0);
    v119 = (int *)v98;
    lseek(v111, v15);
    if ( v17 != read(v111, (int)v98, v17) )
    {
      v50 = "cannot read file data";
      goto LABEL_86;
    }
    v16 = *(unsigned __int16 *)(i + 344);
    v17 = 32 * v16;
  }
  else
  {
    v119 = (int *)(v14 + v15 + 4);
  }
  v18 = v119;
  v103 = v98;
  v19 = alloca((24 * v16 + 18) & 0x3FFFF0);
  v102 = (unsigned int)&v99 >> 2;
  v115 = (unsigned int *)v98;
  if ( v119 >= &v119[v17 / 4u] )
    goto LABEL_168;
  v108 = 7;
  LOBYTE(v110) = 0;
  v118 = 0;
  do
  {
    v20 = *v18;
    if ( *v18 == 6 )
    {
      *(_DWORD *)(i + 336) = v18[2];
    }
    else if ( (unsigned int)*v18 > 6 )
    {
      switch ( v20 )
      {
        case 1685382481:
          v108 = v18[6];
          break;
        case 1685382482:
          *(_DWORD *)(i + 588) = v18[2];
          *(_DWORD *)(i + 592) = v18[5];
          break;
        case 7:
          v21 = v18[5];
          if ( v21 )
          {
            *(_DWORD *)(i + 564) = v21;
            v22 = v18[7];
            *(_DWORD *)(i + 568) = v22;
            if ( v22 )
            {
              v23 = v18[2];
              *(_DWORD *)(i + 572) = v23 & (v22 - 1);
            }
            else
            {
              *(_DWORD *)(i + 572) = 0;
              v23 = v18[2];
            }
            v24 = v18[4];
            *(_DWORD *)(i + 556) = v23;
            *(_DWORD *)(i + 560) = v24;
            if ( (*(_BYTE *)(i + 404) & 3) == 1 || dl_tls_dtv_slotinfo_list )
            {
              *(_DWORD *)(i + 580) = dl_next_tls_modid();
            }
            else
            {
              if ( dl_tls_setup() || (tls = (_DWORD *)dl_allocate_tls(0)) == 0 )
              {
                stack_executable_hook = 12;
                v50 = "cannot allocate TLS data structures for initial thread";
                goto LABEL_66;
              }
              *tls = tls;
              tls[2] = tls;
              tls[4] = dl_sysinfo;
              LODWORD(v120) = -1;
              HIDWORD(v120) = tls;
              v121 = 0xFFFFF;
              v122 = 81;
              if ( (unsigned int)dl_sysinfo(tls) )
              {
                v50 = "set_thread_area failed when setting up thread-local storage\n";
                dl_deallocate_tls(v84, 1);
                goto LABEL_66;
              }
              *(_DWORD *)(i + 580) = ++dl_tls_max_dtv_idx;
            }
          }
          break;
      }
    }
    else if ( v20 == 1 )
    {
      v25 = v18[7];
      v114 = dl_pagesize - 1;
      if ( (v25 & (dl_pagesize - 1)) != 0 )
      {
        v50 = "ELF load command alignment not page-aligned";
        goto LABEL_66;
      }
      v26 = v18[2];
      v117 = v18[1];
      if ( ((v25 - 1) & (v26 - v117)) != 0 )
      {
        v50 = "ELF load command address/offset not properly aligned";
        goto LABEL_66;
      }
      v27 = -dl_pagesize;
      v116 = v118 + 1;
      v28 = (int *)&v115[6 * v118];
      *v28 = -dl_pagesize & v26;
      v29 = v26 + v18[4];
      v30 = v18[5] + v26;
      v28[2] = v29;
      v31 = v28[2] + v114;
      v28[3] = v30;
      v32 = v27 & v31;
      v33 = v117 & v27;
      v34 = v116 <= 1;
      v28[1] = v32;
      v28[4] = v33;
      if ( !v34 )
      {
        v35 = v110;
        if ( *(v28 - 5) != *v28 )
          v35 = 1;
        LOBYTE(v110) = v35;
      }
      v115[6 * v118 + 5] = (1934713408 >> (4 * (v18[6] & 7))) & 0xF;
      v118 = v116;
    }
    else if ( v20 == 2 )
    {
      *(_DWORD *)(i + 8) = v18[2];
      *(_WORD *)(i + 346) = (unsigned int)v18[5] >> 3;
    }
    v18 += 8;
  }
  while ( v18 < &v119[8 * *(unsigned __int16 *)(i + 344)] );
  v36 = v118;
  if ( !v118 )
  {
LABEL_168:
    v50 = "object file has no loadable segments";
    goto LABEL_66;
  }
  v114 = (unsigned __int16)v101;
  if ( (unsigned __int16)v101 != 3 )
  {
    if ( (a8 & 0x20000000) != 0 )
    {
      v43 = v115;
      v85 = *(_DWORD *)(4 * v102);
      v86 = v115[6 * v118 - 3] - v85;
      v87 = *(_DWORD *)i + v85;
      v118 = v86;
      *(_DWORD *)(i + 428) = v87;
      *(_DWORD *)(i + 432) = v86 + v87;
      *(_BYTE *)(i + 405) = ((((unsigned __int8)v110 ^ 1) & 1) << 6) | *(_BYTE *)(i + 405) & 0xBF;
      goto LABEL_61;
    }
    stack_executable_hook = 0;
    v50 = "cannot dynamically load executable";
LABEL_66:
    v51 = 0;
    if ( v104 )
      v51 = (int)v109;
    lose_isra_5(stack_executable_hook, v111, v112, a4, (int)a5, i, v50, v51);
  }
  v117 = v118;
  v37 = *(_DWORD *)(4 * v102);
  v38 = *(_DWORD *)(4 * v102 + 0x14);
  v118 = v115[6 * v118 - 3] - v37;
  v39 = mmap(v37 & dl_use_load_bias, v118, v38, 2050, v111, *(_DWORD *)(4 * v102 + 0x10));
  *(_DWORD *)(i + 428) = v39;
  v36 = v117;
  if ( v39 == -1 )
  {
LABEL_162:
    v50 = "failed to map segment from shared object";
    goto LABEL_66;
  }
  v40 = v39 + v118;
  v41 = v39 - v37;
  v42 = (_BYTE)v110 == 0;
  *(_DWORD *)(i + 432) = v40;
  *(_DWORD *)i = v41;
  if ( !v42 )
  {
    v88 = *(_DWORD *)(4 * v102 + 4);
    v97 = 0;
    v117 = v36;
    mprotect(v88 + v41, v115[6 * v36 - 6] - v88);
    v36 = v117;
  }
  *(_BYTE *)(i + 405) |= 0x40u;
  v43 = v115;
  while ( 1 )
  {
    if ( (v38 & 4) != 0 )
      *(_DWORD *)(i + 436) = *(_DWORD *)i + v43[1];
    if ( !*(_DWORD *)(i + 336) )
    {
      v90 = v43[4];
      v117 = *(_DWORD *)(v107 + 32);
      if ( v90 <= v117 )
      {
        v91 = *v43;
        v110 = v90;
        v116 = v91;
        if ( v90 + v43[1] - v91 >= v117 + 32 * *(unsigned __int16 *)(v107 + 48) )
          *(_DWORD *)(i + 336) = v116 + v117 - v110;
      }
    }
    v44 = v43[3];
    v45 = v43[2];
    if ( v44 > v45 )
    {
      v46 = *(_DWORD *)i + v44;
      v117 = *(_DWORD *)i + v45;
      v116 = v46;
      v102 = dl_pagesize;
      v110 = -dl_pagesize;
      v101 = -dl_pagesize;
      v47 = -dl_pagesize & (v117 + dl_pagesize - 1);
      if ( v46 <= v47 )
        v47 = v116;
      v110 = v47;
      if ( v117 < v47 )
      {
        if ( (v38 & 2) != 0 )
        {
          v102 = v36;
          j_memset(v117, 0, v110 - v117);
          v36 = v102;
        }
        else
        {
          v100 = v36;
          v97 = v38 | 2;
          if ( (mprotect(v117 & v101, v102) & 0x80000000) != 0 )
          {
            stack_executable_hook = 0;
            v50 = "cannot change memory protections";
            goto LABEL_66;
          }
          v102 = v100;
          j_memset(v117, 0, v110 - v117);
          v97 = v38;
          mprotect(v117 & -dl_pagesize, dl_pagesize);
          v36 = v102;
        }
      }
      if ( v116 > v110 )
      {
        v117 = v36;
        v92 = mmap(v110, v116 - v110, v38, 50, -1, 0);
        v36 = v117;
        if ( v92 == -1 )
        {
          v50 = "cannot map zero-fill pages";
          goto LABEL_66;
        }
      }
    }
    v43 += 6;
LABEL_61:
    if ( v43 >= &v115[6 * v36] )
      break;
    v48 = v43[1];
    v49 = *v43;
    if ( v48 > *v43 )
    {
      v38 = v43[5];
      v117 = v36;
      v89 = mmap(*(_DWORD *)i + v49, v48 - v49, v38, 2066, v111, v43[4]);
      v36 = v117;
      if ( v89 == -1 )
        goto LABEL_162;
    }
    else
    {
      v38 = v43[5];
    }
  }
  v53 = *(_DWORD *)(i + 8);
  if ( !v53 )
  {
    if ( v114 == 3 )
    {
      v50 = "object file has no dynamic section";
      goto LABEL_66;
    }
LABEL_169:
    v74 = *(_DWORD *)(i + 516);
    goto LABEL_127;
  }
  v54 = *(_DWORD *)i;
  v55 = (unsigned int *)(*(_DWORD *)i + v53);
  *(_DWORD *)(i + 8) = v55;
  if ( !v55 )
    goto LABEL_169;
  v56 = *v55;
  for ( j = i + 32; *v55; v56 = *v55 )
  {
    if ( v56 > 0x21 )
    {
      if ( 1879048191 - v56 > 0xF )
      {
        v58 = (int)(2 * v56) >> 1;
        if ( v58 <= 0xFFFFFFFC )
        {
          if ( 1879047679 - v56 > 0xB )
          {
            if ( 1879047935 - v56 <= 0xA )
              *(_DWORD *)(j - 4 * v56 - 1073742592) = v55;
          }
          else
          {
            *(_DWORD *)(j - 4 * v56 - 1073743664) = v55;
          }
        }
        else
        {
          *(_DWORD *)(j + 4 * ~v58 + 200) = v55;
        }
        goto LABEL_78;
      }
      v56 = 1879048225 - v56;
    }
    *(_DWORD *)(j + 4 * v56) = v55;
LABEL_78:
    v55 += 2;
  }
  if ( v54 )
  {
    v59 = *(_DWORD *)(i + 48);
    if ( v59 )
      *(_DWORD *)(v59 + 4) += v54;
    v60 = *(_DWORD *)(i + 44);
    if ( v60 )
      *(_DWORD *)(v60 + 4) += v54;
    v61 = *(_DWORD *)(i + 52);
    if ( v61 )
      *(_DWORD *)(v61 + 4) += v54;
    v62 = *(_DWORD *)(i + 56);
    if ( v62 )
      *(_DWORD *)(v62 + 4) += v54;
    v63 = *(_DWORD *)(i + 60);
    if ( v63 )
      *(_DWORD *)(v63 + 4) += v54;
    v64 = *(_DWORD *)(i + 100);
    if ( v64 )
      *(_DWORD *)(v64 + 4) += v54;
    v65 = *(_DWORD *)(i + 124);
    if ( v65 )
      *(_DWORD *)(v65 + 4) += v54;
    v66 = *(_DWORD *)(i + 228);
    if ( v66 )
      *(_DWORD *)(v66 + 4) += v54;
    v67 = *(_DWORD *)(i + 332);
    if ( v67 )
      *(_DWORD *)(v67 + 4) += v54;
  }
  v68 = *(_DWORD *)(i + 112);
  if ( v68 )
  {
    v69 = *(_DWORD *)(v68 + 4);
    if ( v69 != 17 && v69 != 7 )
      _assert_fail(
        "info[DT_PLTREL]->d_un.d_val == DT_REL || info[DT_PLTREL]->d_un.d_val == DT_RELA",
        "get-dynamic-info.h",
        124,
        "elf_get_dynamic_info");
  }
  if ( *(_DWORD *)(i + 60) && *(_DWORD *)(*(_DWORD *)(i + 68) + 4) != 12 )
    _assert_fail(
      "info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela))",
      "get-dynamic-info.h",
      129,
      "elf_get_dynamic_info");
  if ( *(_DWORD *)(i + 100) && *(_DWORD *)(*(_DWORD *)(i + 108) + 4) != 8 )
    _assert_fail("info[DT_RELENT]->d_un.d_val == sizeof (ElfW(Rel))", "get-dynamic-info.h", 133, "elf_get_dynamic_info");
  v70 = *(_DWORD *)(i + 152);
  if ( v70 )
  {
    v71 = *(_DWORD *)(v70 + 4);
    *(_DWORD *)(i + 520) = v71;
    if ( (v71 & 2) != 0 )
      *(_DWORD *)(i + 96) = v70;
    if ( (v71 & 4) != 0 )
      *(_DWORD *)(i + 120) = v70;
    if ( (v71 & 8) != 0 )
      *(_DWORD *)(i + 128) = v70;
  }
  v72 = *(_DWORD *)(i + 184);
  if ( v72 )
  {
    v42 = (dl_debug_mask & 0x40) == 0;
    v73 = *(_DWORD *)(v72 + 4);
    *(_DWORD *)(i + 516) = v73;
    LOBYTE(v74) = v73;
    if ( !v42 && (v73 & 0xFFFFF716) != 0 )
    {
      dl_debug_printf("\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\n", v73 & 0xFFFFF716);
      v74 = *(_DWORD *)(i + 516);
      LOBYTE(v73) = v74;
    }
    if ( (v73 & 1) != 0 )
      *(_DWORD *)(i + 128) = *(_DWORD *)(i + 184);
  }
  else
  {
    v74 = *(_DWORD *)(i + 516);
  }
  if ( *(_DWORD *)(i + 148) )
    *(_DWORD *)(i + 92) = 0;
LABEL_127:
  if ( (v74 & 0x40) != 0 && a8 < 0 )
  {
    munmap(*(_DWORD *)(i + 428), *(_DWORD *)(i + 432) - *(_DWORD *)(i + 428));
    if ( !*(_DWORD *)(*(_DWORD *)(i + 28) + 8) )
      free(*(_DWORD *)(i + 28));
    v50 = "shared object cannot be dlopen()ed";
    if ( *(char *)(i + 404) < 0 )
      free(*(_DWORD *)(i + 336));
    goto LABEL_66;
  }
  v75 = *(_DWORD *)(i + 336);
  if ( !v75 )
  {
    v94 = 32 * *(unsigned __int16 *)(v107 + 48);
    v95 = (_BYTE *)malloc(v94);
    if ( v95 )
    {
      v96 = memcpy(v95, v119, v94);
      *(_BYTE *)(i + 404) |= 0x80u;
      *(_DWORD *)(i + 336) = v96;
      goto LABEL_131;
    }
    v50 = "cannot allocate memory for program header";
    goto LABEL_86;
  }
  *(_DWORD *)(i + 336) = *(_DWORD *)i + v75;
LABEL_131:
  if ( ((unsigned __int8)v108 & (unsigned __int8)~(_BYTE)dl_stack_flags & 1) != 0 )
  {
    _stack_prot |= 7u;
    stack_executable_hook = dl_make_stack_executable_hook();
    if ( stack_executable_hook )
    {
      v50 = "cannot enable executable stack as shared object requires";
      goto LABEL_66;
    }
  }
  v76 = *(_DWORD *)(i + 556);
  if ( v76 )
    *(_DWORD *)(i + 556) = *(_DWORD *)i + v76;
  if ( close(v111) )
  {
    v50 = "cannot close file descriptor";
    goto LABEL_86;
  }
  if ( v114 == 2 && (*(_BYTE *)(i + 404) & 3) != 0 )
    _assert_fail("type != ET_EXEC || l->l_type == lt_executable", "dl-load.c", 1348, "_dl_map_object_from_fd");
  v77 = *(_DWORD *)i;
  v78 = *(_DWORD *)i + *(_DWORD *)(i + 340);
  v42 = (dl_debug_mask & 0x40) == 0;
  *(_DWORD *)(i + 340) = v78;
  if ( !v42 )
    dl_debug_printf(
      "  dynamic: 0x%0*lx  base: 0x%0*lx   size: 0x%0*Zx\n    entry: 0x%0*lx  phdr: 0x%0*lx  phnum:   %*u\n\n",
      8,
      *(_DWORD *)(i + 8),
      8,
      v77,
      8,
      v118,
      8,
      v78,
      8,
      *(_DWORD *)(i + 336),
      8,
      *(unsigned __int16 *)(i + 344));
  dl_setup_hash((_DWORD *)i);
  if ( (a8 & 8) == 0 )
  {
    if ( *(_DWORD *)(i + 96) )
    {
      v79 = *(_DWORD **)(i + 460);
      if ( *v79 != i + 348 )
      {
        **(_DWORD **)(i + 356) = i;
        v80 = *(_DWORD *)(i + 456);
        *(_DWORD *)(i + 360) = 1;
        j_memmove(v79 + 1, v79, 4 * v80 - 4);
        **(_DWORD **)(i + 460) = i + 356;
      }
    }
  }
  if ( (*(_BYTE *)(i + 516) & 0x20) != 0 )
    dl_initfirst = i;
  v81 = dl_profile;
  v82 = v113;
  *(_QWORD *)(i + 472) = v106;
  *(_QWORD *)(i + 480) = v82;
  if ( v81 )
  {
    v93 = *(_DWORD *)(i + 88);
    if ( v93 )
      add_name_to_object(i, (_BYTE *)(*(_DWORD *)(*(_DWORD *)(i + 52) + 4) + *(_DWORD *)(v93 + 4)), a4);
  }
  dl_add_to_namespace_list(i, a10);
  return i;
}
// 80945FD: write access to const memory at 80EAFEC has been detected
// 8094329: variable 'v84' is possibly undefined
// 80481D0: using guessed type int __cdecl j_memmove(_DWORD, _DWORD, _DWORD);
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 8070160: using guessed type int dl_debug_state(void);
// 80EAFEC: using guessed type int _stack_prot;
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EB9F4: using guessed type int (*dl_make_stack_executable_hook)(void);
// 80EB9F8: using guessed type int dl_stack_flags;
// 80EBA08: using guessed type int dl_pagesize;
// 80EBA40: using guessed type void *dl_ns;
// 80EBD0C: using guessed type int dl_use_load_bias;
// 80ECA08: using guessed type int dl_tls_max_dtv_idx;
// 80ECC20: using guessed type int dl_tls_dtv_slotinfo_list;
// 80ECC60: using guessed type int dl_debug_mask;
// 80ECC68: using guessed type int dl_profile;
// 80ECCB8: using guessed type int dl_initfirst;

//----- (08094890) --------------------------------------------------------
int __usercall add_path_isra_4_constprop_9@<eax>(int result@<eax>, int *a2@<edx>)
{
  int *v2; // esi
  int v3; // ebx
  _DWORD *v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // ebp
  unsigned int v9; // edx
  _BYTE *v10; // ecx
  _WORD *v11; // eax

  if ( a2 != (int *)-1 )
  {
    v2 = a2;
    v3 = result;
    result = *a2;
    do
    {
      while ( 1 )
      {
        ++v2;
        if ( *(_BYTE *)v3 )
          break;
        v6 = *(_DWORD *)(v3 + 4);
        v7 = v6 + 1;
        v8 = *(_DWORD *)(v3 + 8) + 8 * v6;
        v9 = *(_DWORD *)(result + 16);
        *(_DWORD *)(v3 + 4) = v7;
        v10 = *(_BYTE **)(v3 + 12);
        *(_DWORD *)(v8 + 8) = v10;
        if ( v9 <= 1 )
        {
          *(_DWORD *)(v3 + 12) = v10 + 1;
          *v10 = (v9 != 0) + 46;
          v11 = *(_WORD **)(v3 + 12);
        }
        else
        {
          v11 = mempcpy(v10, *(_BYTE **)(result + 12), v9 - 1);
        }
        *(_DWORD *)(v3 + 12) = (char *)v11 + 1;
        *(_BYTE *)v11 = 0;
        result = *v2;
        *(_DWORD *)(v8 + 12) = 0;
        if ( !result )
          return result;
      }
      v4 = *(_DWORD **)(v3 + 8);
      v5 = 2;
      ++v4[1];
      if ( *(_DWORD *)(result + 16) >= 2u )
        v5 = *(_DWORD *)(result + 16);
      result = *v2;
      *v4 += v5;
    }
    while ( result );
  }
  return result;
}

//----- (08094940) --------------------------------------------------------
int __cdecl dl_dst_count(int a1, int a2)
{
  int v2; // esi
  int v3; // eax
  char *v4; // ebx
  int v5; // eax

  v2 = 0;
  v3 = a1;
  do
  {
    v4 = (char *)(v3 + 1);
    v5 = is_dst(a1, (char *)(v3 + 1), "ORIGIN", a2, _libc_enable_secure);
    if ( v5 || (v5 = is_dst(a1, v4, "PLATFORM", a2, 0)) != 0 || (v5 = is_dst(a1, v4, "LIB", a2, 0)) != 0 )
      ++v2;
    v3 = j_strchr(&v4[v5], 36);
  }
  while ( v3 );
  return v2;
}
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 80EAFCC: using guessed type int _libc_enable_secure;

//----- (080949E0) --------------------------------------------------------
char *__cdecl dl_dst_substitute(int a1, _BYTE *a2, char *a3, int a4)
{
  _BYTE *v4; // esi
  char v5; // cl
  char *v6; // edi
  char *v7; // ebp
  _BYTE *v8; // ebx
  unsigned int v9; // edx
  const char *v10; // eax
  char v11; // al
  char *result; // eax
  bool v13; // zf
  char v14; // [esp+7h] [ebp-25h]
  char *v15; // [esp+8h] [ebp-24h]
  unsigned int v16; // [esp+Ch] [ebp-20h]
  char v17; // [esp+Ch] [ebp-20h]

  v4 = a2;
  v14 = 0;
  v5 = *a2;
  v15 = a3;
  v6 = a3;
  while ( v5 != 36 )
  {
    *v6 = v5;
    v7 = v6 + 1;
    v8 = v4 + 1;
    v5 = v4[1];
    if ( a4 && v5 == 58 )
    {
      if ( v14 )
      {
        v17 = v4[1];
        v14 = is_trusted_path_normalize(v15, v7 - v15);
        v5 = v17;
        if ( v14 )
        {
          v15 = v6 + 1;
          v14 = 0;
        }
        else
        {
          v7 = v15;
        }
      }
      else
      {
        v15 = v6 + 1;
      }
      goto LABEL_3;
    }
LABEL_2:
    if ( !v5 )
      goto LABEL_19;
LABEL_3:
    v6 = v7;
    v4 = v8;
  }
  v8 = v4 + 1;
  v9 = is_dst((int)a2, v4 + 1, "ORIGIN", a4, _libc_enable_secure);
  if ( v9 )
  {
    v14 = 0;
    v10 = *(const char **)(a1 + 424);
    if ( _libc_enable_secure )
      v14 = (*(_BYTE *)(a1 + 404) & 3) == 0;
LABEL_12:
    if ( (unsigned int)(v10 - 1) <= 0xFFFFFFFD )
      goto LABEL_24;
    goto LABEL_13;
  }
  v9 = is_dst((int)a2, v4 + 1, "PLATFORM", a4, 0);
  v10 = (const char *)dl_platform;
  if ( v9 )
    goto LABEL_12;
  v9 = is_dst((int)a2, v4 + 1, "LIB", a4, 0);
  if ( !v9 )
    goto LABEL_25;
  v10 = "lib32";
  if ( (unsigned int)&aLib32[-1] <= 0xFFFFFFFD )
  {
LABEL_24:
    v16 = v9;
    v7 = (char *)j_stpcpy(v6, v10);
    v8 += v16;
    v5 = *v8;
    goto LABEL_2;
  }
LABEL_13:
  if ( v9 <= 1 )
  {
LABEL_25:
    *v6 = 36;
    v7 = v6 + 1;
    v5 = v4[1];
    goto LABEL_2;
  }
  v8 += v9;
  v11 = *v8;
  if ( *v8 )
  {
    while ( v11 != 58 || !a4 )
    {
      v11 = *++v8;
      if ( !*v8 )
        goto LABEL_18;
    }
    if ( v15 != a3 )
    {
      v5 = *v8;
      v7 = v15;
      goto LABEL_3;
    }
    v5 = v8[1];
    if ( v5 )
    {
      ++v8;
      v7 = v15;
      goto LABEL_3;
    }
    v5 = *v8;
    v7 = v15;
    goto LABEL_2;
  }
LABEL_18:
  v7 = v15;
LABEL_19:
  if ( v14 )
  {
    v13 = (unsigned __int8)is_trusted_path_normalize(v15, v7 - v15) == 0;
    result = a3;
    if ( v13 )
      v7 = v15;
    *v7 = 0;
  }
  else
  {
    *v7 = 0;
    return a3;
  }
  return result;
}
// 8094BA0: conditional instruction was optimized away because %arg_C.4!=0
// 8048210: using guessed type int __cdecl j_stpcpy(_DWORD, _DWORD);
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80ECC80: using guessed type int dl_platform;

//----- (08094C40) --------------------------------------------------------
char *__usercall expand_dynamic_string_token@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v6; // eax
  char *result; // eax
  int v8; // ebp
  int v9; // ecx
  _BYTE *origin; // eax
  unsigned int v11; // eax
  unsigned int v12; // edx
  int v13; // [esp+14h] [ebp-20h]
  int v14; // [esp+14h] [ebp-20h]

  v6 = j_strchr(a2, 36);
  if ( !v6 )
    return strdup(a2);
  v8 = dl_dst_count(v6, a3);
  if ( !v8 )
    return strdup(a2);
  v9 = strlen(a2);
  origin = *(_BYTE **)(a1 + 424);
  if ( !origin )
  {
    if ( **(_BYTE **)(a1 + 4) )
      _assert_fail("(l)->l_name[0] == '\\0' || IS_RTLD (l)", "dl-load.c", 379, "expand_dynamic_string_token");
    v14 = v9;
    origin = (_BYTE *)dl_get_origin();
    *(_DWORD *)(a1 + 424) = origin;
    v9 = v14;
    if ( (unsigned int)(origin - 1) <= 0xFFFFFFFD )
      goto LABEL_7;
LABEL_16:
    v11 = 0;
    goto LABEL_8;
  }
  if ( origin == (_BYTE *)-1 )
    goto LABEL_16;
LABEL_7:
  v13 = v9;
  v11 = strlen(origin);
  v9 = v13;
LABEL_8:
  v12 = 5;
  if ( (unsigned int)dl_platformlen >= 5 )
    v12 = dl_platformlen;
  if ( v12 < v11 )
    v12 = v11;
  result = (char *)malloc(v9 + (v12 - 4) * v8 + 1);
  if ( result )
    return dl_dst_substitute(a1, a2, result, a3);
  return result;
}
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80ECC5C: using guessed type int dl_platformlen;

//----- (08094D50) --------------------------------------------------------
_DWORD *__usercall fillin_rpath@<eax>(
        _BYTE *a1@<eax>,
        _DWORD *a2@<edx>,
        char *a3@<ecx>,
        long double a4@<st0>,
        int a5,
        int a6,
        _BYTE *a7,
        int a8)
{
  _BYTE *v9; // eax
  char *v10; // esi
  unsigned int v11; // eax
  unsigned int v12; // ebx
  int v13; // edx
  _DWORD *v14; // ebp
  int v15; // eax
  int *v16; // eax
  int *v17; // ecx
  _WORD *v18; // eax
  int *v19; // edx
  bool v20; // cc
  int v21; // eax
  int v22; // ecx
  _BYTE *v23; // eax
  int v24; // eax
  unsigned int v25; // edi
  int v26; // ebx
  const char *v27; // ebp
  int *v28; // esi
  char *v30; // [esp+8h] [ebp-34h]
  unsigned int v31; // [esp+Ch] [ebp-30h]
  char *v32; // [esp+Ch] [ebp-30h]
  int v34; // [esp+14h] [ebp-28h]
  int *v35; // [esp+18h] [ebp-24h]
  _DWORD *v36; // [esp+18h] [ebp-24h]
  _BYTE *v37; // [esp+1Ch] [ebp-20h] BYREF

  v37 = a1;
  v34 = 0;
LABEL_2:
  while ( 1 )
  {
    v9 = strsep(&v37, a3);
    if ( !v9 )
      break;
    v10 = expand_dynamic_string_token(a8, v9, 1);
    v11 = strlen(v10);
    v12 = v11;
    v30 = (char *)&curwd_9710;
    if ( !v11 )
      goto LABEL_12;
    if ( v11 > 1 )
    {
      v13 = v11 - 1;
      if ( v10[v11 - 1] != 47 )
      {
        v30 = v10;
        v12 = v11 + 1;
        v10[v11] = 47;
        goto LABEL_37;
      }
      while ( v13 != 1 )
      {
        if ( v10[v13 - 1] != 47 )
          goto LABEL_36;
        --v13;
      }
    }
    if ( *v10 == 47 )
    {
      v30 = v10;
      v12 = 1;
LABEL_12:
      if ( !a5 )
        goto LABEL_13;
      goto LABEL_38;
    }
    v13 = 1;
LABEL_36:
    v12 = v13 + 1;
    v10[v13] = 47;
    v30 = v10;
LABEL_37:
    if ( !a5 )
      goto LABEL_13;
LABEL_38:
    v36 = a2;
    v25 = v12;
    v26 = 7;
    v32 = v10;
    v27 = "/lib32/";
    v28 = (int *)&system_dirs_len;
    if ( v25 == 7 )
      goto LABEL_41;
    do
    {
      do
      {
        if ( &unk_80CE4BC == (_UNKNOWN *)++v28 )
        {
          a2 = v36;
          free(v32);
          goto LABEL_2;
        }
        v27 += v26 + 1;
        v26 = *v28;
      }
      while ( *v28 != v25 );
LABEL_41:
      ;
    }
    while ( j_memcmp(v27, v30, v26) );
    v12 = v25;
    v10 = v32;
    a2 = v36;
LABEL_13:
    v14 = (_DWORD *)dl_all_dirs;
    if ( dl_all_dirs )
    {
      while ( v12 != v14[4] || j_memcmp(v30, v14[3], v12) )
      {
        v14 = (_DWORD *)*v14;
        if ( !v14 )
          goto LABEL_25;
      }
      if ( v34 )
      {
        if ( v14 == (_DWORD *)*a2 )
          goto LABEL_24;
        v15 = 0;
        while ( v34 != ++v15 )
        {
          if ( v14 == (_DWORD *)a2[v15] )
            goto LABEL_24;
        }
      }
      a2[v34++] = v14;
    }
    else
    {
LABEL_25:
      if ( a7 )
        v31 = strlen(a7) + 1;
      else
        v31 = 0;
      v16 = (int *)malloc(v31 + v12 + 4 * ncapstr + 20 + 1);
      if ( !v16 )
        dl_signal_error(12, 0, 0, a4, "cannot create cache for search path");
      v35 = v16;
      v17 = &v16[ncapstr + 5];
      v16[3] = (int)v17;
      v18 = mempcpy(v17, v30, v12);
      v19 = v35;
      v20 = v12 <= max_dirnamelen;
      *(_BYTE *)v18 = 0;
      v35[4] = v12;
      if ( !v20 )
        max_dirnamelen = v12;
      v21 = 0;
      v22 = 2 * (*v30 != 47);
      if ( ncapstr )
      {
        do
          v35[v21++ + 5] = v22;
        while ( v21 != ncapstr );
      }
      v35[1] = a6;
      if ( a7 )
      {
        v23 = memcpy((_BYTE *)&v35[v21 + 5] + v12 + 1, a7, v31);
        v19 = v35;
        v35[2] = (int)v23;
      }
      else
      {
        v35[2] = 0;
      }
      v24 = dl_all_dirs;
      dl_all_dirs = (int)v19;
      *v19 = v24;
      a2[v34++] = v19;
    }
LABEL_24:
    free(v10);
  }
  a2[v34] = 0;
  return a2;
}
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EAFDC: using guessed type int ncapstr;
// 80EC78C: using guessed type int max_dirnamelen;
// 80ECCBC: using guessed type int dl_all_dirs;

//----- (080950A0) --------------------------------------------------------
int __usercall cache_rpath_part_6@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, long double a4@<st0>, int a5)
{
  int v6; // ecx
  int v7; // ebp
  char *v8; // ecx
  char *v9; // esi
  _BYTE *v10; // ebp
  int v11; // ebx
  char *v12; // eax
  char *v13; // esi
  char v14; // al
  int v15; // ecx
  char *v16; // edx
  _DWORD *v17; // eax
  _DWORD *v18; // ebp
  char v20; // dl
  char v21; // bl
  _BYTE *v22; // esi
  int v23; // ebp
  char *v24; // edx
  char v25; // al
  char v26; // al
  const char *v27; // eax
  char *v28; // [esp+18h] [ebp-24h]
  char v29; // [esp+1Fh] [ebp-1Dh]

  v6 = *(_DWORD *)(a1 + 4 * a3 + 32);
  if ( v6 )
  {
    v7 = *(_DWORD *)(v6 + 4);
    v8 = (char *)dl_inhibit_rpath;
    v9 = *(char **)(a1 + 4);
    v10 = (_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) + v7);
    v28 = v9;
    if ( dl_inhibit_rpath && !_libc_enable_secure )
    {
      v20 = *v9;
      v21 = *(_BYTE *)dl_inhibit_rpath;
      v22 = v10;
      v23 = a1;
      v29 = v20;
      do
      {
        if ( v29 == v21 )
        {
          if ( !v29 )
            goto LABEL_8;
          v24 = v28;
          while ( 1 )
          {
            ++v8;
            ++v24;
            v21 = *v8;
            v25 = *v24;
            if ( *v8 != *v24 )
              break;
            if ( !v21 )
              goto LABEL_8;
          }
        }
        else
        {
          v25 = v29;
        }
        if ( !v25 && (!v21 || v21 == 58) )
          goto LABEL_8;
        do
        {
          v26 = *v8;
          if ( !*v8 )
            goto LABEL_23;
          ++v8;
        }
        while ( v26 != 58 );
        v21 = *v8;
      }
      while ( *v8 );
LABEL_23:
      a1 = v23;
      v10 = v22;
    }
    v11 = a1;
    v12 = strdup(v10);
    v13 = v12;
    if ( !v12 )
    {
      v27 = "cannot create RUNPATH/RPATH copy";
      goto LABEL_28;
    }
    v14 = *v12;
    v15 = 0;
    v16 = v13;
    if ( v14 )
    {
      do
      {
        ++v16;
        v15 += v14 == 58;
        v14 = *v16;
      }
      while ( *v16 );
      v17 = (_DWORD *)malloc(4 * v15 + 8);
      v18 = v17;
      if ( v17 )
      {
        fillin_rpath(v13, v17, ":", a4, 0, a5, v28, v11);
        free(v13);
        *a2 = v18;
        a2[1] = 1;
        return 1;
      }
      free(v13);
      v27 = "cannot create cache for search path";
LABEL_28:
      dl_signal_error(12, 0, 0, a4, v27);
    }
    free(v13);
    *a2 = -1;
    return 0;
  }
  else
  {
LABEL_8:
    *a2 = -1;
    return 0;
  }
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80ECCC4: using guessed type int dl_inhibit_rpath;

//----- (08095270) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_DWORD *__usercall dl_init_paths@<eax>(_BYTE *a1@<eax>, long double a2@<st0>)
{
  unsigned int v2; // edi
  _DWORD *v3; // eax
  _DWORD *v4; // ecx
  int v5; // edx
  _DWORD *v6; // ebx
  int *v7; // edi
  const char *v8; // ecx
  int v9; // edx
  int v10; // edx
  bool v11; // zf
  int v12; // edx
  _DWORD *result; // eax
  _BYTE *v14; // ebx
  int v15; // eax
  void *v16; // esp
  _BYTE *v17; // eax
  char v18; // dl
  _BYTE *v19; // esi
  int v20; // eax
  _BYTE *v21; // ecx
  _DWORD *v22; // eax
  const char *v23; // eax
  char v24[12]; // [esp+Ch] [ebp-38h] BYREF
  _BYTE *v25; // [esp+18h] [ebp-2Ch]
  int v26; // [esp+1Ch] [ebp-28h]
  unsigned int v27; // [esp+20h] [ebp-24h]
  _DWORD *v28; // [esp+24h] [ebp-20h]
  _DWORD *v29; // [esp+28h] [ebp-1Ch]

  v25 = a1;
  capstr = (int)dl_important_hwcaps(dl_platform, dl_platformlen, &ncapstr, a2, &max_capstrlen);
  v28 = (_DWORD *)malloc(a2, 0x14u);
  rtld_search_dirs = (int)v28;
  if ( !v28 )
  {
    v23 = "cannot create search path array";
LABEL_20:
    dl_signal_error(12, 0, 0, a2, v23);
  }
  v2 = (4 * ncapstr + 39) / 0x14u;
  v3 = (_DWORD *)malloc(a2, 720 * v2);
  *v28 = v3;
  if ( !v3 )
    goto LABEL_19;
  v4 = v28;
  dword_80EAFD4 = 0;
  dl_all_dirs = (int)v3;
  v3[1] = "system search path";
  v3[2] = 0;
  v3[3] = "/lib32/";
  v3[4] = 7;
  v27 = 20 * v2;
  v29 = v4 + 4;
  v5 = -20 * v2;
  v6 = v4 + 1;
  v7 = (int *)&system_dirs_len;
  v8 = "/usr/lib32/";
  v26 = v5;
  while ( 1 )
  {
    v9 = 0;
    if ( ncapstr )
    {
      do
        v3[v9++ + 5] = 0;
      while ( ncapstr != v9 );
    }
    if ( v29 == v6 )
      break;
    v3 = (_DWORD *)((char *)v3 + v27);
    ++v6;
    ++v7;
    *(_DWORD *)((char *)v3 + v26) = v3;
    v10 = *v7;
    v11 = *v8 == 47;
    *(v6 - 1) = v3;
    v3[1] = "system search path";
    v3[2] = 0;
    v3[4] = v10;
    v3[3] = v8;
    v12 = (int)&v8[v10 + 1];
    if ( !v11 )
      _assert_fail(a2, (int)"pelem->dirname[0] == '/'", (int)"dl-load.c", 719, "_dl_init_paths");
    v8 = (const char *)v12;
  }
  *v3 = 0;
  max_dirnamelen = 11;
  v28[4] = 0;
  result = v25;
  if ( !v25 || (result = v25, !*v25) )
  {
    env_path_list = -1;
    return result;
  }
  LOBYTE(v29) = *v25;
  v14 = v25;
  v15 = strlen(v25);
  v16 = alloca(v15 + 16);
  v17 = memcpy(v24, v25, v15 + 1);
  v18 = (char)v29;
  v19 = v17;
  v20 = 1;
  v21 = v14;
  do
  {
    v20 += (unsigned __int8)(v18 - 58) < 2u;
    v18 = *++v21;
  }
  while ( *v21 );
  v22 = (_DWORD *)malloc(a2, 4 * v20 + 4);
  env_path_list = (int)v22;
  if ( !v22 )
  {
LABEL_19:
    v23 = "cannot create cache for search path";
    goto LABEL_20;
  }
  fillin_rpath(v19, v22, ":;", a2, _libc_enable_secure, (int)"LD_LIBRARY_PATH", 0, 0);
  result = (_DWORD *)env_path_list;
  if ( !*(_DWORD *)env_path_list )
  {
    result = free(a2, env_path_list);
    env_path_list = -1;
  }
  dword_80EAFE8 = 0;
  return result;
}
// 8095298: write access to const memory at 80EAFE0 has been detected
// 80952AA: write access to const memory at 80EAFD0 has been detected
// 80952F5: write access to const memory at 80EAFD4 has been detected
// 80953CB: write access to const memory at 80EAFE4 has been detected
// 8095448: write access to const memory at 80EAFE4 has been detected
// 809547A: write access to const memory at 80EAFE8 has been detected
// 8095495: write access to const memory at 80EAFE4 has been detected
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80EAFD0: using guessed type int rtld_search_dirs;
// 80EAFD4: using guessed type int dword_80EAFD4;
// 80EAFD8: using guessed type int max_capstrlen;
// 80EAFDC: using guessed type int ncapstr;
// 80EAFE0: using guessed type int capstr;
// 80EAFE4: using guessed type int env_path_list;
// 80EAFE8: using guessed type int dword_80EAFE8;
// 80EC78C: using guessed type int max_dirnamelen;
// 80ECC5C: using guessed type int dl_platformlen;
// 80ECC80: using guessed type int dl_platform;
// 80ECCBC: using guessed type int dl_all_dirs;
// 8095270: using guessed type char anonymous_0[12];

//----- (080954E0) --------------------------------------------------------
int __userpurge dl_map_object@<eax>(
        int *a1@<eax>,
        char *a2@<edx>,
        char a3@<cl>,
        long double a4@<st0>,
        int a5,
        unsigned int a6,
        int a7)
{
  int v9; // ebp
  int v10; // eax
  const char *v12; // eax
  char *v13; // edx
  char *v14; // eax
  int v15; // eax
  int v16; // eax
  _BYTE *v17; // eax
  _BYTE *v18; // edi
  int v19; // eax
  int v20; // edi
  int v21; // eax
  char *cache_lookup; // ebp
  int *v23; // eax
  int v24; // edx
  int v25; // eax
  int v26; // eax
  int *v27; // edi
  int v28; // edx
  const char *v29; // ecx
  int v31; // [esp+20h] [ebp-23Ch]
  unsigned int v32; // [esp+24h] [ebp-238h]
  int v33; // [esp+24h] [ebp-238h]
  _DWORD *v34; // [esp+28h] [ebp-234h]
  const char *v35; // [esp+28h] [ebp-234h]
  char v36; // [esp+2Ch] [ebp-230h]
  int v37; // [esp+2Ch] [ebp-230h]
  char v38; // [esp+33h] [ebp-229h] BYREF
  char *v39; // [esp+34h] [ebp-228h] BYREF
  int v40; // [esp+38h] [ebp-224h] BYREF
  char v41[544]; // [esp+3Ch] [ebp-220h] BYREF

  if ( a7 < 0 )
    _assert_fail("nsid >= 0", "dl-load.c", 2175, "_dl_map_object");
  if ( a7 >= (unsigned int)dl_nns )
    _assert_fail("nsid < GL(dl_nns)", "dl-load.c", 2176, "_dl_map_object");
  v9 = (int)*(&dl_ns + 19 * a7);
  if ( v9 )
  {
    while ( 1 )
    {
      if ( (*(_BYTE *)(v9 + 405) & 2) == 0 && (*(_BYTE *)(v9 + 405) & 0x20) == 0 )
      {
        if ( dl_name_match_p((int)a2, v9) )
          return v9;
        if ( (*(_BYTE *)(v9 + 405) & 1) == 0 )
        {
          v10 = *(_DWORD *)(v9 + 88);
          if ( v10 )
          {
            if ( !j_strcmp(a2, *(_DWORD *)(*(_DWORD *)(v9 + 52) + 4) + *(_DWORD *)(v10 + 4)) )
              break;
          }
        }
      }
      v9 = *(_DWORD *)(v9 + 12);
      if ( !v9 )
        goto LABEL_13;
    }
    add_name_to_object(v9, a2, a4);
    *(_BYTE *)(v9 + 405) |= 1u;
    return v9;
  }
LABEL_13:
  if ( (dl_debug_mask & 0x40) != 0 && a1 )
  {
    v12 = (const char *)a1[1];
    if ( !*v12 )
    {
      v12 = (const char *)program_invocation_short_name;
      if ( !program_invocation_short_name )
        v12 = "<main program>";
    }
    v13 = "\nfile=%s [%lu];  dynamically loaded by %s [%lu]\n";
    v31 = a6 & 0x10000000;
    if ( (a6 & 0x10000000) == 0 )
      v13 = "\nfile=%s [%lu];  needed by %s [%lu]\n";
    dl_debug_printf(v13, a2, a7, v12, a1[6]);
  }
  else
  {
    v31 = a6 & 0x10000000;
  }
  v38 = 0;
  if ( !j_strchr(a2, 47) )
  {
    v32 = strlen(a2) + 1;
    if ( (dl_debug_mask & 1) != 0 )
      dl_debug_printf("find library=%s [%lu]; searching\n", a2, a7);
    if ( a1 )
    {
      if ( a1[37] )
        goto LABEL_32;
      v20 = (int)a1;
      v36 = 0;
      v34 = dl_ns;
      do
      {
        v21 = *(_DWORD *)(v20 + 408);
        if ( v21 != -1 && (v21 || (unsigned __int8)cache_rpath_part_6(v20, (_DWORD *)(v20 + 408), 15, a4, (int)"RPATH")) )
        {
          v15 = open_path(a2, v32, a6, a4, (int *)(v20 + 408), &v39, (int)v41, (int)a1, 4, &v38);
          if ( v15 != -1 )
            goto LABEL_39;
          v36 |= v34 == (_DWORD *)v20;
        }
        v20 = *(_DWORD *)(v20 + 364);
      }
      while ( v20 );
      if ( v36 )
        goto LABEL_32;
    }
    else
    {
      v34 = dl_ns;
    }
    if ( v34 )
    {
      if ( (v34[101] & 3) != 2 )
      {
        v25 = v34[102];
        if ( v25 != -1 && (v25 || (unsigned __int8)cache_rpath_part_6((int)v34, v34 + 102, 15, a4, (int)"RPATH")) )
        {
          v26 = (int)v34;
          if ( a1 )
            v26 = (int)a1;
          v15 = open_path(a2, v32, a6, a4, v34 + 102, &v39, (int)v41, v26, 4, &v38);
          if ( v15 != -1 )
            goto LABEL_39;
        }
      }
    }
LABEL_32:
    if ( env_path_list == -1 )
    {
      if ( !a1 )
        goto LABEL_67;
    }
    else
    {
      if ( !a1 )
      {
        v15 = open_path(a2, v32, a6, a4, &env_path_list, &v39, (int)v41, (int)dl_ns, 2, &v38);
LABEL_38:
        if ( v15 != -1 )
          goto LABEL_39;
        goto LABEL_67;
      }
      v15 = open_path(a2, v32, a6, a4, &env_path_list, &v39, (int)v41, (int)a1, 2, &v38);
      if ( v15 != -1 )
        goto LABEL_39;
    }
    v16 = a1[122];
    if ( v16 != -1 && (v16 || (unsigned __int8)cache_rpath_part_6((int)a1, a1 + 122, 29, a4, (int)"RUNPATH")) )
    {
      v15 = open_path(a2, v32, a6, a4, a1 + 122, &v39, (int)v41, (int)a1, 4, &v38);
      goto LABEL_38;
    }
LABEL_67:
    v39 = 0;
    if ( ((a6 & 0x4000000) == 0 || !_libc_enable_secure) && !dl_inhibit_cache )
    {
      cache_lookup = dl_load_cache_lookup(a2);
      if ( cache_lookup )
      {
        v23 = a1;
        if ( !a1 )
          v23 = (int *)dl_ns;
        if ( (*((_BYTE *)v23 + 517) & 8) != 0 )
        {
          v27 = (int *)&system_dirs_len;
          v28 = 7;
          v29 = "/lib32/";
          while ( 1 )
          {
            v37 = v28;
            v35 = v29;
            if ( !j_memcmp(cache_lookup, v29, v28) )
              break;
            if ( ++v27 == (int *)&unk_80CE4BC )
              goto LABEL_73;
            v29 = &v35[v37 + 1];
            v28 = *v27;
          }
        }
        else
        {
LABEL_73:
          v15 = open_verify_constprop_7(cache_lookup, (int)v41, a6, a4, &v38, 0);
          if ( v15 != -1 )
          {
            v39 = cache_lookup;
            goto LABEL_39;
          }
        }
        free(cache_lookup);
      }
    }
    v24 = (int)a1;
    if ( (a1 || (v24 = (int)*(&dl_ns + 19 * a7)) != 0) && (*(_BYTE *)(v24 + 517) & 8) != 0 )
    {
      v15 = -1;
    }
    else
    {
      v15 = -1;
      if ( rtld_search_dirs != -1 )
        v15 = open_path(a2, v32, a6, a4, &rtld_search_dirs, &v39, (int)v41, v24, 64, &v38);
    }
LABEL_39:
    if ( (dl_debug_mask & 1) != 0 )
    {
      v33 = v15;
      dl_debug_printf("\n");
      v15 = v33;
    }
    if ( v31 )
      a1 = 0;
    if ( v15 != -1 )
      goto LABEL_27;
    goto LABEL_47;
  }
  if ( a1 )
    v14 = expand_dynamic_string_token((int)a1, a2, 0);
  else
    v14 = strdup(a2);
  v39 = v14;
  if ( !v14 )
  {
    if ( v31 )
      a1 = 0;
    goto LABEL_47;
  }
  v15 = open_verify_constprop_7(v14, (int)v41, a6, a4, &v38, 1);
  if ( v15 == -1 )
  {
    free(v39);
    if ( v31 )
      a1 = 0;
LABEL_47:
    if ( !a5 || (dl_debug_mask & 0x800) != 0 )
    {
      if ( v38 )
        dl_signal_error(0, a2, 0, a4, "wrong ELF class: ELFCLASS64");
      dl_signal_error(__readgsdword(0xFFFFFFE8), a2, 0, a4, "cannot open shared object file");
    }
    v17 = strdup(a2);
    v18 = v17;
    if ( !v17 || (v19 = dl_new_object(v17, a2, a3, (int)a1, a6, a7), (v9 = v19) == 0) )
    {
      free(v18);
      dl_signal_error(12, a2, 0, a4, "cannot create shared object descriptor");
    }
    *(_BYTE *)(v19 + 405) |= 2u;
    *(_BYTE *)(v19 + 404) |= 4u;
    *(_DWORD *)(v19 + 396) = &dummy_bucket_10000;
    *(_DWORD *)(v19 + 376) = 1;
    dl_add_to_namespace_list(v19, a7);
    return v9;
  }
  if ( v31 )
    a1 = 0;
LABEL_27:
  v40 = _libc_stack_end;
  return dl_map_object_from_fd_constprop_8(a2, v15, (int)v41, a4, v39, (int)a1, a3, a6, (int)&v40, a7);
}
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EAFC8: using guessed type int _libc_stack_end;
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80EAFD0: using guessed type int rtld_search_dirs;
// 80EAFE4: using guessed type int env_path_list;
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80EBA28: using guessed type int dl_nns;
// 80EBA40: using guessed type void *dl_ns;
// 80ECC60: using guessed type int dl_debug_mask;
// 80ECC8C: using guessed type int dl_inhibit_cache;

//----- (08095C80) --------------------------------------------------------
int __usercall dl_rtld_di_serinfo@<eax>(int a1@<eax>, _DWORD *a2@<edx>, char a3@<cl>, long double a4@<st0>)
{
  int v6; // eax
  int v7; // edx
  int result; // eax
  int *v9; // edx
  int v10; // ebx
  int *v11; // edx
  void *v12; // ebx
  int *v13; // edx
  char v15[4]; // [esp+10h] [ebp-2Ch] BYREF
  int v16; // [esp+14h] [ebp-28h]
  _DWORD *v17; // [esp+18h] [ebp-24h]
  int v18; // [esp+1Ch] [ebp-20h]

  if ( a3 )
  {
    a2[1] = 0;
    *a2 = 0;
    v6 = 8;
  }
  else
  {
    v6 = 8 * a2[1] + 8;
  }
  v7 = *(_DWORD *)(a1 + 148);
  v16 = 0;
  v17 = a2;
  v18 = (int)a2 + v6;
  v15[0] = a3;
  if ( v7 )
    goto LABEL_4;
  v10 = a1;
  do
  {
    v11 = *(int **)(v10 + 408);
    if ( v11 == (int *)-1 )
      goto LABEL_17;
    if ( v11 )
      goto LABEL_16;
    if ( (unsigned __int8)cache_rpath_part_6(v10, (_DWORD *)(v10 + 408), 15, a4, (int)"RPATH") )
    {
      v11 = *(int **)(v10 + 408);
LABEL_16:
      add_path_isra_4_constprop_9((int)v15, v11);
    }
LABEL_17:
    v10 = *(_DWORD *)(v10 + 364);
  }
  while ( v10 );
  if ( !*(_DWORD *)(a1 + 24) )
  {
    v12 = dl_ns;
    if ( dl_ns )
    {
      if ( (*((_BYTE *)dl_ns + 404) & 3) != 2 && (void *)a1 != dl_ns )
      {
        v13 = (int *)*((_DWORD *)dl_ns + 102);
        if ( v13 != (int *)-1 )
        {
          if ( v13 )
            goto LABEL_24;
          if ( (unsigned __int8)cache_rpath_part_6((int)dl_ns, (_DWORD *)dl_ns + 102, 15, a4, (int)"RPATH") )
          {
            v13 = (int *)*((_DWORD *)v12 + 102);
LABEL_24:
            add_path_isra_4_constprop_9((int)v15, v13);
          }
        }
      }
    }
  }
LABEL_4:
  result = add_path_isra_4_constprop_9((int)v15, (int *)env_path_list);
  v9 = *(int **)(a1 + 488);
  if ( v9 != (int *)-1 )
  {
    if ( v9 )
      goto LABEL_6;
    result = cache_rpath_part_6(a1, (_DWORD *)(a1 + 488), 29, a4, (int)"RUNPATH");
    if ( (_BYTE)result )
    {
      v9 = *(int **)(a1 + 488);
LABEL_6:
      result = add_path_isra_4_constprop_9((int)v15, v9);
    }
  }
  if ( (*(_BYTE *)(a1 + 517) & 8) == 0 )
    result = add_path_isra_4_constprop_9((int)v15, (int *)rtld_search_dirs);
  if ( a3 )
  {
    result = 8 * a2[1] + 8;
    *a2 += result;
  }
  return result;
}
// 80EAFD0: using guessed type int rtld_search_dirs;
// 80EAFE4: using guessed type int env_path_list;
// 80EBA40: using guessed type void *dl_ns;
// 8095C80: using guessed type char var_2C[4];

//----- (08095E60) --------------------------------------------------------
int __usercall check_match@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        _DWORD *a3@<ecx>,
        char a4,
        unsigned __int8 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        _DWORD *a10,
        _DWORD *a11)
{
  int v11; // esi
  int v12; // ebp
  int v14; // eax
  __int16 v15; // bp
  _DWORD *v16; // eax
  int v17; // edi
  int v20; // eax

  v11 = *(_BYTE *)(a6 + 12) & 0xF;
  if ( (*(_DWORD *)(a6 + 4) || (_BYTE)v11 == 6) && ((*(_WORD *)(a6 + 14) == 0) & a5) == 0 )
  {
    v12 = 1127;
    if ( _bittest(&v12, v11) )
    {
      if ( a6 == a2 || !j_strcmp(*(_DWORD *)a6 + a8, a1) )
      {
        v14 = *(_DWORD *)(a9 + 420);
        if ( a3 )
        {
          if ( !v14 )
          {
            v20 = a3[3];
            if ( v20 && dl_name_match_p(v20, a9) )
              _assert_fail(
                "version->filename == NULL || ! _dl_name_match_p (version->filename, map)",
                "dl-lookup.c",
                128,
                "check_match");
            return a6;
          }
          v15 = *(_WORD *)(v14 + 2 * a7);
          v16 = (_DWORD *)(*(_DWORD *)(a9 + 368) + 16 * (v15 & 0x7FFF));
          v17 = v16[1];
          if ( v17 == a3[1] && !j_strcmp(*v16, *a3) || !a3[2] && !v17 && v15 >= 0 )
            return a6;
        }
        else
        {
          if ( !v14 || ((a4 & 2) == 0) + 2 > (*(_WORD *)(v14 + 2 * a7) & 0x7FFF) )
            return a6;
          if ( *(__int16 *)(v14 + 2 * a7) >= 0 && (*a11)++ == 0 )
            *a10 = a6;
        }
      }
    }
  }
  return 0;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08095FC0) --------------------------------------------------------
int __usercall do_lookup_x@<eax>(
        unsigned __int8 *a1@<eax>,
        unsigned int a2@<edx>,
        unsigned int *a3@<ecx>,
        int a4,
        int *a5,
        int *a6,
        int a7,
        _DWORD *a8,
        char a9,
        int a10,
        int a11,
        unsigned int a12)
{
  int v13; // ebp
  int v14; // edi
  int v15; // eax
  int v16; // ecx
  unsigned int v17; // eax
  bool v18; // al
  int v19; // eax
  const char *v22; // eax
  unsigned int v23; // eax
  int v24; // ebx
  int v25; // eax
  char v26; // al
  unsigned int v27; // ebp
  int v28; // ecx
  int v29; // ebx
  unsigned int *v30; // eax
  unsigned int v31; // esi
  int v32; // ebx
  unsigned int v33; // edi
  int v34; // edx
  int v35; // ecx
  int v36; // eax
  unsigned int v37; // esi
  unsigned int v38; // edi
  _DWORD *v39; // ebx
  int j; // edx
  int v41; // eax
  unsigned int *v42; // eax
  int v43; // eax
  int v44; // edx
  int v45; // eax
  unsigned int v46; // eax
  unsigned int v47; // eax
  int v48; // ebx
  int v49; // edi
  unsigned int v50; // eax
  int v51; // edx
  int v52; // eax
  int v53; // edx
  unsigned int v54; // ecx
  int v55; // eax
  int *v56; // esi
  int v57; // eax
  unsigned int v58; // esi
  unsigned int *v59; // ebx
  unsigned int v60; // edi
  unsigned int v61; // ecx
  _DWORD *v62; // eax
  int v63; // ebx
  int v64; // edx
  int v65; // eax
  unsigned int v66; // eax
  unsigned int v67; // eax
  int v68; // edx
  int v69; // ebx
  int v70; // edi
  unsigned int v71; // eax
  int v72; // edx
  int v73; // eax
  int v74; // edx
  unsigned int v75; // ecx
  unsigned int v76; // edx
  _BYTE *v77; // eax
  int i; // ecx
  int v79; // edx
  int v80; // eax
  unsigned int v81; // [esp+1Ch] [ebp-60h]
  int v82; // [esp+1Ch] [ebp-60h]
  int v83; // [esp+1Ch] [ebp-60h]
  unsigned int v85; // [esp+24h] [ebp-58h]
  unsigned int v86; // [esp+28h] [ebp-54h]
  int v87; // [esp+28h] [ebp-54h]
  int v88; // [esp+2Ch] [ebp-50h]
  int v89; // [esp+2Ch] [ebp-50h]
  unsigned int v90; // [esp+2Ch] [ebp-50h]
  int v91; // [esp+30h] [ebp-4Ch]
  unsigned int v93; // [esp+38h] [ebp-44h]
  int v94; // [esp+38h] [ebp-44h]
  int v96; // [esp+3Ch] [ebp-40h]
  int v97; // [esp+40h] [ebp-3Ch]
  unsigned int v98; // [esp+40h] [ebp-3Ch]
  int v99; // [esp+40h] [ebp-3Ch]
  unsigned int v100; // [esp+40h] [ebp-3Ch]
  int v101; // [esp+44h] [ebp-38h]
  int v102; // [esp+44h] [ebp-38h]
  unsigned int *v103; // [esp+44h] [ebp-38h]
  int v104; // [esp+48h] [ebp-34h]
  int v105; // [esp+48h] [ebp-34h]
  unsigned int v106; // [esp+48h] [ebp-34h]
  int v107; // [esp+4Ch] [ebp-30h]
  int v108; // [esp+58h] [ebp-24h] BYREF
  int v109[8]; // [esp+5Ch] [ebp-20h] BYREF
  int v110; // [esp+8Ch] [ebp+10h]

  v13 = *a6;
  v81 = a6[1];
  v93 = a2 >> 5;
LABEL_2:
  v14 = *(_DWORD *)(*(_DWORD *)(v13 + 4 * a7) + 20);
  if ( v14 == a10 || (a11 & 2) != 0 && (*(_BYTE *)(v14 + 404) & 3) == 0 || (*(_BYTE *)(v14 + 405) & 0x20) != 0 )
    goto LABEL_15;
  if ( (dl_debug_mask & 8) != 0 )
  {
    v22 = *(const char **)(v14 + 4);
    if ( !*v22 )
    {
      v22 = (const char *)program_invocation_short_name;
      if ( !program_invocation_short_name )
        v22 = "<main program>";
    }
    dl_debug_printf("symbol=%s;  lookup in file=%s [%lu]\n", (const char *)a1, v22, *(_DWORD *)(v14 + 24));
  }
  v86 = *(_DWORD *)(v14 + 376);
  if ( !v86 )
    goto LABEL_15;
  v15 = *(_DWORD *)(v14 + 56);
  v16 = *(_DWORD *)(v14 + 388);
  v108 = 0;
  v109[0] = 0;
  v88 = *(_DWORD *)(v15 + 4);
  v91 = *(_DWORD *)(*(_DWORD *)(v14 + 52) + 4);
  if ( v16 )
  {
    v17 = *(_DWORD *)(v16 + 4 * (*(_DWORD *)(v14 + 380) & v93));
    if ( ((unsigned __int8)(v17 >> (a2 >> *(_DWORD *)(v14 + 384))) & (unsigned __int8)(v17 >> a2) & 1) != 0 )
    {
      v55 = *(_DWORD *)(*(_DWORD *)(v14 + 392) + 4 * (a2 % v86));
      if ( v55 )
      {
        v97 = v13;
        v110 = a7;
        v56 = (int *)(*(_DWORD *)(v14 + 396) + 4 * v55);
        while ( 1 )
        {
          v57 = *v56;
          if ( !((*v56 ^ a2) >> 1) )
          {
            v24 = ((int)v56 - *(_DWORD *)(v14 + 396)) >> 2;
            v25 = check_match((int)a1, a4, a8, a9, a11, v88 + 16 * v24, v24, v91, v14, v109, &v108);
            if ( v25 )
              goto LABEL_28;
            v57 = *v56;
          }
          ++v56;
          if ( (v57 & 1) != 0 )
            goto LABEL_86;
        }
      }
    }
    goto LABEL_10;
  }
  v23 = *a3;
  if ( *a3 == -1 )
  {
    v76 = 0;
    if ( *a1 )
    {
      v76 = *a1;
      if ( a1[1] )
      {
        v76 = a1[1] + 16 * v76;
        if ( a1[2] )
        {
          v76 = a1[2] + 16 * v76;
          if ( a1[3] )
          {
            v76 = a1[3] + 16 * v76;
            if ( a1[4] )
            {
              v77 = a1 + 5;
              v76 = a1[4] + 16 * v76;
              for ( i = a1[5]; *v77; v76 = ((v79 & 0xF0000000) >> 24) ^ v79 & 0xFFFFFFF )
              {
                ++v77;
                v79 = i + 16 * v76;
                i = (unsigned __int8)*v77;
              }
            }
          }
        }
      }
    }
    *a3 = v76;
    v23 = v76;
  }
  v24 = *(_DWORD *)(*(_DWORD *)(v14 + 396) + 4 * (v23 % v86));
  if ( !v24 )
    goto LABEL_10;
  v97 = v13;
  v110 = a7;
  while ( 1 )
  {
    v25 = check_match((int)a1, a4, a8, a9, a11, v88 + 16 * v24, v24, v91, v14, v109, &v108);
    if ( v25 )
      break;
    v24 = *(_DWORD *)(*(_DWORD *)(v14 + 392) + 4 * v24);
    if ( !v24 )
    {
LABEL_86:
      v13 = v97;
      a7 = v110;
      if ( v108 == 1 )
      {
        v87 = v109[0];
        if ( v109[0] )
        {
          v24 = 0;
          goto LABEL_29;
        }
      }
LABEL_10:
      v18 = 1;
      goto LABEL_11;
    }
  }
LABEL_28:
  v13 = v97;
  a7 = v110;
  v87 = v25;
LABEL_29:
  if ( !a12 && (*(_BYTE *)(v14 + 404) & 3) == 0 && a11 == 4 )
  {
    v44 = *(_DWORD *)(v14 + 60);
    if ( v44 )
    {
      v45 = *(_DWORD *)(v14 + 64);
      if ( v45 )
      {
        v46 = *(_DWORD *)(v45 + 4);
        if ( v46 )
        {
          v47 = v46 / 0xC;
          if ( v47 )
          {
            v102 = v14;
            v105 = v24;
            v99 = v13;
            v48 = *(_DWORD *)(v44 + 4);
            v49 = v48 + 12 * v47;
            while ( 1 )
            {
              v52 = *(_DWORD *)(v48 + 4);
              v53 = (unsigned __int8)v52;
              v54 = (unsigned __int8)v52 - 7;
              if ( v54 > 0x1E )
              {
                v50 = (unsigned __int8)v52 == 41;
                if ( v53 == 5 )
                {
                  v50 |= 2u;
                  v51 = 0;
LABEL_73:
                  if ( (v51 | v50) == 2 && !j_strcmp(*(_DWORD *)(v88 + 16 * (*(_DWORD *)(v48 + 4) >> 8)) + v91, a1) )
                  {
LABEL_131:
                    v13 = v99;
                    v14 = v102;
                    v18 = v105 == 0;
LABEL_11:
                    if ( a8 )
                    {
                      if ( v18 )
                      {
                        v19 = a8[3];
                        if ( v19 )
                        {
                          if ( dl_name_match_p(v19, v14) )
                            return -1;
                        }
                      }
                    }
LABEL_15:
                    if ( v81 <= ++a7 )
                      return 0;
                    goto LABEL_2;
                  }
                  goto LABEL_75;
                }
              }
              else
              {
                v50 = ((unsigned __int8)v52 == 41) | (0x70000081u >> v54) & 1;
              }
              if ( v53 == 6 )
              {
                v51 = 4;
                goto LABEL_73;
              }
LABEL_75:
              v48 += 12;
              if ( v48 == v49 )
              {
                v14 = v102;
                v24 = v105;
                break;
              }
            }
          }
        }
      }
    }
    v64 = *(_DWORD *)(v14 + 100);
    if ( v64 )
    {
      v65 = *(_DWORD *)(v14 + 104);
      if ( v65 )
      {
        v66 = *(_DWORD *)(v65 + 4);
        if ( v66 )
        {
          v67 = v66 >> 3;
          v68 = *(_DWORD *)(v64 + 4);
          if ( v67 )
          {
            v102 = v14;
            v105 = v24;
            v99 = v13;
            v69 = v68;
            v70 = v68 + 8 * v67;
            while ( 1 )
            {
              v73 = *(_DWORD *)(v69 + 4);
              v74 = (unsigned __int8)v73;
              v75 = (unsigned __int8)v73 - 7;
              if ( v75 > 0x1E )
              {
                v71 = (unsigned __int8)v73 == 41;
                if ( v74 == 5 )
                {
                  v71 |= 2u;
                  v72 = 0;
LABEL_113:
                  if ( (v72 | v71) == 2 && !j_strcmp(*(_DWORD *)(v88 + 16 * (*(_DWORD *)(v69 + 4) >> 8)) + v91, a1) )
                    goto LABEL_131;
                  goto LABEL_115;
                }
              }
              else
              {
                v71 = ((unsigned __int8)v73 == 41) | (0x70000081u >> v75) & 1;
              }
              if ( v74 == 6 )
              {
                v72 = 4;
                goto LABEL_113;
              }
LABEL_115:
              v69 += 8;
              if ( v69 == v70 )
              {
                v14 = v102;
                v24 = v105;
                break;
              }
            }
          }
        }
      }
    }
  }
  if ( (*(_BYTE *)(v87 + 13) & 3u) - 1 <= 1 )
  {
LABEL_34:
    v18 = v24 == 0;
    goto LABEL_11;
  }
  v26 = *(_BYTE *)(v87 + 12) >> 4;
  if ( v26 == 2 )
  {
    if ( dl_dynamic_weak )
    {
      if ( !*a5 )
      {
        a5[1] = v14;
        *a5 = v87;
      }
      goto LABEL_34;
    }
    goto LABEL_42;
  }
  if ( v26 != 10 )
  {
    if ( v26 != 1 )
      goto LABEL_34;
LABEL_42:
    a5[1] = v14;
    *a5 = v87;
    return 1;
  }
  v96 = *(_DWORD *)(v14 + 24);
  v94 = dword_80EBA68[19 * v96];
  v31 = dword_80EBA6C[19 * v96];
  v98 = v31;
  if ( !v94 )
  {
    v80 = calloc(0x10u, 0x1Fu);
    v94 = v80;
    if ( v80 )
    {
      dword_80EBA68[19 * v96] = v80;
      dword_80EBA6C[19 * v96] = 31;
      dword_80EBA74[19 * v96] = (int)free;
      v98 = 31;
      v27 = a2 % 0x1F;
      j = a2 % 0x1D + 1;
      goto LABEL_36;
    }
LABEL_132:
    dl_dprintf(2, "out of memory\n");
    exit(127);
  }
  v101 = v14;
  v32 = a2 % v31;
  v104 = a2 % v31;
  v33 = a2 % (v31 - 2) + 1;
  v34 = dword_80EBA6C[19 * v96];
  v35 = 16 * v33;
LABEL_45:
  v36 = v33;
  v37 = v33 + v32;
  v38 = v34;
  v39 = (_DWORD *)(v94 + 16 * v32);
  for ( j = v36; ; v37 += j )
  {
    if ( a2 != *v39 )
    {
      if ( v39[1] )
        goto LABEL_47;
      v14 = v101;
      v27 = v104;
      if ( 3 * v98 > 4 * dword_80EBA70[19 * v96] )
      {
LABEL_36:
        v28 = 16 * j;
        v29 = *(_DWORD *)v87 + v91;
        if ( (a11 & 2) != 0 )
        {
LABEL_37:
          v30 = (unsigned int *)(v94 + 16 * v27);
          while ( v30[1] )
          {
            v27 += j;
            v30 = (unsigned int *)((char *)v30 + v28);
            if ( v98 <= v27 )
            {
              v27 -= v98;
              goto LABEL_37;
            }
          }
          v30[1] = v29;
          *v30 = a2;
          v30[2] = a4;
          v30[3] = a12;
        }
        else
        {
LABEL_58:
          v42 = (unsigned int *)(v94 + 16 * v27);
          while ( v42[1] )
          {
            v27 += j;
            v42 = (unsigned int *)((char *)v42 + v28);
            if ( v98 <= v27 )
            {
              v27 -= v98;
              goto LABEL_58;
            }
          }
          v42[1] = v29;
          v42[3] = v14;
          *v42 = a2;
          v42[2] = v87;
          if ( (*(_BYTE *)(v14 + 404) & 3) == 2 )
            *(_DWORD *)(v14 + 516) |= 8u;
        }
        ++dword_80EBA70[19 * v96];
        goto LABEL_42;
      }
      v58 = dl_higher_prime_number(v98 + 1);
      v83 = calloc(0x10u, v58);
      if ( v83 )
      {
        v106 = v58 - 2;
        if ( v98 )
        {
          v107 = v101;
          v59 = (unsigned int *)v94;
          v103 = (unsigned int *)(v94 + 16 * v98);
          do
          {
            v60 = v59[1];
            if ( v60 )
            {
              v85 = v59[3];
              v90 = v59[2];
              v100 = *v59;
              v61 = *v59 % v58;
LABEL_95:
              v62 = (_DWORD *)(v83 + 16 * v61);
              while ( v62[1] )
              {
                v61 += v100 % v106 + 1;
                v62 += 4 * (*v59 % v106) + 4;
                if ( v58 <= v61 )
                {
                  v61 -= v58;
                  goto LABEL_95;
                }
              }
              v62[1] = v60;
              v62[2] = v90;
              *v62 = v100;
              v62[3] = v85;
            }
            v59 += 4;
          }
          while ( v103 != v59 );
          v14 = v107;
        }
        v63 = 19 * v96;
        ((void (__cdecl *)(int))dword_80EBA74[19 * v96])(v94);
        dword_80EBA6C[v63] = v58;
        dword_80EBA74[v63] = (int)free;
        dword_80EBA68[v63] = v83;
        v27 = a2 % v58;
        j = a2 % v106 + 1;
        v98 = v58;
        v94 = v83;
        goto LABEL_36;
      }
      goto LABEL_132;
    }
    v89 = v35;
    v82 = j;
    v41 = j_strcmp(v39[1], a1);
    j = v82;
    v35 = v89;
    if ( !v41 )
      break;
LABEL_47:
    v39 = (_DWORD *)((char *)v39 + v35);
    if ( v38 <= v37 )
    {
      v43 = j;
      v34 = v38;
      v32 = v37 - v38;
      v33 = v43;
      goto LABEL_45;
    }
  }
  if ( (a11 & 2) != 0 )
  {
    a5[1] = v101;
    *a5 = v87;
  }
  else
  {
    *a5 = v39[2];
    a5[1] = v39[3];
  }
  return 1;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80EBA68: using guessed type int dword_80EBA68[];
// 80EBA6C: using guessed type int dword_80EBA6C[];
// 80EBA70: using guessed type int dword_80EBA70[];
// 80EBA74: using guessed type int dword_80EBA74[];
// 80ECC60: using guessed type int dl_debug_mask;
// 80ECCA0: using guessed type int dl_dynamic_weak;

//----- (080969E0) --------------------------------------------------------
int __userpurge dl_lookup_symbol_x@<eax>(
        unsigned __int8 *a1@<eax>,
        unsigned int a2@<edx>,
        int *a3@<ecx>,
        long double a4@<st0>,
        int **a5,
        const char **a6,
        int a7,
        int a8,
        int a9)
{
  int v9; // ebx
  unsigned __int8 *v10; // edx
  int v11; // eax
  int *v12; // eax
  int v13; // edx
  int **v14; // esi
  int v15; // eax
  int v16; // eax
  int v17; // edi
  int *v19; // ecx
  int **v20; // esi
  int v21; // ebx
  int v22; // edx
  unsigned int v23; // ecx
  const char *v24; // edx
  const char *v25; // eax
  unsigned __int8 *v26; // edi
  int *v27; // edi
  int v28; // ebx
  int v29; // edx
  const char **v30; // ebx
  void *v31; // esp
  const char *v32; // ecx
  char *v33; // eax
  char *v34; // eax
  int *v35; // eax
  int v36; // edx
  unsigned int v37; // ecx
  int v38; // eax
  int v39; // edx
  int j; // eax
  __int64 v41; // rax
  int v42; // ebx
  const char *v43; // edx
  const char *v44; // eax
  const char *v45; // esi
  bool v46; // zf
  const char **v47; // ebx
  const char *v48; // eax
  int v49; // esi
  char *v50; // edi
  int k; // eax
  const char *v52; // ecx
  void *v53; // esp
  char *v54; // eax
  char *v55; // edx
  int v56; // esi
  unsigned int v57; // ebx
  unsigned int v58; // esi
  unsigned int v59; // ebx
  const char *v60; // edx
  const char *v61; // eax
  int v62; // ebx
  int v63; // eax
  int v64; // edx
  unsigned int v65; // eax
  unsigned int v66; // esi
  int v67; // eax
  int *v69; // edx
  int v70; // ecx
  int *v71; // edx
  int v72; // ecx
  int *v73; // edx
  int v74; // ecx
  unsigned int v75; // ebx
  _BYTE *v76; // [esp-10h] [ebp-88h]
  _BYTE *v77; // [esp-10h] [ebp-88h]
  char v78[8]; // [esp+0h] [ebp-78h] BYREF
  int *v79; // [esp+8h] [ebp-70h]
  int v80; // [esp+Ch] [ebp-6Ch]
  __int64 v81; // [esp+10h] [ebp-68h]
  unsigned int v82; // [esp+18h] [ebp-60h]
  unsigned int v83; // [esp+1Ch] [ebp-5Ch]
  unsigned int v84; // [esp+20h] [ebp-58h]
  unsigned __int8 *v85; // [esp+24h] [ebp-54h]
  unsigned int v86; // [esp+28h] [ebp-50h]
  int *i; // [esp+2Ch] [ebp-4Ch]
  unsigned int v88; // [esp+34h] [ebp-44h] BYREF
  int v89; // [esp+38h] [ebp-40h] BYREF
  unsigned int v90; // [esp+3Ch] [ebp-3Ch]
  const char *v91; // [esp+40h] [ebp-38h] BYREF
  unsigned __int8 *v92; // [esp+44h] [ebp-34h] BYREF
  const char *v93; // [esp+48h] [ebp-30h]
  const char *v94; // [esp+4Ch] [ebp-2Ch]
  int v95[4]; // [esp+50h] [ebp-28h] BYREF
  char v96; // [esp+60h] [ebp-18h] BYREF

  v9 = 5381;
  v85 = a1;
  v84 = a2;
  v10 = a1;
  v11 = *a1;
  for ( i = a3; (_BYTE)v11; v11 = *v10 )
  {
    ++v10;
    v9 = v11 + 33 * v9;
  }
  v88 = -1;
  v89 = 0;
  v90 = 0;
  if ( a6 && (a8 & 0xFFFFFFFA) != 0 )
    _assert_fail(
      "version == NULL || (flags & ~(DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_GSCOPE_LOCK)) == 0",
      "dl-lookup.c",
      822,
      "_dl_lookup_symbol_x");
  v12 = *a5;
  if ( a9 )
  {
    if ( a9 == *(_DWORD *)*v12 )
    {
      v83 = 0;
    }
    else
    {
      v23 = 0;
      do
        ++v23;
      while ( a9 != *(_DWORD *)(*v12 + 4 * v23) );
      v83 = v23;
    }
  }
  else
  {
    v83 = 0;
    if ( !v12 )
    {
LABEL_39:
      if ( (!*i || *(_BYTE *)(*i + 12) >> 4 != 2) && (dl_debug_mask & 0x100) == 0 )
      {
        if ( v84 )
          v86 = *(_DWORD *)(v84 + 4);
        else
          v86 = (unsigned int)&unk_80CFAB1;
        if ( a6 )
        {
          v24 = ", version ";
          v25 = *a6;
          if ( !*a6 )
            v25 = (const char *)&unk_80CFAB1;
        }
        else
        {
          v24 = (const char *)&unk_80CFAB1;
          v25 = (const char *)&unk_80CFAB1;
        }
        v26 = v85;
        v93 = v24;
        v94 = v25;
        v85 = (unsigned __int8 *)&v91;
        v91 = "undefined symbol: ";
        v92 = v26;
        v27 = (int *)&v92;
        v28 = 19;
        if ( v95 != (int *)&v92 )
        {
          do
          {
            v76 = (_BYTE *)*v27++;
            v28 += strlen(v76);
          }
          while ( v95 != v27 );
        }
        v29 = v28;
        v30 = (const char **)v85;
        v31 = alloca(v29 + 15);
        v32 = "undefined symbol: ";
        v33 = v78;
        while ( 1 )
        {
          ++v30;
          v33 = (char *)j_stpcpy(v33, v32);
          if ( v27 == (int *)v30 )
            break;
          v32 = *v30;
        }
        if ( !*(_BYTE *)v86 )
        {
          v34 = "<main program>";
          if ( program_invocation_short_name )
            v34 = (char *)program_invocation_short_name;
          v86 = (unsigned int)v34;
        }
        dl_signal_cerror(0, (char *)v86, "symbol lookup error", a4, v78);
      }
      v17 = 0;
      *i = 0;
      return v17;
    }
  }
  v86 = v9;
  v13 = v83;
  v14 = a5;
  while ( 1 )
  {
    v15 = do_lookup_x(v85, v86, &v88, *i, &v89, v12, v13, a6, a8, a9, a7, v84);
    if ( v15 > 0 )
    {
LABEL_12:
      if ( !v89 )
        goto LABEL_39;
      v16 = *i;
      if ( !*i || (*(_BYTE *)(v16 + 13) & 3) != 3 )
      {
        v17 = v90;
        v86 = 0;
        goto LABEL_16;
      }
      if ( a7 == 1 )
      {
        v17 = v84;
        if ( v84 != v90 )
        {
          v89 = *i;
          v90 = v84;
          v86 = 1;
LABEL_16:
          if ( (*(_BYTE *)(v17 + 404) & 3) != 2 || (a8 & 1) == 0 || v84 == v17 || (*(_BYTE *)(v17 + 516) & 8) != 0 )
            goto LABEL_17;
          v83 = *(_DWORD *)(v84 + 500);
          v82 = v83;
          v35 = *(int **)(v84 + 496);
          v83 = (unsigned int)v35;
          v79 = v35;
          if ( v35 )
          {
            while ( 1 )
            {
              v36 = *v35;
              if ( !*v35 )
                break;
              ++v35;
              if ( v36 == v17 )
                goto LABEL_116;
            }
          }
          if ( v82 )
          {
            v37 = *(_DWORD *)v82;
            v83 = *(_DWORD *)v82;
            if ( v83 )
            {
              if ( *(_DWORD *)(v82 + 4) == v17 )
              {
LABEL_116:
                v17 = v90;
LABEL_17:
                if ( !*(_DWORD *)(v17 + 508) )
                  *(_DWORD *)(v17 + 508) = 1;
                if ( (dl_debug_mask & 0x804) != 0 && (dl_debug_mask & 4) != 0 )
                {
                  v43 = "normal";
                  if ( v86 )
                    v43 = "protected";
                  v44 = *(const char **)(v17 + 4);
                  if ( !*v44 )
                  {
                    v44 = (const char *)program_invocation_short_name;
                    if ( !program_invocation_short_name )
                      v44 = "<main program>";
                  }
                  v45 = *(const char **)(v84 + 4);
                  if ( !*v45 )
                  {
                    v45 = "<main program>";
                    if ( program_invocation_short_name )
                      v45 = (const char *)program_invocation_short_name;
                  }
                  dl_debug_printf(
                    "binding file %s [%lu] to %s [%lu]: %s symbol `%s'",
                    v45,
                    *(_DWORD *)(v84 + 24),
                    v44,
                    *(_DWORD *)(v17 + 24),
                    v43,
                    (const char *)v85);
                  if ( a6 )
                    dl_debug_printf_c(" [%s]\n", *a6);
                  else
                    dl_debug_printf_c("\n");
                  v17 = v90;
                }
                *i = v89;
                return v17;
              }
              v38 = 0;
              while ( v37 != ++v38 )
              {
                if ( *(_DWORD *)(v82 + 4 + 4 * v38) == v17 )
                  goto LABEL_116;
              }
            }
          }
          else
          {
            v83 = 0;
          }
          v39 = *(_DWORD *)(v17 + 600);
          LODWORD(v81) = *(_DWORD *)(v17 + 596);
          HIDWORD(v81) = v39;
          v80 = a8 & 4;
          if ( (a8 & 4) != 0 )
          {
            if ( _InterlockedExchange(MK_FP(__GS__, 28), 0) == 2 )
              dl_sysinfo(129);
            v69 = *(int **)(v84 + 496);
            if ( v69 )
            {
              if ( v69 != v79 )
              {
                v70 = *v69;
                if ( *v69 )
                {
                  v71 = v69 + 1;
                  if ( v17 == v70 )
                  {
                    v41 = *(_QWORD *)(v17 + 596);
                    goto LABEL_78;
                  }
                  while ( 1 )
                  {
                    v72 = *v71;
                    if ( !*v71 )
                      break;
                    ++v71;
                    if ( v17 == v72 )
                      goto LABEL_165;
                  }
                }
              }
            }
            v73 = *(int **)(v84 + 500);
            if ( v73 )
            {
              if ( (int *)v82 != v73 )
              {
                v83 = *v73;
                if ( !v83 )
                  goto LABEL_72;
                v74 = 0;
                if ( v17 != v73[1] )
                {
                  while ( v83 != ++v74 )
                  {
                    if ( v17 == v73[v74 + 1] )
                      goto LABEL_165;
                  }
                  goto LABEL_72;
                }
LABEL_165:
                v41 = *(_QWORD *)(v17 + 596);
                goto LABEL_78;
              }
              if ( *(_DWORD *)v82 <= v83 )
                goto LABEL_72;
              if ( v17 == *(_DWORD *)(v82 + 4 + 4 * v83) )
                goto LABEL_165;
              v75 = v83;
              while ( *(_DWORD *)v82 != ++v75 )
              {
                if ( v17 == *(_DWORD *)(v82 + 4 + 4 * v75) )
                  goto LABEL_165;
              }
              v83 = v75;
            }
          }
LABEL_72:
          for ( j = (int)*(&dl_ns + 19 * *(_DWORD *)(v84 + 24)); j; j = *(_DWORD *)(j + 12) )
          {
            if ( j == v17 )
              break;
          }
          if ( !j )
          {
            v42 = -1;
            goto LABEL_79;
          }
          v41 = *(_QWORD *)(v17 + 596);
          if ( v41 != v81 )
          {
LABEL_78:
            v42 = -(v81 != v41);
            goto LABEL_79;
          }
          v56 = *(_DWORD *)(v17 + 516);
          if ( (v56 & 8) != 0 )
          {
LABEL_125:
            v42 = 0;
            goto LABEL_79;
          }
          LOBYTE(v82) = *(_BYTE *)(v84 + 404);
          if ( (v82 & 3) == 2 && (*(_BYTE *)(v84 + 516) & 8) == 0 )
          {
            v57 = *(_DWORD *)(v84 + 504);
            if ( v57 > v83 )
            {
              v58 = v84;
              v59 = v83;
              *(_DWORD *)(*(_DWORD *)(v84 + 500) + 4 * v83 + 4) = v17;
              **(_DWORD **)(v58 + 500) = v59 + 1;
              goto LABEL_131;
            }
            if ( v57 )
            {
              v62 = 2 * v57;
              v63 = 4 * v62 + 4;
            }
            else
            {
              v63 = 44;
              v62 = 10;
            }
            v64 = malloc(v63);
            if ( v64 )
            {
              if ( v83 )
              {
                LODWORD(v81) = v64;
                v82 = *(_DWORD *)(v84 + 500);
                memcpy((_BYTE *)(v64 + 4), (_BYTE *)(v82 + 4), 4 * v83);
                v64 = v81;
              }
              v65 = v83;
              *(_DWORD *)(v64 + 4 * v83 + 4) = v17;
              *(_DWORD *)v64 = v65 + 1;
              v66 = v84;
              v67 = *(_DWORD *)(v84 + 500);
              *(_DWORD *)(v84 + 504) = v62;
              *(_DWORD *)(v66 + 500) = v64;
              if ( v67 )
                dl_scope_free(v67);
LABEL_131:
              if ( (dl_debug_mask & 0x40) != 0 )
              {
                v60 = *(const char **)(v84 + 4);
                if ( !*v60 )
                {
                  v60 = (const char *)program_invocation_short_name;
                  if ( !program_invocation_short_name )
                    v60 = "<main program>";
                }
                v61 = *(const char **)(v17 + 4);
                if ( !*v61 )
                {
                  v61 = (const char *)program_invocation_short_name;
                  if ( !program_invocation_short_name )
                    v61 = "<main program>";
                }
                v42 = 0;
                dl_debug_printf(
                  "\nfile=%s [%lu];  needed by %s [%lu] (relocation dependency)\n\n",
                  v61,
                  *(_DWORD *)(v17 + 24),
                  v60,
                  *(_DWORD *)(v84 + 24));
LABEL_79:
                if ( v80 )
                {
                  __writegsdword(0x1Cu, 1u);
                  if ( v42 == -1 )
                  {
                    a5 = *(int ***)(v84 + 460);
                    return dl_lookup_symbol_x(a5, a6, a7, a8, a9);
                  }
                }
                else if ( v42 == -1 )
                {
                  return dl_lookup_symbol_x(a5, a6, a7, a8, a9);
                }
                goto LABEL_116;
              }
              goto LABEL_125;
            }
          }
          *(_DWORD *)(v17 + 516) = v56 | 8;
          goto LABEL_125;
        }
        v17 = v84;
      }
      else
      {
        v91 = 0;
        v92 = 0;
        v19 = *a5;
        if ( !*a5 )
          goto LABEL_98;
        v20 = a5;
        v21 = v83;
        LOBYTE(v82) = a7 == 4;
        while ( 1 )
        {
          if ( (*(_BYTE *)(v16 + 12) & 0xF) != 1 || (v22 = 4, !(_BYTE)v82) )
            v22 = 1;
          if ( do_lookup_x(v85, v86, &v88, v16, (int *)&v91, v19, v21, a6, a8, a9, v22, 0) )
            break;
          v19 = *++v20;
          if ( !*v20 )
            break;
          v21 = 0;
          v16 = *i;
        }
        if ( v91 && (v17 = v84, (unsigned __int8 *)v84 != v92) )
        {
          v90 = v84;
          v89 = *i;
        }
        else
        {
LABEL_98:
          v17 = v90;
        }
      }
      v86 = 1;
      goto LABEL_16;
    }
    if ( !a9 && v15 )
      break;
    v12 = *++v14;
    v13 = 0;
    if ( !*v14 )
      goto LABEL_12;
  }
  if ( !a6 )
    _assert_fail("version != NULL", "dl-lookup.c", 844, "_dl_lookup_symbol_x");
  if ( v84 )
    v86 = *(_DWORD *)(v84 + 4);
  else
    v86 = (unsigned int)&unk_80CFAB1;
  v46 = v15 == -2;
  v47 = (const char **)&v92;
  v48 = (const char *)&unk_80CFAB1;
  v91 = "symbol ";
  v93 = ", version ";
  v95[0] = (int)" not defined in file ";
  v95[2] = (int)" with link time reference";
  v49 = 1;
  v92 = v85;
  v94 = *a6;
  v50 = (char *)&v92;
  v95[1] = (int)a6[3];
  if ( v46 )
    v48 = " (no version symbols)";
  v95[3] = (int)v48;
  for ( k = 7; ; k = strlen(v77) )
  {
    v49 += k;
    if ( &v96 == v50 )
      break;
    v77 = *(_BYTE **)v50;
    v50 += 4;
  }
  v52 = "symbol ";
  v53 = alloca(v49 + 15);
  v54 = v78;
  while ( 1 )
  {
    v54 = (char *)j_stpcpy(v54, v52);
    if ( v50 == (char *)v47 )
      break;
    v52 = *v47++;
  }
  if ( !*(_BYTE *)v86 )
  {
    v55 = "<main program>";
    if ( program_invocation_short_name )
      v55 = (char *)program_invocation_short_name;
    v86 = (unsigned int)v55;
  }
  v17 = 0;
  dl_signal_cerror(0, (char *)v86, "relocation error", a4, v78);
  *i = 0;
  return v17;
}
// 8048210: using guessed type int __cdecl j_stpcpy(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EBA40: using guessed type void *dl_ns;
// 80ECC60: using guessed type int dl_debug_mask;

//----- (080973B0) --------------------------------------------------------
_DWORD *__usercall dl_setup_hash@<eax>(_DWORD *result@<eax>)
{
  int v1; // edx
  int *v2; // edx
  int v3; // ecx
  int v4; // ebx
  int v5; // edi
  _DWORD *v6; // esi
  int v7; // edx
  _DWORD *v8; // edx
  int v9; // edx
  int *v10; // edx
  int v11; // ecx

  v1 = result[83];
  if ( v1 )
  {
    v2 = *(int **)(v1 + 4);
    v3 = *v2;
    result[94] = *v2;
    v4 = v2[2];
    v5 = v2[1];
    if ( ((v4 - 1) & v4) != 0 )
      _assert_fail("(bitmask_nwords & (bitmask_nwords - 1)) == 0", "dl-lookup.c", 971, "_dl_setup_hash");
    result[95] = v4 - 1;
    v6 = v2 + 4;
    v7 = v2[3];
    result[97] = v6;
    result[96] = v7;
    v8 = &v6[v4];
    result[98] = v8;
    result[99] = &v8[v3 - v5];
  }
  else
  {
    v9 = result[12];
    if ( v9 )
    {
      v10 = *(int **)(v9 + 4);
      v11 = *v10;
      v10 += 2;
      result[99] = v10;
      result[94] = v11;
      result[98] = &v10[v11];
    }
  }
  return result;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08097450) --------------------------------------------------------
int __usercall dl_add_to_namespace_list@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v4; // ecx
  __int64 v5; // rax
  unsigned int v6; // kr00_4
  int result; // eax

  v4 = (int)*(&dl_ns + 19 * a2);
  if ( v4 )
  {
    while ( *(_DWORD *)(v4 + 12) )
      v4 = *(_DWORD *)(v4 + 12);
    *(_DWORD *)(a1 + 16) = v4;
    *(_DWORD *)(v4 + 12) = a1;
  }
  else
  {
    *(&dl_ns + 19 * a2) = (void *)a1;
  }
  v5 = dl_load_adds;
  *(_QWORD *)(a1 + 596) = dl_load_adds;
  ++dword_80EBA44[19 * a2];
  v6 = v5;
  result = 0;
  dl_load_adds = __PAIR64__(HIDWORD(v5), v6) + 1;
  return result;
}
// 80EBA20: using guessed type __int64 dl_load_adds;
// 80EBA40: using guessed type void *dl_ns;
// 80EBA44: using guessed type int dword_80EBA44[];

//----- (080974F0) --------------------------------------------------------
int __userpurge dl_new_object@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, char a3@<cl>, int a4, char a5, int a6)
{
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  int v10; // esi
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  char v13; // dl
  bool v14; // zf
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // edi
  int v19; // eax
  int v20; // ebx
  _BYTE *v21; // esi
  _BYTE *v22; // eax
  int v23; // ebp
  _BYTE *v24; // ecx
  _BYTE *v26; // eax
  _BYTE *v27; // ecx
  _WORD *i; // eax
  _BYTE *v29; // ecx
  _BYTE *v30; // eax
  int v31; // [esp+Ch] [ebp-2Ch]
  char v34; // [esp+14h] [ebp-24h]
  int v35; // [esp+14h] [ebp-24h]
  unsigned int v36; // [esp+18h] [ebp-20h]

  v7 = a4;
  v8 = strlen(a2);
  v9 = calloc(v8 + 621, 1u);
  v10 = v9;
  if ( !v9 )
    return v10;
  *(_DWORD *)(v9 + 20) = v9;
  *(_DWORD *)(v9 + 356) = v9 + 604;
  *(_DWORD *)(v9 + 28) = v9 + 608;
  v11 = memcpy((_BYTE *)(v9 + 620), a2, v8 + 1);
  *(_DWORD *)(v10 + 608) = v11;
  v12 = &v11[v8];
  *(_DWORD *)(v10 + 616) = 1;
  v13 = *a1;
  if ( *a1 )
    v12 = a1;
  *(_DWORD *)(v10 + 4) = v12;
  v14 = (dl_debug_mask & 0x100) == 0;
  *(_BYTE *)(v10 + 404) = a3 & 3 | *(_BYTE *)(v10 + 404) & 0xFC;
  if ( v14 )
    *(_DWORD *)(v10 + 508) = 1;
  *(_DWORD *)(v10 + 364) = a4;
  *(_DWORD *)(v10 + 456) = 4;
  *(_DWORD *)(v10 + 24) = a6;
  *(_DWORD *)(v10 + 460) = v10 + 440;
  v15 = (int)*(&dl_ns + 19 * a6);
  if ( v15 )
  {
    v16 = v15 + 348;
    *(_DWORD *)(v10 + 440) = v16;
    if ( !a4 )
    {
      v7 = v10;
      goto LABEL_24;
    }
    v17 = 1;
  }
  else
  {
    if ( !a4 )
    {
      v7 = v10;
LABEL_12:
      v18 = v7 + 348;
      v19 = 0;
LABEL_13:
      *(_DWORD *)(v10 + v19 + 440) = v18;
      goto LABEL_14;
    }
    v17 = 0;
  }
  while ( *(_DWORD *)(v7 + 364) )
    v7 = *(_DWORD *)(v7 + 364);
  if ( !v17 )
    goto LABEL_12;
  v16 = *(_DWORD *)(v10 + 440);
LABEL_24:
  v18 = v7 + 348;
  if ( v16 != v18 )
  {
    if ( (a5 & 8) != 0 )
    {
      *(_DWORD *)(v10 + 444) = v16;
      v19 = 0;
    }
    else
    {
      v19 = 4;
    }
    goto LABEL_13;
  }
LABEL_14:
  v34 = v13;
  *(_DWORD *)(v10 + 464) = v10 + 348;
  if ( v13 )
  {
    v31 = strlen(a1);
    v36 = v31 + 1;
    v20 = v31 + 1;
    if ( v34 == 47 )
    {
      v30 = (_BYTE *)malloc(v36);
      v23 = (int)v30;
      if ( !v30 )
      {
        v23 = -1;
LABEL_21:
        *(_DWORD *)(v10 + 424) = v23;
        return v10;
      }
      v27 = v30;
    }
    else
    {
      v35 = v10;
      v21 = 0;
      while ( 1 )
      {
        v22 = (_BYTE *)realloc(v21, v20 + 128);
        v23 = (int)v22;
        if ( !v22 )
        {
LABEL_20:
          v24 = v21;
          v10 = v35;
          v23 = -1;
          free(v24);
          goto LABEL_21;
        }
        if ( getcwd(v22, v20 + 127 - v31) )
          break;
        v21 = (_BYTE *)v23;
        v20 += 128;
        if ( __readgsdword(0xFFFFFFE8) != 34 )
          goto LABEL_20;
      }
      v10 = v35;
      v26 = (_BYTE *)j_strchr(v23, 0);
      v27 = v26;
      if ( *(v26 - 1) != 47 )
      {
        v27 = v26 + 1;
        *v26 = 47;
      }
    }
    for ( i = mempcpy(v27, a1, v36); ; i = (_WORD *)((char *)i - 1) )
    {
      v29 = (char *)i - 1;
      if ( *((_BYTE *)i - 1) == 47 )
        break;
    }
    if ( (_BYTE *)v23 == v29 )
      v29 = i;
    *v29 = 0;
    goto LABEL_21;
  }
  return v10;
}
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EBA40: using guessed type void *dl_ns;
// 80ECC60: using guessed type int dl_debug_mask;

//----- (080977D0) --------------------------------------------------------
int __usercall dl_try_allocate_static_tls@<eax>(int a1@<eax>)
{
  unsigned int v1; // esi
  int v3; // edi
  unsigned int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // ecx
  int v7; // eax

  if ( *(_DWORD *)(a1 + 576) == -1 )
    return -1;
  v1 = *(_DWORD *)(a1 + 568);
  if ( v1 > dl_tls_static_align )
    return -1;
  if ( (unsigned int)(dl_tls_static_size - dl_tls_static_used) <= 0x4BF )
    return -1;
  v3 = *(_DWORD *)(a1 + 572);
  v4 = dl_tls_static_size - dl_tls_static_used - 1216;
  v5 = v3 + *(_DWORD *)(a1 + 564);
  if ( v4 < v5 )
    return -1;
  v6 = v4 + dl_tls_static_used - v3 - v1 * ((v4 - v5) / v1);
  v7 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 576) = v6;
  dl_tls_static_used = v6;
  if ( (*(_BYTE *)(v7 + 404) & 4) != 0 )
    dl_init_static_tls(a1);
  else
    *(_BYTE *)(a1 + 405) |= 4u;
  return 0;
}
// 80EB068: using guessed type int dl_tls_static_size;
// 80EBA0C: using guessed type int (__cdecl *dl_init_static_tls)(_DWORD);
// 80ECA00: using guessed type int dl_tls_static_used;
// 80ECA04: using guessed type int dl_tls_static_align;

//----- (08097880) --------------------------------------------------------
int __usercall dl_allocate_static_tls@<eax>(int a1@<eax>, long double a2@<st0>)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 576) == -1 || (result = dl_try_allocate_static_tls(a1)) != 0 )
    dl_signal_error(0, *(_BYTE **)(a1 + 4), 0, a2, "cannot allocate memory in static TLS block");
  return result;
}

//----- (080978C0) --------------------------------------------------------
int __cdecl dl_nothread_init_static_tls(int a1)
{
  unsigned int v1; // ebx
  _WORD *v2; // eax
  unsigned int v4; // [esp-4h] [ebp-14h]

  v4 = *(_DWORD *)(a1 + 560);
  v1 = *(_DWORD *)(a1 + 564) - v4;
  v2 = mempcpy((_BYTE *)(__readgsdword(8u) - *(_DWORD *)(a1 + 576)), *(_BYTE **)(a1 + 556), v4);
  return j_memset(v2, 0, v1);
}
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);

//----- (08097910) --------------------------------------------------------
_DWORD *__usercall dl_protect_relro@<eax>(_DWORD *result@<eax>, long double a2@<st0>)
{
  int v2; // ebx
  int v3; // edx
  int v4; // ebx
  int v5; // edx
  _DWORD *v6; // esi

  v2 = *result + result[147];
  v3 = result[148] + v2;
  v4 = -dl_pagesize & v2;
  v5 = -dl_pagesize & v3;
  if ( v4 != v5 )
  {
    v6 = result;
    result = (_DWORD *)mprotect(v4, v5 - v4);
    if ( (int)result < 0 )
      dl_signal_error(
        __readgsdword(0xFFFFFFE8),
        (_BYTE *)v6[1],
        0,
        a2,
        "cannot apply additional memory protection after relocation");
  }
  return result;
}
// 80EBA08: using guessed type int dl_pagesize;

//----- (08097970) --------------------------------------------------------
void __usercall __noreturn dl_reloc_bad_type(int a1@<eax>, unsigned __int8 a2@<dl>, int a3@<ecx>, long double a4@<st0>)
{
  _BYTE *v6; // eax
  char v7[44]; // [esp+10h] [ebp-2Ch] BYREF

  v6 = (_BYTE *)j_stpcpy(v7, 32 * a3 + 135065184);
  v6[2] = 0;
  *v6 = itoa_lower_digits[a2 >> 4];
  v6[1] = itoa_lower_digits[a2 & 0xF];
  dl_signal_error(0, *(_BYTE **)(a1 + 4), 0, a4, v7);
}
// 8048210: using guessed type int __cdecl j_stpcpy(_DWORD, _DWORD);

//----- (080979C0) --------------------------------------------------------
void __usercall dl_relocate_object(long double a1@<st0>, int a2, int **a3, int a4, int a5)
{
  int v5; // edi
  int v6; // esi
  int v7; // ebx
  int v8; // eax
  int v9; // edx
  unsigned int j; // eax
  int v11; // eax
  unsigned int v12; // ebx
  int v13; // esi
  int v14; // eax
  int v15; // edx
  int v16; // edi
  int v17; // eax
  _BYTE *v18; // esi
  int v19; // eax
  unsigned int v20; // eax
  _DWORD *v21; // esi
  unsigned int v22; // eax
  bool v23; // cc
  unsigned int k; // eax
  int v25; // eax
  unsigned int v26; // edx
  int v27; // ecx
  int v28; // ebx
  int v29; // eax
  _BYTE *v30; // esi
  int v31; // eax
  int *v32; // eax
  int *v33; // esi
  int v34; // eax
  unsigned int v35; // eax
  __int16 v36; // dx
  int v37; // ebx
  int v38; // edi
  unsigned int v39; // ecx
  int v40; // ecx
  int v41; // eax
  int v42; // edx
  bool v43; // zf
  const char **v44; // eax
  const char **v45; // ecx
  int v46; // eax
  int v47; // ecx
  int (*v48)(void); // edx
  int (*v49)(void); // eax
  int v50; // ecx
  int v51; // eax
  int v52; // edx
  const char *v53; // edx
  int v54; // ecx
  int v55; // edx
  __int16 v56; // dx
  int v57; // eax
  unsigned __int8 v58; // cl
  _BYTE *v59; // edx
  int v60; // edx
  _BYTE *v61; // edx
  int (__usercall *v62)@<eax>(int@<eax>); // eax
  int v63; // edx
  int v64; // ecx
  _DWORD *v65; // esi
  _DWORD *v66; // eax
  int v67; // eax
  _DWORD *v68; // edi
  unsigned int v69; // eax
  int v70; // esi
  int (__usercall **v71)@<eax>(int@<eax>); // edx
  int v72; // ebx
  unsigned int v73; // eax
  int v74; // ecx
  int v75; // edx
  int v76; // edx
  int v77; // eax
  int v78; // eax
  const char **v79; // ecx
  int v80; // eax
  int v81; // edx
  int v82; // ecx
  int (__usercall **v83)@<eax>(int@<eax>); // esi
  char *v84; // esi
  int v85; // eax
  unsigned int v86; // ecx
  int v87; // eax
  int v88; // eax
  int (__usercall **v89)@<eax>(int@<eax>); // esi
  _BYTE *v90; // edx
  int v91; // ecx
  int v92; // edx
  int v93; // edx
  int v94; // eax
  int v95; // ecx
  _DWORD *v96; // edx
  _DWORD *i; // ebx
  _BYTE *v98; // eax
  int v99; // eax
  const char *v100; // eax
  int v101; // eax
  int v102; // edx
  _BYTE *v103; // edx
  int v104; // ecx
  int v105; // eax
  int (*v106)(void); // eax
  unsigned int v107; // eax
  int v108; // ebx
  unsigned int v109; // edx
  int v110; // eax
  int v111; // edx
  int v112; // eax
  int v113; // ecx
  int (*v114)(void); // edx
  int v115; // ecx
  int v116; // eax
  _DWORD *v117; // edi
  int v118; // ecx
  int v119; // eax
  unsigned int v120; // ecx
  unsigned int v121; // edx
  unsigned int v122; // ecx
  unsigned int v123; // edx
  int v124; // ecx
  int v125; // eax
  int v126; // ecx
  int v127; // eax
  _DWORD *v128; // edi
  int (__usercall **v129)@<eax>(int@<eax>); // edx
  int v130; // ebx
  int v131; // ecx
  int v132; // ecx
  int v133; // ecx
  unsigned int v134; // edi
  int v135; // ebx
  int v136; // edi
  unsigned int v137; // edx
  int v138; // eax
  int v139; // edx
  int v140; // edx
  int v141; // eax
  int (__usercall **v142)@<eax>(int@<eax>); // edi
  char *v143; // edi
  int v144; // ecx
  unsigned int v145; // edx
  int v146; // ecx
  int v147; // ecx
  int (__usercall **v148)@<eax>(int@<eax>); // edi
  const char *v149; // edx
  _DWORD *v150; // edi
  int *v151; // ebx
  int v152; // eax
  int v153; // eax
  const char *v154; // eax
  int v155; // eax
  int v156; // eax
  int v157; // edx
  const char *v158; // edx
  int v159; // eax
  int v160; // edx
  int (*v161)(void); // eax
  int v162; // edx
  const char *v163; // eax
  int v164; // edx
  _DWORD *v165; // edi
  const char *v166; // edx
  const char *v167; // ecx
  _BYTE *v168; // [esp-20h] [ebp-B8h] BYREF
  int v169; // [esp-1Ch] [ebp-B4h]
  int v170; // [esp-18h] [ebp-B0h]
  int v171; // [esp-14h] [ebp-ACh]
  int v172; // [esp-8h] [ebp-A0h]
  const char *v173; // [esp-4h] [ebp-9Ch]
  int *v174; // [esp+4h] [ebp-94h]
  int v175; // [esp+8h] [ebp-90h]
  int *v176; // [esp+Ch] [ebp-8Ch]
  int v177; // [esp+10h] [ebp-88h]
  int v178; // [esp+14h] [ebp-84h]
  unsigned int v179; // [esp+18h] [ebp-80h]
  int v180; // [esp+1Ch] [ebp-7Ch]
  int (__usercall **v181)@<eax>(int@<eax>); // [esp+20h] [ebp-78h]
  int (*v182)(void); // [esp+30h] [ebp-68h]
  int v183; // [esp+34h] [ebp-64h]
  unsigned int v184; // [esp+38h] [ebp-60h]
  unsigned int v185; // [esp+3Ch] [ebp-5Ch]
  int v186; // [esp+48h] [ebp-50h] BYREF
  int v187; // [esp+4Ch] [ebp-4Ch] BYREF
  int v188; // [esp+50h] [ebp-48h] BYREF
  int v189; // [esp+54h] [ebp-44h] BYREF
  int v190; // [esp+58h] [ebp-40h] BYREF
  int v191; // [esp+5Ch] [ebp-3Ch] BYREF
  unsigned int v192; // [esp+60h] [ebp-38h] BYREF
  int v193; // [esp+64h] [ebp-34h]
  int v194; // [esp+68h] [ebp-30h]
  unsigned int v195; // [esp+70h] [ebp-28h]
  unsigned int v196; // [esp+74h] [ebp-24h]
  int v197; // [esp+7Ch] [ebp-1Ch]
  char v198[24]; // [esp+80h] [ebp-18h] BYREF

  v5 = a2;
  if ( (*(_BYTE *)(a2 + 404) & 4) != 0 )
    return;
  if ( a5 || !*(_DWORD *)(a2 + 128) )
  {
    v175 = a4 & 1;
    if ( (dl_debug_mask & 0x20) != 0 )
    {
      v53 = " (lazy)";
      if ( (a4 & 1) == 0 )
        v53 = (const char *)&unk_80CFAB1;
      goto LABEL_199;
    }
  }
  else
  {
    v175 = 0;
    if ( (dl_debug_mask & 0x20) != 0 )
    {
      v53 = (const char *)&unk_80CFAB1;
LABEL_199:
      v100 = *(const char **)(a2 + 4);
      if ( !*v100 )
      {
        v100 = (const char *)program_invocation_short_name;
        if ( !program_invocation_short_name )
          v100 = "<main program>";
      }
      dl_debug_printf("\nrelocation processing: %s%s\n", v100, v53);
    }
  }
  v6 = *(_DWORD *)(a2 + 120);
  v174 = 0;
  if ( v6 )
  {
    v95 = *(unsigned __int16 *)(a2 + 344);
    v96 = *(_DWORD **)(a2 + 336);
    for ( i = v96; i < &v96[8 * v95]; i += 8 )
    {
      if ( *i == 1 && (i[6] & 2) == 0 )
      {
        v185 = -dl_pagesize & i[2];
        v98 = (_BYTE *)(*(_DWORD *)a2 + v185);
        v169 = ((i[5] + i[2] + dl_pagesize - 1) & -dl_pagesize) - v185;
        v168 = v98;
        if ( (mprotect((int)v98, v169) & 0x80000000) != 0 )
        {
          v167 = "cannot make segment writable for relocation";
          goto LABEL_470;
        }
        v96 = *(_DWORD **)(a2 + 336);
        v95 = *(unsigned __int16 *)(a2 + 344);
        v170 = (1934713408 >> (4 * (i[6] & 7))) & 0xF;
        v99 = (int)v174;
        v174 = (int *)&v168;
        v171 = v99;
      }
    }
  }
  v7 = *(_DWORD *)(a2 + 124);
  v178 = *(_DWORD *)(*(_DWORD *)(a2 + 52) + 4);
  if ( v7 && v175 )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(a2 + 44) + 4);
    v9 = *(_DWORD *)(v8 + 4);
    if ( v9 )
    {
      *(_DWORD *)(a2 + 528) = *(_DWORD *)a2 + v9;
      *(_DWORD *)(a2 + 532) = v8 + 12;
    }
    *(_DWORD *)(v8 + 4) = a2;
    if ( a5 )
    {
      *(_DWORD *)(v8 + 8) = dl_runtime_profile;
      if ( dl_profile && dl_name_match_p(dl_profile, a2) )
        dl_profile_map = a2;
    }
    else
    {
      *(_DWORD *)(v8 + 8) = dl_runtime_resolve;
    }
  }
  for ( j = 0; j < 0x20; j += 4 )
    *(unsigned int *)((char *)&v192 + j) = 0;
  v11 = *(_DWORD *)(a2 + 100);
  if ( v11 )
  {
    v12 = *(_DWORD *)(v11 + 4);
    v13 = *(_DWORD *)(*(_DWORD *)(a2 + 104) + 4);
    v14 = *(_DWORD *)(a2 + 188);
    v192 = v12;
    v193 = v13;
    if ( v14 )
      v194 = *(_DWORD *)(v14 + 4);
    v185 = v12 + v13;
  }
  else
  {
    v185 = 0;
    v13 = 0;
    v12 = 0;
  }
  v15 = *(_DWORD *)(a2 + 112);
  if ( v15 && *(_DWORD *)(v15 + 4) == 17 )
  {
    v90 = *(_BYTE **)(*(_DWORD *)(a2 + 124) + 4);
    v91 = *(_DWORD *)(*(_DWORD *)(a2 + 40) + 4);
    if ( &v90[v91] == (_BYTE *)v185 )
    {
      v13 -= v91;
      v193 = v13;
      v185 = v13 + v12;
    }
    if ( !v175 && v90 == (_BYTE *)v185 )
    {
      v13 += v91;
      v193 = v13;
    }
    else
    {
      v195 = (unsigned int)v90;
      v196 = v91;
      v197 = v175;
    }
  }
  v16 = *(_DWORD *)a2;
  v177 = a4 & 0x2000000;
  v176 = (int *)&v192;
  v17 = 0;
  while ( 1 )
  {
    v18 = (_BYTE *)(v12 + v13);
    v185 = (unsigned int)v18;
    if ( !v17 )
    {
      v182 = *(int (**)(void))(*(_DWORD *)(a2 + 56) + 4);
      v65 = (_DWORD *)(v12 + 8 * v176[2]);
      if ( a2 && v16 && v12 < (unsigned int)v65 )
      {
        do
        {
          v66 = (_DWORD *)(v16 + *(_DWORD *)v12);
          if ( *(_BYTE *)(v12 + 4) != 8 )
            _assert_fail(
              "ELF32_R_TYPE (reloc->r_info) == R_386_RELATIVE",
              "../sysdeps/i386/dl-machine.h",
              618,
              "elf_machine_rel_relative");
          v12 += 8;
          *v66 += v16;
        }
        while ( (unsigned int)v65 > v12 );
      }
      v67 = *(_DWORD *)(a2 + 228);
      if ( v67 )
      {
        v180 = *(_DWORD *)(v67 + 4);
        if ( v185 > (unsigned int)v65 )
        {
          v179 = v16;
          v68 = v65;
          while ( 1 )
          {
            v69 = v68[1];
            v70 = (unsigned __int8)v69;
            v71 = (int (__usercall **)@<eax>(int@<eax>))(*v68 + v179);
            v72 = (int)v182 + 16 * (v69 >> 8);
            LOWORD(v184) = *(_WORD *)(v180 + 2 * (v69 >> 8));
            v181 = v71;
            v189 = v72;
            v183 = *(_DWORD *)(a2 + 368);
            if ( (unsigned __int8)v69 == 8 )
            {
              *v181 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v181 + *(_DWORD *)a2);
              goto LABEL_127;
            }
            if ( (_BYTE)v69 )
              break;
LABEL_127:
            v68 += 2;
            if ( v185 <= (unsigned int)v68 )
              goto LABEL_30;
          }
          if ( !(*(_BYTE *)(v72 + 12) >> 4) || (*(_BYTE *)(v72 + 13) & 3u) - 1 <= 1 )
          {
            v81 = (int)v182 + 16 * (v69 >> 8);
            v82 = a2;
LABEL_123:
            v184 = *(_DWORD *)v82 + *(_DWORD *)(v81 + 4);
LABEL_124:
            if ( (*(_BYTE *)(v81 + 12) & 0xF) == 10 && *(_WORD *)(v81 + 14) && !v177 )
            {
              v183 = v82;
              v184 = ((int (*)(void))v184)();
              v82 = v183;
              switch ( v70 )
              {
                case 1:
                  goto LABEL_138;
                case 2:
                  goto LABEL_136;
                case 5:
                  v81 = v189;
                  if ( v189 )
                    goto LABEL_144;
                  goto LABEL_127;
                case 6:
                case 7:
                  goto LABEL_134;
                case 14:
                  v81 = v189;
                  if ( v189 )
                    goto LABEL_140;
                  goto LABEL_127;
                case 35:
                  goto LABEL_131;
                case 36:
                  v81 = v189;
                  if ( v189 )
                    goto LABEL_154;
                  goto LABEL_127;
                case 37:
                  v81 = v189;
                  if ( v189 )
                    goto LABEL_150;
                  goto LABEL_127;
                case 38:
                  v81 = v189;
                  goto LABEL_130;
                case 41:
                  v81 = v189;
                  if ( v189 )
                    goto LABEL_156;
                  goto LABEL_265;
                case 42:
                  goto LABEL_126;
                default:
                  goto LABEL_159;
              }
            }
            switch ( v70 )
            {
              case 1:
                goto LABEL_138;
              case 2:
                goto LABEL_136;
              case 5:
LABEL_144:
                v86 = *(_DWORD *)(v72 + 8);
                if ( *(_DWORD *)(v81 + 8) > v86 || *(_DWORD *)(v81 + 8) < v86 && dl_verbose )
                {
                  v149 = (const char *)program_invocation_short_name;
                  v173 = (const char *)(*(_DWORD *)(*(_DWORD *)(a2 + 52) + 4) + *(_DWORD *)v72);
                  if ( !program_invocation_short_name )
                    v149 = "<program name unknown>";
                  dl_dprintf(
                    2,
                    "%s: Symbol `%s' has different size in shared object, consider re-linking\n",
                    v149,
                    v173);
                  v86 = *(_DWORD *)(v72 + 8);
                }
                if ( *(_DWORD *)(v189 + 8) <= v86 )
                  v86 = *(_DWORD *)(v189 + 8);
                memcpy(v181, (_BYTE *)v184, v86);
                goto LABEL_127;
              case 6:
              case 7:
                goto LABEL_134;
              case 14:
LABEL_140:
                v85 = *(_DWORD *)(v82 + 576);
                if ( (unsigned int)(v85 + 1) <= 1 )
                {
                  v184 = v82;
                  dl_allocate_static_tls(v82, a1);
                  v81 = v189;
                  v85 = *(_DWORD *)(v184 + 576);
                }
                *v181 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v181 + *(_DWORD *)(v81 + 4) - v85);
                goto LABEL_127;
              case 35:
LABEL_131:
                if ( v82 )
                  *v181 = *(int (__usercall **)@<eax>(int@<eax>))(v82 + 580);
                goto LABEL_127;
              case 36:
LABEL_154:
                *v181 = *(int (__usercall **)@<eax>(int@<eax>))(v81 + 4);
                goto LABEL_127;
              case 37:
LABEL_150:
                v87 = *(_DWORD *)(v82 + 576);
                if ( (unsigned int)(v87 + 1) <= 1 )
                {
                  v184 = v82;
                  dl_allocate_static_tls(v82, a1);
                  v81 = v189;
                  v87 = *(_DWORD *)(v184 + 576);
                }
                *v181 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v181 + v87 - *(_DWORD *)(v81 + 4));
                goto LABEL_127;
              case 38:
                goto LABEL_130;
              case 41:
LABEL_156:
                v88 = *(_DWORD *)(v82 + 576);
                if ( (unsigned int)(v88 + 1) <= 1 )
                {
                  v184 = v82;
                  dl_allocate_static_tls(v82, a1);
                  v81 = v189;
                  v88 = *(_DWORD *)(v184 + 576);
                }
                v89 = v181;
                v181[1] = (int (__usercall *)@<eax>(int@<eax>))((char *)v181[1] + *(_DWORD *)(v81 + 4) - v88);
                *v89 = dl_tlsdesc_return;
                goto LABEL_127;
              case 42:
                goto LABEL_126;
              default:
                goto LABEL_159;
            }
          }
          if ( v72 != *(_DWORD *)(a2 + 540) )
          {
            if ( (unsigned __int8)v69 == 7 || (unsigned __int8)v69 == 35 )
            {
              v74 = 1;
              goto LABEL_117;
            }
            goto LABEL_113;
          }
          if ( (unsigned int)(unsigned __int8)v69 - 7 <= 0x1E
            && (v92 = 1879048321, _bittest(&v92, (unsigned __int8)v69 - 7)) )
          {
            v93 = 1;
          }
          else
          {
            v93 = (unsigned __int8)v69 == 41;
            if ( (unsigned __int8)v69 == 5 )
            {
              v93 |= 2u;
              v94 = 0;
              goto LABEL_267;
            }
          }
          if ( (unsigned __int8)v69 != 6 )
          {
            if ( *(_DWORD *)(a2 + 544) != v93 )
            {
              if ( (unsigned __int8)v69 == 35 || (unsigned __int8)v69 == 7 )
              {
                v75 = 0;
                v74 = 1;
                goto LABEL_118;
              }
LABEL_113:
              v73 = 0;
              if ( (unsigned int)(v70 - 14) <= 0x1B )
                v73 = (0x8C00001u >> (v70 - 14)) & 1;
              v74 = v73;
LABEL_116:
              if ( v70 == 5 )
              {
                v74 |= 2u;
                v75 = 0;
                goto LABEL_118;
              }
LABEL_117:
              v75 = 4 * (v70 == 6);
LABEL_118:
              v76 = v74 | v75;
              v77 = v184 & 0x7FFF;
              *(_DWORD *)(a2 + 544) = v76;
              *(_DWORD *)(a2 + 540) = v72;
              v78 = v183 + 16 * v77;
              if ( v78 )
              {
                v79 = 0;
                if ( *(_DWORD *)(v78 + 4) )
                  v79 = (const char **)v78;
              }
              else
              {
                v79 = 0;
              }
              v80 = dl_lookup_symbol_x((unsigned __int8 *)(*(_DWORD *)v72 + v178), a2, &v189, a1, a3, v79, v76, 1, 0);
              v81 = v189;
              v82 = v80;
              *(_DWORD *)(a2 + 552) = v189;
              *(_DWORD *)(a2 + 548) = v80;
              goto LABEL_122;
            }
LABEL_268:
            v81 = *(_DWORD *)(a2 + 552);
            v82 = *(_DWORD *)(a2 + 548);
            v189 = v81;
LABEL_122:
            if ( v82 )
              goto LABEL_123;
            if ( v81 )
            {
              v184 = 0;
              goto LABEL_124;
            }
            switch ( v70 )
            {
              case 1:
                v184 = 0;
LABEL_138:
                *v181 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v181 + v184);
                break;
              case 2:
                v184 = 0;
LABEL_136:
                v84 = (char *)v181;
                v181 = (int (__usercall **)@<eax>(int@<eax>))*v181;
                *(_DWORD *)v84 = (char *)v181 - v84 + v184;
                break;
              case 5:
              case 14:
              case 35:
              case 36:
              case 37:
                goto LABEL_127;
              case 6:
              case 7:
                v184 = 0;
LABEL_134:
                *v181 = (int (__usercall *)@<eax>(int@<eax>))v184;
                break;
              case 38:
LABEL_130:
                *v181 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v181 + *(_DWORD *)(v81 + 8));
                break;
              case 41:
LABEL_265:
                *v181 = (int (__usercall *)@<eax>(int@<eax>))dl_tlsdesc_undefweak;
                break;
              case 42:
LABEL_126:
                v83 = v181;
                *v83 = (int (__usercall *)@<eax>(int@<eax>))((int (*)(void))((char *)*v181 + *(_DWORD *)a2))();
                break;
              default:
LABEL_159:
                dl_reloc_bad_type(a2, v70, 0, a1);
            }
            goto LABEL_127;
          }
          v94 = 4;
LABEL_267:
          v74 = 0;
          if ( *(_DWORD *)(a2 + 544) != (v93 | v94) )
            goto LABEL_116;
          goto LABEL_268;
        }
LABEL_30:
        v16 = *(_DWORD *)a2;
        goto LABEL_31;
      }
      if ( v185 <= (unsigned int)v65 )
        goto LABEL_30;
      v183 = v16;
      while ( 1 )
      {
        v134 = v65[1];
        v135 = (unsigned __int8)v134;
        v136 = (int)v182 + 16 * (v134 >> 8);
        v181 = (int (__usercall **)@<eax>(int@<eax>))(*v65 + v183);
        v188 = v136;
        if ( v135 == 8 )
        {
          *v181 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v181 + *(_DWORD *)a2);
          goto LABEL_336;
        }
        if ( v135 )
          break;
LABEL_336:
        v65 += 2;
        if ( v185 <= (unsigned int)v65 )
          goto LABEL_30;
      }
      if ( !(*(_BYTE *)(v136 + 12) >> 4) || (*(_BYTE *)(v136 + 13) & 3u) - 1 <= 1 )
      {
        v141 = v136;
        v140 = a2;
LABEL_332:
        v184 = *(_DWORD *)v140 + *(_DWORD *)(v141 + 4);
LABEL_333:
        if ( (*(_BYTE *)(v141 + 12) & 0xF) == 10 && *(_WORD *)(v141 + 14) && !v177 )
        {
          v180 = v140;
          v184 = ((int (*)(void))v184)();
          v140 = v180;
          switch ( v135 )
          {
            case 1:
              goto LABEL_347;
            case 2:
              goto LABEL_345;
            case 5:
              v141 = v188;
              if ( v188 )
                goto LABEL_353;
              goto LABEL_336;
            case 6:
            case 7:
              goto LABEL_343;
            case 14:
              v141 = v188;
              if ( v188 )
                goto LABEL_349;
              goto LABEL_336;
            case 35:
              goto LABEL_340;
            case 36:
              v141 = v188;
              if ( v188 )
                goto LABEL_363;
              goto LABEL_336;
            case 37:
              v141 = v188;
              if ( v188 )
                goto LABEL_359;
              goto LABEL_336;
            case 38:
              v141 = v188;
              goto LABEL_339;
            case 41:
              v141 = v188;
              if ( v188 )
                goto LABEL_365;
              goto LABEL_373;
            case 42:
              goto LABEL_335;
            default:
              goto LABEL_368;
          }
        }
        switch ( v135 )
        {
          case 1:
            goto LABEL_347;
          case 2:
            goto LABEL_345;
          case 5:
LABEL_353:
            v145 = *(_DWORD *)(v136 + 8);
            if ( *(_DWORD *)(v141 + 8) > v145 || *(_DWORD *)(v141 + 8) < v145 && dl_verbose )
            {
              v163 = (const char *)program_invocation_short_name;
              v173 = (const char *)(*(_DWORD *)(*(_DWORD *)(a2 + 52) + 4) + *(_DWORD *)v136);
              if ( !program_invocation_short_name )
                v163 = "<program name unknown>";
              dl_dprintf(2, "%s: Symbol `%s' has different size in shared object, consider re-linking\n", v163, v173);
              v145 = *(_DWORD *)(v136 + 8);
            }
            if ( *(_DWORD *)(v188 + 8) <= v145 )
              v145 = *(_DWORD *)(v188 + 8);
            memcpy(v181, (_BYTE *)v184, v145);
            goto LABEL_336;
          case 6:
          case 7:
            goto LABEL_343;
          case 14:
LABEL_349:
            v144 = *(_DWORD *)(v140 + 576);
            if ( (unsigned int)(v144 + 1) <= 1 )
            {
              v184 = v140;
              dl_allocate_static_tls(v140, a1);
              v141 = v188;
              v144 = *(_DWORD *)(v184 + 576);
            }
            *v181 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v181 + *(_DWORD *)(v141 + 4) - v144);
            goto LABEL_336;
          case 35:
LABEL_340:
            if ( v140 )
              *v181 = *(int (__usercall **)@<eax>(int@<eax>))(v140 + 580);
            goto LABEL_336;
          case 36:
LABEL_363:
            *v181 = *(int (__usercall **)@<eax>(int@<eax>))(v141 + 4);
            goto LABEL_336;
          case 37:
LABEL_359:
            v146 = *(_DWORD *)(v140 + 576);
            if ( (unsigned int)(v146 + 1) <= 1 )
            {
              v184 = v140;
              dl_allocate_static_tls(v140, a1);
              v141 = v188;
              v146 = *(_DWORD *)(v184 + 576);
            }
            *v181 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v181 + v146 - *(_DWORD *)(v141 + 4));
            goto LABEL_336;
          case 38:
            goto LABEL_339;
          case 41:
LABEL_365:
            v147 = *(_DWORD *)(v140 + 576);
            if ( (unsigned int)(v147 + 1) <= 1 )
            {
              v184 = v140;
              dl_allocate_static_tls(v140, a1);
              v141 = v188;
              v147 = *(_DWORD *)(v184 + 576);
            }
            v148 = v181;
            v181[1] = (int (__usercall *)@<eax>(int@<eax>))((char *)v181[1] + *(_DWORD *)(v141 + 4) - v147);
            *v148 = dl_tlsdesc_return;
            goto LABEL_336;
          case 42:
            goto LABEL_335;
          default:
            goto LABEL_368;
        }
      }
      if ( v136 != *(_DWORD *)(a2 + 540) )
      {
        if ( v135 != 7 && v135 != 35 )
        {
LABEL_326:
          v137 = 0;
          if ( (unsigned int)(v135 - 14) <= 0x1B )
            v137 = (0x8C00001u >> (v135 - 14)) & 1;
          goto LABEL_328;
        }
        v137 = 1;
LABEL_328:
        if ( v135 == 5 )
        {
          v137 |= 2u;
          v138 = 0;
        }
        else
        {
          v138 = 4 * (v135 == 6);
        }
        goto LABEL_330;
      }
      if ( (unsigned int)(v135 - 7) <= 0x1E && (v157 = 1879048321, _bittest(&v157, v135 - 7)) )
      {
        v156 = 1;
      }
      else
      {
        v156 = v135 == 41;
        if ( v135 == 5 )
        {
          v156 |= 2u;
          v162 = 0;
          goto LABEL_442;
        }
      }
      if ( v135 != 6 )
      {
        if ( *(_DWORD *)(a2 + 544) != v156 )
        {
          if ( v135 == 35 || v135 == 7 )
          {
            v138 = 0;
            v137 = 1;
LABEL_330:
            v139 = v138 | v137;
            *(_DWORD *)(a2 + 544) = v139;
            *(_DWORD *)(a2 + 540) = v136;
            v140 = dl_lookup_symbol_x((unsigned __int8 *)(*(_DWORD *)v136 + v178), a2, &v188, a1, a3, 0, v139, 1, 0);
            v141 = v188;
            *(_DWORD *)(a2 + 552) = v188;
            *(_DWORD *)(a2 + 548) = v140;
LABEL_331:
            if ( v140 )
              goto LABEL_332;
            if ( v141 )
            {
              v184 = 0;
              goto LABEL_333;
            }
            switch ( v135 )
            {
              case 1:
                v184 = 0;
LABEL_347:
                *v181 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v181 + v184);
                break;
              case 2:
                v184 = 0;
LABEL_345:
                v143 = (char *)v181;
                v181 = (int (__usercall **)@<eax>(int@<eax>))*v181;
                *(_DWORD *)v143 = v184 + (char *)v181 - v143;
                break;
              case 5:
              case 14:
              case 35:
              case 36:
              case 37:
                goto LABEL_336;
              case 6:
              case 7:
                v184 = 0;
LABEL_343:
                *v181 = (int (__usercall *)@<eax>(int@<eax>))v184;
                break;
              case 38:
LABEL_339:
                *v181 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v181 + *(_DWORD *)(v141 + 8));
                break;
              case 41:
LABEL_373:
                *v181 = (int (__usercall *)@<eax>(int@<eax>))dl_tlsdesc_undefweak;
                break;
              case 42:
LABEL_335:
                v142 = v181;
                *v142 = (int (__usercall *)@<eax>(int@<eax>))((int (*)(void))((char *)*v181 + *(_DWORD *)a2))();
                break;
              default:
LABEL_368:
                dl_reloc_bad_type(a2, v135, 0, a1);
            }
            goto LABEL_336;
          }
          goto LABEL_326;
        }
        goto LABEL_445;
      }
      v162 = 4;
LABEL_442:
      if ( *(_DWORD *)(a2 + 544) != (v162 | v156) )
      {
        v137 = 0;
        goto LABEL_328;
      }
LABEL_445:
      v141 = *(_DWORD *)(a2 + 552);
      v140 = *(_DWORD *)(a2 + 548);
      v188 = v141;
      goto LABEL_331;
    }
    if ( v12 < (unsigned int)v18 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v20 = *(_DWORD *)(v12 + 4);
          v21 = (_DWORD *)(v16 + *(_DWORD *)v12);
          if ( (unsigned __int8)v20 == 7 )
          {
            v19 = *(_DWORD *)(a2 + 528);
            if ( v19 )
              *v21 = v19 + 4 * ((_DWORD)v21 - *(_DWORD *)(a2 + 532));
            else
              *v21 += v16;
            goto LABEL_25;
          }
          if ( (unsigned __int8)v20 != 41 )
          {
            if ( (unsigned __int8)v20 != 42 )
              dl_reloc_bad_type(a2, v20, 1, a1);
            v161 = (int (*)(void))(*(_DWORD *)a2 + *v21);
            if ( !v177 )
              v161 = (int (*)(void))v161();
            *v21 = v161;
            goto LABEL_25;
          }
          v22 = v20 >> 8;
          if ( v22 )
            break;
          v12 += 8;
          v23 = v185 <= v12;
          *v21 = dl_tlsdesc_resolve_abs_plus_addend;
          if ( v23 )
            goto LABEL_30;
        }
        if ( v21[1] )
          break;
        v21[1] = v12;
        *v21 = dl_tlsdesc_resolve_rel;
LABEL_25:
        v12 += 8;
        if ( v185 <= v12 )
          goto LABEL_30;
      }
      v54 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 4);
      v55 = *(_DWORD *)(a2 + 228);
      if ( v55 )
      {
        v56 = *(_WORD *)(*(_DWORD *)(v55 + 4) + 2 * v22);
        v57 = v54 + 16 * v22;
        v58 = *(_BYTE *)(v57 + 12);
        v187 = v57;
        LOWORD(v181) = v56;
        v184 = *(_DWORD *)(a2 + 368);
        if ( !(v58 >> 4) )
        {
          v59 = (_BYTE *)a2;
LABEL_93:
          v181 = (int (__usercall **)@<eax>(int@<eax>))(*(_DWORD *)v59 + *(_DWORD *)(v57 + 4));
LABEL_94:
          if ( (*(_BYTE *)(v57 + 12) & 0xF) != 10
            || !*(_WORD *)(v57 + 14)
            || v177
            || (v184 = (unsigned int)v59, ((void (*)(void))v181)(), v59 = (_BYTE *)v184, v187) )
          {
            v62 = (int (__usercall *)@<eax>(int@<eax>))*((_DWORD *)v59 + 144);
            if ( (unsigned int)v62 + 1 <= 1 )
            {
              v181 = (int (__usercall **)@<eax>(int@<eax>))v59;
              dl_allocate_static_tls((int)v59, a1);
              v62 = v181[144];
            }
            v63 = v21[1];
            v64 = v187;
LABEL_264:
            v21[1] = *(_DWORD *)(v64 + 4) + v63 - (_DWORD)v62;
            *v21 = dl_tlsdesc_return;
            goto LABEL_25;
          }
          goto LABEL_207;
        }
        v59 = (_BYTE *)a2;
        if ( (*(_BYTE *)(v57 + 13) & 3u) - 1 <= 1 )
          goto LABEL_93;
        if ( v57 == *(_DWORD *)(a2 + 540) && *(_DWORD *)(a2 + 544) == 1 )
        {
          v57 = *(_DWORD *)(a2 + 552);
          v59 = *(_BYTE **)(a2 + 548);
          v187 = v57;
        }
        else
        {
          v60 = (unsigned __int16)v181 & 0x7FFF;
          *(_DWORD *)(a2 + 544) = 1;
          *(_DWORD *)(a2 + 540) = v57;
          v61 = (_BYTE *)(v184 + 16 * v60);
          if ( v61 )
          {
            if ( !*((_DWORD *)v61 + 1) )
              v61 = 0;
          }
          else
          {
            v61 = 0;
          }
          v59 = (_BYTE *)dl_lookup_symbol_x(
                           (unsigned __int8 *)(*(_DWORD *)v57 + v178),
                           a2,
                           &v187,
                           a1,
                           a3,
                           (const char **)v61,
                           1,
                           1,
                           0);
          v57 = v187;
          *(_DWORD *)(a2 + 552) = v187;
          *(_DWORD *)(a2 + 548) = v59;
        }
        if ( v59 )
          goto LABEL_93;
        if ( v57 )
        {
          v181 = 0;
          goto LABEL_94;
        }
LABEL_207:
        *v21 = dl_tlsdesc_undefweak;
        goto LABEL_25;
      }
      v101 = v54 + 16 * v22;
      v102 = *(unsigned __int8 *)(v101 + 12);
      v186 = v101;
      if ( (unsigned __int8)v102 >> 4 )
      {
        v103 = (_BYTE *)a2;
        if ( (*(_BYTE *)(v101 + 13) & 3u) - 1 > 1 )
        {
          if ( v101 == *(_DWORD *)(a2 + 540) && *(_DWORD *)(a2 + 544) == 1 )
          {
            v101 = *(_DWORD *)(a2 + 552);
            v103 = *(_BYTE **)(a2 + 548);
            v186 = v101;
          }
          else
          {
            *(_DWORD *)(a2 + 540) = v101;
            *(_DWORD *)(a2 + 544) = 1;
            v103 = (_BYTE *)dl_lookup_symbol_x(
                              (unsigned __int8 *)(*(_DWORD *)v101 + v178),
                              a2,
                              &v186,
                              a1,
                              a3,
                              0,
                              1,
                              1,
                              0);
            v101 = v186;
            *(_DWORD *)(a2 + 552) = v186;
            *(_DWORD *)(a2 + 548) = v103;
          }
          if ( !v103 )
          {
            if ( !v101 )
              goto LABEL_207;
            v181 = 0;
LABEL_260:
            if ( (*(_BYTE *)(v101 + 12) & 0xF) != 10
              || !*(_WORD *)(v101 + 14)
              || v177
              || (v184 = (unsigned int)v103, ((void (*)(void))v181)(), v103 = (_BYTE *)v184, v186) )
            {
              v62 = (int (__usercall *)@<eax>(int@<eax>))*((_DWORD *)v103 + 144);
              if ( (unsigned int)v62 + 1 <= 1 )
              {
                v181 = (int (__usercall **)@<eax>(int@<eax>))v103;
                dl_allocate_static_tls((int)v103, a1);
                v62 = v181[144];
              }
              v63 = v21[1];
              v64 = v186;
              goto LABEL_264;
            }
            goto LABEL_207;
          }
        }
      }
      else
      {
        v103 = (_BYTE *)a2;
      }
      v181 = (int (__usercall **)@<eax>(int@<eax>))(*(_DWORD *)v103 + *(_DWORD *)(v101 + 4));
      goto LABEL_260;
    }
LABEL_31:
    v176 += 4;
    if ( v198 == (char *)v176 )
      break;
    v17 = v176[3];
    v13 = v176[1];
    v12 = *v176;
  }
  v181 = (int (__usercall **)@<eax>(int@<eax>))v16;
  for ( k = 0; k < 0x20; k += 4 )
    *(unsigned int *)((char *)&v192 + k) = 0;
  v25 = *(_DWORD *)(a2 + 60);
  if ( v25 )
  {
    v26 = *(_DWORD *)(v25 + 4);
    v27 = 0;
    v28 = *(_DWORD *)(*(_DWORD *)(a2 + 64) + 4);
    v29 = *(_DWORD *)(a2 + 192);
    v192 = v26;
    v193 = v28;
    v30 = (_BYTE *)(v26 + v28);
    if ( v29 )
    {
      v27 = *(_DWORD *)(v29 + 4);
      v30 = (_BYTE *)(v26 + v28);
      v194 = v27;
    }
  }
  else
  {
    v27 = 0;
    v30 = 0;
    v28 = 0;
    v26 = 0;
  }
  v31 = *(_DWORD *)(a2 + 112);
  if ( v31 && *(_DWORD *)(v31 + 4) == 7 )
  {
    v185 = *(_DWORD *)(*(_DWORD *)(a2 + 124) + 4);
    v184 = *(_DWORD *)(*(_DWORD *)(a2 + 40) + 4);
    if ( (_BYTE *)(v185 + v184) == v30 )
    {
      v28 -= v184;
      v193 = v28;
      v30 = (_BYTE *)(v28 + v26);
    }
    if ( !v175 && (_BYTE *)v185 == v30 )
    {
      v28 += v184;
      v193 = v28;
    }
    else
    {
      v195 = v185;
      v196 = v184;
    }
  }
  v176 = (int *)&v192;
  while ( 1 )
  {
    v32 = (int *)v26;
    v184 = v26 + v28;
    v33 = (int *)(v26 + 12 * v27);
    v183 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 4);
    if ( a2 && (v181 || !*(_DWORD *)(a2 + 284)) && v26 < (unsigned int)v33 )
    {
      v129 = v181;
      do
      {
        v130 = v32[2];
        v131 = *v32;
        v32 += 3;
        *(int (__usercall **)@<eax>(int@<eax>))((char *)v129 + v131) = (int (__usercall *)@<eax>(int@<eax>))((char *)v129 + v130);
      }
      while ( v33 > v32 );
    }
    v34 = *(_DWORD *)(a2 + 228);
    if ( !v34 )
    {
      while ( 1 )
      {
        if ( v184 <= (unsigned int)v33 )
          goto LABEL_73;
        v185 = (unsigned int)v181 + *v33;
        v107 = v33[1];
        v38 = (unsigned __int8)v107;
        v108 = v183 + 16 * (v107 >> 8);
        v190 = v108;
        if ( (unsigned __int8)v107 == 8 )
        {
          *(_DWORD *)v185 = *(_DWORD *)a2 + v33[2];
          goto LABEL_213;
        }
        if ( !(_BYTE)v107 )
          goto LABEL_213;
        if ( !(*(_BYTE *)(v108 + 12) >> 4) || (*(_BYTE *)(v108 + 13) & 3u) - 1 <= 1 )
        {
          v113 = v183 + 16 * (v107 >> 8);
          v114 = (int (*)(void))a2;
LABEL_228:
          v106 = (int (*)(void))(*(_DWORD *)v114 + *(_DWORD *)(v113 + 4));
          if ( *(_WORD *)(v113 + 14) && (*(_BYTE *)(v113 + 12) & 0xF) == 10 && !v177 )
          {
            v182 = v114;
            v106 = (int (*)(void))v106();
            v114 = v182;
          }
          goto LABEL_232;
        }
        if ( v108 != *(_DWORD *)(a2 + 540) )
        {
          if ( (unsigned __int8)v107 != 7 && (unsigned __int8)v107 != 35 )
            goto LABEL_222;
          v109 = 1;
          goto LABEL_224;
        }
        if ( (unsigned int)(unsigned __int8)v107 - 7 <= 0x1E
          && (v160 = 1879048321, _bittest(&v160, (unsigned __int8)v107 - 7)) )
        {
          v159 = 1;
        }
        else
        {
          v159 = (unsigned __int8)v107 == 41;
          if ( v38 == 5 )
          {
            v159 |= 2u;
            v164 = 0;
LABEL_456:
            if ( *(_DWORD *)(a2 + 544) != (v164 | v159) )
            {
              v109 = 0;
              goto LABEL_224;
            }
            goto LABEL_454;
          }
        }
        if ( v38 == 6 )
        {
          v164 = 4;
          goto LABEL_456;
        }
        if ( *(_DWORD *)(a2 + 544) != v159 )
        {
          if ( v38 == 35 || v38 == 7 )
          {
            v109 = 1;
            v110 = 0;
LABEL_226:
            v111 = v110 | v109;
            *(_DWORD *)(a2 + 544) = v111;
            *(_DWORD *)(a2 + 540) = v108;
            v112 = dl_lookup_symbol_x((unsigned __int8 *)(*(_DWORD *)v108 + v178), a2, &v190, a1, a3, 0, v111, 1, 0);
            v113 = v190;
            v114 = (int (*)(void))v112;
            *(_DWORD *)(a2 + 552) = v190;
            *(_DWORD *)(a2 + 548) = v112;
            goto LABEL_227;
          }
LABEL_222:
          v109 = (0x8C00001u >> (v38 - 14)) & 1;
          if ( (unsigned int)(v38 - 14) > 0x1B )
            v109 = 0;
LABEL_224:
          if ( v38 == 5 )
          {
            v109 |= 2u;
            v110 = 0;
          }
          else
          {
            v110 = 4 * (v38 == 6);
          }
          goto LABEL_226;
        }
LABEL_454:
        v113 = *(_DWORD *)(a2 + 552);
        v114 = *(int (**)(void))(a2 + 548);
        v190 = v113;
LABEL_227:
        v106 = 0;
        if ( v113 )
          goto LABEL_228;
LABEL_232:
        switch ( *((_BYTE *)v33 + 4) )
        {
          case 1:
          case 6:
          case 7:
            goto LABEL_212;
          case 2:
            *(_DWORD *)v185 = (char *)v106 + v33[2] - v185;
            break;
          case 5:
            if ( v190 )
            {
              v122 = *(_DWORD *)(v190 + 8);
              v123 = *(_DWORD *)(v108 + 8);
              if ( v122 > v123 || v122 < v123 && dl_verbose )
              {
                v182 = v106;
                v166 = (const char *)program_invocation_short_name;
                v173 = (const char *)(*(_DWORD *)(*(_DWORD *)(a2 + 52) + 4) + *(_DWORD *)v108);
                if ( !program_invocation_short_name )
                  v166 = "<program name unknown>";
                dl_dprintf(2, "%s: Symbol `%s' has different size in shared object, consider re-linking\n", v166, v173);
                v123 = *(_DWORD *)(v108 + 8);
                v106 = v182;
                v122 = *(_DWORD *)(v190 + 8);
              }
              if ( v123 > v122 )
                v123 = v122;
              memcpy((_BYTE *)v185, v106, v123);
            }
            break;
          case 0xE:
            v104 = v190;
            if ( !v190 )
              break;
            v105 = *((_DWORD *)v114 + 144);
            if ( (unsigned int)(v105 + 1) <= 1 )
            {
              v182 = v114;
              dl_allocate_static_tls((int)v114, a1);
              v104 = v190;
              v105 = *((_DWORD *)v182 + 144);
            }
            v106 = (int (*)(void))(*(_DWORD *)(v104 + 4) - v105);
LABEL_212:
            *(_DWORD *)v185 = (char *)v106 + v33[2];
            break;
          case 0x23:
            if ( v114 )
              *(_DWORD *)v185 = *((_DWORD *)v114 + 145);
            break;
          case 0x24:
            if ( v190 )
              v106 = *(int (**)(void))(v190 + 4);
            else
              v106 = 0;
            goto LABEL_212;
          case 0x25:
            v124 = v190;
            if ( v190 )
            {
              v125 = *((_DWORD *)v114 + 144);
              if ( (unsigned int)(v125 + 1) <= 1 )
              {
                v182 = v114;
                dl_allocate_static_tls((int)v114, a1);
                v124 = v190;
                v125 = *((_DWORD *)v182 + 144);
              }
              *(_DWORD *)v185 = v33[2] + v125 - *(_DWORD *)(v124 + 4);
            }
            break;
          case 0x26:
            v106 = *(int (**)(void))(v190 + 8);
            goto LABEL_212;
          case 0x29:
            v126 = v190;
            if ( v190 )
            {
              v127 = *((_DWORD *)v114 + 144);
              if ( (unsigned int)(v127 + 1) <= 1 )
              {
                v182 = v114;
                dl_allocate_static_tls((int)v114, a1);
                v126 = v190;
                v127 = *((_DWORD *)v182 + 144);
              }
              v128 = (_DWORD *)v185;
              *(_DWORD *)(v185 + 4) = *(_DWORD *)(v126 + 4) - v127 + v33[2];
              *v128 = dl_tlsdesc_return;
            }
            else
            {
              v165 = (_DWORD *)v185;
              *(_DWORD *)(v185 + 4) = v33[2];
              *v165 = dl_tlsdesc_undefweak;
            }
            break;
          case 0x2A:
            *(_DWORD *)v185 = ((int (*)(void))(*(_DWORD *)a2 + v33[2]))();
            break;
          default:
LABEL_254:
            dl_reloc_bad_type(a2, v38, 0, a1);
        }
LABEL_213:
        v33 += 3;
      }
    }
    v180 = *(_DWORD *)(v34 + 4);
    while ( v184 > (unsigned int)v33 )
    {
      v35 = v33[1];
      v185 = (unsigned int)v181 + *v33;
      v36 = *(_WORD *)(v180 + 2 * (v35 >> 8));
      v37 = v183 + 16 * (v35 >> 8);
      v182 = *(int (**)(void))(a2 + 368);
      v38 = (unsigned __int8)v35;
      v191 = v37;
      if ( (unsigned __int8)v35 == 8 )
      {
        *(_DWORD *)v185 = *(_DWORD *)a2 + v33[2];
      }
      else if ( (_BYTE)v35 )
      {
        if ( *(_BYTE *)(v37 + 12) >> 4 && (*(_BYTE *)(v37 + 13) & 3u) - 1 > 1 )
        {
          if ( v37 != *(_DWORD *)(a2 + 540) )
          {
            if ( (unsigned __int8)v35 != 7 && (unsigned __int8)v35 != 35 )
              goto LABEL_52;
            v179 = 1;
LABEL_56:
            v40 = 4 * (v38 == 6);
            goto LABEL_57;
          }
          if ( (unsigned int)(unsigned __int8)v35 - 7 <= 0x1E
            && (v133 = 1879048321, _bittest(&v133, (unsigned __int8)v35 - 7)) )
          {
            v132 = 1;
LABEL_308:
            if ( (unsigned __int8)v35 != 6 )
            {
              if ( *(_DWORD *)(a2 + 544) != v132 )
              {
                if ( (unsigned __int8)v35 == 35 || (unsigned __int8)v35 == 7 )
                {
                  v179 = 1;
                  v40 = 0;
                  goto LABEL_57;
                }
LABEL_52:
                v39 = 0;
                if ( (unsigned int)(unsigned __int8)v35 - 14 <= 0x1B )
                  v39 = (0x8C00001u >> (v35 - 14)) & 1;
                v179 = v39;
                goto LABEL_55;
              }
LABEL_407:
              v47 = *(_DWORD *)(a2 + 552);
              v48 = *(int (**)(void))(a2 + 548);
              v191 = v47;
              goto LABEL_61;
            }
            v155 = 4;
          }
          else
          {
            v132 = (unsigned __int8)v35 == 41;
            if ( (unsigned __int8)v35 != 5 )
              goto LABEL_308;
            v132 |= 2u;
            v155 = 0;
          }
          if ( *(_DWORD *)(a2 + 544) == (v132 | v155) )
            goto LABEL_407;
          v179 = 0;
LABEL_55:
          if ( v38 != 5 )
            goto LABEL_56;
          v179 |= 2u;
          v40 = 0;
LABEL_57:
          v41 = 16 * (v36 & 0x7FFF);
          v42 = v40 | v179;
          v43 = (int (*)(void))((char *)v182 + v41) == 0;
          v44 = (const char **)((char *)v182 + v41);
          *(_DWORD *)(a2 + 544) = v40 | v179;
          *(_DWORD *)(a2 + 540) = v37;
          if ( v43 )
          {
            v45 = 0;
          }
          else
          {
            v45 = 0;
            if ( v44[1] )
              v45 = v44;
          }
          v46 = dl_lookup_symbol_x((unsigned __int8 *)(*(_DWORD *)v37 + v178), a2, &v191, a1, a3, v45, v42, 1, 0);
          v47 = v191;
          v48 = (int (*)(void))v46;
          *(_DWORD *)(a2 + 552) = v191;
          *(_DWORD *)(a2 + 548) = v46;
LABEL_61:
          v49 = 0;
          if ( v47 )
          {
LABEL_62:
            v49 = (int (*)(void))(*(_DWORD *)v48 + *(_DWORD *)(v47 + 4));
            if ( *(_WORD *)(v47 + 14) && (*(_BYTE *)(v47 + 12) & 0xF) == 10 && !v177 )
            {
              v182 = v48;
              v49 = (int (*)(void))v49();
              v48 = v182;
            }
          }
          switch ( *((_BYTE *)v33 + 4) )
          {
            case 1:
            case 6:
            case 7:
              goto LABEL_71;
            case 2:
              *(_DWORD *)v185 = (char *)v49 + v33[2] - v185;
              goto LABEL_72;
            case 5:
              if ( v191 )
              {
                v120 = *(_DWORD *)(v191 + 8);
                v121 = *(_DWORD *)(v37 + 8);
                if ( v120 > v121 || v120 < v121 && dl_verbose )
                {
                  v182 = v49;
                  v158 = (const char *)program_invocation_short_name;
                  v173 = (const char *)(*(_DWORD *)(*(_DWORD *)(a2 + 52) + 4) + *(_DWORD *)v37);
                  if ( !program_invocation_short_name )
                    v158 = "<program name unknown>";
                  dl_dprintf(
                    2,
                    "%s: Symbol `%s' has different size in shared object, consider re-linking\n",
                    v158,
                    v173);
                  v121 = *(_DWORD *)(v37 + 8);
                  v49 = v182;
                  v120 = *(_DWORD *)(v191 + 8);
                }
                if ( v121 > v120 )
                  v121 = v120;
                memcpy((_BYTE *)v185, v49, v121);
              }
              goto LABEL_72;
            case 0xE:
              v50 = v191;
              if ( !v191 )
                goto LABEL_72;
              v51 = *((_DWORD *)v48 + 144);
              if ( (unsigned int)(v51 + 1) <= 1 )
              {
                v182 = v48;
                dl_allocate_static_tls((int)v48, a1);
                v50 = v191;
                v51 = *((_DWORD *)v182 + 144);
              }
              v49 = (int (*)(void))(*(_DWORD *)(v50 + 4) - v51);
LABEL_71:
              *(_DWORD *)v185 = (char *)v49 + v33[2];
              break;
            case 0x23:
              if ( v48 )
                *(_DWORD *)v185 = *((_DWORD *)v48 + 145);
              goto LABEL_72;
            case 0x24:
              if ( v191 )
                v49 = *(int (**)(void))(v191 + 4);
              else
                v49 = 0;
              goto LABEL_71;
            case 0x25:
              v118 = v191;
              if ( v191 )
              {
                v119 = *((_DWORD *)v48 + 144);
                if ( (unsigned int)(v119 + 1) <= 1 )
                {
                  v182 = v48;
                  dl_allocate_static_tls((int)v48, a1);
                  v118 = v191;
                  v119 = *((_DWORD *)v182 + 144);
                }
                *(_DWORD *)v185 = v33[2] + v119 - *(_DWORD *)(v118 + 4);
              }
              goto LABEL_72;
            case 0x26:
              v49 = *(int (**)(void))(v191 + 8);
              goto LABEL_71;
            case 0x29:
              v115 = v191;
              if ( v191 )
              {
                v116 = *((_DWORD *)v48 + 144);
                if ( (unsigned int)(v116 + 1) <= 1 )
                {
                  v182 = v48;
                  dl_allocate_static_tls((int)v48, a1);
                  v115 = v191;
                  v116 = *((_DWORD *)v182 + 144);
                }
                v117 = (_DWORD *)v185;
                *(_DWORD *)(v185 + 4) = *(_DWORD *)(v115 + 4) - v116 + v33[2];
                *v117 = dl_tlsdesc_return;
              }
              else
              {
                v150 = (_DWORD *)v185;
                *(_DWORD *)(v185 + 4) = v33[2];
                *v150 = dl_tlsdesc_undefweak;
              }
              goto LABEL_72;
            case 0x2A:
              *(_DWORD *)v185 = ((int (*)(void))(*(_DWORD *)a2 + v33[2]))();
              goto LABEL_72;
            default:
              goto LABEL_254;
          }
          goto LABEL_72;
        }
        v48 = (int (*)(void))a2;
        v47 = v183 + 16 * (v35 >> 8);
        goto LABEL_62;
      }
LABEL_72:
      v33 += 3;
    }
LABEL_73:
    v176 += 4;
    if ( v198 == (char *)v176 )
      break;
    v27 = v176[2];
    v28 = v176[1];
    v26 = *v176;
    v181 = *(int (__usercall ***)@<eax>(int@<eax>))a2;
  }
  v5 = a2;
  if ( a5 )
  {
    v152 = *(_DWORD *)(a2 + 40);
    if ( v152 )
    {
      v153 = calloc(
               0x14u,
               *(_DWORD *)(v152 + 4) / (4 * (unsigned int)(*(_DWORD *)(*(_DWORD *)(a2 + 112) + 4) == 7) + 8));
      *(_DWORD *)(a2 + 416) = v153;
      if ( !v153 )
      {
        v154 = (const char *)program_invocation_short_name;
        v173 = *(const char **)(a2 + 4);
        if ( !program_invocation_short_name )
          v154 = "<program name unknown>";
        dl_dprintf(2, "%s: out of memory to store relocation results for %s\n", v154, v173);
        exit(127);
      }
    }
  }
  v52 = (int)v174;
  *(_BYTE *)(a2 + 404) |= 4u;
  if ( v52 )
  {
    v151 = v174;
    while ( 1 )
    {
      v172 = v151[2];
      if ( (mprotect(*v151, v151[1]) & 0x80000000) != 0 )
        break;
      v151 = (int *)v151[3];
      if ( !v151 )
        goto LABEL_76;
    }
    v167 = "cannot restore segment prot after reloc";
LABEL_470:
    dl_signal_error(__readgsdword(0xFFFFFFE8), *(_BYTE **)(v5 + 4), 0, a1, v167);
  }
LABEL_76:
  if ( *(_DWORD *)(a2 + 592) )
    dl_protect_relro((_DWORD *)a2, a1);
}
// 8098318: conditional instruction was optimized away because esi.4 is in (==7|==23)
// 8098A6A: conditional instruction was optimized away because edi.4 is in (==7|==23)
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80EBA08: using guessed type int dl_pagesize;
// 80ECC60: using guessed type int dl_debug_mask;
// 80ECC68: using guessed type int dl_profile;
// 80ECCAC: using guessed type int dl_verbose;
// 80ECCB4: using guessed type int dl_profile_map;

//----- (08099560) --------------------------------------------------------
_DWORD *__userpurge dl_important_hwcaps@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        _DWORD *a3@<ecx>,
        long double a4@<st0>,
        _DWORD *a5)
{
  unsigned int v5; // esi
  int v6; // edi
  char v7; // cl
  unsigned __int64 v8; // rax
  int v9; // edx
  int v10; // eax
  __int64 v11; // rax
  _BYTE *v12; // ecx
  int v13; // eax
  unsigned int v14; // edx
  int v15; // edi
  _DWORD *v16; // esi
  const char *v17; // eax
  unsigned int v18; // eax
  int v19; // ebx
  bool v20; // zf
  unsigned int v21; // ecx
  int v22; // eax
  void *v23; // esp
  _BYTE *v24; // edi
  unsigned int v25; // ebx
  unsigned int v26; // edi
  _BYTE *v27; // ebx
  _DWORD *v28; // ecx
  bool v29; // cc
  _BYTE *v30; // esi
  int v31; // eax
  int v32; // ecx
  int v33; // eax
  char *v34; // esi
  int v35; // ecx
  unsigned __int64 v36; // rax
  char **v37; // edx
  int v38; // eax
  int v39; // ecx
  unsigned int v40; // edx
  unsigned __int64 v41; // rax
  _DWORD *result; // eax
  _DWORD *v43; // edi
  _DWORD *v44; // ecx
  _DWORD *v45; // ecx
  int v46; // esi
  unsigned int v47; // edx
  int *v48; // eax
  int v49; // edx
  int v50; // ecx
  int v51; // ebx
  unsigned int v52; // ecx
  _WORD *v53; // eax
  int v54; // ecx
  int v55; // edi
  _WORD *v56; // eax
  _WORD *v57; // eax
  int v58; // esi
  _DWORD *v59; // ebx
  _WORD *v60; // eax
  _WORD *v61; // eax
  int v62; // edx
  unsigned int v63; // ecx
  unsigned int v64; // ebx
  unsigned int v65; // eax
  int i; // ecx
  int v67; // eax
  int v68; // edx
  unsigned int v69; // ebx
  int v70; // ebx
  int v71; // edi
  int v72; // eax
  unsigned int v73; // edx
  int v74; // ecx
  int v75; // esi
  int v76; // esi
  _BYTE *v77; // esi
  int v78; // edx
  int v79; // ecx
  unsigned int v80; // edi
  char v81; // bl
  unsigned int v82; // edx
  int v83; // ebx
  unsigned int v84; // ecx
  _WORD *v85; // eax
  _WORD *v86; // eax
  _WORD *v87; // eax
  unsigned int v88; // esi
  int v89; // eax
  _DWORD *v90; // ebx
  void *v91; // esp
  _BYTE *v92; // eax
  _BYTE *v93; // [esp-Ch] [ebp-64h]
  unsigned int v94; // [esp-8h] [ebp-60h]
  _BYTE v95[12]; // [esp+0h] [ebp-58h] BYREF
  int v96; // [esp+Ch] [ebp-4Ch]
  _BYTE *v97; // [esp+10h] [ebp-48h]
  int v98; // [esp+14h] [ebp-44h]
  unsigned int v99; // [esp+18h] [ebp-40h]
  _DWORD *v100; // [esp+1Ch] [ebp-3Ch]
  _BYTE *v101; // [esp+20h] [ebp-38h]
  _BYTE *v102; // [esp+24h] [ebp-34h]
  unsigned __int64 v103; // [esp+28h] [ebp-30h]
  unsigned int v104; // [esp+30h] [ebp-28h]
  _BYTE *v105; // [esp+34h] [ebp-24h]
  int v106; // [esp+38h] [ebp-20h]
  unsigned int v107; // [esp+3Ch] [ebp-1Ch]

  v98 = a1;
  v97 = (_BYTE *)a2;
  v100 = a3;
  v5 = dl_hwcap_mask & dl_hwcap;
  v103 = dl_hwcap_mask & dl_hwcap;
  v104 = a1 != 0;
  if ( (dl_hwcap_mask & dl_hwcap) != 0 )
  {
    v6 = HIDWORD(dl_hwcap_mask) & HIDWORD(dl_hwcap);
    v7 = 0;
    do
    {
      v8 = __PAIR64__(v6, v5) >> (v7 & 0x1F);
      if ( (v7 & 0x20) != 0 )
        LOBYTE(v8) = __PAIR64__(v6, v5) >> (v7 & 0x1F) >> 32;
      HIDWORD(v8) = -1;
      v104 -= ((v8 & 1) == 0) - 1;
      v10 = -1 << ++v7;
      if ( (v7 & 0x20) != 0 )
      {
        v9 = -1 << v7;
        v10 = 0;
      }
      HIDWORD(v11) = v6 & v9;
      LODWORD(v11) = v5 & v10;
    }
    while ( v11 );
  }
  v101 = (_BYTE *)dl_sysinfo_map;
  if ( dl_sysinfo_map )
  {
    v12 = *(_BYTE **)(dl_sysinfo_map + 336);
    v13 = *(unsigned __int16 *)(dl_sysinfo_map + 344);
    v106 = v13;
    if ( v13 )
    {
      v107 = 0;
      while ( 2 )
      {
        while ( 1 )
        {
          if ( *(_DWORD *)v12 == 4 )
          {
            v14 = *((_DWORD *)v12 + 5);
            v15 = *((_DWORD *)v12 + 2) + *(_DWORD *)v101;
            v16 = (_DWORD *)v15;
            v17 = (const char *)(v15 + 12);
            if ( v14 > 0xC )
              break;
          }
          ++v107;
          v12 += 32;
          if ( v106 == v107 )
            goto LABEL_36;
        }
        v102 = v12;
        do
        {
          v19 = *v16;
          if ( v16[2] == 2 && v19 == 4 )
          {
            v105 = (_BYTE *)v14;
            v20 = strcmp(v17, "GNU") == 0;
            v18 = v16[1];
            if ( v20 && v18 > 0xA )
            {
              v21 = v18 - 8;
              v22 = v16[4];
              v107 = v21;
              v99 = v104 + v22 + 1;
              if ( !access((int)"/etc/ld.so.nohwcap", 0) )
                goto LABEL_37;
              v23 = alloca(8 * v99 + 15);
              v106 = v16[5];
              v24 = v95;
              HIDWORD(dl_hwcap) |= v106 << 20;
              HIDWORD(dl_hwcap_mask) |= v106 << 20;
              v25 = 0;
              v105 = v95;
              v107 += (unsigned int)(v16 + 6);
              if ( v107 <= (unsigned int)(v16 + 6) )
              {
                v33 = 1;
                v32 = 0;
              }
              else
              {
                v104 = (unsigned int)v95;
                v26 = 0;
                v27 = v16 + 6;
                do
                {
                  while ( 1 )
                  {
                    v30 = v27 + 1;
                    v31 = strlen(v27 + 1);
                    if ( ((1 << *v27) & v106) == 0 )
                      break;
                    v27 = &v30[v31 + 1];
                    v28 = &v105[8 * v26++];
                    v29 = v107 <= (unsigned int)v27;
                    *v28 = v30;
                    v28[1] = v31;
                    if ( v29 )
                      goto LABEL_27;
                  }
                  --v99;
                  v27 = &v30[v31 + 1];
                }
                while ( v107 > (unsigned int)v27 );
LABEL_27:
                v25 = v26;
                v24 = (_BYTE *)v104;
                v32 = 8 * v25;
                v33 = v25 + 1;
              }
LABEL_28:
              if ( v103 )
              {
                v34 = "fpu";
                v35 = 0;
                v105 = v24;
                while ( 1 )
                {
                  while ( 1 )
                  {
                    v36 = v103 >> (v35 & 0x1F);
                    if ( (v35 & 0x20) != 0 )
                      LOBYTE(v36) = v103 >> (v35 & 0x1F) >> 32;
                    if ( (v36 & 1) != 0 )
                      break;
                    ++v35;
                    v34 += 8;
                  }
                  v106 = v35;
                  v37 = (char **)&v105[8 * v25];
                  *v37 = v34;
                  v107 = (unsigned int)v37;
                  v38 = strlen(v34);
                  v39 = v106;
                  v40 = v107;
                  v107 = v25 + 1;
                  *(_DWORD *)(v40 + 4) = v38;
                  v34 += 8;
                  HIDWORD(v41) = HIDWORD(v103) ^ (((v39 & 0x20) != 0) << v39);
                  LODWORD(v41) = v103 ^ (((v39 & 0x20) == 0) << v39);
                  v35 = v39 + 1;
                  if ( !v41 )
                    break;
                  v25 = v107;
                  v103 = v41;
                }
                v24 = v105;
                v33 = v25 + 2;
                v32 = 8 * v107;
              }
              if ( v98 )
              {
                v44 = &v24[v32];
                *v44 = v98;
                v44[1] = v97;
                v32 = 8 * v33++;
              }
              v45 = &v24[v32];
              v20 = v99 == v33;
              *v45 = "tls";
              v45[1] = 3;
              if ( !v20 )
                _assert_fail(a4, (int)"m == cnt", (int)"dl-hwcaps.c", 181, "_dl_important_hwcaps");
              if ( v99 == 1 )
              {
                v88 = *((_DWORD *)v24 + 1);
                *v100 = 2;
                v89 = malloc(a4, v88 + 17);
                v90 = (_DWORD *)v89;
                if ( !v89 )
                  goto LABEL_83;
                v92 = (_BYTE *)(v89 + 16);
                v90[3] = 0;
                *v90 = v92;
                v90[1] = v88 + 1;
                v90[2] = v92;
                *(_BYTE *)mempcpy(v92, *(_BYTE **)v24, v88) = 47;
                *v100 = 2;
                *a5 = v90[1];
                return v90;
              }
              else
              {
                v46 = 8 * v99 - 8;
                v104 = *((_DWORD *)v24 + 1);
                LODWORD(v103) = &v24[v46];
                v105 = *(_BYTE **)&v24[v46 + 4];
                v47 = (unsigned int)&v105[v104 + 2];
                if ( v99 > 2 )
                {
                  v48 = (int *)(v24 + 12);
                  v49 = 2 * v47;
                  do
                  {
                    v50 = *v48;
                    v48 += 2;
                    v49 += v50 + 1;
                  }
                  while ( v48 != (int *)&v24[v46 + 4] );
                  if ( v99 == 3 || v99 <= 0x1F && !((unsigned int)(v49 + 64) >> (35 - v99)) )
                  {
                    v106 = 1 << v99;
                    *v100 = 1 << v99;
                    v51 = 8 << v99;
                    v107 = malloc(a4, (v49 << (v99 - 3)) + (8 << v99));
                    if ( v107 )
                    {
                      v52 = v107;
                      v53 = (_WORD *)(v51 + v107);
                      *(_DWORD *)v107 = v51 + v107;
                      *(_DWORD *)(v52 + 8) = v53;
LABEL_53:
                      v97 = v24;
                      v98 = v99 - 1;
                      v96 = v99 - 1;
                      v102 = *(_BYTE **)v24;
                      v101 = *(_BYTE **)v103;
                      v100 = (_DWORD *)(v99 - 2);
                      v54 = (int)&v24[v46 - 8];
                      v55 = 1 << (v99 - 1);
                      LODWORD(v103) = v54;
                      do
                      {
                        v55 -= 2;
                        v56 = mempcpy(v53, v101, (unsigned int)v105);
                        v57 = mempcpy(v56, byte_80CDC92, 1u);
                        v58 = v103;
                        v59 = v100;
                        do
                        {
                          while ( (v55 & (1 << (char)v59)) == 0 )
                          {
                            v58 -= 8;
                            v59 = (_DWORD *)((char *)v59 - 1);
                            if ( !v59 )
                              goto LABEL_58;
                          }
                          v94 = *(_DWORD *)(v58 + 4);
                          v93 = *(_BYTE **)v58;
                          v58 -= 8;
                          v60 = mempcpy(v57, v93, v94);
                          v57 = mempcpy(v60, byte_80CDC92, 1u);
                          v59 = (_DWORD *)((char *)v59 - 1);
                        }
                        while ( v59 );
LABEL_58:
                        v61 = mempcpy(v57, v102, v104);
                        v53 = mempcpy(v61, byte_80CDC92, 1u);
                      }
                      while ( v55 );
                      v24 = v97;
                      v62 = v96;
                      v63 = 1 << v99;
                      if ( 1 << v99 )
                        goto LABEL_60;
                      goto LABEL_62;
                    }
                  }
LABEL_83:
                  dl_signal_error(12, 0, 0, a4, "cannot create capability list");
                }
                v81 = v99;
                v106 = 1 << v99;
                *v100 = 1 << v99;
                v82 = (8 << v81) + v47;
                v83 = 8 << v81;
                v107 = malloc(a4, v82);
                if ( !v107 )
                  goto LABEL_83;
                v84 = v107;
                v53 = (_WORD *)(v83 + v107);
                v20 = v99 == 2;
                *(_DWORD *)v107 = v83 + v107;
                *(_DWORD *)(v84 + 8) = v53;
                if ( !v20 )
                  goto LABEL_53;
                v85 = mempcpy(v53, *((_BYTE **)v24 + 2), *((_DWORD *)v24 + 3));
                v86 = mempcpy(v85, byte_80CDC92, 1u);
                v87 = mempcpy(v86, *(_BYTE **)v24, v104);
                mempcpy(v87, byte_80CDC92, 1u);
                v98 = 1;
                v63 = 4;
                v62 = 1;
LABEL_60:
                v64 = v107;
                v65 = 0;
                do
                  *(_DWORD *)(v64 + 8 * v65++ + 4) = 0;
                while ( v63 > v65 );
LABEL_62:
                for ( i = v62; ; --i )
                {
                  v67 = v106;
                  v68 = 1 << i;
                  if ( v106 )
                  {
                    v69 = v107;
                    do
                    {
                      if ( (--v67 & v68) != 0 )
                      {
                        do
                        {
                          --v67;
                          *(_DWORD *)(v69 + 4) += *(_DWORD *)&v24[8 * i + 4] + 1;
                          v69 += 8;
                        }
                        while ( (v67 & v68) != 0 );
                      }
                      v69 += 8;
                    }
                    while ( v67 );
                  }
                  if ( !i )
                    break;
                }
                v70 = v106 - 2;
                v71 = 1 << v98;
                v72 = v107 + 16;
                if ( 1 << v98 != v106 - 2 )
                {
                  v73 = v107 + 16;
                  v74 = v106 - 2;
                  do
                  {
                    while ( (--v74 & 1) != 0 )
                    {
                      v75 = *(_DWORD *)(v73 - 16) + *(_DWORD *)(v73 - 12);
                      v73 += 8;
                      *(_DWORD *)(v73 - 8) = v75;
                      if ( v71 == v74 )
                        goto LABEL_75;
                    }
                    v76 = *(_DWORD *)(v73 - 8);
                    v73 += 8;
                    *(_DWORD *)(v73 - 8) = v76;
                  }
                  while ( v71 != v74 );
LABEL_75:
                  v70 = v71 + v70 - v106 + 2;
                  v72 = v72 + 8 * (v106 - v71) - 16;
                }
                v77 = v105 + 1;
                v78 = -8 << v98;
                do
                {
                  v79 = *(_DWORD *)(v72 + v78);
                  v72 += 8;
                  *(_DWORD *)(v72 - 8) = &v77[v79];
                  --v70;
                }
                while ( v70 );
                v80 = v107;
                *a5 = *(_DWORD *)(v107 + 4);
                return (_DWORD *)v80;
              }
            }
          }
          else
          {
            v18 = v16[1];
          }
          v16 = (_DWORD *)((char *)v16 + ((v19 + 3) & 0xFFFFFFFC) + ((v18 + 3) & 0xFFFFFFFC) + 12);
          v17 = (const char *)(v16 + 3);
        }
        while ( (unsigned int)v16 - v15 + 12 < v14 );
        ++v107;
        v12 = v102 + 32;
        if ( v106 != v107 )
          continue;
        break;
      }
    }
  }
LABEL_36:
  if ( access((int)"/etc/ld.so.nohwcap", 0) )
  {
    v32 = 0;
    v25 = 0;
    v99 = v104 + 1;
    v91 = alloca(8 * (v104 + 1) + 15);
    v24 = v95;
    v33 = 1;
    goto LABEL_28;
  }
LABEL_37:
  result = (_DWORD *)malloc(a4, 8u);
  if ( !result )
    goto LABEL_83;
  v43 = v100;
  *result = result;
  result[1] = 0;
  *v43 = 1;
  return result;
}
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 80CDC92: using guessed type _BYTE byte_80CDC92[2];
// 80EC540: using guessed type __int64 dl_hwcap_mask;
// 80EC550: using guessed type __int64 dl_hwcap;
// 80ECC88: using guessed type int dl_sysinfo_map;

//----- (08099D10) --------------------------------------------------------
void __usercall __noreturn dl_signal_error(
        signed int a1@<eax>,
        _BYTE *a2@<edx>,
        const char *a3@<ecx>,
        long double a4@<st0>,
        const char *a5)
{
  const char *v6; // eax
  int v8; // ebx
  const char *v9; // ecx
  unsigned int v10; // edi
  _BYTE *v11; // eax
  _WORD *v12; // eax
  const char *v13; // eax
  const char *v14; // ebp
  const char *v15; // ebx
  const char *v16; // edx
  signed int v17; // [esp+0h] [ebp-43Ch]
  char *v18; // [esp+4h] [ebp-438h]
  char *v19; // [esp+14h] [ebp-428h]
  _BYTE *v20; // [esp+14h] [ebp-428h]
  unsigned int v22; // [esp+18h] [ebp-424h]
  _DWORD *v23; // [esp+1Ch] [ebp-420h]
  char v24[1052]; // [esp+20h] [ebp-41Ch] BYREF

  v6 = "DYNAMIC LINKER BUG!!!";
  if ( a5 )
    v6 = a5;
  v19 = (char *)v6;
  v8 = *(_DWORD *)dl_error_catch_tsd();
  if ( !a2 )
    a2 = &unk_80CFAB1;
  v9 = a3;
  if ( v8 )
  {
    v10 = strlen(a2) + 1;
    v22 = strlen(v19) + 1;
    v11 = (_BYTE *)malloc(v22 + v10);
    if ( v11 )
    {
      v23 = *(_DWORD **)v8;
      v18 = v19;
      v20 = v11;
      v12 = mempcpy(v11, v18, v22);
      *v23 = memcpy(v12, a2, v10);
      **(_DWORD **)(v8 + 4) = v20;
      **(_BYTE **)(v8 + 8) = 1;
    }
    else
    {
      **(_DWORD **)v8 = &unk_80CFAB1;
      **(_DWORD **)(v8 + 4) = "out of memory";
      **(_BYTE **)(v8 + 8) = 0;
    }
    **(_DWORD **)(v8 + 12) = a1;
    _longjmp((struct __jmp_buf_tag *)(v8 + 16), 1);
  }
  if ( a1 )
  {
    v17 = a1;
    v14 = "undefined symbol: " + 16;
    v13 = (const char *)strerror_r(a4, v17, v24, 0x400u);
    v9 = a3;
  }
  else
  {
    v13 = (const char *)&unk_80CFAB1;
    v14 = (const char *)&unk_80CFAB1;
  }
  v15 = "undefined symbol: " + 16;
  if ( !*a2 )
    v15 = (const char *)&unk_80CFAB1;
  if ( !v9 )
    v9 = "error while loading shared libraries";
  v16 = (const char *)program_invocation_short_name;
  if ( !program_invocation_short_name )
    v16 = "<program name unknown>";
  dl_dprintf(2, "%s: %s: %s%s%s%s%s\n", v16, v9, a2, v15, v19, v14, v13);
  exit(127);
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80EBF30: using guessed type int (*dl_error_catch_tsd)(void);
// 8099D10: using guessed type char var_41C[1052];

//----- (08099E70) --------------------------------------------------------
int __userpurge dl_signal_cerror@<eax>(
        signed int a1@<eax>,
        char *a2@<edx>,
        const char *a3@<ecx>,
        long double a4@<st0>,
        const char *a5)
{
  const char *v6; // ebx
  char *v7; // [esp+4h] [ebp-18h]
  const char *v8; // [esp+8h] [ebp-14h]
  signed int v9; // [esp+Ch] [ebp-10h]

  if ( (dl_debug_mask & 0xFFFFF77F) != 0 )
  {
    v9 = a1;
    v6 = "continued";
    if ( !receiver )
      v6 = "fatal";
    v8 = a3;
    v7 = a2;
    dl_debug_printf("%s: error: %s: %s (%s)\n", a2, a3, a5, v6);
    a1 = v9;
    a3 = v8;
    a2 = v7;
  }
  if ( !receiver )
    dl_signal_error(a1, a2, a3, a4, a5);
  return receiver(a1, a2, a5);
}
// 80EC790: using guessed type int (__cdecl *receiver)(_DWORD, _DWORD, _DWORD);
// 80ECC60: using guessed type int dl_debug_mask;

//----- (08099F00) --------------------------------------------------------
int __userpurge dl_catch_error@<eax>(
        _DWORD *a1@<eax>,
        _DWORD *a2@<edx>,
        _BYTE *a3@<ecx>,
        int a4@<ebp>,
        int a5@<edi>,
        int a6@<esi>,
        void (__cdecl *a7)(int),
        int a8)
{
  int *v8; // eax
  int v9; // ebx
  int result; // eax
  int *v11; // [esp+Ch] [ebp-D0h]
  int v15; // [esp+20h] [ebp-BCh] BYREF
  int v16[4]; // [esp+24h] [ebp-B8h] BYREF
  char v17[168]; // [esp+34h] [ebp-A8h] BYREF

  v16[0] = (int)a1;
  v16[1] = (int)a2;
  v16[2] = (int)a3;
  v16[3] = (int)&v15;
  v8 = (int *)dl_error_catch_tsd();
  v9 = *v8;
  v11 = v8;
  *v8 = (int)v16;
  if ( _sigsetjmp(v9, a4, a5, a6, (int)v17, 0) )
  {
    *v11 = v9;
    return v15;
  }
  else
  {
    a7(a8);
    *v11 = v9;
    *a1 = 0;
    result = 0;
    *a2 = 0;
    *a3 = 0;
  }
  return result;
}
// 80EBF30: using guessed type int (*dl_error_catch_tsd)(void);
// 8099F00: using guessed type char var_A8[168];

//----- (08099FC0) --------------------------------------------------------
int __usercall dl_receive_error@<eax>(
        int (__cdecl *a1)(_DWORD, _DWORD, _DWORD)@<eax>,
        int (__cdecl *a2)(int)@<edx>,
        int a3@<ecx>)
{
  _DWORD *v4; // eax
  int v5; // edi
  int (__cdecl *v6)(_DWORD, _DWORD, _DWORD); // esi
  _DWORD *v7; // ebx
  int result; // eax

  v4 = (_DWORD *)dl_error_catch_tsd();
  v5 = *v4;
  v6 = receiver;
  *v4 = 0;
  v7 = v4;
  receiver = a1;
  result = a2(a3);
  *v7 = v5;
  receiver = v6;
  return result;
}
// 80EBF30: using guessed type int (*dl_error_catch_tsd)(void);
// 80EC790: using guessed type int (__cdecl *receiver)(_DWORD, _DWORD, _DWORD);

//----- (0809A010) --------------------------------------------------------
__int64 __usercall dl_debug_vdprintf@<edx:eax>(int a1@<eax>, int a2@<edx>, char *a3@<ecx>, int *a4)
{
  int v5; // edi
  char v6; // al
  int v7; // ecx
  int v8; // ecx
  char *v9; // eax
  char v10; // al
  char *v11; // ecx
  unsigned int v12; // esi
  bool v14; // zf
  unsigned int v15; // eax
  _BYTE *v16; // eax
  _BYTE *v17; // edx
  char v18; // cl
  int v19; // edi
  int v20; // eax
  int v21; // eax
  unsigned int v22; // eax
  char v23; // [esp-14h] [ebp-25Ch] BYREF
  _BYTE *v24; // [esp-10h] [ebp-258h]
  int v25; // [esp+0h] [ebp-248h]
  int v26; // [esp+4h] [ebp-244h]
  char *v27; // [esp+8h] [ebp-240h]
  unsigned int *v28; // [esp+Ch] [ebp-23Ch]
  char *v29; // [esp+10h] [ebp-238h]
  int v30; // [esp+14h] [ebp-234h]
  int v31; // [esp+18h] [ebp-230h]
  int v32; // [esp+1Ch] [ebp-22Ch]
  char v33[10]; // [esp+24h] [ebp-224h] BYREF
  __int16 v34; // [esp+2Eh] [ebp-21Ah] BYREF
  int v35[134]; // [esp+30h] [ebp-218h] BYREF

  v5 = 0;
  v26 = a1;
  v32 = a2;
  v31 = 0;
LABEL_2:
  v6 = *a3;
  if ( !*a3 )
    return dl_sysinfo(v35);
LABEL_3:
  if ( v32 > 0 )
  {
    v7 = v31;
    if ( !v31 )
      goto LABEL_24;
    goto LABEL_5;
  }
  v8 = (int)a3;
  while ( 1 )
  {
    if ( v6 != 37 && v6 )
    {
      if ( v6 == 10 && v32 )
      {
        v6 = 10;
      }
      else
      {
        do
          v6 = *++a3;
        while ( *a3 && v6 != 37 && (v6 != 10 || !v32) );
      }
    }
    if ( v5 > 63 )
      _assert_fail("niov < NIOVMAX", "dl-misc.c", 125, "_dl_debug_vdprintf");
    v35[2 * v5 + 1] = (int)&a3[-v8];
    if ( a3 != (char *)v8 )
      v35[2 * v5++] = v8;
    if ( v6 == 37 )
    {
      v10 = a3[1];
      if ( v10 == 48 )
      {
        v10 = a3[2];
        v11 = a3 + 2;
        LOBYTE(v29) = 48;
        v30 = -1;
        if ( v10 != 42 )
          goto LABEL_30;
      }
      else
      {
        v11 = a3 + 1;
        LOBYTE(v29) = 32;
        v30 = -1;
        if ( v10 != 42 )
        {
LABEL_30:
          v12 = -1;
          if ( v10 == 46 )
          {
            if ( v11[1] != 42 )
              goto LABEL_52;
            v11 += 2;
            v12 = *a4;
            v10 = *v11;
            ++a4;
          }
          if ( v10 == 108 || v10 == 90 )
            v10 = *++v11;
          if ( v10 == 115 )
          {
            v29 = v11;
            v30 = (int)(a4 + 1);
            v24 = (_BYTE *)*a4;
            v35[2 * v5] = (int)v24;
            v22 = strlen(v24);
            v11 = v29;
            if ( v12 == -1 )
            {
              v35[2 * v5 + 1] = v22;
            }
            else
            {
              if ( v12 > v22 )
                v12 = v22;
              v35[2 * v5 + 1] = v12;
            }
            ++v5;
            a4 = (int *)v30;
          }
          else if ( v10 > 115 )
          {
            if ( v10 != 117 && v10 != 120 )
LABEL_52:
              _assert_fail("! \"invalid format specifier\"", "dl-misc.c", 221, "_dl_debug_vdprintf");
            v27 = v11;
            v14 = v10 == 120;
            v15 = 10;
            if ( v14 )
              v15 = 16;
            v28 = (unsigned int *)(a4 + 1);
            v16 = itoa((unsigned int)*a4, &v23, v15, 0);
            v11 = v27;
            v17 = (_BYTE *)(&v23 - v16);
            if ( v30 != -1 && v30 > (int)v17 )
            {
              v18 = (char)v29;
              v25 = v5;
              v19 = v30;
              do
              {
                *--v16 = v18;
                v17 = (_BYTE *)(&v23 - v16);
              }
              while ( v19 > &v23 - v16 );
              v11 = v27;
              v5 = v25;
            }
            v35[2 * v5] = (int)v16;
            v20 = (int)v28;
            v35[2 * v5++ + 1] = (int)v17;
            a4 = (int *)v20;
          }
          else
          {
            if ( v10 != 37 )
              goto LABEL_52;
            v35[2 * v5] = (int)v11;
            v35[2 * v5++ + 1] = 1;
          }
          a3 = v11 + 1;
          v6 = v11[1];
          if ( !v6 )
            return dl_sysinfo(v35);
          goto LABEL_3;
        }
      }
      ++v11;
      v21 = *a4++;
      v30 = v21;
      v10 = *v11;
      goto LABEL_30;
    }
    if ( v6 != 10 )
      goto LABEL_2;
    if ( a3 == (char *)v8 )
    {
      v35[2 * v5] = (int)a3;
      v35[2 * v5++ + 1] = 1;
    }
    else
    {
      ++*(_DWORD *)&v33[8 * v5 + 8];
    }
    if ( !a3[1] )
      return dl_sysinfo(v35);
    v7 = v31;
    ++a3;
    if ( !v31 )
    {
LABEL_24:
      v31 = getpid(v7);
      if ( v31 < 0 )
        _assert_fail("pid >= 0 && sizeof (pid_t) <= 4", "dl-misc.c", 103, "_dl_debug_vdprintf");
      v9 = itoa(v31, &v34, 0xAu, 0);
      if ( v9 > v33 )
      {
        do
          *--v9 = 32;
        while ( v9 != v33 );
      }
      v34 = 2362;
    }
LABEL_5:
    if ( v5 > 63 )
      _assert_fail("niov < NIOVMAX", "dl-misc.c", 112, "_dl_debug_vdprintf");
    v6 = *a3;
    v35[2 * v5 + 1] = 12;
    v8 = (int)a3;
    v35[2 * v5] = (int)v33;
    v32 = -1;
    ++v5;
  }
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0809A430) --------------------------------------------------------
int __usercall dl_sysdep_read_whole_file@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)
{
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  bool v8; // zf
  unsigned int v9; // esi
  int v11; // [esp+0h] [ebp-74h]
  char v12[44]; // [esp+8h] [ebp-6Ch] BYREF
  int v13; // [esp+34h] [ebp-40h]

  v5 = open(a1, 0x80000, v11);
  if ( v5 < 0 )
    return -1;
  v6 = v5;
  if ( (_fxstat64(3, v5, (int)v12) & 0x80000000) != 0 || (v7 = v13, v8 = v13 == 0, *a2 = v13, v8) )
    v9 = -1;
  else
    v9 = mmap(0, v7, a3, 2, v6, 0);
  close(v6);
  return v9;
}
// 809A440: variable 'v11' is possibly undefined
// 809A430: using guessed type char var_6C[44];

//----- (0809A4C0) --------------------------------------------------------
__int64 dl_debug_printf(char *a1, ...)
{
  va_list va; // [esp+14h] [ebp+8h] BYREF

  va_start(va, a1);
  return dl_debug_vdprintf(dl_debug_fd, 1, a1, (int *)va);
}
// 80EBA04: using guessed type int dl_debug_fd;

//----- (0809A4F0) --------------------------------------------------------
__int64 dl_debug_printf_c(char *a1, ...)
{
  va_list va; // [esp+14h] [ebp+8h] BYREF

  va_start(va, a1);
  return dl_debug_vdprintf(dl_debug_fd, -1, a1, (int *)va);
}
// 80EBA04: using guessed type int dl_debug_fd;

//----- (0809A520) --------------------------------------------------------
__int64 dl_dprintf(int a1, char *a2, ...)
{
  va_list va; // [esp+18h] [ebp+Ch] BYREF

  va_start(va, a2);
  return dl_debug_vdprintf(a1, 0, a2, (int *)va);
}

//----- (0809A540) --------------------------------------------------------
int __usercall dl_name_match_p@<eax>(int a1@<eax>, int a2@<edx>)
{
  _DWORD *v4; // ebx

  if ( !j_strcmp(a1, *(_DWORD *)(a2 + 4)) )
    return 1;
  v4 = *(_DWORD **)(a2 + 28);
  if ( v4 )
  {
    while ( j_strcmp(a1, *v4) )
    {
      v4 = (_DWORD *)v4[1];
      if ( !v4 )
        return 0;
    }
    return 1;
  }
  return 0;
}
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);

//----- (0809A5A0) --------------------------------------------------------
int __usercall dl_higher_prime_number@<eax>(unsigned int a1@<eax>)
{
  const char *v1; // ecx
  const char *v2; // ebx
  int v3; // edx
  const char *v4; // esi
  int v5; // ecx
  const char *v7; // edx

  v1 = "cannot allocate memory for thread-local data: ABORT\n";
  v2 = "\a";
  while ( 1 )
  {
    v3 = (int)(((v1 - v2) >> 2) + ((unsigned int)(v1 - v2) >> 31)) >> 1;
    v4 = &v2[4 * v3];
    if ( a1 <= *(_DWORD *)v4 )
      break;
    v7 = &v2[4 * v3];
LABEL_9:
    v2 = v7 + 4;
    if ( v7 + 4 == v1 )
    {
      v4 = v1;
      return *(_DWORD *)v4;
    }
  }
  while ( v4 != v2 )
  {
    v5 = (v4 - v2) >> 2;
    v7 = &v2[4 * ((int)(v5 + ((unsigned int)(v4 - v2) >> 31)) >> 1)];
    if ( *(_DWORD *)v7 < a1 )
    {
      v1 = v4;
      goto LABEL_9;
    }
    v4 = &v2[4 * ((int)(v5 + ((unsigned int)(v4 - v2) >> 31)) >> 1)];
  }
  return *(_DWORD *)v4;
}

//----- (0809A610) --------------------------------------------------------
int __usercall allocate_dtv@<eax>(int a1@<eax>)
{
  int v2; // ebx
  int *v3; // eax
  _DWORD *v4; // edx
  int result; // eax

  v2 = dl_tls_max_dtv_idx + 14;
  v3 = (int *)calloc(dl_tls_max_dtv_idx + 16, 8u);
  if ( !v3 )
    return 0;
  v4 = v3 + 2;
  *v3 = v2;
  result = a1;
  *(_DWORD *)(a1 + 4) = v4;
  return result;
}
// 80ECA08: using guessed type int dl_tls_max_dtv_idx;

//----- (0809A650) --------------------------------------------------------
unsigned int dl_next_tls_modid()
{
  unsigned int result; // eax
  unsigned int *v1; // edx
  int v2; // ebx
  unsigned int i; // esi

  if ( dl_tls_dtv_gaps )
  {
    result = dl_tls_static_nelem + 1;
    if ( dl_tls_static_nelem + 1 > (unsigned int)dl_tls_max_dtv_idx )
      goto LABEL_12;
    v1 = (unsigned int *)dl_tls_dtv_slotinfo_list;
    v2 = 0;
    for ( i = *(_DWORD *)dl_tls_dtv_slotinfo_list; ; i = *v1 )
    {
      while ( result - v2 < i )
      {
        if ( !v1[2 * (result - v2) + 3] )
          goto LABEL_11;
        if ( ++result > dl_tls_max_dtv_idx + 1 )
          _assert_fail("result <= GL(dl_tls_max_dtv_idx) + 1", "dl-tls.c", 74, "_dl_next_tls_modid");
      }
      v1 = (unsigned int *)v1[1];
      v2 += i;
      if ( !v1 )
        break;
    }
LABEL_11:
    if ( result > dl_tls_max_dtv_idx )
    {
LABEL_12:
      if ( result != dl_tls_max_dtv_idx + 1 )
        _assert_fail("result == GL(dl_tls_max_dtv_idx) + 1", "dl-tls.c", 88, "_dl_next_tls_modid");
      dl_tls_dtv_gaps = 0;
      dl_tls_max_dtv_idx = result;
    }
  }
  else
  {
    return ++dl_tls_max_dtv_idx;
  }
  return result;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80ECA08: using guessed type int dl_tls_max_dtv_idx;
// 80ECC20: using guessed type int dl_tls_dtv_slotinfo_list;
// 80ECC24: using guessed type char dl_tls_dtv_gaps;
// 80ECC2C: using guessed type int dl_tls_static_nelem;

//----- (0809A720) --------------------------------------------------------
int dl_count_modids()
{
  int result; // eax
  _DWORD *v1; // ecx
  int v2; // edx

  if ( !dl_tls_dtv_gaps )
    return dl_tls_max_dtv_idx;
  v1 = (_DWORD *)dl_tls_dtv_slotinfo_list;
  result = 0;
  if ( dl_tls_dtv_slotinfo_list )
  {
    do
    {
      v2 = 0;
      if ( *v1 )
      {
        do
          result -= (v1[2 * v2++ + 3] == 0) - 1;
        while ( v2 != *v1 );
      }
      v1 = (_DWORD *)v1[1];
    }
    while ( v1 );
  }
  return result;
}
// 80ECA08: using guessed type int dl_tls_max_dtv_idx;
// 80ECC20: using guessed type int dl_tls_dtv_slotinfo_list;
// 80ECC24: using guessed type char dl_tls_dtv_gaps;

//----- (0809A770) --------------------------------------------------------
int __usercall dl_get_tls_static_info@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>)
{
  int result; // eax

  *a1 = dl_tls_static_size;
  result = dl_tls_static_align;
  *a2 = dl_tls_static_align;
  return result;
}
// 80EB068: using guessed type int dl_tls_static_size;
// 80ECA04: using guessed type int dl_tls_static_align;

//----- (0809A780) --------------------------------------------------------
int dl_allocate_tls_storage()
{
  int v0; // edi
  int v1; // eax
  _DWORD *v2; // edx
  int v3; // ebx
  int result; // eax

  v0 = dl_tls_static_size;
  v1 = memalign(dl_tls_static_align, dl_tls_static_size);
  if ( !v1 )
    return 0;
  v2 = (_DWORD *)(v1 + v0 - 1216);
  v3 = v1;
  *v2 = 0;
  v2[303] = 0;
  memset((void *)((unsigned int)(v2 + 1) & 0xFFFFFFFC), 0, 4 * ((v1 + v0 - ((unsigned int)(v2 + 1) & 0xFFFFFFFC)) >> 2));
  result = allocate_dtv((int)v2);
  if ( !result )
  {
    free(v3);
    return 0;
  }
  return result;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EB068: using guessed type int dl_tls_static_size;
// 80ECA04: using guessed type int dl_tls_static_align;

//----- (0809A810) --------------------------------------------------------
int __usercall dl_allocate_tls_init@<eax>(int a1@<eax>)
{
  unsigned int v1; // edx
  _BOOL4 v2; // eax
  int v3; // ebp
  unsigned int v4; // edi
  _DWORD *v5; // ebx
  int v6; // eax
  unsigned int v7; // edx
  int v8; // ecx
  char *v9; // edx
  unsigned int v10; // edx
  unsigned int v11; // esi
  unsigned int v12; // ecx
  unsigned int v13; // esi
  _WORD *v14; // eax
  int v16; // ebx
  int v17; // esi
  int *v18; // edi
  unsigned int v19; // ebp
  int *v20; // eax
  unsigned int v21; // [esp+4h] [ebp-38h]
  _DWORD *v22; // [esp+8h] [ebp-34h]
  unsigned int v23; // [esp+Ch] [ebp-30h]
  int v24; // [esp+10h] [ebp-2Ch]
  unsigned int *v25; // [esp+14h] [ebp-28h]
  unsigned int v27; // [esp+1Ch] [ebp-20h]

  if ( !a1 )
    return a1;
  v1 = dl_tls_max_dtv_idx;
  v25 = *(unsigned int **)(a1 + 4);
  if ( *(v25 - 2) < dl_tls_max_dtv_idx )
  {
    v16 = dl_tls_max_dtv_idx + 14;
    v17 = *(v25 - 2);
    if ( v25 == (unsigned int *)&unk_80ECA28 )
    {
      v20 = (int *)malloc(8 * dl_tls_max_dtv_idx + 128);
      v18 = v20;
      if ( v20 )
      {
        v19 = 8 * v17 + 16;
        memcpy(v20, &dl_static_dtv, v19);
        goto LABEL_28;
      }
    }
    else
    {
      v18 = (int *)realloc((_BYTE *)v25 - 8, 8 * dl_tls_max_dtv_idx + 128);
      if ( v18 )
      {
        v19 = 8 * v17 + 16;
LABEL_28:
        *v18 = v16;
        j_memset((char *)v18 + v19, 0, 8 * (v16 - v17));
        v1 = dl_tls_max_dtv_idx;
        v25 = (unsigned int *)(v18 + 2);
        *(_DWORD *)(a1 + 4) = v18 + 2;
        goto LABEL_3;
      }
    }
    oom();
  }
LABEL_3:
  v21 = 0;
  v27 = 0;
  v22 = (_DWORD *)dl_tls_dtv_slotinfo_list;
  while ( 1 )
  {
    v2 = v27 == 0;
    if ( (unsigned int)v2 >= *v22 )
    {
      v3 = v27 == 0;
    }
    else
    {
      v23 = v2 + v27;
      if ( v2 + v27 > v1 )
        break;
      v3 = v27 == 0;
      v4 = v2 + v27;
      v5 = &v22[2 * v2];
      v24 = v27 + v2 + 1;
      while ( 1 )
      {
        v6 = v5[3];
        if ( v6 )
        {
          v7 = v5[2];
          if ( v7 > dl_tls_generation )
            _assert_fail("listp->slotinfo[cnt].gen <= GL(dl_tls_generation)", "dl-tls.c", 493, "_dl_allocate_tls_init");
          if ( v21 >= v7 )
            v7 = v21;
          v8 = *(_DWORD *)(v6 + 580);
          v21 = v7;
          v9 = (char *)&v25[2 * v8];
          *(_DWORD *)v9 = -1;
          v9[4] = 0;
          v10 = *(_DWORD *)(v6 + 576);
          if ( v10 + 1 > 1 )
          {
            if ( v8 != v4 )
              _assert_fail("map->l_tls_modid == total + cnt", "dl-tls.c", 503, "_dl_allocate_tls_init");
            v11 = *(_DWORD *)(v6 + 564);
            v12 = *(_DWORD *)(v6 + 560);
            if ( v11 < v12 )
              _assert_fail(
                "map->l_tls_blocksize >= map->l_tls_initimage_size",
                "dl-tls.c",
                504,
                "_dl_allocate_tls_init");
            if ( v10 < v11 )
              _assert_fail(
                "(size_t) map->l_tls_offset >= map->l_tls_blocksize",
                "dl-tls.c",
                506,
                "_dl_allocate_tls_init");
            v13 = v11 - v12;
            v14 = mempcpy((_BYTE *)(a1 - v10), *(_BYTE **)(v6 + 556), *(_DWORD *)(v6 + 560));
            j_memset(v14, 0, v13);
          }
        }
        if ( *v22 <= (unsigned int)++v3 )
          break;
        v5 += 2;
        v4 += v24 - v23;
        if ( dl_tls_max_dtv_idx < v4 )
          goto LABEL_22;
      }
      v1 = dl_tls_max_dtv_idx;
    }
    v27 += v3;
    if ( v27 >= v1 )
      break;
    v22 = (_DWORD *)v22[1];
    if ( !v22 )
      _assert_fail("listp != NULL", "dl-tls.c", 525, "_dl_allocate_tls_init");
  }
LABEL_22:
  *v25 = v21;
  return a1;
}
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);
// 80483D8: using guessed type void __noreturn oom(void);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80ECA08: using guessed type int dl_tls_max_dtv_idx;
// 80ECA20: using guessed type int dl_static_dtv;
// 80ECC20: using guessed type int dl_tls_dtv_slotinfo_list;
// 80ECC28: using guessed type int dl_tls_generation;

//----- (0809AAD0) --------------------------------------------------------
int __usercall dl_allocate_tls@<eax>(int a1@<eax>)
{
  int dtv; // eax

  if ( a1 )
    dtv = allocate_dtv(a1);
  else
    dtv = dl_allocate_tls_storage();
  return dl_allocate_tls_init(dtv);
}

//----- (0809AB00) --------------------------------------------------------
int __usercall dl_deallocate_tls@<eax>(int a1@<eax>, int a2@<edx>)
{
  unsigned int v4; // ebx
  _DWORD *v5; // esi
  unsigned int v6; // eax
  int result; // eax

  v4 = 0;
  v5 = *(_DWORD **)(a1 + 4);
  v6 = *(v5 - 2);
  while ( v4 < v6 )
  {
    while ( 1 )
    {
      ++v4;
      if ( LOBYTE(v5[2 * v4 + 1]) || v5[2 * v4] == -1 )
        break;
      free(v5[2 * v4]);
      v6 = *(v5 - 2);
      if ( v4 >= v6 )
        goto LABEL_6;
    }
  }
LABEL_6:
  if ( v5 != (_DWORD *)&unk_80ECA28 )
    free(v5 - 2);
  result = a2;
  if ( (_BYTE)a2 )
    return free(a1 - dl_tls_static_size + 1216);
  return result;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EB068: using guessed type int dl_tls_static_size;

//----- (0809AB80) --------------------------------------------------------
int __cdecl dl_tls_get_addr_soft(int a1)
{
  unsigned int v1; // eax
  _DWORD *v2; // edx
  int result; // eax
  unsigned int *v4; // ecx
  unsigned int v5; // esi
  unsigned int v6; // ebx

  v1 = *(_DWORD *)(a1 + 580);
  if ( !v1 )
    return 0;
  v2 = (_DWORD *)__readgsdword(4u);
  if ( *v2 != dl_tls_generation )
  {
    if ( v1 >= *(v2 - 2) )
      return 0;
    v4 = (unsigned int *)dl_tls_dtv_slotinfo_list;
    v5 = *(_DWORD *)(a1 + 580);
    v6 = *(_DWORD *)dl_tls_dtv_slotinfo_list;
    if ( v1 >= *(_DWORD *)dl_tls_dtv_slotinfo_list )
    {
      do
      {
        v4 = (unsigned int *)v4[1];
        v5 -= v6;
        v6 = *v4;
      }
      while ( *v4 <= v5 );
    }
    if ( *v2 < v4[2 * v5 + 2] )
      return 0;
  }
  result = v2[2 * v1];
  if ( result == -1 )
    return 0;
  return result;
}
// 80ECC20: using guessed type int dl_tls_dtv_slotinfo_list;
// 80ECC28: using guessed type int dl_tls_generation;

//----- (0809ABF0) --------------------------------------------------------
int __usercall dl_add_to_slotinfo@<eax>(long double a1@<st0>, unsigned int a2)
{
  unsigned int *v2; // esi
  unsigned int v3; // ebx
  int v4; // eax
  unsigned int *v5; // edx
  int result; // eax
  unsigned int *v7; // eax

  v2 = (unsigned int *)dl_tls_dtv_slotinfo_list;
  v3 = *(_DWORD *)(a2 + 580);
  while ( v3 >= *v2 )
  {
    v3 -= *v2;
    if ( !v2[1] )
    {
      if ( v3 )
        _assert_fail("idx == 0", "dl-tls.c", 917, "_dl_add_to_slotinfo");
      v7 = (unsigned int *)malloc(504);
      v2[1] = (unsigned int)v7;
      if ( !v7 )
      {
        ++dl_tls_generation;
        dl_signal_error(12, "dlopen", 0, a1, "cannot create TLS data structures");
      }
      *v7 = 62;
      v7[1] = 0;
      v2 = v7;
      memset(v7 + 2, 0, 0x1F0u);
      break;
    }
    v2 = (unsigned int *)v2[1];
  }
  v4 = dl_tls_generation;
  v5 = &v2[2 * v3];
  v5[3] = a2;
  result = v4 + 1;
  v5[2] = result;
  return result;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80ECC20: using guessed type int dl_tls_dtv_slotinfo_list;
// 80ECC28: using guessed type int dl_tls_generation;

//----- (0809ACC0) --------------------------------------------------------
int dl_get_origin()
{
  int v0; // eax
  _BYTE *v1; // ecx
  int v2; // esi
  _WORD *v3; // ebx
  _BYTE *v4; // esi
  int v5; // edi
  _BYTE *v6; // eax
  _WORD *v7; // eax
  _BYTE *v8; // edx
  _BYTE *v10; // eax
  _BYTE *v11; // ebx
  _BYTE *v12; // [esp+1Ch] [ebp-1010h]
  char v13[4108]; // [esp+20h] [ebp-100Ch] BYREF

  v0 = dl_sysinfo(v13);
  if ( v0 <= 0 || v13[0] == 91 )
  {
    v4 = (_BYTE *)dl_origin_path;
    if ( dl_origin_path )
    {
      v5 = strlen((_BYTE *)dl_origin_path);
      v6 = (_BYTE *)malloc(v5 + 1);
      v3 = v6;
      if ( v6 )
      {
        v7 = mempcpy(v6, v4, v5);
        v8 = (char *)v3 + 1;
        if ( (_WORD *)((char *)v3 + 1) < v7 )
        {
          while ( *((_BYTE *)v7 - 1) == 47 )
          {
            v7 = (_WORD *)((char *)v7 - 1);
            if ( v8 == (_BYTE *)v7 )
              goto LABEL_19;
          }
        }
        v8 = v7;
LABEL_19:
        *v8 = 0;
        return (int)v3;
      }
    }
    return -1;
  }
  if ( v13[0] != 47 )
    _assert_fail("linkval[0] == '/'", "../sysdeps/unix/sysv/linux/dl-origin.c", 47, "_dl_get_origin");
  if ( v0 == 1 )
  {
LABEL_10:
    v3 = (_WORD *)malloc(2);
    if ( v3 )
    {
      *v3 = 47;
      return (int)v3;
    }
    return -1;
  }
  v2 = v0 - 1;
  if ( v13[v0 - 1] != 47 )
  {
    while ( v2 != 1 )
    {
      if ( v1[v2 - 1] == 47 )
        goto LABEL_22;
      --v2;
    }
    goto LABEL_10;
  }
  v2 = v0;
LABEL_22:
  v12 = v1;
  v10 = (_BYTE *)malloc(v2 + 1);
  v11 = v10;
  if ( !v10 )
    return -1;
  *(_BYTE *)mempcpy(v10, v12, v2 - 1) = 0;
  return (int)v11;
}
// 809AD10: variable 'v1' is possibly undefined
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80ECC98: using guessed type int dl_origin_path;
// 809ACC0: using guessed type char var_100C[4108];

//----- (0809AE20) --------------------------------------------------------
int __cdecl dl_scope_free(int a1)
{
  unsigned int v1; // ebx
  int *v3; // ebx
  int v4; // eax
  int i; // eax
  int v6; // eax
  _DWORD *v7; // eax

  v1 = __readgsdword(0xCu);
  if ( v1 )
  {
    v3 = (int *)dl_scope_free_list;
    if ( dl_scope_free_list )
    {
      v4 = *(_DWORD *)dl_scope_free_list;
      if ( *(_DWORD *)dl_scope_free_list > 0x31u )
      {
        dl_wait_lookup_done();
        for ( i = *v3; *v3; i = *v3 )
        {
          v6 = i - 1;
          *v3 = v6;
          free(v3[v6 + 1]);
        }
        return 1;
      }
      else
      {
        *(_DWORD *)dl_scope_free_list = v4 + 1;
        v3[v4 + 1] = a1;
        return 0;
      }
    }
    else
    {
      v7 = (_DWORD *)malloc(204);
      dl_scope_free_list = (int)v7;
      if ( v7 )
      {
        *v7 = 1;
        v1 = 0;
        v7[1] = a1;
      }
      else
      {
        dl_wait_lookup_done();
        v1 = 1;
        free(a1);
      }
    }
  }
  else
  {
    free(a1);
  }
  return v1;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80ECC64: using guessed type int (*dl_wait_lookup_done)(void);
// 80ECC94: using guessed type int dl_scope_free_list;

//----- (0809AEF0) --------------------------------------------------------
unsigned int __usercall dl_make_stack_executable@<eax>(_DWORD *a1@<eax>)
{
  unsigned int result; // eax

  if ( *a1 != _libc_stack_end )
    return 1;
  result = mprotect(*a1 & -dl_pagesize, dl_pagesize);
  if ( result )
    return __readgsdword(0xFFFFFFE8);
  *a1 = 0;
  dl_stack_flags |= 1u;
  return result;
}
// 80EAFC8: using guessed type int _libc_stack_end;
// 80EB9F8: using guessed type int dl_stack_flags;
// 80EBA08: using guessed type int dl_pagesize;

//----- (0809AF60) --------------------------------------------------------
int __usercall add_to_global@<eax>(int a1@<eax>, long double a2@<st0>)
{
  int v3; // edi
  int v4; // eax
  int v5; // ebp
  int v6; // ecx
  int v7; // esi
  void **v8; // ecx
  _BYTE **v9; // edx
  int v10; // eax
  _BYTE *v11; // eax
  void **v12; // eax
  unsigned int v13; // edi
  int v14; // ecx
  char v15; // dl
  int v17; // eax
  void *v18; // ebp
  _BYTE *v19; // eax
  _BYTE *v20; // edi
  void *v21; // eax
  unsigned int v22; // [esp+0h] [ebp-2Ch]
  int v23; // [esp+0h] [ebp-2Ch]
  void **v24; // [esp+0h] [ebp-2Ch]
  _BYTE **v25; // [esp+4h] [ebp-28h]
  _DWORD *v26; // [esp+4h] [ebp-28h]
  _BYTE *v27; // [esp+8h] [ebp-24h]

  v3 = *(_DWORD *)(a1 + 352);
  if ( v3 )
  {
    v4 = *(_DWORD *)(a1 + 348);
    v5 = 0;
    v6 = v4 + 4 * v3;
    do
    {
      v5 += (*(_BYTE *)(*(_DWORD *)v4 + 404) & 0x10) == 0;
      v4 += 4;
    }
    while ( v6 != v4 );
  }
  else
  {
    v5 = 0;
  }
  v7 = *(_DWORD *)(a1 + 24);
  v8 = &dl_ns + 19 * v7;
  v22 = (unsigned int)v8[3];
  if ( !v22 )
  {
    v9 = (_BYTE **)v8[2];
    if ( !v9 )
    {
      v21 = (void *)calloc(1u, 8u);
      *(&dl_ns + 19 * v7 + 2) = v21;
      if ( !v21 )
        goto LABEL_24;
      v9 = (_BYTE **)v21;
    }
    v25 = v9;
    v10 = (int)&v9[1][v5 + 8];
    v23 = (int)v9[1];
    dword_80EBA4C[19 * v7] = v10;
    v11 = (_BYTE *)malloc(4 * v10);
    if ( v11 )
    {
      *v25 = memcpy(v11, *v25, 4 * v23);
      v12 = (&off_80EBA48)[19 * v7][1];
      goto LABEL_8;
    }
    dword_80EBA4C[19 * v7] = 0;
LABEL_24:
    dl_signal_error(12, **(_BYTE ***)(a1 + 28), 0, a2, "cannot extend global scope");
  }
  v26 = v8[2];
  v12 = (void **)v26[1];
  if ( v22 < (unsigned int)v12 + v5 )
  {
    v17 = v22 + v5;
    v18 = (void *)(2 * (v22 + v5));
    v27 = (_BYTE *)*v26;
    v19 = (_BYTE *)malloc(8 * v17);
    v20 = v19;
    if ( !v19 )
      goto LABEL_24;
    memcpy(v19, v27, 4 * v22);
    *(&dl_ns + 19 * v7 + 3) = v18;
    *v26 = v20;
    if ( __readgsdword(0xCu) )
      dl_wait_lookup_done();
    free(v27);
    v3 = *(_DWORD *)(a1 + 352);
    v12 = (&off_80EBA48)[19 * v7][1];
  }
LABEL_8:
  if ( v3 )
  {
    v13 = 0;
    do
    {
      v14 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v13);
      v15 = *(_BYTE *)(v14 + 404);
      if ( (v15 & 0x10) == 0 )
      {
        *(_BYTE *)(v14 + 404) = v15 | 0x10;
        (*(&off_80EBA48)[19 * v7])[(_DWORD)v12] = (void *)v14;
        v12 = (void **)((char *)v12 + 1);
        if ( (dl_debug_mask & 0x200) != 0 )
        {
          v24 = v12;
          dl_debug_printf("\nadd %s [%lu] to global scope\n", *(const char **)(v14 + 4), *(_DWORD *)(v14 + 24));
          v12 = v24;
        }
      }
      ++v13;
    }
    while ( *(_DWORD *)(a1 + 352) > v13 );
  }
  (&off_80EBA48)[19 * v7][1] = v12;
  return 0;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EBA40: using guessed type void *dl_ns;
// 80EBA48: using guessed type void ***off_80EBA48;
// 80EBA4C: using guessed type int dword_80EBA4C[];
// 80ECC60: using guessed type int dl_debug_mask;
// 80ECC64: using guessed type int (*dl_wait_lookup_done)(void);

//----- (0809B1A0) --------------------------------------------------------
_DWORD *__usercall dl_find_dso_for_object@<eax>(unsigned int a1@<eax>)
{
  _DWORD *v1; // ebx

  if ( !dl_nns )
    return 0;
  v1 = dl_ns;
  if ( !dl_ns )
    return 0;
  while ( v1[107] > a1 || a1 >= v1[108] || (*((_BYTE *)v1 + 405) & 0x40) == 0 && !dl_addr_inside_object((int)v1, a1) )
  {
    v1 = (_DWORD *)v1[3];
    if ( !v1 )
      return 0;
  }
  if ( v1[6] )
    _assert_fail("ns == l->l_ns", "dl-open.c", 188, "_dl_find_dso_for_object");
  return v1;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EBA28: using guessed type int dl_nns;
// 80EBA40: using guessed type void *dl_ns;

//----- (0809B220) --------------------------------------------------------
int __usercall dl_open@<eax>(
        int a1@<edi>,
        long double a2@<st0>,
        _BYTE *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  int v9; // ebx
  int v11; // eax
  unsigned int v12; // edx
  int v13; // esi
  char *v14; // eax
  void *v15; // esp
  int v16; // eax
  void *v17; // esp
  char v18[12]; // [esp+0h] [ebp-58h] BYREF
  unsigned int v19; // [esp+Ch] [ebp-4Ch]
  char v20; // [esp+13h] [ebp-45h] BYREF
  char *v21; // [esp+14h] [ebp-44h] BYREF
  _BYTE *v22; // [esp+18h] [ebp-40h] BYREF
  int v23[4]; // [esp+1Ch] [ebp-3Ch] BYREF
  int v24; // [esp+2Ch] [ebp-2Ch]
  int v25; // [esp+30h] [ebp-28h]
  int v26; // [esp+34h] [ebp-24h]
  int v27; // [esp+38h] [ebp-20h]
  int v28; // [esp+3Ch] [ebp-1Ch]
  int savedregs; // [esp+58h] [ebp+0h] BYREF
  int retaddr; // [esp+5Ch] [ebp+4h]

  if ( (a4 & 3) == 0 )
    dl_signal_error(22, a3, 0, a2, "invalid mode for dlopen()");
  if ( a6 == -1 )
    dl_signal_error(22, a3, 0, a2, "no more namespaces available for dlmopen()");
  if ( ((a6 + 2) & 0xFFFFFFFD) != 0 )
    dl_signal_error(22, a3, 0, a2, "invalid target namespace in dlmopen()");
  v25 = a6;
  v23[1] = a4;
  v24 = 0;
  v23[0] = (int)a3;
  v23[2] = a5;
  v23[3] = retaddr;
  v26 = a7;
  v27 = a8;
  v28 = a9;
  v9 = dl_catch_error(&v21, &v22, &v20, (int)&savedregs, a1, a4, (void (__cdecl *)(int))dl_open_worker, (int)v23);
  dl_unload_cache();
  if ( v22 )
  {
    if ( v24 )
    {
      if ( (a4 & 0x8000000) == 0 )
        dl_tls_dtv_gaps = 1;
      dl_close_worker(a2, v24, 1);
    }
    if ( !dl_debug_initialize(0, v25)[3] )
    {
      v11 = strlen(v22);
      v12 = v11 + 1;
      v13 = v11;
      v14 = &v22[v11 + 1];
      if ( v14 == v21 )
      {
        v19 = v12;
        v16 = strlen(v14);
        v17 = alloca(v13 + v16 + 17);
        memcpy(v18, v22, v13 + v16 + 2);
        v21 = &v18[v19];
      }
      else
      {
        v15 = alloca(v13 + 16);
        memcpy(v18, v22, v12);
      }
      if ( v20 )
        free(v22);
      dl_signal_error(v9, v21, 0, a2, v18);
    }
    _assert_fail("_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT", "dl-open.c", 688, "_dl_open");
  }
  if ( dl_debug_initialize(0, v25)[3] )
    _assert_fail("_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT", "dl-open.c", 717, "_dl_open");
  return v24;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80ECC24: using guessed type char dl_tls_dtv_gaps;

//----- (0809B4B0) --------------------------------------------------------
__int64 __cdecl dl_show_scope(_DWORD *a1, int a2)
{
  const char *v2; // eax
  int v3; // eax
  int v4; // esi
  unsigned int v5; // ebx
  _DWORD *v6; // eax
  const char *v7; // eax
  int v9; // [esp+Ch] [ebp-20h]

  v9 = a2;
  v2 = (const char *)a1[1];
  if ( !*v2 )
  {
    v2 = (const char *)program_invocation_short_name;
    if ( !program_invocation_short_name )
      v2 = "<main program>";
  }
  dl_debug_printf("object=%s [%lu]\n", v2, a1[6]);
  v3 = a1[115];
  if ( v3 )
  {
    v4 = 4 * a2;
    if ( *(_DWORD *)(v3 + 4 * a2) )
    {
      do
      {
        v5 = 0;
        dl_debug_printf(" scope %u:", v9);
        v6 = *(_DWORD **)(a1[115] + v4);
        if ( v6[1] )
        {
          do
          {
            v7 = *(const char **)(*(_DWORD *)(*v6 + 4 * v5) + 4);
            if ( !*v7 )
            {
              v7 = (const char *)program_invocation_short_name;
              if ( !program_invocation_short_name )
                v7 = "<program name unknown>";
            }
            ++v5;
            dl_debug_printf_c(" %s", v7);
            v6 = *(_DWORD **)(a1[115] + v4);
          }
          while ( v6[1] > v5 );
        }
        v4 += 4;
        dl_debug_printf_c("\n");
        ++v9;
      }
      while ( *(_DWORD *)(a1[115] + v4) );
    }
  }
  else
  {
    dl_debug_printf(" no scope\n");
  }
  return dl_debug_printf("\n");
}
// 80EB99C: using guessed type void *program_invocation_short_name;

//----- (0809B5E0) --------------------------------------------------------
_DWORD *__usercall dl_open_worker@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // esi
  int *v3; // edi
  int *dso_for_object; // ebx
  int v5; // edi
  _DWORD *result; // eax
  int v7; // esi
  unsigned int v8; // eax
  unsigned int v9; // ebx
  _DWORD *v10; // eax
  int v11; // eax
  int v12; // ecx
  _DWORD *v13; // eax
  int v14; // edx
  int v15; // eax
  unsigned int v16; // ecx
  void *v17; // esp
  _DWORD *v18; // eax
  unsigned int v19; // esi
  void *v20; // esp
  unsigned int v21; // eax
  unsigned int v22; // esi
  _WORD *v23; // edx
  bool v24; // cf
  int v25; // ebx
  int *v26; // eax
  int v27; // ecx
  int v28; // edx
  unsigned int v29; // eax
  unsigned int v30; // esi
  int v31; // esi
  unsigned int v32; // ebx
  int v33; // eax
  unsigned int v34; // esi
  unsigned int v35; // eax
  int v36; // ebx
  int v37; // ecx
  _BYTE *v38; // edi
  int v39; // edx
  _DWORD *v40; // eax
  unsigned int v41; // eax
  bool v42; // zf
  int v43; // ebx
  _DWORD *v44; // edx
  int v45; // ebx
  unsigned int v46; // esi
  int v47; // edi
  _BYTE *v48; // edx
  unsigned int v49; // edx
  int v50; // eax
  _DWORD v51[5]; // [esp+8h] [ebp-58h] BYREF
  int v52; // [esp+1Ch] [ebp-44h]
  int v53; // [esp+20h] [ebp-40h]
  _DWORD *v54; // [esp+24h] [ebp-3Ch]
  unsigned int v55; // [esp+28h] [ebp-38h]
  unsigned int v56; // [esp+2Ch] [ebp-34h]
  int v57; // [esp+30h] [ebp-30h]
  unsigned int v58; // [esp+34h] [ebp-2Ch]
  _WORD *v59; // [esp+38h] [ebp-28h]
  _DWORD *v60; // [esp+3Ch] [ebp-24h]
  int v61; // [esp+40h] [ebp-20h]
  unsigned int v62; // [esp+44h] [ebp-1Ch]
  unsigned int v63; // [esp+50h] [ebp-10h]

  v2 = *(char **)a2;
  v53 = *(_DWORD *)(a2 + 4);
  if ( j_strchr(v2, 36) || (v5 = *(_DWORD *)(a2 + 20), v5 == -2) || (dso_for_object = 0, !j_strchr(v2, 47)) )
  {
    v3 = (int *)dl_ns;
    dso_for_object = dl_find_dso_for_object(*(_DWORD *)(a2 + 8));
    if ( !dso_for_object )
      dso_for_object = v3;
    v5 = *(_DWORD *)(a2 + 20);
    if ( v5 == -2 )
    {
      v5 = dso_for_object[6];
      *(_DWORD *)(a2 + 20) = v5;
    }
  }
  dl_debug_initialize(0, v5);
  result = (_DWORD *)dl_map_object(dso_for_object, v2, 2, a1, 0, v53 | 0x10000000, *(_DWORD *)(a2 + 20));
  v54 = result;
  *(_DWORD *)(a2 + 16) = result;
  if ( !result )
  {
    if ( (v53 & 4) == 0 )
      _assert_fail("mode & RTLD_NOLOAD", "dl-open.c", 244, "dl_open_worker");
    return result;
  }
  if ( (v53 & 0x1000) != 0 )
  {
    result = v54;
    v54[129] |= 8u;
  }
  if ( (v53 & 0x40000000) != 0 )
    return result;
  v7 = v54[87];
  v62 = v54[100];
  v8 = v62 + 1;
  v54[100] = v62 + 1;
  if ( v7 )
  {
    if ( (dl_debug_mask & 0x40) != 0 )
      dl_debug_printf("opening file=%s [%lu]; direct_opencount=%u\n\n", (const char *)v54[1], v54[6], v8);
    if ( (v53 & 0x100) != 0 && (v54[101] & 0x10) == 0 )
      add_to_global((int)v54, a1);
    result = dl_debug_initialize(0, *(_DWORD *)(a2 + 20));
    if ( result[3] )
      _assert_fail("_dl_debug_initialize (0, args->nsid)->r_state == RT_CONSISTENT", "dl-open.c", 274, "dl_open_worker");
    return result;
  }
  v9 = 0;
  dl_map_object_deps((int)v54, 0, 0, a1, 0, v53 & 0x88000008);
  if ( v54[88] )
  {
    do
    {
      v10 = *(_DWORD **)(*(_DWORD *)(v54[87] + 4 * v9) + 20);
      if ( !v10[92] )
        dl_check_map_versions(v10, 0, 0, a1);
      ++v9;
    }
    while ( v54[88] > v9 );
  }
  dl_debug_initialize(0, *(_DWORD *)(a2 + 20))[3] = 0;
  dl_debug_state();
  if ( (dl_debug_mask & 0x200) != 0 )
    dl_show_scope(v54, 0);
  v11 = v53 & 0x8000000;
  if ( dl_lazy )
    v11 = v53 & 0x8000001;
  v12 = 0;
  v52 = v11;
  v13 = v54;
  do
  {
    v14 = v13[5];
    v13 = (_DWORD *)v13[3];
    v12 += (*(_BYTE *)(v14 + 404) & 4) == 0;
  }
  while ( v13 );
  v15 = 4 * v12 + 18;
  v51[4] = v51;
  v16 = 0;
  v17 = alloca(v15 & 0xFFFFFFF0);
  v18 = v54;
  do
  {
    if ( (*(_BYTE *)(v18[5] + 404) & 4) == 0 )
      v51[v16++] = v18;
    v18 = (_DWORD *)v18[3];
  }
  while ( v18 );
  v19 = v16;
  v58 = v16;
  if ( v16 <= 1 )
  {
    v31 = v52;
    v32 = v58 - 1;
    if ( !v58 )
      goto LABEL_38;
  }
  else
  {
    v51[3] = v51;
    v20 = alloca(2 * v16 + 1);
    v60 = v51;
    j_memset(v51, 0, 2 * v16);
    v62 = 0;
    v61 = 1;
    v55 = v19 - 1;
    while ( 1 )
    {
LABEL_27:
      v21 = v62;
      v22 = v55;
      v23 = (_WORD *)v60 + v62;
      v24 = v62 < v55;
      LOWORD(v57) = *v23 + 1;
      *v23 = v57;
      v25 = v51[v21];
      if ( v24 )
      {
        do
        {
          v26 = *(int **)(v51[v22] + 496);
          if ( v26 )
          {
            while ( 1 )
            {
              v27 = *v26;
              if ( !*v26 )
                break;
              ++v26;
              if ( v25 == v27 )
              {
                v59 = v23;
                v56 = v22 - v62;
                j_memmove(&v51[v61 - 1], &v51[v61], 4 * (v22 - v62));
                v28 = (int)v59;
                v29 = v58 - v62;
                v51[v22] = v25;
                if ( *(unsigned __int16 *)(v28 + 2) > v29 )
                  goto LABEL_32;
                v43 = (int)v60;
                j_memmove((char *)v60 + 2 * v61 - 2, (char *)v60 + 2 * v61, 2 * v56);
                *(_WORD *)(v43 + 2 * v22) = v57;
                goto LABEL_27;
              }
            }
          }
          --v22;
        }
        while ( v62 != v22 );
      }
      if ( v58 == v61 )
        break;
LABEL_32:
      v30 = v61;
      j_memset((char *)v60 + 2 * v61, 0, 2 * (v58 - v61));
      v62 = v30;
      v61 = v30 + 1;
    }
    v32 = v62;
    v31 = v52;
  }
  do
  {
    v33 = v51[v32--];
    dl_relocate_object(a1, v33, *(int ***)(v33 + 460), v31, 0);
  }
  while ( v32 != -1 );
LABEL_38:
  LOBYTE(v59) = 0;
  v34 = 0;
  v35 = v54[88];
  v60 = v54 + 87;
  v62 = v35;
  v58 = v35;
  if ( !v35 )
    goto LABEL_33;
  do
  {
    v37 = *(_DWORD *)(v54[87] + 4 * v34);
    if ( (*(_BYTE *)(v37 + 404) & 0xB) != 10 )
    {
      v36 = 0;
      if ( (*(_BYTE *)(v37 + 404) & 8) == 0 )
      {
        if ( *(_DWORD *)(v37 + 564) )
        {
          v63 = *(_DWORD *)(v54[87] + 4 * v34);
          v62 = v37;
          dl_add_to_slotinfo(a1, v63);
          v37 = v62;
          LOBYTE(v59) = 1;
          if ( (*(_BYTE *)(v62 + 405) & 4) != 0 && v54[88] == v58 )
          {
            v58 = v34;
            LOBYTE(v59) = 1;
          }
        }
      }
      if ( (dl_debug_mask & 0x200) != 0 )
        goto LABEL_54;
      goto LABEL_43;
    }
    v38 = *(_BYTE **)(v37 + 460);
    if ( !*(_DWORD *)v38 )
    {
      v62 = 1;
      v36 = 0;
      v41 = *(_DWORD *)(v37 + 456);
      if ( v41 > 1 )
        goto LABEL_52;
      goto LABEL_75;
    }
    if ( *(_DWORD **)v38 != v60 )
    {
      v61 = *(_DWORD *)(v54[87] + 4 * v34);
      v39 = 0;
      while ( 1 )
      {
        v36 = v39 + 1;
        v40 = *(_DWORD **)&v38[4 * v39 + 4];
        if ( !v40 )
          break;
        ++v39;
        if ( v40 == v60 )
          goto LABEL_44;
      }
      v37 = v61;
      v62 = v39 + 2;
      v41 = *(_DWORD *)(v61 + 456);
      if ( v41 > v39 + 2 )
      {
LABEL_52:
        v61 = 4 * v36;
        goto LABEL_53;
      }
LABEL_75:
      v48 = (_BYTE *)(v37 + 440);
      v57 = v37 + 440;
      if ( v41 > 3 || (v56 = 4, v38 == v48) )
      {
        v61 = v37;
        v56 = 2 * v41;
        v48 = (_BYTE *)malloc(8 * v41);
        v37 = v61;
        if ( !v48 )
          dl_signal_error(12, "dlopen", 0, a1, "cannot create scope list");
      }
      v52 = v37;
      v61 = 4 * v36;
      v55 = (unsigned int)v48;
      memcpy(v48, v38, 4 * v36);
      v37 = v52;
      v49 = v55;
      v50 = *(_DWORD *)(v52 + 460);
      v42 = v57 == v50;
      *(_DWORD *)(v52 + 460) = v55;
      if ( !v42 )
      {
        v57 = v37;
        dl_scope_free(v50);
        v37 = v57;
        v49 = *(_DWORD *)(v57 + 460);
      }
      v38 = (_BYTE *)v49;
      *(_DWORD *)(v37 + 456) = v56;
LABEL_53:
      *(_DWORD *)&v38[4 * v62] = 0;
      v42 = (dl_debug_mask & 0x200) == 0;
      *(_DWORD *)(*(_DWORD *)(v37 + 460) + v61) = v60;
      if ( !v42 )
LABEL_54:
        dl_show_scope((_DWORD *)v37, v36);
LABEL_43:
      v62 = v54[88];
    }
LABEL_44:
    ++v34;
  }
  while ( v62 > v34 );
  if ( (_BYTE)v59 )
  {
    if ( !++dl_tls_generation )
    {
      dl_dprintf(2, "TLS generation counter wrapped!  Please report this.");
      exit(127);
    }
  }
  if ( v58 < v62 )
  {
    v44 = v54;
    v45 = 4 * v58;
    v46 = v58;
    do
    {
      v47 = *(_DWORD *)(v44[87] + v45);
      if ( (*(_WORD *)(v47 + 404) & 0x408) == 1024 )
      {
        if ( *(_DWORD *)(v47 + 564) )
        {
          v62 = (unsigned int)v44;
          *(_BYTE *)(v47 + 405) &= ~4u;
          dl_init_static_tls(v47);
          v44 = (_DWORD *)v62;
          if ( (*(_BYTE *)(v47 + 405) & 4) != 0 )
            _assert_fail("imap->l_need_tls_init == 0", "dl-open.c", 562, "dl_open_worker");
        }
      }
      ++v46;
      v45 += 4;
    }
    while ( v44[88] > v46 );
  }
LABEL_33:
  result = (_DWORD *)dl_init(v54, *(_DWORD *)(a2 + 24), *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 32));
  if ( (v53 & 0x100) == 0 || (result = (_DWORD *)add_to_global((int)v54, a1)) == 0 )
  {
    _libc_multiple_libcs = 1;
    if ( (dl_debug_mask & 0x40) != 0 )
      return (_DWORD *)dl_debug_printf(
                         "opening file=%s [%lu]; direct_opencount=%u\n\n",
                         (const char *)v54[1],
                         v54[6],
                         v54[100]);
  }
  return result;
}
// 80481D0: using guessed type int __cdecl j_memmove(_DWORD, _DWORD, _DWORD);
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 8070160: using guessed type int dl_debug_state(void);
// 80EBA0C: using guessed type int (__cdecl *dl_init_static_tls)(_DWORD);
// 80EBA40: using guessed type void *dl_ns;
// 80EBD10: using guessed type int _libc_multiple_libcs;
// 80ECC28: using guessed type int dl_tls_generation;
// 80ECC60: using guessed type int dl_debug_mask;
// 80ECC84: using guessed type int dl_lazy;

//----- (0809BDC0) --------------------------------------------------------
int __usercall remove_slotinfo@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, unsigned __int8 a4)
{
  int v6; // edx
  unsigned int v7; // ecx
  unsigned int v8; // eax
  _DWORD *v10; // edx
  int v11; // ecx
  int v12; // edi

  if ( (unsigned int)(a1 - a3) < *a2 )
  {
    v10 = &a2[2 * (a1 - a3)];
    v11 = v10[3];
    if ( v11 )
    {
      if ( a1 != *(_DWORD *)(v11 + 580) )
        _assert_fail("old_map->l_tls_modid == idx", "dl-close.c", 80, "remove_slotinfo");
      v12 = dl_tls_generation;
      v10[3] = 0;
      v10[2] = v12 + 1;
    }
    v6 = dl_tls_max_dtv_idx;
    if ( a1 != dl_tls_max_dtv_idx )
      return 1;
  }
  else if ( a2[1] )
  {
    if ( (unsigned __int8)remove_slotinfo(a4) )
      return 1;
    v6 = a3 + *a2;
  }
  else
  {
    if ( a4 )
      _assert_fail("! should_be_there", "dl-close.c", 59, "remove_slotinfo");
    v6 = a1;
  }
  v7 = dl_tls_static_nelem + 1;
  if ( a3 )
    v7 = 0;
  v8 = v6 - a3;
  do
  {
    if ( v7 >= v8 )
      return 0;
    --v8;
    --v6;
  }
  while ( !a2[2 * v8 + 3] );
  dl_tls_max_dtv_idx = v6;
  return 1;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80ECA08: using guessed type int dl_tls_max_dtv_idx;
// 80ECC28: using guessed type int dl_tls_generation;
// 80ECC2C: using guessed type int dl_tls_static_nelem;

//----- (0809BED0) --------------------------------------------------------
_DWORD *__usercall dl_close_worker@<eax>(long double a1@<st0>, int a2, char a3)
{
  _DWORD *result; // eax
  bool v4; // zf
  int v5; // eax
  void *v6; // esp
  void *v7; // esp
  void *v8; // esp
  int v9; // edx
  int v10; // eax
  _DWORD *v11; // ecx
  unsigned int v12; // esi
  int v13; // esi
  unsigned int v14; // eax
  int v15; // edx
  int *v16; // eax
  int v17; // edx
  unsigned int v18; // ecx
  int v19; // edx
  int v20; // edx
  unsigned int *v21; // ecx
  unsigned int v22; // edx
  int v23; // eax
  unsigned int v24; // ebx
  int v25; // eax
  unsigned int v26; // esi
  int v27; // ebx
  char v28; // al
  int v29; // eax
  int v30; // esi
  int v31; // eax
  void (**v32)(void); // edi
  void (**v33)(void); // esi
  int v34; // eax
  bool v35; // cf
  unsigned int v36; // eax
  int v37; // edi
  int v38; // esi
  char v39; // cl
  _DWORD *v40; // edx
  int v41; // eax
  int v42; // edi
  unsigned int v43; // edx
  int v44; // edi
  int v45; // eax
  unsigned int v46; // eax
  _DWORD *v47; // eax
  int v48; // edx
  int v49; // eax
  int v50; // ecx
  int v51; // ebx
  int v52; // eax
  char v53; // cl
  int v54; // eax
  char v55; // si
  int v56; // eax
  int v57; // ecx
  int i; // edx
  int v59; // eax
  int v60; // edx
  int v61; // edi
  _DWORD *v62; // eax
  int *v63; // eax
  int v64; // ebx
  int v65; // ecx
  int v66; // eax
  unsigned int v67; // eax
  _DWORD *v68; // ecx
  _BYTE *v69; // ebx
  int v70; // esi
  _DWORD *v71; // eax
  int v72; // edx
  _DWORD *v73; // ecx
  _DWORD *v74; // edx
  int v75; // eax
  int v76; // edx
  int v77; // edx
  int v78; // eax
  int v79; // edi
  int v80; // eax
  _DWORD *v81; // eax
  _DWORD *v82; // edx
  int v83; // esi
  int j; // ebx
  int v85; // edx
  int v86; // edi
  int *v87; // ebx
  int v88; // eax
  int v89; // eax
  unsigned int v90; // [esp-8h] [ebp-70h]
  _BYTE v91[3]; // [esp+0h] [ebp-68h] BYREF
  _BYTE v92[9]; // [esp+3h] [ebp-65h] BYREF
  int v93; // [esp+Ch] [ebp-5Ch]
  _DWORD *v94; // [esp+10h] [ebp-58h]
  _DWORD *v95; // [esp+14h] [ebp-54h]
  int v96; // [esp+18h] [ebp-50h]
  int v97; // [esp+1Ch] [ebp-4Ch]
  _DWORD *v98; // [esp+20h] [ebp-48h]
  int v99; // [esp+24h] [ebp-44h]
  _DWORD *v100; // [esp+28h] [ebp-40h]
  char v101; // [esp+2Dh] [ebp-3Bh]
  char v102; // [esp+2Eh] [ebp-3Ah]
  char v103; // [esp+2Fh] [ebp-39h]
  int v104; // [esp+30h] [ebp-38h]
  unsigned int v105; // [esp+34h] [ebp-34h]
  int v106; // [esp+38h] [ebp-30h]
  int v107; // [esp+3Ch] [ebp-2Ch]
  _DWORD *v108; // [esp+40h] [ebp-28h]
  unsigned int v109; // [esp+44h] [ebp-24h]
  unsigned int v110; // [esp+48h] [ebp-20h]
  unsigned int v111; // [esp+4Ch] [ebp-1Ch]

  v103 = a3;
  v111 = *(_DWORD *)(a2 + 400);
  result = (_DWORD *)(v111 - 1);
  v4 = v111 == 1;
  *(_DWORD *)(a2 + 400) = v111 - 1;
  if ( !v4 )
    goto LABEL_3;
  LOBYTE(v111) = *(_BYTE *)(a2 + 404);
  if ( (v111 & 3) != 2 )
    goto LABEL_3;
  if ( dl_close_state_10451 )
  {
    dl_close_state_10451 = 2;
LABEL_3:
    if ( (dl_debug_mask & 0x40) != 0 )
      return (_DWORD *)dl_debug_printf(
                         "\nclosing file=%s; direct_opencount=%u\n",
                         (const char *)*(_DWORD *)(a2 + 4),
                         result);
    return result;
  }
  v107 = *(_DWORD *)(a2 + 24);
  v95 = (_DWORD *)(76 * v107 + 135182912);
  v93 = (int)&unk_80EBA50 + 76 * v107;
  while ( 2 )
  {
    *(_DWORD *)&v92[5] = v91;
    dl_close_state_10451 = 1;
    v111 = v95[1];
    v5 = 16 * ((v111 + 15) >> 4);
    v6 = alloca(v5);
    v7 = alloca(v5);
    v109 = (unsigned int)v91;
    v8 = alloca(4 * v111 + 3);
    v105 = (unsigned int)v92 >> 2;
    v108 = v91;
    if ( v103 )
      *(_DWORD *)(a2 + 516) &= ~8u;
    v9 = 0;
    v10 = *v95;
    if ( *v95 )
    {
      v11 = v108;
      do
      {
        *(_DWORD *)(v10 + 524) = v9;
        v11[v9++] = v10;
        v10 = *(_DWORD *)(v10 + 12);
      }
      while ( v10 );
    }
    if ( v111 != v9 )
      _assert_fail("idx == nloaded", "dl-close.c", 165, "_dl_close_worker");
    v12 = v111;
    j_memset(v91, 0, v111);
    v90 = v12;
    v13 = -1;
    j_memset(v109, 0, v90);
    while ( v111 > ++v13 )
    {
      if ( !*(_BYTE *)(v109 + v13) )
      {
        v110 = v108[v13];
        LOBYTE(v106) = *(_BYTE *)(v110 + 404);
        if ( (v106 & 3) != 2
          || *(_DWORD *)(v110 + 400)
          || (*(_BYTE *)(v110 + 516) & 8) != 0
          || (v106 = *(_DWORD *)(v110 + 584)) != 0
          || v91[v13] )
        {
          v14 = v109;
          v91[v13] = 1;
          *(_BYTE *)(v14 + v13) = 1;
          v15 = *(_DWORD *)(v110 + 496);
          *(_DWORD *)(v110 + 524) = -1;
          if ( v15 )
          {
            v16 = (int *)(v15 + 4);
            v17 = *(_DWORD *)(v15 + 4);
            if ( v17 )
            {
              v18 = v111;
              do
              {
                v19 = *(_DWORD *)(v17 + 524);
                if ( v19 != -1 )
                {
                  if ( v19 < 0 || v18 <= v19 )
                    _assert_fail("(*lp)->l_idx >= 0 && (*lp)->l_idx < nloaded", "dl-close.c", 207, "_dl_close_worker");
                  if ( !v91[v19] )
                  {
                    v91[v19] = 1;
                    v20 = *(_DWORD *)(*v16 + 524);
                    if ( v20 <= v13 )
                      v13 = v20 - 1;
                  }
                }
                v17 = *++v16;
              }
              while ( *v16 );
            }
          }
          v21 = *(unsigned int **)(v110 + 500);
          if ( v21 && *v21 )
          {
            v22 = 0;
            do
            {
              v24 = v21[v22 + 1];
              v25 = *(_DWORD *)(v24 + 524);
              if ( v25 != -1 )
              {
                if ( v25 < 0 || v111 <= v25 )
                  _assert_fail("jmap->l_idx >= 0 && jmap->l_idx < nloaded", "dl-close.c", 232, "_dl_close_worker");
                if ( !v91[v25] )
                {
                  v91[v25] = 1;
                  v23 = *(_DWORD *)(v24 + 524);
                  if ( v23 <= v13 )
                    v13 = v23 - 1;
                  v21 = *(unsigned int **)(v110 + 500);
                }
              }
              ++v22;
            }
            while ( v22 < *v21 );
          }
        }
      }
    }
    v26 = v111;
    result = dl_sort_fini(v108, v111, (int)v91, v107);
    if ( !v26 )
      goto LABEL_112;
    v27 = *(_DWORD *)(4 * v105);
    if ( v107 != *(_DWORD *)(v27 + 24) )
LABEL_67:
      _assert_fail("imap->l_ns == nsid", "dl-close.c", 260, "_dl_close_worker");
    v104 = 0;
    v110 = 0;
    v102 = 0;
    LOBYTE(v105) = 0;
    v109 = -1;
    v106 = (int)v91;
    while ( 1 )
    {
      v28 = *(_BYTE *)(v27 + 404);
      if ( !*(_BYTE *)(v106 + v110) )
      {
        if ( (v28 & 3) != 2 || (*(_BYTE *)(v27 + 516) & 8) != 0 )
          _assert_fail(
            "imap->l_type == lt_loaded && (imap->l_flags_1 & DF_1_NODELETE) == 0",
            "dl-close.c",
            265,
            "_dl_close_worker");
        if ( (v28 & 8) != 0 )
        {
          if ( (dl_debug_mask & 2) != 0 )
            dl_debug_printf("\ncalling fini: %s [%lu]\n\n", *(const char **)(v27 + 4), v107);
          v29 = *(_DWORD *)(v27 + 136);
          if ( v29 )
          {
            v30 = *(_DWORD *)v27 + *(_DWORD *)(v29 + 4);
            v31 = *(_DWORD *)(*(_DWORD *)(v27 + 144) + 4) >> 2;
            if ( v31 )
            {
              v32 = (void (**)(void))(v30 + 4 * v31 - 4);
              v33 = (void (**)(void))(v30 - 4);
              do
                (*v32--)();
              while ( v32 != v33 );
            }
          }
          v34 = *(_DWORD *)(v27 + 84);
          if ( v34 )
            ((void (*)(void))(*(_DWORD *)(v34 + 4) + *(_DWORD *)v27))();
          v28 = *(_BYTE *)(v27 + 404);
        }
        *(_BYTE *)(v27 + 405) |= 0x20u;
        LOBYTE(v105) = 1;
        v35 = (v28 & 0x10) == 0;
        v36 = v109;
        v104 -= v35 - 1;
        if ( v109 > v110 )
          v36 = v110;
        v109 = v36;
        goto LABEL_65;
      }
      if ( (v28 & 3) != 2 )
        goto LABEL_65;
      if ( *(_DWORD *)(v27 + 348) || (v57 = *(_DWORD *)(v27 + 496)) == 0 )
      {
        v37 = **(_DWORD **)(v27 + 460);
        v100 = *(_DWORD **)(v27 + 460);
        v96 = 0;
        v99 = 1;
        if ( !v37 )
          goto LABEL_80;
      }
      else
      {
        if ( *(_DWORD *)(v57 + 4) )
        {
          for ( i = 1; ; ++i )
          {
            v59 = i + 1;
            if ( !*(_DWORD *)(v57 + 4 * (i + 1)) )
              break;
          }
          v60 = 4 * i + 8;
        }
        else
        {
          v60 = 8;
          v59 = 1;
        }
        *(_DWORD *)(v27 + 352) = v59;
        *(_DWORD *)(v27 + 348) = v57 + v60;
        v96 = v27 + 348;
        v37 = **(_DWORD **)(v27 + 460);
        v100 = *(_DWORD **)(v27 + 460);
        if ( !v37 )
          goto LABEL_79;
        v99 = 2;
      }
      v38 = v27 + 356;
      v98 = (_DWORD *)v27;
      v97 = v37;
      v39 = 0;
      v94 = v100 + 1;
      v40 = v100 + 1;
      v41 = v37;
      v42 = v99;
      do
      {
        while ( v38 != v41 )
        {
          if ( v107 != *(_DWORD *)(v41 - 324) )
            _assert_fail("tmap->l_ns == nsid", "dl-close.c", 363, "_dl_close_worker");
          if ( *(_DWORD *)(v41 + 176) == -1 )
            break;
          v41 = *v40++;
          v39 = 1;
          if ( !v41 )
            goto LABEL_77;
        }
        v41 = *v40++;
        ++v42;
      }
      while ( v41 );
LABEL_77:
      v43 = v42;
      v27 = (int)v98;
      v44 = v97;
      if ( v39 )
      {
        v47 = v98 + 110;
        v98 += 110;
        if ( v43 > 3 || (v48 = v27 + 440, v99 = 4, v100 == v47) )
        {
          v56 = *(_DWORD *)(v27 + 456);
          LOBYTE(v97) = v39;
          v99 = v56;
          v48 = malloc(4 * v56);
          v39 = v97;
          if ( !v48 )
            dl_signal_error(12, "dlclose", 0, a1, "cannot create scope list");
        }
        v97 = v27;
        v101 = v39;
        v49 = 0;
        v50 = (int)v94;
        v51 = v96;
        do
        {
          while ( v44 == v38 || *(_DWORD *)(v44 + 176) == -1 )
          {
            v50 += 4;
            *(_DWORD *)(v48 + 4 * v49++) = v44;
            v44 = *(_DWORD *)(v50 - 4);
            if ( !v44 )
              goto LABEL_95;
          }
          if ( v51 )
          {
            *(_DWORD *)(v48 + 4 * v49++) = v51;
            v51 = 0;
          }
          v50 += 4;
          v44 = *(_DWORD *)(v50 - 4);
        }
        while ( v44 );
LABEL_95:
        *(_DWORD *)(v48 + 4 * v49) = 0;
        v52 = (int)v100;
        v27 = v97;
        v53 = v101;
        v4 = v100 == v98;
        *(_DWORD *)(v97 + 460) = v48;
        if ( v4 )
        {
          v102 = v53;
        }
        else
        {
          v54 = dl_scope_free(v52);
          v55 = v102;
          if ( v54 )
            v55 = 0;
          v102 = v55;
        }
        *(_DWORD *)(v27 + 456) = v99;
        goto LABEL_80;
      }
      if ( v96 )
      {
LABEL_79:
        *(_DWORD *)(v27 + 348) = 0;
        *(_DWORD *)(v27 + 352) = 0;
      }
LABEL_80:
      v45 = *(_DWORD *)(v27 + 364);
      if ( v45 && *(_DWORD *)(v45 + 524) != -1 )
        *(_DWORD *)(v27 + 364) = 0;
      v46 = v109;
      if ( v109 > v110 )
        v46 = v110;
      v109 = v46;
LABEL_65:
      result = (_DWORD *)++v110;
      if ( v111 == v110 )
        break;
      v27 = v108[v110];
      if ( v107 != *(_DWORD *)(v27 + 24) )
        goto LABEL_67;
    }
    v61 = v106;
    if ( (_BYTE)v105 )
    {
      v62 = dl_debug_initialize(0, v107);
      v62[3] = 2;
      v100 = v62;
      dl_debug_state();
      if ( v104 )
      {
        v63 = (int *)v95[2];
        v64 = v63[1];
        v111 = (unsigned int)v63;
        if ( v64 )
        {
          v65 = *v63;
          if ( (*(_BYTE *)(*(_DWORD *)(*v63 + 4 * v64 - 4) + 405) & 0x20) != 0 )
          {
            v66 = v64;
            while ( --v66 )
            {
              if ( (*(_BYTE *)(*(_DWORD *)(v65 + 4 * v66 - 4) + 405) & 0x20) == 0 )
              {
                v83 = v66;
                goto LABEL_182;
              }
            }
          }
          else
          {
            v83 = v64;
LABEL_182:
            v66 = v83;
            if ( v64 != v83 + v104 )
            {
              v66 = 0;
              for ( j = 0; j != v83; ++j )
              {
                v85 = *(_DWORD *)(v65 + 4 * j);
                if ( (*(_BYTE *)(v85 + 405) & 0x20) == 0 )
                {
                  if ( v66 != j )
                    *(_DWORD *)(v65 + 4 * v66) = v85;
                  ++v66;
                }
              }
            }
          }
        }
        else
        {
          v66 = 0;
        }
        *(_DWORD *)(v111 + 4) = v66;
      }
      if ( __readgsdword(0xCu) && (v104 || v102 || dl_scope_free_list && *(_DWORD *)dl_scope_free_list) )
      {
        dl_wait_lookup_done();
        v87 = (int *)dl_scope_free_list;
        if ( dl_scope_free_list )
        {
          v88 = *(_DWORD *)dl_scope_free_list;
          if ( *(_DWORD *)dl_scope_free_list )
          {
            do
            {
              v89 = v88 - 1;
              *v87 = v89;
              free(v87[v89 + 1]);
              v88 = *v87;
            }
            while ( *v87 );
          }
        }
      }
      v67 = v109;
      if ( v110 > v109 )
      {
        v68 = v108;
        v69 = (_BYTE *)(v61 + v109);
        v110 += v61;
        LOBYTE(v109) = 0;
        v108 = 0;
        v106 = 0;
        v111 = (unsigned int)&v68[v67];
        do
        {
          if ( !*v69 )
          {
            v70 = *(_DWORD *)v111;
            if ( (*(_BYTE *)(*(_DWORD *)v111 + 404) & 3) != 2 )
              _assert_fail("imap->l_type == lt_loaded", "dl-close.c", 547, "_dl_close_worker");
            if ( *(_DWORD *)(v70 + 564) )
            {
              if ( dl_tls_dtv_slotinfo_list
                && !(unsigned __int8)remove_slotinfo(
                                       *(_DWORD *)(v70 + 580),
                                       (_DWORD *)dl_tls_dtv_slotinfo_list,
                                       0,
                                       (*(_BYTE *)(*(_DWORD *)v111 + 404) & 8) != 0) )
              {
                dl_tls_max_dtv_idx = dl_tls_static_nelem;
              }
              v81 = *(_DWORD **)(v70 + 576);
              LOBYTE(v109) = v105;
              if ( (unsigned int)v81 + 1 > 1 )
              {
                LOBYTE(v109) = v106 == 0 || v81 == (_DWORD *)v106;
                if ( (_BYTE)v109 )
                {
                  v106 = (int)v81 - *(_DWORD *)(v70 + 564);
                  if ( v108 )
                    v81 = v108;
                  v108 = v81;
                }
                else
                {
                  v82 = (_DWORD *)((char *)v81 - *(_DWORD *)(v70 + 564));
                  if ( v82 == v108 )
                  {
                    v108 = v81;
                    LOBYTE(v109) = v105;
                  }
                  else if ( (_DWORD *)dl_tls_static_used == v108 )
                  {
                    v108 = v81;
                    v86 = v106;
                    v106 = (int)v82;
                    dl_tls_static_used = v86;
                    LOBYTE(v109) = v105;
                  }
                  else if ( v81 == (_DWORD *)dl_tls_static_used )
                  {
                    dl_tls_static_used = (int)v81 - *(_DWORD *)(v70 + 564);
                    LOBYTE(v109) = v105;
                  }
                  else
                  {
                    if ( v81 > v108 )
                    {
                      v108 = v81;
                      v106 = (int)v82;
                    }
                    LOBYTE(v109) = v105;
                  }
                }
              }
            }
            if ( v103 )
            {
              v71 = (_DWORD *)v95[10];
              if ( v71 )
              {
                v72 = v95[11];
                if ( v72 )
                {
                  v73 = v95;
                  v74 = &v71[4 * v72];
                  do
                  {
                    while ( !v71[1] || v70 != v71[3] )
                    {
                      v71 += 4;
                      if ( v74 == v71 )
                        goto LABEL_136;
                    }
                    v71[1] = 0;
                    *v71 = 0;
                    v71 += 4;
                    --v73[12];
                  }
                  while ( v74 != v71 );
                }
              }
            }
LABEL_136:
            dl_unmap(v70);
            if ( v107 )
              _assert_fail("nsid == LM_ID_BASE", "dl-close.c", 687, "_dl_close_worker");
            v75 = *(_DWORD *)(v70 + 16);
            if ( !v75 )
              _assert_fail("imap->l_prev != NULL", "dl-close.c", 688, "_dl_close_worker");
            v76 = *(_DWORD *)(v70 + 12);
            --dword_80EBA44[0];
            *(_DWORD *)(v75 + 12) = v76;
            v77 = *(_DWORD *)(v70 + 12);
            if ( v77 )
              *(_DWORD *)(v77 + 16) = v75;
            free(*(_DWORD *)(v70 + 368));
            if ( *(_DWORD *)(v70 + 424) != -1 )
              free(*(_DWORD *)(v70 + 424));
            free(*(_DWORD *)(v70 + 500));
            if ( (dl_debug_mask & 0x40) != 0 )
              dl_debug_printf(
                "\nfile=%s [%lu];  destroying link map\n",
                *(const char **)(v70 + 4),
                *(_DWORD *)(v70 + 24));
            free(*(_DWORD *)(v70 + 4));
            v78 = *(_DWORD *)(v70 + 28);
            do
            {
              while ( 1 )
              {
                v79 = *(_DWORD *)(v78 + 4);
                if ( !*(_DWORD *)(v78 + 8) )
                  break;
                v78 = *(_DWORD *)(v78 + 4);
                if ( !v79 )
                  goto LABEL_148;
              }
              free(v78);
              v78 = v79;
            }
            while ( v79 );
LABEL_148:
            free(*(_DWORD *)(v70 + 496));
            v80 = *(_DWORD *)(v70 + 460);
            if ( v80 != v70 + 440 )
              free(v80);
            if ( *(char *)(v70 + 404) < 0 )
              free(*(_DWORD *)(v70 + 336));
            if ( *(_DWORD *)(v70 + 408) != -1 )
              free(*(_DWORD *)(v70 + 408));
            if ( *(_DWORD *)(v70 + 488) != -1 )
              free(*(_DWORD *)(v70 + 488));
            free(v70);
          }
          ++v69;
          v111 += 4;
        }
        while ( v69 != (_BYTE *)v110 );
        if ( (_BYTE)v109 )
        {
          if ( !++dl_tls_generation )
          {
            dl_dprintf(
              2,
              "TLS generation counter wrapped!  Please report as described in <http://www.debian.org/Bugs/>.\n");
            exit(127);
          }
          if ( (_DWORD *)dl_tls_static_used == v108 )
            dl_tls_static_used = v106;
        }
      }
      if ( !*v95 && dl_nns - 1 == v107 )
        dl_nns = v107;
      v100[3] = 0;
      result = (_DWORD *)dl_debug_state();
    }
LABEL_112:
    if ( dl_close_state_10451 == 2 )
      continue;
    break;
  }
  dl_close_state_10451 = 0;
  return result;
}
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 8070160: using guessed type int dl_debug_state(void);
// 80EBA28: using guessed type int dl_nns;
// 80EBA44: using guessed type int dword_80EBA44[];
// 80EC794: using guessed type int dl_close_state_10451;
// 80ECA00: using guessed type int dl_tls_static_used;
// 80ECA08: using guessed type int dl_tls_max_dtv_idx;
// 80ECC20: using guessed type int dl_tls_dtv_slotinfo_list;
// 80ECC28: using guessed type int dl_tls_generation;
// 80ECC2C: using guessed type int dl_tls_static_nelem;
// 80ECC60: using guessed type int dl_debug_mask;
// 80ECC64: using guessed type int (*dl_wait_lookup_done)(void);
// 80ECC94: using guessed type int dl_scope_free_list;

//----- (0809CB80) --------------------------------------------------------
void __usercall dl_close(long double a1@<st0>, int a2)
{
  if ( (*(_BYTE *)(a2 + 516) & 8) != 0 )
  {
    if ( (*(_BYTE *)(a2 + 404) & 8) == 0 )
      _assert_fail(a1, (int)"map->l_init_called", (int)"dl-close.c", 811, "_dl_close");
  }
  else
  {
    if ( !*(_DWORD *)(a2 + 400) )
      dl_signal_error(0, *(_BYTE **)(a2 + 4), 0, a1, "shared object not open");
    dl_close_worker(a1, a2, 0);
  }
}

//----- (0809CC20) --------------------------------------------------------
void __userpurge __spoils<ecx,st0> dl_runtime_resolve(long double a1@<st0>, int a2, int a3, int a4)
{
  unsigned int retaddr; // [esp+8h] [ebp+0h]

  dl_fixup(retaddr, a2, a1);
}

//----- (0809CC40) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge __spoils<edx,ecx,st0,xmm0> dl_runtime_profile(
        unsigned int a1@<edx>,
        unsigned int a2@<ecx>,
        long double a3@<st1>,
        long double a4@<st0>,
        __int64 _XMM0_8@<xmm0>,
        __int64 _XMM1_8@<xmm1>,
        int a7,
        int a8,
        char a9,
        int a10,
        int a11)
{
  int (*v11)(void); // eax
  __int64 v14; // [esp-8h] [ebp-4Ch] BYREF
  long double v15; // [esp+0h] [ebp-44h]
  long double v16; // [esp+Ch] [ebp-38h]
  __int64 v17; // [esp+18h] [ebp-2Ch] BYREF
  __int64 v18; // [esp+20h] [ebp-24h] BYREF
  unsigned __int64 v19; // [esp+28h] [ebp-1Ch] BYREF
  int v20; // [esp+38h] [ebp-Ch]
  unsigned int v21; // [esp+3Ch] [ebp-8h]
  unsigned int v22; // [esp+40h] [ebp-4h]
  int retaddr; // [esp+44h] [ebp+0h]

  v20 += 8;
  v19 = __PAIR64__(a2, a1);
  HIDWORD(v18) = -1;
  v11 = dl_profile_fixup(v21, v22, retaddr, a4, (int)&v19, (_DWORD *)&v18 + 1);
  if ( v18 >= 0 )
  {
    qmemcpy((char *)&v17 - (HIDWORD(v18) & 0xFFFFFFF8 | 4) + 4, &a7, 4 * (HIDWORD(v18) >> 2));
    v14 = ((__int64 (__fastcall *)(_DWORD, _DWORD, int (*)(void)))v11)(HIDWORD(v19), v19, v11);
    v15 = a3;
    v16 = a4;
    __asm
    {
      bndmov  [esp+44h+var_24], bnd0
      bndmov  [esp+44h+var_1C], bnd1
    }
    dl_call_pltexit(&v14);
    __asm
    {
      bndmov  bnd0, [esp+44h+var_24]
      bndmov  bnd1, [esp+44h+var_1C]
    }
  }
  else
  {
    HIDWORD(v19) = v11;
  }
}
// 809CD0B: positive sp value 8 has been found
// 809CC40: unsupported processor register 'bnd0'
// 80A1DA0: using guessed type _DWORD __stdcall dl_call_pltexit(_DWORD);

//----- (0809CD10) --------------------------------------------------------
int __usercall dl_cache_libcmp@<eax>(char *a1@<eax>, char *a2@<edx>)
{
  int v2; // ebx
  int v3; // ecx
  int v4; // esi
  int v5; // ebx
  int i; // ecx
  char v8; // di
  int v9; // [esp+0h] [ebp-18h]

  while ( 1 )
  {
    v2 = *a1;
    if ( !(_BYTE)v2 )
      return -*a2;
    while ( (unsigned __int8)(v2 - 48) > 9u )
    {
      v8 = *a2;
      if ( (unsigned __int8)(*a2 - 48) <= 9u )
        return -1;
      if ( (_BYTE)v2 != v8 )
        return v2 - v8;
      v2 = *++a1;
      ++a2;
      if ( !(_BYTE)v2 )
        return -*a2;
    }
    if ( (unsigned __int8)(*a2 - 48) > 9u )
      break;
    v3 = a1[1];
    v9 = v2 - 48;
    v4 = *a2 - 48;
    ++a1;
    for ( ; (unsigned __int8)(v3 - 48) <= 9u; v9 = v5 )
    {
      ++a1;
      v5 = v3 + 10 * v9 - 48;
      v3 = *a1;
    }
    for ( i = *++a2; (unsigned __int8)(i - 48) <= 9u; i = *a2 )
    {
      ++a2;
      v4 = i + 10 * v4 - 48;
    }
    if ( v4 != v9 )
      return v9 - v4;
  }
  return 1;
}

//----- (0809CE30) --------------------------------------------------------
_BYTE *__usercall dl_load_cache_lookup@<eax>(char *a1@<eax>)
{
  int v1; // esi
  unsigned int v2; // ebx
  unsigned int v3; // esi
  int v4; // ebx
  const char *v5; // edi
  int v6; // esi
  int v7; // esi
  int v8; // edi
  unsigned int v9; // edx
  int v10; // ebx
  int v11; // eax
  int v13; // edi
  unsigned int v14; // edx
  int v15; // ebx
  int v16; // esi
  _DWORD *v17; // ebx
  unsigned int v18; // edx
  int v19; // ecx
  int v20; // edx
  __int64 v21; // rax
  int v22; // edi
  int v23; // eax
  void *v24; // esp
  int whole_file; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // edx
  unsigned int v30; // ebx
  int v31; // eax
  int v32; // edi
  unsigned int v33; // edx
  int v34; // esi
  int v35; // ebx
  int v36; // eax
  int v37; // esi
  int v38; // ebx
  unsigned int v39; // edx
  int v40; // esi
  int v41; // edi
  _DWORD *v42; // esi
  unsigned int v43; // edx
  int v44; // edx
  unsigned int v45; // eax
  unsigned int v46; // [esp+0h] [ebp-68h] BYREF
  bool v47; // [esp+7h] [ebp-61h]
  int v48; // [esp+8h] [ebp-60h]
  unsigned int v49; // [esp+Ch] [ebp-5Ch]
  int v50; // [esp+10h] [ebp-58h]
  int v51; // [esp+14h] [ebp-54h]
  __int64 v52; // [esp+18h] [ebp-50h]
  int v53; // [esp+20h] [ebp-48h]
  unsigned int v54; // [esp+24h] [ebp-44h]
  __int64 v55; // [esp+28h] [ebp-40h]
  int v56; // [esp+30h] [ebp-38h]
  _BYTE *v57; // [esp+34h] [ebp-34h]
  int v58; // [esp+38h] [ebp-30h]
  int v59; // [esp+3Ch] [ebp-2Ch]
  int v60; // [esp+40h] [ebp-28h]
  char *v61; // [esp+44h] [ebp-24h]
  unsigned int v62; // [esp+48h] [ebp-20h]
  int v63; // [esp+4Ch] [ebp-1Ch]

  v61 = a1;
  if ( (dl_debug_mask & 1) != 0 )
    dl_debug_printf(" search cache=%s\n", "/etc/ld.so.cache");
  v1 = cache;
  if ( cache )
  {
    if ( cache == -1 )
      return 0;
    v2 = cachesize;
    goto LABEL_6;
  }
  whole_file = dl_sysdep_read_whole_file((int)"/etc/ld.so.cache", &cachesize, 1);
  v1 = whole_file;
  if ( whole_file != -1 )
  {
    v2 = cachesize;
    if ( (unsigned int)cachesize > 0x10 )
    {
      if ( !j_memcmp(whole_file, "ld.so-1.7.0", 11) )
      {
        v26 = *(_DWORD *)(v1 + 12);
        cache = v1;
        v27 = 12 * v26 + 16;
        cache_new = v1 + v27;
        if ( v2 < v27 + 48 || j_memcmp(v1 + v27, "glibc-ld.so.cache1.1", 20) )
        {
          cache_new = -1;
          goto LABEL_56;
        }
LABEL_6:
        v60 = cache_new;
        if ( cache_new != -1 )
        {
LABEL_7:
          v3 = v2 + v1;
          v4 = dl_platform;
          v62 = v3 - v60;
          if ( dl_platform )
          {
            v5 = "i386";
            v6 = 0;
            while ( j_strcmp(v4, v5) )
            {
              ++v6;
              v5 += 5;
              if ( v6 == 4 )
                goto LABEL_11;
            }
            v50 = ((((_BYTE)v6 + 48) & 0x20) == 0) << (v6 + 48);
            v51 = ((((_BYTE)v6 + 48) & 0x20) != 0) << (v6 + 48);
          }
          else
          {
LABEL_11:
            v50 = -1;
            v51 = -1;
          }
          v47 = access((int)"/etc/ld.so.nohwcap", 0) == 0;
          v55 = dl_hwcap;
          v63 = cache_new;
          v52 = dl_hwcap_mask;
          v59 = *(_DWORD *)(cache_new + 20);
          v7 = v59 - 1;
          if ( v59 - 1 < 0 )
            return 0;
          v8 = v7 >> 1;
          v9 = *(_DWORD *)(cache_new + 24 * (v7 >> 1) + 52);
          if ( v62 <= v9 )
            return 0;
          v10 = 0;
          while ( 1 )
          {
            v11 = dl_cache_libcmp(v61, (char *)(v60 + v9));
            if ( !v11 )
              break;
            if ( v11 >= 0 )
            {
              v7 = v8 - 1;
              if ( v10 > v8 - 1 )
                return 0;
            }
            else
            {
              v10 = v8 + 1;
              if ( v8 + 1 > v7 )
                return 0;
            }
            v8 = (v10 + v7) / 2;
            v9 = *(_DWORD *)(v63 + 24 * v8 + 52);
            if ( v62 <= v9 )
              return 0;
          }
          v58 = v7;
          v59 = v8;
          if ( v8 <= 0 || (v13 = v8 - 1, v14 = *(_DWORD *)(v63 + 24 * v13 + 52), v14 >= v62) )
          {
            v13 = v59;
          }
          else
          {
            v15 = v63 + 24 * v59;
            while ( !dl_cache_libcmp(v61, (char *)(v60 + v14)) )
            {
              if ( !v13 )
                goto LABEL_30;
              v15 -= 24;
              v14 = *(_DWORD *)(v15 + 28);
              if ( v62 <= v14 )
                goto LABEL_30;
              --v13;
            }
            ++v13;
          }
LABEL_30:
          v16 = v63;
          v57 = 0;
          v63 = v13;
          v56 = dl_correct_cache_id;
          v46 = dl_osversion;
          v49 = HIDWORD(v52) & HIDWORD(v55) | 0x800F0000;
          v17 = (_DWORD *)(v16 + 24 * v13);
          v48 = v52 & v55;
          do
          {
            if ( v63 > v59 )
            {
              v18 = v17[13];
              if ( v62 <= v18 || dl_cache_libcmp(v61, (char *)(v60 + v18)) )
                break;
            }
            v19 = v17[12];
            if ( (v19 & 0xFFFFFFFD) == 1 )
            {
              LODWORD(v55) = v17[14];
              if ( v62 > (unsigned int)v55 && (!v57 || v19 == v56) )
              {
                v20 = v17[17];
                LODWORD(v52) = v17[16];
                HIDWORD(v52) = v20;
                v53 = ~v48;
                LODWORD(v21) = v52 & ~v48;
                v54 = ~v49;
                HIDWORD(v21) = v20 & ~v49;
                if ( !v21 && (!v46 || v46 >= v17[15]) && (!v52 || !v47) )
                {
                  LODWORD(v52) = 0;
                  v22 = HIDWORD(v52) & 0xF0000 ^ v51;
                  HIDWORD(v52) &= 0xF0000u;
                  if ( !(v22 | v50) || !v52 )
                  {
                    v57 = (_BYTE *)(v60 + v55);
                    if ( v19 == v56 )
                      break;
                  }
                }
              }
            }
            ++v63;
            v17 += 6;
          }
          while ( v63 <= v58 );
LABEL_47:
          if ( (dl_debug_mask & 1) != 0 )
          {
            if ( v57 )
            {
              dl_debug_printf("  trying file=%s\n", v57);
              goto LABEL_49;
            }
          }
          else if ( v57 )
          {
LABEL_49:
            v23 = strlen(v57);
            v24 = alloca(v23 + 16);
            memcpy(&v46, v57, v23 + 1);
            return strdup(&v46);
          }
          return 0;
        }
LABEL_56:
        v28 = *(_DWORD *)(v1 + 12);
        v29 = 12 * v28 + 16;
        v30 = v2 - v29;
        v31 = v28 - 1;
        v62 = v30;
        v63 = v1 + v29;
        if ( v31 < 0 )
          return 0;
        v32 = v31 >> 1;
        v33 = *(_DWORD *)(v1 + 12 * (v31 >> 1) + 20);
        if ( v30 <= v33 )
          return 0;
        v60 = v1;
        v34 = 0;
        v35 = v31;
        while ( 1 )
        {
          v36 = dl_cache_libcmp(v61, (char *)(v63 + v33));
          if ( !v36 )
            break;
          if ( v36 >= 0 )
            v35 = v32 - 1;
          else
            v34 = v32 + 1;
          if ( v35 >= v34 )
          {
            v32 = (v35 + v34) / 2;
            v33 = *(_DWORD *)(v60 + 12 * v32 + 20);
            if ( v62 > v33 )
              continue;
          }
          return 0;
        }
        v37 = v60;
        v59 = v35;
        if ( v32 <= 0 || (v38 = v32 - 1, v39 = *(_DWORD *)(v60 + 12 * (v32 - 1) + 20), v62 <= v39) )
        {
          v38 = v32;
        }
        else
        {
          v58 = v60;
          v60 = v32;
          v40 = v37 + 12 * v32;
          while ( 1 )
          {
            if ( dl_cache_libcmp(v61, (char *)(v63 + v39)) )
            {
              v37 = v58;
              v32 = v60;
              ++v38;
              goto LABEL_74;
            }
            if ( !v38 )
              break;
            v40 -= 12;
            v39 = *(_DWORD *)(v40 + 8);
            if ( v62 <= v39 )
              break;
            --v38;
          }
          v32 = v60;
          v37 = v58;
        }
LABEL_74:
        v60 = v32;
        v41 = v38;
        v57 = 0;
        v58 = dl_correct_cache_id;
        v42 = (_DWORD *)(v37 + 12 * v38);
        while ( 1 )
        {
          if ( v41 > v60 )
          {
            v43 = v42[5];
            if ( v62 <= v43 || dl_cache_libcmp(v61, (char *)(v63 + v43)) )
              goto LABEL_47;
          }
          v44 = v42[4];
          if ( (v44 & 0xFFFFFFFD) == 1 )
          {
            v45 = v42[6];
            if ( v62 > v45 )
            {
              if ( v57 )
              {
                if ( v44 == v58 )
                {
                  v57 = (_BYTE *)(v63 + v45);
                  goto LABEL_47;
                }
              }
              else
              {
                v57 = (_BYTE *)(v63 + v45);
                if ( v44 == v58 )
                  goto LABEL_47;
              }
            }
          }
          ++v41;
          v42 += 3;
          if ( v41 > v59 )
            goto LABEL_47;
        }
      }
      if ( v2 > 0x30 && !j_memcmp(v1, "glibc-ld.so.cache1.1", 20) )
      {
        cache_new = v1;
        cache = v1;
        v60 = v1;
        goto LABEL_7;
      }
    }
    munmap(v1, v2);
  }
  cache = -1;
  return 0;
}
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80EBA00: using guessed type int dl_correct_cache_id;
// 80EC540: using guessed type __int64 dl_hwcap_mask;
// 80EC550: using guessed type __int64 dl_hwcap;
// 80EC798: using guessed type int cachesize;
// 80EC79C: using guessed type int cache_new;
// 80EC7A0: using guessed type int cache;
// 80ECC60: using guessed type int dl_debug_mask;
// 80ECC80: using guessed type int dl_platform;
// 80ECCC0: using guessed type int dl_osversion;
// 809CE30: using guessed type unsigned int var_68;

//----- (0809D470) --------------------------------------------------------
unsigned int dl_unload_cache()
{
  unsigned int result; // eax

  result = cache;
  if ( (unsigned int)(cache - 1) <= 0xFFFFFFFD )
  {
    result = munmap(cache, cachesize);
    cache = 0;
  }
  return result;
}
// 80EC798: using guessed type int cachesize;
// 80EC7A0: using guessed type int cache;

//----- (0809D4A0) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_early_return_p@<eax>(
        int (__usercall **a1)@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)@<eax>,
        int (__usercall *a2)@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)@<edx>)
{
  if ( *a1 != a2 )
    return 1;
  *a1 = dl_tlsdesc_resolve_hold;
  return 0;
}

//----- (0809D510) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_abs_plus_addend_fixup@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        long double a4@<st0>)
{
  int v6; // esi
  int result; // eax
  int v8; // eax
  int v9; // esi
  char *retaddr; // [esp+Ch] [ebp+0h]

  v6 = *(_DWORD *)(a1 + 4);
  result = dl_tlsdesc_resolve_early_return_p(
             (int (__usercall **)@<eax>(char **@<eax>, int@<edx>, int@<ecx>))a1,
             (int (__usercall *)@<eax>(char **@<eax>, int@<edx>, int@<ecx>))&retaddr[-a3]);
  if ( !result )
  {
    v8 = *(_DWORD *)(a2 + 576);
    if ( (unsigned int)(v8 + 1) <= 1 )
    {
      dl_allocate_static_tls(a2, a4);
      v8 = *(_DWORD *)(a2 + 576);
    }
    v9 = v6 - v8;
    result = 0;
    *(_DWORD *)(a1 + 4) = v9;
    *(_DWORD *)a1 = dl_tlsdesc_return;
  }
  return result;
}

//----- (0809D570) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_rel_fixup@<eax>(
        int a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        long double a4@<st0>)
{
  int v6; // edi
  int result; // eax
  int v8; // ebp
  int v9; // edx
  unsigned __int8 v10; // cl
  int v11; // eax
  int v12; // edi
  int v13; // ecx
  int v14; // eax
  int v15; // [esp+Ch] [ebp-30h]
  int v16[8]; // [esp+1Ch] [ebp-20h] BYREF
  char *retaddr; // [esp+3Ch] [ebp+0h]

  v6 = *(_DWORD *)(a1 + 4);
  result = dl_tlsdesc_resolve_early_return_p(
             (int (__usercall **)@<eax>(char **@<eax>, int@<edx>, int@<ecx>))a1,
             (int (__usercall *)@<eax>(char **@<eax>, int@<edx>, int@<ecx>))&retaddr[-a3]);
  if ( !result )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(a2 + 52) + 4);
    v15 = *(_DWORD *)(v6 + 4) >> 8;
    v9 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 4) + 16 * v15;
    v10 = *(_BYTE *)(v9 + 12);
    v16[0] = v9;
    if ( !(v10 >> 4) || (*(_BYTE *)(v9 + 13) & 3) != 0 )
      goto LABEL_3;
    v12 = *(_DWORD *)(a2 + 228);
    if ( v12 )
    {
      v13 = *(_DWORD *)(a2 + 368) + 16 * (*(_WORD *)(*(_DWORD *)(v12 + 4) + 2 * v15) & 0x7FFF);
      if ( !*(_DWORD *)(v13 + 4) )
        v13 = 0;
    }
    else
    {
      v13 = 0;
    }
    v14 = dl_lookup_symbol_x(
            (unsigned __int8 *)(v8 + *(_DWORD *)v9),
            a2,
            v16,
            a4,
            *(int ***)(a2 + 460),
            (const char **)v13,
            1,
            1,
            0);
    v9 = v16[0];
    a2 = v14;
    if ( v16[0] )
    {
LABEL_3:
      v11 = *(_DWORD *)(a2 + 576);
      if ( (unsigned int)(v11 + 1) <= 1 )
      {
        dl_allocate_static_tls(a2, a4);
        v9 = v16[0];
        v11 = *(_DWORD *)(a2 + 576);
      }
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(v9 + 4) - v11;
      *(_DWORD *)a1 = dl_tlsdesc_return;
    }
    else
    {
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = dl_tlsdesc_undefweak;
    }
    return 0;
  }
  return result;
}
// 809D570: using guessed type int var_20[8];

//----- (0809D690) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_rela_fixup@<eax>(
        int a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        long double a4@<st0>)
{
  int v6; // edi
  int result; // eax
  int v8; // edx
  unsigned __int8 v9; // cl
  int v10; // ecx
  int v11; // ebp
  int v12; // ecx
  int v13; // eax
  int v14; // [esp+8h] [ebp-34h]
  int v15; // [esp+Ch] [ebp-30h]
  int v16[8]; // [esp+1Ch] [ebp-20h] BYREF
  char *retaddr; // [esp+3Ch] [ebp+0h]

  v6 = *(_DWORD *)(a1 + 4);
  result = dl_tlsdesc_resolve_early_return_p(
             (int (__usercall **)@<eax>(char **@<eax>, int@<edx>, int@<ecx>))a1,
             (int (__usercall *)@<eax>(char **@<eax>, int@<edx>, int@<ecx>))&retaddr[-a3]);
  if ( !result )
  {
    v14 = *(_DWORD *)(*(_DWORD *)(a2 + 52) + 4);
    v15 = *(_DWORD *)(v6 + 4) >> 8;
    v8 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 4) + 16 * v15;
    v9 = *(_BYTE *)(v8 + 12);
    v16[0] = v8;
    if ( !(v9 >> 4) || (*(_BYTE *)(v8 + 13) & 3) != 0 )
      goto LABEL_3;
    v11 = *(_DWORD *)(a2 + 228);
    if ( v11 )
    {
      v12 = *(_DWORD *)(a2 + 368) + 16 * (*(_WORD *)(*(_DWORD *)(v11 + 4) + 2 * v15) & 0x7FFF);
      if ( !*(_DWORD *)(v12 + 4) )
        v12 = 0;
    }
    else
    {
      v12 = 0;
    }
    v13 = dl_lookup_symbol_x(
            (unsigned __int8 *)(*(_DWORD *)v8 + v14),
            a2,
            v16,
            a4,
            *(int ***)(a2 + 460),
            (const char **)v12,
            1,
            1,
            0);
    v8 = v16[0];
    a2 = v13;
    if ( v16[0] )
    {
LABEL_3:
      v10 = *(_DWORD *)(a2 + 576);
      if ( (unsigned int)(v10 + 1) <= 1 )
      {
        dl_allocate_static_tls(a2, a4);
        v8 = v16[0];
        v10 = *(_DWORD *)(a2 + 576);
      }
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(v6 + 8) + *(_DWORD *)(v8 + 4) - v10;
      *(_DWORD *)a1 = dl_tlsdesc_return;
    }
    else
    {
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)a1 = dl_tlsdesc_undefweak;
    }
    return 0;
  }
  return result;
}
// 809D690: using guessed type int var_20[8];

//----- (0809D7C0) --------------------------------------------------------
char *__usercall dl_tlsdesc_resolve_hold_fixup@<eax>(char **a1@<eax>, int a2@<ecx>)
{
  char *v2; // edx
  char *result; // eax
  char *retaddr; // [esp+Ch] [ebp+0h]

  v2 = *a1;
  result = &retaddr[-a2];
  if ( v2 == &retaddr[-a2] )
    return 0;
  return result;
}

//----- (0809D810) --------------------------------------------------------
unsigned int __usercall dl_unmap@<eax>(int a1@<eax>)
{
  return munmap(*(_DWORD *)(a1 + 428), *(_DWORD *)(a1 + 432) - *(_DWORD *)(a1 + 428));
}

//----- (0809D830) --------------------------------------------------------
int __usercall dl_tlsdesc_return@<eax>(int a1@<eax>)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (0809D840) --------------------------------------------------------
unsigned int __usercall dl_tlsdesc_undefweak@<eax>(int a1@<eax>)
{
  return *(_DWORD *)(a1 + 4) - __readgsdword(0);
}

//----- (0809D850) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_abs_plus_addend@<eax>(
        int (__fastcall **a1)(int, int)@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        long double a5@<st0>)
{
  dl_tlsdesc_resolve_abs_plus_addend_fixup((int)a1, *(_DWORD *)(a4 + 4), 16, a5);
  return (*a1)(a3, a2);
}

//----- (0809D870) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_rel@<eax>(
        int (__fastcall **a1)(int, int)@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        long double a5@<st0>)
{
  dl_tlsdesc_resolve_rel_fixup((int)a1, *(_DWORD *)(a4 + 4), 16, a5);
  return (*a1)(a3, a2);
}

//----- (0809D890) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_rela@<eax>(
        int (__fastcall **a1)(int, int)@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        long double a5@<st0>)
{
  dl_tlsdesc_resolve_rela_fixup((int)a1, *(_DWORD *)(a4 + 4), 16, a5);
  return (*a1)(a3, a2);
}

//----- (0809D8B0) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_hold@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  dl_tlsdesc_resolve_hold_fixup(a1, 16);
  return ((int (__fastcall *)(int, int))*a1)(a3, a2);
}

//----- (0809D8D0) --------------------------------------------------------
void __cdecl dl_mcount_wrapper(int a1)
{
  int retaddr; // [esp+14h] [ebp+0h]

  dl_mcount(retaddr, a1);
}

//----- (0809D8F0) --------------------------------------------------------
void __cdecl dl_mcount_wrapper_check(int a1)
{
  int retaddr; // [esp+0h] [ebp+0h]

  if ( dl_profile_map )
    dl_mcount(retaddr, a1);
}
// 80ECCB4: using guessed type int dl_profile_map;

//----- (0809D910) --------------------------------------------------------
int __usercall do_dlopen@<eax>(int a1@<edi>, long double a2@<st0>, int a3)
{
  int result; // eax

  result = dl_open(a1, a2, *(_BYTE **)a3, *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), -2, _libc_argc, _libc_argv, environ);
  *(_DWORD *)(a3 + 12) = result;
  return result;
}
// 80EC524: using guessed type int environ;
// 80ECCCC: using guessed type int _libc_argc;
// 80ECCD0: using guessed type int _libc_argv;

//----- (0809D950) --------------------------------------------------------
int __usercall dlerror_run@<eax>(void (__cdecl *a1)(int)@<eax>, int a2@<edx>, int a3@<ebp>, int a4@<edi>, int a5@<esi>)
{
  int result; // eax
  int v6; // [esp+14h] [ebp-20h]
  char v7; // [esp+1Fh] [ebp-15h] BYREF
  int v8; // [esp+20h] [ebp-14h] BYREF
  int v9[4]; // [esp+24h] [ebp-10h] BYREF

  v9[0] = 0;
  result = dl_catch_error(&v8, v9, &v7, a3, a4, a5, a1, a2);
  if ( !result )
  {
    if ( !v9[0] )
      return result;
    result = 1;
  }
  if ( v7 )
  {
    v6 = result;
    free(v9[0]);
    return v6;
  }
  return result;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 809D950: using guessed type int var_10[4];

//----- (0809D9B0) --------------------------------------------------------
int __usercall _libc_dlsym@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5)
{
  int v5; // eax
  int v7[2]; // [esp+0h] [ebp-1Ch] BYREF
  int *v8; // [esp+8h] [ebp-14h]
  int v9; // [esp+Ch] [ebp-10h]

  v7[0] = a4;
  v7[1] = a5;
  if ( dlerror_run((void (__cdecl *)(int))do_dlsym, (int)v7, a1, a2, a3) )
    return 0;
  if ( v8 )
    v5 = *v8;
  else
    v5 = 0;
  return *(_DWORD *)(v9 + 4) + v5;
}

//----- (0809DA00) --------------------------------------------------------
int __usercall _libc_dlclose@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4)
{
  return dlerror_run((void (__cdecl *)(int))do_dlclose, a4, a1, a2, a3);
}
// 809DAB0: using guessed type int do_dlclose();

//----- (0809DA10) --------------------------------------------------------
int __usercall do_dlsym_private@<eax>(long double a1@<st0>, int a2)
{
  int result; // eax
  const char *v3[7]; // [esp+Ch] [ebp-1Ch] BYREF

  v3[0] = "GLIBC_PRIVATE";
  v3[2] = (const char *)1;
  v3[1] = (const char *)157536133;
  v3[3] = 0;
  *(_DWORD *)(a2 + 12) = 0;
  result = dl_lookup_symbol_x(
             *(unsigned __int8 **)(a2 + 4),
             *(_DWORD *)a2,
             (int *)(a2 + 12),
             a1,
             *(int ***)(*(_DWORD *)a2 + 460),
             v3,
             0,
             0,
             0);
  *(_DWORD *)(a2 + 8) = result;
  return result;
}

//----- (0809DA70) --------------------------------------------------------
int __usercall do_dlsym@<eax>(long double a1@<st0>, _DWORD *a2)
{
  unsigned int v2; // edx
  unsigned __int8 *v3; // eax
  int result; // eax

  v2 = *a2;
  v3 = (unsigned __int8 *)a2[1];
  a2[3] = 0;
  result = dl_lookup_symbol_x(v3, v2, a2 + 3, a1, (int **)(v2 + 464), 0, 0, 2, 0);
  a2[2] = result;
  return result;
}

//----- (0809DAC0) --------------------------------------------------------
int __usercall _libc_dlsym_private@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5)
{
  int v5; // eax
  int v7[2]; // [esp+0h] [ebp-1Ch] BYREF
  int *v8; // [esp+8h] [ebp-14h]
  int v9; // [esp+Ch] [ebp-10h]

  v7[0] = a4;
  v7[1] = a5;
  if ( dlerror_run((void (__cdecl *)(int))do_dlsym_private, (int)v7, a1, a2, a3) )
    return 0;
  if ( v8 )
    v5 = *v8;
  else
    v5 = 0;
  return *(_DWORD *)(v9 + 4) + v5;
}

//----- (0809DB10) --------------------------------------------------------
int __usercall _libc_dlopen_mode@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5)
{
  int v5; // eax
  int v6; // edx
  _DWORD *v7; // eax
  int v9[3]; // [esp+0h] [ebp-1Ch] BYREF
  int v10; // [esp+Ch] [ebp-10h]
  int retaddr; // [esp+1Ch] [ebp+0h]

  v9[0] = a4;
  v9[1] = a5;
  v9[2] = retaddr;
  v5 = dlerror_run((void (__cdecl *)(int))do_dlopen, (int)v9, a1, a2, a3);
  v6 = 0;
  if ( !v5 )
  {
    v7 = (_DWORD *)_libc_dlsym_private(a1, a2, a3, v10, (int)"_dl_open_hook");
    if ( v7 )
      *v7 = dl_open_hook;
    _libc_register_dlfcn_hook(a1, a2, a3, v10);
    return v10;
  }
  return v6;
}
// 80EBF24: using guessed type int (__cdecl *dl_open_hook[2])(int, int);

//----- (0809DB80) --------------------------------------------------------
_DWORD *__usercall _libc_register_dl_open_hook@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4)
{
  _DWORD *result; // eax

  result = (_DWORD *)_libc_dlsym_private(a1, a2, a3, a4, (int)"_dl_open_hook");
  if ( result )
    *result = dl_open_hook;
  return result;
}
// 80EBF24: using guessed type int (__cdecl *dl_open_hook[2])(int, int);

//----- (0809DBB0) --------------------------------------------------------
unsigned int dl_initial_error_catch_tsd()
{
  return __readgsdword(0) - 4;
}

//----- (0809DBC0) --------------------------------------------------------
int __usercall _sigsetjmp@<eax>(int ebx0@<ebx>, int ebp0@<ebp>, int a3@<edi>, int a4@<esi>, int a1, _BOOL4 a2)
{
  _DWORD *v6; // eax
  unsigned int retaddr; // [esp+0h] [ebp+0h]

  v6 = (_DWORD *)a1;
  *(_DWORD *)a1 = ebx0;
  v6[1] = a4;
  v6[2] = a3;
  v6[4] = __ROL4__(__readgsdword(0x18u) ^ (unsigned int)&a1, 9);
  v6[5] = __ROL4__(__readgsdword(0x18u) ^ retaddr, 9);
  v6[3] = ebp0;
  return _sigjmp_save(a1, a2);
}

//----- (0809DC00) --------------------------------------------------------
int __cdecl _sigjmp_save(int a1, _BOOL4 a2)
{
  _BOOL4 v2; // eax

  v2 = a2;
  if ( a2 )
    v2 = sigprocmask(0, 0) == 0;
  *(_DWORD *)(a1 + 24) = v2;
  return 0;
}

//----- (0809DC40) --------------------------------------------------------
void __noreturn _longjmp(struct __jmp_buf_tag env[1], int val)
{
  ((void (*)(void))(__readgsdword(0x18u) ^ __ROR4__(env->__jmpbuf[5], 9)))();
}

//----- (0809DC80) --------------------------------------------------------
int __cdecl _mpn_cmp(int a1, int a2, int a3)
{
  int v3; // eax
  unsigned int v4; // ecx
  unsigned int v5; // edx

  v3 = a3 - 1;
  if ( a3 - 1 < 0 )
    return 0;
  while ( 1 )
  {
    v4 = *(_DWORD *)(a1 + 4 * v3);
    v5 = *(_DWORD *)(a2 + 4 * v3);
    if ( v4 != v5 )
      break;
    if ( --v3 == -1 )
      return 0;
  }
  return v4 <= v5 ? -1 : 1;
}

//----- (0809DCD0) --------------------------------------------------------
int __cdecl _mpn_divrem(int a1, int a2, _DWORD *a3, int a4, unsigned int *a5, int a6)
{
  unsigned int *v6; // edi
  int v7; // esi
  unsigned int v8; // eax
  unsigned int v9; // ebp
  unsigned int *v10; // esi
  unsigned int v11; // ebx
  unsigned int v12; // esi
  unsigned int v13; // ebx
  unsigned int v14; // eax
  unsigned int v15; // ecx
  bool v16; // cf
  unsigned int *v17; // eax
  unsigned int v18; // edx
  unsigned int *v20; // eax
  unsigned int v21; // ebp
  unsigned int v22; // edi
  unsigned __int64 v23; // rcx
  unsigned int v24; // esi
  unsigned int v25; // edi
  int v26; // edx
  int v27; // esi
  unsigned __int64 v28; // rax
  unsigned int v29; // esi
  unsigned int v30; // ecx
  unsigned __int64 v31; // rax
  int v32; // esi
  int v33; // edi
  unsigned __int64 v34; // rt2
  int v35; // esi
  unsigned int v36; // [esp+Ch] [ebp-40h]
  int v37; // [esp+Ch] [ebp-40h]
  int v38; // [esp+10h] [ebp-3Ch]
  unsigned int v39; // [esp+10h] [ebp-3Ch]
  int v40; // [esp+14h] [ebp-38h]
  unsigned int *v41; // [esp+18h] [ebp-34h]
  unsigned int *v42; // [esp+18h] [ebp-34h]
  int v43; // [esp+1Ch] [ebp-30h]
  int v44; // [esp+1Ch] [ebp-30h]
  int v45; // [esp+24h] [ebp-28h]
  int v46; // [esp+28h] [ebp-24h]
  int v47; // [esp+28h] [ebp-24h]
  int v48; // [esp+28h] [ebp-24h]

  switch ( a6 )
  {
    case 1:
      v48 = 0;
      v30 = *a5;
      HIDWORD(v31) = a3[a4 - 1];
      if ( *a5 <= HIDWORD(v31) )
      {
        HIDWORD(v31) -= v30;
        v48 = 1;
      }
      v32 = a4 - 2;
      if ( a4 - 2 >= 0 )
      {
        v33 = a1 + 4 * (v32 + a2);
        do
        {
          LODWORD(v31) = a3[v32--];
          v33 -= 4;
          v34 = v31 % v30;
          LODWORD(v31) = v31 / v30;
          HIDWORD(v31) = v34;
          *(_DWORD *)(v33 + 4) = v31;
        }
        while ( v32 != -1 );
      }
      if ( a2 - 1 >= 0 )
      {
        v35 = a1 + 4 * (a2 - 1);
        do
        {
          v35 -= 4;
          LODWORD(v31) = __PAIR64__(HIDWORD(v31), 0) / v30;
          HIDWORD(v31) = __PAIR64__(HIDWORD(v31), 0) % v30;
          *(_DWORD *)(v35 + 4) = v31;
        }
        while ( a1 - 4 != v35 );
      }
      *a3 = HIDWORD(v31);
      return v48;
    case 2:
      v47 = 0;
      v20 = &a3[a4 - 2];
      v21 = a5[1];
      v22 = *a5;
      HIDWORD(v23) = v20[1];
      v42 = v20;
      v24 = *v20;
      if ( __PAIR64__(v21, v22) <= __PAIR64__(HIDWORD(v23), v24) )
      {
        HIDWORD(v23) = (__PAIR64__(HIDWORD(v23), v24) - __PAIR64__(v21, v22)) >> 32;
        v24 -= v22;
        v47 = 1;
      }
      v37 = a2 + a4 - 3;
      if ( v37 < 0 )
      {
LABEL_34:
        v42[1] = HIDWORD(v23);
        *v42 = v24;
        return v47;
      }
      v39 = *a5;
      v44 = -v22;
      while ( 1 )
      {
        if ( a2 > v37 )
        {
          LODWORD(v23) = 0;
          *v42 = 0;
          if ( v21 != HIDWORD(v23) )
          {
LABEL_29:
            v25 = v39;
            v26 = __PAIR64__(HIDWORD(v23), v24) % v21;
            v27 = __PAIR64__(HIDWORD(v23), v24) / v21;
            HIDWORD(v23) = v26;
            v28 = (unsigned int)v27 * (unsigned __int64)v39;
            goto LABEL_30;
          }
        }
        else
        {
          LODWORD(v23) = *--v42;
          if ( v21 != HIDWORD(v23) )
            goto LABEL_29;
        }
        v16 = __CFADD__(v21, v24);
        v29 = v21 + v24;
        HIDWORD(v23) = v29;
        if ( !v16 )
        {
          v25 = v39;
          v27 = -1;
          HIDWORD(v28) = v39 - (v39 != 0);
          LODWORD(v28) = v44;
          do
          {
LABEL_30:
            if ( v28 <= v23 )
              break;
            --v27;
            v28 -= v25;
            v16 = __CFADD__(v21, HIDWORD(v23));
            HIDWORD(v23) += v21;
          }
          while ( !v16 );
          v39 = v25;
          *(_DWORD *)(a1 + 4 * v37) = v27;
          HIDWORD(v23) = (v23 - v28) >> 32;
          v24 = v23 - v28;
          goto LABEL_33;
        }
        HIDWORD(v23) = v29 - v39;
        HIDWORD(v23) = (v39 + v23) >> 32;
        v24 = v39 + v23;
        *(_DWORD *)(a1 + 4 * v37) = -1;
LABEL_33:
        if ( --v37 == -1 )
          goto LABEL_34;
      }
    case 0:
      return 1 / 0;
  }
  v46 = 0;
  v6 = &a3[a4 - a6];
  v7 = a6 + 0x3FFFFFFF;
  v8 = a5[v7];
  v45 = v7 * 4;
  v36 = v8;
  v38 = v7 * 4 - 4;
  v9 = a5[v7 - 1];
  v10 = &v6[v7];
  v11 = *v10;
  if ( v8 <= *v10 && (v8 < *v10 || _mpn_cmp((int)v6, (int)a5, a6 - 1) >= 0) )
  {
    _mpn_sub_n(v6, v6, a5, a6);
    v11 = *v10;
    v46 = 1;
  }
  v40 = a2 + a4 - a6 - 1;
  if ( v40 >= 0 )
  {
    if ( a2 > v40 )
      goto LABEL_19;
LABEL_7:
    v43 = *(unsigned int *)((char *)v6 + v45);
    v41 = (unsigned int *)((char *)v6 + v45 - 4);
    for ( --v6; ; *v6 = 0 )
    {
      v12 = -1;
      if ( v36 != v11 )
      {
        v12 = __PAIR64__(v11, *v41) / v36;
        v13 = __PAIR64__(v11, *v41) % v36;
        v14 = v12 * v9;
        v15 = (v12 * (unsigned __int64)v9) >> 32;
        while ( v15 > v13 || v15 == v13 && v14 > *(unsigned int *)((char *)v6 + v38) )
        {
          --v12;
          v16 = __CFADD__(v36, v13);
          v13 += v36;
          if ( v16 )
            break;
          v15 = (__PAIR64__(v15, v14) - v9) >> 32;
          v14 -= v9;
        }
      }
      if ( v43 != _mpn_submul_1((int)v6, (int)a5, a6, v12) )
      {
        --v12;
        _mpn_add_n(v6, v6, a5, a6);
      }
      *(_DWORD *)(a1 + 4 * v40--) = v12;
      v11 = *v41;
      if ( v40 == -1 )
        break;
      if ( a2 <= v40 )
        goto LABEL_7;
LABEL_19:
      v41 = (unsigned int *)((char *)v6 + v45);
      v43 = *(unsigned int *)((char *)v6 + v45);
      v17 = (unsigned int *)((char *)v6 + v45 + 4);
      if ( a6 > 0 )
      {
        do
        {
          v18 = *--v17;
          v17[1] = v18;
        }
        while ( v6 != v17 );
      }
    }
  }
  return v46;
}

//----- (0809E0B0) --------------------------------------------------------
int __cdecl _mpn_lshift(_DWORD *a1, int a2, int a3, char a4)
{
  int v4; // esi
  unsigned int v5; // ebx
  int result; // eax
  int v7; // edx
  unsigned int v8; // eax
  int v9; // [esp-4h] [ebp-10h]

  v4 = a2 - 4;
  v5 = *(_DWORD *)(a2 - 4 + 4 * a3);
  result = (unsigned __int64)v5 << a4 >> 32;
  v7 = a3 - 1;
  if ( a3 == 1 )
  {
    *a1 = v5 << a4;
  }
  else
  {
    v9 = (unsigned __int64)*(unsigned int *)(a2 - 4 + 4 * a3) << a4 >> 32;
    if ( (v7 & 1) != 0 )
      goto LABEL_5;
    v8 = *(_DWORD *)(a2 - 4 + 4 * a3);
    do
    {
      v5 = *(_DWORD *)(v4 + 4 * v7);
      a1[v7--] = __PAIR64__(v8, v5) << a4 >> 32;
LABEL_5:
      v8 = *(_DWORD *)(v4 + 4 * v7);
      a1[v7--] = __PAIR64__(v5, v8) << a4 >> 32;
    }
    while ( v7 );
    *a1 = v8 << a4;
    return v9;
  }
  return result;
}

//----- (0809E110) --------------------------------------------------------
int __cdecl _mpn_rshift(int a1, unsigned int *a2, int a3, char a4)
{
  unsigned int *v4; // edi
  unsigned int *v5; // esi
  unsigned int v6; // ebx
  int result; // eax
  unsigned __int64 v8; // rt0
  int v9; // edx
  unsigned int v10; // eax
  int v11; // [esp-4h] [ebp-10h]

  v4 = (unsigned int *)(a1 + 4 * a3 - 4);
  v5 = &a2[a3];
  v6 = *a2;
  LODWORD(v8) = 0;
  HIDWORD(v8) = *a2;
  result = v8 >> a4;
  v9 = 1 - a3;
  if ( a3 == 1 )
  {
    *v4 = v6 >> a4;
  }
  else
  {
    v11 = result;
    if ( (v9 & 1) != 0 )
      goto LABEL_5;
    v10 = *a2;
    do
    {
      v6 = v5[v9];
      v4[v9++] = __PAIR64__(v6, v10) >> a4;
LABEL_5:
      v10 = v5[v9];
      v4[v9++] = __PAIR64__(v10, v6) >> a4;
    }
    while ( v9 );
    *v4 = v10 >> a4;
    return v11;
  }
  return result;
}

//----- (0809E170) --------------------------------------------------------
int __cdecl _mpn_mul(_DWORD *a1, unsigned int *a2, int a3, unsigned int *a4, int a5)
{
  int result; // eax
  int v6; // esi
  unsigned int *v7; // edi
  unsigned int *v8; // ebx
  int v9; // esi
  void *v10; // esp
  int v11; // edx
  _DWORD *v12; // eax
  int i; // eax
  _DWORD *v14; // esi
  _BOOL4 v15; // ebx
  _DWORD *v16; // eax
  _DWORD *v17; // esi
  bool v18; // cf
  _DWORD *v19; // ecx
  _DWORD *v20; // ebx
  int v21; // edx
  int v22; // eax
  int v23; // edx
  int v24; // eax
  void *v25; // esp
  _DWORD *v26; // ebx
  _DWORD *v27; // esi
  int v28; // esi
  _BOOL4 v29; // eax
  _DWORD *v30; // ecx
  int v31; // edx
  int v32; // esi
  int v33; // eax
  bool v34; // cc
  int v35; // eax
  _DWORD *v36; // [esp-10h] [ebp-58h]
  _DWORD *v37; // [esp-10h] [ebp-58h]
  _DWORD *v38; // [esp-Ch] [ebp-54h]
  _DWORD *v39; // [esp-Ch] [ebp-54h]
  _DWORD v40[3]; // [esp+0h] [ebp-48h] BYREF
  _DWORD *v41; // [esp+Ch] [ebp-3Ch]
  int v42; // [esp+10h] [ebp-38h]
  _DWORD *v43; // [esp+14h] [ebp-34h]
  _DWORD *v44; // [esp+18h] [ebp-30h]
  _DWORD *v45; // [esp+1Ch] [ebp-2Ch]
  _DWORD *v46; // [esp+20h] [ebp-28h]
  int v47; // [esp+24h] [ebp-24h]
  unsigned int *v48; // [esp+28h] [ebp-20h]
  char *v49; // [esp+2Ch] [ebp-1Ch]

  if ( a5 > 31 )
  {
    v9 = 16 * ((unsigned int)(8 * a5 + 30) >> 4);
    v10 = alloca(v9);
    v44 = v40;
    _mpn_impn_mul_n(a1, a2, a4, a5, v40);
    v49 = (char *)(4 * a5);
    v11 = a3 - a5;
    v45 = &a1[a5];
    v48 = &a2[a5];
    if ( a5 <= a3 - a5 )
    {
      v25 = alloca(v9);
      v47 = v11 - a5;
      v46 = v40;
      v26 = (_DWORD *)((char *)v45 + (_DWORD)v49);
      v41 = (_DWORD *)((char *)v40 + (_DWORD)v49);
      v42 = (int)&v40[1] + (_DWORD)v49;
      do
      {
        v27 = (_DWORD *)((char *)v26 - v49);
        _mpn_impn_mul_n(v46, v48, a4, a5, v44);
        v39 = v27;
        v37 = v27;
        v28 = a5;
        v29 = _mpn_add_n(v37, v39, v46, a5);
        v45 = v26;
        v30 = v26 + 1;
        v18 = __CFADD__(*v41, v29);
        *v26 = *v41 + v29;
        v31 = v42;
        if ( v18 )
        {
          while ( --v28 )
          {
            v31 += 4;
            ++v30;
            v35 = *(_DWORD *)(v31 - 4) + 1;
            *(v30 - 1) = v35;
            if ( v35 )
              goto LABEL_34;
          }
        }
        else
        {
LABEL_34:
          if ( v30 != (_DWORD *)v31 && v28 > 1 )
          {
            v32 = v28 - 1;
            v33 = 0;
            v43 = v26;
            do
            {
              v30[v33] = *(_DWORD *)(v31 + 4 * v33);
              ++v33;
            }
            while ( v33 != v32 );
            v26 = v43;
          }
        }
        v48 = (unsigned int *)((char *)v48 + (_DWORD)v49);
        v11 = v47;
        v26 = (_DWORD *)((char *)v26 + (_DWORD)v49);
        v34 = v47 < a5;
        v47 -= a5;
      }
      while ( !v34 );
    }
    if ( v11 )
    {
      v14 = v44;
      v47 = v11;
      _mpn_mul(v44, a4, a5, v48, v11);
      v15 = _mpn_add_n(v45, v45, v14, a5);
      v16 = (_DWORD *)((char *)v14 + (_DWORD)v49);
      v17 = (_DWORD *)((char *)v45 + (_DWORD)v49);
      v18 = __CFADD__(*v16, v15);
      v19 = v16 + 1;
      *v17 = *v16 + v15;
      v20 = v17 + 1;
      v21 = v47;
      if ( v18 )
      {
        while ( --v21 )
        {
          ++v19;
          ++v20;
          v22 = *(v19 - 1) + 1;
          *(v20 - 1) = v22;
          if ( v22 )
            goto LABEL_27;
        }
      }
      else
      {
LABEL_27:
        if ( v20 != v19 && v21 > 1 )
        {
          v23 = v21 - 1;
          v24 = 0;
          do
          {
            v20[v24] = v19[v24];
            ++v24;
          }
          while ( v23 != v24 );
        }
      }
    }
    return a1[a3 + a5 - 1];
  }
  result = 0;
  if ( !a5 )
    return result;
  if ( *a4 > 1 )
  {
    result = _mpn_mul_1((int)a1, (int)a2, a3, *a4);
    goto LABEL_5;
  }
  if ( *a4 != 1 )
  {
    v12 = a1;
    if ( a3 > 0 )
    {
      do
        *v12++ = 0;
      while ( &a1[a3] != v12 );
    }
    goto LABEL_19;
  }
  if ( a3 <= 0 )
  {
LABEL_19:
    result = 0;
    goto LABEL_5;
  }
  for ( i = 0; i != a3; ++i )
    a1[i] = a2[i];
  result = 0;
LABEL_5:
  v6 = (int)(a1 + 1);
  v48 = (unsigned int *)(4 * a3);
  a1[a3] = result;
  if ( a5 > 1 )
  {
    v49 = (char *)&a1[a5];
    v7 = a4 + 1;
    v8 = v48;
    do
    {
      while ( *v7 > 1 )
      {
        result = _mpn_addmul_1(v6, (int)a2, a3, *v7);
LABEL_8:
        *(unsigned int *)((char *)v8 + v6) = result;
        ++v7;
        v6 += 4;
        if ( (char *)v6 == v49 )
          return result;
      }
      result = 0;
      if ( *v7 != 1 )
        goto LABEL_8;
      ++v7;
      v38 = (_DWORD *)v6;
      v36 = (_DWORD *)v6;
      v6 += 4;
      result = _mpn_add_n(v36, v38, a2, a3);
      *(unsigned int *)((char *)v8 + v6 - 4) = result;
    }
    while ( (char *)v6 != v49 );
  }
  return result;
}

//----- (0809E490) --------------------------------------------------------
int __cdecl _mpn_mul_1(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // ecx
  int v5; // ebp
  unsigned __int64 v6; // rax
  int v7; // edx

  v4 = -a3;
  v5 = 0;
  do
  {
    v6 = a4 * (unsigned __int64)*(unsigned int *)(a2 + 4 * a3 + 4 * v4);
    *(_DWORD *)(a1 + 4 * a3 + 4 * v4) = v5 + v6;
    v7 = __CFADD__(v5, (_DWORD)v6) + HIDWORD(v6);
    v5 = v7;
    ++v4;
  }
  while ( v4 );
  return v7;
}

//----- (0809E4D0) --------------------------------------------------------
int __cdecl _mpn_impn_mul_n_basecase(int a1, _DWORD *a2, unsigned int *a3, int a4)
{
  int result; // eax
  int v5; // ebx
  int v6; // esi
  unsigned int v7; // eax
  bool v8; // zf
  _DWORD *v9; // eax
  int i; // eax
  _DWORD *v11; // [esp-10h] [ebp-2Ch]
  _DWORD *v12; // [esp-Ch] [ebp-28h]

  if ( *a3 > 1 )
  {
    result = _mpn_mul_1(a1, (int)a2, a4, *a3);
    goto LABEL_3;
  }
  if ( *a3 != 1 )
  {
    v9 = (_DWORD *)a1;
    if ( a4 > 0 )
    {
      do
        *v9++ = 0;
      while ( v9 != (_DWORD *)(a1 + 4 * a4) );
    }
    goto LABEL_14;
  }
  if ( a4 <= 0 )
  {
LABEL_14:
    result = 0;
    goto LABEL_3;
  }
  for ( i = 0; i != a4; ++i )
    *(_DWORD *)(a1 + 4 * i) = a2[i];
  result = 0;
LABEL_3:
  *(_DWORD *)(a1 + 4 * a4) = result;
  v5 = a1 + 4;
  v6 = 1;
  if ( a4 > 1 )
  {
    do
    {
      while ( 1 )
      {
        v7 = a3[v6];
        v8 = v7 == 1;
        if ( v7 <= 1 )
          break;
        result = _mpn_addmul_1(v5, (int)a2, a4, a3[v6]);
LABEL_6:
        ++v6;
        *(_DWORD *)(v5 + 4 * a4) = result;
        v5 += 4;
        if ( a4 == v6 )
          return result;
      }
      result = 0;
      if ( !v8 )
        goto LABEL_6;
      ++v6;
      v12 = (_DWORD *)v5;
      v11 = (_DWORD *)v5;
      v5 += 4;
      result = _mpn_add_n(v11, v12, a2, a4);
      *(_DWORD *)(v5 + 4 * a4 - 4) = result;
    }
    while ( a4 != v6 );
  }
  return result;
}

//----- (0809E5D0) --------------------------------------------------------
int __cdecl _mpn_impn_mul_n(_DWORD *a1, unsigned int *a2, unsigned int *a3, int a4, _DWORD *a5)
{
  int v5; // ebx
  int result; // eax
  int v7; // ebx
  unsigned int *v8; // ebp
  int v9; // ebp
  _DWORD *v10; // eax
  _DWORD *v11; // ebp
  int v12; // eax
  _BOOL4 v13; // edx
  int v14; // eax
  int v15; // edx
  int v16; // eax
  int v17; // esi
  _BOOL4 v18; // edx
  unsigned int *v19; // [esp+8h] [ebp-34h]
  _DWORD *v20; // [esp+Ch] [ebp-30h]
  int v21; // [esp+10h] [ebp-2Ch]
  int v22; // [esp+14h] [ebp-28h]
  int v23; // [esp+14h] [ebp-28h]
  unsigned int *v24; // [esp+18h] [ebp-24h]
  _BOOL4 v25; // [esp+18h] [ebp-24h]
  int v26; // [esp+1Ch] [ebp-20h]

  if ( (a4 & 1) != 0 )
  {
    v5 = a4 - 1;
    if ( a4 - 1 <= 31 )
      _mpn_impn_mul_n_basecase((int)a1, a2, a3, a4 - 1);
    else
      _mpn_impn_mul_n(a1, a2, a3, a4 - 1, a5);
    a1[2 * v5] = _mpn_addmul_1((int)&a1[v5], (int)a2, v5, a3[v5]);
    result = _mpn_addmul_1((int)&a1[v5], (int)a3, a4, a2[v5]);
    a1[a4 + v5] = result;
    return result;
  }
  v7 = a4 >> 1;
  v21 = a4 >> 1;
  v24 = &a3[v21];
  v8 = &a2[v21];
  v26 = a4;
  v20 = &a1[a4];
  if ( a4 >> 1 <= 31 )
    _mpn_impn_mul_n_basecase((int)&a1[a4], &a2[a4 >> 1], &a3[a4 >> 1], a4 >> 1);
  else
    _mpn_impn_mul_n(&a1[a4], &a2[a4 >> 1], &a3[a4 >> 1], a4 >> 1, a5);
  if ( _mpn_cmp((int)v8, (int)a2, v7) < 0 )
  {
    _mpn_sub_n(a1, a2, v8, v7);
    v22 = 1;
  }
  else
  {
    _mpn_sub_n(a1, v8, a2, v7);
    v22 = 0;
  }
  v19 = &a1[v21];
  if ( _mpn_cmp((int)v24, (int)a3, v7) < 0 )
  {
    _mpn_sub_n(&a1[v21], a3, v24, v7);
  }
  else
  {
    _mpn_sub_n(&a1[v21], v24, a3, v7);
    v22 ^= 1u;
  }
  if ( v7 > 31 )
  {
    _mpn_impn_mul_n(a5, a1, v19, v7, &a5[v26]);
  }
  else
  {
    _mpn_impn_mul_n_basecase((int)a5, a1, v19, v7);
    if ( v7 <= 0 )
    {
      v9 = v7 + a4;
      goto LABEL_16;
    }
  }
  v9 = v7 + a4;
  v10 = &a1[a4];
  do
  {
    v10[v7 - a4] = *v10;
    ++v10;
  }
  while ( v10 != &a1[v7 + a4] );
LABEL_16:
  v11 = &a1[v9];
  v25 = _mpn_add_n(v20, v20, v11, v7);
  if ( v22 )
    v23 = v25 - _mpn_sub_n(v19, v19, a5, a4);
  else
    v23 = v25 + _mpn_add_n(v19, v19, a5, a4);
  if ( v7 > 31 )
    _mpn_impn_mul_n(a5, a2, a3, v7, &a5[v26]);
  else
    _mpn_impn_mul_n_basecase((int)a5, a2, a3, v7);
  v12 = v23 + _mpn_add_n(v19, v19, a5, a4);
  if ( v12 )
  {
    v13 = __CFADD__(*v11, v12);
    *v11 += v12;
    if ( v13 )
    {
      v14 = 0;
      do
      {
        if ( v7 - 1 == v14 )
          break;
        v15 = v11[v14 + 1] + 1;
        v11[++v14] = v15;
      }
      while ( !v15 );
    }
  }
  v16 = 0;
  if ( v7 > 0 )
  {
    do
    {
      a1[v16] = a5[v16];
      ++v16;
    }
    while ( v7 != v16 );
  }
  result = _mpn_add_n(v19, v19, &a5[v21], v7);
  if ( result )
  {
    v18 = (*v20)++ == -1;
    result = 0;
    if ( v18 && a4 != 1 )
    {
      do
      {
        v17 = v20[result + 1];
        v20[++result] = v17 + 1;
      }
      while ( v17 == -1 && result != a4 - 1 );
    }
  }
  return result;
}

//----- (0809E9A0) --------------------------------------------------------
int __cdecl _mpn_impn_sqr_n_basecase(int a1, unsigned int *a2, int a3)
{
  int result; // eax
  _DWORD *v4; // ebx
  int v5; // esi
  unsigned int v6; // eax
  bool v7; // zf
  _DWORD *v8; // eax
  int i; // eax

  if ( *a2 > 1 )
  {
    result = _mpn_mul_1(a1, (int)a2, a3, *a2);
    goto LABEL_3;
  }
  if ( *a2 != 1 )
  {
    v8 = (_DWORD *)a1;
    if ( a3 > 0 )
    {
      do
        *v8++ = 0;
      while ( v8 != (_DWORD *)(a1 + 4 * a3) );
    }
    goto LABEL_14;
  }
  if ( a3 <= 0 )
  {
LABEL_14:
    result = 0;
    goto LABEL_3;
  }
  for ( i = 0; i != a3; ++i )
    *(_DWORD *)(a1 + 4 * i) = a2[i];
  result = 0;
LABEL_3:
  *(_DWORD *)(a1 + 4 * a3) = result;
  v4 = (_DWORD *)(a1 + 4);
  v5 = 1;
  if ( a3 > 1 )
  {
    do
    {
      v6 = a2[v5];
      v7 = v6 == 1;
      if ( v6 > 1 )
      {
        result = _mpn_addmul_1((int)v4, (int)a2, a3, a2[v5]);
      }
      else
      {
        result = 0;
        if ( v7 )
          result = _mpn_add_n(v4, v4, a2, a3);
      }
      ++v5;
      ++v4;
      v4[a3 - 1] = result;
    }
    while ( a3 != v5 );
  }
  return result;
}

//----- (0809EA80) --------------------------------------------------------
int __cdecl _mpn_impn_sqr_n(unsigned int *a1, unsigned int *a2, int a3, _DWORD *a4)
{
  int v4; // ebx
  unsigned int *v5; // ebp
  int result; // eax
  int v7; // ebx
  unsigned int *v8; // ebp
  int i; // eax
  unsigned int *v10; // edx
  unsigned int *v11; // edx
  int v12; // eax
  _BOOL4 v13; // ecx
  int v14; // eax
  int v15; // ebx
  int v16; // ecx
  int v17; // eax
  unsigned int v18; // edi
  _BOOL4 v19; // edx
  unsigned int *v20; // [esp+Ch] [ebp-30h]
  unsigned int *v21; // [esp+Ch] [ebp-30h]
  int v22; // [esp+10h] [ebp-2Ch]
  int v23; // [esp+14h] [ebp-28h]
  unsigned int *v24; // [esp+14h] [ebp-28h]
  unsigned int *v25; // [esp+14h] [ebp-28h]
  _BOOL4 v26; // [esp+14h] [ebp-28h]
  _BOOL4 v27; // [esp+18h] [ebp-24h]
  int v28; // [esp+18h] [ebp-24h]

  if ( (a3 & 1) != 0 )
  {
    v4 = a3 - 1;
    if ( a3 - 1 <= 31 )
      _mpn_impn_sqr_n_basecase((int)a1, a2, a3 - 1);
    else
      _mpn_impn_sqr_n(a1, a2, a3 - 1, a4);
    v5 = &a2[v4];
    a1[2 * v4] = _mpn_addmul_1((int)&a1[v4], (int)a2, v4, *v5);
    result = _mpn_addmul_1((int)&a1[v4], (int)a2, a3, *v5);
    a1[a3 + v4] = result;
    return result;
  }
  v7 = a3 >> 1;
  v23 = a3;
  v8 = &a1[a3];
  v22 = a3 >> 1;
  v20 = &a2[v22];
  if ( a3 >> 1 <= 31 )
    _mpn_impn_sqr_n_basecase((int)&a1[a3], &a2[v22], a3 >> 1);
  else
    _mpn_impn_sqr_n(&a1[a3], &a2[v22], a3 >> 1, a4);
  if ( _mpn_cmp((int)v20, (int)a2, v7) < 0 )
    _mpn_sub_n(a1, a2, v20, v7);
  else
    _mpn_sub_n(a1, v20, a2, v7);
  if ( v7 > 31 )
  {
    _mpn_impn_sqr_n(a4, a1, v7, &a4[v23]);
  }
  else
  {
    _mpn_impn_sqr_n_basecase((int)a4, a1, v7);
    if ( v7 <= 0 )
    {
      v26 = _mpn_add_n(v8, v8, &a1[v7 + a3], v7);
      v21 = &a1[v22];
      v28 = v26 - _mpn_sub_n(&a1[v22], &a1[v22], a4, a3);
      v10 = &a1[v7 + a3];
LABEL_15:
      v24 = v10;
      _mpn_impn_sqr_n_basecase((int)a4, a2, v7);
      v11 = v24;
      goto LABEL_16;
    }
  }
  for ( i = 0; i < v7; ++i )
    a1[v7 + i] = a1[a3 + i];
  v27 = _mpn_add_n(v8, v8, &a1[v7 + a3], v7);
  v21 = &a1[v22];
  v28 = v27 - _mpn_sub_n(v21, v21, a4, a3);
  v10 = &a1[v7 + a3];
  if ( v7 <= 31 )
    goto LABEL_15;
  _mpn_impn_sqr_n(a4, a2, v7, &a4[v23]);
  v11 = &a1[v7 + a3];
LABEL_16:
  v25 = v11;
  v12 = v28 + _mpn_add_n(v21, v21, a4, a3);
  if ( v12 )
  {
    v13 = __CFADD__(*v25, v12);
    *v25 += v12;
    if ( v13 )
    {
      v14 = 0;
      v15 = v7 - 1;
      do
      {
        if ( v14 == v15 )
          break;
        v16 = v25[v14 + 1] + 1;
        v25[++v14] = v16;
      }
      while ( !v16 );
      v7 = a3 >> 1;
    }
  }
  v17 = 0;
  if ( v7 > 0 )
  {
    do
    {
      a1[v17] = a4[v17];
      ++v17;
    }
    while ( v7 != v17 );
  }
  result = _mpn_add_n(v21, v21, &a4[v22], v7);
  if ( result )
  {
    v19 = (*v8)++ == -1;
    result = 0;
    if ( v19 && a3 != 1 )
    {
      do
      {
        v18 = v8[result + 1];
        v8[++result] = v18 + 1;
      }
      while ( v18 == -1 && result != a3 - 1 );
    }
  }
  return result;
}

//----- (0809EDE0) --------------------------------------------------------
int __cdecl _mpn_mul_n(unsigned int *a1, unsigned int *a2, unsigned int *a3, int a4)
{
  void *v4; // esp
  void *v6; // esp
  int v7; // [esp+0h] [ebp-8h] BYREF

  if ( a2 == a3 )
  {
    if ( a4 > 31 )
    {
      v6 = alloca(8 * a4 + 15);
      return _mpn_impn_sqr_n(a1, a2, a4, &v7);
    }
    else
    {
      return _mpn_impn_sqr_n_basecase((int)a1, a2, a4);
    }
  }
  else if ( a4 <= 31 )
  {
    return _mpn_impn_mul_n_basecase((int)a1, a2, a3, a4);
  }
  else
  {
    v4 = alloca(8 * a4 + 15);
    return _mpn_impn_mul_n(a1, a2, a3, a4, &v7);
  }
}

//----- (0809EE90) --------------------------------------------------------
_BOOL4 __cdecl _mpn_sub_n(_DWORD *a1, unsigned int *a2, _DWORD *a3, unsigned int a4)
{
  unsigned int v7; // ecx
  bool v8; // cf
  unsigned int v9; // ett
  unsigned int v10; // eax
  unsigned int v11; // ett
  unsigned int v12; // eax
  unsigned int v13; // ett
  unsigned int v14; // eax
  unsigned int v15; // ett
  unsigned int v16; // eax
  unsigned int v17; // ett
  unsigned int v18; // eax
  unsigned int v19; // ett
  unsigned int v20; // eax
  unsigned int v21; // ett
  unsigned int v22; // eax
  unsigned int v23; // ett

  v7 = a4 >> 3;
  v8 = 0;
  if ( (-a4 & 7) != 0 )
    __asm { jmp     eax }
  do
  {
    v9 = v8 + *a3;
    v8 = *a2 < v9;
    *a1 = *a2 - v9;
    v10 = a2[1];
    v11 = v8 + a3[1];
    v8 = v10 < v11;
    a1[1] = v10 - v11;
    v12 = a2[2];
    v13 = v8 + a3[2];
    v8 = v12 < v13;
    a1[2] = v12 - v13;
    v14 = a2[3];
    v15 = v8 + a3[3];
    v8 = v14 < v15;
    a1[3] = v14 - v15;
    v16 = a2[4];
    v17 = v8 + a3[4];
    v8 = v16 < v17;
    a1[4] = v16 - v17;
    v18 = a2[5];
    v19 = v8 + a3[5];
    v8 = v18 < v19;
    a1[5] = v18 - v19;
    v20 = a2[6];
    v21 = v8 + a3[6];
    v8 = v20 < v21;
    a1[6] = v20 - v21;
    v22 = a2[7];
    v23 = v8 + a3[7];
    v8 = v22 < v23;
    a1[7] = v22 - v23;
    a1 += 8;
    a2 += 8;
    a3 += 8;
    --v7;
  }
  while ( v7 );
  return v8;
}

//----- (0809EF20) --------------------------------------------------------
int __cdecl _mpn_submul_1(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // edi
  int v5; // ecx
  int v6; // ebp
  unsigned __int64 v7; // rax
  bool v8; // cf
  int v9; // edx

  v4 = a1 + 4 * a3;
  v5 = -a3;
  v6 = 0;
  do
  {
    v7 = (unsigned int)v6 + a4 * (unsigned __int64)*(unsigned int *)(a2 + 4 * a3 + 4 * v5);
    v8 = *(_DWORD *)(v4 + 4 * v5) < (unsigned int)v7;
    *(_DWORD *)(v4 + 4 * v5) -= v7;
    v9 = v8 + HIDWORD(v7);
    v6 = v9;
    ++v5;
  }
  while ( v5 );
  return v9;
}

//----- (0809EF60) --------------------------------------------------------
int __cdecl _mpn_extract_double(unsigned int *a1, int a2, int *a3, unsigned int *a4, unsigned int a5, unsigned int a6)
{
  int v6; // edx
  unsigned int v7; // eax
  signed int v8; // eax
  int v9; // edx
  int result; // eax
  unsigned int v11; // eax
  unsigned int v12; // ecx

  *a4 = a6 >> 31;
  *a3 = ((a6 >> 20) & 0x7FF) - 1023;
  v6 = a6 & 0xFFFFF;
  *a1 = a5;
  a1[1] = a6 & 0xFFFFF;
  if ( (a6 & 0x7FF00000) != 0 )
  {
    a1[1] = v6 | 0x100000;
    return 2;
  }
  if ( !a5 )
  {
    if ( v6 )
      goto LABEL_10;
    *a3 = 0;
    return 2;
  }
  if ( v6 )
  {
LABEL_10:
    _BitScanReverse(&v11, v6);
    v12 = (v11 ^ 0x1F) - 11;
    *a1 = a5 << v12;
    a1[1] = (v6 << v12) | (a5 >> (32 - v12));
    result = 2;
    *a3 = -1022 - v12;
    return result;
  }
  _BitScanReverse(&v7, a5);
  v8 = v7 ^ 0x1F;
  if ( v8 > 10 )
  {
    *a1 = 0;
    a1[1] = a5 << (v8 - 11);
  }
  else
  {
    a1[1] = a5 >> (11 - v8);
    *a1 = a5 << (v8 + 21);
  }
  v9 = -1043 - v8;
  result = 2;
  *a3 = v9;
  return result;
}

//----- (0809F060) --------------------------------------------------------
int __cdecl _mpn_extract_long_double(int a1, int a2, unsigned int *a3, int *a4, long double a5)
{
  int v5; // ecx
  int v6; // edx
  unsigned int v7; // ecx
  int result; // eax
  unsigned int v9; // eax
  int v10; // ebp
  unsigned int v11; // edx

  *a4 = BYTE9(a5) >> 7;
  v5 = WORD4(a5) & 0x7FFF;
  *a3 = v5 - 0x3FFF;
  *(_QWORD *)a1 = *(_QWORD *)&a5;
  if ( (WORD4(a5) & 0x7FFF) != 0 )
  {
    if ( DWORD1(a5) != 0 || LODWORD(a5) != 0 || v5 == 0x7FFF )
      return 2;
    goto LABEL_9;
  }
  if ( !*(_QWORD *)&a5 )
  {
LABEL_9:
    *a3 = 0;
    return 2;
  }
  v6 = DWORD1(a5) & 0x7FFFFFFF;
  *(_DWORD *)(a1 + 4) = DWORD1(a5) & 0x7FFFFFFF;
  if ( (DWORD1(a5) & 0x7FFFFFFF) != 0 )
  {
    _BitScanReverse(&v9, v6);
    v10 = (v6 << (v9 ^ 0x1F)) | (LODWORD(a5) >> (32 - (v9 ^ 0x1F)));
    *(_DWORD *)a1 = LODWORD(a5) << (v9 ^ 0x1F);
    v11 = -16382 - (v9 ^ 0x1F);
    *(_DWORD *)(a1 + 4) = v10;
    result = 2;
    *a3 = v11;
  }
  else
  {
    if ( LODWORD(a5) )
    {
      _BitScanReverse(&v7, LODWORD(a5));
      *(_DWORD *)a1 = 0;
      v7 ^= 0x1Fu;
      *(_DWORD *)(a1 + 4) = LODWORD(a5) << v7;
      *a3 = -16414 - v7;
    }
    else
    {
      *(_DWORD *)(a1 + 4) = 0x80000000;
      *a3 = -16382;
    }
    return 2;
  }
  return result;
}

//----- (0809F180) --------------------------------------------------------
_DWORD *__cdecl itowa(unsigned __int64 a1, _DWORD *a2, unsigned int a3, int a4)
{
  int *v4; // esi
  unsigned int v5; // edx
  unsigned int v6; // ebp
  _DWORD *v7; // ecx
  _DWORD *result; // eax
  char v9; // cl
  int v10; // edx
  unsigned int v11; // eax
  int i; // ebx
  int v13; // et2
  int v14; // ebp
  int v15; // eax
  _DWORD *v16; // edx
  char v17; // bl
  int v18; // ebx
  char v19; // dl
  char v20; // cl
  _DWORD *v21; // ebx
  unsigned __int64 v22; // rtt
  int v23; // eax
  int *v24; // [esp+4h] [ebp-30h]
  unsigned int v25; // [esp+4h] [ebp-30h]
  unsigned int v26; // [esp+Ch] [ebp-28h]
  int v27; // [esp+14h] [ebp-20h] BYREF
  int v28[7]; // [esp+18h] [ebp-1Ch] BYREF

  v4 = &itowa_lower_digits;
  v5 = HIDWORD(a1);
  v6 = a1;
  v7 = a2;
  if ( a4 )
    v4 = (int *)&itowa_upper_digits;
  if ( a3 == 8 )
  {
    result = a2;
    if ( HIDWORD(a1) )
    {
      result = a2;
      do
      {
        v17 = v6;
        --result;
        v6 >>= 3;
        *result = v4[v17 & 7];
      }
      while ( a2 - 10 != result );
      v6 |= (4 * BYTE4(a1)) & 4;
      if ( HIDWORD(a1) >> 1 )
      {
        v18 = v4[v6];
        v6 = HIDWORD(a1) >> 1;
        *(result - 1) = v18;
        result = a2 - 11;
      }
    }
    do
    {
      v19 = v6;
      v6 >>= 3;
      *--result = v4[v19 & 7];
    }
    while ( v6 );
  }
  else if ( a3 == 16 )
  {
    if ( HIDWORD(a1) )
    {
      result = a2;
      do
      {
        v9 = v6;
        --result;
        v6 >>= 4;
        *result = v4[v9 & 0xF];
      }
      while ( a2 - 8 != result );
    }
    else
    {
      v5 = a1;
      result = a2;
    }
    do
    {
      v20 = v5;
      v5 >>= 4;
      *--result = v4[v20 & 0xF];
    }
    while ( v5 );
  }
  else
  {
    if ( HIDWORD(a1) )
    {
      v21 = &itoa_base_table[3 * a3 - 6];
      v25 = v21[2];
      if ( HIDWORD(a1) < v25 )
      {
        v28[0] = a1 % v25;
        v6 = v28[0];
        v27 = a1 / v25;
        v10 = 2;
      }
      else
      {
        v26 = HIDWORD(a1) / v25;
        LODWORD(v22) = a1;
        HIDWORD(v22) = HIDWORD(a1) % v25;
        v6 = v22 % v25;
        v28[1] = v6;
        LODWORD(v22) = v22 / v25;
        HIDWORD(v22) = HIDWORD(a1) / v25;
        v23 = v22 / (unsigned int)v21[2];
        v28[0] = v22 % (unsigned int)v21[2];
        v27 = v23;
        v10 = 3;
      }
    }
    else
    {
      v27 = a1;
      v10 = 1;
    }
    v24 = &v28[v10 - 1];
    v11 = v6;
    while ( 1 )
    {
      for ( i = 0; v11; *v7 = v4[v13] )
      {
        --v7;
        ++i;
        v13 = v11 % a3;
        v11 /= a3;
      }
      if ( v28 == v24 )
        break;
      v14 = *((char *)&itoa_base_table[3 * a3 - 4] - 3);
      if ( v14 > i )
      {
        v15 = i;
        v16 = v7;
        do
        {
          ++v15;
          *--v16 = 48;
        }
        while ( v15 != v14 );
        v7 += i - v15;
      }
      v11 = *(v24 - 2);
      --v24;
    }
    return v7;
  }
  return result;
}
// 80CC860: using guessed type _DWORD itoa_base_table[112];
// 80D4220: using guessed type int itowa_lower_digits;

//----- (0809F390) --------------------------------------------------------
int __usercall sscanf@<eax>(long double a1@<st0>, unsigned int a2, unsigned int a3, ...)
{
  va_list va; // [esp+18h] [ebp+Ch] BYREF

  va_start(va, a3);
  return vsscanf(a1, a2, a3, (long double **)va);
}

//----- (0809F3B0) --------------------------------------------------------
int __usercall vsscanf@<eax>(long double a1@<st0>, unsigned int a2, unsigned int a3, long double **a4)
{
  unsigned int v5[43]; // [esp+Ch] [ebp-ACh] BYREF

  v5[18] = 0;
  IO_no_init((int)v5, 0x8000, -1, 0, 0);
  v5[37] = (unsigned int)&IO_str_jumps;
  IO_str_init_static_internal(v5, a2, 0, 0);
  return IO_vfscanf_internal(a1, (int)v5, a3, a4, 0);
}

//----- (0809F420) --------------------------------------------------------
int __cdecl fileno_unlocked(_DWORD *a1)
{
  int result; // eax

  if ( (*a1 & 0x2000) == 0 || (result = a1[14], result < 0) )
  {
    __writegsdword(0xFFFFFFE8, 9u);
    return -1;
  }
  return result;
}

//----- (0809F450) --------------------------------------------------------
int __cdecl fseek(int *a1, int a2, unsigned int a3)
{
  unsigned int v4; // esi
  bool v6; // zf
  int v7; // eax
  int v8; // edx
  int v9; // edx
  _DWORD *v10; // ecx

  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v4 = __readgsdword(8u);
    if ( v4 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v6 = __readgsdword(0xCu) == 0;
      if ( !v6 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v6 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v4;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v7 = IO_seekoff_unlocked(a1, a2, a3, 3);
  v9 = -((v8 & v7) == -1);
  if ( (*a1 & 0x8000) == 0 )
  {
    v10 = (_DWORD *)a1[18];
    v6 = v10[1]-- == 1;
    if ( v6 )
    {
      v10[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*v10)-- == 1;
      if ( !v6 )
        _lll_unlock_wake_private(v10);
    }
  }
  return v9;
}
// 809F4AA: variable 'v8' is possibly undefined
// 809F4EB: variable 'v9' is possibly undefined

//----- (0809F530) --------------------------------------------------------
int __cdecl ftello(int *a1)
{
  unsigned int v2; // esi
  bool v4; // zf
  unsigned int v5; // edx
  __int64 v6; // rdi
  int result; // eax
  _DWORD *v8; // edx
  int v9; // [esp+Ch] [ebp-1Ch]

  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v2 = __readgsdword(8u);
    if ( v2 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v4 = __readgsdword(0xCu) == 0;
      if ( !v4 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v4 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v2;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  HIDWORD(v6) = IO_seekoff_unlocked(a1, 0LL, 1u, 0);
  LODWORD(v6) = v5;
  v9 = *a1;
  if ( (*a1 & 0x100) == 0 )
    goto LABEL_17;
  if ( __PAIR64__(~v5, ~HIDWORD(v6)) )
  {
    if ( a1[26] > 0 )
    {
      if ( (v9 & 0x8000) != 0 )
        goto LABEL_13;
      v8 = (_DWORD *)a1[18];
      v4 = v8[1]-- == 1;
      if ( !v4 )
        goto LABEL_13;
      goto LABEL_19;
    }
    LODWORD(v6) = (__PAIR64__(v5, HIDWORD(v6)) - (a1[11] - a1[9])) >> 32;
    HIDWORD(v6) -= a1[11] - a1[9];
LABEL_17:
    if ( (v9 & 0x8000) != 0 )
      goto LABEL_23;
    v8 = (_DWORD *)a1[18];
    v4 = v8[1]-- == 1;
    if ( !v4 )
      goto LABEL_23;
    goto LABEL_19;
  }
  if ( (v9 & 0x8000) == 0 )
  {
    v8 = (_DWORD *)a1[18];
    v4 = v8[1]-- == 1;
    if ( v4 )
    {
LABEL_19:
      v8[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v4 = (*v8)-- == 1;
      if ( !v4 )
        _lll_unlock_wake_private(v8);
LABEL_23:
      if ( v6 == -1 )
        goto LABEL_24;
LABEL_13:
      result = HIDWORD(v6);
      if ( SHIDWORD(v6) >> 31 != (unsigned int)v6 )
      {
        __writegsdword(0xFFFFFFE8, 0x4Bu);
        return -1;
      }
      return result;
    }
  }
LABEL_24:
  result = -1;
  if ( !__readgsdword(0xFFFFFFE8) )
    __writegsdword(0xFFFFFFE8, 5u);
  return result;
}
// 809F592: variable 'v5' is possibly undefined

//----- (0809F6D0) --------------------------------------------------------
int __cdecl fread_unlocked(int a1, unsigned int a2, int a3, int a4)
{
  int v4; // ebx
  unsigned int v6; // eax

  v4 = a3 * a2;
  if ( !(a3 * a2) )
    return v4;
  v6 = IO_sgetn(a4, a1, a3 * a2);
  if ( v4 == v6 )
    return a3;
  return v6 / a2;
}

//----- (0809F730) --------------------------------------------------------
int init()
{
  int result; // eax

  result = 0;
  static_buf = (int)&last_result;
  return result;
}
// 80EC7AC: using guessed type int static_buf;

//----- (0809F770) --------------------------------------------------------
int __usercall _dlerror@<eax>(long double a1@<st0>)
{
  unsigned __int8 *v1; // eax
  int result; // eax
  const char *v3; // eax
  const char *v4; // ecx
  const char *v5; // edx
  const char *v6; // esi
  const char *v7; // eax
  const char *v8; // ecx
  const char *v9; // edx
  int v10[4]; // [esp+1Ch] [ebp-10h] BYREF

  v10[0] = 0;
  if ( !once )
  {
    static_buf = (int)&last_result;
    once = 2;
  }
  v1 = (unsigned __int8 *)*((_DWORD *)&last_result + 4);
  if ( *((_DWORD *)&last_result + 1) )
  {
    if ( v1 )
    {
      if ( strcmp(*((const char **)&last_result + 4), "out of memory") )
        free(a1, *((_DWORD *)&last_result + 4));
      *((_DWORD *)&last_result + 4) = 0;
    }
    return v10[0];
  }
  if ( !v1 )
    return v10[0];
  v10[0] = *((_DWORD *)&last_result + 4);
  if ( last_result )
  {
    v6 = (const char *)strerror(a1, last_result);
    v7 = (const char *)dcgettext(a1, "libc", *((unsigned __int8 **)&last_result + 4), 5u);
    v8 = (const char *)*((_DWORD *)&last_result + 3);
    v9 = "undefined symbol: " + 16;
    if ( !*v8 )
      v9 = byte_80CFAB1;
    if ( asprintf(a1, v10, (unsigned int)"%s%s%s: %s", v8, v9, v7, v6) != -1 )
      goto LABEL_13;
  }
  else
  {
    v3 = (const char *)dcgettext(a1, "libc", v1, 5u);
    v4 = (const char *)*((_DWORD *)&last_result + 3);
    v5 = "undefined symbol: " + 16;
    if ( !*v4 )
      v5 = byte_80CFAB1;
    if ( asprintf(a1, v10, (unsigned int)"%s%s%s", v4, v5, v3) != -1 )
    {
LABEL_13:
      if ( strcmp(*((const char **)&last_result + 4), "out of memory") )
        free(a1, *((_DWORD *)&last_result + 4));
      result = v10[0];
      *((_DWORD *)&last_result + 4) = v10[0];
      goto LABEL_16;
    }
  }
  result = v10[0];
LABEL_16:
  *((_DWORD *)&last_result + 1) = 1;
  return result;
}
// 80CFAB1: using guessed type _BYTE byte_80CFAB1[1231];
// 80EC7A4: using guessed type int once;
// 80EC7AC: using guessed type int static_buf;

//----- (0809F970) --------------------------------------------------------
const char *__usercall check_free_isra_0@<eax>(const char *result@<eax>, long double a2@<st0>)
{
  if ( result )
  {
    if ( strcmp(result, "out of memory") )
      return (const char *)free(a2, (int)result);
  }
  return result;
}

//----- (0809F9A0) --------------------------------------------------------
int __cdecl free_key_mem(int a1)
{
  check_free_isra_0();
  free(a1);
  return 0;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 809F970: using guessed type int check_free_isra_0(void);

//----- (0809F9E0) --------------------------------------------------------
_BOOL4 __usercall dlerror_run@<eax>(void (__cdecl *a1)(int)@<eax>, int a2@<edx>, int a3@<ebp>)
{
  int v5; // eax
  _BOOL4 v6; // edx
  _BOOL4 result; // eax
  int *v8; // ebx

  v8 = (int *)static_buf;
  if ( once )
  {
    if ( static_buf )
      goto LABEL_3;
  }
  else
  {
    static_buf = (int)&last_result;
    v8 = (int *)&last_result;
    once = 2;
    if ( &last_result )
      goto LABEL_3;
  }
  v8 = (int *)calloc(1u, 0x14u);
  if ( !v8 )
    v8 = (int *)&last_result;
LABEL_3:
  if ( v8[4] )
  {
    if ( *((_BYTE *)v8 + 8) )
      free(v8[4]);
    v8[4] = 0;
  }
  *v8 = dl_catch_error(v8 + 3, v8 + 4, (_BYTE *)v8 + 8, a3, a2, (int)a1, a1, a2);
  v5 = v8[4];
  v6 = v5 == 0;
  result = v5 != 0;
  v8[1] = v6;
  return result;
}
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EC7A4: using guessed type int once;
// 80EC7AC: using guessed type int static_buf;

//----- (0809FB60) --------------------------------------------------------
_DWORD *__usercall _libc_register_dlfcn_hook@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4)
{
  _DWORD *result; // eax

  result = (_DWORD *)_libc_dlsym_private(a1, a2, a3, a4, (int)"_dlfcn_hook");
  if ( result )
    *result = &dlfcn_hooks;
  return result;
}
// 80EBF40: using guessed type int (__cdecl *dlfcn_hooks)(int, int, int);

//----- (0809FB90) --------------------------------------------------------
int __cdecl _dladdr(unsigned int a1, _DWORD *a2)
{
  return dl_addr(a1, a2, 0, 0);
}

//----- (0809FBB0) --------------------------------------------------------
int __cdecl _dladdr1(unsigned int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  if ( a4 == 1 )
    return dl_addr(a1, a2, 0, a3);
  if ( a4 == 2 )
    return dl_addr(a1, a2, a3, 0);
  return dl_addr(a1, a2, 0, 0);
}

//----- (0809FC10) --------------------------------------------------------
int *__usercall dlinfo_doit@<eax>(long double a1@<st0>, int *a2)
{
  int *result; // eax
  int addr_soft; // edx
  int v4; // edx
  int **v5; // edx

  result = (int *)a2[1];
  switch ( a2[2] )
  {
    case 1:
      v4 = result[6];
      result = (int *)a2[3];
      *result = v4;
      break;
    case 2:
      *(_DWORD *)a2[3] = result;
      break;
    case 4:
      result = (int *)dl_rtld_di_serinfo((int)result, (_DWORD *)a2[3], 0, a1);
      break;
    case 5:
      result = (int *)dl_rtld_di_serinfo((int)result, (_DWORD *)a2[3], 1, a1);
      break;
    case 6:
      result = (int *)j_strcpy(a2[3], result[106]);
      break;
    case 9:
      v5 = (int **)a2[3];
      *v5 = 0;
      result = (int *)result[145];
      *v5 = result;
      break;
    case 10:
      addr_soft = 0;
      if ( result[145] )
        addr_soft = dl_tls_get_addr_soft(a2[1]);
      result = (int *)a2[3];
      *result = addr_soft;
      break;
    default:
      dl_signal_error(0, 0, 0, a1, "unsupported dlinfo request");
  }
  return result;
}
// 80481B0: using guessed type int __cdecl j_strcpy(_DWORD, _DWORD);

//----- (0809FD00) --------------------------------------------------------
int __usercall _dlinfo@<eax>(int a1@<ebp>, int a2, int a3, int a4, int a5)
{
  int v6[7]; // [esp+0h] [ebp-1Ch] BYREF

  v6[0] = a5;
  v6[1] = a2;
  v6[2] = a3;
  v6[3] = a4;
  return -dlerror_run((void (__cdecl *)(int))dlinfo_doit, (int)v6, a1);
}

//----- (0809FD40) --------------------------------------------------------
int __usercall dlmopen_doit@<eax>(int a1@<edi>, long double a2@<st0>, _DWORD *a3)
{
  _BYTE *v3; // eax
  int result; // eax

  if ( *a3 )
    dl_signal_error(22, 0, 0, a2, "invalid namespace");
  v3 = (_BYTE *)a3[1];
  if ( !v3 )
    v3 = byte_80CFAB1;
  result = dl_open(a1, a2, v3, a3[2] | 0x80000000, a3[4], 0, _libc_argc, _libc_argv, environ);
  a3[3] = result;
  return result;
}
// 80CFAB1: using guessed type _BYTE byte_80CFAB1[1231];
// 80EC524: using guessed type int environ;
// 80ECCCC: using guessed type int _libc_argc;
// 80ECCD0: using guessed type int _libc_argv;

//----- (0809FDB0) --------------------------------------------------------
int __usercall _dlmopen@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5, int a6, int a7)
{
  _BOOL4 v7; // eax
  int v8; // edx
  int v10[3]; // [esp+Ch] [ebp-20h] BYREF
  int v11; // [esp+18h] [ebp-14h]
  int v12; // [esp+1Ch] [ebp-10h]

  v10[0] = a4;
  v10[1] = a5;
  v10[2] = a6;
  v12 = a7;
  v7 = dlerror_run((void (__cdecl *)(int))dlmopen_doit, (int)v10, a1);
  v8 = 0;
  if ( !v7 )
  {
    _libc_register_dl_open_hook(a1, a2, a3, v11);
    _libc_register_dlfcn_hook(a1, a2, a3, v11);
    return v11;
  }
  return v8;
}

//----- (0809FE10) --------------------------------------------------------
unsigned int __usercall strerror@<eax>(long double a1@<st0>, signed int a2)
{
  unsigned int result; // eax
  _BYTE *v3; // eax
  unsigned int v4; // edi

  result = strerror_r(a1, a2, 0, 0);
  if ( !result )
  {
    v3 = (_BYTE *)buf;
    v4 = __readgsdword(0xFFFFFFE8);
    if ( buf )
    {
      __writegsdword(0xFFFFFFE8, v4);
      return strerror_r(a1, a2, v3, 0x400u);
    }
    v3 = (_BYTE *)malloc(a1, 0x400u);
    buf = (int)v3;
    __writegsdword(0xFFFFFFE8, v4);
    if ( v3 )
      return strerror_r(a1, a2, v3, 0x400u);
    return dcgettext(a1, "libc", "Unknown error", 5u);
  }
  return result;
}
// 80ECDA0: using guessed type int buf;

//----- (0809FE90) --------------------------------------------------------
_BYTE *__cdecl strsep(_BYTE **a1, char *a2)
{
  _BYTE *v2; // ebx
  int v3; // eax
  _BYTE *v4; // eax

  v2 = *a1;
  if ( !*a1 )
    return v2;
  v3 = *a2;
  if ( !(_BYTE)v3 )
    goto LABEL_10;
  if ( a2[1] )
  {
    v4 = strpbrk((int)v2, a2);
    goto LABEL_5;
  }
  if ( (_BYTE)v3 == *v2 )
  {
    v4 = *a1;
    goto LABEL_6;
  }
  if ( *v2 )
  {
    v4 = (_BYTE *)j_strchr(v2 + 1, v3);
LABEL_5:
    if ( v4 )
    {
LABEL_6:
      *v4 = 0;
      *a1 = v4 + 1;
      return v2;
    }
  }
LABEL_10:
  *a1 = 0;
  return v2;
}
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);

//----- (0809FF20) --------------------------------------------------------
int __cdecl _offtime(_DWORD *a1, int a2, int *a3)
{
  int v3; // edi
  int v4; // ecx
  int v5; // ebp
  int v6; // ecx
  unsigned int v7; // ebx
  int v8; // ecx
  int v9; // ebx
  unsigned int v10; // edi
  int v11; // ecx
  int v12; // ebp
  unsigned int v13; // ecx
  unsigned int v14; // edx
  int v15; // eax
  __int16 *v16; // ecx
  int v17; // eax
  int i; // edx
  int v20; // [esp+0h] [ebp-1Ch]
  int v21; // [esp+4h] [ebp-18h]

  v3 = *a1 / 86400;
  v4 = a2 + *a1 % 86400;
  if ( v4 >= 0 )
  {
    while ( v4 > 86399 )
    {
      v4 -= 86400;
      ++v3;
    }
  }
  else
  {
    do
    {
      --v3;
      v4 += 86400;
    }
    while ( v4 < 0 );
  }
  v5 = 1970;
  v20 = v3;
  a3[2] = v4 / 3600;
  v6 = v4 % 3600;
  a3[1] = v6 / 60;
  *a3 = v6 % 60;
  a3[6] = (v3 + 4) % 7 + ((v3 + 4) % 7 < 0 ? 7 : 0);
  while ( 1 )
  {
    if ( v20 >= 0 )
    {
      v15 = 365;
      if ( (v5 & 3) == 0 )
      {
        v15 = 366;
        if ( v5 == 100 * (v5 / 100) )
          v15 = (v5 == 400 * (v5 / 400)) + 365;
      }
      if ( v20 < v15 )
        break;
    }
    v7 = v20 / 365 + v5 - ((unsigned int)(v20 % 365) >> 31);
    v8 = v7 + 2;
    v21 = v7;
    v9 = v7 - 1;
    if ( v9 >= 0 )
      v8 = v9;
    v10 = v9 / 400
        - ((unsigned int)(v9 % 400) >> 31)
        + (v8 >> 2)
        - ((unsigned int)(v9 % 4) >> 31)
        - (v9 / 100
         - ((unsigned int)(v9 % 100) >> 31))
        + 365 * (v20 / 365 - ((unsigned int)(v20 % 365) >> 31));
    v11 = v5 + 2;
    v12 = v5 - 1;
    if ( v12 >= 0 )
      v11 = v12;
    v13 = (v11 >> 2) - ((unsigned int)(v12 % 4) >> 31) - (v12 / 100 - ((unsigned int)(v12 % 100) >> 31));
    v14 = v12 / 400 - ((unsigned int)(v12 % 400) >> 31);
    v5 = v21;
    v20 -= v10 - (v14 + v13);
  }
  v16 = _mon_yday;
  a3[5] = v5 - 1900;
  a3[7] = v20;
  if ( (v5 & 3) == 0 )
  {
    v16 = (__int16 *)&unk_80D51DA;
    if ( v5 == 100 * (v5 / 100) && v5 != 400 * (v5 / 400) )
      v16 = _mon_yday;
  }
  v17 = (unsigned __int16)v16[11];
  for ( i = 11; v20 < v17; v17 = (unsigned __int16)v16[i] )
    --i;
  a3[3] = v20 - v17 + 1;
  a3[4] = i;
  return 1;
}
// 80D51C0: using guessed type __int16 _mon_yday[13];

//----- (080A0210) --------------------------------------------------------
int *__usercall localtime_r@<eax>(long double a1@<st0>, int *a2, int *a3)
{
  return _tz_convert(a1, a2, 1, a3);
}

//----- (080A0230) --------------------------------------------------------
int *__usercall localtime@<eax>(long double a1@<st0>, int *a2)
{
  return _tz_convert(a1, a2, 1, tmbuf);
}
// 80ECD60: using guessed type int tmbuf[11];

//----- (080A0250) --------------------------------------------------------
int __usercall ranged_convert@<eax>(int (__cdecl *a1)(int *, int)@<eax>, int *a2@<edx>, int a3@<ecx>)
{
  int result; // eax
  int v6; // esi
  int v7; // ecx
  int v8; // ebx
  int v9; // [esp+10h] [ebp-24h]

  result = a1(a2, a3);
  if ( !result )
  {
    v6 = *a2;
    v7 = 0;
    if ( *a2 )
    {
      if ( v6 != ((v6 >> 31) | 1) )
      {
        do
        {
          v9 = v7;
          v8 = (v7 >> 1) + (v6 >> 1) + ((unsigned __int8)v7 & (unsigned __int8)v6 & 1);
          *a2 = v8;
          result = a1(a2, a3);
          v7 = v9;
          if ( result )
            v7 = v8;
          else
            v6 = v8;
        }
        while ( v6 != v7 + ((v6 >> 31) | 1) );
      }
      if ( !result )
      {
        if ( v7 )
        {
          *a2 = v7;
          return a1(a2, a3);
        }
      }
    }
  }
  return result;
}

//----- (080A0300) --------------------------------------------------------
int __usercall guess_time_tm_isra_0@<eax>(
        unsigned __int64 a1@<edx:eax>,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        _DWORD *a8)
{
  int v8; // esi
  int v9; // ecx
  int v10; // edx
  int result; // eax

  if ( !a8
    || (v8 = (__PAIR64__((unsigned int)(a1 >> 2) + 475, a1 & 3) - 1) >> 32,
        v9 = ((int)a8[5] >> 2) + 475 - ((a8[5] & 3) == 0),
        v10 = 60
            * (60
             * (a4
              - a8[2]
              + 24
              * (v9 / 25
               - ((unsigned int)(v9 % 25) >> 31)
               + ((int)(v8 / 25 - ((unsigned int)(v8 % 25) >> 31)) >> 2)
               + 365 * (a1 - a8[5])
               + v8
               + a2
               - a8[7]
               - v9
               - (v8 / 25
                - ((unsigned int)(v8 % 25) >> 31))
               - ((int)(v9 / 25 - ((unsigned int)(v9 % 25) >> 31)) >> 2)))
             + a5
             - a8[1])
            + a6
            - *a8,
        result = v10 + a7,
        v10 + a7 >= a7 == v10 < 0) )
  {
    if ( a7 < 0 )
    {
      result = a7 + 1;
      if ( a7 != 0x80000000 && a7 != -2147483647 )
        return 0x80000000;
    }
    else
    {
      result = a7 - 1;
      if ( a7 < 2147483646 )
        return 0x7FFFFFFF;
    }
  }
  return result;
}

//----- (080A0460) --------------------------------------------------------
int __cdecl _mktime_internal(int *a1, int (__cdecl *a2)(int *, int), int *a3)
{
  int v3; // ecx
  int v4; // ebx
  unsigned int v5; // ebp
  unsigned int v6; // eax
  __int64 v7; // rdi
  _BOOL4 v8; // ecx
  int v9; // eax
  int v10; // edx
  int v11; // ebx
  int v12; // ebp
  int v13; // kr00_4
  int v14; // edi
  int v15; // edx
  int v16; // esi
  int v17; // edi
  _DWORD *v18; // eax
  int v19; // ebx
  int result; // eax
  int v21; // ecx
  int v22; // edx
  int v23; // edi
  int v24; // ebp
  int v25; // esi
  unsigned __int64 v26; // [esp+0h] [ebp-BCh]
  int v27; // [esp+8h] [ebp-B4h]
  int v28; // [esp+Ch] [ebp-B0h]
  __int64 v29; // [esp+10h] [ebp-ACh]
  int v30; // [esp+18h] [ebp-A4h]
  int v31; // [esp+18h] [ebp-A4h]
  int v32; // [esp+1Ch] [ebp-A0h]
  bool v33; // [esp+1Ch] [ebp-A0h]
  int v34; // [esp+20h] [ebp-9Ch]
  int v35; // [esp+24h] [ebp-98h]
  int v36; // [esp+28h] [ebp-94h]
  int v37; // [esp+2Ch] [ebp-90h]
  int v38; // [esp+2Ch] [ebp-90h]
  int v39; // [esp+3Ch] [ebp-80h] BYREF
  int v40; // [esp+40h] [ebp-7Ch] BYREF
  int v41; // [esp+44h] [ebp-78h] BYREF
  int v42[8]; // [esp+48h] [ebp-74h] BYREF
  int v43; // [esp+68h] [ebp-54h]
  int v44; // [esp+6Ch] [ebp-50h]
  int v45; // [esp+70h] [ebp-4Ch]
  _DWORD v46[8]; // [esp+74h] [ebp-48h] BYREF
  int v47; // [esp+94h] [ebp-28h]

  v36 = *a1;
  v37 = a1[8];
  v27 = a1[1];
  v28 = a1[2];
  v30 = a1[3];
  v3 = a1[4];
  v32 = a1[5];
  v4 = v3 % 12;
  v5 = (unsigned int)(v3 % 12) >> 31;
  v6 = v32 + v3 / 12 - v5;
  LODWORD(v7) = 0;
  HIDWORD(v26) = (unsigned __int64)(v32 + (__int64)(int)(v3 / 12 - v5)) >> 32;
  HIDWORD(v7) = ((_BYTE)v32 + (unsigned __int8)(v3 / 12) - (v3 % 12 < 0)) & 3;
  v8 = 0;
  LODWORD(v26) = v6;
  if ( !HIDWORD(v7) )
  {
    v8 = 1;
    if ( !((__int64)v26 % 100) )
      v8 = (((__int64)v26 / 100) & 3) == 1;
  }
  v29 = v30 + (__int64)((unsigned __int16)_mon_yday[13 * v8 + 12 * v5 + v4] - 1);
  v9 = 59;
  v10 = 0;
  if ( v36 <= 59 )
    v9 = *a1;
  v11 = *a3;
  if ( v9 >= 0 )
    v10 = v9;
  v12 = v10;
  v34 = *a3;
  v13 = (v26 >> 2) - (v7 == 0) + 475;
  v14 = v10
      + v11
      + 60
      * (v27
       + 60
       * (v28
        + 24
        * (v29
         + ((int)(v13 / 25 - ((unsigned int)(v13 % 25) >> 31)) >> 2)
         + (v26 >> 2)
         - (v7 == 0)
         + 365 * (v26 - 70)
         - 2
         - (v13 / 25
          - ((unsigned int)(v13 % 25) >> 31)))));
  v35 = v14;
  v15 = (v27 >> 20) + (v28 >> 14) + (v32 >> 1) + (v30 >> 10) - 35;
  if ( ((((v14 >> 26) - v15) >> 31) ^ ((v14 >> 26) - v15)) <= 21
    || (v35 = ~v14, v34 = ~v14 - v14 + v11, ((((~v14 >> 26) - v15) >> 31) ^ ((~v14 >> 26) - v15)) <= 21) )
  {
    v16 = 6;
    v31 = 0;
    v40 = v35;
    v39 = v35;
    v17 = v35;
    while ( 1 )
    {
      v18 = (_DWORD *)ranged_convert(a2, &v39, (int)v42);
      v19 = v39;
      result = guess_time_tm_isra_0(v26, v29, SHIDWORD(v29), v28, v27, v12, v39, v18);
      if ( result == v19 )
        break;
      if ( v17 == v19 && v17 != v40 )
      {
        if ( v43 < 0 )
          goto LABEL_19;
        if ( v37 < 0 )
        {
          if ( v31 <= (v43 != 0) )
          {
            result = v17;
            goto LABEL_20;
          }
        }
        else if ( (v37 != 0) != (v43 != 0) )
        {
LABEL_19:
          result = v17;
          goto LABEL_20;
        }
      }
      if ( !--v16 )
        return -1;
      v39 = result;
      v17 = v40;
      v40 = v19;
      v31 = v43 != 0;
    }
    v33 = v37 == 0;
    if ( (v43 == 0) != (v37 == 0) && v43 >= 0 )
    {
      v23 = 601200;
      if ( v37 >= 0 )
      {
        v38 = v12;
        do
        {
          v24 = 2;
          v25 = -v23;
          do
          {
            if ( v25 + v19 >= v19 != v25 < 0 )
            {
              v41 = v25 + v19;
              ranged_convert(a2, &v41, (int)v46);
              if ( v33 == (v47 == 0) || v47 < 0 )
              {
                v12 = v38;
                v39 = guess_time_tm_isra_0(v26, v29, SHIDWORD(v29), v28, v27, v38, v41, v46);
                ranged_convert(a2, &v39, (int)v42);
                result = v39;
                goto LABEL_20;
              }
              v19 = v39;
            }
            v25 += 2 * v23;
            --v24;
          }
          while ( v24 );
          v23 += 601200;
        }
        while ( v23 != 269337600 );
        v12 = v38;
        result = v19;
      }
    }
LABEL_20:
    *a3 = result + v34 - v35;
    if ( v36 == v42[0] )
      goto LABEL_25;
    v21 = v36 + result;
    v22 = (v42[0] == 60 && v12 == 0) - v12;
    if ( v36 + result >= result != v36 < 0 && v21 <= v22 + v21 != v22 < 0 )
    {
      v40 = v22 + v21;
      if ( a2(&v40, (int)v42) )
      {
        result = v40;
LABEL_25:
        *a1 = v42[0];
        a1[1] = v42[1];
        a1[2] = v42[2];
        a1[3] = v42[3];
        a1[4] = v42[4];
        a1[5] = v42[5];
        a1[6] = v42[6];
        a1[7] = v42[7];
        a1[8] = v43;
        a1[9] = v44;
        a1[10] = v45;
        return result;
      }
    }
  }
  return -1;
}
// 80D51C0: using guessed type __int16 _mon_yday[13];
// 80A0460: using guessed type _DWORD var_48[8];

//----- (080A0980) --------------------------------------------------------
int __usercall timelocal@<eax>(long double a1@<st0>, int *a2)
{
  tzset(a1);
  return _mktime_internal(a2, (int (__cdecl *)(int *, int))localtime_r, &localtime_offset);
}
// 80EC7C4: using guessed type int localtime_offset;

//----- (080A09B0) --------------------------------------------------------
unsigned int __fastcall _getdents64(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080A09E0) --------------------------------------------------------
int __fastcall getpid(int a1)
{
  __int64 v1; // rax

  HIDWORD(v1) = __readgsdword(0x6Cu);
  LODWORD(v1) = HIDWORD(v1);
  if ( SHIDWORD(v1) <= 0 )
  {
    if ( HIDWORD(v1) || (LODWORD(v1) = __readgsdword(0x68u), !(_DWORD)v1) )
    {
      v1 = dl_sysinfo(a1);
      if ( !HIDWORD(v1) )
        __writegsdword(0x68u, v1);
    }
  }
  return v1;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080A0A20) --------------------------------------------------------
int __usercall dl_build_local_scope@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  _DWORD *v3; // esi
  int v4; // eax
  int v5; // edx
  int *v6; // ebx
  int v7; // eax

  v3 = a1 + 1;
  *a1 = a2;
  *(_BYTE *)(a2 + 404) = *(_BYTE *)(a2 + 404) & 0x9F | 0x20;
  v4 = *(_DWORD *)(a2 + 496);
  if ( v4 )
  {
    v5 = *(_DWORD *)(v4 + 4);
    v6 = (int *)(v4 + 4);
    if ( v5 )
    {
      do
      {
        while ( (*(_BYTE *)(v5 + 404) & 0x60) != 0 )
        {
          v5 = *++v6;
          if ( !*v6 )
            return v3 - a1;
        }
        ++v6;
        v7 = dl_build_local_scope();
        v5 = *v6;
        v3 += v7;
      }
      while ( *v6 );
    }
  }
  return v3 - a1;
}

//----- (080A0A90) --------------------------------------------------------
int __usercall openaux@<eax>(long double a1@<st0>, int a2)
{
  char v2; // cl
  int result; // eax

  v2 = *(_BYTE *)(*(_DWORD *)a2 + 404) & 3;
  if ( !v2 )
    v2 = 1;
  result = dl_map_object(
             *(int **)a2,
             *(char **)(a2 + 16),
             v2,
             a1,
             *(_DWORD *)(a2 + 4),
             *(_DWORD *)(a2 + 8),
             *(_DWORD *)(*(_DWORD *)a2 + 24));
  *(_DWORD *)(a2 + 20) = result;
  return result;
}

//----- (080A0AD0) --------------------------------------------------------
int __userpurge dl_map_object_deps@<eax>(
        int a1@<eax>,
        int *a2@<edx>,
        unsigned int a3@<ecx>,
        long double a4@<st0>,
        int a5,
        int a6)
{
  void *v6; // esp
  unsigned int **v7; // eax
  int *v8; // edi
  int *v9; // ecx
  int v10; // ebx
  int v11; // eax
  int v12; // edi
  int v13; // ebx
  int v14; // eax
  _BYTE *v15; // eax
  int *v16; // edi
  int v17; // eax
  unsigned int v18; // edx
  char *v19; // esi
  int v20; // eax
  int v21; // eax
  char *v22; // edx
  int v23; // eax
  char v24; // cl
  int v25; // eax
  unsigned int v26; // ecx
  int v27; // eax
  unsigned int v28; // esi
  int v29; // esi
  int v30; // ecx
  int v31; // ecx
  int v32; // esi
  int *v33; // eax
  unsigned int v34; // ecx
  int v35; // esi
  int v36; // edx
  int v37; // eax
  _BYTE *v38; // ebx
  int v39; // edi
  unsigned int v40; // esi
  int *v41; // eax
  unsigned int v42; // ecx
  int v43; // eax
  _BYTE *v44; // esi
  int v45; // edx
  int v46; // edi
  int v47; // eax
  int *v48; // edx
  int *v49; // ebx
  int v50; // ecx
  _BYTE *v51; // ecx
  unsigned int v52; // edi
  _BYTE *v53; // ebx
  int v54; // esi
  unsigned int *v55; // eax
  int v56; // edx
  bool v57; // cf
  unsigned int v58; // ecx
  unsigned int *v59; // edi
  int v60; // eax
  _BYTE *v61; // edi
  unsigned int v62; // ecx
  unsigned int v63; // eax
  int v64; // edx
  unsigned int v65; // edi
  void *v66; // esp
  _BYTE *v67; // eax
  unsigned int v68; // edi
  int *v69; // ecx
  int v70; // ebx
  int v71; // edx
  int *v72; // eax
  int v73; // esi
  unsigned int v74; // esi
  int v75; // ecx
  unsigned int v76; // eax
  int v77; // ebx
  int v78; // ecx
  _BYTE *origin; // eax
  unsigned int v80; // eax
  unsigned int v81; // edx
  void *v82; // esp
  char *v83; // eax
  _BYTE *v84; // eax
  unsigned int v85; // eax
  unsigned int v86; // edx
  void *v87; // esp
  char *v88; // eax
  int v89; // eax
  void *v90; // esp
  const char *v91; // esi
  int v92; // eax
  void *v93; // esp
  int v94; // edx
  _BYTE *v95; // edi
  int v96; // eax
  int v97; // edi
  int v98; // eax
  int result; // eax
  int v100; // ebx
  int *i; // ecx
  int v102; // esi
  unsigned int v103; // ecx
  int v104; // esi
  int v105; // eax
  unsigned int v106; // eax
  unsigned int v107; // eax
  void *v108; // esp
  const char *v109; // eax
  unsigned int v110; // edi
  _DWORD *v111; // edx
  _DWORD *v112; // esi
  int v113; // edi
  int v114; // eax
  unsigned int v115; // eax
  unsigned int v116; // ebx
  int v117; // eax
  int v118; // eax
  _BYTE *v119; // ecx
  signed int v120; // ecx
  int v121; // [esp-20h] [ebp-B8h] BYREF
  int v122; // [esp-1Ch] [ebp-B4h]
  int v123; // [esp-18h] [ebp-B0h]
  int v124; // [esp+0h] [ebp-98h] BYREF
  int v125; // [esp+4h] [ebp-94h]
  int *v126; // [esp+8h] [ebp-90h]
  int v127; // [esp+Ch] [ebp-8Ch] BYREF
  int v128; // [esp+10h] [ebp-88h]
  int v129; // [esp+14h] [ebp-84h]
  unsigned int *v130; // [esp+18h] [ebp-80h] BYREF
  int v131; // [esp+1Ch] [ebp-7Ch]
  unsigned int v132; // [esp+20h] [ebp-78h]
  int *v133; // [esp+24h] [ebp-74h]
  unsigned int v134; // [esp+28h] [ebp-70h]
  unsigned int v135; // [esp+2Ch] [ebp-6Ch]
  int *v136; // [esp+30h] [ebp-68h]
  int v137; // [esp+34h] [ebp-64h]
  unsigned int v138; // [esp+38h] [ebp-60h]
  unsigned int v139; // [esp+3Ch] [ebp-5Ch]
  int v140; // [esp+40h] [ebp-58h]
  _BYTE *v141; // [esp+44h] [ebp-54h]
  int v142; // [esp+48h] [ebp-50h]
  unsigned int v143; // [esp+4Ch] [ebp-4Ch]
  char v144; // [esp+5Fh] [ebp-39h] BYREF
  char *v145; // [esp+60h] [ebp-38h] BYREF
  _BYTE *v146; // [esp+64h] [ebp-34h] BYREF
  int v147[4]; // [esp+68h] [ebp-30h] BYREF
  char *v148; // [esp+78h] [ebp-20h]
  int v149; // [esp+7Ch] [ebp-1Ch]
  int savedregs; // [esp+98h] [ebp+0h] BYREF

  v131 = a1;
  v143 = a3;
  v142 = 12 * a3;
  v6 = alloca(12 * a3 + 39);
  v128 = (int)&v124;
  v124 = 0;
  v125 = a1;
  v126 = &v127;
  LOBYTE(v141) = *(_BYTE *)(a1 + 404);
  *(_BYTE *)(a1 + 404) = (unsigned __int8)v141 & 0x9F | 0x20;
  if ( a3 )
  {
    v7 = &v130;
    v8 = &a2[a3];
    v9 = a2;
    do
    {
      v10 = *v9;
      *(v7 - 3) = 0;
      ++v9;
      *(v7 - 1) = (unsigned int *)v7;
      v7 += 3;
      *(v7 - 5) = (unsigned int *)v10;
      *(_BYTE *)(v10 + 404) = *(_BYTE *)(v10 + 404) & 0x9F | 0x20;
    }
    while ( v8 != v9 );
    v11 = v142;
    v12 = v125;
    v134 = v143 + 1;
  }
  else
  {
    v12 = v131;
    v11 = 0;
    v134 = 1;
  }
  v145 = 0;
  v136 = &v124;
  v139 = (unsigned int)&v124 + v11;
  *(int **)((char *)&v126 + v11) = 0;
  v132 = 0;
  v133 = 0;
  v137 = v12;
  v130 = (unsigned int *)__readgsdword(0xFFFFFFE8);
  __writegsdword(0xFFFFFFE8, 0);
  while ( 1 )
  {
    *v136 = 1;
    v142 = *(_DWORD *)(v137 + 348);
    if ( v142 )
    {
      v142 = 0;
    }
    else if ( !*(_DWORD *)(v137 + 496) && v131 != v137 )
    {
      v105 = *(unsigned __int16 *)(v137 + 346);
      if ( (_WORD)v105 )
      {
        v106 = 4 * v105;
        v142 = (int)v133;
        if ( v106 > v132 )
        {
          v107 = (v106 + 15) & 0xFFFFFFF0;
          v108 = alloca((v107 + 30) & 0xFFFF0);
          if ( v133 == (int *)((char *)&v124 + v107) )
          {
            v132 += v107;
            v133 = &v124;
            v142 = (int)&v124;
          }
          else
          {
            v142 = (int)&v124;
            v132 = v107;
            v133 = &v124;
          }
        }
      }
    }
    if ( !*(_DWORD *)(v137 + 36) && !*(_DWORD *)(v137 + 240) && !*(_DWORD *)(v137 + 232) )
      break;
    v13 = v137;
    v14 = *(_DWORD *)(v137 + 52);
    v147[0] = v137;
    v15 = *(_BYTE **)(v14 + 4);
    v147[1] = a5;
    v141 = v15;
    v147[3] = (int)v15;
    v147[2] = a6;
    v16 = *(int **)(v137 + 8);
    v17 = *v16;
    if ( *v16 )
    {
      v143 = 0;
      v135 = (unsigned int)v136;
      while ( 1 )
      {
        if ( v17 == 1 )
        {
          v19 = &v141[v16[1]];
          v20 = j_strchr(v19, 36);
          if ( v20 )
          {
            v138 = dl_dst_count(v20, 0);
            if ( v138 )
            {
              if ( _libc_enable_secure )
                dl_signal_error(0, v19, 0, a4, "DST not allowed in SUID/SGID programs");
              v78 = strlen(v19);
              origin = *(_BYTE **)(v13 + 424);
              if ( origin )
              {
                if ( origin != (_BYTE *)-1 )
                  goto LABEL_88;
LABEL_110:
                v80 = 0;
              }
              else
              {
                if ( **(_BYTE **)(v13 + 4) )
                  _assert_fail("(l)->l_name[0] == '\\0' || IS_RTLD (l)", "dl-deps.c", 249, "_dl_map_object_deps");
                v140 = v78;
                origin = (_BYTE *)dl_get_origin();
                *(_DWORD *)(v13 + 424) = origin;
                v78 = v140;
                if ( (unsigned int)(origin - 1) > 0xFFFFFFFD )
                  goto LABEL_110;
LABEL_88:
                v140 = v78;
                v80 = strlen(origin);
                v78 = v140;
              }
              v81 = 5;
              if ( (unsigned int)dl_platformlen >= 5 )
                v81 = dl_platformlen;
              if ( v81 >= v80 )
                v80 = v81;
              v82 = alloca(v78 + v138 * (v80 - 4) + 15);
              v83 = dl_dst_substitute(v13, v19, (char *)&v124, 0);
              if ( !*v83 )
                goto LABEL_106;
              v19 = v83;
            }
          }
          v148 = v19;
          v21 = dl_catch_error(
                  &v146,
                  &v145,
                  &v144,
                  (int)&savedregs,
                  (int)v16,
                  (int)v19,
                  (void (__cdecl *)(int))openaux,
                  (int)v147);
          v22 = v145;
          if ( v145 )
            goto LABEL_111;
          v23 = v149;
          if ( (*(_BYTE *)(v149 + 404) & 0x60) == 0 )
          {
            ++v134;
            v122 = v149;
            v121 = 0;
            v123 = 0;
            *(_DWORD *)(v139 + 8) = &v121;
            v24 = *(_BYTE *)(v23 + 404);
            v139 = (unsigned int)&v121;
            *(_BYTE *)(v23 + 404) = v24 & 0x9F | 0x20;
          }
          if ( v142 )
          {
            v18 = v143;
            *(_DWORD *)(v142 + 4 * v143) = v23;
            v143 = v18 + 1;
          }
          goto LABEL_13;
        }
        if ( (v17 & 0xFFFFFFFD) != 2147483645 )
          goto LABEL_13;
        v19 = &v141[v16[1]];
        v25 = j_strchr(v19, 36);
        if ( v25 )
        {
          v140 = dl_dst_count(v25, 0);
          if ( v140 )
            break;
        }
        v148 = v19;
        if ( (dl_debug_mask & 1) != 0 )
          goto LABEL_151;
LABEL_22:
        v21 = dl_catch_error(
                &v146,
                &v145,
                &v144,
                (int)&savedregs,
                (int)v16,
                (int)v19,
                (void (__cdecl *)(int))openaux,
                (int)v147);
        v22 = v145;
        if ( v145 )
        {
          if ( *v16 != 2147483645 )
          {
LABEL_111:
            v129 = v21;
            v143 = (unsigned int)v22;
            v89 = strlen(v22);
            v90 = alloca(v89 + 16);
            v91 = memcpy(&v124, (_BYTE *)v143, v89 + 1);
            v92 = strlen(v146);
            v93 = alloca(v92 + 16);
            v146 = memcpy(&v124, v146, v92 + 1);
            if ( v144 )
              free(v143);
            v145 = (char *)v91;
            v94 = -1;
            if ( v129 )
              v94 = v129;
            v129 = v94;
            if ( !__readgsdword(0xFFFFFFE8) )
            {
LABEL_116:
              if ( v130 )
                __writegsdword(0xFFFFFFE8, (unsigned int)v130);
            }
            goto LABEL_44;
          }
          if ( v144 )
            free(v145);
LABEL_13:
          v16 += 2;
          v17 = *v16;
          if ( !*v16 )
            goto LABEL_35;
        }
        else
        {
          v26 = v135;
          v121 = *(_DWORD *)v135;
          v122 = *(_DWORD *)(v135 + 4);
          v123 = *(_DWORD *)(v135 + 8);
          v27 = v149;
          *(_DWORD *)v135 = 0;
          *(_DWORD *)(v26 + 4) = v27;
          if ( v142 )
          {
            v28 = v143;
            *(_DWORD *)(v142 + 4 * v143) = v27;
            v143 = v28 + 1;
          }
          if ( (*(_BYTE *)(v27 + 404) & 0x60) != 0 )
          {
            for ( i = &v121; ; i = (int *)i[2] )
            {
              v102 = i[2];
              if ( !v102 )
              {
                v103 = v135;
                *(_DWORD *)v135 = v121;
                *(_DWORD *)(v103 + 4) = v122;
                *(_DWORD *)(v103 + 8) = v123;
                goto LABEL_13;
              }
              if ( v27 == *(_DWORD *)(v102 + 4) )
                break;
            }
            *(_DWORD *)(v135 + 8) = &v121;
            v140 = i[2];
            v104 = v139;
            if ( v140 == v139 )
              v104 = (int)i;
            v139 = v104;
            i[2] = *(_DWORD *)(v140 + 8);
            v29 = *(_DWORD *)(v27 + 16);
            if ( !v29 )
              goto LABEL_28;
LABEL_27:
            *(_DWORD *)(v29 + 12) = *(_DWORD *)(v27 + 12);
            goto LABEL_28;
          }
          v29 = *(_DWORD *)(v27 + 16);
          ++v134;
          *(_DWORD *)(v135 + 8) = &v121;
          *(_BYTE *)(v27 + 404) = *(_BYTE *)(v27 + 404) & 0x9F | 0x20;
          if ( v29 )
            goto LABEL_27;
LABEL_28:
          v30 = *(_DWORD *)(v27 + 12);
          if ( v30 )
            *(_DWORD *)(v30 + 16) = v29;
          v31 = v122;
          *(_DWORD *)(v27 + 16) = *(_DWORD *)(v122 + 16);
          *(_DWORD *)(v31 + 16) = v27;
          v32 = *(_DWORD *)(v27 + 16);
          if ( v32 )
            *(_DWORD *)(v32 + 12) = v27;
          *(_DWORD *)(v27 + 12) = v31;
          v33 = (int *)v139;
          v34 = v135;
          v135 = (unsigned int)&v121;
          if ( v139 == v34 )
            v33 = &v121;
          v16 += 2;
          v139 = (unsigned int)v33;
          v17 = *v16;
          if ( !*v16 )
            goto LABEL_35;
        }
      }
      if ( _libc_enable_secure )
        dl_signal_error(0, v19, 0, a4, "DST not allowed in SUID/SGID programs");
      v138 = strlen(v19);
      v84 = *(_BYTE **)(v13 + 424);
      if ( v84 )
      {
        if ( v84 != (_BYTE *)-1 )
          goto LABEL_99;
LABEL_198:
        v85 = 0;
      }
      else
      {
        if ( **(_BYTE **)(v13 + 4) )
          _assert_fail("(l)->l_name[0] == '\\0' || IS_RTLD (l)", "dl-deps.c", 301, "_dl_map_object_deps");
        v84 = (_BYTE *)dl_get_origin();
        *(_DWORD *)(v13 + 424) = v84;
        if ( (unsigned int)(v84 - 1) > 0xFFFFFFFD )
          goto LABEL_198;
LABEL_99:
        v85 = strlen(v84);
      }
      v86 = 5;
      if ( (unsigned int)dl_platformlen >= 5 )
        v86 = dl_platformlen;
      if ( v86 >= v85 )
        v85 = v86;
      v87 = alloca(v138 + v140 * (v85 - 4) + 15);
      v88 = dl_dst_substitute(v13, v19, (char *)&v124, 0);
      if ( !*v88 )
      {
        if ( *v16 == 2147483645 )
          dl_signal_error(0, v19, 0, a4, "empty dynamic string token substitution");
LABEL_106:
        if ( (dl_debug_mask & 1) != 0 )
          dl_debug_printf("cannot load auxiliary `%s' because of empty dynamic string token substitution\n", v19);
        goto LABEL_13;
      }
      v19 = v88;
      v148 = v88;
      if ( (dl_debug_mask & 1) == 0 )
        goto LABEL_22;
LABEL_151:
      v109 = *(const char **)(v13 + 4);
      if ( !*v109 )
      {
        v109 = (const char *)program_invocation_short_name;
        if ( !program_invocation_short_name )
          v109 = "<main program>";
      }
      dl_debug_printf("load auxiliary object=%s requested by file=%s\n", v19, v109);
      goto LABEL_22;
    }
    v143 = 0;
LABEL_35:
    if ( v142 )
    {
      v35 = v143 + 1;
      v36 = 4 * v143;
      v37 = 8 * (v143 + 1) + 4;
LABEL_37:
      *(_DWORD *)(v142 + v36) = 0;
      v38 = (_BYTE *)malloc(v37);
      if ( !v38 )
        dl_signal_error(12, *(_BYTE **)(v131 + 4), 0, a4, "cannot allocate dependency list");
      v39 = v137;
      v40 = 4 * v35;
      *(_DWORD *)v38 = v137;
      memcpy(v38 + 4, (_BYTE *)v142, v40);
      memcpy(&v38[4 * v143 + 8], v38, v40);
      *(_BYTE *)(v39 + 406) |= 1u;
      *(_DWORD *)(v39 + 496) = v38;
    }
    if ( *v136 )
      goto LABEL_40;
LABEL_149:
    v137 = v136[1];
  }
  if ( v142 )
  {
    v37 = 12;
    v36 = 0;
    v35 = 1;
    v143 = 0;
    goto LABEL_37;
  }
LABEL_40:
  v41 = v136;
  while ( 1 )
  {
    v41 = (int *)v41[2];
    if ( !v41 )
      break;
    if ( !*v41 )
    {
      v136 = v41;
      goto LABEL_149;
    }
  }
  v129 = 0;
  if ( !__readgsdword(0xFFFFFFE8) )
    goto LABEL_116;
LABEL_44:
  v127 = *(_DWORD *)(v131 + 496);
  if ( v127 )
  {
    LOBYTE(v143) = *(_BYTE *)(v131 + 404);
    if ( (v143 & 3) == 2 )
    {
      if ( *(_DWORD *)(v131 + 348) )
        _assert_fail("map->l_searchlist.r_list == NULL", "dl-deps.c", 493, "_dl_map_object_deps");
    }
    else
    {
      v127 = 0;
    }
  }
  v141 = (_BYTE *)malloc(8 * v134 + 4);
  if ( !v141 )
LABEL_183:
    dl_signal_error(12, *(_BYTE **)(v131 + 4), 0, a4, "cannot allocate symbol search list");
  v42 = 0;
  v43 = v131;
  v44 = &v141[4 * v134 + 4];
  v45 = v128;
  *(_DWORD *)(v131 + 352) = v134;
  v46 = v43;
  *(_DWORD *)(v43 + 348) = v44;
  do
  {
    while ( 1 )
    {
      v47 = *(_DWORD *)(v45 + 4);
      if ( a5 )
      {
        if ( (*(_BYTE *)(v47 + 405) & 2) != 0 )
          break;
      }
      *(_DWORD *)&v44[4 * v42++] = v47;
      *(_BYTE *)(*(_DWORD *)(v45 + 4) + 404) &= 0x9Fu;
      v45 = *(_DWORD *)(v45 + 8);
      if ( !v45 )
        goto LABEL_53;
    }
    --*(_DWORD *)(v46 + 352);
    *(_BYTE *)(v47 + 404) &= 0x9Fu;
    v45 = *(_DWORD *)(v45 + 8);
  }
  while ( v45 );
LABEL_53:
  v135 = v42;
  if ( (dl_debug_mask & 0x800) != 0 && (void *)v131 == dl_ns && v42 )
  {
    v111 = v44;
    v112 = v141;
    v143 = 0;
    do
    {
      v113 = v111[v143];
      if ( v131 != v113 )
      {
        v114 = *(_DWORD *)(v113 + 464);
        if ( !v114 || !*(_DWORD *)(v114 + 4) )
        {
          if ( *(_DWORD *)(v113 + 240) || *(_DWORD *)(v113 + 232) )
            dl_signal_error(22, *(_BYTE **)(v113 + 4), 0, a4, "Filters not supported with LD_TRACE_PRELINKING");
          v115 = dl_build_local_scope(v112, v111[v143]);
          v116 = v115;
          if ( v115 > v135 )
            _assert_fail("cnt <= nlist", "dl-deps.c", 549, "_dl_map_object_deps");
          if ( v115 )
          {
            *(_BYTE *)(*v112 + 404) &= 0x9Fu;
            v117 = 0;
            while ( v116 != ++v117 )
            {
              *(_BYTE *)(v112[v117] + 404) &= 0x9Fu;
              if ( *(_DWORD *)(v112[v117] + 96) )
                *(_BYTE *)(v113 + 405) |= 0x80u;
            }
          }
          v142 = 4 * v116 + 8;
          v118 = malloc(v142);
          *(_DWORD *)(v113 + 464) = v118;
          if ( !v118 )
            goto LABEL_183;
          v119 = (_BYTE *)(v142 - 8);
          *(_DWORD *)(v118 + 4) = v116;
          *(_DWORD *)v118 = v118 + 8;
          memcpy((_BYTE *)(v118 + 8), v112, (unsigned int)v119);
          v111 = *(_DWORD **)(v131 + 348);
        }
      }
      ++v143;
    }
    while ( v143 != v135 );
    v44 = v111;
    if ( v131 != *v111 )
LABEL_175:
      _assert_fail("map->l_searchlist.r_list[0] == map", "dl-deps.c", 574, "_dl_map_object_deps");
  }
  else if ( v131 != *(_DWORD *)v44 )
  {
    goto LABEL_175;
  }
  v143 = *(_DWORD *)(v131 + 500);
  if ( v143 )
  {
    if ( v135 <= 1 )
    {
      v51 = (_BYTE *)(v143 + 4);
      if ( *(_DWORD *)v143 )
      {
LABEL_60:
        v130 = 0;
        v52 = 0;
        v53 = v51;
        v139 = (unsigned int)v44;
        do
        {
          while ( 1 )
          {
            v54 = 4 * v52;
            if ( (*(_BYTE *)(*(_DWORD *)&v53[4 * v52] + 404) & 0x60) != 0 )
            {
              v55 = (unsigned int *)malloc(4 * *(_DWORD *)(v131 + 504) + 4);
              v130 = v55;
              if ( v55 )
                break;
            }
            if ( *(_DWORD *)v143 <= ++v52 )
              goto LABEL_71;
          }
          memcpy((_BYTE *)v55 + 4, v53, 4 * v52);
          v142 = v52 + 1;
          v56 = *(_DWORD *)v143;
          v57 = v52 + 1 < *(_DWORD *)v143;
          v140 = *(_DWORD *)v143;
          if ( v57 )
          {
            v58 = v52;
            v138 = v52;
            v59 = v130;
            v60 = (int)&v53[v54 + 4];
            do
            {
              if ( (*(_BYTE *)(*(_DWORD *)v60 + 404) & 0x60) == 0 )
                v59[++v58] = *(_DWORD *)v60;
              v60 += 4;
            }
            while ( (_BYTE *)v60 != &v53[4 * v56] );
            v61 = (_BYTE *)(v142 + v140 - 1 - v138);
          }
          else
          {
            v58 = v52;
            v61 = (_BYTE *)v142;
          }
          v52 = (unsigned int)(v61 + 1);
          *v130 = v58;
        }
        while ( *(_DWORD *)v143 > v52 );
LABEL_71:
        v44 = (_BYTE *)v139;
        if ( v135 > 1 )
          goto LABEL_72;
      }
      else
      {
        v130 = 0;
      }
      v128 = 4 * v135;
      memcpy(v141, v44, 4 * v135);
    }
    else
    {
      v48 = (int *)(v44 + 4);
      v49 = (int *)&v44[4 * v135];
      do
      {
        v50 = *v48++;
        *(_BYTE *)(v50 + 404) = *(_BYTE *)(v50 + 404) & 0x9F | 0x20;
      }
      while ( v49 != v48 );
      v51 = (_BYTE *)(v143 + 4);
      if ( *(_DWORD *)v143 )
        goto LABEL_60;
      v130 = 0;
LABEL_72:
      v62 = v135;
      v63 = 1;
      do
      {
        v64 = *(_DWORD *)&v44[4 * v63++];
        *(_BYTE *)(v64 + 404) &= 0x9Fu;
      }
      while ( v63 < v62 );
      v128 = 4 * v135;
      memcpy(v141, v44, 4 * v135);
LABEL_75:
      v65 = v135;
      v126 = &v124;
      v66 = alloca(2 * v135 + 1);
      v140 = (int)&v124;
      j_memset(&v124, 0, 2 * v135);
      v142 = 2;
      v133 = (int *)(v65 - 1);
      v67 = &v141[4 * v65 - 4];
      v68 = 1;
      v132 = (unsigned int)v67;
      while ( 1 )
      {
LABEL_76:
        v69 = (int *)(v140 + 2 * v68);
        LOWORD(v134) = *(_WORD *)v69 + 1;
        *(_WORD *)v69 = v134;
        v139 = 4 * v68;
        v138 = (unsigned int)&v141[4 * v68];
        v70 = *(_DWORD *)v138;
        if ( v68 < (unsigned int)v133 )
        {
          v71 = v132;
          v143 = (unsigned int)v133;
          do
          {
            v72 = *(int **)(*(_DWORD *)v71 + 496);
            if ( v72 )
            {
              while ( 1 )
              {
                v73 = *v72;
                if ( !*v72 )
                  break;
                ++v72;
                if ( v70 == v73 )
                {
                  v136 = v69;
                  v137 = v71;
                  v74 = v143 - v68;
                  j_memmove(v138, &v141[v139 + 4], 4 * (v143 - v68));
                  v75 = (int)v136;
                  v76 = v135;
                  *(_DWORD *)v137 = v70;
                  if ( *(unsigned __int16 *)(v75 + 2) > v76 - v68 )
                  {
                    v68 = v142;
                    goto LABEL_83;
                  }
                  v100 = v140;
                  j_memmove(v140 + 2 * v142 - 2, v140 + 2 * v142, 2 * v74);
                  *(_WORD *)(v100 + 2 * v143) = v134;
                  goto LABEL_76;
                }
              }
            }
            --v143;
            v71 -= 4;
          }
          while ( v68 < v143 );
        }
        v68 = v142;
        if ( v142 == v135 )
          break;
LABEL_83:
        v77 = v142;
        j_memset(v140 + 2 * v142, 0, 2 * (v135 - v142));
        v142 = v77 + 1;
      }
    }
  }
  else
  {
    v110 = v135;
    v128 = 4 * v135;
    memcpy(v141, v44, 4 * v135);
    v130 = 0;
    if ( v110 > 1 )
      goto LABEL_75;
  }
  v95 = v141;
  *(_DWORD *)&v141[v128] = 0;
  v96 = v131;
  *(_BYTE *)(v131 + 406) |= 1u;
  *(_DWORD *)(v96 + 496) = v95;
  if ( v130 )
  {
    v97 = v96;
    v98 = *(_DWORD *)(v96 + 500);
    *(_DWORD *)(v97 + 500) = v130;
    dl_scope_free(v98);
  }
  result = v127;
  if ( v127 )
    result = dl_scope_free(v127);
  if ( v129 )
  {
    v120 = 0;
    if ( v129 != -1 )
      v120 = v129;
    dl_signal_error(v120, v146, 0, a4, v145);
  }
  return result;
}
// 80481D0: using guessed type int __cdecl j_memmove(_DWORD, _DWORD, _DWORD);
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);
// 8048290: using guessed type int __cdecl j_strchr(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EAFCC: using guessed type int _libc_enable_secure;
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80EBA40: using guessed type void *dl_ns;
// 80ECC5C: using guessed type int dl_platformlen;
// 80ECC60: using guessed type int dl_debug_mask;

//----- (080A1A10) --------------------------------------------------------
int (*__usercall dl_fixup@<eax>(unsigned int a1@<eax>, int a2@<edx>, long double a3@<st0>))(void)
{
  _DWORD *v4; // ebp
  unsigned int v5; // edx
  unsigned int v6; // edi
  int v7; // ecx
  int v8; // esi
  int v9; // eax
  int (**v10)(void); // ebp
  int v11; // edx
  int v12; // edx
  int v13; // esi
  int *v14; // edi
  int v15; // eax
  int (*result)(void); // eax
  int v18; // [esp+Ch] [ebp-30h]
  int v19[8]; // [esp+1Ch] [ebp-20h] BYREF

  v18 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  v4 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 124) + 4) + a2);
  v5 = v4[1];
  v6 = v5 >> 8;
  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4) + 16 * (v5 >> 8);
  v8 = *(_DWORD *)a1;
  v9 = *(_DWORD *)a1 + *v4;
  v19[0] = v7;
  if ( (_BYTE)v5 != 7 )
    _assert_fail("ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT", "dl-runtime.c", 79, "_dl_fixup");
  v10 = (int (**)(void))v9;
  if ( (*(_BYTE *)(v7 + 13) & 3) != 0 )
  {
    v15 = v8;
  }
  else
  {
    v11 = *(_DWORD *)(a1 + 228);
    if ( v11 )
    {
      v12 = *(_DWORD *)(a1 + 368) + 16 * (*(_WORD *)(*(_DWORD *)(v11 + 4) + 2 * v6) & 0x7FFF);
      if ( !*(_DWORD *)(v12 + 4) )
        v12 = 0;
    }
    else
    {
      v12 = 0;
    }
    v13 = 1;
    if ( __readgsdword(0xCu) )
    {
      __writegsdword(0x1Cu, 1u);
      v13 = 5;
    }
    v14 = (int *)dl_lookup_symbol_x(
                   (unsigned __int8 *)(*(_DWORD *)v7 + v18),
                   a1,
                   v19,
                   a3,
                   *(int ***)(a1 + 460),
                   (const char **)v12,
                   1,
                   v13,
                   0);
    if ( __readgsdword(0xCu) && _InterlockedExchange(MK_FP(__GS__, 28), 0) == 2 )
      dl_sysinfo(129);
    v7 = v19[0];
    if ( !v19[0] )
    {
      result = 0;
      goto LABEL_14;
    }
    if ( v14 )
      v15 = *v14;
    else
      v15 = 0;
  }
  result = (int (*)(void))(*(_DWORD *)(v7 + 4) + v15);
  if ( (*(_BYTE *)(v7 + 12) & 0xF) == 10 )
    result = (int (*)(void))result();
LABEL_14:
  if ( !dl_bind_not )
    *v10 = result;
  return result;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80ECC78: using guessed type int dl_bind_not;
// 80A1A10: using guessed type int var_20[8];

//----- (080A1BB0) --------------------------------------------------------
int (*__userpurge dl_profile_fixup@<eax>(
        unsigned int a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        long double a4@<st0>,
        int a5,
        _DWORD *a6))(void)
{
  int v6; // ecx
  int (*v7)(void); // ebp
  int v8; // esi
  unsigned int v9; // edx
  unsigned int v10; // ebx
  int v11; // ecx
  int v12; // edx
  int v13; // edx
  int v14; // edi
  int (**v15)(void); // edi
  int (**v19)(void); // [esp+Ch] [ebp-30h]
  int v20[8]; // [esp+1Ch] [ebp-20h] BYREF

  v6 = *(_DWORD *)(a1 + 416);
  if ( !v6 )
  {
    *a6 = -1;
    return dl_fixup(a1, a2, a4);
  }
  v7 = *(int (**)(void))(v6 + 20 * (a2 >> 3));
  v19 = (int (**)(void))(v6 + 20 * (a2 >> 3));
  if ( !v7 )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
    v9 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 124) + 4) + a2 + 4);
    v10 = v9 >> 8;
    v11 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4) + 16 * (v9 >> 8);
    v20[0] = v11;
    if ( (_BYTE)v9 != 7 )
      _assert_fail("ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT", "dl-runtime.c", 203, "_dl_profile_fixup");
    if ( (*(_BYTE *)(v11 + 13) & 3) != 0 )
    {
      v7 = (int (*)(void))(*(_DWORD *)a1 + *(_DWORD *)(v11 + 4));
      if ( (*(_BYTE *)(v11 + 12) & 0xF) != 10 )
        goto LABEL_15;
    }
    else
    {
      v12 = *(_DWORD *)(a1 + 228);
      if ( v12 )
      {
        v13 = *(_DWORD *)(a1 + 368) + 16 * (*(_WORD *)(*(_DWORD *)(v12 + 4) + 2 * v10) & 0x7FFF);
        if ( !*(_DWORD *)(v13 + 4) )
          v13 = 0;
      }
      else
      {
        v13 = 0;
      }
      v14 = 1;
      if ( __readgsdword(0xCu) )
      {
        __writegsdword(0x1Cu, 1u);
        v14 = 5;
      }
      v15 = (int (**)(void))dl_lookup_symbol_x(
                              (unsigned __int8 *)(*(_DWORD *)v11 + v8),
                              a1,
                              v20,
                              a4,
                              *(int ***)(a1 + 460),
                              (const char **)v13,
                              1,
                              v14,
                              0);
      if ( __readgsdword(0xCu) && _InterlockedExchange(MK_FP(__GS__, 28), 0) == 2 )
        dl_sysinfo(129);
      if ( !v20[0] )
        goto LABEL_15;
      if ( v15 )
        v7 = *v15;
      v7 = (int (*)(void))((char *)v7 + *(_DWORD *)(v20[0] + 4));
      if ( (*(_BYTE *)(v20[0] + 12) & 0xF) != 10 )
        goto LABEL_15;
    }
    v7 = (int (*)(void))v7();
LABEL_15:
    if ( !dl_bind_not )
      *v19 = v7;
  }
  *a6 = -1;
  dl_mcount(a3, (int)v7);
  return v7;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80ECC78: using guessed type int dl_bind_not;
// 80A1BB0: using guessed type int var_20[8];

//----- (080A1DB0) --------------------------------------------------------
int __usercall call_init_part_0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  char v6; // di
  const char *v7; // ecx
  _DWORD *v8; // edi
  int v9; // eax
  int v10; // edx
  int v11; // edi
  int i; // ebp
  int v13; // [esp+Ch] [ebp-20h]

  v6 = *(_BYTE *)(result + 404) | 8;
  *(_BYTE *)(result + 404) = v6;
  v7 = *(const char **)(result + 4);
  if ( !*v7 && (v6 & 3) == 0 )
    return result;
  v8 = (_DWORD *)result;
  v9 = *(_DWORD *)(result + 80);
  if ( v9 )
  {
    if ( (dl_debug_mask & 2) == 0 )
    {
LABEL_4:
      ((void (__cdecl *)(int, int, int))(*v8 + *(_DWORD *)(v9 + 4)))(a2, a3, a4);
      result = v8[33];
      goto LABEL_5;
    }
  }
  else
  {
    result = v8[33];
    if ( !result )
      return result;
    if ( (dl_debug_mask & 2) == 0 )
      goto LABEL_6;
  }
  if ( !*v7 )
  {
    v7 = (const char *)program_invocation_short_name;
    if ( !program_invocation_short_name )
      v7 = "<main program>";
  }
  dl_debug_printf("\ncalling init: %s\n\n", v7);
  v9 = v8[20];
  if ( v9 )
    goto LABEL_4;
  result = v8[33];
LABEL_5:
  if ( !result )
    return result;
LABEL_6:
  v10 = v8[35];
  v11 = *(_DWORD *)(result + 4) + *v8;
  v13 = *(_DWORD *)(v10 + 4) >> 2;
  if ( v13 )
  {
    for ( i = 0; i != v13; ++i )
      result = (*(int (__cdecl **)(int, int, int))(v11 + 4 * i))(a2, a3, a4);
  }
  return result;
}
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80ECC60: using guessed type int dl_debug_mask;

//----- (080A1EC0) --------------------------------------------------------
int __userpurge dl_init@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  int v6; // esi
  int v7; // ebx
  int result; // eax
  int v9; // ebx
  int v10; // esi
  int v11; // ebx
  int v12; // esi
  const char *v13; // eax
  int v15; // [esp+8h] [ebp-24h]

  v6 = a1[40];
  v7 = a1[41];
  result = dl_initfirst;
  if ( dl_initfirst )
  {
    if ( (*(_BYTE *)(dl_initfirst + 404) & 8) == 0 )
      result = call_init_part_0(dl_initfirst, a2, a3, a4);
    dl_initfirst = 0;
  }
  if ( v6 )
  {
    if ( v7 )
    {
      result = *(_DWORD *)(v7 + 4) >> 2;
      v15 = result;
      if ( result )
      {
        if ( (dl_debug_mask & 2) != 0 )
        {
          v13 = (const char *)a1[1];
          if ( !*v13 )
          {
            v13 = (const char *)program_invocation_short_name;
            if ( !program_invocation_short_name )
              v13 = "<main program>";
          }
          dl_debug_printf("\ncalling preinit: %s\n\n", v13);
        }
        v11 = *(_DWORD *)(v6 + 4) + *a1;
        v12 = 0;
        do
          result = (*(int (__cdecl **)(int, int, int))(v11 + 4 * v12++))(a2, a3, a4);
        while ( v15 != v12 );
      }
    }
  }
  v9 = a1[88];
  v10 = 4 * v9 - 4;
  while ( v9 )
  {
    result = *(_DWORD *)(a1[124] + v10);
    if ( (*(_BYTE *)(result + 404) & 8) == 0 )
      result = call_init_part_0(result, a2, a3, a4);
    --v9;
    v10 -= 4;
  }
  return result;
}
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80ECC60: using guessed type int dl_debug_mask;
// 80ECCB8: using guessed type int dl_initfirst;

//----- (080A1FF0) --------------------------------------------------------
_DWORD *__userpurge dl_sort_fini@<eax>(_DWORD *result@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  _DWORD *v4; // esi
  int v6; // edx
  void *v7; // esp
  int v8; // eax
  int v9; // edi
  char *v10; // edx
  int v11; // eax
  unsigned int v12; // eax
  _WORD *v13; // esi
  int v14; // ecx
  _DWORD *v15; // ebx
  int v16; // ecx
  _DWORD *v17; // eax
  _DWORD *v18; // edx
  int v19; // ecx
  int v20; // edx
  char v21; // bl
  _DWORD *v22; // eax
  int *v23; // ebx
  _DWORD *v24; // edx
  int v25; // eax
  int *v26; // edx
  int v27; // eax
  int v28; // [esp-4Ch] [ebp-4Ch] BYREF
  int v29; // [esp-48h] [ebp-48h]
  int v30; // [esp-44h] [ebp-44h]
  int v31; // [esp-40h] [ebp-40h]
  int v32; // [esp-3Ch] [ebp-3Ch]
  unsigned int v33; // [esp-38h] [ebp-38h]
  __int16 v34; // [esp-32h] [ebp-32h]
  _DWORD *v35; // [esp-30h] [ebp-30h]
  _DWORD *v36; // [esp-2Ch] [ebp-2Ch]
  int *v37; // [esp-28h] [ebp-28h]
  int v38; // [esp-24h] [ebp-24h]
  unsigned int v39; // [esp-20h] [ebp-20h]

  if ( a2 != 1 )
  {
    v4 = result;
    v36 = result;
    v38 = a2;
    v6 = 2 * a2;
    v31 = a3;
    v28 = (int)&v28;
    v7 = alloca(v6 + 1);
    v39 = a4 == 0;
    v37 = &v28;
    j_memset(&v28, 0, v6);
    v8 = (int)&v4[a2 - 1];
    v9 = (a4 == 0) + 1;
    v29 = v8;
    while ( 1 )
    {
LABEL_5:
      v12 = v39;
      v13 = (_WORD *)v37 + v39;
      v34 = *v13 + 1;
      *v13 = v34;
      v14 = 4 * v12;
      result = &v36[v12];
      v15 = (_DWORD *)*result;
      v35 = result;
      if ( v15 == (_DWORD *)v15[5] && v15[131] != -1 )
      {
        result = (_DWORD *)(v38 - 1);
        v33 = v38 - 1;
        if ( v39 < v38 - 1 )
        {
          v30 = v14;
          v32 = v29;
          do
          {
            v16 = *(_DWORD *)v32;
            v17 = *(_DWORD **)(*(_DWORD *)v32 + 496);
            if ( v17 )
            {
              while ( 1 )
              {
                v18 = (_DWORD *)*v17;
                if ( !*v17 )
                  break;
                ++v17;
                if ( v15 == v18 )
                {
LABEL_12:
                  v19 = v30;
                  v30 = v33 - v39;
                  j_memmove(v35, (char *)v36 + v19 + 4, 4 * (v33 - v39));
                  v20 = v31;
                  *(_DWORD *)v32 = v15;
                  if ( v20 )
                  {
                    v21 = *(_BYTE *)(v20 + v39);
                    v31 = v20;
                    j_memmove(v20 + v39, v20 + v9, v30);
                    *(_BYTE *)(v31 + v33) = v21;
                  }
                  if ( (unsigned __int16)v13[1] > v38 - v39 )
                  {
                    v39 = v9;
                    goto LABEL_4;
                  }
                  v23 = v37;
                  j_memmove((char *)v37 + 2 * v9 - 2, (char *)v37 + 2 * v9, 2 * v30);
                  *((_WORD *)v23 + v33) = v34;
                  goto LABEL_5;
                }
              }
            }
            v22 = *(_DWORD **)(v16 + 500);
            if ( v22 )
            {
              v24 = v22 + 1;
              v25 = *v22 - 1;
              while ( v25 != -1 )
              {
                if ( v15 == (_DWORD *)v24[v25--] )
                {
                  v26 = (int *)v15[124];
                  if ( v26 )
                  {
                    while ( 1 )
                    {
                      v27 = *v26;
                      if ( !*v26 )
                        break;
                      ++v26;
                      if ( v16 == v27 )
                        goto LABEL_18;
                    }
                  }
                  goto LABEL_12;
                }
              }
            }
LABEL_18:
            --v33;
            v32 -= 4;
            result = (_DWORD *)v33;
          }
          while ( v39 < v33 );
        }
      }
      v39 = v9;
      if ( v38 == v9 )
        break;
LABEL_4:
      v10 = (char *)v37 + 2 * v9;
      v11 = v38 - v9++;
      j_memset(v10, 0, 2 * v11);
    }
  }
  return result;
}
// 80481D0: using guessed type int __cdecl j_memmove(_DWORD, _DWORD, _DWORD);
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);

//----- (080A2220) --------------------------------------------------------
int __usercall dl_fini@<eax>(long double a1@<st0>)
{
  int result; // eax
  unsigned int v2; // edx
  void *v3; // esp
  _DWORD *v4; // eax
  unsigned int v5; // ecx
  int v6; // ebx
  char v7; // al
  int v8; // eax
  int v9; // esi
  int v10; // eax
  void (**v11)(void); // edi
  void (**v12)(void); // esi
  int v13; // eax
  const char *v14; // eax
  _DWORD v15[3]; // [esp+0h] [ebp-38h] BYREF
  _DWORD *v16; // [esp+Ch] [ebp-2Ch]
  _DWORD *v17; // [esp+10h] [ebp-28h]
  int v18; // [esp+14h] [ebp-24h]
  int v19; // [esp+18h] [ebp-20h]
  int v20; // [esp+1Ch] [ebp-1Ch]

  result = dl_nns;
  v18 = dl_nns - 1;
  if ( dl_nns - 1 >= 0 )
  {
    v16 = (_DWORD *)(76 * dl_nns + 135182836);
    while ( 1 )
    {
      while ( 1 )
      {
        v2 = v16[1];
        if ( v2 )
          break;
        --v18;
        v16 -= 19;
        result = v18;
        if ( v18 == -1 )
          return result;
      }
      v15[2] = v15;
      v3 = alloca(4 * v2 + 3);
      v17 = v15;
      v4 = (_DWORD *)*v16;
      if ( *v16 )
      {
        v5 = 0;
        do
        {
          while ( (_DWORD *)v4[5] != v4 )
          {
            v4 = (_DWORD *)v4[3];
            if ( !v4 )
              goto LABEL_11;
          }
          if ( v2 <= v5 )
            _assert_fail(a1, (int)"i < nloaded", (int)"dl-fini.c", 177, "_dl_fini");
          v15[v5] = v4;
          v4[131] = v5++;
          ++v4[100];
          v4 = (_DWORD *)v4[3];
        }
        while ( v4 );
LABEL_11:
        v19 = v5;
      }
      else
      {
        v19 = 0;
      }
      if ( !v18 && v2 != v19 )
        _assert_fail(a1, (int)"ns != LM_ID_BASE || i == nloaded", (int)"dl-fini.c", 187, "_dl_fini");
      if ( v18 && v2 != v19 && v2 - 1 != v19 )
        _assert_fail(a1, (int)"ns == LM_ID_BASE || i == nloaded || i == nloaded - 1", (int)"dl-fini.c", 188, "_dl_fini");
      dl_sort_fini(v17, v19, 0, v18);
      v20 = 0;
      if ( v19 )
        break;
LABEL_27:
      --v18;
      v16 -= 19;
      result = v18;
      if ( v18 == -1 )
        return result;
    }
    while ( 1 )
    {
      v6 = v17[v20];
      v7 = *(_BYTE *)(v6 + 404);
      if ( (v7 & 8) == 0 )
        goto LABEL_26;
      *(_BYTE *)(v6 + 404) = v7 & 0xF7;
      v8 = *(_DWORD *)(v6 + 136);
      if ( v8 )
      {
        if ( (dl_debug_mask & 2) == 0 )
          goto LABEL_21;
      }
      else
      {
        v13 = *(_DWORD *)(v6 + 84);
        if ( !v13 )
          goto LABEL_26;
        if ( (dl_debug_mask & 2) == 0 )
        {
LABEL_25:
          ((void (*)(void))(*(_DWORD *)v6 + *(_DWORD *)(v13 + 4)))();
          goto LABEL_26;
        }
      }
      v14 = *(const char **)(v6 + 4);
      if ( !*v14 )
      {
        v14 = (const char *)program_invocation_short_name;
        if ( !program_invocation_short_name )
          v14 = "<main program>";
      }
      dl_debug_printf("\ncalling fini: %s [%lu]\n\n", v14, v18);
      v8 = *(_DWORD *)(v6 + 136);
      if ( v8 )
      {
LABEL_21:
        v9 = *(_DWORD *)v6 + *(_DWORD *)(v8 + 4);
        v10 = *(_DWORD *)(*(_DWORD *)(v6 + 144) + 4) >> 2;
        if ( v10 )
        {
          v11 = (void (**)(void))(v9 + 4 * v10 - 4);
          v12 = (void (**)(void))(v9 - 4);
          do
            (*v11--)();
          while ( v11 != v12 );
        }
      }
      v13 = *(_DWORD *)(v6 + 84);
      if ( v13 )
        goto LABEL_25;
LABEL_26:
      ++v20;
      --*(_DWORD *)(v6 + 400);
      if ( v20 == v19 )
        goto LABEL_27;
    }
  }
  return result;
}
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80EBA28: using guessed type int dl_nns;
// 80ECC60: using guessed type int dl_debug_mask;

//----- (080A24B0) --------------------------------------------------------
int __userpurge match_symbol@<eax>(
        int *a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        long double a4@<st0>,
        const char *a5,
        _DWORD *a6,
        int a7,
        int a8)
{
  _DWORD *v9; // ebx
  int v10; // ecx
  int v11; // eax
  int v12; // edx
  unsigned __int16 *v13; // edi
  int v14; // ebx
  int v15; // eax
  unsigned int v16; // eax
  int v17; // eax
  const char *v18; // ecx
  void *v19; // esp
  int *v20; // eax
  int *j; // esi
  const char *v23; // eax
  int v24; // esi
  char *v25; // edx
  const char *v26; // eax
  int v27; // eax
  const char *v28; // ecx
  void *v29; // esp
  int *v30; // eax
  int *k; // esi
  int v32; // esi
  int v33; // edi
  const char *v34; // edx
  void *v35; // esp
  int v36; // edi
  int *v37; // eax
  int v38; // esi
  int v39; // edi
  int i; // eax
  int v41; // edx
  void *v42; // esp
  int v43; // edi
  int *v44; // eax
  char *v45; // [esp-10h] [ebp-58h]
  int v46; // [esp+0h] [ebp-48h] BYREF
  int v47; // [esp+4h] [ebp-44h]
  int v48; // [esp+8h] [ebp-40h]
  int *v49; // [esp+Ch] [ebp-3Ch]
  const char *v50; // [esp+10h] [ebp-38h] BYREF
  _BYTE *v51; // [esp+14h] [ebp-34h]
  const char *v52; // [esp+18h] [ebp-30h]
  const char *v53; // [esp+1Ch] [ebp-2Ch] BYREF
  const char *v54; // [esp+20h] [ebp-28h]
  const char *v55; // [esp+24h] [ebp-24h]
  int *v56; // [esp+28h] [ebp-20h] BYREF
  int v57; // [esp+2Ch] [ebp-1Ch] BYREF

  v9 = a6;
  v49 = a1;
  v10 = *(_DWORD *)(a6[13] + 4);
  if ( (dl_debug_mask & 0x10) != 0 )
  {
    v48 = a6[6];
    v26 = (const char *)a6[1];
    if ( !*v26 )
    {
      v26 = (const char *)program_invocation_short_name;
      if ( !program_invocation_short_name )
        v26 = "<main program>";
    }
    v47 = v10;
    dl_debug_printf(
      "checking for version `%s' in file %s [%lu] required by file %s [%lu]\n",
      a5,
      v26,
      v48,
      (const char *)v49,
      a2);
    v11 = a6[45];
    v10 = v47;
    if ( v11 )
      goto LABEL_3;
  }
  else
  {
    v11 = a6[45];
    if ( v11 )
    {
LABEL_3:
      v12 = *(_DWORD *)(v11 + 4);
      if ( !v12 )
        _assert_fail("def_offset != 0", "dl-version.c", 107, "match_symbol");
      v13 = (unsigned __int16 *)(*a6 + v12);
      if ( *v13 == 1 )
      {
        v14 = v10;
        while ( *((_DWORD *)v13 + 2) != a3 || j_strcmp(a5, v14 + *(_DWORD *)((char *)v13 + *((_DWORD *)v13 + 3))) )
        {
          v15 = *((_DWORD *)v13 + 4);
          if ( !v15 )
          {
            v9 = a6;
            if ( a8 )
            {
              if ( !a7 )
                return 0;
              v32 = 1;
              v53 = "weak version `";
              v55 = "' not found (required by ";
              v57 = 135066410;
              v54 = a5;
              v56 = v49;
              v33 = 15;
              do
              {
                v45 = (char *)(&v53)[v32++];
                v33 += strlen(v45);
              }
              while ( v32 != 5 );
              v34 = "weak version `";
              v35 = alloca(v33 + 15);
              v36 = 0;
              v37 = &v46;
              while ( 1 )
              {
                ++v36;
                v37 = (int *)j_stpcpy(v37, v34);
                if ( v36 == 5 )
                  break;
                v34 = (&v53)[v36];
              }
              v23 = (const char *)&v46;
              v24 = 0;
            }
            else
            {
              v53 = "weak version `" + 5;
              v38 = 0;
              v55 = "' not found (required by ";
              v57 = 135066410;
              v39 = 1;
              v54 = a5;
              v56 = v49;
              for ( i = 9; ; i = strlen((&v53)[v38]) )
              {
                ++v38;
                v39 += i;
                if ( v38 == 5 )
                  break;
              }
              v41 = 135091407;
              v42 = alloca(v39 + 15);
              v43 = 0;
              v44 = &v46;
              while ( 1 )
              {
                ++v43;
                v44 = (int *)j_stpcpy(v44, v41);
                if ( v43 == 5 )
                  break;
                v41 = (int)(&v53)[v43];
              }
              v23 = (const char *)&v46;
              v24 = 1;
            }
            goto LABEL_16;
          }
          v13 = (unsigned __int16 *)((char *)v13 + v15);
          if ( *v13 != 1 )
          {
            v9 = a6;
            goto LABEL_10;
          }
        }
        return 0;
      }
LABEL_10:
      HIBYTE(v57) = 0;
      v16 = *v13;
      v50 = "unsupported version ";
      v51 = itoa(v16, (_BYTE *)&v57 + 3, 0xAu, 0);
      v52 = " of Verdef record";
      v17 = strlen(v51);
      v18 = "unsupported version ";
      v19 = alloca(v17 + 53);
      v20 = &v46;
      v49 = &v46;
      for ( j = (int *)&v50; ; v18 = (const char *)*j )
      {
        ++j;
        v20 = (int *)j_stpcpy(v20, v18);
        if ( j == (int *)&v53 )
          break;
      }
      v23 = (const char *)v49;
      v24 = 1;
      goto LABEL_16;
    }
  }
  if ( !a7 )
    return 0;
  v53 = "no version information available (required by ";
  v55 = "invalid mode for dlopen()" + 24;
  v54 = (const char *)v49;
  v27 = strlen(v49);
  v28 = "no version information available (required by ";
  v29 = alloca(v27 + 63);
  v30 = &v46;
  v49 = &v46;
  for ( k = (int *)&v53; ; v28 = (const char *)*k )
  {
    ++k;
    v30 = (int *)j_stpcpy(v30, v28);
    if ( k == (int *)&v56 )
      break;
  }
  v23 = (const char *)v49;
  v24 = 0;
LABEL_16:
  v25 = (char *)v9[1];
  if ( !*v25 )
  {
    v25 = (char *)program_invocation_short_name;
    if ( !program_invocation_short_name )
      v25 = "<main program>";
  }
  dl_signal_cerror(0, v25, "version lookup error", a4, v23);
  return v24;
}
// 8048210: using guessed type int __cdecl j_stpcpy(_DWORD, _DWORD);
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80ECC60: using guessed type int dl_debug_mask;

//----- (080A2820) --------------------------------------------------------
int __usercall dl_check_map_versions@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>)
{
  int v4; // ebx
  int v5; // esi
  int v6; // ecx
  bool v7; // zf
  _DWORD *v8; // ebx
  int v9; // esi
  const char *v10; // esi
  char *i; // edi
  int v12; // ecx
  int v13; // ebx
  int *v14; // eax
  int v15; // eax
  _DWORD *v16; // esi
  int v17; // eax
  int v18; // edi
  int v19; // edx
  const char *v20; // eax
  const char *v21; // ecx
  int v22; // eax
  const char *v24; // esi
  int v25; // eax
  _DWORD *v26; // ecx
  const char *v27; // edi
  int v28; // eax
  _DWORD *v29; // ebx
  int v30; // edi
  int v31; // ecx
  char *j; // ecx
  unsigned int v33; // eax
  char *v34; // eax
  int v35; // ebx
  int v36; // edx
  _DWORD *v37; // ebx
  int v38; // eax
  int v39; // eax
  int v40; // ebx
  int k; // eax
  int v42; // ecx
  char *v43; // edx
  int v44; // esi
  int v45; // edx
  char *v46; // edi
  int v47; // eax
  const char *v48; // edx
  void *v49; // esp
  const char *v50; // ebx
  int *v51; // eax
  signed int v52; // eax
  char *v53; // edx
  int v54; // [esp+0h] [ebp-68h] BYREF
  int v55; // [esp+4h] [ebp-64h]
  int v56; // [esp+8h] [ebp-60h]
  _DWORD *v57; // [esp+Ch] [ebp-5Ch]
  int v58; // [esp+10h] [ebp-58h]
  int v59; // [esp+14h] [ebp-54h]
  int v60; // [esp+18h] [ebp-50h]
  int v61; // [esp+1Ch] [ebp-4Ch]
  _DWORD *v62; // [esp+20h] [ebp-48h]
  int v63; // [esp+24h] [ebp-44h]
  const char *v64; // [esp+28h] [ebp-40h]
  _DWORD *v65; // [esp+2Ch] [ebp-3Ch]
  const char *v66; // [esp+30h] [ebp-38h] BYREF
  _BYTE *v67; // [esp+34h] [ebp-34h]
  const char *v68; // [esp+38h] [ebp-30h]
  char v69; // [esp+3Ch] [ebp-2Ch] BYREF
  char v70[25]; // [esp+4Fh] [ebp-19h] BYREF

  v4 = a1[13];
  if ( !v4 )
  {
    v59 = 0;
    return 0;
  }
  v5 = *(_DWORD *)(v4 + 4);
  v56 = a3;
  v62 = a1;
  v58 = a2;
  v61 = v5;
  v6 = a1[43];
  v54 = v6;
  v55 = a1[45];
  if ( v6 )
  {
    v7 = *(_WORD *)(*a1 + *(_DWORD *)(v6 + 4)) == 1;
    v57 = (_DWORD *)(*a1 + *(_DWORD *)(v6 + 4));
    if ( v7 )
    {
      v64 = 0;
      v59 = 0;
      while ( 1 )
      {
        v8 = (_DWORD *)(v57[1] + v61);
        v9 = (int)*(&dl_ns + 19 * v62[6]);
        if ( v9 )
        {
          while ( !dl_name_match_p((int)v8, v9) )
          {
            v9 = *(_DWORD *)(v9 + 12);
            if ( !v9 )
              goto LABEL_20;
          }
        }
        else
        {
LABEL_20:
          if ( !v62[88] )
            goto LABEL_25;
          v65 = v8;
          v18 = 0;
          while ( !dl_name_match_p((int)v65, *(_DWORD *)(v62[87] + 4 * v18)) )
          {
            if ( (unsigned int)++v18 >= v62[88] )
              goto LABEL_25;
          }
          v9 = *(_DWORD *)(v62[87] + 4 * v18);
          if ( !v9 )
LABEL_25:
            _assert_fail("needed != NULL", "dl-version.c", 224, "_dl_check_map_versions");
        }
        if ( v56 && (*(_BYTE *)(v9 + 405) & 2) != 0 )
        {
          v16 = v57;
          v17 = v57[3];
          if ( !v17 )
            goto LABEL_28;
        }
        else
        {
          v60 = v9;
          v10 = v64;
          for ( i = (char *)v57 + v57[2]; ; i += v15 )
          {
            v12 = *(_DWORD *)i;
            v13 = *((_WORD *)i + 2) & 2;
            v65 = *(_DWORD **)(v60 + 20);
            v64 = (const char *)(*((_DWORD *)i + 2) + v61);
            v14 = (int *)v62[1];
            v7 = *(_BYTE *)v14 == 0;
            v63 = v62[6];
            if ( v7 )
            {
              v14 = (int *)program_invocation_short_name;
              if ( !program_invocation_short_name )
                v14 = (int *)"<main program>";
            }
            v59 |= match_symbol(v14, v63, v12, a4, v64, v65, v58, v13);
            if ( (unsigned int)v10 < (*((_WORD *)i + 3) & 0x7FFFu) )
              v10 = (const char *)(*((_WORD *)i + 3) & 0x7FFF);
            v15 = *((_DWORD *)i + 3);
            if ( !v15 )
              break;
          }
          v64 = v10;
          v16 = v57;
          v17 = v57[3];
          if ( !v17 )
          {
LABEL_28:
            if ( v55 )
              goto LABEL_29;
LABEL_36:
            if ( !v64 )
              return v59;
            v24 = v64 + 1;
            v25 = calloc((unsigned int)(v64 + 1), 0x10u);
            v26 = v62;
            v27 = (const char *)v25;
            v62[92] = v25;
            if ( v25 )
            {
              v28 = v26[57];
              v26[93] = v24;
              v26[105] = *(_DWORD *)(v28 + 4);
              if ( v54 )
              {
                v29 = (_DWORD *)(*v26 + *(_DWORD *)(v54 + 4));
                v64 = v27;
                v30 = v61;
                while ( 1 )
                {
                  v31 = v29[2];
                  v65 = v29;
                  for ( j = (char *)v29 + v31; ; j += v38 )
                  {
                    v33 = *((_WORD *)j + 3) & 0x7FFF;
                    if ( (unsigned int)v24 > v33 )
                    {
                      v34 = (char *)&v64[16 * v33];
                      v35 = *(_DWORD *)j;
                      *((_DWORD *)v34 + 2) = *((_WORD *)j + 3) & 0x8000;
                      v36 = *((_DWORD *)j + 2);
                      *((_DWORD *)v34 + 1) = v35;
                      v37 = v65;
                      *(_DWORD *)v34 = v30 + v36;
                      *((_DWORD *)v34 + 3) = v37[1] + v30;
                    }
                    v38 = *((_DWORD *)j + 3);
                    if ( !v38 )
                      break;
                  }
                  v39 = v65[3];
                  if ( !v39 )
                    break;
                  v29 = (_DWORD *)((char *)v65 + v39);
                }
                v27 = v64;
              }
              if ( !v55 )
                return v59;
              v40 = v61;
              for ( k = *v62 + *(_DWORD *)(v55 + 4); ; k += v45 )
              {
                if ( (*(_BYTE *)(k + 2) & 1) == 0 )
                {
                  v42 = *(_DWORD *)(k + 12);
                  v43 = (char *)&v27[16 * (*(_WORD *)(k + 4) & 0x7FFF)];
                  *((_DWORD *)v43 + 1) = *(_DWORD *)(k + 8);
                  v44 = *(_DWORD *)(k + v42);
                  *((_DWORD *)v43 + 3) = 0;
                  *(_DWORD *)v43 = v40 + v44;
                }
                v45 = *(_DWORD *)(k + 16);
                if ( !v45 )
                  break;
              }
              return v59;
            }
            v52 = 12;
            v50 = "cannot allocate version reference table";
LABEL_63:
            v53 = (char *)v62[1];
            if ( !*v53 )
            {
              v53 = (char *)program_invocation_short_name;
              if ( !program_invocation_short_name )
                v53 = "<main program>";
            }
            dl_signal_error(v52, v53, 0, a4, v50);
          }
        }
        v57 = (_DWORD *)((char *)v16 + v17);
      }
    }
    v70[0] = 0;
    v46 = (char *)&v66;
    v66 = "unsupported version ";
    v67 = itoa(*(unsigned __int16 *)v57, v70, 0xAu, 0);
    v68 = " of Verneed record\n";
    v47 = strlen(v67);
    v48 = "unsupported version ";
    v49 = alloca(v47 + 55);
    v50 = (const char *)&v54;
    v51 = &v54;
    while ( 1 )
    {
      v46 += 4;
      v51 = (int *)j_stpcpy(v51, v48);
      if ( v46 == &v69 )
        break;
      v48 = *(const char **)v46;
    }
    v52 = 0;
    goto LABEL_63;
  }
  v64 = 0;
  v59 = 0;
  if ( v55 )
  {
LABEL_29:
    v19 = *v62 + *(_DWORD *)(v55 + 4);
    v20 = (const char *)(*(_WORD *)(v19 + 4) & 0x7FFF);
    if ( v64 >= v20 )
      v20 = v64;
    v21 = v20;
    v64 = v20;
    v22 = *(_DWORD *)(v19 + 16);
    if ( v22 )
    {
      do
      {
        v19 += v22;
        if ( (unsigned int)v21 < (*(_WORD *)(v19 + 4) & 0x7FFFu) )
          v21 = (const char *)(*(_WORD *)(v19 + 4) & 0x7FFF);
        v22 = *(_DWORD *)(v19 + 16);
      }
      while ( v22 );
      v64 = v21;
    }
    goto LABEL_36;
  }
  return v59;
}
// 8048210: using guessed type int __cdecl j_stpcpy(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EB99C: using guessed type void *program_invocation_short_name;
// 80EBA40: using guessed type void *dl_ns;
// 80A2820: using guessed type char var_19[25];

//----- (080A2C50) --------------------------------------------------------
int __usercall dl_check_all_versions@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>)
{
  int v4; // ebx
  int v7; // esi
  int v8; // eax

  if ( !a1 )
    return 0;
  v4 = a1;
  v7 = 0;
  do
  {
    while ( (*(_BYTE *)(v4 + 405) & 2) != 0 )
    {
      v4 = *(_DWORD *)(v4 + 12);
      if ( !v4 )
        return v7;
    }
    v8 = dl_check_map_versions((_DWORD *)v4, a2, a3, a4);
    v4 = *(_DWORD *)(v4 + 12);
    v7 |= v8 != 0;
  }
  while ( v4 );
  return v7;
}

//----- (080A2CB0) --------------------------------------------------------
int __usercall dl_start_profile@<eax>(long double a1@<st0>)
{
  unsigned int v1; // eax
  unsigned int v2; // edx
  unsigned int v3; // ebx
  unsigned int v4; // esi
  int v5; // ecx
  unsigned int v6; // ecx
  int v7; // edi
  int v8; // ecx
  unsigned int v9; // eax
  unsigned int v10; // ebx
  unsigned int v11; // edx
  int v12; // esi
  int v13; // edi
  void *v14; // esp
  const char *v15; // edi
  _BYTE *v16; // eax
  int v17; // esi
  char *v18; // ebx
  signed int v19; // edx
  unsigned int v20; // eax
  int result; // eax
  void *v22; // esp
  int v23; // ebx
  int v24; // edi
  int v25; // eax
  int *v26; // edx
  unsigned int *v27; // esi
  int v28; // eax
  unsigned int v29; // edx
  int v30; // edi
  int v31; // eax
  int v32; // eax
  int v33; // edx
  __int16 *v34; // ecx
  int v35; // ebx
  __int16 v36; // si
  bool v37; // zf
  int v38; // eax
  unsigned int v39; // ecx
  unsigned int v40; // esi
  int v41; // eax
  int v42; // eax
  unsigned int v43; // ecx
  _BYTE v44[12]; // [esp+0h] [ebp-278h] BYREF
  unsigned int v45; // [esp+Ch] [ebp-26Ch]
  int v46; // [esp+10h] [ebp-268h]
  _BYTE *v47; // [esp+14h] [ebp-264h]
  unsigned int v48; // [esp+18h] [ebp-260h]
  unsigned int v49; // [esp+1Ch] [ebp-25Ch]
  __int64 v50; // [esp+20h] [ebp-258h]
  unsigned int v51; // [esp+28h] [ebp-250h]
  int v52; // [esp+2Ch] [ebp-24Ch]
  int v53; // [esp+3Ch] [ebp-23Ch] BYREF
  int v54; // [esp+40h] [ebp-238h]
  int v55; // [esp+44h] [ebp-234h]
  int v56; // [esp+48h] [ebp-230h]
  int v57; // [esp+4Ch] [ebp-22Ch]
  int v58; // [esp+50h] [ebp-228h] BYREF
  int v59; // [esp+54h] [ebp-224h]
  unsigned int v60; // [esp+58h] [ebp-220h]
  int v61; // [esp+5Ch] [ebp-21Ch]
  _DWORD v62[2]; // [esp+60h] [ebp-218h] BYREF
  int v63; // [esp+68h] [ebp-210h]
  int v64; // [esp+6Ch] [ebp-20Ch]
  char v65[16]; // [esp+70h] [ebp-208h] BYREF
  int v66; // [esp+80h] [ebp-1F8h]
  __int64 v67; // [esp+9Ch] [ebp-1DCh]
  char v68[424]; // [esp+D0h] [ebp-1A8h] BYREF

  v51 = dl_profile_map;
  v1 = *(_DWORD *)(dl_profile_map + 336);
  v2 = v1 + 32 * *(unsigned __int16 *)(dl_profile_map + 344);
  if ( v1 >= v2 )
  {
    v8 = 0;
    v7 = -1;
    v4 = 0;
    v3 = -1;
  }
  else
  {
    v3 = -1;
    LODWORD(v50) = dl_pagesize - 1;
    v52 = -dl_pagesize;
    v4 = 0;
    do
    {
      while ( *(_DWORD *)v1 != 1 || (*(_BYTE *)(v1 + 24) & 1) == 0 )
      {
        v1 += 32;
        if ( v2 <= v1 )
          goto LABEL_11;
      }
      v5 = *(_DWORD *)(v1 + 8);
      if ( v3 > (v5 & (unsigned int)v52) )
        v3 = v5 & v52;
      v6 = v52 & (v50 + *(_DWORD *)(v1 + 20) + v5);
      if ( v4 < v6 )
        v4 = v6;
      v1 += 32;
    }
    while ( v2 > v1 );
LABEL_11:
    v7 = v3;
    v8 = v4;
  }
  running = 0;
  log_hashfraction = 4;
  v9 = (v4 + *(_DWORD *)v51 + 3) & 0xFFFFFFFC;
  lowpc = (*(_DWORD *)v51 + v3) & 0xFFFFFFFC;
  v49 = v9;
  v10 = v9 - lowpc;
  textsize = v9 - lowpc;
  v11 = 3 * (v9 - lowpc) / 0x64;
  if ( v11 > 0x31 )
  {
    if ( v11 <= 0x100000 )
    {
      fromlimit = 3 * (v9 - lowpc) / 0x64;
      v51 = 8 * v11;
      LODWORD(v50) = 96 * v11 + 64;
    }
    else
    {
      fromlimit = 0x100000;
      v51 = 0x800000;
      LODWORD(v50) = 100663360;
    }
  }
  else
  {
    fromlimit = 50;
    v51 = 400;
    LODWORD(v50) = 4864;
  }
  v59 = v8;
  v58 = v7;
  v53 = 1852796263;
  v54 = 0x1FFFF;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v60 = v10 >> 2;
  v64 = 1929379840;
  v61 = _profile_frequency();
  strcpy((char *)v62, "seconds");
  v63 = 0;
  v52 = dl_profile_output;
  v12 = dl_profile;
  v13 = strlen((_BYTE *)dl_profile_output);
  v14 = alloca(v13 + strlen((_BYTE *)dl_profile) + 25);
  v15 = v44;
  v16 = (_BYTE *)j_stpcpy(v44, dl_profile_output);
  *v16 = 47;
  strcpy((char *)j_stpcpy(v16 + 1, v12), ".profile");
  v17 = open((int)v44, 131138, 438);
  if ( v17 == -1 )
  {
    v18 = "%s: cannot open file: %s\n";
    v19 = __readgsdword(0xFFFFFFE8);
    goto LABEL_19;
  }
  if ( (_fxstat64(3, v17, (int)v65) & 0x80000000) != 0 || (v66 & 0xF000) != 0x8000 )
  {
    v18 = "%s: cannot stat file: %s\n";
LABEL_18:
    v52 = __readgsdword(0xFFFFFFE8);
    close(v17);
    v19 = v52;
LABEL_19:
    v20 = strerror_r(a1, v19, v68, 0x190u);
    return dl_dprintf(2, v18, v15, v20);
  }
  v48 = v10 >> 1;
  v52 = (v10 >> 1) + v50;
  v50 = v67;
  if ( v67 )
  {
    if ( v52 != v50 )
    {
      close(v17);
      return dl_dprintf(2, "%s: file is no correct profile data file for `%s'\n", v15, (const char *)dl_profile);
    }
  }
  else
  {
    LODWORD(v50) = v44;
    v22 = alloca(dl_pagesize);
    v47 = v44;
    v46 = dl_pagesize;
    j_memset(v44, 0, dl_pagesize);
    if ( lseek(v17, v52 & -v46) == -1 )
    {
LABEL_55:
      v18 = "%s: cannot create file: %s\n";
      goto LABEL_18;
    }
    v45 = v10;
    v46 = (int)v44;
    v23 = v52;
    v24 = (int)v47;
    while ( 1 )
    {
      v25 = write(v17, v24, v23 & (dl_pagesize - 1));
      if ( v25 != -1 )
        break;
      if ( __readgsdword(0xFFFFFFE8) != 4 )
      {
        v15 = (const char *)v46;
        goto LABEL_55;
      }
    }
    v10 = v45;
    v15 = (const char *)v46;
    if ( v25 < 0 )
      goto LABEL_55;
  }
  LODWORD(v50) = mmap(0, v52, 3, 1, v17, 0);
  if ( (_DWORD)v50 == -1 )
  {
    v18 = "%s: cannot map file: %s\n";
    goto LABEL_18;
  }
  close(v17);
  v26 = (int *)v50;
  v27 = (unsigned int *)(v50 + 56 + v48 + 4);
  v47 = (_BYTE *)(v50 + 56);
  narcsp = (int)v27;
  data = v50 + 56 + v48 + 8;
  if ( v67 )
  {
    v41 = j_memcmp(v50, &v53, 20);
    v26 = (int *)v50;
    if ( v41 || *(_DWORD *)(v50 + 20) || (v42 = j_memcmp(v50 + 24, &v58, 32), v26 = (int *)v50, v42) || *(v27 - 1) != 1 )
    {
      munmap((int)v26, v52);
      return dl_dprintf(2, "%s: file is no correct profile data file for `%s'\n", v15, (const char *)dl_profile);
    }
  }
  else
  {
    v28 = v53;
    *(_DWORD *)(v50 + 20) = 0;
    *v26 = v28;
    v26[1] = v54;
    v26[2] = v55;
    v26[3] = v56;
    v26[4] = v57;
    v26[6] = v58;
    v26[7] = v59;
    v26[8] = v60;
    v26[9] = v61;
    v26[10] = v62[0];
    v26[11] = v62[1];
    v26[12] = v63;
    v26[13] = v64;
    *(v27 - 1) = 1;
  }
  v46 = (int)v26;
  LODWORD(v50) = calloc(v48 + v51, 1u);
  tos = v50;
  if ( !(_DWORD)v50 )
  {
    munmap(v46, v52);
    dl_dprintf(2, "Out of memory while initializing profiler\n");
    exit(127);
  }
  fromidx = 0;
  v29 = *v27;
  v30 = v48 + v50;
  froms = v48 + v50;
  v31 = fromlimit;
  if ( v29 < fromlimit )
    v31 = *v27;
  narcs = v31;
  if ( v31 )
  {
    v51 = v10;
    v32 = (int)&v27[3 * v31 - 2];
    v52 = (int)(v27 - 2);
    do
    {
      v33 = fromidx;
      v34 = (__int16 *)(v50 + 2 * (*(_DWORD *)(v32 + 4) >> 2));
      ++fromidx;
      v35 = v30 + 8 * v33;
      v36 = *v34;
      *(_DWORD *)v35 = v32;
      v32 -= 12;
      v37 = v52 == v32;
      *(_WORD *)(v35 + 4) = v36;
      *v34 = v33;
    }
    while ( !v37 );
    v10 = v51;
  }
  v38 = 0x10000;
  v39 = v49 - lowpc;
  if ( v48 < v49 - lowpc )
  {
    v40 = v39 / v48;
    v38 = 1;
    if ( v39 / v48 <= 0xFFFF )
    {
      if ( v40 <= 0xFF )
      {
        if ( v39 <= 0xFFFFFF )
          v43 = (v39 << 8) / v48;
        else
          v43 = v39 / (v10 >> 9);
        v38 = 0x1000000 / v43;
      }
      else
      {
        v38 = 0x10000 / v40;
      }
    }
  }
  result = profil((int)v47, v48, lowpc, v38);
  running = 1;
  return result;
}
// 8048210: using guessed type int __cdecl j_stpcpy(_DWORD, _DWORD);
// 8048230: using guessed type int __cdecl j_memcmp(_DWORD, _DWORD, _DWORD);
// 8048250: using guessed type int __cdecl j_memset(_DWORD, _DWORD, _DWORD);
// 80EBA08: using guessed type int dl_pagesize;
// 80EC7C8: using guessed type int log_hashfraction;
// 80EC7CC: using guessed type int textsize;
// 80EC7D0: using guessed type int lowpc;
// 80EC7D4: using guessed type int fromidx;
// 80EC7D8: using guessed type int fromlimit;
// 80EC7DC: using guessed type int froms;
// 80EC7E0: using guessed type int tos;
// 80EC7E4: using guessed type int narcsp;
// 80EC7E8: using guessed type int narcs;
// 80EC7EC: using guessed type int running;
// 80EC7F0: using guessed type int data;
// 80ECC58: using guessed type int dl_profile_output;
// 80ECC68: using guessed type int dl_profile;
// 80ECCB4: using guessed type int dl_profile_map;
// 80A2CB0: using guessed type char var_208[16];
// 80A2CB0: using guessed type char var_1A8[424];

//----- (080A3440) --------------------------------------------------------
void __cdecl dl_mcount(int a1, int a2)
{
  int v2; // ebx
  int v3; // eax
  _DWORD *v4; // edi
  int v5; // eax
  int v6; // esi
  int v7; // ebx
  int v8; // ebp
  int v9; // edx
  int v10; // eax
  int v11; // ecx
  _WORD *v12; // edx
  unsigned int v13; // edx
  __int16 v14; // ax
  int v15; // ecx
  int v16; // ecx
  _DWORD *v17; // eax
  _DWORD *v18; // ecx
  int v19; // edx
  int v20; // eax
  int v21; // [esp+0h] [ebp-30h]
  _WORD *v22; // [esp+4h] [ebp-2Ch]
  int v23; // [esp+8h] [ebp-28h]
  int v24; // [esp+Ch] [ebp-24h]

  if ( running )
  {
    v2 = a1 - lowpc;
    if ( a1 - lowpc >= (unsigned int)textsize )
      v2 = 0;
    v23 = a2 - lowpc;
    if ( textsize > (unsigned int)(a2 - lowpc) )
    {
      v21 = tos;
      v22 = (_WORD *)(tos + 2 * ((unsigned int)(a2 - lowpc) >> log_hashfraction));
      v3 = (unsigned __int16)*v22;
      if ( *v22 )
        goto LABEL_30;
      while ( 1 )
      {
        v4 = (_DWORD *)narcsp;
        v5 = narcs;
        if ( narcs != *(_DWORD *)narcsp && fromlimit > (unsigned int)narcs )
        {
          v24 = v2;
          v6 = froms;
          v7 = data;
          do
          {
            v8 = v7 + 12 * v5;
            v9 = *(_DWORD *)(v8 + 4) >> 2;
            if ( __readgsdword(0xCu) )
              __asm { lock }
            v10 = fromidx++;
            ++v10;
            v11 = v6 + 8 * v10;
            *(_DWORD *)v11 = v8;
            v12 = (_WORD *)(v21 + 2 * v9);
            *(_WORD *)(v11 + 4) = *v12;
            *v12 = v10;
            if ( __readgsdword(0xCu) )
              __asm { lock }
            v5 = ++narcs;
          }
          while ( *v4 != narcs && narcs < (unsigned int)fromlimit );
          v2 = v24;
        }
        if ( !*v22 )
          break;
        v3 = (unsigned __int16)*v22;
LABEL_30:
        v19 = froms + 8 * v3;
        v18 = *(_DWORD **)v19;
        if ( v2 == **(_DWORD **)v19 )
          goto LABEL_25;
        v20 = *(unsigned __int16 *)(v19 + 4);
        if ( (_WORD)v20 )
        {
          do
          {
            v19 = froms + 8 * v20;
            v20 = *(unsigned __int16 *)(v19 + 4);
            v18 = *(_DWORD **)v19;
          }
          while ( (_WORD)v20 && v2 != *v18 );
        }
        if ( v2 == *v18 )
          goto LABEL_25;
        v22 = (_WORD *)(v19 + 4);
      }
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v13 = (*v4)++;
      if ( v13 < fromlimit )
      {
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v14 = fromidx++;
        v15 = froms;
        *v22 = v14 + 1;
        v16 = v15 + 8 * (unsigned __int16)*v22;
        v17 = (_DWORD *)(data + 12 * v13);
        *(_DWORD *)v16 = v17;
        *v17 = v2;
        v17[2] = 0;
        v17[1] = v23;
        *(_WORD *)(v16 + 4) = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        ++narcs;
        v18 = *(_DWORD **)v16;
LABEL_25:
        if ( __readgsdword(0xCu) )
          __asm { lock }
        ++v18[2];
      }
    }
  }
}
// 80EC7C8: using guessed type int log_hashfraction;
// 80EC7CC: using guessed type int textsize;
// 80EC7D0: using guessed type int lowpc;
// 80EC7D4: using guessed type int fromidx;
// 80EC7D8: using guessed type int fromlimit;
// 80EC7DC: using guessed type int froms;
// 80EC7E0: using guessed type int tos;
// 80EC7E4: using guessed type int narcsp;
// 80EC7E8: using guessed type int narcs;
// 80EC7EC: using guessed type int running;
// 80EC7F0: using guessed type int data;

//----- (080A3650) --------------------------------------------------------
_BOOL4 __cdecl _mpn_add_n(_DWORD *a1, _DWORD *a2, _DWORD *a3, unsigned int a4)
{
  unsigned int v7; // ecx
  bool v8; // cf
  _BOOL4 v9; // ett
  int v10; // eax
  int v11; // eax
  _BOOL4 v12; // ett
  int v13; // eax
  int v14; // eax
  _BOOL4 v15; // ett
  int v16; // eax
  int v17; // eax
  _BOOL4 v18; // ett
  int v19; // eax
  int v20; // eax
  _BOOL4 v21; // ett
  int v22; // eax
  int v23; // eax
  _BOOL4 v24; // ett
  int v25; // eax
  int v26; // eax
  _BOOL4 v27; // ett
  int v28; // eax
  int v29; // eax
  _BOOL4 v30; // ett

  v7 = a4 >> 3;
  v8 = 0;
  if ( (-a4 & 7) != 0 )
    __asm { jmp     eax }
  do
  {
    v9 = v8;
    v8 = __CFADD__(v8, *a2) | __CFADD__(*a3, v8 + *a2);
    *a1 = *a3 + v9 + *a2;
    v10 = a2[1];
    v12 = v8;
    v8 = __CFADD__(v8, v10);
    v11 = v12 + v10;
    v8 |= __CFADD__(a3[1], v11);
    a1[1] = a3[1] + v11;
    v13 = a2[2];
    v15 = v8;
    v8 = __CFADD__(v8, v13);
    v14 = v15 + v13;
    v8 |= __CFADD__(a3[2], v14);
    a1[2] = a3[2] + v14;
    v16 = a2[3];
    v18 = v8;
    v8 = __CFADD__(v8, v16);
    v17 = v18 + v16;
    v8 |= __CFADD__(a3[3], v17);
    a1[3] = a3[3] + v17;
    v19 = a2[4];
    v21 = v8;
    v8 = __CFADD__(v8, v19);
    v20 = v21 + v19;
    v8 |= __CFADD__(a3[4], v20);
    a1[4] = a3[4] + v20;
    v22 = a2[5];
    v24 = v8;
    v8 = __CFADD__(v8, v22);
    v23 = v24 + v22;
    v8 |= __CFADD__(a3[5], v23);
    a1[5] = a3[5] + v23;
    v25 = a2[6];
    v27 = v8;
    v8 = __CFADD__(v8, v25);
    v26 = v27 + v25;
    v8 |= __CFADD__(a3[6], v26);
    a1[6] = a3[6] + v26;
    v28 = a2[7];
    v30 = v8;
    v8 = __CFADD__(v8, v28);
    v29 = v30 + v28;
    v8 |= __CFADD__(a3[7], v29);
    a1[7] = a3[7] + v29;
    a1 += 8;
    a2 += 8;
    a3 += 8;
    --v7;
  }
  while ( v7 );
  return v8;
}

//----- (080A36E0) --------------------------------------------------------
int __cdecl _mpn_addmul_1(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // edi
  int v5; // ecx
  unsigned int v6; // ebp
  unsigned __int64 v7; // kr00_8

  v4 = a1 + 4 * a3;
  v5 = -a3;
  v6 = 0;
  do
  {
    v7 = v6 + a4 * (unsigned __int64)*(unsigned int *)(a2 + 4 * a3 + 4 * v5) + *(unsigned int *)(v4 + 4 * v5);
    *(_DWORD *)(v4 + 4 * v5) = v7;
    v6 = HIDWORD(v7);
    ++v5;
  }
  while ( v5 );
  return HIDWORD(v7);
}

//----- (080A3720) --------------------------------------------------------
int __usercall char_buffer_add_slow@<eax>(int result@<eax>, char a2@<dl>)
{
  _DWORD *v3; // ebx
  int v4; // edi
  int v5; // eax
  int v6; // edx

  if ( *(_DWORD *)result )
  {
    v3 = (_DWORD *)result;
    v4 = *(_DWORD *)(result + 4) - *(_DWORD *)(result + 8);
    result = _libc_scratch_buffer_grow_preserve(result + 8);
    if ( (_BYTE)result )
    {
      v5 = v3[2];
      v6 = v5 + v3[3];
      result = v4 + v5;
      v3[1] = v6;
      *v3 = result + 1;
      *(_BYTE *)result = a2;
    }
    else
    {
      *v3 = 0;
      v3[1] = 0;
    }
  }
  return result;
}

//----- (080A3780) --------------------------------------------------------
int __usercall IO_vfscanf_internal@<eax>(long double a1@<st0>, int a2, unsigned int a3, long double **a4, _DWORD *a5)
{
  unsigned int v5; // esi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  const char *v9; // ecx
  int v10; // edx
  unsigned __int8 v11; // al
  unsigned int v12; // ebx
  unsigned __int8 *v13; // eax
  int v14; // eax
  int v15; // edi
  int i; // edx
  unsigned __int8 *v17; // eax
  int v18; // eax
  int v19; // eax
  unsigned __int8 *v20; // edx
  int v21; // ebx
  unsigned __int8 *v22; // eax
  unsigned int v23; // ecx
  unsigned int v26; // edi
  bool v28; // zf
  int v29; // ebx
  int *v30; // eax
  int v31; // ebx
  int v32; // eax
  unsigned __int8 v33; // dl
  unsigned __int8 *v34; // ecx
  int *v35; // eax
  int *v36; // ebx
  _DWORD *v37; // edx
  unsigned __int8 *v38; // eax
  unsigned int v39; // edx
  unsigned __int8 *v40; // edx
  unsigned int v41; // eax
  int v42; // ecx
  int v43; // eax
  unsigned __int8 *v44; // edi
  unsigned __int8 v45; // al
  unsigned int v46; // edi
  char *v47; // esi
  unsigned int v48; // ecx
  int v49; // eax
  int v50; // esi
  unsigned __int8 *v51; // eax
  int v52; // ecx
  char v53; // bl
  int *jj; // esi
  unsigned int v55; // ebx
  _DWORD *v56; // eax
  bool v57; // cc
  int *v58; // esi
  unsigned int v59; // edi
  unsigned int v60; // eax
  unsigned __int8 *v61; // eax
  char *v62; // edi
  unsigned __int8 *v63; // eax
  unsigned __int8 *v64; // eax
  unsigned __int8 *v65; // eax
  unsigned __int8 *v66; // eax
  int v67; // ebx
  int *v68; // ecx
  unsigned __int8 *v69; // eax
  unsigned __int8 *v70; // eax
  unsigned __int8 *v71; // edx
  unsigned __int8 *v72; // eax
  int v73; // ebx
  __int64 v74; // rax
  long double **v75; // edx
  int *v76; // eax
  char **v77; // edi
  char *v78; // eax
  int v79; // edx
  int v80; // ecx
  int *v81; // edi
  unsigned __int8 *v82; // eax
  char *v83; // esi
  unsigned int v84; // ecx
  int ii; // ebx
  int v86; // eax
  unsigned __int8 *v87; // eax
  int v88; // eax
  int *v89; // eax
  char **v90; // esi
  int v91; // eax
  char *v92; // eax
  int v93; // edx
  int v94; // ecx
  int v95; // edi
  int *v96; // esi
  unsigned __int8 *v97; // eax
  _BYTE *v98; // eax
  unsigned int v99; // edi
  char *v100; // edi
  int *v101; // edi
  int n; // ebx
  int v103; // eax
  unsigned __int8 *v104; // eax
  int v105; // ebx
  int *v106; // eax
  int **v107; // esi
  int *v108; // eax
  int v109; // edx
  int v110; // ecx
  int v111; // esi
  unsigned __int8 *v112; // eax
  int *v113; // edx
  int v114; // edi
  int *v115; // esi
  int *v116; // esi
  int *v117; // ecx
  unsigned __int8 *v118; // eax
  int v119; // ecx
  int *v120; // eax
  int *v121; // eax
  int v122; // esi
  int v123; // esi
  int v124; // ebx
  int *v125; // eax
  int **v126; // edi
  int v127; // eax
  int *v128; // eax
  int v129; // edx
  int v130; // ecx
  int v131; // edi
  unsigned __int8 *v132; // eax
  int v133; // ecx
  char *v134; // ebx
  int v135; // edi
  int v136; // eax
  unsigned __int8 *v137; // eax
  int *v138; // eax
  char **v139; // esi
  char *v140; // eax
  int v141; // edx
  int v142; // ebx
  int v143; // esi
  int *v144; // ecx
  char v145; // bl
  int v146; // eax
  unsigned __int8 *v147; // eax
  unsigned int v148; // edi
  int v149; // eax
  unsigned __int8 *v150; // edx
  char v151; // si
  unsigned __int8 v152; // cl
  int v153; // ebx
  int v154; // eax
  unsigned __int8 *v155; // eax
  unsigned __int8 *v156; // eax
  int v157; // ecx
  int v158; // eax
  unsigned __int8 *v159; // eax
  unsigned __int8 *v160; // eax
  char v161; // di
  int v162; // ebx
  unsigned __int8 *v163; // eax
  unsigned __int8 *v164; // edi
  int v165; // eax
  char v166; // dl
  char *v167; // edi
  int v168; // ebx
  int v169; // eax
  unsigned __int8 *v170; // eax
  char v171; // dl
  char *v172; // edi
  unsigned __int8 *v173; // eax
  unsigned __int8 *v174; // eax
  unsigned int v175; // edi
  unsigned int v176; // edi
  int v177; // eax
  const char *v178; // esi
  int v179; // edi
  int v180; // ecx
  unsigned __int8 *v181; // eax
  int v182; // eax
  unsigned __int8 *v183; // eax
  unsigned __int8 *v184; // eax
  unsigned int v185; // ebx
  unsigned int v186; // edi
  int v187; // eax
  unsigned int v188; // esi
  unsigned __int8 *v189; // eax
  int v190; // edx
  int v191; // ebx
  unsigned __int8 *v192; // eax
  unsigned __int8 *v193; // eax
  unsigned __int8 *v194; // eax
  char v195; // si
  unsigned __int8 *v196; // edx
  unsigned __int8 *v197; // eax
  double *v198; // ecx
  _BYTE *v199; // eax
  unsigned __int8 *v200; // eax
  char *v201; // ebx
  int *v202; // edi
  _BYTE *v203; // eax
  signed int v204; // edx
  int v205; // eax
  int *v206; // ebx
  int *v207; // edi
  int v208; // eax
  unsigned __int8 *v209; // eax
  int *v210; // eax
  int **v211; // esi
  int *v212; // eax
  int v213; // edx
  int v214; // ebx
  int v215; // esi
  int *v216; // ecx
  long double **v217; // edx
  const char *v218; // esi
  const char *v219; // edi
  int v220; // eax
  const char *v221; // eax
  char v222; // bl
  unsigned __int8 *v223; // eax
  char v224; // dl
  int v225; // ecx
  int v226; // edi
  unsigned __int8 *v227; // eax
  char v228; // ah
  char *v229; // ebx
  int *v230; // esi
  int v231; // eax
  int v232; // eax
  _BYTE *v233; // eax
  int v234; // eax
  unsigned __int8 *v235; // edi
  const char *v236; // edi
  char v237; // dl
  char *m; // edi
  unsigned __int8 *v239; // eax
  unsigned __int8 *v240; // eax
  int *v241; // esi
  int v242; // edi
  int *v243; // ecx
  int *v244; // ebx
  _BYTE *v245; // eax
  unsigned __int8 *v246; // eax
  int *v247; // edx
  int v248; // ecx
  char *v249; // eax
  char *v250; // eax
  char v251; // ah
  int *v252; // ebx
  int *v253; // edi
  int v254; // eax
  int v255; // ebx
  unsigned __int8 *v256; // eax
  int v257; // ebx
  unsigned __int8 *v258; // eax
  unsigned __int8 *v259; // eax
  unsigned __int8 *v260; // eax
  long double **v261; // edx
  long double *v262; // eax
  long double **v263; // edx
  unsigned __int8 *v264; // eax
  unsigned __int8 *v265; // eax
  _BYTE *v266; // eax
  unsigned __int8 *v267; // edx
  unsigned __int8 *v268; // eax
  unsigned __int8 *v269; // eax
  int v270; // edx
  int v271; // eax
  int v272; // eax
  unsigned __int8 *v273; // eax
  int v274; // ebx
  int *v275; // eax
  int v276; // esi
  _BYTE *v277; // edx
  int v278; // edx
  unsigned __int8 *v279; // eax
  int v280; // esi
  int *v281; // esi
  int v282; // eax
  signed int v283; // eax
  int v284; // eax
  int v285; // edx
  signed int v286; // ecx
  unsigned __int8 *v287; // eax
  _BYTE *v288; // eax
  unsigned __int8 *v289; // edx
  unsigned __int8 *v290; // eax
  int v291; // ebx
  unsigned __int8 *v292; // eax
  unsigned __int8 *v293; // eax
  char **v294; // eax
  int *v295; // eax
  int *v296; // eax
  char **v297; // eax
  long double **v298; // edx
  char v299; // di
  float *v300; // ecx
  int v301; // eax
  unsigned __int8 *v302; // esi
  int v303; // eax
  int v304; // esi
  _BYTE *v305; // ebx
  int v306; // edi
  char *v307; // edx
  unsigned __int8 *v308; // edi
  char *v309; // esi
  int v310; // eax
  int v311; // ecx
  unsigned __int8 *v312; // eax
  int v313; // edx
  char v314; // al
  unsigned __int8 *v315; // edi
  int v316; // eax
  unsigned int v317; // eax
  int v318; // eax
  int v319; // edi
  char *v320; // edi
  int *v321; // edx
  int v322; // edx
  int v323; // ecx
  int v324; // edi
  char *v325; // esi
  int v326; // ecx
  char v327; // al
  unsigned __int8 *v328; // eax
  unsigned int v329; // edi
  char *v330; // esi
  int v331; // eax
  char *v332; // eax
  int v333; // eax
  int v334; // edi
  char *v335; // ecx
  const char *v336; // esi
  unsigned __int8 *v337; // eax
  char *v338; // eax
  unsigned __int8 *v339; // eax
  unsigned __int8 *v340; // eax
  unsigned __int8 *v341; // eax
  int v342; // eax
  unsigned __int8 *v343; // eax
  unsigned int v344; // ebx
  unsigned int v345; // esi
  unsigned int v346; // ebx
  int v347; // eax
  signed int v348; // edx
  signed int v349; // ecx
  int *v350; // eax
  int *v351; // eax
  int *v352; // eax
  int v353; // eax
  char v354; // di
  long double *v355; // ecx
  long double **v356; // eax
  long double **v357; // edx
  int v358; // esi
  long double **v359; // edx
  long double *v360; // eax
  char *v361; // eax
  int *v362; // eax
  long double **v363; // eax
  int **v364; // eax
  signed int v365; // ecx
  int v366; // eax
  int *v367; // eax
  int *v368; // eax
  int *v369; // eax
  char **v370; // eax
  long double *v371; // eax
  int *v372; // eax
  int **v373; // eax
  int **v374; // eax
  int v375; // eax
  int v376; // edi
  int v377; // eax
  long double **v378; // eax
  int v379; // eax
  int v380; // esi
  int v381; // eax
  double **v382; // ecx
  int v383; // ecx
  unsigned int v384; // eax
  int v385; // ecx
  int v386; // edx
  int v387; // eax
  int v388; // ecx
  int v389; // eax
  float **v390; // ecx
  long double **v391; // ecx
  unsigned __int8 *v392; // eax
  int v393; // eax
  unsigned __int8 *v394; // eax
  int *v395; // esi
  _BYTE *v396; // eax
  signed int v397; // edx
  int v398; // eax
  long double **v399; // eax
  int v400; // eax
  int v401; // edi
  int v402; // eax
  int v403; // ecx
  int v404; // eax
  int v405; // esi
  unsigned __int8 *v406; // edx
  char *v407; // edx
  const char *v408; // esi
  int v409; // eax
  const char *v410; // eax
  unsigned int v411; // eax
  int *v412; // eax
  int v413; // eax
  unsigned __int8 *v414; // eax
  _BYTE *v415; // eax
  unsigned __int8 *v416; // ecx
  _BYTE *v417; // eax
  unsigned __int8 *v418; // ecx
  _BYTE *v419; // eax
  unsigned __int8 *v420; // ecx
  unsigned __int8 *v421; // eax
  int v422; // eax
  unsigned int v423; // edi
  _BYTE *v424; // ebx
  unsigned int v425; // eax
  int v426; // esi
  int v427; // eax
  _BYTE *v428; // esi
  unsigned int v429; // eax
  void *v430; // esp
  _WORD *v431; // eax
  _WORD *v432; // eax
  char *v433; // ecx
  int v434; // eax
  int *v435; // eax
  int v436; // eax
  char *v437; // eax
  unsigned __int8 *v438; // eax
  unsigned int v439; // eax
  bool v440; // si
  int v441; // eax
  const char *v442; // edi
  unsigned int v443; // kr04_4
  bool v444; // cl
  bool v445; // al
  int v446; // ebx
  int *v447; // eax
  unsigned int v448; // eax
  char *v449; // edi
  int *v450; // edi
  int v451; // eax
  int v452; // edx
  unsigned int v453; // eax
  char v454; // bl
  int v455; // eax
  int v456; // ebx
  unsigned __int8 *v457; // esi
  int *v458; // edi
  int v459; // esi
  int v460; // edx
  int *v461; // esi
  int *v462; // ecx
  int v463; // eax
  int v464; // edx
  unsigned __int8 *v465; // eax
  unsigned int v466; // ecx
  unsigned __int8 *v467; // ebx
  int *v468; // ecx
  int v469; // eax
  int v470; // eax
  int v471; // eax
  int v472; // esi
  unsigned __int8 *v473; // eax
  char v474; // dl
  unsigned __int8 *v475; // eax
  char *j; // esi
  char v477; // al
  unsigned __int8 *v478; // ecx
  int v479; // eax
  char *k; // esi
  char v481; // al
  unsigned __int8 *v482; // ecx
  int *v483; // eax
  unsigned int v484; // ecx
  int v485; // [esp-A0h] [ebp-668h] BYREF
  int v486; // [esp-9Ch] [ebp-664h]
  int v487; // [esp-8h] [ebp-5D0h]
  int v488; // [esp-4h] [ebp-5CCh]
  int v489; // [esp+0h] [ebp-5C8h] BYREF
  int v490; // [esp+4h] [ebp-5C4h]
  int *v491; // [esp+8h] [ebp-5C0h]
  int v492; // [esp+Ch] [ebp-5BCh]
  char *v493; // [esp+10h] [ebp-5B8h]
  char *v494; // [esp+14h] [ebp-5B4h]
  char *v495; // [esp+18h] [ebp-5B0h]
  int *v496; // [esp+1Ch] [ebp-5ACh]
  int *v497; // [esp+20h] [ebp-5A8h]
  char *v498; // [esp+24h] [ebp-5A4h]
  int v499; // [esp+28h] [ebp-5A0h]
  signed int v500; // [esp+2Ch] [ebp-59Ch]
  long double **v501; // [esp+30h] [ebp-598h]
  char *v502; // [esp+34h] [ebp-594h]
  int *v503; // [esp+38h] [ebp-590h]
  const char *v504; // [esp+3Ch] [ebp-58Ch]
  unsigned int v505; // [esp+40h] [ebp-588h]
  int *v506; // [esp+44h] [ebp-584h]
  unsigned int v507; // [esp+48h] [ebp-580h]
  int v508; // [esp+4Ch] [ebp-57Ch]
  unsigned int v509; // [esp+50h] [ebp-578h]
  int v510; // [esp+54h] [ebp-574h]
  int v511; // [esp+58h] [ebp-570h]
  unsigned int v512; // [esp+5Ch] [ebp-56Ch]
  unsigned int v513; // [esp+60h] [ebp-568h]
  int v514; // [esp+64h] [ebp-564h]
  unsigned __int8 *v515; // [esp+68h] [ebp-560h]
  int v516; // [esp+6Ch] [ebp-55Ch]
  unsigned __int8 *v517; // [esp+70h] [ebp-558h] BYREF
  int v518[2]; // [esp+74h] [ebp-554h] BYREF
  int v519[6]; // [esp+7Ch] [ebp-54Ch] BYREF
  char v520[16]; // [esp+94h] [ebp-534h] BYREF
  int v521[11]; // [esp+A4h] [ebp-524h] BYREF
  unsigned int v522; // [esp+D0h] [ebp-4F8h]
  int v523; // [esp+D4h] [ebp-4F4h] BYREF
  int v524; // [esp+D8h] [ebp-4F0h]
  char v525[17]; // [esp+17Eh] [ebp-44Ah] BYREF
  char v526[17]; // [esp+18Fh] [ebp-439h] BYREF
  unsigned __int8 *v527; // [esp+1A0h] [ebp-428h] BYREF
  unsigned __int8 *v528; // [esp+1A4h] [ebp-424h]
  unsigned __int8 *v529; // [esp+1A8h] [ebp-420h] BYREF
  int v530; // [esp+1ACh] [ebp-41Ch]
  char v531[1048]; // [esp+1B0h] [ebp-418h] BYREF

  v5 = a3;
  v509 = __readgsdword(0xFFFFFFDC);
  v6 = *(_DWORD *)v509;
  v530 = 1024;
  v499 = v6;
  v529 = (unsigned __int8 *)v531;
  v7 = *(_DWORD *)(a2 + 104);
  if ( v7 )
  {
    if ( v7 != -1 )
      goto LABEL_35;
  }
  else
  {
    *(_DWORD *)(a2 + 104) = -1;
  }
  v8 = *(_DWORD *)a2;
  v9 = (const char *)(*(_DWORD *)a2 & 4);
  if ( !v9 )
  {
    if ( a3 )
    {
      v10 = *(_DWORD *)(v509 + 4);
      v495 = *(char **)(v10 + 36);
      if ( **(_BYTE **)(v10 + 40) )
        v9 = *(const char **)(v10 + 40);
      v504 = v9;
      v519[2] = (int)funlockfile;
      v519[3] = a2;
      if ( (v8 & 0x8000) == 0 )
      {
        _EDX = *(_DWORD *)(a2 + 72);
        v26 = __readgsdword(8u);
        if ( v26 != *(_DWORD *)(_EDX + 8) )
        {
          _ECX = 1;
          v28 = __readgsdword(0xCu) == 0;
          if ( !v28 )
            __asm { lock }
          __asm { cmpxchg [edx], ecx }
          if ( !v28 )
            _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
          _EDX = *(_DWORD *)(a2 + 72);
          *(_DWORD *)(_EDX + 8) = v26;
        }
        ++*(_DWORD *)(_EDX + 4);
      }
      v518[0] = 0;
      v518[1] = 0;
      v516 = 0;
      v500 = 0;
      v512 = 0;
      v501 = a4;
      v513 = 0;
      v511 = 0;
      v506 = 0;
      v498 = 0;
      v496 = 0;
      v497 = 0;
      v510 = 0;
      while ( 2 )
      {
        v11 = *(_BYTE *)v5;
        if ( *(_BYTE *)v5 )
        {
          if ( (v11 & 0x80u) == 0 )
            goto LABEL_11;
          v18 = strlen((_BYTE *)v5);
          v19 = mbrlen((_BYTE *)v5, v18, v518);
          if ( v19 <= 0 )
          {
            v11 = *(_BYTE *)v5;
LABEL_11:
            v515 = (unsigned __int8 *)(v5 + 1);
            if ( v11 != 37 )
            {
              v12 = v11;
              if ( (*(_BYTE *)(*(_DWORD *)(v509 + 52) + 2 * v11 + 1) & 0x20) != 0 )
              {
                v516 = 1;
                goto LABEL_33;
              }
              if ( v513 == -1 )
              {
                v36 = (int *)a2;
                __writegsdword(0xFFFFFFE8, v512);
              }
              else
              {
                v13 = *(unsigned __int8 **)(a2 + 4);
                if ( (unsigned int)v13 < *(_DWORD *)(a2 + 8) )
                {
                  *(_DWORD *)(a2 + 4) = v13 + 1;
                  v14 = *v13;
                  goto LABEL_16;
                }
                v14 = _uflow((int *)a2);
                if ( v14 != -1 )
                {
LABEL_16:
                  v15 = ++v510;
                  if ( v516 )
                  {
                    for ( i = *(_DWORD *)(v509 + 52); (*(_BYTE *)(i + 2 * v14 + 1) & 0x20) != 0; i = *(_DWORD *)(v509 + 52) )
                    {
                      while ( 1 )
                      {
                        v17 = *(unsigned __int8 **)(a2 + 4);
                        if ( (unsigned int)v17 >= *(_DWORD *)(a2 + 8) )
                          break;
                        ++v15;
                        *(_DWORD *)(a2 + 4) = v17 + 1;
                        v14 = *v17;
                        if ( (*(_BYTE *)(i + 2 * v14 + 1) & 0x20) == 0 )
                          goto LABEL_21;
                      }
                      v14 = _uflow((int *)a2);
                      if ( v14 == -1 )
                      {
                        v36 = (int *)a2;
                        if ( v511 )
                          v14 = v511;
                        v511 = v14;
                        goto LABEL_53;
                      }
                      ++v15;
                    }
LABEL_21:
                    v510 = v15;
                  }
                  v513 = v12;
                  if ( v14 == v12 )
                    goto LABEL_23;
LABEL_461:
                  v36 = (int *)a2;
                  IO_sputbackc((_DWORD *)a2, (unsigned __int8)v14);
                  v516 = 2;
                  break;
                }
                v36 = (int *)a2;
              }
              v516 = 1;
              if ( !v511 )
                v511 = -1;
              break;
            }
            v527 = v529;
            v528 = &v529[v530];
            v29 = *(unsigned __int8 *)(v5 + 1);
            v30 = (int *)(v29 - 48);
            if ( (unsigned int)(v29 - 48) > 9 )
            {
              v503 = 0;
            }
            else
            {
              v31 = v29 - 48;
              v503 = v30;
              v32 = *(unsigned __int8 *)(v5 + 2);
              v515 = (unsigned __int8 *)(v5 + 2);
              v33 = v32;
              if ( (unsigned int)(v32 - 48) <= 9 )
              {
                v34 = (unsigned __int8 *)(v5 + 2);
                do
                {
                  ++v34;
                  v31 = v32 + 10 * v31 - 48;
                  v32 = *v34;
                  v5 = v32 - 48;
                  v33 = *v34;
                }
                while ( (unsigned int)(v32 - 48) <= 9 );
                v515 = v34;
                v503 = (int *)v31;
              }
              if ( v33 != 36 )
              {
                v35 = v503;
                v507 = 0;
                v503 = 0;
                v514 = (int)v35;
                LOBYTE(v29) = *v515;
                goto LABEL_83;
              }
              LOBYTE(v29) = *++v515;
            }
            v5 = 0;
            v38 = v515;
            while ( (_BYTE)v29 == 39 || (_BYTE)v29 == 42 || (_BYTE)v29 == 73 )
            {
              ++v38;
              switch ( (_BYTE)v29 )
              {
                case '*':
                  v5 |= 8u;
                  break;
                case 'I':
                  v5 |= 0x400u;
                  break;
                case '\'':
                  v39 = v5;
                  if ( v504 )
                  {
                    LOBYTE(v39) = v5 | 0x80;
                    v5 = v39;
                  }
                  break;
              }
              LOBYTE(v29) = *v38;
            }
            v40 = v38;
            v515 = v38;
            v41 = (unsigned __int8)v29 - 48;
            v507 = v5;
            if ( v41 > 9 )
            {
              v514 = -1;
              goto LABEL_86;
            }
            v42 = 0;
            do
            {
              ++v40;
              v42 = v41 + 10 * v42;
              v29 = *v40;
              v41 = v29 - 48;
            }
            while ( (unsigned int)(v29 - 48) <= 9 );
            v515 = v40;
            v514 = v42;
LABEL_83:
            v43 = -1;
            if ( v514 )
              v43 = v514;
            v514 = v43;
LABEL_86:
            v44 = v515 + 1;
            switch ( (char)v29 )
            {
              case 'L':
              case 'q':
                v507 |= 3u;
                goto LABEL_93;
              case 'a':
                v45 = v515[1];
                if ( (v45 & 0xF7) == 83 || v45 == 115 )
                {
                  v5 = a2;
                  if ( (*(_BYTE *)(a2 + 60) & 0x10) == 0 )
                  {
                    v507 |= 0x100u;
                    LOBYTE(v29) = v45;
LABEL_94:
                    if ( !(_BYTE)v29 )
                    {
                      v36 = (int *)a2;
                      v516 = 2;
                      goto LABEL_53;
                    }
                    v515 = v44 + 1;
                    if ( v516 || (_BYTE)v29 != 91 && (v29 & 0xDF) != 67 && (_BYTE)v29 != 110 )
                      goto LABEL_108;
                    switch ( (char)v29 )
                    {
                      case '%':
                        if ( v513 == -1 )
                        {
                          v36 = (int *)a2;
                          v176 = -24;
LABEL_405:
                          __writegsdword(v176, v512);
                        }
                        else
                        {
LABEL_392:
                          v174 = *(unsigned __int8 **)(a2 + 4);
                          if ( (unsigned int)v174 < *(_DWORD *)(a2 + 8) )
                          {
                            *(_DWORD *)(a2 + 4) = v174 + 1;
                            v513 = *v174;
                            goto LABEL_394;
                          }
                          v513 = _uflow((int *)a2);
                          if ( v513 != -1 )
                          {
LABEL_394:
                            ++v510;
                            if ( v513 != 37 )
                            {
                              v36 = (int *)a2;
                              IO_sputbackc((_DWORD *)a2, (unsigned __int8)v513);
                              v516 = 2;
                              goto LABEL_53;
                            }
                            goto LABEL_23;
                          }
                          v36 = (int *)a2;
                        }
                        v516 = 1;
                        if ( !v511 )
                          v511 = -1;
                        goto LABEL_53;
                      case 'A':
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'a':
                      case 'e':
                      case 'f':
                      case 'g':
                        if ( v513 == -1 )
                        {
                          v36 = (int *)a2;
                          v175 = -24;
LABEL_401:
                          __writegsdword(v175, v512);
                        }
                        else
                        {
LABEL_339:
                          v155 = *(unsigned __int8 **)(a2 + 4);
                          if ( (unsigned int)v155 < *(_DWORD *)(a2 + 8) )
                          {
                            ++v510;
                            *(_DWORD *)(a2 + 4) = v155 + 1;
                            v513 = *v155;
                            if ( v514 <= 0 )
                              goto LABEL_342;
                            goto LABEL_341;
                          }
                          v513 = _uflow((int *)a2);
                          if ( v513 != -1 )
                          {
                            ++v510;
                            if ( v514 <= 0 )
                            {
                              if ( ((v513 - 43) & 0xFFFFFFFD) == 0 )
                              {
                                LOBYTE(v493) = v513 == 45;
LABEL_344:
                                v156 = *(unsigned __int8 **)(a2 + 4);
                                if ( (unsigned int)v156 >= *(_DWORD *)(a2 + 8) )
                                {
                                  v513 = _uflow((int *)a2);
                                  if ( v513 == -1 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                }
                                else
                                {
                                  *(_DWORD *)(a2 + 4) = v156 + 1;
                                  v513 = *v156;
                                }
                                ++v510;
                                v514 -= v514 > 0;
LABEL_347:
                                v157 = v509;
                                v158 = *(_DWORD *)(*(_DWORD *)(v509 + 56) + 4 * (unsigned __int8)v513);
                                if ( v158 == 110 )
                                {
                                  v265 = v527;
                                  if ( v527 == v528 )
                                  {
                                    char_buffer_add_slow((int)&v527, v513);
                                  }
                                  else
                                  {
                                    ++v527;
                                    *v265 = v513;
                                  }
                                  if ( !v514 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v266 = *(_BYTE **)(a2 + 4);
                                  if ( (unsigned int)v266 >= *(_DWORD *)(a2 + 8) )
                                  {
                                    v266 = (_BYTE *)_uflow((int *)a2);
                                    if ( v266 == (_BYTE *)-1 )
                                    {
                                      v36 = (int *)a2;
                                      v516 = 2;
                                      goto LABEL_53;
                                    }
                                  }
                                  else
                                  {
                                    *(_DWORD *)(a2 + 4) = v266 + 1;
                                    LOBYTE(v266) = *v266;
                                  }
                                  if ( *(_DWORD *)(*(_DWORD *)(v509 + 56) + 4 * (unsigned __int8)v266) != 97 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v267 = v527;
                                  v514 -= v514 > 0;
                                  if ( v527 == v528 )
                                  {
                                    char_buffer_add_slow((int)&v527, (char)v266);
                                  }
                                  else
                                  {
                                    ++v527;
                                    *v267 = (unsigned __int8)v266;
                                  }
                                  if ( !v514 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v268 = *(unsigned __int8 **)(a2 + 4);
                                  if ( (unsigned int)v268 >= *(_DWORD *)(a2 + 8) )
                                  {
                                    v513 = _uflow((int *)a2);
                                    if ( v513 == -1 )
                                    {
                                      v36 = (int *)a2;
                                      v516 = 2;
                                      goto LABEL_53;
                                    }
                                    v510 += 2;
                                  }
                                  else
                                  {
                                    v510 += 2;
                                    *(_DWORD *)(a2 + 4) = v268 + 1;
                                    v513 = *v268;
                                  }
                                  if ( *(_DWORD *)(*(_DWORD *)(v509 + 56) + 4 * (unsigned __int8)v513) != 110 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v269 = v527;
                                  if ( v527 == v528 )
                                    goto LABEL_1227;
                                }
                                else
                                {
                                  if ( v158 != 105 )
                                  {
                                    if ( !v514 || v513 != 48 )
                                    {
                                      LOBYTE(v508) = 101;
                                      v161 = 0;
                                      goto LABEL_358;
                                    }
                                    v159 = v527;
                                    if ( v527 == v528 )
                                    {
                                      char_buffer_add_slow((int)&v527, 48);
                                    }
                                    else
                                    {
                                      ++v527;
                                      *v159 = 48;
                                    }
                                    v157 = a2;
                                    v160 = *(unsigned __int8 **)(a2 + 4);
                                    if ( (unsigned int)v160 >= *(_DWORD *)(a2 + 8) )
                                    {
                                      v513 = _uflow((int *)a2);
                                      if ( v513 == -1 )
                                      {
                                        v512 = __readgsdword(0xFFFFFFE8);
LABEL_356:
                                        v514 -= v514 > 0;
                                        if ( !v514 )
                                        {
                                          LOBYTE(v508) = 101;
                                          v161 = 1;
                                          goto LABEL_358;
                                        }
                                        LOBYTE(v508) = 101;
                                        v161 = 1;
                                        if ( *(_DWORD *)(*(_DWORD *)(v509 + 56) + 4 * (unsigned __int8)v513) != 120 )
                                        {
LABEL_358:
                                          LOBYTE(v502) = 0;
                                          LOBYTE(v505) = 0;
                                          LOBYTE(v494) = v161;
                                          v162 = v513;
                                          while ( 1 )
                                          {
                                            v164 = v527;
                                            if ( !v527 )
                                              goto LABEL_1332;
                                            if ( (unsigned int)(v162 - 48) <= 9 )
                                            {
                                              if ( v527 == v528 )
                                              {
                                                char_buffer_add_slow((int)&v527, v162);
                                              }
                                              else
                                              {
                                                ++v527;
                                                *v164 = v162;
                                              }
                                              if ( v514 )
                                              {
                                                LOBYTE(v494) = 1;
                                                goto LABEL_363;
                                              }
LABEL_999:
                                              v513 = v162;
                                              goto LABEL_491;
                                            }
                                            if ( (_BYTE)v502 )
                                            {
                                              v157 = (unsigned __int8)v508;
                                              if ( (_BYTE)v508 == *(v527 - 1) && ((v162 - 43) & 0xFFFFFFFD) == 0 )
                                              {
                                                if ( v527 == v528 )
                                                {
                                                  char_buffer_add_slow((int)&v527, v162);
                                                }
                                                else
                                                {
                                                  ++v527;
                                                  *v164 = v162;
                                                }
                                                goto LABEL_488;
                                              }
                                            }
                                            else
                                            {
                                              if ( (v507 & 0x800) != 0
                                                && (*(_BYTE *)(*(_DWORD *)(v509 + 52) + 2 * v162 + 1) & 0x10) != 0 )
                                              {
                                                if ( v527 == v528 )
                                                {
                                                  char_buffer_add_slow((int)&v527, v162);
                                                  LOBYTE(v494) = 1;
                                                }
                                                else
                                                {
                                                  LOBYTE(v494) = 1;
                                                  ++v527;
                                                  *v164 = v162;
                                                }
                                                goto LABEL_488;
                                              }
                                              if ( (_BYTE)v494 )
                                              {
                                                v157 = *(_DWORD *)(v509 + 56);
                                                if ( (_BYTE)v508 == *(_BYTE *)(v157 + 4 * (unsigned __int8)v162) )
                                                {
                                                  if ( v527 == v528 )
                                                  {
                                                    char_buffer_add_slow((int)&v527, v508);
                                                  }
                                                  else
                                                  {
                                                    ++v527;
                                                    *v164 = v508;
                                                  }
                                                  LOBYTE(v502) = (_BYTE)v494;
                                                  LOBYTE(v505) = (_BYTE)v494;
                                                  goto LABEL_488;
                                                }
                                              }
                                            }
                                            v165 = 0x7FFFFFFF;
                                            if ( v514 > 0 )
                                              v165 = v514;
                                            v516 = v165;
                                            if ( (_BYTE)v505 )
                                              break;
                                            v166 = *v495;
                                            v157 = (unsigned __int8)*v495;
                                            if ( v162 != v157 )
                                            {
                                              v167 = v495;
LABEL_383:
                                              if ( v166 )
                                                goto LABEL_716;
                                              v171 = *v495;
                                              goto LABEL_385;
                                            }
                                            v167 = v495 + 1;
                                            if ( !v495[1] )
                                            {
                                              v169 = v162;
LABEL_1034:
                                              v171 = v157;
                                              v162 = v169;
LABEL_385:
                                              v172 = v495;
                                              if ( v171 )
                                              {
                                                do
                                                {
                                                  v173 = v527;
                                                  if ( v527 == v528 )
                                                  {
                                                    char_buffer_add_slow((int)&v527, v171);
                                                  }
                                                  else
                                                  {
                                                    ++v527;
                                                    *v173 = v171;
                                                  }
                                                  v171 = *++v172;
                                                }
                                                while ( *v172 );
                                              }
LABEL_606:
                                              if ( v514 > 0 )
                                                v514 = v516;
                                              LOBYTE(v505) = 1;
                                              goto LABEL_488;
                                            }
                                            v168 = v516;
                                            do
                                            {
                                              v170 = *(unsigned __int8 **)(a2 + 4);
                                              if ( (unsigned int)v170 < *(_DWORD *)(a2 + 8) )
                                              {
                                                *(_DWORD *)(a2 + 4) = v170 + 1;
                                                v157 = *v170;
                                              }
                                              else
                                              {
                                                v157 = _uflow((int *)a2);
                                                if ( v157 == -1 )
                                                {
                                                  v516 = v168;
                                                  v162 = -1;
                                                  v166 = *v167;
                                                  v512 = __readgsdword(0xFFFFFFE8);
                                                  goto LABEL_383;
                                                }
                                              }
                                              v169 = (unsigned __int8)*v167;
                                              ++v510;
                                              --v168;
                                              v166 = v169;
                                              if ( v169 != v157 )
                                              {
                                                v516 = v168;
                                                v162 = v157;
                                                goto LABEL_383;
                                              }
                                              if ( !*++v167 )
                                              {
                                                v516 = v168;
                                                LOBYTE(v157) = *v495;
                                                goto LABEL_1034;
                                              }
                                            }
                                            while ( v168 );
                                            v516 = 0;
                                            v162 = v157;
LABEL_716:
                                            if ( (v507 & 0x80u) == 0 )
                                              goto LABEL_610;
                                            v270 = v167 - v495;
                                            if ( v167 - v495 <= 0 )
                                            {
                                              v271 = 0;
                                              v236 = v504;
                                              goto LABEL_723;
                                            }
                                            v157 = (int)v504;
                                            if ( *v504 != *v495 )
                                            {
                                              v236 = v504;
LABEL_612:
                                              if ( !*v236 )
                                                goto LABEL_613;
                                              goto LABEL_1153;
                                            }
                                            v236 = v504;
                                            v513 = v162;
                                            while ( 1 )
                                            {
                                              v271 = ++v236 - v504;
                                              if ( v270 <= v236 - v504 )
                                                break;
                                              if ( *v236 != v495[v271] )
                                              {
                                                v162 = v513;
                                                goto LABEL_612;
                                              }
                                            }
                                            v162 = v513;
LABEL_723:
                                            if ( v270 != v271 )
                                              goto LABEL_611;
                                            v272 = *(unsigned __int8 *)v236;
                                            if ( v272 != v162 )
                                              goto LABEL_612;
                                            if ( v236[1] )
                                            {
                                              if ( v516 )
                                              {
                                                ++v236;
                                                while ( 1 )
                                                {
                                                  v273 = *(unsigned __int8 **)(a2 + 4);
                                                  if ( (unsigned int)v273 < *(_DWORD *)(a2 + 8) )
                                                  {
                                                    *(_DWORD *)(a2 + 4) = v273 + 1;
                                                    v162 = *v273;
                                                  }
                                                  else
                                                  {
                                                    v162 = _uflow((int *)a2);
                                                    if ( v162 == -1 )
                                                    {
                                                      v512 = __readgsdword(0xFFFFFFE8);
                                                      goto LABEL_612;
                                                    }
                                                  }
                                                  v272 = *(unsigned __int8 *)v236;
                                                  ++v510;
                                                  --v516;
                                                  if ( v272 != v162 )
                                                    goto LABEL_612;
                                                  if ( !*++v236 )
                                                    goto LABEL_1197;
                                                  if ( !v516 )
                                                    goto LABEL_1199;
                                                }
                                              }
                                              v272 = v162;
LABEL_1199:
                                              v513 = v272;
LABEL_1154:
                                              if ( v513 != -1 )
                                              {
                                                v488 = v157;
                                                v487 = v157;
                                                --v510;
                                                IO_sputbackc((_DWORD *)a2, (unsigned __int8)v513);
                                              }
LABEL_491:
                                              v193 = v527;
                                              if ( !v527 )
                                                goto LABEL_1332;
                                              if ( (v507 & 0x400) == 0 )
                                                goto LABEL_493;
                                              v516 = v507 & 0x800;
                                              if ( (v507 & 0x800) != 0 || v529 != v527 && (v505 & 1) == 0 )
                                                goto LABEL_493;
                                              v491 = (int *)wctrans((int)"to_inpunct");
                                              if ( !v491 )
                                                goto LABEL_1326;
                                              if ( v513 == -1 )
                                              {
                                                v439 = -24;
                                                __writegsdword(0xFFFFFFE8, v512);
                                              }
                                              else
                                              {
                                                v438 = *(unsigned __int8 **)(a2 + 4);
                                                if ( (unsigned int)v438 < *(_DWORD *)(a2 + 8) )
                                                {
                                                  *(_DWORD *)(a2 + 4) = v438 + 1;
                                                  v439 = *v438;
                                                  v513 = v439;
                                                  goto LABEL_1297;
                                                }
                                                v513 = _uflow((int *)a2);
                                                v439 = v513 + 1;
                                                if ( v513 == -1 )
                                                {
                                                  v439 = __readgsdword(0xFFFFFFE8);
                                                  v512 = v439;
                                                }
                                                else
                                                {
LABEL_1297:
                                                  ++v510;
                                                }
                                              }
                                              v488 = v439;
                                              v487 = v439;
                                              v522 = towctrans(0x2Eu, v491);
                                              v494 = v520;
                                              memset(v520, 0, 8u);
                                              v440 = v527 == v529;
                                              v441 = wcrtomb(v526, v522, v520);
                                              if ( v441 == -1 )
                                              {
                                                v466 = strlen(v495) + 1;
                                                if ( v466 - 1 > 0x10 )
                                                  goto LABEL_1326;
                                                v445 = v440 || v527 - v529 == v466 - 1;
                                                qmemcpy(v526, v495, v466);
                                              }
                                              else
                                              {
                                                v442 = v495;
                                                v526[v441] = 0;
                                                v443 = strlen(v442) + 1;
                                                v444 = 0;
                                                if ( v443 - 1 == v527 - v529 )
                                                {
                                                  v488 = v443 - 1;
                                                  v487 = v443 - 1;
                                                  v444 = j_strcmp(v495, v526) == 0;
                                                }
                                                v445 = v444 || v440;
                                              }
                                              if ( !v445 )
                                                goto LABEL_1326;
                                              v446 = 0;
                                              LOBYTE(v490) = (v507 & 0x80) != 0;
                                              v447 = &v523;
                                              v492 = (int)&v523;
                                              do
                                              {
                                                v488 = (int)v447;
                                                v487 = (int)v447;
                                                v448 = towctrans(v446 + 48, v491);
                                                v449 = v494;
                                                v521[v446] = v448;
                                                memset(v449, 0, 8u);
                                                v450 = (int *)v492;
                                                v451 = wcrtomb(v492, v448, v494);
                                                if ( v451 == -1 )
                                                  goto LABEL_1326;
                                                v452 = 17 * v446++;
                                                v531[v452 - 220 + v451] = 0;
                                                v447 = (int *)((char *)v450 + 17);
                                                v492 = (int)v450 + 17;
                                              }
                                              while ( v446 != 10 );
                                              v488 = (int)v450 + 17;
                                              v487 = (int)v450 + 17;
                                              v453 = towctrans(0x2Cu, v491);
                                              v521[10] = v453;
                                              v454 = v490 & (v453 != 0);
                                              memset(v494, 0, 8u);
                                              v455 = wcrtomb(v492, v453, v494);
                                              if ( v455 == -1 )
                                              {
                                                if ( v454 )
                                                {
                                                  v484 = strlen(v504) + 1;
                                                  if ( v484 - 1 <= 0x10 )
                                                    qmemcpy(v525, v504, v484);
                                                }
                                              }
                                              else
                                              {
                                                v525[v455] = 0;
                                              }
                                              v456 = v513;
                                              v492 = (char)v508;
LABEL_1309:
                                              v457 = v527;
                                              if ( !v527 )
                                                goto LABEL_1327;
                                              if ( (_BYTE)v502 )
                                              {
                                                if ( (_BYTE)v508 == *(v527 - 1) && ((v456 - 43) & 0xFFFFFFFD) == 0 )
                                                {
                                                  v474 = v456;
                                                  if ( v527 == v528 )
                                                    goto LABEL_1362;
                                                  ++v527;
                                                  *v457 = v456;
                                                  goto LABEL_1353;
                                                }
                                              }
                                              else if ( v527 != v529
                                                     && (_BYTE)v508 == *(_BYTE *)(*(_DWORD *)(v509 + 56)
                                                                                + 4 * (unsigned __int8)v456) )
                                              {
                                                if ( v527 == v528 )
                                                {
                                                  char_buffer_add_slow((int)&v527, v492);
                                                  LOBYTE(v502) = 1;
                                                  LOBYTE(v505) = 1;
                                                }
                                                else
                                                {
                                                  LOBYTE(v502) = 1;
                                                  LOBYTE(v505) = 1;
                                                  ++v527;
                                                  *v457 = v508;
                                                }
                                                goto LABEL_1353;
                                              }
                                              v458 = &v523;
                                              v459 = 0x7FFFFFFF;
                                              if ( v514 > 0 )
                                                v459 = v514;
                                              v494 = (char *)v459;
                                              v513 = 0;
                                              while ( 1 )
                                              {
                                                v460 = *(unsigned __int8 *)v458;
                                                if ( v460 == v456 )
                                                {
                                                  v461 = (int *)((char *)v458 + 1);
                                                  if ( !*((_BYTE *)v458 + 1) )
                                                    goto LABEL_1393;
                                                  v462 = (int *)v494;
                                                  while ( 1 )
                                                  {
                                                    v465 = *(unsigned __int8 **)(a2 + 4);
                                                    if ( (unsigned int)v465 < *(_DWORD *)(a2 + 8) )
                                                    {
                                                      *(_DWORD *)(a2 + 4) = v465 + 1;
                                                      v463 = *v465;
                                                    }
                                                    else
                                                    {
                                                      v491 = v462;
                                                      v463 = _uflow((int *)a2);
                                                      v462 = v491;
                                                      if ( v463 == -1 )
                                                      {
                                                        v456 = -1;
                                                        v463 = __readgsdword(0xFFFFFFE8);
                                                        v512 = v463;
                                                        goto LABEL_1390;
                                                      }
                                                    }
                                                    v464 = *(unsigned __int8 *)v461;
                                                    ++v510;
                                                    v462 = (int *)((char *)v462 - 1);
                                                    if ( v464 != v463 )
                                                      break;
                                                    v461 = (int *)((char *)v461 + 1);
                                                    if ( !*(_BYTE *)v461 )
                                                    {
                                                      v456 = v464;
                                                      goto LABEL_1347;
                                                    }
                                                    if ( !v462 )
                                                    {
                                                      v456 = v464;
                                                      goto LABEL_1335;
                                                    }
                                                  }
                                                  v456 = v463;
LABEL_1390:
                                                  if ( !*(_BYTE *)v461 )
                                                  {
LABEL_1347:
                                                    v472 = v513;
                                                    goto LABEL_1348;
                                                  }
LABEL_1335:
                                                  if ( v461 > v458 )
                                                  {
                                                    if ( v456 != -1 )
                                                    {
                                                      v488 = v463;
                                                      v487 = v463;
                                                      --v510;
                                                      IO_sputbackc((_DWORD *)a2, (unsigned __int8)v456);
                                                    }
                                                    v467 = (unsigned __int8 *)v461 - 1;
                                                    if ( (int *)((char *)v461 - 1) > v458 )
                                                    {
                                                      v468 = (int *)((char *)v461 - 1);
                                                      do
                                                      {
                                                        v469 = *(unsigned __int8 *)v468;
                                                        v491 = v468;
                                                        IO_sputbackc((_DWORD *)a2, v469);
                                                        v468 = (int *)((char *)v491 - 1);
                                                      }
                                                      while ( v458 != (int *)((char *)v491 - 1) );
                                                      v470 = (char *)v458 - (char *)v461 + 1;
                                                      v510 += v470;
                                                      v467 += v470;
                                                    }
                                                    v456 = *v467;
                                                  }
                                                }
                                                else if ( !(_BYTE)v460 )
                                                {
LABEL_1393:
                                                  v472 = v513;
                                                  v462 = (int *)v494;
LABEL_1348:
                                                  if ( v514 <= 0 )
                                                    v462 = (int *)v514;
                                                  v514 = (int)v462;
                                                  if ( v472 > 9 )
                                                  {
                                                    v471 = ((unsigned __int8)v505 ^ 1) & 1;
                                                    if ( v472 == 11 && (_BYTE)v471 )
                                                    {
                                                      for ( j = v495; ; ++j )
                                                      {
                                                        v477 = *j;
                                                        if ( !*j )
                                                          break;
                                                        v478 = v527;
                                                        if ( v527 == v528 )
                                                        {
                                                          char_buffer_add_slow((int)&v527, v477);
                                                        }
                                                        else
                                                        {
                                                          ++v527;
                                                          *v478 = v477;
                                                        }
                                                      }
                                                      LOBYTE(v505) = 1;
                                                      goto LABEL_1353;
                                                    }
                                                    if ( v472 == 10
                                                      && ((unsigned __int8)v471 & (unsigned __int8)v490) != 0 )
                                                    {
                                                      for ( k = (char *)v504; ; ++k )
                                                      {
                                                        v481 = *k;
                                                        if ( !*k )
                                                          break;
                                                        v482 = v527;
                                                        if ( v527 == v528 )
                                                        {
                                                          char_buffer_add_slow((int)&v527, v481);
                                                        }
                                                        else
                                                        {
                                                          ++v527;
                                                          *v482 = v481;
                                                        }
                                                      }
                                                      LOBYTE(v505) = 0;
                                                      goto LABEL_1353;
                                                    }
LABEL_1344:
                                                    v513 = v456;
                                                    if ( v456 != -1 )
                                                    {
                                                      v488 = v471;
                                                      v487 = v471;
                                                      --v510;
                                                      IO_sputbackc((_DWORD *)a2, (unsigned __int8)v513);
                                                    }
                                                  }
                                                  else
                                                  {
                                                    v473 = v527;
                                                    v474 = v472 + 48;
                                                    if ( v527 != v528 )
                                                    {
                                                      ++v527;
                                                      *v473 = v472 + 48;
                                                      goto LABEL_1353;
                                                    }
LABEL_1362:
                                                    char_buffer_add_slow((int)&v527, v474);
LABEL_1353:
                                                    if ( v514 )
                                                    {
                                                      if ( v456 != -1 )
                                                      {
                                                        v475 = *(unsigned __int8 **)(a2 + 4);
                                                        if ( (unsigned int)v475 < *(_DWORD *)(a2 + 8) )
                                                        {
                                                          *(_DWORD *)(a2 + 4) = v475 + 1;
                                                          v456 = *v475;
                                                          goto LABEL_1357;
                                                        }
                                                        v456 = _uflow((int *)a2);
                                                        if ( v456 == -1 )
                                                        {
                                                          v513 = -1;
                                                          v512 = __readgsdword(0xFFFFFFE8);
                                                          goto LABEL_1326;
                                                        }
LABEL_1357:
                                                        ++v510;
                                                        v514 -= v514 > 0;
                                                        goto LABEL_1309;
                                                      }
                                                      v513 = -1;
                                                      __writegsdword(0xFFFFFFE8, v512);
                                                    }
                                                    else
                                                    {
                                                      v513 = v456;
                                                    }
                                                  }
LABEL_1326:
                                                  v193 = v527;
                                                  if ( !v527 )
                                                  {
LABEL_1327:
                                                    v36 = (int *)a2;
                                                    v511 = -1;
                                                    __writegsdword(0xFFFFFFE8, 0xCu);
                                                    goto LABEL_53;
                                                  }
LABEL_493:
                                                  if ( v193 == v529 )
                                                  {
                                                    v36 = (int *)a2;
                                                    v516 = 2;
                                                    goto LABEL_53;
                                                  }
                                                  if ( (v507 & 0x800) != 0 && v193 - v529 == 2 )
                                                  {
                                                    v36 = (int *)a2;
                                                    v516 = 2;
                                                    goto LABEL_53;
                                                  }
LABEL_496:
                                                  v194 = v527;
                                                  if ( v527 == v528 )
                                                  {
                                                    char_buffer_add_slow((int)&v527, 0);
                                                  }
                                                  else
                                                  {
                                                    ++v527;
                                                    *v194 = 0;
                                                  }
                                                  if ( v527 )
                                                  {
                                                    if ( (v507 & 2) != 0 )
                                                    {
                                                      v354 = v507;
                                                      _strtold_internal((unsigned int)v529, &v517, v507 & 0x80);
                                                      if ( (v354 & 8) != 0 )
                                                        goto LABEL_697;
                                                      v196 = v529;
                                                      v197 = v517;
                                                      if ( v517 == v529 )
                                                        goto LABEL_1283;
                                                      if ( v503 )
                                                      {
                                                        v391 = &a4[(_DWORD)v503 - 1];
                                                        if ( v503 == (int *)1 )
                                                          v391 = a4;
                                                        v355 = *v391;
                                                      }
                                                      else
                                                      {
                                                        v355 = *v501++;
                                                      }
                                                      if ( (_BYTE)v493 )
                                                        a1 = -a1;
                                                      *v355 = a1;
                                                    }
                                                    else
                                                    {
                                                      v195 = v507;
                                                      if ( (v507 & 3) != 0 )
                                                      {
                                                        _strtod_internal((unsigned int)v529, &v517, v507 & 0x80);
                                                        if ( (v195 & 8) == 0 )
                                                        {
                                                          v196 = v529;
                                                          v197 = v517;
                                                          if ( v517 != v529 )
                                                          {
                                                            if ( v503 )
                                                            {
                                                              v382 = (double **)&a4[(_DWORD)v503 - 1];
                                                              if ( v503 == (int *)1 )
                                                                v382 = (double **)a4;
                                                              v198 = *v382;
                                                            }
                                                            else
                                                            {
                                                              v198 = (double *)*v501++;
                                                            }
                                                            if ( (_BYTE)v493 )
                                                              a1 = -a1;
                                                            *v198 = a1;
                                                            goto LABEL_508;
                                                          }
LABEL_1283:
                                                          v36 = (int *)a2;
                                                          v516 = 2;
                                                          goto LABEL_53;
                                                        }
LABEL_697:
                                                        if ( v517 == v529 )
                                                        {
                                                          v36 = (int *)a2;
                                                          v516 = 2;
                                                          goto LABEL_53;
                                                        }
LABEL_23:
                                                        v516 = 0;
                                                        goto LABEL_33;
                                                      }
                                                      v299 = v507;
                                                      _strtof_internal((unsigned int)v529, &v517, v507 & 0x80);
                                                      if ( (v299 & 8) != 0 )
                                                        goto LABEL_697;
                                                      v196 = v529;
                                                      v197 = v517;
                                                      if ( v517 == v529 )
                                                        goto LABEL_1283;
                                                      if ( v503 )
                                                      {
                                                        v390 = (float **)&a4[(_DWORD)v503 - 1];
                                                        if ( v503 == (int *)1 )
                                                          v390 = (float **)a4;
                                                        v300 = *v390;
                                                      }
                                                      else
                                                      {
                                                        v300 = (float *)*v501++;
                                                      }
                                                      if ( (_BYTE)v493 )
                                                        a1 = -a1;
                                                      *v300 = a1;
                                                    }
LABEL_508:
                                                    if ( v196 == v197 )
                                                    {
                                                      v36 = (int *)a2;
                                                      v516 = 2;
                                                      goto LABEL_53;
                                                    }
                                                    ++v511;
                                                    v516 = 0;
                                                    goto LABEL_33;
                                                  }
LABEL_1332:
                                                  v36 = (int *)a2;
                                                  v516 = 0;
                                                  v511 = -1;
                                                  __writegsdword(0xFFFFFFE8, 0xCu);
                                                  goto LABEL_53;
                                                }
                                                ++v513;
                                                v458 = (int *)((char *)v458 + 17);
                                                v471 = v513;
                                                if ( v513 == 12 )
                                                  goto LABEL_1344;
                                              }
                                            }
LABEL_1197:
                                            v162 = v272;
LABEL_613:
                                            v237 = *v504;
                                            for ( m = (char *)v504; *m; v237 = *m )
                                            {
                                              v239 = v527;
                                              if ( v527 == v528 )
                                              {
                                                char_buffer_add_slow((int)&v527, v237);
                                              }
                                              else
                                              {
                                                ++v527;
                                                *v239 = v237;
                                              }
                                              ++m;
                                            }
                                            v248 = v516;
                                            if ( v514 <= 0 )
                                              v248 = v514;
                                            v514 = v248;
LABEL_488:
                                            if ( !v514 )
                                              goto LABEL_999;
                                            if ( v162 == -1 )
                                            {
                                              v513 = -1;
                                              __writegsdword(0xFFFFFFE8, v512);
                                              goto LABEL_491;
                                            }
LABEL_363:
                                            v163 = *(unsigned __int8 **)(a2 + 4);
                                            if ( (unsigned int)v163 >= *(_DWORD *)(a2 + 8) )
                                            {
                                              v162 = _uflow((int *)a2);
                                              if ( v162 == -1 )
                                              {
                                                v513 = -1;
                                                v512 = __readgsdword(0xFFFFFFE8);
                                                goto LABEL_491;
                                              }
                                            }
                                            else
                                            {
                                              *(_DWORD *)(a2 + 4) = v163 + 1;
                                              v162 = *v163;
                                            }
                                            ++v510;
                                            v157 = v514 - (v514 > 0);
                                            v514 = v157;
                                          }
                                          if ( *v495 )
                                          {
LABEL_610:
                                            v236 = v504;
LABEL_611:
                                            if ( v236 )
                                              goto LABEL_612;
LABEL_1153:
                                            v513 = v162;
                                            goto LABEL_1154;
                                          }
                                          goto LABEL_606;
                                        }
                                        v392 = v527;
                                        if ( v527 == v528 )
                                        {
                                          char_buffer_add_slow((int)&v527, v513);
                                        }
                                        else
                                        {
                                          v157 = (unsigned __int8)v513;
                                          ++v527;
                                          *v392 = v513;
                                        }
                                        HIWORD(v393) = HIWORD(v507);
                                        LOBYTE(v393) = v507 & 0x7F;
                                        BYTE1(v393) = BYTE1(v507) | 8;
                                        v507 = v393;
                                        if ( v513 == -1 )
                                        {
                                          v157 = v512;
                                          __writegsdword(0xFFFFFFE8, v512);
                                        }
                                        else
                                        {
                                          v394 = *(unsigned __int8 **)(a2 + 4);
                                          if ( (unsigned int)v394 < *(_DWORD *)(a2 + 8) )
                                          {
                                            *(_DWORD *)(a2 + 4) = v394 + 1;
                                            v513 = *v394;
LABEL_1107:
                                            ++v510;
                                            goto LABEL_1108;
                                          }
                                          v513 = _uflow((int *)a2);
                                          if ( v513 != -1 )
                                            goto LABEL_1107;
                                          v512 = __readgsdword(0xFFFFFFE8);
                                        }
LABEL_1108:
                                        LOBYTE(v508) = 112;
                                        v161 = 0;
                                        if ( v514 > 0 )
                                          --v514;
                                        goto LABEL_358;
                                      }
                                    }
                                    else
                                    {
                                      *(_DWORD *)(a2 + 4) = v160 + 1;
                                      v513 = *v160;
                                    }
                                    ++v510;
                                    goto LABEL_356;
                                  }
                                  v287 = v527;
                                  if ( v527 == v528 )
                                  {
                                    char_buffer_add_slow((int)&v527, v513);
                                  }
                                  else
                                  {
                                    ++v527;
                                    *v287 = v513;
                                  }
                                  if ( !v514 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v288 = *(_BYTE **)(a2 + 4);
                                  if ( (unsigned int)v288 >= *(_DWORD *)(a2 + 8) )
                                  {
                                    v288 = (_BYTE *)_uflow((int *)a2);
                                    if ( v288 == (_BYTE *)-1 )
                                    {
                                      v36 = (int *)a2;
                                      v516 = 2;
                                      goto LABEL_53;
                                    }
                                  }
                                  else
                                  {
                                    *(_DWORD *)(a2 + 4) = v288 + 1;
                                    LOBYTE(v288) = *v288;
                                  }
                                  if ( *(_DWORD *)(*(_DWORD *)(v509 + 56) + 4 * (unsigned __int8)v288) != 110 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v289 = v527;
                                  v514 -= v514 > 0;
                                  if ( v527 == v528 )
                                  {
                                    char_buffer_add_slow((int)&v527, (char)v288);
                                  }
                                  else
                                  {
                                    ++v527;
                                    *v289 = (unsigned __int8)v288;
                                  }
                                  if ( !v514 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v290 = *(unsigned __int8 **)(a2 + 4);
                                  if ( (unsigned int)v290 >= *(_DWORD *)(a2 + 8) )
                                  {
                                    v513 = _uflow((int *)a2);
                                    if ( v513 == -1 )
                                    {
                                      v36 = (int *)a2;
                                      v516 = 2;
                                      goto LABEL_53;
                                    }
                                    v291 = v510 + 2;
                                  }
                                  else
                                  {
                                    *(_DWORD *)(a2 + 4) = v290 + 1;
                                    v513 = *v290;
                                    v291 = v510 + 2;
                                  }
                                  if ( *(_DWORD *)(*(_DWORD *)(v509 + 56) + 4 * (unsigned __int8)v513) != 102 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v292 = v527;
                                  v514 -= v514 > 0;
                                  if ( v527 == v528 )
                                  {
                                    char_buffer_add_slow((int)&v527, v513);
                                  }
                                  else
                                  {
                                    ++v527;
                                    *v292 = v513;
                                  }
                                  if ( !v514 )
                                  {
                                    v510 = v291;
                                    goto LABEL_496;
                                  }
                                  v293 = *(unsigned __int8 **)(a2 + 4);
                                  if ( (unsigned int)v293 >= *(_DWORD *)(a2 + 8) )
                                  {
                                    v513 = _uflow((int *)a2);
                                    if ( v513 == -1 )
                                    {
                                      v510 = v291;
                                      v512 = __readgsdword(0xFFFFFFE8);
                                      goto LABEL_496;
                                    }
                                  }
                                  else
                                  {
                                    *(_DWORD *)(a2 + 4) = v293 + 1;
                                    v513 = *v293;
                                  }
                                  if ( *(_DWORD *)(*(_DWORD *)(v509 + 56) + 4 * (unsigned __int8)v513) != 105 )
                                  {
                                    v488 = a2;
                                    v487 = a2;
                                    IO_sputbackc((_DWORD *)a2, (unsigned __int8)v513);
                                    v510 = v291;
                                    goto LABEL_496;
                                  }
                                  v414 = v527;
                                  v514 -= v514 > 0;
                                  if ( v527 == v528 )
                                  {
                                    char_buffer_add_slow((int)&v527, v513);
                                  }
                                  else
                                  {
                                    ++v527;
                                    *v414 = v513;
                                  }
                                  if ( !v514 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v415 = *(_BYTE **)(a2 + 4);
                                  if ( (unsigned int)v415 >= *(_DWORD *)(a2 + 8) )
                                  {
                                    v415 = (_BYTE *)_uflow((int *)a2);
                                    if ( v415 == (_BYTE *)-1 )
                                    {
                                      v36 = (int *)a2;
                                      v516 = 2;
                                      goto LABEL_53;
                                    }
                                  }
                                  else
                                  {
                                    *(_DWORD *)(a2 + 4) = v415 + 1;
                                    LOBYTE(v415) = *v415;
                                  }
                                  if ( *(_DWORD *)(*(_DWORD *)(v509 + 56) + 4 * (unsigned __int8)v415) != 110 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v416 = v527;
                                  v514 -= v514 > 0;
                                  if ( v527 == v528 )
                                  {
                                    char_buffer_add_slow((int)&v527, (char)v415);
                                  }
                                  else
                                  {
                                    ++v527;
                                    *v416 = (unsigned __int8)v415;
                                  }
                                  if ( !v514 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v417 = *(_BYTE **)(a2 + 4);
                                  if ( (unsigned int)v417 >= *(_DWORD *)(a2 + 8) )
                                  {
                                    v417 = (_BYTE *)_uflow((int *)a2);
                                    if ( v417 == (_BYTE *)-1 )
                                    {
                                      v36 = (int *)a2;
                                      v516 = 2;
                                      goto LABEL_53;
                                    }
                                  }
                                  else
                                  {
                                    *(_DWORD *)(a2 + 4) = v417 + 1;
                                    LOBYTE(v417) = *v417;
                                  }
                                  if ( *(_DWORD *)(*(_DWORD *)(v509 + 56) + 4 * (unsigned __int8)v417) != 105 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v514 -= v514 > 0;
                                  v418 = v527;
                                  if ( v527 == v528 )
                                  {
                                    char_buffer_add_slow((int)&v527, (char)v417);
                                  }
                                  else
                                  {
                                    ++v527;
                                    *v418 = (unsigned __int8)v417;
                                  }
                                  if ( !v514 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v419 = *(_BYTE **)(a2 + 4);
                                  if ( (unsigned int)v419 >= *(_DWORD *)(a2 + 8) )
                                  {
                                    v419 = (_BYTE *)_uflow((int *)a2);
                                    if ( v419 == (_BYTE *)-1 )
                                    {
                                      v36 = (int *)a2;
                                      v516 = 2;
                                      goto LABEL_53;
                                    }
                                  }
                                  else
                                  {
                                    *(_DWORD *)(a2 + 4) = v419 + 1;
                                    LOBYTE(v419) = *v419;
                                  }
                                  if ( *(_DWORD *)(*(_DWORD *)(v509 + 56) + 4 * (unsigned __int8)v419) != 116 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v420 = v527;
                                  v514 -= v514 > 0;
                                  if ( v527 == v528 )
                                  {
                                    char_buffer_add_slow((int)&v527, (char)v419);
                                  }
                                  else
                                  {
                                    ++v527;
                                    *v420 = (unsigned __int8)v419;
                                  }
                                  if ( !v514 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v421 = *(unsigned __int8 **)(a2 + 4);
                                  if ( (unsigned int)v421 >= *(_DWORD *)(a2 + 8) )
                                  {
                                    v513 = _uflow((int *)a2);
                                    if ( v513 == -1 )
                                    {
                                      v36 = (int *)a2;
                                      v516 = 2;
                                      goto LABEL_53;
                                    }
                                    v510 += 7;
                                  }
                                  else
                                  {
                                    v510 += 7;
                                    *(_DWORD *)(a2 + 4) = v421 + 1;
                                    v513 = *v421;
                                  }
                                  if ( *(_DWORD *)(*(_DWORD *)(v509 + 56) + 4 * (unsigned __int8)v513) != 121 )
                                  {
                                    v36 = (int *)a2;
                                    v516 = 2;
                                    goto LABEL_53;
                                  }
                                  v269 = v527;
                                  if ( v527 == v528 )
                                  {
LABEL_1227:
                                    char_buffer_add_slow((int)&v527, v513);
                                    goto LABEL_496;
                                  }
                                }
                                v527 = v269 + 1;
                                *v269 = v513;
                                goto LABEL_496;
                              }
LABEL_561:
                              LOBYTE(v493) = 0;
                              goto LABEL_347;
                            }
LABEL_341:
                            --v514;
LABEL_342:
                            if ( ((v513 - 43) & 0xFFFFFFFD) == 0 )
                            {
                              LOBYTE(v493) = v513 == 45;
                              if ( !v514 )
                              {
                                v36 = (int *)a2;
                                v516 = 2;
                                goto LABEL_53;
                              }
                              goto LABEL_344;
                            }
                            goto LABEL_561;
                          }
                          v36 = (int *)a2;
                        }
                        v516 = 1;
                        if ( !v511 )
                          v511 = -1;
                        goto LABEL_53;
                      case 'C':
                        goto LABEL_224;
                      case 'S':
                        goto LABEL_203;
                      case 'X':
                      case 'x':
                        goto LABEL_146;
                      case '[':
LABEL_307:
                        v516 = v507 & 1;
                        if ( (v507 & 1) != 0 )
                        {
                          if ( (v507 & 8) == 0 )
                          {
                            if ( (v507 & 0x2100) != 0 )
                            {
                              if ( v503 )
                              {
                                v362 = (int *)&a4[(_DWORD)v503 - 1];
                                if ( v503 == (int *)1 )
                                  v362 = (int *)a4;
                                v506 = (int *)*v362;
                              }
                              else
                              {
                                v138 = (int *)*v501++;
                                v506 = v138;
                              }
                              v139 = (char **)v506;
                              if ( !v506 )
                              {
                                v36 = (int *)a2;
                                v516 = 2;
                                goto LABEL_53;
                              }
                              v140 = (char *)malloc(400);
                              *v139 = v140;
                              if ( !v140 )
                              {
                                v36 = (int *)a2;
                                v375 = v507 & 0x2000;
                                v376 = v375 == 0 ? 2 : 0;
                                v28 = v375 == 0;
                                v377 = -1;
                                if ( v28 )
                                  v377 = v511;
                                v516 = v376;
                                v511 = v377;
                                goto LABEL_53;
                              }
                              if ( !v497 || (v141 = *v497, v142 = *v497 + 1, *v497 == 32) )
                              {
                                v142 = 1;
                                v485 = 0;
                                v486 = (int)v497;
                                v497 = &v485;
                                v141 = 0;
                              }
                              v143 = (int)v497;
                              v144 = v506;
                              v498 = v140;
                              v500 = 100;
                              *v497 = v142;
                              *(_DWORD *)(v143 + 4 * v141 + 8) = v144;
                            }
                            else
                            {
                              if ( v503 )
                              {
                                v370 = (char **)&a4[(_DWORD)v503 - 1];
                                if ( v503 == (int *)1 )
                                  v370 = (char **)a4;
                                v498 = *v370;
                              }
                              else
                              {
                                v361 = (char *)*v501++;
                                v498 = v361;
                              }
                              if ( !v498 )
                              {
                                v36 = (int *)a2;
                                v516 = 2;
                                goto LABEL_53;
                              }
                            }
                          }
                        }
                        else if ( (v507 & 8) == 0 )
                        {
                          if ( (v507 & 0x2100) != 0 )
                          {
                            if ( v503 )
                            {
                              v368 = (int *)&a4[(_DWORD)v503 - 1];
                              if ( v503 == (int *)1 )
                                v368 = (int *)a4;
                              v506 = (int *)*v368;
                            }
                            else
                            {
                              v210 = (int *)*v501++;
                              v506 = v210;
                            }
                            v211 = (int **)v506;
                            if ( !v506 )
                            {
                              v36 = (int *)a2;
                              v516 = 2;
                              goto LABEL_53;
                            }
                            v212 = (int *)malloc(100);
                            *v211 = v212;
                            if ( !v212 )
                            {
                              v36 = (int *)a2;
                              v400 = v507 & 0x2000;
                              v401 = v400 == 0 ? 2 : 0;
                              v28 = v400 == 0;
                              v402 = -1;
                              if ( v28 )
                                v402 = v511;
                              v516 = v401;
                              v511 = v402;
                              goto LABEL_53;
                            }
                            if ( !v497 || (v213 = *v497, v214 = *v497 + 1, *v497 == 32) )
                            {
                              v214 = 1;
                              v485 = 0;
                              v486 = (int)v497;
                              v497 = &v485;
                              v213 = 0;
                            }
                            v215 = (int)v497;
                            v216 = v506;
                            v496 = v212;
                            v500 = 100;
                            *v497 = v214;
                            *(_DWORD *)(v215 + 4 * v213 + 8) = v216;
                          }
                          else
                          {
                            if ( v503 )
                            {
                              v374 = (int **)&a4[(_DWORD)v503 - 1];
                              if ( v503 == (int *)1 )
                                v374 = (int **)a4;
                              v496 = *v374;
                            }
                            else
                            {
                              v350 = (int *)*v501++;
                              v496 = v350;
                            }
                            if ( !v496 )
                            {
                              v36 = (int *)a2;
                              v516 = 2;
                              goto LABEL_53;
                            }
                          }
                        }
                        v145 = 0;
                        if ( v44[1] == 94 )
                        {
                          v145 = 1;
                          v515 = v44 + 2;
                        }
                        v146 = 0x7FFFFFFF;
                        if ( v514 >= 0 )
                          v146 = v514;
                        v514 = v146;
                        if ( !(unsigned __int8)_libc_scratch_buffer_set_array_size((int *)&v529, 0x100u, 1) )
                        {
                          v36 = (int *)a2;
                          v516 = 0;
                          v511 = -1;
                          goto LABEL_53;
                        }
                        v147 = v529;
                        v148 = (unsigned int)(v529 + 4);
                        *(_DWORD *)v529 = 0;
                        *((_DWORD *)v147 + 63) = 0;
                        memset(
                          (void *)(v148 & 0xFFFFFFFC),
                          0,
                          4 * ((unsigned int)&v147[-(v148 & 0xFFFFFFFC) + 256] >> 2));
                        v149 = *v515;
                        if ( (_BYTE)v149 == 93 || (_BYTE)v149 == 45 )
                        {
                          v235 = v515;
                          v151 = v145;
                          v529[v149] = 1;
                          v149 = *++v235;
                          v150 = v235;
                        }
                        else
                        {
                          v150 = v515;
                          v151 = v145;
                        }
                        while ( 2 )
                        {
                          ++v150;
                          if ( !(_BYTE)v149 )
                          {
                            v36 = (int *)a2;
                            v516 = 2;
                            goto LABEL_53;
                          }
                          if ( (_BYTE)v149 != 93 )
                          {
                            if ( (_BYTE)v149 == 45
                              && (v152 = *v150, *v150 != 93)
                              && v152
                              && (v153 = *(v150 - 2), (unsigned __int8)v153 <= v152) )
                            {
                              if ( (unsigned __int8)v153 >= v152 )
                                goto LABEL_327;
                              do
                              {
                                v154 = (unsigned __int8)v153++;
                                v529[v154] = 1;
                              }
                              while ( *v150 > (unsigned __int8)v153 );
                            }
                            else
                            {
                              v529[v149] = 1;
                            }
                            v152 = *v150;
LABEL_327:
                            v149 = v152;
                            continue;
                          }
                          break;
                        }
                        v222 = v151;
                        v515 = v150;
                        if ( v516 )
                        {
                          if ( v513 == -1 )
                          {
                            v36 = (int *)a2;
                            __writegsdword(0xFFFFFFE8, v512);
                          }
                          else
                          {
                            v223 = *(unsigned __int8 **)(a2 + 4);
                            if ( (unsigned int)v223 < *(_DWORD *)(a2 + 8) )
                            {
                              *(_DWORD *)(a2 + 4) = v223 + 1;
                              v513 = *v223;
                              v508 = v510 + 1;
                              goto LABEL_576;
                            }
                            v513 = _uflow((int *)a2);
                            if ( v513 != -1 )
                            {
                              v508 = v510 + 1;
LABEL_576:
                              v224 = v151;
                              v225 = v513;
                              v36 = (int *)a2;
                              v226 = 0;
                              v521[0] = 0;
                              v521[1] = 0;
                              v503 = v521;
                              v502 = (char *)(v507 & 0x2100);
LABEL_577:
                              if ( v224 == v529[v225] )
                              {
LABEL_582:
                                v513 = v225;
                                --v508;
                                IO_sputbackc((_DWORD *)a2, (unsigned __int8)v225);
LABEL_583:
                                if ( v226 )
                                {
                                  v36 = (int *)a2;
                                  v516 = 4;
                                  __writegsdword(0xFFFFFFE8, 0x54u);
                                  goto LABEL_53;
                                }
                                if ( v508 == v510 )
                                {
                                  v36 = (int *)a2;
                                  v516 = 2;
                                  goto LABEL_53;
                                }
                                v228 = BYTE1(v507);
                                if ( (v507 & 8) == 0 )
                                {
                                  v229 = v498 + 4;
                                  *(_DWORD *)v498 = 0;
                                  if ( (v228 & 0x21) != 0 )
                                  {
                                    v230 = v506;
                                    if ( v500 != (int)&v229[-*v506] >> 2 )
                                    {
                                      v231 = realloc((_BYTE *)*v506, (unsigned int)&v229[-*v506]);
                                      if ( v231 )
                                        *v230 = v231;
                                    }
                                  }
                                  ++v511;
                                  v498 = v229;
                                  v506 = 0;
                                }
                                v516 = 0;
                                v510 = v508;
                                goto LABEL_33;
                              }
                              while ( 1 )
                              {
                                v516 = v507 & 8;
                                if ( (v507 & 8) == 0 )
                                {
                                  LOBYTE(v505) = v224;
                                  LOBYTE(v523) = v225;
                                  v513 = v225;
                                  v232 = mbrtowc(v498, &v523, 1, v503);
                                  v225 = v513;
                                  v224 = v505;
                                  if ( v232 == -2 )
                                  {
                                    if ( (unsigned int)++v226 >= *(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFD8) + 88) )
                                      _assert_fail("cnt < MB_CUR_MAX", "vfscanf.c", 2678, "_IO_vfscanf_internal");
                                    goto LABEL_580;
                                  }
                                  v498 += 4;
                                  if ( v502 )
                                  {
                                    v233 = (_BYTE *)*v506;
                                    v505 = v500;
                                    v513 = 4 * v500;
                                    v226 = 0;
                                    if ( v498 == &v233[4 * v500] )
                                    {
                                      v494 = (char *)v225;
                                      LOBYTE(v498) = v224;
                                      v234 = realloc(v233, 8 * v500);
                                      v224 = (char)v498;
                                      v225 = (int)v494;
                                      if ( v234 )
                                      {
                                        v500 *= 2;
                                        *v506 = v234;
                                        v498 = (char *)(v513 + v234);
                                      }
                                      else
                                      {
                                        v488 = (unsigned __int8)v498;
                                        v487 = (unsigned __int8)v498;
                                        ++v500;
                                        v434 = realloc((_BYTE *)*v506, v513 + 4);
                                        v224 = (char)v498;
                                        v225 = (int)v494;
                                        if ( !v434 )
                                        {
                                          if ( (v507 & 0x2000) != 0 )
                                          {
                                            v511 = -1;
                                          }
                                          else
                                          {
                                            v435 = v506;
                                            ++v511;
                                            v506 = 0;
                                            v516 = 2;
                                            *(_DWORD *)(*v435 + 4 * v505 - 4) = 0;
                                          }
                                          goto LABEL_53;
                                        }
                                        *v506 = v434;
                                        v498 = (char *)(v513 + v434);
                                      }
                                    }
                                  }
                                  else
                                  {
                                    v226 = 0;
                                  }
                                }
                                if ( !--v514 )
                                {
                                  v513 = v225;
                                  goto LABEL_583;
                                }
LABEL_580:
                                v227 = *(unsigned __int8 **)(a2 + 4);
                                if ( (unsigned int)v227 >= *(_DWORD *)(a2 + 8) )
                                {
                                  LOBYTE(v516) = v224;
                                  v225 = _uflow((int *)a2);
                                  v224 = v516;
                                  if ( v225 == -1 )
                                  {
                                    v513 = -1;
                                    v512 = __readgsdword(0xFFFFFFE8);
                                    goto LABEL_583;
                                  }
                                  ++v508;
                                  goto LABEL_577;
                                }
                                ++v508;
                                *(_DWORD *)(a2 + 4) = v227 + 1;
                                v225 = *v227;
                                if ( v224 == v529[v225] )
                                  goto LABEL_582;
                              }
                            }
                            v36 = (int *)a2;
                          }
                          v358 = -1;
                          if ( v511 )
                            v358 = v511;
                          v511 = v358;
                          goto LABEL_53;
                        }
                        if ( v513 == -1 )
                        {
                          v36 = (int *)a2;
                          __writegsdword(0xFFFFFFE8, v512);
                        }
                        else
                        {
                          v240 = *(unsigned __int8 **)(a2 + 4);
                          if ( (unsigned int)v240 < *(_DWORD *)(a2 + 8) )
                          {
                            *(_DWORD *)(a2 + 4) = v240 + 1;
                            v513 = *v240;
                            goto LABEL_627;
                          }
                          v513 = _uflow((int *)a2);
                          if ( v513 != -1 )
                          {
LABEL_627:
                            v241 = (int *)(v510 + 1);
                            if ( v222 != v529[v513] )
                            {
                              LOBYTE(v508) = v222;
                              v242 = v513;
                              v243 = v496;
                              v244 = (int *)a2;
                              v505 = v507 & 0x2100;
                              v513 = v507 & 8;
                              do
                              {
                                if ( !v513 )
                                {
                                  v247 = (int *)((char *)v243 + 1);
                                  *(_BYTE *)v243 = v242;
                                  if ( v505 )
                                  {
                                    v245 = (_BYTE *)*v506;
                                    v503 = (int *)(*v506 + v500);
                                    v243 = (int *)((char *)v243 + 1);
                                    if ( v247 == v503 )
                                    {
                                      v503 = v241;
                                      a2 = (int)v244;
                                      v345 = v500 + 1;
                                      v346 = 2 * v500;
                                      while ( 1 )
                                      {
                                        v347 = realloc(v245, v346);
                                        if ( v347 )
                                          break;
                                        if ( v346 <= v345 )
                                        {
                                          v36 = (int *)a2;
                                          if ( (v507 & 0x2000) != 0 )
                                          {
                                            v516 = 0;
                                            v511 = -1;
                                          }
                                          else
                                          {
                                            v369 = v506;
                                            ++v511;
                                            v506 = 0;
                                            v516 = 2;
                                            *(_BYTE *)(*v369 + v500 - 1) = 0;
                                          }
                                          goto LABEL_53;
                                        }
                                        v346 = v345;
                                        v245 = (_BYTE *)*v506;
                                      }
                                      v348 = v346;
                                      v241 = v503;
                                      v244 = (int *)a2;
                                      *v506 = v347;
                                      v349 = v500;
                                      v500 = v348;
                                      v243 = (int *)(v347 + v349);
                                    }
                                  }
                                  else
                                  {
                                    v243 = (int *)((char *)v243 + 1);
                                  }
                                }
                                if ( !--v514 )
                                {
                                  v496 = v243;
                                  v513 = v242;
                                  goto LABEL_650;
                                }
                                v246 = (unsigned __int8 *)v244[1];
                                if ( (unsigned int)v246 >= v244[2] )
                                {
                                  v503 = v243;
                                  v242 = _uflow(v244);
                                  v243 = v503;
                                  if ( v242 == -1 )
                                  {
                                    v513 = -1;
                                    v496 = v503;
                                    v512 = __readgsdword(0xFFFFFFE8);
LABEL_650:
                                    if ( v241 == (int *)v510 )
                                    {
                                      v36 = (int *)a2;
                                      v516 = 2;
                                      goto LABEL_53;
                                    }
                                    v251 = BYTE1(v507);
                                    v510 = (int)v241;
                                    if ( (v507 & 8) == 0 )
                                    {
                                      v252 = (int *)((char *)v496 + 1);
                                      *(_BYTE *)v496 = 0;
                                      if ( (v251 & 0x21) != 0 )
                                      {
                                        v253 = v506;
                                        if ( (int *)v500 != (int *)((char *)v252 - *v506) )
                                        {
                                          v254 = realloc((_BYTE *)*v506, (unsigned int)v252 - *v506);
                                          if ( v254 )
                                            *v253 = v254;
                                        }
                                      }
                                      ++v511;
                                      v516 = 0;
                                      v496 = v252;
                                      v510 = (int)v241;
                                      v506 = 0;
                                    }
                                    goto LABEL_33;
                                  }
                                }
                                else
                                {
                                  v244[1] = (int)(v246 + 1);
                                  v242 = *v246;
                                }
                                v241 = (int *)((char *)v241 + 1);
                              }
                              while ( (_BYTE)v508 != v529[v242] );
                              v496 = v243;
                              v513 = v242;
                            }
                            v241 = (int *)((char *)v241 - 1);
                            IO_sputbackc((_DWORD *)a2, (unsigned __int8)v513);
                            goto LABEL_650;
                          }
                          v36 = (int *)a2;
                        }
                        v516 = 1;
                        if ( !v511 )
                          v511 = -1;
                        goto LABEL_53;
                      case 'c':
LABEL_282:
                        v516 = v507 & 1;
                        if ( (v507 & 1) != 0 )
                        {
LABEL_224:
                          v88 = 1;
                          if ( v514 != -1 )
                            v88 = v514;
                          v514 = v88;
                          v516 = v507 & 8;
                          if ( (v507 & 8) == 0 )
                          {
                            if ( (v507 & 0x2100) != 0 )
                            {
                              if ( v503 )
                              {
                                v295 = (int *)&a4[(_DWORD)v503 - 1];
                                if ( v503 == (int *)1 )
                                  v295 = (int *)a4;
                                v506 = (int *)*v295;
                              }
                              else
                              {
                                v89 = (int *)*v501++;
                                v506 = v89;
                              }
                              v90 = (char **)v506;
                              if ( !v506 )
                              {
                                v36 = (int *)a2;
                                v516 = 2;
                                goto LABEL_53;
                              }
                              v91 = 1024;
                              if ( v514 <= 1024 )
                                v91 = v514;
                              v500 = v91;
                              v92 = (char *)malloc(4 * v91);
                              *v90 = v92;
                              if ( !v92 )
                              {
                                v36 = (int *)a2;
                                if ( (v507 & 0x2000) != 0 )
                                  v511 = -1;
                                else
                                  v516 = 2;
                                goto LABEL_53;
                              }
                              if ( !v497 || (v93 = *v497, v94 = *v497 + 1, *v497 == 32) )
                              {
                                v486 = (int)v497;
                                v485 = 0;
                                v94 = 1;
                                v497 = &v485;
                                v93 = 0;
                              }
                              v95 = (int)v497;
                              v96 = v506;
                              v498 = v92;
                              *v497 = v94;
                              *(_DWORD *)(v95 + 4 * v93 + 8) = v96;
                            }
                            else
                            {
                              if ( v503 )
                              {
                                v297 = (char **)&a4[(_DWORD)v503 - 1];
                                if ( v503 == (int *)1 )
                                  v297 = (char **)a4;
                                v498 = *v297;
                              }
                              else
                              {
                                v249 = (char *)*v501++;
                                v498 = v249;
                              }
                              if ( !v498 )
                              {
                                v36 = (int *)a2;
                                v516 = 2;
                                goto LABEL_53;
                              }
                            }
                          }
                          if ( v513 == -1 )
                          {
                            v36 = (int *)a2;
                            __writegsdword(0xFFFFFFE8, v512);
                          }
                          else
                          {
                            v97 = *(unsigned __int8 **)(a2 + 4);
                            if ( (unsigned int)v97 < *(_DWORD *)(a2 + 8) )
                            {
                              *(_DWORD *)(a2 + 4) = v97 + 1;
                              v513 = *v97;
                              goto LABEL_240;
                            }
                            v513 = _uflow((int *)a2);
                            if ( v513 != -1 )
                            {
LABEL_240:
                              ++v510;
                              v36 = (int *)a2;
                              v523 = 0;
                              v524 = 0;
                              v505 = v507 & 0x2100;
                              while ( 1 )
                              {
                                LOBYTE(v521[0]) = v513;
                                if ( !v516 )
                                {
                                  if ( v505 )
                                  {
                                    v98 = (_BYTE *)*v506;
                                    v99 = 4 * v500;
                                    if ( v498 == (char *)(*v506 + 4 * v500) )
                                    {
                                      v508 = v514 - 1;
                                      v365 = v514 - 1;
                                      if ( v514 >= v500 )
                                        v365 = v500;
                                      v508 = v500 + v365;
                                      v366 = realloc(v98, 4 * (v500 + v365));
                                      if ( v366 )
                                      {
                                        v500 = v508;
                                        *v506 = v366;
                                        v498 = (char *)(v99 + v366);
                                      }
                                      else
                                      {
                                        v488 = 0;
                                        v487 = 0;
                                        ++v500;
                                        v422 = realloc((_BYTE *)*v506, v99 + 4);
                                        if ( !v422 )
                                        {
                                          v511 = -1;
                                          goto LABEL_53;
                                        }
                                        *v506 = v422;
                                        v498 = (char *)(v99 + v422);
                                      }
                                    }
                                  }
                                }
                                v100 = 0;
                                if ( !v516 )
                                  v100 = v498;
                                v508 = (int)v100;
                                v101 = v36;
                                for ( n = v513; ; LOBYTE(v521[0]) = n )
                                {
                                  v103 = mbrtowc((char *)v508, v521, 1, &v523);
                                  if ( v103 != -2 )
                                    break;
                                  v104 = (unsigned __int8 *)v101[1];
                                  if ( (unsigned int)v104 >= v101[2] )
                                  {
                                    n = _uflow(v101);
                                    if ( n == -1 )
                                    {
                                      v36 = v101;
                                      v516 = 4;
                                      __writegsdword(0xFFFFFFE8, 0x54u);
                                      goto LABEL_53;
                                    }
                                  }
                                  else
                                  {
                                    v101[1] = (int)(v104 + 1);
                                    n = *v104;
                                  }
                                  ++v510;
                                }
                                v513 = n;
                                v36 = v101;
                                if ( v103 != 1 )
                                  break;
                                --v514;
                                v498 += 4;
                                if ( v514 <= 0 )
                                  goto LABEL_1112;
                                v209 = (unsigned __int8 *)v101[1];
                                if ( (unsigned int)v209 >= v101[2] )
                                {
                                  v513 = _uflow(v101);
                                  if ( v513 == -1 )
                                  {
                                    v512 = __readgsdword(0xFFFFFFE8);
LABEL_1112:
                                    if ( v516 )
                                      goto LABEL_23;
                                    if ( (v507 & 0x2100) != 0 )
                                    {
                                      v395 = v506;
                                      v396 = (_BYTE *)*v506;
                                      v397 = (signed int)&v498[-*v506];
                                      if ( v500 != v397 >> 2 )
                                      {
                                        v488 = (int)&v498[-*v506] >> 2;
                                        v487 = v397 >> 2;
                                        v398 = realloc(v396, v397);
                                        if ( v398 )
                                          *v395 = v398;
                                      }
                                    }
                                    ++v511;
                                    v506 = 0;
                                    goto LABEL_33;
                                  }
                                }
                                else
                                {
                                  v101[1] = (int)(v209 + 1);
                                  v513 = *v209;
                                }
                                ++v510;
                              }
LABEL_990:
                              v516 = 4;
                              __writegsdword(0xFFFFFFE8, 0x54u);
                              goto LABEL_53;
                            }
                            v36 = (int *)a2;
                          }
                          v516 = 1;
                          if ( !v511 )
                            v511 = -1;
                          goto LABEL_53;
                        }
                        v123 = 1;
                        if ( v514 != -1 )
                          v123 = v514;
                        v124 = v507 & 8;
                        v514 = v123;
                        if ( (v507 & 8) == 0 )
                        {
                          if ( (v507 & 0x2100) != 0 )
                          {
                            if ( v503 )
                            {
                              v367 = (int *)&a4[(_DWORD)v503 - 1];
                              if ( v503 == (int *)1 )
                                v367 = (int *)a4;
                              v506 = (int *)*v367;
                            }
                            else
                            {
                              v125 = (int *)*v501++;
                              v506 = v125;
                            }
                            v126 = (int **)v506;
                            if ( !v506 )
                            {
                              v36 = (int *)a2;
                              v516 = 2;
                              goto LABEL_53;
                            }
                            v127 = 1024;
                            if ( v514 <= 1024 )
                              v127 = v514;
                            v500 = v127;
                            v128 = (int *)malloc(v127);
                            *v126 = v128;
                            if ( !v128 )
                            {
                              v36 = (int *)a2;
                              v379 = v507 & 0x2000;
                              v380 = v379 == 0 ? 2 : 0;
                              v28 = v379 == 0;
                              v381 = -1;
                              if ( v28 )
                                v381 = v511;
                              v516 = v380;
                              v511 = v381;
                              goto LABEL_53;
                            }
                            if ( !v497 || (v129 = *v497, v130 = *v497 + 1, *v497 == 32) )
                            {
                              v130 = 1;
                              v485 = 0;
                              v486 = (int)v497;
                              v497 = &v485;
                              v129 = 0;
                            }
                            v131 = (int)v497;
                            v496 = v128;
                            *v497 = v130;
                            *(_DWORD *)(v131 + 4 * v129 + 8) = v506;
                          }
                          else
                          {
                            if ( v503 )
                            {
                              v373 = (int **)&a4[(_DWORD)v503 - 1];
                              if ( v503 == (int *)1 )
                                v373 = (int **)a4;
                              v496 = *v373;
                            }
                            else
                            {
                              v351 = (int *)*v501++;
                              v496 = v351;
                            }
                            if ( !v496 )
                            {
                              v36 = (int *)a2;
                              v516 = 2;
                              goto LABEL_53;
                            }
                          }
                        }
                        if ( v513 == -1 )
                        {
                          v36 = (int *)a2;
                          __writegsdword(0xFFFFFFE8, v512);
                          goto LABEL_790;
                        }
                        v132 = *(unsigned __int8 **)(a2 + 4);
                        if ( (unsigned int)v132 >= *(_DWORD *)(a2 + 8) )
                        {
                          v513 = _uflow((int *)a2);
                          if ( v513 == -1 )
                          {
                            v36 = (int *)a2;
LABEL_790:
                            v516 = 1;
                            if ( !v511 )
                              v511 = -1;
                            goto LABEL_53;
                          }
                        }
                        else
                        {
                          *(_DWORD *)(a2 + 4) = v132 + 1;
                          v513 = *v132;
                        }
                        v133 = v510;
                        if ( !v124 )
                        {
                          ++v510;
                          v274 = v513;
                          v275 = v496;
                          v516 = v507 & 0x2100;
                          v276 = v514;
                          if ( (v507 & 0x2100) == 0 )
                            goto LABEL_738;
LABEL_737:
                          v277 = (_BYTE *)*v506;
                          v514 = v500;
                          if ( v275 == (int *)&v277[v500] )
                          {
                            v283 = v276 - 1;
                            if ( v276 > v500 )
                              v283 = v500;
                            v513 = v283 + v500;
                            v284 = realloc(v277, v283 + v500);
                            v286 = v513;
                            if ( v284 )
                            {
                              *v506 = v284;
                              v275 = (int *)(v500 + v284);
                              v500 = v286;
                            }
                            else
                            {
                              ++v500;
                              v488 = v285;
                              v487 = v285;
                              v413 = realloc((_BYTE *)*v506, v500);
                              if ( !v413 )
                              {
                                v36 = (int *)a2;
                                v516 = 0;
                                v511 = -1;
                                goto LABEL_53;
                              }
                              *v506 = v413;
                              v275 = (int *)(v514 + v413);
                            }
                          }
LABEL_738:
                          while ( 1 )
                          {
                            --v276;
                            v278 = (int)v275 + 1;
                            *(_BYTE *)v275 = v274;
                            if ( v276 <= 0 )
                              break;
                            v279 = *(unsigned __int8 **)(a2 + 4);
                            if ( (unsigned int)v279 >= *(_DWORD *)(a2 + 8) )
                            {
                              v514 = v278;
                              v274 = _uflow((int *)a2);
                              v278 = v514;
                              if ( v274 == -1 )
                              {
                                v513 = -1;
                                v206 = (int *)v514;
                                v280 = v516;
                                v512 = __readgsdword(0xFFFFFFE8);
                                goto LABEL_745;
                              }
                            }
                            else
                            {
                              *(_DWORD *)(a2 + 4) = v279 + 1;
                              v274 = *v279;
                            }
                            ++v510;
                            v275 = (int *)v278;
                            if ( v516 )
                              goto LABEL_737;
                          }
                          v513 = v274;
                          v280 = v516;
                          v206 = (int *)((char *)v275 + 1);
LABEL_745:
                          if ( v280 )
                          {
                            v281 = v506;
                            if ( (int *)((char *)v206 - *v506) != (int *)v500 )
                            {
                              v282 = realloc((_BYTE *)*v506, (unsigned int)v206 - *v506);
                              if ( v282 )
                                *v281 = v282;
                            }
                          }
                          goto LABEL_533;
                        }
                        ++v510;
                        v134 = (char *)(v514 + v133);
                        if ( v514 <= 1 )
                          goto LABEL_33;
                        v135 = v510;
                        do
                        {
                          v137 = *(unsigned __int8 **)(a2 + 4);
                          if ( (unsigned int)v137 < *(_DWORD *)(a2 + 8) )
                          {
                            *(_DWORD *)(a2 + 4) = v137 + 1;
                            v136 = *v137;
                          }
                          else
                          {
                            v136 = _uflow((int *)a2);
                            if ( v136 == -1 )
                            {
                              v513 = -1;
                              v510 = v135;
                              v512 = __readgsdword(0xFFFFFFE8);
                              goto LABEL_33;
                            }
                          }
                          ++v135;
                        }
                        while ( v134 != (char *)v135 );
                        v510 = v135;
                        v513 = v136;
LABEL_33:
                        v5 = (unsigned int)v515;
                        continue;
                      case 'd':
LABEL_251:
                        v507 |= 0x40u;
                        goto LABEL_252;
                      case 'i':
LABEL_337:
                        v507 |= 0x40u;
                        v508 = 0;
                        goto LABEL_147;
                      case 'n':
LABEL_277:
                        v516 = v507 & 8;
                        if ( (v507 & 8) != 0 )
                          goto LABEL_23;
                        if ( (v507 & 2) != 0 )
                        {
                          if ( v503 )
                          {
                            v356 = &a4[(_DWORD)v503 - 1];
                            if ( v503 == (int *)1 )
                              v356 = a4;
                            v121 = (int *)*v356;
                          }
                          else
                          {
                            v121 = (int *)*v501++;
                          }
                          v122 = v510;
                          v121[1] = 0;
                          *v121 = v122;
                        }
                        else if ( (v507 & 4) != 0 )
                        {
                          if ( v503 )
                          {
                            v363 = &a4[(_DWORD)v503 - 1];
                            if ( v503 == (int *)1 )
                              v363 = a4;
                            v262 = *v363;
                          }
                          else
                          {
                            v262 = *v501++;
                          }
                          v516 = 0;
                          *(_WORD *)v262 = v510;
                        }
                        else
                        {
                          v516 = v507 & 0x200;
                          if ( (v507 & 0x200) != 0 )
                          {
                            if ( v503 )
                            {
                              v378 = &a4[(_DWORD)v503 - 1];
                              if ( v503 == (int *)1 )
                                v378 = a4;
                              v371 = *v378;
                            }
                            else
                            {
                              v371 = *v501++;
                            }
                            v516 = 0;
                            *(_BYTE *)v371 = v510;
                          }
                          else
                          {
                            if ( v503 )
                            {
                              v399 = &a4[(_DWORD)v503 - 1];
                              if ( v503 == (int *)1 )
                                v399 = a4;
                              v360 = *v399;
                            }
                            else
                            {
                              v360 = *v501++;
                            }
                            *(_DWORD *)v360 = v510;
                          }
                        }
                        goto LABEL_33;
                      case 'o':
                        v508 = 8;
                        goto LABEL_147;
                      case 'p':
LABEL_145:
                        v60 = v507 & 0xFFFFFFF9;
                        BYTE1(v60) = ((unsigned __int16)(v507 & 0xFFF9) >> 8) | 0x10;
                        v507 = v60;
LABEL_146:
                        v508 = 16;
                        goto LABEL_147;
                      case 's':
LABEL_253:
                        v516 = v507 & 1;
                        if ( (v507 & 1) == 0 )
                        {
                          v105 = v507 & 8;
                          if ( (v507 & 8) == 0 )
                          {
                            if ( (v507 & 0x2100) != 0 )
                            {
                              if ( v503 )
                              {
                                v372 = (int *)&a4[(_DWORD)v503 - 1];
                                if ( v503 == (int *)1 )
                                  v372 = (int *)a4;
                                v506 = (int *)*v372;
                              }
                              else
                              {
                                v106 = (int *)*v501++;
                                v506 = v106;
                              }
                              v107 = (int **)v506;
                              if ( !v506 )
                              {
                                v36 = (int *)a2;
                                v516 = 2;
                                goto LABEL_53;
                              }
                              v108 = (int *)malloc(100);
                              *v107 = v108;
                              if ( !v108 )
                              {
                                v36 = (int *)a2;
                                v387 = v507 & 0x2000;
                                v388 = v387 == 0 ? 2 : 0;
                                v28 = v387 == 0;
                                v389 = -1;
                                if ( v28 )
                                  v389 = v511;
                                v516 = v388;
                                v511 = v389;
                                goto LABEL_53;
                              }
                              if ( !v497 || (v109 = *v497, v110 = *v497 + 1, *v497 == 32) )
                              {
                                v110 = 1;
                                v485 = 0;
                                v486 = (int)v497;
                                v497 = &v485;
                                v109 = 0;
                              }
                              v111 = (int)v497;
                              v496 = v108;
                              v500 = 100;
                              *v497 = v110;
                              *(_DWORD *)(v111 + 4 * v109 + 8) = v506;
                            }
                            else
                            {
                              if ( v503 )
                              {
                                v364 = (int **)&a4[(_DWORD)v503 - 1];
                                if ( v503 == (int *)1 )
                                  v364 = (int **)a4;
                                v496 = *v364;
                              }
                              else
                              {
                                v352 = (int *)*v501++;
                                v496 = v352;
                              }
                              if ( !v496 )
                              {
                                v36 = (int *)a2;
                                v516 = 2;
                                goto LABEL_53;
                              }
                            }
                          }
                          if ( v513 == -1 )
                          {
                            v36 = (int *)a2;
                            __writegsdword(0xFFFFFFE8, v512);
                          }
                          else
                          {
                            v112 = *(unsigned __int8 **)(a2 + 4);
                            if ( (unsigned int)v112 < *(_DWORD *)(a2 + 8) )
                            {
                              *(_DWORD *)(a2 + 4) = v112 + 1;
                              v513 = *v112;
                              goto LABEL_266;
                            }
                            v513 = _uflow((int *)a2);
                            if ( v513 != -1 )
                            {
LABEL_266:
                              ++v510;
                              if ( (*(_BYTE *)(*(_DWORD *)(v509 + 52) + 2 * v513 + 1) & 0x20) != 0 )
                                goto LABEL_938;
                              v113 = (int *)v513;
                              v114 = v514;
                              v514 = v105;
                              v36 = (int *)a2;
                              v513 = v509;
                              v508 = v507 & 0x2100;
                              v115 = v496;
                              do
                              {
                                if ( !v514 )
                                {
                                  v119 = v508;
                                  v120 = (int *)((char *)v115 + 1);
                                  *(_BYTE *)v115 = (_BYTE)v113;
                                  if ( v119 )
                                  {
                                    v116 = (int *)*v506;
                                    v505 = v500;
                                    v503 = v116;
                                    v117 = (int *)((char *)v116 + v500);
                                    v115 = v120;
                                    if ( v120 == v117 )
                                    {
                                      v496 = v113;
                                      v502 = (char *)(2 * v500);
                                      v353 = realloc(v503, 2 * v500);
                                      v113 = v496;
                                      if ( v353 )
                                      {
                                        *v506 = v353;
                                        v115 = (int *)(v353 + v500);
                                        v500 = (signed int)v502;
                                      }
                                      else
                                      {
                                        ++v500;
                                        v503 = v496;
                                        v488 = (int)v496;
                                        v487 = (int)v496;
                                        v404 = realloc((_BYTE *)*v506, v500);
                                        v113 = v503;
                                        if ( !v404 )
                                        {
                                          if ( (v507 & 0x2000) != 0 )
                                          {
                                            v516 = 0;
                                            v511 = -1;
                                          }
                                          else
                                          {
                                            v412 = v506;
                                            ++v511;
                                            v506 = 0;
                                            v516 = 2;
                                            *(_BYTE *)(*v412 + v505 - 1) = 0;
                                          }
                                          goto LABEL_53;
                                        }
                                        v405 = v505;
                                        *v506 = v404;
                                        v115 = (int *)(v404 + v405);
                                      }
                                    }
                                  }
                                  else
                                  {
                                    v115 = (int *)((char *)v115 + 1);
                                  }
                                }
                                if ( v114 > 0 && !--v114 )
                                {
                                  v496 = v115;
                                  v513 = (unsigned int)v113;
                                  v105 = v514;
                                  goto LABEL_528;
                                }
                                v118 = *(unsigned __int8 **)(a2 + 4);
                                if ( (unsigned int)v118 >= *(_DWORD *)(a2 + 8) )
                                {
                                  v113 = (int *)_uflow((int *)a2);
                                  if ( v113 == (int *)-1 )
                                  {
                                    v513 = -1;
                                    v105 = v514;
                                    v496 = v115;
                                    v512 = __readgsdword(0xFFFFFFE8);
                                    goto LABEL_528;
                                  }
                                }
                                else
                                {
                                  *(_DWORD *)(a2 + 4) = v118 + 1;
                                  v113 = (int *)*v118;
                                }
                                ++v510;
                              }
                              while ( (*(_BYTE *)(*(_DWORD *)(v513 + 52) + 2 * (_DWORD)v113 + 1) & 0x20) == 0 );
                              v105 = v514;
                              v496 = v115;
                              v513 = (unsigned int)v113;
LABEL_938:
                              --v510;
                              IO_sputbackc((_DWORD *)a2, (unsigned __int8)v513);
LABEL_528:
                              if ( v105 )
                                goto LABEL_33;
                              v28 = (v507 & 0x2100) == 0;
                              v206 = (int *)((char *)v496 + 1);
                              *(_BYTE *)v496 = 0;
                              if ( !v28 )
                              {
                                v207 = v506;
                                if ( (int *)v500 != (int *)((char *)v206 - *v506) )
                                {
                                  v208 = realloc((_BYTE *)*v506, (unsigned int)v206 - *v506);
                                  if ( v208 )
                                    *v207 = v208;
                                }
                              }
LABEL_533:
                              ++v511;
                              v516 = 0;
                              v496 = v206;
                              v506 = 0;
                              goto LABEL_33;
                            }
                            v36 = (int *)a2;
                          }
                          v516 = 1;
                          if ( !v511 )
                            v511 = -1;
                          goto LABEL_53;
                        }
LABEL_203:
                        v516 = v507 & 8;
                        if ( (v507 & 8) == 0 )
                        {
                          if ( (v507 & 0x2100) != 0 )
                          {
                            if ( v503 )
                            {
                              v296 = (int *)&a4[(_DWORD)v503 - 1];
                              if ( v503 == (int *)1 )
                                v296 = (int *)a4;
                              v506 = (int *)*v296;
                            }
                            else
                            {
                              v76 = (int *)*v501++;
                              v506 = v76;
                            }
                            v77 = (char **)v506;
                            if ( !v506 )
                            {
                              v36 = (int *)a2;
                              v516 = 2;
                              goto LABEL_53;
                            }
                            v78 = (char *)malloc(400);
                            *v77 = v78;
                            if ( !v78 )
                            {
                              v36 = (int *)a2;
                              if ( (v507 & 0x2000) != 0 )
                                v511 = -1;
                              else
                                v516 = 2;
                              goto LABEL_53;
                            }
                            if ( !v497 || (v79 = *v497, v80 = *v497 + 1, *v497 == 32) )
                            {
                              v80 = 1;
                              v485 = 0;
                              v486 = (int)v497;
                              v497 = &v485;
                              v79 = 0;
                            }
                            v5 = (unsigned int)v497;
                            v81 = v506;
                            v498 = v78;
                            v500 = 100;
                            *v497 = v80;
                            *(_DWORD *)(v5 + 4 * v79 + 8) = v81;
                          }
                          else
                          {
                            if ( v503 )
                            {
                              v5 = (unsigned int)a4;
                              v294 = (char **)&a4[(_DWORD)v503 - 1];
                              if ( v503 == (int *)1 )
                                v294 = (char **)a4;
                              v498 = *v294;
                            }
                            else
                            {
                              v250 = (char *)*v501++;
                              v498 = v250;
                            }
                            if ( !v498 )
                            {
                              v36 = (int *)a2;
                              v516 = 2;
                              goto LABEL_53;
                            }
                          }
                        }
                        if ( v513 == -1 )
                        {
                          v36 = (int *)a2;
                          __writegsdword(0xFFFFFFE8, v512);
                        }
                        else
                        {
                          v82 = *(unsigned __int8 **)(a2 + 4);
                          if ( (unsigned int)v82 < *(_DWORD *)(a2 + 8) )
                          {
                            v5 = a2;
                            *(_DWORD *)(a2 + 4) = v82 + 1;
                            v513 = *v82;
                            goto LABEL_215;
                          }
                          v513 = _uflow((int *)a2);
                          if ( v513 != -1 )
                          {
LABEL_215:
                            v523 = 0;
                            v524 = 0;
                            ++v510;
                            if ( (*(_BYTE *)(*(_DWORD *)(v509 + 52) + 2 * v513 + 1) & 0x20) == 0 )
                            {
                              v36 = (int *)a2;
                              v508 = (int)v521;
                              v505 = v507 & 0x2100;
                              do
                              {
                                v83 = v498;
                                v84 = v513;
                                if ( v516 )
                                  v83 = 0;
                                LOBYTE(v521[0]) = v513;
                                v513 = (unsigned int)v83;
                                v5 = (unsigned int)v36;
                                for ( ii = v84; ; LOBYTE(v521[0]) = ii )
                                {
                                  v86 = mbrtowc((char *)v513, (_BYTE *)v508, 1, &v523);
                                  if ( v86 != -2 )
                                    break;
                                  v87 = *(unsigned __int8 **)(v5 + 4);
                                  if ( (unsigned int)v87 >= *(_DWORD *)(v5 + 8) )
                                  {
                                    ii = _uflow((int *)v5);
                                    if ( ii == -1 )
                                    {
                                      v36 = (int *)v5;
                                      v516 = 4;
                                      __writegsdword(0xFFFFFFE8, 0x54u);
                                      goto LABEL_53;
                                    }
                                  }
                                  else
                                  {
                                    *(_DWORD *)(v5 + 4) = v87 + 1;
                                    ii = *v87;
                                  }
                                  ++v510;
                                }
                                v513 = ii;
                                v36 = (int *)v5;
                                if ( v86 != 1 )
                                  goto LABEL_990;
                                v498 += 4;
                                if ( !v516 )
                                {
                                  v5 = v505;
                                  if ( v505 )
                                  {
                                    v199 = (_BYTE *)*v506;
                                    v503 = (int *)v500;
                                    v5 = 4 * v500;
                                    if ( v498 == &v199[4 * v500] )
                                    {
                                      v488 = (int)&v199[4 * v500];
                                      v487 = v488;
                                      v436 = realloc(v199, 8 * v500);
                                      if ( v436 )
                                      {
                                        *v506 = v436;
                                        v437 = (char *)(v5 + v436);
                                        v5 = v500;
                                        v498 = v437;
                                        v500 *= 2;
                                      }
                                      else
                                      {
                                        v488 = 0;
                                        v487 = 0;
                                        ++v500;
                                        v479 = realloc((_BYTE *)*v506, v5 + 4);
                                        if ( !v479 )
                                        {
                                          if ( (v507 & 0x2000) != 0 )
                                          {
                                            v511 = -1;
                                          }
                                          else
                                          {
                                            v483 = v506;
                                            ++v511;
                                            v506 = 0;
                                            v516 = 2;
                                            *(_DWORD *)(*v483 + 4 * (_DWORD)v503 - 4) = 0;
                                          }
                                          goto LABEL_53;
                                        }
                                        *v506 = v479;
                                        v498 = (char *)(v5 + v479);
                                      }
                                    }
                                  }
                                }
                                if ( v514 > 0 && !--v514 )
                                  goto LABEL_520;
                                v200 = (unsigned __int8 *)v36[1];
                                if ( (unsigned int)v200 >= v36[2] )
                                {
                                  v513 = _uflow(v36);
                                  if ( v513 == -1 )
                                  {
                                    v512 = __readgsdword(0xFFFFFFE8);
LABEL_520:
                                    if ( !v516 )
                                    {
                                      v28 = (v507 & 0x2100) == 0;
                                      v201 = v498 + 4;
                                      *(_DWORD *)v498 = 0;
                                      if ( !v28 )
                                      {
                                        v202 = v506;
                                        v203 = (_BYTE *)*v506;
                                        v204 = (signed int)&v201[-*v506];
                                        if ( v500 != v204 >> 2 )
                                        {
                                          v488 = v5;
                                          v487 = v5;
                                          v205 = realloc(v203, v204);
                                          if ( v205 )
                                            *v202 = v205;
                                        }
                                      }
                                      ++v511;
                                      v498 = v201;
                                      v506 = 0;
                                    }
                                    goto LABEL_23;
                                  }
                                }
                                else
                                {
                                  v36[1] = (int)(v200 + 1);
                                  v513 = *v200;
                                }
                                v5 = v513;
                                ++v510;
                              }
                              while ( (*(_BYTE *)(*(_DWORD *)(v509 + 52) + 2 * v513 + 1) & 0x20) == 0 );
                            }
                            --v510;
                            IO_sputbackc((_DWORD *)a2, (unsigned __int8)v513);
                            goto LABEL_520;
                          }
                          v36 = (int *)a2;
                        }
                        v516 = 1;
                        if ( !v511 )
                          v511 = -1;
                        goto LABEL_53;
                      case 'u':
LABEL_252:
                        v508 = 10;
LABEL_147:
                        if ( v513 == -1 )
                        {
                          v36 = (int *)a2;
                          v59 = -24;
LABEL_139:
                          __writegsdword(v59, v512);
                        }
                        else
                        {
LABEL_148:
                          v61 = *(unsigned __int8 **)(a2 + 4);
                          if ( (unsigned int)v61 < *(_DWORD *)(a2 + 8) )
                          {
                            *(_DWORD *)(a2 + 4) = v61 + 1;
                            v513 = *v61;
                            goto LABEL_150;
                          }
                          v513 = _uflow((int *)a2);
                          if ( v513 != -1 )
                          {
LABEL_150:
                            v62 = (char *)(v510 + 1);
                            if ( ((v513 - 43) & 0xFFFFFFFD) == 0 )
                            {
                              v63 = v527;
                              if ( v528 == v527 )
                              {
                                char_buffer_add_slow((int)&v527, v513);
                              }
                              else
                              {
                                ++v527;
                                *v63 = v513;
                              }
                              v514 -= v514 > 0;
                              v64 = *(unsigned __int8 **)(a2 + 4);
                              if ( (unsigned int)v64 >= *(_DWORD *)(a2 + 8) )
                              {
                                v513 = _uflow((int *)a2);
                                if ( v513 == -1 )
                                {
                                  v512 = __readgsdword(0xFFFFFFE8);
                                  goto LABEL_449;
                                }
                              }
                              else
                              {
                                *(_DWORD *)(a2 + 4) = v64 + 1;
                                v513 = *v64;
                              }
                              v62 = (char *)(v510 + 2);
                            }
                            if ( v514 && v513 == 48 )
                            {
                              v65 = v527;
                              v514 -= v514 > 0;
                              if ( v528 == v527 )
                              {
                                char_buffer_add_slow((int)&v527, 48);
                              }
                              else
                              {
                                ++v527;
                                *v65 = 48;
                              }
                              v66 = *(unsigned __int8 **)(a2 + 4);
                              if ( (unsigned int)v66 >= *(_DWORD *)(a2 + 8) )
                              {
                                v513 = _uflow((int *)a2);
                                if ( v513 == -1 )
                                {
                                  v512 = __readgsdword(0xFFFFFFE8);
                                  goto LABEL_163;
                                }
                              }
                              else
                              {
                                *(_DWORD *)(a2 + 4) = v66 + 1;
                                v513 = *v66;
                              }
                              ++v62;
LABEL_163:
                              if ( !v514 || *(_DWORD *)(*(_DWORD *)(v509 + 56) + 4 * (unsigned __int8)v513) != 120 )
                              {
                                if ( !v508 )
                                {
                                  v508 = 8;
                                  goto LABEL_169;
                                }
                                goto LABEL_166;
                              }
                              if ( (v508 & 0xA) != 0 )
                                goto LABEL_166;
                              v514 -= v514 > 0;
                              if ( v513 == -1 )
                              {
                                __writegsdword(0xFFFFFFE8, v512);
                              }
                              else
                              {
                                v264 = *(unsigned __int8 **)(a2 + 4);
                                if ( (unsigned int)v264 < *(_DWORD *)(a2 + 8) )
                                {
                                  *(_DWORD *)(a2 + 4) = v264 + 1;
                                  v513 = *v264;
LABEL_696:
                                  ++v62;
                                  v508 = 16;
                                  goto LABEL_169;
                                }
                                v513 = _uflow((int *)a2);
                                if ( v513 != -1 )
                                  goto LABEL_696;
                                v512 = __readgsdword(0xFFFFFFE8);
                              }
                              v508 = 16;
                              v513 = -1;
                              v71 = v527;
                              goto LABEL_183;
                            }
LABEL_449:
                            if ( !v508 )
                            {
LABEL_167:
                              if ( (v507 & 0x400) != 0 )
                              {
                                v491 = (int *)wctrans((int)"to_inpunct");
                                v516 = *(_DWORD *)(v499 + 112);
                                v490 = v516 - 1;
                                if ( v491 )
                                {
                                  v510 = (int)v62;
                                  v490 = v516;
                                  v423 = 48;
                                  v494 = v520;
                                  v505 = (unsigned int)v521;
                                  do
                                  {
                                    v424 = *(_BYTE **)(v499 + 4 * v423 - 76);
                                    *(_DWORD *)(v505 + 4 * v423 - 192) = v424;
                                    v425 = towctrans(v423, v491);
                                    v519[0] = 0;
                                    v519[1] = 0;
                                    v508 = wcrtomb(v494, v425, v519);
                                    if ( v508 == -1 )
                                    {
                                      v62 = (char *)v510;
                                      v491 = 0;
                                      goto LABEL_800;
                                    }
                                    v426 = 0;
                                    v427 = (int)v424;
                                    if ( v516 > 0 )
                                    {
                                      do
                                      {
                                        ++v426;
                                        v427 = j_rawmemchr(v427, 0) + 1;
                                      }
                                      while ( v516 != v426 );
                                    }
                                    v428 = (_BYTE *)v508;
                                    v429 = v427 - (_DWORD)v424;
                                    v430 = alloca(v508 + v429 + 16);
                                    v508 = (int)&v489;
                                    v431 = mempcpy(&v489, v424, v429);
                                    v432 = mempcpy(v431, v494, (unsigned int)v428);
                                    v433 = (char *)v508;
                                    *(_BYTE *)v432 = 0;
                                    (&v494)[v423++] = v433;
                                  }
                                  while ( v423 != 58 );
                                  v62 = (char *)v510;
                                }
LABEL_800:
                                v36 = (int *)a2;
                                v508 = 0;
                                v516 = (int)v62;
                                while ( 1 )
                                {
                                  if ( v513 == -1 || !v514 )
                                  {
LABEL_916:
                                    v62 = (char *)v516;
                                    v71 = v527;
                                    goto LABEL_917;
                                  }
                                  v301 = 0x7FFFFFFF;
                                  v510 = 0;
                                  if ( v514 > 0 )
                                    v301 = v514;
                                  v494 = (char *)v301;
                                  v505 = (unsigned int)v521;
                                  do
                                  {
                                    if ( v491 )
                                      v302 = (unsigned __int8 *)*(&v523 + v510);
                                    else
                                      v302 = *(unsigned __int8 **)(v499 + 4 * v510 + 116);
                                    *(_DWORD *)(v505 + 4 * v510) = v302;
                                    if ( v508 )
                                    {
                                      v303 = (int)v302;
                                      a2 = (int)v36;
                                      v304 = v505;
                                      v305 = 0;
                                      v306 = v510;
                                      do
                                      {
                                        ++v305;
                                        v303 = j_rawmemchr(v303, 0) + 1;
                                        v28 = v508 == (_DWORD)v305;
                                        *(_DWORD *)(v304 + 4 * v306) = v303;
                                      }
                                      while ( !v28 );
                                      v36 = (int *)a2;
                                      v302 = (unsigned __int8 *)v303;
                                    }
                                    v307 = (char *)*v302;
                                    if ( v307 != (char *)v513 )
                                    {
                                      if ( (_BYTE)v307 )
                                        goto LABEL_830;
LABEL_898:
                                      v324 = (int)v494;
                                      goto LABEL_873;
                                    }
                                    v308 = v302 + 1;
                                    if ( !v302[1] )
                                      goto LABEL_898;
                                    v502 = (char *)v302;
                                    v309 = v494;
                                    while ( 1 )
                                    {
                                      v312 = (unsigned __int8 *)v36[1];
                                      if ( (unsigned int)v312 < v36[2] )
                                      {
                                        v36[1] = (int)(v312 + 1);
                                        v310 = *v312;
                                      }
                                      else
                                      {
                                        v310 = _uflow(v36);
                                        if ( v310 == -1 )
                                        {
                                          v513 = -1;
                                          v313 = (int)v309;
                                          v302 = (unsigned __int8 *)v502;
                                          v512 = __readgsdword(0xFFFFFFE8);
                                          v314 = *v308;
                                          goto LABEL_822;
                                        }
                                      }
                                      v311 = *v308;
                                      ++v516;
                                      --v309;
                                      if ( v311 != v310 )
                                        break;
                                      if ( !*++v308 )
                                      {
                                        v324 = (int)v309;
LABEL_873:
                                        v492 = v508;
                                        if ( v514 <= 0 )
                                          v324 = v514;
LABEL_875:
                                        v505 = v510 + 48;
                                        v340 = v527;
                                        v513 = v510 + 48;
                                        LOBYTE(v510) = v510 + 48;
                                        v490 = v492;
                                        v508 = v492;
                                        goto LABEL_876;
                                      }
                                      if ( !v309 )
                                      {
                                        v302 = (unsigned __int8 *)v502;
                                        v513 = v310;
                                        if ( v308 > (unsigned __int8 *)v502 )
                                        {
LABEL_870:
                                          --v516;
                                          IO_sputbackc(v36, (unsigned __int8)v513);
                                          goto LABEL_825;
                                        }
                                        goto LABEL_830;
                                      }
                                    }
                                    v513 = v310;
                                    v313 = (int)v309;
                                    v314 = v311;
                                    v302 = (unsigned __int8 *)v502;
LABEL_822:
                                    if ( !v314 )
                                    {
                                      v324 = v313;
                                      goto LABEL_873;
                                    }
                                    if ( v302 < v308 )
                                    {
                                      if ( v513 != -1 )
                                        goto LABEL_870;
LABEL_825:
                                      v513 = (unsigned int)(v308 - 1);
                                      if ( v308 - 1 > v302 )
                                      {
                                        v502 = (char *)v308;
                                        v315 = v308 - 1;
                                        do
                                        {
                                          v316 = *v315--;
                                          IO_sputbackc(v36, v316);
                                        }
                                        while ( v315 != v302 );
                                        v317 = v302 - (unsigned __int8 *)v502 + 1;
                                        v513 += v317;
                                        v516 += v317;
                                      }
                                      v513 = *(unsigned __int8 *)v513;
                                    }
LABEL_830:
                                    v318 = j_rawmemchr(v302, 0);
                                    v319 = v510;
                                    *(_DWORD *)(v505 + 4 * v510) = v318 + 1;
                                    v510 = v319 + 1;
                                  }
                                  while ( v319 != 9 );
                                  v320 = (char *)v513;
                                  v321 = v36;
                                  v492 = v508 + 1;
                                  if ( v490 < v508 + 1 )
                                    goto LABEL_854;
                                  do
                                  {
                                    v36 = v321;
                                    v510 = 0;
                                    v322 = (int)v320;
                                    do
                                    {
                                      v323 = **(unsigned __int8 **)(v505 + 4 * v510);
                                      v513 = *(_DWORD *)(v505 + 4 * v510);
                                      if ( v323 != v322 )
                                      {
                                        if ( (_BYTE)v323 )
                                          goto LABEL_851;
                                        v324 = (int)v494;
LABEL_884:
                                        if ( v514 <= 0 )
                                          v324 = v514;
                                        goto LABEL_875;
                                      }
                                      v324 = (int)v494;
                                      v325 = (char *)(v513 + 1);
                                      if ( !*(_BYTE *)(v513 + 1) )
                                        goto LABEL_884;
                                      do
                                      {
                                        v328 = (unsigned __int8 *)v36[1];
                                        if ( (unsigned int)v328 < v36[2] )
                                        {
                                          v36[1] = (int)(v328 + 1);
                                          v322 = *v328;
                                        }
                                        else
                                        {
                                          v322 = _uflow(v36);
                                          if ( v322 == -1 )
                                          {
                                            v512 = __readgsdword(0xFFFFFFE8);
                                            v327 = *v325;
LABEL_843:
                                            if ( v327 )
                                            {
                                              if ( v513 < (unsigned int)v325 )
                                              {
                                                if ( v322 != -1 )
                                                  goto LABEL_868;
LABEL_846:
                                                v502 = v325 - 1;
                                                if ( v513 < (unsigned int)(v325 - 1) )
                                                {
                                                  v493 = v325;
                                                  v329 = v513;
                                                  v330 = v325 - 1;
                                                  do
                                                  {
                                                    v331 = (unsigned __int8)*v330--;
                                                    IO_sputbackc(v36, v331);
                                                  }
                                                  while ( (char *)v329 != v330 );
                                                  v332 = (char *)(v513 - (_DWORD)v493 + 1);
                                                  v502 = &v502[(_DWORD)v332];
                                                  v516 += (int)v332;
                                                }
                                                v322 = (unsigned __int8)*v502;
                                              }
                                              goto LABEL_851;
                                            }
                                            goto LABEL_884;
                                          }
                                        }
                                        v326 = (unsigned __int8)*v325;
                                        ++v516;
                                        --v324;
                                        v327 = v326;
                                        if ( v326 != v322 )
                                          goto LABEL_843;
                                        if ( !*++v325 )
                                          goto LABEL_884;
                                      }
                                      while ( v324 );
                                      if ( v513 < (unsigned int)v325 )
                                      {
LABEL_868:
                                        --v516;
                                        IO_sputbackc(v36, (unsigned __int8)v322);
                                        goto LABEL_846;
                                      }
LABEL_851:
                                      v502 = (char *)v322;
                                      v333 = j_rawmemchr(v513, 0);
                                      v334 = v510;
                                      v322 = (int)v502;
                                      *(_DWORD *)(v505 + 4 * v510) = v333 + 1;
                                      v510 = v334 + 1;
                                    }
                                    while ( v334 != 9 );
                                    ++v492;
                                    v320 = (char *)v322;
                                    v321 = v36;
                                  }
                                  while ( v490 >= v492 );
                                  v513 = (unsigned int)v320;
LABEL_854:
                                  if ( (v507 & 0x80u) == 0 )
                                    goto LABEL_916;
                                  v324 = 0x7FFFFFFF;
                                  if ( v514 > 0 )
                                    v324 = v514;
                                  v335 = (char *)*(unsigned __int8 *)v504;
                                  if ( v335 == (char *)v513 )
                                  {
                                    v336 = v504;
                                    while ( 1 )
                                    {
                                      LOBYTE(v510) = (_BYTE)v335;
                                      v505 = (char)v335;
                                      v339 = v527;
                                      if ( v528 == v527 )
                                      {
                                        v513 = (unsigned int)v335;
                                        char_buffer_add_slow((int)&v527, v505);
                                        v335 = (char *)v513;
                                      }
                                      else
                                      {
                                        ++v527;
                                        *v339 = (unsigned __int8)v335;
                                      }
                                      if ( !*++v336 )
                                        break;
                                      if ( !v324 )
                                      {
                                        v71 = v527;
                                        v62 = (char *)v516;
                                        v344 = (unsigned int)v336;
                                        if ( !v527 )
                                        {
                                          v36 = (int *)a2;
                                          goto LABEL_441;
                                        }
                                        v513 = (unsigned int)v335;
LABEL_1179:
                                        if ( (unsigned int)v504 < v344 )
                                        {
                                          v406 = &v71[-(v344 - (_DWORD)v504)];
                                          v527 = v406;
                                          if ( v513 != -1 )
                                          {
                                            v488 = (int)v406;
                                            v487 = (int)v406;
                                            --v62;
                                            IO_sputbackc((_DWORD *)a2, (unsigned __int8)v513);
                                          }
                                          v407 = (char *)(v344 - 1);
                                          if ( (unsigned int)v504 < v344 - 1 )
                                          {
                                            v408 = (const char *)(v344 - 1);
                                            do
                                            {
                                              v409 = *(unsigned __int8 *)v408;
                                              v516 = (int)v407;
                                              --v408;
                                              IO_sputbackc((_DWORD *)a2, v409);
                                              v407 = (char *)v516;
                                            }
                                            while ( v504 != v408 );
                                            v410 = &v504[-v344 + 1];
                                            v407 = (char *)&v410[v516];
                                            v62 = &v62[(_DWORD)v410];
                                          }
                                          v411 = (unsigned __int8)*v407;
                                          v71 = v527;
                                          v513 = v411;
                                        }
LABEL_917:
                                        v508 = 10;
LABEL_183:
                                        if ( !v71 )
                                          goto LABEL_1332;
                                        goto LABEL_184;
                                      }
                                      v337 = (unsigned __int8 *)v36[1];
                                      if ( (unsigned int)v337 >= v36[2] )
                                      {
                                        v342 = _uflow(v36);
                                        if ( v342 == -1 )
                                        {
                                          v513 = -1;
                                          v512 = __readgsdword(0xFFFFFFE8);
                                          goto LABEL_890;
                                        }
                                        v335 = (char *)v342;
                                      }
                                      else
                                      {
                                        v36[1] = (int)(v337 + 1);
                                        v335 = (char *)*v337;
                                      }
                                      v338 = (char *)*(unsigned __int8 *)v336;
                                      ++v516;
                                      --v324;
                                      if ( v338 != v335 )
                                      {
                                        v513 = (unsigned int)v335;
                                        goto LABEL_890;
                                      }
                                    }
                                    v343 = v527;
                                    if ( !v527 )
                                      goto LABEL_441;
                                    v513 = (unsigned int)v335;
                                  }
                                  else
                                  {
                                    v336 = v504;
LABEL_890:
                                    v343 = v527;
                                    v71 = v527;
                                    if ( !v527 )
                                      goto LABEL_441;
                                    if ( *v336 )
                                    {
                                      v62 = (char *)v516;
                                      v344 = (unsigned int)v336;
                                      goto LABEL_1179;
                                    }
                                    LOBYTE(v510) = v513;
                                    v505 = (char)v513;
                                  }
                                  if ( v514 <= 0 )
                                    v324 = v514;
                                  v340 = v343 - 1;
                                  v527 = v340;
LABEL_876:
                                  if ( v528 == v340 )
                                  {
                                    char_buffer_add_slow((int)&v527, v505);
                                  }
                                  else
                                  {
                                    v527 = v340 + 1;
                                    *v340 = v510;
                                  }
                                  v514 = v324 - (v324 > 0);
                                  if ( v513 == -1 )
                                  {
                                    __writegsdword(0xFFFFFFE8, v512);
                                  }
                                  else
                                  {
                                    v341 = (unsigned __int8 *)v36[1];
                                    if ( (unsigned int)v341 < v36[2] )
                                    {
                                      v36[1] = (int)(v341 + 1);
                                      v513 = *v341;
                                      goto LABEL_881;
                                    }
                                    v513 = _uflow(v36);
                                    if ( v513 == -1 )
                                      v512 = __readgsdword(0xFFFFFFE8);
                                    else
LABEL_881:
                                      ++v516;
                                  }
                                }
                              }
                              v508 = 10;
LABEL_169:
                              v67 = v513;
                              v68 = (int *)a2;
                              v510 = (int)v62;
                              while ( 1 )
                              {
LABEL_170:
                                if ( v67 == -1 )
                                {
LABEL_182:
                                  v62 = (char *)v510;
                                  v71 = v527;
                                  v513 = v67;
                                  goto LABEL_183;
                                }
                                while ( 1 )
                                {
                                  if ( !v514 )
                                    goto LABEL_182;
                                  if ( v508 == 16 )
                                  {
                                    if ( (*(_BYTE *)(*(_DWORD *)(v509 + 52) + 2 * v67 + 1) & 0x10) == 0 )
                                      goto LABEL_182;
                                    v69 = v527;
                                    LOBYTE(v516) = v67;
                                    v513 = (char)v67;
                                  }
                                  else if ( (unsigned int)(v67 - 48) > 9 )
                                  {
                                    if ( v508 != 10 || (v507 & 0x80u) == 0 )
                                      goto LABEL_182;
                                    v177 = 0x7FFFFFFF;
                                    if ( v514 > 0 )
                                      v177 = v514;
                                    v178 = v504;
                                    v179 = v177;
                                    if ( v67 == *(unsigned __int8 *)v504 )
                                    {
                                      a2 = (int)v68;
                                      v180 = v177;
                                      while ( 1 )
                                      {
                                        LOBYTE(v516) = v67;
                                        v513 = (char)v67;
                                        v183 = v527;
                                        if ( v527 == v528 )
                                        {
                                          v505 = v180;
                                          char_buffer_add_slow((int)&v527, v67);
                                          v180 = v505;
                                        }
                                        else
                                        {
                                          ++v527;
                                          *v183 = v67;
                                        }
                                        if ( !*++v178 )
                                          break;
                                        if ( !v180 )
                                        {
                                          v71 = v527;
                                          v513 = v67;
                                          v185 = (unsigned int)v178;
                                          v62 = (char *)v510;
                                          if ( !v527 )
                                          {
                                            v36 = (int *)a2;
                                            goto LABEL_441;
                                          }
LABEL_563:
                                          if ( v185 > (unsigned int)v504 )
                                          {
                                            v527 = &v71[-(v185 - (_DWORD)v504)];
                                            if ( v513 != -1 )
                                            {
                                              --v62;
                                              IO_sputbackc((_DWORD *)a2, (unsigned __int8)v513);
                                            }
                                            v516 = v185 - 1;
                                            if ( (unsigned int)v504 < v185 - 1 )
                                            {
                                              v510 = v185;
                                              v218 = v504;
                                              v513 = (unsigned int)v62;
                                              v219 = (const char *)(v185 - 1);
                                              do
                                              {
                                                v220 = *(unsigned __int8 *)v219--;
                                                IO_sputbackc((_DWORD *)a2, v220);
                                              }
                                              while ( v218 != v219 );
                                              v221 = &v504[-v510 + 1];
                                              v516 += (int)v221;
                                              v62 = (char *)&v221[v513];
                                            }
                                            v71 = v527;
                                            v513 = *(unsigned __int8 *)v516;
                                            goto LABEL_183;
                                          }
LABEL_184:
                                          if ( v71 != v529 )
                                          {
                                            if ( v71 - v529 == 1 && ((*v529 - 43) & 0xFD) == 0 )
                                              goto LABEL_482;
                                            v510 = (int)v62;
                                            if ( v513 != -1 )
                                            {
                                              v510 = (int)(v62 - 1);
                                              IO_sputbackc((_DWORD *)a2, (unsigned __int8)v513);
                                            }
LABEL_188:
                                            v72 = v527;
                                            if ( v527 == v528 )
                                            {
                                              char_buffer_add_slow((int)&v527, 0);
                                            }
                                            else
                                            {
                                              ++v527;
                                              *v72 = 0;
                                            }
                                            if ( !v527 )
                                              goto LABEL_1332;
                                            v73 = v507 & 2;
                                            if ( (v507 & 2) != 0 )
                                            {
                                              if ( (v507 & 0x40) != 0 )
                                                v74 = _strtoll_internal(v529, &v517, v508, (unsigned __int8)v507 & 0x80);
                                              else
                                                LODWORD(v74) = _strtoull_internal(v529, &v517, v508, v507 & 0x80);
                                              v489 = HIDWORD(v74);
                                            }
                                            else if ( (v507 & 0x40) != 0 )
                                            {
                                              LODWORD(v74) = _strtol_internal(
                                                               (char *)v529,
                                                               (char **)&v517,
                                                               v508,
                                                               v507 & 0x80);
                                            }
                                            else
                                            {
                                              LODWORD(v74) = _strtoul_internal(
                                                               (char *)v529,
                                                               (char **)&v517,
                                                               v508,
                                                               v507 & 0x80);
                                            }
                                            if ( v517 == v529 )
                                            {
                                              v36 = (int *)a2;
                                              v516 = 2;
                                              goto LABEL_53;
                                            }
                                            v516 = v507 & 8;
                                            if ( (v507 & 8) != 0 )
                                              goto LABEL_23;
                                            if ( (v507 & 0x40) != 0 )
                                            {
                                              if ( v73 )
                                              {
                                                if ( v503 )
                                                {
                                                  v357 = &a4[(_DWORD)v503 - 1];
                                                  if ( v503 == (int *)1 )
                                                    v357 = a4;
                                                  HIDWORD(v74) = *v357;
                                                }
                                                else
                                                {
                                                  v75 = v501++;
                                                  HIDWORD(v74) = *v75;
                                                }
                                                goto LABEL_201;
                                              }
                                              if ( (v507 & 4) != 0 )
                                              {
                                                if ( v503 )
                                                {
                                                  v263 = &a4[(_DWORD)v503 - 1];
                                                  if ( v503 == (int *)1 )
                                                    v263 = a4;
                                                  HIDWORD(v74) = *v263;
                                                  goto LABEL_680;
                                                }
LABEL_786:
                                                v298 = v501++;
                                                HIDWORD(v74) = *v298;
                                                goto LABEL_680;
                                              }
                                              if ( (v507 & 0x200) != 0 )
                                              {
                                                if ( v503 )
                                                {
                                                  HIDWORD(v74) = &a4[(_DWORD)v503 - 1];
                                                  if ( v503 == (int *)1 )
                                                    HIDWORD(v74) = a4;
                                                  **(_BYTE **)HIDWORD(v74) = v74;
                                                }
                                                else
                                                {
                                                  HIDWORD(v74) = *v501++;
                                                  *(_BYTE *)HIDWORD(v74) = v74;
                                                }
                                                goto LABEL_202;
                                              }
                                              if ( !v503 )
                                              {
                                                HIDWORD(v74) = *v501++;
                                                *(_DWORD *)HIDWORD(v74) = v74;
                                                goto LABEL_202;
                                              }
LABEL_1029:
                                              HIDWORD(v74) = &a4[(_DWORD)v503 - 1];
                                              if ( v503 == (int *)1 )
                                                HIDWORD(v74) = a4;
                                              **(_DWORD **)HIDWORD(v74) = v74;
                                              goto LABEL_202;
                                            }
                                            if ( v73 )
                                            {
                                              if ( v503 )
                                              {
                                                v359 = &a4[(_DWORD)v503 - 1];
                                                if ( v503 == (int *)1 )
                                                  v359 = a4;
                                                HIDWORD(v74) = *v359;
                                              }
                                              else
                                              {
                                                v217 = v501++;
                                                HIDWORD(v74) = *v217;
                                              }
LABEL_201:
                                              *(_DWORD *)HIDWORD(v74) = v74;
                                              *(_DWORD *)(HIDWORD(v74) + 4) = v489;
                                            }
                                            else if ( (v507 & 4) != 0 )
                                            {
                                              if ( !v503 )
                                                goto LABEL_786;
                                              v261 = &a4[(_DWORD)v503 - 1];
                                              if ( v503 == (int *)1 )
                                                v261 = a4;
                                              HIDWORD(v74) = *v261;
LABEL_680:
                                              *(_WORD *)HIDWORD(v74) = v74;
                                            }
                                            else
                                            {
                                              if ( (v507 & 0x200) != 0 )
                                              {
                                                if ( v503 )
                                                {
                                                  HIDWORD(v74) = &a4[(_DWORD)v503 - 1];
                                                  if ( v503 == (int *)1 )
                                                    HIDWORD(v74) = a4;
                                                  **(_BYTE **)HIDWORD(v74) = v74;
                                                }
                                                else
                                                {
                                                  HIDWORD(v74) = *v501++;
                                                  *(_BYTE *)HIDWORD(v74) = v74;
                                                }
                                                goto LABEL_202;
                                              }
                                              if ( v503 )
                                                goto LABEL_1029;
                                              HIDWORD(v74) = *v501++;
                                              *(_DWORD *)HIDWORD(v74) = v74;
                                            }
LABEL_202:
                                            ++v511;
                                            goto LABEL_33;
                                          }
                                          if ( (v507 & 0x1000) != 0 && (unsigned int)v514 > 4 && v513 == 40 )
                                          {
                                            v191 = *(_DWORD *)(v509 + 56);
                                            v192 = *(unsigned __int8 **)(a2 + 4);
                                            if ( (unsigned int)v192 < *(_DWORD *)(a2 + 8) )
                                            {
                                              *(_DWORD *)(a2 + 4) = v192 + 1;
                                              v513 = *v192;
                                              goto LABEL_481;
                                            }
                                            v513 = _uflow((int *)a2);
                                            if ( v513 == -1 )
                                            {
                                              v403 = v191;
                                              v36 = (int *)a2;
                                              v384 = __readgsdword(0xFFFFFFE8);
                                              if ( *(_DWORD *)(v403 + 1020) == 110 )
                                              {
                                                __writegsdword(0xFFFFFFE8, v384);
                                                v386 = *(_DWORD *)(v509 + 56);
                                                if ( *(_DWORD *)(v386 + 1020) != 105 )
                                                  goto LABEL_993;
LABEL_1079:
                                                v28 = *(_DWORD *)(v386 + 1020) == 108;
                                                __writegsdword(0xFFFFFFE8, v384);
                                                if ( v28 )
LABEL_1080:
                                                  __writegsdword(0xFFFFFFE8, v384);
                                                v516 = 2;
                                                goto LABEL_53;
                                              }
LABEL_1075:
                                              v516 = 2;
                                              goto LABEL_53;
                                            }
LABEL_481:
                                            if ( *(_DWORD *)(v191 + 4 * (unsigned __int8)v513) != 110 )
                                              goto LABEL_482;
                                            v255 = *(_DWORD *)(v509 + 56);
                                            v256 = *(unsigned __int8 **)(a2 + 4);
                                            if ( (unsigned int)v256 >= *(_DWORD *)(a2 + 8) )
                                            {
                                              v513 = _uflow((int *)a2);
                                              if ( v513 == -1 )
                                              {
                                                v385 = v255;
                                                v36 = (int *)a2;
                                                v384 = __readgsdword(0xFFFFFFE8);
                                                if ( *(_DWORD *)(v385 + 1020) == 105 )
                                                {
                                                  v386 = *(_DWORD *)(v509 + 56);
                                                  goto LABEL_1079;
                                                }
                                                goto LABEL_1075;
                                              }
                                            }
                                            else
                                            {
                                              *(_DWORD *)(a2 + 4) = v256 + 1;
                                              v513 = *v256;
                                            }
                                            if ( *(_DWORD *)(v255 + 4 * (unsigned __int8)v513) != 105 )
                                              goto LABEL_482;
                                            v257 = *(_DWORD *)(v509 + 56);
                                            v258 = *(unsigned __int8 **)(a2 + 4);
                                            if ( (unsigned int)v258 >= *(_DWORD *)(a2 + 8) )
                                            {
                                              v513 = _uflow((int *)a2);
                                              if ( v513 == -1 )
                                              {
                                                v383 = v257;
                                                v36 = (int *)a2;
                                                v384 = __readgsdword(0xFFFFFFE8);
                                                if ( *(_DWORD *)(v383 + 1020) == 108 )
                                                  goto LABEL_1080;
                                                goto LABEL_1075;
                                              }
                                            }
                                            else
                                            {
                                              *(_DWORD *)(a2 + 4) = v258 + 1;
                                              v513 = *v258;
                                            }
                                            if ( *(_DWORD *)(v257 + 4 * (unsigned __int8)v513) != 108 )
                                              goto LABEL_482;
                                            v259 = *(unsigned __int8 **)(a2 + 4);
                                            if ( (unsigned int)v259 >= *(_DWORD *)(a2 + 8) )
                                            {
                                              v513 = _uflow((int *)a2);
                                              if ( v513 == -1 )
                                              {
                                                v36 = (int *)a2;
LABEL_993:
                                                v516 = 2;
                                                goto LABEL_53;
                                              }
                                            }
                                            else
                                            {
                                              *(_DWORD *)(a2 + 4) = v259 + 1;
                                              v513 = *v259;
                                            }
                                            v510 = (int)(v62 + 4);
                                            if ( v513 == 41 )
                                            {
                                              v260 = v527;
                                              if ( v527 == v528 )
                                              {
                                                char_buffer_add_slow((int)&v527, 48);
                                              }
                                              else
                                              {
                                                ++v527;
                                                *v260 = 48;
                                              }
                                              goto LABEL_188;
                                            }
                                            v36 = (int *)a2;
                                          }
                                          else
                                          {
LABEL_482:
                                            v36 = (int *)a2;
                                            if ( v513 == -1 )
                                              goto LABEL_1075;
                                          }
                                          IO_sputbackc(v36, (unsigned __int8)v513);
                                          v516 = 2;
                                          goto LABEL_53;
                                        }
                                        v181 = *(unsigned __int8 **)(a2 + 4);
                                        if ( (unsigned int)v181 >= *(_DWORD *)(a2 + 8) )
                                        {
                                          v516 = v180;
                                          v67 = _uflow((int *)a2);
                                          v180 = v516;
                                          if ( v67 == -1 )
                                          {
                                            v179 = v516;
                                            v68 = (int *)a2;
                                            v512 = __readgsdword(0xFFFFFFE8);
                                            goto LABEL_429;
                                          }
                                        }
                                        else
                                        {
                                          *(_DWORD *)(a2 + 4) = v181 + 1;
                                          v67 = *v181;
                                        }
                                        v182 = *(unsigned __int8 *)v178;
                                        ++v510;
                                        --v180;
                                        if ( v182 != v67 )
                                        {
                                          v179 = v180;
                                          v68 = (int *)a2;
                                          goto LABEL_429;
                                        }
                                      }
                                      v184 = v527;
                                      v179 = v180;
                                      v68 = (int *)a2;
                                      if ( !v527 )
                                      {
LABEL_440:
                                        v36 = v68;
LABEL_441:
                                        v516 = 0;
                                        v511 = -1;
                                        __writegsdword(0xFFFFFFE8, 0xCu);
                                        goto LABEL_53;
                                      }
                                    }
                                    else
                                    {
                                      v178 = v504;
LABEL_429:
                                      v184 = v527;
                                      v71 = v527;
                                      if ( !v527 )
                                        goto LABEL_440;
                                      if ( *v178 )
                                      {
                                        v62 = (char *)v510;
                                        v513 = v67;
                                        v185 = (unsigned int)v178;
                                        goto LABEL_563;
                                      }
                                      LOBYTE(v516) = v67;
                                      v513 = (char)v67;
                                    }
                                    if ( v514 <= 0 )
                                      v179 = v514;
                                    v69 = v184 - 1;
                                    v527 = v69;
                                    v514 = v179;
                                  }
                                  else
                                  {
                                    if ( v67 - 47 > v508 )
                                      goto LABEL_182;
                                    v69 = v527;
                                    LOBYTE(v516) = v67;
                                    v513 = v67;
                                  }
                                  if ( v69 == v528 )
                                  {
                                    v516 = (int)v68;
                                    char_buffer_add_slow((int)&v527, v513);
                                    v68 = (int *)v516;
                                  }
                                  else
                                  {
                                    v527 = v69 + 1;
                                    *v69 = v516;
                                  }
                                  v514 -= v514 > 0;
                                  if ( v67 == -1 )
                                    break;
                                  v70 = (unsigned __int8 *)v68[1];
                                  if ( (unsigned int)v70 >= v68[2] )
                                  {
                                    v516 = (int)v68;
                                    v67 = _uflow(v68);
                                    v68 = (int *)v516;
                                    if ( v67 == -1 )
                                    {
                                      v512 = __readgsdword(0xFFFFFFE8);
                                      goto LABEL_170;
                                    }
                                  }
                                  else
                                  {
                                    v68[1] = (int)(v70 + 1);
                                    v67 = *v70;
                                  }
                                  ++v510;
                                }
                                __writegsdword(0xFFFFFFE8, v512);
                              }
                            }
LABEL_166:
                            if ( v508 != 10 )
                              goto LABEL_169;
                            goto LABEL_167;
                          }
                          v36 = (int *)a2;
                        }
                        v516 = 1;
                        if ( !v511 )
                          v511 = -1;
                        goto LABEL_53;
                      default:
                        v36 = (int *)a2;
                        v516 = 2;
                        goto LABEL_53;
                    }
                  }
                }
                v44 = v515++;
LABEL_108:
                v508 = (int)v44;
                LOBYTE(v505) = v29;
                v46 = v509;
                v36 = (int *)a2;
                v47 = (char *)__readgsdword(0xFFFFFFE8);
                v48 = -24;
                v516 = -24;
                __writegsdword(0xFFFFFFE8, 0);
                v49 = v513;
                v502 = v47;
                v50 = v510;
                break;
              case 'h':
                LOBYTE(v29) = v515[1];
                if ( (_BYTE)v29 == 104 )
                {
                  v44 = v515 + 2;
                  v507 |= 0x200u;
                  LOBYTE(v29) = v515[2];
                }
                else
                {
                  v507 |= 4u;
                }
                goto LABEL_94;
              case 'j':
                v507 |= 2u;
                LOBYTE(v29) = v515[1];
                goto LABEL_94;
              case 'l':
                LOBYTE(v29) = v515[1];
                if ( (_BYTE)v29 == 108 )
                {
                  v44 = v515 + 2;
                  v507 |= 3u;
                  LOBYTE(v29) = v515[2];
                }
                else
                {
                  v507 |= 1u;
                }
                goto LABEL_94;
              case 'm':
                LOBYTE(v29) = v515[1];
                if ( (_BYTE)v29 == 108 )
                {
                  v507 |= 0x2001u;
                  v44 = v515 + 2;
                  LOBYTE(v29) = v515[2];
                }
                else
                {
                  v507 |= 0x2000u;
                }
                goto LABEL_94;
              case 't':
              case 'z':
LABEL_93:
                LOBYTE(v29) = v515[1];
                goto LABEL_94;
              default:
                v44 = v515;
                goto LABEL_94;
            }
            while ( 1 )
            {
              while ( 1 )
              {
                if ( v49 == -1 )
                {
                  if ( __readgsdword(v48) == 4 )
                    goto LABEL_119;
                  goto LABEL_114;
                }
                v51 = *(unsigned __int8 **)(a2 + 4);
                if ( (unsigned int)v51 >= *(_DWORD *)(a2 + 8) )
                  break;
                ++v50;
                *(_DWORD *)(a2 + 4) = v51 + 1;
                v49 = *v51;
LABEL_111:
                if ( (*(_BYTE *)(*(_DWORD *)(v46 + 52) + 2 * v49 + 1) & 0x20) == 0 )
                  goto LABEL_115;
              }
              v513 = v48;
              v49 = _uflow((int *)a2);
              v48 = v513;
              if ( v49 != -1 )
              {
                ++v50;
                goto LABEL_111;
              }
              v512 = __readgsdword(v513);
              if ( v512 == 4 )
              {
LABEL_119:
                v516 = 1;
                if ( !v511 )
                  v511 = -1;
                goto LABEL_53;
              }
LABEL_114:
              v49 = -1;
              if ( (*(_BYTE *)(*(_DWORD *)(v46 + 52) - 2 + 1) & 0x20) == 0 )
              {
LABEL_115:
                v52 = v50;
                v510 = v50;
                v5 = (unsigned int)v502;
                v44 = (unsigned __int8 *)v508;
                v513 = v49;
                __writegsdword(v516, (unsigned int)v502);
                if ( v49 == -1 )
                {
                  switch ( (char)v505 )
                  {
                    case '%':
                      v36 = (int *)a2;
                      v176 = v516;
                      goto LABEL_405;
                    case 'A':
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'a':
                    case 'e':
                    case 'f':
                    case 'g':
                      v36 = (int *)a2;
                      v175 = v516;
                      goto LABEL_401;
                    case 'C':
                      goto LABEL_224;
                    case 'S':
                      goto LABEL_203;
                    case 'X':
                    case 'd':
                    case 'i':
                    case 'o':
                    case 'u':
                    case 'x':
                      v36 = (int *)a2;
                      v59 = v516;
                      goto LABEL_139;
                    case '[':
                      goto LABEL_307;
                    case 'c':
                      goto LABEL_282;
                    case 'n':
                      goto LABEL_277;
                    case 'p':
                      goto LABEL_145;
                    case 's':
                      goto LABEL_253;
                    default:
                      v36 = (int *)a2;
                      v516 = 2;
                      break;
                  }
                }
                else
                {
                  v5 = v52 - 1;
                  v53 = v505 - 37;
                  v510 = v52 - 1;
                  IO_sputbackc((_DWORD *)a2, (unsigned __int8)v49);
                  switch ( v53 )
                  {
                    case 0:
                      goto LABEL_392;
                    case 28:
                    case 32:
                    case 33:
                    case 34:
                    case 60:
                    case 64:
                    case 65:
                    case 66:
                      goto LABEL_339;
                    case 30:
                      goto LABEL_224;
                    case 46:
                      goto LABEL_203;
                    case 51:
                    case 83:
                      v508 = 16;
                      goto LABEL_148;
                    case 54:
                      goto LABEL_307;
                    case 62:
                      goto LABEL_282;
                    case 63:
                      goto LABEL_251;
                    case 68:
                      goto LABEL_337;
                    case 73:
                      goto LABEL_277;
                    case 74:
                      v508 = 8;
                      goto LABEL_148;
                    case 75:
                      goto LABEL_145;
                    case 78:
                      goto LABEL_253;
                    case 80:
                      v508 = 10;
                      goto LABEL_148;
                    default:
                      v36 = (int *)a2;
                      v516 = 2;
                      break;
                  }
                }
                goto LABEL_53;
              }
            }
          }
          if ( v513 != -1 )
          {
            v20 = (unsigned __int8 *)(v5 + v19);
            v21 = v510;
            while ( 1 )
            {
              v22 = *(unsigned __int8 **)(a2 + 4);
              if ( (unsigned int)v22 >= *(_DWORD *)(a2 + 8) )
              {
                v515 = v20;
                v14 = _uflow((int *)a2);
                v20 = v515;
                if ( v14 == -1 )
                {
                  v36 = (int *)a2;
                  goto LABEL_51;
                }
              }
              else
              {
                *(_DWORD *)(a2 + 4) = v22 + 1;
                v14 = *v22;
              }
              v23 = *(unsigned __int8 *)v5++;
              ++v21;
              if ( v23 != v14 )
                goto LABEL_461;
              if ( (unsigned __int8 *)v5 == v20 )
              {
                v515 = (unsigned __int8 *)v5;
                v510 = v21;
                v513 = v23;
                goto LABEL_33;
              }
            }
          }
          v36 = (int *)a2;
          __writegsdword(0xFFFFFFE8, v512);
LABEL_51:
          v516 = 1;
          if ( !v511 )
            v511 = -1;
        }
        else
        {
          v36 = (int *)a2;
          if ( v516 )
          {
            v186 = v512;
            v187 = v513;
            v188 = v509;
            do
            {
              if ( v187 == -1 )
              {
                __writegsdword(0xFFFFFFE8, v186);
                v190 = -2;
              }
              else
              {
                v189 = *(unsigned __int8 **)(a2 + 4);
                if ( (unsigned int)v189 >= *(_DWORD *)(a2 + 8) )
                {
                  v187 = _uflow((int *)a2);
                  if ( v187 == -1 )
                  {
                    v186 = __readgsdword(0xFFFFFFE8);
                    v190 = -2;
                  }
                  else
                  {
                    v190 = 2 * v187;
                  }
                }
                else
                {
                  *(_DWORD *)(a2 + 4) = v189 + 1;
                  v187 = *v189;
                  v190 = 2 * v187;
                }
              }
            }
            while ( (*(_WORD *)(*(_DWORD *)(v188 + 52) + v190) & 0x2000) != 0 );
            v516 = 0;
            if ( v187 != -1 )
              IO_sputbackc((_DWORD *)a2, (unsigned __int8)v187);
          }
        }
        break;
      }
LABEL_53:
      if ( (*v36 & 0x8000) == 0 )
      {
        v37 = (_DWORD *)v36[18];
        v28 = v37[1]-- == 1;
        if ( v28 )
        {
          v37[2] = 0;
          if ( __readgsdword(0xCu) )
            __asm { lock }
          v28 = (*v37)-- == 1;
          if ( !v28 )
            _lll_unlock_wake_private(v37);
        }
      }
      if ( v529 != (unsigned __int8 *)v531 )
        free(v529);
      if ( a5 )
        *a5 |= v516;
      if ( v511 != -1 )
      {
        if ( v506 )
        {
          v58 = v506;
          free(*v506);
          *v58 = 0;
        }
        return v511;
      }
      for ( jj = v497; jj; jj = (int *)jj[1] )
      {
        v55 = 0;
        if ( *jj )
        {
          do
          {
            free(*(_DWORD *)jj[v55 + 2]);
            v56 = (_DWORD *)jj[v55++ + 2];
            v57 = *jj <= v55;
            *v56 = 0;
          }
          while ( !v57 );
        }
      }
    }
    else
    {
      __writegsdword(0xFFFFFFE8, 0x16u);
    }
LABEL_35:
    v511 = -1;
    return -1;
  }
  v511 = -1;
  __writegsdword(0xFFFFFFE8, 9u);
  return v511;
}
// 80A43AC: conditional instruction was optimized away because ebx.4!=FFFFFFFF
// 80A4481: variable 'v74' is possibly undefined
// 80A86DD: variable 'v157' is possibly undefined
// 80A899E: variable 'v285' is possibly undefined
// 80481E0: using guessed type int __cdecl j_rawmemchr(_DWORD, _DWORD);
// 8048260: using guessed type int __cdecl j_strcmp(_DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 808F410: using guessed type _DWORD __cdecl wcrtomb(_DWORD, _DWORD, _DWORD);
// 80A3780: using guessed type char var_439[17];
// 80A3780: using guessed type char var_44A[17];

//----- (080A9A60) --------------------------------------------------------
int __usercall vfscanf@<eax>(long double a1@<st0>, int a2, unsigned int a3, long double **a4)
{
  return IO_vfscanf_internal(a1, a2, a3, a4, 0);
}

//----- (080A9A80) --------------------------------------------------------
int __cdecl IO_seekoff_unlocked(int *a1, __int64 a2, unsigned int a3, int a4)
{
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // eax
  int v7; // ebp
  unsigned __int64 v9; // [esp+8h] [ebp-24h]
  unsigned __int64 v10; // [esp+8h] [ebp-24h]

  v5 = HIDWORD(a2);
  v4 = a2;
  if ( a3 > 2 )
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    return -1;
  }
  else
  {
    if ( a4 )
    {
      v6 = a1[26];
      if ( v6 < 0 )
      {
        if ( a1[9] )
        {
          if ( a3 == 1 && (*a1 & 0x100) != 0 )
          {
            v5 = (unsigned __int64)(a2 - (a1[2] - a1[1])) >> 32;
            v4 = a2 - (a1[2] - a1[1]);
          }
          v9 = __PAIR64__(v5, v4);
          IO_free_backup_area(a1);
          v5 = HIDWORD(v9);
          v4 = v9;
        }
      }
      else if ( v6 && *(_DWORD *)(a1[22] + 32) )
      {
        if ( a3 == 1 && (*a1 & 0x100) != 0 )
          abort(HIDWORD(a2));
        IO_free_wbackup_area(a1);
        v5 = HIDWORD(a2);
        v4 = a2;
      }
    }
    v7 = a1[37];
    if ( (char *)_start___libc_atexit - (char *)&_start___libc_IO_vtables <= (unsigned int)(v7
                                                                                          - (_DWORD)&_start___libc_IO_vtables) )
    {
      v10 = __PAIR64__(v5, v4);
      IO_vtable_check();
      v5 = HIDWORD(v10);
      v4 = v10;
    }
    return (*(int (__cdecl **)(int *, unsigned int, unsigned int, unsigned int, int))(v7 + 36))(a1, v4, v5, a3, a4);
  }
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 8051620: using guessed type int IO_vtable_check(void);
// 80D6B34: using guessed type int (*_start___libc_atexit[2])();

//----- (080A9BD0) --------------------------------------------------------
int __cdecl IO_seekoff(int *a1, __int64 a2, unsigned int a3, int a4)
{
  bool v6; // zf
  int v7; // esi
  _DWORD *v8; // edx
  unsigned int v10; // [esp+Ch] [ebp-1Ch]

  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v10 = __readgsdword(8u);
    if ( v10 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v6 = __readgsdword(0xCu) == 0;
      if ( !v6 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v6 )
        _lll_lock_wait_private(0, (volatile __int32 *)_EDX);
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v10;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v7 = IO_seekoff_unlocked(a1, a2, a3, a4);
  if ( (*a1 & 0x8000) == 0 )
  {
    v8 = (_DWORD *)a1[18];
    v6 = v8[1]-- == 1;
    if ( v6 )
    {
      v8[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*v8)-- == 1;
      if ( !v6 )
        _lll_unlock_wake_private(v8);
    }
  }
  return v7;
}

//----- (080A9CC0) --------------------------------------------------------
int __usercall dlopen_doit@<eax>(int a1@<edi>, long double a2@<st0>, int a3)
{
  int v3; // eax
  _BYTE *v4; // edx
  int v5; // eax
  int result; // eax
  const char *v7; // eax

  v3 = *(_DWORD *)(a3 + 4);
  if ( (v3 & 0xBFFFEEF0) != 0 )
  {
    v7 = (const char *)dcgettext(a2, "libc", "invalid mode parameter", 5u);
    dl_signal_error(0, 0, 0, a2, v7);
  }
  v4 = *(_BYTE **)a3;
  v5 = v3 | 0x80000000;
  if ( !*(_DWORD *)a3 )
    v4 = &unk_80CFAB1;
  result = dl_open(a1, a2, v4, v5, *(_DWORD *)(a3 + 12), 0, _libc_argc, _libc_argv, environ);
  *(_DWORD *)(a3 + 8) = result;
  return result;
}
// 80EC524: using guessed type int environ;
// 80ECCCC: using guessed type int _libc_argc;
// 80ECCD0: using guessed type int _libc_argv;

//----- (080A9D30) --------------------------------------------------------
int __usercall _dlopen@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5, int a6)
{
  _BOOL4 v6; // eax
  int v7; // edx
  int v9[2]; // [esp+0h] [ebp-1Ch] BYREF
  int v10; // [esp+8h] [ebp-14h]
  int v11; // [esp+Ch] [ebp-10h]

  v9[0] = a4;
  v9[1] = a5;
  v11 = a6;
  v6 = dlerror_run((void (__cdecl *)(int))dlopen_doit, (int)v9, a1);
  v7 = 0;
  if ( !v6 )
  {
    _libc_register_dl_open_hook(a1, a2, a3, v10);
    _libc_register_dlfcn_hook(a1, a2, a3, v10);
    return v10;
  }
  return v7;
}

//----- (080A9D90) --------------------------------------------------------
int __usercall _dlclose@<eax>(int a1@<ebp>, int a2)
{
  return -dlerror_run((void (__cdecl *)(int))dlclose_doit, a2, a1);
}
// 80A9D80: using guessed type int dlclose_doit();

//----- (080A9DB0) --------------------------------------------------------
int (*__usercall dlsym_doit@<eax>(long double a1@<st0>, int a2))(void)
{
  int (*result)(void); // eax

  result = dl_sym(*(_DWORD *)a2, *(unsigned __int8 **)(a2 + 4), *(_DWORD *)(a2 + 8), a1);
  *(_DWORD *)(a2 + 12) = result;
  return result;
}

//----- (080A9DD0) --------------------------------------------------------
int __usercall _dlsym@<eax>(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // ebx
  int v6[7]; // [esp+0h] [ebp-1Ch] BYREF

  v6[2] = a4;
  v6[0] = a2;
  v6[1] = a3;
  v4 = 0;
  if ( !dlerror_run((void (__cdecl *)(int))dlsym_doit, (int)v6, a1) )
    return v6[3];
  return v4;
}

//----- (080A9E40) --------------------------------------------------------
int (*__usercall dlvsym_doit@<eax>(long double a1@<st0>, int a2))(void)
{
  int (*result)(void); // eax

  result = dl_vsym(
             *(_DWORD *)a2,
             *(unsigned __int8 **)(a2 + 4),
             *(unsigned __int8 **)(a2 + 8),
             a1,
             *(_DWORD *)(a2 + 12));
  *(_DWORD *)(a2 + 16) = result;
  return result;
}

//----- (080A9E60) --------------------------------------------------------
int __usercall _dlvsym@<eax>(int a1@<ebp>, int a2, int a3, int a4, int a5)
{
  int v5; // ebx
  int v7[8]; // [esp+Ch] [ebp-20h] BYREF

  v7[0] = a2;
  v7[1] = a3;
  v7[3] = a5;
  v7[2] = a4;
  v5 = 0;
  if ( !dlerror_run((void (__cdecl *)(int))dlvsym_doit, (int)v7, a1) )
    return v7[4];
  return v5;
}

//----- (080A9EE0) --------------------------------------------------------
int __cdecl _libc_scratch_buffer_set_array_size(int *a1, unsigned int a2, int a3)
{
  unsigned int v3; // esi
  int result; // eax

  v3 = a3 * a2;
  if ( (a3 | a2) >> 16 && a2 && a3 != v3 / a2 )
  {
    if ( (int *)*a1 != a1 + 2 )
      free(*a1);
    *a1 = (int)(a1 + 2);
    a1[1] = 1024;
    __writegsdword(0xFFFFFFE8, 0xCu);
    return 0;
  }
  else
  {
    result = 1;
    if ( v3 > a1[1] )
    {
      if ( (int *)*a1 != a1 + 2 )
        free(*a1);
      result = malloc(v3);
      if ( result )
      {
        *a1 = result;
        a1[1] = v3;
        return 1;
      }
      else
      {
        *a1 = (int)(a1 + 2);
        a1[1] = 1024;
      }
    }
  }
  return result;
}
// 805A010: using guessed type _DWORD __cdecl malloc(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);

//----- (080A9F90) --------------------------------------------------------
_BYTE *__cdecl strpbrk(int a1, _BYTE *a2)
{
  int v3; // ecx
  _BYTE *result; // eax
  char v5[256]; // [esp+0h] [ebp-100h] BYREF

  v3 = 0;
  memset(v5, 0, sizeof(v5));
  do
  {
    if ( !*a2 )
      break;
    LOBYTE(v3) = *a2;
    v5[v3] = *a2;
    LOBYTE(v3) = a2[1];
    if ( !(_BYTE)v3 )
      break;
    v5[v3] = v3;
    LOBYTE(v3) = a2[2];
    if ( !(_BYTE)v3 )
      break;
    v5[v3] = v3;
    LOBYTE(v3) = a2[3];
    a2 += 4;
    v5[v3] = v3;
  }
  while ( (_BYTE)v3 );
  result = (_BYTE *)(a1 - 4);
  while ( 1 )
  {
    result += 4;
    LOBYTE(v3) = *result;
    if ( v5[v3] == *result )
      break;
    LOBYTE(v3) = result[1];
    if ( v5[v3] == (_BYTE)v3 )
      goto LABEL_13;
    LOBYTE(v3) = result[2];
    if ( v5[v3] == (_BYTE)v3 )
      goto LABEL_12;
    LOBYTE(v3) = result[3];
    if ( v5[v3] == (_BYTE)v3 )
    {
      ++result;
LABEL_12:
      ++result;
LABEL_13:
      ++result;
      break;
    }
  }
  if ( !(_BYTE)v3 )
    return 0;
  return result;
}
// 80A9F90: using guessed type char var_100[256];

//----- (080AA050) --------------------------------------------------------
int __cdecl mbrlen(_BYTE *a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax

  v3 = a3;
  if ( !a3 )
    v3 = &internal;
  return mbrtowc(0, a1, a2, v3);
}

//----- (080AA080) --------------------------------------------------------
int __cdecl mbrtowc(char *a1, _BYTE *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // eax
  _BYTE *v5; // esi
  int v6; // edi
  char *v7; // ebx
  int v9; // ebp
  void **v10; // eax
  bool v11; // cf
  int v12; // edi
  int (__cdecl *v13)(void *, int *, _BYTE **, int, _DWORD, char *, _DWORD, int); // ebp
  int v14; // eax
  unsigned int v15; // edx
  void **v16; // [esp+Ch] [ebp-50h]
  char v17; // [esp+14h] [ebp-48h] BYREF
  char v18[4]; // [esp+18h] [ebp-44h] BYREF
  _BYTE *v19; // [esp+1Ch] [ebp-40h] BYREF
  int v20[5]; // [esp+20h] [ebp-3Ch] BYREF
  _DWORD *v21; // [esp+34h] [ebp-28h]

  v4 = a4;
  v5 = a2;
  v6 = a3;
  v20[3] = 0;
  v20[4] = 1;
  v7 = a1;
  if ( !a1 )
    v7 = &v17;
  v20[2] = 1;
  if ( !a4 )
    v4 = &state_2;
  v21 = v4;
  if ( a2 )
  {
    if ( !a3 )
      return -2;
  }
  else
  {
    v7 = &v17;
    v6 = 1;
    v5 = &unk_80CFAB1;
  }
  v20[0] = (int)v7;
  v20[1] = (int)(v7 + 4);
  v9 = *(_DWORD *)__readgsdword(0xFFFFFFD8);
  v10 = *(void ***)(v9 + 20);
  if ( !v10 )
  {
    if ( (void **)v9 == &nl_C_LC_CTYPE )
    {
      v10 = &_wcsmbs_gconv_fcts_c;
    }
    else
    {
      _wcsmbs_load_conv();
      v10 = *(void ***)(v9 + 20);
    }
  }
  v11 = __CFADD__(v5, v6);
  v12 = (int)&v5[v6];
  v19 = v5;
  if ( v11 )
  {
    v12 = -1;
    if ( v5 == (_BYTE *)-1 )
      goto LABEL_19;
  }
  v13 = (int (__cdecl *)(void *, int *, _BYTE **, int, _DWORD, char *, _DWORD, int))*((_DWORD *)*v10 + 5);
  if ( *(_DWORD *)*v10 )
    v13 = (int (__cdecl *)(void *, int *, _BYTE **, int, _DWORD, char *, _DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v13, 9));
  v16 = v10;
  dl_mcount_wrapper_check((int)v13);
  v14 = v13(*v16, v20, &v19, v12, 0, v18, 0, 1);
  v15 = v14 - 4;
  if ( v14 && v15 > 3 )
    _assert_fail(
      "status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __GCONV_INCO"
      "MPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
      "mbrtowc.c",
      96,
      "__mbrtowc");
  if ( v14 && v15 > 1 )
  {
    if ( v14 == 7 )
      return -2;
LABEL_19:
    __writegsdword(0xFFFFFFE8, 0x54u);
    return -1;
  }
  if ( (char *)v20[0] == v7 || *(_DWORD *)v7 )
    return v19 - v5;
  if ( *v21 )
    _assert_fail("__mbsinit (data.__statep)", "mbrtowc.c", 105, "__mbrtowc");
  return 0;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 806D520: using guessed type int _wcsmbs_load_conv(void);
// 80BE940: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80C0B60: using guessed type void *nl_C_LC_CTYPE;
// 80AA080: using guessed type char var_44[4];

//----- (080AA230) --------------------------------------------------------
unsigned int __cdecl _profil_counter(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16)
{
  unsigned int result; // eax

  result = ((unsigned int)pc_scale * (unsigned __int64)(unsigned int)((a16 - pc_offset) / 2)) >> 16;
  if ( result < nsamples )
    ++*(_WORD *)(samples + 2 * result);
  return result;
}
// 80EC8BC: using guessed type int pc_scale;
// 80EC8C0: using guessed type int pc_offset;
// 80EC8C4: using guessed type int nsamples;
// 80EC8C8: using guessed type int samples;

//----- (080AA270) --------------------------------------------------------
int __cdecl profil(int a1, unsigned int a2, int a3, int a4)
{
  int *v4; // eax
  int result; // eax
  int v6[3]; // [esp+4h] [ebp-A8h] BYREF
  int v7; // [esp+10h] [ebp-9Ch]
  unsigned int (__cdecl *v8)(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int); // [esp+14h] [ebp-98h] BYREF
  char v9; // [esp+94h] [ebp-18h] BYREF
  int v10; // [esp+98h] [ebp-14h]

  if ( a1 )
  {
    if ( !samples || (setitimer(2, (int)&otimer_7767) & 0x80000000) == 0 && sigaction(27, oact_7766, 0) >= 0 )
    {
      samples = a1;
      v8 = _profil_counter;
      v10 = 0x10000000;
      nsamples = a2 >> 1;
      pc_offset = a3;
      pc_scale = a4;
      v4 = (int *)&v9;
      do
        *v4-- = -1;
      while ( v4 != (int *)&v8 );
      if ( sigaction(27, v4, oact_7766) >= 0 )
      {
        v6[2] = 0;
        v7 = 1000000 / _profile_frequency();
        v6[0] = 0;
        v6[1] = v7;
        return setitimer(2, (int)v6);
      }
    }
    return -1;
  }
  result = 0;
  if ( samples )
  {
    if ( (setitimer(2, (int)&otimer_7767) & 0x80000000) == 0 )
    {
      samples = 0;
      return sigaction(27, oact_7766, 0);
    }
    return -1;
  }
  return result;
}
// 80EC820: using guessed type int oact_7766[35];
// 80EC8BC: using guessed type int pc_scale;
// 80EC8C0: using guessed type int pc_offset;
// 80EC8C4: using guessed type int nsamples;
// 80EC8C8: using guessed type int samples;

//----- (080AA3E0) --------------------------------------------------------
int _profile_frequency()
{
  return dl_clktck;
}
// 80ECC9C: using guessed type int dl_clktck;

//----- (080AA3F0) --------------------------------------------------------
int __usercall call_dl_lookup@<eax>(long double a1@<st0>, int a2)
{
  int result; // eax

  result = dl_lookup_symbol_x(
             *(unsigned __int8 **)(a2 + 4),
             *(_DWORD *)a2,
             *(int **)(a2 + 20),
             a1,
             *(int ***)(*(_DWORD *)a2 + 460),
             *(const char ***)(a2 + 8),
             0,
             *(_DWORD *)(a2 + 12),
             0);
  *(_DWORD *)a2 = result;
  return result;
}

//----- (080AA420) --------------------------------------------------------
int (*__userpurge do_sym@<eax>(
        unsigned int a1@<eax>,
        unsigned __int8 *a2@<edx>,
        unsigned int a3@<ecx>,
        long double a4@<st0>,
        const char **a5,
        int a6))(void)
{
  int **dso_for_object; // eax
  int *v10; // eax
  int v11; // eax
  int (*result)(void); // eax
  int **v13; // edx
  int v14; // edi
  _BYTE *v16; // ebx
  int v17; // eax
  void *v18; // esp
  const char *v19; // esi
  int v20; // eax
  void *v21; // esp
  _BYTE *v22; // eax
  _BYTE v23[12]; // [esp+0h] [ebp-58h] BYREF
  _BYTE *v24; // [esp+Ch] [ebp-4Ch]
  char v25; // [esp+1Bh] [ebp-3Dh] BYREF
  int v26; // [esp+1Ch] [ebp-3Ch] BYREF
  _BYTE *v27; // [esp+20h] [ebp-38h] BYREF
  _BYTE *v28; // [esp+24h] [ebp-34h] BYREF
  int v29[12]; // [esp+28h] [ebp-30h] BYREF
  int savedregs; // [esp+58h] [ebp+0h] BYREF

  v26 = 0;
  dso_for_object = (int **)dl_find_dso_for_object(a3);
  if ( !dso_for_object )
    dso_for_object = (int **)dl_ns;
  if ( a1 )
  {
    if ( a1 == -1 )
    {
      v13 = dso_for_object;
      if ( dso_for_object == dl_ns )
      {
        if ( !dso_for_object || a3 < (unsigned int)dso_for_object[107] || a3 >= (unsigned int)dso_for_object[108] )
          dl_signal_error(0, 0, 0, a4, "RTLD_NEXT used in code not dynamically loaded");
        v13 = dso_for_object;
      }
      while ( v13[91] )
        v13 = (int **)v13[91];
      v10 = (int *)dl_lookup_symbol_x(
                     a2,
                     (unsigned int)dso_for_object,
                     &v26,
                     a4,
                     v13 + 116,
                     a5,
                     0,
                     0,
                     (int)dso_for_object);
    }
    else
    {
      v10 = (int *)dl_lookup_symbol_x(a2, a1, &v26, a4, (int **)(a1 + 464), a5, 0, a6, 0);
    }
  }
  else if ( __readgsdword(0xCu) )
  {
    v29[0] = (int)dso_for_object;
    v29[1] = (int)a2;
    v29[2] = (int)a5;
    v29[3] = a6 | 5;
    v29[5] = (int)&v26;
    __writegsdword(0x1Cu, 1u);
    v28 = 0;
    v14 = dl_catch_error(&v27, &v28, &v25, (int)&savedregs, (int)a2, 0, (void (__cdecl *)(int))call_dl_lookup, (int)v29);
    if ( _InterlockedExchange(MK_FP(__GS__, 28), 0) == 2 )
      dl_sysinfo(129);
    v16 = v28;
    v10 = (int *)v29[0];
    if ( v28 )
    {
      v17 = strlen(v28);
      v18 = alloca(v17 + 16);
      v19 = memcpy(v23, v28, v17 + 1);
      v24 = v27;
      v20 = strlen(v27);
      v21 = alloca(v20 + 16);
      v22 = memcpy(v23, v27, v20 + 1);
      if ( v25 )
      {
        v24 = v22;
        free(a4, (int)v16);
        v22 = v24;
      }
      dl_signal_error(v14, v22, 0, a4, v19);
    }
  }
  else
  {
    v10 = (int *)dl_lookup_symbol_x(
                   a2,
                   (unsigned int)dso_for_object,
                   &v26,
                   a4,
                   (int **)dso_for_object[115],
                   a5,
                   0,
                   a6 | 1,
                   0);
  }
  if ( !v26 )
    return 0;
  if ( v10 )
    v11 = *v10;
  else
    v11 = 0;
  result = (int (*)(void))(*(_DWORD *)(v26 + 4) + v11);
  if ( (*(_BYTE *)(v26 + 12) & 0xF) == 10 )
    return (int (*)(void))result();
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EBA40: using guessed type void *dl_ns;

//----- (080AA680) --------------------------------------------------------
int (*__userpurge dl_vsym@<eax>(
        unsigned int a1@<eax>,
        unsigned __int8 *a2@<edx>,
        unsigned __int8 *a3@<ecx>,
        long double a4@<st0>,
        unsigned int a5))(void)
{
  unsigned int v5; // esi
  unsigned int v7; // ecx
  int v8; // ecx
  _BYTE *v9; // ebx
  int i; // ecx
  int v11; // esi
  const char *v13[7]; // [esp+8h] [ebp-1Ch] BYREF

  v5 = 0;
  v13[0] = (const char *)a3;
  v13[2] = (const char *)1;
  v7 = *a3;
  if ( v7 )
  {
    v5 = v7;
    if ( a3[1] )
    {
      v5 = a3[1] + 16 * v7;
      if ( a3[2] )
      {
        v5 = a3[2] + 16 * v5;
        if ( a3[3] )
        {
          v5 = a3[3] + 16 * v5;
          v8 = a3[4];
          if ( a3[4] )
          {
            v9 = a3 + 5;
            v5 = v8 + 16 * v5;
            for ( i = (unsigned __int8)*v9; *v9; v5 = ((v11 & 0xF0000000) >> 24) ^ v11 & 0xFFFFFFF )
            {
              ++v9;
              v11 = i + 16 * v5;
              i = (unsigned __int8)*v9;
            }
          }
        }
      }
    }
  }
  v13[1] = (const char *)v5;
  v13[3] = 0;
  return do_sym(a1, a2, a5, a4, v13, 0);
}

//----- (080AA720) --------------------------------------------------------
int (*__usercall dl_sym@<eax>(
        unsigned int a1@<eax>,
        unsigned __int8 *a2@<edx>,
        unsigned int a3@<ecx>,
        long double a4@<st0>))(void)
{
  return do_sym(a1, a2, a3, a4, 0, 2);
}

//----- (080AA730) --------------------------------------------------------
__int64 __cdecl _strtoll_internal(unsigned __int8 *a1, _DWORD *a2, int a3, int a4)
{
  return ___strtoll_l_internal(a1, a2, a3, a4, __readgsdword(0xFFFFFFDC));
}

//----- (080AA760) --------------------------------------------------------
__int64 __cdecl strtoq(unsigned __int8 *a1, _DWORD *a2, int a3)
{
  return ___strtoll_l_internal(a1, a2, a3, 0, __readgsdword(0xFFFFFFDC));
}

//----- (080AA790) --------------------------------------------------------
int __cdecl _strtoull_internal(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4)
{
  return ___strtoull_l_internal(a1, a2, a3, a4, __readgsdword(0xFFFFFFDC));
}

//----- (080AA7C0) --------------------------------------------------------
int __cdecl strtouq(unsigned __int8 *a1, unsigned __int8 **a2, int a3)
{
  return ___strtoull_l_internal(a1, a2, a3, 0, __readgsdword(0xFFFFFFDC));
}

//----- (080AA7F0) --------------------------------------------------------
__int64 __cdecl ___strtoll_l_internal(unsigned __int8 *a1, _DWORD *a2, int a3, int a4, int a5)
{
  _BYTE *v5; // ebp
  int v6; // ecx
  unsigned __int8 v7; // al
  char *v8; // edx
  int v9; // ecx
  int v10; // eax
  int v11; // edi
  char *v12; // esi
  unsigned int v13; // eax
  unsigned __int8 v14; // dl
  int v15; // edx
  int v16; // ebx
  char *v17; // edx
  int v19; // edx
  unsigned int v20; // ecx
  char *v21; // ebx
  int i; // ecx
  int v23; // edx
  unsigned __int8 v24; // al
  int v25; // eax
  int v26; // eax
  unsigned __int8 v27; // cl
  int v28; // edx
  int v29; // ebx
  char *v30; // ecx
  int v31; // edx
  char *v32; // [esp+Ch] [ebp-50h]
  unsigned int v33; // [esp+10h] [ebp-4Ch]
  unsigned __int64 v34; // [esp+10h] [ebp-4Ch]
  unsigned __int8 *v35; // [esp+18h] [ebp-44h]
  char *v36; // [esp+18h] [ebp-44h]
  unsigned __int64 v37; // [esp+20h] [ebp-3Ch]
  int v38; // [esp+28h] [ebp-34h]
  int v39; // [esp+28h] [ebp-34h]
  unsigned __int8 v40; // [esp+2Fh] [ebp-2Dh]
  int v41; // [esp+30h] [ebp-2Ch]

  v5 = 0;
  v32 = 0;
  if ( a4 )
  {
    v19 = *(_DWORD *)(a5 + 4);
    v32 = *(char **)(v19 + 44);
    if ( (unsigned __int8)(*v32 - 1) > 0x7Du )
    {
      v32 = 0;
    }
    else
    {
      v5 = *(_BYTE **)(v19 + 40);
      if ( !*v5 )
      {
        v32 = 0;
        v5 = 0;
      }
    }
  }
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    return 0LL;
  }
  v6 = *(_DWORD *)(a5 + 52);
  v35 = a1;
  v7 = *a1;
  if ( (*(_BYTE *)(v6 + 2 * (char)*a1 + 1) & 0x20) != 0 )
  {
    v8 = (char *)a1;
    do
      v7 = *++v8;
    while ( (*(_BYTE *)(v6 + 2 * *v8 + 1) & 0x20) != 0 );
    v35 = (unsigned __int8 *)v8;
  }
  if ( !v7 )
  {
    v36 = (char *)a1;
    goto LABEL_55;
  }
  if ( v7 == 45 )
  {
    v36 = (char *)(v35 + 1);
    v41 = 1;
  }
  else
  {
    v41 = 0;
    v36 = (char *)&v35[v7 == 43];
  }
  v9 = (unsigned __int8)*v36;
  if ( (_BYTE)v9 == 48 )
  {
    if ( (a3 & 0xFFFFFFEF) == 0 )
    {
      if ( dword_80C1B40[v36[1]] == 88 )
      {
        v40 = 15;
        v11 = 0;
        v37 = 0xFFFFFFFFFFFFFFFLL;
        a3 = 16;
        v32 = 0;
        v9 = (unsigned __int8)v36[2];
        v36 += 2;
        v10 = 14;
        goto LABEL_15;
      }
      if ( !a3 )
      {
        a3 = 8;
        v9 = 48;
        v37 = 0x1FFFFFFFFFFFFFFFLL;
        v11 = 0;
        v40 = 7;
        v32 = 0;
        v33 = 0x1FFFFFFF;
        goto LABEL_17;
      }
    }
  }
  else if ( !a3 )
  {
    goto LABEL_37;
  }
  if ( a3 != 10 )
  {
    v32 = 0;
    v10 = a3 - 2;
    HIDWORD(v37) = dword_80D5C84[2 * a3 - 4];
    LODWORD(v37) = _strtol_ull_max_tab[2 * a3 - 4];
    v11 = 0;
    v40 = byte_80D5C3E[a3];
    goto LABEL_15;
  }
LABEL_37:
  if ( v32 )
  {
    v26 = strlen(v5);
    v11 = v26;
    if ( !v26 )
      goto LABEL_55;
    v27 = *v36;
    if ( *v36 == *v5 )
    {
      v28 = 0;
      do
      {
        if ( v26 == ++v28 )
          goto LABEL_55;
      }
      while ( v5[v28] == v36[v28] );
      v27 = *v36;
    }
    v29 = v27;
    if ( v27 )
    {
      v30 = v36;
      while ( 1 )
      {
        if ( (unsigned __int8)(v29 - 48) > 9u )
        {
          if ( *v30 == *v5 )
          {
            v31 = 0;
            while ( v26 != ++v31 )
            {
              if ( v5[v31] != v30[v31] )
              {
                v29 = (unsigned __int8)v29;
                goto LABEL_103;
              }
            }
          }
          else
          {
LABEL_103:
            if ( (byte_80C2440[2 * v29 + 1] & 4) == 0 || (int)dword_80C1B40[v29] > 64 )
            {
LABEL_100:
              v11 = v26;
              goto LABEL_101;
            }
          }
        }
        v29 = (unsigned __int8)*++v30;
        if ( !(_BYTE)v29 )
          goto LABEL_100;
      }
    }
    v30 = v36;
LABEL_101:
    v32 = (char *)_correctly_grouped_prefixmb((unsigned int)v36, (unsigned int)v30, v5, v32);
    v9 = (unsigned __int8)*v36;
    v40 = 5;
    v37 = 0x1999999999999999LL;
    v10 = 8;
    a3 = 10;
  }
  else
  {
    v40 = 5;
    v37 = 0x1999999999999999LL;
    v10 = 8;
    a3 = 10;
    v11 = 0;
  }
LABEL_15:
  v33 = _strtol_ul_max_tab[v10];
  if ( !(_BYTE)v9 || v32 == v36 )
    goto LABEL_55;
LABEL_17:
  v12 = v36;
  v13 = 0;
  while ( 1 )
  {
    v14 = v9 - 48;
    if ( (unsigned __int8)(v9 - 48) > 9u )
    {
      if ( v11 && *v5 == *v12 )
      {
        v15 = 0;
        while ( 1 )
        {
          v16 = v15 + 1;
          if ( v15 + 1 == v11 )
            break;
          if ( v5[++v15] != v12[v16] )
            goto LABEL_39;
        }
        v17 = &v12[v15];
        goto LABEL_25;
      }
LABEL_39:
      if ( (byte_80C2440[2 * v9 + 1] & 4) == 0 )
        goto LABEL_27;
      v14 = dword_80C1B40[v9] - 55;
    }
    if ( v14 >= a3 )
      goto LABEL_27;
    if ( v13 >= v33 )
      break;
    v13 = v14 + a3 * v13;
    v17 = v12;
LABEL_25:
    v12 = v17 + 1;
    v9 = (unsigned __int8)v17[1];
    if ( v17 + 1 == v32 || !(_BYTE)v9 )
    {
LABEL_27:
      v34 = v13;
      v38 = 0;
      goto LABEL_28;
    }
  }
  v34 = v13;
  v20 = v14;
  v21 = v12;
  v39 = 0;
LABEL_62:
  v34 = v20 + a3 * v34;
LABEL_63:
  for ( i = v39; ; i = 1 )
  {
    ++v12;
    v23 = (unsigned __int8)v21[1];
    if ( v12 == v32 || !(_BYTE)v23 )
      break;
    v24 = v23 - 48;
    if ( (unsigned __int8)(v23 - 48) > 9u )
    {
      if ( v11 && (_BYTE)v23 == *v5 )
      {
        v25 = 0;
        do
        {
          if ( ++v25 == v11 )
          {
            v12 = &v21[v11];
            v21 += v11;
            goto LABEL_63;
          }
        }
        while ( v5[v25] == v21[v25 + 1] );
        v23 = (unsigned __int8)v23;
      }
      if ( (byte_80C2440[2 * v23 + 1] & 4) == 0 )
        break;
      v24 = dword_80C1B40[v23] - 55;
    }
    if ( v24 >= a3 )
      break;
    if ( v34 <= v37 && (v37 != v34 || v24 <= v40) )
    {
      v39 = i;
      v21 = v12;
      v20 = v24;
      goto LABEL_62;
    }
    v21 = v12;
  }
  v38 = i;
LABEL_28:
  if ( v12 == v36 )
  {
LABEL_55:
    if ( !a2 )
      return 0LL;
    if ( v36 - (char *)a1 > 1 && dword_80C1B40[*(v36 - 1)] == 88 && *(v36 - 2) == 48 )
    {
      *a2 = v36 - 1;
      return 0LL;
    }
    else
    {
      *a2 = a1;
      return 0LL;
    }
  }
  if ( a2 )
    *a2 = v12;
  if ( v38 )
  {
    __writegsdword(0xFFFFFFE8, 0x22u);
    if ( v41 )
      return 0x8000000000000000LL;
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  if ( !v41 )
  {
    if ( (v34 & 0x8000000000000000LL) == 0LL )
      return v34;
    __writegsdword(0xFFFFFFE8, 0x22u);
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  if ( v34 > 0x8000000000000000LL )
  {
    __writegsdword(0xFFFFFFE8, 0x22u);
    return 0x8000000000000000LL;
  }
  return -(__int64)v34;
}
// 80C1B40: using guessed type _DWORD dword_80C1B40[256];
// 80C2440: using guessed type _BYTE byte_80C2440[512];
// 80CC7C0: using guessed type int _strtol_ul_max_tab[6];
// 80D5C80: using guessed type int _strtol_ull_max_tab[];
// 80D5C84: using guessed type int dword_80D5C84[69];

//----- (080AAEE0) --------------------------------------------------------
__int64 __cdecl strtoll_l(unsigned __int8 *a1, _DWORD *a2, int a3, int a4)
{
  return ___strtoll_l_internal(a1, a2, a3, 0, a4);
}

//----- (080AAF00) --------------------------------------------------------
int __cdecl ___strtoull_l_internal(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4, int a5)
{
  _BYTE *v5; // ebp
  int v6; // ecx
  unsigned __int8 v7; // al
  char *v8; // edx
  int v9; // ecx
  unsigned int v10; // edi
  char *v11; // ebx
  unsigned __int64 v12; // rax
  int v13; // edx
  int v14; // esi
  int v15; // edx
  unsigned int v16; // ecx
  int v17; // edx
  char *v18; // edi
  int v19; // ebx
  int v20; // esi
  unsigned __int64 v21; // rax
  char *i; // esi
  int v23; // ebx
  int v24; // ecx
  int v25; // eax
  unsigned __int8 v26; // cl
  int v27; // edx
  int v28; // ebx
  char *v29; // ecx
  int v30; // edx
  char *v32; // [esp+8h] [ebp-54h]
  int v33; // [esp+Ch] [ebp-50h]
  unsigned __int8 *v34; // [esp+10h] [ebp-4Ch]
  char *v35; // [esp+10h] [ebp-4Ch]
  unsigned __int64 v36; // [esp+18h] [ebp-44h]
  int v37; // [esp+20h] [ebp-3Ch]
  char *v38; // [esp+20h] [ebp-3Ch]
  int v39; // [esp+28h] [ebp-34h]
  int v40; // [esp+2Ch] [ebp-30h]
  unsigned __int8 v41; // [esp+37h] [ebp-25h]

  v5 = 0;
  v32 = 0;
  if ( a4 )
  {
    v15 = *(_DWORD *)(a5 + 4);
    v32 = *(char **)(v15 + 44);
    if ( (unsigned __int8)(*v32 - 1) > 0x7Du )
    {
      v32 = 0;
    }
    else
    {
      v5 = *(_BYTE **)(v15 + 40);
      if ( !*v5 )
      {
        v32 = 0;
        v5 = 0;
      }
    }
  }
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    LODWORD(v12) = 0;
    return v12;
  }
  v6 = *(_DWORD *)(a5 + 52);
  v34 = a1;
  v7 = *a1;
  if ( (*(_BYTE *)(v6 + 2 * (char)*a1 + 1) & 0x20) != 0 )
  {
    v8 = (char *)a1;
    do
      v7 = *++v8;
    while ( (*(_BYTE *)(v6 + 2 * *v8 + 1) & 0x20) != 0 );
    v34 = (unsigned __int8 *)v8;
  }
  if ( !v7 )
  {
    v35 = (char *)a1;
    goto LABEL_53;
  }
  if ( v7 == 45 )
  {
    v35 = (char *)(v34 + 1);
    v40 = 1;
  }
  else
  {
    v40 = 0;
    v35 = (char *)&v34[v7 == 43];
  }
  v9 = (unsigned __int8)*v35;
  if ( (_BYTE)v9 == 48 )
  {
    if ( (a3 & 0xFFFFFFEF) == 0 )
    {
      if ( dword_80C1B40[v35[1]] == 88 )
      {
        v37 = 14;
        a3 = 16;
        v39 = 0;
        v32 = 0;
        v9 = (unsigned __int8)v35[2];
        v35 += 2;
        goto LABEL_15;
      }
      if ( !a3 )
      {
        v10 = 0x1FFFFFFF;
        a3 = 8;
        v9 = 48;
        v37 = 6;
        v39 = 0;
        v32 = 0;
        goto LABEL_17;
      }
    }
  }
  else if ( !a3 )
  {
    goto LABEL_36;
  }
  if ( a3 != 10 )
  {
    v39 = 0;
    v32 = 0;
    v37 = a3 - 2;
    goto LABEL_15;
  }
LABEL_36:
  if ( v32 )
  {
    v25 = strlen(v5);
    v39 = v25;
    if ( !v25 )
      goto LABEL_53;
    v26 = *v35;
    if ( *v35 == *v5 )
    {
      v27 = 0;
      do
      {
        if ( v25 == ++v27 )
          goto LABEL_53;
      }
      while ( v5[v27] == v35[v27] );
      v26 = *v35;
    }
    v28 = v26;
    if ( v26 )
    {
      v29 = v35;
      while ( 1 )
      {
        if ( (unsigned __int8)(v28 - 48) > 9u )
        {
          if ( *v5 == *v29 )
          {
            v30 = 0;
            while ( v25 != ++v30 )
            {
              if ( v5[v30] != v29[v30] )
              {
                v28 = (unsigned __int8)v28;
                goto LABEL_97;
              }
            }
          }
          else
          {
LABEL_97:
            if ( (byte_80C2440[2 * v28 + 1] & 4) == 0 || (int)dword_80C1B40[v28] > 64 )
              goto LABEL_95;
          }
        }
        v28 = (unsigned __int8)*++v29;
        if ( !(_BYTE)v28 )
          goto LABEL_95;
      }
    }
    v29 = v35;
LABEL_95:
    v32 = (char *)_correctly_grouped_prefixmb((unsigned int)v35, (unsigned int)v29, v5, v32);
    v9 = (unsigned __int8)*v35;
    v37 = 8;
    a3 = 10;
  }
  else
  {
    v37 = 8;
    a3 = 10;
    v39 = 0;
  }
LABEL_15:
  v10 = _strtol_ul_max_tab[v37];
  if ( !(_BYTE)v9 || v32 == v35 )
    goto LABEL_53;
LABEL_17:
  v11 = v35;
  LODWORD(v12) = 0;
  while ( 1 )
  {
    BYTE4(v12) = v9 - 48;
    if ( (unsigned __int8)(v9 - 48) > 9u )
    {
      if ( v39 && *v5 == *v11 )
      {
        v13 = 0;
        while ( 1 )
        {
          v14 = v13 + 1;
          if ( v13 + 1 == v39 )
            break;
          ++v13;
          if ( v5[v14] != v11[v14] )
          {
            v9 = (unsigned __int8)v9;
            goto LABEL_39;
          }
        }
        HIDWORD(v12) = &v11[v13];
        goto LABEL_25;
      }
LABEL_39:
      if ( (byte_80C2440[2 * v9 + 1] & 4) == 0 )
        goto LABEL_27;
      BYTE4(v12) = dword_80C1B40[v9] - 55;
    }
    if ( BYTE4(v12) >= a3 )
      goto LABEL_27;
    if ( (unsigned int)v12 >= v10 )
      break;
    LODWORD(v12) = BYTE4(v12) + a3 * v12;
    HIDWORD(v12) = v11;
LABEL_25:
    v11 = (char *)(HIDWORD(v12) + 1);
    v9 = *(unsigned __int8 *)(HIDWORD(v12) + 1);
    if ( (char *)(HIDWORD(v12) + 1) == v32 || !(_BYTE)v9 )
    {
LABEL_27:
      HIDWORD(v12) = 0;
      v33 = 0;
      goto LABEL_28;
    }
  }
  v16 = BYTE4(v12);
  v17 = v37;
  v33 = 0;
  v38 = v11;
  HIDWORD(v36) = dword_80D5C84[2 * v17];
  LODWORD(v36) = _strtol_ull_max_tab[2 * v17];
  v41 = _strtol_ull_rem_tab[v17];
  HIDWORD(v12) = 0;
  v18 = v11;
LABEL_58:
  v19 = HIDWORD(v12) * a3;
  v20 = v12 * (a3 >> 31);
  v21 = (unsigned int)a3 * (unsigned __int64)(unsigned int)v12;
  HIDWORD(v21) += v20 + v19;
  v12 = v16 + v21;
LABEL_59:
  for ( i = v38; ; i = v18 )
  {
    ++v18;
    v23 = (unsigned __int8)i[1];
    if ( v18 == v32 || !(_BYTE)v23 )
      break;
    LOBYTE(v16) = v23 - 48;
    if ( (unsigned __int8)(v23 - 48) > 9u )
    {
      if ( v39 && (_BYTE)v23 == *v5 )
      {
        v24 = 0;
        while ( ++v24 != v39 )
        {
          if ( v5[v24] != i[v24 + 1] )
            goto LABEL_68;
        }
        v18 = &i[v39];
        i += v39;
        goto LABEL_59;
      }
LABEL_68:
      if ( (byte_80C2440[2 * v23 + 1] & 4) == 0 )
        break;
      LOBYTE(v16) = dword_80C1B40[v23] - 55;
    }
    if ( (unsigned __int8)v16 >= a3 )
      break;
    if ( v36 >= v12 && (v12 != v36 || (unsigned __int8)v16 <= v41) )
    {
      v16 = (unsigned __int8)v16;
      v38 = v18;
      goto LABEL_58;
    }
    v33 = 1;
  }
  v11 = v18;
LABEL_28:
  if ( v11 == v35 )
  {
LABEL_53:
    if ( a2 )
    {
      if ( v35 - (char *)a1 > 1 && dword_80C1B40[*(v35 - 1)] == 88 && *(v35 - 2) == 48 )
      {
        *a2 = (unsigned __int8 *)(v35 - 1);
        LODWORD(v12) = 0;
      }
      else
      {
        *a2 = a1;
        LODWORD(v12) = 0;
      }
    }
    else
    {
      LODWORD(v12) = 0;
    }
    return v12;
  }
  if ( a2 )
    *a2 = (unsigned __int8 *)v11;
  if ( v33 )
  {
    __writegsdword(0xFFFFFFE8, 0x22u);
    LODWORD(v12) = -1;
  }
  else if ( v40 )
  {
    return -(__int64)v12;
  }
  return v12;
}
// 80C1B40: using guessed type _DWORD dword_80C1B40[256];
// 80C2440: using guessed type _BYTE byte_80C2440[512];
// 80CC7C0: using guessed type int _strtol_ul_max_tab[6];
// 80D5C80: using guessed type int _strtol_ull_max_tab[];
// 80D5C84: using guessed type int dword_80D5C84[69];

//----- (080AB530) --------------------------------------------------------
int __cdecl strtoull_l(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4)
{
  return ___strtoull_l_internal(a1, a2, a3, 0, a4);
}

//----- (080AB550) --------------------------------------------------------
void __cdecl _strtof_internal(unsigned int a1, _DWORD *a2, int a3)
{
  ___strtof_l_internal(a1, a2, a3, (_DWORD *)__readgsdword(0xFFFFFFDC));
}

//----- (080AB570) --------------------------------------------------------
void __cdecl strtof(unsigned int a1, _DWORD *a2)
{
  ___strtof_l_internal(a1, a2, 0, (_DWORD *)__readgsdword(0xFFFFFFDC));
}

//----- (080AB590) --------------------------------------------------------
void __cdecl _strtod_internal(unsigned int a1, _DWORD *a2, int a3)
{
  ___strtod_l_internal(a1, a2, a3, (_DWORD *)__readgsdword(0xFFFFFFDC));
}

//----- (080AB5B0) --------------------------------------------------------
void __cdecl strtod(unsigned int a1, _DWORD *a2)
{
  ___strtod_l_internal(a1, a2, 0, (_DWORD *)__readgsdword(0xFFFFFFDC));
}

//----- (080AB5D0) --------------------------------------------------------
void __cdecl _strtold_internal(unsigned int a1, _DWORD *a2, int a3)
{
  ___strtold_l_internal(a1, a2, a3, (_DWORD *)__readgsdword(0xFFFFFFDC));
}

//----- (080AB5F0) --------------------------------------------------------
void __cdecl strtold(unsigned int a1, _DWORD *a2)
{
  ___strtold_l_internal(a1, a2, 0, (_DWORD *)__readgsdword(0xFFFFFFDC));
}

//----- (080AB610) --------------------------------------------------------
int __usercall round_away@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4, int a5)
{
  int result; // eax
  bool v6; // zf
  int v7; // edx

  if ( a5 == 1024 )
  {
    v6 = a1 == 0;
    result = 0;
    if ( !v6 )
      return a3 | a4;
  }
  else if ( a5 <= 1024 )
  {
    if ( a5 )
      goto LABEL_13;
    v7 = a4 | a2;
    result = 0;
    if ( (_BYTE)a3 )
      return v7;
  }
  else
  {
    if ( a5 != 2048 )
    {
      result = 0;
      if ( a5 == 3072 )
        return result;
LABEL_13:
      abort(a3);
    }
    v6 = a1 == 0;
    result = 0;
    if ( v6 )
      return a3 | a4;
  }
  return result;
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080AB690) --------------------------------------------------------
long double __usercall round_and_return@<st0>(
        unsigned int *a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        int a4,
        unsigned int a5,
        char a6,
        int a7)
{
  int v7; // edi
  int v8; // esi
  __int16 v10; // ax
  int v11; // ebp
  bool v12; // cc
  long double v13; // fst7
  unsigned int v16; // edi
  bool v17; // si
  int v18; // edx
  unsigned int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // ecx
  int v23; // edi
  int v24; // kr00_4
  int v25; // eax
  bool v26; // [esp+4h] [ebp-38h]
  int v27; // [esp+8h] [ebp-34h]
  unsigned int v28; // [esp+Ch] [ebp-30h]
  __int16 v29; // [esp+1Ch] [ebp-20h]

  v7 = a3;
  v8 = a2;
  v10 = v29 & 0xC00;
  if ( (v29 & 0xC00) == 1024 )
  {
    v11 = 1024;
    goto LABEL_5;
  }
  if ( (v29 & 0xC00u) <= 0x400 )
  {
    v11 = 0;
    if ( !v10 )
      goto LABEL_5;
LABEL_20:
    abort(a3);
  }
  if ( v10 == 2048 )
  {
    v12 = a3 < -1;
    v11 = 2048;
    if ( a3 > -1 )
      goto LABEL_39;
    goto LABEL_11;
  }
  v11 = 3072;
  if ( v10 != 3072 )
    goto LABEL_20;
LABEL_5:
  v12 = a3 < -1;
  if ( a3 > -1 )
  {
LABEL_39:
    if ( __SPAIR64__(a3, a2) > 128 )
      goto LABEL_7;
    v26 = a4 != 0;
    v27 = (a5 >> a6) & 1;
    v28 = *a1;
    v18 = *a1 & 1;
    goto LABEL_31;
  }
LABEL_11:
  if ( v12 )
    goto LABEL_24;
  if ( a2 >= 0xFFFFFF82 )
    goto LABEL_39;
  if ( a3 < -1 || a2 < 0xFFFFFF6A )
  {
LABEL_24:
    v13 = 1.1754944e-38;
    __writegsdword(0xFFFFFFE8, 0x22u);
    if ( a4 )
      return (float)(1.1754944e-38 * -1.1754944e-38);
    return (float)(v13 * v13);
  }
  v16 = -126 - a2;
  a7 |= (((1 << a6) - 1) & a5) != 0;
  if ( a2 == -150 )
  {
    v19 = *a1;
    *a1 = 0;
    v28 = 0;
    a6 = 23;
    a5 = v19;
    v26 = a4 != 0;
    v18 = 0;
    v17 = a7 != 0;
  }
  else
  {
    if ( v16 == 1 )
    {
      v17 = a7 != 0;
      v22 = (a5 >> a6) & 1;
      a5 = *a1;
      v27 = *a1 & 1;
      v26 = a4 != 0;
      if ( (unsigned __int8)round_away(a4 != 0, v27, v22, a7 != 0, v11) )
      {
        _mpn_rshift((int)a1, a1, 1, 1);
        v28 = *a1;
        if ( ((a5 + 1) & 0x1000000) != 0 )
        {
          a6 = 0;
          v8 = -127;
          v18 = *a1 & 1;
          v7 = -1;
          goto LABEL_31;
        }
        a6 = 0;
        v18 = *a1 & 1;
        goto LABEL_27;
      }
    }
    else
    {
      a5 = *a1;
      v26 = a4 != 0;
      v17 = a7 != 0;
    }
    a6 = v16 - 1;
    _mpn_rshift((int)a1, a1, 1, v16);
    v28 = *a1;
    v18 = *a1 & 1;
  }
LABEL_27:
  v27 = (a5 >> a6) & 1;
  if ( !v27 && !v17 )
  {
    v20 = a5 & ((1 << a6) - 1);
    if ( !v20 )
    {
      v27 = 0;
      v8 = -127;
      v7 = -1;
      goto LABEL_33;
    }
  }
  __writegsdword(0xFFFFFFE8, 0x22u);
  v8 = -127;
  v7 = -1;
LABEL_31:
  v21 = 1;
  if ( !a7 )
  {
    v20 = a5 & ((1 << a6) - 1);
LABEL_33:
    v21 = v20 != 0;
  }
  if ( (unsigned __int8)round_away(v26, v18, v27, v21, v11) )
  {
    *a1 = v28 + 1;
    if ( ((v28 + 1) & 0x1000000) == 0 )
    {
      if ( !(v8 ^ 0xFFFFFF81 | ~v7) )
        LOBYTE(v8) = (((v28 + 1) & 0x800000) != 0) - 127;
      return _mpn_construct_float(a1, v8, a4);
    }
    v24 = v8 + 1;
    v23 = (__PAIR64__(v7, v8) + 1) >> 32;
    LOBYTE(v8) = v8 + 1;
    _mpn_rshift((int)a1, a1, 1, 1);
    v25 = v24;
    *a1 |= 0x800000u;
    LOBYTE(v25) = v24 ^ 0x81;
    if ( !(v25 | v23) )
    {
LABEL_7:
      v13 = 3.4028235e38;
      __writegsdword(0xFFFFFFE8, 0x22u);
      if ( a4 )
        return (float)(3.4028235e38 * -3.4028235e38);
      return (float)(v13 * v13);
    }
  }
  return _mpn_construct_float(a1, v8, a4);
}
// 80AB730: conditional instruction was optimized away because ecx.4<0
// 80AB6A6: variable 'v29' is possibly undefined
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080ABA70) --------------------------------------------------------
char *__usercall str_to_mpn_isra_0@<eax>(
        char *a1@<eax>,
        int a2@<edx>,
        int *a3@<ecx>,
        int *a4,
        unsigned int *a5,
        int a6,
        _BYTE *a7)
{
  int v9; // esi
  int v10; // ecx
  int v11; // eax
  bool v12; // zf
  char v13; // al
  int v14; // eax
  char v15; // dl
  int v16; // eax
  int v17; // edx
  _BOOL4 v18; // ecx
  int v19; // esi
  int v20; // edx
  int v21; // ecx
  int v22; // eax
  int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // eax
  int v27; // eax
  int v28; // edx
  _BOOL4 v29; // ecx
  int v30; // edx
  int v31; // eax
  int v32; // edx
  int v33; // edx
  int v34; // ecx
  int v35; // edi
  int v36; // [esp+0h] [ebp-2Ch]
  unsigned int v37; // [esp+0h] [ebp-2Ch]
  int v38; // [esp+4h] [ebp-28h]

  v36 = a2;
  *a4 = 0;
  if ( a2 <= 0 )
    _assert_fail("digcnt > 0", "strtod_l.c", 352, "str_to_mpn");
  v38 = 0;
  v9 = 0;
  v10 = 0;
  while ( 1 )
  {
    v11 = *a1;
    if ( (unsigned __int8)(v11 - 48) <= 9u )
      goto LABEL_7;
    if ( !a7 || (_BYTE)v11 != *a7 )
    {
LABEL_6:
      a1 += a6;
      v11 = *a1;
      goto LABEL_7;
    }
    v13 = a7[1];
    if ( v13 )
    {
      if ( a1[1] != v13 )
        goto LABEL_6;
      v14 = 1;
      while ( 1 )
      {
        v15 = a7[++v14];
        if ( !v15 )
          break;
        if ( a1[v14] != v15 )
          goto LABEL_6;
      }
    }
    else
    {
      v14 = 1;
    }
    a1 += v14;
    v11 = *a1;
LABEL_7:
    ++a1;
    ++v10;
    v12 = v36-- == 1;
    v9 = v11 + 10 * v9 - 48;
    if ( v12 )
      break;
    if ( v10 == 9 )
    {
      if ( v38 )
      {
        v16 = _mpn_mul_1((int)a3, (int)a3, v38, 0x3B9ACA00u);
        v17 = *a4;
        v18 = __CFADD__(*a3, v9);
        *a3 += v9;
        if ( v18 )
        {
          v19 = v17 - 1;
          v20 = 0;
          while ( v19 != v20 )
          {
            v21 = a3[v20 + 1] + 1;
            a3[++v20] = v21;
            if ( v21 )
              goto LABEL_24;
          }
          v12 = v16 == -1;
          v9 = v16 + 1;
          v22 = *a4;
          if ( v12 )
            goto LABEL_25;
LABEL_22:
          if ( v22 > 17 )
            _assert_fail("*nsize < MPNSIZE", "strtod_l.c", 369, "str_to_mpn");
          a3[v22] = v9;
          v10 = 0;
          v23 = *a4 + 1;
          *a4 = v23;
          v38 = v23;
          v9 = 0;
        }
        else
        {
LABEL_24:
          v12 = v16 == 0;
          v9 = v16;
          v22 = *a4;
          if ( !v12 )
            goto LABEL_22;
LABEL_25:
          v38 = v22;
          v10 = 0;
        }
      }
      else
      {
        *a3 = v9;
        v10 = 0;
        v38 = 1;
        v9 = 0;
        *a4 = 1;
      }
    }
  }
  v37 = *a5;
  v24 = a5[1];
  if ( __SPAIR64__(v24, v37) <= 0 || __SPAIR64__(v24, v37) > 9 - v10 )
  {
    v25 = tens_in_limb[v10];
    if ( v38 )
      goto LABEL_32;
    goto LABEL_29;
  }
  v9 *= tens_in_limb[v37];
  v25 = tens_in_limb[v37 + v10];
  *a5 = 0;
  a5[1] = 0;
  if ( !v38 )
  {
LABEL_29:
    *a3 = v9;
    *a4 = 1;
    return a1;
  }
LABEL_32:
  v27 = _mpn_mul_1((int)a3, (int)a3, v38, v25);
  v28 = *a4;
  v29 = __CFADD__(*a3, v9);
  *a3 += v9;
  if ( v29 )
  {
    v33 = v28 - 1;
    v34 = 0;
    while ( v33 != v34 )
    {
      v35 = a3[v34 + 1];
      a3[++v34] = v35 + 1;
      if ( v35 != -1 )
        goto LABEL_33;
    }
    v30 = 1;
  }
  else
  {
LABEL_33:
    v30 = 0;
  }
  v31 = v30 + v27;
  if ( !v31 )
    return a1;
  v32 = *a4;
  if ( *a4 > 17 )
    _assert_fail("*nsize < MPNSIZE", "strtod_l.c", 425, "str_to_mpn");
  *a4 = v32 + 1;
  a3[v32] = v31;
  return a1;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80D6200: using guessed type int tens_in_limb[10];

//----- (080ABD80) --------------------------------------------------------
long double __cdecl ___strtof_l_internal(unsigned int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // eax
  unsigned int i; // edx
  int v6; // ecx
  char *v7; // ebx
  int v8; // eax
  int v9; // edx
  char v10; // cl
  int v11; // esi
  char *j; // ebp
  char v13; // di
  char *v14; // esi
  char v15; // bl
  int v16; // eax
  char v17; // dl
  int v18; // eax
  char *k; // eax
  int v20; // eax
  long double result; // fst7
  int v22; // edx
  int v23; // esi
  char *v24; // edi
  unsigned int v25; // eax
  char *v26; // ecx
  unsigned int v27; // edx
  int v28; // eax
  char v29; // cl
  int v30; // ebx
  int v31; // eax
  int v32; // ecx
  char v33; // cl
  unsigned int v34; // edx
  int v35; // esi
  unsigned int v36; // ebx
  char v37; // al
  char v38; // bl
  int v39; // eax
  char v40; // dl
  unsigned int v41; // edi
  unsigned int v42; // esi
  __int64 v43; // rax
  signed __int64 v44; // rax
  long double v45; // fst7
  long double v46; // fst7
  char *v47; // eax
  int v48; // edx
  int v49; // ebx
  _BYTE *v50; // ecx
  __int64 v51; // kr08_8
  __int64 v52; // rax
  _BYTE *v53; // ecx
  long double v54; // fst7
  long double v55; // fst7
  int v56; // eax
  char v57; // cl
  int v58; // eax
  int v59; // ebx
  int v60; // edi
  int v61; // esi
  int v62; // ebx
  __int64 v63; // rax
  unsigned int v64; // eax
  __int64 v65; // rax
  _BYTE *v66; // esi
  _BYTE *v67; // ebx
  long double v68; // fst6
  int v69; // eax
  char v70; // cl
  unsigned __int8 *v71; // esi
  int v72; // edx
  int v73; // ecx
  char m; // al
  int v75; // edx
  _BYTE *v76; // eax
  unsigned int v77; // ebp
  unsigned __int64 v78; // rcx
  __int64 v79; // rax
  int v80; // eax
  unsigned int *v81; // ecx
  _DWORD *v82; // esi
  int v83; // ebx
  int v84; // edi
  int v85; // ebp
  int v86; // eax
  int *v87; // eax
  unsigned int v88; // ebx
  unsigned int v89; // ebx
  int v90; // eax
  int v91; // ebx
  int v92; // ebp
  int v93; // ebx
  char v94; // di
  unsigned int v95; // esi
  int v96; // edi
  unsigned int v97; // esi
  int v98; // edi
  int v99; // ebx
  unsigned int v100; // ebp
  char v101; // cl
  int v102; // ecx
  unsigned int v103; // edx
  unsigned int v104; // edx
  unsigned int v105; // ebp
  _BYTE *v106; // ecx
  _BYTE *v107; // eax
  int v108; // eax
  char *v109; // edi
  int v110; // ebp
  char v111; // dl
  bool v112; // zf
  long double v113; // fst6
  int v114; // edi
  _DWORD *v115; // esi
  int v116; // ebp
  int v117; // ebx
  int v118; // eax
  int *v119; // ebx
  unsigned int v120; // ebp
  int v121; // eax
  int v122; // esi
  int v123; // eax
  int v124; // ebx
  __int64 *v125; // eax
  int *v126; // eax
  int v127; // ebx
  unsigned __int8 *v128; // edx
  unsigned int v129; // esi
  unsigned int v130; // ebx
  unsigned int v131; // eax
  unsigned int v132; // ecx
  bool v133; // cf
  int v134; // ebx
  char *v135; // eax
  int v136; // edx
  unsigned int v137; // ebx
  signed int v138; // eax
  int v139; // ebx
  unsigned __int64 v140; // rax
  unsigned __int64 v141; // rtt
  unsigned int v142; // ebx
  signed int v143; // ebx
  char v144; // di
  unsigned int v145; // ebx
  char v146; // di
  unsigned int v147; // esi
  unsigned __int64 v148; // rt2
  int v149; // ebp
  unsigned int v150; // eax
  int v151; // eax
  char v152; // si
  int v153; // esi
  unsigned int v154; // ebx
  int v155; // eax
  int v156; // eax
  int v157; // eax
  unsigned int v158; // ebx
  int v159; // ebp
  unsigned __int8 *v160; // eax
  unsigned int v161; // edx
  unsigned int v162; // eax
  char v163; // di
  signed int v164; // eax
  unsigned int v165; // edx
  int v166; // edx
  unsigned int v167; // edi
  long double v168; // fst7
  int v169; // [esp+0h] [ebp-11Ch]
  int v170; // [esp+0h] [ebp-11Ch]
  int v171; // [esp+0h] [ebp-11Ch]
  int *v172; // [esp+0h] [ebp-11Ch]
  unsigned int v173; // [esp+0h] [ebp-11Ch]
  __int64 v174; // [esp+0h] [ebp-11Ch]
  unsigned int v175; // [esp+0h] [ebp-11Ch]
  unsigned int v176; // [esp+0h] [ebp-11Ch]
  char v177; // [esp+0h] [ebp-11Ch]
  char v178; // [esp+8h] [ebp-114h]
  char v179; // [esp+8h] [ebp-114h]
  char *v180; // [esp+8h] [ebp-114h]
  unsigned int v181; // [esp+8h] [ebp-114h]
  __int64 v182; // [esp+8h] [ebp-114h]
  _BYTE *v183; // [esp+8h] [ebp-114h]
  int v184; // [esp+8h] [ebp-114h]
  unsigned int *v185; // [esp+8h] [ebp-114h]
  unsigned int *v186; // [esp+8h] [ebp-114h]
  __int64 v187; // [esp+8h] [ebp-114h]
  unsigned __int64 v188; // [esp+8h] [ebp-114h]
  bool v189; // [esp+8h] [ebp-114h]
  __int64 v190; // [esp+8h] [ebp-114h]
  int v191; // [esp+10h] [ebp-10Ch]
  int v192; // [esp+10h] [ebp-10Ch]
  int v193; // [esp+10h] [ebp-10Ch]
  __int64 v194; // [esp+10h] [ebp-10Ch]
  int *v195; // [esp+10h] [ebp-10Ch]
  unsigned __int8 *v196; // [esp+10h] [ebp-10Ch]
  int v197; // [esp+10h] [ebp-10Ch]
  unsigned int v198; // [esp+10h] [ebp-10Ch]
  unsigned __int64 v199; // [esp+18h] [ebp-104h]
  signed int v200; // [esp+18h] [ebp-104h]
  __int64 v201; // [esp+18h] [ebp-104h]
  char *v202; // [esp+20h] [ebp-FCh]
  __int64 v203; // [esp+20h] [ebp-FCh]
  int v204; // [esp+20h] [ebp-FCh]
  signed int v205; // [esp+20h] [ebp-FCh]
  unsigned int *n; // [esp+20h] [ebp-FCh]
  unsigned int v207; // [esp+28h] [ebp-F4h]
  char *v208; // [esp+28h] [ebp-F4h]
  int v209; // [esp+28h] [ebp-F4h]
  char *v210; // [esp+2Ch] [ebp-F0h]
  char *v211; // [esp+30h] [ebp-ECh]
  unsigned int v212; // [esp+34h] [ebp-E8h]
  int v213; // [esp+38h] [ebp-E4h]
  int v214; // [esp+3Ch] [ebp-E0h]
  __int64 v215; // [esp+40h] [ebp-DCh]
  char v216; // [esp+40h] [ebp-DCh]
  char *v217; // [esp+40h] [ebp-DCh]
  unsigned int v218; // [esp+40h] [ebp-DCh]
  bool v219; // [esp+48h] [ebp-D4h]
  int v220; // [esp+48h] [ebp-D4h]
  char *v221; // [esp+48h] [ebp-D4h]
  int v222; // [esp+4Ch] [ebp-D0h]
  char *v223; // [esp+58h] [ebp-C4h]
  int v224; // [esp+60h] [ebp-BCh] BYREF
  int v225; // [esp+64h] [ebp-B8h] BYREF
  __int64 v226; // [esp+68h] [ebp-B4h] BYREF
  unsigned int v227; // [esp+70h] [ebp-ACh] BYREF
  int v228[17]; // [esp+74h] [ebp-A8h]
  int v229; // [esp+B8h] [ebp-64h] BYREF
  unsigned int v230; // [esp+BCh] [ebp-60h]

  v202 = 0;
  v211 = 0;
  v4 = (_DWORD *)a4[1];
  if ( a3 )
  {
    v202 = (char *)v4[11];
    if ( (unsigned __int8)(*v202 - 1) > 0x7Du )
    {
      v202 = 0;
    }
    else
    {
      v211 = (char *)v4[10];
      if ( !*v211 )
      {
        v202 = 0;
        v211 = 0;
      }
    }
  }
  v210 = (char *)v4[9];
  v213 = strlen(v210);
  if ( !v213 )
    _assert_fail("decimal_len > 0", "strtod_l.c", 570, "____strtof_l_internal");
  v226 = 0LL;
  for ( i = a1 - 1; ; ++i )
  {
    v6 = *(char *)(i + 1);
    v7 = (char *)(i + 1);
    v8 = v6;
    if ( (*(_BYTE *)(a4[13] + 2 * v6 + 1) & 0x20) == 0 )
      break;
  }
  if ( (_BYTE)v6 == 45 )
  {
    v8 = *(char *)(i + 2);
    v214 = 1;
    v7 = (char *)(i + 2);
  }
  else
  {
    v214 = 0;
    if ( (_BYTE)v6 == 43 )
    {
      v8 = *(char *)(i + 2);
      v7 = (char *)(i + 2);
    }
  }
  v178 = *v210;
  if ( !*v210 )
  {
    v11 = 0;
    goto LABEL_14;
  }
  if ( *v210 == *v7 )
  {
    v9 = 0;
    while ( 1 )
    {
      v10 = v210[++v9];
      v11 = v9;
      if ( !v10 )
        break;
      if ( v10 != v7[v9] )
        goto LABEL_28;
    }
LABEL_14:
    if ( (unsigned __int8)(v7[v11] - 48) <= 9u )
      goto LABEL_15;
  }
LABEL_28:
  if ( (unsigned __int8)(v8 - 48) > 9u )
  {
    v20 = dword_80C1540[v8];
    if ( (_BYTE)v20 == 105 )
    {
      if ( !j_strncasecmp_l(v7, &unk_80CCFA7, 3, nl_C_locobj) )
      {
        if ( a2 )
        {
          v66 = v7 + 3;
          v67 = v7 + 8;
          if ( !j_strncasecmp_l(v66, "inity", 5, nl_C_locobj) )
            v66 = v67;
          *a2 = v66;
        }
        v68 = -INFINITY;
        if ( !v214 )
          return INFINITY;
        return v68;
      }
    }
    else if ( (_BYTE)v20 == 110 && !j_strncasecmp_l(v7, &unk_80CCFA3, 3, nl_C_locobj) )
    {
      v71 = (unsigned __int8 *)(v7 + 3);
      result = NAN;
      if ( v7[3] == 40 )
      {
        result = _strtof_nan((unsigned __int8 *)v7 + 4, (unsigned __int8 **)&v229, 41);
        if ( *(_BYTE *)v229 == 41 )
          v71 = (unsigned __int8 *)(v229 + 1);
      }
      if ( a2 )
        *a2 = v71;
      return result;
    }
    goto LABEL_31;
  }
LABEL_15:
  if ( (_BYTE)v8 == 48 )
  {
    v22 = v7[1];
    v191 = a4[14];
    if ( *(_DWORD *)(v191 + 4 * v22) == 120 )
    {
      j = v7 + 2;
      LOBYTE(v8) = v7[2];
      if ( !v211 )
      {
        if ( (_BYTE)v8 != 48 )
        {
          v202 = 0;
          v7 += 2;
          v22 = (char)v8;
          v169 = 16;
          goto LABEL_36;
        }
        v22 = v7[3];
        v202 = 0;
        v7 += 2;
        v169 = 16;
        goto LABEL_137;
      }
      v7 += 2;
      v202 = 0;
      v169 = 16;
    }
    else
    {
      v169 = 10;
      if ( !v211 )
      {
LABEL_137:
        for ( j = v7; ; v22 = j[1] )
        {
          ++j;
          if ( (_BYTE)v22 != 48 )
            break;
        }
        goto LABEL_36;
      }
    }
LABEL_18:
    j = v7;
    v13 = *v211;
    v14 = v7;
    v15 = v8;
    if ( (_BYTE)v8 == 48 )
      goto LABEL_27;
    while ( 1 )
    {
      if ( v13 )
      {
        if ( *j != v13 )
        {
LABEL_35:
          v22 = v15;
          v7 = v14;
          goto LABEL_36;
        }
        v16 = 0;
        while ( 1 )
        {
          v17 = v211[++v16];
          if ( !v17 )
            break;
          if ( v17 != j[v16] )
            goto LABEL_35;
        }
        v18 = v16 - 1;
      }
      else
      {
        v18 = -1;
      }
      for ( k = &j[v18]; ; k = j )
      {
        v15 = k[1];
        j = k + 1;
        if ( v15 != 48 )
          break;
LABEL_27:
        ;
      }
    }
  }
  if ( v211 )
  {
    v169 = 10;
    v191 = a4[14];
    goto LABEL_18;
  }
  v22 = (char)v8;
  j = v7;
  v169 = 10;
  v191 = a4[14];
LABEL_36:
  if ( (unsigned __int8)(v22 - 48) <= 9u )
    goto LABEL_111;
  v23 = *(_DWORD *)(v191 + 4 * (char)v22);
  if ( (unsigned __int8)(v23 - 97) > 5u || (v24 = j, LODWORD(v199) = 0, v169 != 16) )
  {
    if ( v178 )
    {
      if ( *j != v178 )
      {
LABEL_168:
        if ( v169 != 16 || (_BYTE)v23 != 112 || j == v7 )
          goto LABEL_169;
        goto LABEL_111;
      }
      v56 = 0;
      while ( 1 )
      {
        v57 = v210[++v56];
        if ( !v57 )
          break;
        if ( v57 != j[v56] )
          goto LABEL_168;
      }
    }
    if ( v169 == 16 && j == v7 )
    {
      v58 = j[v213];
      if ( (unsigned __int8)(v58 - 48) > 9u && (unsigned __int8)(*(_BYTE *)(v191 + 4 * v58) - 97) > 5u )
      {
LABEL_169:
        if ( v169 != 16 )
        {
          v24 = j;
          LODWORD(v199) = 0;
          if ( (_BYTE)v23 == 101 )
            goto LABEL_39;
        }
        v64 = _correctly_grouped_prefixmb((unsigned int)v7, (unsigned int)j, v211, v202);
        if ( a2 )
        {
          if ( (char *)v64 == v7 )
          {
            v64 = (unsigned int)(j - 1);
            if ( v169 != 16 )
              v64 = a1;
          }
          *a2 = v64;
        }
        goto LABEL_54;
      }
    }
LABEL_111:
    v24 = j;
    LODWORD(v199) = 0;
    goto LABEL_39;
  }
  while ( 1 )
  {
LABEL_39:
    if ( (unsigned __int8)(v22 - 48) <= 9u
      || v169 == 16 && (unsigned __int8)(*(_BYTE *)(v191 + 4 * (char)v22) - 97) <= 5u )
    {
      LODWORD(v199) = v199 + 1;
      v47 = v24;
      goto LABEL_108;
    }
    if ( !v211 )
      break;
    if ( !*v211 )
    {
      v47 = v24 - 1;
      goto LABEL_108;
    }
    if ( *v24 != *v211 )
      break;
    v69 = 0;
    while ( 1 )
    {
      v70 = v211[++v69];
      if ( !v70 )
        break;
      if ( v70 != v24[v69] )
        goto LABEL_42;
    }
    v47 = &v24[v69 - 1];
LABEL_108:
    v24 = v47 + 1;
    v22 = v47[1];
  }
LABEL_42:
  if ( v24 > v7 && v202 )
  {
    v179 = v22;
    v25 = _correctly_grouped_prefixmb((unsigned int)v7, (unsigned int)v24, v211, v202);
    v22 = v179;
    if ( v24 != (char *)v25 )
    {
      if ( (char *)v25 != v7 )
      {
        if ( (unsigned int)j > v25 )
        {
          if ( a2 )
            *a2 = v25;
        }
        else
        {
          v26 = j;
          if ( (unsigned int)j < v25 )
          {
            v27 = 0;
            do
              v27 += (unsigned __int8)(*v26++ - 48) < 0xAu;
            while ( (char *)v25 != v26 );
            v207 = v27;
            LODWORD(v199) = v27;
            v212 = 0;
            goto LABEL_51;
          }
          if ( a2 )
          {
            v26 = (char *)v25;
            v212 = 0;
            LODWORD(v199) = 0;
            v207 = 0;
            goto LABEL_52;
          }
        }
LABEL_54:
        if ( v214 )
          return -0.0;
        return 0.0;
      }
LABEL_31:
      if ( a2 )
      {
        result = 0.0;
        *a2 = a1;
        return result;
      }
      return 0.0;
    }
    v178 = *v210;
    v191 = a4[14];
  }
  v212 = -((_DWORD)v199 == 0);
  if ( !v178 )
  {
LABEL_62:
    v30 = -((_DWORD)v199 == 0);
    v31 = v24[v213];
    v24 += v213;
    v32 = v199 - (_DWORD)v24;
    v180 = v24;
    while ( 1 )
    {
      if ( (unsigned __int8)(v31 - 48) > 9u )
      {
        if ( v169 != 16 )
        {
          v207 = (unsigned int)&v24[v32];
          v212 = v30;
          v219 = 0;
          v33 = *(_BYTE *)(v191 + 4 * v31);
LABEL_71:
          if ( v169 == 16 || v33 != 101 )
          {
LABEL_73:
            v26 = v24;
            goto LABEL_74;
          }
          goto LABEL_115;
        }
        if ( (unsigned __int8)(*(_BYTE *)(v191 + 4 * (char)v31) - 97) > 5u )
        {
          v207 = (unsigned int)&v24[v32];
          v212 = v30;
          LOBYTE(v48) = *(_DWORD *)(v191 + 4 * (char)v31);
          goto LABEL_114;
        }
      }
      if ( (_BYTE)v31 != 48 && v30 == -1 )
        v30 = v24 - v180;
      v31 = *++v24;
    }
  }
  v28 = 0;
  if ( *v24 == v178 )
  {
    do
    {
      v29 = v210[++v28];
      if ( !v29 )
        goto LABEL_62;
    }
    while ( v29 == v24[v28] );
  }
  v48 = *(_DWORD *)(v191 + 4 * v22);
  v207 = v199;
LABEL_114:
  v33 = v48;
  v219 = v169 == 16 && (_BYTE)v48 == 112;
  if ( !v219 )
  {
    v219 = v169 == 16;
    goto LABEL_71;
  }
LABEL_115:
  v49 = v24[1];
  if ( (_BYTE)v49 == 45 )
  {
    v50 = v24 + 2;
    v49 = v24[2];
    v222 = 1;
  }
  else
  {
    if ( (_BYTE)v49 == 43 )
    {
      v50 = v24 + 2;
      v49 = v24[2];
    }
    else
    {
      v50 = v24 + 1;
    }
    v222 = 0;
  }
  if ( (unsigned __int8)(v49 - 48) > 9u )
    goto LABEL_73;
  if ( v219 )
  {
    if ( v222 )
    {
      v182 = 4LL * (unsigned int)v199 + 149;
      v203 = v182 / 10;
    }
    else if ( (_DWORD)v199 )
    {
      if ( v212 )
        _assert_fail(
          "lead_zero == 0 && int_no <= (uintmax_t) INTMAX_MAX / 4",
          "strtod_l.c",
          886,
          "____strtof_l_internal");
      v65 = 4 * (32LL - (unsigned int)v199) + 3;
LABEL_181:
      v182 = v65;
      if ( v65 < 0 )
        v182 = 0LL;
      v203 = v182 / 10;
    }
    else if ( v212 == -1 )
    {
      v203 = 13LL;
      v182 = 131LL;
    }
    else
    {
      v182 = 4LL * v212 + 131;
      v203 = v182 / 10;
    }
  }
  else
  {
    if ( v222 )
    {
      v182 = (unsigned int)v199 + 61LL;
      v203 = v182 / 10;
      goto LABEL_123;
    }
    if ( (_DWORD)v199 )
    {
      if ( v212 )
        _assert_fail("lead_zero == 0 && int_no <= (uintmax_t) INTMAX_MAX", "strtod_l.c", 918, "____strtof_l_internal");
      v65 = 39LL - (unsigned int)v199;
      goto LABEL_181;
    }
    if ( v212 == -1 )
    {
      v203 = 3LL;
      v182 = 39LL;
    }
    else
    {
      v182 = v212 + 39LL;
      v203 = v182 / 10;
    }
  }
LABEL_123:
  v51 = v182 % 10;
  v52 = v226;
  v216 = 0;
  v223 = v24;
  v183 = v50;
  while ( 2 )
  {
    if ( v203 < v52 )
    {
      v53 = v183;
      if ( v216 )
        v226 = v52;
LABEL_127:
      if ( v212 == -1 )
      {
        v113 = -0.0;
        if ( !v214 )
          v113 = 0.0;
        result = v113;
        goto LABEL_132;
      }
      __writegsdword(0xFFFFFFE8, 0x22u);
      if ( v222 )
      {
        v54 = 1.1754944e-38;
        if ( v214 )
        {
          v55 = 1.1754944e-38 * -1.1754944e-38;
          goto LABEL_131;
        }
      }
      else
      {
        v54 = 3.4028235e38;
        if ( v214 )
        {
          v55 = 3.4028235e38 * -3.4028235e38;
          goto LABEL_131;
        }
      }
      v55 = v54 * v54;
LABEL_131:
      *(float *)&v229 = v55;
      result = *(float *)&v229;
      do
LABEL_132:
        ++v53;
      while ( (unsigned __int8)(*v53 - 48) <= 9u );
      if ( a2 )
        *a2 = v53;
      return result;
    }
    v59 = v49 - 48;
    v60 = v59 >> 31;
    v61 = v59;
    if ( v52 == v203 && v59 > v51 )
    {
      v53 = v183;
      if ( v216 )
        v226 = v203;
      goto LABEL_127;
    }
    v216 = 1;
    v62 = 10 * HIDWORD(v52);
    v63 = 10LL * (unsigned int)v52;
    HIDWORD(v63) += v62;
    v52 = __PAIR64__(v60, v61) + v63;
    v49 = (char)*++v183;
    if ( (unsigned __int8)(v49 - 48) <= 9u )
      continue;
    break;
  }
  v24 = v223;
  v26 = v183;
  v226 = v52;
  if ( v222 )
    v226 = -v52;
LABEL_74:
  if ( (unsigned int)v199 < v207 )
  {
    if ( *(v24 - 1) != 48 )
      goto LABEL_51;
    v34 = v207 - (_DWORD)v24;
    do
      --v24;
    while ( *(v24 - 1) == 48 );
    if ( (unsigned int)v199 > (unsigned int)&v24[v34] )
      _assert_fail("dig_no >= int_no", "strtod_l.c", 993, "____strtof_l_internal");
    v207 = (unsigned int)&v24[v34];
  }
  if ( (_DWORD)v199 != v207 || !v207 )
  {
LABEL_51:
    if ( a2 )
      goto LABEL_52;
    goto LABEL_53;
  }
  v35 = HIDWORD(v226);
  v36 = v226;
  if ( v226 < 0 )
  {
    v194 = 1LL;
    if ( v219 )
      v194 = 4LL;
    v217 = j;
    v109 = v24 - 1;
    v189 = 0;
    v110 = v199;
    while ( 1 )
    {
      if ( v219 )
        v111 = ((*(_WORD *)(a4[13] + 2 * *v109) >> 12) ^ 1) & 1;
      else
        v111 = (unsigned int)(*v109 - 48) > 9;
      if ( !v111 )
      {
        if ( *v109 != 48 )
        {
          LODWORD(v199) = v110;
          j = v217;
          if ( !v189 )
            goto LABEL_51;
LABEL_369:
          v226 = __PAIR64__(v35, v36);
          goto LABEL_51;
        }
        --v110;
        v35 = (v194 + __PAIR64__(v35, v36)) >> 32;
        v36 += v194;
        v112 = v207-- == 1;
        v189 = v35 < 0 && !v112;
        if ( !v189 )
        {
          LODWORD(v199) = v110;
          j = v217;
          goto LABEL_369;
        }
      }
      --v109;
    }
  }
  if ( a2 )
  {
LABEL_52:
    *a2 = v26;
LABEL_53:
    if ( v207 )
      goto LABEL_84;
    goto LABEL_54;
  }
LABEL_84:
  if ( !v212 )
    goto LABEL_98;
  v37 = *j;
  v38 = v210[1];
  while ( 2 )
  {
    if ( *v210 != v37 )
    {
      v37 = j[1];
LABEL_87:
      ++j;
      continue;
    }
    break;
  }
  if ( !v38 )
    goto LABEL_94;
  v37 = j[1];
  if ( v37 != v38 )
    goto LABEL_87;
  v39 = 1;
  while ( 1 )
  {
    v40 = v210[++v39];
    if ( !v40 )
      break;
    if ( v40 != j[v39] )
    {
      v37 = v210[1];
      goto LABEL_87;
    }
  }
LABEL_94:
  if ( v169 == 16 )
  {
    v41 = HIDWORD(v226);
    v42 = v226;
    if ( v212 > (v226 + 0x8000000000000000LL) >> 2 )
      goto LABEL_223;
    v43 = 4LL * v212;
  }
  else
  {
    v41 = HIDWORD(v226);
    v42 = v226;
    if ( HIDWORD(v226) == 0x80000000 && v212 > (unsigned int)v226 )
LABEL_223:
      _assert_fail(
        "lead_zero <= (base == 16 ? ((uintmax_t) exponent - (uintmax_t) INTMAX_MIN) / 4 : ((uintmax_t) exponent - (uintma"
        "x_t) INTMAX_MIN))",
        "strtod_l.c",
        1048,
        "____strtof_l_internal");
    v43 = v212;
  }
  j += v212 + v213;
  v207 -= v212;
  v226 = __PAIR64__(v41, v42) - v43;
LABEL_98:
  if ( v169 == 16 )
  {
    v72 = a4[13];
    v170 = v72;
    v73 = *j;
    for ( m = *j; (*(_BYTE *)(v72 + 2 * v73 + 1) & 0x10) == 0; m = *j )
      v73 = *++j;
    if ( m == 48 )
    {
      do
        ++j;
      while ( *j == 48 );
      v73 = *j;
    }
    v75 = v73 - 48;
    v76 = j + 1;
    if ( (unsigned int)(v73 - 48) > 9 )
      v75 = *(_DWORD *)(a4[14] + 4 * v73) - 87;
    v184 = nbits_11204[v75];
    if ( !v184 )
      _assert_fail("bits != 0", "strtod_l.c", 1072, "____strtof_l_internal");
    HIDWORD(v199) = 0;
    v192 = 23 - v184;
    v77 = v75 << (24 - v184);
    v225 = v77;
    if ( v226 < 0 )
      v78 = (__int64)(0x8000000000000000LL - v184) >> 2;
    else
      v78 = (0x7FFFFFFFFFFFFFFFLL - v226 - v184 + 1) / 4;
    if ( v199 > v78 )
      _assert_fail(
        "int_no <= (uintmax_t) (exponent < 0 ? (INTMAX_MAX - bits + 1) / 4 : (INTMAX_MAX - exponent - bits + 1) / 4)",
        "strtod_l.c",
        1093,
        "____strtof_l_internal");
    v96 = (v226 + 4 * (v199 - 1) + v184 - 1) >> 32;
    v97 = v226 + 4 * (v199 - 1) + v184 - 1;
    v226 += 4 * (v199 - 1) + v184 - 1;
    if ( v207 == 1 )
      return round_and_return((unsigned int *)&v225, v97, v96, v214, 0, 0, 0);
    v188 = __PAIR64__(v96, v97);
    v98 = v77;
    v99 = v192;
    v100 = v207 - 1;
    while ( 1 )
    {
      v102 = (char)*v76;
      if ( (*(_BYTE *)(v170 + 2 * v102 + 1) & 0x10) == 0 )
      {
        v76 += v213;
        v102 = (char)*v76;
      }
      v103 = v102 - 48;
      ++v76;
      if ( (unsigned int)(v102 - 48) > 9 )
        v103 = *(_DWORD *)(a4[14] + 4 * v102) - 87;
      if ( v99 <= 2 )
        break;
      v101 = v99 - 3;
      v99 -= 4;
      v98 |= v103 << v101;
      if ( !--v100 )
      {
        v149 = v98;
        v96 = HIDWORD(v188);
        v97 = v188;
        v225 = v149;
        return round_and_return((unsigned int *)&v225, v97, v96, v214, 0, 0, 0);
      }
    }
    v173 = v100;
    v225 = v98 | (v103 >> (3 - v99));
    v104 = v103 << (v99 + 29);
    v105 = v100 - 1;
    if ( v173 != 1 )
    {
      if ( *v76 != 48 )
      {
LABEL_426:
        v108 = 1;
        return round_and_return((unsigned int *)&v225, v188, SHIDWORD(v188), v214, v104, 31, v108);
      }
      v106 = v76 + 1;
      v107 = &v76[v105];
      while ( v106 != v107 )
      {
        if ( *v106++ != 48 )
          goto LABEL_426;
      }
    }
    v108 = 0;
    return round_and_return((unsigned int *)&v225, v188, SHIDWORD(v188), v214, v104, 31, v108);
  }
  if ( v226 < 0 )
  {
    v44 = -(__int64)(unsigned int)v199;
    if ( v44 < v226 )
LABEL_101:
      v44 = v226;
  }
  else
  {
    v44 = v207 - (unsigned __int64)(unsigned int)v199;
    if ( v44 > v226 )
      goto LABEL_101;
  }
  v181 = v44 + v199;
  v226 -= v44;
  v215 = (unsigned int)(v44 + v199);
  if ( v226 > 39 - v215 )
  {
    v45 = 3.4028235e38;
    __writegsdword(0xFFFFFFE8, 0x22u);
    if ( v214 )
    {
      v46 = 3.4028235e38 * -3.4028235e38;
LABEL_105:
      *(float *)&v229 = v46;
      return *(float *)&v229;
    }
    goto LABEL_425;
  }
  if ( v226 < -45 )
  {
    v45 = 1.1754944e-38;
    __writegsdword(0xFFFFFFE8, 0x22u);
    if ( v214 )
    {
      v46 = 1.1754944e-38 * -1.1754944e-38;
      goto LABEL_105;
    }
LABEL_425:
    v46 = v45 * v45;
    goto LABEL_105;
  }
  v200 = 0;
  if ( v181 )
  {
    j = str_to_mpn_isra_0(j, v181, (int *)&v227, &v224, (unsigned int *)&v226, v213, v211);
    v174 = v226;
    if ( v226 > 0 )
    {
      v114 = v224;
      v221 = j;
      v115 = &fpioconst_pow10;
      v116 = 1;
      v195 = &v229;
      for ( n = &v227; ; n = (unsigned int *)v119 )
      {
        while ( (v116 & (unsigned __int64)v174) == 0 )
        {
          v116 *= 2;
          v115 += 4;
        }
        v117 = v115[1] - 2;
        v226 = v174 ^ v116;
        if ( v117 > v114 )
          v118 = _mpn_mul(v195, &dword_80D0BC8[*v115], v117, n, v114);
        else
          v118 = _mpn_mul(v195, n, v114, &dword_80D0BC8[*v115], v117);
        v114 = v117 + v224;
        v224 += v117;
        if ( !v118 )
          v224 = --v114;
        v116 *= 2;
        v115 += 4;
        v174 = v226;
        if ( !v226 )
          break;
        v119 = v195;
        v195 = (int *)n;
      }
      j = v221;
      if ( v195 == &v229 )
        memcpy(&v227, v195, 4 * v114);
    }
    else
    {
      v114 = v224;
    }
    _BitScanReverse(&v150, *(&v227 + v114 - 1));
    v200 = 32 * v114 - (v150 ^ 0x1F);
    if ( !((v200 - 128 < 0) ^ __OFADD__(-128, v200) | (v200 == 128)) )
    {
      __writegsdword(0xFFFFFFE8, 0x22u);
      if ( v214 )
        v168 = 3.4028235e38 * -3.4028235e38;
      else
        v168 = 3.4028235e38 * 3.4028235e38;
      *(float *)&v225 = v168;
      return *(float *)&v225;
    }
    if ( v200 > 24 )
    {
      v151 = (v200 - 24) >> 5;
      v152 = (v200 - 24) & 0x1F;
      if ( v152 )
      {
        v177 = v152 - 1;
        v154 = v228[v151 - 1];
        if ( v114 - 1 > v151 )
        {
          v166 = v228[v151] << (32 - v152);
          v167 = (unsigned int)v228[v151 - 1] >> v152;
          v153 = (v200 - 24) >> 5;
          v165 = v167 | v166;
        }
        else
        {
          v153 = (v200 - 24) >> 5;
          v165 = (unsigned int)v228[v151 - 1] >> ((v200 - 24) & 0x1F);
        }
        v225 = v165;
      }
      else
      {
        v153 = v151 - 1;
        v177 = 31;
        v154 = *(&v227 + v151 - 1);
        v225 = v228[v151 - 1];
      }
      v155 = 0;
      if ( !v227 )
      {
        do
          ++v155;
        while ( !v228[v155 - 1] );
      }
      return round_and_return(
               (unsigned int *)&v225,
               v200 - 1,
               (v200 - 1) >> 31,
               v214,
               v154,
               v177,
               (v207 > v181) | (unsigned __int8)(v155 < v153));
    }
    if ( v207 != v181 )
    {
      memcpy(&v225, &v227, 4 * v114);
      goto LABEL_161;
    }
    v157 = (v200 - 1) % 32;
    if ( v157 == 23 )
    {
      memcpy((_BYTE *)&v225 + 4 * (1 - v114), &v227, 4 * v114);
      if ( 1 - v114 <= 0 )
        return round_and_return((unsigned int *)&v225, v200 - 1, (v200 - 1) >> 31, v214, 0, 0, 0);
    }
    else
    {
      _mpn_lshift(&v225 + 1 - v114, (int)&v227, v114, 23 - v157);
      if ( 1 - v224 <= 0 )
        return round_and_return((unsigned int *)&v225, v200 - 1, (v200 - 1) >> 31, v214, 0, 0, 0);
    }
    *(float *)&v225 = 0.0;
    return round_and_return((unsigned int *)&v225, v200 - 1, (v200 - 1) >> 31, v214, 0, 0, 0);
  }
LABEL_161:
  if ( v207 <= v181 || (unsigned __int64)(v226 + 45) > 0x2D )
    _assert_fail(
      "dig_no > int_no && exponent <= 0 && exponent >= MIN_10_EXP - (DIG + 2)",
      "strtod_l.c",
      1332,
      "____strtof_l_internal");
  if ( v200 <= 0 )
  {
    if ( v181 || *j == 48 )
      _assert_fail("int_no == 0 && *startp != L_('0')", "strtod_l.c", 1348, "____strtof_l_internal");
    v156 = 10 * (1 - v226) / 3 + 25;
    v204 = v226;
    if ( v156 > 151 )
      v156 = 151;
    v171 = v226 + v156;
    if ( (int)v226 + v156 <= 0 )
      _assert_fail("need_frac_digits > 0", "strtod_l.c", 1369, "____strtof_l_internal");
  }
  else
  {
    if ( !v181 || v226 )
      _assert_fail("int_no > 0 && exponent == 0", "strtod_l.c", 1342, "____strtof_l_internal");
    v204 = 0;
    v171 = 25 - v200;
  }
  v79 = v171;
  if ( v171 > v207 - v215 )
  {
    v171 = v207 - v181;
    v79 = (int)(v207 - v181);
  }
  if ( v207 <= v215 + v79 )
  {
    v220 = 0;
  }
  else
  {
    v220 = 1;
    v207 = v181 + v171;
  }
  v80 = v207 - v181;
  v81 = (unsigned int *)&v229;
  v208 = j;
  v82 = &fpioconst_pow10;
  v83 = 1;
  v193 = v80;
  v84 = v80 - v204;
  v172 = (int *)&v227;
  v85 = 0;
  do
  {
    if ( (v84 & v83) != 0 )
    {
      v84 ^= v83;
      if ( v85 )
      {
        v186 = v81;
        v86 = _mpn_mul(v172, &dword_80D0BC8[*v82], v82[1] - 2, v81, v85);
        v85 = v85 + v82[1] - 2;
        if ( v86 )
        {
          v87 = (int *)v186;
        }
        else
        {
          v87 = (int *)v186;
          --v85;
        }
        v81 = (unsigned int *)v172;
        v172 = v87;
      }
      else
      {
        v85 = v82[1] - 2;
        v185 = v81;
        memcpy(v81, &dword_80D0BC8[*v82], 4 * v85);
        v81 = v185;
      }
    }
    v83 *= 2;
    v82 += 4;
  }
  while ( v84 );
  v205 = v85;
  if ( v81 == &v227 )
    memcpy(&v229, &v227, 4 * v85);
  str_to_mpn_isra_0(v208, v193, (int *)&v227, &v224, (unsigned int *)&v226, v213, v211);
  _BitScanReverse(&v88, *(&v229 + v85 - 1));
  v209 = v85 - 1;
  v89 = v88 ^ 0x1F;
  if ( v89 && (_mpn_lshift(&v229, (int)&v229, v85, v89), (v90 = _mpn_lshift(&v227, (int)&v227, v224, v89)) != 0) )
  {
    v91 = v224 + 1;
    v228[v224 - 1] = v90;
    v224 = v91;
  }
  else
  {
    v91 = v224;
  }
  v226 = v200;
  if ( v85 == 1 )
  {
    if ( v91 != 1 || v227 >= v229 )
      _assert_fail("numsize == 1 && n < d", "strtod_l.c", 1469, "____strtof_l_internal");
    v139 = v200;
    v176 = v227;
    while ( 1 )
    {
      while ( 1 )
      {
        LODWORD(v141) = 0;
        HIDWORD(v141) = v176;
        LODWORD(v140) = v141 / (unsigned int)v229;
        HIDWORD(v140) = v141 % (unsigned int)v229;
        v176 = HIDWORD(v140);
        if ( v139 )
          break;
        while ( !(_DWORD)v140 )
        {
          v226 -= 32LL;
          v148 = v140 % (unsigned int)v229;
          LODWORD(v140) = v140 / (unsigned int)v229;
          HIDWORD(v140) = v148;
        }
        _BitScanReverse(&v142, v140);
        v176 = HIDWORD(v140);
        v143 = v142 ^ 0x1F;
        v190 = v226 - v143;
        v226 = v190;
        if ( 32 - v143 > 24 )
        {
          v144 = v143;
          v145 = v140;
          v146 = v144 + 24;
          v147 = HIDWORD(v140);
          v225 = (unsigned int)v140 >> (32 - v146);
          return round_and_return(
                   (unsigned int *)&v225,
                   (int)v190 - 1,
                   (unsigned __int64)(v190 - 1) >> 32,
                   v214,
                   v145,
                   31 - v146,
                   v220 | (unsigned int)(v147 != 0));
        }
        v139 = 32 - v143;
        v225 = v140;
      }
      if ( v139 >= -7 )
      {
        HIDWORD(v140) = v139;
        v145 = v140;
        v147 = v176;
        v146 = 24 - BYTE4(v140);
        if ( HIDWORD(v140) != 24 )
        {
          _mpn_lshift(&v225, (int)&v225, 1, 24 - BYTE4(v140));
          v225 |= v145 >> (32 - v146);
        }
        v190 = v226;
        return round_and_return(
                 (unsigned int *)&v225,
                 (int)v190 - 1,
                 (unsigned __int64)(v190 - 1) >> 32,
                 v214,
                 v145,
                 31 - v146,
                 v220 | (unsigned int)(v147 != 0));
      }
      v225 = v140;
      v139 += 32;
    }
  }
  if ( v85 != 2 )
  {
    v175 = *(&v229 + v209);
    v120 = *(&v229 + v85 - 2);
    v121 = _mpn_cmp((int)&v227, (int)(&v229 + v205 - v91), v91);
    v122 = v224;
    if ( v121 > 0 )
    {
      v122 = v224 + 1;
      v228[v224 - 1] = 0;
      v224 = v122;
    }
    if ( v205 <= v122 )
    {
      if ( v205 != v122 )
        _assert_fail("numsize == densize", "strtod_l.c", 1680, "____strtof_l_internal");
      v164 = v205;
      if ( v205 > 0 )
      {
        do
        {
          --v164;
          v228[v164] = v228[v164 - 1];
        }
        while ( v164 );
      }
      v227 = 0;
      *(&v229 + v205) = 0;
      v127 = v228[v205 - 1];
    }
    else
    {
      v123 = v205 - v122;
      v124 = v205 - v122;
      if ( v200 <= 0 )
      {
        v226 -= 32 * v123;
      }
      else
      {
        LOBYTE(v84) = 24 - v200;
        v112 = v200 == 24;
        v200 += 32 * v123;
        if ( !v112 )
        {
          _mpn_lshift(&v225, (int)&v225, 1, v84);
          v122 = v224;
        }
      }
      if ( v122 > 0 )
      {
        v125 = (__int64 *)&v228[v122 - 2];
        do
        {
          *((_DWORD *)v125 + v124 + 1) = *(_DWORD *)v125;
          v125 = (__int64 *)((char *)v125 - 4);
        }
        while ( (__int64 *)((char *)&v226 + 4) != v125 );
      }
      v126 = (int *)&v227;
      do
        *v126++ = 0;
      while ( v126 != &v228[v124] );
      *(&v229 + v205) = 0;
      v127 = v228[v205 - 1];
      if ( v200 > 24 )
      {
        v129 = 0;
        v201 = v226;
        goto LABEL_338;
      }
    }
    v196 = (unsigned __int8 *)v127;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v128 = v196;
          v129 = -1;
          if ( (unsigned __int8 *)v175 != v196 )
          {
            v197 = v228[v209 - 1];
            v129 = __PAIR64__((unsigned int)v128, v197) / v175;
            v130 = __PAIR64__((unsigned int)v128, v197) % v175;
            v131 = v129 * v120;
            v132 = (v129 * (unsigned __int64)v120) >> 32;
            while ( v132 > v130 || v132 == v130 && v131 > *(&v227 + v205 - 2) )
            {
              --v129;
              v133 = __CFADD__(v175, v130);
              v130 += v175;
              if ( v133 )
                break;
              v132 = (__PAIR64__(v132, v131) - v120) >> 32;
              v131 -= v120;
            }
          }
          if ( _mpn_submul_1((int)&v227, (int)&v229, v205 + 1, v129) != v228[v205 - 1] )
          {
            if ( !_mpn_add_n(&v227, &v227, &v229, v205) )
              _assert_fail("cy != 0", "strtod_l.c", 1722, "____strtof_l_internal");
            --v129;
          }
          v134 = v228[v209 - 1];
          v228[v205 - 1] = v134;
          v196 = (unsigned __int8 *)v134;
          v135 = (char *)&v226 + 4 * v205;
          if ( v209 > 0 )
          {
            do
            {
              v136 = *(_DWORD *)v135;
              v135 -= 4;
              *((_DWORD *)v135 + 2) = v136;
            }
            while ( (char *)&v226 + 4 != v135 );
            v196 = (unsigned __int8 *)v134;
          }
          v227 = 0;
          if ( !v200 )
            break;
          if ( v200 >= -7 )
          {
            LOBYTE(v84) = 24 - v200;
            if ( v200 != 24 )
            {
              _mpn_lshift(&v225, (int)&v225, 1, 24 - v200);
              v225 |= v129 >> (32 - v84);
            }
            v201 = v226;
            goto LABEL_338;
          }
          v225 = v129;
          v200 += 32;
        }
        if ( v129 )
          break;
        v133 = __CFADD__((_DWORD)v226, -32);
        LODWORD(v226) = v226 - 32;
        *(float *)&v225 = 0.0;
        HIDWORD(v226) = v133 + HIDWORD(v226) - 1;
      }
      _BitScanReverse(&v137, v129);
      v218 = v137 ^ 0x1F;
      v201 = v226 - (int)(v137 ^ 0x1F);
      v226 = v201;
      if ( (int)(32 - (v137 ^ 0x1F)) > 24 )
        break;
      v200 = 32 - v218;
      v225 = v129;
    }
    LOBYTE(v84) = v218 + 24;
    v225 = v129 >> (32 - (v218 + 24));
LABEL_338:
    v138 = v205;
    if ( v205 < 0 || v228[v205 - 1] )
    {
      v138 = v205;
    }
    else
    {
      do
        --v138;
      while ( v138 != -1 && !v228[v138 - 1] );
    }
    return round_and_return(
             (unsigned int *)&v225,
             (int)v201 - 1,
             (unsigned __int64)(v201 - 1) >> 32,
             v214,
             v129,
             31 - (unsigned __int8)v84,
             v220 | (unsigned int)(v138 >= 0));
  }
  if ( v91 > 1 )
  {
    v93 = v228[0];
    v92 = v227;
    goto LABEL_397;
  }
  v92 = v227;
  if ( v230 <= v227 )
  {
    v93 = 0;
    goto LABEL_397;
  }
  if ( v200 > 0 )
  {
    if ( v200 != 24 )
      _mpn_lshift(&v225, (int)&v225, 1, 24 - v200);
    v93 = v227;
    v92 = 0;
    v94 = 31 - (24 - v200);
    v95 = 0;
    v187 = v226;
    return round_and_return(
             (unsigned int *)&v225,
             (int)v187 - 1,
             (unsigned __int64)(v187 - 1) >> 32,
             v214,
             v95,
             v94,
             (unsigned __int8)(v220 | (v93 != 0 || v92 != 0)));
  }
  v93 = v227;
  v226 = v200 - 32LL;
  v92 = 0;
  while ( 1 )
  {
LABEL_397:
    if ( v230 != v93 )
    {
      v95 = __PAIR64__(v93, v92) / v230;
      v158 = __PAIR64__(v93, v92) % v230;
      v159 = v95 * v229;
      v160 = (unsigned __int8 *)((v95 * (unsigned __int64)(unsigned int)v229) >> 32);
      goto LABEL_399;
    }
    v158 = v230 + v92;
    if ( __CFADD__(v230, v92) )
      break;
    v159 = -v229;
    v160 = (unsigned __int8 *)(v229 - (v229 != 0));
    v95 = -1;
    do
    {
LABEL_399:
      if ( (unsigned int)v160 <= v158 && (v160 != (unsigned __int8 *)v158 || !v159) )
        break;
      --v95;
      v160 = (unsigned __int8 *)((__PAIR64__((unsigned int)v160, v159) - (unsigned int)v229) >> 32);
      v159 -= v229;
      v133 = __CFADD__(v230, v158);
      v158 += v230;
    }
    while ( !v133 );
    v93 = (__PAIR64__(v158, 0) - __PAIR64__((unsigned int)v160, v159)) >> 32;
    v92 = -v159;
    if ( v200 )
      goto LABEL_412;
    if ( !v95 )
    {
      v133 = __CFADD__((_DWORD)v226, -32);
      LODWORD(v226) = v226 - 32;
      *(float *)&v225 = 0.0;
      HIDWORD(v226) = v133 + HIDWORD(v226) - 1;
      continue;
    }
    _BitScanReverse(&v161, v95);
    v198 = v161 ^ 0x1F;
    v187 = v226 - (int)(v161 ^ 0x1F);
    v226 = v187;
    if ( (int)(32 - (v161 ^ 0x1F)) > 24 )
    {
      v162 = v95 >> (32 - (v198 + 24));
      v94 = 31 - (v198 + 24);
LABEL_407:
      v225 = v162;
      return round_and_return(
               (unsigned int *)&v225,
               (int)v187 - 1,
               (unsigned __int64)(v187 - 1) >> 32,
               v214,
               v95,
               v94,
               (unsigned __int8)(v220 | (v93 != 0 || v92 != 0)));
    }
    v200 = 32 - v198;
    v225 = v95;
  }
  v93 = ((unsigned int)v229 + __PAIR64__(v158 - v229, 0)) >> 32;
  v92 = v229;
  if ( !v200 )
  {
    v94 = 7;
    v95 = -1;
    v187 = v226;
    v162 = 0xFFFFFF;
    goto LABEL_407;
  }
  v95 = -1;
LABEL_412:
  if ( v200 < -7 )
  {
    v225 = v95;
    v200 += 32;
    goto LABEL_397;
  }
  v163 = 24 - v200;
  if ( v200 != 24 )
  {
    _mpn_lshift(&v225, (int)&v225, 1, 24 - v200);
    v225 |= v95 >> (32 - v163);
  }
  v94 = 31 - v163;
  v187 = v226;
  return round_and_return(
           (unsigned int *)&v225,
           (int)v187 - 1,
           (unsigned __int64)(v187 - 1) >> 32,
           v214,
           v95,
           v94,
           (unsigned __int8)(v220 | (v93 != 0 || v92 != 0)));
}
// 8048280: using guessed type int __cdecl j_strncasecmp_l(_DWORD, _DWORD, _DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80C1540: using guessed type int dword_80C1540[256];
// 80CC680: using guessed type void **nl_C_locobj[6];
// 80D0BC8: using guessed type unsigned int dword_80D0BC8[3438];
// 80D6040: using guessed type int nbits_11204[16];
// 80ABD80: using guessed type int var_A8[17];

//----- (080AE070) --------------------------------------------------------
void __cdecl strtof_l(unsigned int a1, _DWORD *a2, _DWORD *a3)
{
  ___strtof_l_internal(a1, a2, 0, a3);
}

//----- (080AE090) --------------------------------------------------------
int __usercall round_away_0@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4, int a5)
{
  int result; // eax
  bool v6; // zf
  int v7; // edx

  if ( a5 == 1024 )
  {
    v6 = a1 == 0;
    result = 0;
    if ( !v6 )
      return a3 | a4;
  }
  else if ( a5 <= 1024 )
  {
    if ( a5 )
      goto LABEL_13;
    v7 = a4 | a2;
    result = 0;
    if ( (_BYTE)a3 )
      return v7;
  }
  else
  {
    if ( a5 != 2048 )
    {
      result = 0;
      if ( a5 == 3072 )
        return result;
LABEL_13:
      abort(a3);
    }
    v6 = a1 == 0;
    result = 0;
    if ( v6 )
      return a3 | a4;
  }
  return result;
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080AE110) --------------------------------------------------------
long double __usercall round_and_return_0@<st0>(
        unsigned int *a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        int a4,
        unsigned int a5,
        char a6,
        int a7)
{
  int v7; // edi
  int v8; // esi
  __int16 v10; // ax
  bool v11; // cc
  long double v12; // fst7
  int v15; // eax
  unsigned int v16; // ebp
  int v17; // edx
  int v18; // edx
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // ecx
  unsigned int v24; // eax
  unsigned int v25; // ebp
  int v26; // ecx
  char v27; // si
  unsigned int v28; // eax
  int v29; // edi
  int v30; // kr00_4
  int v31; // [esp+4h] [ebp-38h]
  int v32; // [esp+8h] [ebp-34h]
  bool v33; // [esp+Ch] [ebp-30h]
  __int16 v34; // [esp+18h] [ebp-24h]

  v7 = a3;
  v8 = a2;
  v10 = v34 & 0xC00;
  if ( (v34 & 0xC00) == 1024 )
  {
    v31 = 1024;
    goto LABEL_5;
  }
  if ( (v34 & 0xC00u) <= 0x400 )
  {
    v31 = 0;
    if ( !v10 )
      goto LABEL_5;
LABEL_21:
    abort(a3);
  }
  if ( v10 == 2048 )
  {
    v11 = a3 < -1;
    v31 = 2048;
    if ( a3 > -1 )
      goto LABEL_46;
    goto LABEL_11;
  }
  v31 = 3072;
  if ( v10 != 3072 )
    goto LABEL_21;
LABEL_5:
  v11 = a3 < -1;
  if ( a3 > -1 )
  {
LABEL_46:
    if ( __SPAIR64__(a3, a2) > 1024 )
      goto LABEL_7;
    v32 = (a5 >> a6) & 1;
    v16 = *a1;
    v33 = a4 != 0;
    v17 = *a1 & 1;
    goto LABEL_36;
  }
LABEL_11:
  if ( v11 )
    goto LABEL_25;
  if ( a2 >= 0xFFFFFC02 )
    goto LABEL_46;
  if ( a3 < -1 || a2 < 0xFFFFFBCD )
  {
LABEL_25:
    v12 = 2.225073858507201e-308;
    __writegsdword(0xFFFFFFE8, 0x22u);
    if ( a4 )
      return (double)(2.225073858507201e-308 * -2.225073858507201e-308);
    return (double)(v12 * v12);
  }
  v15 = -1022 - a2;
  a7 |= (((1 << a6) - 1) & a5) != 0;
  if ( a2 == -1075 )
  {
    v24 = a1[1];
    v25 = *a1;
    a1[1] = 0;
    *a1 = 0;
    a6 = 20;
    a5 = v24;
    v17 = 0;
    a7 |= v25 != 0;
    v16 = 0;
  }
  else if ( v15 > 31 )
  {
    v18 = (v15 - 1) >> 5;
    a6 = (v15 - 1) & 0x1F;
    a5 = a1[v18];
    if ( v18 == 1 )
      a7 |= *a1 != 0;
    a7 |= (((1 << a6) - 1) & a5) != 0;
    v19 = v15 & 0x1F;
    if ( v19 )
    {
      _mpn_rshift((int)a1, a1 + 1, 1, v19);
      v16 = *a1;
    }
    else
    {
      v16 = a1[1];
      *a1 = v16;
    }
    a1[1] = 0;
    v17 = v16 & 1;
  }
  else
  {
    if ( v15 == 1 )
    {
      v26 = (a5 >> a6) & 1;
      a5 = *a1;
      v33 = a4 != 0;
      v27 = 1;
      if ( (unsigned __int8)round_away_0(a4 != 0, *a1 & 1, v26, a7 != 0, v31) )
      {
        v28 = a1[1];
        if ( a5 == -1 )
          ++v28;
        v27 = ((v28 >> 21) ^ 1) & 1;
      }
      _mpn_rshift((int)a1, a1, 2, 1);
      if ( !v27 )
      {
        v16 = *a1;
        v8 = -1023;
        a6 = 0;
        v7 = -1;
        v32 = a5 & 1;
        v17 = *a1 & 1;
        goto LABEL_36;
      }
      a6 = 0;
    }
    else
    {
      a5 = *a1;
      a6 = v15 - 1;
      _mpn_rshift((int)a1, a1, 2, v15);
    }
    v16 = *a1;
    v17 = *a1 & 1;
  }
  v20 = (a5 >> a6) & 1;
  v32 = v20;
  if ( !a7 && !(_BYTE)v20 )
  {
    v21 = a5 & ((1 << a6) - 1);
    if ( !v21 )
    {
      v32 = 0;
      v7 = -1;
      v8 = -1023;
      v33 = a4 != 0;
      goto LABEL_38;
    }
  }
  __writegsdword(0xFFFFFFE8, 0x22u);
  v8 = -1023;
  v7 = -1;
  v33 = a4 != 0;
LABEL_36:
  v22 = 1;
  if ( !a7 )
  {
    v21 = a5 & ((1 << a6) - 1);
LABEL_38:
    v22 = v21 != 0;
  }
  if ( (unsigned __int8)round_away_0(v33, v17, v32, v22, v31) )
  {
    *a1 = v16 + 1;
    if ( v16 == -1 )
    {
      v23 = a1[1] + 1;
      a1[1] = v23;
    }
    else
    {
      v23 = a1[1];
    }
    if ( (v23 & 0x200000) == 0 )
    {
      if ( !(v8 ^ 0xFFFFFC01 | ~v7) )
        LOWORD(v8) = ((v23 & 0x100000) != 0) - 1023;
      return _mpn_construct_double(a1, v8, a4);
    }
    v30 = v8 + 1;
    v29 = (__PAIR64__(v7, v8) + 1) >> 32;
    LOWORD(v8) = v8 + 1;
    _mpn_rshift((int)a1, a1, 2, 1);
    a1[1] |= 0x100000u;
    if ( !(v30 ^ 0x401 | v29) )
    {
LABEL_7:
      v12 = 1.797693134862316e308;
      __writegsdword(0xFFFFFFE8, 0x22u);
      if ( a4 )
        return (double)(1.797693134862316e308 * -1.797693134862316e308);
      return (double)(v12 * v12);
    }
  }
  return _mpn_construct_double(a1, v8, a4);
}
// 80AE1B6: conditional instruction was optimized away because ecx.4<0
// 80AE126: variable 'v34' is possibly undefined
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080AE5B0) --------------------------------------------------------
char *__usercall str_to_mpn_isra_0_0@<eax>(
        char *a1@<eax>,
        int a2@<edx>,
        int *a3@<ecx>,
        int *a4,
        unsigned int *a5,
        int a6,
        _BYTE *a7)
{
  int v9; // esi
  int v10; // ecx
  int v11; // eax
  bool v12; // zf
  char v13; // al
  int v14; // eax
  char v15; // dl
  int v16; // eax
  int v17; // edx
  _BOOL4 v18; // ecx
  int v19; // esi
  int v20; // edx
  int v21; // ecx
  int v22; // eax
  int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // eax
  int v27; // eax
  int v28; // edx
  _BOOL4 v29; // ecx
  int v30; // edx
  int v31; // eax
  int v32; // edx
  int v33; // edx
  int v34; // ecx
  int v35; // edi
  int v36; // [esp+0h] [ebp-2Ch]
  unsigned int v37; // [esp+0h] [ebp-2Ch]
  int v38; // [esp+4h] [ebp-28h]

  v36 = a2;
  *a4 = 0;
  if ( a2 <= 0 )
    _assert_fail("digcnt > 0", "strtod_l.c", 352, "str_to_mpn");
  v38 = 0;
  v9 = 0;
  v10 = 0;
  while ( 1 )
  {
    v11 = *a1;
    if ( (unsigned __int8)(v11 - 48) <= 9u )
      goto LABEL_7;
    if ( !a7 || (_BYTE)v11 != *a7 )
    {
LABEL_6:
      a1 += a6;
      v11 = *a1;
      goto LABEL_7;
    }
    v13 = a7[1];
    if ( v13 )
    {
      if ( a1[1] != v13 )
        goto LABEL_6;
      v14 = 1;
      while ( 1 )
      {
        v15 = a7[++v14];
        if ( !v15 )
          break;
        if ( a1[v14] != v15 )
          goto LABEL_6;
      }
    }
    else
    {
      v14 = 1;
    }
    a1 += v14;
    v11 = *a1;
LABEL_7:
    ++a1;
    ++v10;
    v12 = v36-- == 1;
    v9 = v11 + 10 * v9 - 48;
    if ( v12 )
      break;
    if ( v10 == 9 )
    {
      if ( v38 )
      {
        v16 = _mpn_mul_1((int)a3, (int)a3, v38, 0x3B9ACA00u);
        v17 = *a4;
        v18 = __CFADD__(*a3, v9);
        *a3 += v9;
        if ( v18 )
        {
          v19 = v17 - 1;
          v20 = 0;
          while ( v19 != v20 )
          {
            v21 = a3[v20 + 1] + 1;
            a3[++v20] = v21;
            if ( v21 )
              goto LABEL_24;
          }
          v12 = v16 == -1;
          v9 = v16 + 1;
          v22 = *a4;
          if ( v12 )
            goto LABEL_25;
LABEL_22:
          if ( v22 > 114 )
            _assert_fail("*nsize < MPNSIZE", "strtod_l.c", 369, "str_to_mpn");
          a3[v22] = v9;
          v10 = 0;
          v23 = *a4 + 1;
          *a4 = v23;
          v38 = v23;
          v9 = 0;
        }
        else
        {
LABEL_24:
          v12 = v16 == 0;
          v9 = v16;
          v22 = *a4;
          if ( !v12 )
            goto LABEL_22;
LABEL_25:
          v38 = v22;
          v10 = 0;
        }
      }
      else
      {
        *a3 = v9;
        v10 = 0;
        v38 = 1;
        v9 = 0;
        *a4 = 1;
      }
    }
  }
  v37 = *a5;
  v24 = a5[1];
  if ( __SPAIR64__(v24, v37) <= 0 || __SPAIR64__(v24, v37) > 9 - v10 )
  {
    v25 = tens_in_limb[v10];
    if ( v38 )
      goto LABEL_32;
    goto LABEL_29;
  }
  v9 *= tens_in_limb[v37];
  v25 = tens_in_limb[v37 + v10];
  *a5 = 0;
  a5[1] = 0;
  if ( !v38 )
  {
LABEL_29:
    *a3 = v9;
    *a4 = 1;
    return a1;
  }
LABEL_32:
  v27 = _mpn_mul_1((int)a3, (int)a3, v38, v25);
  v28 = *a4;
  v29 = __CFADD__(*a3, v9);
  *a3 += v9;
  if ( v29 )
  {
    v33 = v28 - 1;
    v34 = 0;
    while ( v33 != v34 )
    {
      v35 = a3[v34 + 1];
      a3[++v34] = v35 + 1;
      if ( v35 != -1 )
        goto LABEL_33;
    }
    v30 = 1;
  }
  else
  {
LABEL_33:
    v30 = 0;
  }
  v31 = v30 + v27;
  if ( !v31 )
    return a1;
  v32 = *a4;
  if ( *a4 > 114 )
    _assert_fail("*nsize < MPNSIZE", "strtod_l.c", 425, "str_to_mpn");
  *a4 = v32 + 1;
  a3[v32] = v31;
  return a1;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80D6200: using guessed type int tens_in_limb[10];

//----- (080AE8C0) --------------------------------------------------------
long double __cdecl ___strtod_l_internal(unsigned int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // eax
  unsigned int i; // edx
  int v6; // ecx
  char *v7; // ebx
  int v8; // eax
  int v9; // edx
  char v10; // cl
  int v11; // esi
  char *j; // ebp
  char v13; // di
  char *v14; // esi
  char v15; // bl
  int v16; // eax
  char v17; // dl
  int v18; // eax
  char *k; // eax
  int v20; // eax
  long double result; // fst7
  int v22; // edx
  int v23; // esi
  char *v24; // edi
  char *v25; // eax
  unsigned int v26; // eax
  char *v27; // ecx
  unsigned int v28; // esi
  int v29; // eax
  char v30; // cl
  int v31; // eax
  unsigned int v32; // ecx
  char v33; // al
  int v34; // ebx
  char *v35; // ecx
  int v36; // edx
  __int64 v37; // rax
  char v38; // al
  char v39; // bl
  int v40; // eax
  char v41; // dl
  __int64 v42; // rax
  signed __int64 v43; // rax
  long double v44; // fst7
  long double v45; // fst7
  char *v46; // eax
  int v47; // edx
  __int64 v48; // kr08_8
  __int64 v49; // rax
  unsigned int v50; // ebp
  char *v51; // ecx
  unsigned int v52; // esi
  long double v53; // fst7
  long double v54; // fst7
  int v55; // eax
  char v56; // cl
  int v57; // eax
  __int64 v58; // rax
  int v59; // ebx
  int v60; // edi
  int v61; // esi
  int v62; // ebx
  __int64 v63; // rax
  unsigned int v64; // eax
  _BYTE *v65; // esi
  _BYTE *v66; // ebx
  int v67; // esi
  int v68; // eax
  char v69; // cl
  int v70; // esi
  int v71; // eax
  char m; // dl
  int v73; // edx
  _BYTE *v74; // ebp
  int v75; // edi
  unsigned __int64 v76; // rcx
  char *v77; // edi
  char *v78; // ebx
  unsigned int v79; // ebp
  int v80; // esi
  bool v81; // zf
  char *v82; // esi
  int v83; // esi
  int v84; // ecx
  int v85; // ebx
  int v86; // eax
  _DWORD *v87; // esi
  int v88; // eax
  unsigned int *v89; // edx
  int v90; // ebx
  int v91; // edi
  int v92; // ebp
  int v93; // eax
  int *v94; // eax
  unsigned int v95; // ebx
  unsigned int v96; // ebx
  int v97; // eax
  int v98; // edx
  unsigned int v99; // ecx
  unsigned int v100; // ebp
  int v101; // ebx
  unsigned int v102; // esi
  int v103; // edi
  unsigned int v104; // edx
  unsigned int v105; // ebx
  unsigned int v106; // edi
  int v107; // edx
  bool v108; // cf
  int v109; // kr28_4
  int v110; // edx
  int v111; // edi
  char *v112; // ebx
  int v113; // ecx
  unsigned int v114; // eax
  char v115; // cl
  int v116; // edx
  unsigned int v117; // eax
  unsigned int v118; // ecx
  int ii; // esi
  unsigned __int64 v120; // rax
  unsigned __int64 v121; // rtt
  unsigned int v122; // ebx
  __int64 v123; // rax
  unsigned __int64 v124; // rt2
  int v125; // ecx
  unsigned int v126; // esi
  char v127; // bl
  int v128; // edi
  unsigned int v129; // edi
  int v130; // eax
  int v131; // ecx
  int v132; // eax
  int v133; // ebx
  int v134; // esi
  int v135; // eax
  char *v136; // eax
  int *v137; // eax
  int v138; // ecx
  unsigned int v139; // esi
  unsigned int v140; // ecx
  unsigned int v141; // eax
  unsigned int v142; // ebp
  char *v143; // eax
  int v144; // edx
  int v145; // eax
  signed int v146; // eax
  __int64 v147; // rax
  int v148; // ebx
  int v149; // eax
  double *v150; // esi
  int v151; // esi
  unsigned int v152; // eax
  int v153; // eax
  char v154; // si
  int v155; // ebx
  int v156; // edx
  char v157; // bp
  unsigned int v158; // eax
  int v159; // eax
  int v160; // ecx
  char *v161; // ebx
  _BYTE *v162; // ecx
  _BYTE *v163; // ebp
  signed int v164; // eax
  int v165; // eax
  int v166; // eax
  int v167; // edx
  int v168; // eax
  long double v169; // fst7
  unsigned int v170; // ebx
  unsigned int v171; // edi
  int v172; // edi
  int v173; // [esp+Ch] [ebp-430h]
  unsigned int v174; // [esp+Ch] [ebp-430h]
  int v175; // [esp+Ch] [ebp-430h]
  int *v176; // [esp+Ch] [ebp-430h]
  int v177; // [esp+Ch] [ebp-430h]
  unsigned int v178; // [esp+Ch] [ebp-430h]
  char *v179; // [esp+10h] [ebp-42Ch]
  char v180; // [esp+10h] [ebp-42Ch]
  char *v181; // [esp+10h] [ebp-42Ch]
  __int64 v182; // [esp+10h] [ebp-42Ch]
  __int64 v183; // [esp+10h] [ebp-42Ch]
  char *v184; // [esp+10h] [ebp-42Ch]
  __int64 v185; // [esp+10h] [ebp-42Ch]
  __int64 v186; // [esp+10h] [ebp-42Ch]
  unsigned int *v187; // [esp+10h] [ebp-42Ch]
  unsigned int *v188; // [esp+10h] [ebp-42Ch]
  unsigned int v189; // [esp+10h] [ebp-42Ch]
  __int64 v190; // [esp+10h] [ebp-42Ch]
  int v191; // [esp+10h] [ebp-42Ch]
  unsigned int v192; // [esp+10h] [ebp-42Ch]
  int v193; // [esp+18h] [ebp-424h]
  signed int v194; // [esp+18h] [ebp-424h]
  char *v195; // [esp+18h] [ebp-424h]
  __int64 v196; // [esp+18h] [ebp-424h]
  int v197; // [esp+18h] [ebp-424h]
  unsigned int v198; // [esp+20h] [ebp-41Ch]
  signed int v199; // [esp+20h] [ebp-41Ch]
  _DWORD *v200; // [esp+20h] [ebp-41Ch]
  int v201; // [esp+20h] [ebp-41Ch]
  char v202; // [esp+24h] [ebp-418h]
  char *v203; // [esp+24h] [ebp-418h]
  int v204; // [esp+24h] [ebp-418h]
  int v205; // [esp+24h] [ebp-418h]
  __int64 v206; // [esp+28h] [ebp-414h]
  unsigned int v207; // [esp+28h] [ebp-414h]
  char *v208; // [esp+30h] [ebp-40Ch]
  char *v209; // [esp+34h] [ebp-408h]
  int v210; // [esp+34h] [ebp-408h]
  int v211; // [esp+38h] [ebp-404h]
  bool v212; // [esp+3Ch] [ebp-400h]
  int v213; // [esp+3Ch] [ebp-400h]
  double *v214; // [esp+3Ch] [ebp-400h]
  int v215; // [esp+40h] [ebp-3FCh]
  char v216; // [esp+44h] [ebp-3F8h]
  char *v217; // [esp+44h] [ebp-3F8h]
  int v218; // [esp+44h] [ebp-3F8h]
  unsigned int *n; // [esp+44h] [ebp-3F8h]
  int v220; // [esp+48h] [ebp-3F4h]
  __int64 v221; // [esp+48h] [ebp-3F4h]
  char *v222; // [esp+48h] [ebp-3F4h]
  char *v223; // [esp+50h] [ebp-3ECh]
  char *v224; // [esp+5Ch] [ebp-3E0h]
  int v225; // [esp+6Ch] [ebp-3D0h] BYREF
  __int64 v226; // [esp+70h] [ebp-3CCh] BYREF
  unsigned __int64 v227; // [esp+78h] [ebp-3C4h] BYREF
  char v228; // [esp+80h] [ebp-3BCh] BYREF
  unsigned int v229; // [esp+84h] [ebp-3B8h] BYREF
  int v230[114]; // [esp+88h] [ebp-3B4h]
  double v231[61]; // [esp+250h] [ebp-1ECh] BYREF

  v179 = 0;
  v209 = 0;
  v4 = (_DWORD *)a4[1];
  if ( a3 )
  {
    v179 = (char *)v4[11];
    if ( (unsigned __int8)(*v179 - 1) > 0x7Du )
    {
      v179 = 0;
    }
    else
    {
      v209 = (char *)v4[10];
      if ( !*v209 )
      {
        v179 = 0;
        v209 = 0;
      }
    }
  }
  v208 = (char *)v4[9];
  v215 = strlen(v208);
  if ( !v215 )
    _assert_fail("decimal_len > 0", "strtod_l.c", 570, "____strtod_l_internal");
  v226 = 0LL;
  for ( i = a1 - 1; ; ++i )
  {
    v6 = *(char *)(i + 1);
    v7 = (char *)(i + 1);
    v8 = v6;
    if ( (*(_BYTE *)(a4[13] + 2 * v6 + 1) & 0x20) == 0 )
      break;
  }
  if ( (_BYTE)v6 == 45 )
  {
    v8 = *(char *)(i + 2);
    v211 = 1;
    v7 = (char *)(i + 2);
  }
  else
  {
    v211 = 0;
    if ( (_BYTE)v6 == 43 )
    {
      v8 = *(char *)(i + 2);
      v7 = (char *)(i + 2);
    }
  }
  v202 = *v208;
  if ( !*v208 )
  {
    v11 = 0;
    goto LABEL_14;
  }
  if ( v202 == *v7 )
  {
    v9 = 0;
    while ( 1 )
    {
      v10 = v208[++v9];
      v11 = v9;
      if ( !v10 )
        break;
      if ( v10 != v7[v9] )
        goto LABEL_28;
    }
LABEL_14:
    if ( (unsigned __int8)(v7[v11] - 48) <= 9u )
      goto LABEL_15;
  }
LABEL_28:
  if ( (unsigned __int8)(v8 - 48) > 9u )
  {
    v20 = dword_80C1540[v8];
    if ( (_BYTE)v20 == 105 )
    {
      if ( !j_strncasecmp_l(v7, &unk_80CCFA7, 3, nl_C_locobj) )
      {
        if ( a2 )
        {
          v65 = v7 + 3;
          v66 = v7 + 8;
          if ( !j_strncasecmp_l(v65, "inity", 5, nl_C_locobj) )
            v65 = v66;
          *a2 = v65;
        }
        if ( v211 )
          return -INFINITY;
        else
          return INFINITY;
      }
    }
    else if ( (_BYTE)v20 == 110 && !j_strncasecmp_l(v7, &unk_80CCFA3, 3, nl_C_locobj) )
    {
      v67 = (int)(v7 + 3);
      if ( v7[3] == 40 )
      {
        result = _strtod_nan((unsigned __int8 *)v7 + 4, (unsigned __int8 **)v231, 41);
        if ( *(_BYTE *)LODWORD(v231[0]) == 41 )
          v67 = LODWORD(v231[0]) + 1;
      }
      else
      {
        result = NAN;
      }
      if ( a2 )
        *a2 = v67;
      return result;
    }
    goto LABEL_31;
  }
LABEL_15:
  if ( (_BYTE)v8 == 48 )
  {
    v193 = a4[14];
    v22 = v7[1];
    if ( *(_DWORD *)(v193 + 4 * v22) == 120 )
    {
      j = v7 + 2;
      LOBYTE(v8) = v7[2];
      if ( !v209 )
      {
        if ( (_BYTE)v8 != 48 )
        {
          v179 = 0;
          v7 += 2;
          v22 = (char)v8;
          v173 = 16;
          goto LABEL_36;
        }
        v22 = v7[3];
        v179 = 0;
        v7 += 2;
        v173 = 16;
        goto LABEL_137;
      }
      v7 += 2;
      v179 = 0;
      v173 = 16;
    }
    else
    {
      v173 = 10;
      if ( !v209 )
      {
LABEL_137:
        for ( j = v7; ; v22 = j[1] )
        {
          ++j;
          if ( (_BYTE)v22 != 48 )
            break;
        }
        goto LABEL_36;
      }
    }
LABEL_18:
    j = v7;
    v13 = *v209;
    v14 = v7;
    v15 = v8;
    if ( (_BYTE)v8 == 48 )
      goto LABEL_27;
    while ( 1 )
    {
      if ( v13 )
      {
        if ( *j != v13 )
        {
LABEL_35:
          v22 = v15;
          v7 = v14;
          goto LABEL_36;
        }
        v16 = 0;
        while ( 1 )
        {
          v17 = v209[++v16];
          if ( !v17 )
            break;
          if ( v17 != j[v16] )
            goto LABEL_35;
        }
        v18 = v16 - 1;
      }
      else
      {
        v18 = -1;
      }
      for ( k = &j[v18]; ; k = j )
      {
        v15 = k[1];
        j = k + 1;
        if ( v15 != 48 )
          break;
LABEL_27:
        ;
      }
    }
  }
  v193 = a4[14];
  if ( v209 )
  {
    v173 = 10;
    goto LABEL_18;
  }
  v22 = (char)v8;
  j = v7;
  v173 = 10;
LABEL_36:
  if ( (unsigned __int8)(v22 - 48) <= 9u )
    goto LABEL_112;
  v23 = *(_DWORD *)(v193 + 4 * (char)v22);
  if ( (unsigned __int8)(v23 - 97) > 5u || (v24 = j, v198 = 0, v173 != 16) )
  {
    if ( v202 )
    {
      if ( *j != v202 )
      {
LABEL_171:
        if ( v173 != 16 || (_BYTE)v23 != 112 || j == v7 )
          goto LABEL_172;
        goto LABEL_112;
      }
      v55 = 0;
      while ( 1 )
      {
        v56 = v208[++v55];
        if ( !v56 )
          break;
        if ( v56 != j[v55] )
          goto LABEL_171;
      }
    }
    if ( v173 == 16 && j == v7 )
    {
      v57 = j[v215];
      if ( (unsigned __int8)(v57 - 48) > 9u && (unsigned __int8)(*(_BYTE *)(v193 + 4 * v57) - 97) > 5u )
      {
LABEL_172:
        if ( v173 != 16 )
        {
          v24 = j;
          v198 = 0;
          if ( (_BYTE)v23 == 101 )
            goto LABEL_39;
        }
        v64 = _correctly_grouped_prefixmb((unsigned int)v7, (unsigned int)j, v209, v179);
        if ( a2 )
        {
          if ( (char *)v64 == v7 )
          {
            v64 = (unsigned int)(j - 1);
            if ( v173 != 16 )
              v64 = a1;
          }
          *a2 = v64;
        }
        goto LABEL_53;
      }
    }
LABEL_112:
    v24 = j;
    v198 = 0;
    goto LABEL_39;
  }
  while ( 1 )
  {
LABEL_39:
    if ( (unsigned __int8)(v22 - 48) <= 9u
      || v173 == 16 && (unsigned __int8)(*(_BYTE *)(v193 + 4 * (char)v22) - 97) <= 5u )
    {
      ++v198;
      v46 = v24;
      goto LABEL_109;
    }
    if ( !v209 )
      break;
    if ( !*v209 )
    {
      v46 = v24 - 1;
      goto LABEL_109;
    }
    if ( *v24 != *v209 )
      break;
    v68 = 0;
    while ( 1 )
    {
      v69 = v209[++v68];
      if ( !v69 )
        break;
      if ( v69 != v24[v68] )
        goto LABEL_42;
    }
    v46 = &v24[v68 - 1];
LABEL_109:
    v24 = v46 + 1;
    v22 = v46[1];
  }
LABEL_42:
  if ( v24 > v7 )
  {
    v25 = v179;
    if ( v179 )
    {
      v180 = v22;
      v26 = _correctly_grouped_prefixmb((unsigned int)v7, (unsigned int)v24, v209, v25);
      v22 = v180;
      if ( v24 != (char *)v26 )
      {
        if ( (char *)v26 != v7 )
        {
          if ( (unsigned int)j > v26 )
          {
            if ( a2 )
              *a2 = v26;
          }
          else
          {
            v27 = j;
            v203 = 0;
            if ( (unsigned int)j < v26 )
            {
              do
                v203 += (unsigned __int8)(*v27++ - 48) < 0xAu;
              while ( (char *)v26 != v27 );
              v28 = 0;
              v198 = (unsigned int)v203;
              goto LABEL_50;
            }
            if ( a2 )
            {
              v27 = (char *)v26;
              v28 = 0;
              v198 = 0;
              v203 = 0;
              goto LABEL_51;
            }
          }
LABEL_53:
          if ( v211 )
            return -0.0;
          return 0.0;
        }
LABEL_31:
        if ( a2 )
        {
          result = 0.0;
          *a2 = a1;
          return result;
        }
        return 0.0;
      }
      v202 = *v208;
      v193 = a4[14];
    }
  }
  v28 = -(v198 == 0);
  if ( v202 )
  {
    v29 = 0;
    if ( *v24 == v202 )
    {
      do
      {
        v30 = v208[++v29];
        if ( !v30 )
          goto LABEL_61;
      }
      while ( v30 == v24[v29] );
    }
    v47 = *(_DWORD *)(v193 + 4 * v22);
    v203 = (char *)v198;
  }
  else
  {
LABEL_61:
    v24 += v215;
    v181 = v24;
    v31 = *v24;
    v32 = v198 - (_DWORD)v24;
    while ( 1 )
    {
      if ( (unsigned __int8)(v31 - 48) > 9u )
      {
        if ( v173 != 16 )
        {
          v203 = &v24[v32];
          v27 = v24;
          v212 = 0;
          v33 = *(_BYTE *)(v193 + 4 * v31);
LABEL_70:
          if ( v173 == 16 || v33 != 101 )
            goto LABEL_75;
          v34 = v24[1];
          if ( (_BYTE)v34 == 45 )
            goto LABEL_73;
LABEL_117:
          if ( (_BYTE)v34 == 43 )
          {
            v35 = v24 + 2;
            v34 = v24[2];
          }
          else
          {
            v35 = v24 + 1;
          }
          v220 = 0;
          if ( (unsigned __int8)(v34 - 48) <= 9u )
            goto LABEL_120;
LABEL_74:
          v27 = v24;
          goto LABEL_75;
        }
        if ( (unsigned __int8)(*(_BYTE *)(v193 + 4 * (char)v31) - 97) > 5u )
          break;
      }
      if ( (_BYTE)v31 != 48 && v28 == -1 )
        v28 = v24 - v181;
      v31 = *++v24;
    }
    v203 = &v24[v32];
    LOBYTE(v47) = *(_DWORD *)(v193 + 4 * (char)v31);
  }
  v33 = v47;
  v212 = v173 == 16 && (_BYTE)v47 == 112;
  if ( !v212 )
  {
    v212 = v173 == 16;
    v27 = v24;
    goto LABEL_70;
  }
  v34 = v24[1];
  if ( (_BYTE)v34 != 45 )
    goto LABEL_117;
LABEL_73:
  v34 = v24[2];
  v35 = v24 + 2;
  v220 = 1;
  if ( (unsigned __int8)(v34 - 48) > 9u )
    goto LABEL_74;
LABEL_120:
  if ( v212 )
  {
    if ( v220 )
    {
      v183 = 4LL * v198 + 1074;
      v206 = v183 / 10;
    }
    else if ( v198 )
    {
      if ( v28 )
        _assert_fail(
          "lead_zero == 0 && int_no <= (uintmax_t) INTMAX_MAX / 4",
          "strtod_l.c",
          886,
          "____strtod_l_internal");
      v58 = 4 * (256LL - v198) + 3;
LABEL_184:
      v183 = v58;
      if ( v58 < 0 )
        v183 = 0LL;
      v206 = v183 / 10;
    }
    else if ( v28 == -1 )
    {
      v206 = 102LL;
      v183 = 1027LL;
    }
    else
    {
      v183 = 4LL * v28 + 1027;
      v206 = v183 / 10;
    }
  }
  else
  {
    if ( v220 )
    {
      v183 = v198 + 360LL;
      v206 = v183 / 10;
      goto LABEL_123;
    }
    if ( v198 )
    {
      if ( v28 )
        _assert_fail("lead_zero == 0 && int_no <= (uintmax_t) INTMAX_MAX", "strtod_l.c", 918, "____strtod_l_internal");
      v58 = 309LL - v198;
      goto LABEL_184;
    }
    if ( v28 == -1 )
    {
      v206 = 30LL;
      v183 = 309LL;
    }
    else
    {
      v183 = v28 + 309LL;
      v206 = v183 / 10;
    }
  }
LABEL_123:
  v48 = v183 % 10;
  v49 = v226;
  v223 = j;
  v50 = v28;
  v216 = 0;
  v224 = v24;
  v184 = v35;
  while ( 2 )
  {
    if ( v206 < v49 )
    {
      v51 = v184;
      v52 = v50;
      if ( v216 )
        v226 = v49;
LABEL_127:
      if ( v52 == -1 )
      {
        result = 0.0;
        if ( v211 )
          result = -0.0;
        goto LABEL_132;
      }
      __writegsdword(0xFFFFFFE8, 0x22u);
      if ( v220 )
      {
        v53 = 2.225073858507201e-308;
        if ( v211 )
        {
          v54 = 2.225073858507201e-308 * -2.225073858507201e-308;
          goto LABEL_131;
        }
      }
      else
      {
        v53 = 1.797693134862316e308;
        if ( v211 )
        {
          v54 = 1.797693134862316e308 * -1.797693134862316e308;
          goto LABEL_131;
        }
      }
      v54 = v53 * v53;
LABEL_131:
      v231[0] = v54;
      result = (double)v54;
      do
LABEL_132:
        ++v51;
      while ( (unsigned __int8)(*v51 - 48) <= 9u );
      if ( a2 )
        *a2 = v51;
      return result;
    }
    v59 = v34 - 48;
    v60 = v59 >> 31;
    v61 = v59;
    if ( v49 == v206 && v59 > v48 )
    {
      v51 = v184;
      v52 = v50;
      if ( v216 )
        v226 = v206;
      goto LABEL_127;
    }
    v216 = 1;
    v62 = 10 * HIDWORD(v49);
    v63 = 10LL * (unsigned int)v49;
    HIDWORD(v63) += v62;
    v49 = __PAIR64__(v60, v61) + v63;
    v34 = *++v184;
    if ( (unsigned __int8)(v34 - 48) <= 9u )
      continue;
    break;
  }
  v28 = v50;
  v24 = v224;
  v27 = v184;
  j = v223;
  v226 = v49;
  if ( v220 )
    v226 = -v49;
LABEL_75:
  if ( v198 < (unsigned int)v203 )
  {
    if ( *(v24 - 1) != 48 )
      goto LABEL_50;
    v36 = v203 - v24;
    do
      --v24;
    while ( *(v24 - 1) == 48 );
    if ( v198 > (unsigned int)&v24[v36] )
      _assert_fail("dig_no >= int_no", "strtod_l.c", 993, "____strtod_l_internal");
    v203 = &v24[v36];
  }
  if ( (char *)v198 != v203 || !v203 )
  {
LABEL_50:
    if ( a2 )
      goto LABEL_51;
    goto LABEL_52;
  }
  v37 = v226;
  if ( v226 < 0 )
  {
    v185 = 1LL;
    if ( v212 )
      v185 = 4LL;
    v217 = j;
    v77 = v24 - 1;
    v78 = 0;
    v195 = v27;
    v207 = v28;
    v79 = v198;
    while ( 1 )
    {
      v83 = *v77;
      if ( v212 )
      {
        v80 = ((*(_WORD *)(a4[13] + 2 * v83) >> 12) ^ 1) & 1;
      }
      else
      {
        LOBYTE(v27) = (unsigned int)(v83 - 48) > 9;
        v80 = (int)v27;
      }
      v27 = (char *)v80;
      if ( !(_BYTE)v80 )
      {
        if ( *v77 != 48 )
        {
          v198 = v79;
          v27 = v195;
          v28 = v207;
          j = v217;
          if ( (_BYTE)v78 )
            v226 = v37;
          goto LABEL_50;
        }
        --v79;
        v37 += v185;
        v81 = v203-- == (char *)1;
        LOBYTE(v78) = !v81;
        v82 = v78;
        v78 = (char *)(HIDWORD(v37) >> 31);
        v27 = v82;
        LOBYTE(v78) = (unsigned __int8)v82 & (v37 < 0);
        if ( !(_BYTE)v78 )
        {
          v198 = v79;
          v27 = v195;
          v28 = v207;
          v226 = v37;
          j = v217;
          goto LABEL_50;
        }
      }
      --v77;
    }
  }
  if ( a2 )
  {
LABEL_51:
    *a2 = v27;
LABEL_52:
    if ( v203 )
      goto LABEL_85;
    goto LABEL_53;
  }
LABEL_85:
  if ( !v28 )
    goto LABEL_99;
  v38 = *j;
  v39 = v208[1];
  while ( 2 )
  {
    if ( *v208 != v38 )
    {
      v38 = j[1];
LABEL_88:
      ++j;
      continue;
    }
    break;
  }
  if ( !v39 )
    goto LABEL_95;
  v38 = j[1];
  if ( v38 != v39 )
    goto LABEL_88;
  v40 = 1;
  while ( 1 )
  {
    v41 = v208[++v40];
    if ( !v41 )
      break;
    if ( v41 != j[v40] )
    {
      v38 = v208[1];
      goto LABEL_88;
    }
  }
LABEL_95:
  if ( v173 == 16 )
  {
    v182 = v226;
    if ( v28 > (v226 + 0x8000000000000000LL) >> 2 )
      goto LABEL_239;
    v42 = 4LL * v28;
  }
  else
  {
    v182 = v226;
    if ( HIDWORD(v226) == 0x80000000 && v28 > (unsigned int)v226 )
LABEL_239:
      _assert_fail(
        "lead_zero <= (base == 16 ? ((uintmax_t) exponent - (uintmax_t) INTMAX_MIN) / 4 : ((uintmax_t) exponent - (uintma"
        "x_t) INTMAX_MIN))",
        "strtod_l.c",
        1048,
        "____strtod_l_internal");
    v42 = v28;
  }
  j += v215 + v28;
  v203 -= v28;
  v226 = v182 - v42;
LABEL_99:
  if ( v173 == 16 )
  {
    v70 = a4[13];
    v71 = *j;
    for ( m = *j; (*(_BYTE *)(v70 + 2 * v71 + 1) & 0x10) == 0; m = *j )
      v71 = *++j;
    if ( m == 48 )
    {
      do
        ++j;
      while ( *j == 48 );
      v71 = *j;
    }
    v73 = v71 - 48;
    v74 = j + 1;
    if ( (unsigned int)(v71 - 48) > 9 )
      v73 = *(_DWORD *)(a4[14] + 4 * v71) - 87;
    v175 = nbits_11199[v73];
    if ( !v175 )
      _assert_fail("bits != 0", "strtod_l.c", 1072, "____strtod_l_internal");
    v75 = 20 - v175;
    HIDWORD(v227) = v73 << (21 - v175);
    if ( v226 < 0 )
      v76 = (__int64)(0x8000000000000000LL - v175) >> 2;
    else
      v76 = (0x7FFFFFFFFFFFFFFFLL - v226 - v175 + 1) / 4;
    if ( v198 > v76 )
      _assert_fail(
        "int_no <= (uintmax_t) (exponent < 0 ? (INTMAX_MAX - bits + 1) / 4 : (INTMAX_MAX - exponent - bits + 1) / 4)",
        "strtod_l.c",
        1093,
        "____strtod_l_internal");
    v112 = v203;
    v196 = v226 + v175 - 1 + 4 * (v198 - 1LL);
    v177 = 1;
    v226 = v196;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v112 == (char *)1 )
        {
          if ( v177 == 1 )
            LODWORD(v227) = 0;
          return round_and_return_0((unsigned int *)&v227, v196, SHIDWORD(v196), v211, 0, 0, 0);
        }
        v113 = (char)*v74;
        if ( (*(_BYTE *)(v70 + 2 * v113 + 1) & 0x10) == 0 )
        {
          v74 += v215;
          v113 = (char)*v74;
        }
        v114 = v113 - 48;
        ++v74;
        if ( (unsigned int)(v113 - 48) > 9 )
          v114 = *(_DWORD *)(a4[14] + 4 * v113) - 87;
        if ( v75 <= 2 )
          break;
        v115 = v75 - 3;
        v75 -= 4;
        *((_DWORD *)&v227 + v177) |= v114 << v115;
        --v112;
      }
      v116 = v177;
      *((_DWORD *)&v227 + v177) |= v114 >> (3 - v75);
      v117 = v114 << (v75 + 29);
      if ( !v177 )
        break;
      LODWORD(v227) = v117;
      v75 += 28;
      --v112;
      v177 = 0;
    }
    v161 = v112 - 2;
    if ( v161 )
    {
      if ( *v74 == 48 )
      {
        v162 = v74 + 1;
        v163 = &v74[(_DWORD)v161];
        while ( v163 != v162 )
        {
          if ( *v162++ != 48 )
            goto LABEL_437;
        }
      }
      else
      {
LABEL_437:
        v116 = 1;
      }
    }
    return round_and_return_0((unsigned int *)&v227, v196, SHIDWORD(v196), v211, v117, 31, v116);
  }
  if ( v226 < 0 )
  {
    v43 = -(__int64)v198;
    if ( v43 < v226 )
      goto LABEL_102;
  }
  else
  {
    v43 = (signed __int64)&v203[-(unsigned __int64)v198];
    if ( v43 > v226 )
LABEL_102:
      v43 = v226;
  }
  v174 = v43 + v198;
  v226 -= v43;
  v221 = (unsigned int)v43 + v198;
  if ( v226 > 309 - v221 )
  {
    v44 = 1.797693134862316e308;
    __writegsdword(0xFFFFFFE8, 0x22u);
    if ( v211 )
    {
      v45 = 1.797693134862316e308 * -1.797693134862316e308;
      goto LABEL_106;
    }
LABEL_411:
    v45 = v44 * v44;
    goto LABEL_106;
  }
  if ( v226 >= -324 )
  {
    v194 = 0;
    if ( !v174 )
      goto LABEL_165;
    j = str_to_mpn_isra_0_0(j, v174, (int *)&v229, &v225, (unsigned int *)&v226, v215, v209);
    v147 = v226;
    if ( v226 > 0 )
    {
      v197 = 1;
      v214 = v231;
      v191 = v225;
      v200 = &fpioconst_pow10;
      for ( n = &v229; ; n = (unsigned int *)v150 )
      {
        while ( !((unsigned int)v147 & v197 | HIDWORD(v147) & (v197 >> 31)) )
        {
          v197 *= 2;
          v200 += 4;
        }
        v226 = v197 ^ (unsigned __int64)v147;
        v148 = v200[1] - 2;
        if ( v148 > v191 )
          v149 = _mpn_mul(v214, &dword_80D0BC8[*v200], v148, n, v191);
        else
          v149 = _mpn_mul(v214, n, v191, &dword_80D0BC8[*v200], v200[1] - 2);
        v191 = v225 + v148;
        v225 += v148;
        if ( !v149 )
          v225 = --v191;
        v147 = v226;
        v197 *= 2;
        v200 += 4;
        if ( !v226 )
          break;
        v150 = v214;
        v214 = (double *)n;
      }
      v151 = v191;
      if ( v214 == v231 )
        memcpy(&v229, v214, 4 * v191);
    }
    else
    {
      v151 = v225;
    }
    v201 = v151 - 1;
    _BitScanReverse(&v152, *(&v229 + v151 - 1));
    v194 = 32 * v151 - (v152 ^ 0x1F);
    if ( v194 > 1024 )
    {
      __writegsdword(0xFFFFFFE8, 0x22u);
      if ( v211 )
        v169 = 1.797693134862316e308 * -1.797693134862316e308;
      else
        v169 = 1.797693134862316e308 * 1.797693134862316e308;
      *(double *)&v227 = v169;
      return (double)v169;
    }
    if ( v194 > 53 )
    {
      v153 = (v194 - 53) >> 5;
      v154 = (v194 - 53) & 0x1F;
      if ( !v154 )
      {
        v155 = v153 - 1;
        v156 = v230[v153];
        v157 = 31;
        LODWORD(v227) = v230[v153 - 1];
        v158 = *(&v229 + v153 - 1);
        HIDWORD(v227) = v156;
        v192 = v158;
LABEL_384:
        v159 = 0;
        if ( !v229 )
        {
          do
            ++v159;
          while ( !v230[v159 - 1] );
        }
        return round_and_return_0(
                 (unsigned int *)&v227,
                 v194 - 1,
                 (v194 - 1) >> 31,
                 v211,
                 v192,
                 v157,
                 ((unsigned int)v203 > v174) | (unsigned __int8)(v159 < v155));
      }
      v157 = v154 - 1;
      if ( v201 <= v153 )
      {
        v170 = v230[v153 - 1];
        v192 = v170;
      }
      else
      {
        v170 = v230[v153];
        v192 = v230[v153 - 1];
        LODWORD(v227) = (v170 << (32 - v154)) | (v192 >> v154);
        if ( v153 + 1 < v201 )
        {
          v171 = v170 >> v154;
          v170 = v230[v153 + 1];
          HIDWORD(v227) = (v170 << (32 - v154)) | v171;
        }
        if ( v201 - v153 > 1 )
        {
          v155 = (v194 - 53) >> 5;
          goto LABEL_384;
        }
      }
      HIDWORD(v227) = v170 >> v154;
      v155 = (v194 - 53) >> 5;
      goto LABEL_384;
    }
    if ( v203 != (char *)v174 )
    {
      memcpy(&v227, &v229, 4 * v151);
      if ( v151 <= 1 )
        *((_DWORD *)&v227 + v151) = 0;
LABEL_165:
      if ( (unsigned int)v203 <= v174 || (unsigned __int64)(v226 + 324) > 0x144 )
        _assert_fail(
          "dig_no > int_no && exponent <= 0 && exponent >= MIN_10_EXP - (DIG + 2)",
          "strtod_l.c",
          1332,
          "____strtod_l_internal");
      if ( v194 <= 0 )
      {
        if ( v174 || *j == 48 )
          _assert_fail("int_no == 0 && *startp != L_('0')", "strtod_l.c", 1348, "____strtod_l_internal");
        v85 = v226;
        v160 = 1076;
        if ( (int)(10 * (1 - v226) / 3 + 54) <= 1076 )
          v160 = 10 * (1 - v226) / 3 + 54;
        v84 = v226 + v160;
        if ( v84 <= 0 )
          _assert_fail("need_frac_digits > 0", "strtod_l.c", 1369, "____strtod_l_internal");
      }
      else
      {
        if ( v226 || !v174 )
          _assert_fail("int_no > 0 && exponent == 0", "strtod_l.c", 1342, "____strtod_l_internal");
        v84 = 54 - v194;
        v85 = 0;
      }
      v186 = v84;
      if ( v84 > (int)&v203[-v221] )
      {
        v84 = (int)&v203[-v174];
        v186 = (int)&v203[-v174];
      }
      if ( (unsigned int)v203 <= v221 + v186 )
      {
        v218 = 0;
      }
      else
      {
        v218 = 1;
        v203 = (char *)(v174 + v84);
      }
      v86 = (int)&v203[-v174];
      v222 = j;
      v87 = &fpioconst_pow10;
      v176 = (int *)&v229;
      v204 = v86;
      v88 = v86 - v85;
      v89 = (unsigned int *)v231;
      v90 = 1;
      v91 = 0;
      v92 = v88;
      do
      {
        if ( (v92 & v90) != 0 )
        {
          v92 ^= v90;
          if ( v91 )
          {
            v188 = v89;
            v93 = _mpn_mul(v176, &dword_80D0BC8[*v87], v87[1] - 2, v89, v91);
            v91 = v91 + v87[1] - 2;
            if ( v93 )
            {
              v94 = (int *)v188;
            }
            else
            {
              v94 = (int *)v188;
              --v91;
            }
            v89 = (unsigned int *)v176;
            v176 = v94;
          }
          else
          {
            v91 = v87[1] - 2;
            v187 = v89;
            memcpy(v89, &dword_80D0BC8[*v87], 4 * v91);
            v89 = v187;
          }
        }
        v90 *= 2;
        v87 += 4;
      }
      while ( v92 );
      LOBYTE(v213) = 0;
      v199 = v91;
      if ( v89 == &v229 )
        memcpy(v231, &v229, 4 * v91);
      str_to_mpn_isra_0_0(v222, v204, (int *)&v229, &v225, (unsigned int *)&v226, v215, v209);
      _BitScanReverse(&v95, *((_DWORD *)v231 + v91 - 1));
      v205 = v91 - 1;
      v96 = v95 ^ 0x1F;
      if ( v96 && (_mpn_lshift(v231, (int)v231, v91, v96), (v97 = _mpn_lshift(&v229, (int)&v229, v225, v96)) != 0) )
      {
        v98 = v225 + 1;
        v230[v225 - 1] = v97;
        v225 = v98;
      }
      else
      {
        v98 = v225;
      }
      v226 = v194;
      if ( v91 == 1 )
      {
        v118 = v229;
        if ( v229 >= LODWORD(v231[0]) || v98 != 1 )
          _assert_fail("numsize == 1 && n < d", "strtod_l.c", 1469, "____strtod_l_internal");
        for ( ii = v194; ; ii += 32 )
        {
          while ( 1 )
          {
            LODWORD(v121) = 0;
            HIDWORD(v121) = v118;
            LODWORD(v120) = v121 / LODWORD(v231[0]);
            HIDWORD(v120) = v121 % LODWORD(v231[0]);
            v118 = HIDWORD(v120);
            if ( ii )
              break;
            while ( !(_DWORD)v120 )
            {
              v226 -= 32LL;
              v124 = v120 % LODWORD(v231[0]);
              LODWORD(v120) = v120 / LODWORD(v231[0]);
              HIDWORD(v120) = v124;
            }
            v122 = v120;
            _BitScanReverse((unsigned int *)&v120, v120);
            v118 = HIDWORD(v120);
            v123 = (int)(v120 ^ 0x1F);
            ii = 32 - v123;
            v226 -= v123;
            v227 = v122;
          }
          if ( ii > 21 )
            break;
          HIDWORD(v120) = v227;
          v227 = v120;
        }
        v125 = ii;
        v126 = v120;
        v127 = 53 - v125;
        v128 = HIDWORD(v120);
        if ( v125 != 53 )
        {
          _mpn_lshift(&v227, (int)&v227, 2, 53 - v125);
          LODWORD(v227) = (v126 >> (32 - v127)) | v227;
        }
        return round_and_return_0(
                 (unsigned int *)&v227,
                 (int)v226 - 1,
                 (unsigned __int64)(v226 - 1) >> 32,
                 v211,
                 v126,
                 31 - v127,
                 v218 | (unsigned int)(v128 != 0));
      }
      if ( v91 == 2 )
      {
        v99 = HIDWORD(v231[0]);
        v100 = LODWORD(v231[0]);
        if ( v98 > 1 )
        {
          v101 = v230[0];
          v102 = v229;
          goto LABEL_276;
        }
        v101 = v229;
        if ( HIDWORD(v231[0]) <= v229 )
        {
          v102 = v229;
          v101 = 0;
          goto LABEL_276;
        }
        if ( v194 <= 0 )
        {
          LODWORD(v226) = v194 - 32;
          v102 = 0;
          HIDWORD(v226) = __CFADD__(v194, -32) + (v194 >> 31) - 1;
          goto LABEL_276;
        }
        if ( v194 <= 21 )
        {
          v168 = v227;
          LODWORD(v227) = 0;
          HIDWORD(v227) = v168;
        }
        else
        {
          LOBYTE(v213) = 53 - v194;
          if ( v194 != 53 )
          {
            v189 = HIDWORD(v231[0]);
            _mpn_lshift(&v227, (int)&v227, 2, 53 - v194);
            v101 = v229;
            v99 = v189;
          }
        }
        v194 += 32;
        v102 = 0;
        v103 = 0;
        if ( v194 > 53 )
          return round_and_return_0(
                   (unsigned int *)&v227,
                   (int)v226 - 1,
                   (unsigned __int64)(v226 - 1) >> 32,
                   v211,
                   v102,
                   31 - (unsigned __int8)v213,
                   (unsigned __int8)(v218 | (v103 != 0 || v101 != 0)));
LABEL_276:
        while ( v101 == v99 )
        {
          v108 = __CFADD__(v102, v101);
          v105 = v102 + v101;
          if ( v108 )
          {
            v101 = (v100 + __PAIR64__(v105 - v100, 0)) >> 32;
            v102 = v100;
            if ( !v194 )
            {
              v194 = 32;
              v190 = 0LL;
              v111 = -1;
              goto LABEL_285;
            }
            v103 = v100;
            v102 = -1;
LABEL_289:
            if ( v194 > 21 )
            {
              LOBYTE(v213) = 53 - v194;
              if ( v194 != 53 )
              {
                _mpn_lshift(&v227, (int)&v227, 2, 53 - v194);
                LODWORD(v227) = (v102 >> (32 - (53 - v194))) | v227;
              }
              return round_and_return_0(
                       (unsigned int *)&v227,
                       (int)v226 - 1,
                       (unsigned __int64)(v226 - 1) >> 32,
                       v211,
                       v102,
                       31 - (unsigned __int8)v213,
                       (unsigned __int8)(v218 | (v103 != 0 || v101 != 0)));
            }
            v227 = __PAIR64__(v227, v102);
            v102 = v103;
            v194 += 32;
          }
          else
          {
            v107 = -v100;
            v102 = -1;
            v106 = v100 - (v100 != 0);
            do
            {
LABEL_278:
              if ( v106 <= v105 && (v106 != v105 || !v107) )
                break;
              --v102;
              v106 = (__PAIR64__(v106, v107) - v100) >> 32;
              v107 -= v100;
              v108 = __CFADD__(v99, v105);
              v105 += v99;
            }
            while ( !v108 );
            v109 = -v107;
            v101 = (__PAIR64__(v105, 0) - __PAIR64__(v106, v107)) >> 32;
            v103 = -v107;
            if ( v194 )
              goto LABEL_289;
            if ( v102 )
            {
              _BitScanReverse((unsigned int *)&v110, v102);
              v110 ^= 0x1Fu;
              v190 = v110;
              v194 = 32 - v110;
              v111 = v102;
              v102 = v109;
            }
            else
            {
              v111 = 0;
              v102 = -v107;
              v190 = 32LL;
            }
LABEL_285:
            v226 -= v190;
            v227 = (unsigned int)v111;
          }
        }
        v104 = __PAIR64__(v101, v102) % v99;
        v102 = __PAIR64__(v101, v102) / v99;
        v105 = v104;
        v106 = (v102 * (unsigned __int64)v100) >> 32;
        v107 = v102 * v100;
        goto LABEL_278;
      }
      v178 = *((_DWORD *)v231 + v205);
      v129 = *((_DWORD *)&v231[-1] + v91);
      v130 = _mpn_cmp((int)&v229, (int)v231 + 4 * (v199 - v98), v98);
      v131 = v225;
      if ( v130 > 0 )
      {
        v131 = v225 + 1;
        v230[v225 - 1] = 0;
        v225 = v131;
      }
      if ( v199 <= v131 )
      {
        if ( v199 != v131 )
          _assert_fail("numsize == densize", "strtod_l.c", 1680, "____strtod_l_internal");
        if ( v199 > 0 )
        {
          v164 = v199;
          do
          {
            --v164;
            v230[v164] = v230[v164 - 1];
          }
          while ( v164 );
        }
        v229 = 0;
        *((_DWORD *)v231 + v199) = 0;
        v138 = v230[v199 - 1];
      }
      else
      {
        v132 = v199 - v131;
        v133 = v199 - v131;
        if ( v194 <= 0 )
        {
          v226 -= 32 * v132;
        }
        else
        {
          v134 = 32 * v132 + v194;
          if ( v134 > 53 )
          {
            v213 = 53 - v194;
            if ( 53 - v194 > 31 )
            {
              _mpn_lshift((_DWORD *)&v227 + 1, (int)&v227, 1, (53 - v194) & 0x1F);
              LODWORD(v227) = 0;
              v131 = v225;
              v194 = v134;
            }
            else
            {
              v194 += 32 * v132;
              if ( v213 )
              {
                _mpn_lshift(&v227, (int)&v227, 2, v213);
                v131 = v225;
              }
            }
          }
          else
          {
            if ( v133 != 1 )
              _assert_fail("empty == 1", "strtod_l.c", 1643, "____strtod_l_internal");
            v135 = v227;
            v194 = v134;
            LODWORD(v227) = 0;
            HIDWORD(v227) = v135;
          }
        }
        if ( v131 > 0 )
        {
          v136 = (char *)&v230[v131 - 2];
          do
          {
            *(_DWORD *)&v136[4 * v133 + 4] = *(_DWORD *)v136;
            v136 -= 4;
          }
          while ( &v228 != v136 );
        }
        v137 = (int *)&v229;
        do
          *v137++ = 0;
        while ( v137 != &v230[v133] );
        *((_DWORD *)v231 + v199) = 0;
        v138 = v230[v199 - 1];
        if ( v194 > 53 )
        {
          v139 = 0;
LABEL_360:
          v146 = v199;
          if ( v199 < 0 || v230[v199 - 1] )
          {
            v146 = v199;
          }
          else
          {
            do
              --v146;
            while ( v146 != -1 && !v230[v146 - 1] );
          }
          return round_and_return_0(
                   (unsigned int *)&v227,
                   (int)v226 - 1,
                   (unsigned __int64)(v226 - 1) >> 32,
                   v211,
                   v139,
                   31 - (unsigned __int8)v213,
                   v218 | (unsigned int)(v146 >= 0));
        }
      }
      while ( 1 )
      {
        while ( 1 )
        {
          v139 = -1;
          if ( v178 != v138 )
          {
            v210 = v230[v205 - 1];
            v139 = __PAIR64__(v138, v210) / v178;
            v140 = __PAIR64__(v138, v210) % v178;
            v141 = v139 * v129;
            v142 = (v139 * (unsigned __int64)v129) >> 32;
            while ( v142 > v140 || v142 == v140 && v141 > *(&v229 + v199 - 2) )
            {
              --v139;
              v108 = __CFADD__(v178, v140);
              v140 += v178;
              if ( v108 )
                break;
              v142 = (__PAIR64__(v142, v141) - v129) >> 32;
              v141 -= v129;
            }
          }
          if ( _mpn_submul_1((int)&v229, (int)v231, v199 + 1, v139) != v230[v199 - 1] )
          {
            if ( !_mpn_add_n(&v229, &v229, v231, v199) )
              _assert_fail("cy != 0", "strtod_l.c", 1722, "____strtod_l_internal");
            --v139;
          }
          v138 = v230[v205 - 1];
          v230[v199 - 1] = v138;
          if ( v205 > 0 )
          {
            v143 = (char *)&v227 + 4 * v199 + 4;
            do
            {
              v144 = *(_DWORD *)v143;
              v143 -= 4;
              *((_DWORD *)v143 + 2) = v144;
            }
            while ( v143 != &v228 );
          }
          v229 = 0;
          if ( v194 )
            break;
          if ( v139 )
          {
            _BitScanReverse((unsigned int *)&v145, v139);
            v145 ^= 0x1Fu;
            v227 = v139;
            v194 = 32 - v145;
            v226 -= v145;
          }
          else
          {
            v108 = __CFADD__((_DWORD)v226, -32);
            LODWORD(v226) = v226 - 32;
            HIDWORD(v226) = v108 + HIDWORD(v226) - 1;
            v227 = 0LL;
          }
        }
        if ( v194 > 21 )
          break;
        v227 = __PAIR64__(v227, v139);
        v194 += 32;
      }
      LOBYTE(v213) = 53 - v194;
      if ( v194 != 53 )
      {
        _mpn_lshift(&v227, (int)&v227, 2, 53 - v194);
        LODWORD(v227) = (v139 >> (32 - (53 - v194))) | v227;
      }
      goto LABEL_360;
    }
    v165 = (v194 - 1) % 32;
    if ( v165 == 20 )
    {
      v172 = 2 - v151;
      memcpy((_BYTE *)&v227 + 4 * (2 - v151), &v229, 4 * v151);
      if ( 2 - v151 <= 0 )
        return round_and_return_0((unsigned int *)&v227, v194 - 1, (v194 - 1) >> 31, v211, 0, 0, 0);
    }
    else
    {
      if ( v165 > 19 )
      {
        if ( v151 > 1 )
          _assert_fail("numsize < RETURN_LIMB_SIZE", "strtod_l.c", 1288, "____strtod_l_internal");
        v166 = _mpn_rshift((int)&v227 + 4 * (2 - v151), &v229, v151, v165 - 20);
        v167 = 1 - v225;
        *((_DWORD *)&v227 + v167) = v166;
        if ( v167 <= 0 )
          return round_and_return_0((unsigned int *)&v227, v194 - 1, (v194 - 1) >> 31, v211, 0, 0, 0);
        LODWORD(v227) = 0;
        if ( v167 == 1 )
          return round_and_return_0((unsigned int *)&v227, v194 - 1, (v194 - 1) >> 31, v211, 0, 0, 0);
LABEL_426:
        HIDWORD(v227) = 0;
        return round_and_return_0((unsigned int *)&v227, v194 - 1, (v194 - 1) >> 31, v211, 0, 0, 0);
      }
      _mpn_lshift((_DWORD *)&v227 + 2 - v151, (int)&v229, v151, 20 - v165);
      v172 = 2 - v225;
      if ( 2 - v225 <= 0 )
        return round_and_return_0((unsigned int *)&v227, v194 - 1, (v194 - 1) >> 31, v211, 0, 0, 0);
    }
    LODWORD(v227) = 0;
    if ( v172 == 1 )
      return round_and_return_0((unsigned int *)&v227, v194 - 1, (v194 - 1) >> 31, v211, 0, 0, 0);
    goto LABEL_426;
  }
  v44 = 2.225073858507201e-308;
  __writegsdword(0xFFFFFFE8, 0x22u);
  if ( !v211 )
    goto LABEL_411;
  v45 = 2.225073858507201e-308 * -2.225073858507201e-308;
LABEL_106:
  v231[0] = v45;
  return (double)v45;
}
// 8048280: using guessed type int __cdecl j_strncasecmp_l(_DWORD, _DWORD, _DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80C1540: using guessed type int dword_80C1540[256];
// 80CC680: using guessed type void **nl_C_locobj[6];
// 80D0BC8: using guessed type unsigned int dword_80D0BC8[3438];
// 80D60E0: using guessed type int nbits_11199[16];

//----- (080B0C80) --------------------------------------------------------
void __cdecl strtod_l(unsigned int a1, _DWORD *a2, _DWORD *a3)
{
  ___strtod_l_internal(a1, a2, 0, a3);
}

//----- (080B0CA0) --------------------------------------------------------
int __usercall round_away_1@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4, int a5)
{
  int result; // eax
  bool v6; // zf
  int v7; // edx

  if ( a5 == 1024 )
  {
    v6 = a1 == 0;
    result = 0;
    if ( !v6 )
      return a3 | a4;
  }
  else if ( a5 <= 1024 )
  {
    if ( a5 )
      goto LABEL_13;
    v7 = a4 | a2;
    result = 0;
    if ( (_BYTE)a3 )
      return v7;
  }
  else
  {
    if ( a5 != 2048 )
    {
      result = 0;
      if ( a5 == 3072 )
        return result;
LABEL_13:
      abort(a3);
    }
    v6 = a1 == 0;
    result = 0;
    if ( v6 )
      return a3 | a4;
  }
  return result;
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080B0D20) --------------------------------------------------------
long double __usercall round_and_return_1@<st0>(
        unsigned int *a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        int a4,
        unsigned int a5,
        char a6,
        int a7)
{
  int v7; // edi
  int v8; // esi
  __int16 v10; // ax
  bool v11; // cc
  int v13; // eax
  unsigned int v14; // ebp
  int v15; // edx
  int v16; // edx
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  bool v21; // zf
  int v22; // edi
  int v23; // kr00_4
  unsigned int v24; // eax
  unsigned int v25; // ebp
  int v26; // ecx
  char v27; // si
  int v28; // [esp+4h] [ebp-38h]
  int v29; // [esp+8h] [ebp-34h]
  bool v30; // [esp+Ch] [ebp-30h]
  __int16 v31; // [esp+1Eh] [ebp-1Eh]

  v7 = a3;
  v8 = a2;
  v10 = v31 & 0xC00;
  if ( (v31 & 0xC00) == 1024 )
  {
    v28 = 1024;
    goto LABEL_5;
  }
  if ( (v31 & 0xC00u) <= 0x400 )
  {
    v28 = 0;
    if ( !v10 )
      goto LABEL_5;
LABEL_19:
    abort(a3);
  }
  if ( v10 == 2048 )
  {
    v11 = a3 < -1;
    v28 = 2048;
    if ( a3 > -1 )
      goto LABEL_47;
    goto LABEL_10;
  }
  v28 = 3072;
  if ( v10 != 3072 )
    goto LABEL_19;
LABEL_5:
  v11 = a3 < -1;
  if ( a3 > -1 )
  {
LABEL_47:
    if ( __SPAIR64__(a3, a2) > 0x4000 )
    {
LABEL_7:
      __writegsdword(0xFFFFFFE8, 0x22u);
      if ( a4 )
        return -1.189731495357231765e4932 * 1.189731495357231765e4932;
      else
        return 1.189731495357231765e4932 * 1.189731495357231765e4932;
    }
    v29 = (a5 >> a6) & 1;
    v14 = *a1;
    v30 = a4 != 0;
    v15 = *a1 & 1;
    goto LABEL_36;
  }
LABEL_10:
  if ( !v11 )
  {
    if ( a2 >= 0xFFFFC002 )
      goto LABEL_47;
    if ( a3 >= -1 && a2 >= 0xFFFFBFC2 )
    {
      v13 = -16382 - a2;
      a7 |= (((1 << a6) - 1) & a5) != 0;
      if ( a2 == -16446 )
      {
        v24 = a1[1];
        v25 = *a1;
        a1[1] = 0;
        *a1 = 0;
        a6 = 31;
        a5 = v24;
        v15 = 0;
        a7 |= v25 != 0;
        v14 = 0;
      }
      else if ( v13 > 31 )
      {
        v16 = (v13 - 1) >> 5;
        a6 = (v13 - 1) & 0x1F;
        a5 = a1[v16];
        if ( v16 == 1 )
          a7 |= *a1 != 0;
        a7 |= (((1 << a6) - 1) & a5) != 0;
        v17 = v13 & 0x1F;
        if ( v17 )
        {
          _mpn_rshift((int)a1, a1 + 1, 1, v17);
          v14 = *a1;
        }
        else
        {
          v14 = a1[1];
          *a1 = v14;
        }
        a1[1] = 0;
        v15 = v14 & 1;
      }
      else
      {
        if ( v13 == 1 )
        {
          v26 = (a5 >> a6) & 1;
          a5 = *a1;
          v30 = a4 != 0;
          v27 = round_away_1(a4 != 0, *a1 & 1, v26, a7 != 0, v28);
          if ( v27 )
          {
            if ( a5 == -1 )
              v27 = a1[1] != -1;
          }
          else
          {
            v27 = 1;
          }
          _mpn_rshift((int)a1, a1, 2, 1);
          if ( !v27 )
          {
            v14 = *a1;
            v8 = -16383;
            a6 = 0;
            v7 = -1;
            v29 = a5 & 1;
            v15 = *a1 & 1;
            goto LABEL_36;
          }
          a6 = 0;
        }
        else
        {
          a5 = *a1;
          a6 = v13 - 1;
          _mpn_rshift((int)a1, a1, 2, v13);
        }
        v14 = *a1;
        v15 = *a1 & 1;
      }
      v18 = (a5 >> a6) & 1;
      v29 = v18;
      if ( !a7 && !(_BYTE)v18 )
      {
        v19 = a5 & ((1 << a6) - 1);
        if ( !v19 )
        {
          v29 = 0;
          v7 = -1;
          v8 = -16383;
          v30 = a4 != 0;
          goto LABEL_38;
        }
      }
      __writegsdword(0xFFFFFFE8, 0x22u);
      v8 = -16383;
      v7 = -1;
      v30 = a4 != 0;
LABEL_36:
      v20 = 1;
      if ( a7 )
      {
LABEL_39:
        if ( !(unsigned __int8)round_away_1(v30, v15, v29, v20, v28) )
          return _mpn_construct_long_double(a1, v8, a4);
        *a1 = v14 + 1;
        if ( v14 != -1 || (v21 = a1[1] == -1, ++a1[1], !v21) )
        {
          if ( !(v8 ^ 0xFFFFC001 | ~v7) )
            LOWORD(v8) = (a1[1] >> 31) - 0x3FFF;
          return _mpn_construct_long_double(a1, v8, a4);
        }
        v23 = v8 + 1;
        v22 = (__PAIR64__(v7, v8) + 1) >> 32;
        LOWORD(v8) = v8 + 1;
        _mpn_rshift((int)a1, a1, 2, 1);
        a1[1] |= 0x80000000;
        if ( v23 ^ 0x4001 | v22 )
          return _mpn_construct_long_double(a1, v8, a4);
        goto LABEL_7;
      }
      v19 = a5 & ((1 << a6) - 1);
LABEL_38:
      v20 = v19 != 0;
      goto LABEL_39;
    }
  }
  __writegsdword(0xFFFFFFE8, 0x22u);
  if ( a4 )
    return -3.3621031431120935063e-4932 * 3.3621031431120935063e-4932;
  else
    return 3.3621031431120935063e-4932 * 3.3621031431120935063e-4932;
}
// 80B0DBE: conditional instruction was optimized away because ecx.4<0
// 80B0D36: variable 'v31' is possibly undefined
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080B11C0) --------------------------------------------------------
char *__usercall str_to_mpn_isra_0_1@<eax>(
        char *a1@<eax>,
        int a2@<edx>,
        int *a3@<ecx>,
        int *a4,
        unsigned int *a5,
        int a6,
        _BYTE *a7)
{
  int v9; // esi
  int v10; // ecx
  int v11; // eax
  bool v12; // zf
  char v13; // al
  int v14; // eax
  char v15; // dl
  int v16; // eax
  int v17; // edx
  _BOOL4 v18; // ecx
  int v19; // esi
  int v20; // edx
  int v21; // ecx
  int v22; // eax
  int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // eax
  int v27; // eax
  int v28; // edx
  _BOOL4 v29; // ecx
  int v30; // edx
  int v31; // eax
  int v32; // edx
  int v33; // edx
  int v34; // ecx
  int v35; // edi
  int v36; // [esp+0h] [ebp-2Ch]
  unsigned int v37; // [esp+0h] [ebp-2Ch]
  int v38; // [esp+4h] [ebp-28h]

  v36 = a2;
  *a4 = 0;
  if ( a2 <= 0 )
    _assert_fail("digcnt > 0", &unk_80D6140, 352, "str_to_mpn");
  v38 = 0;
  v9 = 0;
  v10 = 0;
  while ( 1 )
  {
    v11 = *a1;
    if ( (unsigned __int8)(v11 - 48) <= 9u )
      goto LABEL_7;
    if ( !a7 || (_BYTE)v11 != *a7 )
    {
LABEL_6:
      a1 += a6;
      v11 = *a1;
      goto LABEL_7;
    }
    v13 = a7[1];
    if ( v13 )
    {
      if ( a1[1] != v13 )
        goto LABEL_6;
      v14 = 1;
      while ( 1 )
      {
        v15 = a7[++v14];
        if ( !v15 )
          break;
        if ( a1[v14] != v15 )
          goto LABEL_6;
      }
    }
    else
    {
      v14 = 1;
    }
    a1 += v14;
    v11 = *a1;
LABEL_7:
    ++a1;
    ++v10;
    v12 = v36-- == 1;
    v9 = v11 + 10 * v9 - 48;
    if ( v12 )
      break;
    if ( v10 == 9 )
    {
      if ( v38 )
      {
        v16 = _mpn_mul_1((int)a3, (int)a3, v38, 0x3B9ACA00u);
        v17 = *a4;
        v18 = __CFADD__(*a3, v9);
        *a3 += v9;
        if ( v18 )
        {
          v19 = v17 - 1;
          v20 = 0;
          while ( v19 != v20 )
          {
            v21 = a3[v20 + 1] + 1;
            a3[++v20] = v21;
            if ( v21 )
              goto LABEL_24;
          }
          v12 = v16 == -1;
          v9 = v16 + 1;
          v22 = *a4;
          if ( v12 )
            goto LABEL_25;
LABEL_22:
          if ( v22 > 1715 )
            _assert_fail("*nsize < MPNSIZE", &unk_80D6140, 369, "str_to_mpn");
          a3[v22] = v9;
          v10 = 0;
          v23 = *a4 + 1;
          *a4 = v23;
          v38 = v23;
          v9 = 0;
        }
        else
        {
LABEL_24:
          v12 = v16 == 0;
          v9 = v16;
          v22 = *a4;
          if ( !v12 )
            goto LABEL_22;
LABEL_25:
          v38 = v22;
          v10 = 0;
        }
      }
      else
      {
        *a3 = v9;
        v10 = 0;
        v38 = 1;
        v9 = 0;
        *a4 = 1;
      }
    }
  }
  v37 = *a5;
  v24 = a5[1];
  if ( __SPAIR64__(v24, v37) <= 0 || __SPAIR64__(v24, v37) > 9 - v10 )
  {
    v25 = tens_in_limb[v10];
    if ( v38 )
      goto LABEL_32;
    goto LABEL_29;
  }
  v9 *= tens_in_limb[v37];
  v25 = tens_in_limb[v37 + v10];
  *a5 = 0;
  a5[1] = 0;
  if ( !v38 )
  {
LABEL_29:
    *a3 = v9;
    *a4 = 1;
    return a1;
  }
LABEL_32:
  v27 = _mpn_mul_1((int)a3, (int)a3, v38, v25);
  v28 = *a4;
  v29 = __CFADD__(*a3, v9);
  *a3 += v9;
  if ( v29 )
  {
    v33 = v28 - 1;
    v34 = 0;
    while ( v33 != v34 )
    {
      v35 = a3[v34 + 1];
      a3[++v34] = v35 + 1;
      if ( v35 != -1 )
        goto LABEL_33;
    }
    v30 = 1;
  }
  else
  {
LABEL_33:
    v30 = 0;
  }
  v31 = v30 + v27;
  if ( !v31 )
    return a1;
  v32 = *a4;
  if ( *a4 > 1715 )
    _assert_fail("*nsize < MPNSIZE", &unk_80D6140, 425, "str_to_mpn");
  *a4 = v32 + 1;
  a3[v32] = v31;
  return a1;
}
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80D6200: using guessed type int tens_in_limb[10];

//----- (080B14D0) --------------------------------------------------------
long double __cdecl ___strtold_l_internal(unsigned int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // eax
  unsigned int i; // edx
  int v6; // ecx
  char *v7; // ebx
  int v8; // eax
  int v9; // edx
  char v10; // cl
  int v11; // esi
  char *j; // ebp
  char v13; // di
  char *v14; // esi
  char v15; // bl
  int v16; // eax
  char v17; // dl
  int v18; // eax
  char *k; // eax
  int v20; // eax
  long double result; // fst7
  int v22; // edx
  int v23; // esi
  char *v24; // edi
  char *v25; // eax
  unsigned int v26; // eax
  char *v27; // ecx
  unsigned int v28; // esi
  int v29; // eax
  char v30; // cl
  int v31; // eax
  unsigned int v32; // ecx
  char v33; // al
  int v34; // ebx
  char *v35; // ecx
  int v36; // edx
  __int64 v37; // rax
  char v38; // al
  char v39; // bl
  int v40; // eax
  char v41; // dl
  __int64 v42; // rax
  signed __int64 v43; // rax
  char *v44; // eax
  int v45; // edx
  __int64 v46; // kr08_8
  __int64 v47; // rax
  unsigned int v48; // ebp
  char *v49; // ecx
  unsigned int v50; // esi
  int v51; // eax
  char v52; // cl
  int v53; // eax
  __int64 v54; // rax
  int v55; // ebx
  int v56; // edi
  int v57; // esi
  int v58; // ebx
  __int64 v59; // rax
  unsigned int v60; // eax
  _BYTE *v61; // esi
  _BYTE *v62; // ebx
  int v63; // eax
  char v64; // cl
  unsigned __int8 *v65; // esi
  int v66; // esi
  int v67; // eax
  char m; // dl
  int v69; // edx
  _BYTE *v70; // ebp
  int v71; // edi
  unsigned __int64 v72; // rcx
  char *v73; // edi
  char *v74; // ebx
  unsigned int v75; // ebp
  int v76; // esi
  bool v77; // zf
  char *v78; // esi
  int v79; // esi
  int v80; // ecx
  int v81; // ebx
  int v82; // eax
  _DWORD *v83; // esi
  int v84; // eax
  unsigned int *v85; // edx
  int v86; // ebx
  int v87; // edi
  int v88; // ebp
  int v89; // eax
  int *v90; // eax
  unsigned int v91; // ebx
  unsigned int v92; // ebx
  int v93; // eax
  int v94; // edx
  int v95; // ebp
  int v96; // ecx
  int v97; // ebx
  unsigned int v98; // esi
  int v99; // edi
  unsigned int v100; // edx
  unsigned int v101; // ebx
  unsigned __int8 *v102; // edi
  int v103; // edx
  bool v104; // cf
  int v105; // kr20_4
  int v106; // edx
  int v107; // edi
  char *v108; // ebx
  int v109; // ecx
  unsigned int v110; // eax
  char v111; // cl
  int v112; // edx
  unsigned int v113; // eax
  unsigned int v114; // ecx
  int ii; // esi
  unsigned __int64 v116; // rax
  unsigned __int64 v117; // rtt
  unsigned int v118; // ebx
  __int64 v119; // rax
  unsigned __int64 v120; // rt2
  int v121; // ecx
  unsigned int v122; // esi
  char v123; // bl
  int v124; // edi
  unsigned int v125; // edi
  int v126; // eax
  int v127; // ecx
  int v128; // eax
  int v129; // ebx
  int v130; // esi
  int v131; // eax
  int *v132; // eax
  int *v133; // eax
  int v134; // ecx
  unsigned int v135; // esi
  unsigned int v136; // ecx
  unsigned int v137; // eax
  unsigned int v138; // ebp
  char *v139; // eax
  int v140; // edx
  int v141; // eax
  signed int v142; // eax
  char *v143; // eax
  int v144; // edi
  int v145; // esi
  __int64 v146; // rcx
  int v147; // eax
  int v148; // ebp
  int v149; // eax
  unsigned int *v150; // ebx
  int v151; // ecx
  unsigned int v152; // eax
  int v153; // eax
  char v154; // si
  int v155; // ebx
  int v156; // edx
  char v157; // bp
  unsigned int v158; // eax
  int v159; // eax
  int v160; // ecx
  char *v161; // ebx
  _BYTE *v162; // ecx
  _BYTE *v163; // ebp
  int v164; // eax
  int v165; // esi
  signed int v166; // eax
  unsigned int v167; // ebx
  unsigned int v168; // edi
  int v169; // eax
  int v170; // [esp+Ch] [ebp-3630h]
  unsigned int v171; // [esp+Ch] [ebp-3630h]
  int v172; // [esp+Ch] [ebp-3630h]
  int *v173; // [esp+Ch] [ebp-3630h]
  int v174; // [esp+Ch] [ebp-3630h]
  unsigned int v175; // [esp+Ch] [ebp-3630h]
  char *v176; // [esp+10h] [ebp-362Ch]
  char v177; // [esp+10h] [ebp-362Ch]
  char *v178; // [esp+10h] [ebp-362Ch]
  __int64 v179; // [esp+10h] [ebp-362Ch]
  __int64 v180; // [esp+10h] [ebp-362Ch]
  char *v181; // [esp+10h] [ebp-362Ch]
  __int64 v182; // [esp+10h] [ebp-362Ch]
  __int64 v183; // [esp+10h] [ebp-362Ch]
  unsigned int *v184; // [esp+10h] [ebp-362Ch]
  unsigned int *v185; // [esp+10h] [ebp-362Ch]
  unsigned int v186; // [esp+10h] [ebp-362Ch]
  __int64 v187; // [esp+10h] [ebp-362Ch]
  int v188; // [esp+10h] [ebp-362Ch]
  unsigned int v189; // [esp+10h] [ebp-362Ch]
  int v190; // [esp+10h] [ebp-362Ch]
  int v191; // [esp+18h] [ebp-3624h]
  signed int v192; // [esp+18h] [ebp-3624h]
  char *v193; // [esp+18h] [ebp-3624h]
  __int64 v194; // [esp+18h] [ebp-3624h]
  int v195; // [esp+18h] [ebp-3624h]
  unsigned int v196; // [esp+20h] [ebp-361Ch]
  signed int v197; // [esp+20h] [ebp-361Ch]
  _DWORD *v198; // [esp+20h] [ebp-361Ch]
  int v199; // [esp+20h] [ebp-361Ch]
  char v200; // [esp+24h] [ebp-3618h]
  char *v201; // [esp+24h] [ebp-3618h]
  int v202; // [esp+24h] [ebp-3618h]
  int v203; // [esp+24h] [ebp-3618h]
  __int64 v204; // [esp+28h] [ebp-3614h]
  unsigned int v205; // [esp+28h] [ebp-3614h]
  char *v206; // [esp+30h] [ebp-360Ch]
  char *v207; // [esp+34h] [ebp-3608h]
  int v208; // [esp+34h] [ebp-3608h]
  int v209; // [esp+38h] [ebp-3604h]
  bool v210; // [esp+3Ch] [ebp-3600h]
  int v211; // [esp+3Ch] [ebp-3600h]
  unsigned __int8 **v212; // [esp+3Ch] [ebp-3600h]
  int v213; // [esp+40h] [ebp-35FCh]
  char v214; // [esp+44h] [ebp-35F8h]
  char *v215; // [esp+44h] [ebp-35F8h]
  int v216; // [esp+44h] [ebp-35F8h]
  unsigned int *n; // [esp+44h] [ebp-35F8h]
  int v218; // [esp+48h] [ebp-35F4h]
  __int64 v219; // [esp+48h] [ebp-35F4h]
  char *v220; // [esp+48h] [ebp-35F4h]
  char *v221; // [esp+50h] [ebp-35ECh]
  char *v222; // [esp+50h] [ebp-35ECh]
  char *v223; // [esp+5Ch] [ebp-35E0h]
  int v224; // [esp+6Ch] [ebp-35D0h] BYREF
  __int64 v225; // [esp+70h] [ebp-35CCh] BYREF
  unsigned __int64 v226; // [esp+78h] [ebp-35C4h] BYREF
  unsigned int v227; // [esp+80h] [ebp-35BCh] BYREF
  int v228[1715]; // [esp+84h] [ebp-35B8h]
  unsigned int v229; // [esp+1B50h] [ebp-1AECh] BYREF
  unsigned int v230; // [esp+1B54h] [ebp-1AE8h]

  v176 = 0;
  v207 = 0;
  v4 = (_DWORD *)a4[1];
  if ( a3 )
  {
    v176 = (char *)v4[11];
    if ( (unsigned __int8)(*v176 - 1) > 0x7Du )
    {
      v176 = 0;
    }
    else
    {
      v207 = (char *)v4[10];
      if ( !*v207 )
      {
        v176 = 0;
        v207 = 0;
      }
    }
  }
  v206 = (char *)v4[9];
  v213 = strlen(v206);
  if ( !v213 )
    _assert_fail("decimal_len > 0", &unk_80D6140, 570, "____strtold_l_internal");
  v225 = 0LL;
  for ( i = a1 - 1; ; ++i )
  {
    v6 = *(char *)(i + 1);
    v7 = (char *)(i + 1);
    v8 = v6;
    if ( (*(_BYTE *)(a4[13] + 2 * v6 + 1) & 0x20) == 0 )
      break;
  }
  if ( (_BYTE)v6 == 45 )
  {
    v8 = *(char *)(i + 2);
    v209 = 1;
    v7 = (char *)(i + 2);
  }
  else
  {
    v209 = 0;
    if ( (_BYTE)v6 == 43 )
    {
      v8 = *(char *)(i + 2);
      v7 = (char *)(i + 2);
    }
  }
  v200 = *v206;
  if ( !*v206 )
  {
    v11 = 0;
    goto LABEL_14;
  }
  if ( v200 == *v7 )
  {
    v9 = 0;
    while ( 1 )
    {
      v10 = v206[++v9];
      v11 = v9;
      if ( !v10 )
        break;
      if ( v10 != v7[v9] )
        goto LABEL_28;
    }
LABEL_14:
    if ( (unsigned __int8)(v7[v11] - 48) <= 9u )
      goto LABEL_15;
  }
LABEL_28:
  if ( (unsigned __int8)(v8 - 48) > 9u )
  {
    v20 = dword_80C1540[v8];
    if ( (_BYTE)v20 == 105 )
    {
      if ( !j_strncasecmp_l(v7, &unk_80CCFA7, 3, nl_C_locobj) )
      {
        if ( a2 )
        {
          v61 = v7 + 3;
          v62 = v7 + 8;
          if ( !j_strncasecmp_l(v61, "inity", 5, nl_C_locobj) )
            v61 = v62;
          *a2 = v61;
        }
        if ( v209 )
          return -INFINITY;
        else
          return INFINITY;
      }
    }
    else if ( (_BYTE)v20 == 110 && !j_strncasecmp_l(v7, &unk_80CCFA3, 3, nl_C_locobj) )
    {
      v65 = (unsigned __int8 *)(v7 + 3);
      if ( v7[3] == 40 )
      {
        result = _strtold_nan((unsigned __int8 *)v7 + 4, (unsigned __int8 **)&v229, 41);
        if ( *(_BYTE *)v229 == 41 )
          v65 = (unsigned __int8 *)(v229 + 1);
      }
      else
      {
        result = NAN;
      }
      if ( a2 )
        *a2 = v65;
      return result;
    }
    goto LABEL_31;
  }
LABEL_15:
  if ( (_BYTE)v8 == 48 )
  {
    v191 = a4[14];
    v22 = v7[1];
    if ( *(_DWORD *)(v191 + 4 * v22) == 120 )
    {
      j = v7 + 2;
      LOBYTE(v8) = v7[2];
      if ( !v207 )
      {
        if ( (_BYTE)v8 != 48 )
        {
          v176 = 0;
          v7 += 2;
          v22 = (char)v8;
          v170 = 16;
          goto LABEL_36;
        }
        v22 = v7[3];
        v176 = 0;
        v7 += 2;
        v170 = 16;
        goto LABEL_135;
      }
      v7 += 2;
      v176 = 0;
      v170 = 16;
    }
    else
    {
      v170 = 10;
      if ( !v207 )
      {
LABEL_135:
        for ( j = v7; ; v22 = j[1] )
        {
          ++j;
          if ( (_BYTE)v22 != 48 )
            break;
        }
        goto LABEL_36;
      }
    }
LABEL_18:
    j = v7;
    v13 = *v207;
    v14 = v7;
    v15 = v8;
    if ( (_BYTE)v8 == 48 )
      goto LABEL_27;
    while ( 1 )
    {
      if ( v13 )
      {
        if ( *j != v13 )
        {
LABEL_35:
          v22 = v15;
          v7 = v14;
          goto LABEL_36;
        }
        v16 = 0;
        while ( 1 )
        {
          v17 = v207[++v16];
          if ( !v17 )
            break;
          if ( v17 != j[v16] )
            goto LABEL_35;
        }
        v18 = v16 - 1;
      }
      else
      {
        v18 = -1;
      }
      for ( k = &j[v18]; ; k = j )
      {
        v15 = k[1];
        j = k + 1;
        if ( v15 != 48 )
          break;
LABEL_27:
        ;
      }
    }
  }
  v191 = a4[14];
  if ( v207 )
  {
    v170 = 10;
    goto LABEL_18;
  }
  v22 = (char)v8;
  j = v7;
  v170 = 10;
LABEL_36:
  if ( (unsigned __int8)(v22 - 48) <= 9u )
    goto LABEL_111;
  v23 = *(_DWORD *)(v191 + 4 * (char)v22);
  if ( (unsigned __int8)(v23 - 97) > 5u || (v24 = j, v196 = 0, v170 != 16) )
  {
    if ( v200 )
    {
      if ( *j != v200 )
      {
LABEL_169:
        if ( v170 != 16 || (_BYTE)v23 != 112 || j == v7 )
          goto LABEL_170;
        goto LABEL_111;
      }
      v51 = 0;
      while ( 1 )
      {
        v52 = v206[++v51];
        if ( !v52 )
          break;
        if ( v52 != j[v51] )
          goto LABEL_169;
      }
    }
    if ( v170 == 16 && j == v7 )
    {
      v53 = j[v213];
      if ( (unsigned __int8)(v53 - 48) > 9u && (unsigned __int8)(*(_BYTE *)(v191 + 4 * v53) - 97) > 5u )
      {
LABEL_170:
        if ( v170 != 16 )
        {
          v24 = j;
          v196 = 0;
          if ( (_BYTE)v23 == 101 )
            goto LABEL_39;
        }
        v60 = _correctly_grouped_prefixmb((unsigned int)v7, (unsigned int)j, v207, v176);
        if ( a2 )
        {
          if ( (char *)v60 == v7 )
          {
            v60 = (unsigned int)(j - 1);
            if ( v170 != 16 )
              v60 = a1;
          }
          *a2 = v60;
        }
        goto LABEL_53;
      }
    }
LABEL_111:
    v24 = j;
    v196 = 0;
    goto LABEL_39;
  }
  while ( 1 )
  {
LABEL_39:
    if ( (unsigned __int8)(v22 - 48) <= 9u
      || v170 == 16 && (unsigned __int8)(*(_BYTE *)(v191 + 4 * (char)v22) - 97) <= 5u )
    {
      ++v196;
      v44 = v24;
      goto LABEL_108;
    }
    if ( !v207 )
      break;
    if ( !*v207 )
    {
      v44 = v24 - 1;
      goto LABEL_108;
    }
    if ( *v24 != *v207 )
      break;
    v63 = 0;
    while ( 1 )
    {
      v64 = v207[++v63];
      if ( !v64 )
        break;
      if ( v64 != v24[v63] )
        goto LABEL_42;
    }
    v44 = &v24[v63 - 1];
LABEL_108:
    v24 = v44 + 1;
    v22 = v44[1];
  }
LABEL_42:
  if ( v24 > v7 )
  {
    v25 = v176;
    if ( v176 )
    {
      v177 = v22;
      v26 = _correctly_grouped_prefixmb((unsigned int)v7, (unsigned int)v24, v207, v25);
      v22 = v177;
      if ( v24 != (char *)v26 )
      {
        if ( (char *)v26 != v7 )
        {
          if ( (unsigned int)j > v26 )
          {
            if ( a2 )
              *a2 = v26;
          }
          else
          {
            v27 = j;
            v201 = 0;
            if ( (unsigned int)j < v26 )
            {
              do
                v201 += (unsigned __int8)(*v27++ - 48) < 0xAu;
              while ( (char *)v26 != v27 );
              v28 = 0;
              v196 = (unsigned int)v201;
              goto LABEL_50;
            }
            if ( a2 )
            {
              v27 = (char *)v26;
              v28 = 0;
              v196 = 0;
              v201 = 0;
              goto LABEL_51;
            }
          }
LABEL_53:
          if ( v209 )
            return -0.0;
          return 0.0;
        }
LABEL_31:
        if ( a2 )
        {
          result = 0.0;
          *a2 = a1;
          return result;
        }
        return 0.0;
      }
      v200 = *v206;
      v191 = a4[14];
    }
  }
  v28 = -(v196 == 0);
  if ( v200 )
  {
    v29 = 0;
    if ( *v24 == v200 )
    {
      do
      {
        v30 = v206[++v29];
        if ( !v30 )
          goto LABEL_61;
      }
      while ( v30 == v24[v29] );
    }
    v45 = *(_DWORD *)(v191 + 4 * v22);
    v201 = (char *)v196;
  }
  else
  {
LABEL_61:
    v24 += v213;
    v178 = v24;
    v31 = *v24;
    v32 = v196 - (_DWORD)v24;
    while ( 1 )
    {
      if ( (unsigned __int8)(v31 - 48) > 9u )
      {
        if ( v170 != 16 )
        {
          v201 = &v24[v32];
          v27 = v24;
          v210 = 0;
          v33 = *(_BYTE *)(v191 + 4 * v31);
          goto LABEL_70;
        }
        if ( (unsigned __int8)(*(_BYTE *)(v191 + 4 * (char)v31) - 97) > 5u )
          break;
      }
      if ( (_BYTE)v31 != 48 && v28 == -1 )
        v28 = v24 - v178;
      v31 = *++v24;
    }
    v201 = &v24[v32];
    LOBYTE(v45) = *(_DWORD *)(v191 + 4 * (char)v31);
  }
  v33 = v45;
  v210 = v170 == 16 && (_BYTE)v45 == 112;
  if ( !v210 )
  {
    v210 = v170 == 16;
    v27 = v24;
LABEL_70:
    if ( v170 == 16 || v33 != 101 )
      goto LABEL_75;
    v34 = v24[1];
    if ( (_BYTE)v34 != 45 )
      goto LABEL_116;
    goto LABEL_73;
  }
  v34 = v24[1];
  if ( (_BYTE)v34 == 45 )
  {
LABEL_73:
    v34 = v24[2];
    v35 = v24 + 2;
    v218 = 1;
    if ( (unsigned __int8)(v34 - 48) <= 9u )
      goto LABEL_119;
    goto LABEL_74;
  }
LABEL_116:
  if ( (_BYTE)v34 == 43 )
  {
    v35 = v24 + 2;
    v34 = v24[2];
  }
  else
  {
    v35 = v24 + 1;
  }
  v218 = 0;
  if ( (unsigned __int8)(v34 - 48) > 9u )
  {
LABEL_74:
    v27 = v24;
    goto LABEL_75;
  }
LABEL_119:
  if ( v210 )
  {
    if ( v218 )
    {
      v180 = 4LL * v196 + 16445;
      v204 = v180 / 10;
      goto LABEL_122;
    }
    if ( !v196 )
    {
      if ( v28 == -1 )
      {
        v204 = 1638LL;
        v180 = 16387LL;
      }
      else
      {
        v180 = 4LL * v28 + 16387;
        v204 = v180 / 10;
      }
      goto LABEL_122;
    }
    if ( v28 )
      _assert_fail(
        "lead_zero == 0 && int_no <= (uintmax_t) INTMAX_MAX / 4",
        &unk_80D6140,
        886,
        "____strtold_l_internal");
    v54 = 4 * (4096LL - v196) + 3;
LABEL_182:
    v180 = v54;
    if ( v54 < 0 )
      v180 = 0LL;
    v204 = v180 / 10;
    goto LABEL_122;
  }
  if ( !v218 )
  {
    if ( !v196 )
    {
      if ( v28 == -1 )
      {
        v204 = 493LL;
        v180 = 4933LL;
      }
      else
      {
        v180 = v28 + 4933LL;
        v204 = v180 / 10;
      }
      goto LABEL_122;
    }
    if ( v28 )
      _assert_fail("lead_zero == 0 && int_no <= (uintmax_t) INTMAX_MAX", &unk_80D6140, 918, "____strtold_l_internal");
    v54 = 4933LL - v196;
    goto LABEL_182;
  }
  v180 = v196 + 4995LL;
  v204 = v180 / 10;
LABEL_122:
  v46 = v180 % 10;
  v47 = v225;
  v221 = j;
  v48 = v28;
  v214 = 0;
  v223 = v24;
  v181 = v35;
  do
  {
    if ( v47 > v204 )
    {
      v49 = v181;
      v50 = v48;
      if ( v214 )
        v225 = v47;
      goto LABEL_126;
    }
    v55 = v34 - 48;
    v56 = v55 >> 31;
    v57 = v55;
    if ( v47 == v204 && v55 > v46 )
    {
      v49 = v181;
      v50 = v48;
      if ( v214 )
        v225 = v204;
LABEL_126:
      if ( v50 == -1 )
      {
        result = 0.0;
        if ( v209 )
          result = -0.0;
      }
      else
      {
        __writegsdword(0xFFFFFFE8, 0x22u);
        if ( v218 )
        {
          if ( v209 )
            result = -3.3621031431120935063e-4932 * 3.3621031431120935063e-4932;
          else
            result = 3.3621031431120935063e-4932 * 3.3621031431120935063e-4932;
        }
        else if ( v209 )
        {
          result = -1.189731495357231765e4932 * 1.189731495357231765e4932;
        }
        else
        {
          result = 1.189731495357231765e4932 * 1.189731495357231765e4932;
        }
      }
      do
        ++v49;
      while ( (unsigned __int8)(*v49 - 48) <= 9u );
      if ( a2 )
        *a2 = v49;
      return result;
    }
    v214 = 1;
    v58 = 10 * HIDWORD(v47);
    v59 = 10LL * (unsigned int)v47;
    HIDWORD(v59) += v58;
    v47 = __PAIR64__(v56, v57) + v59;
    v34 = *++v181;
  }
  while ( (unsigned __int8)(v34 - 48) <= 9u );
  v28 = v48;
  v24 = v223;
  v27 = v181;
  j = v221;
  v225 = v47;
  if ( v218 )
    v225 = -v47;
LABEL_75:
  if ( v196 < (unsigned int)v201 )
  {
    if ( *(v24 - 1) != 48 )
      goto LABEL_50;
    v36 = v201 - v24;
    do
      --v24;
    while ( *(v24 - 1) == 48 );
    if ( v196 > (unsigned int)&v24[v36] )
      _assert_fail("dig_no >= int_no", &unk_80D6140, 993, "____strtold_l_internal");
    v201 = &v24[v36];
  }
  if ( (char *)v196 == v201 && v201 )
  {
    v37 = v225;
    if ( v225 < 0 )
    {
      v182 = 1LL;
      if ( v210 )
        v182 = 4LL;
      v215 = j;
      v73 = v24 - 1;
      v74 = 0;
      v193 = v27;
      v205 = v28;
      v75 = v196;
      while ( 1 )
      {
        v79 = *v73;
        if ( v210 )
        {
          v76 = ((*(_WORD *)(a4[13] + 2 * v79) >> 12) ^ 1) & 1;
        }
        else
        {
          LOBYTE(v27) = (unsigned int)(v79 - 48) > 9;
          v76 = (int)v27;
        }
        v27 = (char *)v76;
        if ( !(_BYTE)v76 )
        {
          if ( *v73 != 48 )
          {
            v196 = v75;
            v27 = v193;
            v28 = v205;
            j = v215;
            if ( (_BYTE)v74 )
              v225 = v37;
            goto LABEL_50;
          }
          --v75;
          v37 += v182;
          v77 = v201-- == (char *)1;
          LOBYTE(v74) = !v77;
          v78 = v74;
          v74 = (char *)(HIDWORD(v37) >> 31);
          v27 = v78;
          LOBYTE(v74) = (unsigned __int8)v78 & (v37 < 0);
          if ( !(_BYTE)v74 )
          {
            v196 = v75;
            v27 = v193;
            v28 = v205;
            v225 = v37;
            j = v215;
            goto LABEL_50;
          }
        }
        --v73;
      }
    }
    if ( !a2 )
      goto LABEL_85;
LABEL_51:
    *a2 = v27;
  }
  else
  {
LABEL_50:
    if ( a2 )
      goto LABEL_51;
  }
  if ( !v201 )
    goto LABEL_53;
LABEL_85:
  if ( !v28 )
    goto LABEL_99;
  v38 = *j;
  v39 = v206[1];
  while ( 2 )
  {
    if ( *v206 != v38 )
    {
      v38 = j[1];
LABEL_88:
      ++j;
      continue;
    }
    break;
  }
  if ( !v39 )
    goto LABEL_95;
  v38 = j[1];
  if ( v38 != v39 )
    goto LABEL_88;
  v40 = 1;
  while ( 1 )
  {
    v41 = v206[++v40];
    if ( !v41 )
      break;
    if ( v41 != j[v40] )
    {
      v38 = v206[1];
      goto LABEL_88;
    }
  }
LABEL_95:
  if ( v170 == 16 )
  {
    v179 = v225;
    if ( v28 > (v225 + 0x8000000000000000LL) >> 2 )
      goto LABEL_237;
    v42 = 4LL * v28;
  }
  else
  {
    v179 = v225;
    if ( HIDWORD(v225) == 0x80000000 && v28 > (unsigned int)v225 )
LABEL_237:
      _assert_fail(
        "lead_zero <= (base == 16 ? ((uintmax_t) exponent - (uintmax_t) INTMAX_MIN) / 4 : ((uintmax_t) exponent - (uintma"
        "x_t) INTMAX_MIN))",
        &unk_80D6140,
        1048,
        "____strtold_l_internal");
    v42 = v28;
  }
  j += v213 + v28;
  v201 -= v28;
  v225 = v179 - v42;
LABEL_99:
  if ( v170 == 16 )
  {
    v66 = a4[13];
    v67 = *j;
    for ( m = *j; (*(_BYTE *)(v66 + 2 * v67 + 1) & 0x10) == 0; m = *j )
      v67 = *++j;
    if ( m == 48 )
    {
      do
        ++j;
      while ( *j == 48 );
      v67 = *j;
    }
    v69 = v67 - 48;
    v70 = j + 1;
    if ( (unsigned int)(v67 - 48) > 9 )
      v69 = *(_DWORD *)(a4[14] + 4 * v67) - 87;
    v172 = nbits_11199_0[v69];
    if ( !v172 )
      _assert_fail("bits != 0", &unk_80D6140, 1072, "____strtold_l_internal");
    v71 = 31 - v172;
    HIDWORD(v226) = v69 << (32 - v172);
    if ( v225 < 0 )
      v72 = (__int64)(0x8000000000000000LL - v172) >> 2;
    else
      v72 = (0x7FFFFFFFFFFFFFFFLL - v225 - v172 + 1) / 4;
    if ( v196 > v72 )
      _assert_fail(
        "int_no <= (uintmax_t) (exponent < 0 ? (INTMAX_MAX - bits + 1) / 4 : (INTMAX_MAX - exponent - bits + 1) / 4)",
        &unk_80D6140,
        1093,
        "____strtold_l_internal");
    v108 = v201;
    v194 = v225 + v172 - 1 + 4 * (v196 - 1LL);
    v174 = 1;
    v225 = v194;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v108 == (char *)1 )
        {
          if ( v174 == 1 )
            LODWORD(v226) = 0;
          return round_and_return_1((unsigned int *)&v226, v194, SHIDWORD(v194), v209, 0, 0, 0);
        }
        v109 = (char)*v70;
        if ( (*(_BYTE *)(v66 + 2 * v109 + 1) & 0x10) == 0 )
        {
          v70 += v213;
          v109 = (char)*v70;
        }
        v110 = v109 - 48;
        ++v70;
        if ( (unsigned int)(v109 - 48) > 9 )
          v110 = *(_DWORD *)(a4[14] + 4 * v109) - 87;
        if ( v71 <= 2 )
          break;
        v111 = v71 - 3;
        v71 -= 4;
        *((_DWORD *)&v226 + v174) |= v110 << v111;
        --v108;
      }
      v112 = v174;
      *((_DWORD *)&v226 + v174) |= v110 >> (3 - v71);
      v113 = v110 << (v71 + 29);
      if ( !v174 )
        break;
      LODWORD(v226) = v113;
      v71 += 28;
      --v108;
      v174 = 0;
    }
    v161 = v108 - 2;
    if ( v161 )
    {
      if ( *v70 == 48 )
      {
        v162 = v70 + 1;
        v163 = &v70[(_DWORD)v161];
        while ( v163 != v162 )
        {
          if ( *v162++ != 48 )
            goto LABEL_425;
        }
      }
      else
      {
LABEL_425:
        v112 = 1;
      }
    }
    return round_and_return_1((unsigned int *)&v226, v194, SHIDWORD(v194), v209, v113, 31, v112);
  }
  if ( v225 < 0 )
  {
    v43 = -(__int64)v196;
    if ( v43 < v225 )
      goto LABEL_102;
  }
  else
  {
    v43 = (signed __int64)&v201[-(unsigned __int64)v196];
    if ( v43 > v225 )
LABEL_102:
      v43 = v225;
  }
  v171 = v43 + v196;
  v225 -= v43;
  v219 = (unsigned int)v43 + v196;
  if ( v225 > 4933 - v219 )
  {
LABEL_104:
    __writegsdword(0xFFFFFFE8, 0x22u);
    if ( v209 )
      return -1.189731495357231765e4932 * 1.189731495357231765e4932;
    else
      return 1.189731495357231765e4932 * 1.189731495357231765e4932;
  }
  if ( v225 < -4951 )
  {
    __writegsdword(0xFFFFFFE8, 0x22u);
    if ( v209 )
      return -3.3621031431120935063e-4932 * 3.3621031431120935063e-4932;
    else
      return 3.3621031431120935063e-4932 * 3.3621031431120935063e-4932;
  }
  v192 = 0;
  if ( v171 )
  {
    v143 = str_to_mpn_isra_0_1(j, v171, (int *)&v227, &v224, (unsigned int *)&v225, v213, v207);
    v144 = HIDWORD(v225);
    v145 = v225;
    j = v143;
    if ( v225 > 0 )
    {
      v195 = 1;
      v222 = v143;
      v212 = (unsigned __int8 **)&v229;
      v188 = v224;
      v198 = &fpioconst_pow10;
      for ( n = &v227; ; n = v150 )
      {
        while ( !(v145 & v195 | v144 & (v195 >> 31)) )
        {
          v195 *= 2;
          v198 += 4;
        }
        LODWORD(v146) = v145 ^ v195;
        HIDWORD(v146) = v144 ^ (v195 >> 31);
        v225 = v146;
        v147 = v198[1] - 2;
        v148 = v147;
        if ( v147 > v188 )
          v149 = _mpn_mul(v212, &dword_80D0BC8[*v198], v147, n, v188);
        else
          v149 = _mpn_mul(v212, n, v188, &dword_80D0BC8[*v198], v198[1] - 2);
        v188 = v148 + v224;
        v224 += v148;
        if ( !v149 )
          v224 = --v188;
        v144 = HIDWORD(v225);
        v145 = v225;
        v195 *= 2;
        v198 += 4;
        if ( !v225 )
          break;
        v150 = (unsigned int *)v212;
        v212 = (unsigned __int8 **)n;
      }
      v151 = v188;
      j = v222;
      if ( v212 == (unsigned __int8 **)&v229 )
      {
        memcpy(&v227, v212, 4 * v188);
        v151 = v188;
      }
    }
    else
    {
      v151 = v224;
    }
    v199 = v151 - 1;
    _BitScanReverse(&v152, *(&v227 + v151 - 1));
    v192 = 32 * v151 - (v152 ^ 0x1F);
    if ( v192 > 0x4000 )
      goto LABEL_104;
    if ( v192 > 64 )
    {
      v153 = (v192 - 64) >> 5;
      v154 = (v192 - 64) & 0x1F;
      if ( !v154 )
      {
        v155 = v153 - 1;
        v156 = v228[v153];
        v157 = 31;
        LODWORD(v226) = v228[v153 - 1];
        v158 = *(&v227 + v153 - 1);
        HIDWORD(v226) = v156;
        v189 = v158;
LABEL_383:
        v159 = 0;
        if ( !v227 )
        {
          do
            ++v159;
          while ( !v228[v159 - 1] );
        }
        return round_and_return_1(
                 (unsigned int *)&v226,
                 v192 - 1,
                 (v192 - 1) >> 31,
                 v209,
                 v189,
                 v157,
                 ((unsigned int)v201 > v171) | (unsigned __int8)(v159 < v155));
      }
      v157 = v154 - 1;
      if ( v199 <= v153 )
      {
        v167 = v228[v153 - 1];
        v189 = v167;
      }
      else
      {
        v167 = v228[v153];
        v189 = v228[v153 - 1];
        LODWORD(v226) = (v167 << (32 - v154)) | (v189 >> v154);
        if ( v153 + 1 < v199 )
        {
          v168 = v167 >> v154;
          v167 = v228[v153 + 1];
          HIDWORD(v226) = (v167 << (32 - v154)) | v168;
        }
        if ( v199 - v153 > 1 )
        {
          v155 = (v192 - 64) >> 5;
          goto LABEL_383;
        }
      }
      HIDWORD(v226) = v167 >> v154;
      v155 = (v192 - 64) >> 5;
      goto LABEL_383;
    }
    if ( v201 != (char *)v171 )
    {
      v190 = v151;
      memcpy(&v226, &v227, 4 * v151);
      if ( v190 <= 1 )
        *((_DWORD *)&v226 + v190) = 0;
      goto LABEL_166;
    }
    v164 = (v192 - 1) % 32;
    if ( v164 == 31 )
    {
      v165 = 2 - v151;
      memcpy((_BYTE *)&v226 + 4 * (2 - v151), &v227, 4 * v151);
      if ( v165 > 0 )
      {
LABEL_416:
        LODWORD(v226) = 0;
        if ( v165 != 1 )
          HIDWORD(v226) = 0;
      }
    }
    else
    {
      _mpn_lshift((_DWORD *)&v226 + 2 - v151, (int)&v227, v151, 31 - v164);
      v165 = 2 - v224;
      if ( 2 - v224 > 0 )
        goto LABEL_416;
    }
    return round_and_return_1((unsigned int *)&v226, v192 - 1, (v192 - 1) >> 31, v209, 0, 0, 0);
  }
LABEL_166:
  if ( (unsigned int)v201 <= v171 || (unsigned __int64)(v225 + 4951) > 0x1357 )
    _assert_fail(
      "dig_no > int_no && exponent <= 0 && exponent >= MIN_10_EXP - (DIG + 2)",
      &unk_80D6140,
      1332,
      "____strtold_l_internal");
  if ( v192 <= 0 )
  {
    if ( v171 || *j == 48 )
      _assert_fail("int_no == 0 && *startp != L_('0')", &unk_80D6140, 1348, "____strtold_l_internal");
    v81 = v225;
    v160 = 16447;
    if ( (int)(10 * (1 - v225) / 3 + 65) <= 16447 )
      v160 = 10 * (1 - v225) / 3 + 65;
    v80 = v225 + v160;
    if ( v80 <= 0 )
      _assert_fail("need_frac_digits > 0", &unk_80D6140, 1369, "____strtold_l_internal");
  }
  else
  {
    if ( v225 || !v171 )
      _assert_fail("int_no > 0 && exponent == 0", &unk_80D6140, 1342, "____strtold_l_internal");
    v80 = 65 - v192;
    v81 = 0;
  }
  v183 = v80;
  if ( v80 > (int)&v201[-v219] )
  {
    v80 = (int)&v201[-v171];
    v183 = (int)&v201[-v171];
  }
  if ( (unsigned int)v201 <= v219 + v183 )
  {
    v216 = 0;
  }
  else
  {
    v216 = 1;
    v201 = (char *)(v171 + v80);
  }
  v82 = (int)&v201[-v171];
  v220 = j;
  v83 = &fpioconst_pow10;
  v173 = (int *)&v227;
  v202 = v82;
  v84 = v82 - v81;
  v85 = &v229;
  v86 = 1;
  v87 = 0;
  v88 = v84;
  do
  {
    if ( (v88 & v86) != 0 )
    {
      v88 ^= v86;
      if ( v87 )
      {
        v185 = v85;
        v89 = _mpn_mul(v173, &dword_80D0BC8[*v83], v83[1] - 2, v85, v87);
        v87 = v87 + v83[1] - 2;
        if ( v89 )
        {
          v90 = (int *)v185;
        }
        else
        {
          v90 = (int *)v185;
          --v87;
        }
        v85 = (unsigned int *)v173;
        v173 = v90;
      }
      else
      {
        v87 = v83[1] - 2;
        v184 = v85;
        memcpy(v85, &dword_80D0BC8[*v83], 4 * v87);
        v85 = v184;
      }
    }
    v86 *= 2;
    v83 += 4;
  }
  while ( v88 );
  LOBYTE(v211) = 0;
  v197 = v87;
  if ( v85 == &v227 )
    memcpy(&v229, &v227, 4 * v87);
  str_to_mpn_isra_0_1(v220, v202, (int *)&v227, &v224, (unsigned int *)&v225, v213, v207);
  _BitScanReverse(&v91, *(&v229 + v87 - 1));
  v203 = v87 - 1;
  v92 = v91 ^ 0x1F;
  if ( v92 && (_mpn_lshift(&v229, (int)&v229, v87, v92), (v93 = _mpn_lshift(&v227, (int)&v227, v224, v92)) != 0) )
  {
    v94 = v224 + 1;
    v228[v224 - 1] = v93;
    v224 = v94;
  }
  else
  {
    v94 = v224;
  }
  v225 = v192;
  if ( v87 == 1 )
  {
    v114 = v227;
    if ( v227 >= v229 || v94 != 1 )
      _assert_fail("numsize == 1 && n < d", &unk_80D6140, 1469, "____strtold_l_internal");
    for ( ii = v192; ; ii += 32 )
    {
      while ( 1 )
      {
        LODWORD(v117) = 0;
        HIDWORD(v117) = v114;
        LODWORD(v116) = v117 / v229;
        HIDWORD(v116) = v117 % v229;
        v114 = HIDWORD(v116);
        if ( ii )
          break;
        while ( !(_DWORD)v116 )
        {
          v225 -= 32LL;
          v120 = v116 % v229;
          LODWORD(v116) = v116 / v229;
          HIDWORD(v116) = v120;
        }
        v118 = v116;
        _BitScanReverse((unsigned int *)&v116, v116);
        v114 = HIDWORD(v116);
        v119 = (int)(v116 ^ 0x1F);
        ii = 32 - v119;
        v225 -= v119;
        v226 = v118;
      }
      if ( ii > 32 )
        break;
      HIDWORD(v116) = v226;
      v226 = v116;
    }
    v121 = ii;
    v122 = v116;
    v123 = 64 - v121;
    v124 = HIDWORD(v116);
    if ( v121 != 64 )
    {
      _mpn_lshift(&v226, (int)&v226, 2, 64 - v121);
      LODWORD(v226) = (v122 >> (32 - v123)) | v226;
    }
    return round_and_return_1(
             (unsigned int *)&v226,
             (int)v225 - 1,
             (unsigned __int64)(v225 - 1) >> 32,
             v209,
             v122,
             31 - v123,
             v216 | (unsigned int)(v124 != 0));
  }
  else
  {
    if ( v87 == 2 )
    {
      v95 = v229;
      v96 = v230;
      if ( v94 > 1 )
      {
        v97 = v228[0];
        v98 = v227;
        goto LABEL_275;
      }
      v97 = v227;
      if ( v230 <= v227 )
      {
        v98 = v227;
        v97 = 0;
        goto LABEL_275;
      }
      if ( v192 <= 0 )
      {
        LODWORD(v225) = v192 - 32;
        v98 = 0;
        HIDWORD(v225) = __CFADD__(v192, -32) + (v192 >> 31) - 1;
        goto LABEL_275;
      }
      if ( v192 <= 32 )
      {
        v169 = v226;
        LODWORD(v226) = 0;
        HIDWORD(v226) = v169;
      }
      else
      {
        LOBYTE(v211) = 64 - v192;
        if ( v192 != 64 )
        {
          v186 = v230;
          _mpn_lshift(&v226, (int)&v226, 2, 64 - v192);
          v97 = v227;
          v96 = v186;
        }
      }
      v192 += 32;
      v98 = 0;
      v99 = 0;
      if ( v192 > 64 )
        return round_and_return_1(
                 (unsigned int *)&v226,
                 (int)v225 - 1,
                 (unsigned __int64)(v225 - 1) >> 32,
                 v209,
                 v98,
                 31 - (unsigned __int8)v211,
                 (unsigned __int8)(v216 | (v99 != 0 || v97 != 0)));
LABEL_275:
      while ( 2 )
      {
        while ( 2 )
        {
          if ( v97 == v96 )
          {
            v104 = __CFADD__(v98, v97);
            v101 = v98 + v97;
            if ( !v104 )
            {
              v103 = -v95;
              v98 = -1;
              v102 = (unsigned __int8 *)(v95 - (v95 != 0));
              goto LABEL_277;
            }
            v97 = ((unsigned int)v95 + __PAIR64__(v101 - v95, 0)) >> 32;
            v98 = v95;
            if ( !v192 )
            {
              v192 = 32;
              v187 = 0LL;
              v107 = -1;
LABEL_284:
              v225 -= v187;
              v226 = (unsigned int)v107;
              continue;
            }
            v99 = v95;
            v98 = -1;
          }
          else
          {
            v100 = __PAIR64__(v97, v98) % (unsigned int)v96;
            v98 = __PAIR64__(v97, v98) / (unsigned int)v96;
            v101 = v100;
            v102 = (unsigned __int8 *)((v98 * (unsigned __int64)(unsigned int)v95) >> 32);
            v103 = v98 * v95;
            do
            {
LABEL_277:
              if ( (unsigned int)v102 <= v101 && (v102 != (unsigned __int8 *)v101 || !v103) )
                break;
              --v98;
              v102 = (unsigned __int8 *)((__PAIR64__((unsigned int)v102, v103) - (unsigned int)v95) >> 32);
              v103 -= v95;
              v104 = __CFADD__(v96, v101);
              v101 += v96;
            }
            while ( !v104 );
            v105 = -v103;
            v97 = (__PAIR64__(v101, 0) - __PAIR64__((unsigned int)v102, v103)) >> 32;
            v99 = -v103;
            if ( !v192 )
            {
              if ( v98 )
              {
                _BitScanReverse((unsigned int *)&v106, v98);
                v106 ^= 0x1Fu;
                v187 = v106;
                v192 = 32 - v106;
                v107 = v98;
                v98 = v105;
              }
              else
              {
                v107 = 0;
                v98 = -v103;
                v187 = 32LL;
              }
              goto LABEL_284;
            }
          }
          break;
        }
        if ( v192 > 32 )
        {
          LOBYTE(v211) = 64 - v192;
          if ( v192 != 64 )
          {
            _mpn_lshift(&v226, (int)&v226, 2, 64 - v192);
            LODWORD(v226) = (v98 >> (32 - (64 - v192))) | v226;
          }
          return round_and_return_1(
                   (unsigned int *)&v226,
                   (int)v225 - 1,
                   (unsigned __int64)(v225 - 1) >> 32,
                   v209,
                   v98,
                   31 - (unsigned __int8)v211,
                   (unsigned __int8)(v216 | (v99 != 0 || v97 != 0)));
        }
        v226 = __PAIR64__(v226, v98);
        v98 = v99;
        v192 += 32;
        continue;
      }
    }
    v175 = *(&v229 + v203);
    v125 = *(&v229 + v87 - 2);
    v126 = _mpn_cmp((int)&v227, (int)(&v229 + v197 - v94), v94);
    v127 = v224;
    if ( v126 > 0 )
    {
      v127 = v224 + 1;
      v228[v224 - 1] = 0;
      v224 = v127;
    }
    if ( v197 <= v127 )
    {
      if ( v197 != v127 )
        _assert_fail("numsize == densize", &unk_80D6140, 1680, "____strtold_l_internal");
      if ( v197 > 0 )
      {
        v166 = v197;
        do
        {
          --v166;
          v228[v166] = v228[v166 - 1];
        }
        while ( v166 );
      }
      v227 = 0;
      *(&v229 + v197) = 0;
      v134 = v228[v197 - 1];
      while ( 1 )
      {
        while ( 1 )
        {
LABEL_338:
          v135 = -1;
          if ( v175 != v134 )
          {
            v208 = v228[v203 - 1];
            v135 = __PAIR64__(v134, v208) / v175;
            v136 = __PAIR64__(v134, v208) % v175;
            v137 = v135 * v125;
            v138 = (v135 * (unsigned __int64)v125) >> 32;
            while ( v138 > v136 || v138 == v136 && v137 > *(&v227 + v197 - 2) )
            {
              --v135;
              v104 = __CFADD__(v175, v136);
              v136 += v175;
              if ( v104 )
                break;
              v138 = (__PAIR64__(v138, v137) - v125) >> 32;
              v137 -= v125;
            }
          }
          if ( _mpn_submul_1((int)&v227, (int)&v229, v197 + 1, v135) != v228[v197 - 1] )
          {
            if ( !_mpn_add_n(&v227, &v227, &v229, v197) )
              _assert_fail("cy != 0", &unk_80D6140, 1722, "____strtold_l_internal");
            --v135;
          }
          v134 = v228[v203 - 1];
          v228[v197 - 1] = v134;
          if ( v203 > 0 )
          {
            v139 = (char *)&v226 + 4 * v197;
            do
            {
              v140 = *(_DWORD *)v139;
              v139 -= 4;
              *((_DWORD *)v139 + 2) = v140;
            }
            while ( v139 != (char *)&v226 + 4 );
          }
          v227 = 0;
          if ( v192 )
            break;
          if ( v135 )
          {
            _BitScanReverse((unsigned int *)&v141, v135);
            v141 ^= 0x1Fu;
            v226 = v135;
            v192 = 32 - v141;
            v225 -= v141;
          }
          else
          {
            v104 = __CFADD__((_DWORD)v225, -32);
            LODWORD(v225) = v225 - 32;
            HIDWORD(v225) = v104 + HIDWORD(v225) - 1;
            v226 = 0LL;
          }
        }
        if ( v192 > 32 )
          break;
        v226 = __PAIR64__(v226, v135);
        v192 += 32;
      }
      LOBYTE(v211) = 64 - v192;
      if ( v192 != 64 )
      {
        _mpn_lshift(&v226, (int)&v226, 2, 64 - v192);
        LODWORD(v226) = (v135 >> (32 - (64 - v192))) | v226;
      }
    }
    else
    {
      v128 = v197 - v127;
      v129 = v197 - v127;
      if ( v192 <= 0 )
      {
        v225 -= 32 * v128;
      }
      else
      {
        v130 = 32 * v128 + v192;
        if ( v130 > 64 )
        {
          v211 = 64 - v192;
          if ( 64 - v192 > 31 )
          {
            _mpn_lshift((_DWORD *)&v226 + 1, (int)&v226, 1, (64 - v192) & 0x1F);
            LODWORD(v226) = 0;
            v127 = v224;
            v192 = v130;
          }
          else
          {
            v192 += 32 * v128;
            if ( v211 )
            {
              _mpn_lshift(&v226, (int)&v226, 2, v211);
              v127 = v224;
            }
          }
        }
        else
        {
          if ( v129 != 1 )
            _assert_fail("empty == 1", &unk_80D6140, 1643, "____strtold_l_internal");
          v131 = v226;
          v192 = v130;
          LODWORD(v226) = 0;
          HIDWORD(v226) = v131;
        }
      }
      if ( v127 > 0 )
      {
        v132 = &v228[v127 - 2];
        do
        {
          v132[v129 + 1] = *v132;
          --v132;
        }
        while ( (int *)((char *)&v226 + 4) != v132 );
      }
      v133 = (int *)&v227;
      do
        *v133++ = 0;
      while ( v133 != &v228[v129] );
      *(&v229 + v197) = 0;
      v134 = v228[v197 - 1];
      if ( v192 <= 64 )
        goto LABEL_338;
      v135 = 0;
    }
    v142 = v197;
    if ( v197 < 0 || v228[v197 - 1] )
    {
      v142 = v197;
    }
    else
    {
      do
        --v142;
      while ( v142 != -1 && !v228[v142 - 1] );
    }
    return round_and_return_1(
             (unsigned int *)&v226,
             (int)v225 - 1,
             (unsigned __int64)(v225 - 1) >> 32,
             v209,
             v135,
             31 - (unsigned __int8)v211,
             v216 | (unsigned int)(v142 >= 0));
  }
}
// 8048280: using guessed type int __cdecl j_strncasecmp_l(_DWORD, _DWORD, _DWORD, _DWORD);
// 80496A0: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80C1540: using guessed type int dword_80C1540[256];
// 80CC680: using guessed type void **nl_C_locobj[6];
// 80D0BC8: using guessed type unsigned int dword_80D0BC8[3438];
// 80D6180: using guessed type int nbits_11199_0[16];

//----- (080B37F0) --------------------------------------------------------
void __cdecl strtold_l(unsigned int a1, _DWORD *a2, _DWORD *a3)
{
  ___strtold_l_internal(a1, a2, 0, a3);
}

//----- (080B3810) --------------------------------------------------------
long double __usercall _strtof_nan@<st0>(unsigned __int8 *a1@<eax>, unsigned __int8 **a2@<edx>, char a3@<cl>)
{
  unsigned __int8 *i; // ebx
  unsigned __int8 v6; // cl
  long double result; // fst7
  int v8; // eax
  int v9; // eax
  long double v10; // fst6
  unsigned __int8 *v11; // [esp+1Ch] [ebp-10h] BYREF

  for ( i = a1; ; ++i )
  {
    v6 = *i;
    if ( (unsigned __int8)((*i & 0xDF) - 65) > 0x19u && (unsigned __int8)(v6 - 48) > 9u && v6 != 95 )
      break;
  }
  if ( v6 == a3 && (v8 = ___strtoull_l_internal(a1, &v11, 0, 0, (int)nl_C_locobj), i == v11) )
  {
    v9 = v8 & 0x3FFFFF | 0x7FC00000;
    v10 = NAN;
    if ( (v9 & 0x7FFFFF) != 0 )
      v10 = *(float *)&v9;
    result = v10;
  }
  else
  {
    result = NAN;
  }
  if ( a2 )
    *a2 = i;
  return result;
}
// 80CC680: using guessed type void **nl_C_locobj[6];

//----- (080B38A0) --------------------------------------------------------
long double __usercall _strtod_nan@<st0>(unsigned __int8 *a1@<eax>, unsigned __int8 **a2@<edx>, char a3@<cl>)
{
  unsigned __int8 *i; // ebx
  unsigned __int8 v6; // cl
  long double result; // fst7
  int v8; // eax
  int v9; // edx
  unsigned __int8 *v10; // [esp+1Ch] [ebp-20h] BYREF

  for ( i = a1; ; ++i )
  {
    v6 = *i;
    if ( (unsigned __int8)((*i & 0xDF) - 65) > 0x19u && (unsigned __int8)(v6 - 48) > 9u && v6 != 95 )
      break;
  }
  if ( v6 == a3
    && (v8 = ___strtoull_l_internal(a1, &v10, 0, 0, (int)nl_C_locobj), i == v10)
    && v8 | v9 & 0x7FFFF | 0x80000 )
  {
    result = COERCE_DOUBLE(__PAIR64__(v9 & 0x7FFFF | 0x7FF80000u, v8));
  }
  else
  {
    result = NAN;
  }
  if ( a2 )
    *a2 = i;
  return result;
}
// 80B3918: variable 'v9' is possibly undefined
// 80CC680: using guessed type void **nl_C_locobj[6];

//----- (080B3930) --------------------------------------------------------
long double __usercall _strtold_nan@<st0>(unsigned __int8 *a1@<eax>, unsigned __int8 **a2@<edx>, char a3@<cl>)
{
  unsigned __int8 *i; // ebx
  unsigned __int8 v6; // cl
  long double result; // fst7
  __int64 v8; // rax
  unsigned __int8 *v9; // [esp+Ch] [ebp-20h] BYREF
  long double v10; // [esp+10h] [ebp-1Ch]

  for ( i = a1; ; ++i )
  {
    v6 = *i;
    if ( (unsigned __int8)((*i & 0xDF) - 65) > 0x19u && (unsigned __int8)(v6 - 48) > 9u && v6 != 95 )
      break;
  }
  if ( v6 == a3 && (LODWORD(v8) = ___strtoull_l_internal(a1, &v9, 0, 0, (int)nl_C_locobj), i == v9) )
  {
    v10 = NAN;
    result = NAN;
    HIDWORD(v8) = HIDWORD(v8) & 0x3FFFFFFF | DWORD1(v10) & 0xC0000000;
    *(_QWORD *)&v10 = v8;
    if ( v8 )
      result = v10;
  }
  else
  {
    result = NAN;
  }
  if ( a2 )
    *a2 = i;
  return result;
}
// 80B39A1: variable 'v8' is possibly undefined
// 80CC680: using guessed type void **nl_C_locobj[6];

//----- (080B39E0) --------------------------------------------------------
long double __cdecl _mpn_construct_float(_DWORD *a1, char a2, unsigned __int8 a3)
{
  return COERCE_FLOAT(*a1 & 0x7FFFFF | ((unsigned __int8)(a2 + 127) << 23) | (a3 << 31));
}

//----- (080B3A20) --------------------------------------------------------
long double __cdecl _mpn_construct_double(_DWORD *a1, __int16 a2, unsigned __int8 a3)
{
  double v4; // [esp+0h] [ebp-14h]

  LODWORD(v4) = *a1;
  HIDWORD(v4) = a1[1] & 0xFFFFF | (((a2 + 1023) & 0x7FF) << 20) | (a3 << 31);
  return v4;
}

//----- (080B3A90) --------------------------------------------------------
long double __cdecl _mpn_construct_long_double(_QWORD *a1, __int16 a2, char a3)
{
  long double v4; // [esp+0h] [ebp-1Ch]

  BYTE9(v4) = (a3 << 7) | BYTE9(v4) & 0x7F;
  WORD4(v4) = (a2 + 0x3FFF) & 0x7FFF | WORD4(v4) & 0x8000;
  *(_QWORD *)&v4 = *a1;
  return v4;
}
// 80B3AA4: variable 'v4' is possibly undefined

//----- (080B3AE0) --------------------------------------------------------
int (__cdecl *strncasecmp_l())(char *a1, unsigned __int8 *a2, int a3, int a4)
{
  int (__cdecl *result)(char *, unsigned __int8 *, int, int); // eax

  result = _strncasecmp_l_nonascii;
  if ( (dword_80EC570 & 0x200) != 0 )
  {
    result = _strncasecmp_l_ssse3;
    if ( (dword_80EC570 & 0x100000) != 0 && (dword_80EC5A0 & 0x200) == 0 )
      return _strncasecmp_l_sse4_2;
  }
  return result;
}
// 80EC570: using guessed type int dword_80EC570;
// 80EC5A0: using guessed type int dword_80EC5A0;

//----- (080B3B20) --------------------------------------------------------
int __cdecl _strncasecmp_l_nonascii(char *a1, unsigned __int8 *a2, int a3, int a4)
{
  char *v4; // ecx
  unsigned __int8 *v5; // edx
  int v6; // esi
  char v7; // di
  int v8; // ebp

  v4 = a1;
  v5 = a2;
  v6 = a3;
  if ( a1 == (char *)a2 || !a3 )
    return 0;
  do
  {
    v7 = *v4;
    v8 = *(_DWORD *)(*(_DWORD *)(a4 + 56) + 4 * (unsigned __int8)*v4) - *(_DWORD *)(*(_DWORD *)(a4 + 56) + 4 * *v5++);
    if ( v8 )
      break;
    ++v4;
    if ( !v7 )
      break;
    --v6;
  }
  while ( v6 );
  return v8;
}

//----- (080B3B90) --------------------------------------------------------
int __cdecl _strncasecmp_ssse3(char *a1, unsigned __int8 *a2, int a3)
{
  if ( (*(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFDC) + 320) & 1) == 0 )
    JUMPOUT(0x80B3BC6);
  return _strncasecmp_nonascii(a1, a2, a3);
}
// 80B3BA8: control flows out of bounds to 80B3BC6

//----- (080B3BB0) --------------------------------------------------------
int __cdecl _strncasecmp_l_ssse3(char *a1, unsigned __int8 *a2, int a3, int a4)
{
  unsigned __int8 *v4; // edx
  unsigned __int8 *v5; // eax
  unsigned int v6; // ebp
  __m128i v7; // xmm1
  __m128i v8; // xmm2
  __m128i v9; // xmm1
  int v10; // ecx
  unsigned int v11; // ecx
  unsigned int v12; // edi
  const __m128i *v13; // eax
  const __m128i *v14; // edx
  const __m128i *v15; // et0
  unsigned int v16; // et1
  int v17; // edi
  bool v18; // zf
  __m128i si128; // xmm1
  __m128i v20; // xmm2
  unsigned int v21; // edi
  int v22; // esi
  int v23; // edi
  __m128i v24; // xmm0
  __m128i v25; // xmm1
  __m128i v26; // xmm2
  __m128i v27; // xmm1
  __m128i v28; // xmm1
  __m128i v29; // xmm2
  unsigned int v30; // edi
  __m128i v31; // xmm3
  __m128i v32; // xmm0
  int v33; // edi
  __m128i v34; // xmm1
  __m128i v35; // xmm4
  __m128i v36; // xmm2
  __m128i v37; // xmm1
  __m128i v38; // xmm1
  __m128i v39; // xmm4
  __m128i v40; // xmm2
  __m128i v41; // xmm1
  __m128i v42; // xmm0
  __m128i v43; // xmm1
  __m128i v44; // xmm0
  __m128i v45; // xmm3
  __m128i v46; // xmm1
  __m128i v47; // xmm2
  unsigned int v48; // edi
  __m128i v49; // xmm3
  __m128i v50; // xmm0
  int v51; // edi
  __m128i v52; // xmm1
  __m128i v53; // xmm4
  __m128i v54; // xmm2
  __m128i v55; // xmm1
  __m128i v56; // xmm1
  __m128i v57; // xmm4
  __m128i v58; // xmm2
  __m128i v59; // xmm1
  __m128i v60; // xmm0
  __m128i v61; // xmm1
  __m128i v62; // xmm2
  unsigned int v63; // edi
  __m128i v64; // xmm3
  __m128i v65; // xmm0
  int v66; // edi
  __m128i v67; // xmm1
  __m128i v68; // xmm4
  __m128i v69; // xmm2
  __m128i v70; // xmm1
  __m128i v71; // xmm1
  __m128i v72; // xmm4
  __m128i v73; // xmm2
  __m128i v74; // xmm1
  __m128i v75; // xmm0
  __m128i v76; // xmm1
  __m128i v77; // xmm2
  unsigned int v78; // edi
  __m128i v79; // xmm3
  __m128i v80; // xmm0
  int v81; // edi
  __m128i v82; // xmm1
  __m128i v83; // xmm4
  __m128i v84; // xmm2
  __m128i v85; // xmm1
  __m128i v86; // xmm1
  __m128i v87; // xmm4
  __m128i v88; // xmm2
  __m128i v89; // xmm1
  __m128i v90; // xmm0
  __m128i v91; // xmm1
  __m128i v92; // xmm2
  unsigned int v93; // edi
  __m128i v94; // xmm3
  __m128i v95; // xmm0
  int v96; // edi
  __m128i v97; // xmm1
  __m128i v98; // xmm4
  __m128i v99; // xmm2
  __m128i v100; // xmm1
  __m128i v101; // xmm1
  __m128i v102; // xmm4
  __m128i v103; // xmm2
  __m128i v104; // xmm1
  __m128i v105; // xmm0
  __m128i v106; // xmm1
  __m128i v107; // xmm2
  unsigned int v108; // edi
  __m128i v109; // xmm3
  __m128i v110; // xmm0
  int v111; // edi
  __m128i v112; // xmm1
  __m128i v113; // xmm4
  __m128i v114; // xmm2
  __m128i v115; // xmm1
  __m128i v116; // xmm1
  __m128i v117; // xmm4
  __m128i v118; // xmm2
  __m128i v119; // xmm1
  __m128i v120; // xmm0
  __m128i v121; // xmm1
  __m128i v122; // xmm2
  unsigned int v123; // edi
  __m128i v124; // xmm3
  __m128i v125; // xmm0
  int v126; // edi
  __m128i v127; // xmm1
  __m128i v128; // xmm4
  __m128i v129; // xmm2
  __m128i v130; // xmm1
  __m128i v131; // xmm1
  __m128i v132; // xmm4
  __m128i v133; // xmm2
  __m128i v134; // xmm1
  __m128i v135; // xmm0
  __m128i v136; // xmm1
  __m128i v137; // xmm2
  unsigned int v138; // edi
  __m128i v139; // xmm3
  __m128i v140; // xmm0
  int v141; // edi
  __m128i v142; // xmm1
  __m128i v143; // xmm4
  __m128i v144; // xmm2
  __m128i v145; // xmm1
  __m128i v146; // xmm1
  __m128i v147; // xmm4
  __m128i v148; // xmm2
  __m128i v149; // xmm1
  __m128i v150; // xmm0
  __m128i v151; // xmm1
  __m128i v152; // xmm2
  unsigned int v153; // edi
  __m128i v154; // xmm3
  __m128i v155; // xmm0
  int v156; // edi
  __m128i v157; // xmm1
  __m128i v158; // xmm4
  __m128i v159; // xmm2
  __m128i v160; // xmm1
  __m128i v161; // xmm1
  __m128i v162; // xmm4
  __m128i v163; // xmm2
  __m128i v164; // xmm1
  __m128i v165; // xmm0
  __m128i v166; // xmm1
  __m128i v167; // xmm2
  unsigned int v168; // edi
  __m128i v169; // xmm3
  __m128i v170; // xmm0
  int v171; // edi
  __m128i v172; // xmm1
  __m128i v173; // xmm4
  __m128i v174; // xmm2
  __m128i v175; // xmm1
  __m128i v176; // xmm1
  __m128i v177; // xmm4
  __m128i v178; // xmm2
  __m128i v179; // xmm1
  __m128i v180; // xmm0
  __m128i v181; // xmm1
  __m128i v182; // xmm2
  unsigned int v183; // edi
  __m128i v184; // xmm3
  __m128i v185; // xmm0
  int v186; // edi
  __m128i v187; // xmm1
  __m128i v188; // xmm4
  __m128i v189; // xmm2
  __m128i v190; // xmm1
  __m128i v191; // xmm1
  __m128i v192; // xmm4
  __m128i v193; // xmm2
  __m128i v194; // xmm1
  __m128i v195; // xmm0
  __m128i v196; // xmm1
  __m128i v197; // xmm2
  unsigned int v198; // edi
  __m128i v199; // xmm3
  __m128i v200; // xmm0
  int v201; // edi
  __m128i v202; // xmm1
  __m128i v203; // xmm4
  __m128i v204; // xmm2
  __m128i v205; // xmm1
  __m128i v206; // xmm1
  __m128i v207; // xmm4
  __m128i v208; // xmm2
  __m128i v209; // xmm1
  __m128i v210; // xmm0
  __m128i v211; // xmm1
  __m128i v212; // xmm2
  unsigned int v213; // edi
  __m128i v214; // xmm3
  __m128i v215; // xmm0
  int v216; // edi
  __m128i v217; // xmm1
  __m128i v218; // xmm4
  __m128i v219; // xmm2
  __m128i v220; // xmm1
  __m128i v221; // xmm1
  __m128i v222; // xmm4
  __m128i v223; // xmm2
  __m128i v224; // xmm1
  __m128i v225; // xmm0
  __m128i v226; // xmm1
  __m128i v227; // xmm2
  unsigned int v228; // edi
  __m128i v229; // xmm3
  __m128i v230; // xmm0
  int v231; // edi
  __m128i v232; // xmm1
  __m128i v233; // xmm4
  __m128i v234; // xmm2
  __m128i v235; // xmm1
  __m128i v236; // xmm1
  __m128i v237; // xmm4
  __m128i v238; // xmm2
  __m128i v239; // xmm1
  __m128i v240; // xmm0
  __m128i v241; // xmm1
  __m128i v242; // xmm2
  unsigned int v243; // edi
  __m128i v244; // xmm3
  __m128i v245; // xmm0
  int v246; // edi
  __m128i v247; // xmm1
  __m128i v248; // xmm4
  __m128i v249; // xmm2
  __m128i v250; // xmm1
  __m128i v251; // xmm1
  __m128i v252; // xmm4
  __m128i v253; // xmm2
  __m128i v254; // xmm1
  __m128i v255; // xmm0
  unsigned __int8 *v256; // et2
  int result; // eax
  unsigned int v258; // ecx
  unsigned int v259; // esi
  char v260; // cc
  unsigned int v261; // ecx
  unsigned int v262; // esi
  unsigned int v263; // ecx
  unsigned int v264; // esi
  unsigned int v265; // ecx
  unsigned int v266; // esi
  unsigned int v267; // ecx
  unsigned int v268; // esi
  unsigned int v269; // ecx
  unsigned int v270; // esi
  unsigned int v271; // ecx
  unsigned int v272; // esi
  unsigned int v273; // ecx
  unsigned int v274; // esi
  unsigned int v275; // ecx
  unsigned int v276; // esi
  unsigned int v277; // ecx
  unsigned int v278; // esi
  unsigned int v279; // ecx
  unsigned int v280; // esi
  unsigned int v281; // ecx
  unsigned int v282; // esi
  unsigned int v283; // ecx
  unsigned int v284; // esi
  unsigned int v285; // ecx
  unsigned int v286; // esi
  unsigned int v287; // ecx
  unsigned int v288; // esi
  char v289; // [esp+0h] [ebp-10h]

  if ( (*(_DWORD *)(*(_DWORD *)a4 + 320) & 1) != 0 )
    return _strncasecmp_nonascii(a1, a2, a3);
  v4 = (unsigned __int8 *)a1;
  v5 = a2;
  v6 = a3;
  if ( (unsigned int)a3 < 0x10 )
  {
    if ( !a3 )
      return 0;
    v258 = dword_80C1540[*a2];
    v259 = dword_80C1540[(unsigned __int8)*a1];
    v260 = v259 <= v258;
    if ( v259 != v258 )
      goto LABEL_328;
    if ( !(_BYTE)v258 )
      return 0;
    if ( a3 == 1 )
      return 0;
    v261 = dword_80C1540[a2[1]];
    v262 = dword_80C1540[(unsigned __int8)a1[1]];
    v260 = v262 <= v261;
    if ( v262 != v261 )
      goto LABEL_328;
    if ( !(_BYTE)v261 )
      return 0;
    if ( a3 == 2 )
      return 0;
    v263 = dword_80C1540[a2[2]];
    v264 = dword_80C1540[(unsigned __int8)a1[2]];
    v260 = v264 <= v263;
    if ( v264 != v263 )
      goto LABEL_328;
    if ( !(_BYTE)v263 )
      return 0;
    if ( a3 == 3 )
      return 0;
    v265 = dword_80C1540[a2[3]];
    v266 = dword_80C1540[(unsigned __int8)a1[3]];
    v260 = v266 <= v265;
    if ( v266 != v265 )
      goto LABEL_328;
    if ( !(_BYTE)v265 )
      return 0;
    if ( a3 == 4 )
      return 0;
    v267 = dword_80C1540[a2[4]];
    v268 = dword_80C1540[(unsigned __int8)a1[4]];
    v260 = v268 <= v267;
    if ( v268 != v267 )
      goto LABEL_328;
    if ( !(_BYTE)v267 )
      return 0;
    if ( a3 == 5 )
      return 0;
    v269 = dword_80C1540[a2[5]];
    v270 = dword_80C1540[(unsigned __int8)a1[5]];
    v260 = v270 <= v269;
    if ( v270 != v269 )
      goto LABEL_328;
    if ( !(_BYTE)v269 )
      return 0;
    if ( a3 == 6 )
      return 0;
    v271 = dword_80C1540[a2[6]];
    v272 = dword_80C1540[(unsigned __int8)a1[6]];
    v260 = v272 <= v271;
    if ( v272 != v271 )
      goto LABEL_328;
    if ( !(_BYTE)v271 )
      return 0;
    if ( a3 == 7 )
      return 0;
    v273 = dword_80C1540[a2[7]];
    v274 = dword_80C1540[(unsigned __int8)a1[7]];
    v260 = v274 <= v273;
    if ( v274 != v273 )
      goto LABEL_328;
    if ( !(_BYTE)v273 )
      return 0;
    if ( a3 == 8 )
      return 0;
    v275 = dword_80C1540[a2[8]];
    v276 = dword_80C1540[(unsigned __int8)a1[8]];
    v260 = v276 <= v275;
    if ( v276 != v275 )
      goto LABEL_328;
    if ( !(_BYTE)v275 )
      return 0;
    if ( a3 == 9 )
      return 0;
    v277 = dword_80C1540[a2[9]];
    v278 = dword_80C1540[(unsigned __int8)a1[9]];
    v260 = v278 <= v277;
    if ( v278 != v277 )
      goto LABEL_328;
    if ( !(_BYTE)v277 )
      return 0;
    if ( a3 == 10 )
      return 0;
    v279 = dword_80C1540[a2[10]];
    v280 = dword_80C1540[(unsigned __int8)a1[10]];
    v260 = v280 <= v279;
    if ( v280 != v279 )
      goto LABEL_328;
    if ( !(_BYTE)v279 )
      return 0;
    if ( a3 == 11 )
      return 0;
    v281 = dword_80C1540[a2[11]];
    v282 = dword_80C1540[(unsigned __int8)a1[11]];
    v260 = v282 <= v281;
    if ( v282 != v281 )
      goto LABEL_328;
    if ( !(_BYTE)v281 )
      return 0;
    if ( a3 == 12 )
      return 0;
    v283 = dword_80C1540[a2[12]];
    v284 = dword_80C1540[(unsigned __int8)a1[12]];
    v260 = v284 <= v283;
    if ( v284 != v283 )
      goto LABEL_328;
    if ( !(_BYTE)v283 )
      return 0;
    if ( a3 == 13 )
      return 0;
    v285 = dword_80C1540[a2[13]];
    v286 = dword_80C1540[(unsigned __int8)a1[13]];
    v260 = v286 <= v285;
    if ( v286 == v285 )
    {
      if ( !(_BYTE)v285 )
        return 0;
      if ( a3 == 14 )
        return 0;
      v287 = dword_80C1540[a2[14]];
      v288 = dword_80C1540[(unsigned __int8)a1[14]];
      v260 = v288 <= v287;
      if ( v288 == v287 )
        return 0;
    }
LABEL_328:
    result = 1;
    if ( v260 )
      return -1;
    return result;
  }
  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFF0 && ((unsigned __int16)a2 & 0xFFFu) <= 0xFF0 )
  {
    v7.m128i_i64[0] = *(__int64 *)a2;
    v8.m128i_i64[0] = *(__int64 *)a1;
    v7.m128i_i64[1] = *((__int64 *)a2 + 1);
    v8.m128i_i64[1] = *((__int64 *)a1 + 1);
    v9 = _mm_or_si128(
           v7,
           _mm_and_si128(
             _mm_and_si128(
               _mm_cmpgt_epi8(v7, (__m128i)xmmword_80BE5A0),
               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v7)),
             (__m128i)xmmword_80BE5C0));
    v10 = _mm_movemask_epi8(
            _mm_sub_epi8(
              _mm_cmpeq_epi8(
                v9,
                _mm_or_si128(
                  v8,
                  _mm_and_si128(
                    _mm_and_si128(
                      _mm_cmpgt_epi8(v8, (__m128i)xmmword_80BE5A0),
                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v8)),
                    (__m128i)xmmword_80BE5C0))),
              _mm_cmpeq_epi8((__m128i)0LL, v9)))
        - 0xFFFF;
    if ( v10 )
      goto LABEL_248;
    v6 = a3 - 16;
    if ( (unsigned int)a3 <= 0x10 )
      return 0;
    v5 = a2 + 16;
    v4 = (unsigned __int8 *)(a1 + 16);
  }
  v289 = 0;
  v11 = (unsigned __int8)v5 & 0xF;
  v12 = (unsigned __int8)v4 & 0xF;
  v13 = (const __m128i *)(v11 ^ (unsigned int)v5);
  v14 = (const __m128i *)(v12 ^ (unsigned int)v4);
  if ( v11 == v12 )
  {
LABEL_27:
    si128 = _mm_load_si128(v13);
    v20 = _mm_load_si128(v14);
    v21 = (unsigned int)_mm_movemask_epi8(
                          _mm_sub_epi8(
                            _mm_cmpeq_epi8(
                              _mm_or_si128(
                                si128,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(si128, (__m128i)xmmword_80BE5A0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), si128)),
                                  (__m128i)xmmword_80BE5C0)),
                              _mm_or_si128(
                                v20,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(v20, (__m128i)xmmword_80BE5A0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v20)),
                                  (__m128i)xmmword_80BE5C0))),
                            _mm_cmpeq_epi8((__m128i)0LL, si128))) >> v11;
    v22 = (0xFFFFu >> v11) - v21;
    v18 = 0xFFFFu >> v11 == v21;
    v23 = v11;
    if ( !v18 )
      goto LABEL_245;
    if ( v6 > 16 - v11 )
    {
      v6 -= 16 - v11;
      v289 = 16;
      v11 = 16;
      v24 = 0LL;
      while ( 1 )
      {
        v25 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
        v26 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
        v27 = _mm_or_si128(
                v25,
                _mm_and_si128(
                  _mm_and_si128(
                    _mm_cmpgt_epi8(v25, (__m128i)xmmword_80BE5A0),
                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v25)),
                  (__m128i)xmmword_80BE5C0));
        v24 = _mm_cmpeq_epi8(v24, v27);
        v22 = _mm_movemask_epi8(
                _mm_sub_epi8(
                  _mm_cmpeq_epi8(
                    v27,
                    _mm_or_si128(
                      v26,
                      _mm_and_si128(
                        _mm_and_si128(
                          _mm_cmpgt_epi8(v26, (__m128i)xmmword_80BE5A0),
                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v26)),
                        (__m128i)xmmword_80BE5C0))),
                  v24))
            - 0xFFFF;
        if ( v22 )
          break;
        v260 = v6 <= 0x10;
        v6 -= 16;
        if ( v260 )
          return 0;
        v11 += 16;
      }
      goto LABEL_244;
    }
    return 0;
  }
  if ( v11 <= v12 )
  {
    v289 = 32;
    v15 = v13;
    v13 = v14;
    v14 = v15;
    v16 = v11;
    v11 = v12;
    v12 = v16;
  }
  v17 = v12 + 15 - v11;
  v18 = v17 == 8;
  if ( v17 <= 8 )
    goto LABEL_18;
  if ( v17 != 14 )
  {
    if ( v17 != 13 )
    {
      if ( v17 != 12 )
      {
        if ( v17 != 11 )
        {
          if ( v17 != 10 )
          {
            v18 = v17 == 9;
            if ( v17 != 9 )
            {
LABEL_18:
              if ( !v18 )
              {
                if ( v17 != 7 )
                {
                  if ( v17 != 6 )
                  {
                    if ( v17 != 5 )
                    {
                      if ( v17 != 4 )
                      {
                        if ( v17 != 3 )
                        {
                          if ( v17 != 2 )
                          {
                            if ( v17 != 1 )
                            {
                              if ( v17 )
                                goto LABEL_27;
                              v28 = _mm_load_si128(v13);
                              v29 = _mm_slli_si128(_mm_load_si128(v14), 15);
                              v30 = (unsigned int)_mm_movemask_epi8(
                                                    _mm_sub_epi8(
                                                      _mm_cmpeq_epi8(
                                                        _mm_or_si128(
                                                          v29,
                                                          _mm_and_si128(
                                                            _mm_and_si128(
                                                              _mm_cmpgt_epi8(v29, (__m128i)xmmword_80BE5A0),
                                                              _mm_cmpgt_epi8(
                                                                _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                                v29)),
                                                            (__m128i)xmmword_80BE5C0)),
                                                        _mm_or_si128(
                                                          v28,
                                                          _mm_and_si128(
                                                            _mm_and_si128(
                                                              _mm_cmpgt_epi8(v28, (__m128i)xmmword_80BE5A0),
                                                              _mm_cmpgt_epi8(
                                                                _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                                v28)),
                                                            (__m128i)xmmword_80BE5C0))),
                                                      _mm_cmpeq_epi8((__m128i)0LL, v28))) >> v11;
                              v22 = (0xFFFFu >> v11) - v30;
                              v18 = 0xFFFFu >> v11 == v30;
                              v23 = v11 - 15;
                              if ( !v18 )
                                goto LABEL_245;
                              if ( v6 <= 16 - v11 )
                                return 0;
                              v6 -= 16 - v11;
                              v31 = _mm_load_si128(v14);
                              v32 = 0LL;
                              v11 = 16;
                              v289 |= 1u;
                              v33 = (((_WORD)v14 + 1) & 0xFFF) - 4096;
                              while ( 1 )
                              {
                                v260 = (v33 + 16 < 0) ^ __OFADD__(16, v33) | (v33 == -16);
                                v33 += 16;
                                if ( !v260 )
                                  goto LABEL_43;
                                while ( 1 )
                                {
                                  v34 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                                  v35 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                                  v36 = _mm_alignr_epi8(v35, v31, 1);
                                  v37 = _mm_or_si128(
                                          v34,
                                          _mm_and_si128(
                                            _mm_and_si128(
                                              _mm_cmpgt_epi8(v34, (__m128i)xmmword_80BE5A0),
                                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v34)),
                                            (__m128i)xmmword_80BE5C0));
                                  v32 = _mm_cmpeq_epi8(v32, v37);
                                  v22 = _mm_movemask_epi8(
                                          _mm_sub_epi8(
                                            _mm_cmpeq_epi8(
                                              v37,
                                              _mm_or_si128(
                                                v36,
                                                _mm_and_si128(
                                                  _mm_and_si128(
                                                    _mm_cmpgt_epi8(v36, (__m128i)xmmword_80BE5A0),
                                                    _mm_cmpgt_epi8(
                                                      _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                      v36)),
                                                  (__m128i)xmmword_80BE5C0))),
                                            v32))
                                      - 0xFFFF;
                                  if ( v22 )
                                    goto LABEL_244;
                                  v260 = v6 <= 0x10;
                                  v6 -= 16;
                                  if ( v260 )
                                    return 0;
                                  v11 += 16;
                                  v31 = v35;
                                  v260 = (v33 + 16 < 0) ^ __OFADD__(16, v33) | (v33 == -16);
                                  v33 += 16;
                                  if ( v260 )
                                    break;
LABEL_43:
                                  v42 = _mm_cmpeq_epi8(v32, v31);
                                  if ( (_mm_movemask_epi8(v42) & 0xFFFE) != 0 || v6 <= 0xF )
                                  {
                                    v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                                    v44 = _mm_srli_si128(v42, 1);
                                    v45 = _mm_srli_si128(v31, 1);
                                    goto LABEL_243;
                                  }
                                  v32 = 0LL;
                                  v33 -= 4096;
                                }
                                v38 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                                v39 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                                v40 = _mm_alignr_epi8(v39, v31, 1);
                                v41 = _mm_or_si128(
                                        v38,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v38, (__m128i)xmmword_80BE5A0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v38)),
                                          (__m128i)xmmword_80BE5C0));
                                v32 = _mm_cmpeq_epi8(v32, v41);
                                v22 = _mm_movemask_epi8(
                                        _mm_sub_epi8(
                                          _mm_cmpeq_epi8(
                                            v41,
                                            _mm_or_si128(
                                              v40,
                                              _mm_and_si128(
                                                _mm_and_si128(
                                                  _mm_cmpgt_epi8(v40, (__m128i)xmmword_80BE5A0),
                                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v40)),
                                                (__m128i)xmmword_80BE5C0))),
                                          v32))
                                    - 0xFFFF;
                                if ( v22 )
                                  goto LABEL_244;
                                v260 = v6 <= 0x10;
                                v6 -= 16;
                                if ( v260 )
                                  return 0;
                                v11 += 16;
                                v31 = v39;
                              }
                            }
                            v46 = _mm_load_si128(v13);
                            v47 = _mm_slli_si128(_mm_load_si128(v14), 14);
                            v48 = (unsigned int)_mm_movemask_epi8(
                                                  _mm_sub_epi8(
                                                    _mm_cmpeq_epi8(
                                                      _mm_or_si128(
                                                        v47,
                                                        _mm_and_si128(
                                                          _mm_and_si128(
                                                            _mm_cmpgt_epi8(v47, (__m128i)xmmword_80BE5A0),
                                                            _mm_cmpgt_epi8(
                                                              _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                              v47)),
                                                          (__m128i)xmmword_80BE5C0)),
                                                      _mm_or_si128(
                                                        v46,
                                                        _mm_and_si128(
                                                          _mm_and_si128(
                                                            _mm_cmpgt_epi8(v46, (__m128i)xmmword_80BE5A0),
                                                            _mm_cmpgt_epi8(
                                                              _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                              v46)),
                                                          (__m128i)xmmword_80BE5C0))),
                                                    _mm_cmpeq_epi8((__m128i)0LL, v46))) >> v11;
                            v22 = (0xFFFFu >> v11) - v48;
                            v18 = 0xFFFFu >> v11 == v48;
                            v23 = v11 - 14;
                            if ( !v18 )
                              goto LABEL_245;
                            if ( v6 <= 16 - v11 )
                              return 0;
                            v6 -= 16 - v11;
                            v49 = _mm_load_si128(v14);
                            v50 = 0LL;
                            v11 = 16;
                            v289 |= 2u;
                            v51 = (((_WORD)v14 + 2) & 0xFFF) - 4096;
                            while ( 1 )
                            {
                              v260 = (v51 + 16 < 0) ^ __OFADD__(16, v51) | (v51 == -16);
                              v51 += 16;
                              if ( !v260 )
                                goto LABEL_57;
                              while ( 1 )
                              {
                                v52 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                                v53 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                                v54 = _mm_alignr_epi8(v53, v49, 2);
                                v55 = _mm_or_si128(
                                        v52,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v52, (__m128i)xmmword_80BE5A0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v52)),
                                          (__m128i)xmmword_80BE5C0));
                                v50 = _mm_cmpeq_epi8(v50, v55);
                                v22 = _mm_movemask_epi8(
                                        _mm_sub_epi8(
                                          _mm_cmpeq_epi8(
                                            v55,
                                            _mm_or_si128(
                                              v54,
                                              _mm_and_si128(
                                                _mm_and_si128(
                                                  _mm_cmpgt_epi8(v54, (__m128i)xmmword_80BE5A0),
                                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v54)),
                                                (__m128i)xmmword_80BE5C0))),
                                          v50))
                                    - 0xFFFF;
                                if ( v22 )
                                  goto LABEL_244;
                                v260 = v6 <= 0x10;
                                v6 -= 16;
                                if ( v260 )
                                  return 0;
                                v11 += 16;
                                v49 = v53;
                                v260 = (v51 + 16 < 0) ^ __OFADD__(16, v51) | (v51 == -16);
                                v51 += 16;
                                if ( v260 )
                                  break;
LABEL_57:
                                v60 = _mm_cmpeq_epi8(v50, v49);
                                if ( (_mm_movemask_epi8(v60) & 0xFFFC) != 0 || v6 <= 0xE )
                                {
                                  v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                                  v44 = _mm_srli_si128(v60, 2);
                                  v45 = _mm_srli_si128(v49, 2);
                                  goto LABEL_243;
                                }
                                v50 = 0LL;
                                v51 -= 4096;
                              }
                              v56 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                              v57 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                              v58 = _mm_alignr_epi8(v57, v49, 2);
                              v59 = _mm_or_si128(
                                      v56,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v56, (__m128i)xmmword_80BE5A0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v56)),
                                        (__m128i)xmmword_80BE5C0));
                              v50 = _mm_cmpeq_epi8(v50, v59);
                              v22 = _mm_movemask_epi8(
                                      _mm_sub_epi8(
                                        _mm_cmpeq_epi8(
                                          v59,
                                          _mm_or_si128(
                                            v58,
                                            _mm_and_si128(
                                              _mm_and_si128(
                                                _mm_cmpgt_epi8(v58, (__m128i)xmmword_80BE5A0),
                                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v58)),
                                              (__m128i)xmmword_80BE5C0))),
                                        v50))
                                  - 0xFFFF;
                              if ( v22 )
                                goto LABEL_244;
                              v260 = v6 <= 0x10;
                              v6 -= 16;
                              if ( v260 )
                                return 0;
                              v11 += 16;
                              v49 = v57;
                            }
                          }
                          v61 = _mm_load_si128(v13);
                          v62 = _mm_slli_si128(_mm_load_si128(v14), 13);
                          v63 = (unsigned int)_mm_movemask_epi8(
                                                _mm_sub_epi8(
                                                  _mm_cmpeq_epi8(
                                                    _mm_or_si128(
                                                      v62,
                                                      _mm_and_si128(
                                                        _mm_and_si128(
                                                          _mm_cmpgt_epi8(v62, (__m128i)xmmword_80BE5A0),
                                                          _mm_cmpgt_epi8(
                                                            _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                            v62)),
                                                        (__m128i)xmmword_80BE5C0)),
                                                    _mm_or_si128(
                                                      v61,
                                                      _mm_and_si128(
                                                        _mm_and_si128(
                                                          _mm_cmpgt_epi8(v61, (__m128i)xmmword_80BE5A0),
                                                          _mm_cmpgt_epi8(
                                                            _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                            v61)),
                                                        (__m128i)xmmword_80BE5C0))),
                                                  _mm_cmpeq_epi8((__m128i)0LL, v61))) >> v11;
                          v22 = (0xFFFFu >> v11) - v63;
                          v18 = 0xFFFFu >> v11 == v63;
                          v23 = v11 - 13;
                          if ( !v18 )
                            goto LABEL_245;
                          if ( v6 <= 16 - v11 )
                            return 0;
                          v6 -= 16 - v11;
                          v64 = _mm_load_si128(v14);
                          v65 = 0LL;
                          v11 = 16;
                          v289 |= 3u;
                          v66 = (((_WORD)v14 + 3) & 0xFFF) - 4096;
                          while ( 1 )
                          {
                            v260 = (v66 + 16 < 0) ^ __OFADD__(16, v66) | (v66 == -16);
                            v66 += 16;
                            if ( !v260 )
                              goto LABEL_71;
                            while ( 1 )
                            {
                              v67 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                              v68 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                              v69 = _mm_alignr_epi8(v68, v64, 3);
                              v70 = _mm_or_si128(
                                      v67,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v67, (__m128i)xmmword_80BE5A0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v67)),
                                        (__m128i)xmmword_80BE5C0));
                              v65 = _mm_cmpeq_epi8(v65, v70);
                              v22 = _mm_movemask_epi8(
                                      _mm_sub_epi8(
                                        _mm_cmpeq_epi8(
                                          v70,
                                          _mm_or_si128(
                                            v69,
                                            _mm_and_si128(
                                              _mm_and_si128(
                                                _mm_cmpgt_epi8(v69, (__m128i)xmmword_80BE5A0),
                                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v69)),
                                              (__m128i)xmmword_80BE5C0))),
                                        v65))
                                  - 0xFFFF;
                              if ( v22 )
                                goto LABEL_244;
                              v260 = v6 <= 0x10;
                              v6 -= 16;
                              if ( v260 )
                                return 0;
                              v11 += 16;
                              v64 = v68;
                              v260 = (v66 + 16 < 0) ^ __OFADD__(16, v66) | (v66 == -16);
                              v66 += 16;
                              if ( v260 )
                                break;
LABEL_71:
                              v75 = _mm_cmpeq_epi8(v65, v64);
                              if ( (_mm_movemask_epi8(v75) & 0xFFF8) != 0 || v6 <= 0xD )
                              {
                                v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                                v44 = _mm_srli_si128(v75, 3);
                                v45 = _mm_srli_si128(v64, 3);
                                goto LABEL_243;
                              }
                              v65 = 0LL;
                              v66 -= 4096;
                            }
                            v71 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                            v72 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                            v73 = _mm_alignr_epi8(v72, v64, 3);
                            v74 = _mm_or_si128(
                                    v71,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v71, (__m128i)xmmword_80BE5A0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v71)),
                                      (__m128i)xmmword_80BE5C0));
                            v65 = _mm_cmpeq_epi8(v65, v74);
                            v22 = _mm_movemask_epi8(
                                    _mm_sub_epi8(
                                      _mm_cmpeq_epi8(
                                        v74,
                                        _mm_or_si128(
                                          v73,
                                          _mm_and_si128(
                                            _mm_and_si128(
                                              _mm_cmpgt_epi8(v73, (__m128i)xmmword_80BE5A0),
                                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v73)),
                                            (__m128i)xmmword_80BE5C0))),
                                      v65))
                                - 0xFFFF;
                            if ( v22 )
                              goto LABEL_244;
                            v260 = v6 <= 0x10;
                            v6 -= 16;
                            if ( v260 )
                              return 0;
                            v11 += 16;
                            v64 = v72;
                          }
                        }
                        v76 = _mm_load_si128(v13);
                        v77 = _mm_slli_si128(_mm_load_si128(v14), 12);
                        v78 = (unsigned int)_mm_movemask_epi8(
                                              _mm_sub_epi8(
                                                _mm_cmpeq_epi8(
                                                  _mm_or_si128(
                                                    v77,
                                                    _mm_and_si128(
                                                      _mm_and_si128(
                                                        _mm_cmpgt_epi8(v77, (__m128i)xmmword_80BE5A0),
                                                        _mm_cmpgt_epi8(
                                                          _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                          v77)),
                                                      (__m128i)xmmword_80BE5C0)),
                                                  _mm_or_si128(
                                                    v76,
                                                    _mm_and_si128(
                                                      _mm_and_si128(
                                                        _mm_cmpgt_epi8(v76, (__m128i)xmmword_80BE5A0),
                                                        _mm_cmpgt_epi8(
                                                          _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                          v76)),
                                                      (__m128i)xmmword_80BE5C0))),
                                                _mm_cmpeq_epi8((__m128i)0LL, v76))) >> v11;
                        v22 = (0xFFFFu >> v11) - v78;
                        v18 = 0xFFFFu >> v11 == v78;
                        v23 = v11 - 12;
                        if ( !v18 )
                          goto LABEL_245;
                        if ( v6 <= 16 - v11 )
                          return 0;
                        v6 -= 16 - v11;
                        v79 = _mm_load_si128(v14);
                        v80 = 0LL;
                        v11 = 16;
                        v289 |= 4u;
                        v81 = (((_WORD)v14 + 4) & 0xFFF) - 4096;
                        while ( 1 )
                        {
                          v260 = (v81 + 16 < 0) ^ __OFADD__(16, v81) | (v81 == -16);
                          v81 += 16;
                          if ( !v260 )
                            goto LABEL_85;
                          while ( 1 )
                          {
                            v82 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                            v83 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                            v84 = _mm_alignr_epi8(v83, v79, 4);
                            v85 = _mm_or_si128(
                                    v82,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v82, (__m128i)xmmword_80BE5A0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v82)),
                                      (__m128i)xmmword_80BE5C0));
                            v80 = _mm_cmpeq_epi8(v80, v85);
                            v22 = _mm_movemask_epi8(
                                    _mm_sub_epi8(
                                      _mm_cmpeq_epi8(
                                        v85,
                                        _mm_or_si128(
                                          v84,
                                          _mm_and_si128(
                                            _mm_and_si128(
                                              _mm_cmpgt_epi8(v84, (__m128i)xmmword_80BE5A0),
                                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v84)),
                                            (__m128i)xmmword_80BE5C0))),
                                      v80))
                                - 0xFFFF;
                            if ( v22 )
                              goto LABEL_244;
                            v260 = v6 <= 0x10;
                            v6 -= 16;
                            if ( v260 )
                              return 0;
                            v11 += 16;
                            v79 = v83;
                            v260 = (v81 + 16 < 0) ^ __OFADD__(16, v81) | (v81 == -16);
                            v81 += 16;
                            if ( v260 )
                              break;
LABEL_85:
                            v90 = _mm_cmpeq_epi8(v80, v79);
                            if ( (_mm_movemask_epi8(v90) & 0xFFF0) != 0 || v6 <= 0xC )
                            {
                              v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                              v44 = _mm_srli_si128(v90, 4);
                              v45 = _mm_srli_si128(v79, 4);
                              goto LABEL_243;
                            }
                            v80 = 0LL;
                            v81 -= 4096;
                          }
                          v86 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                          v87 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                          v88 = _mm_alignr_epi8(v87, v79, 4);
                          v89 = _mm_or_si128(
                                  v86,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v86, (__m128i)xmmword_80BE5A0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v86)),
                                    (__m128i)xmmword_80BE5C0));
                          v80 = _mm_cmpeq_epi8(v80, v89);
                          v22 = _mm_movemask_epi8(
                                  _mm_sub_epi8(
                                    _mm_cmpeq_epi8(
                                      v89,
                                      _mm_or_si128(
                                        v88,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v88, (__m128i)xmmword_80BE5A0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v88)),
                                          (__m128i)xmmword_80BE5C0))),
                                    v80))
                              - 0xFFFF;
                          if ( v22 )
                            goto LABEL_244;
                          v260 = v6 <= 0x10;
                          v6 -= 16;
                          if ( v260 )
                            return 0;
                          v11 += 16;
                          v79 = v87;
                        }
                      }
                      v91 = _mm_load_si128(v13);
                      v92 = _mm_slli_si128(_mm_load_si128(v14), 11);
                      v93 = (unsigned int)_mm_movemask_epi8(
                                            _mm_sub_epi8(
                                              _mm_cmpeq_epi8(
                                                _mm_or_si128(
                                                  v92,
                                                  _mm_and_si128(
                                                    _mm_and_si128(
                                                      _mm_cmpgt_epi8(v92, (__m128i)xmmword_80BE5A0),
                                                      _mm_cmpgt_epi8(
                                                        _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                        v92)),
                                                    (__m128i)xmmword_80BE5C0)),
                                                _mm_or_si128(
                                                  v91,
                                                  _mm_and_si128(
                                                    _mm_and_si128(
                                                      _mm_cmpgt_epi8(v91, (__m128i)xmmword_80BE5A0),
                                                      _mm_cmpgt_epi8(
                                                        _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                        v91)),
                                                    (__m128i)xmmword_80BE5C0))),
                                              _mm_cmpeq_epi8((__m128i)0LL, v91))) >> v11;
                      v22 = (0xFFFFu >> v11) - v93;
                      v18 = 0xFFFFu >> v11 == v93;
                      v23 = v11 - 11;
                      if ( !v18 )
                        goto LABEL_245;
                      if ( v6 <= 16 - v11 )
                        return 0;
                      v6 -= 16 - v11;
                      v94 = _mm_load_si128(v14);
                      v95 = 0LL;
                      v11 = 16;
                      v289 |= 5u;
                      v96 = (((_WORD)v14 + 5) & 0xFFF) - 4096;
                      while ( 1 )
                      {
                        v260 = (v96 + 16 < 0) ^ __OFADD__(16, v96) | (v96 == -16);
                        v96 += 16;
                        if ( !v260 )
                          goto LABEL_99;
                        while ( 1 )
                        {
                          v97 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                          v98 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                          v99 = _mm_alignr_epi8(v98, v94, 5);
                          v100 = _mm_or_si128(
                                   v97,
                                   _mm_and_si128(
                                     _mm_and_si128(
                                       _mm_cmpgt_epi8(v97, (__m128i)xmmword_80BE5A0),
                                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v97)),
                                     (__m128i)xmmword_80BE5C0));
                          v95 = _mm_cmpeq_epi8(v95, v100);
                          v22 = _mm_movemask_epi8(
                                  _mm_sub_epi8(
                                    _mm_cmpeq_epi8(
                                      v100,
                                      _mm_or_si128(
                                        v99,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v99, (__m128i)xmmword_80BE5A0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v99)),
                                          (__m128i)xmmword_80BE5C0))),
                                    v95))
                              - 0xFFFF;
                          if ( v22 )
                            goto LABEL_244;
                          v260 = v6 <= 0x10;
                          v6 -= 16;
                          if ( v260 )
                            return 0;
                          v11 += 16;
                          v94 = v98;
                          v260 = (v96 + 16 < 0) ^ __OFADD__(16, v96) | (v96 == -16);
                          v96 += 16;
                          if ( v260 )
                            break;
LABEL_99:
                          v105 = _mm_cmpeq_epi8(v95, v94);
                          if ( (_mm_movemask_epi8(v105) & 0xFFE0) != 0 || v6 <= 0xB )
                          {
                            v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                            v44 = _mm_srli_si128(v105, 5);
                            v45 = _mm_srli_si128(v94, 5);
                            goto LABEL_243;
                          }
                          v95 = 0LL;
                          v96 -= 4096;
                        }
                        v101 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                        v102 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                        v103 = _mm_alignr_epi8(v102, v94, 5);
                        v104 = _mm_or_si128(
                                 v101,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v101, (__m128i)xmmword_80BE5A0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v101)),
                                   (__m128i)xmmword_80BE5C0));
                        v95 = _mm_cmpeq_epi8(v95, v104);
                        v22 = _mm_movemask_epi8(
                                _mm_sub_epi8(
                                  _mm_cmpeq_epi8(
                                    v104,
                                    _mm_or_si128(
                                      v103,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v103, (__m128i)xmmword_80BE5A0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v103)),
                                        (__m128i)xmmword_80BE5C0))),
                                  v95))
                            - 0xFFFF;
                        if ( v22 )
                          goto LABEL_244;
                        v260 = v6 <= 0x10;
                        v6 -= 16;
                        if ( v260 )
                          return 0;
                        v11 += 16;
                        v94 = v102;
                      }
                    }
                    v106 = _mm_load_si128(v13);
                    v107 = _mm_slli_si128(_mm_load_si128(v14), 10);
                    v108 = (unsigned int)_mm_movemask_epi8(
                                           _mm_sub_epi8(
                                             _mm_cmpeq_epi8(
                                               _mm_or_si128(
                                                 v107,
                                                 _mm_and_si128(
                                                   _mm_and_si128(
                                                     _mm_cmpgt_epi8(v107, (__m128i)xmmword_80BE5A0),
                                                     _mm_cmpgt_epi8(
                                                       _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                       v107)),
                                                   (__m128i)xmmword_80BE5C0)),
                                               _mm_or_si128(
                                                 v106,
                                                 _mm_and_si128(
                                                   _mm_and_si128(
                                                     _mm_cmpgt_epi8(v106, (__m128i)xmmword_80BE5A0),
                                                     _mm_cmpgt_epi8(
                                                       _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                       v106)),
                                                   (__m128i)xmmword_80BE5C0))),
                                             _mm_cmpeq_epi8((__m128i)0LL, v106))) >> v11;
                    v22 = (0xFFFFu >> v11) - v108;
                    v18 = 0xFFFFu >> v11 == v108;
                    v23 = v11 - 10;
                    if ( !v18 )
                      goto LABEL_245;
                    if ( v6 <= 16 - v11 )
                      return 0;
                    v6 -= 16 - v11;
                    v109 = _mm_load_si128(v14);
                    v110 = 0LL;
                    v11 = 16;
                    v289 |= 6u;
                    v111 = (((_WORD)v14 + 6) & 0xFFF) - 4096;
                    while ( 1 )
                    {
                      v260 = (v111 + 16 < 0) ^ __OFADD__(16, v111) | (v111 == -16);
                      v111 += 16;
                      if ( !v260 )
                        goto LABEL_113;
                      while ( 1 )
                      {
                        v112 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                        v113 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                        v114 = _mm_alignr_epi8(v113, v109, 6);
                        v115 = _mm_or_si128(
                                 v112,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v112, (__m128i)xmmword_80BE5A0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v112)),
                                   (__m128i)xmmword_80BE5C0));
                        v110 = _mm_cmpeq_epi8(v110, v115);
                        v22 = _mm_movemask_epi8(
                                _mm_sub_epi8(
                                  _mm_cmpeq_epi8(
                                    v115,
                                    _mm_or_si128(
                                      v114,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v114, (__m128i)xmmword_80BE5A0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v114)),
                                        (__m128i)xmmword_80BE5C0))),
                                  v110))
                            - 0xFFFF;
                        if ( v22 )
                          goto LABEL_244;
                        v260 = v6 <= 0x10;
                        v6 -= 16;
                        if ( v260 )
                          return 0;
                        v11 += 16;
                        v109 = v113;
                        v260 = (v111 + 16 < 0) ^ __OFADD__(16, v111) | (v111 == -16);
                        v111 += 16;
                        if ( v260 )
                          break;
LABEL_113:
                        v120 = _mm_cmpeq_epi8(v110, v109);
                        if ( (_mm_movemask_epi8(v120) & 0xFFC0) != 0 || v6 <= 0xA )
                        {
                          v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                          v44 = _mm_srli_si128(v120, 6);
                          v45 = _mm_srli_si128(v109, 6);
                          goto LABEL_243;
                        }
                        v110 = 0LL;
                        v111 -= 4096;
                      }
                      v116 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                      v117 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                      v118 = _mm_alignr_epi8(v117, v109, 6);
                      v119 = _mm_or_si128(
                               v116,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v116, (__m128i)xmmword_80BE5A0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v116)),
                                 (__m128i)xmmword_80BE5C0));
                      v110 = _mm_cmpeq_epi8(v110, v119);
                      v22 = _mm_movemask_epi8(
                              _mm_sub_epi8(
                                _mm_cmpeq_epi8(
                                  v119,
                                  _mm_or_si128(
                                    v118,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v118, (__m128i)xmmword_80BE5A0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v118)),
                                      (__m128i)xmmword_80BE5C0))),
                                v110))
                          - 0xFFFF;
                      if ( v22 )
                        goto LABEL_244;
                      v260 = v6 <= 0x10;
                      v6 -= 16;
                      if ( v260 )
                        return 0;
                      v11 += 16;
                      v109 = v117;
                    }
                  }
                  v121 = _mm_load_si128(v13);
                  v122 = _mm_slli_si128(_mm_load_si128(v14), 9);
                  v123 = (unsigned int)_mm_movemask_epi8(
                                         _mm_sub_epi8(
                                           _mm_cmpeq_epi8(
                                             _mm_or_si128(
                                               v122,
                                               _mm_and_si128(
                                                 _mm_and_si128(
                                                   _mm_cmpgt_epi8(v122, (__m128i)xmmword_80BE5A0),
                                                   _mm_cmpgt_epi8(
                                                     _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                     v122)),
                                                 (__m128i)xmmword_80BE5C0)),
                                             _mm_or_si128(
                                               v121,
                                               _mm_and_si128(
                                                 _mm_and_si128(
                                                   _mm_cmpgt_epi8(v121, (__m128i)xmmword_80BE5A0),
                                                   _mm_cmpgt_epi8(
                                                     _mm_load_si128((const __m128i *)&xmmword_80BE5B0),
                                                     v121)),
                                                 (__m128i)xmmword_80BE5C0))),
                                           _mm_cmpeq_epi8((__m128i)0LL, v121))) >> v11;
                  v22 = (0xFFFFu >> v11) - v123;
                  v18 = 0xFFFFu >> v11 == v123;
                  v23 = v11 - 9;
                  if ( !v18 )
                    goto LABEL_245;
                  if ( v6 <= 16 - v11 )
                    return 0;
                  v6 -= 16 - v11;
                  v124 = _mm_load_si128(v14);
                  v125 = 0LL;
                  v11 = 16;
                  v289 |= 7u;
                  v126 = (((_WORD)v14 + 8) & 0xFFF) - 4096;
                  while ( 1 )
                  {
                    v260 = (v126 + 16 < 0) ^ __OFADD__(16, v126) | (v126 == -16);
                    v126 += 16;
                    if ( !v260 )
                      goto LABEL_127;
                    while ( 1 )
                    {
                      v127 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                      v128 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                      v129 = _mm_alignr_epi8(v128, v124, 7);
                      v130 = _mm_or_si128(
                               v127,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v127, (__m128i)xmmword_80BE5A0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v127)),
                                 (__m128i)xmmword_80BE5C0));
                      v125 = _mm_cmpeq_epi8(v125, v130);
                      v22 = _mm_movemask_epi8(
                              _mm_sub_epi8(
                                _mm_cmpeq_epi8(
                                  v130,
                                  _mm_or_si128(
                                    v129,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v129, (__m128i)xmmword_80BE5A0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v129)),
                                      (__m128i)xmmword_80BE5C0))),
                                v125))
                          - 0xFFFF;
                      if ( v22 )
                        goto LABEL_244;
                      v260 = v6 <= 0x10;
                      v6 -= 16;
                      if ( v260 )
                        return 0;
                      v11 += 16;
                      v124 = v128;
                      v260 = (v126 + 16 < 0) ^ __OFADD__(16, v126) | (v126 == -16);
                      v126 += 16;
                      if ( v260 )
                        break;
LABEL_127:
                      v135 = _mm_cmpeq_epi8(v125, v124);
                      if ( (_mm_movemask_epi8(v135) & 0xFF80) != 0 || v6 <= 9 )
                      {
                        v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                        v44 = _mm_srli_si128(v135, 7);
                        v45 = _mm_srli_si128(v124, 7);
                        goto LABEL_243;
                      }
                      v125 = 0LL;
                      v126 -= 4096;
                    }
                    v131 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                    v132 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                    v133 = _mm_alignr_epi8(v132, v124, 7);
                    v134 = _mm_or_si128(
                             v131,
                             _mm_and_si128(
                               _mm_and_si128(
                                 _mm_cmpgt_epi8(v131, (__m128i)xmmword_80BE5A0),
                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v131)),
                               (__m128i)xmmword_80BE5C0));
                    v125 = _mm_cmpeq_epi8(v125, v134);
                    v22 = _mm_movemask_epi8(
                            _mm_sub_epi8(
                              _mm_cmpeq_epi8(
                                v134,
                                _mm_or_si128(
                                  v133,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v133, (__m128i)xmmword_80BE5A0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v133)),
                                    (__m128i)xmmword_80BE5C0))),
                              v125))
                        - 0xFFFF;
                    if ( v22 )
                      goto LABEL_244;
                    v260 = v6 <= 0x10;
                    v6 -= 16;
                    if ( v260 )
                      return 0;
                    v11 += 16;
                    v124 = v132;
                  }
                }
                v136 = _mm_load_si128(v13);
                v137 = _mm_slli_si128(_mm_load_si128(v14), 8);
                v138 = (unsigned int)_mm_movemask_epi8(
                                       _mm_sub_epi8(
                                         _mm_cmpeq_epi8(
                                           _mm_or_si128(
                                             v137,
                                             _mm_and_si128(
                                               _mm_and_si128(
                                                 _mm_cmpgt_epi8(v137, (__m128i)xmmword_80BE5A0),
                                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v137)),
                                               (__m128i)xmmword_80BE5C0)),
                                           _mm_or_si128(
                                             v136,
                                             _mm_and_si128(
                                               _mm_and_si128(
                                                 _mm_cmpgt_epi8(v136, (__m128i)xmmword_80BE5A0),
                                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v136)),
                                               (__m128i)xmmword_80BE5C0))),
                                         _mm_cmpeq_epi8((__m128i)0LL, v136))) >> v11;
                v22 = (0xFFFFu >> v11) - v138;
                v18 = 0xFFFFu >> v11 == v138;
                v23 = v11 - 8;
                if ( !v18 )
                  goto LABEL_245;
                if ( v6 <= 16 - v11 )
                  return 0;
                v6 -= 16 - v11;
                v139 = _mm_load_si128(v14);
                v140 = 0LL;
                v11 = 16;
                v289 |= 8u;
                v141 = (((_WORD)v14 + 8) & 0xFFF) - 4096;
                while ( 1 )
                {
                  v260 = (v141 + 16 < 0) ^ __OFADD__(16, v141) | (v141 == -16);
                  v141 += 16;
                  if ( !v260 )
                    goto LABEL_141;
                  while ( 1 )
                  {
                    v142 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                    v143 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                    v144 = _mm_alignr_epi8(v143, v139, 8);
                    v145 = _mm_or_si128(
                             v142,
                             _mm_and_si128(
                               _mm_and_si128(
                                 _mm_cmpgt_epi8(v142, (__m128i)xmmword_80BE5A0),
                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v142)),
                               (__m128i)xmmword_80BE5C0));
                    v140 = _mm_cmpeq_epi8(v140, v145);
                    v22 = _mm_movemask_epi8(
                            _mm_sub_epi8(
                              _mm_cmpeq_epi8(
                                v145,
                                _mm_or_si128(
                                  v144,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v144, (__m128i)xmmword_80BE5A0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v144)),
                                    (__m128i)xmmword_80BE5C0))),
                              v140))
                        - 0xFFFF;
                    if ( v22 )
                      goto LABEL_244;
                    v260 = v6 <= 0x10;
                    v6 -= 16;
                    if ( v260 )
                      return 0;
                    v11 += 16;
                    v139 = v143;
                    v260 = (v141 + 16 < 0) ^ __OFADD__(16, v141) | (v141 == -16);
                    v141 += 16;
                    if ( v260 )
                      break;
LABEL_141:
                    v150 = _mm_cmpeq_epi8(v140, v139);
                    if ( (_mm_movemask_epi8(v150) & 0xFF00) != 0 || v6 <= 8 )
                    {
                      v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                      v44 = _mm_srli_si128(v150, 8);
                      v45 = _mm_srli_si128(v139, 8);
                      goto LABEL_243;
                    }
                    v140 = 0LL;
                    v141 -= 4096;
                  }
                  v146 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                  v147 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                  v148 = _mm_alignr_epi8(v147, v139, 8);
                  v149 = _mm_or_si128(
                           v146,
                           _mm_and_si128(
                             _mm_and_si128(
                               _mm_cmpgt_epi8(v146, (__m128i)xmmword_80BE5A0),
                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v146)),
                             (__m128i)xmmword_80BE5C0));
                  v140 = _mm_cmpeq_epi8(v140, v149);
                  v22 = _mm_movemask_epi8(
                          _mm_sub_epi8(
                            _mm_cmpeq_epi8(
                              v149,
                              _mm_or_si128(
                                v148,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(v148, (__m128i)xmmword_80BE5A0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v148)),
                                  (__m128i)xmmword_80BE5C0))),
                            v140))
                      - 0xFFFF;
                  if ( v22 )
                    goto LABEL_244;
                  v260 = v6 <= 0x10;
                  v6 -= 16;
                  if ( v260 )
                    return 0;
                  v11 += 16;
                  v139 = v147;
                }
              }
              v151 = _mm_load_si128(v13);
              v152 = _mm_slli_si128(_mm_load_si128(v14), 7);
              v153 = (unsigned int)_mm_movemask_epi8(
                                     _mm_sub_epi8(
                                       _mm_cmpeq_epi8(
                                         _mm_or_si128(
                                           v152,
                                           _mm_and_si128(
                                             _mm_and_si128(
                                               _mm_cmpgt_epi8(v152, (__m128i)xmmword_80BE5A0),
                                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v152)),
                                             (__m128i)xmmword_80BE5C0)),
                                         _mm_or_si128(
                                           v151,
                                           _mm_and_si128(
                                             _mm_and_si128(
                                               _mm_cmpgt_epi8(v151, (__m128i)xmmword_80BE5A0),
                                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v151)),
                                             (__m128i)xmmword_80BE5C0))),
                                       _mm_cmpeq_epi8((__m128i)0LL, v151))) >> v11;
              v22 = (0xFFFFu >> v11) - v153;
              v18 = 0xFFFFu >> v11 == v153;
              v23 = v11 - 7;
              if ( !v18 )
                goto LABEL_245;
              if ( v6 <= 16 - v11 )
                return 0;
              v6 -= 16 - v11;
              v154 = _mm_load_si128(v14);
              v155 = 0LL;
              v11 = 16;
              v289 |= 9u;
              v156 = (((_WORD)v14 + 9) & 0xFFF) - 4096;
              while ( 1 )
              {
                v260 = (v156 + 16 < 0) ^ __OFADD__(16, v156) | (v156 == -16);
                v156 += 16;
                if ( !v260 )
                  goto LABEL_155;
                while ( 1 )
                {
                  v157 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                  v158 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                  v159 = _mm_alignr_epi8(v158, v154, 9);
                  v160 = _mm_or_si128(
                           v157,
                           _mm_and_si128(
                             _mm_and_si128(
                               _mm_cmpgt_epi8(v157, (__m128i)xmmword_80BE5A0),
                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v157)),
                             (__m128i)xmmword_80BE5C0));
                  v155 = _mm_cmpeq_epi8(v155, v160);
                  v22 = _mm_movemask_epi8(
                          _mm_sub_epi8(
                            _mm_cmpeq_epi8(
                              v160,
                              _mm_or_si128(
                                v159,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(v159, (__m128i)xmmword_80BE5A0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v159)),
                                  (__m128i)xmmword_80BE5C0))),
                            v155))
                      - 0xFFFF;
                  if ( v22 )
                    goto LABEL_244;
                  v260 = v6 <= 0x10;
                  v6 -= 16;
                  if ( v260 )
                    return 0;
                  v11 += 16;
                  v154 = v158;
                  v260 = (v156 + 16 < 0) ^ __OFADD__(16, v156) | (v156 == -16);
                  v156 += 16;
                  if ( v260 )
                    break;
LABEL_155:
                  v165 = _mm_cmpeq_epi8(v155, v154);
                  if ( (_mm_movemask_epi8(v165) & 0xFE00) != 0 || v6 <= 7 )
                  {
                    v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                    v44 = _mm_srli_si128(v165, 9);
                    v45 = _mm_srli_si128(v154, 9);
                    goto LABEL_243;
                  }
                  v155 = 0LL;
                  v156 -= 4096;
                }
                v161 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                v162 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                v163 = _mm_alignr_epi8(v162, v154, 9);
                v164 = _mm_or_si128(
                         v161,
                         _mm_and_si128(
                           _mm_and_si128(
                             _mm_cmpgt_epi8(v161, (__m128i)xmmword_80BE5A0),
                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v161)),
                           (__m128i)xmmword_80BE5C0));
                v155 = _mm_cmpeq_epi8(v155, v164);
                v22 = _mm_movemask_epi8(
                        _mm_sub_epi8(
                          _mm_cmpeq_epi8(
                            v164,
                            _mm_or_si128(
                              v163,
                              _mm_and_si128(
                                _mm_and_si128(
                                  _mm_cmpgt_epi8(v163, (__m128i)xmmword_80BE5A0),
                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v163)),
                                (__m128i)xmmword_80BE5C0))),
                          v155))
                    - 0xFFFF;
                if ( v22 )
                  goto LABEL_244;
                v260 = v6 <= 0x10;
                v6 -= 16;
                if ( v260 )
                  return 0;
                v11 += 16;
                v154 = v162;
              }
            }
            v166 = _mm_load_si128(v13);
            v167 = _mm_slli_si128(_mm_load_si128(v14), 6);
            v168 = (unsigned int)_mm_movemask_epi8(
                                   _mm_sub_epi8(
                                     _mm_cmpeq_epi8(
                                       _mm_or_si128(
                                         v167,
                                         _mm_and_si128(
                                           _mm_and_si128(
                                             _mm_cmpgt_epi8(v167, (__m128i)xmmword_80BE5A0),
                                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v167)),
                                           (__m128i)xmmword_80BE5C0)),
                                       _mm_or_si128(
                                         v166,
                                         _mm_and_si128(
                                           _mm_and_si128(
                                             _mm_cmpgt_epi8(v166, (__m128i)xmmword_80BE5A0),
                                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v166)),
                                           (__m128i)xmmword_80BE5C0))),
                                     _mm_cmpeq_epi8((__m128i)0LL, v166))) >> v11;
            v22 = (0xFFFFu >> v11) - v168;
            v18 = 0xFFFFu >> v11 == v168;
            v23 = v11 - 6;
            if ( !v18 )
              goto LABEL_245;
            if ( v6 <= 16 - v11 )
              return 0;
            v6 -= 16 - v11;
            v169 = _mm_load_si128(v14);
            v170 = 0LL;
            v11 = 16;
            v289 |= 0xAu;
            v171 = (((_WORD)v14 + 10) & 0xFFF) - 4096;
            while ( 1 )
            {
              v260 = (v171 + 16 < 0) ^ __OFADD__(16, v171) | (v171 == -16);
              v171 += 16;
              if ( !v260 )
                goto LABEL_169;
              while ( 1 )
              {
                v172 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                v173 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
                v174 = _mm_alignr_epi8(v173, v169, 10);
                v175 = _mm_or_si128(
                         v172,
                         _mm_and_si128(
                           _mm_and_si128(
                             _mm_cmpgt_epi8(v172, (__m128i)xmmword_80BE5A0),
                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v172)),
                           (__m128i)xmmword_80BE5C0));
                v170 = _mm_cmpeq_epi8(v170, v175);
                v22 = _mm_movemask_epi8(
                        _mm_sub_epi8(
                          _mm_cmpeq_epi8(
                            v175,
                            _mm_or_si128(
                              v174,
                              _mm_and_si128(
                                _mm_and_si128(
                                  _mm_cmpgt_epi8(v174, (__m128i)xmmword_80BE5A0),
                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v174)),
                                (__m128i)xmmword_80BE5C0))),
                          v170))
                    - 0xFFFF;
                if ( v22 )
                  goto LABEL_244;
                v260 = v6 <= 0x10;
                v6 -= 16;
                if ( v260 )
                  return 0;
                v11 += 16;
                v169 = v173;
                v260 = (v171 + 16 < 0) ^ __OFADD__(16, v171) | (v171 == -16);
                v171 += 16;
                if ( v260 )
                  break;
LABEL_169:
                v180 = _mm_cmpeq_epi8(v170, v169);
                if ( (_mm_movemask_epi8(v180) & 0xFC00) != 0 || v6 <= 6 )
                {
                  v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                  v44 = _mm_srli_si128(v180, 10);
                  v45 = _mm_srli_si128(v169, 10);
                  goto LABEL_243;
                }
                v170 = 0LL;
                v171 -= 4096;
              }
              v176 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
              v177 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
              v178 = _mm_alignr_epi8(v177, v169, 10);
              v179 = _mm_or_si128(
                       v176,
                       _mm_and_si128(
                         _mm_and_si128(
                           _mm_cmpgt_epi8(v176, (__m128i)xmmword_80BE5A0),
                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v176)),
                         (__m128i)xmmword_80BE5C0));
              v170 = _mm_cmpeq_epi8(v170, v179);
              v22 = _mm_movemask_epi8(
                      _mm_sub_epi8(
                        _mm_cmpeq_epi8(
                          v179,
                          _mm_or_si128(
                            v178,
                            _mm_and_si128(
                              _mm_and_si128(
                                _mm_cmpgt_epi8(v178, (__m128i)xmmword_80BE5A0),
                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v178)),
                              (__m128i)xmmword_80BE5C0))),
                        v170))
                  - 0xFFFF;
              if ( v22 )
                goto LABEL_244;
              v260 = v6 <= 0x10;
              v6 -= 16;
              if ( v260 )
                return 0;
              v11 += 16;
              v169 = v177;
            }
          }
          v181 = _mm_load_si128(v13);
          v182 = _mm_slli_si128(_mm_load_si128(v14), 5);
          v183 = (unsigned int)_mm_movemask_epi8(
                                 _mm_sub_epi8(
                                   _mm_cmpeq_epi8(
                                     _mm_or_si128(
                                       v182,
                                       _mm_and_si128(
                                         _mm_and_si128(
                                           _mm_cmpgt_epi8(v182, (__m128i)xmmword_80BE5A0),
                                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v182)),
                                         (__m128i)xmmword_80BE5C0)),
                                     _mm_or_si128(
                                       v181,
                                       _mm_and_si128(
                                         _mm_and_si128(
                                           _mm_cmpgt_epi8(v181, (__m128i)xmmword_80BE5A0),
                                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v181)),
                                         (__m128i)xmmword_80BE5C0))),
                                   _mm_cmpeq_epi8((__m128i)0LL, v181))) >> v11;
          v22 = (0xFFFFu >> v11) - v183;
          v18 = 0xFFFFu >> v11 == v183;
          v23 = v11 - 5;
          if ( !v18 )
            goto LABEL_245;
          if ( v6 <= 16 - v11 )
            return 0;
          v6 -= 16 - v11;
          v184 = _mm_load_si128(v14);
          v185 = 0LL;
          v11 = 16;
          v289 |= 0xBu;
          v186 = (((_WORD)v14 + 11) & 0xFFF) - 4096;
          while ( 1 )
          {
            v260 = (v186 + 16 < 0) ^ __OFADD__(16, v186) | (v186 == -16);
            v186 += 16;
            if ( !v260 )
              goto LABEL_183;
            while ( 1 )
            {
              v187 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
              v188 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
              v189 = _mm_alignr_epi8(v188, v184, 11);
              v190 = _mm_or_si128(
                       v187,
                       _mm_and_si128(
                         _mm_and_si128(
                           _mm_cmpgt_epi8(v187, (__m128i)xmmword_80BE5A0),
                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v187)),
                         (__m128i)xmmword_80BE5C0));
              v185 = _mm_cmpeq_epi8(v185, v190);
              v22 = _mm_movemask_epi8(
                      _mm_sub_epi8(
                        _mm_cmpeq_epi8(
                          v190,
                          _mm_or_si128(
                            v189,
                            _mm_and_si128(
                              _mm_and_si128(
                                _mm_cmpgt_epi8(v189, (__m128i)xmmword_80BE5A0),
                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v189)),
                              (__m128i)xmmword_80BE5C0))),
                        v185))
                  - 0xFFFF;
              if ( v22 )
                goto LABEL_244;
              v260 = v6 <= 0x10;
              v6 -= 16;
              if ( v260 )
                return 0;
              v11 += 16;
              v184 = v188;
              v260 = (v186 + 16 < 0) ^ __OFADD__(16, v186) | (v186 == -16);
              v186 += 16;
              if ( v260 )
                break;
LABEL_183:
              v195 = _mm_cmpeq_epi8(v185, v184);
              if ( (_mm_movemask_epi8(v195) & 0xF800) != 0 || v6 <= 5 )
              {
                v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
                v44 = _mm_srli_si128(v195, 11);
                v45 = _mm_srli_si128(v184, 11);
                goto LABEL_243;
              }
              v185 = 0LL;
              v186 -= 4096;
            }
            v191 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
            v192 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
            v193 = _mm_alignr_epi8(v192, v184, 11);
            v194 = _mm_or_si128(
                     v191,
                     _mm_and_si128(
                       _mm_and_si128(
                         _mm_cmpgt_epi8(v191, (__m128i)xmmword_80BE5A0),
                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v191)),
                       (__m128i)xmmword_80BE5C0));
            v185 = _mm_cmpeq_epi8(v185, v194);
            v22 = _mm_movemask_epi8(
                    _mm_sub_epi8(
                      _mm_cmpeq_epi8(
                        v194,
                        _mm_or_si128(
                          v193,
                          _mm_and_si128(
                            _mm_and_si128(
                              _mm_cmpgt_epi8(v193, (__m128i)xmmword_80BE5A0),
                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v193)),
                            (__m128i)xmmword_80BE5C0))),
                      v185))
                - 0xFFFF;
            if ( v22 )
              goto LABEL_244;
            v260 = v6 <= 0x10;
            v6 -= 16;
            if ( v260 )
              return 0;
            v11 += 16;
            v184 = v192;
          }
        }
        v196 = _mm_load_si128(v13);
        v197 = _mm_slli_si128(_mm_load_si128(v14), 4);
        v198 = (unsigned int)_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(
                                   _mm_or_si128(
                                     v197,
                                     _mm_and_si128(
                                       _mm_and_si128(
                                         _mm_cmpgt_epi8(v197, (__m128i)xmmword_80BE5A0),
                                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v197)),
                                       (__m128i)xmmword_80BE5C0)),
                                   _mm_or_si128(
                                     v196,
                                     _mm_and_si128(
                                       _mm_and_si128(
                                         _mm_cmpgt_epi8(v196, (__m128i)xmmword_80BE5A0),
                                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v196)),
                                       (__m128i)xmmword_80BE5C0))),
                                 _mm_cmpeq_epi8((__m128i)0LL, v196))) >> v11;
        v22 = (0xFFFFu >> v11) - v198;
        v18 = 0xFFFFu >> v11 == v198;
        v23 = v11 - 4;
        if ( !v18 )
          goto LABEL_245;
        if ( v6 <= 16 - v11 )
          return 0;
        v6 -= 16 - v11;
        v199 = _mm_load_si128(v14);
        v200 = 0LL;
        v11 = 16;
        v289 |= 0xCu;
        v201 = (((_WORD)v14 + 12) & 0xFFF) - 4096;
        while ( 1 )
        {
          v260 = (v201 + 16 < 0) ^ __OFADD__(16, v201) | (v201 == -16);
          v201 += 16;
          if ( !v260 )
            goto LABEL_197;
          while ( 1 )
          {
            v202 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
            v203 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
            v204 = _mm_alignr_epi8(v203, v199, 12);
            v205 = _mm_or_si128(
                     v202,
                     _mm_and_si128(
                       _mm_and_si128(
                         _mm_cmpgt_epi8(v202, (__m128i)xmmword_80BE5A0),
                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v202)),
                       (__m128i)xmmword_80BE5C0));
            v200 = _mm_cmpeq_epi8(v200, v205);
            v22 = _mm_movemask_epi8(
                    _mm_sub_epi8(
                      _mm_cmpeq_epi8(
                        v205,
                        _mm_or_si128(
                          v204,
                          _mm_and_si128(
                            _mm_and_si128(
                              _mm_cmpgt_epi8(v204, (__m128i)xmmword_80BE5A0),
                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v204)),
                            (__m128i)xmmword_80BE5C0))),
                      v200))
                - 0xFFFF;
            if ( v22 )
              goto LABEL_244;
            v260 = v6 <= 0x10;
            v6 -= 16;
            if ( v260 )
              return 0;
            v11 += 16;
            v199 = v203;
            v260 = (v201 + 16 < 0) ^ __OFADD__(16, v201) | (v201 == -16);
            v201 += 16;
            if ( v260 )
              break;
LABEL_197:
            v210 = _mm_cmpeq_epi8(v200, v199);
            if ( (_mm_movemask_epi8(v210) & 0xF000) != 0 || v6 <= 4 )
            {
              v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
              v44 = _mm_srli_si128(v210, 12);
              v45 = _mm_srli_si128(v199, 12);
              goto LABEL_243;
            }
            v200 = 0LL;
            v201 -= 4096;
          }
          v206 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
          v207 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
          v208 = _mm_alignr_epi8(v207, v199, 12);
          v209 = _mm_or_si128(
                   v206,
                   _mm_and_si128(
                     _mm_and_si128(
                       _mm_cmpgt_epi8(v206, (__m128i)xmmword_80BE5A0),
                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v206)),
                     (__m128i)xmmword_80BE5C0));
          v200 = _mm_cmpeq_epi8(v200, v209);
          v22 = _mm_movemask_epi8(
                  _mm_sub_epi8(
                    _mm_cmpeq_epi8(
                      v209,
                      _mm_or_si128(
                        v208,
                        _mm_and_si128(
                          _mm_and_si128(
                            _mm_cmpgt_epi8(v208, (__m128i)xmmword_80BE5A0),
                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v208)),
                          (__m128i)xmmword_80BE5C0))),
                    v200))
              - 0xFFFF;
          if ( v22 )
            goto LABEL_244;
          v260 = v6 <= 0x10;
          v6 -= 16;
          if ( v260 )
            return 0;
          v11 += 16;
          v199 = v207;
        }
      }
      v211 = _mm_load_si128(v13);
      v212 = _mm_slli_si128(_mm_load_si128(v14), 3);
      v213 = (unsigned int)_mm_movemask_epi8(
                             _mm_sub_epi8(
                               _mm_cmpeq_epi8(
                                 _mm_or_si128(
                                   v212,
                                   _mm_and_si128(
                                     _mm_and_si128(
                                       _mm_cmpgt_epi8(v212, (__m128i)xmmword_80BE5A0),
                                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v212)),
                                     (__m128i)xmmword_80BE5C0)),
                                 _mm_or_si128(
                                   v211,
                                   _mm_and_si128(
                                     _mm_and_si128(
                                       _mm_cmpgt_epi8(v211, (__m128i)xmmword_80BE5A0),
                                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v211)),
                                     (__m128i)xmmword_80BE5C0))),
                               _mm_cmpeq_epi8((__m128i)0LL, v211))) >> v11;
      v22 = (0xFFFFu >> v11) - v213;
      v18 = 0xFFFFu >> v11 == v213;
      v23 = v11 - 3;
      if ( !v18 )
        goto LABEL_245;
      if ( v6 <= 16 - v11 )
        return 0;
      v6 -= 16 - v11;
      v214 = _mm_load_si128(v14);
      v215 = 0LL;
      v11 = 16;
      v289 |= 0xDu;
      v216 = (((_WORD)v14 + 13) & 0xFFF) - 4096;
      while ( 1 )
      {
        v260 = (v216 + 16 < 0) ^ __OFADD__(16, v216) | (v216 == -16);
        v216 += 16;
        if ( !v260 )
          goto LABEL_211;
        while ( 1 )
        {
          v217 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
          v218 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
          v219 = _mm_alignr_epi8(v218, v214, 13);
          v220 = _mm_or_si128(
                   v217,
                   _mm_and_si128(
                     _mm_and_si128(
                       _mm_cmpgt_epi8(v217, (__m128i)xmmword_80BE5A0),
                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v217)),
                     (__m128i)xmmword_80BE5C0));
          v215 = _mm_cmpeq_epi8(v215, v220);
          v22 = _mm_movemask_epi8(
                  _mm_sub_epi8(
                    _mm_cmpeq_epi8(
                      v220,
                      _mm_or_si128(
                        v219,
                        _mm_and_si128(
                          _mm_and_si128(
                            _mm_cmpgt_epi8(v219, (__m128i)xmmword_80BE5A0),
                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v219)),
                          (__m128i)xmmword_80BE5C0))),
                    v215))
              - 0xFFFF;
          if ( v22 )
            goto LABEL_244;
          v260 = v6 <= 0x10;
          v6 -= 16;
          if ( v260 )
            return 0;
          v11 += 16;
          v214 = v218;
          v260 = (v216 + 16 < 0) ^ __OFADD__(16, v216) | (v216 == -16);
          v216 += 16;
          if ( v260 )
            break;
LABEL_211:
          v225 = _mm_cmpeq_epi8(v215, v214);
          if ( (_mm_movemask_epi8(v225) & 0xE000) != 0 || v6 <= 3 )
          {
            v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
            v44 = _mm_srli_si128(v225, 13);
            v45 = _mm_srli_si128(v214, 13);
            goto LABEL_243;
          }
          v215 = 0LL;
          v216 -= 4096;
        }
        v221 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
        v222 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
        v223 = _mm_alignr_epi8(v222, v214, 13);
        v224 = _mm_or_si128(
                 v221,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v221, (__m128i)xmmword_80BE5A0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v221)),
                   (__m128i)xmmword_80BE5C0));
        v215 = _mm_cmpeq_epi8(v215, v224);
        v22 = _mm_movemask_epi8(
                _mm_sub_epi8(
                  _mm_cmpeq_epi8(
                    v224,
                    _mm_or_si128(
                      v223,
                      _mm_and_si128(
                        _mm_and_si128(
                          _mm_cmpgt_epi8(v223, (__m128i)xmmword_80BE5A0),
                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v223)),
                        (__m128i)xmmword_80BE5C0))),
                  v215))
            - 0xFFFF;
        if ( v22 )
          goto LABEL_244;
        v260 = v6 <= 0x10;
        v6 -= 16;
        if ( v260 )
          return 0;
        v11 += 16;
        v214 = v222;
      }
    }
    v226 = _mm_load_si128(v13);
    v227 = _mm_slli_si128(_mm_load_si128(v14), 2);
    v228 = (unsigned int)_mm_movemask_epi8(
                           _mm_sub_epi8(
                             _mm_cmpeq_epi8(
                               _mm_or_si128(
                                 v227,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v227, (__m128i)xmmword_80BE5A0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v227)),
                                   (__m128i)xmmword_80BE5C0)),
                               _mm_or_si128(
                                 v226,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v226, (__m128i)xmmword_80BE5A0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v226)),
                                   (__m128i)xmmword_80BE5C0))),
                             _mm_cmpeq_epi8((__m128i)0LL, v226))) >> v11;
    v22 = (0xFFFFu >> v11) - v228;
    v18 = 0xFFFFu >> v11 == v228;
    v23 = v11 - 2;
    if ( !v18 )
      goto LABEL_245;
    if ( v6 <= 16 - v11 )
      return 0;
    v6 -= 16 - v11;
    v229 = _mm_load_si128(v14);
    v230 = 0LL;
    v11 = 16;
    v289 |= 0xEu;
    v231 = (((_WORD)v14 + 14) & 0xFFF) - 4096;
    while ( 1 )
    {
      v260 = (v231 + 16 < 0) ^ __OFADD__(16, v231) | (v231 == -16);
      v231 += 16;
      if ( !v260 )
        goto LABEL_225;
      while ( 1 )
      {
        v232 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
        v233 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
        v234 = _mm_alignr_epi8(v233, v229, 14);
        v235 = _mm_or_si128(
                 v232,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v232, (__m128i)xmmword_80BE5A0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v232)),
                   (__m128i)xmmword_80BE5C0));
        v230 = _mm_cmpeq_epi8(v230, v235);
        v22 = _mm_movemask_epi8(
                _mm_sub_epi8(
                  _mm_cmpeq_epi8(
                    v235,
                    _mm_or_si128(
                      v234,
                      _mm_and_si128(
                        _mm_and_si128(
                          _mm_cmpgt_epi8(v234, (__m128i)xmmword_80BE5A0),
                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v234)),
                        (__m128i)xmmword_80BE5C0))),
                  v230))
            - 0xFFFF;
        if ( v22 )
          goto LABEL_244;
        v260 = v6 <= 0x10;
        v6 -= 16;
        if ( v260 )
          return 0;
        v11 += 16;
        v229 = v233;
        v260 = (v231 + 16 < 0) ^ __OFADD__(16, v231) | (v231 == -16);
        v231 += 16;
        if ( v260 )
          break;
LABEL_225:
        v240 = _mm_cmpeq_epi8(v230, v229);
        if ( (_mm_movemask_epi8(v240) & 0xC000) != 0 || v6 <= 2 )
        {
          v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
          v44 = _mm_srli_si128(v240, 14);
          v45 = _mm_srli_si128(v229, 14);
          goto LABEL_243;
        }
        v230 = 0LL;
        v231 -= 4096;
      }
      v236 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
      v237 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
      v238 = _mm_alignr_epi8(v237, v229, 14);
      v239 = _mm_or_si128(
               v236,
               _mm_and_si128(
                 _mm_and_si128(
                   _mm_cmpgt_epi8(v236, (__m128i)xmmword_80BE5A0),
                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v236)),
                 (__m128i)xmmword_80BE5C0));
      v230 = _mm_cmpeq_epi8(v230, v239);
      v22 = _mm_movemask_epi8(
              _mm_sub_epi8(
                _mm_cmpeq_epi8(
                  v239,
                  _mm_or_si128(
                    v238,
                    _mm_and_si128(
                      _mm_and_si128(
                        _mm_cmpgt_epi8(v238, (__m128i)xmmword_80BE5A0),
                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v238)),
                      (__m128i)xmmword_80BE5C0))),
                v230))
          - 0xFFFF;
      if ( v22 )
        goto LABEL_244;
      v260 = v6 <= 0x10;
      v6 -= 16;
      if ( v260 )
        return 0;
      v11 += 16;
      v229 = v237;
    }
  }
  v241 = _mm_load_si128(v13);
  v242 = _mm_slli_si128(_mm_load_si128(v14), 1);
  v243 = (unsigned int)_mm_movemask_epi8(
                         _mm_sub_epi8(
                           _mm_cmpeq_epi8(
                             _mm_or_si128(
                               v242,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v242, (__m128i)xmmword_80BE5A0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v242)),
                                 (__m128i)xmmword_80BE5C0)),
                             _mm_or_si128(
                               v241,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v241, (__m128i)xmmword_80BE5A0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v241)),
                                 (__m128i)xmmword_80BE5C0))),
                           _mm_cmpeq_epi8((__m128i)0LL, v241))) >> v11;
  v22 = (0xFFFFu >> v11) - v243;
  v18 = 0xFFFFu >> v11 == v243;
  v23 = v11 - 1;
  if ( !v18 )
    goto LABEL_245;
  if ( v6 <= 16 - v11 )
    return 0;
  v6 -= 16 - v11;
  v244 = _mm_load_si128(v14);
  v245 = 0LL;
  v11 = 16;
  v289 |= 0xFu;
  v246 = (((_WORD)v14 + 15) & 0xFFF) - 4096;
LABEL_232:
  v260 = (v246 + 16 < 0) ^ __OFADD__(16, v246) | (v246 == -16);
  v246 += 16;
  if ( !v260 )
    goto LABEL_239;
  while ( 1 )
  {
    v247 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
    v248 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
    v249 = _mm_alignr_epi8(v248, v244, 15);
    v250 = _mm_or_si128(
             v247,
             _mm_and_si128(
               _mm_and_si128(
                 _mm_cmpgt_epi8(v247, (__m128i)xmmword_80BE5A0),
                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v247)),
               (__m128i)xmmword_80BE5C0));
    v245 = _mm_cmpeq_epi8(v245, v250);
    v22 = _mm_movemask_epi8(
            _mm_sub_epi8(
              _mm_cmpeq_epi8(
                v250,
                _mm_or_si128(
                  v249,
                  _mm_and_si128(
                    _mm_and_si128(
                      _mm_cmpgt_epi8(v249, (__m128i)xmmword_80BE5A0),
                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v249)),
                    (__m128i)xmmword_80BE5C0))),
              v245))
        - 0xFFFF;
    if ( v22 )
      goto LABEL_244;
    v260 = v6 <= 0x10;
    v6 -= 16;
    if ( v260 )
      return 0;
    v11 += 16;
    v244 = v248;
    v260 = (v246 + 16 < 0) ^ __OFADD__(16, v246) | (v246 == -16);
    v246 += 16;
    if ( v260 )
    {
      v251 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
      v252 = _mm_load_si128((const __m128i *)((char *)v14 + v11));
      v253 = _mm_alignr_epi8(v252, v244, 15);
      v254 = _mm_or_si128(
               v251,
               _mm_and_si128(
                 _mm_and_si128(
                   _mm_cmpgt_epi8(v251, (__m128i)xmmword_80BE5A0),
                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v251)),
                 (__m128i)xmmword_80BE5C0));
      v245 = _mm_cmpeq_epi8(v245, v254);
      v22 = _mm_movemask_epi8(
              _mm_sub_epi8(
                _mm_cmpeq_epi8(
                  v254,
                  _mm_or_si128(
                    v253,
                    _mm_and_si128(
                      _mm_and_si128(
                        _mm_cmpgt_epi8(v253, (__m128i)xmmword_80BE5A0),
                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v253)),
                      (__m128i)xmmword_80BE5C0))),
                v245))
          - 0xFFFF;
      if ( v22 )
        goto LABEL_244;
      v260 = v6 <= 0x10;
      v6 -= 16;
      if ( v260 )
        return 0;
      v11 += 16;
      v244 = v252;
      goto LABEL_232;
    }
LABEL_239:
    v255 = _mm_cmpeq_epi8(v245, v244);
    if ( (_mm_movemask_epi8(v255) & 0x8000) != 0 || v6 <= 1 )
      break;
    v245 = 0LL;
    v246 -= 4096;
  }
  v43 = _mm_load_si128((const __m128i *)((char *)v13 + v11));
  v44 = _mm_srli_si128(v255, 15);
  v45 = _mm_srli_si128(v244, 15);
LABEL_243:
  v22 = ~_mm_movemask_epi8(
           _mm_sub_epi8(
             _mm_cmpeq_epi8(
               _mm_or_si128(
                 v43,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v43, (__m128i)xmmword_80BE5A0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v43)),
                   (__m128i)xmmword_80BE5C0)),
               _mm_or_si128(
                 v45,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v45, (__m128i)xmmword_80BE5A0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v45)),
                   (__m128i)xmmword_80BE5C0))),
             v44));
LABEL_244:
  v23 = (v289 & 0x1F) + v11 - 16;
LABEL_245:
  v4 = &v14->m128i_u8[v23];
  v5 = &v13->m128i_u8[v11];
  if ( (v289 & 0x20) != 0 )
  {
    v256 = v5;
    v5 = v4;
    v4 = v256;
  }
  LOWORD(v10) = v22;
LABEL_248:
  if ( !(_BYTE)v10 )
  {
    v5 += 8;
    v4 += 8;
    v260 = v6 <= 8;
    v6 -= 8;
    if ( v260 )
      return 0;
    if ( (v10 & 0x100) == 0 )
    {
      if ( (v10 & 0x200) == 0 )
      {
        if ( (v10 & 0x400) == 0 )
        {
          if ( (v10 & 0x800) == 0 )
          {
            if ( (v10 & 0x1000) == 0 )
            {
              if ( (v10 & 0x2000) == 0 )
              {
                if ( (v10 & 0x4000) == 0 )
                {
                  if ( v6 <= 7 )
                    return 0;
                  return dword_80C1540[v4[7]] - dword_80C1540[v5[7]];
                }
LABEL_270:
                if ( v6 <= 6 )
                  return 0;
                return dword_80C1540[v4[6]] - dword_80C1540[v5[6]];
              }
LABEL_268:
              if ( v6 <= 5 )
                return 0;
              return dword_80C1540[v4[5]] - dword_80C1540[v5[5]];
            }
LABEL_266:
            if ( v6 <= 4 )
              return 0;
            return dword_80C1540[v4[4]] - dword_80C1540[v5[4]];
          }
LABEL_264:
          if ( v6 <= 3 )
            return 0;
          return dword_80C1540[v4[3]] - dword_80C1540[v5[3]];
        }
LABEL_262:
        if ( v6 <= 2 )
          return 0;
        return dword_80C1540[v4[2]] - dword_80C1540[v5[2]];
      }
LABEL_260:
      if ( v6 <= 1 )
        return 0;
      return dword_80C1540[v4[1]] - dword_80C1540[v5[1]];
    }
LABEL_258:
    if ( !v6 )
      return 0;
    return dword_80C1540[*v4] - dword_80C1540[*v5];
  }
  if ( (v10 & 1) != 0 )
    goto LABEL_258;
  if ( (v10 & 2) != 0 )
    goto LABEL_260;
  if ( (v10 & 4) != 0 )
    goto LABEL_262;
  if ( (v10 & 8) != 0 )
    goto LABEL_264;
  if ( (v10 & 0x10) != 0 )
    goto LABEL_266;
  if ( (v10 & 0x20) != 0 )
    goto LABEL_268;
  if ( (v10 & 0x40) != 0 )
    goto LABEL_270;
  if ( v6 > 7 )
    return dword_80C1540[v4[7]] - dword_80C1540[v5[7]];
  return 0;
}
// 80B66A2: conditional instruction was optimized away because %arg_8.4==F
// 80BE5A0: using guessed type __int128 xmmword_80BE5A0;
// 80BE5B0: using guessed type __int128 xmmword_80BE5B0;
// 80BE5C0: using guessed type __int128 xmmword_80BE5C0;
// 80C1540: using guessed type int dword_80C1540[256];

//----- (080B66E0) --------------------------------------------------------
int __cdecl _strncasecmp_sse4_2(char *a1, unsigned __int8 *a2, int a3)
{
  if ( (*(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFDC) + 320) & 1) == 0 )
    JUMPOUT(0x80B6716);
  return _strncasecmp_nonascii(a1, a2, a3);
}
// 80B66F8: control flows out of bounds to 80B6716

//----- (080B6700) --------------------------------------------------------
int __cdecl _strncasecmp_l_sse4_2(char *a1, unsigned __int8 *a2, int a3, int a4)
{
  unsigned __int8 *v4; // edx
  unsigned __int8 *v5; // eax
  int v6; // ebp
  __m128i v7; // xmm2
  __m128i v8; // xmm1
  __m128i v9; // xmm2
  __m128i v10; // xmm1
  int v11; // ecx
  unsigned int v12; // ecx
  unsigned int v13; // edi
  char v14; // cc
  unsigned int v15; // ecx
  unsigned int v16; // edi
  unsigned int v17; // ecx
  unsigned int v18; // edi
  unsigned int v19; // ecx
  unsigned int v20; // edi
  unsigned int v21; // ecx
  unsigned int v22; // edi
  unsigned int v23; // ecx
  unsigned int v24; // edi
  unsigned int v25; // ecx
  unsigned int v26; // edi
  unsigned int v27; // ecx
  unsigned int v28; // edi
  unsigned int v29; // ebp
  unsigned __int8 *v30; // edi
  unsigned __int8 *v31; // esi
  int result; // eax
  int v33; // ecx
  int v34; // edx
  unsigned __int8 *v35; // edi
  unsigned __int8 *v36; // esi
  __m128i v37; // xmm2
  __m128i v38; // xmm1
  __m128i v39; // xmm2
  __m128i v40; // xmm1
  bool v41; // cf
  unsigned int v42; // ecx
  int v43; // ecx
  int v44; // ecx
  int v45; // ecx
  int v46; // edi
  int v47; // ecx
  unsigned int v48; // ecx
  unsigned int v49; // edi
  unsigned int v50; // ecx
  unsigned int v51; // edi
  unsigned int v52; // ecx
  unsigned int v53; // edi
  unsigned int v54; // ecx
  unsigned int v55; // edi
  unsigned int v56; // ecx
  unsigned int v57; // edi
  unsigned int v58; // ecx
  unsigned int v59; // edi
  unsigned int v60; // ecx
  unsigned int v61; // edi
  unsigned int v62; // ecx
  unsigned int v63; // edi

  if ( (*(_DWORD *)(*(_DWORD *)a4 + 320) & 1) != 0 )
    return _strncasecmp_nonascii(a1, a2, a3);
  v4 = (unsigned __int8 *)a1;
  v5 = a2;
  v6 = a3;
  if ( !a3 )
    return 0;
  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFF0 )
  {
    v7 = _mm_loadu_si128((const __m128i *)a1);
    if ( ((unsigned __int16)a2 & 0xFFFu) <= 0xFF0 )
    {
      v8 = _mm_loadu_si128((const __m128i *)a2);
      v9 = _mm_or_si128(
             v7,
             _mm_and_si128(
               _mm_and_si128(
                 _mm_cmpgt_epi8(v7, (__m128i)xmmword_80BE5A0),
                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v7)),
               (__m128i)xmmword_80BE5C0));
      v10 = _mm_or_si128(
              v8,
              _mm_and_si128(
                _mm_and_si128(
                  _mm_cmpgt_epi8(v8, (__m128i)xmmword_80BE5A0),
                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v8)),
                (__m128i)xmmword_80BE5C0));
      v11 = _mm_cvtsi128_si32(v9);
      if ( v11 == _mm_cvtsi128_si32(v10) )
      {
        if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(v10, v9))
          && _mm_testc_si128((__m128i)0LL, _mm_cmpeq_epi8(v9, (__m128i)0LL)) )
        {
          v6 = a3 - 16;
          if ( (unsigned int)a3 <= 0x10 )
            return 0;
          v4 = (unsigned __int8 *)(a1 + 16);
          v5 = a2 + 16;
          goto LABEL_10;
        }
        v41 = __CFADD__(v11, -16843009);
        v44 = v11 - 16843009;
        if ( v41 && (_mm_cvtsi128_si32(v9) ^ v44 | 0xFEFEFEFF) == -1 )
        {
          if ( (unsigned int)a3 <= 4 )
            return 0;
          v45 = _mm_cvtsi128_si32(_mm_srli_si128(v9, 4));
          v46 = v45;
          if ( v45 != _mm_cvtsi128_si32(_mm_srli_si128(v10, 4)) )
            goto LABEL_73;
          v41 = __CFADD__(v45, -16843009);
          v47 = v45 - 16843009;
          if ( !v41 || (v46 ^ v47 | 0xFEFEFEFF) != -1 )
            goto LABEL_73;
          v6 = a3 - 8;
          if ( (unsigned int)a3 <= 8 )
            return 0;
          v4 = (unsigned __int8 *)(a1 + 8);
          v5 = a2 + 8;
        }
      }
      v48 = dword_80C1540[*v5];
      v49 = dword_80C1540[*v4];
      v14 = v49 <= v48;
      if ( v49 != v48 )
        goto LABEL_51;
      if ( !v48 || v6 == 1 )
        return 0;
      v50 = dword_80C1540[v5[1]];
      v51 = dword_80C1540[v4[1]];
      v14 = v51 <= v50;
      if ( v51 != v50 )
        goto LABEL_51;
      if ( !v50 || v6 == 2 )
        return 0;
      v52 = dword_80C1540[v5[2]];
      v53 = dword_80C1540[v4[2]];
      v14 = v53 <= v52;
      if ( v53 != v52 )
        goto LABEL_51;
      if ( !v52 || v6 == 3 )
        return 0;
      v54 = dword_80C1540[v5[3]];
      v55 = dword_80C1540[v4[3]];
      v14 = v55 <= v54;
      if ( v55 != v54 )
      {
LABEL_51:
        result = 1;
        if ( v14 )
          return -1;
        return result;
      }
      if ( !v54 )
        return 0;
LABEL_73:
      if ( v6 == 4 )
        return 0;
      v56 = dword_80C1540[v5[4]];
      v57 = dword_80C1540[v4[4]];
      v14 = v57 <= v56;
      if ( v57 == v56 )
      {
        if ( !v56 )
          return 0;
        if ( v6 == 5 )
          return 0;
        v58 = dword_80C1540[v5[5]];
        v59 = dword_80C1540[v4[5]];
        v14 = v59 <= v58;
        if ( v59 == v58 )
        {
          if ( !v58 )
            return 0;
          if ( v6 == 6 )
            return 0;
          v60 = dword_80C1540[v5[6]];
          v61 = dword_80C1540[v4[6]];
          v14 = v61 <= v60;
          if ( v61 == v60 )
          {
            if ( !v60 )
              return 0;
            if ( v6 == 7 )
              return 0;
            v62 = dword_80C1540[v5[7]];
            v63 = dword_80C1540[v4[7]];
            v14 = v63 <= v62;
            if ( v63 == v62 )
              return 0;
          }
        }
      }
      goto LABEL_51;
    }
  }
LABEL_10:
  v12 = dword_80C1540[*v5];
  v13 = dword_80C1540[*v4];
  v14 = v13 <= v12;
  if ( v13 != v12 )
    goto LABEL_51;
  if ( !v12 || v6 == 1 )
    return 0;
  v15 = dword_80C1540[v5[1]];
  v16 = dword_80C1540[v4[1]];
  v14 = v16 <= v15;
  if ( v16 != v15 )
    goto LABEL_51;
  if ( !v15 || v6 == 2 )
    return 0;
  v17 = dword_80C1540[v5[2]];
  v18 = dword_80C1540[v4[2]];
  v14 = v18 <= v17;
  if ( v18 != v17 )
    goto LABEL_51;
  if ( !v17 || v6 == 3 )
    return 0;
  v19 = dword_80C1540[v5[3]];
  v20 = dword_80C1540[v4[3]];
  v14 = v20 <= v19;
  if ( v20 != v19 )
    goto LABEL_51;
  if ( !v19 || v6 == 4 )
    return 0;
  v21 = dword_80C1540[v5[4]];
  v22 = dword_80C1540[v4[4]];
  v14 = v22 <= v21;
  if ( v22 != v21 )
    goto LABEL_51;
  if ( !v21 || v6 == 5 )
    return 0;
  v23 = dword_80C1540[v5[5]];
  v24 = dword_80C1540[v4[5]];
  v14 = v24 <= v23;
  if ( v24 != v23 )
    goto LABEL_51;
  if ( !v23 || v6 == 6 )
    return 0;
  v25 = dword_80C1540[v5[6]];
  v26 = dword_80C1540[v4[6]];
  v14 = v26 <= v25;
  if ( v26 != v25 )
    goto LABEL_51;
  if ( !v25 || v6 == 7 )
    return 0;
  v27 = dword_80C1540[v5[7]];
  v28 = dword_80C1540[v4[7]];
  v14 = v28 <= v27;
  if ( v28 != v27 )
    goto LABEL_51;
  if ( !v27 )
    return 0;
  v29 = v6 - 8;
  if ( !v29 )
    return 0;
  v30 = v4 + 8;
  v31 = v5 + 8;
  result = 0;
LABEL_35:
  v33 = (unsigned __int16)v31 & 0xFFF;
  if ( v33 < ((unsigned __int16)v30 & 0xFFF) )
    v33 = (unsigned __int16)v30 & 0xFFF;
  v34 = v33 - 4080;
  v35 = &v30[-v33 + 4080];
  v36 = &v31[-v33 + 4080];
  if ( v33 - 4080 > 0 )
  {
LABEL_41:
    while ( 1 )
    {
      v43 = dword_80C1540[v36[v34]];
      result = dword_80C1540[v35[v34]] - v43;
      if ( result || !v43 )
        break;
      v14 = v29-- <= 1;
      if ( v14 )
        return 0;
      if ( ++v34 > 15 )
      {
        v30 = &v35[v34];
        v31 = &v36[v34];
        goto LABEL_35;
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v37 = _mm_loadu_si128((const __m128i *)&v36[v34]);
      v38 = _mm_loadu_si128((const __m128i *)&v35[v34]);
      v39 = _mm_or_si128(
              v37,
              _mm_and_si128(
                _mm_and_si128(
                  _mm_cmpgt_epi8(v37, (__m128i)xmmword_80BE5A0),
                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v37)),
                (__m128i)xmmword_80BE5C0));
      v40 = _mm_or_si128(
              v38,
              _mm_and_si128(
                _mm_and_si128(
                  _mm_cmpgt_epi8(v38, (__m128i)xmmword_80BE5A0),
                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80BE5B0), v38)),
                (__m128i)xmmword_80BE5C0));
      v42 = _mm_cmpistri(v40, v39, 26);
      v41 = _mm_cmpistrc(v40, v39, 26);
      if ( v41 | _mm_cmpistrz(v40, v39, 26) )
        break;
      v14 = v29 <= 0x10;
      v29 -= 16;
      if ( v14 )
        return 0;
      v14 = (v34 + 16 < 0) ^ __OFADD__(16, v34) | (v34 == -16);
      v34 += 16;
      if ( !v14 )
        goto LABEL_41;
    }
    if ( v41 )
    {
      if ( v29 > v42 )
        return dword_80C1540[v35[v42 + v34]] - dword_80C1540[v36[v42 + v34]];
      return 0;
    }
  }
  return result;
}
// 80BE5A0: using guessed type __int128 xmmword_80BE5A0;
// 80BE5B0: using guessed type __int128 xmmword_80BE5B0;
// 80BE5C0: using guessed type __int128 xmmword_80BE5C0;
// 80C1540: using guessed type int dword_80C1540[256];

//----- (080B6C70) --------------------------------------------------------
unsigned int __cdecl setitimer(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EB9F0: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080B6CA0) --------------------------------------------------------
int __cdecl _strncasecmp_nonascii(char *a1, unsigned __int8 *a2, int a3)
{
  char *v3; // ecx
  unsigned __int8 *v4; // edx
  int v5; // esi
  int v6; // ebx
  char v7; // di
  int v8; // ebp

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( a1 == (char *)a2 || !a3 )
    return 0;
  v6 = *(_DWORD *)(__readgsdword(0xFFFFFFDC) + 56);
  do
  {
    v7 = *v3;
    v8 = *(_DWORD *)(v6 + 4 * (unsigned __int8)*v3) - *(_DWORD *)(v6 + 4 * *v4++);
    if ( v8 )
      break;
    ++v3;
    if ( !v7 )
      break;
    --v5;
  }
  while ( v5 );
  return v8;
}

//----- (080B7060) --------------------------------------------------------
unsigned int *__usercall read_encoded_value_with_base@<eax>(
        char a1@<al>,
        unsigned __int16 *a2@<edx>,
        unsigned __int16 *a3@<ecx>,
        unsigned int *a4)
{
  int v5; // ecx
  unsigned int v6; // esi
  unsigned int *v7; // ebx
  unsigned int *result; // eax
  unsigned int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  unsigned int *v13; // edi
  char v14; // [esp+0h] [ebp-24h]
  char v15; // [esp+4h] [ebp-20h]

  if ( a1 == 80 )
  {
    v13 = (unsigned int *)(((unsigned int)a3 + 3) & 0xFFFFFFFC);
    *a4 = *v13;
    return v13 + 1;
  }
  else
  {
    v5 = a1 & 0xF;
    switch ( (char)v5 )
    {
      case 0:
      case 3:
      case 11:
        v6 = *(_DWORD *)a3;
        v7 = (unsigned int *)(a3 + 2);
        goto LABEL_4;
      case 1:
        v7 = (unsigned int *)a3;
        v6 = 0;
        v11 = 0;
        v14 = a1;
        do
        {
          v7 = (unsigned int *)((char *)v7 + 1);
          v12 = (*((_BYTE *)v7 - 1) & 0x7F) << v11;
          v11 += 7;
          v6 |= v12;
        }
        while ( *((char *)v7 - 1) < 0 );
        a1 = v14;
        goto LABEL_4;
      case 2:
        v6 = *a3;
        v7 = (unsigned int *)(a3 + 1);
        goto LABEL_4;
      case 4:
      case 12:
        v6 = *(_DWORD *)a3;
        v7 = (unsigned int *)(a3 + 4);
        goto LABEL_4;
      case 9:
        v7 = (unsigned int *)a3;
        v6 = 0;
        v9 = 0;
        v15 = a1;
        do
        {
          v7 = (unsigned int *)((char *)v7 + 1);
          v10 = (*((_BYTE *)v7 - 1) & 0x7F) << v9;
          v9 += 7;
          v6 |= v10;
        }
        while ( *((char *)v7 - 1) < 0 );
        a1 = v15;
        if ( v9 > 0x1F || (*((_BYTE *)v7 - 1) & 0x40) == 0 )
          goto LABEL_4;
        v6 |= -1 << v9;
        goto LABEL_5;
      case 10:
        v6 = (__int16)*a3;
        v7 = (unsigned int *)(a3 + 1);
LABEL_4:
        if ( v6 )
        {
LABEL_5:
          if ( (a1 & 0x70) == 16 )
            a2 = a3;
          v6 += (unsigned int)a2;
          if ( a1 < 0 )
            v6 = *(_DWORD *)v6;
        }
        *a4 = v6;
        result = v7;
        break;
      default:
        abort(v5);
    }
  }
  return result;
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080B71C0) --------------------------------------------------------
int __usercall base_of_encoded_value@<eax>(char a1@<al>, _DWORD *a2@<edx>, int a3@<ecx>)
{
  unsigned __int8 v3; // al

  if ( a1 == -1 )
    return 0;
  v3 = a1 & 0x70;
  if ( v3 == 32 )
    return a2[21];
  if ( v3 <= 0x20u )
  {
    if ( v3 && v3 != 16 )
      goto LABEL_11;
    return 0;
  }
  if ( v3 != 64 )
  {
    if ( v3 != 80 )
    {
      if ( v3 == 48 )
        return a2[22];
LABEL_11:
      abort(a3);
    }
    return 0;
  }
  return a2[23];
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080B7230) --------------------------------------------------------
unsigned int __usercall execute_cfa_program@<eax>(
        unsigned int result@<eax>,
        unsigned int a2@<edx>,
        _DWORD *a3@<ecx>,
        unsigned int a4)
{
  unsigned int *encoded_value_with_base; // esi
  unsigned int v5; // edx
  char v6; // dl
  unsigned __int16 *v7; // ebx
  int v8; // ecx
  unsigned __int8 v9; // dl
  int v10; // edi
  int v11; // ecx
  int v12; // eax
  int v13; // edi
  unsigned __int8 v14; // dl
  int v15; // ecx
  int v16; // ebx
  int v17; // eax
  char v18; // si
  unsigned __int16 *v19; // eax
  int v20; // edx
  int v21; // edx
  unsigned int v22; // edi
  int v23; // ecx
  int v24; // eax
  int v25; // ebx
  int v26; // ecx
  int v27; // eax
  int v28; // ebx
  int v29; // ecx
  unsigned int v30; // ebx
  int v31; // ecx
  unsigned int v32; // ebx
  int v33; // ecx
  int v34; // ecx
  unsigned int v35; // ebx
  int v36; // eax
  int v37; // edi
  int v38; // ecx
  int v39; // edi
  int v40; // ecx
  int v41; // ebx
  int v42; // eax
  int v43; // ecx
  int v44; // ebx
  int v45; // eax
  int v46; // ecx
  int v47; // ebx
  int v48; // eax
  int v49; // ecx
  int v50; // ebx
  int v51; // eax
  int v52; // esi
  int v53; // ecx
  unsigned int v54; // esi
  int v55; // ecx
  int v56; // eax
  unsigned __int16 **v57; // eax
  int v58; // esi
  int v59; // ecx
  int v60; // ecx
  int v61; // eax
  unsigned int v62; // ecx
  int v63; // eax
  int v64; // ecx
  int v65; // ebx
  int v66; // eax
  unsigned int v67; // ecx
  int v68; // ebx
  int v69; // eax
  int v70; // ebx
  unsigned int v71; // ecx
  int v72; // ebx
  int v73; // eax
  unsigned int v74; // edi
  int v75; // ecx
  int v76; // eax
  int v77; // ebx
  int v78; // ecx
  int v79; // eax
  int v80; // ebx
  unsigned int v81; // esi
  int v82; // ecx
  int v83; // eax
  unsigned __int16 **v84; // eax
  int v85; // esi
  int v86; // ecx
  unsigned int v87; // edi
  int v88; // ecx
  int v89; // eax
  int v90; // ebx
  int v91; // ecx
  int v92; // eax
  int v93; // ebx
  int v94; // ecx
  int v95; // eax
  unsigned int v96; // ecx
  int v97; // eax
  int v98; // [esp-C8h] [ebp-108h] BYREF
  unsigned int *v99; // [esp+0h] [ebp-40h]
  unsigned int v100; // [esp+4h] [ebp-3Ch]
  int *v101; // [esp+8h] [ebp-38h]
  _DWORD *v102; // [esp+Ch] [ebp-34h]
  unsigned int v103; // [esp+10h] [ebp-30h]
  unsigned int v104; // [esp+14h] [ebp-2Ch]
  unsigned int v105; // [esp+24h] [ebp-1Ch] BYREF

  encoded_value_with_base = (unsigned int *)result;
  v101 = &GLOBAL_OFFSET_TABLE_;
  v103 = a2;
  v102 = a3;
  *(int *)((char *)&dword_80EB090 + a4 - 135180288) = 0;
  if ( result < a2 )
  {
    v5 = *(int *)((char *)&dword_80EB0A4 + a4 - 135180288);
    v104 = a3[24];
    result = a3[19] + (v104 >> 31);
    if ( v5 < result )
    {
      v100 = 0;
      v99 = &v105;
      result = v5;
      do
      {
        v6 = *(_BYTE *)encoded_value_with_base;
        v7 = (unsigned __int16 *)((char *)encoded_value_with_base + 1);
        v8 = *(_BYTE *)encoded_value_with_base & 0xC0;
        switch ( (_BYTE)v8 )
        {
          case 0x40:
            encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
            *(int *)((char *)&dword_80EB0A4 + a4 - 135180288) = result
                                                              + *(int *)((char *)&dword_80EB0B0 + a4 - 135180288)
                                                              * (v6 & 0x3F);
            break;
          case 0x80:
            v9 = v6 & 0x3F;
            encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
            v10 = 0;
            v11 = 0;
            v104 = v9;
            do
            {
              encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
              v12 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v11;
              v11 += 7;
              v10 |= v12;
            }
            while ( *((char *)encoded_value_with_base - 1) < 0 );
            result = a4;
            v13 = *(_DWORD *)(a4 + 172) * v10;
            if ( v9 <= 0x11u )
            {
              result = a4 + 8 * v104;
              *(_DWORD *)(result + 4) = 1;
              *(_DWORD *)result = v13;
            }
            break;
          case 0xC0:
            v14 = v6 & 0x3F;
            result = v14;
            if ( v14 > 0x11u )
            {
_L122:
              encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
            }
            else
            {
              encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
              *(_DWORD *)(a4 + 8 * v14 + 4) = 0;
            }
            break;
          default:
            switch ( v6 )
            {
              case 0:
              case 45:
                goto _L122;
              case 1:
                v18 = *(_BYTE *)(a4 + 184);
                v19 = (unsigned __int16 *)base_of_encoded_value(v18, v102, v8);
                encoded_value_with_base = read_encoded_value_with_base(v18, v19, v7, v99);
                result = v105;
                *(int *)((char *)&dword_80EB0A4 + a4 - 135180288) = v105;
                goto LABEL_9;
              case 2:
                v20 = *((unsigned __int8 *)encoded_value_with_base + 1);
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 2);
                result += *(int *)((char *)&dword_80EB0B0 + a4 - 135180288) * v20;
                *(int *)((char *)&dword_80EB0A4 + a4 - 135180288) = result;
                goto LABEL_9;
              case 3:
                v21 = *(unsigned __int16 *)((char *)encoded_value_with_base + 1);
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 3);
                result += *(int *)((char *)&dword_80EB0B0 + a4 - 135180288) * v21;
                *(int *)((char *)&dword_80EB0A4 + a4 - 135180288) = result;
                goto LABEL_9;
              case 4:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 5);
                result += *(encoded_value_with_base - 1) * *(int *)((char *)&dword_80EB0B0 + a4 - 135180288);
                *(int *)((char *)&dword_80EB0A4 + a4 - 135180288) = result;
                goto LABEL_9;
              case 5:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v22 = 0;
                v23 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v24 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v23;
                  v23 += 7;
                  v22 |= v24;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                v25 = 0;
                v26 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v27 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v26;
                  v26 += 7;
                  v25 |= v27;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                goto LABEL_30;
              case 6:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v29 = 0;
                v30 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  result = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v29;
                  v29 += 7;
                  v30 |= result;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                goto LABEL_34;
              case 7:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v31 = 0;
                v32 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  result = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v31;
                  v31 += 7;
                  v32 |= result;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                if ( v32 <= 0x11 )
                {
                  result = a4;
                  *(_DWORD *)(a4 + 8 * v32 + 4) = 6;
                }
                goto LABEL_9;
              case 8:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v33 = 0;
                v30 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  result = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v33;
                  v33 += 7;
                  v30 |= result;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
LABEL_34:
                if ( v30 <= 0x11 )
                {
                  result = a4;
                  *(_DWORD *)(a4 + 8 * v30 + 4) = 0;
                }
                goto LABEL_9;
              case 9:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v34 = 0;
                v35 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v36 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v34;
                  v34 += 7;
                  v35 |= v36;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                v37 = 0;
                v38 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  result = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v38;
                  v38 += 7;
                  v37 |= result;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                if ( v35 <= 0x11 )
                {
                  result = a4 + 8 * v35;
                  *(_DWORD *)(result + 4) = 2;
                  *(_DWORD *)result = v37;
                }
                goto LABEL_9;
              case 10:
                result = v100;
                if ( v100 )
                  v100 = *(int *)((char *)&dword_80EB090 + v100 - 135180288);
                else
                  result = (unsigned int)&v98;
                qmemcpy((void *)result, (const void *)a4, 0xA4u);
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                *(int *)((char *)&dword_80EB090 + a4 - 135180288) = result;
                goto LABEL_9;
              case 11:
                result = *(_DWORD *)(a4 + 144);
                qmemcpy((void *)a4, (const void *)result, 0xA4u);
                v39 = v100;
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v100 = result;
                *(_DWORD *)(result + 144) = v39;
                goto LABEL_9;
              case 12:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v40 = 0;
                v41 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v42 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v40;
                  v40 += 7;
                  v41 |= v42;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                v43 = 0;
                *(_DWORD *)(a4 + 152) = v41;
                v44 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v45 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v43;
                  v43 += 7;
                  v44 |= v45;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                result = a4;
                *(_DWORD *)(a4 + 148) = v44;
                *(_DWORD *)(a4 + 160) = 1;
                goto LABEL_9;
              case 13:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v46 = 0;
                v47 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v48 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v46;
                  v46 += 7;
                  v47 |= v48;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                result = a4;
                *(_DWORD *)(a4 + 152) = v47;
                *(_DWORD *)(a4 + 160) = 1;
                goto LABEL_9;
              case 14:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v49 = 0;
                v50 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v51 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v49;
                  v49 += 7;
                  v50 |= v51;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                result = a4;
                *(_DWORD *)(a4 + 148) = v50;
                goto LABEL_9;
              case 15:
                v52 = 0;
                v53 = 0;
                *(_DWORD *)(a4 + 156) = v7;
                *(_DWORD *)(a4 + 160) = 2;
                do
                {
                  v7 = (unsigned __int16 *)((char *)v7 + 1);
                  result = (*((_BYTE *)v7 - 1) & 0x7F) << v53;
                  v53 += 7;
                  v52 |= result;
                }
                while ( *((char *)v7 - 1) < 0 );
                encoded_value_with_base = (unsigned int *)((char *)v7 + v52);
                goto LABEL_9;
              case 16:
                v54 = 0;
                v55 = 0;
                do
                {
                  v7 = (unsigned __int16 *)((char *)v7 + 1);
                  v56 = (*((_BYTE *)v7 - 1) & 0x7F) << v55;
                  v55 += 7;
                  v54 |= v56;
                }
                while ( *((char *)v7 - 1) < 0 );
                if ( v54 <= 0x11 )
                {
                  v57 = (unsigned __int16 **)(a4 + 8 * v54);
                  v57[1] = (unsigned __int16 *)3;
                  *v57 = v7;
                }
                v58 = 0;
                v59 = 0;
                do
                {
                  v7 = (unsigned __int16 *)((char *)v7 + 1);
                  result = (*((_BYTE *)v7 - 1) & 0x7F) << v59;
                  v59 += 7;
                  v58 |= result;
                }
                while ( *((char *)v7 - 1) < 0 );
                encoded_value_with_base = (unsigned int *)((char *)v7 + v58);
                goto LABEL_9;
              case 17:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v22 = 0;
                v60 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v61 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v60;
                  v60 += 7;
                  v22 |= v61;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                v25 = 0;
                v62 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v63 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v62;
                  v62 += 7;
                  v25 |= v63;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                if ( v62 <= 0x1F && (*((_BYTE *)encoded_value_with_base - 1) & 0x40) != 0 )
                  v25 |= -(1 << v62);
LABEL_30:
                result = a4;
                v28 = *(_DWORD *)(a4 + 172) * v25;
                if ( v22 <= 0x11 )
                {
                  result = a4 + 8 * v22;
                  *(_DWORD *)(result + 4) = 1;
                  *(_DWORD *)result = v28;
                }
                goto LABEL_9;
              case 18:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v64 = 0;
                v65 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v66 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v64;
                  v64 += 7;
                  v65 |= v66;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                v67 = 0;
                *(_DWORD *)(a4 + 152) = v65;
                v68 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v69 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v67;
                  v67 += 7;
                  v68 |= v69;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                if ( v67 <= 0x1F && (*((_BYTE *)encoded_value_with_base - 1) & 0x40) != 0 )
                  v68 |= -(1 << v67);
                result = a4;
                v70 = *(_DWORD *)(a4 + 172) * v68;
                *(_DWORD *)(a4 + 160) = 1;
                *(_DWORD *)(a4 + 148) = v70;
                goto LABEL_9;
              case 19:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v71 = 0;
                v72 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v73 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v71;
                  v71 += 7;
                  v72 |= v73;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                if ( v71 <= 0x1F && (*((_BYTE *)encoded_value_with_base - 1) & 0x40) != 0 )
                  v72 |= -(1 << v71);
                result = a4;
                *(_DWORD *)(a4 + 148) = *(_DWORD *)(a4 + 172) * v72;
                goto LABEL_9;
              case 20:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v74 = 0;
                v75 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v76 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v75;
                  v75 += 7;
                  v74 |= v76;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                v77 = 0;
                v78 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v79 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v78;
                  v78 += 7;
                  v77 |= v79;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                goto LABEL_99;
              case 21:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v74 = 0;
                v94 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v95 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v94;
                  v94 += 7;
                  v74 |= v95;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                v77 = 0;
                v96 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v97 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v96;
                  v96 += 7;
                  v77 |= v97;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                if ( v96 <= 0x1F && (*((_BYTE *)encoded_value_with_base - 1) & 0x40) != 0 )
                  v77 |= -(1 << v96);
LABEL_99:
                result = a4;
                v80 = *(_DWORD *)(a4 + 172) * v77;
                if ( v74 <= 0x11 )
                {
                  result = a4 + 8 * v74;
                  *(_DWORD *)(result + 4) = 4;
                  *(_DWORD *)result = v80;
                }
                break;
              case 22:
                v81 = 0;
                v82 = 0;
                do
                {
                  v7 = (unsigned __int16 *)((char *)v7 + 1);
                  v83 = (*((_BYTE *)v7 - 1) & 0x7F) << v82;
                  v82 += 7;
                  v81 |= v83;
                }
                while ( *((char *)v7 - 1) < 0 );
                if ( v81 <= 0x11 )
                {
                  v84 = (unsigned __int16 **)(a4 + 8 * v81);
                  v84[1] = (unsigned __int16 *)5;
                  *v84 = v7;
                }
                v85 = 0;
                v86 = 0;
                do
                {
                  v7 = (unsigned __int16 *)((char *)v7 + 1);
                  result = (*((_BYTE *)v7 - 1) & 0x7F) << v86;
                  v86 += 7;
                  v85 |= result;
                }
                while ( *((char *)v7 - 1) < 0 );
                encoded_value_with_base = (unsigned int *)((char *)v7 + v85);
                break;
              case 46:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v15 = 0;
                v16 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v17 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v15;
                  v15 += 7;
                  v16 |= v17;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                result = (unsigned int)v102;
                v102[26] = v16;
                break;
              case 47:
                encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                v87 = 0;
                v88 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v89 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v88;
                  v88 += 7;
                  v87 |= v89;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                v90 = 0;
                v91 = 0;
                do
                {
                  encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
                  v92 = (*((_BYTE *)encoded_value_with_base - 1) & 0x7F) << v91;
                  v91 += 7;
                  v90 |= v92;
                }
                while ( *((char *)encoded_value_with_base - 1) < 0 );
                result = a4;
                v93 = *(_DWORD *)(a4 + 172) * v90;
                if ( v87 <= 0x11 )
                {
                  result = a4 + 8 * v87;
                  *(_DWORD *)(result + 4) = 1;
                  *(_DWORD *)result = -v93;
                }
                break;
              default:
                abort(v8);
            }
            break;
        }
LABEL_9:
        if ( v103 <= (unsigned int)encoded_value_with_base )
          break;
        result = *(_DWORD *)(a4 + 164);
        v104 = v102[24];
      }
      while ( result < v102[19] + (v104 >> 31) );
    }
  }
  return result;
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 80EB000: using guessed type int GLOBAL_OFFSET_TABLE_;
// 80EB090: using guessed type int dword_80EB090;
// 80EB0A4: using guessed type int dword_80EB0A4;
// 80EB0B0: using guessed type int dword_80EB0B0;

//----- (080B7A40) --------------------------------------------------------
int *init_dwarf_reg_size_table()
{
  int *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  dwarf_reg_size_table[0] = 4;
  byte_80EC8D2 = 4;
  byte_80EC8D1 = 4;
  byte_80EC8D3 = 4;
  byte_80EC8D6 = 4;
  byte_80EC8D7 = 4;
  byte_80EC8D5 = 4;
  byte_80EC8D4 = 4;
  byte_80EC8DB = 12;
  byte_80EC8DC = 12;
  byte_80EC8DD = 12;
  byte_80EC8DE = 12;
  byte_80EC8DF = 12;
  byte_80EC8E0 = 12;
  byte_80EC8D9 = 4;
  byte_80EC8D8 = 4;
  return result;
}
// 80EB000: using guessed type int GLOBAL_OFFSET_TABLE_;
// 80EC8D1: using guessed type char byte_80EC8D1;
// 80EC8D2: using guessed type char byte_80EC8D2;
// 80EC8D3: using guessed type char byte_80EC8D3;
// 80EC8D4: using guessed type char byte_80EC8D4;
// 80EC8D5: using guessed type char byte_80EC8D5;
// 80EC8D6: using guessed type char byte_80EC8D6;
// 80EC8D7: using guessed type char byte_80EC8D7;
// 80EC8D8: using guessed type char byte_80EC8D8;
// 80EC8D9: using guessed type char byte_80EC8D9;
// 80EC8DB: using guessed type char byte_80EC8DB;
// 80EC8DC: using guessed type char byte_80EC8DC;
// 80EC8DD: using guessed type char byte_80EC8DD;
// 80EC8DE: using guessed type char byte_80EC8DE;
// 80EC8DF: using guessed type char byte_80EC8DF;
// 80EC8E0: using guessed type char byte_80EC8E0;

//----- (080B7AC0) --------------------------------------------------------
int __usercall uw_frame_state_for@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, long double a3@<st0>)
{
  int v4; // eax
  _BYTE *v6; // eax
  int v7; // esi
  int v8; // ecx
  int v9; // edx
  int v10; // ebp
  unsigned int v11; // ecx
  int v12; // edx
  unsigned int *v13; // ebx
  int v14; // ecx
  int v15; // esi
  int v16; // eax
  unsigned __int8 *v17; // ebp
  char v18; // al
  unsigned int *v19; // ecx
  unsigned int *encoded_value_with_base; // ebp
  char *v21; // esi
  char v22; // al
  int v23; // ecx
  int v24; // eax
  int result; // eax
  char v26; // al
  char v27; // bl
  unsigned __int16 *v28; // eax
  unsigned int *v29; // ebx
  unsigned int v30; // ebp
  int v31; // ecx
  char v32; // al
  unsigned __int8 v33; // al
  int v34; // ebx
  unsigned __int16 *v35; // ebx
  int v36; // esi
  int v37; // eax
  char v38; // al
  unsigned int v39; // esi
  int v40; // edx
  int v41; // esi
  int v42; // ecx
  int v43; // eax
  int v44; // edx
  char v45; // bp
  unsigned __int16 *v46; // eax
  int v47; // eax
  int v48; // edx
  int v49; // ecx
  _DWORD *v50; // [esp+0h] [ebp-44h]
  char *v51; // [esp+8h] [ebp-3Ch]
  _DWORD *FDE; // [esp+Ch] [ebp-38h]
  int v53; // [esp+10h] [ebp-34h]
  unsigned __int8 v54; // [esp+14h] [ebp-30h]
  unsigned int v55; // [esp+14h] [ebp-30h]
  unsigned int v56[8]; // [esp+24h] [ebp-20h] BYREF

  memset(a2, 0, 0xC0u);
  a1[26] = 0;
  a1[20] = 0;
  v4 = a1[19];
  if ( v4 )
  {
    v50 = a1;
    FDE = (_DWORD *)Unwind_Find_FDE(0, a3, v4 + (a1[24] >> 31) - 1, a1 + 21);
    if ( FDE )
    {
      *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80EB0A4 - 33795072)) = a1[23];
      v53 = (int)FDE - FDE[1] + 4;
      v51 = (char *)(v53 + 9);
      v6 = (_BYTE *)(v53 + 9 + strlen((_BYTE *)(v53 + 9)) + 1);
      if ( *(_BYTE *)(v53 + 9) == 101 && *(_BYTE *)(v53 + 10) == 104 )
      {
        v40 = *(_DWORD *)v6;
        v6 += 4;
        v51 = (char *)(v53 + 11);
        *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80EB0BC - 33795072)) = v40;
      }
      v54 = *(_BYTE *)(v53 + 8);
      if ( v54 > 3u )
      {
        if ( *v6 != 4 || v6[1] )
          return 3;
        v6 += 2;
      }
      v7 = 0;
      v8 = 0;
      do
      {
        v9 = (*v6++ & 0x7F) << v8;
        v8 += 7;
        v7 |= v9;
      }
      while ( (char)*(v6 - 1) < 0 );
      *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80EB0B0 - 33795072)) = v7;
      v10 = 0;
      v11 = 0;
      while ( 1 )
      {
        v12 = (*v6 & 0x7F) << v11;
        v11 += 7;
        v10 |= v12;
        if ( (char)*v6 >= 0 )
          break;
        ++v6;
      }
      v13 = (unsigned int *)(v6 + 1);
      if ( v11 <= 0x1F && (*v6 & 0x40) != 0 )
        v10 |= -1 << v11;
      v14 = 0;
      *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80EB0AC - 33795072)) = v10;
      v15 = 0;
      if ( v54 == 1 )
      {
        v44 = *(unsigned __int8 *)v13;
        v13 = (unsigned int *)(v6 + 2);
        *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80EB0B4 - 33795072)) = v44;
      }
      else
      {
        do
        {
          v13 = (unsigned int *)((char *)v13 + 1);
          v16 = (*((_BYTE *)v13 - 1) & 0x7F) << v14;
          v14 += 7;
          v15 |= v16;
        }
        while ( *((char *)v13 - 1) < 0 );
        *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80EB0B4 - 33795072)) = v15;
      }
      byte_80EB0B9[(_DWORD)a2 - 135180288] = -1;
      v17 = 0;
      v18 = *v51;
      if ( *v51 == 122 )
      {
        v41 = 0;
        v42 = 0;
        do
        {
          v13 = (unsigned int *)((char *)v13 + 1);
          v43 = (*((_BYTE *)v13 - 1) & 0x7F) << v42;
          v42 += 7;
          v41 |= v43;
        }
        while ( *((char *)v13 - 1) < 0 );
        v17 = (unsigned __int8 *)v13 + v41;
        byte_80EB0BA[(_DWORD)a2 - 135180288] = 1;
        v18 = *++v51;
      }
      v19 = v56;
      v55 = (unsigned int)v17;
      encoded_value_with_base = v13;
      v21 = v51 + 1;
      while ( v18 )
      {
        switch ( v18 )
        {
          case 'L':
            v22 = *(_BYTE *)encoded_value_with_base;
            encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
            byte_80EB0B9[(_DWORD)a2 - 135180288] = v22;
            break;
          case 'R':
            v26 = *(_BYTE *)encoded_value_with_base;
            encoded_value_with_base = (unsigned int *)((char *)encoded_value_with_base + 1);
            byte_80EB0B8[(_DWORD)a2 - 135180288] = v26;
            break;
          case 'P':
            v27 = *(_BYTE *)encoded_value_with_base;
            v28 = (unsigned __int16 *)base_of_encoded_value(*(_BYTE *)encoded_value_with_base, v50, (int)v19);
            encoded_value_with_base = read_encoded_value_with_base(
                                        v27,
                                        v28,
                                        (unsigned __int16 *)((char *)encoded_value_with_base + 1),
                                        v56);
            *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80EB0A8 - 33795072)) = v56[0];
            break;
          case 'S':
            byte_80EB0BB[(_DWORD)a2 - 135180288] = 1;
            break;
          default:
            v30 = v55;
            goto LABEL_47;
        }
        v18 = *v21++;
      }
      v29 = encoded_value_with_base;
      v30 = v55;
      if ( !v55 )
      {
        v30 = (unsigned int)v29;
LABEL_47:
        if ( !v30 )
          return 3;
      }
      execute_cfa_program(v30, v53 + *(_DWORD *)v53 + 4, v50, (unsigned int)a2);
      v32 = byte_80EB0B8[(_DWORD)a2 - 135180288];
      if ( v32 == -1 )
      {
        v34 = 2;
      }
      else
      {
        v33 = v32 & 7;
        if ( v33 == 2 )
        {
          v34 = 3;
        }
        else
        {
          if ( v33 <= 2u )
          {
            if ( v33 )
              goto LABEL_59;
          }
          else if ( v33 != 3 )
          {
            v34 = 6;
            if ( v33 == 4 )
              goto LABEL_38;
LABEL_59:
            abort(v31);
          }
          v34 = 4;
        }
      }
LABEL_38:
      v35 = (unsigned __int16 *)&FDE[v34];
      if ( byte_80EB0BA[(_DWORD)a2 - 135180288] )
      {
        v36 = 0;
        v31 = 0;
        do
        {
          v35 = (unsigned __int16 *)((char *)v35 + 1);
          v37 = (*((_BYTE *)v35 - 1) & 0x7F) << v31;
          v31 += 7;
          v36 |= v37;
        }
        while ( *((char *)v35 - 1) < 0 );
        v38 = byte_80EB0B9[(_DWORD)a2 - 135180288];
        v39 = (unsigned int)v35 + v36;
        if ( v38 == -1 )
          goto LABEL_42;
      }
      else
      {
        v38 = byte_80EB0B9[(_DWORD)a2 - 135180288];
        v39 = 0;
        if ( v38 == -1 )
        {
          v39 = (unsigned int)v35;
LABEL_44:
          execute_cfa_program(v39, (unsigned int)FDE + *FDE + 4, v50, (unsigned int)a2);
          return 0;
        }
      }
      v45 = v38;
      v46 = (unsigned __int16 *)base_of_encoded_value(v38, v50, v31);
      v35 = (unsigned __int16 *)read_encoded_value_with_base(v45, v46, v35, v56);
      v50[20] = v56[0];
LABEL_42:
      if ( !v39 )
        v39 = (unsigned int)v35;
      goto LABEL_44;
    }
    v23 = a1[18];
    v24 = a1[19];
    if ( *(_WORD *)v24 == 0xB858 && *(_DWORD *)(v24 + 2) == 119 && *(_WORD *)(v24 + 6) == 0x80CD )
    {
      v47 = v23 + 4;
LABEL_66:
      v48 = *(_DWORD *)(v47 + 28);
      *(_DWORD *)((char *)a2 + (_DWORD)(&IO_2_1_stderr_ - 33795072)) = 1;
      *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80EB098 - 33795072)) = 4;
      a2[1] = 1;
      a2[7] = 1;
      a2[3] = 1;
      a2[5] = 1;
      a2[13] = 1;
      a2[15] = 1;
      *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80EB094 - 33795072)) = v48 - v23;
      a2[11] = 1;
      a2[17] = 1;
      *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80EB0B4 - 33795072)) = 8;
      *a2 = v47 + 44 - v48;
      byte_80EB0BB[(_DWORD)a2 - 135180288] = 1;
      a2[6] = v47 + 32 - v48;
      a2[2] = v47 + 40 - v48;
      a2[4] = v47 + 36 - v48;
      a2[12] = v47 + 20 - v48;
      a2[14] = v47 + 16 - v48;
      v49 = v47 + 24 - v48;
      a2[16] = v47 + 56 - v48;
      result = 0;
      a2[10] = v49;
      return result;
    }
    if ( *(_BYTE *)v24 == 0xB8 && *(_DWORD *)(v24 + 1) == 173 && *(_WORD *)(v24 + 5) == 0x80CD )
    {
      v47 = v23 + 160;
      goto LABEL_66;
    }
  }
  return 5;
}
// 80B7CDA: variable 'v19' is possibly undefined
// 80B7EB6: variable 'v31' is possibly undefined
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 80EB094: using guessed type int dword_80EB094;
// 80EB098: using guessed type int dword_80EB098;
// 80EB0A0: using guessed type int IO_2_1_stderr_;
// 80EB0A4: using guessed type int dword_80EB0A4;
// 80EB0A8: using guessed type int dword_80EB0A8;
// 80EB0AC: using guessed type int dword_80EB0AC;
// 80EB0B0: using guessed type int dword_80EB0B0;
// 80EB0B4: using guessed type int dword_80EB0B4;
// 80EB0BC: using guessed type int dword_80EB0BC;

//----- (080B8020) --------------------------------------------------------
int __usercall execute_stack_op@<eax>(char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4)
{
  int result; // eax
  int v6; // esi
  unsigned __int8 v7; // al
  int v8; // esi
  int v9; // edi
  int v10; // edi
  char v11; // si
  unsigned __int16 *v12; // eax
  unsigned int *encoded_value_with_base; // eax
  int v14; // esi
  int v15; // eax
  int v16; // esi
  int v17; // ecx
  int v18; // eax
  int v19; // edi
  int v20; // eax
  int v21; // esi
  char v22; // al
  int v23; // edx
  int v24; // eax
  int v25; // edi
  int v26; // eax
  _DWORD *v27; // eax
  int v28; // eax
  int v29; // edi
  int v30; // esi
  int v31; // ebx
  int v32; // esi
  int v33; // eax
  int v34; // eax
  unsigned __int8 v35; // al
  int v36; // [esp+0h] [ebp-140h]
  int v37; // [esp+0h] [ebp-140h]
  unsigned __int8 *v38; // [esp+4h] [ebp-13Ch]
  int v40; // [esp+Ch] [ebp-134h]
  int v41; // [esp+1Ch] [ebp-124h]
  int v42; // [esp+20h] [ebp-120h] BYREF
  int v43[71]; // [esp+24h] [ebp-11Ch]

  result = a4;
  v40 = a3;
  v43[0] = a4;
  if ( (unsigned int)a1 < a2 )
  {
    v36 = 1;
    while ( 2 )
    {
      v6 = (unsigned __int8)*a1;
      v38 = (unsigned __int8 *)(a1 + 1);
      v7 = v6;
      switch ( (char)v6 )
      {
        case 3:
        case 12:
        case 13:
          v8 = v36;
          v9 = *(_DWORD *)(a1 + 1);
          a1 += 5;
          goto LABEL_5;
        case 6:
        case 25:
        case 31:
        case 32:
        case 35:
        case -108:
          a3 = v36;
          if ( !v36 )
            goto _L261;
          v8 = v36 - 1;
          v10 = v43[v36 - 1];
          if ( v7 == 31 )
          {
            v9 = -v10;
            ++a1;
          }
          else if ( v7 <= 0x1Fu )
          {
            if ( v7 == 6 )
            {
              v9 = *(_DWORD *)v10;
              ++a1;
            }
            else
            {
              if ( v7 != 25 )
                goto _L261;
              ++a1;
              v9 = abs32(v10);
            }
          }
          else
          {
            switch ( v7 )
            {
              case 0x23u:
                ++a1;
                v37 = v36 - 1;
                a3 = 0;
                v32 = 0;
                do
                {
                  v33 = (*a1++ & 0x7F) << a3;
                  a3 += 7;
                  v32 |= v33;
                }
                while ( *(a1 - 1) < 0 );
                v34 = v32;
                v8 = v37;
                v9 = v34 + v10;
                break;
              case 0x94:
                v35 = a1[1];
                if ( v35 == 2 )
                {
                  v9 = *(unsigned __int16 *)v10;
                  a1 += 2;
                }
                else if ( v35 <= 2u )
                {
                  if ( v35 != 1 )
                    goto _L261;
                  v9 = *(unsigned __int8 *)v10;
                  a1 += 2;
                }
                else
                {
                  if ( v35 != 4 && v35 != 8 )
                    goto _L261;
                  v9 = *(_DWORD *)v10;
                  a1 += 2;
                }
                break;
              case 0x20u:
                v9 = ~v10;
                ++a1;
                break;
              default:
                goto _L261;
            }
          }
LABEL_5:
          if ( v8 > 63 )
            goto _L261;
          v43[v8] = v9;
          v36 = v8 + 1;
LABEL_7:
          if ( a2 > (unsigned int)a1 )
            continue;
          if ( !v36 )
_L261:
            abort(a3);
          result = v43[v36 - 1];
          break;
        case 8:
          v9 = (unsigned __int8)a1[1];
          v8 = v36;
          a1 += 2;
          goto LABEL_5;
        case 9:
          v9 = a1[1];
          v8 = v36;
          a1 += 2;
          goto LABEL_5;
        case 10:
          v9 = *(unsigned __int16 *)(a1 + 1);
          v8 = v36;
          a1 += 3;
          goto LABEL_5;
        case 11:
          v9 = *(__int16 *)(a1 + 1);
          v8 = v36;
          a1 += 3;
          goto LABEL_5;
        case 14:
        case 15:
          v9 = *(_DWORD *)(a1 + 1);
          v8 = v36;
          a1 += 9;
          goto LABEL_5;
        case 16:
          ++a1;
          v9 = 0;
          a3 = 0;
          do
          {
            v24 = (*a1++ & 0x7F) << a3;
            a3 += 7;
            v9 |= v24;
          }
          while ( *(a1 - 1) < 0 );
          goto LABEL_48;
        case 17:
          ++a1;
          v9 = 0;
          a3 = 0;
          do
          {
            v22 = *a1++;
            v23 = (v22 & 0x7F) << a3;
            a3 += 7;
            v9 |= v23;
          }
          while ( v22 < 0 );
          if ( (unsigned int)a3 <= 0x1F && (v22 & 0x40) != 0 )
          {
            v9 |= -(1 << a3);
            v8 = v36;
          }
          else
          {
LABEL_48:
            v8 = v36;
          }
          goto LABEL_5;
        case 18:
          if ( !v36 )
            goto _L261;
          v9 = v43[v36 - 1];
          v8 = v36;
          ++a1;
          goto LABEL_5;
        case 19:
          if ( !v36 )
            goto _L261;
          ++a1;
          --v36;
          goto LABEL_7;
        case 20:
          if ( v36 <= 1 )
            goto _L261;
          v9 = *(&v41 + v36);
          v8 = v36;
          ++a1;
          goto LABEL_5;
        case 21:
          v8 = v36;
          a3 = (unsigned __int8)a1[1];
          if ( a3 >= v36 - 1 )
            goto _L261;
          a1 += 2;
          v9 = v43[v36 - 1 - a3];
          goto LABEL_5;
        case 22:
          if ( v36 <= 1 )
            goto _L261;
          a3 = v43[v36 - 1];
          v43[v36 - 1] = v43[v36 - 2];
          ++a1;
          v43[v36 - 2] = a3;
          goto LABEL_7;
        case 23:
          if ( v36 <= 2 )
            goto _L261;
          a3 = v36 - 1;
          v30 = v43[v36 - 3];
          v31 = v43[v36 - 1];
          v43[v36 - 1] = v43[v36 - 2];
          v43[v36 - 2] = v30;
          v43[v36 - 3] = v31;
          a1 = (char *)v38;
          goto LABEL_7;
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 33:
        case 34:
        case 36:
        case 37:
        case 38:
        case 39:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
          a3 = v36;
          if ( v36 > 1 )
          {
            v8 = v36 - 2;
            a3 = v43[v36 - 1];
            v29 = v43[v36 - 2];
            switch ( v7 )
            {
              case 0x1Au:
                v9 = a3 & v29;
                ++a1;
                goto LABEL_5;
              case 0x1Bu:
                ++a1;
                v9 = v29 / a3;
                goto LABEL_5;
              case 0x1Cu:
                v9 = v29 - a3;
                ++a1;
                goto LABEL_5;
              case 0x1Du:
                ++a1;
                v9 = v29 % (unsigned int)a3;
                goto LABEL_5;
              case 0x1Eu:
                v9 = a3 * v29;
                ++a1;
                goto LABEL_5;
              case 0x21u:
                v9 = a3 | v29;
                ++a1;
                goto LABEL_5;
              case 0x22u:
                v9 = a3 + v29;
                ++a1;
                goto LABEL_5;
              case 0x24u:
                v9 = v29 << a3;
                ++a1;
                goto LABEL_5;
              case 0x25u:
                v9 = (unsigned int)v29 >> a3;
                ++a1;
                goto LABEL_5;
              case 0x26u:
                v9 = v29 >> a3;
                ++a1;
                goto LABEL_5;
              case 0x27u:
                v9 = a3 ^ v29;
                ++a1;
                goto LABEL_5;
              case 0x29u:
                ++a1;
                v9 = v29 == a3;
                goto LABEL_5;
              case 0x2Au:
                ++a1;
                v9 = v29 >= a3;
                goto LABEL_5;
              case 0x2Bu:
                ++a1;
                v9 = v29 > a3;
                goto LABEL_5;
              case 0x2Cu:
                ++a1;
                v9 = v29 <= a3;
                goto LABEL_5;
              case 0x2Du:
                ++a1;
                v9 = v29 < a3;
                goto LABEL_5;
              case 0x2Eu:
                ++a1;
                v9 = v29 != a3;
                goto LABEL_5;
              default:
                goto _L261;
            }
          }
          goto _L261;
        case 40:
          if ( !v36 )
            goto _L261;
          if ( v43[--v36] )
            a1 += *(__int16 *)(a1 + 1) + 3;
          else
            a1 += 3;
          goto LABEL_7;
        case 47:
          a1 += *(__int16 *)(a1 + 1) + 3;
          goto LABEL_7;
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
          v9 = v6 - 48;
          ++a1;
          v8 = v36;
          goto LABEL_5;
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
          v28 = v6 - 80;
          if ( v6 - 80 > 17 )
            goto _L261;
          a3 = v40;
          if ( (*(_BYTE *)(v40 + 99) & 0x40) != 0 && *(_BYTE *)(v40 + v28 + 108) )
          {
            v9 = *(_DWORD *)(v40 + 4 * v28);
            v8 = v36;
            ++a1;
          }
          else
          {
            if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + v6 + 6272) != 4 )
              goto _L261;
            v9 = **(_DWORD **)(v40 + 4 * v28);
            v8 = v36;
            ++a1;
          }
          goto LABEL_5;
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 127:
        case -128:
        case -127:
        case -126:
        case -125:
        case -124:
        case -123:
        case -122:
        case -121:
        case -120:
        case -119:
        case -118:
        case -117:
        case -116:
        case -115:
        case -114:
        case -113:
          ++a1;
          v25 = 0;
          a3 = 0;
          do
          {
            v26 = (*a1++ & 0x7F) << a3;
            a3 += 7;
            v25 |= v26;
          }
          while ( *(a1 - 1) < 0 );
          if ( (unsigned int)a3 <= 0x1F && (*(a1 - 1) & 0x40) != 0 )
            v25 |= -(1 << a3);
          if ( v6 - 112 > 17 )
            goto _L261;
          a3 = v40;
          v27 = *(_DWORD **)(v40 + 4 * (v6 - 112));
          if ( (*(_BYTE *)(v40 + 99) & 0x40) != 0 && *(_BYTE *)(v40 + v6 - 4) )
            goto LABEL_56;
          if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + v6 + 6240) != 4 )
            goto _L261;
          v27 = (_DWORD *)*v27;
LABEL_56:
          v9 = (int)v27 + v25;
          v8 = v36;
          goto LABEL_5;
        case -112:
          ++a1;
          v14 = 0;
          a3 = 0;
          do
          {
            v15 = (*a1++ & 0x7F) << a3;
            a3 += 7;
            v14 |= v15;
          }
          while ( *(a1 - 1) < 0 );
          if ( v14 > 17 )
            goto _L261;
          v9 = *(_DWORD *)(v40 + 4 * v14);
          if ( (*(_BYTE *)(v40 + 99) & 0x40) != 0 && *(_BYTE *)(v40 + v14 + 108) )
          {
            v8 = v36;
          }
          else
          {
            if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + v14 + 6352) != 4 )
              goto _L261;
            v9 = *(_DWORD *)v9;
            v8 = v36;
          }
          goto LABEL_5;
        case -110:
          ++a1;
          v16 = 0;
          v17 = 0;
          do
          {
            v18 = (*a1++ & 0x7F) << v17;
            v17 += 7;
            v16 |= v18;
          }
          while ( *(a1 - 1) < 0 );
          v19 = 0;
          a3 = 0;
          do
          {
            v20 = (*a1++ & 0x7F) << a3;
            a3 += 7;
            v19 |= v20;
          }
          while ( *(a1 - 1) < 0 );
          if ( (unsigned int)a3 <= 0x1F && (*(a1 - 1) & 0x40) != 0 )
            v19 |= -(1 << a3);
          if ( v16 > 17 )
            goto _L261;
          a3 = v40;
          if ( (*(_BYTE *)(v40 + 99) & 0x40) != 0 && *(_BYTE *)(v40 + v16 + 108) )
          {
            v21 = *(_DWORD *)(v40 + 4 * v16);
          }
          else
          {
            if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + v16 + 6352) != 4 )
              goto _L261;
            v21 = **(_DWORD **)(v40 + 4 * v16);
          }
          v9 = v21 + v19;
          v8 = v36;
          goto LABEL_5;
        case -106:
          ++a1;
          goto LABEL_7;
        case -15:
          v11 = a1[1];
          v12 = (unsigned __int16 *)base_of_encoded_value(v11, (_DWORD *)v40, a3);
          encoded_value_with_base = read_encoded_value_with_base(
                                      v11,
                                      v12,
                                      (unsigned __int16 *)a1 + 1,
                                      (unsigned int *)&v42);
          v9 = v42;
          a1 = (char *)encoded_value_with_base;
          v8 = v36;
          goto LABEL_5;
        default:
          goto _L261;
      }
      break;
    }
  }
  return result;
}
// 80B8162: variable 'a3' is possibly undefined
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 80EB000: using guessed type int GLOBAL_OFFSET_TABLE_;
// 80B8020: using guessed type int var_11C[71];

//----- (080B87A0) --------------------------------------------------------
int __usercall uw_update_context_1@<eax>(int a1@<eax>, int a2@<edx>)
{
  int *v2; // ecx
  int v3; // edx
  int v4; // eax
  int v5; // esi
  int v6; // ecx
  char *v7; // eax
  int v8; // edx
  int v9; // ebx
  int *v10; // esi
  int v11; // eax
  int result; // eax
  char *v13; // eax
  int v14; // ebp
  int v15; // ecx
  int v16; // edx
  int v17; // eax
  int v18; // edi
  char *v19; // eax
  int v20; // ebp
  int v21; // ecx
  int v22; // edx
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v27; // [esp+8h] [ebp-B8h]
  int v29; // [esp+20h] [ebp-A0h] BYREF
  int v30[39]; // [esp+24h] [ebp-9Ch] BYREF

  qmemcpy(v30, (const void *)a1, 0x80u);
  v2 = 0;
  v3 = v30[24];
  if ( ((v30[24] & 0x40000000) == 0 || !LOBYTE(v30[28])) && !v30[4] )
  {
    if ( byte_80EC8D4 != 4 )
      goto LABEL_20;
    v29 = *(_DWORD *)(a1 + 72);
    if ( (v30[24] & 0x40000000) != 0 )
      LOBYTE(v30[28]) = 0;
    v30[4] = (int)&v29;
  }
  if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 )
    *(_BYTE *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  v4 = *(_DWORD *)(a2 + 160);
  if ( v4 != 1 )
  {
    if ( v4 == 2 )
    {
      v5 = 0;
      v6 = 0;
      v7 = *(char **)(a2 + 156);
      do
      {
        v8 = (*v7++ & 0x7F) << v6;
        v6 += 7;
        v5 |= v8;
      }
      while ( *(v7 - 1) < 0 );
      v27 = execute_stack_op(v7, (unsigned int)&v7[v5], (int)v30, 0);
      goto LABEL_10;
    }
LABEL_20:
    abort(v2);
  }
  v24 = *(_DWORD *)(a2 + 152);
  if ( v24 > 17 )
    goto LABEL_20;
  v2 = (int *)v30[v24];
  if ( (v3 & 0x40000000) != 0 && *((_BYTE *)&v30[27] + v24) )
  {
    v25 = v30[v24];
  }
  else
  {
    if ( dwarf_reg_size_table[v24] != 4 )
      goto LABEL_20;
    v25 = *v2;
  }
  v27 = *(int *)((char *)&dword_80EB094 + a2 - 135180288) + v25;
LABEL_10:
  v9 = 0;
  *(_DWORD *)(a1 + 72) = v27;
  v10 = (int *)a2;
  while ( 2 )
  {
    switch ( v10[1] )
    {
      case 1:
        v18 = a1;
        v17 = *v10 + v27;
        if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 )
          goto LABEL_30;
        goto LABEL_31;
      case 2:
        v23 = *v10;
        if ( *((_BYTE *)&v30[27] + *v10) )
        {
          if ( v23 > 17 )
            goto LABEL_20;
          if ( (v30[24] & 0x40000000) != 0 )
          {
            v2 = &GLOBAL_OFFSET_TABLE_;
            v11 = v30[v23];
            if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + v9 + 6352) > 4u )
              goto LABEL_20;
          }
          else
          {
            v2 = &GLOBAL_OFFSET_TABLE_;
            if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + v23 + 6352) != 4 )
              goto LABEL_20;
            v2 = &GLOBAL_OFFSET_TABLE_;
            v11 = *(_DWORD *)v30[v23];
            if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + v9 + 6352) > 4u )
              goto LABEL_20;
          }
LABEL_22:
          *(_BYTE *)(a1 + v9 + 108) = 1;
          *(_DWORD *)(a1 + 4 * v9) = v11;
        }
        else
        {
          v18 = a1;
          v17 = v30[v23];
          if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 )
LABEL_30:
            *(_BYTE *)(v18 + v9 + 108) = 0;
LABEL_31:
          *(_DWORD *)(a1 + 4 * v9) = v17;
        }
_L416:
        ++v9;
        v10 += 2;
        if ( v9 != 18 )
          continue;
        if ( *(_BYTE *)(a2 + 187) )
        {
          *(_DWORD *)(a1 + 96) |= 0x80000000;
          result = *(_DWORD *)(a1 + 76);
          if ( *(_BYTE *)result != 0xB8 )
            return result;
        }
        else
        {
          *(_DWORD *)(a1 + 96) &= ~0x80000000;
          result = *(_DWORD *)(a1 + 76);
          if ( *(_BYTE *)result != 0xB8 )
            return result;
        }
        if ( *(_DWORD *)(result + 1) == 173 )
        {
          result = *(unsigned __int16 *)(result + 5);
          if ( (_WORD)result == 0x80CD || (_WORD)result == 1295 )
          {
            result = a1;
            *(_DWORD *)(a1 + 96) |= 0x80000000;
          }
        }
        return result;
      case 3:
        v13 = (char *)*v10;
        v14 = 0;
        v15 = 0;
        do
        {
          v16 = (*v13++ & 0x7F) << v15;
          v15 += 7;
          v14 |= v16;
        }
        while ( *(v13 - 1) < 0 );
        v17 = execute_stack_op(v13, (unsigned int)&v13[v14], (int)v30, v27);
        v18 = a1;
        if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 )
          goto LABEL_30;
        goto LABEL_31;
      case 4:
        v11 = *v10 + v27;
        if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + v9 + 6352) <= 4u )
          goto LABEL_22;
        goto LABEL_20;
      case 5:
        v19 = (char *)*v10;
        v20 = 0;
        v21 = 0;
        do
        {
          v22 = (*v19++ & 0x7F) << v21;
          v21 += 7;
          v20 |= v22;
        }
        while ( *(v19 - 1) < 0 );
        v11 = execute_stack_op(v19, (unsigned int)&v19[v20], (int)v30, v27);
        if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + v9 + 6352) > 4u )
          goto LABEL_20;
        goto LABEL_22;
      default:
        goto _L416;
    }
  }
}
// 80B8914: variable 'v2' is possibly undefined
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 80EB000: using guessed type int GLOBAL_OFFSET_TABLE_;
// 80EB094: using guessed type int dword_80EB094;
// 80EC8D4: using guessed type char byte_80EC8D4;

//----- (080B8B80) --------------------------------------------------------
int __usercall uw_init_context_1@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>)
{
  int v6; // ecx
  bool v7; // zf
  int result; // eax
  int v10; // [esp+1Ch] [ebp-E0h] BYREF
  _DWORD v11[55]; // [esp+20h] [ebp-DCh] BYREF
  void *retaddr; // [esp+FCh] [ebp+0h]

  memset((void *)a1, 0, 0x80u);
  *(_DWORD *)(a1 + 96) = 0x40000000;
  *(_DWORD *)(a1 + 76) = retaddr;
  if ( uw_frame_state_for((_DWORD *)a1, v11, a4) )
    goto LABEL_9;
  if ( !dwarf_reg_size_table[0] )
  {
    dwarf_reg_size_table[0] = 4;
    byte_80EC8D2 = 4;
    byte_80EC8D1 = 4;
    byte_80EC8D3 = 4;
    byte_80EC8D6 = 4;
    byte_80EC8D7 = 4;
    byte_80EC8D5 = 4;
    byte_80EC8D4 = 4;
    byte_80EC8DB = 12;
    byte_80EC8DC = 12;
    byte_80EC8DD = 12;
    byte_80EC8DE = 12;
    byte_80EC8DF = 12;
    byte_80EC8E0 = 12;
    byte_80EC8D9 = 4;
    byte_80EC8D8 = 4;
  }
  if ( byte_80EC8D4 != 4 )
LABEL_9:
    abort(v6);
  v7 = (*(_BYTE *)(a1 + 99) & 0x40) == 0;
  v10 = a2;
  if ( !v7 )
    *(_BYTE *)(a1 + 112) = 0;
  v11[40] = 1;
  v11[38] = 4;
  v11[37] = 0;
  *(_DWORD *)(a1 + 16) = &v10;
  uw_update_context_1(a1, (int)v11);
  result = a3;
  *(_DWORD *)(a1 + 76) = a3;
  return result;
}
// 80B8CDE: variable 'v6' is possibly undefined
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 80EC8D1: using guessed type char byte_80EC8D1;
// 80EC8D2: using guessed type char byte_80EC8D2;
// 80EC8D3: using guessed type char byte_80EC8D3;
// 80EC8D4: using guessed type char byte_80EC8D4;
// 80EC8D5: using guessed type char byte_80EC8D5;
// 80EC8D6: using guessed type char byte_80EC8D6;
// 80EC8D7: using guessed type char byte_80EC8D7;
// 80EC8D8: using guessed type char byte_80EC8D8;
// 80EC8D9: using guessed type char byte_80EC8D9;
// 80EC8DB: using guessed type char byte_80EC8DB;
// 80EC8DC: using guessed type char byte_80EC8DC;
// 80EC8DD: using guessed type char byte_80EC8DD;
// 80EC8DE: using guessed type char byte_80EC8DE;
// 80EC8DF: using guessed type char byte_80EC8DF;
// 80EC8E0: using guessed type char byte_80EC8E0;

//----- (080B8CF0) --------------------------------------------------------
int __usercall uw_update_context@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v4; // ecx
  int result; // eax

  uw_update_context_1(a1, a2);
  result = *(_DWORD *)(a2 + 180);
  if ( *(_DWORD *)(a2 + 8 * result + 4) != 6 )
  {
    if ( result <= 17 )
    {
      if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 && *(_BYTE *)(a1 + result + 108) )
      {
        result = *(_DWORD *)(a1 + 4 * result);
        goto LABEL_6;
      }
      if ( dwarf_reg_size_table[result] == 4 )
      {
        result = **(_DWORD **)(a1 + 4 * result);
LABEL_6:
        *(_DWORD *)(a1 + 76) = result;
        return result;
      }
    }
    abort(v4);
  }
  *(_DWORD *)(a1 + 76) = 0;
  return result;
}
// 80B8D53: variable 'v4' is possibly undefined
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080B8D60) --------------------------------------------------------
int __usercall Unwind_RaiseException_Phase2@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, long double a3@<st0>)
{
  int result; // eax
  int v6; // eax
  int v7; // ebx
  _DWORD v8[42]; // [esp+4h] [ebp-DCh] BYREF
  int (__cdecl *v9)(int, int, _DWORD, _DWORD, _DWORD *, _DWORD *); // [esp+ACh] [ebp-34h]

  while ( 1 )
  {
    v6 = uw_frame_state_for(a2, v8, a3);
    v7 = 4 * (a1[4] == a2[18] - (a2[24] >> 31));
    if ( v6 )
      break;
    if ( v9 )
    {
      result = v9(1, v7 | 2, *a1, a1[1], a1, a2);
      if ( result == 7 )
        return result;
      if ( result != 8 )
        break;
    }
    if ( v7 )
      abort(a3);
    uw_update_context((int)a2, (int)v8);
  }
  return 2;
}
// 80B8D60: using guessed type _DWORD var_DC[42];

//----- (080B8E00) --------------------------------------------------------
int __usercall Unwind_ForcedUnwind_Phase2@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, long double a3@<st0>)
{
  int v5; // ebp
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // eax
  int (__cdecl *v11)(int, int, _DWORD, _DWORD, _DWORD *, _DWORD *, int); // [esp+8h] [ebp-E4h]
  _DWORD v12[42]; // [esp+10h] [ebp-DCh] BYREF
  int (__cdecl *v13)(int, int, _DWORD, _DWORD, _DWORD *, _DWORD *); // [esp+B8h] [ebp-34h]

  v5 = a1[4];
  v11 = (int (__cdecl *)(int, int, _DWORD, _DWORD, _DWORD *, _DWORD *, int))a1[3];
  while ( 1 )
  {
    v8 = uw_frame_state_for(a2, v12, a3);
    if ( v8 )
    {
      if ( v8 != 5 )
        break;
    }
    if ( v8 == 5 )
    {
      v9 = v11(1, 26, *a1, a1[1], a1, a2, v5);
      v7 = 5;
      if ( !v9 )
        return v7;
      return 2;
    }
    if ( v11(1, 10, *a1, a1[1], a1, a2, v5) )
      return 2;
    if ( v13 )
    {
      v6 = v13(1, 10, *a1, a1[1], a1, a2);
      v7 = v6;
      if ( v6 == 7 )
        return v7;
      if ( v6 != 8 )
        return 2;
    }
    uw_update_context((int)a2, (int)v12);
  }
  return 2;
}
// 80B8E00: using guessed type _DWORD var_DC[42];

//----- (080B8EC0) --------------------------------------------------------
int __usercall uw_install_context_1@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>)
{
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // ecx
  _BYTE *v7; // esi
  unsigned int v8; // ebp
  int result; // eax
  _DWORD *v10; // eax
  int v11; // [esp+18h] [ebp-20h] BYREF

  v4 = *(_DWORD *)(a2 + 96);
  if ( ((v4 & 0x40000000) == 0 || !*(_BYTE *)(a2 + 112)) && !*(_DWORD *)(a2 + 16) )
  {
    if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + 6356) != 4 )
      goto LABEL_32;
    v11 = *(_DWORD *)(a2 + 72);
    if ( (v4 & 0x40000000) != 0 )
      *(_BYTE *)(a2 + 112) = 0;
    *(_DWORD *)(a2 + 16) = &v11;
  }
  v5 = 0;
  do
  {
    while ( 1 )
    {
      v6 = *(_DWORD **)(a1 + 4 * v5);
      v7 = *(_BYTE **)(a2 + 4 * v5);
      if ( *(_BYTE *)(a1 + v5 + 108) )
        goto LABEL_32;
      if ( *(_BYTE *)(a2 + v5 + 108) && v6 )
      {
        if ( dwarf_reg_size_table[v5] != 4 )
          goto LABEL_32;
        *v6 = v7;
        goto LABEL_7;
      }
      if ( v6 != 0 && v7 != 0 && v6 != (_DWORD *)v7 )
        break;
LABEL_7:
      if ( ++v5 == 17 )
        goto LABEL_22;
    }
    v8 = (unsigned __int8)dwarf_reg_size_table[v5];
    if ( v8 < 4 )
    {
      if ( dwarf_reg_size_table[v5] )
      {
        *(_BYTE *)v6 = *v7;
        if ( (v8 & 2) != 0 )
          *(_WORD *)((char *)v6 + v8 - 2) = *(_WORD *)&v7[v8 - 2];
      }
      goto LABEL_7;
    }
    ++v5;
    *v6 = *(_DWORD *)v7;
    *(_DWORD *)((char *)v6 + v8 - 4) = *(_DWORD *)&v7[v8 - 4];
    qmemcpy(
      (void *)((unsigned int)(v6 + 1) & 0xFFFFFFFC),
      (const void *)(v7 - ((char *)v6 - ((unsigned int)(v6 + 1) & 0xFFFFFFFC))),
      4 * (((unsigned int)v6 + v8 - ((unsigned int)(v6 + 1) & 0xFFFFFFFC)) >> 2));
  }
  while ( v5 != 17 );
LABEL_22:
  result = 0;
  if ( ((*(_BYTE *)(a1 + 99) & 0x40) == 0 || !*(_BYTE *)(a1 + 112)) && !*(_DWORD *)(a1 + 16) )
  {
    v10 = *(_DWORD **)(a2 + 16);
    if ( (*(_BYTE *)(a2 + 99) & 0x40) != 0 && *(_BYTE *)(a2 + 112) )
      return (int)v10 + *(_DWORD *)(a2 + 104) - *(_DWORD *)(a1 + 72);
    if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + 6356) == 4 )
    {
      v10 = (_DWORD *)*v10;
      return (int)v10 + *(_DWORD *)(a2 + 104) - *(_DWORD *)(a1 + 72);
    }
LABEL_32:
    abort(a3);
  }
  return result;
}
// 80EB000: using guessed type int GLOBAL_OFFSET_TABLE_;

//----- (080B9070) --------------------------------------------------------
int __cdecl Unwind_GetGR(int a1, int a2)
{
  int result; // eax

  if ( a2 > 17 )
    goto LABEL_7;
  result = *(_DWORD *)(a1 + 4 * a2);
  if ( (*(_BYTE *)(a1 + 99) & 0x40) == 0 || !*(_BYTE *)(a1 + a2 + 108) )
  {
    if ( dwarf_reg_size_table[a2] == 4 )
      return *(_DWORD *)result;
LABEL_7:
    abort(a1);
  }
  return result;
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080B90D0) --------------------------------------------------------
int __cdecl Unwind_GetCFA(int a1)
{
  return *(_DWORD *)(a1 + 72);
}

//----- (080B90E0) --------------------------------------------------------
int __usercall Unwind_SetGR@<eax>(long double a1@<st0>, int a2, int a3, int a4)
{
  int result; // eax

  result = a3;
  if ( a3 > 17 )
    goto LABEL_7;
  if ( (*(_BYTE *)(a2 + 99) & 0x40) == 0 || !*(_BYTE *)(a2 + a3 + 108) )
  {
    if ( dwarf_reg_size_table[a3] == 4 )
    {
      result = a4;
      **(_DWORD **)(a2 + 4 * a3) = a4;
      return result;
    }
LABEL_7:
    abort(a1);
  }
  *(_DWORD *)(a2 + 4 * a3) = a4;
  return result;
}

//----- (080B9140) --------------------------------------------------------
int __cdecl Unwind_GetIP(int a1)
{
  return *(_DWORD *)(a1 + 76);
}

//----- (080B9150) --------------------------------------------------------
int __cdecl Unwind_GetIPInfo(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 96) >> 31;
  return *(_DWORD *)(a1 + 76);
}

//----- (080B9170) --------------------------------------------------------
int __cdecl Unwind_SetIP(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 76) = a2;
  return result;
}

//----- (080B9180) --------------------------------------------------------
int __cdecl Unwind_GetLanguageSpecificData(int a1)
{
  return *(_DWORD *)(a1 + 80);
}

//----- (080B9190) --------------------------------------------------------
int __cdecl Unwind_GetRegionStart(int a1)
{
  return *(_DWORD *)(a1 + 92);
}

//----- (080B91A0) --------------------------------------------------------
int __usercall Unwind_FindEnclosingFunction@<eax>(unsigned int a1@<ecx>, long double a2@<st0>, int a3)
{
  _DWORD v4[6]; // [esp+0h] [ebp-18h] BYREF

  if ( Unwind_Find_FDE(a1, a2, a3 - 1, v4) )
    return v4[2];
  else
    return 0;
}

//----- (080B91E0) --------------------------------------------------------
int __cdecl Unwind_GetDataRelBase(int a1)
{
  return *(_DWORD *)(a1 + 88);
}

//----- (080B91F0) --------------------------------------------------------
int __cdecl Unwind_GetTextRelBase(int a1)
{
  return *(_DWORD *)(a1 + 84);
}

//----- (080B9200) --------------------------------------------------------
int __usercall _frame_state_for@<eax>(long double a1@<st0>, int a2, int a3)
{
  int i; // edx
  int v4; // ecx
  int v6[32]; // [esp+0h] [ebp-15Ch] BYREF
  _DWORD v7[37]; // [esp+80h] [ebp-DCh] BYREF
  int v8; // [esp+114h] [ebp-48h]
  int v9; // [esp+118h] [ebp-44h]
  int v10; // [esp+120h] [ebp-3Ch]
  int v11; // [esp+134h] [ebp-28h]
  int v12; // [esp+13Ch] [ebp-20h]

  memset(v6, 0, sizeof(v6));
  v6[24] = 0x40000000;
  v6[19] = a2 + 1;
  if ( uw_frame_state_for(v6, v7, a1) || v10 == 2 )
    return 0;
  for ( i = 0; i != 18; ++i )
  {
    while ( 1 )
    {
      v4 = v7[2 * i + 1];
      *(_BYTE *)(a3 + i + 92) = v4;
      if ( (_BYTE)v4 == 1 || (_BYTE)v4 == 2 )
        break;
      *(_DWORD *)(a3 + 4 * i++ + 16) = 0;
      if ( i == 18 )
        goto LABEL_8;
    }
    *(_DWORD *)(a3 + 4 * i + 16) = v7[2 * i];
  }
LABEL_8:
  *(_DWORD *)(a3 + 8) = v8;
  *(_WORD *)(a3 + 88) = v9;
  *(_WORD *)(a3 + 90) = v11;
  *(_DWORD *)(a3 + 12) = v6[26];
  *(_DWORD *)(a3 + 4) = v12;
  return a3;
}
// 80B9200: using guessed type _DWORD var_DC[37];

//----- (080B92F0) --------------------------------------------------------
int __usercall Unwind_RaiseException@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>, _DWORD *a4)
{
  int v4; // eax
  int result; // eax
  int v6; // ecx
  int v7; // ebx
  char v8[128]; // [esp+4h] [ebp-1D8h] BYREF
  int v9[32]; // [esp+84h] [ebp-158h] BYREF
  _DWORD v10[42]; // [esp+104h] [ebp-D8h] BYREF
  int (__cdecl *v11)(int, int, _DWORD, _DWORD, _DWORD *, int *); // [esp+1ACh] [ebp-30h]
  int v12; // [esp+1C8h] [ebp-14h]
  int v13; // [esp+1CCh] [ebp-10h]
  int retaddr; // [esp+1E0h] [ebp+4h]

  v13 = a2;
  v12 = a1;
  uw_init_context_1((int)v8, (int)&a4, retaddr, a3);
  qmemcpy(v9, v8, sizeof(v9));
  while ( 1 )
  {
    result = uw_frame_state_for(v9, v10, a3);
    if ( result == 5 )
      break;
    if ( result )
      return 3;
    if ( v11 )
    {
      v4 = v11(1, 1, *a4, a4[1], a4, v9);
      if ( v4 == 6 )
      {
        v6 = v9[18];
        a4[3] = 0;
        a4[4] = v6 - ((unsigned int)v9[24] >> 31);
        qmemcpy(v9, v8, sizeof(v9));
        result = Unwind_RaiseException_Phase2(a4, v9, a3);
        if ( result == 7 )
        {
          uw_install_context_1((int)v8, (int)v9, a3);
          v7 = v9[19];
          *(int *)((char *)&retaddr + Unwind_DebugHook(v9[18], v9[19])) = v7;
          return v12;
        }
        return result;
      }
      if ( v4 != 8 )
        return 3;
    }
    uw_update_context((int)v9, (int)v10);
  }
  return result;
}
// 80B92F0: using guessed type _DWORD var_D8[42];

//----- (080B9420) --------------------------------------------------------
int __usercall Unwind_ForcedUnwind@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>, _DWORD *a4, int a5, int a6)
{
  _DWORD *v6; // esi
  int result; // eax
  int v8; // eax
  int v9; // ebx
  int v10; // esi
  char v11[128]; // [esp+0h] [ebp-118h] BYREF
  int v12[33]; // [esp+80h] [ebp-98h] BYREF
  int v13; // [esp+104h] [ebp-14h]
  int v14; // [esp+108h] [ebp-10h]
  int retaddr; // [esp+11Ch] [ebp+4h]

  v14 = a2;
  v13 = a1;
  uw_init_context_1((int)v11, (int)&a4, retaddr, a3);
  qmemcpy(v12, v11, 0x80u);
  v6 = a4;
  a4[3] = a5;
  v6[4] = a6;
  result = Unwind_ForcedUnwind_Phase2(v6, v12, a3);
  if ( result == 7 )
  {
    v8 = uw_install_context_1((int)v11, (int)v12, a3);
    v9 = v12[19];
    v10 = v8;
    Unwind_DebugHook(v12[18], v12[19], v8, v8);
    *(int *)((char *)&retaddr + v10) = v9;
    return v13;
  }
  return result;
}
// 80B92E0: using guessed type int __cdecl Unwind_DebugHook(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080B94C0) --------------------------------------------------------
void __usercall __noreturn Unwind_Resume(int a1@<eax>, int a2@<edx>, long double a3@<st0>, _DWORD *a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // ebx
  int v7; // edi
  char v8[128]; // [esp+8h] [ebp-118h] BYREF
  int v9[35]; // [esp+88h] [ebp-98h] BYREF
  int retaddr; // [esp+124h] [ebp+4h]

  v9[34] = a2;
  v9[33] = a1;
  uw_init_context_1((int)v8, (int)&a4, retaddr, a3);
  qmemcpy(v9, v8, 0x80u);
  if ( a4[3] )
    v4 = Unwind_ForcedUnwind_Phase2(a4, v9, a3);
  else
    v4 = Unwind_RaiseException_Phase2(a4, v9, a3);
  if ( v4 != 7 )
    abort(a3);
  v5 = uw_install_context_1((int)v8, (int)v9, a3);
  v6 = v9[19];
  v7 = v5;
  Unwind_DebugHook(v9[18], v9[19], v5, v5);
  *(int *)((char *)&retaddr + v7) = v6;
}
// 80B92E0: using guessed type int __cdecl Unwind_DebugHook(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080B9570) --------------------------------------------------------
void __usercall __noreturn Unwind_Resume_or_Rethrow(int a1@<eax>, int a2@<edx>, long double a3@<st0>, _DWORD *a4)
{
  int v4; // ebx
  char v5[128]; // [esp+4h] [ebp-118h] BYREF
  int v6[35]; // [esp+84h] [ebp-98h] BYREF
  int retaddr; // [esp+120h] [ebp+4h]

  v6[34] = a2;
  v6[33] = a1;
  if ( a4[3] )
  {
    uw_init_context_1((int)v5, (int)&a4, retaddr, a3);
    qmemcpy(v6, v5, 0x80u);
    if ( Unwind_ForcedUnwind_Phase2(a4, v6, a3) != 7 )
      abort(a3);
    uw_install_context_1((int)v5, (int)v6, a3);
    v4 = v6[19];
    *(int *)((char *)&retaddr + Unwind_DebugHook(v6[18], v6[19])) = v4;
  }
  else
  {
    Unwind_RaiseException(0, a2, a3, a4);
  }
}

//----- (080B9640) --------------------------------------------------------
int (__cdecl *__cdecl Unwind_DeleteException(int a1))(int, int)
{
  int (__cdecl *result)(int, int); // eax

  result = *(int (__cdecl **)(int, int))(a1 + 8);
  if ( result )
    return (int (__cdecl *)(int, int))result(1, a1);
  return result;
}

//----- (080B9660) --------------------------------------------------------
int __usercall Unwind_Backtrace@<eax>(long double a1@<st0>, int (__cdecl *a2)(_DWORD *, int), int a3)
{
  int v3; // eax
  int v4; // edi
  _DWORD v6[32]; // [esp+0h] [ebp-158h] BYREF
  _DWORD v7[54]; // [esp+80h] [ebp-D8h] BYREF
  int retaddr; // [esp+15Ch] [ebp+4h]

  uw_init_context_1((int)v6, (int)&a2, retaddr, a1);
  while ( 1 )
  {
    v3 = uw_frame_state_for(v6, v7, a1);
    v4 = v3;
    if ( v3 )
    {
      if ( v3 != 5 )
        break;
    }
    if ( a2(v6, a3) )
      break;
    if ( v4 == 5 )
      return v4;
    uw_update_context((int)v6, (int)v7);
  }
  return 3;
}
// 80B9660: using guessed type _DWORD var_158[32];
// 80B9660: using guessed type _DWORD var_D8[54];

//----- (080B96D2) --------------------------------------------------------
void *_x86_get_pc_thunk_ax()
{
  void *retaddr; // [esp+0h] [ebp+0h]

  return retaddr;
}

//----- (080B96D6) --------------------------------------------------------
void _x86_get_pc_thunk_si()
{
  ;
}

//----- (080B96DA) --------------------------------------------------------
void _x86_get_pc_thunk_di()
{
  ;
}

//----- (080B96DE) --------------------------------------------------------
void _x86_get_pc_thunk_bp()
{
  ;
}

//----- (080B96F0) --------------------------------------------------------
int __cdecl fde_unencoded_compare(int a1, int a2, int a3)
{
  int result; // eax

  result = -(*(_DWORD *)(a2 + 8) < *(_DWORD *)(a3 + 8));
  if ( *(_DWORD *)(a2 + 8) > *(_DWORD *)(a3 + 8) )
    return 1;
  return result;
}

//----- (080B9710) --------------------------------------------------------
int __usercall frame_downheap@<eax>(
        int result@<eax>,
        int (__cdecl *a2)(int, int, int)@<edx>,
        int a3@<ecx>,
        int a4,
        int a5)
{
  int v5; // edx
  int i; // esi
  int *v8; // edi
  int v9; // ebx
  int *v10; // esi
  int v11; // eax
  int v12; // [esp+0h] [ebp-2Ch]
  int v14; // [esp+Ch] [ebp-20h]

  v5 = a4;
  v12 = result;
  for ( i = 2 * a4 + 1; a5 > i; v5 = v9 )
  {
    v9 = i + 1;
    if ( a5 <= i + 1 )
    {
      v8 = (int *)(a3 + 4 * i);
      v9 = i;
    }
    else
    {
      v14 = v5;
      v8 = (int *)(a3 + 4 * v9 - 4);
      v11 = a2(v12, *v8, *(_DWORD *)(a3 + 4 * v9));
      v5 = v14;
      if ( v11 < 0 )
        v8 = (int *)(a3 + 4 * v9);
      else
        v9 = i;
    }
    v10 = (int *)(a3 + 4 * v5);
    result = a2(v12, *v10, *v8);
    if ( result >= 0 )
      break;
    result = *v10;
    *v10 = *v8;
    i = 2 * v9 + 1;
    *v8 = result;
  }
  return result;
}

//----- (080B97D0) --------------------------------------------------------
int __usercall frame_heapsort@<eax>(int result@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3@<ecx>)
{
  int v3; // ebp
  int v4; // edi
  unsigned int v5; // ebx
  int v6; // esi
  int v7; // ebx
  int v8; // eax
  int v9; // [esp-10h] [ebp-3Ch]
  int v10; // [esp+4h] [ebp-28h]

  v3 = a3;
  v4 = a3 + 8;
  v5 = *(_DWORD *)(a3 + 4);
  v10 = result;
  v6 = (v5 >> 1) - 1;
  if ( v5 >> 1 )
  {
    do
    {
      v9 = v6--;
      result = frame_downheap(v10, a2, v4, v9, v5);
    }
    while ( v6 != -1 );
    v3 = a3;
  }
  v7 = v5 - 1;
  if ( v7 > 0 )
  {
    do
    {
      v8 = *(_DWORD *)(v3 + 8);
      *(_DWORD *)(v3 + 8) = *(_DWORD *)(v4 + 4 * v7);
      *(_DWORD *)(v4 + 4 * v7) = v8;
      result = frame_downheap(v10, a2, v4, 0, v7--);
    }
    while ( v7 );
  }
  return result;
}

//----- (080B9860) --------------------------------------------------------
int __usercall size_of_encoded_value@<eax>(char a1@<al>, int a2@<ecx>)
{
  unsigned __int8 v2; // dl
  int result; // eax

  if ( a1 == -1 )
    return 0;
  v2 = a1 & 7;
  if ( (a1 & 7) == 2 )
    return 2;
  if ( v2 <= 2u )
  {
    if ( v2 )
LABEL_9:
      abort(a2);
    return 4;
  }
  if ( v2 == 3 )
    return 4;
  result = 8;
  if ( v2 != 4 )
    goto LABEL_9;
  return result;
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080B98D0) --------------------------------------------------------
int __usercall base_from_object@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>)
{
  unsigned __int8 v3; // al

  if ( a1 == -1 )
    return 0;
  v3 = a1 & 0x70;
  if ( v3 != 32 )
  {
    if ( v3 > 0x20u )
    {
      if ( v3 == 48 )
        return *(_DWORD *)(a2 + 8);
      if ( v3 == 80 )
        return 0;
LABEL_8:
      abort(a3);
    }
    if ( v3 && v3 != 16 )
      goto LABEL_8;
    return 0;
  }
  return *(_DWORD *)(a2 + 4);
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080B9930) --------------------------------------------------------
int __usercall base_from_cb_data@<eax>(char a1@<al>, int a2@<edx>, int a3@<ecx>)
{
  unsigned __int8 v3; // al

  if ( a1 == -1 )
    return 0;
  v3 = a1 & 0x70;
  if ( v3 != 32 )
  {
    if ( v3 > 0x20u )
    {
      if ( v3 == 48 )
        return *(_DWORD *)(a2 + 8);
      if ( v3 == 80 )
        return 0;
LABEL_8:
      abort(a3);
    }
    if ( v3 && v3 != 16 )
      goto LABEL_8;
    return 0;
  }
  return *(_DWORD *)(a2 + 4);
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080B9990) --------------------------------------------------------
unsigned int *__usercall read_encoded_value_with_base_0@<eax>(
        char a1@<al>,
        unsigned __int16 *a2@<edx>,
        unsigned __int16 *a3@<ecx>,
        unsigned int *a4)
{
  int v5; // ecx
  unsigned int v6; // esi
  unsigned int *v7; // ebx
  unsigned int *result; // eax
  unsigned int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  unsigned int *v13; // edi
  char v14; // [esp+0h] [ebp-24h]
  char v15; // [esp+4h] [ebp-20h]

  if ( a1 == 80 )
  {
    v13 = (unsigned int *)(((unsigned int)a3 + 3) & 0xFFFFFFFC);
    *a4 = *v13;
    return v13 + 1;
  }
  else
  {
    v5 = a1 & 0xF;
    switch ( (char)v5 )
    {
      case 0:
      case 3:
      case 11:
        v6 = *(_DWORD *)a3;
        v7 = (unsigned int *)(a3 + 2);
        goto LABEL_4;
      case 1:
        v7 = (unsigned int *)a3;
        v6 = 0;
        v11 = 0;
        v14 = a1;
        do
        {
          v7 = (unsigned int *)((char *)v7 + 1);
          v12 = (*((_BYTE *)v7 - 1) & 0x7F) << v11;
          v11 += 7;
          v6 |= v12;
        }
        while ( *((char *)v7 - 1) < 0 );
        a1 = v14;
        goto LABEL_4;
      case 2:
        v6 = *a3;
        v7 = (unsigned int *)(a3 + 1);
        goto LABEL_4;
      case 4:
      case 12:
        v6 = *(_DWORD *)a3;
        v7 = (unsigned int *)(a3 + 4);
        goto LABEL_4;
      case 9:
        v7 = (unsigned int *)a3;
        v6 = 0;
        v9 = 0;
        v15 = a1;
        do
        {
          v7 = (unsigned int *)((char *)v7 + 1);
          v10 = (*((_BYTE *)v7 - 1) & 0x7F) << v9;
          v9 += 7;
          v6 |= v10;
        }
        while ( *((char *)v7 - 1) < 0 );
        a1 = v15;
        if ( v9 > 0x1F || (*((_BYTE *)v7 - 1) & 0x40) == 0 )
          goto LABEL_4;
        v6 |= -1 << v9;
        goto LABEL_5;
      case 10:
        v6 = (__int16)*a3;
        v7 = (unsigned int *)(a3 + 1);
LABEL_4:
        if ( v6 )
        {
LABEL_5:
          if ( (a1 & 0x70) == 16 )
            a2 = a3;
          v6 += (unsigned int)a2;
          if ( a1 < 0 )
            v6 = *(_DWORD *)v6;
        }
        *a4 = v6;
        result = v7;
        break;
      default:
        abort(v5);
    }
  }
  return result;
}
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);

//----- (080B9AF0) --------------------------------------------------------
int __cdecl fde_single_encoding_compare(int a1, int a2, int a3)
{
  int v3; // ecx
  char v4; // bl
  unsigned __int16 *v5; // esi
  int result; // eax
  unsigned int v7; // [esp+8h] [ebp-14h] BYREF
  unsigned int v8[4]; // [esp+Ch] [ebp-10h] BYREF

  v4 = *(_WORD *)(a1 + 16) >> 3;
  v5 = (unsigned __int16 *)base_from_object(v4, a1, v3);
  read_encoded_value_with_base_0(v4, v5, (unsigned __int16 *)(a2 + 8), &v7);
  read_encoded_value_with_base_0(*(_WORD *)(a1 + 16) >> 3, v5, (unsigned __int16 *)(a3 + 8), v8);
  result = -(v7 < v8[0]);
  if ( v7 > v8[0] )
    return 1;
  return result;
}
// 80B9B09: variable 'v3' is possibly undefined
// 80B9AF0: using guessed type unsigned int var_10[4];

//----- (080B9B70) --------------------------------------------------------
int __usercall get_cie_encoding@<eax>(_BYTE *a1@<eax>)
{
  _BYTE *v1; // edi
  int v3; // eax
  unsigned __int8 v4; // cl
  char *v5; // edx
  int result; // eax
  unsigned int *encoded_value_with_base_0; // eax
  char *v8; // ebx
  char v9; // dl
  unsigned int v10[4]; // [esp+0h] [ebp-10h] BYREF

  v1 = a1 + 9;
  v3 = strlen(a1 + 9);
  v4 = a1[8];
  v5 = &v1[v3 + 1];
  if ( v4 > 3u )
  {
    result = 255;
    if ( *v5 != 4 || v5[1] )
      return result;
    v5 += 2;
  }
  if ( a1[9] != 122 )
    return 0;
  do
  {
    if ( *v5++ >= 0 )
      break;
    ++v5;
  }
  while ( *(v5 - 1) < 0 );
  while ( 1 )
  {
    encoded_value_with_base_0 = (unsigned int *)(v5 + 1);
    if ( *v5 >= 0 )
      break;
    ++v5;
  }
  if ( v4 == 1 )
  {
    encoded_value_with_base_0 = (unsigned int *)(v5 + 2);
  }
  else
  {
    do
      encoded_value_with_base_0 = (unsigned int *)((char *)encoded_value_with_base_0 + 1);
    while ( *((char *)encoded_value_with_base_0 - 1) < 0 );
  }
  v8 = a1 + 10;
  do
    encoded_value_with_base_0 = (unsigned int *)((char *)encoded_value_with_base_0 + 1);
  while ( *((char *)encoded_value_with_base_0 - 1) < 0 );
  v9 = a1[10];
  if ( v9 != 82 )
  {
    do
    {
      while ( v9 == 80 )
      {
        ++v8;
        encoded_value_with_base_0 = read_encoded_value_with_base_0(
                                      *(_BYTE *)encoded_value_with_base_0 & 0x7F,
                                      0,
                                      (unsigned __int16 *)((char *)encoded_value_with_base_0 + 1),
                                      v10);
        v9 = *v8;
        if ( *v8 == 82 )
          return *(unsigned __int8 *)encoded_value_with_base_0;
      }
      if ( v9 != 76 )
        return 0;
      v9 = *++v8;
      encoded_value_with_base_0 = (unsigned int *)((char *)encoded_value_with_base_0 + 1);
    }
    while ( *v8 != 82 );
  }
  return *(unsigned __int8 *)encoded_value_with_base_0;
}
// 80B9B70: using guessed type unsigned int var_10[4];

//----- (080B9C90) --------------------------------------------------------
int __usercall linear_search_fdes@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  __int16 v6; // ax
  int cie_encoding; // esi
  unsigned int v8; // edx
  int v9; // edx
  int v10; // ebp
  int v11; // ecx
  unsigned __int16 *v12; // eax
  int v13; // ecx
  unsigned int v14; // eax
  int v15; // edx
  int i; // [esp+Ch] [ebp-40h]
  unsigned __int16 *v18; // [esp+10h] [ebp-3Ch]
  unsigned int v20; // [esp+28h] [ebp-24h] BYREF
  unsigned int v21[8]; // [esp+2Ch] [ebp-20h] BYREF

  v6 = *(_WORD *)(a1 + 16) >> 3;
  cie_encoding = (unsigned __int8)v6;
  v18 = (unsigned __int16 *)base_from_object(v6, a1, a3);
  for ( i = 0; *(_DWORD *)a2; a2 += *(_DWORD *)a2 + 4 )
  {
    v9 = *(_DWORD *)(a2 + 4);
    if ( v9 )
    {
      if ( (*(_BYTE *)(a1 + 16) & 4) != 0 )
      {
        v10 = a2 + 4 - v9;
        if ( v10 != i )
        {
          cie_encoding = get_cie_encoding((_BYTE *)(a2 + 4 - v9));
          i = v10;
          v18 = (unsigned __int16 *)base_from_object(cie_encoding, a1, v11);
        }
      }
      if ( cie_encoding )
      {
        v12 = (unsigned __int16 *)read_encoded_value_with_base_0(cie_encoding, v18, (unsigned __int16 *)(a2 + 8), &v20);
        read_encoded_value_with_base_0(cie_encoding & 0xF, 0, v12, v21);
        v14 = size_of_encoded_value(cie_encoding, v13);
        v15 = -1;
        if ( v14 <= 3 )
          v15 = (1 << (8 * v14)) - 1;
        if ( (v20 & v15) != 0 && a3 - v20 < v21[0] )
          return a2;
      }
      else
      {
        v8 = *(_DWORD *)(a2 + 12);
        v20 = *(_DWORD *)(a2 + 8);
        v21[0] = v8;
        if ( v20 && a3 - v20 < v8 )
          return a2;
      }
    }
  }
  return 0;
}
// 80B9D36: variable 'v11' is possibly undefined
// 80B9D76: variable 'v13' is possibly undefined
// 80B9C90: using guessed type unsigned int var_20[8];

//----- (080B9DE0) --------------------------------------------------------
int __cdecl Unwind_IteratePhdrCallback(int a1, unsigned int a2, int *a3)
{
  int *v3; // ebp
  _DWORD *v4; // eax
  int v5; // ecx
  int v6; // esi
  int *v7; // ecx
  int v8; // ecx
  int v9; // edx
  _DWORD *v10; // ebx
  int v11; // esi
  unsigned int v12; // esi
  unsigned int v13; // ebp
  int *v14; // ecx
  int v15; // eax
  int v16; // esi
  int *v18; // eax
  int v19; // edx
  char v20; // bl
  unsigned __int16 *v21; // eax
  unsigned int *encoded_value_with_base_0; // eax
  int v23; // ecx
  char v24; // bl
  unsigned __int16 *v25; // edi
  unsigned int v26; // eax
  int v27; // ecx
  unsigned int v28; // eax
  int v29; // eax
  char cie_encoding; // bl
  int v31; // ecx
  unsigned __int16 *v32; // eax
  int *v33; // edi
  unsigned int v34; // esi
  int *v35; // eax
  unsigned __int16 *v36; // eax
  unsigned int *v37; // eax
  unsigned int v38; // edi
  unsigned int v39; // ecx
  unsigned int v40; // ebx
  unsigned int v41; // edx
  unsigned int *v42; // edi
  int v43; // ebx
  int v44; // ecx
  int v45; // eax
  int v46; // esi
  int v47; // [esp+0h] [ebp-5Ch]
  char v48; // [esp+0h] [ebp-5Ch]
  int v49; // [esp+4h] [ebp-58h]
  _DWORD *v50; // [esp+4h] [ebp-58h]
  unsigned int v51; // [esp+4h] [ebp-58h]
  int v52; // [esp+8h] [ebp-54h]
  int *v53; // [esp+Ch] [ebp-50h]
  int v54; // [esp+14h] [ebp-48h]
  int v55; // [esp+18h] [ebp-44h]
  int *v56; // [esp+1Ch] [ebp-40h]
  int v57; // [esp+20h] [ebp-3Ch] BYREF
  int v58; // [esp+24h] [ebp-38h] BYREF
  unsigned int v59[13]; // [esp+28h] [ebp-34h] BYREF

  v3 = a3;
  v4 = *(_DWORD **)(a1 + 8);
  v47 = *(_DWORD *)a1;
  if ( !a3[5] || a2 <= 0x1F )
  {
    if ( a2 <= 0xD )
      return -1;
    goto LABEL_8;
  }
  v5 = *(_DWORD *)(a1 + 16);
  v6 = *(_DWORD *)(a1 + 24);
  v49 = *(_DWORD *)(a1 + 28);
  if ( *(_QWORD *)(a1 + 16) != *((_QWORD *)&GLOBAL_OFFSET_TABLE_ + 495)
    || *((_QWORD *)&GLOBAL_OFFSET_TABLE_ + 802) != __PAIR64__(v49, v6) )
  {
    *(&GLOBAL_OFFSET_TABLE_ + 991) = *(_DWORD *)(a1 + 20);
    *(&GLOBAL_OFFSET_TABLE_ + 990) = v5;
    v7 = &GLOBAL_OFFSET_TABLE_ + 1614;
    *(&GLOBAL_OFFSET_TABLE_ + 1604) = v6;
    *(&GLOBAL_OFFSET_TABLE_ + 1605) = v49;
    do
    {
      *(v7 - 6) = 0;
      *(v7 - 5) = 0;
      *(v7 - 1) = (int)v7;
      v7 += 6;
    }
    while ( &GLOBAL_OFFSET_TABLE_ + 1662 != v7 );
    v53 = 0;
    v56 = 0;
    *(&GLOBAL_OFFSET_TABLE_ + 1655) = 0;
    a3[5] = 0;
    *(&GLOBAL_OFFSET_TABLE_ + 1606) = (int)(&GLOBAL_OFFSET_TABLE_ + 1608);
LABEL_9:
    v8 = *(unsigned __int16 *)(a1 + 12);
    if ( !(_WORD)v8 )
      return 0;
    v9 = 0;
    v55 = 0;
    v54 = 0;
    v52 = 0;
    v10 = 0;
    v50 = 0;
    while ( 1 )
    {
      v11 = *v4;
      if ( *v4 != 1 )
        break;
      v12 = v4[2] + v47;
      if ( v12 > *a3 || (v13 = v12 + v4[5], *a3 >= v13) )
      {
LABEL_14:
        ++v9;
        v4 += 8;
        if ( v8 == v9 )
          goto LABEL_19;
      }
      else
      {
        ++v9;
        v4 += 8;
        v55 = v13;
        v54 = v12;
        v52 = 1;
        if ( v8 == v9 )
        {
LABEL_19:
          v14 = (int *)v52;
          v3 = a3;
          if ( v52 )
          {
            if ( a2 > 0x1F )
            {
              if ( v53 && v56 )
              {
                v56[5] = v53[5];
                v14 = &GLOBAL_OFFSET_TABLE_;
                v15 = *(&GLOBAL_OFFSET_TABLE_ + 1606);
                *(&GLOBAL_OFFSET_TABLE_ + 1606) = (int)v53;
                v53[5] = v15;
              }
              else
              {
                v53 = (int *)frame_hdr_cache_head;
              }
              v53[2] = v47;
              v53[4] = (int)v10;
              v53[3] = (int)v50;
              *v53 = v54;
              v53[1] = v55;
            }
            goto LABEL_25;
          }
          return 0;
        }
      }
    }
    if ( v11 == 1685382480 )
    {
      v50 = v4;
    }
    else if ( v11 == 2 )
    {
      v10 = v4;
    }
    goto LABEL_14;
  }
  v33 = (int *)*(&GLOBAL_OFFSET_TABLE_ + 1606);
  if ( !v33 )
  {
LABEL_8:
    v53 = 0;
    v56 = 0;
    goto LABEL_9;
  }
  v34 = *a3;
  v14 = (int *)*(&GLOBAL_OFFSET_TABLE_ + 1606);
  v35 = 0;
  while ( *v14 > v34 || v14[1] <= v34 )
  {
    if ( !*(_QWORD *)v14 || !v14[5] )
    {
      v56 = v35;
      v53 = v14;
      v4 = *(_DWORD **)(a1 + 8);
      goto LABEL_9;
    }
    v35 = v14;
    v14 = (int *)v14[5];
  }
  v47 = v14[2];
  v50 = (_DWORD *)v14[3];
  v10 = (_DWORD *)v14[4];
  if ( v33 != v14 )
  {
    v35[5] = v14[5];
    v14[5] = (int)v33;
    frame_hdr_cache_head = (int)v14;
  }
LABEL_25:
  if ( !v50 )
    return 0;
  v16 = v50[2] + v47;
  if ( *(_BYTE *)v16 != 1 )
    return 1;
  v3[2] = 0;
  if ( v10 )
  {
    v18 = (int *)(v10[2] + v47);
    v19 = *v18;
    if ( *v18 )
    {
      while ( v19 != 3 )
      {
        v18 += 2;
        v19 = *v18;
        if ( !*v18 )
          goto LABEL_35;
      }
      v3[2] = v18[1];
    }
  }
LABEL_35:
  v20 = *(_BYTE *)(v16 + 1);
  v21 = (unsigned __int16 *)base_from_cb_data(v20, (int)v3, (int)v14);
  encoded_value_with_base_0 = read_encoded_value_with_base_0(
                                v20,
                                v21,
                                (unsigned __int16 *)(v16 + 4),
                                (unsigned int *)&v57);
  v24 = *(_BYTE *)(v16 + 2);
  v25 = (unsigned __int16 *)encoded_value_with_base_0;
  if ( v24 == -1 || *(_BYTE *)(v16 + 3) != 59 )
    goto LABEL_37;
  v36 = (unsigned __int16 *)base_from_cb_data(*(_BYTE *)(v16 + 2), (int)v3, v23);
  v37 = read_encoded_value_with_base_0(v24, v36, v25, (unsigned int *)&v58);
  if ( !v58 )
    return 1;
  if ( ((unsigned __int8)v37 & 3) != 0 )
  {
LABEL_37:
    v26 = v3[1];
    v27 = *v3;
    v59[4] = 4;
    v59[0] = 0;
    v59[1] = v26;
    v28 = v3[2];
    v59[3] = v57;
    v59[2] = v28;
    v29 = linear_search_fdes((int)v59, v57, v27);
    v3[4] = v29;
    if ( v29 )
    {
      cie_encoding = get_cie_encoding((_BYTE *)(v29 + 4 - *(_DWORD *)(v29 + 4)));
      v32 = (unsigned __int16 *)base_from_cb_data(cie_encoding, (int)v3, v31);
      read_encoded_value_with_base_0(cie_encoding, v32, (unsigned __int16 *)(v3[4] + 8), (unsigned int *)&v58);
      v3[3] = v58;
    }
    return 1;
  }
  v51 = *v3;
  if ( *v3 < v16 + *v37 )
    return 1;
  v38 = v58 - 1;
  v39 = v16 + v37[2 * v58 - 2];
  if ( *v3 >= v39 )
  {
    v42 = &v37[2 * v38];
    goto LABEL_65;
  }
  if ( v58 == 1 )
    goto LABEL_70;
  v40 = 0;
  while ( 1 )
  {
    v41 = (v38 + v40) >> 1;
    v39 = 8 * v41;
    if ( v51 < v37[2 * v41] + v16 )
    {
      v38 = (v38 + v40) >> 1;
      goto LABEL_59;
    }
    if ( v51 < *(unsigned int *)((char *)v37 + v39 + 8) + v16 )
      break;
    v40 = v41 + 1;
LABEL_59:
    if ( v40 >= v38 )
      goto LABEL_70;
  }
  if ( v38 <= v40 )
LABEL_70:
    abort(v39);
  v42 = &v37[2 * v41];
LABEL_65:
  v43 = v16 + v42[1];
  v48 = get_cie_encoding((_BYTE *)(v43 + 4 - *(_DWORD *)(v43 + 4)));
  v45 = size_of_encoded_value(v48, v44);
  read_encoded_value_with_base_0(v48 & 0xF, 0, (unsigned __int16 *)(v43 + v45 + 8), v59);
  v46 = *v42 + v16;
  if ( *v3 < v46 + v59[0] )
    v3[4] = v43;
  v3[3] = v46;
  return 1;
}
// 80BA0EB: variable 'v31' is possibly undefined
// 80BA1CF: variable 'v23' is possibly undefined
// 80BA2CB: variable 'v44' is possibly undefined
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 80EB000: using guessed type int GLOBAL_OFFSET_TABLE_;
// 80EC918: using guessed type int frame_hdr_cache_head;

//----- (080BA320) --------------------------------------------------------
int __cdecl fde_mixed_encoding_compare(int a1, int a2, int a3)
{
  char cie_encoding; // di
  int v4; // ecx
  unsigned __int16 *v5; // eax
  char v6; // si
  int v7; // ecx
  unsigned __int16 *v8; // eax
  int result; // eax
  unsigned int v10; // [esp+8h] [ebp-24h] BYREF
  unsigned int v11[8]; // [esp+Ch] [ebp-20h] BYREF

  cie_encoding = get_cie_encoding((_BYTE *)(a2 + 4 - *(_DWORD *)(a2 + 4)));
  v5 = (unsigned __int16 *)base_from_object(cie_encoding, a1, v4);
  read_encoded_value_with_base_0(cie_encoding, v5, (unsigned __int16 *)(a2 + 8), &v10);
  v6 = get_cie_encoding((_BYTE *)(a3 + 4 - *(_DWORD *)(a3 + 4)));
  v8 = (unsigned __int16 *)base_from_object(v6, a1, v7);
  read_encoded_value_with_base_0(v6, v8, (unsigned __int16 *)(a3 + 8), v11);
  result = -(v10 < v11[0]);
  if ( v10 > v11[0] )
    return 1;
  return result;
}
// 80BA345: variable 'v4' is possibly undefined
// 80BA370: variable 'v7' is possibly undefined
// 80BA320: using guessed type unsigned int var_20[8];

//----- (080BA3B0) --------------------------------------------------------
int __usercall classify_object_over_fdes@<eax>(int a1@<eax>, _DWORD *a2@<edx>)
{
  _DWORD *v3; // ebx
  char *v4; // ecx
  int v5; // eax
  char v6; // di
  char *v7; // esi
  int v8; // ecx
  unsigned __int16 v9; // ax
  int v10; // ecx
  unsigned int v11; // eax
  int v12; // edx
  int cie_encoding; // [esp+0h] [ebp-3Ch]
  unsigned __int16 *v15; // [esp+4h] [ebp-38h]
  int v16; // [esp+Ch] [ebp-30h]
  unsigned int v17[8]; // [esp+1Ch] [ebp-20h] BYREF

  if ( *a2 )
  {
    v3 = a2;
    v15 = 0;
    LOBYTE(cie_encoding) = 0;
    v4 = 0;
    v16 = 0;
    while ( 1 )
    {
      v5 = v3[1];
      if ( v5 )
      {
        v6 = cie_encoding;
        v7 = (char *)v3 - v5 + 4;
        if ( v7 != v4 )
        {
          cie_encoding = get_cie_encoding((_BYTE *)v3 - v5 + 4);
          if ( cie_encoding == 255 )
            return -1;
          v6 = cie_encoding;
          v15 = (unsigned __int16 *)base_from_object(cie_encoding, a1, v8);
          v9 = *(_WORD *)(a1 + 16);
          if ( (v9 & 0x7F8) == 2040 )
          {
            *(_WORD *)(a1 + 16) = (8 * (unsigned __int8)cie_encoding) | v9 & 0xF807;
          }
          else if ( cie_encoding != (unsigned __int8)(v9 >> 3) )
          {
            *(_BYTE *)(a1 + 16) |= 4u;
          }
        }
        read_encoded_value_with_base_0(v6, v15, (unsigned __int16 *)v3 + 4, v17);
        v11 = size_of_encoded_value(v6, v10);
        v12 = -1;
        if ( v11 <= 3 )
          v12 = (1 << (8 * v11)) - 1;
        v4 = v7;
        if ( (v17[0] & v12) != 0 )
        {
          ++v16;
          if ( *(_DWORD *)a1 > v17[0] )
            *(_DWORD *)a1 = v17[0];
          v4 = v7;
        }
      }
      v3 = (_DWORD *)((char *)v3 + *v3 + 4);
      if ( !*v3 )
        return v16;
    }
  }
  return 0;
}
// 80BA425: variable 'v8' is possibly undefined
// 80BA46B: variable 'v10' is possibly undefined
// 80BA3B0: using guessed type unsigned int var_20[8];

//----- (080BA500) --------------------------------------------------------
unsigned int *__usercall add_fdes@<eax>(int a1@<eax>, int *a2@<edx>, int a3@<ecx>)
{
  int v4; // ebx
  __int16 v5; // ax
  int cie_encoding; // esi
  unsigned int *result; // eax
  int v8; // eax
  int v9; // edx
  int v10; // edx
  int v11; // ebp
  int v12; // ecx
  int v13; // ecx
  unsigned int v14; // eax
  int v15; // edx
  int v16; // [esp+0h] [ebp-3Ch]
  unsigned __int16 *v17; // [esp+4h] [ebp-38h]
  unsigned int v19[8]; // [esp+1Ch] [ebp-20h] BYREF

  v4 = a3;
  v5 = *(_WORD *)(a1 + 16) >> 3;
  cie_encoding = (unsigned __int8)v5;
  v17 = (unsigned __int16 *)base_from_object(v5, a1, a3);
  result = v19;
  v16 = 0;
  if ( *(_DWORD *)v4 )
  {
    while ( 1 )
    {
      v10 = *(_DWORD *)(v4 + 4);
      if ( !v10 )
        goto LABEL_6;
      if ( (*(_BYTE *)(a1 + 16) & 4) != 0 )
      {
        v11 = v4 + 4 - v10;
        if ( v11 != v16 )
        {
          cie_encoding = get_cie_encoding((_BYTE *)(v4 + 4 - v10));
          v16 = v11;
          v17 = (unsigned __int16 *)base_from_object(cie_encoding, a1, v12);
        }
      }
      if ( cie_encoding )
      {
        read_encoded_value_with_base_0(cie_encoding, v17, (unsigned __int16 *)(v4 + 8), v19);
        v14 = size_of_encoded_value(cie_encoding, v13);
        v15 = -1;
        if ( v14 <= 3 )
          v15 = (1 << (8 * v14)) - 1;
        if ( (v15 & v19[0]) != 0 )
        {
LABEL_4:
          v8 = *a2;
          if ( *a2 )
          {
            v9 = *(_DWORD *)(v8 + 4);
            *(_DWORD *)(v8 + 4) = v9 + 1;
            *(_DWORD *)(v8 + 4 * v9 + 8) = v4;
          }
          goto LABEL_6;
        }
        v4 += *(_DWORD *)v4 + 4;
        result = *(unsigned int **)v4;
        if ( !*(_DWORD *)v4 )
          return result;
      }
      else
      {
        if ( *(_DWORD *)(v4 + 8) )
          goto LABEL_4;
LABEL_6:
        v4 += *(_DWORD *)v4 + 4;
        result = *(unsigned int **)v4;
        if ( !*(_DWORD *)v4 )
          return result;
      }
    }
  }
  return result;
}
// 80BA59B: variable 'v12' is possibly undefined
// 80BA5C7: variable 'v13' is possibly undefined

//----- (080BA610) --------------------------------------------------------
int __usercall search_object@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, long double a4@<st0>)
{
  unsigned int *v4; // ebp
  char v5; // al
  unsigned __int16 v6; // ax
  unsigned int v7; // ebp
  unsigned int v8; // edi
  unsigned int v9; // ecx
  int result; // eax
  unsigned int v11; // ebx
  int v12; // esi
  int v13; // ebx
  _DWORD **v14; // ebx
  _DWORD *v15; // edx
  unsigned int v16; // esi
  int v17; // eax
  int *v18; // esi
  int i; // edx
  unsigned int v20; // edx
  unsigned int v21; // esi
  int v22; // edi
  char cie_encoding; // bp
  int v24; // ecx
  unsigned __int16 *v25; // eax
  unsigned __int16 *v26; // eax
  _DWORD *v27; // eax
  int v28; // eax
  int *v29; // ebx
  int v30; // ecx
  int (__cdecl *v31)(int, int, int); // edi
  int (__cdecl *v32)(int, int, int); // eax
  int *v33; // ebx
  int *v34; // esi
  char *v35; // eax
  unsigned int v36; // edi
  char v37; // bl
  int v38; // eax
  unsigned int v39; // edi
  unsigned int v40; // ebp
  unsigned int v41; // esi
  unsigned __int16 *v42; // eax
  int v43; // ebx
  int v44; // edx
  int v45; // eax
  int v46; // ebp
  int v47; // ebx
  _DWORD *v48; // esi
  int v49; // ebp
  int *v50; // eax
  _DWORD *v51; // eax
  _DWORD *v52; // edi
  int v53; // esi
  _DWORD *v54; // ebp
  int v55; // ebx
  _DWORD *v56; // eax
  unsigned int j; // [esp+4h] [ebp-50h]
  unsigned int v59; // [esp+4h] [ebp-50h]
  int *v60; // [esp+4h] [ebp-50h]
  unsigned int v61; // [esp+4h] [ebp-50h]
  int v62; // [esp+4h] [ebp-50h]
  unsigned int v63; // [esp+8h] [ebp-4Ch]
  int v64; // [esp+8h] [ebp-4Ch]
  char v65; // [esp+8h] [ebp-4Ch]
  unsigned int *v66; // [esp+8h] [ebp-4Ch]
  char *v67; // [esp+Ch] [ebp-48h]
  unsigned int *v68; // [esp+Ch] [ebp-48h]
  int (__cdecl *v69)(int, int, int); // [esp+Ch] [ebp-48h]
  int v70; // [esp+10h] [ebp-44h]
  int v71; // [esp+10h] [ebp-44h]
  unsigned int v72; // [esp+14h] [ebp-40h]
  unsigned __int16 *v73; // [esp+14h] [ebp-40h]
  int v74; // [esp+18h] [ebp-3Ch]
  int v75; // [esp+18h] [ebp-3Ch]
  char v76; // [esp+18h] [ebp-3Ch]
  int v77; // [esp+18h] [ebp-3Ch]
  unsigned int v78; // [esp+1Ch] [ebp-38h]
  _DWORD *v79; // [esp+20h] [ebp-34h]
  _DWORD *v80; // [esp+24h] [ebp-30h]
  unsigned int v81; // [esp+2Ch] [ebp-28h] BYREF
  _DWORD *v82; // [esp+30h] [ebp-24h] BYREF
  int v83; // [esp+34h] [ebp-20h]

  v4 = (unsigned int *)a1;
  v5 = *(_BYTE *)(a1 + 16);
  if ( (v5 & 1) != 0 )
    goto LABEL_2;
  v78 = v4[4] >> 11;
  if ( !v78 )
  {
    if ( (v5 & 2) != 0 )
    {
      v14 = (_DWORD **)v4[3];
      v15 = *v14;
      if ( !*v14 )
        goto LABEL_20;
      v16 = 0;
      do
      {
        v17 = classify_object_over_fdes((int)v4, v15);
        if ( v17 == -1 )
          goto LABEL_19;
        v15 = *++v14;
        v16 += v17;
      }
      while ( *v14 );
      v78 = v16;
    }
    else
    {
      v78 = classify_object_over_fdes((int)v4, (_DWORD *)v4[3]);
      if ( v78 == -1 )
      {
LABEL_19:
        v4[4] = 0;
        *((_WORD *)v4 + 8) = 2040;
        v4[3] = (unsigned int)(&GLOBAL_OFFSET_TABLE_ + 1601);
        goto LABEL_20;
      }
    }
    if ( (v78 & 0xFFE00000) != 0 )
      v4[4] &= 0x7FFu;
    else
      v4[4] = (v78 << 11) | v4[4] & 0x7FF;
    if ( !v78 )
      goto LABEL_20;
  }
  v27 = (_DWORD *)malloc(a4, 4 * v78 + 8);
  v82 = v27;
  if ( !v27 )
    goto LABEL_20;
  v27[1] = 0;
  v28 = malloc(a4, 4 * v78 + 8);
  v83 = v28;
  if ( v28 )
    *(_DWORD *)(v28 + 4) = 0;
  if ( (v4[4] & 2) != 0 )
  {
    v29 = (int *)v4[3];
    v30 = *v29;
    if ( !*v29 )
      goto LABEL_98;
    do
    {
      ++v29;
      add_fdes((int)v4, (int *)&v82, v30);
      v30 = *v29;
    }
    while ( *v29 );
  }
  else
  {
    add_fdes((int)v4, (int *)&v82, v4[3]);
  }
  v79 = v82;
  v80 = v82;
  if ( v82 && v82[1] != v78 )
    goto LABEL_98;
  v31 = (int (__cdecl *)(int, int, int))(&GLOBAL_OFFSET_TABLE_ - 49976);
  if ( (v4[4] & 4) == 0 )
  {
    v32 = (int (__cdecl *)(int, int, int))(&GLOBAL_OFFSET_TABLE_ - 50756);
    if ( (v4[4] & 0x7F8) != 0 )
      v32 = fde_single_encoding_compare;
    v31 = v32;
  }
  v64 = v83;
  if ( !v83 )
  {
    frame_heapsort((int)v4, v31, (int)v82);
    goto LABEL_89;
  }
  v75 = v82[1];
  if ( v75 )
  {
    v70 = 0;
    v67 = (char *)(v82 + 2);
    v33 = v82 + 2;
    v60 = &GLOBAL_OFFSET_TABLE_ + 1600;
    v34 = &GLOBAL_OFFSET_TABLE_ + 1600;
    while ( 1 )
    {
      *(_DWORD *)(v64 + 4 * v70++ + 8) = v34;
      if ( v75 == v70 )
        break;
      if ( v33 == v60 )
      {
LABEL_70:
        v34 = &GLOBAL_OFFSET_TABLE_ + 1600;
        ++v33;
      }
      else
      {
        v34 = v33;
        while ( v31((int)v4, v33[1], *v34) < 0 )
        {
          v35 = (char *)(v64 + (char *)v34 - v67);
          v34 = (int *)*((_DWORD *)v35 + 2);
          *((_DWORD *)v35 + 2) = 0;
          if ( v34 == v60 )
            goto LABEL_70;
        }
        ++v33;
      }
    }
    v43 = 0;
    v44 = 0;
    v45 = 0;
    v68 = v4;
    do
    {
      v46 = v79[v45 + 2];
      if ( *(_DWORD *)(v64 + 4 * v45 + 8) )
        v79[v44++ + 2] = v46;
      else
        *(_DWORD *)(v64 + 4 * v43++ + 8) = v46;
      ++v45;
    }
    while ( v70 != v45 );
    v4 = v68;
    v30 = v83;
    v75 = v44;
    v79 = v82;
  }
  else
  {
    v30 = v83;
    v43 = 0;
  }
  v80[1] = v75;
  *(_DWORD *)(v64 + 4) = v43;
  if ( v79[1] + *(_DWORD *)(v30 + 4) != v78 )
LABEL_98:
    abort(v30);
  frame_heapsort((int)v4, v31, v30);
  v47 = *(_DWORD *)(v83 + 4);
  v77 = v83;
  if ( !v47 )
    goto LABEL_88;
  v48 = v82;
  v66 = v4;
  v69 = v31;
  v49 = v82[1];
  while ( 1 )
  {
    v71 = v47 - 1;
    v50 = (int *)(4 * v47 + v77);
    v62 = v50[1];
    if ( !v49 )
      break;
    v51 = &v48[v47];
    v52 = v48;
    v53 = v49;
    v54 = v51;
    do
    {
      v55 = v53 - 1;
      if ( v69((int)v66, v52[v53 + 1], v62) <= 0 )
        break;
      --v53;
      v54[v55 + 2] = v52[v55 + 2];
    }
    while ( v55 );
    v49 = v53;
    v48 = v52;
LABEL_85:
    v48[v49 + 2 + v71] = v62;
    if ( !v71 )
      goto LABEL_87;
    v47 = v71;
  }
  v48[v47 + 1] = v50[1];
  if ( v47 != 1 )
  {
    v71 = v47 - 2;
    v62 = *v50;
    goto LABEL_85;
  }
LABEL_87:
  v4 = v66;
  v48[1] += *(_DWORD *)(v77 + 4);
  v77 = v83;
LABEL_88:
  free(v77);
LABEL_89:
  v56 = v82;
  *v82 = v4[3];
  v4[3] = (unsigned int)v56;
  *((_BYTE *)v4 + 16) |= 1u;
LABEL_20:
  if ( *v4 > a2 )
    return 0;
  v5 = *((_BYTE *)v4 + 16);
  if ( (v5 & 1) == 0 )
  {
    if ( (v5 & 2) == 0 )
      return linear_search_fdes((int)v4, v4[3], a2);
    v18 = (int *)v4[3];
    for ( i = *v18; *v18; i = *v18 )
    {
      result = linear_search_fdes((int)v4, i, a2);
      if ( result )
        return result;
      ++v18;
    }
    return 0;
  }
LABEL_2:
  if ( (v5 & 4) == 0 )
  {
    v6 = *((_WORD *)v4 + 8);
    if ( (v6 & 0x7F8) != 0 )
    {
      v36 = v4[3];
      v37 = v6 >> 3;
      v65 = v37;
      v61 = v36;
      v38 = base_from_object(v37, (int)v4, a3);
      v39 = *(_DWORD *)(v36 + 4);
      v73 = (unsigned __int16 *)v38;
      if ( v39 )
      {
        v40 = 0;
        v76 = v37 & 0xF;
        do
        {
          v41 = (v39 + v40) >> 1;
          v13 = *(_DWORD *)(v61 + 4 * v41 + 8);
          v42 = (unsigned __int16 *)read_encoded_value_with_base_0(v65, v73, (unsigned __int16 *)(v13 + 8), &v81);
          read_encoded_value_with_base_0(v76, 0, v42, (unsigned int *)&v82);
          if ( a2 >= v81 )
          {
            if ( a2 < (unsigned int)v82 + v81 )
              return v13;
            v40 = v41 + 1;
          }
          else
          {
            v39 = (v39 + v40) >> 1;
          }
        }
        while ( v40 < v39 );
      }
    }
    else
    {
      v7 = v4[3];
      v8 = 0;
      for ( j = *(_DWORD *)(v7 + 4); v8 < j; j = v9 )
      {
        v9 = (v8 + j) >> 1;
        result = *(_DWORD *)(v7 + 4 * v9 + 8);
        v11 = *(_DWORD *)(result + 8);
        v12 = *(_DWORD *)(result + 12);
        if ( a2 < v11 )
        {
          while ( v8 < v9 )
          {
            v20 = (v8 + v9) >> 1;
            result = *(_DWORD *)(v7 + 4 * v20 + 8);
            v11 = *(_DWORD *)(result + 8);
            v12 = *(_DWORD *)(result + 12);
            if ( a2 >= v11 )
              goto LABEL_28;
            v9 = (v8 + v9) >> 1;
          }
          return 0;
        }
        v20 = (v8 + j) >> 1;
        v9 = j;
LABEL_28:
        if ( a2 < v12 + v11 )
          return result;
        v8 = v20 + 1;
      }
    }
    return 0;
  }
  v72 = v4[3];
  v59 = *(_DWORD *)(v72 + 4);
  if ( !v59 )
    return 0;
  v63 = 0;
  v74 = (int)v4;
  while ( 2 )
  {
    v21 = (v59 + v63) >> 1;
    v22 = *(_DWORD *)(v72 + 4 * v21 + 8);
    cie_encoding = get_cie_encoding((_BYTE *)(v22 + 4 - *(_DWORD *)(v22 + 4)));
    v25 = (unsigned __int16 *)base_from_object(cie_encoding, v74, v24);
    v26 = (unsigned __int16 *)read_encoded_value_with_base_0(cie_encoding, v25, (unsigned __int16 *)(v22 + 8), &v81);
    read_encoded_value_with_base_0(cie_encoding & 0xF, 0, v26, (unsigned int *)&v82);
    if ( a2 < v81 )
    {
      v59 = (v59 + v63) >> 1;
LABEL_34:
      if ( v63 >= v59 )
        return 0;
      continue;
    }
    break;
  }
  if ( a2 >= (unsigned int)v82 + v81 )
  {
    v63 = v21 + 1;
    goto LABEL_34;
  }
  return v22;
}
// 80BA81C: variable 'v24' is possibly undefined
// 80BAA38: variable 'a3' is possibly undefined
// 80BACBE: variable 'v30' is possibly undefined
// 804DC50: using guessed type void __fastcall __noreturn abort(_DWORD);
// 805A510: using guessed type _DWORD __cdecl free(_DWORD);
// 80EB000: using guessed type int GLOBAL_OFFSET_TABLE_;

//----- (080BACD0) --------------------------------------------------------
int __usercall _register_frame_info_part_4@<eax>(int a1@<eax>, _DWORD *a2@<edx>)
{
  int result; // eax

  a2[3] = a1;
  a2[4] = 0;
  *a2 = -1;
  a2[1] = 0;
  a2[2] = 0;
  *((_WORD *)a2 + 8) = 2040;
  result = unseen_objects;
  unseen_objects = (int)a2;
  a2[5] = result;
  return result;
}
// 80EC9FC: using guessed type int unseen_objects;

//----- (080BAD60) --------------------------------------------------------
int __cdecl _register_frame_info_bases(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  int result; // eax

  result = (int)a1;
  if ( a1 )
  {
    if ( *a1 )
    {
      a2[3] = a1;
      a2[4] = 0;
      *a2 = -1;
      a2[1] = a3;
      *((_WORD *)a2 + 8) = 2040;
      a2[2] = a4;
      result = unseen_objects;
      unseen_objects = (int)a2;
      a2[5] = result;
    }
  }
  return result;
}
// 80EC9FC: using guessed type int unseen_objects;

//----- (080BAE00) --------------------------------------------------------
int __cdecl _register_frame_info(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  result = (int)a1;
  if ( a1 )
  {
    if ( *a1 )
      return _register_frame_info_part_4((int)a1, a2);
  }
  return result;
}

//----- (080BAE20) --------------------------------------------------------
int __usercall _register_frame@<eax>(long double a1@<st0>, int *a2)
{
  int result; // eax
  _DWORD *v3; // eax

  result = *a2;
  if ( *a2 )
  {
    v3 = (_DWORD *)malloc(a1, 0x18u);
    return _register_frame_info_part_4((int)a2, v3);
  }
  return result;
}

//----- (080BAE60) --------------------------------------------------------
int __cdecl _register_frame_info_table_bases(int a1, _DWORD *a2, int a3, int a4)
{
  int result; // eax

  a2[4] = 0;
  *((_BYTE *)a2 + 16) = 2;
  a2[1] = a3;
  *a2 = -1;
  a2[2] = a4;
  *((_WORD *)a2 + 8) |= 0x7F8u;
  a2[3] = a1;
  result = unseen_objects;
  unseen_objects = (int)a2;
  a2[5] = result;
  return result;
}
// 80EC9FC: using guessed type int unseen_objects;

//----- (080BAEF0) --------------------------------------------------------
int __cdecl _register_frame_info_table(int a1, _DWORD *a2)
{
  return _register_frame_info_table_bases(a1, a2, 0, 0);
}

//----- (080BAF10) --------------------------------------------------------
int __usercall _register_frame_table@<eax>(long double a1@<st0>, int a2)
{
  _DWORD *v2; // eax

  v2 = (_DWORD *)malloc(a1, 0x18u);
  return _register_frame_info_table_bases(a2, v2, 0, 0);
}

//----- (080BAF40) --------------------------------------------------------
int __usercall _deregister_frame_info_bases@<eax>(long double a1@<st0>, _DWORD *a2)
{
  int v2; // eax
  int v4; // esi
  int *v5; // eax

  if ( !a2 || !*a2 )
    return 0;
  v2 = unseen_objects;
  if ( unseen_objects )
  {
    if ( a2 == *(_DWORD **)(unseen_objects + 12) )
    {
      v4 = unseen_objects;
      v5 = &unseen_objects;
    }
    else
    {
      while ( 1 )
      {
        v4 = *(_DWORD *)(v2 + 20);
        if ( !v4 )
          goto LABEL_9;
        if ( a2 == *(_DWORD **)(v4 + 12) )
          break;
        v2 = *(_DWORD *)(v2 + 20);
      }
      v5 = (int *)(v2 + 20);
    }
LABEL_15:
    *v5 = *(_DWORD *)(v4 + 20);
    return v4;
  }
LABEL_9:
  v4 = seen_objects;
  if ( !seen_objects )
LABEL_18:
    abort(a1);
  v5 = &seen_objects;
  while ( (*(_BYTE *)(v4 + 16) & 1) == 0 )
  {
    if ( a2 == *(_DWORD **)(v4 + 12) )
      goto LABEL_15;
LABEL_12:
    v5 = (int *)(v4 + 20);
    v4 = *(_DWORD *)(v4 + 20);
    if ( !v4 )
      goto LABEL_18;
  }
  if ( a2 != **(_DWORD ***)(v4 + 12) )
    goto LABEL_12;
  *v5 = *(_DWORD *)(v4 + 20);
  free(a1, *(_DWORD *)(v4 + 12));
  return v4;
}
// 80EC9F8: using guessed type int seen_objects;
// 80EC9FC: using guessed type int unseen_objects;

//----- (080BB070) --------------------------------------------------------
_DWORD *__usercall _deregister_frame@<eax>(long double a1@<st0>, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // eax

  result = a2;
  if ( *a2 )
  {
    v3 = _deregister_frame_info_bases(a1, a2);
    return free(a1, v3);
  }
  return result;
}

//----- (080BB0B0) --------------------------------------------------------
int __usercall Unwind_Find_FDE@<eax>(unsigned int a1@<ecx>, long double a2@<st0>, unsigned int a3, _DWORD *a4)
{
  int v4; // ebp
  int v5; // edi
  __int16 v6; // ax
  char v7; // bl
  unsigned __int16 *v8; // eax
  int v10; // eax
  unsigned int *v11; // edx
  int *v12; // edi
  unsigned int v13; // [esp+10h] [ebp-34h] BYREF
  int v14; // [esp+14h] [ebp-30h]
  int v15; // [esp+18h] [ebp-2Ch]
  int v16; // [esp+1Ch] [ebp-28h]
  int v17; // [esp+20h] [ebp-24h]
  int v18; // [esp+24h] [ebp-20h]

  v4 = seen_objects;
  if ( !seen_objects )
    goto LABEL_10;
  while ( a3 < *(_DWORD *)v4 )
  {
    v4 = *(_DWORD *)(v4 + 20);
    if ( !v4 )
      goto LABEL_10;
  }
  v5 = search_object(v4, a3, a1, a2);
  if ( v5 )
  {
LABEL_6:
    *a4 = *(_DWORD *)(v4 + 4);
    a4[1] = *(_DWORD *)(v4 + 8);
    if ( (*(_BYTE *)(v4 + 16) & 4) != 0 )
      LOBYTE(v6) = get_cie_encoding((_BYTE *)(v5 + 4 - *(_DWORD *)(v5 + 4)));
    else
      v6 = *(_WORD *)(v4 + 16) >> 3;
    v7 = v6;
    v8 = (unsigned __int16 *)base_from_object(v6, v4, a1);
    read_encoded_value_with_base_0(v7, v8, (unsigned __int16 *)(v5 + 8), &v13);
    a4[2] = v13;
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v4 = unseen_objects;
      if ( !unseen_objects )
        break;
      unseen_objects = *(_DWORD *)(unseen_objects + 20);
      v10 = search_object(v4, a3, a1, a2);
      v11 = (unsigned int *)seen_objects;
      if ( seen_objects && (a1 = *(_DWORD *)v4, *(_DWORD *)v4 <= *(_DWORD *)seen_objects) )
      {
        do
        {
          v12 = (int *)(v11 + 5);
          v11 = (unsigned int *)v11[5];
        }
        while ( v11 && *v11 >= a1 );
        *(_DWORD *)(v4 + 20) = v11;
        *v12 = v4;
        if ( v10 )
        {
LABEL_17:
          v5 = v10;
          goto LABEL_6;
        }
      }
      else
      {
        *(_DWORD *)(v4 + 20) = seen_objects;
        seen_objects = v4;
        if ( v10 )
          goto LABEL_17;
      }
    }
    v13 = a3;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 1;
    if ( dl_iterate_phdr((int (__cdecl *)(int *, int, int))Unwind_IteratePhdrCallback, (int)&v13) < 0 )
    {
      return 0;
    }
    else
    {
      v5 = v17;
      if ( v17 )
      {
        *a4 = v14;
        a4[1] = v15;
        a4[2] = v16;
      }
    }
  }
  return v5;
}
// 80BB11D: conditional instruction was optimized away because %var_44.4==0
// 80BB206: conditional instruction was optimized away because %var_44.4==0
// 80BB15C: variable 'a1' is possibly undefined
// 80EC9F8: using guessed type int seen_objects;
// 80EC9FC: using guessed type int unseen_objects;

//----- (080BB2B0) --------------------------------------------------------
int __usercall base_of_encoded_value_0@<eax>(char a1@<al>, int a2@<edx>, long double a3@<st0>)
{
  unsigned __int8 v3; // al

  if ( a1 == -1 )
    return 0;
  v3 = a1 & 0x70;
  if ( v3 == 32 )
    return Unwind_GetTextRelBase(a2);
  if ( v3 <= 0x20u )
  {
    if ( v3 && v3 != 16 )
      goto LABEL_11;
    return 0;
  }
  if ( v3 != 64 )
  {
    if ( v3 != 80 )
    {
      if ( v3 == 48 )
        return Unwind_GetDataRelBase(a2);
LABEL_11:
      abort(a3);
    }
    return 0;
  }
  return Unwind_GetRegionStart(a2);
}

//----- (080BB340) --------------------------------------------------------
unsigned int *__usercall read_encoded_value_with_base_1@<eax>(
        char a1@<al>,
        unsigned __int16 *a2@<edx>,
        unsigned __int16 *a3@<ecx>,
        long double a4@<st0>,
        unsigned int *a5)
{
  unsigned int v6; // esi
  unsigned int *v7; // ebx
  unsigned int *result; // eax
  unsigned int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  unsigned int *v13; // edi
  char v14; // [esp+0h] [ebp-24h]
  char v15; // [esp+4h] [ebp-20h]

  if ( a1 == 80 )
  {
    v13 = (unsigned int *)(((unsigned int)a3 + 3) & 0xFFFFFFFC);
    *a5 = *v13;
    return v13 + 1;
  }
  else
  {
    switch ( a1 & 0xF )
    {
      case 0:
      case 3:
      case 0xB:
        v6 = *(_DWORD *)a3;
        v7 = (unsigned int *)(a3 + 2);
        goto LABEL_4;
      case 1:
        v7 = (unsigned int *)a3;
        v6 = 0;
        v11 = 0;
        v14 = a1;
        do
        {
          v7 = (unsigned int *)((char *)v7 + 1);
          v12 = (*((_BYTE *)v7 - 1) & 0x7F) << v11;
          v11 += 7;
          v6 |= v12;
        }
        while ( *((char *)v7 - 1) < 0 );
        a1 = v14;
        goto LABEL_4;
      case 2:
        v6 = *a3;
        v7 = (unsigned int *)(a3 + 1);
        goto LABEL_4;
      case 4:
      case 0xC:
        v6 = *(_DWORD *)a3;
        v7 = (unsigned int *)(a3 + 4);
        goto LABEL_4;
      case 9:
        v7 = (unsigned int *)a3;
        v6 = 0;
        v9 = 0;
        v15 = a1;
        do
        {
          v7 = (unsigned int *)((char *)v7 + 1);
          v10 = (*((_BYTE *)v7 - 1) & 0x7F) << v9;
          v9 += 7;
          v6 |= v10;
        }
        while ( *((char *)v7 - 1) < 0 );
        a1 = v15;
        if ( v9 > 0x1F || (*((_BYTE *)v7 - 1) & 0x40) == 0 )
          goto LABEL_4;
        v6 |= -1 << v9;
        goto LABEL_5;
      case 0xA:
        v6 = (__int16)*a3;
        v7 = (unsigned int *)(a3 + 1);
LABEL_4:
        if ( v6 )
        {
LABEL_5:
          if ( (a1 & 0x70) == 16 )
            a2 = a3;
          v6 += (unsigned int)a2;
          if ( a1 < 0 )
            v6 = *(_DWORD *)v6;
        }
        *a5 = v6;
        result = v7;
        break;
      default:
        abort(a4);
    }
  }
  return result;
}

//----- (080BB4A0) --------------------------------------------------------
int __usercall _gcc_personality_v0@<eax>(long double a1@<st0>, int a2, char a3, int a4, int a5, int a6, int a7)
{
  int result; // eax
  char *LanguageSpecificData; // esi
  int RegionStart; // eax
  char v10; // dl
  unsigned __int16 *encoded_value_with_base_1; // ebx
  char v12; // si
  unsigned __int16 *v13; // eax
  char *v14; // edx
  int v15; // esi
  int v16; // ecx
  int v17; // eax
  unsigned __int16 *v18; // esi
  int v19; // ebx
  int v20; // ecx
  int v21; // eax
  int IPInfo; // eax
  unsigned int v23; // edi
  char v24; // bl
  unsigned __int16 *v25; // eax
  unsigned int *v26; // eax
  char v27; // bl
  unsigned __int16 *v28; // esi
  unsigned __int16 *v29; // eax
  unsigned int *v30; // eax
  char v31; // bl
  unsigned __int16 *v32; // esi
  unsigned __int16 *v33; // eax
  int v34; // esi
  unsigned int v35; // [esp+14h] [ebp-44h] BYREF
  unsigned int v36; // [esp+18h] [ebp-40h] BYREF
  unsigned int v37; // [esp+1Ch] [ebp-3Ch] BYREF
  unsigned int v38; // [esp+20h] [ebp-38h] BYREF
  int v39; // [esp+24h] [ebp-34h]
  int v40; // [esp+28h] [ebp-30h] BYREF
  char *v41; // [esp+30h] [ebp-28h]
  unsigned int v42; // [esp+34h] [ebp-24h]
  char v43; // [esp+38h] [ebp-20h]
  char v44; // [esp+39h] [ebp-1Fh]

  result = 3;
  v35 = 0;
  if ( a2 == 1 )
  {
    if ( (a3 & 2) != 0 )
    {
      LanguageSpecificData = (char *)Unwind_GetLanguageSpecificData(a7);
      if ( LanguageSpecificData )
      {
        RegionStart = 0;
        if ( a7 )
          RegionStart = Unwind_GetRegionStart(a7);
        v39 = RegionStart;
        v10 = *LanguageSpecificData;
        encoded_value_with_base_1 = (unsigned __int16 *)(LanguageSpecificData + 1);
        if ( *LanguageSpecificData == -1 )
        {
          v40 = RegionStart;
        }
        else
        {
          v12 = *LanguageSpecificData;
          v13 = (unsigned __int16 *)base_of_encoded_value_0(v10, a7, a1);
          encoded_value_with_base_1 = (unsigned __int16 *)read_encoded_value_with_base_1(
                                                            v12,
                                                            v13,
                                                            encoded_value_with_base_1,
                                                            a1,
                                                            (unsigned int *)&v40);
        }
        v14 = (char *)encoded_value_with_base_1 + 1;
        v43 = *(_BYTE *)encoded_value_with_base_1;
        if ( v43 == -1 )
        {
          v41 = 0;
        }
        else
        {
          v15 = 0;
          v16 = 0;
          do
          {
            v17 = (*v14++ & 0x7F) << v16;
            v16 += 7;
            v15 |= v17;
          }
          while ( *(v14 - 1) < 0 );
          v41 = &v14[v15];
        }
        v18 = (unsigned __int16 *)(v14 + 1);
        v19 = 0;
        v20 = 0;
        v44 = *v14;
        do
        {
          v18 = (unsigned __int16 *)((char *)v18 + 1);
          v21 = (*((_BYTE *)v18 - 1) & 0x7F) << v20;
          v20 += 7;
          v19 |= v21;
        }
        while ( *((char *)v18 - 1) < 0 );
        v42 = (unsigned int)v18 + v19;
        IPInfo = Unwind_GetIPInfo(a7, &v35);
        v23 = (__PAIR64__(IPInfo, v35) - 1) >> 32;
        while ( v42 > (unsigned int)v18 )
        {
          v24 = v44;
          v25 = (unsigned __int16 *)base_of_encoded_value_0(v44, 0, a1);
          v26 = read_encoded_value_with_base_1(v24, v25, v18, a1, &v36);
          v27 = v44;
          v28 = (unsigned __int16 *)v26;
          v29 = (unsigned __int16 *)base_of_encoded_value_0(v44, 0, a1);
          v30 = read_encoded_value_with_base_1(v27, v29, v28, a1, &v37);
          v31 = v44;
          v32 = (unsigned __int16 *)v30;
          v33 = (unsigned __int16 *)base_of_encoded_value_0(v44, 0, a1);
          v18 = (unsigned __int16 *)read_encoded_value_with_base_1(v31, v33, v32, a1, &v38);
          do
            v18 = (unsigned __int16 *)((char *)v18 + 1);
          while ( *((char *)v18 - 1) < 0 );
          if ( v23 < v39 + v36 )
            break;
          if ( v23 < v37 + v39 + v36 )
          {
            if ( v38 )
            {
              v34 = v40 + v38;
              if ( v40 + v38 )
              {
                Unwind_SetGR(a1, a7, 0, a6);
                Unwind_SetGR(a1, a7, 2, 0);
                Unwind_SetIP(a7, v34);
                return 7;
              }
            }
            return 8;
          }
        }
      }
    }
    return 8;
  }
  return result;
}

//----- (080BB730) --------------------------------------------------------
int __cdecl dl_iterate_phdr(int (__cdecl *a1)(int *, int, int), int a2)
{
  _DWORD *v2; // edi
  int v3; // eax
  int v4; // eax
  int v5; // edx
  int v6; // edx
  __int64 v9; // [esp+8h] [ebp-54h]
  int v10[3]; // [esp+18h] [ebp-44h] BYREF
  __int16 v11; // [esp+24h] [ebp-38h]
  __int64 v12; // [esp+28h] [ebp-34h]
  __int64 v13; // [esp+30h] [ebp-2Ch]
  int addr_soft; // [esp+3Ch] [ebp-20h]

  v9 = (unsigned int)dword_80EBA44[0];
  if ( !dl_ns )
    return 0;
  v2 = dl_ns;
  while ( 1 )
  {
    v4 = v2[5];
    v10[0] = *(_DWORD *)v4;
    v5 = *(_DWORD *)(v4 + 4);
    v12 = dl_load_adds;
    v10[1] = v5;
    v6 = *(_DWORD *)(v4 + 336);
    addr_soft = 0;
    v13 = dl_load_adds - v9;
    v10[2] = v6;
    v11 = *(_WORD *)(v4 + 344);
    if ( *(_DWORD *)(v4 + 580) )
      addr_soft = dl_tls_get_addr_soft(v4);
    v3 = a1(v10, 40, a2);
    if ( v3 )
      break;
    v2 = (_DWORD *)v2[3];
    if ( !v2 )
      return 0;
  }
  return v3;
}
// 80EBA20: using guessed type __int64 dl_load_adds;
// 80EBA40: using guessed type void *dl_ns;
// 80EBA44: using guessed type int dword_80EBA44[];

//----- (080BB850) --------------------------------------------------------
int *__usercall free_mem@<eax>(long double a1@<st0>)
{
  int *i; // ebx
  int *result; // eax
  int v3; // ebx

  for ( i = (int *)nl_domain_bindings; nl_domain_bindings; i = (int *)nl_domain_bindings )
  {
    nl_domain_bindings = *i;
    if ( (char *)i[1] != "/usr/share/locale" )
      free(a1, i[1]);
    free(a1, i[2]);
    free(a1, (int)i);
  }
  if ( nl_current_default_domain != "messages" )
    free(a1, (int)nl_current_default_domain);
  tdestroy((_DWORD *)root, (long double (__cdecl *)(_DWORD))free);
  result = (int *)transmem_list;
  root = 0;
  if ( transmem_list )
  {
    do
    {
      transmem_list = *result;
      v3 = transmem_list;
      free(a1, (int)result);
      result = (int *)v3;
    }
    while ( v3 );
  }
  return result;
}
// 80EB06C: using guessed type char *nl_current_default_domain;
// 80EC1F4: using guessed type int transmem_list;
// 80EC1F8: using guessed type int root;
// 80ECC30: using guessed type int nl_domain_bindings;

//----- (080BB900) --------------------------------------------------------
void __usercall nl_finddomain_subfreeres(long double a1@<st0>)
{
  int *v1; // ebx
  int *v2; // eax
  int *v3; // esi

  v1 = (int *)nl_loaded_domains;
  if ( nl_loaded_domains )
  {
    while ( 1 )
    {
      v2 = (int *)v1[2];
      if ( v2 )
        nl_unload_domain(v2, a1);
      v3 = (int *)v1[3];
      free(a1, *v1);
      free(a1, (int)v1);
      if ( !v3 )
        break;
      v1 = v3;
    }
  }
}
// 80EC240: using guessed type int nl_loaded_domains;

//----- (080BB950) --------------------------------------------------------
_DWORD *__usercall nl_unload_domain@<eax>(int *a1@<eax>, long double a2@<st0>)
{
  _DWORD *v3; // eax
  int v4; // edi
  unsigned int i; // esi
  int *v6; // eax
  int *v7; // ebx
  int v8; // eax

  v3 = (_DWORD *)a1[24];
  if ( v3 != (_DWORD *)&_gettext_germanic_plural )
    _gettext_free_exp(v3);
  v4 = 0;
  for ( i = 0; a1[15] > i; v4 += 12 )
  {
    v7 = (int *)(v4 + a1[14]);
    free(a2, *v7);
    v8 = v7[2];
    if ( (unsigned int)(v8 - 1) <= 0xFFFFFFFD )
      free(a2, v8);
    v6 = (int *)v7[1];
    if ( v6 != (int *)-1 )
      _gconv_close(v6, a2);
    ++i;
  }
  free(a2, a1[14]);
  free(a2, a1[4]);
  if ( a1[1] )
    munmap(*a1, a1[2]);
  else
    free(a2, *a1);
  return free(a2, (int)a1);
}

//----- (080BBA40) --------------------------------------------------------
_DWORD *__usercall buffer_free@<eax>(long double a1@<st0>)
{
  int v1; // ebx
  _DWORD *result; // eax

  v1 = freeres_list;
  for ( dealloc_buffers = 1; v1; freeres_list = v1 )
  {
    result = free(a1, *(_DWORD *)(v1 + 96));
    v1 = *(_DWORD *)(v1 + 92);
  }
  return result;
}
// 80EC4AC: using guessed type int freeres_list;
// 80EC4B0: using guessed type char dealloc_buffers;

//----- (080BBA80) --------------------------------------------------------
_DWORD *__usercall free_derivation@<eax>(long double a1@<st0>, int a2)
{
  int v2; // edx
  unsigned int v3; // esi
  _DWORD *v4; // eax
  int v5; // ebx
  void (__cdecl *v6)(int); // ebx

  v2 = *(_DWORD *)(a2 + 8);
  if ( *(_DWORD *)(a2 + 12) )
  {
    v3 = 0;
    do
    {
      v4 = (_DWORD *)(v2 + 60 * v3);
      if ( (int)v4[2] > 0 )
      {
        v5 = v4[8];
        if ( v5 )
        {
          if ( !*v4 )
            _assert_fail(a1, (int)"deriv->steps[cnt].__shlib_handle != NULL", (int)"gconv_db.c", 185, "free_derivation");
          v6 = (void (__cdecl *)(int))(__readgsdword(0x18u) ^ __ROR4__(v5, 9));
          dl_mcount_wrapper_check((int)v6);
          v6(*(_DWORD *)(a2 + 8) + 60 * v3);
          v2 = *(_DWORD *)(a2 + 8);
        }
      }
      ++v3;
    }
    while ( *(_DWORD *)(a2 + 12) > v3 );
  }
  if ( v2 )
  {
    free(a1, *(_DWORD *)(v2 + 12));
    free(a1, *(_DWORD *)(*(_DWORD *)(a2 + 8) + 60 * *(_DWORD *)(a2 + 12) - 44));
    free(a1, *(_DWORD *)(a2 + 8));
  }
  return free(a1, a2);
}

//----- (080BBB40) --------------------------------------------------------
_DWORD *__usercall free_modules_db@<eax>(_DWORD *a1@<eax>, long double a2@<st0>)
{
  _DWORD *v2; // ebx
  _DWORD *result; // eax
  int v4; // esi
  int v5; // [esp-10h] [ebp-1Ch]

  v2 = a1;
  if ( a1[5] )
    free_modules_db();
  if ( v2[7] )
    free_modules_db();
  do
  {
    while ( 1 )
    {
      result = (_DWORD *)v2[4];
      v4 = v2[6];
      if ( *(_BYTE *)result == 47 )
        break;
      v2 = (_DWORD *)v2[6];
      if ( !v4 )
        return result;
    }
    v5 = (int)v2;
    v2 = (_DWORD *)v2[6];
    result = free(a2, v5);
  }
  while ( v4 );
  return result;
}

//----- (080BBBA0) --------------------------------------------------------
_DWORD *__usercall free_mem_0@<eax>(long double a1@<st0>)
{
  _DWORD *result; // eax

  nl_locale_subfreeres(a1);
  nl_finddomain_subfreeres(a1);
  if ( _gconv_alias_db )
    tdestroy((_DWORD *)_gconv_alias_db, (long double (__cdecl *)(_DWORD))free);
  if ( _gconv_modules_db )
    free_modules_db((_DWORD *)_gconv_modules_db, a1);
  result = (_DWORD *)known_derivations;
  if ( known_derivations )
    return tdestroy((_DWORD *)known_derivations, (long double (__cdecl *)(_DWORD))free_derivation);
  return result;
}
// 80EC5AC: using guessed type int known_derivations;
// 80ECCD4: using guessed type int _gconv_modules_db;
// 80ECCDC: using guessed type int _gconv_alias_db;

//----- (080BBC00) --------------------------------------------------------
_DWORD *__usercall free_mem_1@<eax>(long double a1@<st0>)
{
  _DWORD *result; // eax

  result = (_DWORD *)_gconv_path_elem;
  if ( (_UNKNOWN *)_gconv_path_elem != &empty_path_elem )
  {
    if ( _gconv_path_elem )
      return free(a1, _gconv_path_elem);
  }
  return result;
}
// 80ECCE8: using guessed type int _gconv_path_elem;

//----- (080BBC20) --------------------------------------------------------
_DWORD *__usercall free_mem_2@<eax>(long double a1@<st0>)
{
  _DWORD *result; // eax

  if ( cache_malloced )
    return free(a1, gconv_cache);
  result = (_DWORD *)gconv_cache;
  if ( gconv_cache )
    return (_DWORD *)munmap(gconv_cache, cache_size);
  return result;
}
// 80EC5B8: using guessed type int cache_malloced;
// 80EC5BC: using guessed type int cache_size;
// 80EC5C0: using guessed type int gconv_cache;

//----- (080BBC70) --------------------------------------------------------
_DWORD *__usercall do_release_all@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, long double a4@<st0>, int a5)
{
  if ( *(_DWORD *)(a5 + 8) )
    _libc_dlclose(a1, a2, a3, *(_DWORD *)(a5 + 8));
  return free(a4, a5);
}

//----- (080BBCA0) --------------------------------------------------------
_DWORD *free_mem_3()
{
  _DWORD *result; // eax

  result = tdestroy((_DWORD *)loaded, (long double (__cdecl *)(_DWORD))do_release_all);
  loaded = 0;
  return result;
}
// 80EC5C8: using guessed type int loaded;

//----- (080BBCD0) --------------------------------------------------------
void **__usercall free_category@<eax>(void **result@<eax>, void **a2@<edx>, void **a3@<ecx>, long double a4@<st0>)
{
  int *v5; // ebx
  void **v6; // esi
  void (__cdecl *v7)(); // eax
  void **v8; // esi
  int *v9; // eax
  int *v10; // esi

  v5 = (int *)nl_locale_file_list[(_DWORD)result];
  if ( a2 != a3 )
  {
    v6 = result;
    if ( nl_current_used[(_DWORD)result] )
    {
      v7 = (void (__cdecl *)())nl_category_postload[(_DWORD)result];
      nl_global_locale[(_DWORD)v6] = a3;
      if ( v7 )
        v7();
    }
    v8 = v6 + 4;
    result = nl_global_locale[(_DWORD)v8];
    if ( result != (void **)&nl_C_name )
    {
      result = (void **)free(a4, (int)nl_global_locale[(_DWORD)v8]);
      nl_global_locale[(_DWORD)v8] = (void **)&nl_C_name;
    }
  }
  if ( v5 )
  {
    while ( 1 )
    {
      v9 = (int *)v5[2];
      if ( v9 )
      {
        if ( a3 != (void **)v9 )
          nl_unload_locale(v9, a4);
      }
      v10 = (int *)v5[3];
      free(a4, *v5);
      result = (void **)free(a4, (int)v5);
      if ( !v10 )
        break;
      v5 = v10;
    }
  }
  return result;
}
// 80C0240: using guessed type int (*nl_category_postload[12])();
// 80C0340: using guessed type int nl_current_used[13];
// 80EBEA0: using guessed type void **nl_global_locale[6];
// 80ECD00: using guessed type int nl_locale_file_list[13];

//----- (080BBD70) --------------------------------------------------------
int __usercall nl_locale_subfreeres@<eax>(long double a1@<st0>)
{
  free_category(0, *(void ***)__readgsdword(0xFFFFFFD8), &nl_C_LC_CTYPE, a1);
  free_category((void **)4, *(void ***)__readgsdword(0xFFFFFFE0), &nl_C_LC_MONETARY, a1);
  free_category((void **)1, *(void ***)__readgsdword(0xFFFFFFE4), &nl_C_LC_NUMERIC, a1);
  if ( off_80EBEF8 != &nl_C_name )
  {
    free(a1, (int)off_80EBEF8);
    off_80EBEF8 = &nl_C_name;
  }
  return nl_archive_subfreeres(a1);
}
// 80C0B60: using guessed type void *nl_C_LC_CTYPE;
// 80CF860: using guessed type void *nl_C_LC_MONETARY;
// 80CF960: using guessed type void *nl_C_LC_NUMERIC;
// 80EBEF8: using guessed type void *off_80EBEF8;

//----- (080BBF40) --------------------------------------------------------
int __usercall nl_archive_subfreeres@<eax>(long double a1@<st0>)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi
  int v3; // ebx
  int v4; // eax
  void (*v5)(void); // edx
  int result; // eax
  int *v7; // ebx
  int *v8; // esi
  int v9; // [esp+0h] [ebp-1Ch]
  int v10; // [esp+0h] [ebp-1Ch]

  v1 = (_DWORD *)archloaded;
  if ( archloaded )
  {
    do
    {
      v2 = (_DWORD *)*v1;
      v3 = 1;
      free(a1, v1[1]);
      while ( 1 )
      {
        if ( v3 != 7 )
        {
          v4 = v1[v3 + 1];
          if ( v4 )
          {
            v5 = *(void (**)(void))(v4 + 16);
            if ( v5 )
            {
              v5();
              v4 = v1[v3 + 1];
            }
            free(a1, v4);
          }
          if ( v3 == 13 )
            break;
        }
        ++v3;
      }
      v9 = (int)v1;
      v1 = v2;
      free(a1, v9);
    }
    while ( v2 );
  }
  result = archmapped;
  archloaded = 0;
  if ( archmapped )
  {
    if ( (int *)archmapped != &headmap )
      _assert_fail(a1, (int)"archmapped == &headmap", (int)"loadarchive.c", 535, "_nl_archive_subfreeres");
    archmapped = 0;
    result = munmap(headmap, dword_80EC688);
    v7 = (int *)dword_80EC68C;
    if ( dword_80EC68C )
    {
      do
      {
        v8 = (int *)v7[3];
        munmap(*v7, v7[2]);
        v10 = (int)v7;
        v7 = v8;
        result = (int)free(a1, v10);
      }
      while ( v8 );
    }
  }
  return result;
}
// 80EC600: using guessed type int archloaded;
// 80EC680: using guessed type int headmap;
// 80EC688: using guessed type int dword_80EC688;
// 80EC68C: using guessed type int dword_80EC68C;
// 80EC690: using guessed type int archmapped;

//----- (080BC040) --------------------------------------------------------
_DWORD *__usercall free_mem_4@<eax>(long double a1@<st0>)
{
  _DWORD *result; // eax

  clearenv(a1);
  result = tdestroy((_DWORD *)known_values, (long double (__cdecl *)(_DWORD))free);
  known_values = 0;
  return result;
}
// 80EC698: using guessed type int known_values;

//----- (080BC070) --------------------------------------------------------
void __usercall free_mem_5(long double a1@<st0>)
{
  int v1; // edx
  int i; // esi
  _DWORD *v3; // eax
  _DWORD *v4; // ebx

  v1 = _printf_modifier_table;
  if ( _printf_modifier_table )
  {
    for ( i = 0; i != 1020; i += 4 )
    {
      v3 = *(_DWORD **)(v1 + i);
      if ( v3 )
      {
        do
        {
          v4 = (_DWORD *)*v3;
          free(a1, (int)v3);
          v3 = v4;
        }
        while ( v4 );
        v1 = _printf_modifier_table;
      }
    }
    free(a1, v1);
  }
}
// 80ECD38: using guessed type int _printf_modifier_table;

//----- (080BC0D0) --------------------------------------------------------
_DWORD *__usercall free_mem_6@<eax>(long double a1@<st0>)
{
  int *v1; // eax
  int v2; // ebx
  _DWORD *result; // eax

  v1 = (int *)tzstring_list;
  if ( tzstring_list )
  {
    do
    {
      tzstring_list = *v1;
      v2 = tzstring_list;
      free(a1, (int)v1);
      v1 = (int *)v2;
    }
    while ( v2 );
  }
  result = free(a1, old_tz);
  old_tz = 0;
  return result;
}
// 80EC6EC: using guessed type int old_tz;
// 80EC6F0: using guessed type int tzstring_list;

//----- (080BC120) --------------------------------------------------------
int __usercall free_slotinfo@<eax>(int *a1@<eax>, long double a2@<st0>)
{
  int result; // eax
  int v4; // ecx
  int v5; // ebx
  int v6; // edx
  unsigned __int8 v7; // [esp+1h] [ebp-Dh]

  if ( !*a1 )
    return 1;
  result = free_slotinfo();
  if ( (_BYTE)result )
  {
    v4 = *a1;
    v5 = *(_DWORD *)*a1;
    if ( v5 )
    {
      if ( *(_DWORD *)(v4 + 12) )
        return 0;
      v6 = 0;
      while ( ++v6 != v5 )
      {
        if ( *(_DWORD *)(v4 + 8 * v6 + 12) )
          return 0;
      }
    }
    v7 = result;
    free(a2, v4);
    result = v7;
    *a1 = 0;
  }
  return result;
}

//----- (080BC1A0) --------------------------------------------------------
_DWORD *__usercall free_mem_7@<eax>(long double a1@<st0>)
{
  _DWORD *v1; // eax
  _DWORD *v2; // ebx
  _DWORD *v3; // esi
  int v4; // edx
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v9; // edx

  v1 = (_DWORD *)dl_all_dirs;
  if ( dl_all_dirs != dl_init_all_dirs )
  {
    do
    {
      v2 = (_DWORD *)*v1;
      free(a1, (int)v1);
      v1 = v2;
    }
    while ( (_DWORD *)dl_init_all_dirs != v2 );
  }
  if ( dl_nns )
  {
    v3 = dl_ns;
    if ( dl_ns )
    {
      do
      {
        v4 = v3[7];
        v5 = *(_DWORD *)(v4 + 4);
        *(_DWORD *)(v4 + 4) = 0;
        if ( v5 )
        {
          do
          {
            while ( 1 )
            {
              v6 = *(_DWORD *)(v5 + 4);
              if ( !*(_DWORD *)(v5 + 8) )
                break;
              v5 = *(_DWORD *)(v5 + 4);
              if ( !v6 )
                goto LABEL_10;
            }
            free(a1, v5);
            v5 = v6;
          }
          while ( v6 );
        }
LABEL_10:
        if ( (*((_BYTE *)v3 + 406) & 1) != 0 )
          free(a1, v3[124]);
        v3[124] = 0;
        v3 = (_DWORD *)v3[3];
      }
      while ( v3 );
    }
    if ( dword_80EBA4C[0] && off_80EBA48[1] == (void **)dword_80EBA14 )
    {
      v9 = (int)*off_80EBA48;
      *off_80EBA48 = dl_initial_searchlist;
      dword_80EBA4C[0] = 0;
      free(a1, v9);
    }
  }
  free_slotinfo((int *)(dl_tls_dtv_slotinfo_list + 4), a1);
  v7 = dl_scope_free_list;
  dl_scope_free_list = 0;
  return free(a1, v7);
}
// 80EBA10: using guessed type void **dl_initial_searchlist;
// 80EBA14: using guessed type int dword_80EBA14;
// 80EBA28: using guessed type int dl_nns;
// 80EBA40: using guessed type void *dl_ns;
// 80EBA48: using guessed type void ***off_80EBA48;
// 80EBA4C: using guessed type int dword_80EBA4C[];
// 80ECC20: using guessed type int dl_tls_dtv_slotinfo_list;
// 80ECC94: using guessed type int dl_scope_free_list;
// 80ECCA8: using guessed type int dl_init_all_dirs;
// 80ECCBC: using guessed type int dl_all_dirs;

//----- (080BC2C0) --------------------------------------------------------
int __usercall arena_thread_freeres@<eax>(long double a1@<st0>)
{
  int result; // eax
  unsigned int v2; // edx
  bool v4; // zf
  int v5; // eax

  result = -20;
  v2 = __readgsdword(0xFFFFFFEC);
  __writegsdword(0xFFFFFFEC, 0);
  if ( v2 )
  {
    _ECX = 1;
    v4 = __readgsdword(0xCu) == 0;
    if ( !v4 )
      __asm { lock }
    __asm { cmpxchg ds:free_list_lock, ecx }
    if ( !v4 )
      _lll_lock_wait_private(0, &free_list_lock);
    v5 = *(_DWORD *)(v2 + 1096);
    if ( !v5 )
      _malloc_assert((int)"a->attached_threads > 0", (unsigned int)"arena.c", 923, a1, "arena_thread_freeres");
    result = v5 - 1;
    *(_DWORD *)(v2 + 1096) = result;
    if ( !result )
    {
      result = free_list;
      free_list = v2;
      *(_DWORD *)(v2 + 1092) = result;
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --free_list_lock )
      return _lll_unlock_wake_private(&free_list_lock);
  }
  return result;
}
// 80BC2F9: variable 'v2' is possibly undefined
// 80EC50C: using guessed type int free_list;
// 80EC510: using guessed type int free_list_lock;

//----- (080BC360) --------------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=927 queued=899 decompiled=899 lumina nreq=0 worse=0 better=0
// ALL OK, 899 function(s) have been successfully decompiled
