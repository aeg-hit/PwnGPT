/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

void (*init_proc())(void);
int __cdecl stpcpy(_DWORD, _DWORD); // weak
char *strcpy(char *dest, const char *src);
int __cdecl strnlen(_DWORD, _DWORD); // weak
void *memmove(void *dest, const void *src, size_t n);
int __cdecl rawmemchr(_DWORD, _DWORD); // weak
size_t wcslen(const wchar_t *s);
char *strrchr(const char *s, int c);
void *memchr(const void *s, int c, size_t n);
char *strstr(const char *haystack, const char *needle);
char *strncpy(char *dest, const char *src, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);
int __cdecl strcasecmp_l(_DWORD, _DWORD, _DWORD); // weak
wchar_t *wcschr(const wchar_t *wcs, wchar_t wc);
void *memset(void *s, int c, size_t n);
int strcmp(const char *s1, const char *s2);
int __cdecl strncasecmp_l(_DWORD, _DWORD, _DWORD, _DWORD); // weak
char *strchr(const char *s, int c);
// char *__userpurge group_number@<eax>(char *a1@<eax>, int a2@<edx>, char *a3@<ecx>, const char *a4);
// _BYTE *__usercall i18n_number_rewrite@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>);
// _BYTE *__usercall i18n_number_rewrite_0@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall is_trusted_path_normalize@<eax>(char *a1@<eax>, int a2@<edx>);
// __int64 __usercall print_search_path@<edx:eax>(_DWORD *a1@<eax>, const char *a2@<edx>, const char *a3@<ecx>);
// _BYTE *__usercall strip@<eax>(_BYTE *result@<eax>, char *a2@<edx>);
// _BYTE *__userpurge group_number_0@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>, _BYTE *a3@<ecx>, int a4);
// _BYTE *__usercall i18n_number_rewrite_1@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>);
// void __usercall fini(long double a1@<st0>);
unsigned int init_cacheinfo();
// void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>);
void _do_global_dtors_aux();
int frame_dummy();
// int __usercall exec_the_string@<eax>(long double a1@<st0>);
int __cdecl call_me_with_cafebabe(int a1);
int __cdecl call_me_with_two_args(int a1, int a2);
int vulnerable_function();
unsigned int __fastcall be_nice_to_people(int a1);
int __cdecl main(int argc, const char **argv, const char **envp);
int __cdecl _libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __usercall check_one_fd@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ebp>);
// int __usercall _libc_check_standard_fds@<eax>(int a1@<ebp>);
void __cdecl __noreturn _libc_setup_tls(int a1, unsigned int a2);
int dl_tls_setup();
void __noreturn _pthread_initialize_minimal();
void _libc_csu_irel();
void _libc_csu_init(void); // idb
void _libc_csu_fini(void); // idb
int setjmp(jmp_buf env);
// void __usercall __noreturn _run_exit_handlers(long double a1@<st0>, int status, _DWORD **a3, char a4);
// void __usercall __noreturn exit(long double a1@<st0>, int a2);
// void __usercall _new_exitfn(int a1@<ebp>, long double a2@<st0>, _DWORD *a3);
// int __usercall _internal_atexit@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, int a5, _DWORD *a6);
int __cdecl _cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle);
// void __usercall L_lock_22(int a1@<eax>);
void L_unlock_125();
// int __usercall _libc_message@<eax>(long double a1@<st0>, int a2, char *a3, ...);
void __cdecl __noreturn _libc_fatal(const char *a1);
void ptmalloc_lock_all();
void ptmalloc_unlock_all2();
// int __usercall mem2mem_check@<eax>(int result@<eax>, unsigned int a2@<edx>);
// unsigned int __usercall mem2chunk_check@<eax>(int a1@<eax>, _DWORD *a2@<edx>);
// void __usercall __noreturn _malloc_assert(const char *a1@<eax>, const char *a2@<edx>, int a3@<ecx>, long double a4@<st0>, const char *a5);
// int __usercall new_heap@<eax>(unsigned int a1@<eax>, int a2@<edx>);
// void __usercall mi_arena_10548(int *a1@<eax>, _DWORD *a2@<ecx>);
// int *__usercall mremap_chunk@<eax>(int *result@<eax>, int a2@<edx>);
void ptmalloc_unlock_all();
// int __usercall sYSTRIm_isra_1@<eax>(int a1@<eax>, int *a2@<edx>, _DWORD *a3@<ecx>);
// int __usercall malloc_printerr@<eax>(char a1@<al>, const char *a2@<edx>, unsigned int a3@<ecx>, long double a4@<st0>);
int top_check();
// int *__usercall malloc_consolidate@<eax>(int *a1@<eax>);
// int *__usercall mALLINFo@<eax>(int *a1@<eax>, int *a2@<edx>);
// int __usercall munmap_chunk@<eax>(_DWORD *a1@<eax>, long double a2@<st0>);
// void __usercall int_free(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>);
// void *__usercall int_malloc@<eax>(int *a1@<eax>, size_t a2@<edx>, long double a3@<st0>);
void __cdecl malloc_check(unsigned int a1);
// int __usercall int_memalign@<eax>(int *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>);
void __cdecl memalign_check(unsigned int a1, unsigned int a2);
// unsigned int __usercall int_realloc@<eax>(int *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, unsigned int a4);
void __cdecl free_atfork(int a1);
void __cdecl free_check(int a1);
// void __usercall realloc_check(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, _BYTE *a5, unsigned int a6);
void __fastcall arena_get2(int _ECX, int a2);
int _malloc_check_init();
int (*ptmalloc_init())(void);
// void __usercall mALLOPt(int a1@<eax>, int a2@<edx>);
// void __usercall malloc_set_state(long double a1@<st0>, _DWORD *a2);
// void __usercall malloc(long double a1@<st0>, size_t a2);
void __cdecl malloc_atfork(unsigned int a1);
int __cdecl malloc_hook_ini(int a1);
// void __usercall malloc_get_state(long double a1@<st0>);
// void __usercall free(long double a1@<st0>, int a2);
void __cdecl realloc(_BYTE *a1, unsigned int a2);
int __cdecl realloc_hook_ini(int a1, int a2);
void __cdecl memalign(unsigned int a1, unsigned int a2);
int __cdecl memalign_hook_ini(int a1, int a2);
// void __usercall valloc(long double a1@<st0>, unsigned int a2);
// void __usercall pvalloc(long double a1@<st0>, int a2);
void __cdecl calloc(int a1, unsigned int a2);
// void __usercall malloc_trim(long double a1@<st0>, int a2);
unsigned int __cdecl malloc_usable_size(int a1);
void malloc_stats();
void __stdcall mallinfo(int *a1);
void __cdecl mallopt(int a1, int a2);
int __cdecl posix_memalign(int *a1, unsigned int a2, unsigned int a3);
int __cdecl malloc_info(int a1, int a2);
// void __usercall L_lock_33(int a1@<eax>);
// void __usercall L_lock_50(int a1@<eax>, volatile __int32 *a2@<edx>);
// void __usercall L_lock_929(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_1146(_DWORD *a1);
void __fastcall L_unlock_1541(int a1, _DWORD *a2);
void L_unlock_1550();
// void __usercall L_lock_3402(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_3551(int a1, _DWORD *a2);
// void __usercall L_lock_3877(int a1@<eax>, volatile __int32 *a2@<ebp>);
void __fastcall L_unlock_3891(_DWORD *a1);
void __fastcall L_unlock_3935(int a1, _DWORD *a2);
// void __usercall L_lock_7025(int a1@<eax>);
void L_unlock_7042();
// void __usercall L_lock_7415(int a1@<eax>);
void L_unlock_7433();
// void __usercall L_lock_8098(int a1@<eax>);
void L_unlock_8121();
void L_unlock_8139();
void L_unlock_8155();
// void __usercall L_lock_8199(int a1@<eax>);
void L_unlock_8210();
// void __usercall L_lock_8242(int a1@<eax>);
void L_unlock_8280();
// void __usercall L_lock_8453(int a1@<eax>);
void L_unlock_8466();
// void __usercall L_lock_8474(int a1@<eax>, volatile __int32 *a2@<ebx>);
// void __usercall L_lock_8634(int a1@<eax>, volatile __int32 *a2@<ebx>);
// void __usercall L_lock_8829(int a1@<eax>, volatile __int32 *a2@<ebx>);
// void __usercall L_lock_8834(int a1@<eax>);
void L_unlock_8841();
// void __usercall L_lock_9436(int a1@<eax>);
void L_unlock_9453();
// void __usercall L_lock_9599(int a1@<eax>);
void L_unlock_9894();
// void __usercall L_lock_10019(int a1@<eax>, volatile __int32 *a2@<edi>);
// void __usercall L_unlock_10041(_DWORD *a1@<edi>);
// void __usercall L_unlock_10098(_DWORD *a1@<edi>);
// void __usercall L_lock_10105(int a1@<eax>);
void L_unlock_10114();
void L_unlock_10171();
// void __usercall L_unlock_10190(_DWORD *a1@<edi>);
// void __usercall L_lock_10248(int a1@<eax>);
void L_unlock_10251();
// void __usercall L_lock_10365(int a1@<eax>);
void L_unlock_10447();
// void __usercall L_lock_10645(int a1@<eax>, volatile __int32 *a2@<esi>);
// void __usercall L_unlock_10658(_DWORD *a1@<esi>);
// void __usercall L_lock_10980(int a1@<eax>, volatile __int32 *a2@<edi>);
// void __usercall L_unlock_11003(_DWORD *a1@<edi>);
// void __usercall L_unlock_11078(_DWORD *a1@<edi>);
// void __usercall L_lock_11085(int a1@<eax>);
void L_unlock_11095();
void L_unlock_11163();
// void __usercall L_unlock_11183(_DWORD *a1@<edi>);
// void __usercall L_lock_11280(int a1@<eax>, volatile __int32 *a2@<esi>);
// void __usercall L_unlock_11320(_DWORD *a1@<esi>);
// void __usercall L_unlock_11397(_DWORD *a1@<esi>);
// void __usercall L_lock_11403(int a1@<eax>);
void L_unlock_11412();
void L_unlock_11486();
// void __usercall L_unlock_11505(_DWORD *a1@<esi>);
// void __usercall L_lock_11594(int a1@<eax>, volatile __int32 *a2@<esi>);
// void __usercall L_unlock_11640(_DWORD *a1@<esi>);
// void __usercall L_unlock_11718(_DWORD *a1@<esi>);
// void __usercall L_lock_11724(int a1@<eax>);
void L_unlock_11733();
void L_unlock_11811();
// void __usercall L_unlock_11831(_DWORD *a1@<esi>);
// void __usercall L_lock_11918(int a1@<eax>, volatile __int32 *a2@<edi>);
// void __usercall L_unlock_11987(_DWORD *a1@<edi>);
// void __usercall L_unlock_12108(_DWORD *a1@<edi>);
// void __usercall L_lock_12114(int a1@<eax>);
void L_unlock_12123();
void L_unlock_12214();
// void __usercall L_unlock_12233(_DWORD *a1@<edi>);
// void __usercall L_lock_12371(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_12552(int a1, _DWORD *a2);
// void __usercall L_lock_12841(int a1@<eax>, volatile __int32 *a2@<ebx>);
// void __usercall L_unlock_12879(_DWORD *a1@<ebx>);
// void __userpurge L_lock_12970(int a1@<eax>, int a2);
void __stdcall L_unlock_12976(int a1);
int __cdecl _default_morecore(int a1);
int __cdecl strlen(_BYTE *a1);
int (__cdecl *memcmp())(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl _memcmp_ia32(unsigned int *a1, unsigned int *a2, int a3);
int (__cdecl *memset())(int a1, unsigned __int8 a2, unsigned int a3);
unsigned __int8 *__cdecl _memset_ia32(unsigned __int8 *a1, unsigned __int8 a2, unsigned int a3);
_WORD *__cdecl mempcpy(_BYTE *a1, _BYTE *a2, unsigned int a3);
_BYTE *__cdecl memcpy(_BYTE *a1, _BYTE *a2, unsigned int a3);
unsigned int *__cdecl strchrnul(unsigned int *a1, int a2);
int __cdecl _memset_sse2(int a1, unsigned __int8 a2, unsigned int a3);
int __cdecl _memset_sse2_rep(int a1, unsigned __int8 a2, unsigned int a3);
int __cdecl _memcmp_ssse3(const __m128i *a1, const __m128i *a2, unsigned int a3);
int __cdecl _memcmp_sse4_2(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl intel_02_known_compare(_BYTE *a1, _BYTE *a2);
// int __usercall handle_amd@<eax>(int a1@<eax>);
// int __usercall intel_check_word@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, _BYTE *a4);
// int __usercall handle_intel@<eax>(int a1@<eax>, unsigned int a2@<edx>);
int __cdecl _cache_sysconf(int a1);
void exit(int status);
// int __usercall execlp@<eax>(long double a1@<st0>, char *a2, int a3, int a4, int a5);
__int64 __fastcall getegid(int a1);
unsigned int __cdecl setresgid(int a1, int a2);
int __cdecl _exit_thread(int a1, int a2, int a3);
unsigned int __cdecl _fxstat64(int a1, int a2, int a3);
// int __usercall open@<eax>(int ebp0@<ebp>, int a1, int a2);
unsigned int __cdecl _open_nocancel(int a1, int a2);
// int __usercall read@<eax>(int ebp0@<ebp>, int a1, int a2);
unsigned int __cdecl _read_nocancel(int a1, int a2);
// int __usercall write@<eax>(int a1@<ebp>, int a2, int a3, int a4);
unsigned int __cdecl _write_nocancel(int a1, int a2);
unsigned int __cdecl _fcntl_nocancel(int a1, int a2);
// unsigned int __usercall fcntl@<eax>(int a1@<ebp>, int a2, int a3);
int __cdecl sbrk(int a1);
void cancel_handler();
// char *__usercall openlog_internal@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebp>);
// int __usercall closelog_internal@<eax>(int a1@<ebp>);
// void __usercall _vsyslog_chk(long double a1@<st0>, int a2, int a3, int a4, int a5);
// void __usercall _syslog_chk(long double a1@<st0>, int a2, int a3, int a4, ...);
int syslog(int a1, int a2, ...);
// void __usercall vsyslog(long double a1@<st0>, int a2, int a3, int a4);
// void __usercall openlog(int a1@<ebp>, int a2, int a3, int a4);
// void __usercall closelog(int a1@<ebp>);
int __cdecl setlogmask(int a1);
void L_unlock_7();
// void __usercall L_lock_498(int a1@<eax>);
void L_unlock_527();
// void __usercall L_lock_999(int a1@<eax>);
// void __usercall L_lock_1062(int a1@<eax>);
unsigned int __cdecl mmap(int a1, int a2, int a3, int a4, int a5, __int16 a6);
unsigned int __cdecl munmap(int a1, int a2);
unsigned int __cdecl mprotect(int a1, int a2);
unsigned int __cdecl madvise(int a1, int a2);
// int __usercall phys_pages_info@<eax>(unsigned __int8 *a1@<eax>, long double a2@<st0>);
// char *__usercall next_line@<eax>(int a1@<eax>, char *a2@<edx>, const void **a3@<ecx>, int *a4, int a5);
int __fastcall get_nprocs(int a1);
int get_nprocs_conf();
// int __usercall get_phys_pages@<eax>(long double a1@<st0>);
// int __usercall get_avphys_pages@<eax>(long double a1@<st0>);
void __cdecl _init_misc(int a1, const char **a2);
unsigned int __cdecl mremap(int a1, int a2);
// unsigned int __usercall connect@<eax>(int a1@<ebp>, char a2);
// unsigned int __usercall send@<eax>(int a1@<ebp>, char a2);
unsigned int __cdecl socket(char a1);
_BOOL4 __cdecl _libc_alloca_cutoff(unsigned int a1);
// __int32 __usercall _lll_lock_wait_private@<eax>(int a1@<eax>, volatile __int32 *a2@<ecx>);
// int __usercall _lll_unlock_wake_private@<eax>(_DWORD *a1@<eax>);
int _libc_enable_asynccancel();
// int __usercall _libc_disable_asynccancel@<eax>(int result@<eax>, int a2@<ebp>);
void __cdecl _register_atfork(int a1, int a2, int a3, int a4);
int __cdecl _linkin_atfork(_DWORD *a1);
// void __usercall L_lock_83(int a1@<eax>);
void L_unlock_178();
void __cdecl _vfprintf_chk(_DWORD *a1, int a2, int a3, int a4);
// void __usercall L_lock_34(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_97(int a1, _DWORD *a2);
void __noreturn L_unlock_140(); // weak
int __cdecl backtrace_helper(int a1, _DWORD *a2);
int __cdecl backtrace(int a1, int a2);
unsigned int __cdecl backtrace_symbols_fd(int a1, int a2, int a3);
void dl_sysinfo_int80();
// int __usercall dl_aux_init@<eax>(int result@<eax>);
// char *__usercall dl_non_dynamic_init@<eax>(long double a1@<st0>);
int *__thiscall dl_important_hwcaps(_DWORD *this, int a2);
// int __usercall dl_addr_inside_object@<eax>(int a1@<eax>, int a2@<edx>);
// int __userpurge dl_addr@<eax>(unsigned int a1@<eax>, _DWORD *a2@<edx>, int *a3@<ecx>, _DWORD *a4);
int __fastcall _libc_init_secure(int a1);
int __fastcall dl_discover_osversion(int a1);
// int __usercall _libc_init_first@<eax>(long double a1@<st0>, int a2, const char **a3, char **a4);
void __fastcall __noreturn dl_start(int a1, int a2);
// int __usercall _syscall_error@<eax>(int a1@<eax>);
unsigned int _init_cpu_features();
int *_get_cpu_features();
// void __usercall __noreturn _assert_fail_base(int a1@<ebp>, long double a2@<st0>, int a3, int a4, int a5, int a6, void *a7);
// void __usercall __noreturn _assert_fail(int a1@<ebp>, long double a2@<st0>, int a3, int a4, int a5, void *a6);
unsigned int _ctype_b_loc();
unsigned int _ctype_toupper_loc();
unsigned int _ctype_tolower_loc();
int _ctype_init();
// char *__usercall dcgettext@<eax>(long double a1@<st0>, char *s1, char *a3, int a4);
// int __usercall plural_eval@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>);
// unsigned int __userpurge plural_lookup@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
int __cdecl transcmp(int a1, int a2);
// void __userpurge nl_find_msg(int *a1@<eax>, int a2@<edx>, char *a3@<ecx>, int a4, unsigned __int32 *a5);
// char *__usercall _dcigettext@<eax>(long double a1@<st0>, char *s1, char *a3, char *a4, int a5, int a6, unsigned int a7);
// void __userpurge L_lock_1296(int a1@<eax>, int a2, int a3);
void __stdcall L_unlock_1444(int a1, int a2);
void __stdcall L_unlock_1520(int a1, int a2);
void __stdcall L_unlock_1533(int a1, int a2);
// void __userpurge L_lock_2131(int a1@<eax>, int a2, int a3);
void __stdcall L_unlock_2138(int a1, int a2);
// int *__userpurge nl_find_domain@<eax>(_BYTE *a1@<eax>, int a2@<edx>, char *a3@<ecx>, long double a4@<st0>, int a5);
// void __usercall nl_load_domain(int *a1@<eax>, int a2@<edx>);
// void __usercall L_lock_33_0(int a1@<eax>);
void L_unlock_68();
// int __usercall read_alias_file@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>, long double a3@<st0>);
int __cdecl alias_compare(_DWORD *a1, _DWORD *a2);
// void __usercall nl_expand_alias(long double a1@<st0>, int a2);
// void __usercall L_lock_570(int a1@<eax>);
void L_unlock_649();
const char **__cdecl nl_make_l10nflist(const char ***a1, _BYTE *a2, int a3, int a4, _BYTE *a5, _BYTE *a6, _BYTE *a7, _BYTE *a8, _BYTE *a9, char *src, int a11);
_DWORD *__cdecl nl_normalize_codeset(int a1, int a2);
int __cdecl nl_explode_name(_BYTE *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, const char **a5, const char **a6);
// _DWORD *__usercall _gettext_free_exp@<eax>(_DWORD *result@<eax>);
// _DWORD *__usercall new_exp@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// _DWORD *__usercall new_exp_2@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
int __cdecl _gettextparse(_DWORD); // weak
// char *__usercall _gettext_extract_plural@<eax>(char *result@<eax>, char **a2@<edx>, _DWORD *a3@<ecx>);
int __cdecl _hash_string(unsigned __int8 *a1);
unsigned int __cdecl _setfpucw(unsigned __int16 a1);
void __fastcall __noreturn abort(_DWORD, _DWORD); // weak
// void __usercall __noreturn L_lock_19_0(int a1@<eax>);
void __noreturn L_unlock_142(void); // weak
// void __usercall __noreturn L_lock_161(int a1@<eax>);
int __cdecl bsearch(int a1, int a2, unsigned int a3, int a4, int (__cdecl *a5)(int, int));
// _BYTE *__usercall msort_with_tmp_part_0@<eax>(unsigned int *a1@<eax>, int *a2@<edx>, unsigned int a3@<ecx>);
// unsigned int __usercall qsort_r@<eax>(long double a1@<st0>, unsigned int a2, unsigned int a3, unsigned int a4, int (__cdecl *a5)(unsigned int, unsigned int, int), int a6);
// unsigned int __usercall qsort@<eax>(long double a1@<st0>, unsigned int a2, unsigned int a3, unsigned int a4, int (__cdecl *a5)(unsigned int, unsigned int, int));
int __cdecl getenv(_BYTE *a1);
// void __usercall _add_to_environ(long double a1@<st0>, unsigned __int8 *a2, _BYTE *a3, unsigned __int8 *a4, int a5);
// void __usercall setenv(long double a1@<st0>, char *s, _BYTE *a3, int a4);
void __cdecl unsetenv(char *s);
// void __usercall clearenv(long double a1@<st0>);
// void __usercall L_lock_44(int a1@<eax>);
void L_unlock_163();
void L_unlock_317();
void L_unlock_362();
// void __usercall L_lock_631(int a1@<eax>);
void L_unlock_668();
// void __usercall L_lock_733(int a1@<eax>);
void L_unlock_742();
int __cdecl _secure_getenv(_BYTE *a1);
unsigned int __cdecl _strtol_internal(char *a1, char **a2, int a3, int a4);
unsigned int __cdecl strtol(char *a1, char **a2, int a3);
int __cdecl _strtoul_internal(char *a1, char **a2, int a3, int a4);
int __cdecl strtoul(char *a1, char **a2, int a3);
unsigned int __cdecl ___strtol_l_internal(char *a1, char **a2, int a3, int a4, _DWORD *a5);
unsigned int __cdecl strtol_l(char *a1, char **a2, int a3, _DWORD *a4);
int __cdecl ___strtoul_l_internal(char *a1, char **a2, int a3, int a4, _DWORD *a5);
int __cdecl strtoul_l(char *a1, char **a2, int a3, _DWORD *a4);
unsigned int __cdecl _correctly_grouped_prefixmb(unsigned int a1, unsigned int a2, _BYTE *a3, char *a4);
char *__cdecl itoa_word(unsigned int a1, char *a2, unsigned int a3, int a4);
char *__cdecl itoa(unsigned __int64 a1, char *a2, unsigned int a3, int a4);
char *__cdecl fitoa_word(unsigned int a1, _BYTE *a2, unsigned int a3, int a4);
char *__cdecl fitoa(unsigned __int64 a1, _BYTE *a2, unsigned int a3, int a4);
int __cdecl IO_helper_overflow(int a1, unsigned __int8 a2);
// void __usercall buffered_vfprintf(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
_DWORD __cdecl vfprintf(_DWORD, _DWORD, _DWORD); // weak
// void __usercall L_lock_193(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_241(int a1, _DWORD *a2);
// void __usercall L_lock_1107(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_1177(int a1, _DWORD *a2);
int __fastcall hack_digit_12413(int a1);
int __cdecl _guess_grouping(unsigned int a1, unsigned __int8 *a2);
int __cdecl _printf_fp(int a1, int a2, long double **a3);
void __cdecl register_printf_specifier(unsigned int a1, int a2, int a3);
// void __usercall L_lock_18(int a1@<eax>);
void L_unlock_38();
int __cdecl _printf_fphex(_DWORD *a1, int a2, long double **a3);
// void __usercall register_printf_modifier(long double a1@<st0>, char *a2);
int __cdecl _handle_registered_modifier_mb(unsigned __int8 **a1, int a2);
int __cdecl _handle_registered_modifier_wc(_DWORD *a1, int a2);
// void __usercall L_lock_129(int a1@<eax>);
void L_unlock_180();
void __cdecl register_printf_type(int a1);
// void __usercall L_lock_11(int a1@<eax>);
void L_unlock_35();
int fprintf(int a1, int a2, ...);
// int __usercall asprintf@<eax>(long double a1@<st0>, _DWORD *a2, int a3, ...);
int dprintf(unsigned int a1, int a2, ...);
// void __usercall sscanf(long double a1@<st0>, unsigned int a2, unsigned __int8 *a3, ...);
void __cdecl funlockfile(int a1);
void __fastcall L_unlock_16(int a1, _DWORD *a2);
int __cdecl _parse_one_specmb(unsigned __int8 *a1, int a2, int a3, unsigned int *a4);
// void __usercall _fxprintf(long double a1@<st0>, _DWORD *a2, char *a3, ...);
void __cdecl fclose(int *a1);
// void __usercall L_lock_38(int a1@<eax>, volatile __int32 *a2@<edx>);
// void __usercall L_lock_101(int a1@<eax>);
void L_unlock_110();
void __fastcall L_unlock_191(int a1, _DWORD *a2);
void __noreturn L_unlock_220(); // weak
void __cdecl fflush(_DWORD *a1);
// void __usercall L_lock_33_1(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_80(_DWORD *a1);
void __noreturn L_unlock_137(); // weak
int __cdecl _fopen_maybe_mmap(int a1);
int *__cdecl _fopen_internal(int a1, _BYTE *a2, int a3);
int *__cdecl fopen(int a1, _BYTE *a2);
void __cdecl fputs(_BYTE *a1, _DWORD *a2);
// void __usercall L_lock_41(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_100(_DWORD *a1);
void __noreturn L_unlock_156(); // weak
void __cdecl ftell(int *a1);
// void __usercall L_lock_30(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_168(int a1, _DWORD *a2);
void __noreturn L_unlock_207(); // weak
void __cdecl fwrite(int a1, int a2, int a3, _DWORD *a4);
// void __usercall L_lock_43(int a1@<eax>, volatile __int32 *a2@<edx>);
// void __usercall L_unlock_192(_DWORD *a1@<ebx>);
void __noreturn L_unlock_221(); // weak
int __cdecl IO_padn(int a1, int a2, int a3);
int __cdecl IO_seekoff_unlocked(int *a1, __int64 a2, unsigned int a3, int a4);
void __cdecl IO_seekoff(int *a1, __int64 a2, unsigned int a3, int a4);
// void __usercall L_lock_189(int a1@<eax>, volatile __int32 *a2@<edx>);
// void __usercall L_unlock_238(_DWORD *a1@<ebx>);
void __noreturn L_unlock_283(); // weak
// void __usercall vsscanf(long double a1@<st0>, unsigned int a2, unsigned __int8 *a3, int *a4);
int __cdecl IO_mem_sync(int a1);
// void __usercall IO_mem_finish(long double a1@<st0>, int a2);
_DWORD *__cdecl open_memstream(int a1, int a2);
// int __usercall vasprintf@<eax>(long double a1@<st0>, _DWORD *a2, int a3, int a4);
int __cdecl vdprintf(unsigned int a1, int a2, int a3);
int fcloseall(void); // weak
int __cdecl fgets_unlocked(int a1, int a2, int *a3);
int __cdecl fputs_unlocked(_BYTE *a1, int a2);
int __cdecl IO_wpadn(int a1, int a2, int a3);
// int __usercall save_for_wbackup@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>);
int __cdecl IO_least_wmarker(int a1, int a2);
_DWORD *__cdecl IO_switch_to_main_wget_area(_DWORD *a1);
_DWORD *__cdecl IO_switch_to_wbackup_area(_DWORD *a1);
int __cdecl IO_wsetb(int a1, int a2, int a3, int a4);
// int __usercall IO_wdefault_pbackfail@<eax>(long double a1@<st0>, int *a2, int a3);
// void __usercall IO_wdefault_finish(long double a1@<st0>, int a2);
int __cdecl IO_wdefault_uflow(int a1);
int __cdecl _woverflow(int a1, int a2);
unsigned int __cdecl IO_wdefault_xsputn(int a1, _BYTE *a2, unsigned int a3);
int __cdecl IO_wdoallocbuf(int a1);
int __cdecl IO_wdefault_doallocate(int a1);
int __cdecl IO_switch_to_wget_mode(int *a1);
_DWORD *__cdecl IO_free_wbackup_area(_DWORD *a1);
// int __usercall _wunderflow@<eax>(long double a1@<st0>, int *a2);
// unsigned int __usercall IO_wdefault_xsgetn@<eax>(long double a1@<st0>, int *a2, _WORD *a3, unsigned int a4);
// int __usercall _wuflow@<eax>(long double a1@<st0>, int *a2);
int __cdecl IO_sputbackwc(_DWORD *a1, int a2);
int __cdecl IO_sungetwc(_DWORD *a1);
int __cdecl IO_adjust_wcolumn(int a1, unsigned int a2, int a3);
int __cdecl IO_init_wmarker(int *a1, int *a2);
int __cdecl IO_wmarker_delta(int a1);
int __cdecl IO_seekwmark(int *a1, int a2);
_DWORD *__cdecl IO_unsave_wmarkers(_DWORD *a1);
// int __usercall IO_wfile_seekoff@<eax>(long double a1@<st0>, int a2, int a3, unsigned int a4, int a5, int a6);
// void __usercall IO_wfile_underflow(long double a1@<st0>, int a2);
int __cdecl IO_wfile_underflow_maybe_mmap(_DWORD *a1);
// int __usercall IO_wfile_underflow_mmap@<eax>(long double a1@<st0>, _DWORD *a2);
int __cdecl IO_wdo_write(_DWORD *a1, int a2, int a3);
unsigned int __cdecl IO_wfile_xsputn(_DWORD *a1, char *a2, unsigned int a3);
int __cdecl IO_wfile_sync(_DWORD *a1);
int __cdecl IO_wfile_overflow(int *a1, int a2);
// void __usercall L_lock_752(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_1161(int a1, _DWORD *a2);
void __noreturn L_unlock_1374(); // weak
int __cdecl IO_file_seekoff_maybe_mmap(_DWORD *a1, int a2, int a3, int a4);
int __cdecl IO_file_sync_mmap(_DWORD *a1);
__int64 __cdecl IO_file_seek(int a1, int a2, int a3);
// int __usercall decide_maybe_mmap@<eax>(_DWORD *a1@<eax>);
int __cdecl IO_file_xsgetn_maybe_mmap(_DWORD *a1, int a2, int a3);
int __cdecl IO_file_underflow_maybe_mmap(_DWORD *a1);
// int __usercall mmap_remap_check@<eax>(int a1@<eax>);
int __cdecl IO_file_xsgetn_mmap(_DWORD *a1, char *a2, unsigned int a3);
// unsigned int __usercall IO_file_xsgetn@<eax>(long double a1@<st0>, int a2, _BYTE *a3, unsigned int a4);
// int __usercall new_do_write@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>);
int __cdecl IO_new_file_write(int a1, int a2, int a3);
unsigned int __fastcall IO_file_close(int a1);
unsigned int __cdecl IO_file_close_mmap(int a1);
unsigned int __cdecl IO_file_stat(int a1, int a2);
// int __usercall IO_new_file_seekoff@<eax>(long double a1@<st0>, int *a2, __int64 a3, int a4, int a5);
_DWORD *__cdecl IO_new_file_setbuf(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl IO_file_setbuf_mmap(_DWORD *a1, int a2, int a3);
int __cdecl IO_file_seekoff_mmap(_DWORD *a1, __int64 a2, int a3, int a4);
int __cdecl IO_file_underflow_mmap(_DWORD *a1);
int __cdecl IO_new_file_xsputn(_DWORD *a1, _BYTE *a2, unsigned int a3);
// int __usercall IO_file_read@<eax>(int a1@<ebp>, int a2, int a3);
void __cdecl IO_new_file_init(int *a1);
// int __usercall IO_file_open@<eax>(int a1@<ebp>, int a2, int a3, int a4, int a5, __int16 a6, int a7);
unsigned int *__cdecl IO_new_file_attach(unsigned int *a1, unsigned int a2);
int __cdecl IO_new_do_write(int a1, unsigned int a2, int a3);
int __cdecl IO_new_file_sync(_DWORD *a1);
// void __usercall IO_new_file_finish(long double a1@<st0>, int *a2);
int __cdecl IO_new_file_close_it(int a1);
int __cdecl IO_new_file_fopen(_DWORD *a1, int a2, _BYTE *a3, int a4);
// void __usercall IO_new_file_underflow(long double a1@<st0>, int *a2);
int __cdecl IO_new_file_overflow(int *a1, int a2);
// void __usercall L_lock_4026(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_4065(int a1, _DWORD *a2);
void __noreturn L_unlock_4233(); // weak
void __fastcall flush_cleanup(int a1);
// int __usercall save_for_backup@<eax>(_DWORD *a1@<eax>, int a2@<edx>);
void __cdecl IO_un_link(int *a1);
void __cdecl IO_link_in(int *a1);
int __cdecl IO_least_marker(int a1, int a2);
_DWORD *__cdecl IO_switch_to_main_get_area(_DWORD *a1);
_DWORD *__cdecl IO_switch_to_backup_area(_DWORD *a1);
int __cdecl IO_switch_to_get_mode(int *a1);
int __cdecl IO_free_backup_area(int *a1);
int __cdecl _overflow(int a1, int a2);
int __cdecl _underflow(int *a1);
int __cdecl _uflow(int *a1);
int __cdecl IO_setb(int a1, int a2, int a3, int a4);
int __cdecl IO_doallocbuf(int a1);
int IO_default_underflow();
int __cdecl IO_default_uflow(int a1);
unsigned int __cdecl IO_default_xsputn(_DWORD *a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl IO_sgetn(int a1);
unsigned int __cdecl IO_default_xsgetn(int *a1, _BYTE *a2, unsigned int a3);
_DWORD *__cdecl IO_default_setbuf(_DWORD *a1, int a2, int a3);
int __cdecl IO_default_seekpos(int a1, int a2, int a3, int a4);
int __cdecl IO_default_doallocate(int a1);
_DWORD *__cdecl IO_old_init(int a1, int a2);
_DWORD *__cdecl IO_no_init(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD *a5);
_DWORD *__cdecl IO_init(_DWORD *a1, int a2);
int IO_default_sync();
// void __usercall IO_default_finish(long double a1@<st0>, int *a2);
__int64 IO_default_seekoff();
int __cdecl IO_sputbackc(_DWORD *a1, int a2);
int __cdecl IO_sungetc(_DWORD *a1);
int __cdecl IO_adjust_column(int a1, unsigned int a2, int a3);
void __cdecl IO_flush_all_lockp(int a1);
void IO_cleanup();
void IO_flush_all();
void __fastcall flushlbf(int _ECX);
int __cdecl IO_init_marker(int *a1, int *a2);
_DWORD *__cdecl IO_remove_marker(_DWORD *a1);
int __cdecl IO_marker_difference(int a1, int a2);
int __cdecl IO_marker_delta(int a1);
int __cdecl IO_seekmark(int *a1, int a2);
int __cdecl IO_unsave_markers(int *a1);
// int __usercall IO_default_pbackfail@<eax>(long double a1@<st0>, int *a2, int a3);
__int64 IO_default_seek();
int IO_default_stat();
int IO_default_read();
int IO_default_write();
int IO_default_showmanyc();
void *IO_iter_begin();
int IO_iter_end();
int __cdecl IO_iter_next(int a1);
int __cdecl IO_iter_file(int a1);
void IO_list_lock();
void IO_list_unlock();
void IO_list_resetlock();
void __fastcall L_unlock_24(int a1, _DWORD *a2);
void L_unlock_37();
// void __usercall L_lock_436(int a1@<eax>);
// void __usercall L_lock_470(int a1@<eax>, volatile __int32 *a2@<edx>);
void L_unlock_543();
void __fastcall L_unlock_599(int a1, _DWORD *a2);
// void __usercall L_lock_661(int a1@<eax>);
// void __usercall L_lock_699(int a1@<eax>, volatile __int32 *a2@<edx>);
void L_unlock_738();
void __fastcall L_unlock_798(int a1, _DWORD *a2);
// void __usercall L_lock_2351(int a1@<eax>);
// void __usercall L_lock_2424(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_2477(int a1, _DWORD *a2);
void L_unlock_2553();
void __fastcall L_unlock_2754(int a1, _DWORD *a2);
// void __usercall L_lock_2824(int a1@<eax>);
// void __usercall L_lock_2890(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_2923(int a1, _DWORD *a2);
void L_unlock_2957();
// void __usercall L_lock_3626(int a1@<eax>);
void L_unlock_3653();
int __cdecl IO_str_underflow(_DWORD *a1);
// void __usercall IO_str_finish(long double a1@<st0>, int *a2);
// int __usercall IO_str_pbackfail@<eax>(long double a1@<st0>, int *a2, int a3);
int __cdecl IO_str_overflow(int a1, int a2);
// int __usercall enlarge_userbuf_part_0@<eax>(int a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, long double a4@<st0>, int a5);
// int __usercall IO_str_seekoff@<eax>(long double a1@<st0>, int *a2, __int64 a3, int a4, int a5);
int __cdecl IO_str_init_static_internal(_DWORD *a1, unsigned int a2, int a3, int a4);
int __cdecl IO_str_init_static(_DWORD *a1, unsigned int a2, int a3, int a4);
int __cdecl IO_str_init_readonly(_DWORD *a1, unsigned int a2, int a3);
unsigned int __cdecl IO_str_count(_DWORD *a1);
const __m128i *(__cdecl *strchr())(const __m128i *a1, unsigned int a2);
unsigned int *__cdecl _strchr_ia32(unsigned int *a1, int a2);
int (__cdecl *strcmp())(const __m128i *a1, const __m128i *a2);
int __cdecl _strcmp_ia32(char *a1, _BYTE *a2);
unsigned int (__cdecl *strcpy())(unsigned int a1, unsigned int a2);
void __cdecl _strcpy_ia32(int a1, char a2);
_BYTE *__cdecl strdup(_BYTE *a1);
// char *__usercall strerror_r@<eax>(long double a1@<st0>, signed int a2, _BYTE *a3, unsigned int a4);
int (__cdecl *strnlen())(_BYTE *a1, int a2);
unsigned int (__cdecl *strncpy())(unsigned int a1, unsigned int a2, unsigned int a3);
const __m128i *(__usercall *strrchr())@<eax>(const __m128i *a1@<esi>, const __m128i *a2, unsigned int a3);
unsigned int *__cdecl _strrchr_ia32(unsigned int *a1, int a2);
int (__cdecl *memchr())(const __m128i *a1, unsigned int a2, unsigned int a3);
_BYTE *__cdecl _memchr_ia32(_BYTE *a1, int a2, unsigned int a3);
unsigned int (__usercall *memmove())@<eax>(const __m128i *a1@<esi>, unsigned int a2, _DWORD *a3, unsigned int a4);
_BYTE *__cdecl _memmove_ia32(_BYTE *a1, _BYTE *a2, unsigned int a3);
unsigned int (__cdecl *stpcpy())(unsigned int a1, unsigned int a2);
void __cdecl _stpcpy_ia32(int a1, char a2);
int (__cdecl *strcasecmp_l())(int a1, int a2, int a3);
int __cdecl _strcasecmp_l_ia32(char *a1, _BYTE *a2);
int (__cdecl *rawmemchr())(const __m128i *a1, unsigned int a2);
_BYTE *__cdecl _rawmemchr_ia32(_BYTE *a1, int a2);
int __cdecl argz_count(_BYTE *a1, int a2);
void __cdecl argz_stringify(_BYTE *a1, int a2, char a3);
// unsigned int __usercall _memmove_chk_ssse3@<eax>(const __m128i *a1@<esi>, long double fst7_0@<st0>, unsigned int a2, _QWORD *a3, unsigned int a4, unsigned int a6);
// unsigned int __usercall _memmove_ssse3@<eax>(const __m128i *a1@<esi>, unsigned int a2, _QWORD *a3, unsigned int a4);
// unsigned int __usercall _memmove_chk_ssse3_rep@<eax>(const __m128i *a1@<esi>, long double fst7_0@<st0>, unsigned int a2, _DWORD *a3, unsigned int a4, unsigned int a6);
// unsigned int __usercall _memmove_ssse3_rep@<eax>(const __m128i *a1@<esi>, unsigned int a2, _DWORD *a3, unsigned int a4);
int __cdecl _strcmp_ssse3(int a1, int a2);
int __cdecl _strcmp_sse4_2(const __m128i *a1, const __m128i *a2);
int __cdecl strncmp(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl _strncpy_ia32(int a1, char *a2, unsigned int a3);
unsigned int __cdecl _strcpy_ssse3(unsigned int a1, unsigned int a2);
unsigned int __cdecl _strncpy_ssse3(unsigned int a1, unsigned int a2, unsigned int a3);
unsigned int __cdecl _stpcpy_ssse3(unsigned int a1, unsigned int a2);
int __cdecl _strcpy_sse2(int a1, unsigned int a2);
__m128i *__cdecl _strncpy_sse2(__m128i *a1, unsigned int a2, unsigned int a3);
char *__cdecl _stpcpy_sse2(int a1, unsigned int a2);
const __m128i *__cdecl _strchr_sse2(const __m128i *a1, unsigned int a2);
// const __m128i *__usercall _strrchr_sse2@<eax>(const __m128i *a1@<esi>, const __m128i *a2, unsigned int a3);
char *__cdecl _strchr_sse2_bsf(const __m128i *a1, unsigned int a2);
// int __usercall _strrchr_sse2_bsf@<eax>(const __m128i *a1@<esi>, const __m128i *a2, unsigned int a3);
const __m128i *__cdecl _memchr_sse2(const __m128i *a1, unsigned int a2, unsigned int a3);
int __cdecl _memchr_sse2_bsf(const __m128i *a1, unsigned int a2, unsigned int a3);
const __m128i *__cdecl _rawmemchr_sse2(const __m128i *a1, unsigned int a2);
int __cdecl _rawmemchr_sse2_bsf(const __m128i *a1, unsigned int a2);
int __cdecl _strnlen_sse2(_BYTE *a1, unsigned int a2);
int __cdecl _strnlen_ia32(_BYTE *a1, int a2);
int __cdecl _strcasecmp_ssse3(int a1, int a2);
int __cdecl _strcasecmp_l_ssse3(int a1, int a2, int a3);
int __cdecl _strcasecmp_sse4_2(int a1, int a2);
int __cdecl _strcasecmp_l_sse4_2(int a1, int a2, int a3);
// int __usercall critical_factorization@<eax>(int a1@<eax>, unsigned int a2@<edx>, int *a3@<ecx>);
// void *__usercall two_way_long_needle@<eax>(_BYTE *s1@<ecx>, int a2@<eax>, int a3@<edx>, int a4);
char *__cdecl _strstr_ia32(char *a1, char *a2);
char *(__cdecl *strstr())(char *a1, char *a2);
_BYTE *__cdecl wmemcpy(_BYTE *a1, _BYTE *a2, int a3);
_DWORD *__cdecl wmemset(_DWORD *a1, int a2, unsigned int a3);
void *__cdecl wmemmove(void *a1, const void *a2, int a3);
_WORD *__cdecl wmempcpy(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl wcrtomb(int *a1, int a2, void *a3);
int __cdecl wcsrtombs(int a1, const wchar_t **a2, int a3, int *a4);
int __cdecl mbsnrtowcs(int a1, int *a2, int a3, int a4, int *a5);
int __cdecl wcsnlen(_DWORD *a1, int a2);
// int __usercall nl_cleanup_ctype@<eax>(int result@<eax>);
int __cdecl _wcsmbs_getfct(char *a1, char *a2, _DWORD *a3);
// int __usercall _wcsmbs_load_conv@<eax>(_DWORD *a1@<eax>);
// _DWORD *__usercall _wcsmbs_clone_conv@<eax>(void **a1@<eax>);
// _BOOL4 __usercall _wcsmbs_named_conv@<eax>(int *a1@<eax>, int a2@<edx>);
// void __usercall localtime_r(long double a1@<st0>, int *a2, int *a3);
// void __usercall localtime(long double a1@<st0>, int *a2);
__int64 __fastcall time(int a1);
// int __usercall compute_offset@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>);
// int __usercall compute_change@<eax>(int result@<eax>, int a2@<edx>);
unsigned int update_vars();
const char *__cdecl _tzstring(char *src);
// unsigned int __usercall _tzset_parse_tz@<eax>(long double a1@<st0>, _BYTE *a2);
// int __usercall tzset_internal@<eax>(int result@<eax>, int a2@<edx>, long double a3@<st0>);
// void __usercall _tzname_max(long double a1@<st0>);
// int __usercall _tz_compute@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>);
// void __usercall tzset(long double a1@<st0>);
// void __usercall _tz_convert(long double a1@<st0>, int *a2, int a3, int *a4);
// void __usercall L_lock_1706(int a1@<eax>);
void L_unlock_1712();
// void __usercall L_lock_1819(int a1@<eax>);
void L_unlock_1835();
// void __usercall L_lock_1862(int a1@<eax>);
void L_unlock_1923();
int __cdecl _tzfile_read(char *haystack, unsigned int a2, _DWORD *a3);
char *__cdecl _tzfile_default(char *a1, char *a2, int a3, int a4);
// int __usercall _tzfile_compute@<eax>(long double a1@<st0>, int a2, int a3, _DWORD *a4, int *a5, int *a6);
// int __usercall _strftime_internal@<eax>(char *a1@<eax>, int a2@<edx>, unsigned __int8 *a3@<ecx>, long double a4@<st0>, signed int *a5, _BYTE *a6, _DWORD *a7);
// int __usercall strftime_l@<eax>(long double a1@<st0>, char *a2, int a3, unsigned __int8 *a4, signed int *a5, _DWORD *a6);
// int __usercall nl_init_alt_digit@<eax>(_DWORD *a1@<eax>);
// int __usercall nl_get_alt_digit@<eax>(unsigned int a1@<eax>, int a2@<edx>);
// int __usercall nl_get_walt_digit@<eax>(unsigned int a1@<eax>, _DWORD *a2@<edx>, long double a3@<st0>);
// int __usercall nl_parse_alt_digit@<eax>(unsigned __int8 **a1@<eax>, int a2@<edx>);
// int __usercall nl_init_era_entries_part_0@<eax>(_DWORD *a1@<eax>);
// _DWORD *__usercall nl_get_era_entry@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>);
// int __usercall nl_select_era_entry@<eax>(int a1@<eax>, _DWORD *a2@<edx>);
// int __usercall nl_cleanup_time@<eax>(int result@<eax>);
// int *__userpurge _alloc_dir@<eax>(int a1@<eax>, char a2@<dl>, int a3@<ecx>, int a4);
// int *__usercall _opendirat@<eax>(int a1@<eax>, _BYTE *a2@<edx>);
int *__cdecl opendir(_BYTE *a1);
unsigned int __cdecl closedir(int a1);
void __cdecl readdir64(_DWORD *a1);
// void __usercall L_lock_21(int a1@<eax>, int a2@<ebx>);
// void __usercall L_unlock_92(int a1@<ebx>);
unsigned int __fastcall uname(int a1);
// int __usercall fork@<eax>(long double a1@<st0>);
// int __usercall execvp@<eax>(long double a1@<st0>, char *s, int a3);
// int __usercall execvpe@<eax>(long double a1@<st0>, char *s, int a3);
int __fastcall getpid(int a1);
__int64 __fastcall getuid(int a1);
__int64 __fastcall geteuid(int a1);
__int64 __fastcall getgid(int a1);
// int __usercall _sysconf_check_spec@<eax>(_BYTE *a1@<eax>);
// void __usercall sysconf(int a1@<ecx>, long double a2@<st0>, int a3);
// unsigned int __usercall confstr@<eax>(int a1@<ecx>, long double a2@<st0>, int a3, _BYTE *a4, unsigned int a5);
unsigned int __fastcall sched_yield(int a1);
int _get_child_max();
unsigned int __cdecl _xstat64(int a1, int a2, int a3);
unsigned int __cdecl _openat_nocancel(int a1, int a2);
// int __usercall openat@<eax>(int a1@<ebp>, int a2, int a3);
// int __usercall _openat_2@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, char a5);
// int __usercall close@<eax>(int a1@<ebp>, int a2);
unsigned int __fastcall _close_nocancel(int a1);
unsigned int __cdecl access(int a1, int a2);
_BYTE *__cdecl getcwd(_BYTE *a1, unsigned int a2);
unsigned int __cdecl getrlimit(int a1, int a2);
int __cdecl brk(unsigned int a1);
// unsigned int __usercall writev@<eax>(int a1@<ebp>, int a2, int a3);
int getpagesize();
int getdtablesize();
unsigned int __cdecl mmap64(int a1, int a2, int a3, int a4, int a5, __int64 a6);
// int __usercall trecurse@<eax>(int a1@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3@<ecx>);
// void __usercall tdestroy_recurse(_DWORD *a1@<eax>, long double (__cdecl *a2)(_DWORD)@<edx>, int a3@<ecx>);
// int __usercall maybe_split_for_insert_isra_0@<eax>(int result@<eax>, int *a2@<edx>, int *a3@<ecx>, int a4, int a5, int a6);
_DWORD *__cdecl tsearch(int a1, int *a2, int (__cdecl *a3)(int, _DWORD));
_DWORD *__cdecl tfind(int a1, _DWORD *a2, int (__cdecl *a3)(int, _DWORD));
// int __usercall tdelete@<eax>(long double a1@<st0>, int a2, int **a3, int (__cdecl *a4)(int, int));
int __cdecl twalk(int a1, int (__cdecl *a2)(int, int, int));
void __cdecl tdestroy(_DWORD *a1, long double (__cdecl *a2)(_DWORD));
int _getclktck();
__int64 __cdecl lseek64(int a1, int a2, int a3);
int __cdecl wctrans(char *s1); // idb
unsigned int __cdecl towctrans(unsigned int a1, _DWORD *a2);
// void __usercall __noreturn _chk_fail(long double a1@<st0>);
int __cdecl _readonly_area(unsigned int a1, unsigned int a2);
// void __usercall __noreturn _fortify_fail(int a1@<eax>, long double a2@<st0>);
// int __usercall is_dst@<eax>(int a1@<eax>, char *a2@<edx>, _BYTE *a3@<ecx>, int a4, int a5);
// _BYTE *__usercall local_strdup@<eax>(_BYTE *a1@<eax>);
// _DWORD *__usercall fillin_rpath@<eax>(int a1@<eax>, _DWORD *a2@<edx>, char *a3@<ecx>, int a4, int a5, _BYTE *a6);
// _BYTE *__usercall add_name_to_object@<eax>(int a1@<eax>, char *a2@<edx>);
// void __usercall __noreturn lose(int a1@<edx>, int a2, int a3, int a4, int a5);
// int __usercall dl_map_object_from_fd@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>, _BYTE *a4, int a5, char a6, int a7, int a8, int a9);
// int __usercall open_verify_isra_3@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>, char a4);
// int __usercall open_path_isra_4@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int *a4, _DWORD *a5, int a6, int a7, int a8);
// int *__usercall add_path_8960_isra_2_constprop_6@<eax>(int *result@<eax>, int a2@<ecx>);
int __cdecl dl_dst_count(int a1, int a2);
char *__cdecl dl_dst_substitute(int a1, char *a2, char *a3, int a4);
// char *__usercall expand_dynamic_string_token@<eax>(int a1@<eax>, char *s@<edx>, int a3@<ecx>);
// int __usercall cache_rpath@<eax>(int a1@<eax>, int *a2@<edx>, int a3@<ecx>, int a4);
// void __usercall dl_init_paths(_BYTE *a1@<eax>, long double a2@<st0>);
// int __userpurge dl_map_object@<eax>(int a1@<eax>, char *a2@<edx>, char a3@<cl>, int a4, int a5, int a6);
// int *__usercall dl_rtld_di_serinfo@<eax>(int a1@<eax>, int *a2@<edx>, char a3@<cl>);
// int __usercall dl_cache_libcmp@<eax>(char *a1@<eax>, char *a2@<edx>);
// const char *__usercall dl_load_cache_lookup@<eax>(char *a1@<eax>);
unsigned int dl_unload_cache();
// int __usercall enter_8787@<eax>(int a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, int a4, int a5, int a6);
// int __usercall check_match_8739@<eax>(int a1@<eax>, int a2@<ecx>);
// int __usercall do_lookup_x@<eax>(char *a1@<eax>, unsigned int a2@<edx>, unsigned int *a3@<ecx>, int a4, int *a5, int *a6, int a7, int a8, int a9, int a10, int a11, int a12);
// int __userpurge dl_lookup_symbol_x@<eax>(char *a1@<eax>, int a2@<edx>, int *a3@<ecx>, long double a4@<st0>, int **a5, int a6, int a7, int a8, int a9);
// _DWORD *__usercall dl_setup_hash@<eax>(_DWORD *result@<eax>);
// int __usercall dl_add_to_namespace_list@<eax>(_DWORD *a1@<eax>, int a2@<edx>);
// int __userpurge dl_new_object@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, char a3@<cl>, int a4, char a5, int a6);
// int __usercall dl_try_allocate_static_tls@<eax>(int a1@<eax>);
// int __usercall dl_allocate_static_tls@<eax>(int a1@<eax>);
void *__cdecl dl_nothread_init_static_tls(int a1);
// signed int __usercall dl_protect_relro@<eax>(_DWORD *a1@<eax>);
void __fastcall __noreturn dl_reloc_bad_type(int a1, unsigned __int8 a2);
int __cdecl dl_relocate_object(int a1, int a2, int a3, int a4);
// void __usercall __noreturn dl_signal_error(int a1@<eax>, _BYTE *a2@<edx>, const char *a3@<ecx>, long double a4@<st0>, char *a5);
// int __userpurge dl_signal_cerror@<eax>(int a1@<eax>, char *a2@<edx>, const char *a3@<ecx>, long double a4@<st0>, char *a5);
// int __userpurge dl_catch_error@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _BYTE *a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>, void (__cdecl *a8)(int), int a9);
// int (__cdecl *__usercall dl_receive_error@<eax>(int (__cdecl *a1)(_DWORD, _DWORD, _DWORD)@<eax>, void (__cdecl *a2)(int)@<edx>, int a3@<ecx>))(_DWORD, _DWORD, _DWORD);
int dl_debug_state(void); // weak
// _DWORD *__usercall dl_debug_initialize@<eax>(int a1@<eax>, int a2@<edx>);
// __int64 __usercall dl_debug_vdprintf@<edx:eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int *a4);
// unsigned int __usercall dl_sysdep_read_whole_file@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>);
__int64 dl_debug_printf(int a1, ...);
__int64 dl_debug_printf_c(int a1, ...);
__int64 dl_dprintf(int a1, int a2, ...);
// int __usercall dl_name_match_p@<eax>(const char *s1@<eax>, int a2@<edx>);
// int __usercall dl_higher_prime_number@<eax>(unsigned int a1@<eax>);
// int __usercall allocate_dtv@<eax>(int a1@<eax>);
unsigned int dl_next_tls_modid();
// int __usercall dl_get_tls_static_info@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>);
int dl_allocate_tls_storage();
// int __usercall dl_allocate_tls_init@<eax>(int a1@<eax>);
// int __usercall dl_allocate_tls@<eax>(int a1@<eax>);
// int __usercall dl_deallocate_tls@<eax>(int a1@<eax>, char a2@<dl>);
int __cdecl dl_tls_get_addr_soft(int a1);
int __cdecl dl_add_to_slotinfo(unsigned int a1);
int dl_get_origin();
int __cdecl dl_scope_free(int a1);
// unsigned int __usercall dl_make_stack_executable@<eax>(_DWORD *a1@<eax>);
void __stdcall __spoils<ecx> dl_runtime_resolve(int a1, int a2, int a3);
// void __userpurge __spoils<ecx,st0> dl_runtime_profile(int a1@<ecx>, int a2@<edi>, long double a3@<st1>, long double a4@<st0>, int a5, int a6, char a7, int a8, int a9);
int __cdecl dl_mcount_wrapper(int a1);
int __cdecl dl_mcount_wrapper_check(int a1);
unsigned int dl_initial_error_catch_tsd();
// int __usercall dl_tlsdesc_return@<eax>(int a1@<eax>);
// unsigned int __usercall dl_tlsdesc_undefweak@<eax>(int a1@<eax>);
// int __usercall dl_tlsdesc_resolve_abs_plus_addend@<eax>(int (__fastcall **a1)(int, int)@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall dl_tlsdesc_resolve_rel@<eax>(int (__fastcall **a1)(int, int)@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>);
// int __usercall dl_tlsdesc_resolve_rela@<eax>(int (__fastcall **a1)(int, int)@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, long double a5@<st0>);
// int __usercall dl_tlsdesc_resolve_hold@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __userpurge _gconv_open@<eax>(const char *a1@<eax>, int *a2@<edx>, int **a3@<ecx>, int a4);
// int __userpurge _gconv@<eax>(_DWORD *a1@<eax>, int *a2@<edx>, unsigned int a3@<ecx>, int *a4, int a5, _DWORD *a6);
// void __usercall _gconv_close(int *a1@<eax>, long double a2@<st0>);
int __cdecl _gconv_alias_compare(char *s1, char *s2); // idb
// int __usercall do_lookup_alias@<eax>(int a1@<eax>);
int __cdecl derivation_compare(const char **a1, const char **a2);
int _gconv_get_modules_db();
int _gconv_get_alias_db();
// int __usercall _gconv_release_step@<eax>(int *a1@<eax>);
// int __userpurge find_derivation@<eax>(char *a1@<eax>, char *a2@<edx>, _BYTE *a3@<ecx>, _BYTE *a4, int *a5, unsigned int *a6);
// int __usercall _gconv_compare_alias@<eax>(char *a1@<eax>, char *a2@<edx>);
// void __userpurge _gconv_find_transform(char *a1@<eax>, char *a2@<edx>, int *a3@<ecx>, unsigned int *a4, int a5);
// void __usercall _gconv_close_transform(int a1@<eax>, int a2@<edx>);
// void __userpurge L_lock_2277(int a1@<eax>, int a2, int a3);
void __stdcall L_unlock_2293(int a1, int a2);
void __stdcall L_unlock_2353(int a1, int a2);
void __stdcall L_unlock_2373(int a1, int a2);
void __stdcall L_unlock_2470(int a1, int a2);
// void __usercall L_lock_2497(int a1@<eax>);
void L_unlock_2528();
// int __usercall insert_module@<eax>(int result@<eax>, int a2@<edx>);
// void __userpurge add_module(_BYTE *a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>, int a4, int a5, int a6);
// _DWORD *__usercall add_alias2_isra_1@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>);
void _gconv_get_path();
unsigned int _gconv_read_conf();
// void __usercall L_lock_862(int a1@<eax>);
void L_unlock_872();
// int __usercall _gconv_get_builtin_trans@<eax>(const char *a1@<eax>, _DWORD *a2@<edx>);
int __cdecl _gconv_btwoc_ascii(int a1, unsigned __int8 a2);
// int __usercall _gconv_transform_internal_ucs4@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, unsigned int *a5, char *a6, unsigned int *a7, int a8, int a9, int a10);
// int __usercall _gconv_transform_ucs4_internal@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, unsigned int **a5, unsigned int *a6, int **a7, _DWORD *a8, int a9, int a10);
// int __usercall _gconv_transform_internal_ucs4le@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, unsigned int *a5, char *a6, _BYTE **a7, int a8, int a9, int a10);
// int __usercall _gconv_transform_ucs4le_internal@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, char **a5, unsigned int a6, _BYTE **a7, _DWORD *a8, int a9, int a10);
// int __usercall _gconv_transform_ascii_internal@<eax>(long double a1@<st0>, int a2, unsigned int *a3, _DWORD *a4, int a5, unsigned int *a6, _DWORD *a7, int a8, int a9);
// int __usercall _gconv_transform_internal_ascii@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, int *a5, unsigned int a6, unsigned int **a7, _DWORD *a8, int a9, int a10);
// int __usercall _gconv_transform_internal_utf8@<eax>(long double a1@<st0>, int a2, int a3, int *a4, unsigned int a5, unsigned int **a6, _DWORD *a7, int a8, int a9);
// int __usercall _gconv_transform_utf8_internal@<eax>(long double a1@<st0>, int a2, unsigned int **a3, char **a4, unsigned int a5, unsigned int **a6, _DWORD *a7, int a8, int a9);
// int __usercall _gconv_transform_ucs2_internal@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, unsigned int *a4, int *a5, unsigned int a6, unsigned int *a7, _DWORD *a8, int a9, int a10);
// int __usercall _gconv_transform_internal_ucs2@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, int *a5, unsigned int a6, unsigned int **a7, _DWORD *a8, int a9, int a10);
// int __usercall _gconv_transform_ucs2reverse_internal@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, int *a5, unsigned int a6, char **a7, _DWORD *a8, int a9, int a10);
// int __usercall _gconv_transform_internal_ucs2reverse@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, int *a5, unsigned int a6, unsigned int **a7, _DWORD *a8, int a9, int a10);
// int __usercall open_translit@<eax>(_DWORD *a1@<eax>, int a2@<ebp>, int a3@<edi>, int a4@<esi>);
int __cdecl trans_compare(char *s1, char *s2); // idb
int __cdecl _gconv_transliterate(_DWORD *a1, int a2, int a3, int a4, unsigned int **a5, unsigned int a6, int *a7, _DWORD *a8);
// void __usercall _gconv_translit_find(_BYTE **a1@<eax>, int a2@<ebp>);
// void __usercall L_lock_723(int a1@<eax>);
void L_unlock_751();
// int __usercall find_module_idx@<eax>(unsigned __int8 *a1@<eax>, _DWORD *a2@<edx>);
// int __usercall find_module@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, int **a3@<ecx>);
int _gconv_get_cache();
// int __usercall _gconv_load_cache@<eax>(int a1@<ebp>);
// int __usercall _gconv_compare_alias_cache@<eax>(char *a1@<eax>, char *a2@<edx>, int *a3@<ecx>);
// int __userpurge _gconv_lookup_cache@<eax>(unsigned __int8 *a1@<eax>, unsigned __int8 *a2@<edx>, _DWORD *a3@<ecx>, int *a4, char a5);
// int __usercall _gconv_release_cache@<eax>(int result@<eax>);
int __cdecl known_compare(char *s1, char *s2); // idb
// char __usercall do_release_shlib@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int *a4, int a5);
// int __usercall _gconv_release_shlib@<eax>(int a1@<eax>);
// int *__usercall _gconv_find_shlib@<eax>(_BYTE *a1@<eax>, int a2@<ebp>, unsigned int a3@<edi>, _BYTE *a4@<esi>);
// void __usercall setname(int a1@<eax>, char *a2@<edx>, long double a3@<st0>);
// const char *__usercall new_composite_name@<eax>(int a1@<eax>, const char **a2@<edx>, long double a3@<st0>);
// char *__usercall setlocale@<eax>(long double a1@<st0>, unsigned int a2, char *s1);
// char **__userpurge nl_find_locale@<eax>(char *a1@<eax>, int a2@<edx>, char *a3@<ecx>, long double a4@<st0>, const char **a5);
// void __usercall nl_remove_locale(int a1@<eax>, int *a2@<edx>, long double a3@<st0>);
// void __usercall nl_intern_locale_data(int a1@<eax>, int *a2@<edx>, unsigned int a3@<ecx>, int a4@<ebp>, long double a5@<st0>);
// void __usercall nl_load_locale(int *a1@<eax>, int a2@<edx>, long double a3@<st0>);
// void __usercall nl_unload_locale(int *a1@<eax>, long double a2@<st0>);
int __cdecl rangecmp(_DWORD *a1, _DWORD *a2);
// int __usercall nl_load_locale_from_archive@<eax>(int a1@<eax>, char **a2@<edx>, int a3@<ecx>, long double a4@<st0>);
unsigned int nl_postload_ctype();
int __cdecl _current_locale_name(int a1);
int __cdecl isinf(double a1); // idb
unsigned int __cdecl isnan(double a1);
int __cdecl isinfl(int a1, int a2, __int16 a3);
int __cdecl isnanl(int a1, int a2, __int16 a3);
// int __usercall _sigsetjmp@<eax>(int ebx0@<ebx>, int ebp0@<ebp>, int a3@<edi>, int a4@<esi>, int a1, int a2);
int __cdecl _sigjmp_save(int a1, int a2);
void _longjmp(struct __jmp_buf_tag env[1], int val);
unsigned int raise();
int _restore_rt(); // weak
int __cdecl _libc_sigaction(int a1, int *a2, _DWORD *a3);
int __cdecl sigaction(int a1, int *a2, _DWORD *a3);
unsigned int __cdecl sigprocmask(int a1, int *a2);
int __cdecl _mpn_cmp(int a1, int a2, int a3);
int __cdecl _mpn_divrem(int a1, int a2, _DWORD *a3, int a4, unsigned int *a5, unsigned int a6);
int __cdecl _mpn_lshift(_DWORD *a1, int a2, int a3, char a4);
int __cdecl _mpn_rshift(int a1, unsigned int *a2, int a3, char a4);
int __cdecl _mpn_mul(_DWORD *a1, unsigned int *a2, int a3, unsigned int *a4, int a5);
int __cdecl _mpn_mul_1(int a1, int a2, int a3, unsigned int a4);
unsigned int __cdecl _mpn_impn_mul_n_basecase(int a1, _DWORD *a2, unsigned int *a3, int a4);
unsigned int __cdecl _mpn_impn_mul_n(_DWORD *a1, unsigned int *a2, unsigned int *a3, int a4, _DWORD *a5);
unsigned int __cdecl _mpn_impn_sqr_n_basecase(int a1, unsigned int *a2, int a3);
unsigned int __cdecl _mpn_impn_sqr_n(unsigned int *a1, unsigned int *a2, int a3, _DWORD *a4);
unsigned int __cdecl _mpn_mul_n(unsigned int *a1, unsigned int *a2, unsigned int *a3, int a4);
_BOOL4 __cdecl _mpn_sub_n(_DWORD *a1, unsigned int *a2, _DWORD *a3, unsigned int a4);
int __cdecl _mpn_submul_1(int a1, int a2, int a3, unsigned int a4);
int __cdecl _mpn_extract_double(unsigned int *a1, int a2, _DWORD *a3, unsigned int *a4, unsigned int a5, unsigned int a6);
int __cdecl _mpn_extract_long_double(unsigned int *a1, int a2, _DWORD *a3, int *a4, unsigned int a5, unsigned int a6, __int16 a7);
unsigned int __cdecl quicksort(unsigned int a1, unsigned int a2, unsigned int a3, int (__cdecl *a4)(unsigned int, unsigned int, int), int a5);
int *__cdecl itowa(unsigned __int64 a1, int *a2, unsigned int a3, int a4);
// void __usercall IO_vfscanf_internal(long double a1@<st0>, char *a2, unsigned __int8 *a3, int *a4, _DWORD *a5);
// void __usercall vfscanf(long double a1@<st0>, char *a2, unsigned __int8 *a3, int *a4);
void __fastcall L_unlock_1211(int a1, _DWORD *a2);
// void __usercall L_lock_1267(int a1@<eax>, volatile __int32 *a2@<edx>);
int __cdecl IO_helper_overflow_0(int a1, int a2);
// void __usercall vfwprintf(int a1@<edi>, long double a2@<st0>, _DWORD *a3, wchar_t *s, int *a5);
// void __usercall buffered_vfprintf_0(int a1@<ecx>, wchar_t *s@<edx>, _DWORD *a3@<eax>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
// void __usercall L_lock_612(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_696(int a1, _DWORD *a2);
// void __usercall L_lock_12760(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_12810(int a1, _DWORD *a2);
int __cdecl _parse_one_specwc(int *a1, int a2, int a3, unsigned int *a4);
int __cdecl IO_file_doallocate(_DWORD *a1);
void __cdecl getdelim(_BYTE **a1, unsigned int *a2, int c, int *a4);
// void __usercall L_lock_53(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_262(int a1, _DWORD *a2);
void __noreturn L_unlock_379(); // weak
_BYTE *__cdecl IO_getline_info(int *a1, int a2, size_t a3, int c, int a5, _DWORD *a6);
_BYTE *__cdecl IO_getline(int *a1, int a2, size_t a3, int a4, int a5);
int __cdecl do_encoding(int a1);
int do_always_noconv();
int __cdecl do_max_length(int a1);
int __cdecl do_in(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8);
int __cdecl do_unshift(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl do_out(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8);
int __cdecl do_length(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl IO_fwide(int a1, int a2);
int __cdecl fileno_unlocked(_DWORD *a1);
void __cdecl fseek(int *a1, int a2, unsigned int a3);
// void __usercall L_lock_31(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_89(int a1, _DWORD *a2);
void __noreturn L_unlock_130(); // weak
void __cdecl ftello(int *a1);
// void __usercall L_lock_30_0(int a1@<eax>, volatile __int32 *a2@<edx>);
void __fastcall L_unlock_168_0(int a1, _DWORD *a2);
void __noreturn L_unlock_207_0(); // weak
int __cdecl fread_unlocked(int a1, unsigned int a2, int a3, int a4);
int __cdecl IO_wfile_doallocate(_DWORD *a1);
// _BYTE *__usercall strndup@<eax>(long double a1@<st0>, _BYTE *a2, int a3);
const __m128i *__cdecl _strstr_sse42(const __m128i *a1, const __m128i *a2);
int __cdecl strsep(int *a1, char *a2);
// int __usercall argz_create_sep@<eax>(long double a1@<st0>, char *a2, int a3, int *a4, int *a5);
int __cdecl argz_add_sep(_BYTE **a1, _DWORD *a2, char *a3, int a4);
int __cdecl _strcasecmp_nonascii(int a1, int a2);
int *(__cdecl *wcschr())(int *a1, int a2);
unsigned int (__cdecl *wcslen())(_DWORD *a1);
int __cdecl btowc(int a1);
int __cdecl mbrlen(_BYTE *a1, int a2, _DWORD *a3);
int __cdecl mbrtowc(char *a1, _BYTE *a2, int a3, _DWORD *a4);
// int __usercall mbsrtowcs@<eax>(long double a1@<st0>, int a2, _DWORD *a3, int a4, void *a5);
_DWORD *__cdecl wcschrnul(_DWORD *a1, int a2);
// int __usercall _mbsrtowcs_l@<eax>(long double a1@<st0>, int a2, _DWORD *a3, int a4, int a5, _DWORD **a6);
unsigned int __cdecl _wcslen_sse2(_DWORD *a1);
char __cdecl _wcslen_ia32(_DWORD *a1);
const __m128i *__cdecl _wcschr_sse2(const __m128i *a1, unsigned int a2);
int *__cdecl _wcschr_ia32(int *a1, int a2);
int __cdecl _offtime(_DWORD *a1, int a2, int *a3);
// int __usercall ranged_convert@<eax>(int (__cdecl *a1)(int *, int)@<eax>, int *a2@<edx>, int a3@<ecx>);
// unsigned int __usercall guess_time_tm_isra_0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5, int a6, _DWORD *a7);
int __cdecl _mktime_internal(int *a1, int (__cdecl *a2)(int *, int), int *a3);
// int __usercall timelocal@<eax>(long double a1@<st0>, int *a2);
void __cdecl readdir(_DWORD *a1);
// void __usercall L_lock_21_0(int a1@<eax>, int a2@<ebx>);
// void __usercall L_unlock_92_0(int a1@<ebx>);
void __cdecl rewinddir(int *a1);
// void __usercall L_lock_16(int a1@<eax>, int a2@<ebx>);
// void __usercall L_unlock_28(int a1@<ebx>);
int __fastcall _getdents(int a1, unsigned int a2);
unsigned int __fastcall _getdents64(int a1, int a2);
// int *__usercall fdopendir@<eax>(int a1@<ebp>, int a2);
unsigned int __cdecl execve(int a1, int a2);
unsigned int __cdecl _lxstat64(int a1, int a2, int a3);
int __cdecl _fxstatat64(int a1, int a2, int a3);
unsigned int __cdecl _openat64_nocancel(int a1, int a2);
// int __usercall openat64@<eax>(int a1@<ebp>, int a2, int a3);
// int __usercall _openat64_2@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, char a5);
unsigned int __cdecl lseek(int a1, int a2);
_BOOL4 __cdecl isatty(int a1);
int __cdecl tcgetattr(int a1, int a2);
// int (*__usercall dl_fixup@<eax>(int (**a1)(void)@<eax>, int a2@<edx>))(void);
// int (*__userpurge dl_profile_fixup@<eax>(_DWORD *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4, _DWORD *a5))(void);
_DWORD __stdcall dl_call_pltexit(_DWORD); // weak
// int __usercall dl_start_profile@<eax>(long double a1@<st0>);
int __cdecl dl_mcount(int a1, int a2);
// char __usercall dlerror_run@<al>(void (__cdecl *a1)(int)@<eax>, int a2@<edx>, int a3@<ebx>, int a4@<ebp>, int a5@<edi>, int a6@<esi>);
// char __usercall _libc_dlclose@<al>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5);
// int __usercall _libc_dlsym@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5, int a6);
int do_dlclose(); // weak
// int __usercall do_dlsym@<eax>(long double a1@<st0>, int *a2);
int __cdecl do_dlsym_private(int *a1);
int __cdecl do_dlopen(int *a1);
// int __usercall _libc_dlsym_private@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5, int a6);
// _DWORD *__usercall _libc_register_dl_open_hook@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5);
// int __usercall _libc_dlopen_mode@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5, int a6);
// char *__usercall dl_tlsdesc_resolve_abs_plus_addend_fixup@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// char *__usercall dl_tlsdesc_resolve_rel_fixup@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>);
// char *__usercall dl_tlsdesc_resolve_rela_fixup@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>);
// char *__usercall dl_tlsdesc_resolve_hold_fixup@<eax>(char **a1@<eax>, int a2@<ecx>);
// unsigned int __usercall dl_unmap@<eax>(int a1@<eax>);
_BOOL4 __cdecl _mpn_add_n(_DWORD *a1, _DWORD *a2, _DWORD *a3, unsigned int a4);
int __cdecl _mpn_addmul_1(int a1, int a2, int a3, unsigned int a4);
unsigned __int64 __cdecl _strtoll_internal(char *a1, char **a2, int a3, int a4);
unsigned __int64 __cdecl strtoq(char *a1, char **a2, int a3);
__int64 __cdecl _strtoull_internal(char *a1, char **a2, int a3, int a4);
__int64 __cdecl strtouq(char *a1, char **a2, int a3);
unsigned __int64 __cdecl ___strtoll_l_internal(char *a1, char **a2, int a3, int a4, _DWORD *a5);
unsigned __int64 __cdecl strtoll_l(char *a1, char **a2, int a3, _DWORD *a4);
__int64 __cdecl ___strtoull_l_internal(char *a1, char **a2, int a3, int a4, _DWORD *a5);
__int64 __cdecl strtoull_l(char *a1, char **a2, int a3, _DWORD *a4);
void __cdecl _strtof_internal(_BYTE *, unsigned int *, int);
void __cdecl strtof(_BYTE *a1, unsigned int *a2);
void __cdecl _strtod_internal(_BYTE *, unsigned int *, int);
void __cdecl strtod(_BYTE *a1, unsigned int *a2);
void __cdecl _strtold_internal(_BYTE *, unsigned int *, int);
void __cdecl strtold(_BYTE *a1, unsigned int *a2);
// long double __usercall round_and_return@<st0>(unsigned int *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, int a4, unsigned int a5, unsigned int a6, int a7);
// _BYTE *__usercall str_to_mpn_isra_0@<eax>(_BYTE *a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>, int *a4, __int64 *a5, int a6, _BYTE *a7);
long double __cdecl ___strtof_l_internal(_BYTE *a1, unsigned int *a2, int a3, _DWORD *a4);
void __cdecl strtof_l(_BYTE *a1, unsigned int *a2, _DWORD *a3);
// long double __usercall round_and_return_0@<st0>(unsigned int *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4, unsigned int a5, int a6, int a7);
// _BYTE *__usercall str_to_mpn_isra_0_0@<eax>(_BYTE *a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>, int *a4, __int64 *a5, int a6, _BYTE *a7);
long double __cdecl ___strtod_l_internal(_BYTE *a1, unsigned int *a2, int a3, _DWORD *a4);
void __cdecl strtod_l(_BYTE *a1, unsigned int *a2, _DWORD *a3);
// long double __usercall round_and_return_1@<st0>(unsigned int *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4, unsigned int a5, int a6, int a7);
// _BYTE *__usercall str_to_mpn_isra_0_1@<eax>(_BYTE *a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>, int *a4, __int64 *a5, int a6, _BYTE *a7);
long double __cdecl ___strtold_l_internal(_BYTE *a1, unsigned int *a2, int a3, _DWORD *a4);
void __cdecl strtold_l(_BYTE *a1, unsigned int *a2, _DWORD *a3);
int init();
// int __usercall _dlerror@<eax>(long double a1@<st0>);
// void __usercall check_free(long double a1@<st0>, int a2);
// int __usercall free_key_mem@<eax>(long double a1@<st0>, int a2);
// _BOOL4 __usercall dlerror_run@<eax>(void (__cdecl *a1)(int)@<eax>, int a2@<edx>, long double a3@<st0>);
// _DWORD *__usercall _libc_register_dlfcn_hook@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5);
int __cdecl _dladdr(unsigned int a1, _DWORD *a2);
int __cdecl _dladdr1(unsigned int a1, _DWORD *a2, int *a3, int a4);
// void *__usercall dlinfo_doit@<eax>(long double a1@<st0>, int a2);
// int __usercall _dlinfo@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5);
// int __usercall dlmopen_doit@<eax>(long double a1@<st0>, _DWORD *a2);
// int __usercall _dlmopen@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, long double a5@<st0>, int a6, int a7, int a8, int a9);
// char *__usercall strerror@<eax>(long double a1@<st0>, signed int a2);
_BYTE *__cdecl strpbrk(int a1, _BYTE *a2);
int (__cdecl *strncasecmp_l())(char *a1, unsigned __int8 *a2, int a3, int a4);
int __cdecl _strncasecmp_l_ia32(char *a1, _BYTE *a2);
int __cdecl _strncasecmp_ssse3(char *a1, unsigned __int8 *a2, int a3);
int __cdecl _strncasecmp_l_ssse3(char *a1, unsigned __int8 *a2, int a3);
int __cdecl _strncasecmp_sse4_2(char *a1, unsigned __int8 *a2, int a3);
int __cdecl _strncasecmp_l_sse4_2(char *a1, unsigned __int8 *a2, int a3, int a4);
unsigned int __cdecl profil_counter(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16);
int __cdecl profil(int a1, unsigned int a2, int a3, int a4);
int _profile_frequency();
// int __usercall add_to_global@<eax>(_DWORD *a1@<eax>);
int __cdecl dl_open(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
__int64 __cdecl dl_show_scope(_DWORD *a1, int a2);
_DWORD *__cdecl dl_open_worker(int a1);
// int __usercall remove_slotinfo@<eax>(int a1@<eax>, unsigned int *a2@<edx>, int a3@<ecx>, char a4);
int *__cdecl dl_close_worker(int a1);
// int __usercall dl_close@<eax>(int a1@<ebp>, long double a2@<st0>, int a3);
long double __cdecl _mpn_construct_float(_DWORD *a1, char a2, unsigned __int8 a3);
long double __cdecl _mpn_construct_double(_DWORD *a1, __int16 a2, unsigned __int8 a3);
long double __cdecl _mpn_construct_long_double(_QWORD *a1, __int16 a2, char a3);
// int __usercall dlopen_doit@<eax>(long double a1@<st0>, int a2);
// int __usercall _dlopen@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, long double a5@<st0>, int a6, int a7, int a8);
int dlclose_doit(); // weak
// int __usercall _dlclose@<eax>(long double a1@<st0>, int a2);
// int (*__usercall dlsym_doit@<eax>(int a1@<edi>, long double a2@<st0>, int a3))(void);
// int __usercall _dlsym@<eax>(long double a1@<st0>, int a2, int a3, int a4);
// int (*__usercall dlvsym_doit@<eax>(int a1@<edi>, long double a2@<st0>, int a3))(void);
// int __usercall _dlvsym@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5);
int __cdecl _strncasecmp_nonascii(char *a1, unsigned __int8 *a2, int a3);
unsigned int __cdecl setitimer(int a1, int a2);
// int __usercall dl_build_local_scope@<eax>(_DWORD *a1@<eax>, int a2@<edx>);
int __cdecl openaux(int a1);
// _BYTE *__userpurge dl_map_object_deps@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5);
// int __usercall call_init@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
// int __userpurge dl_init@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
// int *__userpurge dl_sort_fini@<eax>(int *result@<eax>, size_t a2@<edx>, int a3@<ecx>, int a4);
// int __usercall dl_fini@<eax>(long double a1@<st0>);
// int __userpurge match_symbol@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char *s1, _DWORD *a5, int a6, int a7);
// int __usercall dl_check_map_versions@<eax>(int a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>);
// int __usercall dl_check_all_versions@<eax>(int a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>);
// int __usercall call_dl_lookup@<eax>(long double a1@<st0>, int a2);
// int (*__userpurge do_sym@<eax>(__int32 a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, int i@<edi>, long double a6@<st0>, int a7, int a8))(void);
// int (*__userpurge dl_vsym@<eax>(__int32 a1@<eax>, char *a2@<edx>, unsigned __int8 *a3@<ecx>, int a4@<edi>, long double a5@<st0>, unsigned int a6))(void);
// int (*__usercall dl_sym@<eax>(__int32 a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, int a5@<edi>, long double a6@<st0>))(void);
// char *__usercall read_sleb128@<eax>(char *result@<eax>, _DWORD *a2@<edx>);
// char *__usercall read_encoded_value_with_base@<eax>(char a1@<al>, char *a2@<edx>, char *a3, int *a4);
void init_dwarf_reg_size_table();
// unsigned int __usercall execute_cfa_program@<eax>(unsigned int result@<eax>, unsigned int a2@<edx>, _DWORD *a3, unsigned int a4);
// int __usercall execute_stack_op@<eax>(char *encoded_value_with_base@<eax>, unsigned int a2@<edx>, int a3, int a4);
// int __usercall uw_update_context_1@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall uw_update_context@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall uw_frame_state_for@<eax>(int a1@<eax>, unsigned int a2@<edx>);
// int __usercall uw_init_context_1@<eax>(int a1@<eax>, int a2@<edx>, int a3);
// int __usercall Unwind_ForcedUnwind_Phase2@<eax>(_DWORD *a1@<eax>, int a2@<edx>);
// int __usercall Unwind_RaiseException_Phase2@<eax>(_DWORD *a1@<eax>, int a2@<edx>);
// int __usercall uw_install_context_1@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
int __cdecl Unwind_GetGR(int a1, int a2);
int __cdecl Unwind_GetCFA(int a1);
_DWORD *__cdecl Unwind_SetGR(int a1, int a2, int a3);
int __cdecl Unwind_GetIP(int a1);
int __cdecl Unwind_GetIPInfo(int a1, _DWORD *a2);
int __cdecl Unwind_SetIP(int a1, int a2);
int __cdecl Unwind_GetLanguageSpecificData(int a1);
int __cdecl Unwind_GetRegionStart(int a1);
int __cdecl Unwind_FindEnclosingFunction(int a1);
int __cdecl Unwind_GetDataRelBase(int a1);
int __cdecl Unwind_GetTextRelBase(int a1);
int __cdecl _frame_state_for(int a1, int a2);
int __cdecl Unwind_DebugHook(_DWORD, _DWORD); // weak
// int __usercall Unwind_RaiseException@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3);
// int __usercall Unwind_ForcedUnwind@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3, int a4, int a5);
// void __usercall __noreturn Unwind_Resume(int a1@<eax>, int a2@<edx>, _DWORD *a3);
// void __usercall __noreturn Unwind_Resume_or_Rethrow(int a1@<eax>, int a2@<edx>, _DWORD *a3);
int (__cdecl *__cdecl Unwind_DeleteException(int a1))(int, int);
int __cdecl Unwind_Backtrace(int (__cdecl *a1)(char *, int), int a2);
// int __usercall frame_downheap@<eax>(int result@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3, int a4, int a5);
// unsigned int __usercall frame_heapsort@<eax>(int a1@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3);
// int __usercall size_of_encoded_value@<eax>(char a1@<al>);
// char *__usercall read_encoded_value_with_base_0@<eax>(char a1@<al>, char *a2@<edx>, char *a3, unsigned int *a4);
// int __usercall get_cie_encoding@<eax>(_BYTE *a1@<eax>);
int __cdecl fde_unencoded_compare(int a1, int a2, int a3);
// int __usercall base_from_object_isra_3@<eax>(char a1@<al>, int a2@<edx>, int a3);
// int __usercall classify_object_over_fdes@<eax>(int a1@<eax>, char *a2@<edx>);
// int __usercall add_fdes@<eax>(int a1@<eax>, int *a2@<edx>, _DWORD *a3);
int __cdecl fde_single_encoding_compare(int a1, int a2, int a3);
// int __usercall linear_search_fdes@<eax>(int a1@<eax>, int a2@<edx>, int a3);
// int __usercall base_from_cb_data_isra_4@<eax>(char a1@<al>, int a2@<edx>, int a3);
// int __usercall search_object@<eax>(int a1@<eax>, unsigned int a2@<edx>);
int __cdecl fde_mixed_encoding_compare(int a1, int a2, int a3);
int __cdecl Unwind_IteratePhdrCallback(int *a1, unsigned int a2, int *a3);
int __cdecl _register_frame_info_bases(_DWORD *a1, _DWORD *a2, int a3, int a4);
int __cdecl _register_frame_info(_DWORD *a1, _DWORD *a2);
// void __usercall _register_frame(long double a1@<st0>, _DWORD *a2);
int __cdecl _register_frame_info_table_bases(int a1, _DWORD *a2, int a3, int a4);
int __cdecl _register_frame_info_table(int a1, _DWORD *a2);
// int __usercall _register_frame_table@<eax>(long double a1@<st0>, int a2);
// int __usercall _deregister_frame_info_bases@<eax>(_DWORD *a1@<edx>, int a2@<ecx>, long double a3@<st0>, _DWORD *a4);
int __cdecl _deregister_frame_info(_DWORD); // weak
// void __usercall _deregister_frame(int a1@<ecx>, long double a2@<st0>, _DWORD *a3);
int __cdecl Unwind_Find_FDE(unsigned int a1, _DWORD *a2);
// char *__usercall read_encoded_value_with_base_1@<eax>(char a1@<al>, char *a2@<edx>, char *a3, unsigned int *a4);
int __cdecl _gcc_personality_v0(int a1, char a2, int a3, int a4, int a5, int a6);
int cancel_handler_0();
int __cdecl _dl_iterate_phdr(int (__cdecl *a1)(int *, int, int), int a2);
int __cdecl dl_iterate_phdr(int (__cdecl *a1)(int *, int, int), int a2);
void (*_do_global_ctors_aux())(void);
void arena_thread_freeres();
// void __usercall L_lock_145(int a1@<eax>);
void L_unlock_151();
// void __usercall free_mem(long double a1@<st0>);
// void __usercall L_lock_19(int a1@<eax>);
void L_unlock_30();
// void __usercall free_mem_0(long double a1@<st0>);
// void __usercall nl_finddomain_subfreeres(long double a1@<st0>);
// void __usercall nl_unload_domain(int *a1@<eax>, long double a2@<st0>);
// void __usercall free_mem_1(long double a1@<st0>);
// void __usercall free_mem_2(long double a1@<st0>);
int buffer_free();
// void __usercall free_mem_3(long double a1@<st0>);
// void __usercall free_modules_db(int a1@<eax>, long double a2@<st0>);
// void __usercall free_mem_4(int a1@<ebp>, long double a2@<st0>);
// void __usercall free_derivation(long double a1@<st0>, int a2);
// void __usercall free_mem_5(long double a1@<st0>);
// void __usercall free_mem_6(long double a1@<st0>);
void free_mem_7();
// void __usercall do_release_all(int a1@<ebp>, int a2@<edi>, int a3@<esi>, long double a4@<st0>, int a5);
// void __usercall free_category(int a1@<eax>, char *a2@<edx>, char *a3@<ecx>, long double a4@<st0>);
// void __usercall nl_locale_subfreeres(int a1@<ebp>, long double a2@<st0>);
// void __usercall nl_archive_subfreeres(int a1@<ebp>, long double a2@<st0>);
// int __usercall free_slotinfo@<eax>(int *a1@<eax>, long double a2@<st0>);
// void __usercall free_mem_8(long double a1@<st0>);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

int (**off_8048138)() = &off_80EF040; // weak
char byte_804813C[] = { '*' }; // weak
_UNKNOWN _restore; // weak
_UNKNOWN unk_80C5EC8; // weak
char aBin[5] = "/bin"; // weak
_UNKNOWN intel_02_known; // weak
char **nl_C_locobj[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
char *nl_C_LC_MONETARY = "C"; // weak
char *nl_C_LC_NUMERIC = "C"; // weak
_UNKNOWN unk_80C86D9; // weak
_UNKNOWN _gettext_germanic_plural; // weak
char _strtol_ul_rem_tab[] = { '\x01' }; // weak
int _strtol_ul_max_tab[34] =
{
  2147483647,
  1431655765,
  1073741823,
  858993459,
  715827882,
  613566756,
  536870911,
  477218588,
  429496729,
  390451572,
  357913941,
  330382099,
  306783378,
  286331153,
  268435455,
  252645135,
  238609294,
  226050910,
  214748364,
  204522252,
  195225786,
  186737708,
  178956970,
  171798691,
  165191049,
  159072862,
  153391689,
  148102320,
  143165576,
  138547332,
  134217727,
  130150524,
  126322567,
  122713351
}; // weak
_UNKNOWN unk_80C9508; // weak
char itoa_lower_digits[37] = "0123456789abcdefghijklmnopqrstuvwxyz"; // weak
_UNKNOWN itoa_upper_digits; // weak
_UNKNOWN IO_helper_jumps; // weak
_UNKNOWN unk_80C9C94; // weak
_UNKNOWN unk_80C9C98; // weak
_UNKNOWN unk_80C9C9C; // weak
_UNKNOWN unk_80C9CA0; // weak
_UNKNOWN unk_80C9CA4; // weak
_UNKNOWN unk_80C9CB4; // weak
_UNKNOWN unk_80C9CC4; // weak
_UNKNOWN unk_80C9CD4; // weak
_BYTE byte_80C9CE4[28] =
{
  48,
  0,
  0,
  0,
  46,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_UNKNOWN blanks; // weak
_UNKNOWN IO_mem_jumps; // weak
_UNKNOWN blanks_0; // weak
_UNKNOWN zeroes_0; // weak
_UNKNOWN IO_wfile_jumps_maybe_mmap; // weak
_UNKNOWN IO_wfile_jumps_mmap; // weak
_DWORD IO_wfile_jumps[21] =
{
  0,
  0,
  134656176,
  134649568,
  134646800,
  134643248,
  134642768,
  134648816,
  134651952,
  134645296,
  134662080,
  134654336,
  134649216,
  134917312,
  134655392,
  134652720,
  134650464,
  134652848,
  134652928,
  134665296,
  134665312
}; // weak
_UNKNOWN IO_file_jumps_maybe_mmap; // weak
_UNKNOWN IO_file_jumps_mmap; // weak
_UNKNOWN IO_file_jumps; // weak
_UNKNOWN IO_str_jumps; // weak
__int128 xmmword_80CA9D0 = 0x40404040404040404040404040404040LL; // weak
__int128 xmmword_80CA9E0 = 0x5B5B5B5B5B5B5B5B5B5B5B5B5B5B5B5BLL; // weak
__int128 xmmword_80CA9F0 = 0x20202020202020202020202020202020LL; // weak
void *_wcsmbs_gconv_fcts_c = &to_wc; // weak
char byte_80CAC58 = 'U'; // weak
_UNKNOWN unk_80CAC65; // weak
const char byte_80CAC6D = '.'; // idb
_UNKNOWN curwd_8656; // weak
_UNKNOWN unk_80CAC6F; // weak
size_t system_dirs_len[8] = { 7u, 11u, 5u, 9u, 0u, 0u, 0u, 0u }; // weak
_UNKNOWN expected_8843; // weak
_UNKNOWN unk_80CCD8D; // weak
_UNKNOWN expected2_8842; // weak
_UNKNOWN expected_note_8849; // weak
_UNKNOWN dummy_bucket_8949; // weak
char *internal_trans_names_7159 = "INTERNAL"; // weak
int gconv_module_ext = 7303982; // weak
_UNKNOWN empty_path_elem; // weak
char *map_0 = "=INTERNAL->ucs4"; // weak
int (__cdecl *off_80CE024[47])(int, int, int, int, int, int, int, int) =
{
  &_gconv_transform_internal_ucs4,
  NULL,
  (int (__cdecl *)(int, int, int, int, int, int, int, int))0x4040404,
  &aUcs4Internal,
  &_gconv_transform_ucs4_internal,
  NULL,
  (int (__cdecl *)(int, int, int, int, int, int, int, int))0x4040404,
  &aInternalUcs4le,
  &_gconv_transform_internal_ucs4le,
  NULL,
  (int (__cdecl *)(int, int, int, int, int, int, int, int))0x4040404,
  &aUcs4leInternal,
  &_gconv_transform_ucs4le_internal,
  NULL,
  (int (__cdecl *)(int, int, int, int, int, int, int, int))0x4040404,
  &aInternalUtf8,
  &_gconv_transform_internal_utf8,
  NULL,
  (int (__cdecl *)(int, int, int, int, int, int, int, int))0x6010404,
  &aUtf8Internal,
  &_gconv_transform_utf8_internal,
  &_gconv_btwoc_ascii,
  (int (__cdecl *)(int, int, int, int, int, int, int, int))0x4040601,
  &unk_80CDB1F,
  &_gconv_transform_ucs2_internal,
  NULL,
  (int (__cdecl *)(int, int, int, int, int, int, int, int))0x4040202,
  &aInternalUcs2,
  &_gconv_transform_internal_ucs2,
  NULL,
  (int (__cdecl *)(int, int, int, int, int, int, int, int))0x2020404,
  &aAsciiInternal,
  &_gconv_transform_ascii_internal,
  &_gconv_btwoc_ascii,
  (int (__cdecl *)(int, int, int, int, int, int, int, int))0x1010404,
  &aInternalAscii,
  &_gconv_transform_internal_ascii,
  NULL,
  (int (__cdecl *)(int, int, int, int, int, int, int, int))0x1010404,
  &aUcs2reverseInt,
  &_gconv_transform_ucs2reverse_internal,
  NULL,
  (int (__cdecl *)(int, int, int, int, int, int, int, int))0x4040202,
  &aInternalUcs2re,
  &_gconv_transform_internal_ucs2reverse,
  NULL,
  (int (__cdecl *)(int, int, int, int, int, int, int, int))0x2020404
}; // weak
_DWORD dword_80CE028[46] =
{
  0,
  67372036,
  135060129,
  134815936,
  0,
  67372036,
  135060155,
  134817264,
  0,
  67372036,
  135060173,
  134818352,
  0,
  67372036,
  135060207,
  134823120,
  0,
  100729860,
  135060223,
  134826560,
  134814832,
  67372545,
  135060255,
  134830384,
  0,
  67371522,
  135060271,
  134832048,
  0,
  33686532,
  135060304,
  134819696,
  134814832,
  16843780,
  135060321,
  134820736,
  0,
  16843780,
  135060351,
  134834512,
  0,
  67371522,
  135060374,
  134836112,
  0,
  33686532
}; // weak
char byte_80CE57E[] = { '\0' }; // weak
char byte_80CE6BF[] = { '\0' }; // weak
char nl_category_name_sizes[12] = { '\b', '\n', '\a', '\n', '\v', '\v', '\x06', '\b', '\a', '\n', '\f', '\x0E' }; // weak
char byte_80CE6CC[] = { '\x11' }; // weak
char nl_category_name_idxs[19] =
{
  '\v',
  ' ',
  '+',
  '\0',
  '\x14',
  '3',
  '\0',
  '?',
  'H',
  'P',
  '[',
  'h',
  'w',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_BYTE byte_80CE769[3] = { 76, 79, 67 }; // weak
int nl_current_used[16] = { 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int (*nl_category_postload[13])() =
{
  &nl_postload_ctype,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // weak
char **nl_C[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
int codeset_idx_8258[13] = { 14, 5, 110, 18, 45, 4, 0, 2, 6, 12, 4, 1, 15 }; // weak
int nl_category_num_items[16] = { 86, 6, 111, 19, 46, 5, 0, 3, 7, 13, 5, 2, 16, 0, 0, 0 }; // weak
void *nl_value_types = &nl_value_type_LC_CTYPE; // weak
char *nl_C_LC_CTYPE = "C"; // weak
int dword_80CFDC0[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // weak
_DWORD dword_80D03C0[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // weak
_BYTE byte_80D0CC0[512] =
{
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  3,
  32,
  2,
  32,
  2,
  32,
  2,
  32,
  2,
  32,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  1,
  96,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_UNKNOWN unk_80DAF1A; // weak
int fpioconst_pow10[4] = { 0, 3, 4, 0 }; // weak
_UNKNOWN unk_80DB6D0; // weak
_UNKNOWN unk_80DB790; // weak
_BYTE _tens[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
unsigned int dword_80DB7A8[886] =
{
  10u,
  0u,
  0u,
  100u,
  0u,
  0u,
  10000u,
  0u,
  0u,
  100000000u,
  0u,
  0u,
  1874919424u,
  2328306u,
  0u,
  0u,
  0u,
  2242703233u,
  762134875u,
  1262u,
  0u,
  0u,
  0u,
  0u,
  3211403009u,
  1849224548u,
  3668416493u,
  3913284084u,
  1593091u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  781532673u,
  64985353u,
  253049085u,
  594863151u,
  3553621484u,
  3288652808u,
  3167596762u,
  2788392729u,
  3911132675u,
  590u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2553183233u,
  3201533787u,
  3638140786u,
  303378311u,
  1809731782u,
  3477761648u,
  3583367183u,
  649228654u,
  2915460784u,
  487929380u,
  1011012442u,
  1677677582u,
  3428152256u,
  1710878487u,
  1438394610u,
  2161952759u,
  4100910556u,
  1608314830u,
  349175u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  4234999809u,
  2012377703u,
  2408924892u,
  1570150255u,
  3090844311u,
  3273530073u,
  1187251475u,
  2498123591u,
  3364452033u,
  1148564857u,
  687371067u,
  2854068671u,
  1883165473u,
  505794538u,
  2988060450u,
  3159489326u,
  2531348317u,
  3215191468u,
  849106862u,
  3892080979u,
  3288073877u,
  2242451748u,
  4183778142u,
  2995818208u,
  2477501924u,
  325481258u,
  2487842652u,
  1774082830u,
  1933815724u,
  2962865281u,
  1168579910u,
  2724829000u,
  2360374019u,
  2315984659u,
  2360052375u,
  3251779801u,
  1664357844u,
  28u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  689565697u,
  4116392818u,
  1853628763u,
  516071302u,
  2568769159u,
  365238920u,
  336250165u,
  1283268122u,
  3425490969u,
  248595470u,
  2305176814u,
  2111925499u,
  507770399u,
  2681111421u,
  589114268u,
  591287751u,
  1708941527u,
  4098957707u,
  475844916u,
  3378731398u,
  2452339615u,
  2817037361u,
  2678008327u,
  1656645978u,
  2383430340u,
  73103988u,
  448667107u,
  2329420453u,
  3124020241u,
  3625235717u,
  3208634035u,
  2412059158u,
  2981664444u,
  4117622508u,
  838560765u,
  3069470027u,
  270153238u,
  1802868219u,
  3692709886u,
  2161737865u,
  2159912357u,
  2585798786u,
  837488486u,
  4237238160u,
  2540319504u,
  3798629246u,
  3748148874u,
  1021550776u,
  2386715342u,
  1973637538u,
  1823520457u,
  1146713475u,
  833971519u,
  3277251466u,
  905620390u,
  26278816u,
  2680483154u,
  2294040859u,
  373297482u,
  5996609u,
  4109575006u,
  512575049u,
  917036550u,
  1942311753u,
  2816916778u,
  3248920332u,
  1192784020u,
  3537586671u,
  2456567643u,
  2925660628u,
  759380297u,
  888447942u,
  3559939476u,
  3654687237u,
  805u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  322166785u,
  3809044581u,
  2994556223u,
  1239584207u,
  3962455841u,
  4001882964u,
  3053876612u,
  915114683u,
  2783289745u,
  785739093u,
  4253185907u,
  3931164994u,
  1370983858u,
  2553556126u,
  3360742076u,
  2255410929u,
  422849554u,
  2457422215u,
  3539495362u,
  1720790602u,
  1908931983u,
  1470596141u,
  592794347u,
  4219465164u,
  4085652704u,
  941661409u,
  2534650953u,
  885063988u,
  2355909854u,
  2812815516u,
  767256131u,
  3821757683u,
  2155151105u,
  3817418473u,
  281116564u,
  2834395026u,
  2821201622u,
  2524625843u,
  1511330880u,
  2572352493u,
  330571332u,
  2951088579u,
  2730271766u,
  4044456479u,
  4212286644u,
  2444937588u,
  3603420843u,
  2387148597u,
  1142537539u,
  3299235429u,
  1751012624u,
  861228086u,
  2873722519u,
  230498814u,
  1023297821u,
  2553128038u,
  3421129895u,
  2651917435u,
  2042981258u,
  1606787143u,
  2228751918u,
  447345732u,
  1930371132u,
  1784132011u,
  3612538790u,
  2275925090u,
  2487567871u,
  1080427616u,
  2009179183u,
  3383506781u,
  3899054063u,
  1950782960u,
  2168622213u,
  2717674390u,
  3616636027u,
  2079341593u,
  1530129217u,
  1461057425u,
  2406264415u,
  3674671357u,
  2972036238u,
  2019354295u,
  1455849819u,
  1866918619u,
  1324269294u,
  424891864u,
  2722422332u,
  2641594816u,
  1400249021u,
  3482963993u,
  3734946379u,
  225889849u,
  1891545473u,
  777383150u,
  3589824633u,
  4117601611u,
  4220028667u,
  334453379u,
  1083130821u,
  1060342180u,
  4208163139u,
  1489826908u,
  4163762246u,
  1096580926u,
  689301528u,
  2336054516u,
  1782865703u,
  4175148410u,
  3398369392u,
  2329412588u,
  3001580596u,
  59740741u,
  3202189932u,
  3351895776u,
  246185302u,
  718535188u,
  3772647488u,
  4151666556u,
  4055698133u,
  2461934110u,
  2281316281u,
  3466396836u,
  3536023465u,
  1064267812u,
  2955456354u,
  2423805422u,
  3627960790u,
  1325057500u,
  3876919979u,
  2009959531u,
  175455101u,
  184092852u,
  2358785571u,
  3842977831u,
  2485266289u,
  487121622u,
  4159252710u,
  4075707558u,
  459389244u,
  300652075u,
  2521346588u,
  3458976673u,
  888631636u,
  2076098096u,
  3844514585u,
  2363697580u,
  3729421522u,
  3051115477u,
  649395u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  711442433u,
  3564261005u,
  2399042279u,
  4170849936u,
  4010295575u,
  1423987028u,
  330414929u,
  1349249065u,
  4213813618u,
  3852031822u,
  4040843590u,
  2154565331u,
  3094013374u,
  1159028371u,
  3227065538u,
  2115927092u,
  2085102554u,
  488590542u,
  2609619432u,
  3602898805u,
  3812736528u,
  3269439096u,
  23816114u,
  253984538u,
  1035905997u,
  2942969204u,
  3400787671u,
  338562688u,
  1637191975u,
  740509713u,
  2264962817u,
  3410753922u,
  4162231428u,
  2282041228u,
  1759373012u,
  3155367777u,
  4278913285u,
  1420532801u,
  1981002276u,
  438054990u,
  1006507643u,
  1142697287u,
  1332538012u,
  2029019521u,
  3949305784u,
  818392641u,
  2491288846u,
  2716584663u,
  3648886102u,
  556814413u,
  444795339u,
  4071412999u,
  1066321706u,
  4253169466u,
  2510832316u,
  672091442u,
  4083256000u,
  2165985028u,
  1841538484u,
  3549854235u,
  364431512u,
  3707648143u,
  1162785440u,
  2268641545u,
  281340310u,
  735693841u,
  848809228u,
  1700785200u,
  2919703985u,
  4094234344u,
  58530286u,
  965505005u,
  1000010347u,
  3381961808u,
  3040089923u,
  1973852082u,
  2890971585u,
  1019960210u,
  4292895237u,
  2821887841u,
  3756675650u,
  3951282907u,
  3885870583u,
  1008791145u,
  503998487u,
  1881258362u,
  1949332730u,
  392996726u,
  2012973814u,
  3970014187u,
  2461725150u,
  2942547730u,
  3728066699u,
  2766901132u,
  3778532841u,
  1085564064u,
  2278673896u,
  1116879805u,
  3448726271u,
  774279411u,
  157211670u,
  1506320155u,
  531168605u,
  1362654525u,
  956967721u,
  2148871960u,
  769186085u,
  4186232894u,
  2055679604u,
  3248365487u,
  3981268013u,
  3975787984u,
  2489510517u,
  3309046495u,
  212771124u,
  933418041u,
  3371839114u,
  562115198u,
  1853601831u,
  757336096u,
  1354633440u,
  1486083256u,
  2872126393u,
  522920738u,
  1141587749u,
  3210903262u,
  1926940553u,
  3054024853u,
  2021162538u,
  2262742000u,
  1877899947u,
  3147002868u,
  669840763u,
  4158174590u,
  4238502559u,
  1023731922u,
  3386840011u,
  829588074u,
  3449720188u,
  2835142880u,
  2999162007u,
  813056473u,
  482949569u,
  638108879u,
  3067201471u,
  1026714238u,
  4004452838u,
  2383667807u,
  3999477803u,
  771648919u,
  630660440u,
  3827121348u,
  176185980u,
  2878191002u,
  2666149832u,
  3909811063u,
  2429163983u,
  2665690412u,
  907266128u,
  4269332098u,
  2022665808u,
  1527122180u,
  3072053668u,
  1072477492u,
  3006022924u,
  549664855u,
  2800340954u,
  37352654u,
  1212772743u,
  2711280533u,
  3029527946u,
  2511120040u,
  1305308377u,
  3474662224u,
  4226330922u,
  442988428u,
  954940108u,
  3274548099u,
  4212288177u,
  2688499880u,
  3982226758u,
  3922609956u,
  1279948029u,
  1939943640u,
  3650489901u,
  2733364929u,
  2494263275u,
  1864579964u,
  1225941120u,
  2390465139u,
  1267503249u,
  3533240729u,
  904410805u,
  2842550015u,
  2517736241u,
  1796069820u,
  3335274381u,
  673539835u,
  1924694759u,
  3598098235u,
  2792633405u,
  16535707u,
  3703535497u,
  3592841791u,
  2929082877u,
  1317622811u,
  294990855u,
  1396706563u,
  2383271770u,
  3853857605u,
  277813677u,
  277580220u,
  1101318484u,
  3761974115u,
  1132150143u,
  2544692622u,
  3419825776u,
  743770306u,
  1695464553u,
  1548693232u,
  2421159615u,
  2575672031u,
  2678971806u,
  1591267897u,
  626546738u,
  3823443129u,
  267710932u,
  1455435162u,
  2353985540u,
  3248523795u,
  335348168u,
  3872552561u,
  2814522612u,
  2634118860u,
  3503767026u,
  1301019273u,
  1414467789u,
  722985138u,
  3070909565u,
  4253482569u,
  3744939841u,
  558142907u,
  2229819389u,
  13833173u,
  77003966u,
  2763671364u,
  3905603970u,
  2931990126u,
  2280419384u,
  1879090457u,
  2934846267u,
  4284933164u,
  2331863845u,
  62191163u,
  3178861020u,
  1522063815u,
  785672270u,
  1215568492u,
  2936443917u,
  802972489u,
  2956820173u,
  3916732783u,
  2893572089u,
  1391232801u,
  3168640330u,
  2396859648u,
  894950918u,
  1103583736u,
  961991865u,
  2807302642u,
  305977505u,
  3054505899u,
  1048256994u,
  781017659u,
  2459278754u,
  3164823415u,
  537658277u,
  905753687u,
  464963300u,
  4149131560u,
  1029507924u,
  2278300961u,
  1231291503u,
  414073408u,
  3630740085u,
  2345841814u,
  475358196u,
  3258243317u,
  4167625072u,
  4178911231u,
  2927355042u,
  655438830u,
  3138378018u,
  623200562u,
  2785714112u,
  273403236u,
  807993669u,
  98u,
  0u,
  0u,
  0u,
  0u
}; // weak
_UNKNOWN itowa_upper_digits; // weak
int itowa_lower_digits[36] =
{
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122
}; // weak
_UNKNOWN unk_80DC970; // weak
char jump_table_10848[91] =
{
  '\x01',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\x0E',
  '\0',
  '\x06',
  '\0',
  '\0',
  '\a',
  '\x02',
  '\0',
  '\x03',
  '\t',
  '\0',
  '\x05',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1A',
  '\0',
  '\x19',
  '\0',
  '\x13',
  '\x13',
  '\x13',
  '\0',
  '\x1D',
  '\0',
  '\0',
  '\f',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x15',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x12',
  '\0',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1A',
  '\0',
  '\x14',
  '\x0F',
  '\x13',
  '\x13',
  '\x13',
  '\n',
  '\x0F',
  '\x1C',
  '\0',
  '\v',
  '\x18',
  '\x17',
  '\x11',
  '\x16',
  '\f',
  '\0',
  '\x15',
  '\x1B',
  '\x10',
  '\0',
  '\0',
  '\x12',
  '\0',
  '\r'
}; // weak
_UNKNOWN IO_helper_jumps_0; // weak
const char *const sys_errlist[] = { "Success" };
int sys_nerr = 135; // weak
int (__cdecl *_libio_translit)(int, int, int, int, int, int, int, int) = &_gconv_transliterate; // weak
_UNKNOWN _libio_codecvt; // weak
int CSWTCH_11[8] = { 0, 2, 2, 2, 0, 1, 2, 1 }; // weak
int CSWTCH_13[8] = { 0, 2, 2, 2, 0, 1, 2, 1 }; // weak
int CSWTCH_15[8] = { 0, 2, 2, 2, 0, 1, 2, 1 }; // weak
__int128 __m128i_shift_right = 0xF0E0D0C0B0A09080706050403020100LL; // weak
__int16 word_80DE01E[] = { 0 }; // weak
__int16 _mon_yday[13] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 }; // weak
_UNKNOWN unk_80DE03A; // weak
char _strtol_ull_rem_tab[] = { '\x01' }; // weak
int _strtol_ull_max_tab[] = { -1 }; // weak
int dword_80DE204[69] =
{
  2147483647,
  1431655765,
  1431655765,
  -1,
  1073741823,
  858993459,
  858993459,
  -1431655766,
  715827882,
  -1840700270,
  613566756,
  -1,
  536870911,
  1908874353,
  477218588,
  -1717986919,
  429496729,
  1561806289,
  390451572,
  1431655765,
  357913941,
  -1321528399,
  330382099,
  1227133513,
  306783378,
  286331153,
  286331153,
  -1,
  268435455,
  252645135,
  252645135,
  954437176,
  238609294,
  1356305461,
  226050910,
  -858993460,
  214748364,
  818089008,
  204522252,
  780903144,
  195225786,
  -2054114794,
  186737708,
  -1431655766,
  178956970,
  -687194768,
  171798691,
  -660764200,
  165191049,
  -795364315,
  159072862,
  613566756,
  153391689,
  -1925330168,
  148102320,
  -2004318072,
  143165576,
  554189328,
  138547332,
  -1,
  134217727,
  520602096,
  130150524,
  -2021161081,
  126322567,
  1349846864,
  122713351,
  477218588,
  119304647
}; // weak
int nbits_9430[16] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4 }; // weak
int nbits_9419[16] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4 }; // weak
_UNKNOWN unk_80DE720; // weak
int nbits_9419_0[16] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4 }; // weak
int tens_in_limb[10] = { 0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 }; // weak
int (*_elf_set___libc_atexit_element__IO_cleanup__)() = &IO_cleanup; // weak
_DWORD _EH_FRAME_BEGIN__[14696] =
{
  20,
  0,
  5405185,
  17333249,
  67374107,
  392,
  28,
  28,
  -615124,
  36,
  135151872,
  222429829,
  214261765,
  1028,
  28,
  60,
  -615120,
  26,
  135151872,
  222429829,
  67917317,
  50436,
  28,
  92,
  -615126,
  45,
  135151872,
  222429829,
  67922181,
  50436,
  28,
  124,
  -615113,
  41,
  135151872,
  222429829,
  214263045,
  1028,
  28,
  156,
  -615104,
  41,
  135151872,
  222429829,
  214263045,
  1028,
  28,
  188,
  -615095,
  25,
  135151872,
  222429829,
  214258949,
  1028,
  36,
  220,
  -615092,
  591,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  40,
  260,
  -614540,
  228,
  -1878112768,
  92489217,
  1493468745,
  59179653,
  68029033,
  -1010382907,
  2881,
  20,
  304,
  -614344,
  48,
  269370112,
  265832,
  60,
  328,
  -614320,
  542,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  167893763,
  239145998,
  239190800,
  239191564,
  239191816,
  188925188,
  16,
  392,
  -613840,
  86,
  0,
  20,
  412,
  -613764,
  27,
  537805568,
  265815,
  52,
  436,
  -613756,
  95,
  135151872,
  239469191,
  1191413260,
  75698190,
  2065698374,
  1091571210,
  1103301646,
  1103497230,
  1103561742,
  11,
  56,
  492,
  -613716,
  155,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  336498434,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  28,
  552,
  -613616,
  45,
  135151872,
  239993475,
  135157776,
  -1023144383,
  16,
  584,
  -613600,
  54,
  0,
  32,
  604,
  -613556,
  233,
  135151872,
  239141511,
  1090749964,
  75698190,
  3149379,
  16,
  640,
  -613352,
  31,
  537805568,
  16,
  0,
  5405185,
  17333249,
  265243,
  44,
  24,
  -612917,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1156774280,
  486536869,
  -157017843,
  8959,
  44,
  72,
  -612949,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -2029189512,
  486536869,
  -156994803,
  8959,
  60,
  776,
  -613456,
  317,
  135151872,
  239272581,
  1174636300,
  75894798,
  -2095837631,
  806241029,
  235584770,
  269370132,
  202260931,
  135152070,
  68043207,
  739269,
  24,
  840,
  -613200,
  69,
  537805568,
  68029050,
  2881,
  20,
  868,
  -613148,
  43,
  537805568,
  265831,
  44,
  892,
  -613092,
  911,
  135151872,
  222429829,
  92490757,
  59180166,
  167884547,
  1103512003,
  67912135,
  188859652,
  24,
  940,
  -612228,
  34,
  135151872,
  239272579,
  32,
  44,
  312,
  -588090,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1576204680,
  486536966,
  -156716019,
  8959,
  44,
  360,
  -588122,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1779238520,
  486536966,
  -156723443,
  8959,
  44,
  408,
  -107019,
  13,
  34084352,
  373689208,
  91750920,
  235411012,
  -1458764168,
  486538845,
  -27430643,
  8959,
  44,
  456,
  -107054,
  13,
  34084352,
  373689208,
  91750920,
  235411012,
  1913456248,
  486538845,
  -27438579,
  8959,
  44,
  504,
  -588254,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1441986952,
  486536965,
  -156341235,
  8959,
  44,
  552,
  -588290,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1913456248,
  486536965,
  -156240115,
  8959,
  44,
  600,
  -588326,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  973932152,
  486536965,
  -156020979,
  8959,
  44,
  648,
  -588362,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  101516920,
  486536965,
  -156028659,
  8959,
  44,
  696,
  -588394,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -838007176,
  486536964,
  -155290611,
  8959,
  44,
  744,
  -588430,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1777531272,
  486536964,
  -155246835,
  8959,
  44,
  792,
  -588466,
  13,
  34084352,
  373491832,
  91750920,
  235411012,
  1594689144,
  486536964,
  -155150835,
  8959,
  44,
  840,
  -588501,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  655165048,
  486536964,
  -155157235,
  8959,
  44,
  888,
  -588537,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -284359048,
  486536963,
  -155160307,
  8959,
  44,
  936,
  -588573,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1156774280,
  486536963,
  -153914611,
  8959,
  44,
  984,
  -588605,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -2029189512,
  486536963,
  -153919219,
  8959,
  44,
  1032,
  -588637,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1393362552,
  486536963,
  -153756147,
  8959,
  44,
  1080,
  -588669,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  520947320,
  486536963,
  -153760243,
  8959,
  44,
  1128,
  -588701,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -351467912,
  486536962,
  -153484787,
  8959,
  44,
  1176,
  -588733,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1223883144,
  486536962,
  -153486835,
  8959,
  44,
  1224,
  -588765,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -2096298376,
  486536962,
  -153495795,
  8959,
  44,
  1272,
  -588797,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1326253688,
  486536962,
  -153502963,
  8959,
  44,
  1320,
  -588829,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  453838456,
  486536962,
  -153490419,
  8959,
  44,
  1368,
  -588861,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -418576776,
  486536961,
  -153497843,
  8959,
  44,
  1416,
  -588893,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1290992008,
  486536961,
  -153490675,
  8959,
  44,
  1464,
  -588925,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  2131560056,
  486536961,
  -153485555,
  8959,
  44,
  1512,
  -588957,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1259144824,
  486536961,
  -153426163,
  8959,
  44,
  1560,
  -588989,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  386729592,
  486536961,
  -153432051,
  8959,
  44,
  1608,
  -589021,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -552794504,
  486536960,
  -153441523,
  8959,
  44,
  1656,
  -589057,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1492318600,
  486536960,
  -153409011,
  8959,
  44,
  1704,
  -589093,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1863124600,
  486536960,
  -153352691,
  8959,
  44,
  1752,
  -589129,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  990709368,
  486536960,
  -153362931,
  8959,
  44,
  1800,
  -589161,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  118294136,
  486536960,
  -153369843,
  8959,
  44,
  1848,
  -589193,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -754121096,
  486536959,
  -153082355,
  8959,
  44,
  1896,
  -589225,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1626536328,
  486536959,
  -153086195,
  8959,
  44,
  1944,
  -589257,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1796015736,
  486536959,
  -153004787,
  8959,
  44,
  1992,
  -589289,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  923600504,
  486536959,
  -152816627,
  8959,
  44,
  2040,
  -589321,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -15923592,
  486536958,
  -152763123,
  8959,
  44,
  2088,
  -589357,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -955447688,
  486536958,
  -152771571,
  8959,
  44,
  2136,
  -589393,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1894971784,
  486536958,
  -152765683,
  8959,
  44,
  2184,
  -589429,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1527580280,
  486536958,
  -152775155,
  8959,
  44,
  2232,
  -589461,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  655165048,
  486536958,
  -152782835,
  8959,
  44,
  2280,
  -589493,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -217250184,
  486536957,
  -152778483,
  8959,
  44,
  2328,
  -589525,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1156774280,
  486536957,
  -152782323,
  8959,
  44,
  2376,
  -589561,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -2029189512,
  486536957,
  -152772339,
  8959,
  44,
  2424,
  -589593,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1393362552,
  486536957,
  -152783603,
  8959,
  44,
  2472,
  -589625,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  520947320,
  486536957,
  -152751859,
  8959,
  44,
  2520,
  -589657,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -351467912,
  486536956,
  -152678387,
  8959,
  44,
  2568,
  -589689,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1290992008,
  486536956,
  -152607219,
  8959,
  44,
  2616,
  -589725,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  2064451192,
  486536956,
  -152613875,
  8959,
  44,
  2664,
  -589761,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1124927096,
  486536956,
  -152482547,
  8959,
  44,
  2712,
  -589797,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  185403000,
  486536956,
  -152490483,
  8959,
  44,
  2760,
  -589833,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -754121096,
  486536955,
  -152475891,
  8959,
  44,
  2808,
  -589869,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1626536328,
  486536955,
  -152485363,
  8959,
  44,
  2856,
  -589901,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1796015736,
  486536955,
  -152492531,
  8959,
  44,
  2904,
  -589933,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  923600504,
  486536955,
  -152478451,
  8959,
  44,
  2952,
  -589965,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -15923592,
  486536954,
  -152481779,
  8959,
  44,
  3000,
  -590001,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -955447688,
  486536954,
  -152450035,
  8959,
  44,
  3048,
  -590037,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1894971784,
  486536954,
  -152455411,
  8959,
  44,
  3096,
  -590073,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1460471416,
  486536954,
  -152444147,
  8959,
  44,
  3144,
  -590109,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  588056184,
  486536954,
  -152453619,
  8959,
  44,
  3192,
  -590141,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -284359048,
  486536953,
  -152460787,
  8959,
  44,
  3240,
  -590173,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1156774280,
  486536953,
  -152450803,
  8959,
  44,
  3288,
  -590205,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -2096298376,
  486536953,
  -152454131,
  8959,
  44,
  3336,
  -590241,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1259144824,
  486536953,
  -152425971,
  8959,
  44,
  3384,
  -590277,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  319620728,
  486536953,
  -152428275,
  8959,
  44,
  3432,
  -590313,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -619903368,
  486536952,
  -152416499,
  8959,
  44,
  3480,
  -590349,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1492318600,
  486536952,
  -152425971,
  8959,
  44,
  3528,
  -590381,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1930233464,
  486536952,
  -152433139,
  8959,
  44,
  3576,
  -590413,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1057818232,
  486536952,
  -152425203,
  8959,
  44,
  3624,
  -590445,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  118294136,
  486536952,
  -152426995,
  8959,
  44,
  3672,
  -590481,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -821229960,
  486536951,
  -152400627,
  8959,
  44,
  3720,
  -590517,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1760754056,
  486536951,
  -152390131,
  8959,
  44,
  3768,
  -590553,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1594689144,
  486536951,
  -152349939,
  8959,
  44,
  3816,
  -590589,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  722273912,
  486536951,
  -152359411,
  8959,
  44,
  3864,
  -590621,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -150141320,
  486536950,
  -152366579,
  8959,
  44,
  3912,
  -590653,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1022556552,
  486536950,
  -152346355,
  8959,
  44,
  3960,
  -590685,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1962080648,
  486536950,
  -152349171,
  8959,
  44,
  4008,
  -590721,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1393362552,
  486536950,
  -152307187,
  8959,
  44,
  4056,
  -590757,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  453838456,
  486536950,
  -152250867,
  8959,
  44,
  4104,
  -590793,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -485685640,
  486536949,
  -152163059,
  8959,
  44,
  4152,
  -590829,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1425209736,
  486536949,
  -152147187,
  8959,
  44,
  4200,
  -590865,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1997342328,
  486536949,
  -152099059,
  8959,
  44,
  4248,
  -590897,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1124927096,
  486536949,
  -152107251,
  8959,
  44,
  4952,
  -616192,
  208,
  135153152,
  239141511,
  1090749964,
  75698190,
  202294530,
  135152067,
  68043206,
  199,
  16,
  5000,
  -616032,
  123,
  0,
  16,
  5020,
  -111060,
  85,
  0,
  32,
  5040,
  -615944,
  89,
  135151872,
  239272582,
  33784588,
  -1022882221,
  -972812735,
  84,
  5076,
  -615884,
  641,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  604914437,
  167839491,
  239277070,
  239190800,
  239191564,
  239191816,
  188925188,
  167851267,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189072398,
  36,
  5164,
  -615316,
  122,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  40,
  5204,
  -615228,
  518,
  1074676480,
  1342473801,
  -2058484857,
  33915650,
  68029093,
  -1010382907,
  2881,
  64,
  5248,
  -614744,
  1074,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -2146548219,
  57738002,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  11,
  36,
  5316,
  -613724,
  280,
  537805568,
  1174570829,
  -2091908218,
  176161284,
  -960035826,
  737987,
  16,
  5356,
  -613476,
  132,
  0,
  40,
  5376,
  -613352,
  194,
  1074676480,
  1275429702,
  75891591,
  33719622,
  68029000,
  -1010382907,
  2885,
  56,
  5420,
  -613188,
  201,
  135151872,
  239141510,
  1208189708,
  173690894,
  239143950,
  239190792,
  188925444,
  235567618,
  247677196,
  247873800,
  738308,
  40,
  5480,
  -613040,
  278,
  806241024,
  1476756306,
  59179653,
  -1023277946,
  -989590006,
  1220789959,
  11,
  84,
  5524,
  -612796,
  763,
  135151872,
  239272581,
  1174636300,
  75894798,
  -2095837631,
  1343111941,
  167867139,
  239145998,
  239190800,
  239191564,
  239191816,
  188990724,
  336464473,
  269402945,
  202294849,
  135186241,
  68076865,
  2883,
  60,
  5612,
  -612116,
  284,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235601154,
  269369620,
  202260931,
  135152070,
  68043207,
  737733,
  36,
  5676,
  -611892,
  142,
  537805568,
  -2096986544,
  172098051,
  -1010433010,
  242420545,
  12830212,
  132,
  5716,
  -611788,
  2459,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879983365,
  235592706,
  269369620,
  202260931,
  135152070,
  68043207,
  51070917,
  235537419,
  247677204,
  247873808,
  247939340,
  247808264,
  1124811012,
  1125387786,
  1103302670,
  1103498254,
  1103562766,
  1204093966,
  17564427,
  1175719434,
  1103302670,
  1103498254,
  1103562766,
  1170539534,
  11,
  108,
  5852,
  -609460,
  4227,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837629,
  -1609677307,
  180093441,
  239277070,
  239190800,
  239191564,
  239191816,
  188925188,
  168084227,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  235591170,
  247677716,
  247873808,
  247939340,
  247808264,
  737540,
  40,
  5964,
  -605332,
  131,
  135151872,
  239272579,
  173867536,
  239273998,
  189580036,
  1124601423,
  12780558,
  52,
  6008,
  -605232,
  574,
  1074676480,
  1443201865,
  59179653,
  1258488966,
  68028929,
  -1010382907,
  1157761859,
  -989590006,
  1271121607,
  11,
  44,
  6064,
  -604712,
  210,
  269370112,
  1208125000,
  2130838403,
  -972812790,
  1460356803,
  -972812790,
  1493912003,
  -1010433010,
  40,
  6112,
  -604536,
  928,
  1074676480,
  1225033286,
  -2058287741,
  50562818,
  235536865,
  -959986428,
  738499,
  16,
  6156,
  -603652,
  74,
  0,
  52,
  6176,
  -603592,
  197,
  135151872,
  239272579,
  174457360,
  239142926,
  189121284,
  135137883,
  -1023144381,
  241175370,
  68043528,
  195,
  40,
  6232,
  -603440,
  560,
  1611547392,
  1426424648,
  59179653,
  805504134,
  68028929,
  -1010382907,
  2888,
  72,
  6276,
  -602924,
  751,
  135151872,
  239141511,
  1124304396,
  75698190,
  35655235,
  269355647,
  -1022620093,
  -972550591,
  -956035519,
  -2013131964,
  1125125642,
  1091309251,
  1091047110,
  1124339399,
  11,
  16,
  6352,
  -602248,
  75,
  0,
  84,
  6372,
  -602188,
  970,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  336464460,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  -1459483839,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  11,
  32,
  6460,
  -601300,
  402,
  269370112,
  1258521414,
  1761739398,
  -972812790,
  738243,
  84,
  6496,
  -600920,
  1074,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  167998211,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  235570178,
  247678484,
  247873808,
  247939340,
  247808264,
  737540,
  36,
  6584,
  -599920,
  459,
  537805568,
  1308853839,
  75694727,
  235566594,
  -1010383100,
  2882,
  60,
  6624,
  -599496,
  160,
  135151872,
  239272579,
  172818960,
  239142926,
  189186820,
  135137871,
  -1023144381,
  173607758,
  239273998,
  189121284,
  1124601411,
  12780558,
  28,
  6688,
  -599400,
  36,
  135151872,
  239272579,
  135158288,
  -1023144383,
  40,
  6720,
  -599384,
  421,
  135151872,
  239141510,
  1124303628,
  -1694294002,
  1124863489,
  1103300622,
  12977166,
  32,
  6764,
  -598996,
  140,
  537805568,
  68029044,
  175049545,
  189072398,
  265815,
  52,
  6800,
  -598888,
  618,
  1074676480,
  1208320847,
  -2058484857,
  33850882,
  68029170,
  -1010382907,
  -285078714,
  -989590006,
  1237567175,
  11,
  28,
  6856,
  -598320,
  68,
  269370112,
  1208189768,
  241959558,
  12830212,
  48,
  6888,
  -598272,
  542,
  806241024,
  1208256079,
  -2024930683,
  33915651,
  68029082,
  -1010382907,
  173476678,
  -943389682,
  189383622,
  28,
  6940,
  -597780,
  58,
  269370112,
  1208189768,
  241304198,
  12830212,
  40,
  6972,
  -597748,
  545,
  806241024,
  1409451341,
  75891591,
  -1727920765,
  -989590006,
  1136903879,
  11,
  36,
  7016,
  -597232,
  567,
  806241024,
  -2029877922,
  -2096855549,
  179438085,
  -943389682,
  189121478,
  40,
  7056,
  -596696,
  877,
  1074676480,
  1745191752,
  59179653,
  -838728570,
  -989590006,
  1204012743,
  11,
  60,
  7100,
  -595860,
  597,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  167868419,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  32,
  7164,
  -595316,
  50,
  135151872,
  174129795,
  1187185678,
  247679243,
  4,
  60,
  7200,
  -595288,
  426,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  167874819,
  239145998,
  239190800,
  239191564,
  239191816,
  189056260,
  32,
  7264,
  -594920,
  103,
  135151872,
  239272579,
  173212176,
  239273998,
  189186820,
  16,
  7300,
  -594844,
  13,
  0,
  44,
  7320,
  -594848,
  123,
  135151872,
  239600259,
  235556896,
  68043016,
  1326139075,
  1174933002,
  1124339395,
  11,
  44,
  7368,
  -594768,
  278,
  135151872,
  239600259,
  235557744,
  68043016,
  34292675,
  135138016,
  68076355,
  2885,
  20,
  7416,
  -593392,
  30,
  537805568,
  265818,
  16,
  7440,
  -593384,
  187,
  0,
  16,
  7460,
  -593212,
  57,
  0,
  116,
  7480,
  -593168,
  723,
  135151872,
  240845443,
  239190788,
  1174569736,
  1103299598,
  42141710,
  1108086339,
  -1979579514,
  1137051662,
  1103299598,
  59116558,
  1879179907,
  1137051662,
  1103299598,
  59116558,
  2063729283,
  1137051662,
  1103299598,
  59116558,
  -2013134205,
  1137051662,
  1103299598,
  59116558,
  -1694367101,
  1103497230,
  12780558,
  16,
  7600,
  -592536,
  57,
  0,
  24,
  7620,
  -592492,
  67,
  135152128,
  1862436689,
  13042702,
  28,
  7648,
  -592440,
  34,
  118048256,
  101271040,
  1120359170,
  198,
  16,
  7680,
  -592424,
  101,
  0,
  24,
  7700,
  -592332,
  351,
  135151872,
  1560478343,
  -956035583,
  36,
  7728,
  -592008,
  1543,
  17892096,
  42141710,
  -1023144369,
  135191298,
  -1543372157,
  12780558,
  44,
  7768,
  -590496,
  1335,
  17892096,
  42403854,
  -2096361919,
  135155203,
  242811587,
  240109316,
  1761773320,
  13042702,
  608,
  7816,
  -589200,
  5803,
  135157504,
  239665795,
  242336516,
  1090683656,
  59116558,
  -2028990911,
  134416900,
  -955511295,
  -972550591,
  34212677,
  -955511152,
  -972550591,
  34212677,
  -955511208,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511132,
  -972550591,
  34212677,
  -955511216,
  -972550591,
  34212677,
  -955511140,
  -972550591,
  34212677,
  -955511211,
  -972550591,
  -1023144383,
  1275726657,
  1103563790,
  1103497230,
  1103299598,
  239929867,
  239191820,
  239191560,
  188859140,
  202263818,
  135152071,
  68043206,
  168509891,
  -955511219,
  -972550591,
  -1023144383,
  1292503873,
  1103563790,
  1103497230,
  1103299598,
  239929867,
  239191820,
  239191560,
  188859140,
  202263818,
  135152071,
  68043206,
  168509891,
  -955511171,
  -972550591,
  -1023144383,
  -2096624063,
  39977730,
  1103299598,
  42141710,
  68074498,
  135152067,
  -1174273405,
  1103299598,
  42141710,
  68066562,
  135152067,
  241828483,
  49924,
  220,
  8428,
  -584004,
  2945,
  135161344,
  1778516611,
  1254294542,
  42141710,
  -1023144377,
  -2096624016,
  248316418,
  239190788,
  33719048,
  -1023144312,
  -2096624063,
  244974082,
  239190788,
  33719048,
  -1023144275,
  -2096624063,
  243073538,
  239190788,
  33719048,
  -1023144324,
  -2096624063,
  243925506,
  239190788,
  33719048,
  -1023144291,
  -2096624063,
  243728898,
  239190788,
  33719048,
  -1023144308,
  -2096624063,
  244974082,
  239190788,
  33719048,
  -1023144275,
  -2096624063,
  244777474,
  239190788,
  33719048,
  -1023144292,
  -2096624063,
  246022658,
  239190788,
  33719048,
  -1023144259,
  -2096624063,
  243991042,
  239190788,
  1929544456,
  1103299598,
  42141710,
  -1023144346,
  24,
  8652,
  -581268,
  25,
  135151872,
  240583299,
  49924,
  32,
  8680,
  -581264,
  460,
  537805568,
  1224902214,
  1929511811,
  -972812790,
  738243,
  60,
  8716,
  -580836,
  670,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547909,
  235592706,
  269369620,
  202260931,
  135152070,
  68043207,
  739269,
  56,
  8780,
  -580228,
  216,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837629,
  1343111941,
  336513026,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  48,
  8840,
  -580064,
  89,
  135151872,
  239272579,
  235559440,
  68043528,
  1393248195,
  1124601354,
  1254294542,
  135153931,
  -1023144381,
  84,
  8892,
  -624756,
  552,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  336464474,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  1040386881,
  336464385,
  269402945,
  202294849,
  135186241,
  68076865,
  2881,
  60,
  8980,
  -580076,
  298,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1072806395,
  175899168,
  239277070,
  239190800,
  239191564,
  239191816,
  189056260,
  16,
  9044,
  -579836,
  12,
  0,
  32,
  9064,
  -579840,
  98,
  135151872,
  239600259,
  235565888,
  68043016,
  737731,
  16,
  9100,
  -579764,
  30,
  0,
  32,
  9120,
  -579752,
  45,
  135151872,
  173736579,
  1103299598,
  247680779,
  4,
  40,
  9156,
  -579740,
  99,
  135154432,
  240648835,
  240304900,
  202260744,
  240649091,
  239715080,
  4,
  40,
  9200,
  -579672,
  99,
  135154432,
  240648835,
  240304900,
  202260744,
  240649091,
  239715080,
  4,
  40,
  9244,
  -579604,
  99,
  135154432,
  240648835,
  240304900,
  202260744,
  240649091,
  239715080,
  4,
  32,
  9288,
  -579536,
  49,
  135151872,
  173998723,
  1103299598,
  247680779,
  4,
  32,
  9324,
  -579508,
  160,
  537805568,
  -2096986544,
  235564803,
  1103349252,
  11,
  40,
  9360,
  -579384,
  157,
  537805568,
  1208189770,
  175899270,
  -1010433010,
  175246151,
  68077251,
  2886,
  44,
  8748,
  -576911,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1292699256,
  486537010,
  -148300019,
  8959,
  44,
  8796,
  -576943,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  420284024,
  486537010,
  -148018675,
  8959,
  44,
  8844,
  -576975,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -452131208,
  486537009,
  -148016627,
  8959,
  44,
  8892,
  -577007,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1324546440,
  486537009,
  -147803891,
  8959,
  44,
  8940,
  -577039,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  2098005624,
  486537009,
  -147797747,
  8959,
  16,
  9644,
  -579508,
  25,
  0,
  36,
  9664,
  -579496,
  504,
  806241024,
  -2029877932,
  -2096855549,
  177668613,
  -943389682,
  188924870,
  20,
  9704,
  -579024,
  49,
  537805568,
  265837,
  28,
  0,
  1280342529,
  2080440402,
  -1342175480,
  527436,
  67374107,
  392,
  68,
  36,
  -579016,
  1358,
  248981508,
  135151880,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1072806395,
  44434177,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1153762318,
  11,
  20,
  9832,
  -577728,
  43,
  537805568,
  265831,
  20,
  9856,
  -577704,
  43,
  537805568,
  265831,
  20,
  9880,
  -577680,
  43,
  537805568,
  265831,
  36,
  180,
  -577656,
  109,
  248994308,
  537805576,
  -2096986537,
  235567107,
  1170458116,
  11,
  28,
  220,
  -577584,
  103,
  248997380,
  806241032,
  235554562,
  737540,
  16,
  9976,
  -577504,
  21,
  0,
  56,
  9996,
  -577412,
  71,
  135151872,
  1091309121,
  239144974,
  58934292,
  1141147212,
  -2059139705,
  269376514,
  202260935,
  135152070,
  68043203,
  197,
  16,
  10056,
  -577392,
  35,
  0,
  24,
  10076,
  -577364,
  37,
  135151872,
  240648835,
  49924,
  24,
  10104,
  -577344,
  37,
  135151872,
  240648835,
  49924,
  60,
  10132,
  -577324,
  211,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  -1072806395,
  247595584,
  269369620,
  202260931,
  135152070,
  68043207,
  197,
  40,
  10196,
  -577164,
  452,
  1343111936,
  1241810504,
  42272131,
  33785687,
  68028999,
  -1010382907,
  2885,
  60,
  10240,
  -576744,
  637,
  135151872,
  222429829,
  92491013,
  59180166,
  167859203,
  1103512003,
  67912135,
  188859652,
  -1022716926,
  -951990719,
  67945793,
  737540,
  60,
  10304,
  -576168,
  155,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235569666,
  269370132,
  202260931,
  135152070,
  68043207,
  737733,
  16,
  10368,
  -576072,
  10,
  0,
  16,
  10388,
  -576076,
  10,
  0,
  32,
  10408,
  -576080,
  80,
  537805568,
  1208189768,
  175374982,
  -1010433010,
  2881,
  40,
  10444,
  -576036,
  49,
  135151872,
  239141511,
  1090749964,
  75698190,
  -1022620064,
  -972550591,
  -956035519,
  36,
  10488,
  -576016,
  95,
  50940928,
  1271092738,
  -2042165234,
  50938370,
  1237538306,
  265926,
  36,
  10528,
  -575960,
  95,
  50940928,
  1271092738,
  -2042165234,
  50938370,
  1237538306,
  265926,
  20,
  10568,
  -575904,
  34,
  50938368,
  12801538,
  16,
  10592,
  -575880,
  55,
  0,
  40,
  10612,
  -575836,
  44,
  135151872,
  1091309121,
  42078222,
  75891587,
  -972288410,
  -1022882239,
  -1039921599,
  40,
  10656,
  -575832,
  36,
  135151872,
  1091309121,
  42143758,
  75629441,
  -1039397282,
  -1056436671,
  -1023144383,
  24,
  10700,
  -575828,
  85,
  269370112,
  68029036,
  2881,
  32,
  10728,
  -575760,
  120,
  269370112,
  -2046654641,
  2013561603,
  -956035574,
  188859334,
  44,
  10108,
  -116573,
  13,
  34084352,
  373689208,
  91750920,
  235411012,
  2131560056,
  486538808,
  -29877747,
  8959,
  44,
  10156,
  -116608,
  13,
  34084352,
  373689208,
  91750920,
  235411012,
  1208813176,
  486538808,
  -29881843,
  8959,
  44,
  10204,
  -575466,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -905116040,
  486537015,
  -147410675,
  8959,
  44,
  10252,
  -575498,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1777531272,
  486537015,
  -147391731,
  8959,
  48,
  10956,
  -116884,
  119,
  135151872,
  239469191,
  1124304396,
  75698190,
  35655237,
  1091571300,
  1103301646,
  1103497230,
  13042702,
  24,
  11008,
  -575912,
  251,
  537805568,
  235582722,
  739332,
  16,
  11036,
  -575684,
  42,
  0,
  44,
  10400,
  -575365,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1393362552,
  486537016,
  -147354867,
  8959,
  44,
  10448,
  -575401,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  453838456,
  486537016,
  -147344371,
  8959,
  44,
  10496,
  -575440,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  -536017288,
  486537015,
  -147343859,
  8959,
  40,
  1476,
  -575768,
  259,
  249000452,
  537805576,
  1208255304,
  -2024995962,
  178651650,
  -960035826,
  737731,
  40,
  11244,
  -575508,
  113,
  135151872,
  222757509,
  92489989,
  -2029746615,
  223674883,
  -1010383100,
  -989589951,
  56,
  11288,
  -575424,
  178,
  135151872,
  222429829,
  92489989,
  59180166,
  -1022719230,
  -951990719,
  67374145,
  1309361861,
  1103512003,
  214254023,
  1028,
  64,
  11348,
  -575292,
  708,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1072806395,
  34865921,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1187316750,
  11,
  16,
  11416,
  -574640,
  3,
  0,
  60,
  11436,
  -574644,
  791,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  167858947,
  239145998,
  239190800,
  239191564,
  239191816,
  188925188,
  84,
  11500,
  -573908,
  673,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  167909635,
  239145998,
  239190800,
  239191564,
  239191816,
  189056260,
  235561730,
  247677204,
  247873808,
  247939340,
  247808264,
  737540,
  16,
  11588,
  -573308,
  34,
  0,
  56,
  11608,
  -573280,
  78,
  135151872,
  239141511,
  1090749964,
  75698190,
  247663224,
  247875084,
  247939336,
  1091257860,
  1136856078,
  1103497230,
  13042702,
  60,
  11668,
  -573260,
  802,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611549189,
  235577858,
  269370132,
  202260931,
  135152070,
  68043207,
  740037,
  44,
  11732,
  -572508,
  77,
  135151872,
  239272579,
  235555856,
  68043016,
  1577797571,
  1091046922,
  1090784963,
  11,
  60,
  11780,
  -572476,
  272,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1878112763,
  176816644,
  239277070,
  239190800,
  239191564,
  239191816,
  188859652,
  36,
  11844,
  -572268,
  148,
  537806848,
  1208255306,
  -2025323642,
  173998594,
  -960035826,
  739267,
  16,
  11884,
  -572148,
  8,
  269370112,
  16,
  11904,
  -572152,
  14,
  0,
  40,
  11924,
  -572156,
  589,
  470696704,
  1527087942,
  59179653,
  1845625990,
  -989590006,
  1187235527,
  11,
  16,
  11968,
  -571608,
  20,
  0,
  28,
  11988,
  -571596,
  373,
  135151872,
  239469190,
  1124303628,
  20494,
  16,
  12020,
  -571244,
  71,
  806241024,
  16,
  12040,
  -571184,
  13,
  0,
  16,
  12060,
  -571188,
  13,
  0,
  16,
  12080,
  -571192,
  13,
  0,
  16,
  12100,
  -571196,
  68,
  0,
  20,
  12120,
  -571136,
  59,
  806241024,
  265847,
  44,
  11488,
  -566233,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  51185272,
  486537052,
  -145764083,
  8959,
  44,
  11536,
  -566265,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -821229960,
  486537051,
  -145700083,
  8959,
  44,
  11584,
  -566297,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1693645192,
  486537051,
  -145680371,
  8959,
  44,
  11632,
  -566329,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1728906872,
  486537051,
  -145688819,
  8959,
  44,
  11680,
  -566361,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  856491640,
  486537051,
  -145516787,
  8959,
  44,
  11728,
  -566393,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -15923592,
  486537050,
  -145526515,
  8959,
  40,
  12432,
  -571384,
  457,
  537805568,
  1208320838,
  -2058287994,
  1728284418,
  -989590006,
  1204012743,
  11,
  32,
  12476,
  -118244,
  163,
  135151872,
  239272579,
  245170720,
  68043016,
  195,
  68,
  12512,
  -571000,
  101,
  135151872,
  239141511,
  1090749964,
  75698190,
  35655237,
  269355585,
  -1022620093,
  -972550591,
  -956035519,
  239274826,
  247678224,
  247873804,
  247939336,
  4,
  44,
  12584,
  -570960,
  117,
  135151872,
  239141510,
  1124303628,
  1593974798,
  1091309066,
  1103300622,
  1120273422,
  11,
  60,
  12632,
  -570880,
  2443,
  135151872,
  222429829,
  92489989,
  59180166,
  167852547,
  1103512003,
  67912135,
  189252868,
  167884803,
  1103512003,
  214254023,
  189072388,
  76,
  12696,
  -568496,
  1711,
  135151872,
  222429829,
  92489989,
  59180166,
  168012547,
  1103512003,
  67912135,
  189187332,
  -1022736382,
  -951990719,
  67945793,
  51070212,
  -1022754506,
  -951990719,
  67945793,
  737540,
  44,
  12776,
  -566768,
  617,
  135151872,
  222429829,
  92488965,
  59180166,
  -1022711294,
  -951990719,
  67374145,
  738245,
  40,
  12824,
  -118416,
  69,
  135151872,
  239141510,
  1124303628,
  243081230,
  135151884,
  68043203,
  198,
  44,
  12212,
  -560659,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -921893256,
  486537073,
  -144953075,
  8959,
  44,
  12260,
  -560691,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1794308488,
  486537073,
  -144952051,
  8959,
  44,
  12964,
  -566332,
  5577,
  135151872,
  222429829,
  75908101,
  -2091121785,
  174785029,
  1103512003,
  67912135,
  189252868,
  80,
  13012,
  -118524,
  217,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  806241029,
  235578626,
  269369620,
  202260931,
  135152070,
  68043207,
  1544242885,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  1038,
  44,
  12440,
  -559384,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1005779336,
  486537078,
  -143277043,
  8959,
  44,
  12488,
  -559416,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1878194568,
  486537078,
  -143259891,
  8959,
  60,
  13192,
  -560944,
  1123,
  135151872,
  222429829,
  92493061,
  59180166,
  167961091,
  1103512003,
  67912135,
  188990724,
  167839491,
  1103512003,
  214254023,
  188810244,
  20,
  13256,
  -559872,
  39,
  537805568,
  265827,
  52,
  13280,
  -559848,
  280,
  135151872,
  239272583,
  1174636044,
  75698190,
  37752387,
  269355686,
  -1022620093,
  -972550591,
  -956035519,
  2888,
  84,
  13336,
  -559584,
  1311,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879983365,
  168008195,
  239277070,
  239190800,
  239191564,
  239191816,
  189252868,
  336464459,
  269402947,
  202294849,
  135186241,
  68076865,
  2887,
  60,
  13424,
  -558360,
  226,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235581954,
  269369620,
  202260931,
  135152070,
  68043207,
  738245,
  60,
  13488,
  -558184,
  549,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235586306,
  269370132,
  202260931,
  135152070,
  68043207,
  739525,
  32,
  13552,
  -557688,
  66,
  135151872,
  239403651,
  235560992,
  68043016,
  737731,
  80,
  13588,
  -557644,
  128,
  135151872,
  239272581,
  1124304652,
  75894798,
  -2095837629,
  806241541,
  235556098,
  247677204,
  247873808,
  247939340,
  247808264,
  1510686980,
  239145998,
  239190800,
  239191564,
  239191816,
  50436,
  20,
  13672,
  -557600,
  31,
  537805568,
  265819,
  64,
  13696,
  -557592,
  1557,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1609677307,
  46072586,
  1125387786,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  11,
  40,
  13764,
  -556092,
  230,
  1074676480,
  1174766408,
  -2025454458,
  42288643,
  235569666,
  -959986428,
  737731,
  16,
  13808,
  -555896,
  52,
  0,
  20,
  13828,
  -555852,
  100,
  403587840,
  68050946,
  44,
  13196,
  -555242,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -234027400,
  486537094,
  -142275571,
  8959,
  44,
  13244,
  -555274,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1106442632,
  486537094,
  -142219507,
  8959,
  44,
  13292,
  -555306,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1978857864,
  486537094,
  -142222067,
  8959,
  24,
  13996,
  -555908,
  522,
  135151872,
  239469191,
  688,
  56,
  14024,
  -555360,
  88,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  336480258,
  -1022357949,
  -972288447,
  -955773375,
  -989589951,
  60,
  14084,
  -555324,
  801,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  235601410,
  269369620,
  202260931,
  135152070,
  68043207,
  739269,
  60,
  14148,
  -554572,
  730,
  135151872,
  222429829,
  92489989,
  59180166,
  167873539,
  1103512003,
  214254023,
  189072388,
  1103301224,
  1103577542,
  -989592564,
  2885,
  20,
  14212,
  -553900,
  51,
  806241024,
  265839,
  80,
  14236,
  -553860,
  203,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235557890,
  269369620,
  202260931,
  135152070,
  68043207,
  34292165,
  1091833443,
  1141903043,
  1091309254,
  1091047111,
  265925,
  44,
  13664,
  -552232,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1274214792,
  486537106,
  -141748467,
  8959,
  44,
  13712,
  -552264,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -2146630024,
  486537106,
  -141704691,
  8959,
  44,
  13760,
  -552296,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1275922040,
  486537106,
  -141648883,
  8959,
  44,
  13808,
  -552328,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  403506808,
  486537106,
  -141644275,
  8959,
  44,
  13856,
  -552360,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -468908424,
  486537105,
  -141520371,
  8959,
  44,
  13904,
  -552392,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1341323656,
  486537105,
  -141518067,
  8959,
  44,
  13952,
  -552424,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  2081228408,
  486537105,
  -141509363,
  8959,
  44,
  14000,
  -552456,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1208813176,
  486537105,
  -141514739,
  8959,
  44,
  14704,
  -554120,
  1030,
  135151872,
  222429829,
  92490757,
  59180166,
  167852547,
  1103512003,
  67912135,
  189056260,
  40,
  14752,
  -553128,
  102,
  135151872,
  239272579,
  172229152,
  239142926,
  189252356,
  1174933071,
  265923,
  80,
  14796,
  -553060,
  233,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235579394,
  269370132,
  202260931,
  135152070,
  68043207,
  1728791493,
  -1018817522,
  -968814578,
  -952038386,
  -985593842,
  1038,
  24,
  14880,
  -552904,
  112,
  537805568,
  235557634,
  737796,
  20,
  14908,
  -120196,
  43,
  537805568,
  265831,
  16,
  14932,
  -552716,
  19,
  0,
  20,
  14952,
  -552704,
  55,
  806241024,
  265843,
  20,
  14976,
  -552664,
  55,
  806241024,
  265843,
  20,
  15000,
  -552624,
  55,
  806241024,
  265843,
  20,
  15024,
  -552584,
  55,
  806241024,
  265843,
  84,
  15048,
  -552544,
  1172,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167887363,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  235597826,
  247677204,
  247875088,
  247939340,
  247808264,
  737540,
  20,
  15136,
  -551448,
  51,
  806241024,
  265839,
  84,
  15160,
  -551408,
  1148,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167876611,
  -1019145202,
  -968683506,
  -952038386,
  -985593842,
  188941326,
  336464465,
  -1022357949,
  -972288447,
  -955773375,
  -989589951,
  2881,
  20,
  15248,
  -550344,
  51,
  806241024,
  265839,
  84,
  15272,
  -550304,
  652,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  235595778,
  269369620,
  202260931,
  135152070,
  68043207,
  51070405,
  235536699,
  247677204,
  247873808,
  247939340,
  247808264,
  737540,
  60,
  15360,
  -549736,
  179,
  135151872,
  239141511,
  1174636044,
  75698190,
  235554818,
  239190796,
  239191560,
  189187844,
  247683074,
  247873804,
  247939336,
  4,
  84,
  15424,
  -549608,
  527,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837626,
  806241029,
  167874307,
  239277070,
  239190800,
  239191564,
  239191816,
  188925188,
  336464480,
  269402947,
  202294849,
  135186241,
  68076865,
  2882,
  40,
  15512,
  -549168,
  95,
  135151872,
  239141510,
  1124303628,
  1426205710,
  239275022,
  239190792,
  50692,
  40,
  15556,
  -549116,
  103,
  135151872,
  239141510,
  1124303628,
  1560430606,
  239275022,
  239190792,
  50692,
  44,
  14944,
  -528116,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -468908424,
  486537200,
  -140451827,
  8959,
  44,
  14992,
  -528152,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1408432520,
  486537200,
  -140441075,
  8959,
  44,
  15040,
  -528188,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1947010680,
  486537200,
  -140330995,
  8959,
  44,
  15088,
  -528224,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1007486584,
  486537200,
  -140330483,
  8959,
  48,
  15792,
  -549240,
  197,
  806241024,
  1275429704,
  59180166,
  1694664022,
  -989590006,
  1187235527,
  241697291,
  -959986428,
  195,
  40,
  15844,
  -549084,
  488,
  -267500032,
  92490049,
  -2029877920,
  50628099,
  235536740,
  -959986428,
  738755,
  44,
  15888,
  -634008,
  215,
  135151872,
  222429829,
  75908101,
  -2092366969,
  -1010761211,
  -951990719,
  67374145,
  197,
  44,
  15936,
  -633841,
  457,
  135151872,
  222429829,
  75908101,
  -2092760185,
  29033221,
  1103512003,
  67912135,
  50436,
  64,
  6260,
  -548728,
  20228,
  249004036,
  135151880,
  222429829,
  92490757,
  59180166,
  167841027,
  1103512003,
  67912135,
  188859652,
  -1022726654,
  -951990715,
  67945793,
  738052,
  84,
  16052,
  -528508,
  323,
  135151872,
  239141510,
  1157858060,
  -1711132658,
  1124863498,
  1091047107,
  1124339398,
  235566603,
  135152396,
  68043203,
  1795901126,
  1124863498,
  1091047107,
  1090784966,
  235559179,
  247677708,
  247873800,
  738052,
  44,
  16140,
  -633588,
  457,
  135151872,
  222429829,
  75908101,
  -2092760185,
  29033221,
  1103512003,
  67912135,
  50436,
  32,
  16188,
  -528308,
  67,
  135151872,
  239272582,
  2097382156,
  1103300622,
  12977166,
  44,
  16224,
  -528264,
  8631,
  135151872,
  222429829,
  92490757,
  59180166,
  167941891,
  1103512003,
  67912135,
  189252868,
  44,
  15616,
  -519475,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1458764168,
  486537234,
  -133036531,
  8959,
  44,
  15664,
  -519507,
  13,
  34084352,
  373689208,
  91750920,
  235411012,
  1963787896,
  486537234,
  -133041139,
  8959,
  32,
  16368,
  -519768,
  179,
  135151872,
  239272579,
  174326304,
  239273998,
  189121284,
  16,
  16404,
  -519612,
  5,
  0,
  64,
  16424,
  -519584,
  5614,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1878112763,
  36897539,
  1125387786,
  1103302670,
  1103498254,
  1103562766,
  1170539534,
  11,
  44,
  15836,
  -513246,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -32700808,
  486537258,
  -131576307,
  8959,
  44,
  15884,
  -513278,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -905116040,
  486537258,
  -131557363,
  8959,
  40,
  16588,
  -121828,
  87,
  135151872,
  239141510,
  1124303628,
  1325539342,
  239143950,
  239190792,
  50692,
  68,
  16632,
  -514176,
  332,
  135151872,
  239141511,
  1090749964,
  75698190,
  1981812291,
  1125125642,
  1103301646,
  1103497230,
  1204225038,
  180355595,
  -1019015154,
  -968815602,
  -952039410,
  188810254,
  60,
  16704,
  -513912,
  239,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  672023301,
  235592450,
  269369620,
  202260931,
  135152070,
  68043207,
  737733,
  60,
  16768,
  -513736,
  214,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  604914437,
  235585538,
  269369620,
  202260931,
  135152070,
  68043207,
  737733,
  44,
  16176,
  -513381,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1997342328,
  486537258,
  -131472115,
  8959,
  44,
  16224,
  -513413,
  13,
  34084352,
  373689208,
  91750920,
  235411012,
  1124927096,
  486537258,
  -131473139,
  8959,
  24,
  16928,
  -513640,
  163,
  537805568,
  235561986,
  737540,
  20,
  16956,
  -513476,
  35,
  537805568,
  265823,
  20,
  16980,
  -513452,
  35,
  537805568,
  265823,
  20,
  17004,
  -513428,
  35,
  537805568,
  265823,
  20,
  17028,
  -513404,
  35,
  537805568,
  265823,
  44,
  16396,
  -513335,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  -1592981896,
  486537258,
  -131427827,
  8959,
  16,
  17100,
  -513428,
  45,
  0,
  84,
  17120,
  -513384,
  1750,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  167887619,
  239277070,
  239190800,
  239191564,
  239191816,
  189318404,
  167844867,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189137934,
  60,
  17208,
  -511712,
  199,
  135151872,
  222429829,
  92489989,
  59180166,
  -1022725374,
  -951990719,
  67374145,
  1460356805,
  -968768758,
  -985544895,
  1090782220,
  11,
  44,
  16616,
  -511132,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1007486584,
  486537267,
  -130956531,
  8959,
  44,
  16664,
  -511168,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  135071352,
  486537267,
  -130943987,
  8959,
  44,
  16712,
  -511200,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -737343880,
  486537266,
  -130951155,
  8959,
  44,
  16760,
  -511232,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  -1676867976,
  486537266,
  -130931187,
  8959,
  44,
  16808,
  -511271,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  1628243576,
  486537266,
  -130935027,
  8959,
  56,
  7788,
  -511808,
  436,
  249023236,
  135151880,
  239141511,
  1090749964,
  75698190,
  52432451,
  235536648,
  202261264,
  135152067,
  68043206,
  738759,
  44,
  16916,
  -511138,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  906823288,
  486537267,
  -130903795,
  8959,
  44,
  16964,
  -511174,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  -32700808,
  486537266,
  -130902003,
  8959,
  44,
  17012,
  -511213,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  -1022556552,
  486537266,
  -130901747,
  8959,
  60,
  7992,
  -511500,
  218,
  249028356,
  135151880,
  239141510,
  1124303628,
  -1962794994,
  1124863498,
  1103300622,
  1153827854,
  235553547,
  135151884,
  68043203,
  738758,
  16,
  17780,
  -511308,
  50,
  0,
  32,
  17800,
  -511264,
  206,
  135151872,
  239403651,
  179307056,
  239273998,
  188859140,
  20,
  17836,
  -511092,
  35,
  537805568,
  265823,
  44,
  17204,
  -510784,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1743976840,
  486537268,
  -130824947,
  8959,
  44,
  17252,
  -510820,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  1611466360,
  486537268,
  -130816499,
  8959,
  44,
  17300,
  -510859,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  621610616,
  486537268,
  -130811123,
  8959,
  44,
  8280,
  -511212,
  284,
  249031940,
  806241032,
  1208190792,
  -2058680957,
  33850882,
  68029106,
  -1010382907,
  2888,
  44,
  17396,
  -510558,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  2047673976,
  486537269,
  -130796787,
  8959,
  44,
  17444,
  -510594,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  1108149880,
  486537269,
  -130756083,
  8959,
  44,
  17492,
  -510633,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  118294136,
  486537269,
  -130753267,
  8959,
  48,
  8472,
  -511084,
  382,
  249035524,
  806241032,
  1359185480,
  75694727,
  235581186,
  -1010383100,
  175835973,
  247973571,
  738564,
  44,
  17592,
  -510399,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  420284024,
  486537270,
  -130734579,
  8959,
  44,
  17640,
  -510435,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  -519240072,
  486537269,
  -130707955,
  8959,
  44,
  17688,
  -510474,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  -1509095816,
  486537269,
  -130712563,
  8959,
  44,
  8668,
  -510864,
  321,
  249039108,
  806241032,
  1208256072,
  -2092432505,
  42290949,
  235572482,
  -959986428,
  737731,
  80,
  18440,
  -510560,
  172,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235564546,
  269370132,
  202260931,
  135152070,
  68043207,
  1527466181,
  -1019145202,
  -968552434,
  -952038386,
  -985593842,
  1038,
  44,
  17868,
  -509960,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -804452744,
  486537271,
  -130607347,
  8959,
  44,
  17916,
  -509996,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  -1743976840,
  486537271,
  -130601203,
  8959,
  44,
  17964,
  -510035,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  1561134712,
  486537271,
  -130600179,
  8959,
  48,
  18668,
  -510612,
  251,
  806241024,
  1342408264,
  -2025126781,
  174785026,
  -960035826,
  34293699,
  68029021,
  1103349447,
  11,
  44,
  8996,
  -510408,
  252,
  249042948,
  1074676488,
  1208320840,
  -2025323386,
  42290435,
  235576066,
  -959986428,
  737731,
  32,
  18768,
  -510168,
  151,
  135151872,
  239469187,
  -1912471088,
  239142926,
  49924,
  32,
  18804,
  -510044,
  78,
  135151872,
  239272579,
  235563808,
  68043528,
  739011,
  40,
  18840,
  -510000,
  105,
  135151872,
  239141510,
  1124303628,
  1560420366,
  239143950,
  239190792,
  50692,
  32,
  18884,
  -509932,
  187,
  537805568,
  -2096921014,
  42420996,
  68067842,
  12830407,
  40,
  18920,
  -509776,
  410,
  -267500032,
  42292481,
  -2024471165,
  50628099,
  235536642,
  -959986428,
  739011,
  44,
  18964,
  -509404,
  319,
  135151872,
  239141510,
  1174635276,
  33787918,
  202246907,
  -1022882237,
  -972812735,
  2881,
  16,
  19012,
  -509132,
  5,
  0,
  40,
  19032,
  -509136,
  185,
  1074676480,
  1208320844,
  -2058353530,
  33785602,
  68029044,
  -1010382907,
  2885,
  40,
  19076,
  -508988,
  122,
  537805568,
  1208190536,
  -2025388925,
  235568386,
  -1010383100,
  -1017574583,
  68077510,
  80,
  19120,
  -508904,
  164,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  235562498,
  269370132,
  202260931,
  135152070,
  68043207,
  1527466181,
  -1019145202,
  -968552434,
  -952038386,
  -985593842,
  1038,
  60,
  19204,
  -508812,
  579,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343112453,
  235580674,
  269369620,
  202260931,
  135152070,
  68043207,
  739013,
  16,
  19268,
  -508284,
  40,
  0,
  16,
  19288,
  -508256,
  40,
  0,
  24,
  19308,
  -508228,
  42,
  135151872,
  241697411,
  49924,
  44,
  19336,
  -508208,
  109,
  135151872,
  239272579,
  235565344,
  68043016,
  1191920323,
  1091046922,
  1208225475,
  11,
  40,
  19384,
  -508144,
  336,
  1074676480,
  1342538568,
  59180166,
  -620625275,
  -989590006,
  1120126663,
  11,
  32,
  19428,
  -507852,
  140,
  135151872,
  239272579,
  172556832,
  239142926,
  189448964,
  28,
  19464,
  -507744,
  49,
  135151872,
  239272579,
  135162144,
  -1023144381,
  28,
  19496,
  -507712,
  72,
  537805568,
  1208189768,
  242418310,
  12830212,
  56,
  19528,
  -507664,
  198,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  336508930,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  40,
  19588,
  -507516,
  89,
  135151872,
  239272579,
  235557152,
  68043016,
  2131444419,
  -1019148274,
  1038,
  24,
  19632,
  -507464,
  111,
  806241024,
  235561730,
  737796,
  32,
  19660,
  -507380,
  117,
  135151872,
  239272579,
  235568160,
  68043016,
  739267,
  28,
  19696,
  -507288,
  66,
  135151872,
  239272579,
  135167008,
  -1023144383,
  56,
  19728,
  -507240,
  256,
  135151872,
  239272579,
  173802016,
  239142926,
  189252356,
  135137880,
  -1023144383,
  1560415047,
  1091046922,
  1107562179,
  11,
  60,
  19788,
  -507044,
  176,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235566338,
  269369620,
  202261443,
  135152070,
  68043207,
  739013,
  56,
  19852,
  -506932,
  264,
  135151872,
  239272579,
  173802016,
  239142926,
  189252356,
  135137880,
  -1023144383,
  1644301127,
  1091046922,
  1157893827,
  11,
  32,
  19912,
  -506720,
  63,
  135151872,
  239272579,
  235565600,
  68043016,
  737731,
  32,
  19948,
  -506692,
  62,
  135151872,
  239272579,
  235561248,
  68043016,
  737987,
  32,
  19984,
  -506664,
  66,
  135151872,
  175243907,
  1170408462,
  247679243,
  4,
  32,
  20020,
  -506620,
  100,
  537805568,
  1208189768,
  175112838,
  -1010433010,
  2885,
  16,
  20056,
  -506544,
  58,
  0,
  40,
  20076,
  -506500,
  133,
  269370112,
  1191347789,
  174850947,
  -1010433010,
  174918469,
  68077251,
  2883,
  16,
  20120,
  -506400,
  42,
  0,
  44,
  19484,
  -501522,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -972224904,
  486537304,
  -129217779,
  8959,
  44,
  19532,
  -501558,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1911749000,
  486537304,
  -129046003,
  8959,
  44,
  19580,
  -501594,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1443694200,
  486537304,
  -128955379,
  8959,
  40,
  20284,
  -506516,
  1498,
  -804370944,
  42290689,
  1308919374,
  -2090990713,
  176030213,
  -943389682,
  189055942,
  112,
  10604,
  -505056,
  1333,
  249046532,
  135151880,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  167903235,
  239145998,
  239190800,
  239191564,
  239191816,
  189121796,
  336464488,
  269402945,
  202294854,
  135186241,
  68076865,
  1912736583,
  1175719434,
  1091571395,
  1091309254,
  1091047111,
  1157893829,
  11,
  40,
  20444,
  -503828,
  54,
  135151872,
  239272579,
  235557920,
  68044296,
  1393246915,
  239142926,
  49924,
  72,
  20488,
  -503808,
  291,
  135151872,
  239141510,
  1124303628,
  -1375584242,
  1091309066,
  1103300622,
  1137050638,
  235554059,
  247677196,
  247873800,
  1695236356,
  1091309066,
  1091047107,
  1090784966,
  11,
  60,
  20564,
  -503580,
  295,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167840771,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  40,
  20628,
  -503340,
  400,
  1074676480,
  1208320842,
  -2058353530,
  33785602,
  68029087,
  -1010382907,
  2884,
  36,
  20672,
  -502984,
  348,
  806241024,
  1426359112,
  59114119,
  235559938,
  -1010383100,
  2884,
  36,
  20712,
  -502672,
  578,
  537805568,
  1208255304,
  -2025192570,
  235562754,
  -1010383100,
  2884,
  44,
  20096,
  -493415,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1896679032,
  486537336,
  -126563059,
  8959,
  44,
  20144,
  -493451,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  957154936,
  486537336,
  -126558451,
  8959,
  44,
  20192,
  -493487,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  17630840,
  486537336,
  -126492147,
  8959,
  36,
  20896,
  -502232,
  100,
  537805568,
  1342473032,
  59114119,
  68029045,
  1220789959,
  11,
  36,
  20936,
  -502160,
  146,
  537805568,
  1258586952,
  59114119,
  235560194,
  -1010383100,
  2885,
  16,
  20976,
  -502040,
  16,
  0,
  36,
  20996,
  -502044,
  463,
  -1878112768,
  75712769,
  -2046654625,
  173212163,
  -960035826,
  739267,
  32,
  21036,
  -501620,
  70,
  269370112,
  1208255303,
  -2025323642,
  68053506,
  12830407,
  28,
  21072,
  -501576,
  34,
  135151872,
  239272579,
  135158544,
  -1023144383,
  40,
  21104,
  -501560,
  615,
  -1609677312,
  92489985,
  -2029877914,
  33850883,
  68029082,
  -1010382907,
  2881,
  40,
  21148,
  -500980,
  248,
  1074676480,
  1342473800,
  92472199,
  33719628,
  68029008,
  -1010382907,
  2881,
  84,
  21192,
  -500768,
  474,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  167837699,
  239277070,
  239321872,
  239191564,
  239191816,
  188859652,
  235554818,
  247677716,
  247874320,
  247939340,
  247808264,
  739332,
  40,
  21280,
  -500376,
  281,
  1074676480,
  1208320838,
  -2058550138,
  33785602,
  68029032,
  -1010382907,
  2882,
  60,
  21324,
  -500132,
  125,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235561218,
  269369620,
  202260931,
  135152070,
  68043207,
  737989,
  16,
  21388,
  -500068,
  16,
  0,
  28,
  21408,
  -500072,
  58,
  135151872,
  239272579,
  135163936,
  -1023144383,
  20,
  21440,
  -500040,
  38,
  537805568,
  265826,
  112,
  21464,
  -500016,
  1353,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1341241851,
  26477313,
  1125387786,
  1136857102,
  1103498254,
  1103562766,
  1120207886,
  19071755,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  32178955,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  32,
  21580,
  -498772,
  68,
  135151872,
  239272579,
  235567136,
  68043528,
  737731,
  40,
  21616,
  -498728,
  92,
  135151872,
  239272579,
  235567648,
  68043016,
  1510687171,
  -1019148274,
  1038,
  40,
  21660,
  -498676,
  327,
  1343111936,
  1342342472,
  92472454,
  33785678,
  68029097,
  -1010382907,
  2886,
  40,
  21704,
  -498384,
  72,
  135151872,
  239272579,
  235557392,
  68043016,
  1829454275,
  239142926,
  49924,
  40,
  21748,
  -498348,
  449,
  1074676480,
  1208256074,
  -2025323133,
  42290179,
  235597570,
  -959986428,
  739523,
  16,
  21792,
  -497928,
  50,
  0,
  28,
  21812,
  -497884,
  48,
  135151872,
  239272579,
  135162400,
  -1023144383,
  36,
  21844,
  -497868,
  252,
  806241024,
  1325695824,
  -2024471674,
  173867522,
  -960035826,
  738499,
  36,
  21884,
  -497652,
  156,
  806241024,
  1308918600,
  59114119,
  235564802,
  -1010383100,
  2888,
  28,
  21924,
  -497532,
  45,
  135151872,
  239403651,
  135161104,
  -1023144383,
  32,
  21956,
  -497516,
  203,
  135151872,
  239272579,
  173802016,
  239142926,
  189252356,
  32,
  21992,
  -497344,
  122,
  135151872,
  239272579,
  172163616,
  239142926,
  189317892,
  52,
  22028,
  -497252,
  399,
  135151872,
  239141511,
  1090749964,
  75698190,
  52432451,
  235536656,
  202261264,
  135152067,
  68043206,
  738759,
  76,
  12360,
  -496908,
  1108,
  249051908,
  135151880,
  222429829,
  92492293,
  59180166,
  1103301236,
  1103577542,
  -989592564,
  172886852,
  1103512003,
  214254023,
  189203460,
  167953155,
  1103512003,
  214254023,
  188875780,
  48,
  12440,
  -495868,
  543,
  249057284,
  537805576,
  1376027464,
  59114119,
  167846915,
  -960035826,
  1376470979,
  -943275254,
  189137934,
  52,
  22216,
  -495376,
  497,
  135151872,
  239141511,
  1090749964,
  75698190,
  35655235,
  269355618,
  -1022620095,
  -972550591,
  -956035519,
  2885,
  44,
  21616,
  -488249,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1626536328,
  486537356,
  -126689779,
  8959,
  44,
  21664,
  -488285,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1796015736,
  486537356,
  -126694131,
  8959,
  44,
  21712,
  -488317,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  923600504,
  486537356,
  -126570227,
  8959,
  44,
  21760,
  -488349,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -15923592,
  486537355,
  -126569715,
  8959,
  44,
  21808,
  -488385,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -888338824,
  486537355,
  -126545651,
  8959,
  44,
  21856,
  -488417,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1827862920,
  486537355,
  -126531059,
  8959,
  44,
  21904,
  -488453,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1594689144,
  486537355,
  -126508275,
  8959,
  44,
  21952,
  -488485,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  655165048,
  486537355,
  -126504691,
  8959,
  44,
  22000,
  -488521,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -217250184,
  486537354,
  -126490099,
  8959,
  44,
  22048,
  -488553,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1156774280,
  486537354,
  -126469619,
  8959,
  44,
  22096,
  -488589,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -2029189512,
  486537354,
  -125797107,
  8959,
  44,
  22144,
  -488621,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1326253688,
  486537354,
  -125782259,
  8959,
  44,
  22192,
  -488657,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  386729592,
  486537354,
  -125768691,
  8959,
  44,
  22240,
  -488693,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -485685640,
  486537353,
  -125744883,
  8959,
  44,
  22288,
  -488725,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1425209736,
  486537353,
  -125666803,
  8959,
  44,
  22336,
  -488761,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1997342328,
  486537353,
  -125644019,
  8959,
  44,
  22384,
  -488793,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1057818232,
  486537353,
  -125630451,
  8959,
  44,
  22432,
  -488829,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  118294136,
  486537353,
  -125627891,
  8959,
  44,
  22480,
  -488865,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -754121096,
  486537352,
  -125623539,
  8959,
  44,
  22528,
  -488897,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1626536328,
  486537352,
  -125364979,
  8959,
  44,
  22576,
  -488929,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1796015736,
  486537352,
  -125364723,
  8959,
  16,
  23280,
  -495896,
  112,
  0,
  20,
  23300,
  -128444,
  75,
  537805568,
  68044546,
  60,
  23324,
  -495828,
  446,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1343112453,
  235563778,
  269369620,
  202260931,
  135152070,
  68043207,
  739013,
  52,
  23388,
  -495444,
  484,
  135151872,
  239141511,
  1090749964,
  75698190,
  53481027,
  235536739,
  202260752,
  135152067,
  68043206,
  738503,
  40,
  23444,
  -495004,
  486,
  1074676480,
  1443201864,
  59179653,
  1359152262,
  68028929,
  -1010382907,
  2886,
  16,
  23488,
  -494552,
  40,
  0,
  16,
  23508,
  -494524,
  38,
  0,
  24,
  23528,
  -494496,
  40,
  135151872,
  241566339,
  49924,
  32,
  23556,
  -494476,
  109,
  135151872,
  239272579,
  235566112,
  68043016,
  739267,
  32,
  23592,
  -494400,
  93,
  135151872,
  239272579,
  172687904,
  239142926,
  189317892,
  16,
  23628,
  -494340,
  41,
  0,
  52,
  23648,
  -494312,
  193,
  135151872,
  239272579,
  172950048,
  239142926,
  189055748,
  135137864,
  68076358,
  174525250,
  239142926,
  189317892,
  52,
  23704,
  -494160,
  193,
  135151872,
  239272579,
  172950048,
  239142926,
  189055748,
  135137864,
  68076358,
  174918466,
  239142926,
  188924676,
  44,
  23760,
  -494008,
  95,
  135151872,
  239272579,
  235564064,
  68043016,
  1175144387,
  1091046922,
  1090784963,
  11,
  40,
  23808,
  -493960,
  88,
  135151872,
  239272579,
  235556384,
  68043016,
  2114667971,
  -1019148274,
  1038,
  16,
  23852,
  -493908,
  6,
  0,
  32,
  23872,
  -493912,
  55,
  135151872,
  239272579,
  235562016,
  68043016,
  739267,
  56,
  23908,
  -493884,
  174,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  336502786,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  16,
  23968,
  -493768,
  15,
  0,
  60,
  23988,
  -493772,
  135,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235561218,
  269369620,
  202260931,
  135152582,
  68043207,
  737989,
  36,
  24052,
  -493692,
  188,
  537805568,
  1208255304,
  -2025323642,
  175702530,
  -960035826,
  738499,
  28,
  24092,
  -493540,
  57,
  135151872,
  239272579,
  135164720,
  -1023144383,
  24,
  24124,
  -493508,
  111,
  806241024,
  235561730,
  737796,
  16,
  24152,
  -493424,
  149,
  0,
  32,
  24172,
  -493284,
  162,
  403587840,
  1208190540,
  -2092432761,
  243401220,
  -1010383100,
  20,
  24208,
  -493144,
  51,
  403587840,
  265839,
  16,
  24232,
  -493104,
  3,
  0,
  32,
  24252,
  -493108,
  125,
  135151872,
  239272579,
  172360224,
  239142926,
  189121284,
  16,
  24288,
  -493016,
  11,
  0,
  32,
  24308,
  -493020,
  75,
  135151872,
  239272579,
  235565856,
  68043016,
  739523,
  40,
  24344,
  -492976,
  70,
  135151872,
  239272579,
  235559968,
  68043016,
  1544243139,
  -1019148274,
  1038,
  32,
  24388,
  -492940,
  63,
  135151872,
  175243907,
  1170408462,
  247678475,
  4,
  60,
  24424,
  -492912,
  553,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  167882499,
  239277070,
  239190800,
  239191564,
  239191816,
  189056260,
  60,
  24488,
  -492416,
  337,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235586050,
  269369620,
  202260931,
  135152070,
  68043207,
  738245,
  20,
  24552,
  -492128,
  19,
  537805568,
  265807,
  60,
  24576,
  -492120,
  481,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  167873283,
  239145998,
  239190800,
  239191564,
  239191816,
  189121796,
  32,
  24640,
  -491688,
  84,
  537805568,
  1208189768,
  174785158,
  -1010433010,
  2882,
  16,
  24676,
  -491628,
  45,
  0,
  16,
  24696,
  -491600,
  15,
  0,
  16,
  24716,
  -491604,
  47,
  0,
  36,
  24736,
  -491576,
  133,
  135151872,
  239469190,
  33784588,
  135137856,
  68043203,
  739526,
  16,
  24776,
  -491472,
  42,
  0,
  40,
  24796,
  -491444,
  348,
  1074676480,
  1275429704,
  59180166,
  1744995664,
  -989590006,
  1103349447,
  11,
  16,
  24840,
  -491136,
  11,
  0,
  16,
  24860,
  -491140,
  6,
  0,
  16,
  24880,
  -491144,
  6,
  0,
  16,
  24900,
  -491148,
  3,
  0,
  16,
  24920,
  -491152,
  6,
  0,
  16,
  24940,
  -491156,
  2,
  0,
  16,
  24960,
  -491160,
  6,
  0,
  16,
  24980,
  -491164,
  3,
  0,
  16,
  25000,
  -491168,
  8,
  0,
  16,
  25020,
  -491172,
  5,
  0,
  16,
  25040,
  -491176,
  60,
  0,
  16,
  25060,
  -491132,
  53,
  0,
  16,
  25080,
  -491088,
  31,
  0,
  28,
  25100,
  -490772,
  73,
  135151872,
  175309443,
  1153631246,
  11,
  28,
  25132,
  -490724,
  57,
  135151872,
  239272579,
  135163680,
  -1023144383,
  16,
  25164,
  -490692,
  43,
  0,
  40,
  25184,
  -490664,
  418,
  1074676480,
  1208256074,
  -2024798845,
  1610777859,
  -989590006,
  1136903879,
  11,
  40,
  25228,
  -490276,
  405,
  1343111936,
  1325761350,
  -2024471931,
  1426359811,
  -989590006,
  1187235527,
  11,
  40,
  25272,
  -489904,
  554,
  1074676480,
  1208124744,
  -2042100349,
  59197444,
  167843587,
  -943389682,
  189187014,
  40,
  25316,
  -489388,
  163,
  806241024,
  1208320844,
  -2025323386,
  42289155,
  235560194,
  -959986428,
  738499,
  16,
  25360,
  -489256,
  23,
  0,
  28,
  25380,
  -489244,
  58,
  135151872,
  239600259,
  135163680,
  -1023144383,
  16,
  25412,
  -489212,
  18,
  0,
  24,
  25432,
  -489200,
  70,
  135151872,
  1140982403,
  12780558,
  76,
  25460,
  -489148,
  446,
  934144,
  1090589505,
  323027475,
  118573571,
  290652794,
  51477254,
  2097484156,
  318844163,
  323077380,
  323076869,
  323077638,
  323077895,
  2047283459,
  293275153,
  85031939,
  125,
  16,
  25540,
  -488780,
  57,
  0,
  16,
  25560,
  -488736,
  37,
  0,
  16,
  25580,
  -488708,
  69,
  0,
  44,
  25600,
  -488648,
  139,
  135151872,
  1091309121,
  -2025582578,
  59130882,
  33850186,
  -1022620045,
  -972550591,
  -956035519,
  28,
  25648,
  -488552,
  70,
  537805568,
  1191412552,
  242418310,
  12830212,
  40,
  25680,
  -488504,
  428,
  1611547392,
  1208320840,
  -2058877818,
  59198466,
  235553282,
  -959986428,
  737731,
  24,
  25724,
  -488116,
  52,
  135151872,
  242352771,
  49924,
  16,
  25752,
  -488080,
  69,
  0,
  24,
  25772,
  -488020,
  70,
  135151872,
  1140982403,
  12780558,
  36,
  25800,
  -487968,
  441,
  135151872,
  239141511,
  59131404,
  234991363,
  239191560,
  50948,
  40,
  25840,
  -487560,
  74,
  135151872,
  242745987,
  239190788,
  1191346952,
  1103299598,
  42141710,
  -1023144377,
  36,
  25884,
  -487524,
  411,
  135151872,
  -2029253055,
  42355715,
  234982147,
  239191816,
  50692,
  16,
  25924,
  -487148,
  57,
  0,
  44,
  25944,
  -487104,
  88,
  135151872,
  1174570824,
  1476527625,
  68044230,
  135152071,
  101253767,
  1187406850,
  13042702,
  16,
  25992,
  -487056,
  69,
  0,
  44,
  26012,
  -486996,
  143,
  135151872,
  1091309121,
  -2025582578,
  59130882,
  33850186,
  -1022620041,
  -972550591,
  -956035519,
  16,
  26060,
  -486900,
  57,
  0,
  16,
  26080,
  -486856,
  37,
  0,
  40,
  26100,
  -486828,
  74,
  135151872,
  242745987,
  239190788,
  1191346952,
  1103299598,
  42141710,
  -1023144377,
  24,
  26144,
  -486792,
  198,
  135151872,
  -1006501241,
  13042702,
  48,
  26172,
  -486612,
  54,
  135151872,
  239272583,
  1090749964,
  75698190,
  1746931267,
  239276046,
  239190796,
  239191560,
  50948,
  48,
  26224,
  -486600,
  64,
  135151872,
  239141511,
  1090749964,
  75698190,
  1981812291,
  239144974,
  239190796,
  239191560,
  50948,
  16,
  26276,
  -486588,
  14,
  0,
  260,
  26296,
  -486592,
  5441,
  239403520,
  1174570760,
  59116558,
  168518922,
  -972550585,
  68062210,
  135153607,
  239534727,
  -519846140,
  1577716481,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  1560939335,
  46532622,
  -956035476,
  184914691,
  135156746,
  68044742,
  51839943,
  42338318,
  68048386,
  135153606,
  646,
  16,
  26560,
  -481400,
  14,
  0,
  284,
  26580,
  -481404,
  4273,
  239403520,
  1174570760,
  59116558,
  246874634,
  239191560,
  189253380,
  250544650,
  239191560,
  189253380,
  16909066,
  1103497230,
  1204225038,
  240454155,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  1204225038,
  240978443,
  1812121096,
  63374350,
  168493434,
  -972550552,
  -956035513,
  168549122,
  -972550548,
  -956035519,
  234972163,
  33719816,
  -972812708,
  -2046292409,
  2,
  44,
  26868,
  -477404,
  5229,
  18154240,
  42141710,
  -2029253055,
  269369603,
  1543701638,
  -972288494,
  -955773375,
  -1023144383,
  36,
  26916,
  -472220,
  651,
  18350848,
  42403854,
  -2046030271,
  242680323,
  239191560,
  50948,
  72,
  26956,
  -471604,
  219,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837629,
  175768069,
  1136857102,
  1103498254,
  1103562766,
  1103430670,
  -1018363381,
  -968683506,
  -952038386,
  -985593842,
  1038,
  56,
  27032,
  -471456,
  188,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  176685573,
  1136857102,
  1103498254,
  1103562766,
  1204093966,
  11,
  180,
  27092,
  -471324,
  6219,
  245891584,
  1124239112,
  59116558,
  236202499,
  242402824,
  239191812,
  1929545480,
  1103561742,
  42403854,
  68044034,
  135152071,
  242811527,
  239191812,
  1258456840,
  1103561742,
  42403854,
  -956035503,
  -2029515199,
  68048130,
  135152071,
  239927943,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035507,
  -2029515199,
  68047618,
  135152071,
  241238663,
  239191812,
  1560446728,
  1103561742,
  42403854,
  -956035485,
  -2029515199,
  68050690,
  135152071,
  241107591,
  239191812,
  235046664,
  50948,
  776,
  27276,
  -465284,
  11112,
  135151872,
  -956169597,
  59182094,
  -2045768125,
  391971588,
  2076576782,
  1103562766,
  1103299598,
  42141710,
  59182094,
  135152130,
  68043207,
  135152067,
  202244739,
  1409418119,
  1103562766,
  1103299598,
  42141710,
  59182094,
  -955773320,
  -1023144383,
  -2096624063,
  -2029253118,
  -2045768189,
  202264324,
  19137478,
  75894798,
  -972288420,
  -955773332,
  -1023144383,
  -2096624063,
  -2029253118,
  135163907,
  68043207,
  135152067,
  202244739,
  242811783,
  239191816,
  239190788,
  235045640,
  2097383180,
  1103562766,
  1103299598,
  42141710,
  59182094,
  -955773343,
  -1023144383,
  -2096624063,
  -2029253118,
  135159811,
  68043207,
  135152067,
  202244739,
  241435527,
  239191816,
  239190788,
  235045640,
  1543735052,
  1103562766,
  1103299598,
  42141710,
  59182094,
  -955773344,
  -1023144383,
  -2096624063,
  -2029253118,
  135158787,
  68043207,
  135152067,
  202244739,
  241304455,
  239191816,
  239190788,
  235045640,
  1610843916,
  1103562766,
  1103299598,
  42141710,
  59182094,
  -955773332,
  -1023144383,
  -2096624063,
  -2029253118,
  135160323,
  68043207,
  135152067,
  202244739,
  242090887,
  239191816,
  239190788,
  235045640,
  1845724940,
  1103562766,
  1103299598,
  42141710,
  59182094,
  1321666574,
  1103299598,
  42141710,
  -1023144367,
  -2096624063,
  68046850,
  135152067,
  240255619,
  239190788,
  1258455816,
  1103299598,
  42141710,
  -1023144366,
  -2096624063,
  68046850,
  135152067,
  239993475,
  239190788,
  1308787464,
  1103299598,
  42141710,
  -1023144366,
  -2096624063,
  68046850,
  135152067,
  239993475,
  239190788,
  1325564680,
  1103299598,
  42141710,
  -1023144367,
  -2096624063,
  68046594,
  135152067,
  240059011,
  239190788,
  1325564680,
  1103299598,
  42141710,
  202278146,
  239141767,
  -1576876280,
  1103299598,
  42141710,
  -1023144351,
  -2096624063,
  68052226,
  135152067,
  240583299,
  239190788,
  1694663432,
  1103299598,
  42141710,
  -1023144351,
  -2096624063,
  68050178,
  135152067,
  240976515,
  239190788,
  1694663432,
  1103299598,
  42141710,
  -1023144351,
  -2096624063,
  68050178,
  135152067,
  241107587,
  239190788,
  1661109000,
  1103299598,
  42141710,
  -1023144337,
  -2096624063,
  68054786,
  135152067,
  241500803,
  239190788,
  235045640,
  235111948,
  50628368,
  202246224,
  -955773242,
  -1023144373,
  -2096624063,
  242483714,
  239190788,
  33719048,
  -1023144367,
  -2096624063,
  242549250,
  239190788,
  33719048,
  -1023144362,
  -2096624063,
  2,
  180,
  28056,
  -454944,
  6252,
  245891584,
  1124239112,
  59116558,
  236202499,
  242468360,
  239191812,
  1929545480,
  1103561742,
  42403854,
  68044034,
  135152071,
  242811527,
  239191812,
  1241679624,
  1103561742,
  42403854,
  -956035502,
  -2029515199,
  68048130,
  135152071,
  240976519,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035491,
  -2029515199,
  68047618,
  135152071,
  241238663,
  239191812,
  1560446728,
  1103561742,
  42403854,
  -956035485,
  -2029515199,
  68050690,
  135152071,
  241107591,
  239191812,
  235046664,
  50948,
  180,
  28240,
  -448872,
  1509,
  245891584,
  1090684680,
  58919950,
  234998787,
  1224917768,
  1103561742,
  42403854,
  68048130,
  135152071,
  240255623,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035499,
  -2029515199,
  68044546,
  135152071,
  240452231,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035507,
  -2029515199,
  68048130,
  135152071,
  241238663,
  239191812,
  1560446728,
  1103561742,
  42403854,
  -956035489,
  -2029515199,
  68051202,
  135152071,
  241107591,
  239191812,
  1594001160,
  1103561742,
  42403854,
  13042702,
  2160,
  28424,
  -447536,
  4006,
  135151872,
  239141507,
  1090749964,
  75960334,
  235175427,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1527023376,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511199,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202268676,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  240649351,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1610909456,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511198,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202267396,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  240845959,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1610909456,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511198,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202267396,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  240977031,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1627686672,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511187,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202272004,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  241370247,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1610909456,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511198,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202267396,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  240977031,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1610909456,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511186,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202272004,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  242025607,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1879344912,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511182,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202271492,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  242025607,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1728349968,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511187,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202272004,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  242025607,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1392805648,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511217,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202265348,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  239404167,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1392805648,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511217,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202263300,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  239797383,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1392805648,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511201,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202267396,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  240977031,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1627686672,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511203,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202267908,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  240321671,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1392805648,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511201,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202267396,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  240977031,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1661241104,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511205,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202267908,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  240977031,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1661241104,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511201,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202267396,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  240977031,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1459914512,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511203,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202267908,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  240977031,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1661241104,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511227,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202264324,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  239993991,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1292142352,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511220,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202264580,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  239993991,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1275365136,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511220,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202264580,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  239993991,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1275365136,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511219,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  202264324,
  135152071,
  68043206,
  135152067,
  202244739,
  269353862,
  239928455,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  1225033488,
  1103563790,
  1103497230,
  1103299598,
  42141710,
  59116558,
  75960334,
  -955511220,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  250216964,
  239191820,
  239191560,
  239190788,
  235045640,
  235111948,
  33851152,
  -955511138,
  -972550591,
  -1023144383,
  -2096624063,
  -2046030334,
  -2028990973,
  4,
  180,
  30588,
  -445684,
  1542,
  245891584,
  1090684680,
  58919950,
  234998787,
  1241694984,
  1103561742,
  42403854,
  68048130,
  135152071,
  240190087,
  239191812,
  1375897352,
  1103561742,
  42403854,
  -956035499,
  -2029515199,
  68048642,
  135152071,
  240452231,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035491,
  -2029515199,
  68048130,
  135152071,
  241238663,
  239191812,
  1560446728,
  1103561742,
  42403854,
  -956035489,
  -2029515199,
  68051202,
  135152071,
  241107591,
  239191812,
  1594001160,
  1103561742,
  42403854,
  13042702,
  216,
  30772,
  -444316,
  980,
  135151872,
  1610809991,
  -956035583,
  -2029515199,
  239403522,
  239191812,
  33720072,
  -956035492,
  -2029515199,
  239403522,
  239191812,
  33720072,
  -956035515,
  -2029515199,
  240255490,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035504,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046338,
  135152071,
  647,
  688,
  30992,
  -443544,
  1583,
  135151872,
  1275200135,
  59116558,
  -2096099775,
  202261508,
  -1022882106,
  -2046030249,
  269369603,
  239666307,
  135185932,
  202276803,
  239141766,
  1141146384,
  247860238,
  240304904,
  1090749964,
  75698190,
  202276610,
  135152067,
  202261958,
  269353859,
  239207558,
  239190796,
  239322632,
  239191812,
  235046664,
  235111180,
  33850896,
  -1022620074,
  -972550591,
  -2096361915,
  -2045768189,
  202274052,
  135152067,
  202261958,
  269353859,
  242287750,
  239190796,
  239453704,
  235111180,
  1929676304,
  1103301646,
  1170606094,
  58919950,
  75894798,
  -1022620083,
  -972550591,
  -2096361915,
  -2045768189,
  202263044,
  135152067,
  202261958,
  269353859,
  239731846,
  239190796,
  239453704,
  235111180,
  1241810448,
  1103301646,
  1170606094,
  58919950,
  75894798,
  -1022620086,
  -972550591,
  -2096361918,
  -2045768189,
  202263812,
  135152067,
  202261190,
  269353859,
  240059526,
  239190796,
  239257096,
  235111180,
  1292142096,
  1103301646,
  1120274446,
  58919950,
  75894798,
  -1022620083,
  -972550591,
  -2096361918,
  -2045768189,
  202263812,
  135152067,
  202261190,
  269353859,
  239928454,
  239190796,
  239257096,
  235111180,
  1292142096,
  1103301646,
  1791363086,
  1103561742,
  42403854,
  -956035484,
  -2029515199,
  68053250,
  135152071,
  241697415,
  239191812,
  1141016328,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1308788488,
  1103561742,
  42403854,
  68043266,
  135152071,
  242352775,
  239191812,
  1979877128,
  1103561742,
  42403854,
  -956035464,
  -2029515199,
  68047362,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  2,
  48,
  31684,
  -442652,
  260,
  135151872,
  1476526727,
  1103561742,
  42403854,
  68067330,
  135152071,
  239600263,
  239191812,
  165640,
  172,
  31736,
  -442432,
  486,
  135154432,
  1107427975,
  59116558,
  -2096099775,
  202262276,
  -1022882106,
  -956035482,
  -2029515199,
  202262786,
  239141766,
  1292141328,
  247860238,
  243254024,
  1090749964,
  75698190,
  -972288444,
  1724057614,
  1103561742,
  42403854,
  -2046030265,
  269369603,
  -2080242557,
  1103301646,
  1153828878,
  1103561742,
  42403854,
  58919950,
  75894798,
  -1022620046,
  -972550591,
  -956035511,
  -2029515199,
  68044290,
  135152071,
  202244743,
  269353859,
  239928454,
  239190796,
  239191560,
  50948,
  328,
  31912,
  -442112,
  1380,
  135151872,
  402850439,
  -956035582,
  -2029515199,
  68051458,
  135152071,
  241762951,
  239191812,
  1744996104,
  1103561742,
  42403854,
  68057858,
  135152071,
  239534727,
  239191812,
  1342342920,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  243204743,
  239191812,
  1879213832,
  1103561742,
  42403854,
  -956035463,
  -2029515199,
  68052994,
  135152071,
  239731335,
  239191812,
  1493337864,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  239796871,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1325565704,
  1103561742,
  42403854,
  -956035505,
  -2029515199,
  68046594,
  135152071,
  239665799,
  239191812,
  165640,
  148,
  32244,
  -441052,
  836,
  240517632,
  1560446728,
  1321665550,
  42403854,
  -956035478,
  -2029515199,
  23593730,
  1103561742,
  42403854,
  68054530,
  135152071,
  242549383,
  239191812,
  1308788488,
  1103561742,
  42403854,
  -956035507,
  -2029515199,
  68047106,
  135152071,
  240059015,
  239191812,
  1359120136,
  1103561742,
  42403854,
  -956035500,
  -2029515199,
  68046594,
  135152071,
  240059015,
  239191812,
  1124239112,
  1103561742,
  42403854,
  16,
  32396,
  -440356,
  787,
  0,
  16,
  32416,
  -439576,
  531,
  0,
  344,
  32436,
  -439052,
  1771,
  135152896,
  -469564793,
  -956035582,
  42403854,
  -956035482,
  42403854,
  -956035481,
  42403854,
  -956035479,
  42403854,
  68052994,
  -2029515065,
  68058626,
  -2029515065,
  68055810,
  -2029515065,
  68056834,
  -2029515065,
  68053250,
  -2029515065,
  68048130,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68045826,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68046850,
  -2029515065,
  68045826,
  -2029515065,
  241041922,
  135186180,
  1493303943,
  247923726,
  33720072,
  -956035504,
  42403854,
  -956035468,
  42403854,
  -956035500,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  -956035515,
  42403854,
  36,
  32784,
  -437624,
  150,
  135151872,
  239272582,
  33784588,
  135137932,
  68043203,
  737734,
  16,
  32824,
  -437504,
  26,
  0,
  48,
  32844,
  -437492,
  9408,
  248447488,
  1090684680,
  59116558,
  51383874,
  202252867,
  -972550591,
  -956035519,
  234988803,
  0,
  16,
  32896,
  -428136,
  26,
  0,
  52,
  32916,
  -428124,
  1190,
  135157504,
  67306119,
  -2046030334,
  249758211,
  239191560,
  239388420,
  239978240,
  1241614084,
  1187446798,
  25625614,
  60,
  32972,
  -426980,
  368,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837626,
  739132677,
  235592450,
  269369620,
  202260931,
  135152070,
  68043207,
  738245,
  88,
  33036,
  -426676,
  896,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837631,
  -267499515,
  31851272,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  19268363,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  11,
  84,
  33128,
  -425872,
  881,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  235579650,
  269370132,
  202260931,
  135152070,
  68043207,
  1124811461,
  1125387786,
  1125125827,
  1091309254,
  1091047111,
  1157893829,
  11,
  24,
  33216,
  -425064,
  47,
  269370112,
  68029025,
  2884,
  16,
  33244,
  -425044,
  10,
  0,
  32,
  33264,
  -425048,
  88,
  135151872,
  239141510,
  33784588,
  -1022882220,
  -972812735,
  16,
  33300,
  -424988,
  10,
  0,
  16,
  33320,
  -424992,
  10,
  0,
  60,
  33340,
  -424996,
  539,
  135151872,
  222429829,
  75908869,
  -2091908217,
  184025605,
  1103512003,
  67912135,
  188990724,
  -1022708222,
  -951990719,
  67945793,
  739076,
  64,
  33404,
  -424516,
  823,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  -1878112763,
  25035523,
  1125387786,
  1103302670,
  1103498254,
  1103562766,
  1170539534,
  11,
  84,
  33472,
  -423752,
  840,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  -1878112763,
  24052483,
  1125387786,
  1103302670,
  1103498254,
  1103562766,
  1153762318,
  176030219,
  -1019014130,
  -968683506,
  -952038386,
  -985593842,
  188875790,
  36,
  33560,
  -422992,
  144,
  135151872,
  239141510,
  33784588,
  135137914,
  68043203,
  737734,
  28,
  33600,
  -422888,
  59,
  135151872,
  239272579,
  135165216,
  -1023144383,
  40,
  33632,
  -422856,
  89,
  135151872,
  239403651,
  235568176,
  68043528,
  1292583875,
  -1019017202,
  1038,
  44,
  33676,
  -422804,
  460,
  135151872,
  222429829,
  92492293,
  59180166,
  167849731,
  1103512003,
  67912135,
  188859652,
  44,
  33724,
  -422388,
  100,
  135151872,
  239141510,
  1157858060,
  1090654222,
  1091309066,
  1103300622,
  1103496206,
  11,
  44,
  33772,
  -422324,
  123,
  135151872,
  239272582,
  1157858060,
  1426202638,
  1091309066,
  1103300622,
  1220936718,
  11,
  20,
  33820,
  -422244,
  35,
  537805568,
  265823,
  20,
  33844,
  -422220,
  35,
  537805568,
  265823,
  24,
  33868,
  -422196,
  26,
  135151872,
  240648835,
  49924,
  44,
  33240,
  -418472,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  873268856,
  486537629,
  -107307763,
  8959,
  44,
  33288,
  -418504,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  853624,
  486537629,
  -107316723,
  8959,
  44,
  33336,
  -418536,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -871561608,
  486537628,
  -107281139,
  8959,
  44,
  33384,
  -418568,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1743976840,
  486537628,
  -107281139,
  8959,
  44,
  33432,
  -418600,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1678575224,
  486537628,
  -107281395,
  8959,
  44,
  33480,
  -418632,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  806159992,
  486537628,
  -107260403,
  8959,
  24,
  34184,
  -422480,
  45,
  135152640,
  241697411,
  49924,
  40,
  34212,
  -422460,
  644,
  537805568,
  1376093003,
  59179653,
  1895957638,
  -989590006,
  1204012743,
  11,
  28,
  34256,
  -139320,
  66,
  135151872,
  239272579,
  135167008,
  -1023144383,
  40,
  34288,
  -421880,
  107,
  135151872,
  239272582,
  1124303628,
  1627529230,
  239143950,
  239190792,
  50692,
  60,
  34332,
  -421812,
  166,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235570690,
  269370132,
  202260931,
  135152070,
  68043207,
  737733,
  48,
  34396,
  -421700,
  1656,
  135151872,
  222757509,
  75909893,
  -2090859641,
  20841221,
  -968768758,
  205637441,
  1153762308,
  11,
  44,
  34448,
  -420088,
  381,
  537805568,
  1241744968,
  75694727,
  68029017,
  1120126663,
  18481931,
  -956035574,
  189187014,
  20,
  34496,
  -419752,
  76,
  269370112,
  68044802,
  36,
  34520,
  -419696,
  155,
  269370112,
  1225032517,
  -2025127034,
  174129666,
  -960035826,
  738243,
  20,
  34560,
  -419576,
  106,
  269370112,
  68052482,
  52,
  34584,
  -419488,
  328,
  135151872,
  239141511,
  1090749964,
  75698190,
  37752387,
  269355724,
  -1022620093,
  -972550591,
  -956035519,
  2881,
  44,
  34640,
  -419112,
  3017,
  135151872,
  222429829,
  92490757,
  59180166,
  1103301242,
  1103577542,
  -989592564,
  2884,
  80,
  34688,
  -416136,
  475,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167886083,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  1091833421,
  1091571395,
  1091309254,
  1091047111,
  265925,
  108,
  34772,
  -415740,
  1470,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  167924739,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  235567874,
  247677204,
  247873808,
  247939340,
  247808264,
  1359692036,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  11,
  64,
  34884,
  -414380,
  6733,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1341241851,
  26739457,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1120207886,
  11,
  20,
  34952,
  -407712,
  52,
  806241024,
  265840,
  52,
  34976,
  -407672,
  158,
  135151872,
  239141511,
  1090749964,
  75698190,
  35655237,
  269355615,
  -1022620095,
  -972550591,
  -956035519,
  2881,
  36,
  35032,
  -407568,
  146,
  537805568,
  1224967750,
  -2025454461,
  174195202,
  -960035826,
  739011,
  60,
  35072,
  -407448,
  247,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837629,
  806241541,
  235559938,
  269370132,
  202260931,
  135152070,
  68043207,
  737733,
  60,
  35136,
  -407256,
  253,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676997,
  235589890,
  269369620,
  202260931,
  135152070,
  68043207,
  737733,
  60,
  35200,
  -407064,
  565,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837629,
  1074677765,
  235553282,
  269369620,
  202260931,
  135152070,
  68043207,
  738501,
  84,
  35264,
  -406552,
  358,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241541,
  235577858,
  269369620,
  202260931,
  135152070,
  68043207,
  1863008709,
  1125387786,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  11,
  32,
  35352,
  -406272,
  82,
  135151872,
  239403651,
  235558432,
  68043016,
  738243,
  32,
  35388,
  -406212,
  70,
  135151872,
  239272579,
  239075872,
  68043016,
  195,
  40,
  35424,
  -406168,
  238,
  806241024,
  1208320840,
  -2059009145,
  75908610,
  235563010,
  -959986428,
  739779,
  24,
  35468,
  -405972,
  86,
  537805568,
  68029054,
  2881,
  16,
  35496,
  -405904,
  14,
  0,
  40,
  35516,
  -405908,
  62,
  135151872,
  239272579,
  235559200,
  68043016,
  1326140099,
  239470606,
  49924,
  44,
  34904,
  -405715,
  13,
  34084352,
  373491832,
  91750920,
  235411012,
  101516920,
  486537679,
  -103908595,
  8959,
  44,
  34952,
  -405750,
  10,
  34084352,
  373491832,
  91750920,
  235411012,
  -821229960,
  486537678,
  -103899123,
  8959,
  60,
  35656,
  -405984,
  173,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235573250,
  269370132,
  202260931,
  135152070,
  68043207,
  737733,
  16,
  35720,
  -405840,
  31,
  0,
  60,
  35740,
  -405828,
  700,
  135151872,
  222429829,
  92492549,
  59180166,
  167889155,
  1103512003,
  67912135,
  188859652,
  -1022722558,
  -951990719,
  67945793,
  738308,
  20,
  35804,
  -405188,
  36,
  537805568,
  265824,
  72,
  35828,
  -405164,
  1055,
  135151872,
  222429829,
  92489989,
  59180166,
  -1022736638,
  -951990719,
  67374145,
  1426801349,
  -968768758,
  -985544895,
  1208222732,
  176882187,
  1103512003,
  214254023,
  188875780,
  16,
  35904,
  -404184,
  59,
  0,
  16,
  35924,
  -404140,
  12,
  0,
  16,
  35944,
  -404144,
  12,
  0,
  16,
  35964,
  -404148,
  12,
  0,
  44,
  35984,
  -404152,
  223,
  135151872,
  222429829,
  59196165,
  -2046459045,
  178389508,
  1103512771,
  67912135,
  189252868,
  56,
  36032,
  -403976,
  1841,
  1343111936,
  1392739912,
  75694727,
  235563266,
  -1010383100,
  1459817281,
  -960296447,
  1141116615,
  43909899,
  -956035574,
  189121478,
  40,
  36092,
  -402180,
  1546,
  -1878112768,
  75912449,
  1375962958,
  92471941,
  235560450,
  -959986428,
  739267,
  16,
  36136,
  -400672,
  23,
  0,
  20,
  36156,
  -400660,
  41,
  806241024,
  265827,
  32,
  36180,
  -400636,
  45,
  135151872,
  173736579,
  1103299598,
  247680779,
  4,
  32,
  36216,
  -400624,
  71,
  202261248,
  -2096986541,
  235560963,
  1103349252,
  11,
  36,
  36252,
  -400580,
  167,
  537805568,
  -2096921004,
  42424324,
  68029029,
  1103349447,
  11,
  24,
  36292,
  -400444,
  49,
  269370112,
  68029023,
  2885,
  28,
  36320,
  -400408,
  88,
  50950656,
  1103319298,
  239601678,
  4,
  16,
  36352,
  -400344,
  35,
  0,
  40,
  36372,
  -400316,
  1836,
  -267500032,
  42290689,
  1376028238,
  92472199,
  235573506,
  -959986428,
  738243,
  32,
  36416,
  -398520,
  45,
  135151872,
  173736579,
  1103299598,
  247680779,
  4,
  32,
  36452,
  -398508,
  51,
  135151872,
  173867651,
  1120076814,
  247681547,
  4,
  32,
  36488,
  -398480,
  150,
  537805568,
  -2096986544,
  235564803,
  1103349252,
  11,
  24,
  36524,
  -398356,
  52,
  537805568,
  68029004,
  2881,
  20,
  36552,
  -398320,
  41,
  806241024,
  265827,
  80,
  36576,
  -398296,
  92,
  135151872,
  1091309121,
  239144974,
  42294036,
  1275298628,
  -2025585530,
  269372421,
  202260935,
  135152070,
  68043203,
  336481477,
  58917509,
  92734598,
  -955249087,
  -972288447,
  -1022882239,
  -989589951,
  36,
  36660,
  -398284,
  162,
  537805568,
  1224902470,
  -2042231677,
  174588419,
  -960035826,
  739523,
  28,
  36700,
  -398148,
  68,
  537805568,
  1224966982,
  242287238,
  12830212,
  40,
  36732,
  -398100,
  291,
  403587840,
  1376028236,
  59179653,
  -1576925821,
  -989590006,
  1170458311,
  11,
  60,
  36776,
  -397840,
  292,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  167839491,
  239277070,
  239190800,
  239191564,
  239191816,
  189056260,
  52,
  36840,
  -397600,
  69,
  135151872,
  239141511,
  1090749964,
  75698190,
  1965035075,
  1125125642,
  1103301646,
  1103497230,
  1103561742,
  11,
  60,
  36896,
  -397576,
  1081,
  135151872,
  222429829,
  92490757,
  59180166,
  -1022724094,
  -951990719,
  67374145,
  51070661,
  -1022754467,
  -951990719,
  67945793,
  739332,
  16,
  36960,
  -396552,
  27,
  0,
  16,
  36980,
  -396540,
  26,
  0,
  16,
  37000,
  -396528,
  16,
  0,
  40,
  37020,
  -396532,
  127,
  537805568,
  -2096921004,
  42421252,
  68029039,
  1103349447,
  -960271605,
  265927,
  80,
  37064,
  -396448,
  114,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235558658,
  269369620,
  202260931,
  135152070,
  68043207,
  1124812485,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  1038,
  28,
  37148,
  -396404,
  91,
  202261248,
  -2096986541,
  239337987,
  12830212,
  16,
  37180,
  -396340,
  13,
  269370112,
  84,
  37200,
  -396344,
  490,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  167845123,
  239145998,
  239190800,
  239191564,
  239191816,
  189318404,
  235563522,
  247678484,
  247873808,
  247939340,
  247808264,
  738564,
  28,
  37288,
  -395936,
  59,
  135151872,
  239272582,
  1208189708,
  8206,
  60,
  37320,
  -395904,
  185,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837629,
  403587845,
  235553538,
  269369620,
  202260931,
  135152070,
  68043207,
  739013,
  28,
  37384,
  -395776,
  68,
  537805568,
  1141080905,
  242418310,
  12830212,
  60,
  37416,
  -395728,
  730,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  167918339,
  239277070,
  239190800,
  239191564,
  239191816,
  188859652,
  84,
  37480,
  -395056,
  201,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241541,
  336464493,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  1342311233,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  40,
  37568,
  -654559,
  214,
  135151872,
  222560901,
  92491781,
  59180166,
  1103346946,
  1103577542,
  -989592564,
  44,
  37612,
  -654389,
  333,
  135151872,
  222429829,
  92488965,
  59180166,
  -1023327997,
  -951990719,
  67374145,
  197,
  36,
  37660,
  -395028,
  109,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837629,
  806241541,
  60,
  37700,
  -394956,
  3894,
  135151872,
  222429829,
  92495877,
  59180166,
  -1022702334,
  -951990719,
  67945793,
  51070212,
  -1022752730,
  -951990719,
  67374145,
  737733,
  60,
  37764,
  -391116,
  1203,
  135151872,
  222429829,
  59196165,
  -2046459043,
  30147332,
  -968768758,
  205637441,
  1103430660,
  173081099,
  1103512003,
  214254023,
  188810244,
  60,
  37828,
  -389964,
  988,
  135151872,
  222429829,
  92499461,
  59180166,
  167896835,
  1103512003,
  67912135,
  189121796,
  -1022706686,
  -951990719,
  67945795,
  737540,
  60,
  37892,
  -389036,
  176,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241541,
  235572482,
  269369620,
  202260931,
  135152070,
  68043207,
  739013,
  56,
  37956,
  -388924,
  162,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837629,
  806241029,
  336499202,
  -1022357949,
  -972288447,
  -955773375,
  -989589951,
  60,
  38016,
  -388808,
  573,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235560450,
  269369620,
  202260931,
  135152070,
  68043207,
  739269,
  52,
  38080,
  -388296,
  342,
  1074676480,
  1174766417,
  -2059008890,
  59196418,
  68029022,
  -1010382907,
  -1409152187,
  -989590006,
  1103349447,
  11,
  40,
  38136,
  -388000,
  448,
  1074676480,
  1208320838,
  -2058287994,
  1543735042,
  -989590006,
  1120126663,
  11,
  60,
  38180,
  -387596,
  643,
  135151872,
  222757509,
  92494597,
  59180166,
  167857155,
  1103512003,
  67912135,
  188859652,
  -1022707966,
  -951990719,
  67945793,
  737540,
  84,
  38244,
  -387004,
  1939,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837629,
  -2146547707,
  174588421,
  239277070,
  239190800,
  239191564,
  239191816,
  189056260,
  235596290,
  247677204,
  247873808,
  247940364,
  247808264,
  738820,
  44,
  38332,
  -385140,
  376,
  135151872,
  239272582,
  1124303628,
  2063740942,
  1091309066,
  1103300622,
  1153827854,
  11,
  144,
  38380,
  -384804,
  275,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  403587845,
  235582466,
  247677204,
  247873808,
  247939340,
  247808264,
  1644904708,
  1091833354,
  1103302670,
  1103498254,
  1137117198,
  1103430670,
  235553547,
  247678484,
  247873808,
  247939340,
  247808264,
  1124811012,
  1192496650,
  1125125827,
  1091309254,
  1091047111,
  1090784965,
  336478987,
  269402950,
  202294849,
  135186241,
  68076865,
  84,
  38528,
  -384664,
  1426,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  167863811,
  239277070,
  239190800,
  239191564,
  239191816,
  189121796,
  167945987,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  20,
  38616,
  -383312,
  48,
  537805568,
  265836,
  60,
  38640,
  -383288,
  110,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  403588357,
  235557634,
  269369620,
  202260931,
  135152070,
  68043207,
  739525,
  40,
  38704,
  -383240,
  371,
  806241024,
  1174766406,
  -2057829242,
  33785602,
  68029087,
  -1010382907,
  2882,
  84,
  38748,
  -382900,
  1695,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1609677307,
  23790337,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1204093966,
  235568395,
  247678484,
  247873808,
  247939340,
  247808264,
  737796,
  64,
  38836,
  -381292,
  2532,
  135151872,
  222429829,
  59196165,
  -2046459065,
  21562116,
  -968768758,
  205637441,
  1204093956,
  18023179,
  -968768758,
  -985544895,
  1241777164,
  11,
  36,
  38904,
  -378816,
  186,
  537805568,
  -2046654634,
  33850115,
  68029014,
  1103349447,
  11,
  44,
  38944,
  -378664,
  148,
  135151872,
  239272582,
  1241744140,
  2063736846,
  1091309066,
  1103300622,
  1103496206,
  11,
  60,
  38992,
  -378552,
  695,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837629,
  1074676485,
  167887363,
  239277070,
  239190800,
  239191564,
  239191816,
  189252868,
  36,
  39056,
  -377912,
  199,
  806241024,
  -2029877921,
  -2096855549,
  176554501,
  -943389682,
  189318086,
  32,
  39096,
  -377744,
  48,
  135151872,
  239403651,
  235558176,
  68043016,
  737731,
  44,
  39132,
  -377732,
  149,
  135151872,
  239141510,
  1124303628,
  1761746958,
  1091309066,
  1103300622,
  1103496206,
  11,
  32,
  39180,
  -377620,
  93,
  135151872,
  239403651,
  235568160,
  68043016,
  737731,
  32,
  39216,
  -377560,
  84,
  135151872,
  239141511,
  1124304396,
  75698190,
  4197957,
  44,
  39252,
  -377500,
  6772,
  135151872,
  222429829,
  92491525,
  59180166,
  168053251,
  1103512003,
  67912135,
  188859652,
  40,
  39300,
  -370764,
  374,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837629,
  -535934971,
  8,
  36,
  39344,
  -370424,
  154,
  1074676480,
  1241744978,
  75694727,
  68029030,
  1136903879,
  11,
  36,
  39384,
  -370304,
  208,
  135151872,
  239469187,
  -1979579936,
  1124601354,
  1136854030,
  11,
  36,
  39424,
  -370136,
  102,
  1074676480,
  1174766406,
  -2025454458,
  42288131,
  68045826,
  -1010382907,
  16,
  39464,
  -370064,
  2,
  0,
  32,
  39484,
  -370068,
  80,
  135152896,
  175899267,
  1203962894,
  247678731,
  4,
  48,
  39520,
  -370024,
  1112,
  135151872,
  222429829,
  59196165,
  1124369987,
  -402520701,
  -968768758,
  205637441,
  1103430660,
  11,
  40,
  39572,
  -368956,
  196,
  -1609677312,
  92489985,
  -2046589101,
  42289412,
  235563010,
  -959986428,
  738755,
  20,
  39616,
  -368792,
  33,
  537805568,
  265821,
  20,
  39640,
  -368768,
  33,
  537805568,
  265821,
  20,
  39664,
  -368744,
  29,
  537805568,
  265817,
  52,
  39688,
  -368736,
  98,
  135151872,
  239272582,
  1157858060,
  1208098830,
  1124863498,
  1103300622,
  1137050638,
  202261259,
  135185221,
  68077121,
  32,
  39744,
  -368680,
  85,
  135151872,
  239469190,
  33784588,
  -1022882228,
  -972812735,
  32,
  39780,
  -368620,
  76,
  537805568,
  1174570570,
  175047555,
  -1010433010,
  2886,
  36,
  39816,
  -368576,
  224,
  806241024,
  -2029877927,
  -2096855549,
  235561221,
  -959986428,
  737731,
  16,
  39856,
  -368392,
  16,
  0,
  44,
  39876,
  -368396,
  239,
  806241024,
  1325695823,
  59114119,
  235559682,
  -1010383100,
  174918468,
  247973571,
  738052,
  60,
  39924,
  -368204,
  526,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  167876099,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  28,
  39988,
  -367740,
  37,
  269370112,
  68029004,
  239602505,
  4,
  56,
  40020,
  -367724,
  113,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837631,
  1074676997,
  336486658,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  32,
  40080,
  -367656,
  120,
  269370112,
  -2046654631,
  1829012227,
  -956035574,
  188859334,
  40,
  40116,
  -367564,
  214,
  806241024,
  1308919368,
  92472199,
  33719628,
  68029037,
  -1010382907,
  2881,
  88,
  40160,
  -367384,
  334,
  135151872,
  239469191,
  1090749964,
  75698190,
  547360331,
  235567874,
  202261264,
  135152067,
  68043206,
  34293191,
  269355617,
  202294083,
  135185985,
  68077377,
  172362562,
  -1018687474,
  -968815602,
  -952039410,
  189269006,
  32,
  40252,
  -367140,
  182,
  537805568,
  1308853064,
  173343366,
  -1010433010,
  2881,
  32,
  40288,
  -366984,
  88,
  135151872,
  239403651,
  235568928,
  68043016,
  737731,
  28,
  40324,
  -366924,
  30,
  202260480,
  1091571265,
  239145998,
  336481816,
  84,
  40356,
  -366926,
  182,
  202260992,
  1158680129,
  239145998,
  470696216,
  1159728705,
  240134158,
  604918060,
  1092619848,
  239934478,
  159597348,
  -2027418045,
  739131658,
  223480710,
  1137068291,
  67981255,
  239321924,
  1141788736,
  527971,
  20,
  40444,
  -366820,
  27,
  537805568,
  265815,
  20,
  40468,
  -366812,
  36,
  537805568,
  265824,
  16,
  40492,
  -366788,
  12,
  0,
  16,
  40512,
  -366792,
  4,
  0,
  16,
  40532,
  -366808,
  23,
  0,
  32,
  40552,
  -366805,
  26,
  135153152,
  1091309121,
  239996942,
  135151884,
  265793,
  32,
  40588,
  -366815,
  32,
  135154688,
  1091309121,
  239996942,
  135151884,
  265793,
  32,
  40624,
  -366819,
  32,
  135154688,
  1091309121,
  239996942,
  135151884,
  265793,
  32,
  40660,
  -366823,
  32,
  135154688,
  1091309121,
  239996942,
  135151884,
  265793,
  44,
  40696,
  -366816,
  1851,
  135151872,
  222429829,
  92488965,
  59180166,
  167963139,
  1103512003,
  67912135,
  188990724,
  84,
  40744,
  -365008,
  530,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837629,
  1343112453,
  167843331,
  239145998,
  239190800,
  239191564,
  239191816,
  189383940,
  336464451,
  269402950,
  202294849,
  135186241,
  68076865,
  2884,
  60,
  40832,
  -364552,
  148,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235559426,
  269370132,
  202260931,
  135152070,
  68043207,
  739781,
  44,
  40240,
  -360970,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -770898312,
  486537853,
  -92557299,
  8959,
  44,
  40288,
  -361002,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1643313544,
  486537853,
  -92560371,
  8959,
  44,
  40336,
  -361034,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1779238520,
  486537853,
  -92547059,
  8959,
  44,
  40384,
  -361066,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  906823288,
  486537853,
  -92553459,
  8959,
  44,
  40432,
  -361098,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  34408056,
  486537853,
  -92522995,
  8959,
  44,
  40480,
  -361130,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -838007176,
  486537852,
  -92526323,
  8959,
  44,
  40528,
  -361162,
  13,
  34084352,
  373689208,
  91750920,
  235411012,
  -1710422408,
  486537852,
  -92528883,
  8959,
  40,
  41232,
  -146216,
  74,
  135151872,
  239141510,
  1157858060,
  175448078,
  239143950,
  239190792,
  188925444,
  20,
  41276,
  -146180,
  81,
  537805568,
  68046082,
  60,
  41300,
  -146108,
  194,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235572738,
  269369620,
  202260931,
  135152070,
  68043207,
  738757,
  16,
  41364,
  -364924,
  25,
  0,
  24,
  41384,
  -364912,
  52,
  806241024,
  68029036,
  2881,
  36,
  41412,
  -364876,
  84,
  537805568,
  1208125000,
  174916483,
  -1010433010,
  239799112,
  12830212,
  16,
  41452,
  -364820,
  6,
  0,
  16,
  41472,
  -364824,
  6,
  0,
  32,
  41492,
  -364828,
  131,
  537805568,
  1241744198,
  1124205190,
  -972812790,
  737987,
  44,
  41528,
  -364720,
  2311,
  135151872,
  222429829,
  -2092170747,
  -2029746683,
  179700227,
  1103512003,
  67912135,
  188990724,
  44,
  41576,
  -362448,
  165,
  806241024,
  1292076614,
  -2025454461,
  235567106,
  -1010383100,
  175442756,
  247973571,
  737540,
  40,
  41624,
  -362320,
  507,
  1074676480,
  1292142150,
  -2025454205,
  42289155,
  235570690,
  -959986428,
  739011,
  56,
  41668,
  -361852,
  110,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837629,
  537806085,
  336484098,
  -1022357949,
  -972288447,
  -955773375,
  -989589951,
  44,
  41072,
  -358657,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -619903368,
  486537862,
  -92300531,
  8959,
  44,
  41120,
  -358689,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  -1492318600,
  486537862,
  -92309235,
  8959,
  20,
  41824,
  -146424,
  31,
  537805568,
  265819,
  80,
  41848,
  -361808,
  208,
  135151872,
  239141509,
  1174636300,
  75894798,
  -2095837631,
  1074676997,
  336464500,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  -2097018046,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  1038,
  44,
  41932,
  -361684,
  781,
  135151872,
  222429829,
  92488965,
  59180166,
  -1022728702,
  -951990719,
  67374145,
  738245,
  60,
  41980,
  -360948,
  160,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837629,
  806241541,
  235569154,
  269369620,
  202260931,
  135152070,
  68043207,
  739269,
  44,
  42044,
  -360852,
  844,
  135151872,
  222560901,
  92498181,
  59180166,
  1103301216,
  1103577542,
  -989592564,
  2887,
  60,
  42092,
  -360052,
  1031,
  135151872,
  222429829,
  92490757,
  59180166,
  167920899,
  1103512003,
  67912135,
  188859652,
  167877635,
  1103512003,
  214254023,
  188810244,
  56,
  42156,
  -359044,
  177,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837629,
  806241541,
  336502530,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  16,
  42216,
  -358912,
  19,
  0,
  60,
  42236,
  -358900,
  1065,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  167959299,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  148,
  42300,
  -357892,
  1328,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  167982851,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  235557378,
  247677204,
  247873808,
  247939340,
  247808264,
  34293508,
  336464613,
  269402945,
  202294849,
  135186241,
  68076865,
  -2046686399,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  336483851,
  269402945,
  202294849,
  135186241,
  68076865,
  60,
  42452,
  -356716,
  1088,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  167933699,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  152,
  42516,
  -355692,
  1332,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  167982851,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  336464487,
  269402945,
  202294849,
  135186241,
  68076865,
  1057164098,
  336464385,
  269402945,
  202294849,
  135186241,
  68076865,
  173542209,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  336464470,
  269402945,
  202294849,
  135186241,
  68076865,
  2881,
  152,
  42672,
  -354504,
  1026,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -2146548987,
  39977729,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  173933067,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  235574274,
  247677204,
  247873808,
  247939340,
  247808264,
  34291972,
  336464475,
  269402945,
  202294849,
  135186241,
  68076865,
  173411137,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  156,
  42828,
  -353620,
  2380,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -2146548987,
  50529025,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  54067979,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  235561995,
  247677204,
  247873808,
  247939340,
  247808264,
  51069188,
  235536888,
  247677204,
  247873808,
  247939340,
  247808264,
  34291972,
  336464488,
  269402945,
  202294849,
  135186241,
  68076865,
  2881,
  176,
  42988,
  -351396,
  3431,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1341241851,
  53674753,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  235564299,
  247677204,
  247873808,
  247939340,
  247808264,
  51070212,
  235537149,
  247677204,
  247873808,
  247939340,
  247808264,
  51069188,
  235537134,
  247677204,
  247873808,
  247939340,
  247808264,
  34291972,
  336464544,
  269402945,
  202294849,
  135186241,
  68076865,
  173148993,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  136,
  43168,
  -348136,
  3814,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1878113531,
  58065665,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  53674763,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  34145035,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  64684811,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  108,
  43308,
  -344452,
  1655,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -2146548987,
  53740289,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  24314635,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  181338635,
  -1019145202,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  180,
  43420,
  -342900,
  2456,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -2146548987,
  52167425,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  55116555,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  235561483,
  247677204,
  247873808,
  247939340,
  247808264,
  51069188,
  235536820,
  247677204,
  247873808,
  247939340,
  247808264,
  34291972,
  336464479,
  269402945,
  202294849,
  135186241,
  68076865,
  1828850497,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  108,
  43604,
  -340620,
  1586,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  167961603,
  239277070,
  239190800,
  239191564,
  239191816,
  188859652,
  167899907,
  -1019145202,
  -968814578,
  -952038386,
  -985331698,
  188810254,
  235564034,
  247677204,
  247874320,
  247939340,
  247808264,
  737540,
  180,
  43716,
  -339132,
  2464,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -2146548987,
  52691713,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  55116555,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  235561483,
  247677204,
  247873808,
  247939340,
  247808264,
  51069188,
  235536820,
  247677204,
  247873808,
  247939340,
  247808264,
  34291972,
  336464479,
  269402945,
  202294849,
  135186241,
  68076865,
  1828850497,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  44,
  43244,
  -334962,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  1779238520,
  486537955,
  -85907187,
  8959,
  44,
  43292,
  -334994,
  16,
  34084352,
  373689208,
  91750920,
  235411012,
  906823288,
  486537955,
  -85904115,
  8959,
  40,
  43996,
  -336948,
  218,
  135151872,
  239403651,
  174588448,
  239142926,
  188859140,
  135161346,
  68076355,
  16,
  44040,
  -336768,
  25,
  0,
  108,
  44060,
  -336756,
  1012,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -2146548987,
  183501313,
  239277070,
  239190800,
  239191564,
  239191816,
  188859652,
  167890179,
  -1018883058,
  -968683506,
  -952038386,
  -985593842,
  188941326,
  336464504,
  269402947,
  202294849,
  135186241,
  68076865,
  2881,
  60,
  44172,
  -335844,
  610,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676997,
  235568130,
  269370132,
  202260931,
  135152070,
  68043207,
  738757,
  80,
  44236,
  -335252,
  244,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  235585538,
  269370900,
  202260931,
  135152070,
  68043207,
  1426802885,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  1038,
  40,
  44320,
  -335080,
  217,
  135151872,
  222429829,
  92488965,
  59180166,
  1103351042,
  1103577542,
  -989592564,
  28,
  44364,
  -148932,
  60,
  537805568,
  68029032,
  239799109,
  4,
  16,
  44396,
  -334932,
  6,
  0,
  52,
  44416,
  -334936,
  473,
  135151872,
  239141511,
  1174636044,
  75698190,
  26218051,
  167838211,
  239276046,
  239190796,
  239191560,
  188860164,
  44,
  44472,
  -334512,
  135,
  806241024,
  1258586950,
  -2025454714,
  235565570,
  -1010383100,
  174721860,
  247973571,
  738820,
  40,
  44520,
  -334416,
  916,
  1611547392,
  1225098058,
  -2059008890,
  59198978,
  235557634,
  -959986428,
  738243,
  20,
  44564,
  -333532,
  25,
  537805568,
  265813,
  20,
  44588,
  -149092,
  38,
  537805568,
  265826,
  28,
  44612,
  -149068,
  36,
  135151872,
  239272579,
  135158304,
  -1023144383,
  16,
  44644,
  -333580,
  25,
  0,
  44,
  44664,
  -333568,
  144,
  135151872,
  239272579,
  172360224,
  239142926,
  189121284,
  135137863,
  68076353,
  2888,
  20,
  44712,
  -333472,
  33,
  537805568,
  265821,
  68,
  44736,
  -333448,
  465,
  135151872,
  239141511,
  1090749964,
  75698190,
  36703811,
  269355759,
  -1022620093,
  -972550591,
  -956035519,
  173804358,
  -1019146226,
  -968815602,
  -952039410,
  188810254,
  28,
  44808,
  -333040,
  62,
  537805568,
  1292075847,
  241566342,
  12830212,
  48,
  44840,
  -149248,
  145,
  135151872,
  239141511,
  1124304396,
  75698190,
  36703811,
  1091571331,
  1103301646,
  1103497230,
  13042702,
  104,
  44892,
  -333060,
  457,
  135151872,
  239272581,
  1174636300,
  75894798,
  -2095837631,
  1074677765,
  235591938,
  269370132,
  202260931,
  135152070,
  68043207,
  34293445,
  336464531,
  269402945,
  202294851,
  135186241,
  68076865,
  241699655,
  247677204,
  247874832,
  247939340,
  247808264,
  4,
  76,
  45000,
  -332704,
  1405,
  135151872,
  222429829,
  92490757,
  59180166,
  -1022728958,
  -951990719,
  67374145,
  51069381,
  -1022754556,
  -951990717,
  67945793,
  51070724,
  -1022754493,
  -951990717,
  67945793,
  739332,
  24,
  45080,
  -149328,
  431,
  269371392,
  234988035,
  4,
  52,
  45108,
  -661552,
  108,
  135151872,
  239272581,
  1191413516,
  75894798,
  -2095837625,
  240321029,
  239387408,
  239191564,
  239191816,
  50436,
  44,
  45164,
  -331460,
  1126,
  135151872,
  222429829,
  75909381,
  1342538565,
  1912734599,
  -956035830,
  239190982,
  189056260,
  16,
  45212,
  -330372,
  66,
  0,
  60,
  45232,
  -330312,
  880,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837629,
  1074676997,
  167974403,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  44,
  45296,
  -329496,
  675,
  135151872,
  222429829,
  75908101,
  -2090531961,
  180421125,
  1103512003,
  67912135,
  188859652,
  32,
  45344,
  -328856,
  92,
  135151872,
  239403651,
  235567136,
  68043016,
  737731,
  16,
  45380,
  -328796,
  13,
  0,
  60,
  45400,
  -328800,
  2624,
  135151872,
  222429829,
  92490501,
  59180166,
  -1022731006,
  -951990719,
  67374145,
  51069637,
  -1022753449,
  -951990719,
  67945793,
  737540,
  52,
  45464,
  -149280,
  245,
  135151872,
  239141511,
  1090749964,
  75698190,
  35655235,
  269355719,
  -1022620095,
  -972550591,
  -956035519,
  2881,
  32,
  45520,
  -326296,
  100,
  135153152,
  175833731,
  1203962894,
  247683851,
  4,
  16,
  45556,
  -326220,
  17,
  0,
  20,
  45576,
  -326208,
  53,
  269370112,
  265809,
  20,
  45600,
  -326168,
  47,
  269370112,
  265809,
  20,
  45624,
  -326144,
  88,
  336478976,
  265851,
  20,
  45648,
  -326072,
  73,
  336478976,
  265837,
  16,
  45672,
  -326016,
  53,
  0,
  28,
  45692,
  -325972,
  63,
  135151872,
  239403651,
  135165216,
  -1023144381,
  40,
  45724,
  -325940,
  49,
  810496,
  34081024,
  -2097085431,
  2131104000,
  293472017,
  -1018462971,
  12961734,
  32,
  45768,
  -325920,
  100,
  135151872,
  176030339,
  1103299598,
  -1022730485,
  188810254,
  40,
  45804,
  -325828,
  300,
  -1274132992,
  75911170,
  1375896910,
  92472199,
  235584514,
  -959986428,
  739011,
  32,
  45848,
  -325568,
  56,
  135151872,
  174129795,
  1170408462,
  68046859,
  195,
  36,
  45884,
  -325540,
  160,
  -1878112768,
  42426369,
  75694982,
  235556354,
  -1010383100,
  2881,
  44,
  45924,
  -325420,
  61,
  135151872,
  239272582,
  1896055564,
  -1022882294,
  -972812735,
  -1019016382,
  -968816626,
  1038,
  108,
  45972,
  -325404,
  1057,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  336464511,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  1778584385,
  336464386,
  269402945,
  202294849,
  135186241,
  68076865,
  -637400249,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  64,
  46084,
  -324444,
  87,
  135151872,
  1091309121,
  -2025582578,
  59130882,
  168067918,
  1762922057,
  239144974,
  239190796,
  239191560,
  188860164,
  -1022620091,
  -972550591,
  -956035519,
  64,
  46152,
  -324416,
  87,
  135151872,
  1091309121,
  -2025582578,
  59130882,
  168067924,
  1662258761,
  239144974,
  239190796,
  239191560,
  188860164,
  -1022620091,
  -972550591,
  -956035519,
  60,
  46220,
  -324388,
  842,
  135151872,
  222429829,
  92489989,
  59180166,
  -1022703614,
  -951990719,
  67374145,
  34292165,
  1103301238,
  1103577542,
  67374277,
  2887,
  56,
  46284,
  -323604,
  57,
  135151872,
  1091309121,
  239144974,
  42419220,
  1208190532,
  -2058746493,
  269375236,
  202260931,
  135152069,
  68043206,
  199,
  60,
  46344,
  -323600,
  256,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235582466,
  269369620,
  202260931,
  135152070,
  68043207,
  737733,
  84,
  46408,
  -323408,
  1097,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  235574530,
  269369620,
  202260931,
  135152070,
  68043207,
  51071173,
  235536974,
  247677204,
  247873808,
  247939340,
  247808264,
  738820,
  60,
  46496,
  -322392,
  237,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235578370,
  269369620,
  202260931,
  135152070,
  68043207,
  737733,
  84,
  46560,
  -322216,
  889,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343111941,
  235571970,
  269369620,
  202260931,
  135152070,
  68043207,
  51069637,
  235536878,
  247677204,
  247873808,
  247939340,
  247808264,
  738820,
  52,
  46648,
  -321408,
  185,
  135151872,
  222429829,
  75715845,
  175899526,
  -1010433011,
  -989589951,
  173804355,
  68011715,
  68076865,
  2883,
  36,
  46704,
  -321272,
  144,
  135151872,
  1141640769,
  -2042363257,
  243532291,
  239191560,
  50948,
  52,
  46744,
  -321168,
  60,
  135151872,
  1091309121,
  239144974,
  -2046654700,
  -2096855805,
  269382661,
  202260931,
  135152069,
  68043206,
  199,
  40,
  46800,
  -321160,
  272,
  403587840,
  1443071816,
  92472454,
  33719676,
  68029020,
  -1010382907,
  2887,
  40,
  46844,
  -320932,
  287,
  604914432,
  1275233608,
  -2042100349,
  59199748,
  235571970,
  -959986428,
  738755,
  64,
  46888,
  -320688,
  1265,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -535935483,
  32441090,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  11,
  84,
  46956,
  -319476,
  484,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837626,
  806241029,
  167869187,
  239277070,
  239190800,
  239191564,
  239191816,
  188990724,
  336464479,
  269402947,
  202294849,
  135186241,
  68076865,
  2883,
  44,
  46388,
  -287185,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  118294136,
  486538142,
  -81241843,
  8959,
  44,
  46436,
  -287221,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -821229960,
  486538141,
  -81232371,
  8959,
  60,
  47140,
  -319164,
  31832,
  135151872,
  222429829,
  92492037,
  59180166,
  167951107,
  1103512003,
  67912135,
  189187332,
  168025859,
  1103512003,
  214254023,
  188810244,
  20,
  47204,
  -287388,
  43,
  537805568,
  265831,
  44,
  46572,
  -266684,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  470615672,
  486538222,
  -73458675,
  8959,
  44,
  46620,
  -266720,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -468908424,
  486538221,
  -73435635,
  8959,
  44,
  46668,
  -266756,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1408432520,
  486538221,
  -68376051,
  8959,
  44,
  46716,
  -266792,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  1947010680,
  486538221,
  -68364787,
  8959,
  48,
  47420,
  -287524,
  207,
  806241024,
  1275364936,
  92472199,
  1761772892,
  -989590006,
  1153681095,
  241828363,
  -959986428,
  195,
  44,
  47472,
  -663808,
  170,
  135151872,
  222429829,
  59196165,
  -2046459065,
  -1013513724,
  -951990719,
  67374145,
  197,
  44,
  47520,
  -663686,
  262,
  135151872,
  222429829,
  59196165,
  -2046459068,
  -1007156732,
  -951990719,
  67374145,
  197,
  76,
  47568,
  -287464,
  19934,
  135151872,
  222429829,
  92491525,
  59180166,
  167875587,
  1103512003,
  214254023,
  189203460,
  1103301202,
  1103577542,
  -989592564,
  1090652995,
  -968637686,
  -985544895,
  1107559436,
  11,
  44,
  47648,
  -267608,
  504,
  -1341241856,
  -2092367229,
  75910149,
  1224968009,
  -2046623099,
  68028929,
  -1010382907,
  2885,
  84,
  47696,
  -267096,
  1629,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  167889667,
  239277070,
  239190800,
  239191564,
  239191816,
  189318404,
  167840771,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  189137934,
  36,
  47784,
  -265552,
  343,
  -1878112768,
  75714049,
  1275299404,
  -972946809,
  -956035574,
  189187014,
  44,
  47168,
  -264631,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  554501752,
  486538230,
  -67891699,
  8959,
  44,
  47216,
  -264667,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -385022344,
  486538229,
  -67814643,
  8959,
  44,
  47264,
  -264703,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  -1324546440,
  486538229,
  -67795955,
  8959,
  64,
  38244,
  -265384,
  609,
  249062404,
  135151880,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  167888899,
  239277070,
  239190800,
  239191564,
  239191816,
  188859652,
  84,
  48036,
  -264796,
  372,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235584514,
  269369620,
  202260931,
  135152070,
  68043207,
  34292165,
  336464454,
  269402945,
  202294849,
  135186241,
  68076865,
  2881,
  20,
  48124,
  -264500,
  59,
  806241024,
  265847,
  16,
  48148,
  -264460,
  35,
  0,
  16,
  48168,
  -264432,
  3,
  0,
  16,
  48188,
  -264436,
  11,
  0,
  48,
  48208,
  -264440,
  174,
  135151872,
  239141511,
  1090749964,
  75698190,
  37752387,
  1125125794,
  1103301646,
  1103497230,
  13042702,
  32,
  48260,
  -264316,
  174,
  1074676480,
  1376027468,
  59114119,
  68062210,
  12830407,
  48,
  48296,
  -264176,
  174,
  135151872,
  239141511,
  1090749964,
  75698190,
  37752387,
  1125125794,
  1103301646,
  1103497230,
  13042702,
  44,
  48348,
  -264052,
  170,
  135151872,
  222429829,
  75910149,
  1845855046,
  1694630791,
  -960035827,
  68043203,
  197,
  40,
  48396,
  -263924,
  475,
  1343111936,
  1225033295,
  -2025192827,
  50692867,
  235536749,
  -959986428,
  737731,
  16,
  48440,
  -263488,
  42,
  0,
  44,
  47804,
  -263232,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  -1743976840,
  486538235,
  -67444467,
  8959,
  44,
  47852,
  -263268,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  1611466360,
  486538235,
  -67434739,
  8959,
  44,
  47900,
  -263307,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  621610616,
  486538235,
  -67437811,
  8959,
  48,
  38880,
  -263604,
  228,
  249066500,
  135151880,
  239141510,
  1124303628,
  -1576914930,
  1124863498,
  1103300622,
  1103496206,
  11,
  44,
  48000,
  -263002,
  12,
  34084352,
  373426040,
  91750920,
  235411012,
  2114782840,
  486538236,
  -67422451,
  8959,
  44,
  48048,
  -263038,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  1175258744,
  486538236,
  -67381747,
  8959,
  44,
  48096,
  -263077,
  9,
  34084352,
  373426040,
  91750920,
  235411012,
  185403000,
  486538236,
  -67378931,
  8959,
  48,
  39076,
  -263528,
  382,
  249070084,
  806241032,
  1359185480,
  75694727,
  235581186,
  -1010383100,
  175835973,
  247973571,
  738564,
  36,
  48852,
  -263164,
  92,
  537805568,
  1208255304,
  -2042232185,
  235559427,
  -1010383100,
  2885,
  44,
  48892,
  -263108,
  159,
  135151872,
  239141510,
  1124303628,
  2130849806,
  1091309066,
  1103300622,
  1120273422,
  11,
  40,
  48940,
  -262996,
  72,
  135151872,
  239141510,
  1124303628,
  1073881102,
  239143950,
  239190792,
  50692,
  108,
  48984,
  -262960,
  1594,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  235580674,
  269369620,
  202260931,
  135152070,
  68043207,
  51071173,
  235537082,
  247677716,
  247873808,
  247939340,
  247808264,
  34293764,
  336464457,
  269402947,
  202294849,
  135186241,
  68076865,
  2881,
  40,
  49096,
  -261472,
  140,
  537805568,
  1241679432,
  175047555,
  -1010433010,
  174394180,
  68077251,
  2883,
  40,
  49140,
  -261372,
  207,
  806241024,
  1275233608,
  92472454,
  2080606024,
  -989590006,
  1170458311,
  11,
  40,
  49184,
  -261208,
  189,
  806241024,
  1275233608,
  92472454,
  33785672,
  68029078,
  -1010382907,
  2883,
  36,
  49228,
  -261060,
  98,
  336478976,
  1208190797,
  -2041576827,
  2030404356,
  -943389682,
  50118,
  24,
  49268,
  -260988,
  52,
  135151872,
  242352771,
  49924,
  24,
  49296,
  -260952,
  52,
  135151872,
  242352771,
  49924,
  40,
  49324,
  -260916,
  393,
  -2146548992,
  92490497,
  -2029877924,
  1476691459,
  -989590006,
  1187235527,
  11,
  20,
  49368,
  -260560,
  53,
  537805568,
  265841,
  108,
  49392,
  -260520,
  498,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  -2146548987,
  18219777,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1120207886,
  235568907,
  247677716,
  247873808,
  247939340,
  247808264,
  1644905220,
  1175719434,
  1091571395,
  1091309254,
  1091047111,
  1157893829,
  11,
  20,
  49504,
  -260120,
  66,
  806241024,
  265854,
  16,
  49528,
  -260064,
  50,
  0,
  64,
  49548,
  -260020,
  1044,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1878112763,
  34865923,
  1125387786,
  1103302670,
  1103498254,
  1103562766,
  1153762318,
  11,
  16,
  49616,
  -259032,
  502,
  0,
  40,
  49636,
  -258540,
  100,
  135151872,
  1409417859,
  -1023144438,
  172165955,
  1157893827,
  247677707,
  4,
  32,
  49680,
  -258472,
  467,
  240189952,
  1761773320,
  1707541518,
  42403854,
  -956035516,
  16,
  49716,
  -258028,
  25,
  0,
  60,
  49736,
  -258016,
  778,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  604914437,
  167957251,
  239145998,
  239190800,
  239191564,
  239191816,
  189121796,
  36,
  49800,
  -257296,
  181,
  1074676480,
  1527087942,
  59179653,
  173606022,
  -943389682,
  188990406,
  80,
  49840,
  -257144,
  305,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837631,
  604914437,
  167839235,
  239145998,
  239190800,
  239191564,
  239191816,
  189121796,
  1091833428,
  1091571395,
  1091309254,
  1091047111,
  265925,
  84,
  49924,
  -256908,
  1305,
  135151872,
  239272581,
  1174636300,
  75894798,
  -2095837631,
  -804370939,
  59638529,
  1125387786,
  1103302670,
  1103498254,
  1103562766,
  1136985102,
  235554315,
  247678996,
  247873808,
  247939340,
  247808264,
  739076,
  20,
  50012,
  -255684,
  40,
  537805568,
  265828,
  44,
  49380,
  -255487,
  13,
  34084352,
  373491832,
  91750920,
  235411012,
  -636680584,
  486538265,
  -65450227,
  8959,
  44,
  49428,
  -255522,
  10,
  34084352,
  373491832,
  91750920,
  235411012,
  -1559427464,
  486538265,
  -65440755,
  8959,
  60,
  50132,
  -255756,
  173,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235573250,
  269370132,
  202260931,
  135152070,
  68043207,
  737733,
  44,
  49540,
  -255511,
  10,
  34084352,
  373491832,
  91750920,
  235411012,
  -1039333768,
  486538265,
  -65442035,
  8959,
  44,
  49588,
  -255549,
  10,
  34084352,
  373491832,
  91750920,
  235411012,
  -2012412296,
  486538265,
  -65443059,
  8959,
  32,
  50292,
  -255708,
  101,
  135151872,
  239403651,
  240976416,
  68043016,
  195,
  60,
  50328,
  -255616,
  138,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837629,
  1074676997,
  235563010,
  269370132,
  202260931,
  135152070,
  68043207,
  737733,
  32,
  50392,
  -255536,
  63,
  202261248,
  1224902214,
  173802371,
  -1010433010,
  2881,
  44,
  50428,
  -255508,
  146,
  135151872,
  239141510,
  1124303628,
  33652750,
  202246758,
  -1022882239,
  -972812735,
  2881,
  32,
  50476,
  -255396,
  49,
  135151872,
  173998723,
  1103299598,
  247680779,
  4,
  32,
  50512,
  -255368,
  45,
  135151872,
  173736579,
  1103299598,
  247680779,
  4,
  36,
  50548,
  -255356,
  107,
  269370112,
  -2046654638,
  33850115,
  68028992,
  1103349447,
  11,
  32,
  50588,
  -255284,
  74,
  202261248,
  -2096986541,
  235561731,
  1103349252,
  11,
  36,
  50624,
  -255240,
  173,
  537805568,
  -2096921004,
  42424324,
  68029032,
  1103349447,
  11,
  24,
  50664,
  -255104,
  49,
  269370112,
  68029023,
  2885,
  24,
  50692,
  -255068,
  37,
  135151872,
  240648835,
  49924,
  20,
  50720,
  -255048,
  35,
  1611547392,
  265820,
  44,
  50744,
  -255024,
  177,
  135151872,
  239469190,
  1124303628,
  -1811792882,
  1091309066,
  1103300622,
  1103496206,
  11,
  60,
  50792,
  -254880,
  389,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547909,
  235601154,
  269369620,
  202260931,
  135152070,
  68043207,
  737733,
  60,
  50856,
  -254544,
  444,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1611547397,
  167847939,
  239277070,
  239190800,
  239191564,
  239191816,
  188990724,
  16,
  50920,
  -254160,
  3,
  0,
  44,
  50940,
  -254164,
  1967,
  135151872,
  222429829,
  92491525,
  59180166,
  167936771,
  1103512003,
  67912135,
  189318404,
  60,
  50988,
  -252244,
  544,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  739132165,
  167885315,
  239145998,
  239190800,
  239191564,
  239191816,
  188990724,
  52,
  51052,
  -154612,
  114,
  135151872,
  239469190,
  1157858060,
  1359093774,
  1124863498,
  1103300622,
  1204159502,
  202261771,
  135185219,
  68077121,
  60,
  51108,
  -154540,
  271,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235586562,
  269369620,
  202260931,
  135152070,
  68043207,
  737733,
  28,
  51172,
  -251884,
  95,
  1074676480,
  68029042,
  241568579,
  4,
  16,
  51204,
  -251820,
  11,
  0,
  20,
  51224,
  -251824,
  59,
  537805568,
  265847,
  16,
  51248,
  -251784,
  5,
  0,
  28,
  51268,
  -251788,
  94,
  806241024,
  1627620168,
  242287238,
  12830212,
  40,
  51300,
  -251724,
  114,
  135151872,
  239141510,
  1124303628,
  1778532366,
  239143950,
  239190792,
  50692,
  32,
  51344,
  -251640,
  75,
  135151872,
  239272579,
  239403568,
  68043016,
  195,
  20,
  51380,
  -251596,
  59,
  537805568,
  265847,
  20,
  51404,
  -251556,
  37,
  537805568,
  265825,
  20,
  51428,
  -251532,
  81,
  806241024,
  68046082,
  44,
  51452,
  -251460,
  173,
  806241024,
  1174636104,
  -2025388925,
  235558658,
  -1010383100,
  1191316289,
  -943275254,
  188810254,
  40,
  51500,
  -251332,
  357,
  1611547392,
  1174701640,
  -2025388669,
  42290179,
  68029011,
  -1010382907,
  2881,
  40,
  51544,
  -251008,
  364,
  1611547392,
  1174636360,
  -2042165885,
  42290180,
  68029011,
  -1010382907,
  2881,
  28,
  51588,
  -250684,
  70,
  537805568,
  68029007,
  242027334,
  4,
  20,
  51620,
  -250636,
  33,
  537805568,
  265821,
  36,
  51644,
  -250612,
  144,
  135151872,
  1141640769,
  -2042363257,
  243532291,
  239191560,
  50948,
  56,
  51684,
  -250508,
  60,
  135151872,
  1091309121,
  239144974,
  42419220,
  1208190532,
  -2058746493,
  269376004,
  202260931,
  135152069,
  68043206,
  199,
  20,
  51744,
  -250504,
  55,
  806241024,
  265843,
  20,
  51768,
  -250464,
  55,
  806241024,
  265843,
  20,
  51792,
  -250424,
  55,
  806241024,
  265843,
  20,
  51816,
  -250384,
  55,
  806241024,
  265843,
  88,
  51840,
  -250344,
  1719,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -2146548987,
  36963073,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  17957643,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1090784965,
  11,
  20,
  51932,
  -248708,
  51,
  806241024,
  265839,
  84,
  51956,
  -248668,
  1747,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -2146548987,
  33030913,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1157893829,
  235562763,
  269369620,
  202260931,
  135152070,
  68043207,
  738757,
  20,
  52044,
  -246996,
  51,
  806241024,
  265839,
  20,
  52068,
  -246956,
  47,
  537805568,
  265835,
  20,
  52092,
  -246932,
  47,
  537805568,
  265835,
  20,
  52116,
  -246908,
  47,
  537805568,
  265835,
  20,
  52140,
  -246884,
  47,
  537805568,
  265835,
  20,
  52164,
  -246860,
  47,
  537805568,
  265835,
  20,
  52188,
  -246836,
  47,
  537805568,
  265835,
  52,
  52212,
  -246812,
  519,
  1074676480,
  1392740166,
  -2042100349,
  42289156,
  68029044,
  -1010382907,
  -1761473720,
  -989590006,
  1237567175,
  11,
  84,
  52268,
  -246340,
  863,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676997,
  235600642,
  269370132,
  202260931,
  135152070,
  68043207,
  51070661,
  235536773,
  247677204,
  247873808,
  247939340,
  247808264,
  739076,
  88,
  52356,
  -245564,
  9776,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1609677307,
  80216834,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1120207886,
  23134987,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1124339397,
  11,
  20,
  52448,
  -235880,
  43,
  537805568,
  265831,
  52,
  52472,
  -235856,
  659,
  1074676480,
  1392740166,
  -2042100349,
  42289156,
  68029040,
  -1010382907,
  -1476261052,
  -989590006,
  1220789959,
  11,
  84,
  52528,
  -235240,
  863,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676997,
  235600642,
  269370132,
  202260931,
  135152070,
  68043207,
  51070661,
  235536773,
  247677204,
  247873808,
  247939340,
  247808264,
  739076,
  88,
  52616,
  -234464,
  10009,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -2146548219,
  87294724,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  21365515,
  1091833354,
  1125125827,
  1091309254,
  1091047111,
  1090784965,
  11,
  20,
  52708,
  -224540,
  43,
  537805568,
  265831,
  52,
  52732,
  -224516,
  670,
  1074676480,
  1392870214,
  -2025323386,
  42289155,
  68029040,
  -1010382907,
  -1476261052,
  -989590006,
  1220789959,
  11,
  84,
  52788,
  -223900,
  863,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676997,
  235600642,
  269370132,
  202260931,
  135152070,
  68043207,
  51070661,
  235536776,
  247677204,
  247873808,
  247939340,
  247808264,
  738308,
  88,
  52876,
  -223124,
  9840,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1878112763,
  87294754,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1103430670,
  21234443,
  1091833354,
  1125125827,
  1091309254,
  1091047111,
  1090784965,
  11,
  20,
  52968,
  -213376,
  43,
  537805568,
  265831,
  24,
  52992,
  -213352,
  52,
  537806848,
  68029009,
  2881,
  72,
  53020,
  -213316,
  461,
  135151872,
  239469191,
  1090749964,
  75698190,
  37752387,
  269355646,
  -1022620095,
  -972550591,
  -956035519,
  -1912468668,
  1091571210,
  1091309251,
  1091047110,
  1191448263,
  11,
  36,
  53096,
  -212928,
  124,
  1074676480,
  1258586952,
  59114119,
  68029025,
  1103349447,
  11,
  28,
  53136,
  -212840,
  59,
  135151872,
  239272579,
  135165216,
  -1023144383,
  40,
  53168,
  -212808,
  309,
  806241024,
  1292076870,
  -2041707899,
  33915652,
  68029046,
  -1010382907,
  2886,
  20,
  53212,
  -669108,
  19,
  537805568,
  265807,
  20,
  53236,
  -212556,
  37,
  537805568,
  265825,
  20,
  53260,
  -212532,
  32,
  537805568,
  265820,
  40,
  53284,
  -212524,
  77,
  135151872,
  239272579,
  235564576,
  68043016,
  1393247683,
  -1019148274,
  1038,
  92,
  53328,
  -212488,
  231,
  135151872,
  239272579,
  172753440,
  239142926,
  189252356,
  135137867,
  68076353,
  172493636,
  -1019148274,
  189203470,
  135137862,
  -1023144381,
  172362567,
  239470606,
  189580036,
  135137880,
  68076353,
  173280071,
  -1019148274,
  188941326,
  20,
  53424,
  -212344,
  57,
  537805568,
  265843,
  44,
  53448,
  -212304,
  124,
  135151872,
  239141510,
  1124303628,
  1593978894,
  1091309066,
  1103300622,
  1103496206,
  11,
  20,
  53496,
  -212224,
  89,
  1074676480,
  68048130,
  36,
  53520,
  -212152,
  164,
  537805568,
  1527022408,
  59114119,
  68029016,
  1103349447,
  11,
  244,
  53560,
  -212016,
  179,
  135154432,
  1091309121,
  239144974,
  403587348,
  1092357697,
  239149070,
  672022820,
  1093406273,
  239153166,
  940458292,
  1094454849,
  239157262,
  1208893764,
  1095503425,
  239161358,
  1477329236,
  1096552001,
  239165454,
  1745764708,
  1097600577,
  239169550,
  2014200180,
  1098649153,
  1090617358,
  1090618382,
  1090619406,
  1090620430,
  1090621454,
  1090622478,
  1090623502,
  1090624526,
  1090625550,
  1090626574,
  1090627598,
  1090628622,
  1090629646,
  1090630670,
  1090631694,
  1090632718,
  1090633742,
  1090634766,
  1090635790,
  1090636814,
  1090637838,
  1090638862,
  1090639886,
  1090640910,
  1090641934,
  1090642958,
  1090643982,
  1107422222,
  1107423246,
  1107424270,
  1107425294,
  1107426318,
  1107460110,
  33719310,
  265819,
  16,
  53808,
  -212072,
  57,
  0,
  16,
  53828,
  -212028,
  37,
  0,
  16,
  53848,
  -212000,
  26,
  0,
  192,
  53868,
  -211988,
  11040,
  135157504,
  -771620219,
  59182094,
  -2045768127,
  336478724,
  622396170,
  239144974,
  239191564,
  1694680840,
  1153762318,
  42272782,
  -989589920,
  -2063069616,
  68051458,
  135155397,
  241304197,
  240043268,
  1644332296,
  1321534478,
  42272782,
  -989589918,
  -2063069618,
  68051458,
  135155397,
  241304197,
  240043268,
  33719560,
  -989589913,
  -2063069623,
  68045826,
  -989852095,
  239274819,
  202260752,
  135152070,
  68043207,
  135154373,
  239141509,
  50562572,
  135135930,
  68043206,
  135152837,
  202244741,
  239993734,
  239191560,
  50436,
  16,
  54064,
  -201144,
  26,
  0,
  84,
  54084,
  -201132,
  1379,
  135157504,
  239141509,
  50562828,
  269353569,
  34210950,
  -972288279,
  -955773375,
  -989589951,
  239143756,
  239322636,
  239191816,
  239846660,
  235046152,
  1241745164,
  1103562766,
  1170539534,
  42272782,
  59182094,
  20,
  54172,
  -199828,
  61,
  269370112,
  265849,
  56,
  54196,
  -199788,
  439,
  135151872,
  239141510,
  1174635276,
  50446350,
  235536710,
  135152396,
  68043203,
  34292166,
  1158418013,
  1091047107,
  265926,
  16,
  54256,
  -199400,
  6,
  0,
  60,
  54276,
  -199404,
  459,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676997,
  235581698,
  269370132,
  202260931,
  135152070,
  68043207,
  739525,
  44,
  54340,
  -199004,
  680,
  135151872,
  222429829,
  92489989,
  59180166,
  -1022699518,
  -951990719,
  67374145,
  737733,
  56,
  54388,
  -198364,
  268,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1074676485,
  336526338,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  44,
  54448,
  -198152,
  2405,
  135151872,
  222429829,
  92489989,
  59180166,
  168134403,
  1103512003,
  67912135,
  188859652,
  104,
  54496,
  -195784,
  298,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837629,
  806241541,
  235563522,
  269369620,
  202260931,
  135152070,
  68043207,
  1963673029,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1191448261,
  235555083,
  247678484,
  247873808,
  247939340,
  247808264,
  738820,
  44,
  54604,
  -195588,
  2985,
  135151872,
  222429829,
  92494853,
  59180166,
  1103301216,
  1103577542,
  -989592564,
  2881,
  44,
  54652,
  -192644,
  151,
  135151872,
  239272579,
  172491296,
  239142926,
  189121284,
  135137859,
  -1023144383,
  2881,
  20,
  54700,
  -192532,
  50,
  135152384,
  265838,
  20,
  54724,
  -192492,
  99,
  269370112,
  68050690,
  20,
  54748,
  -192404,
  77,
  336478976,
  68045058,
  44,
  54772,
  -192348,
  147,
  135151872,
  239141510,
  1124303628,
  1627533326,
  1091309066,
  1103300622,
  1103496206,
  11,
  20,
  54820,
  -192236,
  81,
  806241024,
  68046082,
  16,
  54844,
  -192164,
  5,
  0,
  20,
  54864,
  -192168,
  28,
  269370112,
  265814,
  28,
  54888,
  -192160,
  29,
  135151872,
  239272579,
  135157520,
  -1023144383,
  32,
  54920,
  -192160,
  100,
  135151872,
  239272579,
  240910896,
  68043528,
  195,
  28,
  54956,
  -192084,
  38,
  135151872,
  239272579,
  135159840,
  -1023144383,
  32,
  54988,
  -192068,
  108,
  135151872,
  239272579,
  241435200,
  68043528,
  195,
  40,
  55024,
  -191992,
  124,
  336478976,
  -2046459048,
  42290948,
  1241645959,
  -989590006,
  1153681095,
  11,
  24,
  55068,
  -191908,
  37,
  135151872,
  240648835,
  49924,
  44,
  55096,
  -191888,
  104,
  135151872,
  239272583,
  1090749964,
  75698190,
  202267906,
  135152835,
  68043206,
  199,
  36,
  55144,
  -191824,
  102,
  806241024,
  1359315789,
  59179653,
  1140982918,
  -943389682,
  50118,
  44,
  55184,
  -191752,
  3989,
  135151872,
  222429829,
  92492293,
  59180166,
  168296195,
  1103512003,
  67912135,
  188990724,
  40,
  55232,
  -187800,
  304,
  1074676480,
  1610974022,
  59179653,
  -1342045050,
  -989590006,
  1204012743,
  11,
  60,
  55276,
  -187540,
  258,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837629,
  1074676485,
  235561730,
  269369620,
  202260931,
  135152070,
  68043207,
  739525,
  44,
  55340,
  -187332,
  533,
  135151872,
  222429829,
  92494597,
  59180166,
  167845891,
  1103512003,
  67912135,
  188990724,
  44,
  55388,
  -186836,
  690,
  135151872,
  222429829,
  92493573,
  59180166,
  167871747,
  1103512003,
  67912135,
  189187332,
  48,
  55436,
  -186180,
  849,
  135151872,
  222429829,
  59196165,
  -2046459064,
  21562116,
  -968768758,
  205637441,
  1187316740,
  11,
  76,
  55488,
  -185368,
  1061,
  135151872,
  222429829,
  59196165,
  -2046459050,
  32768772,
  -968768758,
  205637441,
  1103430660,
  16777995,
  -968768758,
  -985544895,
  1090782220,
  -1022734837,
  -951990719,
  67945793,
  737540,
  56,
  55568,
  -184376,
  82,
  135151872,
  239272581,
  1124304652,
  75894798,
  -2095837629,
  537805573,
  1125387902,
  1103302670,
  1103498254,
  1103562766,
  12911630,
  28,
  55628,
  -184340,
  84,
  806241024,
  1459848008,
  242287238,
  12830212,
  44,
  55660,
  -184276,
  770,
  135151872,
  222429829,
  75908101,
  -2090597497,
  181666309,
  1103512003,
  67912135,
  189187332,
  32,
  55708,
  -183540,
  180,
  806241024,
  1174700870,
  -2024799354,
  244449794,
  -1010383100,
  20,
  55744,
  -183384,
  30,
  537805568,
  265818,
  36,
  55768,
  -183376,
  358,
  806241024,
  1409517384,
  75891333,
  235558402,
  -959986428,
  2883,
  36,
  55808,
  -183048,
  458,
  806241024,
  1208190800,
  -2057304954,
  173867522,
  -943389682,
  739526,
  48,
  55848,
  -182624,
  76,
  135151872,
  239272581,
  1124304652,
  75894798,
  2115243587,
  239144974,
  239191564,
  239191816,
  50436,
  40,
  55900,
  -182596,
  396,
  1074676480,
  1392870212,
  -2025454458,
  42289667,
  235575042,
  -959986428,
  739267,
  16,
  55944,
  -182240,
  124,
  0,
  44,
  55964,
  -182132,
  2171,
  135151872,
  222560901,
  92489989,
  59180166,
  -1022706942,
  -951990719,
  67374145,
  738501,
  64,
  56012,
  -180004,
  2779,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -804370939,
  72483586,
  1125387786,
  1103302670,
  1103498254,
  1103562766,
  1187316750,
  11,
  64,
  56080,
  -177288,
  975,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  -535935483,
  29754113,
  1091833354,
  1103302670,
  1103498254,
  1103562766,
  1204093966,
  11,
  44,
  56148,
  -176380,
  140,
  269370112,
  1359250243,
  -2042232185,
  173015555,
  -960035826,
  1393247171,
  -943275254,
  189072398,
  108,
  56196,
  -176284,
  1526,
  135151872,
  239141509,
  1124304652,
  75894798,
  -2095837629,
  1343113221,
  167888899,
  239145998,
  239190800,
  239191564,
  239191816,
  189056260,
  167877123,
  -1019014130,
  -968814578,
  -952038386,
  -985593842,
  188810254,
  235561986,
  247678484,
  247873808,
  247939340,
  247808264,
  737796,
  44,
  56308,
  -174860,
  485,
  -1878112768,
  92489474,
  1225033302,
  -2058484857,
  25821954,
  -989590006,
  1153681095,
  11,
  48,
  56356,
  -174412,
  225,
  135151872,
  239272581,
  1090750220,
  75894798,
  41946696,
  269405698,
  -972288445,
  -955773375,
  -989589951,
  60,
  56408,
  -174224,
  170,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837629,
  -2146548219,
  177340930,
  239145998,
  239190800,
  239191564,
  239191816,
  188859652,
  80,
  56472,
  -174112,
  292,
  135151872,
  239272581,
  1090750220,
  75894798,
  -2095837629,
  1074676485,
  235576578,
  269369620,
  202260931,
  135152070,
  68043207,
  34292933,
  1091833455,
  1091571395,
  1091309254,
  1091047111,
  265925,
  36,
  56556,
  -173892,
  102,
  269370112,
  1409516364,
  175178374,
  -1010433010,
  -1018361020,
  265926,
  16,
  56596,
  -173820,
  8,
  0,
  36,
  56616,
  -173824,
  110,
  269370112,
  1392739148,
  175833734,
  -1010433010,
  -1018361021,
  265926,
  16,
  56656,
  -173752,
  8,
  0,
  16,
  56676,
  -173756,
  20,
  0,
  16,
  56696,
  -173744,
  12,
  0,
  16,
  56716,
  -173748,
  8,
  0,
  16,
  56736,
  -173752,
  8,
  0,
  32,
  56756,
  -173756,
  60,
  135151872,
  239272579,
  235564336,
  68043016,
  739011,
  16,
  56792,
  -173728,
  8,
  0,
  16,
  56812,
  -173732,
  8,
  0,
  68,
  56832,
  -173736,
  215,
  135151872,
  239272581,
  1174636300,
  75894798,
  47189574,
  235582210,
  202261264,
  135152070,
  68043207,
  1175142853,
  -968552434,
  -952038386,
  -985593842,
  1038,
  16,
  56904,
  -173584,
  1,
  0,
  68,
  56924,
  -173588,
  357,
  135151872,
  222429829,
  125848325,
  92472962,
  59180166,
  -989152766,
  -956038132,
  189318086,
  -960296369,
  67374279,
  34292165,
  -959986302,
  213959363,
  1025,
  60,
  56996,
  -173292,
  190,
  135151872,
  222429829,
  125849349,
  1275494991,
  75891591,
  2131067724,
  -956035830,
  239190982,
  188859652,
  -943374078,
  -1060977722,
  262412,
  44,
  57060,
  -173164,
  195,
  135151872,
  222429829,
  125846789,
  92472962,
  59180166,
  -943343614,
  -1060977722,
  262412,
  60,
  57108,
  -173004,
  220,
  135151872,
  222429829,
  125848581,
  -2046459066,
  59201540,
  173213314,
  -960035827,
  68043203,
  34293701,
  -959986287,
  213959363,
  1025,
  20,
  57172,
  -172844,
  31,
  537805568,
  265819,
  36,
  57196,
  -172836,
  129,
  135151872,
  222429829,
  75911429,
  1778516871,
  1103577542,
  -989592564,
  16,
  57236,
  -172747,
  4,
  0,
  48,
  57256,
  -172752,
  183,
  135151872,
  239141509,
  1090750220,
  75894798,
  36703811,
  1091571373,
  1103498254,
  1103562766,
  12911630,
  48,
  57308,
  -172612,
  152,
  135151872,
  239141509,
  1090750220,
  75894798,
  36703811,
  1091571342,
  1103498254,
  1103562766,
  12911630,
  60,
  57360,
  -172504,
  103,
  135151872,
  239272579,
  235565840,
  68044296,
  1124811715,
  1174933002,
  1191448259,
  235553547,
  247678472,
  1124812548,
  -1019017202,
  1038,
  40,
  57424,
  -172456,
  437,
  806241024,
  1594196804,
  59179653,
  -1660812154,
  -989590006,
  1170458311,
  11,
  104,
  57468,
  -172052,
  306,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837629,
  1074679301,
  336464493,
  -1022357951,
  -972288447,
  -955773375,
  -989589951,
  -1375597757,
  1091833354,
  1091571395,
  1091309254,
  1091047111,
  1174671045,
  235553547,
  247677716,
  247873808,
  247939340,
  247808264,
  737540,
  28,
  57576,
  -171840,
  53,
  470696704,
  -2046654626,
  68047619,
  50887,
  52,
  57608,
  -171808,
  98,
  135151872,
  239272579,
  235565840,
  68043528,
  1158366915,
  1091046922,
  1107562179,
  235555083,
  247677192,
  738820,
  48,
  57664,
  -171752,
  347,
  135151872,
  239272581,
  1090750220,
  75894798,
  55578181,
  269353293,
  -972288447,
  -955773375,
  -989589951,
  48,
  57716,
  -171452,
  311,
  135151872,
  239272581,
  1090750220,
  75894798,
  55578179,
  269353259,
  -972288447,
  -955773375,
  -989589951,
  32,
  57768,
  -171184,
  156,
  806241024,
  1275364936,
  42271623,
  68060162,
  13027269,
  68,
  57804,
  -171060,
  347,
  135151872,
  239141509,
  1090750220,
  75894798,
  55578181,
  235536702,
  202261264,
  135152070,
  68043207,
  1124812229,
  -968552434,
  -952038386,
  -985593842,
  1038,
  52,
  57876,
  -170780,
  98,
  135151872,
  239272579,
  235565840,
  68043528,
  1158366915,
  1091046922,
  1107562179,
  235555083,
  247677192,
  738820,
  108,
  57932,
  -170724,
  1718,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  168000771,
  239277070,
  239190800,
  239191564,
  239191816,
  189187332,
  235595266,
  247677716,
  247874320,
  247939340,
  247808264,
  51069444,
  235536841,
  247677204,
  247874832,
  247939340,
  247808264,
  737540,
  48,
  58044,
  -169108,
  167,
  135151872,
  239141509,
  1090750220,
  75894798,
  37752387,
  1091571357,
  1103498254,
  1103562766,
  12911630,
  84,
  58096,
  -168984,
  1376,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  -1878113531,
  36766465,
  1125387786,
  1103302670,
  1103498254,
  1103562766,
  1120207886,
  235557643,
  247677716,
  247874320,
  247939340,
  247808264,
  738564,
  36,
  58184,
  -167696,
  160,
  537805568,
  1392804680,
  -2025323642,
  174588418,
  -960035826,
  737731,
  20,
  58224,
  -167576,
  43,
  537805568,
  265831,
  28,
  58248,
  -167552,
  68,
  537805568,
  1141016136,
  242484099,
  12830212,
  36,
  58280,
  -167504,
  154,
  537805568,
  1141081676,
  -2023160701,
  172753410,
  -960035826,
  737731,
  20,
  58320,
  -167384,
  43,
  537805568,
  265831,
  28,
  58344,
  -167360,
  48,
  135151872,
  239993475,
  135159584,
  -1023144383,
  84,
  58376,
  -167344,
  247,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  806241029,
  235582210,
  269370132,
  202260931,
  135152070,
  68043207,
  1124812997,
  1125387786,
  1125125827,
  1091309254,
  1091047111,
  1157893829,
  11,
  16,
  58464,
  -167176,
  5,
  0,
  28,
  58484,
  -167180,
  46,
  135151872,
  239272579,
  135161888,
  -1023144383,
  60,
  58516,
  -167164,
  464,
  135151872,
  239141509,
  1090750220,
  75894798,
  -2095837631,
  1343114757,
  235589378,
  269370132,
  202260931,
  135152070,
  68043207,
  737733,
  40,
  58580,
  -166764,
  437,
  806241024,
  1594196804,
  59179653,
  -1660812154,
  -989590006,
  1170458311,
  11,
  40,
  58624,
  -166360,
  1168,
  1879982848,
  1493533508,
  -2058746746,
  1426294530,
  -989590006,
  1103349447,
  11,
  16,
  58668,
  -165236,
  23,
  0,
  56,
  58688,
  -165224,
  257,
  135151872,
  239469189,
  1090750220,
  75894798,
  -2095837631,
  1879982853,
  336522754,
  -1022357949,
  -972288447,
  -955773375,
  -989589951,
  36,
  58748,
  -165012,
  163,
  1611547392,
  1208320845,
  -2058615674,
  33785602,
  -989589890,
  12830407
}; // weak
int (*_init_array_start[2])() = { &init_cacheinfo, &fini }; // weak
int (*_fini_array_start)() = &fini; // weak
int _CTOR_LIST__ = -1; // weak
int _DTOR_LIST__[] = { -1 }; // weak
int _DTOR_END__ = 0; // weak
int _JCR_LIST__ = 0; // weak
int dl_random = 0; // weak
int _libc_stack_end = 0; // weak
int _libc_enable_secure = 1; // weak
int _stack_prot = 16777216; // weak
int ncapstr = 0; // weak
int max_capstrlen = 0; // weak
int capstr = 0; // weak
int rtld_search_dirs = 0; // weak
int dword_80EEFE0 = 0; // weak
int env_path_list = 0; // weak
int dword_80EEFE8 = 0; // weak
int (*off_80EF040)() = &strchr; // weak
int _dso_handle = 0; // weak
int dl_tls_static_size = 2048; // weak
void *_exit_funcs = &initial; // weak
int _libc_malloc_initialized = -1; // weak
int (__cdecl *_memalign_hook)(_DWORD, _DWORD, _DWORD) = &memalign_hook_ini; // weak
int (__cdecl *_realloc_hook)(int, int) = &realloc_hook_ini; // weak
int (__cdecl *_malloc_hook)(_DWORD, _DWORD) = &malloc_hook_ini; // weak
int (__cdecl *_morecore)(_DWORD) = &_default_morecore; // weak
int main_arena = 0; // weak
int dword_80EF0A4 = 0; // weak
int dword_80EF0A8[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_80EF0D0 = 0; // weak
int dword_80EF0D4 = 0; // weak
int dword_80EF0D8 = 0; // weak
int dword_80EF4D0[] = { 0 }; // weak
int dword_80EF4D4 = 0; // weak
int dword_80EF4D8 = 0; // weak
int dword_80EF4DC = 0; // weak
int *off_80EF4E0 = &main_arena; // weak
int dword_80EF4E8 = 0; // weak
int dword_80EF4EC = 0; // weak
int mp_ = 131072; // weak
int dword_80EF504 = 131072; // weak
int dword_80EF508 = 131072; // weak
int dword_80EF50C = 2; // weak
int dword_80EF510 = 0; // weak
int dword_80EF514 = 0; // weak
int dword_80EF518 = 65536; // weak
int dword_80EF51C = 0; // weak
int dword_80EF520 = 0; // weak
int dword_80EF524 = 0; // weak
int dword_80EF528 = 0; // weak
int dword_80EF52C = 0; // weak
int dword_80EF530 = 0; // weak
int check_action = 3; // weak
int narenas = 1; // weak
int _x86_raw_shared_cache_size = 1048576; // weak
int _x86_raw_shared_cache_size_half = 524288; // weak
int _x86_shared_cache_size = 1048576; // weak
int _x86_shared_cache_size_half = 524288; // weak
int _x86_raw_data_cache_size = 32768; // weak
int _x86_raw_data_cache_size_half = 16384; // weak
int _x86_data_cache_size = 32768; // weak
int _x86_data_cache_size_half = 16384; // weak
int LogMask = 255; // weak
int LogFacility = 8; // weak
int LogType = 2; // weak
int LogFile = -1; // weak
void *program_invocation_short_name = &unk_80C86D9; // weak
void *program_invocation_name = &unk_80C86D9; // weak
int dl_load_lock = 0; // weak
int dword_80EF590 = 0; // weak
int dword_80EF594 = 0; // weak
int dword_80EF598 = 1; // weak
int dword_80EF59C = 0; // weak
int dword_80EF5A0 = 0; // weak
__int64 (__fastcall *dl_sysinfo)(_DWORD) = &dl_sysinfo_int80; // weak
int (*dl_make_stack_executable_hook)(void) = &dl_make_stack_executable; // weak
int dl_stack_flags = 7; // weak
int dl_correct_cache_id = 3; // weak
int dl_debug_fd = 2; // weak
int dl_pagesize = 4096; // weak
int (__cdecl *dl_init_static_tls)(_DWORD) = &dl_nothread_init_static_tls; // weak
int dl_use_load_bias = -2; // weak
int _libc_multiple_libcs = 1; // weak
char *nl_current_default_domain[2] = { "messages", "/usr/share/locale" }; // weak
char *locale_alias_path_8071 = "/usr/share/locale"; // weak
__int16 _fpu_control = 895; // weak
int pa_next_type = 8; // weak
void *IO_list_all = &IO_2_1_stderr_; // weak
int stderr = 135198208; // idb
void *stdout = &IO_2_1_stdout_; // weak
void *stdin = &IO_2_1_stdin_; // weak
char *tzname = "GMT"; // idb
char *off_80EFA2C = "GMT"; // weak
int (*dl_error_catch_tsd)(void) = &dl_initial_error_catch_tsd; // weak
char *builtin_modules[2] = { "INTERNAL", "ISO-10646/UCS4/" }; // weak
char *nl_global_locale = &nl_C_LC_CTYPE; // idb
char (*off_80EFBF4)[512] = &byte_80D0CC0; // weak
int off_80EFBF8 = 135069120; // weak
char *s1 = &dword_80D03C0; // idb
char *s2 = "C"; // idb
int (__cdecl *dl_open_hook[2])(int, int) = { &_libc_dlopen_mode, &_libc_dlsym }; // weak
int (__cdecl *dlfcn_hooks)(int, int, int) = &_dlopen; // weak
__int64 adds_8108 = -1LL; // weak
char completed_5679; // weak
int dtor_idx_5681; // weak
_DWORD object_5691[6]; // weak
int static_dtv; // weak
_UNKNOWN unk_80EFCA8; // weak
int dword_80EFCB0; // weak
char byte_80EFCB4; // weak
int dword_80F00E0; // weak
int static_slotinfo; // weak
int lock; // weak
int (__fastcall *_after_morecore_hook)(_DWORD); // weak
int (__cdecl *_free_hook)(_DWORD, _DWORD); // weak
int (*_malloc_initialize_hook)(void); // weak
int disallow_malloc_check; // weak
int using_malloc_checking; // weak
int global_max_fast; // weak
int perturb_byte; // weak
int arena_mem; // weak
int aligned_heap_area; // weak
_DWORD atfork_mem; // weak
int dword_80F0570; // weak
int dword_80F0574; // weak
int dword_80F0578; // weak
int dword_80F057C; // weak
int dword_80F0580; // weak
int save_arena; // weak
int save_malloc_hook; // weak
int save_free_hook; // weak
int free_list; // weak
int list_lock; // weak
int atfork_recursive_cntr; // weak
int narenas_limit_9720; // weak
int next_to_use_9704; // weak
char **environ; // idb
int LogTag; // weak
int LogStat; // weak
int syslog_lock; // weak
int connected; // weak
__int16 SyslogAddr; // weak
char dest[110]; // idb
int timestamp_9146; // weak
int cached_result_9145; // weak
int _fork_lock; // weak
int fork_handler_pool; // weak
int dl_hwcap_mask; // weak
int dword_80F0BCC; // weak
int dl_hwcap; // weak
int dword_80F0BD4; // weak
int result_8500; // weak
int dword_80F0BDC; // weak
_UNKNOWN buf_8501; // weak
int root; // weak
int lock_8842; // weak
int freemem_8854; // weak
int freemem_size_8855; // weak
int transmem_list; // weak
int output_charset_cached_8903; // weak
int output_charset_cache_8902; // weak
int nl_loaded_domains; // weak
int lock_8574; // weak
int dword_80F0C88; // weak
int dword_80F0C8C; // weak
int lock_0; // weak
int nmap; // weak
int maxmap; // weak
int string_space_act; // weak
int string_space_max; // weak
int _abort_msg; // weak
int lock_1; // weak
int dword_80F0CAC; // weak
int dword_80F0CB0; // weak
int stage; // weak
int pagesize_6803; // weak
int phys_pages_6802; // weak
int envlock; // weak
int last_environ; // weak
int known_values; // weak
int lock_2; // weak
int next_bit; // weak
int lock_3; // weak
int lock_4; // weak
int list_all_lock; // weak
int dword_80F0CE0; // weak
int dword_80F0CE4; // weak
int run_fp; // weak
int IO_list_all_stamp; // weak
char dealloc_buffers; // weak
int freeres_list; // weak
_UNKNOWN state; // weak
_UNKNOWN state_0; // weak
_UNKNOWN state_1; // weak
int timezone; // weak
int daylight; // weak
int tzstring_list; // weak
int tzset_lock; // weak
int is_initialized_7800; // weak
char *old_tz; // idb
int tz_rules; // weak
char algn_80F0D64[4]; // weak
__int16 word_80F0D68[]; // weak
__int16 word_80F0D6A[]; // weak
__int16 word_80F0D6C[]; // weak
_UNKNOWN unk_80F0D70; // weak
int dword_80F0D74[]; // weak
int dword_80F0D78; // weak
int dword_80F0D80; // weak
int dword_80F0D94; // weak
int dword_80F0D98; // weak
__int64 tzfile_ino; // weak
__int64 tzfile_dev; // weak
int tzfile_mtime; // weak
int num_transitions; // weak
int num_types; // weak
int num_leaps; // weak
int type_idxs; // weak
int types; // weak
char *zone_names; // idb
int leaps; // weak
int tzspec; // weak
int rule_dstoff; // weak
int rule_stdoff; // weak
int _curbrk; // weak
int max_dirnamelen; // weak
int cache; // weak
int cachesize; // weak
int cache_new; // weak
int (__cdecl *receiver)(_DWORD, _DWORD, _DWORD); // weak
int once_0; // weak
int known_derivations; // weak
int lock_10442; // weak
int modcounter_10422; // weak
int lock_5; // weak
int search_tree; // weak
int gconv_cache; // weak
int cache_size; // weak
int cache_malloced; // weak
int loaded; // weak
int release_handle; // weak
int archloaded; // weak
int archmapped; // weak
int headmap; // weak
int dword_80F0E50; // weak
int dword_80F0E54; // weak
__int64 archive_stat; // weak
__int64 qword_80F0E8C; // weak
int dword_80F0EA8; // weak
__int64 qword_80F0EB8; // weak
_UNKNOWN internal; // weak
_UNKNOWN state_2; // weak
_UNKNOWN state_3; // weak
int localtime_offset; // weak
int fromidx; // weak
int running; // weak
int lowpc; // weak
int textsize; // weak
int log_hashfraction; // weak
int fromlimit; // weak
int narcsp; // weak
int data; // weak
int tos; // weak
int froms; // weak
int narcs; // weak
int once; // weak
_UNKNOWN last_result; // weak
int static_buf; // weak
int samples; // weak
_UNKNOWN otimer_7293; // weak
int oact_7292[11]; // weak
char byte_80F0F8C[32]; // weak
char byte_80F0FAC[64]; // weak
int nsamples; // weak
int pc_offset; // weak
int pc_scale; // weak
int dl_close_state_9537; // weak
char dwarf_reg_size_table[]; // weak
char byte_80F0FFD; // weak
char byte_80F0FFE; // weak
char byte_80F0FFF; // weak
char byte_80F1000; // weak
char byte_80F1001; // weak
char byte_80F1002; // weak
char byte_80F1003; // weak
char byte_80F1004; // weak
char byte_80F1005; // weak
char byte_80F1007; // weak
char byte_80F1008; // weak
char byte_80F1009; // weak
char byte_80F100A; // weak
char byte_80F100B; // weak
char byte_80F100C; // weak
int unseen_objects; // weak
int seen_objects; // weak
__int64 subs_8109; // weak
int frame_hdr_cache_head; // weak
_UNKNOWN frame_hdr_cache; // weak
int dword_80F111C; // weak
_UNKNOWN terminator_7952; // weak
_UNKNOWN marker_7846; // weak
int exec_string; // weak
int dl_tls_static_used; // weak
int dl_tls_static_align; // weak
int dl_tls_max_dtv_idx; // weak
int dl_tls_dtv_slotinfo_list; // weak
char dl_tls_dtv_gaps; // weak
int dl_tls_generation; // weak
int dl_tls_static_nelem; // weak
__int64 _new_exitfn_called; // weak
int _have_sock_cloexec; // weak
int dl_profile_output; // weak
int dl_initial_searchlist; // weak
int dword_80F1188; // weak
int dl_platformlen; // weak
int dl_debug_mask; // weak
__int64 dl_load_adds; // weak
int (*dl_wait_lookup_done)(void); // weak
int dl_profile; // weak
__int64 dl_cpuclock_offset; // weak
int dl_bind_not; // weak
char *dl_platform; // idb
int dl_lazy; // weak
int dl_phdr; // weak
int dl_nns; // weak
int dl_scope_free_list; // weak
int dl_origin_path; // weak
int dl_clktck; // weak
int dl_dynamic_weak; // weak
int dl_sysinfo_dso; // weak
int dl_init_all_dirs; // weak
int dl_verbose; // weak
int dl_phnum; // weak
int dl_profile_map; // weak
int dl_initfirst; // weak
int dl_all_dirs; // weak
int dl_osversion; // weak
int dl_inhibit_rpath; // weak
int dl_ns[]; // weak
int dword_80F1204[]; // weak
int dword_80F1208[]; // weak
int dword_80F120C[]; // weak
_UNKNOWN unk_80F1228; // weak
_UNKNOWN unk_80F122C; // weak
int _libc_enable_secure_decided; // weak
int _libc_argc; // weak
int _libc_argv; // weak
int _cpu_features; // weak
int dword_80F1264; // weak
int dword_80F1268; // weak
int dword_80F126C; // weak
int dword_80F1270; // weak
int dword_80F1274; // weak
int dword_80F1278; // weak
int dword_80F127C; // weak
int dword_80F1280; // weak
int dword_80F1284; // weak
int dword_80F1288; // weak
int dword_80F128C; // weak
int dword_80F1290; // weak
int nl_domain_bindings; // weak
int nl_msg_cat_cntr; // weak
int _printf_function_table; // weak
int _printf_modifier_table; // weak
int tmbuf[11]; // weak
int _tzname_cur_max; // weak
int _use_tzfile; // weak
int _fork_generation_pointer; // weak
int _fork_handlers; // weak
_UNKNOWN r_debug; // weak
int dword_80F130C; // weak
int _gconv_modules_db; // weak
int _gconv_lock; // weak
int _gconv_alias_db; // weak
int _gconv_path_envvar; // weak
int _gconv_max_path_elem_len; // weak
int _gconv_path_elem; // weak
int nl_locale_file_list[13]; // weak
int map; // weak
int string_space; // weak
int _printf_arginfo_table; // weak
int _printf_va_arg_table; // weak
int transitions; // weak
int buf; // weak


//----- (080481C0) --------------------------------------------------------
void (*init_proc())(void)
{
  frame_dummy();
  return _do_global_ctors_aux();
}

//----- (08048300) --------------------------------------------------------
char *__userpurge group_number@<eax>(char *a1@<eax>, int a2@<edx>, char *a3@<ecx>, const char *a4)
{
  char v6; // al
  int v7; // edi
  void *v8; // esp
  _WORD *v9; // eax
  unsigned int v10; // edx
  char *v11; // ecx
  int v12; // esi
  int v13; // ebx
  unsigned int v15; // [esp+10h] [ebp-28h] BYREF
  unsigned int v16; // [esp+14h] [ebp-24h]
  _BYTE *v17; // [esp+18h] [ebp-20h]
  const char *v18; // [esp+1Ch] [ebp-1Ch]

  v18 = (const char *)a2;
  v6 = *a3;
  v16 = strlen(a4);
  if ( (unsigned __int8)(v6 - 1) <= 0x7Du )
  {
    v7 = v6;
    v17 = a3 + 1;
    v8 = alloca(v18 - a1 + 15);
    v15 = (unsigned int)&v15;
    v9 = mempcpy(&v15, a1, v18 - a1);
    a1 = (char *)v18;
    v10 = v15;
    v18 = a4;
    while ( (unsigned int)v9 > v10 )
    {
      v9 = (_WORD *)((char *)v9 - 1);
      --v7;
      v11 = a1 - 1;
      *(a1 - 1) = *(_BYTE *)v9;
      if ( !v7 && (unsigned int)v9 > v10 )
      {
        v12 = v16;
        v13 = (int)v18;
        do
        {
          --v12;
          *--v11 = *(_BYTE *)(v13 + v12);
        }
        while ( v12 > 0 );
        v18 = (const char *)v13;
        LOBYTE(v7) = *v17;
        if ( *v17 >= 0x7Fu )
        {
          a1 = v11;
          do
          {
            v9 = (_WORD *)((char *)v9 - 1);
            *--a1 = *(_BYTE *)v9;
          }
          while ( (unsigned int)v9 > v10 );
          return a1;
        }
        if ( (_BYTE)v7 )
        {
          v7 = (char)v7;
          ++v17;
        }
        else
        {
          v7 = (char)*(v17 - 1);
        }
      }
      a1 = v11;
    }
  }
  return a1;
}

//----- (080483D7) --------------------------------------------------------
_BYTE *__usercall i18n_number_rewrite@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v5; // edx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  unsigned int v9; // esi
  bool v10; // al
  void *v11; // esp
  char *v12; // eax
  char *v13; // esi
  char v14; // al
  const char *v15; // edx
  unsigned int v16; // ecx
  const char *v17; // edx
  unsigned int v18; // ecx
  int v20; // [esp+10h] [ebp-68h] BYREF
  int v21; // [esp+14h] [ebp-64h]
  _BYTE *v22; // [esp+18h] [ebp-60h]
  bool v23; // [esp+1Fh] [ebp-59h]
  _DWORD *v24; // [esp+20h] [ebp-58h]
  int *v25; // [esp+24h] [ebp-54h]
  int *v26; // [esp+28h] [ebp-50h]
  int *v27; // [esp+2Ch] [ebp-4Ch]
  int v28[4]; // [esp+36h] [ebp-42h] BYREF
  int v29[4]; // [esp+47h] [ebp-31h] BYREF
  char v30[32]; // [esp+58h] [ebp-20h] BYREF

  v22 = (_BYTE *)a3;
  v24 = (_DWORD *)wctrans("to_outpunct");
  v25 = (int *)towctrans(0x2Eu, v24);
  v5 = towctrans(0x2Cu, v24);
  if ( v24 )
  {
    v27 = (int *)v30;
    memset(v30, 0, 8u);
    v21 = v5;
    v6 = wcrtomb(v28, (int)v25, v30);
    v7 = v21;
    if ( v6 == -1 )
      LOWORD(v28[0]) = 46;
    else
      *((_BYTE *)v28 + v6) = 0;
    memset(v27, 0, 8u);
    v8 = wcrtomb(v29, v7, v30);
    if ( v8 == -1 )
      LOWORD(v29[0]) = 44;
    else
      *((_BYTE *)v29 + v8) = 0;
  }
  v9 = a2 - (_DWORD)a1;
  v10 = 1;
  if ( v9 > 0x1000 )
    v10 = _libc_alloca_cutoff(v9);
  v23 = v10;
  if ( v10 )
  {
    v11 = alloca(v9 + 15);
    v25 = &v20;
  }
  else
  {
    v25 = (int *)malloc(v9);
    if ( !v25 )
      return a1;
  }
  v12 = (char *)mempcpy(v25, a1, v9);
  a1 = v22;
  v13 = v12;
  v27 = v28;
  v26 = v29;
  while ( --v13 >= (char *)v25 )
  {
    v14 = *v13;
    if ( (unsigned __int8)(*v13 - 48) > 9u )
    {
      if ( v24 && (v14 == 44 || v14 == 46) )
      {
        v17 = (const char *)v27;
        if ( v14 != 46 )
          v17 = (const char *)v26;
        v18 = strlen(v17);
        a1 -= v18;
        while ( v18 )
        {
          --v18;
          a1[v18] = v17[v18];
        }
      }
      else
      {
        *--a1 = v14;
      }
    }
    else
    {
      v15 = *(const char **)(*(_DWORD *)__readgsdword(0xFFFFFFDC) + 4 * v14 + 8);
      v16 = strlen(v15);
      a1 -= v16;
      while ( v16 )
      {
        --v16;
        a1[v16] = v15[v16];
      }
    }
  }
  if ( !v23 )
    free(v25);
  return a1;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (080485A0) --------------------------------------------------------
_BYTE *__usercall i18n_number_rewrite_0@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v5; // edx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  unsigned int v9; // esi
  bool v10; // al
  void *v11; // esp
  char *v12; // eax
  char *v13; // esi
  char v14; // al
  const char *v15; // edx
  unsigned int v16; // ecx
  const char *v17; // edx
  unsigned int v18; // ecx
  int v20; // [esp+10h] [ebp-68h] BYREF
  int v21; // [esp+14h] [ebp-64h]
  _BYTE *v22; // [esp+18h] [ebp-60h]
  bool v23; // [esp+1Fh] [ebp-59h]
  _DWORD *v24; // [esp+20h] [ebp-58h]
  int *v25; // [esp+24h] [ebp-54h]
  int *v26; // [esp+28h] [ebp-50h]
  int *v27; // [esp+2Ch] [ebp-4Ch]
  int v28[4]; // [esp+36h] [ebp-42h] BYREF
  int v29[4]; // [esp+47h] [ebp-31h] BYREF
  char v30[32]; // [esp+58h] [ebp-20h] BYREF

  v22 = (_BYTE *)a3;
  v24 = (_DWORD *)wctrans("to_outpunct");
  v25 = (int *)towctrans(0x2Eu, v24);
  v5 = towctrans(0x2Cu, v24);
  if ( v24 )
  {
    v27 = (int *)v30;
    memset(v30, 0, 8u);
    v21 = v5;
    v6 = wcrtomb(v28, (int)v25, v30);
    v7 = v21;
    if ( v6 == -1 )
      LOWORD(v28[0]) = 46;
    else
      *((_BYTE *)v28 + v6) = 0;
    memset(v27, 0, 8u);
    v8 = wcrtomb(v29, v7, v30);
    if ( v8 == -1 )
      LOWORD(v29[0]) = 44;
    else
      *((_BYTE *)v29 + v8) = 0;
  }
  v9 = a2 - (_DWORD)a1;
  v10 = 1;
  if ( v9 > 0x1000 )
    v10 = _libc_alloca_cutoff(v9);
  v23 = v10;
  if ( v10 )
  {
    v11 = alloca(v9 + 15);
    v25 = &v20;
  }
  else
  {
    v25 = (int *)malloc(v9);
    if ( !v25 )
      return a1;
  }
  v12 = (char *)mempcpy(v25, a1, v9);
  a1 = v22;
  v13 = v12;
  v27 = v28;
  v26 = v29;
  while ( --v13 >= (char *)v25 )
  {
    v14 = *v13;
    if ( (unsigned __int8)(*v13 - 48) > 9u )
    {
      if ( v24 && (v14 == 44 || v14 == 46) )
      {
        v17 = (const char *)v27;
        if ( v14 != 46 )
          v17 = (const char *)v26;
        v18 = strlen(v17);
        a1 -= v18;
        while ( v18 )
        {
          --v18;
          a1[v18] = v17[v18];
        }
      }
      else
      {
        *--a1 = v14;
      }
    }
    else
    {
      v15 = *(const char **)(*(_DWORD *)__readgsdword(0xFFFFFFDC) + 4 * v14 + 8);
      v16 = strlen(v15);
      a1 -= v16;
      while ( v16 )
      {
        --v16;
        a1[v16] = v15[v16];
      }
    }
  }
  if ( !v23 )
    free(v25);
  return a1;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08048769) --------------------------------------------------------
int __usercall is_trusted_path_normalize@<eax>(char *a1@<eax>, int a2@<edx>)
{
  int result; // eax
  void *v4; // esp
  _BYTE *v5; // esi
  char v6; // dl
  char v7; // bl
  char v8; // al
  int v9; // ebx
  const char *v10; // edx
  size_t v11; // esi
  int v12; // eax
  _BYTE v13[8]; // [esp+10h] [ebp-28h] BYREF
  const char *v14; // [esp+18h] [ebp-20h]
  unsigned int v15; // [esp+1Ch] [ebp-1Ch]

  result = 0;
  if ( !a2 )
    return result;
  if ( *a1 == 58 )
  {
    ++a1;
    --a2;
  }
  v4 = alloca(a2 + 17);
  v5 = v13;
  while ( 1 )
  {
    v8 = *a1;
    if ( !*a1 )
      break;
    if ( v8 != 47 )
      goto LABEL_18;
    if ( a1[1] != 46 )
      goto LABEL_16;
    v6 = a1[2];
    if ( v6 == 46 && ((v7 = a1[3]) == 0 || v7 == 47) )
    {
      do
      {
        if ( v5 <= v13 )
          break;
        --v5;
      }
      while ( *v5 != 47 );
      a1 += 3;
    }
    else if ( v6 && v6 != 47 )
    {
LABEL_16:
      if ( v5 <= v13 || *(v5 - 1) != 47 )
LABEL_18:
        *v5++ = v8;
      ++a1;
    }
    else
    {
      a1 += 2;
    }
  }
  if ( v5 == v13 || *(v5 - 1) != 47 )
    *v5++ = 47;
  v9 = 0;
  v10 = "/lib32/";
  v15 = v5 - v13;
  while ( 1 )
  {
    v11 = system_dirs_len[v9];
    if ( v15 >= v11 )
    {
      v14 = v10;
      v12 = memcmp(v10, v13, v11);
      v10 = v14;
      if ( !v12 )
        break;
    }
    ++v9;
    v10 += v11 + 1;
    if ( v9 == 4 )
      return 0;
  }
  return 1;
}
// 80CCD40: using guessed type size_t system_dirs_len[8];

//----- (0804883F) --------------------------------------------------------
__int64 __usercall print_search_path@<edx:eax>(_DWORD *a1@<eax>, const char *a2@<edx>, const char *a3@<ecx>)
{
  void *v4; // esp
  int v5; // ecx
  unsigned int v6; // esi
  _BYTE *v7; // eax
  _WORD *v8; // eax
  _DWORD *v9; // edx
  int v10; // ebx
  int v11; // eax
  _BYTE *v12; // eax
  char *v13; // eax
  int v14; // edx
  char *v15; // eax
  int v16; // eax
  unsigned int v18; // [esp+8h] [ebp-40h]
  unsigned int v19; // [esp+8h] [ebp-40h]
  char v20; // [esp+10h] [ebp-38h] BYREF
  _BYTE v21[3]; // [esp+11h] [ebp-37h] BYREF
  _DWORD *v22; // [esp+1Ch] [ebp-2Ch]
  const char *v23; // [esp+20h] [ebp-28h]
  const char *v24; // [esp+24h] [ebp-24h]
  char *v25; // [esp+28h] [ebp-20h]
  _BYTE *v26; // [esp+2Ch] [ebp-1Ch]

  v24 = a2;
  v23 = a3;
  v4 = alloca(max_dirnamelen + max_capstrlen + 15);
  dl_debug_printf((int)" search path=");
  v5 = 1;
  v25 = v21;
  while ( 1 )
  {
    v16 = *a1;
    if ( !*a1 || *(const char **)(v16 + 4) != v24 )
      break;
    v6 = 0;
    v18 = *(_DWORD *)(v16 + 16);
    v7 = *(_BYTE **)(v16 + 12);
    v22 = (_DWORD *)v5;
    v8 = mempcpy(&v20, v7, v18);
    v9 = a1;
    v10 = (int)v22;
    v26 = v8;
    while ( v6 < ncapstr )
    {
      if ( *(_DWORD *)(*v9 + 4 * v6 + 20) != 1 )
      {
        v11 = capstr + 8 * v6;
        v19 = *(_DWORD *)(v11 + 4);
        v12 = *(_BYTE **)v11;
        v22 = v9;
        v13 = (char *)mempcpy(v26, v12, v19);
        v14 = (int)v22;
        if ( &v20 == v13 || v13 == v25 && v20 == 47 )
          *v13 = 0;
        else
          *(v13 - 1) = 0;
        v15 = "%s";
        if ( !v10 )
          v15 = ":%s";
        v10 = 0;
        v22 = (_DWORD *)v14;
        dl_debug_printf_c((int)v15, &v20);
        v9 = v22;
      }
      ++v6;
    }
    v5 = v10;
    a1 = v9 + 1;
  }
  if ( !v23 )
    return dl_debug_printf_c((int)"\t\t(%s)\n", v24);
  if ( !*v23 )
    v23 = (const char *)program_invocation_short_name;
  return dl_debug_printf_c((int)"\t\t(%s from file %s)\n", v24, v23);
}
// 80EEFD0: using guessed type int ncapstr;
// 80EEFD4: using guessed type int max_capstrlen;
// 80EEFD8: using guessed type int capstr;
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80F0DE0: using guessed type int max_dirnamelen;

//----- (0804898C) --------------------------------------------------------
_BYTE *__usercall strip@<eax>(_BYTE *result@<eax>, char *a2@<edx>)
{
  int v2; // ebp
  char v3; // cl
  int v4; // ebp

  v2 = 0;
  while ( 1 )
  {
    v3 = *a2;
    if ( !*a2 )
      break;
    if ( (byte_80D0CC0[2 * v3] & 8) != 0 || v3 == 95 || v3 == 45 || v3 == 46 || v3 == 44 || v3 == 58 )
    {
      *result++ = dword_80D03C0[v3];
    }
    else if ( v3 == 47 )
    {
      if ( ++v2 == 3 )
        break;
      *result++ = 47;
    }
    ++a2;
  }
  v4 = v2 - (_DWORD)result;
  while ( (int)&result[v4] <= 1 )
    *result++ = 47;
  *result = 0;
  return result;
}
// 80D03C0: using guessed type _DWORD dword_80D03C0[256];
// 80D0CC0: using guessed type _BYTE byte_80D0CC0[512];

//----- (080489F8) --------------------------------------------------------
_BYTE *__userpurge group_number_0@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>, _BYTE *a3@<ecx>, int a4)
{
  int v5; // ebx
  void *v6; // esp
  _WORD *v7; // edx
  _BYTE *v8; // ecx
  _BYTE v9[12]; // [esp+10h] [ebp-28h] BYREF
  _BYTE *v10; // [esp+1Ch] [ebp-1Ch]

  LOBYTE(v5) = *a3;
  if ( (unsigned __int8)(*a3 - 1) <= 0x7Du )
  {
    v5 = (char)v5;
    v10 = a3 + 1;
    v6 = alloca(((a2 - result) & 0xFFFFFFFC) + 15);
    v7 = mempcpy(v9, result, (a2 - result) & 0xFFFFFFFC);
    result = a2;
    while ( v7 > (_WORD *)v9 )
    {
      v7 -= 2;
      --v5;
      v8 = result - 4;
      *((_DWORD *)result - 1) = *(_DWORD *)v7;
      if ( !v5 && v7 > (_WORD *)v9 )
      {
        v8 = result - 8;
        *((_DWORD *)result - 2) = a4;
        LOBYTE(v5) = *v10;
        if ( (char)*v10 < 0 || (_BYTE)v5 == 127 )
        {
          result -= 8;
          do
          {
            v7 -= 2;
            result -= 4;
            *(_DWORD *)result = *(_DWORD *)v7;
          }
          while ( v7 > (_WORD *)v9 );
          return result;
        }
        if ( (_BYTE)v5 )
        {
          v5 = (char)v5;
          ++v10;
        }
        else
        {
          v5 = (char)*(v10 - 1);
        }
      }
      result = v8;
    }
  }
  return result;
}

//----- (08048AA2) --------------------------------------------------------
_BYTE *__usercall i18n_number_rewrite_1@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>)
{
  _BYTE *v4; // ebx
  unsigned int v5; // edi
  bool v6; // al
  void *v7; // esp
  int *v8; // esi
  int *v9; // eax
  int *v10; // eax
  _DWORD *v11; // edi
  unsigned int *i; // edx
  unsigned int v13; // ecx
  bool v14; // zf
  int v16; // [esp+10h] [ebp-38h] BYREF
  unsigned int v17; // [esp+1Ch] [ebp-2Ch]
  unsigned int v18; // [esp+20h] [ebp-28h]
  int v19; // [esp+24h] [ebp-24h]
  bool v20; // [esp+2Bh] [ebp-1Dh]
  _DWORD *v21; // [esp+2Ch] [ebp-1Ch]

  v4 = a1;
  v19 = a3;
  v5 = (a2 - (_DWORD)a1) & 0xFFFFFFFC;
  v21 = (_DWORD *)wctrans("to_outpunct");
  v18 = towctrans(0x2Eu, v21);
  v17 = towctrans(0x2Cu, v21);
  v6 = 1;
  if ( v5 > 0x1000 )
    v6 = _libc_alloca_cutoff(v5);
  v20 = v6;
  if ( v6 )
  {
    v7 = alloca(v5 + 15);
    v8 = &v16;
  }
  else
  {
    malloc(a4, v5);
    v8 = v9;
    if ( !v9 )
      return v4;
  }
  v10 = (int *)mempcpy(v8, v4, v5);
  v11 = (_DWORD *)__readgsdword(0xFFFFFFDC);
  for ( i = (unsigned int *)(v19 - 4); ; --i )
  {
    --v10;
    v4 = i + 1;
    if ( v10 < v8 )
      break;
    v13 = *v10;
    if ( (unsigned int)(*v10 - 48) > 9 )
    {
      if ( v21 && (v13 == 44 || v13 == 46) )
      {
        v14 = v13 == 46;
        v13 = v18;
        if ( !v14 )
          v13 = v17;
      }
      *i = v13;
    }
    else
    {
      *i = *(_DWORD *)(*v11 + 4 * v13 + 48);
    }
  }
  if ( !v20 )
    free(v8);
  return v4;
}
// 8048B2E: variable 'v9' is possibly undefined
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08048BB0) --------------------------------------------------------
void __usercall fini(long double a1@<st0>)
{
  check_free(a1, (int)&last_result);
}

//----- (08048BD0) --------------------------------------------------------
unsigned int init_cacheinfo()
{
  unsigned int result; // eax
  int v1; // edi
  int v2; // esi
  int v3; // ebp
  int v8; // ebp
  int v13; // ecx
  unsigned int v14; // ecx
  unsigned int v15; // ecx
  int v16; // eax
  signed int v17; // edi
  int v18; // eax
  signed int v19; // esi
  int v20; // ebp
  unsigned int v29; // ebx
  int v35; // [esp+4h] [ebp-28h]
  int v36; // [esp+4h] [ebp-28h]
  int v37; // [esp+4h] [ebp-28h]

  result = _cpu_features;
  if ( !_cpu_features )
  {
    _init_cpu_features();
    result = _cpu_features;
  }
  if ( result == 1 )
  {
    LOBYTE(result) = -68;
    v1 = handle_intel(result, dword_80F1264);
    v35 = 3;
    v2 = handle_intel(194, dword_80F1264);
    if ( v2 <= 0 )
    {
      v35 = 2;
      v2 = handle_intel(191, dword_80F1264);
    }
    result = dword_80F1264;
    if ( dword_80F1264 > 3 )
    {
      v3 = 0;
      while ( 1 )
      {
        _EAX = 4;
        ++v3;
        __asm { cpuid }
        if ( (result & 0x1F) == 0 )
          break;
        if ( (unsigned __int8)result >> 5 == v35 )
        {
          result = (result >> 14) & 0x3FF;
          v36 = result;
          if ( result && dword_80F1264 > 10 )
          {
            v8 = 0;
            while ( 1 )
            {
              _EAX = 11;
              ++v8;
              __asm { cpuid }
              v13 = _ECX & 0xFF0;
              if ( !v13 || !(_BYTE)_EBX )
                break;
              if ( v13 == 512 )
              {
                _BitScanReverse(&v14, v36);
                v36 = ((unsigned __int8)_EBX - 1) & ~(-1 << (v14 + 1));
                break;
              }
            }
          }
          v15 = v36 + 1;
          goto LABEL_20;
        }
      }
    }
    v15 = BYTE2(dword_80F126C);
LABEL_20:
    if ( v15 && v2 > 0 )
    {
      result = v2 / v15;
      v2 /= v15;
    }
  }
  else
  {
    if ( result != 2 )
      return result;
    LOBYTE(result) = -68;
    v1 = handle_amd(result);
    v37 = handle_amd(191);
    v2 = v37;
    v20 = handle_amd(194);
    _EAX = 0x80000000;
    __asm { cpuid }
    if ( v20 > 0 )
    {
      if ( result > 0x80000007 )
      {
        _EAX = -2147483640;
        __asm { cpuid }
        v29 = 1 << ((unsigned __int16)_ECX >> 12);
        if ( v29 )
          goto LABEL_34;
      }
      _EAX = 1;
      __asm { cpuid }
      if ( (_EDX & 0x10000000) != 0 )
      {
        v29 = BYTE2(_EBX);
        if ( v29 )
        {
LABEL_34:
          result = v20 / v29;
          v20 /= v29;
        }
      }
      v2 = v20 + v37;
    }
  }
  if ( v1 > 0 )
  {
    v16 = v1 >> 1;
    _x86_raw_data_cache_size = v1;
    v17 = v1 & 0xFFFFFF00;
    _x86_raw_data_cache_size_half = v16;
    result = v17 >> 1;
    _x86_data_cache_size_half = v17 >> 1;
    _x86_data_cache_size = v17;
  }
  if ( v2 > 0 )
  {
    v18 = v2 >> 1;
    _x86_raw_shared_cache_size = v2;
    v19 = v2 & 0xFFFFFF00;
    _x86_raw_shared_cache_size_half = v18;
    result = v19 >> 1;
    _x86_shared_cache_size = v19;
    _x86_shared_cache_size_half = v19 >> 1;
  }
  return result;
}
// 80EF53C: using guessed type int _x86_raw_shared_cache_size;
// 80EF540: using guessed type int _x86_raw_shared_cache_size_half;
// 80EF544: using guessed type int _x86_shared_cache_size;
// 80EF548: using guessed type int _x86_shared_cache_size_half;
// 80EF54C: using guessed type int _x86_raw_data_cache_size;
// 80EF550: using guessed type int _x86_raw_data_cache_size_half;
// 80EF554: using guessed type int _x86_data_cache_size;
// 80EF558: using guessed type int _x86_data_cache_size_half;
// 80F1260: using guessed type int _cpu_features;
// 80F1264: using guessed type int dword_80F1264;
// 80F126C: using guessed type int dword_80F126C;

//----- (08048DF8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  _libc_start_main((int (__cdecl *)(int, char **, char **))main, v2, &retaddr, _libc_csu_init, _libc_csu_fini, a2, &v3);
  __halt();
}
// 8048DFB: positive sp value 4 has been found

//----- (08048E20) --------------------------------------------------------
void _do_global_dtors_aux()
{
  int v0; // eax
  unsigned int i; // ebx

  if ( !completed_5679 )
  {
    v0 = dtor_idx_5681;
    for ( i = &_DTOR_END__ - _DTOR_LIST__ - 1; dtor_idx_5681 < i; v0 = dtor_idx_5681 )
    {
      dtor_idx_5681 = v0 + 1;
      ((void (*)(void))_DTOR_LIST__[v0 + 1])();
    }
    if ( _deregister_frame_info )
      _deregister_frame_info(&_EH_FRAME_BEGIN__);
    completed_5679 = 1;
  }
}
// 80C48E0: using guessed type int __cdecl _deregister_frame_info(_DWORD);
// 80EEFB0: using guessed type int _DTOR_LIST__[];
// 80EEFB4: using guessed type int _DTOR_END__;
// 80EFC80: using guessed type char completed_5679;
// 80EFC84: using guessed type int dtor_idx_5681;

//----- (08048E90) --------------------------------------------------------
int frame_dummy()
{
  int result; // eax

  if ( _register_frame_info )
    _register_frame_info(_EH_FRAME_BEGIN__, object_5691);
  result = _JCR_LIST__;
  if ( _JCR_LIST__ )
    return 0;
  return result;
}
// 80DF184: using guessed type _DWORD _EH_FRAME_BEGIN__[14696];
// 80EEFB8: using guessed type int _JCR_LIST__;
// 80EFC88: using guessed type _DWORD object_5691[6];

//----- (08048ED0) --------------------------------------------------------
int __usercall exec_the_string@<eax>(long double a1@<st0>)
{
  int v2; // [esp+Ch] [ebp-Ch]

  return execlp(a1, (char *)&exec_string, (int)&exec_string, 0, v2);
}
// 8048EED: variable 'v2' is possibly undefined
// 80F112C: using guessed type int exec_string;

//----- (08048EF4) --------------------------------------------------------
int __cdecl call_me_with_cafebabe(int a1)
{
  int result; // eax

  if ( a1 == -889275714 )
  {
    result = unk_80C5EC8;
    exec_string = unk_80C5EC8;
  }
  return result;
}
// 80F112C: using guessed type int exec_string;

//----- (08048F0E) --------------------------------------------------------
int __cdecl call_me_with_two_args(int a1, int a2)
{
  int result; // eax

  if ( a2 == -889275714 && a1 == -559038737 )
  {
    strcpy((char *)&exec_string, "/bin");
    return (unsigned __int8)aBin[4];
  }
  return result;
}
// 80F112C: using guessed type int exec_string;

//----- (08048F3B) --------------------------------------------------------
int vulnerable_function()
{
  char v1[136]; // [esp+10h] [ebp-88h] BYREF
  int savedregs; // [esp+98h] [ebp+0h] BYREF

  return read((int)&savedregs, 0, (int)v1);
}
// 8048F3B: using guessed type char var_88[136];

//----- (08048F64) --------------------------------------------------------
unsigned int __fastcall be_nice_to_people(int a1)
{
  int v2; // [esp+8h] [ebp-20h]

  v2 = getegid(a1);
  return setresgid(v2, v2);
}

//----- (08048F8D) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // ecx

  LOBYTE(exec_string) = 0;
  be_nice_to_people(v3);
  return vulnerable_function();
}
// 8048F9A: variable 'v3' is possibly undefined
// 80F112C: using guessed type int exec_string;

//----- (08048FB0) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __cdecl _libc_start_main(
        int (__cdecl *main)(int, char **, char **),
        int argc,
        char **ubp_av,
        void (*init)(void),
        void (*fini)(void),
        void (*rtld_fini)(void),
        void *stack_end)
{
  char **v7; // eax
  int v9; // ecx
  int v10; // eax

  _libc_multiple_libcs = 0;
  v7 = &ubp_av[argc + 1];
  environ = v7;
  _libc_stack_end = (int)stack_end;
  while ( *v7++ )
    ;
  dl_aux_init((int)v7);
  if ( !_libc_multiple_libcs )
  {
    v10 = dl_discover_osversion(v9);
    if ( v10 < 0 )
      _libc_fatal("FATAL: cannot determine kernel version\n");
    if ( !dl_osversion || dl_osversion > (unsigned int)v10 )
      dl_osversion = v10;
    if ( v10 <= 132631 )
      _libc_fatal("FATAL: kernel too old\n");
  }
  _libc_csu_irel();
  _pthread_initialize_minimal();
}
// 8048FF7: write access to const memory at 80EEFC0 has been detected
// 8049018: variable 'v9' is possibly undefined
// 80EEFBC: using guessed type int dl_random;
// 80EEFC0: using guessed type int _libc_stack_end;
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EF5C4: using guessed type int _libc_multiple_libcs;
// 80F11F0: using guessed type int dl_osversion;

//----- (08049200) --------------------------------------------------------
int __usercall check_one_fd@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ebp>)
{
  int result; // eax
  int v6; // edi
  const char *v7; // eax
  char v8[16]; // [esp+10h] [ebp-7Ch] BYREF
  int v9; // [esp+20h] [ebp-6Ch]
  int v10; // [esp+30h] [ebp-5Ch]
  int v11; // [esp+34h] [ebp-58h]

  result = fcntl(a3, a1, 1);
  if ( result == -1 )
  {
    result = -24;
    if ( __readgsdword(0xFFFFFFE8) == 9 )
    {
      if ( (a2 & 3) == 1 )
      {
        v6 = 263;
        v7 = "/dev/full";
      }
      else
      {
        v6 = 259;
        v7 = "/dev/null";
      }
      if ( a1 != _open_nocancel((int)v7, a2)
        || _fxstat64(3, a1, (int)v8)
        || (result = v9 & 0xF000, result != 0x2000)
        || v11
        || v10 != v6 )
      {
        __halt();
      }
    }
  }
  return result;
}
// 8049200: using guessed type char var_7C[16];

//----- (080492F0) --------------------------------------------------------
int __usercall _libc_check_standard_fds@<eax>(int a1@<ebp>)
{
  check_one_fd(0, 131073, a1);
  check_one_fd(1, 0x20000, a1);
  return check_one_fd(2, 0x20000, a1);
}

//----- (08049320) --------------------------------------------------------
void __cdecl __noreturn _libc_setup_tls(int a1, unsigned int a2)
{
  _DWORD *v2; // eax
  unsigned int v3; // edx
  unsigned int v4; // ebp
  unsigned int v5; // esi
  unsigned int v6; // edi
  int v7; // eax
  int v8; // ebx
  unsigned int v9; // eax
  _BYTE *v10; // edx
  __int64 (__fastcall *v11)(_DWORD); // eax
  _DWORD *v12; // ebx
  unsigned int v13; // [esp+10h] [ebp-3Ch]
  unsigned int v14; // [esp+14h] [ebp-38h]
  _BYTE *v15; // [esp+18h] [ebp-34h]

  v2 = (_DWORD *)dl_phdr;
  if ( dl_phdr && (v3 = dl_phdr + 32 * dl_phnum, v3 > dl_phdr) )
  {
    while ( *v2 != 7 )
    {
      v2 += 8;
      if ( v3 <= (unsigned int)v2 )
        goto LABEL_9;
    }
    v4 = a2;
    v5 = v2[7];
    v6 = v2[5];
    v14 = v2[4];
    if ( a2 < v5 )
      v4 = v2[7];
    v15 = (_BYTE *)v2[2];
  }
  else
  {
LABEL_9:
    v4 = a2;
    v5 = 0;
    v15 = 0;
    v6 = 0;
    v14 = 0;
  }
  v13 = (v6 + a2 + dl_tls_static_size - 1) / a2 * a2;
  v7 = sbrk(v13 + v4 + a1);
  static_dtv = 62;
  v8 = -v4 & (v7 + v4 - 1);
  if ( v5 )
  {
    v9 = v5 * ((v6 + v5 - 1) / v5);
    v10 = (_BYTE *)(v8 + v13 - v9);
  }
  else
  {
    v9 = v6;
    v10 = (_BYTE *)(v8 + v13 - v6);
  }
  dword_80EFCB0 = (int)v10;
  dword_80F00E0 = v9;
  byte_80EFCB4 = 1;
  memcpy(v10, v15, v14);
  v11 = dl_sysinfo;
  v12 = (_DWORD *)(v13 + v8);
  v12[1] = &unk_80EFCA8;
  *v12 = v12;
  v12[2] = v12;
  v12[4] = v11;
  __asm { int     80h; LINUX - sys_set_thread_area }
  _libc_fatal("set_thread_area failed when setting up thread-local storage\n");
}
// 80EF068: using guessed type int dl_tls_static_size;
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EFCA0: using guessed type int static_dtv;
// 80EFCB0: using guessed type int dword_80EFCB0;
// 80EFCB4: using guessed type char byte_80EFCB4;
// 80F00CC: using guessed type int dword_80F00CC;
// 80F00D0: using guessed type int dword_80F00D0;
// 80F00D4: using guessed type int dword_80F00D4;
// 80F00D8: using guessed type int dword_80F00D8;
// 80F00E0: using guessed type int dword_80F00E0;
// 80F00E4: using guessed type int dword_80F00E4;
// 80F0100: using guessed type int static_slotinfo;
// 80F0114: using guessed type int dword_80F0114;
// 80F1140: using guessed type int dl_tls_static_used;
// 80F1144: using guessed type int dl_tls_static_align;
// 80F1148: using guessed type int dl_tls_max_dtv_idx;
// 80F114C: using guessed type int dl_tls_dtv_slotinfo_list;
// 80F1158: using guessed type int dl_tls_static_nelem;
// 80F11BC: using guessed type int dl_phdr;
// 80F11E0: using guessed type int dl_phnum;

//----- (08049540) --------------------------------------------------------
int dl_tls_setup()
{
  int result; // eax

  static_slotinfo = 64;
  dl_tls_max_dtv_idx = 1;
  dl_tls_dtv_slotinfo_list = (int)&static_slotinfo;
  dl_tls_static_size = ((dl_tls_static_size + 1279) & 0xFFFFFFC0) + 1216;
  result = 0;
  dl_tls_static_used = 1216;
  dl_tls_static_align = 64;
  dl_tls_static_nelem = 1;
  return result;
}
// 80EF068: using guessed type int dl_tls_static_size;
// 80F0100: using guessed type int static_slotinfo;
// 80F1140: using guessed type int dl_tls_static_used;
// 80F1144: using guessed type int dl_tls_static_align;
// 80F1148: using guessed type int dl_tls_max_dtv_idx;
// 80F114C: using guessed type int dl_tls_dtv_slotinfo_list;
// 80F1158: using guessed type int dl_tls_static_nelem;

//----- (080495A0) --------------------------------------------------------
void __noreturn _pthread_initialize_minimal()
{
  _libc_setup_tls(1216, 0x40u);
}

//----- (080495C0) --------------------------------------------------------
void _libc_csu_irel()
{
  int v0; // edi
  int (**v1)(); // esi
  int v2; // ebx

  v0 = ((char *)init_proc - (char *)&off_8048138) >> 3;
  if ( v0 )
  {
    v1 = &off_80EF040;
    v2 = 0;
    while ( 1 )
    {
      ++v2;
      *v1 = (int (*)())(*v1)();
      if ( v2 == v0 )
        break;
      v1 = (&off_8048138)[2 * v2];
      if ( byte_804813C[8 * v2] != 42 )
        _libc_fatal("unexpected reloc type in static binary");
    }
  }
}
// 8048138: using guessed type int (**off_8048138)();
// 80EF040: using guessed type int (*off_80EF040)();

//----- (08049620) --------------------------------------------------------
void _libc_csu_init(void)
{
  int v0; // ebx

  init_proc();
  if ( &_fini_array_start - _init_array_start )
  {
    v0 = 0;
    do
      _init_array_start[v0++]();
    while ( v0 != &_fini_array_start - _init_array_start );
  }
}
// 80EEFA0: using guessed type int (*_init_array_start[2])();
// 80EEFA4: using guessed type int (*_fini_array_start)();

//----- (080496C0) --------------------------------------------------------
void _libc_csu_fini(void)
{
  int i; // ebx

  for ( i = ((char *)&_CTOR_LIST__ - (char *)&_fini_array_start) >> 2; i; --i )
    _init_array_start[i]();
  term_proc();
}
// 80EEFA0: using guessed type int (*_init_array_start[2])();
// 80EEFA4: using guessed type int (*_fini_array_start)();
// 80EEFA8: using guessed type int _CTOR_LIST__;

//----- (080496F0) --------------------------------------------------------
int setjmp(jmp_buf env)
{
  int v1; // ebx
  int v2; // ebp
  int v3; // edi
  int v4; // esi
  int result; // eax
  struct __jmp_buf_tag *__attribute__((__org_typedef(jmp_buf))) v6; // edx
  unsigned int retaddr; // [esp+0h] [ebp+0h]

  result = 0;
  v6 = env;
  env->__jmpbuf[0] = v1;
  v6->__jmpbuf[1] = v4;
  v6->__jmpbuf[2] = v3;
  v6->__jmpbuf[4] = __ROL4__(__readgsdword(0x18u) ^ (unsigned int)&env, 9);
  v6->__jmpbuf[5] = __ROL4__(__readgsdword(0x18u) ^ retaddr, 9);
  v6->__jmpbuf[3] = v2;
  v6->__mask_was_saved = 0;
  return result;
}
// 80496F6: variable 'v1' is possibly undefined
// 80496F8: variable 'v4' is possibly undefined
// 80496FB: variable 'v3' is possibly undefined
// 804971F: variable 'v2' is possibly undefined

//----- (08049730) --------------------------------------------------------
void __usercall __noreturn _run_exit_handlers(long double a1@<st0>, int status, _DWORD **a3, char a4)
{
  _DWORD *v4; // ebx
  int v5; // eax
  int v6; // edx
  bool v7; // zf
  void (**v8)(void); // ebx

  while ( 1 )
  {
    v4 = *a3;
    if ( !*a3 )
    {
LABEL_11:
      if ( a4 && &_elf_set___libc_atexit_element__IO_cleanup__ < _EH_FRAME_BEGIN__ )
      {
        v8 = (void (**)(void))&_elf_set___libc_atexit_element__IO_cleanup__;
        do
          (*v8++)();
        while ( v8 < _EH_FRAME_BEGIN__ );
      }
      exit(status);
    }
LABEL_2:
    v5 = v4[1];
    while ( v5 )
    {
      --v5;
      v6 = v4[4 * v5 + 2];
      v4[1] = v5;
      switch ( v6 )
      {
        case 3:
          ((void (*)(void))(__readgsdword(0x18u) ^ __ROR4__(v4[4 * v5 + 3], 9)))();
          goto LABEL_2;
        case 4:
          ((void (__cdecl *)(_DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v4[4 * v5 + 3], 9)))(v4[4 * v5 + 4], status);
          goto LABEL_2;
        case 2:
          ((void (__cdecl *)(int, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v4[4 * v5 + 3], 9)))(status, v4[4 * v5 + 4]);
          goto LABEL_2;
      }
    }
    v7 = *v4 == 0;
    *a3 = (_DWORD *)*v4;
    if ( v7 )
      goto LABEL_11;
    free(a1, (int)v4);
  }
}
// 80DF180: using guessed type int (*_elf_set___libc_atexit_element__IO_cleanup__)();
// 80DF184: using guessed type _DWORD _EH_FRAME_BEGIN__[14696];

//----- (08049820) --------------------------------------------------------
void __usercall __noreturn exit(long double a1@<st0>, int a2)
{
  _run_exit_handlers(a1, a2, (_DWORD **)&_exit_funcs, 1);
}
// 80EF06C: using guessed type void *_exit_funcs;

//----- (08049840) --------------------------------------------------------
void __usercall _new_exitfn(int a1@<ebp>, long double a2@<st0>, _DWORD *a3)
{
  bool v4; // zf
  _DWORD *v5; // esi
  _DWORD *v6; // edi
  _DWORD *v7; // eax
  int v8; // ecx
  int v9; // edx
  _DWORD *v10; // edx
  _DWORD *v11; // edx
  char v12; // al
  _DWORD *v13; // eax

  _ECX = 1;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg ds:lock, ecx }
  if ( !v4 )
  {
    L_lock_22(0);
    return;
  }
  v5 = (_DWORD *)*a3;
  v6 = 0;
  v7 = (_DWORD *)*a3;
  if ( !*a3 )
  {
    v6 = 0;
LABEL_24:
    v12 = 1;
    goto LABEL_21;
  }
  while ( 1 )
  {
    v8 = v7[1];
    if ( !v8 )
      goto LABEL_11;
    v9 = v8 - 1;
    a1 = v7[4 * v8 - 2];
    if ( a1 )
      break;
    a1 = (int)&v7[4 * v8 - 6];
    while ( 1 )
    {
      v8 = v9;
      if ( !v9 )
        break;
      a1 -= 16;
      if ( *(_DWORD *)(a1 + 16) )
        goto LABEL_13;
      --v9;
    }
LABEL_11:
    v10 = (_DWORD *)*v7;
    v6 = v7;
    v7[1] = 0;
    if ( !v10 )
      goto LABEL_24;
    v7 = v10;
  }
LABEL_13:
  if ( v8 != 32 )
  {
    v11 = &v7[4 * v8 + 2];
    v7[1] = v8 + 1;
    goto LABEL_15;
  }
  v12 = 0;
LABEL_21:
  if ( v6 )
  {
LABEL_22:
    v11 = v6 + 2;
    v6[1] = 1;
LABEL_15:
    *v11 = 1;
    ++_new_exitfn_called;
  }
  else
  {
    if ( v12 )
      _assert_fail(a1, a2, (int)"l != ((void *)0)", (int)"cxa_atexit.c", 100, "__new_exitfn");
    calloc(1, 0x208u);
    v6 = v13;
    if ( v13 )
    {
      *v13 = v5;
      *a3 = v13;
      goto LABEL_22;
    }
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --lock )
    L_unlock_125();
}
// 804994F: variable 'v13' is possibly undefined
// 80F0320: using guessed type int lock;
// 80F1160: using guessed type __int64 _new_exitfn_called;

//----- (08049980) --------------------------------------------------------
int __usercall _internal_atexit@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, int a5, _DWORD *a6)
{
  _DWORD *v6; // eax

  _new_exitfn(a1, a2, a6);
  if ( !v6 )
    return -1;
  v6[1] = __ROL4__(__readgsdword(0x18u) ^ a3, 9);
  v6[2] = a4;
  v6[3] = a5;
  *v6 = 4;
  return 0;
}
// 8049991: variable 'v6' is possibly undefined

//----- (080499D0) --------------------------------------------------------
int __cdecl _cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle)
{
  int v3; // ebp
  long double v4; // fst7

  return _internal_atexit(v3, v4, (int)lpfunc, (int)obj, (int)lpdso_handle, &_exit_funcs);
}
// 80499F2: variable 'v3' is possibly undefined
// 80499F2: variable 'v4' is possibly undefined
// 80EF06C: using guessed type void *_exit_funcs;

//----- (080499FB) --------------------------------------------------------
void __usercall L_lock_22(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &lock);
  JUMPOUT(0x804986A);
}
// 8049A06: control flows out of bounds to 804986A
// 80F0320: using guessed type int lock;

//----- (08049A0B) --------------------------------------------------------
void L_unlock_125()
{
  _lll_unlock_wake_private(&lock);
  JUMPOUT(0x8049908);
}
// 8049A16: control flows out of bounds to 8049908
// 80F0320: using guessed type int lock;

//----- (08049A20) --------------------------------------------------------
int __usercall _libc_message@<eax>(long double a1@<st0>, int a2, char *a3, ...)
{
  _BYTE *v3; // eax
  bool v4; // zf
  char v5; // dl
  const char *v6; // esi
  _DWORD *v7; // edi
  char v8; // bl
  unsigned int *v9; // eax
  const char *v10; // ebx
  int v11; // edx
  _DWORD *v12; // ecx
  int v13; // eax
  const char **v14; // eax
  int v15; // edx
  void *v16; // esp
  int v17; // eax
  int v18; // ebx
  int v19; // ebx
  int v20; // ebx
  _DWORD *v21; // ecx
  __int64 v22; // rax
  _DWORD *v23; // edi
  int v24; // ecx
  int v25; // esi
  int v26; // ebx
  int result; // eax
  __int64 v28; // rax
  _DWORD *v29; // eax
  _WORD *v30; // eax
  int v31; // ebx
  int v32; // esi
  _BYTE *v33; // edx
  int *v34; // eax
  int v35; // ebx
  int v36; // ebx
  int v37; // ecx
  signed int nocancel; // esi
  unsigned int v39; // [esp-18h] [ebp-570h]
  _DWORD v40[11]; // [esp+0h] [ebp-558h] BYREF
  int v41; // [esp+2Ch] [ebp-52Ch]
  int v42; // [esp+30h] [ebp-528h]
  const char **v43; // [esp+34h] [ebp-524h]
  int v44; // [esp+38h] [ebp-520h]
  int i; // [esp+3Ch] [ebp-51Ch]
  char v46[1024]; // [esp+40h] [ebp-518h] BYREF
  char v47[4]; // [esp+440h] [ebp-118h] BYREF
  char v48[276]; // [esp+444h] [ebp-114h] BYREF
  va_list va; // [esp+568h] [ebp+10h] BYREF

  va_start(va, a3);
  va_copy(v43, va);
  v3 = (_BYTE *)_secure_getenv("LIBC_FATAL_STDERR_");
  if ( !v3 || (v4 = *v3 == 0, v44 = 2, v4) )
  {
    v44 = _open_nocancel((int)"/dev/tty", 2306);
    v13 = 2;
    if ( v44 != -1 )
      v13 = v44;
    v44 = v13;
  }
  v5 = *a3;
  if ( !*a3 )
    goto LABEL_27;
  v6 = a3;
  v7 = 0;
  v8 = *a3;
  for ( i = 0; ; ++i )
  {
    v9 = (unsigned int *)v6;
    do
    {
      if ( v5 == 37 && *((_BYTE *)v9 + 1) == 115 )
        break;
      v9 = strchrnul((unsigned int *)((char *)v9 + 1), 37);
      v5 = *(_BYTE *)v9;
    }
    while ( *(_BYTE *)v9 );
    if ( v8 == 37 && v6[1] == 115 )
    {
      v14 = v43;
      v6 += 2;
      ++v43;
      v10 = *v14;
      v11 = strlen(*v14);
    }
    else
    {
      v10 = v6;
      v11 = (char *)v9 - v6;
      v6 = (const char *)v9;
    }
    v12 = v40;
    v40[0] = v10;
    v40[1] = v11;
    v40[2] = v7;
    v5 = *v6;
    if ( !*v6 )
      break;
    v8 = *v6;
    v7 = v40;
  }
  v15 = 0;
  v16 = alloca(16 * ((8 * (i + 1) + 30) / 0x10u));
  v17 = i;
  do
  {
    v40[2 * v17] = *v12;
    v18 = v12[1];
    v12 = (_DWORD *)v12[2];
    v40[2 * v17-- + 1] = v18;
    v19 = v15 + v18;
    v15 = v19;
  }
  while ( v17 != -1 );
  i = v19;
  v20 = v44;
  v21 = v40;
  do
    v22 = dl_sysinfo(v21);
  while ( (_DWORD)v22 == -4 );
  v23 = v21;
  v24 = a2;
  v25 = HIDWORD(v22);
  v44 = v20;
  v26 = v22;
  if ( a2 )
  {
    v41 = -dl_pagesize & (dl_pagesize + i);
    v29 = (_DWORD *)mmap(0, v41, 3, 34, -1, 0);
    v43 = (const char **)v29;
    if ( v29 != (_DWORD *)-1 )
    {
      *v29 = v41;
      v30 = v29 + 1;
      v42 = v26;
      v31 = v25;
      v32 = 0;
      do
      {
        ++v32;
        v39 = v23[1];
        v33 = (_BYTE *)*v23;
        v23 += 2;
        v30 = mempcpy(v30, v33, v39);
      }
      while ( v32 < v31 );
      *(_BYTE *)v30 = 0;
      v26 = v42;
      v34 = (int *)_InterlockedExchange(&_abort_msg, (__int32)v43);
      if ( v34 )
        munmap((int)v34, *v34);
    }
  }
  if ( i == v26 )
  {
    result = 1;
  }
  else
  {
LABEL_27:
    vsyslog(a1, 3, (int)a3, (int)va);
    result = 0;
  }
  HIDWORD(v28) = a2;
  if ( a2 )
  {
    if ( a2 > 1 )
    {
      if ( (_BYTE)result )
      {
        v35 = backtrace((int)v47, 64);
        if ( v35 > 2 )
        {
          _write_nocancel(v44, (int)"======= Backtrace: =========\n");
          backtrace_symbols_fd((int)v48, v35 - 1, v44);
          _write_nocancel(v44, (int)"======= Memory map: ========\n");
          v36 = _open_nocancel((int)"/proc/self/maps", 0);
          do
            nocancel = _read_nocancel(v36, (int)v46);
          while ( nocancel > 0 && _write_nocancel(v44, (int)v46) == nocancel );
          v28 = dl_sysinfo(v37);
        }
      }
    }
    abort(v24, HIDWORD(v28));
  }
  return result;
}
// 8049BA5: variable 'v21' is possibly undefined
// 8049CD2: variable 'v24' is possibly undefined
// 8049CD2: variable 'v28' is possibly undefined
// 8049DA4: variable 'v37' is possibly undefined
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EF5B8: using guessed type int dl_pagesize;
// 80F0CA4: using guessed type int _abort_msg;
// 8049A20: using guessed type char var_118[4];
// 8049A20: using guessed type char var_114[276];

//----- (08049DB0) --------------------------------------------------------
void __cdecl __noreturn _libc_fatal(const char *a1)
{
  while ( 1 )
    _libc_message(1, "%s", a1);
}
// 8049A20: using guessed type _DWORD _libc_message(_DWORD, const char *, ...);

//----- (08049DE0) --------------------------------------------------------
void ptmalloc_lock_all()
{
  bool v3; // zf
  int (__cdecl *v4)(int); // eax
  int v5; // eax
  unsigned int v6; // eax

  if ( _libc_malloc_initialized > 0 )
  {
    _ECX = 1;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    __asm { cmpxchg ds:list_lock, ecx }
    _EDX = &main_arena;
    while ( 1 )
    {
      _ECX = 1;
      v3 = __readgsdword(0xCu) == 0;
      if ( !v3 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v3 )
        break;
      _EDX = (int *)_EDX[272];
      if ( _EDX == &main_arena )
      {
        v4 = _malloc_hook[0];
        _malloc_hook[0] = (int (__cdecl *)(int))malloc_atfork;
        save_malloc_hook = (int)v4;
        v5 = _free_hook;
        _free_hook = (int)free_atfork;
        save_free_hook = v5;
        v6 = __readgsdword(0xFFFFFFEC);
        __writegsdword(0xFFFFFFEC, 0xFFFFFFFF);
        save_arena = v6;
        ++atfork_recursive_cntr;
        return;
      }
    }
    L_lock_50(0, _EDX);
  }
}
// 80EF080: using guessed type int _libc_malloc_initialized;
// 80EF08C: using guessed type int (__cdecl *_malloc_hook[2])(int);
// 80EF0A0: using guessed type int main_arena;
// 80F054C: using guessed type int _free_hook;
// 80F0588: using guessed type int save_arena;
// 80F058C: using guessed type int save_malloc_hook;
// 80F0590: using guessed type int save_free_hook;
// 80F0598: using guessed type int list_lock;
// 80F059C: using guessed type int atfork_recursive_cntr;

//----- (08049EB0) --------------------------------------------------------
void ptmalloc_unlock_all2()
{
  int v0; // edx
  int v1; // ecx
  int *v2; // eax

  if ( _libc_malloc_initialized > 0 )
  {
    v0 = 0;
    v1 = save_arena;
    free_list = 0;
    __writegsdword(0xFFFFFFEC, save_arena);
    _malloc_hook[0] = (int (__cdecl *)(int))save_malloc_hook;
    _free_hook = save_free_hook;
    v2 = &main_arena;
    do
    {
      *v2 = 0;
      if ( v2 != (int *)v1 )
      {
        v2[273] = v0;
        v0 = (int)v2;
      }
      v2 = (int *)v2[272];
    }
    while ( v2 != &main_arena );
    free_list = v0;
    list_lock = 0;
    atfork_recursive_cntr = 0;
  }
}
// 80EF080: using guessed type int _libc_malloc_initialized;
// 80EF08C: using guessed type int (__cdecl *_malloc_hook[2])(int);
// 80EF0A0: using guessed type int main_arena;
// 80F054C: using guessed type int _free_hook;
// 80F0588: using guessed type int save_arena;
// 80F058C: using guessed type int save_malloc_hook;
// 80F0590: using guessed type int save_free_hook;
// 80F0594: using guessed type int free_list;
// 80F0598: using guessed type int list_lock;
// 80F059C: using guessed type int atfork_recursive_cntr;

//----- (08049F30) --------------------------------------------------------
int __usercall mem2mem_check@<eax>(int result@<eax>, unsigned int a2@<edx>)
{
  unsigned int v2; // ecx

  if ( result )
  {
    v2 = (*(_DWORD *)(result - 4) & 0xFFFFFFF8) - ((*(_DWORD *)(result - 4) & 2) == 0 ? 5 : 9);
    if ( v2 > a2 )
    {
      while ( v2 - a2 > 0xFF )
      {
        *(_BYTE *)(result + v2) = -1;
        v2 -= 255;
        if ( a2 >= v2 )
          goto LABEL_7;
      }
      *(_BYTE *)(result + v2) = v2 - a2;
    }
LABEL_7:
    *(_BYTE *)(result + a2) = ((unsigned int)(result - 8) >> 3) ^ ((unsigned int)(result - 8) >> 11);
  }
  return result;
}

//----- (08049F90) --------------------------------------------------------
unsigned int __usercall mem2chunk_check@<eax>(int a1@<eax>, _DWORD *a2@<edx>)
{
  unsigned int v2; // edi
  int v3; // ecx
  unsigned int v4; // esi
  unsigned int v5; // esi
  unsigned __int8 *v6; // ebx
  int v7; // ecx
  int v8; // ebp
  unsigned __int8 v9; // al
  unsigned int v11; // ebx
  unsigned int v12; // ecx
  unsigned int v13; // esi
  int v14; // ebp
  int v15; // ecx
  int v16; // eax
  unsigned int v17; // ecx
  unsigned __int8 v18; // [esp+3h] [ebp-1Dh]

  v2 = 0;
  if ( (a1 & 7) != 0 )
    return v2;
  v3 = *(_DWORD *)(a1 - 4);
  v2 = a1 - 8;
  if ( (v3 & 2) != 0 )
  {
    v11 = (dl_pagesize - 1) & a1;
    if ( v11
      && v11 != 8
      && v11 != 32
      && v11 != 16
      && v11 != 128
      && v11 != 64
      && v11 != 512
      && v11 != 256
      && v11 != 2048
      && v11 != 1024
      && v11 <= 0x1FFF
      && v11 != 4096 )
    {
      return 0;
    }
    if ( (*(_DWORD *)(a1 - 4) & 3) != 2 )
      return 0;
    v12 = v3 & 0xFFFFFFF8;
    if ( ((dl_pagesize - 1) & ((v12 + *(_DWORD *)(a1 - 8)) | (v2 - *(_DWORD *)(a1 - 8)))) != 0 )
      return 0;
    v13 = v12 - 1;
    v6 = (unsigned __int8 *)(v2 + v12 - 1);
    v18 = *v6;
    v14 = (unsigned __int8)((v2 >> 11) ^ (v2 >> 3));
    if ( *v6 == v14 )
      goto LABEL_17;
    if ( !v18 )
      return 0;
    v15 = *v6;
    if ( v13 < (unsigned int)v18 + 8 )
      return 0;
    while ( 1 )
    {
      v13 -= v15;
      v6 = (unsigned __int8 *)(v2 + v13);
      v9 = *(_BYTE *)(v2 + v13);
      v15 = v9;
      if ( v9 == v14 )
        break;
      if ( !v9 || (unsigned int)v9 + 8 > v13 )
        return 0;
    }
LABEL_16:
    v18 = v9;
LABEL_17:
    *v6 = ~v18;
    if ( a2 )
      *a2 = v6;
    return v2;
  }
  v4 = v3 & 0xFFFFFFF8;
  if ( (dword_80EF0A4 & 2) == 0 && (v2 < dword_80EF530 || v2 + v4 >= dword_80EF4E8 + dword_80EF530) )
    return 0;
  if ( v4 <= 0xF || (*(_BYTE *)(v2 + (v3 & 0xFFFFFFF8) + 4) & 1) == 0 )
    return 0;
  if ( (v3 & 1) == 0 )
  {
    v16 = *(_DWORD *)(a1 - 8);
    if ( (v16 & 7) != 0 )
      return 0;
    v17 = v2 - v16;
    if ( (dword_80EF0A4 & 2) == 0 && v17 < dword_80EF530 )
      return 0;
    if ( v16 != (*(_DWORD *)(v17 + 4) & 0xFFFFFFF8) )
      return 0;
  }
  v5 = v4 + 3;
  v6 = (unsigned __int8 *)(v2 + v5);
  v7 = *(unsigned __int8 *)(v2 + v5);
  v18 = *(_BYTE *)(v2 + v5);
  v8 = (unsigned __int8)((v2 >> 11) ^ (v2 >> 3));
  if ( v7 == v8 )
    goto LABEL_17;
  if ( *(_BYTE *)(v2 + v5) && v5 >= (unsigned int)*(unsigned __int8 *)(v2 + v5) + 8 )
  {
    while ( 1 )
    {
      v5 -= v7;
      v6 = (unsigned __int8 *)(v2 + v5);
      v9 = *(_BYTE *)(v2 + v5);
      v7 = v9;
      if ( v9 == v8 )
        break;
      if ( !v9 || (unsigned int)v9 + 8 > v5 )
        return 0;
    }
    goto LABEL_16;
  }
  return 0;
}
// 80EF0A4: using guessed type int dword_80EF0A4;
// 80EF4E8: using guessed type int dword_80EF4E8;
// 80EF530: using guessed type int dword_80EF530;
// 80EF5B8: using guessed type int dl_pagesize;

//----- (0804A220) --------------------------------------------------------
void __usercall __noreturn _malloc_assert(
        const char *a1@<eax>,
        const char *a2@<edx>,
        int a3@<ecx>,
        long double a4@<st0>,
        const char *a5)
{
  const char *v5; // ebp
  const char *v6; // esi
  const char *v7; // ebx
  int v8; // edx
  int v9; // ecx

  v5 = ": ";
  v6 = a5;
  if ( !a5 )
  {
    v5 = (const char *)&unk_80C86D9;
    v6 = (const char *)&unk_80C86D9;
  }
  v7 = ": ";
  if ( !*(_BYTE *)program_invocation_short_name )
    v7 = (const char *)&unk_80C86D9;
  _fxprintf(
    a4,
    0,
    "%s%s%s:%u: %s%sAssertion `%s' failed.\n",
    (const char *)program_invocation_short_name,
    v7,
    a2,
    a3,
    v6,
    v5,
    a1);
  fflush((_DWORD *)stderr);
  abort(v9, v8);
}
// 804A28C: variable 'v9' is possibly undefined
// 804A28C: variable 'v8' is possibly undefined
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);
// 80EF56C: using guessed type void *program_invocation_short_name;

//----- (0804A2A0) --------------------------------------------------------
int __usercall new_heap@<eax>(unsigned int a1@<eax>, int a2@<edx>)
{
  unsigned int v3; // esi
  int v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // ebx
  int v8; // esi
  int result; // eax
  int v10; // eax
  int v11; // ebp
  int v12; // edx
  unsigned int v13; // eax

  v3 = a2 + a1;
  v4 = dl_pagesize;
  if ( a2 + a1 <= 0x7FFF )
  {
    v5 = aligned_heap_area;
    v3 = 0x8000;
    if ( !aligned_heap_area )
      goto LABEL_10;
    goto LABEL_4;
  }
  if ( v3 <= 0x100000 || (result = 0, v3 = 0x100000, a1 <= 0x100000) )
  {
    v5 = aligned_heap_area;
    if ( !aligned_heap_area )
      goto LABEL_10;
LABEL_4:
    v6 = mmap(v5, 0x100000, 0, 16418, -1, 0);
    aligned_heap_area = 0;
    v7 = v6;
    if ( v6 != -1 )
    {
      if ( (v6 & 0xFFFFF) == 0 )
        goto LABEL_6;
      munmap(v6, 0x100000);
    }
LABEL_10:
    v10 = mmap(0, 0x200000, 0, 16418, -1, 0);
    if ( v10 == -1 )
    {
      v13 = mmap(0, 0x100000, 0, 16418, -1, 0);
      v7 = v13;
      if ( v13 == -1 )
        return 0;
      if ( (v13 & 0xFFFFF) != 0 )
        goto LABEL_20;
    }
    else
    {
      v7 = (v10 + 0xFFFFF) & 0xFFF00000;
      v11 = v7 - v10;
      if ( v7 == v10 )
      {
        v12 = v7 + 0x100000;
        aligned_heap_area = v7 + 0x100000;
      }
      else
      {
        munmap(v10, v11);
        v12 = v7 + 0x100000;
      }
      munmap(v12, 0x100000 - v11);
    }
LABEL_6:
    v8 = ~(v4 - 1) & (v4 - 1 + v3);
    if ( !mprotect(v7, v8) )
    {
      *(_DWORD *)(v7 + 8) = v8;
      result = v7;
      *(_DWORD *)(v7 + 12) = v8;
      return result;
    }
LABEL_20:
    munmap(v7, 0x100000);
    return 0;
  }
  return result;
}
// 80EF5B8: using guessed type int dl_pagesize;
// 80F0568: using guessed type int aligned_heap_area;

//----- (0804A4B0) --------------------------------------------------------
void __usercall mi_arena_10548(int *a1@<eax>, _DWORD *a2@<ecx>)
{
  int v2; // eax
  bool v5; // zf
  unsigned int v6; // ecx
  int v7; // esi
  int v8; // edi
  int v9; // eax
  int v10; // edx
  unsigned int v11; // ebx
  int *v12; // edx
  size_t v13; // ebx
  size_t v14; // ebp
  size_t v15; // ecx
  size_t v16; // edi
  size_t v17; // eax
  char *v18; // ebp
  int *v19; // edx
  unsigned int v20; // ebx
  int v21; // edi
  int v22; // esi
  unsigned int v23; // ecx
  unsigned int v24; // eax
  int v25; // eax
  int v26; // edx
  int *v27; // ebx
  int v28; // esi
  int v29; // eax
  int v30; // edx
  int v31; // eax
  unsigned int v32; // ebx
  int v33; // eax
  int v34; // [esp+Ch] [ebp-8F0h]
  int v35; // [esp+10h] [ebp-8ECh]
  int v36; // [esp+14h] [ebp-8E8h]
  int v37; // [esp+2Ch] [ebp-8D0h]
  size_t v38; // [esp+30h] [ebp-8CCh]
  size_t v39; // [esp+34h] [ebp-8C8h]
  int *v40; // [esp+3Ch] [ebp-8C0h]
  int v43; // [esp+48h] [ebp-8B4h]
  int v44; // [esp+4Ch] [ebp-8B0h]
  int v45[3]; // [esp+50h] [ebp-8ACh]
  int v46[37]; // [esp+5Ch] [ebp-8A0h] BYREF
  size_t v47; // [esp+F0h] [ebp-80Ch]
  size_t v48; // [esp+F4h] [ebp-808h]
  size_t v49; // [esp+F8h] [ebp-804h]
  size_t v50; // [esp+FCh] [ebp-800h]
  char v51; // [esp+100h] [ebp-7FCh] BYREF

  v2 = a2[9];
  a2[9] = v2 + 1;
  fprintf(a2[8], (int)"<heap nr=\"%d\">\n<sizes>\n", v2);
  _ECX = 1;
  _EDX = a1;
  v5 = __readgsdword(0xCu) == 0;
  if ( !v5 )
    __asm { lock }
  __asm { cmpxchg [edx], ecx }
  if ( v5 )
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = a1[v6 / 4 + 2];
      if ( v9 )
      {
        v10 = 0;
        v11 = *(_DWORD *)(v9 + 4) & 0xFFFFFFF8;
        do
        {
          v9 = *(_DWORD *)(v9 + 8);
          ++v10;
        }
        while ( v9 );
        v7 += v10;
        v45[v6 + 1] = v11;
        v46[v6] = v10;
        v8 += v11 * v10;
        v45[v6] = v11 - 7;
      }
      else
      {
        v46[v6] = 0;
        v10 = 0;
        v45[v6 + 1] = 0;
        v45[v6] = 0;
      }
      v45[v6 + 2] = v45[v6 + 1] * v10;
      v6 += 4;
    }
    while ( v6 != 40 );
    v43 = v7;
    v44 = v8;
    v38 = 0;
    v12 = (int *)a1[14];
    v39 = 0;
    if ( v12 )
    {
      if ( a1 + 12 == v12 )
      {
        v39 = v50;
        v38 = v49;
      }
      else
      {
        v13 = v47;
        v14 = v50;
        v15 = v48;
        v16 = v49;
        do
        {
          v17 = v12[1];
          ++v14;
          v12 = (int *)v12[2];
          v16 += v17;
          if ( v13 > v17 )
            v13 = v17;
          if ( v15 < v17 )
            v15 = v17;
        }
        while ( a1 + 12 != v12 );
        v38 = v16;
        v39 = v14;
        v50 = v14;
        v49 = v16;
        v47 = v13;
        v48 = v15;
      }
    }
    v18 = &v51;
    v37 = 0;
    v40 = a1 + 14;
    do
    {
      *(_DWORD *)v18 = -1;
      *((_DWORD *)v18 + 3) = 0;
      v19 = (int *)v40[v37 + 2];
      *((_DWORD *)v18 + 2) = 0;
      *((_DWORD *)v18 + 1) = 0;
      if ( v19 && &v40[v37] != v19 )
      {
        v20 = -1;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        do
        {
          v24 = v19[1];
          ++v21;
          v19 = (int *)v19[2];
          v22 += v24;
          if ( v20 > v24 )
            v20 = v24;
          if ( v23 < v24 )
            v23 = v24;
        }
        while ( &v40[v37] != v19 );
        *(_DWORD *)v18 = v20;
        *((_DWORD *)v18 + 3) = v21;
        *((_DWORD *)v18 + 2) = v22;
        *((_DWORD *)v18 + 1) = v23;
      }
      v25 = *((_DWORD *)v18 + 3);
      if ( !v25 )
        *(_DWORD *)v18 = 0;
      v26 = *((_DWORD *)v18 + 2);
      v18 += 16;
      v37 += 2;
      v39 += v25;
      v38 += v26;
    }
    while ( v37 != 252 );
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v5 = (*a1)-- == 1;
    if ( v5 )
    {
      v27 = v46;
      v28 = 0;
      a2[7] += v43;
      a2[6] += v44;
      a2[5] += v39;
      a2[4] += v38;
      do
      {
        while ( !*v27 || v28 == 10 )
        {
          ++v28;
          v27 += 4;
          if ( v28 == 137 )
            goto LABEL_40;
        }
        v36 = *v27;
        ++v28;
        v35 = *(v27 - 1);
        v34 = *(v27 - 2);
        v29 = *(v27 - 3);
        v27 += 4;
        fprintf(a2[8], (int)"<size from=\"%zu\" to=\"%zu\" total=\"%zu\" count=\"%zu\"/>\n", v29, v34, v35, v36);
      }
      while ( v28 != 137 );
LABEL_40:
      if ( v50 )
        fprintf(a2[8], (int)"<unsorted from=\"%zu\" to=\"%zu\" total=\"%zu\" count=\"%zu\"/>\n", v47, v48, v49, v50);
      v30 = a1[274];
      a2[3] += v30;
      v31 = a1[275];
      a2[2] += v31;
      fprintf(
        a2[8],
        (int)"</sizes>\n"
             "<total type=\"fast\" count=\"%zu\" size=\"%zu\"/>\n"
             "<total type=\"rest\" count=\"%zu\" size=\"%zu\"/>\n"
             "<system type=\"current\" size=\"%zu\"/>\n"
             "<system type=\"max\" size=\"%zu\"/>\n",
        v43,
        v44,
        v39,
        v38,
        v30,
        v31);
      if ( a1 == &main_arena )
      {
        fprintf(
          a2[8],
          (int)"<aspace type=\"total\" size=\"%zu\"/>\n<aspace type=\"mprotect\" size=\"%zu\"/>\n",
          dword_80EF4E8,
          dword_80EF4E8);
        v33 = dword_80EF4E8;
        a2[1] += dword_80EF4E8;
        *a2 += v33;
      }
      else
      {
        v32 = a1[12] & 0xFFF00000;
        fprintf(
          a2[8],
          (int)"<aspace type=\"total\" size=\"%zu\"/>\n<aspace type=\"mprotect\" size=\"%zu\"/>\n",
          *(_DWORD *)(v32 + 8),
          *(_DWORD *)(v32 + 0xC));
        a2[1] += *(_DWORD *)(v32 + 8);
        *a2 += *(_DWORD *)(v32 + 12);
      }
      fputs("</heap>\n", (_DWORD *)a2[8]);
    }
    else
    {
      L_unlock_1146(a1);
    }
  }
  else
  {
    L_lock_929(0, a1);
  }
}
// 80EF0A0: using guessed type int main_arena;
// 80EF4E8: using guessed type int dword_80EF4E8;
// 804A4B0: using guessed type int var_8A0[37];

//----- (0804A8F0) --------------------------------------------------------
int *__usercall mremap_chunk@<eax>(int *result@<eax>, int a2@<edx>)
{
  int v2; // edi
  int v3; // esi
  int v4; // edi
  int v5; // ebx
  unsigned int v6; // eax
  int v7; // edx
  unsigned int v8; // ebx
  bool v9; // cc

  v2 = result[1];
  v3 = *result;
  if ( (v2 & 2) == 0 )
    _malloc_assert("mremap_chunk");
  v4 = v3 + (v2 & 0xFFFFFFF8);
  if ( ((dl_pagesize - 1) & v4) != 0 )
    _malloc_assert("mremap_chunk");
  v5 = ~(dl_pagesize - 1) & (a2 + dl_pagesize - 1 + v3 + 4);
  if ( v4 != v5 )
  {
    v6 = mremap((int)result - v3, v4);
    if ( v6 == -1 )
    {
      return 0;
    }
    else
    {
      result = (int *)(v3 + v6);
      if ( ((unsigned __int8)result & 7) != 0 )
        _malloc_assert("mremap_chunk");
      if ( *result != v3 )
        _malloc_assert("mremap_chunk");
      v7 = (v5 - *result) | 2;
      v8 = dword_80EF524 + v5 - v4;
      v9 = v8 <= dword_80EF528;
      result[1] = v7;
      dword_80EF524 = v8;
      if ( !v9 )
        dword_80EF528 = v8;
    }
  }
  return result;
}
// 804A220: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80EF524: using guessed type int dword_80EF524;
// 80EF528: using guessed type int dword_80EF528;
// 80EF5B8: using guessed type int dl_pagesize;

//----- (0804AA10) --------------------------------------------------------
void ptmalloc_unlock_all()
{
  int v0; // ecx
  int *v1; // edx

  v0 = _libc_malloc_initialized;
  if ( _libc_malloc_initialized > 0 && !--atfork_recursive_cntr )
  {
    __writegsdword(0xFFFFFFEC, save_arena);
    v1 = &main_arena;
    _malloc_hook[0] = (int (__cdecl *)(int))save_malloc_hook;
    _free_hook = save_free_hook;
    do
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( (*v1)-- != 1 )
      {
        L_unlock_1541(v0, v1);
        return;
      }
      v1 = (int *)v1[272];
    }
    while ( v1 != &main_arena );
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_lock )
      L_unlock_1550();
  }
}
// 80EF080: using guessed type int _libc_malloc_initialized;
// 80EF08C: using guessed type int (__cdecl *_malloc_hook[2])(int);
// 80EF0A0: using guessed type int main_arena;
// 80F054C: using guessed type int _free_hook;
// 80F0588: using guessed type int save_arena;
// 80F058C: using guessed type int save_malloc_hook;
// 80F0590: using guessed type int save_free_hook;
// 80F0598: using guessed type int list_lock;
// 80F059C: using guessed type int atfork_recursive_cntr;

//----- (0804AAA0) --------------------------------------------------------
int __usercall sYSTRIm_isra_1@<eax>(int a1@<eax>, int *a2@<edx>, _DWORD *a3@<ecx>)
{
  int v4; // edi
  unsigned int v6; // esi
  int v7; // edx
  int v9; // edx
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // [esp+18h] [ebp-24h]
  int v14; // [esp+18h] [ebp-24h]
  int v15; // [esp+1Ch] [ebp-20h]

  v4 = 0;
  v6 = *(_DWORD *)(*a2 + 4) & 0xFFFFFFF8;
  v15 = -dl_pagesize & (v6 - a1 - 17);
  if ( v15 > 0 )
  {
    v7 = _morecore(0);
    if ( v7 == v6 + *a2 )
    {
      v13 = v7;
      _morecore(-v15);
      v9 = v13;
      if ( _after_morecore_hook )
      {
        ((void (*)(void))_after_morecore_hook)();
        v9 = v13;
      }
      v14 = v9;
      v4 = 0;
      v10 = _morecore(0);
      if ( v10 )
      {
        v11 = v14 - v10;
        if ( v14 != v10 )
        {
          v12 = *a2;
          LOWORD(v4) = 1;
          *a3 -= v11;
          *(_DWORD *)(v12 + 4) = (v6 - v11) | 1;
        }
      }
    }
  }
  return v4;
}
// 80EF090: using guessed type int (__cdecl *_morecore)(_DWORD);
// 80EF5B8: using guessed type int dl_pagesize;
// 80F0548: using guessed type int _after_morecore_hook;

//----- (0804AB70) --------------------------------------------------------
int __usercall malloc_printerr@<eax>(char a1@<al>, const char *a2@<edx>, unsigned int a3@<ecx>, long double a4@<st0>)
{
  int result; // eax
  char *v6; // eax
  const char *v7; // ecx
  char v9[8]; // [esp+37h] [ebp-15h] BYREF
  char v10[13]; // [esp+3Fh] [ebp-Dh] BYREF

  result = a1 & 5;
  if ( result == 5 )
    return _libc_message(a4, a1 & 2, "%s\n", a2);
  if ( (a1 & 1) != 0 )
  {
    v10[0] = 0;
    v6 = itoa_word(a3, v10, 0x10u, 0);
    if ( v6 > v9 )
    {
      do
        *--v6 = 48;
      while ( v6 != v9 );
      v6 = v9;
    }
    v7 = *(const char **)_libc_argv;
    if ( !*(_DWORD *)_libc_argv )
      v7 = "<unknown>";
    return _libc_message(a4, a1 & 2, "*** glibc detected *** %s: %s: 0x%s ***\n", v7, a2, v6);
  }
  else if ( (a1 & 2) != 0 )
  {
    abort(a3, a2);
  }
  return result;
}
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);
// 80F1254: using guessed type int _libc_argv;
// 804AB70: using guessed type char var_D[13];

//----- (0804AC40) --------------------------------------------------------
int top_check()
{
  int result; // eax
  int v1; // ebx
  int v2; // edx
  int v3; // esi
  int v4; // edi
  int v5; // ebx
  int v6; // ebp

  result = 0;
  v1 = dl_pagesize;
  if ( (int *)dword_80EF0D0 != &dword_80EF0D0 )
  {
    v2 = *(_DWORD *)(dword_80EF0D0 + 4);
    if ( (v2 & 2) != 0
      || (v2 & 0xFFFFFFF8) <= 0xF
      || (v2 & 1) == 0
      || (dword_80EF0A4 & 2) == 0 && dword_80EF0D0 + (v2 & 0xFFFFFFF8) != dword_80EF4E8 + dword_80EF530 )
    {
      malloc_printerr(dword_80EF0D0, "malloc: top chunk is corrupt");
      v3 = _morecore(0);
      v4 = v3 & 7;
      if ( (v3 & 7) != 0 )
        v4 = 8 - v4;
      v5 = v4 + dword_80EF504 + 16 + v1 - ((v1 - 1) & (v3 + v4 + dword_80EF504 + 16));
      v6 = _morecore(v5);
      if ( v6 )
      {
        if ( _after_morecore_hook )
          _after_morecore_hook();
        dword_80EF0D0 = v4 + v3;
        result = 0;
        dword_80EF4E8 = v5 + v6 - dword_80EF530;
        *(_DWORD *)(v4 + v3 + 4) = (v5 - v4) | 1;
      }
      else
      {
        __writegsdword(0xFFFFFFE8, 0xCu);
        return -1;
      }
    }
  }
  return result;
}
// 80F0548: invalid function type '?' has been ignored
// 804AB70: using guessed type int __fastcall malloc_printerr(_DWORD, _DWORD);
// 80EF090: using guessed type int (__cdecl *_morecore)(_DWORD);
// 80EF0A4: using guessed type int dword_80EF0A4;
// 80EF0D0: using guessed type int dword_80EF0D0;
// 80EF4E8: using guessed type int dword_80EF4E8;
// 80EF504: using guessed type int dword_80EF504;
// 80EF530: using guessed type int dword_80EF530;
// 80EF5B8: using guessed type int dl_pagesize;
// 80F0548: using guessed type int (*_after_morecore_hook)(void);

//----- (0804AD60) --------------------------------------------------------
int *__usercall malloc_consolidate@<eax>(int *a1@<eax>)
{
  int v2; // edx
  int *v3; // ecx
  int *v4; // ebx
  unsigned int v5; // edi
  _DWORD *v6; // eax
  int v7; // edx
  bool v8; // cc
  int v9; // ecx
  int v10; // eax
  _DWORD *v11; // esi
  int v12; // eax
  _DWORD *v13; // eax
  int v14; // edx
  int v15; // ecx
  unsigned int v16; // eax
  int *v17; // eax
  int v18; // eax
  int *result; // eax
  int v20; // edx
  int v21; // edx
  int *v22; // [esp+1Ch] [ebp-30h]
  int v23; // [esp+20h] [ebp-2Ch]
  volatile __int32 *v24; // [esp+24h] [ebp-28h]
  int *v25; // [esp+28h] [ebp-24h]
  volatile __int32 *v26; // [esp+2Ch] [ebp-20h]

  v2 = -2;
  v3 = a1 + 14;
  if ( global_max_fast )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    a1[1] |= 1u;
    v25 = a1 + 12;
    v26 = a1 + 11;
    v24 = a1 + 2;
    do
    {
      v4 = (int *)_InterlockedExchange(v24, 0);
      if ( v4 )
      {
        while ( 1 )
        {
          v22 = (int *)v4[2];
          v5 = v4[1] & 0xFFFFFFFA;
          v11 = (int *)((char *)v4 + v5);
          v23 = *(int *)((char *)v4 + v5 + 4);
          if ( (v4[1] & 1) == 0 )
          {
            v12 = *v4;
            v4 = (int *)((char *)v4 - *v4);
            v5 += v12;
            v13 = (_DWORD *)v4[2];
            v14 = v4[3];
            if ( v4 == (int *)v13[3] && v4 == *(int **)(v14 + 8) )
            {
              v8 = (unsigned int)v4[1] <= 0x1FF;
              v13[3] = v14;
              *(_DWORD *)(v14 + 8) = v13;
              if ( !v8 )
              {
                v15 = v4[4];
                if ( v15 )
                {
                  if ( v4 != *(int **)(v15 + 20) )
                    _malloc_assert("malloc_consolidate");
                  v21 = v4[5];
                  if ( v4 != *(int **)(v21 + 16) )
                    _malloc_assert("malloc_consolidate");
                  if ( v13[4] )
                  {
                    *(_DWORD *)(v15 + 20) = v21;
                    *(_DWORD *)(v4[5] + 16) = v15;
                  }
                  else if ( v4 == (int *)v15 )
                  {
                    v13[5] = v13;
                    v13[4] = v13;
                  }
                  else
                  {
                    v13[5] = v21;
                    v13[4] = v15;
                    *(_DWORD *)(v4[4] + 20) = v13;
                    *(_DWORD *)(v4[5] + 16) = v13;
                  }
                }
              }
            }
            else
            {
              malloc_printerr(v4, "corrupted double-linked list");
            }
          }
          v16 = v23 & 0xFFFFFFF8;
          if ( v11 == (_DWORD *)a1[12] )
          {
            v4[1] = (v16 + v5) | 1;
            a1[12] = (int)v4;
          }
          else
          {
            if ( (*((_BYTE *)v11 + v16 + 4) & 1) != 0 )
            {
              v11[1] &= ~1u;
            }
            else
            {
              v5 += v16;
              v6 = (_DWORD *)v11[2];
              v7 = v11[3];
              if ( v11 == (_DWORD *)v6[3] && v11 == *(_DWORD **)(v7 + 8) )
              {
                v8 = v11[1] <= 0x1FFu;
                v6[3] = v7;
                *(_DWORD *)(v7 + 8) = v6;
                if ( !v8 )
                {
                  v9 = v11[4];
                  if ( v9 )
                  {
                    if ( v11 != *(_DWORD **)(v9 + 20) )
                      _malloc_assert("malloc_consolidate");
                    v20 = v11[5];
                    if ( v11 != *(_DWORD **)(v20 + 16) )
                      _malloc_assert("malloc_consolidate");
                    if ( v6[4] )
                    {
                      *(_DWORD *)(v9 + 20) = v20;
                      *(_DWORD *)(v11[5] + 16) = v9;
                    }
                    else if ( v11 == (_DWORD *)v9 )
                    {
                      v6[5] = v6;
                      v6[4] = v6;
                    }
                    else
                    {
                      v6[5] = v20;
                      v6[4] = v9;
                      *(_DWORD *)(v11[4] + 20) = v6;
                      *(_DWORD *)(v11[5] + 16) = v6;
                    }
                  }
                }
              }
              else
              {
                malloc_printerr(v11, "corrupted double-linked list");
              }
            }
            v10 = a1[14];
            a1[14] = (int)v4;
            *(_DWORD *)(v10 + 12) = v4;
            if ( v5 > 0x1FF )
            {
              v4[4] = 0;
              v4[5] = 0;
            }
            v4[1] = v5 | 1;
            v4[2] = v10;
            *(int *)((char *)v4 + v5) = v5;
            v4[3] = (int)v25;
          }
          if ( !v22 )
            break;
          v4 = v22;
        }
      }
      result = (int *)v24++;
    }
    while ( v26 != v24 - 1 );
  }
  else
  {
    do
    {
      v17 = &v3[v2];
      v2 += 2;
      v17[3] = (int)v17;
      v17[2] = (int)v17;
    }
    while ( v2 != 252 );
    if ( a1 == &main_arena )
    {
      global_max_fast = 64;
      v18 = dword_80EF0A4;
    }
    else
    {
      v18 = a1[1] | 2;
    }
    a1[1] = v18 | 1;
    result = a1 + 12;
    a1[12] = (int)(a1 + 12);
  }
  return result;
}
// 804A220: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 804AB70: using guessed type int __fastcall malloc_printerr(_DWORD, _DWORD);
// 80EF0A0: using guessed type int main_arena;
// 80EF0A4: using guessed type int dword_80EF0A4;
// 80F055C: using guessed type int global_max_fast;

//----- (0804B060) --------------------------------------------------------
int *__usercall mALLINFo@<eax>(int *a1@<eax>, int *a2@<edx>)
{
  int v2; // eax
  int v3; // ebp
  int v4; // ecx
  int v5; // esi
  int i; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // edi
  int v10; // ebx
  int *v11; // ebp
  int *j; // eax
  int v13; // edx
  int v14; // eax
  int v15; // edx
  int v16; // edx
  int v17; // edx
  int *result; // eax
  int v21; // [esp+18h] [ebp-24h]
  int v22; // [esp+1Ch] [ebp-20h]

  v2 = a2[12];
  if ( !v2 )
  {
    malloc_consolidate(a2);
    v2 = a2[12];
  }
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v21 = *(_DWORD *)(v2 + 4);
  do
  {
    for ( i = a2[v4 + 2]; i; v3 += v7 & 0xFFFFFFF8 )
    {
      v7 = *(_DWORD *)(i + 4);
      ++v5;
      i = *(_DWORD *)(i + 8);
    }
    ++v4;
  }
  while ( v4 != 10 );
  v8 = v3 + (v21 & 0xFFFFFFF8);
  v9 = -2;
  v22 = v3;
  v10 = 1;
  v11 = a2 + 14;
  do
  {
    for ( j = (int *)v11[v9 + 3]; &v11[v9] != j; v8 += v13 & 0xFFFFFFF8 )
    {
      v13 = j[1];
      ++v10;
      j = (int *)j[3];
    }
    v9 += 2;
  }
  while ( v9 != 252 );
  v14 = a2[274];
  a1[1] = v10;
  *a1 = v14;
  a1[2] = v5;
  v15 = dword_80EF514;
  a1[7] = v14 - v8;
  a1[3] = v15;
  v16 = dword_80EF524;
  a1[6] = v22;
  a1[8] = v8;
  a1[4] = v16;
  v17 = dword_80EF52C;
  a1[9] = v21 & 0xFFFFFFF8;
  result = a1;
  a1[5] = v17;
  return result;
}
// 80EF514: using guessed type int dword_80EF514;
// 80EF524: using guessed type int dword_80EF524;
// 80EF52C: using guessed type int dword_80EF52C;

//----- (0804B180) --------------------------------------------------------
int __usercall munmap_chunk@<eax>(_DWORD *a1@<eax>, long double a2@<st0>)
{
  int v2; // ecx
  int v3; // edx
  int v5; // [esp+0h] [ebp-1Ch]

  v2 = a1[1];
  if ( (v2 & 2) == 0 )
    _malloc_assert("((p)->size & 0x2)", "malloc.c", 2839, a2, "munmap_chunk");
  v3 = *a1 + (v2 & 0xFFFFFFF8);
  if ( ((dl_pagesize - 1) & (v3 | ((unsigned int)a1 - *a1))) != 0 )
    return malloc_printerr(check_action, "munmap_chunk(): invalid pointer", (unsigned int)(a1 + 2), a2);
  v5 = (int)a1 - *a1;
  --dword_80EF514;
  dword_80EF524 -= v3;
  return munmap(v5, v3);
}
// 80EF514: using guessed type int dword_80EF514;
// 80EF524: using guessed type int dword_80EF524;
// 80EF534: using guessed type int check_action;
// 80EF5B8: using guessed type int dl_pagesize;

//----- (0804B210) --------------------------------------------------------
void __usercall int_free(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)
{
  int v4; // eax
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // eax
  int v8; // esi
  int *v9; // edx
  int v11; // edi
  int *v13; // eax
  _DWORD *v14; // edi
  unsigned int v15; // ebp
  unsigned int v16; // ebp
  int v17; // eax
  _DWORD *v18; // eax
  int v19; // edx
  bool v20; // cc
  int v21; // eax
  int v22; // edx
  int v23; // eax
  unsigned int v24; // ebx
  _DWORD *v25; // esi
  int v26; // ecx
  _DWORD *v27; // ebp
  _DWORD *v28; // ebp
  unsigned int v29; // edx
  unsigned int v30; // edi
  _DWORD *v31; // eax
  int v32; // edx
  int v33; // edx
  int v34; // edi
  int v35; // edx
  _DWORD *v36; // ebp
  unsigned int v37; // eax
  int v38; // edx
  bool v41; // zf
  _DWORD *v42; // eax
  int v43; // edx
  unsigned int v44; // edx
  int v45; // edi
  int v46; // ebp
  unsigned int v47; // edx
  const char *v48; // edi
  int v49; // ecx
  bool v51; // zf
  unsigned int v52; // eax
  unsigned int v53; // eax
  int v54; // edx
  int v55; // edx
  int v56; // edx
  unsigned int v57; // [esp+28h] [ebp-44h]
  unsigned int v58; // [esp+28h] [ebp-44h]
  int v59; // [esp+2Ch] [ebp-40h]
  _DWORD *v60; // [esp+2Ch] [ebp-40h]
  int v61; // [esp+30h] [ebp-3Ch]
  unsigned int v62; // [esp+34h] [ebp-38h]
  int v64; // [esp+3Ch] [ebp-30h]
  unsigned int v65; // [esp+40h] [ebp-2Ch]
  int v67; // [esp+48h] [ebp-24h]
  int v68; // [esp+4Ch] [ebp-20h]

  _EBX = (int *)a2;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v4 & 0xFFFFFFF8;
  if ( a2 > -(v4 & 0xFFFFFFF8) || (a2 & 7) != 0 )
  {
    v48 = "free(): invalid pointer";
    goto LABEL_99;
  }
  if ( v5 <= 0xF )
  {
    v48 = "free(): invalid size";
    goto LABEL_99;
  }
  if ( v5 <= global_max_fast )
  {
    v6 = a2 + v5;
    v7 = *(int *)((char *)_EBX + v5 + 4);
    if ( v7 > 8 && (v7 & 0xFFFFFFF8) < *(_DWORD *)(a1 + 1096) )
      goto LABEL_7;
    v48 = "free(): invalid next size (fast)";
    if ( a3 )
      goto LABEL_99;
    _ECX = 1;
    _EBP = a1;
    v51 = __readgsdword(0xCu) == 0;
    if ( !v51 )
      __asm { lock }
    __asm { cmpxchg [ebp+0], ecx }
    if ( !v51 )
    {
      L_lock_3877(0, (volatile __int32 *)a1);
      return;
    }
    v52 = *(_DWORD *)(v6 + 4);
    if ( v52 > 8 && (v52 & 0xFFFFFFF8) < *(_DWORD *)(a1 + 1096) )
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v41 = (*(_DWORD *)a1)-- == 1;
      if ( !v41 )
      {
        L_unlock_3891((_DWORD *)a1);
        return;
      }
LABEL_7:
      if ( perturb_byte )
        memset(_EBX + 2, (unsigned __int8)perturb_byte, v5 - 8);
      if ( __readgsdword(0xCu) )
        __asm { lock }
      *(_DWORD *)(a1 + 4) &= ~1u;
      v8 = (v5 >> 3) - 2;
      v9 = *(int **)(a1 + 4 * v8 + 8);
      _ECX = a1 + 4 * v8 + 8;
      if ( _EBX == v9 )
      {
        v48 = "double free or corruption (fasttop)";
      }
      else
      {
        v11 = -1;
        if ( v9 )
          v11 = ((unsigned int)v9[1] >> 3) - 2;
        _EBX[2] = (int)v9;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        __asm { cmpxchg [ecx], ebx }
        if ( !v9 || v8 == v11 )
          return;
        v48 = "invalid fastbin entry (free)";
      }
LABEL_99:
      malloc_printerr(_EBX + 2, v48);
      return;
    }
LABEL_119:
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v41 = (*(_DWORD *)a1)-- == 1;
    if ( !v41 )
    {
      L_unlock_3935(_ECX, (_DWORD *)a1);
      return;
    }
    goto LABEL_99;
  }
  if ( (v4 & 2) != 0 )
  {
    munmap_chunk();
    return;
  }
  v67 = 0;
  if ( !a3 )
  {
    _ECX = 1;
    _EDX = a1;
    v41 = __readgsdword(0xCu) == 0;
    if ( !v41 )
      __asm { lock }
    __asm { cmpxchg [edx], ecx }
    if ( !v41 )
    {
      L_lock_3402(0, (volatile __int32 *)a1);
      return;
    }
    v67 = 1;
  }
  _ECX = a1;
  v13 = *(int **)(a1 + 48);
  if ( _EBX == v13 )
  {
    v48 = "double free or corruption (top)";
    goto LABEL_117;
  }
  v14 = (int *)((char *)_EBX + v5);
  if ( (*(_BYTE *)(a1 + 4) & 2) == 0 && v14 >= (int *)((char *)v13 + (v13[1] & 0xFFFFFFF8)) )
  {
    v48 = "double free or corruption (out)";
    goto LABEL_117;
  }
  v15 = v14[1];
  if ( (v15 & 1) == 0 )
  {
    v48 = "double free or corruption (!prev)";
    goto LABEL_117;
  }
  if ( v15 <= 8 || (v16 = v15 & 0xFFFFFFF8, v16 >= *(_DWORD *)(a1 + 1096)) )
  {
    v48 = "free(): invalid next size (normal)";
LABEL_117:
    if ( !v67 || a3 )
      goto LABEL_99;
    goto LABEL_119;
  }
  if ( perturb_byte )
    memset(_EBX + 2, (unsigned __int8)perturb_byte, v5 - 8);
  if ( (_EBX[1] & 1) == 0 )
  {
    v17 = *_EBX;
    _EBX = (int *)((char *)_EBX - *_EBX);
    v5 += v17;
    v18 = (_DWORD *)_EBX[2];
    v19 = _EBX[3];
    if ( _EBX == (int *)v18[3] && _EBX == *(int **)(v19 + 8) )
    {
      v20 = (unsigned int)_EBX[1] <= 0x1FF;
      v18[3] = v19;
      *(_DWORD *)(v19 + 8) = v18;
      if ( !v20 )
      {
        _ECX = _EBX[4];
        if ( _ECX )
        {
          if ( *(int **)(_ECX + 20) != _EBX )
            _malloc_assert("_int_free");
          v56 = _EBX[5];
          if ( _EBX != *(int **)(v56 + 16) )
            _malloc_assert("_int_free");
          if ( v18[4] )
          {
            *(_DWORD *)(_ECX + 20) = v56;
            *(_DWORD *)(_EBX[5] + 16) = _ECX;
          }
          else if ( (int *)_ECX == _EBX )
          {
            v18[5] = v18;
            v18[4] = v18;
          }
          else
          {
            v18[5] = v56;
            v18[4] = _ECX;
            *(_DWORD *)(_EBX[4] + 20) = v18;
            *(_DWORD *)(_EBX[5] + 16) = v18;
          }
        }
      }
    }
    else
    {
      malloc_printerr(_EBX, "corrupted double-linked list");
    }
  }
  if ( *(_DWORD **)(a1 + 48) == v14 )
  {
    v5 += v16;
    _EBX[1] = v5 | 1;
    *(_DWORD *)(a1 + 48) = _EBX;
    goto LABEL_40;
  }
  if ( (*((_BYTE *)v14 + v16 + 4) & 1) != 0 )
  {
    v14[1] &= ~1u;
  }
  else
  {
    v42 = (_DWORD *)v14[2];
    v43 = v14[3];
    if ( v14 == (_DWORD *)v42[3] && v14 == *(_DWORD **)(v43 + 8) )
    {
      v20 = v14[1] <= 0x1FFu;
      v42[3] = v43;
      *(_DWORD *)(v43 + 8) = v42;
      if ( !v20 && (_ECX = v14[4]) != 0 )
      {
        v60 = *(_DWORD **)(_ECX + 20);
        if ( v60 != v14 )
          _malloc_assert("_int_free");
        v55 = v14[5];
        if ( v14 != *(_DWORD **)(v55 + 16) )
          _malloc_assert("_int_free");
        if ( v42[4] )
        {
          *(_DWORD *)(_ECX + 20) = v55;
          v5 += v16;
          *(_DWORD *)(v14[5] + 16) = _ECX;
        }
        else if ( (_DWORD *)_ECX == v14 )
        {
          v42[5] = v42;
          v5 += v16;
          v42[4] = v42;
        }
        else
        {
          v42[4] = _ECX;
          _ECX = (int)v60;
          v5 += v16;
          v42[5] = v55;
          *(_DWORD *)(v60[4] + 20) = v42;
          *(_DWORD *)(v60[5] + 16) = v42;
        }
      }
      else
      {
        v5 += v16;
      }
    }
    else
    {
      v5 += v16;
      malloc_printerr(v14, "corrupted double-linked list");
    }
  }
  v21 = *(_DWORD *)(a1 + 56);
  if ( a1 + 48 != *(_DWORD *)(v21 + 12) )
  {
    v48 = "free(): corrupted unsorted chunks";
    goto LABEL_117;
  }
  _EBX[2] = v21;
  _EBX[3] = a1 + 48;
  if ( v5 > 0x1FF )
  {
    _EBX[4] = 0;
    _EBX[5] = 0;
  }
  *(_DWORD *)(v21 + 12) = _EBX;
  _EBX[1] = v5 | 1;
  *(_DWORD *)(a1 + 56) = _EBX;
  *(int *)((char *)_EBX + v5) = v5;
LABEL_40:
  if ( v5 <= 0xFFFF )
    goto LABEL_81;
  if ( (*(_BYTE *)(a1 + 4) & 1) == 0 )
    malloc_consolidate((int *)a1);
  if ( (int *)a1 == &main_arena )
  {
    if ( (*(_DWORD *)(dword_80EF0D0 + 4) & 0xFFFFFFF8) >= mp_ )
      sYSTRIm_isra_1(dword_80EF504, &dword_80EF0D0, &dword_80EF4E8);
    goto LABEL_81;
  }
  v22 = *(_DWORD *)(a1 + 48);
  v23 = v22 & 0xFFF00000;
  v59 = *(_DWORD *)(v22 & 0xFFF00000);
  if ( v59 != a1 )
    _malloc_assert("_int_free");
  v24 = v23 + 16;
  v68 = dword_80EF504;
  v64 = dl_pagesize;
  if ( v23 + 16 == v22 )
  {
    v25 = *(_DWORD **)((*(_DWORD *)(a1 + 48) & 0xFFF00000) + 4);
    v26 = v25[2];
    v27 = (_DWORD *)((char *)v25 + v26 - 8);
    if ( v27[1] != 1 )
LABEL_94:
      _malloc_assert("heap_trim");
    v28 = (_DWORD *)((char *)v27 - *v27);
    v61 = v28[1];
    v29 = v61 & 0xFFFFFFF8;
    if ( (v61 & 0xFFFFFFF8) + 7 > 0x1E )
LABEL_97:
      _malloc_assert("heap_trim");
    v62 = v29 + 8;
    v65 = dword_80EF504 + dl_pagesize + 16;
    v30 = v29 + 8;
    while ( 1 )
    {
      if ( (v61 & 1) == 0 )
        v30 = *v28 + v62;
      if ( v30 - 1 > 0xFFFFE )
        _malloc_assert("heap_trim");
      if ( v30 - v26 + 0x100000 < v65 )
        break;
      v38 = *(_DWORD *)(v23 + 8);
      arena_mem -= v38;
      *(_DWORD *)(v59 + 1096) -= v38;
      if ( aligned_heap_area == v23 + 0x100000 )
        aligned_heap_area = 0;
      v24 = (unsigned int)v28;
      munmap(v23, 0x100000);
      if ( (v28[1] & 1) == 0 )
      {
        v24 = (unsigned int)v28 - *v28;
        v31 = *(_DWORD **)(v24 + 8);
        v32 = *(_DWORD *)(v24 + 12);
        if ( v24 == v31[3] && v24 == *(_DWORD *)(v32 + 8) )
        {
          v20 = *(_DWORD *)(v24 + 4) <= 0x1FFu;
          v31[3] = v32;
          *(_DWORD *)(v32 + 8) = v31;
          if ( !v20 )
          {
            v33 = *(_DWORD *)(v24 + 16);
            if ( v33 )
            {
              if ( v24 != *(_DWORD *)(v33 + 20) )
                _malloc_assert("heap_trim");
              v49 = *(_DWORD *)(v24 + 20);
              if ( v24 != *(_DWORD *)(v49 + 16) )
                _malloc_assert("heap_trim");
              if ( v31[4] )
              {
                *(_DWORD *)(v33 + 20) = v49;
                *(_DWORD *)(*(_DWORD *)(v24 + 20) + 16) = v33;
              }
              else if ( v24 == v33 )
              {
                v31[5] = v31;
                v31[4] = v31;
              }
              else
              {
                v31[4] = v33;
                v54 = *(_DWORD *)(v24 + 16);
                v31[5] = v49;
                *(_DWORD *)(v54 + 20) = v31;
                *(_DWORD *)(*(_DWORD *)(v24 + 20) + 16) = v31;
              }
            }
          }
        }
        else
        {
          malloc_printerr(v24, "corrupted double-linked list");
        }
      }
      if ( ((v64 - 1) & (v24 + v30)) != 0 )
        _malloc_assert("heap_trim");
      if ( (_DWORD *)(v24 + v30) != (_DWORD *)((char *)v25 + v25[2]) )
        _malloc_assert("heap_trim");
      v34 = v30 | 1;
      *(_DWORD *)(v59 + 48) = v24;
      *(_DWORD *)(v24 + 4) = v34;
      if ( (_DWORD *)v24 != v25 + 4 )
        goto LABEL_76;
      v35 = v25[1];
      v26 = *(_DWORD *)(v35 + 8);
      v36 = (_DWORD *)(v35 + v26 - 8);
      if ( v36[1] != 1 )
        goto LABEL_94;
      v28 = (_DWORD *)((char *)v36 - *v36);
      v37 = v28[1] & 0xFFFFFFF8;
      v61 = v28[1];
      v30 = v37 + 8;
      v62 = v37 + 8;
      if ( v37 + 7 > 0x1E )
        goto LABEL_97;
      v23 = (int)v25;
      v25 = (_DWORD *)v25[1];
    }
    v34 = *(_DWORD *)(v24 + 4);
    v25 = (_DWORD *)v23;
  }
  else
  {
    v34 = *(_DWORD *)(v22 + 4);
    v24 = *(_DWORD *)(a1 + 48);
    v25 = (_DWORD *)(v24 & 0xFFF00000);
  }
LABEL_76:
  v44 = v34 & 0xFFFFFFF8;
  v45 = -v64 & ((v34 & 0xFFFFFFF8) - v68 - 17);
  if ( v45 < v64 )
    goto LABEL_81;
  v46 = v25[2] - v45;
  if ( v46 <= 15 )
    goto LABEL_81;
  if ( !_libc_enable_secure )
  {
    v57 = v44;
    madvise((int)v25 + v46, v45);
    v47 = v57;
LABEL_80:
    v25[2] = v46;
    arena_mem -= v45;
    *(_DWORD *)(v59 + 1096) -= v45;
    *(_DWORD *)(v24 + 4) = (v47 - v45) | 1;
    goto LABEL_81;
  }
  v58 = v44;
  v53 = mmap((int)v25 + v46, v45, 0, 50, -1, 0);
  v47 = v58;
  if ( v53 != -1 )
  {
    v25[3] = v46;
    goto LABEL_80;
  }
LABEL_81:
  if ( !a3 )
  {
    if ( !v67 )
      _malloc_assert("_int_free");
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v41 = (*(_DWORD *)a1)-- == 1;
    if ( !v41 )
      L_unlock_3551(0, (_DWORD *)a1);
  }
}
// 804B920: variable '_ECX' is possibly undefined
// 804A220: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 804AB70: using guessed type int __fastcall malloc_printerr(_DWORD, _DWORD);
// 804B180: using guessed type int munmap_chunk(void);
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80EF0A0: using guessed type int main_arena;
// 80EF0D0: using guessed type int dword_80EF0D0;
// 80EF4E8: using guessed type int dword_80EF4E8;
// 80EF500: using guessed type int mp_;
// 80EF504: using guessed type int dword_80EF504;
// 80EF5B8: using guessed type int dl_pagesize;
// 80F055C: using guessed type int global_max_fast;
// 80F0560: using guessed type int perturb_byte;
// 80F0564: using guessed type int arena_mem;
// 80F0568: using guessed type int aligned_heap_area;

//----- (0804BBB0) --------------------------------------------------------
void *__usercall int_malloc@<eax>(int *a1@<eax>, size_t a2@<edx>, long double a3@<st0>)
{
  unsigned int v4; // edx
  int v5; // eax
  _DWORD *i; // ebp
  char v9; // al
  void *s; // ebx
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  _DWORD *v16; // eax
  bool v17; // zf
  unsigned int v18; // ebx
  unsigned int v19; // ebp
  int v20; // edi
  unsigned int v21; // ebp
  int v22; // edi
  unsigned int v23; // eax
  _DWORD *v24; // edi
  unsigned int v25; // ebp
  int v26; // ebp
  unsigned int v27; // edx
  int v28; // edx
  int v29; // eax
  unsigned int v30; // ebp
  _DWORD *v31; // ebx
  unsigned int v32; // eax
  int v33; // edx
  unsigned int v34; // edi
  unsigned int v35; // ebx
  int v36; // ebp
  int v37; // eax
  unsigned int v38; // edi
  int v39; // edi
  int v40; // eax
  int v41; // edx
  unsigned int v42; // ebx
  _DWORD *v43; // eax
  int v44; // edx
  bool v45; // cc
  int v46; // ecx
  unsigned int v47; // ecx
  unsigned int v48; // ebx
  unsigned int v49; // edi
  _DWORD *v50; // eax
  int v51; // ecx
  _DWORD *v52; // edx
  int v53; // ebx
  int v54; // ecx
  int v55; // edx
  _DWORD *v56; // eax
  int v57; // edx
  unsigned int v58; // ebx
  unsigned int v59; // ecx
  unsigned int v60; // edx
  unsigned int v61; // eax
  unsigned int v62; // ebp
  int v63; // eax
  unsigned int v64; // eax
  unsigned int v65; // eax
  unsigned int v66; // ecx
  void *v67; // ebp
  unsigned int v68; // eax
  int **v69; // eax
  int **v70; // edx
  int *v71; // ecx
  int v72; // eax
  unsigned int v73; // ecx
  unsigned int v74; // edi
  unsigned int *v75; // edx
  int v76; // edx
  int v77; // eax
  int v78; // edx
  unsigned int v79; // ecx
  int v80; // eax
  int v81; // eax
  unsigned int v82; // ecx
  unsigned int v83; // edx
  const char *v84; // edx
  int v85; // edx
  unsigned int v86; // eax
  int v87; // eax
  unsigned int v88; // ebx
  int v89; // eax
  int v90; // ecx
  int v91; // ecx
  int v92; // edx
  unsigned int v93; // ecx
  int v94; // eax
  unsigned int v95; // edi
  int v96; // edx
  unsigned int v97; // eax
  unsigned int v98; // [esp+2Ch] [ebp-70h]
  int v99; // [esp+2Ch] [ebp-70h]
  int v100; // [esp+2Ch] [ebp-70h]
  unsigned int v101; // [esp+30h] [ebp-6Ch]
  int v102; // [esp+30h] [ebp-6Ch]
  int v103; // [esp+30h] [ebp-6Ch]
  int v104; // [esp+30h] [ebp-6Ch]
  int v105; // [esp+34h] [ebp-68h]
  int v106; // [esp+34h] [ebp-68h]
  unsigned int v107; // [esp+38h] [ebp-64h]
  int *v108; // [esp+3Ch] [ebp-60h]
  int v109; // [esp+3Ch] [ebp-60h]
  unsigned int v110; // [esp+40h] [ebp-5Ch]
  unsigned int v111; // [esp+40h] [ebp-5Ch]
  int v112; // [esp+40h] [ebp-5Ch]
  unsigned int v113; // [esp+40h] [ebp-5Ch]
  int *v114; // [esp+44h] [ebp-58h]
  char v115; // [esp+44h] [ebp-58h]
  int v116; // [esp+44h] [ebp-58h]
  int v118; // [esp+4Ch] [ebp-50h]
  int v119; // [esp+4Ch] [ebp-50h]
  unsigned int v120; // [esp+54h] [ebp-48h]
  char v121; // [esp+58h] [ebp-44h]

  if ( a2 > 0xFFFFFFDF )
    goto LABEL_99;
  v4 = (a2 + 11) & 0xFFFFFFF8;
  if ( a2 + 11 < 0x10 )
    v4 = 16;
  v107 = v4;
  if ( v4 <= global_max_fast )
  {
    v5 = (v4 >> 3) - 2;
    i = (_DWORD *)a1[v5 + 2];
    if ( i )
    {
      _ECX = &a1[v5];
      _EBX = i[2];
      if ( __readgsdword(0xCu) )
        __asm { lock }
      __asm { cmpxchg [ecx+8], ebx }
      if ( (v4 >> 3) - 2 == (i[1] >> 3) - 2 )
        goto LABEL_9;
      v84 = "malloc(): memory corruption (fast)";
      goto LABEL_183;
    }
  }
  if ( v4 <= 0x1FF )
  {
    v12 = (int)&a1[2 * (v4 >> 3) + 10];
    i = (_DWORD *)a1[2 * (v4 >> 3) + 13];
    v118 = v4 >> 3;
    if ( i == (_DWORD *)v12 )
      goto LABEL_22;
    if ( i )
    {
      v13 = i[3];
      if ( i != *(_DWORD **)(v13 + 8) )
      {
        v84 = "malloc(): smallbin double linked list corrupted";
        goto LABEL_183;
      }
      a1[2 * (v107 >> 3) + 13] = v13;
      *(_DWORD *)(v13 + 8) = v12;
      *(_DWORD *)((char *)i + v107 + 4) |= 1u;
      if ( a1 == &main_arena )
        goto LABEL_9;
      goto LABEL_16;
    }
    goto LABEL_21;
  }
  if ( v4 >> 6 <= 0x26 )
  {
    v118 = (v4 >> 6) + 56;
  }
  else if ( v4 >> 9 > 0x14 )
  {
    if ( v4 >> 12 <= 0xA )
    {
      v118 = (v4 >> 12) + 110;
    }
    else if ( v4 >> 15 > 4 )
    {
      v57 = (v4 >> 18) + 124;
      if ( v107 >> 18 > 2 )
        v57 = 126;
      v118 = v57;
    }
    else
    {
      v118 = (v4 >> 15) + 119;
    }
  }
  else
  {
    v118 = (v4 >> 9) + 91;
  }
  if ( (a1[1] & 1) == 0 )
LABEL_21:
    malloc_consolidate(a1);
LABEL_22:
  v108 = a1 + 12;
  v120 = v107 + 16;
  v114 = a1 + 14;
LABEL_23:
  v105 = 10000;
  while ( 1 )
  {
    v18 = a1[15];
    if ( (int *)v18 == v108 )
    {
LABEL_58:
      if ( v107 > 0x1FF )
      {
        v40 = (int)&v114[2 * v118 - 4];
        v41 = *(_DWORD *)(v40 + 8);
        if ( v41 != v40 && v107 <= *(_DWORD *)(v41 + 4) )
        {
          for ( i = *(_DWORD **)(v41 + 20); ; i = (_DWORD *)i[5] )
          {
            v42 = i[1] & 0xFFFFFFF8;
            if ( v107 <= v42 )
              break;
          }
          v17 = *(_DWORD *)(v40 + 12) == (_DWORD)i;
          v43 = (_DWORD *)i[2];
          if ( !v17 && v43[1] == i[1] )
          {
            i = (_DWORD *)i[2];
            v43 = (_DWORD *)v43[2];
          }
          v44 = i[3];
          if ( i == (_DWORD *)v43[3] && i == *(_DWORD **)(v44 + 8) )
          {
            v45 = i[1] <= 0x1FFu;
            v43[3] = v44;
            *(_DWORD *)(v44 + 8) = v43;
            if ( !v45 )
            {
              v46 = i[4];
              if ( v46 )
              {
                if ( *(_DWORD **)(v46 + 20) != i )
                  _malloc_assert("_int_malloc");
                v96 = i[5];
                if ( i != *(_DWORD **)(v96 + 16) )
                  _malloc_assert("_int_malloc");
                if ( v43[4] )
                {
                  *(_DWORD *)(v46 + 20) = v96;
                  *(_DWORD *)(i[5] + 16) = v46;
                }
                else if ( (_DWORD *)v46 == i )
                {
                  v43[5] = v43;
                  v43[4] = v43;
                }
                else
                {
                  v43[5] = v96;
                  v43[4] = v46;
                  *(_DWORD *)(i[4] + 20) = v43;
                  *(_DWORD *)(i[5] + 16) = v43;
                }
              }
            }
          }
          else
          {
            malloc_printerr(check_action, "corrupted double-linked list", (unsigned int)i, a3);
          }
          v47 = v42 - v107;
          if ( v42 - v107 > 0xF )
          {
            v85 = a1[14];
            if ( *(int **)(v85 + 12) == v108 )
            {
              v56 = (_DWORD *)((char *)i + v107);
              v56[3] = v108;
              v56[2] = v85;
              *(_DWORD *)(v85 + 12) = (char *)i + v107;
              a1[14] = (int)i + v107;
              if ( v47 > 0x1FF )
                goto LABEL_117;
              goto LABEL_118;
            }
            v84 = "malloc(): corrupted unsorted chunks";
            goto LABEL_183;
          }
          *(_DWORD *)((char *)i + v42 + 4) |= 1u;
          if ( a1 == &main_arena )
            goto LABEL_9;
          goto LABEL_16;
        }
      }
      v32 = 1 << (v118 + 1);
      v33 = (int)&v114[2 * v118 - 2];
      v34 = (unsigned int)(v118 + 1) >> 5;
      v35 = a1[v34 + 268];
LABEL_60:
      if ( v32 && v32 <= v35 )
      {
LABEL_66:
        if ( (v35 & v32) == 0 )
          goto LABEL_65;
        goto LABEL_67;
      }
      while ( ++v34 <= 3 )
      {
        v35 = a1[v34 + 268];
        if ( v35 )
        {
          v33 = (int)&v114[64 * v34 - 4];
          v32 = 1;
          if ( (v35 & 1) == 0 )
          {
LABEL_65:
            v33 += 8;
            v32 *= 2;
            if ( !v32 )
              _malloc_assert("_int_malloc");
            goto LABEL_66;
          }
LABEL_67:
          i = *(_DWORD **)(v33 + 12);
          if ( i != (_DWORD *)v33 )
          {
            v48 = i[1];
            v49 = v48 & 0xFFFFFFF8;
            if ( v107 > (v48 & 0xFFFFFFF8) )
              _malloc_assert("_int_malloc");
            v50 = (_DWORD *)i[2];
            v51 = i[3];
            v52 = (_DWORD *)v50[3];
            if ( v52 == i && v52 == *(_DWORD **)(v51 + 8) )
            {
              v50[3] = v51;
              *(_DWORD *)(v51 + 8) = v50;
              if ( v48 > 0x1FF )
              {
                v53 = v52[4];
                if ( v53 )
                {
                  if ( v52 != *(_DWORD **)(v53 + 20) )
                    _malloc_assert("_int_malloc");
                  v54 = v52[5];
                  if ( v52 != *(_DWORD **)(v54 + 16) )
                    _malloc_assert("_int_malloc");
                  if ( v50[4] )
                  {
                    *(_DWORD *)(v53 + 20) = v54;
                    *(_DWORD *)(v52[5] + 16) = v53;
                  }
                  else if ( v52 == (_DWORD *)v53 )
                  {
                    v50[5] = v50;
                    v50[4] = v50;
                  }
                  else
                  {
                    v50[5] = v54;
                    v50[4] = v53;
                    *(_DWORD *)(v52[4] + 20) = v50;
                    *(_DWORD *)(v52[5] + 16) = v50;
                  }
                }
              }
            }
            else
            {
              malloc_printerr(check_action, "corrupted double-linked list", (unsigned int)i, a3);
            }
            v47 = v49 - v107;
            if ( v49 - v107 > 0xF )
            {
              v55 = a1[14];
              if ( *(int **)(v55 + 12) == v108 )
              {
                v56 = (_DWORD *)((char *)i + v107);
                v56[3] = v108;
                v56[2] = v55;
                *(_DWORD *)(v55 + 12) = (char *)i + v107;
                a1[14] = (int)i + v107;
                if ( v107 <= 0x1FF )
                  a1[13] = (int)v56;
                if ( v47 > 0x1FF )
                {
LABEL_117:
                  v56[4] = 0;
                  v56[5] = 0;
                }
LABEL_118:
                i[1] = (4 * (a1 != &main_arena)) | v107 | 1;
                v56[1] = v47 | 1;
                *(_DWORD *)((char *)v56 + v47) = v47;
LABEL_9:
                v9 = perturb_byte;
                s = i + 2;
                if ( perturb_byte )
                  goto LABEL_55;
                return s;
              }
              v84 = "malloc(): corrupted unsorted chunks 2";
LABEL_183:
              s = 0;
              malloc_printerr(check_action, v84, (unsigned int)(i + 2), a3);
              return s;
            }
            *(_DWORD *)((char *)i + v49 + 4) |= 1u;
            if ( a1 == &main_arena )
              goto LABEL_9;
LABEL_16:
            i[1] |= 4u;
            goto LABEL_9;
          }
          v33 += 8;
          v36 = ~v32;
          v32 *= 2;
          v35 &= v36;
          a1[v34 + 268] = v35;
          goto LABEL_60;
        }
      }
      v18 = a1[12];
      v37 = *(_DWORD *)(v18 + 4);
      v38 = v37 & 0xFFFFFFF8;
      if ( (v37 & 0xFFFFFFF8) >= v120 )
      {
        a1[12] = v18 + v107;
        *(_DWORD *)(v18 + 4) = (4 * (a1 != &main_arena)) | v107 | 1;
        *(_DWORD *)(v18 + v107 + 4) = (v38 - v107) | 1;
LABEL_81:
        v9 = perturb_byte;
        s = (void *)(v18 + 8);
        if ( perturb_byte )
          goto LABEL_55;
        return s;
      }
      if ( (a1[1] & 1) != 0 )
      {
        v115 = 0;
        v119 = dl_pagesize;
        v106 = dl_pagesize - 1;
        if ( v107 < dword_80EF508 || dword_80EF514 >= dword_80EF518 )
          goto LABEL_133;
        while ( 1 )
        {
          v58 = ~v106 & (v107 + v119 + 3);
          if ( v107 < v58 )
          {
            v86 = mmap(0, ~v106 & (v107 + v119 + 3), 3, 34, -1, 0);
            if ( v86 != -1 )
            {
              v67 = (void *)(v86 + 8);
              if ( ((v86 + 8) & 7) != 0 )
                _malloc_assert("sYSMALLOc");
              *(_DWORD *)(v86 + 4) = v58 | 2;
              v87 = ++dword_80EF514;
              if ( dword_80EF514 > dword_80EF51C )
                dword_80EF51C = v87;
              v88 = dword_80EF524 + v58;
              dword_80EF524 = v88;
              if ( v88 > dword_80EF528 )
                dword_80EF528 = v88;
              goto LABEL_149;
            }
          }
          v18 = a1[12];
          v37 = *(_DWORD *)(v18 + 4);
          v115 = 1;
          v38 = v37 & 0xFFFFFFF8;
LABEL_133:
          v111 = v18 + v38;
          if ( v38 || v108 != (int *)v18 )
          {
            if ( v38 <= 0xF || (v37 & 1) == 0 || (v106 & v111) != 0 )
              _malloc_assert("sYSMALLOc");
            if ( v120 <= v38 )
              _malloc_assert("sYSMALLOc");
          }
          if ( a1 == &main_arena )
            break;
          v59 = v18 & 0xFFF00000;
          v112 = *(_DWORD *)((v18 & 0xFFF00000) + 8);
          if ( (int)(v120 - v38) > 0 )
          {
            v60 = v112 + (~(dl_pagesize - 1) & (dl_pagesize - 1 + v120 - v38));
            if ( v60 <= 0x100000 )
            {
              v61 = *(_DWORD *)((v18 & 0xFFF00000) + 0xC);
              v62 = v18;
              if ( v60 <= v61 )
                goto LABEL_144;
              v101 = v112 + (~(dl_pagesize - 1) & (dl_pagesize - 1 + v120 - v38));
              v68 = mprotect(v59 + v61, v60 - v61);
              v60 = v101;
              v59 = v18 & 0xFFF00000;
              if ( !v68 )
              {
                *(_DWORD *)((v18 & 0xFFF00000) + 0xC) = v101;
                v62 = a1[12];
LABEL_144:
                v63 = a1[274];
                *(_DWORD *)(v59 + 8) = v60;
                arena_mem += v60 - v112;
                v64 = v60 - v112 + v63;
                a1[274] = v64;
                *(_DWORD *)(v18 + 4) = (v59 + v60 - v18) | 1;
LABEL_145:
                if ( v64 > a1[275] )
                  a1[275] = v64;
                v65 = *(_DWORD *)(v62 + 4) & 0xFFFFFFF8;
                if ( v120 <= v65 )
                {
                  v66 = v62 + v107;
                  a1[12] = v62 + v107;
                  *(_DWORD *)(v62 + 4) = (4 * (a1 != &main_arena)) | v107 | 1;
                  v67 = (void *)(v62 + 8);
                  *(_DWORD *)(v66 + 4) = (v65 - v107) | 1;
LABEL_149:
                  s = 0;
                  if ( v67 )
                  {
                    s = v67;
                    if ( perturb_byte )
                      memset(v67, (unsigned __int8)~(_BYTE)perturb_byte, a2);
                  }
                  return s;
                }
LABEL_99:
                __writegsdword(0xFFFFFFE8, 0xCu);
                return 0;
              }
            }
          }
          v98 = v59;
          v69 = (int **)new_heap(v107 + 32, dword_80EF504);
          v70 = v69;
          if ( v69 )
          {
            v69[1] = (int *)v98;
            v71 = v69[2];
            v62 = (unsigned int)(v69 + 4);
            *v69 = a1;
            v72 = a1[274];
            arena_mem += (int)v71;
            a1[12] = (int)(v70 + 4);
            v64 = (unsigned int)v71 + v72;
            a1[274] = v64;
            v70[5] = (int *)((unsigned int)(v71 - 4) | 1);
            v73 = v38 - 16;
            v74 = v38 - 8;
            v75 = (unsigned int *)(v18 + v74);
            *(_DWORD *)(v18 + v74 + 4) = 1;
            if ( v73 > 0xF )
            {
              *(_DWORD *)(v18 + v73 + 4) = 9;
              *v75 = 8;
              *(_DWORD *)(v18 + 4) = v73 | 5;
              int_free((int)a1, v18, 1);
              v64 = a1[274];
              v62 = a1[12];
            }
            else
            {
              *(_DWORD *)(v18 + 4) = v74 | 1;
              *v75 = v74;
            }
            goto LABEL_145;
          }
          if ( v115 )
          {
            v64 = a1[274];
            v62 = a1[12];
            goto LABEL_145;
          }
        }
        v76 = v107 + dword_80EF504 + 16;
        v77 = dword_80EF0A4 & 2;
        if ( (dword_80EF0A4 & 2) == 0 )
          v76 = v107 + dword_80EF504 + 16 - v38;
        v78 = ~v106 & (v106 + v76);
        v109 = ~v106;
        v79 = v78;
        if ( v78 <= 0
          || (v102 = v78,
              v99 = v78,
              v80 = _morecore(v78),
              v78 = v102,
              v79 = v99,
              v62 = v80,
              v77 = dword_80EF0A4 & 2,
              !v62) )
        {
          if ( !v77 )
            v79 = v109 & (v78 + v38 + v106);
          v83 = 0x100000;
          if ( v79 > 0xFFFFF )
            v83 = v79;
          if ( v107 < v83 )
          {
            v104 = v83;
            v97 = mmap(0, v83, 3, 34, -1, 0);
            v78 = v104;
            v62 = v97;
            if ( v97 != -1 )
            {
              dword_80EF0A4 |= 2u;
              if ( v97 )
              {
                v17 = v104 + v97 == 0;
                v81 = v104 + v97;
                v121 = v17;
                goto LABEL_168;
              }
            }
          }
          goto LABEL_178;
        }
        if ( _after_morecore_hook )
        {
          _after_morecore_hook(v99);
          v78 = v102;
        }
        v121 = 1;
        v81 = 0;
LABEL_168:
        if ( !dword_80EF530 )
          dword_80EF530 = v62;
        v82 = v78 + dword_80EF4E8;
        v116 = v78 + dword_80EF4E8;
        dword_80EF4E8 += v78;
        if ( v111 == v62 && v121 )
        {
          v64 = v82;
          v62 = dword_80EF0D0;
          *(_DWORD *)(v18 + 4) = (v38 + v78) | 1;
          goto LABEL_145;
        }
        if ( v38 )
        {
          if ( (dword_80EF0A4 & 2) == 0 )
          {
            if ( v111 > v62 )
            {
              malloc_printerr(3, "break adjusted to free malloc space", v62, a3);
              v64 = dword_80EF4E8;
              v62 = dword_80EF0D0;
              goto LABEL_145;
            }
            dword_80EF4E8 = v116 + v62 - v111;
LABEL_202:
            v89 = 0;
            v113 = v62;
            if ( (v62 & 7) != 0 )
            {
              LOBYTE(v89) = 8;
              v89 -= v62 & 7;
              v113 = v62 + v89;
            }
            v90 = (v109 & (v106 + v62 + v38 + v89 + v78)) - (v62 + v78);
            if ( v90 < 0 )
              _malloc_assert("sYSMALLOc");
            v100 = (v109 & (v106 + v62 + v38 + v89 + v78)) - (v62 + v78);
            v81 = _morecore(v90);
            v91 = v100;
            if ( v81 )
            {
              if ( _after_morecore_hook )
              {
                v103 = v81;
                _after_morecore_hook(v100);
                v81 = v103;
                v91 = v100;
              }
              v62 = v113;
              v92 = v91;
LABEL_209:
              v93 = v81 - v62 + v91;
              v94 = dword_80EF4E8;
              dword_80EF0D0 = v62;
              *(_DWORD *)(v62 + 4) = v93 | 1;
              v64 = v92 + v94;
              dword_80EF4E8 = v64;
              if ( !v38 )
                goto LABEL_145;
              v95 = v38 - 16;
              *(_DWORD *)(v18 + 4) = v95 | 1;
              *(_DWORD *)(v18 + v95 + 4) = 9;
              *(_DWORD *)(v18 + v95 + 12) = 9;
              if ( v95 <= 0xF )
                goto LABEL_145;
              int_free((int)&main_arena, v18, 1);
LABEL_178:
              v64 = dword_80EF4E8;
              v62 = dword_80EF0D0;
              goto LABEL_145;
            }
            v81 = _morecore(0);
            v62 = v113;
LABEL_213:
            v92 = 0;
            v91 = 0;
            if ( v81 )
              goto LABEL_209;
            goto LABEL_178;
          }
        }
        else if ( (dword_80EF0A4 & 2) == 0 )
        {
          goto LABEL_202;
        }
        if ( (v62 & 7) != 0 )
          _malloc_assert("sYSMALLOc");
        if ( v121 )
          v81 = _morecore(0);
        goto LABEL_213;
      }
      malloc_consolidate(a1);
      v118 = v107 >> 3;
      if ( v107 > 0x1FF )
      {
        v118 = (v107 >> 6) + 56;
        if ( v107 >> 6 > 0x26 )
        {
          v118 = (v107 >> 9) + 91;
          if ( v107 >> 9 > 0x14 )
          {
            v118 = (v107 >> 12) + 110;
            if ( v107 >> 12 > 0xA )
            {
              v118 = (v107 >> 15) + 119;
              if ( v107 >> 15 > 4 )
              {
                v39 = 126;
                if ( v107 >> 18 < 3 )
                  v39 = (v107 >> 18) + 124;
                v118 = v39;
              }
            }
          }
        }
      }
      goto LABEL_23;
    }
    v19 = *(_DWORD *)(v18 + 4);
    v20 = *(_DWORD *)(v18 + 12);
    if ( v19 <= 8 || v19 > a1[274] )
    {
      malloc_printerr(check_action, "malloc(): memory corruption", v18 + 8, a3);
      v19 = *(_DWORD *)(v18 + 4);
    }
    v21 = v19 & 0xFFFFFFF8;
    if ( v107 <= 0x1FF && v108 == (int *)v20 )
    {
      v29 = a1[13];
      if ( v29 == v18 && v21 > v120 )
        break;
    }
    a1[15] = v20;
    *(_DWORD *)(v20 + 8) = v108;
    if ( v107 == v21 )
    {
      *(_DWORD *)(v18 + v107 + 4) |= 1u;
      if ( a1 != &main_arena )
        *(_DWORD *)(v18 + 4) |= 4u;
      goto LABEL_81;
    }
    if ( v21 <= 0x1FF )
    {
      v14 = v21 >> 3;
      v15 = (int)&v114[2 * (v21 >> 3) - 4];
      v16 = *(_DWORD **)(v15 + 8);
    }
    else
    {
      v14 = (v21 >> 6) + 56;
      v22 = 8 * (v21 >> 6) + 432;
      if ( v21 >> 6 > 0x26 )
      {
        v14 = (v21 >> 9) + 91;
        v22 = 8 * (v21 >> 9) + 712;
        if ( v21 >> 9 > 0x14 )
        {
          v14 = (v21 >> 12) + 110;
          v22 = 8 * (v21 >> 12) + 864;
          if ( v21 >> 12 > 0xA )
          {
            v14 = (v21 >> 15) + 119;
            v22 = 8 * (v21 >> 15) + 936;
            if ( v21 >> 15 > 4 )
            {
              v22 = 992;
              v23 = v21 >> 18;
              v14 = 126;
              if ( v21 >> 18 <= 2 )
              {
                v14 = v23 + 124;
                v22 = 8 * v23 + 976;
              }
            }
          }
        }
      }
      v24 = (int *)((char *)v114 + v22);
      v16 = (_DWORD *)v24[2];
      if ( v16 == v24 )
      {
        *(_DWORD *)(v18 + 20) = v18;
        v15 = (int)v16;
        *(_DWORD *)(v18 + 16) = v18;
      }
      else
      {
        v15 = v24[3];
        v110 = *(_DWORD *)(v15 + 4);
        if ( (v110 & 4) != 0 )
          _malloc_assert("_int_malloc");
        v25 = v21 | 1;
        if ( v25 >= v110 )
        {
          v27 = v16[1];
          if ( (v27 & 4) != 0 )
            _malloc_assert("_int_malloc");
          while ( v27 > v25 )
          {
            v16 = (_DWORD *)v16[4];
            v27 = v16[1];
            if ( (v27 & 4) != 0 )
              _malloc_assert("_int_malloc");
          }
          if ( v25 == v27 )
          {
            v16 = (_DWORD *)v16[2];
          }
          else
          {
            v28 = v16[5];
            *(_DWORD *)(v18 + 16) = v16;
            *(_DWORD *)(v18 + 20) = v28;
            v16[5] = v18;
            *(_DWORD *)(*(_DWORD *)(v18 + 20) + 16) = v18;
          }
          v15 = v16[3];
        }
        else
        {
          v26 = v16[5];
          *(_DWORD *)(v18 + 16) = v16;
          *(_DWORD *)(v18 + 20) = v26;
          *(_DWORD *)(v26 + 16) = v18;
          v16[5] = v18;
          v16 = v24;
        }
      }
    }
    a1[(v14 >> 5) + 268] |= 1 << v14;
    v17 = v105-- == 1;
    *(_DWORD *)(v18 + 12) = v15;
    *(_DWORD *)(v18 + 8) = v16;
    v16[3] = v18;
    *(_DWORD *)(v15 + 8) = v18;
    if ( v17 )
      goto LABEL_58;
  }
  v30 = v21 - v107;
  v31 = (_DWORD *)(v107 + v18);
  a1[13] = (int)v31;
  a1[14] = (int)v31;
  a1[15] = (int)v31;
  v31[2] = v108;
  v31[3] = v108;
  if ( v30 > 0x1FF )
  {
    v31[4] = 0;
    v31[5] = 0;
  }
  *(_DWORD *)((char *)v31 + v30) = v30;
  *(_DWORD *)(v29 + 4) = (4 * (a1 != &main_arena)) | v107 | 1;
  v31[1] = v30 | 1;
  s = (void *)(v29 + 8);
  v9 = perturb_byte;
  if ( perturb_byte )
LABEL_55:
    memset(s, (unsigned __int8)~v9, a2);
  return s;
}
// 804A220: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80EF090: using guessed type int (__cdecl *_morecore)(_DWORD);
// 80EF0A0: using guessed type int main_arena;
// 80EF0A4: using guessed type int dword_80EF0A4;
// 80EF0D0: using guessed type int dword_80EF0D0;
// 80EF4E8: using guessed type int dword_80EF4E8;
// 80EF504: using guessed type int dword_80EF504;
// 80EF508: using guessed type int dword_80EF508;
// 80EF514: using guessed type int dword_80EF514;
// 80EF518: using guessed type int dword_80EF518;
// 80EF51C: using guessed type int dword_80EF51C;
// 80EF524: using guessed type int dword_80EF524;
// 80EF528: using guessed type int dword_80EF528;
// 80EF530: using guessed type int dword_80EF530;
// 80EF534: using guessed type int check_action;
// 80EF5B8: using guessed type int dl_pagesize;
// 80F0548: using guessed type int (__fastcall *_after_morecore_hook)(_DWORD);
// 80F055C: using guessed type int global_max_fast;
// 80F0560: using guessed type int perturb_byte;
// 80F0564: using guessed type int arena_mem;

//----- (0804CC40) --------------------------------------------------------
void __cdecl malloc_check(unsigned int a1)
{
  bool v2; // zf
  int v3; // eax
  int v4; // ecx

  if ( a1 == -1 )
  {
    __writegsdword(0xFFFFFFE8, 0xCu);
  }
  else
  {
    _ECX = 1;
    v2 = __readgsdword(0xCu) == 0;
    if ( !v2 )
      __asm { lock }
    __asm { cmpxchg main_arena, ecx }
    if ( v2 )
    {
      v3 = top_check();
      v4 = 0;
      if ( v3 >= 0 )
        v4 = int_malloc(0, a1 + 1);
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --main_arena )
        L_unlock_7042();
      else
        mem2mem_check(v4, a1);
    }
    else
    {
      L_lock_7025(0);
    }
  }
}
// 804BBB0: using guessed type int __fastcall int_malloc(_DWORD, _DWORD);
// 80EF0A0: using guessed type int main_arena;

//----- (0804CCD0) --------------------------------------------------------
int __usercall int_memalign@<eax>(int *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>)
{
  unsigned int v3; // ebx
  unsigned int v4; // ecx
  unsigned int v5; // edi
  unsigned int v6; // eax
  _DWORD *v7; // esi
  unsigned int v8; // ebp
  unsigned int v9; // edx
  unsigned int v10; // ecx
  int v11; // ecx
  int v12; // eax
  unsigned int v13; // eax
  unsigned int i; // eax
  _DWORD *v16; // [esp+14h] [ebp-28h]
  unsigned int v18; // [esp+1Ch] [ebp-20h]

  v3 = a2;
  if ( a2 > 8 )
  {
    if ( a2 > 0xF )
    {
      if ( (a2 & (a2 - 1)) != 0 && a2 != 16 )
      {
        for ( i = 16; i < a2; i *= 2 )
          ;
        v3 = i;
      }
    }
    else
    {
      v3 = 16;
    }
    if ( a3 > 0xFFFFFFDF )
    {
      v7 = 0;
      __writegsdword(0xFFFFFFE8, 0xCu);
    }
    else
    {
      v4 = a3 + 11;
      v5 = 16;
      if ( v4 >= 0x10 )
        v5 = v4 & 0xFFFFFFF8;
      v6 = int_malloc(v4, v5 + v3 + 16);
      v7 = (_DWORD *)v6;
      if ( !v6 )
        return (int)v7;
      v8 = v6 - 8;
      if ( !(v6 % v3) )
        goto LABEL_17;
      v9 = (-v3 & (v6 + v3 - 1)) - v6;
      v16 = (_DWORD *)((-v3 & (v6 + v3 - 1)) - 8);
      if ( v9 <= 0xF )
      {
        v16 = (_DWORD *)(v3 + (-v3 & (v6 + v3 - 1)) - 8);
        v9 = (unsigned int)v16 - v8;
      }
      v10 = (*(_DWORD *)(v6 - 4) & 0xFFFFFFF8) - v9;
      v18 = v10;
      if ( (*(_DWORD *)(v6 - 4) & 2) == 0 )
      {
        if ( a1 == &main_arena )
        {
          v16[1] = v10 | 1;
          *(_DWORD *)((char *)v16 + v10 + 4) |= 1u;
          v11 = 0;
        }
        else
        {
          v16[1] = v10 | 5;
          *(_DWORD *)((char *)v16 + v10 + 4) |= 1u;
          v11 = 4;
        }
        *(_DWORD *)(v6 - 4) = v9 | v11 | *(_DWORD *)(v6 - 4) & 7;
        int_free((int)a1, v8, 1);
        if ( v5 > v18 || (v7 = v16 + 2, (unsigned int)(v16 + 2) % v3) )
          _malloc_assert("_int_memalign");
        v8 = (unsigned int)v16;
LABEL_17:
        v12 = *(_DWORD *)(v8 + 4);
        if ( (v12 & 2) == 0 )
        {
          v13 = v12 & 0xFFFFFFF8;
          if ( v13 > v5 + 16 )
          {
            *(_DWORD *)(v8 + v5 + 4) = (4 * (a1 != &main_arena)) | (v13 - v5) | 1;
            *(_DWORD *)(v8 + 4) = v5 | *(_DWORD *)(v8 + 4) & 7;
            int_free((int)a1, v8 + v5, 1);
          }
        }
        return (int)v7;
      }
      *v16 = *(_DWORD *)(v6 - 8) + v9;
      v16[1] = v10 | 2;
      return (int)(v16 + 2);
    }
    return (int)v7;
  }
  return int_malloc(a3, a3);
}
// 804A220: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 804BBB0: using guessed type int __fastcall int_malloc(_DWORD, _DWORD);
// 80EF0A0: using guessed type int main_arena;

//----- (0804CF10) --------------------------------------------------------
void __cdecl memalign_check(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // esi
  bool v4; // zf
  int v5; // eax
  int v6; // ecx

  v2 = a1;
  if ( a1 <= 8 )
  {
    malloc_check(a2);
  }
  else
  {
    if ( a1 <= 0xF )
      v2 = 16;
    if ( a2 == -1 )
    {
      __writegsdword(0xFFFFFFE8, 0xCu);
    }
    else
    {
      _ECX = 1;
      v4 = __readgsdword(0xCu) == 0;
      if ( !v4 )
        __asm { lock }
      __asm { cmpxchg main_arena, ecx }
      if ( v4 )
      {
        v5 = top_check();
        v6 = 0;
        if ( v5 >= 0 )
          v6 = int_memalign(&main_arena, v2, a2 + 1);
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --main_arena )
          L_unlock_7433();
        else
          mem2mem_check(v6, a2);
      }
      else
      {
        L_lock_7415(0);
      }
    }
  }
}
// 80EF0A0: using guessed type int main_arena;

//----- (0804CFF0) --------------------------------------------------------
unsigned int __usercall int_realloc@<eax>(int *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, unsigned int a4)
{
  unsigned int v5; // eax
  unsigned int v7; // edx
  _DWORD *v8; // edi
  unsigned int v9; // ebp
  unsigned int v10; // ebp
  int v11; // eax
  int v12; // ebp
  unsigned int v13; // eax
  int v14; // ecx
  int v15; // ecx
  unsigned int v16; // ecx
  int v17; // eax
  unsigned int v18; // edx
  int v19; // edi
  const char *v21; // edx
  unsigned int v22; // [esp+14h] [ebp-28h]
  int v23; // [esp+14h] [ebp-28h]
  unsigned int v25; // [esp+1Ch] [ebp-20h]
  _DWORD *v26; // [esp+1Ch] [ebp-20h]

  v5 = *(_DWORD *)(a2 + 4);
  if ( v5 <= 8 || (v7 = a1[274], v7 <= a3) )
  {
    v21 = "realloc(): invalid old size";
LABEL_41:
    v12 = 0;
    malloc_printerr(a2 + 8, v21);
    return v12;
  }
  if ( (v5 & 2) != 0 )
    _malloc_assert("_int_realloc");
  v8 = (_DWORD *)(a2 + a3);
  v9 = *(_DWORD *)(a2 + a3 + 4);
  v22 = v9;
  if ( v9 <= 8 || (v25 = v9 & 0xFFFFFFF8, v7 <= (v9 & 0xFFFFFFF8)) )
  {
    v21 = "realloc(): invalid next size";
    goto LABEL_41;
  }
  v10 = a3;
  if ( a3 >= a4 )
  {
LABEL_27:
    v16 = v10 - a4;
    if ( v10 - a4 <= 0xF )
    {
      *(_DWORD *)(a2 + 4) = (4 * (a1 != &main_arena)) | v10 | v5 & 7;
      *(_DWORD *)(a2 + v10 + 4) |= 1u;
    }
    else
    {
      v17 = v5 & 7;
      v18 = a2 + a4;
      if ( a1 == &main_arena )
      {
        v19 = 0;
        *(_DWORD *)(a2 + 4) = a4 | v17;
      }
      else
      {
        *(_DWORD *)(a2 + 4) = v17 | a4 | 4;
        v19 = 4;
      }
      *(_DWORD *)(v18 + 4) = v19 | v16 | 1;
      *(_DWORD *)(v18 + v16 + 4) |= 1u;
      int_free((int)a1, v18, 1);
    }
    return a2 + 8;
  }
  if ( (_DWORD *)a1[12] == v8 )
  {
    if ( a3 + v25 >= a4 + 16 )
    {
      *(_DWORD *)(a2 + 4) = (4 * (a1 != &main_arena)) | a4 | v5 & 7;
      v12 = a2 + 8;
      a1[12] = a2 + a4;
      *(_DWORD *)(a2 + a4 + 4) = (a3 + v25 - a4) | 1;
      return v12;
    }
  }
  else if ( (*((_BYTE *)v8 + v25 + 4) & 1) == 0 )
  {
    v10 = v25 + a3;
    if ( a4 <= v25 + a3 )
    {
      v26 = (_DWORD *)v8[2];
      v14 = v8[3];
      if ( v8 == (_DWORD *)v26[3] && v8 == *(_DWORD **)(v14 + 8) )
      {
        v26[3] = v14;
        *(_DWORD *)(v14 + 8) = v26;
        if ( v22 > 0x1FF )
        {
          v15 = v8[4];
          if ( v15 )
          {
            if ( *(_DWORD **)(v15 + 20) != v8 )
              _malloc_assert("_int_realloc");
            v23 = v8[5];
            if ( v8 != *(_DWORD **)(v23 + 16) )
              _malloc_assert("_int_realloc");
            if ( v26[4] )
            {
              *(_DWORD *)(v15 + 20) = v23;
              *(_DWORD *)(v8[5] + 16) = v15;
            }
            else if ( (_DWORD *)v15 == v8 )
            {
              v26[5] = v26;
              v26[4] = v26;
            }
            else
            {
              v26[4] = v15;
              v26[5] = v23;
              *(_DWORD *)(v8[4] + 20) = v26;
              *(_DWORD *)(v8[5] + 16) = v26;
            }
          }
        }
      }
      else
      {
        malloc_printerr(v8, "corrupted double-linked list");
        v5 = *(_DWORD *)(a2 + 4);
      }
      goto LABEL_27;
    }
  }
  v11 = int_malloc(a3, a4 - 7);
  v12 = v11;
  if ( !v11 )
    return v12;
  if ( v8 == (_DWORD *)(v11 - 8) )
  {
    v10 = a3 + (*(_DWORD *)(v11 - 4) & 0xFFFFFFF8);
    if ( a4 > v10 )
      _malloc_assert("_int_realloc");
    v5 = *(_DWORD *)(a2 + 4);
    goto LABEL_27;
  }
  v13 = (a3 - 4) >> 2;
  if ( v13 <= 2 )
    _malloc_assert("_int_realloc");
  if ( v13 > 9 )
  {
    memcpy((_BYTE *)v12, (_BYTE *)(a2 + 8), a3 - 4);
  }
  else
  {
    *(_DWORD *)v12 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(v12 + 4) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(v12 + 8) = *(_DWORD *)(a2 + 16);
    if ( v13 > 4 )
    {
      *(_DWORD *)(v12 + 12) = *(_DWORD *)(a2 + 20);
      *(_DWORD *)(v12 + 16) = *(_DWORD *)(a2 + 24);
      if ( v13 > 6 )
      {
        *(_DWORD *)(v12 + 20) = *(_DWORD *)(a2 + 28);
        *(_DWORD *)(v12 + 24) = *(_DWORD *)(a2 + 32);
        if ( v13 == 9 )
        {
          *(_DWORD *)(v12 + 28) = *(_DWORD *)(a2 + 36);
          *(_DWORD *)(v12 + 32) = *(_DWORD *)(a2 + 40);
        }
      }
    }
  }
  int_free((int)a1, a2, 1);
  return v12;
}
// 804A220: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 804AB70: using guessed type int __fastcall malloc_printerr(_DWORD, _DWORD);
// 804BBB0: using guessed type int __fastcall int_malloc(_DWORD, _DWORD);
// 80EF0A0: using guessed type int main_arena;

//----- (0804D390) --------------------------------------------------------
void __cdecl free_atfork(int a1)
{
  int v1; // ecx
  unsigned int v2; // edx
  int *v3; // eax

  if ( a1 )
  {
    v1 = *(_DWORD *)(a1 - 4);
    v2 = a1 - 8;
    if ( (v1 & 2) != 0 )
    {
      munmap_chunk();
    }
    else
    {
      v3 = &main_arena;
      if ( (v1 & 4) != 0 )
        v3 = *(int **)(v2 & 0xFFF00000);
      int_free((int)v3, v2, __readgsdword(0xFFFFFFEC) == -1);
    }
  }
}
// 804B180: using guessed type int munmap_chunk(void);
// 80EF0A0: using guessed type int main_arena;

//----- (0804D3E0) --------------------------------------------------------
void __cdecl free_check(int a1)
{
  bool v2; // zf
  unsigned int v3; // eax

  if ( a1 )
  {
    _ECX = 1;
    v2 = __readgsdword(0xCu) == 0;
    if ( !v2 )
      __asm { lock }
    __asm { cmpxchg main_arena, ecx }
    if ( v2 )
    {
      v3 = mem2chunk_check(a1, 0);
      if ( v3 )
      {
        if ( (*(_BYTE *)(v3 + 4) & 2) != 0 )
        {
          if ( __readgsdword(0xCu) )
            __asm { lock }
          if ( --main_arena )
            L_unlock_8139();
          else
            munmap_chunk();
        }
        else
        {
          int_free((int)&main_arena, v3, 1);
          if ( __readgsdword(0xCu) )
            __asm { lock }
          if ( --main_arena )
            L_unlock_8121();
        }
      }
      else
      {
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --main_arena )
          L_unlock_8155();
        else
          malloc_printerr(a1, "free(): invalid pointer");
      }
    }
    else
    {
      L_lock_8098(0);
    }
  }
}
// 804AB70: using guessed type int __fastcall malloc_printerr(_DWORD, _DWORD);
// 804B180: using guessed type int munmap_chunk(void);
// 80EF0A0: using guessed type int main_arena;

//----- (0804D4B0) --------------------------------------------------------
void __usercall realloc_check(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, _BYTE *a5, unsigned int a6)
{
  bool v7; // zf
  unsigned int v8; // eax
  unsigned int v9; // esi
  int v10; // eax
  unsigned int v11; // ecx
  bool v13; // zf
  int v14; // eax
  unsigned int v15; // edx
  int v16; // edi
  int *v17; // eax
  int v18; // ecx
  _BYTE *v19; // eax
  unsigned int v20; // [esp+28h] [ebp-34h]
  unsigned int v21; // [esp+2Ch] [ebp-30h]
  int v22[8]; // [esp+3Ch] [ebp-20h] BYREF

  v22[4] = a1;
  v22[5] = a4;
  v22[6] = a3;
  v22[7] = a2;
  if ( a6 == -1 )
    goto LABEL_32;
  if ( !a5 )
  {
LABEL_36:
    malloc_check(a6);
    return;
  }
  if ( !a6 )
  {
    free_check((int)a5);
    return;
  }
  _ECX = 1;
  v7 = __readgsdword(0xCu) == 0;
  if ( !v7 )
    __asm { lock }
  __asm { cmpxchg main_arena, ecx }
  if ( !v7 )
  {
    L_lock_8199(0);
    return;
  }
  v8 = mem2chunk_check((int)a5, v22);
  v9 = v8;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
  {
    L_unlock_8210();
    return;
  }
  if ( !v8 )
  {
    malloc_printerr(a5, "realloc(): invalid pointer");
    goto LABEL_36;
  }
  v10 = *(_DWORD *)(v8 + 4);
  if ( a6 + 1 > 0xFFFFFFDF )
  {
LABEL_32:
    __writegsdword(0xFFFFFFE8, 0xCu);
    return;
  }
  v11 = (a6 + 12) & 0xFFFFFFF8;
  if ( a6 + 12 < 0x10 )
    v11 = 16;
  v20 = v11;
  _ECX = 1;
  v21 = v10 & 0xFFFFFFF8;
  v13 = __readgsdword(0xCu) == 0;
  if ( !v13 )
    __asm { lock }
  __asm { cmpxchg main_arena, ecx }
  if ( !v13 )
  {
    L_lock_8242(0);
    return;
  }
  if ( (*(_BYTE *)(v9 + 4) & 2) != 0 )
  {
    v17 = mremap_chunk((int *)v9, v20);
    v16 = (int)(v17 + 2);
    if ( v17 )
      goto LABEL_22;
    v16 = (int)a5;
    if ( v20 <= v21 - 4 )
      goto LABEL_23;
    if ( top_check() >= 0 )
    {
      v19 = (_BYTE *)int_malloc(v18, a6 + 1);
      v16 = (int)v19;
      if ( v19 )
      {
        memcpy(v19, a5, v21 - 8);
        munmap_chunk();
        goto LABEL_23;
      }
    }
LABEL_33:
    v16 = 0;
    *(_BYTE *)v22[0] = ~*(_BYTE *)v22[0];
    goto LABEL_23;
  }
  v14 = top_check();
  v15 = 16;
  if ( v14 < 0 )
    goto LABEL_33;
  if ( a6 + 12 >= 0x10 )
    v15 = (a6 + 12) & 0xFFFFFFF8;
  v16 = int_realloc(&main_arena, v9, v21, v15);
LABEL_22:
  if ( !v16 )
    goto LABEL_33;
LABEL_23:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
    L_unlock_8280();
  else
    mem2mem_check(v16, a6);
}
// 804D63D: variable 'v18' is possibly undefined
// 804AB70: using guessed type int __fastcall malloc_printerr(_DWORD, _DWORD);
// 804B180: using guessed type int munmap_chunk(void);
// 804BBB0: using guessed type int __fastcall int_malloc(_DWORD, _DWORD);
// 80EF0A0: using guessed type int main_arena;

//----- (0804D6E0) --------------------------------------------------------
void __fastcall arena_get2(int _ECX, int a2)
{
  bool v2; // zf
  bool v5; // zf
  int v6; // eax
  int nprocs; // eax
  int v11; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // ecx
  int v16; // eax
  bool v18; // zf
  bool v20; // zf
  int v21; // [esp+Ch] [ebp-10h]

  if ( free_list )
  {
    _ECX = 1;
    v2 = __readgsdword(0xCu) == 0;
    if ( !v2 )
      __asm { lock }
    __asm { cmpxchg ds:list_lock, ecx }
    if ( !v2 )
    {
      L_lock_8453(0);
      return;
    }
    _EBX = (volatile __int32 *)free_list;
    if ( free_list )
      free_list = *(_DWORD *)(free_list + 1092);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_lock )
    {
      L_unlock_8466();
      return;
    }
    if ( _EBX )
    {
      _ECX = 1;
      v5 = __readgsdword(0xCu) == 0;
      if ( !v5 )
        __asm { lock }
      __asm { cmpxchg [ebx], ecx }
      if ( v5 )
        __writegsdword(0xFFFFFFEC, (unsigned int)_EBX);
      else
        L_lock_8474(0, _EBX);
      return;
    }
  }
  if ( !narenas_limit_9720 )
  {
    v6 = dword_80EF510;
    if ( !dword_80EF510 )
    {
      v21 = a2;
      nprocs = get_nprocs(_ECX);
      a2 = v21;
      if ( nprocs <= 0 )
      {
        narenas_limit_9720 = 4;
        goto LABEL_19;
      }
      v6 = 2 * nprocs;
    }
    narenas_limit_9720 = v6;
  }
LABEL_19:
  if ( narenas <= (unsigned int)dword_80EF50C || narenas < (unsigned int)narenas_limit_9720 )
  {
    _EBX = narenas + 1;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    __asm { cmpxchg narenas, ebx }
    v11 = new_heap(a2 + 1128, dword_80EF504);
    if ( !v11 )
    {
      v11 = new_heap(0x468u, dword_80EF504);
      if ( !v11 )
        goto LABEL_62;
    }
    _EBX = (int *)(v11 + 16);
    v13 = -8;
    *(_DWORD *)v11 = v11 + 16;
    do
    {
      v14 = v11 + 72 + v13;
      v13 += 8;
      *(_DWORD *)(v14 + 12) = v14;
      *(_DWORD *)(v14 + 8) = v14;
    }
    while ( v13 != 1008 );
    if ( _EBX == &main_arena )
      global_max_fast = 64;
    else
      *(_DWORD *)(v11 + 20) |= 2u;
    v15 = *(_DWORD *)(v11 + 8);
    *(_DWORD *)(v11 + 20) |= 1u;
    arena_mem += v15;
    v16 = v11 + 1120;
    *(_DWORD *)(v11 + 1116) = v15;
    *(_DWORD *)(v11 + 1112) = v15;
    if ( (v11 & 7) != 0 )
      v16 = v16 - (v11 & 7) + 8;
    *(_DWORD *)(v11 + 64) = v16;
    *(_DWORD *)(v16 + 4) = (v11 + v15 - v16) | 1;
    _ECX = 1;
    *(_DWORD *)(v11 + 16) = 0;
    __writegsdword(0xFFFFFFEC, (unsigned int)_EBX);
    v18 = __readgsdword(0xCu) == 0;
    if ( !v18 )
      __asm { lock }
    __asm { cmpxchg [ebx], ecx }
    if ( !v18 )
    {
      L_lock_8829(0, _EBX);
      return;
    }
    _ECX = 1;
    v20 = __readgsdword(0xCu) == 0;
    if ( !v20 )
      __asm { lock }
    __asm { cmpxchg ds:list_lock, ecx }
    if ( !v20 )
    {
      L_lock_8834(0);
      return;
    }
    *(_DWORD *)(v11 + 1104) = off_80EF4E0;
    off_80EF4E0 = (int *)(v11 + 16);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_lock )
    {
      L_unlock_8841();
      return;
    }
    if ( v11 == -16 )
    {
LABEL_62:
      if ( __readgsdword(0xCu) )
        __asm { lock }
      --narenas;
    }
  }
  else
  {
    _EBX = (int *)next_to_use_9704;
    if ( !next_to_use_9704 )
    {
      next_to_use_9704 = (int)&main_arena;
      _EBX = &main_arena;
    }
    _EDX = 1;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    __asm { cmpxchg [ebx], edx }
    __writegsdword(0xFFFFFFEC, (unsigned int)_EBX);
    next_to_use_9704 = _EBX[272];
  }
}
// 80EF0A0: using guessed type int main_arena;
// 80EF4E0: using guessed type int *off_80EF4E0;
// 80EF504: using guessed type int dword_80EF504;
// 80EF50C: using guessed type int dword_80EF50C;
// 80EF510: using guessed type int dword_80EF510;
// 80EF538: using guessed type int narenas;
// 80F055C: using guessed type int global_max_fast;
// 80F0564: using guessed type int arena_mem;
// 80F0594: using guessed type int free_list;
// 80F0598: using guessed type int list_lock;
// 80F05A0: using guessed type int narenas_limit_9720;
// 80F05A4: using guessed type int next_to_use_9704;

//----- (0804D9D0) --------------------------------------------------------
int _malloc_check_init()
{
  int result; // eax

  result = disallow_malloc_check;
  if ( disallow_malloc_check )
  {
    disallow_malloc_check = 0;
  }
  else
  {
    using_malloc_checking = 1;
    _malloc_hook[0] = (int (__cdecl *)(int))malloc_check;
    _free_hook = (int)free_check;
    _realloc_hook = (int (__cdecl *)(int, int))realloc_check;
    _memalign_hook[0] = (int (__cdecl *)(int, int))memalign_check;
  }
  return result;
}
// 80EF084: using guessed type int (__cdecl *_memalign_hook[2])(int, int);
// 80EF088: using guessed type int (__cdecl *_realloc_hook)(int, int);
// 80EF08C: using guessed type int (__cdecl *_malloc_hook[2])(int);
// 80F054C: using guessed type int _free_hook;
// 80F0554: using guessed type int disallow_malloc_check;
// 80F0558: using guessed type int using_malloc_checking;

//----- (0804DA20) --------------------------------------------------------
int (*ptmalloc_init())(void)
{
  int (*result)(void); // eax
  int *v1; // eax
  char **v2; // ebx
  _BYTE *v3; // esi
  char *v4; // edi
  const void *s1; // ebp
  char v6; // dl
  int v7; // eax
  char v8; // dl
  _BYTE *v9; // edi
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax

  result = (int (*)(void))_libc_malloc_initialized;
  if ( _libc_malloc_initialized < 0 )
  {
    _libc_malloc_initialized = 0;
    dword_80F0570 = (int)ptmalloc_lock_all;
    dword_80F0574 = (int)ptmalloc_unlock_all;
    __writegsdword(0xFFFFFFEC, (unsigned int)&main_arena);
    dword_80F0578 = (int)ptmalloc_unlock_all2;
    if ( &_dso_handle )
      v1 = (int *)_dso_handle;
    else
      v1 = &_dso_handle;
    dword_80F057C = (int)v1;
    dword_80F0580 = 1;
    _linkin_atfork(&atfork_mem);
    v2 = environ;
    if ( environ )
    {
      v3 = 0;
LABEL_6:
      while ( 1 )
      {
        v4 = *v2;
        if ( !*v2 )
          break;
        while ( *v4 != 77 || v4[1] != 65 || v4[2] != 76 || v4[3] != 76 || v4[4] != 79 || v4[5] != 67 || v4[6] != 95 )
        {
          v4 = *++v2;
          if ( !*v2 )
            goto LABEL_9;
        }
        ++v2;
        s1 = v4 + 7;
        if ( v4 == (char *)-7 )
          break;
        v6 = v4[7];
        if ( v6 )
        {
          v7 = 0;
          if ( v6 != 61 )
          {
            while ( 1 )
            {
              v8 = v4[++v7 + 7];
              if ( !v8 )
                break;
              if ( v8 == 61 )
              {
                switch ( v7 )
                {
                  case 6:
                    v9 = v4 + 14;
                    if ( !memcmp(s1, "CHECK_", 6u) )
                      v3 = v9;
                    break;
                  case 8:
                    if ( !_libc_enable_secure )
                    {
                      if ( !memcmp(v4 + 7, "TOP_PAD_", 8u) )
                      {
                        v16 = strtol(v4 + 16, 0, 10);
                        mALLOPt(-2, v16);
                      }
                      else if ( !memcmp(v4 + 7, "PERTURB_", 8u) )
                      {
                        v14 = strtol(v4 + 16, 0, 10);
                        mALLOPt(-6, v14);
                      }
                    }
                    break;
                  case 9:
                    if ( !_libc_enable_secure )
                    {
                      if ( !memcmp(v4 + 7, "MMAP_MAX_", 9u) )
                      {
                        v15 = strtol(v4 + 17, 0, 10);
                        mALLOPt(-4, v15);
                      }
                      else if ( !memcmp(v4 + 7, "ARENA_MAX", 9u) )
                      {
                        v13 = strtol(v4 + 17, 0, 10);
                        mALLOPt(-8, v13);
                      }
                    }
                    break;
                  case 10:
                    if ( !_libc_enable_secure && !memcmp(v4 + 7, "ARENA_TEST", 0xAu) )
                    {
                      v11 = strtol(v4 + 18, 0, 10);
                      mALLOPt(-7, v11);
                    }
                    break;
                  case 15:
                    if ( !_libc_enable_secure )
                    {
                      if ( !memcmp(v4 + 7, "TRIM_THRESHOLD_", 0xFu) )
                      {
                        v12 = strtol(v4 + 23, 0, 10);
                        mALLOPt(-1, v12);
                      }
                      else if ( !memcmp(v4 + 7, "MMAP_THRESHOLD_", 0xFu) )
                      {
                        v10 = strtol(v4 + 23, 0, 10);
                        mALLOPt(-3, v10);
                      }
                    }
                    break;
                  default:
                    goto LABEL_6;
                }
                goto LABEL_6;
              }
            }
          }
        }
      }
LABEL_9:
      if ( v3 )
      {
        if ( *v3 )
        {
          mALLOPt(-5, (char)*v3 - 48);
          if ( check_action )
            _malloc_check_init();
        }
      }
    }
    result = _malloc_initialize_hook;
    if ( _malloc_initialize_hook )
      result = (int (*)(void))_malloc_initialize_hook();
    _libc_malloc_initialized = 1;
  }
  return result;
}
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80EF064: using guessed type int _dso_handle;
// 80EF080: using guessed type int _libc_malloc_initialized;
// 80EF0A0: using guessed type int main_arena;
// 80EF534: using guessed type int check_action;
// 80F0550: using guessed type int (*_malloc_initialize_hook)(void);
// 80F056C: using guessed type _DWORD atfork_mem;
// 80F0570: using guessed type int dword_80F0570;
// 80F0574: using guessed type int dword_80F0574;
// 80F0578: using guessed type int dword_80F0578;
// 80F057C: using guessed type int dword_80F057C;
// 80F0580: using guessed type int dword_80F0580;

//----- (0804DDF0) --------------------------------------------------------
void __usercall mALLOPt(int a1@<eax>, int a2@<edx>)
{
  bool v5; // zf
  unsigned int v6; // eax

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init();
  _ECX = 1;
  v5 = __readgsdword(0xCu) == 0;
  if ( !v5 )
    __asm { lock }
  __asm { cmpxchg main_arena, ecx }
  if ( v5 )
  {
    malloc_consolidate(&main_arena);
    switch ( a1 )
    {
      case -8:
        if ( a2 > 0 )
          dword_80EF510 = a2;
        break;
      case -7:
        if ( a2 > 0 )
          dword_80EF50C = a2;
        break;
      case -6:
        perturb_byte = a2;
        break;
      case -5:
        check_action = a2;
        break;
      case -4:
        dword_80EF518 = a2;
        dword_80EF520 = 1;
        break;
      case -3:
        if ( (unsigned int)a2 <= 0x80000 )
          dword_80EF508 = a2;
        dword_80EF520 = 1;
        break;
      case -2:
        dword_80EF504 = a2;
        dword_80EF520 = 1;
        break;
      case -1:
        mp_ = a2;
        dword_80EF520 = 1;
        break;
      case 1:
        if ( (unsigned int)a2 <= 0x50 )
        {
          v6 = 8;
          if ( a2 )
            v6 = (a2 + 4) & 0xFFFFFFF8;
          global_max_fast = v6;
        }
        break;
      default:
        break;
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --main_arena )
      L_unlock_9453();
  }
  else
  {
    L_lock_9436(0);
  }
}
// 804DA20: using guessed type int ptmalloc_init(void);
// 80EF080: using guessed type int _libc_malloc_initialized;
// 80EF0A0: using guessed type int main_arena;
// 80EF500: using guessed type int mp_;
// 80EF504: using guessed type int dword_80EF504;
// 80EF508: using guessed type int dword_80EF508;
// 80EF50C: using guessed type int dword_80EF50C;
// 80EF510: using guessed type int dword_80EF510;
// 80EF518: using guessed type int dword_80EF518;
// 80EF520: using guessed type int dword_80EF520;
// 80EF534: using guessed type int check_action;
// 80F055C: using guessed type int global_max_fast;
// 80F0560: using guessed type int perturb_byte;

//----- (0804DF90) --------------------------------------------------------
void __usercall malloc_set_state(long double a1@<st0>, _DWORD *a2)
{
  bool v3; // zf
  int v4; // edx
  unsigned int v5; // eax
  int i; // eax
  int v7; // eax
  int *v8; // edx
  unsigned int v9; // ecx
  int *v10; // eax
  unsigned int v11; // edi
  int v12; // ebp
  int v13; // edi
  int v14; // ebp
  int v15; // ebp
  int v16; // esi
  int v17; // edi
  unsigned int v18; // edi
  int v19; // ebp
  unsigned int v20; // edi
  int v21; // ecx
  int *j; // eax
  unsigned int v23; // edi

  disallow_malloc_check = 1;
  ptmalloc_init();
  if ( *a2 != 1145849153 || (int)a2[1] >= 0 && (a2[1] & 0xFFFFFF00) != 0 )
    return;
  _ECX = 1;
  v3 = __readgsdword(0xCu) == 0;
  if ( !v3 )
    __asm { lock }
  __asm { cmpxchg main_arena, ecx }
  if ( !v3 )
  {
    L_lock_9599(0);
    return;
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  dword_80EF0A4 |= 1u;
  if ( (int)a2[1] <= 3 )
  {
    global_max_fast = 64;
  }
  else
  {
    v4 = a2[274];
    v5 = 8;
    if ( v4 )
      v5 = (v4 + 4) & 0xFFFFFFF8;
    global_max_fast = v5;
  }
  for ( i = 0; i != 10; ++i )
    dword_80EF0A8[i] = 0;
  v7 = a2[4];
  v8 = a2 + 7;
  v9 = 1;
  dword_80EF4D0[0] = 0;
  dword_80EF4D4 = 0;
  dword_80EF4D8 = 0;
  dword_80EF0D0 = v7;
  v10 = &dword_80EF0D0;
  dword_80EF4DC = 0;
  dword_80EF0D4 = 0;
  do
  {
    v16 = *(v8 - 1);
    if ( v16 )
    {
      if ( (int)a2[1] <= 2 )
        goto LABEL_18;
      if ( v9 <= 0x3F )
      {
LABEL_23:
        v17 = *v8;
        v10[2] = v16;
        v10[3] = v17;
        *(_DWORD *)(v16 + 12) = v10;
        *(_DWORD *)(v10[3] + 8) = v10;
        dword_80EF4D0[v9 >> 5] |= 1 << v9;
        goto LABEL_19;
      }
      v11 = *(_DWORD *)(v16 + 4);
      if ( v11 >> 6 > 0x26 )
      {
        if ( v11 >> 9 <= 0x14 )
        {
          if ( (v11 >> 9) + 91 != v9 )
            goto LABEL_18;
LABEL_29:
          v18 = *(_DWORD *)(a2[2 * v9 + 5] + 4);
          if ( v18 >> 6 > 0x26 )
          {
            if ( v18 >> 9 > 0x14 )
            {
              if ( v18 >> 12 > 0xA )
              {
                if ( v18 >> 15 > 4 )
                {
                  v23 = v18 >> 18;
                  v19 = v23 + 124;
                  if ( v23 > 2 )
                    v19 = 126;
                }
                else
                {
                  v19 = (v18 >> 15) + 119;
                }
              }
              else
              {
                v19 = (v18 >> 12) + 110;
              }
            }
            else
            {
              v19 = (v18 >> 9) + 91;
            }
          }
          else
          {
            v19 = (v18 >> 6) + 56;
          }
          if ( v19 != v9 )
          {
LABEL_18:
            v10[3] = (int)v10;
            v13 = *v8;
            v10[2] = (int)v10;
            v14 = dword_80EF0D8;
            *(_DWORD *)(v16 + 12) = &dword_80EF0D0;
            *(_DWORD *)(v13 + 8) = v14;
            v15 = dword_80EF0D8;
            dword_80EF0D8 = v16;
            *(_DWORD *)(v15 + 12) = v13;
            goto LABEL_19;
          }
          goto LABEL_23;
        }
        if ( v11 >> 12 > 0xA )
        {
          if ( v11 >> 15 > 4 )
          {
            v20 = v11 >> 18;
            v12 = v20 + 124;
            if ( v20 > 2 )
              v12 = 126;
          }
          else
          {
            v12 = (v11 >> 15) + 119;
          }
        }
        else
        {
          v12 = (v11 >> 12) + 110;
        }
      }
      else
      {
        v12 = (v11 >> 6) + 56;
      }
      if ( v12 != v9 )
        goto LABEL_18;
      goto LABEL_29;
    }
    if ( *v8 )
      _malloc_assert("ms->av[2*i+3] == 0", "hooks.c", 470, a1, "__malloc_set_state");
    v10[3] = (int)v10;
    v10[2] = (int)v10;
LABEL_19:
    ++v9;
    v10 += 2;
    v8 += 2;
  }
  while ( v9 != 128 );
  v21 = a2[1];
  if ( v21 <= 2 )
  {
    for ( j = (int *)dword_80EF0D8; j != &dword_80EF0D0; j = (int *)j[2] )
    {
      if ( (j[1] & 0xFFFFFFF8) > 0x1FF )
      {
        j[4] = 0;
        j[5] = 0;
      }
    }
  }
  dword_80EF530 = a2[260];
  dword_80EF4E8 = a2[261];
  mp_ = a2[262];
  dword_80EF504 = a2[263];
  dword_80EF518 = a2[264];
  dword_80EF508 = a2[265];
  check_action = a2[266];
  dword_80EF4EC = a2[267];
  dword_80EF514 = a2[269];
  dword_80EF51C = a2[270];
  dword_80EF524 = a2[271];
  dword_80EF528 = a2[272];
  if ( v21 > 0 )
  {
    if ( a2[273] )
    {
      if ( !using_malloc_checking && !disallow_malloc_check )
        _malloc_check_init();
    }
    else if ( using_malloc_checking )
    {
      _malloc_hook = 0;
      _free_hook = 0;
      _realloc_hook = 0;
      _memalign_hook = 0;
      using_malloc_checking = 0;
    }
  }
  if ( (int)a2[1] > 3 )
  {
    dword_80EF50C = a2[275];
    dword_80EF510 = a2[276];
    narenas = a2[277];
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
    L_unlock_9894();
}
// 80EF084: using guessed type int (__cdecl *_memalign_hook)(_DWORD, _DWORD, _DWORD);
// 80EF088: using guessed type int (__cdecl *_realloc_hook)(int, int);
// 80EF08C: using guessed type int (__cdecl *_malloc_hook)(_DWORD, _DWORD);
// 80EF0A0: using guessed type int main_arena;
// 80EF0A4: using guessed type int dword_80EF0A4;
// 80EF0A8: using guessed type int dword_80EF0A8[10];
// 80EF0D0: using guessed type int dword_80EF0D0;
// 80EF0D4: using guessed type int dword_80EF0D4;
// 80EF0D8: using guessed type int dword_80EF0D8;
// 80EF4D0: using guessed type int dword_80EF4D0[];
// 80EF4D4: using guessed type int dword_80EF4D4;
// 80EF4D8: using guessed type int dword_80EF4D8;
// 80EF4DC: using guessed type int dword_80EF4DC;
// 80EF4E8: using guessed type int dword_80EF4E8;
// 80EF4EC: using guessed type int dword_80EF4EC;
// 80EF500: using guessed type int mp_;
// 80EF504: using guessed type int dword_80EF504;
// 80EF508: using guessed type int dword_80EF508;
// 80EF50C: using guessed type int dword_80EF50C;
// 80EF510: using guessed type int dword_80EF510;
// 80EF514: using guessed type int dword_80EF514;
// 80EF518: using guessed type int dword_80EF518;
// 80EF51C: using guessed type int dword_80EF51C;
// 80EF524: using guessed type int dword_80EF524;
// 80EF528: using guessed type int dword_80EF528;
// 80EF530: using guessed type int dword_80EF530;
// 80EF534: using guessed type int check_action;
// 80EF538: using guessed type int narenas;
// 80F054C: using guessed type int (__cdecl *_free_hook)(_DWORD, _DWORD);
// 80F0554: using guessed type int disallow_malloc_check;
// 80F0558: using guessed type int using_malloc_checking;
// 80F055C: using guessed type int global_max_fast;

//----- (0804E3D0) --------------------------------------------------------
void __usercall malloc(long double a1@<st0>, size_t a2)
{
  bool v4; // zf
  _DWORD *v5; // ebx
  int v6; // eax
  int *v7; // edx
  bool v9; // zf
  volatile __int32 *v10; // eax
  int *v11; // eax
  void *retaddr; // [esp+1Ch] [ebp+0h]

  if ( _malloc_hook )
  {
    _malloc_hook(a2, retaddr);
    return;
  }
  _EDI = (volatile __int32 *)__readgsdword(0xFFFFFFEC);
  if ( _EDI )
  {
    _ECX = 1;
    v4 = __readgsdword(0xCu) == 0;
    if ( !v4 )
      __asm { lock }
    __asm { cmpxchg [edi], ecx }
    if ( !v4 )
    {
      L_lock_10019(0, _EDI);
      return;
    }
  }
  else
  {
    arena_get2(0, a2);
    _EDI = v10;
    if ( !v10 )
      return;
  }
  v5 = int_malloc((int *)_EDI, a2, a1);
  if ( v5 )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v4 = (*_EDI)-- == 1;
    if ( !v4 )
    {
      L_unlock_10041(_EDI);
      return;
    }
LABEL_10:
    v6 = *(v5 - 1);
    if ( (v6 & 2) == 0 )
    {
      v7 = &main_arena;
      if ( (v6 & 4) != 0 )
        v7 = *(int **)((unsigned int)(v5 - 2) & 0xFFF00000);
      if ( v7 != _EDI )
        _malloc_assert("__libc_malloc");
    }
    return;
  }
  if ( _EDI != &main_arena )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v4 = (*_EDI)-- == 1;
    if ( !v4 )
    {
      L_unlock_10098(_EDI);
      return;
    }
    _ECX = 1;
    v9 = __readgsdword(0xCu) == 0;
    if ( !v9 )
      __asm { lock }
    __asm { cmpxchg main_arena, ecx }
    if ( !v9 )
    {
      L_lock_10105(0);
      return;
    }
    v5 = int_malloc(&main_arena, a2, a1);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --main_arena )
    {
      L_unlock_10114();
      return;
    }
    _EDI = &main_arena;
    goto LABEL_26;
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
  {
    L_unlock_10171();
    return;
  }
  arena_get2((int)&main_arena, a2);
  _EDI = v11;
  if ( v11 )
  {
    v5 = int_malloc(v11, a2, a1);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v4 = (*_EDI)-- == 1;
    if ( !v4 )
    {
      L_unlock_10190(_EDI);
      return;
    }
LABEL_26:
    if ( !v5 )
      return;
    goto LABEL_10;
  }
}
// 804E4FF: variable 'v10' is possibly undefined
// 804E542: variable 'v11' is possibly undefined
// 804A220: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 80EF08C: using guessed type int (__cdecl *_malloc_hook)(_DWORD, _DWORD);
// 80EF0A0: using guessed type int main_arena;
// 80EF4E0: using guessed type int *off_80EF4E0;

//----- (0804E5A0) --------------------------------------------------------
void __cdecl malloc_atfork(unsigned int a1)
{
  int v1; // ecx
  bool v3; // zf
  int v4; // ecx
  int v5; // eax

  if ( __readgsdword(0xFFFFFFEC) == -1 )
  {
    if ( (void (__cdecl *)(unsigned int))save_malloc_hook == malloc_check )
    {
      if ( top_check() >= 0 )
      {
        v5 = int_malloc(v4, a1 + 1);
        mem2mem_check(v5, a1);
      }
    }
    else
    {
      int_malloc(v1, a1);
    }
  }
  else
  {
    _ECX = 1;
    v3 = __readgsdword(0xCu) == 0;
    if ( !v3 )
      __asm { lock }
    __asm { cmpxchg ds:list_lock, ecx }
    if ( v3 )
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --list_lock )
        L_unlock_10251();
      else
        malloc(a1);
    }
    else
    {
      L_lock_10248(0);
    }
  }
}
// 804E60F: variable 'v1' is possibly undefined
// 804E629: variable 'v4' is possibly undefined
// 804BBB0: using guessed type int __fastcall int_malloc(_DWORD, _DWORD);
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80F058C: using guessed type int save_malloc_hook;
// 80F0598: using guessed type int list_lock;

//----- (0804E640) --------------------------------------------------------
int __cdecl malloc_hook_ini(int a1)
{
  _malloc_hook[0] = 0;
  ptmalloc_init();
  return malloc(a1);
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80EF08C: using guessed type int (__cdecl *_malloc_hook[2])(int);

//----- (0804E670) --------------------------------------------------------
void __usercall malloc_get_state(long double a1@<st0>)
{
  _DWORD *v1; // eax
  _DWORD *v2; // ebx
  bool v4; // zf
  int v5; // eax
  int v6; // edx
  int *v7; // eax
  int v8; // ecx
  int v9; // eax

  malloc(a1, 0x458u);
  v2 = v1;
  if ( v1 )
  {
    _ECX = 1;
    v4 = __readgsdword(0xCu) == 0;
    if ( !v4 )
      __asm { lock }
    __asm { cmpxchg main_arena, ecx }
    if ( v4 )
    {
      malloc_consolidate(&main_arena);
      v5 = dword_80EF0D0;
      v6 = 2;
      *v2 = 1145849153;
      v2[1] = 4;
      v2[2] = 0;
      v2[4] = v5;
      v7 = &dword_80EF0D8;
      v2[3] = 0;
      v2[5] = 0;
      do
      {
        while ( (int *)*v7 != v7 - 2 )
        {
          v2[2 * v6 + 2] = *v7;
          v8 = v7[1];
          v7 += 2;
          v2[2 * v6++ + 3] = v8;
          if ( v7 == dword_80EF4D0 )
            goto LABEL_9;
        }
        v7 += 2;
        v2[2 * v6 + 3] = 0;
        v2[2 * v6++ + 2] = 0;
      }
      while ( v7 != dword_80EF4D0 );
LABEL_9:
      v2[260] = dword_80EF530;
      v2[261] = dword_80EF4E8;
      v2[262] = mp_;
      v2[263] = dword_80EF504;
      v2[264] = dword_80EF518;
      v2[265] = dword_80EF508;
      v2[266] = check_action;
      v9 = dword_80EF4EC;
      v2[268] = 0;
      v2[267] = v9;
      v2[269] = dword_80EF514;
      v2[270] = dword_80EF51C;
      v2[271] = dword_80EF524;
      v2[272] = dword_80EF528;
      v2[273] = using_malloc_checking;
      v2[274] = global_max_fast;
      v2[275] = dword_80EF50C;
      v2[276] = dword_80EF510;
      v2[277] = narenas;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --main_arena )
        L_unlock_10447();
    }
    else
    {
      L_lock_10365(0);
    }
  }
}
// 804E683: variable 'v1' is possibly undefined
// 80EF0A0: using guessed type int main_arena;
// 80EF0D0: using guessed type int dword_80EF0D0;
// 80EF0D8: using guessed type int dword_80EF0D8;
// 80EF4D0: using guessed type int dword_80EF4D0[];
// 80EF4E8: using guessed type int dword_80EF4E8;
// 80EF4EC: using guessed type int dword_80EF4EC;
// 80EF500: using guessed type int mp_;
// 80EF504: using guessed type int dword_80EF504;
// 80EF508: using guessed type int dword_80EF508;
// 80EF50C: using guessed type int dword_80EF50C;
// 80EF510: using guessed type int dword_80EF510;
// 80EF514: using guessed type int dword_80EF514;
// 80EF518: using guessed type int dword_80EF518;
// 80EF51C: using guessed type int dword_80EF51C;
// 80EF524: using guessed type int dword_80EF524;
// 80EF528: using guessed type int dword_80EF528;
// 80EF530: using guessed type int dword_80EF530;
// 80EF534: using guessed type int check_action;
// 80EF538: using guessed type int narenas;
// 80F0558: using guessed type int using_malloc_checking;
// 80F055C: using guessed type int global_max_fast;

//----- (0804E820) --------------------------------------------------------
void __usercall free(long double a1@<st0>, int a2)
{
  unsigned int v2; // edx
  unsigned int v3; // ecx
  int *v4; // eax
  void *retaddr; // [esp+1Ch] [ebp+0h]

  if ( _free_hook )
  {
    _free_hook(a2, retaddr);
  }
  else if ( a2 )
  {
    v2 = a2 - 8;
    v3 = *(_DWORD *)(a2 - 4);
    if ( (v3 & 2) != 0 )
    {
      if ( !dword_80EF520 && v3 > dword_80EF508 && v3 <= 0x80000 )
      {
        dword_80EF508 = v3 & 0xFFFF8;
        mp_ = 2 * (v3 & 0xFFFFFFF8);
      }
      munmap_chunk((_DWORD *)v2, a1);
    }
    else
    {
      v4 = &main_arena;
      if ( (v3 & 4) != 0 )
        v4 = *(int **)(v2 & 0xFFF00000);
      int_free((int)v4, v2, 0);
    }
  }
}
// 80F054C: invalid function type '?' has been ignored
// 804E87C: mask 0xFFFFFFF8 is shortened because ecx.4 <= 0x80000
// 80EF0A0: using guessed type int main_arena;
// 80EF500: using guessed type int mp_;
// 80EF508: using guessed type int dword_80EF508;
// 80EF520: using guessed type int dword_80EF520;
// 80F054C: using guessed type int (__cdecl *_free_hook)(_DWORD, _DWORD);

//----- (0804E8B0) --------------------------------------------------------
void __cdecl realloc(_BYTE *a1, unsigned int a2)
{
  int v2; // eax
  unsigned int v3; // ebp
  int v4; // ecx
  bool v7; // zf
  unsigned int v8; // eax
  unsigned int v9; // edx
  int v10; // eax
  int *v11; // ecx
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  unsigned int v14; // [esp+18h] [ebp-24h]
  unsigned int v15; // [esp+1Ch] [ebp-20h]

  if ( _realloc_hook )
  {
    _realloc_hook((int)a1, a2);
  }
  else if ( a2 || !a1 )
  {
    if ( a1 )
    {
      v2 = *((_DWORD *)a1 - 1);
      v3 = (unsigned int)(a1 - 8);
      v15 = v2 & 0xFFFFFFF8;
      if ( (unsigned int)(a1 - 8) > -(v2 & 0xFFFFFFF8) || (v3 & 7) != 0 )
      {
        malloc_printerr(a1, "realloc(): invalid pointer");
      }
      else if ( a2 > 0xFFFFFFDF )
      {
        __writegsdword(0xFFFFFFE8, 0xCu);
      }
      else
      {
        v4 = (a2 + 11) & 0xFFFFFFF8;
        if ( a2 + 11 < 0x10 )
          v4 = 16;
        v14 = v4;
        if ( (v2 & 2) != 0 )
        {
          if ( !mremap_chunk((int *)a1 - 2, v4) && v14 > v15 - 4 )
          {
            v12 = (_BYTE *)malloc(a2);
            if ( v12 )
            {
              memcpy(v12, a1, v15 - 8);
              munmap_chunk();
            }
          }
        }
        else
        {
          _ESI = &main_arena;
          if ( (v2 & 4) != 0 )
            _ESI = *(int **)(v3 & 0xFFF00000);
          _ECX = 1;
          v7 = __readgsdword(0xCu) == 0;
          if ( !v7 )
            __asm { lock }
          __asm { cmpxchg [esi], ecx }
          if ( v7 )
          {
            v8 = int_realloc(_ESI, (unsigned int)(a1 - 8), v15, v14);
            v9 = v8;
            if ( __readgsdword(0xCu) )
              __asm { lock }
            v7 = (*_ESI)-- == 1;
            if ( v7 )
            {
              if ( v8 )
              {
                v10 = *(_DWORD *)(v8 - 4);
                if ( (v10 & 2) == 0 )
                {
                  v11 = &main_arena;
                  if ( (v10 & 4) != 0 )
                    v11 = *(int **)((v9 - 8) & 0xFFF00000);
                  if ( _ESI != v11 )
                    _malloc_assert("__libc_realloc");
                }
              }
              else
              {
                v13 = (_BYTE *)malloc(a2);
                if ( v13 )
                {
                  memcpy(v13, a1, v15 - 4);
                  int_free((int)_ESI, v3, 0);
                }
              }
            }
            else
            {
              L_unlock_10658(_ESI);
            }
          }
          else
          {
            L_lock_10645(0, _ESI);
          }
        }
      }
    }
    else
    {
      malloc(a2);
    }
  }
  else
  {
    free(a1);
  }
}
// 804A220: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 804AB70: using guessed type int __fastcall malloc_printerr(_DWORD, _DWORD);
// 804B180: using guessed type int munmap_chunk(void);
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80EF088: using guessed type int (__cdecl *_realloc_hook)(int, int);
// 80EF0A0: using guessed type int main_arena;
// 80EF534: using guessed type int check_action;

//----- (0804EB20) --------------------------------------------------------
int __cdecl realloc_hook_ini(int a1, int a2)
{
  _malloc_hook = 0;
  _realloc_hook = 0;
  ptmalloc_init();
  return realloc(a1, a2);
}
// 804E8B0: using guessed type _DWORD __cdecl realloc(_DWORD, _DWORD);
// 80EF088: using guessed type int (__cdecl *_realloc_hook)(int, int);
// 80EF08C: using guessed type int (__cdecl *_malloc_hook)(_DWORD, _DWORD);

//----- (0804EB70) --------------------------------------------------------
void __cdecl memalign(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // esi
  bool v5; // zf
  int v6; // ebx
  int v7; // eax
  int *v8; // edx
  bool v10; // zf
  volatile __int32 *v11; // eax
  int *v12; // eax
  void *retaddr; // [esp+2Ch] [ebp+0h]

  v2 = a1;
  if ( _memalign_hook )
  {
    _memalign_hook(a1, a2, retaddr);
    return;
  }
  if ( a1 <= 8 )
  {
    malloc(a2);
    return;
  }
  if ( a1 <= 0xF )
    v2 = 16;
  _EDI = (volatile __int32 *)__readgsdword(0xFFFFFFEC);
  if ( _EDI )
  {
    _ECX = 1;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg [edi], ecx }
    if ( !v5 )
    {
      L_lock_10980(0, _EDI);
      return;
    }
  }
  else
  {
    arena_get2(0, v2 + a2 + 16);
    _EDI = v11;
    if ( !v11 )
      return;
  }
  v6 = int_memalign((int *)_EDI, v2, a2);
  if ( v6 )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v5 = (*_EDI)-- == 1;
    if ( !v5 )
    {
      L_unlock_11003(_EDI);
      return;
    }
LABEL_13:
    v7 = *(_DWORD *)(v6 - 4);
    if ( (v7 & 2) == 0 )
    {
      v8 = &main_arena;
      if ( (v7 & 4) != 0 )
        v8 = *(int **)((v6 - 8) & 0xFFF00000);
      if ( v8 != _EDI )
        _malloc_assert("__libc_memalign");
    }
    return;
  }
  if ( _EDI != &main_arena )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v5 = (*_EDI)-- == 1;
    if ( !v5 )
    {
      L_unlock_11078(_EDI);
      return;
    }
    _ECX = 1;
    v10 = __readgsdword(0xCu) == 0;
    if ( !v10 )
      __asm { lock }
    __asm { cmpxchg main_arena, ecx }
    if ( !v10 )
    {
      L_lock_11085(0);
      return;
    }
    v6 = int_memalign(&main_arena, v2, a2);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --main_arena )
    {
      L_unlock_11095();
      return;
    }
    _EDI = &main_arena;
    goto LABEL_30;
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
  {
    L_unlock_11163();
    return;
  }
  arena_get2((int)&main_arena, a2);
  _EDI = v12;
  if ( v12 )
  {
    v6 = int_memalign(v12, v2, a2);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v5 = (*_EDI)-- == 1;
    if ( !v5 )
    {
      L_unlock_11183(_EDI);
      return;
    }
LABEL_30:
    if ( !v6 )
      return;
    goto LABEL_13;
  }
}
// 80EF084: invalid function type '?' has been ignored
// 804ECE9: variable 'v11' is possibly undefined
// 804ED4A: variable 'v12' is possibly undefined
// 804A220: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80EF084: using guessed type int (__cdecl *_memalign_hook)(_DWORD, _DWORD, _DWORD);
// 80EF0A0: using guessed type int main_arena;
// 80EF4E0: using guessed type int *off_80EF4E0;

//----- (0804ED90) --------------------------------------------------------
int __cdecl memalign_hook_ini(int a1, int a2)
{
  _memalign_hook[0] = 0;
  ptmalloc_init();
  return memalign(a1, a2);
}
// 804EB70: using guessed type _DWORD __cdecl memalign(_DWORD, _DWORD);
// 80EF084: using guessed type int (__cdecl *_memalign_hook[2])(int, int);

//----- (0804EDD0) --------------------------------------------------------
void __usercall valloc(long double a1@<st0>, unsigned int a2)
{
  unsigned int v2; // edi
  bool v5; // zf
  int v6; // ebx
  int v7; // eax
  int *v8; // edx
  bool v10; // zf
  int *v11; // eax
  int *v12; // eax
  void *retaddr; // [esp+2Ch] [ebp+0h]

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init();
  v2 = dl_pagesize;
  if ( _memalign_hook )
  {
    _memalign_hook(dl_pagesize, a2, retaddr);
    return;
  }
  _ESI = (int *)__readgsdword(0xFFFFFFEC);
  if ( _ESI )
  {
    _ECX = 1;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg [esi], ecx }
    if ( !v5 )
    {
      L_lock_11280(0, _ESI);
      return;
    }
  }
  else
  {
    arena_get2(0, dl_pagesize + a2 + 16);
    _ESI = v11;
    if ( !v11 )
      return;
  }
  if ( (_ESI[1] & 1) == 0 )
    malloc_consolidate(_ESI);
  v6 = int_memalign(_ESI, dl_pagesize, a2);
  if ( v6 )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v5 = (*_ESI)-- == 1;
    if ( !v5 )
    {
      L_unlock_11320(_ESI);
      return;
    }
LABEL_14:
    v7 = *(_DWORD *)(v6 - 4);
    if ( (v7 & 2) == 0 )
    {
      v8 = &main_arena;
      if ( (v7 & 4) != 0 )
        v8 = *(int **)((v6 - 8) & 0xFFF00000);
      if ( v8 != _ESI )
        _malloc_assert(
          "!p || ((((mchunkptr)((char*)(p) - 2*(sizeof(size_t)))))->size & 0x2) || ar_ptr == (((((mchunkptr)((char*)(p) -"
          " 2*(sizeof(size_t)))))->size & 0x4) ? ((heap_info *)((unsigned long)(((mchunkptr)((char*)(p) - 2*(sizeof(size_"
          "t))))) & ~((2 * (512 * 1024))-1)))->ar_ptr : &main_arena)",
          "malloc.c",
          3175,
          a1,
          "__libc_valloc");
    }
    return;
  }
  if ( _ESI != &main_arena )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v5 = (*_ESI)-- == 1;
    if ( !v5 )
    {
      L_unlock_11397(_ESI);
      return;
    }
    _ECX = 1;
    v10 = __readgsdword(0xCu) == 0;
    if ( !v10 )
      __asm { lock }
    __asm { cmpxchg main_arena, ecx }
    if ( !v10 )
    {
      L_lock_11403(0);
      return;
    }
    v6 = int_memalign(&main_arena, v2, a2);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --main_arena )
    {
      L_unlock_11412();
      return;
    }
    _ESI = &main_arena;
    goto LABEL_30;
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
  {
    L_unlock_11486();
    return;
  }
  arena_get2((int)&main_arena, a2);
  _ESI = v12;
  if ( v12 )
  {
    v6 = int_memalign(v12, v2, a2);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v5 = (*_ESI)-- == 1;
    if ( !v5 )
    {
      L_unlock_11505(_ESI);
      return;
    }
LABEL_30:
    if ( !v6 )
      return;
    goto LABEL_14;
  }
}
// 804EF4F: variable 'v11' is possibly undefined
// 804EF92: variable 'v12' is possibly undefined
// 80EF080: using guessed type int _libc_malloc_initialized;
// 80EF084: using guessed type int (__cdecl *_memalign_hook)(_DWORD, _DWORD, _DWORD);
// 80EF0A0: using guessed type int main_arena;
// 80EF4E0: using guessed type int *off_80EF4E0;
// 80EF5B8: using guessed type int dl_pagesize;

//----- (0804F000) --------------------------------------------------------
void __usercall pvalloc(long double a1@<st0>, int a2)
{
  unsigned int v2; // ebp
  int v3; // edi
  bool v6; // zf
  int v7; // ebx
  int v8; // eax
  int *v9; // edx
  bool v11; // zf
  int *v12; // eax
  int *v13; // eax
  void *retaddr; // [esp+2Ch] [ebp+0h]

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init();
  v2 = dl_pagesize;
  v3 = ~(dl_pagesize - 1) & (dl_pagesize - 1 + a2);
  if ( _memalign_hook )
  {
    _memalign_hook(dl_pagesize, ~(dl_pagesize - 1) & (dl_pagesize - 1 + a2), retaddr);
    return;
  }
  _ESI = (int *)__readgsdword(0xFFFFFFEC);
  if ( _ESI )
  {
    _ECX = 1;
    v6 = __readgsdword(0xCu) == 0;
    if ( !v6 )
      __asm { lock }
    __asm { cmpxchg [esi], ecx }
    if ( !v6 )
    {
      L_lock_11594(0, _ESI);
      return;
    }
  }
  else
  {
    arena_get2(0, a2 + 2 * dl_pagesize + 16);
    _ESI = v12;
  }
  if ( (_ESI[1] & 1) == 0 )
    malloc_consolidate(_ESI);
  v7 = int_memalign(_ESI, dl_pagesize, -dl_pagesize & (dl_pagesize + a2 - 1));
  if ( v7 )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v6 = (*_ESI)-- == 1;
    if ( !v6 )
    {
      L_unlock_11640(_ESI);
      return;
    }
LABEL_14:
    v8 = *(_DWORD *)(v7 - 4);
    if ( (v8 & 2) == 0 )
    {
      v9 = &main_arena;
      if ( (v8 & 4) != 0 )
        v9 = *(int **)((v7 - 8) & 0xFFF00000);
      if ( v9 != _ESI )
        _malloc_assert(
          "!p || ((((mchunkptr)((char*)(p) - 2*(sizeof(size_t)))))->size & 0x2) || ar_ptr == (((((mchunkptr)((char*)(p) -"
          " 2*(sizeof(size_t)))))->size & 0x4) ? ((heap_info *)((unsigned long)(((mchunkptr)((char*)(p) - 2*(sizeof(size_"
          "t))))) & ~((2 * (512 * 1024))-1)))->ar_ptr : &main_arena)",
          "malloc.c",
          3223,
          a1,
          "__libc_pvalloc");
    }
    return;
  }
  if ( _ESI != &main_arena )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v6 = (*_ESI)-- == 1;
    if ( !v6 )
    {
      L_unlock_11718(_ESI);
      return;
    }
    _ECX = 1;
    v11 = __readgsdword(0xCu) == 0;
    if ( !v11 )
      __asm { lock }
    __asm { cmpxchg main_arena, ecx }
    if ( !v11 )
    {
      L_lock_11724(0);
      return;
    }
    v7 = int_memalign(&main_arena, v2, v3);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --main_arena )
    {
      L_unlock_11733();
      return;
    }
    _ESI = &main_arena;
    goto LABEL_30;
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
  {
    L_unlock_11811();
    return;
  }
  arena_get2((int)&main_arena, a2 + 2 * v2 + 16);
  _ESI = v13;
  if ( v13 )
  {
    v7 = int_memalign(v13, v2, v3);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v6 = (*_ESI)-- == 1;
    if ( !v6 )
    {
      L_unlock_11831(_ESI);
      return;
    }
LABEL_30:
    if ( !v7 )
      return;
    goto LABEL_14;
  }
}
// 804F199: variable 'v12' is possibly undefined
// 804F1D8: variable 'v13' is possibly undefined
// 80EF080: using guessed type int _libc_malloc_initialized;
// 80EF084: using guessed type int (__cdecl *_memalign_hook)(_DWORD, _DWORD, _DWORD);
// 80EF0A0: using guessed type int main_arena;
// 80EF4E0: using guessed type int *off_80EF4E0;
// 80EF5B8: using guessed type int dl_pagesize;

//----- (0804F240) --------------------------------------------------------
void __cdecl calloc(int a1, unsigned int a2)
{
  bool v4; // zf
  unsigned int v5; // ebp
  unsigned int v6; // esi
  int v7; // eax
  _DWORD *s; // ebx
  int v9; // eax
  int *v10; // edx
  int v11; // eax
  unsigned int v12; // eax
  size_t v13; // eax
  unsigned int v14; // edx
  bool v16; // zf
  unsigned int v17; // eax
  int v18; // ecx
  _DWORD *v19; // eax
  _DWORD *v20; // edi
  void *v21; // ebx
  unsigned int n; // [esp+1Ch] [ebp-20h]
  void *retaddr; // [esp+3Ch] [ebp+0h]

  n = a1 * a2;
  if ( (a1 | a2) > 0xFFFF && a2 && n / a2 != a1 )
  {
    __writegsdword(0xFFFFFFE8, 0xCu);
    return;
  }
  if ( _malloc_hook )
  {
    v21 = (void *)_malloc_hook(n, retaddr);
    if ( v21 )
      memset(v21, 0, n);
  }
  else
  {
    _EDI = __readgsdword(0xFFFFFFEC);
    if ( _EDI )
    {
      _ECX = 1;
      v4 = __readgsdword(0xCu) == 0;
      if ( !v4 )
        __asm { lock }
      __asm { cmpxchg [edi], ecx }
      if ( !v4 )
      {
        L_lock_11918(0, (volatile __int32 *)_EDI);
        return;
      }
    }
    else
    {
      arena_get2(0, n);
      _EDI = v17;
      if ( !v17 )
        return;
    }
    v5 = *(_DWORD *)(_EDI + 48);
    v6 = *(_DWORD *)(v5 + 4) & 0xFFFFFFF8;
    if ( (int *)_EDI != &main_arena && v6 < *(_DWORD *)((v5 & 0xFFF00000) + 0xC) + (v5 & 0xFFF00000) - v5 )
      v6 = *(_DWORD *)((v5 & 0xFFF00000) + 0xC) + (v5 & 0xFFF00000) - v5;
    v7 = int_malloc(_ECX, n);
    s = (_DWORD *)v7;
    if ( v7 )
    {
      v9 = *(_DWORD *)(v7 - 4);
      if ( (v9 & 2) == 0 )
      {
        v10 = &main_arena;
        if ( (v9 & 4) != 0 )
          v10 = *(int **)((unsigned int)(s - 2) & 0xFFF00000);
        if ( v10 != (int *)_EDI )
          _malloc_assert("__libc_calloc");
      }
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v4 = (*(_DWORD *)_EDI)-- == 1;
      if ( !v4 )
      {
        L_unlock_11987((_DWORD *)_EDI);
        return;
      }
LABEL_18:
      v11 = *(s - 1);
      if ( (v11 & 2) != 0 )
      {
        if ( perturb_byte )
          memset(s, 0, n);
      }
      else
      {
        v12 = v11 & 0xFFFFFFF8;
        if ( !perturb_byte && (_DWORD *)v5 == s - 2 && v12 > v6 )
          v12 = v6;
        v13 = v12 - 4;
        v14 = v13 >> 2;
        if ( v13 >> 2 <= 2 )
          _malloc_assert("__libc_calloc");
        if ( v14 > 9 )
        {
          memset(s, 0, v13);
        }
        else
        {
          *s = 0;
          s[1] = 0;
          s[2] = 0;
          if ( v14 > 4 )
          {
            s[3] = 0;
            s[4] = 0;
            if ( v14 > 6 )
            {
              s[5] = 0;
              s[6] = 0;
              if ( v14 == 9 )
              {
                s[7] = 0;
                s[8] = 0;
              }
            }
          }
        }
      }
      return;
    }
    if ( (int *)_EDI != &main_arena )
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v4 = (*(_DWORD *)_EDI)-- == 1;
      if ( !v4 )
      {
        L_unlock_12108((_DWORD *)_EDI);
        return;
      }
      _ECX = 1;
      v16 = __readgsdword(0xCu) == 0;
      if ( !v16 )
        __asm { lock }
      __asm { cmpxchg main_arena, ecx }
      if ( !v16 )
      {
        L_lock_12114(0);
        return;
      }
      s = (_DWORD *)int_malloc(1, n);
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --main_arena )
      {
        L_unlock_12123();
        return;
      }
      goto LABEL_43;
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --main_arena )
    {
      L_unlock_12214();
      return;
    }
    arena_get2((int)&main_arena, n);
    v20 = v19;
    if ( v19 )
    {
      s = (_DWORD *)int_malloc(v18, n);
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v4 = (*v20)-- == 1;
      if ( !v4 )
      {
        L_unlock_12233(v20);
        return;
      }
LABEL_43:
      if ( !s )
        return;
      goto LABEL_18;
    }
  }
}
// 80EF08C: invalid function type '?' has been ignored
// 804F2D2: variable '_ECX' is possibly undefined
// 804F47F: variable 'v17' is possibly undefined
// 804F4E4: variable 'v19' is possibly undefined
// 804F4F0: variable 'v18' is possibly undefined
// 804A220: using guessed type void __cdecl __noreturn _malloc_assert(_DWORD);
// 804BBB0: using guessed type int __fastcall int_malloc(_DWORD, _DWORD);
// 80EF08C: using guessed type int (__cdecl *_malloc_hook)(_DWORD, _DWORD);
// 80EF0A0: using guessed type int main_arena;
// 80EF4E0: using guessed type int *off_80EF4E0;
// 80F0560: using guessed type int perturb_byte;

//----- (0804F5B0) --------------------------------------------------------
void __usercall malloc_trim(long double a1@<st0>, int a2)
{
  bool v4; // zf
  int v5; // ecx
  unsigned int v6; // esi
  int v7; // edi
  int v8; // ebx
  int v9; // ebp
  unsigned int v10; // eax
  unsigned int v11; // edx
  unsigned int v12; // eax
  int v13; // eax
  int *v14; // edx
  unsigned int v15; // edx
  unsigned int v16; // [esp+14h] [ebp-38h]
  int i; // [esp+18h] [ebp-34h]
  int v18; // [esp+1Ch] [ebp-30h]
  signed int v19; // [esp+20h] [ebp-2Ch]
  int *v20; // [esp+28h] [ebp-24h]
  int v21; // [esp+2Ch] [ebp-20h]

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init();
  v20 = &main_arena;
  v21 = 0;
  while ( 1 )
  {
    _EDX = v20;
    _ECX = 1;
    v4 = __readgsdword(0xCu) == 0;
    if ( !v4 )
      __asm { lock }
    __asm { cmpxchg [edx], ecx }
    if ( !v4 )
    {
      L_lock_12371(0, v20);
      return;
    }
    malloc_consolidate(v20);
    if ( (unsigned int)dl_pagesize > 0x1FF )
    {
      if ( (unsigned int)dl_pagesize >> 6 > 0x26 )
      {
        if ( (unsigned int)dl_pagesize >> 9 > 0x14 )
        {
          if ( (unsigned int)dl_pagesize >> 12 > 0xA )
          {
            if ( (unsigned int)dl_pagesize >> 15 > 4 )
            {
              v15 = ((unsigned int)dl_pagesize >> 18) + 124;
              if ( (unsigned int)dl_pagesize >> 18 > 2 )
                v15 = 126;
              v19 = v15;
            }
            else
            {
              v19 = ((unsigned int)dl_pagesize >> 15) + 119;
            }
          }
          else
          {
            v19 = ((unsigned int)dl_pagesize >> 12) + 110;
          }
        }
        else
        {
          v19 = ((unsigned int)dl_pagesize >> 9) + 91;
        }
      }
      else
      {
        v19 = ((unsigned int)dl_pagesize >> 6) + 56;
      }
    }
    else
    {
      v19 = (unsigned int)dl_pagesize >> 3;
    }
    v6 = dl_pagesize + 23;
    v16 = dl_pagesize - 1;
    v18 = 0;
    for ( i = 1; i != 128; ++i )
    {
      if ( i >= v19 || i == 1 )
      {
        v7 = (int)&v20[2 * i + 10];
        v8 = *(_DWORD *)(v7 + 12);
        if ( v7 != v8 )
        {
          v9 = ~v16;
          do
          {
            while ( 1 )
            {
              v10 = *(_DWORD *)(v8 + 4) & 0xFFFFFFF8;
              if ( v10 > v6 )
              {
                v11 = v9 & (v8 + v6);
                if ( v11 < v8 + 24 )
                  _malloc_assert(
                    "(char *) ((void*)((char*)(p) + 2*(sizeof(size_t)))) + 4 * (sizeof(size_t)) <= paligned_mem",
                    "malloc.c",
                    4624,
                    a1,
                    "mTRIm");
                if ( v11 >= v8 + v10 )
                  _malloc_assert("(char *) p + size > paligned_mem", "malloc.c", 4625, a1, "mTRIm");
                v5 = v8 - v11;
                v12 = v8 - v11 + v10;
                if ( v16 < v12 )
                  break;
              }
              v8 = *(_DWORD *)(v8 + 12);
              if ( v7 == v8 )
                goto LABEL_20;
            }
            madvise(v9 & (v8 + v6), v9 & v12);
            v8 = *(_DWORD *)(v8 + 12);
            v18 = 1;
          }
          while ( v7 != v8 );
        }
      }
LABEL_20:
      ;
    }
    v13 = 0;
    if ( v20 == &main_arena )
      v13 = sYSTRIm_isra_1(a2, &dword_80EF0D0, &dword_80EF4E8);
    v14 = v20;
    v21 |= v18 | v13;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v4 = (*v20)-- == 1;
    if ( !v4 )
      break;
    v20 = (int *)v20[272];
    if ( (int *)v14[272] == &main_arena )
      return;
  }
  L_unlock_12552(v5, v20);
}
// 804F70D: variable 'v5' is possibly undefined
// 80EF080: using guessed type int _libc_malloc_initialized;
// 80EF0A0: using guessed type int main_arena;
// 80EF0D0: using guessed type int dword_80EF0D0;
// 80EF4E8: using guessed type int dword_80EF4E8;
// 80EF5B8: using guessed type int dl_pagesize;

//----- (0804F810) --------------------------------------------------------
unsigned int __cdecl malloc_usable_size(int a1)
{
  unsigned int result; // eax
  int v2; // ecx
  unsigned int v3; // ecx

  result = 0;
  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 - 4);
    if ( (v2 & 2) != 0 )
    {
      return (v2 & 0xFFFFFFF8) - 8;
    }
    else
    {
      v3 = v2 & 0xFFFFFFF8;
      if ( (*(_BYTE *)(a1 + v3 - 4) & 1) != 0 )
        return v3 - 4;
    }
  }
  return result;
}

//----- (0804F850) --------------------------------------------------------
void malloc_stats()
{
  int v0; // edi
  int v2; // esi
  bool v4; // zf
  int v5; // ebp
  int v6; // [esp+14h] [ebp-58h]
  int v7; // [esp+18h] [ebp-54h]
  int v8; // [esp+1Ch] [ebp-50h]
  int v9[17]; // [esp+28h] [ebp-44h] BYREF

  v0 = dword_80EF524;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init();
  _EBX = &main_arena;
  v2 = 0;
  v7 = v0;
  v8 = *(_DWORD *)(stderr + 60);
  *(_DWORD *)(stderr + 60) = v8 | 2;
  while ( 1 )
  {
    _ECX = 1;
    v4 = __readgsdword(0xCu) == 0;
    if ( !v4 )
      __asm { lock }
    __asm { cmpxchg [ebx], ecx }
    if ( !v4 )
    {
      L_lock_12841(0, _EBX);
      return;
    }
    mALLINFo(v9, _EBX);
    v5 = v9[7];
    v6 = v9[0];
    fprintf(stderr, (int)"Arena %d:\n", v2);
    fprintf(stderr, (int)"system bytes     = %10u\n", v6);
    fprintf(stderr, (int)"in use bytes     = %10u\n", v5);
    v0 += v6;
    v7 += v5;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v4 = (*_EBX)-- == 1;
    if ( !v4 )
      break;
    _EBX = (int *)_EBX[272];
    if ( _EBX == &main_arena )
    {
      fwrite((int)"Total (incl. mmap):\n", 1, 20, (_DWORD *)stderr);
      fprintf(stderr, (int)"system bytes     = %10u\n", v0);
      fprintf(stderr, (int)"in use bytes     = %10u\n", v7);
      fprintf(stderr, (int)"max mmap regions = %10u\n", dword_80EF51C);
      fprintf(stderr, (int)"max mmap bytes   = %10lu\n", dword_80EF528);
      *(_DWORD *)(stderr + 60) |= v8;
      return;
    }
    ++v2;
  }
  L_unlock_12879(_EBX);
}
// 80EF080: using guessed type int _libc_malloc_initialized;
// 80EF0A0: using guessed type int main_arena;
// 80EF51C: using guessed type int dword_80EF51C;
// 80EF524: using guessed type int dword_80EF524;
// 80EF528: using guessed type int dword_80EF528;

//----- (0804FA00) --------------------------------------------------------
void __stdcall mallinfo(int *a1)
{
  bool v2; // zf

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init();
  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg main_arena, ecx }
  if ( v2 )
  {
    mALLINFo(a1, &main_arena);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --main_arena )
      L_unlock_12976((int)a1);
  }
  else
  {
    L_lock_12970(0, (int)a1);
  }
}
// 80EF080: using guessed type int _libc_malloc_initialized;
// 80EF0A0: using guessed type int main_arena;

//----- (0804FA70) --------------------------------------------------------
void __cdecl mallopt(int a1, int a2)
{
  mALLOPt(a1, a2);
}

//----- (0804FA80) --------------------------------------------------------
int __cdecl posix_memalign(int *a1, unsigned int a2, unsigned int a3)
{
  int result; // eax
  int v4; // eax
  int v5; // edx
  void *retaddr; // [esp+1Ch] [ebp+0h]

  result = 22;
  if ( (a2 & 3) == 0 )
  {
    if ( ((a2 >> 2) & ((a2 >> 2) - 1)) != 0 || !a2 )
    {
      return 22;
    }
    else
    {
      if ( _memalign_hook )
      {
        v5 = _memalign_hook(a2, a3, retaddr);
      }
      else
      {
        memalign(a2, a3);
        v5 = v4;
      }
      result = 12;
      if ( v5 )
      {
        *a1 = v5;
        return 0;
      }
    }
  }
  return result;
}
// 804FAD1: variable 'v4' is possibly undefined
// 80EF084: using guessed type int (__cdecl *_memalign_hook)(_DWORD, _DWORD, _DWORD);

//----- (0804FB00) --------------------------------------------------------
int __cdecl malloc_info(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // edx
  int *v4; // ebx
  size_t v5; // [esp+38h] [ebp-34h] BYREF
  size_t v6; // [esp+3Ch] [ebp-30h]
  size_t v7; // [esp+40h] [ebp-2Ch]
  size_t v8; // [esp+44h] [ebp-28h]
  size_t v9; // [esp+48h] [ebp-24h]
  size_t v10; // [esp+4Ch] [ebp-20h]
  size_t v11; // [esp+50h] [ebp-1Ch]
  size_t v12; // [esp+54h] [ebp-18h]
  _DWORD *v13; // [esp+58h] [ebp-14h]
  int v14; // [esp+5Ch] [ebp-10h]

  result = 22;
  v3 = (_DWORD *)a2;
  v13 = (_DWORD *)a2;
  if ( !a1 )
  {
    v14 = 0;
    v10 = 0;
    v12 = 0;
    v9 = 0;
    v11 = 0;
    v8 = 0;
    v7 = 0;
    v6 = 0;
    v5 = 0;
    if ( _libc_malloc_initialized < 0 )
    {
      ptmalloc_init();
      v3 = v13;
    }
    v4 = &main_arena;
    fputs("<malloc version=\"1\">\n", v3);
    do
    {
      mi_arena_10548(v4, &v5);
      v4 = (int *)v4[272];
    }
    while ( v4 != &main_arena );
    fprintf(
      (int)v13,
      (int)"<total type=\"fast\" count=\"%zu\" size=\"%zu\"/>\n"
           "<total type=\"rest\" count=\"%zu\" size=\"%zu\"/>\n"
           "<system type=\"current\" size=\"%zu\"/>\n"
           "<system type=\"max\" size=\"%zu\"/>\n"
           "<aspace type=\"total\" size=\"%zu\"/>\n"
           "<aspace type=\"mprotect\" size=\"%zu\"/>\n"
           "</malloc>\n",
      v12,
      v11,
      v10,
      v9,
      v8,
      v7,
      v6,
      v5);
    return 0;
  }
  return result;
}
// 80EF080: using guessed type int _libc_malloc_initialized;
// 80EF0A0: using guessed type int main_arena;

//----- (0804FC16) --------------------------------------------------------
void __usercall L_lock_33(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &list_lock);
  JUMPOUT(0x8049E39);
}
// 804FC21: control flows out of bounds to 8049E39
// 80F0598: using guessed type int list_lock;

//----- (0804FC26) --------------------------------------------------------
void __usercall L_lock_50(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x8049E60);
}
// 804FC2D: control flows out of bounds to 8049E60

//----- (0804FC32) --------------------------------------------------------
void __usercall L_lock_929(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804A501);
}
// 804FC39: control flows out of bounds to 804A501

//----- (0804FC3E) --------------------------------------------------------
void __fastcall L_unlock_1146(_DWORD *a1)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804A6D0);
}
// 804FC45: control flows out of bounds to 804A6D0

//----- (0804FC4A) --------------------------------------------------------
void __fastcall L_unlock_1541(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x804AA6C);
}
// 804FC51: control flows out of bounds to 804AA6C

//----- (0804FC56) --------------------------------------------------------
void L_unlock_1550()
{
  _lll_unlock_wake_private(&list_lock);
  JUMPOUT(0x804AA92);
}
// 804FC61: control flows out of bounds to 804AA92
// 80F0598: using guessed type int list_lock;

//----- (0804FC66) --------------------------------------------------------
void __usercall L_lock_3402(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804B619);
}
// 804FC6D: control flows out of bounds to 804B619

//----- (0804FC72) --------------------------------------------------------
void __fastcall L_unlock_3551(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x804B708);
}
// 804FC79: control flows out of bounds to 804B708

//----- (0804FC7E) --------------------------------------------------------
void __usercall L_lock_3877(int a1@<eax>, volatile __int32 *a2@<ebp>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804B8C3);
}
// 804FC86: control flows out of bounds to 804B8C3

//----- (0804FC8B) --------------------------------------------------------
void __fastcall L_unlock_3891(_DWORD *a1)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804B8EE);
}
// 804FC92: control flows out of bounds to 804B8EE

//----- (0804FC97) --------------------------------------------------------
void __fastcall L_unlock_3935(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x804B926);
}
// 804FC9E: control flows out of bounds to 804B926

//----- (0804FCA3) --------------------------------------------------------
void __usercall L_lock_7025(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804CC6C);
}
// 804FCAE: control flows out of bounds to 804CC6C
// 80EF0A0: using guessed type int main_arena;

//----- (0804FCB3) --------------------------------------------------------
void L_unlock_7042()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804CC9E);
}
// 804FCBE: control flows out of bounds to 804CC9E
// 80EF0A0: using guessed type int main_arena;

//----- (0804FCC3) --------------------------------------------------------
void __usercall L_lock_7415(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804CF5F);
}
// 804FCCE: control flows out of bounds to 804CF5F
// 80EF0A0: using guessed type int main_arena;

//----- (0804FCD3) --------------------------------------------------------
void L_unlock_7433()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804CF93);
}
// 804FCDE: control flows out of bounds to 804CF93
// 80EF0A0: using guessed type int main_arena;

//----- (0804FCE3) --------------------------------------------------------
void __usercall L_lock_8098(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804D40B);
}
// 804FCEE: control flows out of bounds to 804D40B
// 80EF0A0: using guessed type int main_arena;

//----- (0804FCF3) --------------------------------------------------------
void L_unlock_8121()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804D447);
}
// 804FCFE: control flows out of bounds to 804D447
// 80EF0A0: using guessed type int main_arena;

//----- (0804FD03) --------------------------------------------------------
void L_unlock_8139()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804D468);
}
// 804FD0E: control flows out of bounds to 804D468
// 80EF0A0: using guessed type int main_arena;

//----- (0804FD13) --------------------------------------------------------
void L_unlock_8155()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804D490);
}
// 804FD1E: control flows out of bounds to 804D490
// 80EF0A0: using guessed type int main_arena;

//----- (0804FD23) --------------------------------------------------------
void __usercall L_lock_8199(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804D505);
}
// 804FD2E: control flows out of bounds to 804D505
// 80EF0A0: using guessed type int main_arena;

//----- (0804FD33) --------------------------------------------------------
void L_unlock_8210()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804D52C);
}
// 804FD3E: control flows out of bounds to 804D52C
// 80EF0A0: using guessed type int main_arena;

//----- (0804FD43) --------------------------------------------------------
void __usercall L_lock_8242(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804D58C);
}
// 804FD4E: control flows out of bounds to 804D58C
// 80EF0A0: using guessed type int main_arena;

//----- (0804FD53) --------------------------------------------------------
void L_unlock_8280()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804D5E4);
}
// 804FD5E: control flows out of bounds to 804D5E4
// 80EF0A0: using guessed type int main_arena;

//----- (0804FD63) --------------------------------------------------------
void __usercall L_lock_8453(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &list_lock);
  JUMPOUT(0x804D710);
}
// 804FD6E: control flows out of bounds to 804D710
// 80F0598: using guessed type int list_lock;

//----- (0804FD73) --------------------------------------------------------
void L_unlock_8466()
{
  _lll_unlock_wake_private(&list_lock);
  JUMPOUT(0x804D73D);
}
// 804FD7E: control flows out of bounds to 804D73D
// 80F0598: using guessed type int list_lock;

//----- (0804FD83) --------------------------------------------------------
void __usercall L_lock_8474(int a1@<eax>, volatile __int32 *a2@<ebx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804D75C);
}
// 804FD8A: control flows out of bounds to 804D75C

//----- (0804FD8F) --------------------------------------------------------
void __usercall L_lock_8634(int a1@<eax>, volatile __int32 *a2@<ebx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804D81F);
}
// 804FD96: control flows out of bounds to 804D81F

//----- (0804FD9B) --------------------------------------------------------
void __usercall L_lock_8829(int a1@<eax>, volatile __int32 *a2@<ebx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804D93F);
}
// 804FDA2: control flows out of bounds to 804D93F

//----- (0804FDA7) --------------------------------------------------------
void __usercall L_lock_8834(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &list_lock);
  JUMPOUT(0x804D95B);
}
// 804FDB2: control flows out of bounds to 804D95B
// 80F0598: using guessed type int list_lock;

//----- (0804FDB7) --------------------------------------------------------
void L_unlock_8841()
{
  _lll_unlock_wake_private(&list_lock);
  JUMPOUT(0x804D984);
}
// 804FDC2: control flows out of bounds to 804D984
// 80F0598: using guessed type int list_lock;

//----- (0804FDC7) --------------------------------------------------------
void __usercall L_lock_9436(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804DE2B);
}
// 804FDD2: control flows out of bounds to 804DE2B
// 80EF0A0: using guessed type int main_arena;

//----- (0804FDD7) --------------------------------------------------------
void L_unlock_9453()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804DE60);
}
// 804FDE2: control flows out of bounds to 804DE60
// 80EF0A0: using guessed type int main_arena;

//----- (0804FDE7) --------------------------------------------------------
void __usercall L_lock_9599(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804DFE2);
}
// 804FDF2: control flows out of bounds to 804DFE2
// 80EF0A0: using guessed type int main_arena;

//----- (0804FDF7) --------------------------------------------------------
void L_unlock_9894()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804E305);
}
// 804FE02: control flows out of bounds to 804E305
// 80EF0A0: using guessed type int main_arena;

//----- (0804FE07) --------------------------------------------------------
void __usercall L_lock_10019(int a1@<eax>, volatile __int32 *a2@<edi>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804E41A);
}
// 804FE0E: control flows out of bounds to 804E41A

//----- (0804FE13) --------------------------------------------------------
void __usercall L_unlock_10041(_DWORD *a1@<edi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804E43D);
}
// 804FE1A: control flows out of bounds to 804E43D

//----- (0804FE1F) --------------------------------------------------------
void __usercall L_unlock_10098(_DWORD *a1@<edi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804E498);
}
// 804FE26: control flows out of bounds to 804E498

//----- (0804FE2B) --------------------------------------------------------
void __usercall L_lock_10105(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804E4B7);
}
// 804FE36: control flows out of bounds to 804E4B7
// 80EF0A0: using guessed type int main_arena;

//----- (0804FE3B) --------------------------------------------------------
void L_unlock_10114()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804E4DD);
}
// 804FE46: control flows out of bounds to 804E4DD
// 80EF0A0: using guessed type int main_arena;

//----- (0804FE4B) --------------------------------------------------------
void L_unlock_10171()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804E532);
}
// 804FE56: control flows out of bounds to 804E532
// 80EF0A0: using guessed type int main_arena;

//----- (0804FE5B) --------------------------------------------------------
void __usercall L_unlock_10190(_DWORD *a1@<edi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804E567);
}
// 804FE62: control flows out of bounds to 804E567

//----- (0804FE67) --------------------------------------------------------
void __usercall L_lock_10248(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &list_lock);
  JUMPOUT(0x804E5D2);
}
// 804FE72: control flows out of bounds to 804E5D2
// 80F0598: using guessed type int list_lock;

//----- (0804FE77) --------------------------------------------------------
void L_unlock_10251()
{
  _lll_unlock_wake_private(&list_lock);
  JUMPOUT(0x804E5EA);
}
// 804FE82: control flows out of bounds to 804E5EA
// 80F0598: using guessed type int list_lock;

//----- (0804FE87) --------------------------------------------------------
void __usercall L_lock_10365(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804E6AA);
}
// 804FE92: control flows out of bounds to 804E6AA
// 80EF0A0: using guessed type int main_arena;

//----- (0804FE97) --------------------------------------------------------
void L_unlock_10447()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804E80D);
}
// 804FEA2: control flows out of bounds to 804E80D
// 80EF0A0: using guessed type int main_arena;

//----- (0804FEA7) --------------------------------------------------------
void __usercall L_lock_10645(int a1@<eax>, volatile __int32 *a2@<esi>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804E967);
}
// 804FEAE: control flows out of bounds to 804E967

//----- (0804FEB3) --------------------------------------------------------
void __usercall L_unlock_10658(_DWORD *a1@<esi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804E991);
}
// 804FEBA: control flows out of bounds to 804E991

//----- (0804FEBF) --------------------------------------------------------
void __usercall L_lock_10980(int a1@<eax>, volatile __int32 *a2@<edi>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804EBD6);
}
// 804FEC6: control flows out of bounds to 804EBD6

//----- (0804FECB) --------------------------------------------------------
void __usercall L_unlock_11003(_DWORD *a1@<edi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804EBFB);
}
// 804FED2: control flows out of bounds to 804EBFB

//----- (0804FED7) --------------------------------------------------------
void __usercall L_unlock_11078(_DWORD *a1@<edi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804EC78);
}
// 804FEDE: control flows out of bounds to 804EC78

//----- (0804FEE3) --------------------------------------------------------
void __usercall L_lock_11085(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804EC97);
}
// 804FEEE: control flows out of bounds to 804EC97
// 80EF0A0: using guessed type int main_arena;

//----- (0804FEF3) --------------------------------------------------------
void L_unlock_11095()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804ECBF);
}
// 804FEFE: control flows out of bounds to 804ECBF
// 80EF0A0: using guessed type int main_arena;

//----- (0804FF03) --------------------------------------------------------
void L_unlock_11163()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804ED3A);
}
// 804FF0E: control flows out of bounds to 804ED3A
// 80EF0A0: using guessed type int main_arena;

//----- (0804FF13) --------------------------------------------------------
void __usercall L_unlock_11183(_DWORD *a1@<edi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804ED71);
}
// 804FF1A: control flows out of bounds to 804ED71

//----- (0804FF1F) --------------------------------------------------------
void __usercall L_lock_11280(int a1@<eax>, volatile __int32 *a2@<esi>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804EE31);
}
// 804FF26: control flows out of bounds to 804EE31

//----- (0804FF2B) --------------------------------------------------------
void __usercall L_unlock_11320(_DWORD *a1@<esi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804EE60);
}
// 804FF32: control flows out of bounds to 804EE60

//----- (0804FF37) --------------------------------------------------------
void __usercall L_unlock_11397(_DWORD *a1@<esi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804EED0);
}
// 804FF3E: control flows out of bounds to 804EED0

//----- (0804FF43) --------------------------------------------------------
void __usercall L_lock_11403(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804EEEF);
}
// 804FF4E: control flows out of bounds to 804EEEF
// 80EF0A0: using guessed type int main_arena;

//----- (0804FF53) --------------------------------------------------------
void L_unlock_11412()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804EF17);
}
// 804FF5E: control flows out of bounds to 804EF17
// 80EF0A0: using guessed type int main_arena;

//----- (0804FF63) --------------------------------------------------------
void L_unlock_11486()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804EF82);
}
// 804FF6E: control flows out of bounds to 804EF82
// 80EF0A0: using guessed type int main_arena;

//----- (0804FF73) --------------------------------------------------------
void __usercall L_unlock_11505(_DWORD *a1@<esi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804EFB9);
}
// 804FF7A: control flows out of bounds to 804EFB9

//----- (0804FF7F) --------------------------------------------------------
void __usercall L_lock_11594(int a1@<eax>, volatile __int32 *a2@<esi>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804F06B);
}
// 804FF86: control flows out of bounds to 804F06B

//----- (0804FF8B) --------------------------------------------------------
void __usercall L_unlock_11640(_DWORD *a1@<esi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804F0A6);
}
// 804FF92: control flows out of bounds to 804F0A6

//----- (0804FF97) --------------------------------------------------------
void __usercall L_unlock_11718(_DWORD *a1@<esi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804F118);
}
// 804FF9E: control flows out of bounds to 804F118

//----- (0804FFA3) --------------------------------------------------------
void __usercall L_lock_11724(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804F137);
}
// 804FFAE: control flows out of bounds to 804F137
// 80EF0A0: using guessed type int main_arena;

//----- (0804FFB3) --------------------------------------------------------
void L_unlock_11733()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804F15F);
}
// 804FFBE: control flows out of bounds to 804F15F
// 80EF0A0: using guessed type int main_arena;

//----- (0804FFC3) --------------------------------------------------------
void L_unlock_11811()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804F1C2);
}
// 804FFCE: control flows out of bounds to 804F1C2
// 80EF0A0: using guessed type int main_arena;

//----- (0804FFD3) --------------------------------------------------------
void __usercall L_unlock_11831(_DWORD *a1@<esi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804F1FF);
}
// 804FFDA: control flows out of bounds to 804F1FF

//----- (0804FFDF) --------------------------------------------------------
void __usercall L_lock_11918(int a1@<eax>, volatile __int32 *a2@<edi>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804F2AA);
}
// 804FFE6: control flows out of bounds to 804F2AA

//----- (0804FFEB) --------------------------------------------------------
void __usercall L_unlock_11987(_DWORD *a1@<edi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804F317);
}
// 804FFF2: control flows out of bounds to 804F317

//----- (0804FFF7) --------------------------------------------------------
void __usercall L_unlock_12108(_DWORD *a1@<edi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804F3F8);
}
// 804FFFE: control flows out of bounds to 804F3F8

//----- (08050003) --------------------------------------------------------
void __usercall L_lock_12114(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804F417);
}
// 805000E: control flows out of bounds to 804F417
// 80EF0A0: using guessed type int main_arena;

//----- (08050013) --------------------------------------------------------
void L_unlock_12123()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804F43F);
}
// 805001E: control flows out of bounds to 804F43F
// 80EF0A0: using guessed type int main_arena;

//----- (08050023) --------------------------------------------------------
void L_unlock_12214()
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804F4D2);
}
// 805002E: control flows out of bounds to 804F4D2
// 80EF0A0: using guessed type int main_arena;

//----- (08050033) --------------------------------------------------------
void __usercall L_unlock_12233(_DWORD *a1@<edi>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804F50B);
}
// 805003A: control flows out of bounds to 804F50B

//----- (0805003F) --------------------------------------------------------
void __usercall L_lock_12371(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804F5F3);
}
// 8050046: control flows out of bounds to 804F5F3

//----- (0805004B) --------------------------------------------------------
void __fastcall L_unlock_12552(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x804F713);
}
// 8050052: control flows out of bounds to 804F713

//----- (08050057) --------------------------------------------------------
void __usercall L_lock_12841(int a1@<eax>, volatile __int32 *a2@<ebx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x804F8AE);
}
// 805005E: control flows out of bounds to 804F8AE

//----- (08050063) --------------------------------------------------------
void __usercall L_unlock_12879(_DWORD *a1@<ebx>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x804F930);
}
// 805006A: control flows out of bounds to 804F930

//----- (0805006F) --------------------------------------------------------
void __userpurge L_lock_12970(int a1@<eax>, int a2)
{
  _lll_lock_wait_private(a1, &main_arena);
  JUMPOUT(0x804FA30);
}
// 805007A: control flows out of bounds to 804FA30
// 80EF0A0: using guessed type int main_arena;

//----- (0805007F) --------------------------------------------------------
void __stdcall L_unlock_12976(int a1)
{
  _lll_unlock_wake_private(&main_arena);
  JUMPOUT(0x804FA54);
}
// 805008A: control flows out of bounds to 804FA54
// 80EF0A0: using guessed type int main_arena;

//----- (08050090) --------------------------------------------------------
int __cdecl _default_morecore(int a1)
{
  int result; // eax

  result = sbrk(a1);
  if ( result == -1 )
    return 0;
  return result;
}

//----- (080500B0) --------------------------------------------------------
int __cdecl strlen(_BYTE *a1)
{
  _BYTE *v1; // eax
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  bool v5; // cf
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  int v16; // edx
  int v17; // ecx

  v1 = a1;
  v2 = (unsigned __int8)a1 & 3;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( __SETP__((unsigned __int8)a1 & 3, 0) )
      goto LABEL_6;
    if ( *a1 == BYTE1(v2) )
      return v1 - a1;
    v1 = a1 + 1;
    if ( a1[1] == BYTE1(v2) )
      return v1 - a1;
    v1 = a1 + 2;
    v2 ^= 2u;
    if ( v2 )
    {
LABEL_6:
      if ( *v1 == BYTE1(v2) )
        return v1 - a1;
      ++v1;
      v2 = 0;
    }
  }
  do
  {
    v3 = *(_DWORD *)v1;
    v1 += 4;
    v4 = v2 - v3;
    v5 = __CFADD__(v3, -16843009);
    v6 = v3 - 16843009;
    v7 = v4 - 1;
    if ( !v5 )
      break;
    if ( ((v6 ^ v7) & 0x1010100) != 0 )
      break;
    v8 = *(_DWORD *)v1;
    v1 += 4;
    v9 = -v8;
    v5 = __CFADD__(v8, -16843009);
    v6 = v8 - 16843009;
    v10 = v9 - 1;
    if ( !v5 )
      break;
    if ( ((v6 ^ v10) & 0x1010100) != 0 )
      break;
    v11 = *(_DWORD *)v1;
    v1 += 4;
    v12 = -v11;
    v5 = __CFADD__(v11, -16843009);
    v6 = v11 - 16843009;
    v13 = v12 - 1;
    if ( !v5 )
      break;
    if ( ((v6 ^ v13) & 0x1010100) != 0 )
      break;
    v14 = *(_DWORD *)v1;
    v1 += 4;
    v15 = -v14;
    v5 = __CFADD__(v14, -16843009);
    v6 = v14 - 16843009;
    v16 = v15 - 1;
    if ( !v5 )
      break;
    v2 = (v6 ^ v16) & 0x1010100;
  }
  while ( !v2 );
  v1 -= 4;
  v17 = v6 + 16843009;
  if ( (_BYTE)v17 )
  {
    ++v1;
    if ( BYTE1(v17) )
    {
      ++v1;
      if ( BYTE2(v17) )
        ++v1;
    }
  }
  return v1 - a1;
}

//----- (08050170) --------------------------------------------------------
int (__cdecl *memcmp())(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  int (__cdecl *result)(unsigned __int8 *, unsigned __int8 *, unsigned int); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (int (__cdecl *)(unsigned __int8 *, unsigned __int8 *, unsigned int))_memcmp_ia32;
  if ( (dword_80F1270 & 0x200) != 0 )
  {
    result = (int (__cdecl *)(unsigned __int8 *, unsigned __int8 *, unsigned int))_memcmp_ssse3;
    if ( (dword_80F1270 & 0x100000) != 0 )
      return _memcmp_sse4_2;
  }
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1270: using guessed type int dword_80F1270;

//----- (080501B0) --------------------------------------------------------
int __cdecl _memcmp_ia32(unsigned int *a1, unsigned int *a2, int a3)
{
  unsigned int *v3; // edx
  int v4; // ecx
  int result; // eax
  unsigned int *v6; // esi
  char *v7; // edx
  char *v8; // esi
  unsigned int v9; // eax
  unsigned int v10; // ecx
  unsigned __int8 v11; // al
  bool v12; // cf
  unsigned int v13; // eax
  unsigned int v14; // ecx
  unsigned int v15; // eax
  unsigned int v16; // ecx
  unsigned __int8 v17; // al
  unsigned int v18; // eax
  unsigned int v19; // ecx

  v3 = a2;
  v4 = a3;
  if ( a3 == 1 )
  {
    if ( *(_BYTE *)a1 == *(_BYTE *)a2 )
      return 0;
    return -(*(_BYTE *)a1 < *(_BYTE *)a2) - ((*(_BYTE *)a1 < *(_BYTE *)a2) - 1);
  }
  else
  {
    if ( a3 < 1 )
      return 0;
    v6 = a1;
    if ( a3 < 32 )
    {
      v7 = (char *)a2 + a3;
      v8 = (char *)a1 + a3;
      switch ( a3 )
      {
        case 0:
          return 0;
        case 1:
          goto LABEL_23;
        case 2:
          goto LABEL_32;
        case 3:
          goto LABEL_42;
        case 4:
          goto LABEL_14;
        case 5:
          goto LABEL_22;
        case 6:
          goto LABEL_31;
        case 7:
          goto LABEL_41;
        case 8:
          goto LABEL_13;
        case 9:
          goto LABEL_21;
        case 10:
          goto LABEL_30;
        case 11:
          goto LABEL_40;
        case 12:
          goto LABEL_12;
        case 13:
          goto LABEL_20;
        case 14:
          goto LABEL_29;
        case 15:
          goto LABEL_39;
        case 16:
          goto LABEL_11;
        case 17:
          goto LABEL_19;
        case 18:
          goto LABEL_28;
        case 19:
          goto LABEL_38;
        case 20:
          goto LABEL_10;
        case 21:
          goto LABEL_18;
        case 22:
          goto LABEL_27;
        case 23:
          goto LABEL_37;
        case 24:
          goto LABEL_9;
        case 25:
          goto LABEL_17;
        case 26:
          goto LABEL_26;
        case 27:
          goto LABEL_36;
        case 28:
          goto LABEL_8;
        case 29:
          goto LABEL_16;
        case 30:
          goto LABEL_25;
        case 31:
          goto LABEL_35;
      }
    }
    do
    {
      v4 -= 32;
      v9 = *v6;
      if ( *v6 != *v3 )
        goto LABEL_63;
      v9 = v6[1];
      if ( v9 != v3[1] )
        goto LABEL_62;
      v9 = v6[2];
      if ( v9 != v3[2] )
        goto LABEL_61;
      v9 = v6[3];
      if ( v9 != v3[3] )
        goto LABEL_60;
      v9 = v6[4];
      if ( v9 != v3[4] )
        goto LABEL_59;
      v9 = v6[5];
      if ( v9 != v3[5] )
        goto LABEL_58;
      v9 = v6[6];
      if ( v9 != v3[6] )
        goto LABEL_57;
      v9 = v6[7];
      if ( v9 != v3[7] )
      {
        ++v3;
LABEL_57:
        ++v3;
LABEL_58:
        ++v3;
LABEL_59:
        ++v3;
LABEL_60:
        ++v3;
LABEL_61:
        ++v3;
LABEL_62:
        ++v3;
LABEL_63:
        v10 = *v3;
LABEL_64:
        v12 = (unsigned __int8)v9 < (unsigned __int8)v10;
        if ( (_BYTE)v9 == (_BYTE)v10 )
        {
          v12 = BYTE1(v9) < BYTE1(v10);
          if ( BYTE1(v9) == BYTE1(v10) )
          {
            v18 = HIWORD(v9);
            v19 = HIWORD(v10);
            v12 = (unsigned __int8)v18 < (unsigned __int8)v19;
            if ( (_BYTE)v18 == (_BYTE)v19 )
              v12 = v18 < v19;
          }
        }
        return -v12 - (v12 - 1);
      }
      v6 += 8;
      v3 += 8;
    }
    while ( v4 >= 32 );
    v7 = (char *)v3 + v4;
    v8 = (char *)v6 + v4;
    switch ( v4 )
    {
      case 0:
        return 0;
      case 1:
        goto LABEL_23;
      case 2:
        goto LABEL_32;
      case 3:
        goto LABEL_42;
      case 4:
        goto LABEL_14;
      case 5:
        goto LABEL_22;
      case 6:
        goto LABEL_31;
      case 7:
        goto LABEL_41;
      case 8:
        goto LABEL_13;
      case 9:
        goto LABEL_21;
      case 10:
        goto LABEL_30;
      case 11:
        goto LABEL_40;
      case 12:
        goto LABEL_12;
      case 13:
        goto LABEL_20;
      case 14:
        goto LABEL_29;
      case 15:
        goto LABEL_39;
      case 16:
        goto LABEL_11;
      case 17:
        goto LABEL_19;
      case 18:
        goto LABEL_28;
      case 19:
        goto LABEL_38;
      case 20:
        goto LABEL_10;
      case 21:
        goto LABEL_18;
      case 22:
        goto LABEL_27;
      case 23:
        goto LABEL_37;
      case 24:
        goto LABEL_9;
      case 25:
        goto LABEL_17;
      case 26:
        goto LABEL_26;
      case 27:
        goto LABEL_36;
      case 28:
LABEL_8:
        v9 = *((_DWORD *)v8 - 7);
        v10 = *((_DWORD *)v7 - 7);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_9:
        v9 = *((_DWORD *)v8 - 6);
        v10 = *((_DWORD *)v7 - 6);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_10:
        v9 = *((_DWORD *)v8 - 5);
        v10 = *((_DWORD *)v7 - 5);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_11:
        v9 = *((_DWORD *)v8 - 4);
        v10 = *((_DWORD *)v7 - 4);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_12:
        v9 = *((_DWORD *)v8 - 3);
        v10 = *((_DWORD *)v7 - 3);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_13:
        v9 = *((_DWORD *)v8 - 2);
        v10 = *((_DWORD *)v7 - 2);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_14:
        v9 = *((_DWORD *)v8 - 1);
        v10 = *((_DWORD *)v7 - 1);
        if ( v9 != v10 )
          goto LABEL_64;
        return 0;
      case 29:
LABEL_16:
        v9 = *(_DWORD *)(v8 - 29);
        v10 = *(_DWORD *)(v7 - 29);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_17:
        v9 = *(_DWORD *)(v8 - 25);
        v10 = *(_DWORD *)(v7 - 25);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_18:
        v9 = *(_DWORD *)(v8 - 21);
        v10 = *(_DWORD *)(v7 - 21);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_19:
        v9 = *(_DWORD *)(v8 - 17);
        v10 = *(_DWORD *)(v7 - 17);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_20:
        v9 = *(_DWORD *)(v8 - 13);
        v10 = *(_DWORD *)(v7 - 13);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_21:
        v9 = *(_DWORD *)(v8 - 9);
        v10 = *(_DWORD *)(v7 - 9);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_22:
        v9 = *(_DWORD *)(v8 - 5);
        v10 = *(_DWORD *)(v7 - 5);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_23:
        v11 = *(v8 - 1);
        v12 = v11 < (unsigned __int8)*(v7 - 1);
        if ( v11 != *(v7 - 1) )
          return -v12 - (v12 - 1);
        result = 0;
        break;
      case 30:
LABEL_25:
        v9 = *(_DWORD *)(v8 - 30);
        v10 = *(_DWORD *)(v7 - 30);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_26:
        v9 = *(_DWORD *)(v8 - 26);
        v10 = *(_DWORD *)(v7 - 26);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_27:
        v9 = *(_DWORD *)(v8 - 22);
        v10 = *(_DWORD *)(v7 - 22);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_28:
        v9 = *(_DWORD *)(v8 - 18);
        v10 = *(_DWORD *)(v7 - 18);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_29:
        v9 = *(_DWORD *)(v8 - 14);
        v10 = *(_DWORD *)(v7 - 14);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_30:
        v9 = *(_DWORD *)(v8 - 10);
        v10 = *(_DWORD *)(v7 - 10);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_31:
        v9 = *(_DWORD *)(v8 - 6);
        v10 = *(_DWORD *)(v7 - 6);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_32:
        v13 = *((unsigned __int16 *)v8 - 1);
        v14 = *((unsigned __int16 *)v7 - 1);
        v12 = (unsigned __int8)v13 < (unsigned __int8)v14;
        if ( (_BYTE)v13 != (_BYTE)v14 )
          return -v12 - (v12 - 1);
        v12 = v13 < v14;
        if ( v13 != v14 )
          return -v12 - (v12 - 1);
        result = 0;
        break;
      case 31:
LABEL_35:
        v9 = *(_DWORD *)(v8 - 31);
        v10 = *(_DWORD *)(v7 - 31);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_36:
        v9 = *(_DWORD *)(v8 - 27);
        v10 = *(_DWORD *)(v7 - 27);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_37:
        v9 = *(_DWORD *)(v8 - 23);
        v10 = *(_DWORD *)(v7 - 23);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_38:
        v9 = *(_DWORD *)(v8 - 19);
        v10 = *(_DWORD *)(v7 - 19);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_39:
        v9 = *(_DWORD *)(v8 - 15);
        v10 = *(_DWORD *)(v7 - 15);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_40:
        v9 = *(_DWORD *)(v8 - 11);
        v10 = *(_DWORD *)(v7 - 11);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_41:
        v9 = *(_DWORD *)(v8 - 7);
        v10 = *(_DWORD *)(v7 - 7);
        if ( v9 != v10 )
          goto LABEL_64;
LABEL_42:
        v15 = *(unsigned __int16 *)(v8 - 3);
        v16 = *(unsigned __int16 *)(v7 - 3);
        v12 = (unsigned __int8)v15 < (unsigned __int8)v16;
        if ( (_BYTE)v15 != (_BYTE)v16 )
          return -v12 - (v12 - 1);
        v12 = v15 < v16;
        if ( v15 != v16 )
          return -v12 - (v12 - 1);
        v17 = *(v8 - 1);
        v12 = v17 < (unsigned __int8)*(v7 - 1);
        if ( v17 != *(v7 - 1) )
          return -v12 - (v12 - 1);
        result = 0;
        break;
    }
  }
  return result;
}

//----- (080504A0) --------------------------------------------------------
int (__cdecl *memset())(int a1, unsigned __int8 a2, unsigned int a3)
{
  int (__cdecl *result)(int, unsigned __int8, unsigned int); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (int (__cdecl *)(int, unsigned __int8, unsigned int))_memset_ia32;
  if ( (dword_80F1274 & 0x4000000) != 0 )
  {
    result = _memset_sse2;
    if ( (dword_80F1290 & 1) != 0 )
      return _memset_sse2_rep;
  }
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1274: using guessed type int dword_80F1274;
// 80F1290: using guessed type int dword_80F1290;

//----- (080504E0) --------------------------------------------------------
unsigned __int8 *__cdecl _memset_ia32(unsigned __int8 *a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int v3; // ecx
  unsigned __int8 *v4; // edi
  int v5; // edx
  char v6; // dl
  unsigned int v7; // ecx

  v3 = a3;
  if ( a3 )
  {
    v4 = a1;
    v5 = (unsigned __int8)a1 & 3;
    if ( ((unsigned __int8)a1 & 3) == 0 )
    {
LABEL_8:
      v6 = v3;
      v7 = v3 >> 2;
      memset32(v4, 16843009 * a2, v7);
      memset(&v4[4 * v7], a2, v6 & 3);
      return a1;
    }
    if ( __SETP__(v5, 0) || (*a1 = a2, v4 = a1 + 1, v3 = a3 - 1, a3 != 1) )
    {
      *v4++ = a2;
      if ( --v3 )
      {
        if ( v5 == 1 )
        {
          *v4++ = a2;
          --v3;
        }
        goto LABEL_8;
      }
    }
  }
  return a1;
}

//----- (08050530) --------------------------------------------------------
_WORD *__cdecl mempcpy(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  _WORD *v3; // edi
  _WORD *v4; // esi
  unsigned int v5; // ecx

  v3 = a1;
  v4 = a2;
  if ( a3 & 1 )
  {
    *a1 = *a2;
    v4 = a2 + 1;
    v3 = a1 + 1;
  }
  v5 = a3 >> 2;
  if ( (a3 & 2) != 0 )
    *v3++ = *v4++;
  qmemcpy(v3, v4, 4 * v5);
  return &v3[2 * v5];
}

//----- (08050560) --------------------------------------------------------
_BYTE *__cdecl memcpy(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  _WORD *v3; // edi
  _WORD *v4; // esi
  unsigned int v5; // ecx

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( (((unsigned __int8)a2 ^ (unsigned __int8)a1) & 3) != 0 || a3 <= 3 )
  {
    if ( a3 & 1 )
    {
      *a1 = *a2;
      v4 = a2 + 1;
      v3 = a1 + 1;
    }
    if ( (a3 & 2) != 0 )
      *v3++ = *v4++;
    qmemcpy(v3, v4, 4 * (a3 >> 2));
  }
  else
  {
    if ( ((unsigned __int8)a2 & 3) != 0 )
    {
      *a1 = *a2;
      v4 = a2 + 1;
      v3 = a1 + 1;
      v5 = a3 - 1;
      if ( ((unsigned int)(a2 + 1) & 3) != 0 )
      {
        *(_BYTE *)v3 = *(_BYTE *)v4;
        v4 = a2 + 2;
        v3 = a1 + 2;
        v5 = a3 - 2;
        if ( ((unsigned int)(a2 + 2) & 3) != 0 )
        {
          *(_BYTE *)v3 = *(_BYTE *)v4;
          v4 = a2 + 3;
          v3 = a1 + 3;
          v5 = a3 - 3;
        }
      }
    }
    qmemcpy(v3, v4, v5);
  }
  return a1;
}

//----- (080505D0) --------------------------------------------------------
unsigned int *__cdecl strchrnul(unsigned int *a1, int a2)
{
  unsigned int *result; // eax
  int v3; // edx
  __int16 v4; // cx
  int v5; // edx
  unsigned int v6; // ecx
  unsigned int v7; // ecx

  result = a1;
  v3 = a2;
  BYTE1(v3) = a2;
  v4 = v3;
  v5 = v3 << 16;
  LOWORD(v5) = v4;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( (_BYTE)v4 != *(_BYTE *)a1 && *(_BYTE *)a1 )
    {
      result = (unsigned int *)((char *)a1 + 1);
      if ( (((_BYTE)a1 + 1) & 3) == 0 )
        goto LABEL_12;
      if ( (_BYTE)v4 != *(_BYTE *)result && *(_BYTE *)result )
      {
        result = (unsigned int *)((char *)a1 + 2);
        if ( (((_BYTE)a1 + 2) & 3) == 0 )
          goto LABEL_12;
        if ( (_BYTE)v4 != *(_BYTE *)result && *(_BYTE *)result )
        {
          result = (unsigned int *)((char *)a1 + 3);
          goto LABEL_12;
        }
      }
    }
  }
  else
  {
LABEL_12:
    while ( 1 )
    {
      v6 = v5 ^ *result;
      if ( v6 < 0x1010101 )
        break;
      if ( (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v6 = *result;
      if ( *result < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v6 = v5 ^ result[1];
      if ( v6 < 0x1010101 )
        goto LABEL_30;
      if ( (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_30;
      v6 = result[1];
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_30;
      v6 = v5 ^ result[2];
      if ( v6 < 0x1010101 )
        goto LABEL_29;
      if ( (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_29;
      v6 = result[2];
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_29;
      v6 = v5 ^ result[3];
      if ( v6 < 0x1010101
        || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1
        || (v6 = result[3], v6 < 0x1010101)
        || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
      {
        ++result;
LABEL_29:
        ++result;
LABEL_30:
        ++result;
        break;
      }
      result += 4;
    }
    if ( (_BYTE)v6 )
    {
      if ( (_BYTE)v6 != (_BYTE)v5 )
      {
        result = (unsigned int *)((char *)result + 1);
        if ( BYTE1(v6) )
        {
          if ( BYTE1(v6) != (_BYTE)v5 )
          {
            result = (unsigned int *)((char *)result + 1);
            v7 = HIWORD(v6);
            if ( (_BYTE)v7 )
            {
              if ( (_BYTE)v7 != (_BYTE)v5 )
                return (unsigned int *)((char *)result + 1);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (08050730) --------------------------------------------------------
int __cdecl _memset_sse2(int a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax
  unsigned int v6; // edx
  int result; // eax
  __m128i v8; // xmm0
  __m128i *v9; // edx
  unsigned int v10; // ebx
  unsigned int v11; // ecx
  bool v12; // cf
  unsigned int v13; // ecx
  unsigned int v14; // ecx

  v3 = a3;
  v4 = a2;
  BYTE1(v4) = a2;
  v5 = v4 | (v4 << 16);
  v6 = a3 + a1;
  switch ( a3 )
  {
    case 0u:
      goto LABEL_9;
    case 1u:
      goto LABEL_17;
    case 2u:
      goto LABEL_25;
    case 3u:
      goto LABEL_33;
    case 4u:
      goto LABEL_8;
    case 5u:
      goto LABEL_16;
    case 6u:
      goto LABEL_24;
    case 7u:
      goto LABEL_32;
    case 8u:
      goto LABEL_7;
    case 9u:
      goto LABEL_15;
    case 0xAu:
      goto LABEL_23;
    case 0xBu:
      goto LABEL_31;
    case 0xCu:
      goto LABEL_6;
    case 0xDu:
      goto LABEL_14;
    case 0xEu:
      goto LABEL_22;
    case 0xFu:
      goto LABEL_30;
    case 0x10u:
      goto LABEL_5;
    case 0x11u:
      goto LABEL_13;
    case 0x12u:
      goto LABEL_21;
    case 0x13u:
      goto LABEL_29;
    case 0x14u:
      goto LABEL_4;
    case 0x15u:
      goto LABEL_12;
    case 0x16u:
      goto LABEL_20;
    case 0x17u:
      goto LABEL_28;
    case 0x18u:
      goto LABEL_3;
    case 0x19u:
      goto LABEL_11;
    case 0x1Au:
      goto LABEL_19;
    case 0x1Bu:
      goto LABEL_27;
    case 0x1Cu:
      *(_DWORD *)(v6 - 28) = v5;
LABEL_3:
      *(_DWORD *)(v6 - 24) = v5;
LABEL_4:
      *(_DWORD *)(v6 - 20) = v5;
LABEL_5:
      *(_DWORD *)(v6 - 16) = v5;
LABEL_6:
      *(_DWORD *)(v6 - 12) = v5;
LABEL_7:
      *(_DWORD *)(v6 - 8) = v5;
LABEL_8:
      *(_DWORD *)(v6 - 4) = v5;
LABEL_9:
      result = a1;
      break;
    case 0x1Du:
      *(_DWORD *)(v6 - 29) = v5;
LABEL_11:
      *(_DWORD *)(v6 - 25) = v5;
LABEL_12:
      *(_DWORD *)(v6 - 21) = v5;
LABEL_13:
      *(_DWORD *)(v6 - 17) = v5;
LABEL_14:
      *(_DWORD *)(v6 - 13) = v5;
LABEL_15:
      *(_DWORD *)(v6 - 9) = v5;
LABEL_16:
      *(_DWORD *)(v6 - 5) = v5;
LABEL_17:
      *(_BYTE *)(v6 - 1) = v5;
      result = a1;
      break;
    case 0x1Eu:
      *(_DWORD *)(v6 - 30) = v5;
LABEL_19:
      *(_DWORD *)(v6 - 26) = v5;
LABEL_20:
      *(_DWORD *)(v6 - 22) = v5;
LABEL_21:
      *(_DWORD *)(v6 - 18) = v5;
LABEL_22:
      *(_DWORD *)(v6 - 14) = v5;
LABEL_23:
      *(_DWORD *)(v6 - 10) = v5;
LABEL_24:
      *(_DWORD *)(v6 - 6) = v5;
LABEL_25:
      *(_WORD *)(v6 - 2) = v5;
      result = a1;
      break;
    case 0x1Fu:
      *(_DWORD *)(v6 - 31) = v5;
LABEL_27:
      *(_DWORD *)(v6 - 27) = v5;
LABEL_28:
      *(_DWORD *)(v6 - 23) = v5;
LABEL_29:
      *(_DWORD *)(v6 - 19) = v5;
LABEL_30:
      *(_DWORD *)(v6 - 15) = v5;
LABEL_31:
      *(_DWORD *)(v6 - 11) = v5;
LABEL_32:
      *(_DWORD *)(v6 - 7) = v5;
LABEL_33:
      *(_WORD *)(v6 - 3) = v5;
      *(_BYTE *)(v6 - 1) = v5;
      result = a1;
      break;
    default:
      v8 = _mm_shuffle_epi32(_mm_cvtsi32_si128(v5), 0);
      if ( (v6 & 0xF) != 0 )
      {
        *(__m128i *)v6 = v8;
        v6 = (v6 & 0xFFFFFFF0) + 16;
        v3 = a3 + a1 - v6 + a3;
        v5 = _mm_cvtsi128_si32(v8);
      }
      v9 = (__m128i *)(v3 + v6);
      switch ( v3 )
      {
        case 0u:
          goto LABEL_56;
        case 1u:
          goto LABEL_64;
        case 2u:
          goto LABEL_72;
        case 3u:
          goto LABEL_80;
        case 4u:
          goto LABEL_88;
        case 5u:
          goto LABEL_96;
        case 6u:
          goto LABEL_104;
        case 7u:
          goto LABEL_112;
        case 8u:
          goto LABEL_120;
        case 9u:
          goto LABEL_128;
        case 0xAu:
          goto LABEL_136;
        case 0xBu:
          goto LABEL_144;
        case 0xCu:
          goto LABEL_152;
        case 0xDu:
          goto LABEL_160;
        case 0xEu:
          goto LABEL_168;
        case 0xFu:
          goto LABEL_176;
        case 0x10u:
          goto LABEL_55;
        case 0x11u:
          goto LABEL_63;
        case 0x12u:
          goto LABEL_71;
        case 0x13u:
          goto LABEL_79;
        case 0x14u:
          goto LABEL_87;
        case 0x15u:
          goto LABEL_95;
        case 0x16u:
          goto LABEL_103;
        case 0x17u:
          goto LABEL_111;
        case 0x18u:
          goto LABEL_119;
        case 0x19u:
          goto LABEL_127;
        case 0x1Au:
          goto LABEL_135;
        case 0x1Bu:
          goto LABEL_143;
        case 0x1Cu:
          goto LABEL_151;
        case 0x1Du:
          goto LABEL_159;
        case 0x1Eu:
          goto LABEL_167;
        case 0x1Fu:
          goto LABEL_175;
        case 0x20u:
          goto LABEL_54;
        case 0x21u:
          goto LABEL_62;
        case 0x22u:
          goto LABEL_70;
        case 0x23u:
          goto LABEL_78;
        case 0x24u:
          goto LABEL_86;
        case 0x25u:
          goto LABEL_94;
        case 0x26u:
          goto LABEL_102;
        case 0x27u:
          goto LABEL_110;
        case 0x28u:
          goto LABEL_118;
        case 0x29u:
          goto LABEL_126;
        case 0x2Au:
          goto LABEL_134;
        case 0x2Bu:
          goto LABEL_142;
        case 0x2Cu:
          goto LABEL_150;
        case 0x2Du:
          goto LABEL_158;
        case 0x2Eu:
          goto LABEL_166;
        case 0x2Fu:
          goto LABEL_174;
        case 0x30u:
          goto LABEL_53;
        case 0x31u:
          goto LABEL_61;
        case 0x32u:
          goto LABEL_69;
        case 0x33u:
          goto LABEL_77;
        case 0x34u:
          goto LABEL_85;
        case 0x35u:
          goto LABEL_93;
        case 0x36u:
          goto LABEL_101;
        case 0x37u:
          goto LABEL_109;
        case 0x38u:
          goto LABEL_117;
        case 0x39u:
          goto LABEL_125;
        case 0x3Au:
          goto LABEL_133;
        case 0x3Bu:
          goto LABEL_141;
        case 0x3Cu:
          goto LABEL_149;
        case 0x3Du:
          goto LABEL_157;
        case 0x3Eu:
          goto LABEL_165;
        case 0x3Fu:
          goto LABEL_173;
        case 0x40u:
          goto LABEL_52;
        case 0x41u:
          goto LABEL_60;
        case 0x42u:
          goto LABEL_68;
        case 0x43u:
          goto LABEL_76;
        case 0x44u:
          goto LABEL_84;
        case 0x45u:
          goto LABEL_92;
        case 0x46u:
          goto LABEL_100;
        case 0x47u:
          goto LABEL_108;
        case 0x48u:
          goto LABEL_116;
        case 0x49u:
          goto LABEL_124;
        case 0x4Au:
          goto LABEL_132;
        case 0x4Bu:
          goto LABEL_140;
        case 0x4Cu:
          goto LABEL_148;
        case 0x4Du:
          goto LABEL_156;
        case 0x4Eu:
          goto LABEL_164;
        case 0x4Fu:
          goto LABEL_172;
        case 0x50u:
          goto LABEL_51;
        case 0x51u:
          goto LABEL_59;
        case 0x52u:
          goto LABEL_67;
        case 0x53u:
          goto LABEL_75;
        case 0x54u:
          goto LABEL_83;
        case 0x55u:
          goto LABEL_91;
        case 0x56u:
          goto LABEL_99;
        case 0x57u:
          goto LABEL_107;
        case 0x58u:
          goto LABEL_115;
        case 0x59u:
          goto LABEL_123;
        case 0x5Au:
          goto LABEL_131;
        case 0x5Bu:
          goto LABEL_139;
        case 0x5Cu:
          goto LABEL_147;
        case 0x5Du:
          goto LABEL_155;
        case 0x5Eu:
          goto LABEL_163;
        case 0x5Fu:
          goto LABEL_171;
        case 0x60u:
          goto LABEL_50;
        case 0x61u:
          goto LABEL_58;
        case 0x62u:
          goto LABEL_66;
        case 0x63u:
          goto LABEL_74;
        case 0x64u:
          goto LABEL_82;
        case 0x65u:
          goto LABEL_90;
        case 0x66u:
          goto LABEL_98;
        case 0x67u:
          goto LABEL_106;
        case 0x68u:
          goto LABEL_114;
        case 0x69u:
          goto LABEL_122;
        case 0x6Au:
          goto LABEL_130;
        case 0x6Bu:
          goto LABEL_138;
        case 0x6Cu:
          goto LABEL_146;
        case 0x6Du:
          goto LABEL_154;
        case 0x6Eu:
          goto LABEL_162;
        case 0x6Fu:
          goto LABEL_170;
        case 0x70u:
LABEL_49:
          v9[-7] = v8;
LABEL_50:
          v9[-6] = v8;
LABEL_51:
          v9[-5] = v8;
LABEL_52:
          v9[-4] = v8;
LABEL_53:
          v9[-3] = v8;
LABEL_54:
          v9[-2] = v8;
LABEL_55:
          v9[-1] = v8;
LABEL_56:
          result = a1;
          break;
        case 0x71u:
LABEL_57:
          *(__m128i *)((char *)v9 - 113) = v8;
LABEL_58:
          *(__m128i *)((char *)v9 - 97) = v8;
LABEL_59:
          *(__m128i *)((char *)v9 - 81) = v8;
LABEL_60:
          *(__m128i *)((char *)v9 - 65) = v8;
LABEL_61:
          *(__m128i *)((char *)v9 - 49) = v8;
LABEL_62:
          *(__m128i *)((char *)v9 - 33) = v8;
LABEL_63:
          *(__m128i *)((char *)v9 - 17) = v8;
LABEL_64:
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x72u:
LABEL_65:
          *(__m128i *)((char *)v9 - 114) = v8;
LABEL_66:
          *(__m128i *)((char *)v9 - 98) = v8;
LABEL_67:
          *(__m128i *)((char *)v9 - 82) = v8;
LABEL_68:
          *(__m128i *)((char *)v9 - 66) = v8;
LABEL_69:
          *(__m128i *)((char *)v9 - 50) = v8;
LABEL_70:
          *(__m128i *)((char *)v9 - 34) = v8;
LABEL_71:
          *(__m128i *)((char *)v9 - 18) = v8;
LABEL_72:
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x73u:
LABEL_73:
          *(__m128i *)((char *)v9 - 115) = v8;
LABEL_74:
          *(__m128i *)((char *)v9 - 99) = v8;
LABEL_75:
          *(__m128i *)((char *)v9 - 83) = v8;
LABEL_76:
          *(__m128i *)((char *)v9 - 67) = v8;
LABEL_77:
          *(__m128i *)((char *)v9 - 51) = v8;
LABEL_78:
          *(__m128i *)((char *)v9 - 35) = v8;
LABEL_79:
          *(__m128i *)((char *)v9 - 19) = v8;
LABEL_80:
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x74u:
LABEL_81:
          *(__m128i *)((char *)v9 - 116) = v8;
LABEL_82:
          *(__m128i *)((char *)v9 - 100) = v8;
LABEL_83:
          *(__m128i *)((char *)v9 - 84) = v8;
LABEL_84:
          *(__m128i *)((char *)v9 - 68) = v8;
LABEL_85:
          *(__m128i *)((char *)v9 - 52) = v8;
LABEL_86:
          *(__m128i *)((char *)v9 - 36) = v8;
LABEL_87:
          *(__m128i *)((char *)v9 - 20) = v8;
LABEL_88:
          v9[-1].m128i_i32[3] = v5;
          result = a1;
          break;
        case 0x75u:
LABEL_89:
          *(__m128i *)((char *)v9 - 117) = v8;
LABEL_90:
          *(__m128i *)((char *)v9 - 101) = v8;
LABEL_91:
          *(__m128i *)((char *)v9 - 85) = v8;
LABEL_92:
          *(__m128i *)((char *)v9 - 69) = v8;
LABEL_93:
          *(__m128i *)((char *)v9 - 53) = v8;
LABEL_94:
          *(__m128i *)((char *)v9 - 37) = v8;
LABEL_95:
          *(__m128i *)((char *)v9 - 21) = v8;
LABEL_96:
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 3) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x76u:
LABEL_97:
          *(__m128i *)((char *)v9 - 118) = v8;
LABEL_98:
          *(__m128i *)((char *)v9 - 102) = v8;
LABEL_99:
          *(__m128i *)((char *)v9 - 86) = v8;
LABEL_100:
          *(__m128i *)((char *)v9 - 70) = v8;
LABEL_101:
          *(__m128i *)((char *)v9 - 54) = v8;
LABEL_102:
          *(__m128i *)((char *)v9 - 38) = v8;
LABEL_103:
          *(__m128i *)((char *)v9 - 22) = v8;
LABEL_104:
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 2) = v5;
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x77u:
LABEL_105:
          *(__m128i *)((char *)v9 - 119) = v8;
LABEL_106:
          *(__m128i *)((char *)v9 - 103) = v8;
LABEL_107:
          *(__m128i *)((char *)v9 - 87) = v8;
LABEL_108:
          *(__m128i *)((char *)v9 - 71) = v8;
LABEL_109:
          *(__m128i *)((char *)v9 - 55) = v8;
LABEL_110:
          *(__m128i *)((char *)v9 - 39) = v8;
LABEL_111:
          *(__m128i *)((char *)v9 - 23) = v8;
LABEL_112:
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 1) = v5;
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x78u:
LABEL_113:
          *(__m128i *)((char *)v9 - 120) = v8;
LABEL_114:
          *(__m128i *)((char *)v9 - 104) = v8;
LABEL_115:
          *(__m128i *)((char *)v9 - 88) = v8;
LABEL_116:
          *(__m128i *)((char *)v9 - 72) = v8;
LABEL_117:
          *(__m128i *)((char *)v9 - 56) = v8;
LABEL_118:
          *(__m128i *)((char *)v9 - 40) = v8;
LABEL_119:
          *(__m128i *)((char *)v9 - 24) = v8;
LABEL_120:
          v9[-1].m128i_i64[1] = v8.m128i_i64[0];
          result = a1;
          break;
        case 0x79u:
LABEL_121:
          *(__m128i *)((char *)v9 - 121) = v8;
LABEL_122:
          *(__m128i *)((char *)v9 - 105) = v8;
LABEL_123:
          *(__m128i *)((char *)v9 - 89) = v8;
LABEL_124:
          *(__m128i *)((char *)v9 - 73) = v8;
LABEL_125:
          *(__m128i *)((char *)v9 - 57) = v8;
LABEL_126:
          *(__m128i *)((char *)v9 - 41) = v8;
LABEL_127:
          *(__m128i *)((char *)v9 - 25) = v8;
LABEL_128:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 7) = v8.m128i_i64[0];
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x7Au:
LABEL_129:
          *(__m128i *)((char *)v9 - 122) = v8;
LABEL_130:
          *(__m128i *)((char *)v9 - 106) = v8;
LABEL_131:
          *(__m128i *)((char *)v9 - 90) = v8;
LABEL_132:
          *(__m128i *)((char *)v9 - 74) = v8;
LABEL_133:
          *(__m128i *)((char *)v9 - 58) = v8;
LABEL_134:
          *(__m128i *)((char *)v9 - 42) = v8;
LABEL_135:
          *(__m128i *)((char *)v9 - 26) = v8;
LABEL_136:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 6) = v8.m128i_i64[0];
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x7Bu:
LABEL_137:
          *(__m128i *)((char *)v9 - 123) = v8;
LABEL_138:
          *(__m128i *)((char *)v9 - 107) = v8;
LABEL_139:
          *(__m128i *)((char *)v9 - 91) = v8;
LABEL_140:
          *(__m128i *)((char *)v9 - 75) = v8;
LABEL_141:
          *(__m128i *)((char *)v9 - 59) = v8;
LABEL_142:
          *(__m128i *)((char *)v9 - 43) = v8;
LABEL_143:
          *(__m128i *)((char *)v9 - 27) = v8;
LABEL_144:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 5) = v8.m128i_i64[0];
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x7Cu:
LABEL_145:
          *(__m128i *)((char *)v9 - 124) = v8;
LABEL_146:
          *(__m128i *)((char *)v9 - 108) = v8;
LABEL_147:
          *(__m128i *)((char *)v9 - 92) = v8;
LABEL_148:
          *(__m128i *)((char *)v9 - 76) = v8;
LABEL_149:
          *(__m128i *)((char *)v9 - 60) = v8;
LABEL_150:
          *(__m128i *)((char *)v9 - 44) = v8;
LABEL_151:
          *(__m128i *)((char *)v9 - 28) = v8;
LABEL_152:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 4) = v8.m128i_i64[0];
          v9[-1].m128i_i32[3] = v5;
          result = a1;
          break;
        case 0x7Du:
LABEL_153:
          *(__m128i *)((char *)v9 - 125) = v8;
LABEL_154:
          *(__m128i *)((char *)v9 - 109) = v8;
LABEL_155:
          *(__m128i *)((char *)v9 - 93) = v8;
LABEL_156:
          *(__m128i *)((char *)v9 - 77) = v8;
LABEL_157:
          *(__m128i *)((char *)v9 - 61) = v8;
LABEL_158:
          *(__m128i *)((char *)v9 - 45) = v8;
LABEL_159:
          *(__m128i *)((char *)v9 - 29) = v8;
LABEL_160:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 3) = v8.m128i_i64[0];
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 3) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x7Eu:
LABEL_161:
          *(__m128i *)((char *)v9 - 126) = v8;
LABEL_162:
          *(__m128i *)((char *)v9 - 110) = v8;
LABEL_163:
          *(__m128i *)((char *)v9 - 94) = v8;
LABEL_164:
          *(__m128i *)((char *)v9 - 78) = v8;
LABEL_165:
          *(__m128i *)((char *)v9 - 62) = v8;
LABEL_166:
          *(__m128i *)((char *)v9 - 46) = v8;
LABEL_167:
          *(__m128i *)((char *)v9 - 30) = v8;
LABEL_168:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 2) = v8.m128i_i64[0];
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 2) = v5;
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x7Fu:
LABEL_169:
          *(__m128i *)((char *)v9 - 127) = v8;
LABEL_170:
          *(__m128i *)((char *)v9 - 111) = v8;
LABEL_171:
          *(__m128i *)((char *)v9 - 95) = v8;
LABEL_172:
          *(__m128i *)((char *)v9 - 79) = v8;
LABEL_173:
          *(__m128i *)((char *)v9 - 63) = v8;
LABEL_174:
          *(__m128i *)((char *)v9 - 47) = v8;
LABEL_175:
          *(__m128i *)((char *)v9 - 31) = v8;
LABEL_176:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 1) = v8.m128i_i64[0];
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 1) = v5;
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        default:
          v10 = _x86_shared_cache_size;
          if ( v3 < _x86_shared_cache_size )
          {
            if ( v3 < _x86_data_cache_size )
            {
              v11 = v3 - 128;
              do
              {
                v12 = v11 < 0x80;
                v11 -= 128;
                *v9 = v8;
                v9[1] = v8;
                v9[2] = v8;
                v9[3] = v8;
                v9[4] = v8;
                v9[5] = v8;
                v9[6] = v8;
                v9[7] = v8;
                v9 += 8;
                if ( v12 )
                  break;
                v12 = v11 < 0x80;
                v11 -= 128;
                *v9 = v8;
                v9[1] = v8;
                v9[2] = v8;
                v9[3] = v8;
                v9[4] = v8;
                v9[5] = v8;
                v9[6] = v8;
                v9[7] = v8;
                v9 += 8;
              }
              while ( !v12 );
              v13 = v11 + 128;
              v9 = (__m128i *)((char *)v9 + v13);
              switch ( v13 )
              {
                case 0u:
                  goto LABEL_56;
                case 1u:
                  goto LABEL_64;
                case 2u:
                  goto LABEL_72;
                case 3u:
                  goto LABEL_80;
                case 4u:
                  goto LABEL_88;
                case 5u:
                  goto LABEL_96;
                case 6u:
                  goto LABEL_104;
                case 7u:
                  goto LABEL_112;
                case 8u:
                  goto LABEL_120;
                case 9u:
                  goto LABEL_128;
                case 0xAu:
                  goto LABEL_136;
                case 0xBu:
                  goto LABEL_144;
                case 0xCu:
                  goto LABEL_152;
                case 0xDu:
                  goto LABEL_160;
                case 0xEu:
                  goto LABEL_168;
                case 0xFu:
                  goto LABEL_176;
                case 0x10u:
                  goto LABEL_55;
                case 0x11u:
                  goto LABEL_63;
                case 0x12u:
                  goto LABEL_71;
                case 0x13u:
                  goto LABEL_79;
                case 0x14u:
                  goto LABEL_87;
                case 0x15u:
                  goto LABEL_95;
                case 0x16u:
                  goto LABEL_103;
                case 0x17u:
                  goto LABEL_111;
                case 0x18u:
                  goto LABEL_119;
                case 0x19u:
                  goto LABEL_127;
                case 0x1Au:
                  goto LABEL_135;
                case 0x1Bu:
                  goto LABEL_143;
                case 0x1Cu:
                  goto LABEL_151;
                case 0x1Du:
                  goto LABEL_159;
                case 0x1Eu:
                  goto LABEL_167;
                case 0x1Fu:
                  goto LABEL_175;
                case 0x20u:
                  goto LABEL_54;
                case 0x21u:
                  goto LABEL_62;
                case 0x22u:
                  goto LABEL_70;
                case 0x23u:
                  goto LABEL_78;
                case 0x24u:
                  goto LABEL_86;
                case 0x25u:
                  goto LABEL_94;
                case 0x26u:
                  goto LABEL_102;
                case 0x27u:
                  goto LABEL_110;
                case 0x28u:
                  goto LABEL_118;
                case 0x29u:
                  goto LABEL_126;
                case 0x2Au:
                  goto LABEL_134;
                case 0x2Bu:
                  goto LABEL_142;
                case 0x2Cu:
                  goto LABEL_150;
                case 0x2Du:
                  goto LABEL_158;
                case 0x2Eu:
                  goto LABEL_166;
                case 0x2Fu:
                  goto LABEL_174;
                case 0x30u:
                  goto LABEL_53;
                case 0x31u:
                  goto LABEL_61;
                case 0x32u:
                  goto LABEL_69;
                case 0x33u:
                  goto LABEL_77;
                case 0x34u:
                  goto LABEL_85;
                case 0x35u:
                  goto LABEL_93;
                case 0x36u:
                  goto LABEL_101;
                case 0x37u:
                  goto LABEL_109;
                case 0x38u:
                  goto LABEL_117;
                case 0x39u:
                  goto LABEL_125;
                case 0x3Au:
                  goto LABEL_133;
                case 0x3Bu:
                  goto LABEL_141;
                case 0x3Cu:
                  goto LABEL_149;
                case 0x3Du:
                  goto LABEL_157;
                case 0x3Eu:
                  goto LABEL_165;
                case 0x3Fu:
                  goto LABEL_173;
                case 0x40u:
                  goto LABEL_52;
                case 0x41u:
                  goto LABEL_60;
                case 0x42u:
                  goto LABEL_68;
                case 0x43u:
                  goto LABEL_76;
                case 0x44u:
                  goto LABEL_84;
                case 0x45u:
                  goto LABEL_92;
                case 0x46u:
                  goto LABEL_100;
                case 0x47u:
                  goto LABEL_108;
                case 0x48u:
                  goto LABEL_116;
                case 0x49u:
                  goto LABEL_124;
                case 0x4Au:
                  goto LABEL_132;
                case 0x4Bu:
                  goto LABEL_140;
                case 0x4Cu:
                  goto LABEL_148;
                case 0x4Du:
                  goto LABEL_156;
                case 0x4Eu:
                  goto LABEL_164;
                case 0x4Fu:
                  goto LABEL_172;
                case 0x50u:
                  goto LABEL_51;
                case 0x51u:
                  goto LABEL_59;
                case 0x52u:
                  goto LABEL_67;
                case 0x53u:
                  goto LABEL_75;
                case 0x54u:
                  goto LABEL_83;
                case 0x55u:
                  goto LABEL_91;
                case 0x56u:
                  goto LABEL_99;
                case 0x57u:
                  goto LABEL_107;
                case 0x58u:
                  goto LABEL_115;
                case 0x59u:
                  goto LABEL_123;
                case 0x5Au:
                  goto LABEL_131;
                case 0x5Bu:
                  goto LABEL_139;
                case 0x5Cu:
                  goto LABEL_147;
                case 0x5Du:
                  goto LABEL_155;
                case 0x5Eu:
                  goto LABEL_163;
                case 0x5Fu:
                  goto LABEL_171;
                case 0x60u:
                  goto LABEL_50;
                case 0x61u:
                  goto LABEL_58;
                case 0x62u:
                  goto LABEL_66;
                case 0x63u:
                  goto LABEL_74;
                case 0x64u:
                  goto LABEL_82;
                case 0x65u:
                  goto LABEL_90;
                case 0x66u:
                  goto LABEL_98;
                case 0x67u:
                  goto LABEL_106;
                case 0x68u:
                  goto LABEL_114;
                case 0x69u:
                  goto LABEL_122;
                case 0x6Au:
                  goto LABEL_130;
                case 0x6Bu:
                  goto LABEL_138;
                case 0x6Cu:
                  goto LABEL_146;
                case 0x6Du:
                  goto LABEL_154;
                case 0x6Eu:
                  goto LABEL_162;
                case 0x6Fu:
                  goto LABEL_170;
                case 0x70u:
                  goto LABEL_49;
                case 0x71u:
                  goto LABEL_57;
                case 0x72u:
                  goto LABEL_65;
                case 0x73u:
                  goto LABEL_73;
                case 0x74u:
                  goto LABEL_81;
                case 0x75u:
                  goto LABEL_89;
                case 0x76u:
                  goto LABEL_97;
                case 0x77u:
                  goto LABEL_105;
                case 0x78u:
                  goto LABEL_113;
                case 0x79u:
                  goto LABEL_121;
                case 0x7Au:
                  goto LABEL_129;
                case 0x7Bu:
                  goto LABEL_137;
                case 0x7Cu:
                  goto LABEL_145;
                case 0x7Du:
                  goto LABEL_153;
                case 0x7Eu:
                  goto LABEL_161;
                case 0x7Fu:
                  goto LABEL_169;
              }
            }
            while ( 2 )
            {
              _mm_prefetch(v9[56].m128i_i8, 1);
              _mm_prefetch(v9[60].m128i_i8, 1);
              v3 -= 128;
              *v9 = v8;
              v9[1] = v8;
              v9[2] = v8;
              v9[3] = v8;
              v9[4] = v8;
              v9[5] = v8;
              v9[6] = v8;
              v9[7] = v8;
              v9 = (__m128i *)((char *)v9 + v3 + 128);
              switch ( v3 )
              {
                case 0u:
                  goto LABEL_56;
                case 1u:
                  goto LABEL_64;
                case 2u:
                  goto LABEL_72;
                case 3u:
                  goto LABEL_80;
                case 4u:
                  goto LABEL_88;
                case 5u:
                  goto LABEL_96;
                case 6u:
                  goto LABEL_104;
                case 7u:
                  goto LABEL_112;
                case 8u:
                  goto LABEL_120;
                case 9u:
                  goto LABEL_128;
                case 0xAu:
                  goto LABEL_136;
                case 0xBu:
                  goto LABEL_144;
                case 0xCu:
                  goto LABEL_152;
                case 0xDu:
                  goto LABEL_160;
                case 0xEu:
                  goto LABEL_168;
                case 0xFu:
                  goto LABEL_176;
                case 0x10u:
                  goto LABEL_55;
                case 0x11u:
                  goto LABEL_63;
                case 0x12u:
                  goto LABEL_71;
                case 0x13u:
                  goto LABEL_79;
                case 0x14u:
                  goto LABEL_87;
                case 0x15u:
                  goto LABEL_95;
                case 0x16u:
                  goto LABEL_103;
                case 0x17u:
                  goto LABEL_111;
                case 0x18u:
                  goto LABEL_119;
                case 0x19u:
                  goto LABEL_127;
                case 0x1Au:
                  goto LABEL_135;
                case 0x1Bu:
                  goto LABEL_143;
                case 0x1Cu:
                  goto LABEL_151;
                case 0x1Du:
                  goto LABEL_159;
                case 0x1Eu:
                  goto LABEL_167;
                case 0x1Fu:
                  goto LABEL_175;
                case 0x20u:
                  goto LABEL_54;
                case 0x21u:
                  goto LABEL_62;
                case 0x22u:
                  goto LABEL_70;
                case 0x23u:
                  goto LABEL_78;
                case 0x24u:
                  goto LABEL_86;
                case 0x25u:
                  goto LABEL_94;
                case 0x26u:
                  goto LABEL_102;
                case 0x27u:
                  goto LABEL_110;
                case 0x28u:
                  goto LABEL_118;
                case 0x29u:
                  goto LABEL_126;
                case 0x2Au:
                  goto LABEL_134;
                case 0x2Bu:
                  goto LABEL_142;
                case 0x2Cu:
                  goto LABEL_150;
                case 0x2Du:
                  goto LABEL_158;
                case 0x2Eu:
                  goto LABEL_166;
                case 0x2Fu:
                  goto LABEL_174;
                case 0x30u:
                  goto LABEL_53;
                case 0x31u:
                  goto LABEL_61;
                case 0x32u:
                  goto LABEL_69;
                case 0x33u:
                  goto LABEL_77;
                case 0x34u:
                  goto LABEL_85;
                case 0x35u:
                  goto LABEL_93;
                case 0x36u:
                  goto LABEL_101;
                case 0x37u:
                  goto LABEL_109;
                case 0x38u:
                  goto LABEL_117;
                case 0x39u:
                  goto LABEL_125;
                case 0x3Au:
                  goto LABEL_133;
                case 0x3Bu:
                  goto LABEL_141;
                case 0x3Cu:
                  goto LABEL_149;
                case 0x3Du:
                  goto LABEL_157;
                case 0x3Eu:
                  goto LABEL_165;
                case 0x3Fu:
                  goto LABEL_173;
                case 0x40u:
                  goto LABEL_52;
                case 0x41u:
                  goto LABEL_60;
                case 0x42u:
                  goto LABEL_68;
                case 0x43u:
                  goto LABEL_76;
                case 0x44u:
                  goto LABEL_84;
                case 0x45u:
                  goto LABEL_92;
                case 0x46u:
                  goto LABEL_100;
                case 0x47u:
                  goto LABEL_108;
                case 0x48u:
                  goto LABEL_116;
                case 0x49u:
                  goto LABEL_124;
                case 0x4Au:
                  goto LABEL_132;
                case 0x4Bu:
                  goto LABEL_140;
                case 0x4Cu:
                  goto LABEL_148;
                case 0x4Du:
                  goto LABEL_156;
                case 0x4Eu:
                  goto LABEL_164;
                case 0x4Fu:
                  goto LABEL_172;
                case 0x50u:
                  goto LABEL_51;
                case 0x51u:
                  goto LABEL_59;
                case 0x52u:
                  goto LABEL_67;
                case 0x53u:
                  goto LABEL_75;
                case 0x54u:
                  goto LABEL_83;
                case 0x55u:
                  goto LABEL_91;
                case 0x56u:
                  goto LABEL_99;
                case 0x57u:
                  goto LABEL_107;
                case 0x58u:
                  goto LABEL_115;
                case 0x59u:
                  goto LABEL_123;
                case 0x5Au:
                  goto LABEL_131;
                case 0x5Bu:
                  goto LABEL_139;
                case 0x5Cu:
                  goto LABEL_147;
                case 0x5Du:
                  goto LABEL_155;
                case 0x5Eu:
                  goto LABEL_163;
                case 0x5Fu:
                  goto LABEL_171;
                case 0x60u:
                  goto LABEL_50;
                case 0x61u:
                  goto LABEL_58;
                case 0x62u:
                  goto LABEL_66;
                case 0x63u:
                  goto LABEL_74;
                case 0x64u:
                  goto LABEL_82;
                case 0x65u:
                  goto LABEL_90;
                case 0x66u:
                  goto LABEL_98;
                case 0x67u:
                  goto LABEL_106;
                case 0x68u:
                  goto LABEL_114;
                case 0x69u:
                  goto LABEL_122;
                case 0x6Au:
                  goto LABEL_130;
                case 0x6Bu:
                  goto LABEL_138;
                case 0x6Cu:
                  goto LABEL_146;
                case 0x6Du:
                  goto LABEL_154;
                case 0x6Eu:
                  goto LABEL_162;
                case 0x6Fu:
                  goto LABEL_170;
                case 0x70u:
                  goto LABEL_49;
                case 0x71u:
                  goto LABEL_57;
                case 0x72u:
                  goto LABEL_65;
                case 0x73u:
                  goto LABEL_73;
                case 0x74u:
                  goto LABEL_81;
                case 0x75u:
                  goto LABEL_89;
                case 0x76u:
                  goto LABEL_97;
                case 0x77u:
                  goto LABEL_105;
                case 0x78u:
                  goto LABEL_113;
                case 0x79u:
                  goto LABEL_121;
                case 0x7Au:
                  goto LABEL_129;
                case 0x7Bu:
                  goto LABEL_137;
                case 0x7Cu:
                  goto LABEL_145;
                case 0x7Du:
                  goto LABEL_153;
                case 0x7Eu:
                  goto LABEL_161;
                case 0x7Fu:
                  goto LABEL_169;
                default:
                  continue;
              }
            }
          }
          v14 = v3 - _x86_shared_cache_size;
          do
          {
            _mm_prefetch(v9[60].m128i_i8, 1);
            _mm_prefetch(v9[56].m128i_i8, 1);
            v10 -= 128;
            *v9 = v8;
            v9[1] = v8;
            v9[2] = v8;
            v9[3] = v8;
            v9[4] = v8;
            v9[5] = v8;
            v9[6] = v8;
            v9[7] = v8;
            v9 += 8;
          }
          while ( v10 >= 0x80 );
          if ( v14 >= 0x80 )
          {
LABEL_47:
            v14 -= 128;
            _mm_stream_si128(v9, v8);
            _mm_stream_si128(v9 + 1, v8);
            _mm_stream_si128(v9 + 2, v8);
            _mm_stream_si128(v9 + 3, v8);
            _mm_stream_si128(v9 + 4, v8);
            _mm_stream_si128(v9 + 5, v8);
            _mm_stream_si128(v9 + 6, v8);
            _mm_stream_si128(v9 + 7, v8);
            v9 += 8;
            _mm_sfence();
          }
          v9 = (__m128i *)((char *)v9 + v14);
          switch ( v14 )
          {
            case 0u:
              goto LABEL_56;
            case 1u:
              goto LABEL_64;
            case 2u:
              goto LABEL_72;
            case 3u:
              goto LABEL_80;
            case 4u:
              goto LABEL_88;
            case 5u:
              goto LABEL_96;
            case 6u:
              goto LABEL_104;
            case 7u:
              goto LABEL_112;
            case 8u:
              goto LABEL_120;
            case 9u:
              goto LABEL_128;
            case 0xAu:
              goto LABEL_136;
            case 0xBu:
              goto LABEL_144;
            case 0xCu:
              goto LABEL_152;
            case 0xDu:
              goto LABEL_160;
            case 0xEu:
              goto LABEL_168;
            case 0xFu:
              goto LABEL_176;
            case 0x10u:
              goto LABEL_55;
            case 0x11u:
              goto LABEL_63;
            case 0x12u:
              goto LABEL_71;
            case 0x13u:
              goto LABEL_79;
            case 0x14u:
              goto LABEL_87;
            case 0x15u:
              goto LABEL_95;
            case 0x16u:
              goto LABEL_103;
            case 0x17u:
              goto LABEL_111;
            case 0x18u:
              goto LABEL_119;
            case 0x19u:
              goto LABEL_127;
            case 0x1Au:
              goto LABEL_135;
            case 0x1Bu:
              goto LABEL_143;
            case 0x1Cu:
              goto LABEL_151;
            case 0x1Du:
              goto LABEL_159;
            case 0x1Eu:
              goto LABEL_167;
            case 0x1Fu:
              goto LABEL_175;
            case 0x20u:
              goto LABEL_54;
            case 0x21u:
              goto LABEL_62;
            case 0x22u:
              goto LABEL_70;
            case 0x23u:
              goto LABEL_78;
            case 0x24u:
              goto LABEL_86;
            case 0x25u:
              goto LABEL_94;
            case 0x26u:
              goto LABEL_102;
            case 0x27u:
              goto LABEL_110;
            case 0x28u:
              goto LABEL_118;
            case 0x29u:
              goto LABEL_126;
            case 0x2Au:
              goto LABEL_134;
            case 0x2Bu:
              goto LABEL_142;
            case 0x2Cu:
              goto LABEL_150;
            case 0x2Du:
              goto LABEL_158;
            case 0x2Eu:
              goto LABEL_166;
            case 0x2Fu:
              goto LABEL_174;
            case 0x30u:
              goto LABEL_53;
            case 0x31u:
              goto LABEL_61;
            case 0x32u:
              goto LABEL_69;
            case 0x33u:
              goto LABEL_77;
            case 0x34u:
              goto LABEL_85;
            case 0x35u:
              goto LABEL_93;
            case 0x36u:
              goto LABEL_101;
            case 0x37u:
              goto LABEL_109;
            case 0x38u:
              goto LABEL_117;
            case 0x39u:
              goto LABEL_125;
            case 0x3Au:
              goto LABEL_133;
            case 0x3Bu:
              goto LABEL_141;
            case 0x3Cu:
              goto LABEL_149;
            case 0x3Du:
              goto LABEL_157;
            case 0x3Eu:
              goto LABEL_165;
            case 0x3Fu:
              goto LABEL_173;
            case 0x40u:
              goto LABEL_52;
            case 0x41u:
              goto LABEL_60;
            case 0x42u:
              goto LABEL_68;
            case 0x43u:
              goto LABEL_76;
            case 0x44u:
              goto LABEL_84;
            case 0x45u:
              goto LABEL_92;
            case 0x46u:
              goto LABEL_100;
            case 0x47u:
              goto LABEL_108;
            case 0x48u:
              goto LABEL_116;
            case 0x49u:
              goto LABEL_124;
            case 0x4Au:
              goto LABEL_132;
            case 0x4Bu:
              goto LABEL_140;
            case 0x4Cu:
              goto LABEL_148;
            case 0x4Du:
              goto LABEL_156;
            case 0x4Eu:
              goto LABEL_164;
            case 0x4Fu:
              goto LABEL_172;
            case 0x50u:
              goto LABEL_51;
            case 0x51u:
              goto LABEL_59;
            case 0x52u:
              goto LABEL_67;
            case 0x53u:
              goto LABEL_75;
            case 0x54u:
              goto LABEL_83;
            case 0x55u:
              goto LABEL_91;
            case 0x56u:
              goto LABEL_99;
            case 0x57u:
              goto LABEL_107;
            case 0x58u:
              goto LABEL_115;
            case 0x59u:
              goto LABEL_123;
            case 0x5Au:
              goto LABEL_131;
            case 0x5Bu:
              goto LABEL_139;
            case 0x5Cu:
              goto LABEL_147;
            case 0x5Du:
              goto LABEL_155;
            case 0x5Eu:
              goto LABEL_163;
            case 0x5Fu:
              goto LABEL_171;
            case 0x60u:
              goto LABEL_50;
            case 0x61u:
              goto LABEL_58;
            case 0x62u:
              goto LABEL_66;
            case 0x63u:
              goto LABEL_74;
            case 0x64u:
              goto LABEL_82;
            case 0x65u:
              goto LABEL_90;
            case 0x66u:
              goto LABEL_98;
            case 0x67u:
              goto LABEL_106;
            case 0x68u:
              goto LABEL_114;
            case 0x69u:
              goto LABEL_122;
            case 0x6Au:
              goto LABEL_130;
            case 0x6Bu:
              goto LABEL_138;
            case 0x6Cu:
              goto LABEL_146;
            case 0x6Du:
              goto LABEL_154;
            case 0x6Eu:
              goto LABEL_162;
            case 0x6Fu:
              goto LABEL_170;
            case 0x70u:
              goto LABEL_49;
            case 0x71u:
              goto LABEL_57;
            case 0x72u:
              goto LABEL_65;
            case 0x73u:
              goto LABEL_73;
            case 0x74u:
              goto LABEL_81;
            case 0x75u:
              goto LABEL_89;
            case 0x76u:
              goto LABEL_97;
            case 0x77u:
              goto LABEL_105;
            case 0x78u:
              goto LABEL_113;
            case 0x79u:
              goto LABEL_121;
            case 0x7Au:
              goto LABEL_129;
            case 0x7Bu:
              goto LABEL_137;
            case 0x7Cu:
              goto LABEL_145;
            case 0x7Du:
              goto LABEL_153;
            case 0x7Eu:
              goto LABEL_161;
            case 0x7Fu:
              goto LABEL_169;
            default:
              goto LABEL_47;
          }
      }
      break;
  }
  return result;
}
// 80EF544: using guessed type int _x86_shared_cache_size;
// 80EF554: using guessed type int _x86_data_cache_size;

//----- (08050D40) --------------------------------------------------------
int __cdecl _memset_sse2_rep(int a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax
  unsigned int v6; // edx
  int result; // eax
  __m128i v8; // xmm0
  __m128i *v9; // edx
  unsigned int v10; // ecx
  bool v11; // cf
  unsigned int v12; // ecx
  __m128i *v13; // edi
  char v14; // dl
  unsigned int v15; // ecx
  unsigned int v16; // edx
  char *v17; // edi

  v3 = a3;
  v4 = a2;
  BYTE1(v4) = a2;
  v5 = v4 | (v4 << 16);
  v6 = a3 + a1;
  switch ( a3 )
  {
    case 0u:
      goto LABEL_9;
    case 1u:
      goto LABEL_17;
    case 2u:
      goto LABEL_25;
    case 3u:
      goto LABEL_33;
    case 4u:
      goto LABEL_8;
    case 5u:
      goto LABEL_16;
    case 6u:
      goto LABEL_24;
    case 7u:
      goto LABEL_32;
    case 8u:
      goto LABEL_7;
    case 9u:
      goto LABEL_15;
    case 0xAu:
      goto LABEL_23;
    case 0xBu:
      goto LABEL_31;
    case 0xCu:
      goto LABEL_6;
    case 0xDu:
      goto LABEL_14;
    case 0xEu:
      goto LABEL_22;
    case 0xFu:
      goto LABEL_30;
    case 0x10u:
      goto LABEL_5;
    case 0x11u:
      goto LABEL_13;
    case 0x12u:
      goto LABEL_21;
    case 0x13u:
      goto LABEL_29;
    case 0x14u:
      goto LABEL_4;
    case 0x15u:
      goto LABEL_12;
    case 0x16u:
      goto LABEL_20;
    case 0x17u:
      goto LABEL_28;
    case 0x18u:
      goto LABEL_3;
    case 0x19u:
      goto LABEL_11;
    case 0x1Au:
      goto LABEL_19;
    case 0x1Bu:
      goto LABEL_27;
    case 0x1Cu:
      *(_DWORD *)(v6 - 28) = v5;
LABEL_3:
      *(_DWORD *)(v6 - 24) = v5;
LABEL_4:
      *(_DWORD *)(v6 - 20) = v5;
LABEL_5:
      *(_DWORD *)(v6 - 16) = v5;
LABEL_6:
      *(_DWORD *)(v6 - 12) = v5;
LABEL_7:
      *(_DWORD *)(v6 - 8) = v5;
LABEL_8:
      *(_DWORD *)(v6 - 4) = v5;
LABEL_9:
      result = a1;
      break;
    case 0x1Du:
      *(_DWORD *)(v6 - 29) = v5;
LABEL_11:
      *(_DWORD *)(v6 - 25) = v5;
LABEL_12:
      *(_DWORD *)(v6 - 21) = v5;
LABEL_13:
      *(_DWORD *)(v6 - 17) = v5;
LABEL_14:
      *(_DWORD *)(v6 - 13) = v5;
LABEL_15:
      *(_DWORD *)(v6 - 9) = v5;
LABEL_16:
      *(_DWORD *)(v6 - 5) = v5;
LABEL_17:
      *(_BYTE *)(v6 - 1) = v5;
      result = a1;
      break;
    case 0x1Eu:
      *(_DWORD *)(v6 - 30) = v5;
LABEL_19:
      *(_DWORD *)(v6 - 26) = v5;
LABEL_20:
      *(_DWORD *)(v6 - 22) = v5;
LABEL_21:
      *(_DWORD *)(v6 - 18) = v5;
LABEL_22:
      *(_DWORD *)(v6 - 14) = v5;
LABEL_23:
      *(_DWORD *)(v6 - 10) = v5;
LABEL_24:
      *(_DWORD *)(v6 - 6) = v5;
LABEL_25:
      *(_WORD *)(v6 - 2) = v5;
      result = a1;
      break;
    case 0x1Fu:
      *(_DWORD *)(v6 - 31) = v5;
LABEL_27:
      *(_DWORD *)(v6 - 27) = v5;
LABEL_28:
      *(_DWORD *)(v6 - 23) = v5;
LABEL_29:
      *(_DWORD *)(v6 - 19) = v5;
LABEL_30:
      *(_DWORD *)(v6 - 15) = v5;
LABEL_31:
      *(_DWORD *)(v6 - 11) = v5;
LABEL_32:
      *(_DWORD *)(v6 - 7) = v5;
LABEL_33:
      *(_WORD *)(v6 - 3) = v5;
      *(_BYTE *)(v6 - 1) = v5;
      result = a1;
      break;
    default:
      v8 = _mm_shuffle_epi32(_mm_cvtsi32_si128(v5), 0);
      if ( (v6 & 0xF) != 0 )
      {
        *(__m128i *)v6 = v8;
        v6 = (v6 & 0xFFFFFFF0) + 16;
        v3 = a3 + a1 - v6 + a3;
        v5 = _mm_cvtsi128_si32(v8);
      }
      v9 = (__m128i *)(v3 + v6);
      switch ( v3 )
      {
        case 0u:
          goto LABEL_54;
        case 1u:
          goto LABEL_62;
        case 2u:
          goto LABEL_70;
        case 3u:
          goto LABEL_78;
        case 4u:
          goto LABEL_86;
        case 5u:
          goto LABEL_94;
        case 6u:
          goto LABEL_102;
        case 7u:
          goto LABEL_110;
        case 8u:
          goto LABEL_118;
        case 9u:
          goto LABEL_126;
        case 0xAu:
          goto LABEL_134;
        case 0xBu:
          goto LABEL_142;
        case 0xCu:
          goto LABEL_150;
        case 0xDu:
          goto LABEL_158;
        case 0xEu:
          goto LABEL_166;
        case 0xFu:
          goto LABEL_174;
        case 0x10u:
          goto LABEL_53;
        case 0x11u:
          goto LABEL_61;
        case 0x12u:
          goto LABEL_69;
        case 0x13u:
          goto LABEL_77;
        case 0x14u:
          goto LABEL_85;
        case 0x15u:
          goto LABEL_93;
        case 0x16u:
          goto LABEL_101;
        case 0x17u:
          goto LABEL_109;
        case 0x18u:
          goto LABEL_117;
        case 0x19u:
          goto LABEL_125;
        case 0x1Au:
          goto LABEL_133;
        case 0x1Bu:
          goto LABEL_141;
        case 0x1Cu:
          goto LABEL_149;
        case 0x1Du:
          goto LABEL_157;
        case 0x1Eu:
          goto LABEL_165;
        case 0x1Fu:
          goto LABEL_173;
        case 0x20u:
          goto LABEL_52;
        case 0x21u:
          goto LABEL_60;
        case 0x22u:
          goto LABEL_68;
        case 0x23u:
          goto LABEL_76;
        case 0x24u:
          goto LABEL_84;
        case 0x25u:
          goto LABEL_92;
        case 0x26u:
          goto LABEL_100;
        case 0x27u:
          goto LABEL_108;
        case 0x28u:
          goto LABEL_116;
        case 0x29u:
          goto LABEL_124;
        case 0x2Au:
          goto LABEL_132;
        case 0x2Bu:
          goto LABEL_140;
        case 0x2Cu:
          goto LABEL_148;
        case 0x2Du:
          goto LABEL_156;
        case 0x2Eu:
          goto LABEL_164;
        case 0x2Fu:
          goto LABEL_172;
        case 0x30u:
          goto LABEL_51;
        case 0x31u:
          goto LABEL_59;
        case 0x32u:
          goto LABEL_67;
        case 0x33u:
          goto LABEL_75;
        case 0x34u:
          goto LABEL_83;
        case 0x35u:
          goto LABEL_91;
        case 0x36u:
          goto LABEL_99;
        case 0x37u:
          goto LABEL_107;
        case 0x38u:
          goto LABEL_115;
        case 0x39u:
          goto LABEL_123;
        case 0x3Au:
          goto LABEL_131;
        case 0x3Bu:
          goto LABEL_139;
        case 0x3Cu:
          goto LABEL_147;
        case 0x3Du:
          goto LABEL_155;
        case 0x3Eu:
          goto LABEL_163;
        case 0x3Fu:
          goto LABEL_171;
        case 0x40u:
          goto LABEL_50;
        case 0x41u:
          goto LABEL_58;
        case 0x42u:
          goto LABEL_66;
        case 0x43u:
          goto LABEL_74;
        case 0x44u:
          goto LABEL_82;
        case 0x45u:
          goto LABEL_90;
        case 0x46u:
          goto LABEL_98;
        case 0x47u:
          goto LABEL_106;
        case 0x48u:
          goto LABEL_114;
        case 0x49u:
          goto LABEL_122;
        case 0x4Au:
          goto LABEL_130;
        case 0x4Bu:
          goto LABEL_138;
        case 0x4Cu:
          goto LABEL_146;
        case 0x4Du:
          goto LABEL_154;
        case 0x4Eu:
          goto LABEL_162;
        case 0x4Fu:
          goto LABEL_170;
        case 0x50u:
          goto LABEL_49;
        case 0x51u:
          goto LABEL_57;
        case 0x52u:
          goto LABEL_65;
        case 0x53u:
          goto LABEL_73;
        case 0x54u:
          goto LABEL_81;
        case 0x55u:
          goto LABEL_89;
        case 0x56u:
          goto LABEL_97;
        case 0x57u:
          goto LABEL_105;
        case 0x58u:
          goto LABEL_113;
        case 0x59u:
          goto LABEL_121;
        case 0x5Au:
          goto LABEL_129;
        case 0x5Bu:
          goto LABEL_137;
        case 0x5Cu:
          goto LABEL_145;
        case 0x5Du:
          goto LABEL_153;
        case 0x5Eu:
          goto LABEL_161;
        case 0x5Fu:
          goto LABEL_169;
        case 0x60u:
          goto LABEL_48;
        case 0x61u:
          goto LABEL_56;
        case 0x62u:
          goto LABEL_64;
        case 0x63u:
          goto LABEL_72;
        case 0x64u:
          goto LABEL_80;
        case 0x65u:
          goto LABEL_88;
        case 0x66u:
          goto LABEL_96;
        case 0x67u:
          goto LABEL_104;
        case 0x68u:
          goto LABEL_112;
        case 0x69u:
          goto LABEL_120;
        case 0x6Au:
          goto LABEL_128;
        case 0x6Bu:
          goto LABEL_136;
        case 0x6Cu:
          goto LABEL_144;
        case 0x6Du:
          goto LABEL_152;
        case 0x6Eu:
          goto LABEL_160;
        case 0x6Fu:
          goto LABEL_168;
        case 0x70u:
LABEL_47:
          v9[-7] = v8;
LABEL_48:
          v9[-6] = v8;
LABEL_49:
          v9[-5] = v8;
LABEL_50:
          v9[-4] = v8;
LABEL_51:
          v9[-3] = v8;
LABEL_52:
          v9[-2] = v8;
LABEL_53:
          v9[-1] = v8;
LABEL_54:
          result = a1;
          break;
        case 0x71u:
LABEL_55:
          *(__m128i *)((char *)v9 - 113) = v8;
LABEL_56:
          *(__m128i *)((char *)v9 - 97) = v8;
LABEL_57:
          *(__m128i *)((char *)v9 - 81) = v8;
LABEL_58:
          *(__m128i *)((char *)v9 - 65) = v8;
LABEL_59:
          *(__m128i *)((char *)v9 - 49) = v8;
LABEL_60:
          *(__m128i *)((char *)v9 - 33) = v8;
LABEL_61:
          *(__m128i *)((char *)v9 - 17) = v8;
LABEL_62:
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x72u:
LABEL_63:
          *(__m128i *)((char *)v9 - 114) = v8;
LABEL_64:
          *(__m128i *)((char *)v9 - 98) = v8;
LABEL_65:
          *(__m128i *)((char *)v9 - 82) = v8;
LABEL_66:
          *(__m128i *)((char *)v9 - 66) = v8;
LABEL_67:
          *(__m128i *)((char *)v9 - 50) = v8;
LABEL_68:
          *(__m128i *)((char *)v9 - 34) = v8;
LABEL_69:
          *(__m128i *)((char *)v9 - 18) = v8;
LABEL_70:
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x73u:
LABEL_71:
          *(__m128i *)((char *)v9 - 115) = v8;
LABEL_72:
          *(__m128i *)((char *)v9 - 99) = v8;
LABEL_73:
          *(__m128i *)((char *)v9 - 83) = v8;
LABEL_74:
          *(__m128i *)((char *)v9 - 67) = v8;
LABEL_75:
          *(__m128i *)((char *)v9 - 51) = v8;
LABEL_76:
          *(__m128i *)((char *)v9 - 35) = v8;
LABEL_77:
          *(__m128i *)((char *)v9 - 19) = v8;
LABEL_78:
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x74u:
LABEL_79:
          *(__m128i *)((char *)v9 - 116) = v8;
LABEL_80:
          *(__m128i *)((char *)v9 - 100) = v8;
LABEL_81:
          *(__m128i *)((char *)v9 - 84) = v8;
LABEL_82:
          *(__m128i *)((char *)v9 - 68) = v8;
LABEL_83:
          *(__m128i *)((char *)v9 - 52) = v8;
LABEL_84:
          *(__m128i *)((char *)v9 - 36) = v8;
LABEL_85:
          *(__m128i *)((char *)v9 - 20) = v8;
LABEL_86:
          v9[-1].m128i_i32[3] = v5;
          result = a1;
          break;
        case 0x75u:
LABEL_87:
          *(__m128i *)((char *)v9 - 117) = v8;
LABEL_88:
          *(__m128i *)((char *)v9 - 101) = v8;
LABEL_89:
          *(__m128i *)((char *)v9 - 85) = v8;
LABEL_90:
          *(__m128i *)((char *)v9 - 69) = v8;
LABEL_91:
          *(__m128i *)((char *)v9 - 53) = v8;
LABEL_92:
          *(__m128i *)((char *)v9 - 37) = v8;
LABEL_93:
          *(__m128i *)((char *)v9 - 21) = v8;
LABEL_94:
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 3) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x76u:
LABEL_95:
          *(__m128i *)((char *)v9 - 118) = v8;
LABEL_96:
          *(__m128i *)((char *)v9 - 102) = v8;
LABEL_97:
          *(__m128i *)((char *)v9 - 86) = v8;
LABEL_98:
          *(__m128i *)((char *)v9 - 70) = v8;
LABEL_99:
          *(__m128i *)((char *)v9 - 54) = v8;
LABEL_100:
          *(__m128i *)((char *)v9 - 38) = v8;
LABEL_101:
          *(__m128i *)((char *)v9 - 22) = v8;
LABEL_102:
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 2) = v5;
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x77u:
LABEL_103:
          *(__m128i *)((char *)v9 - 119) = v8;
LABEL_104:
          *(__m128i *)((char *)v9 - 103) = v8;
LABEL_105:
          *(__m128i *)((char *)v9 - 87) = v8;
LABEL_106:
          *(__m128i *)((char *)v9 - 71) = v8;
LABEL_107:
          *(__m128i *)((char *)v9 - 55) = v8;
LABEL_108:
          *(__m128i *)((char *)v9 - 39) = v8;
LABEL_109:
          *(__m128i *)((char *)v9 - 23) = v8;
LABEL_110:
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 1) = v5;
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x78u:
LABEL_111:
          *(__m128i *)((char *)v9 - 120) = v8;
LABEL_112:
          *(__m128i *)((char *)v9 - 104) = v8;
LABEL_113:
          *(__m128i *)((char *)v9 - 88) = v8;
LABEL_114:
          *(__m128i *)((char *)v9 - 72) = v8;
LABEL_115:
          *(__m128i *)((char *)v9 - 56) = v8;
LABEL_116:
          *(__m128i *)((char *)v9 - 40) = v8;
LABEL_117:
          *(__m128i *)((char *)v9 - 24) = v8;
LABEL_118:
          v9[-1].m128i_i64[1] = v8.m128i_i64[0];
          result = a1;
          break;
        case 0x79u:
LABEL_119:
          *(__m128i *)((char *)v9 - 121) = v8;
LABEL_120:
          *(__m128i *)((char *)v9 - 105) = v8;
LABEL_121:
          *(__m128i *)((char *)v9 - 89) = v8;
LABEL_122:
          *(__m128i *)((char *)v9 - 73) = v8;
LABEL_123:
          *(__m128i *)((char *)v9 - 57) = v8;
LABEL_124:
          *(__m128i *)((char *)v9 - 41) = v8;
LABEL_125:
          *(__m128i *)((char *)v9 - 25) = v8;
LABEL_126:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 7) = v8.m128i_i64[0];
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x7Au:
LABEL_127:
          *(__m128i *)((char *)v9 - 122) = v8;
LABEL_128:
          *(__m128i *)((char *)v9 - 106) = v8;
LABEL_129:
          *(__m128i *)((char *)v9 - 90) = v8;
LABEL_130:
          *(__m128i *)((char *)v9 - 74) = v8;
LABEL_131:
          *(__m128i *)((char *)v9 - 58) = v8;
LABEL_132:
          *(__m128i *)((char *)v9 - 42) = v8;
LABEL_133:
          *(__m128i *)((char *)v9 - 26) = v8;
LABEL_134:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 6) = v8.m128i_i64[0];
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x7Bu:
LABEL_135:
          *(__m128i *)((char *)v9 - 123) = v8;
LABEL_136:
          *(__m128i *)((char *)v9 - 107) = v8;
LABEL_137:
          *(__m128i *)((char *)v9 - 91) = v8;
LABEL_138:
          *(__m128i *)((char *)v9 - 75) = v8;
LABEL_139:
          *(__m128i *)((char *)v9 - 59) = v8;
LABEL_140:
          *(__m128i *)((char *)v9 - 43) = v8;
LABEL_141:
          *(__m128i *)((char *)v9 - 27) = v8;
LABEL_142:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 5) = v8.m128i_i64[0];
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x7Cu:
LABEL_143:
          *(__m128i *)((char *)v9 - 124) = v8;
LABEL_144:
          *(__m128i *)((char *)v9 - 108) = v8;
LABEL_145:
          *(__m128i *)((char *)v9 - 92) = v8;
LABEL_146:
          *(__m128i *)((char *)v9 - 76) = v8;
LABEL_147:
          *(__m128i *)((char *)v9 - 60) = v8;
LABEL_148:
          *(__m128i *)((char *)v9 - 44) = v8;
LABEL_149:
          *(__m128i *)((char *)v9 - 28) = v8;
LABEL_150:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 4) = v8.m128i_i64[0];
          v9[-1].m128i_i32[3] = v5;
          result = a1;
          break;
        case 0x7Du:
LABEL_151:
          *(__m128i *)((char *)v9 - 125) = v8;
LABEL_152:
          *(__m128i *)((char *)v9 - 109) = v8;
LABEL_153:
          *(__m128i *)((char *)v9 - 93) = v8;
LABEL_154:
          *(__m128i *)((char *)v9 - 77) = v8;
LABEL_155:
          *(__m128i *)((char *)v9 - 61) = v8;
LABEL_156:
          *(__m128i *)((char *)v9 - 45) = v8;
LABEL_157:
          *(__m128i *)((char *)v9 - 29) = v8;
LABEL_158:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 3) = v8.m128i_i64[0];
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 3) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        case 0x7Eu:
LABEL_159:
          *(__m128i *)((char *)v9 - 126) = v8;
LABEL_160:
          *(__m128i *)((char *)v9 - 110) = v8;
LABEL_161:
          *(__m128i *)((char *)v9 - 94) = v8;
LABEL_162:
          *(__m128i *)((char *)v9 - 78) = v8;
LABEL_163:
          *(__m128i *)((char *)v9 - 62) = v8;
LABEL_164:
          *(__m128i *)((char *)v9 - 46) = v8;
LABEL_165:
          *(__m128i *)((char *)v9 - 30) = v8;
LABEL_166:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 2) = v8.m128i_i64[0];
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 2) = v5;
          v9[-1].m128i_i16[7] = v5;
          result = a1;
          break;
        case 0x7Fu:
LABEL_167:
          *(__m128i *)((char *)v9 - 127) = v8;
LABEL_168:
          *(__m128i *)((char *)v9 - 111) = v8;
LABEL_169:
          *(__m128i *)((char *)v9 - 95) = v8;
LABEL_170:
          *(__m128i *)((char *)v9 - 79) = v8;
LABEL_171:
          *(__m128i *)((char *)v9 - 63) = v8;
LABEL_172:
          *(__m128i *)((char *)v9 - 47) = v8;
LABEL_173:
          *(__m128i *)((char *)v9 - 31) = v8;
LABEL_174:
          *(__int64 *)((char *)v9[-1].m128i_i64 + 1) = v8.m128i_i64[0];
          *(__int32 *)((char *)&v9[-1].m128i_i32[2] + 1) = v5;
          *(__int16 *)((char *)&v9[-1].m128i_i16[6] + 1) = v5;
          v9[-1].m128i_i8[15] = v5;
          result = a1;
          break;
        default:
          if ( v3 < _x86_data_cache_size - ((unsigned int)_x86_data_cache_size >> 4) )
          {
            v10 = v3 - 128;
            do
            {
              v11 = v10 < 0x80;
              v10 -= 128;
              *v9 = v8;
              v9[1] = v8;
              v9[2] = v8;
              v9[3] = v8;
              v9[4] = v8;
              v9[5] = v8;
              v9[6] = v8;
              v9[7] = v8;
              v9 += 8;
              if ( v11 )
                break;
              v11 = v10 < 0x80;
              v10 -= 128;
              *v9 = v8;
              v9[1] = v8;
              v9[2] = v8;
              v9[3] = v8;
              v9[4] = v8;
              v9[5] = v8;
              v9[6] = v8;
              v9[7] = v8;
              v9 += 8;
            }
            while ( !v11 );
            v12 = v10 + 128;
            v9 = (__m128i *)((char *)v9 + v12);
            switch ( v12 )
            {
              case 0u:
                goto LABEL_54;
              case 1u:
                goto LABEL_62;
              case 2u:
                goto LABEL_70;
              case 3u:
                goto LABEL_78;
              case 4u:
                goto LABEL_86;
              case 5u:
                goto LABEL_94;
              case 6u:
                goto LABEL_102;
              case 7u:
                goto LABEL_110;
              case 8u:
                goto LABEL_118;
              case 9u:
                goto LABEL_126;
              case 0xAu:
                goto LABEL_134;
              case 0xBu:
                goto LABEL_142;
              case 0xCu:
                goto LABEL_150;
              case 0xDu:
                goto LABEL_158;
              case 0xEu:
                goto LABEL_166;
              case 0xFu:
                goto LABEL_174;
              case 0x10u:
                goto LABEL_53;
              case 0x11u:
                goto LABEL_61;
              case 0x12u:
                goto LABEL_69;
              case 0x13u:
                goto LABEL_77;
              case 0x14u:
                goto LABEL_85;
              case 0x15u:
                goto LABEL_93;
              case 0x16u:
                goto LABEL_101;
              case 0x17u:
                goto LABEL_109;
              case 0x18u:
                goto LABEL_117;
              case 0x19u:
                goto LABEL_125;
              case 0x1Au:
                goto LABEL_133;
              case 0x1Bu:
                goto LABEL_141;
              case 0x1Cu:
                goto LABEL_149;
              case 0x1Du:
                goto LABEL_157;
              case 0x1Eu:
                goto LABEL_165;
              case 0x1Fu:
                goto LABEL_173;
              case 0x20u:
                goto LABEL_52;
              case 0x21u:
                goto LABEL_60;
              case 0x22u:
                goto LABEL_68;
              case 0x23u:
                goto LABEL_76;
              case 0x24u:
                goto LABEL_84;
              case 0x25u:
                goto LABEL_92;
              case 0x26u:
                goto LABEL_100;
              case 0x27u:
                goto LABEL_108;
              case 0x28u:
                goto LABEL_116;
              case 0x29u:
                goto LABEL_124;
              case 0x2Au:
                goto LABEL_132;
              case 0x2Bu:
                goto LABEL_140;
              case 0x2Cu:
                goto LABEL_148;
              case 0x2Du:
                goto LABEL_156;
              case 0x2Eu:
                goto LABEL_164;
              case 0x2Fu:
                goto LABEL_172;
              case 0x30u:
                goto LABEL_51;
              case 0x31u:
                goto LABEL_59;
              case 0x32u:
                goto LABEL_67;
              case 0x33u:
                goto LABEL_75;
              case 0x34u:
                goto LABEL_83;
              case 0x35u:
                goto LABEL_91;
              case 0x36u:
                goto LABEL_99;
              case 0x37u:
                goto LABEL_107;
              case 0x38u:
                goto LABEL_115;
              case 0x39u:
                goto LABEL_123;
              case 0x3Au:
                goto LABEL_131;
              case 0x3Bu:
                goto LABEL_139;
              case 0x3Cu:
                goto LABEL_147;
              case 0x3Du:
                goto LABEL_155;
              case 0x3Eu:
                goto LABEL_163;
              case 0x3Fu:
                goto LABEL_171;
              case 0x40u:
                goto LABEL_50;
              case 0x41u:
                goto LABEL_58;
              case 0x42u:
                goto LABEL_66;
              case 0x43u:
                goto LABEL_74;
              case 0x44u:
                goto LABEL_82;
              case 0x45u:
                goto LABEL_90;
              case 0x46u:
                goto LABEL_98;
              case 0x47u:
                goto LABEL_106;
              case 0x48u:
                goto LABEL_114;
              case 0x49u:
                goto LABEL_122;
              case 0x4Au:
                goto LABEL_130;
              case 0x4Bu:
                goto LABEL_138;
              case 0x4Cu:
                goto LABEL_146;
              case 0x4Du:
                goto LABEL_154;
              case 0x4Eu:
                goto LABEL_162;
              case 0x4Fu:
                goto LABEL_170;
              case 0x50u:
                goto LABEL_49;
              case 0x51u:
                goto LABEL_57;
              case 0x52u:
                goto LABEL_65;
              case 0x53u:
                goto LABEL_73;
              case 0x54u:
                goto LABEL_81;
              case 0x55u:
                goto LABEL_89;
              case 0x56u:
                goto LABEL_97;
              case 0x57u:
                goto LABEL_105;
              case 0x58u:
                goto LABEL_113;
              case 0x59u:
                goto LABEL_121;
              case 0x5Au:
                goto LABEL_129;
              case 0x5Bu:
                goto LABEL_137;
              case 0x5Cu:
                goto LABEL_145;
              case 0x5Du:
                goto LABEL_153;
              case 0x5Eu:
                goto LABEL_161;
              case 0x5Fu:
                goto LABEL_169;
              case 0x60u:
                goto LABEL_48;
              case 0x61u:
                goto LABEL_56;
              case 0x62u:
                goto LABEL_64;
              case 0x63u:
                goto LABEL_72;
              case 0x64u:
                goto LABEL_80;
              case 0x65u:
                goto LABEL_88;
              case 0x66u:
                goto LABEL_96;
              case 0x67u:
                goto LABEL_104;
              case 0x68u:
                goto LABEL_112;
              case 0x69u:
                goto LABEL_120;
              case 0x6Au:
                goto LABEL_128;
              case 0x6Bu:
                goto LABEL_136;
              case 0x6Cu:
                goto LABEL_144;
              case 0x6Du:
                goto LABEL_152;
              case 0x6Eu:
                goto LABEL_160;
              case 0x6Fu:
                goto LABEL_168;
              case 0x70u:
                goto LABEL_47;
              case 0x71u:
                goto LABEL_55;
              case 0x72u:
                goto LABEL_63;
              case 0x73u:
                goto LABEL_71;
              case 0x74u:
                goto LABEL_79;
              case 0x75u:
                goto LABEL_87;
              case 0x76u:
                goto LABEL_95;
              case 0x77u:
                goto LABEL_103;
              case 0x78u:
                goto LABEL_111;
              case 0x79u:
                goto LABEL_119;
              case 0x7Au:
                goto LABEL_127;
              case 0x7Bu:
                goto LABEL_135;
              case 0x7Cu:
                goto LABEL_143;
              case 0x7Du:
                goto LABEL_151;
              case 0x7Eu:
                goto LABEL_159;
              case 0x7Fu:
                goto LABEL_167;
            }
          }
          v13 = v9;
          v14 = v3;
          v15 = v3 >> 2;
          v16 = v14 & 3;
          memset32(v13, v5, v15);
          v17 = &v13->m128i_i8[4 * v15];
          if ( v16 )
          {
            if ( v16 < 2 || (*(_WORD *)v17 = v5, v17 += 2, v16 != 2) )
              *v17 = v5;
          }
          result = a1;
          break;
      }
      break;
  }
  return result;
}
// 80EF554: using guessed type int _x86_data_cache_size;

//----- (08051280) --------------------------------------------------------
int __cdecl _memcmp_ssse3(const __m128i *a1, const __m128i *a2, unsigned int a3)
{
  unsigned int v3; // ecx
  int v4; // edx
  __int8 *v5; // eax
  int result; // eax
  unsigned int v7; // edi
  int v8; // edx
  const __m128i *v9; // esi
  int v10; // edx
  __m128i *v11; // esi
  unsigned int v12; // ecx
  unsigned int v13; // edx
  int v14; // eax
  __m128i v15; // xmm1
  int v16; // edx
  __m128i v17; // xmm0
  __m128i v18; // xmm2
  unsigned __int64 v19; // kr00_8
  __m128i v20; // xmm2
  bool v21; // cf
  __m128i v22; // xmm2
  int v23; // edx
  __m128i v24; // xmm0
  __m128i v25; // xmm3
  int v26; // kr08_4
  int v27; // edx
  __m128i v28; // xmm3
  __m128i v29; // xmm3
  __m128i v30; // xmm2
  int v31; // edx
  __m128i v32; // xmm0
  __m128i v33; // xmm3
  int v34; // kr10_4
  int v35; // edx
  __m128i v36; // xmm3
  __m128i v37; // xmm3
  __m128i v38; // xmm2
  int v39; // edx
  __m128i v40; // xmm0
  __m128i v41; // xmm3
  int v42; // kr18_4
  int v43; // edx
  __m128i v44; // xmm3
  __m128i v45; // xmm3
  __m128i v46; // xmm2
  int v47; // edx
  __m128i v48; // xmm0
  __m128i v49; // xmm3
  int v50; // kr20_4
  int v51; // edx
  __m128i v52; // xmm3
  __m128i v53; // xmm3
  __m128i v54; // xmm2
  int v55; // edx
  __m128i v56; // xmm0
  __m128i v57; // xmm3
  int v58; // kr28_4
  int v59; // edx
  __m128i v60; // xmm3
  __m128i v61; // xmm3
  __m128i v62; // xmm2
  int v63; // edx
  __m128i v64; // xmm0
  __m128i v65; // xmm3
  int v66; // kr30_4
  int v67; // edx
  __m128i v68; // xmm3
  __m128i v69; // xmm3
  __m128i v70; // xmm2
  int v71; // edx
  __m128i v72; // xmm0
  __m128i v73; // xmm3
  int v74; // kr38_4
  int v75; // edx
  __m128i v76; // xmm3
  __m128i v77; // xmm3
  __m128i si128; // xmm2
  int v79; // edx
  __m128i v80; // xmm0
  __m128i v81; // xmm3
  int v82; // kr40_4
  int v83; // edx
  __m128i v84; // xmm3
  __m128i v85; // xmm3
  __m128i v86; // xmm2
  int v87; // edx
  __m128i v88; // xmm0
  __m128i v89; // xmm3
  int v90; // kr48_4
  int v91; // edx
  __m128i v92; // xmm3
  __m128i v93; // xmm3
  __m128i v94; // xmm2
  int v95; // edx
  __m128i v96; // xmm0
  __m128i v97; // xmm3
  int v98; // kr50_4
  int v99; // edx
  __m128i v100; // xmm3
  __m128i v101; // xmm3
  __m128i v102; // xmm2
  int v103; // edx
  __m128i v104; // xmm0
  __m128i v105; // xmm3
  int v106; // kr58_4
  int v107; // edx
  __m128i v108; // xmm3
  __m128i v109; // xmm3
  __m128i v110; // xmm2
  int v111; // edx
  __m128i v112; // xmm0
  __m128i v113; // xmm3
  int v114; // kr60_4
  int v115; // edx
  __m128i v116; // xmm3
  __m128i v117; // xmm3
  __m128i v118; // xmm2
  int v119; // edx
  __m128i v120; // xmm0
  __m128i v121; // xmm3
  int v122; // kr68_4
  int v123; // edx
  __m128i v124; // xmm3
  __m128i v125; // xmm3
  __m128i v126; // xmm2
  int v127; // edx
  __m128i v128; // xmm0
  __m128i v129; // xmm3
  int v130; // kr70_4
  int v131; // edx
  __m128i v132; // xmm3
  __m128i v133; // xmm3
  __m128i v134; // xmm2
  int v135; // edx
  __m128i v136; // xmm0
  __m128i v137; // xmm3
  int v138; // kr78_4
  int v139; // edx
  __m128i v140; // xmm3
  __m128i v141; // xmm3
  int v142; // ebx
  unsigned int v143; // ecx
  unsigned int v144; // ebx
  unsigned __int8 v145; // cl
  bool v146; // cc
  __int16 v147; // cx
  __int16 v148; // bx
  unsigned __int16 v149; // cx
  unsigned __int16 v150; // bx
  unsigned __int8 v151; // al
  bool v152; // zf
  unsigned int v153; // ecx
  unsigned int v154; // ebx

  v3 = a3;
  if ( a3 >= 0x30 )
  {
    v7 = (unsigned int)&a1[1];
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), _mm_loadu_si128(a2))) - 0xFFFF;
    v9 = a2 + 1;
    if ( v8 )
      goto LABEL_192;
    v10 = v7 & 0xF;
    v7 ^= v10;
    v11 = (__m128i *)((char *)v9 - v10);
    v12 = v10 + a3;
    v13 = (unsigned __int8)v11 & 0xF;
    if ( ((unsigned __int8)v11 & 0xF) == 0 )
      goto LABEL_29;
    v11 = (__m128i *)(v13 ^ (unsigned int)v11);
    if ( v13 >= 8 )
    {
      switch ( v13 )
      {
        case 8u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 8;
          if ( v21 )
          {
            si128 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(si128, *v11, 8), *(__m128i *)v7);
            v79 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), si128, 8), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v79 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[2] + v3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v80 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 8), *(__m128i *)v7);
            v81 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 8), *(__m128i *)(v7 + 16));
            do
            {
              v83 = _mm_movemask_epi8(_mm_and_si128(v81, v80));
              v15 = v80;
              v84 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 8);
              v82 = v3 - 32;
              v8 = (__PAIR64__(v83, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v80 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 8), *(__m128i *)(v7 + 32));
              v11 += 2;
              v81 = _mm_cmpeq_epi8(v84, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v85 = _mm_and_si128(v81, v80);
            if ( v82 < 0 )
            {
              ++v8;
              v3 = v82 + 32;
            }
            if ( !v8 )
            {
              v15 = v80;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v85) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[2] + v3;
                goto LABEL_252;
              }
            }
          }
          break;
        case 9u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 9;
          if ( v21 )
          {
            v86 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v86, *v11, 9), *(__m128i *)v7);
            v87 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v86, 9), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v87 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[2] + v3 + 1;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v88 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 9), *(__m128i *)v7);
            v89 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 9), *(__m128i *)(v7 + 16));
            do
            {
              v91 = _mm_movemask_epi8(_mm_and_si128(v89, v88));
              v15 = v88;
              v92 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 9);
              v90 = v3 - 32;
              v8 = (__PAIR64__(v91, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v88 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 9), *(__m128i *)(v7 + 32));
              v11 += 2;
              v89 = _mm_cmpeq_epi8(v92, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v93 = _mm_and_si128(v89, v88);
            if ( v90 < 0 )
            {
              ++v8;
              v3 = v90 + 32;
            }
            if ( !v8 )
            {
              v15 = v88;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v93) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[2] + v3 + 1;
                goto LABEL_252;
              }
            }
          }
          break;
        case 0xAu:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 10;
          if ( v21 )
          {
            v94 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v94, *v11, 10), *(__m128i *)v7);
            v95 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v94, 10), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v95 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[2] + v3 + 2;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v96 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 10), *(__m128i *)v7);
            v97 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 10), *(__m128i *)(v7 + 16));
            do
            {
              v99 = _mm_movemask_epi8(_mm_and_si128(v97, v96));
              v15 = v96;
              v100 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 10);
              v98 = v3 - 32;
              v8 = (__PAIR64__(v99, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v96 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 10), *(__m128i *)(v7 + 32));
              v11 += 2;
              v97 = _mm_cmpeq_epi8(v100, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v101 = _mm_and_si128(v97, v96);
            if ( v98 < 0 )
            {
              ++v8;
              v3 = v98 + 32;
            }
            if ( !v8 )
            {
              v15 = v96;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v101) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[2] + v3 + 2;
                goto LABEL_252;
              }
            }
          }
          break;
        case 0xBu:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 11;
          if ( v21 )
          {
            v102 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v102, *v11, 11), *(__m128i *)v7);
            v103 = _mm_movemask_epi8(
                     _mm_and_si128(
                       _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v102, 11), *(__m128i *)(v7 + 16)),
                       v15));
            v7 += 32;
            v11 += 2;
            v8 = v103 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[2] + v3 + 3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v104 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 11), *(__m128i *)v7);
            v105 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 11), *(__m128i *)(v7 + 16));
            do
            {
              v107 = _mm_movemask_epi8(_mm_and_si128(v105, v104));
              v15 = v104;
              v108 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 11);
              v106 = v3 - 32;
              v8 = (__PAIR64__(v107, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v104 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 11), *(__m128i *)(v7 + 32));
              v11 += 2;
              v105 = _mm_cmpeq_epi8(v108, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v109 = _mm_and_si128(v105, v104);
            if ( v106 < 0 )
            {
              ++v8;
              v3 = v106 + 32;
            }
            if ( !v8 )
            {
              v15 = v104;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v109) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[2] + v3 + 3;
                goto LABEL_252;
              }
            }
          }
          break;
        case 0xCu:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 12;
          if ( v21 )
          {
            v110 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v110, *v11, 12), *(__m128i *)v7);
            v111 = _mm_movemask_epi8(
                     _mm_and_si128(
                       _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v110, 12), *(__m128i *)(v7 + 16)),
                       v15));
            v7 += 32;
            v11 += 2;
            v8 = v111 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[3] + v3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v112 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 12), *(__m128i *)v7);
            v113 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 12), *(__m128i *)(v7 + 16));
            do
            {
              v115 = _mm_movemask_epi8(_mm_and_si128(v113, v112));
              v15 = v112;
              v116 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 12);
              v114 = v3 - 32;
              v8 = (__PAIR64__(v115, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v112 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 12), *(__m128i *)(v7 + 32));
              v11 += 2;
              v113 = _mm_cmpeq_epi8(v116, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v117 = _mm_and_si128(v113, v112);
            if ( v114 < 0 )
            {
              ++v8;
              v3 = v114 + 32;
            }
            if ( !v8 )
            {
              v15 = v112;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v117) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[3] + v3;
                goto LABEL_252;
              }
            }
          }
          break;
        case 0xDu:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 13;
          if ( v21 )
          {
            v118 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v118, *v11, 13), *(__m128i *)v7);
            v119 = _mm_movemask_epi8(
                     _mm_and_si128(
                       _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v118, 13), *(__m128i *)(v7 + 16)),
                       v15));
            v7 += 32;
            v11 += 2;
            v8 = v119 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[3] + v3 + 1;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v120 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 13), *(__m128i *)v7);
            v121 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 13), *(__m128i *)(v7 + 16));
            do
            {
              v123 = _mm_movemask_epi8(_mm_and_si128(v121, v120));
              v15 = v120;
              v124 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 13);
              v122 = v3 - 32;
              v8 = (__PAIR64__(v123, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v120 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 13), *(__m128i *)(v7 + 32));
              v11 += 2;
              v121 = _mm_cmpeq_epi8(v124, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v125 = _mm_and_si128(v121, v120);
            if ( v122 < 0 )
            {
              ++v8;
              v3 = v122 + 32;
            }
            if ( !v8 )
            {
              v15 = v120;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v125) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[3] + v3 + 1;
                goto LABEL_252;
              }
            }
          }
          break;
        case 0xEu:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 14;
          if ( v21 )
          {
            v126 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v126, *v11, 14), *(__m128i *)v7);
            v127 = _mm_movemask_epi8(
                     _mm_and_si128(
                       _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v126, 14), *(__m128i *)(v7 + 16)),
                       v15));
            v7 += 32;
            v11 += 2;
            v8 = v127 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[3] + v3 + 2;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v128 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 14), *(__m128i *)v7);
            v129 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 14), *(__m128i *)(v7 + 16));
            do
            {
              v131 = _mm_movemask_epi8(_mm_and_si128(v129, v128));
              v15 = v128;
              v132 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 14);
              v130 = v3 - 32;
              v8 = (__PAIR64__(v131, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v128 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 14), *(__m128i *)(v7 + 32));
              v11 += 2;
              v129 = _mm_cmpeq_epi8(v132, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v133 = _mm_and_si128(v129, v128);
            if ( v130 < 0 )
            {
              ++v8;
              v3 = v130 + 32;
            }
            if ( !v8 )
            {
              v15 = v128;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v133) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[3] + v3 + 2;
                goto LABEL_252;
              }
            }
          }
          break;
        default:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = v13;
          if ( v21 )
          {
            v134 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v134, *v11, 15), *(__m128i *)v7);
            v135 = _mm_movemask_epi8(
                     _mm_and_si128(
                       _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v134, 15), *(__m128i *)(v7 + 16)),
                       v15));
            v7 += 32;
            v11 += 2;
            v8 = v135 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[3] + v3 + 3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v136 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 15), *(__m128i *)v7);
            v137 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 15), *(__m128i *)(v7 + 16));
            do
            {
              v139 = _mm_movemask_epi8(_mm_and_si128(v137, v136));
              v15 = v136;
              v140 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 15);
              v138 = v3 - 32;
              v8 = (__PAIR64__(v139, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v136 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 15), *(__m128i *)(v7 + 32));
              v11 += 2;
              v137 = _mm_cmpeq_epi8(v140, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v141 = _mm_and_si128(v137, v136);
            if ( v138 < 0 )
            {
              ++v8;
              v3 = v138 + 32;
            }
            if ( !v8 )
            {
              v15 = v136;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v141) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[3] + v3 + 3;
                goto LABEL_252;
              }
            }
          }
          break;
      }
      goto LABEL_189;
    }
    if ( v13 )
    {
      switch ( v13 )
      {
        case 1u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 1;
          if ( v21 )
          {
            v22 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v22, *v11, 1), *(__m128i *)v7);
            v23 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v22, 1), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v23 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)v11->m128i_i32 + v3 + 1;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v24 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 1), *(__m128i *)v7);
            v25 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 1), *(__m128i *)(v7 + 16));
            do
            {
              v27 = _mm_movemask_epi8(_mm_and_si128(v25, v24));
              v15 = v24;
              v28 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 1);
              v26 = v3 - 32;
              v8 = (__PAIR64__(v27, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v24 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 1), *(__m128i *)(v7 + 32));
              v11 += 2;
              v25 = _mm_cmpeq_epi8(v28, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v29 = _mm_and_si128(v25, v24);
            if ( v26 < 0 )
            {
              ++v8;
              v3 = v26 + 32;
            }
            if ( !v8 )
            {
              v15 = v24;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v29) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)v11->m128i_i32 + v3 + 1;
                goto LABEL_252;
              }
            }
          }
          break;
        case 2u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 2;
          if ( v21 )
          {
            v30 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v30, *v11, 2), *(__m128i *)v7);
            v31 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v30, 2), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v31 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)v11->m128i_i32 + v3 + 2;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v32 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 2), *(__m128i *)v7);
            v33 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 2), *(__m128i *)(v7 + 16));
            do
            {
              v35 = _mm_movemask_epi8(_mm_and_si128(v33, v32));
              v15 = v32;
              v36 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 2);
              v34 = v3 - 32;
              v8 = (__PAIR64__(v35, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v32 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 2), *(__m128i *)(v7 + 32));
              v11 += 2;
              v33 = _mm_cmpeq_epi8(v36, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v37 = _mm_and_si128(v33, v32);
            if ( v34 < 0 )
            {
              ++v8;
              v3 = v34 + 32;
            }
            if ( !v8 )
            {
              v15 = v32;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v37) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)v11->m128i_i32 + v3 + 2;
                goto LABEL_252;
              }
            }
          }
          break;
        case 3u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 3;
          if ( v21 )
          {
            v38 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v38, *v11, 3), *(__m128i *)v7);
            v39 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v38, 3), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v39 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)v11->m128i_i32 + v3 + 3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v40 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 3), *(__m128i *)v7);
            v41 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 3), *(__m128i *)(v7 + 16));
            do
            {
              v43 = _mm_movemask_epi8(_mm_and_si128(v41, v40));
              v15 = v40;
              v44 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 3);
              v42 = v3 - 32;
              v8 = (__PAIR64__(v43, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v40 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 3), *(__m128i *)(v7 + 32));
              v11 += 2;
              v41 = _mm_cmpeq_epi8(v44, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v45 = _mm_and_si128(v41, v40);
            if ( v42 < 0 )
            {
              ++v8;
              v3 = v42 + 32;
            }
            if ( !v8 )
            {
              v15 = v40;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v45) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)v11->m128i_i32 + v3 + 3;
                goto LABEL_252;
              }
            }
          }
          break;
        case 4u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 4;
          if ( v21 )
          {
            v46 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v46, *v11, 4), *(__m128i *)v7);
            v47 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v46, 4), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v47 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[1] + v3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v48 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 4), *(__m128i *)v7);
            v49 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 4), *(__m128i *)(v7 + 16));
            do
            {
              v51 = _mm_movemask_epi8(_mm_and_si128(v49, v48));
              v15 = v48;
              v52 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 4);
              v50 = v3 - 32;
              v8 = (__PAIR64__(v51, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v48 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 4), *(__m128i *)(v7 + 32));
              v11 += 2;
              v49 = _mm_cmpeq_epi8(v52, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v53 = _mm_and_si128(v49, v48);
            if ( v50 < 0 )
            {
              ++v8;
              v3 = v50 + 32;
            }
            if ( !v8 )
            {
              v15 = v48;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v53) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[1] + v3;
                goto LABEL_252;
              }
            }
          }
          break;
        case 5u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 5;
          if ( v21 )
          {
            v54 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v54, *v11, 5), *(__m128i *)v7);
            v55 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v54, 5), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v55 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[1] + v3 + 1;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v56 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 5), *(__m128i *)v7);
            v57 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 5), *(__m128i *)(v7 + 16));
            do
            {
              v59 = _mm_movemask_epi8(_mm_and_si128(v57, v56));
              v15 = v56;
              v60 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 5);
              v58 = v3 - 32;
              v8 = (__PAIR64__(v59, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v56 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 5), *(__m128i *)(v7 + 32));
              v11 += 2;
              v57 = _mm_cmpeq_epi8(v60, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v61 = _mm_and_si128(v57, v56);
            if ( v58 < 0 )
            {
              ++v8;
              v3 = v58 + 32;
            }
            if ( !v8 )
            {
              v15 = v56;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v61) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[1] + v3 + 1;
                goto LABEL_252;
              }
            }
          }
          break;
        case 6u:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 6;
          if ( v21 )
          {
            v62 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v62, *v11, 6), *(__m128i *)v7);
            v63 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v62, 6), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v63 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[1] + v3 + 2;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v64 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 6), *(__m128i *)v7);
            v65 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 6), *(__m128i *)(v7 + 16));
            do
            {
              v67 = _mm_movemask_epi8(_mm_and_si128(v65, v64));
              v15 = v64;
              v68 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 6);
              v66 = v3 - 32;
              v8 = (__PAIR64__(v67, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v64 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 6), *(__m128i *)(v7 + 32));
              v11 += 2;
              v65 = _mm_cmpeq_epi8(v68, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v69 = _mm_and_si128(v65, v64);
            if ( v66 < 0 )
            {
              ++v8;
              v3 = v66 + 32;
            }
            if ( !v8 )
            {
              v15 = v64;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v69) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[1] + v3 + 2;
                goto LABEL_252;
              }
            }
          }
          break;
        default:
          v21 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = v13;
          if ( v21 )
          {
            v70 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v70, *v11, 7), *(__m128i *)v7);
            v71 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v70, 7), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32;
            v11 += 2;
            v8 = v71 - 0xFFFF;
            if ( !v8 )
            {
              v5 = (__int8 *)(v3 + v7);
              v4 = (int)&v11->m128i_i32[1] + v3 + 3;
              goto LABEL_252;
            }
          }
          else
          {
            v3 -= 32;
            v72 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 7), *(__m128i *)v7);
            v73 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 7), *(__m128i *)(v7 + 16));
            do
            {
              v75 = _mm_movemask_epi8(_mm_and_si128(v73, v72));
              v15 = v72;
              v76 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 7);
              v74 = v3 - 32;
              v8 = (__PAIR64__(v75, v3) - 0xFFFF00000020LL) >> 32;
              v3 -= 32;
              v72 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 7), *(__m128i *)(v7 + 32));
              v11 += 2;
              v73 = _mm_cmpeq_epi8(v76, *(__m128i *)(v7 + 48));
              v7 += 32;
            }
            while ( !v8 );
            v77 = _mm_and_si128(v73, v72);
            if ( v74 < 0 )
            {
              ++v8;
              v3 = v74 + 32;
            }
            if ( !v8 )
            {
              v15 = v72;
              v7 += 32;
              v11 += 2;
              v8 = _mm_movemask_epi8(v77) - 0xFFFF;
              if ( !v8 )
              {
                v5 = (__int8 *)(v3 + v7);
                v4 = (int)&v11->m128i_i32[1] + v3 + 3;
                goto LABEL_252;
              }
            }
          }
          break;
      }
    }
    else
    {
LABEL_29:
      if ( v12 >= 0x50 )
      {
        v14 = 0;
        v17 = _mm_cmpeq_epi8(_mm_load_si128(v11), *(__m128i *)v7);
        v3 = v12 - 80;
        v18 = _mm_cmpeq_epi8(_mm_load_si128(v11 + 1), *(__m128i *)(v7 + 16));
        do
        {
          v15 = v17;
          v19 = __PAIR64__(_mm_movemask_epi8(_mm_and_si128(v18, v17)), v3) - 0xFFFF00000020LL;
          v8 = HIDWORD(v19);
          v3 = v19;
          v17 = _mm_cmpeq_epi8(_mm_load_si128(v11 + 2), *(__m128i *)(v7 + 32));
          v18 = _mm_cmpeq_epi8(_mm_load_si128(v11 + 3), *(__m128i *)(v7 + 48));
          v7 += 32;
          v11 += 2;
        }
        while ( !HIDWORD(v19) );
        v20 = _mm_and_si128(v18, v17);
        if ( (v19 & 0x80000000) != 0LL )
        {
          v8 = HIDWORD(v19) + 1;
          v3 = v19 + 32;
        }
        if ( !v8 )
        {
          v15 = v17;
          v7 += 32;
          v11 += 2;
          v8 = _mm_movemask_epi8(v20) - 0xFFFF;
          if ( !v8 )
          {
            v5 = (__int8 *)(v3 + v7);
            v4 = (int)v11->m128i_i32 + v3;
            goto LABEL_252;
          }
        }
      }
      else
      {
        v3 = v12 - 48;
        v14 = 0;
        v15 = _mm_cmpeq_epi8(*v11, *(__m128i *)v7);
        v16 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(v11[1], *(__m128i *)(v7 + 16)), v15));
        v7 += 32;
        v11 += 2;
        v8 = v16 - 0xFFFF;
        if ( !v8 )
        {
          v5 = (__int8 *)(v3 + v7);
          v4 = (int)v11->m128i_i32 + v3;
          goto LABEL_252;
        }
      }
    }
LABEL_189:
    v142 = _mm_movemask_epi8(v15) - 0xFFFF;
    if ( v142 )
    {
      --v11;
      v7 -= 16;
      LOWORD(v8) = v142;
    }
    v9 = (__m128i *)((char *)v11 + v14);
LABEL_192:
    if ( (_BYTE)v8 )
    {
      if ( (v8 & 1) == 0 )
      {
        if ( (v8 & 2) == 0 )
        {
          if ( (v8 & 4) == 0 )
          {
            if ( (v8 & 8) == 0 )
            {
              if ( (v8 & 0x10) == 0 )
              {
                if ( (v8 & 0x20) == 0 )
                {
                  if ( (v8 & 0x40) == 0 )
                    return *(unsigned __int8 *)(v7 - 9) - v9[-1].m128i_u8[7];
                  return *(unsigned __int8 *)(v7 - 10) - v9[-1].m128i_u8[6];
                }
                return *(unsigned __int8 *)(v7 - 11) - v9[-1].m128i_u8[5];
              }
              return *(unsigned __int8 *)(v7 - 12) - v9[-1].m128i_u8[4];
            }
            return *(unsigned __int8 *)(v7 - 13) - v9[-1].m128i_u8[3];
          }
          return *(unsigned __int8 *)(v7 - 14) - v9[-1].m128i_u8[2];
        }
        return *(unsigned __int8 *)(v7 - 15) - v9[-1].m128i_u8[1];
      }
    }
    else
    {
      v7 += 8;
      v9 = (const __m128i *)((char *)v9 + 8);
      if ( (v8 & 0x100) == 0 )
      {
        if ( (v8 & 0x200) == 0 )
        {
          if ( (v8 & 0x400) == 0 )
          {
            if ( (v8 & 0x800) == 0 )
            {
              if ( (v8 & 0x1000) == 0 )
              {
                if ( (v8 & 0x2000) == 0 )
                {
                  if ( (v8 & 0x4000) == 0 )
                    return *(unsigned __int8 *)(v7 - 9) - v9[-1].m128i_u8[7];
                  return *(unsigned __int8 *)(v7 - 10) - v9[-1].m128i_u8[6];
                }
                return *(unsigned __int8 *)(v7 - 11) - v9[-1].m128i_u8[5];
              }
              return *(unsigned __int8 *)(v7 - 12) - v9[-1].m128i_u8[4];
            }
            return *(unsigned __int8 *)(v7 - 13) - v9[-1].m128i_u8[3];
          }
          return *(unsigned __int8 *)(v7 - 14) - v9[-1].m128i_u8[2];
        }
        return *(unsigned __int8 *)(v7 - 15) - v9[-1].m128i_u8[1];
      }
    }
    return *(unsigned __int8 *)(v7 - 16) - v9[-1].m128i_u8[0];
  }
  if ( a3 <= 1 )
  {
    if ( !a3 || a1->m128i_i8[0] == a2->m128i_i8[0] )
      return 0;
    result = 1;
    if ( a1->m128i_i8[0] <= (unsigned int)a2->m128i_i8[0] )
      return -1;
    return result;
  }
  v4 = (int)a2->m128i_i32 + a3;
  v5 = &a1->m128i_i8[a3];
LABEL_252:
  if ( v3 >= 8 )
  {
    if ( v3 < 0x10 )
    {
      switch ( v3 )
      {
        case 8u:
LABEL_276:
          v143 = *((_DWORD *)v5 - 2);
          v144 = *(_DWORD *)(v4 - 8);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_277;
        case 9u:
LABEL_288:
          v143 = *(_DWORD *)(v5 - 9);
          v144 = *(_DWORD *)(v4 - 9);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_289;
        case 0xAu:
LABEL_301:
          v143 = *(_DWORD *)(v5 - 10);
          v144 = *(_DWORD *)(v4 - 10);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_302:
          v143 = *(_DWORD *)(v5 - 6);
          v144 = *(_DWORD *)(v4 - 6);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_303;
        case 0xBu:
LABEL_315:
          v143 = *(_DWORD *)(v5 - 11);
          v144 = *(_DWORD *)(v4 - 11);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_316;
      }
      if ( v3 != 12 )
      {
        if ( v3 != 13 )
        {
          if ( v3 != 14 )
          {
LABEL_314:
            v143 = *(_DWORD *)(v5 - 15);
            v144 = *(_DWORD *)(v4 - 15);
            if ( v143 != v144 )
              goto LABEL_321;
            goto LABEL_315;
          }
          goto LABEL_300;
        }
        goto LABEL_287;
      }
LABEL_275:
      v143 = *((_DWORD *)v5 - 3);
      v144 = *(_DWORD *)(v4 - 12);
      if ( v143 != v144 )
        goto LABEL_321;
      goto LABEL_276;
    }
    if ( v3 < 0x18 )
    {
      switch ( v3 )
      {
        case 0x10u:
LABEL_274:
          v143 = *((_DWORD *)v5 - 4);
          v144 = *(_DWORD *)(v4 - 16);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_275;
        case 0x11u:
LABEL_286:
          v143 = *(_DWORD *)(v5 - 17);
          v144 = *(_DWORD *)(v4 - 17);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_287:
          v143 = *(_DWORD *)(v5 - 13);
          v144 = *(_DWORD *)(v4 - 13);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_288;
        case 0x12u:
LABEL_299:
          v143 = *(_DWORD *)(v5 - 18);
          v144 = *(_DWORD *)(v4 - 18);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_300:
          v143 = *(_DWORD *)(v5 - 14);
          v144 = *(_DWORD *)(v4 - 14);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_301;
        case 0x13u:
LABEL_313:
          v143 = *(_DWORD *)(v5 - 19);
          v144 = *(_DWORD *)(v4 - 19);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_314;
      }
      if ( v3 != 20 )
      {
        if ( v3 != 21 )
        {
          if ( v3 != 22 )
          {
LABEL_312:
            v143 = *(_DWORD *)(v5 - 23);
            v144 = *(_DWORD *)(v4 - 23);
            if ( v143 != v144 )
              goto LABEL_321;
            goto LABEL_313;
          }
          goto LABEL_298;
        }
        goto LABEL_285;
      }
LABEL_273:
      v143 = *((_DWORD *)v5 - 5);
      v144 = *(_DWORD *)(v4 - 20);
      if ( v143 != v144 )
        goto LABEL_321;
      goto LABEL_274;
    }
    if ( v3 < 0x20 )
    {
      switch ( v3 )
      {
        case 0x18u:
LABEL_272:
          v143 = *((_DWORD *)v5 - 6);
          v144 = *(_DWORD *)(v4 - 24);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_273;
        case 0x19u:
LABEL_284:
          v143 = *(_DWORD *)(v5 - 25);
          v144 = *(_DWORD *)(v4 - 25);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_285:
          v143 = *(_DWORD *)(v5 - 21);
          v144 = *(_DWORD *)(v4 - 21);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_286;
        case 0x1Au:
LABEL_297:
          v143 = *(_DWORD *)(v5 - 26);
          v144 = *(_DWORD *)(v4 - 26);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_298:
          v143 = *(_DWORD *)(v5 - 22);
          v144 = *(_DWORD *)(v4 - 22);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_299;
        case 0x1Bu:
LABEL_311:
          v143 = *(_DWORD *)(v5 - 27);
          v144 = *(_DWORD *)(v4 - 27);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_312;
      }
      if ( v3 != 28 )
      {
        if ( v3 != 29 )
        {
          if ( v3 != 30 )
          {
LABEL_310:
            v143 = *(_DWORD *)(v5 - 31);
            v144 = *(_DWORD *)(v4 - 31);
            if ( v143 != v144 )
              goto LABEL_321;
            goto LABEL_311;
          }
          goto LABEL_296;
        }
        goto LABEL_283;
      }
LABEL_271:
      v143 = *((_DWORD *)v5 - 7);
      v144 = *(_DWORD *)(v4 - 28);
      if ( v143 != v144 )
        goto LABEL_321;
      goto LABEL_272;
    }
    if ( v3 < 0x28 )
    {
      switch ( v3 )
      {
        case ' ':
LABEL_270:
          v143 = *((_DWORD *)v5 - 8);
          v144 = *(_DWORD *)(v4 - 32);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_271;
        case '!':
LABEL_282:
          v143 = *(_DWORD *)(v5 - 33);
          v144 = *(_DWORD *)(v4 - 33);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_283:
          v143 = *(_DWORD *)(v5 - 29);
          v144 = *(_DWORD *)(v4 - 29);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_284;
        case '"':
LABEL_295:
          v143 = *(_DWORD *)(v5 - 34);
          v144 = *(_DWORD *)(v4 - 34);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_296:
          v143 = *(_DWORD *)(v5 - 30);
          v144 = *(_DWORD *)(v4 - 30);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_297;
        case '#':
LABEL_309:
          v143 = *(_DWORD *)(v5 - 35);
          v144 = *(_DWORD *)(v4 - 35);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_310;
      }
      if ( v3 != 36 )
      {
        if ( v3 != 37 )
        {
          if ( v3 != 38 )
          {
LABEL_308:
            v143 = *(_DWORD *)(v5 - 39);
            v144 = *(_DWORD *)(v4 - 39);
            if ( v143 != v144 )
              goto LABEL_321;
            goto LABEL_309;
          }
          goto LABEL_294;
        }
        goto LABEL_281;
      }
LABEL_269:
      v143 = *((_DWORD *)v5 - 9);
      v144 = *(_DWORD *)(v4 - 36);
      if ( v143 != v144 )
        goto LABEL_321;
      goto LABEL_270;
    }
    if ( v3 != 40 )
    {
      switch ( v3 )
      {
        case ')':
          goto LABEL_280;
        case '*':
          goto LABEL_293;
        case '+':
LABEL_307:
          v143 = *(_DWORD *)(v5 - 43);
          v144 = *(_DWORD *)(v4 - 43);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_308;
      }
      if ( v3 != 44 )
      {
        if ( v3 != 45 )
        {
          if ( v3 != 46 )
          {
            v143 = *(_DWORD *)(v5 - 47);
            v144 = *(_DWORD *)(v4 - 47);
            if ( v143 != v144 )
              goto LABEL_321;
            goto LABEL_307;
          }
          v143 = *(_DWORD *)(v5 - 46);
          v144 = *(_DWORD *)(v4 - 46);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_293:
          v143 = *(_DWORD *)(v5 - 42);
          v144 = *(_DWORD *)(v4 - 42);
          if ( v143 != v144 )
            goto LABEL_321;
LABEL_294:
          v143 = *(_DWORD *)(v5 - 38);
          v144 = *(_DWORD *)(v4 - 38);
          if ( v143 != v144 )
            goto LABEL_321;
          goto LABEL_295;
        }
        v143 = *(_DWORD *)(v5 - 45);
        v144 = *(_DWORD *)(v4 - 45);
        if ( v143 != v144 )
          goto LABEL_321;
LABEL_280:
        v143 = *(_DWORD *)(v5 - 41);
        v144 = *(_DWORD *)(v4 - 41);
        if ( v143 != v144 )
          goto LABEL_321;
LABEL_281:
        v143 = *(_DWORD *)(v5 - 37);
        v144 = *(_DWORD *)(v4 - 37);
        if ( v143 != v144 )
          goto LABEL_321;
        goto LABEL_282;
      }
      v143 = *((_DWORD *)v5 - 11);
      v144 = *(_DWORD *)(v4 - 44);
      if ( v143 != v144 )
        goto LABEL_321;
    }
    v143 = *((_DWORD *)v5 - 10);
    v144 = *(_DWORD *)(v4 - 40);
    if ( v143 != v144 )
      goto LABEL_321;
    goto LABEL_269;
  }
  if ( v3 != 2 )
  {
    if ( v3 == 3 )
    {
LABEL_317:
      v149 = *(_WORD *)(v5 - 3);
      v150 = *(_WORD *)(v4 - 3);
      v146 = (unsigned __int8)v149 <= (unsigned __int8)v150;
      if ( (_BYTE)v149 == (_BYTE)v150 )
      {
        v146 = v149 <= v150;
        if ( v149 == v150 )
        {
          v151 = *(v5 - 1);
          v152 = v151 == *(_BYTE *)(v4 - 1);
          v146 = v151 <= *(_BYTE *)(v4 - 1);
          result = 0;
          if ( v152 )
            return result;
        }
      }
LABEL_325:
      result = 1;
      if ( v146 )
        return -1;
      return result;
    }
    if ( v3 != 4 )
    {
      if ( v3 != 5 )
      {
        if ( v3 != 6 )
        {
LABEL_316:
          v143 = *(_DWORD *)(v5 - 7);
          v144 = *(_DWORD *)(v4 - 7);
          if ( v143 == v144 )
            goto LABEL_317;
LABEL_321:
          v146 = (unsigned __int8)v143 <= (unsigned __int8)v144;
          if ( (_BYTE)v143 == (_BYTE)v144 )
          {
            v146 = (unsigned __int16)v143 <= (unsigned __int16)v144;
            if ( (_WORD)v143 == (_WORD)v144 )
            {
              v153 = HIWORD(v143);
              v154 = HIWORD(v144);
              v146 = (unsigned __int8)v153 <= (unsigned __int8)v154;
              if ( (_BYTE)v153 == (_BYTE)v154 )
                v146 = (unsigned __int16)v153 <= (unsigned __int16)v154;
            }
          }
          goto LABEL_325;
        }
        goto LABEL_302;
      }
LABEL_289:
      v143 = *(_DWORD *)(v5 - 5);
      v144 = *(_DWORD *)(v4 - 5);
      if ( v143 == v144 )
      {
        v145 = *(v5 - 1);
        v146 = v145 <= *(_BYTE *)(v4 - 1);
        result = 0;
        if ( v145 == *(_BYTE *)(v4 - 1) )
          return result;
        goto LABEL_325;
      }
      goto LABEL_321;
    }
LABEL_277:
    v143 = *((_DWORD *)v5 - 1);
    v144 = *(_DWORD *)(v4 - 4);
    result = 0;
    if ( v143 == v144 )
      return result;
    goto LABEL_321;
  }
LABEL_303:
  v147 = *((_WORD *)v5 - 1);
  v148 = *(_WORD *)(v4 - 2);
  v146 = (unsigned __int8)v147 <= (unsigned __int8)v148;
  if ( (_BYTE)v147 != (_BYTE)v148 )
    goto LABEL_325;
  v146 = HIBYTE(v147) <= HIBYTE(v148);
  result = 0;
  if ( HIBYTE(v147) != HIBYTE(v148) )
    goto LABEL_325;
  return result;
}

//----- (08052930) --------------------------------------------------------
int __cdecl _memcmp_sse4_2(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  const __m128i *v3; // edx
  const __m128i *v4; // eax
  bool v5; // cc
  unsigned __int8 v6; // bl
  unsigned __int8 v7; // bl
  unsigned __int8 v8; // bl
  unsigned __int8 v9; // bl
  unsigned __int8 v10; // bl
  unsigned __int8 v11; // bl
  int result; // eax
  int v13; // ecx
  unsigned int v14; // ebx
  bool v15; // cf
  unsigned __int32 v16; // ecx
  unsigned __int32 v17; // ebx
  int v18; // ebx
  unsigned __int8 v19; // cl
  bool v20; // cc
  __int16 v21; // cx
  __int16 v22; // bx
  unsigned __int16 v23; // cx
  unsigned __int16 v24; // bx
  unsigned __int8 v25; // al
  bool v26; // zf
  unsigned __int8 v27; // cl
  __int16 v28; // cx
  __int16 v29; // bx
  unsigned __int16 v30; // cx
  unsigned __int16 v31; // bx
  unsigned __int8 v32; // al
  unsigned __int8 v33; // cl
  __int16 v34; // cx
  __int16 v35; // bx
  unsigned __int16 v36; // cx
  unsigned __int16 v37; // bx
  unsigned __int8 v38; // al
  unsigned __int8 v39; // cl
  __int16 v40; // cx
  __int16 v41; // bx
  unsigned __int16 v42; // cx
  unsigned __int16 v43; // bx
  unsigned __int8 v44; // al
  unsigned __int32 *v45; // eax
  unsigned __int32 *v46; // edx
  unsigned __int32 v47; // ecx
  unsigned __int32 v48; // ebx

  if ( a3 <= 1 )
  {
    if ( a3 )
      return *a1 - *a2;
    else
      return 0;
  }
  else if ( a3 < 8 )
  {
    v5 = *a1 <= *a2;
    if ( *a1 != *a2 )
      goto LABEL_16;
    v6 = a1[1];
    v5 = v6 <= a2[1];
    if ( v6 != a2[1] )
      goto LABEL_16;
    if ( a3 == 2 )
      return 0;
    v7 = a1[2];
    v5 = v7 <= a2[2];
    if ( v7 != a2[2] )
      goto LABEL_16;
    if ( a3 == 3 )
      return 0;
    v8 = a1[3];
    v5 = v8 <= a2[3];
    if ( v8 != a2[3] )
      goto LABEL_16;
    if ( a3 == 4 )
      return 0;
    v9 = a1[4];
    v5 = v9 <= a2[4];
    if ( v9 == a2[4]
      && (a3 == 5
       || (v10 = a1[5], v5 = v10 <= a2[5], v10 == a2[5]) && (a3 == 6 || (v11 = a1[6], v5 = v11 <= a2[6], v11 == a2[6]))) )
    {
      return 0;
    }
    else
    {
LABEL_16:
      result = 1;
      if ( v5 )
        return -1;
    }
  }
  else
  {
    v3 = (const __m128i *)&a2[a3];
    v4 = (const __m128i *)&a1[a3];
    switch ( a3 )
    {
      case 0u:
        return 0;
      case 1u:
        goto LABEL_64;
      case 2u:
        goto LABEL_53;
      case 3u:
        goto LABEL_62;
      case 4u:
        goto LABEL_37;
      case 5u:
        goto LABEL_44;
      case 6u:
        goto LABEL_52;
      case 7u:
        goto LABEL_61;
      case 8u:
        goto LABEL_36;
      case 9u:
        goto LABEL_43;
      case 0xAu:
        goto LABEL_51;
      case 0xBu:
        goto LABEL_60;
      case 0xCu:
        goto LABEL_35;
      case 0xDu:
        goto LABEL_42;
      case 0xEu:
        goto LABEL_50;
      case 0xFu:
        goto LABEL_59;
      case 0x10u:
        goto LABEL_34;
      case 0x11u:
        goto LABEL_41;
      case 0x12u:
        goto LABEL_49;
      case 0x13u:
        goto LABEL_58;
      case 0x14u:
        goto LABEL_68;
      case 0x15u:
        goto LABEL_73;
      case 0x16u:
        goto LABEL_79;
      case 0x17u:
        goto LABEL_86;
      case 0x18u:
        goto LABEL_94;
      case 0x19u:
        goto LABEL_100;
      case 0x1Au:
        goto LABEL_107;
      case 0x1Bu:
        goto LABEL_115;
      case 0x1Cu:
        goto LABEL_124;
      case 0x1Du:
        goto LABEL_131;
      case 0x1Eu:
        goto LABEL_139;
      case 0x1Fu:
        goto LABEL_148;
      case 0x20u:
        goto LABEL_158;
      case 0x21u:
        goto LABEL_40;
      case 0x22u:
        goto LABEL_48;
      case 0x23u:
        goto LABEL_57;
      case 0x24u:
        goto LABEL_67;
      case 0x25u:
        goto LABEL_72;
      case 0x26u:
        goto LABEL_78;
      case 0x27u:
        goto LABEL_85;
      case 0x28u:
        goto LABEL_93;
      case 0x29u:
        goto LABEL_99;
      case 0x2Au:
        goto LABEL_106;
      case 0x2Bu:
        goto LABEL_114;
      case 0x2Cu:
        goto LABEL_123;
      case 0x2Du:
        goto LABEL_130;
      case 0x2Eu:
        goto LABEL_138;
      case 0x2Fu:
        goto LABEL_147;
      case 0x30u:
        goto LABEL_157;
      case 0x31u:
LABEL_39:
        v18 = -49;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 49)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 49)))) )
          goto LABEL_164;
LABEL_40:
        v18 = -33;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 33)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 33)))) )
          goto LABEL_164;
LABEL_41:
        v16 = *(unsigned __int32 *)((char *)&v4[-2].m128i_u32[3] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-2].m128i_u32[3] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_42:
        v16 = *(unsigned __int32 *)((char *)v4[-1].m128i_u32 + 3);
        v17 = *(unsigned __int32 *)((char *)v3[-1].m128i_u32 + 3);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_43:
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_44:
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v19 = v4[-1].m128i_u8[15];
        v20 = v19 <= (unsigned int)v3[-1].m128i_i8[15];
        result = 0;
        if ( v19 == v3[-1].m128i_i8[15] )
          return result;
        goto LABEL_172;
      case 0x32u:
LABEL_47:
        v18 = -50;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 50)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 50)))) )
          goto LABEL_164;
LABEL_48:
        v18 = -34;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 34)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 34)))) )
          goto LABEL_164;
LABEL_49:
        v16 = *(unsigned __int32 *)((char *)&v4[-2].m128i_u32[3] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-2].m128i_u32[3] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_50:
        v16 = *(unsigned __int32 *)((char *)v4[-1].m128i_u32 + 2);
        v17 = *(unsigned __int32 *)((char *)v3[-1].m128i_u32 + 2);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_51:
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_52:
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_53:
        v21 = v4[-1].m128i_i16[7];
        v22 = v3[-1].m128i_i16[7];
        v20 = (unsigned __int8)v21 <= (unsigned __int8)v22;
        if ( (_BYTE)v21 == (_BYTE)v22 )
        {
          v20 = HIBYTE(v21) <= HIBYTE(v22);
          result = 0;
          if ( HIBYTE(v21) == HIBYTE(v22) )
            return result;
        }
        goto LABEL_172;
      case 0x33u:
LABEL_56:
        v18 = -51;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 51)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 51)))) )
          goto LABEL_164;
LABEL_57:
        v18 = -35;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 35)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 35)))) )
          goto LABEL_164;
LABEL_58:
        v16 = *(unsigned __int32 *)((char *)&v4[-2].m128i_u32[3] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-2].m128i_u32[3] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_59:
        v16 = *(unsigned __int32 *)((char *)v4[-1].m128i_u32 + 1);
        v17 = *(unsigned __int32 *)((char *)v3[-1].m128i_u32 + 1);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_60:
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_61:
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
LABEL_62:
        v23 = *(unsigned __int16 *)((char *)&v4[-1].m128i_u16[6] + 1);
        v24 = *(unsigned __int16 *)((char *)&v3[-1].m128i_u16[6] + 1);
        v20 = (unsigned __int8)v23 <= (unsigned __int8)v24;
        if ( (_BYTE)v23 != (_BYTE)v24 )
          goto LABEL_172;
        v20 = v23 <= v24;
        if ( v23 != v24 )
          goto LABEL_172;
LABEL_64:
        v25 = v4[-1].m128i_u8[15];
        v26 = v25 == v3[-1].m128i_i8[15];
        v20 = v25 <= (unsigned int)v3[-1].m128i_i8[15];
        result = 0;
        if ( v26 )
          return result;
        goto LABEL_172;
      case 0x34u:
LABEL_66:
        v18 = -52;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 52)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 52)))) )
          goto LABEL_164;
LABEL_67:
        v18 = -36;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 36)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 36)))) )
          goto LABEL_164;
LABEL_68:
        v18 = -20;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 20)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 20)))) )
          goto LABEL_164;
        v16 = v4[-1].m128i_u32[3];
        v17 = v3[-1].m128i_u32[3];
        result = 0;
        if ( v16 == v17 )
          return result;
        goto LABEL_168;
      case 0x35u:
LABEL_71:
        v18 = -53;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 53)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 53)))) )
          goto LABEL_164;
LABEL_72:
        v18 = -37;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 37)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 37)))) )
          goto LABEL_164;
LABEL_73:
        v18 = -21;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 21)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 21)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v27 = v4[-1].m128i_u8[15];
        v20 = v27 <= (unsigned int)v3[-1].m128i_i8[15];
        result = 0;
        if ( v27 == v3[-1].m128i_i8[15] )
          return result;
        goto LABEL_172;
      case 0x36u:
LABEL_77:
        v18 = -54;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 54)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 54)))) )
          goto LABEL_164;
LABEL_78:
        v18 = -38;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 38)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 38)))) )
          goto LABEL_164;
LABEL_79:
        v18 = -22;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 22)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 22)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
        v28 = v4[-1].m128i_i16[7];
        v29 = v3[-1].m128i_i16[7];
        v20 = (unsigned __int8)v28 <= (unsigned __int8)v29;
        if ( (_BYTE)v28 == (_BYTE)v29 )
        {
          v20 = HIBYTE(v28) <= HIBYTE(v29);
          result = 0;
          if ( HIBYTE(v28) == HIBYTE(v29) )
            return result;
        }
        goto LABEL_172;
      case 0x37u:
LABEL_84:
        v18 = -55;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 55)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 55)))) )
          goto LABEL_164;
LABEL_85:
        v18 = -39;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 39)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 39)))) )
          goto LABEL_164;
LABEL_86:
        v18 = -23;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 23)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 23)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
        v30 = *(unsigned __int16 *)((char *)&v4[-1].m128i_u16[6] + 1);
        v31 = *(unsigned __int16 *)((char *)&v3[-1].m128i_u16[6] + 1);
        v20 = (unsigned __int8)v30 <= (unsigned __int8)v31;
        if ( (_BYTE)v30 == (_BYTE)v31 )
        {
          v20 = v30 <= v31;
          if ( v30 == v31 )
          {
            v32 = v4[-1].m128i_u8[15];
            v26 = v32 == v3[-1].m128i_i8[15];
            v20 = v32 <= (unsigned int)v3[-1].m128i_i8[15];
            result = 0;
            if ( v26 )
              return result;
          }
        }
        goto LABEL_172;
      case 0x38u:
LABEL_92:
        v18 = -56;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 56)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 56)))) )
          goto LABEL_164;
LABEL_93:
        v18 = -40;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 40)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 40)))) )
          goto LABEL_164;
LABEL_94:
        v18 = -24;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 24)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 24)))) )
          goto LABEL_164;
        v16 = v4[-1].m128i_u32[2];
        v17 = v3[-1].m128i_u32[2];
        if ( v16 == v17 )
        {
          v16 = v4[-1].m128i_u32[3];
          v17 = v3[-1].m128i_u32[3];
          result = 0;
          if ( v16 == v17 )
            return result;
        }
        goto LABEL_168;
      case 0x39u:
LABEL_98:
        v18 = -57;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 57)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 57)))) )
          goto LABEL_164;
LABEL_99:
        v18 = -41;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 41)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 41)))) )
          goto LABEL_164;
LABEL_100:
        v18 = -25;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 25)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 25)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v33 = v4[-1].m128i_u8[15];
        v20 = v33 <= (unsigned int)v3[-1].m128i_i8[15];
        result = 0;
        if ( v33 == v3[-1].m128i_i8[15] )
          return result;
        goto LABEL_172;
      case 0x3Au:
LABEL_105:
        v18 = -58;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 58)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 58)))) )
          goto LABEL_164;
LABEL_106:
        v18 = -42;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 42)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 42)))) )
          goto LABEL_164;
LABEL_107:
        v18 = -26;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 26)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 26)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
        v34 = v4[-1].m128i_i16[7];
        v35 = v3[-1].m128i_i16[7];
        v20 = (unsigned __int8)v34 <= (unsigned __int8)v35;
        if ( (_BYTE)v34 == (_BYTE)v35 )
        {
          v20 = HIBYTE(v34) <= HIBYTE(v35);
          result = 0;
          if ( HIBYTE(v34) == HIBYTE(v35) )
            return result;
        }
        goto LABEL_172;
      case 0x3Bu:
LABEL_113:
        v18 = -59;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 59)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 59)))) )
          goto LABEL_164;
LABEL_114:
        v18 = -43;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 43)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 43)))) )
          goto LABEL_164;
LABEL_115:
        v18 = -27;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 27)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 27)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
        v36 = *(unsigned __int16 *)((char *)&v4[-1].m128i_u16[6] + 1);
        v37 = *(unsigned __int16 *)((char *)&v3[-1].m128i_u16[6] + 1);
        v20 = (unsigned __int8)v36 <= (unsigned __int8)v37;
        if ( (_BYTE)v36 == (_BYTE)v37 )
        {
          v20 = v36 <= v37;
          if ( v36 == v37 )
          {
            v38 = v4[-1].m128i_u8[15];
            v26 = v38 == v3[-1].m128i_i8[15];
            v20 = v38 <= (unsigned int)v3[-1].m128i_i8[15];
            result = 0;
            if ( v26 )
              return result;
          }
        }
        goto LABEL_172;
      case 0x3Cu:
LABEL_122:
        v18 = -60;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 60)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 60)))) )
          goto LABEL_164;
LABEL_123:
        v18 = -44;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 44)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 44)))) )
          goto LABEL_164;
LABEL_124:
        v18 = -28;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 28)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 28)))) )
          goto LABEL_164;
        v16 = v4[-1].m128i_u32[1];
        v17 = v3[-1].m128i_u32[1];
        if ( v16 == v17 )
        {
          v16 = v4[-1].m128i_u32[2];
          v17 = v3[-1].m128i_u32[2];
          if ( v16 == v17 )
          {
            v16 = v4[-1].m128i_u32[3];
            v17 = v3[-1].m128i_u32[3];
            result = 0;
            if ( v16 == v17 )
              return result;
          }
        }
        goto LABEL_168;
      case 0x3Du:
LABEL_129:
        v18 = -61;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 61)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 61)))) )
          goto LABEL_164;
LABEL_130:
        v18 = -45;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 45)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 45)))) )
          goto LABEL_164;
LABEL_131:
        v18 = -29;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 29)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 29)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)v4[-1].m128i_u32 + 3);
        v17 = *(unsigned __int32 *)((char *)v3[-1].m128i_u32 + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 3);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 3);
        if ( v16 != v17 )
          goto LABEL_168;
        v39 = v4[-1].m128i_u8[15];
        v20 = v39 <= (unsigned int)v3[-1].m128i_i8[15];
        result = 0;
        if ( v39 == v3[-1].m128i_i8[15] )
          return result;
        goto LABEL_172;
      case 0x3Eu:
LABEL_137:
        v18 = -62;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 62)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 62)))) )
          goto LABEL_164;
LABEL_138:
        v18 = -46;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 46)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 46)))) )
          goto LABEL_164;
LABEL_139:
        v18 = -30;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 30)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 30)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)v4[-1].m128i_u32 + 2);
        v17 = *(unsigned __int32 *)((char *)v3[-1].m128i_u32 + 2);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 2);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 2);
        if ( v16 != v17 )
          goto LABEL_168;
        v40 = v4[-1].m128i_i16[7];
        v41 = v3[-1].m128i_i16[7];
        v20 = (unsigned __int8)v40 <= (unsigned __int8)v41;
        if ( (_BYTE)v40 == (_BYTE)v41 )
        {
          v20 = HIBYTE(v40) <= HIBYTE(v41);
          result = 0;
          if ( HIBYTE(v40) == HIBYTE(v41) )
            return result;
        }
        goto LABEL_172;
      case 0x3Fu:
LABEL_146:
        v18 = -63;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 63)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 63)))) )
          goto LABEL_164;
LABEL_147:
        v18 = -47;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 47)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 47)))) )
          goto LABEL_164;
LABEL_148:
        v18 = -31;
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_xor_si128(
                  _mm_loadu_si128((const __m128i *)((char *)v3 - 31)),
                  _mm_loadu_si128((const __m128i *)((char *)v4 - 31)))) )
          goto LABEL_164;
        v16 = *(unsigned __int32 *)((char *)v4[-1].m128i_u32 + 1);
        v17 = *(unsigned __int32 *)((char *)v3[-1].m128i_u32 + 1);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[1] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[1] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = *(unsigned __int32 *)((char *)&v4[-1].m128i_u32[2] + 1);
        v17 = *(unsigned __int32 *)((char *)&v3[-1].m128i_u32[2] + 1);
        if ( v16 != v17 )
          goto LABEL_168;
        v42 = *(unsigned __int16 *)((char *)&v4[-1].m128i_u16[6] + 1);
        v43 = *(unsigned __int16 *)((char *)&v3[-1].m128i_u16[6] + 1);
        v20 = (unsigned __int8)v42 <= (unsigned __int8)v43;
        if ( (_BYTE)v42 == (_BYTE)v43 )
        {
          v20 = v42 <= v43;
          if ( v42 == v43 )
          {
            v44 = v4[-1].m128i_u8[15];
            v26 = v44 == v3[-1].m128i_i8[15];
            v20 = v44 <= (unsigned int)v3[-1].m128i_i8[15];
            result = 0;
            if ( v26 )
              return result;
          }
        }
        goto LABEL_172;
      case 0x40u:
LABEL_156:
        v18 = -64;
        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3 - 4), _mm_loadu_si128(v4 - 4))) )
          goto LABEL_164;
LABEL_157:
        v18 = -48;
        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3 - 3), _mm_loadu_si128(v4 - 3))) )
          goto LABEL_164;
LABEL_158:
        v18 = -32;
        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3 - 2), _mm_loadu_si128(v4 - 2))) )
        {
LABEL_164:
          v45 = (unsigned __int32 *)((char *)v4->m128i_u32 + v18);
          v46 = (unsigned __int32 *)((char *)v3->m128i_u32 + v18);
          v16 = *v45;
          v17 = *v46;
          if ( *v45 == *v46 )
          {
            v16 = v45[1];
            v17 = v46[1];
            if ( v16 == v17 )
            {
              v16 = v45[2];
              v17 = v46[2];
              if ( v16 == v17 )
              {
                v16 = v45[3];
                v17 = v46[3];
                result = 0;
                if ( v16 == v17 )
                  return result;
              }
            }
          }
          goto LABEL_168;
        }
        v16 = v4[-1].m128i_u32[0];
        v17 = v3[-1].m128i_u32[0];
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = v4[-1].m128i_u32[1];
        v17 = v3[-1].m128i_u32[1];
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = v4[-1].m128i_u32[2];
        v17 = v3[-1].m128i_u32[2];
        if ( v16 != v17 )
          goto LABEL_168;
        v16 = v4[-1].m128i_u32[3];
        v17 = v3[-1].m128i_u32[3];
        result = 0;
        if ( v16 != v17 )
          goto LABEL_168;
        return result;
      default:
        v13 = 64;
        v14 = a3 - 64;
        break;
    }
    while ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3), _mm_loadu_si128(v4))) )
    {
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3 + 1), _mm_loadu_si128(v4 + 1))) )
        goto LABEL_31;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3 + 2), _mm_loadu_si128(v4 + 2))) )
        goto LABEL_32;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(v3 + 3), _mm_loadu_si128(v4 + 3))) )
        goto LABEL_33;
      v4 += 4;
      v3 += 4;
      v15 = v14 < 0x40;
      v14 -= 64;
      if ( v15 )
      {
        v3 = (const __m128i *)((char *)v3 + v14 + 64);
        v4 = (const __m128i *)((char *)v4 + v14 + 64);
        switch ( v14 )
        {
          case 0xFFFFFFC0:
            return 0;
          case 0xFFFFFFC1:
            goto LABEL_64;
          case 0xFFFFFFC2:
            goto LABEL_53;
          case 0xFFFFFFC3:
            goto LABEL_62;
          case 0xFFFFFFC4:
            goto LABEL_37;
          case 0xFFFFFFC5:
            goto LABEL_44;
          case 0xFFFFFFC6:
            goto LABEL_52;
          case 0xFFFFFFC7:
            goto LABEL_61;
          case 0xFFFFFFC8:
            goto LABEL_36;
          case 0xFFFFFFC9:
            goto LABEL_43;
          case 0xFFFFFFCA:
            goto LABEL_51;
          case 0xFFFFFFCB:
            goto LABEL_60;
          case 0xFFFFFFCC:
            goto LABEL_35;
          case 0xFFFFFFCD:
            goto LABEL_42;
          case 0xFFFFFFCE:
            goto LABEL_50;
          case 0xFFFFFFCF:
            goto LABEL_59;
          case 0xFFFFFFD0:
            goto LABEL_34;
          case 0xFFFFFFD1:
            goto LABEL_41;
          case 0xFFFFFFD2:
            goto LABEL_49;
          case 0xFFFFFFD3:
            goto LABEL_58;
          case 0xFFFFFFD4:
            goto LABEL_68;
          case 0xFFFFFFD5:
            goto LABEL_73;
          case 0xFFFFFFD6:
            goto LABEL_79;
          case 0xFFFFFFD7:
            goto LABEL_86;
          case 0xFFFFFFD8:
            goto LABEL_94;
          case 0xFFFFFFD9:
            goto LABEL_100;
          case 0xFFFFFFDA:
            goto LABEL_107;
          case 0xFFFFFFDB:
            goto LABEL_115;
          case 0xFFFFFFDC:
            goto LABEL_124;
          case 0xFFFFFFDD:
            goto LABEL_131;
          case 0xFFFFFFDE:
            goto LABEL_139;
          case 0xFFFFFFDF:
            goto LABEL_148;
          case 0xFFFFFFE0:
            goto LABEL_158;
          case 0xFFFFFFE1:
            goto LABEL_40;
          case 0xFFFFFFE2:
            goto LABEL_48;
          case 0xFFFFFFE3:
            goto LABEL_57;
          case 0xFFFFFFE4:
            goto LABEL_67;
          case 0xFFFFFFE5:
            goto LABEL_72;
          case 0xFFFFFFE6:
            goto LABEL_78;
          case 0xFFFFFFE7:
            goto LABEL_85;
          case 0xFFFFFFE8:
            goto LABEL_93;
          case 0xFFFFFFE9:
            goto LABEL_99;
          case 0xFFFFFFEA:
            goto LABEL_106;
          case 0xFFFFFFEB:
            goto LABEL_114;
          case 0xFFFFFFEC:
            goto LABEL_123;
          case 0xFFFFFFED:
            goto LABEL_130;
          case 0xFFFFFFEE:
            goto LABEL_138;
          case 0xFFFFFFEF:
            goto LABEL_147;
          case 0xFFFFFFF0:
            goto LABEL_157;
          case 0xFFFFFFF1:
            goto LABEL_39;
          case 0xFFFFFFF2:
            goto LABEL_47;
          case 0xFFFFFFF3:
            goto LABEL_56;
          case 0xFFFFFFF4:
            goto LABEL_66;
          case 0xFFFFFFF5:
            goto LABEL_71;
          case 0xFFFFFFF6:
            goto LABEL_77;
          case 0xFFFFFFF7:
            goto LABEL_84;
          case 0xFFFFFFF8:
            goto LABEL_92;
          case 0xFFFFFFF9:
            goto LABEL_98;
          case 0xFFFFFFFA:
            goto LABEL_105;
          case 0xFFFFFFFB:
            goto LABEL_113;
          case 0xFFFFFFFC:
            goto LABEL_122;
          case 0xFFFFFFFD:
            goto LABEL_129;
          case 0xFFFFFFFE:
            goto LABEL_137;
          case 0xFFFFFFFF:
            goto LABEL_146;
          case 0u:
            goto LABEL_156;
        }
      }
    }
    v13 = 48;
LABEL_31:
    v13 -= 16;
LABEL_32:
    v13 -= 16;
LABEL_33:
    v3 = (const __m128i *)((char *)v3 + v13);
    v4 = (const __m128i *)((char *)v4 + v13);
LABEL_34:
    v16 = v4[-1].m128i_u32[0];
    v17 = v3[-1].m128i_u32[0];
    if ( v16 == v17 )
    {
LABEL_35:
      v16 = v4[-1].m128i_u32[1];
      v17 = v3[-1].m128i_u32[1];
      if ( v16 == v17 )
      {
LABEL_36:
        v16 = v4[-1].m128i_u32[2];
        v17 = v3[-1].m128i_u32[2];
        if ( v16 == v17 )
        {
LABEL_37:
          v16 = v4[-1].m128i_u32[3];
          v17 = v3[-1].m128i_u32[3];
          result = 0;
          if ( v16 == v17 )
            return result;
        }
      }
    }
LABEL_168:
    v20 = (unsigned __int8)v16 <= (unsigned __int8)v17;
    if ( (_BYTE)v16 == (_BYTE)v17 )
    {
      v20 = (unsigned __int16)v16 <= (unsigned __int16)v17;
      if ( (_WORD)v16 == (_WORD)v17 )
      {
        v47 = HIWORD(v16);
        v48 = HIWORD(v17);
        v20 = (unsigned __int8)v47 <= (unsigned __int8)v48;
        if ( (_BYTE)v47 == (_BYTE)v48 )
          v20 = (unsigned __int16)v47 <= (unsigned __int16)v48;
      }
    }
LABEL_172:
    result = 1;
    if ( v20 )
      return -1;
  }
  return result;
}
// 8052930: could not find valid save-restore pair for ebx

//----- (080534C0) --------------------------------------------------------
int __cdecl intel_02_known_compare(_BYTE *a1, _BYTE *a2)
{
  int result; // eax

  result = 0;
  if ( *a1 != *a2 )
    return *a1 < *a2 ? -1 : 1;
  return result;
}

//----- (080534E0) --------------------------------------------------------
int __usercall handle_amd@<eax>(int a1@<eax>)
{
  int result; // eax
  unsigned int v13; // eax
  unsigned int v14; // ecx

  _EAX = 0x80000000;
  __asm { cpuid }
  if ( a1 > 196 || (unsigned int)(a1 >= 191) - 2147483643 > _EAX )
    return 0;
  _EAX = (a1 >= 191) - 2147483643;
  __asm { cpuid }
  if ( a1 <= 187 )
  {
    a1 += 3;
    _ECX = _EDX;
  }
  switch ( a1 )
  {
    case 188:
      result = (_ECX >> 14) & 0x3FC00;
      break;
    case 189:
      v14 = HIWORD(_ECX);
      result = (unsigned __int8)v14;
      if ( (unsigned __int8)v14 == 255 )
        result = (4 * v14) & 0x3FC00;
      break;
    case 190:
      result = (unsigned __int8)_ECX;
      break;
    case 191:
      result = 0;
      if ( (_ECX & 0xF000) != 0 )
        result = (_ECX >> 6) & 0x3FFFC00;
      break;
    case 192:
      v13 = _ECX >> 12;
      switch ( (unsigned __int16)_ECX >> 12 )
      {
        case 0:
        case 1:
        case 2:
        case 4:
          goto LABEL_33;
        case 3:
        case 5:
        case 7:
        case 9:
          return 0;
        case 6:
          goto LABEL_32;
        case 8:
          goto LABEL_31;
        case 10:
          goto LABEL_30;
        case 11:
          goto LABEL_29;
        case 12:
          goto LABEL_28;
        case 13:
          goto LABEL_27;
        case 14:
          goto LABEL_26;
        case 15:
          result = ((_ECX >> 6) & 0x3FFFC00) / (unsigned __int8)_ECX;
          break;
      }
      break;
    case 193:
      result = 0;
      if ( (_ECX & 0xF000) != 0 )
        result = (unsigned __int8)_ECX;
      break;
    case 194:
      result = 0;
      if ( (_EDX & 0xF000) != 0 )
        result = 2 * (_EDX & 0x3FFC0000);
      break;
    case 195:
      v13 = _EDX >> 12;
      switch ( (unsigned __int16)_EDX >> 12 )
      {
        case 0:
        case 1:
        case 2:
        case 4:
LABEL_33:
          result = v13 & 0xF;
          break;
        case 3:
        case 5:
        case 7:
        case 9:
          return 0;
        case 6:
LABEL_32:
          result = 8;
          break;
        case 8:
LABEL_31:
          result = 16;
          break;
        case 10:
LABEL_30:
          result = 32;
          break;
        case 11:
LABEL_29:
          result = 48;
          break;
        case 12:
LABEL_28:
          result = 64;
          break;
        case 13:
LABEL_27:
          result = 96;
          break;
        case 14:
LABEL_26:
          result = 128;
          break;
        case 15:
          result = 2 * (_EDX & 0x3FFC0000) / (unsigned __int8)_EDX;
          break;
      }
      break;
    case 196:
      result = 0;
      if ( (_EDX & 0xF000) != 0 )
        result = (unsigned __int8)_EDX;
      break;
    default:
      _assert_fail("! \"cannot happen\"", "../sysdeps/x86_64/cacheinfo.c", 478, "handle_amd");
  }
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080536B0) --------------------------------------------------------
int __usercall intel_check_word@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, _BYTE *a4)
{
  unsigned int v4; // ebx
  int v5; // esi
  int v6; // eax
  unsigned __int8 v7; // dl
  unsigned int v14; // ebp
  int v15; // edx
  int v16; // ebx
  int v18; // ebp
  unsigned int v22; // ett
  int v23; // eax
  int v24; // eax
  int v25; // edx
  int v26; // [esp+28h] [ebp-34h]
  int v28; // [esp+2Ch] [ebp-30h]
  char v29[36]; // [esp+38h] [ebp-24h] BYREF

  v4 = a2;
  v26 = a1;
  if ( a2 <= 0 )
    return 0;
  v5 = 3 * ((a1 - 185) / 3);
  while ( 1 )
  {
    _EAX = (unsigned __int8)v4;
    if ( (unsigned __int8)v4 == 64 )
    {
      *a4 = 1;
      if ( v5 == 9 )
        return 0;
      goto LABEL_13;
    }
    if ( (unsigned __int8)v4 == 255 )
      break;
    if ( (unsigned __int8)v4 == 73 && v5 == 9 )
    {
      if ( dword_80F128C == 6 && dword_80F1288 == 15 )
      {
        v26 -= 3;
        LOWORD(v5) = 6;
      }
      else
      {
        v5 = 9;
      }
    }
    v29[0] = v4;
    v6 = bsearch((int)v29, (int)&intel_02_known, 0x44u, 8, (int (__cdecl *)(int, int))intel_02_known_compare);
    if ( v6 )
    {
      v7 = *(_BYTE *)(v6 + 3);
      if ( v7 == v5 )
      {
        v25 = v26 - 185 - v5;
        if ( v26 - 185 == v5 )
          return *(_DWORD *)(v6 + 4);
        if ( v25 == 1 )
          return *(unsigned __int8 *)(v6 + 1);
        if ( v25 != 2 )
          _assert_fail("offset == 2", "../sysdeps/x86_64/cacheinfo.c", 287, "intel_check_word");
        return *(unsigned __int8 *)(v6 + 2);
      }
      if ( v7 == 6 )
        *a3 = 1;
    }
LABEL_13:
    v4 >>= 8;
    if ( !v4 )
      return 0;
  }
  LOBYTE(_EAX) = 4;
  __asm { cpuid }
  v14 = _EBX;
  v15 = _EAX & 0x1F;
  if ( (_EAX & 0x1F) == 0 )
    return 0;
  v16 = 0;
  v28 = _ECX;
  while ( 1 )
  {
    v23 = (unsigned __int8)_EAX >> 5;
    if ( v23 == 1 && (v15 == 1 && v5 == 3 || v15 == 2 && !v5) )
      break;
    if ( v23 == 2 && v5 == 6 || v23 == 3 && v5 == 9 || v23 == 4 && v5 == 12 )
      break;
    _EAX = 4;
    v18 = v16 + 1;
    __asm { cpuid }
    v22 = _EBX;
    v16 = v18;
    v14 = v22;
    v15 = _EAX & 0x1F;
    v28 = _ECX;
    if ( (_EAX & 0x1F) == 0 )
      return 0;
  }
  v24 = v26 - 185 - v5;
  if ( v26 - 185 == v5 )
    return (((v14 >> 12) & 0x3FF) + 1) * (v28 + 1) * ((v14 & 0xFFF) + 1) * ((v14 >> 22) + 1);
  if ( v24 == 1 )
    return (v14 >> 22) + 1;
  if ( v24 != 2 )
    _assert_fail("offset == 2", "../sysdeps/x86_64/cacheinfo.c", 226, "intel_check_word");
  return (v14 & 0xFFF) + 1;
}
// 8053823: conditional instruction was optimized away because eax.4==1
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80F1288: using guessed type int dword_80F1288;
// 80F128C: using guessed type int dword_80F128C;
// 80536B0: using guessed type char var_24[36];

//----- (08053950) --------------------------------------------------------
int __usercall handle_intel@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  int result; // eax
  unsigned int v4; // ebp
  unsigned int v10; // edx
  int v11; // [esp+14h] [ebp-38h]
  int v12; // [esp+18h] [ebp-34h]
  unsigned int v13; // [esp+1Ch] [ebp-30h]
  char v14; // [esp+2Eh] [ebp-1Eh] BYREF
  char v15[29]; // [esp+2Fh] [ebp-1Dh] BYREF

  result = 0;
  if ( a2 > 1 )
  {
    v14 = 0;
    v4 = 1;
    v15[0] = 0;
    v13 = 1;
    while ( 1 )
    {
      _EAX = 2;
      __asm { cpuid }
      v12 = _EDX;
      v11 = _ECX;
      if ( v4 == 1 )
      {
        v10 = (unsigned __int8)_EAX;
        LOBYTE(_EAX) = 0;
        v13 = v10;
      }
      result = intel_check_word(a1, _EAX, v15, &v14);
      if ( result )
        break;
      result = intel_check_word(a1, _EBX, v15, &v14);
      if ( result )
        break;
      result = intel_check_word(a1, v11, v15, &v14);
      if ( result )
        break;
      result = intel_check_word(a1, v12, v15, &v14);
      if ( result )
        break;
      if ( v13 <= v4 )
      {
        if ( (unsigned int)(a1 - 191) <= 5 )
        {
          if ( v14 )
            return -1;
        }
        return result;
      }
      ++v4;
    }
  }
  return result;
}

//----- (08053A30) --------------------------------------------------------
int __cdecl _cache_sysconf(int a1)
{
  int v1; // eax

  v1 = _cpu_features;
  if ( !_cpu_features )
  {
    _init_cpu_features();
    v1 = _cpu_features;
  }
  if ( v1 == 1 )
    return handle_intel(a1, dword_80F1264);
  if ( v1 == 2 )
    return handle_amd(a1);
  return 0;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1264: using guessed type int dword_80F1264;

//----- (08053A8C) --------------------------------------------------------
void __noreturn exit(int status)
{
  int v1; // eax

  dl_sysinfo[0]();
  v1 = sys_exit(status);
}
// 80EF5A4: invalid function type '?' has been ignored
// 80EF5A4: using guessed type int (*dl_sysinfo[2])();

//----- (08053AB0) --------------------------------------------------------
int __usercall execlp@<eax>(long double a1@<st0>, char *a2, int a3, int a4, int a5)
{
  int *v5; // edi
  int v6; // ebx
  int *v7; // esi
  int v8; // ebp
  int *v9; // eax
  int v10; // eax
  int v11; // ebx
  int *v13; // eax
  int *v14; // eax
  int *v15; // [esp+14h] [ebp-1028h]
  int v16[1031]; // [esp+20h] [ebp-101Ch] BYREF

  v16[0] = a3;
  if ( !a3 )
    return execvp(a1, a2, (int)v16);
  v5 = &a5;
  v6 = 1;
  v7 = v16;
  v8 = 1024;
  v16[1] = a4;
  if ( !a4 )
  {
LABEL_6:
    v11 = execvp(a1, a2, (int)v7);
    if ( v7 != v16 )
      goto LABEL_7;
    return v11;
  }
  while ( v8 != ++v6 )
  {
    v9 = v5;
LABEL_5:
    v5 = v9 + 1;
    v10 = *v9;
    v7[v6] = v10;
    if ( !v10 )
      goto LABEL_6;
  }
  v13 = 0;
  if ( v7 != v16 )
    v13 = v7;
  realloc(v13, 8 * v8);
  if ( v14 )
  {
    if ( v7 == v16 )
    {
      v15 = v14;
      memcpy(v14, v7, 4 * v8);
      v9 = v5;
      v8 *= 2;
      v7 = v15;
    }
    else
    {
      v7 = v14;
      v8 *= 2;
      v9 = v5;
    }
    goto LABEL_5;
  }
  v11 = -1;
  if ( v7 == v16 )
    return v11;
LABEL_7:
  free(a1, (int)v7);
  return v11;
}
// 8053B69: variable 'v14' is possibly undefined
// 8053AB0: using guessed type int var_101C[1031];

//----- (08053BE0) --------------------------------------------------------
__int64 __fastcall getegid(int a1)
{
  return dl_sysinfo(a1);
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08053BF0) --------------------------------------------------------
unsigned int __cdecl setresgid(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08053C60) --------------------------------------------------------
int __cdecl _exit_thread(int a1, int a2, int a3)
{
  int v3; // ecx
  unsigned int v4; // eax

  v4 = dl_sysinfo(v3);
  if ( v4 >= 0xFFFFF001 )
    return _syscall_error(v4);
  else
    return _fxstat64(a1, a2, a3);
}
// 8053C6B: variable 'v3' is possibly undefined
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08053C80) --------------------------------------------------------
unsigned int __cdecl _fxstat64(int a1, int a2, int a3)
{
  unsigned int result; // eax

  result = dl_sysinfo(a3);
  if ( result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08053CB0) --------------------------------------------------------
int __usercall open@<eax>(int ebp0@<ebp>, int a1, int a2)
{
  int result; // eax
  __int32 v4; // eax
  unsigned int v5; // [esp+0h] [ebp-4h] BYREF

  if ( !__readgsdword(0xCu) )
    return _open_nocancel(a1, a2);
  v5 = _libc_enable_asynccancel();
  v4 = dl_sysinfo(a2);
  _libc_disable_asynccancel(_InterlockedExchange((volatile __int32 *)&v5, v4), ebp0);
  result = v5;
  if ( v5 >= 0xFFFFF001 )
    return _syscall_error(v5);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08053CBA) --------------------------------------------------------
unsigned int __cdecl _open_nocancel(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08053D20) --------------------------------------------------------
int __usercall read@<eax>(int ebp0@<ebp>, int a1, int a2)
{
  int result; // eax
  __int32 v4; // eax
  unsigned int v5; // [esp+0h] [ebp-4h] BYREF

  if ( !__readgsdword(0xCu) )
    return _read_nocancel(a1, a2);
  v5 = _libc_enable_asynccancel();
  v4 = dl_sysinfo(a2);
  _libc_disable_asynccancel(_InterlockedExchange((volatile __int32 *)&v5, v4), ebp0);
  result = v5;
  if ( v5 >= 0xFFFFF001 )
    return _syscall_error(v5);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08053D2A) --------------------------------------------------------
unsigned int __cdecl _read_nocancel(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08053D90) --------------------------------------------------------
int __usercall write@<eax>(int a1@<ebp>, int a2, int a3, int a4)
{
  int result; // eax
  __int32 v5; // eax
  unsigned int v6; // [esp+0h] [ebp-4h] BYREF

  if ( !__readgsdword(0xCu) )
    return _write_nocancel(a2, a3, a4);
  v6 = _libc_enable_asynccancel();
  v5 = dl_sysinfo(a3);
  _libc_disable_asynccancel(_InterlockedExchange((volatile __int32 *)&v6, v5), a1);
  result = v6;
  if ( v6 >= 0xFFFFF001 )
    return _syscall_error(v6);
  return result;
}
// 8053D9A: using guessed type _DWORD __cdecl _write_nocancel(_DWORD, _DWORD, _DWORD);
// 80EF5A4: using guessed type int (__fastcall *dl_sysinfo)(_DWORD);

//----- (08053D9A) --------------------------------------------------------
unsigned int __cdecl _write_nocancel(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08053E00) --------------------------------------------------------
unsigned int __cdecl _fcntl_nocancel(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08053E40) --------------------------------------------------------
unsigned int __usercall fcntl@<eax>(int a1@<ebp>, int a2, int a3)
{
  unsigned int v3; // eax
  unsigned int v4; // ebx
  int v6; // esi

  if ( __readgsdword(0xCu) && (a3 == 14 || a3 == 7) )
  {
    v6 = _libc_enable_asynccancel();
    v4 = dl_sysinfo(a3);
    if ( v4 > 0xFFFFF000 )
    {
      __writegsdword(0xFFFFFFE8, -v4);
      v4 = -1;
    }
    _libc_disable_asynccancel(v6, a1);
  }
  else
  {
    v3 = dl_sysinfo(a3);
    if ( v3 > 0xFFFFF000 )
    {
      v4 = -1;
      __writegsdword(0xFFFFFFE8, -v3);
    }
    else
    {
      return v3;
    }
  }
  return v4;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08053EE0) --------------------------------------------------------
int __cdecl sbrk(int a1)
{
  unsigned int v1; // ebx
  unsigned int v2; // esi

  v1 = _curbrk;
  if ( !_curbrk || _libc_multiple_libcs )
  {
    v1 = -1;
    if ( brk(0) < 0 )
      return v1;
    v1 = _curbrk;
  }
  if ( !a1 )
    return v1;
  if ( a1 <= 0 )
  {
    if ( v1 >= -a1 )
    {
      v2 = v1 + a1;
LABEL_6:
      if ( brk(v2) < 0 )
        return -1;
      return v1;
    }
  }
  else
  {
    v2 = v1 + a1;
    if ( !__CFADD__(v1, a1) )
      goto LABEL_6;
  }
  return -1;
}
// 80EF5C4: using guessed type int _libc_multiple_libcs;
// 80F0DDC: using guessed type int _curbrk;

//----- (08053F80) --------------------------------------------------------
void cancel_handler()
{
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --syslog_lock )
    L_unlock_7();
}
// 80F05C8: using guessed type int syslog_lock;

//----- (08053FA0) --------------------------------------------------------
char *__usercall openlog_internal@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebp>)
{
  int v4; // esi
  char *result; // eax
  unsigned int v6; // edi
  int v7; // eax
  int v8; // edx

  if ( a1 )
    LogTag = a1;
  LogStat = a2;
  if ( a3 && (a3 & 0xFFFFFC07) == 0 )
    LogFacility = a3;
  v4 = 2;
  while ( 1 )
  {
    result = (char *)LogFile;
    if ( LogFile == -1 )
    {
      SyslogAddr = 1;
      result = strncpy(dest, "/dev/log", 0x6Cu);
      if ( (LogStat & 8) == 0 )
        return result;
      if ( _have_sock_cloexec < 0 )
        goto LABEL_25;
      result = (char *)socket(1);
      v8 = _have_sock_cloexec;
      LogFile = (int)result;
      if ( !_have_sock_cloexec )
      {
        v8 = 1;
        if ( result == (char *)-1 )
          v8 = 2 * (__readgsdword(0xFFFFFFE8) != 22) - 1;
        _have_sock_cloexec = v8;
      }
      if ( v8 < 0 )
      {
LABEL_25:
        result = (char *)socket(1);
        LogFile = (int)result;
      }
      if ( result == (char *)-1 )
        return result;
      if ( _have_sock_cloexec < 0 )
      {
        fcntl(a4, (int)result, 2);
        result = (char *)LogFile;
        if ( LogFile == -1 )
          return result;
      }
    }
    if ( connected )
      return result;
    v6 = __readgsdword(0xFFFFFFE8);
    result = (char *)connect(a4, (char)result);
    if ( result != (char *)-1 )
    {
      connected = 1;
      return result;
    }
    a4 = __readgsdword(0xFFFFFFE8);
    v7 = LogFile;
    LogFile = -1;
    result = (char *)close(a4, v7);
    __writegsdword(0xFFFFFFE8, v6);
    if ( a4 == 91 )
    {
      result = (char *)((LogType != 2) + 1);
      --v4;
      LogType = (int)result;
      if ( v4 )
        continue;
    }
    return result;
  }
}
// 80EF560: using guessed type int LogFacility;
// 80EF564: using guessed type int LogType;
// 80EF568: using guessed type int LogFile;
// 80F05C0: using guessed type int LogTag;
// 80F05C4: using guessed type int LogStat;
// 80F05CC: using guessed type int connected;
// 80F05E0: using guessed type __int16 SyslogAddr;
// 80F1168: using guessed type int _have_sock_cloexec;

//----- (080541A0) --------------------------------------------------------
int __usercall closelog_internal@<eax>(int a1@<ebp>)
{
  int result; // eax

  result = connected;
  if ( connected )
  {
    result = close(a1, LogFile);
    LogFile = -1;
    connected = 0;
  }
  return result;
}
// 80EF568: using guessed type int LogFile;
// 80F05CC: using guessed type int connected;

//----- (080541E0) --------------------------------------------------------
void __usercall _vsyslog_chk(long double a1@<st0>, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  int v6; // edx
  int *v7; // eax
  int v8; // ecx
  int *v9; // ebx
  int v10; // ecx
  char *v11; // esi
  signed int *v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // esi
  _BYTE *v16; // eax
  _BYTE *v17; // eax
  _BYTE *v18; // eax
  char *v19; // ebx
  bool v21; // zf
  int v22; // eax
  int v23; // eax
  int *v24; // ebx
  int v25; // ecx
  char *v26; // edi
  _BYTE *v27; // eax
  int v28; // eax
  int v29; // ebx
  int *v30; // [esp+4h] [ebp-B8h]
  unsigned int v31; // [esp+2Ch] [ebp-90h]
  int v32[11]; // [esp+30h] [ebp-8Ch] BYREF
  char v33[29]; // [esp+5Fh] [ebp-5Dh] BYREF
  int v34[3]; // [esp+7Ch] [ebp-40h] BYREF
  int v35[4]; // [esp+88h] [ebp-34h] BYREF
  char *v36; // [esp+98h] [ebp-24h] BYREF
  int v37[8]; // [esp+9Ch] [ebp-20h] BYREF

  v5 = a2;
  v36 = 0;
  v37[0] = 0;
  v31 = __readgsdword(0xFFFFFFE8);
  if ( (a2 & 0xFFFFFC00) != 0 )
  {
    v5 = a2 & 0x3FF;
    syslog(35, (int)"syslog: unknown facility/priority: %x", a2);
  }
  v6 = LogMask;
  if ( _bittest(&v6, v5 & 7) )
  {
    if ( (v5 & 0x3F8) == 0 )
      v5 |= LogFacility;
    v7 = open_memstream((int)&v36, (int)v37);
    v9 = v7;
    if ( v7 )
    {
      *v7 |= 0x8000u;
      fprintf((int)v7, (int)"<%d>", v5);
      time(v10);
      localtime_r(a1, &v35[3], v32);
      v11 = (char *)v9[5];
      v9[5] = (int)&v11[strftime_l(a1, v11, v9[6] - (_DWORD)v11, "%h %e %T ", v12, nl_C_locobj)];
      ftell(v9);
      v15 = v14;
      v16 = (_BYTE *)LogTag;
      if ( LogTag || (v16 = program_invocation_short_name, (LogTag = (int)program_invocation_short_name) != 0) )
        fputs_unlocked(v16, (int)v9);
      if ( (LogStat & 1) != 0 )
      {
        v23 = getpid(v13);
        fprintf((int)v9, (int)"[%d]", v23);
      }
      if ( LogTag )
      {
        v17 = (_BYTE *)v9[5];
        if ( (unsigned int)v17 >= v9[6] )
        {
          _overflow((int)v9, 58);
          v18 = (_BYTE *)v9[5];
        }
        else
        {
          *v17 = 58;
          v18 = v17 + 1;
          v9[5] = (int)v18;
        }
        if ( v9[6] <= (unsigned int)v18 )
        {
          _overflow((int)v9, 32);
        }
        else
        {
          *v18 = 32;
          v9[5] = (int)(v18 + 1);
        }
      }
      __writegsdword(0xFFFFFFE8, v31);
      if ( a3 == -1 )
        vfprintf(v9, a4, a5);
      else
        _vfprintf_chk(v9, a3, a4, a5);
      fclose(v9);
      v19 = v36;
    }
    else
    {
      strcpy(v33, "out of memory [");
      v24 = v35;
      v25 = getpid(v8);
      do
      {
        v24 = (int *)((char *)v24 - 1);
        *(_BYTE *)v24 = v25 % 10 + 48;
        v25 /= 10;
      }
      while ( v25 );
      v26 = (char *)((char *)v35 - (char *)v24);
      v15 = 0;
      v30 = v24;
      v19 = v33;
      v27 = mempcpy(&v33[15], v30, (unsigned int)v26);
      v36 = v33;
      *v27 = 93;
      v27[1] = 0;
      v37[0] = v27 + 1 - v33;
    }
    if ( (LogStat & 0x20) != 0 )
    {
      v34[0] = (int)&v19[v15];
      v34[1] = v37[0] - v15;
      if ( v19[v37[0] - 1] != 10 )
      {
        v34[2] = (int)"\n";
        v35[0] = 1;
      }
      writev(a3, 2, (int)v34);
      v19 = v36;
    }
    v35[1] = (int)v19;
    _ECX = 1;
    v35[2] = 0;
    v21 = __readgsdword(0xCu) == 0;
    if ( !v21 )
      __asm { lock }
    __asm { cmpxchg ds:syslog_lock, ecx }
    if ( !v21 )
    {
      L_lock_498(0);
      return;
    }
    v22 = connected;
    if ( connected )
    {
      if ( LogType != 1 )
      {
LABEL_28:
        if ( !v22
          || (send(a3, LogFile) & 0x80000000) != 0
          && (!connected
           || (closelog_internal(a3), openlog_internal(LogTag, LogStat | 8, 0, a3), !connected)
           || (send(a3, LogFile) & 0x80000000) != 0) )
        {
          closelog_internal(a3);
          if ( (LogStat & 2) != 0 )
          {
            v28 = open(a3, (int)"/dev/console", 257);
            v29 = v28;
            if ( v28 >= 0 )
            {
              dprintf(v28, (int)"%s\r\n", &v36[v15]);
              close(a3, v29);
            }
          }
        }
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --syslog_lock )
        {
          L_unlock_527();
        }
        else if ( v36 != v33 )
        {
          free(v36);
        }
        return;
      }
    }
    else
    {
      openlog_internal(LogTag, LogStat | 8, 0, a3);
      v22 = connected;
      if ( LogType != 1 )
        goto LABEL_28;
    }
    ++v37[0];
    goto LABEL_28;
  }
}
// 8054293: variable 'v10' is possibly undefined
// 80542CB: variable 'v12' is possibly undefined
// 80542DD: variable 'v14' is possibly undefined
// 80545B0: variable 'v13' is possibly undefined
// 805461E: variable 'v8' is possibly undefined
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 805D080: using guessed type _DWORD __cdecl vfprintf(_DWORD, _DWORD, _DWORD);
// 80C8380: using guessed type char **nl_C_locobj[6];
// 80EF55C: using guessed type int LogMask;
// 80EF560: using guessed type int LogFacility;
// 80EF564: using guessed type int LogType;
// 80EF568: using guessed type int LogFile;
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80F05C0: using guessed type int LogTag;
// 80F05C4: using guessed type int LogStat;
// 80F05C8: using guessed type int syslog_lock;
// 80F05CC: using guessed type int connected;
// 80541E0: using guessed type int var_20[8];
// 80541E0: using guessed type int var_8C[11];

//----- (08054730) --------------------------------------------------------
void __usercall _syslog_chk(long double a1@<st0>, int a2, int a3, int a4, ...)
{
  va_list va; // [esp+2Ch] [ebp+10h] BYREF

  va_start(va, a4);
  _vsyslog_chk(a1, a2, a3, a4, (int)va);
}

//----- (08054760) --------------------------------------------------------
int syslog(int a1, int a2, ...)
{
  va_list va; // [esp+28h] [ebp+Ch] BYREF

  va_start(va, a2);
  return _vsyslog_chk(a1, -1, a2, (char *)va);
}
// 80541E0: using guessed type _DWORD __cdecl _vsyslog_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08054790) --------------------------------------------------------
void __usercall vsyslog(long double a1@<st0>, int a2, int a3, int a4)
{
  _vsyslog_chk(a1, a2, -1, a3, a4);
}

//----- (080547C0) --------------------------------------------------------
void __usercall openlog(int a1@<ebp>, int a2, int a3, int a4)
{
  bool v5; // zf

  _ECX = 1;
  v5 = __readgsdword(0xCu) == 0;
  if ( !v5 )
    __asm { lock }
  __asm { cmpxchg ds:syslog_lock, ecx }
  if ( v5 )
  {
    openlog_internal(a2, a3, a4, a1);
    cancel_handler();
  }
  else
  {
    L_lock_999(0);
  }
}
// 80F05C8: using guessed type int syslog_lock;

//----- (08054830) --------------------------------------------------------
void __usercall closelog(int a1@<ebp>)
{
  bool v2; // zf

  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg ds:syslog_lock, ecx }
  if ( v2 )
  {
    closelog_internal(a1);
    LogTag = 0;
    LogType = 2;
    cancel_handler();
  }
  else
  {
    L_lock_1062(0);
  }
}
// 80EF564: using guessed type int LogType;
// 80F05C0: using guessed type int LogTag;
// 80F05C8: using guessed type int syslog_lock;

//----- (080548A0) --------------------------------------------------------
int __cdecl setlogmask(int a1)
{
  int result; // eax

  result = LogMask;
  if ( a1 )
    LogMask = a1;
  return result;
}
// 80EF55C: using guessed type int LogMask;

//----- (080548B5) --------------------------------------------------------
void L_unlock_7()
{
  _lll_unlock_wake_private(&syslog_lock);
  JUMPOUT(0x8053F98);
}
// 80548C0: control flows out of bounds to 8053F98
// 80F05C8: using guessed type int syslog_lock;

//----- (080548C5) --------------------------------------------------------
void __usercall L_lock_498(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &syslog_lock);
  JUMPOUT(0x8054427);
}
// 80548D0: control flows out of bounds to 8054427
// 80F05C8: using guessed type int syslog_lock;

//----- (080548D5) --------------------------------------------------------
void L_unlock_527()
{
  _lll_unlock_wake_private(&syslog_lock);
  JUMPOUT(0x8054473);
}
// 80548E0: control flows out of bounds to 8054473
// 80F05C8: using guessed type int syslog_lock;

//----- (080548E5) --------------------------------------------------------
void __usercall L_lock_999(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &syslog_lock);
  JUMPOUT(0x80547F6);
}
// 80548F0: control flows out of bounds to 80547F6
// 80F05C8: using guessed type int syslog_lock;

//----- (080548F5) --------------------------------------------------------
void __usercall L_lock_1062(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &syslog_lock);
  JUMPOUT(0x8054852);
}
// 8054900: control flows out of bounds to 8054852
// 80F05C8: using guessed type int syslog_lock;

//----- (08054910) --------------------------------------------------------
unsigned int __cdecl mmap(int a1, int a2, int a3, int a4, int a5, __int16 a6)
{
  unsigned int result; // eax

  result = -22;
  if ( (a6 & 0xFFF) == 0 )
    result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type int (__fastcall *dl_sysinfo)(_DWORD);

//----- (08054960) --------------------------------------------------------
unsigned int __cdecl munmap(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08054990) --------------------------------------------------------
unsigned int __cdecl mprotect(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080549C0) --------------------------------------------------------
unsigned int __cdecl madvise(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080549F0) --------------------------------------------------------
int __usercall phys_pages_info@<eax>(unsigned __int8 *a1@<eax>, long double a2@<st0>)
{
  int *v3; // eax
  int *v4; // ebx
  int v5; // eax
  int result; // eax
  char v7[8192]; // [esp+1Ch] [ebp-2020h] BYREF
  int v8; // [esp+201Ch] [ebp-20h] BYREF

  v8 = -1;
  v3 = fopen((int)"/proc/meminfo", "rce");
  v4 = v3;
  if ( v3 )
  {
    *v3 |= 0x8000u;
    v8 = 0;
    while ( fgets_unlocked((int)v7, 0x2000, v4) )
    {
      sscanf(a2, (unsigned int)v7, a1, &v8);
      if ( v5 == 1 )
      {
        v8 /= getpagesize() / 1024;
        break;
      }
    }
    fclose(v4);
  }
  result = v8;
  if ( v8 == -1 )
    __writegsdword(0xFFFFFFE8, 0x26u);
  return result;
}
// 8054A6B: variable 'v5' is possibly undefined

//----- (08054AD0) --------------------------------------------------------
char *__usercall next_line@<eax>(int a1@<eax>, char *a2@<edx>, const void **a3@<ecx>, int *a4, int a5)
{
  char *v5; // ebx
  int v6; // ebp
  const void **v7; // edi
  char *v8; // eax
  char *v9; // eax
  signed int nocancel; // eax
  int v12; // edx
  int v13; // edx
  char *v14; // eax
  int v15; // ebp
  _BYTE *v16; // edi
  void *v17; // ebx
  signed int v18; // eax
  signed int v19; // ebx
  int v20; // [esp+1Ch] [ebp-30h]
  int n; // [esp+20h] [ebp-2Ch]
  void *desta; // [esp+24h] [ebp-28h]
  const void **v25; // [esp+2Ch] [ebp-20h]

  v5 = (char *)*a3;
  v6 = *a4;
  v7 = a3;
  n = *a4 - (_DWORD)*a3;
  v8 = (char *)memchr(*a3, 10, n);
  if ( v8 )
    goto LABEL_2;
  if ( v5 == a2 || v6 != a5 )
    goto LABEL_8;
  memmove(a2, v5, n);
  *a4 = &a2[*a4] - (_BYTE *)*v7;
  *v7 = a2;
  nocancel = _read_nocancel(a1, *a4);
  if ( nocancel < 0 )
    return 0;
  v12 = nocancel + *a4;
  *a4 = v12;
  v5 = (char *)*v7;
  v20 = v12;
  v8 = (char *)memchr(*v7, 10, v12 - (_DWORD)*v7);
  v13 = v20;
  if ( v8 )
    goto LABEL_2;
  if ( v6 == v20 )
  {
    v25 = v7;
    v14 = &a2[3 * (v6 - (int)a2) / 4];
    desta = (void *)v6;
    v15 = (int)v14;
    while ( 1 )
    {
      *a4 = v15;
      v18 = _read_nocancel(a1, v15);
      v19 = v18;
      if ( v18 < 0 )
        return 0;
      v16 = (_BYTE *)*a4;
      v8 = (char *)memchr((const void *)*a4, 10, v18);
      *v16 = 10;
      v17 = (void *)(*a4 + v19);
      *a4 = (int)v17;
      if ( v8 )
      {
        v7 = v25;
        v5 = (char *)*v25;
        goto LABEL_2;
      }
      if ( desta != v17 )
      {
        v7 = v25;
        v13 = (int)v17;
        v5 = (char *)*v25;
        break;
      }
    }
  }
  v6 = v13;
LABEL_8:
  v8 = (char *)(v6 - 1);
LABEL_2:
  v9 = v8 + 1;
  *v7 = v9;
  if ( (unsigned int)v9 > *a4 )
    _assert_fail("*cp <= *re", "../sysdeps/unix/sysv/linux/getsysstats.c", 123, "next_line");
  if ( v5 == (char *)*a4 )
    return 0;
  return v5;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08054CA0) --------------------------------------------------------
int __fastcall get_nprocs(int a1)
{
  unsigned int v1; // eax
  void *v2; // esp
  char *v3; // eax
  char *v4; // ecx
  char *v5; // esi
  int v6; // eax
  char *v7; // edx
  int v8; // ebx
  unsigned int v9; // ebx
  char *v10; // esi
  char *v12; // edi
  char *v13; // esi
  int v14; // ecx
  bool v15; // zf
  char *v16; // eax
  char *line; // eax
  _BYTE v18[8]; // [esp+10h] [ebp-48h] BYREF
  int v19; // [esp+18h] [ebp-40h]
  const void **v20; // [esp+1Ch] [ebp-3Ch]
  _BYTE *v21; // [esp+20h] [ebp-38h]
  char *v22; // [esp+24h] [ebp-34h]
  int v23; // [esp+28h] [ebp-30h]
  int v24; // [esp+2Ch] [ebp-2Ch]
  const void *v25; // [esp+34h] [ebp-24h] BYREF
  char *v26; // [esp+38h] [ebp-20h] BYREF
  char *v27[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  v19 = time(a1);
  if ( v19 != timestamp_9146 )
  {
    v1 = !_libc_alloca_cutoff(0x2000u) ? 0xFFFFE200 : 0;
    v2 = alloca(v1 + 8208);
    v22 = v18;
    v21 = &v18[v1 + 0x2000];
    v25 = v21;
    v26 = v21;
    v23 = _open_nocancel((int)"/sys/devices/system/cpu/online", 0x80000);
    if ( v23 != -1 )
    {
      v20 = &v25;
      v3 = next_line(v23, v22, &v25, (int *)&v26, (int)v21);
      v24 = 0;
      v5 = v3;
      if ( v3 )
      {
        while ( 1 )
        {
          v6 = strtoul(v5, v27, 10);
          v7 = v27[0];
          v8 = v6;
          if ( v5 == v27[0] )
            break;
          if ( *v27[0] == 45 )
          {
            v10 = v27[0] + 1;
            v6 = strtoul(v27[0] + 1, v27, 10);
            v7 = v27[0];
            if ( v10 == v27[0] )
              break;
          }
          v24 = v6 + v24 - v8 + 1;
          v4 = v26;
          if ( v26 <= v7 )
            goto LABEL_13;
          v9 = __readgsdword(0xFFFFFFF8);
          while ( (*(_BYTE *)(v9 + 2 * *v7 + 1) & 0x20) != 0 )
          {
            if ( ++v7 == v26 )
              goto LABEL_13;
          }
          v5 = v7;
        }
        v24 = 0;
      }
LABEL_13:
      dl_sysinfo(v4);
      if ( v24 > 0 )
        goto LABEL_14;
    }
    v25 = v21;
    v26 = v21;
    v23 = _open_nocancel((int)"/proc/stat", 0x80000);
    if ( v23 == -1 )
    {
      v23 = _open_nocancel((int)"/proc/cpuinfo", 0x80000);
      if ( v23 == -1 )
      {
        v24 = 1;
        goto LABEL_14;
      }
      v24 = 0;
      v20 = &v25;
      while ( 1 )
      {
        line = next_line(v23, v22, v20, (int *)&v26, (int)v21);
        if ( !line )
          break;
        v24 += memcmp(line, "processor", 9u) == 0;
      }
    }
    else
    {
      v24 = 0;
      v20 = &v25;
      while ( 1 )
      {
        v16 = next_line(v23, v22, v20, (int *)&v26, (int)v21);
        v15 = v16 == 0;
        if ( !v16 )
          break;
        v12 = "cpu";
        v13 = v16;
        v14 = 3;
        do
        {
          if ( !v14 )
            break;
          v15 = *v13++ == *v12++;
          --v14;
        }
        while ( v15 );
        if ( !v15 )
          break;
        v24 += (unsigned int)(v16[3] - 48) < 0xA;
      }
    }
    dl_sysinfo(v14);
LABEL_14:
    cached_result_9145 = v24;
    timestamp_9146 = v19;
    return v24;
  }
  v24 = cached_result_9145;
  return cached_result_9145;
}
// 8054DE0: variable 'v4' is possibly undefined
// 8054E82: variable 'v14' is possibly undefined
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80F0650: using guessed type int timestamp_9146;
// 80F0654: using guessed type int cached_result_9145;

//----- (08054F20) --------------------------------------------------------
int get_nprocs_conf()
{
  int v0; // ebp
  int v1; // ecx
  int *v2; // ebx
  _BYTE *v3; // eax
  char *v4; // esi
  char *v6; // [esp+1Ch] [ebp-20h] BYREF

  v0 = 0;
  v2 = opendir("/sys/devices/system/cpu");
  if ( !v2 )
    return get_nprocs(v1);
  while ( 1 )
  {
    readdir64(v2);
    if ( !v3 )
      break;
    while ( v3[18] == 4 )
    {
      if ( memcmp(v3 + 19, "cpu", 3u) )
        break;
      v4 = v3 + 22;
      if ( strtoul(v3 + 22, &v6, 10) == -1 || v4 == v6 )
        break;
      v0 += *v6 == 0;
      readdir64(v2);
      if ( !v3 )
        goto LABEL_8;
    }
  }
LABEL_8:
  closedir((int)v2);
  return v0;
}
// 8054F4A: variable 'v3' is possibly undefined
// 8054FB2: variable 'v1' is possibly undefined

//----- (08054FC0) --------------------------------------------------------
int __usercall get_phys_pages@<eax>(long double a1@<st0>)
{
  return phys_pages_info("MemTotal: %ld kB", a1);
}

//----- (08054FD0) --------------------------------------------------------
int __usercall get_avphys_pages@<eax>(long double a1@<st0>)
{
  return phys_pages_info("MemFree: %ld kB", a1);
}

//----- (08054FE0) --------------------------------------------------------
void __cdecl _init_misc(int a1, const char **a2)
{
  const char *s; // esi
  char *v3; // eax

  if ( a2 )
  {
    s = *a2;
    if ( *a2 )
    {
      v3 = strrchr(s, 47);
      if ( v3 )
        program_invocation_short_name = v3 + 1;
      else
        program_invocation_short_name = (void *)s;
      program_invocation_name = (void *)*a2;
    }
  }
}
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80EF570: using guessed type void *program_invocation_name;

//----- (08055030) --------------------------------------------------------
unsigned int __cdecl mremap(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08055070) --------------------------------------------------------
unsigned int __usercall connect@<eax>(int a1@<ebp>, char a2)
{
  unsigned int result; // eax
  int v3; // esi
  unsigned int v4; // et0

  if ( !__readgsdword(0xCu) )
  {
    result = dl_sysinfo(&a2);
    if ( result < 0xFFFFFF83 )
      return result;
    return _syscall_error(result);
  }
  v3 = _libc_enable_asynccancel();
  v4 = dl_sysinfo(&a2);
  _libc_disable_asynccancel(v3, a1);
  result = v4;
  if ( v4 >= 0xFFFFFF83 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080550D0) --------------------------------------------------------
unsigned int __usercall send@<eax>(int a1@<ebp>, char a2)
{
  unsigned int result; // eax
  int v3; // esi
  unsigned int v4; // et0

  if ( !__readgsdword(0xCu) )
  {
    result = dl_sysinfo(&a2);
    if ( result < 0xFFFFFF83 )
      return result;
    return _syscall_error(result);
  }
  v3 = _libc_enable_asynccancel();
  v4 = dl_sysinfo(&a2);
  _libc_disable_asynccancel(v3, a1);
  result = v4;
  if ( v4 >= 0xFFFFFF83 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08055130) --------------------------------------------------------
unsigned int __cdecl socket(char a1)
{
  unsigned int result; // eax

  result = dl_sysinfo(&a1);
  if ( result >= 0xFFFFFF83 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08055160) --------------------------------------------------------
_BOOL4 __cdecl _libc_alloca_cutoff(unsigned int a1)
{
  unsigned int v1; // eax

  v1 = 0x10000;
  if ( (__readgsdword(0x274u) >> 2) - 1 <= 0xFFFF )
  {
    v1 = __readgsdword(0x274u) >> 2;
    if ( !v1 )
      v1 = 0x40000;
  }
  return v1 >= a1;
}

//----- (080551A0) --------------------------------------------------------
__int32 __usercall _lll_lock_wait_private@<eax>(int a1@<eax>, volatile __int32 *a2@<ecx>)
{
  __int32 v2; // edx
  int v4; // ecx
  __int32 result; // eax

  v2 = 2;
  v4 = 128;
  if ( a1 != 2 )
    goto LABEL_3;
  do
  {
    dl_sysinfo(v4);
LABEL_3:
    result = _InterlockedExchange(a2, v2);
  }
  while ( result );
  return result;
}
// 80EF5A4: invalid function type 'int (*dl_sysinfo[2])()' has been ignored
// 80551BA: variable 'v4' is possibly undefined
// 80551C2: variable 'v2' is possibly undefined
// 80EF5A4: using guessed type int (__fastcall *dl_sysinfo)(_DWORD);

//----- (080551D0) --------------------------------------------------------
int __usercall _lll_unlock_wake_private@<eax>(_DWORD *a1@<eax>)
{
  *a1 = 0;
  return dl_sysinfo(129);
}
// 80EF5A4: using guessed type int (__fastcall *dl_sysinfo)(_DWORD);

//----- (08055200) --------------------------------------------------------
int _libc_enable_asynccancel()
{
  signed __int32 i; // edx
  signed __int32 v1; // eax

  for ( i = __readgsdword(0x84u); ; i = v1 )
  {
    if ( (i | 2) == i )
      return i;
    v1 = _InterlockedCompareExchange(MK_FP(__GS__, 132), i | 2, i);
    if ( i == v1 )
      break;
  }
  if ( (i & 0xFFFFFFB9 | 2) != 10 )
    return i;
  __writegsdword(0x228u, 0xFFFFFFFF);
  _InterlockedOr(MK_FP(__GS__, 132), 0x10u);
  MEMORY[0]();
  return _libc_disable_asynccancel();
}
// 8055260: using guessed type int _libc_disable_asynccancel(void);

//----- (08055260) --------------------------------------------------------
int __usercall _libc_disable_asynccancel@<eax>(int result@<eax>, int a2@<ebp>)
{
  unsigned int v2; // ebx
  signed __int32 i; // ecx
  int v4; // edx
  int *v5; // ebx
  int v6; // eax

  if ( (result & 2) == 0 )
  {
    v2 = __readgsdword(8u);
    for ( i = __readgsdword(0x84u); ; i = result )
    {
      v4 = i & 0xFFFFFFFD;
      result = _InterlockedCompareExchange(MK_FP(__GS__, 132), i & 0xFFFFFFFD, i);
      if ( i == result )
        break;
    }
    if ( (i & 0xC) == 4 )
    {
      v5 = (int *)(v2 + 132);
      do
      {
        v6 = sys_futex(v5, 128, v4, 0, (int *)0xF0, a2);
        v4 = __readgsdword(0x84u);
        result = v4 & 0xC;
      }
      while ( result == 4 );
    }
  }
  return result;
}

//----- (080552E0) --------------------------------------------------------
void __cdecl _register_atfork(int a1, int a2, int a3, int a4)
{
  bool v5; // zf
  int *v6; // eax
  _DWORD *v7; // ecx
  int i; // edx
  int v10; // edx

  _ECX = 1;
  v5 = __readgsdword(0xCu) == 0;
  if ( !v5 )
    __asm { lock }
  __asm { cmpxchg ds:__fork_lock, ecx }
  if ( v5 )
  {
    v6 = &fork_handler_pool;
    while ( 2 )
    {
      v7 = v6 + 6;
      for ( i = 0; i != 48; ++i )
      {
        if ( !*v7 )
          goto LABEL_8;
        v7 += 7;
      }
      v6 = (int *)*v6;
      if ( v6 )
        continue;
      break;
    }
    calloc(1, 0x544u);
    if ( v6 )
    {
      v10 = fork_handler_pool;
      fork_handler_pool = (int)v6;
      *v6 = v10;
      i = 47;
LABEL_8:
      _EDX = &v6[7 * i + 1];
      _EDX[5] = 1;
      _EDX[6] = 0;
      _EDX[1] = a1;
      _EDX[2] = a2;
      _EDX[3] = a3;
      _EDX[4] = a4;
      *_EDX = _fork_handlers;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      __asm { cmpxchg ds:__fork_handlers, edx }
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --_fork_lock )
      L_unlock_178();
  }
  else
  {
    L_lock_83(0);
  }
}
// 8055327: variable 'v6' is possibly undefined
// 80F0660: using guessed type int _fork_lock;
// 80F0680: using guessed type int fork_handler_pool;
// 80F12F8: using guessed type int _fork_handlers;

//----- (080553E0) --------------------------------------------------------
int __cdecl _linkin_atfork(_DWORD *a1)
{
  int v2; // edx
  int result; // eax

  _ECX = a1;
  v2 = _fork_handlers;
  *a1 = _fork_handlers;
  result = v2;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  __asm { cmpxchg ds:__fork_handlers, ecx }
  return result;
}
// 80F12F8: using guessed type int _fork_handlers;

//----- (0805540A) --------------------------------------------------------
void __usercall L_lock_83(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &_fork_lock);
  JUMPOUT(0x8055302);
}
// 8055415: control flows out of bounds to 8055302
// 80F0660: using guessed type int _fork_lock;

//----- (0805541A) --------------------------------------------------------
void L_unlock_178()
{
  _lll_unlock_wake_private(&_fork_lock);
  JUMPOUT(0x8055390);
}
// 8055425: control flows out of bounds to 8055390
// 80F0660: using guessed type int _fork_lock;

//----- (08055430) --------------------------------------------------------
void __cdecl _vfprintf_chk(_DWORD *a1, int a2, int a3, int a4)
{
  unsigned int v5; // edi
  bool v7; // zf
  int v8; // ecx
  int v9; // eax
  _DWORD *v10; // edx

  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v5 = __readgsdword(8u);
    if ( v5 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v7 = __readgsdword(0xCu) == 0;
      if ( !v7 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v7 )
      {
        L_lock_34(0, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v5;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  if ( a2 > 0 )
    a1[15] |= 4u;
  v8 = vfprintf(a1, a3, a4);
  v9 = a1[15];
  if ( a2 > 0 )
  {
    v9 &= ~4u;
    a1[15] = v9;
  }
  a1[15] = v9 & 0xFFFFFFEB;
  if ( (BYTE1(*a1) & 0x80u) == 0 )
  {
    v10 = (_DWORD *)a1[18];
    v7 = v10[1]-- == 1;
    if ( v7 )
    {
      v10[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v7 = (*v10)-- == 1;
      if ( !v7 )
        L_unlock_97(v8, v10);
    }
  }
}
// 805D080: using guessed type _DWORD __cdecl vfprintf(_DWORD, _DWORD, _DWORD);

//----- (08055533) --------------------------------------------------------
void __usercall L_lock_34(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x8055478);
}
// 805553A: control flows out of bounds to 8055478

//----- (0805553F) --------------------------------------------------------
void __fastcall L_unlock_97(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x80554E5);
}
// 8055546: control flows out of bounds to 80554E5

//----- (08055548) --------------------------------------------------------
#error "805552E: call analysis failed (funcsize=5)"

//----- (08055560) --------------------------------------------------------
int __cdecl backtrace_helper(int a1, _DWORD *a2)
{
  int v2; // edx
  int v3; // edi
  int *v4; // edi
  int IP; // eax
  int v6; // edx
  int result; // eax
  bool v8; // zf

  v2 = -1;
  v3 = a2[1];
  if ( v3 != -1 )
  {
    v4 = (int *)(*a2 + 4 * v3);
    IP = Unwind_GetIP(a1);
    v2 = a2[1];
    *v4 = IP;
  }
  v6 = v2 + 1;
  result = 5;
  v8 = v6 == a2[2];
  a2[1] = v6;
  if ( !v8 )
  {
    a2[3] = Unwind_GetGR(a1, 5);
    a2[4] = Unwind_GetCFA(a1);
    return 0;
  }
  return result;
}

//----- (080555E0) --------------------------------------------------------
int __cdecl backtrace(int a1, int a2)
{
  int result; // eax
  unsigned int v3; // edx
  unsigned int v4; // edi
  int v5; // [esp+1Ch] [ebp-2Ch] BYREF
  int v6; // [esp+20h] [ebp-28h]
  int v7; // [esp+24h] [ebp-24h]
  unsigned int v8; // [esp+28h] [ebp-20h]
  unsigned int v9; // [esp+2Ch] [ebp-1Ch]

  v8 = 0;
  v9 = 0;
  v5 = a1;
  v6 = -1;
  v7 = a2;
  if ( a2 <= 0 )
  {
    result = -1;
  }
  else
  {
    Unwind_Backtrace((int (__cdecl *)(char *, int))backtrace_helper, (int)&v5);
    result = v6;
    if ( v6 > 1 && !*(_DWORD *)(v5 + 4 * (v6 - 1)) )
      return v6 - 1;
  }
  if ( a2 > result )
  {
    v3 = v8;
    v4 = v9;
    while ( v4 <= v3 )
    {
      if ( _libc_stack_end < v3 )
        break;
      if ( (v3 & 3) != 0 )
        break;
      *(_DWORD *)(a1 + 4 * result++) = *(_DWORD *)(v3 + 4);
      v3 = *(_DWORD *)v3;
      if ( result == a2 )
        break;
    }
  }
  if ( result == -1 )
    return 0;
  return result;
}
// 80EEFC0: using guessed type int _libc_stack_end;

//----- (080556A0) --------------------------------------------------------
unsigned int __cdecl backtrace_symbols_fd(int a1, int a2, int a3)
{
  unsigned int result; // eax
  int v4; // ebx
  int v5; // ebp
  int v6; // edi
  int v7; // eax
  int v8; // edx
  int v9; // eax
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  char *v12; // eax
  int v13; // edx
  unsigned int v14; // eax
  char *v15; // eax
  int v16; // ecx
  unsigned int v17; // [esp+10h] [ebp-ACh]
  int v18; // [esp+14h] [ebp-A8h]
  int v19; // [esp+14h] [ebp-A8h]
  int v20; // [esp+28h] [ebp-94h]
  int v21; // [esp+2Ch] [ebp-90h]
  _BYTE *v22; // [esp+34h] [ebp-88h] BYREF
  int v23; // [esp+38h] [ebp-84h]
  const char *v24; // [esp+3Ch] [ebp-80h]
  int v25; // [esp+40h] [ebp-7Ch]
  _BYTE *v26; // [esp+44h] [ebp-78h]
  int v27; // [esp+48h] [ebp-74h]
  _BYTE *v28; // [esp+7Ch] [ebp-40h] BYREF
  _BYTE *v29; // [esp+84h] [ebp-38h]
  int v30; // [esp+88h] [ebp-34h]
  char v31[8]; // [esp+94h] [ebp-28h] BYREF
  int v32[8]; // [esp+9Ch] [ebp-20h] BYREF

  result = a2;
  if ( a2 > 0 )
  {
    v4 = 0;
    do
    {
      if ( dl_addr(*(_DWORD *)(a1 + 4 * v4), &v28, v32, 0) && v28 && *v28 )
      {
        v22 = v28;
        v23 = strlen(v28);
        if ( v29 )
        {
          v5 = 7;
          v6 = 6;
          v24 = "(";
          v25 = 1;
          v26 = v29;
          v7 = strlen(v29);
          v8 = 8;
          v21 = 5;
          v20 = 4;
          v27 = v7;
          v17 = v30;
          v9 = 3;
LABEL_7:
          v10 = *(_DWORD *)(a1 + 4 * v4);
          if ( v17 > v10 )
          {
            v11 = v17 - *(_DWORD *)(a1 + 4 * v4);
            (&v22)[2 * v9] = "-0x";
          }
          else
          {
            v11 = v10 - v17;
            (&v22)[2 * v9] = "+0x";
          }
          *(&v23 + 2 * v9) = 3;
          v18 = v8;
          v12 = itoa_word(v11, (char *)v32, 0x10u, 0);
          v13 = v18;
          (&v22)[2 * v20] = v12;
          *(&v23 + 2 * v20) = (char *)v32 - v12;
          (&v22)[2 * v21] = ")";
          *(&v23 + 2 * v21) = 1;
          goto LABEL_10;
        }
        v16 = *(_DWORD *)v32[0];
        if ( *(_DWORD *)v32[0] )
        {
          v24 = "(";
          v8 = 7;
          v5 = 6;
          v25 = 1;
          v6 = 5;
          v9 = 2;
          v17 = v16;
          v30 = v16;
          v21 = 4;
          v20 = 3;
          goto LABEL_7;
        }
        v13 = 3;
        v5 = 2;
        v6 = 1;
      }
      else
      {
        v13 = 2;
        v5 = 1;
        v6 = 0;
      }
LABEL_10:
      (&v22)[2 * v6] = "[0x";
      *(&v23 + 2 * v6) = 3;
      v14 = *(_DWORD *)(a1 + 4 * v4++);
      v19 = v13;
      v15 = itoa_word(v14, v31, 0x10u, 0);
      *(&v23 + 2 * v5) = v31 - v15;
      (&v22)[2 * v5] = v15;
      (&v22)[2 * v19] = "]\n";
      *(&v23 + 2 * v19) = 2;
      result = writev(v5, a3, (int)&v22);
    }
    while ( v4 != a2 );
  }
  return result;
}

//----- (08055970) --------------------------------------------------------
void dl_sysinfo_int80()
{
  __asm { int     80h; LINUX - sys_fork }
}

//----- (08055980) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __usercall dl_aux_init@<eax>(int result@<eax>)
{
  int v1; // ecx
  int *v2; // edx
  int v3; // esi
  int v4; // ecx
  int (*v5)(); // ebp
  int v6; // ecx
  int v7; // ebp
  int v8; // ebp
  int v9; // edi
  int v10; // edi
  int v11; // ecx
  int v12; // ebp
  int v13; // edi
  int v14; // edi
  int v15; // ecx
  int v16; // [esp+4h] [ebp-48h]
  int v17; // [esp+8h] [ebp-44h]
  int v18; // [esp+Ch] [ebp-40h]
  int v19; // [esp+10h] [ebp-3Ch]
  int v20; // [esp+14h] [ebp-38h]
  int (*v21)(); // [esp+18h] [ebp-34h]
  int v22; // [esp+1Ch] [ebp-30h]
  int v23; // [esp+20h] [ebp-2Ch]
  int v24; // [esp+24h] [ebp-28h]
  int v25; // [esp+28h] [ebp-24h]
  int v26; // [esp+2Ch] [ebp-20h]
  int v27; // [esp+30h] [ebp-1Ch]
  int v28; // [esp+34h] [ebp-18h]

  v1 = *(_DWORD *)result;
  if ( *(_DWORD *)result )
  {
    v24 = dl_clktck;
    v23 = dl_phdr;
    v22 = dl_phnum;
    v25 = dl_pagesize;
    v19 = dl_hwcap;
    v20 = dword_80F0BD4;
    v18 = dl_sysinfo_dso;
    v27 = _libc_enable_secure;
    v26 = _libc_enable_secure_decided;
    v2 = (int *)result;
    v21 = dl_sysinfo[0];
    v3 = 0;
    v28 = dl_random;
    v17 = 0;
    v16 = 0;
    while ( 2 )
    {
      switch ( v1 )
      {
        case 3:
          v15 = v2[1];
          v2 += 2;
          v23 = v15;
          v1 = *v2;
          if ( *v2 )
            continue;
          goto LABEL_6;
        case 5:
          v14 = v2[1];
          v2 += 2;
          v1 = *v2;
          v22 = v14;
          if ( *v2 )
            continue;
          goto LABEL_6;
        case 6:
          v25 = v2[1];
          goto LABEL_5;
        case 11:
          v13 = v2[1];
          v2 += 2;
          v3 |= 1u;
          v1 = *v2;
          v17 ^= v13;
          if ( *v2 )
            continue;
          goto LABEL_6;
        case 12:
          v12 = v2[1];
          v2 += 2;
          v3 |= 2u;
          v1 = *v2;
          v17 ^= v12;
          if ( *v2 )
            continue;
          goto LABEL_6;
        case 13:
          v11 = v2[1];
          v2 += 2;
          v3 |= 4u;
          v16 ^= v11;
          v1 = *v2;
          if ( *v2 )
            continue;
          goto LABEL_6;
        case 14:
          v10 = v2[1];
          v2 += 2;
          v3 |= 8u;
          v1 = *v2;
          v16 ^= v10;
          if ( *v2 )
            continue;
          goto LABEL_6;
        case 16:
          v9 = v2[1];
          v2 += 2;
          v1 = *v2;
          v19 = v9;
          v20 = 0;
          if ( *v2 )
            continue;
          goto LABEL_6;
        case 17:
          v8 = v2[1];
          v2 += 2;
          v1 = *v2;
          v24 = v8;
          if ( *v2 )
            continue;
          goto LABEL_6;
        case 23:
          v7 = v2[1];
          v2 += 2;
          v3 = -1;
          v1 = *v2;
          v27 = v7;
          v26 = 1;
          if ( *v2 )
            continue;
          goto LABEL_6;
        case 25:
          v6 = v2[1];
          v2 += 2;
          v28 = v6;
          v1 = *v2;
          if ( *v2 )
            continue;
          goto LABEL_6;
        case 32:
          v5 = (int (*)())v2[1];
          v2 += 2;
          v1 = *v2;
          v21 = v5;
          if ( *v2 )
            continue;
          goto LABEL_6;
        case 33:
          v4 = v2[1];
          v2 += 2;
          v18 = v4;
          v1 = *v2;
          if ( *v2 )
            continue;
          goto LABEL_6;
        default:
LABEL_5:
          v2 += 2;
          v1 = *v2;
          if ( *v2 )
            continue;
LABEL_6:
          dl_phdr = v23;
          dl_clktck = v24;
          dl_pagesize = v25;
          dl_phnum = v22;
          dword_80F0BD4 = v20;
          dl_hwcap = v19;
          result = v26;
          dl_sysinfo[0] = v21;
          dl_sysinfo_dso = v18;
          _libc_enable_secure = v27;
          _libc_enable_secure_decided = v26;
          dl_random = v28;
          if ( v3 == 15 )
          {
            result = v17 != 0 || v16 != 0;
            _libc_enable_secure = result;
            _libc_enable_secure_decided = 1;
          }
          break;
      }
      break;
    }
  }
  return result;
}
// 8055AA5: write access to const memory at 80EEFC8 has been detected
// 8055AB0: write access to const memory at 80EEFBC has been detected
// 8055AC8: write access to const memory at 80EEFC8 has been detected
// 80EEFBC: using guessed type int dl_random;
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80EF5A4: using guessed type int (*dl_sysinfo[2])();
// 80EF5B8: using guessed type int dl_pagesize;
// 80F0BD0: using guessed type int dl_hwcap;
// 80F0BD4: using guessed type int dword_80F0BD4;
// 80F11BC: using guessed type int dl_phdr;
// 80F11CC: using guessed type int dl_clktck;
// 80F11D4: using guessed type int dl_sysinfo_dso;
// 80F11E0: using guessed type int dl_phnum;
// 80F124C: using guessed type int _libc_enable_secure_decided;

//----- (08055CA0) --------------------------------------------------------
char *__usercall dl_non_dynamic_init@<eax>(long double a1@<st0>)
{
  _BYTE *v1; // eax
  _BYTE *v2; // eax
  _BYTE *v3; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  int v7; // eax
  const char *v8; // edx
  char *v9; // ebx
  char *v10; // esi
  char v11; // di
  int v12; // ebp
  int v13; // ebx
  unsigned int v14; // eax
  char *result; // eax
  int v16; // ecx
  int v17; // edx
  char *v18; // [esp+1Ch] [ebp-20h] BYREF

  dl_cpuclock_offset = __rdtsc();
  if ( !dl_pagesize )
    dl_pagesize = getpagesize();
  v1 = (_BYTE *)getenv("LD_WARN");
  if ( !v1 )
    v1 = &unk_80C86D9;
  dl_verbose = *v1 != 0;
  v2 = (_BYTE *)getenv("LD_LIBRARY_PATH");
  dl_init_paths(v2, a1);
  dl_init_all_dirs = dl_all_dirs;
  v3 = (_BYTE *)getenv("LD_BIND_NOW");
  if ( !v3 )
    v3 = &unk_80C86D9;
  dl_lazy = *v3 == 0;
  v4 = (_BYTE *)getenv("LD_BIND_NOT");
  if ( !v4 )
    v4 = &unk_80C86D9;
  dl_bind_not = *v4 != 0;
  v5 = (_BYTE *)getenv("LD_DYNAMIC_WEAK");
  if ( !v5 )
    v5 = &unk_80C86D9;
  dl_dynamic_weak = *v5 == 0;
  v6 = (_BYTE *)getenv("LD_PROFILE_OUTPUT");
  dl_profile_output = (int)v6;
  if ( v6 && *v6 )
  {
    v7 = _libc_enable_secure;
  }
  else
  {
    v7 = _libc_enable_secure;
    v8 = "/var/tmp";
    if ( _libc_enable_secure )
      v8 = "/var/profile";
    dl_profile_output = (int)v8;
  }
  if ( v7 )
  {
    v9 = "GCONV_PATH";
    do
    {
      unsetenv(v9);
      v9 = (char *)(rawmemchr(v9, 0) + 1);
    }
    while ( v9 < "LD_WARN" );
    if ( access((int)"/etc/suid-debug", 0) )
      unsetenv("MALLOC_CHECK_");
  }
  if ( dl_platform && !*dl_platform )
    dl_platform = 0;
  v10 = (char *)getenv("LD_ASSUME_KERNEL");
  if ( v10 )
  {
    v11 = 16;
    v12 = 0;
    v13 = 0;
    while ( 1 )
    {
      v14 = _strtoul_internal(v10, &v18, 0, 0);
      if ( v14 > 0xFE || v10 == v18 )
        break;
      if ( v13 == 2 )
      {
        v12 |= v14 << v11;
        if ( !*v18 )
          goto LABEL_31;
      }
      else
      {
        if ( !*v18 )
        {
          v12 |= v14 << (-8 * v13 + 16);
          if ( !v12 )
            break;
LABEL_32:
          dl_osversion = v12;
          break;
        }
        if ( *v18 != 46 )
          break;
        v12 |= v14 << v11;
      }
      ++v13;
      v11 -= 8;
      v10 = v18 + 1;
      if ( v13 == 3 )
      {
LABEL_31:
        if ( !v12 )
          break;
        goto LABEL_32;
      }
    }
  }
  result = dl_platform;
  if ( dl_platform )
  {
    result = (char *)strlen(dl_platform);
    dl_platformlen = (int)result;
  }
  v16 = dl_phdr;
  if ( dl_phdr && dl_phnum )
  {
    v17 = 0;
    result = (char *)(dl_phdr + 32);
    if ( *(_DWORD *)dl_phdr == 1685382481 )
    {
LABEL_48:
      result = *(char **)(v16 + 24);
      dl_stack_flags = (int)result;
    }
    else
    {
      while ( ++v17 != dl_phnum )
      {
        v16 = (int)result;
        result += 32;
        if ( *((_DWORD *)result - 8) == 1685382481 )
          goto LABEL_48;
      }
    }
  }
  return result;
}
// 8048230: using guessed type int __cdecl rawmemchr(_DWORD, _DWORD);
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80EF5AC: using guessed type int dl_stack_flags;
// 80EF5B8: using guessed type int dl_pagesize;
// 80F1180: using guessed type int dl_profile_output;
// 80F118C: using guessed type int dl_platformlen;
// 80F11A8: using guessed type __int64 dl_cpuclock_offset;
// 80F11B0: using guessed type int dl_bind_not;
// 80F11B8: using guessed type int dl_lazy;
// 80F11BC: using guessed type int dl_phdr;
// 80F11D0: using guessed type int dl_dynamic_weak;
// 80F11D8: using guessed type int dl_init_all_dirs;
// 80F11DC: using guessed type int dl_verbose;
// 80F11E0: using guessed type int dl_phnum;
// 80F11EC: using guessed type int dl_all_dirs;
// 80F11F0: using guessed type int dl_osversion;

//----- (08055F50) --------------------------------------------------------
int *__thiscall dl_important_hwcaps(_DWORD *this, int a2)
{
  int *result; // eax

  result_8500 = (int)&buf_8501;
  result = &result_8500;
  dword_80F0BDC = 0;
  *this = 1;
  return result;
}
// 80F0BD8: using guessed type int result_8500;
// 80F0BDC: using guessed type int dword_80F0BDC;

//----- (08055F80) --------------------------------------------------------
int __usercall dl_addr_inside_object@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // edx
  int v3; // ecx
  int v4; // ebx
  _DWORD *v5; // esi

  v2 = a2 - *(_DWORD *)a1;
  v3 = *(unsigned __int16 *)(a1 + 344) - 1;
  v4 = 32 * v3;
  while ( v3 != -1 )
  {
    v5 = (_DWORD *)(v4 + *(_DWORD *)(a1 + 336));
    if ( *v5 == 1 && (unsigned int)(v2 - v5[2]) < v5[5] )
      return 1;
    --v3;
    v4 -= 32;
  }
  return 0;
}

//----- (08055FD0) --------------------------------------------------------
int __userpurge dl_addr@<eax>(unsigned int a1@<eax>, _DWORD *a2@<edx>, int *a3@<ecx>, _DWORD *a4)
{
  int v5; // esi
  int *v6; // ebp
  int v7; // esi
  unsigned int v8; // edi
  _BYTE *v10; // eax
  unsigned int v11; // eax
  int v12; // edi
  int v13; // eax
  int *v14; // edx
  _WORD *v15; // eax
  _DWORD *v16; // ebp
  unsigned int v17; // ebx
  int v18; // ecx
  int v19; // ecx
  int v20; // eax
  int v21; // edx
  unsigned int v22; // edi
  __int16 v23; // cx
  unsigned int v24; // edx
  unsigned int v25; // ebp
  int v26; // ecx
  _DWORD *v27; // ecx
  int v28; // [esp+18h] [ebp-44h]
  unsigned int v29; // [esp+18h] [ebp-44h]
  int v30; // [esp+1Ch] [ebp-40h]
  _DWORD *v31; // [esp+20h] [ebp-3Ch]
  unsigned int v32; // [esp+2Ch] [ebp-30h]
  unsigned int v34; // [esp+34h] [ebp-28h]
  int v36; // [esp+3Ch] [ebp-20h]

  v5 = 0;
  v30 = dl_nns;
  if ( !dl_nns )
    return v5;
  v6 = dl_ns;
  v28 = 0;
  while ( 1 )
  {
    v7 = *v6;
    if ( *v6 )
      break;
LABEL_9:
    ++v28;
    v6 += 19;
    if ( v28 == v30 )
      return 0;
  }
  while ( 1 )
  {
    v8 = *(_DWORD *)(v7 + 428);
    if ( a1 >= v8 && a1 < *(_DWORD *)(v7 + 432) && ((*(_BYTE *)(v7 + 405) & 0x40) != 0 || dl_addr_inside_object(v7, a1)) )
      break;
    v7 = *(_DWORD *)(v7 + 12);
    if ( !v7 )
      goto LABEL_9;
  }
  v10 = *(_BYTE **)(v7 + 4);
  *a2 = v10;
  a2[1] = v8;
  if ( !*v10 && (*(_BYTE *)(v7 + 404) & 3) == 0 )
    *a2 = program_invocation_short_name;
  v11 = *(_DWORD *)(*(_DWORD *)(v7 + 56) + 4);
  v36 = *(_DWORD *)(*(_DWORD *)(v7 + 52) + 4);
  v32 = v11;
  v34 = *(_DWORD *)(*(_DWORD *)(v7 + 72) + 4);
  if ( *(_DWORD *)(v7 + 332) )
  {
    v31 = 0;
    if ( *(_DWORD *)(v7 + 376) )
    {
      v29 = a1;
      v12 = 0;
      while ( 1 )
      {
        v13 = *(_DWORD *)(*(_DWORD *)(v7 + 392) + 4 * v12);
        if ( v13 )
          break;
LABEL_33:
        if ( ++v12 == *(_DWORD *)(v7 + 376) )
          goto LABEL_34;
      }
      v14 = (int *)(*(_DWORD *)(v7 + 396) + 4 * v13);
      v15 = (_WORD *)(v32 + 16 * v13 + 14);
      while ( 1 )
      {
        v16 = v15 - 7;
        if ( (*v15 || *(_DWORD *)(v15 - 5)) && (*(_BYTE *)(v15 - 1) & 0xF) != 6 )
        {
          v17 = *(_DWORD *)v7 + *(_DWORD *)(v15 - 5);
          if ( v29 >= v17 )
          {
            if ( !*v15 || (v18 = *(_DWORD *)(v15 - 3)) == 0 )
            {
              if ( v29 == v17 )
                goto LABEL_27;
              v18 = *(_DWORD *)(v15 - 3);
            }
            if ( v29 < v18 + v17 )
            {
LABEL_27:
              if ( !v31 || *(_DWORD *)(v15 - 5) > v31[1] )
              {
                if ( v34 <= *(_DWORD *)(v15 - 7) )
                  v16 = v31;
                v31 = v16;
              }
            }
          }
        }
        v19 = *v14;
        v15 += 8;
        ++v14;
        if ( (v19 & 1) != 0 )
          goto LABEL_33;
      }
    }
    goto LABEL_34;
  }
  v21 = *(_DWORD *)(v7 + 48);
  v22 = *(_DWORD *)(*(_DWORD *)(v7 + 52) + 4);
  if ( v21 )
    v22 = v11 + 16 * *(_DWORD *)(*(_DWORD *)(v21 + 4) + 4);
  v31 = 0;
  while ( v11 < v22 )
  {
    if ( (unsigned __int8)((*(_BYTE *)(v11 + 12) >> 4) - 1) <= 1u && (*(_BYTE *)(v11 + 12) & 0xF) != 6 )
    {
      v23 = *(_WORD *)(v11 + 14);
      v24 = *(_DWORD *)(v11 + 4);
      if ( v23 || v24 )
      {
        v25 = v24 + *(_DWORD *)v7;
        if ( a1 >= v25 )
        {
          if ( !v23 || (v26 = *(_DWORD *)(v11 + 8)) == 0 )
          {
            if ( a1 == v25 )
            {
LABEL_53:
              if ( !v31 || v24 > v31[1] )
              {
                v27 = v31;
                if ( v34 > *(_DWORD *)v11 )
                  v27 = (_DWORD *)v11;
                v31 = v27;
              }
              goto LABEL_44;
            }
            v26 = *(_DWORD *)(v11 + 8);
          }
          if ( a1 < v25 + v26 )
            goto LABEL_53;
        }
      }
    }
LABEL_44:
    v11 += 16;
  }
LABEL_34:
  if ( a3 )
    *a3 = v7;
  if ( a4 )
    *a4 = v31;
  if ( v31 )
  {
    a2[2] = *v31 + v36;
    v20 = *(_DWORD *)v7 + v31[1];
    v5 = 1;
    a2[3] = v20;
  }
  else
  {
    v5 = 1;
    a2[2] = 0;
    a2[3] = 0;
  }
  return v5;
}
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80F11C0: using guessed type int dl_nns;
// 80F1200: using guessed type int dl_ns[];

//----- (08056300) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __fastcall _libc_init_secure(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // ecx
  int v4; // ecx
  _BOOL4 v5; // edx
  int v6; // ebx
  int v7; // ecx

  result = _libc_enable_secure_decided;
  if ( !_libc_enable_secure_decided )
  {
    v2 = geteuid(a1);
    result = getuid(v3);
    v5 = 1;
    if ( v2 == result )
    {
      v6 = getegid(v4);
      result = getgid(v7);
      v5 = v6 != result;
    }
    _libc_enable_secure = v5;
  }
  return result;
}
// 805632D: write access to const memory at 80EEFC8 has been detected
// 805631F: variable 'v3' is possibly undefined
// 8056338: variable 'v4' is possibly undefined
// 805633F: variable 'v7' is possibly undefined
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80F124C: using guessed type int _libc_enable_secure_decided;

//----- (08056350) --------------------------------------------------------
int __fastcall dl_discover_osversion(int a1)
{
  int v1; // edi
  char v2; // dl
  int v3; // ebx
  char *v4; // ecx
  int v5; // ebx
  int v7; // eax
  int v8; // esi
  int v9; // edi
  int v10; // eax
  int v11; // [esp+1Ch] [ebp-90h]
  char v12; // [esp+ACh] [ebp+0h] BYREF
  char v13; // [esp+ADh] [ebp+1h] BYREF
  _BYTE v14[88]; // [esp+1B0h] [ebp+104h] BYREF

  if ( uname(a1) )
  {
    v5 = -1;
    v7 = open((int)&v12, (int)"/proc/sys/kernel/osrelease", 0);
    v8 = v7;
    if ( v7 < 0 )
      return v5;
    v9 = read((int)v14, v7, (int)v14);
    close((int)v14, v8);
    if ( v9 <= 0 )
      return v5;
    v10 = 63;
    if ( v9 <= 63 )
      v10 = v9;
    v14[v10] = 0;
  }
  v1 = 0;
  v11 = 0;
  while ( (unsigned __int8)(v12 - 48) <= 9u )
  {
    v2 = v13;
    v3 = v12 - 48;
    v4 = &v13;
    if ( (unsigned __int8)(v13 - 48) <= 9u )
    {
      do
      {
        ++v4;
        v3 = v2 + 10 * v3 - 48;
        v2 = *v4;
      }
      while ( (unsigned __int8)(*v4 - 48) <= 9u );
    }
    ++v1;
    v11 = v3 | (v11 << 8);
    if ( v2 != 46 )
    {
      if ( v1 == 3 )
        return v11;
      break;
    }
    if ( v1 == 3 )
      return v11;
  }
  v11 <<= 8 * (3 - v1);
  return v11;
}

//----- (08056460) --------------------------------------------------------
int __usercall _libc_init_first@<eax>(long double a1@<st0>, int a2, const char **a3, char **a4)
{
  int v4; // ecx

  _libc_multiple_libcs = 0;
  _setfpucw(_fpu_control);
  _libc_argc = a2;
  _libc_argv = (int)a3;
  environ = a4;
  _libc_init_secure(v4);
  dl_non_dynamic_init(a1);
  _init_misc(a2, a3);
  return _ctype_init();
}
// 80564B8: variable 'v4' is possibly undefined
// 80EF5C4: using guessed type int _libc_multiple_libcs;
// 80EF5D0: using guessed type __int16 _fpu_control;
// 80F1250: using guessed type int _libc_argc;
// 80F1254: using guessed type int _libc_argv;

//----- (08056500) --------------------------------------------------------
void __fastcall __noreturn dl_start(int a1, int a2)
{
  abort(a1, a2);
}
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);

//----- (08056510) --------------------------------------------------------
int __usercall _syscall_error@<eax>(int a1@<eax>)
{
  __writegsdword(0xFFFFFFE8, -a1);
  return -1;
}

//----- (08056520) --------------------------------------------------------
unsigned int _init_cpu_features()
{
  unsigned int result; // eax
  int v5; // esi
  int v6; // ebp
  int v7; // edi
  int v25; // edx
  int v26; // ecx
  int v27; // ebx
  char v28; // cl
  bool v29; // zf
  int v30; // ecx
  int v31; // [esp+0h] [ebp-18h]
  int v32; // [esp+4h] [ebp-14h]

  _EAX = 0;
  __asm { cpuid }
  dword_80F1264 = result;
  if ( _ECX == 1818588270 && _EBX == 1970169159 && _EDX == 1231384169 )
  {
    _EAX = 1;
    __asm { cpuid }
    dword_80F1274 = _EDX;
    v25 = dword_80F1290;
    v32 = _ECX;
    v7 = (result >> 8) & 0xF;
    dword_80F1270 = _ECX;
    v6 = (unsigned __int8)result >> 4;
    dword_80F126C = _EBX;
    v26 = (result >> 12) & 0xF0;
    v27 = dword_80F1290 | 8;
    dword_80F1268 = result;
    dword_80F1290 |= 8u;
    if ( v7 == 15 )
    {
      result >>= 20;
      v6 += v26;
      v5 = v32;
      v7 = (unsigned __int8)result + 15;
      v31 = 1;
      goto LABEL_6;
    }
    v5 = v32;
    if ( v7 != 6 )
      goto LABEL_23;
    v6 += v26;
    v28 = v6 - 26;
    if ( (unsigned int)(v6 - 26) <= 0x15 )
    {
      result = 1 << v28;
      v29 = ((1 << v28) & 0x340831) == 0;
      v30 = 1 << v28;
      if ( !v29 )
      {
LABEL_27:
        dword_80F1290 = v27 | 0x33;
LABEL_23:
        v31 = 1;
        goto LABEL_6;
      }
      if ( (v30 & 0x1004) != 0 )
      {
        dword_80F1290 = v25 | 0xC;
        v31 = 1;
        goto LABEL_6;
      }
    }
    v31 = 1;
    if ( (v32 & 0x10000000) == 0 )
      goto LABEL_6;
    goto LABEL_27;
  }
  if ( _ECX == 1145913699 && _EBX == 1752462657 && _EDX == 1769238117 )
  {
    _EAX = 1;
    __asm { cpuid }
    v5 = _ECX;
    v7 = (_EAX >> 8) & 0xF;
    v6 = (unsigned __int8)_EAX >> 4;
    dword_80F1268 = _EAX;
    dword_80F126C = _EBX;
    dword_80F1270 = _ECX;
    dword_80F1274 = _EDX;
    if ( (_ECX & 0x200) != 0 )
      dword_80F1290 |= 8u;
    _EAX = 0x80000000;
    __asm { cpuid }
    v31 = 2;
    if ( result > 0x80000000 )
    {
      _EAX = -2147483647;
      v5 = dword_80F1270;
      __asm { cpuid }
      dword_80F1278 = result;
      dword_80F127C = _EBX;
      dword_80F1280 = _ECX;
      dword_80F1284 = _EDX;
    }
  }
  else
  {
    v5 = dword_80F1270;
    v6 = 0;
    v7 = 0;
    v31 = 3;
  }
LABEL_6:
  if ( (v5 & 0x8000000) != 0 )
  {
    __asm { xgetbv }
    result &= 6u;
    if ( result == 6 )
    {
      if ( (v5 & 0x10000000) != 0 )
        dword_80F1290 |= 0x40u;
      if ( (v5 & 0x1000) != 0 )
        dword_80F1290 |= 0x80u;
      if ( (dword_80F1280 & 0x10000) != 0 )
        dword_80F1290 |= 0x100u;
    }
  }
  dword_80F1288 = v7;
  dword_80F128C = v6;
  _cpu_features = v31;
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1264: using guessed type int dword_80F1264;
// 80F1268: using guessed type int dword_80F1268;
// 80F126C: using guessed type int dword_80F126C;
// 80F1270: using guessed type int dword_80F1270;
// 80F1274: using guessed type int dword_80F1274;
// 80F1278: using guessed type int dword_80F1278;
// 80F127C: using guessed type int dword_80F127C;
// 80F1280: using guessed type int dword_80F1280;
// 80F1284: using guessed type int dword_80F1284;
// 80F1288: using guessed type int dword_80F1288;
// 80F128C: using guessed type int dword_80F128C;
// 80F1290: using guessed type int dword_80F1290;

//----- (08056770) --------------------------------------------------------
int *_get_cpu_features()
{
  if ( !_cpu_features )
    _init_cpu_features();
  return &_cpu_features;
}
// 80F1260: using guessed type int _cpu_features;

//----- (08056790) --------------------------------------------------------
void __usercall __noreturn _assert_fail_base(
        int a1@<ebp>,
        long double a2@<st0>,
        int a3,
        int a4,
        int a5,
        int a6,
        void *a7)
{
  void *v7; // ebx
  char *v8; // ecx
  char *v9; // eax
  unsigned int v10; // eax
  __int32 v11; // ebx
  int *v12; // ebx
  int v13; // edx
  int v14; // ecx
  char *src; // [esp+38h] [ebp-14h] BYREF
  int v16[4]; // [esp+3Ch] [ebp-10h] BYREF

  v7 = a7;
  v8 = ": ";
  if ( !a7 )
  {
    v8 = (char *)&unk_80C86D9;
    v7 = &unk_80C86D9;
  }
  v9 = ": ";
  if ( !*(_BYTE *)program_invocation_short_name )
    v9 = (char *)&unk_80C86D9;
  if ( asprintf(a2, &src, a3, program_invocation_short_name, v9, a5, a6, v7, v8, a4, v16) < 0 )
  {
    write(a1, 2, (int)"Unexpected error.\n", 18);
  }
  else
  {
    _fxprintf(0, "%s", src);
    fflush((_DWORD *)stderr);
    v16[0] = -dl_pagesize & (dl_pagesize + v16[0]);
    v10 = mmap(0, v16[0], 3, 34, -1, 0);
    v11 = v10;
    if ( v10 != -1 )
    {
      *(_DWORD *)v10 = v16[0];
      strcpy((char *)(v10 + 4), src);
      v12 = (int *)_InterlockedExchange(&_abort_msg, v11);
      if ( v12 )
        munmap((int)v12, *v12);
    }
    free(src);
  }
  abort(v14, v13);
}
// 80568D6: variable 'v14' is possibly undefined
// 80568D6: variable 'v13' is possibly undefined
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);
// 80665E0: using guessed type _DWORD _fxprintf(_DWORD, const char *, ...);
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80EF5B8: using guessed type int dl_pagesize;
// 80F0CA4: using guessed type int _abort_msg;
// 8056790: using guessed type int var_10[4];

//----- (08056910) --------------------------------------------------------
void __usercall __noreturn _assert_fail(int a1@<ebp>, long double a2@<st0>, int a3, int a4, int a5, void *a6)
{
  char *v6; // eax

  v6 = dcgettext(a2, "libc", "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", 5);
  _assert_fail_base(a1, a2, (int)v6, a3, a4, a5, a6);
}

//----- (08056960) --------------------------------------------------------
unsigned int _ctype_b_loc()
{
  return __readgsdword(0) - 8;
}

//----- (08056970) --------------------------------------------------------
unsigned int _ctype_toupper_loc()
{
  return __readgsdword(0) - 16;
}

//----- (08056980) --------------------------------------------------------
unsigned int _ctype_tolower_loc()
{
  return __readgsdword(0) - 12;
}

//----- (08056990) --------------------------------------------------------
int _ctype_init()
{
  unsigned int v0; // eax
  int v1; // edx
  int result; // eax

  v0 = __readgsdword(0xFFFFFFDC);
  __writegsdword(0xFFFFFFF8, *(_DWORD *)(*(_DWORD *)v0 + 36) + 256);
  __writegsdword(0xFFFFFFF0, *(_DWORD *)(*(_DWORD *)v0 + 40) + 512);
  v1 = *(_DWORD *)(*(_DWORD *)v0 + 48);
  result = -12;
  __writegsdword(0xFFFFFFF4, v1 + 512);
  return result;
}

//----- (080569E0) --------------------------------------------------------
char *__usercall dcgettext@<eax>(long double a1@<st0>, char *s1, char *a3, int a4)
{
  return _dcigettext(a1, s1, a3, 0, 0, 0, a4);
}

//----- (08056A20) --------------------------------------------------------
int __usercall plural_eval@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int *v3; // ebx
  int v4; // eax
  bool v6; // cc
  int v8; // eax
  int v9; // ecx
  int v10; // edi
  unsigned int v11; // ebp
  int v12; // eax
  int v13; // edx
  unsigned int v14; // eax

  v3 = a1;
  v4 = *a1;
  v6 = v4 <= 1;
  if ( v4 == 1 )
    return plural_eval(a3, a2) == 0;
  while ( 1 )
  {
    if ( v6 )
    {
      if ( v4 )
        return 0;
      v12 = v3[1];
      if ( v12 )
      {
        if ( v12 != 1 )
          return 0;
        return v3[2];
      }
      return a2;
    }
    if ( v4 == 2 )
      break;
    if ( v4 != 3 )
      return 0;
    v3 = (int *)v3[-(plural_eval(a3, a2) != 0) + 4];
    v4 = *v3;
    v6 = *v3 <= 1;
    if ( *v3 == 1 )
      return plural_eval(a3, a2) == 0;
  }
  v8 = plural_eval(a3, a2);
  v10 = v3[1];
  v11 = v8;
  if ( v10 == 15 )
  {
    return v8 || plural_eval(v9, a2) != 0;
  }
  else
  {
    if ( v10 == 14 )
    {
      if ( v8 )
        return plural_eval(v9, a2) != 0;
      return 0;
    }
    v13 = a2;
    a2 = 0;
    v14 = plural_eval(v9, v13);
    switch ( v10 )
    {
      case 3:
        a2 = v11 * v14;
        break;
      case 4:
        a2 = v11 / v14;
        break;
      case 5:
        a2 = v11 % v14;
        break;
      case 6:
        a2 = v14 + v11;
        break;
      case 7:
        a2 = v11 - v14;
        break;
      case 8:
        a2 = v11 < v14;
        break;
      case 9:
        a2 = v11 > v14;
        break;
      case 10:
        a2 = v11 <= v14;
        break;
      case 11:
        a2 = v11 >= v14;
        break;
      case 12:
        a2 = v11 == v14;
        break;
      case 13:
        a2 = v11 != v14;
        break;
      default:
        return a2;
    }
  }
  return a2;
}
// 8056A75: variable 'a3' is possibly undefined
// 8056A96: variable 'v9' is possibly undefined

//----- (08056BF0) --------------------------------------------------------
unsigned int __userpurge plural_lookup@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  int v5; // esi
  unsigned int v6; // edi
  unsigned int result; // eax

  v5 = *(_DWORD *)(a1 + 8);
  v6 = plural_eval(*(int **)(v5 + 96), a2, a3);
  if ( v6 >= *(_DWORD *)(v5 + 100) )
    v6 = 0;
  result = a3;
  while ( v6 )
  {
    --v6;
    result = rawmemchr(result, 0) + 1;
    if ( result >= a3 + a4 )
      return a3;
  }
  return result;
}
// 8048230: using guessed type int __cdecl rawmemchr(_DWORD, _DWORD);

//----- (08056C60) --------------------------------------------------------
int __cdecl transcmp(int a1, int a2)
{
  const char *s2; // edx
  const char *s1; // eax
  int result; // eax

  if ( *(_DWORD *)(a2 + 16) )
    s2 = (const char *)(a2 + 28);
  else
    s2 = *(const char **)(a2 + 28);
  if ( *(_DWORD *)(a1 + 16) )
    s1 = (const char *)(a1 + 28);
  else
    s1 = *(const char **)(a1 + 28);
  result = strcmp(s1, s2);
  if ( !result )
  {
    result = strcmp(*(const char **)a1, *(const char **)a2);
    if ( !result )
    {
      result = strcmp(*(const char **)(a1 + 8), *(const char **)(a2 + 8));
      if ( !result )
        return *(_DWORD *)(a1 + 4) - *(_DWORD *)(a2 + 4);
    }
  }
  return result;
}

//----- (08056CE0) --------------------------------------------------------
void __userpurge nl_find_msg(int *a1@<eax>, int a2@<edx>, char *a3@<ecx>, int a4, unsigned __int32 *a5)
{
  int v5; // ebx
  int *v6; // ebx
  int v7; // ecx
  unsigned int v8; // eax
  unsigned int v9; // esi
  unsigned int v10; // edi
  unsigned int v11; // edx
  int v12; // eax
  unsigned int v13; // esi
  unsigned int v14; // esi
  unsigned int v15; // edx
  unsigned int v16; // eax
  const char *v17; // eax
  unsigned int v18; // esi
  bool v19; // cf
  _DWORD *v20; // ecx
  int v21; // eax
  int v22; // ecx
  unsigned int *v23; // eax
  unsigned int v24; // edx
  int v25; // edi
  int v26; // eax
  const char **v27; // ebx
  int v28; // eax
  _DWORD *v29; // eax
  char *v30; // edx
  unsigned __int32 v31; // eax
  unsigned int v32; // edi
  unsigned __int32 v33; // ecx
  unsigned int v34; // eax
  int v35; // eax
  unsigned __int32 *v36; // eax
  char *v37; // edx
  unsigned __int32 v38; // eax
  int *v39; // eax
  char *v40; // ecx
  int v41; // eax
  unsigned int *v42; // ecx
  int v43; // esi
  const char **v44; // edi
  bool v46; // zf
  int v47; // ebx
  unsigned int v48; // edi
  unsigned __int32 v49; // esi
  int *v50; // eax
  int v51; // edx
  int v52; // eax
  _BYTE *v53; // eax
  _BYTE *v54; // edi
  int v55; // eax
  int v56; // ebx
  char *v57; // esi
  int v58; // eax
  int v59; // eax
  int v60; // edi
  char **v61; // eax
  const char *msg; // eax
  char *v63; // eax
  char *v64; // edx
  char *v65; // edi
  char v66; // al
  unsigned int i; // ecx
  void *v68; // esp
  unsigned int v69; // edi
  _WORD *v70; // eax
  char *v71; // edx
  char v72; // al
  void *v73; // esp
  char v74; // al
  unsigned int *v75; // edx
  char *v76; // ecx
  unsigned int v77; // edi
  unsigned int *j; // edx
  char v79; // al
  unsigned int *v80; // ecx
  void *v81; // esp
  char v82; // al
  unsigned int *v83; // edx
  int v84; // ecx
  int v85; // eax
  char *v86; // eax
  bool v88; // zf
  int v89; // ebx
  int v90; // eax
  char *v91; // [esp+4h] [ebp-64h]
  unsigned int v92; // [esp+10h] [ebp-58h] BYREF
  int *v93; // [esp+14h] [ebp-54h]
  int v94; // [esp+18h] [ebp-50h]
  int *v95; // [esp+1Ch] [ebp-4Ch]
  int *v96; // [esp+20h] [ebp-48h]
  const char *v97; // [esp+24h] [ebp-44h]
  unsigned int *v98; // [esp+28h] [ebp-40h]
  char *s1; // [esp+2Ch] [ebp-3Ch]
  char *v100; // [esp+30h] [ebp-38h]
  int v101; // [esp+34h] [ebp-34h]
  unsigned __int32 v102; // [esp+38h] [ebp-30h]
  char *s2; // [esp+3Ch] [ebp-2Ch]
  int v104; // [esp+44h] [ebp-24h] BYREF
  char *v105; // [esp+48h] [ebp-20h] BYREF
  int v106[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  v5 = a1[1];
  v95 = a1;
  v94 = a2;
  s1 = a3;
  if ( v5 <= 0 )
    nl_load_domain(a1, a2);
  v6 = (int *)v95[2];
  if ( !v6 )
  {
LABEL_24:
    s1 = 0;
    return;
  }
  v7 = v6[12];
  v100 = (char *)v6[5];
  if ( v7 )
  {
    v97 = (const char *)strlen(s1);
    v8 = _hash_string((unsigned __int8 *)s1);
    v9 = v6[11];
    v10 = v8 % v9;
    s2 = (char *)(v9 - 2);
    v11 = v8 % (v9 - 2);
    v12 = v6[12];
    v101 = v11 + 1;
    v98 = (unsigned int *)v6[13];
    v92 = v9 - (v11 + 1);
    v96 = (int *)(v11 + 1 - v9);
    while ( 1 )
    {
      v13 = *(_DWORD *)(v12 + 4 * v10);
      if ( v98 )
        v13 = _byteswap_ulong(v13);
      if ( !v13 )
        goto LABEL_24;
      v14 = v13 - 1;
      if ( (unsigned int)v100 <= v14 )
      {
        v20 = (_DWORD *)(v6[9] + 8 * (v14 - (_DWORD)v100));
        if ( (unsigned int)v97 >= *v20 )
          goto LABEL_18;
        v17 = (const char *)v20[1];
      }
      else
      {
        s2 = (char *)v6[3];
        v102 = v6[6];
        if ( s2 )
          v15 = _byteswap_ulong(*(_DWORD *)(v102 + 8 * v14));
        else
          v15 = *(_DWORD *)(v102 + 8 * v14);
        if ( v15 < (unsigned int)v97 )
          goto LABEL_18;
        v16 = *(_DWORD *)(v102 + 8 * v14 + 4);
        if ( s2 )
          v16 = _byteswap_ulong(v16);
        v17 = (const char *)(*v6 + v16);
      }
      if ( !strcmp(s1, v17) )
        goto LABEL_25;
      v12 = v6[12];
LABEL_18:
      v18 = v10 + v101;
      v19 = v10 < v92;
      v10 += (unsigned int)v96;
      if ( v19 )
        v10 = v18;
    }
  }
  v32 = 0;
  s2 = v100;
  while ( 1 )
  {
    if ( (unsigned int)s2 <= v32 )
      goto LABEL_24;
    v33 = v6[3];
    v101 = *v6;
    v102 = v33;
    while ( 1 )
    {
      v14 = (unsigned int)&s2[v32] >> 1;
      v34 = *(_DWORD *)(v6[6] + 8 * v14 + 4);
      if ( v102 )
        v34 = _byteswap_ulong(v34);
      v35 = strcmp(s1, (const char *)(v101 + v34));
      if ( v35 >= 0 )
        break;
      if ( v14 <= v32 )
        goto LABEL_24;
      s2 = (char *)((unsigned int)&s2[v32] >> 1);
    }
    if ( !v35 )
      break;
    v32 = v14 + 1;
  }
LABEL_25:
  if ( v14 >= (unsigned int)v100 )
  {
    v36 = (unsigned __int32 *)(v6[10] + 8 * (v14 - (_DWORD)v100));
    v37 = (char *)v36[1];
    v38 = *v36;
    s1 = v37;
    v102 = v38;
    goto LABEL_52;
  }
  v21 = 8 * v14;
  v22 = *v6;
  if ( !v6[3] )
  {
    v39 = (int *)(v6[7] + v21);
    v40 = (char *)(v39[1] + v22);
    v41 = *v39;
    s1 = v40;
    v102 = v41 + 1;
LABEL_52:
    if ( !a4 )
      goto LABEL_53;
    goto LABEL_28;
  }
  v23 = (unsigned int *)(v6[7] + v21);
  v24 = v23[1];
  v102 = _byteswap_ulong(*v23) + 1;
  s1 = (char *)(v22 + _byteswap_ulong(v24));
  if ( !a4 )
    goto LABEL_53;
LABEL_28:
  if ( !v94 || (s2 = *(char **)(v94 + 8)) == 0 )
  {
    if ( output_charset_cached_8903 )
    {
      s2 = (char *)output_charset_cache_8902;
    }
    else
    {
      v53 = (_BYTE *)getenv("OUTPUT_CHARSET");
      v54 = v53;
      if ( v53 && *v53 )
      {
        v93 = (int *)(strlen(v53) + 1);
        v86 = (char *)malloc(v93);
        s2 = v86;
        if ( v86 )
          memcpy(v86, v54, (unsigned int)v93);
        output_charset_cache_8902 = (int)s2;
      }
      else
      {
        s2 = (char *)output_charset_cache_8902;
      }
      output_charset_cached_8903 = 1;
    }
    if ( !s2 )
      s2 = *(char **)(*(_DWORD *)__readgsdword(0xFFFFFFDC) + 92);
  }
  v25 = v6[15];
  v101 = 0;
  if ( v25 )
  {
    v26 = v6[14] + 12 * v25 - 12;
    v98 = (unsigned int *)v6;
    v27 = (const char **)v26;
    do
    {
      --v25;
      if ( !strcmp(*v27, s2) )
      {
        v101 = (int)v27;
        v6 = (int *)v98;
        goto LABEL_35;
      }
      v27 -= 3;
    }
    while ( v25 );
    v6 = (int *)v98;
    v101 = 0;
  }
LABEL_35:
  if ( !v101 )
  {
    v101 = v6[15];
    if ( v101 )
    {
      v42 = (unsigned int *)v6[14];
      v97 = (const char *)v14;
      v96 = v6;
      v43 = v101;
      v98 = v42;
      v44 = (const char **)&v42[3 * v101 - 3];
      do
      {
        --v43;
        if ( !strcmp(*v44, s2) )
        {
          v14 = (unsigned int)v97;
          v6 = v96;
          v101 = (int)v44;
          goto LABEL_36;
        }
        v44 -= 3;
      }
      while ( v43 );
      v14 = (unsigned int)v97;
      v6 = v96;
    }
    else
    {
      v98 = (unsigned int *)v6[14];
    }
    realloc(v98, 4 * (3 * v101 + 3));
    v60 = v59;
    if ( !v59 || (v6[14] = v59, (s2 = strdup(s2)) == 0) )
    {
      s1 = (char *)-1;
      return;
    }
    v61 = (char **)(v60 + 12 * v101);
    *v61 = s2;
    v61[1] = (char *)-1;
    v101 = (int)v61;
    msg = (const char *)nl_find_msg(0, &v104);
    if ( msg )
    {
      v63 = strstr(msg, "charset=");
      v64 = v63;
      if ( v63 )
      {
        v65 = v63 + 8;
        v66 = v63[8];
        for ( i = 0; v66; v66 = v64[i + 8] )
        {
          if ( v66 == 32 )
            break;
          if ( v66 == 9 )
            break;
          if ( v66 == 10 )
            break;
          ++i;
        }
        v68 = alloca(i + 16);
        v98 = &v92;
        v91 = v65;
        v69 = 0;
        v70 = mempcpy(&v92, v91, i);
        v71 = s2;
        *(_BYTE *)v70 = 0;
        while ( 1 )
        {
          v72 = *v71;
          if ( !*v71 )
            break;
          ++v71;
          v69 += v72 == 47;
        }
        v73 = alloca(v71 - s2 + 26);
        v97 = (const char *)&v92;
        v74 = *s2;
        v75 = &v92;
        if ( *s2 )
        {
          v76 = s2;
          v96 = v6;
          do
          {
            ++v76;
            *(_BYTE *)v75 = dword_80D03C0[v74];
            v74 = *v76;
            v75 = (unsigned int *)((char *)v75 + 1);
          }
          while ( *v76 );
          v6 = v96;
        }
        if ( v69 <= 1 )
        {
          *(_BYTE *)v75 = 47;
          if ( v69 )
          {
            v75 = (unsigned int *)((char *)v75 + 1);
          }
          else
          {
            *((_BYTE *)v75 + 1) = 47;
            *(unsigned int *)((char *)v75 + 2) = 1312903764;
            *(unsigned int *)((char *)v75 + 6) = 1414089811;
            v75 = (unsigned int *)((char *)v75 + 10);
          }
        }
        *(_BYTE *)v75 = 0;
        v77 = 0;
        for ( j = v98; ; j = (unsigned int *)((char *)j + 1) )
        {
          v79 = *(_BYTE *)j;
          if ( !*(_BYTE *)j )
            break;
          v77 += v79 == 47;
        }
        v80 = v98;
        v81 = alloca((char *)j - (char *)v98 + 18);
        v82 = *(_BYTE *)v98;
        v83 = &v92;
        v96 = (int *)&v92;
        if ( v82 )
        {
          v98 = (unsigned int *)v6;
          do
          {
            v80 = (unsigned int *)((char *)v80 + 1);
            *(_BYTE *)v83 = dword_80D03C0[v82];
            v82 = *(_BYTE *)v80;
            v83 = (unsigned int *)((char *)v83 + 1);
          }
          while ( *(_BYTE *)v80 );
          v6 = (int *)v98;
        }
        if ( v77 <= 1 )
        {
          *(_BYTE *)v83 = 47;
          if ( v77 )
          {
            v83 = (unsigned int *)((char *)v83 + 1);
          }
          else
          {
            *((_BYTE *)v83 + 1) = 47;
            v83 = (unsigned int *)((char *)v83 + 2);
          }
        }
        v84 = v101;
        *(_BYTE *)v83 = 0;
        v85 = _gconv_open(v97, v96, (int **)(v84 + 4), 1);
        if ( v85 )
        {
          if ( v85 != -1 )
          {
            free(s2);
            s1 = 0;
            return;
          }
          *(_DWORD *)(v101 + 4) = -1;
        }
      }
    }
    *(_DWORD *)(v101 + 8) = 0;
    ++v6[15];
  }
LABEL_36:
  if ( *(_DWORD *)(v101 + 4) == -1 )
  {
LABEL_53:
    *a5 = v102;
    return;
  }
  v28 = *(_DWORD *)(v101 + 8);
  if ( v28 )
  {
LABEL_38:
    if ( v28 == -1 )
    {
      s1 = (char *)-1;
      return;
    }
    v29 = *(_DWORD **)(v28 + 4 * v14);
    if ( v29 )
    {
LABEL_40:
      v30 = (char *)(v29 + 1);
      v31 = *v29;
      s1 = v30;
      v102 = v31;
      goto LABEL_53;
    }
    _ECX = 1;
    v46 = __readgsdword(0xCu) == 0;
    if ( !v46 )
      __asm { lock }
    __asm { cmpxchg ds:lock_8842, ecx }
    if ( !v46 )
    {
      L_lock_1296(0, a4, (int)a5);
      return;
    }
    goto LABEL_68;
  }
  _ECX = 1;
  v88 = __readgsdword(0xCu) == 0;
  if ( !v88 )
    __asm { lock }
  __asm { cmpxchg ds:lock_8842, ecx }
  if ( !v88 )
  {
    L_lock_2131(0, a4, (int)a5);
    return;
  }
  if ( *(_DWORD *)(v101 + 8) )
  {
LABEL_143:
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --lock_8842 )
    {
      L_unlock_2138(a4, (int)a5);
      return;
    }
    v28 = *(_DWORD *)(v101 + 8);
    goto LABEL_38;
  }
  calloc((int)&v100[v6[8]], 4u);
  v89 = v101;
  *(_DWORD *)(v101 + 8) = v90;
  if ( !v90 )
  {
    *(_DWORD *)(v89 + 8) = -1;
    goto LABEL_143;
  }
LABEL_68:
  v47 = 0;
  v100 = (char *)v14;
  v48 = freemem_size_8855;
  v49 = v102;
  v105 = s1;
  for ( v106[0] = freemem_8854 + 4; ; v106[0] = (int)(v50 + 2) )
  {
    if ( v48 <= 3 )
    {
      if ( !v47 )
        goto LABEL_78;
      goto LABEL_70;
    }
    v52 = _gconv(*(_DWORD **)(v101 + 4), (int *)&v105, (unsigned int)&v105[v49], v106, v106[0] + v48 - 4, &v104);
    if ( v52 == 4 || !v52 )
      break;
    if ( v52 != 5 )
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --lock_8842 )
        L_unlock_1533(a4, (int)a5);
      else
        s1 = 0;
      return;
    }
    v105 = s1;
    if ( !v47 )
    {
LABEL_78:
      freemem_size_8855 = 4080;
      v50 = (int *)malloc(4080);
      if ( !v50 )
        goto LABEL_81;
      v51 = transmem_list;
      v48 = 4076;
      v47 = 1;
      goto LABEL_72;
    }
LABEL_70:
    ++v47;
    v93 = (int *)transmem_list;
    freemem_size_8855 = 4080 * v47;
    realloc((_BYTE *)transmem_list, 4080 * v47);
    if ( !v50 )
    {
      transmem_list = *v93;
      free(v93);
LABEL_81:
      freemem_8854 = 0;
      freemem_size_8855 = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --lock_8842 )
        L_unlock_1444(a4, (int)a5);
      else
        s1 = (char *)-1;
      return;
    }
    v51 = *v93;
    v48 = 4080 * v47 - 4;
LABEL_72:
    *v50 = v51;
    transmem_list = (int)v50;
    freemem_8854 = (int)(v50 + 1);
    freemem_size_8855 = v48;
  }
  v55 = freemem_8854;
  v56 = v101;
  v57 = v100;
  *(_DWORD *)freemem_8854 = v106[0] - freemem_8854 - 4;
  *(_DWORD *)(*(_DWORD *)(v56 + 8) + 4 * (_DWORD)v57) = v55;
  v58 = freemem_size_8855 + v55 - v106[0];
  freemem_8854 = (v58 & 3) + v106[0];
  freemem_size_8855 = v58 & 0xFFFFFFFC;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( !--lock_8842 )
  {
    v29 = *(_DWORD **)(*(_DWORD *)(v56 + 8) + 4 * (_DWORD)v57);
    goto LABEL_40;
  }
  L_unlock_1520(a4, (int)a5);
}
// 8057151: variable 'v50' is possibly undefined
// 805731D: variable 'v59' is possibly undefined
// 8057656: variable 'v90' is possibly undefined
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80D03C0: using guessed type _DWORD dword_80D03C0[256];
// 80F0C44: using guessed type int lock_8842;
// 80F0C48: using guessed type int freemem_8854;
// 80F0C4C: using guessed type int freemem_size_8855;
// 80F0C50: using guessed type int transmem_list;
// 80F0C54: using guessed type int output_charset_cached_8903;
// 80F0C58: using guessed type int output_charset_cache_8902;
// 8056CE0: using guessed type int var_1C[7];

//----- (08057670) --------------------------------------------------------
char *__usercall _dcigettext@<eax>(long double a1@<st0>, char *s1, char *a3, char *a4, int a5, int a6, unsigned int a7)
{
  char *v7; // edx
  _BYTE *v8; // esi
  int v9; // eax
  void *v10; // esp
  int *v11; // eax
  int v12; // ebx
  int v13; // eax
  char *v14; // edx
  bool v15; // zf
  unsigned int v16; // ebx
  int v17; // esi
  void *v18; // esp
  const char *v19; // ebx
  int v20; // eax
  int v21; // edi
  char *v22; // eax
  _BYTE *v23; // edi
  char *v24; // esi
  char *v25; // ebx
  void *v26; // esp
  int v27; // eax
  void *v28; // esp
  char v29; // al
  char *v30; // edx
  int *domain; // eax
  int v32; // esi
  int v33; // eax
  int v34; // edi
  int *v35; // eax
  int v36; // edx
  int **v37; // edx
  char *result; // eax
  int *v39; // eax
  int v40; // edi
  char *v41; // eax
  unsigned int v43; // ebx
  int v44; // eax
  _DWORD *v45; // eax
  _WORD *v46; // ebx
  _DWORD *v47; // edx
  char *v48; // ecx
  int v49; // eax
  _DWORD *v50; // eax
  char v51[4]; // [esp+10h] [ebp-78h] BYREF
  _DWORD *v52; // [esp+14h] [ebp-74h]
  char *v53; // [esp+18h] [ebp-70h]
  unsigned int v54; // [esp+1Ch] [ebp-6Ch]
  char *v55; // [esp+20h] [ebp-68h]
  int v56; // [esp+24h] [ebp-64h]
  char *src; // [esp+28h] [ebp-60h]
  int **v58; // [esp+2Ch] [ebp-5Ch]
  char *v59; // [esp+30h] [ebp-58h]
  char *v60; // [esp+34h] [ebp-54h]
  int v61; // [esp+38h] [ebp-50h]
  char *s; // [esp+3Ch] [ebp-4Ch]
  int v63[8]; // [esp+4Ch] [ebp-3Ch] BYREF
  unsigned __int32 v64[7]; // [esp+6Ch] [ebp-1Ch] BYREF
  char *s1a; // [esp+90h] [ebp+8h]

  if ( !a3 )
    return a3;
  if ( a7 > 0xC || a7 == 6 )
    goto LABEL_39;
  v7 = s1;
  v63[4] = 0;
  if ( !s1 )
    v7 = nl_current_default_domain[0];
  v63[7] = (int)a3;
  s1a = v7;
  v63[0] = (int)v7;
  v63[1] = a7;
  v8 = (_BYTE *)_current_locale_name(a7);
  v9 = strlen(v8);
  v10 = alloca(v9 + 16);
  src = memcpy(v51, v8, v9 + 1);
  v63[2] = (int)src;
  v58 = (int **)tfind((int)v63, &root, transcmp);
  if ( v58 )
  {
    v11 = *v58;
    if ( (*v58)[3] == nl_msg_cat_cntr )
    {
      if ( a5 )
        return (char *)plural_lookup(v11[4], a6, v11[5], v11[6]);
      else
        return (char *)v11[5];
    }
  }
  v61 = nl_domain_bindings;
  v54 = __readgsdword(0xFFFFFFE8);
  if ( nl_domain_bindings )
  {
    v12 = nl_domain_bindings;
    while ( 1 )
    {
      v13 = strcmp(s1a, (const char *)(v12 + 12));
      if ( !v13 )
        break;
      if ( v13 < 0 )
      {
        v61 = 0;
        v60 = "/usr/share/locale";
        goto LABEL_20;
      }
      v12 = *(_DWORD *)v12;
      if ( !v12 )
      {
        v61 = 0;
        v60 = "/usr/share/locale";
        goto LABEL_20;
      }
    }
    v61 = v12;
    if ( !v12 )
      goto LABEL_67;
    v14 = *(char **)(v12 + 4);
    v15 = *v14 == 47;
    v60 = v14;
    if ( !v15 )
    {
      v16 = 4098;
      v17 = strlen(v14) + 1;
      while ( 1 )
      {
        v18 = alloca(16 * ((v16 + v17 + 30) / 0x10));
        v60 = v51;
        __writegsdword(0xFFFFFFE8, 0);
        if ( getcwd(v51, v16) )
          break;
        if ( __readgsdword(0xFFFFFFE8) != 34 )
          goto LABEL_38;
        v16 += (v16 >> 1) + 32;
      }
      v19 = *(const char **)(v61 + 4);
      v20 = rawmemchr(v60, 0);
      *(_WORD *)v20 = 47;
      strcpy((char *)(v20 + 1), v19);
    }
  }
  else
  {
LABEL_67:
    v60 = "/usr/share/locale";
  }
LABEL_20:
  v21 = (unsigned __int8)nl_category_name_idxs[a7];
  v22 = (char *)getenv("LANGUAGE");
  v23 = (_BYTE *)(v21 + 135063264);
  v24 = v22;
  if ( v22 && *v22 )
  {
    v41 = (char *)_current_locale_name(a7);
    v25 = v41;
    if ( *v41 == 67 )
    {
      if ( v41[1] )
        v25 = v24;
    }
    else
    {
      v25 = v24;
    }
  }
  else
  {
    v25 = (char *)_current_locale_name(a7);
  }
  v56 = strlen(s1a);
  v26 = alloca(v56 + strlen(v23) + 20);
  v59 = v51;
  v27 = stpcpy(v51, v23);
  *(_WORD *)v27 = 47;
  *(_DWORD *)mempcpy((_BYTE *)(v27 + 1), s1a, v56) = 7302446;
  v28 = alloca(strlen(v25) + 16);
  s = v51;
  while ( 1 )
  {
    do
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v29 = *v25;
          if ( *v25 != 58 )
            break;
          ++v25;
        }
        v30 = s;
        if ( !v29 )
          break;
        do
        {
          ++v25;
          *v30 = v29;
          v29 = *v25;
          ++v30;
        }
        while ( *v25 != 58 && v29 );
        *v30 = 0;
        if ( !_libc_enable_secure || !strchr(s, 47) )
        {
          if ( *s != 67 )
            goto LABEL_28;
          goto LABEL_27;
        }
      }
      *s = 67;
      v30[1] = 0;
LABEL_27:
      if ( !s[1] )
        goto LABEL_38;
LABEL_28:
      if ( !strcmp(s, "POSIX") )
        goto LABEL_38;
      domain = nl_find_domain(v60, (int)s, v59, a1, v61);
      v32 = (int)domain;
    }
    while ( !domain );
    nl_find_msg(domain, v61, a3, 1, v64);
    if ( v33 )
      break;
    v39 = *(int **)(v32 + 16);
    if ( v39 )
    {
      v55 = v25;
      v40 = 0;
      do
      {
        nl_find_msg(v39, v61, a3, 1, v64);
        if ( v33 )
        {
          v32 = *(_DWORD *)(v32 + 4 * v40 + 16);
          goto LABEL_31;
        }
        ++v40;
        v39 = *(int **)(v32 + 4 * v40 + 16);
      }
      while ( v39 );
      v25 = v55;
    }
  }
LABEL_31:
  if ( v33 == -1 )
  {
LABEL_38:
    __writegsdword(0xFFFFFFE8, v54);
LABEL_39:
    if ( !a5 )
      return a3;
    result = a4;
    if ( a6 == 1 )
      return a3;
    return result;
  }
  v34 = v33;
  if ( v58 )
  {
    v35 = *v58;
    v36 = nl_msg_cat_cntr;
    v35[4] = v32;
    v35[3] = v36;
    v37 = v58;
    (*v58)[5] = v34;
    (*v37)[6] = v64[0];
  }
  else
  {
    v43 = strlen(a3) + 1;
    v44 = strlen(src);
    v45 = (_DWORD *)malloc(v43 + v56 + v44 + 30);
    if ( v45 )
    {
      v52 = v45;
      v46 = mempcpy((_BYTE *)v45 + 28, a3, v43);
      v53 = (char *)(v56 + 1);
      memcpy(v46, s1a, v56 + 1);
      v53 = &v53[(_DWORD)v46];
      strcpy(v53, src);
      v47 = v52;
      v48 = v53;
      *v52 = v46;
      v47[1] = a7;
      v49 = nl_msg_cat_cntr;
      v47[2] = v48;
      v47[4] = v32;
      v47[5] = v34;
      v47[3] = v49;
      v47[6] = v64[0];
      v52 = v47;
      v50 = tsearch((int)v47, &root, transcmp);
      if ( !v50 || v52 != (_DWORD *)*v50 )
        free(v52);
    }
  }
  __writegsdword(0xFFFFFFE8, v54);
  if ( a5 )
    return (char *)plural_lookup(v32, a6, v34, v64[0]);
  return (char *)v34;
}
// 80579AD: conditional instruction was optimized away because eax.4 is in (1..FFFFFFFE)
// 805799C: variable 'v33' is possibly undefined
// 80481F0: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 8048230: using guessed type int __cdecl rawmemchr(_DWORD, _DWORD);
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80EF5C8: using guessed type char *nl_current_default_domain[2];
// 80F0C40: using guessed type int root;
// 80F1294: using guessed type int nl_domain_bindings;
// 80F1298: using guessed type int nl_msg_cat_cntr;
// 8057670: using guessed type char anonymous_0[4];

//----- (08057D1F) --------------------------------------------------------
void __userpurge L_lock_1296(int a1@<eax>, int a2, int a3)
{
  _lll_lock_wait_private(a1, &lock_8842);
  JUMPOUT(0x80570FE);
}
// 8057D2A: control flows out of bounds to 80570FE
// 80F0C44: using guessed type int lock_8842;

//----- (08057D2F) --------------------------------------------------------
void __stdcall L_unlock_1444(int a1, int a2)
{
  _lll_unlock_wake_private(&lock_8842);
  JUMPOUT(0x805723C);
}
// 8057D3A: control flows out of bounds to 805723C
// 80F0C44: using guessed type int lock_8842;

//----- (08057D3F) --------------------------------------------------------
void __stdcall L_unlock_1520(int a1, int a2)
{
  _lll_unlock_wake_private(&lock_8842);
  JUMPOUT(0x80572CD);
}
// 8057D4A: control flows out of bounds to 80572CD
// 80F0C44: using guessed type int lock_8842;

//----- (08057D4F) --------------------------------------------------------
void __stdcall L_unlock_1533(int a1, int a2)
{
  _lll_unlock_wake_private(&lock_8842);
  JUMPOUT(0x80572F0);
}
// 8057D5A: control flows out of bounds to 80572F0
// 80F0C44: using guessed type int lock_8842;

//----- (08057D5F) --------------------------------------------------------
void __userpurge L_lock_2131(int a1@<eax>, int a2, int a3)
{
  _lll_lock_wait_private(a1, &lock_8842);
  JUMPOUT(0x80575D4);
}
// 8057D6A: control flows out of bounds to 80575D4
// 80F0C44: using guessed type int lock_8842;

//----- (08057D6F) --------------------------------------------------------
void __stdcall L_unlock_2138(int a1, int a2)
{
  _lll_unlock_wake_private(&lock_8842);
  JUMPOUT(0x80575F2);
}
// 8057D7A: control flows out of bounds to 80575F2
// 80F0C44: using guessed type int lock_8842;

//----- (08057D80) --------------------------------------------------------
int *__userpurge nl_find_domain@<eax>(_BYTE *a1@<eax>, int a2@<edx>, char *a3@<ecx>, long double a4@<st0>, int a5)
{
  int v6; // eax
  int *l10nflist; // esi
  int *v9; // eax
  int *v10; // ebx
  _BYTE *v11; // eax
  int v12; // eax
  void *v13; // esp
  int v14; // eax
  int *v15; // eax
  int *v16; // ebx
  char v17[4]; // [esp+30h] [ebp-48h] BYREF
  _BYTE *v18; // [esp+34h] [ebp-44h]
  char *v19; // [esp+38h] [ebp-40h]
  int v20; // [esp+3Ch] [ebp-3Ch]
  int v21; // [esp+4Ch] [ebp-2Ch] BYREF
  int v22; // [esp+50h] [ebp-28h] BYREF
  int v23; // [esp+54h] [ebp-24h] BYREF
  int v24; // [esp+58h] [ebp-20h] BYREF
  int v25; // [esp+5Ch] [ebp-1Ch] BYREF

  v20 = a2;
  v19 = a3;
  v6 = strlen(a1);
  l10nflist = (int *)nl_make_l10nflist(
                       (const char ***)&nl_loaded_domains,
                       a1,
                       v6 + 1,
                       0,
                       (_BYTE *)v20,
                       0,
                       0,
                       0,
                       0,
                       v19,
                       0);
  if ( l10nflist )
  {
    if ( l10nflist[1] <= 0 )
      nl_load_domain(l10nflist, a5);
    if ( !l10nflist[2] )
    {
      v9 = (int *)l10nflist[4];
      if ( v9 )
      {
        v10 = l10nflist;
        do
        {
          if ( v9[1] <= 0 )
            nl_load_domain(v9, a5);
          if ( *(_DWORD *)(v10[4] + 8) )
            break;
          ++v10;
          v9 = (int *)v10[4];
        }
        while ( v9 );
      }
    }
  }
  else
  {
    nl_expand_alias(a4, v20);
    if ( v11 )
    {
      v18 = v11;
      v12 = strlen(v11);
      v13 = alloca(v12 + 16);
      v20 = (int)memcpy(v17, v18, v12 + 1);
    }
    v20 = nl_explode_name((_BYTE *)v20, &v21, &v22, &v23, (const char **)&v24, (const char **)&v25);
    if ( v20 != -1 )
    {
      v14 = strlen(a1);
      l10nflist = (int *)nl_make_l10nflist(
                           (const char ***)&nl_loaded_domains,
                           a1,
                           v14 + 1,
                           v20,
                           (_BYTE *)v21,
                           (_BYTE *)v23,
                           (_BYTE *)v24,
                           (_BYTE *)v25,
                           (_BYTE *)v22,
                           v19,
                           1);
      if ( l10nflist )
      {
        if ( l10nflist[1] <= 0 )
          nl_load_domain(l10nflist, a5);
        if ( !l10nflist[2] )
        {
          v15 = (int *)l10nflist[4];
          if ( v15 )
          {
            v16 = l10nflist;
            do
            {
              if ( v15[1] <= 0 )
                nl_load_domain(v15, a5);
              if ( *(_DWORD *)(v16[4] + 8) )
                break;
              ++v16;
              v15 = (int *)v16[4];
            }
            while ( v15 );
          }
        }
      }
      if ( (v20 & 1) != 0 )
        free(v25);
    }
  }
  return l10nflist;
}
// 8057E8D: variable 'v11' is possibly undefined
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80F0C80: using guessed type int nl_loaded_domains;
// 8057D80: using guessed type char anonymous_0[4];

//----- (08057FF0) --------------------------------------------------------
void __usercall nl_load_domain(int *a1@<eax>, int a2@<edx>)
{
  int *v2; // esi
  unsigned int v3; // edx
  bool v5; // zf
  int v6; // ecx
  int v7; // edx
  int v8; // eax
  int v9; // edx
  int v10; // ebx
  int v11; // ecx
  int v12; // ecx
  int *v13; // edi
  int **v14; // eax
  _BYTE *v15; // edx
  int v16; // ebx
  int v17; // ecx
  _BOOL4 v18; // eax
  unsigned int v19; // edx
  int v20; // ecx
  int *v21; // eax
  int v22; // esi
  int v23; // ebx
  int v24; // edi
  signed int nocancel; // eax
  unsigned int v26; // ecx
  unsigned __int32 v27; // ecx
  unsigned int v28; // ecx
  unsigned int v29; // ecx
  unsigned __int32 v30; // edx
  char *v31; // edx
  void *v32; // esp
  int v33; // ecx
  int v34; // eax
  char *v35; // ebx
  int v36; // esi
  _BYTE *v37; // edx
  unsigned __int32 v38; // ecx
  char *v39; // ecx
  char *msg; // eax
  char v41; // cl
  char v42; // cl
  unsigned __int32 v43; // eax
  int v44; // eax
  int v45; // edi
  unsigned int v46; // ebx
  char *v47; // ebx
  bool v48; // al
  int v49; // esi
  unsigned int *i; // ebx
  unsigned int v51; // eax
  _BYTE *v52; // eax
  int v53; // ecx
  int v54; // edx
  int *v55; // ecx
  int v56; // edx
  unsigned int v57; // eax
  int v58; // esi
  int v59; // ebx
  unsigned int v60; // edx
  char *v61; // edx
  bool v62; // al
  char *j; // edx
  unsigned int v64; // eax
  _BYTE *v65; // esi
  unsigned int v66; // ebx
  unsigned int *v67; // ebx
  unsigned __int32 v68; // eax
  int v69; // eax
  unsigned int v71; // eax
  unsigned int *v72; // edx
  int *v73; // ecx
  int v74; // ebx
  int v75; // ebx
  int *v76; // ebx
  int v77; // esi
  int v78; // ecx
  unsigned int v79; // edx
  int v80; // eax
  int v81; // edi
  unsigned int v82; // edx
  unsigned int v83; // eax
  unsigned int v84; // edi
  unsigned int v85; // ecx
  unsigned int v86; // esi
  unsigned int v87; // edi
  bool v88; // cf
  unsigned int v89; // ebx
  int *v90; // edx
  int *v91; // edi
  unsigned int v92; // ecx
  int v93; // eax
  int v94; // edi
  int v95; // ecx
  int v96; // edx
  unsigned int *v97; // ebx
  _BYTE *v98; // edx
  unsigned __int32 v99; // edi
  int v100; // eax
  char v101; // cl
  _BYTE *v102; // [esp+0h] [ebp-F8h]
  int v103; // [esp+20h] [ebp-D8h] BYREF
  int *v104; // [esp+24h] [ebp-D4h]
  int v105; // [esp+28h] [ebp-D0h]
  int *v106; // [esp+2Ch] [ebp-CCh]
  int *v107; // [esp+30h] [ebp-C8h]
  int v108; // [esp+34h] [ebp-C4h]
  int v109; // [esp+38h] [ebp-C0h]
  int v110; // [esp+3Ch] [ebp-BCh]
  int v111; // [esp+40h] [ebp-B8h]
  int v112; // [esp+44h] [ebp-B4h]
  unsigned int *v113; // [esp+48h] [ebp-B0h]
  int *v114; // [esp+4Ch] [ebp-ACh]
  int v115; // [esp+50h] [ebp-A8h]
  unsigned __int32 v116; // [esp+54h] [ebp-A4h]
  int v117; // [esp+58h] [ebp-A0h]
  int v118; // [esp+5Ch] [ebp-9Ch]
  int *v119; // [esp+60h] [ebp-98h]
  int *v120; // [esp+64h] [ebp-94h]
  unsigned int v121; // [esp+68h] [ebp-90h]
  int v122; // [esp+6Ch] [ebp-8Ch]
  char v123[44]; // [esp+74h] [ebp-84h] BYREF
  unsigned int v124; // [esp+A0h] [ebp-58h]
  int v125; // [esp+A4h] [ebp-54h]
  int v126[2]; // [esp+D4h] [ebp-24h]
  char v127[28]; // [esp+DCh] [ebp-1Ch] BYREF

  v2 = a1;
  v122 = a2;
  v3 = __readgsdword(8u);
  if ( v3 != dword_80F0C8C )
  {
    _ECX = 1;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg ds:lock_8574, ecx }
    if ( !v5 )
    {
      L_lock_33_0(0);
      return;
    }
    dword_80F0C8C = v3;
  }
  v6 = a1[1];
  v7 = dword_80F0C88;
  v8 = ++dword_80F0C88;
  if ( v6 )
  {
    dword_80F0C88 = v7;
    if ( v7 )
      return;
    goto LABEL_8;
  }
  v9 = *v2;
  v2[1] = -1;
  v2[2] = 0;
  if ( !v9 )
    goto LABEL_27;
  v10 = _open_nocancel(v9, 0);
  if ( v10 == -1 )
  {
LABEL_38:
    v8 = dword_80F0C88;
    goto LABEL_27;
  }
  if ( _fxstat64(3, v10, (int)v123) || (v120 = (int *)v124, v125) || v124 <= 0x2F )
  {
LABEL_37:
    dl_sysinfo(v11);
    goto LABEL_38;
  }
  v13 = (int *)mmap(0, v124, 1, 2, v10, 0);
  if ( v13 == (int *)-1 )
  {
    v21 = (int *)malloc(v120);
    if ( v21 )
    {
      v121 = (unsigned int)v2;
      v22 = v10;
      v23 = (int)v21;
      v119 = v21;
      v24 = (int)v120;
      do
      {
        while ( 1 )
        {
          nocancel = _read_nocancel(v22, v23);
          if ( nocancel == -1 )
            break;
          if ( nocancel <= 0 )
            goto LABEL_36;
          v24 -= nocancel;
          if ( !v24 )
          {
            v13 = v119;
            v2 = (int *)v121;
            dl_sysinfo(v11);
            v118 = 0;
            goto LABEL_19;
          }
          v23 += nocancel;
        }
      }
      while ( __readgsdword(0xFFFFFFE8) == 4 );
LABEL_36:
      v2 = (int *)v121;
    }
    goto LABEL_37;
  }
  dl_sysinfo(v12);
  v118 = 1;
LABEL_19:
  if ( *v13 != -569244523 && *v13 != -1794895138 )
  {
    if ( v118 )
      munmap((int)v13, (int)v120);
    else
      free(v13);
    v8 = dword_80F0C88;
    goto LABEL_27;
  }
  v103 = *v13;
  v14 = (int **)malloc(104);
  v15 = (_BYTE *)v103;
  v16 = (int)v14;
  if ( !v14 )
    goto LABEL_38;
  v17 = v118;
  v2[2] = (int)v14;
  *v14 = v13;
  v14[4] = 0;
  v14[1] = (int *)v17;
  v14[2] = v120;
  v18 = v15 + 1794895138 != 0;
  v19 = v13[1];
  *(_DWORD *)(v16 + 12) = v18;
  if ( v18 )
    v19 = _byteswap_ulong(v19);
  v20 = 0;
  if ( v19 > 0x1FFFF )
    goto LABEL_24;
  v26 = v13[2];
  if ( v18 )
  {
    *(_DWORD *)(v16 + 20) = _byteswap_ulong(v26);
    *(_DWORD *)(v16 + 24) = (char *)v13 + _byteswap_ulong(v13[3]);
    *(_DWORD *)(v16 + 28) = (char *)v13 + _byteswap_ulong(v13[4]);
    v27 = _byteswap_ulong(v13[5]);
  }
  else
  {
    *(_DWORD *)(v16 + 20) = v26;
    *(_DWORD *)(v16 + 24) = (char *)v13 + v13[3];
    *(_DWORD *)(v16 + 28) = (char *)v13 + v13[4];
    v27 = v13[5];
  }
  *(_DWORD *)(v16 + 44) = v27;
  v121 = 0;
  if ( v27 > 2 )
  {
    v28 = v13[6];
    if ( v18 )
      v28 = _byteswap_ulong(v28);
    v121 = (unsigned int)v13 + v28;
  }
  v29 = v121;
  *(_DWORD *)(v16 + 52) = v18;
  *(_DWORD *)(v16 + 48) = v29;
  if ( !(_WORD)v19 )
  {
LABEL_64:
    *(_DWORD *)(v16 + 32) = 0;
    *(_DWORD *)(v16 + 36) = 0;
    *(_DWORD *)(v16 + 40) = 0;
    goto LABEL_65;
  }
  if ( !v121 )
  {
LABEL_69:
    v20 = *(_DWORD *)(v16 + 16);
LABEL_24:
    free(v20);
    if ( v118 )
      munmap((int)v13, (int)v120);
    else
      free(v13);
    free(v16);
    v8 = dword_80F0C88;
    v2[2] = 0;
    goto LABEL_27;
  }
  if ( v18 )
    v116 = _byteswap_ulong(v13[9]);
  else
    v116 = v13[9];
  if ( !v116 )
    goto LABEL_64;
  if ( v18 )
  {
    v121 = _byteswap_ulong(v13[7]);
    v30 = _byteswap_ulong(v13[8]);
  }
  else
  {
    v121 = v13[7];
    v30 = v13[8];
  }
  v31 = (char *)v13 + v30;
  v32 = alloca(4 * v121 + 15);
  v119 = &v103;
  if ( v121 )
  {
    v33 = *(_DWORD *)(v16 + 12);
    v34 = 0;
    v115 = v16;
    v35 = v31;
    v114 = v2;
    v112 = v33;
    v36 = v33;
    while ( 1 )
    {
      if ( v36 )
      {
        v37 = (char *)v13 + _byteswap_ulong(*(_DWORD *)&v35[8 * v34 + 4]);
        v38 = _byteswap_ulong(*(_DWORD *)&v35[8 * v34]);
      }
      else
      {
        v38 = *(_DWORD *)&v35[8 * v34];
        v37 = (char *)v13 + *(_DWORD *)&v35[8 * v34 + 4];
      }
      if ( !v38 || v37[v38 - 1] )
      {
        v16 = v115;
        v2 = v114;
        v20 = *(_DWORD *)(v115 + 16);
        goto LABEL_24;
      }
      if ( *v37 != 80 )
      {
        v39 = 0;
        if ( *v37 == 73 && !v37[1] )
          v39 = "I";
        goto LABEL_61;
      }
      v39 = 0;
      if ( v37[1] == 82 && v37[2] == 73 )
      {
        v41 = v37[3];
        LOBYTE(v113) = v41 == 100;
        LOBYTE(v111) = v41 == 105;
        LOBYTE(v117) = v41;
        if ( v41 == 105 || (_BYTE)v113 || v41 == 111 || v41 == 117 || v41 == 120 || (v39 = 0, (_BYTE)v117 == 88) )
        {
          v42 = v37[4];
          switch ( v42 )
          {
            case '8':
              if ( !v37[5] )
              {
                if ( (_BYTE)v113 )
                {
                  v39 = "d";
                }
                else if ( (_BYTE)v111 )
                {
                  v39 = "i";
                }
                else
                {
                  switch ( (_BYTE)v117 )
                  {
                    case 'o':
                      v39 = "o";
                      break;
                    case 'u':
                      v39 = (char *)&unk_80DAF1A;
                      break;
                    case 'x':
                      v39 = "+0x" + 2;
                      break;
                    case 'X':
                      v39 = "ARENA_MAX" + 8;
                      break;
                    default:
                      goto LABEL_276;
                  }
                }
                goto LABEL_61;
              }
              goto LABEL_82;
            case '1':
              if ( v37[5] == 54 && !v37[6] )
              {
                if ( (_BYTE)v113 )
                {
                  v39 = "d";
                }
                else if ( (_BYTE)v111 )
                {
                  v39 = "i";
                }
                else
                {
                  switch ( (_BYTE)v117 )
                  {
                    case 'o':
                      v39 = "o";
                      break;
                    case 'u':
                      v39 = (char *)&unk_80DAF1A;
                      break;
                    case 'x':
                      v39 = "+0x" + 2;
                      break;
                    case 'X':
                      v39 = "ARENA_MAX" + 8;
                      break;
                    default:
                      goto LABEL_276;
                  }
                }
                goto LABEL_61;
              }
LABEL_82:
              v39 = 0;
              goto LABEL_61;
            case '3':
              if ( v37[5] == 50 && !v37[6] )
              {
                if ( (_BYTE)v113 )
                {
                  v39 = "d";
                }
                else if ( (_BYTE)v111 )
                {
                  v39 = "i";
                }
                else
                {
                  switch ( (_BYTE)v117 )
                  {
                    case 'o':
                      v39 = "o";
                      break;
                    case 'u':
                      v39 = (char *)&unk_80DAF1A;
                      break;
                    case 'x':
                      v39 = "+0x" + 2;
                      break;
                    case 'X':
                      v39 = "ARENA_MAX" + 8;
                      break;
                    default:
                      goto LABEL_276;
                  }
                }
                goto LABEL_61;
              }
              goto LABEL_82;
            case '6':
              if ( v37[5] == 52 )
              {
                v39 = 0;
                if ( !v37[6] )
                {
                  if ( (_BYTE)v113 )
                  {
                    v39 = "lld";
                  }
                  else if ( (_BYTE)v111 )
                  {
                    v39 = "lli";
                  }
                  else
                  {
                    switch ( (_BYTE)v117 )
                    {
                      case 'o':
                        v39 = "llo";
                        break;
                      case 'u':
                        v39 = "llu";
                        break;
                      case 'x':
                        v39 = "llx";
                        break;
                      case 'X':
                        v39 = "llX";
                        break;
                      default:
                        goto LABEL_276;
                    }
                  }
                }
                goto LABEL_61;
              }
              goto LABEL_82;
          }
          if ( v42 != 76 )
          {
            switch ( v42 )
            {
              case 'F':
                v39 = 0;
                if ( v37[5] == 65 && v37[6] == 83 && v37[7] == 84 )
                {
                  v5 = v37[8] == 56;
                  LOBYTE(v110) = v37[8];
                  v39 = 0;
                  if ( v5 )
                  {
                    if ( !v37[9] )
                    {
                      if ( (_BYTE)v113 )
                      {
                        v39 = "d";
                      }
                      else if ( (_BYTE)v111 )
                      {
                        v39 = "i";
                      }
                      else
                      {
                        switch ( (_BYTE)v117 )
                        {
                          case 'o':
                            v39 = "o";
                            break;
                          case 'u':
                            v39 = (char *)&unk_80DAF1A;
                            break;
                          case 'x':
                            v39 = "+0x" + 2;
                            break;
                          case 'X':
                            v39 = "ARENA_MAX" + 8;
                            break;
                          default:
                            goto LABEL_276;
                        }
                      }
                    }
                  }
                  else if ( (_BYTE)v110 == 49 )
                  {
                    if ( v37[9] == 54 && !v37[10] )
                    {
                      if ( (_BYTE)v113 )
                      {
                        v39 = "d";
                      }
                      else if ( (_BYTE)v111 )
                      {
                        v39 = "i";
                      }
                      else
                      {
                        switch ( (_BYTE)v117 )
                        {
                          case 'o':
                            v39 = "o";
                            break;
                          case 'u':
                            v39 = (char *)&unk_80DAF1A;
                            break;
                          case 'x':
                            v39 = "+0x" + 2;
                            break;
                          case 'X':
                            v39 = "ARENA_MAX" + 8;
                            break;
                          default:
                            goto LABEL_276;
                        }
                      }
                    }
                  }
                  else if ( (_BYTE)v110 == 51 )
                  {
                    if ( v37[9] == 50 && !v37[10] )
                    {
                      if ( (_BYTE)v113 )
                      {
                        v39 = "d";
                      }
                      else if ( (_BYTE)v111 )
                      {
                        v39 = "i";
                      }
                      else
                      {
                        switch ( (_BYTE)v117 )
                        {
                          case 'o':
                            v39 = "o";
                            break;
                          case 'u':
                            v39 = (char *)&unk_80DAF1A;
                            break;
                          case 'x':
                            v39 = "+0x" + 2;
                            break;
                          case 'X':
                            v39 = "ARENA_MAX" + 8;
                            break;
                          default:
                            goto LABEL_276;
                        }
                      }
                    }
                  }
                  else if ( (_BYTE)v110 == 54 && v37[9] == 52 && !v37[10] )
                  {
                    if ( (_BYTE)v113 )
                    {
                      v39 = "lld";
                    }
                    else if ( (_BYTE)v111 )
                    {
                      v39 = "lli";
                    }
                    else
                    {
                      switch ( (_BYTE)v117 )
                      {
                        case 'o':
                          v39 = "llo";
                          break;
                        case 'u':
                          v39 = "llu";
                          break;
                        case 'x':
                          v39 = "llx";
                          break;
                        case 'X':
                          v39 = "llX";
                          break;
                        default:
                          goto LABEL_276;
                      }
                    }
                  }
                }
                goto LABEL_61;
              case 'M':
                v39 = 0;
                if ( v37[5] == 65 && v37[6] == 88 && !v37[7] )
                {
                  if ( (_BYTE)v113 )
                  {
                    v39 = "lld";
                  }
                  else if ( (_BYTE)v111 )
                  {
                    v39 = "lli";
                  }
                  else
                  {
                    switch ( (_BYTE)v117 )
                    {
                      case 'o':
                        v39 = "llo";
                        break;
                      case 'u':
                        v39 = "llu";
                        break;
                      case 'x':
                        v39 = "llx";
                        break;
                      case 'X':
                        v39 = "llX";
                        break;
                      default:
                        goto LABEL_276;
                    }
                  }
                }
                goto LABEL_61;
              case 'P':
                v39 = 0;
                if ( v37[5] == 84 && v37[6] == 82 && !v37[7] )
                {
                  if ( (_BYTE)v113 )
                  {
                    v39 = "d";
                  }
                  else if ( (_BYTE)v111 )
                  {
                    v39 = "i";
                  }
                  else
                  {
                    switch ( (_BYTE)v117 )
                    {
                      case 'o':
                        v39 = "o";
                        break;
                      case 'u':
                        v39 = (char *)&unk_80DAF1A;
                        break;
                      case 'x':
                        v39 = "+0x" + 2;
                        break;
                      case 'X':
                        v39 = "ARENA_MAX" + 8;
                        break;
                      default:
                        goto LABEL_276;
                    }
                  }
                }
                goto LABEL_61;
            }
            goto LABEL_82;
          }
          if ( v37[5] != 69 || v37[6] != 65 || v37[7] != 83 )
            goto LABEL_82;
          v39 = 0;
          if ( v37[8] == 84 )
          {
            v101 = v37[9];
            switch ( v101 )
            {
              case '8':
                v39 = 0;
                if ( !v37[10] )
                {
                  if ( (_BYTE)v113 )
                  {
                    v39 = "d";
                  }
                  else if ( (_BYTE)v111 )
                  {
                    v39 = "i";
                  }
                  else
                  {
                    switch ( (_BYTE)v117 )
                    {
                      case 'o':
                        v39 = "o";
                        break;
                      case 'u':
                        v39 = (char *)&unk_80DAF1A;
                        break;
                      case 'x':
                        v39 = "+0x" + 2;
                        break;
                      case 'X':
                        v39 = "ARENA_MAX" + 8;
                        break;
                      default:
                        goto LABEL_276;
                    }
                  }
                }
                goto LABEL_61;
              case '1':
                if ( v37[10] == 54 )
                {
                  v39 = 0;
                  if ( !v37[11] )
                  {
                    if ( (_BYTE)v113 )
                    {
                      v39 = "d";
                    }
                    else if ( (_BYTE)v111 )
                    {
                      v39 = "i";
                    }
                    else
                    {
                      switch ( (_BYTE)v117 )
                      {
                        case 'o':
                          v39 = "o";
                          break;
                        case 'u':
                          v39 = (char *)&unk_80DAF1A;
                          break;
                        case 'x':
                          v39 = "+0x" + 2;
                          break;
                        case 'X':
                          v39 = "ARENA_MAX" + 8;
                          break;
                        default:
                          goto LABEL_276;
                      }
                    }
                  }
                  goto LABEL_61;
                }
                break;
              case '3':
                v39 = 0;
                if ( v37[10] == 50 && !v37[11] )
                {
                  if ( (_BYTE)v113 )
                  {
                    v39 = "d";
                  }
                  else if ( (_BYTE)v111 )
                  {
                    v39 = "i";
                  }
                  else
                  {
                    switch ( (_BYTE)v117 )
                    {
                      case 'o':
                        v39 = "o";
                        break;
                      case 'u':
                        v39 = (char *)&unk_80DAF1A;
                        break;
                      case 'x':
                        v39 = "+0x" + 2;
                        break;
                      case 'X':
                        v39 = "ARENA_MAX" + 8;
                        break;
                      default:
                        goto LABEL_276;
                    }
                  }
                }
                goto LABEL_61;
              case '6':
                v39 = 0;
                if ( v37[10] == 52 && !v37[11] )
                {
                  if ( (_BYTE)v113 )
                  {
                    v39 = "lld";
                  }
                  else if ( (_BYTE)v111 )
                  {
                    v39 = "lli";
                  }
                  else
                  {
                    switch ( (_BYTE)v117 )
                    {
                      case 'o':
                        v39 = "llo";
                        break;
                      case 'u':
                        v39 = "llu";
                        break;
                      case 'x':
                        v39 = "llx";
                        break;
                      case 'X':
                        v39 = "llX";
                        break;
                      default:
                        goto LABEL_276;
                    }
                  }
                }
                goto LABEL_61;
            }
            v39 = 0;
          }
        }
      }
LABEL_61:
      v119[v34++] = (int)v39;
      if ( v34 == v121 )
      {
        v16 = v115;
        v2 = v114;
        goto LABEL_95;
      }
    }
  }
  v112 = *(_DWORD *)(v16 + 12);
LABEL_95:
  if ( v112 )
  {
    v110 = (int)v13 + _byteswap_ulong(v13[10]);
    v43 = _byteswap_ulong(v13[11]);
  }
  else
  {
    v43 = v13[11];
    v110 = (int)v13 + v13[10];
  }
  v109 = (int)v13 + v43;
  v44 = *(_DWORD *)(v16 + 44);
  v114 = v13;
  v45 = v112;
  v115 = 0;
  v111 = 0;
  v106 = (int *)(4 * v44);
  v113 = (unsigned int *)(4 * v44);
  v108 = v16;
  v107 = v2;
  do
  {
    v117 = 0;
    while ( 1 )
    {
      if ( v45 )
      {
        v46 = v117 ? *(_DWORD *)(v109 + 4 * v115) : *(_DWORD *)(v110 + 4 * v115);
        v47 = (char *)v114 + _byteswap_ulong(v46);
        v48 = _byteswap_ulong(*((_DWORD *)v47 + 2)) != -1;
      }
      else
      {
        v75 = v117 ? *(_DWORD *)(v109 + 4 * v115) : *(_DWORD *)(v110 + 4 * v115);
        v47 = (char *)v114 + v75;
        v48 = *((_DWORD *)v47 + 2) != -1;
      }
      v49 = 0;
      if ( v48 )
        break;
LABEL_112:
      v53 = v117;
      v126[v117] = v49;
      v117 = v53 + 1;
      if ( v53 == 1 )
      {
        v113 = (unsigned int *)((char *)v113 + v126[1]);
        ++v111;
        v113 = (unsigned int *)((char *)v113 + v126[0]);
        goto LABEL_114;
      }
    }
    for ( i = (unsigned int *)(v47 + 4); ; i += 2 )
    {
      if ( v45 )
      {
        v49 += _byteswap_ulong(*i);
        v51 = _byteswap_ulong(i[1]);
      }
      else
      {
        v49 += *i;
        v51 = i[1];
      }
      if ( v51 == -1 )
        goto LABEL_112;
      if ( v51 >= v121 )
      {
        v13 = v114;
        v16 = v108;
        v2 = v107;
        goto LABEL_69;
      }
      v52 = (_BYTE *)v119[v51];
      if ( !v52 )
        break;
      v49 += strlen(v52);
    }
    v126[v117] = v49;
LABEL_114:
    ++v115;
  }
  while ( v115 != v116 );
  v13 = v114;
  v16 = v108;
  v2 = v107;
  if ( !v111 )
    goto LABEL_64;
  v112 = malloc(&v113[4 * v111]);
  if ( !v112 )
    goto LABEL_69;
  v54 = v112;
  v55 = v119;
  v108 = 0;
  *(_DWORD *)(v16 + 16) = v112;
  v118 = 0;
  v114 = v13;
  v104 = v2;
  v56 = 8 * v111 + v54;
  v120 = (int *)(v56 + 8 * v111);
  v57 = (unsigned int)v120 + (_DWORD)v106;
  v107 = (int *)v56;
  v106 = (int *)v16;
  v121 = v57;
  do
  {
    v58 = 0;
    v59 = v106[3];
    do
    {
      if ( v59 )
      {
        if ( v58 )
          v60 = *(_DWORD *)(v109 + 4 * v118);
        else
          v60 = *(_DWORD *)(v110 + 4 * v118);
        v61 = (char *)v114 + _byteswap_ulong(v60);
        v62 = _byteswap_ulong(*((_DWORD *)v61 + 2)) != -1;
      }
      else
      {
        if ( v58 )
          v96 = *(_DWORD *)(v109 + 4 * v118);
        else
          v96 = *(_DWORD *)(v110 + 4 * v118);
        v61 = (char *)v114 + v96;
        v62 = *((_DWORD *)v61 + 2) != -1;
      }
      if ( v62 )
      {
        for ( j = v61 + 4; ; j += 8 )
        {
          v64 = *((_DWORD *)j + 1);
          if ( v59 )
            v64 = _byteswap_ulong(v64);
          if ( v64 == -1 )
            break;
          if ( !v55[v64] )
            goto LABEL_156;
        }
      }
      ++v58;
    }
    while ( v58 != 2 );
    v65 = (_BYTE *)v121;
    v121 = v106[3];
    v115 = 0;
    v105 = 8 * v108;
    v117 = (int)v55;
    if ( v59 )
    {
LABEL_132:
      if ( v115 )
        v66 = *(_DWORD *)(v109 + 4 * v118);
      else
        v66 = *(_DWORD *)(v110 + 4 * v118);
      v67 = (unsigned int *)((char *)v114 + _byteswap_ulong(v66));
      v68 = _byteswap_ulong(*v67);
      goto LABEL_135;
    }
    while ( 1 )
    {
      v74 = v115 ? *(_DWORD *)(v109 + 4 * v118) : *(_DWORD *)(v110 + 4 * v118);
      v67 = (unsigned int *)((char *)v114 + v74);
      v68 = *v67;
LABEL_135:
      v119 = (int *)((char *)v114 + v68);
      v69 = v112;
      if ( v115 )
        v69 = (int)v107;
      v113 = (unsigned int *)(v105 + v69);
      if ( v121 ? _byteswap_ulong(v67[2]) == -1 : v67[2] == -1 )
      {
        v71 = v67[1];
        if ( v121 )
          v71 = _byteswap_ulong(v71);
        v72 = v113;
        v73 = v119;
        *v113 = v71;
        v72[1] = (unsigned int)v73;
      }
      else
      {
        v97 = v67 + 1;
        v113[1] = (unsigned int)v65;
        while ( 1 )
        {
          v98 = (_BYTE *)*v97;
          if ( v121 )
          {
            v98 = (_BYTE *)_byteswap_ulong((unsigned int)v98);
            v99 = _byteswap_ulong(v97[1]);
          }
          else
          {
            v99 = v97[1];
          }
          if ( v98 )
          {
            v103 = (int)v98;
            memcpy(v65, v119, (unsigned int)v98);
            v119 = (int *)((char *)v119 + v103);
            v65 += v103;
          }
          if ( v99 == -1 )
            break;
          v97 += 2;
          v103 = *(_DWORD *)(v117 + 4 * v99);
          v100 = strlen((_BYTE *)v103);
          v102 = v65;
          v65 += v100;
          memcpy(v102, (_BYTE *)v103, v100);
        }
        *v113 = (unsigned int)&v65[-v113[1]];
      }
      if ( ++v115 == 2 )
        break;
      v121 = v106[3];
      if ( v121 )
        goto LABEL_132;
    }
    v55 = (int *)v117;
    ++v108;
    v121 = (unsigned int)v65;
LABEL_156:
    ++v118;
  }
  while ( v118 != v116 );
  v76 = v106;
  v77 = (int)v104;
  if ( v111 != v108 )
LABEL_276:
    abort();
  v78 = v106[11];
  if ( v78 )
  {
    v79 = v106[12];
    v80 = 0;
    v81 = v106[13];
    v119 = v106;
    v121 = v79;
    do
    {
      v82 = *(_DWORD *)(v121 + 4 * v80);
      if ( v81 )
        v82 = _byteswap_ulong(v82);
      v120[v80++] = v82;
    }
    while ( v80 != v78 );
    v76 = v119;
  }
  v121 = 0;
  v119 = v76;
  v118 = v77;
  do
  {
    v83 = _hash_string(*(unsigned __int8 **)(v112 + 8 * v121 + 4));
    v84 = v119[11];
    v85 = v83 % v84;
    v86 = v83 % (v84 - 2) + 1;
    v87 = v86 - v84;
    while ( 1 )
    {
      v90 = &v120[v85];
      if ( !*v90 )
        break;
      v88 = v85 < v119[11] - v86;
      v89 = v85 + v86;
      v85 += v87;
      if ( v88 )
        v85 = v89;
    }
    v91 = v119;
    v92 = v121 + 1;
    v5 = v121 + 1 == v111;
    *v90 = v121 + v119[5] + 1;
    v121 = v92;
  }
  while ( !v5 );
  v16 = (int)v91;
  v93 = v112;
  v91[8] = v92;
  v94 = (int)v120;
  v95 = (int)v107;
  v2 = (int *)v118;
  *(_DWORD *)(v16 + 36) = v93;
  *(_DWORD *)(v16 + 48) = v94;
  *(_DWORD *)(v16 + 40) = v95;
  *(_DWORD *)(v16 + 52) = 0;
LABEL_65:
  *(_DWORD *)(v16 + 56) = 0;
  *(_DWORD *)(v16 + 60) = 0;
  msg = (char *)nl_find_msg(0, v127);
  _gettext_extract_plural(msg, (char **)(v16 + 96), (_DWORD *)(v16 + 100));
  v8 = dword_80F0C88;
LABEL_27:
  v2[1] = 1;
  dword_80F0C88 = v8 - 1;
  if ( v8 == 1 )
  {
LABEL_8:
    dword_80F0C8C = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --lock_8574 )
      L_unlock_68();
  }
}
// 8058136: variable 'v12' is possibly undefined
// 8058273: variable 'v11' is possibly undefined
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 8056CE0: using guessed type _DWORD __stdcall nl_find_msg(_DWORD, _DWORD);
// 805ACB0: using guessed type void __noreturn abort(void);
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80F0C84: using guessed type int lock_8574;
// 80F0C88: using guessed type int dword_80F0C88;
// 80F0C8C: using guessed type int dword_80F0C8C;
// 8057FF0: using guessed type char var_84[44];
// 8057FF0: using guessed type char var_1C[28];

//----- (080595B9) --------------------------------------------------------
void __usercall L_lock_33_0(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &lock_8574);
  JUMPOUT(0x8058032);
}
// 80595C4: control flows out of bounds to 8058032
// 80F0C84: using guessed type int lock_8574;

//----- (080595C9) --------------------------------------------------------
void L_unlock_68()
{
  _lll_unlock_wake_private(&lock_8574);
  JUMPOUT(0x805807A);
}
// 80595D4: control flows out of bounds to 805807A
// 80F0C84: using guessed type int lock_8574;

//----- (080595E0) --------------------------------------------------------
int __usercall read_alias_file@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>, long double a3@<st0>)
{
  void *v3; // esp
  int v4; // ebx
  int *v5; // eax
  int *v6; // edx
  int v7; // eax
  char *v8; // ebx
  char *v9; // eax
  char v10; // dl
  unsigned int v11; // eax
  unsigned __int8 v12; // cl
  _BYTE *v13; // edx
  _BYTE *v14; // esi
  unsigned __int8 v15; // dl
  unsigned __int8 v16; // dl
  _BYTE *v17; // ecx
  unsigned int v18; // edx
  int v19; // edi
  int v20; // eax
  int v21; // eax
  unsigned int v22; // ecx
  int v23; // edi
  int v24; // eax
  _BYTE *v25; // eax
  _BYTE *v26; // edi
  _BYTE *v27; // eax
  int *v29; // ebx
  int v30; // eax
  int v31; // eax
  int v32; // edx
  _DWORD *v33; // edx
  int v34; // eax
  _BYTE v35[8]; // [esp+10h] [ebp-1E8h] BYREF
  int v36; // [esp+18h] [ebp-1E0h]
  unsigned int v37; // [esp+20h] [ebp-1D8h]
  int v38; // [esp+24h] [ebp-1D4h]
  int v39; // [esp+28h] [ebp-1D0h]
  int v40; // [esp+2Ch] [ebp-1CCh]
  unsigned int v41; // [esp+30h] [ebp-1C8h]
  unsigned int v42; // [esp+34h] [ebp-1C4h]
  int v43; // [esp+38h] [ebp-1C0h]
  int v44; // [esp+3Ch] [ebp-1BCh]
  int v45; // [esp+40h] [ebp-1B8h]
  _DWORD *v46; // [esp+44h] [ebp-1B4h]
  char *v47; // [esp+48h] [ebp-1B0h]
  int *v48; // [esp+4Ch] [ebp-1ACh]
  char s[424]; // [esp+50h] [ebp-1A8h] BYREF

  v3 = alloca(a2 + 29);
  strcpy((char *)mempcpy(v35, a1, a2), "/locale.alias");
  v4 = 0;
  v5 = fopen((int)v35, "rce");
  v48 = v5;
  if ( !v5 )
    return v4;
  v6 = v5;
  v7 = *v5;
  v40 = 0;
  BYTE1(v7) |= 0x80u;
  *v6 = v7;
  if ( (v7 & 0x10) == 0 )
  {
    while ( fgets_unlocked((int)s, 400, v48) )
    {
      v8 = s;
      v9 = strchr(s, 10);
      v10 = s[0];
      v47 = v9;
      v11 = __readgsdword(0xFFFFFFF8);
      if ( (*(_BYTE *)(v11 + 2 * (unsigned __int8)s[0] + 1) & 0x20) != 0 )
      {
        do
          v10 = *++v8;
        while ( (*(_BYTE *)(v11 + 2 * (unsigned __int8)*v8 + 1) & 0x20) != 0 );
      }
      if ( v10 != 35 && v10 )
      {
        v12 = v8[1];
        v13 = v8 + 1;
        if ( v12 )
        {
          while ( (*(_BYTE *)(v11 + 2 * v12 + 1) & 0x20) == 0 )
          {
            v12 = *++v13;
            if ( !*v13 )
              goto LABEL_33;
          }
          *v13 = 0;
          v14 = v13 + 1;
          v15 = v13[1];
        }
        else
        {
LABEL_33:
          v14 = v13;
          v15 = 0;
        }
        while ( (*(_BYTE *)(v11 + 2 * v15 + 1) & 0x20) != 0 )
          v15 = *++v14;
        if ( v15 )
        {
          v16 = v14[1];
          if ( v16 )
          {
            v17 = v14 + 1;
            if ( (*(_BYTE *)(v11 + 2 * v16 + 1) & 0x20) != 0 )
            {
LABEL_43:
              *v17 = 0;
              if ( v16 == 10 )
                v17[1] = 10;
            }
            else
            {
              while ( 1 )
              {
                v16 = v17[1];
                if ( !v16 )
                  break;
                ++v17;
                if ( (*(_BYTE *)(v11 + 2 * v16 + 1) & 0x20) != 0 )
                  goto LABEL_43;
              }
            }
          }
          v45 = nmap;
          if ( nmap >= (unsigned int)maxmap )
          {
            v18 = 800;
            v19 = 100;
            if ( maxmap )
            {
              v19 = 2 * maxmap;
              v18 = 16 * maxmap;
            }
            realloc((_BYTE *)map, v18);
            if ( !v20 )
              break;
            map = v20;
            maxmap = v19;
          }
          v37 = strlen(v8) + 1;
          v21 = strlen(v14);
          v22 = v37;
          v43 = string_space_act;
          v42 = v37 + string_space_act;
          v44 = v21 + 1;
          v41 = v21 + 1 + v37 + string_space_act;
          if ( v41 > string_space_max )
          {
            v30 = v37 + v44;
            if ( v37 + v44 < 0x400 )
              v30 = 1024;
            v46 = (_DWORD *)(string_space_max + v30);
            v39 = string_space;
            realloc((_BYTE *)string_space, string_space_max + v30);
            v22 = v37;
            v23 = v31;
            if ( !v31 )
              break;
            v24 = map;
            if ( v39 != v23 && v45 )
            {
              v32 = v23 - v39;
              v36 = map;
              v39 = 0;
              v38 = v32;
              v33 = (_DWORD *)map;
              do
              {
                v34 = v38;
                *v33 += v38;
                v33[1] += v34;
                v33 += 2;
                ++v39;
              }
              while ( v39 != v45 );
              v24 = v36;
            }
            string_space = v23;
            string_space_max = (int)v46;
          }
          else
          {
            v23 = string_space;
            v24 = map;
          }
          v46 = (_DWORD *)(v24 + 8 * v45);
          v25 = memcpy((_BYTE *)(v23 + v43), v8, v22);
          v26 = (_BYTE *)(v42 + v23);
          *v46 = v25;
          v27 = memcpy(v26, v14, v44);
          ++v40;
          string_space_act = v41;
          v46[1] = v27;
          nmap = v45 + 1;
        }
      }
      if ( !v47 )
      {
        v29 = v48;
        while ( fgets_unlocked((int)s, 400, v29) && !strchr(s, 10) )
          ;
      }
      if ( (*v48 & 0x10) != 0 )
        break;
    }
  }
  v4 = v40;
  fclose(v48);
  if ( !v40 )
    return v4;
  qsort(a3, map, nmap, 8u, (int (__cdecl *)(unsigned int, unsigned int, int))alias_compare);
  return v40;
}
// 80597AF: variable 'v20' is possibly undefined
// 8059973: variable 'v31' is possibly undefined
// 80F0C94: using guessed type int nmap;
// 80F0C98: using guessed type int maxmap;
// 80F0C9C: using guessed type int string_space_act;
// 80F0CA0: using guessed type int string_space_max;
// 80F1374: using guessed type int map;
// 80F1378: using guessed type int string_space;

//----- (08059A50) --------------------------------------------------------
int __cdecl alias_compare(_DWORD *a1, _DWORD *a2)
{
  return strcasecmp_l(*a1, *a2, nl_C_locobj);
}
// 80482A0: using guessed type int __cdecl strcasecmp_l(_DWORD, _DWORD, _DWORD);
// 80C8380: using guessed type char **nl_C_locobj[6];

//----- (08059A80) --------------------------------------------------------
void __usercall nl_expand_alias(long double a1@<st0>, int a2)
{
  bool v3; // zf
  unsigned int v4; // eax
  char *v5; // edi
  char v6; // cl
  char *v7; // eax
  char *v8; // edx
  int v9[5]; // [esp+28h] [ebp-14h] BYREF

  _ECX = 1;
  v3 = __readgsdword(0xCu) == 0;
  if ( !v3 )
    __asm { lock }
  __asm { cmpxchg ds:lock_0, ecx }
  if ( v3 )
  {
    v4 = nmap;
    v9[0] = a2;
    if ( nmap )
      goto LABEL_23;
    while ( 1 )
    {
      v5 = locale_alias_path_8071;
      v6 = *locale_alias_path_8071;
      if ( !*locale_alias_path_8071 )
        break;
      while ( 1 )
      {
        v7 = v5;
        v8 = v5;
        if ( v6 == 58 )
        {
          do
            v6 = *++v7;
          while ( *v7 == 58 );
          v5 = v7;
          v8 = v7;
        }
        if ( v6 )
        {
          do
            ++v8;
          while ( *v8 != 58 && *v8 );
          v5 = v8;
        }
        if ( v8 > v7 )
          break;
        v6 = *v5;
        if ( !*v5 )
        {
          locale_alias_path_8071 = v5;
          goto LABEL_17;
        }
      }
      locale_alias_path_8071 = v5;
      if ( read_alias_file(v7, v8 - v7, a1) )
      {
        v4 = nmap;
        v9[0] = a2;
        if ( nmap )
        {
LABEL_23:
          if ( bsearch((int)v9, map, v4, 8, (int (__cdecl *)(int, int))alias_compare) )
            break;
        }
      }
    }
LABEL_17:
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --lock_0 )
      L_unlock_649();
  }
  else
  {
    L_lock_570(0);
  }
}
// 80EF5CC: using guessed type char *locale_alias_path_8071;
// 80F0C90: using guessed type int lock_0;
// 80F0C94: using guessed type int nmap;
// 80F1374: using guessed type int map;
// 8059A80: using guessed type int var_14[5];

//----- (08059B98) --------------------------------------------------------
void __usercall L_lock_570(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &lock_0);
  JUMPOUT(0x8059AA9);
}
// 8059BA3: control flows out of bounds to 8059AA9
// 80F0C90: using guessed type int lock_0;

//----- (08059BA8) --------------------------------------------------------
void L_unlock_649()
{
  _lll_unlock_wake_private(&lock_0);
  JUMPOUT(0x8059B30);
}
// 8059BB3: control flows out of bounds to 8059B30
// 80F0C90: using guessed type int lock_0;

//----- (08059BC0) --------------------------------------------------------
const char **__cdecl nl_make_l10nflist(
        const char ***a1,
        _BYTE *a2,
        int a3,
        int a4,
        _BYTE *a5,
        _BYTE *a6,
        _BYTE *a7,
        _BYTE *a8,
        _BYTE *a9,
        char *src,
        int a11)
{
  int v11; // ebx
  int v12; // edi
  int v13; // esi
  int v14; // ebp
  int v15; // ecx
  int v16; // edx
  int v17; // eax
  const char **v18; // edi
  char *v19; // eax
  char *v20; // ebx
  _BYTE *v21; // eax
  const char **v22; // esi
  int v23; // eax
  int v24; // ecx
  int v25; // eax
  char **v26; // eax
  int v27; // esi
  int v28; // ebp
  _BYTE *v29; // edi
  _BYTE *v30; // ebx
  int v31; // eax
  int i; // ebx
  int v34; // [esp+3Ch] [ebp-30h]
  const char **v35; // [esp+40h] [ebp-2Ch]

  v11 = 0;
  v12 = strlen(a5);
  if ( (a4 & 4) != 0 )
    v11 = strlen(a6) + 1;
  v13 = 0;
  if ( (a4 & 2) != 0 )
    v13 = strlen(a7) + 1;
  v14 = 0;
  if ( (a4 & 1) != 0 )
    v14 = strlen(a8) + 1;
  v15 = 0;
  if ( (a4 & 8) != 0 )
    v15 = strlen(a9) + 1;
  v34 = v15;
  v16 = strlen(src);
  v17 = a3 + v12 + 2 + v11;
  v18 = 0;
  v19 = (char *)malloc(v34 + v14 + v17 + v13 + v16);
  v20 = v19;
  if ( !v19 )
    return v18;
  memcpy(v19, a2, a3);
  argz_stringify(v20, a3, 58);
  v20[a3 - 1] = 47;
  v21 = (_BYTE *)stpcpy(&v20[a3], a5);
  if ( (a4 & 4) != 0 )
  {
    *v21 = 95;
    v21 = (_BYTE *)stpcpy(v21 + 1, a6);
  }
  if ( (a4 & 2) != 0 )
  {
    *v21 = 46;
    v21 = (_BYTE *)stpcpy(v21 + 1, a7);
  }
  if ( (a4 & 1) != 0 )
  {
    *v21 = 46;
    v21 = (_BYTE *)stpcpy(v21 + 1, a8);
  }
  if ( (a4 & 8) != 0 )
  {
    *v21 = 64;
    v21 = (_BYTE *)stpcpy(v21 + 1, a9);
  }
  v22 = 0;
  *v21 = 47;
  strcpy(v21 + 1, src);
  v18 = *a1;
  if ( !*a1 )
  {
LABEL_24:
    if ( !a11 )
      goto LABEL_42;
    goto LABEL_25;
  }
  while ( !*v18 )
  {
LABEL_23:
    v18 = (const char **)v18[3];
    if ( !v18 )
      goto LABEL_24;
  }
  v23 = strcmp(*v18, v20);
  if ( !v23 )
    goto LABEL_42;
  if ( v23 >= 0 )
  {
    v22 = v18;
    goto LABEL_23;
  }
  v18 = 0;
  if ( a11 )
  {
LABEL_25:
    v24 = argz_count(a2, a3);
    v25 = ((int)(a4 & 0xFFFFAAAA) >> 1) + (a4 & 0x5555);
    LOWORD(v25) = ((((v25 & 0x3333) + ((int)(v25 & 0xFFFFCCCC) >> 2)) >> 4)
                 + (v25 & 0x3333)
                 + ((int)(v25 & 0xFFFFCCCC) >> 2)) & 0xF0F;
    v26 = (char **)malloc(4 * ((2 * v24) << (v25 + BYTE1(v25))) + 20);
    v18 = (const char **)v26;
    if ( !v26 )
      goto LABEL_42;
    *v26 = v20;
    if ( argz_count(a2, a3) == 1 )
    {
      v18[2] = 0;
      v18[1] = (const char *)((a4 & 3) == 3);
      if ( v22 )
        goto LABEL_28;
    }
    else
    {
      v18[1] = (const char *)1;
      v18[2] = 0;
      if ( v22 )
      {
LABEL_28:
        v18[3] = v22[3];
        v22[3] = (const char *)v18;
LABEL_29:
        v27 = 0;
        v28 = a4 - (argz_count(a2, a3) == 1);
        if ( v28 >= 0 )
        {
          v35 = v18;
          v29 = &a2[a3];
          do
          {
            if ( (v28 & ~a4) == 0 && a3 )
            {
              v30 = a2;
              do
              {
                if ( !v30 )
                  break;
                v31 = strlen(v30);
                v35[v27++ + 4] = (const char *)nl_make_l10nflist(
                                                 (int)a1,
                                                 (int)v30,
                                                 v31 + 1,
                                                 v28,
                                                 (int)a5,
                                                 (int)a6,
                                                 (int)a7,
                                                 (int)a8,
                                                 (int)a9,
                                                 src,
                                                 1);
                if ( v30 >= v29 )
                  break;
                v30 = (_BYTE *)(rawmemchr(v30, 0) + 1);
              }
              while ( v29 > v30 );
            }
            --v28;
          }
          while ( v28 != -1 );
          v18 = v35;
        }
        if ( a4 >= 0 )
        {
          for ( i = a4; i != -1; --i )
          {
            if ( (~a4 & i) == 0 )
              v18[v27++ + 4] = (const char *)nl_make_l10nflist(
                                               (int)a1,
                                               (int)"/usr/share/locale-langpack",
                                               27,
                                               i,
                                               (int)a5,
                                               (int)a6,
                                               (int)a7,
                                               (int)a8,
                                               (int)a9,
                                               src,
                                               1);
          }
        }
        v18[v27 + 4] = 0;
        return v18;
      }
    }
    v18[3] = (const char *)*a1;
    *a1 = v18;
    goto LABEL_29;
  }
LABEL_42:
  free(v20);
  return v18;
}
// 8059F39: conditional instruction was optimized away because ebx.4!=0
// 80481F0: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 8048230: using guessed type int __cdecl rawmemchr(_DWORD, _DWORD);
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0805A0E0) --------------------------------------------------------
_DWORD *__cdecl nl_normalize_codeset(int a1, int a2)
{
  int v2; // eax
  int v3; // edi
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  _DWORD *v7; // eax
  unsigned __int8 *v8; // ecx
  int i; // eax
  unsigned __int8 v10; // bl
  _DWORD *v12; // [esp+1Ch] [ebp-20h]

  if ( a2 )
  {
    v2 = 0;
    v3 = 1;
    v4 = 0;
    do
    {
      v5 = *(unsigned __int8 *)(a1 + v2);
      if ( (byte_80D0CC0[2 * v5] & 8) != 0 )
      {
        ++v4;
        if ( (unsigned int)(v5 - 48) >= 0xA )
          v3 = 0;
      }
      ++v2;
    }
    while ( v2 != a2 );
    if ( !v3 )
    {
      v6 = v4 + 1;
      goto LABEL_9;
    }
    v6 = v4 + 4;
  }
  else
  {
    v6 = 4;
  }
  v3 = 1;
LABEL_9:
  v7 = (_DWORD *)malloc(v6);
  v12 = v7;
  if ( v7 )
  {
    v8 = (unsigned __int8 *)v7;
    if ( v3 )
    {
      *v7 = 7304041;
      v8 = (unsigned __int8 *)v7 + 3;
    }
    if ( a2 )
    {
      for ( i = 0; i != a2; ++i )
      {
        while ( 1 )
        {
          v10 = *(_BYTE *)(a1 + i);
          if ( (byte_80D0CC0[2 * v10 + 1] & 4) == 0 )
            break;
          *v8++ = dword_80CFDC0[v10];
LABEL_15:
          if ( ++i == a2 )
            goto LABEL_19;
        }
        if ( (unsigned int)v10 - 48 > 9 )
          goto LABEL_15;
        *v8++ = v10;
      }
    }
LABEL_19:
    *v8 = 0;
  }
  return v12;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80CFDC0: using guessed type int dword_80CFDC0[256];
// 80D0CC0: using guessed type _BYTE byte_80D0CC0[512];

//----- (0805A1D0) --------------------------------------------------------
int __cdecl nl_explode_name(_BYTE *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, const char **a5, const char **a6)
{
  _DWORD *v6; // edx
  char v7; // al
  _BYTE *v8; // ebx
  char v9; // al
  char v10; // cl
  _BYTE *v11; // edi
  int v12; // esi
  int v14; // eax
  _BYTE *v15; // edi
  const char *s2; // ecx
  int v17; // eax
  _BYTE *v18; // eax
  const char *v19; // [esp+1Ch] [ebp-20h]

  v6 = a4;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  *a2 = a1;
  v7 = *a1;
  if ( !*a1 || v7 == 95 || v7 == 64 || v7 == 46 )
    goto LABEL_45;
  v8 = a1;
  do
  {
    v9 = *++v8;
    if ( *v8 == 95 || !v9 )
    {
      v10 = *v8;
      v11 = v8;
      goto LABEL_11;
    }
    if ( v9 == 64 )
    {
      v10 = 64;
      v11 = v8;
      goto LABEL_11;
    }
  }
  while ( v9 != 46 );
  v10 = 46;
  v11 = v8;
LABEL_11:
  if ( a1 == v8 )
  {
LABEL_45:
    v12 = 0;
    v18 = (_BYTE *)rawmemchr(a1, 0);
    v6 = a4;
    v8 = v18;
    v10 = *v18;
  }
  else
  {
    v12 = 0;
    if ( v9 != 64 )
    {
      if ( v9 == 95 )
      {
        *v8++ = 0;
        *a4 = v8;
        v10 = v11[1];
        if ( v10 != 46 )
        {
          while ( v10 )
          {
            if ( v10 == 64 )
            {
              v12 = 4;
              goto LABEL_26;
            }
            v10 = *++v8;
            if ( *v8 == 46 )
              break;
          }
        }
        v12 = 4;
      }
      if ( v10 == 46 )
      {
        v14 = (int)(v8 + 1);
        *v8 = 0;
        *a5 = v8 + 1;
        v10 = v8[1];
        if ( v10 && (v15 = v8 + 1, v10 != 64) )
        {
          while ( 1 )
          {
            v10 = v15[1];
            v8 = v15 + 1;
            if ( v10 == 64 || !v10 )
              break;
            ++v15;
          }
          v12 |= 2u;
          if ( (_BYTE *)v14 != v8 )
          {
            s2 = (const char *)nl_normalize_codeset(v14, (int)&v8[-v14]);
            *a6 = s2;
            if ( !s2 )
              return -1;
            v19 = s2;
            v17 = strcmp(*a5, s2);
            v6 = a4;
            if ( v17 )
            {
              v12 |= 1u;
              v10 = v15[1];
            }
            else
            {
              free(v19);
              v10 = v15[1];
              v6 = a4;
            }
          }
        }
        else
        {
          v12 |= 2u;
          ++v8;
        }
      }
    }
  }
  if ( v10 == 64 )
  {
LABEL_26:
    *v8 = 0;
    *a3 = v8 + 1;
    if ( v8[1] )
      v12 |= 8u;
  }
  if ( *v6 && !*(_BYTE *)*v6 )
    v12 &= ~4u;
  if ( *a5 && !**a5 )
    return v12 & 0xFFFFFFFD;
  return v12;
}
// 8048230: using guessed type int __cdecl rawmemchr(_DWORD, _DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0805A400) --------------------------------------------------------
_DWORD *__usercall _gettext_free_exp@<eax>(_DWORD *result@<eax>)
{
  _DWORD *v1; // ebx
  int v2; // eax

  v1 = result;
  if ( result )
  {
    v2 = *result;
    if ( v2 != 2 )
    {
      if ( v2 != 3 )
      {
        if ( v2 != 1 )
          return (_DWORD *)free(v1);
LABEL_9:
        _gettext_free_exp();
        return (_DWORD *)free(v1);
      }
      _gettext_free_exp();
    }
    _gettext_free_exp();
    goto LABEL_9;
  }
  return result;
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0805A450) --------------------------------------------------------
_DWORD *__usercall new_exp@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v6; // edi
  _DWORD *v7; // eax
  int v8; // edx
  _DWORD *result; // eax

  v6 = a1 - 1;
  if ( a1 - 1 < 0 )
  {
LABEL_6:
    result = (_DWORD *)malloc(20);
    if ( result )
    {
      *result = a1;
      result[1] = a2;
      if ( v6 >= 0 )
      {
        do
        {
          result[v6 + 2] = *(_DWORD *)(a3 + 4 * v6);
          --v6;
        }
        while ( v6 != -1 );
      }
    }
    else if ( v6 >= 0 )
    {
      goto LABEL_11;
    }
    return result;
  }
  v7 = *(_DWORD **)(a3 + 4 * v6);
  v8 = v6;
  if ( v7 )
  {
    while ( --v8 != -1 )
    {
      if ( !*(_DWORD *)(a3 + 4 * v8) )
        goto LABEL_12;
    }
    goto LABEL_6;
  }
LABEL_12:
  while ( 1 )
  {
    _gettext_free_exp(v7);
    if ( --v6 < 0 )
      break;
LABEL_11:
    v7 = *(_DWORD **)(a3 + 4 * v6);
  }
  return 0;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);

//----- (0805A4D0) --------------------------------------------------------
_DWORD *__usercall new_exp_2@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4[5]; // [esp+8h] [ebp-14h] BYREF

  v4[0] = a2;
  v4[1] = a3;
  return new_exp(2, a1, (int)v4);
}

//----- (0805A4F0) --------------------------------------------------------
#error "805A4F0: stack frame is too big (funcsize=0)"

//----- (0805AB10) --------------------------------------------------------
char *__usercall _gettext_extract_plural@<eax>(char *result@<eax>, char **a2@<edx>, _DWORD *a3@<ecx>)
{
  const char *haystack; // ebx
  char *v6; // ebp
  unsigned __int8 v7; // cl
  char *v8; // ebx
  unsigned int v9; // edx
  char *v10; // [esp+14h] [ebp-28h] BYREF
  char *v11; // [esp+18h] [ebp-24h]
  char *v12; // [esp+1Ch] [ebp-20h] BYREF

  haystack = result;
  if ( !result )
    goto LABEL_9;
  v6 = strstr(result, "plural=");
  result = strstr(haystack, "nplurals=");
  if ( !result )
    goto LABEL_9;
  if ( !v6 )
    goto LABEL_9;
  v7 = result[9];
  if ( !v7 )
    goto LABEL_9;
  v8 = result + 9;
  v9 = __readgsdword(0xFFFFFFF8);
  result = (char *)(unsigned __int8)result[9];
  if ( (*(_BYTE *)(v9 + 2 * v7 + 1) & 0x20) != 0 )
  {
    do
    {
      result = (char *)(unsigned __int8)v8[1];
      if ( !(_BYTE)result )
        goto LABEL_9;
      ++v8;
    }
    while ( (*(_BYTE *)(v9 + 2 * (unsigned __int8)result + 1) & 0x20) != 0 );
  }
  result -= 48;
  if ( (unsigned __int8)result > 9u
    || (result = (char *)strtoul(v8, &v12, 10), v8 == v12)
    || (*a3 = result, v10 = v6 + 7, (result = (char *)_gettextparse(&v10)) != 0) )
  {
LABEL_9:
    *a2 = (char *)&_gettext_germanic_plural;
    *a3 = 2;
    return result;
  }
  result = v11;
  *a2 = v11;
  return result;
}
// 805A4F0: using guessed type int __cdecl _gettextparse(_DWORD);

//----- (0805AC00) --------------------------------------------------------
int __cdecl _hash_string(unsigned __int8 *a1)
{
  int result; // eax
  unsigned __int8 v3; // cl

  result = 0;
  while ( 1 )
  {
    v3 = *a1;
    if ( !*a1 )
      break;
    while ( 1 )
    {
      result = v3 + 16 * result;
      ++a1;
      if ( (result & 0xF0000000) == 0 )
        break;
      result ^= ((result & 0xF0000000) >> 24) ^ result & 0xF0000000;
      v3 = *a1;
      if ( !*a1 )
        return result;
    }
  }
  return result;
}

//----- (0805AC40) --------------------------------------------------------
unsigned int __cdecl _setfpucw(unsigned __int16 a1)
{
  int v1; // edx
  int v2; // eax
  unsigned int result; // eax
  unsigned __int16 v4; // [esp+Eh] [ebp-6h]

  v1 = v4;
  v2 = a1;
  LOWORD(v2) = a1 & 0xF3F;
  LOWORD(v1) = v4 & 0xF0C0;
  result = v1 | v2;
  if ( (dl_hwcap & 0x2000000) != 0 )
  {
    result = _mm_getcsr() & 0xFFFF817F | (8 * (a1 & 0xC00)) | ((a1 & 0x3D) << 7);
    _mm_setcsr(result);
  }
  return result;
}
// 805AC4C: variable 'v4' is possibly undefined
// 80F0BD0: using guessed type int dl_hwcap;

//----- (0805ACB0) --------------------------------------------------------
void __noreturn abort()
{
  unsigned int v0; // edx
  bool v2; // zf
  int v3; // eax
  unsigned int v4; // edx
  bool v6; // zf
  char *v7; // eax
  char v8[140]; // [esp+14h] [ebp-118h] BYREF
  int v9[35]; // [esp+A0h] [ebp-8Ch] BYREF

  v0 = __readgsdword(8u);
  if ( v0 != dword_80F0CB0 )
  {
    _ECX = 1;
    v2 = __readgsdword(0xCu) == 0;
    if ( !v2 )
      __asm { lock }
    __asm { cmpxchg ds:lock_1, ecx }
    if ( !v2 )
      L_lock_19_0(0);
    dword_80F0CB0 = v0;
  }
  v3 = stage;
  ++dword_80F0CAC;
  if ( !stage )
  {
    memset(v9, 0, 0x80u);
    stage = 1;
    v9[0] = 32;
    sigprocmask(1, v9);
    v3 = stage;
  }
  if ( v3 == 1 )
  {
    stage = 2;
    IO_flush_all_lockp(0);
    v3 = stage;
  }
  if ( v3 == 2 )
  {
    stage = 0;
    if ( !--dword_80F0CAC )
    {
      dword_80F0CB0 = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --lock_1 )
        L_unlock_142();
    }
    raise();
    v4 = __readgsdword(8u);
    if ( v4 != dword_80F0CB0 )
    {
      _ECX = 1;
      v6 = __readgsdword(0xCu) == 0;
      if ( !v6 )
        __asm { lock }
      __asm { cmpxchg ds:lock_1, ecx }
      if ( !v6 )
        L_lock_161(0);
      dword_80F0CB0 = v4;
    }
    ++dword_80F0CAC;
  }
  else if ( v3 != 3 )
  {
    goto LABEL_12;
  }
  memset(v8, 0, sizeof(v8));
  v7 = &v8[128];
  stage = 4;
  do
  {
    *(_DWORD *)v7 = -1;
    v7 -= 4;
  }
  while ( v7 != v8 );
  sigaction(6, (int *)v7, 0);
  v3 = stage;
LABEL_12:
  if ( v3 == 4 )
  {
    stage = 5;
    fcloseall();
    v3 = stage;
  }
  if ( v3 == 5 )
  {
    stage = 6;
    raise();
    v3 = stage;
  }
  if ( v3 != 6 )
  {
    if ( v3 != 7 )
      __halt();
    stage = 8;
    exit(127);
  }
  __halt();
}
// 805ACB0: using guessed type void __noreturn abort();
// 805AECA: using guessed type void __noreturn L_unlock_142(void);
// 8067700: using guessed type int fcloseall(void);
// 80F0CA8: using guessed type int lock_1;
// 80F0CAC: using guessed type int dword_80F0CAC;
// 80F0CB0: using guessed type int dword_80F0CB0;
// 80F0CB4: using guessed type int stage;

//----- (0805AEBA) --------------------------------------------------------
void __usercall __noreturn L_lock_19_0(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &lock_1);
  JUMPOUT(0x805ACE5);
}
// 805AEC5: control flows out of bounds to 805ACE5
// 80F0CA8: using guessed type int lock_1;

//----- (0805AECA) --------------------------------------------------------
void __noreturn L_unlock_142()
{
  _lll_unlock_wake_private(&lock_1);
  JUMPOUT(0x805AE04);
}
// 805AED5: control flows out of bounds to 805AE04
// 805AECA: using guessed type void __noreturn L_unlock_142();
// 80F0CA8: using guessed type int lock_1;

//----- (0805AEDA) --------------------------------------------------------
void __usercall __noreturn L_lock_161(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &lock_1);
  JUMPOUT(0x805AE3E);
}
// 805AEE5: control flows out of bounds to 805AE3E
// 80F0CA8: using guessed type int lock_1;

//----- (0805AEF0) --------------------------------------------------------
int __cdecl bsearch(int a1, int a2, unsigned int a3, int a4, int (__cdecl *a5)(int, int))
{
  int v5; // ebp
  unsigned int v6; // edi
  unsigned int v7; // esi
  unsigned int v8; // ebx
  int v9; // eax

  v5 = 0;
  v6 = a3;
  if ( a3 )
  {
    v7 = 0;
    do
    {
      while ( 1 )
      {
        v8 = (v6 + v7) >> 1;
        v5 = a2 + v8 * a4;
        v9 = a5(a1, v5);
        if ( v9 >= 0 )
          break;
        v6 = (v6 + v7) >> 1;
        if ( v7 >= v8 )
          return 0;
      }
      if ( !v9 )
        return v5;
      v7 = v8 + 1;
    }
    while ( v8 + 1 < v6 );
    return 0;
  }
  return v5;
}

//----- (0805AF50) --------------------------------------------------------
_BYTE *__usercall msort_with_tmp_part_0@<eax>(unsigned int *a1@<eax>, int *a2@<edx>, unsigned int a3@<ecx>)
{
  unsigned int v3; // ecx
  unsigned int v4; // ebp
  int *v5; // ebx
  _WORD *v6; // esi
  unsigned int v7; // eax
  int *i; // edi
  _WORD *v9; // eax
  int v11; // eax
  int v12; // eax
  _WORD *v13; // eax
  int v14; // eax
  int v15; // edx
  int *v16; // edx
  _WORD *v17; // edi
  int v18; // eax
  int *v19; // eax
  int v20; // ecx
  int *v21; // [esp+10h] [ebp-3Ch]
  unsigned int v22; // [esp+14h] [ebp-38h]
  int (__cdecl *v23)(int *, int *, unsigned int); // [esp+18h] [ebp-34h]
  unsigned int v24; // [esp+1Ch] [ebp-30h]
  unsigned int v25; // [esp+20h] [ebp-2Ch]

  v3 = a3 >> 1;
  v4 = a3 - v3;
  v22 = v3;
  v5 = (int *)((char *)a2 + v3 * *a1);
  if ( v3 > 1 )
    ((void (*)(void))msort_with_tmp_part_0)();
  if ( v4 > 1 )
    msort_with_tmp_part_0(v4, v5);
  v6 = (_WORD *)a1[4];
  v25 = *a1;
  v7 = a1[1];
  v23 = (int (__cdecl *)(int *, int *, unsigned int))a1[2];
  v24 = a1[3];
  switch ( v7 )
  {
    case 1u:
      if ( v4 )
      {
        i = a2;
        if ( v22 )
        {
          do
          {
            if ( v23(i, v5, v24) > 0 )
            {
              v14 = *v5;
              --v4;
              v15 = v5[1];
              v5 += 2;
            }
            else
            {
              v14 = *i;
              v15 = i[1];
              i += 2;
              --v22;
            }
            *(_DWORD *)v6 = v14;
            *((_DWORD *)v6 + 1) = v15;
            v6 += 4;
          }
          while ( v4 && v22 );
          goto LABEL_13;
        }
      }
LABEL_51:
      i = a2;
      goto LABEL_13;
    case 0u:
      for ( i = a2; v4; v6 += 2 )
      {
        if ( !v22 )
          break;
        if ( v23(i, v5, v24) > 0 )
        {
          v11 = *v5;
          --v4;
          ++v5;
        }
        else
        {
          v11 = *i++;
          --v22;
        }
        *(_DWORD *)v6 = v11;
      }
      goto LABEL_13;
    case 2u:
      v16 = a2;
      while ( v4 )
      {
        if ( !v22 )
          break;
        v21 = v16;
        v17 = (_WORD *)((char *)v6 + v25);
        v18 = v23(v16, v5, v24);
        v16 = v21;
        if ( v18 <= 0 )
        {
          v19 = v21;
          --v22;
          v16 = (int *)((char *)v21 + v25);
        }
        else
        {
          v19 = v5;
          --v4;
          v5 = (int *)((char *)v5 + v25);
        }
        if ( v6 < v17 )
        {
          do
          {
            v20 = *v19++;
            *(_DWORD *)v6 = v20;
            v6 += 2;
          }
          while ( v17 > v6 );
          v6 = v17;
        }
        else
        {
          v6 = (_WORD *)((char *)v6 + v25);
        }
      }
      i = v16;
      goto LABEL_13;
  }
  i = a2;
  if ( v7 == 3 )
  {
    if ( v4 )
    {
      i = a2;
      if ( v22 )
      {
        do
        {
          if ( v23((int *)*i, (int *)*v5, v24) > 0 )
          {
            v12 = *v5;
            --v4;
            ++v5;
          }
          else
          {
            v12 = *i++;
            --v22;
          }
          *(_DWORD *)v6 = v12;
          v6 += 2;
        }
        while ( v4 && v22 );
        goto LABEL_13;
      }
    }
    goto LABEL_51;
  }
LABEL_9:
  if ( v4 )
  {
    while ( v22 )
    {
      if ( v23(i, v5, v24) <= 0 )
      {
        v13 = mempcpy(v6, i, v25);
        i = (int *)((char *)i + v25);
        --v22;
        v6 = v13;
        goto LABEL_9;
      }
      --v4;
      v9 = mempcpy(v6, v5, v25);
      v5 = (int *)((char *)v5 + v25);
      v6 = v9;
      if ( !v4 )
        break;
    }
  }
LABEL_13:
  if ( v22 )
    memcpy(v6, i, v25 * v22);
  return memcpy(a2, (_BYTE *)a1[4], v25 * (a3 - v4));
}

//----- (0805B280) --------------------------------------------------------
unsigned int __usercall qsort_r@<eax>(
        long double a1@<st0>,
        unsigned int a2,
        unsigned int a3,
        unsigned int a4,
        int (__cdecl *a5)(unsigned int, unsigned int, int),
        int a6)
{
  unsigned int v6; // ebx
  unsigned int v7; // ecx
  unsigned int v8; // edi
  int v9; // eax
  unsigned int v10; // edi
  int *v11; // edx
  unsigned int v12; // edx
  unsigned int *v13; // eax
  unsigned int *v14; // ebx
  _BYTE *v15; // ebx
  _BYTE *v16; // ecx
  _BYTE **v17; // edx
  void *v19; // esp
  int v20; // eax
  int v21; // ecx
  int v22; // edx
  int v23; // eax
  _DWORD v24[2]; // [esp+20h] [ebp-58h] BYREF
  _DWORD *v25; // [esp+28h] [ebp-50h]
  unsigned int *v26; // [esp+2Ch] [ebp-4Ch]
  unsigned int v27; // [esp+30h] [ebp-48h]
  _BYTE *v28; // [esp+34h] [ebp-44h]
  unsigned int i; // [esp+38h] [ebp-40h]
  unsigned int v30; // [esp+3Ch] [ebp-3Ch]
  unsigned int v31; // [esp+4Ch] [ebp-2Ch] BYREF
  int v32; // [esp+50h] [ebp-28h]
  int (__cdecl *v33)(unsigned int, unsigned int, int); // [esp+54h] [ebp-24h]
  int v34; // [esp+58h] [ebp-20h]
  _DWORD *v35; // [esp+5Ch] [ebp-1Ch]

  v6 = a4 + 8 * a3;
  if ( a4 <= 0x20 )
    v6 = a4 * a3;
  if ( v6 <= 0x3FF )
  {
    v19 = alloca(v6 + 15);
    v35 = v24;
    v25 = 0;
  }
  else
  {
    v7 = pagesize_6803;
    if ( !pagesize_6803 )
    {
      sysconf(0, a1, 85);
      v22 = 0x1FFFFFFF;
      if ( v20 != -1 )
        v22 = v20 / 4;
      phys_pages_6802 = v22;
      sysconf(v21, a1, 30);
      v7 = v23;
      pagesize_6803 = v23;
    }
    if ( v6 / v7 > phys_pages_6802 )
      return quicksort(a2, a3, a4, a5, a6);
    v8 = __readgsdword(0xFFFFFFE8);
    v24[1] = -24;
    v9 = malloc(v6);
    __writegsdword(0xFFFFFFE8, v8);
    v25 = (_DWORD *)v9;
    if ( !v9 )
      return quicksort(a2, a3, a4, a5, a6);
    v35 = v25;
  }
  v31 = a4;
  v32 = 4;
  v33 = a5;
  v34 = a6;
  if ( a4 > 0x20 )
  {
    v10 = (unsigned int)&v35[a3];
    v26 = (unsigned int *)(v10 + 4 * a3);
    v11 = (int *)v10;
    if ( v10 < (unsigned int)v26 )
    {
      v12 = a2;
      v13 = &v35[a3];
      v14 = v26;
      do
      {
        *v13++ = v12;
        v12 += a4;
      }
      while ( v14 > v13 );
      v11 = &v35[a3];
    }
    v31 = 4;
    v32 = 3;
    if ( a3 <= 1 )
    {
      if ( !a3 )
        return free(v25);
    }
    else
    {
      msort_with_tmp_part_0(&v31, v11, a3);
    }
    v27 = 0;
    v28 = (_BYTE *)a2;
    do
    {
      v15 = *(_BYTE **)(v10 + 4 * v27);
      if ( v15 != v28 )
      {
        memcpy(v26, v28, a4);
        v16 = v28;
        for ( i = v27; ; i = v30 )
        {
          v30 = (unsigned int)&v15[-a2] / a4;
          *(_DWORD *)(v10 + 4 * i) = v16;
          memcpy(v16, v15, a4);
          v17 = (_BYTE **)(v10 + 4 * v30);
          if ( *v17 == v28 )
            break;
          v16 = v15;
          v15 = *v17;
        }
        *v17 = v15;
        memcpy(v15, v26, a4);
      }
      ++v27;
      v28 += a4;
    }
    while ( v27 != a3 );
    return free(v25);
  }
  if ( (a4 & 3) == 0 && (a2 & 3) == 0 )
  {
    if ( a4 == 4 )
    {
      v32 = 0;
    }
    else if ( a4 != 8 || (a2 & 7) != 0 )
    {
      v32 = 2;
    }
    else
    {
      v32 = 1;
    }
  }
  if ( a3 <= 1 )
    return free(v25);
  msort_with_tmp_part_0(&v31, (int *)a2, a3);
  return free(v25);
}
// 805B4D4: variable 'v20' is possibly undefined
// 805B4EE: variable 'v21' is possibly undefined
// 805B4F3: variable 'v23' is possibly undefined
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80F0CB8: using guessed type int pagesize_6803;
// 80F0CBC: using guessed type int phys_pages_6802;

//----- (0805B560) --------------------------------------------------------
unsigned int __usercall qsort@<eax>(
        long double a1@<st0>,
        unsigned int a2,
        unsigned int a3,
        unsigned int a4,
        int (__cdecl *a5)(unsigned int, unsigned int, int))
{
  return qsort_r(a1, a2, a3, a4, a5, 0);
}

//----- (0805B5A0) --------------------------------------------------------
int __cdecl getenv(_BYTE *a1)
{
  char **v1; // ebx
  int result; // eax
  _WORD *v3; // edx
  __int16 v4; // ax
  __int16 v5; // di
  int v6; // esi
  int v7; // [esp+1Ch] [ebp-20h]

  v1 = environ;
  v7 = strlen(a1);
  if ( !environ )
    return 0;
  result = 0;
  if ( !*a1 )
    return result;
  if ( !a1[1] )
  {
    v3 = *environ;
    if ( !*environ )
      return result;
    LOBYTE(v4) = *a1;
    HIBYTE(v4) = 61;
    if ( v4 == *v3 )
      return (int)(v3 + 1);
    while ( 1 )
    {
      v3 = *++v1;
      if ( !*v1 )
        break;
      if ( v4 == *v3 )
        return (int)(v3 + 1);
    }
    return 0;
  }
  v5 = *(_WORD *)a1;
  v6 = (int)*environ;
  if ( *environ )
  {
    while ( v5 != *(_WORD *)v6 || strncmp((unsigned __int8 *)(v6 + 2), a1 + 2, v7 - 2) || *(_BYTE *)(v6 + v7) != 61 )
    {
      v6 = (int)*++v1;
      if ( !*v1 )
        return 0;
    }
    return v6 + v7 + 1;
  }
  return result;
}

//----- (0805B670) --------------------------------------------------------
void __usercall _add_to_environ(long double a1@<st0>, unsigned __int8 *a2, _BYTE *a3, unsigned __int8 *a4, int a5)
{
  int v5; // ebx
  bool v7; // zf
  unsigned __int8 **v8; // edi
  unsigned __int8 *v9; // esi
  int v10; // ebx
  unsigned int v11; // eax
  char **v12; // edi
  char **v13; // eax
  char **v14; // esi
  unsigned __int8 *v15; // edx
  int v16; // ecx
  void *v17; // esp
  char *v18; // edi
  _BYTE *v19; // eax
  char **v20; // ebx
  char **v21; // eax
  unsigned __int8 *v22; // edx
  int v23; // ecx
  char *v24; // eax
  char *v25; // eax
  unsigned __int8 *v26; // edx
  _BOOL4 v27; // eax
  char *v28; // eax
  unsigned __int8 *v29; // esi
  int v30; // ecx
  void *v31; // esp
  unsigned __int8 *v32; // edx
  _BYTE *v33; // eax
  unsigned __int8 **v34; // eax
  unsigned __int8 *v35; // eax
  unsigned __int8 *v36; // eax
  _BYTE v37[12]; // [esp+10h] [ebp-38h] BYREF
  unsigned __int8 *v38; // [esp+1Ch] [ebp-2Ch]
  int v39; // [esp+20h] [ebp-28h]
  unsigned int v40; // [esp+24h] [ebp-24h]
  int v41; // [esp+28h] [ebp-20h]
  unsigned int v42; // [esp+2Ch] [ebp-1Ch]

  v40 = 0;
  v5 = strlen(a2);
  if ( a3 )
    v40 = strlen(a3) + 1;
  _ECX = 1;
  v7 = __readgsdword(0xCu) == 0;
  if ( !v7 )
    __asm { lock }
  __asm { cmpxchg ds:envlock, ecx }
  if ( !v7 )
  {
    L_lock_44(0);
    return;
  }
  v8 = (unsigned __int8 **)environ;
  if ( environ )
  {
    v9 = (unsigned __int8 *)*environ;
    v41 = 0;
    if ( v9 )
    {
      v42 = v5;
      v10 = 0;
      do
      {
        if ( !strncmp(v9, a2, v42) && v9[v42] == 61 )
          break;
        ++v8;
        ++v10;
        v9 = *v8;
      }
      while ( *v8 );
      v41 = v10;
      v5 = v42;
      if ( v8 )
      {
        if ( *v8 )
        {
          if ( a5 )
          {
            v29 = a4;
            if ( !a4 )
            {
              v42 += v40 + 1;
              if ( v42 <= 0x1000 || _libc_alloca_cutoff(v40 + v5 + 1) )
              {
                v30 = 1;
                v31 = alloca(v42 + 15);
                v32 = v37;
              }
              else
              {
                malloc(a1, v42);
                v32 = v36;
                if ( !v36 )
                  goto LABEL_36;
                v30 = 0;
              }
              v39 = v30;
              v38 = v32;
              v33 = mempcpy(v32, a2, v5);
              *v33 = 61;
              memcpy(v33 + 1, a3, v40);
              v34 = (unsigned __int8 **)tfind((int)v38, &known_values, (int (__cdecl *)(int, _DWORD))strcmp);
              if ( !v34 || (v29 = *v34) == 0 )
              {
                if ( v39 )
                {
                  malloc(a1, v42);
                  v29 = v35;
                  if ( !v35 )
                    goto LABEL_36;
                  memcpy(v35, v38, v42);
                }
                else
                {
                  v29 = v38;
                }
                tsearch((int)v29, &known_values, (int (__cdecl *)(int, _DWORD))strcmp);
              }
            }
            *v8 = v29;
          }
LABEL_21:
          if ( __readgsdword(0xCu) )
            __asm { lock }
          if ( --envlock )
            L_unlock_163();
          return;
        }
      }
    }
    v11 = 4 * v41 + 8;
  }
  else
  {
    v11 = 8;
    v41 = 0;
  }
  v12 = (char **)last_environ;
  realloc((_BYTE *)last_environ, v11);
  v14 = v13;
  if ( v13 )
  {
    if ( a4 )
    {
      v13[v41] = (char *)a4;
LABEL_18:
      if ( v12 != environ )
        memcpy(v14, environ, 4 * v41);
      last_environ = (int)v14;
      v14[v41 + 1] = 0;
      environ = v14;
      goto LABEL_21;
    }
    v15 = (unsigned __int8 *)(v40 + v5 + 1);
    if ( (unsigned int)v15 <= 0x1000
      || (v38 = (unsigned __int8 *)(v40 + v5 + 1), v27 = _libc_alloca_cutoff((unsigned int)v38), v15 = v38, v27) )
    {
      v16 = 1;
      v17 = alloca((int)(v15 + 15));
      v18 = v37;
    }
    else
    {
      malloc(a1, (size_t)v38);
      v16 = 0;
      v15 = v38;
      v18 = v28;
      if ( !v28 )
      {
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --envlock )
        {
          L_unlock_362();
        }
        else if ( !last_environ )
        {
          free(a1, (int)v14);
        }
        return;
      }
    }
    v38 = v15;
    v39 = v16;
    v19 = mempcpy(v18, a2, v5);
    *v19 = 61;
    memcpy(v19 + 1, a3, v40);
    v20 = &v14[v41];
    v21 = (char **)tfind((int)v18, &known_values, (int (__cdecl *)(int, _DWORD))strcmp);
    v22 = v38;
    v23 = v39;
    if ( v21 )
    {
      v24 = *v21;
      *v20 = v24;
      if ( v24 )
      {
LABEL_34:
        v12 = (char **)last_environ;
        goto LABEL_18;
      }
    }
    else
    {
      *v20 = 0;
    }
    if ( !v23 )
    {
      *v20 = v18;
      goto LABEL_33;
    }
    v38 = v22;
    malloc(a1, (size_t)v22);
    v26 = v38;
    *v20 = v25;
    if ( v25 )
    {
      memcpy(v25, v18, (unsigned int)v26);
      v18 = *v20;
LABEL_33:
      tsearch((int)v18, &known_values, (int (__cdecl *)(int, _DWORD))strcmp);
      goto LABEL_34;
    }
  }
LABEL_36:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --envlock )
    L_unlock_317();
}
// 805B749: variable 'v13' is possibly undefined
// 805B878: variable 'v25' is possibly undefined
// 805B907: variable 'v28' is possibly undefined
// 805BA0E: variable 'v35' is possibly undefined
// 805BA63: variable 'v36' is possibly undefined
// 80F0CC0: using guessed type int envlock;
// 80F0CC4: using guessed type int last_environ;
// 80F0CC8: using guessed type int known_values;

//----- (0805BA80) --------------------------------------------------------
void __usercall setenv(long double a1@<st0>, char *s, _BYTE *a3, int a4)
{
  if ( s && *s && !strchr(s, 61) )
    _add_to_environ(a1, (unsigned __int8 *)s, a3, 0, a4);
  else
    __writegsdword(0xFFFFFFE8, 0x16u);
}

//----- (0805BAF0) --------------------------------------------------------
void __cdecl unsetenv(char *s)
{
  int v1; // eax
  unsigned int v3; // esi
  bool v4; // zf
  unsigned __int8 **v5; // ebp
  unsigned __int8 *v6; // edi
  unsigned __int8 **v7; // eax
  unsigned __int8 *v8; // edx

  if ( s && *s && !strchr(s, 61) )
  {
    v1 = strlen(s);
    _ECX = 1;
    v3 = v1;
    v4 = __readgsdword(0xCu) == 0;
    if ( !v4 )
      __asm { lock }
    __asm { cmpxchg ds:envlock, ecx }
    if ( v4 )
    {
      v5 = (unsigned __int8 **)environ;
      if ( environ )
      {
        while ( 1 )
        {
          v6 = *v5;
          if ( !*v5 )
            break;
          while ( strncmp(v6, (unsigned __int8 *)s, v3) || v6[v3] != 61 )
          {
            v6 = *++v5;
            if ( !*v5 )
              goto LABEL_12;
          }
          v7 = v5;
          do
          {
            v8 = v7[1];
            *v7++ = v8;
          }
          while ( v8 );
        }
      }
LABEL_12:
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --envlock )
        L_unlock_668();
    }
    else
    {
      L_lock_631(0);
    }
  }
  else
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
  }
}
// 80F0CC0: using guessed type int envlock;

//----- (0805BBE0) --------------------------------------------------------
void __usercall clearenv(long double a1@<st0>)
{
  bool v2; // zf

  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg ds:envlock, ecx }
  if ( v2 )
  {
    if ( environ == (char **)last_environ && environ )
    {
      free(a1, (int)environ);
      last_environ = 0;
    }
    environ = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --envlock )
      L_unlock_742();
  }
  else
  {
    L_lock_733(0);
  }
}
// 80F0CC0: using guessed type int envlock;
// 80F0CC4: using guessed type int last_environ;

//----- (0805BC50) --------------------------------------------------------
void __usercall L_lock_44(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &envlock);
  JUMPOUT(0x805B6C4);
}
// 805BC5B: control flows out of bounds to 805B6C4
// 80F0CC0: using guessed type int envlock;

//----- (0805BC60) --------------------------------------------------------
void L_unlock_163()
{
  _lll_unlock_wake_private(&envlock);
  JUMPOUT(0x805B7B3);
}
// 805BC6B: control flows out of bounds to 805B7B3
// 80F0CC0: using guessed type int envlock;

//----- (0805BC70) --------------------------------------------------------
void L_unlock_317()
{
  _lll_unlock_wake_private(&envlock);
  JUMPOUT(0x805B8D1);
}
// 805BC7B: control flows out of bounds to 805B8D1
// 80F0CC0: using guessed type int envlock;

//----- (0805BC80) --------------------------------------------------------
void L_unlock_362()
{
  _lll_unlock_wake_private(&envlock);
  JUMPOUT(0x805B927);
}
// 805BC8B: control flows out of bounds to 805B927
// 80F0CC0: using guessed type int envlock;

//----- (0805BC90) --------------------------------------------------------
void __usercall L_lock_631(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &envlock);
  JUMPOUT(0x805BB4F);
}
// 805BC9B: control flows out of bounds to 805BB4F
// 80F0CC0: using guessed type int envlock;

//----- (0805BCA0) --------------------------------------------------------
void L_unlock_668()
{
  _lll_unlock_wake_private(&envlock);
  JUMPOUT(0x805BB9C);
}
// 805BCAB: control flows out of bounds to 805BB9C
// 80F0CC0: using guessed type int envlock;

//----- (0805BCB0) --------------------------------------------------------
void __usercall L_lock_733(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &envlock);
  JUMPOUT(0x805BC02);
}
// 805BCBB: control flows out of bounds to 805BC02
// 80F0CC0: using guessed type int envlock;

//----- (0805BCC0) --------------------------------------------------------
void L_unlock_742()
{
  _lll_unlock_wake_private(&envlock);
  JUMPOUT(0x805BC31);
}
// 805BCCB: control flows out of bounds to 805BC31
// 80F0CC0: using guessed type int envlock;

//----- (0805BCD0) --------------------------------------------------------
int __cdecl _secure_getenv(_BYTE *a1)
{
  if ( _libc_enable_secure )
    return 0;
  else
    return getenv(a1);
}
// 80EEFC8: using guessed type int _libc_enable_secure;

//----- (0805BCF0) --------------------------------------------------------
unsigned int __cdecl _strtol_internal(char *a1, char **a2, int a3, int a4)
{
  return ___strtol_l_internal(a1, a2, a3, a4, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (0805BD30) --------------------------------------------------------
unsigned int __cdecl strtol(char *a1, char **a2, int a3)
{
  return ___strtol_l_internal(a1, a2, a3, 0, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (0805BD70) --------------------------------------------------------
int __cdecl _strtoul_internal(char *a1, char **a2, int a3, int a4)
{
  return ___strtoul_l_internal(a1, a2, a3, a4, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (0805BDB0) --------------------------------------------------------
int __cdecl strtoul(char *a1, char **a2, int a3)
{
  return ___strtoul_l_internal(a1, a2, a3, 0, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (0805BDF0) --------------------------------------------------------
unsigned int __cdecl ___strtol_l_internal(char *a1, char **a2, int a3, int a4, _DWORD *a5)
{
  int v5; // eax
  char *v6; // ecx
  _BYTE *v7; // esi
  char *v8; // edi
  char v9; // al
  int v10; // ebp
  char *v11; // edi
  int v12; // eax
  int v13; // ebx
  unsigned __int8 v14; // cl
  char *v15; // edx
  unsigned int v16; // ebp
  unsigned __int8 v17; // al
  int v18; // eax
  char *v19; // eax
  unsigned int result; // eax
  char v21; // dl
  int v22; // eax
  unsigned __int8 v23; // al
  int v24; // edx
  unsigned int v25; // eax
  char *v26; // [esp+1Ch] [ebp-40h]
  char *v27; // [esp+20h] [ebp-3Ch]
  unsigned int v28; // [esp+24h] [ebp-38h]
  char *v29; // [esp+28h] [ebp-34h]
  char v30; // [esp+2Ch] [ebp-30h]
  int v31; // [esp+2Ch] [ebp-30h]
  unsigned int v32; // [esp+30h] [ebp-2Ch]
  int v33; // [esp+34h] [ebp-28h]

  v5 = a5[1];
  if ( !a4 || (v6 = *(char **)(v5 + 44), (unsigned __int8)(*v6 - 1) > 0x7Du) || (v7 = *(_BYTE **)(v5 + 40), !*v7) )
  {
    v6 = 0;
    v7 = 0;
  }
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    return 0;
  }
  v8 = a1;
  v9 = *a1;
  v10 = a5[13];
  if ( (*(_BYTE *)(v10 + 2 * *a1 + 1) & 0x20) != 0 )
  {
    do
      v9 = *++v8;
    while ( (*(_BYTE *)(v10 + 2 * *v8 + 1) & 0x20) != 0 );
  }
  if ( !v9 )
  {
    v11 = a1;
LABEL_45:
    result = 0;
    if ( a2 )
    {
      if ( v11 - a1 > 1 && *(_DWORD *)(a5[15] + 4 * *(v11 - 1)) == 88 && *(v11 - 2) == 48 )
      {
        *a2 = v11 - 1;
      }
      else
      {
        result = 0;
        *a2 = a1;
      }
    }
    return result;
  }
  if ( v9 == 45 )
  {
    v11 = v8 + 1;
    v33 = 1;
  }
  else
  {
    v33 = 0;
    v11 = &v8[v9 == 43];
  }
  v30 = *v11;
  if ( *v11 == 48 )
  {
    if ( a3 == 16 || !a3 )
    {
      if ( *(_DWORD *)(a5[15] + 4 * v11[1]) == 88 )
      {
        v21 = v11[2];
        v12 = 14;
        v11 += 2;
        a3 = 16;
        v30 = v21;
        goto LABEL_14;
      }
      if ( !a3 )
      {
        v12 = 6;
        a3 = 8;
        goto LABEL_14;
      }
    }
  }
  else if ( !a3 )
  {
    goto LABEL_36;
  }
  if ( a3 != 10 )
  {
    v12 = a3 - 2;
LABEL_14:
    v13 = 0;
    v29 = 0;
    goto LABEL_15;
  }
LABEL_36:
  if ( !v6 )
  {
    v12 = 8;
    v13 = 0;
    a3 = 10;
    v29 = 0;
    goto LABEL_15;
  }
  v26 = v6;
  v13 = strlen(v7);
  if ( !v13 )
    goto LABEL_67;
  if ( v30 == *v7 )
  {
    v22 = 0;
    while ( ++v22 != v13 )
    {
      if ( v7[v22] != v11[v22] )
        goto LABEL_72;
    }
LABEL_67:
    v29 = v11;
    v12 = 8;
    a3 = 10;
    goto LABEL_15;
  }
LABEL_72:
  v23 = *v11;
  v27 = v11;
  if ( v30 )
  {
    do
    {
      if ( (unsigned __int8)(v23 - 48) > 9u )
      {
        if ( *v27 == *v7 )
        {
          v24 = 0;
          while ( ++v24 != v13 )
          {
            if ( v7[v24] != v27[v24] )
              goto LABEL_80;
          }
        }
        else
        {
LABEL_80:
          if ( (*(_BYTE *)(v10 + 2 * v23 + 1) & 4) == 0 || *(int *)(a5[15] + 4 * v23) > 64 )
            break;
        }
      }
      v23 = *++v27;
    }
    while ( *v27 );
  }
  v25 = _correctly_grouped_prefixmb((unsigned int)v11, (unsigned int)v27, v7, v26);
  a3 = 10;
  v30 = *v11;
  v29 = (char *)v25;
  v12 = 8;
LABEL_15:
  v28 = _strtol_ul_max_tab[v12];
  v14 = v30;
  v32 = (unsigned __int8)_strtol_ul_rem_tab[v12];
  if ( !v30 )
    goto LABEL_45;
  if ( v29 == v11 )
  {
    v11 = v29;
    goto LABEL_45;
  }
  v15 = v11;
  v16 = 0;
  v31 = 0;
  while ( 1 )
  {
    v17 = v14 - 48;
    if ( (unsigned __int8)(v14 - 48) <= 9u )
      break;
    if ( !v13 || *v7 != *v15 )
    {
LABEL_38:
      if ( (*(_BYTE *)(a5[13] + 2 * v14 + 1) & 4) == 0 )
        goto LABEL_44;
      v17 = *(_DWORD *)(a5[15] + 4 * v14) - 55;
      break;
    }
    v18 = 0;
    while ( ++v18 != v13 )
    {
      if ( v7[v18] != v15[v18] )
        goto LABEL_38;
    }
    v19 = &v15[v13 - 1];
LABEL_25:
    v14 = v19[1];
    v15 = v19 + 1;
    if ( !v14 )
      goto LABEL_44;
LABEL_26:
    if ( v29 == v15 )
      goto LABEL_27;
  }
  if ( a3 <= v17 )
    goto LABEL_44;
  if ( v28 < v16 || v16 == v28 && v32 < v17 )
  {
    v19 = v15;
    v31 = 1;
    goto LABEL_25;
  }
  v16 = v17 + a3 * v16;
  v14 = *++v15;
  if ( v14 )
    goto LABEL_26;
LABEL_44:
  if ( v11 == v15 )
    goto LABEL_45;
LABEL_27:
  if ( a2 )
    *a2 = v15;
  if ( v31 || 0x80000000 - (v33 == 0) < v16 )
  {
    __writegsdword(0xFFFFFFE8, 0x22u);
    return 0x80000000 - (v33 == 0);
  }
  else
  {
    result = -v16;
    if ( !v33 )
      return v16;
  }
  return result;
}
// 80C9480: using guessed type int _strtol_ul_max_tab[34];

//----- (0805C290) --------------------------------------------------------
unsigned int __cdecl strtol_l(char *a1, char **a2, int a3, _DWORD *a4)
{
  return ___strtol_l_internal(a1, a2, a3, 0, a4);
}

//----- (0805C2D0) --------------------------------------------------------
int __cdecl ___strtoul_l_internal(char *a1, char **a2, int a3, int a4, _DWORD *a5)
{
  int v5; // eax
  char *v6; // ecx
  _BYTE *v7; // esi
  char *v8; // edi
  int v9; // ebp
  char v10; // al
  char *v11; // edi
  int v12; // eax
  int v13; // ebx
  unsigned __int8 v14; // al
  char *v15; // ecx
  unsigned int v16; // ebp
  unsigned __int8 v17; // dl
  int v18; // edx
  char *v19; // eax
  int v21; // ebp
  char v22; // dl
  int v23; // eax
  unsigned __int8 v24; // al
  int v25; // edx
  unsigned int v26; // eax
  char *v27; // [esp+1Ch] [ebp-40h]
  char *v28; // [esp+20h] [ebp-3Ch]
  unsigned int v29; // [esp+24h] [ebp-38h]
  char *v30; // [esp+28h] [ebp-34h]
  char v31; // [esp+2Ch] [ebp-30h]
  int v32; // [esp+2Ch] [ebp-30h]
  unsigned int v33; // [esp+30h] [ebp-2Ch]
  int v34; // [esp+38h] [ebp-24h]

  v5 = a5[1];
  if ( !a4 || (v6 = *(char **)(v5 + 44), (unsigned __int8)(*v6 - 1) > 0x7Du) || (v7 = *(_BYTE **)(v5 + 40), !*v7) )
  {
    v6 = 0;
    v7 = 0;
  }
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    v21 = 0;
    __writegsdword(0xFFFFFFE8, 0x16u);
    return v21;
  }
  v8 = a1;
  v9 = a5[13];
  v10 = *a1;
  if ( (*(_BYTE *)(v9 + 2 * *a1 + 1) & 0x20) != 0 )
  {
    do
      v10 = *++v8;
    while ( (*(_BYTE *)(v9 + 2 * *v8 + 1) & 0x20) != 0 );
  }
  if ( !v10 )
  {
    v11 = a1;
LABEL_44:
    v21 = 0;
    if ( a2 )
    {
      if ( v11 - a1 > 1 && *(_DWORD *)(a5[15] + 4 * *(v11 - 1)) == 88 && *(v11 - 2) == 48 )
      {
        *a2 = v11 - 1;
      }
      else
      {
        *a2 = a1;
        return 0;
      }
    }
    return v21;
  }
  if ( v10 == 45 )
  {
    v11 = v8 + 1;
    v34 = 1;
  }
  else
  {
    v34 = 0;
    v11 = &v8[v10 == 43];
  }
  v31 = *v11;
  if ( *v11 == 48 )
  {
    if ( a3 == 16 || !a3 )
    {
      if ( *(_DWORD *)(a5[15] + 4 * v11[1]) == 88 )
      {
        v22 = v11[2];
        v12 = 14;
        v11 += 2;
        a3 = 16;
        v31 = v22;
        goto LABEL_14;
      }
      if ( !a3 )
      {
        v12 = 6;
        a3 = 8;
        goto LABEL_14;
      }
    }
  }
  else if ( !a3 )
  {
    goto LABEL_35;
  }
  if ( a3 != 10 )
  {
    v12 = a3 - 2;
LABEL_14:
    v13 = 0;
    v30 = 0;
    goto LABEL_15;
  }
LABEL_35:
  if ( !v6 )
  {
    v12 = 8;
    v13 = 0;
    a3 = 10;
    v30 = 0;
    goto LABEL_15;
  }
  v27 = v6;
  v13 = strlen(v7);
  if ( !v13 )
    goto LABEL_66;
  if ( v31 == *v7 )
  {
    v23 = 0;
    while ( ++v23 != v13 )
    {
      if ( v7[v23] != v11[v23] )
        goto LABEL_71;
    }
LABEL_66:
    v30 = v11;
    v12 = 8;
    a3 = 10;
    goto LABEL_15;
  }
LABEL_71:
  v24 = *v11;
  v28 = v11;
  if ( v31 )
  {
    do
    {
      if ( (unsigned __int8)(v24 - 48) > 9u )
      {
        if ( *v28 == *v7 )
        {
          v25 = 0;
          while ( ++v25 != v13 )
          {
            if ( v7[v25] != v28[v25] )
              goto LABEL_79;
          }
        }
        else
        {
LABEL_79:
          if ( (*(_BYTE *)(v9 + 2 * v24 + 1) & 4) == 0 || *(int *)(a5[15] + 4 * v24) > 64 )
            break;
        }
      }
      v24 = *++v28;
    }
    while ( *v28 );
  }
  v26 = _correctly_grouped_prefixmb((unsigned int)v11, (unsigned int)v28, v7, v27);
  a3 = 10;
  v31 = *v11;
  v30 = (char *)v26;
  v12 = 8;
LABEL_15:
  v29 = _strtol_ul_max_tab[v12];
  v33 = (unsigned __int8)_strtol_ul_rem_tab[v12];
  v14 = v31;
  if ( !v31 )
    goto LABEL_44;
  if ( v30 == v11 )
  {
    v11 = v30;
    goto LABEL_44;
  }
  v15 = v11;
  v16 = 0;
  v32 = 0;
  while ( 1 )
  {
    v17 = v14 - 48;
    if ( (unsigned __int8)(v14 - 48) <= 9u )
      break;
    if ( !v13 || *v7 != *v15 )
    {
LABEL_37:
      if ( (*(_BYTE *)(a5[13] + 2 * v14 + 1) & 4) == 0 )
        goto LABEL_43;
      v17 = *(_DWORD *)(a5[15] + 4 * v14) - 55;
      break;
    }
    v18 = 0;
    while ( ++v18 != v13 )
    {
      if ( v7[v18] != v15[v18] )
        goto LABEL_37;
    }
    v19 = &v15[v13 - 1];
LABEL_25:
    v15 = v19 + 1;
    v14 = v19[1];
    if ( !v14 )
      goto LABEL_43;
LABEL_26:
    if ( v30 == v15 )
      goto LABEL_27;
  }
  if ( a3 <= v17 )
    goto LABEL_43;
  if ( v29 < v16 || v16 == v29 && v33 < v17 )
  {
    v19 = v15;
    v32 = 1;
    goto LABEL_25;
  }
  v14 = *++v15;
  v16 = v17 + a3 * v16;
  if ( *v15 )
    goto LABEL_26;
LABEL_43:
  if ( v11 == v15 )
    goto LABEL_44;
LABEL_27:
  if ( a2 )
    *a2 = v15;
  if ( v32 )
  {
    v21 = -1;
    __writegsdword(0xFFFFFFE8, 0x22u);
    return v21;
  }
  if ( v34 )
    return -v16;
  return v16;
}
// 80C9480: using guessed type int _strtol_ul_max_tab[34];

//----- (0805C750) --------------------------------------------------------
int __cdecl strtoul_l(char *a1, char **a2, int a3, _DWORD *a4)
{
  return ___strtoul_l_internal(a1, a2, a3, 0, a4);
}

//----- (0805C790) --------------------------------------------------------
unsigned int __cdecl _correctly_grouped_prefixmb(unsigned int a1, unsigned int a2, _BYTE *a3, char *a4)
{
  int v4; // eax
  unsigned int v5; // ebp
  unsigned int v6; // esi
  char v7; // di
  char v8; // al
  _BYTE *v9; // eax
  unsigned int v10; // edx
  char v11; // bl
  char v12; // cl
  int v13; // eax
  unsigned int v14; // edx
  unsigned int v16; // esi
  unsigned int v17; // ebp
  _BYTE *v18; // eax
  unsigned int v19; // ecx
  char v20; // bl
  char v21; // dl
  unsigned int v22; // ebp
  _BYTE *v23; // eax
  unsigned int v24; // ecx
  char v25; // bl
  char v26; // dl
  signed int v27; // esi
  unsigned int v28; // [esp+1Ch] [ebp-30h]
  int v29; // [esp+20h] [ebp-2Ch]
  unsigned __int8 v30; // [esp+27h] [ebp-25h]
  unsigned __int8 *v31; // [esp+28h] [ebp-24h]
  unsigned int v32; // [esp+2Ch] [ebp-20h]

  if ( a4 )
  {
    v4 = strlen(a3);
    if ( a2 <= a1 )
    {
LABEL_19:
      v14 = a1;
      if ( a2 >= a1 )
        return a2;
      return v14;
    }
    else
    {
      v29 = v4 - 1;
      while ( 1 )
      {
        v5 = a2 - 1;
        if ( a1 > a2 - 1 )
          break;
        v6 = v29 + a2;
        v7 = *a3;
        while ( 1 )
        {
          if ( v7 == *(_BYTE *)(v6 - 1) )
          {
            v8 = a3[1];
            if ( !v8 )
              goto LABEL_13;
            if ( v8 == *(_BYTE *)(v6 - 2) )
              break;
          }
LABEL_6:
          --v5;
          --v6;
          if ( a1 > v5 )
            return a2;
        }
        v9 = a3;
        v10 = v6;
        while ( 1 )
        {
          v12 = v9[2];
          if ( !v12 )
            break;
          v11 = *(_BYTE *)(v10 - 3);
          ++v9;
          --v10;
          if ( v12 != v11 )
            goto LABEL_6;
        }
LABEL_13:
        v32 = v5;
        if ( a1 > v5 )
          break;
        v13 = *a4 + 1;
        if ( a2 - v5 == v13 )
        {
          v31 = (unsigned __int8 *)a4;
          while ( 1 )
          {
            v30 = v31[1];
            if ( v30 )
            {
LABEL_25:
              ++v31;
              goto LABEL_26;
            }
            while ( 1 )
            {
              v30 = *v31;
LABEL_26:
              v16 = v5 - 1;
              if ( v30 <= 0x7Eu )
                break;
              if ( a1 > v16 )
                return a2;
              v22 = v29 + v5;
              if ( v7 )
              {
                while ( v7 != *(_BYTE *)(v22 - 1) )
                {
LABEL_45:
                  --v16;
                  --v22;
                  if ( a1 > v16 )
                    return a2;
                }
                v23 = a3;
                v24 = v22;
                while ( 1 )
                {
                  v26 = v23[1];
                  if ( !v26 )
                    break;
                  v25 = *(_BYTE *)(v24 - 2);
                  ++v23;
                  --v24;
                  if ( v26 != v25 )
                    goto LABEL_45;
                }
              }
              v5 = v16;
              if ( a1 > v16 )
                return a2;
              v30 = v31[1];
              if ( v30 )
                goto LABEL_25;
            }
            if ( a1 > v16 )
              break;
            v17 = v29 + v5;
            v28 = v16;
            if ( v7 )
            {
              while ( v7 != *(_BYTE *)(v17 - 1) )
              {
LABEL_47:
                --v28;
                --v17;
                if ( a1 > v28 )
                {
                  v27 = v16 - v28;
                  goto LABEL_49;
                }
              }
              v18 = a3;
              v19 = v17;
              while ( 1 )
              {
                v21 = v18[1];
                if ( !v21 )
                  break;
                v20 = *(_BYTE *)(v19 - 2);
                ++v18;
                --v19;
                if ( v21 != v20 )
                  goto LABEL_47;
              }
              v5 = v28;
              if ( a1 > v28 )
              {
LABEL_52:
                v27 = v16 - v5;
                goto LABEL_49;
              }
            }
            else
            {
              v5 = v16;
              if ( a1 > v16 )
                goto LABEL_52;
            }
            if ( v16 - v28 != (char)v30 )
            {
              a2 = v32 - 1;
              goto LABEL_18;
            }
          }
          v27 = 0;
LABEL_49:
          if ( (char)v30 >= v27 )
            return a2;
          a2 = v32 - 1;
        }
        else
        {
          if ( (int)(a2 - v5) > v13 )
            v5 += v13;
          a2 = v5;
        }
LABEL_18:
        if ( a1 >= a2 )
          goto LABEL_19;
      }
    }
  }
  return a2;
}

//----- (0805CA20) --------------------------------------------------------
char *__cdecl itoa_word(unsigned int a1, char *a2, unsigned int a3, int a4)
{
  const char *v4; // esi
  int v7; // edx
  char v9; // al
  char v10; // al
  char v11; // al

  v4 = (const char *)&itoa_upper_digits;
  if ( !a4 )
    v4 = "0123456789abcdefghijklmnopqrstuvwxyz";
  if ( a3 == 10 )
  {
    do
    {
      --a2;
      v11 = v4[a1 % 0xA];
      a1 /= 0xAu;
      *a2 = v11;
    }
    while ( a1 );
    return a2;
  }
  else
  {
    if ( a3 == 16 )
    {
      do
      {
        --a2;
        v9 = v4[a1 & 0xF];
        a1 >>= 4;
        *a2 = v9;
      }
      while ( a1 );
    }
    else if ( a3 == 8 )
    {
      do
      {
        --a2;
        v10 = v4[a1 & 7];
        a1 >>= 3;
        *a2 = v10;
      }
      while ( a1 );
    }
    else
    {
      do
      {
        v7 = a1 % a3;
        --a2;
        a1 /= a3;
        *a2 = v4[v7];
      }
      while ( a1 );
    }
    return a2;
  }
}

//----- (0805CAE0) --------------------------------------------------------
char *__cdecl itoa(unsigned __int64 a1, char *a2, unsigned int a3, int a4)
{
  const char *v4; // esi
  unsigned int v5; // edx
  unsigned int v6; // ebx
  char *v7; // ebp
  unsigned int v8; // ecx
  unsigned __int64 v9; // rtt
  unsigned int v10; // eax
  int v11; // edx
  char *v12; // ecx
  int j; // ebx
  int v14; // et2
  int v15; // ecx
  char v16; // al
  char *v17; // ecx
  unsigned int v18; // eax
  int v19; // ecx
  char v20; // al
  char v21; // dl
  char v23; // al
  unsigned int i; // [esp+4h] [ebp-28h] BYREF
  char v25; // [esp+8h] [ebp-24h] BYREF
  int v26; // [esp+Ch] [ebp-20h]
  int v27; // [esp+10h] [ebp-1Ch]
  unsigned int v28; // [esp+14h] [ebp-18h]

  v4 = (const char *)&itoa_upper_digits;
  v5 = HIDWORD(a1);
  v6 = a1;
  if ( !a4 )
    v4 = "0123456789abcdefghijklmnopqrstuvwxyz";
  if ( a3 == 8 )
  {
    v18 = a1;
    v12 = a2;
    if ( HIDWORD(a1) )
    {
      v19 = 10;
      do
      {
        v20 = v4[v6 & 7];
        v6 >>= 3;
        a2[v19-- - 11] = v20;
      }
      while ( v19 );
      v12 = a2 - 10;
      v18 = HIDWORD(a1) >> 1;
      if ( HIDWORD(a1) >> 1 )
      {
        v12 = a2 - 11;
        *(a2 - 11) = v4[v6 | (4 * (BYTE4(a1) & 1))];
      }
      else
      {
        v18 = v6 | (4 * (BYTE4(a1) & 1));
      }
    }
    do
    {
      --v12;
      v21 = v4[v18 & 7];
      v18 >>= 3;
      *v12 = v21;
    }
    while ( v18 );
    return v12;
  }
  if ( a3 != 16 )
  {
    v7 = (char *)&unk_80C9508 + 12 * a3;
    if ( HIDWORD(a1) )
    {
      v8 = *((_DWORD *)v7 + 2);
      if ( HIDWORD(a1) < v8 )
      {
        v26 = a1 / v8;
        v10 = a1 % v8;
        v27 = v10;
        v11 = 2;
      }
      else
      {
        i = HIDWORD(a1) / v8;
        LODWORD(v9) = a1;
        HIDWORD(v9) = HIDWORD(a1) % v8;
        v28 = v9 % v8;
        LODWORD(v9) = v9 / v8;
        HIDWORD(v9) = HIDWORD(a1) / v8;
        v26 = v9 / v8;
        v10 = v28;
        v27 = v9 % v8;
        v11 = 3;
      }
    }
    else
    {
      v10 = a1;
      v11 = 1;
      v26 = a1;
    }
    v12 = a2;
    for ( i = (unsigned int)(&i + v11); ; i -= 4 )
    {
      for ( j = 0; v10; *v12 = v4[v14] )
      {
        --v12;
        v14 = v10 % a3;
        v10 /= a3;
        ++j;
      }
      if ( (char *)i == &v25 )
        break;
      for ( ; v7[5] > j; *v12 = 48 )
      {
        --v12;
        ++j;
      }
      v10 = *(_DWORD *)i;
    }
    if ( a2 == v12 )
    {
      --v12;
      *(a2 - 1) = 48;
    }
    return v12;
  }
  if ( HIDWORD(a1) )
  {
    v15 = 8;
    do
    {
      v16 = v4[v6 & 0xF];
      v6 >>= 4;
      a2[v15-- - 9] = v16;
    }
    while ( v15 );
    v17 = a2 - 8;
  }
  else
  {
    v17 = a2;
    v5 = a1;
  }
  do
  {
    --v17;
    v23 = v4[v5 & 0xF];
    v5 >>= 4;
    *v17 = v23;
  }
  while ( v5 );
  return v17;
}

//----- (0805CCF0) --------------------------------------------------------
char *__cdecl fitoa_word(unsigned int a1, _BYTE *a2, unsigned int a3, int a4)
{
  _BYTE *v4; // ebx
  char *v5; // eax
  char *v6; // esi
  char *v7; // edx
  _BYTE *v8; // ecx
  char v9; // al
  char v11[8]; // [esp+20h] [ebp-8h] BYREF

  v4 = a2;
  v5 = itoa_word(a1, v11, a3, a4);
  v6 = v5;
  if ( v5 < v11 )
  {
    v7 = v5;
    v8 = a2;
    do
    {
      v9 = *v7++;
      *v8++ = v9;
    }
    while ( v7 < v11 );
    return &a2[v11 - v6];
  }
  return v4;
}

//----- (0805CD50) --------------------------------------------------------
char *__cdecl fitoa(unsigned __int64 a1, _BYTE *a2, unsigned int a3, int a4)
{
  _BYTE *v4; // ebx
  char *v5; // eax
  char *v6; // esi
  char *v7; // edx
  _BYTE *v8; // ecx
  char v9; // al
  char v11[12]; // [esp+38h] [ebp-Ch] BYREF

  v4 = a2;
  v5 = itoa(a1, v11, a3, a4);
  v6 = v5;
  if ( v5 < v11 )
  {
    v7 = v5;
    v8 = a2;
    do
    {
      v9 = *v7++;
      *v8++ = v9;
    }
    while ( v7 < v11 );
    return &a2[v11 - v6];
  }
  return v4;
}

//----- (0805CDC0) --------------------------------------------------------
int __cdecl IO_helper_overflow(int a1, unsigned __int8 a2)
{
  unsigned __int8 *v2; // edx
  _BYTE *v3; // eax
  _BYTE *v4; // edi
  int result; // eax
  int v6; // ebp

  v2 = *(unsigned __int8 **)(a1 + 20);
  v3 = *(_BYTE **)(a1 + 16);
  v4 = (_BYTE *)(v2 - v3);
  if ( v2 != v3 )
  {
    v6 = (*(int (__cdecl **)(_DWORD, _BYTE *, _BYTE *))(*(_DWORD *)(*(_DWORD *)(a1 + 152) + 148) + 28))(
           *(_DWORD *)(a1 + 152),
           v3,
           v4);
    if ( (unsigned int)(v6 - 1) > 0xFFFFFFFD )
      return -1;
    memmove(*(void **)(a1 + 16), (const void *)(*(_DWORD *)(a1 + 16) + v6), (size_t)&v4[-v6]);
    v2 = (unsigned __int8 *)(*(_DWORD *)(a1 + 20) - v6);
    *(_DWORD *)(a1 + 20) = v2;
  }
  if ( (unsigned int)v2 >= *(_DWORD *)(a1 + 24) )
    return _overflow(a1, a2);
  *v2 = a2;
  result = a2;
  *(_DWORD *)(a1 + 20) = v2 + 1;
  return result;
}

//----- (0805CE90) --------------------------------------------------------
void __usercall buffered_vfprintf(
        _DWORD *a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  int v8; // eax
  int v9; // esi
  unsigned int v12; // ebp
  bool v13; // zf
  _DWORD *v14; // edx
  char v15[8192]; // [esp+18h] [ebp-20D4h] BYREF
  int v16[4]; // [esp+2018h] [ebp-D4h] BYREF
  char *v17; // [esp+2028h] [ebp-C4h]
  char *v18; // [esp+202Ch] [ebp-C0h]
  int *v19; // [esp+2030h] [ebp-BCh]
  int v20; // [esp+2054h] [ebp-98h]
  int v21; // [esp+2060h] [ebp-8Ch]
  int v22; // [esp+2080h] [ebp-6Ch]
  void *v23; // [esp+20ACh] [ebp-40h]
  _DWORD *v24; // [esp+20B0h] [ebp-3Ch]
  void (__cdecl *v25)(int); // [esp+20C0h] [ebp-2Ch]
  _DWORD *v26; // [esp+20C4h] [ebp-28h]
  int v27; // [esp+20DCh] [ebp-10h]
  int v28; // [esp+20E0h] [ebp-Ch]
  int v29; // [esp+20E4h] [ebp-8h]
  int v30; // [esp+20E8h] [ebp-4h]

  v27 = a4;
  v8 = a1[26];
  v28 = a7;
  v29 = a6;
  v30 = a5;
  if ( v8 )
  {
    if ( v8 != -1 )
      return;
  }
  else
  {
    a1[26] = -1;
  }
  v9 = a1[15];
  v18 = v15;
  v17 = v15;
  v24 = a1;
  v20 = v9;
  v19 = v16;
  v22 = -1;
  v16[0] = -72515580;
  v21 = 0;
  v23 = &IO_helper_jumps;
  vfprintf(v16, a2, a3);
  v25 = funlockfile;
  v26 = a1;
  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v12 = __readgsdword(8u);
    if ( v12 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v13 = __readgsdword(0xCu) == 0;
      if ( !v13 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v13 )
      {
        L_lock_193(0, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v12;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  if ( v18 - v17 > 0 )
    (*(int (__cdecl **)(_DWORD *, char *, int))(a1[37] + 28))(a1, v17, v18 - v17);
  if ( (BYTE1(*a1) & 0x80u) == 0 )
  {
    v14 = (_DWORD *)a1[18];
    v13 = v14[1]-- == 1;
    if ( v13 )
    {
      v14[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v13 = (*v14)-- == 1;
      if ( !v13 )
        L_unlock_241(_ECX, v14);
    }
  }
}
// 805CFF5: variable '_ECX' is possibly undefined
// 805D080: using guessed type _DWORD __cdecl vfprintf(_DWORD, _DWORD, _DWORD);

//----- (0805D080) --------------------------------------------------------
#error "805D403: switch analysis failed: failed to propagate the switch expression (funcsize=4415)"

//----- (08061F84) --------------------------------------------------------
void __usercall L_lock_193(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x805CF8D);
}
// 8061F8B: control flows out of bounds to 805CF8D

//----- (08061F90) --------------------------------------------------------
void __fastcall L_unlock_241(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x805CFFB);
}
// 8061F97: control flows out of bounds to 805CFFB

//----- (08061F9C) --------------------------------------------------------
void __usercall L_lock_1107(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x805D1ED);
}
// 8061FA3: control flows out of bounds to 805D1ED

//----- (08061FA8) --------------------------------------------------------
void __fastcall L_unlock_1177(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x805D233);
}
// 8061FAF: control flows out of bounds to 805D233

//----- (08061FC0) --------------------------------------------------------
int __fastcall hack_digit_12413(int a1)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax
  int *v5; // esi
  int v6; // esi
  int v7; // ecx
  int v8; // eax
  int v10; // esi
  int v11; // eax
  int v12; // edx
  int v13; // edx
  int *v14; // ebx
  int v15; // esi
  int v16; // eax

  if ( *(_DWORD *)(a1 + 28) )
  {
    if ( *(_DWORD *)(a1 + 24) == 102 )
    {
      v16 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 20) = v16 - 1;
      if ( v16 > 0 )
        return 48;
    }
  }
  v2 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 12);
  if ( !v2 )
  {
    v13 = v3 - 1;
    v14 = (int *)(*(_DWORD *)(a1 + 8) + 4 * v13);
    v15 = *v14 + 48;
    *v14 = _mpn_mul_1(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 8), v13, 0xAu);
    return v15;
  }
  if ( v2 <= v3 )
  {
    v4 = _mpn_divrem(*(_DWORD *)(a1 + 4), 0, *(_DWORD **)(a1 + 8), v3, *(unsigned int **)a1, *(_DWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 16);
    v5 = *(int **)(a1 + 4);
    v5[*(_DWORD *)(a1 + 12) - v3] = v4;
    v6 = *v5;
    *(_DWORD *)(a1 + 12) = v3;
    if ( v3 )
    {
      v7 = *(_DWORD *)(a1 + 8);
      v8 = v3 - 1;
      if ( *(_DWORD *)(v7 + 4 * (v3 - 1)) )
      {
LABEL_20:
        v10 = v6 + 48;
        goto LABEL_13;
      }
      while ( 1 )
      {
        v3 = v8;
        if ( !v8 )
          break;
        if ( *(_DWORD *)(v7 + 4 * v8 - 4) )
        {
          *(_DWORD *)(a1 + 12) = v8;
          goto LABEL_20;
        }
        --v8;
      }
    }
    *(_DWORD *)(a1 + 12) = 1;
    return v6 + 48;
  }
  v7 = *(_DWORD *)(a1 + 8);
  v10 = 48;
LABEL_13:
  v11 = _mpn_mul_1(v7, v7, v3, 0xAu);
  if ( v11 )
  {
    v12 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v12) = v11;
    *(_DWORD *)(a1 + 12) = v12 + 1;
  }
  return v10;
}

//----- (08062110) --------------------------------------------------------
int __cdecl _guess_grouping(unsigned int a1, unsigned __int8 *a2)
{
  int v2; // ecx
  unsigned __int8 v4; // dl
  unsigned int v5; // ebx

  v2 = 0;
  v4 = *a2;
  if ( (unsigned __int8)(*a2 - 1) <= 0x7Du )
  {
    while ( 1 )
    {
      v5 = (char)v4;
      if ( a1 <= (char)v4 )
        break;
      v4 = a2[++v2];
      if ( v4 > 0x7Eu )
        break;
      a1 -= v5;
      if ( !v4 )
      {
        v2 += (a1 - 1) / v5;
        return v2;
      }
    }
  }
  return v2;
}

//----- (08062160) --------------------------------------------------------
int __cdecl _printf_fp(int a1, int a2, long double **a3)
{
  _DWORD *v3; // edi
  bool v4; // al
  char v5; // dl
  int v6; // ecx
  char v7; // bl
  char *v8; // ecx
  int v9; // edx
  bool v10; // dl
  long double *v11; // eax
  _BYTE *v12; // esi
  __int16 v13; // dx
  int v14; // eax
  _BYTE *v15; // ecx
  int v16; // edx
  bool v17; // cc
  int v18; // eax
  int v19; // ebx
  int v20; // edx
  _DWORD *v21; // eax
  int v22; // edx
  int v23; // eax
  int v24; // edx
  int *v25; // ecx
  bool v26; // dl
  int v27; // eax
  int v28; // edx
  int v30; // ecx
  __int16 v31; // dx
  int v32; // ecx
  unsigned int v33; // eax
  int v34; // eax
  void *v35; // esp
  void *v36; // esp
  void *v37; // esp
  int v38; // edx
  _BYTE *v39; // ecx
  int v40; // eax
  char *v41; // ecx
  int v42; // eax
  int v43; // ecx
  unsigned int *v44; // ebx
  int v45; // esi
  int *v46; // ebx
  int v47; // ecx
  unsigned int v48; // esi
  int v49; // eax
  int v50; // edi
  int v51; // edx
  int v52; // eax
  int v53; // edx
  int v54; // edx
  char v55; // al
  int v56; // edx
  _DWORD *v57; // eax
  unsigned __int8 *v58; // eax
  unsigned __int8 v59; // si
  _BYTE *v60; // eax
  int v61; // edx
  _DWORD *v62; // eax
  _BYTE *v63; // eax
  int v64; // eax
  int v65; // eax
  bool v66; // al
  _BYTE *v67; // eax
  int v68; // eax
  int v69; // ebx
  int v70; // eax
  int v71; // eax
  int v72; // eax
  unsigned int v73; // esi
  unsigned int v74; // ecx
  int v75; // ebx
  unsigned int *v76; // edx
  unsigned int *v77; // eax
  unsigned int v78; // esi
  unsigned int v79; // esi
  int v80; // ecx
  int v81; // eax
  _BYTE *v82; // edx
  int v83; // esi
  int v84; // esi
  unsigned int *v85; // edx
  int v86; // eax
  unsigned int *v87; // ecx
  int v88; // eax
  char v89; // dl
  int v90; // edx
  unsigned int v91; // ebx
  int v92; // edx
  unsigned int v93; // ebx
  void *v94; // esp
  int v95; // ebx
  int v96; // esi
  int v97; // edi
  int v98; // eax
  double *v99; // esi
  int v100; // ebx
  int v101; // eax
  int v102; // eax
  int v103; // edx
  double *v104; // edx
  int v105; // eax
  int v106; // esi
  int v107; // ebx
  double *v108; // ecx
  unsigned int v109; // ebx
  int v110; // ebx
  int i; // ecx
  _DWORD *v112; // esi
  int v113; // eax
  char v114; // dl
  int v115; // edx
  _DWORD *v116; // eax
  int v117; // eax
  int v118; // eax
  int v119; // ebx
  int v120; // eax
  int v121; // eax
  unsigned int v122; // ebx
  void *v123; // esp
  unsigned int *v124; // eax
  int v125; // edx
  double *v126; // ebx
  int v127; // edi
  int v128; // ecx
  _BYTE *v129; // ecx
  int v130; // ecx
  int v131; // eax
  int v132; // edx
  _DWORD *v133; // eax
  _BYTE *v134; // ecx
  int v135; // esi
  bool v136; // al
  int v137; // eax
  int v138; // eax
  int v139; // esi
  int v140; // eax
  unsigned int v141; // edi
  _BYTE *v142; // ebx
  int v143; // ecx
  int v144; // edx
  int v145; // eax
  unsigned __int8 v146; // al
  int v147; // esi
  double *v148; // edx
  double *v149; // eax
  double *v150; // eax
  int v151; // edx
  double *v152; // esi
  bool v153; // cf
  int v154; // esi
  _BYTE *v155; // eax
  int v156; // edx
  _DWORD *v157; // eax
  int j; // ecx
  unsigned __int8 *v159; // eax
  unsigned __int8 v160; // dl
  int v161; // eax
  int v162; // edx
  int v163; // edx
  int v164; // eax
  int v165; // eax
  int v166; // ebx
  int v167; // esi
  int v168; // eax
  int v169; // eax
  char *v170; // ebx
  int v171; // eax
  int v172; // ecx
  int v173; // eax
  int v174; // eax
  int v175; // edx
  int v176; // eax
  int v177; // ecx
  _BYTE *v178; // esi
  _BYTE *v179; // ecx
  _BYTE *v180; // edi
  unsigned int v181; // eax
  int v182; // esi
  signed int v183; // esi
  int v184; // edx
  int v185; // ecx
  unsigned int *v186; // edx
  unsigned int *v187; // ebx
  int v188; // edi
  unsigned int *v189; // edx
  int v190; // eax
  _BYTE *v191; // esi
  bool v192; // zf
  int v193; // eax
  _BYTE *v194; // eax
  int v195; // eax
  _DWORD *v196; // ecx
  bool v197; // dl
  int v198; // eax
  int v199; // edx
  int v200; // ecx
  int v201; // edx
  unsigned int *v202; // esi
  int v203; // ebx
  unsigned int *v204; // edi
  _BYTE *v205; // eax
  int v206; // edx
  int v207; // ebx
  int v208; // eax
  int v209; // edx
  int v210; // ecx
  int v211; // eax
  int v212; // edi
  int v213; // eax
  int v214; // eax
  int v215; // edx
  int v216; // edx
  int v217; // eax
  int v218; // eax
  bool v219; // al
  double *v220; // ebx
  double *v221; // edx
  long double v222; // [esp+0h] [ebp-F8h]
  long double v223; // [esp+0h] [ebp-F8h]
  unsigned int v224; // [esp+0h] [ebp-F8h]
  int v225; // [esp+4h] [ebp-F4h]
  int v226; // [esp+4h] [ebp-F4h]
  int v227; // [esp+4h] [ebp-F4h]
  int v228; // [esp+4h] [ebp-F4h]
  unsigned int v229; // [esp+8h] [ebp-F0h]
  long double v230; // [esp+10h] [ebp-E8h]
  double v231[3]; // [esp+20h] [ebp-D8h] BYREF
  unsigned int v232; // [esp+38h] [ebp-C0h]
  int v233; // [esp+3Ch] [ebp-BCh]
  int v234; // [esp+40h] [ebp-B8h]
  char v235; // [esp+46h] [ebp-B2h]
  char v236; // [esp+47h] [ebp-B1h]
  int v237; // [esp+48h] [ebp-B0h]
  int v238; // [esp+4Ch] [ebp-ACh]
  unsigned int v239; // [esp+50h] [ebp-A8h]
  double *v240; // [esp+54h] [ebp-A4h]
  int v241; // [esp+58h] [ebp-A0h]
  double *v242; // [esp+5Ch] [ebp-9Ch]
  _DWORD *v243; // [esp+60h] [ebp-98h]
  char *v244; // [esp+64h] [ebp-94h]
  int v245; // [esp+68h] [ebp-90h]
  _BYTE *v246; // [esp+6Ch] [ebp-8Ch]
  _DWORD *v247; // [esp+70h] [ebp-88h]
  _BYTE *v248; // [esp+74h] [ebp-84h]
  int v249; // [esp+78h] [ebp-80h]
  int v250; // [esp+7Ch] [ebp-7Ch]
  long double v251; // [esp+80h] [ebp-78h]
  int v252; // [esp+8Ch] [ebp-6Ch]
  _BOOL4 v253; // [esp+90h] [ebp-68h]
  int v254; // [esp+94h] [ebp-64h]
  double v255; // [esp+98h] [ebp-60h]
  unsigned int *v256; // [esp+A0h] [ebp-58h] BYREF
  unsigned int *v257; // [esp+A4h] [ebp-54h]
  unsigned int *v258; // [esp+A8h] [ebp-50h]
  int v259; // [esp+ACh] [ebp-4Ch]
  int v260; // [esp+B0h] [ebp-48h]
  int v261; // [esp+B4h] [ebp-44h] BYREF
  int v262; // [esp+B8h] [ebp-40h]
  int v263; // [esp+BCh] [ebp-3Ch]
  long double v264; // [esp+C0h] [ebp-38h]
  unsigned int v265[2]; // [esp+CCh] [ebp-2Ch] BYREF
  unsigned int v266; // [esp+D4h] [ebp-24h] BYREF
  unsigned int v267; // [esp+D8h] [ebp-20h]
  int v268[7]; // [esp+DCh] [ebp-1Ch] BYREF

  v263 = 0;
  v3 = (_DWORD *)a1;
  v268[0] = 0;
  v4 = (*(_BYTE *)(a2 + 13) & 4) != 0;
  v5 = *(_BYTE *)(a2 + 13) & 1;
  v253 = v4;
  if ( v5 )
  {
    v32 = *(_DWORD *)__readgsdword(0xFFFFFFE0);
    v192 = **(_BYTE **)(v32 + 44) == 0;
    v248 = *(_BYTE **)(v32 + 44);
    if ( v192 )
      v248 = *(_BYTE **)(*(_DWORD *)__readgsdword(0xFFFFFFE4) + 36);
    v250 = *(_DWORD *)(v32 + 208);
    if ( !v250 )
      v250 = *(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFE4) + 48);
  }
  else
  {
    v6 = *(_DWORD *)__readgsdword(0xFFFFFFE4);
    v248 = *(_BYTE **)(v6 + 36);
    v250 = *(_DWORD *)(v6 + 48);
  }
  v7 = *(_BYTE *)(a2 + 12);
  if ( v7 >= 0
    || (!v5
      ? (v8 = *(char **)(*(_DWORD *)__readgsdword(0xFFFFFFE4) + 44))
      : (v8 = *(char **)(*(_DWORD *)__readgsdword(0xFFFFFFE0) + 52)),
        LODWORD(v255) = v8,
        v235 = *v8,
        (unsigned __int8)(v235 - 1) > 0x7Du) )
  {
    LODWORD(v255) = 0;
    v247 = 0;
    v246 = 0;
    goto LABEL_44;
  }
  if ( v253 )
  {
    v246 = 0;
    if ( v5 )
      v9 = *(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFE0) + 212);
    else
      v9 = *(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFE4) + 52);
    v247 = (_DWORD *)v9;
    v10 = v9 == 0;
    if ( !v10 )
    {
LABEL_110:
      if ( v253 )
        goto LABEL_111;
      goto LABEL_105;
    }
  }
  else
  {
    if ( !v5 )
    {
      v10 = 1;
      v247 = 0;
      v246 = *(_BYTE **)(*(_DWORD *)__readgsdword(0xFFFFFFE4) + 40);
LABEL_105:
      if ( !*v246 )
      {
        LODWORD(v255) = 0;
        goto LABEL_44;
      }
LABEL_111:
      v64 = -2;
      if ( !v10 )
        v64 = (int)v247;
      v247 = (_DWORD *)v64;
LABEL_44:
      v11 = *a3;
      if ( (v7 & 1) == 0 )
        goto LABEL_13;
LABEL_45:
      v251 = *v11;
      v222 = v251;
      if ( isnanl(SLODWORD(v222), SDWORD1(v222), SWORD4(v222)) )
      {
        v264 = v251;
        v30 = *(_DWORD *)(a2 + 8);
        v12 = &unk_80C9CB4;
        v14 = (SBYTE9(v264) & 0x80u) != 0;
        v268[0] = v14;
        v31 = *(_WORD *)(__readgsdword(0xFFFFFFF8) + 2 * v30);
        v15 = &unk_80C9C98;
        LODWORD(v255) = v31 & 0x100;
        if ( (v31 & 0x100) != 0 )
        {
          v12 = &unk_80C9CC4;
          v15 = &unk_80C9C9C;
        }
LABEL_16:
        LODWORD(v255) = *(_DWORD *)(a2 + 4);
        if ( v14 || (v7 & 0x50) != 0 )
          --LODWORD(v255);
        v16 = LODWORD(v255) - 3;
        v17 = LODWORD(v255) - 3 <= 0;
        LODWORD(v255) -= 3;
        LOBYTE(v251) = !v17;
        if ( v17 || (v7 & 0x20) != 0 )
        {
          v19 = 0;
          if ( v14 )
          {
LABEL_24:
            if ( v253 )
            {
              v20 = *(_DWORD *)(a1 + 88);
              if ( v20 )
              {
                v21 = *(_DWORD **)(v20 + 16);
                if ( (unsigned int)v21 < *(_DWORD *)(v20 + 20) )
                {
                  *v21 = 45;
                  *(_DWORD *)(v20 + 16) = v21 + 1;
LABEL_28:
                  ++v19;
LABEL_29:
                  v22 = 0;
                  if ( !v253 )
                  {
                    v254 = (int)v15;
                    do
                    {
                      v58 = *(unsigned __int8 **)(a1 + 20);
                      v59 = *(_BYTE *)(v254 + v22);
                      if ( (unsigned int)v58 >= *(_DWORD *)(a1 + 24) )
                      {
                        v232 = v22;
                        v218 = _overflow(a1, v59);
                        v22 = v232;
                        if ( v218 == -1 )
                          return -1;
                      }
                      else
                      {
                        *v58 = v59;
                        *(_DWORD *)(a1 + 20) = v58 + 1;
                      }
                      ++v22;
                      ++v19;
                    }
                    while ( v22 != 3 );
LABEL_36:
                    if ( LOBYTE(v251) && (*(_BYTE *)(a2 + 12) & 0x20) != 0 )
                    {
                      if ( v253 )
                        v27 = IO_wpadn(a1, 32, SLODWORD(v255));
                      else
                        v27 = IO_padn(a1, 32, SLODWORD(v255));
                      v28 = v19 + v27;
                      v19 = -1;
                      if ( v27 == LODWORD(v255) )
                        return v28;
                    }
                    return v19;
                  }
                  v254 = (int)(v12 + 12);
                  while ( 1 )
                  {
                    v23 = *(_DWORD *)(a1 + 88);
                    v24 = *(_DWORD *)v12;
                    v12 += 4;
                    if ( v23 && (v25 = *(int **)(v23 + 16), (unsigned int)v25 < *(_DWORD *)(v23 + 20)) )
                    {
                      *v25 = v24;
                      v26 = v24 == -1;
                      *(_DWORD *)(v23 + 16) = v25 + 1;
                    }
                    else
                    {
                      v26 = _woverflow(a1, v24) == -1;
                    }
                    if ( v26 )
                      return -1;
                    ++v19;
                    if ( v12 == (_BYTE *)v254 )
                      goto LABEL_36;
                  }
                }
              }
              v228 = 45;
              goto LABEL_467;
            }
            v60 = *(_BYTE **)(a1 + 20);
            if ( (unsigned int)v60 < *(_DWORD *)(a1 + 24) )
            {
              *v60 = 45;
              *(_DWORD *)(a1 + 20) = v60 + 1;
              goto LABEL_28;
            }
            v225 = 45;
            goto LABEL_115;
          }
        }
        else
        {
          v232 = (unsigned int)v15;
          if ( v253 )
            v18 = IO_wpadn(a1, 32, v16);
          else
            v18 = IO_padn(a1, 32, SLODWORD(v255));
          v15 = (_BYTE *)v232;
          v19 = v18;
          if ( v18 != LODWORD(v255) )
            return -1;
          if ( v268[0] )
            goto LABEL_24;
        }
        v55 = *(_BYTE *)(a2 + 12);
        if ( (v55 & 0x40) != 0 )
        {
          if ( v253 )
          {
            v56 = *(_DWORD *)(a1 + 88);
            if ( v56 )
            {
              v57 = *(_DWORD **)(v56 + 16);
              if ( (unsigned int)v57 < *(_DWORD *)(v56 + 20) )
              {
                *v57 = 43;
                *(_DWORD *)(v56 + 16) = v57 + 1;
                goto LABEL_28;
              }
            }
            v228 = 43;
            goto LABEL_467;
          }
          v63 = *(_BYTE **)(a1 + 20);
          if ( (unsigned int)v63 < *(_DWORD *)(a1 + 24) )
          {
            *v63 = 43;
            *(_DWORD *)(a1 + 20) = v63 + 1;
            goto LABEL_28;
          }
          v225 = 43;
        }
        else
        {
          if ( (v55 & 0x10) == 0 )
            goto LABEL_29;
          if ( v253 )
          {
            v61 = *(_DWORD *)(a1 + 88);
            if ( v61 )
            {
              v62 = *(_DWORD **)(v61 + 16);
              if ( (unsigned int)v62 < *(_DWORD *)(v61 + 20) )
              {
                *v62 = 32;
                *(_DWORD *)(v61 + 16) = v62 + 1;
                goto LABEL_28;
              }
            }
            v228 = 32;
LABEL_467:
            v232 = (unsigned int)v15;
            v217 = _woverflow(a1, v228);
            v15 = (_BYTE *)v232;
            v66 = v217 == -1;
LABEL_116:
            if ( v66 )
              return -1;
            goto LABEL_28;
          }
          v67 = *(_BYTE **)(a1 + 20);
          if ( (unsigned int)v67 < *(_DWORD *)(a1 + 24) )
          {
            *v67 = 32;
            *(_DWORD *)(a1 + 20) = v67 + 1;
            goto LABEL_28;
          }
          v225 = 32;
        }
LABEL_115:
        v232 = (unsigned int)v15;
        v65 = _overflow(a1, v225);
        v15 = (_BYTE *)v232;
        v66 = v65 == -1;
        goto LABEL_116;
      }
      v223 = v251;
      v33 = isinfl(SLODWORD(v223), SDWORD1(v223), SWORD4(v223));
      if ( v33 )
      {
LABEL_54:
        v14 = v33 >> 31;
        v268[0] = v14;
        v12 = &unk_80C9CD4;
        v15 = &unk_80C9CA0;
        LODWORD(v255) = *(_WORD *)(__readgsdword(0xFFFFFFF8) + 2 * *(_DWORD *)(a2 + 8)) & 0x100;
        if ( !LODWORD(v255) )
        {
          v12 = &unk_80C9CA4;
          v15 = &unk_80C9C94;
        }
        goto LABEL_16;
      }
      v230 = v251;
      v259 = _mpn_extract_long_double(v265, 2, &v261, v268, LODWORD(v230), DWORD1(v230), SWORD4(v230));
      v254 = 32 * v259 - 63;
      goto LABEL_59;
    }
    v247 = 0;
    v246 = *(_BYTE **)(*(_DWORD *)__readgsdword(0xFFFFFFE0) + 48);
    v10 = 1;
  }
  if ( !v4 )
    goto LABEL_110;
  v11 = *a3;
  LODWORD(v255) = 0;
  v247 = 0;
  if ( (v7 & 1) != 0 )
    goto LABEL_45;
LABEL_13:
  v231[0] = *(double *)v11;
  if ( isnan(v231[0]) )
  {
    v255 = v231[0];
    v12 = &unk_80C9CC4;
    v13 = *(_WORD *)(__readgsdword(0xFFFFFFF8) + 2 * *(_DWORD *)(a2 + 8));
    v14 = v255 < 0.0;
    v15 = &unk_80C9C9C;
    v268[0] = v14;
    LODWORD(v255) = v13 & 0x100;
    if ( (v13 & 0x100) == 0 )
    {
      v12 = &unk_80C9CB4;
      v15 = &unk_80C9C98;
    }
    goto LABEL_16;
  }
  v33 = isinf(v231[0]);
  if ( v33 )
    goto LABEL_54;
  v259 = _mpn_extract_double(v265, 2, &v261, (unsigned int *)v268, LODWORD(v231[0]), HIDWORD(v231[0]));
  v254 = 32 * v259 - 52;
LABEL_59:
  v260 = 0;
  v34 = (4 * ((int)(abs32(v261) + 31) >> 5) + 46) & 0xFFFFFFF0;
  v35 = alloca(v34);
  v36 = alloca(v34);
  v37 = alloca(v34);
  v257 = (unsigned int *)v231;
  v38 = v261;
  v258 = (unsigned int *)v231;
  v256 = (unsigned int *)v231;
  if ( v261 > 2 )
  {
    v39 = (_BYTE *)(v261 + v254);
    LODWORD(v251) = v261 + v254;
    if ( (((_BYTE)v261 + (_BYTE)v254) & 0x1F) != 0 )
    {
      v68 = _mpn_lshift(&v258[SLODWORD(v251) / 32], (int)v265, v259, SLODWORD(v251) % 32);
      v38 = v261;
      v69 = v68;
      v70 = v261 + v254 + 31;
      if ( v261 + v254 >= 0 )
        v70 = v261 + v254;
      v71 = v259 + (v70 >> 5);
      LODWORD(v251) = v261 + v254;
      v259 = v71;
      if ( v69 )
      {
        v258[v71] = v69;
        v259 = v71 + 1;
      }
      v42 = v260;
    }
    else
    {
      v252 = v259;
      v40 = v259 - 1;
      if ( v259 - 1 < 0 )
      {
        v193 = (int)(v39 + 31);
        if ( (int)v39 >= 0 )
          v193 = v261 + v254;
        v254 = v193 >> 5;
      }
      else
      {
        v254 = SLODWORD(v251) / 32;
        v41 = (char *)v231 + 4 * (SLODWORD(v251) / 32);
        do
        {
          *(_DWORD *)&v41[4 * v40] = v265[v40];
          --v40;
        }
        while ( v40 != -1 );
      }
      v259 = v252 + v254;
      v42 = 0;
    }
    if ( SLODWORD(v251) > 31 )
    {
      v43 = 0;
      v44 = v258;
      v45 = SLODWORD(v251) >> 5;
      do
        v44[v43++] = 0;
      while ( v45 > v43 );
    }
    v46 = (int *)&unk_80DB790;
    v47 = 12;
    LODWORD(v251) = 0;
    v48 = 0;
    v254 = a1;
    while ( 1 )
    {
      v46 -= 4;
      if ( v38 >= (int)(v48 + v46[2] - 1) )
      {
        if ( v42 )
        {
          LODWORD(v230) = v46[1] - 2;
          v51 = *v46;
          v232 = v47;
          v52 = _mpn_mul(v257, v256, v42, &dword_80DB7A8[v51], SLODWORD(v230));
          v53 = v260 + v46[1];
          v47 = v232;
          v50 = v53 - 2;
          v54 = v53 - 3;
          if ( !v52 )
            v50 = v54;
        }
        else
        {
          v49 = *v46;
          v50 = v46[1];
          v232 = v47;
          memcpy(v257, &_tens[4 * v49], 4 * v50);
          v47 = v232;
        }
        if ( v50 < v259 || v50 == v259 && (v232 = v47, v72 = _mpn_cmp((int)v258, (int)v257, v50), v47 = v232, v72 >= 0) )
        {
          v260 = v50;
          v232 = v47;
          memcpy(v256, v257, 4 * v50);
          v42 = v260;
          v47 = v232;
          _BitScanReverse(&v73, v256[v260 - 1]);
          v48 = 32 * (v260 - 2) + (v73 ^ 0xFFFFFFE0);
          LODWORD(v251) |= 1 << v232;
        }
        else
        {
          v42 = v260;
        }
      }
      if ( v46 <= fpioconst_pow10 )
        break;
      v38 = v261;
      --v47;
    }
    v3 = (_DWORD *)v254;
    v261 = LODWORD(v251);
    if ( v42 <= 0 )
      goto LABEL_146;
    v74 = *v256;
    v254 = (int)v256;
    if ( v74 )
    {
      LODWORD(v251) = 0;
      v252 = 0;
      v245 = v254;
      v75 = 0;
    }
    else if ( *v258 )
    {
      v75 = 0;
      LODWORD(v251) = 0;
      v252 = 0;
      v245 = v254;
    }
    else
    {
      v75 = 0;
      v252 = v42;
      v249 = (int)v3;
      v76 = (unsigned int *)(v254 + 4);
      do
      {
        ++v75;
        v77 = v76;
        LODWORD(v251) = 4 * v75;
        v74 = *v76;
        if ( *v76 )
          break;
        ++v76;
      }
      while ( !v258[v75] );
      v245 = (int)v77;
      v42 = v252;
      v252 = v75;
      v3 = (_DWORD *)v249;
    }
    _BitScanReverse(&v78, *(_DWORD *)(v254 + 4 * v42 - 4));
    v79 = v78 ^ 0x1F;
    if ( !v79 )
    {
      if ( v75 )
      {
        v80 = v42 - v75;
        if ( v42 - v75 > 0 )
        {
          v81 = 0;
          v249 = 0;
          LODWORD(v251) = v75;
          v82 = (_BYTE *)(v254 + 4 * v252);
          v83 = v254;
          do
          {
            *(_DWORD *)(v83 + 4 * v81) = *(_DWORD *)&v82[4 * v81];
            ++v81;
          }
          while ( v81 != v80 );
          v75 = LODWORD(v251);
        }
        v260 = v80;
        v84 = v259 - v75;
        if ( v259 - v75 > 0 )
        {
          v85 = v258;
          v86 = 0;
          v87 = &v258[v252];
          do
          {
            v85[v86] = v87[v86];
            ++v86;
          }
          while ( v86 != v84 );
        }
        v259 = v84;
      }
      goto LABEL_146;
    }
    if ( v74 )
    {
      _BitScanForward(&v74, v74);
      v244 = (char *)v74;
      v249 = *(unsigned int *)((char *)v258 + LODWORD(v251));
      if ( v249 )
      {
        _BitScanForward((unsigned int *)&v162, v249);
        if ( (int)v244 <= v162 )
          v162 = (int)v244;
        v244 = (char *)v162;
      }
    }
    else
    {
      _BitScanForward((unsigned int *)&v200, *(unsigned int *)((char *)v258 + LODWORD(v251)));
      v244 = (char *)v200;
    }
    v163 = 32 - v79;
    if ( v75 )
    {
      if ( (int)v244 < v163 )
      {
        LODWORD(v251) = 4 * v252 - 4;
        v232 = 32 - v79;
        _mpn_rshift(v254, (unsigned int *)(LODWORD(v251) + v254), 1 - v75 + v42, v163);
        v260 -= v75;
        _mpn_rshift((int)v258, (unsigned int *)((char *)v258 + LODWORD(v251)), 1 - v75 + v259, v232);
        v164 = v259 - ((v258[v259 - v75] == 0) + v75 - 1);
LABEL_349:
        v259 = v164;
        goto LABEL_146;
      }
    }
    else if ( (int)v244 < v163 )
    {
      _mpn_lshift((_DWORD *)v254, v254, v42, v79);
      v210 = _mpn_lshift(v258, (int)v258, v259, v79);
      if ( v210 )
      {
        v211 = v259;
        v258[v259] = v210;
        v259 = v211 + 1;
      }
      goto LABEL_146;
    }
    v232 = 32 - v79;
    _mpn_rshift(v254, (unsigned int *)v245, v42 - v75, v163);
    v260 += ~v75;
    _mpn_rshift((int)v258, (unsigned int *)((char *)v258 + LODWORD(v251)), v259 - v75, v232);
    v164 = v259 - v75;
    if ( !v258[v259 - v75 - 1] )
      v164 = v259 - (v75 + 1);
    goto LABEL_349;
  }
  if ( v261 >= 0 )
  {
    v130 = _mpn_lshift(v231, (int)v265, v259, v254 + v261);
    v131 = v259;
    v258[v259] = v130;
    v259 = v131 + 1;
    v261 = 0;
    goto LABEL_146;
  }
  v170 = (char *)&unk_80DB790;
  v171 = _mpn_lshift(v231, (int)v265, v259, v254);
  v252 = 12;
  v249 = 0;
  v243 = (_DWORD *)a1;
  v172 = v171;
  v173 = v259;
  v258[v259] = v172;
  v259 = v173 + 1;
  v263 = 1;
  v174 = -v261;
  v261 = -v261;
  while ( 1 )
  {
    v170 -= 16;
    if ( *((_DWORD *)v170 + 3) > v174 )
      goto LABEL_384;
    v175 = *((_DWORD *)v170 + 1) - 2;
    if ( v175 <= v259 )
      v176 = _mpn_mul(v257, v258, v259, &dword_80DB7A8[*(_DWORD *)v170], *((_DWORD *)v170 + 1) - 2);
    else
      v176 = _mpn_mul(v257, &dword_80DB7A8[*(_DWORD *)v170], v175, v258, v259);
    v177 = v259 + *((_DWORD *)v170 + 1);
    v178 = (_BYTE *)(v177 - 2);
    v179 = (_BYTE *)(v177 - 3);
    if ( v176 )
      v179 = v178;
    v180 = v179 - 1;
    _BitScanReverse(&v181, v257[(_DWORD)(v179 - 1)]);
    v254 = (int)v179;
    LODWORD(v251) = v181 ^ 0x1F;
    v174 = v261;
    v182 = 32 * (_DWORD)&v179[-v259] + 31 - LODWORD(v251);
    if ( v261 + 3 == v182 )
    {
      if ( SLODWORD(v251) > 28 )
      {
        v266 = -1610612736;
        v267 = 0;
        _mpn_lshift(&v266, (int)&v266, 2, 32 - LOBYTE(v251));
        v174 = v261;
      }
      else
      {
        v266 = 0;
        v267 = 10 << (28 - LOBYTE(v251));
      }
    }
    if ( v182 > v174 + 2 )
    {
      if ( v174 + 3 != v182 )
        goto LABEL_384;
      v153 = v257[(_DWORD)v180] < v267;
      v192 = v257[(_DWORD)v180] == v267;
      v245 = (int)v257;
      if ( !v153 && (!v192 || v257[v254 - 2] >= v266) )
        goto LABEL_384;
    }
    else
    {
      v245 = (int)v257;
    }
    v174 -= v182;
    v261 = v174;
    v249 |= 1 << v252;
    v183 = *(_DWORD *)v245;
    v184 = LODWORD(v251) - v174;
    if ( v174 >= 0 )
      v184 = LODWORD(v251);
    LODWORD(v251) = v184;
    if ( v183 )
    {
      v189 = (unsigned int *)v245;
      v188 = 0;
      v185 = 0;
    }
    else
    {
      v185 = 0;
      v186 = (unsigned int *)(v245 + 4);
      v244 = v170;
      do
      {
        v187 = v186++;
        v183 = *(v186 - 1);
        v188 = ++v185;
      }
      while ( !v183 );
      v189 = v187;
      v170 = v244;
    }
    if ( LODWORD(v251) == 31 )
    {
      v254 -= v185;
      if ( v254 > 0 )
      {
        v201 = 0;
        LODWORD(v251) = v170;
        v202 = v258;
        v203 = v254;
        v204 = (unsigned int *)(v245 + 4 * v188);
        do
        {
          v202[v201] = v204[v201];
          ++v201;
        }
        while ( v201 != v203 );
        v170 = (char *)LODWORD(v251);
      }
      v259 = v254;
    }
    else
    {
      _BitScanForward((unsigned int *)&v183, v183);
      v190 = 31 - LODWORD(v251);
      if ( v185 )
      {
        if ( v183 >= v190 )
        {
LABEL_382:
          v191 = (_BYTE *)(v254 - v185);
          _mpn_rshift((int)v258, v189, v254 - v185, 31 - LOBYTE(v251));
        }
        else
        {
          v191 = (_BYTE *)(v254 + 1 - v185);
          _mpn_rshift((int)v258, (unsigned int *)(v245 + 4 * v188 - 4), (int)v191, 31 - LOBYTE(v251));
        }
        v174 = v261;
        v259 = (int)v191;
        goto LABEL_384;
      }
      if ( v183 >= v190 )
        goto LABEL_382;
      v212 = v254;
      v213 = _mpn_lshift(v258, v245, v254, LOBYTE(v251) + 1);
      v259 = v212 + 1;
      v258[v212] = v213;
      v174 = v261;
    }
LABEL_384:
    --v252;
    if ( v170 == (char *)&unk_80DB6D0 )
      break;
    if ( v174 <= 0 )
    {
      v3 = v243;
      goto LABEL_387;
    }
  }
  v3 = v243;
  if ( v174 > 0 )
  {
    _mpn_mul_1((int)v257, (int)v258, v259, 0xAu);
    v206 = 4;
    v207 = v259;
    _BitScanForward((unsigned int *)&v208, *v257);
    if ( v261 <= 4 )
      v206 = v261;
    if ( v208 >= v206 )
    {
      _mpn_rshift((int)v258, v257, v259, v206);
    }
    else
    {
      v209 = _mpn_lshift(v258, (int)v257, v259, 32 - v206);
      if ( v209 )
        v258[v207++] = v209;
    }
    v259 = v207;
    v249 |= 1u;
  }
LABEL_387:
  v261 = v249;
LABEL_146:
  v88 = *(_DWORD *)(a2 + 8);
  v89 = *(_BYTE *)(__readgsdword(0xFFFFFFF4) + 4 * v88);
  v241 = *(_DWORD *)(a2 + 4);
  v236 = v89;
  if ( v89 == 101 )
  {
    v154 = *(_DWORD *)a2;
    v262 = v88;
    v252 = v154;
    if ( v154 < 0 )
    {
      v239 = 14;
      v91 = 6;
      v252 = 6;
    }
    else
    {
      v91 = v154;
      v239 = v154 + 8;
    }
    goto LABEL_315;
  }
  if ( v236 == 102 )
  {
    v262 = 102;
    v91 = *(_DWORD *)a2;
    v252 = *(_DWORD *)a2;
    if ( v252 < 0 )
    {
      v91 = 6;
      v252 = 6;
    }
    if ( !v263 )
    {
      v254 = 1;
      v237 = 0x7FFFFFFF;
      v245 = v261 + 1;
      v239 = v261 + v91 + 2;
      v244 = (char *)v252;
      goto LABEL_159;
    }
    v239 = v91 + 2;
LABEL_315:
    v254 = 1;
    v237 = 0x7FFFFFFF;
    v245 = 1;
    v244 = (char *)v252;
    goto LABEL_159;
  }
  if ( *(int *)a2 < 0 )
  {
    v237 = 6;
  }
  else
  {
    v90 = 1;
    if ( *(_DWORD *)a2 )
      v90 = *(_DWORD *)a2;
    v237 = v90;
  }
  if ( v263 )
  {
    if ( v261 <= 4 )
    {
      v262 = 102;
      v245 = 0;
      goto LABEL_155;
    }
LABEL_319:
    v262 = v88 - 2;
    v245 = 1;
    v252 = v237 - 1;
    v91 = v237 - 1;
    v239 = v237 + 7;
  }
  else
  {
    if ( v237 <= v261 )
      goto LABEL_319;
    v262 = 102;
    v245 = v261 + 1;
LABEL_155:
    v239 = v237 + 5;
    v91 = v237 - v245;
    v252 = v237 - v245;
  }
  v92 = 0;
  v244 = 0;
  if ( (*(_BYTE *)(a2 + 12) & 8) != 0 )
    v92 = v252;
  v254 = 0;
  v244 = (char *)v92;
LABEL_159:
  v238 = 0;
  if ( LODWORD(v255) )
  {
    v238 = _guess_grouping(v245, (unsigned __int8 *)LODWORD(v255));
    v239 += v238 + 1;
  }
  if ( v239 < v91 || v239 > 0x3FFFFFFC )
  {
    v19 = -1;
    __writegsdword(0xFFFFFFE8, 0x22u);
    return v19;
  }
  v93 = 4 * v239 + 8;
  if ( v93 <= 0x1000 || _libc_alloca_cutoff(4 * v239 + 8) )
  {
    v94 = alloca(v93 + 15);
    v240 = v231;
    v233 = 0;
  }
  else
  {
    v224 = v93;
    v19 = -1;
    v240 = (double *)malloc(v224);
    if ( !v240 )
      return v19;
    v233 = 1;
  }
  v242 = v240 + 1;
  if ( v263 && v262 == 102 )
  {
    v165 = (int)v240;
    v166 = v250;
    --v261;
    v167 = (int)v240;
    *((_DWORD *)v240 + 2) = 48;
    v99 = (double *)(v167 + 16);
    *(_DWORD *)(v165 + 12) = v166;
    v234 = 0;
    v249 = (int)&v256;
  }
  else
  {
    v95 = 0;
    v249 = (int)&v256;
    if ( v245 <= 0 )
    {
      v99 = v242;
      v234 = 0;
    }
    else
    {
      LODWORD(v251) = v3;
      v96 = (int)v240;
      v97 = v249;
      do
      {
        ++v95;
        v98 = hack_digit_12413(v97);
        v192 = v95 == v245;
        *(_DWORD *)(v96 + 4 * v95 + 4) = v98;
      }
      while ( !v192 );
      v3 = (_DWORD *)LODWORD(v251);
      v234 = v245;
      v99 = (double *)((char *)v242 + 4 * v245);
    }
    if ( (int)v244 > 0 || (*(_BYTE *)(a2 + 12) & 8) != 0 || (v254 = 1, v252 > 0) && (v259 > 1 || *v258) )
    {
      v254 = 1;
      *(_DWORD *)v99 = v250;
      v99 = (double *)((char *)v99 + 4);
    }
  }
  v100 = 0;
  v243 = 0;
  LODWORD(v251) = v244;
  while ( v100 < SLODWORD(v251) || v252 > v100 && (v259 > 1 || *v258) )
  {
    ++v100;
    v101 = hack_digit_12413(v249);
    *(_DWORD *)v99 = v101;
    v99 = (double *)((char *)v99 + 4);
    if ( v101 != 48 || v254 )
    {
      v254 = 1;
    }
    else
    {
      ++v252;
      if ( (int)v244 > 0 )
      {
        v243 = (_DWORD *)((char *)v243 + 1);
        LODWORD(v251) = (char *)v243 + (_DWORD)v244;
      }
    }
  }
  v102 = hack_digit_12413(v249);
  if ( v102 <= 52 )
    goto LABEL_201;
  if ( v102 != 53 )
    goto LABEL_188;
  v168 = *((_DWORD *)v99 - 1);
  if ( v168 == v250 )
  {
    if ( (*(_BYTE *)(v99 - 1) & 1) == 0 )
      goto LABEL_354;
LABEL_188:
    if ( v100 <= 0 )
    {
      v108 = v99;
      if ( !v100 )
      {
LABEL_299:
        if ( *((_DWORD *)v108 - 1) == v250 )
          v108 = (double *)((char *)v108 - 4);
        v150 = (double *)((char *)v108 - 4);
        if ( v242 > (double *)((char *)v108 - 4) )
        {
LABEL_308:
          if ( v262 == 102 )
          {
            if ( v234 == v237 )
            {
              v214 = (int)v240;
              v215 = v250;
              *(_DWORD *)v240 = 49;
              *(_DWORD *)(v214 + 4) = v215;
              if ( v100 > 0 || (*(_BYTE *)(a2 + 12) & 8) != 0 )
              {
                ++v100;
                *((_DWORD *)v240 + v234 + 2) = 48;
              }
              v100 += v234;
              ++v261;
              v216 = *(_DWORD *)(a2 + 8);
              v234 = 1;
              v262 = (*(_WORD *)(__readgsdword(0xFFFFFFF8) + 2 * v216) & 0x100) == 0 ? 101 : 69;
              v242 = v240;
            }
            else
            {
              ++v234;
              v242 = (double *)((char *)v240 + 4);
              *((_DWORD *)v240 + 1) = 49;
            }
          }
          else
          {
            v153 = v263 == 0;
            *((_DWORD *)v240 + 2) = 49;
            v261 += v153 ? 1 : -1;
            if ( !v261 )
              v263 = 0;
          }
          if ( v237 < v100 + v234 )
          {
            v99 = (double *)((char *)v99 - 4 * (v100 + v234 - v237));
            v100 = v237 - v234;
          }
        }
        else
        {
          v151 = *((_DWORD *)v108 - 1);
          if ( v151 == 57 )
          {
            v254 = (int)v99;
            v152 = v242;
            while ( 1 )
            {
              *((_DWORD *)v108 - 1) = 48;
              if ( v152 > (double *)((char *)v150 - 4) )
              {
                v99 = (double *)v254;
                goto LABEL_308;
              }
              if ( *((_DWORD *)v150 - 1) != 57 )
                break;
              v108 = v150;
              v150 = (double *)((char *)v150 - 4);
            }
            v99 = (double *)v254;
            v151 = *((_DWORD *)v150 - 1);
          }
          else
          {
            v150 = v108;
          }
          *((_DWORD *)v150 - 1) = v151 + 1;
        }
        goto LABEL_201;
      }
    }
    else
    {
      v103 = *((_DWORD *)v99 - 1);
      v249 = (int)v99 - 4;
      if ( v103 == v250 || v103 != 57 )
      {
        v108 = (double *)v249;
        LODWORD(v251) = 0;
        v249 = (int)v99;
      }
      else
      {
        v104 = v99;
        v105 = (int)v99 - 4;
        v254 = (int)v99;
        v106 = v250;
        v252 = v100;
        v107 = 0;
        LODWORD(v251) = 0;
        while ( 1 )
        {
          *((_DWORD *)v104 - 1) = 48;
          v103 = *(_DWORD *)(v105 - 4);
          ++v107;
          v108 = (double *)(v105 - 4);
          if ( v103 == v106 || v103 != 57 )
            break;
          v104 = (double *)v105;
          v105 -= 4;
        }
        LODWORD(v251) = v107;
        v99 = (double *)v254;
        v100 = v252;
        v249 = v105;
      }
      if ( (char *)LODWORD(v251) == v244 )
        v243 = (_DWORD *)((char *)v243 + ((int)v243 <= 0) - 1);
      if ( v250 == v103 )
      {
        LODWORD(v251) = (char *)v243 + (_DWORD)v244;
        if ( v236 == 103 && v262 == 102 && (*(_BYTE *)(a2 + 12) & 8) != 0 && v108 == (double *)((char *)v240 + 12) )
        {
          v195 = LODWORD(v251);
          if ( *((_DWORD *)v240 + 2) == 48 )
            v195 = (int)v243 + (_DWORD)v244 - 1;
          LODWORD(v251) = v195;
        }
      }
      else
      {
        *(_DWORD *)(v249 - 4) = v103 + 1;
        LODWORD(v251) = (char *)v243 + (_DWORD)v244;
      }
    }
    if ( *(_DWORD *)v108 != v250 )
      goto LABEL_201;
    goto LABEL_299;
  }
  if ( (v168 & 1) != 0 )
    goto LABEL_188;
LABEL_354:
  if ( v259 != 1 || *v258 )
  {
    if ( v260 )
      goto LABEL_188;
    v169 = v259;
    if ( v259 )
    {
      while ( !v258[v169 - 1] )
      {
        if ( !--v169 )
          goto LABEL_201;
      }
      goto LABEL_188;
    }
  }
LABEL_201:
  if ( v100 > SLODWORD(v251) && *((_DWORD *)v99 - 1) == 48 )
  {
    do
    {
      --v100;
      v99 = (double *)((char *)v99 - 4);
    }
    while ( v100 != LODWORD(v251) && *((_DWORD *)v99 - 1) == 48 );
  }
  if ( !v100 && (*(_BYTE *)(a2 + 12) & 8) == 0 && *((_DWORD *)v99 - 1) == v250 )
    v99 = (double *)((char *)v99 - 4);
  if ( LODWORD(v255) )
  {
    v109 = v245;
    if ( v245 != v234 )
    {
      v109 = v234;
      v238 = _guess_grouping(v234, (unsigned __int8 *)LODWORD(v255));
    }
    if ( v238 )
    {
      v232 = v109 + v238;
      wmemmove(
        (char *)v242 + 4 * v109 + 4 * v238,
        (char *)v242 + 4 * v109,
        ((char *)v99 - ((char *)v242 + 4 * v109)) >> 2);
      v254 = (int)v99;
      v252 = (int)v3;
      v138 = (char)*(_BYTE *)LODWORD(v255);
      LODWORD(v251) = (char *)v242 + 4 * v232 - 4;
      v139 = v138;
      do
      {
        v140 = v139;
        v141 = v109 - v139;
        v142 = (char *)v242 + 4 * (v109 - v139);
        v143 = LODWORD(v251) - 4 * v139;
        do
        {
          *(_DWORD *)(v143 + 4 * v140) = *(_DWORD *)&v142[4 * v140 - 4];
          --v140;
        }
        while ( v140 );
        v109 = v141;
        v144 = LODWORD(v255);
        v145 = LODWORD(v251) - 4 * v139 + 4;
        *(_DWORD *)(v145 - 4) = v247;
        LODWORD(v251) = v145 - 8;
        v146 = *(_BYTE *)(v144 + 1);
        if ( v146 > 0x7Eu )
          break;
        if ( v146 )
          LODWORD(v255) = v144 + 1;
        else
          v146 = *(_BYTE *)LODWORD(v255);
        v139 = (char)v146;
      }
      while ( v141 > (char)v146 );
      v147 = v254;
      v148 = v242;
      v149 = (double *)LODWORD(v251);
      v3 = (_DWORD *)v252;
      do
      {
        --v109;
        *(_DWORD *)v149 = *((_DWORD *)v148 + v109);
        v149 = (double *)((char *)v149 - 4);
      }
      while ( v148 < v149 );
      v242 = v148;
      v99 = (double *)(v147 + 4 * v238);
    }
  }
  if ( v262 != 102 )
  {
    if ( v263 && v236 == 103 && v261 == 4 )
    {
      v220 = v242;
      wmemcpy(v242, byte_80C9CE4, 6);
      *((_DWORD *)v220 + 1) = v250;
      if ( v99 >= v220 + 1 )
      {
        v221 = v99;
        v99 += 2;
        wmemset((_DWORD *)v220 + 6, 48, ((char *)v221 - (char *)(v220 + 1)) >> 2);
      }
      else
      {
        v99 = (double *)((char *)v99 + 20);
      }
    }
    else
    {
      *(_DWORD *)v99 = v262;
      *((_DWORD *)v99 + 1) = v263 == 0 ? 43 : 45;
      v110 = v261;
      if ( v261 <= 9 )
      {
        *((_DWORD *)v99 + 2) = 48;
        v112 = (_DWORD *)v99 + 3;
        v110 = v261;
      }
      else
      {
        for ( i = 10; i <= v261; i *= 10 )
          ;
        v112 = v99 + 1;
        do
        {
          i /= 10;
          *v112++ = v110 / i + 48;
          v110 = v261 % i;
          v261 %= i;
        }
        while ( i > 10 );
      }
      *v112 = v110 + 48;
      v99 = (double *)(v112 + 1);
    }
  }
  v113 = v268[0];
  v114 = *(_BYTE *)(a2 + 12);
  if ( v268[0] || (v114 & 0x50) != 0 )
    --v241;
  LODWORD(v255) = 0;
  LODWORD(v251) = (char *)v99 - (char *)v242;
  v241 -= ((char *)v99 - (char *)v242) >> 2;
  if ( (v114 & 0x20) == 0 )
  {
    if ( v241 <= 0 || *(_DWORD *)(a2 + 16) == 48 )
    {
      LODWORD(v255) = 0;
    }
    else
    {
      v226 = *(_DWORD *)(a2 + 16);
      if ( v253 )
        LODWORD(v255) = IO_wpadn((int)v3, v226, v241);
      else
        LODWORD(v255) = IO_padn((int)v3, v226, v241);
      v113 = v268[0];
      if ( LODWORD(v255) != v241 )
        goto LABEL_231;
    }
  }
  if ( v113 )
  {
    if ( v253 )
    {
      v115 = v3[22];
      if ( v115 )
      {
        v116 = *(_DWORD **)(v115 + 16);
        if ( (unsigned int)v116 < *(_DWORD *)(v115 + 20) )
        {
          *v116 = 45;
          *(_DWORD *)(v115 + 16) = v116 + 1;
          goto LABEL_239;
        }
      }
      v219 = _woverflow((int)v3, 45) == -1;
LABEL_473:
      if ( v219 )
        goto LABEL_231;
    }
    else
    {
      v155 = (_BYTE *)v3[5];
      if ( (unsigned int)v155 >= v3[6] )
      {
        v219 = _overflow((int)v3, 45) == -1;
        goto LABEL_473;
      }
      *v155 = 45;
      v3[5] = v155 + 1;
    }
LABEL_239:
    ++LODWORD(v255);
    LOBYTE(v117) = *(_BYTE *)(a2 + 12);
  }
  else
  {
    v117 = *(unsigned __int8 *)(a2 + 12);
    if ( (v117 & 0x40) != 0 )
    {
      if ( v253 )
      {
        v132 = v3[22];
        if ( !v132 || (v133 = *(_DWORD **)(v132 + 16), (unsigned int)v133 >= *(_DWORD *)(v132 + 20)) )
        {
          v219 = _woverflow((int)v3, 43) == -1;
          goto LABEL_473;
        }
        *v133 = 43;
        *(_DWORD *)(v132 + 16) = v133 + 1;
      }
      else
      {
        v194 = (_BYTE *)v3[5];
        if ( (unsigned int)v194 >= v3[6] )
        {
          v219 = _overflow((int)v3, 43) == -1;
          goto LABEL_473;
        }
        *v194 = 43;
        v3[5] = v194 + 1;
      }
      goto LABEL_239;
    }
    if ( (v117 & 0x10) != 0 )
    {
      if ( v253 )
      {
        v156 = v3[22];
        if ( !v156 || (v157 = *(_DWORD **)(v156 + 16), (unsigned int)v157 >= *(_DWORD *)(v156 + 20)) )
        {
          v219 = _woverflow((int)v3, 32) == -1;
          goto LABEL_473;
        }
        *v157 = 32;
        *(_DWORD *)(v156 + 16) = v157 + 1;
      }
      else
      {
        v205 = (_BYTE *)v3[5];
        if ( (unsigned int)v205 >= v3[6] )
        {
          v219 = _overflow((int)v3, 32) == -1;
          goto LABEL_473;
        }
        *v205 = 32;
        v3[5] = v205 + 1;
      }
      goto LABEL_239;
    }
  }
  if ( (v117 & 0x20) == 0 && v241 > 0 && *(_DWORD *)(a2 + 16) == 48 )
  {
    if ( v253 )
      v118 = IO_wpadn((int)v3, 48, v241);
    else
      v118 = IO_padn((int)v3, 48, v241);
    if ( v118 != v241 )
      goto LABEL_231;
    LODWORD(v255) += v241;
  }
  if ( v253 )
  {
    v124 = 0;
    v245 = 0;
    v254 = 0;
    goto LABEL_270;
  }
  v254 = 1;
  if ( (*(_BYTE *)(a2 + 13) & 8) != 0 )
    v254 = *(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFDC) + 88);
  v119 = 0;
  v120 = strlen(v248);
  v252 = 0;
  v249 = v120;
  if ( v246 )
  {
    v121 = strlen(v246);
    v119 = v121 * v238;
    v252 = v121;
  }
  v122 = v249 + v239 * v254 + 2 + v119;
  if ( v233 )
  {
    v254 = malloc(v122);
    if ( !v254 )
    {
      v19 = -1;
      free(v240);
      return v19;
    }
  }
  else
  {
    v123 = alloca(v122 + 15);
    v254 = (int)v231;
  }
  v124 = (unsigned int *)v254;
  v245 = v254 + v122;
  if ( v99 <= v242 )
    goto LABEL_270;
  v125 = (int)v247;
  v126 = v242;
  v247 = v3;
  v127 = v250;
  while ( 2 )
  {
    v128 = *(_DWORD *)v126;
    if ( *(_DWORD *)v126 == v127 )
    {
      v229 = v249;
      v129 = v248;
      goto LABEL_261;
    }
    if ( v125 == v128 )
    {
      v229 = v252;
      v129 = v246;
LABEL_261:
      v232 = v125;
      v124 = (unsigned int *)mempcpy(v124, v129, v229);
      v125 = v232;
    }
    else
    {
      *(_BYTE *)v124 = v128;
      v124 = (unsigned int *)((char *)v124 + 1);
    }
    v126 = (double *)((char *)v126 + 4);
    if ( v99 > v126 )
      continue;
    break;
  }
  v3 = v247;
LABEL_270:
  if ( (*(_BYTE *)(a2 + 13) & 8) != 0 )
  {
    v134 = i18n_number_rewrite_0((_BYTE *)v254, (int)v124, v245);
    v124 = (unsigned int *)v245;
  }
  else
  {
    v134 = (_BYTE *)v254;
  }
  if ( v253 )
  {
    v135 = SLODWORD(v251) >> 2;
    v136 = (unsigned int)(LODWORD(v251) + 3) > 6;
  }
  else
  {
    v135 = (char *)v124 - v134;
    v136 = (char *)v124 - v134 > 20;
  }
  if ( v136 )
  {
    if ( v253 )
      v134 = v242;
    if ( v135 == (*(int (__cdecl **)(_DWORD *, _BYTE *, int))(v3[37] + 28))(v3, v134, v135) )
    {
      v19 = v135 + LODWORD(v255);
      goto LABEL_279;
    }
LABEL_231:
    v19 = -1;
    if ( v233 )
      free(v240);
  }
  else
  {
    v19 = LODWORD(v255);
    if ( v253 )
    {
      if ( v135 )
      {
        LODWORD(v255) = (char *)v242 - 4 * LODWORD(v255);
        do
        {
          v198 = v3[22];
          v199 = *(_DWORD *)(LODWORD(v255) + 4 * v19);
          if ( v198 && (v196 = *(_DWORD **)(v198 + 16), (unsigned int)v196 < *(_DWORD *)(v198 + 20)) )
          {
            *v196 = v199;
            v197 = v199 == -1;
            *(_DWORD *)(v198 + 16) = v196 + 1;
          }
          else
          {
            v197 = _woverflow((int)v3, *(_DWORD *)(LODWORD(v255) + 4 * v19)) == -1;
          }
          if ( v197 )
            goto LABEL_231;
          ++v19;
        }
        while ( --v135 );
      }
    }
    else
    {
      for ( j = (int)&v134[-LODWORD(v255)]; v135; --v135 )
      {
        v159 = (unsigned __int8 *)v3[5];
        v160 = *(_BYTE *)(j + v19);
        if ( (unsigned int)v159 < v3[6] )
        {
          *v159 = v160;
          v3[5] = v159 + 1;
        }
        else
        {
          v232 = j;
          v161 = _overflow((int)v3, v160);
          j = v232;
          if ( v161 == -1 )
            goto LABEL_231;
        }
        ++v19;
      }
    }
LABEL_279:
    if ( v233 )
    {
      free(v254);
      free(v240);
    }
    if ( v241 > 0 && (*(_BYTE *)(a2 + 12) & 0x20) != 0 )
    {
      v227 = *(_DWORD *)(a2 + 16);
      v137 = v253 ? IO_wpadn((int)v3, v227, v241) : IO_padn((int)v3, v227, v241);
      v19 += v137;
      if ( v137 != v241 )
        goto LABEL_231;
    }
  }
  return v19;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80C9CE4: using guessed type _BYTE byte_80C9CE4[28];
// 80DB6C0: using guessed type int fpioconst_pow10[4];
// 80DB7A0: using guessed type _BYTE _tens[8];
// 80DB7A8: using guessed type unsigned int dword_80DB7A8[886];

//----- (08064320) --------------------------------------------------------
void __cdecl register_printf_specifier(unsigned int a1, int a2, int a3)
{
  bool v4; // zf
  int v5; // eax
  int v6; // eax

  if ( a1 > 0xFF )
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    return;
  }
  _ECX = 1;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg ds:lock_2, ecx }
  if ( !v4 )
  {
    L_lock_18(0);
    return;
  }
  v5 = _printf_function_table;
  if ( !_printf_function_table )
  {
    calloc(256, 8u);
    _printf_arginfo_table = v6;
    if ( !v6 )
      goto LABEL_7;
    v5 = v6 + 1024;
    _printf_function_table = v5;
  }
  *(_DWORD *)(v5 + 4 * a1) = a2;
  *(_DWORD *)(_printf_arginfo_table + 4 * a1) = a3;
LABEL_7:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --lock_2 )
    L_unlock_38();
}
// 80643AB: variable 'v6' is possibly undefined
// 80F0CCC: using guessed type int lock_2;
// 80F129C: using guessed type int _printf_function_table;
// 80F137C: using guessed type int _printf_arginfo_table;

//----- (080643E5) --------------------------------------------------------
void __usercall L_lock_18(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &lock_2);
  JUMPOUT(0x8064353);
}
// 80643F0: control flows out of bounds to 8064353
// 80F0CCC: using guessed type int lock_2;

//----- (080643F5) --------------------------------------------------------
void L_unlock_38()
{
  _lll_unlock_wake_private(&lock_2);
  JUMPOUT(0x8064385);
}
// 8064400: control flows out of bounds to 8064385
// 80F0CCC: using guessed type int lock_2;

//----- (08064410) --------------------------------------------------------
int __cdecl _printf_fphex(_DWORD *a1, int a2, long double **a3)
{
  int v3; // esi
  int v4; // ecx
  _BYTE *v5; // ebp
  int v6; // ecx
  long double *v7; // eax
  char v8; // di
  int *v9; // ebp
  _BOOL4 v10; // edx
  int v11; // ecx
  _BYTE *v12; // eax
  int v13; // ecx
  int v14; // ecx
  int v15; // eax
  _BOOL4 v16; // edx
  int v17; // edi
  int v18; // edx
  _DWORD *v19; // eax
  int v20; // edx
  int v21; // eax
  int v22; // edx
  int *v23; // ecx
  bool v24; // dl
  int v25; // ecx
  int v26; // eax
  int v27; // edx
  int v29; // ecx
  _BYTE *v30; // edi
  unsigned int v31; // eax
  int v32; // ecx
  _BYTE *v33; // edx
  int v34; // ecx
  _BYTE *v35; // eax
  char v36; // al
  int v37; // edx
  _DWORD *v38; // eax
  _BYTE *v39; // eax
  int v40; // edi
  int *v41; // eax
  char *v42; // edx
  unsigned int v43; // edx
  int v44; // eax
  _BYTE *v45; // eax
  int v46; // edx
  _DWORD *v47; // eax
  char *v48; // edi
  int *v49; // eax
  int *v50; // edx
  char *v51; // eax
  char *v52; // ecx
  int v53; // eax
  unsigned int v54; // edi
  long double *v55; // ebp
  int v56; // eax
  int v57; // eax
  int v58; // eax
  int v59; // eax
  int v60; // edx
  _DWORD *v61; // eax
  int v62; // eax
  _DWORD *v63; // edx
  int v64; // edx
  int v65; // eax
  int *v66; // ecx
  bool v67; // dl
  int v68; // eax
  int v69; // eax
  _DWORD *v70; // edx
  bool v71; // cl
  int v72; // edx
  int v73; // eax
  int i; // edi
  unsigned __int8 *v75; // eax
  unsigned __int8 v76; // cl
  int v77; // edi
  char *v78; // ebp
  unsigned __int8 *v79; // eax
  unsigned __int8 v80; // cl
  int v81; // eax
  int v82; // edx
  int v83; // ecx
  int v84; // eax
  int v85; // ecx
  int *v86; // edi
  bool v87; // al
  int v88; // eax
  int v89; // edi
  int *v90; // ecx
  char *v91; // ecx
  char *j; // ebp
  unsigned __int8 *v93; // eax
  unsigned __int8 v94; // dl
  int v95; // eax
  int v96; // eax
  int v97; // edx
  _BYTE *v98; // eax
  int v99; // eax
  bool v100; // al
  _BYTE *v101; // eax
  int *v102; // eax
  char *v103; // edx
  int v104; // eax
  int *v105; // edx
  bool v106; // cl
  char v107; // al
  int v108; // edx
  _DWORD *v109; // eax
  _BYTE *v110; // eax
  _BYTE *v111; // eax
  char *v112; // eax
  int v113; // edx
  _DWORD *v114; // eax
  _BYTE *v115; // eax
  int *v116; // esi
  int v117; // eax
  int v118; // ecx
  int *v119; // ebp
  bool v120; // cl
  _BYTE *v121; // ecx
  _BYTE *v122; // ecx
  char *v123; // esi
  int v124; // eax
  int v125; // edx
  _DWORD *v126; // ebp
  bool v127; // dl
  _BYTE *v128; // eax
  int v129; // eax
  char v130; // bp
  char *v131; // edx
  _BYTE *v132; // eax
  int v133; // eax
  int v134; // eax
  int v135; // eax
  int v136; // eax
  int v137; // eax
  int v138; // eax
  bool v139; // al
  int v140; // eax
  int v141; // eax
  bool v142; // al
  int v143; // eax
  int v144; // eax
  bool v145; // al
  int v146; // eax
  long double v147; // [esp+0h] [ebp-18Ch]
  long double v148; // [esp+0h] [ebp-18Ch]
  int v149; // [esp+4h] [ebp-188h]
  int v150; // [esp+4h] [ebp-188h]
  int v151; // [esp+8h] [ebp-184h]
  int v152; // [esp+20h] [ebp-16Ch]
  int v153; // [esp+20h] [ebp-16Ch]
  int v154; // [esp+20h] [ebp-16Ch]
  char *v155; // [esp+20h] [ebp-16Ch]
  int v156; // [esp+20h] [ebp-16Ch]
  char *v157; // [esp+20h] [ebp-16Ch]
  _BOOL4 v158; // [esp+34h] [ebp-158h]
  int v159; // [esp+34h] [ebp-158h]
  int v160; // [esp+34h] [ebp-158h]
  int v161; // [esp+34h] [ebp-158h]
  int v162; // [esp+34h] [ebp-158h]
  int v163; // [esp+34h] [ebp-158h]
  int v164; // [esp+34h] [ebp-158h]
  int v165; // [esp+34h] [ebp-158h]
  int v166; // [esp+34h] [ebp-158h]
  int v167; // [esp+34h] [ebp-158h]
  int v168; // [esp+38h] [ebp-154h]
  _BYTE *v169; // [esp+38h] [ebp-154h]
  int *v170; // [esp+38h] [ebp-154h]
  long double *v171; // [esp+38h] [ebp-154h]
  long double *v172; // [esp+38h] [ebp-154h]
  int v173; // [esp+38h] [ebp-154h]
  int v174; // [esp+3Ch] [ebp-150h]
  bool v175; // [esp+3Ch] [ebp-150h]
  int v176; // [esp+3Ch] [ebp-150h]
  int v177; // [esp+3Ch] [ebp-150h]
  long double v178; // [esp+40h] [ebp-14Ch]
  int v179; // [esp+40h] [ebp-14Ch]
  double v180; // [esp+40h] [ebp-14Ch]
  int v181; // [esp+40h] [ebp-14Ch]
  char *v182; // [esp+40h] [ebp-14Ch]
  _BOOL4 v183; // [esp+4Ch] [ebp-140h]
  _BYTE *v184; // [esp+50h] [ebp-13Ch]
  int v185; // [esp+50h] [ebp-13Ch]
  int v186; // [esp+54h] [ebp-138h]
  unsigned int v187; // [esp+58h] [ebp-134h]
  char *v188; // [esp+58h] [ebp-134h]
  unsigned int v189; // [esp+58h] [ebp-134h]
  int *v190; // [esp+60h] [ebp-12Ch]
  unsigned int v191; // [esp+60h] [ebp-12Ch]
  _BOOL4 v192; // [esp+68h] [ebp-124h]
  char *v193; // [esp+68h] [ebp-124h]
  int v194; // [esp+6Ch] [ebp-120h]
  char *v195; // [esp+6Ch] [ebp-120h]
  char v196; // [esp+70h] [ebp-11Ch]
  _BOOL4 v197; // [esp+80h] [ebp-10Ch]
  int v198; // [esp+84h] [ebp-108h]
  int v199[12]; // [esp+E8h] [ebp-A4h] BYREF
  int v200; // [esp+118h] [ebp-74h]
  int v201[3]; // [esp+11Ch] [ebp-70h] BYREF
  char v202[16]; // [esp+12Ch] [ebp-60h] BYREF
  char v203[20]; // [esp+13Ch] [ebp-50h] BYREF
  long double v204; // [esp+150h] [ebp-3Ch] BYREF
  long double v205; // [esp+15Ch] [ebp-30h]
  char v206[28]; // [esp+170h] [ebp-1Ch] BYREF

  v3 = a2;
  v186 = *(_DWORD *)a2;
  v174 = *(_DWORD *)(a2 + 4);
  if ( (*(_BYTE *)(a2 + 13) & 1) != 0 )
  {
    v29 = *(_DWORD *)__readgsdword(0xFFFFFFE0);
    v30 = *(_BYTE **)(v29 + 44);
    v6 = *(_DWORD *)(v29 + 208);
    v184 = v30;
  }
  else
  {
    v4 = *(_DWORD *)__readgsdword(0xFFFFFFE4);
    v5 = *(_BYTE **)(v4 + 36);
    v6 = *(_DWORD *)(v4 + 48);
    v184 = v5;
  }
  v168 = v6;
  if ( !*v184 || !v6 )
    _assert_fail("*decimal != '\\0' && decimalwc != L'\\0'", "../stdio-common/printf_fphex.c", 166, "__printf_fphex");
  v7 = *a3;
  v183 = (*(_BYTE *)(a2 + 13) & 4) != 0;
  v8 = *(_BYTE *)(a2 + 12);
  if ( (v8 & 1) != 0 )
  {
    v178 = *v7;
    v205 = v178;
    v147 = v178;
    if ( isnanl(SLODWORD(v147), SDWORD1(v147), SWORD4(v147)) )
    {
      v9 = (int *)&unk_80C9CB4;
      v10 = (SBYTE9(v205) & 0x80u) != 0;
      v11 = *(_WORD *)(__readgsdword(0xFFFFFFF8) + 2 * *(_DWORD *)(a2 + 8)) & 0x100;
      if ( v11 )
        v9 = (int *)&unk_80C9CC4;
      v12 = &unk_80C9C9C;
      if ( !v11 )
        v12 = &unk_80C9C98;
      v169 = v12;
      goto LABEL_12;
    }
    v148 = v178;
    v31 = isinfl(SLODWORD(v148), SDWORD1(v148), SWORD4(v148));
    if ( v31 )
      goto LABEL_43;
    v204 = v178;
    v197 = (SBYTE9(v204) & 0x80u) != 0;
    if ( (v8 & 1) != 0 )
      goto LABEL_84;
    goto LABEL_67;
  }
  *(double *)&v205 = *(double *)v7;
  if ( !isnan(*(double *)&v205) )
  {
    v31 = isinf(*(double *)&v205);
    if ( v31 )
    {
LABEL_43:
      v9 = (int *)&unk_80C9CD4;
      v32 = *(_WORD *)(__readgsdword(0xFFFFFFF8) + 2 * *(_DWORD *)(a2 + 8)) & 0x100;
      if ( !v32 )
        v9 = (int *)&unk_80C9CA4;
      v33 = &unk_80C9C94;
      if ( v32 )
        v33 = &unk_80C9CA0;
      v169 = v33;
      v10 = v31 >> 31;
      goto LABEL_12;
    }
    v180 = *(double *)&v205;
    v197 = HIDWORD(v180) >> 31;
    if ( (v8 & 1) != 0 )
    {
LABEL_84:
      v191 = DWORD1(v205);
      v189 = LODWORD(v205);
      v192 = *(_QWORD *)&v205 == 0LL;
      v48 = itoa(*(unsigned __int64 *)&v205, v203, 0x10u, *(_DWORD *)(a2 + 8) == 65);
      v49 = itowa(__PAIR64__(v191, v189), v201, 0x10u, *(_DWORD *)(a2 + 8) == 65);
      v190 = v49;
      if ( v48 > v202 )
      {
        v50 = v49;
        v51 = v48;
        do
        {
          --v51;
          --v50;
          *v51 = 48;
          *v50 = 48;
        }
        while ( v51 > v202 );
        v52 = (char *)(v202 - (v48 - 1));
        v48 = v202;
        v190 = &v190[(_DWORD)v52 - 1];
      }
      v188 = v48 + 1;
      v53 = WORD4(v205) & 0x7FFF;
      v196 = *v48;
      if ( (WORD4(v205) & 0x7FFF) != 0 )
      {
        if ( (WORD4(v205) & 0x7FFFu) <= 0x4001 )
        {
          v198 = 1;
          v194 = 16386 - v53;
        }
        else
        {
          v194 = v53 - 16386;
          v198 = 0;
        }
        goto LABEL_91;
      }
      if ( !v192 )
      {
        v194 = 16385;
        goto LABEL_190;
      }
      goto LABEL_221;
    }
LABEL_67:
    v40 = DWORD1(v205) & 0xFFFFF;
    v187 = LODWORD(v205);
    v192 = (DWORD1(v205) & 0xFFFFF | LODWORD(v205)) == 0;
    v190 = itowa(*(_QWORD *)&v205 & 0xFFFFFFFFFFFFFLL, v201, 0x10u, *(_DWORD *)(a2 + 8) == 65);
    v188 = itoa(__PAIR64__(v40, v187), v203, 0x10u, *(_DWORD *)(a2 + 8) == 65);
    if ( v190 > v199 )
    {
      v41 = v190;
      v42 = v188;
      do
      {
        --v41;
        --v42;
        *v41 = 48;
        *v42 = 48;
      }
      while ( v41 > v199 );
      v43 = ((unsigned int)v190 + ~(unsigned int)v199) >> 2;
      v188 += ~v43;
      v190 = &v190[-v43 - 1];
    }
    v44 = (WORD3(v205) >> 4) & 0x7FF;
    v196 = 49 - ((WORD3(v205) & 0x7FF0) == 0);
    if ( ((WORD3(v205) >> 4) & 0x7FF) != 0 )
    {
      if ( ((WORD3(v205) >> 4) & 0x7FFu) <= 0x3FE )
      {
        v198 = 1;
        v194 = 1023 - v44;
      }
      else
      {
        v194 = v44 - 1023;
        v198 = 0;
      }
LABEL_91:
      if ( v192 )
      {
        v54 = v194;
        goto LABEL_93;
      }
      goto LABEL_191;
    }
    if ( !v192 )
    {
      v194 = 1022;
LABEL_190:
      v198 = 1;
LABEL_191:
      v193 = v203;
      if ( v200 == 48 )
      {
        v102 = v201;
        v103 = v203;
        do
        {
          --v102;
          --v103;
        }
        while ( *(v102 - 1) == 48 );
        v193 = v103;
      }
      if ( v186 == -1 )
      {
        v186 = v193 - v188;
        v54 = v194;
        goto LABEL_95;
      }
      if ( v186 >= v193 - v188 )
        goto LABEL_199;
      if ( v188[v186] <= 56 )
      {
        if ( v188[v186] != 56 )
          goto LABEL_199;
        if ( v193 - v188 <= v186 + 1 )
        {
          if ( v186 <= 0 )
          {
            if ( v186 || (unsigned int)(v196 - 48) > 9 == (v196 & 1) )
              goto LABEL_199;
LABEL_269:
            if ( v196 == 57 )
            {
              v54 = v194;
              v196 = *(_BYTE *)(a2 + 8);
              goto LABEL_95;
            }
            if ( *(int *)(__readgsdword(0xFFFFFFF4) + 4 * v196) > 101 )
            {
              v196 = 49;
              v54 = v194 + 4;
              if ( v198 )
              {
                v54 = v194 - 4;
                if ( v194 - 4 <= 0 )
                {
                  v54 = 4 - v194;
                  v198 = 0;
                }
                else
                {
                  v198 = 1;
                }
              }
LABEL_95:
              v55 = &v204;
              v195 = itoa_word(v54, v206, 0xAu, 0);
              do
              {
                v55 = (long double *)((char *)v55 - 4);
                v56 = itowa_lower_digits[v54 % 0xA];
                v54 /= 0xAu;
                *(_DWORD *)v55 = v56;
              }
              while ( v54 );
              if ( v197 )
                v57 = -4;
              else
                v57 = -3 - ((*(_BYTE *)(a2 + 12) & 0x50) != 0);
              v181 = v174 + v195 - v206 + v57 - v186 - 2;
              if ( v186 > 0 || (*(_BYTE *)(a2 + 12) & 8) != 0 )
              {
                v58 = 1;
                if ( !v183 )
                  v58 = strlen(v184);
                v181 -= v58;
              }
              v176 = 0;
              if ( (*(_BYTE *)(a2 + 12) & 0x20) == 0 )
              {
                if ( v181 <= 0 || *(_DWORD *)(a2 + 16) == 48 )
                {
                  v176 = 0;
                }
                else
                {
                  if ( v183 )
                    v59 = IO_wpadn((int)a1, 32, v181);
                  else
                    v59 = IO_padn((int)a1, 32, v181);
                  v17 = -1;
                  if ( v59 != v181 )
                    return v17;
                  v176 = v181;
                }
              }
              if ( v197 )
              {
                if ( v183 )
                {
                  v60 = a1[22];
                  if ( v60 )
                  {
                    v61 = *(_DWORD **)(v60 + 16);
                    if ( (unsigned int)v61 < *(_DWORD *)(v60 + 20) )
                    {
                      *v61 = 45;
                      *(_DWORD *)(v60 + 16) = v61 + 1;
LABEL_115:
                      ++v176;
                      goto LABEL_116;
                    }
                  }
                  v139 = _woverflow((int)a1, 45) == -1;
                }
                else
                {
                  v115 = (_BYTE *)a1[5];
                  if ( (unsigned int)v115 < a1[6] )
                  {
                    *v115 = 45;
                    a1[5] = v115 + 1;
                    goto LABEL_115;
                  }
                  v139 = _overflow((int)a1, 45) == -1;
                }
              }
              else
              {
                v107 = *(_BYTE *)(a2 + 12);
                if ( (v107 & 0x40) != 0 )
                {
                  if ( v183 )
                  {
                    v108 = a1[22];
                    if ( v108 )
                    {
                      v109 = *(_DWORD **)(v108 + 16);
                      if ( (unsigned int)v109 < *(_DWORD *)(v108 + 20) )
                      {
                        *v109 = 43;
                        *(_DWORD *)(v108 + 16) = v109 + 1;
                        goto LABEL_115;
                      }
                    }
                    v139 = _woverflow((int)a1, 43) == -1;
                  }
                  else
                  {
                    v128 = (_BYTE *)a1[5];
                    if ( (unsigned int)v128 < a1[6] )
                    {
                      *v128 = 43;
                      a1[5] = v128 + 1;
                      goto LABEL_115;
                    }
                    v139 = _overflow((int)a1, 43) == -1;
                  }
                }
                else
                {
                  if ( (v107 & 0x10) == 0 )
                  {
LABEL_116:
                    if ( v183 )
                    {
                      v62 = a1[22];
                      if ( v62 )
                      {
                        v63 = *(_DWORD **)(v62 + 16);
                        if ( (unsigned int)v63 < *(_DWORD *)(v62 + 20) )
                        {
                          *v63 = 48;
                          *(_DWORD *)(v62 + 16) = v63 + 1;
                          goto LABEL_120;
                        }
                      }
                      v142 = _woverflow((int)a1, 48) == -1;
                    }
                    else
                    {
                      v110 = (_BYTE *)a1[5];
                      if ( (unsigned int)v110 < a1[6] )
                      {
                        *v110 = 48;
                        a1[5] = v110 + 1;
                        goto LABEL_120;
                      }
                      v142 = _overflow((int)a1, 48) == -1;
                    }
                    v17 = -1;
                    if ( v142 )
                      return v17;
LABEL_120:
                    v64 = *(_DWORD *)(a2 + 8) + 23;
                    if ( v183 )
                    {
                      v65 = a1[22];
                      if ( v65 && (v66 = *(int **)(v65 + 16), (unsigned int)v66 < *(_DWORD *)(v65 + 20)) )
                      {
                        *v66 = v64;
                        v67 = v64 == -1;
                        *(_DWORD *)(v65 + 16) = v66 + 1;
                      }
                      else
                      {
                        v67 = _woverflow((int)a1, *(_DWORD *)(a2 + 8) + 23) == -1;
                      }
                    }
                    else
                    {
                      v111 = (_BYTE *)a1[5];
                      if ( (unsigned int)v111 < a1[6] )
                      {
                        *v111 = v64;
                        a1[5] = v111 + 1;
                        goto LABEL_125;
                      }
                      v67 = _overflow((int)a1, (unsigned __int8)v64) == -1;
                    }
                    v17 = -1;
                    if ( v67 )
                      return v17;
LABEL_125:
                    v177 = v176 + 2;
                    if ( (*(_BYTE *)(a2 + 12) & 0x20) == 0 && v181 > 0 && *(_DWORD *)(a2 + 16) == 48 )
                    {
                      if ( v183 )
                        v68 = IO_wpadn((int)a1, 48, v181);
                      else
                        v68 = IO_padn((int)a1, 48, v181);
                      v17 = -1;
                      if ( v68 != v181 )
                        return v17;
                      v177 += v181;
                    }
                    if ( v183 )
                    {
                      v69 = a1[22];
                      if ( v69 && (v70 = *(_DWORD **)(v69 + 16), (unsigned int)v70 < *(_DWORD *)(v69 + 20)) )
                      {
                        *v70 = v196;
                        v71 = v196 == -1;
                        *(_DWORD *)(v69 + 16) = v70 + 1;
                      }
                      else
                      {
                        v71 = _woverflow((int)a1, v196) == -1;
                      }
                    }
                    else
                    {
                      v112 = (char *)a1[5];
                      if ( (unsigned int)v112 < a1[6] )
                      {
                        *v112 = v196;
                        a1[5] = v112 + 1;
                        goto LABEL_137;
                      }
                      v71 = _overflow((int)a1, (unsigned __int8)v196) == -1;
                    }
                    v17 = -1;
                    if ( v71 )
                      return v17;
LABEL_137:
                    v72 = v177 + 1;
                    if ( v186 > 0 || (*(_BYTE *)(a2 + 12) & 8) != 0 )
                    {
                      if ( v183 )
                      {
                        v104 = a1[22];
                        if ( v104 && (v105 = *(int **)(v104 + 16), (unsigned int)v105 < *(_DWORD *)(v104 + 20)) )
                        {
                          *v105 = v168;
                          v106 = v168 == -1;
                          *(_DWORD *)(v104 + 16) = v105 + 1;
                        }
                        else
                        {
                          v106 = _woverflow((int)a1, v168) == -1;
                        }
                        v17 = -1;
                        if ( v106 )
                          return v17;
                        v72 = v177 + 2;
                      }
                      else
                      {
                        v73 = strlen(v184);
                        v72 = v177 + 1;
                        for ( i = v73; i; --i )
                        {
                          v75 = (unsigned __int8 *)a1[5];
                          v76 = v184[v72 - v177 - 1];
                          if ( (unsigned int)v75 >= a1[6] )
                          {
                            v162 = v72;
                            v136 = _overflow((int)a1, v76);
                            v72 = v162;
                            if ( v136 == -1 )
                              return -1;
                          }
                          else
                          {
                            *v75 = v76;
                            a1[5] = v75 + 1;
                          }
                          ++v72;
                        }
                      }
                      if ( v186 > 0 )
                      {
                        v77 = v193 - v188;
                        if ( v193 - v188 > v186 )
                          v77 = v186;
                        if ( v183 )
                        {
                          if ( v77 )
                          {
                            v172 = v55;
                            v116 = &v190[-v72];
                            while ( 1 )
                            {
                              v117 = a1[22];
                              v118 = v116[v72];
                              if ( v117 && (v119 = *(int **)(v117 + 16), (unsigned int)v119 < *(_DWORD *)(v117 + 20)) )
                              {
                                *v119 = v118;
                                v120 = v118 == -1;
                                *(_DWORD *)(v117 + 16) = v119 + 1;
                              }
                              else
                              {
                                v161 = v72;
                                v135 = _woverflow((int)a1, v116[v72]);
                                v72 = v161;
                                v120 = v135 == -1;
                              }
                              if ( v120 )
                                return -1;
                              ++v72;
                              if ( !--v77 )
                              {
                                v55 = v172;
                                v3 = a2;
                                break;
                              }
                            }
                          }
                        }
                        else if ( v77 )
                        {
                          v171 = v55;
                          v78 = &v188[-v72];
                          do
                          {
                            v79 = (unsigned __int8 *)a1[5];
                            v80 = v78[v72];
                            if ( (unsigned int)v79 >= a1[6] )
                            {
                              v164 = v72;
                              v140 = _overflow((int)a1, v80);
                              v72 = v164;
                              if ( v140 == -1 )
                                return -1;
                            }
                            else
                            {
                              *v79 = v80;
                              a1[5] = v79 + 1;
                            }
                            ++v72;
                            --v77;
                          }
                          while ( v77 );
                          v55 = v171;
                        }
                        if ( v188 - v193 + v186 > 0 )
                        {
                          v151 = v188 - v193 + v186;
                          v159 = v72;
                          if ( v183 )
                          {
                            v81 = IO_wpadn((int)a1, 48, v151);
                            v82 = v159;
                            v83 = v188 - v193 + v186;
                          }
                          else
                          {
                            v81 = IO_padn((int)a1, 48, v151);
                            v83 = v188 - v193 + v186;
                            v82 = v159;
                          }
                          v17 = -1;
                          if ( v81 != v83 )
                            return v17;
                          v72 = v81 + v82;
                        }
                      }
                    }
                    v84 = *(_DWORD *)(v3 + 8) + 15;
                    if ( v183 )
                    {
                      v85 = a1[22];
                      if ( v85 && (v86 = *(int **)(v85 + 16), (unsigned int)v86 < *(_DWORD *)(v85 + 20)) )
                      {
                        *v86 = v84;
                        v87 = v84 == -1;
                        *(_DWORD *)(v85 + 16) = v86 + 1;
                      }
                      else
                      {
                        v163 = v72;
                        v138 = _woverflow((int)a1, v84);
                        v72 = v163;
                        v87 = v138 == -1;
                      }
                    }
                    else
                    {
                      v121 = (_BYTE *)a1[5];
                      if ( (unsigned int)v121 < a1[6] )
                      {
                        *v121 = v84;
                        a1[5] = v121 + 1;
                        goto LABEL_163;
                      }
                      v165 = v72;
                      v141 = _overflow((int)a1, (unsigned __int8)v84);
                      v72 = v165;
                      v87 = v141 == -1;
                    }
                    v17 = -1;
                    if ( v87 )
                      return v17;
LABEL_163:
                    v88 = v198 == 0 ? 43 : 45;
                    if ( v183 )
                    {
                      v89 = a1[22];
                      if ( v89 )
                      {
                        v90 = *(int **)(v89 + 16);
                        if ( (unsigned int)v90 < *(_DWORD *)(v89 + 20) )
                        {
                          *v90 = v88;
                          *(_DWORD *)(v89 + 16) = v90 + 1;
LABEL_167:
                          v91 = (char *)(v206 - v195);
                          v17 = v72 + 2;
                          if ( v183 )
                          {
                            if ( v91 )
                            {
                              v173 = v3;
                              v123 = (char *)v55 - 4 * v72;
                              while ( 1 )
                              {
                                v124 = a1[22];
                                v125 = *(_DWORD *)&v123[4 * v17 - 8];
                                if ( v124
                                  && (v126 = *(_DWORD **)(v124 + 16), (unsigned int)v126 < *(_DWORD *)(v124 + 20)) )
                                {
                                  *v126 = v125;
                                  v127 = v125 == -1;
                                  *(_DWORD *)(v124 + 16) = v126 + 1;
                                }
                                else
                                {
                                  v155 = v91;
                                  v134 = _woverflow((int)a1, *(_DWORD *)&v123[4 * v17 - 8]);
                                  v91 = v155;
                                  v127 = v134 == -1;
                                }
                                if ( v127 )
                                  return -1;
                                ++v17;
                                if ( !--v91 )
                                {
                                  v3 = v173;
                                  break;
                                }
                              }
                            }
                          }
                          else
                          {
                            for ( j = &v195[-v72]; v91; --v91 )
                            {
                              v93 = (unsigned __int8 *)a1[5];
                              v94 = j[v17 - 2];
                              if ( (unsigned int)v93 >= a1[6] )
                              {
                                v157 = v91;
                                v143 = _overflow((int)a1, v94);
                                v91 = v157;
                                if ( v143 == -1 )
                                  return -1;
                              }
                              else
                              {
                                *v93 = v94;
                                a1[5] = v93 + 1;
                              }
                              ++v17;
                            }
                          }
                          if ( (*(_BYTE *)(v3 + 12) & 0x20) != 0 )
                          {
                            v95 = *(_DWORD *)(v3 + 16);
                            if ( v181 > 0 && v95 != 48 )
                            {
                              v96 = v183 ? IO_wpadn((int)a1, *(_DWORD *)(v3 + 16), v181) : IO_padn((int)a1, v95, v181);
                              v97 = v17 + v96;
                              v17 = -1;
                              if ( v96 == v181 )
                                return v97;
                            }
                          }
                          return v17;
                        }
                      }
                      v166 = v72;
                      v144 = _woverflow((int)a1, v198 == 0 ? 43 : 45);
                      v72 = v166;
                      v145 = v144 == -1;
                    }
                    else
                    {
                      v122 = (_BYTE *)a1[5];
                      if ( (unsigned int)v122 < a1[6] )
                      {
                        *v122 = v88;
                        a1[5] = v122 + 1;
                        goto LABEL_167;
                      }
                      v167 = v72;
                      v146 = _overflow((int)a1, (unsigned __int8)v88);
                      v72 = v167;
                      v145 = v146 == -1;
                    }
                    v17 = -1;
                    if ( v145 )
                      return v17;
                    goto LABEL_167;
                  }
                  if ( v183 )
                  {
                    v113 = a1[22];
                    if ( v113 )
                    {
                      v114 = *(_DWORD **)(v113 + 16);
                      if ( (unsigned int)v114 < *(_DWORD *)(v113 + 20) )
                      {
                        *v114 = 32;
                        *(_DWORD *)(v113 + 16) = v114 + 1;
                        goto LABEL_115;
                      }
                    }
                    v139 = _woverflow((int)a1, 32) == -1;
                  }
                  else
                  {
                    v132 = (_BYTE *)a1[5];
                    if ( (unsigned int)v132 < a1[6] )
                    {
                      *v132 = 32;
                      a1[5] = v132 + 1;
                      goto LABEL_115;
                    }
                    v139 = _overflow((int)a1, 32) == -1;
                  }
                }
              }
              v17 = -1;
              if ( v139 )
                return v17;
              goto LABEL_115;
            }
            ++v196;
LABEL_199:
            v54 = v194;
            goto LABEL_95;
          }
          if ( (unsigned int)(v188[v186 - 1] - 48) > 9 == (v188[v186 - 1] & 1) )
            goto LABEL_199;
        }
      }
      v129 = v186 - 1;
      if ( v186 - 1 >= 0 )
      {
        v182 = &v188[v129];
        v130 = v188[v129];
        if ( v130 == 57 )
        {
LABEL_278:
          v190[v129] = *(_DWORD *)(a2 + 8);
          *v182 = *(_DWORD *)(a2 + 8);
          goto LABEL_199;
        }
        if ( *(int *)(__readgsdword(0xFFFFFFF4) + 4 * v130) <= 101 )
        {
LABEL_280:
          *v182 = v130 + 1;
          ++v190[v129];
          goto LABEL_199;
        }
        v131 = &v188[v129];
        while ( 1 )
        {
          *v131 = 48;
          v190[v129--] = 48;
          if ( v129 == -1 )
            break;
          v131 = &v188[v129];
          if ( v188[v129] == 57 )
          {
            v182 = &v188[v129];
            goto LABEL_278;
          }
          if ( *(int *)(__readgsdword(0xFFFFFFF4) + 4 * v188[v129]) <= 101 )
          {
            v130 = v188[v129];
            v182 = &v188[v129];
            goto LABEL_280;
          }
        }
      }
      goto LABEL_269;
    }
LABEL_221:
    v54 = 0;
    v198 = 0;
LABEL_93:
    v193 = v188;
    if ( v186 == -1 )
      v186 = 0;
    goto LABEL_95;
  }
  v9 = (int *)&unk_80C9CC4;
  v10 = (SBYTE7(v205) & 0x80u) != 0;
  v34 = *(_WORD *)(__readgsdword(0xFFFFFFF8) + 2 * *(_DWORD *)(a2 + 8)) & 0x100;
  if ( !v34 )
    v9 = (int *)&unk_80C9CB4;
  v35 = &unk_80C9C98;
  if ( v34 )
    v35 = &unk_80C9C9C;
  v169 = v35;
LABEL_12:
  if ( v10 || (v13 = v174, (v8 & 0x50) != 0) )
    v13 = v174 - 1;
  v14 = v13 - 3;
  v175 = v14 > 0;
  if ( v14 <= 0 || (v8 & 0x20) != 0 )
  {
    v17 = 0;
    if ( v10 )
      goto LABEL_21;
LABEL_55:
    v36 = *(_BYTE *)(a2 + 12);
    if ( (v36 & 0x40) != 0 )
    {
      if ( v183 )
      {
        v37 = a1[22];
        if ( v37 )
        {
          v38 = *(_DWORD **)(v37 + 16);
          if ( (unsigned int)v38 < *(_DWORD *)(v37 + 20) )
          {
            *v38 = 43;
            *(_DWORD *)(v37 + 16) = v38 + 1;
            goto LABEL_25;
          }
        }
        v150 = 43;
        goto LABEL_300;
      }
      v98 = (_BYTE *)a1[5];
      if ( (unsigned int)v98 < a1[6] )
      {
        *v98 = 43;
        a1[5] = v98 + 1;
        goto LABEL_25;
      }
      v149 = 43;
    }
    else
    {
      if ( (v36 & 0x10) == 0 )
        goto LABEL_26;
      if ( v183 )
      {
        v46 = a1[22];
        if ( v46 )
        {
          v47 = *(_DWORD **)(v46 + 16);
          if ( (unsigned int)v47 < *(_DWORD *)(v46 + 20) )
          {
            *v47 = 32;
            *(_DWORD *)(v46 + 16) = v47 + 1;
            goto LABEL_25;
          }
        }
        v150 = 32;
        goto LABEL_300;
      }
      v101 = (_BYTE *)a1[5];
      if ( (unsigned int)v101 < a1[6] )
      {
        *v101 = 32;
        a1[5] = v101 + 1;
        goto LABEL_25;
      }
      v149 = 32;
    }
LABEL_183:
    v154 = v14;
    v99 = _overflow((int)a1, v149);
    v14 = v154;
    v100 = v99 == -1;
    goto LABEL_184;
  }
  v158 = v10;
  v152 = v14;
  if ( v183 )
  {
    v15 = IO_wpadn((int)a1, 32, v14);
    v16 = v158;
    v14 = v152;
  }
  else
  {
    v15 = IO_padn((int)a1, 32, v14);
    v14 = v152;
    v16 = v158;
  }
  v17 = -1;
  if ( v15 != v14 )
    return v17;
  v17 = v14;
  if ( !v16 )
    goto LABEL_55;
LABEL_21:
  if ( !v183 )
  {
    v45 = (_BYTE *)a1[5];
    if ( (unsigned int)v45 < a1[6] )
    {
      *v45 = 45;
      a1[5] = v45 + 1;
      goto LABEL_25;
    }
    v149 = 45;
    goto LABEL_183;
  }
  v18 = a1[22];
  if ( !v18 || (v19 = *(_DWORD **)(v18 + 16), (unsigned int)v19 >= *(_DWORD *)(v18 + 20)) )
  {
    v150 = 45;
LABEL_300:
    v156 = v14;
    v137 = _woverflow((int)a1, v150);
    v14 = v156;
    v100 = v137 == -1;
LABEL_184:
    if ( v100 )
      return -1;
    goto LABEL_25;
  }
  *v19 = 45;
  *(_DWORD *)(v18 + 16) = v19 + 1;
LABEL_25:
  ++v17;
LABEL_26:
  v20 = 0;
  if ( v183 )
  {
    v170 = v9 + 3;
    v185 = v14;
    while ( 1 )
    {
      v21 = a1[22];
      v22 = *v9++;
      if ( v21 && (v23 = *(int **)(v21 + 16), (unsigned int)v23 < *(_DWORD *)(v21 + 20)) )
      {
        *v23 = v22;
        v24 = v22 == -1;
        *(_DWORD *)(v21 + 16) = v23 + 1;
      }
      else
      {
        v24 = _woverflow((int)a1, v22) == -1;
      }
      if ( v24 )
        return -1;
      ++v17;
      if ( v9 == v170 )
      {
        v25 = v185;
        goto LABEL_34;
      }
    }
  }
  v179 = v14;
  do
  {
    v39 = (_BYTE *)a1[5];
    if ( (unsigned int)v39 >= a1[6] )
    {
      v160 = v20;
      v133 = _overflow((int)a1, (unsigned __int8)v169[v20]);
      v20 = v160;
      if ( v133 == -1 )
        return -1;
    }
    else
    {
      *v39 = v169[v20];
      a1[5] = v39 + 1;
    }
    ++v20;
    ++v17;
  }
  while ( v20 != 3 );
  v25 = v179;
LABEL_34:
  if ( v175 && (*(_BYTE *)(a2 + 12) & 0x20) != 0 )
  {
    v153 = v25;
    if ( v183 )
      v26 = IO_wpadn((int)a1, 32, v25);
    else
      v26 = IO_padn((int)a1, 32, v25);
    v27 = v17 + v26;
    v17 = -1;
    if ( v26 == v153 )
      return v27;
  }
  return v17;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80DC620: using guessed type int itowa_lower_digits[36];
// 8064410: using guessed type int var_70[3];
// 8064410: using guessed type int var_A4[12];

//----- (08065A00) --------------------------------------------------------
void __usercall register_printf_modifier(long double a1@<st0>, char *a2)
{
  unsigned int v2; // eax
  char *v3; // ebx
  bool v5; // zf
  int v6; // ebx
  int v7; // eax
  int v8; // edi
  int v9; // ecx
  int v10; // eax

  v2 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 )
  {
    v3 = a2;
    while ( v2 <= 0xFF )
    {
      v3 += 4;
      v2 = *(_DWORD *)v3;
      if ( !*(_DWORD *)v3 )
      {
        if ( (unsigned int)(next_bit - 16) <= 7 )
        {
          __writegsdword(0xFFFFFFE8, 0x1Cu);
        }
        else
        {
          _ECX = 1;
          v5 = __readgsdword(0xCu) == 0;
          if ( !v5 )
            __asm { lock }
          __asm { cmpxchg ds:lock_3, ecx }
          if ( v5 )
          {
            if ( _printf_modifier_table || (calloc(255, 4u), (_printf_modifier_table = v10) != 0) )
            {
              v6 = (v3 - a2) >> 2;
              malloc(a1, 4 * v6 + 8);
              v8 = v7;
              if ( v7 )
              {
                v9 = next_bit;
                *(_DWORD *)v7 = *(_DWORD *)(_printf_modifier_table + 4 * (unsigned __int8)*a2);
                *(_DWORD *)(v7 + 4) = 1 << v9;
                next_bit = v9 + 1;
                wmemcpy((_BYTE *)(v7 + 8), a2 + 4, v6);
                *(_DWORD *)(_printf_modifier_table + 4 * (unsigned __int8)*a2) = v8;
              }
            }
            if ( __readgsdword(0xCu) )
              __asm { lock }
            if ( --lock_3 )
              L_unlock_180();
          }
          else
          {
            L_lock_129(0);
          }
        }
        return;
      }
    }
  }
  __writegsdword(0xFFFFFFE8, 0x16u);
}
// 8065A9F: variable 'v7' is possibly undefined
// 8065B29: variable 'v10' is possibly undefined
// 80F0CD0: using guessed type int next_bit;
// 80F0CD4: using guessed type int lock_3;
// 80F12A0: using guessed type int _printf_modifier_table;

//----- (08065B50) --------------------------------------------------------
int __cdecl _handle_registered_modifier_mb(unsigned __int8 **a1, int a2)
{
  _DWORD *v2; // esi
  int result; // eax
  unsigned __int8 v4; // di
  _DWORD *v5; // edx
  int v6; // eax
  unsigned __int8 *v7; // eax
  int v8; // [esp+4h] [ebp-20h]
  unsigned __int8 *v9; // [esp+8h] [ebp-1Ch]
  int v10; // [esp+Ch] [ebp-18h]
  unsigned __int8 *v11; // [esp+10h] [ebp-14h]

  v8 = (int)*a1;
  v2 = *(_DWORD **)(_printf_modifier_table + 4 * **a1);
  result = 1;
  if ( v2 )
  {
    v11 = 0;
    v9 = 0;
    v4 = *(_BYTE *)(v8 + 1);
    v10 = 0;
    while ( 1 )
    {
      v5 = v2 + 2;
      if ( !v4 )
        break;
      v6 = v2[2];
      if ( !v6 )
      {
        v7 = (unsigned __int8 *)(v8 + 1);
LABEL_11:
        if ( (int)&v7[-v8] > (int)v9 )
        {
          v11 = v7;
          v9 = &v7[-v8];
          v10 = v2[1];
        }
        goto LABEL_13;
      }
      if ( v6 == v4 )
      {
        v7 = (unsigned __int8 *)(v8 + 1);
        while ( 1 )
        {
          ++v7;
          ++v5;
          if ( !*v7 )
            break;
          if ( !*v5 )
            goto LABEL_11;
          if ( *v5 != *v7 )
            goto LABEL_13;
        }
LABEL_10:
        if ( !*v5 )
          goto LABEL_11;
      }
LABEL_13:
      v2 = (_DWORD *)*v2;
      if ( !v2 )
      {
        result = 1;
        if ( v10 )
        {
          *(_WORD *)(a2 + 14) |= v10;
          *a1 = v11;
          return 0;
        }
        return result;
      }
    }
    v7 = (unsigned __int8 *)(v8 + 1);
    goto LABEL_10;
  }
  return result;
}
// 80F12A0: using guessed type int _printf_modifier_table;

//----- (08065C40) --------------------------------------------------------
int __cdecl _handle_registered_modifier_wc(_DWORD *a1, int a2)
{
  _DWORD *v2; // ebp
  _DWORD *v3; // esi
  int result; // eax
  int v5; // edi
  _DWORD *v6; // edx
  int v7; // eax
  _DWORD *v8; // eax
  int v9; // [esp+4h] [ebp-1Ch]
  int v10; // [esp+8h] [ebp-18h]
  _DWORD *v11; // [esp+Ch] [ebp-14h]

  v2 = (_DWORD *)*a1;
  v3 = *(_DWORD **)(_printf_modifier_table + 4 * *(_DWORD *)*a1);
  result = 1;
  if ( v3 )
  {
    v5 = v2[1];
    v11 = 0;
    v9 = 0;
    v10 = 0;
    while ( 1 )
    {
      v6 = v3 + 2;
      if ( !v5 )
        break;
      v7 = v3[2];
      if ( !v7 )
      {
        v8 = v2 + 1;
LABEL_11:
        if ( v8 - v2 > v9 )
        {
          v11 = v8;
          v9 = v8 - v2;
          v10 = v3[1];
        }
        goto LABEL_13;
      }
      if ( v7 == v5 )
      {
        v8 = v2 + 1;
        while ( 1 )
        {
          ++v8;
          ++v6;
          if ( !*v8 )
            break;
          if ( !*v6 )
            goto LABEL_11;
          if ( *v8 != *v6 )
            goto LABEL_13;
        }
LABEL_10:
        if ( !*v6 )
          goto LABEL_11;
      }
LABEL_13:
      v3 = (_DWORD *)*v3;
      if ( !v3 )
      {
        result = 1;
        if ( v10 )
        {
          *(_WORD *)(a2 + 14) |= v10;
          *a1 = v11;
          return 0;
        }
        return result;
      }
    }
    v8 = v2 + 1;
    goto LABEL_10;
  }
  return result;
}
// 80F12A0: using guessed type int _printf_modifier_table;

//----- (08065D16) --------------------------------------------------------
void __usercall L_lock_129(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &lock_3);
  JUMPOUT(0x8065A77);
}
// 8065D21: control flows out of bounds to 8065A77
// 80F0CD4: using guessed type int lock_3;

//----- (08065D26) --------------------------------------------------------
void L_unlock_180()
{
  _lll_unlock_wake_private(&lock_3);
  JUMPOUT(0x8065B05);
}
// 8065D31: control flows out of bounds to 8065B05
// 80F0CD4: using guessed type int lock_3;

//----- (08065D40) --------------------------------------------------------
void __cdecl register_printf_type(int a1)
{
  bool v2; // zf
  int v3; // edx
  int v4; // eax

  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg ds:lock_4, ecx }
  if ( v2 )
  {
    if ( _printf_va_arg_table || (calloc(248, 4u), (_printf_va_arg_table = v4) != 0) )
    {
      v3 = pa_next_type;
      if ( pa_next_type == 256 )
      {
        __writegsdword(0xFFFFFFE8, 0x1Cu);
      }
      else
      {
        ++pa_next_type;
        *(_DWORD *)(_printf_va_arg_table + 4 * v3 - 32) = a1;
      }
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --lock_4 )
      L_unlock_35();
  }
  else
  {
    L_lock_11(0);
  }
}
// 8065DBE: variable 'v4' is possibly undefined
// 80EF5D4: using guessed type int pa_next_type;
// 80F0CD8: using guessed type int lock_4;
// 80F1380: using guessed type int _printf_va_arg_table;

//----- (08065DE3) --------------------------------------------------------
void __usercall L_lock_11(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &lock_4);
  JUMPOUT(0x8065D62);
}
// 8065DEE: control flows out of bounds to 8065D62
// 80F0CD8: using guessed type int lock_4;

//----- (08065DF3) --------------------------------------------------------
void L_unlock_35()
{
  _lll_unlock_wake_private(&lock_4);
  JUMPOUT(0x8065DA2);
}
// 8065DFE: control flows out of bounds to 8065DA2
// 80F0CD8: using guessed type int lock_4;

//----- (08065E00) --------------------------------------------------------
int fprintf(int a1, int a2, ...)
{
  va_list va; // [esp+28h] [ebp+Ch] BYREF

  va_start(va, a2);
  return vfprintf(a1, a2, (char *)va);
}
// 805D080: using guessed type _DWORD __cdecl vfprintf(_DWORD, _DWORD, _DWORD);

//----- (08065E30) --------------------------------------------------------
int __usercall asprintf@<eax>(long double a1@<st0>, _DWORD *a2, int a3, ...)
{
  va_list va; // [esp+28h] [ebp+Ch] BYREF

  va_start(va, a3);
  return vasprintf(a1, a2, a3, (int)va);
}

//----- (08065E60) --------------------------------------------------------
int dprintf(unsigned int a1, int a2, ...)
{
  va_list va; // [esp+28h] [ebp+Ch] BYREF

  va_start(va, a2);
  return vdprintf(a1, a2, (int)va);
}

//----- (08065E90) --------------------------------------------------------
void __usercall sscanf(long double a1@<st0>, unsigned int a2, unsigned __int8 *a3, ...)
{
  va_list va; // [esp+28h] [ebp+Ch] BYREF

  va_start(va, a3);
  vsscanf(a1, a2, a3, (int *)va);
}

//----- (08065EC0) --------------------------------------------------------
void __cdecl funlockfile(int a1)
{
  int v1; // ecx
  _DWORD *v2; // edx
  bool v3; // zf

  v2 = *(_DWORD **)(a1 + 72);
  v3 = v2[1]-- == 1;
  if ( v3 )
  {
    v2[2] = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v3 = (*v2)-- == 1;
    if ( !v3 )
      L_unlock_16(v1, v2);
  }
}
// 8065EE9: variable 'v1' is possibly undefined

//----- (08065EED) --------------------------------------------------------
void __fastcall L_unlock_16(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x8065EEB);
}
// 8065EF4: control flows out of bounds to 8065EEB

//----- (08065F00) --------------------------------------------------------
int __cdecl _parse_one_specmb(unsigned __int8 *a1, int a2, int a3, unsigned int *a4)
{
  int v4; // ebx
  unsigned __int8 *v5; // edx
  char v6; // di
  char v7; // al
  int v8; // edi
  unsigned __int8 v9; // al
  unsigned int v10; // esi
  unsigned __int8 v11; // cl
  unsigned __int8 *v12; // eax
  unsigned __int8 *v13; // ebp
  int v14; // esi
  unsigned int v15; // ecx
  int v16; // eax
  unsigned __int8 v17; // cl
  unsigned __int8 *v18; // eax
  unsigned __int8 v19; // cl
  int v20; // edx
  int v21; // ecx
  unsigned int *v22; // eax
  unsigned __int8 *v24; // eax
  unsigned __int8 v25; // dl
  unsigned __int8 *v26; // edi
  unsigned __int8 *v27; // eax
  unsigned __int8 *v28; // esi
  unsigned int v29; // ecx
  unsigned __int8 *v30; // eax
  unsigned __int8 v31; // dl
  int v32; // ebp
  unsigned __int8 v33; // al
  unsigned int v34; // eax
  unsigned __int8 v35; // cl
  int v36; // eax
  char v37; // al
  char v38; // di
  unsigned int *v39; // ecx
  unsigned int v40; // eax
  char v41; // al
  int v42; // eax
  unsigned __int8 *v43; // edi
  unsigned int v44; // ecx
  unsigned __int8 *v45; // eax
  unsigned __int8 v46; // dl
  unsigned int *v47; // ebp
  unsigned int v48; // edx
  int v49; // ebp
  int v50; // edx
  unsigned int *v51; // edi
  unsigned int v52; // edx
  int v53; // eax
  int v54; // eax
  int (__cdecl *v55)(int, int, int, int); // eax
  int v56; // eax
  unsigned __int8 *v57; // [esp+18h] [ebp-24h]
  unsigned __int8 *v58; // [esp+1Ch] [ebp-20h]

  v4 = a3;
  v5 = a1 + 1;
  v57 = a1++;
  v6 = *(_BYTE *)(a3 + 12);
  v7 = *(_BYTE *)(a3 + 13);
  *(_DWORD *)(a3 + 36) = -1;
  *(_DWORD *)(v4 + 16) = 32;
  v8 = v6 & 7;
  *(_BYTE *)(v4 + 12) = v8;
  *(_BYTE *)(v4 + 13) = v7 & 0xF2;
  v9 = v57[1];
  v10 = v9 - 48;
  if ( v10 <= 9 )
  {
    a1 = v57 + 2;
    v58 = v57 + 2;
    v11 = v57[2];
    if ( (unsigned int)v11 - 48 <= 9 )
    {
      v12 = v57 + 3;
      do
      {
        v10 = v11 + 10 * v10 - 48;
        v13 = v12;
        a1 = v12;
        v11 = *v12++;
      }
      while ( (unsigned int)v11 - 48 <= 9 );
      v58 = v13;
    }
    if ( v10 && v11 == 36 )
    {
      v39 = a4;
      *(_DWORD *)(v4 + 36) = v10 - 1;
      v40 = *v39;
      v5 = v58 + 1;
      a1 = v58 + 1;
      if ( v10 >= v40 )
        v40 = v10;
      *v39 = v40;
      v9 = v58[1];
      v8 = *(unsigned __int8 *)(v4 + 12);
    }
    else
    {
      a1 = v5;
      v9 = v57[1];
    }
  }
  while ( 2 )
  {
    switch ( v9 )
    {
      case ' ':
        v8 |= 0x10u;
        *(_BYTE *)(v4 + 12) = v8;
        goto LABEL_27;
      case '#':
        v8 |= 8u;
        *(_BYTE *)(v4 + 12) = v8;
        goto LABEL_27;
      case '\'':
        v8 |= 0xFFFFFF80;
        *(_BYTE *)(v4 + 12) = v8;
        goto LABEL_27;
      case '+':
        v8 |= 0x40u;
        *(_BYTE *)(v4 + 12) = v8;
        goto LABEL_27;
      case '-':
        v8 |= 0x20u;
        *(_BYTE *)(v4 + 12) = v8;
        goto LABEL_27;
      case '0':
        *(_DWORD *)(v4 + 16) = 48;
        goto LABEL_27;
      case 'I':
        *(_BYTE *)(v4 + 13) |= 8u;
LABEL_27:
        a1 = ++v5;
        v9 = *v5;
        if ( !*v5 )
          goto LABEL_10;
        continue;
      default:
LABEL_10:
        if ( (v8 & 0x20) != 0 )
          *(_DWORD *)(v4 + 16) = 32;
        *(_DWORD *)(v4 + 32) = -1;
        *(_DWORD *)(v4 + 4) = 0;
        if ( *v5 == 42 )
        {
          v28 = v5 + 1;
          a1 = v5 + 1;
          v29 = v5[1] - 48;
          if ( v29 > 9 )
            goto LABEL_49;
          v30 = v5 + 2;
          a1 = v5 + 2;
          v31 = v5[2];
          if ( (unsigned int)v31 - 48 <= 9 )
          {
            do
            {
              ++v30;
              v29 = v31 + 10 * v29 - 48;
              a1 = v30;
              v31 = *v30;
            }
            while ( (unsigned int)*v30 - 48 <= 9 );
          }
          if ( !v29 || v31 != 36 )
            goto LABEL_49;
          v51 = a4;
          *(_DWORD *)(v4 + 32) = v29 - 1;
          v52 = *v51;
          if ( v29 >= *v51 )
            v52 = v29;
          *v51 = v52;
          v5 = v30 + 1;
          v53 = *(_DWORD *)(v4 + 32);
          a1 = v5;
          if ( v53 >= 0 )
          {
            v14 = 0;
          }
          else
          {
LABEL_49:
            v32 = a2;
            v5 = v28;
            a1 = v28;
            v14 = 1;
            *(_DWORD *)(v4 + 32) = a2;
            a2 = v32 + 1;
          }
        }
        else
        {
          v14 = 0;
          v15 = *v5 - 48;
          if ( v15 <= 9 )
          {
            a1 = v5 + 1;
            if ( (unsigned int)v5[1] - 48 > 9 )
            {
              ++v5;
            }
            else
            {
              v24 = v5 + 2;
              v25 = v5[1];
              do
              {
                v26 = v24;
                a1 = v24;
                v15 = v25 + 10 * v15 - 48;
                v25 = *v24++;
              }
              while ( (unsigned int)v25 - 48 <= 9 );
              v5 = v26;
            }
            *(_DWORD *)(v4 + 4) = v15;
            v14 = 0;
          }
        }
        *(_DWORD *)(v4 + 28) = -1;
        *(_DWORD *)v4 = -1;
        if ( *v5 == 46 )
        {
          a1 = v5 + 1;
          v33 = v5[1];
          if ( v33 == 42 )
          {
            v43 = v5 + 2;
            a1 = v5 + 2;
            v44 = v5[2] - 48;
            if ( v44 > 9 )
              goto LABEL_85;
            v45 = v5 + 3;
            a1 = v5 + 3;
            v46 = v5[3];
            if ( (unsigned int)v46 - 48 <= 9 )
            {
              do
              {
                ++v45;
                v44 = v46 + 10 * v44 - 48;
                a1 = v45;
                v46 = *v45;
              }
              while ( (unsigned int)*v45 - 48 <= 9 );
            }
            if ( !v44 || v46 != 36 )
              goto LABEL_85;
            v47 = a4;
            *(_DWORD *)(v4 + 28) = v44 - 1;
            v48 = *v47;
            if ( v44 >= *v47 )
              v48 = v44;
            *v47 = v48;
            v49 = *(_DWORD *)(v4 + 28);
            v5 = v45 + 1;
            a1 = v45 + 1;
            if ( v49 < 0 )
            {
LABEL_85:
              v50 = a2;
              ++v14;
              a1 = v43;
              *(_DWORD *)(v4 + 28) = a2;
              a2 = v50 + 1;
              v5 = v43;
            }
          }
          else
          {
            v34 = v33 - 48;
            if ( v34 > 9 )
            {
              *(_DWORD *)v4 = 0;
              ++v5;
            }
            else
            {
              a1 = v5 + 2;
              v35 = v5[2];
              v5 += 2;
              if ( (unsigned int)v35 - 48 <= 9 )
              {
                do
                {
                  ++v5;
                  v34 = v35 + 10 * v34 - 48;
                  a1 = v5;
                  v35 = *v5;
                }
                while ( (unsigned int)*v5 - 48 <= 9 );
              }
              *(_DWORD *)v4 = v34;
            }
          }
        }
        *(_BYTE *)(v4 + 12) &= 0xF8u;
        *(_BYTE *)(v4 + 13) &= ~2u;
        v16 = _printf_modifier_table;
        *(_WORD *)(v4 + 14) = 0;
        if ( v16 && *(_DWORD *)(v16 + 4 * *v5) && (v54 = _handle_registered_modifier_mb(&a1, v4), v5 = a1, !v54) )
        {
          v19 = *a1;
          v18 = a1 + 1;
        }
        else
        {
          v17 = *v5;
          v18 = v5 + 1;
          a1 = v5 + 1;
          switch ( v17 )
          {
            case 'L':
            case 'q':
              v38 = *(_BYTE *)(v4 + 12);
              goto LABEL_64;
            case 'Z':
            case 't':
            case 'z':
              *(_BYTE *)(v4 + 12) &= 0xFAu;
              v19 = v5[1];
              v18 = v5 + 2;
              break;
            case 'h':
              if ( v5[1] == 104 )
              {
                a1 = v5 + 2;
                v18 = v5 + 3;
                *(_BYTE *)(v4 + 13) |= 2u;
                v19 = v5[2];
              }
              else
              {
                *(_BYTE *)(v4 + 12) |= 2u;
                v19 = v5[1];
                v18 = v5 + 2;
              }
              break;
            case 'j':
              *(_BYTE *)(v4 + 12) |= 5u;
              v19 = v5[1];
              v18 = v5 + 2;
              break;
            case 'l':
              v37 = *(_BYTE *)(v4 + 12) | 4;
              *(_BYTE *)(v4 + 12) = v37;
              v19 = v5[1];
              v38 = v37;
              v18 = v5 + 2;
              if ( v19 == 108 )
              {
                a1 = v5 + 2;
LABEL_64:
                *(_BYTE *)(v4 + 12) = v38 | 1;
                v19 = *v18++;
              }
              break;
            default:
              a1 = v5;
              v19 = *v5;
              break;
          }
        }
        v20 = v19;
        v21 = _printf_function_table;
        *(_DWORD *)(v4 + 8) = v20;
        a1 = v18;
        *(_DWORD *)(v4 + 48) = -1;
        if ( !v21 )
          goto LABEL_19;
        v55 = *(int (__cdecl **)(int, int, int, int))(_printf_arginfo_table + 4 * v20);
        if ( !v55 )
          goto LABEL_19;
        v56 = v55(v4, 1, v4 + 40, v4 + 48);
        *(_DWORD *)(v4 + 44) = v56;
        if ( v56 < 0 )
        {
          v20 = *(_DWORD *)(v4 + 8);
LABEL_19:
          *(_DWORD *)(v4 + 44) = 1;
          switch ( v20 )
          {
            case 'A':
            case 'E':
            case 'F':
            case 'G':
            case 'a':
            case 'e':
            case 'f':
            case 'g':
              v42 = -((*(_BYTE *)(v4 + 12) & 1) == 0);
              LOBYTE(v42) = 0;
              *(_DWORD *)(v4 + 40) = v42 + 263;
              break;
            case 'C':
              *(_DWORD *)(v4 + 40) = 2;
              break;
            case 'S':
              *(_DWORD *)(v4 + 40) = 4;
              break;
            case 'X':
            case 'd':
            case 'i':
            case 'o':
            case 'u':
            case 'x':
              v41 = *(_BYTE *)(v4 + 12);
              if ( (v41 & 1) != 0 )
              {
                *(_DWORD *)(v4 + 40) = 256;
              }
              else if ( (v41 & 4) != 0 )
              {
                *(_DWORD *)(v4 + 40) = 512;
              }
              else if ( (v41 & 2) != 0 )
              {
                *(_DWORD *)(v4 + 40) = 1024;
              }
              else
              {
                *(_DWORD *)(v4 + 40) = (*(_BYTE *)(v4 + 13) & 2) != 0;
              }
              break;
            case 'c':
              *(_DWORD *)(v4 + 40) = 1;
              break;
            case 'n':
              *(_DWORD *)(v4 + 40) = 2048;
              break;
            case 'p':
              *(_DWORD *)(v4 + 40) = 5;
              break;
            case 's':
              *(_DWORD *)(v4 + 40) = 3;
              break;
            default:
              *(_DWORD *)(v4 + 44) = 0;
              break;
          }
        }
        if ( *(_DWORD *)(v4 + 36) == -1 )
        {
          v36 = *(_DWORD *)(v4 + 44);
          if ( v36 )
          {
            v14 += v36;
            *(_DWORD *)(v4 + 36) = a2;
          }
        }
        v22 = (unsigned int *)a1;
        if ( *(_DWORD *)(v4 + 8) )
        {
          *(_DWORD *)(v4 + 20) = a1;
          *(_DWORD *)(v4 + 24) = strchrnul(v22, 37);
        }
        else
        {
          v27 = a1 - 1;
          *(_DWORD *)(v4 + 24) = a1 - 1;
          *(_DWORD *)(v4 + 20) = v27;
        }
        return v14;
    }
  }
}
// 80F129C: using guessed type int _printf_function_table;
// 80F12A0: using guessed type int _printf_modifier_table;
// 80F137C: using guessed type int _printf_arginfo_table;

//----- (080665E0) --------------------------------------------------------
void __usercall _fxprintf(long double a1@<st0>, _DWORD *a2, char *a3, ...)
{
  _DWORD *v3; // esi
  int v4; // eax
  void *v5; // esp
  char v6; // cl
  int v7; // edx
  int v8; // [esp+0h] [ebp-38h] BYREF
  wchar_t v9[10]; // [esp+10h] [ebp-28h] BYREF
  int savedregs; // [esp+38h] [ebp+0h] BYREF
  va_list va; // [esp+48h] [ebp+10h] BYREF

  va_start(va, a3);
  v3 = a2;
  if ( !a2 )
    v3 = (_DWORD *)stderr;
  if ( (int)v3[26] <= 0 )
  {
    vfprintf(v3, a3, (int *)va);
  }
  else
  {
    v9[3] = (wchar_t)&v8;
    v4 = strlen(a3);
    v5 = alloca(4 * (v4 + 1) + 15);
    if ( v4 != -1 )
    {
      v6 = *a3;
      if ( *a3 < 0 )
LABEL_11:
        _assert_fail((int)&savedregs, a1, (int)"(((fmt[i]) & ~0x7f) == 0)", (int)"fxprintf.c", 47, "__fxprintf");
      v7 = 0;
      while ( 1 )
      {
        v9[v7] = v6;
        if ( v7 == v4 )
          break;
        v6 = a3[++v7];
        if ( v6 < 0 )
          goto LABEL_11;
      }
    }
    vfwprintf((int)v9, a1, v3, v9, (int *)va);
  }
}
// 805D080: using guessed type _DWORD __cdecl vfprintf(_DWORD, _DWORD, _DWORD);

//----- (080666B0) --------------------------------------------------------
void __cdecl fclose(int *a1)
{
  int v1; // ecx
  int v2; // edx
  int v3; // eax
  unsigned int v5; // esi
  bool v7; // zf
  _DWORD *v8; // edx
  int v9; // edi
  bool v11; // zf

  v1 = *a1;
  v2 = *a1;
  if ( (*a1 & 0x2000) != 0 )
  {
    IO_un_link(a1);
    v1 = *a1;
    v2 = *a1;
  }
  v3 = v1 & 0x8000;
  if ( (v1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v5 = __readgsdword(8u);
    if ( v5 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v7 = __readgsdword(0xCu) == 0;
      if ( !v7 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v7 )
      {
        L_lock_38(v3, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = a1[18];
      v1 = *a1;
      *(_DWORD *)(_EDX + 8) = v5;
    }
    ++*(_DWORD *)(_EDX + 4);
    BYTE1(v2) = BYTE1(v1);
  }
  BYTE1(v1) &= 0x20u;
  if ( BYTE1(v1) )
  {
    IO_new_file_close_it((int)a1);
    v2 = *a1;
  }
  if ( (v2 & 0x8000) != 0 )
    goto LABEL_14;
  v8 = (_DWORD *)a1[18];
  v7 = v8[1]-- == 1;
  if ( !v7 )
    goto LABEL_14;
  v8[2] = 0;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v7 = (*v8)-- == 1;
  if ( v7 )
  {
LABEL_14:
    (*(void (__cdecl **)(int *, _DWORD))(a1[37] + 8))(a1, 0);
    if ( a1[26] <= 0 )
    {
      if ( a1[9] )
        IO_free_backup_area(a1);
    }
    else
    {
      v9 = a1[21];
      _ECX = 1;
      v11 = __readgsdword(0xCu) == 0;
      if ( !v11 )
        __asm { lock }
      __asm { cmpxchg ds:__gconv_lock, ecx }
      if ( !v11 )
      {
        L_lock_101(0);
        return;
      }
      _gconv_release_step(*(int **)(v9 + 36));
      _gconv_release_step(*(int **)(v9 + 80));
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --_gconv_lock )
      {
        L_unlock_110();
        return;
      }
    }
    if ( a1 != stdin && a1 != stdout && a1 != (int *)stderr )
    {
      *a1 = 0;
      free(a1);
    }
  }
  else
  {
    L_unlock_191(v1, v8);
  }
}
// 8066825: variable 'v1' is possibly undefined
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80EFA20: using guessed type void *stdout;
// 80EFA24: using guessed type void *stdin;
// 80F1314: using guessed type int _gconv_lock;

//----- (08066864) --------------------------------------------------------
void __usercall L_lock_38(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x80666F8);
}
// 806686B: control flows out of bounds to 80666F8

//----- (08066870) --------------------------------------------------------
void __usercall L_lock_101(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &_gconv_lock);
  JUMPOUT(0x806676D);
}
// 806687B: control flows out of bounds to 806676D
// 80F1314: using guessed type int _gconv_lock;

//----- (08066880) --------------------------------------------------------
void L_unlock_110()
{
  _lll_unlock_wake_private(&_gconv_lock);
  JUMPOUT(0x8066795);
}
// 806688B: control flows out of bounds to 8066795
// 80F1314: using guessed type int _gconv_lock;

//----- (08066890) --------------------------------------------------------
void __fastcall L_unlock_191(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x8066827);
}
// 8066897: control flows out of bounds to 8066827

//----- (08066899) --------------------------------------------------------
#error "806685F: call analysis failed (funcsize=5)"

//----- (080668B0) --------------------------------------------------------
void __cdecl fflush(_DWORD *a1)
{
  unsigned int v2; // esi
  bool v4; // zf
  _DWORD *v5; // ecx

  if ( !a1 )
  {
    IO_flush_all();
    return;
  }
  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v2 = __readgsdword(8u);
    if ( v2 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v4 = __readgsdword(0xCu) == 0;
      if ( !v4 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v4 )
      {
        L_lock_33_1(0, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v2;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  (*(int (__cdecl **)(_DWORD *))(a1[37] + 48))(a1);
  if ( (BYTE1(*a1) & 0x80u) == 0 )
  {
    v5 = (_DWORD *)a1[18];
    v4 = v5[1]-- == 1;
    if ( v4 )
    {
      v5[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v4 = (*v5)-- == 1;
      if ( !v4 )
        L_unlock_80(v5);
    }
  }
}

//----- (0806698A) --------------------------------------------------------
void __usercall L_lock_33_1(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x80668F2);
}
// 8066991: control flows out of bounds to 80668F2

//----- (08066996) --------------------------------------------------------
void __fastcall L_unlock_80(_DWORD *a1)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x806693D);
}
// 806699D: control flows out of bounds to 806693D

//----- (0806699F) --------------------------------------------------------
#error "8066985: call analysis failed (funcsize=5)"

//----- (080669B0) --------------------------------------------------------
int __cdecl _fopen_maybe_mmap(int a1)
{
  int result; // eax
  void *v2; // edx

  result = a1;
  if ( (*(_BYTE *)(a1 + 60) & 1) != 0 && (*(_BYTE *)a1 & 8) != 0 )
  {
    v2 = &IO_file_jumps_maybe_mmap;
    if ( *(int *)(a1 + 104) > 0 )
      v2 = &IO_wfile_jumps_maybe_mmap;
    *(_DWORD *)(a1 + 148) = v2;
    *(_DWORD *)(*(_DWORD *)(a1 + 88) + 184) = &IO_wfile_jumps_maybe_mmap;
  }
  return result;
}

//----- (080669F0) --------------------------------------------------------
int *__cdecl _fopen_internal(int a1, _BYTE *a2, int a3)
{
  int *v3; // ebx
  int *v4; // eax
  void *v5; // eax
  int *v7; // [esp+0h] [ebp-2Ch]

  v3 = 0;
  v4 = (int *)malloc(352);
  if ( v4 )
  {
    v3 = v4;
    v4[18] = (int)(v4 + 38);
    IO_no_init(v4, 0, 0, v4 + 41, IO_wfile_jumps);
    v3[37] = (int)&IO_file_jumps;
    IO_new_file_init(v3);
    if ( IO_new_file_fopen(v3, a1, a2, a3) )
    {
      if ( (v3[15] & 1) != 0 && (*(_BYTE *)v3 & 8) != 0 )
      {
        v5 = &IO_file_jumps_maybe_mmap;
        if ( v3[26] > 0 )
          v5 = &IO_wfile_jumps_maybe_mmap;
        v3[37] = (int)v5;
        *(_DWORD *)(v3[22] + 184) = &IO_wfile_jumps_maybe_mmap;
      }
    }
    else
    {
      IO_un_link(v3);
      v7 = v3;
      v3 = 0;
      free(v7);
    }
  }
  return v3;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80CA1E0: using guessed type _DWORD IO_wfile_jumps[21];

//----- (08066AC0) --------------------------------------------------------
int *__cdecl fopen(int a1, _BYTE *a2)
{
  return _fopen_internal(a1, a2, 1);
}

//----- (08066AF0) --------------------------------------------------------
void __cdecl fputs(_BYTE *a1, _DWORD *a2)
{
  int v2; // esi
  unsigned int v4; // ebp
  bool v6; // zf
  int v7; // eax
  _DWORD *v8; // ecx

  v2 = strlen(a1);
  if ( (*a2 & 0x8000) == 0 )
  {
    _EDX = a2[18];
    v4 = __readgsdword(8u);
    if ( v4 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v6 = __readgsdword(0xCu) == 0;
      if ( !v6 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v6 )
      {
        L_lock_41(0, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = a2[18];
      *(_DWORD *)(_EDX + 8) = v4;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v7 = a2[26];
  if ( v7 )
  {
    if ( v7 != -1 )
      goto LABEL_11;
  }
  else
  {
    a2[26] = -1;
  }
  (*(int (__cdecl **)(_DWORD *, _BYTE *, int))(a2[37] + 28))(a2, a1, v2);
LABEL_11:
  if ( (BYTE1(*a2) & 0x80u) == 0 )
  {
    v8 = (_DWORD *)a2[18];
    v6 = v8[1]-- == 1;
    if ( v6 )
    {
      v8[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*v8)-- == 1;
      if ( !v6 )
        L_unlock_100(v8);
    }
  }
}

//----- (08066C0C) --------------------------------------------------------
void __usercall L_lock_41(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x8066B46);
}
// 8066C13: control flows out of bounds to 8066B46

//----- (08066C18) --------------------------------------------------------
void __fastcall L_unlock_100(_DWORD *a1)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x8066BAB);
}
// 8066C1F: control flows out of bounds to 8066BAB

//----- (08066C21) --------------------------------------------------------
#error "8066C07: call analysis failed (funcsize=5)"

//----- (08066C30) --------------------------------------------------------
void __cdecl ftell(int *a1)
{
  unsigned int v2; // edi
  bool v4; // zf
  int v5; // edi
  int v6; // edx
  __int64 v7; // rcx
  _DWORD *v8; // edx

  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v2 = __readgsdword(8u);
    if ( v2 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v4 = __readgsdword(0xCu) == 0;
      if ( !v4 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v4 )
      {
        L_lock_30(0, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v2;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  LODWORD(v7) = IO_seekoff_unlocked(a1, 0LL, 1u, 0);
  v5 = *a1;
  HIDWORD(v7) = v6;
  if ( (v6 & (unsigned int)v7) != -1 && (v5 & 0x100) != 0 && a1[26] <= 0 )
    v7 -= a1[11] - a1[9];
  if ( (v5 & 0x8000) != 0 )
    goto LABEL_12;
  v8 = (_DWORD *)a1[18];
  v4 = v8[1]-- == 1;
  if ( !v4 )
    goto LABEL_12;
  v8[2] = 0;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v4 = (*v8)-- == 1;
  if ( v4 )
  {
LABEL_12:
    if ( (HIDWORD(v7) & (unsigned int)v7) == -1 )
    {
      if ( !__readgsdword(0xFFFFFFE8) )
        __writegsdword(0xFFFFFFE8, 5u);
    }
    else if ( (int)v7 >> 31 != HIDWORD(v7) )
    {
      __writegsdword(0xFFFFFFE8, 0x4Bu);
    }
  }
  else
  {
    L_unlock_168(v7, v8);
  }
}
// 8066CAF: variable 'v6' is possibly undefined

//----- (08066DAE) --------------------------------------------------------
void __usercall L_lock_30(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x8066C74);
}
// 8066DB5: control flows out of bounds to 8066C74

//----- (08066DBA) --------------------------------------------------------
void __fastcall L_unlock_168(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x8066D57);
}
// 8066DC1: control flows out of bounds to 8066D57

//----- (08066DC3) --------------------------------------------------------
#error "8066DA9: call analysis failed (funcsize=5)"

//----- (08066DD0) --------------------------------------------------------
void __cdecl fwrite(int a1, int a2, int a3, _DWORD *a4)
{
  unsigned int v5; // ebp
  bool v7; // zf
  int v8; // eax
  _DWORD *v9; // ebx

  if ( !(a3 * a2) )
    return;
  if ( (*a4 & 0x8000) == 0 )
  {
    _EDX = a4[18];
    v5 = __readgsdword(8u);
    if ( v5 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v7 = __readgsdword(0xCu) == 0;
      if ( !v7 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v7 )
      {
        L_lock_43(0, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = a4[18];
      *(_DWORD *)(_EDX + 8) = v5;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v8 = a4[26];
  if ( !v8 )
  {
    a4[26] = -1;
    goto LABEL_15;
  }
  if ( v8 == -1 )
LABEL_15:
    (*(int (__cdecl **)(_DWORD *, int, int))(a4[37] + 28))(a4, a1, a3 * a2);
  if ( (BYTE1(*a4) & 0x80u) == 0 )
  {
    v9 = (_DWORD *)a4[18];
    v7 = v9[1]-- == 1;
    if ( v7 )
    {
      v9[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v7 = (*v9)-- == 1;
      if ( !v7 )
        L_unlock_192(v9);
    }
  }
}

//----- (08066F11) --------------------------------------------------------
void __usercall L_lock_43(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x8066E2B);
}
// 8066F18: control flows out of bounds to 8066E2B

//----- (08066F1D) --------------------------------------------------------
void __usercall L_unlock_192(_DWORD *a1@<ebx>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x8066ED7);
}
// 8066F24: control flows out of bounds to 8066ED7

//----- (08066F26) --------------------------------------------------------
#error "8066F0C: call analysis failed (funcsize=5)"

//----- (08066F30) --------------------------------------------------------
int __cdecl IO_padn(int a1, int a2, int a3)
{
  const char *v3; // ebp
  int v4; // ebx
  int i; // eax
  int v6; // esi
  int v7; // eax
  char v9[44]; // [esp+10h] [ebp-2Ch] BYREF

  v3 = (const char *)&blanks;
  v4 = a3;
  if ( a2 != 32 )
  {
    v3 = "0000000000000000";
    if ( a2 != 48 )
    {
      for ( i = 15; i != -1; --i )
        v9[i] = a2;
      v3 = v9;
    }
  }
  v6 = 0;
  if ( a3 > 15 )
  {
    do
    {
      v7 = (*(int (__cdecl **)(int, const char *, int))(*(_DWORD *)(a1 + 148) + 28))(a1, v3, 16);
      v6 += v7;
      if ( v7 != 16 )
        return v6;
      v4 -= 16;
    }
    while ( v4 > 15 );
  }
  if ( v4 <= 0 )
    return v6;
  return (*(int (__cdecl **)(int, const char *, int))(*(_DWORD *)(a1 + 148) + 28))(a1, v3, v4) + v6;
}
// 8066F30: using guessed type char var_2C[44];

//----- (08066FE0) --------------------------------------------------------
int __cdecl IO_seekoff_unlocked(int *a1, __int64 a2, unsigned int a3, int a4)
{
  int v4; // ecx
  int v5; // eax
  int v7; // edx
  __int64 v8; // [esp+18h] [ebp-14h]

  v8 = a2;
  if ( a3 <= 2 )
  {
    if ( !a4 )
      return (*(int (__cdecl **)(int *, _DWORD, _DWORD, unsigned int, int))(a1[37] + 36))(a1, v8, HIDWORD(v8), a3, a4);
    v5 = a1[26];
    if ( v5 < 0 )
    {
      v4 = a1[9];
      if ( !v4 )
        return (*(int (__cdecl **)(int *, _DWORD, _DWORD, unsigned int, int))(a1[37] + 36))(a1, v8, HIDWORD(v8), a3, a4);
      if ( a3 != 1 )
        goto LABEL_7;
    }
    else
    {
      if ( !v5 || !*(_DWORD *)(a1[22] + 32) )
        return (*(int (__cdecl **)(int *, _DWORD, _DWORD, unsigned int, int))(a1[37] + 36))(a1, v8, HIDWORD(v8), a3, a4);
      if ( a3 != 1 )
        goto LABEL_7;
    }
    v7 = *a1;
    if ( (*a1 & 0x100) != 0 )
    {
      if ( v5 > 0 )
      {
        BYTE1(v7) = BYTE1(*a1) & 1;
        abort(v4, v7);
      }
      v8 = a2 - (a1[2] - a1[1]);
      goto LABEL_15;
    }
LABEL_7:
    if ( v5 > 0 )
    {
      IO_free_wbackup_area(a1);
      return (*(int (__cdecl **)(int *, _DWORD, _DWORD, unsigned int, int))(a1[37] + 36))(a1, v8, HIDWORD(v8), a3, a4);
    }
LABEL_15:
    IO_free_backup_area(a1);
    return (*(int (__cdecl **)(int *, _DWORD, _DWORD, unsigned int, int))(a1[37] + 36))(a1, v8, HIDWORD(v8), a3, a4);
  }
  __writegsdword(0xFFFFFFE8, 0x16u);
  return -1;
}
// 80670D6: variable 'v4' is possibly undefined
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);

//----- (080670E0) --------------------------------------------------------
void __cdecl IO_seekoff(int *a1, __int64 a2, unsigned int a3, int a4)
{
  unsigned int v5; // ebp
  bool v7; // zf
  _DWORD *v8; // ebx

  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v5 = __readgsdword(8u);
    if ( v5 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v7 = __readgsdword(0xCu) == 0;
      if ( !v7 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v7 )
      {
        L_lock_189(0, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v5;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  IO_seekoff_unlocked(a1, a2, a3, a4);
  if ( (BYTE1(*a1) & 0x80u) == 0 )
  {
    v8 = (_DWORD *)a1[18];
    v7 = v8[1]-- == 1;
    if ( v7 )
    {
      v8[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v7 = (*v8)-- == 1;
      if ( !v7 )
        L_unlock_238(v8);
    }
  }
}

//----- (080671DC) --------------------------------------------------------
void __usercall L_lock_189(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x8067130);
}
// 80671E3: control flows out of bounds to 8067130

//----- (080671E8) --------------------------------------------------------
void __usercall L_unlock_238(_DWORD *a1@<ebx>)
{
  _lll_unlock_wake_private(a1);
  JUMPOUT(0x806718C);
}
// 80671EF: control flows out of bounds to 806718C

//----- (080671F1) --------------------------------------------------------
#error "80671D7: call analysis failed (funcsize=5)"

//----- (08067200) --------------------------------------------------------
void __usercall vsscanf(long double a1@<st0>, unsigned int a2, unsigned __int8 *a3, int *a4)
{
  _DWORD v4[43]; // [esp+20h] [ebp-ACh] BYREF

  v4[18] = 0;
  IO_no_init(v4, 0x8000, -1, 0, 0);
  v4[37] = &IO_str_jumps;
  IO_str_init_static_internal(v4, a2, 0, 0);
  IO_vfscanf_internal(a1, (char *)v4, a3, a4, 0);
}

//----- (080672A0) --------------------------------------------------------
int __cdecl IO_mem_sync(int a1)
{
  _BYTE *v1; // eax

  v1 = *(_BYTE **)(a1 + 20);
  if ( v1 == *(_BYTE **)(a1 + 24) )
  {
    IO_str_overflow(a1, 0);
    --*(_DWORD *)(a1 + 20);
  }
  else
  {
    *v1 = 0;
  }
  **(_DWORD **)(a1 + 160) = *(_DWORD *)(a1 + 16);
  **(_DWORD **)(a1 + 164) = *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16);
  return 0;
}

//----- (080672F0) --------------------------------------------------------
void __usercall IO_mem_finish(long double a1@<st0>, int a2)
{
  _DWORD *v2; // esi
  int v3; // eax
  int v4; // edx

  v2 = *(_DWORD **)(a2 + 160);
  realloc(*(_BYTE **)(a2 + 16), *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 16) + 1);
  *v2 = v3;
  v4 = **(_DWORD **)(a2 + 160);
  if ( v4 )
  {
    *(_BYTE *)(v4 + *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 16)) = 0;
    **(_DWORD **)(a2 + 164) = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 28) = 0;
  }
  IO_str_finish(a1, (int *)a2);
}
// 8067316: variable 'v3' is possibly undefined

//----- (08067360) --------------------------------------------------------
_DWORD *__cdecl open_memstream(int a1, int a2)
{
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  _DWORD *v4; // ebx
  unsigned int v5; // eax
  unsigned int v6; // edi

  v2 = 0;
  v3 = (_DWORD *)malloc(368);
  v4 = v3;
  if ( v3 )
  {
    v3[18] = v3 + 42;
    calloc(1, 0x2000u);
    v6 = v5;
    if ( v5 )
    {
      v2 = v4;
      IO_init(v4, 0);
      v4[37] = &IO_mem_jumps;
      IO_str_init_static_internal(v4, v6, 0x2000, v6);
      *v4 &= ~1u;
      v4[38] = malloc;
      v4[40] = a1;
      v4[39] = free;
      v4[41] = a2;
    }
  }
  return v2;
}
// 80673A6: variable 'v5' is possibly undefined
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08067420) --------------------------------------------------------
int __usercall vasprintf@<eax>(long double a1@<st0>, _DWORD *a2, int a3, int a4)
{
  unsigned int v4; // eax
  unsigned int v5; // ebx
  int v6; // edi
  unsigned int v7; // ebx
  unsigned int v8; // esi
  _BYTE *v9; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // [esp+2Ch] [ebp-C0h]
  int v13[4]; // [esp+30h] [ebp-BCh] BYREF
  int v14; // [esp+40h] [ebp-ACh]
  int v15; // [esp+44h] [ebp-A8h]
  int v16; // [esp+48h] [ebp-A4h]
  _BYTE *v17; // [esp+4Ch] [ebp-A0h]
  int v18; // [esp+78h] [ebp-74h]
  void *v19; // [esp+C4h] [ebp-28h]
  void (__usercall *v20)(long double@<st0>, size_t); // [esp+C8h] [ebp-24h]
  _DWORD (__cdecl *v21)(_DWORD); // [esp+CCh] [ebp-20h]

  malloc(a1, 0x64u);
  v5 = v4;
  if ( !v4 )
    return -1;
  v18 = 0;
  IO_no_init(v13, 0x8000, -1, 0, 0);
  v19 = &IO_str_jumps;
  IO_str_init_static_internal(v13, v5, 100, v5);
  v13[0] &= ~1u;
  v20 = malloc;
  v21 = free;
  v6 = vfprintf(v13, a3, a4);
  if ( v6 < 0 )
  {
    free(v17);
    return v6;
  }
  v7 = v15 - v14;
  v8 = v15 - v14 + 1;
  if ( v8 < (unsigned int)(v16 - v14) >> 1 && (malloc(a1, v15 - v14 + 1), (*a2 = v11) != 0) )
  {
    v12 = v17;
    memcpy(v11, v17, v7);
    free(v12);
    v9 = (_BYTE *)*a2;
    if ( !*a2 )
      goto LABEL_9;
  }
  else
  {
    realloc(v17, v8);
    *a2 = v9;
    if ( !v9 )
    {
LABEL_9:
      v9 = v17;
      *a2 = v17;
    }
  }
  v9[v8 - 1] = 0;
  return v6;
}
// 8067457: variable 'v4' is possibly undefined
// 8067524: variable 'v9' is possibly undefined
// 8067562: variable 'v11' is possibly undefined
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 805D080: using guessed type _DWORD __cdecl vfprintf(_DWORD, _DWORD, _DWORD);

//----- (080675C0) --------------------------------------------------------
int __cdecl vdprintf(unsigned int a1, int a2, int a3)
{
  int v3; // esi
  bool v4; // al
  int v6[47]; // [esp+2Ch] [ebp-160h] BYREF
  int v7[4]; // [esp+E8h] [ebp-A4h] BYREF
  unsigned int v8; // [esp+F8h] [ebp-94h]
  int v9; // [esp+FCh] [ebp-90h]
  int v10; // [esp+130h] [ebp-5Ch]
  int v11; // [esp+140h] [ebp-4Ch]
  int v12; // [esp+150h] [ebp-3Ch]
  void (__cdecl **v13)(int *, _DWORD); // [esp+17Ch] [ebp-10h]

  v10 = 0;
  IO_no_init(v7, 0x8000, 0, v6, IO_wfile_jumps);
  v13 = (void (__cdecl **)(int *, _DWORD))&IO_file_jumps;
  IO_new_file_init(v7);
  if ( IO_new_file_attach((unsigned int *)v7, a1) )
  {
    v7[0] = v7[0] & 0xFFFFEFB3 | 0x44;
    v3 = vfprintf(v7, a2, a3);
    if ( v3 != -1 )
    {
      if ( v12 <= 0 )
        v4 = IO_new_do_write((int)v7, v8, v9 - v8) == -1;
      else
        v4 = IO_wdo_write(v7, *(_DWORD *)(v11 + 12), (*(_DWORD *)(v11 + 16) - *(_DWORD *)(v11 + 12)) >> 2) == -1;
      if ( v4 )
        v3 = -1;
    }
    v13[2](v7, 0);
  }
  else
  {
    v3 = -1;
    IO_un_link(v7);
  }
  return v3;
}
// 805D080: using guessed type _DWORD __cdecl vfprintf(_DWORD, _DWORD, _DWORD);
// 80CA1E0: using guessed type _DWORD IO_wfile_jumps[21];
// 80675C0: using guessed type int var_160[47];

//----- (08067710) --------------------------------------------------------
int __cdecl fgets_unlocked(int a1, int a2, int *a3)
{
  int v3; // esi
  char v4; // di
  int v5; // edi
  _BYTE *v6; // eax
  int v7; // ecx
  int v8; // edx

  v3 = a1;
  if ( a2 <= 0 )
    return 0;
  if ( a2 == 1 )
  {
    *(_BYTE *)a1 = 0;
  }
  else
  {
    v4 = *a3;
    *a3 &= ~0x20u;
    v5 = v4 & 0x20;
    v6 = IO_getline(a3, a1, a2 - 1, 10, 1);
    v7 = 0;
    v8 = *a3;
    if ( v6 )
    {
      if ( (v8 & 0x20) == 0 || (v7 = 0, __readgsdword(0xFFFFFFE8) == 11) )
      {
        v6[a1] = 0;
        v7 = a1;
        v8 = *a3;
      }
    }
    v3 = v7;
    *a3 = v8 | v5;
  }
  return v3;
}

//----- (080677D0) --------------------------------------------------------
int __cdecl fputs_unlocked(_BYTE *a1, int a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // edi
  int result; // eax

  v2 = strlen(a1);
  v3 = *(_DWORD *)(a2 + 104);
  v4 = v2;
  if ( !v3 )
  {
    *(_DWORD *)(a2 + 104) = -1;
    return 2 * ((*(int (__cdecl **)(int, _BYTE *, int))(*(_DWORD *)(a2 + 148) + 28))(a2, a1, v4) == v4) - 1;
  }
  result = -1;
  if ( v3 == -1 )
    return 2 * ((*(int (__cdecl **)(int, _BYTE *, int))(*(_DWORD *)(a2 + 148) + 28))(a2, a1, v4) == v4) - 1;
  return result;
}

//----- (08067850) --------------------------------------------------------
int __cdecl IO_wpadn(int a1, int a2, int a3)
{
  char *v3; // ebp
  int v4; // ebx
  char *v5; // eax
  int v6; // esi
  int v7; // eax
  char v9; // [esp+Ch] [ebp-60h] BYREF
  char v10; // [esp+10h] [ebp-5Ch] BYREF
  char v11; // [esp+4Ch] [ebp-20h] BYREF

  v3 = (char *)&blanks_0;
  v4 = a3;
  if ( a2 != 32 )
  {
    v3 = (char *)&zeroes_0;
    if ( a2 != 48 )
    {
      v5 = &v11;
      do
      {
        *(_DWORD *)v5 = a2;
        v5 -= 4;
      }
      while ( v5 != &v9 );
      v3 = &v10;
    }
  }
  v6 = 0;
  if ( a3 > 15 )
  {
    do
    {
      v7 = (*(int (__cdecl **)(int, char *, int))(*(_DWORD *)(a1 + 148) + 28))(a1, v3, 16);
      v6 += v7;
      if ( v7 != 16 )
        return v6;
      v4 -= 16;
    }
    while ( v4 > 15 );
  }
  if ( v4 <= 0 )
    return v6;
  return (*(int (__cdecl **)(int, char *, int))(*(_DWORD *)(a1 + 148) + 28))(a1, v3, v4) + v6;
}

//----- (08067900) --------------------------------------------------------
int __usercall save_for_wbackup@<eax>(int a1@<eax>, int a2@<edx>, long double a3@<st0>)
{
  _DWORD *v4; // ebp
  int v5; // eax
  _DWORD *v6; // edx
  int v7; // eax
  int v8; // edi
  int v9; // esi
  _DWORD *v10; // eax
  int v11; // ecx
  int v12; // ecx
  unsigned int v13; // eax
  int result; // eax
  size_t v15; // ebp
  int v16; // eax
  int v17; // edi
  size_t v18; // ebp
  _DWORD *v19; // eax
  int v20; // edi
  _WORD *v21; // eax
  int v22; // [esp+14h] [ebp-38h]
  int v23; // [esp+1Ch] [ebp-30h]
  int v24; // [esp+1Ch] [ebp-30h]
  unsigned int v25; // [esp+20h] [ebp-2Ch]
  unsigned int v26; // [esp+20h] [ebp-2Ch]
  _BYTE *v28; // [esp+28h] [ebp-24h]
  int v29; // [esp+2Ch] [ebp-20h]

  v4 = *(_DWORD **)(a1 + 88);
  v5 = a2 - v4[2];
  v28 = (_BYTE *)v4[2];
  v6 = *(_DWORD **)(a1 + 48);
  v7 = v5 >> 2;
  v23 = v7;
  v8 = v7;
  if ( v6 )
  {
    v9 = v7;
    v10 = *(_DWORD **)(a1 + 48);
    do
    {
      v11 = v10[2];
      v10 = (_DWORD *)*v10;
      if ( v9 > v11 )
        v9 = v11;
    }
    while ( v10 );
    v29 = v4[10];
    v12 = v23 - v9;
    v22 = v4[8];
    v25 = (v29 - v22) >> 2;
    if ( v23 - v9 > v25 )
    {
      v15 = 4 * v12 + 400;
      malloc(a3, v15);
      v17 = v16;
      if ( !v16 )
        return -1;
      if ( v9 < 0 )
      {
        v21 = wmempcpy((_BYTE *)(v16 + 400), (_BYTE *)(v29 + 4 * v9), -v9);
        wmempcpy(v21, v28, v23);
      }
      else
      {
        wmemcpy((_BYTE *)(v16 + 400), &v28[4 * v9], v23 - v9);
      }
      v18 = v17 + v15;
      free(a3, *(_DWORD *)(*(_DWORD *)(a1 + 88) + 32));
      v19 = *(_DWORD **)(a1 + 88);
      v22 = v17;
      v6 = *(_DWORD **)(a1 + 48);
      v24 = 400;
      v19[8] = v17;
      v20 = a2 - v19[2];
      v19[10] = v18;
      v4 = v19;
      v8 = v20 >> 2;
      goto LABEL_10;
    }
  }
  else
  {
    v9 = v7;
    v12 = 0;
    v29 = v4[10];
    v22 = v4[8];
    v25 = (v29 - v22) >> 2;
  }
  v13 = v25 - v12;
  v26 = v25 - v12;
  if ( v9 < 0 )
  {
    v24 = 4 * v13;
    wmemmove((void *)(4 * v13 + v22), (const void *)(v29 + 4 * v9), -v9);
    wmemcpy(
      (_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 88) + 32) + 4 * (v26 - v9)),
      *(_BYTE **)(*(_DWORD *)(a1 + 88) + 8),
      (a2 - *(_DWORD *)(*(_DWORD *)(a1 + 88) + 8)) >> 2);
  }
  else
  {
    if ( !v12 )
    {
      v24 = 4 * v26;
      goto LABEL_10;
    }
    v24 = 4 * v26;
    wmemcpy((_BYTE *)(4 * v26 + v22), &v28[4 * v9], v12);
  }
  v4 = *(_DWORD **)(a1 + 88);
  v22 = v4[8];
  v8 = (a2 - v4[2]) >> 2;
  v6 = *(_DWORD **)(a1 + 48);
LABEL_10:
  v4[9] = v24 + v22;
  result = 0;
  if ( v6 )
  {
    do
    {
      v6[2] -= v8;
      v6 = (_DWORD *)*v6;
    }
    while ( v6 );
    return 0;
  }
  return result;
}
// 80679D9: variable 'v16' is possibly undefined

//----- (08067B50) --------------------------------------------------------
int __cdecl IO_least_wmarker(int a1, int a2)
{
  _DWORD *v2; // edx
  int result; // eax
  int v4; // ecx

  v2 = *(_DWORD **)(a1 + 48);
  result = (a2 - *(_DWORD *)(*(_DWORD *)(a1 + 88) + 8)) >> 2;
  while ( v2 )
  {
    v4 = v2[2];
    v2 = (_DWORD *)*v2;
    if ( result > v4 )
      result = v4;
  }
  return result;
}

//----- (08067B80) --------------------------------------------------------
_DWORD *__cdecl IO_switch_to_main_wget_area(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // ecx

  *a1 &= ~0x100u;
  result = (_DWORD *)a1[22];
  v2 = result[10];
  result[10] = result[1];
  v3 = result[8];
  result[1] = v2;
  v4 = result[2];
  *result = v3;
  result[2] = v3;
  result[8] = v4;
  return result;
}

//----- (08067BB0) --------------------------------------------------------
_DWORD *__cdecl IO_switch_to_wbackup_area(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // edx
  int v3; // ebx
  int v4; // ecx

  *a1 |= 0x100u;
  result = (_DWORD *)a1[22];
  v2 = result[10];
  v3 = result[8];
  result[10] = result[1];
  v4 = result[2];
  result[1] = v2;
  result[2] = v3;
  *result = v2;
  result[8] = v4;
  return result;
}

//----- (08067BE0) --------------------------------------------------------
int __cdecl IO_wsetb(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  v4 = *(_DWORD *)(a1 + 88);
  v5 = *(_DWORD *)(v4 + 24);
  if ( v5 && (*(_BYTE *)(a1 + 60) & 8) == 0 )
  {
    munmap(v5, (4 * ((*(_DWORD *)(v4 + 28) - v5) >> 2) + 4095) & 0xFFFFF000);
    v4 = *(_DWORD *)(a1 + 88);
  }
  *(_DWORD *)(v4 + 24) = a2;
  *(_DWORD *)(v4 + 28) = a3;
  result = a4;
  if ( a4 )
    *(_DWORD *)(a1 + 60) &= ~8u;
  else
    *(_DWORD *)(a1 + 60) |= 8u;
  return result;
}

//----- (08067C50) --------------------------------------------------------
int __usercall IO_wdefault_pbackfail@<eax>(long double a1@<st0>, int *a2, int a3)
{
  int v3; // esi
  int *v4; // ebp
  int v5; // eax
  int v6; // edx
  _BYTE *v7; // edi
  int v8; // eax
  int v9; // ebp
  int v10; // eax
  int v12; // eax
  int v13; // eax
  int v14; // [esp+14h] [ebp-28h]
  _BYTE *v15; // [esp+18h] [ebp-24h]
  int v16; // [esp+1Ch] [ebp-20h]

  v3 = a3;
  v4 = (int *)a2[22];
  v5 = *a2;
  v6 = *v4;
  v7 = (_BYTE *)v4[2];
  if ( *v4 <= (unsigned int)v7 )
  {
    if ( (v5 & 0x100) == 0 )
    {
      if ( v4[8] )
      {
LABEL_13:
        v4[2] = v6;
        IO_switch_to_wbackup_area(a2);
        v4 = (int *)a2[22];
        v6 = *v4;
        goto LABEL_10;
      }
      goto LABEL_14;
    }
    v9 = (v4[1] - (int)v7) >> 2;
    v16 = 8 * v9;
    malloc(a1, 8 * v9);
    if ( !v10 )
      return -1;
    v15 = (_BYTE *)(v10 + 4 * v9);
    v14 = v10;
    wmemcpy(v15, v7, v9);
    free(a1, *(_DWORD *)(a2[22] + 8));
    v4 = (int *)a2[22];
    v4[2] = v14;
    *v4 = (int)v15;
    v4[9] = (int)v15;
    v4[1] = v16 + v14;
    v6 = (int)v15;
LABEL_10:
    *v4 = v6 - 4;
    *(_DWORD *)(v6 - 4) = a3;
    return v3;
  }
  if ( (v5 & 0x100) != 0 )
    goto LABEL_10;
  v8 = a2[1];
  if ( *(char *)(v8 - 1) == a3 )
  {
    a2[1] = v8 - 1;
    return v3;
  }
  if ( !v4[8] )
  {
LABEL_14:
    malloc(a1, 0x200u);
    if ( !v12 )
      return -1;
    v4[8] = v12;
    v13 = v12 + 512;
    v4[10] = v13;
    v4[9] = v13;
    goto LABEL_16;
  }
  if ( !save_for_wbackup((int)a2, v6, a1) )
  {
LABEL_16:
    v4 = (int *)a2[22];
    v6 = *v4;
    goto LABEL_13;
  }
  return -1;
}
// 8067CDE: variable 'v10' is possibly undefined
// 8067D76: variable 'v12' is possibly undefined

//----- (08067DA0) --------------------------------------------------------
void __usercall IO_wdefault_finish(long double a1@<st0>, int a2)
{
  _DWORD *v2; // edx
  int v3; // eax
  _DWORD *i; // eax

  v2 = *(_DWORD **)(a2 + 88);
  v3 = v2[6];
  if ( v3 && (*(_BYTE *)(a2 + 60) & 8) == 0 )
  {
    munmap(v3, (4 * ((v2[7] - v3) >> 2) + 4095) & 0xFFFFF000);
    v2 = *(_DWORD **)(a2 + 88);
    v2[7] = 0;
    v2[6] = 0;
  }
  for ( i = *(_DWORD **)(a2 + 48); i; i = (_DWORD *)*i )
    i[1] = 0;
  if ( *(_DWORD *)(a2 + 36) )
  {
    free(a1, v2[8]);
    *(_DWORD *)(a2 + 36) = 0;
  }
  IO_un_link((int *)a2);
}

//----- (08067E30) --------------------------------------------------------
int __cdecl IO_wdefault_uflow(int a1)
{
  int v1; // eax
  int v2; // edx
  _DWORD **v3; // eax

  v1 = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 148) + 16))(a1);
  v2 = -1;
  if ( v1 != -1 )
  {
    v3 = *(_DWORD ***)(a1 + 88);
    return *(*v3)++;
  }
  return v2;
}

//----- (08067E70) --------------------------------------------------------
int __cdecl _woverflow(int a1, int a2)
{
  if ( !*(_DWORD *)(a1 + 104) )
    IO_fwide(a1, 1);
  return (*(int (__cdecl **)(int, int))(*(_DWORD *)(a1 + 148) + 12))(a1, a2);
}

//----- (08067EC0) --------------------------------------------------------
unsigned int __cdecl IO_wdefault_xsputn(int a1, _BYTE *a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // esi
  int v6; // edi
  _BYTE *v7; // ecx
  int v8; // eax
  int v9; // ebp
  int v10; // eax
  int v11; // [esp+1Ch] [ebp-20h]

  result = 0;
  if ( a3 )
  {
    for ( i = a3; ; --i )
    {
      v6 = *(_DWORD *)(a1 + 88);
      v7 = *(_BYTE **)(v6 + 16);
      v8 = (*(_DWORD *)(v6 + 20) - (int)v7) >> 2;
      if ( v8 > 0 )
      {
        if ( i < v8 )
          v8 = i;
        if ( v8 > 20 )
        {
          v11 = v8;
          *(_DWORD *)(v6 + 16) = wmempcpy(v7, a2, v8);
          a2 += 4 * v11;
        }
        else
        {
          v11 = 0;
          if ( v8 > 0 )
          {
            v11 = v8;
            v9 = 4 * v8;
            v10 = 0;
            do
            {
              *(_DWORD *)&v7[v10] = *(_DWORD *)&a2[v10];
              v10 += 4;
            }
            while ( v10 != v9 );
            a2 += v10;
            *(_DWORD *)(v6 + 16) = &v7[v10];
          }
        }
        i -= v11;
      }
      if ( !i || _woverflow(a1, *(_DWORD *)a2) == -1 )
        break;
      a2 += 4;
    }
    return a3 - i;
  }
  return result;
}

//----- (08067F90) --------------------------------------------------------
int __cdecl IO_wdoallocbuf(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 88);
  if ( !*(_DWORD *)(result + 24) )
  {
    if ( (*(_BYTE *)a1 & 2) == 0 )
    {
      result = (*(int (__cdecl **)(int))(*(_DWORD *)(result + 184) + 52))(a1);
      if ( result != -1 )
        return result;
      result = *(_DWORD *)(a1 + 88);
    }
    return IO_wsetb(a1, result + 180, result + 184, 0);
  }
  return result;
}

//----- (08067FF0) --------------------------------------------------------
int __cdecl IO_wdefault_doallocate(int a1)
{
  int v1; // eax

  v1 = mmap(0, 0x2000, 3, 34, -1, 0);
  if ( v1 == -1 )
    return -1;
  IO_wsetb(a1, v1, v1 + 0x8000, 1);
  return 1;
}

//----- (08068060) --------------------------------------------------------
int __cdecl IO_switch_to_wget_mode(int *a1)
{
  _DWORD *v1; // eax
  int v2; // ecx
  unsigned int v3; // edx
  int v4; // edx
  int result; // eax

  v1 = (_DWORD *)a1[22];
  if ( v1[4] > v1[3] )
  {
    if ( (*(int (__cdecl **)(int *, int))(v1[46] + 12))(a1, -1) == -1 )
      return -1;
    v1 = (_DWORD *)a1[22];
  }
  v2 = *a1;
  if ( (*a1 & 0x100) != 0 )
  {
    v1[2] = v1[9];
  }
  else
  {
    v1[2] = v1[6];
    v3 = v1[4];
    if ( v3 > v1[1] )
      v1[1] = v3;
  }
  v4 = v1[4];
  BYTE1(v2) &= ~8u;
  *v1 = v4;
  v1[5] = v4;
  v1[3] = v4;
  result = 0;
  *a1 = v2;
  return result;
}

//----- (080680E0) --------------------------------------------------------
_DWORD *__cdecl IO_free_wbackup_area(_DWORD *a1)
{
  _DWORD *result; // eax

  if ( (*a1 & 0x100) != 0 )
    IO_switch_to_main_wget_area(a1);
  free(*(_DWORD *)(a1[22] + 32));
  result = (_DWORD *)a1[22];
  result[8] = 0;
  result[10] = 0;
  result[9] = 0;
  return result;
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08068130) --------------------------------------------------------
int __usercall _wunderflow@<eax>(long double a1@<st0>, int *a2)
{
  int *v2; // eax
  int v3; // edx
  int v4; // edx
  int result; // eax
  int v6; // edx

  if ( a2[26] < 0 )
    return -1;
  if ( a2[26] )
  {
LABEL_3:
    if ( (*a2 & 0x800) == 0 || IO_switch_to_wget_mode(a2) != -1 )
    {
      v2 = (int *)a2[22];
      v3 = *v2;
      if ( *v2 < (unsigned int)v2[1] )
        return *(_DWORD *)v3;
      if ( (*a2 & 0x100) != 0 )
      {
        IO_switch_to_main_wget_area(a2);
        v2 = (int *)a2[22];
        v3 = *v2;
        if ( *v2 < (unsigned int)v2[1] )
          return *(_DWORD *)v3;
      }
      if ( a2[12] )
      {
        v4 = save_for_wbackup((int)a2, v2[1], a1);
        result = -1;
        if ( v4 )
          return result;
      }
      else if ( a2[9] )
      {
        IO_free_wbackup_area(a2);
      }
      return (*(int (__cdecl **)(int *))(a2[37] + 16))(a2);
    }
    return -1;
  }
  v6 = IO_fwide((int)a2, 1);
  result = -1;
  if ( v6 == 1 )
  {
    if ( !a2[26] )
      IO_fwide((int)a2, 1);
    goto LABEL_3;
  }
  return result;
}

//----- (08068230) --------------------------------------------------------
unsigned int __usercall IO_wdefault_xsgetn@<eax>(long double a1@<st0>, int *a2, _WORD *a3, unsigned int a4)
{
  unsigned int v5; // esi
  int v6; // ebp
  _BYTE *v7; // ecx
  int v8; // eax
  int v9; // edi
  unsigned int v10; // eax
  int v12; // [esp+1Ch] [ebp-20h]

  v5 = a4;
  do
  {
    v6 = a2[22];
    v7 = *(_BYTE **)v6;
    v8 = (*(_DWORD *)(v6 + 4) - *(_DWORD *)v6) >> 2;
    if ( v8 > 0 )
    {
      if ( v5 < v8 )
        v8 = v5;
      if ( v8 > 20 )
      {
        v12 = v8;
        a3 = wmempcpy(a3, v7, v8);
        *(_DWORD *)a2[22] += 4 * v12;
      }
      else
      {
        v12 = 0;
        if ( v8 )
        {
          v12 = v8;
          v9 = 4 * v8;
          v10 = 0;
          do
          {
            *(_DWORD *)&a3[v10 / 2] = *(_DWORD *)&v7[v10];
            v10 += 4;
          }
          while ( v10 != v9 );
          a3 = (_WORD *)((char *)a3 + v10);
          *(_DWORD *)v6 = &v7[v10];
        }
      }
      v5 -= v12;
    }
  }
  while ( v5 && _wunderflow(a1, a2) != -1 );
  return a4 - v5;
}

//----- (080682E0) --------------------------------------------------------
int __usercall _wuflow@<eax>(long double a1@<st0>, int *a2)
{
  int v2; // edx
  int *v3; // ecx
  int v4; // edx
  int result; // eax
  int v6; // edx

  if ( a2[26] < 0 )
    return -1;
  if ( a2[26] )
  {
LABEL_3:
    if ( (*a2 & 0x800) == 0 || IO_switch_to_wget_mode(a2) != -1 )
    {
      v2 = a2[22];
      v3 = *(int **)v2;
      if ( *(_DWORD *)v2 < *(_DWORD *)(v2 + 4)
        || (*a2 & 0x100) != 0
        && (IO_switch_to_main_wget_area(a2), v2 = a2[22], v3 = *(int **)v2, *(_DWORD *)v2 < *(_DWORD *)(v2 + 4)) )
      {
        result = *v3;
        *(_DWORD *)v2 = v3 + 1;
        return result;
      }
      if ( a2[12] )
      {
        v4 = save_for_wbackup((int)a2, *(_DWORD *)(v2 + 4), a1);
        result = -1;
        if ( v4 )
          return result;
      }
      else if ( *(_DWORD *)(v2 + 32) )
      {
        IO_free_wbackup_area(a2);
      }
      return (*(int (__cdecl **)(int *))(a2[37] + 20))(a2);
    }
    return -1;
  }
  v6 = IO_fwide((int)a2, 1);
  result = -1;
  if ( v6 == 1 )
  {
    if ( !a2[26] )
      IO_fwide((int)a2, 1);
    goto LABEL_3;
  }
  return result;
}

//----- (080683F0) --------------------------------------------------------
int __cdecl IO_sputbackwc(_DWORD *a1, int a2)
{
  int result; // eax
  int *v3; // edx
  int v4; // ecx

  result = a2;
  v3 = (int *)a1[22];
  v4 = *v3;
  if ( *v3 > (unsigned int)v3[2] && *(_DWORD *)(v4 - 4) == a2 )
    *v3 = v4 - 4;
  else
    result = (*(int (__cdecl **)(_DWORD *, int))(a1[37] + 24))(a1, a2);
  if ( result != -1 )
    *a1 &= ~0x10u;
  return result;
}

//----- (08068430) --------------------------------------------------------
int __cdecl IO_sungetwc(_DWORD *a1)
{
  int *v1; // eax
  int v2; // edx
  int result; // eax

  v1 = (int *)a1[22];
  v2 = *v1;
  if ( *v1 <= (unsigned int)v1[2] )
  {
    result = (*(int (__cdecl **)(_DWORD *, int))(a1[37] + 24))(a1, -1);
  }
  else
  {
    *v1 = v2 - 4;
    result = *(_DWORD *)(v2 - 4);
  }
  if ( result != -1 )
    *a1 &= ~0x10u;
  return result;
}

//----- (08068470) --------------------------------------------------------
int __cdecl IO_adjust_wcolumn(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax
  _DWORD *v4; // edx

  v3 = a2 + 4 * a3;
  if ( a2 >= v3 )
    return a3 + a1;
  v4 = (_DWORD *)(v3 - 4);
  if ( *(_DWORD *)(v3 - 4) != 10 )
  {
    while ( a2 < (unsigned int)v4 )
    {
      if ( *--v4 == 10 )
        return ((int)(v3 - (_DWORD)v4) >> 2) - 1;
    }
    return a3 + a1;
  }
  return ((int)(v3 - (_DWORD)v4) >> 2) - 1;
}

//----- (080684C0) --------------------------------------------------------
int __cdecl IO_init_wmarker(int *a1, int *a2)
{
  int v2; // eax
  int *v3; // edx
  bool v4; // zf
  int v5; // eax
  int v6; // eax
  int result; // eax

  v2 = *a2;
  a1[1] = (int)a2;
  if ( (v2 & 0x800) != 0 )
  {
    IO_switch_to_wget_mode(a2);
    v2 = *a2;
  }
  v3 = (int *)a2[22];
  v4 = (v2 & 0x100) == 0;
  v5 = *v3;
  if ( v4 )
    v6 = v5 - v3[2];
  else
    v6 = v5 - v3[1];
  a1[2] = v6 >> 2;
  result = a2[12];
  *a1 = result;
  a2[12] = (int)a1;
  return result;
}

//----- (08068530) --------------------------------------------------------
int __cdecl IO_wmarker_delta(int a1)
{
  int *v1; // eax
  int v2; // edx
  int *v3; // eax
  bool v4; // zf
  int v5; // edx
  int v6; // edx

  v1 = *(int **)(a1 + 4);
  if ( !v1 )
    return -1;
  v2 = *v1;
  v3 = (int *)v1[22];
  v4 = (v2 & 0x100) == 0;
  v5 = *v3;
  if ( v4 )
    v6 = v5 - v3[2];
  else
    v6 = v5 - v3[1];
  return *(_DWORD *)(a1 + 8) - (v6 >> 2);
}

//----- (08068570) --------------------------------------------------------
int __cdecl IO_seekwmark(int *a1, int a2)
{
  int result; // eax
  int *v3; // ebx
  int v4; // eax
  int v5; // edx

  result = -1;
  v3 = *(int **)(a2 + 4);
  if ( v3 == a1 )
  {
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *v3;
    if ( v4 < 0 )
    {
      if ( (v5 & 0x100) == 0 )
      {
        IO_switch_to_wbackup_area(*(_DWORD **)(a2 + 4));
        v4 = *(_DWORD *)(a2 + 8);
      }
      *(_DWORD *)v3[22] = *(_DWORD *)(v3[22] + 4) + 4 * v4;
      return 0;
    }
    else
    {
      if ( (v5 & 0x100) != 0 )
      {
        IO_switch_to_main_wget_area(*(_DWORD **)(a2 + 4));
        v4 = *(_DWORD *)(a2 + 8);
      }
      *(_DWORD *)v3[22] = *(_DWORD *)(v3[22] + 8) + 4 * v4;
      return 0;
    }
  }
  return result;
}

//----- (08068600) --------------------------------------------------------
_DWORD *__cdecl IO_unsave_wmarkers(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  if ( a1[12] )
    a1[12] = 0;
  if ( a1[9] )
    return IO_free_wbackup_area(a1);
  return result;
}

//----- (08068630) --------------------------------------------------------
int __usercall IO_wfile_seekoff@<eax>(long double a1@<st0>, int a2, int a3, unsigned int a4, int a5, int a6)
{
  unsigned int *v8; // eax
  unsigned int v9; // edx
  int v11; // ecx
  int v12; // ebx
  _DWORD *v13; // eax
  int v14; // edx
  int v15; // ebx
  int v16; // eax
  unsigned __int64 v17; // kr08_8
  __int64 v18; // rax
  int v19; // eax
  int v20; // eax
  _DWORD *v21; // eax
  int v22; // edx
  int v23; // edx
  __int64 v24; // rax
  unsigned __int64 v25; // rcx
  __int64 v26; // rax
  __int64 v27; // rcx
  int v28; // edx
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // edx
  _DWORD *v33; // eax
  int v34; // edx
  __int64 v35; // rax
  int v36; // ecx
  _DWORD *v37; // ecx
  int v38; // ebx
  _DWORD *v39; // eax
  int v40; // ecx
  int v41; // eax
  int v42; // ecx
  int v43; // [esp+4h] [ebp-C8h]
  int v44; // [esp+34h] [ebp-98h]
  __int64 v45; // [esp+38h] [ebp-94h]
  unsigned int v46; // [esp+38h] [ebp-94h]
  __int64 v47; // [esp+38h] [ebp-94h]
  int v48; // [esp+38h] [ebp-94h]
  int v49; // [esp+40h] [ebp-8Ch]
  __int64 v50; // [esp+40h] [ebp-8Ch]
  _BOOL4 v51; // [esp+4Ch] [ebp-80h]
  int v52; // [esp+4Ch] [ebp-80h]
  char v53[16]; // [esp+50h] [ebp-7Ch] BYREF
  int v54; // [esp+60h] [ebp-6Ch]
  __int64 v55; // [esp+7Ch] [ebp-50h]

  v8 = *(unsigned int **)(a2 + 88);
  v51 = 0;
  v9 = v8[1];
  if ( v8[2] == v9 )
    v51 = v8[3] == v8[4];
  if ( !a6 )
  {
    a3 = 0;
    a4 = 0;
    a5 = 1;
    if ( (*(_DWORD *)a2 & 0x100) != 0 )
    {
      if ( v9 > *v8 )
      {
        a3 = -1;
        __writegsdword(0xFFFFFFE8, 0x16u);
        return a3;
      }
      IO_switch_to_main_wget_area((_DWORD *)a2);
      v8 = *(unsigned int **)(a2 + 88);
    }
  }
  if ( v8[4] > v8[3] || (*(_DWORD *)a2 & 0x800) != 0 )
  {
    if ( IO_switch_to_wget_mode((int *)a2) )
      return -1;
    v8 = *(unsigned int **)(a2 + 88);
  }
  if ( !v8[6] )
  {
    v19 = v8[2];
    if ( v19 )
    {
      free(a1, v19);
      *(_DWORD *)a2 &= ~0x100u;
    }
    IO_doallocbuf(a2);
    v20 = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a2 + 20) = v20;
    *(_DWORD *)(a2 + 16) = v20;
    *(_DWORD *)(a2 + 24) = v20;
    *(_DWORD *)(a2 + 12) = v20;
    *(_DWORD *)(a2 + 4) = v20;
    *(_DWORD *)(a2 + 8) = v20;
    v21 = *(_DWORD **)(a2 + 88);
    v22 = v21[6];
    v21[4] = v22;
    v21[3] = v22;
    v21[5] = v22;
    v21[2] = v22;
    *v21 = v22;
    v21[1] = v22;
  }
  if ( a5 == 1 )
  {
    v15 = *(_DWORD *)(a2 + 84);
    v16 = (*(int (__cdecl **)(int))(v15 + 16))(v15);
    if ( v16 <= 0 )
    {
      v39 = *(_DWORD **)(a2 + 88);
      v48 = (*v39 - v39[2]) >> 2;
      v40 = v39[14];
      v39[11] = v39[13];
      v39[12] = v40;
      v41 = (*(int (__cdecl **)(int, int, _DWORD, _DWORD, int))(v15 + 24))(
              v15,
              *(_DWORD *)(a2 + 88) + 44,
              *(_DWORD *)(a2 + 12),
              *(_DWORD *)(a2 + 8),
              v48);
      v42 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 4) = v42 + v41;
      *(_DWORD *)(*(_DWORD *)(a2 + 88) + 4) = **(_DWORD **)(a2 + 88);
      a4 = (__PAIR64__(a4, a3) - (*(_DWORD *)(a2 + 8) - v42 - v41)) >> 32;
      a3 -= *(_DWORD *)(a2 + 8) - v42 - v41;
    }
    else
    {
      v17 = __PAIR64__(a4, a3)
          - v16 * ((*(_DWORD *)(*(_DWORD *)(a2 + 88) + 4) - **(_DWORD **)(a2 + 88)) >> 2)
          - (*(_DWORD *)(a2 + 8)
           - *(_DWORD *)(a2 + 4));
      a4 = HIDWORD(v17);
      a3 = v17;
    }
    v18 = *(_QWORD *)(a2 + 76);
    if ( (HIDWORD(v18) & *(_DWORD *)(a2 + 76)) == -1 )
      goto LABEL_46;
    a4 = (v18 + __PAIR64__(a4, a3)) >> 32;
    a3 += v18;
    a5 = 0;
  }
  else if ( a5 == 2 )
  {
    if ( (*(int (__cdecl **)(int, char *))(*(_DWORD *)(a2 + 148) + 72))(a2, v53) || (v54 & 0xF000) != 0x8000 )
      goto LABEL_46;
    a5 = 0;
    a4 = (v55 + __PAIR64__(a4, a3)) >> 32;
    a3 += v55;
  }
  if ( !a6 )
    return a3;
  v45 = *(_QWORD *)(a2 + 76);
  if ( (HIDWORD(v45) & (unsigned int)v45) == -1 )
  {
    v11 = *(_DWORD *)a2;
  }
  else
  {
    v11 = *(_DWORD *)a2;
    if ( *(_DWORD *)(a2 + 12) )
    {
      if ( (v11 & 0x100) == 0 )
      {
        v12 = *(_DWORD *)(a2 + 28);
        v49 = v45 - (*(_DWORD *)(a2 + 8) - v12);
        if ( __SPAIR64__(a4, a3) >= v45 - (*(_DWORD *)(a2 + 8) - v12) && __SPAIR64__(a4, a3) < v45 )
        {
          *(_DWORD *)(a2 + 12) = v12;
          *(_DWORD *)(a2 + 20) = v12;
          *(_DWORD *)(a2 + 4) = v12 + a3 - v49;
          v13 = *(_DWORD **)(a2 + 88);
          *(_DWORD *)(a2 + 16) = v12;
          *(_DWORD *)(a2 + 24) = v12;
          v14 = v13[6];
          v13[2] = v14;
          *v13 = v14;
          v13[1] = v14;
          v13[4] = v14;
          v13[3] = v14;
          v13[5] = v14;
          *(_DWORD *)a2 = v11 & 0xFFFFFFEF;
          if ( v45 >= 0 )
            (*(void (__cdecl **)(int, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(a2 + 148) + 64))(a2, v45, HIDWORD(v45), 0);
          return a3;
        }
      }
    }
  }
  if ( (v11 & 4) == 0 )
  {
    v23 = *(_DWORD *)(a2 + 28) - *(_DWORD *)(a2 + 32);
    LODWORD(v25) = v23 & a3;
    LODWORD(v24) = a3;
    HIDWORD(v25) = v23 >> 31;
    HIDWORD(v24) = a4;
    HIDWORD(v25) &= a4;
    v50 = v24 - v25;
    HIDWORD(v24) = *(_DWORD *)(a2 + 32) - *(_DWORD *)(a2 + 28);
    v46 = HIDWORD(v24);
    v26 = SHIDWORD(v24);
    if ( SHIDWORD(v50) > (int)v26 >> 31 || SHIDWORD(v50) >= SHIDWORD(v26) && (unsigned int)v50 > v46 )
    {
      v25 = __PAIR64__(a4, a3);
      v50 = 0LL;
    }
    v27 = ((__int64 (__cdecl *)(int, _DWORD, _DWORD, _DWORD))*(_DWORD *)(*(_DWORD *)(a2 + 148) + 64))(
            a2,
            v25,
            HIDWORD(v25),
            0);
    if ( v27 < 0 )
      return -1;
    if ( !v50 )
    {
      v47 = 0LL;
      v52 = 0;
      goto LABEL_43;
    }
    if ( v51 )
    {
      v29 = v50;
      v28 = *(_DWORD *)(a2 + 28);
    }
    else
    {
      v28 = *(_DWORD *)(a2 + 28);
      v29 = *(_DWORD *)(a2 + 32) - v28;
    }
    v44 = v27;
    v30 = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a2 + 148) + 56))(a2, v28, v29);
    LODWORD(v27) = v44;
    v47 = v30;
    if ( v50 <= v30 )
    {
      v52 = v30;
LABEL_43:
      v31 = *(_DWORD *)(a2 + 28);
      *(_DWORD *)(a2 + 12) = v31;
      *(_DWORD *)(a2 + 4) = v31 + v50;
      *(_DWORD *)(a2 + 20) = v31;
      *(_DWORD *)(a2 + 16) = v31;
      *(_DWORD *)(a2 + 24) = v31;
      v32 = v31 + v52;
      v33 = *(_DWORD **)(a2 + 88);
      *(_DWORD *)(a2 + 8) = v32;
      v34 = v33[6];
      v33[2] = v34;
      *v33 = v34;
      v33[1] = v34;
      v33[4] = v34;
      v33[3] = v34;
      v33[5] = v34;
      *(_QWORD *)(a2 + 76) = v47 + v27;
      *(_DWORD *)a2 &= ~0x10u;
      return a3;
    }
    a4 = HIDWORD(v50);
    a3 = v50;
    a5 = 1;
    if ( v30 != -1 )
    {
      a4 = (unsigned __int64)(v50 - v30) >> 32;
      a3 = v50 - v30;
    }
  }
LABEL_46:
  IO_unsave_markers((int *)a2);
  v43 = a3;
  a3 = -1;
  v35 = ((__int64 (__cdecl *)(int, int, unsigned int, int))*(_DWORD *)(*(_DWORD *)(a2 + 148) + 64))(a2, v43, a4, a5);
  if ( (HIDWORD(v35) & (unsigned int)v35) != -1 )
  {
    v36 = *(_DWORD *)(a2 + 28);
    a3 = v35;
    *(_DWORD *)a2 &= ~0x10u;
    *(_DWORD *)(a2 + 76) = v35;
    *(_DWORD *)(a2 + 12) = v36;
    *(_DWORD *)(a2 + 4) = v36;
    *(_DWORD *)(a2 + 8) = v36;
    *(_DWORD *)(a2 + 20) = v36;
    *(_DWORD *)(a2 + 16) = v36;
    *(_DWORD *)(a2 + 24) = v36;
    v37 = *(_DWORD **)(a2 + 88);
    *(_DWORD *)(a2 + 80) = HIDWORD(v35);
    v38 = v37[6];
    v37[2] = v38;
    *v37 = v38;
    v37[1] = v38;
    v37[4] = v38;
    v37[3] = v38;
    v37[5] = v38;
  }
  return a3;
}
// 8068630: using guessed type char var_7C[16];

//----- (08068C10) --------------------------------------------------------
void __usercall IO_wfile_underflow(long double a1@<st0>, int a2)
{
  _DWORD *v2; // ecx
  int v3; // edi
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // esi
  int v7; // edx
  int *v8; // ecx
  unsigned int v10; // edi
  bool v12; // zf
  size_t n; // esi
  _DWORD *v14; // eax
  size_t v15; // edi
  int v16; // edx
  int v17; // eax
  unsigned int v18; // ecx
  unsigned int v19; // edi
  unsigned int v20; // ebp
  _DWORD *v21; // eax
  unsigned int v22; // ebp
  _BYTE *v23; // edx
  int v24; // edi
  int v25; // eax
  char *src; // edx
  const void *v27; // eax
  size_t v28; // ebp
  int v29; // edx
  int v30; // eax
  _DWORD *v31; // eax
  int v32; // edx
  int v33; // eax
  void *v34; // esi
  _DWORD *v35; // edx
  _DWORD *v36; // edx
  int v37; // eax
  int v38; // edx
  int v39; // edx
  char *v40; // edi
  _WORD *v41; // eax
  int v42; // ecx
  int v43; // [esp+2Ch] [ebp-40h]
  char dest[16]; // [esp+38h] [ebp-34h] BYREF
  void *v45; // [esp+48h] [ebp-24h] BYREF
  void *v46[8]; // [esp+4Ch] [ebp-20h] BYREF

  if ( (*(_DWORD *)a2 & 4) != 0 )
  {
    *(_DWORD *)a2 |= 0x20u;
    __writegsdword(0xFFFFFFE8, 9u);
    return;
  }
  v2 = *(_DWORD **)(a2 + 88);
  if ( *v2 >= v2[1] )
  {
    v3 = *(_DWORD *)(a2 + 84);
    v43 = v3;
    if ( *(_DWORD *)(a2 + 4) < *(_DWORD *)(a2 + 8) )
    {
      v29 = v2[12];
      v45 = *(void **)(a2 + 4);
      v30 = v2[11];
      v2[14] = v29;
      v2[13] = v30;
      v31 = *(_DWORD **)(a2 + 88);
      v32 = v31[6];
      *v31 = v32;
      v31[2] = v32;
      v33 = (*(int (__cdecl **)(int, _DWORD *, _DWORD, _DWORD, void **, int, _DWORD, _DWORD *))(v3 + 12))(
              v3,
              v31 + 11,
              *(_DWORD *)(a2 + 4),
              *(_DWORD *)(a2 + 8),
              &v45,
              v32,
              v31[7],
              v31 + 1);
      v34 = v45;
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 + 4);
      v35 = *(_DWORD **)(a2 + 88);
      *(_DWORD *)(a2 + 4) = v34;
      if ( *v35 < v35[1] )
        return;
      if ( v33 == 2 )
      {
        __writegsdword(0xFFFFFFE8, 0x54u);
        *(_DWORD *)a2 |= 0x20u;
        return;
      }
      memmove(*(void **)(a2 + 28), v34, *(_DWORD *)(a2 + 8) - (_DWORD)v34);
      v4 = *(_DWORD *)(a2 + 28);
      v38 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 12) = v4;
      v39 = v4 + v38 - *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = v4;
      *(_DWORD *)(a2 + 8) = v39;
    }
    else
    {
      v4 = *(_DWORD *)(a2 + 28);
      *(_DWORD *)(a2 + 8) = v4;
      *(_DWORD *)(a2 + 4) = v4;
      *(_DWORD *)(a2 + 12) = v4;
    }
    if ( !v4 )
    {
      if ( *(_DWORD *)(a2 + 36) )
      {
        free(a1, *(_DWORD *)(a2 + 36));
        *(_DWORD *)a2 &= ~0x100u;
      }
      IO_doallocbuf(a2);
      v4 = *(_DWORD *)(a2 + 28);
      *(_DWORD *)(a2 + 8) = v4;
      *(_DWORD *)(a2 + 4) = v4;
      *(_DWORD *)(a2 + 12) = v4;
    }
    *(_DWORD *)(a2 + 24) = v4;
    *(_DWORD *)(a2 + 20) = v4;
    *(_DWORD *)(a2 + 16) = v4;
    v5 = *(_DWORD *)(a2 + 88);
    if ( !*(_DWORD *)(v5 + 24) )
    {
      v37 = *(_DWORD *)(v5 + 32);
      if ( v37 )
      {
        free(a1, v37);
        *(_DWORD *)a2 &= ~0x100u;
      }
      IO_wdoallocbuf(a2);
    }
    if ( (*(_DWORD *)a2 & 0x202) != 0 )
    {
      v6 = stdout;
      v7 = *(_DWORD *)stdout;
      v8 = (int *)stdout;
      if ( (*(_DWORD *)stdout & 0x8000) == 0 )
      {
        _EDX = *((_DWORD *)stdout + 18);
        v10 = __readgsdword(8u);
        if ( v10 != *(_DWORD *)(_EDX + 8) )
        {
          _ECX = 1;
          v12 = __readgsdword(0xCu) == 0;
          if ( !v12 )
            __asm { lock }
          __asm { cmpxchg [edx], ecx }
          if ( !v12 )
          {
            L_lock_752(0, (volatile __int32 *)_EDX);
            return;
          }
          _EDX = v6[18];
          v8 = (int *)stdout;
          *(_DWORD *)(_EDX + 8) = v10;
        }
        ++*(_DWORD *)(_EDX + 4);
        v7 = *v8;
      }
      if ( (v7 & 0x288) == 640 )
        (*(void (__cdecl **)(int *, int))(v8[37] + 12))(v8, -1);
      if ( (BYTE1(*v6) & 0x80u) == 0 )
      {
        v36 = (_DWORD *)v6[18];
        v12 = v36[1]-- == 1;
        if ( v12 )
        {
          v36[2] = 0;
          if ( __readgsdword(0xCu) )
            __asm { lock }
          v12 = (*v36)-- == 1;
          if ( !v12 )
          {
            L_unlock_1161((int)v8, v36);
            return;
          }
        }
      }
    }
    n = 0;
    IO_switch_to_get_mode((int *)a2);
    v14 = *(_DWORD **)(a2 + 88);
    v15 = *(_DWORD *)(a2 + 8);
    v16 = v14[6];
    *v14 = v16;
    v14[2] = v16;
    v14[1] = v16;
    v14[5] = v16;
    v14[4] = v16;
    v14[3] = v16;
    while ( 1 )
    {
      v17 = (*(int (__cdecl **)(int, size_t, size_t))(*(_DWORD *)(a2 + 148) + 56))(a2, v15, *(_DWORD *)(a2 + 32) - v15);
      v18 = v17;
      if ( v17 <= 0 )
      {
        if ( n || v17 )
        {
          *(_DWORD *)a2 |= 0x20u;
          if ( n )
            __writegsdword(0xFFFFFFE8, 0x54u);
        }
        else
        {
          *(_DWORD *)a2 |= 0x10u;
        }
        return;
      }
      v19 = *(_DWORD *)(a2 + 76);
      v20 = *(_DWORD *)(a2 + 80);
      *(_DWORD *)(a2 + 8) += v17;
      if ( (v20 & v19) != -1 )
        *(_QWORD *)(a2 + 76) = __PAIR64__(v20, v19) + v17;
      v21 = *(_DWORD **)(a2 + 88);
      v22 = v21[12];
      v21[13] = v21[11];
      v21[14] = v22;
      v23 = *(_BYTE **)(a2 + 4);
      v24 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 12) = v23;
      if ( n )
      {
        v22 = 16 - n;
        if ( 16 - n > v18 )
          v22 = v18;
        v40 = &dest[n];
        n += v22;
        v41 = mempcpy(v40, v23, v22);
        v25 = (*(int (__cdecl **)(int, int, char *, _WORD *, void **, _DWORD, _DWORD, int))(v43 + 12))(
                v43,
                *(_DWORD *)(a2 + 88) + 44,
                dest,
                v41,
                v46,
                *(_DWORD *)(*(_DWORD *)(a2 + 88) + 4),
                *(_DWORD *)(*(_DWORD *)(a2 + 88) + 28),
                *(_DWORD *)(a2 + 88) + 4);
        if ( n )
        {
          src = (char *)v46[0];
          v42 = v46[0] - (void *)v40;
          if ( v46[0] - (void *)v40 < 0 )
            v42 = 0;
          *(_DWORD *)(a2 + 4) += v42;
          goto LABEL_25;
        }
      }
      else
      {
        v25 = (*(int (__cdecl **)(int, int, _BYTE *, int, void **, _DWORD, _DWORD, int))(v43 + 12))(
                v43,
                *(_DWORD *)(a2 + 88) + 44,
                v23,
                v24,
                v46,
                *(_DWORD *)(*(_DWORD *)(a2 + 88) + 4),
                *(_DWORD *)(*(_DWORD *)(a2 + 88) + 28),
                *(_DWORD *)(a2 + 88) + 4);
      }
      src = (char *)v46[0];
      n = 0;
      *(void **)(a2 + 4) = v46[0];
LABEL_25:
      if ( *(_DWORD *)(*(_DWORD *)(a2 + 88) + 4) != *(_DWORD *)(*(_DWORD *)(a2 + 88) + 24) )
        return;
      if ( v25 == 2 )
      {
LABEL_44:
        __writegsdword(0xFFFFFFE8, 0x54u);
        *(_DWORD *)a2 |= 0x20u;
        return;
      }
      if ( v25 != 1 )
        _assert_fail(v22, a1, (int)"status == __codecvt_partial", (int)"wfileops.c", 296, "_IO_wfile_underflow");
      if ( n )
      {
        if ( src != dest )
        {
          n -= src - dest;
          memmove(dest, src, n);
        }
        if ( n == 16 )
          goto LABEL_44;
        v15 = *(_DWORD *)(a2 + 12);
LABEL_32:
        *(_DWORD *)(a2 + 8) = v15;
        *(_DWORD *)(a2 + 4) = v15;
      }
      else
      {
        v15 = *(_DWORD *)(a2 + 12);
        v27 = *(const void **)(a2 + 4);
        if ( v15 >= (unsigned int)v27 )
        {
          n = *(_DWORD *)(a2 + 8) - (_DWORD)v27;
          if ( n > 0xF )
            goto LABEL_44;
          memcpy(dest, *(_BYTE **)(a2 + 4), n);
          goto LABEL_32;
        }
        v28 = *(_DWORD *)(a2 + 8) - (_DWORD)v27;
        memmove(*(void **)(a2 + 12), v27, v28);
        v15 = *(_DWORD *)(a2 + 8) - v28;
        *(_DWORD *)(a2 + 4) = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(a2 + 8) = v15;
      }
    }
  }
}
// 8068F91: variable 'v8' is possibly undefined
// 80EFA20: using guessed type void *stdout;
// 8068C10: using guessed type char var_34[16];

//----- (08069150) --------------------------------------------------------
int __cdecl IO_wfile_underflow_maybe_mmap(_DWORD *a1)
{
  if ( IO_file_underflow_maybe_mmap(a1) == -1 )
    return -1;
  else
    return (*(int (__cdecl **)(_DWORD *))(*(_DWORD *)(a1[22] + 184) + 16))(a1);
}

//----- (08069190) --------------------------------------------------------
int __usercall IO_wfile_underflow_mmap@<eax>(long double a1@<st0>, _DWORD *a2)
{
  _DWORD *v2; // ecx
  unsigned int v3; // eax
  int v4; // esi
  int v5; // edx
  _DWORD *v6; // eax
  int v7; // edx
  _DWORD *v8; // eax
  int result; // eax
  int v10; // edx
  unsigned int v11[4]; // [esp+2Ch] [ebp-10h] BYREF

  if ( (*a2 & 4) != 0 )
  {
    *a2 |= 0x20u;
    __writegsdword(0xFFFFFFE8, 9u);
    return -1;
  }
  v2 = (_DWORD *)a2[22];
  if ( *v2 < v2[1] )
    return *(_DWORD *)*v2;
  v3 = a2[1];
  v4 = a2[21];
  if ( v3 >= a2[2] )
  {
    v10 = IO_file_underflow_mmap(a2);
    result = -1;
    if ( v10 == -1 )
      return result;
    v3 = a2[1];
    v2 = (_DWORD *)a2[22];
  }
  v11[0] = v3;
  if ( !v2[6] )
  {
    if ( v2[8] )
    {
      free(a1, v2[8]);
      *a2 &= ~0x100u;
    }
    IO_wdoallocbuf((int)a2);
    v2 = (_DWORD *)a2[22];
  }
  v5 = v2[12];
  v2[13] = v2[11];
  v2[14] = v5;
  v6 = (_DWORD *)a2[22];
  v7 = v6[6];
  *v6 = v7;
  v6[2] = v7;
  (*(void (__cdecl **)(int, _DWORD *, _DWORD, _DWORD, unsigned int *, int, _DWORD, _DWORD *))(v4 + 12))(
    v4,
    v6 + 11,
    a2[1],
    a2[2],
    v11,
    v7,
    v6[7],
    v6 + 1);
  a2[1] = v11[0];
  v8 = (_DWORD *)a2[22];
  if ( *v8 < v8[1] )
    return *(_DWORD *)*v8;
  __writegsdword(0xFFFFFFE8, 0x54u);
  result = -1;
  *a2 |= 0x20u;
  return result;
}
// 8069190: using guessed type unsigned int var_10[4];

//----- (080692C0) --------------------------------------------------------
int __cdecl IO_wdo_write(_DWORD *a1, int a2, int a3)
{
  int v3; // esi
  int v5; // edx
  int v6; // ecx
  unsigned int v7; // eax
  int v8; // eax
  int v9; // ebp
  int v10; // eax
  _DWORD *v11; // eax
  bool v12; // zf
  int v13; // edx
  int v15; // [esp+28h] [ebp-34h]
  int v16; // [esp+28h] [ebp-34h]
  int v17[8]; // [esp+3Ch] [ebp-20h] BYREF

  v3 = a3;
  v5 = a1[21];
  if ( a3 )
  {
    v6 = a1[5];
    if ( a1[6] != v6 || (v7 = a1[4], v6 == v7) )
    {
LABEL_7:
      while ( 1 )
      {
        v16 = v5;
        v9 = (*(int (__cdecl **)(int, int, int, int, int *, int, _DWORD, _DWORD *))(v5 + 4))(
               v5,
               a1[22] + 44,
               a2,
               a2 + 4 * v3,
               v17,
               v6,
               a1[8],
               a1 + 5);
        v10 = IO_new_do_write((int)a1, a1[4], a1[5] - a1[4]);
        v5 = v16;
        if ( v10 == -1 )
          break;
        v3 -= (v17[0] - a2) >> 2;
        if ( v9 && (v9 != 1 || (unsigned int)(v17[0] - a2 + 3) <= 6) || !v3 )
          goto LABEL_12;
        v6 = a1[5];
        a2 = v17[0];
      }
    }
    else
    {
      v15 = a1[21];
      v8 = IO_new_do_write((int)a1, v7, v6 - v7);
      v5 = v15;
      if ( v8 != -1 )
      {
        v6 = a1[5];
        goto LABEL_7;
      }
    }
    return -1;
  }
  else
  {
LABEL_12:
    v11 = (_DWORD *)a1[22];
    v12 = (*a1 & 0x202) == 0;
    v13 = v11[6];
    v11[2] = v13;
    *v11 = v13;
    v11[1] = v13;
    v11[4] = v13;
    v11[3] = v13;
    if ( v12 )
      v13 = v11[7];
    v11[5] = v13;
    return -(v3 != 0);
  }
}
// 80692C0: using guessed type int var_20[8];

//----- (080693F0) --------------------------------------------------------
unsigned int __cdecl IO_wfile_xsputn(_DWORD *a1, char *a2, unsigned int a3)
{
  unsigned int result; // eax
  char *v4; // esi
  _DWORD *v5; // ebp
  _BYTE *v6; // edx
  unsigned int v7; // ecx
  unsigned int v8; // edi
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // eax
  char *v13; // edi
  char *v14; // edi
  int v15; // [esp+18h] [ebp-24h]

  result = 0;
  v4 = a2;
  if ( a3 )
  {
    v5 = (_DWORD *)a1[22];
    v6 = (_BYTE *)v5[4];
    if ( (*a1 & 0xA00) == 2560 )
    {
      v15 = 0;
      v7 = (v5[7] - (int)v6) >> 2;
      if ( a3 <= v7 )
      {
        v13 = &a2[4 * a3];
        v15 = 0;
        if ( a2 < v13 )
        {
          v14 = v13 - 4;
          if ( *(_DWORD *)&a2[4 * a3 - 4] == 10 )
          {
LABEL_23:
            v7 = ((v14 - a2) >> 2) + 1;
            v15 = 1;
          }
          else
          {
            while ( a2 < v14 )
            {
              v14 -= 4;
              if ( *(_DWORD *)v14 == 10 )
                goto LABEL_23;
            }
            v15 = 0;
          }
        }
      }
    }
    else
    {
      v15 = 0;
      v7 = (v5[5] - (int)v6) >> 2;
    }
    v8 = a3;
    if ( !v7 )
      goto LABEL_5;
    if ( v7 <= a3 )
      v8 = v7;
    v12 = 0;
    if ( v8 > 0x14 )
    {
      v4 = &a2[4 * v8];
      v5[4] = wmempcpy(v6, a2, v8);
    }
    else
    {
      do
      {
        *(_DWORD *)&v6[4 * v12] = *(_DWORD *)&a2[4 * v12];
        ++v12;
      }
      while ( v12 != v8 );
      v4 = &a2[4 * v8];
      v5[4] = &v6[4 * v8];
    }
    v8 = a3 - v8;
    if ( v8 )
LABEL_5:
      v8 -= IO_wdefault_xsputn((int)a1, v4, v8);
    if ( v15 )
    {
      v9 = a1[22];
      v10 = *(_DWORD *)(v9 + 16);
      v11 = *(_DWORD *)(v9 + 12);
      if ( v10 != v11 )
        IO_wdo_write(a1, v11, (v10 - v11) >> 2);
    }
    return a3 - v8;
  }
  return result;
}

//----- (08069580) --------------------------------------------------------
int __cdecl IO_wfile_sync(_DWORD *a1)
{
  _DWORD *v1; // eax
  unsigned int v2; // ecx
  unsigned int v3; // edx
  bool v4; // dl
  int result; // eax
  int v6; // esi
  int v7; // edi
  int v8; // eax
  int v9; // esi
  __int64 v10; // rax
  _DWORD *v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // esi
  int v15; // edx
  int v16; // esi

  v1 = (_DWORD *)a1[22];
  v2 = v1[4];
  v3 = v1[3];
  if ( v2 > v3 )
  {
    if ( (int)a1[26] <= 0 )
      v4 = IO_new_do_write((int)a1, a1[4], a1[5] - a1[4]) != 0;
    else
      v4 = IO_wdo_write(a1, v3, (int)(v2 - v3) >> 2) != 0;
    result = -1;
    if ( v4 )
      return result;
    v1 = (_DWORD *)a1[22];
  }
  v6 = (*v1 - v1[1]) >> 2;
  if ( !v6 )
  {
LABEL_7:
    a1[19] = -1;
    result = 0;
    a1[20] = -1;
    return result;
  }
  v7 = a1[21];
  v8 = (*(int (__cdecl **)(int))(v7 + 16))(v7);
  if ( v8 <= 0 )
  {
    v11 = (_DWORD *)a1[22];
    v12 = v11[14];
    v11[11] = v11[13];
    v11[12] = v12;
    v13 = (*(int (__cdecl **)(int, int, _DWORD, _DWORD, int))(v7 + 24))(v7, a1[22] + 44, a1[3], a1[2], v6);
    v14 = a1[3];
    v15 = v14 + v13;
    v16 = v14 - a1[2];
    a1[1] = v15;
    v9 = v13 + v16;
  }
  else
  {
    v9 = v8 * v6;
  }
  v10 = ((__int64 (__cdecl *)(_DWORD *, int, int, int))*(_DWORD *)(a1[37] + 64))(a1, v9, v9 >> 31, 1);
  if ( (HIDWORD(v10) & (unsigned int)v10) != -1 )
  {
    *(_DWORD *)(a1[22] + 4) = *(_DWORD *)a1[22];
    a1[2] = a1[1];
    goto LABEL_7;
  }
  result = -1;
  if ( __readgsdword(0xFFFFFFE8) == 29 )
    goto LABEL_7;
  return result;
}

//----- (080696E0) --------------------------------------------------------
int __cdecl IO_wfile_overflow(int *a1, int a2)
{
  int v2; // esi
  int v3; // eax
  int *v5; // edx
  int v6; // ecx
  int v7; // edi
  int v8; // edi
  int v9; // edi
  int v10; // edi
  int *v11; // eax
  int *v12; // edx
  int v13; // ecx
  _DWORD *v14; // edx
  bool v15; // al
  bool v16; // al
  int v17; // ecx
  int v18; // eax
  int v19; // eax

  v2 = a2;
  v3 = *a1;
  if ( (*a1 & 8) != 0 )
  {
    v2 = -1;
    *a1 = v3 | 0x20;
    __writegsdword(0xFFFFFFE8, 9u);
  }
  else
  {
    if ( (v3 & 0x800) == 0 )
    {
      v5 = (int *)a1[22];
      if ( v5[3] )
      {
        v6 = *v5;
        v7 = v5[7];
        if ( *v5 == v7 )
        {
          v17 = a1[7];
          a1[1] = v17;
          a1[2] = v17;
          v6 = v5[6];
          *v5 = v6;
          v5[1] = v6;
        }
      }
      else
      {
        IO_wdoallocbuf((int)a1);
        v5 = (int *)a1[22];
        v18 = a1[4];
        v6 = v5[6];
        v5[2] = v6;
        *v5 = v6;
        v5[1] = v6;
        if ( !v18 )
        {
          IO_doallocbuf((int)a1);
          v19 = a1[7];
          v5 = (int *)a1[22];
          a1[1] = v19;
          a1[2] = v19;
          v6 = *v5;
        }
        v7 = v5[7];
        v3 = *a1;
      }
      v5[5] = v7;
      v8 = v5[1];
      BYTE1(v3) |= 8u;
      v5[4] = v6;
      v5[3] = v6;
      *v5 = v8;
      v5[2] = v8;
      v9 = a1[1];
      *a1 = v3;
      a1[5] = v9;
      a1[4] = v9;
      a1[6] = a1[8];
      v10 = a1[2];
      a1[1] = v10;
      a1[3] = v10;
      if ( (v3 & 0x202) != 0 )
        v5[5] = v6;
    }
    if ( a2 == -1 )
    {
      if ( a1[26] <= 0 )
        return IO_new_do_write((int)a1, a1[4], a1[5] - a1[4]);
      else
        return IO_wdo_write(a1, *(_DWORD *)(a1[22] + 12), (*(_DWORD *)(a1[22] + 16) - *(_DWORD *)(a1[22] + 12)) >> 2);
    }
    else
    {
      v11 = (int *)a1[22];
      v12 = (int *)v11[4];
      if ( v12 == (int *)v11[7] )
      {
        if ( a1[26] <= 0 )
          v16 = IO_new_do_write((int)a1, a1[4], a1[5] - a1[4]) == -1;
        else
          v16 = IO_wdo_write(a1, v11[3], ((int)v12 - v11[3]) >> 2) == -1;
        if ( v16 )
          return -1;
        v11 = (int *)a1[22];
        v12 = (int *)v11[4];
      }
      *v12 = a2;
      v13 = *a1;
      v14 = v12 + 1;
      v11[4] = (int)v14;
      if ( (v13 & 2) != 0 || a2 == 10 && (v13 & 0x200) != 0 )
      {
        if ( a1[26] <= 0 )
          v15 = IO_new_do_write((int)a1, a1[4], a1[5] - a1[4]) == -1;
        else
          v15 = IO_wdo_write(a1, v11[3], ((int)v14 - v11[3]) >> 2) == -1;
        if ( v15 )
          return -1;
      }
    }
  }
  return v2;
}

//----- (08069922) --------------------------------------------------------
void __usercall L_lock_752(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x8068CB4);
}
// 8069929: control flows out of bounds to 8068CB4

//----- (0806992E) --------------------------------------------------------
void __fastcall L_unlock_1161(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x8068F97);
}
// 8069935: control flows out of bounds to 8068F97

//----- (0806993A) --------------------------------------------------------
#error "8069140: call analysis failed (funcsize=5)"

//----- (08069950) --------------------------------------------------------
int __cdecl IO_file_seekoff_maybe_mmap(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // edx

  result = (*(int (__cdecl **)(_DWORD *, int, int, int))(a1[37] + 64))(a1, a2, a3, a4);
  if ( v5 < 0 )
    return -1;
  a1[19] = result;
  a1[20] = v5;
  return result;
}
// 8069989: variable 'v5' is possibly undefined

//----- (080699C0) --------------------------------------------------------
int __cdecl IO_file_sync_mmap(_DWORD *a1)
{
  int v1; // esi
  __int64 v2; // rax
  int v3; // ecx
  int v4; // esi
  int v5; // edi
  int v6; // eax

  v1 = a1[1];
  if ( v1 == a1[2] )
  {
    v4 = v1 - a1[7];
    v5 = v4 >> 31;
  }
  else
  {
    v2 = lseek64(a1[14], v1 - a1[7], (v1 - a1[7]) >> 31);
    v3 = a1[1] - a1[7];
    v4 = v3;
    v5 = v3 >> 31;
    if ( v3 != v2 )
    {
      *a1 |= 0x20u;
      return -1;
    }
  }
  v6 = a1[3];
  a1[19] = v4;
  a1[20] = v5;
  a1[1] = v6;
  a1[2] = v6;
  return 0;
}

//----- (08069A60) --------------------------------------------------------
__int64 __cdecl IO_file_seek(int a1, int a2, int a3)
{
  return lseek64(*(_DWORD *)(a1 + 56), a2, a3);
}

//----- (08069A70) --------------------------------------------------------
int __usercall decide_maybe_mmap@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v2; // eax
  int result; // eax
  int v4; // esi
  __int64 v5; // rax
  int v6; // eax
  int v7; // ecx
  int v8; // esi
  int v9; // eax
  void *v10; // eax
  char v11[16]; // [esp+20h] [ebp-6Ch] BYREF
  int v12; // [esp+30h] [ebp-5Ch]
  __int64 v13; // [esp+4Ch] [ebp-40h]

  if ( (*(int (__cdecl **)(_DWORD *, char *))(a1[37] + 72))(a1, v11)
    || (v12 & 0xF000) != 0x8000
    || !v13
    || v13 > 0xFFFFF
    || (a1[20] & a1[19]) != -1 && v13 < *(_QWORD *)(a1 + 19) )
  {
    goto LABEL_3;
  }
  v4 = mmap64(0, v13, 1, 1, a1[14], 0LL);
  if ( v4 == -1 )
    goto LABEL_3;
  v5 = lseek64(a1[14], v13, SHIDWORD(v13));
  if ( v13 != v5 )
  {
    munmap(v4, v13);
    a1[19] = -1;
    a1[20] = -1;
LABEL_3:
    v2 = &IO_file_jumps;
    if ( (int)a1[26] > 0 )
      v2 = IO_wfile_jumps;
    a1[37] = v2;
    result = a1[22];
    *(_DWORD *)(result + 184) = IO_wfile_jumps;
    return result;
  }
  IO_setb((int)a1, v4, v4 + v5, 0);
  if ( (a1[20] & a1[19]) == -1 )
  {
    a1[19] = 0;
    a1[20] = 0;
  }
  v6 = a1[19];
  a1[3] = v4;
  v7 = a1[26];
  a1[1] = v4 + v6;
  v8 = v13 + v4;
  a1[19] = v13;
  v9 = HIDWORD(v13);
  a1[2] = v8;
  a1[20] = v9;
  v10 = &IO_file_jumps_mmap;
  if ( v7 > 0 )
    v10 = &IO_wfile_jumps_mmap;
  a1[37] = v10;
  result = a1[22];
  *(_DWORD *)(result + 184) = &IO_wfile_jumps_mmap;
  return result;
}
// 80CA1E0: using guessed type _DWORD IO_wfile_jumps[21];
// 8069A70: using guessed type char var_6C[16];

//----- (08069C40) --------------------------------------------------------
int __cdecl IO_file_xsgetn_maybe_mmap(_DWORD *a1, int a2, int a3)
{
  decide_maybe_mmap(a1);
  return (*(int (__cdecl **)(_DWORD *, int, int))(a1[37] + 32))(a1, a2, a3);
}

//----- (08069C90) --------------------------------------------------------
int __cdecl IO_file_underflow_maybe_mmap(_DWORD *a1)
{
  decide_maybe_mmap(a1);
  return (*(int (__cdecl **)(_DWORD *))(a1[37] + 16))(a1);
}

//----- (08069CC0) --------------------------------------------------------
int __usercall mmap_remap_check@<eax>(int a1@<eax>)
{
  int v2; // esi
  _DWORD *v3; // eax
  int v4; // eax
  int result; // eax
  int v6; // esi
  int v7; // eax
  int v8; // ebp
  int v9; // ecx
  unsigned int v10; // edx
  unsigned int v11; // eax
  unsigned int v12; // eax
  int v13; // esi
  int v14; // esi
  int v15; // eax
  __int64 v16; // rax
  int v17; // eax
  __int64 v18; // rax
  __int64 v19; // [esp+10h] [ebp-8Ch]
  int v20; // [esp+18h] [ebp-84h]
  int v21; // [esp+18h] [ebp-84h]
  char v22[16]; // [esp+20h] [ebp-7Ch] BYREF
  int v23; // [esp+30h] [ebp-6Ch]
  __int64 v24; // [esp+4Ch] [ebp-50h]

  if ( (*(int (__cdecl **)(int, char *))(*(_DWORD *)(a1 + 148) + 72))(a1, v22) )
    goto LABEL_3;
  if ( (v23 & 0xF000) != 0x8000 )
    goto LABEL_3;
  v6 = v24;
  if ( !v24 || v24 > 0xFFFFF )
    goto LABEL_3;
  v7 = getpagesize();
  v8 = *(_DWORD *)(a1 + 28);
  v9 = v7;
  v20 = -v7;
  v10 = (v6 + v7 - 1) & -v7;
  v11 = -v7 & (v7 + *(_DWORD *)(a1 + 32) + ~v8);
  if ( v10 < v11 )
  {
    munmap(v8 + (v20 & (v9 + v6 - 1)), v11 - (v20 & (v9 + v6 - 1)));
    v8 = *(_DWORD *)(a1 + 28);
    v14 = v8 + v24;
    *(_DWORD *)(a1 + 32) = v8 + v24;
LABEL_12:
    v15 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 12) = v8;
    v19 = v15;
    v16 = *(_QWORD *)(a1 + 76);
    v21 = v16 - v19;
    *(_QWORD *)(a1 + 76) = v16 - v19;
    if ( v16 - v19 >= v14 - v8 )
    {
      *(_DWORD *)(a1 + 4) = v14;
      result = 0;
      *(_DWORD *)(a1 + 8) = v14;
    }
    else
    {
      v17 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(a1 + 8) = v14;
      *(_DWORD *)(a1 + 4) = v21 + v8;
      v18 = lseek64(v17, v14 - v8, (v14 - v8) >> 31);
      if ( *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28) == v18 )
        *(_QWORD *)(a1 + 76) = v18;
      else
        *(_DWORD *)a1 |= 0x20u;
      return 0;
    }
    return result;
  }
  if ( v10 <= v11 )
  {
    v14 = v8 + v6;
    *(_DWORD *)(a1 + 32) = v14;
    goto LABEL_12;
  }
  v12 = mremap(v8, v11);
  v8 = v12;
  if ( v12 != -1 )
  {
    v13 = v24;
    *(_DWORD *)(a1 + 28) = v12;
    v14 = v12 + v13;
    *(_DWORD *)(a1 + 32) = v14;
    goto LABEL_12;
  }
LABEL_3:
  munmap(*(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28));
  v2 = *(_DWORD *)(a1 + 104);
  v3 = &IO_file_jumps;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  if ( v2 > 0 )
    v3 = IO_wfile_jumps;
  *(_DWORD *)(a1 + 148) = v3;
  v4 = *(_DWORD *)(a1 + 88);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(v4 + 184) = IO_wfile_jumps;
  return 1;
}
// 80CA1E0: using guessed type _DWORD IO_wfile_jumps[21];
// 8069CC0: using guessed type char var_7C[16];

//----- (08069F30) --------------------------------------------------------
int __cdecl IO_file_xsgetn_mmap(_DWORD *a1, char *a2, unsigned int a3)
{
  unsigned int v3; // ecx
  _BYTE *v4; // edx
  char *v5; // ebp
  unsigned int v6; // ebx
  int v7; // eax
  char *v9; // eax
  unsigned int v10; // [esp+1Ch] [ebp-20h]
  _BYTE *v11; // [esp+1Ch] [ebp-20h]

  v3 = a3;
  v4 = (_BYTE *)a1[1];
  v5 = a2;
  v6 = a1[2] - (_DWORD)v4;
  if ( v6 >= a3 )
    goto LABEL_7;
  if ( (*a1 & 0x100) != 0 )
  {
    v5 = (char *)mempcpy(a2, (_BYTE *)a1[1], v6);
    IO_switch_to_main_get_area(a1);
    v4 = (_BYTE *)a1[1];
    v3 = a3 - v6;
    v6 = a1[2] - (_DWORD)v4;
    if ( v3 <= v6 )
      goto LABEL_7;
  }
  else
  {
    v5 = a2;
  }
  v10 = v3;
  v7 = mmap_remap_check((int)a1);
  v3 = v10;
  if ( v7 )
    return v5 - a2 + (*(int (__cdecl **)(_DWORD *, char *, unsigned int))(a1[37] + 32))(a1, a2, v10);
  v4 = (_BYTE *)a1[1];
  v6 = a1[2] - (_DWORD)v4;
  if ( v10 > v6 )
    *a1 |= 0x10u;
LABEL_7:
  if ( v6 )
  {
    if ( v3 <= v6 )
      v6 = v3;
    v11 = v4;
    v9 = (char *)mempcpy(v5, v4, v6);
    a1[1] = &v11[v6];
    v5 = v9;
  }
  return v5 - a2;
}

//----- (0806A030) --------------------------------------------------------
unsigned int __usercall IO_file_xsgetn@<eax>(long double a1@<st0>, int a2, _BYTE *a3, unsigned int a4)
{
  unsigned int v4; // esi
  _BYTE *v5; // eax
  unsigned int v7; // edx
  int v8; // eax
  unsigned int v9; // eax
  int v10; // eax
  _WORD *v12; // eax
  unsigned int v13; // [esp+14h] [ebp-28h]
  unsigned int v14; // [esp+18h] [ebp-24h]
  __int64 v15; // [esp+18h] [ebp-24h]

  if ( !*(_DWORD *)(a2 + 28) )
  {
    if ( *(_DWORD *)(a2 + 36) )
    {
      free(a1, *(_DWORD *)(a2 + 36));
      *(_DWORD *)a2 &= ~0x100u;
    }
    IO_doallocbuf(a2);
  }
  v4 = 0;
  if ( !a4 )
    return a4 - v4;
  v5 = *(_BYTE **)(a2 + 4);
  v4 = a4;
  v7 = *(_DWORD *)(a2 + 8) - (_DWORD)v5;
  if ( v7 < a4 )
  {
    do
    {
      if ( v7 )
      {
        v13 = v7;
        v12 = mempcpy(a3, v5, v7);
        *(_DWORD *)(a2 + 4) += v13;
        v4 -= v13;
        a3 = v12;
      }
      if ( (*(_DWORD *)a2 & 0x100) != 0 )
      {
        IO_switch_to_main_get_area((_DWORD *)a2);
        goto LABEL_14;
      }
      v8 = *(_DWORD *)(a2 + 28);
      if ( v8 )
      {
        v14 = *(_DWORD *)(a2 + 32) - v8;
        if ( v4 < v14 )
        {
          if ( _underflow((int *)a2) == -1 )
            return a4 - v4;
          goto LABEL_14;
        }
        *(_DWORD *)(a2 + 12) = v8;
        *(_DWORD *)(a2 + 4) = v8;
        *(_DWORD *)(a2 + 8) = v8;
        *(_DWORD *)(a2 + 20) = v8;
        *(_DWORD *)(a2 + 16) = v8;
        *(_DWORD *)(a2 + 24) = v8;
        v9 = v4;
        if ( v14 > 0x7F )
          v9 = v4 - v4 % v14;
      }
      else
      {
        *(_DWORD *)(a2 + 12) = 0;
        v9 = v4;
        *(_DWORD *)(a2 + 4) = 0;
        *(_DWORD *)(a2 + 8) = 0;
        *(_DWORD *)(a2 + 20) = 0;
        *(_DWORD *)(a2 + 16) = 0;
        *(_DWORD *)(a2 + 24) = 0;
      }
      v10 = (*(int (__cdecl **)(int, _BYTE *, unsigned int))(*(_DWORD *)(a2 + 148) + 56))(a2, a3, v9);
      if ( v10 <= 0 )
      {
        if ( v10 )
          *(_DWORD *)a2 |= 0x20u;
        else
          *(_DWORD *)a2 |= 0x10u;
        return a4 - v4;
      }
      a3 += v10;
      v4 -= v10;
      v15 = *(_QWORD *)(a2 + 76);
      if ( (HIDWORD(v15) & (unsigned int)v15) != -1 )
        *(_QWORD *)(a2 + 76) = v15 + v10;
LABEL_14:
      if ( !v4 )
        return a4 - v4;
      v5 = *(_BYTE **)(a2 + 4);
      v7 = *(_DWORD *)(a2 + 8) - (_DWORD)v5;
    }
    while ( v7 < v4 );
  }
  memcpy(a3, v5, v4);
  *(_DWORD *)(a2 + 4) += v4;
  v4 = 0;
  return a4 - v4;
}

//----- (0806A210) --------------------------------------------------------
int __usercall new_do_write@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)
{
  int v5; // edi
  unsigned __int16 v6; // ax
  int v7; // ebp
  int v8; // eax
  int v10; // eax
  int v11; // edx
  __int64 v12; // rax
  int v13; // [esp+1Ch] [ebp-20h]

  if ( (*(_DWORD *)a1 & 0x1000) != 0 )
  {
    *(_DWORD *)(a1 + 76) = -1;
    *(_DWORD *)(a1 + 80) = -1;
  }
  else
  {
    v10 = *(_DWORD *)(a1 + 8);
    v11 = *(_DWORD *)(a1 + 16);
    if ( v10 != v11 )
    {
      v13 = a3;
      v12 = ((__int64 (__cdecl *)(int, int, int, int))*(_DWORD *)(*(_DWORD *)(a1 + 148) + 64))(
              a1,
              v11 - v10,
              (v11 - v10) >> 31,
              1);
      v5 = 0;
      a3 = v13;
      if ( (HIDWORD(v12) & (unsigned int)v12) == -1 )
        return v5;
      *(_QWORD *)(a1 + 76) = v12;
    }
  }
  v5 = (*(int (__cdecl **)(int, unsigned int, int))(*(_DWORD *)(a1 + 148) + 60))(a1, a2, a3);
  v6 = *(_WORD *)(a1 + 68);
  if ( v5 && v6 )
    *(_WORD *)(a1 + 68) = IO_adjust_column(v6 - 1, a2, v5) + 1;
  v7 = *(_DWORD *)(a1 + 104);
  v8 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 12) = v8;
  *(_DWORD *)(a1 + 4) = v8;
  *(_DWORD *)(a1 + 8) = v8;
  *(_DWORD *)(a1 + 20) = v8;
  *(_DWORD *)(a1 + 16) = v8;
  if ( v7 > 0 || (*(_DWORD *)a1 & 0x202) == 0 )
    v8 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 24) = v8;
  return v5;
}

//----- (0806A330) --------------------------------------------------------
int __cdecl IO_new_file_write(int a1, int a2, int a3)
{
  int result; // eax
  int v5; // edi
  int v6; // eax
  int v7; // [esp+0h] [ebp-2Ch]

  result = 0;
  if ( a3 > 0 )
  {
    v5 = a3;
    do
    {
      v7 = *(_DWORD *)(a1 + 56);
      if ( (*(_BYTE *)(a1 + 60) & 2) != 0 )
        v6 = _write_nocancel(v7, a2);
      else
        v6 = write(a3, v7, a2, v5);
      if ( v6 < 0 )
      {
        *(_DWORD *)a1 |= 0x20u;
        result = a3 - v5;
        goto LABEL_8;
      }
      v5 -= v6;
      a2 += v6;
    }
    while ( v5 > 0 );
    result = a3 - v5;
  }
LABEL_8:
  if ( *(int *)(a1 + 80) >= 0 )
    *(_QWORD *)(a1 + 76) += result;
  return result;
}

//----- (0806A3B0) --------------------------------------------------------
unsigned int __fastcall IO_file_close(int a1)
{
  return _close_nocancel(a1);
}

//----- (0806A3C0) --------------------------------------------------------
unsigned int __cdecl IO_file_close_mmap(int a1)
{
  int v1; // ecx

  munmap(*(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28));
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  return _close_nocancel(v1);
}
// 806A3F5: variable 'v1' is possibly undefined

//----- (0806A400) --------------------------------------------------------
unsigned int __cdecl IO_file_stat(int a1, int a2)
{
  return _fxstat64(3, *(_DWORD *)(a1 + 56), a2);
}

//----- (0806A430) --------------------------------------------------------
int __usercall IO_new_file_seekoff@<eax>(long double a1@<st0>, int *a2, __int64 a3, int a4, int a5)
{
  unsigned int v6; // edx
  int v7; // esi
  int v8; // ecx
  int v9; // esi
  int result; // eax
  int v11; // eax
  int v12; // edi
  __int64 v13; // rax
  int v14; // ecx
  int v15; // ebp
  unsigned int v16; // esi
  int v17; // ebp
  int v18; // edi
  __int64 v19; // kr00_8
  int v20; // edx
  int v21; // eax
  int v22; // eax
  int v23; // ecx
  __int64 v24; // rax
  int v25; // eax
  int v26; // [esp+10h] [ebp-9Ch]
  __int64 v28; // [esp+20h] [ebp-8Ch]
  __int64 v29; // [esp+20h] [ebp-8Ch]
  int v30; // [esp+28h] [ebp-84h]
  __int64 v31; // [esp+28h] [ebp-84h]
  char v32[16]; // [esp+30h] [ebp-7Ch] BYREF
  int v33; // [esp+40h] [ebp-6Ch]
  __int64 v34; // [esp+5Ch] [ebp-50h]

  v6 = a2[5];
  if ( *(_QWORD *)(a2 + 3) == __PAIR64__(v6, a2[2]) )
  {
    v6 = a2[4];
    v30 = 1;
  }
  else
  {
    v30 = 0;
  }
  if ( !a5 )
  {
    a4 = 1;
    a3 = 0LL;
  }
  if ( v6 > a2[4] || (*a2 & 0x800) != 0 )
  {
    v7 = -1;
    if ( IO_switch_to_get_mode(a2) )
      return v7;
    if ( a2[7] )
    {
LABEL_8:
      if ( a4 != 1 )
        goto LABEL_9;
LABEL_24:
      v7 = a2[19];
      v12 = a2[20];
      a3 -= a2[2] - a2[1];
      if ( (v12 & v7) == -1 )
      {
        if ( a5 )
          goto LABEL_28;
        v24 = ((__int64 (__cdecl *)(int *, _DWORD, _DWORD, int))*(_DWORD *)(a2[37] + 64))(a2, 0, 0, 1);
        v12 = HIDWORD(v24);
        v7 = v24;
        if ( (HIDWORD(v24) & (unsigned int)v24) == -1 )
          return v7;
        *(_QWORD *)(a2 + 19) = v24;
      }
      a3 += __PAIR64__(v12, v7);
      if ( a3 < 0 )
      {
        v7 = -1;
        __writegsdword(0xFFFFFFE8, 0x16u);
        return v7;
      }
      a4 = 0;
      goto LABEL_10;
    }
  }
  else if ( a2[7] )
  {
    goto LABEL_8;
  }
  if ( a2[3] )
  {
    free(a1, a2[3]);
    *a2 &= ~0x100u;
  }
  IO_doallocbuf((int)a2);
  v11 = a2[7];
  a2[5] = v11;
  a2[4] = v11;
  a2[6] = v11;
  a2[3] = v11;
  a2[1] = v11;
  a2[2] = v11;
  if ( a4 == 1 )
    goto LABEL_24;
LABEL_9:
  if ( a4 == 2 )
  {
    if ( (*(int (__cdecl **)(int *, char *))(a2[37] + 72))(a2, v32) || (v33 & 0xF000) != 0x8000 )
      goto LABEL_28;
    a3 += v34;
    a4 = 0;
  }
LABEL_10:
  v7 = a3;
  if ( !a5 )
    return v7;
  v28 = *(_QWORD *)(a2 + 19);
  if ( (HIDWORD(v28) & (unsigned int)v28) == -1 )
  {
    v8 = *a2;
  }
  else
  {
    v8 = *a2;
    if ( a2[3] )
    {
      if ( (v8 & 0x100) == 0 )
      {
        v9 = a2[7];
        v26 = v28 - (a2[2] - v9);
        if ( a3 >= v28 - (a2[2] - v9) && a3 < v28 )
        {
          a2[3] = v9;
          a2[5] = v9;
          a2[1] = v9 + a3 - v26;
          a2[4] = v9;
          a2[6] = v9;
          v7 = a3;
          *a2 = v8 & 0xFFFFFFEF;
          if ( v28 >= 0 )
            (*(void (__cdecl **)(int *, _DWORD, _DWORD, _DWORD))(a2[37] + 64))(a2, v28, HIDWORD(v28), 0);
          return v7;
        }
      }
    }
  }
  if ( (v8 & 4) != 0 )
  {
LABEL_28:
    IO_unsave_markers(a2);
    v13 = ((__int64 (__cdecl *)(int *, _DWORD, _DWORD, int))*(_DWORD *)(a2[37] + 64))(a2, a3, HIDWORD(a3), a4);
    v7 = v13;
    if ( (HIDWORD(v13) & (unsigned int)v13) != -1 )
    {
      LODWORD(v13) = a2[7];
      a2[20] = HIDWORD(v13);
      *a2 &= ~0x10u;
      a2[3] = v13;
      a2[1] = v13;
      a2[2] = v13;
      a2[5] = v13;
      a2[4] = v13;
      a2[6] = v13;
      result = v7;
      a2[19] = v7;
      return result;
    }
    return v7;
  }
  v14 = a2[8];
  v15 = a2[7] - v14;
  v16 = v15 & a3;
  v17 = v15 >> 31;
  v18 = v17 & HIDWORD(a3);
  v29 = a3 - __PAIR64__((unsigned int)v17 & HIDWORD(a3), v16);
  if ( (__int64)(a3 - __PAIR64__((unsigned int)v17 & HIDWORD(a3), v16)) > v14 - a2[7] )
  {
    v18 = HIDWORD(a3);
    v16 = a3;
    v29 = 0LL;
  }
  v19 = ((__int64 (__cdecl *)(int *, unsigned int, int, _DWORD))*(_DWORD *)(a2[37] + 64))(a2, v16, v18, 0);
  if ( v19 < 0 )
    return -1;
  if ( v29 )
  {
    if ( v30 )
    {
      v21 = v29;
      v20 = a2[7];
    }
    else
    {
      v20 = a2[7];
      v21 = a2[8] - v20;
    }
    v22 = (*(int (__cdecl **)(int *, int, int))(a2[37] + 56))(a2, v20, v21);
    v31 = v22;
    if ( v29 > v22 )
    {
      a4 = 1;
      a3 = v29;
      if ( v22 != -1 )
        a3 = v29 - v22;
      goto LABEL_28;
    }
    v23 = v22;
  }
  else
  {
    v31 = 0LL;
    v23 = 0;
  }
  v25 = a2[7];
  a2[3] = v25;
  a2[1] = v25 + v29;
  *(_QWORD *)(a2 + 19) = v31 + v19;
  a2[2] = v25 + v23;
  a2[5] = v25;
  a2[4] = v25;
  a2[6] = v25;
  result = a3;
  *a2 &= ~0x10u;
  return result;
}
// 806A430: using guessed type char var_7C[16];

//----- (0806A980) --------------------------------------------------------
_DWORD *__cdecl IO_new_file_setbuf(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // ebx
  int v4; // eax

  v3 = a1;
  if ( !IO_default_setbuf(a1, a2, a3) )
    return 0;
  v4 = a1[7];
  a1[6] = v4;
  a1[5] = v4;
  a1[4] = v4;
  a1[3] = v4;
  a1[1] = v4;
  a1[2] = v4;
  return v3;
}

//----- (0806A9D0) --------------------------------------------------------
_DWORD *__cdecl IO_file_setbuf_mmap(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  _DWORD *result; // eax
  int v5; // edx

  v3 = a1[22];
  a1[37] = &IO_file_jumps;
  *(_DWORD *)(v3 + 184) = IO_wfile_jumps;
  result = IO_new_file_setbuf(a1, a2, a3);
  if ( !result )
  {
    v5 = a1[22];
    a1[37] = &IO_file_jumps_mmap;
    *(_DWORD *)(v5 + 184) = &IO_wfile_jumps_mmap;
  }
  return result;
}
// 80CA1E0: using guessed type _DWORD IO_wfile_jumps[21];

//----- (0806AA30) --------------------------------------------------------
int __cdecl IO_file_seekoff_mmap(_DWORD *a1, __int64 a2, int a3, int a4)
{
  int v4; // edi
  int v5; // esi
  __int64 v6; // rax
  int v7; // ebp
  int v9; // ebp
  int v10; // [esp+24h] [ebp-28h]

  v4 = HIDWORD(a2);
  v5 = a2;
  if ( !a4 )
    return a1[19] - (a1[2] - a1[1]);
  if ( a3 == 1 )
  {
    v4 = (unsigned __int64)(a1[1] - a1[3] + a2) >> 32;
    v5 = a1[1] - a1[3] + a2;
  }
  else if ( a3 == 2 )
  {
    v4 = (unsigned __int64)(a1[8] - a1[7] + a2) >> 32;
    v5 = a1[8] - a1[7] + a2;
  }
  if ( v4 < 0 )
  {
    v5 = -1;
    __writegsdword(0xFFFFFFE8, 0x16u);
  }
  else
  {
    v6 = ((__int64 (__cdecl *)(_DWORD *, int, int, _DWORD))*(_DWORD *)(a1[37] + 64))(a1, v5, v4, 0);
    if ( v6 < 0 )
    {
      return -1;
    }
    else
    {
      v7 = a1[7];
      v10 = a1[8];
      a1[3] = v7;
      if ( __SPAIR64__(v4, v5) > v10 - v7 )
      {
        a1[1] = v10;
        a1[2] = v10;
      }
      else
      {
        v9 = v5 + v7;
        a1[1] = v9;
        a1[2] = v9;
      }
      *a1 &= ~0x10u;
      *(_QWORD *)(a1 + 19) = v6;
    }
  }
  return v5;
}

//----- (0806AB80) --------------------------------------------------------
int __cdecl IO_file_underflow_mmap(_DWORD *a1)
{
  unsigned __int8 *v1; // eax

  v1 = (unsigned __int8 *)a1[1];
  if ( (unsigned int)v1 < a1[2] )
    return *v1;
  if ( mmap_remap_check((int)a1) )
    return (*(int (__cdecl **)(_DWORD *))(a1[37] + 16))(a1);
  v1 = (unsigned __int8 *)a1[1];
  if ( (unsigned int)v1 < a1[2] )
    return *v1;
  *a1 |= 0x10u;
  return -1;
}

//----- (0806ABD0) --------------------------------------------------------
int __cdecl IO_new_file_xsputn(_DWORD *a1, _BYTE *a2, unsigned int a3)
{
  int result; // eax
  unsigned int v4; // ebx
  unsigned int v5; // eax
  unsigned int v6; // ebp
  _BYTE *v7; // edx
  unsigned int v8; // ecx
  unsigned int v9; // eax
  unsigned int v10; // ebp
  int v11; // eax
  _BYTE *v12; // ecx
  _BYTE *v13; // ebp
  unsigned int v14; // eax
  unsigned int v15; // [esp+1Ch] [ebp-20h]
  int v16; // [esp+1Ch] [ebp-20h]

  result = 0;
  v4 = (unsigned int)a2;
  if ( !a3 )
    return result;
  if ( (*a1 & 0xA00) == 2560 )
  {
    v7 = (_BYTE *)a1[5];
    v16 = 0;
    v9 = a1[8] - (_DWORD)v7;
    if ( a3 <= v9 )
    {
      v12 = &a2[a3];
      if ( a2 >= &a2[a3] )
      {
LABEL_12:
        v10 = a3;
        if ( v9 <= a3 )
          v10 = v9;
        v11 = 0;
        if ( v10 > 0x14 )
        {
          v4 = (unsigned int)&a2[v10];
          a1[5] = mempcpy(v7, a2, v10);
        }
        else
        {
          do
          {
            v7[v11] = a2[v11];
            ++v11;
          }
          while ( v11 != v10 );
          v4 = (unsigned int)&a2[v10];
          a1[5] = &v7[v10];
        }
        v6 = a3 - v10;
LABEL_18:
        if ( !(v6 + v16) )
          return a3 - v6;
        goto LABEL_4;
      }
      v13 = v12 - 1;
      if ( *(v12 - 1) != 10 )
      {
        while ( v13 != a2 )
        {
          if ( *--v13 == 10 )
            goto LABEL_26;
        }
        v16 = 0;
        goto LABEL_12;
      }
LABEL_26:
      v9 = v13 - a2 + 1;
      v16 = 1;
    }
LABEL_11:
    v6 = a3;
    if ( !v9 )
      goto LABEL_18;
    goto LABEL_12;
  }
  v5 = a1[6];
  v6 = a3;
  v7 = (_BYTE *)a1[5];
  if ( v5 > (unsigned int)v7 )
  {
    v9 = v5 - (_DWORD)v7;
    v16 = 0;
    goto LABEL_11;
  }
LABEL_4:
  result = (*(int (__cdecl **)(_DWORD *, int))(a1[37] + 12))(a1, -1);
  if ( result != -1 )
  {
    v8 = 0;
    if ( (unsigned int)(a1[8] - a1[7]) > 0x7F )
      v8 = v6 % (a1[8] - a1[7]);
    v15 = v6 - v8;
    if ( v6 == v8 || (v14 = new_do_write((int)a1, v4, v6 - v8), v6 -= v14, v15 <= v14) )
    {
      if ( v6 )
        v6 -= IO_default_xsputn(a1, (unsigned __int8 *)(v15 + v4), v6);
    }
    return a3 - v6;
  }
  if ( v6 )
    return a3 - v6;
  return result;
}

//----- (0806ADA0) --------------------------------------------------------
int __usercall IO_file_read@<eax>(int a1@<ebp>, int a2, int a3)
{
  if ( (*(_BYTE *)(a2 + 60) & 2) != 0 )
    return _read_nocancel(*(_DWORD *)(a2 + 56), a3);
  else
    return read(a1, *(_DWORD *)(a2 + 56), a3);
}

//----- (0806ADE0) --------------------------------------------------------
void __cdecl IO_new_file_init(int *a1)
{
  *a1 |= 0x240Cu;
  a1[19] = -1;
  a1[20] = -1;
  IO_link_in(a1);
  a1[14] = -1;
}

//----- (0806AE10) --------------------------------------------------------
int __usercall IO_file_open@<eax>(int a1@<ebp>, int a2, int a3, int a4, int a5, __int16 a6, int a7)
{
  int v7; // ebx
  int v8; // esi
  int v9; // edx
  __int64 v11; // rax
  int v12; // ecx
  int v13; // [esp+4h] [ebp-28h]

  v7 = a2;
  v13 = a4 | (a7 == 0 ? 0x8000 : 0);
  if ( (*(_BYTE *)(a2 + 60) & 2) != 0 )
    v8 = _open_nocancel(a3, v13);
  else
    v8 = open(a1, a3, v13);
  if ( v8 < 0 )
    return 0;
  v9 = *(_DWORD *)a2;
  *(_DWORD *)(a2 + 56) = v8;
  *(_DWORD *)a2 = v9 & 0xFFFFEFF3 | a6 & 0x100C;
  if ( (a6 & 0x1004) == 4100
    && (v11 = ((__int64 (__cdecl *)(int, _DWORD, _DWORD, int, int))*(_DWORD *)(*(_DWORD *)(a2 + 148) + 36))(
                a2,
                0,
                0,
                2,
                3),
        (HIDWORD(v11) & (unsigned int)v11) == -1)
    && __readgsdword(0xFFFFFFE8) != 29 )
  {
    v7 = 0;
    _close_nocancel(v12);
  }
  else
  {
    IO_link_in((int *)a2);
  }
  return v7;
}
// 806AEEB: variable 'v12' is possibly undefined

//----- (0806AF10) --------------------------------------------------------
unsigned int *__cdecl IO_new_file_attach(unsigned int *a1, unsigned int a2)
{
  unsigned int *v2; // ebx
  unsigned int v3; // edi
  __int64 v4; // rax

  v2 = a1;
  if ( a1[14] != -1 )
    return 0;
  a1[19] = -1;
  a1[20] = -1;
  a1[14] = a2;
  v3 = __readgsdword(0xFFFFFFE8);
  *a1 = *a1 & 0xFFFFFFB3 | 0x40;
  v4 = ((__int64 (__cdecl *)(unsigned int *, _DWORD, _DWORD, int, int))*(_DWORD *)(a1[37] + 36))(a1, 0, 0, 1, 3);
  if ( (HIDWORD(v4) & (unsigned int)v4) == -1 && __readgsdword(0xFFFFFFE8) != 29 )
    return 0;
  __writegsdword(0xFFFFFFE8, v3);
  return v2;
}

//----- (0806AFB0) --------------------------------------------------------
int __cdecl IO_new_do_write(int a1, unsigned int a2, int a3)
{
  int result; // eax

  result = 0;
  if ( a3 )
    return (a3 == new_do_write(a1, a2, a3)) - 1;
  return result;
}

//----- (0806AFE0) --------------------------------------------------------
int __cdecl IO_new_file_sync(_DWORD *a1)
{
  unsigned int v1; // edx
  unsigned int v2; // eax
  bool v3; // dl
  int result; // eax
  int v5; // eax
  __int64 v6; // rax

  v1 = a1[5];
  v2 = a1[4];
  if ( v1 <= v2
    || ((int)a1[26] <= 0
      ? (v3 = IO_new_do_write((int)a1, v2, v1 - v2) != 0)
      : (v3 = IO_wdo_write(a1, *(_DWORD *)(a1[22] + 12), (*(_DWORD *)(a1[22] + 16) - *(_DWORD *)(a1[22] + 12)) >> 2) != 0),
        result = -1,
        !v3) )
  {
    v5 = a1[1] - a1[2];
    if ( !v5 )
    {
LABEL_6:
      a1[19] = -1;
      result = 0;
      a1[20] = -1;
      return result;
    }
    v6 = ((__int64 (__cdecl *)(_DWORD *, int, int, int))*(_DWORD *)(a1[37] + 64))(a1, v5, v5 >> 31, 1);
    if ( (HIDWORD(v6) & (unsigned int)v6) != -1 )
    {
      a1[2] = a1[1];
      goto LABEL_6;
    }
    result = -1;
    if ( __readgsdword(0xFFFFFFE8) == 29 )
      goto LABEL_6;
  }
  return result;
}

//----- (0806B0B0) --------------------------------------------------------
void __usercall IO_new_file_finish(long double a1@<st0>, int *a2)
{
  if ( a2[14] != -1 )
  {
    if ( a2[26] <= 0 )
      IO_new_do_write((int)a2, a2[4], a2[5] - a2[4]);
    else
      IO_wdo_write(a2, *(_DWORD *)(a2[22] + 12), (*(_DWORD *)(a2[22] + 16) - *(_DWORD *)(a2[22] + 12)) >> 2);
    if ( (*(_BYTE *)a2 & 0x40) == 0 )
      (*(void (__cdecl **)(int *))(a2[37] + 68))(a2);
  }
  IO_default_finish(a1, a2);
}

//----- (0806B130) --------------------------------------------------------
int __cdecl IO_new_file_close_it(int a1)
{
  int v1; // esi
  int v2; // edi
  _DWORD *v3; // eax

  if ( *(_DWORD *)(a1 + 56) == -1 )
    return -1;
  v1 = 0;
  if ( (*(_DWORD *)a1 & 0x808) == 2048 )
  {
    if ( *(int *)(a1 + 104) <= 0 )
      v1 = IO_new_do_write(a1, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16));
    else
      v1 = IO_wdo_write(
             (_DWORD *)a1,
             *(_DWORD *)(*(_DWORD *)(a1 + 88) + 12),
             (*(_DWORD *)(*(_DWORD *)(a1 + 88) + 16) - *(_DWORD *)(*(_DWORD *)(a1 + 88) + 12)) >> 2);
  }
  v2 = 0;
  IO_unsave_markers((int *)a1);
  if ( (*(_BYTE *)(a1 + 60) & 0x20) == 0 )
    v2 = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 148) + 68))(a1);
  if ( *(int *)(a1 + 104) > 0 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 88) + 32) )
      IO_free_wbackup_area((_DWORD *)a1);
    IO_wsetb(a1, 0, 0, 0);
    v3 = *(_DWORD **)(a1 + 88);
    v3[2] = 0;
    *v3 = 0;
    v3[1] = 0;
    v3[4] = 0;
    v3[3] = 0;
    v3[5] = 0;
  }
  IO_setb(a1, 0, 0, 0);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  IO_un_link((int *)a1);
  *(_DWORD *)a1 = -72539124;
  if ( !v2 )
    v2 = v1;
  *(_DWORD *)(a1 + 56) = -1;
  *(_DWORD *)(a1 + 76) = -1;
  *(_DWORD *)(a1 + 80) = -1;
  return v2;
}

//----- (0806B2C0) --------------------------------------------------------
int __cdecl IO_new_file_fopen(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  _BYTE *v4; // eax
  char v5; // dl
  __int16 v7; // si
  int v8; // ebx
  _BYTE *v9; // edi
  char v10; // dl
  char *v11; // eax
  _BYTE *v12; // ebx
  char *v13; // eax
  void *v14; // esp
  _WORD *v15; // eax
  _BYTE *v16; // edx
  char v17; // al
  _BYTE *v18; // ecx
  char *v19; // edx
  _BYTE *v20; // eax
  int v21; // edx
  int v22; // ecx
  int v23; // edx
  int v24; // eax
  int v25; // esi
  int v26; // ebx
  int v27; // edx
  _DWORD *v28; // eax
  int v29; // edx
  int v30; // eax
  _DWORD *v31; // edx
  int v32; // eax
  int v33; // ecx
  int v34; // eax
  int v35; // eax
  int v36; // [esp+0h] [ebp-68h] BYREF
  _BYTE v37[12]; // [esp+20h] [ebp-48h] BYREF
  int *v38; // [esp+2Ch] [ebp-3Ch]
  char *v39; // [esp+30h] [ebp-38h]
  int v40; // [esp+34h] [ebp-34h]
  int v41; // [esp+38h] [ebp-30h]
  int v42; // [esp+3Ch] [ebp-2Ch]
  int v43; // [esp+40h] [ebp-28h] BYREF
  int v44; // [esp+44h] [ebp-24h]
  int v45; // [esp+48h] [ebp-20h]
  int v46; // [esp+4Ch] [ebp-1Ch]
  int savedregs; // [esp+68h] [ebp+0h] BYREF

  v4 = a3;
  if ( a1[14] != -1 )
  {
    v41 = 0;
    return 0;
  }
  v5 = *a3;
  if ( *a3 == 114 )
  {
    v7 = 8;
    v8 = 0;
    v42 = 0;
  }
  else if ( v5 == 119 )
  {
    v7 = 4;
    v8 = 576;
    v42 = 1;
  }
  else
  {
    if ( v5 != 97 )
    {
      v41 = 0;
      __writegsdword(0xFFFFFFE8, 0x16u);
      return v41;
    }
    v7 = 4100;
    v8 = 1088;
    v42 = 1;
  }
  v9 = a3;
  do
  {
    v10 = *++v4;
    if ( *v4 == 101 )
    {
      v8 |= 0x80000u;
      a1[15] |= 0x40u;
    }
    else if ( v10 > 101 )
    {
      if ( v10 != 109 )
      {
        if ( v10 != 120 )
          continue;
        LOBYTE(v8) = v8 | 0x80;
LABEL_45:
        v9 = v4;
        continue;
      }
      a1[15] |= 1u;
    }
    else
    {
      if ( v10 == 98 )
        goto LABEL_45;
      if ( v10 > 98 )
      {
        if ( v10 == 99 )
          a1[15] |= 2u;
      }
      else
      {
        if ( !v10 )
          break;
        if ( v10 == 43 )
        {
          v7 &= 0x1000u;
          v9 = v4;
          v42 = 2;
        }
      }
    }
  }
  while ( v4 != a3 + 6 );
  v41 = IO_file_open((int)&savedregs, (int)a1, a2, v42 | v8, 438, v7, a4);
  if ( !v41 )
    return v41;
  v11 = strstr(v9 + 1, ",ccs=");
  v39 = v11;
  if ( !v11 )
    return v41;
  v12 = v11 + 5;
  v38 = &v36;
  v13 = (char *)((char *)strchrnul((unsigned int *)(v11 + 5), 44) - (v11 + 5));
  v14 = alloca((int)(v13 + 18));
  v42 = (int)v37;
  v15 = mempcpy(v37, v12, (unsigned int)v13);
  v16 = (_BYTE *)v42;
  *(_BYTE *)v15 = 0;
  v17 = *v16;
  if ( *v16 )
  {
    v18 = (_BYTE *)v42;
    v40 = 0;
    v19 = (char *)v42;
    do
    {
      while ( (byte_80D0CC0[2 * v17] & 8) != 0 || v17 == 95 || v17 == 45 || v17 == 46 || v17 == 44 || v17 == 58 )
      {
        ++v19;
        *v18 = dword_80D03C0[v17];
        v17 = *v19;
        ++v18;
        if ( !*v19 )
          goto LABEL_31;
      }
      if ( v17 == 47 )
      {
        if ( ++v40 == 3 )
        {
          v20 = v18;
          goto LABEL_35;
        }
        *v18++ = 47;
      }
      v17 = *++v19;
    }
    while ( *v19 );
LABEL_31:
    v20 = v18;
    if ( v40 > 1 )
      goto LABEL_35;
    v21 = v40 + 1;
  }
  else
  {
    v18 = v16;
    v21 = 1;
  }
  v20 = v18;
  v22 = v21 - 1 - (_DWORD)v18;
  do
    *v20++ = 47;
  while ( (int)&v20[v22] <= 1 );
LABEL_35:
  v23 = v42;
  *v20 = 0;
  if ( !*(_BYTE *)(v23 + 2) )
  {
    v24 = 0;
    v25 = v23;
    v26 = (int)v39;
    do
    {
      v27 = dword_80D03C0[*(char *)(v26 + v24 + 5)];
      *(_BYTE *)(v25 + v24++) = v27;
    }
    while ( (_BYTE)v27 );
  }
  if ( _wcsmbs_named_conv(&v43, v42) )
  {
    IO_new_file_close_it((int)a1);
    __writegsdword(0xFFFFFFE8, 0x16u);
    return 0;
  }
  if ( v44 != 1 )
    _assert_fail("fcts.towc_nsteps == 1", 135045345, 383, "_IO_new_file_fopen");
  if ( v46 != 1 )
    _assert_fail("fcts.tomb_nsteps == 1", 135045345, 384, "_IO_new_file_fopen");
  v28 = (_DWORD *)a1[22];
  v29 = v28[1];
  v28[11] = 0;
  v28[12] = 0;
  *v28 = v29;
  v28[4] = v28[3];
  v30 = a1[22];
  *(_DWORD *)(v30 + 52) = 0;
  *(_DWORD *)(v30 + 56) = 0;
  v31 = (_DWORD *)a1[22];
  a1[21] = v31 + 15;
  qmemcpy(v31 + 15, &_libio_codecvt, 0x78u);
  v31[28] = 0;
  v31[29] = 1;
  v32 = v44;
  v33 = v41;
  v31[27] = 1;
  v31[23] = v32;
  v31[24] = v43;
  v34 = *(_DWORD *)(v33 + 88);
  v31[33] = 0;
  v31[39] = 0;
  v31[40] = 1;
  v31[30] = v34 + 44;
  v31[34] = v46;
  v31[35] = v45;
  v31[38] = 1;
  v35 = *(_DWORD *)(v33 + 88);
  v31[44] = &_libio_translit;
  v31[41] = v35 + 44;
  a1[37] = *(_DWORD *)(a1[22] + 184);
  *(_DWORD *)(v33 + 104) = 1;
  return v41;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80D03C0: using guessed type _DWORD dword_80D03C0[256];
// 80D0CC0: using guessed type _BYTE byte_80D0CC0[512];
// 80DDEA0: using guessed type int (__cdecl *_libio_translit)(int, int, int, int, int, int, int, int);

//----- (0806B720) --------------------------------------------------------
void __usercall IO_new_file_underflow(long double a1@<st0>, int *a2)
{
  int v2; // eax
  _DWORD *v3; // esi
  int v4; // edx
  int *v5; // ecx
  unsigned int v7; // edi
  bool v9; // zf
  _DWORD *v10; // edx
  int v11; // eax
  int v12; // edx
  int v13; // ecx
  int v14; // eax
  int v15; // esi
  int v16; // edi

  v2 = *a2;
  if ( (*a2 & 4) != 0 )
  {
    *a2 = v2 | 0x20;
    __writegsdword(0xFFFFFFE8, 9u);
    return;
  }
  if ( a2[1] >= (unsigned int)a2[2] )
  {
    if ( !a2[7] )
    {
      if ( a2[9] )
      {
        free(a1, a2[9]);
        *a2 &= ~0x100u;
      }
      IO_doallocbuf((int)a2);
      v2 = *a2;
    }
    if ( (v2 & 0x202) == 0 )
      goto LABEL_19;
    v3 = stdout;
    v4 = *(_DWORD *)stdout;
    v5 = (int *)stdout;
    if ( (*(_DWORD *)stdout & 0x8000) == 0 )
    {
      _EDX = *((_DWORD *)stdout + 18);
      v7 = __readgsdword(8u);
      if ( v7 != *(_DWORD *)(_EDX + 8) )
      {
        _ECX = 1;
        v9 = __readgsdword(0xCu) == 0;
        if ( !v9 )
          __asm { lock }
        __asm { cmpxchg [edx], ecx }
        if ( !v9 )
        {
          L_lock_4026(0, (volatile __int32 *)_EDX);
          return;
        }
        _EDX = v3[18];
        v5 = (int *)stdout;
        *(_DWORD *)(_EDX + 8) = v7;
      }
      ++*(_DWORD *)(_EDX + 4);
      v4 = *v5;
    }
    if ( (v4 & 0x288) == 640 )
      (*(void (__cdecl **)(int *, int))(v5[37] + 12))(v5, -1);
    if ( (BYTE1(*v3) & 0x80u) != 0 )
      goto LABEL_19;
    v10 = (_DWORD *)v3[18];
    v9 = v10[1]-- == 1;
    if ( !v9 )
      goto LABEL_19;
    v10[2] = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v9 = (*v10)-- == 1;
    if ( !v9 )
    {
      L_unlock_4065((int)v5, v10);
    }
    else
    {
LABEL_19:
      IO_switch_to_get_mode(a2);
      v11 = a2[7];
      v12 = a2[8];
      v13 = a2[37];
      a2[1] = v11;
      a2[3] = v11;
      a2[2] = v11;
      a2[6] = v11;
      a2[5] = v11;
      a2[4] = v11;
      v14 = (*(int (__cdecl **)(int *, int, int))(v13 + 56))(a2, v11, v12 - v11);
      if ( v14 <= 0 )
      {
        if ( v14 )
          *a2 |= 0x20u;
        else
          *a2 |= 0x10u;
      }
      else
      {
        v15 = a2[19];
        v16 = a2[20];
        a2[2] += v14;
        if ( (v16 & v15) != -1 )
          *(_QWORD *)(a2 + 19) = __PAIR64__(v16, v15) + v14;
      }
    }
  }
}
// 806B7EA: variable 'v5' is possibly undefined
// 80EFA20: using guessed type void *stdout;

//----- (0806B940) --------------------------------------------------------
int __cdecl IO_new_file_overflow(int *a1, int a2)
{
  int v2; // edx
  _BYTE *v3; // eax
  int v4; // edx
  _BYTE *v5; // eax
  int result; // eax
  _BYTE *v7; // ecx
  _BYTE *v8; // edi
  int v9; // edi
  bool v10; // dl
  unsigned int v11; // edi
  unsigned int v12; // edx

  v2 = *a1;
  if ( (*a1 & 8) != 0 )
  {
    *a1 = v2 | 0x20;
    __writegsdword(0xFFFFFFE8, 9u);
    return -1;
  }
  if ( (v2 & 0x800) != 0 )
  {
    if ( a1[4] )
    {
      v3 = (_BYTE *)a1[5];
      goto LABEL_5;
    }
    goto LABEL_29;
  }
  if ( !a1[4] )
  {
LABEL_29:
    IO_doallocbuf((int)a1);
    v3 = (_BYTE *)a1[7];
    v2 = *a1;
    a1[3] = (int)v3;
    a1[1] = (int)v3;
    a1[2] = (int)v3;
    goto LABEL_14;
  }
  v3 = (_BYTE *)a1[1];
LABEL_14:
  if ( (v2 & 0x100) != 0 )
  {
    v11 = a1[2] - (_DWORD)v3;
    IO_free_backup_area(a1);
    v12 = a1[3] - a1[7];
    if ( v11 <= v12 )
      v12 = v11;
    v3 = (_BYTE *)(a1[3] - v12);
    v2 = *a1;
    a1[3] = (int)v3;
    a1[1] = (int)v3;
  }
  v7 = (_BYTE *)a1[8];
  if ( v7 == v3 )
  {
    v3 = (_BYTE *)a1[7];
    a1[2] = (int)v3;
    v8 = v3;
  }
  else
  {
    v8 = (_BYTE *)a1[2];
  }
  a1[1] = (int)v8;
  BYTE1(v2) |= 8u;
  a1[3] = (int)v8;
  v9 = a1[26];
  a1[5] = (int)v3;
  a1[4] = (int)v3;
  a1[6] = (int)v7;
  *a1 = v2;
  if ( v9 <= 0 && (v2 & 0x202) != 0 )
    a1[6] = (int)v3;
LABEL_5:
  if ( a2 == -1 )
    return IO_new_do_write((int)a1, a1[4], (int)&v3[-a1[4]]);
  if ( v3 == (_BYTE *)a1[8] )
  {
    if ( a1[26] <= 0 )
      v10 = IO_new_do_write((int)a1, a1[4], (int)&v3[-a1[4]]) == -1;
    else
      v10 = IO_wdo_write(a1, *(_DWORD *)(a1[22] + 12), (*(_DWORD *)(a1[22] + 16) - *(_DWORD *)(a1[22] + 12)) >> 2) == -1;
    result = -1;
    if ( v10 )
      return result;
    v3 = (_BYTE *)a1[5];
  }
  *v3 = a2;
  v4 = *a1;
  v5 = v3 + 1;
  a1[5] = (int)v5;
  if ( ((v4 & 2) != 0 || a2 == 10 && (v4 & 0x200) != 0) && IO_new_do_write((int)a1, a1[4], (int)&v5[-a1[4]]) == -1 )
    return -1;
  else
    return (unsigned __int8)a2;
}

//----- (0806BB31) --------------------------------------------------------
void __usercall L_lock_4026(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x806B79A);
}
// 806BB38: control flows out of bounds to 806B79A

//----- (0806BB3D) --------------------------------------------------------
void __fastcall L_unlock_4065(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x806B7F0);
}
// 806BB44: control flows out of bounds to 806B7F0

//----- (0806BB49) --------------------------------------------------------
#error "806B93A: call analysis failed (funcsize=5)"

//----- (0806BB60) --------------------------------------------------------
void __fastcall flush_cleanup(int a1)
{
  _DWORD *v1; // edx
  bool v2; // zf

  if ( !run_fp )
    goto LABEL_7;
  if ( (BYTE1(*(_DWORD *)run_fp) & 0x80u) != 0 )
    goto LABEL_7;
  v1 = *(_DWORD **)(run_fp + 72);
  v2 = v1[1]-- == 1;
  if ( !v2 )
    goto LABEL_7;
  v1[2] = 0;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v2 = (*v1)-- == 1;
  if ( !v2 )
  {
    L_unlock_24(a1, v1);
  }
  else
  {
LABEL_7:
    if ( !--dword_80F0CE0 )
    {
      dword_80F0CE4 = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --list_all_lock )
        L_unlock_37();
    }
  }
}
// 80F0CDC: using guessed type int list_all_lock;
// 80F0CE0: using guessed type int dword_80F0CE0;
// 80F0CE4: using guessed type int dword_80F0CE4;
// 80F0CE8: using guessed type int run_fp;

//----- (0806BBD0) --------------------------------------------------------
int __usercall save_for_backup@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  _DWORD *v4; // edx
  unsigned int v5; // edi
  int v6; // esi
  _DWORD *v7; // eax
  int v8; // ecx
  int v9; // eax
  unsigned int v10; // ebp
  int v11; // ecx
  int v12; // ecx
  int v13; // ebp
  int result; // eax
  int v15; // eax
  int v16; // ecx
  _WORD *v17; // eax
  _BYTE *dest; // [esp+0h] [ebp-4Ch]
  _BYTE *src; // [esp+4h] [ebp-48h]
  unsigned int n; // [esp+8h] [ebp-44h]
  int v21; // [esp+1Ch] [ebp-30h]
  int v22; // [esp+1Ch] [ebp-30h]
  _BYTE *v24; // [esp+24h] [ebp-28h]
  int v25; // [esp+28h] [ebp-24h]
  unsigned int v26; // [esp+2Ch] [ebp-20h]

  v4 = (_DWORD *)a1[12];
  v5 = a2 - a1[3];
  v24 = (_BYTE *)a1[3];
  if ( v4 )
  {
    v6 = v5;
    v7 = (_DWORD *)a1[12];
    do
    {
      v8 = v7[2];
      v7 = (_DWORD *)*v7;
      if ( v6 > v8 )
        v6 = v8;
    }
    while ( v7 );
    v9 = a1[9];
    v10 = v5 - v6;
    v25 = a1[11];
    v11 = v25 - v9;
    if ( v5 - v6 > v25 - v9 )
    {
      v26 = v10 + 100;
      v15 = malloc(v10 + 100);
      if ( !v15 )
        return -1;
      v13 = v15 + 100;
      v21 = v15;
      if ( v6 < 0 )
      {
        v17 = mempcpy((_BYTE *)(v15 + 100), (_BYTE *)(v25 + v6), -v6);
        memcpy(v17, v24, v5);
      }
      else
      {
        memcpy((_BYTE *)(v15 + 100), &v24[v6], v5 - v6);
      }
      free(a1[9]);
      v5 = a2 - a1[3];
      a1[9] = v21;
      a1[11] = v26 + v21;
      v4 = (_DWORD *)a1[12];
      goto LABEL_10;
    }
  }
  else
  {
    v16 = a1[11];
    v6 = v5;
    v10 = 0;
    v9 = a1[9];
    v25 = v16;
    v11 = v16 - v9;
  }
  v12 = v11 - v10;
  if ( v6 < 0 )
  {
    v22 = v12;
    memmove((void *)(v12 + v9), (const void *)(v6 + v25), -v6);
    src = (_BYTE *)a1[3];
    n = a2 - (_DWORD)src;
    dest = (_BYTE *)(a1[9] + v22 - v6);
  }
  else
  {
    if ( !v10 )
    {
      v13 = v9 + v12;
      goto LABEL_10;
    }
    n = v10;
    dest = (_BYTE *)(v12 + v9);
    src = &v24[v6];
    v22 = v12;
  }
  memcpy(dest, src, n);
  v5 = a2 - a1[3];
  v4 = (_DWORD *)a1[12];
  v13 = v22 + a1[9];
LABEL_10:
  result = 0;
  a1[10] = v13;
  if ( v4 )
  {
    do
    {
      v4[2] -= v5;
      v4 = (_DWORD *)*v4;
    }
    while ( v4 );
    return 0;
  }
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0806BD90) --------------------------------------------------------
void __cdecl IO_un_link(int *a1)
{
  unsigned int v1; // edx
  bool v3; // zf
  int v4; // ecx
  int v5; // eax
  unsigned int v7; // edi
  bool v9; // zf
  int *v10; // eax
  int *v11; // edx
  int v12; // eax
  _DWORD *v13; // edx
  int v14; // eax
  void *v15; // eax

  if ( *(char *)a1 < 0 )
  {
    v1 = __readgsdword(8u);
    if ( v1 != dword_80F0CE4 )
    {
      _ECX = 1;
      v3 = __readgsdword(0xCu) == 0;
      if ( !v3 )
        __asm { lock }
      __asm { cmpxchg ds:list_all_lock, ecx }
      if ( !v3 )
      {
        L_lock_436(0);
        return;
      }
      dword_80F0CE4 = v1;
    }
    v4 = *a1;
    ++dword_80F0CE0;
    run_fp = (int)a1;
    v5 = v4 & 0x8000;
    if ( (v4 & 0x8000) == 0 )
    {
      _EDX = a1[18];
      v7 = __readgsdword(8u);
      if ( v7 != *(_DWORD *)(_EDX + 8) )
      {
        _ECX = 1;
        v9 = __readgsdword(0xCu) == 0;
        if ( !v9 )
          __asm { lock }
        __asm { cmpxchg [edx], ecx }
        if ( !v9 )
        {
          L_lock_470(v5, (volatile __int32 *)_EDX);
          return;
        }
        _EDX = a1[18];
        *(_DWORD *)(_EDX + 8) = v7;
      }
      ++*(_DWORD *)(_EDX + 4);
      v4 = *a1;
    }
    if ( IO_list_all )
    {
      if ( a1 == IO_list_all )
      {
        v15 = (void *)a1[13];
        ++IO_list_all_stamp;
        IO_list_all = v15;
      }
      else
      {
        v10 = (int *)*((_DWORD *)IO_list_all + 13);
        if ( v10 )
        {
          v11 = (int *)((char *)IO_list_all + 52);
          if ( a1 == v10 )
          {
LABEL_28:
            v14 = a1[13];
            ++IO_list_all_stamp;
            *v11 = v14;
          }
          else
          {
            while ( 1 )
            {
              v11 = v10 + 13;
              v10 = (int *)v10[13];
              if ( !v10 )
                break;
              if ( a1 == v10 )
                goto LABEL_28;
            }
          }
        }
      }
    }
    v12 = v4;
    LOBYTE(v12) = v4 & 0x7F;
    BYTE1(v4) &= 0x80u;
    *a1 = v12;
    if ( BYTE1(v4) )
      goto LABEL_23;
    v13 = (_DWORD *)a1[18];
    v3 = v13[1]-- == 1;
    if ( !v3 )
      goto LABEL_23;
    v13[2] = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v3 = (*v13)-- == 1;
    if ( v3 )
    {
LABEL_23:
      run_fp = 0;
      if ( !--dword_80F0CE0 )
      {
        dword_80F0CE4 = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --list_all_lock )
          L_unlock_543();
      }
    }
    else
    {
      L_unlock_599(v4, v13);
    }
  }
}
// 80EF5E0: using guessed type void *IO_list_all;
// 80F0CDC: using guessed type int list_all_lock;
// 80F0CE0: using guessed type int dword_80F0CE0;
// 80F0CE4: using guessed type int dword_80F0CE4;
// 80F0CE8: using guessed type int run_fp;
// 80F0CEC: using guessed type int IO_list_all_stamp;

//----- (0806BF80) --------------------------------------------------------
void __cdecl IO_link_in(int *a1)
{
  int v1; // eax
  unsigned int v2; // edx
  bool v4; // zf
  int v5; // ebp
  int v6; // ecx
  unsigned int v8; // edi
  bool v10; // zf
  void *v11; // eax
  void *v12; // eax

  v1 = *a1;
  if ( (*a1 & 0x80u) != 0 )
    return;
  LOBYTE(v1) = v1 | 0x80;
  *a1 = v1;
  v2 = __readgsdword(8u);
  if ( v2 != dword_80F0CE4 )
  {
    _ECX = 1;
    v4 = __readgsdword(0xCu) == 0;
    if ( !v4 )
      __asm { lock }
    __asm { cmpxchg ds:list_all_lock, ecx }
    if ( !v4 )
    {
      L_lock_661(0);
      return;
    }
    dword_80F0CE4 = v2;
  }
  v5 = *a1;
  run_fp = (int)a1;
  v6 = ++dword_80F0CE0;
  if ( (v5 & 0x8000) != 0 )
  {
    v12 = IO_list_all;
    ++IO_list_all_stamp;
    IO_list_all = a1;
    a1[13] = (int)v12;
  }
  else
  {
    _EDX = a1[18];
    v8 = __readgsdword(8u);
    if ( v8 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v10 = __readgsdword(0xCu) == 0;
      if ( !v10 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v10 )
      {
        L_lock_699(v5 & 0x8000, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = a1[18];
      v5 = *a1;
      *(_DWORD *)(_EDX + 8) = v8;
    }
    v11 = IO_list_all;
    ++*(_DWORD *)(_EDX + 4);
    ++IO_list_all_stamp;
    a1[13] = (int)v11;
    IO_list_all = a1;
    if ( (v5 & 0x8000) == 0 )
    {
      v4 = (*(_DWORD *)(_EDX + 4))-- == 1;
      v6 = dword_80F0CE0;
      if ( !v4 )
        goto LABEL_15;
      *(_DWORD *)(_EDX + 8) = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v4 = (*(_DWORD *)_EDX)-- == 1;
      if ( !v4 )
      {
        L_unlock_798(v6, (_DWORD *)_EDX);
        return;
      }
    }
    v6 = dword_80F0CE0;
  }
LABEL_15:
  run_fp = 0;
  dword_80F0CE0 = v6 - 1;
  if ( v6 == 1 )
  {
    dword_80F0CE4 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      L_unlock_738();
  }
}
// 80EF5E0: using guessed type void *IO_list_all;
// 80F0CDC: using guessed type int list_all_lock;
// 80F0CE0: using guessed type int dword_80F0CE0;
// 80F0CE4: using guessed type int dword_80F0CE4;
// 80F0CE8: using guessed type int run_fp;
// 80F0CEC: using guessed type int IO_list_all_stamp;

//----- (0806C170) --------------------------------------------------------
int __cdecl IO_least_marker(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // edx
  int v4; // ecx

  result = a2 - *(_DWORD *)(a1 + 12);
  v3 = *(_DWORD **)(a1 + 48);
  while ( v3 )
  {
    v4 = v3[2];
    v3 = (_DWORD *)*v3;
    if ( result > v4 )
      result = v4;
  }
  return result;
}

//----- (0806C1A0) --------------------------------------------------------
_DWORD *__cdecl IO_switch_to_main_get_area(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx

  result = a1;
  v2 = a1[2];
  v3 = a1[11];
  *a1 &= ~0x100u;
  a1[11] = v2;
  v4 = a1[9];
  a1[2] = v3;
  v5 = a1[3];
  a1[1] = v4;
  a1[3] = v4;
  a1[9] = v5;
  return result;
}

//----- (0806C1D0) --------------------------------------------------------
_DWORD *__cdecl IO_switch_to_backup_area(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // ebx
  int v5; // ecx

  result = a1;
  v2 = a1[2];
  v3 = a1[11];
  v4 = a1[9];
  *a1 |= 0x100u;
  a1[11] = v2;
  v5 = a1[3];
  a1[2] = v3;
  a1[3] = v4;
  a1[1] = v3;
  a1[9] = v5;
  return result;
}

//----- (0806C200) --------------------------------------------------------
int __cdecl IO_switch_to_get_mode(int *a1)
{
  unsigned int v1; // eax
  int v2; // edx
  bool v3; // cf
  int result; // eax

  v1 = a1[5];
  if ( v1 > a1[4] )
  {
    if ( (*(int (__cdecl **)(int *, int))(a1[37] + 12))(a1, -1) == -1 )
      return -1;
    v1 = a1[5];
  }
  v2 = *a1;
  if ( (*a1 & 0x100) != 0 )
  {
    a1[3] = a1[10];
  }
  else
  {
    v3 = a1[2] < v1;
    a1[3] = a1[7];
    if ( v3 )
      a1[2] = v1;
  }
  BYTE1(v2) &= ~8u;
  a1[1] = v1;
  a1[6] = v1;
  a1[4] = v1;
  result = 0;
  *a1 = v2;
  return result;
}

//----- (0806C270) --------------------------------------------------------
int __cdecl IO_free_backup_area(int *a1)
{
  int v1; // eax
  int v2; // edx
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int result; // eax

  v1 = *a1;
  if ( (*a1 & 0x100) != 0 )
  {
    BYTE1(v1) &= ~1u;
    v2 = a1[11];
    *a1 = v1;
    v3 = a1[2];
    a1[2] = v2;
    v4 = a1[9];
    a1[11] = v3;
    v5 = a1[3];
    a1[1] = v4;
    a1[3] = v4;
    a1[9] = v5;
  }
  else
  {
    v5 = a1[9];
  }
  result = free(v5);
  a1[9] = 0;
  a1[11] = 0;
  a1[10] = 0;
  return result;
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (0806C2D0) --------------------------------------------------------
int __cdecl _overflow(int a1, int a2)
{
  if ( !*(_DWORD *)(a1 + 104) )
    *(_DWORD *)(a1 + 104) = -1;
  return (*(int (__cdecl **)(int, int))(*(_DWORD *)(a1 + 148) + 12))(a1, a2);
}

//----- (0806C300) --------------------------------------------------------
int __cdecl _underflow(int *a1)
{
  int v1; // eax
  unsigned __int8 *v2; // eax
  unsigned int v3; // edx
  int v4; // eax
  unsigned int v6; // ecx
  int v7; // edx

  v1 = a1[26];
  if ( v1 )
  {
    if ( v1 != -1 )
      return -1;
  }
  else
  {
    a1[26] = -1;
  }
  if ( (*a1 & 0x800) != 0 && IO_switch_to_get_mode(a1) == -1 )
    return -1;
  v2 = (unsigned __int8 *)a1[1];
  v3 = a1[2];
  if ( (unsigned int)v2 >= v3 )
  {
    v4 = *a1;
    if ( (*a1 & 0x100) == 0 )
      goto LABEL_6;
    BYTE1(v4) &= ~1u;
    v6 = a1[11];
    *a1 = v4;
    v2 = (unsigned __int8 *)a1[9];
    a1[11] = v3;
    v7 = a1[3];
    a1[2] = v6;
    a1[3] = (int)v2;
    a1[9] = v7;
    a1[1] = (int)v2;
    if ( v6 <= (unsigned int)v2 )
    {
LABEL_6:
      if ( !a1[12] )
      {
        if ( a1[9] )
          IO_free_backup_area(a1);
        return (*(int (__cdecl **)(int *))(a1[37] + 16))(a1);
      }
      if ( !save_for_backup(a1, a1[2]) )
        return (*(int (__cdecl **)(int *))(a1[37] + 16))(a1);
      return -1;
    }
  }
  return *v2;
}

//----- (0806C3D0) --------------------------------------------------------
int __cdecl _uflow(int *a1)
{
  int v1; // eax
  unsigned __int8 *v2; // edx
  unsigned int v3; // eax
  int v4; // edx
  int result; // eax
  unsigned int v6; // ecx
  int v7; // eax

  v1 = a1[26];
  if ( v1 )
  {
    if ( v1 != -1 )
      return -1;
  }
  else
  {
    a1[26] = -1;
  }
  if ( (*a1 & 0x800) != 0 && IO_switch_to_get_mode(a1) == -1 )
    return -1;
  v2 = (unsigned __int8 *)a1[1];
  v3 = a1[2];
  if ( (unsigned int)v2 >= v3 )
  {
    v4 = *a1;
    if ( (*a1 & 0x100) == 0 )
      goto LABEL_6;
    BYTE1(v4) &= ~1u;
    v6 = a1[11];
    *a1 = v4;
    v2 = (unsigned __int8 *)a1[9];
    a1[11] = v3;
    v7 = a1[3];
    a1[2] = v6;
    a1[3] = (int)v2;
    a1[9] = v7;
    a1[1] = (int)v2;
    if ( v6 <= (unsigned int)v2 )
    {
LABEL_6:
      if ( !a1[12] )
      {
        if ( a1[9] )
          IO_free_backup_area(a1);
        return (*(int (__cdecl **)(int *))(a1[37] + 20))(a1);
      }
      if ( !save_for_backup(a1, a1[2]) )
        return (*(int (__cdecl **)(int *))(a1[37] + 20))(a1);
      return -1;
    }
  }
  result = *v2;
  a1[1] = (int)(v2 + 1);
  return result;
}

//----- (0806C4A0) --------------------------------------------------------
int __cdecl IO_setb(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int result; // eax

  v4 = *(_DWORD *)(a1 + 28);
  if ( v4 && (*(_BYTE *)a1 & 1) == 0 )
    munmap(*(_DWORD *)(a1 + 28), (*(_DWORD *)(a1 + 32) - v4 + 4095) & 0xFFFFF000);
  *(_DWORD *)(a1 + 28) = a2;
  *(_DWORD *)(a1 + 32) = a3;
  result = a4;
  if ( a4 )
    *(_DWORD *)a1 &= ~1u;
  else
    *(_DWORD *)a1 |= 1u;
  return result;
}

//----- (0806C500) --------------------------------------------------------
int __cdecl IO_doallocbuf(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 28);
  if ( !result )
  {
    if ( (*(_BYTE *)a1 & 2) != 0 && *(int *)(a1 + 104) <= 0 )
      return IO_setb(a1, a1 + 71, a1 + 72, 0);
    result = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 148) + 52))(a1);
    if ( result == -1 )
      return IO_setb(a1, a1 + 71, a1 + 72, 0);
  }
  return result;
}

//----- (0806C560) --------------------------------------------------------
int IO_default_underflow()
{
  return -1;
}

//----- (0806C570) --------------------------------------------------------
int __cdecl IO_default_uflow(int a1)
{
  unsigned __int8 *v1; // edx
  int result; // eax

  if ( (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 148) + 16))(a1) == -1 )
    return -1;
  v1 = *(unsigned __int8 **)(a1 + 4);
  result = *v1;
  *(_DWORD *)(a1 + 4) = v1 + 1;
  return result;
}

//----- (0806C5B0) --------------------------------------------------------
unsigned int __cdecl IO_default_xsputn(_DWORD *a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // esi
  _BYTE *v6; // edx
  unsigned int v7; // ebp
  unsigned int v8; // ebp
  int j; // eax
  _BYTE *v10; // [esp+4h] [ebp-28h]

  result = 0;
  if ( a3 )
  {
    for ( i = a3; ; --i )
    {
      v6 = (_BYTE *)a1[5];
      v7 = a1[6];
      if ( (unsigned int)v6 < v7 )
      {
        v8 = v7 - (_DWORD)v6;
        if ( i <= v8 )
          v8 = i;
        if ( v8 > 0x14 )
        {
          v10 = a2;
          a2 += v8;
          a1[5] = mempcpy(v6, v10, v8);
        }
        else if ( v8 )
        {
          for ( j = 0; j != v8; ++j )
            v6[j] = a2[j];
          a2 += v8;
          a1[5] = &v6[v8];
        }
        i -= v8;
      }
      if ( !i || (*(int (__cdecl **)(_DWORD *, _DWORD))(a1[37] + 12))(a1, *a2) == -1 )
        break;
      ++a2;
    }
    return a3 - i;
  }
  return result;
}

//----- (0806C660) --------------------------------------------------------
int __cdecl IO_sgetn(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)(a1 + 148) + 32))();
}

//----- (0806C670) --------------------------------------------------------
unsigned int __cdecl IO_default_xsgetn(int *a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v4; // edi
  _BYTE *v5; // edx
  unsigned int v6; // ebx
  unsigned int v7; // ebx
  int i; // eax
  _WORD *v10; // eax

  v4 = a3;
  do
  {
    v5 = (_BYTE *)a1[1];
    v6 = a1[2];
    if ( (unsigned int)v5 < v6 )
    {
      v7 = v6 - (_DWORD)v5;
      if ( v4 <= v7 )
        v7 = v4;
      if ( v7 > 0x14 )
      {
        v10 = mempcpy(a2, v5, v7);
        a1[1] += v7;
        a2 = v10;
      }
      else if ( v7 )
      {
        for ( i = 0; i != v7; ++i )
          a2[i] = v5[i];
        a2 += v7;
        a1[1] = (int)&v5[v7];
      }
      v4 -= v7;
    }
  }
  while ( v4 && _underflow(a1) != -1 );
  return a3 - v4;
}

//----- (0806C700) --------------------------------------------------------
_DWORD *__cdecl IO_default_setbuf(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // ebx

  v3 = a1;
  if ( (*(int (__cdecl **)(_DWORD *))(a1[37] + 48))(a1) == -1 )
    return 0;
  if ( a3 && a2 )
  {
    *a1 &= ~2u;
    IO_setb((int)a1, a2, a2 + a3, 0);
  }
  else
  {
    *a1 |= 2u;
    IO_setb((int)a1, (int)a1 + 71, (int)(a1 + 18), 0);
  }
  a1[6] = 0;
  a1[5] = 0;
  a1[4] = 0;
  a1[2] = 0;
  a1[1] = 0;
  a1[3] = 0;
  return v3;
}

//----- (0806C7C0) --------------------------------------------------------
int __cdecl IO_default_seekpos(int a1, int a2, int a3, int a4)
{
  return (*(int (__cdecl **)(int, int, int, _DWORD, int))(*(_DWORD *)(a1 + 148) + 36))(a1, a2, a3, 0, a4);
}

//----- (0806C800) --------------------------------------------------------
int __cdecl IO_default_doallocate(int a1)
{
  int v1; // eax

  v1 = mmap(0, 0x2000, 3, 34, -1, 0);
  if ( v1 == -1 )
    return -1;
  IO_setb(a1, v1, v1 + 0x2000, 1);
  return 1;
}

//----- (0806C870) --------------------------------------------------------
_DWORD *__cdecl IO_old_init(int a1, int a2)
{
  _DWORD *result; // eax

  *(_DWORD *)a1 = a2 | 0xFBAD0000;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 68) = 0;
  result = *(_DWORD **)(a1 + 72);
  if ( result )
  {
    *result = 0;
    result[1] = 0;
    result[2] = 0;
  }
  return result;
}

//----- (0806C910) --------------------------------------------------------
_DWORD *__cdecl IO_no_init(_DWORD *a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  _DWORD *result; // eax

  result = IO_old_init((int)a1, a2);
  a1[26] = a3;
  if ( a3 >= 0 )
  {
    result = a5;
    a1[22] = a4;
    a4[6] = 0;
    a4[7] = 0;
    a4[2] = 0;
    *a4 = 0;
    a4[1] = 0;
    a4[3] = 0;
    a4[4] = 0;
    a4[5] = 0;
    a4[8] = 0;
    a4[9] = 0;
    a4[10] = 0;
    a4[46] = a5;
  }
  a1[23] = 0;
  return result;
}

//----- (0806C9C0) --------------------------------------------------------
_DWORD *__cdecl IO_init(_DWORD *a1, int a2)
{
  return IO_no_init(a1, a2, -1, 0, 0);
}

//----- (0806CA00) --------------------------------------------------------
int IO_default_sync()
{
  return 0;
}

//----- (0806CA10) --------------------------------------------------------
void __usercall IO_default_finish(long double a1@<st0>, int *a2)
{
  int v2; // eax
  _DWORD *i; // eax

  v2 = a2[7];
  if ( v2 && (*(_BYTE *)a2 & 1) == 0 )
  {
    munmap(a2[7], (a2[8] - v2 + 4095) & 0xFFFFF000);
    a2[8] = 0;
    a2[7] = 0;
  }
  for ( i = (_DWORD *)a2[12]; i; i = (_DWORD *)*i )
    i[1] = 0;
  if ( a2[9] )
  {
    free(a1, a2[9]);
    a2[9] = 0;
  }
  IO_un_link(a2);
}

//----- (0806CA90) --------------------------------------------------------
__int64 IO_default_seekoff()
{
  return -1LL;
}

//----- (0806CAA0) --------------------------------------------------------
int __cdecl IO_sputbackc(_DWORD *a1, int a2)
{
  unsigned int v2; // edx
  int result; // eax

  v2 = a1[1];
  if ( v2 > a1[3] && (LOBYTE(result) = *(_BYTE *)(v2 - 1), (_BYTE)result == (_BYTE)a2) )
  {
    result = (unsigned __int8)result;
    a1[1] = v2 - 1;
  }
  else
  {
    result = (*(int (__cdecl **)(_DWORD *, int))(a1[37] + 24))(a1, a2);
    if ( result == -1 )
      return result;
  }
  *a1 &= ~0x10u;
  return result;
}

//----- (0806CAF0) --------------------------------------------------------
int __cdecl IO_sungetc(_DWORD *a1)
{
  unsigned int v1; // eax
  int result; // eax

  v1 = a1[1];
  if ( v1 > a1[3] )
  {
    a1[1] = v1 - 1;
    result = *(unsigned __int8 *)(v1 - 1);
LABEL_3:
    *a1 &= ~0x10u;
    return result;
  }
  result = (*(int (__cdecl **)(_DWORD *, int))(a1[37] + 24))(a1, -1);
  if ( result != -1 )
    goto LABEL_3;
  return result;
}

//----- (0806CB40) --------------------------------------------------------
int __cdecl IO_adjust_column(int a1, unsigned int a2, int a3)
{
  int v3; // eax
  int v4; // edx

  v3 = a2 + a3;
  if ( a2 >= a2 + a3 )
    return a3 + a1;
  v4 = v3 - 1;
  if ( *(_BYTE *)(v3 - 1) != 10 )
  {
    while ( v4 != a2 )
    {
      if ( *(_BYTE *)--v4 == 10 )
        return v3 - v4 - 1;
    }
    return a3 + a1;
  }
  return v3 - v4 - 1;
}

//----- (0806CB80) --------------------------------------------------------
void __cdecl IO_flush_all_lockp(int a1)
{
  unsigned int v2; // edx
  bool v3; // zf
  _DWORD *v4; // ebx
  int v5; // edi
  bool v7; // zf
  int v8; // eax
  _DWORD *v9; // edx
  unsigned int v10; // [esp+18h] [ebp-34h]
  void (__fastcall *v11)(int); // [esp+20h] [ebp-2Ch]
  int v12; // [esp+24h] [ebp-28h]

  if ( a1 )
  {
    v11 = flush_cleanup;
    v12 = 0;
    v2 = __readgsdword(8u);
    if ( v2 != dword_80F0CE4 )
    {
      _ECX = 1;
      v3 = __readgsdword(0xCu) == 0;
      if ( !v3 )
        __asm { lock }
      __asm { cmpxchg ds:list_all_lock, ecx }
      if ( !v3 )
      {
        L_lock_2351(0);
        return;
      }
      dword_80F0CE4 = v2;
    }
    ++dword_80F0CE0;
  }
  v4 = IO_list_all;
  v5 = IO_list_all_stamp;
  if ( IO_list_all )
  {
    v10 = __readgsdword(8u);
    while ( 1 )
    {
      run_fp = (int)v4;
      if ( a1 && (*v4 & 0x8000) == 0 )
      {
        _EDX = v4[18];
        _ECX = v10;
        if ( v10 != *(_DWORD *)(_EDX + 8) )
        {
          _ECX = 1;
          v7 = __readgsdword(0xCu) == 0;
          if ( !v7 )
            __asm { lock }
          __asm { cmpxchg [edx], ecx }
          if ( !v7 )
          {
            L_lock_2424(0, (volatile __int32 *)_EDX);
            return;
          }
          _EDX = v4[18];
          *(_DWORD *)(_EDX + 8) = v10;
        }
        ++*(_DWORD *)(_EDX + 4);
      }
      if ( (int)v4[26] > 0 )
        break;
      if ( v4[5] > v4[4] )
        goto LABEL_21;
LABEL_22:
      if ( a1 )
      {
        if ( (BYTE1(*v4) & 0x80u) == 0 )
        {
          v9 = (_DWORD *)v4[18];
          v3 = v9[1]-- == 1;
          if ( v3 )
          {
            v9[2] = 0;
            if ( __readgsdword(0xCu) )
              __asm { lock }
            v3 = (*v9)-- == 1;
            if ( !v3 )
            {
              L_unlock_2477(_ECX, v9);
              return;
            }
          }
        }
      }
      run_fp = 0;
      if ( v5 == IO_list_all_stamp )
      {
        v4 = (_DWORD *)v4[13];
        if ( !v4 )
          goto LABEL_30;
      }
      else
      {
        v4 = IO_list_all;
        v5 = IO_list_all_stamp;
        if ( !IO_list_all )
          goto LABEL_30;
      }
    }
    v8 = v4[22];
    _ECX = *(_DWORD *)(v8 + 12);
    if ( *(_DWORD *)(v8 + 16) <= _ECX )
      goto LABEL_22;
LABEL_21:
    (*(int (__cdecl **)(_DWORD *, int))(v4[37] + 12))(v4, -1);
    goto LABEL_22;
  }
LABEL_30:
  if ( a1 )
  {
    if ( !--dword_80F0CE0 )
    {
      dword_80F0CE4 = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --list_all_lock )
        L_unlock_2553();
    }
  }
}
// 806CD1D: conditional instruction was optimized away because %var_30.4==0
// 806CCD3: variable '_ECX' is possibly undefined
// 80EF5E0: using guessed type void *IO_list_all;
// 80F0CDC: using guessed type int list_all_lock;
// 80F0CE0: using guessed type int dword_80F0CE0;
// 80F0CE4: using guessed type int dword_80F0CE4;
// 80F0CE8: using guessed type int run_fp;
// 80F0CEC: using guessed type int IO_list_all_stamp;

//----- (0806CDB0) --------------------------------------------------------
void IO_cleanup()
{
  _DWORD *v0; // ebx
  unsigned int v1; // ebp
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  _DWORD *v8; // edx
  bool v9; // zf

  IO_flush_all_lockp(0);
  v0 = IO_list_all;
  if ( IO_list_all )
  {
    v1 = __readgsdword(8u);
    while ( 1 )
    {
      if ( (*v0 & 2) == 0 && (*v0 & 0x1008) != 8 && v0[26] )
      {
        _EDI = 1;
        _EDX = v0[18];
        if ( _EDX )
        {
          if ( v1 == *(_DWORD *)(_EDX + 8) )
          {
            ++*(_DWORD *)(_EDX + 4);
          }
          else
          {
            if ( __readgsdword(0xCu) )
              __asm { lock }
            __asm { cmpxchg [edx], edi }
            v4 = v0[18];
            *(_DWORD *)(v4 + 8) = v1;
            *(_DWORD *)(v4 + 4) = 1;
          }
        }
        if ( !dealloc_buffers && (*v0 & 1) == 0 )
        {
          v6 = v0[7];
          *v0 |= 1u;
          v7 = freeres_list;
          freeres_list = (int)v0;
          v0[24] = v6;
          v0[23] = v7;
          v0[25] = v0[8] - v6;
        }
        (*(void (__cdecl **)(_DWORD *, _DWORD, _DWORD))(v0[37] + 44))(v0, 0, 0);
        v8 = (_DWORD *)v0[18];
        if ( v8 )
        {
          v9 = v8[1]-- == 1;
          if ( v9 )
          {
            v8[2] = 0;
            if ( __readgsdword(0xCu) )
              __asm { lock }
            v9 = (*v8)-- == 1;
            if ( !v9 )
              break;
          }
        }
      }
      v0[26] = -1;
      v0 = (_DWORD *)v0[13];
      if ( !v0 )
        return;
    }
    L_unlock_2754(v5, v8);
  }
}
// 806CE5D: conditional instruction was optimized away because esi.4==0
// 806CEE9: variable 'v5' is possibly undefined
// 80EF5E0: using guessed type void *IO_list_all;
// 80F0CF0: using guessed type char dealloc_buffers;
// 80F0CF4: using guessed type int freeres_list;

//----- (0806CF10) --------------------------------------------------------
void IO_flush_all()
{
  IO_flush_all_lockp(1);
}

//----- (0806CF30) --------------------------------------------------------
void __fastcall flushlbf(int _ECX)
{
  unsigned int v1; // edx
  bool v2; // zf
  int *v3; // ebx
  int v4; // esi
  int v5; // eax
  unsigned int v6; // edi
  int v7; // eax
  bool v9; // zf
  _DWORD *v10; // edx
  void (__fastcall *v11)(int); // [esp+20h] [ebp-2Ch]
  int v12; // [esp+24h] [ebp-28h]

  v11 = flush_cleanup;
  v12 = 0;
  v1 = __readgsdword(8u);
  if ( v1 != dword_80F0CE4 )
  {
    _ECX = 1;
    v2 = __readgsdword(0xCu) == 0;
    if ( !v2 )
      __asm { lock }
    __asm { cmpxchg ds:list_all_lock, ecx }
    if ( !v2 )
    {
      L_lock_2824(0);
      return;
    }
    dword_80F0CE4 = v1;
  }
  v3 = (int *)IO_list_all;
  v4 = IO_list_all_stamp;
  v5 = ++dword_80F0CE0;
  if ( IO_list_all )
  {
    v6 = __readgsdword(8u);
    while ( 1 )
    {
      v7 = *v3;
      run_fp = (int)v3;
      if ( (v7 & 0x8000) == 0 )
      {
        _EDX = v3[18];
        if ( v6 != *(_DWORD *)(_EDX + 8) )
        {
          _ECX = 1;
          v9 = __readgsdword(0xCu) == 0;
          if ( !v9 )
            __asm { lock }
          __asm { cmpxchg [edx], ecx }
          if ( !v9 )
          {
            L_lock_2890(0, (volatile __int32 *)_EDX);
            return;
          }
          _EDX = v3[18];
          *(_DWORD *)(_EDX + 8) = v6;
        }
        ++*(_DWORD *)(_EDX + 4);
      }
      if ( (*v3 & 0x208) == 512 )
        (*(void (__cdecl **)(int *, int))(v3[37] + 12))(v3, -1);
      if ( (BYTE1(*v3) & 0x80u) == 0 )
      {
        v10 = (_DWORD *)v3[18];
        v2 = v10[1]-- == 1;
        if ( v2 )
        {
          v10[2] = 0;
          if ( __readgsdword(0xCu) )
            __asm { lock }
          v2 = (*v10)-- == 1;
          if ( !v2 )
            break;
        }
      }
      run_fp = 0;
      if ( v4 == IO_list_all_stamp )
      {
        v3 = (int *)v3[13];
        if ( !v3 )
        {
LABEL_25:
          v5 = dword_80F0CE0;
          goto LABEL_26;
        }
      }
      else
      {
        v3 = (int *)IO_list_all;
        v4 = IO_list_all_stamp;
        if ( !IO_list_all )
          goto LABEL_25;
      }
    }
    L_unlock_2923(_ECX, v10);
  }
  else
  {
LABEL_26:
    dword_80F0CE0 = v5 - 1;
    if ( v5 == 1 )
    {
      dword_80F0CE4 = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --list_all_lock )
        L_unlock_2957();
    }
  }
}
// 806D0AE: conditional instruction was optimized away because %var_30.4==0
// 806D04D: variable '_ECX' is possibly undefined
// 80EF5E0: using guessed type void *IO_list_all;
// 80F0CDC: using guessed type int list_all_lock;
// 80F0CE0: using guessed type int dword_80F0CE0;
// 80F0CE4: using guessed type int dword_80F0CE4;
// 80F0CE8: using guessed type int run_fp;
// 80F0CEC: using guessed type int IO_list_all_stamp;

//----- (0806D120) --------------------------------------------------------
int __cdecl IO_init_marker(int *a1, int *a2)
{
  int v2; // eax
  bool v3; // zf
  int v4; // eax
  int result; // eax

  v2 = *a2;
  a1[1] = (int)a2;
  if ( (v2 & 0x800) != 0 )
  {
    IO_switch_to_get_mode(a2);
    v2 = *a2;
  }
  v3 = (v2 & 0x100) == 0;
  v4 = a2[1];
  if ( v3 )
    a1[2] = v4 - a2[3];
  else
    a1[2] = v4 - a2[2];
  result = a2[12];
  *a1 = result;
  a2[12] = (int)a1;
  return result;
}

//----- (0806D180) --------------------------------------------------------
_DWORD *__cdecl IO_remove_marker(_DWORD *a1)
{
  int v1; // ecx
  _DWORD *result; // eax
  _DWORD *v3; // ecx

  v1 = a1[1];
  result = *(_DWORD **)(v1 + 48);
  if ( result )
  {
    v3 = (_DWORD *)(v1 + 48);
    if ( a1 == result )
    {
LABEL_7:
      result = (_DWORD *)*a1;
      *v3 = *a1;
    }
    else
    {
      while ( 1 )
      {
        v3 = result;
        result = (_DWORD *)*result;
        if ( !result )
          break;
        if ( a1 == result )
          goto LABEL_7;
      }
    }
  }
  return result;
}

//----- (0806D1B0) --------------------------------------------------------
int __cdecl IO_marker_difference(int a1, int a2)
{
  return *(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8);
}

//----- (0806D1C0) --------------------------------------------------------
int __cdecl IO_marker_delta(int a1)
{
  _DWORD *v1; // eax
  int v2; // edx
  int v3; // edx

  v1 = *(_DWORD **)(a1 + 4);
  if ( !v1 )
    return -1;
  v2 = v1[1];
  if ( (*v1 & 0x100) != 0 )
    v3 = v2 - v1[2];
  else
    v3 = v2 - v1[3];
  return *(_DWORD *)(a1 + 8) - v3;
}

//----- (0806D1F0) --------------------------------------------------------
int __cdecl IO_seekmark(int *a1, int a2)
{
  int result; // eax
  int *v3; // edx
  int v4; // eax
  int v5; // ecx
  int v6; // ebx
  int v7; // ecx
  int v8; // ebx
  int v9; // ecx
  int v10; // ebx
  int v11; // esi
  int v12; // ebx

  result = -1;
  v3 = *(int **)(a2 + 4);
  if ( v3 == a1 )
  {
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *v3;
    if ( v4 < 0 )
    {
      if ( (v5 & 0x100) != 0 )
      {
        v9 = v3[2];
      }
      else
      {
        v10 = v3[2];
        BYTE1(v5) |= 1u;
        v11 = v3[9];
        *v3 = v5;
        v9 = v3[11];
        v3[11] = v10;
        v12 = v3[3];
        v3[3] = v11;
        v3[2] = v9;
        v3[9] = v12;
      }
    }
    else if ( (v5 & 0x100) != 0 )
    {
      BYTE1(v5) &= ~1u;
      v6 = v3[11];
      *v3 = v5;
      v7 = v3[2];
      v3[2] = v6;
      v8 = v3[3];
      v3[11] = v7;
      v9 = v3[9];
      v3[9] = v8;
      v3[3] = v9;
    }
    else
    {
      v9 = v3[3];
    }
    v3[1] = v9 + v4;
    return 0;
  }
  return result;
}

//----- (0806D280) --------------------------------------------------------
int __cdecl IO_unsave_markers(int *a1)
{
  int result; // eax

  result = (int)a1;
  if ( a1[12] )
    a1[12] = 0;
  if ( a1[9] )
    return IO_free_backup_area(a1);
  return result;
}

//----- (0806D2B0) --------------------------------------------------------
int __usercall IO_default_pbackfail@<eax>(long double a1@<st0>, int *a2, int a3)
{
  unsigned int v3; // edx
  _BYTE *v4; // edi
  int v5; // eax
  int result; // eax
  int v7; // eax
  int v8; // edi
  int v9; // ecx
  int v10; // edx
  unsigned int v11; // ebp
  int v12; // eax
  unsigned int v13; // [esp+14h] [ebp-28h]
  int v14; // [esp+14h] [ebp-28h]
  int v15; // [esp+18h] [ebp-24h]

  v3 = a2[1];
  v4 = (_BYTE *)a2[3];
  v5 = *a2;
  if ( v3 <= (unsigned int)v4 )
  {
    if ( (v5 & 0x100) != 0 )
    {
      v11 = a2[2] - (_DWORD)v4;
      malloc(a1, 2 * v11);
      if ( v12 )
      {
        v13 = v12 + v11;
        v15 = v12;
        memcpy((_BYTE *)(v12 + v11), v4, v11);
        free(a1, a2[3]);
        v3 = v13;
        a2[3] = v15;
        a2[10] = v13;
        a2[2] = 2 * v11 + v15;
        goto LABEL_3;
      }
      return -1;
    }
    v7 = a2[9];
    if ( v7 )
    {
      v8 = a2[1];
      v3 = a2[11];
LABEL_9:
      v9 = a2[2];
      *a2 |= 0x100u;
      a2[2] = v3;
      a2[11] = v9;
      a2[3] = v7;
      a2[9] = v8;
      goto LABEL_3;
    }
LABEL_17:
    v14 = a2[1];
    malloc(a1, 0x80u);
    if ( v7 )
    {
      v8 = v14;
      a2[10] = v7 + 128;
      v3 = v7 + 128;
      goto LABEL_9;
    }
    return -1;
  }
  if ( (v5 & 0x100) != 0 )
  {
LABEL_3:
    a2[1] = v3 - 1;
    *(_BYTE *)(v3 - 1) = a3;
    return (unsigned __int8)a3;
  }
  if ( *(unsigned __int8 *)(v3 - 1) == a3 )
  {
    a2[1] = v3 - 1;
    return (unsigned __int8)a3;
  }
  if ( !a2[9] )
    goto LABEL_17;
  v10 = save_for_backup(a2, v3);
  result = -1;
  if ( !v10 )
  {
    v8 = a2[1];
    v3 = a2[11];
    v7 = a2[9];
    goto LABEL_9;
  }
  return result;
}
// 806D324: variable 'v7' is possibly undefined
// 806D37F: variable 'v12' is possibly undefined

//----- (0806D410) --------------------------------------------------------
__int64 IO_default_seek()
{
  return -1LL;
}

//----- (0806D420) --------------------------------------------------------
int IO_default_stat()
{
  return -1;
}

//----- (0806D430) --------------------------------------------------------
int IO_default_read()
{
  return -1;
}

//----- (0806D440) --------------------------------------------------------
int IO_default_write()
{
  return 0;
}

//----- (0806D450) --------------------------------------------------------
int IO_default_showmanyc()
{
  return -1;
}

//----- (0806D470) --------------------------------------------------------
void *IO_iter_begin()
{
  return IO_list_all;
}
// 80EF5E0: using guessed type void *IO_list_all;

//----- (0806D480) --------------------------------------------------------
int IO_iter_end()
{
  return 0;
}

//----- (0806D490) --------------------------------------------------------
int __cdecl IO_iter_next(int a1)
{
  return *(_DWORD *)(a1 + 52);
}

//----- (0806D4A0) --------------------------------------------------------
int __cdecl IO_iter_file(int a1)
{
  return a1;
}

//----- (0806D4B0) --------------------------------------------------------
void IO_list_lock()
{
  unsigned int v0; // edx
  bool v2; // zf

  v0 = __readgsdword(8u);
  if ( v0 == dword_80F0CE4 )
    goto LABEL_6;
  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg ds:list_all_lock, ecx }
  if ( v2 )
  {
    dword_80F0CE4 = v0;
LABEL_6:
    ++dword_80F0CE0;
    return;
  }
  L_lock_3626(0);
}
// 80F0CDC: using guessed type int list_all_lock;
// 80F0CE0: using guessed type int dword_80F0CE0;
// 80F0CE4: using guessed type int dword_80F0CE4;

//----- (0806D4F0) --------------------------------------------------------
void IO_list_unlock()
{
  if ( !--dword_80F0CE0 )
  {
    dword_80F0CE4 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      L_unlock_3653();
  }
}
// 80F0CDC: using guessed type int list_all_lock;
// 80F0CE0: using guessed type int dword_80F0CE0;
// 80F0CE4: using guessed type int dword_80F0CE4;

//----- (0806D530) --------------------------------------------------------
void IO_list_resetlock()
{
  list_all_lock = 0;
  dword_80F0CE0 = 0;
  dword_80F0CE4 = 0;
}
// 80F0CDC: using guessed type int list_all_lock;
// 80F0CE0: using guessed type int dword_80F0CE0;
// 80F0CE4: using guessed type int dword_80F0CE4;

//----- (0806D54F) --------------------------------------------------------
void __fastcall L_unlock_24(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x806BB9B);
}
// 806D556: control flows out of bounds to 806BB9B

//----- (0806D55B) --------------------------------------------------------
void L_unlock_37()
{
  _lll_unlock_wake_private(&list_all_lock);
  JUMPOUT(0x806BBCE);
}
// 806D566: control flows out of bounds to 806BBCE
// 80F0CDC: using guessed type int list_all_lock;

//----- (0806D56B) --------------------------------------------------------
void __usercall L_lock_436(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &list_all_lock);
  JUMPOUT(0x806BDF6);
}
// 806D576: control flows out of bounds to 806BDF6
// 80F0CDC: using guessed type int list_all_lock;

//----- (0806D57B) --------------------------------------------------------
void __usercall L_lock_470(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x806BE3C);
}
// 806D582: control flows out of bounds to 806BE3C

//----- (0806D587) --------------------------------------------------------
void L_unlock_543()
{
  _lll_unlock_wake_private(&list_all_lock);
  JUMPOUT(0x806BEDE);
}
// 806D592: control flows out of bounds to 806BEDE
// 80F0CDC: using guessed type int list_all_lock;

//----- (0806D597) --------------------------------------------------------
void __fastcall L_unlock_599(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x806BF5B);
}
// 806D59E: control flows out of bounds to 806BF5B

//----- (0806D5A3) --------------------------------------------------------
void __usercall L_lock_661(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &list_all_lock);
  JUMPOUT(0x806BFF8);
}
// 806D5AE: control flows out of bounds to 806BFF8
// 80F0CDC: using guessed type int list_all_lock;

//----- (0806D5B3) --------------------------------------------------------
void __usercall L_lock_699(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x806C04A);
}
// 806D5BA: control flows out of bounds to 806C04A

//----- (0806D5BF) --------------------------------------------------------
void L_unlock_738()
{
  _lll_unlock_wake_private(&list_all_lock);
  JUMPOUT(0x806C0C7);
}
// 806D5CA: control flows out of bounds to 806C0C7
// 80F0CDC: using guessed type int list_all_lock;

//----- (0806D5CF) --------------------------------------------------------
void __fastcall L_unlock_798(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x806C15B);
}
// 806D5D6: control flows out of bounds to 806C15B

//----- (0806D5DB) --------------------------------------------------------
void __usercall L_lock_2351(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &list_all_lock);
  JUMPOUT(0x806CBE2);
}
// 806D5E6: control flows out of bounds to 806CBE2
// 80F0CDC: using guessed type int list_all_lock;

//----- (0806D5EB) --------------------------------------------------------
void __usercall L_lock_2424(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x806CC60);
}
// 806D5F2: control flows out of bounds to 806CC60

//----- (0806D5F7) --------------------------------------------------------
void __fastcall L_unlock_2477(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x806CCD9);
}
// 806D5FE: control flows out of bounds to 806CCD9

//----- (0806D603) --------------------------------------------------------
void L_unlock_2553()
{
  _lll_unlock_wake_private(&list_all_lock);
  JUMPOUT(0x806CD7A);
}
// 806D60E: control flows out of bounds to 806CD7A
// 80F0CDC: using guessed type int list_all_lock;

//----- (0806D613) --------------------------------------------------------
void __fastcall L_unlock_2754(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x806CEEF);
}
// 806D61A: control flows out of bounds to 806CEEF

//----- (0806D61F) --------------------------------------------------------
void __usercall L_lock_2824(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &list_all_lock);
  JUMPOUT(0x806CF8C);
}
// 806D62A: control flows out of bounds to 806CF8C
// 80F0CDC: using guessed type int list_all_lock;

//----- (0806D62F) --------------------------------------------------------
void __usercall L_lock_2890(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x806D005);
}
// 806D636: control flows out of bounds to 806D005

//----- (0806D63B) --------------------------------------------------------
void __fastcall L_unlock_2923(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x806D053);
}
// 806D642: control flows out of bounds to 806D053

//----- (0806D647) --------------------------------------------------------
void L_unlock_2957()
{
  _lll_unlock_wake_private(&list_all_lock);
  JUMPOUT(0x806D0A8);
}
// 806D652: control flows out of bounds to 806D0A8
// 80F0CDC: using guessed type int list_all_lock;

//----- (0806D657) --------------------------------------------------------
void __usercall L_lock_3626(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &list_all_lock);
  JUMPOUT(0x806D4DE);
}
// 806D662: control flows out of bounds to 806D4DE
// 80F0CDC: using guessed type int list_all_lock;

//----- (0806D667) --------------------------------------------------------
void L_unlock_3653()
{
  _lll_unlock_wake_private(&list_all_lock);
  JUMPOUT(0x806D523);
}
// 806D672: control flows out of bounds to 806D523
// 80F0CDC: using guessed type int list_all_lock;

//----- (0806D680) --------------------------------------------------------
int __cdecl IO_str_underflow(_DWORD *a1)
{
  unsigned __int8 *v1; // edx
  unsigned __int8 *v2; // ebx
  int result; // eax
  int v4; // ecx

  v1 = (unsigned __int8 *)a1[5];
  v2 = (unsigned __int8 *)a1[2];
  if ( v1 > v2 )
  {
    a1[2] = v1;
    v2 = v1;
  }
  if ( (*a1 & 0xC00) == 3072 )
  {
    v4 = a1[6];
    *a1 &= ~0x800u;
    a1[1] = v1;
    a1[5] = v4;
  }
  else
  {
    v1 = (unsigned __int8 *)a1[1];
  }
  result = -1;
  if ( v1 < v2 )
    return *v1;
  return result;
}

//----- (0806D6D0) --------------------------------------------------------
void __usercall IO_str_finish(long double a1@<st0>, int *a2)
{
  if ( a2[7] && (*(_BYTE *)a2 & 1) == 0 )
    a1 = ((long double (__cdecl *)(int))a2[39])(a2[7]);
  a2[7] = 0;
  IO_default_finish(a1, a2);
}

//----- (0806D710) --------------------------------------------------------
int __usercall IO_str_pbackfail@<eax>(long double a1@<st0>, int *a2, int a3)
{
  if ( a3 == -1 || (*(_BYTE *)a2 & 8) == 0 )
    return IO_default_pbackfail(a1, a2, a3);
  else
    return -1;
}

//----- (0806D740) --------------------------------------------------------
int __cdecl IO_str_overflow(int a1, int a2)
{
  int v2; // esi
  int v3; // eax
  _BYTE *v5; // eax
  unsigned int v6; // edi
  _BYTE *v7; // eax
  _BYTE *v8; // edx
  _BYTE *v9; // ecx
  int v10; // edx
  int v11; // edx
  _BYTE *v12; // [esp+14h] [ebp-28h]
  _BYTE *v13; // [esp+14h] [ebp-28h]
  _BYTE *v14; // [esp+18h] [ebp-24h]
  int v15; // [esp+18h] [ebp-24h]
  unsigned int v16; // [esp+1Ch] [ebp-20h]

  v2 = a2;
  v3 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 8) != 0 )
    return -(a2 != -1);
  if ( (*(_DWORD *)a1 & 0xC00) == 1024 )
  {
    BYTE1(v3) |= 8u;
    v11 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)a1 = v3;
    v5 = *(_BYTE **)(a1 + 4);
    *(_DWORD *)(a1 + 4) = v11;
    *(_DWORD *)(a1 + 20) = v5;
  }
  else
  {
    v5 = *(_BYTE **)(a1 + 20);
  }
  v6 = *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28);
  if ( __PAIR64__((unsigned int)&v5[-*(_DWORD *)(a1 + 16)], a2 + 1) >= __PAIR64__(v6, 1) )
  {
    if ( (*(_BYTE *)a1 & 1) != 0 )
      return -1;
    v16 = 2 * v6 + 100;
    if ( v6 > v16 )
      return -1;
    v12 = *(_BYTE **)(a1 + 28);
    v7 = (_BYTE *)(*(int (__cdecl **)(unsigned int))(a1 + 152))(2 * v6 + 100);
    v8 = v12;
    v9 = v7;
    if ( !v7 )
      return -1;
    if ( v12 )
    {
      v14 = v7;
      memcpy(v7, v12, v6);
      (*(void (__cdecl **)(_BYTE *))(a1 + 156))(v12);
      v9 = v14;
      v8 = v12;
      *(_DWORD *)(a1 + 28) = 0;
    }
    v13 = v8;
    v15 = (int)v9;
    memset(&v9[v6], 0, v16 - v6);
    IO_setb(a1, v15, v15 + v16, 1);
    *(_DWORD *)(a1 + 12) += v15 - (_DWORD)v13;
    *(_DWORD *)(a1 + 4) += v15 - (_DWORD)v13;
    *(_DWORD *)(a1 + 8) += v15 - (_DWORD)v13;
    v10 = *(_DWORD *)(a1 + 32);
    v5 = (_BYTE *)(*(_DWORD *)(a1 + 20) + v15 - (_DWORD)v13);
    *(_DWORD *)(a1 + 16) = v15;
    *(_DWORD *)(a1 + 20) = v5;
    *(_DWORD *)(a1 + 24) = v10;
  }
  if ( a2 != -1 )
  {
    *v5++ = a2;
    *(_DWORD *)(a1 + 20) = v5;
  }
  if ( (unsigned int)v5 > *(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 8) = v5;
  return v2;
}

//----- (0806D8F0) --------------------------------------------------------
int __usercall enlarge_userbuf_part_0@<eax>(
        int a1@<eax>,
        unsigned int a2@<edx>,
        unsigned int a3@<ecx>,
        long double a4@<st0>,
        int a5)
{
  int v6; // ebp
  _BYTE *v8; // edi
  _BYTE *v9; // eax
  unsigned int v10; // edx
  unsigned int v11; // ecx
  int v12; // esi
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  size_t n; // edx
  void *s; // eax
  unsigned int v20; // [esp+1Ch] [ebp-30h]
  unsigned int v22; // [esp+20h] [ebp-2Ch]
  int v23; // [esp+24h] [ebp-28h]
  int v24; // [esp+28h] [ebp-24h]
  unsigned int v25; // [esp+2Ch] [ebp-20h]

  v6 = 1;
  v23 = *(_DWORD *)(a1 + 24);
  v24 = *(_DWORD *)(a1 + 16);
  if ( (*(_BYTE *)a1 & 1) == 0 )
  {
    v8 = *(_BYTE **)(a1 + 28);
    v25 = a2 + 100;
    v9 = (_BYTE *)(*(int (__cdecl **)(unsigned int))(a1 + 152))(a2 + 100);
    v10 = a2;
    v11 = a3;
    v12 = (int)v9;
    if ( v9 )
    {
      if ( v8 )
      {
        memcpy(v9, v8, *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28));
        (*(void (__cdecl **)(_BYTE *))(a1 + 156))(v8);
        v11 = a3;
        v10 = a2;
        *(_DWORD *)(a1 + 28) = 0;
      }
      v22 = v10;
      v20 = v11;
      IO_setb(a1, v12, v12 + v25, 1);
      v13 = v12 - (_DWORD)v8;
      if ( a5 )
      {
        *(_DWORD *)(a1 + 16) += v13;
        *(_DWORD *)(a1 + 20) += v12 - (_DWORD)v8;
        *(_DWORD *)(a1 + 24) += v12 - (_DWORD)v8;
        *(_DWORD *)(a1 + 4) += v12 - (_DWORD)v8;
        v16 = *(_DWORD *)(a1 + 32);
        *(_DWORD *)(a1 + 12) = v12;
        *(_DWORD *)(a1 + 8) = v16;
      }
      else
      {
        *(_DWORD *)(a1 + 12) += v13;
        *(_DWORD *)(a1 + 4) += v12 - (_DWORD)v8;
        *(_DWORD *)(a1 + 8) += v12 - (_DWORD)v8;
        *(_DWORD *)(a1 + 20) += v12 - (_DWORD)v8;
        v14 = *(_DWORD *)(a1 + 32);
        *(_DWORD *)(a1 + 16) = v12;
        *(_DWORD *)(a1 + 24) = v14;
      }
      v15 = v23 - v24;
      if ( __SPAIR64__(v20, v22) < v23 - v24 )
        _assert_fail(a5, a4, (int)"offset >= oldend", (int)"strops.c", 239, "enlarge_userbuf");
      n = v22 - v15;
      if ( a5 )
        s = (void *)(*(_DWORD *)(a1 + 12) + v15);
      else
        s = (void *)(*(_DWORD *)(a1 + 16) + v15);
      v6 = 0;
      memset(s, 0, n);
    }
  }
  return v6;
}

//----- (0806DA90) --------------------------------------------------------
int __usercall IO_str_seekoff@<eax>(long double a1@<st0>, int *a2, __int64 a3, int a4, int a5)
{
  char v5; // bp
  signed int v6; // edi
  signed int v7; // esi
  unsigned int v8; // eax
  int v9; // ecx
  int v10; // ebp
  int result; // eax
  int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // eax
  int v15; // ecx
  int v16; // ecx
  signed int v17; // [esp+1Ch] [ebp-20h]

  v5 = a5;
  v6 = HIDWORD(a3);
  v7 = a3;
  if ( !a5 )
  {
    v12 = *a2;
    if ( (*a2 & 0x400) == 0 )
    {
      if ( (v12 & 8) != 0 )
        return a2[1] - a2[3];
      else
        return a2[5] - a2[4];
    }
    if ( (v12 & 0x800) != 0 )
    {
      v13 = a2[2];
      if ( a2[5] >= v13 )
        v13 = a2[5];
      v17 = v13 - a2[3];
      goto LABEL_13;
    }
    v14 = a2[2];
    v5 = 1;
    v9 = a2[3];
    if ( a2[5] >= v14 )
      v14 = a2[5];
    v17 = v14 - v9;
    if ( a4 != 1 )
      goto LABEL_6;
    goto LABEL_34;
  }
  v8 = a2[2];
  v9 = a2[3];
  if ( a2[5] >= v8 )
    v8 = a2[5];
  v17 = v8 - v9;
  if ( (a5 & 1) != 0 )
  {
    if ( a4 != 1 )
    {
LABEL_6:
      if ( a4 == 2 )
      {
        v6 = (unsigned __int64)(v17 + a3) >> 32;
        v7 = v17 + a3;
      }
      goto LABEL_8;
    }
LABEL_34:
    v6 = (unsigned __int64)(a2[1] - v9 + a3) >> 32;
    v7 = a2[1] - v9 + a3;
LABEL_8:
    if ( v6 < 0 )
      return -1;
    if ( v17 < v7 && a2[8] - a2[7] < v7 )
    {
      v15 = enlarge_userbuf_part_0((int)a2, v7, v6, a1, 1);
      result = -1;
      if ( v15 )
        return result;
      v9 = a2[3];
    }
    v10 = v5 & 2;
    a2[1] = v9 + v7;
    result = v7;
    a2[2] = v17 + v9;
    goto LABEL_12;
  }
  v10 = a5 & 2;
  result = -1;
LABEL_12:
  if ( !v10 )
    return result;
LABEL_13:
  if ( a4 == 1 )
  {
    v6 = (a2[5] - a2[4] + __PAIR64__(v6, v7)) >> 32;
    v7 += a2[5] - a2[4];
  }
  else if ( a4 == 2 )
  {
    v6 = (v17 + __PAIR64__(v6, v7)) >> 32;
    v7 += v17;
  }
  if ( v6 < 0 )
    return -1;
  if ( v17 >= v7 || a2[8] - a2[7] >= v7 || (v16 = enlarge_userbuf_part_0((int)a2, v7, v6, a1, 0), result = -1, !v16) )
  {
    a2[5] = v7 + a2[4];
    return v7;
  }
  return result;
}

//----- (0806DCC0) --------------------------------------------------------
int __cdecl IO_str_init_static_internal(_DWORD *a1, unsigned int a2, int a3, int a4)
{
  int v4; // ebp
  int result; // eax

  if ( a3 )
  {
    v4 = -1;
    if ( a2 < a2 + a3 )
      v4 = a2 + a3;
  }
  else
  {
    v4 = rawmemchr(a2, 0);
  }
  result = IO_setb((int)a1, a2, v4, 0);
  a1[4] = a2;
  a1[3] = a2;
  a1[1] = a2;
  if ( a4 )
  {
    a1[5] = a4;
    a1[6] = v4;
    a1[2] = a4;
  }
  else
  {
    a1[5] = a2;
    a1[6] = a2;
    a1[2] = v4;
  }
  a1[38] = 0;
  return result;
}
// 8048230: using guessed type int __cdecl rawmemchr(_DWORD, _DWORD);

//----- (0806DD70) --------------------------------------------------------
int __cdecl IO_str_init_static(_DWORD *a1, unsigned int a2, int a3, int a4)
{
  int v4; // eax

  v4 = -1;
  if ( a3 >= 0 )
    v4 = a3;
  return IO_str_init_static_internal(a1, a2, v4, a4);
}

//----- (0806DD90) --------------------------------------------------------
int __cdecl IO_str_init_readonly(_DWORD *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int result; // eax

  v3 = -1;
  if ( a3 >= 0 )
    v3 = a3;
  result = IO_str_init_static_internal(a1, a2, v3, 0);
  *a1 |= 8u;
  return result;
}

//----- (0806DDD0) --------------------------------------------------------
unsigned int __cdecl IO_str_count(_DWORD *a1)
{
  unsigned int v1; // eax

  v1 = a1[2];
  if ( a1[5] >= v1 )
    v1 = a1[5];
  return v1 - a1[3];
}

//----- (0806DDF0) --------------------------------------------------------
const __m128i *(__cdecl *strchr())(const __m128i *a1, unsigned int a2)
{
  const __m128i *(__cdecl *result)(const __m128i *, unsigned int); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (const __m128i *(__cdecl *)(const __m128i *, unsigned int))_strchr_ia32;
  if ( (dword_80F1274 & 0x4000000) != 0 )
  {
    result = (const __m128i *(__cdecl *)(const __m128i *, unsigned int))_strchr_sse2_bsf;
    if ( (dword_80F1290 & 4) != 0 )
      return _strchr_sse2;
  }
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1274: using guessed type int dword_80F1274;
// 80F1290: using guessed type int dword_80F1290;

//----- (0806DE40) --------------------------------------------------------
unsigned int *__cdecl _strchr_ia32(unsigned int *a1, int a2)
{
  unsigned int *result; // eax
  int v3; // edx
  unsigned __int16 v4; // cx
  int v5; // edx
  char v6; // cl
  unsigned int v7; // ecx
  int v8; // ebp
  int v9; // ebp
  unsigned int v10; // ebx
  unsigned int v11; // ecx

  result = a1;
  v3 = a2;
  BYTE1(v3) = a2;
  LOBYTE(v4) = a2;
  HIBYTE(v4) = a2;
  v5 = v4 | (v3 << 16);
  if ( ((unsigned __int8)a1 & 3) == 0 )
  {
LABEL_11:
    v7 = *result;
    v8 = *result - 16843009;
    while ( 1 )
    {
      v9 = v7 ^ v8;
      ++result;
      if ( v7 < 0x1010101 || (v9 | 0xFEFEFEFF) != -1 )
        break;
      v10 = v5 ^ v7;
      v7 = *result;
      if ( v10 < 0x1010101 || (v10 ^ (v10 - 16843009) | 0xFEFEFEFF) != -1 )
      {
LABEL_28:
        --result;
        if ( (_BYTE)v10 )
        {
          result = (unsigned int *)((char *)result + 1);
          if ( BYTE1(v10) )
          {
            result = (unsigned int *)((char *)result + 1);
            if ( BYTE2(v10) )
              return (unsigned int *)((char *)result + 1);
          }
        }
        return result;
      }
      ++result;
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v10 = v5 ^ v7;
      v7 = *result;
      if ( v10 < 0x1010101 || (v10 ^ (v10 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_28;
      ++result;
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v10 = v5 ^ v7;
      v7 = *result;
      if ( v10 < 0x1010101 || (v10 ^ (v10 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_28;
      ++result;
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v10 = v5 ^ v7;
      v7 = *result;
      if ( v10 >= 0x1010101 )
      {
        v8 = v7 - 16843009;
        if ( (v10 ^ (v10 - 16843009) | 0xFEFEFEFF) == -1 )
          continue;
      }
      goto LABEL_28;
    }
    --result;
    if ( (_BYTE)v7 == (_BYTE)v5 )
      return result;
    if ( (_BYTE)v7 )
    {
      result = (unsigned int *)((char *)result + 1);
      if ( BYTE1(v7) == (_BYTE)v5 )
        return result;
      if ( BYTE1(v7) )
      {
        v11 = HIWORD(v7);
        result = (unsigned int *)((char *)result + 1);
        if ( (_BYTE)v11 == (_BYTE)v5 )
          return result;
        if ( (_BYTE)v11 )
        {
          result = (unsigned int *)((char *)result + 1);
          if ( BYTE1(v11) == (_BYTE)v5 )
            return result;
        }
      }
    }
    return 0;
  }
  if ( __SETP__((unsigned __int8)a1 & 3, 0) )
    goto LABEL_8;
  if ( *(_BYTE *)a1 != (unsigned __int8)v5 )
  {
    if ( !*(_BYTE *)a1 )
      return 0;
    v6 = *((_BYTE *)a1 + 1);
    result = (unsigned int *)((char *)a1 + 1);
    if ( (_BYTE)v5 != v6 )
    {
      if ( !v6 )
        return 0;
      result = (unsigned int *)((char *)a1 + 2);
      if ( ((unsigned __int8)a1 & 3) != 1 )
        goto LABEL_11;
LABEL_8:
      if ( (_BYTE)v5 != *(_BYTE *)result )
      {
        if ( *(_BYTE *)result )
        {
          result = (unsigned int *)((char *)result + 1);
          goto LABEL_11;
        }
        return 0;
      }
    }
  }
  return result;
}

//----- (0806E000) --------------------------------------------------------
int (__cdecl *strcmp())(const __m128i *a1, const __m128i *a2)
{
  int (__cdecl *result)(const __m128i *, const __m128i *); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (int (__cdecl *)(const __m128i *, const __m128i *))_strcmp_ia32;
  if ( (dword_80F1270 & 0x200) != 0 )
  {
    result = (int (__cdecl *)(const __m128i *, const __m128i *))_strcmp_ssse3;
    if ( (dword_80F1270 & 0x100000) != 0 )
      return _strcmp_sse4_2;
  }
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1270: using guessed type int dword_80F1270;

//----- (0806E040) --------------------------------------------------------
int __cdecl _strcmp_ia32(char *a1, _BYTE *a2)
{
  char v4; // al
  int result; // eax

  while ( 1 )
  {
    v4 = *a1;
    if ( *a1 != *a2 )
      break;
    ++a1;
    ++a2;
    if ( !v4 )
      return 0;
  }
  result = 1;
  if ( (unsigned __int8)*a1 < *a2 )
    return -1;
  return result;
}

//----- (0806E070) --------------------------------------------------------
unsigned int (__cdecl *strcpy())(unsigned int a1, unsigned int a2)
{
  unsigned int (__cdecl *result)(unsigned int, unsigned int); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (unsigned int (__cdecl *)(unsigned int, unsigned int))_strcpy_ia32;
  if ( (dword_80F1274 & 0x4000000) != 0 )
  {
    result = (unsigned int (__cdecl *)(unsigned int, unsigned int))_strcpy_sse2;
    if ( (dword_80F1290 & 0x10) == 0 && (dword_80F1270 & 0x200) != 0 )
      return _strcpy_ssse3;
  }
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1270: using guessed type int dword_80F1270;
// 80F1274: using guessed type int dword_80F1274;
// 80F1290: using guessed type int dword_80F1290;

//----- (0806E0C0) --------------------------------------------------------
void __cdecl _strcpy_ia32(int a1, char a2)
{
  __asm { jmp     ecx }
}
// 806E0DF: unbalanced stack, ignored a potential tail call

//----- (0806E150) --------------------------------------------------------
_BYTE *__cdecl strdup(_BYTE *a1)
{
  unsigned int v1; // esi
  _BYTE *v2; // edx
  _BYTE *result; // eax

  v1 = strlen(a1) + 1;
  v2 = (_BYTE *)malloc(v1);
  result = 0;
  if ( v2 )
    return memcpy(v2, a1, v1);
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);

//----- (0806E1A0) --------------------------------------------------------
char *__usercall strerror_r@<eax>(long double a1@<st0>, signed int a2, _BYTE *a3, unsigned int a4)
{
  _BYTE *v4; // esi
  char *v5; // eax
  char *v7; // edx
  unsigned int v8; // kr04_4
  char *v9; // ebx
  unsigned int v10; // eax
  _WORD *v11; // eax
  unsigned int v12; // ecx
  char *v13; // edx
  char *v14; // edx
  unsigned int v15; // ecx
  unsigned int v16; // edi
  unsigned int v17; // eax
  _WORD *v18; // eax
  unsigned int v19; // [esp+18h] [ebp-44h]
  char *v20; // [esp+1Ch] [ebp-40h]
  char *v21; // [esp+1Ch] [ebp-40h]
  char v22; // [esp+3Fh] [ebp-1Dh] BYREF
  char v23[12]; // [esp+40h] [ebp-1Ch] BYREF

  v4 = a3;
  if ( a2 < 0 )
  {
    v14 = dcgettext(a1, "libc", "Unknown error ", 5);
    v15 = strlen(v14) + 1;
    v21 = v14;
    v22 = 0;
    v16 = v15 - 1;
    v19 = v15;
    v9 = itoa_word(-a2, &v22, 0xAu, 0);
    v17 = a4;
    if ( v16 <= a4 )
      v17 = v16;
    v18 = mempcpy(a3, v21, v17);
    v12 = v19;
    if ( v16 >= a4 )
      goto LABEL_13;
    *(_BYTE *)v18 = 45;
    v11 = (_WORD *)((char *)v18 + 1);
  }
  else
  {
    if ( a2 < sys_nerr )
    {
      v5 = (char *)sys_errlist[a2];
      if ( v5 )
        return dcgettext(a1, "libc", v5, 5);
    }
    v7 = dcgettext(a1, "libc", "Unknown error ", 5);
    v8 = strlen(v7) + 1;
    v20 = v7;
    v22 = 0;
    v9 = itoa_word(a2, &v22, 0xAu, 0);
    v10 = a4;
    if ( v8 - 1 <= a4 )
      v10 = v8 - 1;
    v11 = mempcpy(a3, v20, v10);
    v12 = v8 - 1;
  }
  if ( v12 < a4 )
  {
    v13 = (char *)(a4 - v12);
    if ( v23 - v9 <= a4 - v12 )
      v13 = (char *)(v23 - v9);
    memcpy(v11, v9, (unsigned int)v13);
  }
LABEL_13:
  if ( a4 )
    a3[a4 - 1] = 0;
  return v4;
}
// 80DDC3C: using guessed type int sys_nerr;

//----- (0806E350) --------------------------------------------------------
int (__cdecl *strnlen())(_BYTE *a1, int a2)
{
  int (__cdecl *result)(_BYTE *, int); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = _strnlen_ia32;
  if ( (dword_80F1274 & 0x4000000) != 0 )
    return (int (__cdecl *)(_BYTE *, int))_strnlen_sse2;
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1274: using guessed type int dword_80F1274;

//----- (0806E390) --------------------------------------------------------
unsigned int (__cdecl *strncpy())(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int (__cdecl *result)(unsigned int, unsigned int, unsigned int); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (unsigned int (__cdecl *)(unsigned int, unsigned int, unsigned int))_strncpy_ia32;
  if ( (dword_80F1274 & 0x4000000) != 0 )
  {
    result = (unsigned int (__cdecl *)(unsigned int, unsigned int, unsigned int))_strncpy_sse2;
    if ( (dword_80F1290 & 0x10) == 0 && (dword_80F1270 & 0x200) != 0 )
      return _strncpy_ssse3;
  }
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1270: using guessed type int dword_80F1270;
// 80F1274: using guessed type int dword_80F1274;
// 80F1290: using guessed type int dword_80F1290;

//----- (0806E3E0) --------------------------------------------------------
const __m128i *(__usercall *strrchr())@<eax>(const __m128i *a1@<esi>, const __m128i *a2, unsigned int a3)
{
  const __m128i *(__usercall *result)@<eax>(const __m128i *@<esi>, const __m128i *, unsigned int); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (const __m128i *(__usercall *)@<eax>(const __m128i *@<esi>, const __m128i *, unsigned int))_strrchr_ia32;
  if ( (dword_80F1274 & 0x4000000) != 0 )
  {
    result = (const __m128i *(__usercall *)@<eax>(const __m128i *@<esi>, const __m128i *, unsigned int))_strrchr_sse2_bsf;
    if ( (dword_80F1290 & 4) != 0 )
      return _strrchr_sse2;
  }
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1274: using guessed type int dword_80F1274;
// 80F1290: using guessed type int dword_80F1290;

//----- (0806E430) --------------------------------------------------------
unsigned int *__cdecl _strrchr_ia32(unsigned int *a1, int a2)
{
  unsigned int *result; // eax
  unsigned int *v3; // esi
  int v4; // ecx
  __int16 v5; // dx
  int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // edx
  unsigned int v9; // edx

  result = 0;
  v3 = a1;
  v4 = a2;
  BYTE1(v4) = a2;
  v5 = v4;
  v6 = v4 << 16;
  LOWORD(v6) = v5;
  if ( ((unsigned __int8)a1 & 3) == 0 )
  {
    while ( 1 )
    {
LABEL_27:
      v7 = *v3;
      if ( *v3 < 0x1010101 || (v7 ^ (*v3 - 16843009) | 0xFEFEFEFF) != -1 )
      {
LABEL_47:
        if ( (_BYTE)v7 == (_BYTE)v6 )
          result = v3;
        if ( (_BYTE)v7 )
        {
          if ( BYTE1(v7) == (_BYTE)v6 )
            result = (unsigned int *)((char *)v3 + 1);
          if ( BYTE1(v7) )
          {
            v9 = HIWORD(v7);
            if ( (_BYTE)v9 == (_BYTE)v6 )
              result = (unsigned int *)((char *)v3 + 2);
            if ( (_BYTE)v9 && BYTE1(v9) == (_BYTE)v6 )
              return (unsigned int *)((char *)v3 + 3);
          }
        }
        return result;
      }
      v8 = v6 ^ v7;
      if ( v8 < 0x1010101 )
      {
        --v3;
LABEL_15:
        --v3;
LABEL_16:
        --v3;
LABEL_17:
        if ( (v8 & 0xFF000000) == 0 )
        {
          result = (unsigned int *)((char *)v3 + 15);
          goto LABEL_26;
        }
        goto LABEL_22;
      }
      if ( (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v7 = v3[1];
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_46;
      v8 = v6 ^ v7;
      if ( v8 < 0x1010101 )
        goto LABEL_15;
      if ( (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_20;
      v7 = v3[2];
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_45;
      v8 = v6 ^ v7;
      if ( v8 < 0x1010101 )
        goto LABEL_16;
      if ( (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) == -1 )
      {
        v7 = v3[3];
        if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        {
          ++v3;
LABEL_45:
          ++v3;
LABEL_46:
          ++v3;
          goto LABEL_47;
        }
        v8 = v6 ^ v7;
        if ( v8 >= 0x1010101 )
        {
          if ( (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) == -1 )
            goto LABEL_26;
          goto LABEL_22;
        }
        goto LABEL_17;
      }
LABEL_21:
      --v3;
LABEL_22:
      if ( (v8 & 0xFF0000) != 0 )
      {
        result = v3 + 3;
        if ( !BYTE1(v8) )
          result = (unsigned int *)((char *)v3 + 13);
      }
      else
      {
        result = (unsigned int *)((char *)v3 + 14);
      }
LABEL_26:
      v3 += 4;
    }
    --v3;
LABEL_20:
    --v3;
    goto LABEL_21;
  }
  if ( (_BYTE)v5 == *(_BYTE *)a1 )
    result = a1;
  if ( *(_BYTE *)a1 )
  {
    v3 = (unsigned int *)((char *)a1 + 1);
    if ( (((unsigned int)a1 + 1) & 3) == 0 )
      goto LABEL_27;
    if ( (_BYTE)v5 == *(_BYTE *)v3 )
      result = (unsigned int *)((char *)a1 + 1);
    if ( *(_BYTE *)v3 )
    {
      v3 = (unsigned int *)((char *)a1 + 2);
      if ( (((unsigned int)a1 + 2) & 3) == 0 )
        goto LABEL_27;
      if ( (_BYTE)v5 == *(_BYTE *)v3 )
        result = (unsigned int *)((char *)a1 + 2);
      if ( *(_BYTE *)v3 )
      {
        v3 = (unsigned int *)((char *)a1 + 3);
        goto LABEL_27;
      }
    }
  }
  return result;
}

//----- (0806E5F0) --------------------------------------------------------
int (__cdecl *memchr())(const __m128i *a1, unsigned int a2, unsigned int a3)
{
  if ( !_cpu_features )
    _init_cpu_features();
  if ( (dword_80F1274 & 0x4000000) == 0 )
    return (int (__cdecl *)(const __m128i *, unsigned int, unsigned int))_memchr_ia32;
  if ( (dword_80F1290 & 4) != 0 )
    return (int (__cdecl *)(const __m128i *, unsigned int, unsigned int))_memchr_sse2;
  return _memchr_sse2_bsf;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1274: using guessed type int dword_80F1274;
// 80F1290: using guessed type int dword_80F1290;

//----- (0806E640) --------------------------------------------------------
_BYTE *__cdecl _memchr_ia32(_BYTE *a1, int a2, unsigned int a3)
{
  _BYTE *result; // eax
  int v4; // edx
  unsigned int v5; // esi
  __int16 v6; // cx
  unsigned int v7; // ecx
  bool v8; // cf
  int v9; // esi
  int v10; // esi

  result = a1;
  v4 = a2;
  v5 = a3;
  if ( a3 < 4 )
  {
LABEL_31:
    v9 = v5 & 3;
    if ( !v9 )
      return 0;
    if ( *result != (_BYTE)v4 )
    {
      ++result;
      v10 = v9 - 1;
      if ( !v10 )
        return 0;
      if ( *result != (_BYTE)v4 )
      {
        ++result;
        if ( v10 == 1 || *result != (_BYTE)v4 )
          return 0;
      }
    }
  }
  else
  {
    BYTE1(v4) = a2;
    v6 = v4;
    v4 <<= 16;
    LOWORD(v4) = v6;
    if ( ((unsigned __int8)a1 & 3) == 0 )
      goto LABEL_20;
    if ( *a1 != (_BYTE)v6 )
    {
      result = a1 + 1;
      v5 = a3 - 1;
      if ( ((unsigned __int8)result & 3) != 0 )
      {
        if ( *result != (_BYTE)v6 )
        {
          result = a1 + 2;
          v5 = a3 - 2;
          if ( ((unsigned __int8)result & 3) == 0 )
            goto LABEL_20;
          if ( *result != (_BYTE)v6 )
          {
            result = a1 + 3;
            v5 = a3 - 3;
            goto LABEL_20;
          }
        }
      }
      else
      {
LABEL_20:
        while ( 1 )
        {
          v8 = v5 < 0x10;
          v5 -= 16;
          if ( v8 )
            break;
          v7 = v4 ^ *(_DWORD *)result;
          if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
            goto LABEL_41;
          v7 = v4 ^ *((_DWORD *)result + 1);
          if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
            goto LABEL_40;
          v7 = v4 ^ *((_DWORD *)result + 2);
          if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
            goto LABEL_39;
          v7 = v4 ^ *((_DWORD *)result + 3);
          if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
          {
            result += 4;
LABEL_39:
            result += 4;
LABEL_40:
            result += 4;
            goto LABEL_41;
          }
          result += 16;
        }
        if ( v5 < 0xFFFFFFF4 )
          goto LABEL_31;
        v7 = v4 ^ *(_DWORD *)result;
        if ( v7 >= 0x1010101 && (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) == -1 )
        {
          result += 4;
          if ( v5 < 0xFFFFFFF8 )
            goto LABEL_31;
          v7 = v4 ^ *(_DWORD *)result;
          if ( v7 >= 0x1010101 && (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) == -1 )
          {
            result += 4;
            if ( v5 < 0xFFFFFFFC )
              goto LABEL_31;
            v7 = v4 ^ *(_DWORD *)result;
            if ( v7 >= 0x1010101 && (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) == -1 )
            {
              result += 4;
              goto LABEL_31;
            }
          }
        }
LABEL_41:
        if ( (_BYTE)v7 )
        {
          ++result;
          if ( BYTE1(v7) )
          {
            ++result;
            if ( (v7 & 0xFF0000) != 0 )
              ++result;
          }
        }
      }
    }
  }
  return result;
}
// 806E673: conditional instruction was optimized away because %arg_8.4>=4u
// 806E68B: conditional instruction was optimized away because %arg_8.4>=4u

//----- (0806E7E0) --------------------------------------------------------
unsigned int (__usercall *memmove())@<eax>(const __m128i *a1@<esi>, unsigned int a2, _DWORD *a3, unsigned int a4)
{
  unsigned int (__usercall *result)@<eax>(const __m128i *@<esi>, unsigned int, _DWORD *, unsigned int); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (unsigned int (__usercall *)@<eax>(const __m128i *@<esi>, unsigned int, _DWORD *, unsigned int))_memmove_ia32;
  if ( (dword_80F1270 & 0x200) != 0 )
  {
    result = (unsigned int (__usercall *)@<eax>(const __m128i *@<esi>, unsigned int, _DWORD *, unsigned int))_memmove_ssse3;
    if ( (dword_80F1290 & 1) != 0 )
      return _memmove_ssse3_rep;
  }
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1270: using guessed type int dword_80F1270;
// 80F1290: using guessed type int dword_80F1290;

//----- (0806E820) --------------------------------------------------------
_BYTE *__cdecl _memmove_ia32(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  _WORD *v3; // edi
  _WORD *v4; // esi
  _BYTE *v6; // edi
  _BYTE *v7; // esi
  _WORD *v8; // edi
  _WORD *v9; // esi

  v3 = a1;
  v4 = a2;
  if ( (unsigned int)a1 >= a1 - a2 )
  {
    v6 = &a1[a3 - 1];
    v7 = &a2[a3 - 1];
    if ( a3 & 1 )
    {
      *v6 = *v7;
      v7 = &a2[a3 - 2];
      v6 = &a1[a3 - 2];
    }
    v8 = v6 - 1;
    v9 = v7 - 1;
    if ( (a3 & 2) != 0 )
      *v8++ = *v9++;
    qmemcpy(v8 - 1, v9 - 1, 4 * (a3 >> 2));
    return a1;
  }
  else
  {
    if ( a3 & 1 )
    {
      *a1 = *a2;
      v4 = a2 + 1;
      v3 = a1 + 1;
    }
    if ( (a3 & 2) != 0 )
      *v3++ = *v4++;
    qmemcpy(v3, v4, 4 * (a3 >> 2));
    return a1;
  }
}

//----- (0806E880) --------------------------------------------------------
unsigned int (__cdecl *stpcpy())(unsigned int a1, unsigned int a2)
{
  unsigned int (__cdecl *result)(unsigned int, unsigned int); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (unsigned int (__cdecl *)(unsigned int, unsigned int))_stpcpy_ia32;
  if ( (dword_80F1274 & 0x4000000) != 0 )
  {
    result = (unsigned int (__cdecl *)(unsigned int, unsigned int))_stpcpy_sse2;
    if ( (dword_80F1290 & 0x10) == 0 && (dword_80F1270 & 0x200) != 0 )
      return _stpcpy_ssse3;
  }
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1270: using guessed type int dword_80F1270;
// 80F1274: using guessed type int dword_80F1274;
// 80F1290: using guessed type int dword_80F1290;

//----- (0806E8D0) --------------------------------------------------------
void __cdecl _stpcpy_ia32(int a1, char a2)
{
  __asm { jmp     ecx }
}
// 806E8EF: unbalanced stack, ignored a potential tail call

//----- (0806E960) --------------------------------------------------------
int (__cdecl *strcasecmp_l())(int a1, int a2, int a3)
{
  int (__cdecl *result)(int, int, int); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (int (__cdecl *)(int, int, int))_strcasecmp_l_ia32;
  if ( (dword_80F1270 & 0x200) != 0 )
  {
    result = _strcasecmp_l_ssse3;
    if ( (dword_80F1270 & 0x100000) != 0 )
      return _strcasecmp_l_sse4_2;
  }
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1270: using guessed type int dword_80F1270;

//----- (0806E9A0) --------------------------------------------------------
int __cdecl _strcasecmp_l_ia32(char *a1, _BYTE *a2)
{
  char v4; // al
  int result; // eax

  while ( 1 )
  {
    v4 = *a1;
    if ( *a1 != *a2 )
      break;
    ++a1;
    ++a2;
    if ( !v4 )
      return 0;
  }
  result = 1;
  if ( (unsigned __int8)*a1 < *a2 )
    return -1;
  return result;
}

//----- (0806E9D0) --------------------------------------------------------
int (__cdecl *rawmemchr())(const __m128i *a1, unsigned int a2)
{
  if ( !_cpu_features )
    _init_cpu_features();
  if ( (dword_80F1274 & 0x4000000) == 0 )
    return (int (__cdecl *)(const __m128i *, unsigned int))_rawmemchr_ia32;
  if ( (dword_80F1290 & 4) != 0 )
    return (int (__cdecl *)(const __m128i *, unsigned int))_rawmemchr_sse2;
  return _rawmemchr_sse2_bsf;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1274: using guessed type int dword_80F1274;
// 80F1290: using guessed type int dword_80F1290;

//----- (0806EA20) --------------------------------------------------------
_BYTE *__cdecl _rawmemchr_ia32(_BYTE *a1, int a2)
{
  _BYTE *result; // eax
  int v3; // edx
  __int16 v4; // cx
  int v5; // edx
  unsigned int v6; // ecx

  result = a1;
  v3 = a2;
  BYTE1(v3) = a2;
  v4 = v3;
  v5 = v3 << 16;
  LOWORD(v5) = v4;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( *a1 != (_BYTE)v4 )
    {
      result = a1 + 1;
      if ( (((_BYTE)a1 + 1) & 3) == 0 )
        goto LABEL_8;
      if ( *result != (_BYTE)v4 )
      {
        result = a1 + 2;
        if ( (((_BYTE)a1 + 2) & 3) == 0 )
          goto LABEL_8;
        if ( *result != (_BYTE)v4 )
        {
          result = a1 + 3;
          goto LABEL_8;
        }
      }
    }
  }
  else
  {
LABEL_8:
    while ( 1 )
    {
      v6 = v5 ^ *(_DWORD *)result;
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v6 = v5 ^ *((_DWORD *)result + 1);
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_19;
      v6 = v5 ^ *((_DWORD *)result + 2);
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_18;
      v6 = v5 ^ *((_DWORD *)result + 3);
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
      {
        result += 4;
LABEL_18:
        result += 4;
LABEL_19:
        result += 4;
        break;
      }
      result += 16;
    }
    if ( (_BYTE)v6 )
    {
      ++result;
      if ( BYTE1(v6) )
      {
        ++result;
        if ( (v6 & 0xFF0000) != 0 )
          ++result;
      }
    }
  }
  return result;
}

//----- (0806EAF0) --------------------------------------------------------
int __cdecl argz_count(_BYTE *a1, int a2)
{
  int v2; // edi
  int i; // ebx
  int v5; // eax

  v2 = 0;
  for ( i = a2; i; i += ~v5 )
  {
    ++v2;
    v5 = strlen(a1);
    a1 += v5 + 1;
  }
  return v2;
}

//----- (0806EB30) --------------------------------------------------------
void __cdecl argz_stringify(_BYTE *a1, int a2, char a3)
{
  int v3; // ebx
  _BYTE *v5; // esi
  int v6; // eax
  bool v7; // cc

  v3 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      v6 = strnlen(a1, v3);
      v7 = (unsigned int)(v3 - v6) <= 1;
      v3 = v3 - v6 - 1;
      if ( v7 )
        break;
      v5 = &a1[v6];
      *v5 = a3;
      a1 = v5 + 1;
    }
  }
}
// 8048210: using guessed type int __cdecl strnlen(_DWORD, _DWORD);

//----- (0806EB70) --------------------------------------------------------
unsigned int __usercall _memmove_chk_ssse3@<eax>(
        const __m128i *a1@<esi>,
        long double fst7_0@<st0>,
        unsigned int a2,
        _QWORD *a3,
        unsigned int a4,
        unsigned int a6)
{
  if ( a6 < a4 )
    _chk_fail(fst7_0);
  return _memmove_ssse3(a1, a2, a3, a4);
}

//----- (0806EB80) --------------------------------------------------------
unsigned int __usercall _memmove_ssse3@<eax>(const __m128i *a1@<esi>, unsigned int a2, _QWORD *a3, unsigned int a4)
{
  unsigned int v4; // ecx
  _QWORD *v5; // eax
  unsigned int v6; // edx
  unsigned int v7; // edx
  const __m128i *v8; // eax
  __m128i v9; // xmm0
  unsigned int v10; // edx
  __m128i *v11; // esi
  unsigned int v12; // edi
  unsigned int v13; // ecx
  const __m128i *v14; // eax
  unsigned int v15; // ecx
  __m128i v16; // xmm1
  bool v17; // cf
  unsigned int v18; // ecx
  int v19; // edi
  __m128i v20; // xmm1
  __m128i v21; // xmm1
  __m128i v22; // xmm1
  unsigned int v23; // ecx
  unsigned int v24; // edi
  unsigned int v25; // ecx
  __m128i v26; // xmm0
  __m128i v27; // xmm1
  __m128i v28; // xmm2
  __m128i v29; // xmm3
  __m128i v30; // xmm4
  __m128i v31; // xmm5
  __m128i v32; // xmm6
  __m128i v33; // xmm7
  bool v34; // cc
  unsigned int v35; // ecx
  __m128i v36; // xmm1
  __m128i v37; // xmm0
  __m128i v38; // xmm1
  __m128i v39; // xmm0
  __m128i v40; // xmm1
  __m128i v41; // xmm0
  __m128i v42; // xmm0
  __m128i v43; // xmm1
  __m128i v44; // xmm2
  __m128i v45; // xmm3
  __m128i v46; // xmm4
  __m128i v47; // xmm5
  __m128i v48; // xmm6
  __m128i v49; // xmm7
  unsigned int v50; // ecx
  __m128i v51; // xmm1
  __m128i v52; // xmm0
  __m128i v53; // xmm1
  __m128i v54; // xmm0
  __m128i v55; // xmm1
  __m128i v56; // xmm0
  __m128i *v57; // eax
  __m128i v58; // xmm1
  int v59; // edi
  unsigned int v60; // ecx
  __m128i si128; // xmm2
  __m128i v62; // xmm4
  __m128i v63; // xmm2
  unsigned int v64; // ecx
  unsigned int v65; // edi
  __m128i *v66; // eax
  __m128i v67; // xmm1
  int v68; // edi
  unsigned int v69; // ecx
  __m128i v70; // xmm2
  __m128i v71; // xmm4
  __m128i v72; // xmm2
  unsigned int v73; // ecx
  unsigned int v74; // edi
  __m128i *v75; // eax
  __m128i v76; // xmm1
  int v77; // edi
  unsigned int v78; // ecx
  __m128i v79; // xmm2
  __m128i v80; // xmm4
  __m128i v81; // xmm2
  unsigned int v82; // ecx
  unsigned int v83; // edi
  __m128i *v84; // eax
  __m128i v85; // xmm1
  int v86; // edi
  unsigned int v87; // ecx
  __m128i v88; // xmm2
  __m128i v89; // xmm4
  __m128i v90; // xmm2
  unsigned int v91; // ecx
  unsigned int v92; // edi
  __m128i *v93; // eax
  __m128i v94; // xmm1
  int v95; // edi
  unsigned int v96; // ecx
  __m128i v97; // xmm2
  __m128i v98; // xmm4
  __m128i v99; // xmm2
  unsigned int v100; // ecx
  unsigned int v101; // edi
  __m128i *v102; // eax
  __m128i v103; // xmm1
  int v104; // edi
  unsigned int v105; // ecx
  __m128i v106; // xmm2
  __m128i v107; // xmm4
  __m128i v108; // xmm2
  unsigned int v109; // ecx
  unsigned int v110; // edi
  __m128i *v111; // eax
  __m128i v112; // xmm1
  int v113; // edi
  unsigned int v114; // ecx
  __m128i v115; // xmm2
  __m128i v116; // xmm4
  __m128i v117; // xmm2
  unsigned int v118; // ecx
  unsigned int v119; // edi
  __m128i *v120; // eax
  __m128i v121; // xmm1
  int v122; // edi
  unsigned int v123; // ecx
  __m128i v124; // xmm2
  __m128i v125; // xmm4
  __m128i v126; // xmm2
  unsigned int v127; // ecx
  unsigned int v128; // edi
  __m128i *v129; // eax
  __m128i v130; // xmm1
  int v131; // edi
  unsigned int v132; // ecx
  __m128i v133; // xmm2
  __m128i v134; // xmm4
  __m128i v135; // xmm2
  unsigned int v136; // ecx
  unsigned int v137; // edi
  __m128i *v138; // eax
  __m128i v139; // xmm1
  int v140; // edi
  unsigned int v141; // ecx
  __m128i v142; // xmm2
  __m128i v143; // xmm4
  __m128i v144; // xmm2
  unsigned int v145; // ecx
  unsigned int v146; // edi
  __m128i *v147; // eax
  __m128i v148; // xmm1
  int v149; // edi
  unsigned int v150; // ecx
  __m128i v151; // xmm2
  __m128i v152; // xmm4
  __m128i v153; // xmm2
  unsigned int v154; // ecx
  unsigned int v155; // edi
  __m128i *v156; // eax
  __m128i v157; // xmm1
  int v158; // edi
  unsigned int v159; // ecx
  __m128i v160; // xmm2
  __m128i v161; // xmm4
  __m128i v162; // xmm2
  unsigned int v163; // ecx
  unsigned int v164; // edi
  __m128i *v165; // eax
  __m128i v166; // xmm1
  int v167; // edi
  unsigned int v168; // ecx
  __m128i v169; // xmm2
  __m128i v170; // xmm4
  __m128i v171; // xmm2
  unsigned int v172; // ecx
  unsigned int v173; // edi
  __m128i *v174; // eax
  __m128i v175; // xmm1
  int v176; // edi
  unsigned int v177; // ecx
  __m128i v178; // xmm2
  __m128i v179; // xmm4
  __m128i v180; // xmm2
  unsigned int v181; // ecx
  unsigned int v182; // edi
  __m128i *v183; // eax
  __m128i v184; // xmm1
  int v185; // edi
  unsigned int v186; // ecx
  __m128i v187; // xmm2
  __m128i v188; // xmm4
  __m128i v189; // xmm2
  unsigned int v190; // ecx
  unsigned int v191; // edi
  unsigned int result; // eax
  __int32 v193; // ecx
  __int32 v194; // eax
  __int16 v195; // cx
  __int8 v196; // al
  __int32 v197; // ecx
  __int32 v198; // eax
  __int16 v199; // cx
  __int8 v200; // al
  __int16 v201; // cx
  __int8 v202; // al
  __int16 v203; // cx
  __int8 v204; // al
  __int16 v205; // cx
  __int8 v206; // al
  __m128i v207; // xmm1
  const __m128i *v208; // eax
  __m128i *v209; // edx
  int v210; // ecx
  __m128i v211; // xmm0
  __m128i v212; // xmm1
  __m128i v213; // xmm2
  __m128i v214; // xmm3
  __m128i v215; // xmm4
  __m128i v216; // xmm5
  __m128i v217; // xmm6
  __m128i v218; // xmm7
  int v219; // ecx
  __m128i v220; // xmm0
  __m128i v221; // xmm1
  __m128i v222; // xmm2
  __m128i v223; // xmm3
  __m128i v224; // xmm0
  __m128i v225; // xmm1
  const __m128i *v226; // [esp-4h] [ebp-4h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( a2 < (unsigned int)a3 )
    goto LABEL_5;
  if ( (_QWORD *)a2 == a3 )
    return a2;
  if ( a4 >= 0x20 )
  {
    v5 = a3;
    if ( a2 >= (unsigned int)a3 + a4 )
    {
LABEL_5:
      v7 = a4 + a2;
      v8 = (const __m128i *)((char *)v5 + a4);
      switch ( a4 )
      {
        case 0u:
          return a2;
        case 1u:
          goto LABEL_115;
        case 2u:
          goto LABEL_127;
        case 3u:
          goto LABEL_138;
        case 4u:
          goto LABEL_97;
        case 5u:
LABEL_104:
          v193 = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
          v194 = v8[-1].m128i_i32[3];
          *(_DWORD *)(v7 - 5) = v193;
          *(_DWORD *)(v7 - 4) = v194;
          return a2;
        case 6u:
          goto LABEL_121;
        case 7u:
          goto LABEL_172;
        case 8u:
          goto LABEL_102;
        case 9u:
          goto LABEL_114;
        case 0xAu:
          goto LABEL_126;
        case 0xBu:
          goto LABEL_137;
        case 0xCu:
          goto LABEL_96;
        case 0xDu:
          goto LABEL_109;
        case 0xEu:
          goto LABEL_120;
        case 0xFu:
          goto LABEL_132;
        case 0x10u:
          goto LABEL_101;
        case 0x11u:
          goto LABEL_113;
        case 0x12u:
          goto LABEL_125;
        case 0x13u:
          goto LABEL_136;
        case 0x14u:
          goto LABEL_95;
        case 0x15u:
          goto LABEL_108;
        case 0x16u:
          goto LABEL_119;
        case 0x17u:
          goto LABEL_131;
        case 0x18u:
          goto LABEL_100;
        case 0x19u:
          goto LABEL_112;
        case 0x1Au:
          goto LABEL_124;
        case 0x1Bu:
          goto LABEL_135;
        case 0x1Cu:
          goto LABEL_94;
        case 0x1Du:
          goto LABEL_107;
        case 0x1Eu:
          goto LABEL_118;
        case 0x1Fu:
          goto LABEL_130;
        case 0x20u:
          goto LABEL_99;
        case 0x21u:
          goto LABEL_111;
        case 0x22u:
          goto LABEL_123;
        case 0x23u:
          goto LABEL_134;
        case 0x24u:
          goto LABEL_93;
        case 0x25u:
          goto LABEL_106;
        case 0x26u:
          goto LABEL_117;
        case 0x27u:
          goto LABEL_129;
        case 0x28u:
LABEL_98:
          *(_QWORD *)(v7 - 40) = v8[-3].m128i_i64[1];
LABEL_99:
          *(_QWORD *)(v7 - 32) = v8[-2].m128i_i64[0];
LABEL_100:
          *(_QWORD *)(v7 - 24) = v8[-2].m128i_i64[1];
LABEL_101:
          *(_QWORD *)(v7 - 16) = v8[-1].m128i_i64[0];
LABEL_102:
          *(_QWORD *)(v7 - 8) = v8[-1].m128i_i64[1];
          return a2;
        case 0x29u:
LABEL_110:
          *(_QWORD *)(v7 - 41) = *(__int64 *)((char *)v8[-3].m128i_i64 + 7);
LABEL_111:
          *(_QWORD *)(v7 - 33) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 7);
LABEL_112:
          *(_QWORD *)(v7 - 25) = *(__int64 *)((char *)v8[-2].m128i_i64 + 7);
LABEL_113:
          *(_QWORD *)(v7 - 17) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 7);
LABEL_114:
          *(_QWORD *)(v7 - 9) = *(__int64 *)((char *)v8[-1].m128i_i64 + 7);
LABEL_115:
          *(_BYTE *)(v7 - 1) = v8[-1].m128i_i8[15];
          return a2;
        case 0x2Au:
LABEL_122:
          *(_QWORD *)(v7 - 42) = *(__int64 *)((char *)v8[-3].m128i_i64 + 6);
LABEL_123:
          *(_QWORD *)(v7 - 34) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 6);
LABEL_124:
          *(_QWORD *)(v7 - 26) = *(__int64 *)((char *)v8[-2].m128i_i64 + 6);
LABEL_125:
          *(_QWORD *)(v7 - 18) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 6);
LABEL_126:
          *(_QWORD *)(v7 - 10) = *(__int64 *)((char *)v8[-1].m128i_i64 + 6);
LABEL_127:
          *(_WORD *)(v7 - 2) = v8[-1].m128i_i16[7];
          return a2;
        case 0x2Bu:
LABEL_133:
          *(_QWORD *)(v7 - 43) = *(__int64 *)((char *)v8[-3].m128i_i64 + 5);
LABEL_134:
          *(_QWORD *)(v7 - 35) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 5);
LABEL_135:
          *(_QWORD *)(v7 - 27) = *(__int64 *)((char *)v8[-2].m128i_i64 + 5);
LABEL_136:
          *(_QWORD *)(v7 - 19) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 5);
LABEL_137:
          *(_QWORD *)(v7 - 11) = *(__int64 *)((char *)v8[-1].m128i_i64 + 5);
LABEL_138:
          v195 = *(__int16 *)((char *)&v8[-1].m128i_i16[6] + 1);
          v196 = v8[-1].m128i_i8[15];
          *(_WORD *)(v7 - 3) = v195;
          *(_BYTE *)(v7 - 1) = v196;
          return a2;
        case 0x2Cu:
LABEL_92:
          *(_QWORD *)(v7 - 44) = *(__int64 *)((char *)v8[-3].m128i_i64 + 4);
LABEL_93:
          *(_QWORD *)(v7 - 36) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 4);
LABEL_94:
          *(_QWORD *)(v7 - 28) = *(__int64 *)((char *)v8[-2].m128i_i64 + 4);
LABEL_95:
          *(_QWORD *)(v7 - 20) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 4);
LABEL_96:
          *(_QWORD *)(v7 - 12) = *(__int64 *)((char *)v8[-1].m128i_i64 + 4);
LABEL_97:
          *(_DWORD *)(v7 - 4) = v8[-1].m128i_i32[3];
          return a2;
        case 0x2Du:
LABEL_105:
          *(_QWORD *)(v7 - 45) = *(__int64 *)((char *)v8[-3].m128i_i64 + 3);
LABEL_106:
          *(_QWORD *)(v7 - 37) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 3);
LABEL_107:
          *(_QWORD *)(v7 - 29) = *(__int64 *)((char *)v8[-2].m128i_i64 + 3);
LABEL_108:
          *(_QWORD *)(v7 - 21) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 3);
LABEL_109:
          *(_QWORD *)(v7 - 13) = *(__int64 *)((char *)v8[-1].m128i_i64 + 3);
          *(_DWORD *)(v7 - 5) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
          *(_BYTE *)(v7 - 1) = v8[-1].m128i_i8[15];
          return a2;
        case 0x2Eu:
LABEL_116:
          *(_QWORD *)(v7 - 46) = *(__int64 *)((char *)v8[-3].m128i_i64 + 2);
LABEL_117:
          *(_QWORD *)(v7 - 38) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 2);
LABEL_118:
          *(_QWORD *)(v7 - 30) = *(__int64 *)((char *)v8[-2].m128i_i64 + 2);
LABEL_119:
          *(_QWORD *)(v7 - 22) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 2);
LABEL_120:
          *(_QWORD *)(v7 - 14) = *(__int64 *)((char *)v8[-1].m128i_i64 + 2);
LABEL_121:
          *(_DWORD *)(v7 - 6) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 2);
          *(_WORD *)(v7 - 2) = v8[-1].m128i_i16[7];
          return a2;
        case 0x2Fu:
LABEL_128:
          *(_QWORD *)(v7 - 47) = *(__int64 *)((char *)v8[-3].m128i_i64 + 1);
LABEL_129:
          *(_QWORD *)(v7 - 39) = *(__int64 *)((char *)&v8[-3].m128i_i64[1] + 1);
LABEL_130:
          *(_QWORD *)(v7 - 31) = *(__int64 *)((char *)v8[-2].m128i_i64 + 1);
LABEL_131:
          *(_QWORD *)(v7 - 23) = *(__int64 *)((char *)&v8[-2].m128i_i64[1] + 1);
LABEL_132:
          *(_QWORD *)(v7 - 15) = *(__int64 *)((char *)v8[-1].m128i_i64 + 1);
LABEL_172:
          *(_DWORD *)(v7 - 7) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 1);
          v199 = *(__int16 *)((char *)&v8[-1].m128i_i16[6] + 1);
          v200 = v8[-1].m128i_i8[15];
          *(_WORD *)(v7 - 3) = v199;
          *(_BYTE *)(v7 - 1) = v200;
          return a2;
        default:
          v9 = _mm_loadu_si128(v8);
          v10 = (v7 & 0xFFFFFFF0) + 16;
          v11 = (__m128i *)(a4 + a2);
          v12 = a4 + a2 - v10;
          v13 = v12 + a4;
          v14 = (const __m128i *)((char *)v8 - v12);
          if ( v12 + a4 >= _x86_shared_cache_size_half )
          {
            v207 = _mm_loadu_si128(v14);
            v208 = v14 + 1;
            *v11 = v9;
            _mm_stream_si128((__m128i *)v10, v207);
            v209 = (__m128i *)(v10 + 16);
            v210 = v13 - 144;
            do
            {
              v211 = _mm_loadu_si128(v208);
              v212 = _mm_loadu_si128(v208 + 1);
              v213 = _mm_loadu_si128(v208 + 2);
              v214 = _mm_loadu_si128(v208 + 3);
              v215 = _mm_loadu_si128(v208 + 4);
              v216 = _mm_loadu_si128(v208 + 5);
              v217 = _mm_loadu_si128(v208 + 6);
              v218 = _mm_loadu_si128(v208 + 7);
              v208 += 8;
              v17 = (unsigned int)v210 < 0x80;
              v210 -= 128;
              _mm_stream_si128(v209, v211);
              _mm_stream_si128(v209 + 1, v212);
              _mm_stream_si128(v209 + 2, v213);
              _mm_stream_si128(v209 + 3, v214);
              _mm_stream_si128(v209 + 4, v215);
              _mm_stream_si128(v209 + 5, v216);
              _mm_stream_si128(v209 + 6, v217);
              _mm_stream_si128(v209 + 7, v218);
              v209 += 8;
            }
            while ( !v17 );
            v34 = v210 < -64;
            v219 = v210 + 128;
            if ( !v34 )
            {
              v220 = _mm_loadu_si128(v208);
              v221 = _mm_loadu_si128(v208 + 1);
              v222 = _mm_loadu_si128(v208 + 2);
              v223 = _mm_loadu_si128(v208 + 3);
              v208 += 4;
              _mm_stream_si128(v209, v220);
              _mm_stream_si128(v209 + 1, v221);
              _mm_stream_si128(v209 + 2, v222);
              _mm_stream_si128(v209 + 3, v223);
              v209 += 4;
              v219 -= 64;
            }
            while ( 2 )
            {
              v7 = (unsigned int)v209->m128i_u32 + v219;
              v8 = (const __m128i *)((char *)v208 + v219);
              _mm_sfence();
              switch ( v219 )
              {
                case 0:
                  return a2;
                case 1:
                  goto LABEL_115;
                case 2:
                  goto LABEL_127;
                case 3:
                  goto LABEL_138;
                case 4:
                  goto LABEL_97;
                case 5:
                  goto LABEL_104;
                case 6:
                  goto LABEL_121;
                case 7:
                  goto LABEL_172;
                case 8:
                  goto LABEL_102;
                case 9:
                  goto LABEL_114;
                case 10:
                  goto LABEL_126;
                case 11:
                  goto LABEL_137;
                case 12:
                  goto LABEL_96;
                case 13:
                  goto LABEL_109;
                case 14:
                  goto LABEL_120;
                case 15:
                  goto LABEL_132;
                case 16:
                  goto LABEL_101;
                case 17:
                  goto LABEL_113;
                case 18:
                  goto LABEL_125;
                case 19:
                  goto LABEL_136;
                case 20:
                  goto LABEL_95;
                case 21:
                  goto LABEL_108;
                case 22:
                  goto LABEL_119;
                case 23:
                  goto LABEL_131;
                case 24:
                  goto LABEL_100;
                case 25:
                  goto LABEL_112;
                case 26:
                  goto LABEL_124;
                case 27:
                  goto LABEL_135;
                case 28:
                  goto LABEL_94;
                case 29:
                  goto LABEL_107;
                case 30:
                  goto LABEL_118;
                case 31:
                  goto LABEL_130;
                default:
                  v224 = _mm_loadu_si128(v8);
                  v225 = _mm_loadu_si128(v8 + 1);
                  v208 = v8 + 2;
                  _mm_stream_si128((__m128i *)v7, v224);
                  _mm_stream_si128((__m128i *)(v7 + 16), v225);
                  v209 = (__m128i *)(v7 + 32);
                  v219 -= 32;
                  continue;
              }
            }
          }
          if ( ((unsigned __int8)v14 & 0xF) != 0 )
          {
            switch ( (unsigned __int8)v14 & 0xF )
            {
              case 0:
                break;
              case 1:
                v57 = (__m128i *)&v14[-1].m128i_i8[15];
                v58 = *v57;
                v59 = 0;
                v60 = v13 - 32;
                *v11 = v9;
                do
                {
                  si128 = _mm_load_si128(&v57[v59 + 1]);
                  v17 = v60 < 0x20;
                  v60 -= 32;
                  v62 = _mm_load_si128(&v57[v59 + 2]);
                  v59 += 2;
                  *(__m128i *)(v10 + v59 * 16 - 32) = _mm_alignr_epi8(si128, v58, 1);
                  *(__m128i *)(v10 + v59 * 16 - 16) = _mm_alignr_epi8(v62, si128, 1);
                  if ( v17 )
                    break;
                  v63 = _mm_load_si128(&v57[v59 + 1]);
                  v17 = v60 < 0x20;
                  v60 -= 32;
                  v58 = _mm_load_si128(&v57[v59 + 2]);
                  v59 += 2;
                  *(__m128i *)(v10 + v59 * 16 - 32) = _mm_alignr_epi8(v63, v62, 1);
                  *(__m128i *)(v10 + v59 * 16 - 16) = _mm_alignr_epi8(v58, v63, 1);
                }
                while ( !v17 );
                v64 = v60 + 32;
                v65 = v64 + v59 * 16;
                v7 = v65 + v10;
                v8 = (const __m128i *)&v57->m128i_i8[v65 + 1];
                switch ( v64 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 2:
                v66 = (__m128i *)&v14[-1].m128i_i8[14];
                v67 = *v66;
                v68 = 0;
                v69 = v13 - 32;
                *v11 = v9;
                do
                {
                  v70 = _mm_load_si128(&v66[v68 + 1]);
                  v17 = v69 < 0x20;
                  v69 -= 32;
                  v71 = _mm_load_si128(&v66[v68 + 2]);
                  v68 += 2;
                  *(__m128i *)(v10 + v68 * 16 - 32) = _mm_alignr_epi8(v70, v67, 2);
                  *(__m128i *)(v10 + v68 * 16 - 16) = _mm_alignr_epi8(v71, v70, 2);
                  if ( v17 )
                    break;
                  v72 = _mm_load_si128(&v66[v68 + 1]);
                  v17 = v69 < 0x20;
                  v69 -= 32;
                  v67 = _mm_load_si128(&v66[v68 + 2]);
                  v68 += 2;
                  *(__m128i *)(v10 + v68 * 16 - 32) = _mm_alignr_epi8(v72, v71, 2);
                  *(__m128i *)(v10 + v68 * 16 - 16) = _mm_alignr_epi8(v67, v72, 2);
                }
                while ( !v17 );
                v73 = v69 + 32;
                v74 = v73 + v68 * 16;
                v7 = v74 + v10;
                v8 = (const __m128i *)&v66->m128i_i8[v74 + 2];
                switch ( v73 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 3:
                v75 = (__m128i *)&v14[-1].m128i_i8[13];
                v76 = *v75;
                v77 = 0;
                v78 = v13 - 32;
                *v11 = v9;
                do
                {
                  v79 = _mm_load_si128(&v75[v77 + 1]);
                  v17 = v78 < 0x20;
                  v78 -= 32;
                  v80 = _mm_load_si128(&v75[v77 + 2]);
                  v77 += 2;
                  *(__m128i *)(v10 + v77 * 16 - 32) = _mm_alignr_epi8(v79, v76, 3);
                  *(__m128i *)(v10 + v77 * 16 - 16) = _mm_alignr_epi8(v80, v79, 3);
                  if ( v17 )
                    break;
                  v81 = _mm_load_si128(&v75[v77 + 1]);
                  v17 = v78 < 0x20;
                  v78 -= 32;
                  v76 = _mm_load_si128(&v75[v77 + 2]);
                  v77 += 2;
                  *(__m128i *)(v10 + v77 * 16 - 32) = _mm_alignr_epi8(v81, v80, 3);
                  *(__m128i *)(v10 + v77 * 16 - 16) = _mm_alignr_epi8(v76, v81, 3);
                }
                while ( !v17 );
                v82 = v78 + 32;
                v83 = v82 + v77 * 16;
                v7 = v83 + v10;
                v8 = (const __m128i *)&v75->m128i_i8[v83 + 3];
                switch ( v82 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 4:
                v84 = (__m128i *)&v14[-1].m128i_i8[12];
                v85 = *v84;
                v86 = 0;
                v87 = v13 - 32;
                *v11 = v9;
                do
                {
                  v88 = _mm_load_si128(&v84[v86 + 1]);
                  v17 = v87 < 0x20;
                  v87 -= 32;
                  v89 = _mm_load_si128(&v84[v86 + 2]);
                  v86 += 2;
                  *(__m128i *)(v10 + v86 * 16 - 32) = _mm_alignr_epi8(v88, v85, 4);
                  *(__m128i *)(v10 + v86 * 16 - 16) = _mm_alignr_epi8(v89, v88, 4);
                  if ( v17 )
                    break;
                  v90 = _mm_load_si128(&v84[v86 + 1]);
                  v17 = v87 < 0x20;
                  v87 -= 32;
                  v85 = _mm_load_si128(&v84[v86 + 2]);
                  v86 += 2;
                  *(__m128i *)(v10 + v86 * 16 - 32) = _mm_alignr_epi8(v90, v89, 4);
                  *(__m128i *)(v10 + v86 * 16 - 16) = _mm_alignr_epi8(v85, v90, 4);
                }
                while ( !v17 );
                v91 = v87 + 32;
                v92 = v91 + v86 * 16;
                v7 = v92 + v10;
                v8 = (const __m128i *)&v84->m128i_i8[v92 + 4];
                switch ( v91 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 5:
                v93 = (__m128i *)&v14[-1].m128i_i8[11];
                v94 = *v93;
                v95 = 0;
                v96 = v13 - 32;
                *v11 = v9;
                do
                {
                  v97 = _mm_load_si128(&v93[v95 + 1]);
                  v17 = v96 < 0x20;
                  v96 -= 32;
                  v98 = _mm_load_si128(&v93[v95 + 2]);
                  v95 += 2;
                  *(__m128i *)(v10 + v95 * 16 - 32) = _mm_alignr_epi8(v97, v94, 5);
                  *(__m128i *)(v10 + v95 * 16 - 16) = _mm_alignr_epi8(v98, v97, 5);
                  if ( v17 )
                    break;
                  v99 = _mm_load_si128(&v93[v95 + 1]);
                  v17 = v96 < 0x20;
                  v96 -= 32;
                  v94 = _mm_load_si128(&v93[v95 + 2]);
                  v95 += 2;
                  *(__m128i *)(v10 + v95 * 16 - 32) = _mm_alignr_epi8(v99, v98, 5);
                  *(__m128i *)(v10 + v95 * 16 - 16) = _mm_alignr_epi8(v94, v99, 5);
                }
                while ( !v17 );
                v100 = v96 + 32;
                v101 = v100 + v95 * 16;
                v7 = v101 + v10;
                v8 = (const __m128i *)&v93->m128i_i8[v101 + 5];
                switch ( v100 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 6:
                v102 = (__m128i *)&v14[-1].m128i_i8[10];
                v103 = *v102;
                v104 = 0;
                v105 = v13 - 32;
                *v11 = v9;
                do
                {
                  v106 = _mm_load_si128(&v102[v104 + 1]);
                  v17 = v105 < 0x20;
                  v105 -= 32;
                  v107 = _mm_load_si128(&v102[v104 + 2]);
                  v104 += 2;
                  *(__m128i *)(v10 + v104 * 16 - 32) = _mm_alignr_epi8(v106, v103, 6);
                  *(__m128i *)(v10 + v104 * 16 - 16) = _mm_alignr_epi8(v107, v106, 6);
                  if ( v17 )
                    break;
                  v108 = _mm_load_si128(&v102[v104 + 1]);
                  v17 = v105 < 0x20;
                  v105 -= 32;
                  v103 = _mm_load_si128(&v102[v104 + 2]);
                  v104 += 2;
                  *(__m128i *)(v10 + v104 * 16 - 32) = _mm_alignr_epi8(v108, v107, 6);
                  *(__m128i *)(v10 + v104 * 16 - 16) = _mm_alignr_epi8(v103, v108, 6);
                }
                while ( !v17 );
                v109 = v105 + 32;
                v110 = v109 + v104 * 16;
                v7 = v110 + v10;
                v8 = (const __m128i *)&v102->m128i_i8[v110 + 6];
                switch ( v109 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 7:
                v111 = (__m128i *)&v14[-1].m128i_i8[9];
                v112 = *v111;
                v113 = 0;
                v114 = v13 - 32;
                *v11 = v9;
                do
                {
                  v115 = _mm_load_si128(&v111[v113 + 1]);
                  v17 = v114 < 0x20;
                  v114 -= 32;
                  v116 = _mm_load_si128(&v111[v113 + 2]);
                  v113 += 2;
                  *(__m128i *)(v10 + v113 * 16 - 32) = _mm_alignr_epi8(v115, v112, 7);
                  *(__m128i *)(v10 + v113 * 16 - 16) = _mm_alignr_epi8(v116, v115, 7);
                  if ( v17 )
                    break;
                  v117 = _mm_load_si128(&v111[v113 + 1]);
                  v17 = v114 < 0x20;
                  v114 -= 32;
                  v112 = _mm_load_si128(&v111[v113 + 2]);
                  v113 += 2;
                  *(__m128i *)(v10 + v113 * 16 - 32) = _mm_alignr_epi8(v117, v116, 7);
                  *(__m128i *)(v10 + v113 * 16 - 16) = _mm_alignr_epi8(v112, v117, 7);
                }
                while ( !v17 );
                v118 = v114 + 32;
                v119 = v118 + v113 * 16;
                v7 = v119 + v10;
                v8 = (const __m128i *)&v111->m128i_i8[v119 + 7];
                switch ( v118 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 8:
                v120 = (__m128i *)&v14[-1].m128i_i8[8];
                v121 = *v120;
                v122 = 0;
                v123 = v13 - 32;
                *v11 = v9;
                do
                {
                  v124 = _mm_load_si128(&v120[v122 + 1]);
                  v17 = v123 < 0x20;
                  v123 -= 32;
                  v125 = _mm_load_si128(&v120[v122 + 2]);
                  v122 += 2;
                  *(__m128i *)(v10 + v122 * 16 - 32) = _mm_alignr_epi8(v124, v121, 8);
                  *(__m128i *)(v10 + v122 * 16 - 16) = _mm_alignr_epi8(v125, v124, 8);
                  if ( v17 )
                    break;
                  v126 = _mm_load_si128(&v120[v122 + 1]);
                  v17 = v123 < 0x20;
                  v123 -= 32;
                  v121 = _mm_load_si128(&v120[v122 + 2]);
                  v122 += 2;
                  *(__m128i *)(v10 + v122 * 16 - 32) = _mm_alignr_epi8(v126, v125, 8);
                  *(__m128i *)(v10 + v122 * 16 - 16) = _mm_alignr_epi8(v121, v126, 8);
                }
                while ( !v17 );
                v127 = v123 + 32;
                v128 = v127 + v122 * 16;
                v7 = v128 + v10;
                v8 = (const __m128i *)&v120->m128i_i8[v128 + 8];
                switch ( v127 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 9:
                v129 = (__m128i *)&v14[-1].m128i_i8[7];
                v130 = *v129;
                v131 = 0;
                v132 = v13 - 32;
                *v11 = v9;
                do
                {
                  v133 = _mm_load_si128(&v129[v131 + 1]);
                  v17 = v132 < 0x20;
                  v132 -= 32;
                  v134 = _mm_load_si128(&v129[v131 + 2]);
                  v131 += 2;
                  *(__m128i *)(v10 + v131 * 16 - 32) = _mm_alignr_epi8(v133, v130, 9);
                  *(__m128i *)(v10 + v131 * 16 - 16) = _mm_alignr_epi8(v134, v133, 9);
                  if ( v17 )
                    break;
                  v135 = _mm_load_si128(&v129[v131 + 1]);
                  v17 = v132 < 0x20;
                  v132 -= 32;
                  v130 = _mm_load_si128(&v129[v131 + 2]);
                  v131 += 2;
                  *(__m128i *)(v10 + v131 * 16 - 32) = _mm_alignr_epi8(v135, v134, 9);
                  *(__m128i *)(v10 + v131 * 16 - 16) = _mm_alignr_epi8(v130, v135, 9);
                }
                while ( !v17 );
                v136 = v132 + 32;
                v137 = v136 + v131 * 16;
                v7 = v137 + v10;
                v8 = (const __m128i *)&v129->m128i_i8[v137 + 9];
                switch ( v136 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 0xA:
                v138 = (__m128i *)&v14[-1].m128i_i8[6];
                v139 = *v138;
                v140 = 0;
                v141 = v13 - 32;
                *v11 = v9;
                do
                {
                  v142 = _mm_load_si128(&v138[v140 + 1]);
                  v17 = v141 < 0x20;
                  v141 -= 32;
                  v143 = _mm_load_si128(&v138[v140 + 2]);
                  v140 += 2;
                  *(__m128i *)(v10 + v140 * 16 - 32) = _mm_alignr_epi8(v142, v139, 10);
                  *(__m128i *)(v10 + v140 * 16 - 16) = _mm_alignr_epi8(v143, v142, 10);
                  if ( v17 )
                    break;
                  v144 = _mm_load_si128(&v138[v140 + 1]);
                  v17 = v141 < 0x20;
                  v141 -= 32;
                  v139 = _mm_load_si128(&v138[v140 + 2]);
                  v140 += 2;
                  *(__m128i *)(v10 + v140 * 16 - 32) = _mm_alignr_epi8(v144, v143, 10);
                  *(__m128i *)(v10 + v140 * 16 - 16) = _mm_alignr_epi8(v139, v144, 10);
                }
                while ( !v17 );
                v145 = v141 + 32;
                v146 = v145 + v140 * 16;
                v7 = v146 + v10;
                v8 = (const __m128i *)&v138->m128i_i8[v146 + 10];
                switch ( v145 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 0xB:
                v147 = (__m128i *)&v14[-1].m128i_i8[5];
                v148 = *v147;
                v149 = 0;
                v150 = v13 - 32;
                *v11 = v9;
                do
                {
                  v151 = _mm_load_si128(&v147[v149 + 1]);
                  v17 = v150 < 0x20;
                  v150 -= 32;
                  v152 = _mm_load_si128(&v147[v149 + 2]);
                  v149 += 2;
                  *(__m128i *)(v10 + v149 * 16 - 32) = _mm_alignr_epi8(v151, v148, 11);
                  *(__m128i *)(v10 + v149 * 16 - 16) = _mm_alignr_epi8(v152, v151, 11);
                  if ( v17 )
                    break;
                  v153 = _mm_load_si128(&v147[v149 + 1]);
                  v17 = v150 < 0x20;
                  v150 -= 32;
                  v148 = _mm_load_si128(&v147[v149 + 2]);
                  v149 += 2;
                  *(__m128i *)(v10 + v149 * 16 - 32) = _mm_alignr_epi8(v153, v152, 11);
                  *(__m128i *)(v10 + v149 * 16 - 16) = _mm_alignr_epi8(v148, v153, 11);
                }
                while ( !v17 );
                v154 = v150 + 32;
                v155 = v154 + v149 * 16;
                v7 = v155 + v10;
                v8 = (const __m128i *)&v147->m128i_i8[v155 + 11];
                switch ( v154 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 0xC:
                v156 = (__m128i *)&v14[-1].m128i_i8[4];
                v157 = *v156;
                v158 = 0;
                v159 = v13 - 32;
                *v11 = v9;
                do
                {
                  v160 = _mm_load_si128(&v156[v158 + 1]);
                  v17 = v159 < 0x20;
                  v159 -= 32;
                  v161 = _mm_load_si128(&v156[v158 + 2]);
                  v158 += 2;
                  *(__m128i *)(v10 + v158 * 16 - 32) = _mm_alignr_epi8(v160, v157, 12);
                  *(__m128i *)(v10 + v158 * 16 - 16) = _mm_alignr_epi8(v161, v160, 12);
                  if ( v17 )
                    break;
                  v162 = _mm_load_si128(&v156[v158 + 1]);
                  v17 = v159 < 0x20;
                  v159 -= 32;
                  v157 = _mm_load_si128(&v156[v158 + 2]);
                  v158 += 2;
                  *(__m128i *)(v10 + v158 * 16 - 32) = _mm_alignr_epi8(v162, v161, 12);
                  *(__m128i *)(v10 + v158 * 16 - 16) = _mm_alignr_epi8(v157, v162, 12);
                }
                while ( !v17 );
                v163 = v159 + 32;
                v164 = v163 + v158 * 16;
                v7 = v164 + v10;
                v8 = (const __m128i *)&v156->m128i_i8[v164 + 12];
                switch ( v163 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 0xD:
                v165 = (__m128i *)&v14[-1].m128i_i8[3];
                v166 = *v165;
                v167 = 0;
                v168 = v13 - 32;
                *v11 = v9;
                do
                {
                  v169 = _mm_load_si128(&v165[v167 + 1]);
                  v17 = v168 < 0x20;
                  v168 -= 32;
                  v170 = _mm_load_si128(&v165[v167 + 2]);
                  v167 += 2;
                  *(__m128i *)(v10 + v167 * 16 - 32) = _mm_alignr_epi8(v169, v166, 13);
                  *(__m128i *)(v10 + v167 * 16 - 16) = _mm_alignr_epi8(v170, v169, 13);
                  if ( v17 )
                    break;
                  v171 = _mm_load_si128(&v165[v167 + 1]);
                  v17 = v168 < 0x20;
                  v168 -= 32;
                  v166 = _mm_load_si128(&v165[v167 + 2]);
                  v167 += 2;
                  *(__m128i *)(v10 + v167 * 16 - 32) = _mm_alignr_epi8(v171, v170, 13);
                  *(__m128i *)(v10 + v167 * 16 - 16) = _mm_alignr_epi8(v166, v171, 13);
                }
                while ( !v17 );
                v172 = v168 + 32;
                v173 = v172 + v167 * 16;
                v7 = v173 + v10;
                v8 = (const __m128i *)&v165->m128i_i8[v173 + 13];
                switch ( v172 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 0xE:
                v174 = (__m128i *)&v14[-1].m128i_i8[2];
                v175 = *v174;
                v176 = 0;
                v177 = v13 - 32;
                *v11 = v9;
                do
                {
                  v178 = _mm_load_si128(&v174[v176 + 1]);
                  v17 = v177 < 0x20;
                  v177 -= 32;
                  v179 = _mm_load_si128(&v174[v176 + 2]);
                  v176 += 2;
                  *(__m128i *)(v10 + v176 * 16 - 32) = _mm_alignr_epi8(v178, v175, 14);
                  *(__m128i *)(v10 + v176 * 16 - 16) = _mm_alignr_epi8(v179, v178, 14);
                  if ( v17 )
                    break;
                  v180 = _mm_load_si128(&v174[v176 + 1]);
                  v17 = v177 < 0x20;
                  v177 -= 32;
                  v175 = _mm_load_si128(&v174[v176 + 2]);
                  v176 += 2;
                  *(__m128i *)(v10 + v176 * 16 - 32) = _mm_alignr_epi8(v180, v179, 14);
                  *(__m128i *)(v10 + v176 * 16 - 16) = _mm_alignr_epi8(v175, v180, 14);
                }
                while ( !v17 );
                v181 = v177 + 32;
                v182 = v181 + v176 * 16;
                v7 = v182 + v10;
                v8 = (const __m128i *)&v174->m128i_i8[v182 + 14];
                switch ( v181 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
              case 0xF:
                v183 = (__m128i *)&v14[-1].m128i_i8[1];
                v184 = *v183;
                v185 = 0;
                v186 = v13 - 32;
                *v11 = v9;
                do
                {
                  v187 = _mm_load_si128(&v183[v185 + 1]);
                  v17 = v186 < 0x20;
                  v186 -= 32;
                  v188 = _mm_load_si128(&v183[v185 + 2]);
                  v185 += 2;
                  *(__m128i *)(v10 + v185 * 16 - 32) = _mm_alignr_epi8(v187, v184, 15);
                  *(__m128i *)(v10 + v185 * 16 - 16) = _mm_alignr_epi8(v188, v187, 15);
                  if ( v17 )
                    break;
                  v189 = _mm_load_si128(&v183[v185 + 1]);
                  v17 = v186 < 0x20;
                  v186 -= 32;
                  v184 = _mm_load_si128(&v183[v185 + 2]);
                  v185 += 2;
                  *(__m128i *)(v10 + v185 * 16 - 32) = _mm_alignr_epi8(v189, v188, 15);
                  *(__m128i *)(v10 + v185 * 16 - 16) = _mm_alignr_epi8(v184, v189, 15);
                }
                while ( !v17 );
                v190 = v186 + 32;
                v191 = v190 + v185 * 16;
                v7 = v191 + v10;
                v8 = (const __m128i *)&v183->m128i_i8[v191 + 15];
                switch ( v190 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_115;
                  case 2u:
                    goto LABEL_127;
                  case 3u:
                    goto LABEL_138;
                  case 4u:
                    goto LABEL_97;
                  case 5u:
                    goto LABEL_104;
                  case 6u:
                    goto LABEL_121;
                  case 7u:
                    goto LABEL_172;
                  case 8u:
                    goto LABEL_102;
                  case 9u:
                    goto LABEL_114;
                  case 0xAu:
                    goto LABEL_126;
                  case 0xBu:
                    goto LABEL_137;
                  case 0xCu:
                    goto LABEL_96;
                  case 0xDu:
                    goto LABEL_109;
                  case 0xEu:
                    goto LABEL_120;
                  case 0xFu:
                    goto LABEL_132;
                  case 0x10u:
                    goto LABEL_101;
                  case 0x11u:
                    goto LABEL_113;
                  case 0x12u:
                    goto LABEL_125;
                  case 0x13u:
                    goto LABEL_136;
                  case 0x14u:
                    goto LABEL_95;
                  case 0x15u:
                    goto LABEL_108;
                  case 0x16u:
                    goto LABEL_119;
                  case 0x17u:
                    goto LABEL_131;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_112;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_135;
                  case 0x1Cu:
                    goto LABEL_94;
                  case 0x1Du:
                    goto LABEL_107;
                  case 0x1Eu:
                    goto LABEL_118;
                  case 0x1Fu:
                    goto LABEL_130;
                  case 0x20u:
                    goto LABEL_99;
                  case 0x21u:
                    goto LABEL_111;
                  case 0x22u:
                    goto LABEL_123;
                  case 0x23u:
                    goto LABEL_134;
                  case 0x24u:
                    goto LABEL_93;
                  case 0x25u:
                    goto LABEL_106;
                  case 0x26u:
                    goto LABEL_117;
                  case 0x27u:
                    goto LABEL_129;
                  case 0x28u:
                    goto LABEL_98;
                  case 0x29u:
                    goto LABEL_110;
                  case 0x2Au:
                    goto LABEL_122;
                  case 0x2Bu:
                    goto LABEL_133;
                  case 0x2Cu:
                    goto LABEL_92;
                  case 0x2Du:
                    goto LABEL_105;
                  case 0x2Eu:
                    goto LABEL_116;
                  case 0x2Fu:
                    goto LABEL_128;
                }
            }
          }
          *v11 = v9;
          if ( v13 <= 0x7F )
          {
            v15 = v13 - 32;
            v16 = _mm_load_si128(v14 + 1);
            v17 = v15 < 0x20;
            v18 = v15 - 32;
            *(__m128i *)v10 = _mm_load_si128(v14);
            *(__m128i *)(v10 + 16) = v16;
            v19 = 32;
            if ( !v17 )
            {
              v20 = _mm_load_si128(v14 + 3);
              v17 = v18 < 0x20;
              v18 -= 32;
              *(__m128i *)(v10 + 32) = _mm_load_si128(v14 + 2);
              *(__m128i *)(v10 + 48) = v20;
              v19 = 64;
              if ( !v17 )
              {
                v21 = _mm_load_si128(v14 + 5);
                v17 = v18 < 0x20;
                v18 -= 32;
                *(__m128i *)(v10 + 64) = _mm_load_si128(v14 + 4);
                *(__m128i *)(v10 + 80) = v21;
                v19 = 96;
                if ( !v17 )
                {
                  v22 = _mm_load_si128(v14 + 7);
                  v18 -= 32;
                  *(__m128i *)(v10 + 96) = _mm_load_si128(v14 + 6);
                  *(__m128i *)(v10 + 112) = v22;
                  v19 = 128;
                }
              }
            }
            v23 = v18 + 32;
            v24 = v23 + v19;
            v7 = v24 + v10;
            v8 = (const __m128i *)((char *)v14 + v24);
            switch ( v23 )
            {
              case 0u:
                goto LABEL_142;
              case 1u:
                goto LABEL_154;
              case 2u:
                goto LABEL_166;
              case 3u:
                goto LABEL_178;
              case 4u:
                goto LABEL_184;
              case 5u:
                goto LABEL_145;
              case 6u:
                goto LABEL_160;
              case 7u:
                goto LABEL_172;
              case 8u:
                goto LABEL_141;
              case 9u:
                goto LABEL_153;
              case 0xAu:
                goto LABEL_165;
              case 0xBu:
                goto LABEL_177;
              case 0xCu:
                goto LABEL_183;
              case 0xDu:
                goto LABEL_148;
              case 0xEu:
                goto LABEL_159;
              case 0xFu:
                goto LABEL_171;
              case 0x10u:
                goto LABEL_144;
              case 0x11u:
                goto LABEL_156;
              case 0x12u:
                goto LABEL_168;
              case 0x13u:
                goto LABEL_180;
              case 0x14u:
                goto LABEL_186;
              case 0x15u:
                goto LABEL_150;
              case 0x16u:
                goto LABEL_162;
              case 0x17u:
                goto LABEL_174;
              case 0x18u:
                goto LABEL_140;
              case 0x19u:
                goto LABEL_152;
              case 0x1Au:
                goto LABEL_164;
              case 0x1Bu:
                goto LABEL_176;
              case 0x1Cu:
                goto LABEL_182;
              case 0x1Du:
                goto LABEL_147;
              case 0x1Eu:
                goto LABEL_158;
              case 0x1Fu:
                goto LABEL_170;
              case 0x20u:
                *(__m128i *)(v7 - 32) = _mm_load_si128(v8 - 2);
LABEL_144:
                *(__m128i *)(v7 - 16) = _mm_load_si128(v8 - 1);
                return a2;
              case 0x21u:
                *(__m128i *)(v7 - 33) = _mm_load_si128((const __m128i *)((char *)v8 - 33));
LABEL_156:
                *(__m128i *)(v7 - 17) = _mm_load_si128((const __m128i *)((char *)v8 - 17));
                *(_BYTE *)(v7 - 1) = v8[-1].m128i_i8[15];
                return a2;
              case 0x22u:
                *(__m128i *)(v7 - 34) = _mm_load_si128((const __m128i *)((char *)v8 - 34));
LABEL_168:
                *(__m128i *)(v7 - 18) = _mm_load_si128((const __m128i *)((char *)v8 - 18));
                *(_WORD *)(v7 - 2) = v8[-1].m128i_i16[7];
                return a2;
              case 0x23u:
                *(__m128i *)(v7 - 35) = _mm_load_si128((const __m128i *)((char *)v8 - 35));
LABEL_180:
                *(__m128i *)(v7 - 19) = _mm_load_si128((const __m128i *)((char *)v8 - 19));
                v205 = *(__int16 *)((char *)&v8[-1].m128i_i16[6] + 1);
                v206 = v8[-1].m128i_i8[15];
                *(_WORD *)(v7 - 3) = v205;
                *(_BYTE *)(v7 - 1) = v206;
                return a2;
              case 0x24u:
                *(__m128i *)(v7 - 36) = _mm_load_si128((const __m128i *)((char *)v8 - 36));
LABEL_186:
                *(__m128i *)(v7 - 20) = _mm_load_si128((const __m128i *)((char *)v8 - 20));
                *(_DWORD *)(v7 - 4) = v8[-1].m128i_i32[3];
                return a2;
              case 0x25u:
                *(__m128i *)(v7 - 37) = _mm_load_si128((const __m128i *)((char *)v8 - 37));
LABEL_150:
                *(__m128i *)(v7 - 21) = _mm_load_si128((const __m128i *)((char *)v8 - 21));
                *(_DWORD *)(v7 - 5) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
                *(_BYTE *)(v7 - 1) = v8[-1].m128i_i8[15];
                return a2;
              case 0x26u:
                *(__m128i *)(v7 - 38) = _mm_load_si128((const __m128i *)((char *)v8 - 38));
LABEL_162:
                *(__m128i *)(v7 - 22) = _mm_load_si128((const __m128i *)((char *)v8 - 22));
                *(_DWORD *)(v7 - 6) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 2);
                *(_WORD *)(v7 - 2) = v8[-1].m128i_i16[7];
                return a2;
              case 0x27u:
                *(__m128i *)(v7 - 39) = _mm_load_si128((const __m128i *)((char *)v8 - 39));
LABEL_174:
                *(__m128i *)(v7 - 23) = _mm_load_si128((const __m128i *)((char *)v8 - 23));
                *(_DWORD *)(v7 - 7) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 1);
                v201 = *(__int16 *)((char *)&v8[-1].m128i_i16[6] + 1);
                v202 = v8[-1].m128i_i8[15];
                *(_WORD *)(v7 - 3) = v201;
                *(_BYTE *)(v7 - 1) = v202;
                return a2;
              case 0x28u:
                *(__m128i *)(v7 - 40) = _mm_load_si128((const __m128i *)((char *)v8 - 40));
LABEL_140:
                *(__m128i *)(v7 - 24) = _mm_load_si128((const __m128i *)((char *)v8 - 24));
                goto LABEL_141;
              case 0x29u:
                *(__m128i *)(v7 - 41) = _mm_load_si128((const __m128i *)((char *)v8 - 41));
LABEL_152:
                *(__m128i *)(v7 - 25) = _mm_load_si128((const __m128i *)((char *)v8 - 25));
                goto LABEL_153;
              case 0x2Au:
                *(__m128i *)(v7 - 42) = _mm_load_si128((const __m128i *)((char *)v8 - 42));
LABEL_164:
                *(__m128i *)(v7 - 26) = _mm_load_si128((const __m128i *)((char *)v8 - 26));
                goto LABEL_165;
              case 0x2Bu:
                *(__m128i *)(v7 - 43) = _mm_load_si128((const __m128i *)((char *)v8 - 43));
LABEL_176:
                *(__m128i *)(v7 - 27) = _mm_load_si128((const __m128i *)((char *)v8 - 27));
                goto LABEL_177;
              case 0x2Cu:
                *(__m128i *)(v7 - 44) = _mm_load_si128((const __m128i *)((char *)v8 - 44));
LABEL_182:
                *(__m128i *)(v7 - 28) = _mm_load_si128((const __m128i *)((char *)v8 - 28));
                goto LABEL_183;
              case 0x2Du:
                *(__m128i *)(v7 - 45) = _mm_load_si128((const __m128i *)((char *)v8 - 45));
LABEL_147:
                *(__m128i *)(v7 - 29) = _mm_load_si128((const __m128i *)((char *)v8 - 29));
                goto LABEL_148;
              case 0x2Eu:
                *(__m128i *)(v7 - 46) = _mm_load_si128((const __m128i *)((char *)v8 - 46));
LABEL_158:
                *(__m128i *)(v7 - 30) = _mm_load_si128((const __m128i *)((char *)v8 - 30));
                goto LABEL_159;
              case 0x2Fu:
                *(__m128i *)(v7 - 47) = _mm_load_si128((const __m128i *)((char *)v8 - 47));
LABEL_170:
                *(__m128i *)(v7 - 31) = _mm_load_si128((const __m128i *)((char *)v8 - 31));
                goto LABEL_171;
            }
          }
          v17 = v13 < _x86_data_cache_size_half;
          v25 = v13 - 128;
          if ( v17 )
          {
            do
            {
              v26 = _mm_load_si128(v14);
              v27 = _mm_load_si128(v14 + 1);
              v28 = _mm_load_si128(v14 + 2);
              v29 = _mm_load_si128(v14 + 3);
              v30 = _mm_load_si128(v14 + 4);
              v31 = _mm_load_si128(v14 + 5);
              v32 = _mm_load_si128(v14 + 6);
              v33 = _mm_load_si128(v14 + 7);
              v14 += 8;
              v17 = v25 < 0x80;
              v25 -= 128;
              *(__m128i *)v10 = v26;
              *(__m128i *)(v10 + 16) = v27;
              *(__m128i *)(v10 + 32) = v28;
              *(__m128i *)(v10 + 48) = v29;
              *(__m128i *)(v10 + 64) = v30;
              *(__m128i *)(v10 + 80) = v31;
              *(__m128i *)(v10 + 96) = v32;
              *(__m128i *)(v10 + 112) = v33;
              v10 += 128;
            }
            while ( !v17 );
            v34 = (int)v25 < -64;
            v35 = v25 + 128;
            if ( !v34 )
            {
              v35 -= 64;
              v36 = _mm_load_si128(v14 + 1);
              *(__m128i *)v10 = _mm_load_si128(v14);
              *(__m128i *)(v10 + 16) = v36;
              v37 = _mm_load_si128(v14 + 2);
              v38 = _mm_load_si128(v14 + 3);
              v14 += 4;
              *(__m128i *)(v10 + 32) = v37;
              *(__m128i *)(v10 + 48) = v38;
              v10 += 64;
            }
            if ( v35 >= 0x20 )
            {
              v39 = _mm_load_si128(v14);
              v35 -= 32;
              v40 = _mm_load_si128(v14 + 1);
              v14 += 2;
              *(__m128i *)v10 = v39;
              *(__m128i *)(v10 + 16) = v40;
              v10 += 32;
            }
            while ( 2 )
            {
              v7 = v35 + v10;
              v8 = (const __m128i *)((char *)v14 + v35);
              switch ( v35 )
              {
                case 0u:
                  return a2;
                case 1u:
                  goto LABEL_115;
                case 2u:
                  goto LABEL_127;
                case 3u:
                  goto LABEL_138;
                case 4u:
                  goto LABEL_97;
                case 5u:
                  goto LABEL_104;
                case 6u:
                  goto LABEL_121;
                case 7u:
                  goto LABEL_172;
                case 8u:
                  goto LABEL_102;
                case 9u:
                  goto LABEL_114;
                case 0xAu:
                  goto LABEL_126;
                case 0xBu:
                  goto LABEL_137;
                case 0xCu:
                  goto LABEL_96;
                case 0xDu:
                  goto LABEL_109;
                case 0xEu:
                  goto LABEL_120;
                case 0xFu:
                  goto LABEL_132;
                default:
                  v35 -= 16;
                  v41 = _mm_load_si128(v8);
                  v14 = v8 + 1;
                  *(__m128i *)v7 = v41;
                  v10 = v7 + 16;
                  continue;
              }
            }
          }
          do
          {
            _mm_prefetch(v14[28].m128i_i8, 1);
            _mm_prefetch(v14[40].m128i_i8, 1);
            _mm_prefetch((const char *)(v10 + 448), 1);
            v42 = _mm_load_si128(v14);
            v43 = _mm_load_si128(v14 + 1);
            v44 = _mm_load_si128(v14 + 2);
            v45 = _mm_load_si128(v14 + 3);
            v46 = _mm_load_si128(v14 + 4);
            v47 = _mm_load_si128(v14 + 5);
            v48 = _mm_load_si128(v14 + 6);
            v49 = _mm_load_si128(v14 + 7);
            v14 += 8;
            v17 = v25 < 0x80;
            v25 -= 128;
            *(__m128i *)v10 = v42;
            *(__m128i *)(v10 + 16) = v43;
            *(__m128i *)(v10 + 32) = v44;
            *(__m128i *)(v10 + 48) = v45;
            *(__m128i *)(v10 + 64) = v46;
            *(__m128i *)(v10 + 80) = v47;
            *(__m128i *)(v10 + 96) = v48;
            *(__m128i *)(v10 + 112) = v49;
            v10 += 128;
          }
          while ( !v17 );
          v34 = (int)v25 < -64;
          v50 = v25 + 128;
          if ( !v34 )
          {
            v50 -= 64;
            v51 = _mm_load_si128(v14 + 1);
            *(__m128i *)v10 = _mm_load_si128(v14);
            *(__m128i *)(v10 + 16) = v51;
            v52 = _mm_load_si128(v14 + 2);
            v53 = _mm_load_si128(v14 + 3);
            v14 += 4;
            *(__m128i *)(v10 + 32) = v52;
            *(__m128i *)(v10 + 48) = v53;
            v10 += 64;
          }
          if ( v50 >= 0x20 )
          {
            v54 = _mm_load_si128(v14);
            v50 -= 32;
            v55 = _mm_load_si128(v14 + 1);
            v14 += 2;
            *(__m128i *)v10 = v54;
            *(__m128i *)(v10 + 16) = v55;
            v10 += 32;
          }
          while ( 2 )
          {
            v7 = v50 + v10;
            v8 = (const __m128i *)((char *)v14 + v50);
            switch ( v50 )
            {
              case 0u:
                goto LABEL_142;
              case 1u:
                goto LABEL_154;
              case 2u:
                goto LABEL_166;
              case 3u:
                goto LABEL_178;
              case 4u:
                goto LABEL_184;
              case 5u:
LABEL_145:
                v197 = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
                v198 = v8[-1].m128i_i32[3];
                *(_DWORD *)(v7 - 5) = v197;
                *(_DWORD *)(v7 - 4) = v198;
                return a2;
              case 6u:
                goto LABEL_160;
              case 7u:
                goto LABEL_172;
              case 8u:
LABEL_141:
                *(_QWORD *)(v7 - 8) = v8[-1].m128i_i64[1];
LABEL_142:
                result = a2;
                break;
              case 9u:
LABEL_153:
                *(_QWORD *)(v7 - 9) = *(__int64 *)((char *)v8[-1].m128i_i64 + 7);
LABEL_154:
                *(_BYTE *)(v7 - 1) = v8[-1].m128i_i8[15];
                result = a2;
                break;
              case 0xAu:
LABEL_165:
                *(_QWORD *)(v7 - 10) = *(__int64 *)((char *)v8[-1].m128i_i64 + 6);
LABEL_166:
                *(_WORD *)(v7 - 2) = v8[-1].m128i_i16[7];
                result = a2;
                break;
              case 0xBu:
LABEL_177:
                *(_QWORD *)(v7 - 11) = *(__int64 *)((char *)v8[-1].m128i_i64 + 5);
LABEL_178:
                v203 = *(__int16 *)((char *)&v8[-1].m128i_i16[6] + 1);
                v204 = v8[-1].m128i_i8[15];
                *(_WORD *)(v7 - 3) = v203;
                *(_BYTE *)(v7 - 1) = v204;
                result = a2;
                break;
              case 0xCu:
LABEL_183:
                *(_QWORD *)(v7 - 12) = *(__int64 *)((char *)v8[-1].m128i_i64 + 4);
LABEL_184:
                *(_DWORD *)(v7 - 4) = v8[-1].m128i_i32[3];
                result = a2;
                break;
              case 0xDu:
LABEL_148:
                *(_QWORD *)(v7 - 13) = *(__int64 *)((char *)v8[-1].m128i_i64 + 3);
                *(_DWORD *)(v7 - 5) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
                *(_BYTE *)(v7 - 1) = v8[-1].m128i_i8[15];
                result = a2;
                break;
              case 0xEu:
LABEL_159:
                *(_QWORD *)(v7 - 14) = *(__int64 *)((char *)v8[-1].m128i_i64 + 2);
LABEL_160:
                *(_DWORD *)(v7 - 6) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 2);
                *(_WORD *)(v7 - 2) = v8[-1].m128i_i16[7];
                result = a2;
                break;
              case 0xFu:
LABEL_171:
                *(_QWORD *)(v7 - 15) = *(__int64 *)((char *)v8[-1].m128i_i64 + 1);
                goto LABEL_172;
              default:
                v50 -= 16;
                v56 = _mm_load_si128(v8);
                v14 = v8 + 1;
                *(__m128i *)v7 = v56;
                v10 = v7 + 16;
                continue;
            }
            return result;
          }
      }
    }
    v226 = a1;
    v6 = a4 + a2;
    a1 = (const __m128i *)((char *)a3 + a4);
    if ( ((a4 + a2) & 3) != 0 )
    {
      if ( (v6 & 1) == 0
        || (a1 = (const __m128i *)((char *)a1 - 1), v4 = a4 - 1, --v6, *(_BYTE *)v6 = a1->m128i_i8[0], (v6 & 2) != 0) )
      {
        a1 = (const __m128i *)((char *)a1 - 2);
        v4 -= 2;
        v6 -= 2;
        *(_WORD *)v6 = a1->m128i_i16[0];
      }
    }
    if ( v4 >= 0x40 )
    {
      if ( (v6 & 0xF) != 0 )
      {
        a1 = (const __m128i *)((char *)a1 - 4);
        v4 -= 4;
        v6 -= 4;
        *(_DWORD *)v6 = a1->m128i_i32[0];
        if ( (v6 & 0xF) != 0 )
        {
          a1 = (const __m128i *)((char *)a1 - 4);
          v4 -= 4;
          v6 -= 4;
          *(_DWORD *)v6 = a1->m128i_i32[0];
          if ( (v6 & 0xF) != 0 )
          {
            a1 = (const __m128i *)((char *)a1 - 4);
            v4 -= 4;
            v6 -= 4;
            *(_DWORD *)v6 = a1->m128i_i32[0];
          }
        }
      }
      if ( v4 < 0x40 )
      {
LABEL_229:
        v4 -= 32;
        *(_QWORD *)(v6 - 8) = a1[-1].m128i_i64[1];
        *(_QWORD *)(v6 - 16) = a1[-1].m128i_i64[0];
        *(_QWORD *)(v6 - 24) = a1[-2].m128i_i64[1];
        *(_QWORD *)(v6 - 32) = a1[-2].m128i_i64[0];
        v6 -= 32;
        a1 -= 2;
      }
      else
      {
        do
        {
          a1 -= 4;
          v4 -= 64;
          v6 -= 64;
          *(__m128i *)(v6 + 48) = _mm_loadu_si128(a1 + 3);
          *(__m128i *)(v6 + 32) = _mm_loadu_si128(a1 + 2);
          *(__m128i *)(v6 + 16) = _mm_loadu_si128(a1 + 1);
          *(__m128i *)v6 = _mm_loadu_si128(a1);
        }
        while ( v4 >= 0x40 );
      }
    }
    v6 -= v4;
    v5 = (__int64 *)((char *)a1->m128i_i64 - v4);
    a1 = v226;
  }
  switch ( v4 )
  {
    case 0u:
      goto LABEL_198;
    case 1u:
      goto LABEL_206;
    case 2u:
      goto LABEL_217;
    case 3u:
      goto LABEL_225;
    case 4u:
      goto LABEL_197;
    case 5u:
      goto LABEL_205;
    case 6u:
      goto LABEL_213;
    case 7u:
      goto LABEL_221;
    case 8u:
      goto LABEL_201;
    case 9u:
      goto LABEL_209;
    case 0xAu:
      goto LABEL_216;
    case 0xBu:
      goto LABEL_224;
    case 0xCu:
      goto LABEL_196;
    case 0xDu:
      goto LABEL_204;
    case 0xEu:
      goto LABEL_212;
    case 0xFu:
      goto LABEL_220;
    case 0x10u:
      goto LABEL_200;
    case 0x11u:
      goto LABEL_208;
    case 0x12u:
      goto LABEL_215;
    case 0x13u:
      goto LABEL_223;
    case 0x14u:
      goto LABEL_195;
    case 0x15u:
      goto LABEL_203;
    case 0x16u:
      goto LABEL_211;
    case 0x17u:
      goto LABEL_219;
    case 0x18u:
      *(_QWORD *)(v6 + 16) = v5[2];
LABEL_200:
      *(_QWORD *)(v6 + 8) = v5[1];
LABEL_201:
      *(_QWORD *)v6 = *v5;
      result = a2;
      break;
    case 0x19u:
      *(_QWORD *)(v6 + 17) = *(_QWORD *)((char *)v5 + 17);
LABEL_208:
      *(_QWORD *)(v6 + 9) = *(_QWORD *)((char *)v5 + 9);
LABEL_209:
      *(_QWORD *)(v6 + 1) = *(_QWORD *)((char *)v5 + 1);
      *(_BYTE *)v6 = *(_BYTE *)v5;
      result = a2;
      break;
    case 0x1Au:
      *(_QWORD *)(v6 + 18) = *(_QWORD *)((char *)v5 + 18);
LABEL_215:
      *(_QWORD *)(v6 + 10) = *(_QWORD *)((char *)v5 + 10);
LABEL_216:
      *(_QWORD *)(v6 + 2) = *(_QWORD *)((char *)v5 + 2);
LABEL_217:
      *(_WORD *)v6 = *(_WORD *)v5;
      result = a2;
      break;
    case 0x1Bu:
      *(_QWORD *)(v6 + 19) = *(_QWORD *)((char *)v5 + 19);
LABEL_223:
      *(_QWORD *)(v6 + 11) = *(_QWORD *)((char *)v5 + 11);
LABEL_224:
      *(_QWORD *)(v6 + 3) = *(_QWORD *)((char *)v5 + 3);
LABEL_225:
      *(_WORD *)(v6 + 1) = *(_WORD *)((char *)v5 + 1);
      *(_BYTE *)v6 = *(_BYTE *)v5;
      result = a2;
      break;
    case 0x1Cu:
      *(_QWORD *)(v6 + 20) = *(_QWORD *)((char *)v5 + 20);
LABEL_195:
      *(_QWORD *)(v6 + 12) = *(_QWORD *)((char *)v5 + 12);
LABEL_196:
      *(_QWORD *)(v6 + 4) = *(_QWORD *)((char *)v5 + 4);
LABEL_197:
      *(_DWORD *)v6 = *(_DWORD *)v5;
LABEL_198:
      result = a2;
      break;
    case 0x1Du:
      *(_QWORD *)(v6 + 21) = *(_QWORD *)((char *)v5 + 21);
LABEL_203:
      *(_QWORD *)(v6 + 13) = *(_QWORD *)((char *)v5 + 13);
LABEL_204:
      *(_QWORD *)(v6 + 5) = *(_QWORD *)((char *)v5 + 5);
LABEL_205:
      *(_DWORD *)(v6 + 1) = *(_DWORD *)((char *)v5 + 1);
LABEL_206:
      *(_BYTE *)v6 = *(_BYTE *)v5;
      result = a2;
      break;
    case 0x1Eu:
      *(_QWORD *)(v6 + 22) = *(_QWORD *)((char *)v5 + 22);
LABEL_211:
      *(_QWORD *)(v6 + 14) = *(_QWORD *)((char *)v5 + 14);
LABEL_212:
      *(_QWORD *)(v6 + 6) = *(_QWORD *)((char *)v5 + 6);
LABEL_213:
      *(_DWORD *)(v6 + 2) = *(_DWORD *)((char *)v5 + 2);
      *(_WORD *)v6 = *(_WORD *)v5;
      result = a2;
      break;
    case 0x1Fu:
      *(_QWORD *)(v6 + 23) = *(_QWORD *)((char *)v5 + 23);
LABEL_219:
      *(_QWORD *)(v6 + 15) = *(_QWORD *)((char *)v5 + 15);
LABEL_220:
      *(_QWORD *)(v6 + 7) = *(_QWORD *)((char *)v5 + 7);
LABEL_221:
      *(_DWORD *)(v6 + 3) = *(_DWORD *)((char *)v5 + 3);
      *(_WORD *)(v6 + 1) = *(_WORD *)((char *)v5 + 1);
      *(_BYTE *)v6 = *(_BYTE *)v5;
      result = a2;
      break;
    default:
      goto LABEL_229;
  }
  return result;
}
// 8070003: conditional instruction was optimized away because %arg_8.4>=20u
// 806FFF6: variable 'v226' is possibly undefined
// 80EF548: using guessed type int _x86_shared_cache_size_half;
// 80EF558: using guessed type int _x86_data_cache_size_half;

//----- (080700D0) --------------------------------------------------------
unsigned int __usercall _memmove_chk_ssse3_rep@<eax>(
        const __m128i *a1@<esi>,
        long double fst7_0@<st0>,
        unsigned int a2,
        _DWORD *a3,
        unsigned int a4,
        unsigned int a6)
{
  if ( a6 < a4 )
    _chk_fail(fst7_0);
  return _memmove_ssse3_rep(a1, a2, a3, a4);
}

//----- (080700E0) --------------------------------------------------------
unsigned int __usercall _memmove_ssse3_rep@<eax>(const __m128i *a1@<esi>, unsigned int a2, _DWORD *a3, unsigned int a4)
{
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  unsigned int v6; // edx
  __m128i *v7; // edx
  const __m128i *v8; // eax
  __m128i v9; // xmm0
  __m128i *v10; // edx
  __m128i *v11; // esi
  unsigned int v12; // edi
  unsigned int v13; // ecx
  const __m128i *v14; // eax
  unsigned int v15; // ecx
  __m128i v16; // xmm1
  bool v17; // cf
  unsigned int v18; // ecx
  int v19; // edi
  __m128i v20; // xmm1
  __m128i v21; // xmm1
  __m128i v22; // xmm1
  unsigned int v23; // ecx
  unsigned int v24; // edi
  unsigned int v25; // ecx
  __m128i v26; // xmm0
  __m128i v27; // xmm1
  __m128i v28; // xmm2
  __m128i v29; // xmm3
  __m128i v30; // xmm4
  __m128i v31; // xmm5
  __m128i v32; // xmm6
  __m128i v33; // xmm7
  unsigned int v34; // ecx
  __m128i v35; // xmm1
  __m128i v36; // xmm0
  __m128i v37; // xmm1
  __m128i v38; // xmm0
  __m128i v39; // xmm1
  __m128i v40; // xmm0
  unsigned int v41; // ecx
  __m128i v42; // xmm0
  __m128i v43; // xmm1
  __m128i v44; // xmm2
  __m128i v45; // xmm3
  __m128i v46; // xmm4
  __m128i v47; // xmm5
  __m128i v48; // xmm6
  __m128i v49; // xmm7
  unsigned int v50; // ecx
  __m128i v51; // xmm1
  __m128i v52; // xmm0
  __m128i v53; // xmm1
  __m128i v54; // xmm0
  __m128i v55; // xmm1
  __m128i v56; // xmm0
  __m128i *v57; // eax
  __m128i v58; // xmm1
  int v59; // edi
  unsigned int v60; // ecx
  __m128i si128; // xmm2
  __m128i v62; // xmm4
  __m128i v63; // xmm2
  unsigned int v64; // ecx
  unsigned int v65; // edi
  __m128i *v66; // eax
  __m128i v67; // xmm1
  int v68; // edi
  unsigned int v69; // ecx
  __m128i v70; // xmm2
  __m128i v71; // xmm4
  __m128i v72; // xmm2
  unsigned int v73; // ecx
  unsigned int v74; // edi
  __m128i *v75; // eax
  __m128i v76; // xmm1
  int v77; // edi
  unsigned int v78; // ecx
  __m128i v79; // xmm2
  __m128i v80; // xmm4
  __m128i v81; // xmm2
  unsigned int v82; // ecx
  unsigned int v83; // edi
  __m128i *v84; // eax
  __m128i v85; // xmm1
  int v86; // edi
  unsigned int v87; // ecx
  __m128i v88; // xmm2
  __m128i v89; // xmm4
  __m128i v90; // xmm2
  unsigned int v91; // ecx
  unsigned int v92; // edi
  __m128i *v93; // eax
  __m128i v94; // xmm1
  int v95; // edi
  unsigned int v96; // ecx
  __m128i v97; // xmm2
  __m128i v98; // xmm4
  __m128i v99; // xmm2
  unsigned int v100; // ecx
  unsigned int v101; // edi
  __m128i *v102; // eax
  __m128i v103; // xmm1
  int v104; // edi
  unsigned int v105; // ecx
  __m128i v106; // xmm2
  __m128i v107; // xmm4
  __m128i v108; // xmm2
  unsigned int v109; // ecx
  unsigned int v110; // edi
  __m128i *v111; // eax
  __m128i v112; // xmm1
  int v113; // edi
  unsigned int v114; // ecx
  __m128i v115; // xmm2
  __m128i v116; // xmm4
  __m128i v117; // xmm2
  unsigned int v118; // ecx
  unsigned int v119; // edi
  __m128i *v120; // eax
  __m128i v121; // xmm1
  int v122; // edi
  unsigned int v123; // ecx
  __m128i v124; // xmm2
  __m128i v125; // xmm4
  __m128i v126; // xmm2
  unsigned int v127; // ecx
  unsigned int v128; // edi
  __m128i *v129; // eax
  __m128i v130; // xmm1
  int v131; // edi
  unsigned int v132; // ecx
  __m128i v133; // xmm2
  __m128i v134; // xmm4
  __m128i v135; // xmm2
  unsigned int v136; // ecx
  unsigned int v137; // edi
  __m128i *v138; // eax
  __m128i v139; // xmm1
  int v140; // edi
  unsigned int v141; // ecx
  __m128i v142; // xmm2
  __m128i v143; // xmm4
  __m128i v144; // xmm2
  unsigned int v145; // ecx
  unsigned int v146; // edi
  __m128i *v147; // eax
  __m128i v148; // xmm1
  int v149; // edi
  unsigned int v150; // ecx
  __m128i v151; // xmm2
  __m128i v152; // xmm4
  __m128i v153; // xmm2
  unsigned int v154; // ecx
  unsigned int v155; // edi
  __m128i *v156; // eax
  __m128i v157; // xmm1
  int v158; // edi
  unsigned int v159; // ecx
  __m128i v160; // xmm2
  __m128i v161; // xmm4
  __m128i v162; // xmm2
  unsigned int v163; // ecx
  unsigned int v164; // edi
  __m128i *v165; // eax
  __m128i v166; // xmm1
  int v167; // edi
  unsigned int v168; // ecx
  __m128i v169; // xmm2
  __m128i v170; // xmm4
  __m128i v171; // xmm2
  unsigned int v172; // ecx
  unsigned int v173; // edi
  __m128i *v174; // eax
  __m128i v175; // xmm1
  int v176; // edi
  unsigned int v177; // ecx
  __m128i v178; // xmm2
  __m128i v179; // xmm4
  __m128i v180; // xmm2
  unsigned int v181; // ecx
  unsigned int v182; // edi
  __m128i *v183; // eax
  __m128i v184; // xmm1
  int v185; // edi
  unsigned int v186; // ecx
  __m128i v187; // xmm2
  __m128i v188; // xmm4
  __m128i v189; // xmm2
  unsigned int v190; // ecx
  unsigned int v191; // edi
  unsigned int result; // eax
  __int32 v193; // ecx
  __int32 v194; // eax
  __int16 v195; // cx
  __int8 v196; // al
  __m128i v197; // xmm1
  unsigned int v198; // ecx
  __m128i v199; // xmm0
  __m128i v200; // xmm1
  __m128i v201; // xmm2
  __m128i v202; // xmm3
  __m128i v203; // xmm4
  __m128i v204; // xmm5
  __m128i v205; // xmm6
  __m128i v206; // xmm7
  unsigned int v207; // ecx
  __m128i v208; // xmm0
  __m128i v209; // xmm1
  __m128i v210; // xmm2
  __m128i v211; // xmm3
  __m128i v212; // xmm0
  __m128i v213; // xmm1
  __m128i *v214; // edi
  char v215; // dl
  unsigned int v216; // ecx
  unsigned int v217; // edx
  __int8 *v218; // edi
  __int8 *v219; // esi
  const __m128i *v220; // [esp-4h] [ebp-4h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( a2 < (unsigned int)a3 )
    goto LABEL_5;
  if ( (_DWORD *)a2 == a3 )
    return a2;
  if ( a4 >= 0x30 )
  {
    v5 = a3;
    if ( a2 >= (unsigned int)a3 + a4 )
    {
LABEL_5:
      v7 = (__m128i *)(a4 + a2);
      v8 = (const __m128i *)((char *)v5 + a4);
      switch ( a4 )
      {
        case 0u:
          return a2;
        case 1u:
          goto LABEL_118;
        case 2u:
          goto LABEL_130;
        case 3u:
          goto LABEL_142;
        case 4u:
          goto LABEL_105;
        case 5u:
LABEL_107:
          v193 = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
          v194 = v8[-1].m128i_i32[3];
          *(__int32 *)((char *)&v7[-1].m128i_i32[2] + 3) = v193;
          v7[-1].m128i_i32[3] = v194;
          return a2;
        case 6u:
          goto LABEL_129;
        case 7u:
          goto LABEL_141;
        case 8u:
          goto LABEL_104;
        case 9u:
          goto LABEL_117;
        case 0xAu:
          goto LABEL_128;
        case 0xBu:
          goto LABEL_140;
        case 0xCu:
          goto LABEL_103;
        case 0xDu:
          goto LABEL_116;
        case 0xEu:
          goto LABEL_127;
        case 0xFu:
          goto LABEL_139;
        case 0x10u:
          goto LABEL_102;
        case 0x11u:
          goto LABEL_115;
        case 0x12u:
          goto LABEL_126;
        case 0x13u:
          goto LABEL_138;
        case 0x14u:
          goto LABEL_101;
        case 0x15u:
          goto LABEL_114;
        case 0x16u:
          goto LABEL_125;
        case 0x17u:
          goto LABEL_137;
        case 0x18u:
          goto LABEL_100;
        case 0x19u:
          goto LABEL_113;
        case 0x1Au:
          goto LABEL_124;
        case 0x1Bu:
          goto LABEL_136;
        case 0x1Cu:
          goto LABEL_99;
        case 0x1Du:
          goto LABEL_112;
        case 0x1Eu:
          goto LABEL_123;
        case 0x1Fu:
          goto LABEL_135;
        case 0x20u:
          goto LABEL_98;
        case 0x21u:
          goto LABEL_111;
        case 0x22u:
          goto LABEL_122;
        case 0x23u:
          goto LABEL_134;
        case 0x24u:
          goto LABEL_97;
        case 0x25u:
          goto LABEL_110;
        case 0x26u:
          goto LABEL_121;
        case 0x27u:
          goto LABEL_133;
        case 0x28u:
          goto LABEL_96;
        case 0x29u:
          goto LABEL_109;
        case 0x2Au:
          goto LABEL_120;
        case 0x2Bu:
          goto LABEL_132;
        case 0x2Cu:
LABEL_95:
          v7[-3].m128i_i32[1] = v8[-3].m128i_i32[1];
LABEL_96:
          v7[-3].m128i_i32[2] = v8[-3].m128i_i32[2];
LABEL_97:
          v7[-3].m128i_i32[3] = v8[-3].m128i_i32[3];
LABEL_98:
          v7[-2].m128i_i32[0] = v8[-2].m128i_i32[0];
LABEL_99:
          v7[-2].m128i_i32[1] = v8[-2].m128i_i32[1];
LABEL_100:
          v7[-2].m128i_i32[2] = v8[-2].m128i_i32[2];
LABEL_101:
          v7[-2].m128i_i32[3] = v8[-2].m128i_i32[3];
LABEL_102:
          v7[-1].m128i_i32[0] = v8[-1].m128i_i32[0];
LABEL_103:
          v7[-1].m128i_i32[1] = v8[-1].m128i_i32[1];
LABEL_104:
          v7[-1].m128i_i32[2] = v8[-1].m128i_i32[2];
LABEL_105:
          v7[-1].m128i_i32[3] = v8[-1].m128i_i32[3];
          return a2;
        case 0x2Du:
LABEL_108:
          *(__int32 *)((char *)v7[-3].m128i_i32 + 3) = *(__int32 *)((char *)v8[-3].m128i_i32 + 3);
LABEL_109:
          *(__int32 *)((char *)&v7[-3].m128i_i32[1] + 3) = *(__int32 *)((char *)&v8[-3].m128i_i32[1] + 3);
LABEL_110:
          *(__int32 *)((char *)&v7[-3].m128i_i32[2] + 3) = *(__int32 *)((char *)&v8[-3].m128i_i32[2] + 3);
LABEL_111:
          *(__int32 *)((char *)&v7[-3].m128i_i32[3] + 3) = *(__int32 *)((char *)&v8[-3].m128i_i32[3] + 3);
LABEL_112:
          *(__int32 *)((char *)v7[-2].m128i_i32 + 3) = *(__int32 *)((char *)v8[-2].m128i_i32 + 3);
LABEL_113:
          *(__int32 *)((char *)&v7[-2].m128i_i32[1] + 3) = *(__int32 *)((char *)&v8[-2].m128i_i32[1] + 3);
LABEL_114:
          *(__int32 *)((char *)&v7[-2].m128i_i32[2] + 3) = *(__int32 *)((char *)&v8[-2].m128i_i32[2] + 3);
LABEL_115:
          *(__int32 *)((char *)&v7[-2].m128i_i32[3] + 3) = *(__int32 *)((char *)&v8[-2].m128i_i32[3] + 3);
LABEL_116:
          *(__int32 *)((char *)v7[-1].m128i_i32 + 3) = *(__int32 *)((char *)v8[-1].m128i_i32 + 3);
LABEL_117:
          *(__int32 *)((char *)&v7[-1].m128i_i32[1] + 3) = *(__int32 *)((char *)&v8[-1].m128i_i32[1] + 3);
          *(__int32 *)((char *)&v7[-1].m128i_i32[2] + 3) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 3);
LABEL_118:
          v7[-1].m128i_i8[15] = v8[-1].m128i_i8[15];
          return a2;
        case 0x2Eu:
LABEL_119:
          *(__int32 *)((char *)v7[-3].m128i_i32 + 2) = *(__int32 *)((char *)v8[-3].m128i_i32 + 2);
LABEL_120:
          *(__int32 *)((char *)&v7[-3].m128i_i32[1] + 2) = *(__int32 *)((char *)&v8[-3].m128i_i32[1] + 2);
LABEL_121:
          *(__int32 *)((char *)&v7[-3].m128i_i32[2] + 2) = *(__int32 *)((char *)&v8[-3].m128i_i32[2] + 2);
LABEL_122:
          *(__int32 *)((char *)&v7[-3].m128i_i32[3] + 2) = *(__int32 *)((char *)&v8[-3].m128i_i32[3] + 2);
LABEL_123:
          *(__int32 *)((char *)v7[-2].m128i_i32 + 2) = *(__int32 *)((char *)v8[-2].m128i_i32 + 2);
LABEL_124:
          *(__int32 *)((char *)&v7[-2].m128i_i32[1] + 2) = *(__int32 *)((char *)&v8[-2].m128i_i32[1] + 2);
LABEL_125:
          *(__int32 *)((char *)&v7[-2].m128i_i32[2] + 2) = *(__int32 *)((char *)&v8[-2].m128i_i32[2] + 2);
LABEL_126:
          *(__int32 *)((char *)&v7[-2].m128i_i32[3] + 2) = *(__int32 *)((char *)&v8[-2].m128i_i32[3] + 2);
LABEL_127:
          *(__int32 *)((char *)v7[-1].m128i_i32 + 2) = *(__int32 *)((char *)v8[-1].m128i_i32 + 2);
LABEL_128:
          *(__int32 *)((char *)&v7[-1].m128i_i32[1] + 2) = *(__int32 *)((char *)&v8[-1].m128i_i32[1] + 2);
LABEL_129:
          *(__int32 *)((char *)&v7[-1].m128i_i32[2] + 2) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 2);
LABEL_130:
          v7[-1].m128i_i16[7] = v8[-1].m128i_i16[7];
          return a2;
        case 0x2Fu:
LABEL_131:
          *(__int32 *)((char *)v7[-3].m128i_i32 + 1) = *(__int32 *)((char *)v8[-3].m128i_i32 + 1);
LABEL_132:
          *(__int32 *)((char *)&v7[-3].m128i_i32[1] + 1) = *(__int32 *)((char *)&v8[-3].m128i_i32[1] + 1);
LABEL_133:
          *(__int32 *)((char *)&v7[-3].m128i_i32[2] + 1) = *(__int32 *)((char *)&v8[-3].m128i_i32[2] + 1);
LABEL_134:
          *(__int32 *)((char *)&v7[-3].m128i_i32[3] + 1) = *(__int32 *)((char *)&v8[-3].m128i_i32[3] + 1);
LABEL_135:
          *(__int32 *)((char *)v7[-2].m128i_i32 + 1) = *(__int32 *)((char *)v8[-2].m128i_i32 + 1);
LABEL_136:
          *(__int32 *)((char *)&v7[-2].m128i_i32[1] + 1) = *(__int32 *)((char *)&v8[-2].m128i_i32[1] + 1);
LABEL_137:
          *(__int32 *)((char *)&v7[-2].m128i_i32[2] + 1) = *(__int32 *)((char *)&v8[-2].m128i_i32[2] + 1);
LABEL_138:
          *(__int32 *)((char *)&v7[-2].m128i_i32[3] + 1) = *(__int32 *)((char *)&v8[-2].m128i_i32[3] + 1);
LABEL_139:
          *(__int32 *)((char *)v7[-1].m128i_i32 + 1) = *(__int32 *)((char *)v8[-1].m128i_i32 + 1);
LABEL_140:
          *(__int32 *)((char *)&v7[-1].m128i_i32[1] + 1) = *(__int32 *)((char *)&v8[-1].m128i_i32[1] + 1);
LABEL_141:
          *(__int32 *)((char *)&v7[-1].m128i_i32[2] + 1) = *(__int32 *)((char *)&v8[-1].m128i_i32[2] + 1);
LABEL_142:
          v195 = *(__int16 *)((char *)&v8[-1].m128i_i16[6] + 1);
          v196 = v8[-1].m128i_i8[15];
          *(__int16 *)((char *)&v7[-1].m128i_i16[6] + 1) = v195;
          v7[-1].m128i_i8[15] = v196;
          return a2;
        default:
          v9 = _mm_loadu_si128(v8);
          v10 = (__m128i *)(((unsigned int)v7 & 0xFFFFFFF0) + 16);
          v11 = (__m128i *)(a4 + a2);
          v12 = a4 + a2 - (_DWORD)v10;
          v13 = v12 + a4;
          v14 = (const __m128i *)((char *)v8 - v12);
          if ( v12 + a4 >= _x86_shared_cache_size_half )
          {
            v197 = _mm_loadu_si128(v14);
            *v11 = v9;
            _mm_stream_si128(v10, v197);
            ++v14;
            ++v10;
            v13 -= 16;
            if ( (_BYTE)v10 != (_BYTE)v14 )
            {
              v198 = v13 - 128;
              do
              {
                _mm_prefetch(v14[28].m128i_i8, 0);
                _mm_prefetch(v14[40].m128i_i8, 0);
                v199 = _mm_loadu_si128(v14);
                v200 = _mm_loadu_si128(v14 + 1);
                v201 = _mm_loadu_si128(v14 + 2);
                v202 = _mm_loadu_si128(v14 + 3);
                v203 = _mm_loadu_si128(v14 + 4);
                v204 = _mm_loadu_si128(v14 + 5);
                v205 = _mm_loadu_si128(v14 + 6);
                v206 = _mm_loadu_si128(v14 + 7);
                v14 += 8;
                _mm_lfence();
                v17 = v198 < 0x80;
                v198 -= 128;
                _mm_stream_si128(v10, v199);
                _mm_stream_si128(v10 + 1, v200);
                _mm_stream_si128(v10 + 2, v201);
                _mm_stream_si128(v10 + 3, v202);
                _mm_stream_si128(v10 + 4, v203);
                _mm_stream_si128(v10 + 5, v204);
                _mm_stream_si128(v10 + 6, v205);
                _mm_stream_si128(v10 + 7, v206);
                v10 += 8;
              }
              while ( !v17 );
              v207 = v198 + 128;
              if ( v207 >= 0x40 )
              {
                v208 = _mm_loadu_si128(v14);
                v209 = _mm_loadu_si128(v14 + 1);
                v210 = _mm_loadu_si128(v14 + 2);
                v211 = _mm_loadu_si128(v14 + 3);
                v14 += 4;
                _mm_stream_si128(v10, v208);
                _mm_stream_si128(v10 + 1, v209);
                _mm_stream_si128(v10 + 2, v210);
                _mm_stream_si128(v10 + 3, v211);
                v10 += 4;
                v207 -= 64;
              }
              while ( 2 )
              {
                v7 = (__m128i *)((char *)v10 + v207);
                v8 = (const __m128i *)((char *)v14 + v207);
                _mm_sfence();
                switch ( v207 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_118;
                  case 2u:
                    goto LABEL_130;
                  case 3u:
                    goto LABEL_142;
                  case 4u:
                    goto LABEL_105;
                  case 5u:
                    goto LABEL_107;
                  case 6u:
                    goto LABEL_129;
                  case 7u:
                    goto LABEL_141;
                  case 8u:
                    goto LABEL_104;
                  case 9u:
                    goto LABEL_117;
                  case 0xAu:
                    goto LABEL_128;
                  case 0xBu:
                    goto LABEL_140;
                  case 0xCu:
                    goto LABEL_103;
                  case 0xDu:
                    goto LABEL_116;
                  case 0xEu:
                    goto LABEL_127;
                  case 0xFu:
                    goto LABEL_139;
                  case 0x10u:
                    goto LABEL_102;
                  case 0x11u:
                    goto LABEL_115;
                  case 0x12u:
                    goto LABEL_126;
                  case 0x13u:
                    goto LABEL_138;
                  case 0x14u:
                    goto LABEL_101;
                  case 0x15u:
                    goto LABEL_114;
                  case 0x16u:
                    goto LABEL_125;
                  case 0x17u:
                    goto LABEL_137;
                  case 0x18u:
                    goto LABEL_100;
                  case 0x19u:
                    goto LABEL_113;
                  case 0x1Au:
                    goto LABEL_124;
                  case 0x1Bu:
                    goto LABEL_136;
                  case 0x1Cu:
                    goto LABEL_99;
                  case 0x1Du:
                    goto LABEL_112;
                  case 0x1Eu:
                    goto LABEL_123;
                  case 0x1Fu:
                    goto LABEL_135;
                  default:
                    v212 = _mm_loadu_si128(v8);
                    v213 = _mm_loadu_si128(v8 + 1);
                    v14 = v8 + 2;
                    _mm_stream_si128(v7, v212);
                    _mm_stream_si128(v7 + 1, v213);
                    v10 = v7 + 2;
                    v207 -= 32;
                    continue;
                }
              }
            }
          }
          else
          {
            if ( ((unsigned __int8)v14 & 0xF) != 0 )
            {
              switch ( (unsigned __int8)v14 & 0xF )
              {
                case 0:
                  break;
                case 1:
                  v57 = (__m128i *)&v14[-1].m128i_i8[15];
                  v58 = *v57;
                  v59 = 0;
                  v60 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    si128 = _mm_load_si128(&v57[v59 + 1]);
                    v17 = v60 < 0x20;
                    v60 -= 32;
                    v62 = _mm_load_si128(&v57[v59 + 2]);
                    v59 += 2;
                    v10[v59 - 2] = _mm_alignr_epi8(si128, v58, 1);
                    v10[v59 - 1] = _mm_alignr_epi8(v62, si128, 1);
                    if ( v17 )
                      break;
                    v63 = _mm_load_si128(&v57[v59 + 1]);
                    v17 = v60 < 0x20;
                    v60 -= 32;
                    v58 = _mm_load_si128(&v57[v59 + 2]);
                    v59 += 2;
                    v10[v59 - 2] = _mm_alignr_epi8(v63, v62, 1);
                    v10[v59 - 1] = _mm_alignr_epi8(v58, v63, 1);
                  }
                  while ( !v17 );
                  v64 = v60 + 32;
                  v65 = v64 + v59 * 16;
                  v7 = (__m128i *)((char *)v10 + v65);
                  v8 = (const __m128i *)&v57->m128i_i8[v65 + 1];
                  switch ( v64 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 2:
                  v66 = (__m128i *)&v14[-1].m128i_i8[14];
                  v67 = *v66;
                  v68 = 0;
                  v69 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v70 = _mm_load_si128(&v66[v68 + 1]);
                    v17 = v69 < 0x20;
                    v69 -= 32;
                    v71 = _mm_load_si128(&v66[v68 + 2]);
                    v68 += 2;
                    v10[v68 - 2] = _mm_alignr_epi8(v70, v67, 2);
                    v10[v68 - 1] = _mm_alignr_epi8(v71, v70, 2);
                    if ( v17 )
                      break;
                    v72 = _mm_load_si128(&v66[v68 + 1]);
                    v17 = v69 < 0x20;
                    v69 -= 32;
                    v67 = _mm_load_si128(&v66[v68 + 2]);
                    v68 += 2;
                    v10[v68 - 2] = _mm_alignr_epi8(v72, v71, 2);
                    v10[v68 - 1] = _mm_alignr_epi8(v67, v72, 2);
                  }
                  while ( !v17 );
                  v73 = v69 + 32;
                  v74 = v73 + v68 * 16;
                  v7 = (__m128i *)((char *)v10 + v74);
                  v8 = (const __m128i *)&v66->m128i_i8[v74 + 2];
                  switch ( v73 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 3:
                  v75 = (__m128i *)&v14[-1].m128i_i8[13];
                  v76 = *v75;
                  v77 = 0;
                  v78 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v79 = _mm_load_si128(&v75[v77 + 1]);
                    v17 = v78 < 0x20;
                    v78 -= 32;
                    v80 = _mm_load_si128(&v75[v77 + 2]);
                    v77 += 2;
                    v10[v77 - 2] = _mm_alignr_epi8(v79, v76, 3);
                    v10[v77 - 1] = _mm_alignr_epi8(v80, v79, 3);
                    if ( v17 )
                      break;
                    v81 = _mm_load_si128(&v75[v77 + 1]);
                    v17 = v78 < 0x20;
                    v78 -= 32;
                    v76 = _mm_load_si128(&v75[v77 + 2]);
                    v77 += 2;
                    v10[v77 - 2] = _mm_alignr_epi8(v81, v80, 3);
                    v10[v77 - 1] = _mm_alignr_epi8(v76, v81, 3);
                  }
                  while ( !v17 );
                  v82 = v78 + 32;
                  v83 = v82 + v77 * 16;
                  v7 = (__m128i *)((char *)v10 + v83);
                  v8 = (const __m128i *)&v75->m128i_i8[v83 + 3];
                  switch ( v82 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 4:
                  v84 = (__m128i *)&v14[-1].m128i_i8[12];
                  v85 = *v84;
                  v86 = 0;
                  v87 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v88 = _mm_load_si128(&v84[v86 + 1]);
                    v17 = v87 < 0x20;
                    v87 -= 32;
                    v89 = _mm_load_si128(&v84[v86 + 2]);
                    v86 += 2;
                    v10[v86 - 2] = _mm_alignr_epi8(v88, v85, 4);
                    v10[v86 - 1] = _mm_alignr_epi8(v89, v88, 4);
                    if ( v17 )
                      break;
                    v90 = _mm_load_si128(&v84[v86 + 1]);
                    v17 = v87 < 0x20;
                    v87 -= 32;
                    v85 = _mm_load_si128(&v84[v86 + 2]);
                    v86 += 2;
                    v10[v86 - 2] = _mm_alignr_epi8(v90, v89, 4);
                    v10[v86 - 1] = _mm_alignr_epi8(v85, v90, 4);
                  }
                  while ( !v17 );
                  v91 = v87 + 32;
                  v92 = v91 + v86 * 16;
                  v7 = (__m128i *)((char *)v10 + v92);
                  v8 = (const __m128i *)&v84->m128i_i8[v92 + 4];
                  switch ( v91 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 5:
                  v93 = (__m128i *)&v14[-1].m128i_i8[11];
                  v94 = *v93;
                  v95 = 0;
                  v96 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v97 = _mm_load_si128(&v93[v95 + 1]);
                    v17 = v96 < 0x20;
                    v96 -= 32;
                    v98 = _mm_load_si128(&v93[v95 + 2]);
                    v95 += 2;
                    v10[v95 - 2] = _mm_alignr_epi8(v97, v94, 5);
                    v10[v95 - 1] = _mm_alignr_epi8(v98, v97, 5);
                    if ( v17 )
                      break;
                    v99 = _mm_load_si128(&v93[v95 + 1]);
                    v17 = v96 < 0x20;
                    v96 -= 32;
                    v94 = _mm_load_si128(&v93[v95 + 2]);
                    v95 += 2;
                    v10[v95 - 2] = _mm_alignr_epi8(v99, v98, 5);
                    v10[v95 - 1] = _mm_alignr_epi8(v94, v99, 5);
                  }
                  while ( !v17 );
                  v100 = v96 + 32;
                  v101 = v100 + v95 * 16;
                  v7 = (__m128i *)((char *)v10 + v101);
                  v8 = (const __m128i *)&v93->m128i_i8[v101 + 5];
                  switch ( v100 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 6:
                  v102 = (__m128i *)&v14[-1].m128i_i8[10];
                  v103 = *v102;
                  v104 = 0;
                  v105 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v106 = _mm_load_si128(&v102[v104 + 1]);
                    v17 = v105 < 0x20;
                    v105 -= 32;
                    v107 = _mm_load_si128(&v102[v104 + 2]);
                    v104 += 2;
                    v10[v104 - 2] = _mm_alignr_epi8(v106, v103, 6);
                    v10[v104 - 1] = _mm_alignr_epi8(v107, v106, 6);
                    if ( v17 )
                      break;
                    v108 = _mm_load_si128(&v102[v104 + 1]);
                    v17 = v105 < 0x20;
                    v105 -= 32;
                    v103 = _mm_load_si128(&v102[v104 + 2]);
                    v104 += 2;
                    v10[v104 - 2] = _mm_alignr_epi8(v108, v107, 6);
                    v10[v104 - 1] = _mm_alignr_epi8(v103, v108, 6);
                  }
                  while ( !v17 );
                  v109 = v105 + 32;
                  v110 = v109 + v104 * 16;
                  v7 = (__m128i *)((char *)v10 + v110);
                  v8 = (const __m128i *)&v102->m128i_i8[v110 + 6];
                  switch ( v109 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 7:
                  v111 = (__m128i *)&v14[-1].m128i_i8[9];
                  v112 = *v111;
                  v113 = 0;
                  v114 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v115 = _mm_load_si128(&v111[v113 + 1]);
                    v17 = v114 < 0x20;
                    v114 -= 32;
                    v116 = _mm_load_si128(&v111[v113 + 2]);
                    v113 += 2;
                    v10[v113 - 2] = _mm_alignr_epi8(v115, v112, 7);
                    v10[v113 - 1] = _mm_alignr_epi8(v116, v115, 7);
                    if ( v17 )
                      break;
                    v117 = _mm_load_si128(&v111[v113 + 1]);
                    v17 = v114 < 0x20;
                    v114 -= 32;
                    v112 = _mm_load_si128(&v111[v113 + 2]);
                    v113 += 2;
                    v10[v113 - 2] = _mm_alignr_epi8(v117, v116, 7);
                    v10[v113 - 1] = _mm_alignr_epi8(v112, v117, 7);
                  }
                  while ( !v17 );
                  v118 = v114 + 32;
                  v119 = v118 + v113 * 16;
                  v7 = (__m128i *)((char *)v10 + v119);
                  v8 = (const __m128i *)&v111->m128i_i8[v119 + 7];
                  switch ( v118 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 8:
                  v120 = (__m128i *)&v14[-1].m128i_i8[8];
                  v121 = *v120;
                  v122 = 0;
                  v123 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v124 = _mm_load_si128(&v120[v122 + 1]);
                    v17 = v123 < 0x20;
                    v123 -= 32;
                    v125 = _mm_load_si128(&v120[v122 + 2]);
                    v122 += 2;
                    v10[v122 - 2] = _mm_alignr_epi8(v124, v121, 8);
                    v10[v122 - 1] = _mm_alignr_epi8(v125, v124, 8);
                    if ( v17 )
                      break;
                    v126 = _mm_load_si128(&v120[v122 + 1]);
                    v17 = v123 < 0x20;
                    v123 -= 32;
                    v121 = _mm_load_si128(&v120[v122 + 2]);
                    v122 += 2;
                    v10[v122 - 2] = _mm_alignr_epi8(v126, v125, 8);
                    v10[v122 - 1] = _mm_alignr_epi8(v121, v126, 8);
                  }
                  while ( !v17 );
                  v127 = v123 + 32;
                  v128 = v127 + v122 * 16;
                  v7 = (__m128i *)((char *)v10 + v128);
                  v8 = (const __m128i *)&v120->m128i_i8[v128 + 8];
                  switch ( v127 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 9:
                  v129 = (__m128i *)&v14[-1].m128i_i8[7];
                  v130 = *v129;
                  v131 = 0;
                  v132 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v133 = _mm_load_si128(&v129[v131 + 1]);
                    v17 = v132 < 0x20;
                    v132 -= 32;
                    v134 = _mm_load_si128(&v129[v131 + 2]);
                    v131 += 2;
                    v10[v131 - 2] = _mm_alignr_epi8(v133, v130, 9);
                    v10[v131 - 1] = _mm_alignr_epi8(v134, v133, 9);
                    if ( v17 )
                      break;
                    v135 = _mm_load_si128(&v129[v131 + 1]);
                    v17 = v132 < 0x20;
                    v132 -= 32;
                    v130 = _mm_load_si128(&v129[v131 + 2]);
                    v131 += 2;
                    v10[v131 - 2] = _mm_alignr_epi8(v135, v134, 9);
                    v10[v131 - 1] = _mm_alignr_epi8(v130, v135, 9);
                  }
                  while ( !v17 );
                  v136 = v132 + 32;
                  v137 = v136 + v131 * 16;
                  v7 = (__m128i *)((char *)v10 + v137);
                  v8 = (const __m128i *)&v129->m128i_i8[v137 + 9];
                  switch ( v136 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 0xA:
                  v138 = (__m128i *)&v14[-1].m128i_i8[6];
                  v139 = *v138;
                  v140 = 0;
                  v141 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v142 = _mm_load_si128(&v138[v140 + 1]);
                    v17 = v141 < 0x20;
                    v141 -= 32;
                    v143 = _mm_load_si128(&v138[v140 + 2]);
                    v140 += 2;
                    v10[v140 - 2] = _mm_alignr_epi8(v142, v139, 10);
                    v10[v140 - 1] = _mm_alignr_epi8(v143, v142, 10);
                    if ( v17 )
                      break;
                    v144 = _mm_load_si128(&v138[v140 + 1]);
                    v17 = v141 < 0x20;
                    v141 -= 32;
                    v139 = _mm_load_si128(&v138[v140 + 2]);
                    v140 += 2;
                    v10[v140 - 2] = _mm_alignr_epi8(v144, v143, 10);
                    v10[v140 - 1] = _mm_alignr_epi8(v139, v144, 10);
                  }
                  while ( !v17 );
                  v145 = v141 + 32;
                  v146 = v145 + v140 * 16;
                  v7 = (__m128i *)((char *)v10 + v146);
                  v8 = (const __m128i *)&v138->m128i_i8[v146 + 10];
                  switch ( v145 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 0xB:
                  v147 = (__m128i *)&v14[-1].m128i_i8[5];
                  v148 = *v147;
                  v149 = 0;
                  v150 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v151 = _mm_load_si128(&v147[v149 + 1]);
                    v17 = v150 < 0x20;
                    v150 -= 32;
                    v152 = _mm_load_si128(&v147[v149 + 2]);
                    v149 += 2;
                    v10[v149 - 2] = _mm_alignr_epi8(v151, v148, 11);
                    v10[v149 - 1] = _mm_alignr_epi8(v152, v151, 11);
                    if ( v17 )
                      break;
                    v153 = _mm_load_si128(&v147[v149 + 1]);
                    v17 = v150 < 0x20;
                    v150 -= 32;
                    v148 = _mm_load_si128(&v147[v149 + 2]);
                    v149 += 2;
                    v10[v149 - 2] = _mm_alignr_epi8(v153, v152, 11);
                    v10[v149 - 1] = _mm_alignr_epi8(v148, v153, 11);
                  }
                  while ( !v17 );
                  v154 = v150 + 32;
                  v155 = v154 + v149 * 16;
                  v7 = (__m128i *)((char *)v10 + v155);
                  v8 = (const __m128i *)&v147->m128i_i8[v155 + 11];
                  switch ( v154 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 0xC:
                  v156 = (__m128i *)&v14[-1].m128i_i8[4];
                  v157 = *v156;
                  v158 = 0;
                  v159 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v160 = _mm_load_si128(&v156[v158 + 1]);
                    v17 = v159 < 0x20;
                    v159 -= 32;
                    v161 = _mm_load_si128(&v156[v158 + 2]);
                    v158 += 2;
                    v10[v158 - 2] = _mm_alignr_epi8(v160, v157, 12);
                    v10[v158 - 1] = _mm_alignr_epi8(v161, v160, 12);
                    if ( v17 )
                      break;
                    v162 = _mm_load_si128(&v156[v158 + 1]);
                    v17 = v159 < 0x20;
                    v159 -= 32;
                    v157 = _mm_load_si128(&v156[v158 + 2]);
                    v158 += 2;
                    v10[v158 - 2] = _mm_alignr_epi8(v162, v161, 12);
                    v10[v158 - 1] = _mm_alignr_epi8(v157, v162, 12);
                  }
                  while ( !v17 );
                  v163 = v159 + 32;
                  v164 = v163 + v158 * 16;
                  v7 = (__m128i *)((char *)v10 + v164);
                  v8 = (const __m128i *)&v156->m128i_i8[v164 + 12];
                  switch ( v163 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 0xD:
                  v165 = (__m128i *)&v14[-1].m128i_i8[3];
                  v166 = *v165;
                  v167 = 0;
                  v168 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v169 = _mm_load_si128(&v165[v167 + 1]);
                    v17 = v168 < 0x20;
                    v168 -= 32;
                    v170 = _mm_load_si128(&v165[v167 + 2]);
                    v167 += 2;
                    v10[v167 - 2] = _mm_alignr_epi8(v169, v166, 13);
                    v10[v167 - 1] = _mm_alignr_epi8(v170, v169, 13);
                    if ( v17 )
                      break;
                    v171 = _mm_load_si128(&v165[v167 + 1]);
                    v17 = v168 < 0x20;
                    v168 -= 32;
                    v166 = _mm_load_si128(&v165[v167 + 2]);
                    v167 += 2;
                    v10[v167 - 2] = _mm_alignr_epi8(v171, v170, 13);
                    v10[v167 - 1] = _mm_alignr_epi8(v166, v171, 13);
                  }
                  while ( !v17 );
                  v172 = v168 + 32;
                  v173 = v172 + v167 * 16;
                  v7 = (__m128i *)((char *)v10 + v173);
                  v8 = (const __m128i *)&v165->m128i_i8[v173 + 13];
                  switch ( v172 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 0xE:
                  v174 = (__m128i *)&v14[-1].m128i_i8[2];
                  v175 = *v174;
                  v176 = 0;
                  v177 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v178 = _mm_load_si128(&v174[v176 + 1]);
                    v17 = v177 < 0x20;
                    v177 -= 32;
                    v179 = _mm_load_si128(&v174[v176 + 2]);
                    v176 += 2;
                    v10[v176 - 2] = _mm_alignr_epi8(v178, v175, 14);
                    v10[v176 - 1] = _mm_alignr_epi8(v179, v178, 14);
                    if ( v17 )
                      break;
                    v180 = _mm_load_si128(&v174[v176 + 1]);
                    v17 = v177 < 0x20;
                    v177 -= 32;
                    v175 = _mm_load_si128(&v174[v176 + 2]);
                    v176 += 2;
                    v10[v176 - 2] = _mm_alignr_epi8(v180, v179, 14);
                    v10[v176 - 1] = _mm_alignr_epi8(v175, v180, 14);
                  }
                  while ( !v17 );
                  v181 = v177 + 32;
                  v182 = v181 + v176 * 16;
                  v7 = (__m128i *)((char *)v10 + v182);
                  v8 = (const __m128i *)&v174->m128i_i8[v182 + 14];
                  switch ( v181 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
                case 0xF:
                  v183 = (__m128i *)&v14[-1].m128i_i8[1];
                  v184 = *v183;
                  v185 = 0;
                  v186 = v13 - 32;
                  *v11 = v9;
                  do
                  {
                    v187 = _mm_load_si128(&v183[v185 + 1]);
                    v17 = v186 < 0x20;
                    v186 -= 32;
                    v188 = _mm_load_si128(&v183[v185 + 2]);
                    v185 += 2;
                    v10[v185 - 2] = _mm_alignr_epi8(v187, v184, 15);
                    v10[v185 - 1] = _mm_alignr_epi8(v188, v187, 15);
                    if ( v17 )
                      break;
                    v189 = _mm_load_si128(&v183[v185 + 1]);
                    v17 = v186 < 0x20;
                    v186 -= 32;
                    v184 = _mm_load_si128(&v183[v185 + 2]);
                    v185 += 2;
                    v10[v185 - 2] = _mm_alignr_epi8(v189, v188, 15);
                    v10[v185 - 1] = _mm_alignr_epi8(v184, v189, 15);
                  }
                  while ( !v17 );
                  v190 = v186 + 32;
                  v191 = v190 + v185 * 16;
                  v7 = (__m128i *)((char *)v10 + v191);
                  v8 = (const __m128i *)&v183->m128i_i8[v191 + 15];
                  switch ( v190 )
                  {
                    case 0u:
                      return a2;
                    case 1u:
                      goto LABEL_118;
                    case 2u:
                      goto LABEL_130;
                    case 3u:
                      goto LABEL_142;
                    case 4u:
                      goto LABEL_105;
                    case 5u:
                      goto LABEL_107;
                    case 6u:
                      goto LABEL_129;
                    case 7u:
                      goto LABEL_141;
                    case 8u:
                      goto LABEL_104;
                    case 9u:
                      goto LABEL_117;
                    case 0xAu:
                      goto LABEL_128;
                    case 0xBu:
                      goto LABEL_140;
                    case 0xCu:
                      goto LABEL_103;
                    case 0xDu:
                      goto LABEL_116;
                    case 0xEu:
                      goto LABEL_127;
                    case 0xFu:
                      goto LABEL_139;
                    case 0x10u:
                      goto LABEL_102;
                    case 0x11u:
                      goto LABEL_115;
                    case 0x12u:
                      goto LABEL_126;
                    case 0x13u:
                      goto LABEL_138;
                    case 0x14u:
                      goto LABEL_101;
                    case 0x15u:
                      goto LABEL_114;
                    case 0x16u:
                      goto LABEL_125;
                    case 0x17u:
                      goto LABEL_137;
                    case 0x18u:
                      goto LABEL_100;
                    case 0x19u:
                      goto LABEL_113;
                    case 0x1Au:
                      goto LABEL_124;
                    case 0x1Bu:
                      goto LABEL_136;
                    case 0x1Cu:
                      goto LABEL_99;
                    case 0x1Du:
                      goto LABEL_112;
                    case 0x1Eu:
                      goto LABEL_123;
                    case 0x1Fu:
                      goto LABEL_135;
                    case 0x20u:
                      goto LABEL_98;
                    case 0x21u:
                      goto LABEL_111;
                    case 0x22u:
                      goto LABEL_122;
                    case 0x23u:
                      goto LABEL_134;
                    case 0x24u:
                      goto LABEL_97;
                    case 0x25u:
                      goto LABEL_110;
                    case 0x26u:
                      goto LABEL_121;
                    case 0x27u:
                      goto LABEL_133;
                    case 0x28u:
                      goto LABEL_96;
                    case 0x29u:
                      goto LABEL_109;
                    case 0x2Au:
                      goto LABEL_120;
                    case 0x2Bu:
                      goto LABEL_132;
                    case 0x2Cu:
                      goto LABEL_95;
                    case 0x2Du:
                      goto LABEL_108;
                    case 0x2Eu:
                      goto LABEL_119;
                    case 0x2Fu:
                      goto LABEL_131;
                  }
              }
            }
            *v11 = v9;
            if ( v13 <= 0x7F )
            {
              v15 = v13 - 32;
              v16 = _mm_load_si128(v14 + 1);
              v17 = v15 < 0x20;
              v18 = v15 - 32;
              *v10 = _mm_load_si128(v14);
              v10[1] = v16;
              v19 = 32;
              if ( !v17 )
              {
                v20 = _mm_load_si128(v14 + 3);
                v17 = v18 < 0x20;
                v18 -= 32;
                v10[2] = _mm_load_si128(v14 + 2);
                v10[3] = v20;
                v19 = 64;
                if ( !v17 )
                {
                  v21 = _mm_load_si128(v14 + 5);
                  v17 = v18 < 0x20;
                  v18 -= 32;
                  v10[4] = _mm_load_si128(v14 + 4);
                  v10[5] = v21;
                  v19 = 96;
                  if ( !v17 )
                  {
                    v22 = _mm_load_si128(v14 + 7);
                    v18 -= 32;
                    v10[6] = _mm_load_si128(v14 + 6);
                    v10[7] = v22;
                    v19 = 128;
                  }
                }
              }
              v23 = v18 + 32;
              v24 = v23 + v19;
              v7 = (__m128i *)((char *)v10 + v24);
              v8 = (const __m128i *)((char *)v14 + v24);
              switch ( v23 )
              {
                case 0u:
                  return a2;
                case 1u:
                  goto LABEL_118;
                case 2u:
                  goto LABEL_130;
                case 3u:
                  goto LABEL_142;
                case 4u:
                  goto LABEL_105;
                case 5u:
                  goto LABEL_107;
                case 6u:
                  goto LABEL_129;
                case 7u:
                  goto LABEL_141;
                case 8u:
                  goto LABEL_104;
                case 9u:
                  goto LABEL_117;
                case 0xAu:
                  goto LABEL_128;
                case 0xBu:
                  goto LABEL_140;
                case 0xCu:
                  goto LABEL_103;
                case 0xDu:
                  goto LABEL_116;
                case 0xEu:
                  goto LABEL_127;
                case 0xFu:
                  goto LABEL_139;
                case 0x10u:
                  goto LABEL_102;
                case 0x11u:
                  goto LABEL_115;
                case 0x12u:
                  goto LABEL_126;
                case 0x13u:
                  goto LABEL_138;
                case 0x14u:
                  goto LABEL_101;
                case 0x15u:
                  goto LABEL_114;
                case 0x16u:
                  goto LABEL_125;
                case 0x17u:
                  goto LABEL_137;
                case 0x18u:
                  goto LABEL_100;
                case 0x19u:
                  goto LABEL_113;
                case 0x1Au:
                  goto LABEL_124;
                case 0x1Bu:
                  goto LABEL_136;
                case 0x1Cu:
                  goto LABEL_99;
                case 0x1Du:
                  goto LABEL_112;
                case 0x1Eu:
                  goto LABEL_123;
                case 0x1Fu:
                  goto LABEL_135;
                case 0x20u:
                  goto LABEL_98;
                case 0x21u:
                  goto LABEL_111;
                case 0x22u:
                  goto LABEL_122;
                case 0x23u:
                  goto LABEL_134;
                case 0x24u:
                  goto LABEL_97;
                case 0x25u:
                  goto LABEL_110;
                case 0x26u:
                  goto LABEL_121;
                case 0x27u:
                  goto LABEL_133;
                case 0x28u:
                  goto LABEL_96;
                case 0x29u:
                  goto LABEL_109;
                case 0x2Au:
                  goto LABEL_120;
                case 0x2Bu:
                  goto LABEL_132;
                case 0x2Cu:
                  goto LABEL_95;
                case 0x2Du:
                  goto LABEL_108;
                case 0x2Eu:
                  goto LABEL_119;
                case 0x2Fu:
                  goto LABEL_131;
              }
            }
            if ( v13 < _x86_data_cache_size_half - ((unsigned int)_x86_data_cache_size_half >> 3) )
            {
              v25 = v13 - 128;
              do
              {
                v26 = _mm_load_si128(v14);
                v27 = v14[1];
                v28 = v14[2];
                v29 = v14[3];
                v30 = v14[4];
                v31 = v14[5];
                v32 = v14[6];
                v33 = v14[7];
                v14 += 8;
                v17 = v25 < 0x80;
                v25 -= 128;
                *v10 = v26;
                v10[1] = v27;
                v10[2] = v28;
                v10[3] = v29;
                v10[4] = v30;
                v10[5] = v31;
                v10[6] = v32;
                v10[7] = v33;
                v10 += 8;
              }
              while ( !v17 );
              v34 = v25 + 128;
              if ( v34 >= 0x40 )
              {
                v34 -= 64;
                v35 = _mm_load_si128(v14 + 1);
                *v10 = _mm_load_si128(v14);
                v10[1] = v35;
                v36 = _mm_load_si128(v14 + 2);
                v37 = _mm_load_si128(v14 + 3);
                v14 += 4;
                v10[2] = v36;
                v10[3] = v37;
                v10 += 4;
              }
              if ( v34 >= 0x20 )
              {
                v38 = _mm_load_si128(v14);
                v34 -= 32;
                v39 = _mm_load_si128(v14 + 1);
                v14 += 2;
                *v10 = v38;
                v10[1] = v39;
                v10 += 2;
              }
              while ( 2 )
              {
                v7 = (__m128i *)((char *)v10 + v34);
                v8 = (const __m128i *)((char *)v14 + v34);
                switch ( v34 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_118;
                  case 2u:
                    goto LABEL_130;
                  case 3u:
                    goto LABEL_142;
                  case 4u:
                    goto LABEL_105;
                  case 5u:
                    goto LABEL_107;
                  case 6u:
                    goto LABEL_129;
                  case 7u:
                    goto LABEL_141;
                  case 8u:
                    goto LABEL_104;
                  case 9u:
                    goto LABEL_117;
                  case 0xAu:
                    goto LABEL_128;
                  case 0xBu:
                    goto LABEL_140;
                  case 0xCu:
                    goto LABEL_103;
                  case 0xDu:
                    goto LABEL_116;
                  case 0xEu:
                    goto LABEL_127;
                  case 0xFu:
                    goto LABEL_139;
                  default:
                    v34 -= 16;
                    v40 = _mm_load_si128(v8);
                    v14 = v8 + 1;
                    *v7 = v40;
                    v10 = v7 + 1;
                    continue;
                }
              }
            }
            if ( (_BYTE)v10 != (_BYTE)v14 )
            {
              v41 = v13 - 128;
              do
              {
                _mm_prefetch(v14[28].m128i_i8, 0);
                _mm_prefetch(v14[40].m128i_i8, 0);
                _mm_prefetch(v10[28].m128i_i8, 0);
                _mm_prefetch(v10[40].m128i_i8, 0);
                v42 = _mm_load_si128(v14);
                v43 = v14[1];
                v44 = v14[2];
                v45 = v14[3];
                v46 = v14[4];
                v47 = v14[5];
                v48 = v14[6];
                v49 = v14[7];
                v14 += 8;
                v17 = v41 < 0x80;
                v41 -= 128;
                *v10 = v42;
                v10[1] = v43;
                v10[2] = v44;
                v10[3] = v45;
                v10[4] = v46;
                v10[5] = v47;
                v10[6] = v48;
                v10[7] = v49;
                v10 += 8;
              }
              while ( !v17 );
              v50 = v41 + 128;
              if ( v50 >= 0x40 )
              {
                v50 -= 64;
                v51 = _mm_load_si128(v14 + 1);
                *v10 = _mm_load_si128(v14);
                v10[1] = v51;
                v52 = _mm_load_si128(v14 + 2);
                v53 = _mm_load_si128(v14 + 3);
                v14 += 4;
                v10[2] = v52;
                v10[3] = v53;
                v10 += 4;
              }
              if ( v50 >= 0x20 )
              {
                v54 = _mm_load_si128(v14);
                v50 -= 32;
                v55 = _mm_load_si128(v14 + 1);
                v14 += 2;
                *v10 = v54;
                v10[1] = v55;
                v10 += 2;
              }
              while ( 2 )
              {
                v7 = (__m128i *)((char *)v10 + v50);
                v8 = (const __m128i *)((char *)v14 + v50);
                switch ( v50 )
                {
                  case 0u:
                    return a2;
                  case 1u:
                    goto LABEL_118;
                  case 2u:
                    goto LABEL_130;
                  case 3u:
                    goto LABEL_142;
                  case 4u:
                    goto LABEL_105;
                  case 5u:
                    goto LABEL_107;
                  case 6u:
                    goto LABEL_129;
                  case 7u:
                    goto LABEL_141;
                  case 8u:
                    goto LABEL_104;
                  case 9u:
                    goto LABEL_117;
                  case 0xAu:
                    goto LABEL_128;
                  case 0xBu:
                    goto LABEL_140;
                  case 0xCu:
                    goto LABEL_103;
                  case 0xDu:
                    goto LABEL_116;
                  case 0xEu:
                    goto LABEL_127;
                  case 0xFu:
                    goto LABEL_139;
                  default:
                    v50 -= 16;
                    v56 = _mm_load_si128(v8);
                    v14 = v8 + 1;
                    *v7 = v56;
                    v10 = v7 + 1;
                    continue;
                }
              }
            }
          }
          v214 = v10;
          v215 = v13;
          v216 = v13 >> 2;
          v217 = v215 & 3;
          qmemcpy(v214, v14, 4 * v216);
          v219 = &v14->m128i_i8[4 * v216];
          v218 = &v214->m128i_i8[4 * v216];
          if ( v217 )
          {
            if ( v217 < 2 || (*(_WORD *)v218 = *(_WORD *)v219, v219 += 2, v218 += 2, v217 != 2) )
              *v218 = *v219;
          }
          return a2;
      }
    }
    v220 = a1;
    v6 = a4 + a2;
    a1 = (const __m128i *)((char *)a3 + a4);
    if ( ((a4 + a2) & 3) != 0 )
    {
      if ( (v6 & 1) == 0
        || (a1 = (const __m128i *)((char *)a1 - 1), v4 = a4 - 1, --v6, *(_BYTE *)v6 = a1->m128i_i8[0], (v6 & 2) != 0) )
      {
        a1 = (const __m128i *)((char *)a1 - 2);
        v4 -= 2;
        v6 -= 2;
        *(_WORD *)v6 = a1->m128i_i16[0];
      }
    }
    if ( v4 >= 0x40 )
    {
      if ( (v6 & 0xF) != 0 )
      {
        a1 = (const __m128i *)((char *)a1 - 4);
        v4 -= 4;
        v6 -= 4;
        *(_DWORD *)v6 = a1->m128i_i32[0];
        if ( (v6 & 0xF) != 0 )
        {
          a1 = (const __m128i *)((char *)a1 - 4);
          v4 -= 4;
          v6 -= 4;
          *(_DWORD *)v6 = a1->m128i_i32[0];
          if ( (v6 & 0xF) != 0 )
          {
            a1 = (const __m128i *)((char *)a1 - 4);
            v4 -= 4;
            v6 -= 4;
            *(_DWORD *)v6 = a1->m128i_i32[0];
          }
        }
      }
      if ( v4 < 0x40 )
      {
LABEL_191:
        v4 -= 32;
        *(_DWORD *)(v6 - 4) = a1[-1].m128i_i32[3];
        *(_DWORD *)(v6 - 8) = a1[-1].m128i_i32[2];
        *(_DWORD *)(v6 - 12) = a1[-1].m128i_i32[1];
        *(_DWORD *)(v6 - 16) = a1[-1].m128i_i32[0];
        *(_DWORD *)(v6 - 20) = a1[-2].m128i_i32[3];
        *(_DWORD *)(v6 - 24) = a1[-2].m128i_i32[2];
        *(_DWORD *)(v6 - 28) = a1[-2].m128i_i32[1];
        *(_DWORD *)(v6 - 32) = a1[-2].m128i_i32[0];
        v6 -= 32;
        a1 -= 2;
      }
      else
      {
        do
        {
          a1 -= 4;
          v4 -= 64;
          v6 -= 64;
          *(__m128i *)(v6 + 48) = _mm_loadu_si128(a1 + 3);
          *(__m128i *)(v6 + 32) = _mm_loadu_si128(a1 + 2);
          *(__m128i *)(v6 + 16) = _mm_loadu_si128(a1 + 1);
          *(__m128i *)v6 = _mm_loadu_si128(a1);
        }
        while ( v4 >= 0x40 );
      }
    }
    v6 -= v4;
    v5 = (__int32 *)((char *)a1->m128i_i32 - v4);
    a1 = v220;
  }
  switch ( v4 )
  {
    case 0u:
      goto LABEL_163;
    case 1u:
      goto LABEL_171;
    case 2u:
      goto LABEL_179;
    case 3u:
      goto LABEL_187;
    case 4u:
      goto LABEL_162;
    case 5u:
      goto LABEL_170;
    case 6u:
      goto LABEL_178;
    case 7u:
      goto LABEL_186;
    case 8u:
      goto LABEL_161;
    case 9u:
      goto LABEL_169;
    case 0xAu:
      goto LABEL_177;
    case 0xBu:
      goto LABEL_185;
    case 0xCu:
      goto LABEL_160;
    case 0xDu:
      goto LABEL_168;
    case 0xEu:
      goto LABEL_176;
    case 0xFu:
      goto LABEL_184;
    case 0x10u:
      goto LABEL_159;
    case 0x11u:
      goto LABEL_167;
    case 0x12u:
      goto LABEL_175;
    case 0x13u:
      goto LABEL_183;
    case 0x14u:
      goto LABEL_158;
    case 0x15u:
      goto LABEL_166;
    case 0x16u:
      goto LABEL_174;
    case 0x17u:
      goto LABEL_182;
    case 0x18u:
      goto LABEL_157;
    case 0x19u:
      goto LABEL_165;
    case 0x1Au:
      goto LABEL_173;
    case 0x1Bu:
      goto LABEL_181;
    case 0x1Cu:
      *(_DWORD *)(v6 + 24) = v5[6];
LABEL_157:
      *(_DWORD *)(v6 + 20) = v5[5];
LABEL_158:
      *(_DWORD *)(v6 + 16) = v5[4];
LABEL_159:
      *(_DWORD *)(v6 + 12) = v5[3];
LABEL_160:
      *(_DWORD *)(v6 + 8) = v5[2];
LABEL_161:
      *(_DWORD *)(v6 + 4) = v5[1];
LABEL_162:
      *(_DWORD *)v6 = *v5;
LABEL_163:
      result = a2;
      break;
    case 0x1Du:
      *(_DWORD *)(v6 + 25) = *(_DWORD *)((char *)v5 + 25);
LABEL_165:
      *(_DWORD *)(v6 + 21) = *(_DWORD *)((char *)v5 + 21);
LABEL_166:
      *(_DWORD *)(v6 + 17) = *(_DWORD *)((char *)v5 + 17);
LABEL_167:
      *(_DWORD *)(v6 + 13) = *(_DWORD *)((char *)v5 + 13);
LABEL_168:
      *(_DWORD *)(v6 + 9) = *(_DWORD *)((char *)v5 + 9);
LABEL_169:
      *(_DWORD *)(v6 + 5) = *(_DWORD *)((char *)v5 + 5);
LABEL_170:
      *(_DWORD *)(v6 + 1) = *(_DWORD *)((char *)v5 + 1);
LABEL_171:
      *(_BYTE *)v6 = *(_BYTE *)v5;
      result = a2;
      break;
    case 0x1Eu:
      *(_DWORD *)(v6 + 26) = *(_DWORD *)((char *)v5 + 26);
LABEL_173:
      *(_DWORD *)(v6 + 22) = *(_DWORD *)((char *)v5 + 22);
LABEL_174:
      *(_DWORD *)(v6 + 18) = *(_DWORD *)((char *)v5 + 18);
LABEL_175:
      *(_DWORD *)(v6 + 14) = *(_DWORD *)((char *)v5 + 14);
LABEL_176:
      *(_DWORD *)(v6 + 10) = *(_DWORD *)((char *)v5 + 10);
LABEL_177:
      *(_DWORD *)(v6 + 6) = *(_DWORD *)((char *)v5 + 6);
LABEL_178:
      *(_DWORD *)(v6 + 2) = *(_DWORD *)((char *)v5 + 2);
LABEL_179:
      *(_WORD *)v6 = *(_WORD *)v5;
      result = a2;
      break;
    case 0x1Fu:
      *(_DWORD *)(v6 + 27) = *(_DWORD *)((char *)v5 + 27);
LABEL_181:
      *(_DWORD *)(v6 + 23) = *(_DWORD *)((char *)v5 + 23);
LABEL_182:
      *(_DWORD *)(v6 + 19) = *(_DWORD *)((char *)v5 + 19);
LABEL_183:
      *(_DWORD *)(v6 + 15) = *(_DWORD *)((char *)v5 + 15);
LABEL_184:
      *(_DWORD *)(v6 + 11) = *(_DWORD *)((char *)v5 + 11);
LABEL_185:
      *(_DWORD *)(v6 + 7) = *(_DWORD *)((char *)v5 + 7);
LABEL_186:
      *(_DWORD *)(v6 + 3) = *(_DWORD *)((char *)v5 + 3);
LABEL_187:
      *(_WORD *)(v6 + 1) = *(_WORD *)((char *)v5 + 1);
      *(_BYTE *)v6 = *(_BYTE *)v5;
      result = a2;
      break;
    default:
      goto LABEL_191;
  }
  return result;
}
// 80710D3: conditional instruction was optimized away because %arg_8.4>=30u
// 80710BC: variable 'v220' is possibly undefined
// 80EF548: using guessed type int _x86_shared_cache_size_half;
// 80EF558: using guessed type int _x86_data_cache_size_half;

//----- (080711A0) --------------------------------------------------------
int __cdecl _strcmp_ssse3(int a1, int a2)
{
  char v2; // cc
  unsigned __int8 v3; // cl
  unsigned __int8 v4; // cl
  unsigned __int8 v5; // cl
  unsigned __int8 v6; // cl
  unsigned __int8 v7; // cl
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // cl
  int v10; // edx
  int v11; // eax
  __m128i v12; // xmm1
  __m128i v13; // xmm2
  int v14; // ecx
  unsigned int v15; // ecx
  unsigned int v16; // edi
  const __m128i *v17; // eax
  const __m128i *v18; // edx
  char v19; // bl
  const __m128i *v20; // et0
  unsigned int v21; // et1
  int v22; // edi
  bool v23; // zf
  __m128i si128; // xmm1
  unsigned int v25; // edi
  int v26; // esi
  int v27; // edi
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  __m128i v30; // xmm1
  unsigned int v31; // edi
  __m128i v32; // xmm3
  __m128i v33; // xmm0
  int v34; // edi
  __m128i v35; // xmm1
  __m128i v36; // xmm4
  __m128i v37; // xmm1
  __m128i v38; // xmm4
  __m128i v39; // xmm0
  __m128i v40; // xmm1
  __m128i v41; // xmm0
  __m128i v42; // xmm3
  __m128i v43; // xmm1
  unsigned int v44; // edi
  __m128i v45; // xmm3
  __m128i v46; // xmm0
  int v47; // edi
  __m128i v48; // xmm1
  __m128i v49; // xmm4
  __m128i v50; // xmm1
  __m128i v51; // xmm4
  __m128i v52; // xmm0
  __m128i v53; // xmm1
  unsigned int v54; // edi
  __m128i v55; // xmm3
  __m128i v56; // xmm0
  int v57; // edi
  __m128i v58; // xmm1
  __m128i v59; // xmm4
  __m128i v60; // xmm1
  __m128i v61; // xmm4
  __m128i v62; // xmm0
  __m128i v63; // xmm1
  unsigned int v64; // edi
  __m128i v65; // xmm3
  __m128i v66; // xmm0
  int v67; // edi
  __m128i v68; // xmm1
  __m128i v69; // xmm4
  __m128i v70; // xmm1
  __m128i v71; // xmm4
  __m128i v72; // xmm0
  __m128i v73; // xmm1
  unsigned int v74; // edi
  __m128i v75; // xmm3
  __m128i v76; // xmm0
  int v77; // edi
  __m128i v78; // xmm1
  __m128i v79; // xmm4
  __m128i v80; // xmm1
  __m128i v81; // xmm4
  __m128i v82; // xmm0
  __m128i v83; // xmm1
  unsigned int v84; // edi
  __m128i v85; // xmm3
  __m128i v86; // xmm0
  int v87; // edi
  __m128i v88; // xmm1
  __m128i v89; // xmm4
  __m128i v90; // xmm1
  __m128i v91; // xmm4
  __m128i v92; // xmm0
  __m128i v93; // xmm1
  unsigned int v94; // edi
  __m128i v95; // xmm3
  __m128i v96; // xmm0
  int v97; // edi
  __m128i v98; // xmm1
  __m128i v99; // xmm4
  __m128i v100; // xmm1
  __m128i v101; // xmm4
  __m128i v102; // xmm0
  __m128i v103; // xmm1
  unsigned int v104; // edi
  __m128i v105; // xmm3
  __m128i v106; // xmm0
  int v107; // edi
  __m128i v108; // xmm1
  __m128i v109; // xmm4
  __m128i v110; // xmm1
  __m128i v111; // xmm4
  __m128i v112; // xmm0
  __m128i v113; // xmm1
  unsigned int v114; // edi
  __m128i v115; // xmm3
  __m128i v116; // xmm0
  int v117; // edi
  __m128i v118; // xmm1
  __m128i v119; // xmm4
  __m128i v120; // xmm1
  __m128i v121; // xmm4
  __m128i v122; // xmm0
  __m128i v123; // xmm1
  unsigned int v124; // edi
  __m128i v125; // xmm3
  __m128i v126; // xmm0
  int v127; // edi
  __m128i v128; // xmm1
  __m128i v129; // xmm4
  __m128i v130; // xmm1
  __m128i v131; // xmm4
  __m128i v132; // xmm0
  __m128i v133; // xmm1
  unsigned int v134; // edi
  __m128i v135; // xmm3
  __m128i v136; // xmm0
  int v137; // edi
  __m128i v138; // xmm1
  __m128i v139; // xmm4
  __m128i v140; // xmm1
  __m128i v141; // xmm4
  __m128i v142; // xmm0
  __m128i v143; // xmm1
  unsigned int v144; // edi
  __m128i v145; // xmm3
  __m128i v146; // xmm0
  int v147; // edi
  __m128i v148; // xmm1
  __m128i v149; // xmm4
  __m128i v150; // xmm1
  __m128i v151; // xmm4
  __m128i v152; // xmm0
  __m128i v153; // xmm1
  unsigned int v154; // edi
  __m128i v155; // xmm3
  __m128i v156; // xmm0
  int v157; // edi
  __m128i v158; // xmm1
  __m128i v159; // xmm4
  __m128i v160; // xmm1
  __m128i v161; // xmm4
  __m128i v162; // xmm0
  __m128i v163; // xmm1
  unsigned int v164; // edi
  __m128i v165; // xmm3
  __m128i v166; // xmm0
  int v167; // edi
  __m128i v168; // xmm1
  __m128i v169; // xmm4
  __m128i v170; // xmm1
  __m128i v171; // xmm4
  __m128i v172; // xmm0
  __m128i v173; // xmm1
  unsigned int v174; // edi
  __m128i v175; // xmm3
  __m128i v176; // xmm0
  int v177; // edi
  __m128i v178; // xmm1
  __m128i v179; // xmm4
  __m128i v180; // xmm1
  __m128i v181; // xmm4
  __m128i v182; // xmm0
  int v183; // et2
  int result; // eax

  v2 = *(_BYTE *)a1 <= *(_BYTE *)a2;
  if ( *(_BYTE *)a1 != *(_BYTE *)a2 )
    goto LABEL_223;
  if ( !*(_BYTE *)a2 )
    return 0;
  v3 = *(_BYTE *)(a2 + 1);
  v2 = *(_BYTE *)(a1 + 1) <= v3;
  if ( *(_BYTE *)(a1 + 1) != v3 )
    goto LABEL_223;
  if ( !*(_BYTE *)(a2 + 1) )
    return 0;
  v4 = *(_BYTE *)(a2 + 2);
  v2 = *(_BYTE *)(a1 + 2) <= v4;
  if ( *(_BYTE *)(a1 + 2) != v4 )
    goto LABEL_223;
  if ( !*(_BYTE *)(a2 + 2) )
    return 0;
  v5 = *(_BYTE *)(a2 + 3);
  v2 = *(_BYTE *)(a1 + 3) <= v5;
  if ( *(_BYTE *)(a1 + 3) != v5 )
    goto LABEL_223;
  if ( !*(_BYTE *)(a2 + 3) )
    return 0;
  v6 = *(_BYTE *)(a2 + 4);
  v2 = *(_BYTE *)(a1 + 4) <= v6;
  if ( *(_BYTE *)(a1 + 4) != v6 )
    goto LABEL_223;
  if ( !*(_BYTE *)(a2 + 4) )
    return 0;
  v7 = *(_BYTE *)(a2 + 5);
  v2 = *(_BYTE *)(a1 + 5) <= v7;
  if ( *(_BYTE *)(a1 + 5) != v7 )
    goto LABEL_223;
  if ( !*(_BYTE *)(a2 + 5) )
    return 0;
  v8 = *(_BYTE *)(a2 + 6);
  v2 = *(_BYTE *)(a1 + 6) <= v8;
  if ( *(_BYTE *)(a1 + 6) != v8 )
    goto LABEL_223;
  if ( !*(_BYTE *)(a2 + 6) )
    return 0;
  v9 = *(_BYTE *)(a2 + 7);
  v2 = *(_BYTE *)(a1 + 7) <= v9;
  if ( *(_BYTE *)(a1 + 7) != v9 )
  {
LABEL_223:
    result = 1;
    if ( v2 )
      return -1;
    return result;
  }
  if ( !*(_BYTE *)(a2 + 7) )
    return 0;
  v10 = a1 + 8;
  v11 = a2 + 8;
  if ( (((_WORD)a1 + 8) & 0xFFFu) <= 0xFF0 && (v11 & 0xFFFu) <= 0xFF0 )
  {
    v12.m128i_i64[0] = *(__int64 *)v11;
    v13.m128i_i64[0] = *(__int64 *)v10;
    v12.m128i_i64[1] = *(__int64 *)(a2 + 16);
    v13.m128i_i64[1] = *(__int64 *)(a1 + 16);
    v14 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v12, v13), _mm_cmpeq_epi8((__m128i)0LL, v12))) - 0xFFFF;
    if ( v14 )
      goto LABEL_199;
    v11 = a2 + 24;
    v10 = a1 + 24;
  }
  v15 = v11 & 0xF;
  v16 = v10 & 0xF;
  v17 = (const __m128i *)(v15 ^ v11);
  v18 = (const __m128i *)(v16 ^ v10);
  v19 = 0;
  if ( v15 == v16 )
  {
LABEL_40:
    si128 = _mm_load_si128(v17);
    v25 = (unsigned int)_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(si128, *v18), _mm_cmpeq_epi8((__m128i)0LL, si128))) >> v15;
    v26 = (0xFFFFu >> v15) - v25;
    v23 = 0xFFFFu >> v15 == v25;
    v27 = v15;
    if ( v23 )
    {
      v19 = 16;
      v15 = 16;
      v28 = 0LL;
      while ( 1 )
      {
        v29 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
        v28 = _mm_cmpeq_epi8(v28, v29);
        v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v29, *(const __m128i *)((char *)v18 + v15)), v28)) - 0xFFFF;
        if ( v26 )
          break;
        v15 += 16;
      }
      goto LABEL_195;
    }
    goto LABEL_196;
  }
  if ( v15 <= v16 )
  {
    v19 = 32;
    v20 = v17;
    v17 = v18;
    v18 = v20;
    v21 = v15;
    v15 = v16;
    v16 = v21;
  }
  v22 = v16 + 15 - v15;
  v23 = v22 == 8;
  if ( v22 <= 8 )
    goto LABEL_31;
  if ( v22 != 14 )
  {
    if ( v22 != 13 )
    {
      if ( v22 != 12 )
      {
        if ( v22 != 11 )
        {
          if ( v22 != 10 )
          {
            v23 = v22 == 9;
            if ( v22 != 9 )
            {
LABEL_31:
              if ( !v23 )
              {
                if ( v22 != 7 )
                {
                  if ( v22 != 6 )
                  {
                    if ( v22 != 5 )
                    {
                      if ( v22 != 4 )
                      {
                        if ( v22 != 3 )
                        {
                          if ( v22 != 2 )
                          {
                            if ( v22 != 1 )
                            {
                              if ( v22 )
                                goto LABEL_40;
                              v30 = _mm_load_si128(v17);
                              v31 = (unsigned int)_mm_movemask_epi8(
                                                    _mm_sub_epi8(
                                                      _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 15), v30),
                                                      _mm_cmpeq_epi8((__m128i)0LL, v30))) >> v15;
                              v26 = (0xFFFFu >> v15) - v31;
                              v23 = 0xFFFFu >> v15 == v31;
                              v27 = v15 - 15;
                              if ( !v23 )
                                goto LABEL_196;
                              v32 = _mm_load_si128(v18);
                              v33 = 0LL;
                              v15 = 16;
                              v19 |= 1u;
                              v34 = (((_WORD)v18 + 1) & 0xFFF) - 4096;
                              while ( 1 )
                              {
                                v2 = (v34 + 16 < 0) ^ __OFADD__(16, v34) | (v34 == -16);
                                v34 += 16;
                                if ( !v2 )
                                  goto LABEL_51;
                                while ( 1 )
                                {
                                  v35 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                                  v36 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                                  v33 = _mm_cmpeq_epi8(v33, v35);
                                  v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v35, _mm_alignr_epi8(v36, v32, 1)), v33))
                                      - 0xFFFF;
                                  if ( v26 )
                                    goto LABEL_195;
                                  v15 += 16;
                                  v32 = v36;
                                  v2 = (v34 + 16 < 0) ^ __OFADD__(16, v34) | (v34 == -16);
                                  v34 += 16;
                                  if ( v2 )
                                    break;
LABEL_51:
                                  v39 = _mm_cmpeq_epi8(v33, v32);
                                  if ( (_mm_movemask_epi8(v39) & 0xFFFE) != 0 )
                                  {
                                    v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                                    v41 = _mm_srli_si128(v39, 1);
                                    v42 = _mm_srli_si128(v32, 1);
                                    goto LABEL_194;
                                  }
                                  v33 = 0LL;
                                  v34 -= 4096;
                                }
                                v37 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                                v38 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                                v33 = _mm_cmpeq_epi8(v33, v37);
                                v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v37, _mm_alignr_epi8(v38, v32, 1)), v33))
                                    - 0xFFFF;
                                if ( v26 )
                                  goto LABEL_195;
                                v15 += 16;
                                v32 = v38;
                              }
                            }
                            v43 = _mm_load_si128(v17);
                            v44 = (unsigned int)_mm_movemask_epi8(
                                                  _mm_sub_epi8(
                                                    _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 14), v43),
                                                    _mm_cmpeq_epi8((__m128i)0LL, v43))) >> v15;
                            v26 = (0xFFFFu >> v15) - v44;
                            v23 = 0xFFFFu >> v15 == v44;
                            v27 = v15 - 14;
                            if ( !v23 )
                              goto LABEL_196;
                            v45 = _mm_load_si128(v18);
                            v46 = 0LL;
                            v15 = 16;
                            v19 |= 2u;
                            v47 = (((_WORD)v18 + 2) & 0xFFF) - 4096;
                            while ( 1 )
                            {
                              v2 = (v47 + 16 < 0) ^ __OFADD__(16, v47) | (v47 == -16);
                              v47 += 16;
                              if ( !v2 )
                                goto LABEL_61;
                              while ( 1 )
                              {
                                v48 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                                v49 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                                v46 = _mm_cmpeq_epi8(v46, v48);
                                v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v48, _mm_alignr_epi8(v49, v45, 2)), v46))
                                    - 0xFFFF;
                                if ( v26 )
                                  goto LABEL_195;
                                v15 += 16;
                                v45 = v49;
                                v2 = (v47 + 16 < 0) ^ __OFADD__(16, v47) | (v47 == -16);
                                v47 += 16;
                                if ( v2 )
                                  break;
LABEL_61:
                                v52 = _mm_cmpeq_epi8(v46, v45);
                                if ( (_mm_movemask_epi8(v52) & 0xFFFC) != 0 )
                                {
                                  v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                                  v41 = _mm_srli_si128(v52, 2);
                                  v42 = _mm_srli_si128(v45, 2);
                                  goto LABEL_194;
                                }
                                v46 = 0LL;
                                v47 -= 4096;
                              }
                              v50 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                              v51 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                              v46 = _mm_cmpeq_epi8(v46, v50);
                              v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v50, _mm_alignr_epi8(v51, v45, 2)), v46))
                                  - 0xFFFF;
                              if ( v26 )
                                goto LABEL_195;
                              v15 += 16;
                              v45 = v51;
                            }
                          }
                          v53 = _mm_load_si128(v17);
                          v54 = (unsigned int)_mm_movemask_epi8(
                                                _mm_sub_epi8(
                                                  _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 13), v53),
                                                  _mm_cmpeq_epi8((__m128i)0LL, v53))) >> v15;
                          v26 = (0xFFFFu >> v15) - v54;
                          v23 = 0xFFFFu >> v15 == v54;
                          v27 = v15 - 13;
                          if ( !v23 )
                            goto LABEL_196;
                          v55 = _mm_load_si128(v18);
                          v56 = 0LL;
                          v15 = 16;
                          v19 |= 3u;
                          v57 = (((_WORD)v18 + 3) & 0xFFF) - 4096;
                          while ( 1 )
                          {
                            v2 = (v57 + 16 < 0) ^ __OFADD__(16, v57) | (v57 == -16);
                            v57 += 16;
                            if ( !v2 )
                              goto LABEL_71;
                            while ( 1 )
                            {
                              v58 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                              v59 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                              v56 = _mm_cmpeq_epi8(v56, v58);
                              v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v58, _mm_alignr_epi8(v59, v55, 3)), v56))
                                  - 0xFFFF;
                              if ( v26 )
                                goto LABEL_195;
                              v15 += 16;
                              v55 = v59;
                              v2 = (v57 + 16 < 0) ^ __OFADD__(16, v57) | (v57 == -16);
                              v57 += 16;
                              if ( v2 )
                                break;
LABEL_71:
                              v62 = _mm_cmpeq_epi8(v56, v55);
                              if ( (_mm_movemask_epi8(v62) & 0xFFF8) != 0 )
                              {
                                v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                                v41 = _mm_srli_si128(v62, 3);
                                v42 = _mm_srli_si128(v55, 3);
                                goto LABEL_194;
                              }
                              v56 = 0LL;
                              v57 -= 4096;
                            }
                            v60 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                            v61 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                            v56 = _mm_cmpeq_epi8(v56, v60);
                            v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v60, _mm_alignr_epi8(v61, v55, 3)), v56))
                                - 0xFFFF;
                            if ( v26 )
                              goto LABEL_195;
                            v15 += 16;
                            v55 = v61;
                          }
                        }
                        v63 = _mm_load_si128(v17);
                        v64 = (unsigned int)_mm_movemask_epi8(
                                              _mm_sub_epi8(
                                                _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 12), v63),
                                                _mm_cmpeq_epi8((__m128i)0LL, v63))) >> v15;
                        v26 = (0xFFFFu >> v15) - v64;
                        v23 = 0xFFFFu >> v15 == v64;
                        v27 = v15 - 12;
                        if ( !v23 )
                          goto LABEL_196;
                        v65 = _mm_load_si128(v18);
                        v66 = 0LL;
                        v15 = 16;
                        v19 |= 4u;
                        v67 = (((_WORD)v18 + 4) & 0xFFF) - 4096;
                        while ( 1 )
                        {
                          v2 = (v67 + 16 < 0) ^ __OFADD__(16, v67) | (v67 == -16);
                          v67 += 16;
                          if ( !v2 )
                            goto LABEL_81;
                          while ( 1 )
                          {
                            v68 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                            v69 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                            v66 = _mm_cmpeq_epi8(v66, v68);
                            v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v68, _mm_alignr_epi8(v69, v65, 4)), v66))
                                - 0xFFFF;
                            if ( v26 )
                              goto LABEL_195;
                            v15 += 16;
                            v65 = v69;
                            v2 = (v67 + 16 < 0) ^ __OFADD__(16, v67) | (v67 == -16);
                            v67 += 16;
                            if ( v2 )
                              break;
LABEL_81:
                            v72 = _mm_cmpeq_epi8(v66, v65);
                            if ( (_mm_movemask_epi8(v72) & 0xFFF0) != 0 )
                            {
                              v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                              v41 = _mm_srli_si128(v72, 4);
                              v42 = _mm_srli_si128(v65, 4);
                              goto LABEL_194;
                            }
                            v66 = 0LL;
                            v67 -= 4096;
                          }
                          v70 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                          v71 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                          v66 = _mm_cmpeq_epi8(v66, v70);
                          v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v70, _mm_alignr_epi8(v71, v65, 4)), v66))
                              - 0xFFFF;
                          if ( v26 )
                            goto LABEL_195;
                          v15 += 16;
                          v65 = v71;
                        }
                      }
                      v73 = _mm_load_si128(v17);
                      v74 = (unsigned int)_mm_movemask_epi8(
                                            _mm_sub_epi8(
                                              _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 11), v73),
                                              _mm_cmpeq_epi8((__m128i)0LL, v73))) >> v15;
                      v26 = (0xFFFFu >> v15) - v74;
                      v23 = 0xFFFFu >> v15 == v74;
                      v27 = v15 - 11;
                      if ( !v23 )
                        goto LABEL_196;
                      v75 = _mm_load_si128(v18);
                      v76 = 0LL;
                      v15 = 16;
                      v19 |= 5u;
                      v77 = (((_WORD)v18 + 5) & 0xFFF) - 4096;
                      while ( 1 )
                      {
                        v2 = (v77 + 16 < 0) ^ __OFADD__(16, v77) | (v77 == -16);
                        v77 += 16;
                        if ( !v2 )
                          goto LABEL_91;
                        while ( 1 )
                        {
                          v78 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                          v79 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                          v76 = _mm_cmpeq_epi8(v76, v78);
                          v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v78, _mm_alignr_epi8(v79, v75, 5)), v76))
                              - 0xFFFF;
                          if ( v26 )
                            goto LABEL_195;
                          v15 += 16;
                          v75 = v79;
                          v2 = (v77 + 16 < 0) ^ __OFADD__(16, v77) | (v77 == -16);
                          v77 += 16;
                          if ( v2 )
                            break;
LABEL_91:
                          v82 = _mm_cmpeq_epi8(v76, v75);
                          if ( (_mm_movemask_epi8(v82) & 0xFFE0) != 0 )
                          {
                            v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                            v41 = _mm_srli_si128(v82, 5);
                            v42 = _mm_srli_si128(v75, 5);
                            goto LABEL_194;
                          }
                          v76 = 0LL;
                          v77 -= 4096;
                        }
                        v80 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                        v81 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                        v76 = _mm_cmpeq_epi8(v76, v80);
                        v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v80, _mm_alignr_epi8(v81, v75, 5)), v76))
                            - 0xFFFF;
                        if ( v26 )
                          goto LABEL_195;
                        v15 += 16;
                        v75 = v81;
                      }
                    }
                    v83 = _mm_load_si128(v17);
                    v84 = (unsigned int)_mm_movemask_epi8(
                                          _mm_sub_epi8(
                                            _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 10), v83),
                                            _mm_cmpeq_epi8((__m128i)0LL, v83))) >> v15;
                    v26 = (0xFFFFu >> v15) - v84;
                    v23 = 0xFFFFu >> v15 == v84;
                    v27 = v15 - 10;
                    if ( !v23 )
                      goto LABEL_196;
                    v85 = _mm_load_si128(v18);
                    v86 = 0LL;
                    v15 = 16;
                    v19 |= 6u;
                    v87 = (((_WORD)v18 + 6) & 0xFFF) - 4096;
                    while ( 1 )
                    {
                      v2 = (v87 + 16 < 0) ^ __OFADD__(16, v87) | (v87 == -16);
                      v87 += 16;
                      if ( !v2 )
                        goto LABEL_101;
                      while ( 1 )
                      {
                        v88 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                        v89 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                        v86 = _mm_cmpeq_epi8(v86, v88);
                        v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v88, _mm_alignr_epi8(v89, v85, 6)), v86))
                            - 0xFFFF;
                        if ( v26 )
                          goto LABEL_195;
                        v15 += 16;
                        v85 = v89;
                        v2 = (v87 + 16 < 0) ^ __OFADD__(16, v87) | (v87 == -16);
                        v87 += 16;
                        if ( v2 )
                          break;
LABEL_101:
                        v92 = _mm_cmpeq_epi8(v86, v85);
                        if ( (_mm_movemask_epi8(v92) & 0xFFC0) != 0 )
                        {
                          v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                          v41 = _mm_srli_si128(v92, 6);
                          v42 = _mm_srli_si128(v85, 6);
                          goto LABEL_194;
                        }
                        v86 = 0LL;
                        v87 -= 4096;
                      }
                      v90 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                      v91 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                      v86 = _mm_cmpeq_epi8(v86, v90);
                      v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v90, _mm_alignr_epi8(v91, v85, 6)), v86))
                          - 0xFFFF;
                      if ( v26 )
                        goto LABEL_195;
                      v15 += 16;
                      v85 = v91;
                    }
                  }
                  v93 = _mm_load_si128(v17);
                  v94 = (unsigned int)_mm_movemask_epi8(
                                        _mm_sub_epi8(
                                          _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 9), v93),
                                          _mm_cmpeq_epi8((__m128i)0LL, v93))) >> v15;
                  v26 = (0xFFFFu >> v15) - v94;
                  v23 = 0xFFFFu >> v15 == v94;
                  v27 = v15 - 9;
                  if ( !v23 )
                    goto LABEL_196;
                  v95 = _mm_load_si128(v18);
                  v96 = 0LL;
                  v15 = 16;
                  v19 |= 7u;
                  v97 = (((_WORD)v18 + 8) & 0xFFF) - 4096;
                  while ( 1 )
                  {
                    v2 = (v97 + 16 < 0) ^ __OFADD__(16, v97) | (v97 == -16);
                    v97 += 16;
                    if ( !v2 )
                      goto LABEL_111;
                    while ( 1 )
                    {
                      v98 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                      v99 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                      v96 = _mm_cmpeq_epi8(v96, v98);
                      v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v98, _mm_alignr_epi8(v99, v95, 7)), v96))
                          - 0xFFFF;
                      if ( v26 )
                        goto LABEL_195;
                      v15 += 16;
                      v95 = v99;
                      v2 = (v97 + 16 < 0) ^ __OFADD__(16, v97) | (v97 == -16);
                      v97 += 16;
                      if ( v2 )
                        break;
LABEL_111:
                      v102 = _mm_cmpeq_epi8(v96, v95);
                      if ( (_mm_movemask_epi8(v102) & 0xFF80) != 0 )
                      {
                        v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                        v41 = _mm_srli_si128(v102, 7);
                        v42 = _mm_srli_si128(v95, 7);
                        goto LABEL_194;
                      }
                      v96 = 0LL;
                      v97 -= 4096;
                    }
                    v100 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                    v101 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                    v96 = _mm_cmpeq_epi8(v96, v100);
                    v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v100, _mm_alignr_epi8(v101, v95, 7)), v96))
                        - 0xFFFF;
                    if ( v26 )
                      goto LABEL_195;
                    v15 += 16;
                    v95 = v101;
                  }
                }
                v103 = _mm_load_si128(v17);
                v104 = (unsigned int)_mm_movemask_epi8(
                                       _mm_sub_epi8(
                                         _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 8), v103),
                                         _mm_cmpeq_epi8((__m128i)0LL, v103))) >> v15;
                v26 = (0xFFFFu >> v15) - v104;
                v23 = 0xFFFFu >> v15 == v104;
                v27 = v15 - 8;
                if ( !v23 )
                  goto LABEL_196;
                v105 = _mm_load_si128(v18);
                v106 = 0LL;
                v15 = 16;
                v19 |= 8u;
                v107 = (((_WORD)v18 + 8) & 0xFFF) - 4096;
                while ( 1 )
                {
                  v2 = (v107 + 16 < 0) ^ __OFADD__(16, v107) | (v107 == -16);
                  v107 += 16;
                  if ( !v2 )
                    goto LABEL_121;
                  while ( 1 )
                  {
                    v108 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                    v109 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                    v106 = _mm_cmpeq_epi8(v106, v108);
                    v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v108, _mm_alignr_epi8(v109, v105, 8)), v106))
                        - 0xFFFF;
                    if ( v26 )
                      goto LABEL_195;
                    v15 += 16;
                    v105 = v109;
                    v2 = (v107 + 16 < 0) ^ __OFADD__(16, v107) | (v107 == -16);
                    v107 += 16;
                    if ( v2 )
                      break;
LABEL_121:
                    v112 = _mm_cmpeq_epi8(v106, v105);
                    if ( (_mm_movemask_epi8(v112) & 0xFF00) != 0 )
                    {
                      v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                      v41 = _mm_srli_si128(v112, 8);
                      v42 = _mm_srli_si128(v105, 8);
                      goto LABEL_194;
                    }
                    v106 = 0LL;
                    v107 -= 4096;
                  }
                  v110 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                  v111 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                  v106 = _mm_cmpeq_epi8(v106, v110);
                  v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v110, _mm_alignr_epi8(v111, v105, 8)), v106))
                      - 0xFFFF;
                  if ( v26 )
                    goto LABEL_195;
                  v15 += 16;
                  v105 = v111;
                }
              }
              v113 = _mm_load_si128(v17);
              v114 = (unsigned int)_mm_movemask_epi8(
                                     _mm_sub_epi8(
                                       _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 7), v113),
                                       _mm_cmpeq_epi8((__m128i)0LL, v113))) >> v15;
              v26 = (0xFFFFu >> v15) - v114;
              v23 = 0xFFFFu >> v15 == v114;
              v27 = v15 - 7;
              if ( !v23 )
                goto LABEL_196;
              v115 = _mm_load_si128(v18);
              v116 = 0LL;
              v15 = 16;
              v19 |= 9u;
              v117 = (((_WORD)v18 + 9) & 0xFFF) - 4096;
              while ( 1 )
              {
                v2 = (v117 + 16 < 0) ^ __OFADD__(16, v117) | (v117 == -16);
                v117 += 16;
                if ( !v2 )
                  goto LABEL_131;
                while ( 1 )
                {
                  v118 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                  v119 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                  v116 = _mm_cmpeq_epi8(v116, v118);
                  v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v118, _mm_alignr_epi8(v119, v115, 9)), v116))
                      - 0xFFFF;
                  if ( v26 )
                    goto LABEL_195;
                  v15 += 16;
                  v115 = v119;
                  v2 = (v117 + 16 < 0) ^ __OFADD__(16, v117) | (v117 == -16);
                  v117 += 16;
                  if ( v2 )
                    break;
LABEL_131:
                  v122 = _mm_cmpeq_epi8(v116, v115);
                  if ( (_mm_movemask_epi8(v122) & 0xFE00) != 0 )
                  {
                    v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                    v41 = _mm_srli_si128(v122, 9);
                    v42 = _mm_srli_si128(v115, 9);
                    goto LABEL_194;
                  }
                  v116 = 0LL;
                  v117 -= 4096;
                }
                v120 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                v121 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                v116 = _mm_cmpeq_epi8(v116, v120);
                v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v120, _mm_alignr_epi8(v121, v115, 9)), v116))
                    - 0xFFFF;
                if ( v26 )
                  goto LABEL_195;
                v15 += 16;
                v115 = v121;
              }
            }
            v123 = _mm_load_si128(v17);
            v124 = (unsigned int)_mm_movemask_epi8(
                                   _mm_sub_epi8(
                                     _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 6), v123),
                                     _mm_cmpeq_epi8((__m128i)0LL, v123))) >> v15;
            v26 = (0xFFFFu >> v15) - v124;
            v23 = 0xFFFFu >> v15 == v124;
            v27 = v15 - 6;
            if ( !v23 )
              goto LABEL_196;
            v125 = _mm_load_si128(v18);
            v126 = 0LL;
            v15 = 16;
            v19 |= 0xAu;
            v127 = (((_WORD)v18 + 10) & 0xFFF) - 4096;
            while ( 1 )
            {
              v2 = (v127 + 16 < 0) ^ __OFADD__(16, v127) | (v127 == -16);
              v127 += 16;
              if ( !v2 )
                goto LABEL_141;
              while ( 1 )
              {
                v128 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                v129 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
                v126 = _mm_cmpeq_epi8(v126, v128);
                v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v128, _mm_alignr_epi8(v129, v125, 10)), v126))
                    - 0xFFFF;
                if ( v26 )
                  goto LABEL_195;
                v15 += 16;
                v125 = v129;
                v2 = (v127 + 16 < 0) ^ __OFADD__(16, v127) | (v127 == -16);
                v127 += 16;
                if ( v2 )
                  break;
LABEL_141:
                v132 = _mm_cmpeq_epi8(v126, v125);
                if ( (_mm_movemask_epi8(v132) & 0xFC00) != 0 )
                {
                  v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                  v41 = _mm_srli_si128(v132, 10);
                  v42 = _mm_srli_si128(v125, 10);
                  goto LABEL_194;
                }
                v126 = 0LL;
                v127 -= 4096;
              }
              v130 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
              v131 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
              v126 = _mm_cmpeq_epi8(v126, v130);
              v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v130, _mm_alignr_epi8(v131, v125, 10)), v126))
                  - 0xFFFF;
              if ( v26 )
                goto LABEL_195;
              v15 += 16;
              v125 = v131;
            }
          }
          v133 = _mm_load_si128(v17);
          v134 = (unsigned int)_mm_movemask_epi8(
                                 _mm_sub_epi8(
                                   _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 5), v133),
                                   _mm_cmpeq_epi8((__m128i)0LL, v133))) >> v15;
          v26 = (0xFFFFu >> v15) - v134;
          v23 = 0xFFFFu >> v15 == v134;
          v27 = v15 - 5;
          if ( !v23 )
            goto LABEL_196;
          v135 = _mm_load_si128(v18);
          v136 = 0LL;
          v15 = 16;
          v19 |= 0xBu;
          v137 = (((_WORD)v18 + 11) & 0xFFF) - 4096;
          while ( 1 )
          {
            v2 = (v137 + 16 < 0) ^ __OFADD__(16, v137) | (v137 == -16);
            v137 += 16;
            if ( !v2 )
              goto LABEL_151;
            while ( 1 )
            {
              v138 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
              v139 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
              v136 = _mm_cmpeq_epi8(v136, v138);
              v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v138, _mm_alignr_epi8(v139, v135, 11)), v136))
                  - 0xFFFF;
              if ( v26 )
                goto LABEL_195;
              v15 += 16;
              v135 = v139;
              v2 = (v137 + 16 < 0) ^ __OFADD__(16, v137) | (v137 == -16);
              v137 += 16;
              if ( v2 )
                break;
LABEL_151:
              v142 = _mm_cmpeq_epi8(v136, v135);
              if ( (_mm_movemask_epi8(v142) & 0xF800) != 0 )
              {
                v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
                v41 = _mm_srli_si128(v142, 11);
                v42 = _mm_srli_si128(v135, 11);
                goto LABEL_194;
              }
              v136 = 0LL;
              v137 -= 4096;
            }
            v140 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
            v141 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
            v136 = _mm_cmpeq_epi8(v136, v140);
            v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v140, _mm_alignr_epi8(v141, v135, 11)), v136)) - 0xFFFF;
            if ( v26 )
              goto LABEL_195;
            v15 += 16;
            v135 = v141;
          }
        }
        v143 = _mm_load_si128(v17);
        v144 = (unsigned int)_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 4), v143),
                                 _mm_cmpeq_epi8((__m128i)0LL, v143))) >> v15;
        v26 = (0xFFFFu >> v15) - v144;
        v23 = 0xFFFFu >> v15 == v144;
        v27 = v15 - 4;
        if ( !v23 )
          goto LABEL_196;
        v145 = _mm_load_si128(v18);
        v146 = 0LL;
        v15 = 16;
        v19 |= 0xCu;
        v147 = (((_WORD)v18 + 12) & 0xFFF) - 4096;
        while ( 1 )
        {
          v2 = (v147 + 16 < 0) ^ __OFADD__(16, v147) | (v147 == -16);
          v147 += 16;
          if ( !v2 )
            goto LABEL_161;
          while ( 1 )
          {
            v148 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
            v149 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
            v146 = _mm_cmpeq_epi8(v146, v148);
            v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v148, _mm_alignr_epi8(v149, v145, 12)), v146)) - 0xFFFF;
            if ( v26 )
              goto LABEL_195;
            v15 += 16;
            v145 = v149;
            v2 = (v147 + 16 < 0) ^ __OFADD__(16, v147) | (v147 == -16);
            v147 += 16;
            if ( v2 )
              break;
LABEL_161:
            v152 = _mm_cmpeq_epi8(v146, v145);
            if ( (_mm_movemask_epi8(v152) & 0xF000) != 0 )
            {
              v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
              v41 = _mm_srli_si128(v152, 12);
              v42 = _mm_srli_si128(v145, 12);
              goto LABEL_194;
            }
            v146 = 0LL;
            v147 -= 4096;
          }
          v150 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
          v151 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
          v146 = _mm_cmpeq_epi8(v146, v150);
          v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v150, _mm_alignr_epi8(v151, v145, 12)), v146)) - 0xFFFF;
          if ( v26 )
            goto LABEL_195;
          v15 += 16;
          v145 = v151;
        }
      }
      v153 = _mm_load_si128(v17);
      v154 = (unsigned int)_mm_movemask_epi8(
                             _mm_sub_epi8(
                               _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 3), v153),
                               _mm_cmpeq_epi8((__m128i)0LL, v153))) >> v15;
      v26 = (0xFFFFu >> v15) - v154;
      v23 = 0xFFFFu >> v15 == v154;
      v27 = v15 - 3;
      if ( !v23 )
        goto LABEL_196;
      v155 = _mm_load_si128(v18);
      v156 = 0LL;
      v15 = 16;
      v19 |= 0xDu;
      v157 = (((_WORD)v18 + 13) & 0xFFF) - 4096;
      while ( 1 )
      {
        v2 = (v157 + 16 < 0) ^ __OFADD__(16, v157) | (v157 == -16);
        v157 += 16;
        if ( !v2 )
          goto LABEL_171;
        while ( 1 )
        {
          v158 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
          v159 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
          v156 = _mm_cmpeq_epi8(v156, v158);
          v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v158, _mm_alignr_epi8(v159, v155, 13)), v156)) - 0xFFFF;
          if ( v26 )
            goto LABEL_195;
          v15 += 16;
          v155 = v159;
          v2 = (v157 + 16 < 0) ^ __OFADD__(16, v157) | (v157 == -16);
          v157 += 16;
          if ( v2 )
            break;
LABEL_171:
          v162 = _mm_cmpeq_epi8(v156, v155);
          if ( (_mm_movemask_epi8(v162) & 0xE000) != 0 )
          {
            v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
            v41 = _mm_srli_si128(v162, 13);
            v42 = _mm_srli_si128(v155, 13);
            goto LABEL_194;
          }
          v156 = 0LL;
          v157 -= 4096;
        }
        v160 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
        v161 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
        v156 = _mm_cmpeq_epi8(v156, v160);
        v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v160, _mm_alignr_epi8(v161, v155, 13)), v156)) - 0xFFFF;
        if ( v26 )
          goto LABEL_195;
        v15 += 16;
        v155 = v161;
      }
    }
    v163 = _mm_load_si128(v17);
    v164 = (unsigned int)_mm_movemask_epi8(
                           _mm_sub_epi8(
                             _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 2), v163),
                             _mm_cmpeq_epi8((__m128i)0LL, v163))) >> v15;
    v26 = (0xFFFFu >> v15) - v164;
    v23 = 0xFFFFu >> v15 == v164;
    v27 = v15 - 2;
    if ( !v23 )
      goto LABEL_196;
    v165 = _mm_load_si128(v18);
    v166 = 0LL;
    v15 = 16;
    v19 |= 0xEu;
    v167 = (((_WORD)v18 + 14) & 0xFFF) - 4096;
    while ( 1 )
    {
      v2 = (v167 + 16 < 0) ^ __OFADD__(16, v167) | (v167 == -16);
      v167 += 16;
      if ( !v2 )
        goto LABEL_181;
      while ( 1 )
      {
        v168 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
        v169 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
        v166 = _mm_cmpeq_epi8(v166, v168);
        v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v168, _mm_alignr_epi8(v169, v165, 14)), v166)) - 0xFFFF;
        if ( v26 )
          goto LABEL_195;
        v15 += 16;
        v165 = v169;
        v2 = (v167 + 16 < 0) ^ __OFADD__(16, v167) | (v167 == -16);
        v167 += 16;
        if ( v2 )
          break;
LABEL_181:
        v172 = _mm_cmpeq_epi8(v166, v165);
        if ( (_mm_movemask_epi8(v172) & 0xC000) != 0 )
        {
          v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
          v41 = _mm_srli_si128(v172, 14);
          v42 = _mm_srli_si128(v165, 14);
          goto LABEL_194;
        }
        v166 = 0LL;
        v167 -= 4096;
      }
      v170 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
      v171 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
      v166 = _mm_cmpeq_epi8(v166, v170);
      v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v170, _mm_alignr_epi8(v171, v165, 14)), v166)) - 0xFFFF;
      if ( v26 )
        goto LABEL_195;
      v15 += 16;
      v165 = v171;
    }
  }
  v173 = _mm_load_si128(v17);
  v174 = (unsigned int)_mm_movemask_epi8(
                         _mm_sub_epi8(
                           _mm_cmpeq_epi8(_mm_slli_si128(_mm_load_si128(v18), 1), v173),
                           _mm_cmpeq_epi8((__m128i)0LL, v173))) >> v15;
  v26 = (0xFFFFu >> v15) - v174;
  v23 = 0xFFFFu >> v15 == v174;
  v27 = v15 - 1;
  if ( !v23 )
    goto LABEL_196;
  v175 = _mm_load_si128(v18);
  v176 = 0LL;
  v15 = 16;
  v19 |= 0xFu;
  v177 = (((_WORD)v18 + 15) & 0xFFF) - 4096;
LABEL_186:
  v2 = (v177 + 16 < 0) ^ __OFADD__(16, v177) | (v177 == -16);
  v177 += 16;
  if ( !v2 )
    goto LABEL_191;
  while ( 1 )
  {
    v178 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
    v179 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
    v176 = _mm_cmpeq_epi8(v176, v178);
    v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v178, _mm_alignr_epi8(v179, v175, 15)), v176)) - 0xFFFF;
    if ( v26 )
      goto LABEL_195;
    v15 += 16;
    v175 = v179;
    v2 = (v177 + 16 < 0) ^ __OFADD__(16, v177) | (v177 == -16);
    v177 += 16;
    if ( v2 )
    {
      v180 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
      v181 = _mm_load_si128((const __m128i *)((char *)v18 + v15));
      v176 = _mm_cmpeq_epi8(v176, v180);
      v26 = _mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v180, _mm_alignr_epi8(v181, v175, 15)), v176)) - 0xFFFF;
      if ( v26 )
        goto LABEL_195;
      v15 += 16;
      v175 = v181;
      goto LABEL_186;
    }
LABEL_191:
    v182 = _mm_cmpeq_epi8(v176, v175);
    if ( (_mm_movemask_epi8(v182) & 0x8000) != 0 )
      break;
    v176 = 0LL;
    v177 -= 4096;
  }
  v40 = _mm_load_si128((const __m128i *)((char *)v17 + v15));
  v41 = _mm_srli_si128(v182, 15);
  v42 = _mm_srli_si128(v175, 15);
LABEL_194:
  v26 = ~_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v40, v42), v41));
LABEL_195:
  v27 = (v19 & 0x1F) + v15 - 16;
LABEL_196:
  v10 = (int)v18->m128i_i32 + v27;
  v11 = (int)v17->m128i_i32 + v15;
  if ( (v19 & 0x20) != 0 )
  {
    v183 = v11;
    v11 = v10;
    v10 = v183;
  }
  LOWORD(v14) = v26;
LABEL_199:
  if ( (_BYTE)v14 )
  {
    if ( (v14 & 1) == 0 )
    {
      if ( (v14 & 2) == 0 )
      {
        if ( (v14 & 4) == 0 )
        {
          if ( (v14 & 8) == 0 )
          {
            if ( (v14 & 0x10) == 0 )
            {
              if ( (v14 & 0x20) == 0 )
              {
                if ( (v14 & 0x40) == 0 )
                  return *(unsigned __int8 *)(v10 + 7) - *(unsigned __int8 *)(v11 + 7);
                return *(unsigned __int8 *)(v10 + 6) - *(unsigned __int8 *)(v11 + 6);
              }
              return *(unsigned __int8 *)(v10 + 5) - *(unsigned __int8 *)(v11 + 5);
            }
            return *(unsigned __int8 *)(v10 + 4) - *(unsigned __int8 *)(v11 + 4);
          }
          return *(unsigned __int8 *)(v10 + 3) - *(unsigned __int8 *)(v11 + 3);
        }
        return *(unsigned __int8 *)(v10 + 2) - *(unsigned __int8 *)(v11 + 2);
      }
      return *(unsigned __int8 *)(v10 + 1) - *(unsigned __int8 *)(v11 + 1);
    }
    return *(unsigned __int8 *)v10 - *(unsigned __int8 *)v11;
  }
  v11 += 8;
  v10 += 8;
  if ( (v14 & 0x100) != 0 )
    return *(unsigned __int8 *)v10 - *(unsigned __int8 *)v11;
  if ( (v14 & 0x200) != 0 )
    return *(unsigned __int8 *)(v10 + 1) - *(unsigned __int8 *)(v11 + 1);
  if ( (v14 & 0x400) != 0 )
    return *(unsigned __int8 *)(v10 + 2) - *(unsigned __int8 *)(v11 + 2);
  if ( (v14 & 0x800) != 0 )
    return *(unsigned __int8 *)(v10 + 3) - *(unsigned __int8 *)(v11 + 3);
  if ( (v14 & 0x1000) != 0 )
    return *(unsigned __int8 *)(v10 + 4) - *(unsigned __int8 *)(v11 + 4);
  if ( (v14 & 0x2000) != 0 )
    return *(unsigned __int8 *)(v10 + 5) - *(unsigned __int8 *)(v11 + 5);
  if ( (v14 & 0x4000) != 0 )
    return *(unsigned __int8 *)(v10 + 6) - *(unsigned __int8 *)(v11 + 6);
  return *(unsigned __int8 *)(v10 + 7) - *(unsigned __int8 *)(v11 + 7);
}

//----- (08072610) --------------------------------------------------------
int __cdecl _strcmp_sse4_2(const __m128i *a1, const __m128i *a2)
{
  const __m128i *v2; // edx
  const __m128i *v3; // eax
  __m128i v4; // xmm2
  int v5; // ecx
  char v6; // cc
  unsigned __int8 v7; // cl
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // cl
  unsigned __int8 v10; // cl
  unsigned __int8 v11; // cl
  unsigned __int8 v12; // cl
  unsigned __int8 v13; // cl
  __int32 *v14; // edi
  __int32 *v15; // esi
  int result; // eax
  int v17; // ecx
  int v18; // edx
  int v19; // edi
  int v20; // esi
  __m128i v21; // xmm2
  __m128i v22; // xmm1
  bool v23; // cf
  int v24; // ecx
  int v25; // ecx
  __int32 v26; // ecx
  __int32 v27; // ecx
  unsigned __int8 v28; // cl
  unsigned __int8 v29; // cl
  unsigned __int8 v30; // cl
  unsigned __int8 v31; // cl
  unsigned __int8 v32; // cl
  unsigned __int8 v33; // cl
  unsigned __int8 v34; // cl

  v2 = a1;
  v3 = a2;
  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFF0 )
  {
    v4 = _mm_loadu_si128(a1);
    if ( ((unsigned __int16)a2 & 0xFFFu) <= 0xFF0 )
    {
      v5 = _mm_cvtsi128_si32(v4);
      if ( v5 == a2->m128i_i32[0] )
      {
        if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(a2), v4))
          && _mm_testc_si128((__m128i)0LL, _mm_cmpeq_epi8(v4, (__m128i)0LL)) )
        {
          v2 = a1 + 1;
          v3 = a2 + 1;
          goto LABEL_7;
        }
        v23 = __CFADD__(v5, -16843009);
        v25 = v5 - 16843009;
        if ( v23 && (a1->m128i_i32[0] ^ v25 | 0xFEFEFEFF) == -1 )
        {
          v26 = a1->m128i_i32[1];
          if ( v26 != a2->m128i_i32[1] )
            goto LABEL_54;
          v23 = __CFADD__(v26, -16843009);
          v27 = v26 - 16843009;
          if ( !v23 || (a1->m128i_i32[1] ^ v27 | 0xFEFEFEFF) != -1 )
            goto LABEL_54;
          v2 = (const __m128i *)&a1->m128i_i8[8];
          v3 = (const __m128i *)&a2->m128i_i8[8];
        }
      }
      v6 = v2->m128i_i8[0] <= (unsigned int)v3->m128i_i8[0];
      if ( v2->m128i_i8[0] != v3->m128i_i8[0] )
        goto LABEL_37;
      if ( !v3->m128i_i8[0] )
        return 0;
      v28 = v3->m128i_u8[1];
      v6 = (unsigned int)v2->m128i_i8[1] <= v28;
      if ( v2->m128i_i8[1] != v28 )
        goto LABEL_37;
      if ( !v3->m128i_i8[1] )
        return 0;
      v29 = v3->m128i_u8[2];
      v6 = (unsigned int)v2->m128i_i8[2] <= v29;
      if ( v2->m128i_i8[2] != v29 )
        goto LABEL_37;
      if ( !v3->m128i_i8[2] )
        return 0;
      v30 = v3->m128i_u8[3];
      v6 = (unsigned int)v2->m128i_i8[3] <= v30;
      if ( v2->m128i_i8[3] != v30 )
        goto LABEL_37;
      if ( !v3->m128i_i8[3] )
        return 0;
LABEL_54:
      v31 = v3->m128i_u8[4];
      v6 = (unsigned int)v2->m128i_i8[4] <= v31;
      if ( v2->m128i_i8[4] == v31 )
      {
        if ( !v3->m128i_i8[4] )
          return 0;
        v32 = v3->m128i_u8[5];
        v6 = (unsigned int)v2->m128i_i8[5] <= v32;
        if ( v2->m128i_i8[5] == v32 )
        {
          if ( !v3->m128i_i8[5] )
            return 0;
          v33 = v3->m128i_u8[6];
          v6 = (unsigned int)v2->m128i_i8[6] <= v33;
          if ( v2->m128i_i8[6] == v33 )
          {
            if ( !v3->m128i_i8[6] )
              return 0;
            v34 = v3->m128i_u8[7];
            v6 = (unsigned int)v2->m128i_i8[7] <= v34;
            if ( v2->m128i_i8[7] == v34 )
              return 0;
          }
        }
      }
      goto LABEL_37;
    }
  }
LABEL_7:
  v6 = v2->m128i_i8[0] <= (unsigned int)v3->m128i_i8[0];
  if ( v2->m128i_i8[0] != v3->m128i_i8[0] )
    goto LABEL_37;
  if ( !v3->m128i_i8[0] )
    return 0;
  v7 = v3->m128i_u8[1];
  v6 = (unsigned int)v2->m128i_i8[1] <= v7;
  if ( v2->m128i_i8[1] != v7 )
    goto LABEL_37;
  if ( !v3->m128i_i8[1] )
    return 0;
  v8 = v3->m128i_u8[2];
  v6 = (unsigned int)v2->m128i_i8[2] <= v8;
  if ( v2->m128i_i8[2] != v8 )
    goto LABEL_37;
  if ( !v3->m128i_i8[2] )
    return 0;
  v9 = v3->m128i_u8[3];
  v6 = (unsigned int)v2->m128i_i8[3] <= v9;
  if ( v2->m128i_i8[3] != v9 )
    goto LABEL_37;
  if ( !v3->m128i_i8[3] )
    return 0;
  v10 = v3->m128i_u8[4];
  v6 = (unsigned int)v2->m128i_i8[4] <= v10;
  if ( v2->m128i_i8[4] != v10 )
    goto LABEL_37;
  if ( !v3->m128i_i8[4] )
    return 0;
  v11 = v3->m128i_u8[5];
  v6 = (unsigned int)v2->m128i_i8[5] <= v11;
  if ( v2->m128i_i8[5] != v11 )
    goto LABEL_37;
  if ( !v3->m128i_i8[5] )
    return 0;
  v12 = v3->m128i_u8[6];
  v6 = (unsigned int)v2->m128i_i8[6] <= v12;
  if ( v2->m128i_i8[6] != v12 )
    goto LABEL_37;
  if ( !v3->m128i_i8[6] )
    return 0;
  v13 = v3->m128i_u8[7];
  v6 = (unsigned int)v2->m128i_i8[7] <= v13;
  if ( v2->m128i_i8[7] != v13 )
  {
LABEL_37:
    result = 1;
    if ( v6 )
      return -1;
    return result;
  }
  if ( !v3->m128i_i8[7] )
    return 0;
  v14 = &v2->m128i_i32[2];
  v15 = &v3->m128i_i32[2];
  result = 0;
LABEL_24:
  v17 = (unsigned __int16)v15 & 0xFFF;
  if ( v17 < ((unsigned __int16)v14 & 0xFFF) )
    v17 = (unsigned __int16)v14 & 0xFFF;
  v18 = v17 - 4080;
  v19 = (int)v14 - v17 + 4080;
  v20 = (int)v15 - v17 + 4080;
  if ( v17 - 4080 > 0 )
  {
LABEL_29:
    while ( 1 )
    {
      result = *(unsigned __int8 *)(v19 + v18) - *(unsigned __int8 *)(v20 + v18);
      if ( result || !*(_BYTE *)(v20 + v18) )
        break;
      if ( ++v18 > 15 )
      {
        v14 = (__int32 *)(v18 + v19);
        v15 = (__int32 *)(v18 + v20);
        goto LABEL_24;
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v21 = _mm_loadu_si128((const __m128i *)(v20 + v18));
      v22 = _mm_loadu_si128((const __m128i *)(v19 + v18));
      v24 = _mm_cmpistri(v22, v21, 26);
      v23 = _mm_cmpistrc(v22, v21, 26);
      if ( v23 | _mm_cmpistrz(v22, v21, 26) )
        break;
      v6 = (v18 + 16 < 0) ^ __OFADD__(16, v18) | (v18 == -16);
      v18 += 16;
      if ( !v6 )
        goto LABEL_29;
    }
    if ( v23 )
      return *(unsigned __int8 *)(v19 + v24 + v18) - *(unsigned __int8 *)(v20 + v24 + v18);
  }
  return result;
}

//----- (080728A0) --------------------------------------------------------
int __cdecl strncmp(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 v3; // al
  unsigned __int8 v4; // si
  int v5; // edi
  unsigned int v8; // ebp
  int v10; // edi
  int v11; // ebp

  v3 = 0;
  v4 = 0;
  v5 = a3;
  if ( a3 > 3 )
  {
    v8 = a3 >> 2;
    while ( 1 )
    {
      v4 = *a2;
      v3 = *a1;
      if ( *a1 != *a2 )
        break;
      if ( !v3 )
        break;
      v4 = a2[1];
      v3 = a1[1];
      if ( v3 != v4 )
        break;
      if ( !v3 )
        break;
      v4 = a2[2];
      v3 = a1[2];
      if ( v3 != v4 )
        break;
      if ( !v3 )
        break;
      v4 = a2[3];
      v3 = a1[3];
      if ( v3 != v4 || !v3 )
        break;
      a1 += 4;
      a2 += 4;
      if ( !--v8 )
      {
        v5 = a3 & 3;
        goto LABEL_14;
      }
    }
    return v3 - v4;
  }
LABEL_14:
  if ( !v5 )
    return v3 - v4;
  v4 = *a2;
  v3 = *a1;
  if ( *a1 != *a2 )
    return v3 - v4;
  v10 = v5 - 1;
  v11 = 0;
  if ( !v3 )
    return v3 - v4;
  while ( v11 != v10 )
  {
    v4 = a2[v11 + 1];
    v3 = a1[++v11];
    if ( v3 != v4 || !v3 )
      return v3 - v4;
  }
  return v3 - v4;
}

//----- (08072980) --------------------------------------------------------
int __cdecl _strncpy_ia32(int a1, char *a2, unsigned int a3)
{
  _BYTE *v4; // edx
  unsigned int v5; // esi
  char v6; // bl
  char v7; // al
  _BYTE *v8; // ebx
  char v9; // al
  char v10; // al
  int v11; // ebx
  char v12; // al
  int v14; // ebx

  v4 = (_BYTE *)(a1 - 1);
  if ( a3 <= 3 )
  {
LABEL_8:
    v11 = a3 & 3;
    if ( (a3 & 3) != 0 )
    {
      while ( 1 )
      {
        v12 = *a2++;
        --v11;
        v4[1] = v12;
        if ( !v11 )
          break;
        ++v4;
        if ( !v12 )
          goto LABEL_11;
      }
    }
  }
  else
  {
    v5 = a3 >> 2;
    while ( 1 )
    {
      v6 = *a2;
      v4[1] = *a2;
      if ( !v6 )
      {
        ++v4;
        goto LABEL_14;
      }
      v7 = a2[1];
      v8 = v4 + 2;
      v4[2] = v7;
      if ( !v7 )
        break;
      v9 = a2[2];
      v8 = v4 + 3;
      v4[3] = v9;
      if ( !v9 )
        break;
      v10 = a2[3];
      v4 += 4;
      *v4 = v10;
      if ( !v10 )
        goto LABEL_14;
      a2 += 4;
      if ( !--v5 )
        goto LABEL_8;
    }
    v4 = v8;
LABEL_14:
    v14 = a3 + a1 - (_DWORD)v4 - 1;
    if ( a3 + a1 - (_DWORD)v4 != 1 )
    {
      ++v4;
      v11 = v14 - 1;
      for ( *v4 = 0; v11; *v4 = 0 )
      {
LABEL_11:
        ++v4;
        --v11;
      }
    }
  }
  return a1;
}

//----- (08072A40) --------------------------------------------------------
unsigned int __cdecl _strcpy_ssse3(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // edx
  unsigned int v3; // ecx
  __m128i *v4; // esi
  __m128i v5; // xmm0
  int v6; // eax
  int v7; // esi
  unsigned int v8; // eax
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  __m128i v11; // xmm3
  __m128i v12; // xmm0
  __m128i v13; // xmm4
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  __m128i v18; // xmm0
  __m128i v19; // xmm3
  __m128i v20; // xmm0
  __m128i v21; // xmm4
  __m128i v22; // xmm5
  __m128i v23; // xmm6
  __m128i v24; // xmm7
  __m128i v25; // xmm3
  __m128i v26; // xmm0
  __m128i v27; // xmm0
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  __m128i v30; // xmm2
  __m128i v31; // xmm0
  __m128i v32; // xmm3
  __m128i v33; // xmm2
  __m128i v34; // xmm1
  __m128i v35; // xmm2
  __m128i v36; // xmm0
  __m128i v37; // xmm3
  __m128i v38; // xmm2
  __m128i v39; // xmm1
  __m128i v40; // xmm0
  __m128i v41; // xmm3
  __m128i v42; // xmm2
  unsigned int v43; // eax
  unsigned int v44; // ecx
  unsigned int v45; // eax
  __m128i v46; // xmm3
  __m128i v47; // xmm4
  __m128i v48; // xmm5
  int v49; // eax
  __m128i v50; // xmm7
  __m128i v51; // xmm5
  __m128i v52; // xmm4
  __m128i v53; // xmm3
  __m128i v54; // xmm2
  __m128i v55; // xmm1
  __m128i v56; // xmm2
  __m128i v57; // xmm0
  __m128i v58; // xmm3
  __m128i v59; // xmm2
  __m128i v60; // xmm1
  __m128i v61; // xmm2
  __m128i v62; // xmm0
  __m128i v63; // xmm3
  __m128i v64; // xmm2
  __m128i v65; // xmm1
  __m128i v66; // xmm0
  __m128i v67; // xmm3
  __m128i v68; // xmm2
  unsigned int v69; // eax
  unsigned int v70; // ecx
  unsigned int v71; // eax
  __m128i v72; // xmm3
  __m128i v73; // xmm4
  __m128i v74; // xmm5
  int v75; // eax
  __m128i v76; // xmm7
  __m128i v77; // xmm5
  __m128i v78; // xmm4
  __m128i v79; // xmm3
  __m128i v80; // xmm2
  double v81; // xmm1_8
  __m128i v82; // xmm1
  __m128i v83; // xmm2
  __m128i v84; // xmm0
  __m128i v85; // xmm3
  __m128i v86; // xmm2
  __m128i v87; // xmm1
  __m128i v88; // xmm2
  __m128i v89; // xmm0
  __m128i v90; // xmm3
  __m128i v91; // xmm2
  __m128i v92; // xmm1
  __m128i v93; // xmm0
  __m128i v94; // xmm3
  __m128i v95; // xmm2
  unsigned int v96; // eax
  unsigned int v97; // ecx
  unsigned int v98; // eax
  __m128i v99; // xmm3
  __m128i v100; // xmm4
  __m128i v101; // xmm5
  int v102; // eax
  __m128i v103; // xmm7
  __m128i v104; // xmm5
  __m128i v105; // xmm4
  __m128i v106; // xmm3
  __m128i v107; // xmm2
  double v108; // xmm1_8
  __m128i v109; // xmm1
  __m128i v110; // xmm2
  __m128i v111; // xmm0
  __m128i v112; // xmm3
  __m128i v113; // xmm2
  __m128i v114; // xmm1
  __m128i v115; // xmm2
  __m128i v116; // xmm0
  __m128i v117; // xmm3
  __m128i v118; // xmm2
  __m128i v119; // xmm1
  __m128i v120; // xmm0
  __m128i v121; // xmm3
  __m128i v122; // xmm2
  unsigned int v123; // eax
  unsigned int v124; // ecx
  unsigned int v125; // eax
  __m128i v126; // xmm3
  __m128i v127; // xmm4
  __m128i v128; // xmm5
  int v129; // eax
  __m128i v130; // xmm7
  __m128i v131; // xmm5
  __m128i v132; // xmm4
  __m128i v133; // xmm3
  __m128i v134; // xmm2
  int v135; // esi
  __m128i v136; // xmm1
  __m128i v137; // xmm2
  __m128i v138; // xmm0
  __m128i v139; // xmm3
  __m128i v140; // xmm2
  __m128i v141; // xmm1
  __m128i v142; // xmm2
  __m128i v143; // xmm0
  __m128i v144; // xmm3
  __m128i v145; // xmm2
  __m128i v146; // xmm1
  __m128i v147; // xmm0
  __m128i v148; // xmm3
  __m128i v149; // xmm2
  unsigned int v150; // eax
  unsigned int v151; // ecx
  unsigned int v152; // eax
  __m128i v153; // xmm3
  __m128i v154; // xmm4
  __m128i v155; // xmm5
  int v156; // eax
  __m128i v157; // xmm7
  __m128i v158; // xmm5
  __m128i v159; // xmm4
  __m128i v160; // xmm3
  __m128i v161; // xmm2
  int v162; // esi
  __m128i v163; // xmm1
  __m128i v164; // xmm2
  __m128i v165; // xmm0
  __m128i v166; // xmm3
  __m128i v167; // xmm2
  __m128i v168; // xmm1
  __m128i v169; // xmm2
  __m128i v170; // xmm0
  __m128i v171; // xmm3
  __m128i v172; // xmm2
  __m128i v173; // xmm1
  __m128i v174; // xmm0
  __m128i v175; // xmm3
  __m128i v176; // xmm2
  unsigned int v177; // eax
  unsigned int v178; // ecx
  unsigned int v179; // eax
  __m128i v180; // xmm3
  __m128i v181; // xmm4
  __m128i v182; // xmm5
  int v183; // eax
  __m128i v184; // xmm7
  __m128i v185; // xmm5
  __m128i v186; // xmm4
  __m128i v187; // xmm3
  __m128i v188; // xmm2
  int v189; // esi
  __m128i v190; // xmm1
  __m128i v191; // xmm2
  __m128i v192; // xmm0
  __m128i v193; // xmm3
  __m128i v194; // xmm2
  __m128i v195; // xmm1
  __m128i v196; // xmm2
  __m128i v197; // xmm0
  __m128i v198; // xmm3
  __m128i v199; // xmm2
  __m128i v200; // xmm1
  __m128i v201; // xmm0
  __m128i v202; // xmm3
  __m128i v203; // xmm2
  unsigned int v204; // eax
  unsigned int v205; // ecx
  unsigned int v206; // eax
  __m128i v207; // xmm3
  __m128i v208; // xmm4
  __m128i v209; // xmm5
  int v210; // eax
  __m128i v211; // xmm7
  __m128i v212; // xmm5
  __m128i v213; // xmm4
  __m128i v214; // xmm3
  __m128i v215; // xmm2
  int v216; // esi
  __m128i v217; // xmm1
  __m128i v218; // xmm2
  __m128i v219; // xmm0
  __m128i v220; // xmm3
  __m128i v221; // xmm2
  __m128i v222; // xmm1
  __m128i v223; // xmm2
  __m128i v224; // xmm0
  __m128i v225; // xmm3
  __m128i v226; // xmm2
  __m128i v227; // xmm1
  __m128i v228; // xmm0
  __m128i v229; // xmm3
  __m128i v230; // xmm2
  unsigned int v231; // eax
  unsigned int v232; // ecx
  unsigned int v233; // eax
  __m128i v234; // xmm3
  __m128i v235; // xmm4
  __m128i v236; // xmm5
  int v237; // eax
  __m128i v238; // xmm7
  __m128i v239; // xmm5
  __m128i v240; // xmm4
  __m128i v241; // xmm3
  __m128i v242; // xmm2
  __m128i v243; // xmm1
  __m128i v244; // xmm2
  __m128i v245; // xmm0
  __m128i v246; // xmm3
  __m128i v247; // xmm2
  __m128i v248; // xmm1
  __m128i v249; // xmm2
  __m128i v250; // xmm0
  __m128i v251; // xmm3
  __m128i v252; // xmm2
  __m128i v253; // xmm1
  __m128i v254; // xmm0
  __m128i v255; // xmm3
  __m128i v256; // xmm2
  unsigned int v257; // eax
  unsigned int v258; // ecx
  unsigned int v259; // eax
  __m128i v260; // xmm3
  __m128i v261; // xmm4
  __m128i v262; // xmm5
  int v263; // eax
  __m128i v264; // xmm7
  __m128i v265; // xmm5
  __m128i v266; // xmm4
  __m128i v267; // xmm3
  __m128i v268; // xmm2
  __m128i v269; // xmm1
  __m128i v270; // xmm2
  __m128i v271; // xmm0
  __m128i v272; // xmm3
  __m128i v273; // xmm2
  __m128i v274; // xmm1
  __m128i v275; // xmm2
  __m128i v276; // xmm0
  __m128i v277; // xmm3
  __m128i v278; // xmm2
  __m128i v279; // xmm1
  __m128i v280; // xmm0
  __m128i v281; // xmm3
  __m128i v282; // xmm2
  unsigned int v283; // eax
  unsigned int v284; // ecx
  unsigned int v285; // eax
  __m128i v286; // xmm3
  __m128i v287; // xmm4
  __m128i v288; // xmm5
  int v289; // eax
  __m128i v290; // xmm7
  __m128i v291; // xmm5
  __m128i v292; // xmm4
  __m128i v293; // xmm3
  __m128i v294; // xmm2
  __m128i v295; // xmm1
  __m128i v296; // xmm2
  __m128i v297; // xmm0
  __m128i v298; // xmm3
  __m128i v299; // xmm2
  __m128i v300; // xmm1
  __m128i v301; // xmm2
  __m128i v302; // xmm0
  __m128i v303; // xmm3
  __m128i v304; // xmm2
  __m128i v305; // xmm1
  __m128i v306; // xmm0
  __m128i v307; // xmm3
  __m128i v308; // xmm2
  unsigned int v309; // eax
  unsigned int v310; // ecx
  unsigned int v311; // eax
  __m128i v312; // xmm3
  __m128i v313; // xmm4
  __m128i v314; // xmm5
  int v315; // eax
  __m128i v316; // xmm7
  __m128i v317; // xmm5
  __m128i v318; // xmm4
  __m128i v319; // xmm3
  __m128i v320; // xmm2
  __m128i v321; // xmm1
  __m128i v322; // xmm2
  __m128i v323; // xmm0
  __m128i v324; // xmm3
  __m128i v325; // xmm2
  __m128i v326; // xmm1
  __m128i v327; // xmm2
  __m128i v328; // xmm0
  __m128i v329; // xmm3
  __m128i v330; // xmm2
  __m128i v331; // xmm1
  __m128i v332; // xmm0
  __m128i v333; // xmm3
  __m128i v334; // xmm2
  unsigned int v335; // eax
  unsigned int v336; // ecx
  unsigned int v337; // eax
  __m128i v338; // xmm3
  __m128i v339; // xmm4
  __m128i v340; // xmm5
  int v341; // eax
  __m128i v342; // xmm7
  __m128i v343; // xmm5
  __m128i v344; // xmm4
  __m128i v345; // xmm3
  __m128i v346; // xmm2
  __m128i v347; // xmm1
  __m128i v348; // xmm2
  __m128i v349; // xmm0
  __m128i v350; // xmm3
  __m128i v351; // xmm2
  __m128i v352; // xmm1
  __m128i v353; // xmm2
  __m128i v354; // xmm0
  __m128i v355; // xmm3
  __m128i v356; // xmm2
  __m128i v357; // xmm1
  __m128i v358; // xmm0
  __m128i v359; // xmm3
  __m128i v360; // xmm2
  unsigned int v361; // eax
  unsigned int v362; // ecx
  unsigned int v363; // eax
  __m128i v364; // xmm3
  __m128i v365; // xmm4
  __m128i v366; // xmm5
  int v367; // eax
  __m128i v368; // xmm7
  __m128i v369; // xmm5
  __m128i v370; // xmm4
  __m128i v371; // xmm3
  __m128i v372; // xmm2
  __m128i v373; // xmm1
  __m128i v374; // xmm2
  __m128i v375; // xmm0
  __m128i v376; // xmm3
  __m128i v377; // xmm2
  __m128i v378; // xmm1
  __m128i v379; // xmm2
  __m128i v380; // xmm0
  __m128i v381; // xmm3
  __m128i v382; // xmm2
  __m128i v383; // xmm1
  __m128i v384; // xmm0
  __m128i v385; // xmm3
  __m128i v386; // xmm2
  unsigned int v387; // eax
  unsigned int v388; // ecx
  unsigned int v389; // eax
  __m128i v390; // xmm3
  __m128i v391; // xmm4
  __m128i v392; // xmm5
  int v393; // eax
  __m128i v394; // xmm7
  __m128i v395; // xmm5
  __m128i v396; // xmm4
  __m128i v397; // xmm3
  __m128i v398; // xmm2
  __m128i v399; // xmm1
  __m128i v400; // xmm2
  __m128i v401; // xmm0
  __m128i v402; // xmm3
  __m128i v403; // xmm2
  __m128i v404; // xmm1
  __m128i v405; // xmm2
  __m128i v406; // xmm0
  __m128i v407; // xmm3
  __m128i v408; // xmm2
  __m128i v409; // xmm1
  __m128i v410; // xmm0
  __m128i v411; // xmm3
  __m128i v412; // xmm2
  unsigned int v413; // eax
  unsigned int v414; // ecx
  unsigned int v415; // eax
  __m128i v416; // xmm3
  __m128i v417; // xmm4
  __m128i v418; // xmm5
  int v419; // eax
  __m128i v420; // xmm7
  __m128i v421; // xmm5
  __m128i v422; // xmm4
  __m128i v423; // xmm3
  __m128i v424; // xmm2
  unsigned int v425; // edx
  unsigned int v426; // ecx
  int v428; // eax
  char v429; // al
  __int16 v430; // ax
  int v431; // eax
  double v432; // xmm1_8
  double v433; // xmm1_8
  double v434; // xmm1_8
  char v435; // al
  __int16 v436; // ax
  int v437; // eax
  int v438; // eax
  double v439; // xmm1_8
  double v440; // xmm1_8
  double v441; // xmm1_8

  v2 = a1;
  v3 = a2;
  if ( *(_BYTE *)a2 )
  {
    if ( *(_BYTE *)(a2 + 1) )
    {
      if ( *(_BYTE *)(a2 + 2) )
      {
        if ( *(_BYTE *)(a2 + 3) )
        {
          if ( *(_BYTE *)(a2 + 4) )
          {
            if ( *(_BYTE *)(a2 + 5) )
            {
              if ( *(_BYTE *)(a2 + 6) )
              {
                if ( *(_BYTE *)(a2 + 7) )
                {
                  if ( *(_BYTE *)(a2 + 8) )
                  {
                    if ( *(_BYTE *)(a2 + 9) )
                    {
                      if ( *(_BYTE *)(a2 + 10) )
                      {
                        if ( *(_BYTE *)(a2 + 11) )
                        {
                          if ( *(_BYTE *)(a2 + 12) )
                          {
                            if ( *(_BYTE *)(a2 + 13) )
                            {
                              if ( *(_BYTE *)(a2 + 14) )
                              {
                                if ( *(_BYTE *)(a2 + 15) )
                                {
                                  v4 = (__m128i *)((a2 + 16) & 0xFFFFFFF0);
                                  *(double *)a1 = *(double *)a2;
                                  v5 = _mm_cmpeq_epi8((__m128i)0LL, *v4);
                                  *(double *)(a1 + 8) = *(double *)(a2 + 8);
                                  v6 = _mm_movemask_epi8(v5);
                                  v7 = (int)v4->m128i_i32 - a2;
                                  if ( !v6 )
                                  {
                                    v2 = (a1 + 16) & 0xFFFFFFF0;
                                    v3 = a2 - (a1 - v2);
                                    v8 = v3 & 0xF;
                                    if ( (v3 & 0xF) != 0 )
                                    {
                                      if ( v8 >= 8 )
                                      {
                                        switch ( v8 )
                                        {
                                          case 8u:
                                            v217 = *(__m128i *)(v3 - 8);
                                            v218 = *(__m128i *)(v3 + 8);
                                            while ( 1 )
                                            {
                                              v219 = _mm_cmpeq_epi8(v5, v218);
                                              v6 = _mm_movemask_epi8(v219);
                                              v220 = v218;
                                              if ( v6 )
                                                break;
                                              v221 = _mm_alignr_epi8(v218, v217, 8);
                                              v222 = v220;
                                              *(__m128i *)v2 = v221;
                                              v223 = *(__m128i *)(v3 + 24);
                                              v224 = _mm_cmpeq_epi8(v219, v223);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v224);
                                              v3 += 16;
                                              v225 = v223;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v223, v222, 8);
                                              v226 = *(__m128i *)(v3 + 24);
                                              v227 = v225;
                                              v228 = _mm_cmpeq_epi8(v224, v226);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v228);
                                              v3 += 16;
                                              v229 = v226;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v226, v227, 8);
                                              v230 = *(__m128i *)(v3 + 24);
                                              v5 = _mm_cmpeq_epi8(v228, v230);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v230, v229, 8);
                                              v231 = v3 + 24;
                                              v232 = (v3 + 24) & 0xFFFFFFC0;
                                              v233 = v231 - v232;
                                              v3 = v232 - 8;
                                              v2 = v2 + 16 - v233;
                                              v217 = *(__m128i *)(v3 - 8);
                                              while ( 1 )
                                              {
                                                v218 = *(__m128i *)(v3 + 8);
                                                v234 = *(__m128i *)(v3 + 24);
                                                v235 = *(__m128i *)(v3 + 40);
                                                v236 = *(__m128i *)(v3 + 56);
                                                v237 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v235, v236),
                                                             _mm_min_epu8(v234, v218)),
                                                           v5));
                                                v238 = v236;
                                                v239 = _mm_alignr_epi8(v236, v235, 8);
                                                v240 = _mm_alignr_epi8(v235, v234, 8);
                                                if ( v237 )
                                                  break;
                                                v241 = _mm_alignr_epi8(v234, v218, 8);
                                                v3 += 64;
                                                v242 = _mm_alignr_epi8(v218, v217, 8);
                                                v217 = v238;
                                                *(__m128i *)(v2 + 48) = v239;
                                                *(__m128i *)(v2 + 32) = v240;
                                                *(__m128i *)(v2 + 16) = v241;
                                                *(__m128i *)v2 = v242;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)v2 = *(double *)v3;
                                            v7 = 8;
                                            break;
                                          case 9u:
                                            v243 = *(__m128i *)(v3 - 9);
                                            v244 = *(__m128i *)(v3 + 7);
                                            while ( 1 )
                                            {
                                              v245 = _mm_cmpeq_epi8(v5, v244);
                                              v6 = _mm_movemask_epi8(v245);
                                              v246 = v244;
                                              if ( v6 )
                                                break;
                                              v247 = _mm_alignr_epi8(v244, v243, 9);
                                              v248 = v246;
                                              *(__m128i *)v2 = v247;
                                              v249 = *(__m128i *)(v3 + 23);
                                              v250 = _mm_cmpeq_epi8(v245, v249);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v250);
                                              v3 += 16;
                                              v251 = v249;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v249, v248, 9);
                                              v252 = *(__m128i *)(v3 + 23);
                                              v253 = v251;
                                              v254 = _mm_cmpeq_epi8(v250, v252);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v254);
                                              v3 += 16;
                                              v255 = v252;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v252, v253, 9);
                                              v256 = *(__m128i *)(v3 + 23);
                                              v5 = _mm_cmpeq_epi8(v254, v256);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v256, v255, 9);
                                              v257 = v3 + 23;
                                              v258 = (v3 + 23) & 0xFFFFFFC0;
                                              v259 = v257 - v258;
                                              v3 = v258 - 7;
                                              v2 = v2 + 16 - v259;
                                              v243 = *(__m128i *)(v3 - 9);
                                              while ( 1 )
                                              {
                                                v244 = *(__m128i *)(v3 + 7);
                                                v260 = *(__m128i *)(v3 + 23);
                                                v261 = *(__m128i *)(v3 + 39);
                                                v262 = *(__m128i *)(v3 + 55);
                                                v263 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v261, v262),
                                                             _mm_min_epu8(v260, v244)),
                                                           v5));
                                                v264 = v262;
                                                v265 = _mm_alignr_epi8(v262, v261, 9);
                                                v266 = _mm_alignr_epi8(v261, v260, 9);
                                                if ( v263 )
                                                  break;
                                                v267 = _mm_alignr_epi8(v260, v244, 9);
                                                v3 += 64;
                                                v268 = _mm_alignr_epi8(v244, v243, 9);
                                                v243 = v264;
                                                *(__m128i *)(v2 + 48) = v265;
                                                *(__m128i *)(v2 + 32) = v266;
                                                *(__m128i *)(v2 + 16) = v267;
                                                *(__m128i *)v2 = v268;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)(v2 - 1) = *(double *)(v3 - 1);
                                            v7 = 7;
                                            break;
                                          case 0xAu:
                                            v269 = *(__m128i *)(v3 - 10);
                                            v270 = *(__m128i *)(v3 + 6);
                                            while ( 1 )
                                            {
                                              v271 = _mm_cmpeq_epi8(v5, v270);
                                              v6 = _mm_movemask_epi8(v271);
                                              v272 = v270;
                                              if ( v6 )
                                                break;
                                              v273 = _mm_alignr_epi8(v270, v269, 10);
                                              v274 = v272;
                                              *(__m128i *)v2 = v273;
                                              v275 = *(__m128i *)(v3 + 22);
                                              v276 = _mm_cmpeq_epi8(v271, v275);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v276);
                                              v3 += 16;
                                              v277 = v275;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v275, v274, 10);
                                              v278 = *(__m128i *)(v3 + 22);
                                              v279 = v277;
                                              v280 = _mm_cmpeq_epi8(v276, v278);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v280);
                                              v3 += 16;
                                              v281 = v278;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v278, v279, 10);
                                              v282 = *(__m128i *)(v3 + 22);
                                              v5 = _mm_cmpeq_epi8(v280, v282);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v282, v281, 10);
                                              v283 = v3 + 22;
                                              v284 = (v3 + 22) & 0xFFFFFFC0;
                                              v285 = v283 - v284;
                                              v3 = v284 - 6;
                                              v2 = v2 + 16 - v285;
                                              v269 = *(__m128i *)(v3 - 10);
                                              while ( 1 )
                                              {
                                                v270 = *(__m128i *)(v3 + 6);
                                                v286 = *(__m128i *)(v3 + 22);
                                                v287 = *(__m128i *)(v3 + 38);
                                                v288 = *(__m128i *)(v3 + 54);
                                                v289 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v287, v288),
                                                             _mm_min_epu8(v286, v270)),
                                                           v5));
                                                v290 = v288;
                                                v291 = _mm_alignr_epi8(v288, v287, 10);
                                                v292 = _mm_alignr_epi8(v287, v286, 10);
                                                if ( v289 )
                                                  break;
                                                v293 = _mm_alignr_epi8(v286, v270, 10);
                                                v3 += 64;
                                                v294 = _mm_alignr_epi8(v270, v269, 10);
                                                v269 = v290;
                                                *(__m128i *)(v2 + 48) = v291;
                                                *(__m128i *)(v2 + 32) = v292;
                                                *(__m128i *)(v2 + 16) = v293;
                                                *(__m128i *)v2 = v294;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)(v2 - 2) = *(double *)(v3 - 2);
                                            v7 = 6;
                                            break;
                                          case 0xBu:
                                            v295 = *(__m128i *)(v3 - 11);
                                            v296 = *(__m128i *)(v3 + 5);
                                            while ( 1 )
                                            {
                                              v297 = _mm_cmpeq_epi8(v5, v296);
                                              v6 = _mm_movemask_epi8(v297);
                                              v298 = v296;
                                              if ( v6 )
                                                break;
                                              v299 = _mm_alignr_epi8(v296, v295, 11);
                                              v300 = v298;
                                              *(__m128i *)v2 = v299;
                                              v301 = *(__m128i *)(v3 + 21);
                                              v302 = _mm_cmpeq_epi8(v297, v301);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v302);
                                              v3 += 16;
                                              v303 = v301;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v301, v300, 11);
                                              v304 = *(__m128i *)(v3 + 21);
                                              v305 = v303;
                                              v306 = _mm_cmpeq_epi8(v302, v304);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v306);
                                              v3 += 16;
                                              v307 = v304;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v304, v305, 11);
                                              v308 = *(__m128i *)(v3 + 21);
                                              v5 = _mm_cmpeq_epi8(v306, v308);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v308, v307, 11);
                                              v309 = v3 + 21;
                                              v310 = (v3 + 21) & 0xFFFFFFC0;
                                              v311 = v309 - v310;
                                              v3 = v310 - 5;
                                              v2 = v2 + 16 - v311;
                                              v295 = *(__m128i *)(v3 - 11);
                                              while ( 1 )
                                              {
                                                v296 = *(__m128i *)(v3 + 5);
                                                v312 = *(__m128i *)(v3 + 21);
                                                v313 = *(__m128i *)(v3 + 37);
                                                v314 = *(__m128i *)(v3 + 53);
                                                v315 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v313, v314),
                                                             _mm_min_epu8(v312, v296)),
                                                           v5));
                                                v316 = v314;
                                                v317 = _mm_alignr_epi8(v314, v313, 11);
                                                v318 = _mm_alignr_epi8(v313, v312, 11);
                                                if ( v315 )
                                                  break;
                                                v319 = _mm_alignr_epi8(v312, v296, 11);
                                                v3 += 64;
                                                v320 = _mm_alignr_epi8(v296, v295, 11);
                                                v295 = v316;
                                                *(__m128i *)(v2 + 48) = v317;
                                                *(__m128i *)(v2 + 32) = v318;
                                                *(__m128i *)(v2 + 16) = v319;
                                                *(__m128i *)v2 = v320;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)(v2 - 3) = *(double *)(v3 - 3);
                                            v7 = 5;
                                            break;
                                          case 0xCu:
                                            v321 = *(__m128i *)(v3 - 12);
                                            v322 = *(__m128i *)(v3 + 4);
                                            while ( 1 )
                                            {
                                              v323 = _mm_cmpeq_epi8(v5, v322);
                                              v6 = _mm_movemask_epi8(v323);
                                              v324 = v322;
                                              if ( v6 )
                                                break;
                                              v325 = _mm_alignr_epi8(v322, v321, 12);
                                              v326 = v324;
                                              *(__m128i *)v2 = v325;
                                              v327 = *(__m128i *)(v3 + 20);
                                              v328 = _mm_cmpeq_epi8(v323, v327);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v328);
                                              v3 += 16;
                                              v329 = v327;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v327, v326, 12);
                                              v330 = *(__m128i *)(v3 + 20);
                                              v331 = v329;
                                              v332 = _mm_cmpeq_epi8(v328, v330);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v332);
                                              v3 += 16;
                                              v333 = v330;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v330, v331, 12);
                                              v334 = *(__m128i *)(v3 + 20);
                                              v5 = _mm_cmpeq_epi8(v332, v334);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v334, v333, 12);
                                              v335 = v3 + 20;
                                              v336 = (v3 + 20) & 0xFFFFFFC0;
                                              v337 = v335 - v336;
                                              v3 = v336 - 4;
                                              v2 = v2 + 16 - v337;
                                              v321 = *(__m128i *)(v3 - 12);
                                              while ( 1 )
                                              {
                                                v322 = *(__m128i *)(v3 + 4);
                                                v338 = *(__m128i *)(v3 + 20);
                                                v339 = *(__m128i *)(v3 + 36);
                                                v340 = *(__m128i *)(v3 + 52);
                                                v341 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v339, v340),
                                                             _mm_min_epu8(v338, v322)),
                                                           v5));
                                                v342 = v340;
                                                v343 = _mm_alignr_epi8(v340, v339, 12);
                                                v344 = _mm_alignr_epi8(v339, v338, 12);
                                                if ( v341 )
                                                  break;
                                                v345 = _mm_alignr_epi8(v338, v322, 12);
                                                v3 += 64;
                                                v346 = _mm_alignr_epi8(v322, v321, 12);
                                                v321 = v342;
                                                *(__m128i *)(v2 + 48) = v343;
                                                *(__m128i *)(v2 + 32) = v344;
                                                *(__m128i *)(v2 + 16) = v345;
                                                *(__m128i *)v2 = v346;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)v2 = *(_DWORD *)v3;
                                            v7 = 4;
                                            break;
                                          case 0xDu:
                                            v347 = *(__m128i *)(v3 - 13);
                                            v348 = *(__m128i *)(v3 + 3);
                                            while ( 1 )
                                            {
                                              v349 = _mm_cmpeq_epi8(v5, v348);
                                              v6 = _mm_movemask_epi8(v349);
                                              v350 = v348;
                                              if ( v6 )
                                                break;
                                              v351 = _mm_alignr_epi8(v348, v347, 13);
                                              v352 = v350;
                                              *(__m128i *)v2 = v351;
                                              v353 = *(__m128i *)(v3 + 19);
                                              v354 = _mm_cmpeq_epi8(v349, v353);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v354);
                                              v3 += 16;
                                              v355 = v353;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v353, v352, 13);
                                              v356 = *(__m128i *)(v3 + 19);
                                              v357 = v355;
                                              v358 = _mm_cmpeq_epi8(v354, v356);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v358);
                                              v3 += 16;
                                              v359 = v356;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v356, v357, 13);
                                              v360 = *(__m128i *)(v3 + 19);
                                              v5 = _mm_cmpeq_epi8(v358, v360);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v360, v359, 13);
                                              v361 = v3 + 19;
                                              v362 = (v3 + 19) & 0xFFFFFFC0;
                                              v363 = v361 - v362;
                                              v3 = v362 - 3;
                                              v2 = v2 + 16 - v363;
                                              v347 = *(__m128i *)(v3 - 13);
                                              while ( 1 )
                                              {
                                                v348 = *(__m128i *)(v3 + 3);
                                                v364 = *(__m128i *)(v3 + 19);
                                                v365 = *(__m128i *)(v3 + 35);
                                                v366 = *(__m128i *)(v3 + 51);
                                                v367 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v365, v366),
                                                             _mm_min_epu8(v364, v348)),
                                                           v5));
                                                v368 = v366;
                                                v369 = _mm_alignr_epi8(v366, v365, 13);
                                                v370 = _mm_alignr_epi8(v365, v364, 13);
                                                if ( v367 )
                                                  break;
                                                v371 = _mm_alignr_epi8(v364, v348, 13);
                                                v3 += 64;
                                                v372 = _mm_alignr_epi8(v348, v347, 13);
                                                v347 = v368;
                                                *(__m128i *)(v2 + 48) = v369;
                                                *(__m128i *)(v2 + 32) = v370;
                                                *(__m128i *)(v2 + 16) = v371;
                                                *(__m128i *)v2 = v372;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)(v2 - 1) = *(_DWORD *)(v3 - 1);
                                            v7 = 3;
                                            break;
                                          case 0xEu:
                                            v373 = *(__m128i *)(v3 - 14);
                                            v374 = *(__m128i *)(v3 + 2);
                                            while ( 1 )
                                            {
                                              v375 = _mm_cmpeq_epi8(v5, v374);
                                              v6 = _mm_movemask_epi8(v375);
                                              v376 = v374;
                                              if ( v6 )
                                                break;
                                              v377 = _mm_alignr_epi8(v374, v373, 14);
                                              v378 = v376;
                                              *(__m128i *)v2 = v377;
                                              v379 = *(__m128i *)(v3 + 18);
                                              v380 = _mm_cmpeq_epi8(v375, v379);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v380);
                                              v3 += 16;
                                              v381 = v379;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v379, v378, 14);
                                              v382 = *(__m128i *)(v3 + 18);
                                              v383 = v381;
                                              v384 = _mm_cmpeq_epi8(v380, v382);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v384);
                                              v3 += 16;
                                              v385 = v382;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v382, v383, 14);
                                              v386 = *(__m128i *)(v3 + 18);
                                              v5 = _mm_cmpeq_epi8(v384, v386);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v386, v385, 14);
                                              v387 = v3 + 18;
                                              v388 = (v3 + 18) & 0xFFFFFFC0;
                                              v389 = v387 - v388;
                                              v3 = v388 - 2;
                                              v2 = v2 + 16 - v389;
                                              v373 = *(__m128i *)(v3 - 14);
                                              while ( 1 )
                                              {
                                                v374 = *(__m128i *)(v3 + 2);
                                                v390 = *(__m128i *)(v3 + 18);
                                                v391 = *(__m128i *)(v3 + 34);
                                                v392 = *(__m128i *)(v3 + 50);
                                                v393 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v391, v392),
                                                             _mm_min_epu8(v390, v374)),
                                                           v5));
                                                v394 = v392;
                                                v395 = _mm_alignr_epi8(v392, v391, 14);
                                                v396 = _mm_alignr_epi8(v391, v390, 14);
                                                if ( v393 )
                                                  break;
                                                v397 = _mm_alignr_epi8(v390, v374, 14);
                                                v3 += 64;
                                                v398 = _mm_alignr_epi8(v374, v373, 14);
                                                v373 = v394;
                                                *(__m128i *)(v2 + 48) = v395;
                                                *(__m128i *)(v2 + 32) = v396;
                                                *(__m128i *)(v2 + 16) = v397;
                                                *(__m128i *)v2 = v398;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)(v2 - 2) = *(_DWORD *)(v3 - 2);
                                            v7 = 2;
                                            break;
                                          default:
                                            v399 = *(__m128i *)(v3 - 15);
                                            v400 = *(__m128i *)(v3 + 1);
                                            while ( 1 )
                                            {
                                              v401 = _mm_cmpeq_epi8(v5, v400);
                                              v6 = _mm_movemask_epi8(v401);
                                              v402 = v400;
                                              if ( v6 )
                                                break;
                                              v403 = _mm_alignr_epi8(v400, v399, 15);
                                              v404 = v402;
                                              *(__m128i *)v2 = v403;
                                              v405 = *(__m128i *)(v3 + 17);
                                              v406 = _mm_cmpeq_epi8(v401, v405);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v406);
                                              v3 += 16;
                                              v407 = v405;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v405, v404, 15);
                                              v408 = *(__m128i *)(v3 + 17);
                                              v409 = v407;
                                              v410 = _mm_cmpeq_epi8(v406, v408);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v410);
                                              v3 += 16;
                                              v411 = v408;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v408, v409, 15);
                                              v412 = *(__m128i *)(v3 + 17);
                                              v5 = _mm_cmpeq_epi8(v410, v412);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v412, v411, 15);
                                              v413 = v3 + 17;
                                              v414 = (v3 + 17) & 0xFFFFFFC0;
                                              v415 = v413 - v414;
                                              v3 = v414 - 1;
                                              v2 = v2 + 16 - v415;
                                              v399 = *(__m128i *)(v3 - 15);
                                              while ( 1 )
                                              {
                                                v400 = *(__m128i *)(v3 + 1);
                                                v416 = *(__m128i *)(v3 + 17);
                                                v417 = *(__m128i *)(v3 + 33);
                                                v418 = *(__m128i *)(v3 + 49);
                                                v419 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v417, v418),
                                                             _mm_min_epu8(v416, v400)),
                                                           v5));
                                                v420 = v418;
                                                v421 = _mm_alignr_epi8(v418, v417, 15);
                                                v422 = _mm_alignr_epi8(v417, v416, 15);
                                                if ( v419 )
                                                  break;
                                                v423 = _mm_alignr_epi8(v416, v400, 15);
                                                v3 += 64;
                                                v424 = _mm_alignr_epi8(v400, v399, 15);
                                                v399 = v420;
                                                *(__m128i *)(v2 + 48) = v421;
                                                *(__m128i *)(v2 + 32) = v422;
                                                *(__m128i *)(v2 + 16) = v423;
                                                *(__m128i *)v2 = v424;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)(v2 - 3) = *(_DWORD *)(v3 - 3);
                                            v7 = 1;
                                            break;
                                        }
                                      }
                                      else
                                      {
                                        switch ( v8 )
                                        {
                                          case 1u:
                                            v29 = *(__m128i *)(v3 - 1);
                                            v30 = *(__m128i *)(v3 + 15);
                                            while ( 1 )
                                            {
                                              v31 = _mm_cmpeq_epi8(v5, v30);
                                              v6 = _mm_movemask_epi8(v31);
                                              v32 = v30;
                                              if ( v6 )
                                                break;
                                              v33 = _mm_alignr_epi8(v30, v29, 1);
                                              v34 = v32;
                                              *(__m128i *)v2 = v33;
                                              v35 = *(__m128i *)(v3 + 31);
                                              v36 = _mm_cmpeq_epi8(v31, v35);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v36);
                                              v3 += 16;
                                              v37 = v35;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v35, v34, 1);
                                              v38 = *(__m128i *)(v3 + 31);
                                              v39 = v37;
                                              v40 = _mm_cmpeq_epi8(v36, v38);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v40);
                                              v3 += 16;
                                              v41 = v38;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v38, v39, 1);
                                              v42 = *(__m128i *)(v3 + 31);
                                              v5 = _mm_cmpeq_epi8(v40, v42);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v42, v41, 1);
                                              v43 = v3 + 31;
                                              v44 = (v3 + 31) & 0xFFFFFFC0;
                                              v45 = v43 - v44;
                                              v3 = v44 - 15;
                                              v2 = v2 + 16 - v45;
                                              v29 = *(__m128i *)(v3 - 1);
                                              while ( 1 )
                                              {
                                                v30 = *(__m128i *)(v3 + 15);
                                                v46 = *(__m128i *)(v3 + 31);
                                                v47 = *(__m128i *)(v3 + 47);
                                                v48 = *(__m128i *)(v3 + 63);
                                                v49 = _mm_movemask_epi8(
                                                        _mm_cmpeq_epi8(
                                                          _mm_min_epu8(_mm_min_epu8(v47, v48), _mm_min_epu8(v46, v30)),
                                                          v5));
                                                v50 = v48;
                                                v51 = _mm_alignr_epi8(v48, v47, 1);
                                                v52 = _mm_alignr_epi8(v47, v46, 1);
                                                if ( v49 )
                                                  break;
                                                v53 = _mm_alignr_epi8(v46, v30, 1);
                                                v3 += 64;
                                                v54 = _mm_alignr_epi8(v30, v29, 1);
                                                v29 = v50;
                                                *(__m128i *)(v2 + 48) = v51;
                                                *(__m128i *)(v2 + 32) = v52;
                                                *(__m128i *)(v2 + 16) = v53;
                                                *(__m128i *)v2 = v54;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)v2 = *(double *)v3;
                                            *(double *)(v2 + 7) = *(double *)(v3 + 7);
                                            v7 = 15;
                                            break;
                                          case 2u:
                                            v55 = *(__m128i *)(v3 - 2);
                                            v56 = *(__m128i *)(v3 + 14);
                                            while ( 1 )
                                            {
                                              v57 = _mm_cmpeq_epi8(v5, v56);
                                              v6 = _mm_movemask_epi8(v57);
                                              v58 = v56;
                                              if ( v6 )
                                                break;
                                              v59 = _mm_alignr_epi8(v56, v55, 2);
                                              v60 = v58;
                                              *(__m128i *)v2 = v59;
                                              v61 = *(__m128i *)(v3 + 30);
                                              v62 = _mm_cmpeq_epi8(v57, v61);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v62);
                                              v3 += 16;
                                              v63 = v61;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v61, v60, 2);
                                              v64 = *(__m128i *)(v3 + 30);
                                              v65 = v63;
                                              v66 = _mm_cmpeq_epi8(v62, v64);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v66);
                                              v3 += 16;
                                              v67 = v64;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v64, v65, 2);
                                              v68 = *(__m128i *)(v3 + 30);
                                              v5 = _mm_cmpeq_epi8(v66, v68);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v68, v67, 2);
                                              v69 = v3 + 30;
                                              v70 = (v3 + 30) & 0xFFFFFFC0;
                                              v71 = v69 - v70;
                                              v3 = v70 - 14;
                                              v2 = v2 + 16 - v71;
                                              v55 = *(__m128i *)(v3 - 2);
                                              while ( 1 )
                                              {
                                                v56 = *(__m128i *)(v3 + 14);
                                                v72 = *(__m128i *)(v3 + 30);
                                                v73 = *(__m128i *)(v3 + 46);
                                                v74 = *(__m128i *)(v3 + 62);
                                                v75 = _mm_movemask_epi8(
                                                        _mm_cmpeq_epi8(
                                                          _mm_min_epu8(_mm_min_epu8(v73, v74), _mm_min_epu8(v72, v56)),
                                                          v5));
                                                v76 = v74;
                                                v77 = _mm_alignr_epi8(v74, v73, 2);
                                                v78 = _mm_alignr_epi8(v73, v72, 2);
                                                if ( v75 )
                                                  break;
                                                v79 = _mm_alignr_epi8(v72, v56, 2);
                                                v3 += 64;
                                                v80 = _mm_alignr_epi8(v56, v55, 2);
                                                v55 = v76;
                                                *(__m128i *)(v2 + 48) = v77;
                                                *(__m128i *)(v2 + 32) = v78;
                                                *(__m128i *)(v2 + 16) = v79;
                                                *(__m128i *)v2 = v80;
                                                v2 += 64;
                                              }
                                            }
                                            v81 = *(double *)(v3 + 6);
                                            *(double *)v2 = *(double *)v3;
                                            *(double *)(v2 + 6) = v81;
                                            v7 = 14;
                                            break;
                                          case 3u:
                                            v82 = *(__m128i *)(v3 - 3);
                                            v83 = *(__m128i *)(v3 + 13);
                                            while ( 1 )
                                            {
                                              v84 = _mm_cmpeq_epi8(v5, v83);
                                              v6 = _mm_movemask_epi8(v84);
                                              v85 = v83;
                                              if ( v6 )
                                                break;
                                              v86 = _mm_alignr_epi8(v83, v82, 3);
                                              v87 = v85;
                                              *(__m128i *)v2 = v86;
                                              v88 = *(__m128i *)(v3 + 29);
                                              v89 = _mm_cmpeq_epi8(v84, v88);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v89);
                                              v3 += 16;
                                              v90 = v88;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v88, v87, 3);
                                              v91 = *(__m128i *)(v3 + 29);
                                              v92 = v90;
                                              v93 = _mm_cmpeq_epi8(v89, v91);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v93);
                                              v3 += 16;
                                              v94 = v91;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v91, v92, 3);
                                              v95 = *(__m128i *)(v3 + 29);
                                              v5 = _mm_cmpeq_epi8(v93, v95);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v95, v94, 3);
                                              v96 = v3 + 29;
                                              v97 = (v3 + 29) & 0xFFFFFFC0;
                                              v98 = v96 - v97;
                                              v3 = v97 - 13;
                                              v2 = v2 + 16 - v98;
                                              v82 = *(__m128i *)(v3 - 3);
                                              while ( 1 )
                                              {
                                                v83 = *(__m128i *)(v3 + 13);
                                                v99 = *(__m128i *)(v3 + 29);
                                                v100 = *(__m128i *)(v3 + 45);
                                                v101 = *(__m128i *)(v3 + 61);
                                                v102 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v100, v101),
                                                             _mm_min_epu8(v99, v83)),
                                                           v5));
                                                v103 = v101;
                                                v104 = _mm_alignr_epi8(v101, v100, 3);
                                                v105 = _mm_alignr_epi8(v100, v99, 3);
                                                if ( v102 )
                                                  break;
                                                v106 = _mm_alignr_epi8(v99, v83, 3);
                                                v3 += 64;
                                                v107 = _mm_alignr_epi8(v83, v82, 3);
                                                v82 = v103;
                                                *(__m128i *)(v2 + 48) = v104;
                                                *(__m128i *)(v2 + 32) = v105;
                                                *(__m128i *)(v2 + 16) = v106;
                                                *(__m128i *)v2 = v107;
                                                v2 += 64;
                                              }
                                            }
                                            v108 = *(double *)(v3 + 5);
                                            *(double *)v2 = *(double *)v3;
                                            *(double *)(v2 + 5) = v108;
                                            v7 = 13;
                                            break;
                                          case 4u:
                                            v109 = *(__m128i *)(v3 - 4);
                                            v110 = *(__m128i *)(v3 + 12);
                                            while ( 1 )
                                            {
                                              v111 = _mm_cmpeq_epi8(v5, v110);
                                              v6 = _mm_movemask_epi8(v111);
                                              v112 = v110;
                                              if ( v6 )
                                                break;
                                              v113 = _mm_alignr_epi8(v110, v109, 4);
                                              v114 = v112;
                                              *(__m128i *)v2 = v113;
                                              v115 = *(__m128i *)(v3 + 28);
                                              v116 = _mm_cmpeq_epi8(v111, v115);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v116);
                                              v3 += 16;
                                              v117 = v115;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v115, v114, 4);
                                              v118 = *(__m128i *)(v3 + 28);
                                              v119 = v117;
                                              v120 = _mm_cmpeq_epi8(v116, v118);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v120);
                                              v3 += 16;
                                              v121 = v118;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v118, v119, 4);
                                              v122 = *(__m128i *)(v3 + 28);
                                              v5 = _mm_cmpeq_epi8(v120, v122);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v122, v121, 4);
                                              v123 = v3 + 28;
                                              v124 = (v3 + 28) & 0xFFFFFFC0;
                                              v125 = v123 - v124;
                                              v3 = v124 - 12;
                                              v2 = v2 + 16 - v125;
                                              v109 = *(__m128i *)(v3 - 4);
                                              while ( 1 )
                                              {
                                                v110 = *(__m128i *)(v3 + 12);
                                                v126 = *(__m128i *)(v3 + 28);
                                                v127 = *(__m128i *)(v3 + 44);
                                                v128 = *(__m128i *)(v3 + 60);
                                                v129 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v127, v128),
                                                             _mm_min_epu8(v126, v110)),
                                                           v5));
                                                v130 = v128;
                                                v131 = _mm_alignr_epi8(v128, v127, 4);
                                                v132 = _mm_alignr_epi8(v127, v126, 4);
                                                if ( v129 )
                                                  break;
                                                v133 = _mm_alignr_epi8(v126, v110, 4);
                                                v3 += 64;
                                                v134 = _mm_alignr_epi8(v110, v109, 4);
                                                v109 = v130;
                                                *(__m128i *)(v2 + 48) = v131;
                                                *(__m128i *)(v2 + 32) = v132;
                                                *(__m128i *)(v2 + 16) = v133;
                                                *(__m128i *)v2 = v134;
                                                v2 += 64;
                                              }
                                            }
                                            v135 = *(_DWORD *)(v3 + 8);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 8) = v135;
                                            v7 = 12;
                                            break;
                                          case 5u:
                                            v136 = *(__m128i *)(v3 - 5);
                                            v137 = *(__m128i *)(v3 + 11);
                                            while ( 1 )
                                            {
                                              v138 = _mm_cmpeq_epi8(v5, v137);
                                              v6 = _mm_movemask_epi8(v138);
                                              v139 = v137;
                                              if ( v6 )
                                                break;
                                              v140 = _mm_alignr_epi8(v137, v136, 5);
                                              v141 = v139;
                                              *(__m128i *)v2 = v140;
                                              v142 = *(__m128i *)(v3 + 27);
                                              v143 = _mm_cmpeq_epi8(v138, v142);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v143);
                                              v3 += 16;
                                              v144 = v142;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v142, v141, 5);
                                              v145 = *(__m128i *)(v3 + 27);
                                              v146 = v144;
                                              v147 = _mm_cmpeq_epi8(v143, v145);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v147);
                                              v3 += 16;
                                              v148 = v145;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v145, v146, 5);
                                              v149 = *(__m128i *)(v3 + 27);
                                              v5 = _mm_cmpeq_epi8(v147, v149);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v149, v148, 5);
                                              v150 = v3 + 27;
                                              v151 = (v3 + 27) & 0xFFFFFFC0;
                                              v152 = v150 - v151;
                                              v3 = v151 - 11;
                                              v2 = v2 + 16 - v152;
                                              v136 = *(__m128i *)(v3 - 5);
                                              while ( 1 )
                                              {
                                                v137 = *(__m128i *)(v3 + 11);
                                                v153 = *(__m128i *)(v3 + 27);
                                                v154 = *(__m128i *)(v3 + 43);
                                                v155 = *(__m128i *)(v3 + 59);
                                                v156 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v154, v155),
                                                             _mm_min_epu8(v153, v137)),
                                                           v5));
                                                v157 = v155;
                                                v158 = _mm_alignr_epi8(v155, v154, 5);
                                                v159 = _mm_alignr_epi8(v154, v153, 5);
                                                if ( v156 )
                                                  break;
                                                v160 = _mm_alignr_epi8(v153, v137, 5);
                                                v3 += 64;
                                                v161 = _mm_alignr_epi8(v137, v136, 5);
                                                v136 = v157;
                                                *(__m128i *)(v2 + 48) = v158;
                                                *(__m128i *)(v2 + 32) = v159;
                                                *(__m128i *)(v2 + 16) = v160;
                                                *(__m128i *)v2 = v161;
                                                v2 += 64;
                                              }
                                            }
                                            v162 = *(_DWORD *)(v3 + 7);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 7) = v162;
                                            v7 = 11;
                                            break;
                                          case 6u:
                                            v163 = *(__m128i *)(v3 - 6);
                                            v164 = *(__m128i *)(v3 + 10);
                                            while ( 1 )
                                            {
                                              v165 = _mm_cmpeq_epi8(v5, v164);
                                              v6 = _mm_movemask_epi8(v165);
                                              v166 = v164;
                                              if ( v6 )
                                                break;
                                              v167 = _mm_alignr_epi8(v164, v163, 6);
                                              v168 = v166;
                                              *(__m128i *)v2 = v167;
                                              v169 = *(__m128i *)(v3 + 26);
                                              v170 = _mm_cmpeq_epi8(v165, v169);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v170);
                                              v3 += 16;
                                              v171 = v169;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v169, v168, 6);
                                              v172 = *(__m128i *)(v3 + 26);
                                              v173 = v171;
                                              v174 = _mm_cmpeq_epi8(v170, v172);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v174);
                                              v3 += 16;
                                              v175 = v172;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v172, v173, 6);
                                              v176 = *(__m128i *)(v3 + 26);
                                              v5 = _mm_cmpeq_epi8(v174, v176);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v176, v175, 6);
                                              v177 = v3 + 26;
                                              v178 = (v3 + 26) & 0xFFFFFFC0;
                                              v179 = v177 - v178;
                                              v3 = v178 - 10;
                                              v2 = v2 + 16 - v179;
                                              v163 = *(__m128i *)(v3 - 6);
                                              while ( 1 )
                                              {
                                                v164 = *(__m128i *)(v3 + 10);
                                                v180 = *(__m128i *)(v3 + 26);
                                                v181 = *(__m128i *)(v3 + 42);
                                                v182 = *(__m128i *)(v3 + 58);
                                                v183 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v181, v182),
                                                             _mm_min_epu8(v180, v164)),
                                                           v5));
                                                v184 = v182;
                                                v185 = _mm_alignr_epi8(v182, v181, 6);
                                                v186 = _mm_alignr_epi8(v181, v180, 6);
                                                if ( v183 )
                                                  break;
                                                v187 = _mm_alignr_epi8(v180, v164, 6);
                                                v3 += 64;
                                                v188 = _mm_alignr_epi8(v164, v163, 6);
                                                v163 = v184;
                                                *(__m128i *)(v2 + 48) = v185;
                                                *(__m128i *)(v2 + 32) = v186;
                                                *(__m128i *)(v2 + 16) = v187;
                                                *(__m128i *)v2 = v188;
                                                v2 += 64;
                                              }
                                            }
                                            v189 = *(_DWORD *)(v3 + 6);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 6) = v189;
                                            v7 = 10;
                                            break;
                                          default:
                                            v190 = *(__m128i *)(v3 - 7);
                                            v191 = *(__m128i *)(v3 + 9);
                                            while ( 1 )
                                            {
                                              v192 = _mm_cmpeq_epi8(v5, v191);
                                              v6 = _mm_movemask_epi8(v192);
                                              v193 = v191;
                                              if ( v6 )
                                                break;
                                              v194 = _mm_alignr_epi8(v191, v190, 7);
                                              v195 = v193;
                                              *(__m128i *)v2 = v194;
                                              v196 = *(__m128i *)(v3 + 25);
                                              v197 = _mm_cmpeq_epi8(v192, v196);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v197);
                                              v3 += 16;
                                              v198 = v196;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v196, v195, 7);
                                              v199 = *(__m128i *)(v3 + 25);
                                              v200 = v198;
                                              v201 = _mm_cmpeq_epi8(v197, v199);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v201);
                                              v3 += 16;
                                              v202 = v199;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v199, v200, 7);
                                              v203 = *(__m128i *)(v3 + 25);
                                              v5 = _mm_cmpeq_epi8(v201, v203);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v203, v202, 7);
                                              v204 = v3 + 25;
                                              v205 = (v3 + 25) & 0xFFFFFFC0;
                                              v206 = v204 - v205;
                                              v3 = v205 - 9;
                                              v2 = v2 + 16 - v206;
                                              v190 = *(__m128i *)(v3 - 7);
                                              while ( 1 )
                                              {
                                                v191 = *(__m128i *)(v3 + 9);
                                                v207 = *(__m128i *)(v3 + 25);
                                                v208 = *(__m128i *)(v3 + 41);
                                                v209 = *(__m128i *)(v3 + 57);
                                                v210 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v208, v209),
                                                             _mm_min_epu8(v207, v191)),
                                                           v5));
                                                v211 = v209;
                                                v212 = _mm_alignr_epi8(v209, v208, 7);
                                                v213 = _mm_alignr_epi8(v208, v207, 7);
                                                if ( v210 )
                                                  break;
                                                v214 = _mm_alignr_epi8(v207, v191, 7);
                                                v3 += 64;
                                                v215 = _mm_alignr_epi8(v191, v190, 7);
                                                v190 = v211;
                                                *(__m128i *)(v2 + 48) = v212;
                                                *(__m128i *)(v2 + 32) = v213;
                                                *(__m128i *)(v2 + 16) = v214;
                                                *(__m128i *)v2 = v215;
                                                v2 += 64;
                                              }
                                            }
                                            v216 = *(_DWORD *)(v3 + 5);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 5) = v216;
                                            v7 = 9;
                                            break;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      v9 = *(__m128i *)(v3 + 16);
                                      *(_OWORD *)v2 = *(_OWORD *)v3;
                                      v10 = _mm_cmpeq_epi8(v5, v9);
                                      v6 = _mm_movemask_epi8(v10);
                                      v7 = 16;
                                      if ( !v6 )
                                      {
                                        v11 = *(__m128i *)(v3 + 32);
                                        *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x10) = v9;
                                        v12 = _mm_cmpeq_epi8(v10, v11);
                                        v6 = _mm_movemask_epi8(v12);
                                        v7 = 32;
                                        if ( !v6 )
                                        {
                                          v13 = *(__m128i *)(v3 + 48);
                                          *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x20) = v11;
                                          v14 = _mm_cmpeq_epi8(v12, v13);
                                          v6 = _mm_movemask_epi8(v14);
                                          v7 = 48;
                                          if ( !v6 )
                                          {
                                            v15 = *(__m128i *)(v3 + 64);
                                            *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x30) = v13;
                                            v16 = _mm_cmpeq_epi8(v14, v15);
                                            v6 = _mm_movemask_epi8(v16);
                                            v7 = 64;
                                            if ( !v6 )
                                            {
                                              v17 = *(__m128i *)(v3 + 80);
                                              *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x40) = v15;
                                              v18 = _mm_cmpeq_epi8(v16, v17);
                                              v6 = _mm_movemask_epi8(v18);
                                              v7 = 80;
                                              if ( !v6 )
                                              {
                                                v19 = *(__m128i *)(v3 + 96);
                                                *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x50) = v17;
                                                v20 = _mm_cmpeq_epi8(v18, v19);
                                                v6 = _mm_movemask_epi8(v20);
                                                v7 = 96;
                                                if ( !v6 )
                                                {
                                                  *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x60) = v19;
                                                  v3 = (v3 + 112) & 0xFFFFFFC0;
                                                  v2 = v3 - (a2 - a1);
                                                  v7 = -64;
                                                  while ( 1 )
                                                  {
                                                    v21 = *(__m128i *)v3;
                                                    v22 = *(__m128i *)(v3 + 16);
                                                    v23 = *(__m128i *)(v3 + 32);
                                                    v24 = *(__m128i *)(v3 + 48);
                                                    v2 += 64;
                                                    v25 = _mm_cmpeq_epi8(
                                                            _mm_min_epu8(
                                                              _mm_min_epu8(v23, v24),
                                                              _mm_min_epu8(*(__m128i *)v3, v22)),
                                                            v20);
                                                    v3 += 64;
                                                    if ( _mm_movemask_epi8(v25) )
                                                      break;
                                                    *(__m128i *)(v2 - 64) = v21;
                                                    *(__m128i *)(v2 - 48) = v22;
                                                    *(__m128i *)(v2 - 32) = v23;
                                                    *(__m128i *)(v2 - 16) = v24;
                                                  }
                                                  v26 = _mm_cmpeq_epi8(v20, v21);
                                                  v6 = _mm_movemask_epi8(v26);
                                                  if ( !v6 )
                                                  {
                                                    v27 = _mm_cmpeq_epi8(v26, v22);
                                                    v6 = _mm_movemask_epi8(v27);
                                                    *(__m128i *)(v2 - 64) = v21;
                                                    v7 = -48;
                                                    if ( !v6 )
                                                    {
                                                      v28 = _mm_cmpeq_epi8(v27, v23);
                                                      v6 = _mm_movemask_epi8(v28);
                                                      *(__m128i *)(v2 - 48) = v22;
                                                      v7 = -32;
                                                      if ( !v6 )
                                                      {
                                                        *(__m128i *)(v2 - 32) = v23;
                                                        LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v28, v24));
                                                        v7 = -16;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  v425 = v7 + v2;
                                  v426 = v7 + v3;
                                  if ( (_BYTE)v6 )
                                  {
                                    if ( (v6 & 0xF) != 0 )
                                    {
                                      if ( (v6 & 1) != 0 )
                                      {
                                        *(_BYTE *)v425 = *(_BYTE *)v426;
                                        return a1;
                                      }
                                      else if ( (v6 & 2) != 0 )
                                      {
                                        *(_WORD *)v425 = *(_WORD *)v426;
                                        return a1;
                                      }
                                      else
                                      {
                                        if ( (v6 & 4) != 0 )
                                        {
                                          *(_WORD *)v425 = *(_WORD *)v426;
                                          *(_BYTE *)(v425 + 2) = *(_BYTE *)(v426 + 2);
                                        }
                                        else
                                        {
                                          *(_DWORD *)v425 = *(_DWORD *)v426;
                                        }
                                        return a1;
                                      }
                                    }
                                    else if ( (v6 & 0x10) != 0 )
                                    {
                                      *(_DWORD *)v425 = *(_DWORD *)v426;
                                      *(_BYTE *)(v425 + 4) = *(_BYTE *)(v426 + 4);
                                      return a1;
                                    }
                                    else if ( (v6 & 0x20) != 0 )
                                    {
                                      *(_DWORD *)v425 = *(_DWORD *)v426;
                                      *(_WORD *)(v425 + 4) = *(_WORD *)(v426 + 4);
                                      return a1;
                                    }
                                    else
                                    {
                                      if ( (v6 & 0x40) != 0 )
                                      {
                                        *(_DWORD *)v425 = *(_DWORD *)v426;
                                        *(_DWORD *)(v425 + 3) = *(_DWORD *)(v426 + 3);
                                      }
                                      else
                                      {
                                        *(double *)v425 = *(double *)v426;
                                      }
                                      return a1;
                                    }
                                  }
                                  else if ( (v6 & 0xF00) != 0 )
                                  {
                                    if ( (v6 & 0x100) != 0 )
                                    {
                                      v429 = *(_BYTE *)(v426 + 8);
                                      *(double *)v425 = *(double *)v426;
                                      *(_BYTE *)(v425 + 8) = v429;
                                      return a1;
                                    }
                                    else if ( (v6 & 0x200) != 0 )
                                    {
                                      v430 = *(_WORD *)(v426 + 8);
                                      *(double *)v425 = *(double *)v426;
                                      *(_WORD *)(v425 + 8) = v430;
                                      return a1;
                                    }
                                    else
                                    {
                                      if ( (v6 & 0x400) != 0 )
                                      {
                                        v431 = *(_DWORD *)(v426 + 7);
                                        *(double *)v425 = *(double *)v426;
                                        *(_DWORD *)(v425 + 7) = v431;
                                      }
                                      else
                                      {
                                        v428 = *(_DWORD *)(v426 + 8);
                                        *(double *)v425 = *(double *)v426;
                                        *(_DWORD *)(v425 + 8) = v428;
                                      }
                                      return a1;
                                    }
                                  }
                                  else if ( (v6 & 0x1000) != 0 )
                                  {
                                    v432 = *(double *)(v426 + 5);
                                    *(double *)v425 = *(double *)v426;
                                    *(double *)(v425 + 5) = v432;
                                    return a1;
                                  }
                                  else if ( (v6 & 0x2000) != 0 )
                                  {
                                    v433 = *(double *)(v426 + 6);
                                    *(double *)v425 = *(double *)v426;
                                    *(double *)(v425 + 6) = v433;
                                    return a1;
                                  }
                                  else
                                  {
                                    if ( (v6 & 0x4000) != 0 )
                                    {
                                      v434 = *(double *)(v426 + 7);
                                      *(double *)v425 = *(double *)v426;
                                      *(double *)(v425 + 7) = v434;
                                    }
                                    else
                                    {
                                      *(__m128i *)v425 = _mm_loadu_si128((const __m128i *)v426);
                                    }
                                    return a1;
                                  }
                                }
                                else
                                {
                                  *(__m128i *)a1 = _mm_loadu_si128((const __m128i *)a2);
                                  return a1;
                                }
                              }
                              else
                              {
                                v441 = *(double *)(a2 + 7);
                                *(double *)a1 = *(double *)a2;
                                *(double *)(a1 + 7) = v441;
                                return a1;
                              }
                            }
                            else
                            {
                              v440 = *(double *)(a2 + 6);
                              *(double *)a1 = *(double *)a2;
                              *(double *)(a1 + 6) = v440;
                              return a1;
                            }
                          }
                          else
                          {
                            v439 = *(double *)(a2 + 5);
                            *(double *)a1 = *(double *)a2;
                            *(double *)(a1 + 5) = v439;
                            return a1;
                          }
                        }
                        else
                        {
                          v438 = *(_DWORD *)(a2 + 8);
                          *(double *)a1 = *(double *)a2;
                          *(_DWORD *)(a1 + 8) = v438;
                          return a1;
                        }
                      }
                      else
                      {
                        v437 = *(_DWORD *)(a2 + 7);
                        *(double *)a1 = *(double *)a2;
                        *(_DWORD *)(a1 + 7) = v437;
                        return a1;
                      }
                    }
                    else
                    {
                      v436 = *(_WORD *)(a2 + 8);
                      *(double *)a1 = *(double *)a2;
                      *(_WORD *)(a1 + 8) = v436;
                      return a1;
                    }
                  }
                  else
                  {
                    v435 = *(_BYTE *)(a2 + 8);
                    *(double *)a1 = *(double *)a2;
                    *(_BYTE *)(a1 + 8) = v435;
                    return a1;
                  }
                }
                else
                {
                  *(double *)a1 = *(double *)a2;
                  return a1;
                }
              }
              else
              {
                *(_DWORD *)a1 = *(_DWORD *)a2;
                *(_DWORD *)(a1 + 3) = *(_DWORD *)(a2 + 3);
                return a1;
              }
            }
            else
            {
              *(_DWORD *)a1 = *(_DWORD *)a2;
              *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
              return a1;
            }
          }
          else
          {
            *(_DWORD *)a1 = *(_DWORD *)a2;
            *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
            return a1;
          }
        }
        else
        {
          *(_DWORD *)a1 = *(_DWORD *)a2;
          return a1;
        }
      }
      else
      {
        *(_WORD *)a1 = *(_WORD *)a2;
        *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
        return a1;
      }
    }
    else
    {
      *(_WORD *)a1 = *(_WORD *)a2;
      return a1;
    }
  }
  else
  {
    *(_BYTE *)a1 = *(_BYTE *)a2;
    return a1;
  }
}

//----- (08074290) --------------------------------------------------------
unsigned int __cdecl _strncpy_ssse3(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // edx
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  __m128i *v6; // esi
  __m128i v7; // xmm0
  int v8; // eax
  int v9; // esi
  char v10; // cc
  unsigned int v11; // ebx
  unsigned int v12; // eax
  unsigned int v13; // eax
  int v14; // esi
  __m128i v15; // xmm2
  __m128i v16; // xmm0
  __m128i v17; // xmm3
  __m128i v18; // xmm0
  __m128i v19; // xmm4
  __m128i v20; // xmm0
  __m128i v21; // xmm1
  __m128i v22; // xmm0
  __m128i v23; // xmm2
  __m128i v24; // xmm0
  __m128i v25; // xmm3
  __m128i v26; // xmm0
  unsigned int v27; // eax
  unsigned int v28; // eax
  unsigned int v29; // ebx
  __m128i v30; // xmm4
  __m128i v31; // xmm5
  __m128i v32; // xmm6
  __m128i v33; // xmm7
  __m128i v34; // xmm3
  int v35; // eax
  __m128i v36; // xmm0
  __m128i v37; // xmm0
  __m128i v38; // xmm0
  __m128i v39; // xmm1
  __m128i v40; // xmm2
  __m128i v41; // xmm0
  __m128i v42; // xmm3
  __m128i v43; // xmm2
  __m128i v44; // xmm1
  __m128i v45; // xmm2
  __m128i v46; // xmm0
  __m128i v47; // xmm3
  __m128i v48; // xmm2
  __m128i v49; // xmm1
  __m128i v50; // xmm0
  __m128i v51; // xmm3
  __m128i v52; // xmm2
  unsigned int v53; // eax
  unsigned int v54; // ecx
  unsigned int v55; // eax
  __m128i v56; // xmm3
  __m128i v57; // xmm4
  __m128i v58; // xmm5
  int v59; // eax
  __m128i v60; // xmm7
  __m128i v61; // xmm5
  __m128i v62; // xmm4
  __m128i v63; // xmm3
  __m128i v64; // xmm2
  __m128i v65; // xmm1
  __m128i v66; // xmm2
  __m128i v67; // xmm0
  __m128i v68; // xmm3
  __m128i v69; // xmm2
  __m128i v70; // xmm1
  __m128i v71; // xmm2
  __m128i v72; // xmm0
  __m128i v73; // xmm3
  __m128i v74; // xmm2
  __m128i v75; // xmm1
  __m128i v76; // xmm0
  __m128i v77; // xmm3
  __m128i v78; // xmm2
  unsigned int v79; // eax
  unsigned int v80; // ecx
  unsigned int v81; // eax
  __m128i v82; // xmm3
  __m128i v83; // xmm4
  __m128i v84; // xmm5
  int v85; // eax
  __m128i v86; // xmm7
  __m128i v87; // xmm5
  __m128i v88; // xmm4
  __m128i v89; // xmm3
  __m128i v90; // xmm2
  double v91; // xmm1_8
  __m128i v92; // xmm1
  __m128i v93; // xmm2
  __m128i v94; // xmm0
  __m128i v95; // xmm3
  __m128i v96; // xmm2
  __m128i v97; // xmm1
  __m128i v98; // xmm2
  __m128i v99; // xmm0
  __m128i v100; // xmm3
  __m128i v101; // xmm2
  __m128i v102; // xmm1
  __m128i v103; // xmm0
  __m128i v104; // xmm3
  __m128i v105; // xmm2
  unsigned int v106; // eax
  unsigned int v107; // ecx
  unsigned int v108; // eax
  __m128i v109; // xmm3
  __m128i v110; // xmm4
  __m128i v111; // xmm5
  int v112; // eax
  __m128i v113; // xmm7
  __m128i v114; // xmm5
  __m128i v115; // xmm4
  __m128i v116; // xmm3
  __m128i v117; // xmm2
  double v118; // xmm1_8
  __m128i v119; // xmm1
  __m128i v120; // xmm2
  __m128i v121; // xmm0
  __m128i v122; // xmm3
  __m128i v123; // xmm2
  __m128i v124; // xmm1
  __m128i v125; // xmm2
  __m128i v126; // xmm0
  __m128i v127; // xmm3
  __m128i v128; // xmm2
  __m128i v129; // xmm1
  __m128i v130; // xmm0
  __m128i v131; // xmm3
  __m128i v132; // xmm2
  unsigned int v133; // eax
  unsigned int v134; // ecx
  unsigned int v135; // eax
  __m128i v136; // xmm3
  __m128i v137; // xmm4
  __m128i v138; // xmm5
  int v139; // eax
  __m128i v140; // xmm7
  __m128i v141; // xmm5
  __m128i v142; // xmm4
  __m128i v143; // xmm3
  __m128i v144; // xmm2
  int v145; // esi
  __m128i v146; // xmm1
  __m128i v147; // xmm2
  __m128i v148; // xmm0
  __m128i v149; // xmm3
  __m128i v150; // xmm2
  __m128i v151; // xmm1
  __m128i v152; // xmm2
  __m128i v153; // xmm0
  __m128i v154; // xmm3
  __m128i v155; // xmm2
  __m128i v156; // xmm1
  __m128i v157; // xmm0
  __m128i v158; // xmm3
  __m128i v159; // xmm2
  unsigned int v160; // eax
  unsigned int v161; // ecx
  unsigned int v162; // eax
  __m128i v163; // xmm3
  __m128i v164; // xmm4
  __m128i v165; // xmm5
  int v166; // eax
  __m128i v167; // xmm7
  __m128i v168; // xmm5
  __m128i v169; // xmm4
  __m128i v170; // xmm3
  __m128i v171; // xmm2
  int v172; // esi
  __m128i v173; // xmm1
  __m128i v174; // xmm2
  __m128i v175; // xmm0
  __m128i v176; // xmm3
  __m128i v177; // xmm2
  __m128i v178; // xmm1
  __m128i v179; // xmm2
  __m128i v180; // xmm0
  __m128i v181; // xmm3
  __m128i v182; // xmm2
  __m128i v183; // xmm1
  __m128i v184; // xmm0
  __m128i v185; // xmm3
  __m128i v186; // xmm2
  unsigned int v187; // eax
  unsigned int v188; // ecx
  unsigned int v189; // eax
  __m128i v190; // xmm3
  __m128i v191; // xmm4
  __m128i v192; // xmm5
  int v193; // eax
  __m128i v194; // xmm7
  __m128i v195; // xmm5
  __m128i v196; // xmm4
  __m128i v197; // xmm3
  __m128i v198; // xmm2
  int v199; // esi
  __m128i v200; // xmm1
  __m128i v201; // xmm2
  __m128i v202; // xmm0
  __m128i v203; // xmm3
  __m128i v204; // xmm2
  __m128i v205; // xmm1
  __m128i v206; // xmm2
  __m128i v207; // xmm0
  __m128i v208; // xmm3
  __m128i v209; // xmm2
  __m128i v210; // xmm1
  __m128i v211; // xmm0
  __m128i v212; // xmm3
  __m128i v213; // xmm2
  unsigned int v214; // eax
  unsigned int v215; // ecx
  unsigned int v216; // eax
  __m128i v217; // xmm3
  __m128i v218; // xmm4
  __m128i v219; // xmm5
  int v220; // eax
  __m128i v221; // xmm7
  __m128i v222; // xmm5
  __m128i v223; // xmm4
  __m128i v224; // xmm3
  __m128i v225; // xmm2
  int v226; // esi
  __m128i v227; // xmm1
  __m128i v228; // xmm2
  __m128i v229; // xmm0
  __m128i v230; // xmm3
  __m128i v231; // xmm2
  __m128i v232; // xmm1
  __m128i v233; // xmm2
  __m128i v234; // xmm0
  __m128i v235; // xmm3
  __m128i v236; // xmm2
  __m128i v237; // xmm1
  __m128i v238; // xmm0
  __m128i v239; // xmm3
  __m128i v240; // xmm2
  unsigned int v241; // eax
  unsigned int v242; // ecx
  unsigned int v243; // eax
  __m128i v244; // xmm3
  __m128i v245; // xmm4
  __m128i v246; // xmm5
  int v247; // eax
  __m128i v248; // xmm7
  __m128i v249; // xmm5
  __m128i v250; // xmm4
  __m128i v251; // xmm3
  __m128i v252; // xmm2
  __m128i v253; // xmm1
  __m128i v254; // xmm2
  __m128i v255; // xmm0
  __m128i v256; // xmm3
  __m128i v257; // xmm2
  __m128i v258; // xmm1
  __m128i v259; // xmm2
  __m128i v260; // xmm0
  __m128i v261; // xmm3
  __m128i v262; // xmm2
  __m128i v263; // xmm1
  __m128i v264; // xmm0
  __m128i v265; // xmm3
  __m128i v266; // xmm2
  unsigned int v267; // eax
  unsigned int v268; // ecx
  unsigned int v269; // eax
  __m128i v270; // xmm3
  __m128i v271; // xmm4
  __m128i v272; // xmm5
  int v273; // eax
  __m128i v274; // xmm7
  __m128i v275; // xmm5
  __m128i v276; // xmm4
  __m128i v277; // xmm3
  __m128i v278; // xmm2
  __m128i v279; // xmm1
  __m128i v280; // xmm2
  __m128i v281; // xmm0
  __m128i v282; // xmm3
  __m128i v283; // xmm2
  __m128i v284; // xmm1
  __m128i v285; // xmm2
  __m128i v286; // xmm0
  __m128i v287; // xmm3
  __m128i v288; // xmm2
  __m128i v289; // xmm1
  __m128i v290; // xmm0
  __m128i v291; // xmm3
  __m128i v292; // xmm2
  unsigned int v293; // eax
  unsigned int v294; // ecx
  unsigned int v295; // eax
  __m128i v296; // xmm3
  __m128i v297; // xmm4
  __m128i v298; // xmm5
  int v299; // eax
  __m128i v300; // xmm7
  __m128i v301; // xmm5
  __m128i v302; // xmm4
  __m128i v303; // xmm3
  __m128i v304; // xmm2
  __m128i v305; // xmm1
  __m128i v306; // xmm2
  __m128i v307; // xmm0
  __m128i v308; // xmm3
  __m128i v309; // xmm2
  __m128i v310; // xmm1
  __m128i v311; // xmm2
  __m128i v312; // xmm0
  __m128i v313; // xmm3
  __m128i v314; // xmm2
  __m128i v315; // xmm1
  __m128i v316; // xmm0
  __m128i v317; // xmm3
  __m128i v318; // xmm2
  unsigned int v319; // eax
  unsigned int v320; // ecx
  unsigned int v321; // eax
  __m128i v322; // xmm3
  __m128i v323; // xmm4
  __m128i v324; // xmm5
  int v325; // eax
  __m128i v326; // xmm7
  __m128i v327; // xmm5
  __m128i v328; // xmm4
  __m128i v329; // xmm3
  __m128i v330; // xmm2
  __m128i v331; // xmm1
  __m128i v332; // xmm2
  __m128i v333; // xmm0
  __m128i v334; // xmm3
  __m128i v335; // xmm2
  __m128i v336; // xmm1
  __m128i v337; // xmm2
  __m128i v338; // xmm0
  __m128i v339; // xmm3
  __m128i v340; // xmm2
  __m128i v341; // xmm1
  __m128i v342; // xmm0
  __m128i v343; // xmm3
  __m128i v344; // xmm2
  unsigned int v345; // eax
  unsigned int v346; // ecx
  unsigned int v347; // eax
  __m128i v348; // xmm3
  __m128i v349; // xmm4
  __m128i v350; // xmm5
  int v351; // eax
  __m128i v352; // xmm7
  __m128i v353; // xmm5
  __m128i v354; // xmm4
  __m128i v355; // xmm3
  __m128i v356; // xmm2
  __m128i v357; // xmm1
  __m128i v358; // xmm2
  __m128i v359; // xmm0
  __m128i v360; // xmm3
  __m128i v361; // xmm2
  __m128i v362; // xmm1
  __m128i v363; // xmm2
  __m128i v364; // xmm0
  __m128i v365; // xmm3
  __m128i v366; // xmm2
  __m128i v367; // xmm1
  __m128i v368; // xmm0
  __m128i v369; // xmm3
  __m128i v370; // xmm2
  unsigned int v371; // eax
  unsigned int v372; // ecx
  unsigned int v373; // eax
  __m128i v374; // xmm3
  __m128i v375; // xmm4
  __m128i v376; // xmm5
  int v377; // eax
  __m128i v378; // xmm7
  __m128i v379; // xmm5
  __m128i v380; // xmm4
  __m128i v381; // xmm3
  __m128i v382; // xmm2
  __m128i v383; // xmm1
  __m128i v384; // xmm2
  __m128i v385; // xmm0
  __m128i v386; // xmm3
  __m128i v387; // xmm2
  __m128i v388; // xmm1
  __m128i v389; // xmm2
  __m128i v390; // xmm0
  __m128i v391; // xmm3
  __m128i v392; // xmm2
  __m128i v393; // xmm1
  __m128i v394; // xmm0
  __m128i v395; // xmm3
  __m128i v396; // xmm2
  unsigned int v397; // eax
  unsigned int v398; // ecx
  unsigned int v399; // eax
  __m128i v400; // xmm3
  __m128i v401; // xmm4
  __m128i v402; // xmm5
  int v403; // eax
  __m128i v404; // xmm7
  __m128i v405; // xmm5
  __m128i v406; // xmm4
  __m128i v407; // xmm3
  __m128i v408; // xmm2
  __m128i v409; // xmm1
  __m128i v410; // xmm2
  __m128i v411; // xmm0
  __m128i v412; // xmm3
  __m128i v413; // xmm2
  __m128i v414; // xmm1
  __m128i v415; // xmm2
  __m128i v416; // xmm0
  __m128i v417; // xmm3
  __m128i v418; // xmm2
  __m128i v419; // xmm1
  __m128i v420; // xmm0
  __m128i v421; // xmm3
  __m128i v422; // xmm2
  unsigned int v423; // eax
  unsigned int v424; // ecx
  unsigned int v425; // eax
  __m128i v426; // xmm3
  __m128i v427; // xmm4
  __m128i v428; // xmm5
  int v429; // eax
  __m128i v430; // xmm7
  __m128i v431; // xmm5
  __m128i v432; // xmm4
  __m128i v433; // xmm3
  __m128i v434; // xmm2
  unsigned int v435; // ebx
  unsigned int v436; // edx
  unsigned int v437; // ecx
  unsigned int result; // eax
  unsigned int v439; // ebx
  unsigned int v440; // ecx
  int v441; // eax
  int v442; // eax
  double v443; // xmm1_8
  char v444; // al
  __int16 v445; // ax
  int v446; // eax
  double v447; // xmm1_8
  double v448; // xmm1_8
  double v449; // xmm1_8
  int v450; // ebx
  unsigned int v451; // ecx
  int v452; // edx
  unsigned int v453; // ebx
  bool v454; // cf
  unsigned int i; // ebx
  int v456; // ebx
  char v457; // al
  __int16 v458; // ax
  int v459; // eax
  int v460; // eax
  double v461; // xmm1_8
  double v462; // xmm1_8
  double v463; // xmm1_8
  __m128i v464; // xmm0
  __m128i v465; // xmm0
  __m128i v466; // xmm0
  double v467; // xmm1_8
  double v468; // xmm1_8
  double v469; // xmm1_8
  int v470; // esi
  int v471; // esi
  int v472; // esi
  int v473; // esi
  __m128i v474; // xmm3
  __m128i v475; // xmm3
  __m128i v476; // xmm3
  __m128i v477; // xmm3
  int v478; // eax
  __m128i v479; // xmm3
  int v480; // eax
  __m128i v481; // xmm3
  __int16 v482; // ax
  __m128i v483; // xmm3
  char v484; // ah
  __m128i v485; // xmm3
  __m128i v486; // xmm3
  __m128i v487; // xmm3
  __m128i v488; // xmm3
  char v489; // ah
  __m128i v490; // xmm3
  __m128i v491; // xmm3
  __m128i v492; // xmm3
  __m128i v493; // xmm3
  double v494; // xmm1_8
  int v495; // eax

  v3 = a1;
  v4 = a2;
  if ( a3 <= 8 )
  {
    if ( a3 <= 4 )
    {
      if ( !a3 )
        return a1;
      if ( a3 != 1 && *(_BYTE *)a2 )
      {
        if ( a3 != 2 && *(_BYTE *)(a2 + 1) )
        {
          if ( a3 != 3 && *(_BYTE *)(a2 + 2) )
          {
            *(_DWORD *)a1 = *(_DWORD *)a2;
            return a1;
          }
          goto LABEL_415;
        }
LABEL_413:
        *(_WORD *)a1 = *(_WORD *)a2;
        result = a1;
        v439 = a3 - 2;
        v440 = a1 + 2;
        if ( a3 == 2 )
          return result;
        goto LABEL_403;
      }
    }
    else if ( *(_BYTE *)a2 )
    {
      if ( *(_BYTE *)(a2 + 1) )
      {
        if ( *(_BYTE *)(a2 + 2) )
        {
          if ( *(_BYTE *)(a2 + 3) )
          {
            if ( a3 != 5 && *(_BYTE *)(a2 + 4) )
            {
              if ( a3 != 6 && *(_BYTE *)(a2 + 5) )
              {
                if ( a3 != 7 && *(_BYTE *)(a2 + 6) )
                {
                  *(double *)a1 = *(double *)a2;
                  return a1;
                }
LABEL_422:
                *(_DWORD *)a1 = *(_DWORD *)a2;
                *(_DWORD *)(a1 + 3) = *(_DWORD *)(a2 + 3);
                result = a1;
                v439 = a3 - 7;
                v440 = a1 + 7;
                if ( a3 == 7 )
                  return result;
                goto LABEL_403;
              }
LABEL_420:
              *(_DWORD *)a1 = *(_DWORD *)a2;
              *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
              result = a1;
              v439 = a3 - 6;
              v440 = a1 + 6;
              if ( a3 == 6 )
                return result;
              goto LABEL_403;
            }
LABEL_418:
            *(_DWORD *)a1 = *(_DWORD *)a2;
            *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
            result = a1;
            v439 = a3 - 5;
            v440 = a1 + 5;
            if ( a3 == 5 )
              return result;
            goto LABEL_403;
          }
LABEL_417:
          *(_DWORD *)a1 = *(_DWORD *)a2;
          result = a1;
          v439 = a3 - 4;
          v440 = a1 + 4;
          goto LABEL_403;
        }
LABEL_415:
        *(_WORD *)a1 = *(_WORD *)a2;
        *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
        result = a1;
        v439 = a3 - 3;
        v440 = a1 + 3;
        if ( a3 == 3 )
          return result;
        goto LABEL_403;
      }
      goto LABEL_413;
    }
LABEL_411:
    *(_BYTE *)a1 = *(_BYTE *)a2;
    result = a1;
    v439 = a3 - 1;
    v440 = a1 + 1;
    if ( a3 == 1 )
      return result;
    goto LABEL_403;
  }
  if ( !*(_BYTE *)a2 )
    goto LABEL_411;
  if ( !*(_BYTE *)(a2 + 1) )
    goto LABEL_413;
  if ( !*(_BYTE *)(a2 + 2) )
    goto LABEL_415;
  if ( !*(_BYTE *)(a2 + 3) )
    goto LABEL_417;
  if ( !*(_BYTE *)(a2 + 4) )
    goto LABEL_418;
  if ( !*(_BYTE *)(a2 + 5) )
    goto LABEL_420;
  if ( !*(_BYTE *)(a2 + 6) )
    goto LABEL_422;
  if ( !*(_BYTE *)(a2 + 7) )
  {
    *(double *)a1 = *(double *)a2;
    result = a1;
    v439 = a3 - 8;
    v440 = a1 + 8;
    goto LABEL_403;
  }
  if ( a3 < 0x10 )
  {
    if ( a3 <= 0xC )
    {
      if ( a3 != 9 && *(_BYTE *)(a2 + 8) )
      {
        if ( a3 != 10 && *(_BYTE *)(a2 + 9) )
        {
          if ( a3 != 11 && *(_BYTE *)(a2 + 10) )
          {
            v495 = *(_DWORD *)(a2 + 8);
            *(double *)a1 = *(double *)a2;
            *(_DWORD *)(a1 + 8) = v495;
            return a1;
          }
          goto LABEL_429;
        }
LABEL_427:
        v458 = *(_WORD *)(a2 + 8);
        *(double *)a1 = *(double *)a2;
        *(_WORD *)(a1 + 8) = v458;
        result = a1;
        v439 = a3 - 10;
        v440 = a1 + 10;
        if ( a3 == 10 )
          return result;
        goto LABEL_403;
      }
    }
    else if ( *(_BYTE *)(a2 + 8) )
    {
      if ( *(_BYTE *)(a2 + 9) )
      {
        if ( *(_BYTE *)(a2 + 10) )
        {
          if ( *(_BYTE *)(a2 + 11) )
          {
            if ( a3 != 13 && *(_BYTE *)(a2 + 12) )
            {
              if ( a3 != 14 && *(_BYTE *)(a2 + 13) )
              {
                v494 = *(double *)(a2 + 7);
                *(double *)a1 = *(double *)a2;
                *(double *)(a1 + 7) = v494;
                return a1;
              }
LABEL_434:
              v462 = *(double *)(a2 + 6);
              *(double *)a1 = *(double *)a2;
              *(double *)(a1 + 6) = v462;
              result = a1;
              v439 = a3 - 14;
              v440 = a1 + 14;
              if ( a3 == 14 )
                return result;
              goto LABEL_403;
            }
LABEL_432:
            v461 = *(double *)(a2 + 5);
            *(double *)a1 = *(double *)a2;
            *(double *)(a1 + 5) = v461;
            result = a1;
            v439 = a3 - 13;
            v440 = a1 + 13;
            if ( a3 == 13 )
              return result;
            goto LABEL_403;
          }
LABEL_431:
          v460 = *(_DWORD *)(a2 + 8);
          *(double *)a1 = *(double *)a2;
          *(_DWORD *)(a1 + 8) = v460;
          result = a1;
          v439 = a3 - 12;
          v440 = a1 + 12;
          goto LABEL_403;
        }
LABEL_429:
        v459 = *(_DWORD *)(a2 + 7);
        *(double *)a1 = *(double *)a2;
        *(_DWORD *)(a1 + 7) = v459;
        result = a1;
        v439 = a3 - 11;
        v440 = a1 + 11;
        if ( a3 == 11 )
          return result;
        goto LABEL_403;
      }
      goto LABEL_427;
    }
LABEL_425:
    v457 = *(_BYTE *)(a2 + 8);
    *(double *)a1 = *(double *)a2;
    *(_BYTE *)(a1 + 8) = v457;
    result = a1;
    v439 = a3 - 9;
    v440 = a1 + 9;
    if ( a3 == 9 )
      return result;
    goto LABEL_403;
  }
  if ( !*(_BYTE *)(a2 + 8) )
    goto LABEL_425;
  if ( !*(_BYTE *)(a2 + 9) )
    goto LABEL_427;
  if ( !*(_BYTE *)(a2 + 10) )
    goto LABEL_429;
  if ( !*(_BYTE *)(a2 + 11) )
    goto LABEL_431;
  if ( !*(_BYTE *)(a2 + 12) )
    goto LABEL_432;
  if ( !*(_BYTE *)(a2 + 13) )
    goto LABEL_434;
  if ( !*(_BYTE *)(a2 + 14) )
  {
    v463 = *(double *)(a2 + 7);
    *(double *)a1 = *(double *)a2;
    *(double *)(a1 + 7) = v463;
    result = a1;
    v439 = a3 - 15;
    v440 = a1 + 15;
    goto LABEL_403;
  }
  if ( a3 != 16 && *(_BYTE *)(a2 + 15) )
  {
    v5 = (a2 & 0xF) + a3 - 16;
    v6 = (__m128i *)((a2 + 16) & 0xFFFFFFF0);
    *(double *)a1 = *(double *)a2;
    v7 = _mm_cmpeq_epi8((__m128i)0LL, *v6);
    *(double *)(a1 + 8) = *(double *)(a2 + 8);
    v8 = _mm_movemask_epi8(v7);
    v9 = (int)v6->m128i_i32 - a2;
    v10 = v5 <= 0x10;
    v11 = v5 - 16;
    if ( v10 )
      goto LABEL_325;
    if ( !v8 )
    {
      v3 = (a1 + 16) & 0xFFFFFFF0;
      v12 = a1 - v3;
      if ( ((a1 - v3 + v9 - 1) & 0x80000000) == 0 )
        v11 += 16;
      v4 = a2 - v12;
      v13 = ((_BYTE)a2 - (_BYTE)v12) & 0xF;
      v14 = 0;
      if ( (v4 & 0xF) != 0 )
      {
        if ( v13 >= 8 )
        {
          switch ( v13 )
          {
            case 8u:
              v227 = *(__m128i *)(v4 - 8);
              v228 = *(__m128i *)(v4 + 8);
              while ( 1 )
              {
                v229 = _mm_cmpeq_epi8(v7, v228);
                v8 = _mm_movemask_epi8(v229);
                v230 = v228;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_171;
                v231 = _mm_alignr_epi8(v228, v227, 8);
                v232 = v230;
                *(__m128i *)v3 = v231;
                v233 = *(__m128i *)(v4 + 24);
                v234 = _mm_cmpeq_epi8(v229, v233);
                v3 += 16;
                v8 = _mm_movemask_epi8(v234);
                v4 += 16;
                v235 = v233;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_171;
                *(__m128i *)v3 = _mm_alignr_epi8(v233, v232, 8);
                v236 = *(__m128i *)(v4 + 24);
                v237 = v235;
                v238 = _mm_cmpeq_epi8(v234, v236);
                v3 += 16;
                v8 = _mm_movemask_epi8(v238);
                v4 += 16;
                v239 = v236;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_171;
                *(__m128i *)v3 = _mm_alignr_epi8(v236, v237, 8);
                v240 = *(__m128i *)(v4 + 24);
                v7 = _mm_cmpeq_epi8(v238, v240);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_171:
                  *(double *)v3 = *(double *)v4;
                  v9 = 8;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v240, v239, 8);
                v241 = v4 + 24;
                v242 = (v4 + 24) & 0xFFFFFFC0;
                v243 = v241 - v242;
                v4 = v242 - 8;
                v3 = v3 + 16 - v243;
                v11 += v243;
                v227 = *(__m128i *)(v4 - 8);
                while ( 1 )
                {
                  v228 = *(__m128i *)(v4 + 8);
                  v244 = *(__m128i *)(v4 + 24);
                  v245 = *(__m128i *)(v4 + 40);
                  v246 = *(__m128i *)(v4 + 56);
                  v247 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v245, v246), _mm_min_epu8(v244, v228)), v7));
                  v248 = v246;
                  v249 = _mm_alignr_epi8(v246, v245, 8);
                  v250 = _mm_alignr_epi8(v245, v244, 8);
                  if ( v247 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v485 = *(__m128i *)(v4 + 8);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v228, v227, 8);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 24), v485, 8);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v250;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v249;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 8;
                    v4 += v14 + 8;
                    *(double *)(v3 - 8) = *(double *)(v4 - 8);
                    v9 = 0;
                    goto LABEL_326;
                  }
                  v251 = _mm_alignr_epi8(v244, v228, 8);
                  v4 += 64;
                  v252 = _mm_alignr_epi8(v228, v227, 8);
                  v227 = v248;
                  *(__m128i *)(v3 + 48) = v249;
                  *(__m128i *)(v3 + 32) = v250;
                  *(__m128i *)(v3 + 16) = v251;
                  *(__m128i *)v3 = v252;
                  v3 += 64;
                }
              }
              *(double *)v3 = *(double *)v4;
              v9 = 8;
              if ( v8 )
                goto LABEL_292;
              break;
            case 9u:
              v253 = *(__m128i *)(v4 - 9);
              v254 = *(__m128i *)(v4 + 7);
              while ( 1 )
              {
                v255 = _mm_cmpeq_epi8(v7, v254);
                v8 = _mm_movemask_epi8(v255);
                v256 = v254;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_185;
                v257 = _mm_alignr_epi8(v254, v253, 9);
                v258 = v256;
                *(__m128i *)v3 = v257;
                v259 = *(__m128i *)(v4 + 23);
                v260 = _mm_cmpeq_epi8(v255, v259);
                v3 += 16;
                v8 = _mm_movemask_epi8(v260);
                v4 += 16;
                v261 = v259;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_185;
                *(__m128i *)v3 = _mm_alignr_epi8(v259, v258, 9);
                v262 = *(__m128i *)(v4 + 23);
                v263 = v261;
                v264 = _mm_cmpeq_epi8(v260, v262);
                v3 += 16;
                v8 = _mm_movemask_epi8(v264);
                v4 += 16;
                v265 = v262;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_185;
                *(__m128i *)v3 = _mm_alignr_epi8(v262, v263, 9);
                v266 = *(__m128i *)(v4 + 23);
                v7 = _mm_cmpeq_epi8(v264, v266);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_185:
                  *(double *)(v3 - 1) = *(double *)(v4 - 1);
                  v9 = 7;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v266, v265, 9);
                v267 = v4 + 23;
                v268 = (v4 + 23) & 0xFFFFFFC0;
                v269 = v267 - v268;
                v4 = v268 - 7;
                v3 = v3 + 16 - v269;
                v11 += v269;
                v253 = *(__m128i *)(v4 - 9);
                while ( 1 )
                {
                  v254 = *(__m128i *)(v4 + 7);
                  v270 = *(__m128i *)(v4 + 23);
                  v271 = *(__m128i *)(v4 + 39);
                  v272 = *(__m128i *)(v4 + 55);
                  v273 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v271, v272), _mm_min_epu8(v270, v254)), v7));
                  v274 = v272;
                  v275 = _mm_alignr_epi8(v272, v271, 9);
                  v276 = _mm_alignr_epi8(v271, v270, 9);
                  if ( v273 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v486 = *(__m128i *)(v4 + 7);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v254, v253, 9);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 23), v486, 9);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v276;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v275;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 7;
                    v4 += v14 + 7;
                    *(double *)(v3 - 8) = *(double *)(v4 - 8);
                    v9 = 0;
                    goto LABEL_326;
                  }
                  v277 = _mm_alignr_epi8(v270, v254, 9);
                  v4 += 64;
                  v278 = _mm_alignr_epi8(v254, v253, 9);
                  v253 = v274;
                  *(__m128i *)(v3 + 48) = v275;
                  *(__m128i *)(v3 + 32) = v276;
                  *(__m128i *)(v3 + 16) = v277;
                  *(__m128i *)v3 = v278;
                  v3 += 64;
                }
              }
              *(double *)v3 = *(double *)v4;
              v9 = 7;
              if ( v8 )
                goto LABEL_292;
              break;
            case 0xAu:
              v279 = *(__m128i *)(v4 - 10);
              v280 = *(__m128i *)(v4 + 6);
              while ( 1 )
              {
                v281 = _mm_cmpeq_epi8(v7, v280);
                v8 = _mm_movemask_epi8(v281);
                v282 = v280;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_199;
                v283 = _mm_alignr_epi8(v280, v279, 10);
                v284 = v282;
                *(__m128i *)v3 = v283;
                v285 = *(__m128i *)(v4 + 22);
                v286 = _mm_cmpeq_epi8(v281, v285);
                v3 += 16;
                v8 = _mm_movemask_epi8(v286);
                v4 += 16;
                v287 = v285;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_199;
                *(__m128i *)v3 = _mm_alignr_epi8(v285, v284, 10);
                v288 = *(__m128i *)(v4 + 22);
                v289 = v287;
                v290 = _mm_cmpeq_epi8(v286, v288);
                v3 += 16;
                v8 = _mm_movemask_epi8(v290);
                v4 += 16;
                v291 = v288;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_199;
                *(__m128i *)v3 = _mm_alignr_epi8(v288, v289, 10);
                v292 = *(__m128i *)(v4 + 22);
                v7 = _mm_cmpeq_epi8(v290, v292);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_199:
                  *(double *)(v3 - 2) = *(double *)(v4 - 2);
                  v9 = 6;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v292, v291, 10);
                v293 = v4 + 22;
                v294 = (v4 + 22) & 0xFFFFFFC0;
                v295 = v293 - v294;
                v4 = v294 - 6;
                v3 = v3 + 16 - v295;
                v11 += v295;
                v279 = *(__m128i *)(v4 - 10);
                while ( 1 )
                {
                  v280 = *(__m128i *)(v4 + 6);
                  v296 = *(__m128i *)(v4 + 22);
                  v297 = *(__m128i *)(v4 + 38);
                  v298 = *(__m128i *)(v4 + 54);
                  v299 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v297, v298), _mm_min_epu8(v296, v280)), v7));
                  v300 = v298;
                  v301 = _mm_alignr_epi8(v298, v297, 10);
                  v302 = _mm_alignr_epi8(v297, v296, 10);
                  if ( v299 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v487 = *(__m128i *)(v4 + 6);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v280, v279, 10);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 22), v487, 10);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v302;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v301;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 6;
                    v4 += v14 + 6;
                    *(double *)(v3 - 8) = *(double *)(v4 - 8);
                    v9 = 0;
                    goto LABEL_326;
                  }
                  v303 = _mm_alignr_epi8(v296, v280, 10);
                  v4 += 64;
                  v304 = _mm_alignr_epi8(v280, v279, 10);
                  v279 = v300;
                  *(__m128i *)(v3 + 48) = v301;
                  *(__m128i *)(v3 + 32) = v302;
                  *(__m128i *)(v3 + 16) = v303;
                  *(__m128i *)v3 = v304;
                  v3 += 64;
                }
              }
              *(double *)(v3 - 1) = *(double *)(v4 - 1);
              v9 = 6;
              if ( v8 )
                goto LABEL_292;
              break;
            case 0xBu:
              v305 = *(__m128i *)(v4 - 11);
              v306 = *(__m128i *)(v4 + 5);
              while ( 1 )
              {
                v307 = _mm_cmpeq_epi8(v7, v306);
                v8 = _mm_movemask_epi8(v307);
                v308 = v306;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_213;
                v309 = _mm_alignr_epi8(v306, v305, 11);
                v310 = v308;
                *(__m128i *)v3 = v309;
                v311 = *(__m128i *)(v4 + 21);
                v312 = _mm_cmpeq_epi8(v307, v311);
                v3 += 16;
                v8 = _mm_movemask_epi8(v312);
                v4 += 16;
                v313 = v311;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_213;
                *(__m128i *)v3 = _mm_alignr_epi8(v311, v310, 11);
                v314 = *(__m128i *)(v4 + 21);
                v315 = v313;
                v316 = _mm_cmpeq_epi8(v312, v314);
                v3 += 16;
                v8 = _mm_movemask_epi8(v316);
                v4 += 16;
                v317 = v314;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_213;
                *(__m128i *)v3 = _mm_alignr_epi8(v314, v315, 11);
                v318 = *(__m128i *)(v4 + 21);
                v7 = _mm_cmpeq_epi8(v316, v318);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_213:
                  *(double *)(v3 - 3) = *(double *)(v4 - 3);
                  v9 = 5;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v318, v317, 11);
                v319 = v4 + 21;
                v320 = (v4 + 21) & 0xFFFFFFC0;
                v321 = v319 - v320;
                v4 = v320 - 5;
                v3 = v3 + 16 - v321;
                v11 += v321;
                v305 = *(__m128i *)(v4 - 11);
                while ( 1 )
                {
                  v306 = *(__m128i *)(v4 + 5);
                  v322 = *(__m128i *)(v4 + 21);
                  v323 = *(__m128i *)(v4 + 37);
                  v324 = *(__m128i *)(v4 + 53);
                  v325 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v323, v324), _mm_min_epu8(v322, v306)), v7));
                  v326 = v324;
                  v327 = _mm_alignr_epi8(v324, v323, 11);
                  v328 = _mm_alignr_epi8(v323, v322, 11);
                  if ( v325 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v488 = *(__m128i *)(v4 + 5);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v306, v305, 11);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 21), v488, 11);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v328;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v327;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 5;
                    v4 += v14 + 5;
                    v489 = *(_BYTE *)(v4 - 1);
                    *(_DWORD *)(v3 - 5) = *(_DWORD *)(v4 - 5);
                    *(_BYTE *)(v3 - 1) = v489;
                    v9 = 0;
                    goto LABEL_326;
                  }
                  v329 = _mm_alignr_epi8(v322, v306, 11);
                  v4 += 64;
                  v330 = _mm_alignr_epi8(v306, v305, 11);
                  v305 = v326;
                  *(__m128i *)(v3 + 48) = v327;
                  *(__m128i *)(v3 + 32) = v328;
                  *(__m128i *)(v3 + 16) = v329;
                  *(__m128i *)v3 = v330;
                  v3 += 64;
                }
              }
              *(double *)(v3 - 2) = *(double *)(v4 - 2);
              v9 = 5;
              if ( v8 )
                goto LABEL_292;
              break;
            case 0xCu:
              v331 = *(__m128i *)(v4 - 12);
              v332 = *(__m128i *)(v4 + 4);
              while ( 1 )
              {
                v333 = _mm_cmpeq_epi8(v7, v332);
                v8 = _mm_movemask_epi8(v333);
                v334 = v332;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_227;
                v335 = _mm_alignr_epi8(v332, v331, 12);
                v336 = v334;
                *(__m128i *)v3 = v335;
                v337 = *(__m128i *)(v4 + 20);
                v338 = _mm_cmpeq_epi8(v333, v337);
                v3 += 16;
                v8 = _mm_movemask_epi8(v338);
                v4 += 16;
                v339 = v337;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_227;
                *(__m128i *)v3 = _mm_alignr_epi8(v337, v336, 12);
                v340 = *(__m128i *)(v4 + 20);
                v341 = v339;
                v342 = _mm_cmpeq_epi8(v338, v340);
                v3 += 16;
                v8 = _mm_movemask_epi8(v342);
                v4 += 16;
                v343 = v340;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_227;
                *(__m128i *)v3 = _mm_alignr_epi8(v340, v341, 12);
                v344 = *(__m128i *)(v4 + 20);
                v7 = _mm_cmpeq_epi8(v342, v344);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_227:
                  *(_DWORD *)v3 = *(_DWORD *)v4;
                  v9 = 4;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v344, v343, 12);
                v345 = v4 + 20;
                v346 = (v4 + 20) & 0xFFFFFFC0;
                v347 = v345 - v346;
                v4 = v346 - 4;
                v3 = v3 + 16 - v347;
                v11 += v347;
                v331 = *(__m128i *)(v4 - 12);
                while ( 1 )
                {
                  v332 = *(__m128i *)(v4 + 4);
                  v348 = *(__m128i *)(v4 + 20);
                  v349 = *(__m128i *)(v4 + 36);
                  v350 = *(__m128i *)(v4 + 52);
                  v351 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v349, v350), _mm_min_epu8(v348, v332)), v7));
                  v352 = v350;
                  v353 = _mm_alignr_epi8(v350, v349, 12);
                  v354 = _mm_alignr_epi8(v349, v348, 12);
                  if ( v351 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v490 = *(__m128i *)(v4 + 4);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v332, v331, 12);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 20), v490, 12);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v354;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v353;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 4;
                    v4 += v14 + 4;
                    *(_DWORD *)(v3 - 4) = *(_DWORD *)(v4 - 4);
                    v9 = 0;
                    goto LABEL_326;
                  }
                  v355 = _mm_alignr_epi8(v348, v332, 12);
                  v4 += 64;
                  v356 = _mm_alignr_epi8(v332, v331, 12);
                  v331 = v352;
                  *(__m128i *)(v3 + 48) = v353;
                  *(__m128i *)(v3 + 32) = v354;
                  *(__m128i *)(v3 + 16) = v355;
                  *(__m128i *)v3 = v356;
                  v3 += 64;
                }
              }
              *(_DWORD *)v3 = *(_DWORD *)v4;
              v9 = 4;
              if ( v8 )
                goto LABEL_292;
              break;
            case 0xDu:
              v357 = *(__m128i *)(v4 - 13);
              v358 = *(__m128i *)(v4 + 3);
              while ( 1 )
              {
                v359 = _mm_cmpeq_epi8(v7, v358);
                v8 = _mm_movemask_epi8(v359);
                v360 = v358;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_241;
                v361 = _mm_alignr_epi8(v358, v357, 13);
                v362 = v360;
                *(__m128i *)v3 = v361;
                v363 = *(__m128i *)(v4 + 19);
                v364 = _mm_cmpeq_epi8(v359, v363);
                v3 += 16;
                v8 = _mm_movemask_epi8(v364);
                v4 += 16;
                v365 = v363;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_241;
                *(__m128i *)v3 = _mm_alignr_epi8(v363, v362, 13);
                v366 = *(__m128i *)(v4 + 19);
                v367 = v365;
                v368 = _mm_cmpeq_epi8(v364, v366);
                v3 += 16;
                v8 = _mm_movemask_epi8(v368);
                v4 += 16;
                v369 = v366;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_241;
                *(__m128i *)v3 = _mm_alignr_epi8(v366, v367, 13);
                v370 = *(__m128i *)(v4 + 19);
                v7 = _mm_cmpeq_epi8(v368, v370);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_241:
                  *(_DWORD *)(v3 - 1) = *(_DWORD *)(v4 - 1);
                  v9 = 3;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v370, v369, 13);
                v371 = v4 + 19;
                v372 = (v4 + 19) & 0xFFFFFFC0;
                v373 = v371 - v372;
                v4 = v372 - 3;
                v3 = v3 + 16 - v373;
                v11 += v373;
                v357 = *(__m128i *)(v4 - 13);
                while ( 1 )
                {
                  v358 = *(__m128i *)(v4 + 3);
                  v374 = *(__m128i *)(v4 + 19);
                  v375 = *(__m128i *)(v4 + 35);
                  v376 = *(__m128i *)(v4 + 51);
                  v377 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v375, v376), _mm_min_epu8(v374, v358)), v7));
                  v378 = v376;
                  v379 = _mm_alignr_epi8(v376, v375, 13);
                  v380 = _mm_alignr_epi8(v375, v374, 13);
                  if ( v377 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v491 = *(__m128i *)(v4 + 3);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v358, v357, 13);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 19), v491, 13);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v380;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v379;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 3;
                    v4 += v14 + 3;
                    *(_DWORD *)(v3 - 4) = *(_DWORD *)(v4 - 4);
                    v9 = 0;
                    goto LABEL_326;
                  }
                  v381 = _mm_alignr_epi8(v374, v358, 13);
                  v4 += 64;
                  v382 = _mm_alignr_epi8(v358, v357, 13);
                  v357 = v378;
                  *(__m128i *)(v3 + 48) = v379;
                  *(__m128i *)(v3 + 32) = v380;
                  *(__m128i *)(v3 + 16) = v381;
                  *(__m128i *)v3 = v382;
                  v3 += 64;
                }
              }
              *(_DWORD *)(v3 - 1) = *(_DWORD *)(v4 - 1);
              v9 = 3;
              if ( v8 )
                goto LABEL_292;
              break;
            case 0xEu:
              v383 = *(__m128i *)(v4 - 14);
              v384 = *(__m128i *)(v4 + 2);
              while ( 1 )
              {
                v385 = _mm_cmpeq_epi8(v7, v384);
                v8 = _mm_movemask_epi8(v385);
                v386 = v384;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_255;
                v387 = _mm_alignr_epi8(v384, v383, 14);
                v388 = v386;
                *(__m128i *)v3 = v387;
                v389 = *(__m128i *)(v4 + 18);
                v390 = _mm_cmpeq_epi8(v385, v389);
                v3 += 16;
                v8 = _mm_movemask_epi8(v390);
                v4 += 16;
                v391 = v389;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_255;
                *(__m128i *)v3 = _mm_alignr_epi8(v389, v388, 14);
                v392 = *(__m128i *)(v4 + 18);
                v393 = v391;
                v394 = _mm_cmpeq_epi8(v390, v392);
                v3 += 16;
                v8 = _mm_movemask_epi8(v394);
                v4 += 16;
                v395 = v392;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_255;
                *(__m128i *)v3 = _mm_alignr_epi8(v392, v393, 14);
                v396 = *(__m128i *)(v4 + 18);
                v7 = _mm_cmpeq_epi8(v394, v396);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_255:
                  *(_DWORD *)(v3 - 2) = *(_DWORD *)(v4 - 2);
                  v9 = 2;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v396, v395, 14);
                v397 = v4 + 18;
                v398 = (v4 + 18) & 0xFFFFFFC0;
                v399 = v397 - v398;
                v4 = v398 - 2;
                v3 = v3 + 16 - v399;
                v11 += v399;
                v383 = *(__m128i *)(v4 - 14);
                while ( 1 )
                {
                  v384 = *(__m128i *)(v4 + 2);
                  v400 = *(__m128i *)(v4 + 18);
                  v401 = *(__m128i *)(v4 + 34);
                  v402 = *(__m128i *)(v4 + 50);
                  v403 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v401, v402), _mm_min_epu8(v400, v384)), v7));
                  v404 = v402;
                  v405 = _mm_alignr_epi8(v402, v401, 14);
                  v406 = _mm_alignr_epi8(v401, v400, 14);
                  if ( v403 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v492 = *(__m128i *)(v4 + 2);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v384, v383, 14);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 18), v492, 14);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v406;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v405;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 2;
                    v4 += v14 + 2;
                    *(_WORD *)(v3 - 2) = *(_WORD *)(v4 - 2);
                    v9 = 0;
                    goto LABEL_326;
                  }
                  v407 = _mm_alignr_epi8(v400, v384, 14);
                  v4 += 64;
                  v408 = _mm_alignr_epi8(v384, v383, 14);
                  v383 = v404;
                  *(__m128i *)(v3 + 48) = v405;
                  *(__m128i *)(v3 + 32) = v406;
                  *(__m128i *)(v3 + 16) = v407;
                  *(__m128i *)v3 = v408;
                  v3 += 64;
                }
              }
              *(_DWORD *)(v3 - 2) = *(_DWORD *)(v4 - 2);
              v9 = 2;
              if ( v8 )
                goto LABEL_292;
              break;
            default:
              v409 = *(__m128i *)(v4 - 15);
              v410 = *(__m128i *)(v4 + 1);
              while ( 1 )
              {
                v411 = _mm_cmpeq_epi8(v7, v410);
                v8 = _mm_movemask_epi8(v411);
                v412 = v410;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_268;
                v413 = _mm_alignr_epi8(v410, v409, 15);
                v414 = v412;
                *(__m128i *)v3 = v413;
                v415 = *(__m128i *)(v4 + 17);
                v416 = _mm_cmpeq_epi8(v411, v415);
                v3 += 16;
                v8 = _mm_movemask_epi8(v416);
                v4 += 16;
                v417 = v415;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_268;
                *(__m128i *)v3 = _mm_alignr_epi8(v415, v414, 15);
                v418 = *(__m128i *)(v4 + 17);
                v419 = v417;
                v420 = _mm_cmpeq_epi8(v416, v418);
                v3 += 16;
                v8 = _mm_movemask_epi8(v420);
                v4 += 16;
                v421 = v418;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_268;
                *(__m128i *)v3 = _mm_alignr_epi8(v418, v419, 15);
                v422 = *(__m128i *)(v4 + 17);
                v7 = _mm_cmpeq_epi8(v420, v422);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_268:
                  *(_DWORD *)(v3 - 3) = *(_DWORD *)(v4 - 3);
                  v9 = 1;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v422, v421, 15);
                v423 = v4 + 17;
                v424 = (v4 + 17) & 0xFFFFFFC0;
                v425 = v423 - v424;
                v4 = v424 - 1;
                v3 = v3 + 16 - v425;
                v11 += v425;
                v409 = *(__m128i *)(v4 - 15);
                while ( 1 )
                {
                  v410 = *(__m128i *)(v4 + 1);
                  v426 = *(__m128i *)(v4 + 17);
                  v427 = *(__m128i *)(v4 + 33);
                  v428 = *(__m128i *)(v4 + 49);
                  v429 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v427, v428), _mm_min_epu8(v426, v410)), v7));
                  v430 = v428;
                  v431 = _mm_alignr_epi8(v428, v427, 15);
                  v432 = _mm_alignr_epi8(v427, v426, 15);
                  if ( v429 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v493 = *(__m128i *)(v4 + 1);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v410, v409, 15);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 17), v493, 15);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v432;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v431;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 1;
                    v4 += v14 + 1;
                    *(_BYTE *)(v3 - 1) = *(_BYTE *)(v4 - 1);
                    v9 = 0;
                    goto LABEL_326;
                  }
                  v433 = _mm_alignr_epi8(v426, v410, 15);
                  v4 += 64;
                  v434 = _mm_alignr_epi8(v410, v409, 15);
                  v409 = v430;
                  *(__m128i *)(v3 + 48) = v431;
                  *(__m128i *)(v3 + 32) = v432;
                  *(__m128i *)(v3 + 16) = v433;
                  *(__m128i *)v3 = v434;
                  v3 += 64;
                }
              }
              *(_DWORD *)(v3 - 3) = *(_DWORD *)(v4 - 3);
              v9 = 1;
              if ( v8 )
                goto LABEL_292;
              break;
          }
        }
        else
        {
          switch ( v13 )
          {
            case 1u:
              v39 = *(__m128i *)(v4 - 1);
              v40 = *(__m128i *)(v4 + 15);
              while ( 1 )
              {
                v41 = _mm_cmpeq_epi8(v7, v40);
                v8 = _mm_movemask_epi8(v41);
                v42 = v40;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_74;
                v43 = _mm_alignr_epi8(v40, v39, 1);
                v44 = v42;
                *(__m128i *)v3 = v43;
                v45 = *(__m128i *)(v4 + 31);
                v46 = _mm_cmpeq_epi8(v41, v45);
                v3 += 16;
                v8 = _mm_movemask_epi8(v46);
                v4 += 16;
                v47 = v45;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_74;
                *(__m128i *)v3 = _mm_alignr_epi8(v45, v44, 1);
                v48 = *(__m128i *)(v4 + 31);
                v49 = v47;
                v50 = _mm_cmpeq_epi8(v46, v48);
                v3 += 16;
                v8 = _mm_movemask_epi8(v50);
                v4 += 16;
                v51 = v48;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_74;
                *(__m128i *)v3 = _mm_alignr_epi8(v48, v49, 1);
                v52 = *(__m128i *)(v4 + 31);
                v7 = _mm_cmpeq_epi8(v50, v52);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_74:
                  *(double *)v3 = *(double *)v4;
                  *(double *)(v3 + 7) = *(double *)(v4 + 7);
                  v9 = 15;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v52, v51, 1);
                v53 = v4 + 31;
                v54 = (v4 + 31) & 0xFFFFFFC0;
                v55 = v53 - v54;
                v4 = v54 - 15;
                v3 = v3 + 16 - v55;
                v11 += v55;
                v39 = *(__m128i *)(v4 - 1);
                while ( 1 )
                {
                  v40 = *(__m128i *)(v4 + 15);
                  v56 = *(__m128i *)(v4 + 31);
                  v57 = *(__m128i *)(v4 + 47);
                  v58 = *(__m128i *)(v4 + 63);
                  v59 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v57, v58), _mm_min_epu8(v56, v40)), v7));
                  v60 = v58;
                  v61 = _mm_alignr_epi8(v58, v57, 1);
                  v62 = _mm_alignr_epi8(v57, v56, 1);
                  if ( v59 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v474 = *(__m128i *)(v4 + 15);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v40, v39, 1);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 31), v474, 1);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v62;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v61;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 15;
                    v4 += v14 + 15;
                    v9 = 0;
                    *(__m128i *)(v3 - 16) = _mm_loadu_si128((const __m128i *)(v4 - 16));
                    goto LABEL_326;
                  }
                  v63 = _mm_alignr_epi8(v56, v40, 1);
                  v4 += 64;
                  v64 = _mm_alignr_epi8(v40, v39, 1);
                  v39 = v60;
                  *(__m128i *)(v3 + 48) = v61;
                  *(__m128i *)(v3 + 32) = v62;
                  *(__m128i *)(v3 + 16) = v63;
                  *(__m128i *)v3 = v64;
                  v3 += 64;
                }
              }
              v467 = *(double *)(v4 + 7);
              *(double *)v3 = *(double *)v4;
              *(double *)(v3 + 7) = v467;
              v9 = 15;
              if ( v8 )
                goto LABEL_292;
              break;
            case 2u:
              v65 = *(__m128i *)(v4 - 2);
              v66 = *(__m128i *)(v4 + 14);
              while ( 1 )
              {
                v67 = _mm_cmpeq_epi8(v7, v66);
                v8 = _mm_movemask_epi8(v67);
                v68 = v66;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_88;
                v69 = _mm_alignr_epi8(v66, v65, 2);
                v70 = v68;
                *(__m128i *)v3 = v69;
                v71 = *(__m128i *)(v4 + 30);
                v72 = _mm_cmpeq_epi8(v67, v71);
                v3 += 16;
                v8 = _mm_movemask_epi8(v72);
                v4 += 16;
                v73 = v71;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_88;
                *(__m128i *)v3 = _mm_alignr_epi8(v71, v70, 2);
                v74 = *(__m128i *)(v4 + 30);
                v75 = v73;
                v76 = _mm_cmpeq_epi8(v72, v74);
                v3 += 16;
                v8 = _mm_movemask_epi8(v76);
                v4 += 16;
                v77 = v74;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_88;
                *(__m128i *)v3 = _mm_alignr_epi8(v74, v75, 2);
                v78 = *(__m128i *)(v4 + 30);
                v7 = _mm_cmpeq_epi8(v76, v78);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_88:
                  v91 = *(double *)(v4 + 6);
                  *(double *)v3 = *(double *)v4;
                  *(double *)(v3 + 6) = v91;
                  v9 = 14;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v78, v77, 2);
                v79 = v4 + 30;
                v80 = (v4 + 30) & 0xFFFFFFC0;
                v81 = v79 - v80;
                v4 = v80 - 14;
                v3 = v3 + 16 - v81;
                v11 += v81;
                v65 = *(__m128i *)(v4 - 2);
                while ( 1 )
                {
                  v66 = *(__m128i *)(v4 + 14);
                  v82 = *(__m128i *)(v4 + 30);
                  v83 = *(__m128i *)(v4 + 46);
                  v84 = *(__m128i *)(v4 + 62);
                  v85 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v83, v84), _mm_min_epu8(v82, v66)), v7));
                  v86 = v84;
                  v87 = _mm_alignr_epi8(v84, v83, 2);
                  v88 = _mm_alignr_epi8(v83, v82, 2);
                  if ( v85 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v475 = *(__m128i *)(v4 + 14);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v66, v65, 2);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 30), v475, 2);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v88;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v87;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 14;
                    v4 += v14 + 14;
                    v9 = 0;
                    *(__m128i *)(v3 - 16) = _mm_loadu_si128((const __m128i *)(v4 - 16));
                    goto LABEL_326;
                  }
                  v89 = _mm_alignr_epi8(v82, v66, 2);
                  v4 += 64;
                  v90 = _mm_alignr_epi8(v66, v65, 2);
                  v65 = v86;
                  *(__m128i *)(v3 + 48) = v87;
                  *(__m128i *)(v3 + 32) = v88;
                  *(__m128i *)(v3 + 16) = v89;
                  *(__m128i *)v3 = v90;
                  v3 += 64;
                }
              }
              v468 = *(double *)(v4 + 6);
              *(double *)v3 = *(double *)v4;
              *(double *)(v3 + 6) = v468;
              v9 = 14;
              if ( v8 )
                goto LABEL_292;
              break;
            case 3u:
              v92 = *(__m128i *)(v4 - 3);
              v93 = *(__m128i *)(v4 + 13);
              while ( 1 )
              {
                v94 = _mm_cmpeq_epi8(v7, v93);
                v8 = _mm_movemask_epi8(v94);
                v95 = v93;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_102;
                v96 = _mm_alignr_epi8(v93, v92, 3);
                v97 = v95;
                *(__m128i *)v3 = v96;
                v98 = *(__m128i *)(v4 + 29);
                v99 = _mm_cmpeq_epi8(v94, v98);
                v3 += 16;
                v8 = _mm_movemask_epi8(v99);
                v4 += 16;
                v100 = v98;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_102;
                *(__m128i *)v3 = _mm_alignr_epi8(v98, v97, 3);
                v101 = *(__m128i *)(v4 + 29);
                v102 = v100;
                v103 = _mm_cmpeq_epi8(v99, v101);
                v3 += 16;
                v8 = _mm_movemask_epi8(v103);
                v4 += 16;
                v104 = v101;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_102;
                *(__m128i *)v3 = _mm_alignr_epi8(v101, v102, 3);
                v105 = *(__m128i *)(v4 + 29);
                v7 = _mm_cmpeq_epi8(v103, v105);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_102:
                  v118 = *(double *)(v4 + 5);
                  *(double *)v3 = *(double *)v4;
                  *(double *)(v3 + 5) = v118;
                  v9 = 13;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v105, v104, 3);
                v106 = v4 + 29;
                v107 = (v4 + 29) & 0xFFFFFFC0;
                v108 = v106 - v107;
                v4 = v107 - 13;
                v3 = v3 + 16 - v108;
                v11 += v108;
                v92 = *(__m128i *)(v4 - 3);
                while ( 1 )
                {
                  v93 = *(__m128i *)(v4 + 13);
                  v109 = *(__m128i *)(v4 + 29);
                  v110 = *(__m128i *)(v4 + 45);
                  v111 = *(__m128i *)(v4 + 61);
                  v112 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v110, v111), _mm_min_epu8(v109, v93)), v7));
                  v113 = v111;
                  v114 = _mm_alignr_epi8(v111, v110, 3);
                  v115 = _mm_alignr_epi8(v110, v109, 3);
                  if ( v112 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v476 = *(__m128i *)(v4 + 13);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v93, v92, 3);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 29), v476, 3);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v115;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v114;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 13;
                    v4 += v14 + 13;
                    v9 = 0;
                    *(__m128i *)(v3 - 16) = _mm_loadu_si128((const __m128i *)(v4 - 16));
                    goto LABEL_326;
                  }
                  v116 = _mm_alignr_epi8(v109, v93, 3);
                  v4 += 64;
                  v117 = _mm_alignr_epi8(v93, v92, 3);
                  v92 = v113;
                  *(__m128i *)(v3 + 48) = v114;
                  *(__m128i *)(v3 + 32) = v115;
                  *(__m128i *)(v3 + 16) = v116;
                  *(__m128i *)v3 = v117;
                  v3 += 64;
                }
              }
              v469 = *(double *)(v4 + 5);
              *(double *)v3 = *(double *)v4;
              *(double *)(v3 + 5) = v469;
              v9 = 13;
              if ( v8 )
                goto LABEL_292;
              break;
            case 4u:
              v119 = *(__m128i *)(v4 - 4);
              v120 = *(__m128i *)(v4 + 12);
              while ( 1 )
              {
                v121 = _mm_cmpeq_epi8(v7, v120);
                v8 = _mm_movemask_epi8(v121);
                v122 = v120;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_116;
                v123 = _mm_alignr_epi8(v120, v119, 4);
                v124 = v122;
                *(__m128i *)v3 = v123;
                v125 = *(__m128i *)(v4 + 28);
                v126 = _mm_cmpeq_epi8(v121, v125);
                v3 += 16;
                v8 = _mm_movemask_epi8(v126);
                v4 += 16;
                v127 = v125;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_116;
                *(__m128i *)v3 = _mm_alignr_epi8(v125, v124, 4);
                v128 = *(__m128i *)(v4 + 28);
                v129 = v127;
                v130 = _mm_cmpeq_epi8(v126, v128);
                v3 += 16;
                v8 = _mm_movemask_epi8(v130);
                v4 += 16;
                v131 = v128;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_116;
                *(__m128i *)v3 = _mm_alignr_epi8(v128, v129, 4);
                v132 = *(__m128i *)(v4 + 28);
                v7 = _mm_cmpeq_epi8(v130, v132);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_116:
                  v145 = *(_DWORD *)(v4 + 8);
                  *(double *)v3 = *(double *)v4;
                  *(_DWORD *)(v3 + 8) = v145;
                  v9 = 12;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v132, v131, 4);
                v133 = v4 + 28;
                v134 = (v4 + 28) & 0xFFFFFFC0;
                v135 = v133 - v134;
                v4 = v134 - 12;
                v3 = v3 + 16 - v135;
                v11 += v135;
                v119 = *(__m128i *)(v4 - 4);
                while ( 1 )
                {
                  v120 = *(__m128i *)(v4 + 12);
                  v136 = *(__m128i *)(v4 + 28);
                  v137 = *(__m128i *)(v4 + 44);
                  v138 = *(__m128i *)(v4 + 60);
                  v139 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v137, v138), _mm_min_epu8(v136, v120)), v7));
                  v140 = v138;
                  v141 = _mm_alignr_epi8(v138, v137, 4);
                  v142 = _mm_alignr_epi8(v137, v136, 4);
                  if ( v139 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v477 = *(__m128i *)(v4 + 12);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v120, v119, 4);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 28), v477, 4);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v142;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v141;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 12;
                    v4 += v14 + 12;
                    v478 = *(_DWORD *)(v4 - 4);
                    *(double *)(v3 - 12) = *(double *)(v4 - 12);
                    *(_DWORD *)(v3 - 4) = v478;
                    v9 = 0;
                    goto LABEL_326;
                  }
                  v143 = _mm_alignr_epi8(v136, v120, 4);
                  v4 += 64;
                  v144 = _mm_alignr_epi8(v120, v119, 4);
                  v119 = v140;
                  *(__m128i *)(v3 + 48) = v141;
                  *(__m128i *)(v3 + 32) = v142;
                  *(__m128i *)(v3 + 16) = v143;
                  *(__m128i *)v3 = v144;
                  v3 += 64;
                }
              }
              v470 = *(_DWORD *)(v4 + 8);
              *(double *)v3 = *(double *)v4;
              *(_DWORD *)(v3 + 8) = v470;
              v9 = 12;
              if ( v8 )
                goto LABEL_292;
              break;
            case 5u:
              v146 = *(__m128i *)(v4 - 5);
              v147 = *(__m128i *)(v4 + 11);
              while ( 1 )
              {
                v148 = _mm_cmpeq_epi8(v7, v147);
                v8 = _mm_movemask_epi8(v148);
                v149 = v147;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_130;
                v150 = _mm_alignr_epi8(v147, v146, 5);
                v151 = v149;
                *(__m128i *)v3 = v150;
                v152 = *(__m128i *)(v4 + 27);
                v153 = _mm_cmpeq_epi8(v148, v152);
                v3 += 16;
                v8 = _mm_movemask_epi8(v153);
                v4 += 16;
                v154 = v152;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_130;
                *(__m128i *)v3 = _mm_alignr_epi8(v152, v151, 5);
                v155 = *(__m128i *)(v4 + 27);
                v156 = v154;
                v157 = _mm_cmpeq_epi8(v153, v155);
                v3 += 16;
                v8 = _mm_movemask_epi8(v157);
                v4 += 16;
                v158 = v155;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_130;
                *(__m128i *)v3 = _mm_alignr_epi8(v155, v156, 5);
                v159 = *(__m128i *)(v4 + 27);
                v7 = _mm_cmpeq_epi8(v157, v159);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_130:
                  v172 = *(_DWORD *)(v4 + 7);
                  *(double *)v3 = *(double *)v4;
                  *(_DWORD *)(v3 + 7) = v172;
                  v9 = 11;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v159, v158, 5);
                v160 = v4 + 27;
                v161 = (v4 + 27) & 0xFFFFFFC0;
                v162 = v160 - v161;
                v4 = v161 - 11;
                v3 = v3 + 16 - v162;
                v11 += v162;
                v146 = *(__m128i *)(v4 - 5);
                while ( 1 )
                {
                  v147 = *(__m128i *)(v4 + 11);
                  v163 = *(__m128i *)(v4 + 27);
                  v164 = *(__m128i *)(v4 + 43);
                  v165 = *(__m128i *)(v4 + 59);
                  v166 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v164, v165), _mm_min_epu8(v163, v147)), v7));
                  v167 = v165;
                  v168 = _mm_alignr_epi8(v165, v164, 5);
                  v169 = _mm_alignr_epi8(v164, v163, 5);
                  if ( v166 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v479 = *(__m128i *)(v4 + 11);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v147, v146, 5);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 27), v479, 5);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v169;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v168;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 11;
                    v4 += v14 + 11;
                    v480 = *(_DWORD *)(v4 - 4);
                    *(double *)(v3 - 11) = *(double *)(v4 - 11);
                    *(_DWORD *)(v3 - 4) = v480;
                    v9 = 0;
                    goto LABEL_326;
                  }
                  v170 = _mm_alignr_epi8(v163, v147, 5);
                  v4 += 64;
                  v171 = _mm_alignr_epi8(v147, v146, 5);
                  v146 = v167;
                  *(__m128i *)(v3 + 48) = v168;
                  *(__m128i *)(v3 + 32) = v169;
                  *(__m128i *)(v3 + 16) = v170;
                  *(__m128i *)v3 = v171;
                  v3 += 64;
                }
              }
              v471 = *(_DWORD *)(v4 + 7);
              *(double *)v3 = *(double *)v4;
              *(_DWORD *)(v3 + 7) = v471;
              v9 = 11;
              if ( v8 )
                goto LABEL_292;
              break;
            case 6u:
              v173 = *(__m128i *)(v4 - 6);
              v174 = *(__m128i *)(v4 + 10);
              while ( 1 )
              {
                v175 = _mm_cmpeq_epi8(v7, v174);
                v8 = _mm_movemask_epi8(v175);
                v176 = v174;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_144;
                v177 = _mm_alignr_epi8(v174, v173, 6);
                v178 = v176;
                *(__m128i *)v3 = v177;
                v179 = *(__m128i *)(v4 + 26);
                v180 = _mm_cmpeq_epi8(v175, v179);
                v3 += 16;
                v8 = _mm_movemask_epi8(v180);
                v4 += 16;
                v181 = v179;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_144;
                *(__m128i *)v3 = _mm_alignr_epi8(v179, v178, 6);
                v182 = *(__m128i *)(v4 + 26);
                v183 = v181;
                v184 = _mm_cmpeq_epi8(v180, v182);
                v3 += 16;
                v8 = _mm_movemask_epi8(v184);
                v4 += 16;
                v185 = v182;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_144;
                *(__m128i *)v3 = _mm_alignr_epi8(v182, v183, 6);
                v186 = *(__m128i *)(v4 + 26);
                v7 = _mm_cmpeq_epi8(v184, v186);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_144:
                  v199 = *(_DWORD *)(v4 + 6);
                  *(double *)v3 = *(double *)v4;
                  *(_DWORD *)(v3 + 6) = v199;
                  v9 = 10;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v186, v185, 6);
                v187 = v4 + 26;
                v188 = (v4 + 26) & 0xFFFFFFC0;
                v189 = v187 - v188;
                v4 = v188 - 10;
                v3 = v3 + 16 - v189;
                v11 += v189;
                v173 = *(__m128i *)(v4 - 6);
                while ( 1 )
                {
                  v174 = *(__m128i *)(v4 + 10);
                  v190 = *(__m128i *)(v4 + 26);
                  v191 = *(__m128i *)(v4 + 42);
                  v192 = *(__m128i *)(v4 + 58);
                  v193 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v191, v192), _mm_min_epu8(v190, v174)), v7));
                  v194 = v192;
                  v195 = _mm_alignr_epi8(v192, v191, 6);
                  v196 = _mm_alignr_epi8(v191, v190, 6);
                  if ( v193 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v481 = *(__m128i *)(v4 + 10);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v174, v173, 6);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 26), v481, 6);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v196;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v195;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 10;
                    v4 += v14 + 10;
                    v482 = *(_WORD *)(v4 - 2);
                    *(double *)(v3 - 10) = *(double *)(v4 - 10);
                    *(_WORD *)(v3 - 2) = v482;
                    v9 = 0;
                    goto LABEL_326;
                  }
                  v197 = _mm_alignr_epi8(v190, v174, 6);
                  v4 += 64;
                  v198 = _mm_alignr_epi8(v174, v173, 6);
                  v173 = v194;
                  *(__m128i *)(v3 + 48) = v195;
                  *(__m128i *)(v3 + 32) = v196;
                  *(__m128i *)(v3 + 16) = v197;
                  *(__m128i *)v3 = v198;
                  v3 += 64;
                }
              }
              v472 = *(_DWORD *)(v4 + 6);
              *(double *)v3 = *(double *)v4;
              *(_DWORD *)(v3 + 6) = v472;
              v9 = 10;
              if ( v8 )
                goto LABEL_292;
              break;
            default:
              v200 = *(__m128i *)(v4 - 7);
              v201 = *(__m128i *)(v4 + 9);
              while ( 1 )
              {
                v202 = _mm_cmpeq_epi8(v7, v201);
                v8 = _mm_movemask_epi8(v202);
                v203 = v201;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_157;
                v204 = _mm_alignr_epi8(v201, v200, 7);
                v205 = v203;
                *(__m128i *)v3 = v204;
                v206 = *(__m128i *)(v4 + 25);
                v207 = _mm_cmpeq_epi8(v202, v206);
                v3 += 16;
                v8 = _mm_movemask_epi8(v207);
                v4 += 16;
                v208 = v206;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_157;
                *(__m128i *)v3 = _mm_alignr_epi8(v206, v205, 7);
                v209 = *(__m128i *)(v4 + 25);
                v210 = v208;
                v211 = _mm_cmpeq_epi8(v207, v209);
                v3 += 16;
                v8 = _mm_movemask_epi8(v211);
                v4 += 16;
                v212 = v209;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                  goto LABEL_157;
                *(__m128i *)v3 = _mm_alignr_epi8(v209, v210, 7);
                v213 = *(__m128i *)(v4 + 25);
                v7 = _mm_cmpeq_epi8(v211, v213);
                v3 += 16;
                v8 = _mm_movemask_epi8(v7);
                v4 += 16;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( v10 )
                  break;
                if ( v8 )
                {
LABEL_157:
                  v226 = *(_DWORD *)(v4 + 5);
                  *(double *)v3 = *(double *)v4;
                  *(_DWORD *)(v3 + 5) = v226;
                  v9 = 9;
                  goto LABEL_269;
                }
                *(__m128i *)v3 = _mm_alignr_epi8(v213, v212, 7);
                v214 = v4 + 25;
                v215 = (v4 + 25) & 0xFFFFFFC0;
                v216 = v214 - v215;
                v4 = v215 - 9;
                v3 = v3 + 16 - v216;
                v11 += v216;
                v200 = *(__m128i *)(v4 - 7);
                while ( 1 )
                {
                  v201 = *(__m128i *)(v4 + 9);
                  v217 = *(__m128i *)(v4 + 25);
                  v218 = *(__m128i *)(v4 + 41);
                  v219 = *(__m128i *)(v4 + 57);
                  v220 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v218, v219), _mm_min_epu8(v217, v201)), v7));
                  v221 = v219;
                  v222 = _mm_alignr_epi8(v219, v218, 7);
                  v223 = _mm_alignr_epi8(v218, v217, 7);
                  if ( v220 )
                    break;
                  v10 = v11 <= 0x40;
                  v11 -= 64;
                  if ( v10 )
                  {
                    v483 = *(__m128i *)(v4 + 9);
                    v10 = ((int)(v11 + 48) < 0) ^ __OFADD__(48, v11) | (v11 == -48);
                    v11 += 48;
                    if ( !v10 )
                    {
                      *(__m128i *)v3 = _mm_alignr_epi8(v201, v200, 7);
                      v14 = 16;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 + 16) = _mm_alignr_epi8(*(__m128i *)(v4 + 25), v483, 7);
                        v14 = 32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 + 32) = v223;
                          v14 = 48;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 + 48) = v222;
                            v14 = 64;
                            v11 -= 16;
                          }
                        }
                      }
                    }
                    v3 += v14 + 9;
                    v4 += v14 + 9;
                    v484 = *(_BYTE *)(v4 - 1);
                    *(double *)(v3 - 9) = *(double *)(v4 - 9);
                    *(_BYTE *)(v3 - 1) = v484;
                    v9 = 0;
                    goto LABEL_326;
                  }
                  v224 = _mm_alignr_epi8(v217, v201, 7);
                  v4 += 64;
                  v225 = _mm_alignr_epi8(v201, v200, 7);
                  v200 = v221;
                  *(__m128i *)(v3 + 48) = v222;
                  *(__m128i *)(v3 + 32) = v223;
                  *(__m128i *)(v3 + 16) = v224;
                  *(__m128i *)v3 = v225;
                  v3 += 64;
                }
              }
              v473 = *(_DWORD *)(v4 + 5);
              *(double *)v3 = *(double *)v4;
              *(_DWORD *)(v3 + 5) = v473;
              v9 = 9;
              if ( !v8 )
                break;
LABEL_292:
              v435 = v11 + 16;
              v437 = v9 + v4;
              v436 = v9 + v3;
              if ( (_BYTE)v8 )
              {
                if ( v435 <= 8 )
                {
                  if ( (v8 & 1) != 0 || v435 == 1 )
                    goto LABEL_345;
                  if ( (v8 & 2) != 0 || v435 == 2 )
                    goto LABEL_347;
                  if ( (v8 & 4) != 0 || v435 == 3 )
                    goto LABEL_349;
                  if ( (v8 & 8) == 0 && v435 != 4 )
                  {
                    if ( (v8 & 0x10) != 0 || v435 == 5 )
                      goto LABEL_351;
                    if ( (v8 & 0x20) != 0 || v435 == 6 )
                      goto LABEL_353;
                    if ( (v8 & 0x40) != 0 || v435 == 7 )
                      goto LABEL_355;
LABEL_279:
                    *(double *)v436 = *(double *)v437;
                    result = a1;
                    v439 = v435 - 8;
                    v440 = v436 + 8;
                    if ( !v439 )
                      return result;
                    goto LABEL_403;
                  }
                  goto LABEL_274;
                }
LABEL_270:
                if ( (v8 & 0xF) == 0 )
                {
                  if ( (v8 & 0x10) != 0 )
                    goto LABEL_351;
                  if ( (v8 & 0x20) != 0 )
                    goto LABEL_353;
                  if ( (v8 & 0x40) != 0 )
                    goto LABEL_355;
                  goto LABEL_279;
                }
                if ( (v8 & 1) != 0 )
                  goto LABEL_345;
                if ( (v8 & 2) != 0 )
                  goto LABEL_347;
                if ( (v8 & 4) != 0 )
                  goto LABEL_349;
LABEL_274:
                *(_DWORD *)v436 = *(_DWORD *)v437;
                result = a1;
                v439 = v435 - 4;
                v440 = v436 + 4;
                if ( !v439 )
                  return result;
                goto LABEL_403;
              }
              if ( v435 <= 8 )
                goto LABEL_327;
              if ( (v8 & 0x100) != 0 || v435 == 9 )
                goto LABEL_357;
              if ( (v8 & 0x200) != 0 || v435 == 10 )
                goto LABEL_359;
              if ( (v8 & 0x400) != 0 || v435 == 11 )
                goto LABEL_361;
              if ( (v8 & 0x800) == 0 && v435 != 12 )
              {
                if ( (v8 & 0x1000) != 0 || v435 == 13 )
                  goto LABEL_363;
                if ( (v8 & 0x2000) != 0 || v435 == 14 )
                  goto LABEL_365;
                if ( (v8 & 0x4000) != 0 || v435 == 15 )
                  goto LABEL_367;
LABEL_290:
                *(__m128i *)v436 = _mm_loadu_si128((const __m128i *)v437);
                result = a1;
                v439 = v435 - 16;
                v440 = v436 + 16;
                if ( !v439 )
                  return result;
                goto LABEL_403;
              }
              goto LABEL_285;
          }
        }
LABEL_326:
        v435 = v11 + 16;
        v436 = v9 + v3;
        v437 = v9 + v4;
        if ( v435 <= 8 )
        {
LABEL_327:
          if ( v435 <= 4 )
          {
            if ( v435 != 1 )
            {
              if ( v435 != 2 )
              {
                if ( v435 != 3 )
                {
                  *(_DWORD *)v436 = *(_DWORD *)v437;
                  return a1;
                }
LABEL_349:
                *(_WORD *)v436 = *(_WORD *)v437;
                *(_BYTE *)(v436 + 2) = *(_BYTE *)(v437 + 2);
                result = a1;
                v439 = v435 - 3;
                v440 = v436 + 3;
                if ( !v439 )
                  return result;
                goto LABEL_403;
              }
LABEL_347:
              *(_WORD *)v436 = *(_WORD *)v437;
              result = a1;
              v439 = v435 - 2;
              v440 = v436 + 2;
              if ( !v439 )
                return result;
              goto LABEL_403;
            }
LABEL_345:
            *(_BYTE *)v436 = *(_BYTE *)v437;
            result = a1;
            v439 = v435 - 1;
            v440 = v436 + 1;
            if ( !v439 )
              return result;
            goto LABEL_403;
          }
          if ( v435 != 5 )
          {
            if ( v435 != 6 )
            {
              if ( v435 != 7 )
              {
                *(double *)v436 = *(double *)v437;
                return a1;
              }
LABEL_355:
              *(_DWORD *)v436 = *(_DWORD *)v437;
              *(_DWORD *)(v436 + 3) = *(_DWORD *)(v437 + 3);
              result = a1;
              v439 = v435 - 7;
              v440 = v436 + 7;
              if ( !v439 )
                return result;
              goto LABEL_403;
            }
LABEL_353:
            *(_DWORD *)v436 = *(_DWORD *)v437;
            *(_WORD *)(v436 + 4) = *(_WORD *)(v437 + 4);
            result = a1;
            v439 = v435 - 6;
            v440 = v436 + 6;
            if ( !v439 )
              return result;
            goto LABEL_403;
          }
LABEL_351:
          *(_DWORD *)v436 = *(_DWORD *)v437;
          *(_BYTE *)(v436 + 4) = *(_BYTE *)(v437 + 4);
          result = a1;
          v439 = v435 - 5;
          v440 = v436 + 5;
          if ( !v439 )
            return result;
          goto LABEL_403;
        }
        if ( v435 <= 0xC )
        {
          if ( v435 != 9 )
          {
            if ( v435 != 10 )
            {
              if ( v435 != 11 )
              {
                v442 = *(_DWORD *)(v437 + 8);
                *(double *)v436 = *(double *)v437;
                *(_DWORD *)(v436 + 8) = v442;
                return a1;
              }
LABEL_361:
              v446 = *(_DWORD *)(v437 + 7);
              *(double *)v436 = *(double *)v437;
              *(_DWORD *)(v436 + 7) = v446;
              result = a1;
              v439 = v435 - 11;
              v440 = v436 + 11;
              if ( !v439 )
                return result;
              goto LABEL_403;
            }
LABEL_359:
            v445 = *(_WORD *)(v437 + 8);
            *(double *)v436 = *(double *)v437;
            *(_WORD *)(v436 + 8) = v445;
            result = a1;
            v439 = v435 - 10;
            v440 = v436 + 10;
            if ( !v439 )
              return result;
            goto LABEL_403;
          }
LABEL_357:
          v444 = *(_BYTE *)(v437 + 8);
          *(double *)v436 = *(double *)v437;
          *(_BYTE *)(v436 + 8) = v444;
          result = a1;
          v439 = v435 - 9;
          v440 = v436 + 9;
          if ( !v439 )
            return result;
          goto LABEL_403;
        }
        if ( v435 != 13 )
        {
          if ( v435 != 14 )
          {
            if ( v435 != 15 )
            {
              v443 = *(double *)(v437 + 8);
              *(double *)v436 = *(double *)v437;
              *(double *)(v436 + 8) = v443;
              return a1;
            }
LABEL_367:
            v449 = *(double *)(v437 + 7);
            *(double *)v436 = *(double *)v437;
            *(double *)(v436 + 7) = v449;
            result = a1;
            v439 = v435 - 15;
            v440 = v436 + 15;
            if ( !v439 )
              return result;
            goto LABEL_403;
          }
LABEL_365:
          v448 = *(double *)(v437 + 6);
          *(double *)v436 = *(double *)v437;
          *(double *)(v436 + 6) = v448;
          result = a1;
          v439 = v435 - 14;
          v440 = v436 + 14;
          if ( !v439 )
            return result;
          goto LABEL_403;
        }
LABEL_363:
        v447 = *(double *)(v437 + 5);
        *(double *)v436 = *(double *)v437;
        *(double *)(v436 + 5) = v447;
        result = a1;
        v439 = v435 - 13;
        v440 = v436 + 13;
        if ( !v439 )
          return result;
        goto LABEL_403;
      }
      v15 = *(__m128i *)(v4 + 16);
      *(_OWORD *)v3 = *(_OWORD *)v4;
      v16 = _mm_cmpeq_epi8(v7, v15);
      v8 = _mm_movemask_epi8(v16);
      v9 = 16;
      v10 = v11 <= 0x10;
      v11 -= 16;
      if ( v10 )
        goto LABEL_325;
      if ( !v8 )
      {
        v17 = *(__m128i *)(v4 + 32);
        *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x10) = v15;
        v18 = _mm_cmpeq_epi8(v16, v17);
        v8 = _mm_movemask_epi8(v18);
        v9 = 32;
        v10 = v11 <= 0x10;
        v11 -= 16;
        if ( v10 )
          goto LABEL_325;
        if ( !v8 )
        {
          v19 = *(__m128i *)(v4 + 48);
          *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x20) = v17;
          v20 = _mm_cmpeq_epi8(v18, v19);
          v8 = _mm_movemask_epi8(v20);
          v9 = 48;
          v10 = v11 <= 0x10;
          v11 -= 16;
          if ( v10 )
            goto LABEL_325;
          if ( !v8 )
          {
            v21 = *(__m128i *)(v4 + 64);
            *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x30) = v19;
            v22 = _mm_cmpeq_epi8(v20, v21);
            v8 = _mm_movemask_epi8(v22);
            v9 = 64;
            v10 = v11 <= 0x10;
            v11 -= 16;
            if ( v10 )
              goto LABEL_325;
            if ( !v8 )
            {
              v23 = *(__m128i *)(v4 + 80);
              *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x40) = v21;
              v24 = _mm_cmpeq_epi8(v22, v23);
              v8 = _mm_movemask_epi8(v24);
              v9 = 80;
              v10 = v11 <= 0x10;
              v11 -= 16;
              if ( v10 )
                goto LABEL_325;
              if ( !v8 )
              {
                v25 = *(__m128i *)(v4 + 96);
                *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x50) = v23;
                v26 = _mm_cmpeq_epi8(v24, v25);
                v8 = _mm_movemask_epi8(v26);
                v9 = 96;
                v10 = v11 <= 0x10;
                v11 -= 16;
                if ( !v10 )
                {
                  if ( !v8 )
                  {
                    *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x60) = v25;
                    v27 = v4;
                    v4 = (v4 + 112) & 0xFFFFFFC0;
                    v28 = v27 - v4;
                    v3 -= v28;
                    v29 = v11 + v28 + 112;
                    v9 = -64;
                    while ( 1 )
                    {
                      v30 = *(__m128i *)v4;
                      v31 = *(__m128i *)(v4 + 16);
                      v32 = *(__m128i *)(v4 + 32);
                      v33 = *(__m128i *)(v4 + 48);
                      v3 += 64;
                      v34 = _mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v32, v33), _mm_min_epu8(*(__m128i *)v4, v31)), v26);
                      v4 += 64;
                      v35 = _mm_movemask_epi8(v34);
                      v10 = v29 <= 0x40;
                      v29 -= 64;
                      if ( v10 )
                        break;
                      if ( v35 )
                      {
                        v11 = v29 + 48;
                        v36 = _mm_cmpeq_epi8(v26, v30);
                        v8 = _mm_movemask_epi8(v36);
                        if ( !v8 )
                        {
                          v37 = _mm_cmpeq_epi8(v36, v31);
                          v11 -= 16;
                          v8 = _mm_movemask_epi8(v37);
                          *(__m128i *)(v3 - 64) = v30;
                          v9 = -48;
                          if ( !v8 )
                          {
                            v38 = _mm_cmpeq_epi8(v37, v32);
                            v11 -= 16;
                            v8 = _mm_movemask_epi8(v38);
                            *(__m128i *)(v3 - 48) = v31;
                            v9 = -32;
                            if ( !v8 )
                            {
                              *(__m128i *)(v3 - 32) = v32;
                              v11 -= 16;
                              LOWORD(v8) = _mm_movemask_epi8(_mm_cmpeq_epi8(v38, v33));
                              v9 = -16;
                            }
                          }
                        }
                        goto LABEL_269;
                      }
                      *(__m128i *)(v3 - 64) = v30;
                      *(__m128i *)(v3 - 48) = v31;
                      *(__m128i *)(v3 - 32) = v32;
                      *(__m128i *)(v3 - 16) = v33;
                    }
                    if ( !v35 )
                    {
                      v10 = ((int)(v29 + 48) < 0) ^ __OFADD__(48, v29) | (v29 == -48);
                      v11 = v29 + 48;
                      if ( !v10 )
                      {
                        *(__m128i *)(v3 - 64) = v30;
                        v9 = -48;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( !v10 )
                        {
                          *(__m128i *)(v3 - 48) = v31;
                          v9 = -32;
                          v10 = v11 <= 0x10;
                          v11 -= 16;
                          if ( !v10 )
                          {
                            *(__m128i *)(v3 - 32) = v32;
                            v9 = -16;
                            v11 -= 16;
                          }
                        }
                      }
                      goto LABEL_326;
                    }
                    v464 = _mm_cmpeq_epi8(v26, v30);
                    v8 = _mm_movemask_epi8(v464);
                    v10 = ((int)(v29 + 48) < 0) ^ __OFADD__(48, v29) | (v29 == -48);
                    v11 = v29 + 48;
                    if ( v10 )
                      goto LABEL_325;
                    if ( !v8 )
                    {
                      v465 = _mm_cmpeq_epi8(v464, v31);
                      v8 = _mm_movemask_epi8(v465);
                      *(__m128i *)(v3 - 64) = v30;
                      v9 = -48;
                      v10 = v11 <= 0x10;
                      v11 -= 16;
                      if ( v10 )
                        goto LABEL_325;
                      if ( !v8 )
                      {
                        v466 = _mm_cmpeq_epi8(v465, v32);
                        v8 = _mm_movemask_epi8(v466);
                        *(__m128i *)(v3 - 48) = v31;
                        v9 = -32;
                        v10 = v11 <= 0x10;
                        v11 -= 16;
                        if ( v10 )
                          goto LABEL_325;
                        if ( !v8 )
                        {
                          LOWORD(v8) = _mm_movemask_epi8(_mm_cmpeq_epi8(v466, v33));
                          *(__m128i *)(v3 - 32) = v32;
                          v9 = -16;
                          v11 -= 16;
                          goto LABEL_292;
                        }
                      }
                    }
                  }
                  goto LABEL_269;
                }
LABEL_325:
                if ( !v8 )
                  goto LABEL_326;
                goto LABEL_292;
              }
            }
          }
        }
      }
    }
LABEL_269:
    v435 = v11 + 16;
    v436 = v9 + v3;
    v437 = v9 + v4;
    if ( (_BYTE)v8 )
      goto LABEL_270;
    if ( (v8 & 0xF00) == 0 )
    {
      if ( (v8 & 0x1000) != 0 )
        goto LABEL_363;
      if ( (v8 & 0x2000) != 0 )
        goto LABEL_365;
      if ( (v8 & 0x4000) != 0 )
        goto LABEL_367;
      goto LABEL_290;
    }
    if ( (v8 & 0x100) != 0 )
      goto LABEL_357;
    if ( (v8 & 0x200) != 0 )
      goto LABEL_359;
    if ( (v8 & 0x400) != 0 )
      goto LABEL_361;
LABEL_285:
    v441 = *(_DWORD *)(v437 + 8);
    *(double *)v436 = *(double *)v437;
    *(_DWORD *)(v436 + 8) = v441;
    result = a1;
    v439 = v435 - 12;
    v440 = v436 + 12;
    if ( !v439 )
      return result;
    goto LABEL_403;
  }
  *(__m128i *)a1 = _mm_loadu_si128((const __m128i *)a2);
  result = a1;
  v439 = a3 - 16;
  v440 = a1 + 16;
  if ( a3 == 16 )
    return result;
LABEL_403:
  v10 = v439 <= 0x10;
  v450 = v439 - 16;
  if ( v10 )
    goto LABEL_382;
  *(_QWORD *)v440 = 0LL;
  *(_QWORD *)(v440 + 8) = 0LL;
  v451 = v440 + 16;
  v452 = v451 & 0xF;
  v440 = v451 - v452;
  v453 = v452 + v450;
  v454 = v453 < 0x40;
  for ( i = v453 - 64; !v454; i -= 64 )
  {
    *(_OWORD *)v440 = 0LL;
    *(_OWORD *)(v440 + 16) = 0LL;
    *(_OWORD *)(v440 + 32) = 0LL;
    *(_OWORD *)(v440 + 48) = 0LL;
    v440 += 64;
    v454 = i < 0x40;
  }
  v10 = ((int)(i + 32) < 0) ^ __OFADD__(32, i);
  v456 = i + 32;
  if ( !v10 )
  {
    *(_OWORD *)v440 = 0LL;
    *(_OWORD *)(v440 + 16) = 0LL;
    v440 += 32;
    v10 = v456 < 16;
    v450 = v456 - 16;
    if ( !v10 )
    {
      *(_OWORD *)v440 = 0LL;
      v440 += 16;
      goto LABEL_383;
    }
LABEL_382:
    v450 += 16;
    goto LABEL_383;
  }
  v10 = (v456 + 16 < 0) ^ __OFADD__(16, v456);
  v450 = v456 + 16;
  if ( v10 )
    goto LABEL_382;
  *(_OWORD *)v440 = 0LL;
  v440 += 16;
LABEL_383:
  if ( v450 )
  {
    if ( v450 == 16 )
    {
      *(_QWORD *)v440 = 0LL;
      *(_QWORD *)(v440 + 8) = 0LL;
    }
    else if ( v450 == 8 )
    {
      *(_QWORD *)v440 = 0LL;
    }
    else if ( v450 > 8 )
    {
      if ( v450 == 12 )
      {
        *(_QWORD *)v440 = 0LL;
        *(_DWORD *)(v440 + 8) = 0;
      }
      else if ( v450 < 12 )
      {
        if ( v450 < 10 )
        {
          *(_QWORD *)v440 = 0LL;
          *(_BYTE *)(v440 + 8) = 0;
        }
        else
        {
          *(_QWORD *)v440 = 0LL;
          if ( v450 == 10 )
            *(_WORD *)(v440 + 8) = 0;
          else
            *(_DWORD *)(v440 + 7) = 0;
        }
      }
      else if ( v450 < 14 )
      {
        *(_QWORD *)v440 = 0LL;
        *(_QWORD *)(v440 + 5) = 0LL;
      }
      else
      {
        *(_QWORD *)v440 = 0LL;
        if ( v450 == 14 )
          *(_QWORD *)(v440 + 6) = 0LL;
        else
          *(_QWORD *)(v440 + 7) = 0LL;
      }
    }
    else if ( v450 == 4 )
    {
      *(_DWORD *)v440 = 0;
    }
    else if ( v450 > 4 )
    {
      if ( v450 < 6 )
      {
        *(_DWORD *)v440 = 0;
        *(_BYTE *)(v440 + 4) = 0;
      }
      else
      {
        *(_DWORD *)v440 = 0;
        if ( v450 == 6 )
          *(_WORD *)(v440 + 4) = 0;
        else
          *(_DWORD *)(v440 + 3) = 0;
      }
    }
    else if ( v450 < 2 )
    {
      *(_BYTE *)v440 = 0;
    }
    else
    {
      *(_WORD *)v440 = 0;
      if ( v450 != 2 )
        *(_BYTE *)(v440 + 2) = 0;
    }
  }
  return result;
}
// 8076105: conditional instruction was optimized away because ebx.4==3
// 8076125: conditional instruction was optimized away because ebx.4 is in (==F|>=11)
// 8076136: conditional instruction was optimized away because ebx.4==7
// 807624C: conditional instruction was optimized away because %arg_8.4>=5u
// 80762D0: conditional instruction was optimized away because %arg_8.4>=9u
// 8076356: conditional instruction was optimized away because %arg_8.4>=Du
// 80763DA: conditional instruction was optimized away because %arg_8.4>=10u

//----- (08076E00) --------------------------------------------------------
unsigned int __cdecl _stpcpy_ssse3(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // edx
  unsigned int v3; // ecx
  __m128i *v4; // esi
  __m128i v5; // xmm0
  int v6; // eax
  int v7; // esi
  unsigned int v8; // eax
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  __m128i v11; // xmm3
  __m128i v12; // xmm0
  __m128i v13; // xmm4
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  __m128i v18; // xmm0
  __m128i v19; // xmm3
  __m128i v20; // xmm0
  __m128i v21; // xmm4
  __m128i v22; // xmm5
  __m128i v23; // xmm6
  __m128i v24; // xmm7
  __m128i v25; // xmm3
  __m128i v26; // xmm0
  __m128i v27; // xmm0
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  __m128i v30; // xmm2
  __m128i v31; // xmm0
  __m128i v32; // xmm3
  __m128i v33; // xmm2
  __m128i v34; // xmm1
  __m128i v35; // xmm2
  __m128i v36; // xmm0
  __m128i v37; // xmm3
  __m128i v38; // xmm2
  __m128i v39; // xmm1
  __m128i v40; // xmm0
  __m128i v41; // xmm3
  __m128i v42; // xmm2
  unsigned int v43; // eax
  unsigned int v44; // ecx
  unsigned int v45; // eax
  __m128i v46; // xmm3
  __m128i v47; // xmm4
  __m128i v48; // xmm5
  int v49; // eax
  __m128i v50; // xmm7
  __m128i v51; // xmm5
  __m128i v52; // xmm4
  __m128i v53; // xmm3
  __m128i v54; // xmm2
  __m128i v55; // xmm1
  __m128i v56; // xmm2
  __m128i v57; // xmm0
  __m128i v58; // xmm3
  __m128i v59; // xmm2
  __m128i v60; // xmm1
  __m128i v61; // xmm2
  __m128i v62; // xmm0
  __m128i v63; // xmm3
  __m128i v64; // xmm2
  __m128i v65; // xmm1
  __m128i v66; // xmm0
  __m128i v67; // xmm3
  __m128i v68; // xmm2
  unsigned int v69; // eax
  unsigned int v70; // ecx
  unsigned int v71; // eax
  __m128i v72; // xmm3
  __m128i v73; // xmm4
  __m128i v74; // xmm5
  int v75; // eax
  __m128i v76; // xmm7
  __m128i v77; // xmm5
  __m128i v78; // xmm4
  __m128i v79; // xmm3
  __m128i v80; // xmm2
  double v81; // xmm1_8
  __m128i v82; // xmm1
  __m128i v83; // xmm2
  __m128i v84; // xmm0
  __m128i v85; // xmm3
  __m128i v86; // xmm2
  __m128i v87; // xmm1
  __m128i v88; // xmm2
  __m128i v89; // xmm0
  __m128i v90; // xmm3
  __m128i v91; // xmm2
  __m128i v92; // xmm1
  __m128i v93; // xmm0
  __m128i v94; // xmm3
  __m128i v95; // xmm2
  unsigned int v96; // eax
  unsigned int v97; // ecx
  unsigned int v98; // eax
  __m128i v99; // xmm3
  __m128i v100; // xmm4
  __m128i v101; // xmm5
  int v102; // eax
  __m128i v103; // xmm7
  __m128i v104; // xmm5
  __m128i v105; // xmm4
  __m128i v106; // xmm3
  __m128i v107; // xmm2
  double v108; // xmm1_8
  __m128i v109; // xmm1
  __m128i v110; // xmm2
  __m128i v111; // xmm0
  __m128i v112; // xmm3
  __m128i v113; // xmm2
  __m128i v114; // xmm1
  __m128i v115; // xmm2
  __m128i v116; // xmm0
  __m128i v117; // xmm3
  __m128i v118; // xmm2
  __m128i v119; // xmm1
  __m128i v120; // xmm0
  __m128i v121; // xmm3
  __m128i v122; // xmm2
  unsigned int v123; // eax
  unsigned int v124; // ecx
  unsigned int v125; // eax
  __m128i v126; // xmm3
  __m128i v127; // xmm4
  __m128i v128; // xmm5
  int v129; // eax
  __m128i v130; // xmm7
  __m128i v131; // xmm5
  __m128i v132; // xmm4
  __m128i v133; // xmm3
  __m128i v134; // xmm2
  int v135; // esi
  __m128i v136; // xmm1
  __m128i v137; // xmm2
  __m128i v138; // xmm0
  __m128i v139; // xmm3
  __m128i v140; // xmm2
  __m128i v141; // xmm1
  __m128i v142; // xmm2
  __m128i v143; // xmm0
  __m128i v144; // xmm3
  __m128i v145; // xmm2
  __m128i v146; // xmm1
  __m128i v147; // xmm0
  __m128i v148; // xmm3
  __m128i v149; // xmm2
  unsigned int v150; // eax
  unsigned int v151; // ecx
  unsigned int v152; // eax
  __m128i v153; // xmm3
  __m128i v154; // xmm4
  __m128i v155; // xmm5
  int v156; // eax
  __m128i v157; // xmm7
  __m128i v158; // xmm5
  __m128i v159; // xmm4
  __m128i v160; // xmm3
  __m128i v161; // xmm2
  int v162; // esi
  __m128i v163; // xmm1
  __m128i v164; // xmm2
  __m128i v165; // xmm0
  __m128i v166; // xmm3
  __m128i v167; // xmm2
  __m128i v168; // xmm1
  __m128i v169; // xmm2
  __m128i v170; // xmm0
  __m128i v171; // xmm3
  __m128i v172; // xmm2
  __m128i v173; // xmm1
  __m128i v174; // xmm0
  __m128i v175; // xmm3
  __m128i v176; // xmm2
  unsigned int v177; // eax
  unsigned int v178; // ecx
  unsigned int v179; // eax
  __m128i v180; // xmm3
  __m128i v181; // xmm4
  __m128i v182; // xmm5
  int v183; // eax
  __m128i v184; // xmm7
  __m128i v185; // xmm5
  __m128i v186; // xmm4
  __m128i v187; // xmm3
  __m128i v188; // xmm2
  int v189; // esi
  __m128i v190; // xmm1
  __m128i v191; // xmm2
  __m128i v192; // xmm0
  __m128i v193; // xmm3
  __m128i v194; // xmm2
  __m128i v195; // xmm1
  __m128i v196; // xmm2
  __m128i v197; // xmm0
  __m128i v198; // xmm3
  __m128i v199; // xmm2
  __m128i v200; // xmm1
  __m128i v201; // xmm0
  __m128i v202; // xmm3
  __m128i v203; // xmm2
  unsigned int v204; // eax
  unsigned int v205; // ecx
  unsigned int v206; // eax
  __m128i v207; // xmm3
  __m128i v208; // xmm4
  __m128i v209; // xmm5
  int v210; // eax
  __m128i v211; // xmm7
  __m128i v212; // xmm5
  __m128i v213; // xmm4
  __m128i v214; // xmm3
  __m128i v215; // xmm2
  int v216; // esi
  __m128i v217; // xmm1
  __m128i v218; // xmm2
  __m128i v219; // xmm0
  __m128i v220; // xmm3
  __m128i v221; // xmm2
  __m128i v222; // xmm1
  __m128i v223; // xmm2
  __m128i v224; // xmm0
  __m128i v225; // xmm3
  __m128i v226; // xmm2
  __m128i v227; // xmm1
  __m128i v228; // xmm0
  __m128i v229; // xmm3
  __m128i v230; // xmm2
  unsigned int v231; // eax
  unsigned int v232; // ecx
  unsigned int v233; // eax
  __m128i v234; // xmm3
  __m128i v235; // xmm4
  __m128i v236; // xmm5
  int v237; // eax
  __m128i v238; // xmm7
  __m128i v239; // xmm5
  __m128i v240; // xmm4
  __m128i v241; // xmm3
  __m128i v242; // xmm2
  __m128i v243; // xmm1
  __m128i v244; // xmm2
  __m128i v245; // xmm0
  __m128i v246; // xmm3
  __m128i v247; // xmm2
  __m128i v248; // xmm1
  __m128i v249; // xmm2
  __m128i v250; // xmm0
  __m128i v251; // xmm3
  __m128i v252; // xmm2
  __m128i v253; // xmm1
  __m128i v254; // xmm0
  __m128i v255; // xmm3
  __m128i v256; // xmm2
  unsigned int v257; // eax
  unsigned int v258; // ecx
  unsigned int v259; // eax
  __m128i v260; // xmm3
  __m128i v261; // xmm4
  __m128i v262; // xmm5
  int v263; // eax
  __m128i v264; // xmm7
  __m128i v265; // xmm5
  __m128i v266; // xmm4
  __m128i v267; // xmm3
  __m128i v268; // xmm2
  __m128i v269; // xmm1
  __m128i v270; // xmm2
  __m128i v271; // xmm0
  __m128i v272; // xmm3
  __m128i v273; // xmm2
  __m128i v274; // xmm1
  __m128i v275; // xmm2
  __m128i v276; // xmm0
  __m128i v277; // xmm3
  __m128i v278; // xmm2
  __m128i v279; // xmm1
  __m128i v280; // xmm0
  __m128i v281; // xmm3
  __m128i v282; // xmm2
  unsigned int v283; // eax
  unsigned int v284; // ecx
  unsigned int v285; // eax
  __m128i v286; // xmm3
  __m128i v287; // xmm4
  __m128i v288; // xmm5
  int v289; // eax
  __m128i v290; // xmm7
  __m128i v291; // xmm5
  __m128i v292; // xmm4
  __m128i v293; // xmm3
  __m128i v294; // xmm2
  __m128i v295; // xmm1
  __m128i v296; // xmm2
  __m128i v297; // xmm0
  __m128i v298; // xmm3
  __m128i v299; // xmm2
  __m128i v300; // xmm1
  __m128i v301; // xmm2
  __m128i v302; // xmm0
  __m128i v303; // xmm3
  __m128i v304; // xmm2
  __m128i v305; // xmm1
  __m128i v306; // xmm0
  __m128i v307; // xmm3
  __m128i v308; // xmm2
  unsigned int v309; // eax
  unsigned int v310; // ecx
  unsigned int v311; // eax
  __m128i v312; // xmm3
  __m128i v313; // xmm4
  __m128i v314; // xmm5
  int v315; // eax
  __m128i v316; // xmm7
  __m128i v317; // xmm5
  __m128i v318; // xmm4
  __m128i v319; // xmm3
  __m128i v320; // xmm2
  __m128i v321; // xmm1
  __m128i v322; // xmm2
  __m128i v323; // xmm0
  __m128i v324; // xmm3
  __m128i v325; // xmm2
  __m128i v326; // xmm1
  __m128i v327; // xmm2
  __m128i v328; // xmm0
  __m128i v329; // xmm3
  __m128i v330; // xmm2
  __m128i v331; // xmm1
  __m128i v332; // xmm0
  __m128i v333; // xmm3
  __m128i v334; // xmm2
  unsigned int v335; // eax
  unsigned int v336; // ecx
  unsigned int v337; // eax
  __m128i v338; // xmm3
  __m128i v339; // xmm4
  __m128i v340; // xmm5
  int v341; // eax
  __m128i v342; // xmm7
  __m128i v343; // xmm5
  __m128i v344; // xmm4
  __m128i v345; // xmm3
  __m128i v346; // xmm2
  __m128i v347; // xmm1
  __m128i v348; // xmm2
  __m128i v349; // xmm0
  __m128i v350; // xmm3
  __m128i v351; // xmm2
  __m128i v352; // xmm1
  __m128i v353; // xmm2
  __m128i v354; // xmm0
  __m128i v355; // xmm3
  __m128i v356; // xmm2
  __m128i v357; // xmm1
  __m128i v358; // xmm0
  __m128i v359; // xmm3
  __m128i v360; // xmm2
  unsigned int v361; // eax
  unsigned int v362; // ecx
  unsigned int v363; // eax
  __m128i v364; // xmm3
  __m128i v365; // xmm4
  __m128i v366; // xmm5
  int v367; // eax
  __m128i v368; // xmm7
  __m128i v369; // xmm5
  __m128i v370; // xmm4
  __m128i v371; // xmm3
  __m128i v372; // xmm2
  __m128i v373; // xmm1
  __m128i v374; // xmm2
  __m128i v375; // xmm0
  __m128i v376; // xmm3
  __m128i v377; // xmm2
  __m128i v378; // xmm1
  __m128i v379; // xmm2
  __m128i v380; // xmm0
  __m128i v381; // xmm3
  __m128i v382; // xmm2
  __m128i v383; // xmm1
  __m128i v384; // xmm0
  __m128i v385; // xmm3
  __m128i v386; // xmm2
  unsigned int v387; // eax
  unsigned int v388; // ecx
  unsigned int v389; // eax
  __m128i v390; // xmm3
  __m128i v391; // xmm4
  __m128i v392; // xmm5
  int v393; // eax
  __m128i v394; // xmm7
  __m128i v395; // xmm5
  __m128i v396; // xmm4
  __m128i v397; // xmm3
  __m128i v398; // xmm2
  __m128i v399; // xmm1
  __m128i v400; // xmm2
  __m128i v401; // xmm0
  __m128i v402; // xmm3
  __m128i v403; // xmm2
  __m128i v404; // xmm1
  __m128i v405; // xmm2
  __m128i v406; // xmm0
  __m128i v407; // xmm3
  __m128i v408; // xmm2
  __m128i v409; // xmm1
  __m128i v410; // xmm0
  __m128i v411; // xmm3
  __m128i v412; // xmm2
  unsigned int v413; // eax
  unsigned int v414; // ecx
  unsigned int v415; // eax
  __m128i v416; // xmm3
  __m128i v417; // xmm4
  __m128i v418; // xmm5
  int v419; // eax
  __m128i v420; // xmm7
  __m128i v421; // xmm5
  __m128i v422; // xmm4
  __m128i v423; // xmm3
  __m128i v424; // xmm2
  unsigned int v425; // edx
  unsigned int v426; // ecx
  int v428; // eax
  char v429; // al
  __int16 v430; // ax
  int v431; // eax
  double v432; // xmm1_8
  double v433; // xmm1_8
  double v434; // xmm1_8
  char v435; // al
  __int16 v436; // ax
  int v437; // eax
  int v438; // eax
  double v439; // xmm1_8
  double v440; // xmm1_8
  double v441; // xmm1_8

  v2 = a1;
  v3 = a2;
  if ( *(_BYTE *)a2 )
  {
    if ( *(_BYTE *)(a2 + 1) )
    {
      if ( *(_BYTE *)(a2 + 2) )
      {
        if ( *(_BYTE *)(a2 + 3) )
        {
          if ( *(_BYTE *)(a2 + 4) )
          {
            if ( *(_BYTE *)(a2 + 5) )
            {
              if ( *(_BYTE *)(a2 + 6) )
              {
                if ( *(_BYTE *)(a2 + 7) )
                {
                  if ( *(_BYTE *)(a2 + 8) )
                  {
                    if ( *(_BYTE *)(a2 + 9) )
                    {
                      if ( *(_BYTE *)(a2 + 10) )
                      {
                        if ( *(_BYTE *)(a2 + 11) )
                        {
                          if ( *(_BYTE *)(a2 + 12) )
                          {
                            if ( *(_BYTE *)(a2 + 13) )
                            {
                              if ( *(_BYTE *)(a2 + 14) )
                              {
                                if ( *(_BYTE *)(a2 + 15) )
                                {
                                  v4 = (__m128i *)((a2 + 16) & 0xFFFFFFF0);
                                  *(double *)a1 = *(double *)a2;
                                  v5 = _mm_cmpeq_epi8((__m128i)0LL, *v4);
                                  *(double *)(a1 + 8) = *(double *)(a2 + 8);
                                  v6 = _mm_movemask_epi8(v5);
                                  v7 = (int)v4->m128i_i32 - a2;
                                  if ( !v6 )
                                  {
                                    v2 = (a1 + 16) & 0xFFFFFFF0;
                                    v3 = a2 - (a1 - v2);
                                    v8 = v3 & 0xF;
                                    if ( (v3 & 0xF) != 0 )
                                    {
                                      if ( v8 >= 8 )
                                      {
                                        switch ( v8 )
                                        {
                                          case 8u:
                                            v217 = *(__m128i *)(v3 - 8);
                                            v218 = *(__m128i *)(v3 + 8);
                                            while ( 1 )
                                            {
                                              v219 = _mm_cmpeq_epi8(v5, v218);
                                              v6 = _mm_movemask_epi8(v219);
                                              v220 = v218;
                                              if ( v6 )
                                                break;
                                              v221 = _mm_alignr_epi8(v218, v217, 8);
                                              v222 = v220;
                                              *(__m128i *)v2 = v221;
                                              v223 = *(__m128i *)(v3 + 24);
                                              v224 = _mm_cmpeq_epi8(v219, v223);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v224);
                                              v3 += 16;
                                              v225 = v223;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v223, v222, 8);
                                              v226 = *(__m128i *)(v3 + 24);
                                              v227 = v225;
                                              v228 = _mm_cmpeq_epi8(v224, v226);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v228);
                                              v3 += 16;
                                              v229 = v226;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v226, v227, 8);
                                              v230 = *(__m128i *)(v3 + 24);
                                              v5 = _mm_cmpeq_epi8(v228, v230);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v230, v229, 8);
                                              v231 = v3 + 24;
                                              v232 = (v3 + 24) & 0xFFFFFFC0;
                                              v233 = v231 - v232;
                                              v3 = v232 - 8;
                                              v2 = v2 + 16 - v233;
                                              v217 = *(__m128i *)(v3 - 8);
                                              while ( 1 )
                                              {
                                                v218 = *(__m128i *)(v3 + 8);
                                                v234 = *(__m128i *)(v3 + 24);
                                                v235 = *(__m128i *)(v3 + 40);
                                                v236 = *(__m128i *)(v3 + 56);
                                                v237 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v235, v236),
                                                             _mm_min_epu8(v234, v218)),
                                                           v5));
                                                v238 = v236;
                                                v239 = _mm_alignr_epi8(v236, v235, 8);
                                                v240 = _mm_alignr_epi8(v235, v234, 8);
                                                if ( v237 )
                                                  break;
                                                v241 = _mm_alignr_epi8(v234, v218, 8);
                                                v3 += 64;
                                                v242 = _mm_alignr_epi8(v218, v217, 8);
                                                v217 = v238;
                                                *(__m128i *)(v2 + 48) = v239;
                                                *(__m128i *)(v2 + 32) = v240;
                                                *(__m128i *)(v2 + 16) = v241;
                                                *(__m128i *)v2 = v242;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)v2 = *(double *)v3;
                                            v7 = 8;
                                            break;
                                          case 9u:
                                            v243 = *(__m128i *)(v3 - 9);
                                            v244 = *(__m128i *)(v3 + 7);
                                            while ( 1 )
                                            {
                                              v245 = _mm_cmpeq_epi8(v5, v244);
                                              v6 = _mm_movemask_epi8(v245);
                                              v246 = v244;
                                              if ( v6 )
                                                break;
                                              v247 = _mm_alignr_epi8(v244, v243, 9);
                                              v248 = v246;
                                              *(__m128i *)v2 = v247;
                                              v249 = *(__m128i *)(v3 + 23);
                                              v250 = _mm_cmpeq_epi8(v245, v249);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v250);
                                              v3 += 16;
                                              v251 = v249;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v249, v248, 9);
                                              v252 = *(__m128i *)(v3 + 23);
                                              v253 = v251;
                                              v254 = _mm_cmpeq_epi8(v250, v252);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v254);
                                              v3 += 16;
                                              v255 = v252;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v252, v253, 9);
                                              v256 = *(__m128i *)(v3 + 23);
                                              v5 = _mm_cmpeq_epi8(v254, v256);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v256, v255, 9);
                                              v257 = v3 + 23;
                                              v258 = (v3 + 23) & 0xFFFFFFC0;
                                              v259 = v257 - v258;
                                              v3 = v258 - 7;
                                              v2 = v2 + 16 - v259;
                                              v243 = *(__m128i *)(v3 - 9);
                                              while ( 1 )
                                              {
                                                v244 = *(__m128i *)(v3 + 7);
                                                v260 = *(__m128i *)(v3 + 23);
                                                v261 = *(__m128i *)(v3 + 39);
                                                v262 = *(__m128i *)(v3 + 55);
                                                v263 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v261, v262),
                                                             _mm_min_epu8(v260, v244)),
                                                           v5));
                                                v264 = v262;
                                                v265 = _mm_alignr_epi8(v262, v261, 9);
                                                v266 = _mm_alignr_epi8(v261, v260, 9);
                                                if ( v263 )
                                                  break;
                                                v267 = _mm_alignr_epi8(v260, v244, 9);
                                                v3 += 64;
                                                v268 = _mm_alignr_epi8(v244, v243, 9);
                                                v243 = v264;
                                                *(__m128i *)(v2 + 48) = v265;
                                                *(__m128i *)(v2 + 32) = v266;
                                                *(__m128i *)(v2 + 16) = v267;
                                                *(__m128i *)v2 = v268;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)(v2 - 1) = *(double *)(v3 - 1);
                                            v7 = 7;
                                            break;
                                          case 0xAu:
                                            v269 = *(__m128i *)(v3 - 10);
                                            v270 = *(__m128i *)(v3 + 6);
                                            while ( 1 )
                                            {
                                              v271 = _mm_cmpeq_epi8(v5, v270);
                                              v6 = _mm_movemask_epi8(v271);
                                              v272 = v270;
                                              if ( v6 )
                                                break;
                                              v273 = _mm_alignr_epi8(v270, v269, 10);
                                              v274 = v272;
                                              *(__m128i *)v2 = v273;
                                              v275 = *(__m128i *)(v3 + 22);
                                              v276 = _mm_cmpeq_epi8(v271, v275);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v276);
                                              v3 += 16;
                                              v277 = v275;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v275, v274, 10);
                                              v278 = *(__m128i *)(v3 + 22);
                                              v279 = v277;
                                              v280 = _mm_cmpeq_epi8(v276, v278);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v280);
                                              v3 += 16;
                                              v281 = v278;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v278, v279, 10);
                                              v282 = *(__m128i *)(v3 + 22);
                                              v5 = _mm_cmpeq_epi8(v280, v282);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v282, v281, 10);
                                              v283 = v3 + 22;
                                              v284 = (v3 + 22) & 0xFFFFFFC0;
                                              v285 = v283 - v284;
                                              v3 = v284 - 6;
                                              v2 = v2 + 16 - v285;
                                              v269 = *(__m128i *)(v3 - 10);
                                              while ( 1 )
                                              {
                                                v270 = *(__m128i *)(v3 + 6);
                                                v286 = *(__m128i *)(v3 + 22);
                                                v287 = *(__m128i *)(v3 + 38);
                                                v288 = *(__m128i *)(v3 + 54);
                                                v289 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v287, v288),
                                                             _mm_min_epu8(v286, v270)),
                                                           v5));
                                                v290 = v288;
                                                v291 = _mm_alignr_epi8(v288, v287, 10);
                                                v292 = _mm_alignr_epi8(v287, v286, 10);
                                                if ( v289 )
                                                  break;
                                                v293 = _mm_alignr_epi8(v286, v270, 10);
                                                v3 += 64;
                                                v294 = _mm_alignr_epi8(v270, v269, 10);
                                                v269 = v290;
                                                *(__m128i *)(v2 + 48) = v291;
                                                *(__m128i *)(v2 + 32) = v292;
                                                *(__m128i *)(v2 + 16) = v293;
                                                *(__m128i *)v2 = v294;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)(v2 - 2) = *(double *)(v3 - 2);
                                            v7 = 6;
                                            break;
                                          case 0xBu:
                                            v295 = *(__m128i *)(v3 - 11);
                                            v296 = *(__m128i *)(v3 + 5);
                                            while ( 1 )
                                            {
                                              v297 = _mm_cmpeq_epi8(v5, v296);
                                              v6 = _mm_movemask_epi8(v297);
                                              v298 = v296;
                                              if ( v6 )
                                                break;
                                              v299 = _mm_alignr_epi8(v296, v295, 11);
                                              v300 = v298;
                                              *(__m128i *)v2 = v299;
                                              v301 = *(__m128i *)(v3 + 21);
                                              v302 = _mm_cmpeq_epi8(v297, v301);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v302);
                                              v3 += 16;
                                              v303 = v301;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v301, v300, 11);
                                              v304 = *(__m128i *)(v3 + 21);
                                              v305 = v303;
                                              v306 = _mm_cmpeq_epi8(v302, v304);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v306);
                                              v3 += 16;
                                              v307 = v304;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v304, v305, 11);
                                              v308 = *(__m128i *)(v3 + 21);
                                              v5 = _mm_cmpeq_epi8(v306, v308);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v308, v307, 11);
                                              v309 = v3 + 21;
                                              v310 = (v3 + 21) & 0xFFFFFFC0;
                                              v311 = v309 - v310;
                                              v3 = v310 - 5;
                                              v2 = v2 + 16 - v311;
                                              v295 = *(__m128i *)(v3 - 11);
                                              while ( 1 )
                                              {
                                                v296 = *(__m128i *)(v3 + 5);
                                                v312 = *(__m128i *)(v3 + 21);
                                                v313 = *(__m128i *)(v3 + 37);
                                                v314 = *(__m128i *)(v3 + 53);
                                                v315 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v313, v314),
                                                             _mm_min_epu8(v312, v296)),
                                                           v5));
                                                v316 = v314;
                                                v317 = _mm_alignr_epi8(v314, v313, 11);
                                                v318 = _mm_alignr_epi8(v313, v312, 11);
                                                if ( v315 )
                                                  break;
                                                v319 = _mm_alignr_epi8(v312, v296, 11);
                                                v3 += 64;
                                                v320 = _mm_alignr_epi8(v296, v295, 11);
                                                v295 = v316;
                                                *(__m128i *)(v2 + 48) = v317;
                                                *(__m128i *)(v2 + 32) = v318;
                                                *(__m128i *)(v2 + 16) = v319;
                                                *(__m128i *)v2 = v320;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)(v2 - 3) = *(double *)(v3 - 3);
                                            v7 = 5;
                                            break;
                                          case 0xCu:
                                            v321 = *(__m128i *)(v3 - 12);
                                            v322 = *(__m128i *)(v3 + 4);
                                            while ( 1 )
                                            {
                                              v323 = _mm_cmpeq_epi8(v5, v322);
                                              v6 = _mm_movemask_epi8(v323);
                                              v324 = v322;
                                              if ( v6 )
                                                break;
                                              v325 = _mm_alignr_epi8(v322, v321, 12);
                                              v326 = v324;
                                              *(__m128i *)v2 = v325;
                                              v327 = *(__m128i *)(v3 + 20);
                                              v328 = _mm_cmpeq_epi8(v323, v327);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v328);
                                              v3 += 16;
                                              v329 = v327;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v327, v326, 12);
                                              v330 = *(__m128i *)(v3 + 20);
                                              v331 = v329;
                                              v332 = _mm_cmpeq_epi8(v328, v330);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v332);
                                              v3 += 16;
                                              v333 = v330;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v330, v331, 12);
                                              v334 = *(__m128i *)(v3 + 20);
                                              v5 = _mm_cmpeq_epi8(v332, v334);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v334, v333, 12);
                                              v335 = v3 + 20;
                                              v336 = (v3 + 20) & 0xFFFFFFC0;
                                              v337 = v335 - v336;
                                              v3 = v336 - 4;
                                              v2 = v2 + 16 - v337;
                                              v321 = *(__m128i *)(v3 - 12);
                                              while ( 1 )
                                              {
                                                v322 = *(__m128i *)(v3 + 4);
                                                v338 = *(__m128i *)(v3 + 20);
                                                v339 = *(__m128i *)(v3 + 36);
                                                v340 = *(__m128i *)(v3 + 52);
                                                v341 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v339, v340),
                                                             _mm_min_epu8(v338, v322)),
                                                           v5));
                                                v342 = v340;
                                                v343 = _mm_alignr_epi8(v340, v339, 12);
                                                v344 = _mm_alignr_epi8(v339, v338, 12);
                                                if ( v341 )
                                                  break;
                                                v345 = _mm_alignr_epi8(v338, v322, 12);
                                                v3 += 64;
                                                v346 = _mm_alignr_epi8(v322, v321, 12);
                                                v321 = v342;
                                                *(__m128i *)(v2 + 48) = v343;
                                                *(__m128i *)(v2 + 32) = v344;
                                                *(__m128i *)(v2 + 16) = v345;
                                                *(__m128i *)v2 = v346;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)v2 = *(_DWORD *)v3;
                                            v7 = 4;
                                            break;
                                          case 0xDu:
                                            v347 = *(__m128i *)(v3 - 13);
                                            v348 = *(__m128i *)(v3 + 3);
                                            while ( 1 )
                                            {
                                              v349 = _mm_cmpeq_epi8(v5, v348);
                                              v6 = _mm_movemask_epi8(v349);
                                              v350 = v348;
                                              if ( v6 )
                                                break;
                                              v351 = _mm_alignr_epi8(v348, v347, 13);
                                              v352 = v350;
                                              *(__m128i *)v2 = v351;
                                              v353 = *(__m128i *)(v3 + 19);
                                              v354 = _mm_cmpeq_epi8(v349, v353);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v354);
                                              v3 += 16;
                                              v355 = v353;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v353, v352, 13);
                                              v356 = *(__m128i *)(v3 + 19);
                                              v357 = v355;
                                              v358 = _mm_cmpeq_epi8(v354, v356);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v358);
                                              v3 += 16;
                                              v359 = v356;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v356, v357, 13);
                                              v360 = *(__m128i *)(v3 + 19);
                                              v5 = _mm_cmpeq_epi8(v358, v360);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v360, v359, 13);
                                              v361 = v3 + 19;
                                              v362 = (v3 + 19) & 0xFFFFFFC0;
                                              v363 = v361 - v362;
                                              v3 = v362 - 3;
                                              v2 = v2 + 16 - v363;
                                              v347 = *(__m128i *)(v3 - 13);
                                              while ( 1 )
                                              {
                                                v348 = *(__m128i *)(v3 + 3);
                                                v364 = *(__m128i *)(v3 + 19);
                                                v365 = *(__m128i *)(v3 + 35);
                                                v366 = *(__m128i *)(v3 + 51);
                                                v367 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v365, v366),
                                                             _mm_min_epu8(v364, v348)),
                                                           v5));
                                                v368 = v366;
                                                v369 = _mm_alignr_epi8(v366, v365, 13);
                                                v370 = _mm_alignr_epi8(v365, v364, 13);
                                                if ( v367 )
                                                  break;
                                                v371 = _mm_alignr_epi8(v364, v348, 13);
                                                v3 += 64;
                                                v372 = _mm_alignr_epi8(v348, v347, 13);
                                                v347 = v368;
                                                *(__m128i *)(v2 + 48) = v369;
                                                *(__m128i *)(v2 + 32) = v370;
                                                *(__m128i *)(v2 + 16) = v371;
                                                *(__m128i *)v2 = v372;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)(v2 - 1) = *(_DWORD *)(v3 - 1);
                                            v7 = 3;
                                            break;
                                          case 0xEu:
                                            v373 = *(__m128i *)(v3 - 14);
                                            v374 = *(__m128i *)(v3 + 2);
                                            while ( 1 )
                                            {
                                              v375 = _mm_cmpeq_epi8(v5, v374);
                                              v6 = _mm_movemask_epi8(v375);
                                              v376 = v374;
                                              if ( v6 )
                                                break;
                                              v377 = _mm_alignr_epi8(v374, v373, 14);
                                              v378 = v376;
                                              *(__m128i *)v2 = v377;
                                              v379 = *(__m128i *)(v3 + 18);
                                              v380 = _mm_cmpeq_epi8(v375, v379);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v380);
                                              v3 += 16;
                                              v381 = v379;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v379, v378, 14);
                                              v382 = *(__m128i *)(v3 + 18);
                                              v383 = v381;
                                              v384 = _mm_cmpeq_epi8(v380, v382);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v384);
                                              v3 += 16;
                                              v385 = v382;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v382, v383, 14);
                                              v386 = *(__m128i *)(v3 + 18);
                                              v5 = _mm_cmpeq_epi8(v384, v386);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v386, v385, 14);
                                              v387 = v3 + 18;
                                              v388 = (v3 + 18) & 0xFFFFFFC0;
                                              v389 = v387 - v388;
                                              v3 = v388 - 2;
                                              v2 = v2 + 16 - v389;
                                              v373 = *(__m128i *)(v3 - 14);
                                              while ( 1 )
                                              {
                                                v374 = *(__m128i *)(v3 + 2);
                                                v390 = *(__m128i *)(v3 + 18);
                                                v391 = *(__m128i *)(v3 + 34);
                                                v392 = *(__m128i *)(v3 + 50);
                                                v393 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v391, v392),
                                                             _mm_min_epu8(v390, v374)),
                                                           v5));
                                                v394 = v392;
                                                v395 = _mm_alignr_epi8(v392, v391, 14);
                                                v396 = _mm_alignr_epi8(v391, v390, 14);
                                                if ( v393 )
                                                  break;
                                                v397 = _mm_alignr_epi8(v390, v374, 14);
                                                v3 += 64;
                                                v398 = _mm_alignr_epi8(v374, v373, 14);
                                                v373 = v394;
                                                *(__m128i *)(v2 + 48) = v395;
                                                *(__m128i *)(v2 + 32) = v396;
                                                *(__m128i *)(v2 + 16) = v397;
                                                *(__m128i *)v2 = v398;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)(v2 - 2) = *(_DWORD *)(v3 - 2);
                                            v7 = 2;
                                            break;
                                          default:
                                            v399 = *(__m128i *)(v3 - 15);
                                            v400 = *(__m128i *)(v3 + 1);
                                            while ( 1 )
                                            {
                                              v401 = _mm_cmpeq_epi8(v5, v400);
                                              v6 = _mm_movemask_epi8(v401);
                                              v402 = v400;
                                              if ( v6 )
                                                break;
                                              v403 = _mm_alignr_epi8(v400, v399, 15);
                                              v404 = v402;
                                              *(__m128i *)v2 = v403;
                                              v405 = *(__m128i *)(v3 + 17);
                                              v406 = _mm_cmpeq_epi8(v401, v405);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v406);
                                              v3 += 16;
                                              v407 = v405;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v405, v404, 15);
                                              v408 = *(__m128i *)(v3 + 17);
                                              v409 = v407;
                                              v410 = _mm_cmpeq_epi8(v406, v408);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v410);
                                              v3 += 16;
                                              v411 = v408;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v408, v409, 15);
                                              v412 = *(__m128i *)(v3 + 17);
                                              v5 = _mm_cmpeq_epi8(v410, v412);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v412, v411, 15);
                                              v413 = v3 + 17;
                                              v414 = (v3 + 17) & 0xFFFFFFC0;
                                              v415 = v413 - v414;
                                              v3 = v414 - 1;
                                              v2 = v2 + 16 - v415;
                                              v399 = *(__m128i *)(v3 - 15);
                                              while ( 1 )
                                              {
                                                v400 = *(__m128i *)(v3 + 1);
                                                v416 = *(__m128i *)(v3 + 17);
                                                v417 = *(__m128i *)(v3 + 33);
                                                v418 = *(__m128i *)(v3 + 49);
                                                v419 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v417, v418),
                                                             _mm_min_epu8(v416, v400)),
                                                           v5));
                                                v420 = v418;
                                                v421 = _mm_alignr_epi8(v418, v417, 15);
                                                v422 = _mm_alignr_epi8(v417, v416, 15);
                                                if ( v419 )
                                                  break;
                                                v423 = _mm_alignr_epi8(v416, v400, 15);
                                                v3 += 64;
                                                v424 = _mm_alignr_epi8(v400, v399, 15);
                                                v399 = v420;
                                                *(__m128i *)(v2 + 48) = v421;
                                                *(__m128i *)(v2 + 32) = v422;
                                                *(__m128i *)(v2 + 16) = v423;
                                                *(__m128i *)v2 = v424;
                                                v2 += 64;
                                              }
                                            }
                                            *(_DWORD *)(v2 - 3) = *(_DWORD *)(v3 - 3);
                                            v7 = 1;
                                            break;
                                        }
                                      }
                                      else
                                      {
                                        switch ( v8 )
                                        {
                                          case 1u:
                                            v29 = *(__m128i *)(v3 - 1);
                                            v30 = *(__m128i *)(v3 + 15);
                                            while ( 1 )
                                            {
                                              v31 = _mm_cmpeq_epi8(v5, v30);
                                              v6 = _mm_movemask_epi8(v31);
                                              v32 = v30;
                                              if ( v6 )
                                                break;
                                              v33 = _mm_alignr_epi8(v30, v29, 1);
                                              v34 = v32;
                                              *(__m128i *)v2 = v33;
                                              v35 = *(__m128i *)(v3 + 31);
                                              v36 = _mm_cmpeq_epi8(v31, v35);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v36);
                                              v3 += 16;
                                              v37 = v35;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v35, v34, 1);
                                              v38 = *(__m128i *)(v3 + 31);
                                              v39 = v37;
                                              v40 = _mm_cmpeq_epi8(v36, v38);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v40);
                                              v3 += 16;
                                              v41 = v38;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v38, v39, 1);
                                              v42 = *(__m128i *)(v3 + 31);
                                              v5 = _mm_cmpeq_epi8(v40, v42);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v42, v41, 1);
                                              v43 = v3 + 31;
                                              v44 = (v3 + 31) & 0xFFFFFFC0;
                                              v45 = v43 - v44;
                                              v3 = v44 - 15;
                                              v2 = v2 + 16 - v45;
                                              v29 = *(__m128i *)(v3 - 1);
                                              while ( 1 )
                                              {
                                                v30 = *(__m128i *)(v3 + 15);
                                                v46 = *(__m128i *)(v3 + 31);
                                                v47 = *(__m128i *)(v3 + 47);
                                                v48 = *(__m128i *)(v3 + 63);
                                                v49 = _mm_movemask_epi8(
                                                        _mm_cmpeq_epi8(
                                                          _mm_min_epu8(_mm_min_epu8(v47, v48), _mm_min_epu8(v46, v30)),
                                                          v5));
                                                v50 = v48;
                                                v51 = _mm_alignr_epi8(v48, v47, 1);
                                                v52 = _mm_alignr_epi8(v47, v46, 1);
                                                if ( v49 )
                                                  break;
                                                v53 = _mm_alignr_epi8(v46, v30, 1);
                                                v3 += 64;
                                                v54 = _mm_alignr_epi8(v30, v29, 1);
                                                v29 = v50;
                                                *(__m128i *)(v2 + 48) = v51;
                                                *(__m128i *)(v2 + 32) = v52;
                                                *(__m128i *)(v2 + 16) = v53;
                                                *(__m128i *)v2 = v54;
                                                v2 += 64;
                                              }
                                            }
                                            *(double *)v2 = *(double *)v3;
                                            *(double *)(v2 + 7) = *(double *)(v3 + 7);
                                            v7 = 15;
                                            break;
                                          case 2u:
                                            v55 = *(__m128i *)(v3 - 2);
                                            v56 = *(__m128i *)(v3 + 14);
                                            while ( 1 )
                                            {
                                              v57 = _mm_cmpeq_epi8(v5, v56);
                                              v6 = _mm_movemask_epi8(v57);
                                              v58 = v56;
                                              if ( v6 )
                                                break;
                                              v59 = _mm_alignr_epi8(v56, v55, 2);
                                              v60 = v58;
                                              *(__m128i *)v2 = v59;
                                              v61 = *(__m128i *)(v3 + 30);
                                              v62 = _mm_cmpeq_epi8(v57, v61);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v62);
                                              v3 += 16;
                                              v63 = v61;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v61, v60, 2);
                                              v64 = *(__m128i *)(v3 + 30);
                                              v65 = v63;
                                              v66 = _mm_cmpeq_epi8(v62, v64);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v66);
                                              v3 += 16;
                                              v67 = v64;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v64, v65, 2);
                                              v68 = *(__m128i *)(v3 + 30);
                                              v5 = _mm_cmpeq_epi8(v66, v68);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v68, v67, 2);
                                              v69 = v3 + 30;
                                              v70 = (v3 + 30) & 0xFFFFFFC0;
                                              v71 = v69 - v70;
                                              v3 = v70 - 14;
                                              v2 = v2 + 16 - v71;
                                              v55 = *(__m128i *)(v3 - 2);
                                              while ( 1 )
                                              {
                                                v56 = *(__m128i *)(v3 + 14);
                                                v72 = *(__m128i *)(v3 + 30);
                                                v73 = *(__m128i *)(v3 + 46);
                                                v74 = *(__m128i *)(v3 + 62);
                                                v75 = _mm_movemask_epi8(
                                                        _mm_cmpeq_epi8(
                                                          _mm_min_epu8(_mm_min_epu8(v73, v74), _mm_min_epu8(v72, v56)),
                                                          v5));
                                                v76 = v74;
                                                v77 = _mm_alignr_epi8(v74, v73, 2);
                                                v78 = _mm_alignr_epi8(v73, v72, 2);
                                                if ( v75 )
                                                  break;
                                                v79 = _mm_alignr_epi8(v72, v56, 2);
                                                v3 += 64;
                                                v80 = _mm_alignr_epi8(v56, v55, 2);
                                                v55 = v76;
                                                *(__m128i *)(v2 + 48) = v77;
                                                *(__m128i *)(v2 + 32) = v78;
                                                *(__m128i *)(v2 + 16) = v79;
                                                *(__m128i *)v2 = v80;
                                                v2 += 64;
                                              }
                                            }
                                            v81 = *(double *)(v3 + 6);
                                            *(double *)v2 = *(double *)v3;
                                            *(double *)(v2 + 6) = v81;
                                            v7 = 14;
                                            break;
                                          case 3u:
                                            v82 = *(__m128i *)(v3 - 3);
                                            v83 = *(__m128i *)(v3 + 13);
                                            while ( 1 )
                                            {
                                              v84 = _mm_cmpeq_epi8(v5, v83);
                                              v6 = _mm_movemask_epi8(v84);
                                              v85 = v83;
                                              if ( v6 )
                                                break;
                                              v86 = _mm_alignr_epi8(v83, v82, 3);
                                              v87 = v85;
                                              *(__m128i *)v2 = v86;
                                              v88 = *(__m128i *)(v3 + 29);
                                              v89 = _mm_cmpeq_epi8(v84, v88);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v89);
                                              v3 += 16;
                                              v90 = v88;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v88, v87, 3);
                                              v91 = *(__m128i *)(v3 + 29);
                                              v92 = v90;
                                              v93 = _mm_cmpeq_epi8(v89, v91);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v93);
                                              v3 += 16;
                                              v94 = v91;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v91, v92, 3);
                                              v95 = *(__m128i *)(v3 + 29);
                                              v5 = _mm_cmpeq_epi8(v93, v95);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v95, v94, 3);
                                              v96 = v3 + 29;
                                              v97 = (v3 + 29) & 0xFFFFFFC0;
                                              v98 = v96 - v97;
                                              v3 = v97 - 13;
                                              v2 = v2 + 16 - v98;
                                              v82 = *(__m128i *)(v3 - 3);
                                              while ( 1 )
                                              {
                                                v83 = *(__m128i *)(v3 + 13);
                                                v99 = *(__m128i *)(v3 + 29);
                                                v100 = *(__m128i *)(v3 + 45);
                                                v101 = *(__m128i *)(v3 + 61);
                                                v102 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v100, v101),
                                                             _mm_min_epu8(v99, v83)),
                                                           v5));
                                                v103 = v101;
                                                v104 = _mm_alignr_epi8(v101, v100, 3);
                                                v105 = _mm_alignr_epi8(v100, v99, 3);
                                                if ( v102 )
                                                  break;
                                                v106 = _mm_alignr_epi8(v99, v83, 3);
                                                v3 += 64;
                                                v107 = _mm_alignr_epi8(v83, v82, 3);
                                                v82 = v103;
                                                *(__m128i *)(v2 + 48) = v104;
                                                *(__m128i *)(v2 + 32) = v105;
                                                *(__m128i *)(v2 + 16) = v106;
                                                *(__m128i *)v2 = v107;
                                                v2 += 64;
                                              }
                                            }
                                            v108 = *(double *)(v3 + 5);
                                            *(double *)v2 = *(double *)v3;
                                            *(double *)(v2 + 5) = v108;
                                            v7 = 13;
                                            break;
                                          case 4u:
                                            v109 = *(__m128i *)(v3 - 4);
                                            v110 = *(__m128i *)(v3 + 12);
                                            while ( 1 )
                                            {
                                              v111 = _mm_cmpeq_epi8(v5, v110);
                                              v6 = _mm_movemask_epi8(v111);
                                              v112 = v110;
                                              if ( v6 )
                                                break;
                                              v113 = _mm_alignr_epi8(v110, v109, 4);
                                              v114 = v112;
                                              *(__m128i *)v2 = v113;
                                              v115 = *(__m128i *)(v3 + 28);
                                              v116 = _mm_cmpeq_epi8(v111, v115);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v116);
                                              v3 += 16;
                                              v117 = v115;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v115, v114, 4);
                                              v118 = *(__m128i *)(v3 + 28);
                                              v119 = v117;
                                              v120 = _mm_cmpeq_epi8(v116, v118);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v120);
                                              v3 += 16;
                                              v121 = v118;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v118, v119, 4);
                                              v122 = *(__m128i *)(v3 + 28);
                                              v5 = _mm_cmpeq_epi8(v120, v122);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v122, v121, 4);
                                              v123 = v3 + 28;
                                              v124 = (v3 + 28) & 0xFFFFFFC0;
                                              v125 = v123 - v124;
                                              v3 = v124 - 12;
                                              v2 = v2 + 16 - v125;
                                              v109 = *(__m128i *)(v3 - 4);
                                              while ( 1 )
                                              {
                                                v110 = *(__m128i *)(v3 + 12);
                                                v126 = *(__m128i *)(v3 + 28);
                                                v127 = *(__m128i *)(v3 + 44);
                                                v128 = *(__m128i *)(v3 + 60);
                                                v129 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v127, v128),
                                                             _mm_min_epu8(v126, v110)),
                                                           v5));
                                                v130 = v128;
                                                v131 = _mm_alignr_epi8(v128, v127, 4);
                                                v132 = _mm_alignr_epi8(v127, v126, 4);
                                                if ( v129 )
                                                  break;
                                                v133 = _mm_alignr_epi8(v126, v110, 4);
                                                v3 += 64;
                                                v134 = _mm_alignr_epi8(v110, v109, 4);
                                                v109 = v130;
                                                *(__m128i *)(v2 + 48) = v131;
                                                *(__m128i *)(v2 + 32) = v132;
                                                *(__m128i *)(v2 + 16) = v133;
                                                *(__m128i *)v2 = v134;
                                                v2 += 64;
                                              }
                                            }
                                            v135 = *(_DWORD *)(v3 + 8);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 8) = v135;
                                            v7 = 12;
                                            break;
                                          case 5u:
                                            v136 = *(__m128i *)(v3 - 5);
                                            v137 = *(__m128i *)(v3 + 11);
                                            while ( 1 )
                                            {
                                              v138 = _mm_cmpeq_epi8(v5, v137);
                                              v6 = _mm_movemask_epi8(v138);
                                              v139 = v137;
                                              if ( v6 )
                                                break;
                                              v140 = _mm_alignr_epi8(v137, v136, 5);
                                              v141 = v139;
                                              *(__m128i *)v2 = v140;
                                              v142 = *(__m128i *)(v3 + 27);
                                              v143 = _mm_cmpeq_epi8(v138, v142);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v143);
                                              v3 += 16;
                                              v144 = v142;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v142, v141, 5);
                                              v145 = *(__m128i *)(v3 + 27);
                                              v146 = v144;
                                              v147 = _mm_cmpeq_epi8(v143, v145);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v147);
                                              v3 += 16;
                                              v148 = v145;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v145, v146, 5);
                                              v149 = *(__m128i *)(v3 + 27);
                                              v5 = _mm_cmpeq_epi8(v147, v149);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v149, v148, 5);
                                              v150 = v3 + 27;
                                              v151 = (v3 + 27) & 0xFFFFFFC0;
                                              v152 = v150 - v151;
                                              v3 = v151 - 11;
                                              v2 = v2 + 16 - v152;
                                              v136 = *(__m128i *)(v3 - 5);
                                              while ( 1 )
                                              {
                                                v137 = *(__m128i *)(v3 + 11);
                                                v153 = *(__m128i *)(v3 + 27);
                                                v154 = *(__m128i *)(v3 + 43);
                                                v155 = *(__m128i *)(v3 + 59);
                                                v156 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v154, v155),
                                                             _mm_min_epu8(v153, v137)),
                                                           v5));
                                                v157 = v155;
                                                v158 = _mm_alignr_epi8(v155, v154, 5);
                                                v159 = _mm_alignr_epi8(v154, v153, 5);
                                                if ( v156 )
                                                  break;
                                                v160 = _mm_alignr_epi8(v153, v137, 5);
                                                v3 += 64;
                                                v161 = _mm_alignr_epi8(v137, v136, 5);
                                                v136 = v157;
                                                *(__m128i *)(v2 + 48) = v158;
                                                *(__m128i *)(v2 + 32) = v159;
                                                *(__m128i *)(v2 + 16) = v160;
                                                *(__m128i *)v2 = v161;
                                                v2 += 64;
                                              }
                                            }
                                            v162 = *(_DWORD *)(v3 + 7);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 7) = v162;
                                            v7 = 11;
                                            break;
                                          case 6u:
                                            v163 = *(__m128i *)(v3 - 6);
                                            v164 = *(__m128i *)(v3 + 10);
                                            while ( 1 )
                                            {
                                              v165 = _mm_cmpeq_epi8(v5, v164);
                                              v6 = _mm_movemask_epi8(v165);
                                              v166 = v164;
                                              if ( v6 )
                                                break;
                                              v167 = _mm_alignr_epi8(v164, v163, 6);
                                              v168 = v166;
                                              *(__m128i *)v2 = v167;
                                              v169 = *(__m128i *)(v3 + 26);
                                              v170 = _mm_cmpeq_epi8(v165, v169);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v170);
                                              v3 += 16;
                                              v171 = v169;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v169, v168, 6);
                                              v172 = *(__m128i *)(v3 + 26);
                                              v173 = v171;
                                              v174 = _mm_cmpeq_epi8(v170, v172);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v174);
                                              v3 += 16;
                                              v175 = v172;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v172, v173, 6);
                                              v176 = *(__m128i *)(v3 + 26);
                                              v5 = _mm_cmpeq_epi8(v174, v176);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v176, v175, 6);
                                              v177 = v3 + 26;
                                              v178 = (v3 + 26) & 0xFFFFFFC0;
                                              v179 = v177 - v178;
                                              v3 = v178 - 10;
                                              v2 = v2 + 16 - v179;
                                              v163 = *(__m128i *)(v3 - 6);
                                              while ( 1 )
                                              {
                                                v164 = *(__m128i *)(v3 + 10);
                                                v180 = *(__m128i *)(v3 + 26);
                                                v181 = *(__m128i *)(v3 + 42);
                                                v182 = *(__m128i *)(v3 + 58);
                                                v183 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v181, v182),
                                                             _mm_min_epu8(v180, v164)),
                                                           v5));
                                                v184 = v182;
                                                v185 = _mm_alignr_epi8(v182, v181, 6);
                                                v186 = _mm_alignr_epi8(v181, v180, 6);
                                                if ( v183 )
                                                  break;
                                                v187 = _mm_alignr_epi8(v180, v164, 6);
                                                v3 += 64;
                                                v188 = _mm_alignr_epi8(v164, v163, 6);
                                                v163 = v184;
                                                *(__m128i *)(v2 + 48) = v185;
                                                *(__m128i *)(v2 + 32) = v186;
                                                *(__m128i *)(v2 + 16) = v187;
                                                *(__m128i *)v2 = v188;
                                                v2 += 64;
                                              }
                                            }
                                            v189 = *(_DWORD *)(v3 + 6);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 6) = v189;
                                            v7 = 10;
                                            break;
                                          default:
                                            v190 = *(__m128i *)(v3 - 7);
                                            v191 = *(__m128i *)(v3 + 9);
                                            while ( 1 )
                                            {
                                              v192 = _mm_cmpeq_epi8(v5, v191);
                                              v6 = _mm_movemask_epi8(v192);
                                              v193 = v191;
                                              if ( v6 )
                                                break;
                                              v194 = _mm_alignr_epi8(v191, v190, 7);
                                              v195 = v193;
                                              *(__m128i *)v2 = v194;
                                              v196 = *(__m128i *)(v3 + 25);
                                              v197 = _mm_cmpeq_epi8(v192, v196);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v197);
                                              v3 += 16;
                                              v198 = v196;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v196, v195, 7);
                                              v199 = *(__m128i *)(v3 + 25);
                                              v200 = v198;
                                              v201 = _mm_cmpeq_epi8(v197, v199);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v201);
                                              v3 += 16;
                                              v202 = v199;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v199, v200, 7);
                                              v203 = *(__m128i *)(v3 + 25);
                                              v5 = _mm_cmpeq_epi8(v201, v203);
                                              v2 += 16;
                                              v6 = _mm_movemask_epi8(v5);
                                              v3 += 16;
                                              if ( v6 )
                                                break;
                                              *(__m128i *)v2 = _mm_alignr_epi8(v203, v202, 7);
                                              v204 = v3 + 25;
                                              v205 = (v3 + 25) & 0xFFFFFFC0;
                                              v206 = v204 - v205;
                                              v3 = v205 - 9;
                                              v2 = v2 + 16 - v206;
                                              v190 = *(__m128i *)(v3 - 7);
                                              while ( 1 )
                                              {
                                                v191 = *(__m128i *)(v3 + 9);
                                                v207 = *(__m128i *)(v3 + 25);
                                                v208 = *(__m128i *)(v3 + 41);
                                                v209 = *(__m128i *)(v3 + 57);
                                                v210 = _mm_movemask_epi8(
                                                         _mm_cmpeq_epi8(
                                                           _mm_min_epu8(
                                                             _mm_min_epu8(v208, v209),
                                                             _mm_min_epu8(v207, v191)),
                                                           v5));
                                                v211 = v209;
                                                v212 = _mm_alignr_epi8(v209, v208, 7);
                                                v213 = _mm_alignr_epi8(v208, v207, 7);
                                                if ( v210 )
                                                  break;
                                                v214 = _mm_alignr_epi8(v207, v191, 7);
                                                v3 += 64;
                                                v215 = _mm_alignr_epi8(v191, v190, 7);
                                                v190 = v211;
                                                *(__m128i *)(v2 + 48) = v212;
                                                *(__m128i *)(v2 + 32) = v213;
                                                *(__m128i *)(v2 + 16) = v214;
                                                *(__m128i *)v2 = v215;
                                                v2 += 64;
                                              }
                                            }
                                            v216 = *(_DWORD *)(v3 + 5);
                                            *(double *)v2 = *(double *)v3;
                                            *(_DWORD *)(v2 + 5) = v216;
                                            v7 = 9;
                                            break;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      v9 = *(__m128i *)(v3 + 16);
                                      *(_OWORD *)v2 = *(_OWORD *)v3;
                                      v10 = _mm_cmpeq_epi8(v5, v9);
                                      v6 = _mm_movemask_epi8(v10);
                                      v7 = 16;
                                      if ( !v6 )
                                      {
                                        v11 = *(__m128i *)(v3 + 32);
                                        *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x10) = v9;
                                        v12 = _mm_cmpeq_epi8(v10, v11);
                                        v6 = _mm_movemask_epi8(v12);
                                        v7 = 32;
                                        if ( !v6 )
                                        {
                                          v13 = *(__m128i *)(v3 + 48);
                                          *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x20) = v11;
                                          v14 = _mm_cmpeq_epi8(v12, v13);
                                          v6 = _mm_movemask_epi8(v14);
                                          v7 = 48;
                                          if ( !v6 )
                                          {
                                            v15 = *(__m128i *)(v3 + 64);
                                            *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x30) = v13;
                                            v16 = _mm_cmpeq_epi8(v14, v15);
                                            v6 = _mm_movemask_epi8(v16);
                                            v7 = 64;
                                            if ( !v6 )
                                            {
                                              v17 = *(__m128i *)(v3 + 80);
                                              *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x40) = v15;
                                              v18 = _mm_cmpeq_epi8(v16, v17);
                                              v6 = _mm_movemask_epi8(v18);
                                              v7 = 80;
                                              if ( !v6 )
                                              {
                                                v19 = *(__m128i *)(v3 + 96);
                                                *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x50) = v17;
                                                v20 = _mm_cmpeq_epi8(v18, v19);
                                                v6 = _mm_movemask_epi8(v20);
                                                v7 = 96;
                                                if ( !v6 )
                                                {
                                                  *(__m128i *)(((a1 + 16) & 0xFFFFFFF0) + 0x60) = v19;
                                                  v3 = (v3 + 112) & 0xFFFFFFC0;
                                                  v2 = v3 - (a2 - a1);
                                                  v7 = -64;
                                                  while ( 1 )
                                                  {
                                                    v21 = *(__m128i *)v3;
                                                    v22 = *(__m128i *)(v3 + 16);
                                                    v23 = *(__m128i *)(v3 + 32);
                                                    v24 = *(__m128i *)(v3 + 48);
                                                    v2 += 64;
                                                    v25 = _mm_cmpeq_epi8(
                                                            _mm_min_epu8(
                                                              _mm_min_epu8(v23, v24),
                                                              _mm_min_epu8(*(__m128i *)v3, v22)),
                                                            v20);
                                                    v3 += 64;
                                                    if ( _mm_movemask_epi8(v25) )
                                                      break;
                                                    *(__m128i *)(v2 - 64) = v21;
                                                    *(__m128i *)(v2 - 48) = v22;
                                                    *(__m128i *)(v2 - 32) = v23;
                                                    *(__m128i *)(v2 - 16) = v24;
                                                  }
                                                  v26 = _mm_cmpeq_epi8(v20, v21);
                                                  v6 = _mm_movemask_epi8(v26);
                                                  if ( !v6 )
                                                  {
                                                    v27 = _mm_cmpeq_epi8(v26, v22);
                                                    v6 = _mm_movemask_epi8(v27);
                                                    *(__m128i *)(v2 - 64) = v21;
                                                    v7 = -48;
                                                    if ( !v6 )
                                                    {
                                                      v28 = _mm_cmpeq_epi8(v27, v23);
                                                      v6 = _mm_movemask_epi8(v28);
                                                      *(__m128i *)(v2 - 48) = v22;
                                                      v7 = -32;
                                                      if ( !v6 )
                                                      {
                                                        *(__m128i *)(v2 - 32) = v23;
                                                        LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v28, v24));
                                                        v7 = -16;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  v425 = v7 + v2;
                                  v426 = v7 + v3;
                                  if ( (_BYTE)v6 )
                                  {
                                    if ( (v6 & 0xF) != 0 )
                                    {
                                      if ( (v6 & 1) != 0 )
                                      {
                                        *(_BYTE *)v425 = *(_BYTE *)v426;
                                        return v425;
                                      }
                                      else if ( (v6 & 2) != 0 )
                                      {
                                        *(_WORD *)v425 = *(_WORD *)v426;
                                        return v425 + 1;
                                      }
                                      else if ( (v6 & 4) != 0 )
                                      {
                                        *(_WORD *)v425 = *(_WORD *)v426;
                                        *(_BYTE *)(v425 + 2) = *(_BYTE *)(v426 + 2);
                                        return v425 + 2;
                                      }
                                      else
                                      {
                                        *(_DWORD *)v425 = *(_DWORD *)v426;
                                        return v425 + 3;
                                      }
                                    }
                                    else if ( (v6 & 0x10) != 0 )
                                    {
                                      *(_DWORD *)v425 = *(_DWORD *)v426;
                                      *(_BYTE *)(v425 + 4) = *(_BYTE *)(v426 + 4);
                                      return v425 + 4;
                                    }
                                    else if ( (v6 & 0x20) != 0 )
                                    {
                                      *(_DWORD *)v425 = *(_DWORD *)v426;
                                      *(_WORD *)(v425 + 4) = *(_WORD *)(v426 + 4);
                                      return v425 + 5;
                                    }
                                    else if ( (v6 & 0x40) != 0 )
                                    {
                                      *(_DWORD *)v425 = *(_DWORD *)v426;
                                      *(_DWORD *)(v425 + 3) = *(_DWORD *)(v426 + 3);
                                      return v425 + 6;
                                    }
                                    else
                                    {
                                      *(double *)v425 = *(double *)v426;
                                      return v425 + 7;
                                    }
                                  }
                                  else if ( (v6 & 0xF00) != 0 )
                                  {
                                    if ( (v6 & 0x100) != 0 )
                                    {
                                      v429 = *(_BYTE *)(v426 + 8);
                                      *(double *)v425 = *(double *)v426;
                                      *(_BYTE *)(v425 + 8) = v429;
                                      return v425 + 8;
                                    }
                                    else if ( (v6 & 0x200) != 0 )
                                    {
                                      v430 = *(_WORD *)(v426 + 8);
                                      *(double *)v425 = *(double *)v426;
                                      *(_WORD *)(v425 + 8) = v430;
                                      return v425 + 9;
                                    }
                                    else if ( (v6 & 0x400) != 0 )
                                    {
                                      v431 = *(_DWORD *)(v426 + 7);
                                      *(double *)v425 = *(double *)v426;
                                      *(_DWORD *)(v425 + 7) = v431;
                                      return v425 + 10;
                                    }
                                    else
                                    {
                                      v428 = *(_DWORD *)(v426 + 8);
                                      *(double *)v425 = *(double *)v426;
                                      *(_DWORD *)(v425 + 8) = v428;
                                      return v425 + 11;
                                    }
                                  }
                                  else if ( (v6 & 0x1000) != 0 )
                                  {
                                    v432 = *(double *)(v426 + 5);
                                    *(double *)v425 = *(double *)v426;
                                    *(double *)(v425 + 5) = v432;
                                    return v425 + 12;
                                  }
                                  else if ( (v6 & 0x2000) != 0 )
                                  {
                                    v433 = *(double *)(v426 + 6);
                                    *(double *)v425 = *(double *)v426;
                                    *(double *)(v425 + 6) = v433;
                                    return v425 + 13;
                                  }
                                  else if ( (v6 & 0x4000) != 0 )
                                  {
                                    v434 = *(double *)(v426 + 7);
                                    *(double *)v425 = *(double *)v426;
                                    *(double *)(v425 + 7) = v434;
                                    return v425 + 14;
                                  }
                                  else
                                  {
                                    *(__m128i *)v425 = _mm_loadu_si128((const __m128i *)v426);
                                    return v425 + 15;
                                  }
                                }
                                else
                                {
                                  *(__m128i *)a1 = _mm_loadu_si128((const __m128i *)a2);
                                  return a1 + 15;
                                }
                              }
                              else
                              {
                                v441 = *(double *)(a2 + 7);
                                *(double *)a1 = *(double *)a2;
                                *(double *)(a1 + 7) = v441;
                                return a1 + 14;
                              }
                            }
                            else
                            {
                              v440 = *(double *)(a2 + 6);
                              *(double *)a1 = *(double *)a2;
                              *(double *)(a1 + 6) = v440;
                              return a1 + 13;
                            }
                          }
                          else
                          {
                            v439 = *(double *)(a2 + 5);
                            *(double *)a1 = *(double *)a2;
                            *(double *)(a1 + 5) = v439;
                            return a1 + 12;
                          }
                        }
                        else
                        {
                          v438 = *(_DWORD *)(a2 + 8);
                          *(double *)a1 = *(double *)a2;
                          *(_DWORD *)(a1 + 8) = v438;
                          return a1 + 11;
                        }
                      }
                      else
                      {
                        v437 = *(_DWORD *)(a2 + 7);
                        *(double *)a1 = *(double *)a2;
                        *(_DWORD *)(a1 + 7) = v437;
                        return a1 + 10;
                      }
                    }
                    else
                    {
                      v436 = *(_WORD *)(a2 + 8);
                      *(double *)a1 = *(double *)a2;
                      *(_WORD *)(a1 + 8) = v436;
                      return a1 + 9;
                    }
                  }
                  else
                  {
                    v435 = *(_BYTE *)(a2 + 8);
                    *(double *)a1 = *(double *)a2;
                    *(_BYTE *)(a1 + 8) = v435;
                    return a1 + 8;
                  }
                }
                else
                {
                  *(double *)a1 = *(double *)a2;
                  return a1 + 7;
                }
              }
              else
              {
                *(_DWORD *)a1 = *(_DWORD *)a2;
                *(_DWORD *)(a1 + 3) = *(_DWORD *)(a2 + 3);
                return a1 + 6;
              }
            }
            else
            {
              *(_DWORD *)a1 = *(_DWORD *)a2;
              *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
              return a1 + 5;
            }
          }
          else
          {
            *(_DWORD *)a1 = *(_DWORD *)a2;
            *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
            return a1 + 4;
          }
        }
        else
        {
          *(_DWORD *)a1 = *(_DWORD *)a2;
          return a1 + 3;
        }
      }
      else
      {
        *(_WORD *)a1 = *(_WORD *)a2;
        *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
        return a1 + 2;
      }
    }
    else
    {
      *(_WORD *)a1 = *(_WORD *)a2;
      return a1 + 1;
    }
  }
  else
  {
    *(_BYTE *)a1 = *(_BYTE *)a2;
    return a1;
  }
}

//----- (08078670) --------------------------------------------------------
int __cdecl _strcpy_sse2(int a1, unsigned int a2)
{
  __m128i *v2; // edx
  unsigned int v3; // ecx
  __m128i *v4; // ebx
  __m128i v5; // xmm0
  int v6; // eax
  int v7; // ebx
  __m128i v8; // xmm2
  __m128i v9; // xmm0
  __m128i v10; // xmm3
  __m128i v11; // xmm0
  __m128i v12; // xmm4
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  __m128i v15; // xmm0
  __m128i v16; // xmm2
  __m128i v17; // xmm0
  __m128i v18; // xmm3
  __m128i v19; // xmm0
  unsigned int v20; // ecx
  __m128i *v21; // edx
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm6
  __m128i v25; // xmm7
  __m128i v26; // xmm2
  __m128i v27; // xmm3
  __m128i v28; // xmm0
  __m128i v29; // xmm0
  __m128i v30; // xmm0
  __int8 *v31; // edx
  unsigned int v32; // ecx

  v2 = (__m128i *)a1;
  v3 = a2;
  if ( *(_BYTE *)a2 )
  {
    if ( *(_BYTE *)(a2 + 1) )
    {
      if ( *(_BYTE *)(a2 + 2) )
      {
        if ( *(_BYTE *)(a2 + 3) )
        {
          if ( *(_BYTE *)(a2 + 4) )
          {
            if ( *(_BYTE *)(a2 + 5) )
            {
              if ( *(_BYTE *)(a2 + 6) )
              {
                if ( *(_BYTE *)(a2 + 7) )
                {
                  if ( *(_BYTE *)(a2 + 8) )
                  {
                    if ( *(_BYTE *)(a2 + 9) )
                    {
                      if ( *(_BYTE *)(a2 + 10) )
                      {
                        if ( *(_BYTE *)(a2 + 11) )
                        {
                          if ( *(_BYTE *)(a2 + 12) )
                          {
                            if ( *(_BYTE *)(a2 + 13) )
                            {
                              if ( *(_BYTE *)(a2 + 14) )
                              {
                                if ( *(_BYTE *)(a2 + 15) )
                                {
                                  v4 = (__m128i *)((a2 + 16) & 0xFFFFFFF0);
                                  *(__m128i *)a1 = _mm_loadu_si128((const __m128i *)a2);
                                  v5 = _mm_cmpeq_epi8((__m128i)0LL, *v4);
                                  v6 = _mm_movemask_epi8(v5);
                                  v7 = (int)v4->m128i_i32 - a2;
                                  if ( !v6 )
                                  {
                                    v3 = (a2 + 16) & 0xFFFFFFF0;
                                    v2 = (__m128i *)(a1 - (a2 - v3));
                                    v8 = *(__m128i *)(v3 + 0x10);
                                    *v2 = _mm_load_si128((const __m128i *)v3);
                                    v9 = _mm_cmpeq_epi8(v5, v8);
                                    v6 = _mm_movemask_epi8(v9);
                                    v7 = 16;
                                    if ( !v6 )
                                    {
                                      v10 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x20);
                                      v2[1] = v8;
                                      v11 = _mm_cmpeq_epi8(v9, v10);
                                      v6 = _mm_movemask_epi8(v11);
                                      v7 = 32;
                                      if ( !v6 )
                                      {
                                        v12 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x30);
                                        v2[2] = v10;
                                        v13 = _mm_cmpeq_epi8(v11, v12);
                                        v6 = _mm_movemask_epi8(v13);
                                        v7 = 48;
                                        if ( !v6 )
                                        {
                                          v14 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x40);
                                          v2[3] = v12;
                                          v15 = _mm_cmpeq_epi8(v13, v14);
                                          v6 = _mm_movemask_epi8(v15);
                                          v7 = 64;
                                          if ( !v6 )
                                          {
                                            v16 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x50);
                                            v2[4] = v14;
                                            v17 = _mm_cmpeq_epi8(v15, v16);
                                            v6 = _mm_movemask_epi8(v17);
                                            v7 = 80;
                                            if ( !v6 )
                                            {
                                              v18 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x60);
                                              v2[5] = v16;
                                              v19 = _mm_cmpeq_epi8(v17, v18);
                                              v6 = _mm_movemask_epi8(v19);
                                              v7 = 96;
                                              if ( !v6 )
                                              {
                                                v2[6] = v18;
                                                v20 = (v3 + 112) & 0xFFFFFFC0;
                                                v21 = (__m128i *)((char *)v2 - (((a2 + 16) & 0xFFFFFFF0) - v20));
                                                v22 = *(__m128i *)v20;
                                                v23 = *(__m128i *)(v20 + 16);
                                                v24 = *(__m128i *)(v20 + 32);
                                                v25 = *(__m128i *)(v20 + 48);
                                                v26 = _mm_min_epu8(*(__m128i *)v20, v23);
                                                v3 = v20 + 64;
                                                v2 = v21 + 4;
                                                if ( !_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v24, v25), v26), v19)) )
                                                {
                                                  do
                                                  {
                                                    v2[-4] = v22;
                                                    v22 = *(__m128i *)v3;
                                                    v2[-3] = v23;
                                                    v23 = *(__m128i *)(v3 + 16);
                                                    v27 = *(__m128i *)(v3 + 32);
                                                    v2[-2] = v24;
                                                    v24 = v27;
                                                    v2[-1] = v25;
                                                    v25 = *(__m128i *)(v3 + 48);
                                                    v19 = _mm_cmpeq_epi8(
                                                            v19,
                                                            _mm_min_epu8(_mm_min_epu8(v27, v25), _mm_min_epu8(v22, v23)));
                                                    v2 += 4;
                                                    v3 += 64;
                                                  }
                                                  while ( !_mm_movemask_epi8(v19) );
                                                }
                                                v7 = -64;
                                                v28 = _mm_cmpeq_epi8((__m128i)0LL, v22);
                                                v6 = _mm_movemask_epi8(v28);
                                                if ( !v6 )
                                                {
                                                  v29 = _mm_cmpeq_epi8(v28, v23);
                                                  v6 = _mm_movemask_epi8(v29);
                                                  v2[-4] = v22;
                                                  v7 = -48;
                                                  if ( !v6 )
                                                  {
                                                    v30 = _mm_cmpeq_epi8(v29, v24);
                                                    v6 = _mm_movemask_epi8(v30);
                                                    v2[-3] = v23;
                                                    v7 = -32;
                                                    if ( !v6 )
                                                    {
                                                      v2[-2] = v24;
                                                      LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v30, v25));
                                                      v7 = -16;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  v31 = &v2->m128i_i8[v7];
                                  v32 = v7 + v3;
                                  if ( (_BYTE)v6 )
                                  {
                                    if ( (v6 & 1) != 0 )
                                    {
                                      *v31 = *(_BYTE *)v32;
                                      return a1;
                                    }
                                    else if ( (v6 & 2) != 0 )
                                    {
                                      *(_WORD *)v31 = *(_WORD *)v32;
                                      return a1;
                                    }
                                    else if ( (v6 & 4) != 0 )
                                    {
                                      *(_WORD *)v31 = *(_WORD *)v32;
                                      v31[2] = *(_BYTE *)(v32 + 2);
                                      return a1;
                                    }
                                    else if ( (v6 & 8) != 0 )
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      return a1;
                                    }
                                    else if ( (v6 & 0x10) != 0 )
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      v31[4] = *(_BYTE *)(v32 + 4);
                                      return a1;
                                    }
                                    else if ( (v6 & 0x20) != 0 )
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      *((_WORD *)v31 + 2) = *(_WORD *)(v32 + 4);
                                      return a1;
                                    }
                                    else
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      if ( (v6 & 0x40) != 0 )
                                        *(_DWORD *)(v31 + 3) = *(_DWORD *)(v32 + 3);
                                      else
                                        *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                      return a1;
                                    }
                                  }
                                  else if ( (v6 & 0x100) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    v31[8] = *(_BYTE *)(v32 + 8);
                                    return a1;
                                  }
                                  else if ( (v6 & 0x200) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    *((_WORD *)v31 + 4) = *(_WORD *)(v32 + 8);
                                    return a1;
                                  }
                                  else if ( (v6 & 0x400) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    *(_DWORD *)(v31 + 7) = *(_DWORD *)(v32 + 7);
                                    return a1;
                                  }
                                  else if ( (v6 & 0x800) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    *((_DWORD *)v31 + 2) = *(_DWORD *)(v32 + 8);
                                    return a1;
                                  }
                                  else if ( (v6 & 0x1000) != 0 )
                                  {
                                    *(double *)v31 = *(double *)v32;
                                    *(double *)(v31 + 5) = *(double *)(v32 + 5);
                                    return a1;
                                  }
                                  else if ( (v6 & 0x2000) != 0 )
                                  {
                                    *(double *)v31 = *(double *)v32;
                                    *(double *)(v31 + 6) = *(double *)(v32 + 6);
                                    return a1;
                                  }
                                  else
                                  {
                                    *(double *)v31 = *(double *)v32;
                                    if ( (v6 & 0x4000) != 0 )
                                      *(double *)(v31 + 7) = *(double *)(v32 + 7);
                                    else
                                      *((double *)v31 + 1) = *(double *)(v32 + 8);
                                    return a1;
                                  }
                                }
                                else
                                {
                                  *(double *)a1 = *(double *)a2;
                                  *(double *)(a1 + 8) = *(double *)(a2 + 8);
                                  return a1;
                                }
                              }
                              else
                              {
                                *(double *)a1 = *(double *)a2;
                                *(double *)(a1 + 7) = *(double *)(a2 + 7);
                                return a1;
                              }
                            }
                            else
                            {
                              *(double *)a1 = *(double *)a2;
                              *(double *)(a1 + 6) = *(double *)(a2 + 6);
                              return a1;
                            }
                          }
                          else
                          {
                            *(double *)a1 = *(double *)a2;
                            *(double *)(a1 + 5) = *(double *)(a2 + 5);
                            return a1;
                          }
                        }
                        else
                        {
                          *(_DWORD *)a1 = *(_DWORD *)a2;
                          *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
                          return a1;
                        }
                      }
                      else
                      {
                        *(_DWORD *)a1 = *(_DWORD *)a2;
                        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                        *(_DWORD *)(a1 + 7) = *(_DWORD *)(a2 + 7);
                        return a1;
                      }
                    }
                    else
                    {
                      *(_DWORD *)a1 = *(_DWORD *)a2;
                      *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                      *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
                      return a1;
                    }
                  }
                  else
                  {
                    *(_DWORD *)a1 = *(_DWORD *)a2;
                    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                    *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
                    return a1;
                  }
                }
                else
                {
                  *(_DWORD *)a1 = *(_DWORD *)a2;
                  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                  return a1;
                }
              }
              else
              {
                *(_DWORD *)a1 = *(_DWORD *)a2;
                *(_DWORD *)(a1 + 3) = *(_DWORD *)(a2 + 3);
                return a1;
              }
            }
            else
            {
              *(_DWORD *)a1 = *(_DWORD *)a2;
              *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
              return a1;
            }
          }
          else
          {
            *(_DWORD *)a1 = *(_DWORD *)a2;
            *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
            return a1;
          }
        }
        else
        {
          *(_DWORD *)a1 = *(_DWORD *)a2;
          return a1;
        }
      }
      else
      {
        *(_WORD *)a1 = *(_WORD *)a2;
        *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
        return a1;
      }
    }
    else
    {
      *(_WORD *)a1 = *(_WORD *)a2;
      return a1;
    }
  }
  else
  {
    *(_BYTE *)a1 = *(_BYTE *)a2;
    return a1;
  }
}

//----- (08078C60) --------------------------------------------------------
__m128i *__cdecl _strncpy_sse2(__m128i *a1, unsigned int a2, unsigned int a3)
{
  __m128i *v3; // edi
  unsigned int v4; // esi
  unsigned int v5; // ebx
  __m128i *result; // eax
  int v7; // ecx
  unsigned int v8; // edx
  __m128i v9; // xmm0
  unsigned int v10; // edx
  __m128i v11; // xmm2
  __m128i v12; // xmm0
  unsigned int v13; // ecx
  char v14; // cc
  __m128i v15; // xmm3
  __m128i v16; // xmm0
  __m128i v17; // xmm4
  __m128i v18; // xmm0
  __m128i v19; // xmm1
  __m128i v20; // xmm0
  __m128i v21; // xmm0
  __m128i v22; // xmm0
  unsigned int v23; // edx
  unsigned int v24; // edx
  unsigned int v25; // ebx
  __m128i v26; // xmm5
  __m128i v27; // xmm6
  __m128i v28; // xmm7
  int v29; // edx
  unsigned int v30; // ebx
  __m128i v31; // xmm3
  __m128i v32; // xmm0
  __m128i v33; // xmm1
  unsigned int v34; // edx
  unsigned int v35; // ecx
  unsigned int v36; // edx
  unsigned int v37; // ecx
  unsigned int v38; // edx
  unsigned int v39; // ebx
  int m128i_i32; // edi
  __m128i si128; // xmm1
  unsigned int v42; // edx
  __int32 v43; // ecx
  __int16 v44; // dx
  __int32 v45; // edx
  double v46; // xmm0_8
  __int16 v47; // dx
  __int32 v48; // edx
  __int32 v49; // edx
  double v50; // xmm1_8
  double v51; // xmm1_8
  double v52; // xmm1_8
  __int16 v53; // cx
  __int32 v54; // ecx
  __int32 v55; // ecx
  __int32 v56; // ecx
  double v57; // xmm3_8
  double v58; // xmm3_8
  double v59; // xmm2_8
  double v60; // xmm2_8
  double v61; // xmm2_8
  __int16 v62; // cx
  double v63; // xmm2_8
  __int32 v64; // ecx
  double v65; // xmm2_8
  __int32 v66; // ecx
  __m128i v67; // xmm2
  __m128i v68; // xmm2
  __m128i v69; // xmm2
  __m128i v70; // xmm2
  __int8 v71; // dl
  __int8 v72; // dl
  __int16 v73; // dx
  __int32 v74; // edx
  __int8 v75; // dl
  __int16 v76; // dx
  __int32 v77; // edx
  __int32 v78; // edx
  double v79; // xmm1_8
  double v80; // xmm1_8
  double v81; // xmm1_8
  __int8 v82; // cl
  __int16 v83; // cx
  __int32 v84; // ecx
  __int32 v85; // ecx
  __int32 v86; // ecx
  __int8 v87; // dl
  double v88; // xmm3_8
  double v89; // xmm3_8
  double v90; // xmm2_8
  double v91; // xmm2_8
  __int8 v92; // cl
  double v93; // xmm2_8
  __int16 v94; // cx
  double v95; // xmm2_8
  __int32 v96; // ecx
  double v97; // xmm2_8
  __int32 v98; // ecx
  __m128i v99; // xmm2
  __m128i v100; // xmm2
  __m128i v101; // xmm2
  __m128i v102; // xmm2
  __m128i v103; // xmm2
  __int8 v104; // cl
  int v105; // ebx
  int v106; // edi
  int v107; // esi
  unsigned int v108; // ebx
  bool v109; // cf
  unsigned int i; // ebx
  int v111; // ebx
  __m128i v112; // xmm0
  __m128i v113; // xmm0
  __m128i v114; // xmm0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( !a3 )
    return a1;
  result = a1;
  v7 = a2 & 0xF;
  if ( (a2 & 0xF) != 0 )
  {
    v4 = a2 & 0xFFFFFFF0;
    v5 = v7 + a3;
    v8 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(a2 & 0xFFFFFFF0))) >> v7;
    if ( v7 + a3 <= 0x11 )
    {
      if ( v8 )
      {
        v5 = a3;
        v4 += v7;
        _BitScanForward(&v8, v8);
        if ( v8 < a3 )
          goto LABEL_45;
        switch ( a3 )
        {
          case 0u:
            return result;
          case 1u:
            goto LABEL_127;
          case 2u:
            goto LABEL_128;
          case 3u:
            goto LABEL_129;
          case 4u:
            goto LABEL_130;
          case 5u:
            goto LABEL_131;
          case 6u:
            goto LABEL_132;
          case 7u:
            goto LABEL_133;
          case 8u:
            goto LABEL_134;
          case 9u:
            goto LABEL_135;
          case 0xAu:
            goto LABEL_136;
          case 0xBu:
            goto LABEL_137;
          case 0xCu:
            goto LABEL_138;
          case 0xDu:
            goto LABEL_139;
          case 0xEu:
            goto LABEL_140;
          case 0xFu:
            goto LABEL_141;
          case 0x10u:
            goto LABEL_142;
          case 0x11u:
            goto LABEL_143;
          case 0x12u:
            goto LABEL_144;
          case 0x13u:
            goto LABEL_145;
          case 0x14u:
            goto LABEL_146;
          case 0x15u:
            goto LABEL_147;
          case 0x16u:
            goto LABEL_148;
          case 0x17u:
            goto LABEL_149;
          case 0x18u:
            goto LABEL_150;
          case 0x19u:
            goto LABEL_151;
          case 0x1Au:
            goto LABEL_152;
          case 0x1Bu:
            goto LABEL_153;
          case 0x1Cu:
            goto LABEL_154;
          case 0x1Du:
            goto LABEL_155;
          case 0x1Eu:
            goto LABEL_156;
          case 0x1Fu:
            goto LABEL_157;
          case 0x20u:
            goto LABEL_158;
          case 0x21u:
            goto LABEL_159;
        }
      }
      else
      {
        v4 += v7;
        switch ( a3 )
        {
          case 0u:
            return result;
          case 1u:
            goto LABEL_127;
          case 2u:
            goto LABEL_128;
          case 3u:
            goto LABEL_129;
          case 4u:
            goto LABEL_130;
          case 5u:
            goto LABEL_131;
          case 6u:
            goto LABEL_132;
          case 7u:
            goto LABEL_133;
          case 8u:
            goto LABEL_134;
          case 9u:
            goto LABEL_135;
          case 0xAu:
            goto LABEL_136;
          case 0xBu:
            goto LABEL_137;
          case 0xCu:
            goto LABEL_138;
          case 0xDu:
            goto LABEL_139;
          case 0xEu:
            goto LABEL_140;
          case 0xFu:
            goto LABEL_141;
          case 0x10u:
            goto LABEL_142;
          case 0x11u:
            goto LABEL_143;
          case 0x12u:
            goto LABEL_144;
          case 0x13u:
            goto LABEL_145;
          case 0x14u:
            goto LABEL_146;
          case 0x15u:
            goto LABEL_147;
          case 0x16u:
            goto LABEL_148;
          case 0x17u:
            goto LABEL_149;
          case 0x18u:
            goto LABEL_150;
          case 0x19u:
            goto LABEL_151;
          case 0x1Au:
            goto LABEL_152;
          case 0x1Bu:
            goto LABEL_153;
          case 0x1Cu:
            goto LABEL_154;
          case 0x1Du:
            goto LABEL_155;
          case 0x1Eu:
            goto LABEL_156;
          case 0x1Fu:
            goto LABEL_157;
          case 0x20u:
            goto LABEL_158;
          case 0x21u:
            goto LABEL_159;
        }
      }
      return result;
    }
    if ( v8 )
    {
      v5 = a3;
      v4 += v7;
      _BitScanForward(&v8, v8);
      switch ( v8 )
      {
        case 0u:
          goto LABEL_63;
        case 1u:
          goto LABEL_65;
        case 2u:
          goto LABEL_67;
        case 3u:
          goto LABEL_69;
        case 4u:
          goto LABEL_71;
        case 5u:
          goto LABEL_73;
        case 6u:
          goto LABEL_75;
        case 7u:
          goto LABEL_77;
        case 8u:
          goto LABEL_79;
        case 9u:
          goto LABEL_81;
        case 0xAu:
          goto LABEL_83;
        case 0xBu:
          goto LABEL_85;
        case 0xCu:
          goto LABEL_87;
        case 0xDu:
          goto LABEL_89;
        case 0xEu:
          goto LABEL_91;
        case 0xFu:
          goto LABEL_93;
        case 0x10u:
          goto LABEL_95;
        case 0x11u:
          goto LABEL_97;
        case 0x12u:
          goto LABEL_99;
        case 0x13u:
          goto LABEL_101;
        case 0x14u:
          goto LABEL_103;
        case 0x15u:
          goto LABEL_105;
        case 0x16u:
          goto LABEL_107;
        case 0x17u:
          goto LABEL_109;
        case 0x18u:
          goto LABEL_111;
        case 0x19u:
          goto LABEL_113;
        case 0x1Au:
          goto LABEL_115;
        case 0x1Bu:
          goto LABEL_117;
        case 0x1Cu:
          goto LABEL_119;
        case 0x1Du:
          goto LABEL_121;
        case 0x1Eu:
          goto LABEL_123;
        case 0x1Fu:
          goto LABEL_125;
      }
    }
    v9 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a2 & 0xFFFFFFF0) + 0x10));
    v10 = _mm_movemask_epi8(v9);
    if ( v5 <= 0x21 )
    {
      if ( v10 )
      {
        v5 = a3;
        v4 += v7;
        _BitScanForward(&v10, v10);
        v8 = v10 + 16 - v7;
        if ( v8 < a3 )
          goto LABEL_45;
        switch ( a3 )
        {
          case 0u:
            return result;
          case 1u:
            goto LABEL_127;
          case 2u:
            goto LABEL_128;
          case 3u:
            goto LABEL_129;
          case 4u:
            goto LABEL_130;
          case 5u:
            goto LABEL_131;
          case 6u:
            goto LABEL_132;
          case 7u:
            goto LABEL_133;
          case 8u:
            goto LABEL_134;
          case 9u:
            goto LABEL_135;
          case 0xAu:
            goto LABEL_136;
          case 0xBu:
            goto LABEL_137;
          case 0xCu:
            goto LABEL_138;
          case 0xDu:
            goto LABEL_139;
          case 0xEu:
            goto LABEL_140;
          case 0xFu:
            goto LABEL_141;
          case 0x10u:
            goto LABEL_142;
          case 0x11u:
            goto LABEL_143;
          case 0x12u:
            goto LABEL_144;
          case 0x13u:
            goto LABEL_145;
          case 0x14u:
            goto LABEL_146;
          case 0x15u:
            goto LABEL_147;
          case 0x16u:
            goto LABEL_148;
          case 0x17u:
            goto LABEL_149;
          case 0x18u:
            goto LABEL_150;
          case 0x19u:
            goto LABEL_151;
          case 0x1Au:
            goto LABEL_152;
          case 0x1Bu:
            goto LABEL_153;
          case 0x1Cu:
            goto LABEL_154;
          case 0x1Du:
            goto LABEL_155;
          case 0x1Eu:
            goto LABEL_156;
          case 0x1Fu:
            goto LABEL_157;
          case 0x20u:
            goto LABEL_158;
          case 0x21u:
            goto LABEL_159;
        }
      }
      else
      {
        v4 += v7;
        switch ( a3 )
        {
          case 0u:
            return result;
          case 1u:
            goto LABEL_127;
          case 2u:
            goto LABEL_128;
          case 3u:
            goto LABEL_129;
          case 4u:
            goto LABEL_130;
          case 5u:
            goto LABEL_131;
          case 6u:
            goto LABEL_132;
          case 7u:
            goto LABEL_133;
          case 8u:
            goto LABEL_134;
          case 9u:
            goto LABEL_135;
          case 0xAu:
            goto LABEL_136;
          case 0xBu:
            goto LABEL_137;
          case 0xCu:
            goto LABEL_138;
          case 0xDu:
            goto LABEL_139;
          case 0xEu:
            goto LABEL_140;
          case 0xFu:
            goto LABEL_141;
          case 0x10u:
            goto LABEL_142;
          case 0x11u:
            goto LABEL_143;
          case 0x12u:
            goto LABEL_144;
          case 0x13u:
            goto LABEL_145;
          case 0x14u:
            goto LABEL_146;
          case 0x15u:
            goto LABEL_147;
          case 0x16u:
            goto LABEL_148;
          case 0x17u:
            goto LABEL_149;
          case 0x18u:
            goto LABEL_150;
          case 0x19u:
            goto LABEL_151;
          case 0x1Au:
            goto LABEL_152;
          case 0x1Bu:
            goto LABEL_153;
          case 0x1Cu:
            goto LABEL_154;
          case 0x1Du:
            goto LABEL_155;
          case 0x1Eu:
            goto LABEL_156;
          case 0x1Fu:
            goto LABEL_157;
          case 0x20u:
            goto LABEL_158;
          case 0x21u:
            goto LABEL_159;
        }
      }
      return result;
    }
    if ( v10 )
    {
      v5 = a3;
      _BitScanForward(&v10, v10);
      v4 += v7;
      v8 = v10 + 16 - v7;
      switch ( v8 )
      {
        case 0u:
          goto LABEL_63;
        case 1u:
          goto LABEL_65;
        case 2u:
          goto LABEL_67;
        case 3u:
          goto LABEL_69;
        case 4u:
          goto LABEL_71;
        case 5u:
          goto LABEL_73;
        case 6u:
          goto LABEL_75;
        case 7u:
          goto LABEL_77;
        case 8u:
          goto LABEL_79;
        case 9u:
          goto LABEL_81;
        case 0xAu:
          goto LABEL_83;
        case 0xBu:
          goto LABEL_85;
        case 0xCu:
          goto LABEL_87;
        case 0xDu:
          goto LABEL_89;
        case 0xEu:
          goto LABEL_91;
        case 0xFu:
          goto LABEL_93;
        case 0x10u:
          goto LABEL_95;
        case 0x11u:
          goto LABEL_97;
        case 0x12u:
          goto LABEL_99;
        case 0x13u:
          goto LABEL_101;
        case 0x14u:
          goto LABEL_103;
        case 0x15u:
          goto LABEL_105;
        case 0x16u:
          goto LABEL_107;
        case 0x17u:
          goto LABEL_109;
        case 0x18u:
          goto LABEL_111;
        case 0x19u:
          goto LABEL_113;
        case 0x1Au:
          goto LABEL_115;
        case 0x1Bu:
          goto LABEL_117;
        case 0x1Cu:
          goto LABEL_119;
        case 0x1Du:
          goto LABEL_121;
        case 0x1Eu:
          goto LABEL_123;
        case 0x1Fu:
          goto LABEL_125;
      }
    }
    *a1 = _mm_loadu_si128((const __m128i *)(v4 + v7));
    v3 = (__m128i *)((char *)a1 - v7);
    goto LABEL_8;
  }
  si128 = _mm_load_si128((const __m128i *)a2);
  v9 = _mm_cmpeq_epi8((__m128i)0LL, si128);
  v8 = _mm_movemask_epi8(v9);
  if ( a3 <= 0x11 )
  {
LABEL_61:
    if ( !v8 )
    {
      switch ( v5 )
      {
        case 0u:
          return result;
        case 1u:
          goto LABEL_127;
        case 2u:
          goto LABEL_128;
        case 3u:
          goto LABEL_129;
        case 4u:
          goto LABEL_130;
        case 5u:
          goto LABEL_131;
        case 6u:
          goto LABEL_132;
        case 7u:
          goto LABEL_133;
        case 8u:
          goto LABEL_134;
        case 9u:
          goto LABEL_135;
        case 0xAu:
          goto LABEL_136;
        case 0xBu:
          goto LABEL_137;
        case 0xCu:
          goto LABEL_138;
        case 0xDu:
          goto LABEL_139;
        case 0xEu:
          goto LABEL_140;
        case 0xFu:
          goto LABEL_141;
        case 0x10u:
          goto LABEL_142;
        case 0x11u:
          goto LABEL_143;
        default:
          goto LABEL_29;
      }
    }
    _BitScanForward(&v8, v8);
    if ( v8 < v5 )
      goto LABEL_45;
    switch ( v5 )
    {
      case 0u:
        return result;
      case 1u:
LABEL_127:
        v3->m128i_i8[0] = *(_BYTE *)v4;
        break;
      case 2u:
LABEL_128:
        v3->m128i_i16[0] = *(_WORD *)v4;
        break;
      case 3u:
LABEL_129:
        v71 = *(_BYTE *)(v4 + 2);
        v3->m128i_i16[0] = *(_WORD *)v4;
        v3->m128i_i8[2] = v71;
        break;
      case 4u:
LABEL_130:
        v3->m128i_i32[0] = *(_DWORD *)v4;
        break;
      case 5u:
LABEL_131:
        v72 = *(_BYTE *)(v4 + 4);
        v3->m128i_i32[0] = *(_DWORD *)v4;
        v3->m128i_i8[4] = v72;
        break;
      case 6u:
LABEL_132:
        v73 = *(_WORD *)(v4 + 4);
        v3->m128i_i32[0] = *(_DWORD *)v4;
        v3->m128i_i16[2] = v73;
        break;
      case 7u:
LABEL_133:
        v74 = *(_DWORD *)(v4 + 3);
        v3->m128i_i32[0] = *(_DWORD *)v4;
        *(__int32 *)((char *)v3->m128i_i32 + 3) = v74;
        break;
      case 8u:
LABEL_134:
        v3->m128i_i64[0] = *(__int64 *)v4;
        break;
      case 9u:
LABEL_135:
        v75 = *(_BYTE *)(v4 + 8);
        v3->m128i_i64[0] = *(__int64 *)v4;
        v3->m128i_i8[8] = v75;
        break;
      case 0xAu:
LABEL_136:
        v76 = *(_WORD *)(v4 + 8);
        v3->m128i_i64[0] = *(__int64 *)v4;
        v3->m128i_i16[4] = v76;
        break;
      case 0xBu:
LABEL_137:
        v77 = *(_DWORD *)(v4 + 7);
        v3->m128i_i64[0] = *(__int64 *)v4;
        *(__int32 *)((char *)&v3->m128i_i32[1] + 3) = v77;
        break;
      case 0xCu:
LABEL_138:
        v78 = *(_DWORD *)(v4 + 8);
        v3->m128i_i64[0] = *(__int64 *)v4;
        v3->m128i_i32[2] = v78;
        break;
      case 0xDu:
LABEL_139:
        v79 = *(double *)(v4 + 5);
        v3->m128i_i64[0] = *(__int64 *)v4;
        *(double *)((char *)v3->m128i_i64 + 5) = v79;
        break;
      case 0xEu:
LABEL_140:
        v80 = *(double *)(v4 + 6);
        v3->m128i_i64[0] = *(__int64 *)v4;
        *(double *)((char *)v3->m128i_i64 + 6) = v80;
        break;
      case 0xFu:
LABEL_141:
        v81 = *(double *)(v4 + 7);
        v3->m128i_i64[0] = *(__int64 *)v4;
        *(double *)((char *)v3->m128i_i64 + 7) = v81;
        break;
      case 0x10u:
LABEL_142:
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        break;
      case 0x11u:
LABEL_143:
        v82 = *(_BYTE *)(v4 + 16);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        v3[1].m128i_i8[0] = v82;
        break;
      case 0x12u:
LABEL_144:
        v83 = *(_WORD *)(v4 + 16);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        v3[1].m128i_i16[0] = v83;
        break;
      case 0x13u:
LABEL_145:
        v84 = *(_DWORD *)(v4 + 15);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(__int32 *)((char *)&v3->m128i_i32[3] + 3) = v84;
        break;
      case 0x14u:
LABEL_146:
        v85 = *(_DWORD *)(v4 + 16);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        v3[1].m128i_i32[0] = v85;
        break;
      case 0x15u:
LABEL_147:
        v86 = *(_DWORD *)(v4 + 16);
        v87 = *(_BYTE *)(v4 + 20);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        v3[1].m128i_i32[0] = v86;
        v3[1].m128i_i8[4] = v87;
        break;
      case 0x16u:
LABEL_148:
        v88 = *(double *)(v4 + 14);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)((char *)&v3->m128i_i64[1] + 6) = v88;
        break;
      case 0x17u:
LABEL_149:
        v89 = *(double *)(v4 + 15);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)((char *)&v3->m128i_i64[1] + 7) = v89;
        break;
      case 0x18u:
LABEL_150:
        v90 = *(double *)(v4 + 16);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)v3[1].m128i_i64 = v90;
        break;
      case 0x19u:
LABEL_151:
        v91 = *(double *)(v4 + 16);
        v92 = *(_BYTE *)(v4 + 24);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)v3[1].m128i_i64 = v91;
        v3[1].m128i_i8[8] = v92;
        break;
      case 0x1Au:
LABEL_152:
        v93 = *(double *)(v4 + 16);
        v94 = *(_WORD *)(v4 + 24);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)v3[1].m128i_i64 = v93;
        v3[1].m128i_i16[4] = v94;
        break;
      case 0x1Bu:
LABEL_153:
        v95 = *(double *)(v4 + 16);
        v96 = *(_DWORD *)(v4 + 23);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)v3[1].m128i_i64 = v95;
        *(__int32 *)((char *)&v3[1].m128i_i32[1] + 3) = v96;
        break;
      case 0x1Cu:
LABEL_154:
        v97 = *(double *)(v4 + 16);
        v98 = *(_DWORD *)(v4 + 24);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)v3[1].m128i_i64 = v97;
        v3[1].m128i_i32[2] = v98;
        break;
      case 0x1Du:
LABEL_155:
        v99 = _mm_loadu_si128((const __m128i *)(v4 + 13));
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(__m128i *)((char *)v3 + 13) = v99;
        break;
      case 0x1Eu:
LABEL_156:
        v100 = _mm_loadu_si128((const __m128i *)(v4 + 14));
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(__m128i *)((char *)v3 + 14) = v100;
        break;
      case 0x1Fu:
LABEL_157:
        v101 = _mm_loadu_si128((const __m128i *)(v4 + 15));
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(__m128i *)((char *)v3 + 15) = v101;
        break;
      case 0x20u:
LABEL_158:
        v102 = _mm_loadu_si128((const __m128i *)(v4 + 16));
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        v3[1] = v102;
        break;
      case 0x21u:
LABEL_159:
        v103 = _mm_loadu_si128((const __m128i *)(v4 + 16));
        v104 = *(_BYTE *)(v4 + 32);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        v3[1] = v103;
        v3[2].m128i_i8[0] = v104;
        break;
    }
    return result;
  }
LABEL_29:
  if ( v8 )
    goto LABEL_35;
  v9 = _mm_cmpeq_epi8(v9, *(__m128i *)(v4 + 16));
  *v3 = si128;
  v8 = _mm_movemask_epi8(v9);
  if ( v5 <= 0x21 )
  {
    ++v3;
    v4 += 16;
    v5 -= 16;
    goto LABEL_61;
  }
  if ( v8 )
  {
    v4 += 16;
    ++v3;
    v5 -= 16;
LABEL_35:
    _BitScanForward(&v8, v8);
    switch ( v8 )
    {
      case 0u:
LABEL_63:
        v3->m128i_i8[0] = BYTE1(v8);
        v39 = v5 - 1;
        m128i_i32 = (int)v3->m128i_i32 + 1;
        if ( v39 )
          goto LABEL_178;
        break;
      case 1u:
LABEL_65:
        v3->m128i_i16[0] = *(_WORD *)v4;
        v39 = v5 - 2;
        m128i_i32 = (int)v3->m128i_i32 + 2;
        if ( v39 )
          goto LABEL_178;
        break;
      case 2u:
LABEL_67:
        v3->m128i_i16[0] = *(_WORD *)v4;
        v3->m128i_i8[2] = BYTE1(v8);
        v39 = v5 - 3;
        m128i_i32 = (int)v3->m128i_i32 + 3;
        if ( v39 )
          goto LABEL_178;
        break;
      case 3u:
LABEL_69:
        v3->m128i_i32[0] = *(_DWORD *)v4;
        v39 = v5 - 4;
        m128i_i32 = (int)&v3->m128i_i32[1];
        if ( v39 )
          goto LABEL_178;
        break;
      case 4u:
LABEL_71:
        v43 = *(_DWORD *)v4;
        v3->m128i_i8[4] = BYTE1(v8);
        v3->m128i_i32[0] = v43;
        v39 = v5 - 5;
        m128i_i32 = (int)&v3->m128i_i32[1] + 1;
        if ( v39 )
          goto LABEL_178;
        break;
      case 5u:
LABEL_73:
        v44 = *(_WORD *)(v4 + 4);
        v3->m128i_i32[0] = *(_DWORD *)v4;
        v3->m128i_i16[2] = v44;
        v39 = v5 - 6;
        m128i_i32 = (int)&v3->m128i_i32[1] + 2;
        if ( v39 )
          goto LABEL_178;
        break;
      case 6u:
LABEL_75:
        v45 = *(_DWORD *)(v4 + 3);
        v3->m128i_i32[0] = *(_DWORD *)v4;
        *(__int32 *)((char *)v3->m128i_i32 + 3) = v45;
        v39 = v5 - 7;
        m128i_i32 = (int)&v3->m128i_i32[1] + 3;
        if ( v39 )
          goto LABEL_178;
        break;
      case 7u:
LABEL_77:
        v3->m128i_i64[0] = *(__int64 *)v4;
        v39 = v5 - 8;
        m128i_i32 = (int)&v3->m128i_i32[2];
        if ( v39 )
          goto LABEL_178;
        break;
      case 8u:
LABEL_79:
        v46 = *(double *)v4;
        v3->m128i_i8[8] = BYTE1(v8);
        *(double *)v3->m128i_i64 = v46;
        v39 = v5 - 9;
        m128i_i32 = (int)&v3->m128i_i32[2] + 1;
        if ( v39 )
          goto LABEL_178;
        break;
      case 9u:
LABEL_81:
        v47 = *(_WORD *)(v4 + 8);
        v3->m128i_i64[0] = *(__int64 *)v4;
        v3->m128i_i16[4] = v47;
        v39 = v5 - 10;
        m128i_i32 = (int)&v3->m128i_i32[2] + 2;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0xAu:
LABEL_83:
        v48 = *(_DWORD *)(v4 + 7);
        v3->m128i_i64[0] = *(__int64 *)v4;
        *(__int32 *)((char *)&v3->m128i_i32[1] + 3) = v48;
        v39 = v5 - 11;
        m128i_i32 = (int)&v3->m128i_i32[2] + 3;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0xBu:
LABEL_85:
        v49 = *(_DWORD *)(v4 + 8);
        v3->m128i_i64[0] = *(__int64 *)v4;
        v3->m128i_i32[2] = v49;
        v39 = v5 - 12;
        m128i_i32 = (int)&v3->m128i_i32[3];
        if ( v39 )
          goto LABEL_178;
        break;
      case 0xCu:
LABEL_87:
        v50 = *(double *)(v4 + 5);
        v3->m128i_i64[0] = *(__int64 *)v4;
        *(double *)((char *)v3->m128i_i64 + 5) = v50;
        v39 = v5 - 13;
        m128i_i32 = (int)&v3->m128i_i32[3] + 1;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0xDu:
LABEL_89:
        v51 = *(double *)(v4 + 6);
        v3->m128i_i64[0] = *(__int64 *)v4;
        *(double *)((char *)v3->m128i_i64 + 6) = v51;
        v39 = v5 - 14;
        m128i_i32 = (int)&v3->m128i_i32[3] + 2;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0xEu:
LABEL_91:
        v52 = *(double *)(v4 + 7);
        v3->m128i_i64[0] = *(__int64 *)v4;
        *(double *)((char *)v3->m128i_i64 + 7) = v52;
        v39 = v5 - 15;
        m128i_i32 = (int)&v3->m128i_i32[3] + 3;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0xFu:
LABEL_93:
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        v39 = v5 - 16;
        m128i_i32 = (int)v3[1].m128i_i32;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x10u:
LABEL_95:
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        v3[1].m128i_i8[0] = BYTE1(v8);
        v39 = v5 - 17;
        m128i_i32 = (int)v3[1].m128i_i32 + 1;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x11u:
LABEL_97:
        v53 = *(_WORD *)(v4 + 16);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        v3[1].m128i_i16[0] = v53;
        v39 = v5 - 18;
        m128i_i32 = (int)v3[1].m128i_i32 + 2;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x12u:
LABEL_99:
        v54 = *(_DWORD *)(v4 + 15);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(__int32 *)((char *)&v3->m128i_i32[3] + 3) = v54;
        v39 = v5 - 19;
        m128i_i32 = (int)v3[1].m128i_i32 + 3;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x13u:
LABEL_101:
        v55 = *(_DWORD *)(v4 + 16);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        v3[1].m128i_i32[0] = v55;
        v39 = v5 - 20;
        m128i_i32 = (int)&v3[1].m128i_i32[1];
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x14u:
LABEL_103:
        v56 = *(_DWORD *)(v4 + 16);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        v3[1].m128i_i32[0] = v56;
        v3[1].m128i_i8[4] = BYTE1(v8);
        v39 = v5 - 21;
        m128i_i32 = (int)&v3[1].m128i_i32[1] + 1;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x15u:
LABEL_105:
        v57 = *(double *)(v4 + 14);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)((char *)&v3->m128i_i64[1] + 6) = v57;
        v39 = v5 - 22;
        m128i_i32 = (int)&v3[1].m128i_i32[1] + 2;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x16u:
LABEL_107:
        v58 = *(double *)(v4 + 15);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)((char *)&v3->m128i_i64[1] + 7) = v58;
        v39 = v5 - 23;
        m128i_i32 = (int)&v3[1].m128i_i32[1] + 3;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x17u:
LABEL_109:
        v59 = *(double *)(v4 + 16);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)v3[1].m128i_i64 = v59;
        v39 = v5 - 24;
        m128i_i32 = (int)&v3[1].m128i_i32[2];
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x18u:
LABEL_111:
        v60 = *(double *)(v4 + 16);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)v3[1].m128i_i64 = v60;
        v3[1].m128i_i8[8] = BYTE1(v8);
        v39 = v5 - 25;
        m128i_i32 = (int)&v3[1].m128i_i32[2] + 1;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x19u:
LABEL_113:
        v61 = *(double *)(v4 + 16);
        v62 = *(_WORD *)(v4 + 24);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)v3[1].m128i_i64 = v61;
        v3[1].m128i_i16[4] = v62;
        v39 = v5 - 26;
        m128i_i32 = (int)&v3[1].m128i_i32[2] + 2;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x1Au:
LABEL_115:
        v63 = *(double *)(v4 + 16);
        v64 = *(_DWORD *)(v4 + 23);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)v3[1].m128i_i64 = v63;
        *(__int32 *)((char *)&v3[1].m128i_i32[1] + 3) = v64;
        v39 = v5 - 27;
        m128i_i32 = (int)&v3[1].m128i_i32[2] + 3;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x1Bu:
LABEL_117:
        v65 = *(double *)(v4 + 16);
        v66 = *(_DWORD *)(v4 + 24);
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(double *)v3[1].m128i_i64 = v65;
        v3[1].m128i_i32[2] = v66;
        v39 = v5 - 28;
        m128i_i32 = (int)&v3[1].m128i_i32[3];
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x1Cu:
LABEL_119:
        v67 = _mm_loadu_si128((const __m128i *)(v4 + 13));
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(__m128i *)((char *)v3 + 13) = v67;
        v39 = v5 - 29;
        m128i_i32 = (int)&v3[1].m128i_i32[3] + 1;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x1Du:
LABEL_121:
        v68 = _mm_loadu_si128((const __m128i *)(v4 + 14));
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(__m128i *)((char *)v3 + 14) = v68;
        v39 = v5 - 30;
        m128i_i32 = (int)&v3[1].m128i_i32[3] + 2;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x1Eu:
LABEL_123:
        v69 = _mm_loadu_si128((const __m128i *)(v4 + 15));
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        *(__m128i *)((char *)v3 + 15) = v69;
        v39 = v5 - 31;
        m128i_i32 = (int)&v3[1].m128i_i32[3] + 3;
        if ( v39 )
          goto LABEL_178;
        break;
      case 0x1Fu:
LABEL_125:
        v70 = _mm_loadu_si128((const __m128i *)(v4 + 16));
        *v3 = _mm_loadu_si128((const __m128i *)v4);
        v3[1] = v70;
        v39 = v5 - 32;
        m128i_i32 = (int)v3[2].m128i_i32;
        if ( v39 )
          goto LABEL_178;
        break;
    }
    return result;
  }
LABEL_8:
  v11 = *(__m128i *)(v4 + 32);
  v3[1] = _mm_load_si128((const __m128i *)(v4 + 16));
  v12 = _mm_cmpeq_epi8(v9, v11);
  v8 = _mm_movemask_epi8(v12);
  v13 = 32;
  v14 = v5 <= 0x30;
  v5 -= 48;
  if ( v14 )
    goto LABEL_54;
  if ( v8 )
    goto LABEL_176;
  v15 = *(__m128i *)(v4 + 48);
  v3[2] = v11;
  v16 = _mm_cmpeq_epi8(v12, v15);
  v8 = _mm_movemask_epi8(v16);
  v13 = 48;
  v14 = v5 <= 0x10;
  v5 -= 16;
  if ( v14 )
    goto LABEL_54;
  if ( v8 )
  {
LABEL_43:
    *(__m128i *)((char *)v3 + v13) = v15;
    goto LABEL_177;
  }
  v17 = *(__m128i *)(v4 + 64);
  v3[3] = v15;
  v18 = _mm_cmpeq_epi8(v16, v17);
  v8 = _mm_movemask_epi8(v18);
  v13 = 64;
  v14 = v5 <= 0x10;
  v5 -= 16;
  if ( v14 )
    goto LABEL_54;
  if ( v8 )
  {
LABEL_42:
    *(__m128i *)((char *)v3 + v13) = v17;
    goto LABEL_177;
  }
  v19 = *(__m128i *)(v4 + 80);
  v3[4] = v17;
  v20 = _mm_cmpeq_epi8(v18, v19);
  v8 = _mm_movemask_epi8(v20);
  v13 = 80;
  v14 = v5 <= 0x10;
  v5 -= 16;
  if ( v14 )
    goto LABEL_54;
  if ( v8 )
  {
    v3[5] = v19;
    goto LABEL_177;
  }
  v11 = *(__m128i *)(v4 + 96);
  v3[5] = v19;
  v21 = _mm_cmpeq_epi8(v20, v11);
  v8 = _mm_movemask_epi8(v21);
  v13 = 96;
  v14 = v5 <= 0x10;
  v5 -= 16;
  if ( v14 )
    goto LABEL_54;
  if ( v8 )
  {
LABEL_176:
    *(__m128i *)((char *)v3 + v13) = v11;
    goto LABEL_177;
  }
  v15 = *(__m128i *)(v4 + 112);
  v3[6] = v11;
  v22 = _mm_cmpeq_epi8(v21, v15);
  v8 = _mm_movemask_epi8(v22);
  v13 = 112;
  v14 = v5 <= 0x10;
  v5 -= 16;
  if ( v14 )
    goto LABEL_54;
  if ( v8 )
    goto LABEL_43;
  v3[7] = v15;
  v23 = v4;
  v4 = (v4 + 128) & 0xFFFFFFC0;
  v24 = v23 - v4;
  v3 = (__m128i *)((char *)v3 - v24);
  v25 = v5 + v24 + 128;
  v17 = *(__m128i *)v4;
  v26 = *(__m128i *)(v4 + 16);
  v27 = *(__m128i *)(v4 + 32);
  v28 = *(__m128i *)(v4 + 48);
  v29 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v27, v28), _mm_min_epu8(*(__m128i *)v4, v26)), v22));
  v14 = v25 <= 0x40;
  v30 = v25 - 64;
  if ( !v14 )
  {
    if ( v29 )
    {
LABEL_24:
      v32 = _mm_cmpeq_epi8(v22, v17);
      v33 = _mm_cmpeq_epi8((__m128i)0LL, v26);
      v34 = _mm_movemask_epi8(v32);
      v35 = _mm_movemask_epi8(v33);
      if ( v34 )
      {
        _BitScanForward(&v34, v34);
        *v3 = v17;
        v39 = v30 + 63 - v34;
        m128i_i32 = (int)v3->m128i_i32 + v34 + 1;
      }
      else if ( v35 )
      {
        _BitScanForward(&v42, v35);
        *v3 = v17;
        v3[1] = v26;
        v39 = v30 + 47 - v42;
        m128i_i32 = (int)v3[1].m128i_i32 + v42 + 1;
      }
      else
      {
        v36 = _mm_movemask_epi8(_mm_cmpeq_epi8(v32, v27));
        v37 = _mm_movemask_epi8(_mm_cmpeq_epi8(v33, v28));
        if ( v36 )
        {
          _BitScanForward(&v36, v36);
          *v3 = v17;
          v3[1] = v26;
          v3[2] = v27;
          v39 = v30 + 31 - v36;
          m128i_i32 = (int)v3[2].m128i_i32 + v36 + 1;
        }
        else
        {
          _BitScanForward(&v38, v37);
          *v3 = v17;
          v3[1] = v26;
          v3[2] = v27;
          v3[3] = v28;
          v39 = v30 + 15 - v38;
          m128i_i32 = (int)v3[3].m128i_i32 + v38 + 1;
        }
      }
LABEL_178:
      v14 = v39 <= 0x10;
      v105 = v39 - 16;
      if ( !v14 )
      {
        *(_OWORD *)m128i_i32 = 0LL;
        v106 = m128i_i32 + 16;
        v107 = v106 & 0xF;
        m128i_i32 = v106 - v107;
        v108 = v107 + v105;
        v109 = v108 < 0x40;
        for ( i = v108 - 64; !v109; i -= 64 )
        {
          *(_OWORD *)m128i_i32 = 0LL;
          *(_OWORD *)(m128i_i32 + 16) = 0LL;
          *(_OWORD *)(m128i_i32 + 32) = 0LL;
          *(_OWORD *)(m128i_i32 + 48) = 0LL;
          m128i_i32 += 64;
          v109 = i < 0x40;
        }
        v14 = ((int)(i + 32) < 0) ^ __OFADD__(32, i);
        v111 = i + 32;
        if ( v14 )
        {
          v14 = (v111 + 16 < 0) ^ __OFADD__(16, v111);
          v105 = v111 + 16;
          if ( !v14 )
          {
            *(_OWORD *)m128i_i32 = 0LL;
            m128i_i32 += 16;
            switch ( v105 )
            {
              case 0:
                return result;
              case 1:
LABEL_160:
                *(_BYTE *)m128i_i32 = 0;
                break;
              case 2:
LABEL_161:
                *(_WORD *)m128i_i32 = 0;
                break;
              case 3:
LABEL_162:
                *(_DWORD *)(m128i_i32 - 1) = 0;
                break;
              case 4:
LABEL_163:
                *(_DWORD *)m128i_i32 = 0;
                break;
              case 5:
LABEL_164:
                *(_DWORD *)m128i_i32 = 0;
                *(_BYTE *)(m128i_i32 + 4) = 0;
                break;
              case 6:
LABEL_165:
                *(_DWORD *)m128i_i32 = 0;
                *(_WORD *)(m128i_i32 + 4) = 0;
                break;
              case 7:
LABEL_166:
                *(_QWORD *)(m128i_i32 - 1) = 0LL;
                break;
              case 8:
LABEL_167:
                *(_QWORD *)m128i_i32 = 0LL;
                break;
              case 9:
LABEL_168:
                *(_QWORD *)m128i_i32 = 0LL;
                *(_BYTE *)(m128i_i32 + 8) = 0;
                break;
              case 10:
LABEL_169:
                *(_QWORD *)m128i_i32 = 0LL;
                *(_WORD *)(m128i_i32 + 8) = 0;
                break;
              case 11:
LABEL_170:
                *(_QWORD *)m128i_i32 = 0LL;
                *(_DWORD *)(m128i_i32 + 7) = 0;
                break;
              case 12:
LABEL_171:
                *(_QWORD *)m128i_i32 = 0LL;
                *(_DWORD *)(m128i_i32 + 8) = 0;
                break;
              case 13:
LABEL_172:
                *(_QWORD *)m128i_i32 = 0LL;
                *(_QWORD *)(m128i_i32 + 5) = 0LL;
                break;
              case 14:
LABEL_173:
                *(_QWORD *)m128i_i32 = 0LL;
                *(_QWORD *)(m128i_i32 + 6) = 0LL;
                break;
              case 15:
LABEL_174:
                *(_OWORD *)(m128i_i32 - 1) = 0LL;
                break;
              case 16:
LABEL_175:
                *(_OWORD *)m128i_i32 = 0LL;
                break;
            }
            return result;
          }
        }
        else
        {
          *(_OWORD *)m128i_i32 = 0LL;
          *(_OWORD *)(m128i_i32 + 16) = 0LL;
          m128i_i32 += 32;
          v14 = v111 < 16;
          v105 = v111 - 16;
          if ( !v14 )
          {
            *(_OWORD *)m128i_i32 = 0LL;
            m128i_i32 += 16;
            switch ( v105 )
            {
              case 0:
                return result;
              case 1:
                goto LABEL_160;
              case 2:
                goto LABEL_161;
              case 3:
                goto LABEL_162;
              case 4:
                goto LABEL_163;
              case 5:
                goto LABEL_164;
              case 6:
                goto LABEL_165;
              case 7:
                goto LABEL_166;
              case 8:
                goto LABEL_167;
              case 9:
                goto LABEL_168;
              case 10:
                goto LABEL_169;
              case 11:
                goto LABEL_170;
              case 12:
                goto LABEL_171;
              case 13:
                goto LABEL_172;
              case 14:
                goto LABEL_173;
              case 15:
                goto LABEL_174;
              case 16:
                goto LABEL_175;
            }
            return result;
          }
        }
      }
      switch ( v105 )
      {
        case -16:
          return result;
        case -15:
          goto LABEL_160;
        case -14:
          goto LABEL_161;
        case -13:
          goto LABEL_162;
        case -12:
          goto LABEL_163;
        case -11:
          goto LABEL_164;
        case -10:
          goto LABEL_165;
        case -9:
          goto LABEL_166;
        case -8:
          goto LABEL_167;
        case -7:
          goto LABEL_168;
        case -6:
          goto LABEL_169;
        case -5:
          goto LABEL_170;
        case -4:
          goto LABEL_171;
        case -3:
          goto LABEL_172;
        case -2:
          goto LABEL_173;
        case -1:
          goto LABEL_174;
        case 0:
          goto LABEL_175;
      }
      return result;
    }
    while ( 1 )
    {
      v3 += 4;
      v4 += 64;
      v3[-4] = v17;
      v17 = *(__m128i *)v4;
      v3[-3] = v26;
      v26 = *(__m128i *)(v4 + 16);
      v31 = *(__m128i *)(v4 + 32);
      v3[-2] = v27;
      v27 = v31;
      v3[-1] = v28;
      v28 = *(__m128i *)(v4 + 48);
      v29 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v31, v28), _mm_min_epu8(v17, v26)), v22));
      v14 = v30 <= 0x40;
      v30 -= 64;
      if ( v14 )
        break;
      if ( v29 )
        goto LABEL_24;
    }
  }
  if ( !v29 )
  {
    v13 = (v30 + 64) & 0xFFFFFFF0;
    v14 = ((int)(v30 + 48) < 0) ^ __OFADD__(48, v30);
    v5 = v30 + 48;
    if ( !v14 )
    {
      *v3 = v17;
      v109 = v5 < 0x10;
      v5 -= 16;
      if ( !v109 )
      {
        v3[1] = v26;
        v109 = v5 < 0x10;
        v5 -= 16;
        if ( !v109 )
        {
          v3[2] = v27;
          v109 = v5 < 0x10;
          v5 -= 16;
          if ( !v109 )
          {
            v3[3] = v28;
            return result;
          }
        }
      }
    }
    goto LABEL_55;
  }
  v13 = 0;
  v112 = _mm_cmpeq_epi8(v22, v17);
  v8 = _mm_movemask_epi8(v112);
  v14 = ((int)(v30 + 48) < 0) ^ __OFADD__(48, v30) | (v30 == -48);
  v5 = v30 + 48;
  if ( v14 )
    goto LABEL_54;
  if ( v8 )
    goto LABEL_42;
  v113 = _mm_cmpeq_epi8(v112, v26);
  v8 = _mm_movemask_epi8(v113);
  *v3 = v17;
  v13 = 16;
  v14 = v5 <= 0x10;
  v5 -= 16;
  if ( !v14 )
  {
    if ( !v8 )
    {
      v114 = _mm_cmpeq_epi8(v113, v27);
      v8 = _mm_movemask_epi8(v114);
      v3[1] = v26;
      v13 = 32;
      v14 = v5 <= 0x10;
      v5 -= 16;
      if ( !v14 )
      {
        if ( !v8 )
        {
          v3[2] = v27;
          v3 += 3;
          v4 += 48;
          _BitScanForward(&v8, _mm_movemask_epi8(_mm_cmpeq_epi8(v114, v28)));
          if ( v8 >= v5 )
          {
            switch ( v5 )
            {
              case 0u:
                return result;
              case 1u:
                goto LABEL_127;
              case 2u:
                goto LABEL_128;
              case 3u:
                goto LABEL_129;
              case 4u:
                goto LABEL_130;
              case 5u:
                goto LABEL_131;
              case 6u:
                goto LABEL_132;
              case 7u:
                goto LABEL_133;
              case 8u:
                goto LABEL_134;
              case 9u:
                goto LABEL_135;
              case 0xAu:
                goto LABEL_136;
              case 0xBu:
                goto LABEL_137;
              case 0xCu:
                goto LABEL_138;
              case 0xDu:
                goto LABEL_139;
              case 0xEu:
                goto LABEL_140;
              case 0xFu:
                goto LABEL_141;
              case 0x10u:
                goto LABEL_142;
              case 0x11u:
                goto LABEL_143;
              case 0x12u:
                goto LABEL_144;
              case 0x13u:
                goto LABEL_145;
              case 0x14u:
                goto LABEL_146;
              case 0x15u:
                goto LABEL_147;
              case 0x16u:
                goto LABEL_148;
              case 0x17u:
                goto LABEL_149;
              case 0x18u:
                goto LABEL_150;
              case 0x19u:
                goto LABEL_151;
              case 0x1Au:
                goto LABEL_152;
              case 0x1Bu:
                goto LABEL_153;
              case 0x1Cu:
                goto LABEL_154;
              case 0x1Du:
                goto LABEL_155;
              case 0x1Eu:
                goto LABEL_156;
              case 0x1Fu:
                goto LABEL_157;
              case 0x20u:
                goto LABEL_158;
              case 0x21u:
                goto LABEL_159;
            }
            return result;
          }
LABEL_45:
          switch ( v8 )
          {
            case 0u:
              goto LABEL_63;
            case 1u:
              goto LABEL_65;
            case 2u:
              goto LABEL_67;
            case 3u:
              goto LABEL_69;
            case 4u:
              goto LABEL_71;
            case 5u:
              goto LABEL_73;
            case 6u:
              goto LABEL_75;
            case 7u:
              goto LABEL_77;
            case 8u:
              goto LABEL_79;
            case 9u:
              goto LABEL_81;
            case 0xAu:
              goto LABEL_83;
            case 0xBu:
              goto LABEL_85;
            case 0xCu:
              goto LABEL_87;
            case 0xDu:
              goto LABEL_89;
            case 0xEu:
              goto LABEL_91;
            case 0xFu:
              goto LABEL_93;
            case 0x10u:
              goto LABEL_95;
            case 0x11u:
              goto LABEL_97;
            case 0x12u:
              goto LABEL_99;
            case 0x13u:
              goto LABEL_101;
            case 0x14u:
              goto LABEL_103;
            case 0x15u:
              goto LABEL_105;
            case 0x16u:
              goto LABEL_107;
            case 0x17u:
              goto LABEL_109;
            case 0x18u:
              goto LABEL_111;
            case 0x19u:
              goto LABEL_113;
            case 0x1Au:
              goto LABEL_115;
            case 0x1Bu:
              goto LABEL_117;
            case 0x1Cu:
              goto LABEL_119;
            case 0x1Du:
              goto LABEL_121;
            case 0x1Eu:
              goto LABEL_123;
            case 0x1Fu:
              goto LABEL_125;
          }
        }
        v3[2] = v27;
        goto LABEL_177;
      }
      goto LABEL_54;
    }
    v3[1] = v26;
LABEL_177:
    _BitScanForward(&v8, v8);
    v39 = v5 + 15 - v8;
    m128i_i32 = (int)v3->m128i_i32 + v13 + v8 + 1;
    goto LABEL_178;
  }
LABEL_54:
  if ( !v8 )
  {
LABEL_55:
    v3 = (__m128i *)((char *)v3 + v13);
    v4 += v13;
    switch ( v5 )
    {
      case 0xFFFFFFF0:
        return result;
      case 0xFFFFFFF1:
        goto LABEL_127;
      case 0xFFFFFFF2:
        goto LABEL_128;
      case 0xFFFFFFF3:
        goto LABEL_129;
      case 0xFFFFFFF4:
        goto LABEL_130;
      case 0xFFFFFFF5:
        goto LABEL_131;
      case 0xFFFFFFF6:
        goto LABEL_132;
      case 0xFFFFFFF7:
        goto LABEL_133;
      case 0xFFFFFFF8:
        goto LABEL_134;
      case 0xFFFFFFF9:
        goto LABEL_135;
      case 0xFFFFFFFA:
        goto LABEL_136;
      case 0xFFFFFFFB:
        goto LABEL_137;
      case 0xFFFFFFFC:
        goto LABEL_138;
      case 0xFFFFFFFD:
        goto LABEL_139;
      case 0xFFFFFFFE:
        goto LABEL_140;
      case 0xFFFFFFFF:
        goto LABEL_141;
      case 0u:
        goto LABEL_142;
      case 1u:
        goto LABEL_143;
      case 2u:
        goto LABEL_144;
      case 3u:
        goto LABEL_145;
      case 4u:
        goto LABEL_146;
      case 5u:
        goto LABEL_147;
      case 6u:
        goto LABEL_148;
      case 7u:
        goto LABEL_149;
      case 8u:
        goto LABEL_150;
      case 9u:
        goto LABEL_151;
      case 0xAu:
        goto LABEL_152;
      case 0xBu:
        goto LABEL_153;
      case 0xCu:
        goto LABEL_154;
      case 0xDu:
        goto LABEL_155;
      case 0xEu:
        goto LABEL_156;
      case 0xFu:
        goto LABEL_157;
      case 0x10u:
        goto LABEL_158;
      case 0x11u:
        goto LABEL_159;
    }
    return result;
  }
  v5 += 16;
  v3 = (__m128i *)((char *)v3 + v13);
  v4 += v13;
  _BitScanForward(&v8, v8);
  if ( v8 < v5 )
    goto LABEL_45;
  switch ( v5 )
  {
    case 0u:
      return result;
    case 1u:
      goto LABEL_127;
    case 2u:
      goto LABEL_128;
    case 3u:
      goto LABEL_129;
    case 4u:
      goto LABEL_130;
    case 5u:
      goto LABEL_131;
    case 6u:
      goto LABEL_132;
    case 7u:
      goto LABEL_133;
    case 8u:
      goto LABEL_134;
    case 9u:
      goto LABEL_135;
    case 0xAu:
      goto LABEL_136;
    case 0xBu:
      goto LABEL_137;
    case 0xCu:
      goto LABEL_138;
    case 0xDu:
      goto LABEL_139;
    case 0xEu:
      goto LABEL_140;
    case 0xFu:
      goto LABEL_141;
    case 0x10u:
      goto LABEL_142;
    case 0x11u:
      goto LABEL_143;
    case 0x12u:
      goto LABEL_144;
    case 0x13u:
      goto LABEL_145;
    case 0x14u:
      goto LABEL_146;
    case 0x15u:
      goto LABEL_147;
    case 0x16u:
      goto LABEL_148;
    case 0x17u:
      goto LABEL_149;
    case 0x18u:
      goto LABEL_150;
    case 0x19u:
      goto LABEL_151;
    case 0x1Au:
      goto LABEL_152;
    case 0x1Bu:
      goto LABEL_153;
    case 0x1Cu:
      goto LABEL_154;
    case 0x1Du:
      goto LABEL_155;
    case 0x1Eu:
      goto LABEL_156;
    case 0x1Fu:
      goto LABEL_157;
    case 0x20u:
      goto LABEL_158;
    case 0x21u:
      goto LABEL_159;
  }
  return result;
}

//----- (08079C10) --------------------------------------------------------
char *__cdecl _stpcpy_sse2(int a1, unsigned int a2)
{
  __m128i *v2; // edx
  unsigned int v3; // ecx
  __m128i *v4; // ebx
  __m128i v5; // xmm0
  int v6; // eax
  int v7; // ebx
  __m128i v8; // xmm2
  __m128i v9; // xmm0
  __m128i v10; // xmm3
  __m128i v11; // xmm0
  __m128i v12; // xmm4
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  __m128i v15; // xmm0
  __m128i v16; // xmm2
  __m128i v17; // xmm0
  __m128i v18; // xmm3
  __m128i v19; // xmm0
  unsigned int v20; // ecx
  __m128i *v21; // edx
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm6
  __m128i v25; // xmm7
  __m128i v26; // xmm2
  __m128i v27; // xmm3
  __m128i v28; // xmm0
  __m128i v29; // xmm0
  __m128i v30; // xmm0
  __int8 *v31; // edx
  unsigned int v32; // ecx

  v2 = (__m128i *)a1;
  v3 = a2;
  if ( *(_BYTE *)a2 )
  {
    if ( *(_BYTE *)(a2 + 1) )
    {
      if ( *(_BYTE *)(a2 + 2) )
      {
        if ( *(_BYTE *)(a2 + 3) )
        {
          if ( *(_BYTE *)(a2 + 4) )
          {
            if ( *(_BYTE *)(a2 + 5) )
            {
              if ( *(_BYTE *)(a2 + 6) )
              {
                if ( *(_BYTE *)(a2 + 7) )
                {
                  if ( *(_BYTE *)(a2 + 8) )
                  {
                    if ( *(_BYTE *)(a2 + 9) )
                    {
                      if ( *(_BYTE *)(a2 + 10) )
                      {
                        if ( *(_BYTE *)(a2 + 11) )
                        {
                          if ( *(_BYTE *)(a2 + 12) )
                          {
                            if ( *(_BYTE *)(a2 + 13) )
                            {
                              if ( *(_BYTE *)(a2 + 14) )
                              {
                                if ( *(_BYTE *)(a2 + 15) )
                                {
                                  v4 = (__m128i *)((a2 + 16) & 0xFFFFFFF0);
                                  *(__m128i *)a1 = _mm_loadu_si128((const __m128i *)a2);
                                  v5 = _mm_cmpeq_epi8((__m128i)0LL, *v4);
                                  v6 = _mm_movemask_epi8(v5);
                                  v7 = (int)v4->m128i_i32 - a2;
                                  if ( !v6 )
                                  {
                                    v3 = (a2 + 16) & 0xFFFFFFF0;
                                    v2 = (__m128i *)(a1 - (a2 - v3));
                                    v8 = *(__m128i *)(v3 + 0x10);
                                    *v2 = _mm_load_si128((const __m128i *)v3);
                                    v9 = _mm_cmpeq_epi8(v5, v8);
                                    v6 = _mm_movemask_epi8(v9);
                                    v7 = 16;
                                    if ( !v6 )
                                    {
                                      v10 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x20);
                                      v2[1] = v8;
                                      v11 = _mm_cmpeq_epi8(v9, v10);
                                      v6 = _mm_movemask_epi8(v11);
                                      v7 = 32;
                                      if ( !v6 )
                                      {
                                        v12 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x30);
                                        v2[2] = v10;
                                        v13 = _mm_cmpeq_epi8(v11, v12);
                                        v6 = _mm_movemask_epi8(v13);
                                        v7 = 48;
                                        if ( !v6 )
                                        {
                                          v14 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x40);
                                          v2[3] = v12;
                                          v15 = _mm_cmpeq_epi8(v13, v14);
                                          v6 = _mm_movemask_epi8(v15);
                                          v7 = 64;
                                          if ( !v6 )
                                          {
                                            v16 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x50);
                                            v2[4] = v14;
                                            v17 = _mm_cmpeq_epi8(v15, v16);
                                            v6 = _mm_movemask_epi8(v17);
                                            v7 = 80;
                                            if ( !v6 )
                                            {
                                              v18 = *(__m128i *)(((a2 + 16) & 0xFFFFFFF0) + 0x60);
                                              v2[5] = v16;
                                              v19 = _mm_cmpeq_epi8(v17, v18);
                                              v6 = _mm_movemask_epi8(v19);
                                              v7 = 96;
                                              if ( !v6 )
                                              {
                                                v2[6] = v18;
                                                v20 = (v3 + 112) & 0xFFFFFFC0;
                                                v21 = (__m128i *)((char *)v2 - (((a2 + 16) & 0xFFFFFFF0) - v20));
                                                v22 = *(__m128i *)v20;
                                                v23 = *(__m128i *)(v20 + 16);
                                                v24 = *(__m128i *)(v20 + 32);
                                                v25 = *(__m128i *)(v20 + 48);
                                                v26 = _mm_min_epu8(*(__m128i *)v20, v23);
                                                v3 = v20 + 64;
                                                v2 = v21 + 4;
                                                if ( !_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v24, v25), v26), v19)) )
                                                {
                                                  do
                                                  {
                                                    v2[-4] = v22;
                                                    v22 = *(__m128i *)v3;
                                                    v2[-3] = v23;
                                                    v23 = *(__m128i *)(v3 + 16);
                                                    v27 = *(__m128i *)(v3 + 32);
                                                    v2[-2] = v24;
                                                    v24 = v27;
                                                    v2[-1] = v25;
                                                    v25 = *(__m128i *)(v3 + 48);
                                                    v19 = _mm_cmpeq_epi8(
                                                            v19,
                                                            _mm_min_epu8(_mm_min_epu8(v27, v25), _mm_min_epu8(v22, v23)));
                                                    v2 += 4;
                                                    v3 += 64;
                                                  }
                                                  while ( !_mm_movemask_epi8(v19) );
                                                }
                                                v7 = -64;
                                                v28 = _mm_cmpeq_epi8((__m128i)0LL, v22);
                                                v6 = _mm_movemask_epi8(v28);
                                                if ( !v6 )
                                                {
                                                  v29 = _mm_cmpeq_epi8(v28, v23);
                                                  v6 = _mm_movemask_epi8(v29);
                                                  v2[-4] = v22;
                                                  v7 = -48;
                                                  if ( !v6 )
                                                  {
                                                    v30 = _mm_cmpeq_epi8(v29, v24);
                                                    v6 = _mm_movemask_epi8(v30);
                                                    v2[-3] = v23;
                                                    v7 = -32;
                                                    if ( !v6 )
                                                    {
                                                      v2[-2] = v24;
                                                      LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v30, v25));
                                                      v7 = -16;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  v31 = &v2->m128i_i8[v7];
                                  v32 = v7 + v3;
                                  if ( (_BYTE)v6 )
                                  {
                                    if ( (v6 & 1) != 0 )
                                    {
                                      *v31 = *(_BYTE *)v32;
                                      return v31;
                                    }
                                    else if ( (v6 & 2) != 0 )
                                    {
                                      *(_WORD *)v31 = *(_WORD *)v32;
                                      return v31 + 1;
                                    }
                                    else if ( (v6 & 4) != 0 )
                                    {
                                      *(_WORD *)v31 = *(_WORD *)v32;
                                      v31[2] = *(_BYTE *)(v32 + 2);
                                      return v31 + 2;
                                    }
                                    else if ( (v6 & 8) != 0 )
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      return v31 + 3;
                                    }
                                    else if ( (v6 & 0x10) != 0 )
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      v31[4] = *(_BYTE *)(v32 + 4);
                                      return v31 + 4;
                                    }
                                    else if ( (v6 & 0x20) != 0 )
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      *((_WORD *)v31 + 2) = *(_WORD *)(v32 + 4);
                                      return v31 + 5;
                                    }
                                    else
                                    {
                                      *(_DWORD *)v31 = *(_DWORD *)v32;
                                      if ( (v6 & 0x40) != 0 )
                                      {
                                        *(_DWORD *)(v31 + 3) = *(_DWORD *)(v32 + 3);
                                        return v31 + 6;
                                      }
                                      else
                                      {
                                        *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                        return v31 + 7;
                                      }
                                    }
                                  }
                                  else if ( (v6 & 0x100) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    v31[8] = *(_BYTE *)(v32 + 8);
                                    return v31 + 8;
                                  }
                                  else if ( (v6 & 0x200) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    *((_WORD *)v31 + 4) = *(_WORD *)(v32 + 8);
                                    return v31 + 9;
                                  }
                                  else if ( (v6 & 0x400) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    *(_DWORD *)(v31 + 7) = *(_DWORD *)(v32 + 7);
                                    return v31 + 10;
                                  }
                                  else if ( (v6 & 0x800) != 0 )
                                  {
                                    *(_DWORD *)v31 = *(_DWORD *)v32;
                                    *((_DWORD *)v31 + 1) = *(_DWORD *)(v32 + 4);
                                    *((_DWORD *)v31 + 2) = *(_DWORD *)(v32 + 8);
                                    return v31 + 11;
                                  }
                                  else if ( (v6 & 0x1000) != 0 )
                                  {
                                    *(double *)v31 = *(double *)v32;
                                    *(double *)(v31 + 5) = *(double *)(v32 + 5);
                                    return v31 + 12;
                                  }
                                  else if ( (v6 & 0x2000) != 0 )
                                  {
                                    *(double *)v31 = *(double *)v32;
                                    *(double *)(v31 + 6) = *(double *)(v32 + 6);
                                    return v31 + 13;
                                  }
                                  else
                                  {
                                    *(double *)v31 = *(double *)v32;
                                    if ( (v6 & 0x4000) != 0 )
                                    {
                                      *(double *)(v31 + 7) = *(double *)(v32 + 7);
                                      return v31 + 14;
                                    }
                                    else
                                    {
                                      *((double *)v31 + 1) = *(double *)(v32 + 8);
                                      return v31 + 15;
                                    }
                                  }
                                }
                                else
                                {
                                  *(double *)a1 = *(double *)a2;
                                  *(double *)(a1 + 8) = *(double *)(a2 + 8);
                                  return (char *)(a1 + 15);
                                }
                              }
                              else
                              {
                                *(double *)a1 = *(double *)a2;
                                *(double *)(a1 + 7) = *(double *)(a2 + 7);
                                return (char *)(a1 + 14);
                              }
                            }
                            else
                            {
                              *(double *)a1 = *(double *)a2;
                              *(double *)(a1 + 6) = *(double *)(a2 + 6);
                              return (char *)(a1 + 13);
                            }
                          }
                          else
                          {
                            *(double *)a1 = *(double *)a2;
                            *(double *)(a1 + 5) = *(double *)(a2 + 5);
                            return (char *)(a1 + 12);
                          }
                        }
                        else
                        {
                          *(_DWORD *)a1 = *(_DWORD *)a2;
                          *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
                          return (char *)(a1 + 11);
                        }
                      }
                      else
                      {
                        *(_DWORD *)a1 = *(_DWORD *)a2;
                        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                        *(_DWORD *)(a1 + 7) = *(_DWORD *)(a2 + 7);
                        return (char *)(a1 + 10);
                      }
                    }
                    else
                    {
                      *(_DWORD *)a1 = *(_DWORD *)a2;
                      *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                      *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 8);
                      return (char *)(a1 + 9);
                    }
                  }
                  else
                  {
                    *(_DWORD *)a1 = *(_DWORD *)a2;
                    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                    *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 8);
                    return (char *)(a1 + 8);
                  }
                }
                else
                {
                  *(_DWORD *)a1 = *(_DWORD *)a2;
                  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
                  return (char *)(a1 + 7);
                }
              }
              else
              {
                *(_DWORD *)a1 = *(_DWORD *)a2;
                *(_DWORD *)(a1 + 3) = *(_DWORD *)(a2 + 3);
                return (char *)(a1 + 6);
              }
            }
            else
            {
              *(_DWORD *)a1 = *(_DWORD *)a2;
              *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
              return (char *)(a1 + 5);
            }
          }
          else
          {
            *(_DWORD *)a1 = *(_DWORD *)a2;
            *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
            return (char *)(a1 + 4);
          }
        }
        else
        {
          *(_DWORD *)a1 = *(_DWORD *)a2;
          return (char *)(a1 + 3);
        }
      }
      else
      {
        *(_WORD *)a1 = *(_WORD *)a2;
        *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
        return (char *)(a1 + 2);
      }
    }
    else
    {
      *(_WORD *)a1 = *(_WORD *)a2;
      return (char *)(a1 + 1);
    }
  }
  else
  {
    *(_BYTE *)a1 = *(_BYTE *)a2;
    return (char *)a1;
  }
}

//----- (0807A220) --------------------------------------------------------
const __m128i *__cdecl _strchr_sse2(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm2
  const __m128i *v4; // edi
  __m128i v5; // xmm1
  int v6; // ecx
  __m128i v7; // xmm1
  unsigned int v8; // edi
  __m128i v9; // xmm0
  int v10; // edx
  int v11; // eax
  __m128i si128; // xmm0
  __m128i v13; // xmm2
  __m128i v14; // xmm0
  __m128i v15; // xmm2
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  __m128i v18; // xmm0

  v2 = _mm_cvtsi32_si128(a2);
  v3 = 0LL;
  v4 = a1;
  v5 = _mm_unpacklo_epi8(v2, v2);
  v6 = (unsigned __int8)a1 & 0xF;
  v7 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v5, v5), 0);
  if ( ((unsigned __int8)a1 & 0xF) == 0 )
  {
LABEL_7:
    while ( 1 )
    {
      si128 = _mm_load_si128(v4);
      v13 = _mm_cmpeq_epi8(v3, si128);
      v10 = _mm_movemask_epi8(v13);
      v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(si128, v7));
      if ( v11 )
        break;
      if ( v10 )
        return 0;
      v14 = _mm_load_si128(++v4);
      v15 = _mm_cmpeq_epi8(v13, v14);
      v10 = _mm_movemask_epi8(v15);
      v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(v14, v7));
      if ( v11 )
        break;
      if ( v10 )
        return 0;
      v16 = _mm_load_si128(++v4);
      v17 = _mm_cmpeq_epi8(v15, v16);
      v10 = _mm_movemask_epi8(v17);
      v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(v16, v7));
      if ( v11 )
        break;
      if ( v10 )
        return 0;
      v18 = _mm_load_si128(++v4);
      v3 = _mm_cmpeq_epi8(v17, v18);
      v10 = _mm_movemask_epi8(v3);
      v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(v18, v7));
      if ( v11 )
        break;
      if ( v10 )
        return 0;
      ++v4;
    }
    if ( v10 )
      goto LABEL_17;
LABEL_51:
    if ( (_BYTE)v11 )
    {
      if ( (v11 & 1) == 0 )
      {
        if ( (v11 & 2) == 0 )
        {
          if ( (v11 & 4) == 0 )
          {
            if ( (v11 & 8) != 0 )
              return (const __m128i *)&v4->m128i_i8[3];
            if ( (v11 & 0x10) == 0 )
            {
              if ( (v11 & 0x20) == 0 )
              {
                if ( (v11 & 0x40) == 0 )
                  return (const __m128i *)&v4->m128i_i8[7];
                return (const __m128i *)&v4->m128i_i8[6];
              }
              return (const __m128i *)&v4->m128i_i8[5];
            }
            return (const __m128i *)&v4->m128i_i8[4];
          }
          return (const __m128i *)&v4->m128i_i8[2];
        }
        return (const __m128i *)&v4->m128i_i8[1];
      }
      return v4;
    }
    if ( (v11 & 0x100) == 0 )
    {
      if ( (v11 & 0x200) == 0 )
      {
        if ( (v11 & 0x400) == 0 )
        {
          if ( (v11 & 0x800) != 0 )
            return (const __m128i *)&v4->m128i_i8[11];
          if ( (v11 & 0x1000) == 0 )
          {
            if ( (v11 & 0x2000) == 0 )
            {
              if ( (v11 & 0x4000) == 0 )
                return (const __m128i *)&v4->m128i_i8[15];
              return (const __m128i *)&v4->m128i_i8[14];
            }
            return (const __m128i *)&v4->m128i_i8[13];
          }
          return (const __m128i *)&v4->m128i_i8[12];
        }
        return (const __m128i *)&v4->m128i_i8[10];
      }
      return (const __m128i *)&v4->m128i_i8[9];
    }
    return (const __m128i *)&v4->m128i_i8[8];
  }
  v8 = (unsigned int)a1 & 0xFFFFFFF0;
  v9 = _mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0));
  v10 = _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v9)) >> v6;
  v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(v9, v7)) >> v6;
  if ( !v11 )
  {
    if ( !v10 )
    {
      v3 = 0LL;
      v4 = (const __m128i *)(v8 + 16);
      goto LABEL_7;
    }
    return 0;
  }
  v4 = (const __m128i *)(v6 + v8);
  if ( !v10 )
    goto LABEL_51;
LABEL_17:
  if ( !(_BYTE)v11 )
  {
    if ( (_BYTE)v10 )
      return 0;
    if ( (v11 & 0xF00) == 0 )
    {
      if ( (v10 & 0xF00) != 0 )
        return 0;
      if ( (v11 & 0x1000) == 0 )
      {
        if ( (v10 & 0x1000) != 0 )
          return 0;
        if ( (v11 & 0x2000) == 0 )
        {
          if ( (v10 & 0x2000) != 0 )
            return 0;
          if ( (v11 & 0x4000) == 0 )
          {
            if ( (v10 & 0x4000) == 0 )
              return (const __m128i *)&v4->m128i_i8[15];
            return 0;
          }
          return (const __m128i *)&v4->m128i_i8[14];
        }
        return (const __m128i *)&v4->m128i_i8[13];
      }
      return (const __m128i *)&v4->m128i_i8[12];
    }
    if ( (v11 & 0x100) == 0 )
    {
      if ( (v10 & 0x100) != 0 )
        return 0;
      if ( (v11 & 0x200) == 0 )
      {
        if ( (v10 & 0x200) != 0 )
          return 0;
        if ( (v11 & 0x400) == 0 )
        {
          if ( (v10 & 0x400) == 0 )
            return (const __m128i *)&v4->m128i_i8[11];
          return 0;
        }
        return (const __m128i *)&v4->m128i_i8[10];
      }
      return (const __m128i *)&v4->m128i_i8[9];
    }
    return (const __m128i *)&v4->m128i_i8[8];
  }
  if ( (v11 & 0xF) != 0 )
  {
    if ( (v11 & 1) == 0 )
    {
      if ( (v10 & 1) != 0 )
        return 0;
      if ( (v11 & 2) == 0 )
      {
        if ( (v10 & 2) != 0 )
          return 0;
        if ( (v11 & 4) == 0 )
        {
          if ( (v10 & 4) == 0 )
            return (const __m128i *)&v4->m128i_i8[3];
          return 0;
        }
        return (const __m128i *)&v4->m128i_i8[2];
      }
      return (const __m128i *)&v4->m128i_i8[1];
    }
    return v4;
  }
  if ( (v10 & 0xF) != 0 )
    return 0;
  if ( (v11 & 0x10) != 0 )
    return (const __m128i *)&v4->m128i_i8[4];
  if ( (v10 & 0x10) != 0 )
    return 0;
  if ( (v11 & 0x20) != 0 )
    return (const __m128i *)&v4->m128i_i8[5];
  if ( (v10 & 0x20) == 0 )
  {
    if ( (v11 & 0x40) == 0 )
    {
      if ( (v10 & 0x40) == 0 )
        return (const __m128i *)&v4->m128i_i8[7];
      return 0;
    }
    return (const __m128i *)&v4->m128i_i8[6];
  }
  return 0;
}

//----- (0807A600) --------------------------------------------------------
const __m128i *__usercall _strrchr_sse2@<eax>(const __m128i *a1@<esi>, const __m128i *a2, unsigned int a3)
{
  __m128i v3; // xmm1
  __m128i v4; // xmm2
  __m128i v5; // xmm1
  __m128i v6; // xmm1
  __m128i v7; // xmm0
  int v8; // ecx
  unsigned int v9; // eax
  unsigned int v10; // edi
  unsigned int v11; // ebx
  __m128i si128; // xmm0
  unsigned int v13; // edx
  __m128i v14; // xmm0
  __m128i v15; // xmm0
  __m128i v16; // xmm0
  __m128i v17; // xmm0
  int v19; // ecx

  v3 = _mm_cvtsi32_si128(a3);
  v4 = 0LL;
  v5 = _mm_unpacklo_epi8(v3, v3);
  v6 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v5, v5), 0);
  if ( ((unsigned __int8)a2 & 0x3Fu) > 0x30 )
  {
    v8 = (unsigned __int8)a2 & 0xF;
    si128 = _mm_load_si128((const __m128i *)((unsigned int)a2 & 0xFFFFFFF0));
    v13 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, si128)) >> v8;
    v9 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(si128, v6)) >> v8;
    v10 = ((unsigned int)a2 & 0xFFFFFFF0) + 16;
    if ( !v9 )
    {
      if ( !v13 )
      {
        v11 = 0;
        goto LABEL_12;
      }
      return 0;
    }
    if ( !v13 )
    {
      v11 = v9;
      a1 = (const __m128i *)(v10 + v8);
      goto LABEL_12;
    }
    v10 += v8;
    LOWORD(v8) = v13;
  }
  else
  {
    v7 = _mm_loadu_si128(a2);
    v4 = _mm_cmpeq_epi8((__m128i)0LL, v7);
    v8 = _mm_movemask_epi8(v4);
    v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v7, v6));
    v10 = (unsigned int)&a2[1];
    if ( !v9 )
    {
      if ( !v8 )
      {
        v10 &= 0xFFFFFFF0;
        v11 = 0;
        while ( 1 )
        {
          do
          {
LABEL_12:
            v14 = _mm_load_si128((const __m128i *)v10);
            v4 = _mm_cmpeq_epi8(v4, v14);
            v10 += 16;
            v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v14, v6));
            if ( v9 | _mm_movemask_epi8(v4) )
              break;
            v15 = _mm_load_si128((const __m128i *)v10);
            v4 = _mm_cmpeq_epi8(v4, v15);
            v10 += 16;
            v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v15, v6));
            if ( v9 | _mm_movemask_epi8(v4) )
              break;
            v16 = _mm_load_si128((const __m128i *)v10);
            v4 = _mm_cmpeq_epi8(v4, v16);
            v10 += 16;
            v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v16, v6));
            if ( v9 | _mm_movemask_epi8(v4) )
              break;
            v17 = _mm_load_si128((const __m128i *)v10);
            v4 = _mm_cmpeq_epi8(v4, v17);
            v10 += 16;
            v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v17, v6));
          }
          while ( !(v9 | _mm_movemask_epi8(v4)) );
          if ( !v9 )
            break;
          v19 = _mm_movemask_epi8(v4);
          if ( v19 )
          {
            if ( (_BYTE)v19 )
            {
              if ( (v19 & 0xF) != 0 )
              {
                if ( (v19 & 1) != 0 )
                {
                  v9 &= 1u;
                  if ( v9 )
                    goto LABEL_68;
                }
                else if ( (v19 & 2) != 0 )
                {
                  v9 &= 3u;
                  if ( v9 )
                    goto LABEL_68;
                }
                else if ( (v19 & 4) != 0 )
                {
                  v9 &= 7u;
                  if ( v9 )
                    goto LABEL_68;
                }
                else
                {
                  v9 &= 0xFu;
                  if ( v9 )
                    goto LABEL_68;
                }
              }
              else if ( (v19 & 0x10) != 0 )
              {
                v9 &= 0x1Fu;
                if ( v9 )
                  goto LABEL_68;
              }
              else if ( (v19 & 0x20) != 0 )
              {
                v9 &= 0x3Fu;
                if ( v9 )
                  goto LABEL_68;
              }
              else if ( (v19 & 0x40) != 0 )
              {
                v9 &= 0x7Fu;
                if ( v9 )
                  goto LABEL_68;
              }
              else
              {
                LOWORD(v9) = (unsigned __int8)v9;
                if ( (_BYTE)v9 )
                  goto LABEL_68;
              }
            }
            else if ( (v19 & 0xF00) != 0 )
            {
              if ( (v19 & 0x100) != 0 )
              {
                v9 &= 0x1FFu;
                if ( v9 )
                  goto LABEL_68;
              }
              else if ( (v19 & 0x200) != 0 )
              {
                v9 &= 0x3FFu;
                if ( v9 )
                  goto LABEL_68;
              }
              else if ( (v19 & 0x400) != 0 )
              {
                v9 &= 0x7FFu;
                if ( v9 )
                  goto LABEL_68;
              }
              else
              {
                v9 &= 0xFFFu;
                if ( v9 )
                  goto LABEL_68;
              }
            }
            else if ( (v19 & 0x1000) != 0 )
            {
              v9 &= 0x1FFFu;
              if ( v9 )
                goto LABEL_68;
            }
            else if ( (v19 & 0x2000) != 0 )
            {
              v9 &= 0x3FFFu;
              if ( v9 )
                goto LABEL_68;
            }
            else if ( (v19 & 0x4000) != 0 )
            {
              v9 &= 0x7FFFu;
              if ( v9 )
                goto LABEL_68;
            }
            else if ( (_WORD)v9 )
            {
              goto LABEL_68;
            }
            break;
          }
          v11 = v9;
          a1 = (const __m128i *)v10;
        }
        if ( v11 )
        {
          LOWORD(v9) = v11;
          v10 = (unsigned int)a1;
          goto LABEL_68;
        }
        return 0;
      }
      return 0;
    }
    if ( !v8 )
    {
      v11 = v9;
      a1 = a2 + 1;
      v10 &= 0xFFFFFFF0;
      goto LABEL_12;
    }
  }
  if ( (_BYTE)v8 )
  {
    if ( (v8 & 0xF) != 0 )
    {
      if ( (v8 & 1) != 0 )
      {
        v9 &= 1u;
        if ( !v9 )
          return 0;
      }
      else if ( (v8 & 2) != 0 )
      {
        v9 &= 3u;
        if ( !v9 )
          return 0;
      }
      else if ( (v8 & 4) != 0 )
      {
        v9 &= 7u;
        if ( !v9 )
          return 0;
      }
      else
      {
        v9 &= 0xFu;
        if ( !v9 )
          return 0;
      }
    }
    else if ( (v8 & 0x10) != 0 )
    {
      v9 &= 0x1Fu;
      if ( !v9 )
        return 0;
    }
    else if ( (v8 & 0x20) != 0 )
    {
      v9 &= 0x3Fu;
      if ( !v9 )
        return 0;
    }
    else if ( (v8 & 0x40) != 0 )
    {
      v9 &= 0x7Fu;
      if ( !v9 )
        return 0;
    }
    else
    {
      LOWORD(v9) = (unsigned __int8)v9;
      if ( !(_BYTE)v9 )
        return 0;
    }
  }
  else if ( (v8 & 0xF00) != 0 )
  {
    if ( (v8 & 0x100) != 0 )
    {
      v9 &= 0x1FFu;
      if ( !v9 )
        return 0;
    }
    else if ( (v8 & 0x200) != 0 )
    {
      v9 &= 0x3FFu;
      if ( !v9 )
        return 0;
    }
    else if ( (v8 & 0x400) != 0 )
    {
      v9 &= 0x7FFu;
      if ( !v9 )
        return 0;
    }
    else
    {
      v9 &= 0xFFFu;
      if ( !v9 )
        return 0;
    }
  }
  else if ( (v8 & 0x1000) != 0 )
  {
    v9 &= 0x1FFFu;
    if ( !v9 )
      return 0;
  }
  else if ( (v8 & 0x2000) != 0 )
  {
    v9 &= 0x3FFFu;
    if ( !v9 )
      return 0;
  }
  else if ( (v8 & 0x4000) != 0 )
  {
    v9 &= 0x7FFFu;
    if ( !v9 )
      return 0;
  }
  else if ( !(_WORD)v9 )
  {
    return 0;
  }
LABEL_68:
  if ( BYTE1(v9) )
  {
    if ( (v9 & 0xF000) != 0 )
    {
      if ( (v9 & 0x8000) != 0 )
      {
        return (const __m128i *)(v10 - 1);
      }
      else if ( (v9 & 0x4000) != 0 )
      {
        return (const __m128i *)(v10 - 2);
      }
      else if ( (v9 & 0x2000) != 0 )
      {
        return (const __m128i *)(v10 - 3);
      }
      else
      {
        return (const __m128i *)(v10 - 4);
      }
    }
    else if ( (v9 & 0x800) != 0 )
    {
      return (const __m128i *)(v10 - 5);
    }
    else if ( (v9 & 0x400) != 0 )
    {
      return (const __m128i *)(v10 - 6);
    }
    else if ( (v9 & 0x200) != 0 )
    {
      return (const __m128i *)(v10 - 7);
    }
    else
    {
      return (const __m128i *)(v10 - 8);
    }
  }
  else if ( (v9 & 0xF0) != 0 )
  {
    if ( (v9 & 0x80u) != 0 )
    {
      return (const __m128i *)(v10 - 9);
    }
    else if ( (v9 & 0x40) != 0 )
    {
      return (const __m128i *)(v10 - 10);
    }
    else if ( (v9 & 0x20) != 0 )
    {
      return (const __m128i *)(v10 - 11);
    }
    else
    {
      return (const __m128i *)(v10 - 12);
    }
  }
  else if ( (v9 & 8) != 0 )
  {
    return (const __m128i *)(v10 - 13);
  }
  else if ( (v9 & 4) != 0 )
  {
    return (const __m128i *)(v10 - 14);
  }
  else if ( (v9 & 2) != 0 )
  {
    return (const __m128i *)(v10 - 15);
  }
  else
  {
    return (const __m128i *)(v10 - 16);
  }
}

//----- (0807AC30) --------------------------------------------------------
char *__cdecl _strchr_sse2_bsf(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm2
  const __m128i *v4; // edi
  __m128i v5; // xmm1
  int v6; // ecx
  __m128i v7; // xmm1
  unsigned int v8; // edi
  __m128i v9; // xmm0
  unsigned int v10; // edx
  unsigned int v11; // eax
  __m128i si128; // xmm0
  unsigned int v14; // eax
  __m128i v15; // xmm0
  __m128i v16; // xmm0
  __m128i v17; // xmm0
  unsigned int v18; // edx
  unsigned int v19; // ecx

  v2 = _mm_cvtsi32_si128(a2);
  v3 = 0LL;
  v4 = a1;
  v5 = _mm_unpacklo_epi8(v2, v2);
  v6 = (unsigned __int8)a1 & 0xF;
  v7 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v5, v5), 0);
  if ( ((unsigned __int8)a1 & 0xF) == 0 )
  {
    do
    {
LABEL_8:
      si128 = _mm_load_si128(v4);
      v3 = _mm_cmpeq_epi8(v3, si128);
      ++v4;
      v14 = _mm_movemask_epi8(_mm_cmpeq_epi8(si128, v7));
      if ( v14 | _mm_movemask_epi8(v3) )
        break;
      v15 = _mm_load_si128(v4);
      v3 = _mm_cmpeq_epi8(v3, v15);
      ++v4;
      v14 = _mm_movemask_epi8(_mm_cmpeq_epi8(v15, v7));
      if ( v14 | _mm_movemask_epi8(v3) )
        break;
      v16 = _mm_load_si128(v4);
      v3 = _mm_cmpeq_epi8(v3, v16);
      ++v4;
      v14 = _mm_movemask_epi8(_mm_cmpeq_epi8(v16, v7));
      if ( v14 | _mm_movemask_epi8(v3) )
        break;
      v17 = _mm_load_si128(v4);
      v3 = _mm_cmpeq_epi8(v3, v17);
      ++v4;
      v14 = _mm_movemask_epi8(_mm_cmpeq_epi8(v17, v7));
    }
    while ( !(v14 | _mm_movemask_epi8(v3)) );
    v18 = _mm_movemask_epi8(v3);
    if ( v14 )
    {
      _BitScanForward(&v14, v14);
      if ( !v18 )
        return (char *)&v4[-1] + v14;
      _BitScanForward(&v19, v18);
      if ( v14 <= v19 )
        return (char *)&v4[-1] + v14;
    }
    return 0;
  }
  v8 = (unsigned int)a1 & 0xFFFFFFF0;
  v9 = _mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0));
  v10 = _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v9)) >> v6;
  v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(v9, v7)) >> v6;
  if ( v11 )
  {
    _BitScanForward(&v11, v11);
    if ( !v10 )
      return (char *)(v6 + v8 + v11);
    _BitScanForward(&v10, v10);
    if ( v11 <= v10 )
      return (char *)(v6 + v8 + v11);
    return 0;
  }
  if ( !v10 )
  {
    v3 = 0LL;
    v4 = (const __m128i *)(v8 + 16);
    goto LABEL_8;
  }
  return 0;
}

//----- (0807AD40) --------------------------------------------------------
int __usercall _strrchr_sse2_bsf@<eax>(const __m128i *a1@<esi>, const __m128i *a2, unsigned int a3)
{
  __m128i v3; // xmm1
  __m128i v4; // xmm2
  __m128i v5; // xmm1
  __m128i v6; // xmm1
  __m128i v7; // xmm0
  unsigned int v8; // edx
  int v9; // eax
  const __m128i *v10; // edi
  unsigned int v11; // ebx
  unsigned int v12; // ecx
  int v13; // eax
  int v15; // ecx
  unsigned int v16; // edi
  __m128i si128; // xmm0
  unsigned int v18; // edx
  unsigned int v19; // eax
  unsigned int v20; // edi
  unsigned int v21; // ecx
  int v22; // eax
  __m128i v23; // xmm0
  int v24; // eax
  __m128i v25; // xmm0
  __m128i v26; // xmm0
  __m128i v27; // xmm0
  unsigned int v28; // eax
  unsigned int v29; // ecx
  int v30; // eax

  v3 = _mm_cvtsi32_si128(a3);
  v4 = 0LL;
  v5 = _mm_unpacklo_epi8(v3, v3);
  v6 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v5, v5), 0);
  if ( ((unsigned __int8)a2 & 0x3Fu) > 0x30 )
  {
    v15 = (unsigned __int8)a2 & 0xF;
    v16 = (unsigned int)a2 & 0xFFFFFFF0;
    si128 = _mm_load_si128((const __m128i *)((unsigned int)a2 & 0xFFFFFFF0));
    v18 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, si128)) >> v15;
    v19 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(si128, v6)) >> v15;
    if ( v19 )
    {
      if ( !v18 )
      {
        v11 = v19;
        v10 = (const __m128i *)(v16 + 16);
        a1 = (const __m128i *)((char *)v10 + v15);
        goto LABEL_16;
      }
      v20 = v15 + v16;
      _BitScanForward(&v21, v18);
      v22 = ((2 << v21) - 1) & v19;
      if ( v22 )
      {
        _BitScanReverse((unsigned int *)&v22, v22);
        return v20 + v22;
      }
    }
    else if ( !v18 )
    {
      v10 = (const __m128i *)(v16 + 16);
      v11 = 0;
      goto LABEL_16;
    }
    return 0;
  }
  v7 = _mm_loadu_si128(a2);
  v4 = _mm_cmpeq_epi8((__m128i)0LL, v7);
  v8 = _mm_movemask_epi8(v4);
  v9 = _mm_movemask_epi8(_mm_cmpeq_epi8(v7, v6));
  if ( v9 )
  {
    if ( !v8 )
    {
      v11 = v9;
      a1 = a2 + 1;
      v10 = (const __m128i *)(((unsigned int)a2 & 0xFFFFFFF0) + 16);
      goto LABEL_16;
    }
    _BitScanForward(&v12, v8);
    v13 = ((2 << v12) - 1) & v9;
    if ( v13 )
    {
      _BitScanReverse((unsigned int *)&v13, v13);
      return (int)a2 + v13;
    }
    return 0;
  }
  if ( v8 )
    return 0;
  v10 = (const __m128i *)(((unsigned int)a2 & 0xFFFFFFF0) + 16);
  v11 = 0;
  while ( 1 )
  {
    do
    {
LABEL_16:
      v23 = _mm_load_si128(v10);
      v4 = _mm_cmpeq_epi8(v4, v23);
      ++v10;
      v24 = _mm_movemask_epi8(_mm_cmpeq_epi8(v23, v6));
      if ( v24 | _mm_movemask_epi8(v4) )
        break;
      v25 = _mm_load_si128(v10);
      v4 = _mm_cmpeq_epi8(v4, v25);
      ++v10;
      v24 = _mm_movemask_epi8(_mm_cmpeq_epi8(v25, v6));
      if ( v24 | _mm_movemask_epi8(v4) )
        break;
      v26 = _mm_load_si128(v10);
      v4 = _mm_cmpeq_epi8(v4, v26);
      ++v10;
      v24 = _mm_movemask_epi8(_mm_cmpeq_epi8(v26, v6));
      if ( v24 | _mm_movemask_epi8(v4) )
        break;
      v27 = _mm_load_si128(v10);
      v4 = _mm_cmpeq_epi8(v4, v27);
      ++v10;
      v24 = _mm_movemask_epi8(_mm_cmpeq_epi8(v27, v6));
    }
    while ( !(v24 | _mm_movemask_epi8(v4)) );
    if ( !v24 )
      break;
    v29 = _mm_movemask_epi8(v4);
    if ( v29 )
    {
      _BitScanForward(&v29, v29);
      v30 = ((2 << v29) - 1) & v24;
      if ( v30 )
      {
        _BitScanReverse((unsigned int *)&v30, v30);
        return (int)&v10[-1] + v30;
      }
      break;
    }
    v11 = v24;
    a1 = v10;
  }
  if ( !v11 )
    return 0;
  _BitScanReverse(&v28, v11);
  return (int)&a1[-1] + v28;
}

//----- (0807AF30) --------------------------------------------------------
const __m128i *__cdecl _memchr_sse2(const __m128i *a1, unsigned int a2, unsigned int a3)
{
  __m128i v3; // xmm1
  unsigned int v4; // edx
  __m128i v5; // xmm1
  const __m128i *v6; // edi
  __m128i v7; // xmm1
  int v8; // eax
  const __m128i *v9; // edi
  int v10; // edx
  int v11; // ecx
  bool v12; // cc
  unsigned int v13; // edx
  int v14; // ecx
  int v15; // eax
  unsigned int v16; // edi
  char v17; // cl
  __m128i v18; // xmm0
  __m128i v19; // xmm2
  __m128i v20; // xmm4
  const __m128i *v21; // edi
  unsigned int v23; // edx

  v3 = _mm_cvtsi32_si128(a2);
  v4 = a3;
  if ( !a3 )
    return 0;
  v5 = _mm_unpacklo_epi8(v3, v3);
  v6 = a1;
  v7 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v5, v5), 0);
  if ( ((unsigned __int8)a1 & 0x3Fu) > 0x30 )
  {
    v11 = (unsigned __int8)a1 & 0xF;
    v9 = (const __m128i *)((unsigned int)a1 & 0xFFFFFFF0);
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0)), v7)) >> v11;
    if ( v8 )
    {
LABEL_66:
      v6 = (const __m128i *)((char *)v9 + v11);
LABEL_67:
      if ( (_BYTE)v8 )
      {
        if ( (v8 & 0xF) != 0 )
        {
          if ( (v8 & 1) != 0 )
            return v6;
          if ( (v8 & 2) != 0 )
          {
            if ( v4 >= 2 )
              return (const __m128i *)&v6->m128i_i8[1];
          }
          else if ( (v8 & 4) != 0 )
          {
            if ( v4 >= 3 )
              return (const __m128i *)&v6->m128i_i8[2];
          }
          else if ( v4 >= 4 )
          {
            return (const __m128i *)&v6->m128i_i8[3];
          }
        }
        else if ( (v8 & 0x10) != 0 )
        {
          if ( v4 >= 5 )
            return (const __m128i *)&v6->m128i_i8[4];
        }
        else if ( (v8 & 0x20) != 0 )
        {
          if ( v4 >= 6 )
            return (const __m128i *)&v6->m128i_i8[5];
        }
        else if ( (v8 & 0x40) != 0 )
        {
          if ( v4 >= 7 )
            return (const __m128i *)&v6->m128i_i8[6];
        }
        else if ( v4 >= 8 )
        {
          return (const __m128i *)&v6->m128i_i8[7];
        }
      }
      else if ( (v8 & 0xF00) != 0 )
      {
        if ( (v8 & 0x100) != 0 )
        {
          if ( v4 >= 9 )
            return (const __m128i *)&v6->m128i_i8[8];
        }
        else if ( (v8 & 0x200) != 0 )
        {
          if ( v4 >= 0xA )
            return (const __m128i *)&v6->m128i_i8[9];
        }
        else if ( (v8 & 0x400) != 0 )
        {
          if ( v4 >= 0xB )
            return (const __m128i *)&v6->m128i_i8[10];
        }
        else if ( v4 >= 0xC )
        {
          return (const __m128i *)&v6->m128i_i8[11];
        }
      }
      else if ( (v8 & 0x1000) != 0 )
      {
        if ( v4 >= 0xD )
          return (const __m128i *)&v6->m128i_i8[12];
      }
      else if ( (v8 & 0x2000) != 0 )
      {
        if ( v4 >= 0xE )
          return (const __m128i *)&v6->m128i_i8[13];
      }
      else if ( (v8 & 0x4000) != 0 )
      {
        if ( v4 >= 0xF )
          return (const __m128i *)&v6->m128i_i8[14];
      }
      else if ( v4 >= 0x10 )
      {
        return (const __m128i *)&v6->m128i_i8[15];
      }
      return 0;
    }
    v10 = v11 + a3 - 16;
    if ( (v10 < 0) ^ __OFADD__(v11, a3 - 16) | (v10 == 0) )
      return 0;
    ++v9;
  }
  else
  {
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v7));
    if ( v8 )
      goto LABEL_67;
    if ( a3 <= 0x10 )
      return 0;
    v9 = (const __m128i *)((unsigned int)&a1[1] & 0xFFFFFFF0);
    v10 = ((unsigned __int8)a1 & 0xF) + a3 - 16;
  }
  v12 = (unsigned int)v10 <= 0x40;
  v13 = v10 - 64;
  if ( v12 )
  {
LABEL_45:
    v23 = v13 + 64;
    v11 = 0;
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9), v7));
    if ( v8 )
      goto LABEL_65;
    if ( v23 <= 0x10 )
      return 0;
    v11 = 16;
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 1), v7));
    if ( v8 )
      goto LABEL_65;
    if ( v23 <= 0x20 )
      return 0;
    v11 = 32;
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v7));
    if ( v8 )
    {
LABEL_65:
      v4 = v23 - v11;
      goto LABEL_66;
    }
    if ( v23 > 0x30 )
    {
      v11 = 48;
      v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(v7, v9[3]));
      if ( !v8 )
        return 0;
      goto LABEL_65;
    }
    return 0;
  }
  v14 = 0;
  v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9), v7));
  if ( !v15 )
  {
    v14 = 1;
    v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 1), v7));
    if ( !v15 )
    {
      v14 = 2;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v7));
      if ( !v15 )
      {
        v14 = 3;
        v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 3), v7));
        if ( !v15 )
        {
          v9 += 4;
          v12 = v13 <= 0x40;
          v13 -= 64;
          if ( v12 )
            goto LABEL_45;
          v14 = 0;
          v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9), v7));
          if ( !v15 )
          {
            v14 = 1;
            v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 1), v7));
            if ( !v15 )
            {
              v14 = 2;
              v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v7));
              if ( !v15 )
              {
                v14 = 3;
                v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 3), v7));
                if ( !v15 )
                {
                  v16 = (unsigned int)&v9[4];
                  v17 = v16;
                  v9 = (const __m128i *)(v16 & 0xFFFFFFC0);
                  v13 += v17 & 0x3F;
                  while ( 1 )
                  {
                    v12 = v13 <= 0x40;
                    v13 -= 64;
                    if ( v12 )
                      goto LABEL_45;
                    v18 = _mm_cmpeq_epi8(_mm_load_si128(v9), v7);
                    v19 = _mm_cmpeq_epi8(_mm_load_si128(v9 + 1), v7);
                    v20 = _mm_max_epu8(
                            _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 3), v7), v19),
                            _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v7), v18));
                    v9 += 4;
                    if ( _mm_movemask_epi8(v20) )
                    {
                      v9 -= 4;
                      v15 = _mm_movemask_epi8(v18);
                      v14 = 0;
                      if ( !v15 )
                      {
                        v15 = _mm_movemask_epi8(v19);
                        v14 = 1;
                        if ( !v15 )
                        {
                          v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v7));
                          v14 = 2;
                          if ( !v15 )
                          {
                            LOWORD(v15) = _mm_movemask_epi8(_mm_cmpeq_epi8(v7, v9[3]));
                            v14 = 3;
                          }
                        }
                      }
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v21 = &v9[v14];
  if ( (_BYTE)v15 )
  {
    if ( (v15 & 0xF) != 0 )
    {
      if ( (v15 & 1) != 0 )
      {
        return v21;
      }
      else if ( (v15 & 2) != 0 )
      {
        return (const __m128i *)&v21->m128i_i8[1];
      }
      else if ( (v15 & 4) != 0 )
      {
        return (const __m128i *)&v21->m128i_i8[2];
      }
      else
      {
        return (const __m128i *)&v21->m128i_i8[3];
      }
    }
    else if ( (v15 & 0x10) != 0 )
    {
      return (const __m128i *)&v21->m128i_i8[4];
    }
    else if ( (v15 & 0x20) != 0 )
    {
      return (const __m128i *)&v21->m128i_i8[5];
    }
    else if ( (v15 & 0x40) != 0 )
    {
      return (const __m128i *)&v21->m128i_i8[6];
    }
    else
    {
      return (const __m128i *)&v21->m128i_i8[7];
    }
  }
  else if ( (v15 & 0xF00) != 0 )
  {
    if ( (v15 & 0x100) != 0 )
    {
      return (const __m128i *)&v21->m128i_i8[8];
    }
    else if ( (v15 & 0x200) != 0 )
    {
      return (const __m128i *)&v21->m128i_i8[9];
    }
    else if ( (v15 & 0x400) != 0 )
    {
      return (const __m128i *)&v21->m128i_i8[10];
    }
    else
    {
      return (const __m128i *)&v21->m128i_i8[11];
    }
  }
  else if ( (v15 & 0x1000) != 0 )
  {
    return (const __m128i *)&v21->m128i_i8[12];
  }
  else if ( (v15 & 0x2000) != 0 )
  {
    return (const __m128i *)&v21->m128i_i8[13];
  }
  else if ( (v15 & 0x4000) != 0 )
  {
    return (const __m128i *)&v21->m128i_i8[14];
  }
  else
  {
    return (const __m128i *)&v21->m128i_i8[15];
  }
}

//----- (0807B4A0) --------------------------------------------------------
int __cdecl _memchr_sse2_bsf(const __m128i *a1, unsigned int a2, unsigned int a3)
{
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  __m128i v5; // xmm1
  unsigned int v6; // ecx
  const __m128i *v8; // edi
  int v9; // edx
  int v10; // ecx
  unsigned int v11; // edi
  unsigned int v12; // eax
  bool v13; // cc
  unsigned int v14; // edx
  unsigned int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // eax
  __m128i v18; // xmm4
  unsigned int v19; // eax
  char v20; // cl
  __m128i v21; // xmm0
  __m128i v22; // xmm2
  int v23; // eax
  __m128i v24; // xmm3
  __m128i v25; // xmm1
  unsigned int v26; // eax
  unsigned int v27; // edx
  unsigned int v28; // eax
  unsigned int v29; // eax
  unsigned int v30; // eax
  unsigned int v31; // eax

  v3 = _mm_cvtsi32_si128(a2);
  if ( !a3 )
    return 0;
  v4 = _mm_unpacklo_epi8(v3, v3);
  v5 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v4, v4), 0);
  if ( ((unsigned __int8)a1 & 0x3Fu) <= 0x30 )
  {
    v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v5));
    if ( v6 )
    {
      _BitScanForward(&v6, v6);
      if ( a3 > v6 )
        return (int)a1 + v6;
      return 0;
    }
    if ( a3 > 0x10 )
    {
      v8 = (const __m128i *)((unsigned int)&a1[1] & 0xFFFFFFF0);
      v9 = ((unsigned __int8)a1 & 0xF) + a3 - 16;
      goto LABEL_14;
    }
    return 0;
  }
  v10 = (unsigned __int8)a1 & 0xF;
  v11 = (unsigned int)a1 & 0xFFFFFFF0;
  v12 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0)), v5)) >> v10;
  if ( v12 )
  {
    _BitScanForward(&v12, v12);
    if ( a3 > v12 )
      return v10 + v11 + v12;
    return 0;
  }
  v9 = v10 + a3 - 16;
  if ( !((v9 < 0) ^ __OFADD__(v10, a3 - 16) | (v9 == 0)) )
  {
    v8 = (const __m128i *)(v11 + 16);
LABEL_14:
    v13 = (unsigned int)v9 <= 0x40;
    v14 = v9 - 64;
    if ( v13 )
      goto LABEL_32;
    v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8), v5));
    if ( v15 )
      goto LABEL_44;
    v16 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 1), v5));
    if ( v16 )
      goto LABEL_45;
    v17 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 2), v5));
    if ( !v17 )
    {
      v18 = _mm_cmpeq_epi8(_mm_load_si128(v8 + 3), v5);
      v8 += 4;
      v19 = _mm_movemask_epi8(v18);
      if ( v19 )
        goto LABEL_43;
      if ( ((unsigned __int8)v8 & 0x3F) == 0 )
        goto LABEL_26;
      v13 = v14 <= 0x40;
      v14 -= 64;
      if ( v13 )
        goto LABEL_32;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8), v5));
      if ( v15 )
        goto LABEL_44;
      v16 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 1), v5));
      if ( v16 )
        goto LABEL_45;
      v17 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 2), v5));
      if ( !v17 )
      {
        v19 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 3), v5));
        v8 += 4;
        if ( !v19 )
        {
          v20 = (char)v8;
          v8 = (const __m128i *)((unsigned int)v8 & 0xFFFFFFC0);
          v14 += v20 & 0x3F;
LABEL_26:
          while ( 1 )
          {
            v13 = v14 <= 0x40;
            v14 -= 64;
            if ( v13 )
              break;
            v21 = _mm_cmpeq_epi8(_mm_load_si128(v8), v5);
            v22 = _mm_cmpeq_epi8(_mm_load_si128(v8 + 1), v5);
            v23 = _mm_movemask_epi8(
                    _mm_max_epu8(
                      _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 3), v5), v22),
                      _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 2), v5), v21)));
            v8 += 4;
            if ( v23 )
            {
              v8 -= 4;
              v15 = _mm_movemask_epi8(v21);
              if ( v15 )
                goto LABEL_44;
              v16 = _mm_movemask_epi8(v22);
              if ( v16 )
                goto LABEL_45;
              v24 = _mm_cmpeq_epi8(_mm_load_si128(v8 + 2), v5);
              v25 = _mm_cmpeq_epi8(v5, v8[3]);
              v17 = _mm_movemask_epi8(v24);
              if ( v17 )
                goto LABEL_46;
              _BitScanForward(&v26, _mm_movemask_epi8(v25));
              return (int)&v8[3] + v26;
            }
          }
LABEL_32:
          v27 = v14 + 64;
          if ( v27 <= 0x20 )
          {
            v30 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8), v5));
            if ( v30 )
            {
              _BitScanForward(&v30, v30);
              if ( v27 > v30 )
                return (int)v8 + v30;
            }
            else if ( v27 > 0x10 )
            {
              v31 = _mm_movemask_epi8(_mm_cmpeq_epi8(v5, v8[1]));
              if ( !v31 )
                return 0;
              _BitScanForward(&v31, v31);
              if ( v27 - 16 > v31 )
                return (int)&v8[1] + v31;
            }
            return 0;
          }
          v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8), v5));
          if ( !v15 )
          {
            v16 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 1), v5));
            if ( !v16 )
            {
              v28 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v8 + 2), v5));
              if ( v28 )
              {
                _BitScanForward(&v28, v28);
                if ( v27 - 32 > v28 )
                  return (int)&v8[2] + v28;
              }
              else if ( v27 > 0x30 )
              {
                v29 = _mm_movemask_epi8(_mm_cmpeq_epi8(v5, v8[3]));
                if ( !v29 )
                  return 0;
                _BitScanForward(&v29, v29);
                if ( v27 - 48 > v29 )
                  return (int)&v8[3] + v29;
              }
              return 0;
            }
LABEL_45:
            _BitScanForward(&v16, v16);
            return (int)&v8[1] + v16;
          }
LABEL_44:
          _BitScanForward(&v15, v15);
          return (int)v8 + v15;
        }
LABEL_43:
        _BitScanForward(&v19, v19);
        return (int)&v8[-1] + v19;
      }
    }
LABEL_46:
    _BitScanForward(&v17, v17);
    return (int)&v8[2] + v17;
  }
  return 0;
}

//----- (0807B7F0) --------------------------------------------------------
const __m128i *__cdecl _rawmemchr_sse2(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  const __m128i *v4; // edx
  __m128i v5; // xmm1
  int v6; // eax
  const __m128i *v7; // edx
  int v8; // ecx
  const __m128i *v9; // edx
  __m128i v10; // xmm0
  __m128i v11; // xmm2
  __m128i v12; // xmm4

  v2 = _mm_cvtsi32_si128(a2);
  v3 = _mm_unpacklo_epi8(v2, v2);
  v4 = a1;
  v5 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v3, v3), 0);
  if ( ((unsigned __int8)a1 & 0x3Fu) <= 0x30 )
  {
    v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v5));
    if ( v6 )
      goto LABEL_21;
    v7 = (const __m128i *)((unsigned int)&a1[1] & 0xFFFFFFF0);
    goto LABEL_6;
  }
  v8 = (unsigned __int8)a1 & 0xF;
  v7 = (const __m128i *)((unsigned int)a1 & 0xFFFFFFF0);
  v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0)), v5)) >> v8;
  if ( !v6 )
  {
    ++v7;
LABEL_6:
    v8 = 0;
    v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7), v5));
    if ( !v6 )
    {
      v8 = 16;
      v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 1), v5));
      if ( !v6 )
      {
        v8 = 32;
        v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v5));
        if ( !v6 )
        {
          v8 = 48;
          v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 3), v5));
          if ( !v6 )
          {
            v7 += 4;
            v8 = 0;
            v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7), v5));
            if ( !v6 )
            {
              v8 = 16;
              v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 1), v5));
              if ( !v6 )
              {
                v8 = 32;
                v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v5));
                if ( !v6 )
                {
                  v8 = 48;
                  v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 3), v5));
                  if ( !v6 )
                  {
                    v9 = (const __m128i *)((unsigned int)&v7[4] & 0xFFFFFFC0);
                    do
                    {
                      v10 = _mm_cmpeq_epi8(_mm_load_si128(v9), v5);
                      v11 = _mm_cmpeq_epi8(_mm_load_si128(v9 + 1), v5);
                      v12 = _mm_max_epu8(
                              _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 3), v5), v11),
                              _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v9 + 2), v5), v10));
                      v9 += 4;
                    }
                    while ( !_mm_movemask_epi8(v12) );
                    v7 = v9 - 4;
                    v6 = _mm_movemask_epi8(v10);
                    v8 = 0;
                    if ( !v6 )
                    {
                      v6 = _mm_movemask_epi8(v11);
                      v8 = 16;
                      if ( !v6 )
                      {
                        v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v5));
                        v8 = 32;
                        if ( !v6 )
                        {
                          LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v5, v7[3]));
                          v8 = 48;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v4 = (const __m128i *)((char *)v7 + v8);
LABEL_21:
  if ( (_BYTE)v6 )
  {
    if ( (v6 & 0xF) != 0 )
    {
      if ( (v6 & 1) != 0 )
      {
        return v4;
      }
      else if ( (v6 & 2) != 0 )
      {
        return (const __m128i *)&v4->m128i_i8[1];
      }
      else if ( (v6 & 4) != 0 )
      {
        return (const __m128i *)&v4->m128i_i8[2];
      }
      else
      {
        return (const __m128i *)&v4->m128i_i8[3];
      }
    }
    else if ( (v6 & 0x10) != 0 )
    {
      return (const __m128i *)&v4->m128i_i8[4];
    }
    else if ( (v6 & 0x20) != 0 )
    {
      return (const __m128i *)&v4->m128i_i8[5];
    }
    else if ( (v6 & 0x40) != 0 )
    {
      return (const __m128i *)&v4->m128i_i8[6];
    }
    else
    {
      return (const __m128i *)&v4->m128i_i8[7];
    }
  }
  else if ( (v6 & 0xF00) != 0 )
  {
    if ( (v6 & 0x100) != 0 )
    {
      return (const __m128i *)&v4->m128i_i8[8];
    }
    else if ( (v6 & 0x200) != 0 )
    {
      return (const __m128i *)&v4->m128i_i8[9];
    }
    else if ( (v6 & 0x400) != 0 )
    {
      return (const __m128i *)&v4->m128i_i8[10];
    }
    else
    {
      return (const __m128i *)&v4->m128i_i8[11];
    }
  }
  else if ( (v6 & 0x1000) != 0 )
  {
    return (const __m128i *)&v4->m128i_i8[12];
  }
  else if ( (v6 & 0x2000) != 0 )
  {
    return (const __m128i *)&v4->m128i_i8[13];
  }
  else if ( (v6 & 0x4000) != 0 )
  {
    return (const __m128i *)&v4->m128i_i8[14];
  }
  else
  {
    return (const __m128i *)&v4->m128i_i8[15];
  }
}

//----- (0807BB10) --------------------------------------------------------
int __cdecl _rawmemchr_sse2_bsf(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  unsigned int v5; // ecx
  const __m128i *v7; // edx
  int v8; // ecx
  unsigned int v9; // edx
  int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  __m128i v14; // xmm4
  unsigned int v15; // eax
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  int v18; // eax
  __m128i v19; // xmm3
  __m128i v20; // xmm1
  unsigned int v21; // eax

  v2 = _mm_cvtsi32_si128(a2);
  v3 = _mm_unpacklo_epi8(v2, v2);
  v4 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v3, v3), 0);
  if ( ((unsigned __int8)a1 & 0x3Fu) > 0x30 )
  {
    v8 = (unsigned __int8)a1 & 0xF;
    v9 = (unsigned int)a1 & 0xFFFFFFF0;
    v10 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0)), v4)) >> v8;
    if ( v10 )
    {
      _BitScanForward((unsigned int *)&v10, v10);
      return v8 + v9 + v10;
    }
    v7 = (const __m128i *)(v9 + 16);
  }
  else
  {
    v5 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v4));
    if ( v5 )
    {
      _BitScanForward(&v5, v5);
      return (int)a1 + v5;
    }
    v7 = (const __m128i *)((unsigned int)&a1[1] & 0xFFFFFFF0);
  }
  v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7), v4));
  if ( v11 )
    goto LABEL_24;
  v12 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 1), v4));
  if ( v12 )
    goto LABEL_25;
  v13 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v4));
  if ( !v13 )
  {
    v14 = _mm_cmpeq_epi8(_mm_load_si128(v7 + 3), v4);
    v7 += 4;
    v15 = _mm_movemask_epi8(v14);
    if ( v15 )
      goto LABEL_23;
    if ( ((unsigned __int8)v7 & 0x3F) == 0 )
      goto LABEL_18;
    v11 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7), v4));
    if ( v11 )
      goto LABEL_24;
    v12 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 1), v4));
    if ( v12 )
      goto LABEL_25;
    v13 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v4));
    if ( !v13 )
    {
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 3), v4));
      v7 += 4;
      if ( !v15 )
      {
        v7 = (const __m128i *)((unsigned int)v7 & 0xFFFFFFC0);
        do
        {
LABEL_18:
          v16 = _mm_cmpeq_epi8(_mm_load_si128(v7), v4);
          v17 = _mm_cmpeq_epi8(_mm_load_si128(v7 + 1), v4);
          v18 = _mm_movemask_epi8(
                  _mm_max_epu8(
                    _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 3), v4), v17),
                    _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v4), v16)));
          v7 += 4;
        }
        while ( !v18 );
        v7 -= 4;
        v11 = _mm_movemask_epi8(v16);
        if ( !v11 )
        {
          v12 = _mm_movemask_epi8(v17);
          if ( !v12 )
          {
            v19 = _mm_cmpeq_epi8(_mm_load_si128(v7 + 2), v4);
            v20 = _mm_cmpeq_epi8(v4, v7[3]);
            v13 = _mm_movemask_epi8(v19);
            if ( !v13 )
            {
              _BitScanForward(&v21, _mm_movemask_epi8(v20));
              return (int)&v7[3] + v21;
            }
            goto LABEL_26;
          }
LABEL_25:
          _BitScanForward(&v12, v12);
          return (int)&v7[1] + v12;
        }
LABEL_24:
        _BitScanForward(&v11, v11);
        return (int)v7 + v11;
      }
LABEL_23:
      _BitScanForward(&v15, v15);
      return (int)&v7[-1] + v15;
    }
  }
LABEL_26:
  _BitScanForward(&v13, v13);
  return (int)&v7[2] + v13;
}

//----- (0807BD30) --------------------------------------------------------
int __cdecl _strnlen_sse2(_BYTE *a1, unsigned int a2)
{
  int result; // eax
  unsigned int v3; // edi
  bool v4; // cc
  unsigned int v5; // edi
  unsigned int v6; // edi
  _BYTE *v7; // ecx
  unsigned int v8; // eax
  unsigned int v9; // edi
  unsigned int v10; // edi
  __m128i v11; // xmm0
  int v12; // edx
  __m128i v13; // xmm1
  __m128i v14; // xmm2
  __m128i v15; // xmm3
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm2
  __m128i v19; // xmm3
  __m128i v20; // xmm0
  __m128i v21; // xmm1
  __m128i v22; // xmm2
  __m128i v23; // xmm3
  __m128i v24; // xmm3
  __m128i v25; // xmm1
  __m128i v26; // xmm6
  int v27; // edx
  __m128i v28; // xmm3
  __m128i v29; // xmm3
  __m128i v30; // xmm3
  unsigned int v31; // edi
  __m128i v32; // xmm0
  int v33; // edx
  __m128i *v34; // eax
  __m128i v35; // xmm1
  unsigned int v36; // edi
  unsigned int v37; // edi
  unsigned int v38; // edi

  if ( a2 <= 4 )
  {
    result = 0;
    if ( !a2 || !*a1 )
      return result;
    if ( a2 == 1 || !a1[1] )
      goto LABEL_155;
    if ( a2 != 2 && a1[2] )
    {
      if ( a2 != 3 && a1[3] )
        return 4;
      return 3;
    }
LABEL_156:
    result += 2;
    return result;
  }
  result = 0;
  if ( !*a1 )
    return result;
  if ( !a1[1] )
    goto LABEL_155;
  if ( !a1[2] )
    goto LABEL_156;
  if ( !a1[3] )
    return 3;
  v3 = a2 - 8;
  if ( a2 - 4 <= 4 )
  {
    v36 = v3 + 4;
    if ( !a1[4] )
      goto LABEL_158;
    if ( v36 == 1 || !a1[5] )
      goto LABEL_159;
    if ( v36 != 2 && a1[6] )
    {
      if ( v36 != 3 && a1[7] )
        return 8;
      return 7;
    }
LABEL_160:
    result += 6;
    return result;
  }
  if ( !a1[4] )
    goto LABEL_158;
  if ( !a1[5] )
    goto LABEL_159;
  if ( !a1[6] )
    goto LABEL_160;
  if ( !a1[7] )
    return 7;
  v4 = v3 <= 4;
  v5 = a2 - 12;
  if ( v4 )
  {
    v37 = v5 + 4;
    if ( !a1[8] )
      goto LABEL_162;
    if ( v37 == 1 || !a1[9] )
      goto LABEL_163;
    if ( v37 != 2 && a1[10] )
    {
      if ( v37 != 3 && a1[11] )
        return 12;
      return 11;
    }
LABEL_164:
    result += 10;
    return result;
  }
  if ( !a1[8] )
    goto LABEL_162;
  if ( !a1[9] )
    goto LABEL_163;
  if ( !a1[10] )
    goto LABEL_164;
  if ( !a1[11] )
    return 11;
  v4 = v5 <= 4;
  v6 = a2 - 16;
  if ( v4 )
  {
    v38 = v6 + 4;
    if ( !a1[12] )
      goto LABEL_166;
    if ( v38 == 1 || !a1[13] )
      goto LABEL_167;
    if ( v38 == 2 || !a1[14] )
      goto LABEL_168;
    if ( v38 != 3 && a1[15] )
      return 16;
    return 15;
  }
  if ( !a1[12] )
    goto LABEL_166;
  if ( !a1[13] )
    goto LABEL_167;
  if ( !a1[14] )
    goto LABEL_168;
  if ( !a1[15] )
    return 15;
  v7 = a1 + 16;
  v8 = (unsigned int)(a1 + 16) & 0xFFFFFFF0;
  v9 = ((unsigned __int8)a1 & 0xF) + v6;
  v4 = v9 <= 0x40;
  v10 = v9 - 64;
  if ( v4 )
    goto LABEL_68;
  v11 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v11);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v13 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v13);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v14 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v14);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v15 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v15);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v4 = v10 <= 0x40;
  v10 -= 64;
  if ( v4 )
    goto LABEL_68;
  v16 = _mm_cmpeq_epi8(v11, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v16);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v17 = _mm_cmpeq_epi8(v13, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v17);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v18 = _mm_cmpeq_epi8(v14, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v18);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v19 = _mm_cmpeq_epi8(v15, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v19);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v4 = v10 <= 0x40;
  v10 -= 64;
  if ( v4 )
    goto LABEL_68;
  v20 = _mm_cmpeq_epi8(v16, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v20);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v21 = _mm_cmpeq_epi8(v17, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v21);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v22 = _mm_cmpeq_epi8(v18, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v22);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v23 = _mm_cmpeq_epi8(v19, *(__m128i *)v8);
  v12 = _mm_movemask_epi8(v23);
  v8 += 16;
  if ( v12 )
    goto LABEL_48;
  v4 = v10 <= 0x40;
  v10 -= 64;
  if ( v4 )
    goto LABEL_68;
  v12 = _mm_movemask_epi8(_mm_cmpeq_epi8(v20, *(__m128i *)v8));
  v8 += 16;
  if ( v12
    || (v12 = _mm_movemask_epi8(_mm_cmpeq_epi8(v21, *(__m128i *)v8)), v8 += 16, v12)
    || (v12 = _mm_movemask_epi8(_mm_cmpeq_epi8(v22, *(__m128i *)v8)), v8 += 16, v12)
    || (v24 = _mm_cmpeq_epi8(v23, *(__m128i *)v8), v12 = _mm_movemask_epi8(v24), v8 += 16, v12) )
  {
LABEL_48:
    result = v8 - (_DWORD)v7;
    if ( (_BYTE)v12 )
    {
      if ( (v12 & 0xF) != 0 )
      {
        if ( (v12 & 1) != 0 )
          return result;
        if ( (v12 & 2) == 0 )
        {
          if ( (v12 & 4) == 0 )
          {
            result += 3;
            return result;
          }
          goto LABEL_156;
        }
LABEL_155:
        ++result;
        return result;
      }
      if ( (v12 & 0x10) == 0 )
      {
        if ( (v12 & 0x20) == 0 )
        {
          if ( (v12 & 0x40) == 0 )
          {
            result += 7;
            return result;
          }
          goto LABEL_160;
        }
LABEL_159:
        result += 5;
        return result;
      }
LABEL_158:
      result += 4;
      return result;
    }
    if ( (v12 & 0xF00) != 0 )
    {
      if ( (v12 & 0x100) == 0 )
      {
        if ( (v12 & 0x200) == 0 )
        {
          if ( (v12 & 0x400) == 0 )
          {
            result += 11;
            return result;
          }
          goto LABEL_164;
        }
LABEL_163:
        result += 9;
        return result;
      }
LABEL_162:
      result += 8;
      return result;
    }
    if ( (v12 & 0x1000) == 0 )
    {
      if ( (v12 & 0x2000) == 0 )
      {
        if ( (v12 & 0x4000) == 0 )
        {
          result += 15;
          return result;
        }
LABEL_168:
        result += 14;
        return result;
      }
LABEL_167:
      result += 13;
      return result;
    }
LABEL_166:
    result += 12;
    return result;
  }
  v10 += v8 & 0x3F;
  v8 &= 0xFFFFFFC0;
  while ( 1 )
  {
    v4 = v10 <= 0x40;
    v10 -= 64;
    if ( v4 )
      break;
    v25 = *(__m128i *)(v8 + 16);
    v26 = *(__m128i *)(v8 + 48);
    v27 = _mm_movemask_epi8(
            _mm_cmpeq_epi8(
              _mm_min_epu8(_mm_min_epu8(*(__m128i *)(v8 + 32), v26), _mm_min_epu8(*(__m128i *)v8, v25)),
              v24));
    v8 += 64;
    if ( v27 )
    {
      v28 = _mm_cmpeq_epi8(v24, *(__m128i *)(v8 - 64));
      v12 = _mm_movemask_epi8(v28);
      v7 = a1 + 64;
      if ( !v12 )
      {
        v29 = _mm_cmpeq_epi8(v28, v25);
        v12 = _mm_movemask_epi8(v29);
        v7 = a1 + 48;
        if ( !v12 )
        {
          v30 = _mm_cmpeq_epi8(v29, *(__m128i *)(v8 - 32));
          v12 = _mm_movemask_epi8(v30);
          v7 = a1 + 32;
          if ( !v12 )
          {
            LOWORD(v12) = _mm_movemask_epi8(_mm_cmpeq_epi8(v30, v26));
            v7 = a1 + 16;
          }
        }
      }
      goto LABEL_48;
    }
  }
LABEL_68:
  v31 = v10 + 64;
  v32 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v8);
  v33 = _mm_movemask_epi8(v32);
  v34 = (__m128i *)(v8 + 16);
  if ( v33 )
    goto LABEL_76;
  v4 = v31 <= 0x10;
  v31 -= 16;
  if ( v4 )
    return a2;
  v35 = _mm_cmpeq_epi8((__m128i)0LL, *v34);
  v33 = _mm_movemask_epi8(v35);
  ++v34;
  if ( v33 )
    goto LABEL_76;
  v4 = v31 <= 0x10;
  v31 -= 16;
  if ( v4 )
    return a2;
  v33 = _mm_movemask_epi8(_mm_cmpeq_epi8(v32, *v34++));
  if ( v33 )
    goto LABEL_76;
  v4 = v31 <= 0x10;
  v31 -= 16;
  if ( v4 )
    return a2;
  v33 = _mm_movemask_epi8(_mm_cmpeq_epi8(v35, *v34++));
  if ( !v33 )
    return a2;
LABEL_76:
  result = (char *)v34 - v7;
  if ( !(_BYTE)v33 )
  {
    if ( (v33 & 0xF00) != 0 )
    {
      if ( (v33 & 0x100) != 0 )
      {
        if ( v31 >= 9 )
        {
          result += 8;
          return result;
        }
      }
      else if ( (v33 & 0x200) != 0 )
      {
        if ( v31 >= 0xA )
        {
          result += 9;
          return result;
        }
      }
      else if ( (v33 & 0x400) != 0 )
      {
        if ( v31 >= 0xB )
        {
          result += 10;
          return result;
        }
      }
      else if ( v31 >= 0xC )
      {
        result += 11;
        return result;
      }
    }
    else if ( (v33 & 0x1000) != 0 )
    {
      if ( v31 >= 0xD )
      {
        result += 12;
        return result;
      }
    }
    else if ( (v33 & 0x2000) != 0 )
    {
      if ( v31 >= 0xE )
      {
        result += 13;
        return result;
      }
    }
    else if ( (v33 & 0x4000) != 0 )
    {
      if ( v31 >= 0xF )
      {
        result += 14;
        return result;
      }
    }
    else if ( v31 >= 0x10 )
    {
      result += 15;
      return result;
    }
    return a2;
  }
  if ( (v33 & 0xF) == 0 )
  {
    if ( (v33 & 0x10) != 0 )
    {
      if ( v31 >= 5 )
      {
        result += 4;
        return result;
      }
    }
    else if ( (v33 & 0x20) != 0 )
    {
      if ( v31 >= 6 )
      {
        result += 5;
        return result;
      }
    }
    else if ( (v33 & 0x40) != 0 )
    {
      if ( v31 >= 7 )
      {
        result += 6;
        return result;
      }
    }
    else if ( v31 >= 8 )
    {
      result += 7;
      return result;
    }
    return a2;
  }
  if ( (v33 & 1) == 0 )
  {
    if ( (v33 & 2) != 0 )
    {
      if ( v31 >= 2 )
      {
        ++result;
        return result;
      }
    }
    else if ( (v33 & 4) != 0 )
    {
      if ( v31 >= 3 )
      {
        result += 2;
        return result;
      }
    }
    else if ( v31 >= 4 )
    {
      result += 3;
      return result;
    }
    return a2;
  }
  return result;
}

//----- (0807C420) --------------------------------------------------------
int __cdecl _strnlen_ia32(_BYTE *a1, int a2)
{
  int result; // eax
  unsigned int v3; // ebx
  _BYTE *v4; // eax
  _BYTE *v5; // edx

  result = 0;
  if ( !a2 )
    return result;
  v3 = (unsigned int)&a1[a2];
  if ( __CFADD__(a1, a2) )
    v3 = -1;
  v4 = a1;
  if ( ((unsigned __int8)a1 & 3) == 0 )
  {
LABEL_9:
    if ( v3 <= (unsigned int)v4 )
      goto LABEL_18;
    v5 = v4;
    while ( 1 )
    {
      if ( ((*(_DWORD *)v5 - 16843009) & 0x80808080) != 0 )
      {
        if ( !*v5 )
        {
          v4 = v5;
          goto LABEL_18;
        }
        v4 = v5 + 1;
        if ( !v5[1] )
          goto LABEL_18;
        v4 = v5 + 2;
        if ( !v5[2] )
          goto LABEL_18;
        v4 = v5 + 3;
        if ( !v5[3] )
          goto LABEL_18;
      }
      v5 += 4;
      if ( v3 <= (unsigned int)v5 )
      {
        v4 = (_BYTE *)v3;
        goto LABEL_18;
      }
    }
  }
  if ( *a1 )
  {
    while ( ((unsigned __int8)++v4 & 3) != 0 )
    {
      if ( !*v4 )
        goto LABEL_18;
    }
    goto LABEL_9;
  }
LABEL_18:
  if ( (unsigned int)v4 > v3 )
    v4 = (_BYTE *)v3;
  return v4 - a1;
}

//----- (0807C4C0) --------------------------------------------------------
int __cdecl _strcasecmp_ssse3(int a1, int a2)
{
  if ( (*(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFD8) + 320) & 1) == 0 )
    JUMPOUT(0x807C4F6);
  return _strcasecmp_nonascii(a1, a2);
}
// 807C4D8: control flows out of bounds to 807C4F6

//----- (0807C4E0) --------------------------------------------------------
int __cdecl _strcasecmp_l_ssse3(int a1, int a2, int a3)
{
  int v3; // edx
  int v4; // eax
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __m128i v7; // xmm1
  int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // edi
  const __m128i *v11; // eax
  const __m128i *v12; // edx
  const __m128i *v13; // et0
  unsigned int v14; // et1
  int v15; // edi
  bool v16; // zf
  __m128i si128; // xmm1
  __m128i v18; // xmm2
  unsigned int v19; // edi
  int v20; // esi
  int v21; // edi
  __m128i v22; // xmm0
  __m128i v23; // xmm1
  __m128i v24; // xmm2
  __m128i v25; // xmm1
  __m128i v26; // xmm1
  __m128i v27; // xmm2
  unsigned int v28; // edi
  __m128i v29; // xmm3
  __m128i v30; // xmm0
  int v31; // edi
  char v32; // cc
  __m128i v33; // xmm1
  __m128i v34; // xmm4
  __m128i v35; // xmm2
  __m128i v36; // xmm1
  __m128i v37; // xmm1
  __m128i v38; // xmm4
  __m128i v39; // xmm2
  __m128i v40; // xmm1
  __m128i v41; // xmm0
  __m128i v42; // xmm1
  __m128i v43; // xmm0
  __m128i v44; // xmm3
  __m128i v45; // xmm1
  __m128i v46; // xmm2
  unsigned int v47; // edi
  __m128i v48; // xmm3
  __m128i v49; // xmm0
  int v50; // edi
  __m128i v51; // xmm1
  __m128i v52; // xmm4
  __m128i v53; // xmm2
  __m128i v54; // xmm1
  __m128i v55; // xmm1
  __m128i v56; // xmm4
  __m128i v57; // xmm2
  __m128i v58; // xmm1
  __m128i v59; // xmm0
  __m128i v60; // xmm1
  __m128i v61; // xmm2
  unsigned int v62; // edi
  __m128i v63; // xmm3
  __m128i v64; // xmm0
  int v65; // edi
  __m128i v66; // xmm1
  __m128i v67; // xmm4
  __m128i v68; // xmm2
  __m128i v69; // xmm1
  __m128i v70; // xmm1
  __m128i v71; // xmm4
  __m128i v72; // xmm2
  __m128i v73; // xmm1
  __m128i v74; // xmm0
  __m128i v75; // xmm1
  __m128i v76; // xmm2
  unsigned int v77; // edi
  __m128i v78; // xmm3
  __m128i v79; // xmm0
  int v80; // edi
  __m128i v81; // xmm1
  __m128i v82; // xmm4
  __m128i v83; // xmm2
  __m128i v84; // xmm1
  __m128i v85; // xmm1
  __m128i v86; // xmm4
  __m128i v87; // xmm2
  __m128i v88; // xmm1
  __m128i v89; // xmm0
  __m128i v90; // xmm1
  __m128i v91; // xmm2
  unsigned int v92; // edi
  __m128i v93; // xmm3
  __m128i v94; // xmm0
  int v95; // edi
  __m128i v96; // xmm1
  __m128i v97; // xmm4
  __m128i v98; // xmm2
  __m128i v99; // xmm1
  __m128i v100; // xmm1
  __m128i v101; // xmm4
  __m128i v102; // xmm2
  __m128i v103; // xmm1
  __m128i v104; // xmm0
  __m128i v105; // xmm1
  __m128i v106; // xmm2
  unsigned int v107; // edi
  __m128i v108; // xmm3
  __m128i v109; // xmm0
  int v110; // edi
  __m128i v111; // xmm1
  __m128i v112; // xmm4
  __m128i v113; // xmm2
  __m128i v114; // xmm1
  __m128i v115; // xmm1
  __m128i v116; // xmm4
  __m128i v117; // xmm2
  __m128i v118; // xmm1
  __m128i v119; // xmm0
  __m128i v120; // xmm1
  __m128i v121; // xmm2
  unsigned int v122; // edi
  __m128i v123; // xmm3
  __m128i v124; // xmm0
  int v125; // edi
  __m128i v126; // xmm1
  __m128i v127; // xmm4
  __m128i v128; // xmm2
  __m128i v129; // xmm1
  __m128i v130; // xmm1
  __m128i v131; // xmm4
  __m128i v132; // xmm2
  __m128i v133; // xmm1
  __m128i v134; // xmm0
  __m128i v135; // xmm1
  __m128i v136; // xmm2
  unsigned int v137; // edi
  __m128i v138; // xmm3
  __m128i v139; // xmm0
  int v140; // edi
  __m128i v141; // xmm1
  __m128i v142; // xmm4
  __m128i v143; // xmm2
  __m128i v144; // xmm1
  __m128i v145; // xmm1
  __m128i v146; // xmm4
  __m128i v147; // xmm2
  __m128i v148; // xmm1
  __m128i v149; // xmm0
  __m128i v150; // xmm1
  __m128i v151; // xmm2
  unsigned int v152; // edi
  __m128i v153; // xmm3
  __m128i v154; // xmm0
  int v155; // edi
  __m128i v156; // xmm1
  __m128i v157; // xmm4
  __m128i v158; // xmm2
  __m128i v159; // xmm1
  __m128i v160; // xmm1
  __m128i v161; // xmm4
  __m128i v162; // xmm2
  __m128i v163; // xmm1
  __m128i v164; // xmm0
  __m128i v165; // xmm1
  __m128i v166; // xmm2
  unsigned int v167; // edi
  __m128i v168; // xmm3
  __m128i v169; // xmm0
  int v170; // edi
  __m128i v171; // xmm1
  __m128i v172; // xmm4
  __m128i v173; // xmm2
  __m128i v174; // xmm1
  __m128i v175; // xmm1
  __m128i v176; // xmm4
  __m128i v177; // xmm2
  __m128i v178; // xmm1
  __m128i v179; // xmm0
  __m128i v180; // xmm1
  __m128i v181; // xmm2
  unsigned int v182; // edi
  __m128i v183; // xmm3
  __m128i v184; // xmm0
  int v185; // edi
  __m128i v186; // xmm1
  __m128i v187; // xmm4
  __m128i v188; // xmm2
  __m128i v189; // xmm1
  __m128i v190; // xmm1
  __m128i v191; // xmm4
  __m128i v192; // xmm2
  __m128i v193; // xmm1
  __m128i v194; // xmm0
  __m128i v195; // xmm1
  __m128i v196; // xmm2
  unsigned int v197; // edi
  __m128i v198; // xmm3
  __m128i v199; // xmm0
  int v200; // edi
  __m128i v201; // xmm1
  __m128i v202; // xmm4
  __m128i v203; // xmm2
  __m128i v204; // xmm1
  __m128i v205; // xmm1
  __m128i v206; // xmm4
  __m128i v207; // xmm2
  __m128i v208; // xmm1
  __m128i v209; // xmm0
  __m128i v210; // xmm1
  __m128i v211; // xmm2
  unsigned int v212; // edi
  __m128i v213; // xmm3
  __m128i v214; // xmm0
  int v215; // edi
  __m128i v216; // xmm1
  __m128i v217; // xmm4
  __m128i v218; // xmm2
  __m128i v219; // xmm1
  __m128i v220; // xmm1
  __m128i v221; // xmm4
  __m128i v222; // xmm2
  __m128i v223; // xmm1
  __m128i v224; // xmm0
  __m128i v225; // xmm1
  __m128i v226; // xmm2
  unsigned int v227; // edi
  __m128i v228; // xmm3
  __m128i v229; // xmm0
  int v230; // edi
  __m128i v231; // xmm1
  __m128i v232; // xmm4
  __m128i v233; // xmm2
  __m128i v234; // xmm1
  __m128i v235; // xmm1
  __m128i v236; // xmm4
  __m128i v237; // xmm2
  __m128i v238; // xmm1
  __m128i v239; // xmm0
  __m128i v240; // xmm1
  __m128i v241; // xmm2
  unsigned int v242; // edi
  __m128i v243; // xmm3
  __m128i v244; // xmm0
  int v245; // edi
  __m128i v246; // xmm1
  __m128i v247; // xmm4
  __m128i v248; // xmm2
  __m128i v249; // xmm1
  __m128i v250; // xmm1
  __m128i v251; // xmm4
  __m128i v252; // xmm2
  __m128i v253; // xmm1
  __m128i v254; // xmm0
  unsigned __int8 *v255; // et2
  char v257; // [esp+0h] [ebp-Ch]

  if ( (*(_DWORD *)(*(_DWORD *)a3 + 320) & 1) != 0 )
    return _strcasecmp_nonascii(a1, a2);
  v3 = a1;
  v4 = a2;
  if ( (a1 & 0xFFFu) <= 0xFF0 && (a2 & 0xFFFu) <= 0xFF0 )
  {
    v5.m128i_i64[0] = *(__int64 *)a2;
    v6.m128i_i64[0] = *(__int64 *)a1;
    v5.m128i_i64[1] = *(__int64 *)(a2 + 8);
    v6.m128i_i64[1] = *(__int64 *)(a1 + 8);
    v7 = _mm_or_si128(
           v5,
           _mm_and_si128(
             _mm_and_si128(
               _mm_cmpgt_epi8(v5, (__m128i)xmmword_80CA9D0),
               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v5)),
             (__m128i)xmmword_80CA9F0));
    v8 = _mm_movemask_epi8(
           _mm_sub_epi8(
             _mm_cmpeq_epi8(
               v7,
               _mm_or_si128(
                 v6,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v6, (__m128i)xmmword_80CA9D0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v6)),
                   (__m128i)xmmword_80CA9F0))),
             _mm_cmpeq_epi8((__m128i)0LL, v7)))
       - 0xFFFF;
    if ( v8 )
      goto LABEL_184;
    v4 = a2 + 16;
    v3 = a1 + 16;
  }
  v257 = 0;
  v9 = v4 & 0xF;
  v10 = v3 & 0xF;
  v11 = (const __m128i *)(v9 ^ v4);
  v12 = (const __m128i *)(v10 ^ v3);
  if ( v9 == v10 )
  {
LABEL_25:
    si128 = _mm_load_si128(v11);
    v18 = _mm_load_si128(v12);
    v19 = (unsigned int)_mm_movemask_epi8(
                          _mm_sub_epi8(
                            _mm_cmpeq_epi8(
                              _mm_or_si128(
                                si128,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(si128, (__m128i)xmmword_80CA9D0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), si128)),
                                  (__m128i)xmmword_80CA9F0)),
                              _mm_or_si128(
                                v18,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(v18, (__m128i)xmmword_80CA9D0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v18)),
                                  (__m128i)xmmword_80CA9F0))),
                            _mm_cmpeq_epi8((__m128i)0LL, si128))) >> v9;
    v20 = (0xFFFFu >> v9) - v19;
    v16 = 0xFFFFu >> v9 == v19;
    v21 = v9;
    if ( v16 )
    {
      v257 = 16;
      v9 = 16;
      v22 = 0LL;
      while ( 1 )
      {
        v23 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
        v24 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
        v25 = _mm_or_si128(
                v23,
                _mm_and_si128(
                  _mm_and_si128(
                    _mm_cmpgt_epi8(v23, (__m128i)xmmword_80CA9D0),
                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v23)),
                  (__m128i)xmmword_80CA9F0));
        v22 = _mm_cmpeq_epi8(v22, v25);
        v20 = _mm_movemask_epi8(
                _mm_sub_epi8(
                  _mm_cmpeq_epi8(
                    v25,
                    _mm_or_si128(
                      v24,
                      _mm_and_si128(
                        _mm_and_si128(
                          _mm_cmpgt_epi8(v24, (__m128i)xmmword_80CA9D0),
                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v24)),
                        (__m128i)xmmword_80CA9F0))),
                  v22))
            - 0xFFFF;
        if ( v20 )
          break;
        v9 += 16;
      }
      goto LABEL_180;
    }
    goto LABEL_181;
  }
  if ( v9 <= v10 )
  {
    v257 = 32;
    v13 = v11;
    v11 = v12;
    v12 = v13;
    v14 = v9;
    v9 = v10;
    v10 = v14;
  }
  v15 = v10 + 15 - v9;
  v16 = v15 == 8;
  if ( v15 <= 8 )
    goto LABEL_16;
  if ( v15 != 14 )
  {
    if ( v15 != 13 )
    {
      if ( v15 != 12 )
      {
        if ( v15 != 11 )
        {
          if ( v15 != 10 )
          {
            v16 = v15 == 9;
            if ( v15 != 9 )
            {
LABEL_16:
              if ( !v16 )
              {
                if ( v15 != 7 )
                {
                  if ( v15 != 6 )
                  {
                    if ( v15 != 5 )
                    {
                      if ( v15 != 4 )
                      {
                        if ( v15 != 3 )
                        {
                          if ( v15 != 2 )
                          {
                            if ( v15 != 1 )
                            {
                              if ( v15 )
                                goto LABEL_25;
                              v26 = _mm_load_si128(v11);
                              v27 = _mm_slli_si128(_mm_load_si128(v12), 15);
                              v28 = (unsigned int)_mm_movemask_epi8(
                                                    _mm_sub_epi8(
                                                      _mm_cmpeq_epi8(
                                                        _mm_or_si128(
                                                          v27,
                                                          _mm_and_si128(
                                                            _mm_and_si128(
                                                              _mm_cmpgt_epi8(v27, (__m128i)xmmword_80CA9D0),
                                                              _mm_cmpgt_epi8(
                                                                _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                                v27)),
                                                            (__m128i)xmmword_80CA9F0)),
                                                        _mm_or_si128(
                                                          v26,
                                                          _mm_and_si128(
                                                            _mm_and_si128(
                                                              _mm_cmpgt_epi8(v26, (__m128i)xmmword_80CA9D0),
                                                              _mm_cmpgt_epi8(
                                                                _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                                v26)),
                                                            (__m128i)xmmword_80CA9F0))),
                                                      _mm_cmpeq_epi8((__m128i)0LL, v26))) >> v9;
                              v20 = (0xFFFFu >> v9) - v28;
                              v16 = 0xFFFFu >> v9 == v28;
                              v21 = v9 - 15;
                              if ( !v16 )
                                goto LABEL_181;
                              v29 = _mm_load_si128(v12);
                              v30 = 0LL;
                              v9 = 16;
                              v257 |= 1u;
                              v31 = (((_WORD)v12 + 1) & 0xFFF) - 4096;
                              while ( 1 )
                              {
                                v32 = (v31 + 16 < 0) ^ __OFADD__(16, v31) | (v31 == -16);
                                v31 += 16;
                                if ( !v32 )
                                  goto LABEL_36;
                                while ( 1 )
                                {
                                  v33 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                                  v34 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                                  v35 = _mm_alignr_epi8(v34, v29, 1);
                                  v36 = _mm_or_si128(
                                          v33,
                                          _mm_and_si128(
                                            _mm_and_si128(
                                              _mm_cmpgt_epi8(v33, (__m128i)xmmword_80CA9D0),
                                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v33)),
                                            (__m128i)xmmword_80CA9F0));
                                  v30 = _mm_cmpeq_epi8(v30, v36);
                                  v20 = _mm_movemask_epi8(
                                          _mm_sub_epi8(
                                            _mm_cmpeq_epi8(
                                              v36,
                                              _mm_or_si128(
                                                v35,
                                                _mm_and_si128(
                                                  _mm_and_si128(
                                                    _mm_cmpgt_epi8(v35, (__m128i)xmmword_80CA9D0),
                                                    _mm_cmpgt_epi8(
                                                      _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                      v35)),
                                                  (__m128i)xmmword_80CA9F0))),
                                            v30))
                                      - 0xFFFF;
                                  if ( v20 )
                                    goto LABEL_180;
                                  v9 += 16;
                                  v29 = v34;
                                  v32 = (v31 + 16 < 0) ^ __OFADD__(16, v31) | (v31 == -16);
                                  v31 += 16;
                                  if ( v32 )
                                    break;
LABEL_36:
                                  v41 = _mm_cmpeq_epi8(v30, v29);
                                  if ( (_mm_movemask_epi8(v41) & 0xFFFE) != 0 )
                                  {
                                    v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                                    v43 = _mm_srli_si128(v41, 1);
                                    v44 = _mm_srli_si128(v29, 1);
                                    goto LABEL_179;
                                  }
                                  v30 = 0LL;
                                  v31 -= 4096;
                                }
                                v37 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                                v38 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                                v39 = _mm_alignr_epi8(v38, v29, 1);
                                v40 = _mm_or_si128(
                                        v37,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v37, (__m128i)xmmword_80CA9D0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v37)),
                                          (__m128i)xmmword_80CA9F0));
                                v30 = _mm_cmpeq_epi8(v30, v40);
                                v20 = _mm_movemask_epi8(
                                        _mm_sub_epi8(
                                          _mm_cmpeq_epi8(
                                            v40,
                                            _mm_or_si128(
                                              v39,
                                              _mm_and_si128(
                                                _mm_and_si128(
                                                  _mm_cmpgt_epi8(v39, (__m128i)xmmword_80CA9D0),
                                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v39)),
                                                (__m128i)xmmword_80CA9F0))),
                                          v30))
                                    - 0xFFFF;
                                if ( v20 )
                                  goto LABEL_180;
                                v9 += 16;
                                v29 = v38;
                              }
                            }
                            v45 = _mm_load_si128(v11);
                            v46 = _mm_slli_si128(_mm_load_si128(v12), 14);
                            v47 = (unsigned int)_mm_movemask_epi8(
                                                  _mm_sub_epi8(
                                                    _mm_cmpeq_epi8(
                                                      _mm_or_si128(
                                                        v46,
                                                        _mm_and_si128(
                                                          _mm_and_si128(
                                                            _mm_cmpgt_epi8(v46, (__m128i)xmmword_80CA9D0),
                                                            _mm_cmpgt_epi8(
                                                              _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                              v46)),
                                                          (__m128i)xmmword_80CA9F0)),
                                                      _mm_or_si128(
                                                        v45,
                                                        _mm_and_si128(
                                                          _mm_and_si128(
                                                            _mm_cmpgt_epi8(v45, (__m128i)xmmword_80CA9D0),
                                                            _mm_cmpgt_epi8(
                                                              _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                              v45)),
                                                          (__m128i)xmmword_80CA9F0))),
                                                    _mm_cmpeq_epi8((__m128i)0LL, v45))) >> v9;
                            v20 = (0xFFFFu >> v9) - v47;
                            v16 = 0xFFFFu >> v9 == v47;
                            v21 = v9 - 14;
                            if ( !v16 )
                              goto LABEL_181;
                            v48 = _mm_load_si128(v12);
                            v49 = 0LL;
                            v9 = 16;
                            v257 |= 2u;
                            v50 = (((_WORD)v12 + 2) & 0xFFF) - 4096;
                            while ( 1 )
                            {
                              v32 = (v50 + 16 < 0) ^ __OFADD__(16, v50) | (v50 == -16);
                              v50 += 16;
                              if ( !v32 )
                                goto LABEL_46;
                              while ( 1 )
                              {
                                v51 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                                v52 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                                v53 = _mm_alignr_epi8(v52, v48, 2);
                                v54 = _mm_or_si128(
                                        v51,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v51, (__m128i)xmmword_80CA9D0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v51)),
                                          (__m128i)xmmword_80CA9F0));
                                v49 = _mm_cmpeq_epi8(v49, v54);
                                v20 = _mm_movemask_epi8(
                                        _mm_sub_epi8(
                                          _mm_cmpeq_epi8(
                                            v54,
                                            _mm_or_si128(
                                              v53,
                                              _mm_and_si128(
                                                _mm_and_si128(
                                                  _mm_cmpgt_epi8(v53, (__m128i)xmmword_80CA9D0),
                                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v53)),
                                                (__m128i)xmmword_80CA9F0))),
                                          v49))
                                    - 0xFFFF;
                                if ( v20 )
                                  goto LABEL_180;
                                v9 += 16;
                                v48 = v52;
                                v32 = (v50 + 16 < 0) ^ __OFADD__(16, v50) | (v50 == -16);
                                v50 += 16;
                                if ( v32 )
                                  break;
LABEL_46:
                                v59 = _mm_cmpeq_epi8(v49, v48);
                                if ( (_mm_movemask_epi8(v59) & 0xFFFC) != 0 )
                                {
                                  v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                                  v43 = _mm_srli_si128(v59, 2);
                                  v44 = _mm_srli_si128(v48, 2);
                                  goto LABEL_179;
                                }
                                v49 = 0LL;
                                v50 -= 4096;
                              }
                              v55 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                              v56 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                              v57 = _mm_alignr_epi8(v56, v48, 2);
                              v58 = _mm_or_si128(
                                      v55,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v55, (__m128i)xmmword_80CA9D0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v55)),
                                        (__m128i)xmmword_80CA9F0));
                              v49 = _mm_cmpeq_epi8(v49, v58);
                              v20 = _mm_movemask_epi8(
                                      _mm_sub_epi8(
                                        _mm_cmpeq_epi8(
                                          v58,
                                          _mm_or_si128(
                                            v57,
                                            _mm_and_si128(
                                              _mm_and_si128(
                                                _mm_cmpgt_epi8(v57, (__m128i)xmmword_80CA9D0),
                                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v57)),
                                              (__m128i)xmmword_80CA9F0))),
                                        v49))
                                  - 0xFFFF;
                              if ( v20 )
                                goto LABEL_180;
                              v9 += 16;
                              v48 = v56;
                            }
                          }
                          v60 = _mm_load_si128(v11);
                          v61 = _mm_slli_si128(_mm_load_si128(v12), 13);
                          v62 = (unsigned int)_mm_movemask_epi8(
                                                _mm_sub_epi8(
                                                  _mm_cmpeq_epi8(
                                                    _mm_or_si128(
                                                      v61,
                                                      _mm_and_si128(
                                                        _mm_and_si128(
                                                          _mm_cmpgt_epi8(v61, (__m128i)xmmword_80CA9D0),
                                                          _mm_cmpgt_epi8(
                                                            _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                            v61)),
                                                        (__m128i)xmmword_80CA9F0)),
                                                    _mm_or_si128(
                                                      v60,
                                                      _mm_and_si128(
                                                        _mm_and_si128(
                                                          _mm_cmpgt_epi8(v60, (__m128i)xmmword_80CA9D0),
                                                          _mm_cmpgt_epi8(
                                                            _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                            v60)),
                                                        (__m128i)xmmword_80CA9F0))),
                                                  _mm_cmpeq_epi8((__m128i)0LL, v60))) >> v9;
                          v20 = (0xFFFFu >> v9) - v62;
                          v16 = 0xFFFFu >> v9 == v62;
                          v21 = v9 - 13;
                          if ( !v16 )
                            goto LABEL_181;
                          v63 = _mm_load_si128(v12);
                          v64 = 0LL;
                          v9 = 16;
                          v257 |= 3u;
                          v65 = (((_WORD)v12 + 3) & 0xFFF) - 4096;
                          while ( 1 )
                          {
                            v32 = (v65 + 16 < 0) ^ __OFADD__(16, v65) | (v65 == -16);
                            v65 += 16;
                            if ( !v32 )
                              goto LABEL_56;
                            while ( 1 )
                            {
                              v66 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                              v67 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                              v68 = _mm_alignr_epi8(v67, v63, 3);
                              v69 = _mm_or_si128(
                                      v66,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v66, (__m128i)xmmword_80CA9D0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v66)),
                                        (__m128i)xmmword_80CA9F0));
                              v64 = _mm_cmpeq_epi8(v64, v69);
                              v20 = _mm_movemask_epi8(
                                      _mm_sub_epi8(
                                        _mm_cmpeq_epi8(
                                          v69,
                                          _mm_or_si128(
                                            v68,
                                            _mm_and_si128(
                                              _mm_and_si128(
                                                _mm_cmpgt_epi8(v68, (__m128i)xmmword_80CA9D0),
                                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v68)),
                                              (__m128i)xmmword_80CA9F0))),
                                        v64))
                                  - 0xFFFF;
                              if ( v20 )
                                goto LABEL_180;
                              v9 += 16;
                              v63 = v67;
                              v32 = (v65 + 16 < 0) ^ __OFADD__(16, v65) | (v65 == -16);
                              v65 += 16;
                              if ( v32 )
                                break;
LABEL_56:
                              v74 = _mm_cmpeq_epi8(v64, v63);
                              if ( (_mm_movemask_epi8(v74) & 0xFFF8) != 0 )
                              {
                                v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                                v43 = _mm_srli_si128(v74, 3);
                                v44 = _mm_srli_si128(v63, 3);
                                goto LABEL_179;
                              }
                              v64 = 0LL;
                              v65 -= 4096;
                            }
                            v70 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                            v71 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                            v72 = _mm_alignr_epi8(v71, v63, 3);
                            v73 = _mm_or_si128(
                                    v70,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v70, (__m128i)xmmword_80CA9D0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v70)),
                                      (__m128i)xmmword_80CA9F0));
                            v64 = _mm_cmpeq_epi8(v64, v73);
                            v20 = _mm_movemask_epi8(
                                    _mm_sub_epi8(
                                      _mm_cmpeq_epi8(
                                        v73,
                                        _mm_or_si128(
                                          v72,
                                          _mm_and_si128(
                                            _mm_and_si128(
                                              _mm_cmpgt_epi8(v72, (__m128i)xmmword_80CA9D0),
                                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v72)),
                                            (__m128i)xmmword_80CA9F0))),
                                      v64))
                                - 0xFFFF;
                            if ( v20 )
                              goto LABEL_180;
                            v9 += 16;
                            v63 = v71;
                          }
                        }
                        v75 = _mm_load_si128(v11);
                        v76 = _mm_slli_si128(_mm_load_si128(v12), 12);
                        v77 = (unsigned int)_mm_movemask_epi8(
                                              _mm_sub_epi8(
                                                _mm_cmpeq_epi8(
                                                  _mm_or_si128(
                                                    v76,
                                                    _mm_and_si128(
                                                      _mm_and_si128(
                                                        _mm_cmpgt_epi8(v76, (__m128i)xmmword_80CA9D0),
                                                        _mm_cmpgt_epi8(
                                                          _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                          v76)),
                                                      (__m128i)xmmword_80CA9F0)),
                                                  _mm_or_si128(
                                                    v75,
                                                    _mm_and_si128(
                                                      _mm_and_si128(
                                                        _mm_cmpgt_epi8(v75, (__m128i)xmmword_80CA9D0),
                                                        _mm_cmpgt_epi8(
                                                          _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                          v75)),
                                                      (__m128i)xmmword_80CA9F0))),
                                                _mm_cmpeq_epi8((__m128i)0LL, v75))) >> v9;
                        v20 = (0xFFFFu >> v9) - v77;
                        v16 = 0xFFFFu >> v9 == v77;
                        v21 = v9 - 12;
                        if ( !v16 )
                          goto LABEL_181;
                        v78 = _mm_load_si128(v12);
                        v79 = 0LL;
                        v9 = 16;
                        v257 |= 4u;
                        v80 = (((_WORD)v12 + 4) & 0xFFF) - 4096;
                        while ( 1 )
                        {
                          v32 = (v80 + 16 < 0) ^ __OFADD__(16, v80) | (v80 == -16);
                          v80 += 16;
                          if ( !v32 )
                            goto LABEL_66;
                          while ( 1 )
                          {
                            v81 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                            v82 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                            v83 = _mm_alignr_epi8(v82, v78, 4);
                            v84 = _mm_or_si128(
                                    v81,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v81, (__m128i)xmmword_80CA9D0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v81)),
                                      (__m128i)xmmword_80CA9F0));
                            v79 = _mm_cmpeq_epi8(v79, v84);
                            v20 = _mm_movemask_epi8(
                                    _mm_sub_epi8(
                                      _mm_cmpeq_epi8(
                                        v84,
                                        _mm_or_si128(
                                          v83,
                                          _mm_and_si128(
                                            _mm_and_si128(
                                              _mm_cmpgt_epi8(v83, (__m128i)xmmword_80CA9D0),
                                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v83)),
                                            (__m128i)xmmword_80CA9F0))),
                                      v79))
                                - 0xFFFF;
                            if ( v20 )
                              goto LABEL_180;
                            v9 += 16;
                            v78 = v82;
                            v32 = (v80 + 16 < 0) ^ __OFADD__(16, v80) | (v80 == -16);
                            v80 += 16;
                            if ( v32 )
                              break;
LABEL_66:
                            v89 = _mm_cmpeq_epi8(v79, v78);
                            if ( (_mm_movemask_epi8(v89) & 0xFFF0) != 0 )
                            {
                              v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                              v43 = _mm_srli_si128(v89, 4);
                              v44 = _mm_srli_si128(v78, 4);
                              goto LABEL_179;
                            }
                            v79 = 0LL;
                            v80 -= 4096;
                          }
                          v85 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                          v86 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                          v87 = _mm_alignr_epi8(v86, v78, 4);
                          v88 = _mm_or_si128(
                                  v85,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v85, (__m128i)xmmword_80CA9D0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v85)),
                                    (__m128i)xmmword_80CA9F0));
                          v79 = _mm_cmpeq_epi8(v79, v88);
                          v20 = _mm_movemask_epi8(
                                  _mm_sub_epi8(
                                    _mm_cmpeq_epi8(
                                      v88,
                                      _mm_or_si128(
                                        v87,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v87, (__m128i)xmmword_80CA9D0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v87)),
                                          (__m128i)xmmword_80CA9F0))),
                                    v79))
                              - 0xFFFF;
                          if ( v20 )
                            goto LABEL_180;
                          v9 += 16;
                          v78 = v86;
                        }
                      }
                      v90 = _mm_load_si128(v11);
                      v91 = _mm_slli_si128(_mm_load_si128(v12), 11);
                      v92 = (unsigned int)_mm_movemask_epi8(
                                            _mm_sub_epi8(
                                              _mm_cmpeq_epi8(
                                                _mm_or_si128(
                                                  v91,
                                                  _mm_and_si128(
                                                    _mm_and_si128(
                                                      _mm_cmpgt_epi8(v91, (__m128i)xmmword_80CA9D0),
                                                      _mm_cmpgt_epi8(
                                                        _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                        v91)),
                                                    (__m128i)xmmword_80CA9F0)),
                                                _mm_or_si128(
                                                  v90,
                                                  _mm_and_si128(
                                                    _mm_and_si128(
                                                      _mm_cmpgt_epi8(v90, (__m128i)xmmword_80CA9D0),
                                                      _mm_cmpgt_epi8(
                                                        _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                        v90)),
                                                    (__m128i)xmmword_80CA9F0))),
                                              _mm_cmpeq_epi8((__m128i)0LL, v90))) >> v9;
                      v20 = (0xFFFFu >> v9) - v92;
                      v16 = 0xFFFFu >> v9 == v92;
                      v21 = v9 - 11;
                      if ( !v16 )
                        goto LABEL_181;
                      v93 = _mm_load_si128(v12);
                      v94 = 0LL;
                      v9 = 16;
                      v257 |= 5u;
                      v95 = (((_WORD)v12 + 5) & 0xFFF) - 4096;
                      while ( 1 )
                      {
                        v32 = (v95 + 16 < 0) ^ __OFADD__(16, v95) | (v95 == -16);
                        v95 += 16;
                        if ( !v32 )
                          goto LABEL_76;
                        while ( 1 )
                        {
                          v96 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                          v97 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                          v98 = _mm_alignr_epi8(v97, v93, 5);
                          v99 = _mm_or_si128(
                                  v96,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v96, (__m128i)xmmword_80CA9D0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v96)),
                                    (__m128i)xmmword_80CA9F0));
                          v94 = _mm_cmpeq_epi8(v94, v99);
                          v20 = _mm_movemask_epi8(
                                  _mm_sub_epi8(
                                    _mm_cmpeq_epi8(
                                      v99,
                                      _mm_or_si128(
                                        v98,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v98, (__m128i)xmmword_80CA9D0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v98)),
                                          (__m128i)xmmword_80CA9F0))),
                                    v94))
                              - 0xFFFF;
                          if ( v20 )
                            goto LABEL_180;
                          v9 += 16;
                          v93 = v97;
                          v32 = (v95 + 16 < 0) ^ __OFADD__(16, v95) | (v95 == -16);
                          v95 += 16;
                          if ( v32 )
                            break;
LABEL_76:
                          v104 = _mm_cmpeq_epi8(v94, v93);
                          if ( (_mm_movemask_epi8(v104) & 0xFFE0) != 0 )
                          {
                            v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                            v43 = _mm_srli_si128(v104, 5);
                            v44 = _mm_srli_si128(v93, 5);
                            goto LABEL_179;
                          }
                          v94 = 0LL;
                          v95 -= 4096;
                        }
                        v100 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                        v101 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                        v102 = _mm_alignr_epi8(v101, v93, 5);
                        v103 = _mm_or_si128(
                                 v100,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v100, (__m128i)xmmword_80CA9D0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v100)),
                                   (__m128i)xmmword_80CA9F0));
                        v94 = _mm_cmpeq_epi8(v94, v103);
                        v20 = _mm_movemask_epi8(
                                _mm_sub_epi8(
                                  _mm_cmpeq_epi8(
                                    v103,
                                    _mm_or_si128(
                                      v102,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v102, (__m128i)xmmword_80CA9D0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v102)),
                                        (__m128i)xmmword_80CA9F0))),
                                  v94))
                            - 0xFFFF;
                        if ( v20 )
                          goto LABEL_180;
                        v9 += 16;
                        v93 = v101;
                      }
                    }
                    v105 = _mm_load_si128(v11);
                    v106 = _mm_slli_si128(_mm_load_si128(v12), 10);
                    v107 = (unsigned int)_mm_movemask_epi8(
                                           _mm_sub_epi8(
                                             _mm_cmpeq_epi8(
                                               _mm_or_si128(
                                                 v106,
                                                 _mm_and_si128(
                                                   _mm_and_si128(
                                                     _mm_cmpgt_epi8(v106, (__m128i)xmmword_80CA9D0),
                                                     _mm_cmpgt_epi8(
                                                       _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                       v106)),
                                                   (__m128i)xmmword_80CA9F0)),
                                               _mm_or_si128(
                                                 v105,
                                                 _mm_and_si128(
                                                   _mm_and_si128(
                                                     _mm_cmpgt_epi8(v105, (__m128i)xmmword_80CA9D0),
                                                     _mm_cmpgt_epi8(
                                                       _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                       v105)),
                                                   (__m128i)xmmword_80CA9F0))),
                                             _mm_cmpeq_epi8((__m128i)0LL, v105))) >> v9;
                    v20 = (0xFFFFu >> v9) - v107;
                    v16 = 0xFFFFu >> v9 == v107;
                    v21 = v9 - 10;
                    if ( !v16 )
                      goto LABEL_181;
                    v108 = _mm_load_si128(v12);
                    v109 = 0LL;
                    v9 = 16;
                    v257 |= 6u;
                    v110 = (((_WORD)v12 + 6) & 0xFFF) - 4096;
                    while ( 1 )
                    {
                      v32 = (v110 + 16 < 0) ^ __OFADD__(16, v110) | (v110 == -16);
                      v110 += 16;
                      if ( !v32 )
                        goto LABEL_86;
                      while ( 1 )
                      {
                        v111 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                        v112 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                        v113 = _mm_alignr_epi8(v112, v108, 6);
                        v114 = _mm_or_si128(
                                 v111,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v111, (__m128i)xmmword_80CA9D0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v111)),
                                   (__m128i)xmmword_80CA9F0));
                        v109 = _mm_cmpeq_epi8(v109, v114);
                        v20 = _mm_movemask_epi8(
                                _mm_sub_epi8(
                                  _mm_cmpeq_epi8(
                                    v114,
                                    _mm_or_si128(
                                      v113,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v113, (__m128i)xmmword_80CA9D0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v113)),
                                        (__m128i)xmmword_80CA9F0))),
                                  v109))
                            - 0xFFFF;
                        if ( v20 )
                          goto LABEL_180;
                        v9 += 16;
                        v108 = v112;
                        v32 = (v110 + 16 < 0) ^ __OFADD__(16, v110) | (v110 == -16);
                        v110 += 16;
                        if ( v32 )
                          break;
LABEL_86:
                        v119 = _mm_cmpeq_epi8(v109, v108);
                        if ( (_mm_movemask_epi8(v119) & 0xFFC0) != 0 )
                        {
                          v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                          v43 = _mm_srli_si128(v119, 6);
                          v44 = _mm_srli_si128(v108, 6);
                          goto LABEL_179;
                        }
                        v109 = 0LL;
                        v110 -= 4096;
                      }
                      v115 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                      v116 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                      v117 = _mm_alignr_epi8(v116, v108, 6);
                      v118 = _mm_or_si128(
                               v115,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v115, (__m128i)xmmword_80CA9D0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v115)),
                                 (__m128i)xmmword_80CA9F0));
                      v109 = _mm_cmpeq_epi8(v109, v118);
                      v20 = _mm_movemask_epi8(
                              _mm_sub_epi8(
                                _mm_cmpeq_epi8(
                                  v118,
                                  _mm_or_si128(
                                    v117,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v117, (__m128i)xmmword_80CA9D0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v117)),
                                      (__m128i)xmmword_80CA9F0))),
                                v109))
                          - 0xFFFF;
                      if ( v20 )
                        goto LABEL_180;
                      v9 += 16;
                      v108 = v116;
                    }
                  }
                  v120 = _mm_load_si128(v11);
                  v121 = _mm_slli_si128(_mm_load_si128(v12), 9);
                  v122 = (unsigned int)_mm_movemask_epi8(
                                         _mm_sub_epi8(
                                           _mm_cmpeq_epi8(
                                             _mm_or_si128(
                                               v121,
                                               _mm_and_si128(
                                                 _mm_and_si128(
                                                   _mm_cmpgt_epi8(v121, (__m128i)xmmword_80CA9D0),
                                                   _mm_cmpgt_epi8(
                                                     _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                     v121)),
                                                 (__m128i)xmmword_80CA9F0)),
                                             _mm_or_si128(
                                               v120,
                                               _mm_and_si128(
                                                 _mm_and_si128(
                                                   _mm_cmpgt_epi8(v120, (__m128i)xmmword_80CA9D0),
                                                   _mm_cmpgt_epi8(
                                                     _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                     v120)),
                                                 (__m128i)xmmword_80CA9F0))),
                                           _mm_cmpeq_epi8((__m128i)0LL, v120))) >> v9;
                  v20 = (0xFFFFu >> v9) - v122;
                  v16 = 0xFFFFu >> v9 == v122;
                  v21 = v9 - 9;
                  if ( !v16 )
                    goto LABEL_181;
                  v123 = _mm_load_si128(v12);
                  v124 = 0LL;
                  v9 = 16;
                  v257 |= 7u;
                  v125 = (((_WORD)v12 + 8) & 0xFFF) - 4096;
                  while ( 1 )
                  {
                    v32 = (v125 + 16 < 0) ^ __OFADD__(16, v125) | (v125 == -16);
                    v125 += 16;
                    if ( !v32 )
                      goto LABEL_96;
                    while ( 1 )
                    {
                      v126 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                      v127 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                      v128 = _mm_alignr_epi8(v127, v123, 7);
                      v129 = _mm_or_si128(
                               v126,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v126, (__m128i)xmmword_80CA9D0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v126)),
                                 (__m128i)xmmword_80CA9F0));
                      v124 = _mm_cmpeq_epi8(v124, v129);
                      v20 = _mm_movemask_epi8(
                              _mm_sub_epi8(
                                _mm_cmpeq_epi8(
                                  v129,
                                  _mm_or_si128(
                                    v128,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v128, (__m128i)xmmword_80CA9D0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v128)),
                                      (__m128i)xmmword_80CA9F0))),
                                v124))
                          - 0xFFFF;
                      if ( v20 )
                        goto LABEL_180;
                      v9 += 16;
                      v123 = v127;
                      v32 = (v125 + 16 < 0) ^ __OFADD__(16, v125) | (v125 == -16);
                      v125 += 16;
                      if ( v32 )
                        break;
LABEL_96:
                      v134 = _mm_cmpeq_epi8(v124, v123);
                      if ( (_mm_movemask_epi8(v134) & 0xFF80) != 0 )
                      {
                        v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                        v43 = _mm_srli_si128(v134, 7);
                        v44 = _mm_srli_si128(v123, 7);
                        goto LABEL_179;
                      }
                      v124 = 0LL;
                      v125 -= 4096;
                    }
                    v130 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                    v131 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                    v132 = _mm_alignr_epi8(v131, v123, 7);
                    v133 = _mm_or_si128(
                             v130,
                             _mm_and_si128(
                               _mm_and_si128(
                                 _mm_cmpgt_epi8(v130, (__m128i)xmmword_80CA9D0),
                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v130)),
                               (__m128i)xmmword_80CA9F0));
                    v124 = _mm_cmpeq_epi8(v124, v133);
                    v20 = _mm_movemask_epi8(
                            _mm_sub_epi8(
                              _mm_cmpeq_epi8(
                                v133,
                                _mm_or_si128(
                                  v132,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v132, (__m128i)xmmword_80CA9D0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v132)),
                                    (__m128i)xmmword_80CA9F0))),
                              v124))
                        - 0xFFFF;
                    if ( v20 )
                      goto LABEL_180;
                    v9 += 16;
                    v123 = v131;
                  }
                }
                v135 = _mm_load_si128(v11);
                v136 = _mm_slli_si128(_mm_load_si128(v12), 8);
                v137 = (unsigned int)_mm_movemask_epi8(
                                       _mm_sub_epi8(
                                         _mm_cmpeq_epi8(
                                           _mm_or_si128(
                                             v136,
                                             _mm_and_si128(
                                               _mm_and_si128(
                                                 _mm_cmpgt_epi8(v136, (__m128i)xmmword_80CA9D0),
                                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v136)),
                                               (__m128i)xmmword_80CA9F0)),
                                           _mm_or_si128(
                                             v135,
                                             _mm_and_si128(
                                               _mm_and_si128(
                                                 _mm_cmpgt_epi8(v135, (__m128i)xmmword_80CA9D0),
                                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v135)),
                                               (__m128i)xmmword_80CA9F0))),
                                         _mm_cmpeq_epi8((__m128i)0LL, v135))) >> v9;
                v20 = (0xFFFFu >> v9) - v137;
                v16 = 0xFFFFu >> v9 == v137;
                v21 = v9 - 8;
                if ( !v16 )
                  goto LABEL_181;
                v138 = _mm_load_si128(v12);
                v139 = 0LL;
                v9 = 16;
                v257 |= 8u;
                v140 = (((_WORD)v12 + 8) & 0xFFF) - 4096;
                while ( 1 )
                {
                  v32 = (v140 + 16 < 0) ^ __OFADD__(16, v140) | (v140 == -16);
                  v140 += 16;
                  if ( !v32 )
                    goto LABEL_106;
                  while ( 1 )
                  {
                    v141 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                    v142 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                    v143 = _mm_alignr_epi8(v142, v138, 8);
                    v144 = _mm_or_si128(
                             v141,
                             _mm_and_si128(
                               _mm_and_si128(
                                 _mm_cmpgt_epi8(v141, (__m128i)xmmword_80CA9D0),
                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v141)),
                               (__m128i)xmmword_80CA9F0));
                    v139 = _mm_cmpeq_epi8(v139, v144);
                    v20 = _mm_movemask_epi8(
                            _mm_sub_epi8(
                              _mm_cmpeq_epi8(
                                v144,
                                _mm_or_si128(
                                  v143,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v143, (__m128i)xmmword_80CA9D0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v143)),
                                    (__m128i)xmmword_80CA9F0))),
                              v139))
                        - 0xFFFF;
                    if ( v20 )
                      goto LABEL_180;
                    v9 += 16;
                    v138 = v142;
                    v32 = (v140 + 16 < 0) ^ __OFADD__(16, v140) | (v140 == -16);
                    v140 += 16;
                    if ( v32 )
                      break;
LABEL_106:
                    v149 = _mm_cmpeq_epi8(v139, v138);
                    if ( (_mm_movemask_epi8(v149) & 0xFF00) != 0 )
                    {
                      v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                      v43 = _mm_srli_si128(v149, 8);
                      v44 = _mm_srli_si128(v138, 8);
                      goto LABEL_179;
                    }
                    v139 = 0LL;
                    v140 -= 4096;
                  }
                  v145 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                  v146 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                  v147 = _mm_alignr_epi8(v146, v138, 8);
                  v148 = _mm_or_si128(
                           v145,
                           _mm_and_si128(
                             _mm_and_si128(
                               _mm_cmpgt_epi8(v145, (__m128i)xmmword_80CA9D0),
                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v145)),
                             (__m128i)xmmword_80CA9F0));
                  v139 = _mm_cmpeq_epi8(v139, v148);
                  v20 = _mm_movemask_epi8(
                          _mm_sub_epi8(
                            _mm_cmpeq_epi8(
                              v148,
                              _mm_or_si128(
                                v147,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(v147, (__m128i)xmmword_80CA9D0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v147)),
                                  (__m128i)xmmword_80CA9F0))),
                            v139))
                      - 0xFFFF;
                  if ( v20 )
                    goto LABEL_180;
                  v9 += 16;
                  v138 = v146;
                }
              }
              v150 = _mm_load_si128(v11);
              v151 = _mm_slli_si128(_mm_load_si128(v12), 7);
              v152 = (unsigned int)_mm_movemask_epi8(
                                     _mm_sub_epi8(
                                       _mm_cmpeq_epi8(
                                         _mm_or_si128(
                                           v151,
                                           _mm_and_si128(
                                             _mm_and_si128(
                                               _mm_cmpgt_epi8(v151, (__m128i)xmmword_80CA9D0),
                                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v151)),
                                             (__m128i)xmmword_80CA9F0)),
                                         _mm_or_si128(
                                           v150,
                                           _mm_and_si128(
                                             _mm_and_si128(
                                               _mm_cmpgt_epi8(v150, (__m128i)xmmword_80CA9D0),
                                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v150)),
                                             (__m128i)xmmword_80CA9F0))),
                                       _mm_cmpeq_epi8((__m128i)0LL, v150))) >> v9;
              v20 = (0xFFFFu >> v9) - v152;
              v16 = 0xFFFFu >> v9 == v152;
              v21 = v9 - 7;
              if ( !v16 )
                goto LABEL_181;
              v153 = _mm_load_si128(v12);
              v154 = 0LL;
              v9 = 16;
              v257 |= 9u;
              v155 = (((_WORD)v12 + 9) & 0xFFF) - 4096;
              while ( 1 )
              {
                v32 = (v155 + 16 < 0) ^ __OFADD__(16, v155) | (v155 == -16);
                v155 += 16;
                if ( !v32 )
                  goto LABEL_116;
                while ( 1 )
                {
                  v156 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                  v157 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                  v158 = _mm_alignr_epi8(v157, v153, 9);
                  v159 = _mm_or_si128(
                           v156,
                           _mm_and_si128(
                             _mm_and_si128(
                               _mm_cmpgt_epi8(v156, (__m128i)xmmword_80CA9D0),
                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v156)),
                             (__m128i)xmmword_80CA9F0));
                  v154 = _mm_cmpeq_epi8(v154, v159);
                  v20 = _mm_movemask_epi8(
                          _mm_sub_epi8(
                            _mm_cmpeq_epi8(
                              v159,
                              _mm_or_si128(
                                v158,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(v158, (__m128i)xmmword_80CA9D0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v158)),
                                  (__m128i)xmmword_80CA9F0))),
                            v154))
                      - 0xFFFF;
                  if ( v20 )
                    goto LABEL_180;
                  v9 += 16;
                  v153 = v157;
                  v32 = (v155 + 16 < 0) ^ __OFADD__(16, v155) | (v155 == -16);
                  v155 += 16;
                  if ( v32 )
                    break;
LABEL_116:
                  v164 = _mm_cmpeq_epi8(v154, v153);
                  if ( (_mm_movemask_epi8(v164) & 0xFE00) != 0 )
                  {
                    v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                    v43 = _mm_srli_si128(v164, 9);
                    v44 = _mm_srli_si128(v153, 9);
                    goto LABEL_179;
                  }
                  v154 = 0LL;
                  v155 -= 4096;
                }
                v160 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                v161 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                v162 = _mm_alignr_epi8(v161, v153, 9);
                v163 = _mm_or_si128(
                         v160,
                         _mm_and_si128(
                           _mm_and_si128(
                             _mm_cmpgt_epi8(v160, (__m128i)xmmword_80CA9D0),
                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v160)),
                           (__m128i)xmmword_80CA9F0));
                v154 = _mm_cmpeq_epi8(v154, v163);
                v20 = _mm_movemask_epi8(
                        _mm_sub_epi8(
                          _mm_cmpeq_epi8(
                            v163,
                            _mm_or_si128(
                              v162,
                              _mm_and_si128(
                                _mm_and_si128(
                                  _mm_cmpgt_epi8(v162, (__m128i)xmmword_80CA9D0),
                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v162)),
                                (__m128i)xmmword_80CA9F0))),
                          v154))
                    - 0xFFFF;
                if ( v20 )
                  goto LABEL_180;
                v9 += 16;
                v153 = v161;
              }
            }
            v165 = _mm_load_si128(v11);
            v166 = _mm_slli_si128(_mm_load_si128(v12), 6);
            v167 = (unsigned int)_mm_movemask_epi8(
                                   _mm_sub_epi8(
                                     _mm_cmpeq_epi8(
                                       _mm_or_si128(
                                         v166,
                                         _mm_and_si128(
                                           _mm_and_si128(
                                             _mm_cmpgt_epi8(v166, (__m128i)xmmword_80CA9D0),
                                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v166)),
                                           (__m128i)xmmword_80CA9F0)),
                                       _mm_or_si128(
                                         v165,
                                         _mm_and_si128(
                                           _mm_and_si128(
                                             _mm_cmpgt_epi8(v165, (__m128i)xmmword_80CA9D0),
                                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v165)),
                                           (__m128i)xmmword_80CA9F0))),
                                     _mm_cmpeq_epi8((__m128i)0LL, v165))) >> v9;
            v20 = (0xFFFFu >> v9) - v167;
            v16 = 0xFFFFu >> v9 == v167;
            v21 = v9 - 6;
            if ( !v16 )
              goto LABEL_181;
            v168 = _mm_load_si128(v12);
            v169 = 0LL;
            v9 = 16;
            v257 |= 0xAu;
            v170 = (((_WORD)v12 + 10) & 0xFFF) - 4096;
            while ( 1 )
            {
              v32 = (v170 + 16 < 0) ^ __OFADD__(16, v170) | (v170 == -16);
              v170 += 16;
              if ( !v32 )
                goto LABEL_126;
              while ( 1 )
              {
                v171 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                v172 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
                v173 = _mm_alignr_epi8(v172, v168, 10);
                v174 = _mm_or_si128(
                         v171,
                         _mm_and_si128(
                           _mm_and_si128(
                             _mm_cmpgt_epi8(v171, (__m128i)xmmword_80CA9D0),
                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v171)),
                           (__m128i)xmmword_80CA9F0));
                v169 = _mm_cmpeq_epi8(v169, v174);
                v20 = _mm_movemask_epi8(
                        _mm_sub_epi8(
                          _mm_cmpeq_epi8(
                            v174,
                            _mm_or_si128(
                              v173,
                              _mm_and_si128(
                                _mm_and_si128(
                                  _mm_cmpgt_epi8(v173, (__m128i)xmmword_80CA9D0),
                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v173)),
                                (__m128i)xmmword_80CA9F0))),
                          v169))
                    - 0xFFFF;
                if ( v20 )
                  goto LABEL_180;
                v9 += 16;
                v168 = v172;
                v32 = (v170 + 16 < 0) ^ __OFADD__(16, v170) | (v170 == -16);
                v170 += 16;
                if ( v32 )
                  break;
LABEL_126:
                v179 = _mm_cmpeq_epi8(v169, v168);
                if ( (_mm_movemask_epi8(v179) & 0xFC00) != 0 )
                {
                  v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                  v43 = _mm_srli_si128(v179, 10);
                  v44 = _mm_srli_si128(v168, 10);
                  goto LABEL_179;
                }
                v169 = 0LL;
                v170 -= 4096;
              }
              v175 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
              v176 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
              v177 = _mm_alignr_epi8(v176, v168, 10);
              v178 = _mm_or_si128(
                       v175,
                       _mm_and_si128(
                         _mm_and_si128(
                           _mm_cmpgt_epi8(v175, (__m128i)xmmword_80CA9D0),
                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v175)),
                         (__m128i)xmmword_80CA9F0));
              v169 = _mm_cmpeq_epi8(v169, v178);
              v20 = _mm_movemask_epi8(
                      _mm_sub_epi8(
                        _mm_cmpeq_epi8(
                          v178,
                          _mm_or_si128(
                            v177,
                            _mm_and_si128(
                              _mm_and_si128(
                                _mm_cmpgt_epi8(v177, (__m128i)xmmword_80CA9D0),
                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v177)),
                              (__m128i)xmmword_80CA9F0))),
                        v169))
                  - 0xFFFF;
              if ( v20 )
                goto LABEL_180;
              v9 += 16;
              v168 = v176;
            }
          }
          v180 = _mm_load_si128(v11);
          v181 = _mm_slli_si128(_mm_load_si128(v12), 5);
          v182 = (unsigned int)_mm_movemask_epi8(
                                 _mm_sub_epi8(
                                   _mm_cmpeq_epi8(
                                     _mm_or_si128(
                                       v181,
                                       _mm_and_si128(
                                         _mm_and_si128(
                                           _mm_cmpgt_epi8(v181, (__m128i)xmmword_80CA9D0),
                                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v181)),
                                         (__m128i)xmmword_80CA9F0)),
                                     _mm_or_si128(
                                       v180,
                                       _mm_and_si128(
                                         _mm_and_si128(
                                           _mm_cmpgt_epi8(v180, (__m128i)xmmword_80CA9D0),
                                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v180)),
                                         (__m128i)xmmword_80CA9F0))),
                                   _mm_cmpeq_epi8((__m128i)0LL, v180))) >> v9;
          v20 = (0xFFFFu >> v9) - v182;
          v16 = 0xFFFFu >> v9 == v182;
          v21 = v9 - 5;
          if ( !v16 )
            goto LABEL_181;
          v183 = _mm_load_si128(v12);
          v184 = 0LL;
          v9 = 16;
          v257 |= 0xBu;
          v185 = (((_WORD)v12 + 11) & 0xFFF) - 4096;
          while ( 1 )
          {
            v32 = (v185 + 16 < 0) ^ __OFADD__(16, v185) | (v185 == -16);
            v185 += 16;
            if ( !v32 )
              goto LABEL_136;
            while ( 1 )
            {
              v186 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
              v187 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
              v188 = _mm_alignr_epi8(v187, v183, 11);
              v189 = _mm_or_si128(
                       v186,
                       _mm_and_si128(
                         _mm_and_si128(
                           _mm_cmpgt_epi8(v186, (__m128i)xmmword_80CA9D0),
                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v186)),
                         (__m128i)xmmword_80CA9F0));
              v184 = _mm_cmpeq_epi8(v184, v189);
              v20 = _mm_movemask_epi8(
                      _mm_sub_epi8(
                        _mm_cmpeq_epi8(
                          v189,
                          _mm_or_si128(
                            v188,
                            _mm_and_si128(
                              _mm_and_si128(
                                _mm_cmpgt_epi8(v188, (__m128i)xmmword_80CA9D0),
                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v188)),
                              (__m128i)xmmword_80CA9F0))),
                        v184))
                  - 0xFFFF;
              if ( v20 )
                goto LABEL_180;
              v9 += 16;
              v183 = v187;
              v32 = (v185 + 16 < 0) ^ __OFADD__(16, v185) | (v185 == -16);
              v185 += 16;
              if ( v32 )
                break;
LABEL_136:
              v194 = _mm_cmpeq_epi8(v184, v183);
              if ( (_mm_movemask_epi8(v194) & 0xF800) != 0 )
              {
                v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
                v43 = _mm_srli_si128(v194, 11);
                v44 = _mm_srli_si128(v183, 11);
                goto LABEL_179;
              }
              v184 = 0LL;
              v185 -= 4096;
            }
            v190 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
            v191 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
            v192 = _mm_alignr_epi8(v191, v183, 11);
            v193 = _mm_or_si128(
                     v190,
                     _mm_and_si128(
                       _mm_and_si128(
                         _mm_cmpgt_epi8(v190, (__m128i)xmmword_80CA9D0),
                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v190)),
                       (__m128i)xmmword_80CA9F0));
            v184 = _mm_cmpeq_epi8(v184, v193);
            v20 = _mm_movemask_epi8(
                    _mm_sub_epi8(
                      _mm_cmpeq_epi8(
                        v193,
                        _mm_or_si128(
                          v192,
                          _mm_and_si128(
                            _mm_and_si128(
                              _mm_cmpgt_epi8(v192, (__m128i)xmmword_80CA9D0),
                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v192)),
                            (__m128i)xmmword_80CA9F0))),
                      v184))
                - 0xFFFF;
            if ( v20 )
              goto LABEL_180;
            v9 += 16;
            v183 = v191;
          }
        }
        v195 = _mm_load_si128(v11);
        v196 = _mm_slli_si128(_mm_load_si128(v12), 4);
        v197 = (unsigned int)_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(
                                   _mm_or_si128(
                                     v196,
                                     _mm_and_si128(
                                       _mm_and_si128(
                                         _mm_cmpgt_epi8(v196, (__m128i)xmmword_80CA9D0),
                                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v196)),
                                       (__m128i)xmmword_80CA9F0)),
                                   _mm_or_si128(
                                     v195,
                                     _mm_and_si128(
                                       _mm_and_si128(
                                         _mm_cmpgt_epi8(v195, (__m128i)xmmword_80CA9D0),
                                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v195)),
                                       (__m128i)xmmword_80CA9F0))),
                                 _mm_cmpeq_epi8((__m128i)0LL, v195))) >> v9;
        v20 = (0xFFFFu >> v9) - v197;
        v16 = 0xFFFFu >> v9 == v197;
        v21 = v9 - 4;
        if ( !v16 )
          goto LABEL_181;
        v198 = _mm_load_si128(v12);
        v199 = 0LL;
        v9 = 16;
        v257 |= 0xCu;
        v200 = (((_WORD)v12 + 12) & 0xFFF) - 4096;
        while ( 1 )
        {
          v32 = (v200 + 16 < 0) ^ __OFADD__(16, v200) | (v200 == -16);
          v200 += 16;
          if ( !v32 )
            goto LABEL_146;
          while ( 1 )
          {
            v201 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
            v202 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
            v203 = _mm_alignr_epi8(v202, v198, 12);
            v204 = _mm_or_si128(
                     v201,
                     _mm_and_si128(
                       _mm_and_si128(
                         _mm_cmpgt_epi8(v201, (__m128i)xmmword_80CA9D0),
                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v201)),
                       (__m128i)xmmword_80CA9F0));
            v199 = _mm_cmpeq_epi8(v199, v204);
            v20 = _mm_movemask_epi8(
                    _mm_sub_epi8(
                      _mm_cmpeq_epi8(
                        v204,
                        _mm_or_si128(
                          v203,
                          _mm_and_si128(
                            _mm_and_si128(
                              _mm_cmpgt_epi8(v203, (__m128i)xmmword_80CA9D0),
                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v203)),
                            (__m128i)xmmword_80CA9F0))),
                      v199))
                - 0xFFFF;
            if ( v20 )
              goto LABEL_180;
            v9 += 16;
            v198 = v202;
            v32 = (v200 + 16 < 0) ^ __OFADD__(16, v200) | (v200 == -16);
            v200 += 16;
            if ( v32 )
              break;
LABEL_146:
            v209 = _mm_cmpeq_epi8(v199, v198);
            if ( (_mm_movemask_epi8(v209) & 0xF000) != 0 )
            {
              v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
              v43 = _mm_srli_si128(v209, 12);
              v44 = _mm_srli_si128(v198, 12);
              goto LABEL_179;
            }
            v199 = 0LL;
            v200 -= 4096;
          }
          v205 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
          v206 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
          v207 = _mm_alignr_epi8(v206, v198, 12);
          v208 = _mm_or_si128(
                   v205,
                   _mm_and_si128(
                     _mm_and_si128(
                       _mm_cmpgt_epi8(v205, (__m128i)xmmword_80CA9D0),
                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v205)),
                     (__m128i)xmmword_80CA9F0));
          v199 = _mm_cmpeq_epi8(v199, v208);
          v20 = _mm_movemask_epi8(
                  _mm_sub_epi8(
                    _mm_cmpeq_epi8(
                      v208,
                      _mm_or_si128(
                        v207,
                        _mm_and_si128(
                          _mm_and_si128(
                            _mm_cmpgt_epi8(v207, (__m128i)xmmword_80CA9D0),
                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v207)),
                          (__m128i)xmmword_80CA9F0))),
                    v199))
              - 0xFFFF;
          if ( v20 )
            goto LABEL_180;
          v9 += 16;
          v198 = v206;
        }
      }
      v210 = _mm_load_si128(v11);
      v211 = _mm_slli_si128(_mm_load_si128(v12), 3);
      v212 = (unsigned int)_mm_movemask_epi8(
                             _mm_sub_epi8(
                               _mm_cmpeq_epi8(
                                 _mm_or_si128(
                                   v211,
                                   _mm_and_si128(
                                     _mm_and_si128(
                                       _mm_cmpgt_epi8(v211, (__m128i)xmmword_80CA9D0),
                                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v211)),
                                     (__m128i)xmmword_80CA9F0)),
                                 _mm_or_si128(
                                   v210,
                                   _mm_and_si128(
                                     _mm_and_si128(
                                       _mm_cmpgt_epi8(v210, (__m128i)xmmword_80CA9D0),
                                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v210)),
                                     (__m128i)xmmword_80CA9F0))),
                               _mm_cmpeq_epi8((__m128i)0LL, v210))) >> v9;
      v20 = (0xFFFFu >> v9) - v212;
      v16 = 0xFFFFu >> v9 == v212;
      v21 = v9 - 3;
      if ( !v16 )
        goto LABEL_181;
      v213 = _mm_load_si128(v12);
      v214 = 0LL;
      v9 = 16;
      v257 |= 0xDu;
      v215 = (((_WORD)v12 + 13) & 0xFFF) - 4096;
      while ( 1 )
      {
        v32 = (v215 + 16 < 0) ^ __OFADD__(16, v215) | (v215 == -16);
        v215 += 16;
        if ( !v32 )
          goto LABEL_156;
        while ( 1 )
        {
          v216 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
          v217 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
          v218 = _mm_alignr_epi8(v217, v213, 13);
          v219 = _mm_or_si128(
                   v216,
                   _mm_and_si128(
                     _mm_and_si128(
                       _mm_cmpgt_epi8(v216, (__m128i)xmmword_80CA9D0),
                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v216)),
                     (__m128i)xmmword_80CA9F0));
          v214 = _mm_cmpeq_epi8(v214, v219);
          v20 = _mm_movemask_epi8(
                  _mm_sub_epi8(
                    _mm_cmpeq_epi8(
                      v219,
                      _mm_or_si128(
                        v218,
                        _mm_and_si128(
                          _mm_and_si128(
                            _mm_cmpgt_epi8(v218, (__m128i)xmmword_80CA9D0),
                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v218)),
                          (__m128i)xmmword_80CA9F0))),
                    v214))
              - 0xFFFF;
          if ( v20 )
            goto LABEL_180;
          v9 += 16;
          v213 = v217;
          v32 = (v215 + 16 < 0) ^ __OFADD__(16, v215) | (v215 == -16);
          v215 += 16;
          if ( v32 )
            break;
LABEL_156:
          v224 = _mm_cmpeq_epi8(v214, v213);
          if ( (_mm_movemask_epi8(v224) & 0xE000) != 0 )
          {
            v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
            v43 = _mm_srli_si128(v224, 13);
            v44 = _mm_srli_si128(v213, 13);
            goto LABEL_179;
          }
          v214 = 0LL;
          v215 -= 4096;
        }
        v220 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
        v221 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
        v222 = _mm_alignr_epi8(v221, v213, 13);
        v223 = _mm_or_si128(
                 v220,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v220, (__m128i)xmmword_80CA9D0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v220)),
                   (__m128i)xmmword_80CA9F0));
        v214 = _mm_cmpeq_epi8(v214, v223);
        v20 = _mm_movemask_epi8(
                _mm_sub_epi8(
                  _mm_cmpeq_epi8(
                    v223,
                    _mm_or_si128(
                      v222,
                      _mm_and_si128(
                        _mm_and_si128(
                          _mm_cmpgt_epi8(v222, (__m128i)xmmword_80CA9D0),
                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v222)),
                        (__m128i)xmmword_80CA9F0))),
                  v214))
            - 0xFFFF;
        if ( v20 )
          goto LABEL_180;
        v9 += 16;
        v213 = v221;
      }
    }
    v225 = _mm_load_si128(v11);
    v226 = _mm_slli_si128(_mm_load_si128(v12), 2);
    v227 = (unsigned int)_mm_movemask_epi8(
                           _mm_sub_epi8(
                             _mm_cmpeq_epi8(
                               _mm_or_si128(
                                 v226,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v226, (__m128i)xmmword_80CA9D0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v226)),
                                   (__m128i)xmmword_80CA9F0)),
                               _mm_or_si128(
                                 v225,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v225, (__m128i)xmmword_80CA9D0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v225)),
                                   (__m128i)xmmword_80CA9F0))),
                             _mm_cmpeq_epi8((__m128i)0LL, v225))) >> v9;
    v20 = (0xFFFFu >> v9) - v227;
    v16 = 0xFFFFu >> v9 == v227;
    v21 = v9 - 2;
    if ( !v16 )
      goto LABEL_181;
    v228 = _mm_load_si128(v12);
    v229 = 0LL;
    v9 = 16;
    v257 |= 0xEu;
    v230 = (((_WORD)v12 + 14) & 0xFFF) - 4096;
    while ( 1 )
    {
      v32 = (v230 + 16 < 0) ^ __OFADD__(16, v230) | (v230 == -16);
      v230 += 16;
      if ( !v32 )
        goto LABEL_166;
      while ( 1 )
      {
        v231 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
        v232 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
        v233 = _mm_alignr_epi8(v232, v228, 14);
        v234 = _mm_or_si128(
                 v231,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v231, (__m128i)xmmword_80CA9D0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v231)),
                   (__m128i)xmmword_80CA9F0));
        v229 = _mm_cmpeq_epi8(v229, v234);
        v20 = _mm_movemask_epi8(
                _mm_sub_epi8(
                  _mm_cmpeq_epi8(
                    v234,
                    _mm_or_si128(
                      v233,
                      _mm_and_si128(
                        _mm_and_si128(
                          _mm_cmpgt_epi8(v233, (__m128i)xmmword_80CA9D0),
                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v233)),
                        (__m128i)xmmword_80CA9F0))),
                  v229))
            - 0xFFFF;
        if ( v20 )
          goto LABEL_180;
        v9 += 16;
        v228 = v232;
        v32 = (v230 + 16 < 0) ^ __OFADD__(16, v230) | (v230 == -16);
        v230 += 16;
        if ( v32 )
          break;
LABEL_166:
        v239 = _mm_cmpeq_epi8(v229, v228);
        if ( (_mm_movemask_epi8(v239) & 0xC000) != 0 )
        {
          v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
          v43 = _mm_srli_si128(v239, 14);
          v44 = _mm_srli_si128(v228, 14);
          goto LABEL_179;
        }
        v229 = 0LL;
        v230 -= 4096;
      }
      v235 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
      v236 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
      v237 = _mm_alignr_epi8(v236, v228, 14);
      v238 = _mm_or_si128(
               v235,
               _mm_and_si128(
                 _mm_and_si128(
                   _mm_cmpgt_epi8(v235, (__m128i)xmmword_80CA9D0),
                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v235)),
                 (__m128i)xmmword_80CA9F0));
      v229 = _mm_cmpeq_epi8(v229, v238);
      v20 = _mm_movemask_epi8(
              _mm_sub_epi8(
                _mm_cmpeq_epi8(
                  v238,
                  _mm_or_si128(
                    v237,
                    _mm_and_si128(
                      _mm_and_si128(
                        _mm_cmpgt_epi8(v237, (__m128i)xmmword_80CA9D0),
                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v237)),
                      (__m128i)xmmword_80CA9F0))),
                v229))
          - 0xFFFF;
      if ( v20 )
        goto LABEL_180;
      v9 += 16;
      v228 = v236;
    }
  }
  v240 = _mm_load_si128(v11);
  v241 = _mm_slli_si128(_mm_load_si128(v12), 1);
  v242 = (unsigned int)_mm_movemask_epi8(
                         _mm_sub_epi8(
                           _mm_cmpeq_epi8(
                             _mm_or_si128(
                               v241,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v241, (__m128i)xmmword_80CA9D0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v241)),
                                 (__m128i)xmmword_80CA9F0)),
                             _mm_or_si128(
                               v240,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v240, (__m128i)xmmword_80CA9D0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v240)),
                                 (__m128i)xmmword_80CA9F0))),
                           _mm_cmpeq_epi8((__m128i)0LL, v240))) >> v9;
  v20 = (0xFFFFu >> v9) - v242;
  v16 = 0xFFFFu >> v9 == v242;
  v21 = v9 - 1;
  if ( !v16 )
    goto LABEL_181;
  v243 = _mm_load_si128(v12);
  v244 = 0LL;
  v9 = 16;
  v257 |= 0xFu;
  v245 = (((_WORD)v12 + 15) & 0xFFF) - 4096;
LABEL_171:
  v32 = (v245 + 16 < 0) ^ __OFADD__(16, v245) | (v245 == -16);
  v245 += 16;
  if ( !v32 )
    goto LABEL_176;
  while ( 1 )
  {
    v246 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
    v247 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
    v248 = _mm_alignr_epi8(v247, v243, 15);
    v249 = _mm_or_si128(
             v246,
             _mm_and_si128(
               _mm_and_si128(
                 _mm_cmpgt_epi8(v246, (__m128i)xmmword_80CA9D0),
                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v246)),
               (__m128i)xmmword_80CA9F0));
    v244 = _mm_cmpeq_epi8(v244, v249);
    v20 = _mm_movemask_epi8(
            _mm_sub_epi8(
              _mm_cmpeq_epi8(
                v249,
                _mm_or_si128(
                  v248,
                  _mm_and_si128(
                    _mm_and_si128(
                      _mm_cmpgt_epi8(v248, (__m128i)xmmword_80CA9D0),
                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v248)),
                    (__m128i)xmmword_80CA9F0))),
              v244))
        - 0xFFFF;
    if ( v20 )
      goto LABEL_180;
    v9 += 16;
    v243 = v247;
    v32 = (v245 + 16 < 0) ^ __OFADD__(16, v245) | (v245 == -16);
    v245 += 16;
    if ( v32 )
    {
      v250 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
      v251 = _mm_load_si128((const __m128i *)((char *)v12 + v9));
      v252 = _mm_alignr_epi8(v251, v243, 15);
      v253 = _mm_or_si128(
               v250,
               _mm_and_si128(
                 _mm_and_si128(
                   _mm_cmpgt_epi8(v250, (__m128i)xmmword_80CA9D0),
                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v250)),
                 (__m128i)xmmword_80CA9F0));
      v244 = _mm_cmpeq_epi8(v244, v253);
      v20 = _mm_movemask_epi8(
              _mm_sub_epi8(
                _mm_cmpeq_epi8(
                  v253,
                  _mm_or_si128(
                    v252,
                    _mm_and_si128(
                      _mm_and_si128(
                        _mm_cmpgt_epi8(v252, (__m128i)xmmword_80CA9D0),
                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v252)),
                      (__m128i)xmmword_80CA9F0))),
                v244))
          - 0xFFFF;
      if ( v20 )
        goto LABEL_180;
      v9 += 16;
      v243 = v251;
      goto LABEL_171;
    }
LABEL_176:
    v254 = _mm_cmpeq_epi8(v244, v243);
    if ( (_mm_movemask_epi8(v254) & 0x8000) != 0 )
      break;
    v244 = 0LL;
    v245 -= 4096;
  }
  v42 = _mm_load_si128((const __m128i *)((char *)v11 + v9));
  v43 = _mm_srli_si128(v254, 15);
  v44 = _mm_srli_si128(v243, 15);
LABEL_179:
  v20 = ~_mm_movemask_epi8(
           _mm_sub_epi8(
             _mm_cmpeq_epi8(
               _mm_or_si128(
                 v42,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v42, (__m128i)xmmword_80CA9D0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v42)),
                   (__m128i)xmmword_80CA9F0)),
               _mm_or_si128(
                 v44,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v44, (__m128i)xmmword_80CA9D0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v44)),
                   (__m128i)xmmword_80CA9F0))),
             v43));
LABEL_180:
  v21 = (v257 & 0x1F) + v9 - 16;
LABEL_181:
  v3 = (int)v12->m128i_i32 + v21;
  v4 = (int)v11->m128i_i32 + v9;
  if ( (v257 & 0x20) != 0 )
  {
    v255 = (unsigned __int8 *)v4;
    v4 = v3;
    v3 = (int)v255;
  }
  LOWORD(v8) = v20;
LABEL_184:
  if ( (_BYTE)v8 )
  {
    if ( (v8 & 1) == 0 )
    {
      if ( (v8 & 2) == 0 )
      {
        if ( (v8 & 4) == 0 )
        {
          if ( (v8 & 8) == 0 )
          {
            if ( (v8 & 0x10) == 0 )
            {
              if ( (v8 & 0x20) == 0 )
              {
                if ( (v8 & 0x40) == 0 )
                  return dword_80CFDC0[*(unsigned __int8 *)(v3 + 7)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 7)];
                return dword_80CFDC0[*(unsigned __int8 *)(v3 + 6)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 6)];
              }
              return dword_80CFDC0[*(unsigned __int8 *)(v3 + 5)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 5)];
            }
            return dword_80CFDC0[*(unsigned __int8 *)(v3 + 4)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 4)];
          }
          return dword_80CFDC0[*(unsigned __int8 *)(v3 + 3)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 3)];
        }
        return dword_80CFDC0[*(unsigned __int8 *)(v3 + 2)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 2)];
      }
      return dword_80CFDC0[*(unsigned __int8 *)(v3 + 1)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 1)];
    }
    return dword_80CFDC0[*(unsigned __int8 *)v3] - dword_80CFDC0[*(unsigned __int8 *)v4];
  }
  v4 += 8;
  v3 += 8;
  if ( (v8 & 0x100) != 0 )
    return dword_80CFDC0[*(unsigned __int8 *)v3] - dword_80CFDC0[*(unsigned __int8 *)v4];
  if ( (v8 & 0x200) != 0 )
    return dword_80CFDC0[*(unsigned __int8 *)(v3 + 1)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 1)];
  if ( (v8 & 0x400) != 0 )
    return dword_80CFDC0[*(unsigned __int8 *)(v3 + 2)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 2)];
  if ( (v8 & 0x800) != 0 )
    return dword_80CFDC0[*(unsigned __int8 *)(v3 + 3)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 3)];
  if ( (v8 & 0x1000) != 0 )
    return dword_80CFDC0[*(unsigned __int8 *)(v3 + 4)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 4)];
  if ( (v8 & 0x2000) != 0 )
    return dword_80CFDC0[*(unsigned __int8 *)(v3 + 5)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 5)];
  if ( (v8 & 0x4000) != 0 )
    return dword_80CFDC0[*(unsigned __int8 *)(v3 + 6)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 6)];
  return dword_80CFDC0[*(unsigned __int8 *)(v3 + 7)] - dword_80CFDC0[*(unsigned __int8 *)(v4 + 7)];
}
// 80CA9D0: using guessed type __int128 xmmword_80CA9D0;
// 80CA9E0: using guessed type __int128 xmmword_80CA9E0;
// 80CA9F0: using guessed type __int128 xmmword_80CA9F0;
// 80CFDC0: using guessed type int dword_80CFDC0[256];

//----- (0807E9A0) --------------------------------------------------------
int __cdecl _strcasecmp_sse4_2(int a1, int a2)
{
  if ( (*(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFD8) + 320) & 1) == 0 )
    JUMPOUT(0x807E9D6);
  return _strcasecmp_nonascii(a1, a2);
}
// 807E9B8: control flows out of bounds to 807E9D6

//----- (0807E9C0) --------------------------------------------------------
int __cdecl _strcasecmp_l_sse4_2(int a1, int a2, int a3)
{
  unsigned __int8 *v3; // edx
  unsigned __int8 *v4; // eax
  __m128i v5; // xmm2
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm1
  int v9; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // edi
  char v12; // cc
  unsigned int v13; // ecx
  unsigned int v14; // edi
  unsigned int v15; // ecx
  unsigned int v16; // edi
  unsigned int v17; // ecx
  unsigned int v18; // edi
  unsigned int v19; // ecx
  unsigned int v20; // edi
  unsigned int v21; // ecx
  unsigned int v22; // edi
  unsigned int v23; // ecx
  unsigned int v24; // edi
  unsigned int v25; // ecx
  unsigned int v26; // edi
  unsigned __int8 *v27; // edi
  unsigned __int8 *v28; // esi
  int result; // eax
  int v30; // ecx
  int v31; // edx
  unsigned __int8 *v32; // edi
  unsigned __int8 *v33; // esi
  __m128i v34; // xmm2
  __m128i v35; // xmm1
  __m128i v36; // xmm2
  __m128i v37; // xmm1
  bool v38; // cf
  int v39; // ecx
  int v40; // ecx
  int v41; // ecx
  int v42; // ecx
  int v43; // edi
  int v44; // ecx
  unsigned int v45; // ecx
  unsigned int v46; // edi
  unsigned int v47; // ecx
  unsigned int v48; // edi
  unsigned int v49; // ecx
  unsigned int v50; // edi
  unsigned int v51; // ecx
  unsigned int v52; // edi
  unsigned int v53; // ecx
  unsigned int v54; // edi
  unsigned int v55; // ecx
  unsigned int v56; // edi
  unsigned int v57; // ecx
  unsigned int v58; // edi
  unsigned int v59; // ecx
  unsigned int v60; // edi

  if ( (*(_DWORD *)(*(_DWORD *)a3 + 320) & 1) != 0 )
    return _strcasecmp_nonascii(a1, a2);
  v3 = (unsigned __int8 *)a1;
  v4 = (unsigned __int8 *)a2;
  if ( (a1 & 0xFFFu) <= 0xFF0 )
  {
    v5 = _mm_loadu_si128((const __m128i *)a1);
    if ( (a2 & 0xFFFu) <= 0xFF0 )
    {
      v6 = _mm_loadu_si128((const __m128i *)a2);
      v7 = _mm_or_si128(
             v5,
             _mm_and_si128(
               _mm_and_si128(
                 _mm_cmpgt_epi8(v5, (__m128i)xmmword_80CA9D0),
                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v5)),
               (__m128i)xmmword_80CA9F0));
      v8 = _mm_or_si128(
             v6,
             _mm_and_si128(
               _mm_and_si128(
                 _mm_cmpgt_epi8(v6, (__m128i)xmmword_80CA9D0),
                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v6)),
               (__m128i)xmmword_80CA9F0));
      v9 = _mm_cvtsi128_si32(v7);
      if ( v9 == _mm_cvtsi128_si32(v8) )
      {
        if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(v8, v7))
          && _mm_testc_si128((__m128i)0LL, _mm_cmpeq_epi8(v7, (__m128i)0LL)) )
        {
          v3 = (unsigned __int8 *)(a1 + 16);
          v4 = (unsigned __int8 *)(a2 + 16);
          goto LABEL_8;
        }
        v38 = __CFADD__(v9, -16843009);
        v41 = v9 - 16843009;
        if ( v38 && (_mm_cvtsi128_si32(v7) ^ v41 | 0xFEFEFEFF) == -1 )
        {
          v42 = _mm_cvtsi128_si32(_mm_srli_si128(v7, 4));
          v43 = v42;
          if ( v42 != _mm_cvtsi128_si32(_mm_srli_si128(v8, 4)) )
            goto LABEL_55;
          v38 = __CFADD__(v42, -16843009);
          v44 = v42 - 16843009;
          if ( !v38 || (v43 ^ v44 | 0xFEFEFEFF) != -1 )
            goto LABEL_55;
          v3 = (unsigned __int8 *)(a1 + 8);
          v4 = (unsigned __int8 *)(a2 + 8);
        }
      }
      v45 = dword_80CFDC0[*v4];
      v46 = dword_80CFDC0[*v3];
      v12 = v46 <= v45;
      if ( v46 != v45 )
        goto LABEL_38;
      if ( !v45 )
        return 0;
      v47 = dword_80CFDC0[v4[1]];
      v48 = dword_80CFDC0[v3[1]];
      v12 = v48 <= v47;
      if ( v48 != v47 )
        goto LABEL_38;
      if ( !v47 )
        return 0;
      v49 = dword_80CFDC0[v4[2]];
      v50 = dword_80CFDC0[v3[2]];
      v12 = v50 <= v49;
      if ( v50 != v49 )
        goto LABEL_38;
      if ( !v49 )
        return 0;
      v51 = dword_80CFDC0[v4[3]];
      v52 = dword_80CFDC0[v3[3]];
      v12 = v52 <= v51;
      if ( v52 != v51 )
        goto LABEL_38;
      if ( !v51 )
        return 0;
LABEL_55:
      v53 = dword_80CFDC0[v4[4]];
      v54 = dword_80CFDC0[v3[4]];
      v12 = v54 <= v53;
      if ( v54 == v53 )
      {
        if ( !v53 )
          return 0;
        v55 = dword_80CFDC0[v4[5]];
        v56 = dword_80CFDC0[v3[5]];
        v12 = v56 <= v55;
        if ( v56 == v55 )
        {
          if ( !v55 )
            return 0;
          v57 = dword_80CFDC0[v4[6]];
          v58 = dword_80CFDC0[v3[6]];
          v12 = v58 <= v57;
          if ( v58 == v57 )
          {
            if ( !v57 )
              return 0;
            v59 = dword_80CFDC0[v4[7]];
            v60 = dword_80CFDC0[v3[7]];
            v12 = v60 <= v59;
            if ( v60 == v59 )
              return 0;
          }
        }
      }
      goto LABEL_38;
    }
  }
LABEL_8:
  v10 = dword_80CFDC0[*v4];
  v11 = dword_80CFDC0[*v3];
  v12 = v11 <= v10;
  if ( v11 != v10 )
    goto LABEL_38;
  if ( !v10 )
    return 0;
  v13 = dword_80CFDC0[v4[1]];
  v14 = dword_80CFDC0[v3[1]];
  v12 = v14 <= v13;
  if ( v14 != v13 )
    goto LABEL_38;
  if ( !v13 )
    return 0;
  v15 = dword_80CFDC0[v4[2]];
  v16 = dword_80CFDC0[v3[2]];
  v12 = v16 <= v15;
  if ( v16 != v15 )
    goto LABEL_38;
  if ( !v15 )
    return 0;
  v17 = dword_80CFDC0[v4[3]];
  v18 = dword_80CFDC0[v3[3]];
  v12 = v18 <= v17;
  if ( v18 != v17 )
    goto LABEL_38;
  if ( !v17 )
    return 0;
  v19 = dword_80CFDC0[v4[4]];
  v20 = dword_80CFDC0[v3[4]];
  v12 = v20 <= v19;
  if ( v20 != v19 )
    goto LABEL_38;
  if ( !v19 )
    return 0;
  v21 = dword_80CFDC0[v4[5]];
  v22 = dword_80CFDC0[v3[5]];
  v12 = v22 <= v21;
  if ( v22 != v21 )
    goto LABEL_38;
  if ( !v21 )
    return 0;
  v23 = dword_80CFDC0[v4[6]];
  v24 = dword_80CFDC0[v3[6]];
  v12 = v24 <= v23;
  if ( v24 != v23 )
    goto LABEL_38;
  if ( !v23 )
    return 0;
  v25 = dword_80CFDC0[v4[7]];
  v26 = dword_80CFDC0[v3[7]];
  v12 = v26 <= v25;
  if ( v26 != v25 )
  {
LABEL_38:
    result = 1;
    if ( v12 )
      return -1;
    return result;
  }
  if ( !v25 )
    return 0;
  v27 = v3 + 8;
  v28 = v4 + 8;
  result = 0;
LABEL_25:
  v30 = (unsigned __int16)v28 & 0xFFF;
  if ( v30 < ((unsigned __int16)v27 & 0xFFF) )
    v30 = (unsigned __int16)v27 & 0xFFF;
  v31 = v30 - 4080;
  v32 = &v27[-v30 + 4080];
  v33 = &v28[-v30 + 4080];
  if ( v30 - 4080 > 0 )
  {
LABEL_30:
    while ( 1 )
    {
      v40 = dword_80CFDC0[v33[v31]];
      result = dword_80CFDC0[v32[v31]] - v40;
      if ( result || !v40 )
        break;
      if ( ++v31 > 15 )
      {
        v27 = &v32[v31];
        v28 = &v33[v31];
        goto LABEL_25;
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v34 = _mm_loadu_si128((const __m128i *)&v33[v31]);
      v35 = _mm_loadu_si128((const __m128i *)&v32[v31]);
      v36 = _mm_or_si128(
              v34,
              _mm_and_si128(
                _mm_and_si128(
                  _mm_cmpgt_epi8(v34, (__m128i)xmmword_80CA9D0),
                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v34)),
                (__m128i)xmmword_80CA9F0));
      v37 = _mm_or_si128(
              v35,
              _mm_and_si128(
                _mm_and_si128(
                  _mm_cmpgt_epi8(v35, (__m128i)xmmword_80CA9D0),
                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v35)),
                (__m128i)xmmword_80CA9F0));
      v39 = _mm_cmpistri(v37, v36, 26);
      v38 = _mm_cmpistrc(v37, v36, 26);
      if ( v38 | _mm_cmpistrz(v37, v36, 26) )
        break;
      v12 = (v31 + 16 < 0) ^ __OFADD__(16, v31) | (v31 == -16);
      v31 += 16;
      if ( !v12 )
        goto LABEL_30;
    }
    if ( v38 )
      return dword_80CFDC0[v32[v39 + v31]] - dword_80CFDC0[v33[v39 + v31]];
  }
  return result;
}
// 80CA9D0: using guessed type __int128 xmmword_80CA9D0;
// 80CA9E0: using guessed type __int128 xmmword_80CA9E0;
// 80CA9F0: using guessed type __int128 xmmword_80CA9F0;
// 80CFDC0: using guessed type int dword_80CFDC0[256];

//----- (0807EE70) --------------------------------------------------------
int __usercall critical_factorization@<eax>(int a1@<eax>, unsigned int a2@<edx>, int *a3@<ecx>)
{
  int v3; // esi
  unsigned int v4; // ebx
  int v5; // ecx
  unsigned int v6; // edx
  unsigned __int8 v7; // al
  int v8; // eax
  int v9; // eax
  unsigned int v10; // ebx
  int v11; // edi
  int v12; // ecx
  unsigned int v13; // edx
  unsigned __int8 v14; // al
  int v15; // ebp
  int result; // eax
  int v17; // [esp+4h] [ebp-24h]
  int v19; // [esp+Ch] [ebp-1Ch]
  int v21; // [esp+10h] [ebp-18h]

  v3 = -1;
  v4 = 0;
  v5 = 1;
  v19 = 1;
  while ( 1 )
  {
    v6 = v5 + v4;
    if ( v5 + v4 >= a2 )
      break;
    while ( 1 )
    {
      v7 = *(_BYTE *)(v3 + a1 + v5);
      if ( *(_BYTE *)(a1 + v6) >= v7 )
        break;
      v4 = v6;
      v5 = 1;
      v8 = v6 - v3;
      ++v6;
      v19 = v8;
      if ( v6 >= a2 )
        goto LABEL_5;
    }
    if ( *(_BYTE *)(a1 + v6) == v7 )
    {
      if ( v5 == v19 )
      {
        v19 = v5;
        v4 = v6;
        v5 = 1;
      }
      else
      {
        ++v5;
      }
    }
    else
    {
      v3 = v4;
      v5 = 1;
      ++v4;
      v19 = 1;
    }
  }
LABEL_5:
  v9 = a1;
  v10 = 0;
  v11 = -1;
  v21 = 1;
  v17 = v9;
  *a3 = v19;
  v12 = 1;
  while ( 1 )
  {
    v13 = v12 + v10;
    if ( a2 <= v12 + v10 )
      break;
    while ( 1 )
    {
      v14 = *(_BYTE *)(v11 + v17 + v12);
      if ( *(_BYTE *)(v17 + v13) <= v14 )
        break;
      v10 = v13;
      v12 = 1;
      v15 = v13 - v11;
      ++v13;
      v21 = v15;
      if ( a2 <= v13 )
        goto LABEL_9;
    }
    if ( *(_BYTE *)(v17 + v13) == v14 )
    {
      if ( v12 == v21 )
      {
        v21 = v12;
        v10 = v13;
        v12 = 1;
      }
      else
      {
        ++v12;
      }
    }
    else
    {
      v11 = v10;
      v12 = 1;
      ++v10;
      v21 = 1;
    }
  }
LABEL_9:
  result = v11 + 1;
  if ( v11 + 1 < (unsigned int)(v3 + 1) )
  {
    v21 = v19;
    result = v3 + 1;
  }
  *a3 = v21;
  return result;
}

//----- (0807EFE0) --------------------------------------------------------
void *__usercall two_way_long_needle@<eax>(_BYTE *s1@<ecx>, int a2@<eax>, int a3@<edx>, int a4)
{
  int *v6; // eax
  int i; // eax
  int v8; // edx
  int v9; // ecx
  unsigned int v10; // edi
  int v11; // eax
  unsigned int v12; // esi
  int v13; // ebp
  void *result; // eax
  unsigned int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // edx
  unsigned int j; // eax
  unsigned int v19; // eax
  int v20; // edx
  int v21; // eax
  int v22; // ebp
  int v23; // esi
  int v24; // eax
  int v25; // ecx
  unsigned int v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // [esp+18h] [ebp-454h]
  int v29; // [esp+1Ch] [ebp-450h]
  unsigned int v30; // [esp+20h] [ebp-44Ch]
  unsigned int n; // [esp+24h] [ebp-448h]
  unsigned int v33; // [esp+28h] [ebp-444h]
  unsigned int v34; // [esp+30h] [ebp-43Ch]
  unsigned int v35; // [esp+34h] [ebp-438h]
  unsigned int v36; // [esp+38h] [ebp-434h]
  int v37[256]; // [esp+4Ch] [ebp-420h] BYREF
  int v38[8]; // [esp+44Ch] [ebp-20h] BYREF

  n = critical_factorization((int)s1, a4, v38);
  v6 = v37;
  do
    *v6++ = a4;
  while ( v6 != v38 );
  if ( a4 )
  {
    for ( i = 0; i != a4; ++i )
    {
      v8 = (unsigned __int8)s1[i];
      v9 = a4 - 1 - i;
      v37[v8] = v9;
    }
  }
  v10 = 0;
  v34 = v38[0];
  v30 = 0;
  if ( !memcmp(s1, &s1[v38[0]], n) )
  {
    v11 = a3;
    v12 = a4 - 1;
    while ( 1 )
    {
      v13 = a4 + v30;
      result = memchr((const void *)(a2 + v11), 0, a4 + v30 - v11);
      if ( result )
        break;
      if ( !v13 )
        return result;
      v15 = v37[*(unsigned __int8 *)(a2 + v13 - 1)];
      if ( v15 )
      {
        if ( v10 )
        {
          if ( v34 > v15 )
            v15 = a4 - v34;
        }
        v30 += v15;
        v10 = 0;
        v11 = v13;
      }
      else
      {
        v16 = n;
        if ( v10 >= n )
          v16 = v10;
        if ( v16 >= v12 )
        {
LABEL_22:
          v28 = n;
          if ( v10 < n )
          {
            if ( s1[n - 1] == *(_BYTE *)(v30 + a2 + n - 1) )
            {
              for ( j = n - 1; j != v10 && s1[j - 1] == *(_BYTE *)(j + v30 + a2 - 1); --j )
                ;
              v28 = j;
            }
            else
            {
              v28 = n;
            }
          }
          if ( v28 < v10 + 1 )
            return (void *)(v30 + a2);
          v11 = a4 + v30;
          v30 += v34;
          v10 = a4 - v34;
        }
        else
        {
          while ( s1[v16] == *(_BYTE *)(v30 + a2 + v16) )
          {
            if ( ++v16 >= v12 )
              goto LABEL_22;
          }
          v10 = 0;
          v17 = v16 + v30 + 1 - n;
          v11 = a4 + v30;
          v30 = v17;
        }
      }
    }
  }
  else
  {
    v19 = a4 - n;
    if ( a4 - n < n )
      v19 = n;
    v20 = a2;
    v35 = v19 + 1;
    v38[0] = v19 + 1;
    v21 = a3;
    v22 = 0;
    v36 = a4 - 1;
    while ( 1 )
    {
      v29 = v20;
      v23 = v22 + a4;
      result = memchr((const void *)(v20 + v21), 0, v22 + a4 - v21);
      v20 = v29;
      if ( result )
        break;
      if ( !v23 )
        return result;
      v24 = v37[*(unsigned __int8 *)(v29 + v23 - 1)];
      if ( v24 )
      {
        v22 += v24;
        v21 = v23;
      }
      else
      {
        v25 = v29 + v22;
        if ( n >= v36 )
        {
LABEL_45:
          if ( !n )
            return (void *)(v29 + v22);
          if ( s1[n - 1] == *(_BYTE *)(v25 + n - 1) )
          {
            v27 = n - 1;
            while ( --v27 != -1 )
            {
              if ( s1[v27] != *(_BYTE *)(v25 + v27) )
                goto LABEL_54;
            }
            return (void *)(v29 + v22);
          }
LABEL_54:
          v22 += v35;
          v21 = v23;
        }
        else
        {
          v33 = n;
          if ( s1[n] == *(_BYTE *)(v25 + n) )
          {
            v26 = n;
            do
            {
              if ( ++v26 >= v36 )
              {
                v20 = v29;
                goto LABEL_45;
              }
            }
            while ( s1[v26] == *(_BYTE *)(v25 + v26) );
            v20 = v29;
            v33 = v26;
          }
          v21 = v22 + a4;
          v22 += v33 + 1 - n;
        }
      }
    }
  }
  return 0;
}
// 807EFE0: using guessed type int var_420[256];

//----- (0807F360) --------------------------------------------------------
char *__cdecl _strstr_ia32(char *a1, char *a2)
{
  char *v2; // edi
  char v3; // al
  char v4; // dl
  char *v5; // ecx
  char *v6; // ebx
  char v7; // bp
  char *v8; // eax
  unsigned int v9; // esi
  unsigned int v10; // edx
  int v11; // edi
  unsigned int v13; // ebp
  int n; // eax
  int v15; // eax
  int v16; // edi
  unsigned int v17; // eax
  unsigned int v18; // eax
  unsigned int v19; // eax
  int v20; // ebp
  unsigned int v21; // edx
  int v22; // eax
  int v23; // edi
  void *v24; // eax
  unsigned int v25; // eax
  unsigned int v26; // eax
  unsigned int v27; // [esp+20h] [ebp-4Ch]
  char *v28; // [esp+24h] [ebp-48h]
  int v29; // [esp+28h] [ebp-44h]
  unsigned int v30; // [esp+2Ch] [ebp-40h]
  int v31; // [esp+34h] [ebp-38h]
  unsigned int v32; // [esp+38h] [ebp-34h]
  char *v33; // [esp+3Ch] [ebp-30h]
  int v34[8]; // [esp+4Ch] [ebp-20h] BYREF

  v2 = a1;
  v3 = *a1;
  if ( *a1 )
  {
    v4 = *a2;
    if ( !*a2 )
      return v2;
    v5 = a1;
    v6 = a2;
    v7 = 1;
    while ( 1 )
    {
      ++v6;
      v7 &= v3 == v4;
      v3 = v5[1];
      if ( !v3 )
        break;
      v4 = *v6;
      ++v5;
      if ( !*v6 )
        goto LABEL_7;
    }
  }
  else
  {
    v6 = a2;
    v7 = 1;
  }
  if ( *v6 )
    return 0;
LABEL_7:
  if ( v7 )
    return v2;
  v8 = strchr(a1 + 1, *a2);
  v28 = v8;
  if ( v8 )
  {
    v9 = v6 - a2;
    if ( v6 - a2 == 1 )
      return v8;
    v10 = (unsigned int)&a1[v6 - a2];
    v11 = v10 - (_DWORD)v8;
    if ( (unsigned int)v8 > v10 )
      v11 = 1;
    if ( v9 > 0x1F )
      return (char *)two_way_long_needle(a2, (int)v8, v11, v9);
    v13 = 0;
    n = critical_factorization((int)a2, v9, v34);
    v31 = v34[0];
    v30 = n;
    if ( !memcmp(a2, &a2[v34[0]], n) )
    {
      v15 = v11;
      v16 = 0;
      while ( 1 )
      {
        v29 = v16 + v9;
        if ( memchr(&v28[v15], 0, v16 + v9 - v15) || !v29 )
          return 0;
        v17 = v30;
        if ( v13 >= v30 )
          v17 = v13;
        if ( v9 > v17 )
        {
          if ( a2[v17] != v28[v17 + v16] )
          {
LABEL_36:
            v13 = 0;
            v16 += v17 + 1 - v30;
            goto LABEL_35;
          }
          while ( v9 > ++v17 )
          {
            if ( a2[v17] != v28[v16 + v17] )
              goto LABEL_36;
          }
        }
        v18 = v30;
        if ( v30 > v13 )
        {
          v18 = v30 - 1;
          if ( a2[v30 - 1] == v28[v16 - 1 + v30] )
          {
            while ( v18 != v13 && a2[v18 - 1] == v28[v16 - 1 + v18] )
              --v18;
          }
          else
          {
            v18 = v30;
          }
        }
        if ( v13 + 1 > v18 )
          return &v28[v16];
        v13 = v9 - v31;
        v16 += v31;
LABEL_35:
        v15 = v29;
      }
    }
    v19 = v9 - v30;
    if ( v9 - v30 < v30 )
      v19 = v30;
    v20 = 0;
    v21 = v30;
    v32 = v19 + 1;
    v34[0] = v19 + 1;
    v22 = v11;
    while ( 1 )
    {
      v23 = v20 + v9;
      v27 = v21;
      v24 = memchr(&v28[v22], 0, v20 + v9 - v22);
      v21 = v27;
      if ( v24 || !v23 )
        break;
      if ( v9 <= v27 )
      {
        v33 = &v28[v20];
LABEL_48:
        if ( !v30 )
          return v33;
        if ( a2[v30 - 1] == v33[v30 - 1] )
        {
          v26 = v30 - 1;
          while ( --v26 != -1 )
          {
            if ( a2[v26] != v33[v26] )
              goto LABEL_56;
          }
          return v33;
        }
LABEL_56:
        v20 += v32;
        v22 = v23;
      }
      else
      {
        v25 = v27;
        v33 = &v28[v20];
        if ( a2[v27] == v28[v30 + v20] )
        {
          do
          {
            if ( v9 <= ++v25 )
            {
              v21 = v27;
              goto LABEL_48;
            }
          }
          while ( a2[v25] == v33[v25] );
          v21 = v27;
        }
        v20 += v25 + 1 - v30;
        v22 = v23;
      }
    }
  }
  return 0;
}
// 807F360: using guessed type int var_20[8];

//----- (0807F6E0) --------------------------------------------------------
char *(__cdecl *strstr())(char *a1, char *a2)
{
  char *(__cdecl *result)(char *, char *); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (char *(__cdecl *)(char *, char *))_strstr_sse42;
  if ( (dword_80F1270 & 0x100000) == 0 )
    return _strstr_ia32;
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1270: using guessed type int dword_80F1270;

//----- (0807F710) --------------------------------------------------------
_BYTE *__cdecl wmemcpy(_BYTE *a1, _BYTE *a2, int a3)
{
  return memcpy(a1, a2, 4 * a3);
}

//----- (0807F720) --------------------------------------------------------
_DWORD *__cdecl wmemset(_DWORD *a1, int a2, unsigned int a3)
{
  int v3; // esi
  _DWORD *result; // eax
  _DWORD *v5; // edx
  unsigned int v6; // ebx

  v3 = a3;
  result = a1;
  v5 = a1;
  if ( a3 > 3 )
  {
    v6 = a3;
    do
    {
      v6 -= 4;
      *v5 = a2;
      v5[1] = a2;
      v5[2] = a2;
      v5[3] = a2;
      v5 += 4;
    }
    while ( v6 > 3 );
    v3 = a3 & 3;
    v5 = &a1[4 * ((a3 - 4) >> 2) + 4];
  }
  if ( v3 )
  {
    *v5 = a2;
    if ( v3 != 1 )
    {
      v5[1] = a2;
      if ( v3 == 3 )
        v5[2] = a2;
    }
  }
  return result;
}

//----- (0807F780) --------------------------------------------------------
void *__cdecl wmemmove(void *a1, const void *a2, int a3)
{
  return memmove(a1, a2, 4 * a3);
}

//----- (0807F790) --------------------------------------------------------
_WORD *__cdecl wmempcpy(_BYTE *a1, _BYTE *a2, int a3)
{
  return mempcpy(a1, a2, 4 * a3);
}

//----- (0807F7A0) --------------------------------------------------------
int __cdecl wcrtomb(int *a1, int a2, void *a3)
{
  void *v3; // eax
  int *v4; // ebx
  int v5; // edx
  int v6; // edx
  void *v7; // esp
  _DWORD **v8; // eax
  int v9; // esi
  void **v10; // edi
  _DWORD *v11; // eax
  int (__cdecl *v12)(void *, int *, int *, int, _DWORD, char *, int, int); // esi
  int v13; // eax
  int v14; // edx
  int v16; // edx
  int v17; // [esp+20h] [ebp-48h] BYREF
  int v18[9]; // [esp+24h] [ebp-44h] BYREF
  char v19[4]; // [esp+48h] [ebp-20h] BYREF
  int v20[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  v3 = a3;
  v4 = a1;
  v5 = *(_DWORD *)__readgsdword(0xFFFFFFDC);
  v18[3] = 0;
  v18[4] = 1;
  v18[2] = 1;
  v6 = *(_DWORD *)(v5 + 88);
  v18[8] = 0;
  v7 = alloca(v6 + 15);
  if ( !a3 )
    v3 = &state;
  v18[5] = (int)v3;
  if ( !a1 )
  {
    v4 = &v17;
    a2 = 0;
  }
  v8 = (_DWORD **)__readgsdword(0xFFFFFFDC);
  v18[0] = (int)v4;
  v18[1] = (int)v4 + (*v8)[22];
  v9 = (int)*v8;
  if ( (*v8)[5] )
    goto LABEL_6;
  v10 = &_wcsmbs_gconv_fcts_c;
  if ( (char **)v9 != &nl_C_LC_CTYPE )
  {
    _wcsmbs_load_conv(*v8);
LABEL_6:
    v10 = *(void ***)(v9 + 20);
  }
  v11 = v10[2];
  v12 = (int (__cdecl *)(void *, int *, int *, int, _DWORD, char *, int, int))v11[5];
  if ( *v11 )
    v12 = (int (__cdecl *)(void *, int *, int *, int, _DWORD, char *, int, int))(__readgsdword(0x18u) ^ __ROR4__(v12, 9));
  if ( a2 )
  {
    v20[0] = (int)&a2;
    dl_mcount_wrapper_check((int)v12);
    v13 = v12(v10[2], v18, v20, v20[0] + 4, 0, v19, 0, 1);
  }
  else
  {
    dl_mcount_wrapper_check((int)v12);
    v13 = v12(v10[2], v18, 0, 0, 0, v19, 1, 1);
    if ( v13 == 4 )
    {
      v14 = v18[0];
      *(_BYTE *)v18[0] = 0;
      v18[0] = v14 + 1;
      goto LABEL_12;
    }
    if ( !v13 )
    {
      v16 = v18[0];
      *(_BYTE *)v18[0] = 0;
      v18[0] = v16 + 1;
LABEL_12:
      if ( v13 == 4 )
        goto LABEL_13;
      goto LABEL_17;
    }
  }
  if ( v13 == 4 )
    goto LABEL_13;
LABEL_17:
  if ( v13 && v13 != 7 && v13 != 6 )
  {
    if ( v13 != 5 )
      _assert_fail(
        "status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __GCONV_IN"
        "COMPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
        "wcrtomb.c",
        103,
        "__wcrtomb");
    return v18[0] - (_DWORD)v4;
  }
LABEL_13:
  if ( v13 == 4 || !v13 )
    return v18[0] - (_DWORD)v4;
  __writegsdword(0xFFFFFFE8, 0x54u);
  return -1;
}
// 807F953: conditional instruction was optimized away because eax.4 is in (6..7)
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80CAB80: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80CF3E0: using guessed type char *nl_C_LC_CTYPE;
// 807F7A0: using guessed type char var_20[4];
// 807F7A0: using guessed type int var_1C[7];

//----- (0807F9C0) --------------------------------------------------------
int __cdecl wcsrtombs(int a1, const wchar_t **a2, int a3, int *a4)
{
  int *v4; // eax
  unsigned int v5; // eax
  char **v6; // ebx
  void **v7; // eax
  _DWORD *v8; // edi
  int (__cdecl *v9)(_DWORD *, char **, const wchar_t **, int, _DWORD, char *, _DWORD, int); // ebx
  int v10; // esi
  int v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // esi
  size_t v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // [esp+2Ch] [ebp-160h]
  char v20[256]; // [esp+3Ch] [ebp-150h] BYREF
  char *v21; // [esp+13Ch] [ebp-50h] BYREF
  int *v22; // [esp+140h] [ebp-4Ch]
  int v23; // [esp+144h] [ebp-48h]
  int v24; // [esp+148h] [ebp-44h]
  int v25; // [esp+14Ch] [ebp-40h]
  int *v26; // [esp+150h] [ebp-3Ch]
  int v27; // [esp+15Ch] [ebp-30h]
  int v28[2]; // [esp+160h] [ebp-2Ch] BYREF
  int v29; // [esp+168h] [ebp-24h] BYREF
  char v30[32]; // [esp+16Ch] [ebp-20h] BYREF

  v4 = a4;
  v27 = 0;
  v24 = 0;
  v25 = 1;
  if ( !a4 )
    v4 = (int *)&state_0;
  v26 = v4;
  v23 = 1;
  v5 = __readgsdword(0xFFFFFFDC);
  v6 = *(char ***)v5;
  if ( *(_DWORD *)(*(_DWORD *)v5 + 20) )
    goto LABEL_4;
  v7 = &_wcsmbs_gconv_fcts_c;
  if ( v6 != &nl_C_LC_CTYPE )
  {
    _wcsmbs_load_conv(v6);
LABEL_4:
    v7 = (void **)v6[5];
  }
  v8 = v7[2];
  v9 = (int (__cdecl *)(_DWORD *, char **, const wchar_t **, int, _DWORD, char *, _DWORD, int))v8[5];
  if ( *v8 )
    v9 = (int (__cdecl *)(_DWORD *, char **, const wchar_t **, int, _DWORD, char *, _DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v9, 9));
  v10 = (int)*a2;
  if ( a1 )
  {
    v11 = wcsnlen(*a2, a3);
    v21 = (char *)a1;
    v12 = v10 + 4 * v11 + 4;
    v22 = (int *)(a1 + a3);
    dl_mcount_wrapper_check((int)v9);
    v13 = v9(v8, &v21, a2, v12, 0, v30, 0, 1);
    v14 = (int)&v21[-a1];
    if ( v13 == 4 )
    {
      if ( !*(v21 - 1) )
      {
LABEL_10:
        if ( (char *)a1 == v21 )
          _assert_fail("data.__outbuf != (unsigned char *) dst", "wcsrtombs.c", 128, "__wcsrtombs");
        if ( *v26 )
          _assert_fail("((data.__statep)->__count == 0)", "wcsrtombs.c", 129, "__wcsrtombs");
        *a2 = 0;
LABEL_13:
        --v14;
      }
    }
    else if ( !v13 && !*(v21 - 1) )
    {
      goto LABEL_10;
    }
  }
  else
  {
    v16 = wcslen(*a2);
    v29 = v10;
    v17 = v10 + 4 * v16 + 4;
    v14 = 0;
    v19 = v17;
    v18 = *v26;
    v28[1] = v26[1];
    v28[0] = v18;
    v26 = v28;
    v22 = (int *)&v21;
    do
    {
      v21 = v20;
      dl_mcount_wrapper_check((int)v9);
      v13 = v9(v8, &v21, (const wchar_t **)&v29, v19, 0, v30, 0, 1);
      v14 += v21 - v20;
    }
    while ( v13 == 5 );
    if ( v13 == 4 || !v13 )
    {
      if ( *(v21 - 1) )
        _assert_fail("data.__outbuf[-1] == '\\0'", "wcsrtombs.c", 100, "__wcsrtombs");
      goto LABEL_13;
    }
  }
  if ( v13 == 4 || !v13 || v13 == 7 || v13 == 6 )
  {
    if ( v13 && v13 != 4 )
    {
      v14 = -1;
      __writegsdword(0xFFFFFFE8, 0x54u);
    }
  }
  else if ( v13 != 5 )
  {
    _assert_fail(
      "status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __GCONV_INCO"
      "MPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
      "wcsrtombs.c",
      140,
      "__wcsrtombs");
  }
  return v14;
}
// 807FB2B: conditional instruction was optimized away because eax.4 is in (==0|==4|6..7)
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80CAB80: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80CF3E0: using guessed type char *nl_C_LC_CTYPE;

//----- (0807FD00) --------------------------------------------------------
int __cdecl mbsnrtowcs(int a1, int *a2, int a3, int a4, int *a5)
{
  int *v5; // eax
  int v6; // ebx
  unsigned int v7; // eax
  int v8; // ebx
  void **v9; // eax
  void *v10; // edi
  int (__cdecl *v11)(void *, char **, int *, int, _DWORD, char *, _DWORD, int); // ebx
  int v12; // eax
  int v13; // edx
  int v14; // esi
  int v16; // edx
  int v17; // edx
  int v18; // eax
  int v19; // [esp+2Ch] [ebp-160h]
  char v20[256]; // [esp+3Ch] [ebp-150h] BYREF
  char *v21; // [esp+13Ch] [ebp-50h] BYREF
  int *v22; // [esp+140h] [ebp-4Ch]
  int v23; // [esp+144h] [ebp-48h]
  int v24; // [esp+148h] [ebp-44h]
  int v25; // [esp+14Ch] [ebp-40h]
  int *v26; // [esp+150h] [ebp-3Ch]
  int v27; // [esp+15Ch] [ebp-30h]
  int v28[2]; // [esp+160h] [ebp-2Ch] BYREF
  char v29[4]; // [esp+168h] [ebp-24h] BYREF
  int v30[8]; // [esp+16Ch] [ebp-20h] BYREF

  v5 = a5;
  v24 = 0;
  if ( !a5 )
    v5 = (int *)&state_1;
  v25 = 1;
  v23 = 1;
  v26 = v5;
  v27 = 0;
  if ( !a3 )
    return 0;
  v6 = *a2;
  v19 = v6 + strnlen(*a2, a3 - 1) + 1;
  v7 = __readgsdword(0xFFFFFFDC);
  v8 = *(_DWORD *)v7;
  if ( !*(_DWORD *)(*(_DWORD *)v7 + 20) )
  {
    v9 = &_wcsmbs_gconv_fcts_c;
    if ( (char **)v8 == &nl_C_LC_CTYPE )
      goto LABEL_6;
    _wcsmbs_load_conv((_DWORD *)v8);
  }
  v9 = *(void ***)(v8 + 20);
LABEL_6:
  v10 = *v9;
  v11 = (int (__cdecl *)(void *, char **, int *, int, _DWORD, char *, _DWORD, int))*((_DWORD *)*v9 + 5);
  if ( *(_DWORD *)*v9 )
    v11 = (int (__cdecl *)(void *, char **, int *, int, _DWORD, char *, _DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v11, 9));
  if ( a1 )
  {
    v21 = (char *)a1;
    v22 = (int *)(a1 + 4 * a4);
    dl_mcount_wrapper_check((int)v11);
    v12 = v11(v10, &v21, a2, v19, 0, v29, 0, 1);
    v13 = (int)&v21[-a1] >> 2;
    v14 = v13;
    if ( v12 == 4 || !v12 )
    {
      if ( !v13 )
        _assert_fail("result > 0", "mbsnrtowcs.c", 124, "__mbsnrtowcs");
      v16 = v13 - 1;
      if ( !*(_DWORD *)(a1 + 4 * v16) )
      {
        if ( *v26 )
          _assert_fail("((data.__statep)->__count == 0)", "mbsnrtowcs.c", 127, "__mbsnrtowcs");
        v14 = v16;
        *a2 = 0;
      }
    }
  }
  else
  {
    v14 = 0;
    v30[0] = *a2;
    v17 = v26[1];
    v18 = *v26;
    v22 = (int *)&v21;
    v28[1] = v17;
    v28[0] = v18;
    v26 = v28;
    do
    {
      v21 = v20;
      dl_mcount_wrapper_check((int)v11);
      v12 = v11(v10, &v21, v30, v19, 0, v29, 0, 1);
      v14 += (v21 - v20) >> 2;
    }
    while ( v12 == 5 );
    if ( v12 == 4 || !v12 )
      v14 = (__PAIR64__(v14, *((_DWORD *)v21 - 1)) - 1) >> 32;
  }
  if ( v12 == 4 || !v12 || v12 == 7 || v12 == 6 )
  {
    if ( v12 && v12 != 7 && v12 != 4 )
    {
      v14 = -1;
      __writegsdword(0xFFFFFFE8, 0x54u);
    }
  }
  else if ( v12 != 5 )
  {
    _assert_fail(
      "status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __GCONV_INCO"
      "MPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
      "mbsnrtowcs.c",
      138,
      "__mbsnrtowcs");
  }
  return v14;
}
// 807FE53: conditional instruction was optimized away because eax.4 is in (==0|==4|6..7)
// 8048210: using guessed type int __cdecl strnlen(_DWORD, _DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80CAB80: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80CF3E0: using guessed type char *nl_C_LC_CTYPE;
// 807FD00: using guessed type char var_24[4];
// 807FD00: using guessed type int var_20[8];

//----- (08080050) --------------------------------------------------------
int __cdecl wcsnlen(_DWORD *a1, int a2)
{
  int v2; // ecx
  int v3; // esi
  int i; // edx
  int result; // eax

  if ( !a2 || !*a1 )
    return 0;
  if ( a2 == 1 || !a1[1] )
    return 1;
  if ( a2 == 2 )
    return 2;
  v2 = a2 - 4;
  v3 = 2;
  for ( i = 0; a1[v3]; i += 4 )
  {
    result = i + 3;
    if ( v2 == -1 )
      return result;
    if ( !a1[i + 3] )
      return result;
    result = i + 4;
    if ( !v2 || !a1[result] )
      return result;
    v3 = i + 5;
    if ( v2 == 1 )
      break;
    if ( !a1[result + 1] )
      break;
    v2 -= 4;
    v3 = i + 6;
    if ( v2 == -2 )
      break;
  }
  return v3;
}

//----- (080800E0) --------------------------------------------------------
int __usercall nl_cleanup_ctype@<eax>(int result@<eax>)
{
  int *v1; // ebx

  v1 = *(int **)(result + 20);
  if ( v1 )
  {
    *(_DWORD *)(result + 20) = 0;
    *(_DWORD *)(result + 16) = 0;
    _gconv_close_transform(v1[2], v1[3]);
    _gconv_close_transform(*v1, v1[1]);
    return free(v1);
  }
  return result;
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08080120) --------------------------------------------------------
int __cdecl _wcsmbs_getfct(char *a1, char *a2, _DWORD *a3)
{
  int v3; // eax
  int v5; // ebx
  unsigned int v6; // [esp+18h] [ebp-14h] BYREF
  int v7[4]; // [esp+1Ch] [ebp-10h] BYREF

  _gconv_find_transform(a1, a2, v7, &v6, 0);
  if ( v3 )
    return 0;
  if ( v6 > 1 )
  {
    _gconv_close_transform(v7[0], v6);
    return 0;
  }
  v5 = v7[0];
  *a3 = v6;
  return v5;
}
// 808014B: variable 'v3' is possibly undefined
// 8080120: using guessed type int var_10[4];

//----- (08080180) --------------------------------------------------------
int __usercall _wcsmbs_load_conv@<eax>(_DWORD *a1@<eax>)
{
  int *v1; // ebx
  int v2; // eax
  int v3; // ecx
  unsigned int v4; // esi
  char *i; // eax
  char v6; // dl
  void *v7; // esp
  char v8; // dl
  _BYTE *v9; // eax
  char *v10; // ecx
  char *v11; // ecx
  int v12; // eax
  int v13; // eax
  int v14; // eax
  unsigned int v16; // esi
  char *v17; // edx
  _BYTE v18[12]; // [esp+10h] [ebp-38h] BYREF
  int v19; // [esp+1Ch] [ebp-2Ch]
  char *v20; // [esp+20h] [ebp-28h]
  unsigned int v21; // [esp+24h] [ebp-24h]
  _DWORD *v22; // [esp+28h] [ebp-20h]
  char *v23; // [esp+2Ch] [ebp-1Ch]

  v22 = a1;
  if ( !a1[5] )
  {
    v1 = (int *)malloc(16);
    if ( v1 )
    {
      v20 = (char *)v22[23];
      v2 = v22[7];
      v3 = v2 == 0 ? 3 : 11;
      v19 = v2;
      v4 = 0;
      v21 = v2 != 0 ? 8 : 0;
      for ( i = v20; ; ++i )
      {
        v6 = *i;
        if ( !*i )
          break;
        v4 += v6 == 47;
      }
      v7 = alloca(v3 + i - v20 + 15);
      v23 = v18;
      v8 = *v20;
      v9 = v18;
      if ( *v20 )
      {
        v10 = v20;
        do
        {
          ++v10;
          *v9 = dword_80D03C0[v8];
          v8 = *v10;
          ++v9;
        }
        while ( *v10 );
      }
      if ( v4 <= 1 )
      {
        *v9 = 47;
        if ( v4 )
        {
          ++v9;
        }
        else
        {
          v16 = v21;
          v9[1] = 47;
          v9 += 2;
          if ( v16 )
          {
            v17 = "TRANSLIT";
            if ( !v19 )
              v17 = (char *)&unk_80C86D9;
            v9 = mempcpy(v9, v17, v21);
          }
        }
      }
      v11 = v23;
      *v9 = 0;
      v12 = _wcsmbs_getfct("INTERNAL", v11, v1 + 1);
      *v1 = v12;
      if ( v12 )
      {
        v13 = _wcsmbs_getfct(v23, "INTERNAL", v1 + 3);
        v1[2] = v13;
        if ( v13 )
        {
          v14 = (int)v22;
          v22[5] = v1;
          *(_DWORD *)(v14 + 16) = nl_cleanup_ctype;
          return 0;
        }
        if ( *v1 )
          _gconv_close_transform(*v1, v1[1]);
      }
      else
      {
        v1[2] = 0;
      }
      free(v1);
    }
    v22[5] = &_wcsmbs_gconv_fcts_c;
  }
  return 0;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80CAB80: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80D03C0: using guessed type _DWORD dword_80D03C0[256];

//----- (08080350) --------------------------------------------------------
_DWORD *__usercall _wcsmbs_clone_conv@<eax>(void **a1@<eax>)
{
  unsigned int v2; // eax
  char **v3; // esi
  void **v4; // eax
  _DWORD *v5; // edx
  bool v6; // zf
  _DWORD *result; // eax

  v2 = __readgsdword(0xFFFFFFDC);
  v3 = *(char ***)v2;
  v4 = *(void ***)(*(_DWORD *)v2 + 20);
  if ( !v4 )
  {
    v4 = &_wcsmbs_gconv_fcts_c;
    if ( v3 != &nl_C_LC_CTYPE )
    {
      _wcsmbs_load_conv(v3);
      v4 = (void **)v3[5];
    }
  }
  v5 = *v4;
  *a1 = *v4;
  a1[1] = v4[1];
  a1[2] = v4[2];
  v6 = *v5 == 0;
  a1[3] = v4[3];
  if ( !v6 )
    ++v5[2];
  result = a1[2];
  if ( *result )
    ++result[2];
  return result;
}
// 80CAB80: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80CF3E0: using guessed type char *nl_C_LC_CTYPE;

//----- (080803C0) --------------------------------------------------------
_BOOL4 __usercall _wcsmbs_named_conv@<eax>(int *a1@<eax>, int a2@<edx>)
{
  int v4; // edx
  _BOOL4 result; // eax
  int v6; // eax

  v4 = _wcsmbs_getfct("INTERNAL", a2, a1 + 1);
  *a1 = v4;
  result = 1;
  if ( v4 )
  {
    v6 = _wcsmbs_getfct(a2, "INTERNAL", a1 + 3);
    a1[2] = v6;
    if ( !v6 )
      _gconv_close_transform(*a1, a1[1]);
    return !*a1 || a1[2] == 0;
  }
  return result;
}
// 8080120: using guessed type _DWORD __cdecl _wcsmbs_getfct(_DWORD, _DWORD, _DWORD);

//----- (08080440) --------------------------------------------------------
void __usercall localtime_r(long double a1@<st0>, int *a2, int *a3)
{
  _tz_convert(a1, a2, 1, a3);
}

//----- (08080470) --------------------------------------------------------
void __usercall localtime(long double a1@<st0>, int *a2)
{
  _tz_convert(a1, a2, 1, tmbuf);
}
// 80F12C0: using guessed type int tmbuf[11];

//----- (080804A0) --------------------------------------------------------
__int64 __fastcall time(int a1)
{
  __int64 result; // rax

  result = dl_sysinfo(a1);
  if ( HIDWORD(result) )
    *(_DWORD *)HIDWORD(result) = result;
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080804C0) --------------------------------------------------------
int __usercall compute_offset@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>)
{
  int v3; // ebx
  int v4; // edx
  int v5; // eax
  int v6; // ebx

  v3 = 59;
  if ( a2 > 0x3B )
    a2 = 59;
  v4 = 60 * a2;
  if ( a1 <= 0x3B )
    v3 = a1;
  v5 = v4 + v3;
  v6 = 24;
  if ( a3 <= 0x18 )
    v6 = a3;
  return 3600 * v6 + v5;
}

//----- (080804F0) --------------------------------------------------------
int __usercall compute_change@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx
  int v4; // esi
  bool v5; // cf
  int v6; // esi
  int v7; // eax
  unsigned __int16 v8; // di
  int v9; // edx
  int v10; // edx
  unsigned int v11; // edx
  int v12; // esi
  int v13; // edi
  int v14; // edx
  int v15; // [esp+0h] [ebp-1Ch]
  int v16; // [esp+4h] [ebp-18h]
  int v17; // [esp+8h] [ebp-14h]

  v2 = result;
  if ( a2 != -1 )
  {
    if ( *(_DWORD *)(result + 28) == a2 )
      return result;
    v4 = 0;
    if ( a2 > 1970 )
      v4 = 86400
         * (365 * a2
          + ((a2 - 1) >> 2)
          - 719542
          - ((int)((unsigned __int64)(1374389535LL * (a2 - 1)) >> 32) >> 5)
          + ((int)((unsigned __int64)(1374389535LL * (a2 - 1)) >> 32) >> 7)
          + 15);
    result = *(_DWORD *)(result + 4);
    v5 = result == 0;
    if ( result != 1 )
      goto LABEL_6;
LABEL_12:
    result = *(unsigned __int16 *)(v2 + 12);
    v4 += 86400 * ((unsigned __int16)result - 1);
    if ( (unsigned __int16)result > 0x3Bu && (a2 & 3) == 0 )
    {
      result = 100 * (a2 / 100);
      if ( a2 != result || a2 == 400 * (a2 / 400) )
        v4 += 86400;
    }
    goto LABEL_8;
  }
  result = *(_DWORD *)(result + 4);
  v4 = 0;
  v5 = result == 0;
  if ( result == 1 )
    goto LABEL_12;
LABEL_6:
  if ( v5 )
  {
    result = 86400 * *(unsigned __int16 *)(v2 + 12);
    v4 += result;
  }
  else if ( result == 2 )
  {
    v7 = 0;
    if ( (a2 & 3) == 0 )
    {
      v7 = 13;
      if ( a2 == 100 * (a2 / 100) )
        v7 = a2 == 400 * (a2 / 400) ? 0xD : 0;
    }
    v8 = *(_WORD *)(v2 + 8);
    v16 = v8 + v7;
    v15 = (unsigned __int16)word_80DE01E[v16];
    v17 = v4 + 86400 * v15;
    v9 = ((a2 - (v8 < 3u)) / 100 / 4
        + (a2 - (v8 < 3u)) % 100
        + (int)(26 * (v8 + 9 - 12 * ((unsigned int)((unsigned __int64)(715827883LL * (v8 + 9)) >> 32) >> 1) + 1) - 2)
        / 10
        + 1
        + (a2 - (v8 < 3u)) % 100 / 4
        - 2 * ((a2 - (v8 < 3u)) / 100))
       % 7;
    v10 = v9 + (v9 < 0 ? 7 : 0);
    result = *(unsigned __int16 *)(v2 + 12) - v10 + (*(unsigned __int16 *)(v2 + 12) - v10 < 0 ? 7 : 0);
    v11 = *(unsigned __int16 *)(v2 + 10);
    v12 = result;
    if ( v11 > 1 )
    {
      v12 = result + 7;
      v13 = (unsigned __int16)_mon_yday[v16] - v15;
      if ( v13 <= result + 7 )
      {
        v12 = result;
      }
      else
      {
        v14 = result + 7 * v11 - 7;
        while ( v12 != v14 )
        {
          result = v12 + 7;
          if ( v12 + 7 >= v13 )
            break;
          v12 += 7;
        }
      }
    }
    v4 = v17 + 86400 * v12;
  }
LABEL_8:
  v6 = *(_DWORD *)(v2 + 16) + v4 - *(_DWORD *)(v2 + 20);
  *(_DWORD *)(v2 + 28) = a2;
  *(_DWORD *)(v2 + 24) = v6;
  return result;
}
// 80DE01E: using guessed type __int16 word_80DE01E[];
// 80DE020: using guessed type __int16 _mon_yday[13];

//----- (08080780) --------------------------------------------------------
unsigned int update_vars()
{
  unsigned int v0; // ebx
  unsigned int result; // eax
  unsigned int v2; // edx

  timezone = -dword_80F0D74;
  daylight = dword_80F0D74 != dword_80F0D94;
  off_80EFA2C = (char *)dword_80F0D80;
  tzname = (char *)tz_rules;
  v0 = strlen((_BYTE *)tz_rules);
  result = strlen((_BYTE *)dword_80F0D80);
  v2 = _tzname_cur_max;
  if ( v0 > _tzname_cur_max )
  {
    _tzname_cur_max = v0;
    v2 = v0;
  }
  if ( v2 < result )
    _tzname_cur_max = result;
  return result;
}
// 80EFA2C: using guessed type char *off_80EFA2C;
// 80F0D40: using guessed type int timezone;
// 80F0D44: using guessed type int daylight;
// 80F0D60: using guessed type int tz_rules;
// 80F0D74: using guessed type int dword_80F0D74;
// 80F0D80: using guessed type int dword_80F0D80;
// 80F0D94: using guessed type int dword_80F0D94;
// 80F12EC: using guessed type int _tzname_cur_max;

//----- (080807F0) --------------------------------------------------------
const char *__cdecl _tzstring(char *src)
{
  int *v1; // ebx
  unsigned int v2; // esi
  unsigned int v3; // eax
  const char *s2; // edi
  int v5; // eax
  int v6; // ebx
  int *v8; // [esp+1Ch] [ebp-20h]

  v1 = (int *)tzstring_list;
  v2 = strlen(src);
  if ( tzstring_list )
  {
    while ( 1 )
    {
      v3 = v1[1];
      if ( v2 <= v3 )
      {
        s2 = (char *)v1 + v3 - v2 + 8;
        if ( !strcmp(src, s2) )
          break;
      }
      if ( !*v1 )
      {
        v8 = v1;
        goto LABEL_8;
      }
      v1 = (int *)*v1;
    }
  }
  else
  {
    v8 = 0;
LABEL_8:
    s2 = 0;
    v5 = malloc(v2 + 9);
    v6 = v5;
    if ( v5 )
    {
      *(_DWORD *)v5 = 0;
      s2 = (const char *)(v5 + 8);
      *(_DWORD *)(v5 + 4) = v2;
      strcpy((char *)(v5 + 8), src);
      if ( v8 )
        *v8 = v6;
      else
        tzstring_list = v6;
    }
  }
  return s2;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80F0D48: using guessed type int tzstring_list;

//----- (080808A0) --------------------------------------------------------
unsigned int __usercall _tzset_parse_tz@<eax>(long double a1@<st0>, _BYTE *a2)
{
  int v2; // eax
  void *v3; // esp
  char *v4; // ebx
  int v5; // eax
  char *v6; // esi
  char *v7; // edx
  unsigned int v8; // edi
  char v9; // al
  char *v10; // esi
  char v11; // al
  bool v12; // dl
  int v13; // eax
  unsigned int result; // eax
  unsigned int v15; // edx
  unsigned int v16; // eax
  int v17; // eax
  char *v18; // esi
  int v19; // eax
  int v20; // eax
  char v21; // al
  char *v22; // edx
  char *v23; // ecx
  unsigned int v24; // edi
  char v25; // al
  bool v26; // dl
  int v27; // eax
  char *v28; // edx
  int v29; // edi
  int *v30; // ebx
  char *v31; // esi
  char v32; // al
  unsigned int v33; // eax
  char v34; // al
  char *v35; // esi
  int v36; // eax
  int v37; // eax
  int v38; // edx
  int v39; // eax
  __int16 v40; // ax
  __int16 v41; // ax
  unsigned int v42; // edx
  unsigned int v43; // eax
  int v44; // eax
  char v45[12]; // [esp+20h] [ebp-38h] BYREF
  char *v46; // [esp+2Ch] [ebp-2Ch]
  int v47; // [esp+30h] [ebp-28h] BYREF
  char *v48; // [esp+34h] [ebp-24h] BYREF
  unsigned __int16 v49; // [esp+3Ah] [ebp-1Eh] BYREF
  unsigned __int16 v50; // [esp+3Ch] [ebp-1Ch] BYREF
  unsigned __int16 v51; // [esp+3Eh] [ebp-1Ah] BYREF

  memset(&tz_rules, 0, 0x40u);
  dword_80F0D80 = (int)&unk_80C86D9;
  tz_rules = (int)&unk_80C86D9;
  v2 = strlen(a2);
  v3 = alloca(v2 + 16);
  v4 = memcpy(v45, a2, v2 + 1);
  sscanf(a1, (unsigned int)a2, "%[A-Za-z]%n", v4, &v47);
  if ( v5 == 1 )
  {
    if ( v47 <= 2 )
      return update_vars();
    v10 = &a2[v47];
  }
  else
  {
    if ( *a2 != 60 )
      return update_vars();
    v6 = a2 + 1;
    v7 = v4;
    v8 = __readgsdword(0xFFFFFFF8);
    while ( 1 )
    {
      v9 = *v6;
      if ( (*(_BYTE *)(v8 + 2 * *v6) & 8) == 0 && v9 != 43 && v9 != 45 )
        break;
      *v7 = v9;
      ++v6;
      ++v7;
    }
    if ( v9 != 62 || v7 - v4 <= 2 )
      return update_vars();
    v10 = v6 + 1;
    *v7 = 0;
  }
  tz_rules = (int)_tzstring(v4);
  v11 = *v10;
  if ( !*v10 )
    return update_vars();
  if ( v11 == 45 || v11 == 43 )
  {
    v12 = v11 == 45;
    if ( v11 == 43 )
    {
LABEL_15:
      ++v10;
      dword_80F0D74 = !v12 ? -1 : 1;
      goto LABEL_16;
    }
  }
  else
  {
    if ( (unsigned int)(v11 - 48) > 9 )
      return update_vars();
    v12 = v11 == 45;
  }
  if ( v12 )
    goto LABEL_15;
  dword_80F0D74 = -1;
LABEL_16:
  sscanf(a1, (unsigned int)v10, "%hu%n:%hu%n:%hu%n", &v49, &v47, &v50, &v47, &v51, &v47);
  if ( v13 == 2 )
  {
    v15 = v50;
LABEL_29:
    v51 = 0;
    v16 = 0;
    goto LABEL_30;
  }
  if ( v13 != 3 )
  {
    if ( v13 != 1 )
    {
      dword_80F0D74 = 0;
      return update_vars();
    }
    v50 = 0;
    v15 = 0;
    goto LABEL_29;
  }
  v16 = v51;
  v15 = v50;
LABEL_30:
  v17 = compute_offset(v16, v15, v49);
  v18 = &v10[v47];
  v19 = dword_80F0D74 * v17;
  v46 = v18;
  dword_80F0D74 = v19;
  if ( !*v18 )
  {
    dword_80F0D94 = v19;
    dword_80F0D80 = tz_rules;
    return update_vars();
  }
  sscanf(a1, (unsigned int)v18, "%[A-Za-z]%n", v4, &v47);
  if ( v20 == 1 )
  {
    if ( v47 > 2 )
    {
      v46 += v47;
      goto LABEL_44;
    }
LABEL_55:
    v21 = *v46;
    goto LABEL_56;
  }
  v21 = *v46;
  if ( *v46 != 60 )
  {
LABEL_56:
    v28 = v46;
    v29 = 0;
    while ( 1 )
    {
      v30 = (int *)(32 * v29 + 135204192);
      v31 = &v28[v21 == 44];
      v32 = *v31;
      if ( *v31 == 74 )
        break;
      if ( (unsigned int)(v32 - 48) <= 9 )
      {
        *(_DWORD *)&algn_80F0D64[32 * v29] = 0;
LABEL_60:
        v33 = strtoul(v31, &v48, 10);
        v28 = v48;
        if ( v33 > 0x16D || v48 == v31 || !v33 && *(_DWORD *)&algn_80F0D64[32 * v29] == 1 )
          return update_vars();
        word_80F0D6C[16 * v29] = v33;
        goto LABEL_64;
      }
      if ( v32 == 77 )
      {
        *(_DWORD *)&algn_80F0D64[32 * v29] = 2;
        sscanf(
          a1,
          (unsigned int)v31,
          "M%hu.%hu.%hu%n",
          32 * v29 + 135204200,
          32 * v29 + 135204202,
          32 * v29 + 135204204,
          &v47);
        if ( v39 != 3 )
          return update_vars();
        v40 = word_80F0D68[16 * v29];
        if ( !v40 )
          return update_vars();
        if ( (unsigned __int16)v40 > 0xCu )
          return update_vars();
        v41 = word_80F0D6A[16 * v29];
        if ( !v41 || (unsigned __int16)v41 > 5u || (unsigned __int16)word_80F0D6C[16 * v29] > 6u )
          return update_vars();
        v28 = &v31[v47];
      }
      else
      {
        if ( v32 )
          return update_vars();
        *(_DWORD *)&algn_80F0D64[32 * v29] = 2;
        if ( v30 == &tz_rules )
        {
          word_80F0D68[0] = 4;
          v28 = v31;
          word_80F0D6A[0] = 1;
          word_80F0D6C[0] = 0;
        }
        else
        {
          word_80F0D68[16 * v29] = 10;
          v28 = v31;
          word_80F0D6A[16 * v29] = 5;
          word_80F0D6C[16 * v29] = 0;
        }
      }
LABEL_64:
      v34 = *v28;
      if ( *v28 != 47 && v34 )
      {
        if ( v34 != 44 )
          return update_vars();
LABEL_67:
        *((_DWORD *)&unk_80F0D70 + 8 * v29) = 7200;
        goto LABEL_68;
      }
      if ( v34 != 47 )
        goto LABEL_67;
      if ( !v28[1] )
        return update_vars();
      v35 = v28 + 1;
      v47 = 0;
      sscanf(a1, (unsigned int)(v28 + 1), "%hu%n:%hu%n:%hu%n", &v49, &v47, &v50, &v47, &v51, &v47);
      if ( v36 == 2 )
      {
        v37 = 60 * v50 + 3600 * v49;
      }
      else
      {
        if ( v36 == 3 )
        {
          v37 = v51 + 60 * v50 + 3600 * v49;
          goto LABEL_78;
        }
        if ( v36 == 1 )
        {
          v37 = 3600 * v49;
        }
        else
        {
          v49 = 2;
          v37 = 7200;
        }
        v50 = 0;
      }
      v51 = 0;
LABEL_78:
      v38 = v47;
      *((_DWORD *)&unk_80F0D70 + 8 * v29) = v37;
      v28 = &v35[v38];
LABEL_68:
      ++v29;
      v30[7] = -1;
      if ( v29 == 2 )
        return update_vars();
      v21 = *v28;
    }
    *(_DWORD *)&algn_80F0D64[32 * v29] = 1;
    if ( (unsigned int)(v31[1] - 48) > 9 )
      return update_vars();
    ++v31;
    goto LABEL_60;
  }
  v22 = v46 + 1;
  v23 = v4;
  v24 = __readgsdword(0xFFFFFFF8);
  while ( 1 )
  {
    v25 = *v22;
    if ( (*(_BYTE *)(v24 + 2 * *v22) & 8) == 0 && v25 != 43 && v25 != 45 )
      break;
    *v23 = v25;
    ++v22;
    ++v23;
  }
  if ( v25 != 62 || v23 - v4 <= 2 )
    goto LABEL_55;
  *v23 = 0;
  v46 = v22 + 1;
LABEL_44:
  dword_80F0D80 = (int)_tzstring(v4);
  v26 = *v46 == 45;
  if ( *v46 == 43 || *v46 == 45 )
  {
    ++v46;
    dword_80F0D94 = !v26 ? -1 : 1;
  }
  else
  {
    dword_80F0D94 = -1;
  }
  sscanf(a1, (unsigned int)v46, "%hu%n:%hu%n:%hu%n", &v49, &v47, &v50, &v47, &v51, &v47);
  switch ( v27 )
  {
    case 2:
      v42 = v50;
      goto LABEL_96;
    case 3:
      v43 = v51;
      v42 = v50;
      goto LABEL_97;
    case 1:
      v50 = 0;
      v42 = 0;
LABEL_96:
      v51 = 0;
      v43 = 0;
LABEL_97:
      v44 = compute_offset(v43, v42, v49);
      v46 += v47;
      dword_80F0D94 *= v44;
      goto LABEL_51;
  }
  dword_80F0D94 = dword_80F0D74 + 3600;
LABEL_51:
  v21 = *v46;
  if ( *v46 && (v21 != 44 || v46[1]) )
    goto LABEL_56;
  _tzfile_default((char *)tz_rules, (char *)dword_80F0D80, dword_80F0D74, dword_80F0D94);
  if ( !_use_tzfile )
    goto LABEL_55;
  result = free(old_tz);
  old_tz = 0;
  return result;
}
// 8080A32: conditional instruction was optimized away because al.1 is in (<2Bu|==2C|>=2Eu)
// 808091A: variable 'v5' is possibly undefined
// 80809E7: variable 'v13' is possibly undefined
// 8080AD2: variable 'v20' is possibly undefined
// 8080BA1: variable 'v27' is possibly undefined
// 8080D11: variable 'v36' is possibly undefined
// 8080DBB: variable 'v39' is possibly undefined
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80F0D60: using guessed type int tz_rules;
// 80F0D68: using guessed type __int16 word_80F0D68[];
// 80F0D6A: using guessed type __int16 word_80F0D6A[];
// 80F0D6C: using guessed type __int16 word_80F0D6C[];
// 80F0D74: using guessed type int dword_80F0D74;
// 80F0D80: using guessed type int dword_80F0D80;
// 80F0D94: using guessed type int dword_80F0D94;
// 80F12F0: using guessed type int _use_tzfile;
// 80808A0: using guessed type char anonymous_0[12];

//----- (08080F20) --------------------------------------------------------
int __usercall tzset_internal@<eax>(int result@<eax>, int a2@<edx>, long double a3@<st0>)
{
  int v4; // eax
  char *v5; // ebx
  char v6; // al
  char *v7; // esi
  char *s1; // ebx

  if ( !result && is_initialized_7800 )
    return result;
  is_initialized_7800 = 1;
  v4 = getenv("TZ");
  v5 = (char *)v4;
  if ( v4 || a2 )
  {
    if ( !v4 )
    {
      v7 = old_tz;
      s1 = "/etc/localtime";
LABEL_14:
      tz_rules = 0;
      dword_80F0D80 = 0;
      free(v7);
      old_tz = strdup(s1);
      result = _tzfile_read(s1, 0, 0);
      if ( !_use_tzfile )
      {
        if ( *s1 && strcmp(s1, "/etc/localtime") )
        {
          return _tzset_parse_tz(a3, s1);
        }
        else
        {
          memset(&tz_rules, 0, 0x40u);
          dword_80F0D80 = (int)&unk_80CAC65;
          tz_rules = (int)&unk_80CAC65;
          dword_80F0D98 = -1;
          dword_80F0D78 = -1;
          return update_vars();
        }
      }
      return result;
    }
  }
  else
  {
    v5 = "/etc/localtime";
  }
  v6 = *v5;
  if ( !*v5 )
  {
    v6 = 85;
    v5 = &byte_80CAC58;
  }
  v7 = old_tz;
  s1 = &v5[v6 == 58];
  if ( !s1 || !old_tz || (result = strcmp(s1, old_tz)) != 0 )
  {
    if ( !s1 )
      s1 = "/etc/localtime";
    goto LABEL_14;
  }
  return result;
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80CAC58: using guessed type char byte_80CAC58;
// 80F0D50: using guessed type int is_initialized_7800;
// 80F0D60: using guessed type int tz_rules;
// 80F0D78: using guessed type int dword_80F0D78;
// 80F0D80: using guessed type int dword_80F0D80;
// 80F0D98: using guessed type int dword_80F0D98;
// 80F12F0: using guessed type int _use_tzfile;

//----- (080810A0) --------------------------------------------------------
void __usercall _tzname_max(long double a1@<st0>)
{
  bool v2; // zf

  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg ds:tzset_lock, ecx }
  if ( v2 )
  {
    tzset_internal(0, 0, a1);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --tzset_lock )
      L_unlock_1712();
  }
  else
  {
    L_lock_1706(0);
  }
}
// 80F0D4C: using guessed type int tzset_lock;
// 80F12EC: using guessed type int _tzname_cur_max;

//----- (080810F0) --------------------------------------------------------
int __usercall _tz_compute@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)
{
  int result; // eax
  _BOOL4 v7; // eax
  char *v8; // edx

  compute_change((int)&tz_rules, a2[5] + 1900);
  result = compute_change((int)&dword_80F0D80, a2[5] + 1900);
  if ( a3 )
  {
    if ( dword_80F0D78 > dword_80F0D98 )
    {
      v7 = 1;
      if ( dword_80F0D98 <= a1 )
        v7 = dword_80F0D78 <= a1;
    }
    else
    {
      v7 = 0;
      if ( dword_80F0D78 <= a1 )
        v7 = dword_80F0D98 > a1;
    }
    v8 = (&tzname)[v7];
    a2[8] = v7;
    result = dword_80F0D74[8 * v7];
    a2[10] = v8;
    a2[9] = result;
  }
  return result;
}
// 80F0D60: using guessed type int tz_rules;
// 80F0D74: using guessed type int dword_80F0D74[];
// 80F0D78: using guessed type int dword_80F0D78;
// 80F0D80: using guessed type int dword_80F0D80;
// 80F0D98: using guessed type int dword_80F0D98;

//----- (08081190) --------------------------------------------------------
void __usercall tzset(long double a1@<st0>)
{
  bool v2; // zf

  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg ds:tzset_lock, ecx }
  if ( v2 )
  {
    tzset_internal(1, 1, a1);
    if ( !_use_tzfile )
    {
      tzname = (char *)tz_rules;
      off_80EFA2C = (char *)dword_80F0D80;
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --tzset_lock )
      L_unlock_1835();
  }
  else
  {
    L_lock_1819(0);
  }
}
// 80EFA2C: using guessed type char *off_80EFA2C;
// 80F0D4C: using guessed type int tzset_lock;
// 80F0D60: using guessed type int tz_rules;
// 80F0D80: using guessed type int dword_80F0D80;
// 80F12F0: using guessed type int _use_tzfile;

//----- (08081200) --------------------------------------------------------
void __usercall _tz_convert(long double a1@<st0>, int *a2, int a3, int *a4)
{
  int *v4; // ebx
  bool v6; // zf
  int v7; // eax
  int v8; // [esp+28h] [ebp-14h] BYREF
  int v9[4]; // [esp+2Ch] [ebp-10h] BYREF

  v4 = a4;
  if ( a2 )
  {
    _ECX = 1;
    v6 = __readgsdword(0xCu) == 0;
    if ( !v6 )
      __asm { lock }
    __asm { cmpxchg ds:tzset_lock, ecx }
    if ( v6 )
    {
      tzset_internal(a3 != 0 && a4 == (int *)&tmbuf, 1, a1);
      if ( _use_tzfile )
      {
        _tzfile_compute(a1, *a2, a3, &v8, v9, a4);
      }
      else
      {
        if ( _offtime(a2, 0, a4) )
          _tz_compute(*a2, a4, a3);
        else
          v4 = 0;
        v8 = 0;
        v9[0] = 0;
      }
      if ( v4 )
      {
        if ( a3 )
        {
          v7 = v4[9];
        }
        else
        {
          v4[8] = 0;
          v7 = 0;
          v4[10] = (int)"GMT";
          v4[9] = 0;
        }
        if ( _offtime(a2, v7 - v8, v4) )
          *v4 += v9[0];
      }
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --tzset_lock )
        L_unlock_1923();
    }
    else
    {
      L_lock_1862(0);
    }
  }
  else
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
  }
}
// 80F0D4C: using guessed type int tzset_lock;
// 80F12F0: using guessed type int _use_tzfile;
// 8081200: using guessed type int var_10[4];

//----- (08081348) --------------------------------------------------------
void __usercall L_lock_1706(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &tzset_lock);
  JUMPOUT(0x80810C2);
}
// 8081353: control flows out of bounds to 80810C2
// 80F0D4C: using guessed type int tzset_lock;

//----- (08081358) --------------------------------------------------------
void L_unlock_1712()
{
  _lll_unlock_wake_private(&tzset_lock);
  JUMPOUT(0x80810E3);
}
// 8081363: control flows out of bounds to 80810E3
// 80F0D4C: using guessed type int tzset_lock;

//----- (08081368) --------------------------------------------------------
void __usercall L_lock_1819(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &tzset_lock);
  JUMPOUT(0x80811B2);
}
// 8081373: control flows out of bounds to 80811B2
// 80F0D4C: using guessed type int tzset_lock;

//----- (08081378) --------------------------------------------------------
void L_unlock_1835()
{
  _lll_unlock_wake_private(&tzset_lock);
  JUMPOUT(0x80811F6);
}
// 8081383: control flows out of bounds to 80811F6
// 80F0D4C: using guessed type int tzset_lock;

//----- (08081388) --------------------------------------------------------
void __usercall L_lock_1862(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &tzset_lock);
  JUMPOUT(0x8081239);
}
// 8081393: control flows out of bounds to 8081239
// 80F0D4C: using guessed type int tzset_lock;

//----- (08081398) --------------------------------------------------------
void L_unlock_1923()
{
  _lll_unlock_wake_private(&tzset_lock);
  JUMPOUT(0x80812CF);
}
// 80813A3: control flows out of bounds to 80812CF
// 80F0D4C: using guessed type int tzset_lock;

//----- (080813B0) --------------------------------------------------------
int __cdecl _tzfile_read(char *haystack, unsigned int a2, _DWORD *a3)
{
  char *v3; // ebx
  int v4; // esi
  char v5; // dl
  int result; // eax
  char *v7; // eax
  char *v8; // eax
  int v9; // eax
  const char *v10; // edx
  int v11; // edi
  int v12; // ecx
  void *v13; // esp
  _BYTE *v14; // eax
  int *v15; // eax
  int *v16; // ebx
  int v17; // eax
  int v18; // edx
  int v19; // eax
  unsigned int v20; // esi
  unsigned int v21; // edx
  unsigned int v22; // eax
  unsigned int v23; // edx
  unsigned int v24; // edx
  unsigned int v25; // edi
  int v26; // ecx
  unsigned int v27; // eax
  int v28; // eax
  int v29; // edi
  int v30; // eax
  int v31; // edx
  int v32; // ecx
  unsigned __int8 *v33; // edx
  int v34; // esi
  unsigned int v35; // ecx
  int v36; // eax
  unsigned int v37; // eax
  int v38; // esi
  unsigned __int8 *v39; // edx
  unsigned int v40; // eax
  int v41; // esi
  int v42; // eax
  unsigned int v43; // edx
  int i; // esi
  _BYTE *v45; // ecx
  int v46; // eax
  int v47; // esi
  _BYTE *v48; // ecx
  int v49; // eax
  bool v50; // cc
  unsigned int v51; // esi
  unsigned __int32 v52; // edi
  unsigned __int8 *v53; // edx
  int v54; // eax
  unsigned int v55; // eax
  int v56; // edx
  unsigned int v57; // esi
  unsigned __int32 v58; // edi
  unsigned __int8 *v59; // edx
  int v60; // eax
  int v61; // edx
  const char *v62; // eax
  unsigned int v63; // ebx
  int v64; // eax
  int v65; // ebx
  int v66; // eax
  int v67; // esi
  char *v68; // edx
  char *v69; // eax
  int v70; // eax
  _BOOL4 v71; // edx
  int v72; // eax
  int v73; // eax
  int v74; // ecx
  int v75; // edx
  int v76; // ebx
  int v77; // ebx
  int v78; // eax
  int v79; // eax
  int v80; // edi
  unsigned __int8 *v81; // edx
  void *v82; // esp
  int v83; // eax
  int v84; // eax
  char *v85; // [esp+4h] [ebp-E4h]
  char *v86; // [esp+4h] [ebp-E4h]
  _BYTE v87[2]; // [esp+Eh] [ebp-DAh]
  char v88[4]; // [esp+10h] [ebp-D8h] BYREF
  const char *v89; // [esp+14h] [ebp-D4h]
  unsigned int v90; // [esp+18h] [ebp-D0h]
  unsigned __int32 v91; // [esp+1Ch] [ebp-CCh]
  unsigned __int32 v92; // [esp+20h] [ebp-C8h]
  unsigned int v93; // [esp+24h] [ebp-C4h]
  unsigned int v94; // [esp+28h] [ebp-C0h]
  unsigned int v95; // [esp+2Ch] [ebp-BCh]
  __int64 v96[5]; // [esp+3Ch] [ebp-ACh] BYREF
  __int64 v97; // [esp+68h] [ebp-80h]
  int v98; // [esp+84h] [ebp-64h]
  __int64 v99; // [esp+94h] [ebp-54h]
  char s1[20]; // [esp+9Ch] [ebp-4Ch] BYREF
  unsigned int v101; // [esp+B0h] [ebp-38h]
  unsigned int v102; // [esp+B4h] [ebp-34h]
  unsigned int v103; // [esp+B8h] [ebp-30h]
  unsigned int v104; // [esp+BCh] [ebp-2Ch]
  unsigned int v105; // [esp+C0h] [ebp-28h]
  unsigned int v106; // [esp+C4h] [ebp-24h]
  unsigned int v107[8]; // [esp+C8h] [ebp-20h]

  v3 = haystack;
  v4 = _use_tzfile;
  _use_tzfile = 0;
  if ( haystack )
  {
    v5 = *haystack;
    if ( !*haystack )
      goto LABEL_3;
    if ( _libc_enable_secure )
    {
      if ( v5 == 47 )
      {
        LOBYTE(v89) = 47;
        v5 = 47;
        if ( strcmp(haystack, "/etc/localtime") )
        {
          v73 = memcmp(haystack, "/usr/share/zoneinfo", 0x13u);
          v5 = (char)v89;
          if ( v73 )
            goto LABEL_3;
        }
      }
      LOBYTE(v89) = v5;
      v7 = strstr(haystack, &byte_80CAC6D);
      v5 = (char)v89;
      if ( v7 )
        goto LABEL_3;
    }
  }
  else
  {
    v5 = 47;
    v3 = "/etc/localtime";
  }
  if ( v5 != 47 )
  {
    v8 = (char *)getenv("TZDIR");
    if ( v8 && *v8 )
    {
      v89 = v8;
      v9 = strlen(v8);
      v10 = v89;
      v94 = v9;
      v11 = v9 + 1;
    }
    else
    {
      v11 = 20;
      v10 = "/usr/share/zoneinfo";
      v94 = 19;
    }
    v89 = v10;
    v12 = strlen(v3) + 1;
    v13 = alloca(v12 + v11 + 15);
    v85 = (char *)v89;
    v89 = (const char *)v12;
    v14 = mempcpy(v88, v85, v94);
    *v14 = 47;
    v86 = v3;
    v3 = v88;
    memcpy(v14 + 1, v86, (unsigned int)v89);
  }
  if ( v4 )
  {
    if ( !_xstat64(3, (int)v3, (int)v96) && tzfile_ino == v99 )
    {
      result = tzfile_dev ^ LODWORD(v96[0]);
      if ( tzfile_dev == v96[0] && v98 == tzfile_mtime )
        goto LABEL_100;
    }
  }
  v15 = fopen((int)v3, "rce");
  v16 = v15;
  if ( !v15 )
    goto LABEL_3;
  v17 = fileno_unlocked(v15);
  if ( _fxstat64(3, v17, (int)v96) )
    goto LABEL_102;
  free(transitions);
  transitions = 0;
  tzfile_dev = v96[0];
  v18 = HIDWORD(v99);
  LODWORD(tzfile_ino) = v99;
  v19 = v98;
  *v16 |= 0x8000u;
  HIDWORD(tzfile_ino) = v18;
  tzfile_mtime = v19;
  if ( fread_unlocked((int)s1, 0x2Cu, 1, (int)v16) != 1 )
    goto LABEL_102;
  if ( memcmp(s1, "TZif", 4u) )
    goto LABEL_102;
  v20 = _byteswap_ulong(v104);
  v21 = _byteswap_ulong(v105);
  v22 = _byteswap_ulong(v103);
  v94 = _byteswap_ulong(v106);
  v92 = _byteswap_ulong(v102);
  num_transitions = v20;
  num_types = v21;
  num_leaps = v22;
  v91 = _byteswap_ulong(v101);
  if ( v20 > 0x33333332 )
    goto LABEL_102;
  v93 = (5 * v20 + 3) & 0xFFFFFFFC;
  if ( ~v93 >> 3 < v21 )
    goto LABEL_102;
  v90 = 8 * v21;
  v23 = 8 * v21 + v93;
  if ( ~v23 < v94 )
    goto LABEL_102;
  v24 = v94 + v23;
  if ( v24 > 0xFFFFFFFC )
    goto LABEL_102;
  v25 = (v24 + 3) & 0xFFFFFFFC;
  if ( ~v25 >> 3 < v22 )
    goto LABEL_102;
  v26 = 8 * v22;
  v27 = v25 + 8 * v22;
  if ( ~v27 < a2 )
    goto LABEL_102;
  v89 = (const char *)v26;
  v28 = malloc(a2 + v27);
  transitions = v28;
  if ( !v28 )
    goto LABEL_102;
  v29 = v28 + v25;
  type_idxs = v28 + 4 * v20;
  leaps = v29;
  tzspec = 0;
  types = v28 + v93;
  zone_names = (char *)(v90 + v28 + v93);
  if ( a2 )
    *a3 = &v89[v29];
  v30 = fread_unlocked(v28, 5u, v20, (int)v16);
  if ( v30 != num_transitions )
    goto LABEL_102;
  if ( v30 )
  {
    if ( *(unsigned __int8 *)type_idxs < (unsigned int)num_types )
    {
      v31 = 0;
      while ( ++v31 != v30 )
      {
        if ( *(unsigned __int8 *)(type_idxs + v31) >= (unsigned int)num_types )
          goto LABEL_102;
      }
      v32 = transitions;
      do
      {
        *(_DWORD *)(v32 + 4 * v30 - 4) = _byteswap_ulong(*(_DWORD *)(v32 + 4 * v30 - 4));
        --v30;
      }
      while ( v30 );
      goto LABEL_36;
    }
    goto LABEL_102;
  }
  if ( num_types )
  {
LABEL_36:
    v95 = 0;
    do
    {
      v33 = (unsigned __int8 *)v16[1];
      v34 = 0;
      v35 = v16[2];
      do
      {
        if ( (unsigned int)v33 >= v35 )
        {
          v36 = _uflow(v16);
          if ( v36 == -1 )
            goto LABEL_102;
          v33 = (unsigned __int8 *)v16[1];
          v35 = v16[2];
        }
        else
        {
          LOBYTE(v36) = *v33++;
          v16[1] = (int)v33;
        }
        *((_BYTE *)v107 + v34++) = v36;
      }
      while ( v34 != 4 );
      if ( (unsigned int)v33 >= v35 )
      {
        v37 = _uflow(v16);
      }
      else
      {
        v37 = *v33;
        v16[1] = (int)(v33 + 1);
      }
      if ( v37 > 1 )
        goto LABEL_102;
      v38 = 8 * v95;
      *(_BYTE *)(types + 8 * v95 + 4) = v37;
      v39 = (unsigned __int8 *)v16[1];
      if ( (unsigned int)v39 >= v16[2] )
      {
        v40 = _uflow(v16);
      }
      else
      {
        v40 = *v39;
        v16[1] = (int)(v39 + 1);
      }
      if ( v40 > v94 )
        goto LABEL_102;
      v41 = types + v38;
      ++v95;
      *(_BYTE *)(v41 + 5) = v40;
      *(_DWORD *)v41 = _byteswap_ulong(v107[0]);
    }
    while ( num_types > v95 );
  }
  v42 = fread_unlocked((int)zone_names, 1u, v94, (int)v16);
  if ( v42 != v94 )
  {
LABEL_102:
    fclose(v16);
LABEL_3:
    result = free(transitions);
    transitions = 0;
    return result;
  }
  v43 = 0;
  if ( num_leaps )
  {
    do
    {
      for ( i = 0; i != 4; ++i )
      {
        v45 = (_BYTE *)v16[1];
        if ( (unsigned int)v45 >= v16[2] )
        {
          v89 = (const char *)v43;
          v46 = _uflow(v16);
          v43 = (unsigned int)v89;
          if ( v46 == -1 )
            goto LABEL_102;
        }
        else
        {
          LOBYTE(v46) = *v45;
          v16[1] = (int)(v45 + 1);
        }
        *((_BYTE *)v107 + i) = v46;
      }
      v47 = 0;
      v95 = 8 * v43;
      *(_DWORD *)(leaps + 8 * v43) = _byteswap_ulong(v107[0]);
      do
      {
        v48 = (_BYTE *)v16[1];
        if ( (unsigned int)v48 >= v16[2] )
        {
          v89 = (const char *)v43;
          v49 = _uflow(v16);
          v43 = (unsigned int)v89;
          if ( v49 == -1 )
            goto LABEL_102;
        }
        else
        {
          LOBYTE(v49) = *v48;
          v16[1] = (int)(v48 + 1);
        }
        *((_BYTE *)v107 + v47++) = v49;
      }
      while ( v47 != 4 );
      v50 = num_leaps <= ++v43;
      *(_DWORD *)(leaps + v95 + 4) = _byteswap_ulong(v107[0]);
    }
    while ( !v50 );
  }
  v51 = 0;
  if ( v92 )
  {
    v52 = v92;
    do
    {
      v53 = (unsigned __int8 *)v16[1];
      if ( (unsigned int)v53 >= v16[2] )
      {
        v54 = _uflow(v16);
        if ( v54 == -1 )
          goto LABEL_102;
      }
      else
      {
        v54 = *v53;
        v16[1] = (int)(v53 + 1);
      }
      *(_BYTE *)(types + 8 * v51++ + 6) = v54 != 0;
    }
    while ( v51 != v52 );
  }
  v55 = num_types;
  if ( num_types > v51 )
  {
    v56 = types;
    do
      *(_BYTE *)(v56 + 8 * v51++ + 6) = 0;
    while ( v51 < v55 );
  }
  v57 = 0;
  if ( v91 )
  {
    v58 = v91;
    do
    {
      v59 = (unsigned __int8 *)v16[1];
      if ( (unsigned int)v59 >= v16[2] )
      {
        v60 = _uflow(v16);
        if ( v60 == -1 )
          goto LABEL_102;
      }
      else
      {
        v60 = *v59;
        v16[1] = (int)(v59 + 1);
      }
      *(_BYTE *)(types + 8 * v57++ + 7) = v60 != 0;
    }
    while ( v57 != v58 );
    v55 = num_types;
  }
  if ( v57 < v55 )
  {
    v61 = types;
    do
      *(_BYTE *)(v61 + 8 * v57++ + 7) = 0;
    while ( v57 < v55 );
  }
  v62 = (const char *)tzspec;
  if ( s1[4] )
  {
    if ( fread_unlocked((int)s1, 0x2Cu, 1, (int)v16) != 1 )
      goto LABEL_102;
    if ( memcmp(s1, "TZif", 4u) )
      goto LABEL_102;
    v93 = _byteswap_ulong(v102);
    v95 = _byteswap_ulong(v101);
    fseek(
      v16,
      v95
    + _byteswap_ulong(v106)
    + v93
    + 9 * _byteswap_ulong(v104)
    + 6 * _byteswap_ulong(v105)
    + 12 * _byteswap_ulong(v103),
      1u);
    if ( v78 )
      goto LABEL_102;
    ftello(v16);
    if ( v79 < 0 || v97 < v79 + 2 )
      goto LABEL_102;
    v80 = v97 - v79;
    v81 = (unsigned __int8 *)v16[1];
    v82 = alloca(v97 - v79 + 14);
    if ( (unsigned int)v81 >= v16[2] )
    {
      v83 = _uflow(v16);
    }
    else
    {
      v83 = *v81;
      v16[1] = (int)(v81 + 1);
    }
    if ( v83 != 10 )
      goto LABEL_102;
    v89 = (const char *)(v80 - 2);
    v84 = fread_unlocked((int)v88, 1u, v80 - 2, (int)v16);
    if ( v89 != (const char *)v84 )
      goto LABEL_102;
    v87[v80] = 0;
    v62 = _tzstring(v88);
    tzspec = (int)v62;
  }
  if ( v62 && !*v62 )
    tzspec = 0;
  fclose(v16);
  if ( num_types )
  {
    v63 = 0;
    do
    {
      v64 = *(unsigned __int8 *)(types + 8 * v63++ + 5);
      _tzstring(&zone_names[v64]);
    }
    while ( num_types > v63 );
  }
  v65 = num_transitions;
  tzname = 0;
  off_80EFA2C = 0;
  if ( !num_transitions )
    goto LABEL_133;
  do
  {
    --v65;
    v66 = types + 8 * *(unsigned __int8 *)(type_idxs + v65);
    v67 = *(unsigned __int8 *)(v66 + 4);
    if ( !(&tzname)[v67] )
    {
      (&tzname)[v67] = (char *)_tzstring(&zone_names[*(unsigned __int8 *)(v66 + 5)]);
      if ( (&tzname)[1 - v67] )
        break;
    }
  }
  while ( v65 );
  if ( !tzname )
  {
LABEL_133:
    if ( num_types != 1 )
      _assert_fail("num_types == 1", "tzfile.c", 491, "__tzfile_read");
    tzname = (char *)_tzstring(zone_names);
  }
  if ( !off_80EFA2C )
    off_80EFA2C = tzname;
  v68 = zone_names;
  do
  {
    v69 = v68;
    if ( *v68 )
    {
      do
        ++v69;
      while ( *v69 );
      if ( v69 - v68 > (unsigned int)_tzname_cur_max )
        _tzname_cur_max = v69 - v68;
    }
    v68 = v69 + 1;
  }
  while ( &zone_names[v94] > v69 + 1 );
  v70 = num_transitions;
  if ( !num_transitions )
  {
    v71 = 0;
    v72 = *(_DWORD *)types;
    rule_dstoff = v72;
    rule_stdoff = v72;
    goto LABEL_99;
  }
  rule_dstoff = 0;
  v74 = 0;
  rule_stdoff = 0;
  v75 = 0;
  v94 = 0;
  v95 = 0;
  do
  {
    if ( v75 || (v76 = types + 8 * *(unsigned __int8 *)(type_idxs + v70 - 1), *(_BYTE *)(v76 + 4)) )
    {
      if ( !v74 )
      {
        v77 = types + 8 * *(unsigned __int8 *)(type_idxs + v70 - 1);
        if ( !*(_BYTE *)(v77 + 4) )
          goto LABEL_114;
        v94 = *(_DWORD *)v77;
      }
      v74 = 1;
      if ( (_BYTE)v75 )
      {
LABEL_120:
        rule_stdoff = v95;
        rule_dstoff = v94;
        v71 = v95 != v94;
        v72 = v95;
        goto LABEL_99;
      }
    }
    else
    {
      LOBYTE(v75) = 1;
      v95 = *(_DWORD *)v76;
      if ( v74 )
        goto LABEL_120;
    }
LABEL_114:
    --v70;
  }
  while ( v70 );
  rule_stdoff = v95;
  rule_dstoff = v94;
  v72 = v95;
  if ( v74 )
  {
    v71 = v94 != v95;
  }
  else
  {
    v71 = 0;
    rule_dstoff = v95;
  }
LABEL_99:
  result = -v72;
  daylight = v71;
  timezone = result;
LABEL_100:
  _use_tzfile = 1;
  return result;
}
// 8081D63: variable 'v78' is possibly undefined
// 8081D75: variable 'v79' is possibly undefined
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80EFA2C: using guessed type char *off_80EFA2C;
// 80F0D40: using guessed type int timezone;
// 80F0D44: using guessed type int daylight;
// 80F0DA0: using guessed type __int64 tzfile_ino;
// 80F0DA8: using guessed type __int64 tzfile_dev;
// 80F0DB0: using guessed type int tzfile_mtime;
// 80F0DB4: using guessed type int num_transitions;
// 80F0DB8: using guessed type int num_types;
// 80F0DBC: using guessed type int num_leaps;
// 80F0DC0: using guessed type int type_idxs;
// 80F0DC4: using guessed type int types;
// 80F0DCC: using guessed type int leaps;
// 80F0DD0: using guessed type int tzspec;
// 80F0DD4: using guessed type int rule_dstoff;
// 80F0DD8: using guessed type int rule_stdoff;
// 80F12EC: using guessed type int _tzname_cur_max;
// 80F12F0: using guessed type int _use_tzfile;
// 80F1384: using guessed type int transitions;
// 80813B0: using guessed type char anonymous_0[4];

//----- (08081F80) --------------------------------------------------------
char *__cdecl _tzfile_default(char *a1, char *a2, int a3, int a4)
{
  unsigned int v4; // ebx
  char *result; // eax
  _WORD *v6; // eax
  int v7; // esi
  int v8; // edi
  unsigned int v9; // eax
  int v10; // ecx
  int v11; // ebp
  _BYTE *v12; // edx
  unsigned int v13; // ecx
  char *v14; // edx
  unsigned int v15; // [esp+1Ch] [ebp-40h]
  unsigned int v16; // [esp+20h] [ebp-3Ch]
  int v17; // [esp+28h] [ebp-34h]
  int v18; // [esp+2Ch] [ebp-30h]
  int v19[8]; // [esp+3Ch] [ebp-20h] BYREF

  v16 = strlen(a1) + 1;
  v4 = strlen(a2) + 1;
  result = (char *)_tzfile_read("posixrules", v4 + v16, v19);
  if ( _use_tzfile )
  {
    if ( (unsigned int)num_types <= 1 )
    {
      _use_tzfile = 0;
    }
    else
    {
      v6 = mempcpy((_BYTE *)v19[0], a1, v16);
      memcpy(v6, a2, v4);
      result = (char *)v19[0];
      num_types = 2;
      v7 = types;
      zone_names = (char *)v19[0];
      v15 = num_transitions;
      if ( num_transitions )
      {
        v8 = 0;
        v9 = 0;
        v10 = type_idxs;
        v11 = transitions;
        v18 = a4 - rule_dstoff;
        v17 = a3 - rule_stdoff;
        while ( 1 )
        {
          v12 = (_BYTE *)(v7 + 8 * *(unsigned __int8 *)(v10 + v9));
          *(_BYTE *)(v10 + v9) = v12[4];
          if ( v12[7] )
            goto LABEL_7;
          if ( !v8 || v12[6] )
          {
            *(_DWORD *)(v11 + 4 * v9++) += v17;
            v8 = (unsigned __int8)v12[4];
            if ( v9 >= v15 )
            {
LABEL_11:
              result = zone_names;
              break;
            }
          }
          else
          {
            *(_DWORD *)(v11 + 4 * v9) += v18;
LABEL_7:
            ++v9;
            v8 = (unsigned __int8)v12[4];
            if ( v9 >= v15 )
              goto LABEL_11;
          }
        }
      }
      *(_BYTE *)(v7 + 5) = 0;
      *(_BYTE *)(v7 + 4) = 0;
      *(_DWORD *)v7 = a3;
      rule_stdoff = a3;
      *(_DWORD *)(v7 + 8) = a4;
      v13 = (unsigned int)&result[v4 + v16];
      rule_dstoff = a4;
      *(_BYTE *)(v7 + 12) = 1;
      *(_BYTE *)(v7 + 13) = v16;
      tzname = a1;
      off_80EFA2C = a2;
      timezone = -a3;
      do
      {
        v14 = result;
        if ( *result )
        {
          do
            ++v14;
          while ( *v14 );
          if ( _tzname_cur_max < (unsigned int)(v14 - result) )
            _tzname_cur_max = v14 - result;
        }
        result = v14 + 1;
      }
      while ( (unsigned int)(v14 + 1) < v13 );
    }
  }
  return result;
}
// 80EFA2C: using guessed type char *off_80EFA2C;
// 80F0D40: using guessed type int timezone;
// 80F0DB4: using guessed type int num_transitions;
// 80F0DB8: using guessed type int num_types;
// 80F0DC0: using guessed type int type_idxs;
// 80F0DC4: using guessed type int types;
// 80F0DD4: using guessed type int rule_dstoff;
// 80F0DD8: using guessed type int rule_stdoff;
// 80F12EC: using guessed type int _tzname_cur_max;
// 80F12F0: using guessed type int _use_tzfile;
// 80F1384: using guessed type int transitions;
// 8081F80: using guessed type int var_20[8];

//----- (08082160) --------------------------------------------------------
int __usercall _tzfile_compute@<eax>(long double a1@<st0>, int a2, int a3, _DWORD *a4, int *a5, int *a6)
{
  int v6; // ebp
  int v7; // edi
  unsigned int v8; // ecx
  unsigned int v9; // eax
  unsigned int v10; // edx
  unsigned int v11; // edx
  unsigned int v12; // edi
  int v13; // eax
  unsigned int v14; // edx
  int v15; // eax
  int v16; // ebx
  char *v17; // eax
  int v18; // edx
  bool v19; // cf
  int v20; // eax
  int v21; // ebx
  unsigned __int8 v22; // al
  char *v23; // eax
  char *v24; // eax
  int v25; // ebx
  int v26; // eax
  const char *s2; // esi
  int *v28; // edx
  int v29; // eax
  int result; // eax
  int v31; // ecx
  int v32; // esi
  int v33; // ebx
  int *v34; // edx
  int v35; // ebx
  int v36; // esi
  int v37; // edx
  _DWORD *v38; // ebp
  int v39; // ecx
  _DWORD *v40; // ebx
  int v41; // edi
  int v42; // eax
  int v43; // eax
  int v44; // ecx
  char *v45; // edx
  unsigned int v46; // esi
  int v47; // edx
  int v48; // edi
  int v49; // edx
  int v50; // ebp
  char *v51; // eax
  int v52; // [esp+1Ch] [ebp-20h]
  int v53; // [esp+1Ch] [ebp-20h]

  if ( a3 )
  {
    tzname = 0;
    off_80EFA2C = 0;
    v52 = num_transitions;
    if ( num_transitions && *(_DWORD *)transitions <= a2 )
    {
      v6 = num_transitions - 1;
      v7 = *(_DWORD *)(transitions + 4 * (num_transitions - 1));
      if ( a2 >= v7 )
      {
        if ( tzspec )
        {
          _tzset_parse_tz(a1, (_BYTE *)tzspec);
          if ( _offtime(&a2, 0, a6) )
          {
            _tz_compute(a2, a6, 1);
            result = num_leaps;
            if ( (char *)(leaps + 8 * num_leaps) == zone_names )
            {
              if ( num_types != 2 )
                _assert_fail("num_types == 2", "tzfile.c", 696, "__tzfile_compute");
              tzname = (char *)_tzstring((char *)(leaps + 8 * num_leaps));
              v42 = strlen(zone_names);
              off_80EFA2C = (char *)_tzstring(&zone_names[v42 + 1]);
              result = num_leaps;
            }
            goto LABEL_31;
          }
          v52 = num_transitions;
          v6 = num_transitions - 1;
        }
        v12 = v52;
        goto LABEL_17;
      }
      v8 = num_transitions - 1;
      v9 = 0;
      v10 = (v7 - a2) / 15778476;
      if ( num_transitions > v10 )
      {
        v11 = num_transitions - v10;
        v12 = v11 - 1;
        if ( a2 >= *(_DWORD *)(transitions + 4 * (v11 - 1)) )
        {
          v9 = v11 + 9;
          if ( num_transitions <= v11 + 9 || a2 < *(_DWORD *)(transitions + 4 * v9) )
          {
            do
              ++v12;
            while ( a2 >= *(_DWORD *)(transitions + 4 * v12) );
            v6 = v12 - 1;
LABEL_17:
            v15 = types + 8 * *(unsigned __int8 *)(type_idxs + v6);
            v16 = *(unsigned __int8 *)(v15 + 4);
            v17 = (char *)_tzstring(&zone_names[*(unsigned __int8 *)(v15 + 5)]);
            v18 = type_idxs;
            v19 = v12 < num_transitions;
            (&tzname)[v16] = v17;
            if ( v19 )
            {
              do
              {
                v20 = types + 8 * *(unsigned __int8 *)(v18 + v12);
                v21 = *(unsigned __int8 *)(v20 + 4);
                v22 = *(_BYTE *)(v20 + 5);
                if ( !(&tzname)[v21] )
                {
                  v23 = (char *)_tzstring(&zone_names[v22]);
                  v18 = type_idxs;
                  (&tzname)[v21] = v23;
                  if ( (&tzname)[1 - v21] )
                    break;
                }
                ++v12;
              }
              while ( num_transitions > v12 );
            }
            v24 = tzname;
            if ( !tzname )
            {
              v24 = off_80EFA2C;
              tzname = off_80EFA2C;
            }
            v25 = types + 8 * *(unsigned __int8 *)(v18 + v6);
LABEL_25:
            daylight = rule_stdoff != rule_dstoff;
            timezone = -rule_stdoff;
            if ( !v24 )
            {
              if ( num_types != 1 )
                _assert_fail("num_types == 1", "tzfile.c", 790, "__tzfile_compute");
              tzname = (char *)_tzstring(zone_names);
            }
            if ( !off_80EFA2C )
              off_80EFA2C = tzname;
            v26 = *(unsigned __int8 *)(v25 + 4);
            s2 = (&tzname)[v26];
            a6[8] = v26;
            if ( strcmp(&zone_names[*(unsigned __int8 *)(v25 + 5)], s2) )
              _assert_fail(
                "__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (&zone_names[info->idx]) && __builtin_"
                "constant_p (__tzname[tp->tm_isdst]) && (__s1_len = __builtin_strlen (&zone_names[info->idx]), __s2_len ="
                " __builtin_strlen (__tzname[tp->tm_isdst]), (!((size_t)(const void *)((&zone_names[info->idx]) + 1) - (s"
                "ize_t)(const void *)(&zone_names[info->idx]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((__tzn"
                "ame[tp->tm_isdst]) + 1) - (size_t)(const void *)(__tzname[tp->tm_isdst]) == 1) || __s2_len >= 4)) ? __bu"
                "iltin_strcmp (&zone_names[info->idx], __tzname[tp->tm_isdst]) : (__builtin_constant_p (&zone_names[info-"
                ">idx]) && ((size_t)(const void *)((&zone_names[info->idx]) + 1) - (size_t)(const void *)(&zone_names[inf"
                "o->idx]) == 1) && (__s1_len = __builtin_strlen (&zone_names[info->idx]), __s1_len < 4) ? (__builtin_cons"
                "tant_p (__tzname[tp->tm_isdst]) && ((size_t)(const void *)((__tzname[tp->tm_isdst]) + 1) - (size_t)(cons"
                "t void *)(__tzname[tp->tm_isdst]) == 1) ? __builtin_strcmp (&zone_names[info->idx], __tzname[tp->tm_isds"
                "t]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (__tzna"
                "me[tp->tm_isdst]); register int __result = (((__const unsigned char *) (__const char *) (&zone_names[inf"
                "o->idx]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__"
                "const char *) (&zone_names[info->idx]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = ("
                "((__const unsigned char *) (__const char *) (&zone_names[info->idx]))[2] - __s2[2]); if (__s1_len > 2 &&"
                " __result == 0) __result = (((__const unsigned char *) (__const char *) (&zone_names[info->idx]))[3] - _"
                "_s2[3]); } } __result; }))) : (__builtin_constant_p (__tzname[tp->tm_isdst]) && ((size_t)(const void *)("
                "(__tzname[tp->tm_isdst]) + 1) - (size_t)(const void *)(__tzname[tp->tm_isdst]) == 1) && (__s2_len = __bu"
                "iltin_strlen (__tzname[tp->tm_isdst]), __s2_len < 4) ? (__builtin_constant_p (&zone_names[info->idx]) &&"
                " ((size_t)(const void *)((&zone_names[info->idx]) + 1) - (size_t)(const void *)(&zone_names[info->idx]) "
                "== 1) ? __builtin_strcmp (&zone_names[info->idx], __tzname[tp->tm_isdst]) : (__extension__ ({ __const un"
                "signed char *__s1 = (__const unsigned char *) (__const char *) (&zone_names[info->idx]); register int __"
                "result = __s1[0] - ((__const unsigned char *) (__const char *) (__tzname[tp->tm_isdst]))[0]; if (__s2_le"
                "n > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (__tzname[tp"
                "->tm_isdst]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *)"
                " (__const char *) (__tzname[tp->tm_isdst]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] "
                "- ((__const unsigned char *) (__const char *) (__tzname[tp->tm_isdst]))[3]); } } __result; }))) : __buil"
                "tin_strcmp (&zone_names[info->idx], __tzname[tp->tm_isdst])))); }) == 0",
                "tzfile.c",
                797,
                "__tzfile_compute");
            v28 = a6;
            v29 = *(_DWORD *)v25;
            a6[10] = (int)s2;
            v28[9] = v29;
            goto LABEL_30;
          }
        }
        else if ( v12 <= 9 || (v8 = v11 - 11, a2 >= *(_DWORD *)(transitions + 4 * (v11 - 11))) )
        {
          v6 = v11 - 2;
          v13 = v11 - 2;
          if ( a2 < *(_DWORD *)(transitions + 4 * (v11 - 2)) )
          {
            do
            {
              v12 = v13--;
              v6 = v13;
            }
            while ( a2 < *(_DWORD *)(transitions + 4 * v12 - 4) );
          }
          goto LABEL_17;
        }
      }
      while ( v8 > v9 + 1 )
      {
        while ( 1 )
        {
          v14 = (v8 + v9) >> 1;
          if ( a2 >= *(_DWORD *)(transitions + 4 * v14) )
            break;
          v8 = (v8 + v9) >> 1;
          if ( v14 <= v9 + 1 )
            goto LABEL_16;
        }
        v9 = (v8 + v9) >> 1;
      }
LABEL_16:
      v6 = v8 - 1;
      v12 = v8;
      goto LABEL_17;
    }
    if ( !num_types )
    {
      v47 = types;
      v48 = 0;
      v46 = 0;
      goto LABEL_74;
    }
    v43 = types;
    v44 = types;
    if ( *(_BYTE *)(types + 4) )
    {
      v45 = 0;
      v46 = 0;
      while ( 1 )
      {
        if ( !v45 )
        {
          off_80EFA2C = (char *)_tzstring(&zone_names[*(unsigned __int8 *)(v44 + 5)]);
          v43 = types;
        }
        ++v46;
        v47 = v43;
        if ( num_types <= v46 )
          break;
        v44 = v43 + 8 * v46;
        if ( !*(_BYTE *)(v44 + 4) )
          break;
        v45 = off_80EFA2C;
      }
      if ( num_types == v46 )
      {
        v48 = 0;
        v46 = 0;
        goto LABEL_74;
      }
      v48 = 8 * v46;
    }
    else
    {
      v48 = 0;
      v46 = 0;
    }
    v47 = v43;
LABEL_74:
    v24 = (char *)_tzstring(&zone_names[*(unsigned __int8 *)(v47 + v48 + 5)]);
    tzname = v24;
    if ( off_80EFA2C || v46 >= num_types )
    {
      v25 = v48 + types;
    }
    else
    {
      v25 = types + v48;
      v49 = types + 8 * v46 + 8;
      if ( *(_BYTE *)(types + v48 + 4) )
      {
LABEL_81:
        v51 = (char *)_tzstring(&zone_names[*(unsigned __int8 *)(v25 + 5)]);
        v25 = v48 + types;
        off_80EFA2C = v51;
        v24 = tzname;
      }
      else
      {
        while ( ++v46 < num_types )
        {
          v50 = v49;
          v49 += 8;
          if ( *(_BYTE *)(v49 - 4) )
          {
            v25 = v50;
            goto LABEL_81;
          }
        }
      }
    }
    goto LABEL_25;
  }
LABEL_30:
  result = num_leaps;
LABEL_31:
  v31 = leaps;
  v32 = a2;
  *a4 = 0;
  v33 = v31 + 8 * result - 8;
  *a5 = 0;
  while ( result )
  {
    v34 = (int *)v33;
    v33 -= 8;
    --result;
    if ( *(_DWORD *)(v33 + 8) <= v32 )
    {
      *a4 = v34[1];
      v35 = *v34;
      if ( v32 == *v34 )
      {
        v36 = v34[1];
        if ( result || v36 <= 0 )
        {
          v37 = result - 1;
          v38 = (_DWORD *)(v31 + 8 * (result - 1));
          v53 = v38[1];
          if ( v53 < v36 )
          {
            *a5 = 1;
            if ( result )
            {
              if ( *v38 + 1 == v35 && v53 + 1 == v36 )
              {
                result = v31 + 8 * result - 4;
                v39 = 2;
                while ( 1 )
                {
                  v41 = v39;
                  if ( !v37 || (v40 = (_DWORD *)result, *(_DWORD *)(result - 4) != *(_DWORD *)(result - 12) + 1) )
                  {
                    *a5 = v39;
                    return result;
                  }
                  ++v39;
                  result -= 8;
                  if ( *v40 != *(v40 - 2) + 1 )
                    break;
                  --v37;
                }
                result = (int)a5;
                *a5 = v41;
              }
            }
          }
        }
        else
        {
          *a5 = 1;
        }
      }
      return result;
    }
  }
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EFA2C: using guessed type char *off_80EFA2C;
// 80F0D40: using guessed type int timezone;
// 80F0D44: using guessed type int daylight;
// 80F0DB4: using guessed type int num_transitions;
// 80F0DB8: using guessed type int num_types;
// 80F0DBC: using guessed type int num_leaps;
// 80F0DC0: using guessed type int type_idxs;
// 80F0DC4: using guessed type int types;
// 80F0DCC: using guessed type int leaps;
// 80F0DD0: using guessed type int tzspec;
// 80F0DD4: using guessed type int rule_dstoff;
// 80F0DD8: using guessed type int rule_stdoff;
// 80F1384: using guessed type int transitions;

//----- (08082720) --------------------------------------------------------
int __usercall _strftime_internal@<eax>(
        char *a1@<eax>,
        int a2@<edx>,
        unsigned __int8 *a3@<ecx>,
        long double a4@<st0>,
        signed int *a5,
        _BYTE *a6,
        _DWORD *a7)
{
  unsigned __int8 v7; // dl
  char *v8; // ebx
  char *v9; // esi
  char *v10; // edi
  int v11; // edi
  char v12; // cl
  int v13; // eax
  int v14; // ebp
  char v15; // al
  char *v16; // edi
  int v18; // edx
  char *v19; // eax
  int v20; // edx
  signed int v21; // eax
  signed int n; // ebp
  unsigned int v23; // eax
  int v24; // edx
  int v25; // ecx
  int v26; // edi
  int v27; // eax
  int v28; // edx
  signed int v29; // ebp
  signed int v30; // eax
  int v31; // eax
  int v32; // edi
  int v33; // eax
  int v34; // eax
  signed int v35; // eax
  signed int v36; // ebp
  int v37; // edx
  unsigned __int8 *v38; // eax
  unsigned __int8 *v39; // edi
  int v40; // ecx
  signed int v41; // edi
  unsigned int v42; // ecx
  char *v43; // edi
  signed int v44; // edx
  unsigned int v45; // eax
  char *v46; // ecx
  signed int v47; // eax
  signed int v48; // ebp
  char *v49; // eax
  int v50; // eax
  _BYTE *v51; // edi
  int v52; // eax
  signed int v53; // ebp
  signed int v54; // eax
  int v55; // eax
  int v56; // ecx
  int v57; // eax
  _BOOL4 v58; // edx
  int v59; // eax
  int v60; // eax
  unsigned int v61; // edi
  int v62; // ecx
  signed int v63; // eax
  signed int v64; // ebp
  unsigned int v65; // eax
  int v66; // ecx
  int v67; // edx
  int v68; // eax
  int v69; // eax
  signed int v70; // ebp
  signed int v71; // eax
  int v72; // eax
  int v73; // ecx
  int v74; // ecx
  int v75; // eax
  const char *v76; // eax
  int v77; // ecx
  int v78; // ecx
  int v79; // ecx
  int v80; // ecx
  int v81; // ecx
  int v82; // eax
  int v83; // eax
  signed int v84; // ebp
  signed int v85; // eax
  int v86; // eax
  signed int v87; // eax
  signed int v88; // ebp
  int v89; // edi
  signed int v90; // eax
  signed int v91; // ebp
  char v92; // al
  int v93; // edi
  int v94; // eax
  int v95; // edx
  int v96; // ecx
  int v97; // edx
  int v98; // ecx
  signed int v99; // ecx
  int v100; // edx
  int v101; // ecx
  int v102; // ecx
  int v103; // ecx
  int v104; // ecx
  int v105; // eax
  int v106; // eax
  signed int v107; // ebp
  signed int v108; // eax
  int v109; // eax
  int v110; // ecx
  int v111; // ecx
  int v112; // edx
  int v113; // eax
  int v114; // edi
  int v115; // ecx
  signed int v116; // eax
  signed int v117; // ebp
  _BYTE *alt_digit; // eax
  int v119; // eax
  _BYTE *v120; // edx
  signed int v121; // eax
  signed int v122; // ebp
  unsigned int v123; // eax
  int v124; // eax
  bool v125; // cc
  int v126; // edi
  int v127; // eax
  unsigned int v128; // eax
  int v129; // ecx
  int v130; // ecx
  int v131; // eax
  _DWORD *v132; // eax
  int v133; // ecx
  _DWORD *v134; // eax
  _DWORD *era_entry; // eax
  signed int v136; // eax
  signed int v137; // ebp
  int v138; // ecx
  char *s; // [esp+0h] [ebp-ACh]
  char *sa; // [esp+0h] [ebp-ACh]
  char *sb; // [esp+0h] [ebp-ACh]
  char *sg; // [esp+0h] [ebp-ACh]
  char *sh; // [esp+0h] [ebp-ACh]
  char *si; // [esp+0h] [ebp-ACh]
  char *sj; // [esp+0h] [ebp-ACh]
  char *sc; // [esp+0h] [ebp-ACh]
  char *sd; // [esp+0h] [ebp-ACh]
  char *sk; // [esp+0h] [ebp-ACh]
  char *se; // [esp+0h] [ebp-ACh]
  char *sf; // [esp+0h] [ebp-ACh]
  char *sl; // [esp+0h] [ebp-ACh]
  int c; // [esp+4h] [ebp-A8h]
  int ca; // [esp+4h] [ebp-A8h]
  int cb; // [esp+4h] [ebp-A8h]
  int cc; // [esp+4h] [ebp-A8h]
  int cd; // [esp+4h] [ebp-A8h]
  int ce; // [esp+4h] [ebp-A8h]
  int cf; // [esp+4h] [ebp-A8h]
  int cg; // [esp+4h] [ebp-A8h]
  int ch; // [esp+4h] [ebp-A8h]
  int v161; // [esp+10h] [ebp-9Ch]
  signed int v162; // [esp+10h] [ebp-9Ch]
  _BOOL4 v163; // [esp+10h] [ebp-9Ch]
  _BOOL4 v164; // [esp+10h] [ebp-9Ch]
  _BYTE *v165; // [esp+10h] [ebp-9Ch]
  int v166; // [esp+14h] [ebp-98h]
  int v167; // [esp+18h] [ebp-94h]
  unsigned int v168; // [esp+1Ch] [ebp-90h]
  int v169; // [esp+1Ch] [ebp-90h]
  int v170; // [esp+1Ch] [ebp-90h]
  unsigned int v171; // [esp+1Ch] [ebp-90h]
  unsigned int v172; // [esp+1Ch] [ebp-90h]
  int v173; // [esp+1Ch] [ebp-90h]
  int v174; // [esp+1Ch] [ebp-90h]
  int v175; // [esp+20h] [ebp-8Ch]
  unsigned int v176; // [esp+20h] [ebp-8Ch]
  int v177; // [esp+20h] [ebp-8Ch]
  const char *v178; // [esp+20h] [ebp-8Ch]
  unsigned int v179; // [esp+20h] [ebp-8Ch]
  char *v180; // [esp+20h] [ebp-8Ch]
  unsigned int v181; // [esp+20h] [ebp-8Ch]
  int v183; // [esp+28h] [ebp-84h]
  char *v184; // [esp+28h] [ebp-84h]
  int v185; // [esp+2Ch] [ebp-80h]
  int v186; // [esp+2Ch] [ebp-80h]
  int v187; // [esp+2Ch] [ebp-80h]
  int v188; // [esp+2Ch] [ebp-80h]
  int v189; // [esp+2Ch] [ebp-80h]
  int v190; // [esp+2Ch] [ebp-80h]
  int v191; // [esp+30h] [ebp-7Ch]
  int v192; // [esp+30h] [ebp-7Ch]
  _DWORD *v193; // [esp+34h] [ebp-78h]
  char *v194; // [esp+38h] [ebp-74h]
  int v195; // [esp+3Ch] [ebp-70h]
  signed int v196; // [esp+3Ch] [ebp-70h]
  _DWORD *v197; // [esp+3Ch] [ebp-70h]
  signed int v198; // [esp+40h] [ebp-6Ch]
  int v199; // [esp+44h] [ebp-68h]
  signed int v200; // [esp+48h] [ebp-64h]
  signed int v201; // [esp+4Ch] [ebp-60h]
  int v202[14]; // [esp+58h] [ebp-54h] BYREF
  char v203[28]; // [esp+90h] [ebp-1Ch] BYREF

  v193 = (_DWORD *)a7[2];
  v191 = a5[2];
  v194 = (char *)a5[10];
  if ( v191 <= 12 )
  {
    v18 = 12;
    if ( v191 )
      v18 = a5[2];
    v192 = v18;
  }
  else
  {
    v192 = v191 - 12;
  }
  v7 = *a3;
  if ( !*a3 )
  {
    v9 = a1;
    v167 = 0;
LABEL_59:
    if ( v9 && a2 )
      *v9 = 0;
    return v167;
  }
  v8 = (char *)a3;
  v9 = a1;
  v167 = 0;
  while ( 2 )
  {
    while ( v7 != 37 )
    {
      if ( (unsigned int)(a2 - v167) <= 1 )
        goto LABEL_33;
      if ( v9 )
        *v9++ = v7;
      ++v167;
      v10 = v8;
LABEL_9:
      v7 = v10[1];
      v8 = v10 + 1;
      if ( !v7 )
        goto LABEL_59;
    }
    v11 = 0;
    v185 = 0;
    v183 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v12 = *++v8;
        if ( *v8 == 48 )
          goto LABEL_25;
        if ( v12 > 48 )
          break;
        if ( v12 == 35 )
        {
          v11 = 1;
        }
        else
        {
          if ( v12 != 45 )
            goto LABEL_16;
LABEL_25:
          v183 = v12;
        }
      }
      if ( v12 != 94 )
        break;
      v185 = 1;
    }
    if ( v12 == 95 )
      goto LABEL_25;
LABEL_16:
    v13 = v12;
    v14 = -1;
    if ( (unsigned int)(v12 - 48) <= 9 )
    {
      v14 = 0;
      do
      {
        if ( v14 <= 214748364 )
        {
          v15 = *v8;
          if ( v14 == 214748364 && v15 > 55 )
            v14 = 0x7FFFFFFF;
          else
            v14 = v15 + 10 * v14 - 48;
        }
        else
        {
          v14 = 0x7FFFFFFF;
        }
        v12 = *++v8;
        v13 = *v8;
      }
      while ( (unsigned int)(v13 - 48) <= 9 );
    }
    if ( v12 == 69 || v12 == 79 )
    {
      v12 = *++v8;
      v175 = v13;
    }
    else
    {
      v175 = 0;
    }
    switch ( v12 )
    {
      case 0:
        v12 = *--v8;
        goto LABEL_29;
      case 37:
        v16 = v8;
        v168 = 1;
        if ( v175 )
          goto LABEL_46;
        v90 = 0;
        v91 = v14 - 1;
        if ( v91 >= 0 )
          v90 = v91;
        v89 = v90 + 1;
        if ( v90 + 1 >= (unsigned int)(a2 - v167) )
          goto LABEL_33;
        if ( v9 )
        {
          v92 = 37;
          if ( v91 > 0 )
          {
            sd = v9;
            v9 += v91;
            if ( v183 == 48 )
              memset(sd, 48, v91);
            else
              memset(sd, 32, v91);
            v92 = *v8;
          }
          *v9++ = v92;
        }
        goto LABEL_271;
      case 65:
        if ( v175 )
          goto LABEL_42;
        v82 = 1;
        if ( !v11 )
          v82 = v185;
        v190 = v82;
        v51 = (_BYTE *)v193[(unsigned __int16)(a5[6] + 7) + 9];
        v83 = strlen(v51);
        v84 = v14 - v83;
        v169 = v83;
        v85 = 0;
        if ( v84 >= 0 )
          v85 = v84;
        v177 = v169 + v85;
        if ( v169 + v85 >= (unsigned int)(a2 - v167) )
          goto LABEL_33;
        if ( !v9 )
          goto LABEL_82;
        if ( v84 > 0 )
        {
          if ( v183 == 48 )
            cd = 48;
          else
            cd = 32;
          sj = v9;
          v9 += v84;
          memset(sj, cd, v84);
          v51 = (_BYTE *)v193[(unsigned __int16)(a5[6] + 7) + 9];
        }
        if ( !v190 )
          goto LABEL_398;
        if ( v169 )
        {
          v86 = v169;
          do
          {
            v9[v86 - 1] = *(_DWORD *)(a7[15] + 4 * (unsigned __int8)v51[v86 - 1]);
            --v86;
          }
          while ( v86 );
        }
        goto LABEL_81;
      case 66:
        if ( v175 )
          goto LABEL_42;
        v68 = 1;
        if ( !v11 )
          v68 = v185;
        v189 = v68;
        v51 = (_BYTE *)v193[(unsigned __int16)(a5[4] + 26) + 9];
        v69 = strlen(v51);
        v70 = v14 - v69;
        v169 = v69;
        v71 = 0;
        if ( v70 >= 0 )
          v71 = v70;
        v177 = v169 + v71;
        if ( v169 + v71 >= (unsigned int)(a2 - v167) )
          goto LABEL_33;
        if ( !v9 )
          goto LABEL_82;
        if ( v70 > 0 )
        {
          if ( v183 == 48 )
            cc = 48;
          else
            cc = 32;
          si = v9;
          v9 += v70;
          memset(si, cc, v70);
          v51 = (_BYTE *)v193[(unsigned __int16)(a5[4] + 26) + 9];
        }
        if ( !v189 )
          goto LABEL_398;
        if ( v169 )
        {
          v72 = v169;
          do
          {
            v9[v72 - 1] = *(_DWORD *)(a7[15] + 4 * (unsigned __int8)v51[v72 - 1]);
            --v72;
          }
          while ( v72 );
        }
        goto LABEL_81;
      case 67:
        if ( v175 != 69 || (era_entry = nl_get_era_entry(a5, v193), (v197 = era_entry) == 0) )
        {
          v67 = 1;
          if ( v14 > 0 )
            v67 = v14;
          v171 = v67;
          v41 = (a5[5] + 1900) / 100 - ((unsigned int)((a5[5] + 1900) % 100) >> 31);
          goto LABEL_104;
        }
        v51 = (_BYTE *)era_entry[8];
        v169 = strlen(v51);
        v136 = 0;
        v137 = v14 - v169;
        if ( v137 >= 0 )
          v136 = v137;
        v177 = v169 + v136;
        if ( v169 + v136 < (unsigned int)(a2 - v167) )
        {
          if ( v9 )
          {
            if ( v137 > 0 )
            {
              if ( v183 == 48 )
                ch = 48;
              else
                ch = 32;
              sl = v9;
              v9 += v137;
              memset(sl, ch, v137);
              v51 = (_BYTE *)v197[8];
            }
            if ( v185 )
            {
              if ( v169 )
              {
                v138 = v169;
                do
                {
                  v9[v138 - 1] = *(_DWORD *)(a7[15] + 4 * (unsigned __int8)v51[v138 - 1]);
                  --v138;
                }
                while ( v138 );
              }
            }
            else
            {
LABEL_398:
              memcpy(v9, v51, v169);
            }
LABEL_81:
            v9 += v169;
          }
LABEL_82:
          v10 = v8;
          v167 += v177;
          goto LABEL_9;
        }
        goto LABEL_33;
      case 68:
        v16 = v8;
        if ( v175 )
          goto LABEL_43;
        v178 = "%m/%d/%y";
        v34 = _strftime_internal("%m/%d/%y", -1, a5, a6, a7);
        goto LABEL_86;
      case 70:
        v16 = v8;
        if ( v175 )
          goto LABEL_43;
        v178 = "%Y-%m-%d";
        v34 = _strftime_internal("%Y-%m-%d", -1, a5, a6, a7);
        goto LABEL_86;
      case 71:
      case 86:
      case 103:
        if ( v175 == 69 )
          goto LABEL_42;
        v201 = a5[5];
        v200 = a5[6];
        v198 = a5[7];
        v199 = v200 - 382 + 7 * ((v198 - v200 + 382) / 7) + 3;
        if ( v199 < 0 )
        {
          v196 = v201 + 1899;
          v131 = 365;
          if ( (((_BYTE)v201 + 107) & 3) == 0 )
          {
            v131 = 366;
            if ( v196 == 100 * (v196 / 100) )
              v131 = 366 - (v201 + 1899 != 400 * (v196 / 400));
          }
          v199 = v200 - 382 + 7 * ((v198 + v131 - v200 + 382) / 7) + 3;
        }
        else
        {
          v196 = v201 + 1900;
          v113 = -365;
          if ( (((_BYTE)v201 + 108) & 3) == 0 )
          {
            v113 = -366;
            if ( v196 == 100 * (v196 / 100) )
              v113 = -(v201 + 1900 == 400 * (v196 / 400)) - 365;
          }
          v114 = 7 * ((v198 + v113 - v200 + 382) / 7);
          if ( v200 - 382 + v114 + 3 >= 0 )
          {
            v199 = v200 - 382 + v114 + 3;
            v196 = v201 + 1901;
          }
        }
        if ( v12 == 71 )
        {
          v130 = 1;
          v41 = v196;
          if ( v14 > 0 )
            v130 = v14;
          v171 = v130;
          goto LABEL_104;
        }
        if ( v12 != 103 )
        {
          v115 = 2;
          if ( v14 >= 2 )
            v115 = v14;
          v171 = v115;
          v41 = v199 / 7 + 1;
          goto LABEL_104;
        }
        v129 = 2;
        if ( v14 >= 2 )
          v129 = v14;
        v171 = v129;
        v99 = v196;
        v100 = 100 * (v196 / 100);
        goto LABEL_301;
      case 72:
        if ( v175 == 69 )
          goto LABEL_42;
        v81 = 2;
        if ( v14 >= 2 )
          v81 = v14;
        v171 = v81;
        v41 = a5[2];
        goto LABEL_104;
      case 73:
        if ( v175 == 69 )
          goto LABEL_42;
        v80 = 2;
        v41 = v192;
        if ( v14 >= 2 )
          v80 = v14;
        v171 = v80;
        goto LABEL_104;
      case 77:
        if ( v175 == 69 )
          goto LABEL_42;
        v79 = 2;
        if ( v14 >= 2 )
          v79 = v14;
        v171 = v79;
        v41 = a5[1];
        goto LABEL_104;
      case 80:
        v24 = 1;
        goto LABEL_65;
      case 82:
        v178 = "%H:%M";
        v34 = _strftime_internal("%H:%M", -1, a5, a6, a7);
        goto LABEL_86;
      case 83:
        if ( v175 == 69 )
          goto LABEL_42;
        v78 = 2;
        if ( v14 >= 2 )
          v78 = v14;
        v171 = v78;
        v41 = *a5;
        goto LABEL_104;
      case 84:
        v178 = "%H:%M:%S";
        goto LABEL_85;
      case 85:
        if ( v175 == 69 )
          goto LABEL_42;
        v77 = 2;
        if ( v14 >= 2 )
          v77 = v14;
        v171 = v77;
        v41 = (a5[7] - a5[6] + 7) / 7;
        goto LABEL_104;
      case 87:
        if ( v175 == 69 )
          goto LABEL_42;
        v40 = 2;
        if ( v14 >= 2 )
          v40 = v14;
        v171 = v40;
        v41 = (7 * ((a5[6] + 6) / 7) - (a5[6] + 6) + a5[7] + 7) / 7;
        goto LABEL_104;
      case 88:
        if ( v175 == 79 )
          goto LABEL_42;
        if ( v175 == 69 )
        {
          v178 = (const char *)v193[58];
          if ( *v178 )
            goto LABEL_85;
        }
        v178 = (const char *)v193[51];
        v34 = _strftime_internal(v178, -1, a5, a6, a7);
        goto LABEL_86;
      case 89:
        if ( v175 == 69 )
        {
          v134 = nl_get_era_entry(a5, v193);
          if ( v134 )
          {
            v178 = (const char *)v134[9];
            v34 = _strftime_internal(v178, -1, a5, a6, a7);
LABEL_86:
            v170 = v34;
            v35 = 0;
            v36 = v14 - v170;
            if ( v36 >= 0 )
              v35 = v36;
            v37 = a2 - v167;
            v195 = v170 + v35;
            if ( v170 + v35 < (unsigned int)(a2 - v167) )
            {
              v38 = 0;
              if ( v9 )
              {
                v39 = (unsigned __int8 *)v9;
                if ( v36 > 0 )
                {
                  if ( v183 == 48 )
                    c = 48;
                  else
                    c = 32;
                  v39 = (unsigned __int8 *)&v9[v36];
                  memset(v9, c, v36);
                  v37 = a2 - v167;
                }
                _strftime_internal(v178, v37, a5, a6, a7);
                v38 = &v39[v170];
              }
              v167 += v195;
              if ( v185 && v38 > (unsigned __int8 *)v9 )
              {
                do
                {
                  *v9 = *(_DWORD *)(a7[15] + 4 * (unsigned __int8)*v9);
                  ++v9;
                }
                while ( v9 != (char *)v38 );
LABEL_98:
                v10 = v8;
              }
              else
              {
                v10 = v8;
                v9 = (char *)v38;
              }
              goto LABEL_9;
            }
          }
          else
          {
LABEL_153:
            v56 = 1;
            if ( v14 > 0 )
              v56 = v14;
            v171 = v56;
            v41 = a5[5] + 1900;
LABEL_104:
            if ( v41 >= 0
              && v175 == 79
              && (alt_digit = (_BYTE *)nl_get_alt_digit(v41, (int)v193)) != 0
              && (v165 = alt_digit, v119 = strlen(alt_digit), v120 = v165, (v181 = v119) != 0) )
            {
              v121 = 0;
              v122 = v14 - v181;
              if ( v122 >= 0 )
                v121 = v122;
              v89 = v121 + v181;
              if ( v121 + v181 < a2 - v167 )
              {
                if ( v9 )
                {
                  if ( v122 > 0 )
                  {
                    sf = v9;
                    v9 += v122;
                    if ( v183 == 48 )
                      memset(sf, 48, v122);
                    else
                      memset(sf, 32, v122);
                    v120 = v165;
                  }
                  v123 = v181;
                  if ( v185 )
                  {
                    do
                    {
                      v9[v123 - 1] = *(_DWORD *)(a7[15] + 4 * (unsigned __int8)v120[v123 - 1]);
                      --v123;
                    }
                    while ( v123 );
                  }
                  else
                  {
                    memcpy(v9, v120, v181);
                  }
                  v9 += v181;
                }
LABEL_271:
                v167 += v89;
                v10 = v8;
                goto LABEL_9;
              }
            }
            else
            {
LABEL_105:
              v179 = (unsigned int)v41 >> 31;
              v42 = -v41;
              if ( v41 >= 0 )
                v42 = v41;
              v43 = v203;
              do
              {
                *--v43 = v42 % 0xA + 48;
                v42 /= 0xAu;
              }
              while ( v42 );
LABEL_109:
              if ( v179 )
                *--v43 = 45;
              if ( v183 != 45 )
              {
                v44 = v171 + v43 - v203;
                if ( v44 > 0 )
                {
                  v45 = a2 - v167;
                  if ( v183 == 95 )
                  {
                    if ( v44 >= v45 )
                      goto LABEL_33;
                    if ( v9 )
                    {
                      memset(v9, 32, v171 + v43 - v203);
                      v44 = v171 + v43 - v203;
                      v9 += v44;
                    }
                    v124 = v14 - v44;
                    v167 += v44;
                    v125 = v14 <= v44;
                    v14 = 0;
                    if ( !v125 )
                      v14 = v124;
                  }
                  else
                  {
                    if ( v171 >= v45 )
                      goto LABEL_33;
                    if ( v179 )
                    {
                      ++v43;
                      if ( v9 )
                        *v9++ = 45;
                      ++v167;
                    }
                    if ( v9 )
                    {
                      v162 = v44;
                      memset(v9, 48, v44);
                      v44 = v162;
                      v9 += v162;
                    }
                    v167 += v44;
                    v14 = 0;
                  }
                }
              }
              v46 = (char *)(v203 - v43);
              v47 = 0;
              v48 = v14 - (v203 - v43);
              if ( v48 >= 0 )
                v47 = v48;
              v180 = &v46[v47];
              v172 = v203 - v43;
              if ( (unsigned int)&v46[v47] < a2 - v167 )
              {
                if ( v9 )
                {
                  if ( v48 > 0 )
                  {
                    sb = v9;
                    v9 += v48;
                    if ( v183 == 48 )
                      memset(sb, 48, v48);
                    else
                      memset(sb, 32, v48);
                  }
                  if ( v185 )
                  {
                    if ( v172 )
                    {
                      v49 = (char *)(v203 - v43);
                      do
                      {
                        v49[(_DWORD)v9 - 1] = *(_DWORD *)(a7[15] + 4 * (unsigned __int8)v49[(_DWORD)v43 - 1]);
                        --v49;
                      }
                      while ( v49 );
                    }
                  }
                  else
                  {
                    memcpy(v9, v43, v172);
                  }
                  v9 += v172;
                }
                v10 = v8;
                v167 += (int)v180;
                goto LABEL_9;
              }
            }
          }
        }
        else
        {
          if ( v175 != 79 )
            goto LABEL_153;
LABEL_42:
          v16 = v8;
LABEL_43:
          v19 = v8 - 1;
          v20 = 1;
          do
          {
            v8 = v19--;
            ++v20;
          }
          while ( v19[1] != 37 );
          v168 = v20;
LABEL_46:
          v21 = 0;
          n = v14 - v168;
          if ( n >= 0 )
            v21 = n;
          v176 = v168 + v21;
          if ( v168 + v21 < a2 - v167 )
          {
            if ( v9 )
            {
              if ( n > 0 )
              {
                s = v9;
                v9 += n;
                if ( v183 == 48 )
                  memset(s, 48, n);
                else
                  memset(s, 32, n);
              }
              if ( v185 )
              {
                if ( v168 )
                {
                  v23 = v168;
                  do
                  {
                    v9[v23 - 1] = *(_DWORD *)(a7[15] + 4 * (unsigned __int8)v8[v23 - 1]);
                    --v23;
                  }
                  while ( v23 );
                }
                v9 += v168;
              }
              else
              {
                memcpy(v9, v8, v168);
                v9 += v168;
              }
            }
            v7 = v16[1];
            v8 = v16 + 1;
            v167 += v176;
            if ( !v7 )
              goto LABEL_59;
            continue;
          }
        }
LABEL_33:
        v167 = 0;
        break;
      case 90:
        v57 = 0;
        v58 = v11 != 0;
        if ( !v11 )
          v57 = v185;
        v188 = v57;
        if ( v194 && *v194 )
          goto LABEL_165;
        v59 = a5[8];
        if ( v59 >= 0 )
        {
          if ( !*a6 )
          {
            tzset(a4);
            v58 = v11 != 0;
            *a6 = 1;
            v59 = a5[8];
          }
          v194 = (&tzname)[v59];
        }
        if ( v194 )
        {
LABEL_165:
          v163 = v58;
          v60 = strlen(v194);
          v58 = v163;
          v61 = v60;
          v62 = v60;
        }
        else
        {
          v62 = 0;
          v61 = 0;
          v194 = (char *)&unk_80C86D9;
        }
        v63 = 0;
        v64 = v14 - v62;
        if ( v64 >= 0 )
          v63 = v64;
        v173 = v62 + v63;
        if ( v62 + v63 >= (unsigned int)(a2 - v167) )
          goto LABEL_33;
        if ( !v9 )
          goto LABEL_180;
        if ( v64 > 0 )
        {
          if ( v183 == 48 )
            cb = 48;
          else
            cb = 32;
          sh = v9;
          v9 += v64;
          v164 = v58;
          memset(sh, cb, v64);
          v58 = v164;
        }
        if ( v58 )
        {
          if ( !v61 )
            goto LABEL_179;
          v184 = v8;
          v65 = v61;
          do
          {
            v9[v65 - 1] = *(_DWORD *)(a7[14] + 4 * (unsigned __int8)v194[v65 - 1]);
            --v65;
          }
          while ( v65 );
        }
        else
        {
          if ( !v188 )
          {
            memcpy(v9, v194, v61);
LABEL_179:
            v9 += v61;
LABEL_180:
            v10 = v8;
            v167 += v173;
            goto LABEL_9;
          }
          if ( !v61 )
            goto LABEL_179;
          v184 = v8;
          v128 = v61;
          do
          {
            v9[v128 - 1] = *(_DWORD *)(a7[15] + 4 * (unsigned __int8)v194[v128 - 1]);
            --v128;
          }
          while ( v128 );
        }
        v8 = v184;
        goto LABEL_179;
      case 97:
        if ( v175 )
          goto LABEL_42;
        v50 = 1;
        if ( !v11 )
          v50 = v185;
        v187 = v50;
        v51 = (_BYTE *)v193[*((unsigned __int16 *)a5 + 12) + 9];
        v52 = strlen(v51);
        v53 = v14 - v52;
        v169 = v52;
        v54 = 0;
        if ( v53 >= 0 )
          v54 = v53;
        v177 = v169 + v54;
        if ( v169 + v54 >= (unsigned int)(a2 - v167) )
          goto LABEL_33;
        if ( !v9 )
          goto LABEL_82;
        if ( v53 > 0 )
        {
          if ( v183 == 48 )
            ca = 48;
          else
            ca = 32;
          sg = v9;
          v9 += v53;
          memset(sg, ca, v53);
          v51 = (_BYTE *)v193[*((unsigned __int16 *)a5 + 12) + 9];
        }
        if ( !v187 )
          goto LABEL_398;
        if ( v169 )
        {
          v55 = v169;
          do
          {
            v9[v55 - 1] = *(_DWORD *)(a7[15] + 4 * (unsigned __int8)v51[v55 - 1]);
            --v55;
          }
          while ( v55 );
        }
        goto LABEL_81;
      case 98:
      case 104:
        v105 = 1;
        if ( !v11 )
          v105 = v185;
        v185 = v105;
        if ( v175 )
          goto LABEL_42;
        v51 = (_BYTE *)v193[(unsigned __int16)(a5[4] + 14) + 9];
        v106 = strlen(v51);
        v107 = v14 - v106;
        v169 = v106;
        v108 = 0;
        if ( v107 >= 0 )
          v108 = v107;
        v177 = v169 + v108;
        if ( v169 + v108 >= (unsigned int)(a2 - v167) )
          goto LABEL_33;
        if ( !v9 )
          goto LABEL_82;
        if ( v107 > 0 )
        {
          if ( v183 == 48 )
            cf = 48;
          else
            cf = 32;
          sk = v9;
          v9 += v107;
          memset(sk, cf, v107);
          v51 = (_BYTE *)v193[(unsigned __int16)(a5[4] + 14) + 9];
        }
        if ( !v185 )
          goto LABEL_398;
        if ( v169 )
        {
          v109 = v169;
          do
          {
            v9[v109 - 1] = *(_DWORD *)(a7[15] + 4 * (unsigned __int8)v51[v109 - 1]);
            --v109;
          }
          while ( v109 );
        }
        goto LABEL_81;
      case 99:
        if ( v175 == 79 )
          goto LABEL_42;
        if ( v175 == 69 )
        {
          v178 = (const char *)v193[57];
          if ( *v178 )
            goto LABEL_85;
        }
        v178 = (const char *)v193[49];
        v34 = _strftime_internal(v178, -1, a5, a6, a7);
        goto LABEL_86;
      case 100:
        if ( v175 == 69 )
          goto LABEL_42;
        v104 = 2;
        if ( v14 >= 2 )
          v104 = v14;
        v171 = v104;
        v41 = a5[3];
        goto LABEL_104;
      case 101:
        if ( v175 == 69 )
          goto LABEL_42;
        v103 = 2;
        if ( v14 >= 2 )
          v103 = v14;
        v171 = v103;
        v41 = a5[3];
        goto LABEL_219;
      case 106:
        if ( v175 == 69 )
          goto LABEL_42;
        v102 = 3;
        if ( v14 >= 3 )
          v102 = v14;
        v171 = v102;
        v41 = a5[7] + 1;
        goto LABEL_104;
      case 107:
        if ( v175 == 69 )
          goto LABEL_42;
        v101 = 2;
        if ( v14 >= 2 )
          v101 = v14;
        v171 = v101;
        v41 = a5[2];
        goto LABEL_219;
      case 108:
        if ( v175 == 69 )
          goto LABEL_42;
        v41 = v192;
        v74 = 2;
        if ( v14 >= 2 )
          v74 = v14;
        v171 = v74;
LABEL_219:
        if ( v183 != 45 )
        {
          v75 = 95;
          if ( v183 == 48 )
            v75 = 48;
          v183 = v75;
        }
        goto LABEL_104;
      case 109:
        if ( v175 == 69 )
          goto LABEL_42;
        v73 = 2;
        if ( v14 >= 2 )
          v73 = v14;
        v171 = v73;
        v41 = a5[4] + 1;
        goto LABEL_104;
      case 110:
        v87 = 0;
        v88 = v14 - 1;
        if ( v88 >= 0 )
          v87 = v88;
        v89 = v87 + 1;
        if ( v87 + 1 >= (unsigned int)(a2 - v167) )
          goto LABEL_33;
        if ( v9 )
        {
          if ( v88 > 0 )
          {
            sc = v9;
            v9 += v88;
            if ( v183 == 48 )
              memset(sc, 48, v88);
            else
              memset(sc, 32, v88);
          }
          *v9++ = 10;
        }
        goto LABEL_271;
      case 112:
        v24 = 0;
LABEL_65:
        if ( v11 )
          v24 = 1;
        v25 = 0;
        if ( !v11 )
          v25 = v185;
        v26 = a5[2];
        v186 = v25;
        v161 = v24;
        v27 = strlen((_BYTE *)v193[(v26 > 11) + 47]);
        v28 = v161;
        v29 = v14 - v27;
        v169 = v27;
        v30 = 0;
        if ( v29 >= 0 )
          v30 = v29;
        v177 = v169 + v30;
        if ( v169 + v30 >= (unsigned int)(a2 - v167) )
          goto LABEL_33;
        if ( !v9 )
          goto LABEL_82;
        if ( v29 > 0 )
        {
          sa = v9;
          v9 += v29;
          if ( v183 == 48 )
            memset(sa, 48, v29);
          else
            memset(sa, 32, v29);
          v28 = v161;
          v26 = a5[2];
        }
        v31 = (v26 >= 12) + 46;
        if ( v28 )
        {
          v32 = v193[v31 + 1];
          if ( v169 )
          {
            v33 = v169;
            do
            {
              v9[v33 - 1] = *(_DWORD *)(a7[14] + 4 * *(unsigned __int8 *)(v32 + v33 - 1));
              --v33;
            }
            while ( v33 );
          }
        }
        else if ( v186 )
        {
          v126 = v193[v31 + 1];
          if ( v169 )
          {
            v127 = v169;
            do
            {
              v9[v127 - 1] = *(_DWORD *)(a7[15] + 4 * *(unsigned __int8 *)(v126 + v127 - 1));
              --v127;
            }
            while ( v127 );
          }
        }
        else
        {
          memcpy(v9, (_BYTE *)v193[v31 + 1], v169);
        }
        goto LABEL_81;
      case 114:
        v76 = "%I:%M:%S %p";
        if ( *(_BYTE *)v193[52] )
          v76 = (const char *)v193[52];
        v178 = v76;
        v34 = _strftime_internal(v76, -1, a5, a6, a7);
        goto LABEL_86;
      case 115:
        v43 = v203;
        v202[0] = *a5;
        v202[1] = a5[1];
        v202[2] = a5[2];
        v202[3] = a5[3];
        v202[4] = a5[4];
        v202[5] = a5[5];
        v202[6] = a5[6];
        v202[7] = a5[7];
        v202[8] = a5[8];
        v202[9] = a5[9];
        v202[10] = a5[10];
        v111 = timelocal(a4, v202);
        v179 = (unsigned int)v111 >> 31;
        do
        {
          v112 = v111 % 10;
          v111 /= 10;
          if ( v179 )
            v112 = -v112;
          *--v43 = v112 + 48;
        }
        while ( v111 );
        v171 = 1;
        goto LABEL_109;
      case 116:
        v116 = 0;
        v117 = v14 - 1;
        if ( v117 >= 0 )
          v116 = v117;
        v89 = v116 + 1;
        if ( v116 + 1 >= (unsigned int)(a2 - v167) )
          goto LABEL_33;
        if ( v9 )
        {
          if ( v117 > 0 )
          {
            se = v9;
            v9 += v117;
            if ( v183 == 48 )
              memset(se, 48, v117);
            else
              memset(se, 32, v117);
          }
          *v9++ = 9;
        }
        goto LABEL_271;
      case 117:
        v66 = 1;
        if ( v14 > 0 )
          v66 = v14;
        v171 = v66;
        v41 = (a5[6] + 6) % 7 + 1;
        goto LABEL_104;
      case 119:
        if ( v175 == 69 )
          goto LABEL_42;
        v110 = 1;
        if ( v14 > 0 )
          v110 = v14;
        v171 = v110;
        v41 = a5[6];
        goto LABEL_104;
      case 120:
        if ( v175 == 79 )
          goto LABEL_42;
        if ( v175 == 69 && (v178 = (const char *)v193[55], *v178) )
        {
LABEL_85:
          v34 = _strftime_internal(v178, -1, a5, a6, a7);
        }
        else
        {
          v178 = (const char *)v193[50];
          v34 = _strftime_internal(v178, -1, a5, a6, a7);
        }
        goto LABEL_86;
      case 121:
        if ( v175 == 69 )
        {
          v132 = nl_get_era_entry(a5, v193);
          if ( v132 )
          {
            v133 = 1;
            if ( v14 > 0 )
              v133 = v14;
            v171 = v133;
            v41 = v132[1] + v132[12] * (a5[5] - v132[2]);
            goto LABEL_105;
          }
        }
        v98 = 2;
        if ( v14 >= 2 )
          v98 = v14;
        v171 = v98;
        v99 = a5[5];
        v100 = 100 * (v99 / 100);
LABEL_301:
        v41 = (v99 - v100 + 100) % 100;
        goto LABEL_104;
      case 122:
        if ( a5[8] < 0 )
          goto LABEL_98;
        v93 = a5[9];
        v94 = 0;
        v95 = v14 - 1;
        if ( v14 - 1 >= 0 )
          v94 = v14 - 1;
        if ( v93 < 0 )
        {
          v174 = v94 + 1;
          if ( v94 + 1 >= (unsigned int)(a2 - v167) )
            goto LABEL_33;
          if ( v9 )
          {
            if ( v95 > 0 )
            {
              if ( v183 == 48 )
                cg = 48;
              else
                cg = 32;
              memset(v9, cg, v14 - 1);
              v9 += v14 - 1;
            }
            *v9++ = 45;
          }
          v93 = -v93;
          v167 += v174;
        }
        else
        {
          v96 = v94 + 1;
          if ( v94 + 1 >= (unsigned int)(a2 - v167) )
            goto LABEL_33;
          if ( v9 )
          {
            if ( v95 > 0 )
            {
              if ( v183 == 48 )
                ce = 48;
              else
                ce = 32;
              v166 = v94 + 1;
              memset(v9, ce, v14 - 1);
              v96 = v166;
              v9 += v14 - 1;
            }
            *v9++ = 43;
          }
          v167 += v96;
        }
        v97 = 4;
        if ( v14 >= 4 )
          v97 = v14;
        v171 = v97;
        v41 = 40 * (v93 / 60 / 60) + v93 / 60;
        goto LABEL_104;
      default:
LABEL_29:
        v16 = v8;
        if ( v12 != 37 )
          goto LABEL_43;
        v168 = 1;
        goto LABEL_46;
    }
    return v167;
  }
}

//----- (08084170) --------------------------------------------------------
int __usercall strftime_l@<eax>(
        long double a1@<st0>,
        char *a2,
        int a3,
        unsigned __int8 *a4,
        signed int *a5,
        _DWORD *a6)
{
  char v7[13]; // [esp+1Fh] [ebp-Dh] BYREF

  v7[0] = 0;
  return _strftime_internal(a2, a3, a4, a1, a5, v7, a6);
}
// 8084170: using guessed type char var_D[13];

//----- (080841B0) --------------------------------------------------------
int __usercall nl_init_alt_digit@<eax>(_DWORD *a1@<eax>)
{
  int v2; // edi
  int result; // eax
  int v4; // esi
  int v5; // ebx
  unsigned int i; // edx

  v2 = a1[5];
  if ( !v2 )
  {
    result = malloc(28);
    a1[5] = result;
    if ( !result )
      return result;
    for ( i = 0; i < 0x1C; i += 4 )
      *(_DWORD *)(result + i) = 0;
    a1[4] = nl_cleanup_time;
    v2 = a1[5];
  }
  result = *(_DWORD *)(v2 + 20);
  if ( !result )
  {
    v4 = a1[56];
    *(_DWORD *)(v2 + 20) = 1;
    if ( v4 )
    {
      result = malloc(400);
      *(_DWORD *)(v2 + 12) = result;
      if ( result )
      {
        v5 = 0;
        while ( 1 )
        {
          *(_DWORD *)(result + v5) = v4;
          v5 += 4;
          result = rawmemchr(v4, 0);
          v4 = result + 1;
          if ( v5 == 400 )
            break;
          result = *(_DWORD *)(v2 + 12);
        }
      }
    }
  }
  return result;
}
// 8048230: using guessed type int __cdecl rawmemchr(_DWORD, _DWORD);
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);

//----- (08084250) --------------------------------------------------------
int __usercall nl_get_alt_digit@<eax>(unsigned int a1@<eax>, int a2@<edx>)
{
  int v2; // esi
  int v5; // eax
  int v6; // eax

  v2 = 0;
  if ( a1 <= 0x63 && **(_BYTE **)(a2 + 224) )
  {
    if ( (v5 = *(_DWORD *)(a2 + 20)) != 0 && *(_DWORD *)(v5 + 20)
      || (v2 = 0, nl_init_alt_digit((_DWORD *)a2), (v5 = *(_DWORD *)(a2 + 20)) != 0) )
    {
      v6 = *(_DWORD *)(v5 + 12);
      v2 = 0;
      if ( v6 )
        return *(_DWORD *)(v6 + 4 * a1);
    }
  }
  return v2;
}

//----- (080842F0) --------------------------------------------------------
int __usercall nl_get_walt_digit@<eax>(unsigned int a1@<eax>, _DWORD *a2@<edx>, long double a3@<st0>)
{
  int v4; // esi
  int v6; // ebp
  int v7; // eax
  const wchar_t *wcs; // edi
  int v10; // eax
  int v11; // eax
  unsigned int i; // edx

  v4 = 0;
  if ( a1 <= 0x63 && *(_DWORD *)a2[107] )
  {
    v6 = a2[5];
    if ( !v6 )
    {
      v4 = 0;
      malloc(a3, 0x1Cu);
      a2[5] = v11;
      if ( !v11 )
        return v4;
      for ( i = 0; i < 0x1C; i += 4 )
        *(_DWORD *)(v11 + i) = 0;
      a2[4] = nl_cleanup_time;
      v6 = a2[5];
    }
    if ( !*(_DWORD *)(v6 + 24) )
    {
      wcs = (const wchar_t *)a2[107];
      *(_DWORD *)(v6 + 24) = 1;
      if ( wcs )
      {
        v4 = 0;
        malloc(a3, 0x190u);
        *(_DWORD *)(v6 + 16) = v10;
        if ( !v10 )
          return v4;
        while ( 1 )
        {
          *(_DWORD *)(v10 + v4) = wcs;
          v4 += 4;
          wcs = wcschr(wcs, 0) + 1;
          if ( v4 == 400 )
            break;
          v10 = *(_DWORD *)(v6 + 16);
        }
      }
    }
    v7 = *(_DWORD *)(v6 + 16);
    v4 = 0;
    if ( v7 )
      return *(_DWORD *)(v7 + 4 * a1);
  }
  return v4;
}
// 8084381: variable 'v10' is possibly undefined
// 80843BE: variable 'v11' is possibly undefined

//----- (080843F0) --------------------------------------------------------
int __usercall nl_parse_alt_digit@<eax>(unsigned __int8 **a1@<eax>, int a2@<edx>)
{
  int v3; // eax
  unsigned int v4; // ebp
  int i; // ebx
  unsigned int v6; // eax
  unsigned int v7; // esi
  int v8; // eax
  int v9; // edx
  int v11; // [esp+10h] [ebp-2Ch]
  int v12; // [esp+14h] [ebp-28h]
  unsigned __int8 *v13; // [esp+18h] [ebp-24h]

  v11 = -1;
  v13 = *a1;
  if ( **(_DWORD **)(a2 + 428) )
  {
    v3 = *(_DWORD *)(a2 + 20);
    if ( v3 && *(_DWORD *)(v3 + 20)
      || (v4 = 0, nl_init_alt_digit((_DWORD *)a2), v3 = *(_DWORD *)(a2 + 20), v11 = -1, v3) )
    {
      v4 = 0;
      v11 = -1;
      v12 = *(_DWORD *)(v3 + 12);
      if ( v12 )
      {
        for ( i = 0; i != 100; ++i )
        {
          v6 = strlen(*(_BYTE **)(v12 + 4 * i));
          v7 = v6;
          if ( v6 > v4 )
          {
            v8 = strncmp(*(unsigned __int8 **)(v12 + 4 * i), v13, v6);
            v9 = v11;
            if ( !v8 )
            {
              v9 = i;
              v4 = v7;
            }
            v11 = v9;
          }
        }
      }
    }
    if ( v11 != -1 )
      *a1 += v4;
  }
  return v11;
}

//----- (080844F0) --------------------------------------------------------
int __usercall nl_init_era_entries_part_0@<eax>(_DWORD *a1@<eax>)
{
  wchar_t *v3; // ebx
  wchar_t *v4; // eax
  wchar_t *v5; // edi
  wchar_t *v6; // esi
  int v7; // eax
  int v8; // eax
  const wchar_t *wcs; // eax
  wchar_t v10; // edx
  wchar_t v11; // eax
  wchar_t v12; // ecx
  wchar_t v13; // ebp
  int v14; // eax
  unsigned int i; // edx
  wchar_t **v16; // ebp
  wchar_t v17; // [esp+10h] [ebp-2Ch]
  wchar_t **v18; // [esp+14h] [ebp-28h]
  wchar_t v19; // [esp+18h] [ebp-24h]
  wchar_t *v20; // [esp+1Ch] [ebp-20h]

  v18 = (wchar_t **)a1[5];
  if ( !v18 )
  {
    v14 = malloc(28);
    a1[5] = v14;
    if ( !v14 )
      return 0;
    for ( i = 0; i < 0x1C; i += 4 )
      *(_DWORD *)(v14 + i) = 0;
    v16 = (wchar_t **)a1[5];
    a1[4] = nl_cleanup_time;
    v18 = v16;
  }
  if ( !v18[2] )
  {
    v20 = (wchar_t *)a1[59];
    if ( v20 )
    {
      v3 = *v18;
      if ( v20 != v18[1] )
      {
        realloc(*v18, 52 * (_DWORD)v20);
        v3 = v4;
      }
      if ( v3 )
      {
        v5 = 0;
        v6 = (wchar_t *)a1[60];
        *v18 = v3;
        v18[1] = v20;
        do
        {
          *v3 = *v6;
          v3[1] = v6[1];
          v10 = v6[2];
          v3[2] = v10;
          v17 = v6[3];
          v3[3] = v17;
          v19 = v6[4];
          v3[4] = v19;
          v11 = v6[5];
          v3[5] = v11;
          v12 = v6[6];
          v3[6] = v12;
          v13 = v6[7];
          v3[7] = v13;
          if ( v10 < v11 || v10 == v11 && (v17 < v12 || v17 == v12 && v19 <= v13) )
            v3[12] = 2 * (*v3 == 43) - 1;
          else
            v3[12] = 2 * (*v3 != 43) - 1;
          v5 = (wchar_t *)((char *)v5 + 1);
          v3[8] = (wchar_t)(v6 + 8);
          v7 = rawmemchr(v6 + 8, 0) + 1;
          v3[9] = v7;
          v8 = rawmemchr(v7, 0);
          v3[10] = v8 + 1 + (~((_BYTE)v8 + 1 - (_BYTE)v6 + 3) & 3);
          wcs = wcschr((const wchar_t *)(v8 + 1 + (~((_BYTE)v8 + 1 - (_BYTE)v6 + 3) & 3)), 0) + 1;
          v3[11] = (wchar_t)wcs;
          v3 += 13;
          v6 = wcschr(wcs, 0) + 1;
        }
        while ( v5 != v20 );
      }
      else
      {
        free(*v18);
        v18[1] = 0;
        *v18 = 0;
      }
    }
    else if ( *v18 )
    {
      free(*v18);
      *v18 = 0;
    }
    v18[2] = (wchar_t *)1;
  }
  return 0;
}
// 808459F: variable 'v4' is possibly undefined
// 8048230: using guessed type int __cdecl rawmemchr(_DWORD, _DWORD);
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08084730) --------------------------------------------------------
_DWORD *__usercall nl_get_era_entry@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>)
{
  _DWORD *v3; // esi
  int v4; // ebp
  int v5; // ecx
  _DWORD *v6; // edx
  int v7; // ebx
  int v8; // edi
  bool v9; // zf
  int v10; // esi
  _DWORD *result; // eax
  int v13; // [esp+8h] [ebp-24h]
  int v14; // [esp+Ch] [ebp-20h]

  v3 = (_DWORD *)a2[5];
  if ( !v3 || !v3[2] )
  {
    if ( a2[59] )
    {
      nl_init_era_entries_part_0(a2);
      result = 0;
      v3 = (_DWORD *)a2[5];
      if ( !v3 )
        return result;
    }
    else
    {
      result = 0;
      if ( !v3 )
        return result;
    }
  }
  v4 = v3[1];
  v5 = a1[5];
  v13 = a1[4];
  v14 = a1[3];
  if ( v4 )
  {
    v6 = (_DWORD *)*v3;
    v7 = 0;
    while ( 1 )
    {
      v10 = v6[2];
      result = v6;
      if ( v5 <= v10 && (v5 != v10 || v13 <= v6[3] && (v13 != v6[3] || v14 < v6[4])) )
        break;
      v8 = v6[5];
      if ( v5 < v8 )
        return result;
      if ( v5 == v8 )
      {
        if ( v13 < v6[6] || v13 == v6[6] && v14 <= v6[7] )
          return result;
LABEL_16:
        if ( v13 > v6[6] )
        {
LABEL_8:
          v9 = v5 == v10;
          if ( v5 < v10 )
            return result;
          goto LABEL_9;
        }
        if ( v13 != v6[6] || v14 < v6[7] )
          goto LABEL_10;
        v9 = v5 == v10;
        if ( v5 < v10 )
          return result;
LABEL_9:
        if ( v9 && (v13 < v6[3] || v13 == v6[3] && v14 <= v6[4]) )
          return result;
LABEL_10:
        ++v7;
        v6 += 13;
        if ( v7 == v4 )
          return 0;
      }
      else
      {
LABEL_7:
        if ( v5 > v8 )
          goto LABEL_8;
        if ( v5 == v8 )
          goto LABEL_16;
        ++v7;
        v6 += 13;
        if ( v7 == v4 )
          return 0;
      }
    }
    v8 = v6[5];
    goto LABEL_7;
  }
  return 0;
}

//----- (080848A0) --------------------------------------------------------
int __usercall nl_select_era_entry@<eax>(int a1@<eax>, _DWORD *a2@<edx>)
{
  _DWORD *v3; // ecx
  int result; // eax

  v3 = (_DWORD *)a2[5];
  if ( v3 && v3[2] )
    return *v3 + 52 * a1;
  if ( a2[59] )
  {
    nl_init_era_entries_part_0(a2);
    result = 0;
    v3 = (_DWORD *)a2[5];
    if ( !v3 )
      return result;
    return *v3 + 52 * a1;
  }
  result = 0;
  if ( v3 )
    return *v3 + 52 * a1;
  return result;
}

//----- (08084900) --------------------------------------------------------
int __usercall nl_cleanup_time@<eax>(int result@<eax>)
{
  _DWORD *v1; // ebx

  v1 = *(_DWORD **)(result + 20);
  if ( v1 )
  {
    *(_DWORD *)(result + 20) = 0;
    *(_DWORD *)(result + 16) = 0;
    free(*v1);
    free(v1[3]);
    free(v1[4]);
    return free(v1);
  }
  return result;
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08084950) --------------------------------------------------------
int *__userpurge _alloc_dir@<eax>(int a1@<eax>, char a2@<dl>, int a3@<ecx>, int a4)
{
  int v6; // eax
  int v7; // esi
  int *v8; // ecx

  if ( !a2 && (a3 & 0x80000) == 0 && (fcntl(a2, a1, 2) & 0x80000000) != 0 )
    return 0;
  v6 = 32792;
  v7 = 0x8000;
  if ( a4 )
  {
    if ( *(_DWORD *)(a4 + 52) >= 0x8000u )
      v7 = *(_DWORD *)(a4 + 52);
    v6 = v7 + 24;
  }
  v8 = (int *)malloc(v6);
  if ( v8 || (v7 = 0x2000, (v8 = (int *)malloc(8216)) != 0) )
  {
    *v8 = a1;
    v8[1] = 0;
    v8[2] = v7;
    v8[3] = 0;
    v8[4] = 0;
    v8[5] = 0;
  }
  else if ( a2 )
  {
    __writegsdword(0xFFFFFFE8, (unsigned __int64)dl_sysinfo(0) >> 32);
  }
  return v8;
}
// 80849C2: variable 'v8' is possibly undefined
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08084A40) --------------------------------------------------------
int *__usercall _opendirat@<eax>(int a1@<eax>, _BYTE *a2@<edx>)
{
  int v2; // eax

  if ( *a2 )
  {
    v2 = _openat_nocancel(a1, (int)a2);
    if ( v2 < 0 )
      return 0;
    else
      return _alloc_dir(v2, 1, 0, 0);
  }
  else
  {
    __writegsdword(0xFFFFFFE8, 2u);
    return 0;
  }
}

//----- (08084AA0) --------------------------------------------------------
int *__cdecl opendir(_BYTE *a1)
{
  return _opendirat(-100, a1);
}

//----- (08084AB0) --------------------------------------------------------
unsigned int __cdecl closedir(int a1)
{
  int v1; // ecx

  if ( a1 )
  {
    free(a1);
    return _close_nocancel(v1);
  }
  else
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    return -1;
  }
}
// 8084ACE: variable 'v1' is possibly undefined
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08084AF0) --------------------------------------------------------
void __cdecl readdir64(_DWORD *a1)
{
  bool v3; // zf
  unsigned int v4; // eax
  int v5; // ecx
  int v6; // ebp
  signed int v7; // eax
  unsigned int v8; // [esp+Ch] [ebp-20h]

  _ECX = 1;
  _EBX = a1;
  v8 = __readgsdword(0xFFFFFFE8);
  v3 = __readgsdword(0xCu) == 0;
  if ( !v3 )
    __asm { lock }
  __asm { cmpxchg [ebx+4], ecx }
  if ( !v3 )
  {
    L_lock_21(0, (int)a1);
    return;
  }
  v4 = a1[4];
  while ( v4 < a1[3] )
  {
LABEL_5:
    v5 = (int)a1 + v4 + 16;
    v4 += *(unsigned __int16 *)((char *)a1 + v4 + 40);
    v6 = *(_DWORD *)(v5 + 16);
    a1[4] = v4;
    a1[5] = v6;
    if ( *(_QWORD *)(v5 + 8) )
      goto LABEL_11;
  }
  v7 = _getdents64(a1[2], (int)(a1 + 6));
  if ( v7 > 0 )
  {
    a1[3] = v7;
    v4 = 0;
    goto LABEL_5;
  }
  if ( !v7 || __readgsdword(0xFFFFFFE8) == 2 )
    __writegsdword(0xFFFFFFE8, v8);
LABEL_11:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v3 = a1[1]-- == 1;
  if ( !v3 )
    L_unlock_92((int)a1);
}

//----- (08084B9D) --------------------------------------------------------
void __usercall L_lock_21(int a1@<eax>, int a2@<ebx>)
{
  _lll_lock_wait_private(a1, (volatile __int32 *)(a2 + 4));
  JUMPOUT(0x8084B20);
}
// 8084BA5: control flows out of bounds to 8084B20

//----- (08084BAA) --------------------------------------------------------
void __usercall L_unlock_92(int a1@<ebx>)
{
  _lll_unlock_wake_private((_DWORD *)(a1 + 4));
  JUMPOUT(0x8084B89);
}
// 8084BB2: control flows out of bounds to 8084B89

//----- (08084BC0) --------------------------------------------------------
unsigned int __fastcall uname(int a1)
{
  unsigned int result; // eax

  result = dl_sysinfo(a1);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08084BE0) --------------------------------------------------------
int __usercall fork@<eax>(long double a1@<st0>)
{
  int v1; // ebx
  signed __int32 v2; // eax
  int v3; // ett
  _DWORD *i; // esi
  void (*v5)(void); // eax
  unsigned int v6; // eax
  int v7; // edi
  unsigned __int64 v8; // rax
  void *j; // ebx
  _DWORD *v10; // eax
  int v11; // eax
  void (*v12)(void); // edx
  int v13; // esi
  int v15; // eax
  void (*v16)(void); // edx
  _DWORD v17[8]; // [esp-10h] [ebp-48h] BYREF
  unsigned int v18; // [esp+10h] [ebp-28h]
  unsigned int v19; // [esp+14h] [ebp-24h]
  unsigned int v20; // [esp+18h] [ebp-20h]
  _DWORD *v21; // [esp+1Ch] [ebp-1Ch]
  int savedregs; // [esp+38h] [ebp+0h] BYREF

  while ( 1 )
  {
    v1 = _fork_handlers;
    if ( !_fork_handlers )
    {
      v21 = 0;
      goto LABEL_10;
    }
    v2 = *(_DWORD *)(_fork_handlers + 20);
    if ( v2 )
    {
      v3 = *(_DWORD *)(_fork_handlers + 20);
      if ( v3 == _InterlockedCompareExchange((volatile signed __int32 *)(_fork_handlers + 20), v2 + 1, v2) )
        break;
    }
  }
  for ( i = 0; ; i = v17 )
  {
    v5 = *(void (**)(void))(v1 + 4);
    if ( v5 )
      v5();
    v17[0] = v1;
    v1 = *(_DWORD *)v1;
    v17[1] = i;
    if ( !v1 )
      break;
    _InterlockedIncrement((volatile signed __int32 *)(v1 + 20));
  }
  v21 = v17;
LABEL_10:
  IO_list_lock();
  v18 = __readgsdword(0x68u);
  v20 = __readgsdword(0x6Cu);
  __writegsdword(0x6Cu, -v20);
  v19 = __readgsdword(8u);
  v6 = dl_sysinfo(0);
  v7 = v6;
  if ( v6 > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -v6);
    v7 = -1;
  }
  else if ( !v6 )
  {
    if ( v18 == __readgsdword(0x68u) )
      _assert_fail(
        (int)&savedregs,
        a1,
        (int)"({ __typeof (self->tid) __value; if (sizeof (__value) == 1) asm volatile (\"movb %%gs:%P2,%b0\" : \"=q\" (_"
             "_value) : \"0\" (0), \"i\" (__builtin_offsetof (struct pthread, tid))); else if (sizeof (__value) == 4) asm"
             " volatile (\"movl %%gs:%P1,%0\" : \"=r\" (__value) : \"i\" (__builtin_offsetof (struct pthread, tid))); els"
             "e { if (sizeof (__value) != 8) abort (); asm volatile (\"movl %%gs:%P1,%%eax\\n\\t\" \"movl %%gs:%P2,%%edx\""
             " : \"=A\" (__value) : \"i\" (__builtin_offsetof (struct pthread, tid)), \"i\" (__builtin_offsetof (struct p"
             "thread, tid) + 4)); } __value; }) != ppid",
        (int)"../nptl/sysdeps/unix/sysv/linux/i386/../fork.c",
        142,
        "__libc_fork");
    if ( _fork_generation_pointer )
      *(_DWORD *)_fork_generation_pointer += 4;
    __writegsdword(0x6Cu, __readgsdword(0x68u));
    v8 = __rdtsc();
    __writegsdword(0x21Cu, v8);
    __writegsdword(0x220u, HIDWORD(v8));
    dl_cpuclock_offset = v8;
    for ( j = IO_iter_begin(); j != (void *)IO_iter_end(); j = (void *)IO_iter_next((int)j) )
    {
      v10 = *(_DWORD **)(IO_iter_file((int)j) + 72);
      *v10 = 0;
      v10[1] = 0;
      v10[2] = 0;
    }
    IO_list_resetlock();
    dl_load_lock = 0;
    dword_80EF590 = 0;
    dword_80EF594 = 0;
    dword_80EF598 = 1;
    dword_80EF59C = 0;
    for ( dword_80EF5A0 = 0; v21; v21 = *(_DWORD **)(v13 + 4) )
    {
      v11 = *v21;
      v12 = *(void (**)(void))(*v21 + 12);
      if ( v12 )
      {
        v12();
        v11 = *v21;
      }
      v13 = (int)v21;
      *(_DWORD *)(v11 + 20) = 1;
    }
    _fork_lock = 0;
    return v7;
  }
  if ( v18 != __readgsdword(0x68u) )
    _assert_fail(
      (int)&savedregs,
      a1,
      (int)"({ __typeof (({ struct pthread *__self; asm (\"movl %%gs:%c1,%0\" : \"=r\" (__self) : \"i\" (__builtin_offset"
           "of (struct pthread, header.self))); __self;})->tid) __value; if (sizeof (__value) == 1) asm volatile (\"movb "
           "%%gs:%P2,%b0\" : \"=q\" (__value) : \"0\" (0), \"i\" (__builtin_offsetof (struct pthread, tid))); else if (si"
           "zeof (__value) == 4) asm volatile (\"movl %%gs:%P1,%0\" : \"=r\" (__value) : \"i\" (__builtin_offsetof (struc"
           "t pthread, tid))); else { if (sizeof (__value) != 8) abort (); asm volatile (\"movl %%gs:%P1,%%eax\\n\\t\" \""
           "movl %%gs:%P2,%%edx\" : \"=A\" (__value) : \"i\" (__builtin_offsetof (struct pthread, tid)), \"i\" (__builtin"
           "_offsetof (struct pthread, tid) + 4)); } __value; }) == ppid",
      (int)"../nptl/sysdeps/unix/sysv/linux/i386/../fork.c",
      212,
      "__libc_fork");
  __writegsdword(0x6Cu, v20);
  IO_list_unlock();
  if ( !v21 )
    return v7;
  do
  {
    v15 = *v21;
    v16 = *(void (**)(void))(*v21 + 8);
    if ( v16 )
    {
      v16();
      v15 = *v21;
    }
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v15 + 20)) && *(_DWORD *)(v15 + 24) )
      __asm { int     80h; LINUX - }
    v21 = (_DWORD *)v21[1];
  }
  while ( v21 );
  return v7;
}
// 80EF58C: using guessed type int dl_load_lock;
// 80EF590: using guessed type int dword_80EF590;
// 80EF594: using guessed type int dword_80EF594;
// 80EF598: using guessed type int dword_80EF598;
// 80EF59C: using guessed type int dword_80EF59C;
// 80EF5A0: using guessed type int dword_80EF5A0;
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80F0660: using guessed type int _fork_lock;
// 80F11A8: using guessed type __int64 dl_cpuclock_offset;
// 80F12F4: using guessed type int _fork_generation_pointer;
// 80F12F8: using guessed type int _fork_handlers;

//----- (08084EA0) --------------------------------------------------------
int __usercall execvp@<eax>(long double a1@<st0>, char *s, int a3)
{
  return execvpe(a1, s, a3);
}

//----- (08084ED0) --------------------------------------------------------
int __usercall execvpe@<eax>(long double a1@<st0>, char *s, int a3)
{
  int i; // eax
  int v5; // esi
  unsigned int v6; // edx
  void *v7; // esp
  int v8; // edx
  const char **v9; // eax
  const char *v10; // ecx
  _BYTE *v11; // eax
  int v12; // ecx
  int v13; // esi
  int v14; // ecx
  int v15; // eax
  unsigned int v16; // ecx
  unsigned int v17; // eax
  void *v18; // esp
  _BYTE *v19; // edx
  _BYTE *v20; // eax
  unsigned int *v21; // eax
  _BYTE *v22; // ecx
  unsigned int *v23; // edi
  int v24; // ecx
  int v25; // eax
  const char *v26; // eax
  int j; // eax
  int v28; // edx
  void *v29; // esp
  int v30; // esi
  bool v31; // zf
  int v32; // edx
  int v33; // esi
  _BOOL4 v34; // eax
  int v35; // eax
  _BOOL4 v36; // eax
  _BOOL4 v37; // eax
  int v38; // eax
  _BYTE v39[8]; // [esp+10h] [ebp-48h] BYREF
  int v40; // [esp+18h] [ebp-40h]
  _BYTE *v41; // [esp+1Ch] [ebp-3Ch]
  _BYTE *v42; // [esp+20h] [ebp-38h]
  int v43; // [esp+24h] [ebp-34h]
  int v44; // [esp+28h] [ebp-30h]
  char v45; // [esp+2Fh] [ebp-29h]
  _BYTE *v46; // [esp+30h] [ebp-28h]
  size_t v47; // [esp+34h] [ebp-24h]
  int v48; // [esp+38h] [ebp-20h]
  _BYTE *v49; // [esp+3Ch] [ebp-1Ch]

  if ( !*s )
  {
    __writegsdword(0xFFFFFFE8, 2u);
    return -1;
  }
  if ( strchr(s, 47) )
  {
    execve((int)s, a3);
    if ( __readgsdword(0xFFFFFFE8) != 8 )
      return -1;
    for ( i = 0; ; ++i )
    {
      v5 = i + 1;
      if ( !*(_DWORD *)(a3 + 4 * i) )
        break;
    }
    v6 = 4 * i + 8;
    if ( v6 <= 0x1000
      || (v42 = (_BYTE *)(4 * i + 8), v36 = _libc_alloca_cutoff((unsigned int)v42), v6 = (unsigned int)v42, v36) )
    {
      v7 = alloca(v6 + 15);
      v8 = 0;
      v9 = (const char **)v39;
    }
    else
    {
      malloc(a1, (size_t)v42);
      v8 = (int)v9;
    }
    if ( !v9 )
      return -1;
    v10 = "/bin/sh";
    *v9 = "/bin/sh";
    v9[1] = s;
    if ( v5 != 1 )
    {
      do
      {
        v9[v5] = *(const char **)(a3 + 4 * v5 - 4);
        --v5;
      }
      while ( v5 != 1 );
      v10 = *v9;
    }
    v42 = (_BYTE *)v8;
    execve((int)v10, (int)v9);
    free(a1, (int)v42);
    return -1;
  }
  v11 = (_BYTE *)getenv("PATH");
  v13 = (int)v11;
  if ( v11 )
  {
    v47 = 1;
    v14 = strlen(v11);
  }
  else
  {
    v14 = confstr(v12, a1, 0, 0, 0);
    v47 = v14 + 2;
  }
  v41 = (_BYTE *)v14;
  v15 = strlen(s);
  v16 = (unsigned int)v41;
  v49 = (_BYTE *)(v15 + 1);
  v48 = (int)&v41[v15 + 1];
  v17 = v47 + v48;
  v47 += v48;
  if ( v47 <= 0x1000 || (v34 = _libc_alloca_cutoff(v17), v16 = (unsigned int)v41, v34) )
  {
    v44 = 0;
    v18 = alloca(v47 + 15);
    v19 = v39;
  }
  else
  {
    malloc(a1, v47);
    v16 = (unsigned int)v41;
    v19 = (_BYTE *)v35;
    if ( !v35 )
      return -1;
    v44 = v35;
  }
  if ( !v13 )
  {
    v13 = (int)&v19[v48 + 1];
    *(_BYTE *)v13 = 58;
    v42 = v19;
    v41 = (_BYTE *)v16;
    confstr(v16, a1, 0, (_BYTE *)(v13 + 1), v16);
    v16 = (unsigned int)v41;
    v19 = v42;
  }
  v20 = memcpy(&v19[v16 + 1], s, (unsigned int)v49);
  v45 = 0;
  v43 = 0;
  v48 = 0;
  v49 = v20;
  v46 = v20 - 1;
  *(v20 - 1) = 47;
  do
  {
    v21 = strchrnul((unsigned int *)v13, 58);
    v22 = v49;
    v23 = v21;
    if ( (unsigned int *)v13 != v21 )
      v22 = memcpy(&v46[v13 - (_DWORD)v21], (_BYTE *)v13, (unsigned int)v21 - v13);
    v41 = v22;
    execve((int)v22, a3);
    v24 = (int)v41;
    v25 = __readgsdword(0xFFFFFFE8);
    if ( v25 == 8 )
    {
      if ( !v48 )
      {
        for ( j = 0; *(_DWORD *)(a3 + 4 * j); ++j )
          ;
        v28 = 4 * j + 8;
        v40 = j + 1;
        if ( v28 + v47 <= 0x1000
          || (v42 = (_BYTE *)(4 * j + 8), v37 = _libc_alloca_cutoff(v28 + v47), v28 = (int)v42, v24 = (int)v41, v37) )
        {
          v29 = alloca(16 * ((v28 + 30) / 0x10u));
          v48 = (int)v39;
        }
        else
        {
          malloc(a1, (size_t)v42);
          v24 = (int)v41;
          v43 = v38;
          v48 = v38;
        }
        if ( !v48 )
          goto LABEL_34;
        v30 = v48;
        v26 = "/bin/sh";
        v31 = v40 == 1;
        *(_DWORD *)v48 = "/bin/sh";
        *(_DWORD *)(v30 + 4) = v24;
        if ( v31 )
          goto LABEL_40;
        v32 = v30;
        v33 = v40;
        do
        {
          *(_DWORD *)(v32 + 4 * v33) = *(_DWORD *)(a3 + 4 * v33 - 4);
          --v33;
        }
        while ( v33 != 1 );
      }
      v26 = *(const char **)v48;
LABEL_40:
      execve((int)v26, v48);
      v25 = __readgsdword(0xFFFFFFE8);
    }
    if ( v25 > 20 )
    {
      if ( v25 != 110 && v25 != 116 )
        return -1;
    }
    else if ( v25 < 19 && v25 != 2 )
    {
      if ( v25 != 13 )
        return -1;
      v45 = 1;
    }
    v13 = (int)v23 + 1;
  }
  while ( *(_BYTE *)v23 );
  if ( v45 )
    __writegsdword(0xFFFFFFE8, 0xDu);
LABEL_34:
  free(a1, v43);
  free(a1, v44);
  return -1;
}
// 8084F82: variable 'v9' is possibly undefined
// 808521B: variable 'v12' is possibly undefined
// 8085285: variable 'v35' is possibly undefined
// 80852E4: variable 'v38' is possibly undefined

//----- (080852F0) --------------------------------------------------------
int __fastcall getpid(int a1)
{
  __int64 v1; // rax

  HIDWORD(v1) = __readgsdword(0x6Cu);
  if ( SHIDWORD(v1) <= 0 )
  {
    if ( HIDWORD(v1) || (LODWORD(v1) = __readgsdword(0x68u), !(_DWORD)v1) )
    {
      v1 = dl_sysinfo(a1);
      if ( !HIDWORD(v1) )
        __writegsdword(0x68u, v1);
    }
  }
  else
  {
    LODWORD(v1) = HIDWORD(v1);
  }
  return v1;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08085330) --------------------------------------------------------
__int64 __fastcall getuid(int a1)
{
  return dl_sysinfo(a1);
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08085340) --------------------------------------------------------
__int64 __fastcall geteuid(int a1)
{
  return dl_sysinfo(a1);
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08085350) --------------------------------------------------------
__int64 __fastcall getgid(int a1)
{
  return dl_sysinfo(a1);
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08085360) --------------------------------------------------------
int __usercall _sysconf_check_spec@<eax>(_BYTE *a1@<eax>)
{
  char *v2; // eax
  char *v3; // esi
  int v4; // edx
  int v5; // ecx
  void *v6; // esp
  _BYTE *v7; // eax
  signed int v8; // eax
  unsigned int v10; // [esp+8h] [ebp-90h]
  _BYTE v11[8]; // [esp+10h] [ebp-88h] BYREF
  int v12; // [esp+18h] [ebp-80h]
  unsigned int v13; // [esp+1Ch] [ebp-7Ch]
  char v14[120]; // [esp+20h] [ebp-78h] BYREF

  v13 = __readgsdword(0xFFFFFFE8);
  v2 = (char *)_secure_getenv("GETCONF_DIR");
  v3 = v2;
  if ( v2 )
  {
    v4 = strlen(v2);
  }
  else
  {
    v4 = 16;
    v3 = "/usr/lib/getconf";
  }
  v12 = v4;
  v5 = strlen(a1);
  v6 = alloca(v12 + v5 + 26);
  v10 = v12;
  v12 = v5;
  v7 = mempcpy(v11, v3, v10);
  qmemcpy(v7, "/POSIX_V6_", 10);
  memcpy(v7 + 10, a1, v12 + 1);
  v8 = _xstat64(3, (int)v11, (int)v14);
  __writegsdword(0xFFFFFFE8, v13);
  return (v8 >> 31) | 1;
}
// 8085360: using guessed type char var_78[120];

//----- (08085440) --------------------------------------------------------
void __usercall sysconf(int a1@<ecx>, long double a2@<st0>, int a3)
{
  unsigned int v3; // eax
  const char *v4; // edx
  int v5; // ebx
  int v6; // ecx
  __int64 v7; // rax
  int v8; // eax
  char v9[32]; // [esp+14h] [ebp-38h] BYREF
  char v10[8]; // [esp+34h] [ebp-18h] BYREF
  char *v11; // [esp+3Ch] [ebp-10h] BYREF

  if ( (unsigned int)(a3 - 185) <= 0xE )
  {
    _cache_sysconf(a3);
    return;
  }
  if ( a3 == 34 )
  {
    v3 = getrlimit(11, (int)v9);
    v4 = "/proc/sys/kernel/rtsig-max";
    if ( !v3 )
      return;
  }
  else
  {
    if ( a3 > 34 )
    {
      if ( a3 >= 138 )
      {
        if ( a3 <= 139 )
          return;
        if ( a3 == 149 )
        {
          dl_sysinfo(v10);
          return;
        }
      }
      goto LABEL_22;
    }
    if ( !a3 )
    {
      getrlimit(3, (int)v9);
      return;
    }
    if ( a3 != 3 )
    {
LABEL_22:
      switch ( a3 )
      {
        case 0:
        case 3:
        case 5:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 129:
        case 130:
        case 131:
        case 132:
        case 133:
        case 134:
        case 135:
        case 136:
        case 137:
        case 138:
        case 139:
        case 140:
        case 141:
        case 142:
        case 143:
        case 144:
        case 145:
        case 146:
        case 147:
        case 148:
        case 149:
        case 150:
        case 151:
        case 152:
        case 153:
        case 154:
        case 155:
        case 156:
        case 157:
        case 158:
        case 159:
        case 160:
        case 161:
        case 162:
        case 163:
        case 164:
        case 165:
        case 166:
        case 167:
        case 168:
        case 169:
        case 170:
        case 171:
        case 172:
        case 173:
        case 174:
        case 175:
        case 176:
        case 177:
        case 180:
        case 181:
        case 182:
        case 183:
        case 184:
        case 185:
        case 186:
        case 187:
        case 188:
        case 189:
        case 190:
        case 191:
        case 192:
        case 193:
        case 194:
        case 195:
        case 196:
        case 197:
        case 198:
        case 235:
        case 236:
        case 237:
        case 238:
        case 242:
        case 243:
        case 244:
        case 245:
        case 246:
          return;
        case 1:
          _get_child_max();
          break;
        case 2:
          _getclktck();
          break;
        case 4:
          getdtablesize();
          break;
        case 6:
          _tzname_max(a2);
          if ( v8 > 6 )
            _tzname_max(a2);
          break;
        case 30:
          getpagesize();
          break;
        case 83:
          get_nprocs_conf();
          break;
        case 84:
          get_nprocs(a1);
          break;
        case 85:
          get_phys_pages(a2);
          break;
        case 86:
          get_avphys_pages(a2);
          break;
        case 127:
        case 239:
          _sysconf_check_spec("LP64_OFF64");
          break;
        case 128:
          _sysconf_check_spec("LPBIG_OFFBIG");
          break;
        case 178:
          _sysconf_check_spec("LP64_OFF64");
          break;
        case 179:
        case 240:
          _sysconf_check_spec("LPBIG_OFFBIG");
          break;
        default:
          __writegsdword(0xFFFFFFE8, 0x16u);
          break;
      }
      return;
    }
    v4 = "/proc/sys/kernel/ngroups_max";
  }
  v5 = _open_nocancel((int)v4, 0);
  if ( v5 == -1 )
    goto LABEL_22;
  while ( _read_nocancel(v5, (int)v9) == -1 && __readgsdword(0xFFFFFFE8) == 4 )
    ;
  v7 = dl_sysinfo(v6);
  if ( SHIDWORD(v7) <= 0 )
    goto LABEL_22;
  v9[HIDWORD(v7)] = 0;
  strtol(v9, &v11, 10);
  if ( v11 == v9 || *v11 != 10 && *v11 )
    goto LABEL_22;
}
// 808557B: variable 'v6' is possibly undefined
// 80856B6: variable 'v8' is possibly undefined
// 8085A70: variable 'a1' is possibly undefined
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 8085440: using guessed type char var_38[32];
// 8085440: using guessed type char var_18[8];

//----- (08085B80) --------------------------------------------------------
unsigned int __usercall confstr@<eax>(int a1@<ecx>, long double a2@<st0>, int a3, _BYTE *a4, unsigned int a5)
{
  unsigned int v5; // ebx
  char *v6; // edx
  int v8; // ebp
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  _DWORD *v12; // ebx
  int v13; // ecx
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // eax
  int v20[25]; // [esp+18h] [ebp-74h] BYREF

  if ( a3 > 1115 )
  {
    if ( a3 == 1132 )
      goto LABEL_15;
    if ( a3 > 1132 )
    {
      if ( a3 > 1139 )
      {
        if ( a3 > 1147 )
        {
          if ( a3 <= 1149 )
          {
            v5 = 18;
            v6 = "POSIXLY_CORRECT=1";
            goto LABEL_4;
          }
          goto LABEL_51;
        }
        if ( a3 >= 1142 )
          goto LABEL_3;
        goto LABEL_54;
      }
      if ( a3 >= 1138 )
        goto LABEL_3;
      if ( a3 <= 1135 )
      {
        if ( a3 >= 1134 )
          goto LABEL_3;
        goto LABEL_15;
      }
      if ( a3 != 1136 )
        goto LABEL_15;
    }
    else
    {
      if ( a3 == 1121 )
        goto LABEL_15;
      if ( a3 > 1121 )
      {
        if ( a3 != 1124 && a3 != 1125 )
          goto LABEL_3;
        goto LABEL_54;
      }
      if ( a3 <= 1119 )
      {
        if ( a3 >= 1118 )
          goto LABEL_3;
        goto LABEL_15;
      }
    }
LABEL_42:
    v5 = 48;
    v6 = "-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64";
    goto LABEL_4;
  }
  if ( a3 < 1110 )
  {
    if ( a3 > 1006 )
    {
      if ( a3 != 1104 )
      {
        if ( a3 <= 1104 )
        {
          if ( a3 != 1101 )
          {
            if ( a3 > 1101 )
              goto LABEL_3;
            if ( a3 != 1007 )
            {
              if ( a3 == 1100 )
                goto LABEL_15;
LABEL_51:
              v5 = 0;
              __writegsdword(0xFFFFFFE8, 0x16u);
              return v5;
            }
LABEL_64:
            v5 = 22;
            v6 = "-D_LARGEFILE64_SOURCE";
            goto LABEL_4;
          }
LABEL_15:
          v5 = 5;
          v6 = "-m32";
          goto LABEL_4;
        }
        if ( a3 <= 1107 )
        {
          if ( a3 >= 1106 )
            goto LABEL_3;
          goto LABEL_15;
        }
LABEL_54:
        sysconf(a1, a2, 239);
        v6 = (char *)&unk_80C86D9;
        v5 = ((v16 >> 31) & 0xFFFFFFFC) + 5;
        if ( v16 >= 0 )
          v6 = "-m64";
        goto LABEL_4;
      }
      goto LABEL_42;
    }
    if ( a3 >= 1005 )
      goto LABEL_3;
    if ( a3 == 5 )
    {
      qmemcpy(v20, "POSIX_V7_ILP32_OFF32\nPOSIX_V7_ILP32_OFFBIG", 42);
      v5 = 43;
      v8 = 42;
      sysconf(a1, a2, 239);
      if ( v14 > 0 )
      {
        qmemcpy((char *)&v20[10] + 2, "\nPOSIX_V7_LP64_OFF64", 20);
        LOBYTE(v5) = 63;
        LOWORD(v8) = 62;
      }
      sysconf(v13, a2, 240);
      v6 = (char *)v20;
      if ( v15 <= 0 )
        goto LABEL_41;
      v12 = (int *)((char *)v20 + v5);
      *((_BYTE *)v20 + v8) = 10;
      *v12 = 1230196560;
      v12[1] = 928407384;
    }
    else
    {
      if ( a3 > 5 )
      {
        if ( a3 > 1002 )
        {
          if ( a3 != 1003 )
            goto LABEL_64;
        }
        else
        {
          if ( a3 >= 1001 )
            goto LABEL_3;
          if ( a3 != 1000 )
            goto LABEL_51;
        }
        v5 = 43;
        v6 = "-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64";
        goto LABEL_4;
      }
      if ( a3 == 2 )
      {
        v5 = 11;
        v6 = "glibc 2.15";
        goto LABEL_4;
      }
      if ( a3 > 2 )
      {
        if ( a3 == 3 )
        {
          v5 = 10;
          v6 = "NPTL 2.15";
          goto LABEL_4;
        }
        qmemcpy(v20, "XBS5_ILP32_OFF32\nXBS5_ILP32_OFFBIG", 34);
        v5 = 35;
        v8 = 34;
        sysconf(a1, a2, 127);
        if ( v18 > 0 )
        {
          qmemcpy((char *)&v20[8] + 2, "\nXBS5_LP64_OFF64", 16);
          LOBYTE(v5) = 51;
          LOWORD(v8) = 50;
        }
        sysconf(v17, a2, 128);
        v6 = (char *)v20;
        if ( v19 > 0 )
        {
          *((_BYTE *)v20 + v8) = 10;
          qmemcpy((char *)v20 + v5, "XBS5_LPBIG_OFFBIG", 17);
          v5 = v8 + 19;
          v8 += 18;
        }
        goto LABEL_41;
      }
      v5 = 14;
      v6 = "/bin:/usr/bin";
      if ( !a3 )
        goto LABEL_4;
      if ( a3 != 1 )
        goto LABEL_51;
      qmemcpy(v20, "POSIX_V6_ILP32_OFF32\nPOSIX_V6_ILP32_OFFBIG", 42);
      v5 = 43;
      v8 = 42;
      sysconf(a1, a2, 178);
      if ( v10 > 0 )
      {
        qmemcpy((char *)&v20[10] + 2, "\nPOSIX_V6_LP64_OFF64", 20);
        LOBYTE(v5) = 63;
        LOWORD(v8) = 62;
      }
      sysconf(v9, a2, 179);
      v6 = (char *)v20;
      if ( v11 <= 0 )
      {
LABEL_41:
        *((_BYTE *)v20 + v8) = 0;
        goto LABEL_4;
      }
      v12 = (int *)((char *)v20 + v5);
      *((_BYTE *)v20 + v8) = 10;
      *v12 = 1230196560;
      v12[1] = 911630168;
    }
    qmemcpy(v12 + 2, "_LPBIG_OFFBIG", 13);
    v5 = v8 + 23;
    v8 += 22;
    goto LABEL_41;
  }
LABEL_3:
  v5 = 1;
  v6 = (char *)&unk_80C86D9;
LABEL_4:
  if ( a5 && a4 )
  {
    if ( v5 <= a5 )
    {
      memcpy(a4, v6, v5);
    }
    else
    {
      memcpy(a4, v6, a5 - 1);
      a4[a5 - 1] = 0;
    }
  }
  return v5;
}
// 8085C5C: conditional instruction was optimized away because %arg_0.4==45D
// 8085F56: conditional instruction was optimized away because %arg_0.4==475
// 8086004: conditional instruction was optimized away because %arg_0.4==3EC
// 8086060: conditional instruction was optimized away because %arg_0.4==455
// 8086080: conditional instruction was optimized away because %arg_0.4==471
// 8086099: conditional instruction was optimized away because %arg_0.4==4
// 8085DA3: variable 'v10' is possibly undefined
// 8085DE3: variable 'v9' is possibly undefined
// 8085DEE: variable 'v11' is possibly undefined
// 8085EB2: variable 'v14' is possibly undefined
// 8085EF2: variable 'v13' is possibly undefined
// 8085EFD: variable 'v15' is possibly undefined
// 8085F9B: variable 'v16' is possibly undefined
// 8086101: variable 'v18' is possibly undefined
// 8086139: variable 'v17' is possibly undefined
// 8086144: variable 'v19' is possibly undefined

//----- (08086190) --------------------------------------------------------
unsigned int __fastcall sched_yield(int a1)
{
  unsigned int result; // eax

  result = dl_sysinfo(a1);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080861B0) --------------------------------------------------------
int _get_child_max()
{
  unsigned int v0; // eax
  int v1; // edx
  int v3[5]; // [esp+18h] [ebp-14h] BYREF

  v0 = getrlimit(6, (int)v3);
  v1 = -1;
  if ( !v0 )
    return v3[0];
  return v1;
}
// 80861B0: using guessed type int var_14[5];

//----- (080861E0) --------------------------------------------------------
unsigned int __cdecl _xstat64(int a1, int a2, int a3)
{
  unsigned int result; // eax

  result = dl_sysinfo(a3);
  if ( result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08086210) --------------------------------------------------------
unsigned int __cdecl _openat_nocancel(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08086260) --------------------------------------------------------
int __usercall openat@<eax>(int a1@<ebp>, int a2, int a3)
{
  unsigned int v3; // esi
  int v5; // edi

  if ( __readgsdword(0xCu) )
  {
    v5 = _libc_enable_asynccancel();
    v3 = dl_sysinfo(a3);
    if ( v3 > 0xFFFFF000 )
    {
      __writegsdword(0xFFFFFFE8, -v3);
      v3 = -1;
    }
    _libc_disable_asynccancel(v5, a1);
  }
  else
  {
    v3 = dl_sysinfo(a3);
    if ( v3 > 0xFFFFF000 )
    {
      __writegsdword(0xFFFFFFE8, -v3);
      return -1;
    }
  }
  return v3;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08086310) --------------------------------------------------------
int __usercall _openat_2@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, char a5)
{
  if ( (a5 & 0x40) != 0 )
    _fortify_fail((int)"invalid openat call: O_CREAT without mode", a2);
  return openat(a1, a3, a4);
}

//----- (08086350) --------------------------------------------------------
int __usercall close@<eax>(int a1@<ebp>, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // ecx
  unsigned int v5; // [esp-4h] [ebp-4h]

  if ( !__readgsdword(0xCu) )
    return _close_nocancel(a2);
  v3 = _libc_enable_asynccancel();
  v5 = dl_sysinfo(v3);
  _libc_disable_asynccancel(v4, a1);
  result = v5;
  if ( v5 >= 0xFFFFF001 )
    return _syscall_error(v5);
  return result;
}
// 8086396: variable 'v4' is possibly undefined
// 808635A: using guessed type _DWORD __cdecl _close_nocancel(_DWORD);
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0808635A) --------------------------------------------------------
unsigned int __fastcall _close_nocancel(int a1)
{
  unsigned int result; // eax

  result = dl_sysinfo(a1);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080863B0) --------------------------------------------------------
unsigned int __cdecl access(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080863E0) --------------------------------------------------------
_BYTE *__cdecl getcwd(_BYTE *a1, unsigned int a2)
{
  _BYTE *v2; // esi
  int v3; // eax
  int v4; // ecx
  _BYTE *v5; // eax
  _BYTE *dest; // ebp
  signed int v7; // eax
  unsigned int v9; // eax
  _BYTE *v10; // eax
  _BYTE *v11; // ebx
  int v12; // ecx
  int v13; // esi
  int *v14; // esi
  char v15; // di
  int v16; // eax
  char v17; // dl
  unsigned int v18; // kr04_4
  unsigned int v19; // edi
  unsigned int v20; // eax
  _BYTE *v21; // eax
  _BYTE *v22; // eax
  unsigned int v23; // eax
  unsigned int v24; // edi
  char v25; // bl
  size_t n; // ebx
  _BYTE *v27; // eax
  int v28; // [esp+20h] [ebp-CCh]
  _BYTE *v29; // [esp+20h] [ebp-CCh]
  int v30; // [esp+24h] [ebp-C8h]
  int v31; // [esp+30h] [ebp-BCh]
  int v32; // [esp+34h] [ebp-B8h]
  __int64 v33; // [esp+38h] [ebp-B4h]
  _BYTE *v34; // [esp+40h] [ebp-ACh]
  unsigned int v35; // [esp+44h] [ebp-A8h]
  _BYTE *v36; // [esp+48h] [ebp-A4h]
  int v37; // [esp+4Ch] [ebp-A0h]
  __int64 v38; // [esp+50h] [ebp-9Ch]
  _BYTE *src; // [esp+5Ch] [ebp-90h]
  unsigned int v40; // [esp+60h] [ebp-8Ch]
  __int64 v41; // [esp+64h] [ebp-88h]
  int v42; // [esp+6Ch] [ebp-80h]
  __int64 v43[2]; // [esp+70h] [ebp-7Ch] BYREF
  int v44; // [esp+80h] [ebp-6Ch]
  __int64 v45; // [esp+C8h] [ebp-24h]

  v2 = a1;
  if ( a2 )
  {
    v4 = a2;
    if ( a1 )
    {
      dest = a1;
      goto LABEL_9;
    }
  }
  else
  {
    if ( a1 )
    {
      v2 = 0;
      __writegsdword(0xFFFFFFE8, 0x16u);
      return v2;
    }
    v3 = getpagesize();
    v4 = 4096;
    if ( v3 >= 4096 )
      v4 = v3;
  }
  v28 = v4;
  v5 = (_BYTE *)malloc(v4);
  v4 = v28;
  dest = v5;
  if ( !v5 )
    return 0;
LABEL_9:
  v7 = dl_sysinfo(v4);
  if ( (unsigned int)v7 > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -v7);
  }
  else if ( v7 >= 0 )
  {
    if ( !a2 && !a1 )
    {
      realloc(dest, v7);
      v2 = v10;
    }
    if ( !v2 )
      return dest;
    return v2;
  }
  v9 = __readgsdword(0xFFFFFFE8);
  if ( v9 != 36 )
  {
    v2 = 0;
    if ( !a1 )
    {
      if ( v9 == 34 && !a2 )
        _assert_fail(
          "__libc_errno != 34 || buf != ((void *)0) || size != 0",
          "../sysdeps/unix/sysv/linux/getcwd.c",
          155,
          "__getcwd");
      v2 = 0;
      free(dest);
    }
    return v2;
  }
  if ( a2 )
  {
    v34 = dest;
    v40 = 36;
    v35 = a2;
LABEL_25:
    v11 = &dest[v35];
    dest[v35 - 1] = 0;
    if ( (_lxstat64(3, (int)".", (int)v43) & 0x80000000) == 0 )
    {
      v13 = v45;
      v33 = v43[0];
      if ( (_lxstat64(3, (int)&unk_80CAC6F, (int)v43) & 0x80000000) == 0 )
      {
        src = v11 - 1;
        v32 = v13;
        v41 = v43[0];
        v37 = v45;
        if ( v13 == (_DWORD)v45 && v43[0] == v33 )
          goto LABEL_85;
        v14 = 0;
        v30 = -100;
        v36 = dest;
        while ( 2 )
        {
          v30 = _openat64_nocancel(v30, (int)"..");
          if ( v30 < 0 )
          {
            dest = v36;
            v25 = 0;
          }
          else
          {
            if ( (_fxstat64(3, v30, (int)v43) & 0x80000000) == 0 )
            {
              if ( v14 && closedir((int)v14) || (v38 = v43[0], v42 = v45, (v14 = fdopendir((int)dest, v30)) == 0) )
              {
                dest = v36;
                v25 = 1;
              }
              else
              {
                v15 = 1;
                while ( 1 )
                {
                  while ( 1 )
                  {
                    __writegsdword(0xFFFFFFE8, 0);
                    readdir(v14);
                    if ( v16 )
                      break;
                    v23 = __readgsdword(0xFFFFFFE8);
                    if ( v23 )
                    {
                      dest = v36;
                      v24 = v23;
                      goto LABEL_67;
                    }
                    if ( !v15 )
                    {
                      v24 = 2;
                      dest = v36;
                      __writegsdword(0xFFFFFFE8, 2u);
                      goto LABEL_67;
                    }
                    v15 = 0;
                    rewinddir(v14);
                  }
                  v17 = *(_BYTE *)(v16 + 10);
                  if ( (!v17 || v17 == 4)
                    && (*(_BYTE *)(v16 + 11) != 46 || *(_BYTE *)(v16 + 12) && *(_WORD *)(v16 + 12) != 46)
                    && (!v15 || v33 != v38 || *(_DWORD *)v16 == v32) )
                  {
                    dest = (_BYTE *)(v16 + 11);
                    if ( _fxstatat64(3, v30, v16 + 11) >= 0 && (v44 & 0xF000) == 0x4000 && v43[0] == v33 && v45 == v32 )
                      break;
                  }
                }
                v18 = strlen(dest) + 1;
                v19 = v18 - 1;
                if ( v18 - 1 >= src - v36 )
                {
                  if ( a2 )
                  {
                    v24 = 34;
                    dest = v36;
                    __writegsdword(0xFFFFFFE8, 0x22u);
                  }
                  else
                  {
                    v20 = v35;
                    if ( v19 >= v35 )
                      v20 = v18 - 1;
                    v31 = 2 * v20;
                    realloc(v36, 2 * v20);
                    if ( v21 )
                    {
                      v29 = v21;
                      v22 = memcpy(&v21[src - &v36[v35] + v31], &v21[src - v36], &v36[v35] - src);
                      v35 = v31;
                      v36 = v29;
                      src = v22;
                      goto LABEL_51;
                    }
                    dest = v36;
                    v24 = __readgsdword(0xFFFFFFE8);
                  }
LABEL_67:
                  v25 = 0;
                  goto LABEL_68;
                }
LABEL_51:
                v32 = v42;
                memcpy(&src[-v19], dest, v19);
                src[-v18] = 47;
                src -= v18;
                if ( v37 != v42 || v38 != v41 )
                {
                  v33 = v38;
                  continue;
                }
                dest = v36;
                if ( !closedir((int)v14) )
                {
                  v11 = &v36[v35];
LABEL_85:
                  if ( src == &dest[v35 - 1] )
                    *--src = 47;
                  n = v11 - src;
                  memmove(dest, src, n);
                  if ( !a2 )
                  {
                    realloc(dest, n);
                    v34 = v27;
                  }
                  v2 = v34;
                  __writegsdword(0xFFFFFFE8, v40);
                  if ( !v34 )
                    return dest;
                  return v2;
                }
                v25 = 0;
              }
              goto LABEL_77;
            }
            dest = v36;
            v25 = 1;
          }
          break;
        }
        v24 = __readgsdword(0xFFFFFFE8);
        if ( v14 )
LABEL_68:
          closedir((int)v14);
        goto LABEL_69;
      }
    }
    v25 = 0;
LABEL_77:
    v24 = __readgsdword(0xFFFFFFE8);
LABEL_69:
    if ( v25 )
      dl_sysinfo(v12);
    if ( !v34 )
      free(dest);
    __writegsdword(0xFFFFFFE8, v24);
    goto LABEL_55;
  }
  if ( a1 )
  {
    v34 = dest;
    __writegsdword(0xFFFFFFE8, 0x16u);
  }
  else
  {
    free(dest);
    v40 = __readgsdword(0xFFFFFFE8);
    v34 = 0;
    dest = (_BYTE *)malloc(4097);
    if ( dest )
    {
      v35 = 4097;
      goto LABEL_25;
    }
  }
LABEL_55:
  v2 = 0;
  if ( !a1 && a2 )
    free(v34);
  return v2;
}
// 8086508: variable 'v10' is possibly undefined
// 80866B9: variable 'v16' is possibly undefined
// 80867B2: variable 'v21' is possibly undefined
// 808693B: variable 'v12' is possibly undefined
// 8086A6C: variable 'v27' is possibly undefined
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08086B10) --------------------------------------------------------
unsigned int __cdecl getrlimit(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08086B40) --------------------------------------------------------
int __cdecl brk(unsigned int a1)
{
  int v1; // ecx
  int result; // eax

  _curbrk = dl_sysinfo(v1);
  result = 0;
  if ( a1 > _curbrk )
  {
    __writegsdword(0xFFFFFFE8, 0xCu);
    return -1;
  }
  return result;
}
// 8086B4A: variable 'v1' is possibly undefined
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80F0DDC: using guessed type int _curbrk;

//----- (08086B80) --------------------------------------------------------
unsigned int __usercall writev@<eax>(int a1@<ebp>, int a2, int a3)
{
  unsigned int v3; // eax
  unsigned int v4; // ebx
  int v6; // esi

  if ( __readgsdword(0xCu) )
  {
    v6 = _libc_enable_asynccancel();
    v4 = dl_sysinfo(a3);
    if ( v4 > 0xFFFFF000 )
    {
      __writegsdword(0xFFFFFFE8, -v4);
      v4 = -1;
    }
    _libc_disable_asynccancel(v6, a1);
  }
  else
  {
    v3 = dl_sysinfo(a3);
    if ( v3 > 0xFFFFF000 )
    {
      v4 = -1;
      __writegsdword(0xFFFFFFE8, -v3);
    }
    else
    {
      return v3;
    }
  }
  return v4;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08086C20) --------------------------------------------------------
int getpagesize()
{
  int result; // eax

  result = dl_pagesize;
  if ( !dl_pagesize )
    _assert_fail("_dl_pagesize != 0", "../sysdeps/unix/sysv/linux/getpagesize.c", 31, "__getpagesize");
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EF5B8: using guessed type int dl_pagesize;

//----- (08086C60) --------------------------------------------------------
int getdtablesize()
{
  signed int v0; // eax
  int v1; // edx
  int v3[5]; // [esp+18h] [ebp-14h] BYREF

  v0 = getrlimit(7, (int)v3);
  v1 = 256;
  if ( v0 >= 0 )
    return v3[0];
  return v1;
}
// 8086C60: using guessed type int var_14[5];

//----- (08086C90) --------------------------------------------------------
unsigned int __cdecl mmap64(int a1, int a2, int a3, int a4, int a5, __int64 a6)
{
  unsigned int result; // eax

  if ( (a6 & 0xFFF) != 0 || HIDWORD(a6) >> 12 )
    return _syscall_error(-22);
  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08086CF0) --------------------------------------------------------
int __usercall trecurse@<eax>(int a1@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3@<ecx>)
{
  if ( !*(_DWORD *)(a1 + 4) && !*(_DWORD *)(a1 + 8) )
    return a2(a1, 3, a3);
  a2(a1, 0, a3);
  if ( *(_DWORD *)(a1 + 4) )
    trecurse(a3 + 1, a2);
  a2(a1, 1, a3);
  if ( *(_DWORD *)(a1 + 8) )
    trecurse(a3 + 1, a2);
  return a2(a1, 2, a3);
}

//----- (08086DA0) --------------------------------------------------------
void __usercall tdestroy_recurse(_DWORD *a1@<eax>, long double (__cdecl *a2)(_DWORD)@<edx>, int a3@<ecx>)
{
  long double v5; // fst7

  if ( a1[1] )
    ((void (*)(void))tdestroy_recurse)();
  if ( a1[2] )
    tdestroy_recurse(a3, a2);
  v5 = a2(*a1);
  free(v5, (int)a1);
}
// 8086DC4: variable 'a3' is possibly undefined

//----- (08086DF0) --------------------------------------------------------
int __usercall maybe_split_for_insert_isra_0@<eax>(
        int result@<eax>,
        int *a2@<edx>,
        int *a3@<ecx>,
        int a4,
        int a5,
        int a6)
{
  int v6; // esi
  int v7; // edi
  int v8; // esi
  int v9; // edx
  int v10; // esi

  v6 = *(_DWORD *)(result + 8);
  if ( a6 == 1 )
  {
    *(_BYTE *)(result + 12) |= 1u;
    if ( !v6 )
      goto LABEL_8;
  }
  else
  {
    if ( !v6 )
      return result;
    v7 = *(_DWORD *)(result + 4);
    if ( !v7 || (*(_BYTE *)(v6 + 12) & 1) == 0 || (*(_BYTE *)(v7 + 12) & 1) == 0 )
      return result;
    *(_BYTE *)(result + 12) |= 1u;
  }
  *(_BYTE *)(v6 + 12) &= ~1u;
LABEL_8:
  v8 = *(_DWORD *)(result + 4);
  if ( v8 )
    *(_BYTE *)(v8 + 12) &= ~1u;
  if ( a2 )
  {
    v9 = *a2;
    if ( (*(_BYTE *)(v9 + 12) & 1) != 0 )
    {
      v10 = *a3;
      if ( a5 > 0 == a4 > 0 )
      {
        *a3 = v9;
        *(_BYTE *)(v9 + 12) &= ~1u;
        *(_BYTE *)(v10 + 12) |= 1u;
        if ( a4 < 0 )
        {
          result = *(_DWORD *)(v9 + 8);
          *(_DWORD *)(v9 + 8) = v10;
          *(_DWORD *)(v10 + 4) = result;
        }
        else
        {
          result = *(_DWORD *)(v9 + 4);
          *(_DWORD *)(v9 + 4) = v10;
          *(_DWORD *)(v10 + 8) = result;
        }
      }
      else
      {
        *(_BYTE *)(v9 + 12) |= 1u;
        *(_BYTE *)(v10 + 12) |= 1u;
        *(_BYTE *)(result + 12) &= ~1u;
        if ( a4 < 0 )
        {
          *(_DWORD *)(v9 + 4) = *(_DWORD *)(result + 8);
          *(_DWORD *)(result + 8) = v9;
          *(_DWORD *)(v10 + 8) = *(_DWORD *)(result + 4);
          *(_DWORD *)(result + 4) = v10;
        }
        else
        {
          *(_DWORD *)(v9 + 8) = *(_DWORD *)(result + 4);
          *(_DWORD *)(result + 4) = v9;
          *(_DWORD *)(v10 + 4) = *(_DWORD *)(result + 8);
          *(_DWORD *)(result + 8) = v10;
        }
        *a3 = result;
      }
    }
  }
  return result;
}

//----- (08086F20) --------------------------------------------------------
_DWORD *__cdecl tsearch(int a1, int *a2, int (__cdecl *a3)(int, _DWORD))
{
  int *v3; // ebp
  _DWORD *v4; // ebx
  int *v5; // esi
  int v6; // edx
  int v7; // edi
  int *v8; // eax
  int *v9; // ebx
  int *v10; // esi
  int v11; // eax
  int v13; // [esp+14h] [ebp-28h]
  int *v14; // [esp+18h] [ebp-24h]
  int v15; // [esp+1Ch] [ebp-20h]

  v3 = a2;
  if ( !a2 )
    return 0;
  v4 = 0;
  if ( *a2 )
  {
    *(_BYTE *)(*a2 + 12) &= ~1u;
    v4 = (_DWORD *)*a2;
  }
  v15 = 0;
  v5 = 0;
  v13 = 0;
  v14 = 0;
  while ( v4 )
  {
    v7 = a3(a1, *v4);
    if ( !v7 )
      return v4;
    maybe_split_for_insert_isra_0(*v3, v14, v5, v13, v15, 0);
    v8 = v4 + 1;
    v9 = v4 + 2;
    if ( v7 >= 0 )
      v8 = v9;
    v4 = (_DWORD *)*v8;
    if ( !*v8 )
    {
      v10 = v8;
      goto LABEL_12;
    }
    v6 = v13;
    v5 = v14;
    v13 = v7;
    v14 = v3;
    v3 = v8;
    v15 = v6;
  }
  v7 = v13;
  v10 = v3;
LABEL_12:
  v4 = 0;
  v11 = malloc(16);
  if ( v11 )
  {
    v4 = (_DWORD *)v11;
    *v10 = v11;
    *(_BYTE *)(v11 + 12) |= 1u;
    *(_DWORD *)v11 = a1;
    *(_DWORD *)(v11 + 8) = 0;
    *(_DWORD *)(v11 + 4) = 0;
    if ( v10 != v3 )
      maybe_split_for_insert_isra_0(*v10, v3, v14, v7, v13, 1);
  }
  return v4;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);

//----- (08087050) --------------------------------------------------------
_DWORD *__cdecl tfind(int a1, _DWORD *a2, int (__cdecl *a3)(int, _DWORD))
{
  _DWORD *v3; // edx
  int v4; // eax
  _DWORD *v5; // ebx
  _DWORD *v7; // ebx

  v3 = a2;
  if ( !a2 )
    return 0;
  while ( 1 )
  {
    v7 = (_DWORD *)*v3;
    if ( !*v3 )
      break;
    v4 = a3(a1, *v7);
    if ( !v4 )
      break;
    v3 = v7 + 1;
    v5 = v7 + 2;
    if ( v4 >= 0 )
      v3 = v5;
  }
  return v7;
}

//----- (080870A0) --------------------------------------------------------
int __usercall tdelete@<eax>(long double a1@<st0>, int a2, int **a3, int (__cdecl *a4)(int, int))
{
  int v4; // ebx
  int *v5; // edi
  unsigned int v6; // ecx
  int *v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // eax
  unsigned int v11; // ecx
  int v12; // esi
  void *v14; // esp
  _BYTE *v15; // eax
  int v16; // edi
  int v17; // ecx
  int v18; // esi
  char v19; // al
  _BYTE *v20; // edi
  int v21; // edx
  int v22; // eax
  char v23; // bl
  int v24; // ebx
  int v25; // ebx
  char v26; // cl
  int v27; // esi
  int v28; // ecx
  _DWORD *v29; // ecx
  int v30; // ebx
  char v31; // al
  int v32; // eax
  _BYTE *v33; // eax
  int v34; // esi
  char v35; // al
  int v36; // eax
  _DWORD *v37; // ecx
  int v38; // eax
  int v39; // eax
  int v40; // eax
  unsigned int v41; // esi
  int v42; // edi
  int v43; // ebx
  int v44; // eax
  void *v45; // esp
  _DWORD *v46; // eax
  _BYTE v47[184]; // [esp+10h] [ebp-F8h] BYREF
  int v48; // [esp+C8h] [ebp-40h]
  unsigned int v49; // [esp+D0h] [ebp-38h]
  unsigned int v50; // [esp+D4h] [ebp-34h]
  int v51; // [esp+D8h] [ebp-30h]
  int v52; // [esp+DCh] [ebp-2Ch]
  int v53; // [esp+E0h] [ebp-28h]
  int v54; // [esp+E4h] [ebp-24h]
  int v55; // [esp+E8h] [ebp-20h]
  _BYTE *v56; // [esp+ECh] [ebp-1Ch]

  v4 = (int)a3;
  v56 = v47;
  if ( !a3 )
    return 0;
  v5 = *a3;
  if ( !*a3 )
    return 0;
  v6 = 0;
  v7 = *a3;
  v54 = 40;
  v8 = (int)v5;
  v52 = 0;
  while ( 1 )
  {
    v9 = *v7;
    v51 = v8;
    v50 = v6;
    v10 = a4(a2, v9);
    v11 = v50;
    v12 = v10;
    if ( !v10 )
      break;
    if ( v52 == v54 )
    {
      v55 = v50 + 110;
      v54 = v52 + 20;
      v14 = alloca(16 * ((v50 + 110) / 0x10));
      v15 = memcpy(v47, v56, v50);
      v11 = v50;
      v56 = v15;
    }
    v8 = *(_DWORD *)v4;
    ++v52;
    *(_DWORD *)&v56[v11] = v4;
    v4 = v8 + 4;
    if ( v12 >= 0 )
      v4 = v8 + 8;
    v6 = v11 + 4;
    v7 = *(int **)v4;
    if ( !*(_DWORD *)v4 )
      return 0;
  }
  v16 = v51;
  v17 = v52;
  v18 = *(_DWORD *)(*(_DWORD *)v4 + 4);
  v55 = *(_DWORD *)v4;
  if ( *(_DWORD *)(v55 + 8) )
  {
    if ( v18 )
    {
      v40 = v4;
      v53 = v51;
      v41 = 4 * v52;
      v42 = v55 + 8;
      v52 = v4;
      v43 = v17;
      v48 = v40;
      while ( 1 )
      {
        if ( v43 == v54 )
        {
          v54 = v43 + 20;
          v49 = v41 + 110;
          v45 = alloca(16 * ((v41 + 110) / 0x10));
          v56 = memcpy(v47, v56, v41);
        }
        ++v43;
        *(_DWORD *)&v56[v41] = v48;
        v44 = *(_DWORD *)v42;
        v41 += 4;
        if ( !*(_DWORD *)(*(_DWORD *)v42 + 4) )
          break;
        v48 = v42;
        v42 = v44 + 4;
      }
      v17 = v43;
      v16 = v53;
      v4 = v52;
      v54 = v44;
      goto LABEL_56;
    }
LABEL_33:
    v54 = v55;
LABEL_56:
    v18 = *(_DWORD *)(v54 + 8);
    goto LABEL_14;
  }
  if ( !v18 )
    goto LABEL_33;
  v54 = v55;
LABEL_14:
  if ( v17 )
  {
    v39 = **(_DWORD **)&v56[4 * v17 - 4];
    if ( *(_DWORD *)(v39 + 8) == v54 )
      *(_DWORD *)(v39 + 8) = v18;
    else
      *(_DWORD *)(v39 + 4) = v18;
  }
  else
  {
    *(_DWORD *)v4 = v18;
  }
  if ( v54 != v55 )
    *(_DWORD *)v55 = *(_DWORD *)v54;
  if ( (*(_BYTE *)(v54 + 12) & 1) != 0 )
    goto LABEL_31;
  if ( !v17 )
    goto LABEL_66;
  v55 = v16;
  while ( 1 )
  {
    if ( v18 )
    {
      v19 = *(_BYTE *)(v18 + 12);
      if ( (v19 & 1) != 0 )
      {
        v16 = v55;
        goto LABEL_63;
      }
    }
    v20 = *(_BYTE **)&v56[4 * v17 - 4];
    v21 = *(_DWORD *)v20;
    v22 = *(_DWORD *)(*(_DWORD *)v20 + 4);
    if ( v22 == v18 )
      break;
    v23 = *(_BYTE *)(v22 + 12);
    if ( (v23 & 1) != 0 )
    {
      *(_BYTE *)(v22 + 12) = v23 & 0xFE;
      *(_BYTE *)(v21 + 12) |= 1u;
      v24 = *(_DWORD *)(v22 + 8);
      *(_DWORD *)(v22 + 8) = v21;
      *(_DWORD *)(v21 + 4) = v24;
      *(_DWORD *)v20 = v22;
      v20 = (_BYTE *)(v22 + 8);
      *(_DWORD *)&v56[4 * v17] = v22 + 8;
      v22 = *(_DWORD *)(v21 + 4);
      ++v17;
    }
    v25 = *(_DWORD *)(v22 + 8);
    if ( v25 && (*(_BYTE *)(v25 + 12) & 1) != 0 )
    {
      v26 = *(_BYTE *)(v25 + 12);
      v27 = *(_DWORD *)(v22 + 4);
      v56 = v20;
      v16 = v55;
      if ( !v27 || (*(_BYTE *)(v27 + 12) & 1) == 0 )
      {
        *(_BYTE *)(v25 + 12) = *(_BYTE *)(v21 + 12) & 1 | v26 & 0xFE;
        *(_DWORD *)(v21 + 4) = *(_DWORD *)(v25 + 8);
        v28 = *(_DWORD *)(v25 + 4);
        *(_DWORD *)(v25 + 4) = v22;
        *(_DWORD *)(v22 + 8) = v28;
        v29 = v56;
        *(_DWORD *)(v25 + 8) = v21;
        *v29 = v25;
        *(_BYTE *)(v21 + 12) &= ~1u;
        goto LABEL_31;
      }
      goto LABEL_37;
    }
    v27 = *(_DWORD *)(v22 + 4);
    if ( v27 && (*(_BYTE *)(v27 + 12) & 1) != 0 )
    {
      v56 = v20;
      v16 = v55;
LABEL_37:
      LOBYTE(v55) = *(_BYTE *)(v21 + 12) & 1;
      *(_BYTE *)(v22 + 12) = v55 | *(_BYTE *)(v22 + 12) & 0xFE;
      *(_BYTE *)(v21 + 12) &= ~1u;
      *(_BYTE *)(v27 + 12) &= ~1u;
      *(_DWORD *)(v22 + 8) = v21;
      *(_DWORD *)(v21 + 4) = v25;
      *(_DWORD *)v56 = v22;
      goto LABEL_31;
    }
    *(_BYTE *)(v22 + 12) |= 1u;
LABEL_39:
    if ( !--v17 )
    {
      v16 = v55;
      v18 = v21;
LABEL_66:
      if ( !v18 )
        goto LABEL_31;
      v19 = *(_BYTE *)(v18 + 12);
LABEL_63:
      *(_BYTE *)(v18 + 12) = v19 & 0xFE;
      goto LABEL_31;
    }
    v18 = v21;
  }
  v30 = *(_DWORD *)(v21 + 8);
  v31 = *(_BYTE *)(v30 + 12);
  if ( (v31 & 1) != 0 )
  {
    *(_BYTE *)(v30 + 12) = v31 & 0xFE;
    *(_BYTE *)(v21 + 12) |= 1u;
    v32 = *(_DWORD *)(v30 + 4);
    *(_DWORD *)(v30 + 4) = v21;
    *(_DWORD *)(v21 + 8) = v32;
    v33 = v56;
    *(_DWORD *)v20 = v30;
    v20 = (_BYTE *)(v30 + 4);
    v30 = *(_DWORD *)(v21 + 8);
    *(_DWORD *)&v33[4 * v17++] = v20;
  }
  v34 = *(_DWORD *)(v30 + 4);
  if ( !v34 || (v35 = *(_BYTE *)(v34 + 12), (v35 & 1) == 0) )
  {
    v36 = *(_DWORD *)(v30 + 8);
    if ( v36 && (*(_BYTE *)(v36 + 12) & 1) != 0 )
    {
      v56 = v20;
      v16 = v55;
      goto LABEL_60;
    }
    *(_BYTE *)(v30 + 12) |= 1u;
    goto LABEL_39;
  }
  v56 = v20;
  v16 = v55;
  LOBYTE(v55) = v35;
  v36 = *(_DWORD *)(v30 + 8);
  if ( !v36 || (*(_BYTE *)(v36 + 12) & 1) == 0 )
  {
    *(_BYTE *)(v34 + 12) = *(_BYTE *)(v21 + 12) & 1 | v55 & 0xFE;
    v37 = v56;
    *(_DWORD *)(v21 + 8) = *(_DWORD *)(v34 + 4);
    v38 = *(_DWORD *)(v34 + 8);
    *(_DWORD *)(v34 + 8) = v30;
    *(_DWORD *)(v30 + 4) = v38;
    *(_DWORD *)(v34 + 4) = v21;
    *v37 = v34;
    *(_BYTE *)(v21 + 12) &= ~1u;
    goto LABEL_31;
  }
LABEL_60:
  LOBYTE(v55) = *(_BYTE *)(v21 + 12) & 1;
  *(_BYTE *)(v30 + 12) = v55 | *(_BYTE *)(v30 + 12) & 0xFE;
  *(_BYTE *)(v21 + 12) &= ~1u;
  *(_BYTE *)(v36 + 12) &= ~1u;
  v46 = v56;
  *(_DWORD *)(v21 + 8) = v34;
  *(_DWORD *)(v30 + 4) = v21;
  *v46 = v30;
LABEL_31:
  free(a1, v54);
  return v16;
}

//----- (080874E0) --------------------------------------------------------
int __cdecl twalk(int a1, int (__cdecl *a2)(int, int, int))
{
  int result; // eax

  result = a1;
  if ( a2 )
  {
    if ( a1 )
      return trecurse(a1, a2, 0);
  }
  return result;
}

//----- (08087500) --------------------------------------------------------
void __cdecl tdestroy(_DWORD *a1, long double (__cdecl *a2)(_DWORD))
{
  int v2; // ecx

  if ( a1 )
    tdestroy_recurse(a1, a2, v2);
}
// 808750C: variable 'v2' is possibly undefined

//----- (08087520) --------------------------------------------------------
int _getclktck()
{
  int result; // eax

  result = dl_clktck;
  if ( !dl_clktck )
    return 100;
  return result;
}
// 80F11CC: using guessed type int dl_clktck;

//----- (08087530) --------------------------------------------------------
__int64 __cdecl lseek64(int a1, int a2, int a3)
{
  unsigned int v3; // eax
  int v4; // ecx
  bool v5; // zf
  __int64 result; // rax
  __int64 v7; // [esp+8h] [ebp-14h]

  v3 = dl_sysinfo(a3);
  if ( v3 > 0xFFFFF000 )
  {
    v4 = -1;
    __writegsdword(0xFFFFFFE8, -v3);
    return v4;
  }
  v4 = v3;
  v5 = v3 == 0;
  result = v7;
  if ( !v5 )
    return v4;
  return result;
}
// 808756D: variable 'v7' is possibly undefined
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080875B0) --------------------------------------------------------
int __cdecl wctrans(char *s1)
{
  int v1; // ebp
  int result; // eax
  const char *s2; // ebx
  int v4; // esi

  v1 = *(_DWORD *)__readgsdword(0xFFFFFFDC);
  result = 0;
  s2 = *(const char **)(v1 + 80);
  if ( *s2 )
  {
    v4 = 0;
    do
    {
      if ( !strcmp(s1, s2) )
        return *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 108) + v4) + 36);
      ++v4;
      s2 = (const char *)(rawmemchr(s2, 0) + 1);
    }
    while ( *s2 );
    return 0;
  }
  return result;
}
// 8048230: using guessed type int __cdecl rawmemchr(_DWORD, _DWORD);

//----- (08087630) --------------------------------------------------------
unsigned int __cdecl towctrans(unsigned int a1, _DWORD *a2)
{
  unsigned int result; // eax
  unsigned int v3; // ebx
  int v4; // ebx
  int v5; // ecx

  result = a1;
  if ( a2 )
  {
    v3 = a1 >> *a2;
    if ( v3 < a2[1] )
    {
      v4 = a2[v3 + 5];
      if ( v4 )
      {
        v5 = *(_DWORD *)((char *)&a2[(a1 >> a2[2]) & a2[3]] + v4);
        if ( v5 )
          return *(_DWORD *)((char *)&a2[a1 & a2[4]] + v5) + a1;
      }
    }
  }
  return result;
}

//----- (08087690) --------------------------------------------------------
void __usercall __noreturn _chk_fail(long double a1@<st0>)
{
  _fortify_fail((int)"buffer overflow detected", a1);
}

//----- (080876A0) --------------------------------------------------------
int __cdecl _readonly_area(unsigned int a1, unsigned int a2)
{
  int *v2; // eax
  int *v3; // ebx
  int v4; // eax
  int v5; // eax
  unsigned int v6; // esi
  char v7; // dl
  char *v8; // eax
  unsigned int v9; // eax
  char *v10; // edx
  char v11; // bp
  int result; // eax
  char v13; // cl
  char v14; // cl
  unsigned int v15; // edx
  char *v16; // [esp+14h] [ebp-38h]
  unsigned int v17; // [esp+18h] [ebp-34h]
  char *v18; // [esp+20h] [ebp-2Ch] BYREF
  unsigned int v19; // [esp+24h] [ebp-28h] BYREF
  char *v20; // [esp+28h] [ebp-24h] BYREF
  char *v21; // [esp+2Ch] [ebp-20h] BYREF
  unsigned int v22; // [esp+54h] [ebp+8h]

  v17 = a2 + a1;
  v2 = fopen((int)"/proc/self/maps", "rce");
  v3 = v2;
  if ( v2 )
  {
    v4 = *v2;
    BYTE1(v4) |= 0x80u;
    *v3 = v4;
    v18 = 0;
    v19 = 0;
    while ( (*v3 & 0x10) == 0 )
    {
      getdelim(&v18, &v19, 10, v3);
      if ( v5 <= 0 )
        break;
      v6 = strtoul(v18, &v20, 16);
      if ( v20 == v18 )
        break;
      v7 = *v20;
      v8 = ++v20;
      if ( v7 != 45 )
        break;
      v9 = strtoul(v8, &v21, 16);
      v10 = v21;
      if ( v21 == v20 )
        break;
      v11 = *v21;
      v16 = ++v21;
      if ( v11 != 32 )
        break;
      if ( a1 < v9 && v17 > v6 )
      {
        v13 = v10[1];
        v21 = v10 + 2;
        if ( v13 != 114 )
          break;
        v14 = v16[1];
        v21 = v10 + 3;
        if ( v14 != 45 )
          break;
        if ( v17 <= v9 )
        {
          if ( v6 <= a1 )
          {
LABEL_19:
            fclose(v3);
            free(v18);
            return 1;
          }
          a2 = v6 + a2 - v17;
        }
        else
        {
          if ( v6 > a1 )
            v22 = v6 + a2;
          else
            v22 = a1 + a2;
          a2 = v22 - v9;
        }
        if ( !a2 )
          goto LABEL_19;
      }
    }
    fclose(v3);
    free(v18);
    return a2 == 0 ? 1 : -1;
  }
  else
  {
    v15 = __readgsdword(0xFFFFFFE8);
    if ( v15 == 13 )
      return 1;
    result = -1;
    if ( v15 == 2 )
      return 1;
  }
  return result;
}
// 8087716: variable 'v5' is possibly undefined
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);

//----- (08087890) --------------------------------------------------------
void __usercall __noreturn _fortify_fail(int a1@<eax>, long double a2@<st0>)
{
  const char *v3; // edx

  while ( 1 )
  {
    v3 = *(const char **)_libc_argv;
    if ( !*(_DWORD *)_libc_argv )
      v3 = "<unknown>";
    _libc_message(a2, 2, "*** %s ***: %s terminated\n", a1, v3);
  }
}
// 80F1254: using guessed type int _libc_argv;

//----- (080878D0) --------------------------------------------------------
int __usercall is_dst@<eax>(int a1@<eax>, char *a2@<edx>, _BYTE *a3@<ecx>, int a4, int a5)
{
  char v5; // di
  char v7; // cl
  int result; // eax
  char v9; // cl

  v5 = 0;
  v7 = *a2;
  if ( *a2 == 123 )
  {
    v7 = a2[1];
    v5 = 1;
    ++a2;
  }
  result = 0;
  if ( v7 == *a3 )
  {
    do
    {
      if ( !v7 )
        break;
      v7 = a2[++result];
    }
    while ( v7 == a3[result] );
  }
  if ( v5 )
  {
    --a2;
    result += 2;
    if ( v7 != 125 )
      return 0;
  }
  else if ( v7 != 47 && v7 && (!a4 || v7 != 58) )
  {
    return 0;
  }
  if ( a5 )
  {
    v9 = a2[result];
    if ( v9 != 47 && v9 && (!a4 || v9 != 58) )
      return 0;
    if ( a2 != (char *)(a1 + 1) )
    {
      if ( !a4 )
        return 0;
      if ( *(a2 - 2) != 58 )
        return 0;
    }
  }
  return result;
}

//----- (08087990) --------------------------------------------------------
_BYTE *__usercall local_strdup@<eax>(_BYTE *a1@<eax>)
{
  unsigned int v2; // esi
  _BYTE *v3; // edx
  _BYTE *result; // eax

  v2 = strlen(a1) + 1;
  v3 = (_BYTE *)malloc(v2);
  result = 0;
  if ( v3 )
    return memcpy(v3, a1, v2);
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);

//----- (080879E0) --------------------------------------------------------
_DWORD *__usercall fillin_rpath@<eax>(int a1@<eax>, _DWORD *a2@<edx>, char *a3@<ecx>, int a4, int a5, _BYTE *a6)
{
  int v6; // ebx
  _BYTE *v7; // eax
  _BYTE *s1; // ebp
  unsigned int v9; // eax
  size_t n; // edi
  int v11; // esi
  int v12; // eax
  int v13; // edx
  int *v14; // eax
  int *v15; // esi
  int *v16; // eax
  _WORD *v17; // eax
  bool v18; // cc
  int v19; // edx
  int v20; // eax
  const char *v22; // esi
  int v23; // ebx
  const void *s2; // edx
  size_t v25; // ebp
  size_t v26; // edi
  int v27; // eax
  const void *v28; // [esp+18h] [ebp-34h]
  int v29; // [esp+1Ch] [ebp-30h]
  int v30; // [esp+1Ch] [ebp-30h]
  unsigned int v33; // [esp+28h] [ebp-24h]
  int v34[8]; // [esp+2Ch] [ebp-20h] BYREF

  v34[0] = a1;
  v6 = 0;
  while ( 1 )
  {
    v7 = (_BYTE *)strsep(v34, a3);
    s1 = v7;
    if ( !v7 )
      break;
    v9 = strlen(v7);
    n = v9;
    if ( v9 )
    {
      if ( v9 > 1 )
      {
        while ( s1[n - 1] == 47 )
        {
          if ( --n == 1 )
            goto LABEL_23;
        }
      }
      else
      {
LABEL_23:
        n = 1;
        if ( *s1 == 47 )
          goto LABEL_9;
      }
      s1[n++] = 47;
    }
    else
    {
      s1 = &curwd_8656;
    }
LABEL_9:
    if ( a4 )
    {
      v30 = v6;
      v22 = "/lib32/";
      v23 = 0;
      s2 = s1;
      v25 = n;
      do
      {
        v26 = system_dirs_len[v23];
        if ( v25 == v26 )
        {
          v28 = s2;
          v27 = memcmp(v22, s2, v25);
          s2 = v28;
          if ( !v27 )
          {
            n = v25;
            v6 = v30;
            s1 = v28;
            goto LABEL_10;
          }
        }
        ++v23;
        v22 += v26 + 1;
      }
      while ( v23 != 4 );
      v6 = v30;
    }
    else
    {
LABEL_10:
      v29 = dl_all_dirs;
      if ( dl_all_dirs )
      {
        v11 = dl_all_dirs;
        while ( *(_DWORD *)(v11 + 16) != n || memcmp(s1, *(const void **)(v11 + 12), n) )
        {
          v11 = *(_DWORD *)v11;
          if ( !v11 )
            goto LABEL_27;
        }
        if ( v6 )
        {
          v12 = 0;
          if ( *a2 != v11 )
          {
            do
            {
              if ( ++v12 == v6 )
                goto LABEL_20;
            }
            while ( a2[v12] != v11 );
            if ( v6 == v12 )
            {
LABEL_20:
              v13 = v12;
              v6 = v12 + 1;
              goto LABEL_21;
            }
          }
        }
        else
        {
          v6 = 1;
          v13 = 0;
LABEL_21:
          a2[v13] = v11;
        }
      }
      else
      {
LABEL_27:
        v33 = 0;
        if ( a6 )
          v33 = strlen(a6) + 1;
        v14 = (int *)malloc(v33 + n + 4 * ncapstr + 20 + 1);
        v15 = v14;
        if ( !v14 )
          dl_signal_error("cannot create cache for search path");
        v16 = &v14[ncapstr + 5];
        v15[3] = (int)v16;
        v17 = mempcpy(v16, s1, n);
        v18 = n <= max_dirnamelen;
        *(_BYTE *)v17 = 0;
        v15[4] = n;
        if ( !v18 )
          max_dirnamelen = n;
        v19 = 2 * (*s1 != 47);
        if ( ncapstr )
        {
          v20 = 0;
          do
            v15[v20++ + 5] = v19;
          while ( v20 != ncapstr );
        }
        v15[1] = a5;
        if ( a6 )
          v15[2] = (int)memcpy((_BYTE *)&v15[ncapstr + 5] + n + 1, a6, v33);
        else
          v15[2] = 0;
        dl_all_dirs = (int)v15;
        *v15 = v29;
        a2[v6++] = v15;
      }
    }
  }
  a2[v6] = 0;
  return a2;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 80CCD40: using guessed type size_t system_dirs_len[8];
// 80EEFD0: using guessed type int ncapstr;
// 80F0DE0: using guessed type int max_dirnamelen;
// 80F11EC: using guessed type int dl_all_dirs;
// 80879E0: using guessed type int var_20[8];

//----- (08087CC0) --------------------------------------------------------
_BYTE *__usercall add_name_to_object@<eax>(int a1@<eax>, char *a2@<edx>)
{
  int v3; // esi
  _BYTE *result; // eax
  int v5; // ebp
  int v6; // eax
  _DWORD *v7; // edi

  v3 = *(_DWORD *)(a1 + 28);
  if ( v3 )
  {
    while ( 1 )
    {
      result = (_BYTE *)strcmp(a2, *(const char **)v3);
      if ( !result )
        break;
      if ( !*(_DWORD *)(v3 + 4) )
        goto LABEL_7;
      v3 = *(_DWORD *)(v3 + 4);
    }
  }
  else
  {
    v3 = 0;
LABEL_7:
    v5 = strlen(a2);
    v6 = malloc(v5 + 13);
    v7 = (_DWORD *)v6;
    if ( !v6 )
      dl_signal_error("cannot allocate name record");
    if ( !v3 )
      _assert_fail("lastp != ((void *)0)", "dl-load.c", 475, "add_name_to_object");
    result = memcpy((_BYTE *)(v6 + 12), a2, v5 + 1);
    v7[1] = 0;
    v7[2] = 0;
    *(_DWORD *)(v3 + 4) = v7;
    *v7 = result;
  }
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);

//----- (08087D90) --------------------------------------------------------
void __usercall __noreturn lose(int a1@<edx>, int a2, int a3, int a4, int a5)
{
  if ( a1 != -1 )
    close(a5, a1);
  if ( a3 && *(_DWORD *)(a3 + 424) != -1 )
    free(*(_DWORD *)(a3 + 424));
  free(a3);
  free(a2);
  if ( a5 )
  {
    *(_DWORD *)(a5 + 12) = 0;
    dl_debug_state();
  }
  dl_signal_error(a4);
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 808E620: using guessed type int dl_debug_state(void);

//----- (08087E00) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __usercall dl_map_object_from_fd@<eax>(
        char *a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        _BYTE *a4,
        int a5,
        char a6,
        int a7,
        int a8,
        int a9)
{
  int v9; // edi
  int v11; // eax
  int v12; // eax
  int v13; // edi
  _DWORD *v14; // ecx
  int v15; // ebx
  unsigned __int16 v16; // si
  int v17; // eax
  int v18; // ebx
  int v19; // eax
  void *v20; // esp
  _BYTE *v21; // esi
  int v22; // edx
  int v23; // edx
  int v24; // eax
  int v25; // edx
  int v26; // eax
  int v27; // ebx
  int v28; // ecx
  int v29; // ebx
  int *v30; // edx
  int v31; // ebx
  int v32; // ecx
  int v33; // ebx
  unsigned int v34; // ecx
  bool v35; // cc
  char v36; // bl
  int *v37; // ebx
  int *v38; // esi
  int v39; // edx
  unsigned int v40; // eax
  int v41; // edx
  unsigned int v42; // eax
  bool v43; // zf
  int v44; // ecx
  unsigned int v45; // edx
  unsigned int v46; // eax
  void *v47; // eax
  unsigned int v48; // esi
  unsigned int v49; // edx
  const char *v50; // esi
  unsigned int v51; // esi
  unsigned int v52; // edx
  int v53; // edx
  unsigned int *v54; // edx
  unsigned int v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // eax
  int v59; // eax
  int v60; // eax
  int v61; // eax
  int v62; // eax
  int v63; // eax
  int v64; // eax
  int v65; // eax
  int v66; // eax
  int v67; // edx
  int v68; // eax
  int v69; // eax
  int v70; // edx
  int v71; // eax
  int v72; // eax
  unsigned int v73; // eax
  int v74; // edx
  _BYTE *v75; // edx
  int v76; // eax
  int v77; // edx
  int v78; // eax
  int v79; // ecx
  void *v80; // esp
  unsigned int v81; // ecx
  int v82; // eax
  unsigned int v83; // ebx
  _BYTE *v84; // eax
  _BYTE *v85; // eax
  int v86; // edx
  int v87; // eax
  int v88; // edx
  char v89; // al
  int v90; // eax
  int v91; // eax
  _DWORD *tls; // eax
  int v93; // [esp+0h] [ebp-128h] BYREF
  int v94; // [esp+8h] [ebp-120h]
  _DWORD v95[5]; // [esp+40h] [ebp-E8h] BYREF
  char v96; // [esp+55h] [ebp-D3h]
  unsigned __int16 v97; // [esp+56h] [ebp-D2h]
  char *v98; // [esp+58h] [ebp-D0h]
  _DWORD *v99; // [esp+5Ch] [ebp-CCh]
  unsigned __int8 v100; // [esp+60h] [ebp-C8h]
  int v101; // [esp+70h] [ebp-B8h]
  int v102; // [esp+74h] [ebp-B4h]
  int v103; // [esp+78h] [ebp-B0h]
  int *v104; // [esp+7Ch] [ebp-ACh]
  int v105; // [esp+80h] [ebp-A8h]
  int v106; // [esp+84h] [ebp-A4h]
  int v107; // [esp+88h] [ebp-A0h]
  void *s; // [esp+8Ch] [ebp-9Ch]
  unsigned int v109; // [esp+90h] [ebp-98h]
  int v110; // [esp+94h] [ebp-94h]
  _BYTE *v111; // [esp+98h] [ebp-90h]
  int *v112; // [esp+9Ch] [ebp-8Ch]
  unsigned int v113; // [esp+A0h] [ebp-88h] BYREF
  _BYTE *v114; // [esp+A4h] [ebp-84h]
  __int64 v115; // [esp+F8h] [ebp-30h]
  int v116[10]; // [esp+100h] [ebp-28h] BYREF
  int savedregs; // [esp+128h] [ebp+0h] BYREF

  v101 = a2;
  v98 = a1;
  v102 = a3;
  v99 = dl_debug_initialize(0, a9);
  if ( (_fxstat64(3, v101, (int)&v113) & 0x80000000) != 0 )
  {
    v96 = 0;
    v50 = "cannot stat shared object";
    v13 = 0;
    goto LABEL_149;
  }
  v9 = dl_ns[19 * a9];
  if ( !v9 )
  {
LABEL_9:
    if ( (a7 & 4) != 0 )
    {
      v13 = 0;
      free(a4);
      close((int)&savedregs, v101);
      return v13;
    }
    if ( (dl_debug_mask & 0x40) != 0 )
      dl_debug_printf((int)"file=%s [%lu];  generating link map\n", v98, a9);
    v11 = v99[3];
    if ( v11 )
    {
      if ( v11 != 1 )
        _assert_fail("r->r_state == RT_ADD", "dl-load.c", 1048, "_dl_map_object_from_fd");
      v96 = 0;
    }
    else
    {
      v99[3] = 1;
      dl_debug_state();
      v96 = 1;
    }
    v12 = dl_new_object(a4, v98, a6, a5, a7, a9);
    v13 = v12;
    if ( !v12 )
    {
      v50 = "cannot create shared object descriptor";
      goto LABEL_149;
    }
    v14 = (_DWORD *)v102;
    v15 = *(unsigned __int16 *)(v102 + 48);
    v16 = *(_WORD *)(v102 + 20);
    *(_DWORD *)(v12 + 340) = *(_DWORD *)(v102 + 28);
    v17 = v14[8];
    *(_WORD *)(v13 + 344) = v15;
    v18 = 32 * v15;
    v97 = v16;
    if ( (unsigned int)(v18 + v17) > *v14 )
    {
      v80 = alloca((v18 + 30) & 0x3FFFF0);
      v111 = v95;
      v94 = 0;
      lseek(v101, *(_DWORD *)(v102 + 32));
      v94 = v18;
      if ( read((int)&savedregs, v101, (int)v111) != v18 )
      {
        v50 = "cannot read file data";
        goto LABEL_149;
      }
    }
    else
    {
      v111 = (char *)v14 + v17 + 4;
    }
    v19 = *(unsigned __int16 *)(v13 + 344);
    v95[4] = &v93;
    v20 = alloca((24 * v19 + 30) & 0xFFFFF0);
    v104 = v95;
    if ( v111 >= &v111[32 * v19] )
      goto LABEL_154;
    v21 = v111;
    v100 = 0;
    v109 = 0;
    v103 = 7;
    v112 = v116;
    do
    {
      v22 = *(_DWORD *)v21;
      if ( *(_DWORD *)v21 == 6 )
      {
        *(_DWORD *)(v13 + 336) = *((_DWORD *)v21 + 2);
      }
      else if ( *(_DWORD *)v21 <= 6u )
      {
        if ( v22 == 1 )
        {
          v27 = *((_DWORD *)v21 + 7);
          v110 = dl_pagesize;
          v107 = dl_pagesize - 1;
          if ( (v27 & (dl_pagesize - 1)) != 0 )
          {
            v50 = "ELF load command alignment not page-aligned";
            goto LABEL_149;
          }
          v28 = *((_DWORD *)v21 + 2);
          s = (void *)*((_DWORD *)v21 + 1);
          if ( ((v28 - (_DWORD)s) & (v27 - 1)) != 0 )
          {
            v50 = "ELF load command address/offset not properly aligned";
            goto LABEL_149;
          }
          v29 = v109++;
          v30 = &v104[6 * v29];
          v110 = -v110;
          v105 = v28 & v110;
          *v30 = v28 & v110;
          v31 = v28 + *((_DWORD *)v21 + 4);
          v32 = *((_DWORD *)v21 + 5) + v28;
          v30[2] = v31;
          v33 = v107 + v31;
          v30[3] = v32;
          v34 = v110 & (unsigned int)s;
          v35 = v109 <= 1;
          v30[1] = v110 & v33;
          v30[4] = v34;
          if ( !v35 )
          {
            v36 = v100;
            if ( v105 != *(v30 - 5) )
              v36 = 1;
            v100 = v36;
          }
          v30[5] = (1934713408 >> (4 * (v21[24] & 7))) & 0xF;
        }
        else if ( v22 == 2 )
        {
          *(_DWORD *)(v13 + 8) = *((_DWORD *)v21 + 2);
          *(_WORD *)(v13 + 346) = *((_DWORD *)v21 + 5) >> 3;
        }
      }
      else
      {
        switch ( v22 )
        {
          case 1685382481:
            v103 = *((_DWORD *)v21 + 6);
            break;
          case 1685382482:
            *(_DWORD *)(v13 + 584) = *((_DWORD *)v21 + 2);
            *(_DWORD *)(v13 + 588) = *((_DWORD *)v21 + 5);
            break;
          case 7:
            v23 = *((_DWORD *)v21 + 5);
            if ( v23 )
            {
              v24 = *((_DWORD *)v21 + 7);
              *(_DWORD *)(v13 + 564) = v23;
              *(_DWORD *)(v13 + 568) = v24;
              v25 = *((_DWORD *)v21 + 2);
              if ( v24 )
                *(_DWORD *)(v13 + 572) = v25 & (v24 - 1);
              else
                *(_DWORD *)(v13 + 572) = 0;
              v26 = *((_DWORD *)v21 + 4);
              *(_DWORD *)(v13 + 556) = v25;
              *(_DWORD *)(v13 + 560) = v26;
              if ( (*(_BYTE *)(v13 + 404) & 3) != 1 && !dl_tls_dtv_slotinfo_list )
              {
                if ( dl_tls_setup() || (tls = (_DWORD *)dl_allocate_tls(0)) == 0 )
                {
                  v50 = "cannot allocate TLS data structures for initial thread";
                }
                else
                {
                  *tls = tls;
                  tls[2] = tls;
                  v116[0] = -1;
                  tls[4] = dl_sysinfo;
                  v116[1] = (int)tls;
                  v116[2] = 0xFFFFF;
                  v116[3] = 81;
                  __asm { int     80h; LINUX - sys_set_thread_area }
                  dl_deallocate_tls((int)tls, 1);
                  v50 = "set_thread_area failed when setting up thread-local storage\n";
                }
                goto LABEL_149;
              }
              *(_DWORD *)(v13 + 580) = dl_next_tls_modid();
              v19 = *(unsigned __int16 *)(v13 + 344);
            }
            break;
        }
      }
      v21 += 32;
    }
    while ( v21 < &v111[32 * v19] );
    if ( !v109 )
    {
LABEL_154:
      v50 = "object file has no loadable segments";
      goto LABEL_149;
    }
    v37 = v104;
    v38 = &v104[6 * v109 - 6];
    v39 = *v104;
    v107 = v97;
    v110 = v38[3] - v39;
    if ( v97 != 3 )
    {
      if ( (a7 & 0x20000000) != 0 )
      {
        v88 = *(_DWORD *)v13 + v39;
        v89 = *(_BYTE *)(v13 + 405);
        *(_DWORD *)(v13 + 428) = v88;
        *(_DWORD *)(v13 + 432) = v110 + v88;
        *(_BYTE *)(v13 + 405) = (((v100 ^ 1) & 1) << 6) | v89 & 0xBF;
        goto LABEL_62;
      }
      v50 = "cannot dynamically load executable";
LABEL_149:
      v82 = 0;
      if ( v96 )
        v82 = (int)v99;
      lose(v101, (int)a4, v13, (int)v50, v82);
    }
    v40 = mmap(dl_use_load_bias & v39, v110, v104[5], 2050, v101, v104[4]);
    *(_DWORD *)(v13 + 428) = v40;
    if ( v40 == -1 )
    {
LABEL_65:
      v50 = "failed to map segment from shared object";
      goto LABEL_149;
    }
    *(_DWORD *)(v13 + 432) = v40 + v110;
    v41 = (int)v104;
    v42 = v40 - *v104;
    v43 = v100 == 0;
    *(_DWORD *)v13 = v42;
    if ( !v43 )
    {
      v79 = *(_DWORD *)(v41 + 4);
      v94 = 0;
      mprotect(v79 + v42, *v38 - v79);
    }
    *(_BYTE *)(v13 + 405) |= 0x40u;
    while ( 1 )
    {
      v44 = v37[5];
      if ( (v44 & 4) != 0 )
      {
        *(_DWORD *)(v13 + 436) = *(_DWORD *)v13 + v37[1];
        if ( *(_DWORD *)(v13 + 336) )
          goto LABEL_53;
      }
      else if ( *(_DWORD *)(v13 + 336) )
      {
        goto LABEL_53;
      }
      v51 = v37[4];
      v52 = *(_DWORD *)(v102 + 32);
      if ( v51 <= v52 )
      {
        v106 = *v37;
        s = (void *)(v51 - v106);
        s = (void *)(v37[1] + v51 - v106);
        v105 = 32 * *(unsigned __int16 *)(v102 + 48);
        if ( (unsigned int)s >= v52 + v105 )
          *(_DWORD *)(v13 + 336) = v106 + v52 - v51;
      }
LABEL_53:
      v45 = v37[3];
      v46 = v37[2];
      if ( v45 > v46 )
      {
        v47 = (void *)(*(_DWORD *)v13 + v46);
        v112 = (int *)(v45 + *(_DWORD *)v13);
        s = v47;
        v105 = dl_pagesize;
        v106 = -dl_pagesize;
        v48 = -dl_pagesize & ((unsigned int)v47 + dl_pagesize - 1);
        if ( v48 > (unsigned int)v112 )
          v48 = (unsigned int)v112;
        if ( (unsigned int)v47 < v48 )
        {
          if ( (v44 & 2) == 0 )
          {
            v94 = v44 | 2;
            if ( (mprotect((unsigned int)s & v106, dl_pagesize) & 0x80000000) != 0 )
            {
              v50 = "cannot change memory protections";
              goto LABEL_149;
            }
          }
          memset(s, 0, v48 - (_DWORD)s);
          if ( (v37[5] & 2) == 0 )
          {
            v94 = v37[5];
            mprotect((unsigned int)s & -dl_pagesize, dl_pagesize);
          }
        }
        if ( (unsigned int)v112 > v48 && mmap(v48, (int)v112 - v48, v37[5], 50, -1, 0) == -1 )
        {
          v50 = "cannot map zero-fill pages";
          goto LABEL_149;
        }
      }
      v37 += 6;
LABEL_62:
      if ( v37 >= &v104[6 * v109] )
      {
        v53 = *(_DWORD *)(v13 + 8);
        if ( v53 )
        {
          v54 = (unsigned int *)(*(_DWORD *)v13 + v53);
          v109 = *(_DWORD *)v13;
          *(_DWORD *)(v13 + 8) = v54;
          if ( v54 )
          {
            v55 = *v54;
            s = (void *)(v13 + 32);
            if ( v55 )
            {
              do
              {
                while ( v55 <= 0x21 )
                {
                  *(_DWORD *)(v13 + 4 * v55 + 32) = v54;
LABEL_75:
                  v54 += 2;
                  v55 = *v54;
                  if ( !*v54 )
                    goto LABEL_79;
                }
                if ( 1879048191 - v55 > 0xF )
                {
                  v81 = (int)(2 * v55) >> 1;
                  if ( v81 <= 0xFFFFFFFC )
                  {
                    if ( 1879047679 - v55 > 0xB )
                    {
                      if ( 1879047935 - v55 <= 0xA )
                        *((_DWORD *)s - v55 - 268435648) = v54;
                    }
                    else
                    {
                      *((_DWORD *)s - v55 - 268435916) = v54;
                    }
                  }
                  else
                  {
                    *((_DWORD *)s + ~v81 + 50) = v54;
                  }
                  goto LABEL_75;
                }
                *(_DWORD *)(v13 + 4 * (1879048233 - v55)) = v54;
                v54 += 2;
                v55 = *v54;
              }
              while ( *v54 );
            }
LABEL_79:
            if ( v109 )
            {
              v56 = *(_DWORD *)(v13 + 48);
              if ( v56 )
                *(_DWORD *)(v56 + 4) += v109;
              v57 = *(_DWORD *)(v13 + 44);
              if ( v57 )
                *(_DWORD *)(v57 + 4) += v109;
              v58 = *(_DWORD *)(v13 + 52);
              if ( v58 )
                *(_DWORD *)(v58 + 4) += v109;
              v59 = *(_DWORD *)(v13 + 56);
              if ( v59 )
                *(_DWORD *)(v59 + 4) += v109;
              v60 = *(_DWORD *)(v13 + 60);
              if ( v60 )
                *(_DWORD *)(v60 + 4) += v109;
              v61 = *(_DWORD *)(v13 + 100);
              if ( v61 )
                *(_DWORD *)(v61 + 4) += v109;
              v62 = *(_DWORD *)(v13 + 124);
              if ( v62 )
                *(_DWORD *)(v62 + 4) += v109;
              v63 = *(_DWORD *)(v13 + 228);
              if ( v63 )
                *(_DWORD *)(v63 + 4) += v109;
              v64 = *(_DWORD *)(v13 + 332);
              if ( v64 )
                *(_DWORD *)(v64 + 4) += v109;
            }
            v65 = *(_DWORD *)(v13 + 112);
            if ( v65 )
            {
              v66 = *(_DWORD *)(v65 + 4);
              if ( v66 != 7 && v66 != 17 )
                _assert_fail(
                  "info[20]->d_un.d_val == 17 || info[20]->d_un.d_val == 7",
                  "dynamic-link.h",
                  192,
                  "elf_get_dynamic_info");
            }
            if ( *(_DWORD *)(v13 + 60) && *(_DWORD *)(*(_DWORD *)(v13 + 68) + 4) != 12 )
              _assert_fail("info[9]->d_un.d_val == sizeof (Elf32_Rela)", "dynamic-link.h", 197, "elf_get_dynamic_info");
            if ( *(_DWORD *)(v13 + 100) && *(_DWORD *)(*(_DWORD *)(v13 + 108) + 4) != 8 )
              _assert_fail("info[19]->d_un.d_val == sizeof (Elf32_Rel)", "dynamic-link.h", 201, "elf_get_dynamic_info");
            v67 = *(_DWORD *)(v13 + 152);
            if ( v67 )
            {
              v68 = *(_DWORD *)(v67 + 4);
              *(_DWORD *)(v13 + 520) = v68;
              if ( (v68 & 2) != 0 )
                *(_DWORD *)(v13 + 96) = v67;
              if ( (v68 & 4) != 0 )
                *(_DWORD *)(v13 + 120) = v67;
              if ( (v68 & 8) != 0 )
                *(_DWORD *)(v13 + 128) = v67;
            }
            v69 = *(_DWORD *)(v13 + 184);
            if ( v69 )
            {
              v70 = *(_DWORD *)(v69 + 4);
              *(_DWORD *)(v13 + 516) = v70;
              if ( (v70 & 1) != 0 )
                *(_DWORD *)(v13 + 128) = v69;
            }
            if ( *(_DWORD *)(v13 + 148) )
              *(_DWORD *)(v13 + 92) = 0;
          }
        }
        else if ( v107 == 3 )
        {
          v50 = "object file has no dynamic section";
          goto LABEL_149;
        }
        if ( a7 < 0 && (*(_BYTE *)(v13 + 516) & 0x40) != 0 )
        {
          munmap(*(_DWORD *)(v13 + 428), *(_DWORD *)(v13 + 432) - *(_DWORD *)(v13 + 428));
          v91 = *(_DWORD *)(v13 + 28);
          if ( !*(_DWORD *)(v91 + 8) )
            free(v91);
          v50 = "shared object cannot be dlopen()ed";
          if ( *(char *)(v13 + 404) < 0 )
            free(*(_DWORD *)(v13 + 336));
          goto LABEL_149;
        }
        v71 = *(_DWORD *)(v13 + 336);
        if ( v71 )
        {
          *(_DWORD *)(v13 + 336) = *(_DWORD *)v13 + v71;
        }
        else
        {
          v83 = 32 * *(unsigned __int16 *)(v102 + 48);
          v84 = (_BYTE *)malloc(v83);
          if ( !v84 )
          {
            v50 = "cannot allocate memory for program header";
            goto LABEL_149;
          }
          v85 = memcpy(v84, v111, v83);
          *(_BYTE *)(v13 + 404) |= 0x80u;
          *(_DWORD *)(v13 + 336) = v85;
        }
        if ( ((unsigned __int8)v103 & (unsigned __int8)~(_BYTE)dl_stack_flags & 1) != 0 )
        {
          _stack_prot |= 7u;
          if ( dl_make_stack_executable_hook() )
          {
            v50 = "cannot enable executable stack as shared object requires";
            goto LABEL_149;
          }
        }
        v72 = *(_DWORD *)(v13 + 556);
        if ( v72 )
          *(_DWORD *)(v13 + 556) = *(_DWORD *)v13 + v72;
        if ( close((int)&savedregs, v101) )
        {
          v50 = "cannot close file descriptor";
          goto LABEL_149;
        }
        if ( v107 == 2 && (*(_BYTE *)(v13 + 404) & 3) == 1 )
          *(_BYTE *)(v13 + 404) &= 0xFCu;
        v73 = *(_DWORD *)v13;
        v74 = *(_DWORD *)v13 + *(_DWORD *)(v13 + 340);
        v43 = (dl_debug_mask & 0x40) == 0;
        *(_DWORD *)(v13 + 340) = v74;
        if ( !v43 )
          dl_debug_printf(
            (int)"  dynamic: 0x%0*lx  base: 0x%0*lx   size: 0x%0*Zx\n"
                 "    entry: 0x%0*lx  phdr: 0x%0*lx  phnum:   %*u\n"
                 "\n",
            8,
            *(_DWORD *)(v13 + 8),
            8,
            v73,
            8,
            v110,
            8,
            v74,
            8,
            *(_DWORD *)(v13 + 336),
            8,
            *(unsigned __int16 *)(v13 + 344));
        dl_setup_hash((_DWORD *)v13);
        if ( (a7 & 8) == 0 && *(_DWORD *)(v13 + 96) && **(_DWORD **)(v13 + 460) != v13 + 348 )
        {
          v86 = *(_DWORD *)(v13 + 456);
          **(_DWORD **)(v13 + 356) = v13;
          v87 = *(_DWORD *)(v13 + 460);
          *(_DWORD *)(v13 + 360) = 1;
          memmove((void *)(v87 + 4), (const void *)v87, 4 * v86 - 4);
          **(_DWORD **)(v13 + 460) = v13 + 356;
        }
        if ( (*(_BYTE *)(v13 + 516) & 0x20) != 0 )
          dl_initfirst = v13;
        v75 = v114;
        *(_DWORD *)(v13 + 472) = v113;
        v76 = v115;
        *(_DWORD *)(v13 + 476) = v75;
        v77 = HIDWORD(v115);
        *(_DWORD *)(v13 + 480) = v76;
        v78 = dl_profile;
        *(_DWORD *)(v13 + 484) = v77;
        if ( v78 )
        {
          v90 = *(_DWORD *)(v13 + 88);
          if ( v90 )
            add_name_to_object(v13, (char *)(*(_DWORD *)(v90 + 4) + *(_DWORD *)(*(_DWORD *)(v13 + 52) + 4)));
        }
        dl_add_to_namespace_list((_DWORD *)v13, a9);
        return v13;
      }
      v49 = v37[1];
      if ( v49 > *v37 && mmap(*(_DWORD *)v13 + *v37, v49 - *v37, v37[5], 2066, v101, v37[4]) == -1 )
        goto LABEL_65;
    }
  }
  v111 = v114;
  while ( (*(_BYTE *)(v9 + 405) & 0x20) != 0
       || *(_QWORD *)(v9 + 480) != v115
       || *(_QWORD *)(v9 + 472) != __PAIR64__((unsigned int)v111, v113) )
  {
    v9 = *(_DWORD *)(v9 + 12);
    if ( !v9 )
      goto LABEL_9;
  }
  close((int)&savedregs, v101);
  free(a4);
  add_name_to_object(v9, v98);
  return v9;
}
// 80889EE: write access to const memory at 80EEFCC has been detected
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808E620: using guessed type int dl_debug_state(void);
// 80EEFCC: using guessed type int _stack_prot;
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80EF5A8: using guessed type int (*dl_make_stack_executable_hook)(void);
// 80EF5AC: using guessed type int dl_stack_flags;
// 80EF5B8: using guessed type int dl_pagesize;
// 80EF5C0: using guessed type int dl_use_load_bias;
// 80F1148: using guessed type int dl_tls_max_dtv_idx;
// 80F114C: using guessed type int dl_tls_dtv_slotinfo_list;
// 80F1190: using guessed type int dl_debug_mask;
// 80F11A4: using guessed type int dl_profile;
// 80F11E8: using guessed type int dl_initfirst;
// 80F1200: using guessed type int dl_ns[];

//----- (08088D40) --------------------------------------------------------
int __usercall open_verify_isra_3@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>, char a4)
{
  int v5; // eax
  int v6; // ebx
  unsigned __int8 v7; // al
  __int16 v8; // ax
  int v9; // eax
  int v10; // edx
  int v11; // esi
  unsigned int v12; // ecx
  _DWORD *v13; // ebx
  int v14; // edi
  unsigned int v15; // esi
  int v16; // eax
  _DWORD *v17; // edi
  unsigned int v18; // ebx
  _DWORD *i; // esi
  unsigned int v20; // eax
  bool v21; // zf
  int result; // eax
  void *v23; // esp
  int v24; // eax
  void *v25; // esp
  int v26; // eax
  const char *v27; // ebx
  unsigned int v28; // ecx
  void *v29; // esp
  char *v30; // edi
  char v31; // al
  bool v32; // dl
  unsigned __int8 v33; // al
  int v34; // [esp+4h] [ebp-44h]
  _BYTE v35[8]; // [esp+10h] [ebp-38h] BYREF
  _BYTE *v36; // [esp+18h] [ebp-30h]
  int v37; // [esp+1Ch] [ebp-2Ch]
  char v38; // [esp+23h] [ebp-25h]
  char *v39; // [esp+24h] [ebp-24h]
  int v40; // [esp+28h] [ebp-20h]
  int v41; // [esp+2Ch] [ebp-1Ch]
  int savedregs; // [esp+48h] [ebp+0h] BYREF

  v40 = a3;
  v39 = a1;
  v38 = a4;
  v5 = open((int)&savedregs, (int)a1, 0x80000);
  v41 = v5;
  if ( v5 == -1 )
    return v41;
  __writegsdword(0xFFFFFFE8, 0);
  v6 = read((int)&savedregs, v5, a2 + 4);
  *(_DWORD *)a2 = v6;
  if ( v6 <= 51 )
  {
    v27 = "file too short";
    if ( __readgsdword(0xFFFFFFE8) )
      v27 = "cannot read file data";
    goto LABEL_42;
  }
  if ( memcmp((const void *)(a2 + 4), &expected_8843, 8u) && memcmp((const void *)(a2 + 4), &expected2_8842, 8u)
    || (v7 = *(_BYTE *)(a2 + 12)) != 0 && (*(_BYTE *)(a2 + 11) != 3 || v7 > 2u)
    || memcmp((const void *)(a2 + 13), &unk_80CCD8D, 7u) )
  {
    if ( *(_DWORD *)(a2 + 4) == 1179403647 )
    {
      if ( *(_BYTE *)(a2 + 8) != 1 )
      {
        *(_BYTE *)v40 = 1;
        goto LABEL_33;
      }
      if ( *(_BYTE *)(a2 + 9) == 1 )
      {
        if ( *(_BYTE *)(a2 + 10) == 1 )
        {
          v31 = *(_BYTE *)(a2 + 11);
          v32 = v31 != 3;
          if ( v31 != 3 && v31 )
          {
            v27 = "ELF file OS ABI invalid";
          }
          else
          {
            v33 = *(_BYTE *)(a2 + 12);
            if ( v33 && (v32 || v33 > 2u) )
            {
              v27 = "ELF file ABI version invalid";
            }
            else
            {
              v27 = "nonzero padding in e_ident";
              if ( !memcmp((const void *)(a2 + 13), &unk_80CCD8D, 7u) )
                v27 = "internal error";
            }
          }
        }
        else
        {
          v27 = "ELF file version ident does not match current one";
        }
      }
      else
      {
        v27 = "ELF file data encoding not little-endian";
      }
    }
    else
    {
      v27 = "invalid ELF header";
    }
    goto LABEL_42;
  }
  if ( *(_DWORD *)(a2 + 24) != 1 )
  {
    v27 = "ELF file version does not match current one";
    goto LABEL_42;
  }
  if ( *(_WORD *)(a2 + 22) != 3 )
    goto LABEL_33;
  v8 = *(_WORD *)(a2 + 20);
  if ( v8 != 3 && v8 != 2 )
  {
    v27 = "only ET_DYN and ET_EXEC can be loaded";
    goto LABEL_42;
  }
  if ( *(_WORD *)(a2 + 46) != 32 )
  {
    v27 = "ELF file's phentsize not the expected size";
    goto LABEL_42;
  }
  v9 = *(unsigned __int16 *)(a2 + 48);
  v10 = *(_DWORD *)(a2 + 32);
  v11 = 32 * v9;
  if ( 32 * v9 + v10 > (unsigned int)v6 )
  {
    v25 = alloca((v11 + 30) & 0x3FFFF0);
    v34 = *(_DWORD *)(a2 + 32);
    v36 = v35;
    lseek(v41, v34);
    v26 = read((int)&savedregs, v41, (int)v36);
    v12 = (unsigned int)v36;
    if ( v11 == v26 )
    {
      v9 = *(unsigned __int16 *)(a2 + 48);
      v11 = 32 * v9;
      goto LABEL_12;
    }
LABEL_55:
    v27 = "cannot read file data";
LABEL_42:
    if ( v38 )
    {
      v28 = strlen(v39) + 1;
      v29 = alloca(v28 + 15);
      v30 = memcpy(v35, v39, v28);
      free(v39);
      v39 = v30;
    }
    lose(v41, 0, 0, (int)v27, 0);
  }
  v12 = a2 + v10 + 4;
LABEL_12:
  if ( v12 >= v12 + v11 )
    return v41;
  v40 = a2;
  v13 = (_DWORD *)v12;
  v14 = v12;
  while ( 1 )
  {
    if ( *v13 != 4 )
      goto LABEL_14;
    v15 = v13[4];
    if ( v15 <= 0x1F || v13[7] <= 3u )
      goto LABEL_14;
    v16 = v13[1];
    if ( v16 + v15 <= *(_DWORD *)v40 )
    {
      v37 = v14;
      v17 = v13;
      v18 = v15;
      i = (_DWORD *)(v40 + v16 + 4);
      goto LABEL_22;
    }
    v23 = alloca(16 * ((v15 + 30) / 0x10));
    v24 = v13[1];
    v36 = v35;
    lseek(v41, v24);
    if ( v15 != read((int)&savedregs, v41, (int)v36) )
      goto LABEL_55;
    v37 = v14;
    v17 = v13;
    v18 = v15;
LABEL_22:
    for ( i = v36; memcmp(i, &expected_note_8849, 0x10u); i = (_DWORD *)((char *)i + v20) )
    {
      v20 = ((*i + 3) & 0xFFFFFFFC) + ((i[1] + 3) & 0xFFFFFFFC) + 12;
      if ( v20 > v18 - 32 )
      {
        v13 = v17;
        v14 = v37;
        v9 = *(unsigned __int16 *)(v40 + 48);
        goto LABEL_14;
      }
      v18 -= v20;
    }
    v21 = v18 == 0;
    v13 = v17;
    v14 = v37;
    if ( !v21 )
      break;
    v9 = *(unsigned __int16 *)(v40 + 48);
LABEL_14:
    v13 += 8;
    if ( (unsigned int)v13 >= v14 + 32 * v9 )
      return v41;
  }
  if ( !i[4]
    && (!dl_osversion
     || (unsigned __int8)i[7] + ((((unsigned __int8)i[5] << 8) + (unsigned int)(unsigned __int8)i[6]) << 8) <= dl_osversion) )
  {
    return v41;
  }
LABEL_33:
  close((int)&savedregs, v41);
  v41 = -1;
  result = -1;
  __writegsdword(0xFFFFFFE8, 2u);
  return result;
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80F11F0: using guessed type int dl_osversion;

//----- (08089200) --------------------------------------------------------
int __usercall open_path_isra_4@<eax>(
        _BYTE *a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        int *a4,
        _DWORD *a5,
        int a6,
        int a7,
        int a8)
{
  int v8; // esi
  void *v9; // esp
  int v10; // edi
  unsigned int v11; // ebx
  unsigned int v12; // eax
  _WORD *v13; // eax
  char *v14; // eax
  int v15; // edx
  int v16; // eax
  unsigned int v17; // eax
  int v19; // edx
  _BYTE *v20; // eax
  int v21; // edx
  unsigned int v22; // eax
  int v23; // ebx
  int v24; // [esp+10h] [ebp-A8h] BYREF
  int v25; // [esp+14h] [ebp-A4h]
  unsigned int v26; // [esp+18h] [ebp-A0h]
  int v27; // [esp+1Ch] [ebp-9Ch]
  int *v28; // [esp+20h] [ebp-98h]
  int v29; // [esp+24h] [ebp-94h]
  _BYTE *v30; // [esp+28h] [ebp-90h]
  unsigned int v31; // [esp+2Ch] [ebp-8Ch]
  _BYTE *v32; // [esp+30h] [ebp-88h]
  int v33; // [esp+34h] [ebp-84h]
  char *v34; // [esp+38h] [ebp-80h]
  unsigned int v35; // [esp+3Ch] [ebp-7Ch]
  char v36[16]; // [esp+40h] [ebp-78h] BYREF
  int v37; // [esp+50h] [ebp-68h]
  int savedregs; // [esp+B8h] [ebp+0h] BYREF

  v30 = a1;
  v31 = a2;
  v29 = a3;
  v28 = (int *)*a4;
  if ( v28 )
  {
    v27 = 0;
    v25 = 0;
    v8 = *v28;
    v9 = alloca(max_dirnamelen + a2 + max_capstrlen + 15);
    v34 = (char *)&v24;
    v26 = ~v31;
    while ( 1 )
    {
      if ( (dl_debug_mask & 1) != 0 )
      {
        v23 = *(_DWORD *)(v8 + 4);
        if ( v23 != v25 )
        {
          print_search_path(v28, *(const char **)(v8 + 4), *(const char **)(v8 + 8));
          v25 = v23;
        }
      }
      v32 = mempcpy(v34, *(_BYTE **)(v8 + 12), *(_DWORD *)(v8 + 16));
      if ( !ncapstr )
      {
        v33 = 0;
        goto LABEL_21;
      }
      v10 = 0;
      v11 = 1;
      v33 = 0;
      while ( 1 )
      {
        if ( *(_DWORD *)(v8 + 4 * v11 + 16) == 1 )
          goto LABEL_10;
        v13 = mempcpy(v32, *(_BYTE **)(v10 + capstr), *(_DWORD *)(v10 + capstr + 4));
        v14 = (char *)mempcpy(v13, v30, v31);
        v35 = v14 - v34;
        if ( (dl_debug_mask & 1) != 0 )
          dl_debug_printf((int)"  trying file=%s\n", v34);
        v15 = open_verify_isra_3(v34, a6, a8, 0);
        v16 = *(_DWORD *)(v8 + 4 * v11 + 16);
        if ( v16 )
          break;
        if ( v15 == -1 )
        {
          if ( !a7 || (v19 = 1, (*(_BYTE *)(dl_ns[19 * *(_DWORD *)(a7 + 24)] + 405) & 8) == 0) )
          {
            v34[v35 + v26] = 0;
            if ( !_xstat64(3, (int)v34, (int)v36) && (v37 & 0xF000) == 0x4000 )
            {
              *(_DWORD *)(v8 + 4 * v11 + 16) = 2;
              v19 = 1;
            }
            else
            {
              *(_DWORD *)(v8 + 4 * v11 + 16) = 1;
              v19 = 0;
            }
          }
          v33 |= v19;
          goto LABEL_10;
        }
        *(_DWORD *)(v8 + 4 * v11 + 16) = 2;
        v33 = 1;
LABEL_8:
        if ( v29
          && _libc_enable_secure
          && ((v24 = v15, v22 = _fxstat64(3, v15, (int)v36), v15 = v24, v22) || (v37 & 0x800) == 0) )
        {
          close((int)&savedregs, v24);
          __writegsdword(0xFFFFFFE8, 2u);
        }
        else if ( v15 != -1 )
        {
          v24 = v15;
          v20 = (_BYTE *)malloc(v35);
          v21 = v24;
          *a5 = v20;
          if ( v20 )
          {
            memcpy(v20, v34, v35);
            return v24;
          }
          close((int)&savedregs, v21);
          return -1;
        }
LABEL_10:
        v10 += 8;
        v12 = v11 + 1;
        if ( v11 >= ncapstr )
          goto LABEL_18;
LABEL_11:
        v11 = v12;
      }
      v33 |= v16 != 1;
      if ( v15 != -1 )
        goto LABEL_8;
      v10 += 8;
      v12 = v11 + 1;
      if ( v11 < ncapstr )
        goto LABEL_11;
LABEL_18:
      if ( v33 )
      {
        v17 = __readgsdword(0xFFFFFFE8);
        if ( v17 != 2 && v17 != 13 )
          return -1;
      }
LABEL_21:
      ++v28;
      v27 |= v33;
      v8 = *v28;
      if ( !*v28 )
      {
        if ( !v27 )
        {
          if ( a4[1] )
            free(*a4);
          if ( a4 != &rtld_search_dirs )
            *a4 = -1;
        }
        return -1;
      }
    }
  }
  return -1;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80EEFD0: using guessed type int ncapstr;
// 80EEFD4: using guessed type int max_capstrlen;
// 80EEFD8: using guessed type int capstr;
// 80EEFDC: using guessed type int rtld_search_dirs;
// 80F0DE0: using guessed type int max_dirnamelen;
// 80F1190: using guessed type int dl_debug_mask;
// 80F1200: using guessed type int dl_ns[];

//----- (080895E0) --------------------------------------------------------
int *__usercall add_path_8960_isra_2_constprop_6@<eax>(int *result@<eax>, int a2@<ecx>)
{
  int v3; // edx
  int *v4; // esi
  unsigned int v5; // edx
  int v6; // ecx
  int v7; // eax
  _BYTE *v8; // ecx
  _DWORD *v9; // edi
  unsigned int v10; // eax

  if ( result != (int *)-1 )
  {
    v3 = *result;
    v4 = result;
    do
    {
      while ( !*(_BYTE *)(a2 + 12) )
      {
        v6 = *(_DWORD *)(a2 + 4);
        v7 = 8 * v6;
        *(_DWORD *)(a2 + 4) = v6 + 1;
        v8 = *(_BYTE **)a2;
        v9 = (_DWORD *)(*(_DWORD *)(a2 + 8) + v7 + 8);
        *v9 = *(_DWORD *)a2;
        v10 = *(_DWORD *)(v3 + 16);
        if ( v10 <= 1 )
        {
          *v8 = 47 - (v10 == 0);
          result = (int *)(*(_DWORD *)a2 + 1);
        }
        else
        {
          result = (int *)mempcpy(v8, *(_BYTE **)(v3 + 12), v10 - 1);
        }
        *(_DWORD *)a2 = result;
        ++v4;
        *(_BYTE *)result = 0;
        v3 = *v4;
        ++*(_DWORD *)a2;
        v9[1] = 0;
        if ( !v3 )
          return result;
      }
      result = *(int **)(a2 + 8);
      ++result[1];
      v5 = *(_DWORD *)(v3 + 16);
      if ( v5 < 2 )
        v5 = 2;
      ++v4;
      *result += v5;
      v3 = *v4;
    }
    while ( *v4 );
  }
  return result;
}

//----- (08089690) --------------------------------------------------------
int __cdecl dl_dst_count(int a1, int a2)
{
  int v2; // esi
  char *v3; // eax
  char *v4; // ebx
  int v5; // eax

  v2 = 0;
  v3 = (char *)a1;
  do
  {
    v4 = v3 + 1;
    v5 = is_dst(a1, v3 + 1, "ORIGIN", a2, _libc_enable_secure);
    if ( v5 || (v5 = is_dst(a1, v4, "PLATFORM", a2, 0)) != 0 || (v5 = is_dst(a1, v4, "LIB", a2, 0)) != 0 )
      ++v2;
    v3 = strchr(&v4[v5], 36);
  }
  while ( v3 );
  return v2;
}
// 80EEFC8: using guessed type int _libc_enable_secure;

//----- (08089740) --------------------------------------------------------
char *__cdecl dl_dst_substitute(int a1, char *a2, char *a3, int a4)
{
  char *v4; // ebx
  char v5; // cl
  char *v6; // esi
  char *v7; // edi
  unsigned int v9; // edx
  const char *origin; // eax
  char i; // al
  int v12; // eax
  char v13; // al
  char *v14; // edx
  unsigned int v15; // [esp+10h] [ebp-2Ch]
  unsigned int v16; // [esp+10h] [ebp-2Ch]
  bool v17; // [esp+17h] [ebp-25h]
  char *v18; // [esp+18h] [ebp-24h]
  int v19; // [esp+1Ch] [ebp-20h]

  v4 = a2;
  v17 = 0;
  v5 = *a2;
  v18 = a3;
  v6 = a3;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( v5 == 36 )
      {
        v7 = v4 + 1;
        v19 = _libc_enable_secure;
        v9 = is_dst((int)a2, v4 + 1, "ORIGIN", a4, _libc_enable_secure);
        if ( v9 )
        {
          if ( a1 )
          {
            origin = *(const char **)(a1 + 424);
          }
          else
          {
            v16 = v9;
            origin = (const char *)dl_get_origin();
            v9 = v16;
            v19 = _libc_enable_secure;
          }
          v17 = 0;
          if ( v19 )
            v17 = (*(_BYTE *)(a1 + 404) & 3) == 0;
        }
        else
        {
          v9 = is_dst((int)a2, v4 + 1, "PLATFORM", a4, 0);
          origin = dl_platform;
          if ( !v9 )
          {
            v9 = is_dst((int)a2, v4 + 1, "LIB", a4, 0);
            if ( !v9 )
            {
LABEL_27:
              *v6++ = 36;
              v5 = v4[1];
              goto LABEL_5;
            }
            origin = "lib32";
          }
        }
        if ( (unsigned int)(origin - 1) <= 0xFFFFFFFD )
        {
          v15 = v9;
          v12 = stpcpy(v6, origin);
          v7 += v15;
          v5 = *v7;
          v6 = (char *)v12;
          goto LABEL_5;
        }
        if ( v9 <= 1 )
          goto LABEL_27;
        v7 += v9;
        for ( i = *v7; *v7; i = *++v7 )
        {
          if ( a4 && i == 58 )
            break;
        }
        if ( v18 != a3 || !a4 || i != 58 || (v5 = v7[1]) == 0 )
        {
          v5 = *v7;
          v6 = v18;
          goto LABEL_5;
        }
        v6 = v18;
        v4 = v7 + 1;
      }
      *v6++ = v5;
      v7 = v4 + 1;
      v5 = v4[1];
      if ( !a4 || v5 != 58 )
        break;
      if ( v17 )
      {
        ++v4;
        v13 = is_trusted_path_normalize(v18, v6 - v18);
        v14 = v18;
        v17 = 0;
        v5 = 58;
        if ( v13 )
          v14 = v6;
        v18 = v14;
        if ( !v13 )
          v6 = v14;
      }
      else
      {
        v18 = v6;
        ++v4;
      }
    }
LABEL_5:
    if ( !v5 )
      break;
    v4 = v7;
  }
  if ( v17 && !(unsigned __int8)is_trusted_path_normalize(v18, v6 - v18) )
    v6 = v18;
  *v6 = 0;
  return a3;
}
// 80481F0: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 80EEFC8: using guessed type int _libc_enable_secure;

//----- (08089980) --------------------------------------------------------
char *__usercall expand_dynamic_string_token@<eax>(int a1@<eax>, char *s@<edx>, int a3@<ecx>)
{
  char *v6; // eax
  char *result; // eax
  unsigned int v8; // kr04_4
  const char *v9; // edx
  unsigned int v10; // eax
  unsigned int v11; // edx
  char *v12; // edx
  int v13; // eax
  unsigned int v14; // ecx
  int origin; // eax
  unsigned int v16; // ecx
  int v17; // [esp+18h] [ebp-24h]

  v6 = strchr(s, 36);
  if ( !v6 )
    return local_strdup(s);
  v17 = dl_dst_count((int)v6, a3);
  if ( !v17 )
    return local_strdup(s);
  v8 = strlen(s) + 1;
  if ( !a1 )
  {
    origin = dl_get_origin();
    v16 = origin - 1;
    v9 = (const char *)origin;
    v10 = 0;
    if ( v16 > 0xFFFFFFFD )
      goto LABEL_8;
    goto LABEL_7;
  }
  v9 = *(const char **)(a1 + 424);
  if ( !v9 )
  {
    if ( **(_BYTE **)(a1 + 4) )
      _assert_fail("(l)->l_name[0] == '\\0' || 0", "dl-load.c", 438, "expand_dynamic_string_token");
    v13 = dl_get_origin();
    v14 = v13 - 1;
    v9 = (const char *)v13;
    *(_DWORD *)(a1 + 424) = v13;
    v10 = 0;
    if ( v14 > 0xFFFFFFFD )
      goto LABEL_8;
    goto LABEL_7;
  }
  v10 = 0;
  if ( v9 != (const char *)-1 )
LABEL_7:
    v10 = strlen(v9);
LABEL_8:
  v11 = 5;
  if ( (unsigned int)dl_platformlen >= 5 )
    v11 = dl_platformlen;
  if ( v11 >= v10 )
    v10 = v11;
  v12 = (char *)malloc(v8 + v17 * (v10 - 4));
  result = 0;
  if ( v12 )
    return dl_dst_substitute(a1, s, v12, a3);
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80F118C: using guessed type int dl_platformlen;

//----- (08089AE0) --------------------------------------------------------
int __usercall cache_rpath@<eax>(int a1@<eax>, int *a2@<edx>, int a3@<ecx>, int a4)
{
  int v5; // edx
  int result; // eax
  int v8; // ecx
  char *v9; // eax
  _BYTE *v10; // ebp
  int v11; // edx
  char *v12; // eax
  int v13; // esi
  char v14; // al
  int v15; // ecx
  char *v16; // edx
  _DWORD *v17; // eax
  _DWORD *v18; // edi
  const char *v19; // eax
  _BYTE *i; // edi
  char v21; // dl
  char v22; // [esp+1Ah] [ebp-22h]

  v5 = *a2;
  if ( v5 == -1 )
    return 0;
  result = 1;
  if ( v5 )
    return result;
  result = *(_DWORD *)(a1 + 4 * a3 + 32);
  if ( result )
  {
    v8 = *(_DWORD *)(result + 4);
    v9 = (char *)dl_inhibit_rpath;
    v10 = *(_BYTE **)(a1 + 4);
    v11 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
    if ( dl_inhibit_rpath && !_libc_enable_secure )
    {
      for ( i = *(_BYTE **)(a1 + 4); ; i = *(_BYTE **)(a1 + 4) )
      {
        while ( 1 )
        {
          v22 = *v9;
          if ( *v9 != *i )
            break;
          if ( !v22 )
            goto LABEL_13;
          ++v9;
          ++i;
        }
        if ( !*i && (v22 == 58 || !v22) )
          goto LABEL_13;
        do
        {
          v21 = *v9;
          if ( !*v9 )
            goto LABEL_27;
          ++v9;
        }
        while ( v21 != 58 );
        if ( !*v9 )
          break;
      }
LABEL_27:
      v11 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
    }
    v12 = expand_dynamic_string_token(a1, (char *)(v8 + v11), 1);
    v13 = (int)v12;
    if ( !v12 )
    {
      v19 = "cannot create RUNPATH/RPATH copy";
      goto LABEL_15;
    }
    v14 = *v12;
    v15 = 0;
    v16 = (char *)v13;
    if ( v14 )
    {
      do
      {
        ++v16;
        v15 += v14 == 58;
        v14 = *v16;
      }
      while ( *v16 );
      v17 = (_DWORD *)malloc(4 * v15 + 8);
      v18 = v17;
      if ( v17 )
      {
        fillin_rpath(v13, v17, ":", 0, a4, v10);
        free(v13);
        result = 1;
        *a2 = (int)v18;
        a2[1] = 1;
        return result;
      }
      free(v13);
      v19 = "cannot create cache for search path";
LABEL_15:
      dl_signal_error(v19);
    }
    free(v13);
LABEL_13:
    *a2 = -1;
    return 0;
  }
  else
  {
    *a2 = -1;
  }
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80F11F4: using guessed type int dl_inhibit_rpath;

//----- (08089CA0) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __usercall dl_init_paths(_BYTE *a1@<eax>, long double a2@<st0>)
{
  _DWORD *v2; // eax
  unsigned int v3; // esi
  _DWORD *v4; // eax
  _DWORD *v5; // edx
  const char *v6; // edi
  int v7; // edx
  int v8; // esi
  _DWORD *v9; // ecx
  int v10; // edx
  _DWORD *v11; // edx
  size_t v12; // edx
  int v13; // edx
  int v14; // eax
  void *v15; // esp
  _BYTE *v16; // ebx
  char v17; // al
  size_t v18; // edx
  _BYTE *v19; // edx
  int v20; // ecx
  _DWORD *v21; // eax
  char *v22; // eax
  char v23[12]; // [esp+10h] [ebp-38h] BYREF
  _BYTE *v24; // [esp+1Ch] [ebp-2Ch]
  _DWORD *v25; // [esp+20h] [ebp-28h]
  int v26; // [esp+24h] [ebp-24h]
  _DWORD *v27; // [esp+28h] [ebp-20h]
  _DWORD *v28; // [esp+2Ch] [ebp-1Ch]
  int savedregs; // [esp+48h] [ebp+0h] BYREF

  v24 = a1;
  capstr = (int)dl_important_hwcaps(&ncapstr, (int)&max_capstrlen);
  malloc(a2, 0x14u);
  v27 = v2;
  rtld_search_dirs = (int)v2;
  if ( !v2 )
  {
    v22 = "cannot create search path array";
LABEL_22:
    dl_signal_error(12, 0, 0, a2, v22);
  }
  v3 = (4 * ncapstr + 39) / 0x14u;
  malloc(a2, 720 * v3);
  v5 = v27;
  *v27 = v4;
  if ( !v4 )
    goto LABEL_21;
  v6 = "/usr/lib32/";
  v28 = v5 + 1;
  v7 = 5 * v3;
  v8 = 0;
  v7 *= 4;
  dword_80EEFE0 = 0;
  v9 = (_DWORD *)((char *)v4 + v7);
  dl_all_dirs = (int)v4;
  v4[1] = "system search path";
  v4[2] = 0;
  v4[3] = "/lib32/";
  v4[4] = 7;
  v26 = v7;
  while ( 1 )
  {
    v10 = 0;
    if ( ncapstr )
    {
      do
        v4[v10++ + 5] = 0;
      while ( v10 != ncapstr );
    }
    if ( ++v8 == 4 )
      break;
    v11 = v28;
    *v4 = v9;
    v9[1] = "system search path";
    v9[2] = 0;
    *v11 = v9;
    v25 = v11 + 1;
    v12 = system_dirs_len[v8];
    v9[3] = v6;
    v4 = (_DWORD *)((char *)v4 + v26);
    v9[4] = v12;
    v13 = (int)&v6[v12 + 1];
    v9 = (_DWORD *)((char *)v9 + v26);
    if ( *v6 != 47 )
      _assert_fail((int)&savedregs, a2, (int)"pelem->dirname[0] == '/'", (int)"dl-load.c", 772, "_dl_init_paths");
    v6 = (const char *)v13;
    v27 = v28;
    v28 = v25;
  }
  *v4 = 0;
  max_dirnamelen = 11;
  v27[1] = 0;
  if ( !v24 || !*v24 )
  {
    env_path_list = -1;
    return;
  }
  v14 = strlen(v24);
  v15 = alloca(v14 + 16);
  v16 = memcpy(v23, v24, v14 + 1);
  v17 = *v24;
  v18 = 8;
  if ( *v24 )
  {
    v19 = v24;
    v20 = 1;
    do
    {
      v20 += (unsigned __int8)(v17 - 58) < 2u;
      v17 = *++v19;
    }
    while ( *v19 );
    v18 = 4 * v20 + 4;
  }
  malloc(a2, v18);
  env_path_list = (int)v21;
  if ( !v21 )
  {
LABEL_21:
    v22 = "cannot create cache for search path";
    goto LABEL_22;
  }
  fillin_rpath((int)v16, v21, ":;", _libc_enable_secure, (int)"LD_LIBRARY_PATH", 0);
  if ( !*(_DWORD *)env_path_list )
  {
    free(a2, env_path_list);
    env_path_list = -1;
  }
  dword_80EEFE8 = 0;
}
// 8089CCB: write access to const memory at 80EEFD8 has been detected
// 8089CE1: write access to const memory at 80EEFDC has been detected
// 8089D37: write access to const memory at 80EEFE0 has been detected
// 8089E01: write access to const memory at 80EEFE4 has been detected
// 8089E83: write access to const memory at 80EEFE4 has been detected
// 8089EBC: write access to const memory at 80EEFE8 has been detected
// 8089ED6: write access to const memory at 80EEFE4 has been detected
// 8089CDE: variable 'v2' is possibly undefined
// 8089D1A: variable 'v4' is possibly undefined
// 8089E83: variable 'v21' is possibly undefined
// 80CCD40: using guessed type size_t system_dirs_len[8];
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80EEFD0: using guessed type int ncapstr;
// 80EEFD4: using guessed type int max_capstrlen;
// 80EEFD8: using guessed type int capstr;
// 80EEFDC: using guessed type int rtld_search_dirs;
// 80EEFE0: using guessed type int dword_80EEFE0;
// 80EEFE4: using guessed type int env_path_list;
// 80EEFE8: using guessed type int dword_80EEFE8;
// 80F0DE0: using guessed type int max_dirnamelen;
// 80F118C: using guessed type int dl_platformlen;
// 80F11EC: using guessed type int dl_all_dirs;
// 8089CA0: using guessed type char anonymous_0[12];

//----- (08089F30) --------------------------------------------------------
int __userpurge dl_map_object@<eax>(int a1@<eax>, char *a2@<edx>, char a3@<cl>, int a4, int a5, int a6)
{
  int v8; // ebp
  int v9; // edi
  char v10; // al
  char *v12; // eax
  int v13; // edx
  _BYTE *v14; // edx
  const char *v15; // eax
  int v16; // eax
  int v17; // edx
  char *v18; // eax
  int v19; // eax
  int v20; // edi
  int v21; // eax
  int v22; // eax
  int v23; // edx
  _BYTE *v24; // eax
  int v25; // eax
  const char *v26; // edi
  int v27; // ecx
  int v28; // esi
  int v29; // edx
  char *v30; // ebp
  size_t n; // ebx
  int v32; // eax
  int v33; // [esp+28h] [ebp-254h]
  int v34; // [esp+28h] [ebp-254h]
  int v35; // [esp+28h] [ebp-254h]
  int v36; // [esp+2Ch] [ebp-250h]
  bool v38; // [esp+34h] [ebp-248h]
  _BYTE *v39; // [esp+34h] [ebp-248h]
  int v40; // [esp+38h] [ebp-244h]
  char *s1; // [esp+3Ch] [ebp-240h]
  char s1a; // [esp+3Ch] [ebp-240h]
  unsigned int v43; // [esp+40h] [ebp-23Ch]
  int v44; // [esp+44h] [ebp-238h]
  char v45[516]; // [esp+50h] [ebp-22Ch] BYREF
  char *v46; // [esp+254h] [ebp-28h] BYREF
  int v47; // [esp+258h] [ebp-24h] BYREF
  char v48[29]; // [esp+25Fh] [ebp-1Dh] BYREF

  v8 = a6;
  if ( a6 < 0 )
    _assert_fail("nsid >= 0", "dl-load.c", 2283, "_dl_map_object");
  if ( a6 >= (unsigned int)dl_nns )
    _assert_fail("nsid < _dl_nns", "dl-load.c", 2284, "_dl_map_object");
  v9 = dl_ns[19 * a6];
  if ( v9 )
  {
    while ( 1 )
    {
      v10 = *(_BYTE *)(v9 + 405);
      if ( (v10 & 2) == 0 && (v10 & 0x20) == 0 )
      {
        if ( dl_name_match_p(a2, v9) )
          return v9;
        if ( (*(_BYTE *)(v9 + 405) & 1) == 0 )
        {
          v23 = *(_DWORD *)(v9 + 88);
          if ( v23 )
          {
            if ( !strcmp(a2, (const char *)(*(_DWORD *)(v23 + 4) + *(_DWORD *)(*(_DWORD *)(v9 + 52) + 4))) )
              break;
          }
        }
      }
      v9 = *(_DWORD *)(v9 + 12);
      if ( !v9 )
        goto LABEL_11;
    }
    add_name_to_object(v9, a2);
    *(_BYTE *)(v9 + 405) |= 1u;
    return v9;
  }
LABEL_11:
  v38 = a1 != 0;
  if ( a1 && (dl_debug_mask & 0x40) != 0 )
  {
    v14 = *(_BYTE **)(a1 + 4);
    if ( !*v14 )
      v14 = program_invocation_short_name;
    v15 = "\nfile=%s [%lu];  dynamically loaded by %s [%lu]\n";
    v40 = a5 & 0x10000000;
    if ( (a5 & 0x10000000) == 0 )
      v15 = "\nfile=%s [%lu];  needed by %s [%lu]\n";
    dl_debug_printf((int)v15, a2, a6, v14, *(_DWORD *)(a1 + 24));
  }
  else
  {
    v40 = a5 & 0x10000000;
  }
  v48[0] = 0;
  if ( strchr(a2, 47) )
  {
    if ( a1 )
      v12 = expand_dynamic_string_token(a1, a2, 0);
    else
      v12 = local_strdup(a2);
    v13 = -1;
    v46 = v12;
    if ( v12 )
    {
      v13 = open_verify_isra_3(v12, (int)v45, (int)v48, 1);
      if ( v13 == -1 )
      {
        free(v46);
        v13 = -1;
      }
    }
    goto LABEL_19;
  }
  v43 = strlen(a2) + 1;
  if ( (dl_debug_mask & 1) != 0 )
    dl_debug_printf((int)"find library=%s [%lu]; searching\n", a2, a6);
  if ( !a1 || !*(_DWORD *)(a1 + 148) )
  {
    v44 = dl_ns[0];
    if ( a1 )
    {
      v20 = a1;
      s1a = 0;
      do
      {
        if ( (unsigned __int8)cache_rpath(v20, (int *)(v20 + 408), 15, (int)"RPATH") )
        {
          v21 = open_path_isra_4(a2, v43, a5 & 0x4000000, (int *)(v20 + 408), &v46, (int)v45, a1, (int)v48);
          if ( v21 != -1 )
          {
            v13 = v21;
            v8 = a6;
            goto LABEL_38;
          }
          s1a |= v20 == v44;
        }
        v20 = *(_DWORD *)(v20 + 364);
      }
      while ( v20 );
      v8 = a6;
      if ( s1a )
        goto LABEL_33;
    }
    if ( v44
      && (*(_BYTE *)(v44 + 404) & 3) != 2
      && (unsigned __int8)cache_rpath(v44, (int *)(v44 + 408), 15, (int)"RPATH") )
    {
      v22 = v44;
      if ( a1 )
        v22 = a1;
      v13 = open_path_isra_4(a2, v43, a5 & 0x4000000, (int *)(v44 + 408), &v46, (int)v45, v22, (int)v48);
      if ( v13 != -1 )
        goto LABEL_38;
    }
  }
LABEL_33:
  if ( env_path_list == -1 )
  {
    v13 = -1;
  }
  else
  {
    v16 = a1;
    if ( !a1 )
      v16 = dl_ns[0];
    v13 = open_path_isra_4(a2, v43, a5 & 0x4000000, &env_path_list, &v46, (int)v45, v16, (int)v48);
    if ( v13 != -1 )
      goto LABEL_37;
  }
  if ( a1 )
  {
    if ( !(unsigned __int8)cache_rpath(a1, (int *)(a1 + 488), 29, (int)"RUNPATH") )
      goto LABEL_44;
    v13 = open_path_isra_4(a2, v43, a5 & 0x4000000, (int *)(a1 + 488), &v46, (int)v45, a1, (int)v48);
  }
LABEL_37:
  if ( v13 != -1 )
    goto LABEL_38;
LABEL_44:
  if ( (a5 & 0x4000000) != 0 && _libc_enable_secure )
    goto LABEL_51;
  s1 = (char *)dl_load_cache_lookup(a2);
  if ( !s1 )
    goto LABEL_51;
  if ( a1 && (*(_BYTE *)(a1 + 517) & 8) != 0 )
  {
    v26 = "/lib32/";
    v27 = a1;
    v28 = 0;
    v29 = v8;
    v30 = a2;
    while ( 1 )
    {
      n = system_dirs_len[v28];
      v35 = v29;
      v36 = v27;
      v32 = memcmp(s1, v26, n);
      v29 = v35;
      v27 = v36;
      if ( !v32 )
        break;
      ++v28;
      v26 += n + 1;
      if ( v28 == 4 )
      {
        a2 = v30;
        a1 = v36;
        v8 = v35;
        goto LABEL_48;
      }
    }
    a2 = v30;
    a1 = v36;
    v8 = v35;
    v19 = v36;
    goto LABEL_53;
  }
LABEL_48:
  v17 = open_verify_isra_3(s1, (int)v45, (int)v48, 0);
  if ( v17 == -1 )
  {
LABEL_51:
    v19 = a1;
    if ( !v38 )
      v19 = dl_ns[19 * v8];
LABEL_53:
    v13 = -1;
    if ( (!v19 || (*(_BYTE *)(v19 + 517) & 8) == 0) && rtld_search_dirs != -1 )
      v13 = open_path_isra_4(a2, v43, a5 & 0x4000000, &rtld_search_dirs, &v46, (int)v45, v19, (int)v48);
    goto LABEL_38;
  }
  v34 = v17;
  v18 = local_strdup(s1);
  v13 = v34;
  v46 = v18;
  if ( !v18 )
  {
    close(v8, v34);
    goto LABEL_51;
  }
LABEL_38:
  if ( (dl_debug_mask & 1) != 0 )
  {
    v33 = v13;
    dl_debug_printf((int)"\n");
    v13 = v33;
  }
LABEL_19:
  if ( v40 )
    a1 = 0;
  if ( v13 == -1 )
  {
    if ( !a4 || (dl_debug_mask & 0x800) != 0 )
    {
      if ( v48[0] )
        dl_signal_error("wrong ELF class: ELFCLASS64");
      dl_signal_error("cannot open shared object file");
    }
    v24 = local_strdup(a2);
    v39 = v24;
    if ( !v24 || (v25 = dl_new_object(v24, a2, a3, a1, a5, v8), (v9 = v25) == 0) )
    {
      free(v39);
      dl_signal_error("cannot create shared object descriptor");
    }
    *(_BYTE *)(v25 + 405) |= 2u;
    *(_BYTE *)(v25 + 404) |= 4u;
    *(_DWORD *)(v25 + 396) = &dummy_bucket_8949;
    *(_DWORD *)(v25 + 376) = 1;
    dl_add_to_namespace_list((_DWORD *)v25, v8);
    return v9;
  }
  v47 = _libc_stack_end;
  return dl_map_object_from_fd(a2, v13, (int)v45, v46, a1, a3, a5, (int)&v47, v8);
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 80CCD40: using guessed type size_t system_dirs_len[8];
// 80EEFC0: using guessed type int _libc_stack_end;
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80EEFDC: using guessed type int rtld_search_dirs;
// 80EEFE4: using guessed type int env_path_list;
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80F1190: using guessed type int dl_debug_mask;
// 80F11C0: using guessed type int dl_nns;
// 80F1200: using guessed type int dl_ns[];
// 8089F30: using guessed type int var_24;

//----- (0808A6D0) --------------------------------------------------------
int *__usercall dl_rtld_di_serinfo@<eax>(int a1@<eax>, int *a2@<edx>, char a3@<cl>)
{
  int v4; // eax
  int v5; // eax
  int *result; // eax
  int v7; // ebx
  int v8; // ebx
  int v9[2]; // [esp+10h] [ebp-1Ch] BYREF
  int *v10; // [esp+18h] [ebp-14h]
  char v11; // [esp+1Ch] [ebp-10h]

  v10 = a2;
  v11 = a3;
  if ( a3 )
  {
    a2[1] = 0;
    v4 = 0;
    *a2 = 0;
  }
  else
  {
    v4 = a2[1];
  }
  v9[0] = (int)&a2[2 * v4 + 2];
  v5 = *(_DWORD *)(a1 + 148);
  v9[1] = 0;
  if ( !v5 )
  {
    v7 = a1;
    do
    {
      while ( !(unsigned __int8)cache_rpath(v7, (int *)(v7 + 408), 15, (int)"RPATH") )
      {
        v7 = *(_DWORD *)(v7 + 364);
        if ( !v7 )
          goto LABEL_16;
      }
      add_path_8960_isra_2_constprop_6(*(int **)(v7 + 408), (int)v9);
      v7 = *(_DWORD *)(v7 + 364);
    }
    while ( v7 );
LABEL_16:
    if ( !*(_DWORD *)(a1 + 24) )
    {
      v8 = dl_ns[0];
      if ( dl_ns[0] )
      {
        if ( dl_ns[0] != a1
          && (*(_BYTE *)(dl_ns[0] + 404) & 3) != 2
          && (unsigned __int8)cache_rpath(dl_ns[0], (int *)(dl_ns[0] + 408), 15, (int)"RPATH") )
        {
          add_path_8960_isra_2_constprop_6(*(int **)(v8 + 408), (int)v9);
        }
      }
    }
  }
  add_path_8960_isra_2_constprop_6((int *)env_path_list, (int)v9);
  result = (int *)cache_rpath(a1, (int *)(a1 + 488), 29, (int)"RUNPATH");
  if ( (_BYTE)result )
  {
    result = add_path_8960_isra_2_constprop_6(*(int **)(a1 + 488), (int)v9);
    if ( (*(_BYTE *)(a1 + 517) & 8) != 0 )
      goto LABEL_6;
  }
  else if ( (*(_BYTE *)(a1 + 517) & 8) != 0 )
  {
    goto LABEL_6;
  }
  result = add_path_8960_isra_2_constprop_6((int *)rtld_search_dirs, (int)v9);
LABEL_6:
  if ( v11 )
  {
    result = v10;
    *v10 += 8 * v10[1] + 8;
  }
  return result;
}
// 80EEFDC: using guessed type int rtld_search_dirs;
// 80EEFE4: using guessed type int env_path_list;
// 80F1200: using guessed type int dl_ns[];

//----- (0808A850) --------------------------------------------------------
int __usercall dl_cache_libcmp@<eax>(char *a1@<eax>, char *a2@<edx>)
{
  char v2; // bl
  char v3; // di
  unsigned __int8 v4; // cl
  char v5; // si
  int v6; // ebx
  char v7; // si
  int v9; // [esp+0h] [ebp-14h]

  while ( 1 )
  {
    v2 = *a1;
    if ( !*a1 )
      return -*a2;
    while ( 1 )
    {
      v3 = *a2;
      v4 = *a2 - 48;
      if ( (unsigned __int8)(v2 - 48) <= 9u )
        break;
      if ( v4 <= 9u )
        return -1;
      if ( v2 != v3 )
        return v2 - v3;
      ++a1;
      ++a2;
      v2 = *a1;
      if ( !*a1 )
        return -*a2;
    }
    if ( v4 > 9u )
      break;
    v5 = a1[1];
    v6 = v2 - 48;
    ++a1;
    v9 = v3 - 48;
    if ( (unsigned __int8)(v5 - 48) <= 9u )
    {
      do
      {
        ++a1;
        v6 = v5 + 10 * v6 - 48;
        v5 = *a1;
      }
      while ( (unsigned __int8)(*a1 - 48) <= 9u );
    }
    v7 = *++a2;
    if ( (unsigned __int8)(v7 - 48) <= 9u )
    {
      do
      {
        ++a2;
        v9 = v7 + 10 * v9 - 48;
        v7 = *a2;
      }
      while ( (unsigned __int8)(*a2 - 48) <= 9u );
    }
    if ( v6 != v9 )
      return v6 - v9;
  }
  return 1;
}

//----- (0808A970) --------------------------------------------------------
const char *__usercall dl_load_cache_lookup@<eax>(char *a1@<eax>)
{
  const char *s1; // ebx
  const char *s2; // esi
  int v3; // edi
  const char *v4; // edi
  unsigned int v5; // eax
  int v6; // ebp
  int v7; // esi
  int v8; // ebx
  unsigned int v9; // edx
  int v10; // eax
  int v12; // eax
  int v13; // esi
  int v14; // ebx
  unsigned int v15; // edx
  int v16; // eax
  _DWORD *whole_file; // eax
  _DWORD *v18; // eax
  unsigned int v19; // edx
  unsigned int v20; // edx
  int i; // edi
  int *v22; // esi
  unsigned int v23; // eax
  int v24; // eax
  unsigned int v25; // ebp
  unsigned int v26; // edx
  int j; // edi
  int *v28; // ecx
  unsigned int v29; // eax
  int v30; // eax
  int v31; // eax
  unsigned int v32; // edx
  _DWORD *v33; // [esp+18h] [ebp-54h]
  char *v34; // [esp+18h] [ebp-54h]
  int v35; // [esp+1Ch] [ebp-50h]
  int v36; // [esp+1Ch] [ebp-50h]
  unsigned int v38; // [esp+24h] [ebp-48h]
  unsigned int v39; // [esp+24h] [ebp-48h]
  int v40; // [esp+24h] [ebp-48h]
  int v41; // [esp+28h] [ebp-44h]
  unsigned int v42; // [esp+2Ch] [ebp-40h]
  int v43; // [esp+2Ch] [ebp-40h]
  int v44; // [esp+30h] [ebp-3Ch]
  int v45; // [esp+34h] [ebp-38h]
  unsigned int v46; // [esp+38h] [ebp-34h]
  int v47; // [esp+40h] [ebp-2Ch]
  int v48; // [esp+44h] [ebp-28h]
  int v49; // [esp+48h] [ebp-24h]

  if ( (dl_debug_mask & 1) != 0 )
    dl_debug_printf((int)" search cache=%s\n", "/etc/ld.so.cache");
  v33 = (_DWORD *)cache;
  if ( cache )
  {
    if ( cache != -1 )
    {
      v42 = cachesize;
      goto LABEL_6;
    }
    return 0;
  }
  whole_file = (_DWORD *)dl_sysdep_read_whole_file((int)"/etc/ld.so.cache", &cachesize, 1);
  v33 = whole_file;
  if ( whole_file == (_DWORD *)-1 )
  {
LABEL_41:
    cache = -1;
    return 0;
  }
  v42 = cachesize;
  if ( (unsigned int)cachesize <= 0x10 )
    goto LABEL_40;
  if ( !memcmp(whole_file, "ld.so-1.7.0", 0xBu) )
  {
    cache = (int)v33;
    v18 = &v33[3 * v33[3] + 4];
    v19 = 12 * v33[3] + 64;
    cache_new = (int)v18;
    if ( v42 < v19 || memcmp(v18, "glibc-ld.so.cache1.1", 0x14u) )
      cache_new = -1;
    goto LABEL_38;
  }
  if ( v42 <= 0x30 || memcmp(v33, "glibc-ld.so.cache1.1", 0x14u) )
  {
LABEL_40:
    munmap((int)v33, v42);
    goto LABEL_41;
  }
  cache_new = (int)v33;
  cache = (int)v33;
LABEL_38:
  if ( !v33 )
    _assert_fail("cache != ((void *)0)", "dl-cache.c", 236, "_dl_load_cache_lookup");
LABEL_6:
  v35 = cache_new;
  if ( cache_new != -1 )
  {
    s1 = dl_platform;
    v44 = -1;
    v45 = -1;
    if ( dl_platform )
    {
      s2 = "i386";
      v3 = 0;
      while ( strcmp(s1, s2) )
      {
        ++v3;
        s2 += 5;
        if ( v3 == 4 )
        {
          v44 = -1;
          v45 = -1;
          goto LABEL_12;
        }
      }
      v44 = ((((_BYTE)v3 + 48) & 0x20) == 0) << (v3 + 48);
      v45 = ((((_BYTE)v3 + 48) & 0x20) != 0) << (v3 + 48);
    }
LABEL_12:
    v4 = 0;
    v5 = access((int)"/etc/ld.so.nohwcap", 0);
    v6 = cache_new;
    v46 = v5;
    v41 = ~(dl_hwcap & dl_hwcap_mask);
    v7 = *(_DWORD *)(cache_new + 20) - 1;
    v38 = ~(dword_80F0BD4 & dword_80F0BCC | 0x800F0000);
    if ( v7 < 0 )
      return v4;
    v8 = v7 >> 1;
    v34 = (char *)v33 + v42 - v35;
    v9 = *(_DWORD *)(cache_new + 24 * (v7 >> 1) + 52);
    if ( (unsigned int)v34 <= v9 )
      return v4;
    while ( 1 )
    {
      v10 = dl_cache_libcmp(a1, (char *)(v35 + v9));
      if ( !v10 )
        break;
      if ( v10 >= 0 )
      {
        v7 = v8 - 1;
        if ( v8 - 1 < (int)v4 )
          return 0;
      }
      else
      {
        v4 = (const char *)(v8 + 1);
        if ( v7 < v8 + 1 )
          return 0;
      }
      v8 = (int)&v4[v7] / 2;
      v9 = *(_DWORD *)(v6 + 24 * v8 + 52);
      if ( (unsigned int)v34 <= v9 )
        return 0;
    }
    v47 = v8;
    if ( v8 > 0 )
    {
      v20 = *(_DWORD *)(v6 + 8 * (3 * v8 - 3) + 52);
      for ( i = v6 + 8 * (3 * v8 - 6) + 52; (unsigned int)v34 > v20; v20 = *(_DWORD *)(i + 24) )
      {
        if ( dl_cache_libcmp(a1, (char *)(v35 + v20)) )
          break;
        if ( !--v8 )
          break;
        i -= 24;
      }
    }
    v4 = 0;
    v49 = v7;
    while ( 1 )
    {
      v22 = (int *)(v6 + 24 * v8 + 48);
      if ( v8 > v47 )
      {
        v23 = *(_DWORD *)(v6 + 24 * v8 + 52);
        if ( (unsigned int)v34 <= v23 || dl_cache_libcmp(a1, (char *)(v23 + v35)) )
          goto LABEL_61;
      }
      v24 = *v22;
      if ( (*v22 == 3 || v24 == 1)
        && (unsigned int)v34 > *(_DWORD *)(v6 + 24 * v8 + 56)
        && (!v4 || v24 == dl_correct_cache_id) )
      {
        v43 = *(_DWORD *)(v6 + 24 * v8 + 68);
        v48 = *(_DWORD *)(v6 + 24 * v8 + 64);
        if ( !(v48 & v41 | v43 & v38) && (!dl_osversion || (unsigned int)dl_osversion >= *(_DWORD *)(v6 + 24 * v8 + 60)) )
        {
          if ( v46 )
          {
            if ( (v43 & 0xF0000) != 0 && v44 | v45 ^ v43 & 0xF0000 )
              goto LABEL_60;
          }
          else if ( v48 | v43 )
          {
            goto LABEL_60;
          }
          v4 = (const char *)(*(_DWORD *)(v6 + 24 * v8 + 56) + v35);
          if ( v24 == dl_correct_cache_id )
            goto LABEL_61;
        }
      }
LABEL_60:
      if ( ++v8 > v49 )
        goto LABEL_61;
    }
  }
  v4 = 0;
  v12 = v33[3];
  v13 = v12 - 1;
  if ( v12 - 1 < 0 )
    return v4;
  v14 = v13 >> 1;
  v36 = (int)&v33[3 * v12 + 4];
  v15 = v33[3 * (v13 >> 1) + 5];
  if ( v42 - (12 * v12 + 16) <= v15 )
    return v4;
  v39 = v42 - (12 * v12 + 16);
  while ( 1 )
  {
    v16 = dl_cache_libcmp(a1, (char *)(v36 + v15));
    if ( !v16 )
      break;
    if ( v16 >= 0 )
      v13 = v14 - 1;
    else
      v4 = (const char *)(v14 + 1);
    if ( v13 >= (int)v4 )
    {
      v14 = (int)&v4[v13] / 2;
      v15 = v33[3 * v14 + 5];
      if ( v39 > v15 )
        continue;
    }
    return 0;
  }
  v25 = v39;
  v40 = v14;
  if ( v14 > 0 )
  {
    v26 = v33[3 * v14 + 2];
    for ( j = (int)&v33[3 * v14 - 1]; v25 > v26; v26 = *(_DWORD *)(j + 12) )
    {
      if ( dl_cache_libcmp(a1, (char *)(v36 + v26)) )
        break;
      if ( !--v14 )
        break;
      j -= 12;
    }
  }
  v4 = 0;
  do
  {
    v28 = &v33[3 * v14 + 4];
    if ( v14 > v40 )
    {
      v29 = v33[3 * v14 + 5];
      if ( v25 <= v29 )
        break;
      v30 = dl_cache_libcmp(a1, (char *)(v29 + v36));
      v28 = &v33[3 * v14 + 4];
      if ( v30 )
        break;
    }
    v31 = *v28;
    if ( *v28 == 3 || v31 == 1 )
    {
      v32 = v28[2];
      if ( v25 > v32 )
      {
        if ( v4 )
        {
          if ( v31 == dl_correct_cache_id )
          {
            v4 = (const char *)(v32 + v36);
            break;
          }
        }
        else
        {
          v4 = (const char *)(v32 + v36);
          if ( v31 == dl_correct_cache_id )
            break;
        }
      }
    }
  }
  while ( ++v14 <= v13 );
LABEL_61:
  if ( !v4 || (dl_debug_mask & 1) == 0 )
    return v4;
  dl_debug_printf((int)"  trying file=%s\n", v4);
  return v4;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EF5B0: using guessed type int dl_correct_cache_id;
// 80F0BC8: using guessed type int dl_hwcap_mask;
// 80F0BCC: using guessed type int dword_80F0BCC;
// 80F0BD0: using guessed type int dl_hwcap;
// 80F0BD4: using guessed type int dword_80F0BD4;
// 80F0DE4: using guessed type int cache;
// 80F0DE8: using guessed type int cachesize;
// 80F0DEC: using guessed type int cache_new;
// 80F1190: using guessed type int dl_debug_mask;
// 80F11F0: using guessed type int dl_osversion;

//----- (0808AF10) --------------------------------------------------------
unsigned int dl_unload_cache()
{
  unsigned int result; // eax

  result = cache;
  if ( (unsigned int)(cache - 1) <= 0xFFFFFFFD )
  {
    result = munmap(cache, cachesize);
    cache = 0;
  }
  return result;
}
// 80F0DE4: using guessed type int cache;
// 80F0DE8: using guessed type int cachesize;

//----- (0808AF40) --------------------------------------------------------
int __usercall enter_8787@<eax>(int a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, int a4, int a5, int a6)
{
  int v7; // esi
  unsigned int v8; // edx
  unsigned int v9; // eax
  _DWORD *v10; // esi
  int result; // eax

  v7 = a3 % a2;
  v8 = a3 % (a2 - 2) + 1;
LABEL_2:
  v9 = v8 + v7;
  v10 = (_DWORD *)(a1 + 16 * v7);
  while ( v10[1] )
  {
    v10 += 4 * v8;
    if ( a2 <= v9 )
    {
      v7 = v9 - a2;
      goto LABEL_2;
    }
    v9 += v8;
  }
  *v10 = a3;
  v10[1] = a4;
  v10[2] = a5;
  result = a6;
  v10[3] = a6;
  return result;
}

//----- (0808AFB0) --------------------------------------------------------
int __usercall check_match_8739@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // ebx
  int v4; // eax
  int v5; // edx
  int v6; // edi
  int v7; // edx
  int v8; // eax
  __int16 v9; // bp
  int v10; // eax
  int v11; // esi
  __int16 v13; // dx
  int v14; // eax
  const char *v15; // eax

  v2 = a1;
  v4 = *(_BYTE *)(a1 + 12) & 0xF;
  if ( v4 != 6 && !*(_DWORD *)(v2 + 4) )
    return 0;
  if ( ((*(_WORD *)(v2 + 14) == 0) & *(_DWORD *)(a2 + 36)) != 0 )
    return 0;
  v5 = 1127;
  if ( !_bittest(&v5, v4)
    || v2 != *(_DWORD *)(a2 + 32)
    && strcmp((const char *)(*(_DWORD *)v2 + *(_DWORD *)(a2 + 28)), *(const char **)(a2 + 24)) )
  {
    return 0;
  }
  v6 = *(_DWORD *)(a2 + 16);
  v7 = *(_DWORD *)(a2 + 20);
  v8 = *(_DWORD *)(v7 + 420);
  if ( !v6 )
  {
    if ( !v8 )
      return v2;
    v13 = *(_WORD *)(v8 + 2 * *(_DWORD *)(a2 + 12));
    if ( ((int)(*(_DWORD *)(a2 + 8) << 30) >> 31) + 3 > (v13 & 0x7FFF) )
      return v2;
    if ( v13 >= 0 )
    {
      v14 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = v14 + 1;
      if ( !v14 )
      {
        *(_DWORD *)a2 = v2;
        return 0;
      }
    }
    return 0;
  }
  if ( v8 )
  {
    v9 = *(_WORD *)(v8 + 2 * *(_DWORD *)(a2 + 12));
    v10 = *(_DWORD *)(v7 + 368) + 16 * (v9 & 0x7FFF);
    v11 = *(_DWORD *)(v10 + 4);
    if ( v11 == *(_DWORD *)(v6 + 4) && !strcmp(*(const char **)v10, *(const char **)v6) )
      return v2;
    if ( !*(_DWORD *)(v6 + 8) && !v11 )
    {
      if ( v9 < 0 )
        return 0;
      return v2;
    }
    return 0;
  }
  v15 = *(const char **)(v6 + 12);
  if ( v15 && dl_name_match_p(v15, v7) )
    _assert_fail(
      "version->filename == ((void *)0) || ! _dl_name_match_p (version->filename, map)",
      "dl-lookup.c",
      168,
      "check_match");
  return v2;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0808B130) --------------------------------------------------------
int __usercall do_lookup_x@<eax>(
        char *a1@<eax>,
        unsigned int a2@<edx>,
        unsigned int *a3@<ecx>,
        int a4,
        int *a5,
        int *a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12)
{
  unsigned int v13; // ebp
  int v14; // edi
  int v15; // eax
  _DWORD *v16; // ebx
  unsigned int v17; // ebp
  unsigned int v18; // eax
  const char *v19; // eax
  int v21; // eax
  char v22; // dl
  unsigned int v23; // ebx
  int v24; // esi
  unsigned int v25; // edx
  unsigned int v26; // ecx
  unsigned int v27; // ebx
  unsigned int v28; // eax
  unsigned int v29; // ecx
  unsigned int v30; // edi
  unsigned int v31; // edx
  unsigned int v32; // ebx
  int v33; // esi
  int v34; // ebp
  int v35; // eax
  unsigned int v36; // eax
  unsigned int v37; // ebx
  int v38; // ebp
  int v39; // eax
  int v40; // edi
  unsigned int *v41; // esi
  int v42; // eax
  int v43; // eax
  int v44; // eax
  unsigned int v45; // ebp
  const char *v46; // edx
  int v47; // edx
  int *v48; // ebx
  int v49; // eax
  char *v50; // ebp
  int i; // ecx
  int v52; // eax
  unsigned int v53; // [esp+1Ch] [ebp-80h]
  unsigned int v54; // [esp+28h] [ebp-74h]
  unsigned int v55; // [esp+2Ch] [ebp-70h]
  unsigned int v56; // [esp+30h] [ebp-6Ch]
  unsigned int v57; // [esp+30h] [ebp-6Ch]
  int v58; // [esp+30h] [ebp-6Ch]
  _DWORD *v60; // [esp+38h] [ebp-64h]
  unsigned int v61; // [esp+3Ch] [ebp-60h]
  int v62; // [esp+3Ch] [ebp-60h]
  char v63; // [esp+40h] [ebp-5Ch]
  _DWORD *v64; // [esp+40h] [ebp-5Ch]
  int v66; // [esp+48h] [ebp-54h]
  int v67; // [esp+58h] [ebp-44h] BYREF
  int v68; // [esp+5Ch] [ebp-40h]
  int v69; // [esp+60h] [ebp-3Ch]
  int v70; // [esp+64h] [ebp-38h]
  int v71; // [esp+68h] [ebp-34h]
  int v72; // [esp+6Ch] [ebp-30h]
  char *s2; // [esp+70h] [ebp-2Ch]
  int v74; // [esp+74h] [ebp-28h]
  int v75; // [esp+78h] [ebp-24h]
  int v76; // [esp+7Ch] [ebp-20h]

  s2 = a1;
  v75 = a4;
  v13 = a6[1];
  v71 = a8;
  v69 = a9;
  v76 = a11;
  v14 = *a6;
  v53 = v13;
  v61 = a2 >> 5;
  v63 = a2 & 0x1F;
  while ( 1 )
  {
    v15 = *(_DWORD *)(v14 + 4 * a7);
    v68 = 0;
    v67 = 0;
    v72 = *(_DWORD *)(v15 + 20);
    v16 = (_DWORD *)v72;
    if ( v72 == a10 || (v76 & 2) != 0 && (*(_BYTE *)(v72 + 404) & 3) == 0 || (*(_BYTE *)(v72 + 405) & 0x20) != 0 )
      goto LABEL_16;
    if ( (dl_debug_mask & 8) != 0 )
    {
      v46 = *(const char **)(v72 + 4);
      if ( !*v46 )
        v46 = (const char *)program_invocation_short_name;
      dl_debug_printf((int)"symbol=%s;  lookup in file=%s [%lu]\n", s2, v46, *(_DWORD *)(v72 + 24));
      v16 = (_DWORD *)v72;
    }
    v17 = v16[94];
    v56 = v17;
    if ( !v17 )
      goto LABEL_16;
    v66 = *(_DWORD *)(v16[14] + 4);
    v74 = *(_DWORD *)(v16[13] + 4);
    v18 = v16[97];
    if ( !v18 )
      break;
    if ( ((unsigned __int8)(*(_DWORD *)(v18 + 4 * (v16[95] & v61)) >> v63) & (unsigned __int8)(*(_DWORD *)(v18 + 4 * (v16[95] & v61)) >> (a2 >> v16[96])) & 1) != 0 )
    {
      v47 = *(_DWORD *)(v16[98] + 4 * (a2 % v17));
      if ( v47 )
      {
        v45 = v53;
        v48 = (int *)(v16[99] + 4 * v47);
        do
        {
          if ( !((*v48 ^ a2) >> 1) )
          {
            v70 = ((int)v48 - *(_DWORD *)(v72 + 396)) >> 2;
            v21 = check_match_8739(v66 + 16 * v70, (int)&v67);
            if ( v21 )
              goto LABEL_68;
          }
          v49 = *v48++;
        }
        while ( (v49 & 1) == 0 );
      }
    }
    v70 = 0;
LABEL_11:
    if ( v68 == 1 )
    {
      v21 = v67;
      if ( v67 )
        goto LABEL_19;
    }
LABEL_12:
    if ( !v70 )
    {
      if ( v71 )
      {
        v19 = *(const char **)(v71 + 12);
        if ( v19 )
        {
          if ( dl_name_match_p(v19, v72) )
            return -1;
        }
      }
    }
LABEL_16:
    if ( v53 <= ++a7 )
      return 0;
  }
  if ( *a3 == -1 )
  {
    if ( *s2 )
    {
      v18 = (unsigned __int8)*s2;
      if ( s2[1] )
      {
        v18 = (unsigned __int8)s2[1] + 16 * v18;
        if ( s2[2] )
        {
          v18 = (unsigned __int8)s2[2] + 16 * v18;
          if ( s2[3] )
          {
            v18 = (unsigned __int8)s2[3] + 16 * v18;
            if ( s2[4] )
            {
              v50 = s2 + 5;
              v18 = (unsigned __int8)s2[4] + 16 * v18;
              for ( i = (unsigned __int8)s2[5]; *v50; v18 = ((v52 & 0xF0000000) >> 24) ^ v52 & 0xFFFFFFF )
              {
                ++v50;
                v52 = i + 16 * v18;
                i = (unsigned __int8)*v50;
              }
            }
          }
        }
      }
    }
    *a3 = v18;
  }
  v70 = *(_DWORD *)(v16[99] + 4 * (*a3 % v56));
  v44 = v70;
  if ( !v70 )
    goto LABEL_11;
  v45 = v53;
  while ( 1 )
  {
    v21 = check_match_8739(v66 + 16 * v44, (int)&v67);
    if ( v21 )
      break;
    v70 = *(_DWORD *)(*(_DWORD *)(v72 + 392) + 4 * v70);
    v44 = v70;
    if ( !v70 )
      goto LABEL_11;
  }
LABEL_68:
  v53 = v45;
LABEL_19:
  v22 = *(_BYTE *)(v21 + 12) >> 4;
  if ( v22 == 2 )
  {
    if ( !dl_dynamic_weak )
    {
LABEL_22:
      v64 = (_DWORD *)v21;
LABEL_23:
      *a5 = (int)v64;
      a5[1] = v72;
      return 1;
    }
    if ( !*a5 )
    {
      *a5 = v21;
      a5[1] = v72;
    }
    goto LABEL_12;
  }
  if ( v22 != 10 )
  {
    if ( v22 == 1 )
      goto LABEL_22;
    goto LABEL_12;
  }
  v64 = (_DWORD *)v21;
  v60 = (_DWORD *)(76 * *(_DWORD *)(v72 + 24) + 135205392);
  v62 = *((_DWORD *)&unk_80F1228 + 19 * *(_DWORD *)(v72 + 24));
  v23 = *((_DWORD *)&unk_80F122C + 19 * *(_DWORD *)(v72 + 24));
  if ( !v62 )
  {
    calloc(16, 0x1Fu);
    v62 = v43;
    if ( v43 )
    {
      v37 = 31;
      v60[6] = v43;
      v60[7] = 31;
      v60[9] = free;
      goto LABEL_40;
    }
LABEL_80:
    dl_dprintf(2, (int)"out of memory\n");
    exit(127);
  }
  v24 = a2 % v23;
  v25 = *((_DWORD *)&unk_80F122C + 19 * *(_DWORD *)(v72 + 24));
  v57 = 16 * (a2 % (v23 - 2) + 1);
  v26 = a2;
  v27 = a2 % (v23 - 2) + 1;
LABEL_29:
  v28 = v26;
  v29 = v25;
  v30 = v27 + v24;
  v31 = v27;
  v32 = v28;
  v33 = v62 + 16 * v24;
  while ( 1 )
  {
    v34 = *(_DWORD *)(v33 + 4);
    if ( *(_DWORD *)v33 == v32 )
    {
      v54 = v31;
      v55 = v29;
      v35 = strcmp(*(const char **)(v33 + 4), s2);
      v31 = v54;
      v29 = v55;
      if ( !v35 )
        break;
    }
    if ( !v34 )
    {
      v37 = v29;
      if ( 3 * v29 > 4 * v60[8] )
      {
LABEL_40:
        if ( (v76 & 2) != 0 )
        {
          enter_8787(v62, v37, a2, *v64 + v74, v75, a12);
        }
        else
        {
          enter_8787(v62, v37, a2, *v64 + v74, (int)v64, v72);
          if ( (*(_BYTE *)(v72 + 404) & 3) == 2 )
            *(_DWORD *)(v72 + 516) |= 8u;
        }
        ++v60[8];
        goto LABEL_23;
      }
      v38 = dl_higher_prime_number(v29 + 1);
      calloc(16, v38);
      v58 = v39;
      if ( v39 )
      {
        v40 = 0;
        v41 = (unsigned int *)v62;
        if ( v37 )
        {
          do
          {
            v42 = v41[1];
            if ( v42 )
              enter_8787(v58, v38, *v41, v42, v41[2], v41[3]);
            ++v40;
            v41 += 4;
          }
          while ( v40 != v37 );
        }
        v37 = v38;
        ((void (__cdecl *)(int))v60[9])(v62);
        v60[7] = v38;
        v60[6] = v58;
        v60[9] = free;
        v62 = v58;
        goto LABEL_40;
      }
      goto LABEL_80;
    }
    v33 += v57;
    if ( v29 <= v30 )
    {
      v36 = v32;
      v27 = v31;
      v25 = v29;
      v24 = v30 - v29;
      v26 = v36;
      goto LABEL_29;
    }
    v30 += v31;
  }
  if ( (v76 & 2) != 0 )
  {
    *a5 = (int)v64;
    a5[1] = v72;
  }
  else
  {
    *a5 = *(_DWORD *)(v33 + 8);
    a5[1] = *(_DWORD *)(v33 + 12);
  }
  return 1;
}
// 808B523: variable 'v39' is possibly undefined
// 808B5C3: variable 'v43' is possibly undefined
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80F1190: using guessed type int dl_debug_mask;
// 80F11D0: using guessed type int dl_dynamic_weak;

//----- (0808B7D0) --------------------------------------------------------
int __userpurge dl_lookup_symbol_x@<eax>(
        char *a1@<eax>,
        int a2@<edx>,
        int *a3@<ecx>,
        long double a4@<st0>,
        int **a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  unsigned int v10; // ebx
  unsigned __int8 *v11; // edx
  unsigned __int8 v12; // al
  int v13; // ecx
  int v14; // ebx
  int *v15; // eax
  int v16; // edx
  int **v17; // esi
  int v18; // eax
  int v19; // edx
  int v20; // esi
  int result; // eax
  char *v22; // ebx
  char *v23; // ecx
  char *v24; // edi
  int v25; // edx
  int v26; // edx
  const char *v27; // edx
  int v28; // eax
  int v29; // esi
  int v30; // ebx
  int v31; // esi
  int v32; // eax
  char *v33; // ebx
  char *v34; // edi
  void *v35; // esp
  int *v36; // eax
  const char *j; // edx
  int **v38; // esi
  int *v39; // eax
  int v40; // ecx
  int v41; // eax
  char *v42; // ebx
  const char *v43; // edx
  void *v44; // eax
  int v45; // esi
  int v46; // edx
  int v47; // eax
  int v48; // edx
  char *v49; // eax
  _DWORD *v50; // edx
  unsigned int v51; // ecx
  _DWORD *v52; // edx
  _DWORD *v53; // eax
  int v54; // edx
  const char *v55; // edx
  const char *v56; // ecx
  const char *v57; // eax
  const char *v58; // ecx
  void *v59; // esp
  int v60; // edx
  int *v61; // eax
  int v62; // eax
  unsigned int v63; // ebx
  int i; // eax
  int v65; // ebx
  _DWORD *v67; // edx
  int v68; // ecx
  int v69; // ecx
  int *v70; // edx
  int v71; // ecx
  unsigned int v72; // edx
  unsigned int v73; // ecx
  unsigned int v74; // ecx
  const char *v75; // edx
  const char *v76; // eax
  int v77; // eax
  unsigned int v78; // eax
  int v79; // edx
  int v80; // eax
  int v81; // [esp+30h] [ebp-88h] BYREF
  int v82; // [esp+34h] [ebp-84h]
  unsigned int v83; // [esp+38h] [ebp-80h]
  unsigned int v84; // [esp+3Ch] [ebp-7Ch]
  int v85; // [esp+40h] [ebp-78h]
  _DWORD *v86; // [esp+44h] [ebp-74h]
  _DWORD *v87; // [esp+48h] [ebp-70h]
  unsigned int v88; // [esp+4Ch] [ebp-6Ch]
  unsigned int v89; // [esp+50h] [ebp-68h]
  unsigned int v90; // [esp+54h] [ebp-64h]
  int v91; // [esp+58h] [ebp-60h]
  char *v92; // [esp+5Ch] [ebp-5Ch]
  const char *v93; // [esp+6Ch] [ebp-4Ch]
  char *v94; // [esp+70h] [ebp-48h]
  const char *v95; // [esp+74h] [ebp-44h]
  int v96; // [esp+78h] [ebp-40h]
  const char *v97; // [esp+7Ch] [ebp-3Ch]
  int v98; // [esp+80h] [ebp-38h]
  const char *v99; // [esp+84h] [ebp-34h]
  const char *v100; // [esp+88h] [ebp-30h]
  int v101; // [esp+8Ch] [ebp-2Ch] BYREF
  int v102; // [esp+90h] [ebp-28h]
  int v103; // [esp+94h] [ebp-24h] BYREF
  int v104; // [esp+98h] [ebp-20h]
  unsigned int v105[7]; // [esp+9Ch] [ebp-1Ch] BYREF

  v10 = 5381;
  v92 = a1;
  v91 = a2;
  v11 = (unsigned __int8 *)a1;
  v12 = *a1;
  if ( v12 )
  {
    do
    {
      ++v11;
      v13 = 33 * v10;
      v14 = v12;
      v12 = *v11;
      v10 = v13 + v14;
    }
    while ( *v11 );
  }
  v105[0] = -1;
  v101 = 0;
  v102 = 0;
  if ( a6 && (a8 & 0xFFFFFFFA) != 0 )
    _assert_fail(
      "version == ((void *)0) || (flags & ~(DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_GSCOPE_LOCK)) == 0",
      "dl-lookup.c",
      728,
      "_dl_lookup_symbol_x");
  v15 = *a5;
  if ( a9 )
  {
    v50 = (_DWORD *)*v15;
    v90 = 0;
    if ( *v50 != a9 )
    {
      v51 = 0;
      do
        ++v51;
      while ( v50[v51] != a9 );
      v90 = v51;
    }
  }
  else
  {
    v90 = 0;
  }
  if ( !v15 )
  {
LABEL_50:
    if ( (!*a3 || *(_BYTE *)(*a3 + 12) >> 4 != 2) && !a9 )
    {
      v42 = (char *)&unk_80C86D9;
      if ( v91 )
        v42 = *(char **)(v91 + 4);
      v43 = (const char *)&unk_80C86D9;
      v44 = &unk_80C86D9;
      if ( a6 )
      {
        v43 = ", version ";
        v44 = *(void **)a6;
        if ( !*(_DWORD *)a6 )
          v44 = &unk_80C86D9;
      }
      v45 = 0;
      v95 = v43;
      v46 = 1;
      v96 = (int)v44;
      v47 = 18;
      v93 = "undefined symbol: ";
      v94 = v92;
      while ( 1 )
      {
        ++v45;
        v48 = v47 + v46;
        if ( v45 == 4 )
          break;
        v49 = (char *)(&v93)[v45];
        v82 = v48;
        v47 = strlen(v49);
        v46 = v82;
      }
      v58 = "undefined symbol: ";
      v59 = alloca(v48 + 15);
      v60 = 0;
      v61 = &v81;
      while ( 1 )
      {
        v82 = v60;
        v61 = (int *)stpcpy(v61, v58);
        v60 = v82 + 1;
        if ( v82 == 3 )
          break;
        v58 = (&v93)[v60];
      }
      if ( !*v42 )
      {
        v42 = (char *)program_invocation_short_name;
        if ( !program_invocation_short_name )
          v42 = "<main program>";
      }
      dl_signal_cerror(0, v42, "symbol lookup error", a4, (char *)&v81);
    }
    *a3 = 0;
    return 0;
  }
  v16 = v90;
  v17 = a5;
  while ( 1 )
  {
    v18 = do_lookup_x(v92, v10, v105, *a3, &v101, v15, v16, a6, a8, a9, a7, v91);
    if ( v18 > 0 )
    {
LABEL_13:
      if ( !v101 )
        goto LABEL_50;
      v19 = *a3;
      if ( *a3 && (*(_BYTE *)(v19 + 13) & 3) == 3 )
      {
        if ( a7 == 1 )
        {
          v20 = v102;
          v90 = 1;
          if ( v102 != v91 )
          {
            v101 = v19;
            v90 = 1;
            v102 = v91;
            v20 = v91;
          }
        }
        else
        {
          v38 = a5;
          v103 = 0;
          v104 = 0;
          v39 = *a5;
          if ( !*a5 )
            goto LABEL_96;
          v40 = v90;
          v90 = v10;
          while ( !do_lookup_x(v92, v90, v105, v19, &v103, v39, v40, a6, a8, a9, 1, 0) )
          {
            v39 = v38[1];
            if ( !v39 )
              break;
            v19 = *a3;
            ++v38;
            v40 = 0;
          }
          if ( v103 && v104 != v91 )
          {
            v41 = *a3;
            v90 = 1;
            v102 = v91;
            v20 = v91;
            v101 = v41;
          }
          else
          {
LABEL_96:
            v20 = v102;
            v90 = 1;
          }
        }
      }
      else
      {
        v20 = v102;
        v90 = 0;
      }
      if ( (*(_BYTE *)(v20 + 404) & 3) != 2 || (a8 & 1) == 0 )
        goto LABEL_18;
      if ( v91 == v20 )
      {
        v20 = v91;
        goto LABEL_18;
      }
      if ( (*(_BYTE *)(v20 + 516) & 8) != 0 )
      {
LABEL_18:
        if ( !*(_DWORD *)(v20 + 508) )
          *(_DWORD *)(v20 + 508) = 1;
        if ( (dl_debug_mask & 0x804) != 0 )
        {
          v55 = *(const char **)(v91 + 4);
          if ( (dl_debug_mask & 4) != 0 )
          {
            v56 = "protected";
            if ( !v90 )
              v56 = "normal";
            v57 = *(const char **)(v20 + 4);
            v90 = *(_DWORD *)(v20 + 24);
            if ( !*v57 )
              v57 = (const char *)program_invocation_short_name;
            if ( !*v55 )
            {
              v55 = (const char *)program_invocation_short_name;
              if ( !program_invocation_short_name )
                v55 = "<main program>";
            }
            dl_debug_printf(
              (int)"binding file %s [%lu] to %s [%lu]: %s symbol `%s'",
              v55,
              *(_DWORD *)(v91 + 24),
              v57,
              v90,
              v56,
              v92);
            if ( a6 )
              dl_debug_printf_c((int)" [%s]\n", *(const char **)a6);
            else
              dl_debug_printf_c((int)"\n");
            v20 = v102;
          }
        }
        *a3 = v101;
        return v20;
      }
      v88 = *(_DWORD *)(v91 + 500);
      v52 = *(_DWORD **)(v91 + 496);
      v87 = v52;
      v86 = v52;
      if ( v52 && *v52 )
      {
        if ( v20 == *v52 )
          goto LABEL_75;
        v53 = v52;
        while ( 1 )
        {
          v54 = v53[1];
          if ( !v54 )
            break;
          ++v53;
          if ( v20 == v54 )
            goto LABEL_75;
        }
      }
      if ( !v88 )
      {
        v89 = 0;
        goto LABEL_106;
      }
      v89 = *(_DWORD *)v88;
      if ( !v89 )
        goto LABEL_106;
      v62 = 0;
      if ( v20 != *(_DWORD *)(v88 + 4) )
      {
        while ( ++v62 != v89 )
        {
          if ( v20 == *(_DWORD *)(v88 + 4 * v62 + 4) )
            goto LABEL_75;
        }
LABEL_106:
        v63 = *(_DWORD *)(v20 + 596);
        v84 = *(_DWORD *)(v20 + 592);
        v83 = v63;
        v85 = a8 & 4;
        if ( (a8 & 4) == 0 )
        {
LABEL_107:
          for ( i = dl_ns[19 * *(_DWORD *)(v91 + 24)]; i != v20; i = *(_DWORD *)(i + 12) )
          {
            if ( !i )
              break;
          }
          v65 = -1;
          if ( i )
          {
            if ( *(_QWORD *)(v20 + 592) != __PAIR64__(v83, v84) )
            {
LABEL_112:
              v65 = -1;
              goto LABEL_113;
            }
            v69 = *(_DWORD *)(v20 + 516);
            v65 = 0;
            if ( (v69 & 8) == 0 )
            {
              if ( (*(_BYTE *)(v91 + 404) & 3) != 2 || (*(_BYTE *)(v91 + 516) & 8) != 0 )
              {
                v65 = 0;
                *(_DWORD *)(v20 + 516) = v69 | 8;
                goto LABEL_113;
              }
              v72 = *(_DWORD *)(v91 + 504);
              if ( v72 <= v89 )
              {
                v77 = 44;
                v88 = 10;
                if ( v72 )
                {
                  v88 = 2 * v72;
                  v77 = 8 * v72 + 4;
                }
                v82 = v69;
                v65 = malloc(v77);
                if ( !v65 )
                {
                  *(_DWORD *)(v20 + 516) = v82 | 8;
                  goto LABEL_113;
                }
                if ( v89 )
                {
                  v81 = *(_DWORD *)(v91 + 500);
                  memcpy((_BYTE *)(v65 + 4), (_BYTE *)(v81 + 4), 4 * v89);
                }
                v78 = v89;
                *(_DWORD *)(v65 + 4 * v89 + 4) = v20;
                *(_DWORD *)v65 = v78 + 1;
                v79 = v91;
                v80 = *(_DWORD *)(v91 + 500);
                *(_DWORD *)(v91 + 504) = v88;
                *(_DWORD *)(v79 + 500) = v65;
                if ( v80 )
                  dl_scope_free(v80);
              }
              else
              {
                v73 = v89;
                *(_DWORD *)(*(_DWORD *)(v91 + 500) + 4 * v89 + 4) = v20;
                **(_DWORD **)(v91 + 500) = v73 + 1;
              }
              if ( (dl_debug_mask & 0x40) != 0 )
              {
                v75 = *(const char **)(v91 + 4);
                if ( !*v75 )
                  v75 = (const char *)program_invocation_short_name;
                v76 = *(const char **)(v20 + 4);
                if ( !*v76 )
                  v76 = (const char *)program_invocation_short_name;
                v65 = 0;
                dl_debug_printf(
                  (int)"\nfile=%s [%lu];  needed by %s [%lu] (relocation dependency)\n\n",
                  v76,
                  *(_DWORD *)(v20 + 24),
                  v75,
                  *(_DWORD *)(v91 + 24));
              }
              else
              {
                v65 = 0;
              }
            }
          }
LABEL_113:
          if ( v85 )
            __writegsdword(0x1Cu, 1u);
          if ( v65 == -1 )
          {
            if ( v85 )
              a5 = *(int ***)(v91 + 460);
            return dl_lookup_symbol_x(a5, a6, a7, a8, a9);
          }
          goto LABEL_75;
        }
        if ( _InterlockedExchange(MK_FP(__GS__, 28), 0) == 2 )
          dl_sysinfo(129);
        if ( v86 != v87 && v87 && *v87 )
        {
          if ( v20 == *v87 )
            goto LABEL_128;
          v67 = v87;
          while ( 1 )
          {
            v68 = v67[1];
            if ( !v68 )
              break;
            ++v67;
            if ( v20 == v68 )
              goto LABEL_128;
          }
        }
        v70 = *(int **)(v91 + 500);
        if ( !v70 )
          goto LABEL_107;
        if ( (int *)v88 == v70 )
        {
          if ( *(_DWORD *)v88 <= v89 )
            goto LABEL_107;
          if ( v20 != *(_DWORD *)(v88 + 4 * v89 + 4) )
          {
            v74 = v89;
            while ( *(_DWORD *)v88 > ++v74 )
            {
              if ( v20 == *(_DWORD *)(v88 + 4 * v74 + 4) )
                goto LABEL_128;
            }
            v89 = *(_DWORD *)v88;
            goto LABEL_107;
          }
        }
        else
        {
          v89 = *v70;
          if ( !v89 )
            goto LABEL_107;
          v71 = 0;
          if ( v20 != v70[1] )
          {
            while ( ++v71 != v89 )
            {
              if ( v20 == v70[v71 + 1] )
                goto LABEL_128;
            }
            goto LABEL_107;
          }
        }
LABEL_128:
        v65 = 0;
        if ( *(_QWORD *)(v20 + 592) != __PAIR64__(v83, v84) )
          goto LABEL_112;
        goto LABEL_113;
      }
LABEL_75:
      v20 = v102;
      goto LABEL_18;
    }
    if ( v18 < 0 && !a9 )
      break;
    v15 = *++v17;
    if ( !*v17 )
      goto LABEL_13;
    v16 = 0;
  }
  if ( !a6 )
    _assert_fail("version != ((void *)0)", "dl-lookup.c", 750, "_dl_lookup_symbol_x");
  v22 = 0;
  if ( v91 )
    v22 = *(char **)(v91 + 4);
  v23 = v92;
  v93 = "symbol ";
  v92 = (char *)a3;
  v24 = v22;
  v25 = *(_DWORD *)a6;
  v94 = v23;
  v95 = ", version ";
  v97 = " not defined in file ";
  v96 = v25;
  v26 = *(_DWORD *)(a6 + 12);
  v99 = " with link time reference";
  v98 = v26;
  v27 = " (no version symbols)";
  if ( v18 != -2 )
    v27 = (const char *)&unk_80C86D9;
  v28 = 7;
  v100 = v27;
  v29 = 0;
  v30 = 1;
  while ( 1 )
  {
    ++v29;
    v30 += v28;
    if ( v29 == 8 )
      break;
    v28 = strlen((&v93)[v29]);
  }
  v31 = 0;
  v32 = v30 + 30;
  v33 = v24;
  v34 = v92;
  v35 = alloca(v32 & 0xFFFFFFF0);
  v92 = (char *)&v81;
  v36 = &v81;
  for ( j = "symbol "; ; j = (&v93)[v31] )
  {
    ++v31;
    v36 = (int *)stpcpy(v36, j);
    if ( v31 == 8 )
      break;
  }
  if ( !*v33 )
  {
    v33 = (char *)program_invocation_short_name;
    if ( !program_invocation_short_name )
      v33 = "<main program>";
  }
  dl_signal_cerror(0, v33, "relocation error", a4, v92);
  result = 0;
  *(_DWORD *)v34 = 0;
  return result;
}
// 80481F0: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80F1190: using guessed type int dl_debug_mask;
// 80F1200: using guessed type int dl_ns[];

//----- (0808C1C0) --------------------------------------------------------
_DWORD *__usercall dl_setup_hash@<eax>(_DWORD *result@<eax>)
{
  int v1; // edx
  int *v2; // edx
  int v3; // ebx
  int v4; // ecx
  int v5; // esi
  int v6; // edi
  _DWORD *v7; // edx
  _DWORD *v8; // edx
  int v9; // edx
  int *v10; // edx
  int v11; // ecx

  v1 = result[83];
  if ( v1 )
  {
    v2 = *(int **)(v1 + 4);
    v3 = *v2;
    result[94] = *v2;
    v4 = v2[2];
    v5 = v2[1];
    if ( (v4 & (v4 - 1)) != 0 )
      _assert_fail("(bitmask_nwords & (bitmask_nwords - 1)) == 0", "dl-lookup.c", 876, "_dl_setup_hash");
    result[95] = v4 - 1;
    v6 = v2[3];
    v7 = v2 + 4;
    result[97] = v7;
    v8 = &v7[v4];
    result[98] = v8;
    result[96] = v6;
    result[99] = &v8[v3 - v5];
  }
  else
  {
    v9 = result[12];
    if ( v9 )
    {
      v10 = *(int **)(v9 + 4);
      v11 = *v10;
      v10 += 2;
      result[99] = v10;
      result[94] = v11;
      result[98] = &v10[v11];
    }
  }
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0808C280) --------------------------------------------------------
int __usercall dl_add_to_namespace_list@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v4; // edx
  int v5; // eax
  int v6; // edx
  int v7; // kr04_4
  int result; // eax

  v4 = dl_ns[19 * a2];
  if ( v4 )
  {
    while ( *(_DWORD *)(v4 + 12) )
      v4 = *(_DWORD *)(v4 + 12);
    a1[4] = v4;
    *(_DWORD *)(v4 + 12) = a1;
  }
  else
  {
    dl_ns[19 * a2] = (int)a1;
  }
  v5 = dl_load_adds;
  v6 = dword_80F119C;
  ++dword_80F1204[19 * a2];
  a1[148] = v5;
  v7 = v5;
  dl_load_adds = v5 + 1;
  result = 0;
  a1[149] = v6;
  dword_80F119C = (__PAIR64__(v6, v7) + 1) >> 32;
  return result;
}
// 80F1198: using guessed type int dl_load_adds;
// 80F119C: using guessed type int dword_80F119C;
// 80F1200: using guessed type int dl_ns[];
// 80F1204: using guessed type int dword_80F1204[];

//----- (0808C320) --------------------------------------------------------
int __userpurge dl_new_object@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, char a3@<cl>, int a4, char a5, int a6)
{
  int v7; // edi
  int v8; // ebp
  int v9; // eax
  int v10; // ebx
  _BYTE *v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  unsigned int v17; // edi
  unsigned int v18; // ebp
  char *i; // ebx
  char *v20; // eax
  const char *s; // esi
  const char *v22; // edx
  int v24; // edx
  char *v25; // eax
  _WORD *j; // eax
  const char *v27; // edx
  unsigned int v28; // [esp+14h] [ebp-28h]
  int v31; // [esp+1Ch] [ebp-20h]

  v7 = a4;
  v8 = strlen(a2);
  calloc(v8 + 617, 1u);
  v10 = v9;
  if ( !v9 )
    return v10;
  *(_DWORD *)(v9 + 20) = v9;
  *(_DWORD *)(v9 + 356) = v9 + 600;
  *(_DWORD *)(v9 + 28) = v9 + 604;
  v11 = memcpy((_BYTE *)(v9 + 616), a2, v8 + 1);
  *(_DWORD *)(v10 + 612) = 1;
  *(_DWORD *)(v10 + 604) = v11;
  *(_DWORD *)(v10 + 4) = a1;
  *(_BYTE *)(v10 + 404) = a3 & 3 | *(_BYTE *)(v10 + 404) & 0xFC;
  if ( (dl_debug_mask & 0x100) == 0 )
    *(_DWORD *)(v10 + 508) = 1;
  *(_DWORD *)(v10 + 460) = v10 + 440;
  *(_DWORD *)(v10 + 364) = a4;
  *(_DWORD *)(v10 + 456) = 4;
  *(_DWORD *)(v10 + 24) = a6;
  v12 = 0;
  v13 = dl_ns[19 * a6];
  if ( v13 )
  {
    LOBYTE(v12) = 1;
    *(_DWORD *)(v10 + 440) = v13 + 348;
  }
  if ( a4 )
  {
    while ( *(_DWORD *)(v7 + 364) )
      v7 = *(_DWORD *)(v7 + 364);
    v14 = 0;
    v15 = v7 + 348;
    if ( !v12 )
      goto LABEL_11;
  }
  else
  {
    v14 = 0;
    v15 = v10 + 348;
    if ( !v12 )
    {
LABEL_11:
      *(_DWORD *)(v10 + v14 + 440) = v15;
      goto LABEL_12;
    }
  }
  v24 = *(_DWORD *)(v10 + 440);
  if ( v24 != v15 )
  {
    if ( (a5 & 8) != 0 )
      *(_DWORD *)(v10 + 444) = v24;
    else
      v14 = 4;
    goto LABEL_11;
  }
LABEL_12:
  *(_DWORD *)(v10 + 464) = v10 + 348;
  if ( *a1 )
  {
    v16 = strlen(a1) + 1;
    v28 = v16;
    if ( *a1 == 47 )
    {
      v25 = (char *)malloc(v16);
      s = v25;
      if ( !v25 )
      {
LABEL_21:
        *(_DWORD *)(v10 + 424) = -1;
        return v10;
      }
    }
    else
    {
      v17 = v16;
      v18 = 128;
      v31 = v10;
      for ( i = 0; ; i = (char *)s )
      {
        v17 += 128;
        realloc(i, v17);
        s = v20;
        if ( !v20 )
        {
          v22 = i;
          v10 = v31;
          goto LABEL_20;
        }
        if ( getcwd(v20, v18) )
          break;
        v18 += 128;
        if ( __readgsdword(0xFFFFFFE8) != 34 )
        {
          v10 = v31;
          v22 = s;
LABEL_20:
          free(v22);
          goto LABEL_21;
        }
      }
      v10 = v31;
      v25 = strchr(s, 0);
      if ( *(v25 - 1) != 47 )
        *v25++ = 47;
    }
    for ( j = mempcpy(v25, a1, v28); ; j = (_WORD *)((char *)j - 1) )
    {
      v27 = (char *)j - 1;
      if ( *((_BYTE *)j - 1) == 47 )
        break;
    }
    if ( s == v27 )
      v27 = (const char *)j;
    *v27 = 0;
    *(_DWORD *)(v10 + 424) = s;
  }
  return v10;
}
// 808C357: variable 'v9' is possibly undefined
// 808C4A3: variable 'v20' is possibly undefined
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80F1190: using guessed type int dl_debug_mask;
// 80F1200: using guessed type int dl_ns[];

//----- (0808C5E0) --------------------------------------------------------
int __usercall dl_try_allocate_static_tls@<eax>(int a1@<eax>)
{
  unsigned int v2; // ebx
  int result; // eax
  int v4; // ebp
  unsigned int v5; // edx
  unsigned int v6; // edi
  int v7; // eax

  if ( *(_DWORD *)(a1 + 576) == 1 )
    return -1;
  v2 = *(_DWORD *)(a1 + 568);
  result = -1;
  if ( v2 <= dl_tls_static_align && (unsigned int)(dl_tls_static_size - dl_tls_static_used) > 0x4BF )
  {
    v4 = *(_DWORD *)(a1 + 572);
    v5 = dl_tls_static_size - dl_tls_static_used - 1216;
    v6 = v4 + *(_DWORD *)(a1 + 564);
    if ( v5 >= v6 )
    {
      v7 = *(_DWORD *)(a1 + 20);
      dl_tls_static_used = v5 + dl_tls_static_used - v4 - v2 * ((v5 - v6) / v2);
      *(_DWORD *)(a1 + 576) = dl_tls_static_used;
      if ( (*(_BYTE *)(v7 + 404) & 4) != 0 )
        dl_init_static_tls(a1);
      else
        *(_BYTE *)(a1 + 405) |= 4u;
      return 0;
    }
  }
  return result;
}
// 80EF068: using guessed type int dl_tls_static_size;
// 80EF5BC: using guessed type int (__cdecl *dl_init_static_tls)(_DWORD);
// 80F1140: using guessed type int dl_tls_static_used;
// 80F1144: using guessed type int dl_tls_static_align;

//----- (0808C6B0) --------------------------------------------------------
int __usercall dl_allocate_static_tls@<eax>(int a1@<eax>)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 576) == 1 || (result = dl_try_allocate_static_tls(a1)) != 0 )
    dl_signal_error("cannot allocate memory in static TLS block");
  return result;
}
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);

//----- (0808C6E0) --------------------------------------------------------
void *__cdecl dl_nothread_init_static_tls(int a1)
{
  unsigned int v1; // esi
  unsigned int v2; // edx
  unsigned int v3; // ecx
  unsigned int v4; // edx
  _BYTE *v5; // esi
  size_t v6; // ebx
  _WORD *s; // eax
  unsigned int n; // [esp+8h] [ebp-14h]

  v1 = __readgsdword(8u);
  v2 = __readgsdword(4u);
  v3 = *(_DWORD *)(a1 + 580);
  if ( v3 > *(_DWORD *)(v2 - 8) )
    _assert_fail("map->l_tls_modid <= dtv[-1].counter", "dl-reloc.c", 141, "_dl_nothread_init_static_tls");
  v4 = v2 + 8 * v3;
  v5 = (_BYTE *)(v1 - *(_DWORD *)(a1 + 576));
  *(_DWORD *)v4 = v5;
  *(_BYTE *)(v4 + 4) = 1;
  n = *(_DWORD *)(a1 + 560);
  v6 = *(_DWORD *)(a1 + 564) - n;
  s = mempcpy(v5, *(_BYTE **)(a1 + 556), n);
  return memset(s, 0, v6);
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0808C780) --------------------------------------------------------
signed int __usercall dl_protect_relro@<eax>(_DWORD *a1@<eax>)
{
  int v2; // edx
  signed int result; // eax
  int v4; // ecx
  int v5; // edx

  v2 = *a1 + a1[146];
  result = -dl_pagesize;
  v4 = v2 & -dl_pagesize;
  v5 = -dl_pagesize & (a1[147] + v2);
  if ( v4 != v5 )
  {
    result = mprotect(v4, v5 - v4);
    if ( result < 0 )
      dl_signal_error("cannot apply additional memory protection after relocation");
  }
  return result;
}
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 80EF5B8: using guessed type int dl_pagesize;

//----- (0808C7E0) --------------------------------------------------------
void __fastcall __noreturn dl_reloc_bad_type(int a1, unsigned __int8 a2)
{
  char *v3; // eax
  char v4; // dl
  char v5[44]; // [esp+10h] [ebp-2Ch] BYREF

  v3 = (char *)stpcpy(v5, 32 * a1 + 135058848);
  v4 = itoa_lower_digits[a2 >> 4];
  v3[2] = 0;
  *v3 = v4;
  v3[1] = itoa_lower_digits[a2 & 0xF];
  dl_signal_error(v5);
}
// 80481F0: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);

//----- (0808C840) --------------------------------------------------------
int __cdecl dl_relocate_object(int a1, int a2, int a3, int a4)
{
  int result; // eax
  unsigned int i; // eax
  int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // ecx
  int v9; // edx
  unsigned int v10; // edx
  unsigned int v11; // ebx
  int v12; // edx
  unsigned int v13; // edi
  _BYTE *v14; // ecx
  _DWORD *v15; // ebx
  unsigned int v16; // eax
  _DWORD *v17; // esi
  int v18; // eax
  int v19; // esi
  unsigned int j; // eax
  int v21; // eax
  unsigned int v22; // ecx
  int v23; // eax
  unsigned int v24; // ebx
  int v25; // eax
  unsigned int v26; // edx
  unsigned int v27; // edx
  int v28; // eax
  int v29; // edx
  int *v30; // eax
  int *v31; // ebx
  int v32; // eax
  int v33; // eax
  unsigned int v34; // edi
  int v35; // ecx
  _BYTE *v36; // edx
  int v37; // edi
  int (__usercall **v38)@<eax>(int@<eax>); // edx
  unsigned __int8 v39; // al
  int v40; // edx
  bool v41; // dl
  bool v42; // al
  bool v43; // dl
  bool v44; // zf
  int v45; // ecx
  int v46; // eax
  int (__usercall **v47)@<eax>(int@<eax>); // ecx
  int v48; // eax
  int (*v49)(void); // eax
  unsigned int v50; // edx
  unsigned int v51; // ecx
  int v52; // eax
  int v53; // edx
  int v54; // eax
  _DWORD *v55; // ebx
  _DWORD *v56; // edx
  int v57; // eax
  int v58; // esi
  __int16 v59; // di
  unsigned int v60; // edx
  int v61; // esi
  int (__usercall **v62)@<eax>(int@<eax>); // edi
  int v63; // edx
  _DWORD *v64; // edi
  bool v65; // al
  bool v66; // dl
  bool v67; // al
  _BOOL4 v68; // ecx
  int v69; // eax
  int v70; // ecx
  int v71; // edx
  unsigned int v72; // edx
  _DWORD *v73; // eax
  int v74; // eax
  int v75; // eax
  unsigned int v76; // edx
  unsigned int v77; // ecx
  bool v78; // cc
  int *v79; // edi
  int v80; // eax
  int v81; // eax
  unsigned int v82; // ecx
  int (__usercall **v83)@<eax>(int@<eax>); // esi
  int v84; // eax
  unsigned int v85; // edx
  int v86; // eax
  unsigned int v87; // ecx
  int v88; // edx
  unsigned int v89; // eax
  int v90; // esi
  int v91; // edx
  _DWORD *v92; // edi
  bool v93; // dl
  bool v94; // al
  bool v95; // dl
  _BOOL4 v96; // eax
  int v97; // edx
  int v98; // eax
  _DWORD *v99; // eax
  int v100; // eax
  int v101; // eax
  int (__usercall **v102)@<eax>(int@<eax>); // edi
  int v103; // eax
  unsigned int v104; // ecx
  int (__usercall **v105)@<eax>(int@<eax>); // esi
  int v106; // eax
  unsigned int v107; // edx
  int v108; // eax
  unsigned int v109; // ecx
  unsigned int v110; // edx
  unsigned int v111; // ecx
  int v112; // eax
  int v113; // edx
  unsigned int v114; // ecx
  _DWORD *v115; // edi
  int v116; // edx
  unsigned int v117; // eax
  int v118; // edx
  int v119; // edx
  unsigned int v120; // ecx
  void (*v121)(void); // edx
  int v122; // edi
  int v123; // ecx
  unsigned int v124; // edi
  int v125; // esi
  int v126; // edx
  int (*v127)(void); // ecx
  bool v128; // dl
  _BOOL4 v129; // ecx
  int v130; // edx
  int v131; // eax
  int v132; // ecx
  int (__usercall **v133)@<eax>(int@<eax>); // ecx
  int (*v134)(void); // eax
  int v135; // eax
  int (*v136)(void); // eax
  unsigned int v137; // edx
  unsigned int v138; // ecx
  int v139; // eax
  int v140; // edx
  unsigned int v141; // esi
  _DWORD *v142; // edi
  int v143; // edx
  unsigned int v144; // eax
  int v145; // edx
  int v146; // edx
  unsigned int v147; // esi
  int v148; // eax
  _DWORD *v149; // edi
  unsigned int v150; // edx
  _DWORD *v151; // esi
  int (*v152)(void); // ecx
  int v153; // eax
  __int16 v154; // ax
  int v155; // edx
  void (*v156)(void); // eax
  int v157; // ecx
  int v158; // eax
  char *v159; // eax
  int (*v160)(void); // eax
  int v161; // eax
  int v162; // edx
  int v163; // eax
  int (*v164)(void); // eax
  int v165; // eax
  _BOOL4 v166; // ecx
  const char *v167; // edx
  _BOOL4 v168; // ecx
  int v169; // eax
  int (*v170)(void); // eax
  int v171; // eax
  int v172; // eax
  const char *v173; // edx
  const char *v174; // eax
  const char *v175; // edx
  int *v176; // ebx
  const char *v177; // ecx
  int v178; // eax
  _DWORD *v179; // ebx
  int v180; // ecx
  int v181; // eax
  const char *v182; // edx
  int v183; // eax
  const char *v184; // edx
  const char *v185; // eax
  const char *v186; // edx
  _BOOL4 v187; // ecx
  const char *v188; // edx
  int v189; // [esp+0h] [ebp-D8h] BYREF
  const char *v190; // [esp+4h] [ebp-D4h]
  int v191; // [esp+8h] [ebp-D0h]
  int *v192; // [esp+Ch] [ebp-CCh]
  int (*v193)(void); // [esp+24h] [ebp-B4h]
  int *v194; // [esp+28h] [ebp-B0h]
  int v195; // [esp+2Ch] [ebp-ACh]
  int v196; // [esp+30h] [ebp-A8h]
  unsigned int v197; // [esp+34h] [ebp-A4h]
  int v198; // [esp+38h] [ebp-A0h]
  int v199; // [esp+3Ch] [ebp-9Ch]
  int v200; // [esp+40h] [ebp-98h]
  char *v201; // [esp+44h] [ebp-94h]
  int v202; // [esp+48h] [ebp-90h]
  unsigned int v203; // [esp+4Ch] [ebp-8Ch]
  int (__usercall **v204)@<eax>(int@<eax>); // [esp+50h] [ebp-88h]
  void (*k)(void); // [esp+60h] [ebp-78h]
  unsigned int v206; // [esp+64h] [ebp-74h]
  int v207; // [esp+68h] [ebp-70h]
  char *v208; // [esp+6Ch] [ebp-6Ch]
  unsigned int v209; // [esp+7Ch] [ebp-5Ch]
  unsigned int v210; // [esp+80h] [ebp-58h]
  unsigned int v211; // [esp+84h] [ebp-54h]
  char v212; // [esp+88h] [ebp-50h] BYREF
  int v213; // [esp+8Ch] [ebp-4Ch]
  int v214; // [esp+90h] [ebp-48h]
  int v215; // [esp+98h] [ebp-40h]
  unsigned int v216; // [esp+9Ch] [ebp-3Ch]
  unsigned int v217; // [esp+A0h] [ebp-38h]
  unsigned int v218; // [esp+A4h] [ebp-34h]
  char v219; // [esp+A8h] [ebp-30h] BYREF
  int v220; // [esp+ACh] [ebp-2Ch]
  int v221; // [esp+B0h] [ebp-28h]
  int v222; // [esp+B8h] [ebp-20h]
  int v223; // [esp+BCh] [ebp-1Ch]

  result = a3 & 0x2000000;
  v196 = a3 & 1;
  v195 = a3 & 0x2000000;
  if ( (*(_BYTE *)(a1 + 404) & 4) == 0 )
  {
    if ( !a4 )
    {
      v54 = 0;
      if ( !*(_DWORD *)(a1 + 128) )
        v54 = a3 & 1;
      v196 = v54;
    }
    if ( (dl_debug_mask & 0x20) != 0 )
    {
      v184 = " (lazy)";
      if ( !v196 )
        v184 = (const char *)&unk_80C86D9;
      v185 = *(const char **)(a1 + 4);
      if ( !*v185 )
        v185 = (const char *)program_invocation_short_name;
      dl_debug_printf((int)"\nrelocation processing: %s%s\n", v185, v184);
    }
    if ( *(_DWORD *)(a1 + 120) )
    {
      v178 = *(unsigned __int16 *)(a1 + 344);
      v179 = *(_DWORD **)(a1 + 336);
      v194 = 0;
      if ( v179 < &v179[8 * v178] )
      {
        do
        {
          if ( *v179 == 1 && (v179[6] & 2) == 0 )
          {
            v180 = v179[2];
            v207 = -dl_pagesize;
            v181 = v180 & -dl_pagesize;
            v182 = (const char *)((-dl_pagesize & (v179[5] + v180 + dl_pagesize - 1)) - v181);
            v183 = *(_DWORD *)a1 + v181;
            v190 = v182;
            v189 = v183;
            if ( (mprotect(v183, (int)v182) & 0x80000000) != 0 )
            {
              v177 = "cannot make segment writable for relocation";
              goto LABEL_383;
            }
            v191 = (1934713408 >> (4 * (v179[6] & 7))) & 0xF;
            v178 = *(unsigned __int16 *)(a1 + 344);
            v192 = v194;
            v194 = &v189;
          }
          v179 += 8;
        }
        while ( (unsigned int)v179 < *(_DWORD *)(a1 + 336) + 32 * v178 );
      }
    }
    else
    {
      v194 = 0;
    }
    v198 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
    if ( (_BYTE)v196 && *(_DWORD *)(a1 + 124) )
    {
      v52 = *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4);
      v53 = *(_DWORD *)(v52 + 4);
      if ( v53 )
      {
        *(_DWORD *)(a1 + 528) = *(_DWORD *)a1 + v53;
        *(_DWORD *)(a1 + 532) = v52 + 12;
      }
      *(_DWORD *)(v52 + 4) = a1;
      if ( a4 )
      {
        *(_DWORD *)(v52 + 8) = dl_runtime_profile;
        if ( dl_profile && dl_name_match_p((const char *)dl_profile, a1) )
          dl_profile_map = a1;
      }
      else
      {
        *(_DWORD *)(v52 + 8) = dl_runtime_resolve;
      }
    }
    for ( i = 0; i < 0x20; i += 4 )
      *(unsigned int *)((char *)&v209 + i) = 0;
    v6 = *(_DWORD *)(a1 + 100);
    if ( v6 )
    {
      v7 = *(_DWORD *)(v6 + 4);
      v8 = *(_DWORD *)(*(_DWORD *)(a1 + 104) + 4);
      v9 = *(_DWORD *)(a1 + 188);
      v209 = v7;
      v210 = v8;
      if ( v9 )
      {
        v10 = *(_DWORD *)(v9 + 4);
        if ( v8 >> 3 <= v10 )
          v10 = v8 >> 3;
        v211 = v10;
      }
      v11 = v8 + v7;
    }
    else
    {
      v11 = 0;
      v8 = 0;
      v7 = 0;
    }
    v12 = *(_DWORD *)(a1 + 112);
    if ( v12 && *(_DWORD *)(v12 + 4) == 17 )
    {
      if ( v196 || *(_DWORD *)(*(_DWORD *)(a1 + 124) + 4) != v11 )
      {
        v213 = *(_DWORD *)(*(_DWORD *)(a1 + 124) + 4);
        v88 = *(_DWORD *)(*(_DWORD *)(a1 + 40) + 4);
        v215 = v196;
        v214 = v88;
      }
      else
      {
        v8 += *(_DWORD *)(*(_DWORD *)(a1 + 40) + 4);
        v210 = v8;
      }
    }
    v201 = &v212;
    v13 = *(_DWORD *)a1;
    v208 = &v219;
    v207 = a1;
    while ( 1 )
    {
      v14 = (_BYTE *)(v7 + v8);
      v206 = (unsigned int)v14;
      v15 = (_DWORD *)v7;
      if ( !*(_DWORD *)v201 )
        break;
      if ( v7 < (unsigned int)v14 )
      {
        while ( 1 )
        {
          v16 = v15[1];
          v17 = (_DWORD *)(v13 + *v15);
          switch ( (unsigned __int8)v16 )
          {
            case 7u:
              v18 = *(_DWORD *)(v207 + 528);
              if ( v18 )
                *v17 = v18 + 4 * ((_DWORD)v17 - *(_DWORD *)(v207 + 532));
              else
                *v17 += v13;
              break;
            case 0x29u:
              v150 = v16 >> 8;
              if ( v16 >> 8 )
              {
                if ( v17[1] )
                {
                  v152 = (int (*)(void))v207;
                  v203 = *(_DWORD *)(*(_DWORD *)(v207 + 56) + 4);
                  v153 = *(_DWORD *)(v207 + 228);
                  if ( v153 )
                  {
                    v154 = *(_WORD *)(*(_DWORD *)(v153 + 4) + 2 * v150);
                    v155 = v203 + 16 * v150;
                    LOWORD(v204) = v154;
                    v156 = *(void (**)(void))(v207 + 368);
                    v223 = v155;
                    k = v156;
                    if ( *(_BYTE *)(v155 + 12) >> 4 )
                    {
                      if ( v155 == *(_DWORD *)(v207 + 540) && *(_DWORD *)(v207 + 544) == 1 )
                      {
                        v155 = *(_DWORD *)(v207 + 552);
                        v152 = *(int (**)(void))(v207 + 548);
                        v223 = v155;
                      }
                      else
                      {
                        v157 = v207;
                        v158 = 16 * ((unsigned __int16)v204 & 0x7FFF);
                        v44 = (void (*)(void))((char *)k + v158) == 0;
                        v159 = (char *)k + v158;
                        *(_DWORD *)(v207 + 544) = 1;
                        *(_DWORD *)(v157 + 540) = v155;
                        if ( !v44 && !*((_DWORD *)v159 + 1) )
                          v159 = 0;
                        k = (void (*)(void))(*(_DWORD *)v155 + v198);
                        v160 = (int (*)(void))dl_lookup_symbol_x(a2, v159, 1, 1, 0);
                        v155 = v223;
                        v152 = v160;
                        v161 = v207;
                        *(_DWORD *)(v207 + 552) = v223;
                        *(_DWORD *)(v161 + 548) = v152;
                      }
                    }
                    k = 0;
                    if ( v152 )
                    {
                      k = *(void (**)(void))(v155 + 4);
                      k = (void (*)(void))((char *)k + *(_DWORD *)v152);
                    }
                    if ( v155 )
                    {
                      if ( (*(_BYTE *)(v155 + 12) & 0xF) != 10 )
                        goto LABEL_300;
                      if ( !*(_WORD *)(v155 + 14) )
                        goto LABEL_300;
                      if ( v195 )
                        goto LABEL_300;
                      v193 = v152;
                      k();
                      v152 = v193;
                      if ( v223 )
                        goto LABEL_300;
                    }
                  }
                  else
                  {
                    v152 = (int (*)(void))v207;
                    v162 = v203 + 16 * v150;
                    v223 = v162;
                    if ( *(_BYTE *)(v162 + 12) >> 4 )
                    {
                      if ( v162 == *(_DWORD *)(v207 + 540) && *(_DWORD *)(v207 + 544) == 1 )
                      {
                        v162 = *(_DWORD *)(v207 + 552);
                        v152 = *(int (**)(void))(v207 + 548);
                        v223 = v162;
                      }
                      else
                      {
                        v163 = v207;
                        *(_DWORD *)(v207 + 540) = v162;
                        *(_DWORD *)(v163 + 544) = 1;
                        v164 = (int (*)(void))dl_lookup_symbol_x(a2, 0, 1, 1, 0);
                        v162 = v223;
                        v152 = v164;
                        v165 = v207;
                        *(_DWORD *)(v207 + 552) = v223;
                        *(_DWORD *)(v165 + 548) = v152;
                      }
                    }
                    k = 0;
                    if ( v152 )
                    {
                      k = *(void (**)(void))(v162 + 4);
                      k = (void (*)(void))((char *)k + *(_DWORD *)v152);
                    }
                    if ( v162 )
                    {
                      if ( (*(_BYTE *)(v162 + 12) & 0xF) != 10
                        || !*(_WORD *)(v162 + 14)
                        || v195
                        || (v193 = v152, k(), v152 = v193, v223) )
                      {
LABEL_300:
                        k = (void (*)(void))*((_DWORD *)v152 + 144);
                        if ( (unsigned int)k <= 1 )
                        {
                          v193 = v152;
                          dl_allocate_static_tls((int)v152);
                          k = (void (*)(void))*((_DWORD *)v193 + 144);
                        }
                        v17[1] = *(_DWORD *)(v223 + 4) + v17[1] - (_DWORD)k;
                        *v17 = dl_tlsdesc_return;
                        break;
                      }
                    }
                  }
                  *v17 = dl_tlsdesc_undefweak;
                }
                else
                {
                  v17[1] = v15;
                  *v17 = dl_tlsdesc_resolve_rel;
                }
              }
              else
              {
                *v17 = dl_tlsdesc_resolve_abs_plus_addend;
              }
              break;
            case 0x2Au:
              v170 = (int (*)(void))(*(_DWORD *)v207 + *v17);
              if ( !v195 )
                v170 = (int (*)(void))v170();
              *v17 = v170;
              break;
            default:
              dl_reloc_bad_type(1, v16);
          }
          v15 += 2;
          if ( v206 <= (unsigned int)v15 )
            goto LABEL_24;
        }
      }
LABEL_25:
      v201 += 16;
      if ( v201 == v208 )
      {
        v19 = v207;
        for ( j = 0; j < 0x20; j += 4 )
          *(unsigned int *)((char *)&v216 + j) = 0;
        v21 = *(_DWORD *)(v19 + 60);
        if ( v21 )
        {
          v22 = *(_DWORD *)(v21 + 4);
          v23 = *(_DWORD *)(v19 + 64);
          v216 = v22;
          v24 = *(_DWORD *)(v23 + 4);
          v25 = *(_DWORD *)(v19 + 192);
          v217 = v24;
          v207 = v25;
          if ( v25 )
          {
            v26 = v24 / 0xC;
            if ( v24 / 0xC > *(_DWORD *)(v207 + 4) )
              v26 = *(_DWORD *)(v207 + 4);
            v218 = v26;
          }
          v27 = v24 + v22;
        }
        else
        {
          v27 = 0;
          v24 = 0;
          v22 = 0;
        }
        v28 = *(_DWORD *)(v19 + 112);
        if ( v28 && *(_DWORD *)(v28 + 4) == 7 )
        {
          if ( v196 || *(_DWORD *)(*(_DWORD *)(v19 + 124) + 4) != v27 )
          {
            v220 = *(_DWORD *)(*(_DWORD *)(v19 + 124) + 4);
            v148 = *(_DWORD *)(*(_DWORD *)(v19 + 40) + 4);
            v222 = v196;
            v221 = v148;
          }
          else
          {
            v24 += *(_DWORD *)(*(_DWORD *)(v19 + 40) + 4);
            v217 = v24;
          }
        }
        v199 = 0;
        for ( k = (void (*)(void))v13; ; k = *(void (**)(void))v19 )
        {
          v29 = *(_DWORD *)(v19 + 56);
          v203 = v22 + v24;
          v30 = (int *)v22;
          v201 = *(char **)(v29 + 4);
          v31 = (int *)(v22 + 12 * *(unsigned int *)((char *)&v218 + v199));
          if ( v19 && (k || !*(_DWORD *)(v19 + 284)) )
          {
            v121 = k;
            if ( v22 < (unsigned int)v31 )
            {
              do
              {
                v122 = v30[2];
                v123 = *v30;
                v30 += 3;
                *(_DWORD *)((char *)v121 + v123) = (char *)v121 + v122;
              }
              while ( v31 > v30 );
            }
          }
          v32 = *(_DWORD *)(v19 + 228);
          if ( v32 )
          {
            v200 = *(_DWORD *)(v32 + 4);
            if ( v203 <= (unsigned int)v31 )
              goto LABEL_67;
            while ( 2 )
            {
              v33 = (unsigned __int8)v31[1];
              v34 = (unsigned int)v31[1] >> 8;
              v35 = *(unsigned __int16 *)(v200 + 2 * v34);
              v36 = (char *)k + *v31;
              v37 = (int)&v201[16 * v34];
              v207 = v33;
              v206 = (unsigned int)v36;
              v38 = *(int (__usercall ***)@<eax>(int@<eax>))(v19 + 368);
              v223 = v37;
              v204 = v38;
              if ( v33 == 8 )
              {
                *(_DWORD *)v206 = *(_DWORD *)v19 + v31[2];
              }
              else if ( v207 )
              {
                v39 = *(_BYTE *)(v37 + 12);
                v40 = v37;
                v202 = v19;
                if ( v39 >> 4 )
                {
                  v41 = v207 == 35;
                  v42 = v207 == 7;
                  if ( v37 != *(_DWORD *)(v19 + 540) )
                  {
                    v43 = v42 || v41;
                    goto LABEL_47;
                  }
                  v43 = v42 || v41;
                  v202 = 1;
                  if ( !v43 )
                    v202 = v207 == 37 || v207 == 36 || v207 == 14 || v207 == 41;
                  if ( (v202 | (2 * (v207 == 5))) == *(_DWORD *)(v19 + 544) )
                  {
                    v40 = *(_DWORD *)(v19 + 552);
                    v169 = *(_DWORD *)(v19 + 548);
                    v223 = v40;
                    v202 = v169;
                  }
                  else
                  {
LABEL_47:
                    v202 = 1;
                    if ( !v43 )
                      v202 = v207 == 37 || v207 == 36 || v207 == 14 || v207 == 41;
                    v44 = v207 == 5;
                    *(_DWORD *)(v19 + 540) = v37;
                    v45 = 4 * (v35 & 0x7FFF);
                    v46 = v202 | (2 * v44);
                    v44 = &v204[v45] == 0;
                    v47 = &v204[v45];
                    *(_DWORD *)(v19 + 544) = v46;
                    if ( !v44 && !v47[1] )
                      v47 = 0;
                    v204 = (int (__usercall **)@<eax>(int@<eax>))(*(_DWORD *)v37 + v198);
                    v48 = dl_lookup_symbol_x(a2, v47, v46, 1, 0);
                    v40 = v223;
                    *(_DWORD *)(v19 + 552) = v223;
                    v202 = v48;
                    *(_DWORD *)(v19 + 548) = v48;
                  }
                }
                v49 = 0;
                if ( v40 )
                {
                  v35 = v202;
                  v49 = (int (*)(void))(*(_DWORD *)v202 + *(_DWORD *)(v40 + 4));
                  if ( *(_WORD *)(v40 + 14) )
                  {
                    if ( (*(_BYTE *)(v40 + 12) & 0xF) == 10 && !v195 )
                      v49 = (int (*)(void))v49();
                  }
                }
                switch ( *((_BYTE *)v31 + 4) )
                {
                  case 1:
                  case 6:
                  case 7:
                    goto LABEL_203;
                  case 2:
                    v49 = (int (*)(void))((char *)v49 - v206);
LABEL_203:
                    *(_DWORD *)v206 = (char *)v49 + v31[2];
                    break;
                  case 5:
                    if ( v223 )
                    {
                      v50 = *(_DWORD *)(v223 + 8);
                      v51 = *(_DWORD *)(v37 + 8);
                      if ( v50 > v51 || v50 < v51 && dl_verbose )
                      {
                        v207 = *(_DWORD *)v37 + *(_DWORD *)(*(_DWORD *)(v19 + 52) + 4);
                        v188 = (const char *)program_invocation_short_name;
                        v193 = v49;
                        v190 = "%s: Symbol `%s' has different size in shared object, consider re-linking\n";
                        v189 = 2;
                        if ( !program_invocation_short_name )
                          v188 = "<program name unknown>";
                        dl_dprintf(v189, (int)v190, v188, v207);
                        v51 = *(_DWORD *)(v37 + 8);
                        v49 = v193;
                        v50 = *(_DWORD *)(v223 + 8);
                      }
                      if ( v50 > v51 )
                        v50 = v51;
                      memcpy((_BYTE *)v206, v49, v50);
                    }
                    break;
                  case 0xE:
                    v119 = v223;
                    if ( v223 )
                    {
                      v120 = *(_DWORD *)(v202 + 576);
                      if ( v120 <= 1 )
                      {
                        dl_allocate_static_tls(v202);
                        v119 = v223;
                        v120 = *(_DWORD *)(v202 + 576);
                      }
                      *(_DWORD *)v206 = *(_DWORD *)(v119 + 4) + v31[2] - v120;
                    }
                    break;
                  case 0x23:
                    if ( v202 )
                      *(_DWORD *)v206 = *(_DWORD *)(v202 + 580);
                    break;
                  case 0x24:
                    v118 = 0;
                    if ( v223 )
                      v118 = *(_DWORD *)(v223 + 4);
                    *(_DWORD *)v206 = v31[2] + v118;
                    break;
                  case 0x25:
                    v116 = v223;
                    if ( v223 )
                    {
                      v117 = *(_DWORD *)(v202 + 576);
                      if ( v117 <= 1 )
                      {
                        dl_allocate_static_tls(v202);
                        v116 = v223;
                        v117 = *(_DWORD *)(v202 + 576);
                      }
                      *(_DWORD *)v206 = v31[2] + v117 - *(_DWORD *)(v116 + 4);
                    }
                    break;
                  case 0x29:
                    v113 = v223;
                    if ( v223 )
                    {
                      v114 = *(_DWORD *)(v202 + 576);
                      if ( v114 <= 1 )
                      {
                        dl_allocate_static_tls(v202);
                        v113 = v223;
                        v114 = *(_DWORD *)(v202 + 576);
                      }
                      v115 = (_DWORD *)v206;
                      *(_DWORD *)(v206 + 4) = *(_DWORD *)(v113 + 4) + v31[2] - v114;
                      *v115 = dl_tlsdesc_return;
                    }
                    else
                    {
                      v149 = (_DWORD *)v206;
                      *(_DWORD *)(v206 + 4) = v31[2];
                      *v149 = dl_tlsdesc_undefweak;
                    }
                    break;
                  case 0x2A:
                    v112 = ((int (__fastcall *)(int))(*(_DWORD *)v19 + v31[2]))(v35);
                    *(_DWORD *)v206 = v112;
                    break;
                  default:
                    dl_reloc_bad_type(0, v207);
                }
              }
              v31 += 3;
              if ( v203 <= (unsigned int)v31 )
                goto LABEL_67;
              continue;
            }
          }
          if ( v203 <= (unsigned int)v31 )
            goto LABEL_67;
          v207 = v19;
          do
          {
            v124 = v31[1];
            v206 = (unsigned int)k + *v31;
            v125 = (int)&v201[16 * (v124 >> 8)];
            v223 = v125;
            if ( (unsigned __int8)v124 == 8 )
            {
              *(_DWORD *)v206 = *(_DWORD *)v207 + v31[2];
              goto LABEL_252;
            }
            if ( !(_BYTE)v124 )
              goto LABEL_252;
            v126 = (int)&v201[16 * (v124 >> 8)];
            v127 = (int (*)(void))v207;
            if ( *(_BYTE *)(v125 + 12) >> 4 )
            {
              if ( v125 != *(_DWORD *)(v207 + 540) )
              {
                v128 = (unsigned __int8)v124 == 35 || (unsigned __int8)v124 == 7;
LABEL_236:
                v129 = 1;
                if ( !v128 )
                  v129 = (unsigned __int8)v124 == 37
                      || (unsigned __int8)v124 == 36
                      || (unsigned __int8)v124 == 14
                      || (unsigned __int8)v124 == 41;
                v130 = v207;
                v131 = v129 | (2 * ((unsigned __int8)v124 == 5));
                v132 = v198;
                *(_DWORD *)(v207 + 544) = v131;
                v133 = (int (__usercall **)@<eax>(int@<eax>))(*(_DWORD *)v125 + v132);
                *(_DWORD *)(v130 + 540) = v125;
                v204 = v133;
                v134 = (int (*)(void))dl_lookup_symbol_x(a2, 0, v131, 1, 0);
                v126 = v223;
                v127 = v134;
                v135 = v207;
                *(_DWORD *)(v207 + 552) = v223;
                *(_DWORD *)(v135 + 548) = v127;
                goto LABEL_241;
              }
              v168 = 1;
              v128 = (unsigned __int8)v124 == 7 || (unsigned __int8)v124 == 35;
              if ( !v128 )
                v168 = (unsigned __int8)v124 == 37
                    || (unsigned __int8)v124 == 36
                    || (unsigned __int8)v124 == 14
                    || (unsigned __int8)v124 == 41;
              if ( (v168 | (2 * ((unsigned __int8)v124 == 5))) != *(_DWORD *)(v207 + 544) )
                goto LABEL_236;
              v126 = *(_DWORD *)(v207 + 552);
              v127 = *(int (**)(void))(v207 + 548);
              v223 = v126;
            }
LABEL_241:
            v136 = 0;
            if ( v126 )
            {
              v136 = (int (*)(void))(*(_DWORD *)v127 + *(_DWORD *)(v126 + 4));
              if ( *(_WORD *)(v126 + 14) )
              {
                if ( (*(_BYTE *)(v126 + 12) & 0xF) == 10 && !v195 )
                {
                  v193 = v127;
                  v136 = (int (*)(void))v136();
                  v127 = v193;
                }
              }
            }
            switch ( *((_BYTE *)v31 + 4) )
            {
              case 1:
              case 6:
              case 7:
                *(_DWORD *)v206 = (char *)v136 + v31[2];
                break;
              case 2:
                *(_DWORD *)v206 = (char *)v136 + v31[2] - v206;
                break;
              case 5:
                if ( v223 )
                {
                  v137 = *(_DWORD *)(v223 + 8);
                  v138 = *(_DWORD *)(v125 + 8);
                  if ( v137 > v138 || v137 < v138 && dl_verbose )
                  {
                    v167 = (const char *)program_invocation_short_name;
                    v192 = (int *)(*(_DWORD *)v125 + *(_DWORD *)(*(_DWORD *)(v207 + 52) + 4));
                    v193 = v136;
                    v190 = "%s: Symbol `%s' has different size in shared object, consider re-linking\n";
                    if ( !program_invocation_short_name )
                      v167 = "<program name unknown>";
                    dl_dprintf(2, (int)v190, v167, v192);
                    v138 = *(_DWORD *)(v125 + 8);
                    v136 = v193;
                    v137 = *(_DWORD *)(v223 + 8);
                  }
                  if ( v137 > v138 )
                    v137 = v138;
                  memcpy((_BYTE *)v206, v136, v137);
                }
                break;
              case 0xE:
                v146 = v223;
                if ( v223 )
                {
                  v147 = *((_DWORD *)v127 + 144);
                  if ( v147 <= 1 )
                  {
                    v193 = v127;
                    dl_allocate_static_tls((int)v127);
                    v146 = v223;
                    v147 = *((_DWORD *)v193 + 144);
                  }
                  *(_DWORD *)v206 = *(_DWORD *)(v146 + 4) + v31[2] - v147;
                }
                break;
              case 0x23:
                if ( v127 )
                  *(_DWORD *)v206 = *((_DWORD *)v127 + 145);
                break;
              case 0x24:
                v145 = 0;
                if ( v223 )
                  v145 = *(_DWORD *)(v223 + 4);
                *(_DWORD *)v206 = v31[2] + v145;
                break;
              case 0x25:
                v143 = v223;
                if ( v223 )
                {
                  v144 = *((_DWORD *)v127 + 144);
                  if ( v144 <= 1 )
                  {
                    v193 = v127;
                    dl_allocate_static_tls((int)v127);
                    v143 = v223;
                    v144 = *((_DWORD *)v193 + 144);
                  }
                  *(_DWORD *)v206 = v31[2] + v144 - *(_DWORD *)(v143 + 4);
                }
                break;
              case 0x29:
                v140 = v223;
                if ( v223 )
                {
                  v141 = *((_DWORD *)v127 + 144);
                  if ( v141 <= 1 )
                  {
                    v193 = v127;
                    dl_allocate_static_tls((int)v127);
                    v140 = v223;
                    v141 = *((_DWORD *)v193 + 144);
                  }
                  v142 = (_DWORD *)v206;
                  *(_DWORD *)(v206 + 4) = *(_DWORD *)(v140 + 4) + v31[2] - v141;
                  *v142 = dl_tlsdesc_return;
                }
                else
                {
                  v151 = (_DWORD *)v206;
                  *(_DWORD *)(v206 + 4) = v31[2];
                  *v151 = dl_tlsdesc_undefweak;
                }
                break;
              case 0x2A:
                v139 = ((int (__fastcall *)(int (*)(void)))(*(_DWORD *)v207 + v31[2]))(v127);
                *(_DWORD *)v206 = v139;
                break;
              default:
                dl_reloc_bad_type(0, v124);
            }
LABEL_252:
            v31 += 3;
          }
          while ( v203 > (unsigned int)v31 );
          v19 = v207;
LABEL_67:
          v199 += 16;
          if ( v199 == 32 )
          {
            if ( !a4 )
              goto LABEL_69;
            v171 = *(_DWORD *)(v19 + 40);
            if ( !v171 )
            {
              v173 = "%s: no PLTREL found in object %s\n";
LABEL_357:
              v174 = (const char *)program_invocation_short_name;
              v192 = *(int **)(v19 + 4);
              v190 = v173;
              v189 = 2;
              if ( !program_invocation_short_name )
                v174 = "<program name unknown>";
              dl_dprintf(v189, (int)v190, v174, v192);
              exit(127);
            }
            calloc(20, *(_DWORD *)(v171 + 4));
            *(_DWORD *)(v19 + 416) = v172;
            if ( !v172 )
            {
              v173 = "%s: out of memory to store relocation results for %s\n";
              goto LABEL_357;
            }
LABEL_69:
            *(_BYTE *)(v19 + 404) |= 4u;
            if ( !v194 )
            {
LABEL_70:
              result = *(_DWORD *)(v19 + 588);
              if ( result )
                return dl_protect_relro((_DWORD *)v19);
              return result;
            }
            v176 = v194;
            while ( 1 )
            {
              v191 = v176[2];
              if ( (mprotect(*v176, v176[1]) & 0x80000000) != 0 )
                break;
              v176 = (int *)v176[3];
              if ( !v176 )
                goto LABEL_70;
            }
            v177 = "cannot restore segment prot after reloc";
LABEL_383:
            dl_signal_error(v177);
          }
          v24 = *(unsigned int *)((char *)&v217 + v199);
          v22 = *(unsigned int *)((char *)&v216 + v199);
        }
      }
      v8 = *((_DWORD *)v201 - 2);
      v7 = *((_DWORD *)v201 - 3);
    }
    v55 = (_DWORD *)(v7 + 8 * *((_DWORD *)v201 - 1));
    v200 = *(_DWORD *)(*(_DWORD *)(v207 + 56) + 4);
    if ( v207 && v13 && v7 < (unsigned int)v55 )
    {
      if ( *(_BYTE *)(v7 + 4) != 8 )
LABEL_304:
        _assert_fail("((reloc->r_info) & 0xff) == 8", "../sysdeps/i386/dl-machine.h", 633, "elf_machine_rel_relative");
      v56 = (_DWORD *)(v13 + *(_DWORD *)v7);
      while ( 1 )
      {
        v7 += 8;
        *v56 += v13;
        if ( (unsigned int)v55 <= v7 )
          break;
        v56 = (_DWORD *)(v13 + *(_DWORD *)v7);
        if ( *(_BYTE *)(v7 + 4) != 8 )
          goto LABEL_304;
      }
    }
    v57 = *(_DWORD *)(v207 + 228);
    if ( v57 )
    {
      v199 = *(_DWORD *)(v57 + 4);
      if ( v206 <= (unsigned int)v55 )
      {
LABEL_24:
        v13 = *(_DWORD *)v207;
        goto LABEL_25;
      }
      v197 = v13;
      while ( 1 )
      {
        v58 = v55[1] >> 8;
        v59 = *(_WORD *)(v199 + 2 * v58);
        v60 = *(_DWORD *)(v207 + 368);
        v61 = v200 + 16 * v58;
        k = (void (*)(void))(unsigned __int8)v55[1];
        LOWORD(v202) = v59;
        v62 = (int (__usercall **)@<eax>(int@<eax>))(*v55 + v197);
        v203 = v60;
        v223 = v61;
        v204 = v62;
        if ( k == (void (*)(void))8 )
        {
          *v62 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v62 + *(_DWORD *)v207);
LABEL_116:
          v55 += 2;
          if ( v206 <= (unsigned int)v55 )
            goto LABEL_24;
          continue;
        }
        if ( !k )
          goto LABEL_116;
        v63 = v61;
        v64 = (_DWORD *)v207;
        if ( *(_BYTE *)(v61 + 12) >> 4 )
        {
          v65 = k == (void (*)(void))35;
          v66 = k == (void (*)(void))7;
          if ( v61 != *(_DWORD *)(v207 + 540) )
          {
            v67 = v66 || v65;
LABEL_96:
            v68 = 1;
            if ( !v67 )
              v68 = k == (void (*)(void))37
                 || k == (void (*)(void))36
                 || k == (void (*)(void))14
                 || k == (void (*)(void))41;
            v69 = v68 | (2 * (k == (void (*)(void))5));
            v70 = v207;
            v71 = 16 * (v202 & 0x7FFF);
            v44 = v203 + v71 == 0;
            v72 = v203 + v71;
            *(_DWORD *)(v207 + 544) = v69;
            *(_DWORD *)(v70 + 540) = v61;
            if ( !v44 && !*(_DWORD *)(v72 + 4) )
              v72 = 0;
            v73 = (_DWORD *)dl_lookup_symbol_x(a2, v72, v69, 1, 0);
            v63 = v223;
            v64 = v73;
            v74 = v207;
            *(_DWORD *)(v207 + 552) = v223;
            *(_DWORD *)(v74 + 548) = v64;
            goto LABEL_104;
          }
          v67 = v66 || v65;
          v166 = 1;
          if ( !v67 )
            v166 = k == (void (*)(void))37
                || k == (void (*)(void))36
                || k == (void (*)(void))14
                || k == (void (*)(void))41;
          if ( (v166 | (2 * (k == (void (*)(void))5))) != *(_DWORD *)(v207 + 544) )
            goto LABEL_96;
          v63 = *(_DWORD *)(v207 + 552);
          v64 = *(_DWORD **)(v207 + 548);
          v223 = v63;
        }
LABEL_104:
        v75 = 0;
        if ( v64 )
          v75 = *v64 + *(_DWORD *)(v63 + 4);
        if ( v63 && (*(_BYTE *)(v63 + 12) & 0xF) == 10 && *(_WORD *)(v63 + 14) && !v195 )
          v75 = ((int (*)(void))v75)();
        switch ( (unsigned int)k )
        {
          case 1u:
            v55 += 2;
            *v204 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v204 + v75);
            if ( v206 <= (unsigned int)v55 )
              goto LABEL_24;
            continue;
          case 2u:
            v55 += 2;
            *v204 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v204 + v75 - (_DWORD)v204);
            if ( v206 <= (unsigned int)v55 )
              goto LABEL_24;
            continue;
          case 5u:
            if ( v223 )
            {
              v76 = *(_DWORD *)(v223 + 8);
              v77 = *(_DWORD *)(v61 + 8);
              if ( v76 > v77 || v76 < v77 && dl_verbose )
              {
                v186 = (const char *)program_invocation_short_name;
                v192 = (int *)(*(_DWORD *)v61 + *(_DWORD *)(*(_DWORD *)(v207 + 52) + 4));
                v193 = (int (*)(void))v75;
                v190 = "%s: Symbol `%s' has different size in shared object, consider re-linking\n";
                if ( !program_invocation_short_name )
                  v186 = "<program name unknown>";
                dl_dprintf(2, (int)v190, v186, v192);
                v77 = *(_DWORD *)(v61 + 8);
                v75 = (int)v193;
                v76 = *(_DWORD *)(v223 + 8);
              }
              if ( v76 > v77 )
                v76 = v77;
              memcpy(v204, (_BYTE *)v75, v76);
            }
            goto LABEL_116;
          case 6u:
          case 7u:
            goto LABEL_121;
          case 0xEu:
            v86 = v223;
            if ( !v223 )
              goto LABEL_116;
            v87 = v64[144];
            if ( v87 <= 1 )
            {
              dl_allocate_static_tls((int)v64);
              v86 = v223;
              v87 = v64[144];
            }
            v55 += 2;
            v78 = v206 <= (unsigned int)v55;
            *v204 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v204 + *(_DWORD *)(v86 + 4) - v87);
            if ( v78 )
              goto LABEL_24;
            continue;
          case 0x23u:
            if ( !v64 )
              goto LABEL_116;
            v55 += 2;
            v78 = v206 <= (unsigned int)v55;
            *v204 = (int (__usercall *)@<eax>(int@<eax>))v64[145];
            if ( v78 )
              goto LABEL_24;
            continue;
          case 0x24u:
            if ( !v223 )
              goto LABEL_116;
            v75 = *(_DWORD *)(v223 + 4);
LABEL_121:
            v55 += 2;
            v78 = v206 <= (unsigned int)v55;
            *v204 = (int (__usercall *)@<eax>(int@<eax>))v75;
            if ( v78 )
              goto LABEL_24;
            continue;
          case 0x25u:
            v84 = v223;
            if ( !v223 )
              goto LABEL_116;
            v85 = v64[144];
            if ( v85 <= 1 )
            {
              dl_allocate_static_tls((int)v64);
              v85 = v64[144];
              v84 = v223;
            }
            v55 += 2;
            v78 = v206 <= (unsigned int)v55;
            *v204 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v204 + v85 - *(_DWORD *)(v84 + 4));
            if ( v78 )
              goto LABEL_24;
            continue;
          case 0x29u:
            v81 = v223;
            if ( !v223 )
            {
              *v204 = (int (__usercall *)@<eax>(int@<eax>))dl_tlsdesc_undefweak;
              goto LABEL_116;
            }
            v82 = v64[144];
            if ( v82 <= 1 )
            {
              dl_allocate_static_tls((int)v64);
              v81 = v223;
              v82 = v64[144];
            }
            v83 = v204;
            v55 += 2;
            v78 = v206 <= (unsigned int)v55;
            v204[1] = (int (__usercall *)@<eax>(int@<eax>))((char *)v204[1] + *(_DWORD *)(v81 + 4) - v82);
            *v83 = dl_tlsdesc_return;
            if ( v78 )
              goto LABEL_24;
            break;
          case 0x2Au:
            v79 = (int *)v204;
            v55 += 2;
            v80 = ((int (*)(void))((char *)*v204 + *(_DWORD *)v207))();
            v78 = v206 <= (unsigned int)v55;
            *v79 = v80;
            if ( v78 )
              goto LABEL_24;
            continue;
          default:
            goto LABEL_109;
        }
      }
    }
    if ( v206 <= (unsigned int)v55 )
    {
      v13 = *(_DWORD *)v207;
      goto LABEL_25;
    }
    v203 = v13;
    while ( 1 )
    {
      v89 = v55[1];
      v204 = (int (__usercall **)@<eax>(int@<eax>))(*v55 + v203);
      v90 = v200 + 16 * (v89 >> 8);
      k = (void (*)(void))(unsigned __int8)v89;
      v223 = v90;
      if ( (unsigned __int8)v89 == 8 )
      {
        *v204 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v204 + *(_DWORD *)v207);
      }
      else if ( k )
      {
        v91 = v200 + 16 * (v89 >> 8);
        v92 = (_DWORD *)v207;
        if ( *(_BYTE *)(v90 + 12) >> 4 )
        {
          v93 = k == (void (*)(void))35;
          v94 = k == (void (*)(void))7;
          if ( v90 != *(_DWORD *)(v207 + 540) )
          {
            v95 = v94 || v93;
            goto LABEL_161;
          }
          v95 = v94 || v93;
          v187 = 1;
          if ( !v95 )
            v187 = k == (void (*)(void))37
                || k == (void (*)(void))36
                || k == (void (*)(void))14
                || k == (void (*)(void))41;
          if ( (v187 | (2 * (k == (void (*)(void))5))) == *(_DWORD *)(v207 + 544) )
          {
            v91 = *(_DWORD *)(v207 + 552);
            v92 = *(_DWORD **)(v207 + 548);
            v223 = v91;
          }
          else
          {
LABEL_161:
            v96 = 1;
            if ( !v95 )
              v96 = k == (void (*)(void))37
                 || k == (void (*)(void))36
                 || k == (void (*)(void))14
                 || k == (void (*)(void))41;
            v97 = v96 | (2 * (k == (void (*)(void))5));
            v98 = v207;
            *(_DWORD *)(v207 + 544) = v97;
            *(_DWORD *)(v98 + 540) = v90;
            v99 = (_DWORD *)dl_lookup_symbol_x(a2, 0, v97, 1, 0);
            v91 = v223;
            v92 = v99;
            v100 = v207;
            *(_DWORD *)(v207 + 552) = v223;
            *(_DWORD *)(v100 + 548) = v92;
          }
        }
        v101 = 0;
        if ( v92 )
          v101 = *v92 + *(_DWORD *)(v91 + 4);
        if ( v91 && (*(_BYTE *)(v91 + 12) & 0xF) == 10 && *(_WORD *)(v91 + 14) && !v195 )
          v101 = ((int (*)(void))v101)();
        switch ( (unsigned int)k )
        {
          case 1u:
            *v204 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v204 + v101);
            break;
          case 2u:
            *v204 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v204 + v101 - (_DWORD)v204);
            break;
          case 5u:
            if ( v223 )
            {
              v110 = *(_DWORD *)(v223 + 8);
              v111 = *(_DWORD *)(v90 + 8);
              if ( v110 > v111 || v110 < v111 && dl_verbose )
              {
                v175 = (const char *)program_invocation_short_name;
                v192 = (int *)(*(_DWORD *)v90 + *(_DWORD *)(*(_DWORD *)(v207 + 52) + 4));
                v193 = (int (*)(void))v101;
                v190 = "%s: Symbol `%s' has different size in shared object, consider re-linking\n";
                if ( !program_invocation_short_name )
                  v175 = "<program name unknown>";
                dl_dprintf(2, (int)v190, v175, v192);
                v111 = *(_DWORD *)(v90 + 8);
                v101 = (int)v193;
                v110 = *(_DWORD *)(v223 + 8);
              }
              if ( v110 > v111 )
                v110 = v111;
              memcpy(v204, (_BYTE *)v101, v110);
            }
            break;
          case 6u:
          case 7u:
            goto LABEL_174;
          case 0xEu:
            v108 = v223;
            if ( v223 )
            {
              v109 = v92[144];
              if ( v109 <= 1 )
              {
                dl_allocate_static_tls((int)v92);
                v108 = v223;
                v109 = v92[144];
              }
              *v204 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v204 + *(_DWORD *)(v108 + 4) - v109);
            }
            break;
          case 0x23u:
            if ( v92 )
              *v204 = (int (__usercall *)@<eax>(int@<eax>))v92[145];
            break;
          case 0x24u:
            if ( !v223 )
              break;
            v101 = *(_DWORD *)(v223 + 4);
LABEL_174:
            *v204 = (int (__usercall *)@<eax>(int@<eax>))v101;
            break;
          case 0x25u:
            v106 = v223;
            if ( v223 )
            {
              v107 = v92[144];
              if ( v107 <= 1 )
              {
                dl_allocate_static_tls((int)v92);
                v107 = v92[144];
                v106 = v223;
              }
              *v204 = (int (__usercall *)@<eax>(int@<eax>))((char *)*v204 + v107 - *(_DWORD *)(v106 + 4));
            }
            break;
          case 0x29u:
            v103 = v223;
            if ( v223 )
            {
              v104 = v92[144];
              if ( v104 <= 1 )
              {
                dl_allocate_static_tls((int)v92);
                v103 = v223;
                v104 = v92[144];
              }
              v105 = v204;
              v204[1] = (int (__usercall *)@<eax>(int@<eax>))((char *)v204[1] + *(_DWORD *)(v103 + 4) - v104);
              *v105 = dl_tlsdesc_return;
            }
            else
            {
              *v204 = (int (__usercall *)@<eax>(int@<eax>))dl_tlsdesc_undefweak;
            }
            break;
          case 0x2Au:
            v102 = v204;
            *v102 = (int (__usercall *)@<eax>(int@<eax>))((int (*)(void))((char *)*v204 + *(_DWORD *)v207))();
            break;
          default:
LABEL_109:
            dl_reloc_bad_type(0, (unsigned __int8)k);
        }
      }
      v55 += 2;
      if ( v206 <= (unsigned int)v55 )
        goto LABEL_24;
    }
  }
  return result;
}
// 808D3F4: variable 'v35' is possibly undefined
// 808DDB4: variable 'v172' is possibly undefined
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808B7D0: using guessed type _DWORD __stdcall dl_lookup_symbol_x(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80EF5B8: using guessed type int dl_pagesize;
// 80F1190: using guessed type int dl_debug_mask;
// 80F11A4: using guessed type int dl_profile;
// 80F11DC: using guessed type int dl_verbose;
// 80F11E4: using guessed type int dl_profile_map;

//----- (0808E2C0) --------------------------------------------------------
void __usercall __noreturn dl_signal_error(
        int a1@<eax>,
        _BYTE *a2@<edx>,
        const char *a3@<ecx>,
        long double a4@<st0>,
        char *a5)
{
  char *v7; // edi
  int *v8; // eax
  const char *v9; // ecx
  int v10; // ebp
  _BYTE *v11; // eax
  _WORD *v12; // eax
  _BYTE *v13; // eax
  char *v14; // eax
  const char *v15; // ebx
  const char *v16; // edx
  unsigned int v18; // [esp+38h] [ebp-424h]
  unsigned int v19; // [esp+3Ch] [ebp-420h]
  const char *v20; // [esp+3Ch] [ebp-420h]
  char v21[1052]; // [esp+40h] [ebp-41Ch] BYREF

  v7 = a5;
  if ( !a5 )
    v7 = "DYNAMIC LINKER BUG!!!";
  v8 = (int *)dl_error_catch_tsd();
  v9 = a3;
  v10 = *v8;
  if ( !a2 )
    a2 = &unk_80C86D9;
  if ( v10 )
  {
    v19 = strlen(a2) + 1;
    v18 = strlen(v7) + 1;
    v11 = (_BYTE *)malloc(v18 + v19);
    *(_DWORD *)(v10 + 4) = v11;
    if ( v11 )
    {
      v12 = mempcpy(v11, v7, v18);
      v13 = memcpy(v12, a2, v19);
      *(_BYTE *)(v10 + 8) = 1;
      *(_DWORD *)v10 = v13;
    }
    else
    {
      *(_DWORD *)v10 = &unk_80C86D9;
      *(_DWORD *)(v10 + 4) = "out of memory";
      *(_BYTE *)(v10 + 8) = 0;
    }
    if ( !a1 )
      a1 = -1;
    _longjmp((struct __jmp_buf_tag *)(v10 + 12), a1);
  }
  if ( a1 )
  {
    v14 = strerror_r(a4, a1, v21, 0x400u);
    v9 = a3;
    v20 = "undefined symbol: " + 16;
  }
  else
  {
    v14 = (char *)&unk_80C86D9;
    v20 = (const char *)&unk_80C86D9;
  }
  v15 = "undefined symbol: " + 16;
  if ( !*a2 )
    v15 = (const char *)&unk_80C86D9;
  if ( !v9 )
    v9 = "error while loading shared libraries";
  v16 = (const char *)program_invocation_short_name;
  if ( !program_invocation_short_name )
    v16 = "<program name unknown>";
  dl_dprintf(2, (int)"%s: %s: %s%s%s%s%s\n", v16, v9, a2, v15, v7, v20, v14);
  exit(127);
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80EFA30: using guessed type int (*dl_error_catch_tsd)(void);
// 808E2C0: using guessed type char var_41C[1052];

//----- (0808E440) --------------------------------------------------------
int __userpurge dl_signal_cerror@<eax>(
        int a1@<eax>,
        char *a2@<edx>,
        const char *a3@<ecx>,
        long double a4@<st0>,
        char *a5)
{
  const char *v6; // ebx
  const char *v7; // [esp+24h] [ebp-18h]
  char *v8; // [esp+28h] [ebp-14h]
  int v9; // [esp+2Ch] [ebp-10h]

  if ( (dl_debug_mask & 0xFFFFF77F) != 0 )
  {
    v6 = "continued";
    if ( !receiver )
      v6 = "fatal";
    v9 = a1;
    v8 = a2;
    v7 = a3;
    dl_debug_printf((int)"%s: error: %s: %s (%s)\n", a2, a3, a5, v6);
    a3 = v7;
    a2 = v8;
    a1 = v9;
  }
  if ( !receiver )
    dl_signal_error(a1, a2, a3, a4, a5);
  return receiver(a1, a2, a5);
}
// 80F0DF0: using guessed type int (__cdecl *receiver)(_DWORD, _DWORD, _DWORD);
// 80F1190: using guessed type int dl_debug_mask;

//----- (0808E4E0) --------------------------------------------------------
int __userpurge dl_catch_error@<eax>(
        _DWORD *a1@<eax>,
        _DWORD *a2@<edx>,
        _BYTE *a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>,
        void (__cdecl *a8)(int),
        int a9)
{
  int v9; // ebx
  int *v11; // [esp+10h] [ebp-CCh]
  int v15; // [esp+24h] [ebp-B8h] BYREF
  int v16; // [esp+28h] [ebp-B4h]
  char v17; // [esp+2Ch] [ebp-B0h]
  char v18[156]; // [esp+30h] [ebp-ACh] BYREF
  int v19; // [esp+CCh] [ebp-10h]

  v16 = 0;
  v11 = (int *)dl_error_catch_tsd();
  v19 = *v11;
  v9 = _sigsetjmp(a4, a5, a6, a7, (int)v18, 0);
  if ( v9 )
  {
    *v11 = v19;
    *a1 = v15;
    *a2 = v16;
    *a3 = v17;
    if ( v9 == -1 )
      return 0;
  }
  else
  {
    *v11 = (int)&v15;
    a8(a9);
    *v11 = v19;
    *a1 = 0;
    *a2 = 0;
    *a3 = 0;
  }
  return v9;
}
// 80EFA30: using guessed type int (*dl_error_catch_tsd)(void);
// 808E4E0: using guessed type char var_AC[156];

//----- (0808E5B0) --------------------------------------------------------
int (__cdecl *__usercall dl_receive_error@<eax>(
        int (__cdecl *a1)(_DWORD, _DWORD, _DWORD)@<eax>,
        void (__cdecl *a2)(int)@<edx>,
        int a3@<ecx>))(_DWORD, _DWORD, _DWORD)
{
  _DWORD *v6; // eax
  int v7; // edx
  _DWORD *v8; // ebp
  int (__cdecl *v9)(_DWORD, _DWORD, _DWORD); // eax
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax
  int (__cdecl *v11)(_DWORD, _DWORD, _DWORD); // [esp+18h] [ebp-24h]
  int v12; // [esp+1Ch] [ebp-20h]

  v6 = (_DWORD *)dl_error_catch_tsd();
  v7 = *v6;
  v8 = v6;
  v9 = receiver;
  *v8 = 0;
  receiver = a1;
  v11 = v9;
  v12 = v7;
  a2(a3);
  result = v11;
  *v8 = v12;
  receiver = v11;
  return result;
}
// 80EFA30: using guessed type int (*dl_error_catch_tsd)(void);
// 80F0DF0: using guessed type int (__cdecl *receiver)(_DWORD, _DWORD, _DWORD);

//----- (0808E630) --------------------------------------------------------
_DWORD *__usercall dl_debug_initialize@<eax>(int a1@<eax>, int a2@<edx>)
{
  _DWORD *result; // eax
  int v4; // edx

  result = &r_debug;
  if ( a2 )
    result = (_DWORD *)(76 * a2 + 135205432);
  if ( a1 || !result[1] )
  {
    if ( !a1 )
      a1 = dword_80F130C;
    *result = 1;
    result[4] = a1;
    v4 = dl_ns[19 * a2];
    result[2] = dl_debug_state;
    result[1] = v4;
  }
  return result;
}
// 808E620: using guessed type int dl_debug_state();
// 80F1200: using guessed type int dl_ns[];
// 80F130C: using guessed type int dword_80F130C;

//----- (0808E680) --------------------------------------------------------
__int64 __usercall dl_debug_vdprintf@<edx:eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int *a4)
{
  _BYTE *v4; // edi
  int v5; // esi
  char v7; // al
  _BYTE *v8; // edx
  char v10; // al
  _BYTE *v11; // edi
  bool v12; // cc
  unsigned int v13; // eax
  bool v14; // zf
  char *v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // edx
  char *v18; // eax
  char *v19; // edx
  unsigned int v20; // edi
  int v21; // esi
  int v22; // edx
  _BYTE *v23; // [esp+0h] [ebp-278h]
  int v24; // [esp+Ch] [ebp-26Ch] BYREF
  int v25; // [esp+2Ch] [ebp-24Ch]
  int v26; // [esp+30h] [ebp-248h]
  unsigned int v27; // [esp+34h] [ebp-244h]
  int v28; // [esp+38h] [ebp-240h]
  int *v29; // [esp+3Ch] [ebp-23Ch]
  int *v30; // [esp+40h] [ebp-238h]
  unsigned int v31; // [esp+44h] [ebp-234h]
  int v32; // [esp+48h] [ebp-230h]
  char *v33; // [esp+4Ch] [ebp-22Ch]
  int v35[128]; // [esp+54h] [ebp-224h] BYREF
  char v36[10]; // [esp+254h] [ebp-24h] BYREF
  char v37[26]; // [esp+25Eh] [ebp-1Ah] BYREF

  v4 = (_BYTE *)a3;
  v5 = 0;
  v28 = a1;
  v7 = *(_BYTE *)a3;
  v32 = 0;
  v33 = v36;
  if ( v7 )
  {
    do
    {
      if ( a2 > 0 )
      {
        if ( !v32 )
        {
          v32 = getpid(a3);
          if ( v32 < 0 )
            _assert_fail("pid >= 0 && sizeof (pid_t) <= 4", "dl-misc.c", 102, "_dl_debug_vdprintf");
          v15 = itoa(v32, v37, 0xAu, 0);
          if ( v15 > v33 )
          {
            do
            {
              v14 = --v15 == v33;
              *v15 = 32;
            }
            while ( !v14 );
          }
          qmemcpy(v37, ":\t", 2);
        }
        if ( v5 > 63 )
          _assert_fail("niov < 64", "dl-misc.c", 111, "_dl_debug_vdprintf");
        v7 = *v4;
        a2 = -1;
        v35[2 * v5 + 1] = 12;
        v35[2 * v5++] = (int)v36;
      }
      if ( v7 && (v8 = v4, v7 != 37) )
      {
        do
        {
          if ( a2 && v7 == 10 )
            break;
          v7 = *++v8;
          if ( *v8 == 37 )
            break;
        }
        while ( v7 );
      }
      else
      {
        v8 = v4;
      }
      if ( v5 > 63 )
        _assert_fail("niov < 64", "dl-misc.c", 124, "_dl_debug_vdprintf");
      a3 = v8 - v4;
      v35[2 * v5 + 1] = v8 - v4;
      if ( v8 != v4 )
        v35[2 * v5++] = (int)v4;
      if ( v7 != 37 )
      {
        if ( v7 == 10 )
        {
          if ( v8 == v4 )
          {
            v35[2 * v5] = (int)v8;
            v35[2 * v5++ + 1] = 1;
          }
          else
          {
            ++v35[2 * v5 - 1];
          }
          a2 = 1;
          v4 = v8 + 1;
        }
        else
        {
          v4 = v8;
        }
        goto LABEL_19;
      }
      v10 = v8[1];
      if ( v10 == 48 )
      {
        v11 = v8 + 2;
        v10 = v8[2];
        LOBYTE(v30) = 48;
      }
      else
      {
        v11 = v8 + 1;
        LOBYTE(v30) = 32;
      }
      a3 = -1;
      if ( v10 == 42 )
      {
        v10 = *++v11;
        a3 = *a4++;
      }
      v31 = -1;
      if ( v10 == 46 )
      {
        if ( v11[1] != 42 )
LABEL_34:
          _assert_fail("! \"invalid format specifier\"", "dl-misc.c", 220, "_dl_debug_vdprintf");
        v10 = v11[2];
        v11 += 2;
        v31 = *a4++;
      }
      if ( v10 == 90 || v10 == 108 )
      {
        v10 = *++v11;
        v12 = v10 <= 117;
        if ( v10 == 117 )
          goto LABEL_47;
      }
      else
      {
        v12 = v10 <= 117;
        if ( v10 == 117 )
          goto LABEL_47;
      }
      if ( v12 )
      {
        if ( v10 == 37 )
        {
          v35[2 * v5] = (int)v11;
          v35[2 * v5++ + 1] = 1;
        }
        else
        {
          if ( v10 != 115 )
            goto LABEL_34;
          v30 = a4 + 1;
          v23 = (_BYTE *)*a4;
          v35[2 * v5] = *a4;
          v13 = strlen(v23);
          v14 = v31 == -1;
          v35[2 * v5 + 1] = v13;
          if ( !v14 )
          {
            if ( v13 > v31 )
              v13 = v31;
            v35[2 * v5 + 1] = v13;
          }
          ++v5;
          a4 = v30;
        }
        goto LABEL_40;
      }
      if ( v10 != 120 )
        goto LABEL_34;
LABEL_47:
      v29 = a4 + 1;
      v14 = *v11 == 120;
      v31 = (unsigned int)&v24;
      v16 = 16;
      v17 = *a4;
      v25 = a3;
      v27 = v17;
      if ( !v14 )
        v16 = 10;
      v18 = itoa(v27, (char *)v31, v16, 0);
      a3 = v25;
      v19 = (char *)(v31 - (_DWORD)v18);
      if ( v25 != -1 && v25 > (int)v19 )
      {
        v27 = (unsigned int)v11;
        v20 = v31;
        v26 = v5;
        v21 = v25;
        a3 = (unsigned __int8)v30;
        do
        {
          v19 = (char *)(v20 - (_DWORD)--v18);
          *v18 = a3;
        }
        while ( v21 > (int)(v20 - (_DWORD)v18) );
        v11 = (_BYTE *)v27;
        v5 = v26;
      }
      v35[2 * v5 + 1] = (int)v19;
      v22 = (int)v29;
      v35[2 * v5++] = (int)v18;
      a4 = (int *)v22;
LABEL_40:
      v4 = v11 + 1;
LABEL_19:
      v7 = *v4;
    }
    while ( *v4 );
  }
  return dl_sysinfo(v35);
}
// 808E878: variable 'a3' is possibly undefined
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (0808EAE0) --------------------------------------------------------
unsigned int __usercall dl_sysdep_read_whole_file@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)
{
  unsigned int v4; // edi
  int v6; // esi
  int v7; // eax
  bool v8; // zf
  char v10[44]; // [esp+20h] [ebp-7Ch] BYREF
  int v11; // [esp+4Ch] [ebp-50h]

  v4 = -1;
  v6 = open(a3, a1, 0x80000);
  if ( v6 >= 0 )
  {
    if ( (_fxstat64(3, v6, (int)v10) & 0x80000000) == 0 )
    {
      v7 = v11;
      v8 = v11 == 0;
      *a2 = v11;
      if ( !v8 )
        v4 = mmap(0, v7, a3, 2, v6, 0);
    }
    close(a3, v6);
  }
  return v4;
}
// 808EAE0: using guessed type char var_7C[44];

//----- (0808EBB0) --------------------------------------------------------
__int64 dl_debug_printf(int a1, ...)
{
  va_list va; // [esp+24h] [ebp+8h] BYREF

  va_start(va, a1);
  return dl_debug_vdprintf(dl_debug_fd, 1, a1, (int *)va);
}
// 80EF5B4: using guessed type int dl_debug_fd;

//----- (0808EBE0) --------------------------------------------------------
__int64 dl_debug_printf_c(int a1, ...)
{
  va_list va; // [esp+24h] [ebp+8h] BYREF

  va_start(va, a1);
  return dl_debug_vdprintf(dl_debug_fd, -1, a1, (int *)va);
}
// 80EF5B4: using guessed type int dl_debug_fd;

//----- (0808EC10) --------------------------------------------------------
__int64 dl_dprintf(int a1, int a2, ...)
{
  va_list va; // [esp+28h] [ebp+Ch] BYREF

  va_start(va, a2);
  return dl_debug_vdprintf(a1, 0, a2, (int *)va);
}

//----- (0808EC30) --------------------------------------------------------
int __usercall dl_name_match_p@<eax>(const char *s1@<eax>, int a2@<edx>)
{
  int v4; // eax
  int v5; // edx
  int v6; // esi

  v4 = strcmp(s1, *(const char **)(a2 + 4));
  v5 = 1;
  if ( !v4 )
    return v5;
  v6 = *(_DWORD *)(a2 + 28);
  LOBYTE(v5) = 0;
  if ( !v6 )
    return v5;
  do
  {
    if ( !strcmp(s1, *(const char **)v6) )
      return 1;
    v6 = *(_DWORD *)(v6 + 4);
  }
  while ( v6 );
  return 0;
}

//----- (0808ECA0) --------------------------------------------------------
int __usercall dl_higher_prime_number@<eax>(unsigned int a1@<eax>)
{
  const char *v1; // ecx
  const char *v2; // ebx
  const char *v3; // edx

  v1 = "\a";
  v2 = "dl-tls.c";
LABEL_3:
  while ( 1 )
  {
    v3 = &v1[4 * ((int)(((unsigned int)(v2 - v1) >> 31) + ((v2 - v1) >> 2)) >> 1)];
    if ( a1 <= *(_DWORD *)v3 )
      break;
    v1 = v3 + 4;
    if ( v3 + 4 == v2 )
      return *(_DWORD *)v1;
  }
  while ( 1 )
  {
    v2 = v3;
    if ( v1 == v3 )
      return *(_DWORD *)v1;
    v3 = &v1[4 * (((v3 - v1) >> 2) / 2)];
    if ( *(_DWORD *)v3 < a1 )
    {
      v1 = v3 + 4;
      if ( v3 + 4 != v2 )
        goto LABEL_3;
      return *(_DWORD *)v1;
    }
  }
}

//----- (0808ED00) --------------------------------------------------------
int __usercall allocate_dtv@<eax>(int a1@<eax>)
{
  int v1; // esi
  _DWORD *v3; // eax

  v1 = dl_tls_max_dtv_idx;
  calloc(dl_tls_max_dtv_idx + 16, 8u);
  if ( !v3 )
    return 0;
  *v3 = v1 + 14;
  *(_DWORD *)(a1 + 4) = v3 + 2;
  return a1;
}
// 808ED28: variable 'v3' is possibly undefined
// 80F1148: using guessed type int dl_tls_max_dtv_idx;

//----- (0808ED50) --------------------------------------------------------
unsigned int dl_next_tls_modid()
{
  int v0; // edx
  unsigned int result; // eax
  unsigned int *v2; // ecx
  unsigned int v3; // esi
  int v4; // ebx

  if ( !dl_tls_dtv_gaps )
  {
    v0 = dl_tls_max_dtv_idx;
LABEL_3:
    result = v0 + 1;
    dl_tls_max_dtv_idx = v0 + 1;
    return result;
  }
  v0 = dl_tls_max_dtv_idx;
  v2 = (unsigned int *)dl_tls_dtv_slotinfo_list;
  result = dl_tls_static_nelem + 1;
  if ( dl_tls_static_nelem + 1 > (unsigned int)dl_tls_max_dtv_idx )
    goto LABEL_14;
  v3 = *(_DWORD *)dl_tls_dtv_slotinfo_list;
  v4 = 0;
  while ( 1 )
  {
    while ( result - v4 < v3 )
    {
      if ( !v2[2 * (result - v4) + 3] )
        goto LABEL_13;
      if ( ++result > dl_tls_max_dtv_idx + 1 )
        _assert_fail("result <= _dl_tls_max_dtv_idx + 1", "dl-tls.c", 76, "_dl_next_tls_modid");
    }
    v2 = (unsigned int *)v2[1];
    if ( !v2 )
      break;
    v4 += v3;
    v3 = *v2;
  }
LABEL_13:
  if ( dl_tls_max_dtv_idx < result )
  {
LABEL_14:
    if ( dl_tls_max_dtv_idx + 1 != result )
      _assert_fail("result == _dl_tls_max_dtv_idx + 1", "dl-tls.c", 90, "_dl_next_tls_modid");
    dl_tls_dtv_gaps = 0;
    goto LABEL_3;
  }
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80F1148: using guessed type int dl_tls_max_dtv_idx;
// 80F114C: using guessed type int dl_tls_dtv_slotinfo_list;
// 80F1150: using guessed type char dl_tls_dtv_gaps;
// 80F1158: using guessed type int dl_tls_static_nelem;

//----- (0808EE30) --------------------------------------------------------
int __usercall dl_get_tls_static_info@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>)
{
  int result; // eax

  *a1 = dl_tls_static_size;
  result = dl_tls_static_align;
  *a2 = dl_tls_static_align;
  return result;
}
// 80EF068: using guessed type int dl_tls_static_size;
// 80F1144: using guessed type int dl_tls_static_align;

//----- (0808EE40) --------------------------------------------------------
int dl_allocate_tls_storage()
{
  int v0; // ebx
  int v1; // eax
  int v2; // esi
  int v3; // edx
  unsigned int v4; // ebx
  _WORD *v5; // edi
  _WORD *v6; // edi
  int result; // eax
  int v8; // [esp+1Ch] [ebp-10h]

  v0 = dl_tls_static_size;
  memalign(dl_tls_static_align, dl_tls_static_size);
  v2 = v1;
  if ( !v1 )
    return 0;
  v3 = v1 + v0 - 1216;
  v4 = 1216;
  v5 = (_WORD *)v3;
  if ( (v3 & 1) != 0 )
  {
    v5 = (_WORD *)(v3 + 1);
    LOBYTE(v4) = -65;
    *(_BYTE *)v3 = 0;
    if ( ((v3 + 1) & 2) == 0 )
      goto LABEL_4;
  }
  else if ( (v3 & 2) == 0 )
  {
    goto LABEL_4;
  }
  *v5 = 0;
  v4 -= 2;
  ++v5;
LABEL_4:
  memset(v5, 0, 4 * (v4 >> 2));
  v6 = &v5[2 * (v4 >> 2)];
  if ( (v4 & 2) != 0 )
  {
    *v6++ = 0;
    if ( (v4 & 1) == 0 )
    {
LABEL_6:
      result = allocate_dtv(v3);
      if ( result )
        return result;
LABEL_9:
      v8 = result;
      free(v2);
      return v8;
    }
  }
  else if ( (v4 & 1) == 0 )
  {
    goto LABEL_6;
  }
  *(_BYTE *)v6 = 0;
  result = allocate_dtv(v3);
  if ( !result )
    goto LABEL_9;
  return result;
}
// 808EE68: variable 'v1' is possibly undefined
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80EF068: using guessed type int dl_tls_static_size;
// 80F1144: using guessed type int dl_tls_static_align;

//----- (0808EF30) --------------------------------------------------------
int __usercall dl_allocate_tls_init@<eax>(int a1@<eax>)
{
  unsigned int v1; // edi
  unsigned int v2; // edx
  unsigned int v3; // ebx
  int *v4; // esi
  unsigned int v5; // ebp
  unsigned int *v6; // ecx
  _WORD *s; // eax
  int v8; // eax
  unsigned int v9; // ecx
  unsigned int *v10; // eax
  unsigned int v12; // [esp+14h] [ebp-38h]
  _BYTE *v13; // [esp+1Ch] [ebp-30h]
  unsigned int *v14; // [esp+20h] [ebp-2Ch]
  unsigned int v15; // [esp+24h] [ebp-28h]
  unsigned int *v16; // [esp+28h] [ebp-24h]

  if ( a1 )
  {
    v1 = 0;
    v15 = 0;
    v16 = *(unsigned int **)(a1 + 4);
    v14 = (unsigned int *)dl_tls_dtv_slotinfo_list;
    v2 = dl_tls_max_dtv_idx;
    while ( 1 )
    {
      v3 = v15 == 0;
      if ( v3 >= *v14 )
        goto LABEL_18;
      if ( __PAIR64__(v2, v15) < __PAIR64__(v15, 1) )
      {
LABEL_21:
        *v16 = v1;
        return a1;
      }
      v4 = (int *)&v14[2 * v3 + 3];
      while ( 1 )
      {
        v8 = *v4;
        if ( !*v4 )
          goto LABEL_10;
        v9 = *(_DWORD *)(v8 + 576);
        if ( v1 < *(v4 - 1) )
          v1 = *(v4 - 1);
        if ( v9 <= 1 )
          break;
        if ( *(_DWORD *)(v8 + 580) != v3 )
          _assert_fail("map->l_tls_modid == cnt", "dl-tls.c", 423, "_dl_allocate_tls_init");
        v5 = *(_DWORD *)(v8 + 560);
        v12 = *(_DWORD *)(v8 + 564);
        if ( v12 < v5 )
          _assert_fail("map->l_tls_blocksize >= map->l_tls_initimage_size", "dl-tls.c", 424, "_dl_allocate_tls_init");
        if ( v9 < v12 )
          _assert_fail("(size_t) map->l_tls_offset >= map->l_tls_blocksize", "dl-tls.c", 426, "_dl_allocate_tls_init");
        v13 = (_BYTE *)(a1 - v9);
        v6 = &v16[2 * v3];
        *((_BYTE *)v6 + 4) = 1;
        *v6 = (unsigned int)v13;
        s = mempcpy(v13, *(_BYTE **)(v8 + 556), v5);
        memset(s, 0, v12 - v5);
LABEL_10:
        if ( *v14 <= ++v3 )
          goto LABEL_17;
LABEL_11:
        v4 += 2;
        if ( v3 + v15 > dl_tls_max_dtv_idx )
          goto LABEL_21;
      }
      ++v3;
      v10 = &v16[2 * *(_DWORD *)(v8 + 580)];
      *v10 = -1;
      *((_BYTE *)v10 + 4) = 0;
      if ( *v14 > v3 )
        goto LABEL_11;
LABEL_17:
      v2 = dl_tls_max_dtv_idx;
LABEL_18:
      v15 += v3;
      if ( v2 <= v15 )
        goto LABEL_21;
      v14 = (unsigned int *)v14[1];
      if ( !v14 )
        _assert_fail("listp != ((void *)0)", "dl-tls.c", 447, "_dl_allocate_tls_init");
    }
  }
  return a1;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80F1148: using guessed type int dl_tls_max_dtv_idx;
// 80F114C: using guessed type int dl_tls_dtv_slotinfo_list;

//----- (0808F140) --------------------------------------------------------
int __usercall dl_allocate_tls@<eax>(int a1@<eax>)
{
  int dtv; // eax

  if ( a1 )
    dtv = allocate_dtv(a1);
  else
    dtv = dl_allocate_tls_storage();
  return dl_allocate_tls_init(dtv);
}

//----- (0808F170) --------------------------------------------------------
int __usercall dl_deallocate_tls@<eax>(int a1@<eax>, char a2@<dl>)
{
  unsigned int v2; // edi
  int v4; // ebp
  unsigned int v5; // eax
  int v6; // esi
  int result; // eax

  v2 = 0;
  v4 = *(_DWORD *)(a1 + 4);
  v5 = *(_DWORD *)(v4 - 8);
  v6 = v4;
  while ( v2 < v5 )
  {
    ++v2;
    if ( !*(_BYTE *)(v6 + 12) && *(_DWORD *)(v6 + 8) != -1 )
    {
      free(*(_DWORD *)(v6 + 8));
      v5 = *(_DWORD *)(v4 - 8);
    }
    v6 += 8;
  }
  result = free(v4 - 8);
  if ( a2 )
    return free(a1 - dl_tls_static_size + 1216);
  return result;
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80EF068: using guessed type int dl_tls_static_size;

//----- (0808F1F0) --------------------------------------------------------
int __cdecl dl_tls_get_addr_soft(int a1)
{
  unsigned int v1; // edx
  _DWORD *v2; // ecx
  int result; // eax
  unsigned int *v4; // esi
  unsigned int v5; // edi
  unsigned int v6; // eax

  v1 = *(_DWORD *)(a1 + 580);
  if ( !v1 )
    return 0;
  v2 = (_DWORD *)__readgsdword(4u);
  if ( *v2 == dl_tls_generation )
    goto LABEL_3;
  result = 0;
  if ( v1 < *(v2 - 2) )
  {
    v4 = (unsigned int *)dl_tls_dtv_slotinfo_list;
    v5 = *(_DWORD *)(a1 + 580);
    v6 = *(_DWORD *)dl_tls_dtv_slotinfo_list;
    if ( v1 >= *(_DWORD *)dl_tls_dtv_slotinfo_list )
    {
      do
      {
        v4 = (unsigned int *)v4[1];
        v5 -= v6;
        v6 = *v4;
      }
      while ( *v4 <= v5 );
    }
    result = 0;
    if ( *v2 >= v4[2 * v5 + 2] )
    {
LABEL_3:
      result = v2[2 * v1];
      if ( result == -1 )
        return 0;
    }
  }
  return result;
}
// 80F114C: using guessed type int dl_tls_dtv_slotinfo_list;
// 80F1154: using guessed type int dl_tls_generation;

//----- (0808F270) --------------------------------------------------------
int __cdecl dl_add_to_slotinfo(unsigned int a1)
{
  unsigned int *v1; // edi
  unsigned int v2; // ebx
  unsigned int *v3; // eax
  int v4; // eax
  int result; // eax

  v1 = (unsigned int *)dl_tls_dtv_slotinfo_list;
  v2 = *(_DWORD *)(a1 + 580);
  while ( v2 >= *v1 )
  {
    v2 -= *v1;
    if ( !v1[1] )
    {
      if ( v2 )
        _assert_fail("idx == 0", "dl-tls.c", 844, "_dl_add_to_slotinfo");
      v3 = (unsigned int *)malloc(504);
      v1[1] = (unsigned int)v3;
      if ( !v3 )
      {
        ++dl_tls_generation;
        dl_signal_error("cannot create TLS data structures");
      }
      *v3 = 62;
      v3[1] = 0;
      memset(v3 + 2, 0, 0x1F0u);
      v1 = v3;
      break;
    }
    v1 = (unsigned int *)v1[1];
  }
  v4 = dl_tls_generation;
  v1[2 * v2 + 3] = a1;
  result = v4 + 1;
  v1[2 * v2 + 2] = result;
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 80F114C: using guessed type int dl_tls_dtv_slotinfo_list;
// 80F1154: using guessed type int dl_tls_generation;

//----- (0808F350) --------------------------------------------------------
int dl_get_origin()
{
  int v0; // ebx
  _BYTE *v1; // ebx
  int v2; // edi
  int v3; // esi
  _BYTE *v4; // eax
  _WORD *i; // eax
  int v7; // eax
  _BYTE *v8; // eax
  char v10[4108]; // [esp+10h] [ebp-100Ch] BYREF

  v0 = dl_sysinfo(v10);
  if ( v0 <= 0 || v10[0] == 91 )
  {
    v1 = (_BYTE *)dl_origin_path;
    v2 = -1;
    if ( !dl_origin_path )
      return v2;
    v3 = strlen((_BYTE *)dl_origin_path);
    v4 = (_BYTE *)malloc(v3 + 1);
    v2 = (int)v4;
    if ( v4 )
    {
      for ( i = mempcpy(v4, v1, v3); (unsigned int)i > v2 + 1; i = (_WORD *)((char *)i - 1) )
      {
        if ( *((_BYTE *)i - 1) != 47 )
          break;
      }
      *(_BYTE *)i = 0;
      return v2;
    }
  }
  else
  {
    if ( v10[0] != 47 )
      _assert_fail("linkval[0] == '/'", "../sysdeps/unix/sysv/linux/dl-origin.c", 48, "_dl_get_origin");
    v7 = 2;
    if ( v0 != 1 )
    {
      do
      {
        if ( v10[v0 - 1] == 47 )
        {
          v7 = v0 + 1;
          goto LABEL_17;
        }
        --v0;
      }
      while ( v0 != 1 );
      v7 = 2;
    }
LABEL_17:
    v8 = (_BYTE *)malloc(v7);
    v2 = (int)v8;
    if ( v8 )
    {
      if ( v0 != 1 )
      {
        *(_BYTE *)mempcpy(v8, v10, v0 - 1) = 0;
        return v2;
      }
      *(_WORD *)v8 = 47;
      return v2;
    }
  }
  return -1;
}
// 808F37F: conditional instruction was optimized away because eax.4>=1
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80F11C8: using guessed type int dl_origin_path;

//----- (0808F4A0) --------------------------------------------------------
int __cdecl dl_scope_free(int a1)
{
  int result; // eax
  int *v2; // esi
  int v3; // eax
  int v4; // edx
  int v5; // edx
  int v6; // eax
  _DWORD *v7; // eax

  if ( __readgsdword(0xCu) )
  {
    v2 = (int *)dl_scope_free_list;
    if ( dl_scope_free_list )
    {
      v3 = *(_DWORD *)dl_scope_free_list;
      if ( *(_DWORD *)dl_scope_free_list > 0x31u )
      {
        dl_wait_lookup_done();
        v4 = *v2;
        result = 1;
        if ( *v2 )
        {
          do
          {
            v5 = v4 - 1;
            v6 = v2[v5 + 1];
            *v2 = v5;
            free(v6);
            v4 = *v2;
          }
          while ( *v2 );
          return 1;
        }
      }
      else
      {
        *(_DWORD *)(dl_scope_free_list + 4 * v3 + 4) = a1;
        *v2 = v3 + 1;
        return 0;
      }
    }
    else
    {
      v7 = (_DWORD *)malloc(204);
      dl_scope_free_list = (int)v7;
      if ( v7 )
      {
        v7[1] = a1;
        *v7 = 1;
        return 0;
      }
      else
      {
        dl_wait_lookup_done();
        free(a1);
        return 1;
      }
    }
  }
  else
  {
    free(a1);
    return 0;
  }
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80F11A0: using guessed type int (*dl_wait_lookup_done)(void);
// 80F11C4: using guessed type int dl_scope_free_list;

//----- (0808F560) --------------------------------------------------------
unsigned int __usercall dl_make_stack_executable@<eax>(_DWORD *a1@<eax>)
{
  unsigned int result; // eax

  if ( *a1 != _libc_stack_end )
    return 1;
  if ( mprotect(*a1 & -dl_pagesize, dl_pagesize) )
    return __readgsdword(0xFFFFFFE8);
  *a1 = 0;
  result = 0;
  dl_stack_flags |= 1u;
  return result;
}
// 80EEFC0: using guessed type int _libc_stack_end;
// 80EF5AC: using guessed type int dl_stack_flags;
// 80EF5B8: using guessed type int dl_pagesize;

//----- (0808F5C0) --------------------------------------------------------
void __stdcall __spoils<ecx> dl_runtime_resolve(int a1, int a2, int a3)
{
  int (**retaddr)(void); // [esp+8h] [ebp+0h]

  dl_fixup(retaddr, a1);
}

//----- (0808F5E0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge __spoils<ecx,st0> dl_runtime_profile(
        int a1@<ecx>,
        int a2@<edi>,
        long double a3@<st1>,
        long double a4@<st0>,
        int a5,
        int a6,
        char a7,
        int a8,
        int a9)
{
  int (*v9)(void); // eax
  __int64 v10; // [esp-8h] [ebp-3Ch] BYREF
  long double v11; // [esp+0h] [ebp-34h]
  long double v12; // [esp+Ch] [ebp-28h] BYREF
  int v13; // [esp+18h] [ebp-1Ch] BYREF
  int (*v14)(void); // [esp+1Ch] [ebp-18h]
  int v15; // [esp+28h] [ebp-Ch]
  _DWORD *v16; // [esp+2Ch] [ebp-8h]
  unsigned int v17; // [esp+30h] [ebp-4h]
  int retaddr; // [esp+34h] [ebp+0h]

  v15 += 8;
  v14 = (int (*)(void))a1;
  HIDWORD(v12) = -1;
  v9 = dl_profile_fixup(v16, v17, retaddr, (int)&v13, (_DWORD *)&v12 + 2);
  if ( v12 >= 0.0 )
  {
    DWORD1(v12) = a2;
    qmemcpy((char *)&v12 - (HIDWORD(v12) & 0xFFFFFFF8 | 4), &a5, 4 * (HIDWORD(v12) >> 2));
    v10 = ((__int64 (__fastcall *)(int (*)(void), int, int (*)(void)))v9)(v14, v13, v9);
    v11 = a3;
    v12 = a4;
    dl_call_pltexit(&v10);
  }
  else
  {
    v14 = v9;
  }
}
// 808F693: positive sp value 8 has been found
// 808F5E0: could not find valid save-restore pair for edi
// 808F5E0: could not find valid save-restore pair for esi
// 80AD7A0: using guessed type _DWORD __stdcall dl_call_pltexit(_DWORD);

//----- (0808F6A0) --------------------------------------------------------
int __cdecl dl_mcount_wrapper(int a1)
{
  int retaddr; // [esp+1Ch] [ebp+0h]

  return dl_mcount(retaddr, a1);
}

//----- (0808F6C0) --------------------------------------------------------
int __cdecl dl_mcount_wrapper_check(int a1)
{
  int result; // eax
  int retaddr; // [esp+1Ch] [ebp+0h]

  result = dl_profile_map;
  if ( dl_profile_map )
    return dl_mcount(retaddr, a1);
  return result;
}
// 80F11E4: using guessed type int dl_profile_map;

//----- (0808F6F0) --------------------------------------------------------
unsigned int dl_initial_error_catch_tsd()
{
  return __readgsdword(0) - 4;
}

//----- (0808F700) --------------------------------------------------------
int __usercall dl_tlsdesc_return@<eax>(int a1@<eax>)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (0808F710) --------------------------------------------------------
unsigned int __usercall dl_tlsdesc_undefweak@<eax>(int a1@<eax>)
{
  return *(_DWORD *)(a1 + 4) - __readgsdword(0);
}

//----- (0808F720) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_abs_plus_addend@<eax>(
        int (__fastcall **a1)(int, int)@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>)
{
  dl_tlsdesc_resolve_abs_plus_addend_fixup((int)a1, *(_DWORD *)(a4 + 4), 16);
  return (*a1)(a3, a2);
}

//----- (0808F740) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_rel@<eax>(
        int (__fastcall **a1)(int, int)@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>)
{
  dl_tlsdesc_resolve_rel_fixup((int)a1, *(_DWORD **)(a4 + 4), 16);
  return (*a1)(a3, a2);
}

//----- (0808F760) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_rela@<eax>(
        int (__fastcall **a1)(int, int)@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        long double a5@<st0>)
{
  dl_tlsdesc_resolve_rela_fixup((int)a1, *(_DWORD *)(a4 + 4), 16, a5);
  return (*a1)(a3, a2);
}

//----- (0808F780) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_hold@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  dl_tlsdesc_resolve_hold_fixup(a1, 16);
  return ((int (__fastcall *)(int, int))*a1)(a3, a2);
}

//----- (0808F7A0) --------------------------------------------------------
int __userpurge _gconv_open@<eax>(const char *a1@<eax>, int *a2@<edx>, int **a3@<ecx>, int a4)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  _BYTE *v9; // edi
  int v10; // eax
  void *v11; // esp
  int transform; // eax
  unsigned int v13; // ebx
  unsigned int v14; // esi
  int v15; // eax
  int v16; // ebx
  size_t v17; // esi
  int *v18; // edx
  int v19; // eax
  int v20; // edi
  _DWORD *v21; // esi
  int v22; // eax
  bool v23; // zf
  int v24; // ebx
  int (__cdecl *v25)(int *, _DWORD); // eax
  _DWORD *v26; // eax
  int *v27; // ecx
  int v28; // edx
  int v29; // edx
  int *v30; // ecx
  unsigned int v31; // ebx
  int v32; // esi
  int v33; // eax
  int *v34; // edx
  _BYTE *v36; // esi
  int v37; // eax
  void *v38; // esp
  int *v39; // edi
  _DWORD *v40; // ebx
  void (__cdecl *v41)(_DWORD); // eax
  _DWORD *v42; // esi
  int v43; // eax
  _BYTE *v44; // esi
  unsigned int v45; // edx
  void *v46; // esp
  int v47; // eax
  void *v48; // esp
  char *m; // esi
  char i; // al
  _BYTE *v51; // eax
  char v52; // cl
  char *v53; // edx
  unsigned int v54; // eax
  void *v55; // esp
  _DWORD *v56; // edi
  _DWORD *v57; // eax
  int v58; // edx
  unsigned int k; // ecx
  char v60; // al
  int *n; // eax
  int *v62; // ecx
  _DWORD *v63; // ebx
  unsigned int j; // edx
  unsigned int v65; // eax
  unsigned int v66; // eax
  _DWORD v67[2]; // [esp-20h] [ebp-78h] BYREF
  char **v68; // [esp-18h] [ebp-70h]
  int v69; // [esp-14h] [ebp-6Ch]
  int (__cdecl *v70)(_DWORD *, int, int, int, unsigned int **, unsigned int, int *, _DWORD *); // [esp-10h] [ebp-68h]
  int **v71; // [esp+10h] [ebp-48h] BYREF
  int v72; // [esp+14h] [ebp-44h]
  int v73; // [esp+18h] [ebp-40h]
  unsigned int v74; // [esp+1Ch] [ebp-3Ch]
  int *v75; // [esp+20h] [ebp-38h]
  unsigned int v76; // [esp+24h] [ebp-34h]
  unsigned int v77; // [esp+28h] [ebp-30h]
  int *v78; // [esp+2Ch] [ebp-2Ch]
  int v79; // [esp+34h] [ebp-24h] BYREF
  unsigned int v80; // [esp+38h] [ebp-20h] BYREF
  int v81[7]; // [esp+3Ch] [ebp-1Ch] BYREF
  int savedregs; // [esp+58h] [ebp+0h] BYREF

  v77 = (unsigned int)a1;
  v71 = a3;
  v5 = strchr(a1, 47);
  v76 = 0;
  v74 = 0;
  if ( v5 )
  {
    v6 = strchr(v5 + 1, 47);
    if ( v6 )
    {
      if ( v6[1] )
      {
        v44 = v6 + 1;
        v45 = (unsigned int)&v6[-v77 + 1];
        v46 = alloca(v45 + 16);
        *((_BYTE *)&v71 + v45) = 0;
        v77 = (unsigned int)memcpy(&v71, (_BYTE *)v77, v45);
        v47 = strlen(v44);
        v48 = alloca(v47 + 16);
        m = memcpy(&v71, v44, v47 + 1);
        for ( i = *m; *m == 44; i = *m )
          ++m;
        v76 = 0;
        v74 = 0;
        if ( i )
        {
          v51 = m + 1;
          v52 = m[1];
          if ( v52 )
          {
            while ( 1 )
            {
              v53 = v51 + 1;
              if ( v52 == 44 )
                break;
              ++v51;
              v52 = *v53;
              if ( !*v53 )
                goto LABEL_65;
            }
            *v51++ = 0;
          }
LABEL_65:
          if ( m )
          {
            v78 = (int *)v51;
            v56 = 0;
            v76 = 0;
            v74 = 0;
            v75 = a2;
            while ( 1 )
            {
              if ( strcasecmp_l(m, "TRANSLIT", nl_C_locobj) )
              {
                if ( strcasecmp_l(m, "IGNORE", nl_C_locobj) )
                {
                  v63 = v56;
                  if ( v56 )
                  {
                    while ( !*v63 || strcasecmp_l(m, *v63, nl_C_locobj) )
                    {
                      if ( !v63[1] )
                      {
                        for ( j = 0; j < 8; ++j )
                          v67[j] = 0;
                        v67[0] = m;
                        if ( v63 )
                          v63[1] = v67;
                        else
                          v56 = v67;
                        break;
                      }
                      v63 = (_DWORD *)v63[1];
                    }
                  }
                  else
                  {
                    v66 = 0;
                    v56 = v67;
                    do
                      v67[v66++] = 0;
                    while ( v66 < 8 );
                    v67[0] = m;
                  }
                }
                else
                {
                  v74 = 2;
                }
              }
              else if ( v56 )
              {
                v57 = v56;
                if ( (int (__cdecl *)(_DWORD *, int, int, int, unsigned int **, unsigned int, int *, _DWORD *))v56[4] != _gconv_transliterate )
                {
                  while ( 1 )
                  {
                    v58 = v57[1];
                    if ( !v58 )
                      break;
                    if ( *(int (__cdecl **)(_DWORD *, int, int, int, unsigned int **, unsigned int, int *, _DWORD *))(v58 + 16) == _gconv_transliterate )
                      goto LABEL_78;
                    v57 = (_DWORD *)v57[1];
                  }
                  for ( k = 0; k < 8; ++k )
                    v67[k] = 0;
                  v68 = &internal_trans_names_7159;
                  v69 = 1;
                  v70 = _gconv_transliterate;
                  if ( v57 )
                    v57[1] = v67;
                  else
                    v56 = v67;
                }
              }
              else
              {
                v65 = 0;
                v56 = v67;
                do
                  v67[v65++] = 0;
                while ( v65 < 8 );
                v68 = &internal_trans_names_7159;
                v69 = 1;
                v70 = _gconv_transliterate;
              }
LABEL_78:
              v60 = *(_BYTE *)v78;
              for ( m = (char *)v78; *m == 44; v60 = *m )
                ++m;
              if ( !v60 )
                break;
              for ( n = (int *)(m + 1); *(_BYTE *)n; n = (int *)((char *)n + 1) )
              {
                v62 = (int *)((char *)n + 1);
                if ( *(_BYTE *)n == 44 )
                {
                  *(_BYTE *)n = 0;
                  goto LABEL_86;
                }
              }
              v62 = n;
LABEL_86:
              if ( !m )
                break;
              v78 = v62;
            }
            v76 = (unsigned int)v56;
            a2 = v75;
          }
          else
          {
            v76 = 0;
            v74 = 0;
          }
        }
      }
    }
    else
    {
      v76 = v74;
    }
  }
  v7 = strchr((const char *)a2, 47);
  if ( v7 )
  {
    v8 = strchr(v7 + 1, 47);
    if ( v8 )
    {
      if ( v8[1] )
      {
        v54 = v8 + 1 - (char *)a2;
        v55 = alloca(v54 + 16);
        *((_BYTE *)&v71 + v54) = 0;
        a2 = (int *)memcpy(&v71, a2, v54);
      }
    }
  }
  if ( *(_BYTE *)v77 == 47 && *(_BYTE *)(v77 + 1) == 47 && !*(_BYTE *)(v77 + 2) )
  {
    v9 = *(_BYTE **)(*(_DWORD *)__readgsdword(0xFFFFFFDC) + 92);
    v10 = strlen(v9);
    v11 = alloca(v10 + 18);
    strcpy((char *)mempcpy(&v71, v9, v10), "//");
    v77 = (unsigned int)&v71;
  }
  if ( *(_BYTE *)a2 == 47 && *((_BYTE *)a2 + 1) == 47 && !*((_BYTE *)a2 + 2) )
  {
    v36 = *(_BYTE **)(*(_DWORD *)__readgsdword(0xFFFFFFDC) + 92);
    v37 = strlen(v36);
    v38 = alloca(v37 + 18);
    a2 = (int *)&v71;
    strcpy((char *)mempcpy(&v71, v36, v37), "//");
  }
  transform = _gconv_find_transform(&v79, a2, &v80, a4);
  v75 = 0;
  v73 = transform;
  if ( !transform )
  {
    if ( v76 )
    {
      v13 = v76;
      v14 = 0;
      do
      {
        if ( *(_DWORD *)v13 && (_gconv_translit_find((_BYTE **)v13, (int)&savedregs), v15) )
        {
          if ( v14 )
          {
            *(_DWORD *)(v14 + 4) = *(_DWORD *)(v13 + 4);
            v13 = *(_DWORD *)(v13 + 4);
          }
          else
          {
            v13 = *(_DWORD *)(v13 + 4);
            v76 = v13;
          }
        }
        else
        {
          v14 = v13;
          v13 = *(_DWORD *)(v13 + 4);
        }
      }
      while ( v13 );
    }
    v16 = v80;
    v17 = 36 * v80;
    v75 = (int *)malloc(36 * v80 + 8);
    if ( !v75 )
    {
      v76 = -24;
      v74 = __readgsdword(0xFFFFFFE8);
LABEL_43:
      _gconv_close_transform(v79, v16);
      v73 = 3;
      v75 = 0;
      __writegsdword(v76, v74);
      goto LABEL_39;
    }
    v18 = v75;
    v19 = v79;
    *v75 = v16;
    v18[1] = v19;
    memset(v18 + 2, 0, v17);
    if ( v80 )
    {
      v20 = 0;
      v77 = 0;
      v78 = v75;
      while ( 1 )
      {
        v21 = (_DWORD *)v76;
        v22 = 9 * v77;
        v23 = v76 == 0;
        v78[7] = (int)&v75[9 * v77 + 8];
        v72 = v22;
        if ( !v23 )
        {
          do
          {
            v24 = 0;
            if ( v21[3] )
            {
              while ( strcasecmp_l(*(_DWORD *)(v79 + v20 + 12), *(_DWORD *)(v21[2] + 4 * v24), nl_C_locobj) )
              {
                if ( v21[3] <= (unsigned int)++v24 )
                  goto LABEL_35;
              }
              v25 = (int (__cdecl *)(int *, _DWORD))v21[6];
              v81[0] = 0;
              if ( !v25 || !v25(v81, *(_DWORD *)(v79 + v20 + 16)) )
              {
                v26 = (_DWORD *)malloc(20);
                if ( !v26 )
                  goto LABEL_45;
                v27 = v78;
                *v26 = v21[4];
                v26[1] = v21[5];
                v28 = v21[7];
                v26[4] = 0;
                v26[2] = v28;
                v26[3] = v81[0];
                v29 = v27[10];
                if ( v29 )
                {
                  do
                  {
                    v30 = (int *)(v29 + 16);
                    v29 = *(_DWORD *)(v29 + 16);
                  }
                  while ( v29 );
                }
                else
                {
                  v30 = &v75[v72 + 10];
                }
                *v30 = (int)v26;
              }
            }
LABEL_35:
            v21 = (_DWORD *)v21[1];
          }
          while ( v21 );
        }
        v31 = v80;
        if ( v80 - 1 <= v77 )
        {
          v75[9 * v77 + 4] = v74 | 1;
          goto LABEL_39;
        }
        v78[4] = v74;
        v32 = 8160 * *(_DWORD *)(v79 + v20 + 48);
        v33 = malloc(v32);
        v34 = v78;
        v78[2] = v33;
        if ( !v33 )
          break;
        v20 += 60;
        ++v77;
        v34[3] = v32 + v33;
        v78 = v34 + 9;
        if ( v31 <= v77 )
          goto LABEL_39;
      }
LABEL_45:
      v76 = -24;
      v74 = __readgsdword(0xFFFFFFE8);
      if ( v77 )
      {
        v78 = (int *)(v77 - 1);
        v39 = &v75[9 * v77 + 1];
        while ( 1 )
        {
          v40 = (_DWORD *)*v39;
          if ( *v39 )
          {
            while ( 1 )
            {
              v41 = (void (__cdecl *)(_DWORD))v40[2];
              v42 = (_DWORD *)v40[4];
              if ( v41 )
                v41(v40[3]);
              free(v40);
              if ( !v42 )
                break;
              v40 = v42;
            }
          }
          v43 = *(v39 - 8);
          v39 -= 9;
          free(v43);
          if ( !v78 )
            break;
          v78 = (int *)((char *)v78 - 1);
        }
      }
      free(v75);
      v16 = v80;
      goto LABEL_43;
    }
  }
LABEL_39:
  *v71 = v75;
  return v73;
}
// 808F8DF: variable 'v15' is possibly undefined
// 80482A0: using guessed type int __cdecl strcasecmp_l(_DWORD, _DWORD, _DWORD);
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 8090CD0: using guessed type int __fastcall _gconv_find_transform(_DWORD, _DWORD, _DWORD, _DWORD);
// 80C8380: using guessed type char **nl_C_locobj[6];
// 80CD950: using guessed type char *internal_trans_names_7159;
// 808F7A0: using guessed type int var_1C[7];

//----- (0808FEE0) --------------------------------------------------------
int __userpurge _gconv@<eax>(_DWORD *a1@<eax>, int *a2@<edx>, unsigned int a3@<ecx>, int *a4, int a5, _DWORD *a6)
{
  int v9; // eax
  int v10; // edx
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  int (__cdecl *v13)(_DWORD, _DWORD *, int *, unsigned int, _DWORD, _DWORD *, int, _DWORD); // edi
  int result; // eax
  _DWORD *v15; // ecx
  unsigned int v16; // edx
  int v17; // [esp+24h] [ebp-28h]
  unsigned int v18; // [esp+28h] [ebp-24h]

  if ( a1 == (_DWORD *)-1 )
    return 8;
  v9 = *a1;
  if ( !a6 )
    _assert_fail("irreversible != ((void *)0)", "gconv.c", 45, "__gconv");
  *a6 = 0;
  v10 = 0;
  if ( a4 )
    v10 = *a4;
  v18 = v9 - 1;
  v11 = &a1[9 * v9 - 9];
  v11[2] = v10;
  v11[3] = a5;
  v12 = (_DWORD *)a1[1];
  v13 = (int (__cdecl *)(_DWORD, _DWORD *, int *, unsigned int, _DWORD, _DWORD *, int, _DWORD))v12[5];
  if ( *v12 )
    v13 = (int (__cdecl *)(_DWORD, _DWORD *, int *, unsigned int, _DWORD, _DWORD *, int, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v13, 9));
  if ( a2 )
  {
    v17 = *a2;
    if ( *a2 )
    {
      if ( !a4 || !*a4 )
        _assert_fail("outbuf != ((void *)0) && *outbuf != ((void *)0)", "gconv.c", 75, "__gconv");
      while ( 1 )
      {
        dl_mcount_wrapper_check((int)v13);
        result = v13(a1[1], a1 + 2, a2, a3, 0, a6, 0, 0);
        if ( result != 4 || v17 == *a2 || a3 < *a2 + *(_DWORD *)(a1[1] + 36) )
          break;
        v17 = *a2;
      }
LABEL_16:
      if ( *a4 )
        *a4 = a1[9 * v18 + 2];
      return result;
    }
  }
  dl_mcount_wrapper_check((int)v13);
  result = v13(a1[1], a1 + 2, 0, 0, 0, a6, (a1[9 * v18 + 2] == 0) - 1 + 2, 0);
  if ( !result )
  {
    v15 = a1;
    v16 = 0;
    do
    {
      ++v16;
      v15[5] = 0;
      v15 += 9;
    }
    while ( v18 >= v16 );
  }
  if ( a4 )
    goto LABEL_16;
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08090100) --------------------------------------------------------
void __usercall _gconv_close(int *a1@<eax>, long double a2@<st0>)
{
  int v2; // ebx
  int *i; // ebp
  _DWORD *v4; // esi
  void (__cdecl *v5)(_DWORD); // eax
  _DWORD *v6; // edi
  int v8; // [esp+1Ch] [ebp-20h]

  v2 = a1[1];
  v8 = *a1;
  for ( i = a1 + 11; ; i += 9 )
  {
    v4 = (_DWORD *)*(i - 1);
    if ( v4 )
    {
      while ( 1 )
      {
        v5 = (void (__cdecl *)(_DWORD))v4[2];
        v6 = (_DWORD *)v4[4];
        if ( v5 )
          v5(v4[3]);
        free(a2, (int)v4);
        if ( !v6 )
          break;
        v4 = v6;
      }
    }
    if ( (*(_BYTE *)(i - 7) & 1) != 0 )
      break;
    if ( *(i - 9) )
    {
      free(a2, *(i - 9));
      if ( (*(_BYTE *)(i - 7) & 1) != 0 )
        break;
    }
  }
  free(a2, (int)a1);
  _gconv_close_transform(v2, v8);
}

//----- (080901A0) --------------------------------------------------------
int __cdecl _gconv_alias_compare(char *s1, char *s2)
{
  return strcmp(*(const char **)s1, *(const char **)s2);
}

//----- (080901C0) --------------------------------------------------------
int __usercall do_lookup_alias@<eax>(int a1@<eax>)
{
  _DWORD *v1; // eax
  int v3[5]; // [esp+18h] [ebp-14h] BYREF

  v3[0] = a1;
  v1 = tfind((int)v3, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
  if ( v1 )
    return *(_DWORD *)(*v1 + 4);
  else
    return 0;
}
// 80F1318: using guessed type int _gconv_alias_db;
// 80901C0: using guessed type int var_14[5];

//----- (08090200) --------------------------------------------------------
int __cdecl derivation_compare(const char **a1, const char **a2)
{
  int result; // eax

  result = strcmp(*a1, *a2);
  if ( !result )
    return strcmp(a1[1], a2[1]);
  return result;
}

//----- (08090260) --------------------------------------------------------
int _gconv_get_modules_db()
{
  return _gconv_modules_db;
}
// 80F1310: using guessed type int _gconv_modules_db;

//----- (08090270) --------------------------------------------------------
int _gconv_get_alias_db()
{
  return _gconv_alias_db;
}
// 80F1318: using guessed type int _gconv_alias_db;

//----- (08090280) --------------------------------------------------------
int __usercall _gconv_release_step@<eax>(int *a1@<eax>)
{
  int result; // eax
  int v4; // esi
  void (__cdecl *v5)(int *); // esi

  result = *a1;
  if ( result )
  {
    if ( a1[2]-- == 1 )
    {
      v4 = a1[8];
      if ( v4 )
      {
        v5 = (void (__cdecl *)(int *))(__readgsdword(0x18u) ^ __ROR4__(v4, 9));
        dl_mcount_wrapper_check((int)v5);
        v5(a1);
        result = *a1;
      }
      result = _gconv_release_shlib(result);
      *a1 = 0;
    }
  }
  else if ( a1[8] )
  {
    _assert_fail("step->__end_fct == ((void *)0)", "gconv_db.c", 234, "__gconv_release_step");
  }
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08090310) --------------------------------------------------------
int __userpurge find_derivation@<eax>(
        char *a1@<eax>,
        char *a2@<edx>,
        _BYTE *a3@<ecx>,
        _BYTE *a4,
        int *a5,
        unsigned int *a6)
{
  char *v6; // eax
  int v7; // edx
  _DWORD *v8; // eax
  int v9; // edx
  int v10; // eax
  unsigned int v11; // edi
  int **i; // ebx
  int *shlib; // eax
  int v14; // edx
  int v15; // edi
  int v16; // eax
  void (__cdecl *v17)(int **); // edi
  int *v18; // eax
  int *v19; // eax
  _BYTE *v20; // esi
  int *v21; // eax
  int v22; // ecx
  int v24; // ebx
  char *v25; // edi
  const char *v26; // esi
  int v27; // eax
  int v28; // esi
  char *v29; // eax
  char *v30; // edx
  char *v31; // ecx
  int v32; // eax
  int v33; // edx
  int v34; // ecx
  int v35; // eax
  int v36; // edx
  unsigned int v37; // edi
  int **v38; // ebx
  int *v39; // eax
  int v40; // eax
  char *v41; // eax
  unsigned int v42; // eax
  int *v43; // eax
  _BYTE *v44; // eax
  int v45; // ebx
  char *v46; // esi
  int v47; // ecx
  const char *v48; // edx
  int v49; // ebx
  int v50; // eax
  int v51; // ecx
  bool v52; // zf
  char *v53; // ecx
  int v54; // ecx
  int v55; // ecx
  _DWORD *v56; // esi
  int v57; // eax
  int v58; // edx
  int v59; // ebx
  int v60; // ecx
  int j; // eax
  char **v62; // eax
  int v63; // esi
  int v64; // edi
  char *v65; // ecx
  char *v66; // ebx
  int v67; // edx
  int v68; // ecx
  int *v69; // eax
  int v70; // ecx
  int v71; // ecx
  int v72; // eax
  int v73; // eax
  int *v74; // eax
  int v75; // ecx
  char *v76; // eax
  _BYTE *v77; // edx
  unsigned int v78; // esi
  unsigned int v79; // edi
  int v80; // eax
  _DWORD *v81; // ebx
  _BYTE *v82; // eax
  _WORD *v83; // eax
  _BYTE *v84; // eax
  _DWORD *v85; // eax
  int v86; // edx
  int v87; // ecx
  char *v88; // edx
  bool v89; // cc
  int v90; // ecx
  int v91; // eax
  int v92; // edx
  int v93; // eax
  int (__cdecl *v94)(_DWORD); // ecx
  unsigned int v95; // edi
  int (__cdecl *v96)(_DWORD); // esi
  int *v97; // ebx
  char *v98; // esi
  int *v99; // ebx
  char *v100; // [esp-80h] [ebp-F8h] BYREF
  int v101; // [esp-7Ch] [ebp-F4h]
  char *v102; // [esp-78h] [ebp-F0h]
  int v103; // [esp-74h] [ebp-ECh]
  char *v104; // [esp-70h] [ebp-E8h]
  int v105; // [esp-6Ch] [ebp-E4h]
  int v106; // [esp-68h] [ebp-E0h] BYREF
  _DWORD v107[6]; // [esp-50h] [ebp-C8h] BYREF
  int v108; // [esp-38h] [ebp-B0h] BYREF
  _BYTE *v109; // [esp-20h] [ebp-98h] BYREF
  int v110; // [esp-1Ch] [ebp-94h]
  int v111; // [esp-18h] [ebp-90h]
  int v112; // [esp-14h] [ebp-8Ch]
  int v113; // [esp-10h] [ebp-88h]
  int v114; // [esp-Ch] [ebp-84h]
  _DWORD *v115; // [esp-8h] [ebp-80h] BYREF
  int (__cdecl *v116)(const char **, const char **); // [esp+8h] [ebp-70h]
  int v117; // [esp+1Ch] [ebp-5Ch]
  int (__cdecl *v118)(int **); // [esp+20h] [ebp-58h]
  int *v119; // [esp+24h] [ebp-54h]
  _BYTE *v120; // [esp+28h] [ebp-50h]
  _BYTE **v121; // [esp+2Ch] [ebp-4Ch]
  char *v122; // [esp+30h] [ebp-48h]
  int v123; // [esp+34h] [ebp-44h]
  char **v124; // [esp+38h] [ebp-40h]
  char *s2; // [esp+3Ch] [ebp-3Ch]
  int v126; // [esp+40h] [ebp-38h]
  int v127; // [esp+44h] [ebp-34h]
  char *v128; // [esp+48h] [ebp-30h]
  const char **v129; // [esp+4Ch] [ebp-2Ch]
  int v130[10]; // [esp+50h] [ebp-28h] BYREF
  int savedregs; // [esp+78h] [ebp+0h] BYREF
  _BYTE *v132; // [esp+80h] [ebp+8h]

  v122 = a1;
  v6 = a2;
  s2 = a2;
  if ( !a2 )
    v6 = v122;
  v120 = a3;
  v130[2] = 0;
  v7 = (int)a4;
  v130[1] = (int)v6;
  v130[3] = 0;
  v116 = derivation_compare;
  if ( !a4 )
    v7 = (int)a3;
  v130[0] = v7;
  v8 = tfind((int)v130, &known_derivations, (int (__cdecl *)(int, _DWORD))v116);
  if ( v8 )
  {
    v9 = *(_DWORD *)(*v8 + 8);
    *a5 = v9;
    v10 = *v8;
    v129 = (const char **)v9;
    v11 = *(_DWORD *)(v10 + 12);
    *a6 = v11;
    v128 = (char *)v11;
    for ( i = (int **)(v9 + 60 * v11 - 60); ; i -= 15 )
    {
      if ( !v11 )
        return 0;
      v19 = i[2];
      v20 = (_BYTE *)(v11 - 1);
      i[2] = (int *)((char *)v19 + 1);
      if ( !v19 )
      {
        v21 = i[1];
        if ( v21 )
        {
          shlib = _gconv_find_shlib(v21, (int)&savedregs, v11, v20);
          *i = shlib;
          if ( !shlib )
          {
            v98 = v128;
            v22 = 1;
            i[2] = (int *)((char *)i[2] - 1);
            if ( (unsigned int)v98 > v11 )
            {
              v99 = (int *)&v129[15 * v11];
              do
              {
                ++v11;
                _gconv_release_step(v99);
                v99 += 15;
              }
              while ( (unsigned int)v98 > v11 );
              return 1;
            }
            return v22;
          }
          v14 = shlib[3];
          v15 = shlib[4];
          v16 = shlib[5];
          i[6] = 0;
          i[5] = (int *)v14;
          i[7] = (int *)v15;
          i[8] = (int *)v16;
        }
        else
        {
          v15 = (int)i[7];
        }
        if ( v15 )
        {
          v17 = (void (__cdecl *)(int **))(__readgsdword(0x18u) ^ __ROR4__(v15, 9));
          dl_mcount_wrapper_check((int)v17);
          v17(i);
          v18 = i[6];
          if ( v18 )
            i[6] = (int *)__ROL4__(__readgsdword(0x18u) ^ (unsigned int)v18, 9);
        }
      }
      v11 = (unsigned int)v20;
    }
  }
  if ( a4 )
  {
    v109 = a4;
    v112 = 0;
    v107[0] = v120;
    v111 = 0;
    v110 = strlen(a4);
    v113 = 0;
    v114 = 0;
    memset(&v107[2], 0, 16);
    v108 = 0;
    v107[1] = strlen(v120);
    v115 = v107;
    v119 = &v108;
  }
  else
  {
    v109 = v120;
    v112 = 0;
    v111 = 0;
    v113 = 0;
    v114 = 0;
    v115 = 0;
    v110 = strlen(v120);
    v119 = (int *)&v115;
  }
  v121 = &v109;
  v123 = 0x7FFFFFFF;
  v126 = 0x7FFFFFFF;
  v124 = 0;
  v129 = (const char **)&v109;
  do
  {
    while ( 1 )
    {
      v24 = (int)v129[3];
      if ( v24 > v126 )
        goto LABEL_30;
      if ( v126 == v24 && (int)v129[2] >= v123 )
        break;
      v25 = (char *)_gconv_modules_db;
      if ( _gconv_modules_db )
      {
        v26 = *v129;
        while ( 1 )
        {
          v27 = strcmp(v26, *(const char **)v25);
          if ( !v27 )
            break;
          if ( v27 >= 0 )
          {
            v25 = (char *)*((_DWORD *)v25 + 7);
            if ( !v25 )
              goto LABEL_30;
          }
          else
          {
            v25 = (char *)*((_DWORD *)v25 + 5);
            if ( !v25 )
              goto LABEL_30;
          }
        }
        while ( 1 )
        {
          v46 = (char *)*((_DWORD *)v25 + 1);
          if ( *v46 == 45 && !v46[1] )
          {
            if ( !s2 )
            {
              v90 = *((_DWORD *)v25 + 3);
              v46 = v122;
              v127 = *((_DWORD *)v25 + 2) + v24;
              v49 = (int)v124;
              v128 = (char *)&v129[2][v90];
              if ( !v124 )
                goto LABEL_120;
LABEL_67:
              while ( strcmp(v46, *(const char **)v49) )
              {
                v49 = *(_DWORD *)(v49 + 24);
                if ( !v49 )
                  goto LABEL_120;
              }
              v50 = *(_DWORD *)(v49 + 12);
              if ( v50 > v127 || v127 == v50 && *(_DWORD *)(v49 + 8) > (int)v128 )
              {
                v86 = (int)v129;
                v87 = v127;
                *(_DWORD *)(v49 + 16) = v25;
                *(_DWORD *)(v49 + 20) = v86;
                v88 = v128;
                *(_DWORD *)(v49 + 12) = v87;
                v51 = v127;
                v89 = v126 <= v127;
                *(_DWORD *)(v49 + 8) = v88;
                if ( !v89 )
                {
LABEL_109:
                  v123 = (int)v128;
                  v126 = v127;
                  goto LABEL_57;
                }
              }
              else
              {
LABEL_70:
                v51 = v127;
                if ( v126 > v127 )
                  goto LABEL_109;
              }
              if ( (int)v128 < v123 )
              {
                v52 = v51 == v126;
                v53 = v128;
                if ( !v52 )
                  v53 = (char *)v123;
                v123 = (int)v53;
                v54 = v127;
                if ( !v52 )
                  v54 = v126;
                v126 = v54;
              }
              goto LABEL_57;
            }
            v46 = s2;
          }
          v47 = *((_DWORD *)v25 + 3);
          v48 = v129[2];
          v127 = *((_DWORD *)v25 + 2) + v24;
          v128 = (char *)&v48[v47];
          if ( !strcmp(v46, v122) || s2 && !strcmp(v46, s2) )
          {
            v49 = (int)v124;
            if ( v124 )
              goto LABEL_67;
LABEL_120:
            v100 = v46;
            v91 = strlen(v46);
            v104 = v25;
            v103 = v127;
            v102 = v128;
            v92 = (int)v124;
            v101 = v91;
            v124 = &v100;
            v105 = (int)v129;
            v106 = v92;
            goto LABEL_70;
          }
          v45 = (int)v121;
          if ( v126 > v127 || v127 == v126 && (int)v128 < v123 )
          {
            while ( strcmp(v46, *(const char **)v45) )
            {
              v45 = *(_DWORD *)(v45 + 24);
              if ( !v45 )
              {
                v100 = v46;
                v93 = strlen(v46);
                v104 = v25;
                v106 = 0;
                v103 = v127;
                v102 = v128;
                v101 = v93;
                v105 = (int)v129;
                *v119 = (int)&v100;
                v119 = &v106;
                goto LABEL_57;
              }
            }
            if ( v127 < *(_DWORD *)(v45 + 12) || v127 == *(_DWORD *)(v45 + 12) && (int)v128 < *(_DWORD *)(v45 + 8) )
            {
              v55 = (int)v129;
              v56 = v121;
              *(_DWORD *)(v45 + 16) = v25;
              *(_DWORD *)(v45 + 20) = v55;
              do
              {
                v57 = v56[4];
                if ( v57 )
                {
                  v58 = v56[5];
                  v59 = *(_DWORD *)(v57 + 8);
                  v60 = *(_DWORD *)(v57 + 12);
                  for ( j = *(_DWORD *)(v58 + 16); j; j = *(_DWORD *)(v58 + 16) )
                  {
                    v58 = *(_DWORD *)(v58 + 20);
                    v59 += *(_DWORD *)(j + 8);
                    v60 += *(_DWORD *)(j + 12);
                  }
                  v56[3] = v59;
                  v56[2] = v60;
                }
                v56 = (_DWORD *)v56[6];
              }
              while ( v56 );
              if ( v124 )
              {
                v128 = v25;
                v62 = v124;
                v63 = v126;
                v64 = v123;
                do
                {
                  while ( 1 )
                  {
                    v65 = v62[4];
                    v66 = v62[5];
                    v67 = *((_DWORD *)v66 + 3) + *((_DWORD *)v65 + 2);
                    v68 = *((_DWORD *)v66 + 2) + *((_DWORD *)v65 + 3);
                    v62[3] = (char *)v67;
                    v62[2] = (char *)v68;
                    if ( v67 >= v63 )
                      break;
                    v62 = (char **)v62[6];
                    v64 = v68;
                    v63 = v67;
                    if ( !v62 )
                      goto LABEL_92;
                  }
                  if ( v63 == v67 && v68 < v64 )
                    v64 = v68;
                  v62 = (char **)v62[6];
                }
                while ( v62 );
LABEL_92:
                v123 = v64;
                v25 = v128;
                v126 = v63;
              }
            }
          }
LABEL_57:
          v25 = (char *)*((_DWORD *)v25 + 6);
          if ( !v25 )
            break;
          v24 = (int)v129[3];
        }
      }
LABEL_30:
      v129 = (const char **)v129[6];
      if ( !v129 )
        goto LABEL_31;
    }
    v129 = (const char **)v129[6];
  }
  while ( v129 );
LABEL_31:
  v28 = (int)v124;
  if ( !v124 )
  {
    v129 = 0;
    v128 = 0;
    *a5 = 0;
    *a6 = 0;
    goto LABEL_126;
  }
  v29 = v124[6];
  if ( v29 )
  {
    v30 = v124[3];
    if ( *((_DWORD *)v29 + 3) < (int)v30 )
    {
      v28 = (int)v124[6];
    }
    else if ( *((char **)v29 + 3) == v30 && *((_DWORD *)v29 + 2) < (int)v124[2] )
    {
      v28 = (int)v124[6];
    }
  }
  v31 = a4;
  v32 = *(_DWORD *)(v28 + 20);
  if ( !a4 )
    v31 = v120;
  v33 = 0;
  v128 = v31;
  v34 = 0;
  if ( v32 )
  {
    do
    {
      v32 = *(_DWORD *)(v32 + 20);
      ++v33;
    }
    while ( v32 );
    v34 = 60 * v33;
  }
  v117 = v33;
  v35 = malloc(v34);
  v36 = v117;
  v129 = (const char **)v35;
  if ( !v35 )
  {
    *a6 = 0;
    v128 = 0;
    *a5 = 0;
    v75 = 3;
    goto LABEL_100;
  }
  *a6 = v117;
  if ( !v36 )
  {
    v128 = 0;
LABEL_99:
    *a5 = (int)v129;
    v75 = 0;
    goto LABEL_100;
  }
  v37 = v36 - 1;
  v38 = (int **)&v129[15 * v36 - 15];
  while ( 2 )
  {
    if ( v37 )
    {
      v38[3] = **(int ***)(v28 + 20);
      if ( *a6 == v36 )
        goto LABEL_51;
      goto LABEL_44;
    }
    v117 = v36;
    v43 = (int *)strdup(v128);
    v36 = v117;
    v38[3] = v43;
    if ( *a6 != v36 )
    {
LABEL_44:
      v39 = (int *)v129[15 * v36 + 3];
      goto LABEL_45;
    }
LABEL_51:
    v44 = *(_BYTE **)v28;
    v117 = v36;
    v39 = (int *)strdup(v44);
    v36 = v117;
LABEL_45:
    v38[4] = v39;
    v40 = *(_DWORD *)(v28 + 16);
    v38[2] = (int *)1;
    v38[14] = 0;
    v41 = *(char **)(v40 + 16);
    if ( *v41 != 47 )
    {
      _gconv_get_builtin_trans(v41, v38);
      goto LABEL_47;
    }
    v117 = v36;
    v69 = _gconv_find_shlib(v41, (int)&savedregs, v37, (_BYTE *)v28);
    if ( !v69 )
    {
      v94 = 0;
      goto LABEL_128;
    }
    v70 = *v69;
    *v38 = v69;
    v38[1] = (int *)v70;
    v38[5] = (int *)v69[3];
    v71 = v69[4];
    v72 = v69[5];
    v38[6] = 0;
    v38[7] = (int *)v71;
    v38[8] = (int *)v72;
    if ( !v71 )
    {
LABEL_47:
      v38 -= 15;
      v28 = *(_DWORD *)(v28 + 20);
      v42 = v37 - 1;
      if ( !v37 )
        goto LABEL_98;
      goto LABEL_48;
    }
    v118 = (int (__cdecl *)(int **))(__readgsdword(0x18u) ^ __ROR4__(v71, 9));
    dl_mcount_wrapper_check((int)v118);
    v73 = v118(v38);
    if ( !v73 )
    {
      v74 = v38[6];
      if ( !v74 )
        goto LABEL_47;
      v38[6] = (int *)__ROL4__(__readgsdword(0x18u) ^ (unsigned int)v74, 9);
      v38 -= 15;
      v28 = *(_DWORD *)(v28 + 20);
      v42 = v37 - 1;
      if ( !v37 )
      {
LABEL_98:
        v128 = (char *)*a6;
        goto LABEL_99;
      }
LABEL_48:
      v36 = v37;
      v37 = v42;
      continue;
    }
    break;
  }
  v37 = v117 - 2;
  v94 = (int (__cdecl *)(_DWORD))v73;
  v129[15 * v117 - 22] = 0;
LABEL_128:
  v95 = v37 + 1;
  if ( *a6 > v95 )
  {
    v96 = v94;
    v97 = (int *)&v129[15 * v95];
    do
    {
      ++v95;
      _gconv_release_step(v97);
      v97 += 15;
    }
    while ( v95 < *a6 );
    v94 = v96;
  }
  v118 = (int (__cdecl *)(int **))v94;
  free(v129);
  v75 = (int)v118;
  v129 = 0;
  v52 = v118 == 0;
  *a6 = 0;
  v128 = 0;
  *a5 = 0;
  if ( v52 )
LABEL_126:
    v75 = 1;
LABEL_100:
  v76 = v122;
  v77 = v120;
  v118 = (int (__cdecl *)(int **))v75;
  if ( s2 )
    v76 = s2;
  s2 = v76;
  if ( a4 )
    v77 = a4;
  v132 = v77;
  v78 = strlen(v77) + 1;
  v79 = strlen(s2) + 1;
  v80 = malloc(v78 + v79 + 16);
  v22 = (int)v118;
  v81 = (_DWORD *)v80;
  if ( v80 )
  {
    v82 = (_BYTE *)(v80 + 16);
    *v81 = v82;
    v83 = mempcpy(v82, v132, v78);
    v84 = memcpy(v83, s2, v79);
    v81[3] = v128;
    v81[1] = v84;
    v81[2] = v129;
    v85 = tsearch((int)v81, &known_derivations, (int (__cdecl *)(int, _DWORD))derivation_compare);
    v22 = (int)v118;
    if ( !v85 )
    {
      free(v81);
      return (int)v118;
    }
  }
  return v22;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80F0DF8: using guessed type int known_derivations;
// 80F1310: using guessed type int _gconv_modules_db;

//----- (08090C20) --------------------------------------------------------
int __usercall _gconv_compare_alias@<eax>(char *a1@<eax>, char *a2@<edx>)
{
  const char *s2; // edi
  const char *s1; // eax
  int v7; // [esp+1Ch] [ebp-10h] BYREF

  if ( !once_0 )
  {
    _gconv_read_conf();
    once_0 |= 2u;
  }
  if ( !_gconv_compare_alias_cache(a1, a2, &v7) )
    return v7;
  s2 = (const char *)do_lookup_alias((int)a2);
  if ( !s2 )
    s2 = a2;
  s1 = (const char *)do_lookup_alias((int)a1);
  if ( !s1 )
    s1 = a1;
  return strcmp(s1, s2);
}
// 80F0DF4: using guessed type int once_0;

//----- (08090CD0) --------------------------------------------------------
void __userpurge _gconv_find_transform(char *a1@<eax>, char *a2@<edx>, int *a3@<ecx>, unsigned int *a4, int a5)
{
  bool v9; // zf
  int v10; // eax
  char *v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  char *v16; // [esp+18h] [ebp-24h]
  char *v17; // [esp+18h] [ebp-24h]
  char *v18; // [esp+1Ch] [ebp-20h]

  if ( !once_0 )
  {
    _gconv_read_conf();
    once_0 |= 2u;
  }
  _ECX = 1;
  v9 = __readgsdword(0xCu) == 0;
  if ( !v9 )
    __asm { lock }
  __asm { cmpxchg ds:__gconv_lock, ecx }
  if ( v9 )
  {
    if ( _gconv_lookup_cache((unsigned __int8 *)a1, (unsigned __int8 *)a2, a3, (int *)a4, a5) == 2 )
    {
      if ( _gconv_modules_db )
      {
        v18 = (char *)do_lookup_alias((int)a2);
        v10 = do_lookup_alias((int)a1);
        v11 = (char *)v10;
        if ( (a5 & 1) == 0 )
          goto LABEL_12;
        v16 = (char *)v10;
        v12 = strcmp(a1, a2);
        v11 = v16;
        if ( !v12 )
          goto LABEL_40;
        if ( v16 )
        {
          v13 = strcmp(v16, a2);
          v11 = v16;
          if ( !v13 )
            goto LABEL_40;
        }
        if ( !v18
          || (v17 = v11, v14 = strcmp(a1, v18), v11 = v17, v14) && (!v17 || (v15 = strcmp(v17, v18), v11 = v17, v15)) )
        {
LABEL_12:
          find_derivation(a1, v11, a2, v18, a3, a4);
          if ( __readgsdword(0xCu) )
            __asm { lock }
          if ( --_gconv_lock )
            L_unlock_2353((int)a4, a5);
        }
        else
        {
LABEL_40:
          if ( __readgsdword(0xCu) )
            __asm { lock }
          if ( --_gconv_lock )
            L_unlock_2470((int)a4, a5);
        }
      }
      else
      {
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --_gconv_lock )
          L_unlock_2373((int)a4, a5);
      }
    }
    else
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --_gconv_lock )
        L_unlock_2293((int)a4, a5);
    }
  }
  else
  {
    L_lock_2277(0, (int)a4, a5);
  }
}
// 80F0DF4: using guessed type int once_0;
// 80F1310: using guessed type int _gconv_modules_db;
// 80F1314: using guessed type int _gconv_lock;

//----- (08090ED0) --------------------------------------------------------
void __usercall _gconv_close_transform(int a1@<eax>, int a2@<edx>)
{
  bool v4; // zf
  int v5; // edi
  int v6; // ebp
  int *v7; // eax

  _ECX = 1;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg ds:__gconv_lock, ecx }
  if ( v4 )
  {
    if ( a2 )
    {
      v5 = a2;
      v6 = a1 + 60 * a2 - 60;
      do
      {
        v7 = (int *)v6;
        v6 -= 60;
        _gconv_release_step(v7);
        --v5;
      }
      while ( v5 );
    }
    _gconv_release_cache(a1);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --_gconv_lock )
      L_unlock_2528();
  }
  else
  {
    L_lock_2497(0);
  }
}
// 80F1314: using guessed type int _gconv_lock;

//----- (08090F3E) --------------------------------------------------------
void __userpurge L_lock_2277(int a1@<eax>, int a2, int a3)
{
  _lll_lock_wait_private(a1, &_gconv_lock);
  JUMPOUT(0x8090D2D);
}
// 8090F49: control flows out of bounds to 8090D2D
// 80F1314: using guessed type int _gconv_lock;

//----- (08090F4E) --------------------------------------------------------
void __stdcall L_unlock_2293(int a1, int a2)
{
  _lll_unlock_wake_private(&_gconv_lock);
  JUMPOUT(0x8090D65);
}
// 8090F59: control flows out of bounds to 8090D65
// 80F1314: using guessed type int _gconv_lock;

//----- (08090F5E) --------------------------------------------------------
void __stdcall L_unlock_2353(int a1, int a2)
{
  _lll_unlock_wake_private(&_gconv_lock);
  JUMPOUT(0x8090DDD);
}
// 8090F69: control flows out of bounds to 8090DDD
// 80F1314: using guessed type int _gconv_lock;

//----- (08090F6E) --------------------------------------------------------
void __stdcall L_unlock_2373(int a1, int a2)
{
  _lll_unlock_wake_private(&_gconv_lock);
  JUMPOUT(0x8090E08);
}
// 8090F79: control flows out of bounds to 8090E08
// 80F1314: using guessed type int _gconv_lock;

//----- (08090F7E) --------------------------------------------------------
void __stdcall L_unlock_2470(int a1, int a2)
{
  _lll_unlock_wake_private(&_gconv_lock);
  JUMPOUT(0x8090EC3);
}
// 8090F89: control flows out of bounds to 8090EC3
// 80F1314: using guessed type int _gconv_lock;

//----- (08090F8E) --------------------------------------------------------
void __usercall L_lock_2497(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &_gconv_lock);
  JUMPOUT(0x8090EFA);
}
// 8090F99: control flows out of bounds to 8090EFA
// 80F1314: using guessed type int _gconv_lock;

//----- (08090F9E) --------------------------------------------------------
void L_unlock_2528()
{
  _lll_unlock_wake_private(&_gconv_lock);
  JUMPOUT(0x8090F34);
}
// 8090FA9: control flows out of bounds to 8090F34
// 80F1314: using guessed type int _gconv_lock;

//----- (08090FB0) --------------------------------------------------------
int __usercall insert_module@<eax>(int result@<eax>, int a2@<edx>)
{
  int *v2; // edi
  int v3; // ebx
  const char *s1; // ebp
  int *v5; // esi
  int v6; // esi
  int v7; // eax

  v2 = &_gconv_modules_db;
  v3 = result;
  while ( 1 )
  {
    v6 = *v2;
    if ( !*v2 )
    {
LABEL_6:
      *v2 = v3;
      return result;
    }
    s1 = *(const char **)v3;
    result = strcmp(*(const char **)v3, *(const char **)v6);
    if ( !result )
      break;
    v2 = (int *)(v6 + 20);
    v5 = (int *)(v6 + 28);
    if ( result >= 0 )
      v2 = v5;
  }
  for ( result = 0; ; result = strcmp(s1, *(const char **)v6) )
  {
    if ( !result )
    {
      result = strcmp(*(const char **)(v3 + 4), *(const char **)(v6 + 4));
      if ( !result )
        break;
    }
    v2 = (int *)(v6 + 24);
    v6 = *(_DWORD *)(v6 + 24);
    if ( !v6 )
      goto LABEL_6;
  }
  v7 = *(_DWORD *)(v6 + 8);
  if ( *(_DWORD *)(v3 + 8) < v7 || *(_DWORD *)(v3 + 8) == v7 && *(_DWORD *)(v3 + 12) < *(_DWORD *)(v6 + 12) )
  {
    *(_DWORD *)(v3 + 20) = *(_DWORD *)(v6 + 20);
    *(_DWORD *)(v3 + 28) = *(_DWORD *)(v6 + 28);
    *(_DWORD *)(v3 + 24) = *(_DWORD *)(v6 + 24);
    *v2 = v3;
    return free(v6);
  }
  else
  {
    result = a2;
    if ( a2 )
      return free(v3);
  }
  return result;
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80F1310: using guessed type int _gconv_modules_db;

//----- (08091080) --------------------------------------------------------
void __userpurge add_module(_BYTE *a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>, int a4, int a5, int a6)
{
  _BYTE *v6; // ebx
  char v7; // dl
  int i; // ecx
  _BYTE *v9; // edx
  char v10; // cl
  char *v11; // esi
  int j; // edx
  char *v13; // edi
  char v14; // dl
  char *v15; // ecx
  char v16; // al
  bool v17; // zf
  unsigned int v18; // eax
  int v19; // esi
  _BYTE *v20; // edi
  unsigned int v21; // eax
  void *v22; // esp
  int v23; // eax
  _DWORD *v24; // ecx
  _BYTE *v25; // eax
  _WORD *v26; // eax
  unsigned int v27; // edx
  _WORD *v28; // eax
  int v29; // ecx
  _WORD *v30; // eax
  int v31; // ecx
  _DWORD *v32; // [esp+10h] [ebp-48h] BYREF
  unsigned int v33; // [esp+14h] [ebp-44h]
  int v34; // [esp+18h] [ebp-40h]
  char *v35; // [esp+1Ch] [ebp-3Ch]
  _BYTE *v36; // [esp+20h] [ebp-38h]
  char *v37; // [esp+24h] [ebp-34h]
  unsigned int v38; // [esp+28h] [ebp-30h]
  char *v39; // [esp+2Ch] [ebp-2Ch]
  _BYTE *v40; // [esp+34h] [ebp-24h] BYREF
  char *v41; // [esp+3Ch] [ebp-1Ch] BYREF

  v6 = a1;
  v36 = a2;
  v7 = *a1;
  v38 = a3;
  for ( i = v7; (byte_80D0CC0[2 * i + 1] & 0x20) != 0; i = (char)*v6 )
    v7 = *++v6;
  if ( v7 )
  {
    if ( (byte_80D0CC0[2 * i + 1] & 0x20) != 0 )
    {
      v9 = v6;
LABEL_10:
      v39 = v9 + 1;
      v10 = v9[1];
      *v9 = 0;
      v11 = v39;
      for ( j = v10; (byte_80D0CC0[2 * j + 1] & 0x20) != 0; j = *v11 )
        v10 = *++v11;
      if ( v10 )
      {
        if ( (byte_80D0CC0[2 * j + 1] & 0x20) != 0 )
        {
          v13 = v39;
LABEL_19:
          *v13 = 0;
          v35 = v13 + 1;
          do
            v14 = *++v11;
          while ( (byte_80D0CC0[2 * *v11 + 1] & 0x20) != 0 );
          v15 = v35;
          if ( v14 )
          {
            v37 = v13;
            do
            {
              *v15 = v14;
              v14 = v11[1];
              ++v15;
              if ( !v14 )
              {
                v13 = v37;
                goto LABEL_26;
              }
              ++v11;
            }
            while ( (byte_80D0CC0[2 * v14 + 1] & 0x20) == 0 );
            *v15 = 0;
            v13 = v37;
            v37 = v15 + 1;
            v34 = strtol(v11, &v41, 10);
            if ( v34 <= 0 || v41 == v11 )
              v34 = 1;
          }
          else
          {
LABEL_26:
            *v15 = 0;
            v37 = v15 + 1;
            v34 = 1;
          }
          v16 = v13[1];
          if ( v16 )
          {
            v17 = v16 == 47;
            v18 = 0;
            if ( !v17 )
              v18 = v38;
            v19 = 3;
            v38 = v18;
            v33 = v37 - v35;
            if ( v37 - v35 > 3 )
              v19 = strcmp(v37 - 4, (const char *)&gconv_module_ext) != 0 ? 3 : 0;
            v20 = (_BYTE *)(v39 - v6);
            v21 = strnlen(v6, v39 - v6);
            v22 = alloca(v21 + 16);
            *((_BYTE *)&v32 + v21) = 0;
            v40 = memcpy(&v32, v6, v21);
            if ( !tfind((int)&v40, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare) )
            {
              calloc(1, v19 + v38 + v37 - v6 + 32);
              v24 = (_DWORD *)v23;
              if ( v23 )
              {
                v25 = (_BYTE *)(v23 + 32);
                *v24 = v25;
                v32 = v24;
                v26 = mempcpy(v25, v6, (unsigned int)v20);
                v27 = v35 - v39;
                v32[1] = v26;
                v28 = mempcpy(v26, v39, v27);
                v29 = (int)v32;
                v32[2] = v34;
                *(_DWORD *)(v29 + 16) = v28;
                *(_DWORD *)(v29 + 12) = a6;
                if ( v38 )
                {
                  v28 = mempcpy(v28, v36, v38);
                  v29 = (int)v32;
                }
                v32 = (_DWORD *)v29;
                v30 = mempcpy(v28, v35, v33);
                v31 = (int)v32;
                if ( v19 )
                  *(_DWORD *)((char *)v30 - 1) = gconv_module_ext;
                insert_module(v31, 1);
              }
            }
          }
        }
        else
        {
          v13 = v39;
          while ( 1 )
          {
            *v13 = dword_80D03C0[j];
            LOBYTE(j) = v11[1];
            if ( !(_BYTE)j )
              break;
            j = (char)j;
            ++v11;
            ++v13;
            if ( (byte_80D0CC0[2 * (char)j + 1] & 0x20) != 0 )
              goto LABEL_19;
          }
        }
      }
    }
    else
    {
      v9 = v6;
      while ( 1 )
      {
        *v9 = dword_80D03C0[i];
        LOBYTE(i) = v9[1];
        if ( !(_BYTE)i )
          break;
        i = (char)i;
        ++v9;
        if ( (byte_80D0CC0[2 * (char)i + 1] & 0x20) != 0 )
          goto LABEL_10;
      }
    }
  }
}
// 8091298: variable 'v23' is possibly undefined
// 8048210: using guessed type int __cdecl strnlen(_DWORD, _DWORD);
// 80CDBAD: using guessed type int gconv_module_ext;
// 80D03C0: using guessed type _DWORD dword_80D03C0[256];
// 80D0CC0: using guessed type _BYTE byte_80D0CC0[512];
// 80F1318: using guessed type int _gconv_alias_db;

//----- (08091390) --------------------------------------------------------
_DWORD *__usercall add_alias2_isra_1@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v6; // edi
  _DWORD *result; // eax
  unsigned int v8; // ebp
  _DWORD *v9; // edi
  _BYTE *v10; // eax

  v6 = _gconv_modules_db;
LABEL_2:
  if ( v6 )
  {
    while ( 1 )
    {
      result = (_DWORD *)strcmp(a1, *(const char **)v6);
      if ( !result )
        break;
      if ( (int)result < 0 )
      {
        v6 = *(_DWORD *)(v6 + 20);
        goto LABEL_2;
      }
      v6 = *(_DWORD *)(v6 + 28);
      if ( !v6 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v8 = a3 - (_DWORD)a1;
    result = (_DWORD *)malloc(v8 + 8);
    v9 = result;
    if ( result )
    {
      v10 = memcpy((_BYTE *)result + 8, a1, v8);
      *v9 = v10;
      v9[1] = &v10[a2 - (_DWORD)a1];
      result = tsearch((int)v9, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
      if ( !result || v9 != (_DWORD *)*result )
        return (_DWORD *)free(v9);
    }
  }
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80F1310: using guessed type int _gconv_modules_db;
// 80F1318: using guessed type int _gconv_alias_db;

//----- (08091430) --------------------------------------------------------
void _gconv_get_path()
{
  bool v1; // zf
  int v2; // eax
  void *v3; // esp
  const char *v4; // ebx
  int v5; // edi
  char *v6; // eax
  char *v7; // edx
  char *v8; // esi
  char *v9; // eax
  char i; // al
  const char *j; // eax
  const char *v12; // ecx
  _BYTE *v13; // eax
  _DWORD *v14; // esi
  const char *v15; // edi
  _WORD *v16; // eax
  _BYTE *v17; // eax
  unsigned int v18; // edx
  bool v19; // cc
  char v20; // dl
  _DWORD *v21; // eax
  const char *k; // edx
  int v23; // edx
  int v24; // eax
  char v25[32]; // [esp-10h] [ebp-48h] BYREF
  int v26; // [esp+10h] [ebp-28h] BYREF
  int v27; // [esp+14h] [ebp-24h]
  _BYTE *v28; // [esp+18h] [ebp-20h]
  int v29; // [esp+1Ch] [ebp-1Ch]

  _ECX = 1;
  v1 = __readgsdword(0xCu) == 0;
  if ( !v1 )
    __asm { lock }
  __asm { cmpxchg ds:lock_10442, ecx }
  if ( v1 )
  {
    if ( !_gconv_path_elem )
    {
      if ( _gconv_path_envvar )
      {
        v2 = strlen((_BYTE *)_gconv_path_envvar);
        v29 = v2 + 18;
        v3 = alloca(v2 + 33);
        v4 = (const char *)&v26;
        strcpy((char *)mempcpy(&v26, (_BYTE *)_gconv_path_envvar, v2), ":/usr/lib32/gconv");
        v28 = getcwd(0, 0);
        v27 = strlen(v28);
        v26 = v27 + 1;
      }
      else
      {
        v4 = v25;
        strcpy(v25, "/usr/lib32/gconv");
        v26 = 1;
        v27 = 0;
        v28 = 0;
        v29 = 17;
      }
      v5 = 1;
      v6 = strchr(v4, 58);
      v7 = 0;
      v8 = v6;
      if ( v6 )
      {
        while ( 1 )
        {
          v5 += v8 != v7 + 1;
          v9 = strchr(v8 + 1, 58);
          if ( !v9 )
            break;
          v7 = v8;
          v8 = v9;
        }
        v23 = v26 * (v5 - 1);
        v24 = 8 * v5 + 8;
      }
      else
      {
        v23 = 0;
        v5 = 1;
        v24 = 16;
      }
      v26 = malloc(v29 + v5 + v24 + v23);
      if ( v26 )
      {
        _gconv_max_path_elem_len = 0;
        for ( i = *v4; *v4 == 58; i = *v4 )
          ++v4;
        if ( !i )
          goto LABEL_40;
        for ( j = v4 + 1; *j; ++j )
        {
          v12 = j + 1;
          if ( *j == 58 )
          {
            *j = 0;
            goto LABEL_25;
          }
        }
        v12 = j;
LABEL_25:
        if ( !v4 )
LABEL_40:
          _assert_fail("elem != ((void *)0)", "gconv_conf.c", 501, "__gconv_get_path");
        v29 = 0;
        v13 = (_BYTE *)(v26 + 8 * v5 + 8);
        v14 = (_DWORD *)v26;
        v15 = v12;
        do
        {
          v1 = *v4 == 47;
          *v14 = v13;
          if ( !v1 )
          {
            if ( !v28 )
              _assert_fail("cwd != ((void *)0)", "gconv_conf.c", 507, "__gconv_get_path");
            v16 = mempcpy(v13, v28, v27);
            *(_BYTE *)v16 = 47;
            v13 = (char *)v16 + 1;
          }
          v17 = (_BYTE *)stpcpy(v13, v4);
          if ( *(v17 - 1) != 47 )
            *v17++ = 47;
          v18 = (unsigned int)&v17[-*v14];
          v19 = v18 <= _gconv_max_path_elem_len;
          v14[1] = v18;
          if ( !v19 )
            _gconv_max_path_elem_len = v18;
          v20 = *v15;
          v4 = v15;
          *v17 = 0;
          v13 = v17 + 1;
          ++v29;
          if ( v20 == 58 )
          {
            do
              v20 = *++v4;
            while ( *v4 == 58 );
          }
          if ( !v20 )
            break;
          for ( k = v4 + 1; *k; ++k )
          {
            v15 = k + 1;
            if ( *k == 58 )
            {
              *k = 0;
              goto LABEL_46;
            }
          }
          v15 = k;
LABEL_46:
          v14 += 2;
        }
        while ( v4 );
        v21 = (_DWORD *)(v26 + 8 * v29);
        *v21 = 0;
        v21[1] = 0;
      }
      else
      {
        v26 = (int)&empty_path_elem;
      }
      _gconv_path_elem = v26;
      free(v28);
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --lock_10442 )
      L_unlock_872();
  }
  else
  {
    L_lock_862(0);
  }
}
// 80481F0: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80F0DFC: using guessed type int lock_10442;
// 80F131C: using guessed type int _gconv_path_envvar;
// 80F1320: using guessed type int _gconv_max_path_elem_len;
// 80F1324: using guessed type int _gconv_path_elem;

//----- (08091780) --------------------------------------------------------
unsigned int _gconv_read_conf()
{
  unsigned int v0; // ebx
  int v1; // eax
  void *v2; // esp
  int *v3; // eax
  int *v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // ebx
  char *v8; // eax
  char *v9; // edx
  char *v10; // ebx
  int v11; // eax
  int j; // ebx
  char *k; // edi
  int v14; // esi
  int v15; // ebx
  unsigned int result; // eax
  int v17; // eax
  char v18; // al
  int v19; // edx
  char *v20; // eax
  _BYTE *v21; // ecx
  int v22; // edx
  char v23; // al
  char *v24; // ecx
  int i; // edx
  _BYTE *v26; // eax
  char *v27; // ebx
  int v28; // edx
  char v29[4]; // [esp+10h] [ebp-58h] BYREF
  char *v30; // [esp+14h] [ebp-54h]
  void *s1; // [esp+18h] [ebp-50h]
  unsigned int v32; // [esp+1Ch] [ebp-4Ch]
  _BYTE *v33; // [esp+20h] [ebp-48h]
  int v34; // [esp+24h] [ebp-44h]
  unsigned int v35; // [esp+28h] [ebp-40h]
  char *v36; // [esp+2Ch] [ebp-3Ch]
  char *v37; // [esp+38h] [ebp-30h] BYREF
  int v38; // [esp+40h] [ebp-28h] BYREF
  int v39; // [esp+44h] [ebp-24h] BYREF
  char *s; // [esp+48h] [ebp-20h] BYREF
  unsigned int v41[7]; // [esp+4Ch] [ebp-1Ch] BYREF
  int savedregs; // [esp+68h] [ebp+0h] BYREF

  v38 = 0;
  v39 = 0;
  v0 = __readgsdword(0xFFFFFFE8);
  v32 = v0;
  if ( _gconv_load_cache((int)&savedregs) )
  {
    v1 = _gconv_path_elem;
    if ( !_gconv_path_elem )
    {
      _gconv_get_path();
      v1 = _gconv_path_elem;
    }
    v36 = *(char **)v1;
    if ( v36 )
    {
      v34 = 8;
      do
      {
        v35 = *(_DWORD *)(v1 + 4);
        v2 = alloca(v35 + 29);
        strcpy((char *)mempcpy(v29, v36, v35), "gconv-modules");
        v3 = fopen((int)v29, "rce");
        s = 0;
        v41[0] = 0;
        v4 = v3;
        if ( v3 )
        {
          v5 = *v3;
          BYTE1(v5) |= 0x80u;
          *v4 = v5;
          if ( (v5 & 0x10) == 0 )
          {
            do
            {
              getdelim(&s, v41, 10, v4);
              v7 = v6;
              if ( v6 < 0 )
                break;
              s1 = s;
              v8 = strchr(s, 35);
              v9 = (char *)s1;
              if ( v8 )
              {
                *v8 = 0;
              }
              else
              {
                v21 = (char *)s1 + v7 - 1;
                if ( *v21 == 10 )
                  *v21 = 0;
              }
              for ( ; (byte_80D0CC0[2 * *v9 + 1] & 0x20) != 0; ++v9 )
                ;
              if ( v8 != v9 && *v9 && (byte_80D0CC0[2 * *v9 + 1] & 0x20) == 0 )
              {
                v10 = v9;
                do
                  ++v10;
                while ( *v10 && (byte_80D0CC0[2 * *v10 + 1] & 0x20) == 0 );
                if ( v10 - v9 == 5 )
                {
                  if ( memcmp(v9, "alias", 5u) )
                  {
                    v11 = *v4;
                    continue;
                  }
                  while ( 1 )
                  {
                    v18 = *v10;
                    v19 = *v10;
                    if ( (byte_80D0CC0[2 * v19 + 1] & 0x20) == 0 )
                      break;
                    ++v10;
                  }
                  if ( v18 )
                  {
                    if ( (byte_80D0CC0[2 * v18 + 1] & 0x20) != 0 )
                    {
                      v20 = v10;
LABEL_48:
                      v22 = (int)(v20 + 1);
                      *v20 = 0;
                      v23 = v20[1];
                      v33 = (_BYTE *)v22;
                      v24 = (char *)v22;
                      for ( i = v23; (byte_80D0CC0[2 * i + 1] & 0x20) != 0; i = *v24 )
                        v23 = *++v24;
                      if ( v23 && (byte_80D0CC0[2 * i + 1] & 0x20) == 0 )
                      {
                        v26 = v33;
                        v30 = v10;
                        do
                        {
                          *v26 = dword_80D03C0[i];
                          LOBYTE(i) = v24[1];
                          ++v26;
                          if ( !(_BYTE)i )
                            break;
                          i = (char)i;
                          ++v24;
                        }
                        while ( (byte_80D0CC0[2 * (char)i + 1] & 0x20) == 0 );
                        v27 = v30;
                        if ( v33 != v26 )
                        {
                          v28 = (int)v33;
                          *v26 = 0;
                          add_alias2_isra_1(v27, v28, (int)(v26 + 1));
                          v11 = *v4;
                          continue;
                        }
                      }
                    }
                    else
                    {
                      v20 = v10;
                      while ( 1 )
                      {
                        *v20 = dword_80D03C0[v19];
                        LOBYTE(v19) = v20[1];
                        if ( !(_BYTE)v19 )
                          break;
                        v19 = (char)v19;
                        ++v20;
                        if ( (byte_80D0CC0[2 * (char)v19 + 1] & 0x20) != 0 )
                          goto LABEL_48;
                      }
                    }
                  }
                }
                else if ( v10 - v9 == 6 && !memcmp(v9, "module", 6u) )
                {
                  v17 = modcounter_10422++;
                  add_module(v10, v36, v35, (int)&v38, (int)&v39, v17);
                  v11 = *v4;
                  continue;
                }
              }
              v11 = *v4;
            }
            while ( (v11 & 0x10) == 0 );
          }
          free(s);
          fclose(v4);
        }
        v1 = _gconv_path_elem + v34;
        v34 += 8;
        v36 = *(char **)v1;
      }
      while ( v36 );
    }
    for ( j = 0; j != 12; ++j )
    {
      v37 = builtin_modules[8 * j];
      if ( !tfind((int)&v37, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare) )
        insert_module((int)&builtin_modules[8 * j], 0);
    }
    for ( k = "UCS4//"; ; k = v36 )
    {
      v14 = rawmemchr(k, 0) + 1;
      v15 = rawmemchr(v14, 0);
      v36 = (char *)(v15 + 1);
      add_alias2_isra_1(k, v14, v15 + 1);
      if ( !*(_BYTE *)(v15 + 1) )
        break;
    }
    result = v32;
    __writegsdword(0xFFFFFFE8, v32);
  }
  else
  {
    result = -24;
    __writegsdword(0xFFFFFFE8, v0);
  }
  return result;
}
// 8091878: variable 'v6' is possibly undefined
// 8048230: using guessed type int __cdecl rawmemchr(_DWORD, _DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80D03C0: using guessed type _DWORD dword_80D03C0[256];
// 80D0CC0: using guessed type _BYTE byte_80D0CC0[512];
// 80EFA40: using guessed type char *builtin_modules[2];
// 80F0E00: using guessed type int modcounter_10422;
// 80F1318: using guessed type int _gconv_alias_db;
// 80F1324: using guessed type int _gconv_path_elem;
// 8091780: using guessed type unsigned int var_1C[7];
// 8091780: using guessed type char anonymous_0[4];

//----- (08091B87) --------------------------------------------------------
void __usercall L_lock_862(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &lock_10442);
  JUMPOUT(0x8091458);
}
// 8091B92: control flows out of bounds to 8091458
// 80F0DFC: using guessed type int lock_10442;

//----- (08091B97) --------------------------------------------------------
void L_unlock_872()
{
  _lll_unlock_wake_private(&lock_10442);
  JUMPOUT(0x809147A);
}
// 8091BA2: control flows out of bounds to 809147A
// 80F0DFC: using guessed type int lock_10442;

//----- (08091BB0) --------------------------------------------------------
int __usercall _gconv_get_builtin_trans@<eax>(const char *a1@<eax>, _DWORD *a2@<edx>)
{
  int v3; // esi
  int (__cdecl *v5)(int, int, int, int, int, int, int, int); // eax
  int v6; // eax
  int result; // eax

  v3 = 0;
  while ( strcmp(a1, (&map_0)[4 * v3]) )
  {
    if ( ++v3 == 12 )
      _assert_fail("cnt < sizeof (map) / sizeof (map[0])", "gconv_builtin.c", 72, "__gconv_get_builtin_trans");
  }
  v5 = off_80CE024[4 * v3];
  a2[7] = 0;
  a2[8] = 0;
  *a2 = 0;
  a2[5] = v5;
  v6 = dword_80CE028[4 * v3];
  a2[1] = 0;
  a2[13] = 0;
  a2[6] = v6;
  a2[9] = SLOBYTE(dword_80CE028[4 * v3 + 1]);
  a2[10] = SBYTE1(dword_80CE028[4 * v3 + 1]);
  a2[11] = SBYTE2(dword_80CE028[4 * v3 + 1]);
  result = SHIBYTE(dword_80CE028[4 * v3 + 1]);
  a2[12] = result;
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80CE020: using guessed type char *map_0;
// 80CE024: using guessed type int (__cdecl *[47])(int, int, int, int, int, int, int, int);
// 80CE028: using guessed type _DWORD[46];

//----- (08091C70) --------------------------------------------------------
int __cdecl _gconv_btwoc_ascii(int a1, unsigned __int8 a2)
{
  int result; // eax

  result = -1;
  if ( (a2 & 0x80u) == 0 )
    return a2;
  return result;
}

//----- (08091C90) --------------------------------------------------------
int __usercall _gconv_transform_internal_ucs4@<eax>(
        int a1@<ebp>,
        long double a2@<st0>,
        int a3,
        int a4,
        unsigned int *a5,
        char *a6,
        unsigned int *a7,
        int a8,
        int a9,
        int a10)
{
  _BYTE *v10; // esi
  unsigned int *v11; // eax
  unsigned int v12; // ebx
  unsigned int v13; // ecx
  char *v14; // edx
  int *v15; // edi
  char v16; // al
  unsigned int v17; // ebp
  _BYTE *v18; // edi
  signed int v19; // edx
  char *v20; // eax
  int v21; // edx
  int i; // eax
  int *j; // ebx
  int v24; // eax
  unsigned int v25; // esi
  int v26; // edx
  char *v27; // eax
  char v28; // bl
  unsigned int v29; // eax
  _DWORD *v31; // eax
  int v32; // [esp+2Ch] [ebp-40h]
  int (__cdecl *v33)(int, int, int *, unsigned int, _DWORD, int, int, int); // [esp+30h] [ebp-3Ch]
  unsigned int v34; // [esp+34h] [ebp-38h]
  int v35; // [esp+38h] [ebp-34h]
  int v36; // [esp+3Ch] [ebp-30h]
  int v37[8]; // [esp+4Ch] [ebp-20h] BYREF

  v35 = a3 + 60;
  v36 = a4 + 36;
  v33 = 0;
  if ( (*(_BYTE *)(a4 + 8) & 1) == 0 )
  {
    v33 = *(int (__cdecl **)(int, int, int *, unsigned int, _DWORD, int, int, int))(a3 + 80);
    if ( *(_DWORD *)(a3 + 60) )
      v33 = (int (__cdecl *)(int, int, int *, unsigned int, _DWORD, int, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a3 + 80), 9));
  }
  if ( a9 )
  {
    if ( a7 )
      _assert_fail(
        a1,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        416,
        "__gconv_transform_internal_ucs4");
    v31 = *(_DWORD **)(a4 + 20);
    *v31 = 0;
    v31[1] = 0;
    v32 = 0;
    if ( (*(_BYTE *)(a4 + 8) & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v33);
      return v33(v35, v36, 0, 0, 0, a8, a9, a10);
    }
  }
  else
  {
    if ( a7 )
      v10 = (_BYTE *)*a7;
    else
      v10 = *(_BYTE **)a4;
    v34 = *(_DWORD *)(a4 + 4);
    if ( a10 && (v11 = *(unsigned int **)(a4 + 20), v12 = *v11, (v13 = *v11 & 7) != 0) )
    {
      if ( a7 )
        _assert_fail(
          a10,
          a2,
          (int)"outbufstart == ((void *)0)",
          (int)"../iconv/skeleton.c",
          559,
          "__gconv_transform_internal_ucs4");
      v14 = (char *)*a5;
      if ( (unsigned int)a6 > *a5 && v13 <= 3 )
      {
        v15 = *(int **)(a4 + 20);
        do
        {
          v16 = *v14++;
          *((_BYTE *)v15 + v13++ + 4) = v16;
          *a5 = (unsigned int)v14;
        }
        while ( v13 <= 3 && a6 > v14 );
        v11 = (unsigned int *)v15;
      }
      if ( v13 > 3 )
      {
        *v10 = *((_BYTE *)v11 + 7);
        v10[1] = *((_BYTE *)v11 + 6);
        v10[2] = *((_BYTE *)v11 + 5);
        v10[3] = *((_BYTE *)v11 + 4);
        v10 += 4;
        *v11 &= 0xFFFFFFF8;
        goto LABEL_18;
      }
      *v11 = v13 | v12 & 0xFFFFFFF8;
      return 7;
    }
    else
    {
      while ( 1 )
      {
LABEL_18:
        v17 = (unsigned int)v10;
        v18 = (_BYTE *)*a5;
        v19 = v34 - (_DWORD)v10;
        if ( (int)(v34 - (_DWORD)v10) > (int)&a6[-*a5] )
          v19 = (signed int)&a6[-*a5];
        v20 = (char *)*a5;
        v21 = v19 / 4;
        if ( v21 )
        {
          for ( i = 0; i != v21; ++i )
            *(_DWORD *)&v10[4 * i] = _byteswap_ulong(*(_DWORD *)&v18[4 * i]);
          v17 = (unsigned int)&v10[4 * v21];
          v20 = &v18[4 * v21];
        }
        v32 = 4;
        *a5 = (unsigned int)v20;
        if ( a6 != v20 )
          v32 = v34 < v17 + 4 ? 5 : 7;
        if ( a7 )
        {
          *a7 = v17;
          return v32;
        }
        for ( j = *(int **)(a4 + 32); j; j = (int *)j[4] )
        {
          if ( j[1] )
          {
            dl_mcount_wrapper_check(j[1]);
            ((void (__cdecl *)(int, _BYTE *, unsigned int, _BYTE *, unsigned int))j[1])(j[3], v18, *a5, v10, v17);
          }
        }
        ++*(_DWORD *)(a4 + 12);
        if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
          break;
        if ( v17 <= (unsigned int)v10 )
          goto LABEL_39;
        v37[0] = *(_DWORD *)a4;
        dl_mcount_wrapper_check((int)v33);
        v24 = v33(v35, v36, v37, v17, 0, a8, 0, a10);
        if ( v24 == 4 )
        {
          if ( v32 != 5 )
            goto LABEL_39;
        }
        else
        {
          if ( v37[0] != v17 )
            *a5 += v37[0] - v17;
          if ( v24 )
          {
            v32 = v24;
            goto LABEL_39;
          }
        }
        v10 = *(_BYTE **)a4;
      }
      *(_DWORD *)a4 = v17;
LABEL_39:
      if ( v32 == 7 && a10 )
      {
        v25 = *a5;
        if ( (int)&a6[-*a5] > 3 )
          _assert_fail(
            v17,
            a2,
            (int)"inend - *inptrp < 4",
            (int)"../iconv/skeleton.c",
            786,
            "__gconv_transform_internal_ucs4");
        v26 = 0;
        v27 = (char *)*a5;
        if ( (unsigned int)a6 <= v25 )
        {
          v29 = 0;
        }
        else
        {
          do
          {
            v28 = *v27++;
            *(_BYTE *)(*(_DWORD *)(a4 + 20) + v26++ + 4) = v28;
            *a5 = (unsigned int)v27;
          }
          while ( v27 != a6 );
          v29 = (unsigned int)&v27[-v25];
        }
        v32 = 7;
        **(_DWORD **)(a4 + 20) = v29 | **(_DWORD **)(a4 + 20) & 0xFFFFFFF8;
      }
    }
  }
  return v32;
}
// 8091C90: using guessed type int var_20[8];

//----- (080920C0) --------------------------------------------------------
int __usercall _gconv_transform_ucs4_internal@<eax>(
        int a1@<ebp>,
        long double a2@<st0>,
        int a3,
        int a4,
        unsigned int **a5,
        unsigned int *a6,
        int **a7,
        _DWORD *a8,
        int a9,
        int a10)
{
  int v10; // eax
  int *v11; // esi
  unsigned int v12; // edx
  int *v13; // edx
  int v14; // edx
  int v15; // ebp
  unsigned int *v16; // ecx
  unsigned int v17; // ebx
  char v18; // al
  int *v19; // ebx
  signed int v20; // edx
  int v21; // ebp
  unsigned int *v22; // edx
  int v23; // ecx
  int v24; // eax
  int *i; // ebp
  int v26; // eax
  int v27; // ecx
  unsigned int *v28; // eax
  unsigned int *v29; // ebp
  char v30; // dl
  int v31; // eax
  int result; // eax
  int v33; // eax
  _DWORD *v34; // eax
  unsigned int v35; // [esp+20h] [ebp-4Ch]
  int v36; // [esp+20h] [ebp-4Ch]
  char v37; // [esp+24h] [ebp-48h]
  int v38; // [esp+24h] [ebp-48h]
  unsigned int *v39; // [esp+28h] [ebp-44h]
  int (__cdecl *v40)(int, int, int **, int *, _DWORD, _DWORD *, int, int); // [esp+2Ch] [ebp-40h]
  unsigned int v41; // [esp+30h] [ebp-3Ch]
  int v42; // [esp+34h] [ebp-38h]
  int v43; // [esp+38h] [ebp-34h]
  int *v44; // [esp+3Ch] [ebp-30h]
  int v45; // [esp+48h] [ebp-24h] BYREF
  int *v46; // [esp+4Ch] [ebp-20h] BYREF

  v40 = 0;
  v42 = a3 + 60;
  v43 = a4 + 36;
  v10 = *(_DWORD *)(a4 + 8);
  if ( (v10 & 1) == 0 )
  {
    v40 = *(int (__cdecl **)(int, int, int **, int *, _DWORD, _DWORD *, int, int))(a3 + 80);
    if ( *(_DWORD *)(a3 + 60) )
      v40 = (int (__cdecl *)(int, int, int **, int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a3 + 80), 9));
  }
  if ( a9 )
  {
    if ( a7 )
      _assert_fail(
        a1,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        416,
        "__gconv_transform_ucs4_internal");
    v34 = *(_DWORD **)(a4 + 20);
    *v34 = 0;
    v34[1] = 0;
    v38 = 0;
    if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
      return v38;
    dl_mcount_wrapper_check((int)v40);
    return v40(v42, v43, 0, 0, 0, a8, a9, a10);
  }
  else
  {
    if ( a7 )
      v11 = *a7;
    else
      v11 = *(int **)a4;
    v12 = *(_DWORD *)(a4 + 4);
    v45 = 0;
    v41 = v12;
    v13 = &v45;
    if ( !a8 )
      v13 = 0;
    v44 = v13;
    if ( !a10 || (v14 = *(_DWORD *)(a4 + 20), v15 = *(_DWORD *)v14, (v35 = *(_DWORD *)v14 & 7) == 0) )
    {
      while ( 1 )
      {
LABEL_22:
        v19 = v11;
        v39 = *a5;
        v20 = (char *)a6 - (char *)*a5;
        if ( (int)(v41 - (_DWORD)v11) <= v20 )
          v20 = v41 - (_DWORD)v11;
        v21 = v20 / 4;
        if ( v20 / 4 )
        {
          v22 = *a5;
          v36 = v10 & 2;
          v23 = 0;
          while ( 1 )
          {
            v24 = _byteswap_ulong(*v22);
            if ( v24 < 0 )
            {
              if ( !v44 )
              {
                v19 = v11;
                v38 = 6;
                goto LABEL_31;
              }
              if ( !v36 )
              {
                *a5 = v22;
                v38 = 6;
                if ( !a7 )
                  goto LABEL_32;
                goto LABEL_57;
              }
              ++*v44;
            }
            else
            {
              *v19++ = v24;
            }
            ++v23;
            ++v22;
            if ( v21 == v23 )
              goto LABEL_29;
          }
        }
        v22 = *a5;
LABEL_29:
        *a5 = v22;
        v38 = 4;
        if ( a6 != v22 )
          v38 = v41 < (unsigned int)(v19 + 1) ? 5 : 7;
LABEL_31:
        if ( a7 )
        {
LABEL_57:
          result = v38;
          *a7 = v19;
          return result;
        }
LABEL_32:
        for ( i = *(int **)(a4 + 32); i; i = (int *)i[4] )
        {
          if ( i[1] )
          {
            dl_mcount_wrapper_check(i[1]);
            ((void (__cdecl *)(int, unsigned int *, unsigned int *, int *, int *))i[1])(i[3], v39, *a5, v11, v19);
          }
        }
        ++*(_DWORD *)(a4 + 12);
        if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
        {
          v33 = v45;
          *(_DWORD *)a4 = v19;
          *a8 += v33;
          goto LABEL_43;
        }
        if ( v19 <= v11 )
          goto LABEL_43;
        v46 = *(int **)a4;
        dl_mcount_wrapper_check((int)v40);
        v26 = v40(v42, v43, &v46, v19, 0, a8, 0, a10);
        if ( v26 == 4 )
        {
          if ( v38 != 5 )
            goto LABEL_43;
        }
        else if ( v46 == v19 )
        {
          if ( v26 )
            goto LABEL_62;
        }
        else
        {
          *a5 = (unsigned int *)((char *)*a5 + (char *)v46 - (char *)v19);
          if ( v26 )
          {
LABEL_62:
            v38 = v26;
LABEL_43:
            if ( v38 == 7 && a10 )
            {
              if ( (char *)a6 - (char *)*a5 > 3 )
                _assert_fail(
                  (int)i,
                  a2,
                  (int)"inend - *inptrp < 4",
                  (int)"../iconv/skeleton.c",
                  786,
                  "__gconv_transform_ucs4_internal");
              v27 = 0;
              v28 = *a5;
              if ( a6 <= *a5 )
              {
                v31 = 0;
              }
              else
              {
                v29 = *a5;
                do
                {
                  v30 = *(_BYTE *)v28;
                  v28 = (unsigned int *)((char *)v28 + 1);
                  *(_BYTE *)(*(_DWORD *)(a4 + 20) + v27++ + 4) = v30;
                  *a5 = v28;
                }
                while ( v28 != a6 );
                v31 = (char *)v28 - (char *)v29;
              }
              v38 = 7;
              **(_DWORD **)(a4 + 20) = v31 | **(_DWORD **)(a4 + 20) & 0xFFFFFFF8;
            }
            return v38;
          }
        }
        v11 = *(int **)a4;
        v10 = *(_DWORD *)(a4 + 8);
      }
    }
    if ( a7 )
      _assert_fail(
        v15,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        559,
        "__gconv_transform_ucs4_internal");
    v16 = *a5;
    v17 = *(_DWORD *)v14 & 7;
    if ( a6 > *a5 && v35 <= 3 )
    {
      v37 = v10;
      do
      {
        v18 = *(_BYTE *)v16;
        v16 = (unsigned int *)((char *)v16 + 1);
        *(_BYTE *)(v14 + v17++ + 4) = v18;
        *a5 = v16;
      }
      while ( v17 <= 3 && a6 > v16 );
      LOBYTE(v10) = v37;
    }
    if ( v17 > 3 )
    {
      if ( *(_BYTE *)(v14 + 4) > 0x80u )
      {
        if ( (v10 & 2) == 0 )
        {
          result = 6;
          *a5 = (unsigned int *)((char *)v16 + v35 - v17);
          return result;
        }
      }
      else
      {
        *(_BYTE *)v11 = *(_BYTE *)(v14 + 7);
        *((_BYTE *)v11 + 1) = *(_BYTE *)(v14 + 6);
        *((_BYTE *)v11 + 2) = *(_BYTE *)(v14 + 5);
        *((_BYTE *)v11 + 3) = *(_BYTE *)(v14 + 4);
        v15 = *(_DWORD *)v14;
        ++v11;
      }
      *(_DWORD *)v14 = v15 & 0xFFFFFFF8;
      v10 = *(_DWORD *)(a4 + 8);
      goto LABEL_22;
    }
    *(_DWORD *)v14 = v17 | v15 & 0xFFFFFFF8;
    return 7;
  }
}

//----- (080925F0) --------------------------------------------------------
int __usercall _gconv_transform_internal_ucs4le@<eax>(
        int a1@<ebp>,
        long double a2@<st0>,
        int a3,
        int a4,
        unsigned int *a5,
        char *a6,
        _BYTE **a7,
        int a8,
        int a9,
        int a10)
{
  _BYTE *v10; // edi
  unsigned int *v11; // eax
  unsigned int v12; // ebx
  unsigned int v13; // ecx
  _BYTE *v14; // ebp
  int v15; // eax
  unsigned int v16; // eax
  _WORD *v17; // eax
  _WORD *v18; // esi
  int *i; // ebx
  int v20; // eax
  unsigned int v21; // esi
  int v22; // edx
  char *v23; // eax
  char v24; // bl
  unsigned int v25; // eax
  char *v27; // edx
  int *v28; // esi
  char v29; // al
  _DWORD *v30; // eax
  int v31; // [esp+2Ch] [ebp-40h]
  int (__cdecl *v32)(int, int, int *, _WORD *, _DWORD, int, int, int); // [esp+30h] [ebp-3Ch]
  unsigned int v33; // [esp+34h] [ebp-38h]
  int v34; // [esp+38h] [ebp-34h]
  int v35; // [esp+3Ch] [ebp-30h]
  int v36[8]; // [esp+4Ch] [ebp-20h] BYREF

  v34 = a3 + 60;
  v35 = a4 + 36;
  v32 = 0;
  if ( (*(_BYTE *)(a4 + 8) & 1) == 0 )
  {
    v32 = *(int (__cdecl **)(int, int, int *, _WORD *, _DWORD, int, int, int))(a3 + 80);
    if ( *(_DWORD *)(a3 + 60) )
      v32 = (int (__cdecl *)(int, int, int *, _WORD *, _DWORD, int, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a3 + 80), 9));
  }
  if ( a9 )
  {
    if ( a7 )
      _assert_fail(
        a1,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        416,
        "__gconv_transform_internal_ucs4le");
    v30 = *(_DWORD **)(a4 + 20);
    *v30 = 0;
    v30[1] = 0;
    v31 = 0;
    if ( (*(_BYTE *)(a4 + 8) & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v32);
      return v32(v34, v35, 0, 0, 0, a8, a9, a10);
    }
  }
  else
  {
    if ( a7 )
      v10 = *a7;
    else
      v10 = *(_BYTE **)a4;
    v33 = *(_DWORD *)(a4 + 4);
    if ( a10 && (v11 = *(unsigned int **)(a4 + 20), v12 = *v11, (v13 = *v11 & 7) != 0) )
    {
      if ( a7 )
        _assert_fail(
          a1,
          a2,
          (int)"outbufstart == ((void *)0)",
          (int)"../iconv/skeleton.c",
          559,
          "__gconv_transform_internal_ucs4le");
      v27 = (char *)*a5;
      if ( (unsigned int)a6 > *a5 && v13 <= 3 )
      {
        v28 = *(int **)(a4 + 20);
        do
        {
          v29 = *v27++;
          *((_BYTE *)v28 + v13++ + 4) = v29;
          *a5 = (unsigned int)v27;
        }
        while ( v13 <= 3 && a6 > v27 );
        v11 = (unsigned int *)v28;
      }
      if ( v13 > 3 )
      {
        *v10 = *((_BYTE *)v11 + 4);
        v10[1] = *((_BYTE *)v11 + 5);
        v10[2] = *((_BYTE *)v11 + 6);
        v10[3] = *((_BYTE *)v11 + 7);
        v10 += 4;
        *v11 &= 0xFFFFFFF8;
        goto LABEL_9;
      }
      *v11 = v13 | v12 & 0xFFFFFFF8;
      return 7;
    }
    else
    {
      while ( 1 )
      {
LABEL_9:
        v14 = (_BYTE *)*a5;
        v15 = (int)&a6[-*a5];
        if ( (int)(v33 - (_DWORD)v10) <= v15 )
          v15 = v33 - (_DWORD)v10;
        v16 = (v15 + (v15 < 0 ? 3 : 0)) & 0xFFFFFFFC;
        *a5 = (unsigned int)&v14[v16];
        v17 = mempcpy(v10, v14, v16);
        v31 = 4;
        v18 = v17;
        if ( a6 != (char *)*a5 )
          v31 = v33 < (unsigned int)(v17 + 2) ? 5 : 7;
        if ( a7 )
        {
          *a7 = v17;
          return v31;
        }
        for ( i = *(int **)(a4 + 32); i; i = (int *)i[4] )
        {
          if ( i[1] )
          {
            dl_mcount_wrapper_check(i[1]);
            ((void (__cdecl *)(int, _BYTE *, unsigned int, _BYTE *, _WORD *))i[1])(i[3], v14, *a5, v10, v18);
          }
        }
        ++*(_DWORD *)(a4 + 12);
        if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
          break;
        if ( v10 >= (_BYTE *)v18 )
          goto LABEL_26;
        v36[0] = *(_DWORD *)a4;
        dl_mcount_wrapper_check((int)v32);
        v20 = v32(v34, v35, v36, v18, 0, a8, 0, a10);
        if ( v20 == 4 )
        {
          if ( v31 != 5 )
            goto LABEL_26;
        }
        else
        {
          if ( (_WORD *)v36[0] != v18 )
            *a5 += v36[0] - (_DWORD)v18;
          if ( v20 )
          {
            v31 = v20;
            goto LABEL_26;
          }
        }
        v10 = *(_BYTE **)a4;
      }
      *(_DWORD *)a4 = v18;
LABEL_26:
      if ( v31 == 7 && a10 )
      {
        v21 = *a5;
        if ( (int)&a6[-*a5] > 3 )
          _assert_fail(
            (int)v14,
            a2,
            (int)"inend - *inptrp < 4",
            (int)"../iconv/skeleton.c",
            786,
            "__gconv_transform_internal_ucs4le");
        v22 = 0;
        v23 = (char *)*a5;
        if ( (unsigned int)a6 <= v21 )
        {
          v25 = 0;
        }
        else
        {
          do
          {
            v24 = *v23++;
            *(_BYTE *)(*(_DWORD *)(a4 + 20) + v22++ + 4) = v24;
            *a5 = (unsigned int)v23;
          }
          while ( v23 != a6 );
          v25 = (unsigned int)&v23[-v21];
        }
        v31 = 7;
        **(_DWORD **)(a4 + 20) = v25 | **(_DWORD **)(a4 + 20) & 0xFFFFFFF8;
      }
    }
  }
  return v31;
}
// 80925F0: using guessed type int var_20[8];

//----- (08092A30) --------------------------------------------------------
int __usercall _gconv_transform_ucs4le_internal@<eax>(
        int a1@<ebp>,
        long double a2@<st0>,
        int a3,
        int a4,
        char **a5,
        unsigned int a6,
        _BYTE **a7,
        _DWORD *a8,
        int a9,
        int a10)
{
  int v10; // ecx
  _BYTE *v11; // esi
  int *v12; // eax
  unsigned int v13; // edx
  int v14; // eax
  int v15; // ebp
  unsigned int v16; // ebx
  char *v17; // edx
  char v18; // cl
  _DWORD *v19; // ebx
  int v20; // eax
  int v21; // ebp
  char *v22; // eax
  int v23; // ebp
  int i; // edx
  int *j; // ebp
  int v26; // eax
  int v27; // ecx
  char *v28; // eax
  char *v29; // ebp
  char v30; // dl
  unsigned int v31; // eax
  int result; // eax
  int v33; // eax
  _DWORD *v34; // eax
  char v35; // [esp+20h] [ebp-4Ch]
  char *v36; // [esp+24h] [ebp-48h]
  int (__cdecl *v37)(int, int, int *, _DWORD *, _DWORD, _DWORD *, int, int); // [esp+28h] [ebp-44h]
  int v38; // [esp+2Ch] [ebp-40h]
  unsigned int v39; // [esp+30h] [ebp-3Ch]
  int v40; // [esp+34h] [ebp-38h]
  int v41; // [esp+38h] [ebp-34h]
  int *v42; // [esp+3Ch] [ebp-30h]
  int v43; // [esp+48h] [ebp-24h] BYREF
  int v44[8]; // [esp+4Ch] [ebp-20h] BYREF

  v40 = a3 + 60;
  v41 = a4 + 36;
  v37 = 0;
  v10 = *(_DWORD *)(a4 + 8);
  if ( (v10 & 1) == 0 )
  {
    v37 = *(int (__cdecl **)(int, int, int *, _DWORD *, _DWORD, _DWORD *, int, int))(a3 + 80);
    if ( *(_DWORD *)(a3 + 60) )
      v37 = (int (__cdecl *)(int, int, int *, _DWORD *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a3 + 80), 9));
  }
  if ( a9 )
  {
    if ( a7 )
      _assert_fail(
        a1,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        416,
        "__gconv_transform_ucs4le_internal");
    v34 = *(_DWORD **)(a4 + 20);
    *v34 = 0;
    v34[1] = 0;
    v38 = 0;
    if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
      return v38;
    dl_mcount_wrapper_check((int)v37);
    return v37(v40, v41, 0, 0, 0, a8, a9, a10);
  }
  else
  {
    if ( a7 )
      v11 = *a7;
    else
      v11 = *(_BYTE **)a4;
    v12 = &v43;
    v13 = *(_DWORD *)(a4 + 4);
    if ( !a8 )
      v12 = 0;
    v43 = 0;
    v39 = v13;
    v42 = v12;
    if ( !a10 || (v14 = *(_DWORD *)(a4 + 20), v15 = *(_DWORD *)v14, (v16 = *(_DWORD *)v14 & 7) == 0) )
    {
      while ( 1 )
      {
LABEL_22:
        v19 = v11;
        v36 = *a5;
        v20 = a6 - (_DWORD)*a5;
        if ( (int)(v39 - (_DWORD)v11) <= v20 )
          v20 = v39 - (_DWORD)v11;
        v21 = v20 + 3;
        if ( v20 >= 0 )
          v21 = v20;
        v22 = *a5;
        v23 = v21 >> 2;
        if ( v23 )
        {
          for ( i = 0; v23 != i; ++i )
          {
            if ( *(int *)v22 < 0 )
            {
              if ( !v42 || (v10 & 2) == 0 )
              {
                v19 = v11;
                v38 = 6;
                goto LABEL_35;
              }
              ++*v42;
            }
            else
            {
              *v19++ = *(_DWORD *)v22;
            }
            v22 += 4;
          }
        }
        *a5 = v22;
        if ( (char *)a6 == v22 )
        {
          v38 = 4;
          if ( a7 )
            goto LABEL_57;
        }
        else
        {
          v38 = 7;
          if ( a6 >= (unsigned int)(v22 + 4) )
          {
            if ( v39 >= (unsigned int)(v19 + 1) )
              _assert_fail(v23, a2, (int)"*outptrp + 4 > outend", (int)"gconv_simple.c", 655, "ucs4le_internal_loop");
            v38 = 5;
          }
LABEL_35:
          if ( a7 )
          {
LABEL_57:
            result = v38;
            *a7 = v19;
            return result;
          }
        }
        for ( j = *(int **)(a4 + 32); j; j = (int *)j[4] )
        {
          if ( j[1] )
          {
            dl_mcount_wrapper_check(j[1]);
            ((void (__cdecl *)(int, char *, char *, _BYTE *, _DWORD *))j[1])(j[3], v36, *a5, v11, v19);
          }
        }
        ++*(_DWORD *)(a4 + 12);
        if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
        {
          v33 = v43;
          *(_DWORD *)a4 = v19;
          *a8 += v33;
          goto LABEL_47;
        }
        if ( v19 <= (_DWORD *)v11 )
          goto LABEL_47;
        v44[0] = *(_DWORD *)a4;
        dl_mcount_wrapper_check((int)v37);
        v26 = v37(v40, v41, v44, v19, 0, a8, 0, a10);
        if ( v26 == 4 )
        {
          if ( v38 != 5 )
            goto LABEL_47;
        }
        else if ( (_DWORD *)v44[0] == v19 )
        {
          if ( v26 )
            goto LABEL_67;
        }
        else
        {
          *a5 += v44[0] - (_DWORD)v19;
          if ( v26 )
          {
LABEL_67:
            v38 = v26;
LABEL_47:
            if ( v38 == 7 && a10 )
            {
              if ( (int)(a6 - (_DWORD)*a5) > 3 )
                _assert_fail(
                  a10,
                  a2,
                  (int)"inend - *inptrp < 4",
                  (int)"../iconv/skeleton.c",
                  786,
                  "__gconv_transform_ucs4le_internal");
              v27 = 0;
              v28 = *a5;
              if ( a6 <= (unsigned int)*a5 )
              {
                v31 = 0;
              }
              else
              {
                v29 = *a5;
                do
                {
                  v30 = *v28++;
                  *(_BYTE *)(*(_DWORD *)(a4 + 20) + v27++ + 4) = v30;
                  *a5 = v28;
                }
                while ( v28 != (char *)a6 );
                v31 = v28 - v29;
              }
              v38 = 7;
              **(_DWORD **)(a4 + 20) = v31 | **(_DWORD **)(a4 + 20) & 0xFFFFFFF8;
            }
            return v38;
          }
        }
        v11 = *(_BYTE **)a4;
        v10 = *(_DWORD *)(a4 + 8);
      }
    }
    if ( a7 )
      _assert_fail(
        v15,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        559,
        "__gconv_transform_ucs4le_internal");
    v17 = *a5;
    if ( a6 > (unsigned int)*a5 && v16 <= 3 )
    {
      v35 = v10;
      do
      {
        v18 = *v17++;
        *(_BYTE *)(v14 + v16++ + 4) = v18;
        *a5 = v17;
      }
      while ( v16 <= 3 && a6 > (unsigned int)v17 );
      LOBYTE(v10) = v35;
    }
    if ( v16 > 3 )
    {
      if ( *(_BYTE *)(v14 + 7) > 0x80u )
      {
        if ( (v10 & 2) == 0 )
          return 6;
      }
      else
      {
        *v11 = *(_BYTE *)(v14 + 4);
        v11[1] = *(_BYTE *)(v14 + 5);
        v11[2] = *(_BYTE *)(v14 + 6);
        v11[3] = *(_BYTE *)(v14 + 7);
        v15 = *(_DWORD *)v14;
        v11 += 4;
      }
      *(_DWORD *)v14 = v15 & 0xFFFFFFF8;
      v10 = *(_DWORD *)(a4 + 8);
      goto LABEL_22;
    }
    *(_DWORD *)v14 = v16 | v15 & 0xFFFFFFF8;
    return 7;
  }
}
// 8092A30: using guessed type int var_20[8];

//----- (08092F70) --------------------------------------------------------
int __usercall _gconv_transform_ascii_internal@<eax>(
        long double a1@<st0>,
        int a2,
        unsigned int *a3,
        _DWORD *a4,
        int a5,
        unsigned int *a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  unsigned int v9; // ecx
  int *v10; // eax
  _DWORD *v11; // edx
  _DWORD *v12; // ebx
  int v13; // eax
  char v14; // cl
  int v15; // edi
  int *i; // edi
  int result; // eax
  _DWORD *v18; // eax
  int v19; // eax
  unsigned int v20; // [esp+2Ch] [ebp-50h]
  unsigned int v21; // [esp+30h] [ebp-4Ch]
  int v22; // [esp+34h] [ebp-48h]
  int (__cdecl *v23)(int, _DWORD *, int *, _DWORD *, _DWORD, _DWORD *, int, int); // [esp+38h] [ebp-44h]
  int v24; // [esp+3Ch] [ebp-40h]
  int v25; // [esp+40h] [ebp-3Ch]
  _DWORD *v26; // [esp+44h] [ebp-38h]
  int v27; // [esp+48h] [ebp-34h]
  int *v28; // [esp+4Ch] [ebp-30h]
  int v29; // [esp+58h] [ebp-24h] BYREF
  int v30[8]; // [esp+5Ch] [ebp-20h] BYREF

  v25 = a2 + 60;
  v26 = a3 + 9;
  v23 = 0;
  v9 = a3[2];
  if ( (v9 & 1) == 0 )
  {
    v23 = *(int (__cdecl **)(int, _DWORD *, int *, _DWORD *, _DWORD, _DWORD *, int, int))(a2 + 80);
    if ( *(_DWORD *)(a2 + 60) )
      v23 = (int (__cdecl *)(int, _DWORD *, int *, _DWORD *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a2 + 80), 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(
        (int)a6,
        a1,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        416,
        "__gconv_transform_ascii_internal");
    v18 = (_DWORD *)a3[5];
    *v18 = 0;
    v18[1] = 0;
    v24 = 0;
    if ( (a3[2] & 1) != 0 )
    {
      return v24;
    }
    else
    {
      dl_mcount_wrapper_check((int)v23);
      return v23(v25, v26, 0, 0, 0, a7, a8, a9);
    }
  }
  else
  {
    if ( a6 )
      v21 = *a6;
    else
      v21 = *a3;
    v10 = &v29;
    v29 = 0;
    if ( !a7 )
      v10 = 0;
    v20 = a3[1];
    v28 = v10;
    while ( 1 )
    {
      v22 = *a4;
      if ( *a4 == a5 )
      {
        v15 = a5;
        v12 = (_DWORD *)v21;
        v24 = 4;
      }
      else
      {
        v11 = (_DWORD *)(v21 + 4);
        if ( v20 < v21 + 4 )
        {
          v15 = *a4;
          v12 = (_DWORD *)v21;
          v24 = 5;
        }
        else
        {
          v12 = (_DWORD *)v21;
          v24 = 4;
          v27 = v9 & 2;
          v13 = v22 + 1;
          do
          {
            v14 = *(_BYTE *)(v13 - 1);
            v15 = v13;
            if ( v14 < 0 )
            {
              if ( !v28 || !v27 )
              {
                v15 = v13 - 1;
                v24 = 6;
                goto LABEL_17;
              }
              v24 = 6;
              ++*v28;
            }
            else
            {
              *v12 = (unsigned __int8)v14;
              v12 = v11;
            }
            if ( a5 == v13 )
              goto LABEL_17;
            v11 = v12 + 1;
            ++v13;
          }
          while ( v20 >= (unsigned int)(v12 + 1) );
          v24 = 5;
        }
      }
LABEL_17:
      *a4 = v15;
      if ( a6 )
      {
        result = v24;
        *a6 = (unsigned int)v12;
        return result;
      }
      for ( i = (int *)a3[8]; i; i = (int *)i[4] )
      {
        if ( i[1] )
        {
          dl_mcount_wrapper_check(i[1]);
          ((void (__cdecl *)(int, int, _DWORD, unsigned int, _DWORD *))i[1])(i[3], v22, *a4, v21, v12);
        }
      }
      ++a3[3];
      if ( (a3[2] & 1) != 0 )
        break;
      if ( (unsigned int)v12 <= v21 )
        return v24;
      v30[0] = *a3;
      dl_mcount_wrapper_check((int)v23);
      result = v23(v25, v26, v30, v12, 0, a7, 0, a9);
      if ( result == 4 )
      {
        if ( v24 != 5 )
          return v24;
      }
      else
      {
        if ( (_DWORD *)v30[0] != v12 )
          *a4 -= ((int)v12 - v30[0]) / 4;
        if ( result )
          return result;
      }
      v21 = *a3;
      v9 = a3[2];
    }
    v19 = v29;
    *a3 = (unsigned int)v12;
    *a7 += v19;
    return v24;
  }
}
// 8092F70: using guessed type int var_20[8];

//----- (08093380) --------------------------------------------------------
int __usercall _gconv_transform_internal_ascii@<eax>(
        int a1@<ebp>,
        long double a2@<st0>,
        int a3,
        int a4,
        int *a5,
        unsigned int a6,
        unsigned int **a7,
        _DWORD *a8,
        int a9,
        int a10)
{
  unsigned int v10; // esi
  int v11; // edi
  int *v12; // eax
  unsigned int v13; // ebp
  unsigned int *v14; // eax
  unsigned int *v15; // ebx
  unsigned int v16; // edx
  int *i; // edi
  int v18; // eax
  unsigned int v19; // edx
  int v20; // ecx
  char *v21; // eax
  char v22; // bl
  unsigned int v23; // eax
  int result; // eax
  int *v25; // edi
  int v26; // eax
  int *v27; // ecx
  int v28; // eax
  unsigned int v29; // ebx
  char *v30; // edx
  char v31; // al
  char *v32; // edx
  unsigned int *v33; // eax
  int v34; // eax
  int v35; // eax
  _DWORD *v36; // eax
  int v37; // eax
  int *v38; // ebx
  char *v39; // esi
  int v40; // eax
  char v41; // al
  int v42; // eax
  signed int v43; // ebx
  unsigned int *v44; // eax
  char v45; // bl
  unsigned int v46; // [esp+24h] [ebp-58h]
  int *v47; // [esp+28h] [ebp-54h]
  int v48; // [esp+2Ch] [ebp-50h]
  int v49; // [esp+2Ch] [ebp-50h]
  unsigned int *v50; // [esp+30h] [ebp-4Ch]
  int v51; // [esp+34h] [ebp-48h]
  int v52; // [esp+38h] [ebp-44h]
  int v53; // [esp+38h] [ebp-44h]
  int (__cdecl *v54)(int, int, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int); // [esp+3Ch] [ebp-40h]
  int v55; // [esp+40h] [ebp-3Ch]
  int v56; // [esp+44h] [ebp-38h]
  int *v57; // [esp+48h] [ebp-34h]
  int v58; // [esp+50h] [ebp-2Ch] BYREF
  unsigned int *v59; // [esp+54h] [ebp-28h] BYREF
  unsigned int *v60; // [esp+58h] [ebp-24h] BYREF
  unsigned int v61; // [esp+5Ch] [ebp-20h] BYREF
  char v62[28]; // [esp+60h] [ebp-1Ch] BYREF

  v10 = a6;
  v55 = a3 + 60;
  v56 = a4 + 36;
  v54 = 0;
  v11 = *(_DWORD *)(a4 + 8);
  if ( (v11 & 1) == 0 )
  {
    a1 = *(_DWORD *)(a3 + 60);
    v54 = *(int (__cdecl **)(int, int, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int))(a3 + 80);
    if ( a1 )
      v54 = (int (__cdecl *)(int, int, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a3 + 80), 9));
  }
  if ( a9 )
  {
    if ( a7 )
      _assert_fail(
        a1,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        416,
        "__gconv_transform_internal_ascii");
    v36 = *(_DWORD **)(a4 + 20);
    *v36 = 0;
    v36[1] = 0;
    v51 = 0;
    if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
      return v51;
    dl_mcount_wrapper_check((int)v54);
    return v54(v55, v56, 0, 0, 0, a8, a9, a10);
  }
  if ( a7 )
    v50 = *a7;
  else
    v50 = *(unsigned int **)a4;
  v12 = &v58;
  v58 = 0;
  v13 = *(_DWORD *)(a4 + 4);
  if ( !a8 )
    v12 = 0;
  v57 = v12;
  if ( !a10 )
  {
    v48 = *a5;
    goto LABEL_11;
  }
  v27 = *(int **)(a4 + 20);
  v53 = *v27;
  v49 = *v27 & 7;
  if ( !v49 )
  {
    v48 = *a5;
    goto LABEL_11;
  }
  if ( a7 )
    _assert_fail(
      v13,
      a2,
      (int)"outbufstart == ((void *)0)",
      (int)"../iconv/skeleton.c",
      559,
      "__gconv_transform_internal_ascii");
  v28 = 0;
  v59 = (unsigned int *)*a5;
  v60 = v50;
  v29 = v49;
  v46 = (unsigned int)v59;
  do
  {
    v62[v28 - 4] = *((_BYTE *)v27 + v28 + 4);
    ++v28;
  }
  while ( v28 != v49 );
  v30 = (char *)v46;
  if ( a6 < v46 - v28 + 4 )
  {
    v51 = 7;
    *a5 = a6;
    if ( a6 <= v46 )
      return v51;
    do
    {
      v41 = *v30++;
      *((_BYTE *)v27 + v29++ + 4) = v41;
      v59 = (unsigned int *)v30;
    }
    while ( v30 != (char *)a6 );
    return 7;
  }
  v51 = 5;
  if ( (unsigned int)v50 >= v13 )
    return v51;
  do
  {
    v31 = *v30++;
    v59 = (unsigned int *)v30;
    v62[v29++ - 4] = v31;
  }
  while ( a6 > (unsigned int)v30 && v29 <= 3 );
  v59 = &v61;
  v32 = &v62[v29 - 4];
  if ( v61 > 0x7F )
  {
    if ( v61 >> 7 == 7168 )
    {
      v59 = (unsigned int *)v62;
      v33 = (unsigned int *)v62;
      goto LABEL_62;
    }
    if ( !v57 )
      return 6;
    v38 = *(int **)(a4 + 32);
    if ( v38 )
    {
      v39 = v32;
      while ( 1 )
      {
        v47 = v27;
        dl_mcount_wrapper_check(*v38);
        v40 = ((int (__cdecl *)(int, int, int, int, unsigned int **, char *, unsigned int **, int *))*v38)(
                a3,
                a4,
                v38[3],
                *a5,
                &v59,
                v39,
                &v60,
                v57);
        v27 = v47;
        if ( v40 != 6 )
          break;
        v38 = (int *)v38[4];
        if ( !v38 )
        {
          v32 = v39;
          v33 = v59;
          v10 = a6;
          goto LABEL_92;
        }
      }
      v51 = v40;
      v32 = v39;
      v33 = v59;
      v10 = a6;
    }
    else
    {
      v33 = &v61;
LABEL_92:
      v51 = 6;
      if ( (v11 & 2) != 0 )
      {
        v59 = ++v33;
        ++*v57;
      }
    }
  }
  else
  {
    v51 = 0;
    *(_BYTE *)v50 = v61;
    v60 = (unsigned int *)((char *)v50 + 1);
    v33 = ++v59;
  }
  if ( v33 != &v61 )
  {
    v53 = *v27;
    v49 = *v27 & 7;
LABEL_62:
    v34 = (char *)v33 - (char *)&v61;
    if ( v34 <= v49 )
      _assert_fail(
        v13,
        a2,
        (int)"inptr - bytebuf > (state->__count & 7)",
        (int)"../iconv/loop.c",
        448,
        "internal_ascii_loop_single");
    v50 = v60;
    v35 = *a5 + v34 - v49;
    *a5 = v35;
    v48 = v35;
    *v27 = v53 & 0xFFFFFFF8;
    v11 = *(_DWORD *)(a4 + 8);
    goto LABEL_11;
  }
  if ( v51 == 7 )
  {
    if ( v32 == v62 )
      _assert_fail(v13, a2, (int)"inend != &bytebuf[4]", (int)"../iconv/loop.c", 466, "internal_ascii_loop_single");
    v42 = v32 - (char *)v33;
    v43 = *v27 & 0xFFFFFFF8;
    *a5 += v42 - (*v27 & 7);
    if ( v42 <= v43 )
      _assert_fail(
        v13,
        a2,
        (int)"inend - inptr > (state->__count & ~7)",
        (int)"../iconv/loop.c",
        476,
        "internal_ascii_loop_single");
    if ( v42 > 7 )
      _assert_fail(v13, a2, (int)"inend - inptr <= 7", (int)"../iconv/loop.c", 477, "internal_ascii_loop_single");
    *v27 = v43 | v42;
    v44 = v59;
    if ( v32 <= (char *)v59 )
      return v51;
    do
    {
      v45 = *(_BYTE *)v44;
      v44 = (unsigned int *)((char *)v44 + 1);
      *((_BYTE *)v27 + 4) = v45;
      v27 = (int *)((char *)v27 + 1);
      v59 = v44;
    }
    while ( v44 != (unsigned int *)v32 );
    return 7;
  }
  if ( v51 )
    return v51;
  v11 = *(_DWORD *)(a4 + 8);
  v48 = *a5;
LABEL_11:
  while ( 2 )
  {
    v51 = 4;
    v52 = v11 & 2;
    v60 = (unsigned int *)v48;
    v14 = (unsigned int *)v48;
    v59 = v50;
    v15 = v50;
LABEL_16:
    while ( (unsigned int *)v10 != v14 )
    {
      if ( v10 < (unsigned int)(v14 + 1) )
      {
        v51 = 7;
        break;
      }
      if ( v13 <= (unsigned int)v15 )
      {
        v51 = 5;
        break;
      }
      v16 = *v14;
      if ( *v14 > 0x7F )
      {
        if ( v16 >> 7 == 7168 )
        {
          v60 = ++v14;
        }
        else
        {
          if ( !v57 )
            goto LABEL_69;
          v25 = *(int **)(a4 + 32);
          if ( v25 )
          {
            while ( 1 )
            {
              dl_mcount_wrapper_check(*v25);
              v26 = ((int (__cdecl *)(int, int, int, int, unsigned int **, unsigned int, unsigned int **, int *))*v25)(
                      a3,
                      a4,
                      v25[3],
                      *a5,
                      &v60,
                      v10,
                      &v59,
                      v57);
              if ( v26 != 6 )
                break;
              v25 = (int *)v25[4];
              if ( !v25 )
              {
                v14 = v60;
                v15 = v59;
                goto LABEL_67;
              }
            }
            v51 = v26;
            if ( v26 != 5 )
            {
              v15 = v59;
              v14 = v60;
              goto LABEL_16;
            }
            v14 = v60;
            v15 = v59;
            break;
          }
LABEL_67:
          if ( !v52 )
          {
LABEL_69:
            v51 = 6;
            break;
          }
          v60 = ++v14;
          v51 = 6;
          ++*v57;
        }
      }
      else
      {
        *(_BYTE *)v15 = v16;
        v15 = (unsigned int *)((char *)v15 + 1);
        v59 = v15;
        v14 = ++v60;
      }
    }
    *a5 = (int)v14;
    if ( !a7 )
    {
      for ( i = *(int **)(a4 + 32); i; i = (int *)i[4] )
      {
        if ( i[1] )
        {
          dl_mcount_wrapper_check(i[1]);
          ((void (__cdecl *)(int, int, int, unsigned int *, unsigned int *))i[1])(i[3], v48, *a5, v50, v15);
        }
      }
      ++*(_DWORD *)(a4 + 12);
      if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
      {
        v13 = (unsigned int)a8;
        v37 = v58;
        *(_DWORD *)a4 = v15;
        *a8 += v37;
      }
      else
      {
        if ( v50 < v15 )
        {
          v59 = *(unsigned int **)a4;
          dl_mcount_wrapper_check((int)v54);
          v18 = v54(v55, v56, &v59, v15, 0, a8, 0, a10);
          if ( v18 == 4 )
          {
            if ( v51 == 5 || !v51 )
            {
LABEL_28:
              v50 = *(unsigned int **)a4;
              v48 = *a5;
              v11 = *(_DWORD *)(a4 + 8);
              continue;
            }
            goto LABEL_31;
          }
          v51 = v18;
          if ( v59 != v15 )
            *a5 += 4 * ((char *)v59 - (char *)v15);
        }
        if ( !v51 )
          goto LABEL_28;
      }
LABEL_31:
      if ( v51 != 7 || !a10 )
        return v51;
      v19 = *a5;
      if ( (int)(v10 - *a5) > 3 )
        _assert_fail(
          v13,
          a2,
          (int)"inend - *inptrp < 4",
          (int)"../iconv/skeleton.c",
          786,
          "__gconv_transform_internal_ascii");
      v20 = 0;
      v21 = (char *)*a5;
      if ( v10 <= v19 )
      {
        v23 = 0;
      }
      else
      {
        do
        {
          v22 = *v21++;
          *(_BYTE *)(*(_DWORD *)(a4 + 20) + v20++ + 4) = v22;
          *a5 = (int)v21;
        }
        while ( v21 != (char *)v10 );
        v23 = (unsigned int)&v21[-v19];
      }
      **(_DWORD **)(a4 + 20) = v23 | **(_DWORD **)(a4 + 20) & 0xFFFFFFF8;
      return 7;
    }
    break;
  }
  result = v51;
  *a7 = v15;
  return result;
}

//----- (08093CD0) --------------------------------------------------------
int __usercall _gconv_transform_internal_utf8@<eax>(
        long double a1@<st0>,
        int a2,
        int a3,
        int *a4,
        unsigned int a5,
        unsigned int **a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  unsigned int v9; // esi
  int v10; // ecx
  int *v11; // eax
  unsigned int v12; // edi
  int *v13; // edx
  unsigned int *v14; // ebx
  int v15; // eax
  int *v16; // esi
  int v17; // eax
  int v18; // edx
  unsigned int v19; // edx
  int v20; // ecx
  char *v21; // eax
  char v22; // bl
  unsigned int v23; // eax
  int result; // eax
  unsigned int v25; // ecx
  char v26; // dl
  unsigned int *v27; // edx
  int v28; // eax
  unsigned int v29; // ebx
  char v30; // al
  unsigned int v31; // eax
  unsigned int *v32; // eax
  int v33; // edx
  int v34; // eax
  int v35; // ecx
  int v36; // ebx
  int v37; // edx
  char v38; // al
  _DWORD *v39; // eax
  int *v40; // ebx
  int v41; // eax
  unsigned int v42; // ecx
  char v43; // bl
  int *v44; // ebx
  unsigned int v45; // edx
  int v46; // eax
  int v47; // eax
  signed int v48; // ecx
  unsigned int *v49; // eax
  _DWORD *v50; // ecx
  char v51; // bl
  unsigned int *v52; // edi
  unsigned int *v53; // edx
  int v54; // ebx
  int v55; // eax
  int v56; // ebx
  unsigned int v57; // ecx
  char v58; // al
  int *v59; // ebx
  int v60; // eax
  bool v61; // zf
  unsigned int v62; // [esp+2Ch] [ebp-80h]
  int v63; // [esp+3Ch] [ebp-70h]
  int v64; // [esp+40h] [ebp-6Ch]
  _DWORD *v65; // [esp+44h] [ebp-68h]
  int v66; // [esp+44h] [ebp-68h]
  unsigned int v67; // [esp+44h] [ebp-68h]
  unsigned int *v68; // [esp+48h] [ebp-64h]
  int v69; // [esp+4Ch] [ebp-60h]
  int v70; // [esp+4Ch] [ebp-60h]
  int v71; // [esp+4Ch] [ebp-60h]
  int v72; // [esp+50h] [ebp-5Ch]
  unsigned int v73; // [esp+50h] [ebp-5Ch]
  unsigned int v74; // [esp+54h] [ebp-58h]
  char *v75; // [esp+54h] [ebp-58h]
  int v76; // [esp+54h] [ebp-58h]
  int (__cdecl *v77)(int, int, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int); // [esp+58h] [ebp-54h]
  unsigned int v78; // [esp+5Ch] [ebp-50h]
  int v79; // [esp+5Ch] [ebp-50h]
  int v80; // [esp+5Ch] [ebp-50h]
  int v81; // [esp+60h] [ebp-4Ch]
  int v82; // [esp+64h] [ebp-48h]
  int *v83; // [esp+68h] [ebp-44h]
  int v84; // [esp+7Ch] [ebp-30h] BYREF
  unsigned int *v85; // [esp+80h] [ebp-2Ch] BYREF
  unsigned int *v86; // [esp+84h] [ebp-28h] BYREF
  unsigned int *v87; // [esp+88h] [ebp-24h] BYREF
  unsigned int v88; // [esp+8Ch] [ebp-20h] BYREF
  char v89; // [esp+90h] [ebp-1Ch] BYREF

  v9 = a5;
  v81 = a2 + 60;
  v77 = 0;
  v82 = a3 + 36;
  v10 = *(_DWORD *)(a3 + 8);
  if ( (v10 & 1) == 0 )
  {
    v77 = *(int (__cdecl **)(int, int, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int))(a2 + 80);
    if ( *(_DWORD *)(a2 + 60) )
      v77 = (int (__cdecl *)(int, int, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(v77, 9));
  }
  if ( a8 )
  {
    if ( a6 )
      _assert_fail(
        (int)a6,
        a1,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        416,
        "__gconv_transform_internal_utf8");
    v39 = *(_DWORD **)(a3 + 20);
    *v39 = 0;
    v39[1] = 0;
    v72 = 0;
    if ( (*(_BYTE *)(a3 + 8) & 1) != 0 )
      return v72;
    dl_mcount_wrapper_check((int)v77);
    return v77(v81, v82, 0, 0, 0, a7, a8, a9);
  }
  if ( a6 )
    v68 = *a6;
  else
    v68 = *(unsigned int **)a3;
  v11 = &v84;
  v84 = 0;
  v12 = *(_DWORD *)(a3 + 4);
  if ( !a7 )
    v11 = 0;
  v83 = v11;
  if ( !a9 || (v65 = *(_DWORD **)(a3 + 20), (v69 = *v65 & 7) == 0) )
  {
    v70 = *a4;
    goto LABEL_12;
  }
  if ( a6 )
    _assert_fail(
      (int)a4,
      a1,
      (int)"outbufstart == ((void *)0)",
      (int)"../iconv/skeleton.c",
      559,
      "__gconv_transform_internal_utf8");
  v27 = (unsigned int *)*a4;
  v74 = *(_DWORD *)(a3 + 4);
  v28 = 0;
  v87 = v68;
  v29 = v69;
  v86 = v27;
  do
  {
    *((_BYTE *)&v88 + v28) = *((_BYTE *)v65 + v28 + 4);
    ++v28;
  }
  while ( v28 != v69 );
  if ( a5 < (unsigned int)v27 - v28 + 4 )
  {
    *a4 = a5;
    v72 = 7;
    if ( a5 > (unsigned int)v27 )
    {
      do
      {
        v38 = *(_BYTE *)v27;
        v27 = (unsigned int *)((char *)v27 + 1);
        *((_BYTE *)v65 + v29++ + 4) = v38;
        v86 = v27;
      }
      while ( v27 != (unsigned int *)a5 );
      return 7;
    }
    return v72;
  }
  v72 = 5;
  if ( (unsigned int)v68 >= v74 )
    return v72;
  do
  {
    v30 = *(_BYTE *)v27;
    v27 = (unsigned int *)((char *)v27 + 1);
    v86 = v27;
    *((_BYTE *)&v88 + v29++) = v30;
  }
  while ( a5 > (unsigned int)v27 && v29 <= 3 );
  v86 = &v88;
  v31 = v88;
  v75 = (char *)&v88 + v29;
  if ( v88 <= 0x7F )
  {
    *(_BYTE *)v68 = v88;
    v87 = (unsigned int *)((char *)v68 + 1);
LABEL_66:
    v72 = 0;
    v32 = ++v86;
    goto LABEL_67;
  }
  if ( (v88 & 0x80000000) == 0 )
  {
    v42 = 2;
    if ( (v88 & 0xFFFFF800) != 0 )
    {
      LOBYTE(v42) = 3;
      if ( (v88 & 0xFFFF0000) != 0 )
      {
        LOBYTE(v42) = 4;
        if ( (v88 & 0xFFE00000) != 0 )
          v42 = 6 - ((v88 & 0xFC000000) == 0);
      }
    }
    if ( v12 < (unsigned int)v68 + v42 )
      return 5;
    *(_BYTE *)v68 = -256 >> v42;
    v87 = (unsigned int *)((char *)v87 + v42);
    do
    {
      --v42;
      v43 = v31 & 0x3F | 0x80;
      v31 >>= 6;
      *((_BYTE *)v68 + v42) = v43;
    }
    while ( v42 > 1 );
    *(_BYTE *)v68 |= v31;
    goto LABEL_66;
  }
  if ( !v83 )
    return 6;
  v44 = *(int **)(a3 + 32);
  if ( v44 )
  {
    v45 = a5;
    while ( 1 )
    {
      v62 = v45;
      v64 = v10;
      dl_mcount_wrapper_check(*v44);
      v46 = ((int (__cdecl *)(int, int, int, int, unsigned int **, char *, unsigned int **, int *))*v44)(
              a2,
              a3,
              v44[3],
              *a4,
              &v86,
              v75,
              &v87,
              v83);
      v45 = v62;
      v10 = v64;
      if ( v46 != 6 )
        break;
      v44 = (int *)v44[4];
      if ( !v44 )
      {
        v32 = v86;
        v9 = v62;
        goto LABEL_107;
      }
    }
    v72 = v46;
    v32 = v86;
    v9 = v62;
  }
  else
  {
    v32 = &v88;
LABEL_107:
    v72 = 6;
    if ( (v10 & 2) != 0 )
    {
      v86 = ++v32;
      ++*v83;
    }
  }
LABEL_67:
  if ( v32 == &v88 )
  {
    if ( v72 == 7 )
    {
      if ( v75 == &v89 )
        _assert_fail((int)a4, a1, (int)"inend != &bytebuf[4]", (int)"../iconv/loop.c", 466, "internal_utf8_loop_single");
      v47 = v75 - (char *)v32;
      v48 = *v65 & 0xFFFFFFF8;
      *a4 += v47 - (*v65 & 7);
      if ( v47 <= v48 )
        _assert_fail(
          (int)a4,
          a1,
          (int)"inend - inptr > (state->__count & ~7)",
          (int)"../iconv/loop.c",
          476,
          "internal_utf8_loop_single");
      if ( v47 > 7 )
        _assert_fail((int)a4, a1, (int)"inend - inptr <= 7", (int)"../iconv/loop.c", 477, "internal_utf8_loop_single");
      *v65 = v48 | v47;
      v49 = v86;
      if ( v75 <= (char *)v86 )
        return v72;
      v50 = v65;
      do
      {
        v51 = *(_BYTE *)v49;
        v49 = (unsigned int *)((char *)v49 + 1);
        *((_BYTE *)v50 + 4) = v51;
        v50 = (_DWORD *)((char *)v50 + 1);
        v86 = v49;
      }
      while ( v49 != (unsigned int *)v75 );
      return 7;
    }
    if ( v72 )
      return v72;
    v70 = *a4;
    v10 = *(_DWORD *)(a3 + 8);
  }
  else
  {
    v33 = (char *)v32 - (char *)&v88;
    v34 = *v65;
    v35 = *v65 & 7;
    if ( v33 <= v35 )
      _assert_fail(
        (int)a4,
        a1,
        (int)"inptr - bytebuf > (state->__count & 7)",
        (int)"../iconv/loop.c",
        448,
        "internal_utf8_loop_single");
    v36 = (int)v87;
    v37 = *a4 + v33 - v35;
    *a4 = v37;
    v70 = v37;
    v68 = (unsigned int *)v36;
    *v65 = v34 & 0xFFFFFFF8;
    v10 = *(_DWORD *)(a3 + 8);
  }
LABEL_12:
  v13 = (int *)v70;
  v14 = v68;
  v72 = 4;
  v66 = v10 & 2;
  v87 = (unsigned int *)v70;
  v86 = v68;
LABEL_18:
  while ( 2 )
  {
    while ( 2 )
    {
      if ( (int *)v9 == v13 )
        goto LABEL_19;
      if ( v9 < (unsigned int)(v13 + 1) )
      {
        v72 = 7;
        goto LABEL_19;
      }
      if ( v12 <= (unsigned int)v14 )
      {
LABEL_44:
        v72 = 5;
        *a4 = (int)v13;
        if ( a6 )
          goto LABEL_45;
LABEL_20:
        if ( *(_DWORD *)(a3 + 32) )
        {
          v78 = v9;
          v16 = *(int **)(a3 + 32);
          do
          {
            if ( v16[1] )
            {
              dl_mcount_wrapper_check(v16[1]);
              ((void (__cdecl *)(int, int, int, unsigned int *, unsigned int *))v16[1])(v16[3], v70, *a4, v68, v14);
            }
            v16 = (int *)v16[4];
          }
          while ( v16 );
          v9 = v78;
        }
        ++*(_DWORD *)(a3 + 12);
        if ( (*(_BYTE *)(a3 + 8) & 1) != 0 )
        {
          *(_DWORD *)a3 = v14;
          *a7 += v84;
          goto LABEL_35;
        }
        if ( v68 >= v14 )
          goto LABEL_31;
        v85 = *(unsigned int **)a3;
        dl_mcount_wrapper_check((int)v77);
        v17 = v77(v81, v82, &v85, v14, 0, a7, 0, a9);
        v18 = v17;
        if ( v17 == 4 )
        {
          if ( v72 == 5 || !v72 )
            goto LABEL_32;
          goto LABEL_35;
        }
        v67 = (unsigned int)v85;
        if ( v85 == v14 )
          goto LABEL_30;
        v73 = v12;
        v52 = (unsigned int *)v70;
        v76 = v17;
        *a4 = v70;
        v80 = *(_DWORD *)(a3 + 8) & 2;
        v86 = (unsigned int *)v70;
        v87 = v68;
        v53 = v68;
        v63 = 4;
        while ( 1 )
        {
          if ( (unsigned int *)v9 == v52 )
          {
            v55 = (int)v53;
            v56 = v63;
            v71 = (int)v52;
            v18 = v76;
            v12 = v73;
            goto LABEL_153;
          }
          if ( v9 < (unsigned int)(v52 + 1) )
          {
            v55 = (int)v53;
            v18 = v76;
            v56 = 7;
            v71 = (int)v52;
            v12 = v73;
            goto LABEL_153;
          }
          if ( v67 <= (unsigned int)v53 )
            goto LABEL_159;
          v54 = *v52;
          if ( *v52 <= 0x7F )
            break;
          if ( v54 < 0 )
          {
            if ( !v83 )
              goto LABEL_148;
            v59 = *(int **)(a3 + 32);
            if ( v59 )
            {
              while ( 1 )
              {
                dl_mcount_wrapper_check(*v59);
                v60 = ((int (__cdecl *)(int, int, int, int, unsigned int **, unsigned int, unsigned int **, int *))*v59)(
                        a2,
                        a3,
                        v59[3],
                        *a4,
                        &v86,
                        v9,
                        &v87,
                        v83);
                if ( v60 != 6 )
                  break;
                v59 = (int *)v59[4];
                if ( !v59 )
                {
                  v52 = v86;
                  v53 = v87;
                  goto LABEL_147;
                }
              }
              v63 = v60;
              if ( v60 == 5 )
              {
                v12 = v73;
                v18 = v76;
                v56 = 5;
                v71 = (int)v86;
                v55 = (int)v87;
LABEL_153:
                v61 = v85 == (unsigned int *)v55;
                *a4 = v71;
                if ( !v61 )
                  _assert_fail(
                    (int)a4,
                    a1,
                    (int)"outbuf == outerr",
                    (int)"../iconv/skeleton.c",
                    736,
                    "__gconv_transform_internal_utf8");
                if ( v56 != 5 )
                  _assert_fail(
                    (int)a4,
                    a1,
                    (int)"nstatus == __GCONV_FULL_OUTPUT",
                    (int)"../iconv/skeleton.c",
                    737,
                    "__gconv_transform_internal_utf8");
                if ( (unsigned int *)v55 == v68 )
                {
                  v72 = v18;
                  --*(_DWORD *)(a3 + 12);
LABEL_31:
                  if ( !v72 )
                  {
LABEL_32:
                    v70 = *a4;
                    v68 = *(unsigned int **)a3;
                    v10 = *(_DWORD *)(a3 + 8);
                    goto LABEL_12;
                  }
LABEL_35:
                  if ( v72 == 7 && a9 )
                  {
                    v19 = *a4;
                    if ( (int)(v9 - *a4) > 3 )
                      _assert_fail(
                        (int)a4,
                        a1,
                        (int)"inend - *inptrp < 4",
                        (int)"../iconv/skeleton.c",
                        786,
                        "__gconv_transform_internal_utf8");
                    v20 = 0;
                    v21 = (char *)*a4;
                    if ( v9 <= v19 )
                    {
                      v23 = 0;
                    }
                    else
                    {
                      do
                      {
                        v22 = *v21++;
                        *(_BYTE *)(*(_DWORD *)(a3 + 20) + v20++ + 4) = v22;
                        *a4 = (int)v21;
                      }
                      while ( v21 != (char *)v9 );
                      v23 = (unsigned int)&v21[-v19];
                    }
                    **(_DWORD **)(a3 + 20) = v23 | **(_DWORD **)(a3 + 20) & 0xFFFFFFF8;
                    return 7;
                  }
                  return v72;
                }
LABEL_30:
                v72 = v18;
                goto LABEL_31;
              }
              v52 = v86;
              v53 = v87;
            }
            else
            {
LABEL_147:
              if ( !v80 )
              {
LABEL_148:
                v55 = (int)v53;
                v56 = 6;
                v18 = v76;
                v71 = (int)v52;
                v12 = v73;
                goto LABEL_153;
              }
              v86 = ++v52;
              v63 = 6;
              ++*v83;
            }
          }
          else
          {
            v57 = 2;
            if ( (v54 & 0xFFFFF800) != 0 )
            {
              LOBYTE(v57) = 3;
              if ( (v54 & 0xFFFF0000) != 0 )
              {
                LOBYTE(v57) = 4;
                if ( (v54 & 0xFFE00000) != 0 )
                  v57 = 6 - ((v54 & 0xFC000000) == 0);
              }
            }
            if ( v67 < (unsigned int)v53 + v57 )
            {
LABEL_159:
              v55 = (int)v53;
              v56 = 5;
              v18 = v76;
              v71 = (int)v52;
              v12 = v73;
              goto LABEL_153;
            }
            *(_BYTE *)v53 = -256 >> v57;
            v87 = (unsigned int *)((char *)v87 + v57);
            do
            {
              --v57;
              v58 = v54 & 0x3F | 0x80;
              v54 = (unsigned int)v54 >> 6;
              *((_BYTE *)v53 + v57) = v58;
            }
            while ( v57 > 1 );
            *(_BYTE *)v53 |= v54;
            v53 = v87;
LABEL_129:
            v52 = ++v86;
          }
        }
        *(_BYTE *)v53 = v54;
        v53 = (unsigned int *)((char *)v53 + 1);
        v87 = v53;
        goto LABEL_129;
      }
      v15 = *v13;
      if ( (unsigned int)*v13 <= 0x7F )
      {
        *(_BYTE *)v14 = v15;
        v14 = (unsigned int *)((char *)v14 + 1);
        v86 = v14;
LABEL_17:
        v13 = (int *)++v87;
        continue;
      }
      break;
    }
    if ( v15 >= 0 )
    {
      v79 = 2;
      if ( (v15 & 0xFFFFF800) != 0 )
      {
        v79 = 3;
        if ( (v15 & 0xFFFF0000) != 0 )
        {
          v79 = 4;
          if ( (v15 & 0xFFE00000) != 0 )
            v79 = 6 - ((v15 & 0xFC000000) == 0);
        }
      }
      if ( v12 < (unsigned int)v14 + v79 )
        goto LABEL_44;
      v25 = v79;
      *(_BYTE *)v14 = -256 >> v79;
      v86 = (unsigned int *)((char *)v86 + v79);
      do
      {
        --v25;
        v26 = v15 & 0x3F | 0x80;
        v15 = (unsigned int)v15 >> 6;
        *((_BYTE *)v14 + v25) = v26;
      }
      while ( v25 > 1 );
      *(_BYTE *)v14 |= v15;
      v14 = v86;
      goto LABEL_17;
    }
    if ( !v83 )
      goto LABEL_86;
    if ( !*(_DWORD *)(a3 + 32) )
      goto LABEL_85;
    v40 = *(int **)(a3 + 32);
    while ( 1 )
    {
      dl_mcount_wrapper_check(*v40);
      v41 = ((int (__cdecl *)(int, int, int, int, unsigned int **, unsigned int, unsigned int **, int *))*v40)(
              a2,
              a3,
              v40[3],
              *a4,
              &v87,
              v9,
              &v86,
              v83);
      if ( v41 != 6 )
        break;
      v40 = (int *)v40[4];
      if ( !v40 )
      {
        v13 = (int *)v87;
        v14 = v86;
LABEL_85:
        if ( !v66 )
        {
LABEL_86:
          v72 = 6;
          goto LABEL_19;
        }
        v87 = (unsigned int *)++v13;
        v72 = 6;
        ++*v83;
        goto LABEL_18;
      }
    }
    v13 = (int *)v87;
    v72 = v41;
    v14 = v86;
    if ( v41 != 5 )
      continue;
    break;
  }
LABEL_19:
  *a4 = (int)v13;
  if ( !a6 )
    goto LABEL_20;
LABEL_45:
  result = v72;
  *a6 = v14;
  return result;
}

//----- (08094A40) --------------------------------------------------------
int __usercall _gconv_transform_utf8_internal@<eax>(
        long double a1@<st0>,
        int a2,
        unsigned int **a3,
        char **a4,
        unsigned int a5,
        unsigned int **a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  unsigned int *v9; // edx
  int *v10; // eax
  unsigned int v11; // ebp
  unsigned __int8 *v12; // eax
  unsigned int *v13; // ebx
  unsigned int *v14; // edi
  unsigned int v15; // edx
  int *i; // edi
  int v17; // edx
  unsigned int v18; // edi
  char *v19; // ebp
  int v20; // eax
  int v21; // eax
  int v22; // edi
  char v23; // cl
  unsigned __int8 *v24; // ebx
  unsigned __int8 *v25; // edx
  int result; // eax
  unsigned int v27; // ebx
  unsigned __int8 v28; // di
  unsigned int v29; // ebp
  unsigned __int8 *v30; // edx
  unsigned __int8 *v31; // edi
  unsigned int v32; // eax
  unsigned int v33; // ecx
  unsigned int v34; // ebx
  char *v35; // ecx
  char *v36; // ecx
  unsigned int v37; // eax
  int v38; // eax
  unsigned int v39; // ecx
  unsigned int v40; // ebx
  char v41; // di
  unsigned int *v42; // eax
  unsigned __int8 *v43; // edx
  unsigned int v44; // edi
  unsigned __int8 *v45; // ecx
  unsigned __int8 *v46; // ebx
  unsigned int v47; // eax
  unsigned int v48; // ecx
  unsigned int v49; // edx
  int v50; // eax
  char *v51; // ecx
  int v52; // eax
  int v53; // eax
  int v54; // ecx
  char v55; // dl
  char *v56; // edi
  char *j; // ebx
  unsigned __int8 *v58; // eax
  unsigned __int8 *v59; // ecx
  unsigned __int8 *v60; // eax
  unsigned __int8 *v61; // ecx
  int *v62; // [esp+24h] [ebp-68h]
  unsigned int v63; // [esp+24h] [ebp-68h]
  unsigned __int8 v64; // [esp+24h] [ebp-68h]
  unsigned int *v65; // [esp+28h] [ebp-64h]
  char *v66; // [esp+2Ch] [ebp-60h]
  unsigned int v67; // [esp+2Ch] [ebp-60h]
  int v68; // [esp+30h] [ebp-5Ch]
  int *v69; // [esp+30h] [ebp-5Ch]
  unsigned int *v70; // [esp+30h] [ebp-5Ch]
  int *v71; // [esp+34h] [ebp-58h]
  int v72; // [esp+34h] [ebp-58h]
  int v73; // [esp+38h] [ebp-54h]
  int v74; // [esp+38h] [ebp-54h]
  int (__cdecl *v75)(int, _DWORD *, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int); // [esp+3Ch] [ebp-50h]
  int v76; // [esp+40h] [ebp-4Ch]
  _DWORD *v77; // [esp+44h] [ebp-48h]
  unsigned __int8 *v78; // [esp+48h] [ebp-44h]
  char *v79; // [esp+48h] [ebp-44h]
  int v80; // [esp+48h] [ebp-44h]
  int *v81; // [esp+4Ch] [ebp-40h]
  unsigned int v82; // [esp+50h] [ebp-3Ch]
  unsigned int *v83; // [esp+50h] [ebp-3Ch]
  unsigned int *v84; // [esp+50h] [ebp-3Ch]
  unsigned int *v85; // [esp+54h] [ebp-38h]
  unsigned int *v86; // [esp+58h] [ebp-34h]
  int v87; // [esp+5Ch] [ebp-30h]
  unsigned __int8 v88; // [esp+62h] [ebp-2Ah] BYREF
  char v89[5]; // [esp+63h] [ebp-29h] BYREF
  int v90; // [esp+68h] [ebp-24h] BYREF
  unsigned int *v91; // [esp+6Ch] [ebp-20h] BYREF

  v76 = a2 + 60;
  v9 = a3[2];
  v77 = a3 + 9;
  v75 = 0;
  if ( ((unsigned __int8)v9 & 1) == 0 )
  {
    v75 = *(int (__cdecl **)(int, _DWORD *, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int))(a2 + 80);
    if ( *(_DWORD *)(a2 + 60) )
      v75 = (int (__cdecl *)(int, _DWORD *, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a2 + 80), 9));
  }
  if ( !a8 )
  {
    if ( a6 )
      v65 = *a6;
    else
      v65 = *a3;
    v10 = &v90;
    v90 = 0;
    v11 = (unsigned int)a3[1];
    if ( !a7 )
      v10 = 0;
    v81 = v10;
    if ( !a9 || (v71 = (int *)a3[5], (*v71 & 7) == 0) )
    {
      v66 = *a4;
LABEL_12:
      if ( (char *)a5 == v66 )
        goto LABEL_32;
LABEL_13:
      v12 = (unsigned __int8 *)v66;
      v13 = v65;
      v14 = v65 + 1;
      if ( v11 < (unsigned int)(v65 + 1) )
      {
LABEL_57:
        v73 = 5;
        goto LABEL_21;
      }
      v73 = 4;
      v68 = (unsigned __int8)v9 & 2;
      v82 = v11;
      while ( 1 )
      {
        v15 = *v12;
        if ( v15 <= 0x7F )
        {
          ++v12;
LABEL_18:
          *v13 = v15;
          v13 = v14;
          goto LABEL_19;
        }
        if ( v15 - 194 > 0x1D )
        {
          if ( (v15 & 0xF0) == 224 )
          {
            v63 = 3;
            v15 &= 0xFu;
            v78 = v12 + 3;
            if ( a5 < (unsigned int)(v12 + 3) )
            {
LABEL_60:
              v30 = v12 + 1;
              v72 = 1;
              if ( a5 > (unsigned int)(v12 + 1) && (v12[1] & 0xC0) == 128 )
              {
                v31 = v12 + 2;
                do
                {
                  ++v72;
                  v30 = v31;
                  if ( v31 == (unsigned __int8 *)a5 )
                    break;
                  ++v31;
                }
                while ( (*v30 & 0xC0) == 128 );
              }
              if ( (unsigned __int8 *)a5 == v30 )
              {
                v11 = v82;
                v73 = 7;
                goto LABEL_21;
              }
              goto LABEL_53;
            }
            goto LABEL_49;
          }
          if ( (v15 & 0xF8) == 240 )
          {
            v15 &= 7u;
            v63 = 4;
          }
          else if ( (v15 & 0xFC) == 248 )
          {
            v15 &= 3u;
            v63 = 5;
          }
          else
          {
            if ( (v15 & 0xFE) != 252 )
            {
              v43 = v12 + 1;
              v44 = 0;
              do
              {
                ++v44;
                v45 = v43;
                if ( (unsigned int)v43 >= a5 )
                  break;
                ++v43;
                if ( (*v45 & 0xC0) != 128 )
                  break;
              }
              while ( v44 <= 4 );
              v72 = v44;
              goto LABEL_53;
            }
            v15 &= 1u;
            v63 = 6;
          }
        }
        else
        {
          v15 &= 0x1Fu;
          v63 = 2;
        }
        v78 = &v12[v63];
        if ( a5 < (unsigned int)&v12[v63] )
          goto LABEL_60;
LABEL_49:
        v85 = v13;
        v27 = 1;
        v86 = v14;
        while ( 1 )
        {
          v28 = v12[v27];
          if ( (v28 & 0xC0) != 128 )
            break;
          ++v27;
          v15 = (v15 << 6) | v28 & 0x3F;
          if ( v63 <= v27 )
          {
            v72 = v27;
            v14 = v86;
            v13 = v85;
            goto LABEL_68;
          }
        }
        v72 = v27;
        v29 = v27;
        v14 = v86;
        v13 = v85;
        if ( v63 > v29 )
          goto LABEL_53;
LABEL_68:
        if ( (v63 == 2 || v15 >> (5 * v63 - 4)) && v15 - 55296 > 0x7FF )
        {
          v12 = v78;
          goto LABEL_18;
        }
LABEL_53:
        if ( !v81 || !v68 )
        {
          v11 = v82;
          v73 = 6;
LABEL_21:
          while ( 2 )
          {
            *a4 = (char *)v12;
            if ( a6 )
            {
              result = v73;
              *a6 = v13;
              return result;
            }
            for ( i = (int *)a3[8]; i; i = (int *)i[4] )
            {
              if ( i[1] )
              {
                dl_mcount_wrapper_check(i[1]);
                ((void (__cdecl *)(int, char *, char *, unsigned int *, unsigned int *))i[1])(i[3], v66, *a4, v65, v13);
              }
            }
            a3[3] = (unsigned int *)((char *)a3[3] + 1);
            if ( ((_BYTE)a3[2] & 1) != 0 )
            {
              v50 = v90;
              *a3 = v13;
              *a7 += v50;
              goto LABEL_34;
            }
            if ( v13 <= v65 )
              goto LABEL_34;
            v91 = *a3;
            dl_mcount_wrapper_check((int)v75);
            v17 = v75(v76, v77, &v91, v13, 0, a7, 0, a9);
            if ( v17 == 4 )
            {
              if ( v73 == 5 )
                goto LABEL_31;
              goto LABEL_34;
            }
            v18 = (unsigned int)v91;
            if ( v91 == v13 )
              goto LABEL_30;
            *a4 = v66;
            if ( (char *)a5 == v66 )
            {
              v70 = v65;
              v74 = 4;
              goto LABEL_150;
            }
            v84 = v65 + 1;
            v70 = v65;
            if ( v18 < (unsigned int)(v65 + 1) )
            {
LABEL_149:
              v74 = 5;
              goto LABEL_150;
            }
            v46 = (unsigned __int8 *)v66;
            v74 = 4;
            v87 = (unsigned int)a3[2] & 2;
            v80 = v17;
LABEL_135:
            v47 = *v46;
            if ( v47 <= 0x7F )
            {
              ++v46;
LABEL_132:
              *v70 = v47;
              v70 = v84;
            }
            else
            {
              if ( v47 - 194 > 0x1D )
              {
                if ( (v47 & 0xF0) == 224 )
                {
                  v47 &= 0xFu;
                  v48 = 3;
                  goto LABEL_138;
                }
                if ( (v47 & 0xF8) == 240 )
                {
                  v47 &= 7u;
                  v48 = 4;
                  goto LABEL_138;
                }
                if ( (v47 & 0xFC) == 248 )
                {
                  v47 &= 3u;
                  v48 = 5;
                  goto LABEL_138;
                }
                if ( (v47 & 0xFE) == 252 )
                {
                  v47 &= 1u;
                  v48 = 6;
                  goto LABEL_138;
                }
                v60 = v46 + 1;
                v49 = 0;
                do
                {
                  ++v49;
                  v61 = v60;
                  if ( a5 <= (unsigned int)v60 )
                    break;
                  ++v60;
                  if ( (*v61 & 0xC0) != 128 )
                    break;
                }
                while ( v49 <= 4 );
              }
              else
              {
                v47 &= 0x1Fu;
                v48 = 2;
LABEL_138:
                if ( a5 < (unsigned int)&v46[v48] )
                {
                  v58 = v46 + 1;
                  v49 = 1;
                  if ( a5 > (unsigned int)(v46 + 1) && (v46[1] & 0xC0) == 128 )
                  {
                    v59 = v46 + 2;
                    do
                    {
                      ++v49;
                      v58 = v59;
                      if ( v59 == (unsigned __int8 *)a5 )
                        break;
                      ++v59;
                    }
                    while ( (*v58 & 0xC0) == 128 );
                  }
                  if ( (unsigned __int8 *)a5 == v58 )
                  {
                    v17 = v80;
                    v66 = (char *)v46;
                    v74 = 7;
                    goto LABEL_150;
                  }
                }
                else
                {
                  v49 = 1;
                  while ( 1 )
                  {
                    v64 = v46[v49];
                    if ( (v64 & 0xC0) != 128 )
                      break;
                    ++v49;
                    v47 = (v47 << 6) | v64 & 0x3F;
                    if ( v48 <= v49 )
                      goto LABEL_142;
                  }
                  if ( v49 < v48 )
                    goto LABEL_201;
LABEL_142:
                  if ( (v48 == 2 || v47 >> (5 * v48 - 4)) && v47 - 55296 > 0x7FF )
                  {
                    v46 += v48;
                    goto LABEL_132;
                  }
                }
              }
LABEL_201:
              if ( !v81 || !v87 )
              {
                v17 = v80;
                v66 = (char *)v46;
                v74 = 6;
LABEL_150:
                *a4 = v66;
                if ( (unsigned int *)v18 != v70 )
                  _assert_fail(
                    v11,
                    a1,
                    (int)"outbuf == outerr",
                    (int)"../iconv/skeleton.c",
                    736,
                    "__gconv_transform_utf8_internal");
                if ( v74 != 5 )
                  _assert_fail(
                    v11,
                    a1,
                    (int)"nstatus == __GCONV_FULL_OUTPUT",
                    (int)"../iconv/skeleton.c",
                    737,
                    "__gconv_transform_utf8_internal");
                if ( (unsigned int *)v18 == v65 )
                  a3[3] = (unsigned int *)((char *)a3[3] - 1);
LABEL_30:
                if ( !v17 )
                {
LABEL_31:
                  v66 = *a4;
                  v9 = a3[2];
                  v65 = *a3;
                  if ( (char *)a5 == *a4 )
                  {
LABEL_32:
                    v12 = (unsigned __int8 *)a5;
                    v13 = v65;
                    v73 = 4;
                    continue;
                  }
                  goto LABEL_13;
                }
                v73 = v17;
LABEL_34:
                if ( v73 == 7 && a9 )
                {
                  v19 = *a4;
                  v20 = (unsigned __int8)**a4;
                  v62 = (int *)a3[5];
                  v67 = a5 - (_DWORD)*a4;
                  *v62 = v67;
                  if ( (unsigned int)(v20 - 194) <= 0x1D )
                  {
                    v21 = v20 & 0x1F;
                    v22 = 512;
                    v23 = 1;
                  }
                  else if ( (v20 & 0xF0) == 224 )
                  {
                    v21 = v20 & 0xF;
                    v22 = 768;
                    v23 = 2;
                  }
                  else if ( (v20 & 0xF8) == 240 )
                  {
                    v21 = v20 & 7;
                    v22 = 1024;
                    v23 = 3;
                  }
                  else if ( (v20 & 0xFC) == 248 )
                  {
                    v21 = v20 & 3;
                    v22 = 1280;
                    v23 = 4;
                  }
                  else
                  {
                    v21 = v20 & 1;
                    v22 = 1536;
                    v23 = 5;
                  }
                  v24 = (unsigned __int8 *)(v19 + 1);
                  *a4 = v19 + 1;
                  v25 = (unsigned __int8 *)(v19 + 1);
                  if ( a5 > (unsigned int)(v19 + 1) )
                  {
                    while ( 1 )
                    {
                      ++v25;
                      v21 = (v21 << 6) | *v24 & 0x3F;
                      *a4 = (char *)v25;
                      if ( v25 == (unsigned __int8 *)a5 )
                        break;
                      v24 = v25;
                    }
                    v23 += (_BYTE)v19 - (_BYTE)v25 + 1;
                  }
                  v73 = 7;
                  *v62 = v67 | v22;
                  v62[1] = v21 << (6 * v23);
                }
                return v73;
              }
              v46 += v49;
              v74 = 6;
              ++*v81;
            }
            break;
          }
          if ( (unsigned __int8 *)a5 == v46 )
          {
            v17 = v80;
            v66 = (char *)v46;
            goto LABEL_150;
          }
          v84 = v70 + 1;
          if ( v18 < (unsigned int)(v70 + 1) )
          {
            v17 = v80;
            v66 = (char *)v46;
            goto LABEL_149;
          }
          goto LABEL_135;
        }
        v12 += v72;
        v73 = 6;
        ++*v81;
LABEL_19:
        if ( (unsigned __int8 *)a5 == v12 )
        {
          v11 = v82;
          goto LABEL_21;
        }
        v14 = v13 + 1;
        if ( v82 < (unsigned int)(v13 + 1) )
        {
          v11 = v82;
          goto LABEL_57;
        }
      }
    }
    if ( a6 )
      _assert_fail(
        v11,
        a1,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        559,
        "__gconv_transform_utf8_internal");
    v32 = (unsigned __int8)*a3[5];
    v33 = (int)*a3[5] >> 8;
    v66 = *a4;
    v34 = v71[1];
    v88 = byte_80CE57E[v33];
    do
    {
      if ( v32 > --v33 )
        v89[v33 - 1] = v34 & 0x3F | 0x80;
      v34 >>= 6;
    }
    while ( v33 > 1 );
    v88 |= v34;
    v73 = 5;
    v83 = v65 + 1;
    if ( v11 < (unsigned int)(v65 + 1) )
      return v73;
    v35 = v66;
    do
    {
      v89[v32++ - 1] = *v35;
      if ( v32 > 5 )
        break;
      ++v35;
    }
    while ( a5 > (unsigned int)v35 );
    v36 = &v89[v32 - 1];
    v37 = v88;
    v69 = (int *)v36;
    if ( v88 <= 0x7Fu )
    {
      v79 = v89;
LABEL_86:
      v73 = 0;
      *v65 = v37;
LABEL_87:
      if ( v79 == (char *)&v88 )
      {
        if ( v73 )
          return v73;
        v9 = a3[2];
      }
      else
      {
        v38 = *v71 & 7;
        if ( v79 - (char *)&v88 <= v38 )
          _assert_fail(
            v11,
            a1,
            (int)"inptr - bytebuf > (state->__count & 7)",
            (int)"../iconv/loop.c",
            448,
            "utf8_internal_loop_single");
        v66 += v79 - (char *)&v88 - v38;
        *a4 = v66;
        *v71 = 0;
        v65 = v83;
        v9 = a3[2];
      }
      goto LABEL_12;
    }
    if ( (unsigned int)v88 - 194 > 0x1D )
    {
      v39 = v88 & 0xF0;
      if ( v39 == 224 )
      {
        v37 = v88 & 0xF;
        LOBYTE(v39) = 3;
      }
      else
      {
        v39 = v88 & 0xF8;
        if ( v39 == 240 )
        {
          v37 = v88 & 7;
          LOBYTE(v39) = 4;
        }
        else
        {
          v39 = v88 & 0xFC;
          if ( v39 == 248 )
          {
            v37 = v88 & 3;
            LOBYTE(v39) = 5;
          }
          else
          {
            v39 = v88 & 0xFE;
            if ( v39 != 252 )
            {
              v40 = 0;
              do
                ++v40;
              while ( v69 > (int *)&v89[v40 - 1] && (v89[v40 - 1] & 0xC0) == 128 && v40 <= 4 );
              goto LABEL_104;
            }
            v37 = v88 & 1;
            LOBYTE(v39) = 6;
          }
        }
      }
    }
    else
    {
      v37 = v88 & 0x1F;
      v39 = 2;
    }
    v79 = &v89[v39 - 1];
    if ( v69 < (int *)&v89[v39 - 1] )
    {
      v40 = 1;
      v51 = v89;
      if ( v69 > (int *)v89 && (v89[0] & 0xC0) == 128 )
      {
        do
          v51 = &v89[v40++];
        while ( v69 > (int *)&v89[v40 - 1] && (v89[v40 - 1] & 0xC0) == 128 );
      }
      if ( v69 == (int *)v51 )
      {
        if ( v69 == &v90 )
          _assert_fail(v11, a1, (int)"inend != &bytebuf[6]", (int)"../iconv/loop.c", 466, "utf8_internal_loop_single");
        *a4 = &v66[(char *)v69 - (char *)&v88 - (*v71 & 7)];
        v52 = v88;
        *v71 = (char *)v69 - (char *)&v88;
        if ( (unsigned int)(v52 - 194) > 0x1D )
        {
          if ( (v52 & 0xF0) == 224 )
          {
            v53 = v52 & 0xF;
            v54 = 768;
            v55 = 2;
          }
          else if ( (v52 & 0xF8) == 240 )
          {
            v53 = v52 & 7;
            v54 = 1024;
            v55 = 3;
          }
          else if ( (v52 & 0xFC) == 248 )
          {
            v53 = v52 & 3;
            v54 = 1280;
            v55 = 4;
          }
          else
          {
            v53 = v52 & 1;
            v54 = 1536;
            v55 = 5;
          }
        }
        else
        {
          v53 = v52 & 0x1F;
          v54 = 512;
          v55 = 1;
        }
        if ( v69 > (int *)v89 )
        {
          v56 = (char *)&v88;
          for ( j = v89; ; ++j )
          {
            --v55;
            v53 = (v53 << 6) | v56[1] & 0x3F;
            if ( v69 <= (int *)(j + 1) )
              break;
            v56 = j;
          }
        }
        *v71 = ((char *)v69 - (char *)&v88) | v54;
        v71[1] = v53 << (6 * v55);
        return 7;
      }
    }
    else
    {
      v40 = 1;
      while ( 1 )
      {
        v41 = v89[v40 - 1];
        if ( (v41 & 0xC0) != 128 )
          break;
        ++v40;
        v37 = (v37 << 6) | v41 & 0x3F;
        if ( v39 <= v40 )
          goto LABEL_101;
      }
      if ( v39 <= v40 )
      {
LABEL_101:
        if ( (v39 == 2 || v37 >> (5 * v39 - 4)) && v37 - 55296 > 0x7FF )
          goto LABEL_86;
      }
    }
LABEL_104:
    v73 = 6;
    if ( !v81 || ((unsigned __int8)v9 & 2) == 0 )
      return v73;
    v79 = &v89[v40 - 1];
    ++*v81;
    v83 = v65;
    goto LABEL_87;
  }
  if ( a6 )
    _assert_fail(
      (int)a3,
      a1,
      (int)"outbufstart == ((void *)0)",
      (int)"../iconv/skeleton.c",
      416,
      "__gconv_transform_utf8_internal");
  v42 = a3[5];
  *v42 = 0;
  v42[1] = 0;
  v73 = 0;
  if ( ((_BYTE)a3[2] & 1) != 0 )
    return v73;
  dl_mcount_wrapper_check((int)v75);
  return v75(v76, v77, 0, 0, 0, a7, a8, a9);
}

//----- (08095930) --------------------------------------------------------
int __usercall _gconv_transform_ucs2_internal@<eax>(
        int a1@<ebp>,
        long double a2@<st0>,
        int a3,
        unsigned int *a4,
        int *a5,
        unsigned int a6,
        unsigned int *a7,
        _DWORD *a8,
        int a9,
        int a10)
{
  unsigned int v10; // ecx
  int *v11; // eax
  unsigned int *v12; // ebx
  unsigned __int16 *v13; // eax
  char *v14; // ebx
  char *v15; // edx
  unsigned __int16 *v16; // edi
  int v17; // ecx
  int *v18; // edi
  int v19; // eax
  unsigned int v20; // edx
  int v21; // ecx
  char *v22; // eax
  char v23; // bl
  unsigned int v24; // eax
  int result; // eax
  unsigned int v26; // edi
  int v27; // eax
  char *v28; // edx
  char *v29; // eax
  char v30; // dl
  _DWORD *v31; // ecx
  unsigned int v32; // ecx
  int v33; // eax
  _DWORD *v34; // eax
  char v35; // al
  unsigned int v36; // [esp+2Ch] [ebp-50h]
  unsigned int v37; // [esp+30h] [ebp-4Ch]
  int v38; // [esp+34h] [ebp-48h]
  char *v39; // [esp+34h] [ebp-48h]
  int (__cdecl *v40)(int, _DWORD *, char **, char *, _DWORD, _DWORD *, int, int); // [esp+38h] [ebp-44h]
  int v41; // [esp+3Ch] [ebp-40h]
  int v42; // [esp+40h] [ebp-3Ch]
  _DWORD *v43; // [esp+44h] [ebp-38h]
  int v44; // [esp+48h] [ebp-34h]
  int *v45; // [esp+4Ch] [ebp-30h]
  int v46; // [esp+54h] [ebp-28h] BYREF
  char *v47; // [esp+58h] [ebp-24h] BYREF
  __int16 v48[15]; // [esp+5Eh] [ebp-1Eh]

  v42 = a3 + 60;
  v43 = a4 + 9;
  v40 = 0;
  v10 = a4[2];
  if ( (v10 & 1) == 0 )
  {
    a1 = *(_DWORD *)(a3 + 80);
    v40 = (int (__cdecl *)(int, _DWORD *, char **, char *, _DWORD, _DWORD *, int, int))a1;
    if ( *(_DWORD *)(a3 + 60) )
    {
      a1 = __readgsdword(0x18u) ^ __ROR4__(a1, 9);
      v40 = (int (__cdecl *)(int, _DWORD *, char **, char *, _DWORD, _DWORD *, int, int))a1;
    }
  }
  if ( a9 )
  {
    if ( a7 )
      _assert_fail(
        (int)a7,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        416,
        "__gconv_transform_ucs2_internal");
    v34 = (_DWORD *)a4[5];
    *v34 = 0;
    v34[1] = 0;
    v41 = 0;
    if ( (a4[2] & 1) != 0 )
      return v41;
    dl_mcount_wrapper_check((int)v40);
    return v40(v42, v43, 0, 0, 0, a8, a9, a10);
  }
  else
  {
    if ( a7 )
      v37 = *a7;
    else
      v37 = *a4;
    v11 = &v46;
    v46 = 0;
    v36 = a4[1];
    if ( !a8 )
      v11 = 0;
    v45 = v11;
    if ( !a10 || (v12 = (unsigned int *)a4[5], (a1 = *v12 & 7) == 0) )
    {
      v38 = *a5;
LABEL_12:
      if ( a6 == v38 )
        goto LABEL_34;
LABEL_13:
      v13 = (unsigned __int16 *)(v38 + 2);
      if ( a6 < v38 + 2 )
      {
        v14 = (char *)v37;
        v13 = (unsigned __int16 *)v38;
        v41 = 7;
      }
      else
      {
        v14 = (char *)v37;
        v15 = (char *)(v37 + 4);
        if ( v36 < v37 + 4 )
        {
          v13 = (unsigned __int16 *)v38;
          v41 = 5;
        }
        else
        {
          v16 = (unsigned __int16 *)v38;
          v41 = 4;
          v44 = v10 & 2;
          while ( 1 )
          {
            v17 = *v16;
            a1 = v17 + 10240;
            if ( (unsigned __int16)(v17 + 10240) <= 0x7FFu )
            {
              if ( !v45 || !v44 )
              {
                v13 = v16;
                v41 = 6;
                goto LABEL_22;
              }
              a1 = (int)v45;
              v41 = 6;
              ++*v45;
            }
            else
            {
              *(_DWORD *)v14 = (unsigned __int16)v17;
              v14 = v15;
            }
            if ( (unsigned __int16 *)a6 == v13 )
              goto LABEL_22;
            if ( a6 < (unsigned int)(v13 + 1) )
              break;
            v15 = v14 + 4;
            if ( v36 < (unsigned int)(v14 + 4) )
            {
              v41 = 5;
              goto LABEL_22;
            }
            v16 = v13++;
          }
          v41 = 7;
        }
      }
      while ( 1 )
      {
LABEL_22:
        *a5 = (int)v13;
        if ( a7 )
        {
          result = v41;
          *a7 = (unsigned int)v14;
          return result;
        }
        v18 = (int *)a4[8];
        if ( v18 )
        {
          a1 = v38;
          do
          {
            if ( v18[1] )
            {
              dl_mcount_wrapper_check(v18[1]);
              ((void (__cdecl *)(int, int, int, unsigned int, char *))v18[1])(v18[3], v38, *a5, v37, v14);
            }
            v18 = (int *)v18[4];
          }
          while ( v18 );
        }
        ++a4[3];
        if ( (a4[2] & 1) != 0 )
        {
          v33 = v46;
          *a4 = (unsigned int)v14;
          *a8 += v33;
          goto LABEL_36;
        }
        if ( (unsigned int)v14 <= v37 )
          goto LABEL_36;
        v47 = (char *)*a4;
        dl_mcount_wrapper_check((int)v40);
        a1 = (int)(a4 + 9);
        v19 = v40(v42, v43, &v47, v14, 0, a8, 0, a10);
        if ( v19 == 4 )
        {
          if ( v41 != 5 )
            goto LABEL_36;
        }
        else if ( v47 == v14 )
        {
          if ( v19 )
            goto LABEL_69;
        }
        else
        {
          *a5 -= (v14 - v47) / 2;
          if ( v19 )
          {
LABEL_69:
            v41 = v19;
LABEL_36:
            if ( v41 == 7 && a10 )
            {
              v20 = *a5;
              if ( (int)(a6 - *a5) > 3 )
                _assert_fail(
                  a1,
                  a2,
                  (int)"inend - *inptrp < 4",
                  (int)"../iconv/skeleton.c",
                  786,
                  "__gconv_transform_ucs2_internal");
              v21 = 0;
              v22 = (char *)*a5;
              if ( a6 <= v20 )
              {
                v24 = 0;
              }
              else
              {
                do
                {
                  v23 = *v22++;
                  *(_BYTE *)(a4[5] + v21++ + 4) = v23;
                  *a5 = (int)v22;
                }
                while ( v22 != (char *)a6 );
                v24 = (unsigned int)&v22[-v20];
              }
              *(_DWORD *)a4[5] = v24 | *(_DWORD *)a4[5] & 0xFFFFFFF8;
              return 7;
            }
            return v41;
          }
        }
        v37 = *a4;
        v38 = *a5;
        v10 = a4[2];
        if ( a6 != *a5 )
          goto LABEL_13;
LABEL_34:
        v14 = (char *)v37;
        v13 = (unsigned __int16 *)a6;
        v41 = 4;
      }
    }
    if ( a7 )
      _assert_fail(
        a1,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        559,
        "__gconv_transform_ucs2_internal");
    v26 = *v12 & 7;
    v27 = 0;
    v39 = (char *)*a5;
    do
    {
      *((_BYTE *)v48 + v27) = *((_BYTE *)v12 + v27 + 4);
      ++v27;
    }
    while ( v27 != a1 );
    v28 = v39;
    if ( a6 >= (unsigned int)&v39[-v27 + 2] )
    {
      v41 = 5;
      a1 = v37 + 4;
      if ( v36 < v37 + 4 )
        return v41;
      v29 = v39;
      do
      {
        v30 = *v29++;
        *((_BYTE *)v48 + v26++) = v30;
      }
      while ( a6 > (unsigned int)v29 && v26 <= 1 );
      if ( (unsigned __int16)(v48[0] + 10240) <= 0x7FFu )
      {
        v41 = 6;
        if ( !v45 || (v10 & 2) == 0 )
          return v41;
        ++*v45;
      }
      else
      {
        v31 = (_DWORD *)v37;
        v37 += 4;
        *v31 = (unsigned __int16)v48[0];
      }
      v32 = *v12;
      if ( (*v12 & 7) > 1 )
        _assert_fail(
          a1,
          a2,
          (int)"inptr - bytebuf > (state->__count & 7)",
          (int)"../iconv/loop.c",
          448,
          "ucs2_internal_loop_single");
      v38 = (int)&v39[-(*v12 & 7) + 2];
      *a5 = v38;
      *v12 = v32 & 0xFFFFFFF8;
      v10 = a4[2];
      goto LABEL_12;
    }
    v41 = 7;
    *a5 = a6;
    if ( a6 > (unsigned int)v39 )
    {
      do
      {
        v35 = *v28++;
        *((_BYTE *)v12 + v26++ + 4) = v35;
      }
      while ( v28 != (char *)a6 );
      return 7;
    }
    return v41;
  }
}
// 8095930: using guessed type char *var_24;

//----- (08095FB0) --------------------------------------------------------
int __usercall _gconv_transform_internal_ucs2@<eax>(
        int a1@<ebp>,
        long double a2@<st0>,
        int a3,
        int a4,
        int *a5,
        unsigned int a6,
        unsigned int **a7,
        _DWORD *a8,
        int a9,
        int a10)
{
  unsigned int v10; // esi
  int v11; // edi
  int *v12; // eax
  unsigned int v13; // ebx
  int v14; // ebp
  unsigned int *v15; // eax
  unsigned int *v16; // ebx
  int v17; // edi
  int v18; // ecx
  unsigned int v19; // edx
  int v20; // eax
  int *v21; // edi
  int v22; // eax
  unsigned int v23; // edx
  int v24; // ecx
  char *v25; // eax
  char v26; // bl
  unsigned int v27; // eax
  int result; // eax
  int *v29; // edi
  int v30; // eax
  int *v31; // ebx
  int v32; // eax
  char *v33; // edx
  unsigned int v34; // ecx
  int *v35; // ebp
  char v36; // al
  char *v37; // ecx
  unsigned int *v38; // eax
  unsigned int *v39; // edx
  int v40; // eax
  int v41; // edx
  int v42; // ecx
  int v43; // edx
  _DWORD *v44; // eax
  int v45; // eax
  unsigned int v46; // edx
  int *v47; // esi
  char *v48; // ebx
  int v49; // eax
  char v50; // al
  int v51; // eax
  signed int v52; // edx
  int v53; // ebp
  unsigned int *v54; // eax
  char v55; // dl
  unsigned int v56; // [esp+24h] [ebp-58h]
  unsigned int v57; // [esp+28h] [ebp-54h]
  unsigned int *v58; // [esp+2Ch] [ebp-50h]
  int v59; // [esp+30h] [ebp-4Ch]
  int v60; // [esp+34h] [ebp-48h]
  int v61; // [esp+34h] [ebp-48h]
  int (__cdecl *v62)(int, int, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int); // [esp+38h] [ebp-44h]
  int v63; // [esp+3Ch] [ebp-40h]
  int v64; // [esp+40h] [ebp-3Ch]
  int v65; // [esp+44h] [ebp-38h]
  int *v66; // [esp+48h] [ebp-34h]
  int v67; // [esp+50h] [ebp-2Ch] BYREF
  unsigned int *v68; // [esp+54h] [ebp-28h] BYREF
  unsigned int *v69; // [esp+58h] [ebp-24h] BYREF
  unsigned int v70; // [esp+5Ch] [ebp-20h] BYREF
  char v71[28]; // [esp+60h] [ebp-1Ch] BYREF

  v10 = a6;
  v63 = a3 + 60;
  v64 = a4 + 36;
  v62 = 0;
  v11 = *(_DWORD *)(a4 + 8);
  if ( (v11 & 1) == 0 )
  {
    a1 = *(_DWORD *)(a3 + 60);
    v62 = *(int (__cdecl **)(int, int, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int))(a3 + 80);
    if ( a1 )
      v62 = (int (__cdecl *)(int, int, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a3 + 80), 9));
  }
  if ( a9 )
  {
    if ( a7 )
      _assert_fail(
        a1,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        416,
        "__gconv_transform_internal_ucs2");
    v44 = *(_DWORD **)(a4 + 20);
    *v44 = 0;
    v44[1] = 0;
    v60 = 0;
    if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
      return v60;
    dl_mcount_wrapper_check((int)v62);
    return v62(v63, v64, 0, 0, 0, a8, a9, a10);
  }
  if ( a7 )
    v58 = *a7;
  else
    v58 = *(unsigned int **)a4;
  v12 = &v67;
  v13 = *(_DWORD *)(a4 + 4);
  if ( !a8 )
    v12 = 0;
  v67 = 0;
  v57 = v13;
  v66 = v12;
  if ( !a10 )
  {
    v59 = *a5;
    goto LABEL_11;
  }
  v31 = *(int **)(a4 + 20);
  v61 = *v31 & 7;
  if ( !v61 )
  {
    v59 = *a5;
    goto LABEL_11;
  }
  if ( a7 )
    _assert_fail(
      *v31 & 7,
      a2,
      (int)"outbufstart == ((void *)0)",
      (int)"../iconv/skeleton.c",
      559,
      "__gconv_transform_internal_ucs2");
  v32 = 0;
  v33 = (char *)*a5;
  v34 = *v31 & 7;
  v69 = v58;
  v68 = (unsigned int *)v33;
  do
  {
    v71[v32 - 4] = *((_BYTE *)v31 + v32 + 4);
    ++v32;
  }
  while ( v32 != v61 );
  if ( a6 < (unsigned int)&v33[-v32 + 4] )
  {
    v60 = 7;
    *a5 = a6;
    if ( a6 <= (unsigned int)v33 )
      return v60;
    do
    {
      v50 = *v33++;
      *((_BYTE *)v31 + v34++ + 4) = v50;
      v68 = (unsigned int *)v33;
    }
    while ( v33 != (char *)a6 );
    return 7;
  }
  v60 = 5;
  v35 = (int *)((char *)v58 + 2);
  if ( v57 < (unsigned int)v58 + 2 )
    return v60;
  do
  {
    v36 = *v33++;
    v68 = (unsigned int *)v33;
    v71[v34++ - 4] = v36;
  }
  while ( a6 > (unsigned int)v33 && v34 <= 3 );
  v37 = &v71[v34 - 4];
  v68 = &v70;
  if ( v70 <= 0xFFFF )
  {
    if ( v70 - 55296 <= 0x7FF )
    {
      v60 = 6;
      if ( !v66 || (v11 & 2) == 0 )
        return v60;
      v35 = (int *)v71;
      v68 = (unsigned int *)v71;
      v38 = (unsigned int *)v71;
      ++*v66;
      goto LABEL_68;
    }
    *(_WORD *)v58 = v70;
    v69 = (unsigned int *)((char *)v58 + 2);
    v68 = (unsigned int *)v71;
LABEL_67:
    v38 = (unsigned int *)v71;
LABEL_68:
    v39 = v38;
    v40 = *v31;
    v41 = (char *)v39 - (char *)&v70;
    v42 = *v31 & 7;
    if ( v41 <= v42 )
      _assert_fail(
        (int)v35,
        a2,
        (int)"inptr - bytebuf > (state->__count & 7)",
        (int)"../iconv/loop.c",
        448,
        "internal_ucs2_loop_single");
    v58 = v69;
    v43 = *a5 + v41 - v42;
    *a5 = v43;
    v59 = v43;
    *v31 = v40 & 0xFFFFFFF8;
    v11 = *(_DWORD *)(a4 + 8);
    goto LABEL_11;
  }
  if ( v70 >> 7 == 7168 )
  {
    v68 = (unsigned int *)v71;
    goto LABEL_67;
  }
  if ( !v66 )
    return 6;
  v35 = *(int **)(a4 + 32);
  if ( v35 )
  {
    v46 = a6;
    v47 = v31;
    v48 = v37;
    while ( 1 )
    {
      v56 = v46;
      dl_mcount_wrapper_check(*v35);
      v49 = ((int (__cdecl *)(int, int, int, int, unsigned int **, char *, unsigned int **, int *))*v35)(
              a3,
              a4,
              v35[3],
              *a5,
              &v68,
              v48,
              &v69,
              v66);
      v46 = v56;
      if ( v49 != 6 )
        break;
      v35 = (int *)v35[4];
      if ( !v35 )
      {
        v38 = v68;
        v37 = v48;
        v31 = v47;
        v10 = v56;
        goto LABEL_97;
      }
    }
    v60 = v49;
    v37 = v48;
    v38 = v68;
    v31 = v47;
    v10 = v56;
  }
  else
  {
    v38 = &v70;
LABEL_97:
    v60 = 6;
    if ( (v11 & 2) != 0 )
    {
      v68 = ++v38;
      ++*v66;
    }
  }
  if ( v38 != &v70 )
    goto LABEL_68;
  if ( v60 == 7 )
  {
    if ( v37 == v71 )
      _assert_fail((int)v35, a2, (int)"inend != &bytebuf[4]", (int)"../iconv/loop.c", 466, "internal_ucs2_loop_single");
    v51 = v37 - (char *)v38;
    v52 = *v31 & 0xFFFFFFF8;
    v53 = v51 - (*v31 & 7);
    *a5 += v53;
    if ( v51 <= v52 )
      _assert_fail(
        v53,
        a2,
        (int)"inend - inptr > (state->__count & ~7)",
        (int)"../iconv/loop.c",
        476,
        "internal_ucs2_loop_single");
    if ( v51 > 7 )
      _assert_fail(v53, a2, (int)"inend - inptr <= 7", (int)"../iconv/loop.c", 477, "internal_ucs2_loop_single");
    *v31 = v52 | v51;
    v54 = v68;
    if ( v37 <= (char *)v68 )
      return v60;
    do
    {
      v55 = *(_BYTE *)v54;
      v54 = (unsigned int *)((char *)v54 + 1);
      *((_BYTE *)v31 + 4) = v55;
      v31 = (int *)((char *)v31 + 1);
      v68 = v54;
    }
    while ( v54 != (unsigned int *)v37 );
    return 7;
  }
  if ( v60 )
    return v60;
  while ( 2 )
  {
    v11 = *(_DWORD *)(a4 + 8);
    v59 = *a5;
LABEL_11:
    v14 = (int)v58;
    v60 = 4;
    v65 = v11 & 2;
    v69 = (unsigned int *)v59;
    v15 = (unsigned int *)v59;
    v68 = v58;
    v16 = v58;
LABEL_17:
    while ( (unsigned int *)v10 != v15 )
    {
      v17 = (int)(v15 + 1);
      if ( v10 < (unsigned int)(v15 + 1) )
      {
        v60 = 7;
        break;
      }
      v18 = (int)v16 + 2;
      if ( v57 < (unsigned int)v16 + 2 )
      {
        v60 = 5;
        break;
      }
      v19 = *v15;
      if ( *v15 > 0xFFFF )
      {
        if ( v19 >> 7 == 7168 )
        {
          v69 = ++v15;
        }
        else
        {
          v14 = (int)v66;
          if ( !v66 )
            goto LABEL_45;
          v29 = *(int **)(a4 + 32);
          if ( v29 )
          {
            v14 = a4;
            while ( 1 )
            {
              dl_mcount_wrapper_check(*v29);
              v30 = ((int (__cdecl *)(int, int, int, int, unsigned int **, unsigned int, unsigned int **, int *))*v29)(
                      a3,
                      a4,
                      v29[3],
                      *a5,
                      &v69,
                      v10,
                      &v68,
                      v66);
              if ( v30 != 6 )
                break;
              v29 = (int *)v29[4];
              if ( !v29 )
              {
                v15 = v69;
                v16 = v68;
                goto LABEL_74;
              }
            }
            v60 = v30;
            if ( v30 != 5 )
            {
              v16 = v68;
              v15 = v69;
              goto LABEL_17;
            }
            v15 = v69;
            v16 = v68;
            break;
          }
LABEL_74:
          if ( !v65 )
            goto LABEL_45;
          v69 = ++v15;
          v60 = 6;
          ++*v66;
        }
      }
      else
      {
        v14 = v19 - 55296;
        if ( v19 - 55296 <= 0x7FF )
        {
          if ( !v66 || !v65 )
          {
LABEL_45:
            v60 = 6;
            break;
          }
          v14 = (int)v66;
          ++v15;
          v69 = (unsigned int *)v17;
          v60 = 6;
          ++*v66;
        }
        else
        {
          v20 = (int)v69;
          *(_WORD *)v16 = v19;
          v16 = (unsigned int *)((char *)v16 + 2);
          v68 = (unsigned int *)v18;
          v15 = (unsigned int *)(v20 + 4);
          v69 = v15;
        }
      }
    }
    *a5 = (int)v15;
    if ( !a7 )
    {
      v21 = *(int **)(a4 + 32);
      if ( v21 )
      {
        v14 = v59;
        do
        {
          if ( v21[1] )
          {
            dl_mcount_wrapper_check(v21[1]);
            ((void (__cdecl *)(int, int, int, unsigned int *, unsigned int *))v21[1])(v21[3], v59, *a5, v58, v16);
          }
          v21 = (int *)v21[4];
        }
        while ( v21 );
      }
      ++*(_DWORD *)(a4 + 12);
      if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
      {
        v14 = (int)a8;
        v45 = v67;
        *(_DWORD *)a4 = v16;
        *a8 += v45;
      }
      else
      {
        if ( v58 < v16 )
        {
          v68 = *(unsigned int **)a4;
          dl_mcount_wrapper_check((int)v62);
          v14 = (int)a8;
          v22 = v62(v63, v64, &v68, v16, 0, a8, 0, a10);
          if ( v22 == 4 )
          {
            if ( v60 == 5 || !v60 )
            {
LABEL_30:
              v58 = *(unsigned int **)a4;
              continue;
            }
            goto LABEL_34;
          }
          v60 = v22;
          if ( v68 != v16 )
            *a5 += 2 * ((char *)v68 - (char *)v16);
        }
        if ( !v60 )
          goto LABEL_30;
      }
LABEL_34:
      if ( v60 != 7 || !a10 )
        return v60;
      v23 = *a5;
      if ( (int)(v10 - *a5) > 3 )
        _assert_fail(
          v14,
          a2,
          (int)"inend - *inptrp < 4",
          (int)"../iconv/skeleton.c",
          786,
          "__gconv_transform_internal_ucs2");
      v24 = 0;
      v25 = (char *)*a5;
      if ( v10 <= v23 )
      {
        v27 = 0;
      }
      else
      {
        do
        {
          v26 = *v25++;
          *(_BYTE *)(*(_DWORD *)(a4 + 20) + v24++ + 4) = v26;
          *a5 = (int)v25;
        }
        while ( v25 != (char *)v10 );
        v27 = (unsigned int)&v25[-v23];
      }
      **(_DWORD **)(a4 + 20) = v27 | **(_DWORD **)(a4 + 20) & 0xFFFFFFF8;
      return 7;
    }
    break;
  }
  result = v60;
  *a7 = v16;
  return result;
}

//----- (08096950) --------------------------------------------------------
int __usercall _gconv_transform_ucs2reverse_internal@<eax>(
        int a1@<ebp>,
        long double a2@<st0>,
        int a3,
        int a4,
        int *a5,
        unsigned int a6,
        char **a7,
        _DWORD *a8,
        int a9,
        int a10)
{
  int v10; // eax
  int *v11; // edx
  _WORD *v12; // edx
  char *v13; // ebx
  char *v14; // ecx
  _WORD *v15; // edi
  unsigned __int16 v16; // ax
  int *j; // edi
  int v18; // eax
  int v19; // ebp
  unsigned int v20; // edx
  int v21; // ecx
  char *v22; // eax
  char v23; // bl
  unsigned int v24; // eax
  unsigned int *v26; // ebx
  int v27; // ebp
  unsigned int v28; // edi
  char *v29; // ecx
  int k; // edx
  char *v31; // edx
  char v32; // bp
  char v33; // al
  char v34; // al
  unsigned __int16 v35; // dx
  int v36; // ebp
  unsigned int v37; // edx
  _DWORD *v38; // eax
  char v39; // al
  unsigned int v40; // [esp+20h] [ebp-4Ch]
  char *v41; // [esp+24h] [ebp-48h]
  int v42; // [esp+28h] [ebp-44h]
  int v43; // [esp+2Ch] [ebp-40h]
  int i; // [esp+2Ch] [ebp-40h]
  int (__cdecl *v45)(int, int, char **, char *, _DWORD, _DWORD *, int, int); // [esp+30h] [ebp-3Ch]
  int v46; // [esp+34h] [ebp-38h]
  int v47; // [esp+38h] [ebp-34h]
  int *v48; // [esp+3Ch] [ebp-30h]
  int v49; // [esp+44h] [ebp-28h] BYREF
  char *v50; // [esp+48h] [ebp-24h] BYREF
  __int16 v51[15]; // [esp+4Eh] [ebp-1Eh]

  v45 = 0;
  v46 = a3 + 60;
  v47 = a4 + 36;
  v10 = *(_DWORD *)(a4 + 8);
  if ( (v10 & 1) == 0 )
  {
    a1 = *(_DWORD *)(a3 + 80);
    v45 = (int (__cdecl *)(int, int, char **, char *, _DWORD, _DWORD *, int, int))a1;
    if ( *(_DWORD *)(a3 + 60) )
    {
      a1 = __readgsdword(0x18u) ^ __ROR4__(a1, 9);
      v45 = (int (__cdecl *)(int, int, char **, char *, _DWORD, _DWORD *, int, int))a1;
    }
  }
  if ( a9 )
  {
    if ( a7 )
      _assert_fail(
        a1,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        416,
        "__gconv_transform_ucs2reverse_internal");
    v19 = 0;
    v38 = *(_DWORD **)(a4 + 20);
    *v38 = 0;
    v38[1] = 0;
    if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
      return v19;
    dl_mcount_wrapper_check((int)v45);
    return v45(v46, v47, 0, 0, 0, a8, a9, a10);
  }
  else
  {
    if ( a7 )
      v41 = *a7;
    else
      v41 = *(char **)a4;
    v11 = &v49;
    v49 = 0;
    v40 = *(_DWORD *)(a4 + 4);
    if ( !a8 )
      v11 = 0;
    v48 = v11;
    if ( !a10 )
    {
      v42 = *a5;
      goto LABEL_11;
    }
    v26 = *(unsigned int **)(a4 + 20);
    v27 = *v26 & 7;
    if ( !v27 )
    {
      v42 = *a5;
LABEL_11:
      if ( a6 == v42 )
        goto LABEL_33;
      while ( 1 )
      {
        v12 = (_WORD *)(v42 + 2);
        if ( a6 < v42 + 2 )
        {
          v13 = v41;
          v12 = (_WORD *)v42;
          i = 7;
          goto LABEL_22;
        }
        v13 = v41;
        v14 = v41 + 4;
        if ( v40 < (unsigned int)(v41 + 4) )
        {
          v12 = (_WORD *)v42;
          i = 5;
          goto LABEL_22;
        }
        v15 = (_WORD *)v42;
        v43 = v10 & 2;
        while ( 1 )
        {
          v16 = __ROR2__(*v15, 8);
          if ( (unsigned __int16)(v16 + 10240) > 0x7FFu )
          {
            *(_DWORD *)v13 = v16;
            v13 = v14;
            goto LABEL_20;
          }
          if ( !v48 || !v43 )
            break;
          ++*v48;
LABEL_20:
          if ( (_WORD *)a6 == v12 )
            goto LABEL_21;
          if ( a6 < (unsigned int)(v12 + 1) )
          {
            i = 7;
            goto LABEL_22;
          }
          v14 = v13 + 4;
          if ( v40 < (unsigned int)(v13 + 4) )
          {
            i = 5;
            goto LABEL_22;
          }
          v15 = v12++;
        }
        v12 = v15;
        for ( i = 6; ; i = 4 )
        {
LABEL_22:
          *a5 = (int)v12;
          if ( a7 )
          {
            *a7 = v13;
            return i;
          }
          for ( j = *(int **)(a4 + 32); j; j = (int *)j[4] )
          {
            if ( j[1] )
            {
              dl_mcount_wrapper_check(j[1]);
              ((void (__cdecl *)(int, int, int, char *, char *))j[1])(j[3], v42, *a5, v41, v13);
            }
          }
          ++*(_DWORD *)(a4 + 12);
          if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
          {
            *(_DWORD *)a4 = v13;
            v19 = i;
            *a8 += v49;
            goto LABEL_36;
          }
          if ( v13 <= v41 )
            goto LABEL_35;
          v50 = *(char **)a4;
          dl_mcount_wrapper_check((int)v45);
          v18 = v45(v46, v47, &v50, v13, 0, a8, 0, a10);
          if ( v18 == 4 )
          {
            if ( i != 5 )
            {
LABEL_35:
              v19 = i;
LABEL_36:
              if ( v19 == 7 && a10 )
              {
                v20 = *a5;
                if ( (int)(a6 - *a5) > 3 )
                  _assert_fail(
                    7,
                    a2,
                    (int)"inend - *inptrp < 4",
                    (int)"../iconv/skeleton.c",
                    786,
                    "__gconv_transform_ucs2reverse_internal");
                v21 = 0;
                v22 = (char *)*a5;
                if ( a6 <= v20 )
                {
                  v24 = 0;
                }
                else
                {
                  do
                  {
                    v23 = *v22++;
                    *(_BYTE *)(*(_DWORD *)(a4 + 20) + v21++ + 4) = v23;
                    *a5 = (int)v22;
                  }
                  while ( v22 != (char *)a6 );
                  v24 = (unsigned int)&v22[-v20];
                }
                **(_DWORD **)(a4 + 20) = v24 | **(_DWORD **)(a4 + 20) & 0xFFFFFFF8;
                return 7;
              }
              return v19;
            }
          }
          else if ( v50 == v13 )
          {
            if ( v18 )
              goto LABEL_77;
          }
          else
          {
            *a5 -= (v13 - v50) / 2;
            if ( v18 )
            {
LABEL_77:
              v19 = v18;
              goto LABEL_36;
            }
          }
          v10 = *(_DWORD *)(a4 + 8);
          v42 = *a5;
          v41 = *(char **)a4;
          if ( a6 != *a5 )
            break;
LABEL_33:
          v13 = v41;
          v12 = (_WORD *)a6;
LABEL_21:
          ;
        }
      }
    }
    if ( a7 )
      _assert_fail(
        v27,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        559,
        "__gconv_transform_ucs2reverse_internal");
    v28 = *v26 & 7;
    v29 = (char *)*a5;
    for ( k = 0; k != v27; ++k )
      *((_BYTE *)v51 + k) = *((_BYTE *)v26 + k + 4);
    if ( a6 >= (unsigned int)&v29[-k + 2] )
    {
      v19 = 5;
      if ( v40 < (unsigned int)(v41 + 4) )
        return v19;
      v31 = v29;
      v32 = v10;
      do
      {
        v33 = *v31++;
        *((_BYTE *)v51 + v28++) = v33;
      }
      while ( a6 > (unsigned int)v31 && v28 <= 1 );
      v34 = v32;
      v35 = __ROR2__(v51[0], 8);
      if ( (unsigned __int16)(v35 + 10240) <= 0x7FFu )
      {
        v19 = 6;
        if ( !v48 || (v34 & 2) == 0 )
          return v19;
        v36 = (int)v48;
        ++*v48;
      }
      else
      {
        v36 = (int)v41;
        *(_DWORD *)v41 = v35;
        v41 += 4;
      }
      v37 = *v26;
      if ( (*v26 & 7) > 1 )
        _assert_fail(
          v36,
          a2,
          (int)"inptr - bytebuf > (state->__count & 7)",
          (int)"../iconv/loop.c",
          448,
          "ucs2reverse_internal_loop_single");
      v42 = (int)&v29[-(*v26 & 7) + 2];
      *a5 = v42;
      *v26 = v37 & 0xFFFFFFF8;
      v10 = *(_DWORD *)(a4 + 8);
      goto LABEL_11;
    }
    v19 = 7;
    *a5 = a6;
    if ( a6 > (unsigned int)v29 )
    {
      do
      {
        v39 = *v29++;
        *((_BYTE *)v26 + v28++ + 4) = v39;
      }
      while ( v29 != (char *)a6 );
      return 7;
    }
    return v19;
  }
}
// 8096950: using guessed type char *var_24;

//----- (08096F90) --------------------------------------------------------
int __usercall _gconv_transform_internal_ucs2reverse@<eax>(
        int a1@<ebp>,
        long double a2@<st0>,
        int a3,
        int a4,
        int *a5,
        unsigned int a6,
        unsigned int **a7,
        _DWORD *a8,
        int a9,
        int a10)
{
  unsigned int v10; // esi
  int v11; // edi
  int *v12; // eax
  unsigned int v13; // ebx
  int v14; // ebp
  unsigned int *v15; // eax
  unsigned int *v16; // ebx
  int v17; // edi
  int v18; // ecx
  unsigned int v19; // edx
  int v20; // eax
  int *v21; // edi
  int v22; // eax
  unsigned int v23; // edx
  int v24; // ecx
  char *v25; // eax
  char v26; // bl
  unsigned int v27; // eax
  int result; // eax
  int *v29; // edi
  int v30; // eax
  int *v31; // ebx
  int v32; // eax
  char *v33; // edx
  unsigned int v34; // ecx
  int *v35; // ebp
  char v36; // al
  char *v37; // ecx
  unsigned int *v38; // eax
  unsigned int *v39; // edx
  int v40; // eax
  int v41; // edx
  int v42; // ecx
  int v43; // edx
  _DWORD *v44; // eax
  int v45; // eax
  unsigned int v46; // edx
  int *v47; // esi
  char *v48; // ebx
  int v49; // eax
  char v50; // al
  int v51; // eax
  signed int v52; // edx
  int v53; // ebp
  unsigned int *v54; // eax
  char v55; // dl
  unsigned int v56; // [esp+24h] [ebp-58h]
  unsigned int v57; // [esp+28h] [ebp-54h]
  unsigned int *v58; // [esp+2Ch] [ebp-50h]
  int v59; // [esp+30h] [ebp-4Ch]
  int v60; // [esp+34h] [ebp-48h]
  int v61; // [esp+34h] [ebp-48h]
  int (__cdecl *v62)(int, int, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int); // [esp+38h] [ebp-44h]
  int v63; // [esp+3Ch] [ebp-40h]
  int v64; // [esp+40h] [ebp-3Ch]
  int v65; // [esp+44h] [ebp-38h]
  int *v66; // [esp+48h] [ebp-34h]
  int v67; // [esp+50h] [ebp-2Ch] BYREF
  unsigned int *v68; // [esp+54h] [ebp-28h] BYREF
  unsigned int *v69; // [esp+58h] [ebp-24h] BYREF
  unsigned int v70; // [esp+5Ch] [ebp-20h] BYREF
  char v71[28]; // [esp+60h] [ebp-1Ch] BYREF

  v10 = a6;
  v63 = a3 + 60;
  v64 = a4 + 36;
  v62 = 0;
  v11 = *(_DWORD *)(a4 + 8);
  if ( (v11 & 1) == 0 )
  {
    a1 = *(_DWORD *)(a3 + 60);
    v62 = *(int (__cdecl **)(int, int, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int))(a3 + 80);
    if ( a1 )
      v62 = (int (__cdecl *)(int, int, unsigned int **, unsigned int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a3 + 80), 9));
  }
  if ( a9 )
  {
    if ( a7 )
      _assert_fail(
        a1,
        a2,
        (int)"outbufstart == ((void *)0)",
        (int)"../iconv/skeleton.c",
        416,
        "__gconv_transform_internal_ucs2reverse");
    v44 = *(_DWORD **)(a4 + 20);
    *v44 = 0;
    v44[1] = 0;
    v60 = 0;
    if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
      return v60;
    dl_mcount_wrapper_check((int)v62);
    return v62(v63, v64, 0, 0, 0, a8, a9, a10);
  }
  if ( a7 )
    v58 = *a7;
  else
    v58 = *(unsigned int **)a4;
  v12 = &v67;
  v13 = *(_DWORD *)(a4 + 4);
  if ( !a8 )
    v12 = 0;
  v67 = 0;
  v57 = v13;
  v66 = v12;
  if ( !a10 )
  {
    v59 = *a5;
    goto LABEL_11;
  }
  v31 = *(int **)(a4 + 20);
  v61 = *v31 & 7;
  if ( !v61 )
  {
    v59 = *a5;
    goto LABEL_11;
  }
  if ( a7 )
    _assert_fail(
      *v31 & 7,
      a2,
      (int)"outbufstart == ((void *)0)",
      (int)"../iconv/skeleton.c",
      559,
      "__gconv_transform_internal_ucs2reverse");
  v32 = 0;
  v33 = (char *)*a5;
  v34 = *v31 & 7;
  v69 = v58;
  v68 = (unsigned int *)v33;
  do
  {
    v71[v32 - 4] = *((_BYTE *)v31 + v32 + 4);
    ++v32;
  }
  while ( v32 != v61 );
  if ( a6 < (unsigned int)&v33[-v32 + 4] )
  {
    v60 = 7;
    *a5 = a6;
    if ( a6 <= (unsigned int)v33 )
      return v60;
    do
    {
      v50 = *v33++;
      *((_BYTE *)v31 + v34++ + 4) = v50;
      v68 = (unsigned int *)v33;
    }
    while ( v33 != (char *)a6 );
    return 7;
  }
  v60 = 5;
  v35 = (int *)((char *)v58 + 2);
  if ( v57 < (unsigned int)v58 + 2 )
    return v60;
  do
  {
    v36 = *v33++;
    v68 = (unsigned int *)v33;
    v71[v34++ - 4] = v36;
  }
  while ( a6 > (unsigned int)v33 && v34 <= 3 );
  v37 = &v71[v34 - 4];
  v68 = &v70;
  if ( v70 <= 0xFFFF )
  {
    if ( v70 - 55296 <= 0x7FF )
    {
      v60 = 6;
      if ( !v66 || (v11 & 2) == 0 )
        return v60;
      v35 = (int *)v71;
      v68 = (unsigned int *)v71;
      v38 = (unsigned int *)v71;
      ++*v66;
      goto LABEL_68;
    }
    *(_WORD *)v58 = __ROR2__(v70, 8);
    v69 = (unsigned int *)((char *)v58 + 2);
    v68 = (unsigned int *)v71;
LABEL_67:
    v38 = (unsigned int *)v71;
LABEL_68:
    v39 = v38;
    v40 = *v31;
    v41 = (char *)v39 - (char *)&v70;
    v42 = *v31 & 7;
    if ( v41 <= v42 )
      _assert_fail(
        (int)v35,
        a2,
        (int)"inptr - bytebuf > (state->__count & 7)",
        (int)"../iconv/loop.c",
        448,
        "internal_ucs2reverse_loop_single");
    v58 = v69;
    v43 = *a5 + v41 - v42;
    *a5 = v43;
    v59 = v43;
    *v31 = v40 & 0xFFFFFFF8;
    v11 = *(_DWORD *)(a4 + 8);
    goto LABEL_11;
  }
  if ( v70 >> 7 == 7168 )
  {
    v68 = (unsigned int *)v71;
    goto LABEL_67;
  }
  if ( !v66 )
    return 6;
  v35 = *(int **)(a4 + 32);
  if ( v35 )
  {
    v46 = a6;
    v47 = v31;
    v48 = v37;
    while ( 1 )
    {
      v56 = v46;
      dl_mcount_wrapper_check(*v35);
      v49 = ((int (__cdecl *)(int, int, int, int, unsigned int **, char *, unsigned int **, int *))*v35)(
              a3,
              a4,
              v35[3],
              *a5,
              &v68,
              v48,
              &v69,
              v66);
      v46 = v56;
      if ( v49 != 6 )
        break;
      v35 = (int *)v35[4];
      if ( !v35 )
      {
        v38 = v68;
        v37 = v48;
        v31 = v47;
        v10 = v56;
        goto LABEL_97;
      }
    }
    v60 = v49;
    v37 = v48;
    v38 = v68;
    v31 = v47;
    v10 = v56;
  }
  else
  {
    v38 = &v70;
LABEL_97:
    v60 = 6;
    if ( (v11 & 2) != 0 )
    {
      v68 = ++v38;
      ++*v66;
    }
  }
  if ( v38 != &v70 )
    goto LABEL_68;
  if ( v60 == 7 )
  {
    if ( v37 == v71 )
      _assert_fail(
        (int)v35,
        a2,
        (int)"inend != &bytebuf[4]",
        (int)"../iconv/loop.c",
        466,
        "internal_ucs2reverse_loop_single");
    v51 = v37 - (char *)v38;
    v52 = *v31 & 0xFFFFFFF8;
    v53 = v51 - (*v31 & 7);
    *a5 += v53;
    if ( v51 <= v52 )
      _assert_fail(
        v53,
        a2,
        (int)"inend - inptr > (state->__count & ~7)",
        (int)"../iconv/loop.c",
        476,
        "internal_ucs2reverse_loop_single");
    if ( v51 > 7 )
      _assert_fail(v53, a2, (int)"inend - inptr <= 7", (int)"../iconv/loop.c", 477, "internal_ucs2reverse_loop_single");
    *v31 = v52 | v51;
    v54 = v68;
    if ( v37 <= (char *)v68 )
      return v60;
    do
    {
      v55 = *(_BYTE *)v54;
      v54 = (unsigned int *)((char *)v54 + 1);
      *((_BYTE *)v31 + 4) = v55;
      v31 = (int *)((char *)v31 + 1);
      v68 = v54;
    }
    while ( v54 != (unsigned int *)v37 );
    return 7;
  }
  if ( v60 )
    return v60;
  while ( 2 )
  {
    v11 = *(_DWORD *)(a4 + 8);
    v59 = *a5;
LABEL_11:
    v14 = (int)v58;
    v60 = 4;
    v65 = v11 & 2;
    v69 = (unsigned int *)v59;
    v15 = (unsigned int *)v59;
    v68 = v58;
    v16 = v58;
LABEL_17:
    while ( (unsigned int *)v10 != v15 )
    {
      v17 = (int)(v15 + 1);
      if ( v10 < (unsigned int)(v15 + 1) )
      {
        v60 = 7;
        break;
      }
      v18 = (int)v16 + 2;
      if ( v57 < (unsigned int)v16 + 2 )
      {
        v60 = 5;
        break;
      }
      v19 = *v15;
      if ( *v15 > 0xFFFF )
      {
        if ( v19 >> 7 == 7168 )
        {
          v69 = ++v15;
        }
        else
        {
          if ( !v66 )
            goto LABEL_45;
          v29 = *(int **)(a4 + 32);
          if ( v29 )
          {
            v14 = a4;
            while ( 1 )
            {
              dl_mcount_wrapper_check(*v29);
              v30 = ((int (__cdecl *)(int, int, int, int, unsigned int **, unsigned int, unsigned int **, int *))*v29)(
                      a3,
                      a4,
                      v29[3],
                      *a5,
                      &v69,
                      v10,
                      &v68,
                      v66);
              if ( v30 != 6 )
                break;
              v29 = (int *)v29[4];
              if ( !v29 )
              {
                v15 = v69;
                v16 = v68;
                goto LABEL_74;
              }
            }
            v60 = v30;
            if ( v30 != 5 )
            {
              v16 = v68;
              v15 = v69;
              goto LABEL_17;
            }
            v15 = v69;
            v16 = v68;
            break;
          }
LABEL_74:
          if ( !v65 )
            goto LABEL_45;
          v69 = ++v15;
          v60 = 6;
          ++*v66;
        }
      }
      else
      {
        v14 = v19 - 55296;
        if ( v19 - 55296 <= 0x7FF )
        {
          if ( !v66 || (v14 = v65) == 0 )
          {
LABEL_45:
            v60 = 6;
            break;
          }
          v14 = (int)v66;
          ++v15;
          v69 = (unsigned int *)v17;
          ++*v66;
        }
        else
        {
          v20 = (int)v69;
          *(_WORD *)v16 = __ROR2__(v19, 8);
          v16 = (unsigned int *)((char *)v16 + 2);
          v68 = (unsigned int *)v18;
          v15 = (unsigned int *)(v20 + 4);
          v69 = v15;
        }
      }
    }
    *a5 = (int)v15;
    if ( !a7 )
    {
      v21 = *(int **)(a4 + 32);
      if ( v21 )
      {
        v14 = v59;
        do
        {
          if ( v21[1] )
          {
            dl_mcount_wrapper_check(v21[1]);
            ((void (__cdecl *)(int, int, int, unsigned int *, unsigned int *))v21[1])(v21[3], v59, *a5, v58, v16);
          }
          v21 = (int *)v21[4];
        }
        while ( v21 );
      }
      ++*(_DWORD *)(a4 + 12);
      if ( (*(_BYTE *)(a4 + 8) & 1) != 0 )
      {
        v14 = (int)a8;
        v45 = v67;
        *(_DWORD *)a4 = v16;
        *a8 += v45;
      }
      else
      {
        if ( v16 > v58 )
        {
          v68 = *(unsigned int **)a4;
          dl_mcount_wrapper_check((int)v62);
          v14 = (int)a8;
          v22 = v62(v63, v64, &v68, v16, 0, a8, 0, a10);
          if ( v22 == 4 )
          {
            if ( v60 == 5 || !v60 )
            {
LABEL_30:
              v58 = *(unsigned int **)a4;
              continue;
            }
            goto LABEL_34;
          }
          v60 = v22;
          if ( v68 != v16 )
            *a5 += 2 * ((char *)v68 - (char *)v16);
        }
        if ( !v60 )
          goto LABEL_30;
      }
LABEL_34:
      if ( v60 != 7 || !a10 )
        return v60;
      v23 = *a5;
      if ( (int)(v10 - *a5) > 3 )
        _assert_fail(
          v14,
          a2,
          (int)"inend - *inptrp < 4",
          (int)"../iconv/skeleton.c",
          786,
          "__gconv_transform_internal_ucs2reverse");
      v24 = 0;
      v25 = (char *)*a5;
      if ( v10 <= v23 )
      {
        v27 = 0;
      }
      else
      {
        do
        {
          v26 = *v25++;
          *(_BYTE *)(*(_DWORD *)(a4 + 20) + v24++ + 4) = v26;
          *a5 = (int)v25;
        }
        while ( v25 != (char *)v10 );
        v27 = (unsigned int)&v25[-v23];
      }
      **(_DWORD **)(a4 + 20) = v27 | **(_DWORD **)(a4 + 20) & 0xFFFFFFF8;
      return 7;
    }
    break;
  }
  result = v60;
  *a7 = v16;
  return result;
}

//----- (08097930) --------------------------------------------------------
int __usercall open_translit@<eax>(_DWORD *a1@<eax>, int a2@<ebp>, int a3@<edi>, int a4@<esi>)
{
  int v5; // edx
  int result; // eax
  int (__cdecl *v7)(_DWORD, _DWORD *, _DWORD *); // eax
  int v8; // eax
  int v9; // eax

  v5 = _libc_dlopen_mode((int)a1, a2, a3, a4, a1[8], -2147483647);
  a1[9] = v5;
  result = 1;
  if ( v5 )
  {
    v7 = (int (__cdecl *)(_DWORD, _DWORD *, _DWORD *))_libc_dlsym(v5, "gconv_trans_context");
    if ( v7 && !v7(*a1, a1 + 2, a1 + 3) && (v8 = _libc_dlsym(a1[9], "gconv_trans"), (a1[4] = v8) != 0) )
    {
      a1[6] = _libc_dlsym(a1[9], "gconv_trans_init");
      a1[5] = _libc_dlsym(a1[9], "gconv_trans_context");
      v9 = _libc_dlsym(a1[9], "gconv_trans_end");
      a1[10] = 1;
      a1[7] = v9;
      return 0;
    }
    else
    {
      _libc_dlclose((int)a1, a2, a3, a4, a1[9]);
      result = 1;
      a1[9] = 0;
    }
  }
  return result;
}
// 80AE1F0: using guessed type _DWORD __cdecl _libc_dlsym(_DWORD, _DWORD);

//----- (08097A10) --------------------------------------------------------
int __cdecl trans_compare(char *s1, char *s2)
{
  return strcmp(*(const char **)s1, *(const char **)s2);
}

//----- (08097A30) --------------------------------------------------------
int __cdecl _gconv_transliterate(
        _DWORD *a1,
        int a2,
        int a3,
        int a4,
        unsigned int **a5,
        unsigned int a6,
        int *a7,
        _DWORD *a8)
{
  unsigned int v8; // edx
  _DWORD *v9; // ebx
  int v10; // edi
  int v11; // esi
  unsigned int *v12; // eax
  int *v13; // ecx
  int v14; // edx
  unsigned int *v15; // ebx
  unsigned int v16; // edx
  int v18; // ebx
  int v19; // eax
  int v20; // ecx
  _DWORD *v21; // ebp
  _DWORD *v22; // eax
  int v23; // eax
  int v24; // eax
  _DWORD *v25; // ecx
  int v26; // ebp
  _DWORD *v27; // ecx
  unsigned int v28; // edi
  int v29; // esi
  int v30; // ebx
  int v31; // esi
  int v32; // eax
  _DWORD *v33; // [esp+28h] [ebp-54h]
  unsigned int v34; // [esp+28h] [ebp-54h]
  int (__cdecl *v35)(_DWORD *, int, int *, int, int *, _DWORD, _DWORD, _DWORD); // [esp+2Ch] [ebp-50h]
  unsigned int v36; // [esp+30h] [ebp-4Ch]
  unsigned int *v37; // [esp+34h] [ebp-48h]
  int v38; // [esp+38h] [ebp-44h]
  unsigned int v39; // [esp+3Ch] [ebp-40h]
  int v40; // [esp+40h] [ebp-3Ch]
  int v41; // [esp+44h] [ebp-38h]
  int v42; // [esp+4Ch] [ebp-30h]
  int v43; // [esp+58h] [ebp-24h] BYREF
  int v44[8]; // [esp+5Ch] [ebp-20h] BYREF

  v37 = *a5;
  v35 = (int (__cdecl *)(_DWORD *, int, int *, int, int *, _DWORD, _DWORD, _DWORD))a1[5];
  if ( *a1 )
    v35 = (int (__cdecl *)(_DWORD *, int, int *, int, int *, _DWORD, _DWORD, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v35, 9));
  v8 = __readgsdword(0xFFFFFFDC);
  v9 = *(_DWORD **)v8;
  v33 = (_DWORD *)v8;
  if ( !*(_DWORD *)(*(_DWORD *)v8 + 280) )
  {
LABEL_26:
    v26 = v9[77];
    if ( v26 )
    {
      v27 = (_DWORD *)v9[78];
      v28 = **a5;
      if ( a6 < (unsigned int)(v37 + 1) )
        return 3 * (v37 != (unsigned int *)a6) + 4;
      v29 = 0;
      if ( v26 > 0 )
      {
        while ( v28 >= *v27 )
        {
          if ( v28 <= v27[1] )
          {
            v16 = (v28 - *v27) % v27[2];
            if ( !v16 )
            {
              ++*a5;
              ++*a8;
              return v16;
            }
          }
          ++v29;
          v27 += 3;
          if ( v26 == v29 )
            break;
        }
      }
    }
    v16 = 6;
    if ( !v9[75] )
      return v16;
    v30 = v9[76];
    v44[0] = v30;
    v31 = *(_DWORD *)(*v33 + 300);
    if ( a6 >= (unsigned int)(v37 + 1) )
    {
      v43 = *a7;
      dl_mcount_wrapper_check((int)v35);
      v32 = v35(a1, a2, v44, v30 + 4 * v31, &v43, 0, 0, 0);
      v16 = 6;
      if ( v32 != 6 )
      {
        if ( v32 == 4 )
        {
          LOBYTE(v32) = 0;
          ++*a8;
          ++*a5;
        }
        *a7 = v43;
        return v32;
      }
      return v16;
    }
    return 3 * (v37 != (unsigned int *)a6) + 4;
  }
  v10 = v9[74];
  v39 = v9[70];
  v40 = v9[72];
  v41 = v9[71];
  v36 = 0;
  v42 = v9[73];
  if ( a6 < (unsigned int)(v37 + 1) )
    return 3 * (v37 != (unsigned int *)a6) + 4;
  while ( 1 )
  {
    v11 = 0;
    v12 = v37;
    v34 = (v39 + v36) >> 1;
    v38 = *(_DWORD *)(v41 + 4 * v34);
    v13 = (int *)(v40 + 4 * v38);
    v14 = *v13;
    while ( 1 )
    {
      v15 = v12;
      if ( *v12 != v14 )
        break;
      v14 = v13[++v11];
      if ( !v14 )
        goto LABEL_13;
      if ( a6 <= (unsigned int)++v12 )
        return 7;
    }
    if ( v11 )
      break;
LABEL_21:
    if ( a6 <= (unsigned int)v15 || *(_DWORD *)(v40 + 4 * (v38 + v11)) < *v15 )
      v36 = v34 + 1;
    else
      v39 = (v39 + v36) >> 1;
    if ( v36 >= v39 )
    {
      v25 = (_DWORD *)__readgsdword(0xFFFFFFDC);
      v9 = (_DWORD *)*v25;
      v33 = v25;
      goto LABEL_26;
    }
  }
  if ( v14 )
    return 7;
LABEL_13:
  v18 = *(_DWORD *)(v42 + 4 * v34);
  v19 = *(_DWORD *)(v10 + 4 * v18);
  while ( 1 )
  {
    v20 = v10 + 4 * v18;
    v21 = (_DWORD *)v20;
    if ( v19 )
    {
      ++v18;
      v22 = (_DWORD *)(v10 + 4 * v18);
      while ( 1 )
      {
        v21 = v22++;
        if ( !*v21 )
          break;
        ++v18;
      }
    }
    v23 = *a7;
    v43 = v20;
    v44[0] = v23;
    dl_mcount_wrapper_check((int)v35);
    v24 = v35(a1, a2, &v43, (int)v21, v44, 0, 0, 0);
    if ( v24 != 6 )
      break;
    ++v18;
    v19 = *(_DWORD *)(v10 + 4 * v18);
    if ( !v19 )
    {
      v15 = &v37[v11];
      goto LABEL_21;
    }
  }
  v16 = v24;
  if ( v24 == 4 )
  {
    LOBYTE(v16) = 0;
    *a5 += v11;
    ++*a8;
    goto LABEL_40;
  }
  if ( v24 == 5 )
    return v16;
LABEL_40:
  *a7 = v44[0];
  return v16;
}

//----- (08097E30) --------------------------------------------------------
void __usercall _gconv_translit_find(_BYTE **a1@<eax>, int a2@<ebp>)
{
  bool v4; // zf
  _DWORD *v5; // eax
  _DWORD **v6; // esi
  _DWORD *v7; // eax
  int v8; // edi
  int v9; // edx
  int v10; // eax
  unsigned int v11; // ebp
  _DWORD *v12; // esi
  _WORD *v13; // eax
  int v14; // edi
  int v15; // ecx
  int v16; // ebx
  unsigned int v17; // edi
  _BYTE *v18; // ebp
  _BYTE *v19; // eax
  _WORD *v20; // eax
  _DWORD *v21; // eax
  int v22; // [esp+14h] [ebp-28h]
  _BOOL4 v23; // [esp+18h] [ebp-24h]
  _BYTE **v24; // [esp+1Ch] [ebp-20h]

  if ( !*a1 )
    _assert_fail("trans->name != ((void *)0)", "gconv_trans.c", 333, "__gconv_translit_find");
  _ECX = 1;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg ds:lock_5, ecx }
  if ( v4 )
  {
    v5 = tfind((int)a1, &search_tree, (int (__cdecl *)(int, _DWORD))trans_compare);
    v6 = (_DWORD **)v5;
    if ( v5 )
    {
      v7 = (_DWORD *)*v5;
      HIWORD(v8) = 0;
      v9 = v7[9];
      if ( v9 )
      {
        LOWORD(v8) = 0;
        if ( v9 == -1 && !open_translit(v7, a2, v8, (int)v6) )
        {
          v21 = *v6;
          *a1 = (_BYTE *)**v6;
          a1[1] = (_BYTE *)v21[1];
          a1[2] = (_BYTE *)v21[2];
          a1[3] = (_BYTE *)v21[3];
          a1[4] = (_BYTE *)v21[4];
          a1[5] = (_BYTE *)v21[5];
          a1[6] = (_BYTE *)v21[6];
          a1[7] = (_BYTE *)v21[7];
          ++(*v6)[10];
        }
      }
    }
    else
    {
      v10 = strlen(*a1);
      v11 = v10 + 1;
      if ( !_gconv_path_elem )
      {
        v22 = v10;
        _gconv_get_path();
        v10 = v22;
      }
      v23 = 1;
      if ( v11 > 4 )
        v23 = memcmp(&(*a1)[v10 - 3], &gconv_module_ext, 3u) != 0;
      v12 = (_DWORD *)malloc(_gconv_max_path_elem_len + 2 * v11 + 47);
      if ( v12 )
      {
        memset(v12, 0, 0x2Cu);
        *v12 = v12 + 11;
        v13 = mempcpy((_BYTE *)v12 + 44, *a1, v11);
        v14 = _gconv_path_elem;
        v15 = *(_DWORD *)_gconv_path_elem;
        v12[8] = v13;
        if ( v15 )
        {
          v24 = a1;
          v16 = v14 + 8;
          v17 = v11;
          while ( 1 )
          {
            v18 = *v24;
            v19 = (_BYTE *)stpcpy(v13, v15);
            v20 = mempcpy(v19, v18, v17);
            if ( v23 )
              *(_DWORD *)v20 = 7303982;
            if ( !open_translit(v12, (int)v18, v17, (int)v12) )
              break;
            v16 += 8;
            v15 = *(_DWORD *)(v16 - 8);
            if ( !v15 )
              goto LABEL_26;
            v13 = (_WORD *)v12[8];
          }
        }
        else
        {
LABEL_26:
          v12[8] = 0;
        }
        tsearch((int)v12, &search_tree, (int (__cdecl *)(int, _DWORD))trans_compare);
      }
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --lock_5 )
      L_unlock_751();
  }
  else
  {
    L_lock_723(0);
  }
}
// 80481F0: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80CDBAD: using guessed type int gconv_module_ext;
// 80F0E04: using guessed type int lock_5;
// 80F0E08: using guessed type int search_tree;
// 80F1320: using guessed type int _gconv_max_path_elem_len;
// 80F1324: using guessed type int _gconv_path_elem;

//----- (08098092) --------------------------------------------------------
void __usercall L_lock_723(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &lock_5);
  JUMPOUT(0x8097E62);
}
// 809809D: control flows out of bounds to 8097E62
// 80F0E04: using guessed type int lock_5;

//----- (080980A2) --------------------------------------------------------
void L_unlock_751()
{
  _lll_unlock_wake_private(&lock_5);
  JUMPOUT(0x8097EB2);
}
// 80980AD: control flows out of bounds to 8097EB2
// 80F0E04: using guessed type int lock_5;

//----- (080980C0) --------------------------------------------------------
int __usercall find_module_idx@<eax>(unsigned __int8 *a1@<eax>, _DWORD *a2@<edx>)
{
  int v2; // ebx
  unsigned int v3; // eax
  int v4; // ecx
  unsigned int v5; // edi
  unsigned int v6; // esi
  unsigned int v7; // edx
  unsigned __int16 *v8; // ebx
  int v9; // eax
  unsigned __int16 v10; // ax
  unsigned int v12; // [esp+10h] [ebp-3Ch]
  int v13; // [esp+14h] [ebp-38h]
  int v15; // [esp+1Ch] [ebp-30h]
  unsigned int v16; // [esp+20h] [ebp-2Ch]
  int v17; // [esp+24h] [ebp-28h]
  unsigned int v18; // [esp+28h] [ebp-24h]

  v2 = gconv_cache;
  v15 = gconv_cache + *(unsigned __int16 *)(gconv_cache + 4);
  v17 = gconv_cache + *(unsigned __int16 *)(gconv_cache + 6);
  v3 = _hash_string(a1);
  v16 = *(unsigned __int16 *)(v2 + 8);
  v4 = v3 % v16;
  v18 = cache_size - *(unsigned __int16 *)(v2 + 4);
  v5 = v3 % (v16 - 2) + 1;
  v13 = 4 * v5;
LABEL_2:
  v6 = v5 + v4;
  v7 = v5;
  v8 = (unsigned __int16 *)(v17 + 4 * v4);
  while ( 1 )
  {
    v10 = *v8;
    if ( !*v8 )
      return -1;
    if ( v18 > v10 )
    {
      v12 = v7;
      v9 = strcmp((const char *)a1, (const char *)(v15 + v10));
      v7 = v12;
      if ( !v9 )
        break;
    }
    v8 = (unsigned __int16 *)((char *)v8 + v13);
    if ( v16 <= v6 )
    {
      v5 = v7;
      v4 = v6 - v16;
      goto LABEL_2;
    }
    v6 += v7;
  }
  *a2 = v8[1];
  return 0;
}
// 80F0E0C: using guessed type int gconv_cache;
// 80F0E10: using guessed type int cache_size;

//----- (080981C0) --------------------------------------------------------
int __usercall find_module@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, int **a3@<ecx>)
{
  unsigned int v4; // edi
  void *v5; // esp
  _WORD *v6; // eax
  int *shlib; // edx
  int result; // eax
  int v9; // eax
  int v10; // esi
  int v11; // eax
  int (__cdecl *v12)(int **); // esi
  int *v13; // edx
  char v14[4]; // [esp+10h] [ebp-28h] BYREF
  int v15; // [esp+14h] [ebp-24h]
  _BYTE *v16; // [esp+18h] [ebp-20h]
  _BYTE *v17; // [esp+1Ch] [ebp-1Ch]
  int savedregs; // [esp+38h] [ebp+0h] BYREF

  v16 = a2;
  v17 = a1;
  v15 = strlen(a1);
  v4 = strlen(v16) + 1;
  v5 = alloca(v4 + v15 + 15);
  v6 = mempcpy(v14, v17, v15);
  memcpy(v6, v16, v4);
  shlib = _gconv_find_shlib(v14, (int)&savedregs, v4, v14);
  *a3 = shlib;
  result = 1;
  if ( shlib )
  {
    v9 = shlib[3];
    v10 = shlib[4];
    a3[1] = 0;
    a3[5] = (int *)v9;
    v11 = shlib[5];
    a3[7] = (int *)v10;
    a3[6] = 0;
    a3[14] = 0;
    a3[8] = (int *)v11;
    result = 0;
    if ( v10 )
    {
      v12 = (int (__cdecl *)(int **))(__readgsdword(0x18u) ^ __ROR4__(v10, 9));
      dl_mcount_wrapper_check((int)v12);
      result = v12(a3);
      v13 = a3[6];
      if ( v13 )
        a3[6] = (int *)__ROL4__(__readgsdword(0x18u) ^ (unsigned int)v13, 9);
    }
  }
  return result;
}
// 80981C0: using guessed type char anonymous_0[4];

//----- (080982A0) --------------------------------------------------------
int _gconv_get_cache()
{
  return gconv_cache;
}
// 80F0E0C: using guessed type int gconv_cache;

//----- (080982B0) --------------------------------------------------------
int __usercall _gconv_load_cache@<eax>(int a1@<ebp>)
{
  int v1; // esi
  int v2; // ebx
  int v3; // ecx
  int v4; // ecx
  unsigned int v5; // ecx
  unsigned __int16 v6; // bx
  unsigned int v8; // esi
  int v9; // eax
  char v10[44]; // [esp+20h] [ebp-6Ch] BYREF
  unsigned int v11; // [esp+4Ch] [ebp-40h]

  v1 = -1;
  _gconv_path_envvar = getenv("GCONV_PATH");
  if ( _gconv_path_envvar )
    return v1;
  v2 = _open_nocancel((int)"/usr/lib32/gconv/gconv-modules.cache", 0);
  if ( v2 == -1 )
    return v1;
  if ( (_fxstat64(3, v2, (int)v10) & 0x80000000) != 0 || v11 <= 0xF )
    goto LABEL_16;
  cache_size = v11;
  gconv_cache = mmap(0, v11, 1, 1, v2, 0);
  if ( gconv_cache == -1 )
  {
    gconv_cache = malloc(cache_size);
    if ( gconv_cache )
    {
      v8 = 0;
      do
      {
        v9 = read(a1, v2, v8 + gconv_cache);
        if ( v9 == -1 )
        {
          free(gconv_cache);
          gconv_cache = 0;
          goto LABEL_16;
        }
        v8 += v9;
      }
      while ( v8 < cache_size );
      cache_malloced = 1;
      goto LABEL_6;
    }
LABEL_16:
    dl_sysinfo(v3);
    return -1;
  }
LABEL_6:
  dl_sysinfo(v4);
  if ( *(_DWORD *)gconv_cache == 536937252 && *(unsigned __int16 *)(gconv_cache + 4) < (unsigned int)cache_size )
  {
    v5 = *(unsigned __int16 *)(gconv_cache + 6);
    if ( cache_size > v5 )
    {
      v6 = *(_WORD *)(gconv_cache + 8);
      if ( v6 )
      {
        if ( cache_size >= v5 + 4 * v6
          && cache_size > (unsigned int)*(unsigned __int16 *)(gconv_cache + 10)
          && cache_size >= (unsigned int)*(unsigned __int16 *)(gconv_cache + 12) )
        {
          return 0;
        }
      }
    }
  }
  if ( cache_malloced )
  {
    free(gconv_cache);
    cache_malloced = 0;
  }
  else
  {
    munmap(gconv_cache, cache_size);
  }
  gconv_cache = 0;
  return -1;
}
// 809836C: variable 'v4' is possibly undefined
// 80983E5: variable 'v3' is possibly undefined
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80F0E0C: using guessed type int gconv_cache;
// 80F0E10: using guessed type int cache_size;
// 80F0E14: using guessed type int cache_malloced;
// 80F131C: using guessed type int _gconv_path_envvar;
// 80982B0: using guessed type char var_6C[44];

//----- (08098490) --------------------------------------------------------
int __usercall _gconv_compare_alias_cache@<eax>(char *a1@<eax>, char *a2@<edx>, int *a3@<ecx>)
{
  int v7; // [esp+18h] [ebp-14h] BYREF
  int v8; // [esp+1Ch] [ebp-10h] BYREF

  if ( !gconv_cache )
    return -1;
  if ( find_module_idx((unsigned __int8 *)a1, &v7) || find_module_idx((unsigned __int8 *)a2, &v8) )
  {
    *a3 = strcmp(a1, a2);
    return 0;
  }
  else
  {
    *a3 = v7 - v8;
    return 0;
  }
}
// 80F0E0C: using guessed type int gconv_cache;

//----- (08098520) --------------------------------------------------------
int __userpurge _gconv_lookup_cache@<eax>(
        unsigned __int8 *a1@<eax>,
        unsigned __int8 *a2@<edx>,
        _DWORD *a3@<ecx>,
        int *a4,
        char a5)
{
  int v5; // ebx
  int module; // esi
  int v8; // edi
  int v10; // ebp
  int v11; // eax
  int v12; // edi
  unsigned __int16 *v13; // eax
  int v14; // edx
  unsigned __int16 v15; // ax
  unsigned __int16 *v16; // ebp
  int v17; // eax
  int v18; // ebx
  int v19; // eax
  _BYTE *v20; // eax
  int v21; // edi
  int **v22; // edx
  _BYTE *v23; // eax
  unsigned __int16 *i; // ebx
  unsigned __int16 v25; // cx
  int v26; // eax
  unsigned __int16 *v27; // edi
  int v28; // esi
  int v29; // eax
  int v30; // eax
  _BYTE *v31; // eax
  int v32; // [esp+10h] [ebp-4Ch]
  unsigned __int16 v34; // [esp+18h] [ebp-44h]
  int v35; // [esp+18h] [ebp-44h]
  unsigned __int16 v36; // [esp+1Ch] [ebp-40h]
  unsigned __int16 *v37; // [esp+1Ch] [ebp-40h]
  int v38; // [esp+20h] [ebp-3Ch]
  int v39; // [esp+24h] [ebp-38h]
  int v40; // [esp+28h] [ebp-34h]
  int v41; // [esp+2Ch] [ebp-30h]
  int v42; // [esp+38h] [ebp-24h] BYREF
  int v43[4]; // [esp+3Ch] [ebp-20h] BYREF

  v5 = gconv_cache;
  module = 2;
  if ( !gconv_cache )
    return module;
  LOWORD(module) = 1;
  v34 = *(_WORD *)(gconv_cache + 4);
  v36 = *(_WORD *)(gconv_cache + 10);
  if ( find_module_idx(a2, &v42) )
    return module;
  v8 = v42;
  if ( (unsigned int)*(unsigned __int16 *)(v5 + 10) + 4 * (3 * v42 + 3) > cache_size )
    return module;
  if ( find_module_idx(a1, v43) )
    return module;
  v10 = v43[0];
  if ( (unsigned int)*(unsigned __int16 *)(v5 + 10) + 4 * (3 * v43[0] + 3) > cache_size )
    return module;
  if ( (a5 & 1) != 0 )
  {
    module = -1;
    if ( v43[0] == v42 )
      return module;
  }
  v38 = v5 + v34;
  v35 = v5 + v36;
  v11 = 3 * v8;
  v12 = v43[0];
  v13 = (unsigned __int16 *)(v35 + 4 * v11);
  v14 = v42;
  v37 = v13;
  if ( v42 )
  {
    if ( !v43[0] )
      goto LABEL_11;
    v15 = v13[5];
    if ( !v15 )
      goto LABEL_11;
    for ( i = (unsigned __int16 *)(gconv_cache + *(unsigned __int16 *)(v5 + 12) + v15 - 1); ; i += 3 * v25 + 1 )
    {
      v25 = *i;
      if ( !*i )
        goto LABEL_11;
      if ( v43[0] == i[3 * v25 - 2] )
        break;
    }
    module = 3;
    *a4 = v25;
    v26 = malloc(60 * v25);
    v39 = v26;
    *a3 = v26;
    if ( !v26 )
      return module;
    v27 = i;
    v28 = v26;
    v41 = 0;
    v40 = v38 + *v37;
    while ( 1 )
    {
      v29 = 12 * v27[1];
      *(_DWORD *)(v28 + 12) = v40;
      v30 = v38 + *(unsigned __int16 *)(v35 + v29);
      *(_DWORD *)(v28 + 8) = 1;
      *(_DWORD *)(v28 + 56) = 0;
      *(_DWORD *)(v28 + 16) = v30;
      v40 = v30;
      v31 = (_BYTE *)(v38 + v27[2]);
      if ( *v31 )
      {
        if ( find_module(v31, (_BYTE *)(v38 + v27[3]), (int **)v28) )
        {
          free(v39);
          v14 = v42;
          if ( !v42 )
          {
LABEL_12:
            v12 = v43[0];
            break;
          }
LABEL_11:
          if ( v37[2] )
            goto LABEL_12;
          return 1;
        }
      }
      else
      {
        _gconv_get_builtin_trans((const char *)(v38 + v27[3]), (_DWORD *)v28);
      }
      ++v41;
      v28 += 60;
      v27 += 3;
      if ( v41 >= *i )
        return 0;
    }
  }
  v16 = (unsigned __int16 *)(v35 + 12 * v10);
  if ( v12 && !v16[4] )
    return 1;
  if ( v14 || (module = 1, v12) )
  {
    v32 = v14;
    module = 3;
    v17 = malloc(120);
    v18 = v17;
    if ( v17 )
    {
      *a3 = v17;
      *a4 = 0;
      if ( v32 )
      {
        v19 = v38 + *v37;
        *(_DWORD *)(v18 + 16) = "INTERNAL";
        *(_DWORD *)(v18 + 8) = 1;
        *(_DWORD *)(v18 + 12) = v19;
        v20 = (_BYTE *)(v38 + v37[3]);
        *(_DWORD *)(v18 + 56) = 0;
        if ( *v20 )
        {
          module = find_module(v20, (_BYTE *)(v38 + v37[4]), (int **)v18);
          if ( module )
            goto LABEL_30;
        }
        else
        {
          _gconv_get_builtin_trans((const char *)(v38 + v37[4]), (_DWORD *)v18);
        }
        v12 = v43[0];
        ++*a4;
      }
      module = 0;
      if ( !v12 )
        return module;
      v21 = *a4;
      v22 = (int **)(v18 + 60 * *a4);
      v22[4] = (int *)(v38 + *v16);
      v23 = (_BYTE *)(v38 + v16[1]);
      v22[3] = (int *)"INTERNAL";
      v22[2] = (int *)1;
      v22[14] = 0;
      if ( !*v23 )
      {
        _gconv_get_builtin_trans((const char *)(v38 + v16[2]), v22);
        goto LABEL_25;
      }
      module = find_module(v23, (_BYTE *)(v38 + v16[2]), v22);
      if ( !module )
      {
LABEL_25:
        module = 0;
        ++*a4;
        return module;
      }
      if ( v21 )
        _gconv_release_step((int *)v18);
LABEL_30:
      free(v18);
    }
  }
  return module;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80F0E0C: using guessed type int gconv_cache;
// 80F0E10: using guessed type int cache_size;
// 8098520: using guessed type int var_20[4];

//----- (080988C0) --------------------------------------------------------
int __usercall _gconv_release_cache@<eax>(int result@<eax>)
{
  if ( gconv_cache )
    return free(result);
  return result;
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80F0E0C: using guessed type int gconv_cache;

//----- (080988E0) --------------------------------------------------------
int __cdecl known_compare(char *s1, char *s2)
{
  return strcmp(*(const char **)s1, *(const char **)s2);
}

//----- (08098900) --------------------------------------------------------
char __usercall do_release_shlib@<al>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int *a4, int a5)
{
  int v5; // eax
  int v6; // ebx

  LOBYTE(v5) = a5;
  v6 = *a4;
  if ( a5 == 3 || !a5 )
  {
    v5 = *(_DWORD *)(v6 + 4);
    if ( v6 == release_handle )
    {
      if ( v5 <= 0 )
        _assert_fail("obj->counter > 0", "gconv_dl.c", 175, "do_release_shlib");
      *(_DWORD *)(v6 + 4) = --v5;
    }
    else if ( (unsigned int)v5 >= 0xFFFFFFFE || v5 == 0 )
    {
      *(_DWORD *)(v6 + 4) = --v5;
      if ( v5 == -3 )
      {
        v5 = *(_DWORD *)(v6 + 8);
        if ( v5 )
        {
          LOBYTE(v5) = _libc_dlclose(v6, a1, a2, a3, *(_DWORD *)(v6 + 8));
          *(_DWORD *)(v6 + 8) = 0;
        }
      }
    }
  }
  return v5;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80F0E1C: using guessed type int release_handle;

//----- (08098990) --------------------------------------------------------
int __usercall _gconv_release_shlib@<eax>(int a1@<eax>)
{
  release_handle = a1;
  return twalk(loaded, (int (__cdecl *)(int, int, int))do_release_shlib);
}
// 80F0E18: using guessed type int loaded;
// 80F0E1C: using guessed type int release_handle;

//----- (080989C0) --------------------------------------------------------
int *__usercall _gconv_find_shlib@<eax>(_BYTE *a1@<eax>, int a2@<ebp>, unsigned int a3@<edi>, _BYTE *a4@<esi>)
{
  int **v4; // eax
  int *v5; // ebx
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int *result; // eax
  bool v12; // cc
  int v13; // edx
  int v14; // ecx
  int v15; // edi
  int v16; // eax
  _BYTE *v17; // eax
  int v18; // eax
  int *v19; // [esp+0h] [ebp-2Ch]
  _BYTE *v20; // [esp+1Ch] [ebp-10h] BYREF

  v20 = a1;
  v4 = (int **)tfind((int)&v20, &loaded, (int (__cdecl *)(int, _DWORD))known_compare);
  if ( v4 )
  {
    v5 = *v4;
    if ( !*v4 )
      return v5;
  }
  else
  {
    a4 = v20;
    v15 = strlen(v20);
    v16 = malloc(v15 + 25);
    v5 = (int *)v16;
    if ( !v16 )
      return v5;
    a3 = v15 + 1;
    v17 = memcpy((_BYTE *)(v16 + 24), a4, a3);
    v5[1] = -3;
    v5[2] = 0;
    *v5 = (int)v17;
    if ( !tsearch((int)v5, &loaded, (int (__cdecl *)(int, _DWORD))known_compare) )
    {
      v19 = v5;
      v5 = 0;
      free(v19);
      return v5;
    }
  }
  v6 = v5[1];
  if ( v6 < -2 )
  {
    if ( v5[2] )
      _assert_fail("found->handle == ((void *)0)", "gconv_dl.c", 117, "__gconv_find_shlib");
    v7 = _libc_dlopen_mode((int)v5, a2, a3, (int)a4, *v5, -2147483647);
    v5[2] = v7;
    if ( !v7 )
      return 0;
    v8 = _libc_dlsym((int)v5, a2, a3, (int)a4, v7, 135059834);
    v5[3] = v8;
    if ( v8 )
    {
      v5[4] = _libc_dlsym((int)v5, a2, a3, (int)a4, v5[2], (int)"gconv_init");
      v5[5] = _libc_dlsym((int)v5, a2, a3, (int)a4, v5[2], (int)"gconv_end");
      v5[3] = __ROL4__(__readgsdword(0x18u) ^ v5[3], 9);
      v9 = v5[4];
      if ( v9 )
        v5[4] = __ROL4__(__readgsdword(0x18u) ^ v9, 9);
      v10 = v5[5];
      if ( v10 )
        v5[5] = __ROL4__(__readgsdword(0x18u) ^ v10, 9);
      v5[1] = 1;
    }
    else
    {
      v18 = (int)v5;
      v5 = 0;
      _gconv_release_shlib(v18);
    }
    return v5;
  }
  if ( !v5[2] )
    return v5;
  v12 = v6 <= 0;
  v13 = 1;
  v14 = v6 + 1;
  result = v5;
  if ( !v12 )
    v13 = v14;
  v5[1] = v13;
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80F0E18: using guessed type int loaded;

//----- (08098BA0) --------------------------------------------------------
void __usercall setname(int a1@<eax>, char *a2@<edx>, long double a3@<st0>)
{
  int v3; // ebx
  const char *v4; // ecx

  v3 = a1 + 16;
  v4 = (&nl_global_locale)[a1 + 16];
  if ( v4 != a2 )
  {
    if ( v4 != "C" )
      free(a3, (int)v4);
    (&nl_global_locale)[v3] = a2;
  }
}

//----- (08098BE0) --------------------------------------------------------
const char *__usercall new_composite_name@<eax>(int a1@<eax>, const char **a2@<edx>, long double a3@<st0>)
{
  size_t v3; // ebp
  int v4; // ebx
  _BOOL4 v5; // edx
  char *s1; // esi
  int v7; // eax
  int v8; // edi
  const char *v9; // esi
  char *v10; // ebx
  const char *v12; // eax
  int i; // ebx
  char *v14; // edi
  _BYTE *v15; // eax
  _BYTE *v16; // eax
  char *v17; // eax
  _BOOL4 v18; // [esp+10h] [ebp-2Ch]
  const char *v21; // [esp+1Ch] [ebp-20h]

  v3 = 0;
  v4 = 1;
  v5 = 1;
  while ( 1 )
  {
    if ( v4 != 7 )
    {
      if ( a1 == 6 )
      {
        s1 = (char *)a2[v4 - 1];
      }
      else if ( a1 == v4 - 1 )
      {
        s1 = (char *)*a2;
      }
      else
      {
        s1 = (&::s1)[v4];
      }
      v18 = v5;
      v7 = strlen(s1);
      v5 = v18;
      v8 = v7;
      v3 += v7 + (unsigned __int8)byte_80CE6BF[v4] + 2;
      if ( v18 )
      {
        v5 = 1;
        if ( s1 != *a2 )
          v5 = strcmp(s1, *a2) == 0;
      }
      if ( v4 == 13 )
        break;
    }
    ++v4;
  }
  if ( v5 )
  {
    v9 = "C";
    v10 = (char *)*a2;
    if ( strcmp(*a2, "C") )
    {
      if ( strcmp(v10, "POSIX") )
      {
        malloc(a3, v8 + 1);
        v9 = v17;
        if ( v17 )
          return memcpy(v17, v10, v8 + 1);
      }
    }
    return v9;
  }
  malloc(a3, v3);
  v9 = v12;
  if ( !v12 )
    return v9;
  v21 = v12;
  for ( i = 1; ; ++i )
  {
    if ( i != 7 )
    {
      if ( a1 == 6 )
        v14 = (char *)a2[i - 1];
      else
        v14 = i - 1 == a1 ? (char *)*a2 : (&::s1)[i];
      v15 = (_BYTE *)stpcpy(v12, (unsigned __int8)byte_80CE6CC[i] + 135063264);
      *v15 = 61;
      v16 = (_BYTE *)stpcpy(v15 + 1, v14);
      *v16 = 59;
      v12 = v16 + 1;
      if ( i == 13 )
        break;
    }
  }
  *((_BYTE *)v12 - 1) = 0;
  return v21;
}
// 8098CE2: variable 'v12' is possibly undefined
// 8098D85: variable 'v17' is possibly undefined
// 80481F0: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);

//----- (08098DB0) --------------------------------------------------------
char *__usercall setlocale@<eax>(long double a1@<st0>, unsigned int a2, char *s1)
{
  char *v3; // esi
  char *v4; // esi
  char *v6; // eax
  int v7; // edi
  char **locale; // eax
  char *v9; // edi
  char *v10; // esi
  void (__cdecl *v11)(); // eax
  int i; // eax
  int v13; // ebx
  int v14; // edi
  char **v15; // eax
  char *v16; // esi
  int v17; // eax
  char *v18; // eax
  int v19; // ebx
  const char *v20; // eax
  int v21; // edi
  int ii; // ebx
  void (__cdecl *v23)(); // eax
  int k; // eax
  unsigned int v25; // ecx
  void *v26; // esp
  _BYTE *j; // edx
  char *v28; // eax
  void *v29; // edx
  int v30; // ecx
  int v31; // edi
  int m; // ebx
  int v33; // eax
  char *v34; // eax
  const char *v35; // [esp+0h] [ebp-A8h]
  const char *v36; // [esp+0h] [ebp-A8h]
  char v37[4]; // [esp+10h] [ebp-98h] BYREF
  void *v38; // [esp+14h] [ebp-94h]
  int v39; // [esp+18h] [ebp-90h]
  size_t n; // [esp+1Ch] [ebp-8Ch]
  char *v41[13]; // [esp+20h] [ebp-88h] BYREF
  const char *v42[13]; // [esp+54h] [ebp-54h] BYREF
  char *v43; // [esp+88h] [ebp-20h] BYREF
  int v44[7]; // [esp+8Ch] [ebp-1Ch] BYREF

  v3 = s1;
  if ( a2 > 0xC )
  {
LABEL_76:
    v4 = 0;
    __writegsdword(0xFFFFFFE8, 0x16u);
    return v4;
  }
  if ( !s1 )
    return (&s2)[a2];
  if ( !strcmp(s1, (&nl_global_locale)[a2 + 16]) )
    return (&nl_global_locale)[a2 + 16];
  v43 = 0;
  v44[0] = 0;
  v6 = (char *)getenv(byte_80CE769);
  if ( v6 )
  {
    if ( *v6 )
    {
      v38 = v44;
      if ( argz_create_sep(a1, v6, 58, (int *)&v43, v44) || argz_add_sep(&v43, v38, "/usr/lib/locale", 58) )
        return 0;
    }
  }
  if ( a2 != 6 )
  {
    v7 = nl_current_used[a2];
    v42[0] = s1;
    if ( v7 )
    {
      locale = nl_find_locale(v43, v44[0], (char *)a2, a1, v42);
      v9 = (char *)locale;
      if ( !locale )
        goto LABEL_58;
      if ( locale[6] != (char *)-1 )
        locale[6] = (char *)-1;
      v3 = (char *)v42[0];
    }
    else
    {
      v9 = 0;
    }
    if ( v3 == "C" || (v42[0] = strdup(v3)) != 0 )
    {
      v10 = (char *)new_composite_name(a2, v42, a1);
      if ( v10 )
      {
        if ( nl_current_used[a2] )
        {
          v11 = (void (__cdecl *)())nl_category_postload[a2];
          (&nl_global_locale)[a2] = v9;
          if ( v11 )
            v11();
        }
        setname(a2, (char *)v42[0], a1);
        setname(6, v10, a1);
        ++nl_msg_cat_cntr;
        goto LABEL_21;
      }
      if ( v42[0] != "C" )
        free(a1, (int)v42[0]);
    }
LABEL_58:
    v42[0] = 0;
LABEL_21:
    free(a1, (int)v43);
    return (char *)v42[0];
  }
  for ( i = 1; ; ++i )
  {
    if ( i != 7 )
    {
      v41[i - 1] = s1;
      if ( i == 13 )
        break;
    }
  }
  if ( strchr(s1, 59) )
  {
    v25 = strlen(s1) + 1;
    v26 = alloca(v25 + 15);
    for ( j = memcpy(v37, s1, v25); ; j = v34 + 1 )
    {
      v38 = j;
      v28 = strchr(j, 61);
      v29 = v38;
      v30 = (int)v28;
      if ( !v28 )
      {
LABEL_71:
        for ( k = 1; ; ++k )
        {
          if ( k != 7 )
          {
            if ( v41[k - 1] == s1 )
              goto LABEL_76;
            if ( k == 13 )
              goto LABEL_29;
          }
        }
      }
      v31 = 1;
      n = v28 - (_BYTE *)v38;
      for ( m = 0; ; ++m )
      {
        if ( m == 6 )
          goto LABEL_81;
        if ( (unsigned __int8)nl_category_name_sizes[m] == n )
        {
          v38 = v29;
          v39 = v30;
          v33 = memcmp(v29, (const void *)((unsigned __int8)nl_category_name_idxs[m] + 135063264), n);
          v29 = v38;
          v30 = v39;
          if ( !v33 )
            break;
        }
        if ( v31 == 13 )
          goto LABEL_76;
LABEL_81:
        ++v31;
      }
      v36 = (const char *)(v39 + 1);
      v41[m] = (char *)(v39 + 1);
      v34 = strchr(v36, 59);
      if ( !v34 )
        goto LABEL_71;
      *v34 = 0;
    }
  }
LABEL_29:
  v13 = 12;
  v14 = 13;
  while ( v13 == 6 )
  {
    v17 = 5;
LABEL_37:
    v14 = v13;
    v13 = v17;
  }
  v15 = nl_find_locale(v43, v44[0], (char *)v13, a1, (const char **)&v41[v13]);
  v42[v13] = (const char *)v15;
  if ( v15 )
  {
    if ( v15[6] != (char *)-1 )
      v15[6] = (char *)-1;
    v16 = v41[v13];
    if ( v16 != "C" )
    {
      v35 = v41[v13];
      v38 = (&s2)[v13];
      if ( !strcmp(v35, (const char *)v38) )
      {
        v41[v13] = (char *)v38;
        v17 = v13 - 1;
        goto LABEL_36;
      }
      v18 = strdup(v16);
      v41[v13] = v18;
      if ( !v18 )
        goto LABEL_44;
    }
  }
  else if ( v41[v13] != "C" )
  {
    goto LABEL_44;
  }
  v17 = v13 - 1;
LABEL_36:
  if ( v13 > 0 )
    goto LABEL_37;
  v14 = v13;
  v13 = v17;
LABEL_44:
  if ( v13 < 0 && (v4 = (char *)new_composite_name(6, (const char **)v41, a1)) != 0 )
  {
    v21 = 1;
    for ( ii = 0; ; ++ii )
    {
      if ( ii != 6 )
      {
        if ( nl_current_used[ii] )
        {
          (&nl_global_locale)[ii] = (char *)v42[ii];
          v23 = (void (__cdecl *)())nl_category_postload[ii];
          if ( v23 )
            v23();
        }
        setname(ii, v41[ii], a1);
        if ( v21 == 13 )
          break;
      }
      ++v21;
    }
    setname(6, v4, a1);
    ++nl_msg_cat_cntr;
  }
  else
  {
    v19 = v14 + 1;
    if ( v14 != 13 )
    {
      while ( 1 )
      {
        if ( v19 != 7 )
        {
          v20 = v41[v19 - 1];
          if ( v20 != "C" && v20 != (&::s1)[v19] )
            free(a1, (int)v41[v19 - 1]);
          if ( v19 == 13 )
            break;
        }
        ++v19;
      }
    }
    v4 = 0;
  }
  free(a1, (int)v43);
  return v4;
}
// 80CE769: using guessed type _BYTE byte_80CE769[3];
// 80CE780: using guessed type int nl_current_used[16];
// 80CE7C0: using guessed type int (*nl_category_postload[13])();
// 80F1298: using guessed type int nl_msg_cat_cntr;
// 8098DB0: using guessed type char anonymous_0[4];

//----- (08099330) --------------------------------------------------------
char **__userpurge nl_find_locale@<eax>(
        char *a1@<eax>,
        int a2@<edx>,
        char *a3@<ecx>,
        long double a4@<st0>,
        const char **a5)
{
  const char *v6; // eax
  const char *v7; // edi
  int v8; // ecx
  char **result; // eax
  const char *v10; // eax
  const char *v11; // eax
  char *v12; // ecx
  char *v13; // eax
  char *v14; // edx
  unsigned int v15; // ecx
  void *v16; // esp
  _BYTE *v17; // eax
  int v18; // eax
  int v19; // edi
  int v20; // ecx
  int *l10nflist; // esi
  int v22; // eax
  char *v23; // edx
  void *v24; // esp
  void *v25; // esp
  char *v26; // eax
  int v27; // ecx
  int *v28; // eax
  int v29; // ecx
  int v30; // edx
  _DWORD *v31; // ebx
  int v32; // eax
  int v33; // ebx
  unsigned int v34; // edx
  int *v35; // eax
  int v36; // edi
  int *v37; // ebx
  int v38; // edi
  char *v39; // eax
  char *v40; // edx
  int v41; // [esp+30h] [ebp-48h] BYREF
  char *v42; // [esp+34h] [ebp-44h]
  int v43; // [esp+38h] [ebp-40h]
  char *v44; // [esp+3Ch] [ebp-3Ch]
  int v45; // [esp+4Ch] [ebp-2Ch] BYREF
  int v46; // [esp+50h] [ebp-28h] BYREF
  int v47; // [esp+54h] [ebp-24h] BYREF
  int v48; // [esp+58h] [ebp-20h] BYREF
  int v49; // [esp+5Ch] [ebp-1Ch] BYREF
  int savedregs; // [esp+78h] [ebp+0h] BYREF

  v43 = a2;
  v6 = *a5;
  v44 = a3;
  if ( *v6 )
  {
    if ( v6 )
      goto LABEL_3;
LABEL_15:
    v12 = v44;
    *a5 = "C";
    return nl_C[(_DWORD)v12];
  }
  v10 = (const char *)getenv("LC_ALL");
  *a5 = v10;
  if ( v10 && *v10
    || (v11 = (const char *)getenv((_BYTE *)((unsigned __int8)nl_category_name_idxs[(_DWORD)v44] + 135063264)),
        (*a5 = v11) != 0)
    && *v11 )
  {
    v6 = *a5;
  }
  else
  {
    v6 = (const char *)getenv("LANG");
    *a5 = v6;
    if ( !v6 )
      goto LABEL_15;
  }
LABEL_3:
  if ( !*v6 || _libc_enable_secure && strchr(v6, 47) )
    goto LABEL_15;
  v7 = *a5;
  if ( !strcmp(*a5, "C") || !strcmp(v7, "POSIX") )
    goto LABEL_15;
  if ( !a1 )
  {
    result = (char **)nl_load_locale_from_archive((int)v44, (char **)a5, v8, a4);
    if ( result )
      return result;
    v7 = *a5;
    a1 = "/usr/lib/locale";
    v43 = 16;
  }
  nl_expand_alias(a4, (int)v7);
  v14 = v13;
  if ( !v13 )
    v14 = (char *)*a5;
  v15 = strlen(v14) + 1;
  v16 = alloca(v15 + 15);
  v17 = memcpy(&v41, v14, v15);
  v18 = nl_explode_name(v17, &v45, &v46, &v47, (const char **)&v48, (const char **)&v49);
  v19 = v18;
  if ( v18 == -1 )
    return 0;
  v20 = (unsigned __int8)nl_category_name_idxs[(_DWORD)v44];
  v41 = (int)&nl_locale_file_list[(_DWORD)v44];
  v42 = (char *)(v20 + 135063264);
  l10nflist = (int *)nl_make_l10nflist(
                       (const char ***)v41,
                       a1,
                       v43,
                       v18,
                       (_BYTE *)v45,
                       (_BYTE *)v47,
                       (_BYTE *)v48,
                       (_BYTE *)v49,
                       (_BYTE *)v46,
                       (char *)(v20 + 135063264),
                       0);
  if ( !l10nflist )
  {
    l10nflist = (int *)nl_make_l10nflist(
                         (const char ***)v41,
                         a1,
                         v43,
                         v19,
                         (_BYTE *)v45,
                         (_BYTE *)v47,
                         (_BYTE *)v48,
                         (_BYTE *)v49,
                         (_BYTE *)v46,
                         v42,
                         1);
    if ( !l10nflist )
      return 0;
  }
  if ( (v19 & 1) != 0 )
    free(a4, v49);
  if ( !l10nflist[1] )
    nl_load_locale(l10nflist, (int)v44, a4);
  if ( !l10nflist[2] )
  {
    v35 = (int *)l10nflist[4];
    v36 = 0;
    if ( v35 )
    {
      v37 = l10nflist;
      do
      {
        if ( !v35[1] )
          nl_load_locale(v35, (int)v44, a4);
        if ( *(_DWORD *)(v37[4] + 8) )
          break;
        ++v37;
        ++v36;
        v35 = (int *)v37[4];
      }
      while ( v35 );
    }
    v38 = v36 + 4;
    l10nflist[4] = l10nflist[v38];
    l10nflist = (int *)l10nflist[v38];
    if ( !l10nflist )
      return 0;
  }
  if ( !v48 )
    goto LABEL_34;
  v22 = l10nflist[2];
  v23 = *(char **)(v22 + 4 * codeset_idx_8258[(_DWORD)v44] + 36);
  if ( !v23 )
    _assert_fail((int)&savedregs, a4, (int)"locale_codeset != ((void *)0)", (int)"findlocale.c", 229, "_nl_find_locale");
  v24 = alloca(strlen(*(const char **)(v22 + 4 * codeset_idx_8258[(_DWORD)v44] + 36)) + 18);
  v44 = (char *)&v41;
  strip(&v41, v23);
  v25 = alloca(strlen((const char *)v48) + 18);
  strip(&v41, (char *)v48);
  v26 = v44;
  do
  {
    v27 = dword_80D03C0[*v26];
    *v26++ = v27;
  }
  while ( (_BYTE)v27 );
  v28 = &v41;
  do
  {
    v29 = dword_80D03C0[*(char *)v28];
    *(_BYTE *)v28 = v29;
    v28 = (int *)((char *)v28 + 1);
  }
  while ( (_BYTE)v29 );
  v30 = _gconv_compare_alias((char *)&v41, v44);
  result = 0;
  if ( !v30 )
  {
LABEL_34:
    v31 = (_DWORD *)l10nflist[2];
    if ( !*v31 )
    {
      v39 = strrchr((const char *)*l10nflist, 47);
      v40 = v39 - 1;
      if ( *(v39 - 2) != 47 )
      {
        do
          --v40;
        while ( *(v40 - 1) != 47 );
      }
      *v31 = strndup(a4, v40, v39 - v40);
    }
    if ( v46 )
    {
      v32 = strcasecmp_l(v46, "TRANSLIT", nl_C_locobj);
      v33 = l10nflist[2];
      if ( !v32 )
        *(_DWORD *)(v33 + 28) = 1;
    }
    else
    {
      v33 = l10nflist[2];
    }
    v34 = *(_DWORD *)(v33 + 24);
    result = (char **)v33;
    if ( v34 <= 0xFFFFFFFD )
      *(_DWORD *)(v33 + 24) = v34 + 1;
  }
  return result;
}
// 80993AB: variable 'v8' is possibly undefined
// 809944F: variable 'v13' is possibly undefined
// 80482A0: using guessed type int __cdecl strcasecmp_l(_DWORD, _DWORD, _DWORD);
// 80C8380: using guessed type char **nl_C_locobj[6];
// 80CE860: using guessed type char **nl_C[6];
// 80CE8A0: using guessed type int codeset_idx_8258[13];
// 80D03C0: using guessed type _DWORD dword_80D03C0[256];
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80F1340: using guessed type int nl_locale_file_list[13];

//----- (080997A0) --------------------------------------------------------
void __usercall nl_remove_locale(int a1@<eax>, int *a2@<edx>, long double a3@<st0>)
{
  _DWORD *i; // ecx

  if ( a2[6]-- == 1 )
  {
    if ( a2[3] != 2 )
    {
      for ( i = (_DWORD *)nl_locale_file_list[a1]; (int *)i[2] != a2; i = (_DWORD *)i[3] )
        ;
      i[1] = 0;
      i[2] = 0;
    }
    nl_unload_locale(a2, a3);
  }
}
// 80F1340: using guessed type int nl_locale_file_list[13];

//----- (080997F0) --------------------------------------------------------
void __usercall nl_intern_locale_data(
        int a1@<eax>,
        int *a2@<edx>,
        unsigned int a3@<ecx>,
        int a4@<ebp>,
        long double a5@<st0>)
{
  int v8; // edx
  int v9; // eax
  unsigned int v10; // eax
  _DWORD *v11; // eax
  int v12; // edx
  unsigned int v13; // ecx
  unsigned int v14; // edx
  int v15; // [esp+1Ch] [ebp-20h]

  if ( a3 <= 7 )
    goto LABEL_43;
  v8 = *a2;
  v9 = 537202711;
  if ( a1 != 3 )
  {
    v9 = 537462560;
    if ( a1 )
      v9 = a1 ^ 0x20031115;
  }
  if ( v9 != v8 || (v10 = a2[1], v10 < nl_category_num_items[a1]) || a3 <= 4 * v10 + 8 )
  {
LABEL_43:
    __writegsdword(0xFFFFFFE8, 0x16u);
    return;
  }
  malloc(a5, 4 * v10 + 36);
  if ( v11 )
  {
    v11[5] = 0;
    v11[4] = 0;
    v12 = a2[1];
    v11[1] = a2;
    v11[2] = a3;
    v11[6] = 0;
    v11[7] = 0;
    v15 = v12;
    v11[8] = v12;
    if ( v12 )
    {
      v13 = a2[2];
      if ( a3 >= v13 )
      {
        v14 = 0;
        while ( 2 )
        {
          switch ( a1 )
          {
            case 1:
              if ( v14 > 5 )
                _assert_fail(
                  a4,
                  a5,
                  (int)"cnt < (sizeof (_nl_value_type_LC_NUMERIC) / sizeof (_nl_value_type_LC_NUMERIC[0]))",
                  (int)"loadlocale.c",
                  129,
                  "_nl_intern_locale_data");
              goto LABEL_19;
            case 2:
              if ( v14 > 0x6E )
                _assert_fail(
                  a4,
                  a5,
                  (int)"cnt < (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))",
                  (int)"loadlocale.c",
                  130,
                  "_nl_intern_locale_data");
              goto LABEL_19;
            case 3:
              if ( v14 > 0x12 )
                _assert_fail(
                  a4,
                  a5,
                  (int)"cnt < (sizeof (_nl_value_type_LC_COLLATE) / sizeof (_nl_value_type_LC_COLLATE[0]))",
                  (int)"loadlocale.c",
                  131,
                  "_nl_intern_locale_data");
              goto LABEL_19;
            case 4:
              if ( v14 > 0x2D )
                _assert_fail(
                  a4,
                  a5,
                  (int)"cnt < (sizeof (_nl_value_type_LC_MONETARY) / sizeof (_nl_value_type_LC_MONETARY[0]))",
                  (int)"loadlocale.c",
                  132,
                  "_nl_intern_locale_data");
              goto LABEL_19;
            case 5:
              if ( v14 > 4 )
                _assert_fail(
                  a4,
                  a5,
                  (int)"cnt < (sizeof (_nl_value_type_LC_MESSAGES) / sizeof (_nl_value_type_LC_MESSAGES[0]))",
                  (int)"loadlocale.c",
                  133,
                  "_nl_intern_locale_data");
              goto LABEL_19;
            case 7:
              if ( v14 > 2 )
                _assert_fail(
                  a4,
                  a5,
                  (int)"cnt < (sizeof (_nl_value_type_LC_PAPER) / sizeof (_nl_value_type_LC_PAPER[0]))",
                  (int)"loadlocale.c",
                  134,
                  "_nl_intern_locale_data");
              goto LABEL_19;
            case 8:
              if ( v14 > 6 )
                _assert_fail(
                  a4,
                  a5,
                  (int)"cnt < (sizeof (_nl_value_type_LC_NAME) / sizeof (_nl_value_type_LC_NAME[0]))",
                  (int)"loadlocale.c",
                  135,
                  "_nl_intern_locale_data");
              goto LABEL_19;
            case 9:
              if ( v14 > 0xC )
                _assert_fail(
                  a4,
                  a5,
                  (int)"cnt < (sizeof (_nl_value_type_LC_ADDRESS) / sizeof (_nl_value_type_LC_ADDRESS[0]))",
                  (int)"loadlocale.c",
                  136,
                  "_nl_intern_locale_data");
              goto LABEL_19;
            case 10:
              if ( v14 > 4 )
                _assert_fail(
                  a4,
                  a5,
                  (int)"cnt < (sizeof (_nl_value_type_LC_TELEPHONE) / sizeof (_nl_value_type_LC_TELEPHONE[0]))",
                  (int)"loadlocale.c",
                  137,
                  "_nl_intern_locale_data");
              goto LABEL_19;
            case 11:
              if ( v14 > 1 )
                _assert_fail(
                  a4,
                  a5,
                  (int)"cnt < (sizeof (_nl_value_type_LC_MEASUREMENT) / sizeof (_nl_value_type_LC_MEASUREMENT[0]))",
                  (int)"loadlocale.c",
                  138,
                  "_nl_intern_locale_data");
              goto LABEL_19;
            case 12:
              if ( v14 > 0xF )
                _assert_fail(
                  a4,
                  a5,
                  (int)"cnt < (sizeof (_nl_value_type_LC_IDENTIFICATION) / sizeof (_nl_value_type_LC_IDENTIFICATION[0]))",
                  (int)"loadlocale.c",
                  139,
                  "_nl_intern_locale_data");
              goto LABEL_19;
            default:
              if ( a1 )
                _assert_fail(a4, a5, (int)"category == __LC_CTYPE", (int)"loadlocale.c", 141, "_nl_intern_locale_data");
              if ( v14 > 0x46 )
                goto LABEL_14;
LABEL_19:
              a4 = (int)*(&nl_value_types + a1);
              if ( *(_DWORD *)(a4 + 4 * v14) == 5 )
              {
                if ( (v13 & 3) != 0 )
                  break;
                v11[v14 + 9] = *(int *)((char *)a2 + v13);
              }
              else
              {
LABEL_14:
                v11[v14 + 9] = (char *)a2 + v13;
              }
              if ( ++v14 == v15 )
                return;
              v13 = a2[v14 + 2];
              if ( a3 >= v13 )
                continue;
              goto LABEL_42;
          }
          break;
        }
      }
LABEL_42:
      free(a5, (int)v11);
      goto LABEL_43;
    }
  }
}
// 809985C: variable 'v11' is possibly undefined
// 80CED20: using guessed type int nl_category_num_items[16];
// 80CED60: using guessed type void *nl_value_types;

//----- (08099B60) --------------------------------------------------------
void __usercall nl_load_locale(int *a1@<eax>, int a2@<edx>, long double a3@<st0>)
{
  int v3; // esi
  int v4; // eax
  int v5; // ebx
  int v6; // ecx
  int v7; // ecx
  int *v8; // edi
  _DWORD *v9; // eax
  _BYTE *v10; // edx
  int v11; // eax
  int v12; // edi
  int v13; // esi
  int v14; // ebx
  signed int nocancel; // eax
  _BYTE *v16; // eax
  char *v17; // edx
  unsigned int v18; // kr04_4
  int v19; // edi
  void *v20; // esp
  _WORD *v21; // eax
  _BYTE v22[12]; // [esp+20h] [ebp-98h] BYREF
  int v23; // [esp+2Ch] [ebp-8Ch]
  int v24; // [esp+30h] [ebp-88h]
  int *v25; // [esp+34h] [ebp-84h]
  int v26; // [esp+38h] [ebp-80h]
  unsigned int v27; // [esp+3Ch] [ebp-7Ch]
  char v28[16]; // [esp+40h] [ebp-78h] BYREF
  int v29; // [esp+50h] [ebp-68h]
  int v30; // [esp+6Ch] [ebp-4Ch]
  int savedregs; // [esp+B8h] [ebp+0h] BYREF

  v3 = (int)a1;
  a1[1] = 1;
  a1[2] = 0;
  v4 = *a1;
  v26 = a2;
  v5 = _open_nocancel(v4, 0x80000);
  if ( v5 >= 0 )
  {
    if ( (_fxstat64(3, v5, (int)v28) & 0x80000000) != 0 )
      goto LABEL_12;
    if ( (v29 & 0xF000) == 0x4000 )
    {
      dl_sysinfo(v6);
      v17 = *(char **)v3;
      v18 = strlen(*(const char **)v3) + 1;
      v19 = (unsigned __int8)nl_category_name_sizes[v26];
      v20 = alloca(v18 - 1 + v19 + 21);
      v27 = (unsigned __int8)nl_category_name_idxs[v26] + 135063264;
      v21 = mempcpy(v22, v17, v18 - 1);
      *(_DWORD *)v21 = 1398362927;
      *((_BYTE *)v21 + 4) = 95;
      memcpy((_BYTE *)v21 + 5, (_BYTE *)v27, v19 + 1);
      v5 = _open_nocancel((int)v22, 0x80000);
      if ( v5 < 0 )
        return;
      if ( (_fxstat64(3, v5, (int)v28) & 0x80000000) != 0 )
      {
LABEL_12:
        dl_sysinfo(v6);
        return;
      }
    }
    v27 = __readgsdword(0xFFFFFFE8);
    v8 = (int *)mmap(0, v30, 1, 2, v5, 0);
    if ( v8 == (int *)-1 )
    {
      if ( __readgsdword(0xFFFFFFE8) == 38 )
      {
        v23 = v30;
        malloc(a3, v30);
        v8 = (int *)v11;
        if ( v11 )
        {
          if ( v23 > 0 )
          {
            v24 = v3;
            v12 = v23;
            v13 = v5;
            v25 = (int *)v11;
            v14 = v11;
            while ( 1 )
            {
              nocancel = _read_nocancel(v13, v14);
              if ( nocancel <= 0 )
                break;
              v12 -= nocancel;
              v14 += nocancel;
              if ( v12 <= 0 )
              {
                v8 = v25;
                v3 = v24;
                goto LABEL_22;
              }
            }
            v23 = nocancel;
            free(a3, (int)v25);
            if ( !v23 )
              __writegsdword(0xFFFFFFE8, 0x16u);
            goto LABEL_12;
          }
LABEL_22:
          v16 = (_BYTE *)v27;
          v27 = 0;
          __writegsdword(0xFFFFFFE8, (unsigned int)v16);
        }
        else
        {
          v27 = 0;
        }
      }
      else
      {
        v27 = 1;
        v8 = 0;
      }
    }
    else
    {
      v27 = 1;
    }
    dl_sysinfo(v7);
    if ( v8 )
    {
      nl_intern_locale_data(v26, v8, v30, (int)&savedregs, a3);
      if ( v9 )
      {
        v10 = (_BYTE *)v27;
        *v9 = 0;
        v9[3] = v10;
        *(_DWORD *)(v3 + 8) = v9;
      }
      else if ( v27 == 1 )
      {
        munmap((int)v8, v30);
      }
    }
  }
}
// 8099C1F: variable 'v7' is possibly undefined
// 8099C38: variable 'v9' is possibly undefined
// 8099C83: variable 'v6' is possibly undefined
// 8099CCB: variable 'v11' is possibly undefined
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (08099E10) --------------------------------------------------------
void __usercall nl_unload_locale(int *a1@<eax>, long double a2@<st0>)
{
  void (*v3)(void); // edx
  int v4; // eax

  v3 = (void (*)(void))a1[4];
  if ( v3 )
    v3();
  v4 = a1[3];
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      munmap(a1[1], a1[2]);
      v4 = a1[3];
    }
  }
  else
  {
    free(a2, a1[1]);
    v4 = a1[3];
  }
  if ( v4 != 2 )
    free(a2, *a1);
  free(a2, (int)a1);
}

//----- (08099E70) --------------------------------------------------------
int __cdecl rangecmp(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (08099E80) --------------------------------------------------------
int __usercall nl_load_locale_from_archive@<eax>(int a1@<eax>, char **a2@<edx>, int a3@<ecx>, long double a4@<st0>)
{
  char *v4; // esi
  int v5; // ebx
  int v6; // eax
  char *v7; // edi
  int v8; // ecx
  int result; // eax
  char *v10; // eax
  char v11; // dl
  int *v12; // ecx
  unsigned int v13; // ebx
  int v14; // eax
  int i; // edx
  int v16; // ecx
  int *v17; // edx
  unsigned int v18; // edx
  unsigned int v19; // eax
  unsigned int v20; // edi
  unsigned int v21; // ebx
  int *v22; // esi
  int v23; // eax
  unsigned int v24; // edi
  int j; // edx
  int v26; // eax
  int v27; // eax
  int v28; // esi
  char *v29; // esi
  int v30; // eax
  signed int v31; // edi
  int v32; // ebx
  int *v33; // edx
  int v34; // edi
  int v35; // esi
  int *v36; // eax
  unsigned int v37; // edx
  int *v38; // ecx
  unsigned int v39; // edi
  int *v40; // ebx
  int v41; // edi
  int v42; // edx
  int *v43; // eax
  unsigned int v44; // edx
  int v45; // edx
  unsigned int v46; // ecx
  unsigned int v47; // ecx
  int *v48; // eax
  int *v49; // eax
  int v50; // edx
  int *v51; // eax
  int *v52; // edx
  int *v53; // ebx
  int *v54; // edx
  unsigned int v55; // ebx
  int v56; // eax
  int v57; // ecx
  int *v58; // eax
  int *v59; // esi
  _BYTE *v60; // eax
  int v61; // eax
  int v62; // edi
  int v63; // ebx
  int *v64; // eax
  int v65; // edx
  int v66; // ecx
  int v67; // eax
  int v68; // edi
  unsigned __int8 *v69; // eax
  unsigned __int8 *v70; // ebx
  int v71; // eax
  unsigned int v72; // edx
  void *v73; // esp
  _WORD *v74; // eax
  _WORD *v75; // eax
  int v76; // eax
  signed int v77; // eax
  int v78; // eax
  unsigned int v79; // edi
  int *v80; // eax
  int v81; // edx
  int v82; // eax
  int v83; // ebx
  char *v84; // [esp+4h] [ebp-204h]
  char v85[4]; // [esp+20h] [ebp-1E8h] BYREF
  int *v86; // [esp+24h] [ebp-1E4h]
  int v87; // [esp+28h] [ebp-1E0h]
  int v88; // [esp+2Ch] [ebp-1DCh]
  int v89; // [esp+30h] [ebp-1D8h]
  int v90; // [esp+34h] [ebp-1D4h]
  int v91; // [esp+38h] [ebp-1D0h]
  int v92; // [esp+3Ch] [ebp-1CCh]
  int v93; // [esp+40h] [ebp-1C8h]
  char **v94; // [esp+44h] [ebp-1C4h]
  int *v95; // [esp+48h] [ebp-1C0h]
  char *s1; // [esp+4Ch] [ebp-1BCh]
  int *v97; // [esp+50h] [ebp-1B8h]
  signed int v98; // [esp+54h] [ebp-1B4h]
  __int64 v99; // [esp+58h] [ebp-1B0h]
  int v100[74]; // [esp+68h] [ebp-1A0h] BYREF
  __int64 v101; // [esp+190h] [ebp-78h] BYREF
  __int64 v102; // [esp+1BCh] [ebp-4Ch]
  int v103; // [esp+1D8h] [ebp-30h]
  __int64 v104; // [esp+1E8h] [ebp-20h]
  int savedregs; // [esp+208h] [ebp+0h] BYREF

  v4 = *a2;
  v92 = a1;
  v94 = a2;
  sysconf(a3, a4, 30);
  v5 = archloaded;
  v93 = v6;
  if ( archloaded )
  {
    while ( 1 )
    {
      v7 = *(char **)(v5 + 4);
      if ( v7 == v4 || !strcmp(v4, *(const char **)(v5 + 4)) )
        break;
      v5 = *(_DWORD *)v5;
      if ( !v5 )
        goto LABEL_8;
    }
    v8 = v92;
    *v94 = v7;
    return *(_DWORD *)(v5 + 4 * v8 + 8);
  }
LABEL_8:
  v10 = strchr(v4, 46);
  if ( v10 )
  {
    v11 = v10[1];
    if ( v11 != 64 )
    {
      if ( v11 )
      {
        v68 = (int)(v10 + 1);
        v98 = (signed int)strchrnul((unsigned int *)(v10 + 1), 64);
        LODWORD(v99) = v98 - v68;
        v69 = (unsigned __int8 *)nl_normalize_codeset(v68, v98 - v68);
        v70 = v69;
        if ( !v69 )
          return 0;
        if ( strncmp(v69, (unsigned __int8 *)v68, v99) || v70[v99] )
        {
          LODWORD(v99) = strlen(v70);
          v71 = strlen((_BYTE *)v98);
          v72 = v68 - (_DWORD)v4;
          v86 = (int *)(v71 + 1);
          v73 = alloca(v71 + 1 + v68 - (_DWORD)v4 + v99 + 15);
          v84 = v4;
          v4 = &v85;
          v74 = mempcpy(&v85, v84, v72);
          v75 = mempcpy(v74, v70, v99);
          memcpy(v75, (_BYTE *)v98, (unsigned int)v86);
        }
        free(a4, (int)v70);
      }
    }
  }
  if ( !archmapped )
  {
    archmapped = (int)&headmap;
    v78 = _open_nocancel((int)"/usr/lib/locale/locale-archive", 557056);
    v91 = v78;
    if ( v78 >= 0 )
    {
      if ( _fxstat64(3, v78, (int)&archive_stat) == -1 )
        goto LABEL_70;
      v99 = qword_80F0E8C;
      if ( qword_80F0E8C > 0x200000 )
        v99 = 0x200000LL;
      v79 = v99;
      v80 = (int *)mmap64(0, v99, 1, 2, v91, 0LL);
      v97 = v80;
      if ( v80 == (int *)-1 )
        goto LABEL_70;
      v12 = v97;
      v81 = v97[2] + 12 * v80[4];
      v82 = v97[8] + 108 * v97[9];
      if ( v81 >= v82 )
        v82 = v81;
      v83 = v97[5] + v97[6];
      if ( v82 >= v83 )
        v83 = v82;
      if ( v79 < v83 )
      {
        munmap((int)v97, v99);
        if ( (unsigned int)v83 > qword_80F0E8C
          || (v79 = (v93 + v83 - 1) & -v93, v97 = (int *)mmap64(0, v79, 1, 2, v91, 0LL), v97 == (int *)-1) )
        {
LABEL_70:
          dl_sysinfo(v12);
          return 0;
        }
      }
      if ( v79 >= qword_80F0E8C )
      {
        dl_sysinfo(v12);
        v91 = -1;
      }
      dword_80F0E50 = v79;
      headmap = (int)v97;
      goto LABEL_13;
    }
    return 0;
  }
  v91 = -1;
  v97 = (int *)headmap;
LABEL_13:
  v12 = v97;
  if ( v97 )
  {
    v13 = -1;
    v14 = strlen(v4);
    if ( v14 )
    {
      v13 = v14;
      for ( i = 0; i != v14; ++i )
      {
        v16 = v4[i];
        v13 = v16 + __ROR4__(v13, 23);
      }
      if ( !v13 )
        v13 = -1;
    }
    s1 = v4;
    v17 = (int *)((char *)v97 + v97[2]);
    LODWORD(v99) = v97[4];
    v95 = v17;
    v18 = v13;
    v98 = 12 * (v13 % ((int)v99 - 2) + 1);
    v19 = v13 % (unsigned int)v99;
    v20 = v13 % ((int)v99 - 2) + 1;
LABEL_20:
    v21 = v20 + v19;
    v22 = &v95[3 * v19 + 1];
    v23 = v20;
    v24 = v18;
    for ( j = v23; ; v21 += j )
    {
      v26 = *v22;
      v12 = v22 - 1;
      if ( !*v22 )
        break;
      if ( *(v22 - 1) == v24 )
      {
        v87 = j;
        v86 = v22 - 1;
        v27 = strcmp(s1, (const char *)v97 + v26);
        j = v87;
        v12 = v86;
        if ( !v27 )
        {
          v28 = v86[2];
          if ( !v28 )
            break;
          v29 = (char *)v97 + v28;
          v30 = 1;
          v98 = 0;
          while ( 1 )
          {
            if ( v30 != 7 )
            {
              v31 = v98;
              v32 = *(_DWORD *)&v29[8 * v30 - 4];
              ++v98;
              v33 = &v100[4 * v31];
              *v33 = v32;
              v34 = *(_DWORD *)&v29[8 * v30];
              v33[2] = v30 - 1;
              v33[3] = 0;
              v33[1] = v34;
              if ( v30 == 13 )
                break;
            }
            ++v30;
          }
          v35 = 0;
          qsort(a4, (unsigned int)v100, v98, 0x10u, (int (__cdecl *)(unsigned int, unsigned int, int))rangecmp);
          v36 = (int *)archmapped;
          s1 = (char *)(v93 - 1);
          v95 = (int *)archmapped;
          v88 = v93 & (v93 - 1);
          do
          {
            if ( !v36 )
            {
LABEL_39:
              v40 = 0;
LABEL_40:
              if ( v88 )
                _assert_fail(
                  (int)&savedregs,
                  a4,
                  (int)"((((ps) - 1) & (ps)) == 0)",
                  (int)"loadarchive.c",
                  373,
                  "_nl_load_locale_from_archive");
              v41 = v35;
              v42 = v100[4 * v35];
              v43 = &v100[4 * v35 + 1];
              v89 = v35;
              LODWORD(v99) = -v93;
              v90 = v42;
              v12 = (int *)v42;
              v97 = (int *)qword_80F0E8C;
              while ( 1 )
              {
                v44 = (unsigned int)v12 + *v43;
                if ( (unsigned int)v97 < v44 )
                  goto LABEL_69;
                v45 = v99 & (unsigned int)&s1[v44];
                if ( (!v40 || (unsigned int)v12 < v40[1]) && v98 > ++v41 )
                {
                  v12 = (int *)v43[3];
                  v43 += 4;
                  if ( (unsigned int)v12 < v45 + v93 )
                    continue;
                }
                v35 = v89;
                if ( v91 != -1 )
                  goto LABEL_48;
                v87 = v45;
                v91 = _open_nocancel((int)"/usr/lib/locale/locale-archive", 557056);
                if ( v91 == -1 )
                  return 0;
                v77 = _fxstat64(3, v91, (int)&v101);
                v45 = v87;
                if ( v77 >= 0 )
                {
                  v12 = (int *)(qword_80F0E8C ^ v102 | HIDWORD(qword_80F0E8C) ^ HIDWORD(v102));
                  if ( qword_80F0E8C == v102 && v103 == dword_80F0EA8 )
                  {
                    v12 = (int *)(archive_stat ^ v101 | HIDWORD(archive_stat) ^ HIDWORD(v101));
                    if ( archive_stat == v101 )
                    {
                      v12 = (int *)(qword_80F0EB8 ^ v104 | HIDWORD(qword_80F0EB8) ^ HIDWORD(v104));
                      if ( qword_80F0EB8 == v104 )
                      {
LABEL_48:
                        v46 = v90 & v99;
                        v90 = v45 - (v90 & v99);
                        v86 = (int *)v46;
                        LODWORD(v99) = mmap64(0, v90, 1, 2, v91, v46);
                        if ( (_DWORD)v99 == -1 )
                          goto LABEL_69;
                        malloc(a4, 0x10u);
                        v47 = (unsigned int)v86;
                        v97 = v48;
                        if ( !v48 )
                        {
                          munmap(v99, v90);
                          goto LABEL_69;
                        }
                        v49 = v97;
                        v50 = v99;
                        v97[1] = (int)v86;
                        *v49 = v50;
                        v49[2] = v90;
                        v51 = (int *)v95[3];
                        if ( v51 != v40 )
                          _assert_fail(
                            (int)&savedregs,
                            a4,
                            (int)"last->next == mapped",
                            (int)"loadarchive.c",
                            431,
                            "_nl_load_locale_from_archive");
                        v52 = v97;
                        v97[3] = (int)v40;
                        v53 = v95;
                        v95 = v51;
                        v53[3] = (int)v52;
                        v54 = &v100[4 * v35];
                        v55 = v47;
                        do
                        {
                          if ( v55 > *v54 )
                            _assert_fail(
                              (int)&savedregs,
                              a4,
                              (int)"ranges[cnt].from >= from",
                              (int)"loadarchive.c",
                              439,
                              "_nl_load_locale_from_archive");
                          v56 = v54[2];
                          ++v35;
                          v100[2 * v56 + 48] = v99 + *v54 - v55;
                          v57 = v54[1];
                          v54 += 4;
                          v100[2 * v56 + 49] = v57;
                        }
                        while ( v41 > v35 );
                        v36 = v95;
                        v95 = v97;
                        goto LABEL_55;
                      }
                    }
                  }
                }
                goto LABEL_69;
              }
            }
            v37 = v36[1];
            v38 = (int *)v100[4 * v35 + 1];
            LODWORD(v99) = v100[4 * v35];
            v97 = v38;
            v39 = (unsigned int)v38 + v99;
            v40 = v36;
            if ( v37 + v36[2] <= (unsigned int)((unsigned int)v38 + v99) )
            {
              while ( 1 )
              {
                v40 = (int *)v36[3];
                if ( !v40 )
                {
                  v95 = v36;
                  goto LABEL_39;
                }
                v37 = v40[1];
                if ( v37 + v40[2] > v39 )
                  break;
                v36 = (int *)v36[3];
              }
              v95 = v36;
            }
            if ( v37 > (unsigned int)v99 || v37 + v40[2] < v39 )
              goto LABEL_40;
            v76 = v35++;
            v57 = v100[4 * v76 + 2];
            v100[2 * v57 + 48] = *v40 + v99 - v37;
            v100[2 * v57 + 49] = (int)v97;
            v36 = v40;
LABEL_55:
            ;
          }
          while ( v35 < v98 );
          if ( v91 >= 0 )
            dl_sysinfo(v57);
          malloc(a4, 0x3Cu);
          v59 = v58;
          if ( v58 )
          {
            v60 = strdup(*v94);
            v59[1] = (int)v60;
            if ( v60 )
            {
              v61 = archloaded;
              v62 = 1;
              v63 = 0;
              archloaded = (int)v59;
              *v59 = v61;
              while ( 1 )
              {
                if ( v63 != 6 )
                {
                  nl_intern_locale_data(v63, (int *)v100[2 * v63 + 48], v100[2 * v63 + 49], (int)&savedregs, a4);
                  v59[v63 + 2] = (int)v64;
                  if ( v64 )
                  {
                    v65 = v59[1];
                    v64[3] = 2;
                    v64[6] = -1;
                    *v64 = v65;
                  }
                  if ( v62 == 13 )
                    break;
                }
                ++v63;
                ++v62;
              }
              v66 = v92;
              *v94 = (char *)v59[1];
              return v59[v66 + 2];
            }
            else
            {
              free(a4, (int)v59);
              return 0;
            }
          }
          return 0;
        }
      }
      v22 = (int *)((char *)v22 + v98);
      if ( (unsigned int)v99 <= v21 )
      {
        v67 = j;
        v18 = v24;
        v20 = v67;
        v19 = v21 - v99;
        goto LABEL_20;
      }
    }
  }
LABEL_69:
  result = 0;
  if ( v91 >= 0 )
    goto LABEL_70;
  return result;
}
// 8099E80: too many cbuild loops
// 8099EAE: variable 'v6' is possibly undefined
// 809A27E: variable 'v48' is possibly undefined
// 809A357: variable 'v58' is possibly undefined
// 809A3B2: variable 'v64' is possibly undefined
// 809A43B: variable 'v12' is possibly undefined
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80F0E40: using guessed type int archloaded;
// 80F0E44: using guessed type int archmapped;
// 80F0E48: using guessed type int headmap;
// 80F0E50: using guessed type int dword_80F0E50;
// 80F0E60: using guessed type __int64 archive_stat;
// 80F0E8C: using guessed type __int64 qword_80F0E8C;
// 80F0EA8: using guessed type int dword_80F0EA8;
// 80F0EB8: using guessed type __int64 qword_80F0EB8;
// 8099E80: using guessed type char anonymous_1[4];

//----- (0809A8C0) --------------------------------------------------------
unsigned int nl_postload_ctype()
{
  char (*v0)[512]; // ecx
  unsigned int v1; // edx
  unsigned int result; // eax
  bool v3; // zf

  v0 = (char (*)[512])(*((_DWORD *)nl_global_locale + 9) + 256);
  off_80EFBF4 = v0;
  v1 = *((_DWORD *)nl_global_locale + 12) + 512;
  off_80EFBF8 = v1;
  result = *((_DWORD *)nl_global_locale + 10) + 512;
  v3 = __readgsdword(0xFFFFFFD8) == (_DWORD)&nl_global_locale;
  s1 = (char *)result;
  if ( v3 )
  {
    __writegsdword(0xFFFFFFF8, (unsigned int)v0);
    __writegsdword(0xFFFFFFF0, result);
    result = -12;
    __writegsdword(0xFFFFFFF4, v1);
  }
  return result;
}
// 80EFBF4: using guessed type char (*off_80EFBF4)[512];
// 80EFBF8: using guessed type int off_80EFBF8;

//----- (0809A930) --------------------------------------------------------
int __cdecl _current_locale_name(int a1)
{
  return *(_DWORD *)(__readgsdword(0xFFFFFFD8) + 4 * a1 + 64);
}

//----- (0809A950) --------------------------------------------------------
int __cdecl isinf(double a1)
{
  return (SHIDWORD(a1) >> 30) & ~((LODWORD(a1) | HIDWORD(a1) & 0x7FFFFFFF ^ 0x7FF00000 | -(LODWORD(a1) | HIDWORD(a1) & 0x7FFFFFFF ^ 0x7FF00000)) >> 31);
}

//----- (0809A990) --------------------------------------------------------
unsigned int __cdecl isnan(double a1)
{
  return (2146435072 - (HIDWORD(a1) & 0x7FFFFFFF | ((LODWORD(a1) | (unsigned int)-LODWORD(a1)) >> 31))) >> 31;
}

//----- (0809A9C0) --------------------------------------------------------
int __cdecl isinfl(int a1, int a2, __int16 a3)
{
  return (1 - ((a3 & 0x8000) >> 14)) & ~((int)(~a3 & 0x7FFF | a1 | (a2 + 0x80000000) | -(~a3 & 0x7FFF | a1 | (a2 + 0x80000000))) >> 31);
}

//----- (0809AA20) --------------------------------------------------------
int __cdecl isnanl(int a1, int a2, __int16 a3)
{
  return (int)(65534
             - ((unsigned __int16)(2 * a3) | ((unsigned int)(a1 | a2 & 0x7FFFFFFF | -(a1 | a2 & 0x7FFFFFFF)) >> 31))) >> 16;
}

//----- (0809AA70) --------------------------------------------------------
int __usercall _sigsetjmp@<eax>(int ebx0@<ebx>, int ebp0@<ebp>, int a3@<edi>, int a4@<esi>, int a1, int a2)
{
  _DWORD *v6; // eax
  unsigned int retaddr; // [esp+0h] [ebp+0h]

  v6 = (_DWORD *)a1;
  *(_DWORD *)a1 = ebx0;
  v6[1] = a4;
  v6[2] = a3;
  v6[4] = __ROL4__(__readgsdword(0x18u) ^ (unsigned int)&a1, 9);
  v6[5] = __ROL4__(__readgsdword(0x18u) ^ retaddr, 9);
  v6[3] = ebp0;
  return _sigjmp_save(a1, a2);
}

//----- (0809AAB0) --------------------------------------------------------
int __cdecl _sigjmp_save(int a1, int a2)
{
  _BOOL4 v2; // eax

  v2 = 0;
  if ( a2 )
    v2 = sigprocmask(0, 0) == 0;
  *(_DWORD *)(a1 + 24) = v2;
  return 0;
}

//----- (0809AAF0) --------------------------------------------------------
void __noreturn _longjmp(struct __jmp_buf_tag env[1], int val)
{
  ((void (*)(void))(__readgsdword(0x18u) ^ __ROR4__(env->__jmpbuf[5], 9)))();
}

//----- (0809AB30) --------------------------------------------------------
unsigned int raise()
{
  unsigned int v0; // ecx
  unsigned int result; // eax

  v0 = __readgsdword(0x68u);
  if ( !v0 )
  {
    v0 = dl_sysinfo(0);
    __writegsdword(0x68u, v0);
  }
  result = dl_sysinfo(v0);
  if ( result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  return result;
}
// 80EF5A4: using guessed type int (__fastcall *dl_sysinfo)(_DWORD);

//----- (0809ABB0) --------------------------------------------------------
int __cdecl _libc_sigaction(int a1, int *a2, _DWORD *a3)
{
  int *v3; // ecx
  int v4; // eax
  int result; // eax
  int (*v6)(); // edx
  int v7; // [esp+8h] [ebp-128h] BYREF
  int v8; // [esp+Ch] [ebp-124h]
  int (*v9)(); // [esp+10h] [ebp-120h]
  char v10[128]; // [esp+14h] [ebp-11Ch] BYREF
  int v11; // [esp+94h] [ebp-9Ch]
  int v12; // [esp+98h] [ebp-98h]
  int v13; // [esp+9Ch] [ebp-94h]
  char v14[128]; // [esp+A0h] [ebp-90h] BYREF

  v3 = 0;
  if ( a2 )
  {
    LOBYTE(v3) = 32;
    v7 = *a2;
    v4 = a2[33];
    v8 = v4;
    qmemcpy(v10, a2 + 1, 4 * (_DWORD)v3);
    if ( !dl_sysinfo_dso )
    {
      v8 = v4 | 0x4000000;
      v6 = _restore_rt;
      if ( (v4 & 4) == 0 )
        v6 = (int (*)())&_restore;
      v9 = v6;
    }
    v3 = &v7;
  }
  result = dl_sysinfo(v3);
  if ( (unsigned int)result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  else if ( result >= 0 )
  {
    if ( a3 )
    {
      *a3 = v11;
      qmemcpy(a3 + 1, v14, 0x80u);
      a3[33] = v12;
      a3[34] = v13;
    }
  }
  return result;
}
// 809ABA0: using guessed type int _restore_rt();
// 80EF5A4: using guessed type int (__fastcall *dl_sysinfo)(_DWORD);
// 80F11D4: using guessed type int dl_sysinfo_dso;
// 809ABB0: using guessed type char var_11C[128];

//----- (0809ACE0) --------------------------------------------------------
int __cdecl sigaction(int a1, int *a2, _DWORD *a3)
{
  if ( (unsigned int)(a1 - 32) > 1 )
    return _libc_sigaction(a1, a2, a3);
  __writegsdword(0xFFFFFFE8, 0x16u);
  return -1;
}

//----- (0809AD20) --------------------------------------------------------
unsigned int __cdecl sigprocmask(int a1, int *a2)
{
  int *v2; // eax
  unsigned int result; // eax
  int v4[32]; // [esp+0h] [ebp-8Ch] BYREF

  v2 = a2;
  if ( a2 && (*a2 < 0 || (a2[1] & 1) != 0) )
  {
    v2 = v4;
    qmemcpy(v4, a2, sizeof(v4));
    v4[0] &= ~0x80000000;
    v4[1] &= ~1u;
  }
  result = dl_sysinfo(v2);
  if ( result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  return result;
}
// 80EF5A4: using guessed type int (__fastcall *dl_sysinfo)(_DWORD);

//----- (0809ADC0) --------------------------------------------------------
int __cdecl _mpn_cmp(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // edx
  unsigned int v5; // eax
  unsigned int v6; // ecx

  result = 0;
  v4 = a3 - 1;
  if ( a3 - 1 >= 0 )
  {
    do
    {
      v5 = *(_DWORD *)(a1 + 4 * v4);
      v6 = *(_DWORD *)(a2 + 4 * v4);
      if ( v5 != v6 )
        return v6 < v5 ? 1 : -1;
      --v4;
    }
    while ( v4 != -1 );
    return 0;
  }
  return result;
}

//----- (0809AE00) --------------------------------------------------------
int __cdecl _mpn_divrem(int a1, int a2, _DWORD *a3, int a4, unsigned int *a5, unsigned int a6)
{
  int result; // eax
  unsigned int *v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // ebx
  unsigned __int64 v11; // rtt
  unsigned int v12; // ecx
  unsigned __int64 i; // rax
  bool v14; // cf
  unsigned int v15; // eax
  __int64 v16; // rdi
  unsigned int v17; // ecx
  unsigned int v18; // ebx
  int v19; // ebp
  unsigned int v20; // edx
  int v21; // ebx
  unsigned int v22; // ecx
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rax
  unsigned int v25; // edi
  int v26; // ecx
  _DWORD *v27; // esi
  unsigned __int64 v28; // rt2
  int v29; // ecx
  _DWORD *v30; // esi
  int v31; // eax
  unsigned int v32; // [esp+10h] [ebp-4Ch]
  unsigned int v33; // [esp+14h] [ebp-48h]
  unsigned int v34; // [esp+18h] [ebp-44h]
  unsigned int v35; // [esp+18h] [ebp-44h]
  unsigned int *v36; // [esp+1Ch] [ebp-40h]
  int v37; // [esp+20h] [ebp-3Ch]
  int v38; // [esp+20h] [ebp-3Ch]
  unsigned int *v39; // [esp+24h] [ebp-38h]
  unsigned int v40; // [esp+24h] [ebp-38h]
  unsigned int v41; // [esp+28h] [ebp-34h]
  int v42; // [esp+2Ch] [ebp-30h]
  int v43; // [esp+30h] [ebp-2Ch]
  int v44; // [esp+30h] [ebp-2Ch]
  int v45; // [esp+30h] [ebp-2Ch]

  switch ( a6 )
  {
    case 1u:
      HIDWORD(v24) = a3[a4 - 1];
      v45 = 0;
      v25 = *a5;
      if ( *a5 <= HIDWORD(v24) )
      {
        HIDWORD(v24) -= v25;
        v45 = 1;
      }
      v26 = a4 - 2;
      if ( a4 - 2 >= 0 )
      {
        v27 = (_DWORD *)(4 * a2 + a1 + 4 * v26);
        do
        {
          LODWORD(v24) = a3[v26--];
          v28 = v24 % v25;
          LODWORD(v24) = v24 / v25;
          HIDWORD(v24) = v28;
          *v27-- = v24;
        }
        while ( v26 != -1 );
      }
      v29 = a2 - 1;
      if ( a2 - 1 >= 0 )
      {
        v30 = (_DWORD *)(a1 + 4 * v29);
        do
        {
          --v29;
          LODWORD(v24) = __PAIR64__(HIDWORD(v24), 0) / v25;
          HIDWORD(v24) = __PAIR64__(HIDWORD(v24), 0) % v25;
          *v30-- = v24;
        }
        while ( v29 != -1 );
      }
      *a3 = HIDWORD(v24);
      return v45;
    case 2u:
      v36 = &a3[a4 - 2];
      v44 = 0;
      v16 = *(_QWORD *)a5;
      v17 = v36[1];
      v18 = *v36;
      if ( a5[1] <= v17 && (v18 >= (unsigned int)v16 || v17 > HIDWORD(v16)) )
      {
        v17 = (__PAIR64__(v17, v18) - v16) >> 32;
        v18 -= v16;
        v44 = 1;
      }
      v19 = a2 + a4 - 3;
      if ( v19 < 0 )
      {
LABEL_35:
        result = v44;
        v36[1] = v17;
        *v36 = v18;
        return result;
      }
      v38 = -(int)v16;
      v40 = *a5;
      while ( 1 )
      {
        if ( a2 > v19 )
        {
          *v36 = 0;
          v35 = 0;
          if ( v17 != HIDWORD(v16) )
          {
LABEL_28:
            LODWORD(v16) = v40;
            v20 = __PAIR64__(v17, v18) % HIDWORD(v16);
            v21 = __PAIR64__(v17, v18) / HIDWORD(v16);
            v22 = v20;
            v23 = (unsigned int)v21 * (unsigned __int64)v40;
            do
            {
LABEL_29:
              if ( HIDWORD(v23) <= v22 && ((unsigned int)v23 <= v35 || HIDWORD(v23) != v22) )
                break;
              --v21;
              v23 -= (unsigned int)v16;
              v14 = __CFADD__(HIDWORD(v16), v22);
              v22 += HIDWORD(v16);
            }
            while ( !v14 );
            v40 = v16;
            *(_DWORD *)(a1 + 4 * v19) = v21;
            v17 = (__PAIR64__(v22, v35) - v23) >> 32;
            v18 = v35 - v23;
            goto LABEL_34;
          }
        }
        else
        {
          v35 = *--v36;
          if ( v17 != HIDWORD(v16) )
            goto LABEL_28;
        }
        v14 = __CFADD__(v18, v17);
        v22 = v18 + v17;
        if ( !v14 )
        {
          v21 = -1;
          LODWORD(v16) = v40;
          HIDWORD(v23) = v40 - (v40 != 0);
          LODWORD(v23) = v38;
          goto LABEL_29;
        }
        v17 = (v40 + __PAIR64__(v22 - v40, v35)) >> 32;
        v18 = v40 + v35;
        *(_DWORD *)(a1 + 4 * v19) = -1;
LABEL_34:
        if ( --v19 == -1 )
          goto LABEL_35;
      }
    case 0u:
      return 1 / 0;
  }
  v43 = 0;
  v7 = &a3[a4 - a6];
  v42 = a6 - 1;
  v34 = a5[a6 - 1];
  v8 = a5[a6 - 2];
  v9 = v7[a6 - 1];
  v39 = &v7[a6 - 1];
  if ( v34 <= v9 )
  {
    if ( v34 < v9 || (v33 = v7[a6 - 1], v31 = _mpn_cmp((int)&a3[a4 - a6], (int)a5, v42), v9 = v33, v31 >= 0) )
    {
      _mpn_sub_n(v7, v7, a5, a6);
      v43 = 1;
      v9 = *v39;
    }
  }
  v37 = a2 + a4 - a6 - 1;
  if ( v37 >= 0 )
  {
    if ( a2 > v37 )
      goto LABEL_20;
LABEL_9:
    --v7;
    v41 = v7[a6];
    v39 = &v7[a6 - 1];
    while ( 1 )
    {
      v10 = -1;
      if ( v9 != v34 )
      {
        LODWORD(v11) = *v39;
        HIDWORD(v11) = v9;
        v12 = v11 % v34;
        v32 = v11 / v34;
        for ( i = v32 * (unsigned __int64)v8; i > __PAIR64__(v12, v7[a6 - 2]); i -= v8 )
        {
          --v32;
          v14 = __CFADD__(v34, v12);
          v12 += v34;
          if ( v14 )
            break;
        }
        v10 = v32;
      }
      if ( v41 != _mpn_submul_1((int)v7, (int)a5, a6, v10) )
      {
        --v10;
        _mpn_add_n(v7, v7, a5, a6);
      }
      *(_DWORD *)(a1 + 4 * v37--) = v10;
      v9 = *v39;
      if ( v37 == -1 )
        break;
      if ( a2 <= v37 )
        goto LABEL_9;
LABEL_20:
      v15 = a6 - 1;
      v41 = *v39;
      if ( v42 >= 0 )
      {
        do
        {
          v7[v15 + 1] = v7[v15];
          --v15;
        }
        while ( v15 != -1 );
      }
      *v7 = 0;
    }
  }
  return v43;
}

//----- (0809B230) --------------------------------------------------------
int __cdecl _mpn_lshift(_DWORD *a1, int a2, int a3, char a4)
{
  int v4; // esi
  unsigned int v5; // ebx
  int result; // eax
  int v7; // edx
  unsigned int v8; // eax
  int v9; // [esp-4h] [ebp-10h]

  v4 = a2 - 4;
  v5 = *(_DWORD *)(a2 - 4 + 4 * a3);
  result = (unsigned __int64)v5 << a4 >> 32;
  v7 = a3 - 1;
  if ( a3 == 1 )
  {
    *a1 = v5 << a4;
  }
  else
  {
    v9 = (unsigned __int64)*(unsigned int *)(a2 - 4 + 4 * a3) << a4 >> 32;
    if ( (v7 & 1) != 0 )
      goto LABEL_5;
    v8 = *(_DWORD *)(a2 - 4 + 4 * a3);
    do
    {
      v5 = *(_DWORD *)(v4 + 4 * v7);
      a1[v7--] = __PAIR64__(v8, v5) << a4 >> 32;
LABEL_5:
      v8 = *(_DWORD *)(v4 + 4 * v7);
      a1[v7--] = __PAIR64__(v5, v8) << a4 >> 32;
    }
    while ( v7 );
    *a1 = v8 << a4;
    return v9;
  }
  return result;
}

//----- (0809B290) --------------------------------------------------------
int __cdecl _mpn_rshift(int a1, unsigned int *a2, int a3, char a4)
{
  unsigned int *v4; // edi
  unsigned int *v5; // esi
  unsigned int v6; // ebx
  int result; // eax
  unsigned __int64 v8; // rt0
  int v9; // edx
  unsigned int v10; // eax
  int v11; // [esp-4h] [ebp-10h]

  v4 = (unsigned int *)(a1 + 4 * a3 - 4);
  v5 = &a2[a3];
  v6 = *a2;
  LODWORD(v8) = 0;
  HIDWORD(v8) = *a2;
  result = v8 >> a4;
  v9 = 1 - a3;
  if ( a3 == 1 )
  {
    *v4 = v6 >> a4;
  }
  else
  {
    v11 = result;
    if ( (v9 & 1) != 0 )
      goto LABEL_5;
    v10 = *a2;
    do
    {
      v6 = v5[v9];
      v4[v9++] = __PAIR64__(v6, v10) >> a4;
LABEL_5:
      v10 = v5[v9];
      v4[v9++] = __PAIR64__(v10, v6) >> a4;
    }
    while ( v9 );
    *v4 = v10 >> a4;
    return v11;
  }
  return result;
}

//----- (0809B2F0) --------------------------------------------------------
int __cdecl _mpn_mul(_DWORD *a1, unsigned int *a2, int a3, unsigned int *a4, int a5)
{
  unsigned int v5; // edi
  int result; // eax
  unsigned int *v7; // esi
  _DWORD *k; // ebx
  unsigned int v9; // eax
  bool v10; // zf
  void *v11; // esp
  unsigned int *v12; // esi
  int v13; // edx
  int j; // eax
  _DWORD *v15; // ebx
  _BOOL4 v16; // eax
  unsigned int *v17; // edx
  _BOOL4 v18; // ecx
  _DWORD *v19; // eax
  unsigned int v20; // ebx
  int *v21; // eax
  unsigned int v22; // ecx
  int *v23; // edx
  int v24; // esi
  int v25; // ecx
  void *v26; // esp
  unsigned int *v27; // ebx
  _BOOL4 v28; // eax
  int v29; // edi
  int *v30; // edx
  int *v31; // ecx
  unsigned int v32; // eax
  bool v33; // cc
  int v34; // edi
  int i; // eax
  int v36; // eax
  int v37; // ecx
  int v38; // ebx
  _DWORD v39[2]; // [esp+20h] [ebp-48h] BYREF
  int v40; // [esp+28h] [ebp-40h]
  unsigned int *v41; // [esp+2Ch] [ebp-3Ch]
  int *v42; // [esp+30h] [ebp-38h]
  _DWORD *v43; // [esp+34h] [ebp-34h]
  _DWORD *v44; // [esp+38h] [ebp-30h]
  unsigned int *v45; // [esp+3Ch] [ebp-2Ch]
  unsigned int v46; // [esp+40h] [ebp-28h]
  int v47; // [esp+44h] [ebp-24h]
  int v48; // [esp+48h] [ebp-20h]
  _DWORD *v49; // [esp+4Ch] [ebp-1Ch]

  v5 = a5;
  if ( a5 > 31 )
  {
    v11 = alloca(8 * a5 + 15);
    v44 = v39;
    _mpn_impn_mul_n(a1, a2, a4, a5, v39);
    v46 = 4 * a5;
    v12 = &a1[a5];
    v45 = &a2[a5];
    v48 = a3 - a5;
    if ( a5 <= a3 - a5 )
    {
      v26 = alloca(8 * a5 + 15);
      v43 = v39;
      v40 = -a5;
      v27 = &a1[a5];
      v47 = a5;
      v41 = &v39[v46 / 4];
      v42 = &v39[v46 / 4 + 1];
      do
      {
        _mpn_impn_mul_n(v43, v45, a4, v47, v44);
        v28 = _mpn_add_n(v27, v27, v43, v47);
        v27 = (unsigned int *)((char *)v27 + v46);
        v29 = v47;
        v30 = v42;
        v31 = (int *)(v27 + 1);
        v32 = *v41 + v28;
        v33 = *v41 <= v32;
        *v27 = v32;
        if ( v33 )
        {
LABEL_32:
          if ( v31 != v30 )
          {
            v34 = v29 - 1;
            if ( v34 > 0 )
            {
              for ( i = 0; i < v34; ++i )
                v31[i] = v30[i];
            }
          }
        }
        else
        {
          while ( --v29 )
          {
            v36 = *v30++;
            *v31++ = ++v36;
            if ( v36 )
              goto LABEL_32;
          }
        }
        v48 += v40;
        v45 = (unsigned int *)((char *)v45 + v46);
      }
      while ( v47 <= v48 );
      v12 = v27;
      v5 = v47;
    }
    if ( v48 )
    {
      _mpn_mul(v44, a4, v5, v45, v48);
      v15 = v44;
      v16 = _mpn_add_n(v12, v12, v44, v5);
      v17 = &v12[v46 / 4];
      v18 = v16;
      v19 = &v15[v46 / 4];
      v20 = v15[v46 / 4];
      v21 = v19 + 1;
      v22 = v20 + v18;
      *v17 = v22;
      v23 = (int *)(v17 + 1);
      if ( v20 > v22 )
      {
        v37 = v48;
        while ( --v37 )
        {
          v38 = *v21++;
          *v23++ = ++v38;
          if ( v38 )
          {
            v48 = v37;
            goto LABEL_25;
          }
        }
      }
      else
      {
LABEL_25:
        if ( v23 != v21 )
        {
          v24 = v48 - 1;
          if ( v48 - 1 > 0 )
          {
            v25 = 0;
            do
            {
              v23[v25] = v21[v25];
              ++v25;
            }
            while ( v24 > v25 );
          }
        }
      }
    }
    return a1[a3 - 1 + v5];
  }
  else
  {
    result = 0;
    if ( a5 )
    {
      if ( *a4 <= 1 )
      {
        if ( *a4 == 1 )
        {
          if ( a3 > 0 )
          {
            for ( j = 0; j != a3; ++j )
              a1[j] = a2[j];
            result = 0;
          }
        }
        else
        {
          v13 = 0;
          if ( a3 > 0 )
          {
            do
              a1[v13++] = 0;
            while ( v13 != a3 );
            result = 0;
          }
        }
      }
      else
      {
        result = _mpn_mul_1((int)a1, (int)a2, a3, *a4);
      }
      a1[a3] = result;
      if ( a5 > 1 )
      {
        v7 = a4;
        v49 = &a1[a5];
        for ( k = a1 + 1; k != v49; ++k )
        {
          while ( 1 )
          {
            v9 = v7[1];
            v10 = v9 == 1;
            if ( v9 <= 1 )
              break;
            result = _mpn_addmul_1((int)k, (int)a2, a3, v7[1]);
LABEL_8:
            k[a3] = result;
            ++v7;
            if ( ++k == v49 )
              return result;
          }
          result = 0;
          if ( !v10 )
            goto LABEL_8;
          ++v7;
          result = _mpn_add_n(k, k, a2, a3);
          k[a3] = result;
        }
      }
    }
  }
  return result;
}

//----- (0809B640) --------------------------------------------------------
int __cdecl _mpn_mul_1(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // ecx
  int v5; // ebp
  unsigned __int64 v6; // rax
  int v7; // edx

  v4 = -a3;
  v5 = 0;
  do
  {
    v6 = a4 * (unsigned __int64)*(unsigned int *)(a2 + 4 * a3 + 4 * v4);
    *(_DWORD *)(a1 + 4 * a3 + 4 * v4) = v5 + v6;
    v7 = __CFADD__(v5, (_DWORD)v6) + HIDWORD(v6);
    v5 = v7;
    ++v4;
  }
  while ( v4 );
  return v7;
}

//----- (0809B680) --------------------------------------------------------
unsigned int __cdecl _mpn_impn_mul_n_basecase(int a1, _DWORD *a2, unsigned int *a3, int a4)
{
  unsigned int result; // eax
  _DWORD *v5; // esi
  int j; // ebx
  unsigned int v7; // eax
  bool v8; // zf
  int i; // eax

  result = *a3;
  if ( *a3 > 1 )
  {
    result = _mpn_mul_1(a1, (int)a2, a4, *a3);
    goto LABEL_3;
  }
  if ( *a3 == 1 )
  {
    if ( a4 > 0 )
    {
      for ( i = 0; i != a4; ++i )
        *(_DWORD *)(a1 + 4 * i) = a2[i];
      result = 0;
      goto LABEL_3;
    }
LABEL_10:
    *(_DWORD *)(a1 + 4 * a4) = 0;
    return result;
  }
  result = 0;
  if ( a4 <= 0 )
    goto LABEL_10;
  do
    *(_DWORD *)(a1 + 4 * result++) = 0;
  while ( result != a4 );
  result = 0;
LABEL_3:
  *(_DWORD *)(a1 + 4 * a4) = result;
  if ( a4 > 1 )
  {
    v5 = (_DWORD *)(a1 + 4);
    for ( j = 1; j != a4; ++j )
    {
      v7 = a3[j];
      v8 = v7 == 1;
      if ( v7 > 1 )
      {
        result = _mpn_addmul_1((int)v5, (int)a2, a4, a3[j]);
      }
      else
      {
        result = 0;
        if ( v8 )
          result = _mpn_add_n(v5, v5, a2, a4);
      }
      v5[a4] = result;
      ++v5;
    }
  }
  return result;
}

//----- (0809B780) --------------------------------------------------------
unsigned int __cdecl _mpn_impn_mul_n(_DWORD *a1, unsigned int *a2, unsigned int *a3, int a4, _DWORD *a5)
{
  int v5; // ebx
  unsigned int result; // eax
  int v7; // ebx
  unsigned int *v8; // edi
  int i; // eax
  unsigned int *v10; // edi
  int v11; // edx
  unsigned int v12; // edx
  bool v13; // cc
  int *v14; // edi
  int v15; // edx
  int v16; // eax
  int j; // eax
  int v18; // edx
  unsigned int *v19; // edi
  unsigned int *v20; // [esp+28h] [ebp-34h]
  int v21; // [esp+2Ch] [ebp-30h]
  int v22; // [esp+2Ch] [ebp-30h]
  unsigned int *v23; // [esp+30h] [ebp-2Ch]
  int v24; // [esp+34h] [ebp-28h]
  int v25; // [esp+38h] [ebp-24h]
  _BOOL4 v26; // [esp+3Ch] [ebp-20h]

  if ( (a4 & 1) != 0 )
  {
    v5 = a4 - 1;
    if ( a4 - 1 <= 31 )
      _mpn_impn_mul_n_basecase((int)a1, a2, a3, a4 - 1);
    else
      _mpn_impn_mul_n(a1, a2, a3, a4 - 1, a5);
    a1[2 * v5] = _mpn_addmul_1((int)&a1[v5], (int)a2, v5, a3[v5]);
    result = _mpn_addmul_1((int)&a1[v5], (int)a3, a4, a2[v5]);
    a1[a4 + v5] = result;
    return result;
  }
  v7 = a4 >> 1;
  v24 = a4 >> 1;
  v25 = a4;
  v8 = &a2[v24];
  v23 = &a1[a4];
  if ( a4 >> 1 <= 31 )
    _mpn_impn_mul_n_basecase((int)&a1[a4], &a2[v7], &a3[v7], v7);
  else
    _mpn_impn_mul_n(&a1[a4], &a2[v7], &a3[v7], v7, a5);
  if ( _mpn_cmp((int)v8, (int)a2, v7) < 0 )
  {
    _mpn_sub_n(a1, a2, v8, v7);
    v21 = 1;
  }
  else
  {
    _mpn_sub_n(a1, v8, a2, v7);
    v21 = 0;
  }
  v20 = &a1[v24];
  if ( _mpn_cmp((int)&a3[a4 >> 1], (int)a3, v7) < 0 )
  {
    _mpn_sub_n(&a1[v24], a3, &a3[a4 >> 1], v7);
  }
  else
  {
    _mpn_sub_n(&a1[v24], &a3[a4 >> 1], a3, v7);
    v21 ^= 1u;
  }
  if ( v7 > 31 )
  {
    _mpn_impn_mul_n(a5, a1, v20, v7, &a5[v25]);
  }
  else
  {
    _mpn_impn_mul_n_basecase((int)a5, a1, v20, v7);
    if ( v7 <= 0 )
      goto LABEL_16;
  }
  for ( i = 0; i != v7; ++i )
    a1[v7 + i] = a1[a4 + i];
LABEL_16:
  v10 = &a1[v7 + a4];
  v26 = _mpn_add_n(v23, v23, v10, v7);
  if ( v21 )
    v22 = v26 - _mpn_sub_n(v20, v20, a5, a4);
  else
    v22 = v26 + _mpn_add_n(v20, v20, a5, a4);
  if ( v7 > 31 )
    _mpn_impn_mul_n(a5, a2, a3, v7, &a5[v25]);
  else
    _mpn_impn_mul_n_basecase((int)a5, a2, a3, v7);
  v11 = _mpn_add_n(v20, v20, a5, a4) + v22;
  if ( v11 )
  {
    v12 = *v10 + v11;
    v13 = *v10 <= v12;
    *v10 = v12;
    if ( !v13 )
    {
      v14 = (int *)(v10 + 1);
      v15 = a4 >> 1;
      do
      {
        if ( !--v15 )
          break;
        v16 = *v14 + 1;
        *v14++ = v16;
      }
      while ( !v16 );
    }
  }
  if ( v7 > 0 )
  {
    for ( j = 0; j != v7; ++j )
      a1[j] = a5[j];
  }
  result = _mpn_add_n(v20, v20, &a5[v24], v7);
  if ( result )
  {
    result = *v23 + 1;
    v13 = *v23 <= result;
    *v23 = result;
    if ( !v13 )
    {
      v18 = a4;
      v19 = v23 + 1;
      do
      {
        if ( !--v18 )
          break;
        result = *v19 + 1;
        *v19++ = result;
      }
      while ( !result );
    }
  }
  return result;
}

//----- (0809BBD0) --------------------------------------------------------
unsigned int __cdecl _mpn_impn_sqr_n_basecase(int a1, unsigned int *a2, int a3)
{
  unsigned int result; // eax
  _DWORD *v4; // esi
  int j; // ebx
  unsigned int v6; // eax
  bool v7; // zf
  int i; // eax

  result = *a2;
  if ( *a2 > 1 )
  {
    result = _mpn_mul_1(a1, (int)a2, a3, *a2);
    goto LABEL_3;
  }
  if ( *a2 == 1 )
  {
    if ( a3 > 0 )
    {
      for ( i = 0; i != a3; ++i )
        *(_DWORD *)(a1 + 4 * i) = a2[i];
      result = 0;
      goto LABEL_3;
    }
LABEL_10:
    *(_DWORD *)(a1 + 4 * a3) = 0;
    return result;
  }
  result = 0;
  if ( a3 <= 0 )
    goto LABEL_10;
  do
    *(_DWORD *)(a1 + 4 * result++) = 0;
  while ( result != a3 );
  result = 0;
LABEL_3:
  *(_DWORD *)(a1 + 4 * a3) = result;
  if ( a3 > 1 )
  {
    v4 = (_DWORD *)(a1 + 4);
    for ( j = 1; j != a3; ++j )
    {
      v6 = a2[j];
      v7 = v6 == 1;
      if ( v6 > 1 )
      {
        result = _mpn_addmul_1((int)v4, (int)a2, a3, a2[j]);
      }
      else
      {
        result = 0;
        if ( v7 )
          result = _mpn_add_n(v4, v4, a2, a3);
      }
      v4[a3] = result;
      ++v4;
    }
  }
  return result;
}

//----- (0809BCC0) --------------------------------------------------------
unsigned int __cdecl _mpn_impn_sqr_n(unsigned int *a1, unsigned int *a2, int a3, _DWORD *a4)
{
  int v4; // ebx
  unsigned int *v5; // edi
  unsigned int result; // eax
  int v7; // ebx
  unsigned int *v8; // edi
  int i; // eax
  _BOOL4 v10; // edi
  _BOOL4 v11; // eax
  unsigned int *v12; // edx
  int v13; // edi
  unsigned int *v14; // edx
  int v15; // edi
  unsigned int v16; // edi
  bool v17; // cc
  int v18; // ecx
  int *v19; // edi
  int v20; // eax
  int j; // eax
  int v22; // edx
  unsigned int *v23; // edi
  _BOOL4 v24; // edi
  _BOOL4 v25; // eax
  unsigned int *v26; // [esp+1Ch] [ebp-30h]
  unsigned int *v27; // [esp+1Ch] [ebp-30h]
  unsigned int *v28; // [esp+20h] [ebp-2Ch]
  int v29; // [esp+24h] [ebp-28h]
  unsigned int *v30; // [esp+28h] [ebp-24h]
  int v31; // [esp+2Ch] [ebp-20h]

  if ( (a3 & 1) != 0 )
  {
    v4 = a3 - 1;
    if ( a3 - 1 <= 31 )
      _mpn_impn_sqr_n_basecase((int)a1, a2, a3 - 1);
    else
      _mpn_impn_sqr_n(a1, a2, a3 - 1, a4);
    v5 = &a2[v4];
    a1[2 * v4] = _mpn_addmul_1((int)&a1[v4], (int)a2, v4, *v5);
    result = _mpn_addmul_1((int)&a1[v4], (int)a2, a3, *v5);
    a1[a3 + v4] = result;
    return result;
  }
  v7 = a3 >> 1;
  v29 = a3 >> 1;
  v8 = &a2[v29];
  v31 = a3;
  v28 = &a1[a3];
  if ( a3 >> 1 <= 31 )
    _mpn_impn_sqr_n_basecase((int)&a1[a3], &a2[v7], v7);
  else
    _mpn_impn_sqr_n(&a1[a3], &a2[v7], v7, a4);
  if ( _mpn_cmp((int)v8, (int)a2, v7) < 0 )
    _mpn_sub_n(a1, a2, v8, v7);
  else
    _mpn_sub_n(a1, v8, a2, v7);
  if ( v7 > 31 )
  {
    _mpn_impn_sqr_n(a4, a1, v7, &a4[v31]);
  }
  else
  {
    _mpn_impn_sqr_n_basecase((int)a4, a1, v7);
    if ( v7 <= 0 )
    {
      v30 = &a1[v7 + a3];
      v24 = _mpn_add_n(v28, v28, v30, v7);
      v25 = _mpn_sub_n(&a1[v29], &a1[v29], a4, a3);
      v12 = &a1[v29];
      v13 = v24 - v25;
      goto LABEL_34;
    }
  }
  for ( i = 0; i != v7; ++i )
    a1[v7 + i] = a1[a3 + i];
  v30 = &a1[v7 + a3];
  v10 = _mpn_add_n(v28, v28, v30, v7);
  v11 = _mpn_sub_n(&a1[v29], &a1[v29], a4, a3);
  v12 = &a1[v29];
  v13 = v10 - v11;
  if ( v7 > 31 )
  {
    _mpn_impn_sqr_n(a4, a2, v7, &a4[v31]);
    v14 = &a1[v29];
    goto LABEL_16;
  }
LABEL_34:
  v27 = v12;
  _mpn_impn_sqr_n_basecase((int)a4, a2, v7);
  v14 = v27;
LABEL_16:
  v26 = v14;
  v15 = _mpn_add_n(v14, v14, a4, a3) + v13;
  if ( v15 )
  {
    v16 = *v30 + v15;
    v17 = *v30 <= v16;
    *v30 = v16;
    if ( !v17 )
    {
      v18 = a3 >> 1;
      v19 = (int *)(v30 + 1);
      do
      {
        if ( !--v18 )
          break;
        v20 = *v19 + 1;
        *v19++ = v20;
      }
      while ( !v20 );
    }
  }
  if ( v7 > 0 )
  {
    for ( j = 0; j != v7; ++j )
      a1[j] = a4[j];
  }
  result = _mpn_add_n(v26, v26, &a4[v29], v7);
  if ( result )
  {
    result = *v28 + 1;
    v17 = *v28 <= result;
    *v28 = result;
    if ( !v17 )
    {
      v22 = a3;
      v23 = v28 + 1;
      do
      {
        if ( !--v22 )
          break;
        result = *v23 + 1;
        *v23++ = result;
      }
      while ( !result );
    }
  }
  return result;
}

//----- (0809C040) --------------------------------------------------------
unsigned int __cdecl _mpn_mul_n(unsigned int *a1, unsigned int *a2, unsigned int *a3, int a4)
{
  void *v4; // esp
  void *v6; // esp
  int v7; // [esp+20h] [ebp-8h] BYREF

  if ( a2 == a3 )
  {
    if ( a4 > 31 )
    {
      v6 = alloca(8 * a4 + 15);
      return _mpn_impn_sqr_n(a1, a2, a4, &v7);
    }
    else
    {
      return _mpn_impn_sqr_n_basecase((int)a1, a2, a4);
    }
  }
  else if ( a4 <= 31 )
  {
    return _mpn_impn_mul_n_basecase((int)a1, a2, a3, a4);
  }
  else
  {
    v4 = alloca(8 * a4 + 15);
    return _mpn_impn_mul_n(a1, a2, a3, a4, &v7);
  }
}

//----- (0809C100) --------------------------------------------------------
_BOOL4 __cdecl _mpn_sub_n(_DWORD *a1, unsigned int *a2, _DWORD *a3, unsigned int a4)
{
  unsigned int v7; // ecx
  bool v8; // cf
  unsigned int v9; // ett
  unsigned int v10; // eax
  unsigned int v11; // ett
  unsigned int v12; // eax
  unsigned int v13; // ett
  unsigned int v14; // eax
  unsigned int v15; // ett
  unsigned int v16; // eax
  unsigned int v17; // ett
  unsigned int v18; // eax
  unsigned int v19; // ett
  unsigned int v20; // eax
  unsigned int v21; // ett
  unsigned int v22; // eax
  unsigned int v23; // ett

  v7 = a4 >> 3;
  v8 = 0;
  if ( (-a4 & 7) != 0 )
    __asm { jmp     eax }
  do
  {
    v9 = v8 + *a3;
    v8 = *a2 < v9;
    *a1 = *a2 - v9;
    v10 = a2[1];
    v11 = v8 + a3[1];
    v8 = v10 < v11;
    a1[1] = v10 - v11;
    v12 = a2[2];
    v13 = v8 + a3[2];
    v8 = v12 < v13;
    a1[2] = v12 - v13;
    v14 = a2[3];
    v15 = v8 + a3[3];
    v8 = v14 < v15;
    a1[3] = v14 - v15;
    v16 = a2[4];
    v17 = v8 + a3[4];
    v8 = v16 < v17;
    a1[4] = v16 - v17;
    v18 = a2[5];
    v19 = v8 + a3[5];
    v8 = v18 < v19;
    a1[5] = v18 - v19;
    v20 = a2[6];
    v21 = v8 + a3[6];
    v8 = v20 < v21;
    a1[6] = v20 - v21;
    v22 = a2[7];
    v23 = v8 + a3[7];
    v8 = v22 < v23;
    a1[7] = v22 - v23;
    a1 += 8;
    a2 += 8;
    a3 += 8;
    --v7;
  }
  while ( v7 );
  return v8;
}

//----- (0809C190) --------------------------------------------------------
int __cdecl _mpn_submul_1(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // edi
  int v5; // ecx
  int v6; // ebp
  unsigned __int64 v7; // rax
  bool v8; // cf
  int v9; // edx

  v4 = a1 + 4 * a3;
  v5 = -a3;
  v6 = 0;
  do
  {
    v7 = (unsigned int)v6 + a4 * (unsigned __int64)*(unsigned int *)(a2 + 4 * a3 + 4 * v5);
    v8 = *(_DWORD *)(v4 + 4 * v5) < (unsigned int)v7;
    *(_DWORD *)(v4 + 4 * v5) -= v7;
    v9 = v8 + HIDWORD(v7);
    v6 = v9;
    ++v5;
  }
  while ( v5 );
  return v9;
}

//----- (0809C1D0) --------------------------------------------------------
int __cdecl _mpn_extract_double(
        unsigned int *a1,
        int a2,
        _DWORD *a3,
        unsigned int *a4,
        unsigned int a5,
        unsigned int a6)
{
  int v6; // esi
  unsigned int v7; // esi
  signed int v8; // esi
  unsigned int v10; // edi

  *a4 = a6 >> 31;
  *a3 = ((a6 >> 20) & 0x7FF) - 1023;
  *a1 = a5;
  v6 = a6 & 0xFFFFF;
  a1[1] = a6 & 0xFFFFF;
  if ( (a6 & 0x7FF00000) != 0 )
  {
    a1[1] = v6 | 0x100000;
    return 2;
  }
  if ( !a5 )
  {
    if ( !v6 )
    {
      *a3 = 0;
      return 2;
    }
    goto LABEL_10;
  }
  if ( v6 )
  {
LABEL_10:
    _BitScanReverse(&v10, v6);
    v10 ^= 0x1Fu;
    a1[1] = (v6 << (v10 - 11)) | (a5 >> (43 - v10));
    *a1 = a5 << (v10 - 11);
    *a3 = -1011 - v10;
    return 2;
  }
  _BitScanReverse(&v7, a5);
  v8 = v7 ^ 0x1F;
  if ( v8 > 10 )
  {
    a1[1] = a5 << (v8 - 11);
    *a1 = 0;
  }
  else
  {
    a1[1] = a5 >> (11 - v8);
    *a1 = a5 << (v8 + 21);
  }
  *a3 = -1043 - v8;
  return 2;
}

//----- (0809C2E0) --------------------------------------------------------
int __cdecl _mpn_extract_long_double(
        unsigned int *a1,
        int a2,
        _DWORD *a3,
        int *a4,
        unsigned int a5,
        unsigned int a6,
        __int16 a7)
{
  int v7; // edi
  int v8; // esi
  unsigned int v9; // edi
  unsigned int v10; // edi
  unsigned int v12; // ecx

  *a4 = HIBYTE(a7) >> 7;
  v7 = a7 & 0x7FFF;
  *a3 = v7 - 0x3FFF;
  a1[1] = a6;
  *a1 = a5;
  if ( (a7 & 0x7FFF) != 0 )
  {
    if ( v7 == 0x7FFF || a5 || a6 )
      return 2;
    goto LABEL_11;
  }
  if ( !a5 )
  {
    if ( a6 )
    {
      v8 = a6 & 0x7FFFFFFF;
      a1[1] = a6 & 0x7FFFFFFF;
      if ( (a6 & 0x7FFFFFFF) != 0 )
        goto LABEL_4;
LABEL_14:
      if ( a5 )
      {
        _BitScanReverse(&v12, a5);
        v12 ^= 0x1Fu;
        a1[1] = a5 << v12;
        *a1 = 0;
        *a3 = -16414 - v12;
      }
      else
      {
        a1[1] = 0x80000000;
        *a3 = -16382;
      }
      return 2;
    }
LABEL_11:
    *a3 = 0;
    return 2;
  }
  v8 = a6 & 0x7FFFFFFF;
  a1[1] = a6 & 0x7FFFFFFF;
  if ( (a6 & 0x7FFFFFFF) == 0 )
    goto LABEL_14;
LABEL_4:
  _BitScanReverse(&v9, v8);
  v10 = v9 ^ 0x1F;
  if ( v10 )
  {
    a1[1] = (v8 << v10) | (a5 >> (32 - v10));
    *a1 = a5 << v10;
  }
  *a3 = -16382 - v10;
  return 2;
}

//----- (0809C400) --------------------------------------------------------
unsigned int __cdecl quicksort(
        unsigned int a1,
        unsigned int a2,
        unsigned int a3,
        int (__cdecl *a4)(unsigned int, unsigned int, int),
        int a5)
{
  unsigned int result; // eax
  int v7; // esi
  unsigned int v8; // ebp
  int (__cdecl *v9)(unsigned int, unsigned int, int); // esi
  unsigned int v10; // edi
  unsigned int v11; // ebx
  int v12; // eax
  char v13; // dl
  unsigned int v14; // ecx
  signed int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // edi
  unsigned int v18; // ebp
  int v19; // eax
  char v20; // cl
  unsigned int v21; // ebx
  int j; // eax
  unsigned int v23; // ebx
  _BYTE *v24; // edx
  _BYTE *v25; // esi
  _BYTE *v26; // ebp
  _BYTE *v27; // eax
  _BYTE *v28; // ecx
  _BYTE *v29; // edx
  unsigned int v30; // eax
  int v31; // eax
  char v32; // cl
  int v33; // eax
  char v34; // cl
  int v35; // eax
  char v36; // cl
  unsigned int v37; // eax
  unsigned int v38; // [esp+20h] [ebp-13Ch]
  char v39; // [esp+20h] [ebp-13Ch]
  unsigned int v40; // [esp+24h] [ebp-138h]
  unsigned int v41; // [esp+2Ch] [ebp-130h]
  unsigned int i; // [esp+2Ch] [ebp-130h]
  unsigned int v43; // [esp+30h] [ebp-12Ch]
  int (__cdecl *v44)(unsigned int, unsigned int, int); // [esp+30h] [ebp-12Ch]
  char *v45; // [esp+34h] [ebp-128h]
  int v46; // [esp+34h] [ebp-128h]
  unsigned int v47; // [esp+38h] [ebp-124h]
  unsigned int v48; // [esp+3Ch] [ebp-120h]
  int v49[2]; // [esp+40h] [ebp-11Ch] BYREF
  char v50; // [esp+48h] [ebp-114h] BYREF

  result = a2;
  v7 = a5;
  if ( a2 )
  {
    v48 = 4 * a3;
    if ( a2 > 4 )
    {
      v49[0] = 0;
      v49[1] = 0;
      v47 = a1 + a3 * (a2 - 1);
      v43 = v47;
      v45 = &v50;
      v41 = a1;
      while ( 1 )
      {
        v8 = a3 * (((v43 - v41) / a3) >> 1) + v41;
        if ( a4(v8, v41, a5) < 0 )
        {
          v35 = 0;
          do
          {
            v36 = *(_BYTE *)(v8 + v35);
            *(_BYTE *)(v8 + v35) = *(_BYTE *)(v41 + v35);
            *(_BYTE *)(v41 + v35++) = v36;
          }
          while ( v35 != a3 );
        }
        if ( a4(v43, v8, a5) < 0 )
        {
          v31 = 0;
          do
          {
            v32 = *(_BYTE *)(v8 + v31);
            *(_BYTE *)(v8 + v31) = *(_BYTE *)(v43 + v31);
            *(_BYTE *)(v43 + v31++) = v32;
          }
          while ( v31 != a3 );
          if ( a4(v8, v41, a5) < 0 )
          {
            v33 = 0;
            do
            {
              v34 = *(_BYTE *)(v8 + v33);
              *(_BYTE *)(v8 + v33) = *(_BYTE *)(v41 + v33);
              *(_BYTE *)(v41 + v33++) = v34;
            }
            while ( v33 != a3 );
          }
        }
        v9 = a4;
        v10 = v43 - a3;
        v11 = a3 + v41;
        while ( 1 )
        {
          while ( v9(v11, v8, a5) < 0 )
            v11 += a3;
          while ( v9(v8, v10, a5) < 0 )
            v10 -= a3;
          if ( v11 < v10 )
          {
            v12 = 0;
            do
            {
              v13 = *(_BYTE *)(v11 + v12);
              *(_BYTE *)(v11 + v12) = *(_BYTE *)(v10 + v12);
              *(_BYTE *)(v10 + v12++) = v13;
            }
            while ( v12 != a3 );
            if ( v8 == v11 )
            {
              v8 = v10;
            }
            else if ( v8 == v10 )
            {
              v8 = v11;
            }
            v11 += a3;
            v10 -= a3;
            goto LABEL_18;
          }
          if ( v11 == v10 )
            break;
LABEL_18:
          if ( v11 > v10 )
          {
            v14 = v11;
            v15 = v10 - v41;
            a4 = v9;
            if ( v48 < v10 - v41 )
              goto LABEL_53;
            goto LABEL_20;
          }
        }
        v10 -= a3;
        v14 = a3 + v11;
        a4 = v9;
        v15 = v10 - v41;
        if ( v48 < v10 - v41 )
        {
LABEL_53:
          if ( v48 >= v43 - v14 )
          {
            v43 = v10;
          }
          else
          {
            if ( v15 <= (int)(v43 - v14) )
            {
              v37 = v43;
              v43 = v10;
              *(_DWORD *)v45 = v14;
              *((_DWORD *)v45 + 1) = v37;
            }
            else
            {
              v30 = v41;
              v41 = v14;
              *((_DWORD *)v45 + 1) = v10;
              *(_DWORD *)v45 = v30;
            }
            v45 += 8;
          }
          goto LABEL_22;
        }
LABEL_20:
        v41 = v14;
        if ( v48 >= v43 - v14 )
        {
          v41 = *((_DWORD *)v45 - 2);
          v43 = *((_DWORD *)v45 - 1);
          v45 -= 8;
        }
LABEL_22:
        if ( v45 <= (char *)v49 )
        {
          v7 = a5;
          goto LABEL_26;
        }
      }
    }
    v47 = a1 + a3 * (a2 - 1);
LABEL_26:
    v16 = v48 + a1;
    if ( v47 <= v48 + a1 )
      v16 = v47;
    v38 = v16;
    v40 = a3 + a1;
    if ( v16 >= a3 + a1 )
    {
      v17 = a1;
      v18 = a3 + a1;
      do
      {
        if ( a4(v18, v17, v7) < 0 )
          v17 = v18;
        v18 += a3;
      }
      while ( v38 >= v18 );
      if ( a1 != v17 )
      {
        v19 = 0;
        do
        {
          v20 = *(_BYTE *)(v17 + v19);
          *(_BYTE *)(v17 + v19) = *(_BYTE *)(a1 + v19);
          *(_BYTE *)(a1 + v19++) = v20;
        }
        while ( a3 != v19 );
      }
    }
    v44 = a4;
    v46 = v7;
    for ( i = v40 + 2 * a3; ; i += a3 )
    {
      result = a3;
      v40 += a3;
      if ( v40 > v47 )
        break;
      v21 = v40 - a3;
      for ( j = v44(v40, v40 - a3, v46); j < 0; j = v44(v40, v21, v46) )
        v21 -= a3;
      v23 = a3 + v21;
      if ( v23 != v40 )
      {
        v24 = (_BYTE *)i;
        v25 = (_BYTE *)(i - 1);
        if ( v40 <= i - 1 )
        {
          v26 = (_BYTE *)(v40 - 1);
          while ( 1 )
          {
            v27 = v26;
            v28 = v25;
            v39 = *(v24 - 1);
            v29 = v25;
            if ( v23 <= (unsigned int)v26 )
            {
              while ( 1 )
              {
                *v28 = *v27;
                if ( v23 > (unsigned int)&v27[-a3] )
                  break;
                v28 = v27;
                v27 -= a3;
              }
              v29 = v27;
            }
            --v26;
            *v29 = v39;
            if ( v40 > (unsigned int)(v25 - 1) )
              break;
            v24 = v25--;
          }
        }
      }
    }
  }
  return result;
}

//----- (0809C900) --------------------------------------------------------
int *__cdecl itowa(unsigned __int64 a1, int *a2, unsigned int a3, int a4)
{
  int *v4; // esi
  unsigned int v5; // edx
  unsigned int v6; // ebx
  char *v7; // ebp
  unsigned int v8; // ecx
  unsigned __int64 v9; // rtt
  unsigned int v10; // eax
  int v11; // edx
  int *v12; // ecx
  int j; // ebx
  int v14; // et2
  int *v15; // ecx
  int v16; // eax
  unsigned int v17; // eax
  int v18; // eax
  int v19; // edx
  int v21; // eax
  unsigned int i; // [esp+4h] [ebp-28h] BYREF
  char v23; // [esp+8h] [ebp-24h] BYREF
  int v24; // [esp+Ch] [ebp-20h]
  int v25; // [esp+10h] [ebp-1Ch]
  unsigned int v26; // [esp+14h] [ebp-18h]

  v4 = (int *)&itowa_upper_digits;
  v5 = HIDWORD(a1);
  v6 = a1;
  if ( !a4 )
    v4 = &itowa_lower_digits;
  if ( a3 == 8 )
  {
    v17 = a1;
    v12 = a2;
    if ( HIDWORD(a1) )
    {
      do
      {
        --v12;
        v18 = v4[v6 & 7];
        v6 >>= 3;
        *v12 = v18;
      }
      while ( v12 != a2 - 10 );
      v17 = HIDWORD(a1) >> 1;
      if ( HIDWORD(a1) >> 1 )
      {
        v12 = a2 - 11;
        *(a2 - 11) = v4[v6 | (4 * (BYTE4(a1) & 1))];
      }
      else
      {
        v17 = v6 | (4 * (BYTE4(a1) & 1));
      }
    }
    do
    {
      --v12;
      v19 = v4[v17 & 7];
      v17 >>= 3;
      *v12 = v19;
    }
    while ( v17 );
    return v12;
  }
  if ( a3 != 16 )
  {
    v7 = (char *)&unk_80C9508 + 12 * a3;
    if ( HIDWORD(a1) )
    {
      v8 = *((_DWORD *)v7 + 2);
      if ( HIDWORD(a1) < v8 )
      {
        v24 = a1 / v8;
        v10 = a1 % v8;
        v25 = v10;
        v11 = 2;
      }
      else
      {
        i = HIDWORD(a1) / v8;
        LODWORD(v9) = a1;
        HIDWORD(v9) = HIDWORD(a1) % v8;
        v26 = v9 % v8;
        LODWORD(v9) = v9 / v8;
        HIDWORD(v9) = HIDWORD(a1) / v8;
        v24 = v9 / v8;
        v10 = v26;
        v25 = v9 % v8;
        v11 = 3;
      }
    }
    else
    {
      v10 = a1;
      v11 = 1;
      v24 = a1;
    }
    v12 = a2;
    for ( i = (unsigned int)(&i + v11); ; i -= 4 )
    {
      for ( j = 0; v10; *v12 = v4[v14] )
      {
        --v12;
        v14 = v10 % a3;
        v10 /= a3;
        ++j;
      }
      if ( (char *)i == &v23 )
        break;
      for ( ; v7[5] > j; *v12 = 48 )
      {
        --v12;
        ++j;
      }
      v10 = *(_DWORD *)i;
    }
    return v12;
  }
  if ( HIDWORD(a1) )
  {
    v15 = a2;
    do
    {
      --v15;
      v16 = v4[v6 & 0xF];
      v6 >>= 4;
      *v15 = v16;
    }
    while ( v15 != a2 - 8 );
  }
  else
  {
    v15 = a2;
    v5 = a1;
  }
  do
  {
    --v15;
    v21 = v4[v5 & 0xF];
    v5 >>= 4;
    *v15 = v21;
  }
  while ( v5 );
  return v15;
}
// 80DC620: using guessed type int itowa_lower_digits;

//----- (0809CAF0) --------------------------------------------------------
void __usercall IO_vfscanf_internal(long double a1@<st0>, char *a2, unsigned __int8 *a3, int *a4, _DWORD *a5)
{
  char *v5; // ebx
  unsigned __int8 *v6; // edi
  int *v7; // eax
  int v8; // esi
  int v9; // eax
  int v10; // eax
  _BYTE *v11; // edx
  int v12; // ecx
  char *v13; // esi
  int v15; // esi
  unsigned __int8 v16; // dl
  unsigned __int8 *v17; // eax
  signed int i; // edi
  unsigned __int8 *v19; // eax
  int v20; // edi
  int v21; // eax
  int *v22; // edi
  unsigned int v23; // esi
  unsigned __int8 *v24; // edx
  int v25; // edx
  int v26; // eax
  int v27; // eax
  int v28; // edi
  char **v29; // edx
  unsigned __int8 *v30; // esi
  int v31; // eax
  unsigned __int8 v32; // dl
  int *v33; // eax
  unsigned __int8 v34; // di
  unsigned __int8 v35; // dl
  int v36; // ecx
  int v37; // edi
  int v38; // ecx
  unsigned __int8 v39; // dl
  unsigned int v40; // ecx
  unsigned __int8 *v41; // eax
  int v42; // eax
  int v43; // edi
  unsigned __int8 *j; // ecx
  int v45; // eax
  unsigned int v46; // ecx
  int v47; // edi
  _DWORD *v48; // edx
  unsigned int v50; // esi
  bool v51; // zf
  unsigned __int8 *v52; // ecx
  unsigned __int8 *v53; // eax
  unsigned __int8 *v54; // eax
  int *v55; // eax
  int v56; // ebx
  int *v57; // esi
  int *v58; // eax
  int *v59; // edx
  unsigned __int64 v60; // rax
  int *v61; // eax
  unsigned __int8 *v62; // eax
  int v63; // edi
  _DWORD *v64; // eax
  char *v65; // eax
  int v66; // eax
  unsigned __int8 *v67; // eax
  int v68; // eax
  char *v69; // eax
  int v70; // eax
  unsigned __int8 *v71; // eax
  int v72; // eax
  _DWORD *v73; // edx
  int v74; // ecx
  char *v75; // eax
  int v76; // eax
  int v77; // edx
  int v78; // edi
  unsigned __int8 *v79; // eax
  char *v80; // ecx
  char *v81; // eax
  int v82; // eax
  unsigned __int8 *v83; // eax
  _DWORD *v84; // edx
  char *v85; // eax
  int v86; // eax
  int v87; // edx
  int v88; // ecx
  _DWORD *v89; // edi
  int v90; // eax
  unsigned __int8 v91; // al
  unsigned __int8 *v92; // edx
  int *v93; // edi
  char **v94; // esi
  unsigned __int8 v95; // bl
  int v96; // eax
  signed int *v97; // eax
  signed int v98; // edx
  unsigned __int8 *v99; // eax
  unsigned __int8 *v100; // eax
  int v101; // eax
  unsigned int v102; // ebx
  char **v103; // edi
  unsigned __int8 *v104; // eax
  int v105; // edx
  int v106; // esi
  char *v107; // esi
  unsigned __int8 v108; // al
  char *v109; // esi
  char v110; // al
  unsigned __int8 *v111; // eax
  int v112; // eax
  unsigned int v113; // edx
  unsigned __int8 v114; // al
  int v115; // eax
  int v116; // edx
  unsigned __int8 *v117; // eax
  int v118; // edi
  unsigned __int8 v119; // al
  signed int v120; // edx
  signed int v121; // edi
  unsigned __int8 *v122; // eax
  unsigned int v123; // edi
  char **v124; // eax
  char **v125; // eax
  char **v126; // edx
  int *v127; // eax
  unsigned int v128; // esi
  unsigned int v129; // edi
  unsigned __int8 *v130; // eax
  int v131; // edi
  int v132; // eax
  int v133; // edi
  unsigned __int8 *v134; // eax
  int v135; // eax
  int v136; // edi
  unsigned __int8 *v137; // eax
  int v138; // eax
  unsigned __int8 *v139; // eax
  unsigned __int8 *v140; // eax
  int v141; // edi
  _BYTE *v142; // edx
  int v143; // eax
  int v144; // eax
  int v145; // eax
  _DWORD *v146; // edx
  int v147; // edx
  char *v148; // eax
  int v149; // eax
  int v150; // edx
  _DWORD *v151; // edi
  int *v152; // edx
  unsigned __int8 *v153; // eax
  signed int v154; // edi
  int v155; // edi
  int v156; // edx
  int *v157; // esi
  char *v158; // ebx
  char *v159; // eax
  int v160; // eax
  unsigned __int8 *v161; // eax
  int *v162; // edi
  _DWORD *v163; // edx
  char *v164; // eax
  int v165; // eax
  int *v166; // edx
  unsigned __int8 *v167; // eax
  int v168; // edi
  int *v169; // esi
  int v170; // ebx
  int v171; // eax
  _BYTE *v172; // eax
  unsigned __int8 *v173; // eax
  char *v174; // eax
  int v175; // eax
  _DWORD *v176; // edx
  char *v177; // eax
  int v178; // eax
  int v179; // edx
  int v180; // ecx
  _DWORD *v181; // edi
  int *v182; // edx
  unsigned __int8 *v183; // eax
  unsigned __int8 *v184; // eax
  _BYTE *v185; // eax
  unsigned __int8 *v186; // eax
  char *v187; // eax
  char *v188; // eax
  int v189; // ebx
  unsigned __int8 *v190; // eax
  int v191; // edx
  signed int v192; // esi
  bool v193; // cc
  _BYTE *v194; // esi
  int v195; // eax
  int v196; // edx
  int *v197; // edi
  int v198; // ebx
  unsigned __int8 *v199; // eax
  int v200; // ecx
  int *v201; // eax
  char *v202; // esi
  char v203; // al
  int v204; // esi
  unsigned int v205; // esi
  char **v206; // eax
  void *v207; // esp
  char **v208; // edx
  int *v209; // eax
  unsigned __int8 *v210; // edi
  unsigned __int8 *v211; // edx
  unsigned __int8 *v212; // eax
  int v213; // edi
  unsigned __int8 *v214; // eax
  _BYTE *v215; // eax
  int v216; // eax
  int *v217; // edx
  unsigned __int8 *v218; // eax
  _DWORD *v219; // edi
  _DWORD *v220; // edx
  char *v221; // edi
  _BYTE *v222; // eax
  unsigned __int8 *v223; // eax
  char *v224; // eax
  int v225; // eax
  char *v226; // eax
  char *v227; // eax
  int v228; // eax
  int v229; // eax
  unsigned __int8 *v230; // eax
  char *v231; // edx
  char *v232; // edi
  _BYTE *v233; // eax
  int v234; // esi
  unsigned __int8 *v235; // eax
  char **v236; // eax
  int *v237; // edx
  char *v238; // eax
  int v239; // eax
  int v240; // edx
  int *v241; // eax
  _BYTE *v242; // eax
  int v243; // esi
  unsigned __int8 *v244; // eax
  signed int v245; // edi
  signed int v246; // edi
  unsigned __int8 *v247; // eax
  int *v248; // eax
  int *v249; // eax
  signed int *v250; // eax
  void *v251; // esp
  char **v252; // eax
  _WORD *v253; // eax
  int *v254; // edx
  int *v255; // eax
  int *v256; // eax
  int v257; // edi
  int v258; // eax
  char *v259; // eax
  char **v260; // eax
  char **v261; // eax
  int v262; // eax
  int v263; // edx
  int *v264; // eax
  int *v265; // eax
  int v266; // ecx
  int v267; // eax
  unsigned int v268; // ecx
  int *v269; // eax
  char **v270; // eax
  int v271; // eax
  int v272; // eax
  int v273; // eax
  int v274; // eax
  int *v275; // eax
  int *v276; // eax
  _DWORD *v277; // edi
  int v278; // eax
  int *v279; // eax
  int v280; // eax
  int v281; // edx
  int v282; // ecx
  _DWORD *v283; // esi
  int *v284; // eax
  int *v285; // eax
  int v286; // eax
  unsigned int v287; // edi
  char **v288; // eax
  void *v289; // esp
  char **v290; // edx
  int *v291; // eax
  _DWORD *v292; // eax
  int v293; // eax
  _BOOL4 v294; // eax
  char **v295; // eax
  int *v296; // eax
  int *v297; // eax
  _BYTE *v298; // eax
  int *v299; // eax
  int *v300; // eax
  char **v301; // eax
  char **v302; // eax
  int v303; // eax
  unsigned int v304; // edx
  char **v305; // eax
  unsigned int v306; // edx
  void *v307; // esp
  int v308; // eax
  _BOOL4 v309; // eax
  char *v310; // eax
  unsigned int v311; // edx
  char **v312; // eax
  unsigned int v313; // edx
  void *v314; // esp
  int v315; // eax
  _BOOL4 v316; // eax
  _BYTE *v317; // eax
  char *v318; // eax
  signed int v319; // ecx
  signed int v320; // edi
  int *v321; // ebx
  int v322; // edx
  char *v323; // edi
  int v324; // eax
  int v325; // edi
  int *v326; // esi
  int v327; // ebx
  unsigned __int8 v328; // al
  int *v329; // esi
  int v330; // edx
  unsigned __int8 *v331; // eax
  unsigned int v332; // edx
  unsigned int v333; // ecx
  char *v334; // eax
  int v335; // esi
  int v336; // eax
  int v337; // eax
  int v338; // edx
  unsigned __int8 *v339; // ecx
  unsigned __int8 v340; // al
  _BYTE *v341; // edi
  unsigned __int8 *v342; // eax
  _BYTE *v343; // esi
  _BYTE *v344; // edx
  int v345; // eax
  int v346; // edi
  int v347; // ecx
  unsigned __int8 v348; // al
  char **v349; // edi
  signed int v350; // ecx
  unsigned int v351; // esi
  _DWORD *v352; // esi
  unsigned __int8 *v353; // eax
  int v354; // edx
  unsigned int v355; // esi
  char **v356; // eax
  unsigned int v357; // ecx
  unsigned int v358; // edx
  void *v359; // esp
  _BYTE *v360; // edx
  int v361; // edx
  signed int v362; // ecx
  unsigned __int8 *v363; // eax
  unsigned int v364; // edx
  char **v365; // eax
  unsigned int v366; // edx
  void *v367; // esp
  char **v368; // eax
  unsigned int v369; // edi
  int v370; // edx
  unsigned int v371; // eax
  signed int v372; // esi
  int v373; // eax
  _BOOL4 v374; // eax
  char **v375; // eax
  char **v376; // eax
  char **v377; // eax
  char **v378; // eax
  int v379; // eax
  int v380; // esi
  char *v381; // esi
  unsigned int k; // edi
  char *v383; // eax
  _BYTE *v384; // ebx
  unsigned int v385; // eax
  int v386; // edx
  _BYTE *v387; // ecx
  int v388; // eax
  void *v389; // esp
  _WORD *v390; // eax
  unsigned int v391; // eax
  _DWORD *v392; // esi
  int v393; // eax
  char **v394; // eax
  int v395; // eax
  int v396; // eax
  int *v397; // eax
  char **v398; // eax
  int v399; // eax
  int v400; // eax
  char **v401; // eax
  int v402; // eax
  int v403; // edx
  int v404; // eax
  int v405; // eax
  int v406; // eax
  int *v407; // eax
  int v408; // eax
  char **v409; // eax
  int v410; // eax
  int v411; // eax
  unsigned __int8 *v412; // eax
  int v413; // esi
  unsigned __int8 *v414; // eax
  int v415; // esi
  unsigned __int8 *v416; // eax
  int v417; // esi
  unsigned __int8 *v418; // eax
  char **v419; // eax
  int v420; // edx
  char **v421; // eax
  int v422; // edx
  char **v423; // eax
  _BOOL4 v424; // eax
  unsigned __int8 *v425; // eax
  unsigned int v426; // eax
  int v427; // eax
  int v428; // edx
  _BOOL4 v429; // eax
  int v430; // edi
  unsigned int v431; // eax
  int v432; // eax
  char **v433; // edi
  unsigned int v434; // ebx
  unsigned __int8 *v435; // esi
  int v436; // eax
  unsigned __int8 v437; // dl
  int v438; // ebx
  unsigned __int8 *v439; // edi
  unsigned __int8 *v440; // edx
  int v441; // edx
  unsigned __int8 *v442; // eax
  unsigned __int8 *v443; // ebx
  int v444; // eax
  unsigned int v445; // eax
  unsigned int v446; // eax
  unsigned int v447; // edx
  char **v448; // eax
  unsigned int v449; // edx
  void *v450; // esp
  unsigned int v451; // esi
  char **v452; // eax
  void *v453; // esp
  char **v454; // edx
  int v455; // eax
  int v456; // edx
  _BOOL4 v457; // eax
  char *v458; // eax
  int v459; // eax
  _BOOL4 v460; // eax
  char **v461; // eax
  int *v462; // eax
  int v463; // eax
  int v464; // eax
  int v465; // ecx
  int *v466; // ebx
  unsigned int v467; // esi
  _DWORD *v468; // eax
  int v469; // eax
  int v470; // eax
  unsigned int v471; // edx
  char **v472; // eax
  unsigned int v473; // edx
  void *v474; // esp
  _BOOL4 v475; // eax
  _BYTE *v476; // eax
  int *v477; // eax
  char **v478; // eax
  char **v479; // eax
  char **v480; // eax
  _BOOL4 v481; // eax
  char **v482; // eax
  char **v483; // eax
  char **v484; // eax
  _BOOL4 v485; // eax
  char **v486; // eax
  unsigned __int8 *v487; // eax
  int v488; // eax
  char **v489; // edx
  int v490; // esi
  unsigned __int8 *v491; // eax
  char **v492; // edx
  int v493; // ecx
  char **v494; // edx
  int v495; // esi
  char **v496; // eax
  unsigned int v497; // esi
  unsigned int v498; // edx
  void *v499; // esp
  unsigned int v500; // esi
  char **v501; // eax
  unsigned int v502; // edx
  void *v503; // esp
  char **v504; // eax
  char **v505; // eax
  unsigned int v506; // esi
  char **v507; // eax
  unsigned int v508; // edx
  void *v509; // esp
  char v510; // al
  char **v511; // esi
  int v512; // ecx
  char v513; // al
  _BYTE *v514; // edi
  unsigned int v515; // edi
  char **v516; // eax
  unsigned int v517; // ecx
  void *v518; // esp
  char **v519; // eax
  char **v520; // eax
  int v521; // ecx
  char v522; // al
  _BYTE *v523; // edi
  unsigned int v524; // edi
  char **v525; // eax
  unsigned int v526; // ecx
  void *v527; // esp
  char **v528; // eax
  unsigned int v529; // esi
  char **v530; // eax
  void *v531; // esp
  char **v532; // edx
  _DWORD *v533; // ebx
  int v534; // eax
  _BOOL4 v535; // eax
  char **v536; // eax
  int v537; // eax
  char **v538; // eax
  char **v539; // eax
  char **v540; // eax
  char *v541; // [esp-100h] [ebp-338h] BYREF
  __int16 v542; // [esp-FCh] [ebp-334h]
  char v543; // [esp-FAh] [ebp-332h]
  int v544; // [esp-90h] [ebp-2C8h] BYREF
  int v545; // [esp-8Ch] [ebp-2C4h]
  char *v546; // [esp+0h] [ebp-238h] BYREF
  unsigned int *v547; // [esp+4h] [ebp-234h]
  int v548; // [esp+8h] [ebp-230h]
  int v549; // [esp+Ch] [ebp-22Ch]
  _BYTE v550[16]; // [esp+10h] [ebp-228h] BYREF
  char **v551; // [esp+20h] [ebp-218h]
  signed int v552; // [esp+24h] [ebp-214h]
  char **v553; // [esp+28h] [ebp-210h]
  char *v554; // [esp+2Ch] [ebp-20Ch]
  int v555; // [esp+30h] [ebp-208h]
  int v556; // [esp+34h] [ebp-204h]
  int v557; // [esp+38h] [ebp-200h]
  int v558; // [esp+3Ch] [ebp-1FCh]
  int v559; // [esp+40h] [ebp-1F8h]
  unsigned int v560; // [esp+44h] [ebp-1F4h]
  unsigned int v561; // [esp+48h] [ebp-1F0h]
  unsigned int v562; // [esp+4Ch] [ebp-1ECh]
  char *v563; // [esp+50h] [ebp-1E8h]
  int *v564; // [esp+54h] [ebp-1E4h]
  char *s1; // [esp+58h] [ebp-1E0h]
  char *v566; // [esp+5Ch] [ebp-1DCh]
  int v567; // [esp+60h] [ebp-1D8h]
  int *v568; // [esp+64h] [ebp-1D4h]
  char v569; // [esp+6Bh] [ebp-1CDh]
  _DWORD *v570; // [esp+6Ch] [ebp-1CCh]
  unsigned int v571; // [esp+70h] [ebp-1C8h]
  int v572; // [esp+74h] [ebp-1C4h]
  int v573; // [esp+78h] [ebp-1C0h]
  int *v574; // [esp+7Ch] [ebp-1BCh]
  int v575; // [esp+80h] [ebp-1B8h]
  unsigned __int8 *v576; // [esp+84h] [ebp-1B4h]
  int v577; // [esp+88h] [ebp-1B0h]
  unsigned int v578; // [esp+8Ch] [ebp-1ACh]
  _BYTE *v579; // [esp+90h] [ebp-1A8h]
  char *v580; // [esp+94h] [ebp-1A4h]
  unsigned int v581; // [esp+98h] [ebp-1A0h]
  char **v582; // [esp+9Ch] [ebp-19Ch]
  int v583; // [esp+A0h] [ebp-198h]
  int v584; // [esp+A4h] [ebp-194h]
  int v585; // [esp+A8h] [ebp-190h]
  signed int v586; // [esp+ACh] [ebp-18Ch]
  char v587[170]; // [esp+B0h] [ebp-188h] BYREF
  char v588[17]; // [esp+15Ah] [ebp-DEh] BYREF
  char s2[57]; // [esp+16Bh] [ebp-CDh] BYREF
  unsigned int v590; // [esp+1A4h] [ebp-94h]
  unsigned int v591; // [esp+1A8h] [ebp-90h]
  int v592[10]; // [esp+1ACh] [ebp-8Ch] BYREF
  int v593[4]; // [esp+1D4h] [ebp-64h] BYREF
  int v594[4]; // [esp+1E4h] [ebp-54h] BYREF
  int v595[2]; // [esp+1F4h] [ebp-44h] BYREF
  int v596[2]; // [esp+1FCh] [ebp-3Ch] BYREF
  int v597[2]; // [esp+204h] [ebp-34h] BYREF
  int v598; // [esp+20Ch] [ebp-2Ch] BYREF
  int v599; // [esp+210h] [ebp-28h]
  int v600[2]; // [esp+214h] [ebp-24h] BYREF
  unsigned int v601[7]; // [esp+21Ch] [ebp-1Ch] BYREF

  v5 = a2;
  v6 = a3;
  v7 = (int *)__readgsdword(0xFFFFFFD8);
  v8 = *v7;
  v574 = v7;
  v9 = *((_DWORD *)a2 + 26);
  v558 = v8;
  v568 = a4;
  if ( v9 )
  {
    if ( v9 != -1 )
    {
      v573 = -1;
      return;
    }
  }
  else
  {
    *((_DWORD *)a2 + 26) = -1;
  }
  v10 = *(_DWORD *)a2;
  v11 = (_BYTE *)(*(_DWORD *)a2 & 4);
  if ( v11 )
  {
    v573 = -1;
    __writegsdword(0xFFFFFFE8, 9u);
    return;
  }
  if ( !a3 )
  {
    v573 = -1;
    __writegsdword(0xFFFFFFE8, 0x16u);
    return;
  }
  v12 = v574[1];
  v13 = *(char **)(v12 + 36);
  _ECX = *(_DWORD *)(v12 + 40);
  s1 = v13;
  if ( *(_BYTE *)_ECX )
    v11 = (_BYTE *)_ECX;
  v579 = v11;
  v559 = 0;
  v593[0] = (int)funlockfile;
  v593[1] = (int)a2;
  if ( (v10 & 0x8000) == 0 )
  {
    _EDX = *((_DWORD *)a2 + 18);
    v50 = __readgsdword(8u);
    if ( v50 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v51 = __readgsdword(0xCu) == 0;
      if ( !v51 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v51 )
      {
        L_lock_1267(0, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = *((_DWORD *)a2 + 18);
      *(_DWORD *)(_EDX + 8) = v50;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v595[0] = 0;
  v15 = 0;
  v595[1] = 0;
  v16 = *a3;
  v569 = 0;
  v581 = 0;
  v582 = 0;
  v584 = 0;
  v567 = 0;
  v570 = 0;
  v580 = 0;
  v566 = 0;
  v564 = 0;
  v578 = 0;
  v586 = 0;
  v573 = 0;
  if ( !v16 )
    goto LABEL_24;
LABEL_9:
  if ( (v16 & 0x80u) != 0 )
  {
    v26 = strlen(v6);
    v27 = mbrlen(v6, v26, v595);
    if ( v27 > 0 )
    {
      if ( v15 != -1 )
      {
        v576 = v6;
        _ECX = v586;
        v28 = v27;
        v29 = (char **)v576;
        while ( 1 )
        {
          v30 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
          if ( (unsigned int)v30 >= *((_DWORD *)v5 + 2) )
          {
            v553 = v29;
            v554 = (char *)_ECX;
            v31 = _uflow((int *)v5);
            v29 = v553;
            _ECX = (int)v554;
            if ( v31 == -1 )
              goto LABEL_84;
          }
          else
          {
            v31 = *v30;
            *((_DWORD *)v5 + 1) = v30 + 1;
          }
          v15 = *(unsigned __int8 *)v29;
          if ( v15 != v31 )
          {
            v20 = 2;
            IO_sputbackc(v5, (unsigned __int8)v31);
            goto LABEL_34;
          }
          ++_ECX;
          v29 = (char **)((char *)v29 + 1);
          if ( !--v28 )
          {
            v586 = _ECX;
            v576 = (unsigned __int8 *)v29;
            goto LABEL_23;
          }
        }
      }
      __writegsdword(0xFFFFFFE8, v578);
LABEL_84:
      v20 = 1;
      if ( v573 )
        goto LABEL_34;
      v42 = *(_DWORD *)v5;
      v573 = -1;
      if ( (v42 & 0x8000) != 0 )
        goto LABEL_35;
      goto LABEL_112;
    }
    v16 = *v6;
  }
  v576 = v6 + 1;
  if ( v16 != 37 )
  {
    _ECX = v574[13];
    if ( (*(_BYTE *)(_ECX + 2 * v16 + 1) & 0x20) != 0 )
    {
      v584 = 1;
      goto LABEL_23;
    }
    if ( v15 == -1 )
    {
      __writegsdword(0xFFFFFFE8, v578);
    }
    else
    {
      v17 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
      if ( (unsigned int)v17 < *((_DWORD *)v5 + 2) )
      {
        v15 = *v17;
        *((_DWORD *)v5 + 1) = v17 + 1;
        goto LABEL_15;
      }
      LOBYTE(v553) = v16;
      v315 = _uflow((int *)v5);
      v16 = (unsigned __int8)v553;
      v15 = v315;
      if ( v315 != -1 )
      {
LABEL_15:
        ++v586;
        if ( v584 )
        {
          _ECX = v574[13];
          for ( i = v586; (*(_BYTE *)(_ECX + 2 * v15 + 1) & 0x20) != 0; ++i )
          {
            v19 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
            if ( (unsigned int)v19 >= *((_DWORD *)v5 + 2) )
            {
              LOBYTE(v553) = v16;
              v293 = _uflow((int *)v5);
              v16 = (unsigned __int8)v553;
              v15 = v293;
              if ( v293 == -1 )
              {
                _ECX = v573;
                v20 = 1;
                if ( !v573 )
                  v573 = -1;
                goto LABEL_34;
              }
              _ECX = v574[13];
            }
            else
            {
              v15 = *v19;
              *((_DWORD *)v5 + 1) = v19 + 1;
            }
          }
          v586 = i;
        }
        if ( v15 == v16 )
        {
          v584 = 0;
          goto LABEL_23;
        }
        goto LABEL_571;
      }
    }
    v20 = 1;
    if ( !v573 )
      v573 = -1;
    goto LABEL_34;
  }
  v32 = v6[1];
  v572 = 0;
  if ( (unsigned int)v32 - 48 <= 9 )
  {
    v572 = v32 - 48;
    v33 = (int *)(v6 + 2);
    v34 = v6[2];
    v35 = v34;
    v585 = v34;
    if ( (unsigned int)v34 - 48 <= 9 )
    {
      v36 = v572;
      v585 = v15;
      do
      {
        v33 = (int *)((char *)v33 + 1);
        v36 = v35 + 10 * v36 - 48;
        v35 = *(_BYTE *)v33;
        v34 = *(_BYTE *)v33;
      }
      while ( (unsigned int)*(unsigned __int8 *)v33 - 48 <= 9 );
      v15 = v585;
      v572 = v36;
    }
    if ( v34 != 36 )
    {
      v37 = v572;
      v32 = *(_BYTE *)v33;
      v572 = 0;
      v575 = 0;
      v583 = v37;
      goto LABEL_59;
    }
    v32 = *((_BYTE *)v33 + 1);
    v576 = (unsigned __int8 *)v33 + 1;
  }
  v43 = 0;
  v575 = 0;
  for ( j = v576 + 1; ; ++j )
  {
    v33 = (int *)(j - 1);
    if ( v32 != 39 && v32 != 42 )
      break;
    if ( v32 == 42 )
    {
      v43 |= 8u;
    }
    else
    {
      v45 = v43;
      if ( v579 )
      {
        LOBYTE(v45) = v43 | 0x80;
        v43 = v45;
      }
    }
LABEL_92:
    v32 = *j;
  }
  if ( v32 == 73 )
  {
    v43 |= 0x400u;
    goto LABEL_92;
  }
  v46 = v32 - 48;
  v575 = v43;
  v583 = -1;
  if ( v46 <= 9 )
  {
    v583 = 0;
    v47 = 0;
    do
    {
      v33 = (int *)((char *)v33 + 1);
      v47 = v46 + 10 * v47;
      v32 = *(_BYTE *)v33;
      v46 = *(unsigned __int8 *)v33 - 48;
    }
    while ( v46 <= 9 );
    v583 = v47;
LABEL_59:
    v38 = -1;
    if ( v583 )
      v38 = v583;
    v583 = v38;
  }
  v585 = (int)v33 + 1;
  LOBYTE(_ECX) = v32 - 76;
  _ECX = (unsigned __int8)_ECX;
  switch ( v32 )
  {
    case 'L':
    case 'q':
      v575 |= 3u;
      goto LABEL_105;
    case 'a':
      _ECX = *((unsigned __int8 *)v33 + 1);
      if ( (_BYTE)_ECX == 83 || (_BYTE)_ECX == 115 || (_BYTE)_ECX == 91 )
      {
        if ( (v5[60] & 0x10) != 0 )
        {
          v585 = (int)v33;
        }
        else
        {
          v575 |= 0x100u;
          v32 = _ECX;
LABEL_64:
          if ( !v32 )
          {
            v20 = 2;
            goto LABEL_34;
          }
        }
        v576 = (unsigned __int8 *)(v585 + 1);
      }
      else
      {
        v52 = (unsigned __int8 *)v585;
        v585 = (int)v33;
        v576 = v52;
      }
      _ECX = v584;
      if ( !v584 && (v32 == 99 || v32 == 91 || v32 == 110 || v32 == 67) )
        goto LABEL_69;
      v40 = __readgsdword(0xFFFFFFE8);
      __writegsdword(0xFFFFFFE8, 0);
      v584 = v40;
      _ECX = (int)v574;
      break;
    case 'h':
      v32 = *((_BYTE *)v33 + 1);
      if ( v32 == 104 )
      {
        v32 = *((_BYTE *)v33 + 2);
        v585 = (int)v33 + 2;
        v575 |= 0x200u;
      }
      else
      {
        v575 |= 4u;
      }
      goto LABEL_64;
    case 'j':
      v575 |= 2u;
      v32 = *((_BYTE *)v33 + 1);
      goto LABEL_64;
    case 'l':
      v32 = *((_BYTE *)v33 + 1);
      if ( v32 == 108 )
      {
        v585 = (int)v33 + 2;
        v32 = *((_BYTE *)v33 + 2);
        v575 |= 3u;
      }
      else
      {
        v575 |= 1u;
      }
      goto LABEL_64;
    case 'm':
      v32 = *((_BYTE *)v33 + 1);
      v575 |= 0x2000u;
      if ( v32 == 108 )
      {
        _ECX = (int)v33 + 2;
        v32 = *((_BYTE *)v33 + 2);
        v585 = (int)v33 + 2;
        v575 |= 1u;
      }
      goto LABEL_64;
    case 't':
    case 'z':
LABEL_105:
      v32 = *((_BYTE *)v33 + 1);
      goto LABEL_64;
    default:
      v585 = (int)v33;
      goto LABEL_64;
  }
  while ( 2 )
  {
    if ( v15 == -1 )
    {
      v391 = __readgsdword(0xFFFFFFE8);
      goto LABEL_1153;
    }
    v41 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
    if ( (unsigned int)v41 < *((_DWORD *)v5 + 2) )
    {
      v15 = *v41;
      *((_DWORD *)v5 + 1) = v41 + 1;
      goto LABEL_78;
    }
    LOBYTE(v553) = v32;
    v554 = (char *)_ECX;
    v393 = _uflow((int *)v5);
    v32 = (unsigned __int8)v553;
    _ECX = (int)v554;
    v15 = v393;
    if ( v393 != -1 )
    {
LABEL_78:
      ++v586;
      goto LABEL_79;
    }
    v578 = __readgsdword(0xFFFFFFE8);
    v391 = v578;
LABEL_1153:
    if ( v391 != 4 )
    {
      v15 = -1;
LABEL_79:
      if ( (*(_BYTE *)(*(_DWORD *)(_ECX + 52) + 2 * v15 + 1) & 0x20) != 0 )
        continue;
      _ECX = v584;
      __writegsdword(0xFFFFFFE8, v584);
      if ( v15 == -1 )
      {
LABEL_69:
        v39 = v32 - 37;
        if ( v39 > 0x53u )
        {
LABEL_70:
          v20 = 2;
          if ( (BYTE1(*(_DWORD *)v5) & 0x80u) != 0 )
            goto LABEL_35;
          goto LABEL_112;
        }
      }
      else
      {
        --v586;
        LOBYTE(v553) = v32;
        IO_sputbackc(v5, (unsigned __int8)v15);
        v39 = (_BYTE)v553 - 37;
      }
      switch ( v39 )
      {
        case 0u:
          if ( v15 == -1 )
          {
            __writegsdword(0xFFFFFFE8, v578);
          }
          else
          {
            v111 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
            if ( (unsigned int)v111 < *((_DWORD *)v5 + 2) )
            {
              v15 = *v111;
              *((_DWORD *)v5 + 1) = v111 + 1;
              goto LABEL_319;
            }
            v15 = _uflow((int *)v5);
            if ( v15 != -1 )
            {
LABEL_319:
              if ( v15 == 37 )
              {
                ++v586;
                v584 = 0;
                goto LABEL_23;
              }
              goto LABEL_571;
            }
          }
          v20 = 1;
          if ( !v573 )
            v573 = -1;
          goto LABEL_34;
        case 0x1Cu:
        case 0x20u:
        case 0x21u:
        case 0x22u:
        case 0x3Cu:
        case 0x40u:
        case 0x41u:
        case 0x42u:
          if ( v15 == -1 )
          {
            __writegsdword(0xFFFFFFE8, v578);
          }
          else
          {
            v99 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
            if ( (unsigned int)v99 < *((_DWORD *)v5 + 2) )
            {
              v15 = *v99;
              *((_DWORD *)v5 + 1) = v99 + 1;
LABEL_281:
              ++v586;
              goto LABEL_282;
            }
            v15 = _uflow((int *)v5);
            if ( v15 != -1 )
              goto LABEL_281;
            v578 = __readgsdword(0xFFFFFFE8);
          }
LABEL_282:
          v583 -= v583 > 0;
          if ( v15 == -1 )
          {
            v20 = 1;
            if ( !v573 )
              v573 = -1;
            goto LABEL_34;
          }
          if ( v15 == 43 || (LOBYTE(v557) = 0, v15 == 45) )
          {
            _ECX = v583;
            LOBYTE(v557) = v15 == 45;
            if ( !v583 )
            {
              v20 = 2;
              goto LABEL_34;
            }
            v100 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
            if ( (unsigned int)v100 >= *((_DWORD *)v5 + 2) )
            {
              v15 = _uflow((int *)v5);
              if ( v15 == -1 )
              {
                v20 = 2;
                goto LABEL_34;
              }
            }
            else
            {
              v15 = *v100;
              *((_DWORD *)v5 + 1) = v100 + 1;
            }
            ++v586;
            v583 -= v583 > 0;
          }
          _ECX = (int)v574;
          v101 = *(_DWORD *)(v574[14] + 4 * (unsigned __int8)v15);
          if ( v101 != 110 )
          {
            if ( v101 != 105 )
            {
              if ( v15 != 48 || !v583 )
              {
                v584 = 0;
                LOBYTE(v562) = 101;
                goto LABEL_294;
              }
              if ( !v581 )
              {
                if ( v569 )
                {
                  realloc(v582, 0x100u);
                  if ( !v409 )
                    goto LABEL_1198;
                  v582 = v409;
                  v581 = 256;
                }
                else
                {
                  v582 = &v541;
                  v581 = 256;
                }
              }
              *(_BYTE *)v582 = 48;
              v183 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
              if ( (unsigned int)v183 >= *((_DWORD *)v5 + 2) )
              {
                v15 = _uflow((int *)v5);
                if ( v15 == -1 )
                {
                  v578 = __readgsdword(0xFFFFFFE8);
                  goto LABEL_491;
                }
              }
              else
              {
                v15 = *v183;
                *((_DWORD *)v5 + 1) = v183 + 1;
              }
              ++v586;
LABEL_491:
              v584 = 1;
              LOBYTE(v562) = 101;
              v583 -= v583 > 0;
              if ( !v583 || *(_DWORD *)(v574[14] + 4 * (unsigned __int8)v15) != 120 )
              {
LABEL_294:
                v585 = v15;
                LOBYTE(v561) = 0;
                v556 = v575 & 0x80;
                _ECX = (int)v5;
                v102 = v584;
                v560 = v575 & 0x800;
                v103 = v582;
                LOBYTE(v571) = 0;
                if ( (unsigned int)(v15 - 48) <= 9 )
                {
LABEL_295:
                  if ( v581 != v102 )
                    goto LABEL_296;
                  v205 = 2 * v102;
                  if ( 2 * v102 < 0x100 )
                    v205 = 256;
                  v484 = v103;
                  if ( !v569 )
                  {
                    if ( v205 <= 0x1000 )
                      goto LABEL_560;
                    v554 = (char *)_ECX;
                    v485 = _libc_alloca_cutoff(v205);
                    _ECX = (int)v554;
                    if ( v485 )
                      goto LABEL_560;
                    v484 = 0;
                  }
                  v554 = (char *)_ECX;
                  realloc(v484, v205);
                  _ECX = (int)v554;
                  v208 = v486;
                  if ( !v486 )
                  {
                    v5 = v554;
                    v582 = v103;
                    if ( v569 )
                    {
                      v546 = (char *)v103;
                      v20 = 0;
                      free(v546);
                      v582 = 0;
                    }
                    else
                    {
                      v582 = 0;
                      v20 = 0;
                    }
                    v573 = -1;
                    goto LABEL_34;
                  }
                  goto LABEL_1448;
                }
LABEL_302:
                if ( (_BYTE)v561 )
                {
                  if ( *((_BYTE *)v103 + v102 - 1) == (_BYTE)v562 && (v585 == 43 || v585 == 45) )
                  {
                    if ( v581 != v102 )
                    {
LABEL_583:
                      LOBYTE(v561) = 1;
                      *((_BYTE *)v103 + v102++) = v585;
                      goto LABEL_297;
                    }
                    v451 = 2 * v102;
                    if ( 2 * v102 < 0x100 )
                      v451 = 256;
                    v452 = v103;
                    if ( !v569 )
                    {
                      if ( v451 <= 0x1000
                        || (v554 = (char *)_ECX, v460 = _libc_alloca_cutoff(v451), _ECX = (int)v554, v460) )
                      {
                        v451 = (v451 + 15) & 0xFFFFFFF0;
                        v453 = alloca(v451 + 16);
                        v454 = (char **)v550;
                        v577 = (int)&v550[v451];
                        if ( v103 == (char **)&v550[v451] )
                          v451 += v581;
                        if ( v103 )
                        {
                          v553 = (char **)v550;
                          v554 = (char *)_ECX;
                          memcpy(v550, v103, v581);
                          v581 = v451;
                          _ECX = (int)v554;
                          v103 = v553;
                          goto LABEL_583;
                        }
LABEL_1347:
                        v581 = v451;
                        v103 = v454;
                        goto LABEL_583;
                      }
                      v452 = 0;
                    }
                    v554 = (char *)_ECX;
                    realloc(v452, v451);
                    _ECX = (int)v554;
                    v454 = v461;
                    if ( !v461 )
                    {
                      v5 = v554;
                      v582 = v103;
                      if ( v569 )
                      {
                        v546 = (char *)v103;
                        v20 = 0;
                        free(v546);
                        v582 = 0;
                      }
                      else
                      {
                        v582 = 0;
                        v20 = 0;
                      }
                      v573 = -1;
                      goto LABEL_34;
                    }
                    if ( !v569 )
                    {
                      v553 = v461;
                      memcpy(v461, v103, v102);
                      v581 = v451;
                      _ECX = (int)v554;
                      v569 = 1;
                      v103 = v553;
                      goto LABEL_583;
                    }
                    goto LABEL_1347;
                  }
                  goto LABEL_304;
                }
                if ( v560 && (*(_BYTE *)(v574[13] + 2 * v585 + 1) & 0x10) != 0 )
                {
                  if ( v581 != v102 )
                    goto LABEL_296;
                  v205 = 2 * v102;
                  if ( 2 * v102 < 0x100 )
                    v205 = 256;
                  v206 = v103;
                  if ( v569 )
                    goto LABEL_1447;
                  if ( v205 > 0x1000 )
                  {
                    v554 = (char *)_ECX;
                    v481 = _libc_alloca_cutoff(v205);
                    _ECX = (int)v554;
                    if ( !v481 )
                    {
                      v206 = 0;
LABEL_1447:
                      v554 = (char *)_ECX;
                      realloc(v206, v205);
                      _ECX = (int)v554;
                      v208 = v482;
                      if ( !v482 )
                      {
                        v5 = v554;
                        v582 = v103;
                        if ( v569 )
                        {
                          v546 = (char *)v103;
                          v20 = 0;
                          free(v546);
                          v582 = 0;
                        }
                        else
                        {
                          v582 = 0;
                          v20 = 0;
                        }
                        v573 = -1;
                        goto LABEL_34;
                      }
LABEL_1448:
                      if ( !v569 )
                      {
                        v553 = v208;
                        v554 = (char *)_ECX;
                        memcpy(v208, v103, v102);
                        v581 = v205;
                        _ECX = (int)v554;
                        v569 = 1;
                        v103 = v553;
                        goto LABEL_296;
                      }
LABEL_1443:
                      v581 = v205;
                      v103 = v208;
LABEL_296:
                      *((_BYTE *)v103 + v102++) = v585;
                      goto LABEL_297;
                    }
                  }
LABEL_560:
                  v205 = (v205 + 15) & 0xFFFFFFF0;
                  v207 = alloca(v205 + 16);
                  v208 = (char **)v550;
                  v577 = (int)&v550[v205];
                  if ( v103 == (char **)&v550[v205] )
                    v205 += v581;
                  if ( !v103 )
                    goto LABEL_1443;
                  v553 = (char **)v550;
                  v554 = (char *)_ECX;
                  memcpy(v550, v103, v581);
                  v581 = v205;
                  _ECX = (int)v554;
                  v103 = v553;
                  goto LABEL_296;
                }
                if ( !v102 || (_BYTE)v562 != *(_BYTE *)(v574[14] + 4 * (unsigned __int8)v585) )
                {
LABEL_304:
                  v106 = 0x7FFFFFFF;
                  if ( v583 > 0 )
                    v106 = v583;
                  v584 = v106;
                  v107 = s1;
                  v108 = *s1;
                  if ( !(_BYTE)v571 && v585 == v108 )
                  {
                    v107 = s1 + 1;
                    if ( !s1[1] )
                      goto LABEL_308;
                    v563 = (char *)v102;
                    v189 = v584;
                    v577 = (int)v103;
                    while ( 1 )
                    {
                      v190 = *(unsigned __int8 **)(_ECX + 4);
                      if ( (unsigned int)v190 >= *(_DWORD *)(_ECX + 8) )
                      {
                        v554 = (char *)_ECX;
                        v537 = _uflow((int *)_ECX);
                        _ECX = (int)v554;
                        v191 = v537;
                        if ( v537 == -1 )
                        {
                          v585 = -1;
                          v584 = v189;
                          v103 = (char **)v577;
                          v102 = (unsigned int)v563;
                          v578 = __readgsdword(0xFFFFFFE8);
                          v108 = *v107;
                          break;
                        }
                      }
                      else
                      {
                        v191 = *v190;
                        *(_DWORD *)(_ECX + 4) = v190 + 1;
                      }
                      v108 = *v107;
                      --v189;
                      ++v586;
                      if ( v108 != v191 )
                      {
                        v584 = v189;
                        v103 = (char **)v577;
                        v585 = v191;
                        v102 = (unsigned int)v563;
                        break;
                      }
                      if ( !*++v107 )
                      {
                        v584 = v189;
                        v103 = (char **)v577;
                        v585 = v191;
                        v102 = (unsigned int)v563;
LABEL_308:
                        v109 = s1;
                        if ( !*s1 )
                        {
LABEL_313:
                          if ( v583 > 0 )
                            v583 = v584;
                          LOBYTE(v571) = 1;
                          goto LABEL_297;
                        }
                        v571 = _ECX;
                        v552 = v581;
                        while ( 2 )
                        {
                          if ( v552 != v102 )
                          {
LABEL_311:
                            v110 = *v109++;
                            *((_BYTE *)v103 + v102++) = v110;
                            if ( !*v109 )
                            {
                              v581 = v552;
                              _ECX = v571;
                              goto LABEL_313;
                            }
                            continue;
                          }
                          break;
                        }
                        v304 = 2 * v102;
                        v305 = v103;
                        if ( 2 * v102 < 0x100 )
                          v304 = 256;
                        if ( v569 )
                        {
LABEL_957:
                          v553 = (char **)v304;
                          realloc(v305, v304);
                          v306 = (unsigned int)v553;
                          _ECX = (int)v310;
                          if ( !v310 )
                          {
                            v582 = v103;
                            v5 = (char *)v571;
                            if ( v569 )
                            {
                              v546 = (char *)v103;
                              v20 = 0;
                              free(v546);
                              v582 = 0;
                            }
                            else
                            {
                              v582 = 0;
                              v20 = 0;
                            }
                            v573 = -1;
                            goto LABEL_34;
                          }
                          if ( !v569 )
                          {
                            v554 = v310;
                            memcpy(v310, v103, v102);
                            v569 = 1;
                            v552 = (signed int)v553;
                            v103 = (char **)v554;
                            goto LABEL_311;
                          }
                        }
                        else
                        {
                          if ( v304 > 0x1000 )
                          {
                            v553 = (char **)v304;
                            v309 = _libc_alloca_cutoff(v304);
                            v304 = (unsigned int)v553;
                            if ( !v309 )
                            {
                              v305 = 0;
                              goto LABEL_957;
                            }
                          }
                          v581 = (v304 + 15) & 0xFFFFFFF0;
                          v577 = v581 + 30;
                          v306 = v552 + v581;
                          v307 = alloca(16 * ((v581 + 30) / 0x10));
                          _ECX = (int)v550;
                          if ( v103 != (char **)&v550[v581] )
                            v306 = v581;
                          if ( v103 )
                          {
                            v553 = (char **)v306;
                            v554 = v550;
                            memcpy(v550, v103, v552);
                            v552 = (signed int)v553;
                            v103 = (char **)v554;
                            goto LABEL_311;
                          }
                        }
                        v552 = v306;
                        v103 = (char **)_ECX;
                        goto LABEL_311;
                      }
                      if ( !v189 )
                      {
                        v584 = 0;
                        v103 = (char **)v577;
                        v102 = (unsigned int)v563;
                        v585 = v191;
                        goto LABEL_522;
                      }
                    }
                  }
                  if ( !v108 )
                    goto LABEL_308;
LABEL_522:
                  if ( (_BYTE)v571 || !v556 )
                  {
                    v194 = v579;
                  }
                  else
                  {
                    v192 = v107 - s1;
                    v193 = v192 <= 0;
                    v552 = v192;
                    v194 = v579;
                    if ( v193 )
                    {
                      v195 = 0;
LABEL_530:
                      if ( v552 == v195 && v585 == (unsigned __int8)*v194 && v584 >= 0 )
                      {
                        v51 = *++v194 == 0;
                        if ( !v51 )
                        {
                          if ( v584 )
                          {
                            v196 = (int)v103;
                            v197 = (int *)_ECX;
                            v577 = v102;
                            v198 = v584;
                            while ( 1 )
                            {
                              v199 = (unsigned __int8 *)v197[1];
                              if ( (unsigned int)v199 >= v197[2] )
                              {
                                v553 = (char **)v196;
                                v477 = (int *)_uflow(v197);
                                v196 = (int)v553;
                                v585 = (int)v477;
                                if ( v477 == (int *)-1 )
                                {
                                  _ECX = (int)v197;
                                  v103 = v553;
                                  v584 = v198;
                                  v102 = v577;
                                  v578 = __readgsdword(0xFFFFFFE8);
                                  break;
                                }
                              }
                              else
                              {
                                v200 = *v199;
                                v197[1] = (int)(v199 + 1);
                                v585 = v200;
                              }
                              v201 = (int *)(unsigned __int8)*v194;
                              --v198;
                              ++v586;
                              if ( v201 == (int *)v585 && v198 >= 0 )
                              {
                                if ( *++v194 )
                                {
                                  if ( v198 )
                                    continue;
                                }
                              }
                              v584 = v198;
                              v102 = v577;
                              _ECX = (int)v197;
                              v103 = (char **)v196;
                              break;
                            }
                          }
                        }
                      }
                    }
                    else if ( *v579 == *s1 )
                    {
                      v577 = (int)v103;
                      v563 = (char *)v102;
                      v551 = (char **)_ECX;
                      do
                      {
                        v195 = ++v194 - v579;
                        if ( v552 <= v194 - v579 )
                        {
                          v103 = (char **)v577;
                          v102 = (unsigned int)v563;
                          _ECX = (int)v551;
                          goto LABEL_530;
                        }
                      }
                      while ( *v194 == s1[v195] );
                      v103 = (char **)v577;
                      v102 = (unsigned int)v563;
                      _ECX = (int)v551;
                    }
                  }
                  if ( !v194 || *v194 )
                  {
                    v15 = v585;
                    v584 = v102;
                    v5 = (char *)_ECX;
                    v582 = v103;
                    if ( v585 != -1 )
                    {
                      --v586;
                      IO_sputbackc((_DWORD *)_ECX, (unsigned __int8)v585);
                    }
LABEL_774:
                    if ( (v575 & 0x400) == 0 || (v575 & 0x800) != 0 )
                      goto LABEL_775;
                    LOBYTE(v577) = v584 == 0;
                    if ( (_BYTE)v571 || (_BYTE)v577 )
                    {
                      v585 = wctrans("to_inpunct");
                      if ( !v585 )
                        goto LABEL_775;
                      if ( v15 == -1 )
                      {
                        __writegsdword(0xFFFFFFE8, v578);
                      }
                      else
                      {
                        v425 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                        if ( (unsigned int)v425 < *((_DWORD *)v5 + 2) )
                        {
                          v15 = *v425;
                          *((_DWORD *)v5 + 1) = v425 + 1;
                          goto LABEL_1281;
                        }
                        v15 = _uflow((int *)v5);
                        if ( v15 == -1 )
                          v578 = __readgsdword(0xFFFFFFE8);
                        else
LABEL_1281:
                          ++v586;
                      }
                      v426 = towctrans(0x2Eu, (_DWORD *)v585);
                      v598 = 0;
                      v599 = 0;
                      v591 = v426;
                      v427 = wcrtomb(s2, v426, &v598);
                      if ( v427 == -1 )
                      {
                        v445 = strlen(s1);
                        if ( v445 > 0x10 )
                          goto LABEL_775;
                        LOBYTE(v554) = (v584 == v445) | v577;
                        memcpy(s2, s1, v445 + 1);
                        _ECX = (unsigned __int8)v554;
                      }
                      else
                      {
                        s2[v427] = 0;
                        v577 = (unsigned __int8)v577;
                        v428 = strlen(s1);
                        v429 = 0;
                        if ( v428 == v584 )
                          v429 = strcmp(s1, s2) == 0;
                        _ECX = v429 | (unsigned __int8)v577;
                      }
                      if ( !(_BYTE)_ECX )
                        goto LABEL_775;
                      v560 = (unsigned int)v587;
                      LOBYTE(v556) = (v575 & 0x80u) != 0;
                      v430 = 0;
                      v563 = v587;
                      LOBYTE(v577) = (v575 & 0x80u) != 0;
                      while ( 1 )
                      {
                        v547 = (unsigned int *)v585;
                        if ( v430 == 10 )
                        {
                          v431 = towctrans(0x2Cu, v547);
                          LOBYTE(v577) = (v431 != 0) & v577;
                          v590 = v431;
                        }
                        else
                        {
                          v431 = towctrans(v430 + 48, v547);
                          *(_DWORD *)&s2[4 * v430 + 17] = v431;
                        }
                        v598 = 0;
                        v599 = 0;
                        v432 = wcrtomb(v563, v431, &v598);
                        if ( v432 == -1 )
                        {
                          if ( v430 != 10 )
                            goto LABEL_775;
                          if ( (_BYTE)v577 )
                          {
                            v446 = strlen(v579);
                            if ( v446 <= 0x10 )
                              memcpy(v588, v579, v446 + 1);
LABEL_1293:
                            v585 = (int)v5;
                            v433 = v582;
                            v434 = v581;
                            v577 = v15;
                            while ( 2 )
                            {
                              v435 = (unsigned __int8 *)v560;
                              v563 = 0;
                              if ( (_BYTE)v561 )
                              {
                                if ( *((_BYTE *)v433 + v584 - 1) == (_BYTE)v562 && (v577 == 43 || v577 == 45) )
                                {
                                  if ( v434 != v584 )
                                  {
                                    v492 = v433;
LABEL_1500:
                                    v493 = v584;
                                    v433 = v492;
                                    *((_BYTE *)v492 + v584) = v577;
                                    v584 = v493 + 1;
                                    goto LABEL_1491;
                                  }
                                  v496 = v433;
                                  v497 = 2 * v584;
                                  if ( (unsigned int)(2 * v584) < 0x100 )
                                    v497 = 256;
                                  if ( !v569 )
                                  {
                                    if ( v497 <= 0x1000 || _libc_alloca_cutoff(v497) )
                                    {
                                      v498 = (v497 + 15) & 0xFFFFFFF0;
                                      v499 = alloca(v498 + 16);
                                      if ( v433 == (char **)&v550[v498] )
                                        v498 += v434;
                                      if ( v433 )
                                      {
                                        v553 = (char **)v498;
                                        memcpy(v550, v433, v434);
                                        v434 = (unsigned int)v553;
                                      }
                                      else
                                      {
                                        v434 = v498;
                                      }
                                      v492 = (char **)v550;
                                      goto LABEL_1500;
                                    }
                                    v496 = 0;
                                  }
                                  realloc(v496, v497);
                                  v492 = v505;
                                  if ( !v505 )
                                  {
                                    v582 = v433;
                                    v5 = (char *)v585;
                                    if ( v569 )
                                    {
                                      v546 = (char *)v433;
                                      v20 = 0;
                                      free(v546);
                                      v582 = 0;
                                    }
                                    else
                                    {
                                      v582 = 0;
                                      v20 = 0;
                                    }
                                    v573 = -1;
                                    goto LABEL_34;
                                  }
                                  v434 = v497;
                                  if ( !v569 )
                                  {
                                    v553 = v505;
                                    memcpy(v505, v433, v584);
                                    v492 = v553;
                                    v569 = 1;
                                  }
                                  goto LABEL_1500;
                                }
LABEL_1296:
                                v436 = v577;
                                v582 = v433;
                                v581 = v434;
                                while ( 1 )
                                {
                                  v437 = *v435;
                                  v438 = 0x7FFFFFFF;
                                  _ECX = *v435;
                                  if ( v583 > 0 )
                                    v438 = v583;
                                  if ( v436 == v437 )
                                    break;
                                  v439 = v435;
LABEL_1484:
                                  if ( !v437 )
                                    goto LABEL_1485;
LABEL_1306:
                                  if ( v435 < v439 )
                                  {
                                    if ( v436 != -1 )
                                    {
                                      --v586;
                                      IO_sputbackc((_DWORD *)v585, (unsigned __int8)v436);
                                    }
                                    v441 = (int)(v439 - 1);
                                    v442 = v439;
                                    v443 = v439 - 1;
                                    if ( v439 - 1 > v435 )
                                    {
                                      while ( 1 )
                                      {
                                        v444 = *(v442 - 1);
                                        v553 = (char **)v441;
                                        IO_sputbackc((_DWORD *)v585, v444);
                                        _ECX = (int)(v443 - 1);
                                        v441 = (int)v553;
                                        if ( v443 - 1 == v435 )
                                          break;
                                        v442 = v443--;
                                      }
                                      v487 = v439 - 2;
                                      v439 = (unsigned __int8 *)v553 + v435 - (v439 - 2);
                                      v586 = v443 - v487 + v586 - 2;
                                    }
                                    v436 = *(v439 - 1);
                                  }
                                  ++v563;
                                  v435 += 17;
                                  if ( v563 == (char *)12 )
                                  {
                                    v5 = (char *)v585;
                                    v15 = v436;
LABEL_1480:
                                    if ( v15 != -1 )
                                    {
                                      --v586;
                                      IO_sputbackc(v5, (unsigned __int8)v15);
                                    }
LABEL_775:
                                    if ( !v584 )
                                    {
                                      v20 = 2;
                                      goto LABEL_34;
                                    }
                                    if ( v584 == 2 && (v575 & 0x800) != 0 )
                                    {
                                      v20 = 2;
                                      goto LABEL_34;
                                    }
                                    goto LABEL_672;
                                  }
                                }
                                v439 = v435 + 1;
                                if ( v435[1] )
                                {
                                  while ( 1 )
                                  {
                                    v440 = *(unsigned __int8 **)(v585 + 4);
                                    if ( (unsigned int)v440 >= *(_DWORD *)(v585 + 8) )
                                    {
                                      v436 = _uflow((int *)v585);
                                      if ( v436 == -1 )
                                      {
                                        v578 = __readgsdword(0xFFFFFFE8);
                                        v437 = *v439;
                                        goto LABEL_1484;
                                      }
                                    }
                                    else
                                    {
                                      v436 = *v440;
                                      *(_DWORD *)(v585 + 4) = v440 + 1;
                                    }
                                    v437 = *v439;
                                    --v438;
                                    ++v586;
                                    _ECX = v437;
                                    if ( v437 != v436 )
                                      goto LABEL_1484;
                                    if ( !*++v439 )
                                      break;
                                    if ( !v438 )
                                      goto LABEL_1306;
                                  }
                                }
LABEL_1485:
                                v577 = v436;
                                v488 = v438;
                                v433 = v582;
                                v434 = v581;
                                if ( v583 <= 0 )
                                  v488 = v583;
                                v583 = v488;
                                if ( (int)v563 <= 9 )
                                {
                                  if ( v581 != v584 )
                                  {
                                    v489 = v582;
LABEL_1490:
                                    v433 = v489;
                                    v490 = v584;
                                    *((_BYTE *)v489 + v584) = (_BYTE)v563 + 48;
                                    v584 = v490 + 1;
                                    goto LABEL_1491;
                                  }
                                  v506 = 2 * v584;
                                  if ( (unsigned int)(2 * v584) < 0x100 )
                                    v506 = 256;
                                  v507 = v582;
                                  if ( !v569 )
                                  {
                                    if ( v506 <= 0x1000 || _libc_alloca_cutoff(v506) )
                                    {
                                      v508 = (v506 + 15) & 0xFFFFFFF0;
                                      v509 = alloca(v508 + 16);
                                      if ( v433 == (char **)&v550[v508] )
                                        v508 += v434;
                                      if ( v433 )
                                      {
                                        v553 = (char **)v508;
                                        memcpy(v550, v433, v434);
                                        v434 = (unsigned int)v553;
                                      }
                                      else
                                      {
                                        v434 = v508;
                                      }
                                      v489 = (char **)v550;
                                      goto LABEL_1490;
                                    }
                                    v507 = 0;
                                  }
                                  realloc(v507, v506);
                                  v489 = v519;
                                  if ( !v519 )
                                  {
                                    v582 = v433;
                                    v5 = (char *)v585;
                                    if ( v569 )
                                    {
                                      v546 = (char *)v433;
                                      v20 = 0;
                                      free(v546);
                                      v582 = 0;
                                    }
                                    else
                                    {
                                      v582 = 0;
                                      v20 = 0;
                                    }
                                    v573 = -1;
                                    goto LABEL_34;
                                  }
                                  v434 = v506;
                                  if ( !v569 )
                                  {
                                    v553 = v519;
                                    memcpy(v519, v433, v584);
                                    v489 = v553;
                                    v569 = 1;
                                  }
                                  goto LABEL_1490;
                                }
                                v510 = v571 ^ 1;
                                if ( v563 == (char *)11 && v510 )
                                {
                                  if ( !*s1 )
                                  {
                                    LOBYTE(v571) = 1;
                                    goto LABEL_1491;
                                  }
                                  v581 = (unsigned int)s1;
                                  v511 = v582;
                                  while ( 2 )
                                  {
                                    if ( v434 == v584 )
                                    {
                                      v515 = 2 * v584;
                                      if ( (unsigned int)(2 * v584) < 0x100 )
                                        v515 = 256;
                                      v516 = v511;
                                      if ( !v569 )
                                      {
                                        if ( v515 <= 0x1000 || _libc_alloca_cutoff(v515) )
                                        {
                                          v517 = (v515 + 15) & 0xFFFFFFF0;
                                          v518 = alloca(16 * ((v517 + 30) / 0x10));
                                          if ( v511 == (char **)&v550[v517] )
                                            v517 += v434;
                                          if ( v511 )
                                          {
                                            v547 = (unsigned int *)v511;
                                            v511 = (char **)v550;
                                            v554 = (char *)v517;
                                            memcpy(v550, v547, v434);
                                            v434 = (unsigned int)v554;
                                          }
                                          else
                                          {
                                            v434 = v517;
                                            v511 = (char **)v550;
                                          }
                                          goto LABEL_1563;
                                        }
                                        v516 = 0;
                                      }
                                      realloc(v516, v515);
                                      if ( !v520 )
                                      {
                                        v20 = 0;
                                        v5 = (char *)v585;
                                        v582 = 0;
                                        v573 = -1;
                                        if ( !v569 )
                                          goto LABEL_34;
                                        goto LABEL_1600;
                                      }
                                      v434 = v515;
                                      if ( v569 )
                                      {
                                        v511 = v520;
                                      }
                                      else
                                      {
                                        v553 = v520;
                                        memcpy(v520, v511, v584);
                                        v569 = 1;
                                        v511 = v553;
                                      }
                                    }
LABEL_1563:
                                    v512 = v584;
                                    v513 = *(_BYTE *)v581++;
                                    v514 = (_BYTE *)v581;
                                    *((_BYTE *)v511 + v584) = v513;
                                    v51 = *v514 == 0;
                                    v584 = v512 + 1;
                                    if ( v51 )
                                    {
                                      v433 = v511;
                                      LOBYTE(v571) = 1;
                                      goto LABEL_1491;
                                    }
                                    continue;
                                  }
                                }
                                if ( v563 != (char *)10 || !v510 || !(_BYTE)v556 )
                                {
                                  v15 = v577;
                                  v5 = (char *)v585;
                                  goto LABEL_1480;
                                }
                                if ( !*v579 )
                                {
                                  LOBYTE(v571) = 0;
LABEL_1491:
                                  _ECX = v583;
                                  if ( !v583 )
                                  {
                                    v581 = v434;
                                    v15 = v577;
                                    v582 = v433;
                                    v5 = (char *)v585;
                                    goto LABEL_775;
                                  }
                                  if ( v577 == -1 )
                                  {
                                    _ECX = v578;
                                    v581 = v434;
                                    v15 = -1;
                                    v582 = v433;
                                    v5 = (char *)v585;
                                    __writegsdword(0xFFFFFFE8, v578);
                                    goto LABEL_775;
                                  }
                                  v491 = *(unsigned __int8 **)(v585 + 4);
                                  if ( (unsigned int)v491 >= *(_DWORD *)(v585 + 8) )
                                  {
                                    v577 = _uflow((int *)v585);
                                    if ( v577 == -1 )
                                    {
                                      v15 = -1;
                                      v581 = v434;
                                      v5 = (char *)v585;
                                      v582 = v433;
                                      v578 = __readgsdword(0xFFFFFFE8);
                                      goto LABEL_775;
                                    }
                                  }
                                  else
                                  {
                                    v577 = *v491;
                                    *(_DWORD *)(v585 + 4) = v491 + 1;
                                  }
                                  ++v586;
                                  v583 -= v583 > 0;
                                  continue;
                                }
                                v581 = (unsigned int)v579;
                                v511 = v582;
                                while ( 2 )
                                {
                                  if ( v434 == v584 )
                                  {
                                    v524 = 2 * v584;
                                    if ( (unsigned int)(2 * v584) < 0x100 )
                                      v524 = 256;
                                    v525 = v511;
                                    if ( !v569 )
                                    {
                                      if ( v524 <= 0x1000 || _libc_alloca_cutoff(v524) )
                                      {
                                        v526 = (v524 + 15) & 0xFFFFFFF0;
                                        v527 = alloca(16 * ((v526 + 30) / 0x10));
                                        if ( v511 == (char **)&v550[v526] )
                                          v526 += v434;
                                        if ( v511 )
                                        {
                                          v547 = (unsigned int *)v511;
                                          v511 = (char **)v550;
                                          v554 = (char *)v526;
                                          memcpy(v550, v547, v434);
                                          v434 = (unsigned int)v554;
                                        }
                                        else
                                        {
                                          v434 = v526;
                                          v511 = (char **)v550;
                                        }
                                        goto LABEL_1592;
                                      }
                                      v525 = 0;
                                    }
                                    realloc(v525, v524);
                                    if ( !v528 )
                                    {
                                      v20 = 0;
                                      v5 = (char *)v585;
                                      v582 = 0;
                                      v573 = -1;
                                      if ( !v569 )
                                        goto LABEL_34;
LABEL_1600:
                                      free(v511);
                                      v20 = (int)v582;
                                      goto LABEL_34;
                                    }
                                    v434 = v524;
                                    if ( v569 )
                                    {
                                      v511 = v528;
                                    }
                                    else
                                    {
                                      v553 = v528;
                                      memcpy(v528, v511, v584);
                                      v569 = 1;
                                      v511 = v553;
                                    }
                                  }
LABEL_1592:
                                  v521 = v584;
                                  v522 = *(_BYTE *)v581++;
                                  v523 = (_BYTE *)v581;
                                  *((_BYTE *)v511 + v584) = v522;
                                  v51 = *v523 == 0;
                                  v584 = v521 + 1;
                                  if ( v51 )
                                  {
                                    v433 = v511;
                                    LOBYTE(v571) = 0;
                                    goto LABEL_1491;
                                  }
                                  continue;
                                }
                              }
                              break;
                            }
                            if ( !v584 )
                              goto LABEL_1296;
                            v435 = (unsigned __int8 *)v560;
                            if ( (_BYTE)v562 != *(_BYTE *)(v574[14] + 4 * (unsigned __int8)v577) )
                              goto LABEL_1296;
                            if ( v434 != v584 )
                            {
                              v494 = v433;
LABEL_1505:
                              v495 = v584;
                              v433 = v494;
                              LOBYTE(v561) = 1;
                              LOBYTE(v571) = 1;
                              *((_BYTE *)v494 + v584) = v562;
                              v584 = v495 + 1;
                              goto LABEL_1491;
                            }
                            v500 = 2 * v584;
                            if ( (unsigned int)(2 * v584) < 0x100 )
                              v500 = 256;
                            v501 = v433;
                            if ( !v569 )
                            {
                              if ( v500 <= 0x1000 || _libc_alloca_cutoff(v500) )
                              {
                                v502 = (v500 + 15) & 0xFFFFFFF0;
                                v503 = alloca(v502 + 16);
                                if ( v433 == (char **)&v550[v502] )
                                  v502 += v434;
                                if ( v433 )
                                {
                                  v553 = (char **)v502;
                                  memcpy(v550, v433, v434);
                                  v434 = (unsigned int)v553;
                                }
                                else
                                {
                                  v434 = v502;
                                }
                                v494 = (char **)v550;
                                goto LABEL_1505;
                              }
                              v501 = 0;
                            }
                            realloc(v501, v500);
                            v494 = v504;
                            if ( !v504 )
                            {
                              v582 = v433;
                              v5 = (char *)v585;
                              if ( v569 )
                              {
                                v546 = (char *)v433;
                                v20 = 0;
                                free(v546);
                                v582 = 0;
                              }
                              else
                              {
                                v582 = 0;
                                v20 = 0;
                              }
                              v573 = -1;
                              goto LABEL_34;
                            }
                            v434 = v500;
                            if ( !v569 )
                            {
                              v553 = v504;
                              memcpy(v504, v433, v584);
                              v494 = v553;
                              v569 = 1;
                            }
                            goto LABEL_1505;
                          }
                        }
                        else
                        {
                          *((_BYTE *)&v601[-91] + 17 * v430 + v432) = 0;
                        }
                        ++v430;
                        v563 += 17;
                        if ( v430 == 11 )
                          goto LABEL_1293;
                      }
                    }
LABEL_672:
                    if ( v581 != v584 )
                    {
                      v20 = (int)v582;
                      goto LABEL_674;
                    }
                    v471 = 2 * v584;
                    if ( (unsigned int)(2 * v584) < 0x100 )
                      v471 = 256;
                    v472 = v582;
                    if ( v569 )
                    {
LABEL_1397:
                      v553 = (char **)v471;
                      realloc(v472, v471);
                      v473 = (unsigned int)v553;
                      v20 = (int)v476;
                      if ( !v476 )
                      {
                        if ( v569 )
                        {
                          free(v582);
                          v582 = 0;
                        }
                        else
                        {
                          v582 = 0;
                          v20 = 0;
                        }
                        v573 = -1;
                        goto LABEL_34;
                      }
                      if ( v569 )
                        goto LABEL_1394;
                      memcpy(v476, v582, v584);
                      v582 = (char **)v20;
                      v569 = 1;
                      v581 = (unsigned int)v553;
                    }
                    else
                    {
                      if ( v471 > 0x1000 )
                      {
                        v553 = (char **)v471;
                        v475 = _libc_alloca_cutoff(v471);
                        v471 = (unsigned int)v553;
                        if ( !v475 )
                        {
                          v472 = 0;
                          goto LABEL_1397;
                        }
                      }
                      v473 = (v471 + 15) & 0xFFFFFFF0;
                      v474 = alloca(v473 + 16);
                      v20 = (int)v550;
                      if ( v582 == (char **)&v550[v473] )
                        v473 += v581;
                      if ( v582 )
                      {
                        v553 = (char **)v473;
                        memcpy(v550, v582, v581);
                        v473 = (unsigned int)v553;
                      }
LABEL_1394:
                      v581 = v473;
                      v582 = (char **)v20;
                    }
LABEL_674:
                    *((_BYTE *)v582 + v584) = 0;
                    if ( (v575 & 2) != 0 )
                    {
                      _strtold_internal((_BYTE *)v20, v601, v575 & 0x80);
                      v236 = (char **)v601[0];
                      if ( (v575 & 8) != 0 )
                        goto LABEL_683;
                      if ( (char **)v601[0] == v582 )
                        goto LABEL_1163;
                      if ( v572 )
                      {
                        v284 = &a4[v572 - 1];
                        if ( v572 == 1 )
                          v284 = a4;
                        _ECX = *v284;
                        v236 = (char **)v601[0];
                        v237 = v568;
                      }
                      else
                      {
                        _ECX = *v568;
                        v237 = v568 + 1;
                      }
                      if ( (_BYTE)v557 )
                        a1 = -a1;
                      *(long double *)_ECX = a1;
                      v568 = v237;
                    }
                    else
                    {
                      v548 = v575 & 0x80;
                      v547 = v601;
                      v546 = (char *)v20;
                      if ( (v575 & 3) != 0 )
                      {
                        _strtod_internal(v546, v547, v548);
                        v236 = (char **)v601[0];
                        if ( (v575 & 8) != 0 )
                          goto LABEL_683;
                        if ( (char **)v601[0] != v582 )
                        {
                          if ( v572 )
                          {
                            v276 = &a4[v572 - 1];
                            if ( v572 == 1 )
                              v276 = a4;
                            _ECX = *v276;
                            v236 = (char **)v601[0];
                          }
                          else
                          {
                            _ECX = *v568++;
                          }
                          if ( (_BYTE)v557 )
                            a1 = -a1;
                          *(double *)_ECX = a1;
                          goto LABEL_683;
                        }
LABEL_1163:
                        v20 = 2;
                        goto LABEL_34;
                      }
                      _strtof_internal(v546, v547, v548);
                      v236 = (char **)v601[0];
                      if ( (v575 & 8) != 0 )
                        goto LABEL_683;
                      if ( (char **)v601[0] == v582 )
                        goto LABEL_1163;
                      if ( v572 )
                      {
                        v275 = &a4[v572 - 1];
                        if ( v572 == 1 )
                          v275 = a4;
                        _ECX = *v275;
                        v236 = (char **)v601[0];
                      }
                      else
                      {
                        _ECX = *v568++;
                      }
                      if ( (_BYTE)v557 )
                        a1 = -a1;
                      *(float *)_ECX = a1;
                    }
LABEL_683:
                    if ( v236 == v582 )
                    {
                      v20 = 2;
                      goto LABEL_34;
                    }
                    v584 = 0;
                    v573 += (v575 & 8) == 0;
LABEL_23:
                    v6 = v576;
                    v16 = *v576;
                    if ( !*v576 )
                    {
LABEL_24:
                      v20 = 0;
                      if ( !v584 )
                        goto LABEL_34;
                      v21 = v15;
                      v22 = v574;
                      v23 = v578;
                      while ( 2 )
                      {
                        while ( v21 == -1 )
                        {
                          _ECX = v22[13];
                          __writegsdword(0xFFFFFFE8, v23);
                          if ( (*(_BYTE *)(_ECX - 2 + 1) & 0x20) == 0 )
                          {
LABEL_32:
                            v20 = 0;
                            if ( v21 != -1 )
                              IO_sputbackc(v5, (unsigned __int8)v21);
                            goto LABEL_34;
                          }
                        }
                        v24 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                        if ( (unsigned int)v24 < *((_DWORD *)v5 + 2) )
                        {
                          v21 = *v24;
                          *((_DWORD *)v5 + 1) = v24 + 1;
                          goto LABEL_28;
                        }
                        v21 = _uflow((int *)v5);
                        if ( v21 == -1 )
                        {
                          v23 = __readgsdword(0xFFFFFFE8);
                          v25 = -2;
                        }
                        else
                        {
LABEL_28:
                          v25 = 2 * v21;
                        }
                        _ECX = v22[13];
                        if ( (*(_BYTE *)(_ECX + v25 + 1) & 0x20) == 0 )
                          goto LABEL_32;
                        continue;
                      }
                    }
                    goto LABEL_9;
                  }
                  v202 = v579;
                  if ( !*v579 )
                    goto LABEL_550;
                  v563 = (char *)_ECX;
                  v551 = (char **)v581;
                  while ( 1 )
                  {
                    if ( v551 == (char **)v102 )
                    {
                      v447 = 2 * v102;
                      v448 = v103;
                      if ( 2 * v102 < 0x100 )
                        v447 = 256;
                      if ( v569 )
                        goto LABEL_1342;
                      if ( v447 > 0x1000 )
                      {
                        v553 = (char **)v447;
                        v457 = _libc_alloca_cutoff(v447);
                        v447 = (unsigned int)v553;
                        if ( !v457 )
                        {
                          v448 = 0;
LABEL_1342:
                          v553 = (char **)v447;
                          realloc(v448, v447);
                          v449 = (unsigned int)v553;
                          _ECX = (int)v458;
                          if ( !v458 )
                          {
                            v582 = v103;
                            v5 = v563;
                            if ( v569 )
                            {
                              v546 = (char *)v103;
                              v20 = 0;
                              free(v546);
                              v582 = 0;
                            }
                            else
                            {
                              v582 = 0;
                              v20 = 0;
                            }
                            v573 = -1;
                            goto LABEL_34;
                          }
                          if ( !v569 )
                          {
                            v554 = v458;
                            memcpy(v458, v103, v102);
                            v569 = 1;
                            v551 = v553;
                            v103 = (char **)v554;
                            goto LABEL_548;
                          }
LABEL_1344:
                          v551 = (char **)v449;
                          v103 = (char **)_ECX;
                          goto LABEL_548;
                        }
                      }
                      v581 = (v447 + 15) & 0xFFFFFFF0;
                      v577 = v581 + 30;
                      v449 = (unsigned int)v551 + v581;
                      v450 = alloca(16 * ((v581 + 30) / 0x10));
                      _ECX = (int)v550;
                      if ( v103 != (char **)&v550[v581] )
                        v449 = v581;
                      if ( !v103 )
                        goto LABEL_1344;
                      v553 = (char **)v449;
                      v554 = v550;
                      memcpy(v550, v103, (unsigned int)v551);
                      v551 = v553;
                      v103 = (char **)v554;
                    }
LABEL_548:
                    v203 = *v202++;
                    *((_BYTE *)v103 + v102++) = v203;
                    if ( !*v202 )
                    {
                      v581 = (unsigned int)v551;
                      _ECX = (int)v563;
LABEL_550:
                      v204 = v584;
                      if ( v583 <= 0 )
                        v204 = v583;
                      v583 = v204;
LABEL_297:
                      if ( !v583 )
                      {
                        v15 = v585;
                        v584 = v102;
                        v5 = (char *)_ECX;
                        v582 = v103;
                        goto LABEL_774;
                      }
                      if ( v585 == -1 )
                      {
                        v582 = v103;
                        v584 = v102;
                        v15 = -1;
                        v5 = (char *)_ECX;
                        __writegsdword(0xFFFFFFE8, v578);
                        goto LABEL_774;
                      }
                      v104 = *(unsigned __int8 **)(_ECX + 4);
                      if ( (unsigned int)v104 < *(_DWORD *)(_ECX + 8) )
                      {
                        v105 = *v104;
                        *(_DWORD *)(_ECX + 4) = v104 + 1;
                        v585 = v105;
                        goto LABEL_301;
                      }
                      v554 = (char *)_ECX;
                      v397 = (int *)_uflow((int *)_ECX);
                      _ECX = (int)v554;
                      v585 = (int)v397;
                      if ( v397 == (int *)-1 )
                      {
                        v584 = v102;
                        v15 = -1;
                        v5 = v554;
                        v582 = v103;
                        v578 = __readgsdword(0xFFFFFFE8);
                        goto LABEL_774;
                      }
LABEL_301:
                      ++v586;
                      v583 -= v583 > 0;
                      if ( (unsigned int)(v585 - 48) <= 9 )
                        goto LABEL_295;
                      goto LABEL_302;
                    }
                  }
                }
                if ( v581 != v102 )
                {
LABEL_567:
                  LOBYTE(v561) = 1;
                  LOBYTE(v571) = 1;
                  *((_BYTE *)v103 + v102++) = v562;
                  goto LABEL_297;
                }
                v529 = 2 * v102;
                if ( 2 * v102 < 0x100 )
                  v529 = 256;
                v530 = v103;
                if ( !v569 )
                {
                  if ( v529 <= 0x1000 || (v554 = (char *)_ECX, v535 = _libc_alloca_cutoff(v529), _ECX = (int)v554, v535) )
                  {
                    v529 = (v529 + 15) & 0xFFFFFFF0;
                    v531 = alloca(v529 + 16);
                    v532 = (char **)v550;
                    v577 = (int)&v550[v529];
                    if ( v103 == (char **)&v550[v529] )
                      v529 += v581;
                    if ( v103 )
                    {
                      v553 = (char **)v550;
                      v554 = (char *)_ECX;
                      memcpy(v550, v103, v581);
                      v581 = v529;
                      _ECX = (int)v554;
                      v103 = v553;
                      goto LABEL_567;
                    }
LABEL_1633:
                    v581 = v529;
                    v103 = v532;
                    goto LABEL_567;
                  }
                  v530 = 0;
                }
                v554 = (char *)_ECX;
                realloc(v530, v529);
                _ECX = (int)v554;
                v532 = v536;
                if ( !v536 )
                {
                  v5 = v554;
                  v582 = v103;
                  if ( v569 )
                  {
                    v546 = (char *)v103;
                    v20 = 0;
                    free(v546);
                    v582 = 0;
                  }
                  else
                  {
                    v582 = 0;
                    v20 = 0;
                  }
                  v573 = -1;
                  goto LABEL_34;
                }
                if ( !v569 )
                {
                  v553 = v536;
                  memcpy(v536, v103, v102);
                  v581 = v529;
                  _ECX = (int)v554;
                  v569 = 1;
                  v103 = v553;
                  goto LABEL_567;
                }
                goto LABEL_1633;
              }
              if ( v581 == 1 )
              {
                if ( v569 )
                {
                  realloc(v582, 0x100u);
                  if ( !v538 )
                    goto LABEL_1198;
                  v582 = v538;
                  v581 = 256;
                }
                else
                {
                  LOBYTE(v541) = *(_BYTE *)v582;
                  v581 = (v582 == &v546) + 256;
                  v582 = &v541;
                }
              }
              v575 |= 0x800u;
              v575 &= ~0x80u;
              *((_BYTE *)v582 + 1) = v15;
              if ( v15 == -1 )
              {
                __writegsdword(0xFFFFFFE8, v578);
              }
              else
              {
                v184 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                if ( (unsigned int)v184 >= *((_DWORD *)v5 + 2) )
                {
                  v15 = _uflow((int *)v5);
                  if ( v15 == -1 )
                  {
                    v578 = __readgsdword(0xFFFFFFE8);
                    goto LABEL_498;
                  }
                }
                else
                {
                  v15 = *v184;
                  *((_DWORD *)v5 + 1) = v184 + 1;
                }
                ++v586;
              }
LABEL_498:
              v584 = 2;
              LOBYTE(v562) = 112;
              v583 -= v583 > 0;
              goto LABEL_294;
            }
            if ( !v581 )
            {
              if ( v569 )
              {
                realloc(v582, 0x100u);
                if ( !v419 )
                  goto LABEL_1198;
                v582 = v419;
                v581 = 256;
              }
              else
              {
                v582 = &v541;
                v581 = 256;
              }
            }
            *(_BYTE *)v582 = v15;
            if ( v583 )
            {
              v242 = (_BYTE *)*((_DWORD *)v5 + 1);
              if ( (unsigned int)v242 < *((_DWORD *)v5 + 2) )
              {
                LOBYTE(v243) = *v242;
                *((_DWORD *)v5 + 1) = v242 + 1;
                goto LABEL_713;
              }
              v243 = _uflow((int *)v5);
              if ( v243 != -1 )
              {
LABEL_713:
                _ECX = (int)v574;
                if ( *(_DWORD *)(v574[14] + 4 * (unsigned __int8)v243) != 110 )
                {
                  v20 = 2;
                  goto LABEL_34;
                }
                v583 -= v583 > 0;
                if ( v581 == 1 )
                {
                  if ( v569 )
                  {
                    realloc(v582, 0x100u);
                    if ( !v401 )
                      goto LABEL_1198;
                    v582 = v401;
                    v581 = 256;
                  }
                  else
                  {
                    LOBYTE(v541) = *(_BYTE *)v582;
                    v581 = (v582 == &v546) + 256;
                    v582 = &v541;
                  }
                }
                _ECX = v583;
                v51 = v583 == 0;
                *((_BYTE *)v582 + 1) = v243;
                if ( !v51 )
                {
                  v244 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                  if ( (unsigned int)v244 < *((_DWORD *)v5 + 2) )
                  {
                    v15 = *v244;
                    *((_DWORD *)v5 + 1) = v244 + 1;
                    goto LABEL_718;
                  }
                  v15 = _uflow((int *)v5);
                  if ( v15 != -1 )
                  {
LABEL_718:
                    _ECX = v15;
                    if ( *(_DWORD *)(v574[14] + 4 * (unsigned __int8)v15) != 102 )
                    {
                      v20 = 2;
                      goto LABEL_34;
                    }
                    v583 -= v583 > 0;
                    if ( v581 == 2 )
                    {
                      if ( v569 )
                      {
                        realloc(v582, 0x100u);
                        if ( !v483 )
                          goto LABEL_1198;
                        v582 = v483;
                        v581 = 256;
                      }
                      else
                      {
                        LOWORD(v541) = *(_WORD *)v582;
                        v581 = 2 * (v582 == &v546) + 256;
                        v582 = &v541;
                      }
                    }
                    v245 = v586;
                    *((_BYTE *)v582 + 2) = v15;
                    v246 = v245 + 2;
                    if ( !v583 )
                    {
                      v586 = v246;
                      v584 = 3;
                      goto LABEL_672;
                    }
                    v247 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                    if ( (unsigned int)v247 >= *((_DWORD *)v5 + 2) )
                    {
                      v15 = _uflow((int *)v5);
                      if ( v15 == -1 )
                      {
                        v586 = v246;
                        v584 = 3;
                        v578 = __readgsdword(0xFFFFFFE8);
                        goto LABEL_672;
                      }
                    }
                    else
                    {
                      v15 = *v247;
                      *((_DWORD *)v5 + 1) = v247 + 1;
                    }
                    if ( *(_DWORD *)(v574[14] + 4 * (unsigned __int8)v15) != 105 )
                    {
                      IO_sputbackc(v5, (unsigned __int8)v15);
                      v586 = v246;
                      v584 = 3;
                      goto LABEL_672;
                    }
                    v583 -= v583 > 0;
                    if ( v581 == 3 )
                    {
                      if ( v569 )
                      {
                        realloc(v582, 0x100u);
                        if ( !v480 )
                          goto LABEL_1198;
                        v582 = v480;
                        v581 = 256;
                      }
                      else
                      {
                        LOWORD(v541) = *(_WORD *)v582;
                        BYTE2(v541) = *((_BYTE *)v582 + 2);
                        v581 = 3 * (v582 == &v546) + 256;
                        v582 = &v541;
                      }
                    }
                    _ECX = v583;
                    v51 = v583 == 0;
                    *((_BYTE *)v582 + 3) = v15;
                    if ( !v51 )
                    {
                      v412 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                      if ( (unsigned int)v412 < *((_DWORD *)v5 + 2) )
                      {
                        v413 = *v412;
                        *((_DWORD *)v5 + 1) = v412 + 1;
                        goto LABEL_1229;
                      }
                      v413 = _uflow((int *)v5);
                      if ( v413 != -1 )
                      {
LABEL_1229:
                        _ECX = v413;
                        if ( *(_DWORD *)(v574[14] + 4 * (unsigned __int8)v413) != 110 )
                        {
                          v20 = 2;
                          goto LABEL_34;
                        }
                        v583 -= v583 > 0;
                        if ( v581 == 4 )
                        {
                          if ( v569 )
                          {
                            realloc(v582, 0x100u);
                            if ( !v478 )
                              goto LABEL_1198;
                            v582 = v478;
                            v581 = 256;
                          }
                          else
                          {
                            _ECX = (int)*v582;
                            v541 = *v582;
                            v581 = 4 * (v582 == &v546) + 256;
                            v582 = &v541;
                          }
                        }
                        *((_BYTE *)v582 + 4) = v413;
                        if ( v583 )
                        {
                          v414 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                          if ( (unsigned int)v414 < *((_DWORD *)v5 + 2) )
                          {
                            v415 = *v414;
                            *((_DWORD *)v5 + 1) = v414 + 1;
                            goto LABEL_1234;
                          }
                          v415 = _uflow((int *)v5);
                          if ( v415 != -1 )
                          {
LABEL_1234:
                            _ECX = v415;
                            if ( *(_DWORD *)(v574[14] + 4 * (unsigned __int8)v415) != 105 )
                            {
                              v20 = 2;
                              goto LABEL_34;
                            }
                            v583 -= v583 > 0;
                            if ( v581 == 5 )
                            {
                              if ( v569 )
                              {
                                realloc(v582, 0x100u);
                                if ( !v479 )
                                  goto LABEL_1198;
                                v582 = v479;
                                v581 = 256;
                              }
                              else
                              {
                                v541 = *v582;
                                LOBYTE(v542) = *((_BYTE *)v582 + 4);
                                v581 = 5 * (v582 == &v546) + 256;
                                v582 = &v541;
                              }
                            }
                            _ECX = v583;
                            v51 = v583 == 0;
                            *((_BYTE *)v582 + 5) = v415;
                            if ( !v51 )
                            {
                              v416 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                              if ( (unsigned int)v416 < *((_DWORD *)v5 + 2) )
                              {
                                v417 = *v416;
                                *((_DWORD *)v5 + 1) = v416 + 1;
                                goto LABEL_1239;
                              }
                              v417 = _uflow((int *)v5);
                              if ( v417 != -1 )
                              {
LABEL_1239:
                                _ECX = v417;
                                if ( *(_DWORD *)(v574[14] + 4 * (unsigned __int8)v417) != 116 )
                                {
                                  v20 = 2;
                                  goto LABEL_34;
                                }
                                v583 -= v583 > 0;
                                if ( v581 == 6 )
                                {
                                  if ( v569 )
                                  {
                                    realloc(v582, 0x100u);
                                    if ( !v423 )
                                      goto LABEL_1198;
                                    v582 = v423;
                                    v581 = 256;
                                  }
                                  else
                                  {
                                    _ECX = (int)v582;
                                    v581 = 256;
                                    v541 = *v582;
                                    v542 = *((_WORD *)v582 + 2);
                                    v422 = 262;
                                    if ( v582 != &v546 )
                                      v422 = v581;
                                    v582 = &v541;
                                    v581 = v422;
                                  }
                                }
                                *((_BYTE *)v582 + 6) = v417;
                                if ( v583 )
                                {
                                  v418 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                                  if ( (unsigned int)v418 < *((_DWORD *)v5 + 2) )
                                  {
                                    v15 = *v418;
                                    *((_DWORD *)v5 + 1) = v418 + 1;
                                    goto LABEL_1244;
                                  }
                                  v15 = _uflow((int *)v5);
                                  if ( v15 != -1 )
                                  {
LABEL_1244:
                                    _ECX = v15;
                                    if ( *(_DWORD *)(v574[14] + 4 * (unsigned __int8)v15) != 121 )
                                    {
                                      v20 = 2;
                                      goto LABEL_34;
                                    }
                                    if ( v581 == 7 )
                                    {
                                      if ( v569 )
                                      {
                                        realloc(v582, 0x100u);
                                        if ( !v421 )
                                          goto LABEL_1198;
                                        v582 = v421;
                                        v581 = 256;
                                      }
                                      else
                                      {
                                        v581 = 256;
                                        v541 = *v582;
                                        v542 = *((_WORD *)v582 + 2);
                                        v543 = *((_BYTE *)v582 + 6);
                                        v420 = 263;
                                        if ( v582 != &v546 )
                                          v420 = v581;
                                        v582 = &v541;
                                        v581 = v420;
                                      }
                                    }
                                    v586 += 7;
                                    v584 = 8;
                                    *((_BYTE *)v582 + 7) = v15;
                                    goto LABEL_672;
                                  }
                                }
                                v20 = 2;
                                goto LABEL_34;
                              }
                            }
                            v20 = 2;
                            goto LABEL_34;
                          }
                        }
                        v20 = 2;
                        goto LABEL_34;
                      }
                    }
                    v20 = 2;
                    goto LABEL_34;
                  }
                }
                v20 = 2;
                goto LABEL_34;
              }
            }
            v20 = 2;
            goto LABEL_34;
          }
          if ( !v581 )
          {
            if ( v569 )
            {
              realloc(v582, 0x100u);
              if ( !v398 )
                goto LABEL_1198;
              v582 = v398;
              v581 = 256;
            }
            else
            {
              v582 = &v541;
              v581 = 256;
            }
          }
          _ECX = v583;
          v51 = v583 == 0;
          *(_BYTE *)v582 = v15;
          if ( v51 )
            goto LABEL_871;
          v233 = (_BYTE *)*((_DWORD *)v5 + 1);
          if ( (unsigned int)v233 >= *((_DWORD *)v5 + 2) )
          {
            v234 = _uflow((int *)v5);
            if ( v234 == -1 )
            {
LABEL_871:
              v20 = 2;
              goto LABEL_34;
            }
          }
          else
          {
            LOBYTE(v234) = *v233;
            *((_DWORD *)v5 + 1) = v233 + 1;
          }
          _ECX = (int)v574;
          if ( *(_DWORD *)(v574[14] + 4 * (unsigned __int8)v234) != 97 )
          {
            v20 = 2;
            goto LABEL_34;
          }
          v583 -= v583 > 0;
          if ( v581 == 1 )
          {
            if ( v569 )
            {
              realloc(v582, 0x100u);
              if ( !v301 )
                goto LABEL_1198;
              v582 = v301;
              v581 = 256;
            }
            else
            {
              _ECX = *(unsigned __int8 *)v582;
              LOBYTE(v541) = *(_BYTE *)v582;
              v581 = (v582 == &v546) + 256;
              v582 = &v541;
            }
          }
          *((_BYTE *)v582 + 1) = v234;
          if ( !v583 )
            goto LABEL_927;
          v235 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
          if ( (unsigned int)v235 >= *((_DWORD *)v5 + 2) )
          {
            v15 = _uflow((int *)v5);
            if ( v15 == -1 )
            {
LABEL_927:
              v20 = 2;
              goto LABEL_34;
            }
          }
          else
          {
            v15 = *v235;
            *((_DWORD *)v5 + 1) = v235 + 1;
          }
          _ECX = v15;
          if ( *(_DWORD *)(v574[14] + 4 * (unsigned __int8)v15) != 110 )
          {
            v20 = 2;
            goto LABEL_34;
          }
          if ( v581 == 2 )
          {
            if ( v569 )
            {
              realloc(v582, 0x100u);
              if ( !v302 )
                goto LABEL_1198;
              v582 = v302;
              v581 = 256;
            }
            else
            {
              LOWORD(v541) = *(_WORD *)v582;
              v581 = 2 * (v582 == &v546) + 256;
              v582 = &v541;
            }
          }
          v586 += 2;
          v584 = 3;
          *((_BYTE *)v582 + 2) = v15;
          goto LABEL_672;
        case 0x1Eu:
          goto LABEL_216;
        case 0x2Eu:
          goto LABEL_193;
        case 0x33u:
        case 0x53u:
          goto LABEL_188;
        case 0x36u:
          v577 = v575 & 1;
          if ( (v575 & 1) != 0 )
          {
            if ( (v575 & 8) == 0 )
            {
              if ( (v575 & 0x2100) != 0 )
              {
                if ( v572 )
                {
                  v300 = &a4[v572 - 1];
                  if ( v572 == 1 )
                    v300 = a4;
                  v570 = (_DWORD *)*v300;
                }
                else
                {
                  v84 = (_DWORD *)*v568;
                  _ECX = (int)++v568;
                  v570 = v84;
                }
                if ( !v570 )
                {
                  v20 = 2;
                  goto LABEL_34;
                }
                v85 = (char *)malloc(400);
                _ECX = (int)v570;
                v580 = v85;
                *v570 = v85;
                if ( !v85 )
                {
                  v405 = v575 & 0x2000;
                  v20 = v405 == 0 ? 2 : 0;
                  v51 = v405 == 0;
                  v406 = -1;
                  if ( v51 )
                    v406 = v573;
                  v573 = v406;
                  goto LABEL_34;
                }
                if ( !v564 || (v86 = *v564, v87 = *v564 + 1, *v564 == 32) )
                {
                  v544 = 0;
                  v545 = (int)v564;
                  v87 = 1;
                  v564 = &v544;
                  v86 = 0;
                }
                v88 = (int)v564;
                v89 = v570;
                v567 = 100;
                *v564 = v87;
                *(_DWORD *)(v88 + 4 * v86 + 8) = v89;
              }
              else
              {
                if ( v572 )
                {
                  _ECX = v572;
                  v270 = (char **)&a4[v572 - 1];
                  if ( v572 == 1 )
                    v270 = (char **)a4;
                  v580 = *v270;
                }
                else
                {
                  v252 = (char **)v568++;
                  v580 = *v252;
                }
                if ( !v580 )
                {
                  v20 = 2;
                  goto LABEL_34;
                }
              }
            }
          }
          else if ( (v575 & 8) == 0 )
          {
            if ( (v575 & 0x2100) != 0 )
            {
              if ( v572 )
              {
                _ECX = v572;
                v285 = &a4[v572 - 1];
                if ( v572 == 1 )
                  v285 = a4;
                v570 = (_DWORD *)*v285;
                v584 = (int)v568;
              }
              else
              {
                v176 = (_DWORD *)*v568;
                v584 = (int)(v568 + 1);
                v570 = v176;
              }
              if ( !v570 )
              {
                v20 = 2;
                goto LABEL_34;
              }
              v177 = (char *)malloc(100);
              v566 = v177;
              *v570 = v177;
              if ( !v177 )
              {
                v395 = v575 & 0x2000;
                v20 = v395 == 0 ? 2 : 0;
                v51 = v395 == 0;
                v396 = -1;
                if ( v51 )
                  v396 = v573;
                v573 = v396;
                goto LABEL_34;
              }
              if ( !v564 || (v178 = *v564, v179 = *v564 + 1, *v564 == 32) )
              {
                v179 = 1;
                v544 = 0;
                v545 = (int)v564;
                v564 = &v544;
                v178 = 0;
              }
              v180 = (int)v564;
              v181 = v570;
              v567 = 100;
              *v564 = v179;
              v182 = (int *)v584;
              *(_DWORD *)(v180 + 4 * v178 + 8) = v181;
              v568 = v182;
            }
            else
            {
              if ( v572 )
              {
                _ECX = v572;
                v297 = &a4[v572 - 1];
                if ( v572 == 1 )
                  v297 = a4;
                v566 = (char *)*v297;
              }
              else
              {
                v255 = v568++;
                v566 = (char *)*v255;
              }
              if ( !v566 )
              {
                v20 = 2;
                goto LABEL_34;
              }
            }
          }
          LOBYTE(v584) = 0;
          if ( *(_BYTE *)(v585 + 1) == 94 )
          {
            v576 = (unsigned __int8 *)(v585 + 2);
            LOBYTE(v584) = 1;
          }
          v90 = 0x7FFFFFFF;
          if ( v583 >= 0 )
            v90 = v583;
          v583 = v90;
          if ( v581 <= 0xFF )
          {
            v582 = &v541;
            v581 = 256;
          }
          memset(v582, 0, 0x100u);
          _ECX = 0;
          v91 = *v576;
          if ( *v576 == 45 || v91 == 93 )
          {
            _ECX = (int)v582;
            v210 = v576;
            v585 = v15;
            *((_BYTE *)v582 + v91) = 1;
            v94 = (char **)_ECX;
            v91 = v210[1];
            v92 = v210 + 1;
            v93 = (int *)v5;
          }
          else
          {
            v585 = v15;
            v92 = v576;
            v93 = (int *)v5;
            v94 = v582;
          }
          while ( 1 )
          {
            if ( !v91 )
            {
              v5 = (char *)v93;
              v20 = 2;
              goto LABEL_34;
            }
            ++v92;
            if ( v91 == 93 )
              break;
            if ( v91 == 45 && (v95 = *v92) != 0 && v95 != 93 && (_ECX = *(v92 - 2), (unsigned __int8)_ECX <= v95) )
            {
              if ( (unsigned __int8)_ECX < v95 )
              {
                do
                {
                  v96 = (unsigned __int8)_ECX++;
                  *((_BYTE *)v94 + v96) = 1;
                }
                while ( *v92 > (unsigned __int8)_ECX );
              }
            }
            else
            {
              *((_BYTE *)v94 + v91) = 1;
            }
            v91 = *v92;
          }
          v5 = (char *)v93;
          v576 = v92;
          if ( v577 )
          {
            if ( v585 == -1 )
            {
              __writegsdword(0xFFFFFFE8, v578);
            }
            else
            {
              v212 = (unsigned __int8 *)v93[1];
              if ( (unsigned int)v212 < v93[2] )
              {
                v15 = *v212;
                v93[1] = (int)(v212 + 1);
LABEL_593:
                v600[0] = 0;
                v600[1] = 0;
                v213 = v586 + 1;
                v585 = 0;
                v577 = v575 & 8;
                while ( 1 )
                {
                  if ( *((_BYTE *)v582 + v15) == (_BYTE)v584 )
                  {
                    --v213;
                    IO_sputbackc(v5, (unsigned __int8)v15);
LABEL_630:
                    if ( !v585 )
                    {
                      if ( v586 == v213 )
                      {
                        v20 = 2;
                        goto LABEL_34;
                      }
                      v586 = v213;
                      v584 = 0;
                      if ( (v575 & 8) != 0 )
                        goto LABEL_23;
                      v226 = v580;
                      *(_DWORD *)v580 = 0;
                      v227 = v226 + 4;
                      v580 = v227;
                      if ( (v575 & 0x2100) != 0 )
                      {
                        _ECX = (int)v570;
                        v228 = (int)&v227[-*v570] >> 2;
                        if ( v228 != v567 )
                        {
                          realloc((_BYTE *)*v570, 4 * v228);
                          if ( v229 )
                            *v570 = v229;
                        }
                      }
                      goto LABEL_625;
                    }
LABEL_875:
                    v20 = 4;
                    __writegsdword(0xFFFFFFE8, 0x54u);
                    goto LABEL_34;
                  }
                  if ( !v577 )
                  {
                    LOBYTE(v594[0]) = v15;
                    if ( mbrtowc(v580, v594, 1, v600) == -2 )
                    {
                      if ( (unsigned int)++v585 >= *(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFDC) + 88) )
                        _assert_fail(
                          "cnt < (((uint32_t) (*_nl_current_LC_CTYPE)->values[((int) (_NL_CTYPE_MB_CUR_MAX) & 0xffff)].word))",
                          "vfscanf.c",
                          2589,
                          "_IO_vfscanf_internal");
                      goto LABEL_597;
                    }
                    v580 += 4;
                    v585 = 0;
                    if ( (v575 & 0x2100) != 0 )
                    {
                      v215 = (_BYTE *)*v570;
                      v571 = v567;
                      v572 = 4 * v567;
                      _ECX = v577;
                      v585 = v577;
                      if ( v580 == &v215[4 * v567] )
                      {
                        realloc(v215, 8 * v567);
                        if ( v216 )
                        {
                          _ECX = (int)v570;
                          v217 = (int *)v577;
                          v567 *= 2;
                          *v570 = v216;
                          v585 = (int)v217;
                          v580 = (char *)(v572 + v216);
                        }
                        else
                        {
                          ++v567;
                          realloc((_BYTE *)*v570, 4 * v567);
                          if ( !v303 )
                          {
                            if ( (v575 & 0x2000) != 0 )
                            {
                              v20 = 0;
                              v573 = -1;
                            }
                            else
                            {
                              ++v573;
                              v308 = *v570;
                              v570 = 0;
                              *(_DWORD *)(v308 + 4 * v571 - 4) = 0;
                              v20 = 2;
                            }
                            goto LABEL_34;
                          }
                          *v570 = v303;
                          v580 = (char *)(v572 + v303);
                        }
                      }
                    }
                  }
                  if ( !--v583 )
                    goto LABEL_630;
LABEL_597:
                  v214 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                  if ( (unsigned int)v214 >= *((_DWORD *)v5 + 2) )
                  {
                    v15 = _uflow((int *)v5);
                    if ( v15 == -1 )
                    {
                      v578 = __readgsdword(0xFFFFFFE8);
                      goto LABEL_630;
                    }
                  }
                  else
                  {
                    v15 = *v214;
                    *((_DWORD *)v5 + 1) = v214 + 1;
                  }
                  ++v213;
                }
              }
              v15 = _uflow(v93);
              if ( v15 != -1 )
                goto LABEL_593;
            }
            _ECX = v573;
            v20 = 1;
            if ( !v573 )
              v573 = -1;
            goto LABEL_34;
          }
          if ( v585 == -1 )
          {
            __writegsdword(0xFFFFFFE8, v578);
          }
          else
          {
            v218 = (unsigned __int8 *)v93[1];
            if ( (unsigned int)v218 < v93[2] )
            {
              v15 = *v218;
              v93[1] = (int)(v218 + 1);
LABEL_608:
              v219 = (_DWORD *)(v586 + 1);
              if ( *((_BYTE *)v582 + v15) == (_BYTE)v584 )
                goto LABEL_618;
              v577 = v575 & 0x2100;
              _ECX = v583;
              v572 = v575 & 8;
              v220 = (_DWORD *)(v586 + 1);
              while ( 1 )
              {
                if ( !v572 )
                {
                  v221 = v566;
                  *v566 = v15;
                  v566 = v221 + 1;
                  if ( v577 )
                  {
                    v222 = (_BYTE *)*v570;
                    if ( v566 == (char *)(*v570 + v567) )
                    {
                      v571 = (unsigned int)v220;
                      v585 = 2 * v567;
                      v583 = v567 + 1;
                      v257 = v572;
                      while ( 1 )
                      {
                        v554 = (char *)_ECX;
                        realloc(v222, v585);
                        _ECX = (int)v554;
                        if ( v258 )
                          break;
                        if ( v585 <= (unsigned int)v583 )
                        {
                          if ( (v575 & 0x2000) != 0 )
                          {
                            v20 = 0;
                            v573 = -1;
                          }
                          else
                          {
                            v283 = v570;
                            v20 = 2;
                            ++v573;
                            v570 = 0;
                            *(_BYTE *)(*v283 + v567 - 1) = 0;
                          }
                          goto LABEL_34;
                        }
                        v222 = (_BYTE *)*v570;
                        v585 = v583;
                      }
                      v572 = v257;
                      v220 = (_DWORD *)v571;
                      *v570 = v258;
                      v259 = (char *)(v567 + v258);
                      v567 = v585;
                      v566 = v259;
                    }
                  }
                }
                if ( --_ECX <= 0 )
                  break;
                v223 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                if ( (unsigned int)v223 >= *((_DWORD *)v5 + 2) )
                {
                  v553 = (char **)v220;
                  v554 = (char *)_ECX;
                  v404 = _uflow((int *)v5);
                  v220 = v553;
                  _ECX = (int)v554;
                  v15 = v404;
                  if ( v404 == -1 )
                  {
                    v213 = (int)v553;
                    v578 = __readgsdword(0xFFFFFFE8);
                    goto LABEL_619;
                  }
                }
                else
                {
                  v15 = *v223;
                  *((_DWORD *)v5 + 1) = v223 + 1;
                }
                v220 = (_DWORD *)((char *)v220 + 1);
                if ( *((_BYTE *)v582 + v15) == (_BYTE)v584 )
                {
                  v219 = v220;
LABEL_618:
                  v213 = (int)v219 - 1;
                  IO_sputbackc(v5, (unsigned __int8)v15);
LABEL_619:
                  if ( v586 == v213 )
                  {
                    v20 = 2;
                    goto LABEL_34;
                  }
                  v586 = v213;
                  v584 = 0;
                  if ( (v575 & 8) != 0 )
                    goto LABEL_23;
                  v224 = v566;
                  *v566 = 0;
                  v566 = v224 + 1;
                  if ( (v575 & 0x2100) != 0 && &v566[-*v570] != (char *)v567 )
                  {
                    realloc((_BYTE *)*v570, (unsigned int)&v566[-*v570]);
                    if ( v225 )
                    {
                      _ECX = (int)v570;
                      *v570 = v225;
                    }
                  }
LABEL_625:
                  ++v573;
                  v586 = v213;
                  v584 = 0;
                  v570 = 0;
                  goto LABEL_23;
                }
              }
              v213 = (int)v220;
              goto LABEL_619;
            }
            v15 = _uflow(v93);
            if ( v15 != -1 )
              goto LABEL_608;
          }
          v20 = 1;
          if ( !v573 )
            v573 = -1;
          goto LABEL_34;
        case 0x3Eu:
          if ( (v575 & 1) != 0 )
          {
LABEL_216:
            v72 = 1;
            if ( v583 != -1 )
              v72 = v583;
            v583 = v72;
            v585 = v575 & 8;
            if ( (v575 & 8) == 0 )
            {
              if ( (v575 & 0x2100) != 0 )
              {
                if ( v572 )
                {
                  v264 = &a4[v572 - 1];
                  if ( v572 == 1 )
                    v264 = a4;
                  v570 = (_DWORD *)*v264;
                }
                else
                {
                  v73 = (_DWORD *)*v568;
                  _ECX = (int)++v568;
                  v570 = v73;
                }
                if ( !v570 )
                {
                  v20 = 2;
                  goto LABEL_34;
                }
                v74 = 1024;
                if ( v583 <= 1024 )
                  v74 = v583;
                v567 = v74;
                v75 = (char *)malloc(4 * v74);
                v580 = v75;
                *v570 = v75;
                if ( !v75 )
                {
                  v271 = v575 & 0x2000;
                  v20 = v271 == 0 ? 2 : 0;
                  v51 = v271 == 0;
                  v272 = -1;
                  if ( v51 )
                    v272 = v573;
                  v573 = v272;
                  goto LABEL_34;
                }
                if ( !v564 || (v76 = *v564, v77 = *v564 + 1, *v564 == 32) )
                {
                  v77 = 1;
                  v544 = 0;
                  v545 = (int)v564;
                  v564 = &v544;
                  v76 = 0;
                }
                v78 = (int)v564;
                _ECX = (int)v570;
                *v564 = v77;
                *(_DWORD *)(v78 + 4 * v76 + 8) = _ECX;
              }
              else
              {
                if ( v572 )
                {
                  _ECX = v572;
                  v261 = (char **)&a4[v572 - 1];
                  if ( v572 == 1 )
                    v261 = (char **)a4;
                  v580 = *v261;
                }
                else
                {
                  v232 = (char *)*v568++;
                  v580 = v232;
                }
                if ( !v580 )
                {
                  v20 = 2;
                  goto LABEL_34;
                }
              }
            }
            if ( v15 == -1 )
            {
              __writegsdword(0xFFFFFFE8, v578);
            }
            else
            {
              v79 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
              if ( (unsigned int)v79 < *((_DWORD *)v5 + 2) )
              {
                v15 = *v79;
                *((_DWORD *)v5 + 1) = v79 + 1;
LABEL_232:
                ++v586;
                v594[0] = 0;
                v594[1] = 0;
                v584 = v575 & 0x2100;
                while ( 1 )
                {
                  LOBYTE(v592[0]) = v15;
                  if ( v585 )
                    goto LABEL_241;
                  if ( v584 )
                  {
                    v80 = (char *)*v570;
                    if ( v580 == (char *)(*v570 + 4 * v567) )
                    {
                      v553 = (char **)(4 * v567);
                      v546 = v80;
                      v580 = (char *)(v583 - 1);
                      v238 = (char *)v567;
                      if ( v583 < v567 )
                        v238 = v580;
                      v577 = (int)&v238[v567];
                      realloc(v546, 4 * (_DWORD)&v238[v567]);
                      v240 = (int)v553;
                      if ( v239 )
                      {
                        *v570 = v239;
                        v580 = (char *)(v240 + v239);
                        v567 = v577;
                      }
                      else
                      {
                        ++v567;
                        realloc((_BYTE *)*v570, 4 * v567);
                        v403 = (int)v553;
                        if ( !v402 )
                        {
                          v20 = 0;
                          v573 = -1;
                          goto LABEL_34;
                        }
                        *v570 = v402;
                        v580 = (char *)(v403 + v402);
                      }
                    }
                  }
                  v81 = v580;
                  if ( v585 )
                    goto LABEL_241;
                  while ( 1 )
                  {
                    v82 = mbrtowc(v81, v592, 1, v594);
                    if ( v82 != -2 )
                      break;
                    v83 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                    if ( (unsigned int)v83 >= *((_DWORD *)v5 + 2) )
                    {
                      v15 = _uflow((int *)v5);
                      if ( v15 == -1 )
                        goto LABEL_875;
                    }
                    else
                    {
                      v15 = *v83;
                      *((_DWORD *)v5 + 1) = v83 + 1;
                    }
                    ++v586;
                    LOBYTE(v592[0]) = v15;
                    v81 = v580;
                    if ( v585 )
LABEL_241:
                      v81 = 0;
                  }
                  if ( v82 != 1 )
                    goto LABEL_875;
                  --v583;
                  v580 += 4;
                  if ( v583 <= 0 )
                    goto LABEL_403;
                  v140 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                  if ( (unsigned int)v140 >= *((_DWORD *)v5 + 2) )
                  {
                    v15 = _uflow((int *)v5);
                    if ( v15 == -1 )
                    {
                      v578 = __readgsdword(0xFFFFFFE8);
LABEL_403:
                      v584 = 0;
                      if ( v585 )
                        goto LABEL_23;
                      if ( (v575 & 0x2100) != 0 )
                      {
                        _ECX = (int)v570;
                        v142 = (_BYTE *)*v570;
                        v143 = (int)&v580[-*v570] >> 2;
                        if ( v143 != v567 )
                        {
LABEL_406:
                          realloc(v142, 4 * v143);
                          if ( v144 )
                            *v570 = v144;
                        }
                      }
LABEL_408:
                      ++v573;
                      v584 = 0;
                      v570 = 0;
                      goto LABEL_23;
                    }
                  }
                  else
                  {
                    v15 = *v140;
                    *((_DWORD *)v5 + 1) = v140 + 1;
                  }
                  ++v586;
                }
              }
              v15 = _uflow((int *)v5);
              if ( v15 != -1 )
                goto LABEL_232;
            }
            v20 = 1;
            if ( !v573 )
              v573 = -1;
            goto LABEL_34;
          }
          v145 = 1;
          if ( v583 != -1 )
            v145 = v583;
          v583 = v145;
          v585 = v575 & 8;
          if ( (v575 & 8) == 0 )
          {
            if ( (v575 & 0x2100) != 0 )
            {
              if ( v572 )
              {
                v299 = &a4[v572 - 1];
                if ( v572 == 1 )
                  v299 = a4;
                v570 = (_DWORD *)*v299;
                v584 = (int)v568;
              }
              else
              {
                v146 = (_DWORD *)*v568;
                v584 = (int)(v568 + 1);
                v570 = v146;
              }
              _ECX = (int)v570;
              if ( !v570 )
              {
                v20 = 2;
                goto LABEL_34;
              }
              v147 = 1024;
              if ( v583 <= 1024 )
                v147 = v583;
              v567 = v147;
              v148 = (char *)malloc(v147);
              _ECX = (int)v570;
              v566 = v148;
              *v570 = v148;
              if ( !v148 )
              {
                v410 = v575 & 0x2000;
                v20 = v410 == 0 ? 2 : 0;
                v51 = v410 == 0;
                v411 = -1;
                if ( v51 )
                  v411 = v573;
                v573 = v411;
                goto LABEL_34;
              }
              if ( !v564 || (v149 = *v564, v150 = *v564 + 1, *v564 == 32) )
              {
                v544 = 0;
                v545 = (int)v564;
                v150 = 1;
                v564 = &v544;
                v149 = 0;
              }
              _ECX = (int)v564;
              v151 = v570;
              *v564 = v150;
              v152 = (int *)v584;
              *(_DWORD *)(_ECX + 4 * v149 + 8) = v151;
              v568 = v152;
            }
            else
            {
              if ( v572 )
              {
                _ECX = v572;
                v269 = &a4[v572 - 1];
                if ( v572 == 1 )
                  v269 = a4;
                v566 = (char *)*v269;
              }
              else
              {
                _ECX = *v568++;
                v566 = (char *)_ECX;
              }
              if ( !v566 )
              {
                v20 = 2;
                goto LABEL_34;
              }
            }
          }
          if ( v15 == -1 )
          {
            __writegsdword(0xFFFFFFE8, v578);
          }
          else
          {
            v153 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
            if ( (unsigned int)v153 < *((_DWORD *)v5 + 2) )
            {
              v15 = *v153;
              *((_DWORD *)v5 + 1) = v153 + 1;
              goto LABEL_436;
            }
            v15 = _uflow((int *)v5);
            if ( v15 != -1 )
            {
LABEL_436:
              v154 = v586 + 1;
              if ( !v585 )
              {
                ++v586;
                v155 = v567;
                v585 = v575 & 0x2100;
                v156 = v15;
                v157 = (int *)v5;
                v158 = v566;
                if ( (v575 & 0x2100) == 0 )
                  goto LABEL_439;
LABEL_438:
                v584 = v155;
                v159 = (char *)*v570;
                if ( v158 == (char *)(*v570 + v155) )
                {
                  v553 = (char **)v156;
                  v546 = v159;
                  v266 = v583 - 1;
                  if ( v583 > v155 )
                    v266 = v155;
                  v554 = (char *)(v155 + v266);
                  realloc(v546, v155 + v266);
                  v156 = (int)v553;
                  v268 = (unsigned int)v554;
                  if ( v267 )
                  {
                    *v570 = v267;
                    v158 = (char *)(v267 + v155);
                    v155 = v268;
                  }
                  else
                  {
                    v533 = v570;
                    realloc((_BYTE *)*v570, ++v155);
                    v156 = (int)v553;
                    if ( !v534 )
                    {
                      v5 = (char *)v157;
                      v20 = 0;
                      v573 = -1;
                      goto LABEL_34;
                    }
                    *v533 = v534;
                    v158 = (char *)(v534 + v584);
                  }
                }
LABEL_439:
                while ( 1 )
                {
                  v160 = --v583;
                  *v158++ = v156;
                  if ( v160 <= 0 )
                    break;
                  v161 = (unsigned __int8 *)v157[1];
                  if ( (unsigned int)v161 >= v157[2] )
                  {
                    v156 = _uflow(v157);
                    if ( v156 == -1 )
                    {
                      v566 = v158;
                      v5 = (char *)v157;
                      v15 = -1;
                      v567 = v155;
                      v578 = __readgsdword(0xFFFFFFE8);
                      goto LABEL_849;
                    }
                  }
                  else
                  {
                    v156 = *v161;
                    v157[1] = (int)(v161 + 1);
                  }
                  ++v586;
                  if ( v585 )
                    goto LABEL_438;
                }
                v566 = v158;
                v5 = (char *)v157;
                v15 = v156;
                v567 = v155;
LABEL_849:
                _ECX = v585;
                if ( v585 )
                {
                  v277 = v570;
                  if ( &v566[-*v570] != (char *)v567 )
                  {
                    realloc((_BYTE *)*v570, (unsigned int)&v566[-*v570]);
                    if ( v278 )
                      *v277 = v278;
                  }
                }
                goto LABEL_408;
              }
              v586 += v583;
              if ( v583 > 1 )
              {
                do
                {
                  v211 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                  if ( (unsigned int)v211 >= *((_DWORD *)v5 + 2) )
                  {
                    v15 = _uflow((int *)v5);
                    if ( v15 == -1 )
                    {
                      v578 = __readgsdword(0xFFFFFFE8);
                      break;
                    }
                  }
                  else
                  {
                    v15 = *v211;
                    *((_DWORD *)v5 + 1) = v211 + 1;
                  }
                  ++v154;
                }
                while ( v154 != v586 );
              }
              v586 = v154;
              v584 = 0;
              goto LABEL_23;
            }
          }
          v20 = 1;
          if ( !v573 )
            v573 = -1;
          goto LABEL_34;
        case 0x3Fu:
          v575 |= 0x40u;
          goto LABEL_139;
        case 0x44u:
          v575 |= 0x40u;
          v577 = 0;
          goto LABEL_140;
        case 0x49u:
          v584 = 0;
          if ( (v575 & 8) == 0 )
          {
            if ( (v575 & 2) != 0 )
            {
              if ( v572 )
              {
                _ECX = v572;
                v256 = &a4[v572 - 1];
                if ( v572 == 1 )
                  v256 = a4;
                v97 = (signed int *)*v256;
              }
              else
              {
                v97 = (signed int *)*v568++;
              }
              v98 = v586;
              v97[1] = 0;
              v584 = 0;
              *v97 = v98;
            }
            else if ( (v575 & 4) != 0 )
            {
              if ( v572 )
              {
                v296 = &a4[v572 - 1];
                if ( v572 == 1 )
                  v296 = a4;
                v254 = v568;
                v253 = (_WORD *)*v296;
              }
              else
              {
                v253 = (_WORD *)*v568;
                v254 = v568 + 1;
              }
              _ECX = (unsigned __int16)v586;
              v568 = v254;
              v584 = 0;
              *v253 = v586;
            }
            else if ( (v575 & 0x200) != 0 )
            {
              if ( v572 )
              {
                v407 = &a4[v572 - 1];
                if ( v572 == 1 )
                  v407 = a4;
                v298 = (_BYTE *)*v407;
              }
              else
              {
                v298 = (_BYTE *)*v568++;
              }
              _ECX = (unsigned __int8)v586;
              v584 = 0;
              *v298 = v586;
            }
            else
            {
              if ( v572 )
              {
                _ECX = v572;
                v462 = &a4[v572 - 1];
                if ( v572 == 1 )
                  v462 = a4;
                v250 = (signed int *)*v462;
              }
              else
              {
                v250 = (signed int *)*v568++;
              }
              v584 = 0;
              *v250 = v586;
            }
          }
          goto LABEL_23;
        case 0x4Au:
          v577 = 8;
          goto LABEL_140;
        case 0x4Bu:
          v575 &= 0xFFFFFFF9;
          v575 |= 0x1000u;
LABEL_188:
          v577 = 16;
          if ( v15 == -1 )
            goto LABEL_189;
          goto LABEL_141;
        case 0x4Eu:
          if ( (v575 & 1) != 0 )
          {
LABEL_193:
            v63 = v575 & 8;
            if ( (v575 & 8) == 0 )
            {
              if ( (v575 & 0x2100) != 0 )
              {
                _ECX = v572;
                if ( v572 )
                {
                  _ECX = v572;
                  v265 = &a4[v572 - 1];
                  if ( v572 == 1 )
                    v265 = a4;
                  v570 = (_DWORD *)*v265;
                }
                else
                {
                  v64 = (_DWORD *)*v568++;
                  v570 = v64;
                }
                if ( !v570 )
                {
                  v20 = 2;
                  goto LABEL_34;
                }
                v65 = (char *)malloc(400);
                _ECX = (int)v570;
                v580 = v65;
                *v570 = v65;
                if ( !v65 )
                {
                  v273 = v575 & 0x2000;
                  v20 = v273 == 0 ? 2 : 0;
                  v51 = v273 == 0;
                  v274 = -1;
                  if ( v51 )
                    v274 = v573;
                  v573 = v274;
                  goto LABEL_34;
                }
                if ( !v564 || (v66 = *v564, *v564 == 32) )
                {
                  v544 = 0;
                  v545 = (int)v564;
                  v564 = &v544;
                  v66 = 0;
                  v585 = 1;
                }
                else
                {
                  v585 = v66 + 1;
                }
                _ECX = (int)v564;
                v567 = 100;
                v564[v66 + 2] = (int)v570;
                *(_DWORD *)_ECX = v585;
              }
              else
              {
                if ( v572 )
                {
                  _ECX = v572;
                  v260 = (char **)&a4[v572 - 1];
                  if ( v572 == 1 )
                    v260 = (char **)a4;
                  v580 = *v260;
                }
                else
                {
                  v231 = (char *)*v568;
                  _ECX = (int)++v568;
                  v580 = v231;
                }
                if ( !v580 )
                {
                  v20 = 2;
                  goto LABEL_34;
                }
              }
            }
            if ( v15 == -1 )
            {
              __writegsdword(0xFFFFFFE8, v578);
            }
            else
            {
              v67 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
              if ( (unsigned int)v67 < *((_DWORD *)v5 + 2) )
              {
                v15 = *v67;
                *((_DWORD *)v5 + 1) = v67 + 1;
                goto LABEL_206;
              }
              v15 = _uflow((int *)v5);
              if ( v15 != -1 )
              {
LABEL_206:
                ++v586;
                v596[0] = 0;
                v68 = v574[13];
                v596[1] = 0;
                if ( (*(_BYTE *)(v68 + 2 * v15 + 1) & 0x20) == 0 )
                {
                  v585 = (int)v592;
                  v584 = v575 & 0x2100;
                  do
                  {
                    for ( LOBYTE(v592[0]) = v15; ; LOBYTE(v592[0]) = v15 )
                    {
                      v69 = 0;
                      if ( !v63 )
                        v69 = v580;
                      v70 = mbrtowc(v69, (_BYTE *)v585, 1, v596);
                      if ( v70 != -2 )
                        break;
                      v71 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                      if ( (unsigned int)v71 >= *((_DWORD *)v5 + 2) )
                      {
                        v15 = _uflow((int *)v5);
                        if ( v15 == -1 )
                          goto LABEL_875;
                      }
                      else
                      {
                        v15 = *v71;
                        *((_DWORD *)v5 + 1) = v71 + 1;
                      }
                      ++v586;
                    }
                    if ( v70 != 1 )
                      goto LABEL_875;
                    v580 += 4;
                    if ( !v63 )
                    {
                      if ( v584 )
                      {
                        v185 = (_BYTE *)*v570;
                        v577 = v567;
                        _ECX = (int)&v185[4 * v567];
                        if ( v580 == (char *)_ECX )
                        {
                          v553 = (char **)(4 * v567);
                          realloc(v185, 8 * v567);
                          v263 = (int)v553;
                          if ( v262 )
                          {
                            _ECX = (int)v570;
                            v567 *= 2;
                            *v570 = v262;
                            v580 = (char *)(v263 + v262);
                          }
                          else
                          {
                            ++v567;
                            realloc((_BYTE *)*v570, 4 * v567);
                            v456 = (int)v553;
                            if ( !v455 )
                            {
                              if ( (v575 & 0x2000) != 0 )
                              {
                                v20 = 0;
                                v573 = -1;
                              }
                              else
                              {
                                ++v573;
                                v459 = *v570;
                                v570 = 0;
                                *(_DWORD *)(v459 + 4 * v577 - 4) = 0;
                                v20 = 2;
                              }
                              goto LABEL_34;
                            }
                            _ECX = (int)v570;
                            *v570 = v455;
                            v580 = (char *)(v456 + v455);
                          }
                        }
                      }
                    }
                    if ( v583 > 0 && !--v583 )
                      goto LABEL_509;
                    v186 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                    if ( (unsigned int)v186 >= *((_DWORD *)v5 + 2) )
                    {
                      v15 = _uflow((int *)v5);
                      if ( v15 == -1 )
                      {
                        v578 = __readgsdword(0xFFFFFFE8);
LABEL_509:
                        v584 = 0;
                        if ( v63 )
                          goto LABEL_23;
                        v187 = v580;
                        *(_DWORD *)v580 = 0;
                        v188 = v187 + 4;
                        v580 = v188;
                        if ( (v575 & 0x2100) != 0 )
                        {
                          _ECX = (int)v570;
                          v142 = (_BYTE *)*v570;
                          v143 = (int)&v188[-*v570] >> 2;
                          if ( v143 != v567 )
                            goto LABEL_406;
                        }
                        goto LABEL_408;
                      }
                    }
                    else
                    {
                      v15 = *v186;
                      *((_DWORD *)v5 + 1) = v186 + 1;
                    }
                    ++v586;
                  }
                  while ( (*(_BYTE *)(v574[13] + 2 * v15 + 1) & 0x20) == 0 );
                }
                --v586;
                IO_sputbackc(v5, (unsigned __int8)v15);
                goto LABEL_509;
              }
            }
            v20 = 1;
            if ( !v573 )
              v573 = -1;
            goto LABEL_34;
          }
          v162 = (int *)(v575 & 8);
          if ( (v575 & 8) == 0 )
          {
            if ( (v575 & 0x2100) != 0 )
            {
              _ECX = v572;
              if ( v572 )
              {
                v291 = &a4[v572 - 1];
                _ECX = (int)v568;
                if ( v572 == 1 )
                  v291 = a4;
                v292 = (_DWORD *)*v291;
                v584 = (int)v568;
                v570 = v292;
              }
              else
              {
                v163 = (_DWORD *)*v568;
                v584 = (int)(v568 + 1);
                v570 = v163;
              }
              if ( !v570 )
              {
                v20 = 2;
                goto LABEL_34;
              }
              v164 = (char *)malloc(100);
              v566 = v164;
              *v570 = v164;
              if ( !v164 )
              {
                v399 = v575 & 0x2000;
                v20 = v399 == 0 ? 2 : 0;
                v51 = v399 == 0;
                v400 = -1;
                if ( v51 )
                  v400 = v573;
                v573 = v400;
                goto LABEL_34;
              }
              if ( !v564 || (v165 = *v564, *v564 == 32) )
              {
                v544 = 0;
                v545 = (int)v564;
                v564 = &v544;
                v165 = 0;
                v585 = 1;
              }
              else
              {
                v585 = v165 + 1;
              }
              v166 = v564;
              _ECX = (int)v570;
              v567 = 100;
              v564[v165 + 2] = (int)v570;
              *v166 = v585;
              v568 = (int *)v584;
            }
            else
            {
              if ( v572 )
              {
                _ECX = v572;
                v279 = &a4[v572 - 1];
                if ( v572 == 1 )
                  v279 = a4;
                v566 = (char *)*v279;
              }
              else
              {
                _ECX = *v568++;
                v566 = (char *)_ECX;
              }
              if ( !v566 )
              {
                v20 = 2;
                goto LABEL_34;
              }
            }
          }
          if ( v15 == -1 )
          {
            __writegsdword(0xFFFFFFE8, v578);
          }
          else
          {
            v167 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
            if ( (unsigned int)v167 < *((_DWORD *)v5 + 2) )
            {
              v15 = *v167;
              *((_DWORD *)v5 + 1) = v167 + 1;
LABEL_457:
              ++v586;
              if ( (*(_BYTE *)(v574[13] + 2 * v15 + 1) & 0x20) != 0 )
                goto LABEL_468;
              v585 = (int)v162;
              _ECX = (int)v566;
              v168 = v15;
              v169 = (int *)v5;
              v170 = v583;
              v584 = v575 & 0x2100;
              while ( 1 )
              {
                if ( !v585 )
                {
                  v171 = v584;
                  *(_BYTE *)_ECX++ = v168;
                  if ( v171 )
                  {
                    v172 = (_BYTE *)*v570;
                    v583 = v567;
                    if ( (_BYTE *)_ECX == &v172[v567] )
                    {
                      v553 = (char **)(2 * v567);
                      realloc(v172, 2 * v567);
                      v281 = (int)v553;
                      if ( v280 )
                      {
                        *v570 = v280;
                        v282 = v567;
                        v567 = v281;
                        _ECX = v280 + v282;
                      }
                      else
                      {
                        realloc((_BYTE *)*v570, ++v567);
                        if ( !v464 )
                        {
                          v5 = (char *)v169;
                          if ( (v575 & 0x2000) != 0 )
                          {
                            v20 = 0;
                            v573 = -1;
                          }
                          else
                          {
                            ++v573;
                            v470 = *v570;
                            v570 = 0;
                            *(_BYTE *)(v470 + v583 - 1) = 0;
                            v20 = 2;
                          }
                          goto LABEL_34;
                        }
                        v465 = v583;
                        *v570 = v464;
                        _ECX = v464 + v465;
                      }
                    }
                  }
                }
                if ( v170 > 0 && !--v170 )
                  break;
                v173 = (unsigned __int8 *)v169[1];
                if ( (unsigned int)v173 >= v169[2] )
                {
                  v554 = (char *)_ECX;
                  v463 = _uflow(v169);
                  _ECX = (int)v554;
                  v168 = v463;
                  if ( v463 == -1 )
                  {
                    v5 = (char *)v169;
                    v15 = -1;
                    v566 = v554;
                    v162 = (int *)v585;
                    v578 = __readgsdword(0xFFFFFFE8);
                    goto LABEL_469;
                  }
                }
                else
                {
                  v168 = *v173;
                  v169[1] = (int)(v173 + 1);
                }
                ++v586;
                if ( (*(_BYTE *)(v574[13] + 2 * v168 + 1) & 0x20) != 0 )
                {
                  v5 = (char *)v169;
                  v15 = v168;
                  v162 = (int *)v585;
                  v566 = (char *)_ECX;
LABEL_468:
                  --v586;
                  IO_sputbackc(v5, (unsigned __int8)v15);
LABEL_469:
                  v584 = 0;
                  if ( v162 )
                    goto LABEL_23;
                  v174 = v566;
                  *v566 = 0;
                  v566 = v174 + 1;
                  if ( (v575 & 0x2100) != 0 && &v566[-*v570] != (char *)v567 )
                  {
                    realloc((_BYTE *)*v570, (unsigned int)&v566[-*v570]);
                    if ( v175 )
                    {
                      _ECX = (int)v570;
                      *v570 = v175;
                    }
                  }
                  goto LABEL_408;
                }
              }
              v5 = (char *)v169;
              v15 = v168;
              v162 = (int *)v585;
              v566 = (char *)_ECX;
              goto LABEL_469;
            }
            v15 = _uflow((int *)v5);
            if ( v15 != -1 )
              goto LABEL_457;
          }
          v20 = 1;
          if ( !v573 )
            v573 = -1;
          goto LABEL_34;
        case 0x50u:
LABEL_139:
          v577 = 10;
LABEL_140:
          if ( v15 == -1 )
          {
LABEL_189:
            __writegsdword(0xFFFFFFE8, v578);
          }
          else
          {
LABEL_141:
            v53 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
            if ( (unsigned int)v53 < *((_DWORD *)v5 + 2) )
            {
              v15 = *v53;
              *((_DWORD *)v5 + 1) = v53 + 1;
LABEL_143:
              v584 = v586 + 1;
              if ( v15 == 43 || (_ECX = 0, v15 == 45) )
              {
                if ( !v581 )
                {
                  if ( v569 )
                  {
                    realloc(v582, 0x100u);
                    if ( !v540 )
                      goto LABEL_1198;
                    v582 = v540;
                    v581 = 256;
                  }
                  else
                  {
                    v582 = &v541;
                    v581 = 256;
                  }
                }
                *(_BYTE *)v582 = v15;
                v583 -= v583 > 0;
                v62 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                if ( (unsigned int)v62 >= *((_DWORD *)v5 + 2) )
                {
                  v15 = _uflow((int *)v5);
                  if ( v15 == -1 )
                  {
                    _ECX = 1;
                    v578 = __readgsdword(0xFFFFFFE8);
                    goto LABEL_184;
                  }
                }
                else
                {
                  v15 = *v62;
                  *((_DWORD *)v5 + 1) = v62 + 1;
                }
                _ECX = 1;
                v584 = v586 + 2;
                if ( v15 != 48 )
                  goto LABEL_184;
              }
              else if ( v15 != 48 )
              {
                goto LABEL_184;
              }
              if ( v583 )
              {
                v583 -= v583 > 0;
                if ( v581 == _ECX )
                {
                  if ( v569 )
                  {
                    v554 = (char *)_ECX;
                    realloc(v582, 0x100u);
                    _ECX = (int)v554;
                    if ( !v539 )
                      goto LABEL_1198;
                    v582 = v539;
                    v581 = 256;
                  }
                  else
                  {
                    LOWORD(v15) = 256;
                    if ( v582 == &v546 )
                      v15 = v581 + 256;
                    if ( v582 )
                    {
                      v554 = (char *)_ECX;
                      memcpy(&v541, v582, v581);
                      _ECX = (int)v554;
                    }
                    v581 = v15;
                    v582 = &v541;
                  }
                }
                *((_BYTE *)v582 + _ECX) = 48;
                v54 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                ++_ECX;
                if ( (unsigned int)v54 >= *((_DWORD *)v5 + 2) )
                {
                  v554 = (char *)_ECX;
                  v469 = _uflow((int *)v5);
                  _ECX = (int)v554;
                  v15 = v469;
                  if ( v469 == -1 )
                  {
                    v578 = __readgsdword(0xFFFFFFE8);
                    goto LABEL_151;
                  }
                }
                else
                {
                  v15 = *v54;
                  *((_DWORD *)v5 + 1) = v54 + 1;
                }
                ++v584;
LABEL_151:
                if ( v583 && *(_DWORD *)(v574[14] + 4 * (unsigned __int8)v15) == 120 )
                {
                  if ( !v577 || v577 == 16 )
                  {
                    v583 -= v583 > 0;
                    if ( v15 == -1 )
                    {
                      v577 = 16;
                      __writegsdword(0xFFFFFFE8, v578);
                      goto LABEL_155;
                    }
                    v230 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                    if ( (unsigned int)v230 >= *((_DWORD *)v5 + 2) )
                    {
                      v554 = (char *)_ECX;
                      v408 = _uflow((int *)v5);
                      _ECX = (int)v554;
                      v15 = v408;
                      if ( v408 == -1 )
                      {
                        v577 = 16;
                        v578 = __readgsdword(0xFFFFFFE8);
                        goto LABEL_155;
                      }
                    }
                    else
                    {
                      v15 = *v230;
                      *((_DWORD *)v5 + 1) = v230 + 1;
                    }
                    ++v584;
                    v577 = 16;
                    goto LABEL_155;
                  }
                }
                else if ( !v577 )
                {
                  v577 = 8;
                  goto LABEL_155;
                }
                goto LABEL_393;
              }
LABEL_184:
              if ( !v577 )
              {
LABEL_185:
                if ( (v575 & 0x400) != 0 )
                {
                  v554 = (char *)_ECX;
                  v318 = (char *)wctrans("to_inpunct");
                  v319 = (signed int)v554;
                  v320 = *(_DWORD *)(v558 + 112);
                  v563 = v318;
                  v586 = v320;
                  v557 = v320 - 1;
                  if ( v318 )
                  {
                    v577 = v15;
                    v381 = v5;
                    v560 = (unsigned int)v587;
                    v571 = (unsigned int)v554;
                    v557 = v586;
                    for ( k = 48; k != 58; ++k )
                    {
                      v383 = v563;
                      v384 = *(_BYTE **)(v558 + 4 * k - 76);
                      *(_DWORD *)(v560 + 4 * k - 192) = v384;
                      v385 = towctrans(k, v383);
                      v597[0] = 0;
                      v597[1] = 0;
                      v585 = wcrtomb(v594, v385, v597);
                      if ( v585 == -1 )
                      {
                        v5 = v381;
                        v319 = v571;
                        v15 = v577;
                        v563 = 0;
                        goto LABEL_993;
                      }
                      v386 = 0;
                      v387 = v384;
                      if ( v586 <= 0 )
                      {
                        v556 = 0;
                      }
                      else
                      {
                        do
                        {
                          v553 = (char **)v386;
                          v388 = rawmemchr(v387, 0);
                          v386 = (int)v553 + 1;
                          v387 = (_BYTE *)(v388 + 1);
                        }
                        while ( (char **)((char *)v553 + 1) != (char **)v586 );
                        v556 = v387 - v384;
                      }
                      v562 = v556 + v585 + 31;
                      v389 = alloca(16 * (v562 / 0x10));
                      v553 = (char **)v550;
                      v390 = mempcpy(v550, v384, v556);
                      *(_BYTE *)mempcpy(v390, v594, v585) = 0;
                      *(_DWORD *)&v587[4 * k + 60] = v553;
                    }
                    v5 = v381;
                    v319 = v571;
                    v15 = v577;
                  }
LABEL_993:
                  v561 = 0;
                  v586 = v319;
                  v556 = v575 & 0x80;
                  while ( 1 )
                  {
                    if ( !v583 || v15 == -1 )
                      goto LABEL_1138;
                    v571 = (unsigned int)v5;
                    v321 = 0;
                    v585 = 0;
                    v577 = (int)v587;
                    do
                    {
                      v322 = 0x7FFFFFFF;
                      if ( v583 > 0 )
                        v322 = v583;
                      v562 = v322;
                      if ( v563 )
                        v323 = (char *)v592[(_DWORD)v321];
                      else
                        v323 = *(char **)(v558 + 4 * (_DWORD)v321 + 116);
                      *(_DWORD *)(v577 + 4 * (_DWORD)v321) = v323;
                      if ( v561 )
                      {
                        v324 = (int)v323;
                        v325 = v15;
                        v326 = v321;
                        v327 = 0;
                        do
                        {
                          ++v327;
                          v324 = rawmemchr(v324, 0) + 1;
                          v51 = v327 == v561;
                          *(_DWORD *)(v577 + 4 * (_DWORD)v326) = v324;
                        }
                        while ( !v51 );
                        v321 = v326;
                        v15 = v325;
                        v323 = (char *)v324;
                      }
                      v328 = *v323;
                      if ( v15 != (unsigned __int8)*v323 )
                        goto LABEL_1015;
                      if ( !v323[1] )
                        goto LABEL_1136;
                      v329 = v321;
                      ++v323;
                      v5 = (char *)v571;
                      do
                      {
                        v331 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                        if ( (unsigned int)v331 < *((_DWORD *)v5 + 2) )
                        {
                          v330 = *v331;
                          *((_DWORD *)v5 + 1) = v331 + 1;
                        }
                        else
                        {
                          v330 = _uflow((int *)v5);
                          if ( v330 == -1 )
                          {
                            v321 = v329;
                            v15 = -1;
                            v578 = __readgsdword(0xFFFFFFE8);
                            v328 = *v323;
                            goto LABEL_1015;
                          }
                        }
                        v328 = *v323;
                        ++v584;
                        --v562;
                        if ( v328 != v330 )
                        {
                          v321 = v329;
                          v15 = v330;
LABEL_1015:
                          if ( v328 )
                            goto LABEL_1016;
LABEL_1136:
                          v585 = (int)v321;
                          v5 = (char *)v571;
LABEL_1132:
                          v380 = v562;
                          if ( v583 <= 0 )
                            v380 = v583;
                          v583 = v380;
                          goto LABEL_1130;
                        }
                        if ( !*++v323 )
                        {
                          v585 = (int)v329;
                          goto LABEL_1132;
                        }
                      }
                      while ( v562 );
                      v321 = v329;
                      v15 = v330;
LABEL_1016:
                      v332 = *(_DWORD *)(v577 + 4 * (_DWORD)v321);
                      if ( (unsigned int)v323 > v332 )
                      {
                        if ( v15 != -1 )
                        {
                          v553 = *(char ***)(v577 + 4 * (_DWORD)v321);
                          --v584;
                          IO_sputbackc((_DWORD *)v571, (unsigned __int8)v15);
                          v332 = (unsigned int)v553;
                        }
                        v333 = (unsigned int)(v323 - 1);
                        v334 = v323;
                        v335 = (int)(v323 - 1);
                        if ( v332 < (unsigned int)(v323 - 1) )
                        {
                          while ( 1 )
                          {
                            v336 = (unsigned __int8)*(v334 - 1);
                            v553 = (char **)v332;
                            v554 = (char *)v333;
                            IO_sputbackc((_DWORD *)v571, v336);
                            v332 = (unsigned int)v553;
                            v585 = v335 - 1;
                            v333 = (unsigned int)v554;
                            if ( (char **)(v335 - 1) == v553 )
                              break;
                            v334 = (char *)v335;
                            v335 = v585;
                          }
                          v584 += v335 - (_DWORD)v323;
                          v323 = &v554[(char *)v553 - v323 + 2];
                        }
                        v15 = (unsigned __int8)*(v323 - 1);
                      }
                      v337 = rawmemchr(v332, 0);
                      *(_DWORD *)(v577 + 4 * (_DWORD)v321) = v337 + 1;
                      v321 = (int *)((char *)v321 + 1);
                    }
                    while ( v321 != (int *)10 );
                    v5 = (char *)v571;
                    v562 = v561 + 1;
                    if ( v557 < (int)(v561 + 1) )
                      goto LABEL_1050;
LABEL_1027:
                    v585 = 0;
                    while ( 1 )
                    {
                      v338 = 0x7FFFFFFF;
                      if ( v583 > 0 )
                        v338 = v583;
                      v339 = *(unsigned __int8 **)(v577 + 4 * v585);
                      v340 = *v339;
                      if ( v15 == *v339 )
                        break;
                      v341 = *(_BYTE **)(v577 + 4 * v585);
LABEL_1038:
                      if ( !v340 )
                        goto LABEL_1127;
LABEL_1039:
                      v571 = *(_DWORD *)(v577 + 4 * v585);
                      if ( (unsigned int)v341 > v571 )
                      {
                        if ( v15 != -1 )
                        {
                          --v584;
                          IO_sputbackc(v5, (unsigned __int8)v15);
                        }
                        v343 = v341 - 1;
                        v344 = v341;
                        v560 = (unsigned int)(v341 - 1);
                        if ( v571 < (unsigned int)(v341 - 1) )
                        {
                          while ( 1 )
                          {
                            IO_sputbackc(v5, (unsigned __int8)*(v344 - 1));
                            if ( v343 - 1 == (_BYTE *)v571 )
                              break;
                            v344 = v343--;
                          }
                          v584 += v343 - v341;
                          v341 = (_BYTE *)(v571 - (_DWORD)v341 + v560 + 2);
                        }
                        v15 = (unsigned __int8)*(v341 - 1);
                      }
                      v345 = rawmemchr(v571, 0);
                      v346 = v585;
                      *(_DWORD *)(v577 + 4 * v585) = v345 + 1;
                      v585 = v346 + 1;
                      if ( v346 == 9 )
                      {
                        if ( v557 < (int)++v562 )
                        {
LABEL_1050:
                          if ( v556 )
                          {
                            v347 = 0x7FFFFFFF;
                            v348 = *v579;
                            if ( v583 > 0 )
                              v347 = v583;
                            v577 = v347;
                            if ( v15 != v348 )
                            {
                              v360 = v579;
                              v349 = v582;
LABEL_1072:
                              if ( v348 )
                              {
                                _ECX = v586;
                                v368 = v349;
                                v369 = (unsigned int)v360;
                                v582 = v368;
                                goto LABEL_1096;
                              }
LABEL_1073:
                              v361 = v577;
                              if ( v583 <= 0 )
                                v361 = v583;
                              --v586;
                              v583 = v361;
                              goto LABEL_1076;
                            }
                            v571 = (unsigned int)v579;
                            v349 = v582;
                            v585 = v15;
                            while ( 2 )
                            {
                              if ( v581 == v586 )
                              {
                                v355 = 2 * v586;
                                if ( (unsigned int)(2 * v586) < 0x100 )
                                  v355 = 256;
                                v356 = v349;
                                if ( v569 )
                                {
LABEL_1115:
                                  realloc(v356, v355);
                                  if ( !v377 )
                                  {
                                    v378 = v349;
                                    v20 = 0;
                                    v582 = 0;
                                    v573 = -1;
                                    if ( !v569 )
                                      goto LABEL_34;
LABEL_1120:
                                    free(v378);
                                    v20 = (int)v582;
                                    goto LABEL_34;
                                  }
                                  if ( v569 )
                                  {
                                    v581 = v355;
                                    v349 = v377;
                                  }
                                  else
                                  {
                                    v553 = v377;
                                    memcpy(v377, v349, v586);
                                    v581 = v355;
                                    v569 = 1;
                                    v349 = v553;
                                  }
                                }
                                else
                                {
                                  if ( v355 > 0x1000 && !_libc_alloca_cutoff(v355) )
                                  {
                                    v356 = 0;
                                    goto LABEL_1115;
                                  }
                                  v357 = (v355 + 15) & 0xFFFFFFF0;
                                  v358 = v357 + v581;
                                  v359 = alloca(16 * ((v357 + 30) / 0x10));
                                  if ( v349 != (char **)&v550[v357] )
                                    v358 = (v355 + 15) & 0xFFFFFFF0;
                                  if ( v349 )
                                  {
                                    v547 = (unsigned int *)v349;
                                    v349 = (char **)v550;
                                    v553 = (char **)v358;
                                    memcpy(v550, v547, v581);
                                    v581 = (unsigned int)v553;
                                  }
                                  else
                                  {
                                    v581 = v358;
                                    v349 = (char **)v550;
                                  }
                                }
                              }
                              v350 = v586;
                              v351 = v571;
                              *((_BYTE *)v349 + v586) = v585;
                              v586 = v350 + 1;
                              v352 = (_DWORD *)(v351 + 1);
                              if ( !*(_BYTE *)(v571 + 1) )
                              {
                                v15 = v585;
                                goto LABEL_1073;
                              }
                              if ( !v577 )
                              {
                                v376 = v349;
                                _ECX = v586;
                                v369 = (unsigned int)v352;
                                v582 = v376;
                                v15 = v585;
LABEL_1096:
                                v577 = 10;
                                if ( (unsigned int)v579 < v369 )
                                {
                                  _ECX += (int)&v579[-v369];
                                  if ( v15 != -1 )
                                  {
                                    v554 = (char *)_ECX;
                                    --v584;
                                    IO_sputbackc(v5, (unsigned __int8)v15);
                                    _ECX = (int)v554;
                                  }
                                  v370 = v369 - 1;
                                  v371 = v369;
                                  v372 = v369 - 1;
                                  if ( (unsigned int)v579 < v369 - 1 )
                                  {
                                    while ( 1 )
                                    {
                                      v373 = *(unsigned __int8 *)(v371 - 1);
                                      v553 = (char **)v370;
                                      v554 = (char *)_ECX;
                                      IO_sputbackc(v5, v373);
                                      v370 = (int)v553;
                                      v586 = v372 - 1;
                                      _ECX = (int)v554;
                                      if ( (_BYTE *)(v372 - 1) == v579 )
                                        break;
                                      v371 = v372;
                                      v372 = v586;
                                    }
                                    v584 += v372 - v369;
                                    v369 = (unsigned int)&v579[(_DWORD)v553 - v369 + 2];
                                  }
                                  v15 = *(unsigned __int8 *)(v369 - 1);
                                  v577 = 10;
                                }
                                goto LABEL_162;
                              }
                              v353 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                              if ( (unsigned int)v353 >= *((_DWORD *)v5 + 2) )
                              {
                                v585 = _uflow((int *)v5);
                                if ( v585 == -1 )
                                {
                                  v360 = v352;
                                  v15 = -1;
                                  v578 = __readgsdword(0xFFFFFFE8);
                                  v348 = *(_BYTE *)(v571 + 1);
                                  goto LABEL_1072;
                                }
                              }
                              else
                              {
                                v354 = *v353;
                                *((_DWORD *)v5 + 1) = v353 + 1;
                                v585 = v354;
                              }
                              v348 = *(_BYTE *)v352;
                              ++v584;
                              --v577;
                              if ( v348 != v585 )
                              {
                                v360 = v352;
                                v15 = v585;
                                goto LABEL_1072;
                              }
                              v571 = (unsigned int)v352;
                              continue;
                            }
                          }
LABEL_1138:
                          _ECX = v586;
                          v577 = 10;
                          goto LABEL_162;
                        }
                        goto LABEL_1027;
                      }
                    }
                    v341 = v339 + 1;
                    if ( v339[1] )
                    {
                      while ( 1 )
                      {
                        v342 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                        if ( (unsigned int)v342 >= *((_DWORD *)v5 + 2) )
                        {
                          v553 = (char **)v338;
                          v379 = _uflow((int *)v5);
                          v338 = (int)v553;
                          v15 = v379;
                          if ( v379 == -1 )
                          {
                            v578 = __readgsdword(0xFFFFFFE8);
                            v340 = *v341;
                            goto LABEL_1038;
                          }
                        }
                        else
                        {
                          v15 = *v342;
                          *((_DWORD *)v5 + 1) = v342 + 1;
                        }
                        v340 = *v341;
                        --v338;
                        ++v584;
                        if ( v340 != v15 )
                          goto LABEL_1038;
                        if ( !*++v341 )
                          break;
                        if ( !v338 )
                          goto LABEL_1039;
                      }
                    }
LABEL_1127:
                    if ( v583 <= 0 )
                      v338 = v583;
                    v583 = v338;
                    v561 = v562;
LABEL_1130:
                    v349 = v582;
                    v15 = v585 + 48;
                    v557 = v561;
LABEL_1076:
                    if ( v581 != v586 )
                    {
                      v582 = v349;
                      goto LABEL_1078;
                    }
                    v364 = 2 * v586;
                    if ( (unsigned int)(2 * v586) < 0x100 )
                      v364 = 256;
                    v365 = v349;
                    if ( v569 )
                    {
LABEL_1107:
                      v553 = (char **)v364;
                      realloc(v365, v364);
                      v582 = v375;
                      if ( !v375 )
                      {
                        v378 = v349;
                        v20 = 0;
                        v573 = -1;
                        if ( !v569 )
                          goto LABEL_34;
                        goto LABEL_1120;
                      }
                      v581 = (unsigned int)v553;
                      if ( !v569 )
                      {
                        memcpy(v582, v349, v586);
                        v569 = 1;
                      }
                    }
                    else
                    {
                      if ( v364 > 0x1000 )
                      {
                        v553 = (char **)v364;
                        v374 = _libc_alloca_cutoff(v364);
                        v364 = (unsigned int)v553;
                        if ( !v374 )
                        {
                          v365 = 0;
                          goto LABEL_1107;
                        }
                      }
                      v366 = (v364 + 15) & 0xFFFFFFF0;
                      v367 = alloca(v366 + 16);
                      v582 = (char **)&v550[v366];
                      if ( v349 == (char **)&v550[v366] )
                        v366 += v581;
                      if ( v349 )
                      {
                        v553 = (char **)v366;
                        v554 = v550;
                        memcpy(v550, v349, v581);
                        v581 = (unsigned int)v553;
                        v582 = (char **)v554;
                      }
                      else
                      {
                        v581 = v366;
                        v582 = (char **)v550;
                      }
                    }
LABEL_1078:
                    v362 = v586;
                    *((_BYTE *)v582 + v586) = v15;
                    v586 = v362 + 1;
                    v583 -= v583 > 0;
                    if ( v15 == -1 )
                    {
                      __writegsdword(0xFFFFFFE8, v578);
                    }
                    else
                    {
                      v363 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                      if ( (unsigned int)v363 < *((_DWORD *)v5 + 2) )
                      {
                        v15 = *v363;
                        *((_DWORD *)v5 + 1) = v363 + 1;
                        goto LABEL_1081;
                      }
                      v15 = _uflow((int *)v5);
                      if ( v15 == -1 )
                        v578 = __readgsdword(0xFFFFFFE8);
                      else
LABEL_1081:
                        ++v584;
                    }
                  }
                }
                v577 = 10;
LABEL_155:
                v55 = (int *)v5;
                v56 = v15;
                v57 = v55;
                v571 = v575 & 0x80;
                while ( 1 )
                {
                  if ( !v583 || v56 == -1 )
                  {
LABEL_161:
                    v58 = v57;
                    v15 = v56;
                    v5 = (char *)v58;
                    goto LABEL_162;
                  }
                  if ( v577 != 16 )
                    break;
                  if ( (*(_BYTE *)(v574[13] + 2 * v56 + 1) & 0x10) == 0 )
                    goto LABEL_161;
LABEL_328:
                  if ( v581 == _ECX )
                  {
                    v287 = 2 * _ECX;
                    if ( (unsigned int)(2 * _ECX) < 0x100 )
                      v287 = 256;
                    v288 = v582;
                    if ( v569 )
                      goto LABEL_896;
                    if ( v287 > 0x1000 )
                    {
                      v554 = (char *)_ECX;
                      v294 = _libc_alloca_cutoff(v287);
                      _ECX = (int)v554;
                      if ( !v294 )
                      {
                        v288 = 0;
LABEL_896:
                        v554 = (char *)_ECX;
                        realloc(v288, v287);
                        _ECX = (int)v554;
                        v290 = v295;
                        if ( !v295 )
                        {
                          v5 = (char *)v57;
                          if ( v569 )
                          {
                            v20 = 0;
                            free(v582);
                            v582 = 0;
                          }
                          else
                          {
                            v582 = 0;
                            v20 = 0;
                          }
                          v573 = -1;
                          goto LABEL_34;
                        }
                        if ( !v569 )
                        {
                          v553 = v295;
                          memcpy(v295, v582, (unsigned int)v554);
                          v581 = v287;
                          _ECX = (int)v554;
                          v569 = 1;
                          v582 = v553;
                          goto LABEL_329;
                        }
LABEL_893:
                        v581 = v287;
                        v582 = v290;
                        goto LABEL_329;
                      }
                    }
                    v287 = (v287 + 15) & 0xFFFFFFF0;
                    v289 = alloca(v287 + 16);
                    v290 = (char **)v550;
                    v585 = (int)&v550[v287];
                    v586 = v287 + v581;
                    if ( v582 == (char **)&v550[v287] )
                      v287 = v586;
                    if ( !v582 )
                      goto LABEL_893;
                    v553 = (char **)v550;
                    v554 = (char *)_ECX;
                    memcpy(v550, v582, v581);
                    v581 = v287;
                    _ECX = (int)v554;
                    v582 = v553;
                  }
LABEL_329:
                  v116 = v583;
                  *((_BYTE *)v582 + _ECX++) = v56;
                  v583 -= v116 > 0;
                  if ( v56 == -1 )
                  {
                    __writegsdword(0xFFFFFFE8, v578);
                  }
                  else
                  {
                    v117 = (unsigned __int8 *)v57[1];
                    if ( (unsigned int)v117 < v57[2] )
                    {
                      v56 = *v117;
                      v57[1] = (int)(v117 + 1);
                      goto LABEL_332;
                    }
                    v554 = (char *)_ECX;
                    v286 = _uflow(v57);
                    _ECX = (int)v554;
                    v56 = v286;
                    if ( v286 == -1 )
                      v578 = __readgsdword(0xFFFFFFE8);
                    else
LABEL_332:
                      ++v584;
                  }
                }
                if ( (unsigned int)(v56 - 48) <= 9 )
                {
                  if ( v56 - 47 > v577 )
                    goto LABEL_161;
                  goto LABEL_328;
                }
                if ( v577 != 10 || !v571 )
                  goto LABEL_161;
                v118 = 0x7FFFFFFF;
                v119 = *v579;
                if ( v583 > 0 )
                  v118 = v583;
                v585 = v118;
                if ( v56 != v119 )
                {
                  v113 = (unsigned int)v579;
                  if ( v119 )
                  {
LABEL_354:
                    v127 = v57;
                    v15 = v56;
                    v5 = (char *)v127;
                    if ( (unsigned int)v579 < v113 )
                    {
                      _ECX += (int)&v579[-v113];
                      if ( v15 != -1 )
                      {
                        v553 = (char **)v113;
                        v554 = (char *)_ECX;
                        --v584;
                        IO_sputbackc(v127, (unsigned __int8)v15);
                        _ECX = (int)v554;
                        v113 = (unsigned int)v553;
                      }
                      v128 = v113 - 1;
                      v586 = v113 - 1;
                      if ( (unsigned int)v579 < v113 - 1 )
                      {
                        v129 = v113;
                        v585 = _ECX;
                        while ( 1 )
                        {
                          IO_sputbackc(v5, *(unsigned __int8 *)(v113 - 1));
                          if ( (_BYTE *)(v128 - 1) == v579 )
                            break;
                          v113 = v128--;
                        }
                        _ECX = v585;
                        v584 += v128 - v129;
                        v113 = (unsigned int)&v579[v586 - v129 + 2];
                      }
                      v15 = *(unsigned __int8 *)(v113 - 1);
                      if ( !_ECX )
                      {
LABEL_363:
                        if ( v15 == 40 && (v575 & 0x1000) != 0 )
                        {
                          v130 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                          v131 = v574[14];
                          if ( (unsigned int)v130 < *((_DWORD *)v5 + 2) )
                          {
                            v15 = *v130;
                            *((_DWORD *)v5 + 1) = v130 + 1;
                            goto LABEL_367;
                          }
                          v15 = _uflow((int *)v5);
                          if ( v15 == -1 )
                          {
                            v578 = __readgsdword(0xFFFFFFE8);
                            v132 = 1020;
                          }
                          else
                          {
LABEL_367:
                            ++v584;
                            v132 = 4 * (unsigned __int8)v15;
                          }
                          if ( *(_DWORD *)(v131 + v132) == 110 )
                          {
                            _ECX = (int)v574;
                            v133 = v574[14];
                            if ( v15 == -1 )
                            {
                              __writegsdword(0xFFFFFFE8, v578);
                              v135 = 1020;
                            }
                            else
                            {
                              v134 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                              if ( (unsigned int)v134 < *((_DWORD *)v5 + 2) )
                              {
                                v15 = *v134;
                                *((_DWORD *)v5 + 1) = v134 + 1;
                                goto LABEL_372;
                              }
                              v15 = _uflow((int *)v5);
                              if ( v15 == -1 )
                              {
                                v578 = __readgsdword(0xFFFFFFE8);
                                v135 = 1020;
                              }
                              else
                              {
LABEL_372:
                                ++v584;
                                _ECX = v15;
                                v135 = 4 * (unsigned __int8)v15;
                              }
                            }
                            if ( *(_DWORD *)(v133 + v135) == 105 )
                            {
                              v136 = v574[14];
                              if ( v15 == -1 )
                              {
                                __writegsdword(0xFFFFFFE8, v578);
                                v138 = 1020;
                              }
                              else
                              {
                                v137 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                                if ( (unsigned int)v137 < *((_DWORD *)v5 + 2) )
                                {
                                  v15 = *v137;
                                  *((_DWORD *)v5 + 1) = v137 + 1;
                                  goto LABEL_377;
                                }
                                v15 = _uflow((int *)v5);
                                if ( v15 == -1 )
                                {
                                  v578 = __readgsdword(0xFFFFFFE8);
                                  v138 = 1020;
                                }
                                else
                                {
LABEL_377:
                                  ++v584;
                                  _ECX = v15;
                                  v138 = 4 * (unsigned __int8)v15;
                                }
                              }
                              if ( *(_DWORD *)(v136 + v138) == 108 )
                              {
                                if ( v15 == -1 )
                                {
                                  v20 = 2;
                                  __writegsdword(0xFFFFFFE8, v578);
                                  goto LABEL_34;
                                }
                                v139 = (unsigned __int8 *)*((_DWORD *)v5 + 1);
                                if ( (unsigned int)v139 >= *((_DWORD *)v5 + 2) )
                                {
                                  v15 = _uflow((int *)v5);
                                  if ( v15 == -1 )
                                  {
                                    v20 = 2;
                                    goto LABEL_34;
                                  }
                                }
                                else
                                {
                                  v15 = *v139;
                                  *((_DWORD *)v5 + 1) = v139 + 1;
                                }
                                if ( v15 == 41 )
                                {
                                  if ( v581 )
                                    goto LABEL_384;
                                  if ( !v569 )
                                  {
                                    v582 = &v541;
                                    v581 = 256;
                                    goto LABEL_384;
                                  }
                                  realloc(v582, 0x100u);
                                  if ( v394 )
                                  {
                                    v582 = v394;
                                    v581 = 256;
LABEL_384:
                                    _ECX = 1;
                                    v586 = v584 + 1;
                                    *(_BYTE *)v582 = 48;
LABEL_166:
                                    if ( v581 != _ECX )
                                    {
                                      v20 = (int)v582;
                                      goto LABEL_168;
                                    }
                                    v311 = 2 * _ECX;
                                    if ( (unsigned int)(2 * _ECX) < 0x100 )
                                      v311 = 256;
                                    v312 = v582;
                                    if ( v569 )
                                    {
LABEL_983:
                                      v553 = (char **)v311;
                                      v554 = (char *)_ECX;
                                      realloc(v312, v311);
                                      v313 = (unsigned int)v553;
                                      _ECX = (int)v554;
                                      v20 = (int)v317;
                                      if ( !v317 )
                                      {
                                        if ( v569 )
                                        {
                                          free(v582);
                                          v582 = 0;
                                        }
                                        else
                                        {
                                          v582 = 0;
                                          v20 = 0;
                                        }
                                        v573 = -1;
                                        goto LABEL_34;
                                      }
                                      if ( v569 )
                                        goto LABEL_980;
                                      memcpy(v317, v582, (unsigned int)v554);
                                      v582 = (char **)v20;
                                      _ECX = (int)v554;
                                      v569 = 1;
                                      v581 = (unsigned int)v553;
                                    }
                                    else
                                    {
                                      if ( v311 > 0x1000 )
                                      {
                                        v553 = (char **)v311;
                                        v554 = (char *)_ECX;
                                        v316 = _libc_alloca_cutoff(v311);
                                        v311 = (unsigned int)v553;
                                        _ECX = (int)v554;
                                        if ( !v316 )
                                        {
                                          v312 = 0;
                                          goto LABEL_983;
                                        }
                                      }
                                      v313 = (v311 + 15) & 0xFFFFFFF0;
                                      v314 = alloca(v313 + 16);
                                      v20 = (int)v550;
                                      v584 = (int)&v550[v313];
                                      v585 = v313 + v581;
                                      if ( v582 == (char **)&v550[v313] )
                                        v313 = v585;
                                      if ( v582 )
                                      {
                                        v553 = (char **)v313;
                                        v554 = (char *)_ECX;
                                        memcpy(v550, v582, v581);
                                        v582 = (char **)v550;
                                        _ECX = (int)v554;
                                        v581 = (unsigned int)v553;
                                        goto LABEL_168;
                                      }
LABEL_980:
                                      v581 = v313;
                                      v582 = (char **)v20;
                                    }
LABEL_168:
                                    v59 = (int *)(v575 & 2);
                                    *((_BYTE *)v582 + _ECX) = 0;
                                    v585 = (int)v59;
                                    if ( v59 )
                                    {
                                      v549 = v575 & 0x80;
                                      v547 = v601;
                                      v548 = v577;
                                      v546 = (char *)v20;
                                      if ( (v575 & 0x40) != 0 )
                                        v60 = _strtoll_internal(v546, (char **)v547, v548, v549);
                                      else
                                        v60 = _strtoull_internal(v546, (char **)v547, v548, v549);
                                      _ECX = HIDWORD(v60);
                                      HIDWORD(v60) = v60;
                                      v555 = _ECX;
                                    }
                                    else
                                    {
                                      v549 = v575 & 0x80;
                                      v547 = v601;
                                      v548 = v577;
                                      v546 = (char *)v20;
                                      if ( (v575 & 0x40) != 0 )
                                        HIDWORD(v60) = _strtol_internal(v546, (char **)v547, v548, v549);
                                      else
                                        HIDWORD(v60) = _strtoul_internal(v546, (char **)v547, v548, v549);
                                    }
                                    if ( v582 == (char **)v601[0] )
                                    {
                                      v20 = 2;
                                      goto LABEL_34;
                                    }
                                    v584 = 0;
                                    if ( (v575 & 8) != 0 )
                                      goto LABEL_23;
                                    if ( (v575 & 0x40) != 0 )
                                    {
                                      if ( v585 )
                                      {
                                        _ECX = v572;
                                        if ( v572 )
                                        {
                                          _ECX = v572;
                                          v241 = &a4[v572 - 1];
                                          if ( v572 == 1 )
                                            v241 = a4;
                                          LODWORD(v60) = *v241;
                                        }
                                        else
                                        {
                                          v61 = v568++;
                                          LODWORD(v60) = *v61;
                                        }
                                        *(_DWORD *)v60 = HIDWORD(v60);
                                        *(_DWORD *)(v60 + 4) = v555;
LABEL_179:
                                        ++v573;
                                        v584 = 0;
                                        goto LABEL_23;
                                      }
                                      if ( (v575 & 4) == 0 )
                                      {
                                        if ( (v575 & 0x200) != 0 )
                                        {
                                          if ( v572 )
                                          {
                                            _ECX = v572;
                                            LODWORD(v60) = &a4[v572 - 1];
                                            if ( v572 == 1 )
                                              LODWORD(v60) = a4;
                                            **(_BYTE **)v60 = BYTE4(v60);
                                          }
                                          else
                                          {
                                            LODWORD(v60) = v568++;
                                            **(_BYTE **)v60 = BYTE4(v60);
                                          }
                                          goto LABEL_179;
                                        }
LABEL_658:
                                        if ( v572 )
                                        {
                                          _ECX = v572;
                                          LODWORD(v60) = &a4[v572 - 1];
                                          if ( v572 == 1 )
                                            LODWORD(v60) = a4;
                                          **(_DWORD **)v60 = HIDWORD(v60);
                                        }
                                        else
                                        {
                                          LODWORD(v60) = v568++;
                                          **(_DWORD **)v60 = HIDWORD(v60);
                                        }
                                        goto LABEL_179;
                                      }
                                    }
                                    else
                                    {
                                      if ( v585 )
                                      {
                                        if ( v572 )
                                        {
                                          _ECX = (int)a4;
                                          v249 = &a4[v572 - 1];
                                          if ( v572 == 1 )
                                            v249 = a4;
                                          LODWORD(v60) = *v249;
                                        }
                                        else
                                        {
                                          LODWORD(v60) = *v568;
                                          _ECX = (int)++v568;
                                        }
                                        v141 = v555;
                                        *(_DWORD *)v60 = HIDWORD(v60);
                                        *(_DWORD *)(v60 + 4) = v141;
                                        goto LABEL_179;
                                      }
                                      if ( (v575 & 4) == 0 )
                                      {
                                        if ( (v575 & 0x200) != 0 )
                                        {
                                          if ( v572 )
                                          {
                                            _ECX = (int)a4;
                                            LODWORD(v60) = &a4[v572 - 1];
                                            if ( v572 == 1 )
                                              LODWORD(v60) = a4;
                                            **(_BYTE **)v60 = BYTE4(v60);
                                          }
                                          else
                                          {
                                            LODWORD(v60) = *v568;
                                            _ECX = (int)++v568;
                                            *(_BYTE *)v60 = BYTE4(v60);
                                          }
                                          goto LABEL_179;
                                        }
                                        goto LABEL_658;
                                      }
                                    }
                                    if ( v572 )
                                    {
                                      _ECX = v572;
                                      v248 = &a4[v572 - 1];
                                      if ( v572 == 1 )
                                        v248 = a4;
                                      LODWORD(v60) = *v248;
                                    }
                                    else
                                    {
                                      v209 = v568++;
                                      LODWORD(v60) = *v209;
                                    }
                                    *(_WORD *)v60 = WORD2(v60);
                                    goto LABEL_179;
                                  }
LABEL_1198:
                                  v20 = 0;
                                  free(v582);
                                  v582 = 0;
                                  v573 = -1;
                                  goto LABEL_34;
                                }
LABEL_571:
                                v20 = 2;
                                IO_sputbackc(v5, (unsigned __int8)v15);
                                goto LABEL_34;
                              }
                            }
                          }
                        }
LABEL_570:
                        if ( v15 == -1 )
                        {
                          v20 = 2;
                          goto LABEL_34;
                        }
                        goto LABEL_571;
                      }
LABEL_163:
                      if ( _ECX != 1 || *(_BYTE *)v582 != 45 && *(_BYTE *)v582 != 43 )
                      {
                        v586 = v584;
                        if ( v15 != -1 )
                        {
                          v554 = (char *)_ECX;
                          v586 = v584 - 1;
                          IO_sputbackc(v5, (unsigned __int8)v15);
                          _ECX = (int)v554;
                        }
                        goto LABEL_166;
                      }
                      goto LABEL_570;
                    }
LABEL_162:
                    if ( !_ECX )
                      goto LABEL_363;
                    goto LABEL_163;
                  }
                  goto LABEL_325;
                }
                v586 = (signed int)v579;
                if ( v581 == _ECX )
                  goto LABEL_345;
                while ( 1 )
                {
                  while ( 1 )
                  {
                    do
                    {
LABEL_339:
                      v120 = v586;
                      v121 = v586;
                      *((_BYTE *)v582 + _ECX++) = v56;
                      v113 = v120 + 1;
                      if ( !*(_BYTE *)(v121 + 1) )
                        goto LABEL_325;
                      if ( !v585 )
                        goto LABEL_354;
                      v122 = (unsigned __int8 *)v57[1];
                      if ( (unsigned int)v122 >= v57[2] )
                      {
                        v553 = (char **)v113;
                        v554 = (char *)_ECX;
                        v112 = _uflow(v57);
                        v113 = (unsigned int)v553;
                        _ECX = (int)v554;
                        v56 = v112;
                        if ( v112 == -1 )
                        {
                          v578 = __readgsdword(0xFFFFFFE8);
                          v114 = *(_BYTE *)(v586 + 1);
LABEL_324:
                          if ( v114 )
                            goto LABEL_354;
LABEL_325:
                          v115 = v585;
                          if ( v583 <= 0 )
                            v115 = v583;
                          --_ECX;
                          v583 = v115;
                          goto LABEL_328;
                        }
                      }
                      else
                      {
                        v56 = *v122;
                        v57[1] = (int)(v122 + 1);
                      }
                      v114 = *(_BYTE *)v113;
                      ++v584;
                      --v585;
                      if ( v114 != v56 )
                        goto LABEL_324;
                      v586 = v113;
                    }
                    while ( v581 != _ECX );
LABEL_345:
                    v123 = 2 * _ECX;
                    if ( (unsigned int)(2 * _ECX) < 0x100 )
                      v123 = 256;
                    v124 = v582;
                    if ( !v569 )
                      break;
LABEL_348:
                    v554 = (char *)_ECX;
                    realloc(v124, v123);
                    _ECX = (int)v554;
                    v126 = v125;
                    if ( !v125 )
                    {
                      v5 = (char *)v57;
                      if ( v569 )
                      {
                        v20 = 0;
                        free(v582);
                        v582 = 0;
                      }
                      else
                      {
                        v582 = 0;
                        v20 = 0;
                      }
                      v573 = -1;
                      goto LABEL_34;
                    }
                    if ( v569 )
                    {
LABEL_350:
                      v581 = v123;
                      v582 = v126;
                      goto LABEL_339;
                    }
                    v553 = v125;
                    memcpy(v125, v582, (unsigned int)v554);
                    v581 = v123;
                    _ECX = (int)v554;
                    v569 = 1;
                    v582 = v553;
                  }
                  if ( v123 > 0x1000 )
                  {
                    v554 = (char *)_ECX;
                    v424 = _libc_alloca_cutoff(v123);
                    _ECX = (int)v554;
                    if ( !v424 )
                    {
                      v124 = 0;
                      goto LABEL_348;
                    }
                  }
                  v560 = (v123 + 15) & 0xFFFFFFF0;
                  v563 = (char *)(v560 + 30);
                  v251 = alloca(16 * ((v560 + 30) / 0x10));
                  v126 = (char **)v550;
                  v123 = v560;
                  if ( v582 == (char **)&v550[v560] )
                    v123 = v560 + v581;
                  if ( !v582 )
                    goto LABEL_350;
                  v553 = (char **)v550;
                  v554 = (char *)_ECX;
                  memcpy(v550, v582, v581);
                  v581 = v123;
                  _ECX = (int)v554;
                  v582 = v553;
                }
              }
LABEL_393:
              if ( v577 != 10 )
                goto LABEL_155;
              goto LABEL_185;
            }
            v15 = _uflow((int *)v5);
            if ( v15 != -1 )
              goto LABEL_143;
          }
          v20 = 1;
          if ( !v573 )
            v573 = -1;
          goto LABEL_34;
        default:
          goto LABEL_70;
      }
    }
    break;
  }
  v20 = 1;
  if ( !v573 )
    v573 = -1;
LABEL_34:
  if ( (BYTE1(*(_DWORD *)v5) & 0x80u) != 0 )
  {
LABEL_35:
    if ( !v559 )
      goto LABEL_36;
LABEL_117:
    MEMORY[0](v593, 0);
    if ( v569 )
LABEL_118:
      free(v582);
LABEL_37:
    if ( a5 )
      *a5 |= v20;
    if ( v573 == -1 )
    {
      if ( v564 )
      {
        v466 = v564;
        do
        {
          v467 = 0;
          if ( *v466 )
          {
            do
            {
              free(*(_DWORD *)v466[v467 + 2]);
              v468 = (_DWORD *)v466[v467++ + 2];
              v193 = *v466 <= v467;
              *v468 = 0;
            }
            while ( !v193 );
          }
          v466 = (int *)v466[1];
        }
        while ( v466 );
      }
    }
    else if ( v570 )
    {
      v392 = v570;
      free(*v570);
      *v392 = 0;
    }
    return;
  }
LABEL_112:
  v48 = (_DWORD *)*((_DWORD *)v5 + 18);
  v51 = v48[1]-- == 1;
  if ( !v51 )
    goto LABEL_35;
  v48[2] = 0;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v51 = (*v48)-- == 1;
  if ( v51 )
  {
    if ( v559 )
      goto LABEL_117;
LABEL_36:
    if ( v569 )
      goto LABEL_118;
    goto LABEL_37;
  }
  L_unlock_1211(_ECX, v48);
}
// 809D0BE: conditional instruction was optimized away because dl.1==27
// 809D0C3: conditional instruction was optimized away because dl.1==27
// 809F69D: conditional instruction was optimized away because esi.4!=FFFFFFFF
// 809FA11: conditional instruction was optimized away because esi.4!=FFFFFFFF
// 809E085: variable 'v125' is possibly undefined
// 809E42E: variable 'v144' is possibly undefined
// 809E900: variable 'v175' is possibly undefined
// 809F251: variable 'v216' is possibly undefined
// 809F3E9: variable 'v225' is possibly undefined
// 809F4F0: variable 'v229' is possibly undefined
// 809F98A: variable 'v239' is possibly undefined
// 80A0005: variable 'v258' is possibly undefined
// 80A016E: variable 'v262' is possibly undefined
// 80A02A6: variable 'v267' is possibly undefined
// 80A049E: variable 'v278' is possibly undefined
// 80A04F3: variable 'v280' is possibly undefined
// 80A0871: variable 'v295' is possibly undefined
// 80A0A8D: variable 'v301' is possibly undefined
// 80A0B29: variable 'v302' is possibly undefined
// 80A0BF2: variable 'v303' is possibly undefined
// 80A0D9E: variable 'v310' is possibly undefined
// 80A0FCD: variable 'v317' is possibly undefined
// 80A190C: variable 'v375' is possibly undefined
// 80A19AE: variable 'v377' is possibly undefined
// 80A1DC8: variable 'v394' is possibly undefined
// 80A1ECB: variable 'v398' is possibly undefined
// 80A205A: variable 'v401' is possibly undefined
// 80A20A1: variable 'v402' is possibly undefined
// 80A2248: variable 'v409' is possibly undefined
// 80A255C: variable 'v419' is possibly undefined
// 80A261A: variable 'v421' is possibly undefined
// 80A26F8: variable 'v423' is possibly undefined
// 80A2CF8: variable 'v455' is possibly undefined
// 80A2D47: variable 'v458' is possibly undefined
// 80A2DFC: variable 'v461' is possibly undefined
// 80A2FAC: variable 'v464' is possibly undefined
// 80A31BF: variable 'v476' is possibly undefined
// 80A33D2: variable 'v478' is possibly undefined
// 80A3401: variable 'v479' is possibly undefined
// 80A3588: variable 'v480' is possibly undefined
// 80A364F: variable 'v482' is possibly undefined
// 80A3756: variable 'v483' is possibly undefined
// 80A384D: variable 'v486' is possibly undefined
// 80A3BD9: variable 'v504' is possibly undefined
// 80A3C3E: variable 'v505' is possibly undefined
// 80A3F5E: variable 'v519' is possibly undefined
// 80A3FE9: variable 'v520' is possibly undefined
// 80A41BB: variable 'v528' is possibly undefined
// 80A4344: variable 'v534' is possibly undefined
// 80A43AD: variable 'v536' is possibly undefined
// 80A4512: variable 'v538' is possibly undefined
// 80A4673: variable 'v539' is possibly undefined
// 80A46A2: variable 'v540' is possibly undefined
// 809D1D4: variable '_ECX' is possibly undefined
// 8048230: using guessed type int __cdecl rawmemchr(_DWORD, _DWORD);
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 807F7A0: using guessed type _DWORD __cdecl wcrtomb(_DWORD, _DWORD, _DWORD);
// 809CAF0: using guessed type char var_DE[17];

//----- (080A4750) --------------------------------------------------------
void __usercall vfscanf(long double a1@<st0>, char *a2, unsigned __int8 *a3, int *a4)
{
  IO_vfscanf_internal(a1, a2, a3, a4, 0);
}

//----- (080A477B) --------------------------------------------------------
void __fastcall L_unlock_1211(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x809D1DA);
}
// 80A4782: control flows out of bounds to 809D1DA

//----- (080A4787) --------------------------------------------------------
void __usercall L_lock_1267(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x809D243);
}
// 80A478E: control flows out of bounds to 809D243

//----- (080A47A0) --------------------------------------------------------
int __cdecl IO_helper_overflow_0(int a1, int a2)
{
  int v2; // edi
  _DWORD *v3; // eax
  int v4; // edx
  int v5; // ebx
  int *v6; // edx
  int v8; // eax
  int v9; // ebp

  v2 = a2;
  v3 = *(_DWORD **)(a1 + 88);
  v4 = v3[3];
  v5 = (v3[4] - v4) >> 2;
  if ( v5 )
  {
    v8 = (*(int (__cdecl **)(_DWORD, int, int))(*(_DWORD *)(*(_DWORD *)(a1 + 340) + 148) + 28))(
           *(_DWORD *)(a1 + 340),
           v4,
           v5);
    if ( (unsigned int)(v8 - 1) > 0xFFFFFFFD )
      return -1;
    v9 = 4 * v8;
    wmemmove(
      *(void **)(*(_DWORD *)(a1 + 88) + 12),
      (const void *)(*(_DWORD *)(*(_DWORD *)(a1 + 88) + 12) + 4 * v8),
      v5 - v8);
    v3 = *(_DWORD **)(a1 + 88);
    v3[4] -= v9;
  }
  if ( v3 )
  {
    v6 = (int *)v3[4];
    if ( (unsigned int)v6 < v3[5] )
    {
      *v6 = a2;
      v3[4] = v6 + 1;
      return v2;
    }
  }
  return _woverflow(a1, a2);
}

//----- (080A4870) --------------------------------------------------------
void __usercall vfwprintf(int a1@<edi>, long double a2@<st0>, _DWORD *a3, wchar_t *s, int *a5)
{
  _DWORD *v5; // ebx
  int v6; // esi
  unsigned int v8; // esi
  bool v10; // zf
  unsigned int v11; // esi
  int v12; // ecx
  _DWORD *v13; // edx
  int *v14; // edi
  int *v15; // ecx
  unsigned int v16; // edi
  unsigned int v17; // eax
  size_t v18; // edi
  char *v19; // edi
  int v20; // eax
  int *v21; // edi
  int v22; // eax
  int *v23; // ecx
  unsigned int v24; // ecx
  void *v25; // esp
  _BYTE *v26; // edx
  void *v27; // ebx
  void *v28; // edx
  unsigned int v29; // eax
  size_t v30; // edi
  void *v31; // esp
  _BYTE *v32; // eax
  int v33; // eax
  int *v34; // ecx
  _DWORD *v35; // edi
  int *v36; // esi
  int j; // ebx
  int v38; // edx
  int v39; // eax
  int v40; // eax
  int v41; // eax
  int v42; // ecx
  int v43; // edi
  double *v44; // ebx
  double *v45; // eax
  int v46; // eax
  double *v47; // eax
  int v48; // edx
  int v49; // eax
  int v50; // eax
  int v51; // edx
  char *v52; // eax
  char v53; // al
  int *v54; // ecx
  unsigned __int8 v55; // dl
  char v56; // di
  char v57; // al
  int v58; // edi
  int v59; // eax
  int v60; // eax
  int v61; // eax
  int v62; // edx
  int v63; // eax
  int v64; // eax
  size_t v65; // edi
  void *v66; // esp
  int v67; // eax
  void *v68; // esp
  _DWORD *v69; // edx
  int k; // eax
  int v71; // eax
  char *v72; // edi
  unsigned int v73; // edx
  int v74; // edi
  unsigned int v75; // edx
  int v76; // ecx
  int v77; // edx
  int *v78; // eax
  unsigned int v79; // edx
  int *v80; // eax
  int *v81; // edx
  int v82; // eax
  int v83; // eax
  int v84; // edi
  unsigned int v85; // edx
  char *v86; // eax
  int v87; // ecx
  int v88; // edx
  int *v89; // eax
  unsigned int v90; // edx
  int v91; // eax
  char *v92; // eax
  unsigned int *v93; // eax
  unsigned int v94; // edx
  unsigned int v95; // eax
  int *v96; // edi
  int v97; // eax
  int v98; // eax
  int v99; // eax
  int v100; // edx
  _DWORD *v101; // eax
  unsigned int v102; // edx
  int v103; // eax
  int v104; // eax
  char *v105; // eax
  int v106; // eax
  int v107; // edx
  _DWORD *v108; // eax
  unsigned int v109; // edx
  int v110; // eax
  int v111; // eax
  int *v112; // ecx
  unsigned int v113; // edx
  int *v114; // eax
  int v115; // eax
  int v116; // eax
  unsigned int v117; // eax
  unsigned int v118; // et2
  int v119; // edx
  _DWORD *v120; // eax
  int v121; // edx
  _DWORD *v122; // eax
  int v123; // edx
  _DWORD *v124; // eax
  int v125; // ecx
  int v126; // edx
  _DWORD *v127; // eax
  int *v128; // eax
  unsigned int v129; // ecx
  unsigned int v130; // eax
  char *v131; // edx
  double v132; // rax
  int v133; // ecx
  int v134; // edx
  _DWORD *v135; // eax
  unsigned int v136; // eax
  unsigned int v137; // eax
  int v138; // edx
  _DWORD *v139; // eax
  int v140; // edx
  _DWORD *v141; // eax
  int v142; // ecx
  unsigned int v143; // edx
  int v144; // edx
  _DWORD *v145; // eax
  _BOOL4 v146; // eax
  unsigned int v147; // eax
  int v148; // eax
  char v149; // bl
  _BOOL4 v150; // eax
  int *v151; // edi
  unsigned int v152; // eax
  int v153; // edx
  int v154; // ecx
  unsigned int v155; // eax
  int *v156; // edx
  int v157; // ecx
  int v158; // ecx
  void *v159; // esp
  int *i; // eax
  int v161; // edx
  int v162; // eax
  unsigned int v163; // eax
  unsigned int v164; // eax
  int v165; // eax
  void *v166; // esp
  int *v167; // edx
  int v168; // ecx
  unsigned int v169; // eax
  int v170; // eax
  int v171; // edi
  _BYTE *v172; // eax
  _BYTE *v173; // edx
  char v174; // al
  _BYTE *v175; // eax
  unsigned int v176; // eax
  int v177; // edx
  void *v178; // esp
  int v179; // eax
  unsigned int v180; // eax
  _BOOL4 v181; // eax
  _BYTE *v182; // eax
  void *v183; // esp
  int v184; // esi
  char *v185; // eax
  wchar_t *v186; // edx
  size_t v187; // eax
  const char *v188; // edx
  unsigned int v189; // edi
  int *v190; // ecx
  int v191; // eax
  int v192; // eax
  int v193; // eax
  unsigned int v194; // edx
  size_t v195; // edi
  void *v196; // esp
  _BYTE *v197; // edx
  int v198; // eax
  _BYTE *v199; // eax
  int v200; // edx
  unsigned int v201; // edi
  void *v202; // esp
  int v203; // edx
  _DWORD *v204; // eax
  char v205; // al
  int v206; // edx
  _DWORD *v207; // eax
  int v208; // edx
  _DWORD *v209; // eax
  int v210; // edx
  _DWORD *v211; // eax
  int v212; // edx
  _DWORD *v213; // eax
  int v214; // edx
  _DWORD *v215; // eax
  unsigned int v216; // eax
  int *v217; // ecx
  unsigned int v218; // et2
  int v219; // eax
  _DWORD *v220; // edx
  int v221; // esi
  int v222; // edx
  _DWORD *v223; // eax
  unsigned int v224; // eax
  int *v225; // ecx
  unsigned int v226; // et2
  int v227; // eax
  _DWORD *v228; // edx
  int v229; // esi
  int v230; // ecx
  int v231; // edx
  _DWORD *v232; // eax
  int v233; // edx
  _DWORD *v234; // eax
  int v235; // edx
  _DWORD *v236; // eax
  int v237; // eax
  int v238; // eax
  unsigned int v239; // eax
  int v240; // edx
  _DWORD *v241; // eax
  double v242; // rax
  int *v243; // edi
  int v244; // eax
  unsigned int v245; // eax
  unsigned int v246; // eax
  int v247; // edx
  _DWORD *v248; // eax
  unsigned int v249; // edx
  int v250; // eax
  int v251; // eax
  int v252; // edx
  _DWORD *v253; // eax
  unsigned int v254; // edx
  int v255; // eax
  int v256; // eax
  int v257; // eax
  int v258; // edx
  _DWORD *v259; // eax
  int v260; // edx
  _DWORD *v261; // eax
  int v262; // edx
  unsigned int *v263; // eax
  unsigned int v264; // ecx
  int v265; // edx
  _DWORD *v266; // eax
  int v267; // edx
  _DWORD *v268; // eax
  unsigned int v269; // edx
  int v270; // edx
  _DWORD *v271; // eax
  int v272; // edx
  unsigned int *v273; // eax
  unsigned int v274; // ecx
  int v275; // edx
  _DWORD *v276; // eax
  char *v277; // edx
  char *v278; // eax
  unsigned int v279; // eax
  double v280; // rax
  int v281; // ecx
  int v282; // edx
  unsigned int v283; // ecx
  int v284; // eax
  int *v285; // ecx
  unsigned int v286; // edx
  int *v287; // eax
  int v288; // eax
  int v289; // eax
  unsigned int v290; // eax
  unsigned int v291; // et2
  int v292; // ecx
  int v293; // eax
  int v294; // edx
  _DWORD *v295; // eax
  int v296; // eax
  char *v297; // eax
  double v298; // rax
  char *v299; // eax
  int v300; // eax
  int v301; // eax
  _BOOL4 v302; // edi
  int v303; // eax
  unsigned int v304; // edi
  int *v305; // eax
  double v306; // rax
  int v307; // ecx
  char *v308; // eax
  wchar_t *v309; // edx
  size_t v310; // eax
  const char *v311; // edx
  unsigned int v312; // edi
  int *v313; // ecx
  int *v314; // eax
  int v315; // eax
  int v316; // eax
  unsigned int v317; // edx
  size_t v318; // edi
  void *v319; // esp
  _BYTE *v320; // edx
  int v321; // eax
  _BYTE *v322; // eax
  unsigned int v323; // eax
  int v324; // edi
  unsigned int v325; // edx
  int v326; // eax
  int v327; // edx
  int v328; // ecx
  int *v329; // eax
  unsigned int v330; // eax
  double v331; // rax
  int v332; // ecx
  size_t v333; // eax
  _WORD *v334; // eax
  int v335; // edi
  unsigned int v336; // edx
  char *v337; // eax
  int v338; // eax
  int v339; // edx
  int v340; // ecx
  int *v341; // eax
  int v342; // edx
  int v343; // ecx
  int *v344; // eax
  char *v345; // eax
  int v346; // eax
  size_t v347; // eax
  _QWORD *v348; // eax
  int v349; // eax
  int v350; // edx
  int v351; // ecx
  int *v352; // eax
  char *v353; // eax
  int v354; // [esp-68Ch] [ebp-17D4h]
  _BYTE v355[1692]; // [esp-670h] [ebp-17B8h] BYREF
  unsigned int v356; // [esp+2Ch] [ebp-111Ch]
  int *v357; // [esp+30h] [ebp-1118h]
  unsigned int v358; // [esp+34h] [ebp-1114h]
  _BOOL4 v359; // [esp+38h] [ebp-1110h]
  int *v360; // [esp+3Ch] [ebp-110Ch]
  char v361; // [esp+43h] [ebp-1105h]
  _BOOL4 v362; // [esp+44h] [ebp-1104h]
  size_t v363; // [esp+48h] [ebp-1100h]
  _BOOL4 v364; // [esp+4Ch] [ebp-10FCh]
  int v365; // [esp+50h] [ebp-10F8h]
  _BOOL4 v366; // [esp+54h] [ebp-10F4h]
  _BOOL4 v367; // [esp+58h] [ebp-10F0h]
  int v368; // [esp+5Ch] [ebp-10ECh]
  unsigned int v369; // [esp+60h] [ebp-10E8h]
  _BOOL4 v370; // [esp+64h] [ebp-10E4h]
  unsigned int v371; // [esp+68h] [ebp-10E0h]
  unsigned int v372; // [esp+6Ch] [ebp-10DCh]
  int v373; // [esp+70h] [ebp-10D8h]
  int v374; // [esp+74h] [ebp-10D4h]
  int v375; // [esp+78h] [ebp-10D0h]
  int v376; // [esp+7Ch] [ebp-10CCh]
  int v377; // [esp+80h] [ebp-10C8h]
  int v378; // [esp+84h] [ebp-10C4h]
  int v379; // [esp+88h] [ebp-10C0h]
  int v380; // [esp+8Ch] [ebp-10BCh]
  int v381; // [esp+90h] [ebp-10B8h]
  unsigned int v382; // [esp+94h] [ebp-10B4h]
  __int64 v383; // [esp+98h] [ebp-10B0h]
  unsigned int v384; // [esp+A0h] [ebp-10A8h]
  int *v385; // [esp+A4h] [ebp-10A4h]
  int v386; // [esp+A8h] [ebp-10A0h]
  int v387; // [esp+ACh] [ebp-109Ch]
  char v388; // [esp+B0h] [ebp-1098h]
  unsigned int v389; // [esp+C0h] [ebp-1088h]
  unsigned int v390; // [esp+C4h] [ebp-1084h]
  double *v391; // [esp+C8h] [ebp-1080h]
  unsigned int v392; // [esp+CCh] [ebp-107Ch]
  int v393; // [esp+D0h] [ebp-1078h]
  int *v394; // [esp+D4h] [ebp-1074h]
  unsigned int v395; // [esp+D8h] [ebp-1070h]
  int v396; // [esp+DCh] [ebp-106Ch]
  void *src; // [esp+E0h] [ebp-1068h]
  _BYTE *v398; // [esp+E4h] [ebp-1064h]
  int v399; // [esp+E8h] [ebp-1060h]
  signed int v400; // [esp+ECh] [ebp-105Ch]
  int *v401; // [esp+F0h] [ebp-1058h]
  unsigned int v402; // [esp+F4h] [ebp-1054h]
  unsigned int v403; // [esp+F8h] [ebp-1050h]
  char *v404; // [esp+FCh] [ebp-104Ch]
  char v405[4000]; // [esp+108h] [ebp-1040h] BYREF
  char v406[48]; // [esp+10A8h] [ebp-A0h] BYREF
  int v407[5]; // [esp+10D8h] [ebp-70h] BYREF
  int v408[4]; // [esp+10ECh] [ebp-5Ch] BYREF
  double v409; // [esp+10FCh] [ebp-4Ch] BYREF
  int v410; // [esp+1104h] [ebp-44h]
  double v411; // [esp+1108h] [ebp-40h] BYREF
  int v412; // [esp+1110h] [ebp-38h]
  char v413[8]; // [esp+1114h] [ebp-34h] BYREF
  char v414[8]; // [esp+111Ch] [ebp-2Ch] BYREF
  double *v415; // [esp+1124h] [ebp-24h] BYREF
  long double *v416; // [esp+1128h] [ebp-20h] BYREF
  unsigned int v417[7]; // [esp+112Ch] [ebp-1Ch] BYREF
  int savedregs; // [esp+1148h] [ebp+0h] BYREF

  v5 = a3;
  v400 = __readgsdword(0xFFFFFFE8);
  if ( IO_fwide((int)a3, 1) == 1 )
  {
    if ( (*a3 & 8) != 0 )
    {
      *a3 |= 0x20u;
      __writegsdword(0xFFFFFFE8, 9u);
      return;
    }
    if ( !s )
    {
      __writegsdword(0xFFFFFFE8, 0x16u);
      return;
    }
    if ( IO_fwide((int)a3, 1) == 1 )
    {
      v6 = *a3;
      if ( (*a3 & 2) != 0 )
      {
        buffered_vfprintf_0((int)a5, s, a3, (int)a3, (int)&savedregs, a1, v6);
      }
      else
      {
        v415 = (double *)a5;
        v399 = 0;
        v401 = wcschrnul(s, 37);
        if ( (v6 & 0x8000) == 0 )
        {
          v408[0] = (int)funlockfile;
          v408[1] = (int)a3;
          _EDX = a3[18];
          v8 = __readgsdword(8u);
          if ( v8 != *(_DWORD *)(_EDX + 8) )
          {
            _ECX = 1;
            v10 = __readgsdword(0xCu) == 0;
            if ( !v10 )
              __asm { lock }
            __asm { cmpxchg [edx], ecx }
            if ( !v10 )
            {
              L_lock_612(0, (volatile __int32 *)_EDX);
              return;
            }
            _EDX = a3[18];
            *(_DWORD *)(_EDX + 8) = v8;
          }
          ++*(_DWORD *)(_EDX + 4);
        }
        v11 = v401 - s;
        if ( v11 == (*(int (__cdecl **)(_DWORD *, wchar_t *, unsigned int))(a3[37] + 28))(a3, s, v11)
          && (char *)v401 - (char *)s >= -3
          && *v401 )
        {
          if ( _printf_function_table || _printf_modifier_table || _printf_va_arg_table )
          {
            v388 = 0;
            v398 = 0;
            v380 = 0;
            v384 = 0;
            v402 = 0;
            v386 = -1;
            v381 = 0;
          }
          else
          {
            v14 = v401;
            v388 = 0;
            v398 = 0;
            v380 = 0;
            v384 = 0;
            v386 = -1;
            v381 = 0;
            while ( 2 )
            {
              v15 = v14 + 1;
              v16 = v14[1];
              v394 = v15;
              v402 = 0;
              v373 = 0;
              v17 = v16 - 32;
              v392 = v16;
              v374 = 0;
              v378 = 0;
              v375 = 0;
              v379 = 0;
              v385 = 0;
              v383 = 0xFFFFFFFF00000000LL;
              v389 = 0;
              v372 = 0;
              v390 = 0;
              v376 = 0;
              v377 = 32;
              v396 = (int)v406;
LABEL_37:
              switch ( v17 )
              {
                case 0u:
LABEL_383:
                  v151 = v394 + 1;
                  v392 = v394[1];
                  v152 = v392 - 32;
                  v374 = 1;
                  goto LABEL_384;
                case 3u:
LABEL_393:
                  v151 = v394 + 1;
                  v392 = v394[1];
                  v152 = v392 - 32;
                  if ( v392 - 32 <= 0x5A )
                    v152 = (unsigned __int8)jump_table_10848[v152];
                  v373 = 1;
                  goto LABEL_384;
                case 5u:
LABEL_670:
                  v240 = v5[22];
                  if ( v240 && (v241 = *(_DWORD **)(v240 + 16), (unsigned int)v241 < *(_DWORD *)(v240 + 20)) )
                  {
                    *v241 = 37;
                    *(_DWORD *)(v240 + 16) = v241 + 1;
                  }
                  else if ( _woverflow((int)v5, 37) == -1 )
                  {
                    goto LABEL_33;
                  }
                  if ( v11 == 0x7FFFFFFF )
                    goto LABEL_33;
                  ++v11;
                  v385 = a5;
                  goto LABEL_146;
                case 7u:
LABEL_402:
                  if ( v386 == -1 )
                  {
                    v170 = *(_DWORD *)__readgsdword(0xFFFFFFE4);
                    v171 = *(_DWORD *)(v170 + 52);
                    v172 = *(_BYTE **)(v170 + 44);
                    v381 = v171;
                    v386 = (int)v172;
                    v173 = v172;
                    v174 = *v172;
                    if ( v174 == 127 || !v174 )
                    {
                      v386 = 0;
                    }
                    else
                    {
                      v175 = 0;
                      if ( v171 )
                        v175 = v173;
                      v386 = (int)v175;
                    }
                  }
                  v151 = v394 + 1;
                  v152 = v394[1] - 32;
                  v392 = v394[1];
                  if ( v152 <= 0x5A )
                    v152 = (unsigned __int8)jump_table_10848[v152];
                  v379 = 1;
                  goto LABEL_384;
                case 0xAu:
LABEL_409:
                  v151 = v394 + 1;
                  v155 = v394[1] - 48;
                  v363 = v394[1];
                  if ( v155 <= 9 )
                  {
                    v156 = v394 + 1;
                    v403 = (unsigned int)v5;
                    while ( 1 )
                    {
                      v157 = *++v156;
                      if ( (unsigned int)(*v156 - 48) > 9 )
                        break;
                      v155 = v157 + 10 * v155 - 48;
                    }
                    v5 = (_DWORD *)v403;
                    if ( v155 )
                    {
                      if ( v157 == 36 )
                        break;
                    }
                  }
                  v360 = a5 + 1;
                  v158 = *a5;
                  v390 = *a5;
                  if ( (v390 & 0x80000000) != 0 )
                  {
                    v390 = -v158;
                    v377 = 32;
                    v378 = 1;
                  }
                  if ( v390 > 0x3FFFFFDE )
                    goto LABEL_480;
                  if ( v390 <= 0x3C7 )
                    goto LABEL_421;
                  v392 = 4 * v390 + 128;
                  if ( v392 <= 0x1000 )
                    goto LABEL_420;
                  if ( _libc_alloca_cutoff(4 * v390 + 128) )
                  {
                    v363 = v394[1];
LABEL_420:
                    v403 = v392 + 30;
                    v159 = alloca(16 * ((v392 + 30) / 0x10));
                    v396 = (int)&v355[v392];
                  }
                  else
                  {
                    malloc(a2, v392);
                    v402 = v176;
                    if ( !v176 )
                      goto LABEL_33;
                    v177 = v394[1];
                    v396 = v402 + v392;
                    v363 = v177;
                  }
LABEL_421:
                  v152 = v363 - 32;
                  v392 = v363;
                  if ( v363 - 32 <= 0x5A )
                    v152 = (unsigned __int8)jump_table_10848[v152];
                  a5 = v360;
                  goto LABEL_384;
                case 0xBu:
LABEL_385:
                  v151 = v394 + 1;
                  v152 = v394[1] - 32;
                  v392 = v394[1];
                  if ( v152 <= 0x5A )
                    v152 = (unsigned __int8)jump_table_10848[v152];
                  v375 = 1;
                  goto LABEL_384;
                case 0xDu:
LABEL_390:
                  v151 = v394 + 1;
                  v152 = v394[1] - 32;
                  v392 = v394[1];
                  if ( v152 <= 0x5A )
                    v152 = (unsigned __int8)jump_table_10848[v152];
                  v377 = 32;
                  v378 = 1;
                  goto LABEL_384;
                case 0xEu:
                  while ( 2 )
                  {
                    v162 = v394[1];
                    v151 = v394 + 1;
                    if ( v162 != 42 )
                    {
                      v163 = v162 - 48;
                      if ( v163 > 9 )
                      {
                        HIDWORD(v383) = 0;
                        v394 = a5;
                        goto LABEL_432;
                      }
                      while ( (unsigned int)(*++v151 - 48) <= 9 )
                        v163 = *v151 + 10 * v163 - 48;
                      HIDWORD(v383) = v163;
                      v394 = a5;
LABEL_442:
                      if ( HIDWORD(v383) > 0x3C8 && SHIDWORD(v383) > (int)v390 )
                      {
                        if ( HIDWORD(v383) > 0x3FFFFFDE )
                        {
LABEL_480:
                          __writegsdword(0xFFFFFFE8, 0x22u);
                          goto LABEL_33;
                        }
                        v392 = 4 * HIDWORD(v383) + 128;
                        if ( v392 <= 0x1000 || _libc_alloca_cutoff(4 * HIDWORD(v383) + 128) )
                        {
                          v403 = v392 + 30;
                          v166 = alloca(16 * ((v392 + 30) / 0x10));
                          v396 = (int)&v355[v392];
                        }
                        else
                        {
                          malloc(a2, v392);
                          v402 = v169;
                          if ( !v169 )
                            goto LABEL_33;
                          v396 = v402 + v392;
                        }
                      }
LABEL_432:
                      v152 = *v151 - 32;
                      v392 = *v151;
                      if ( v152 <= 0x5A )
                        v152 = (unsigned __int8)jump_table_10848[v152];
                      a5 = v394;
LABEL_384:
                      v394 = v151;
                      switch ( v152 )
                      {
                        case 0u:
                          goto LABEL_383;
                        case 1u:
                        case 2u:
                        case 4u:
                        case 6u:
                        case 8u:
                        case 9u:
                        case 0xCu:
                        case 0xFu:
                        case 0x1Au:
                        case 0x1Bu:
                        case 0x1Cu:
                        case 0x1Du:
                        case 0x1Eu:
                        case 0x1Fu:
                        case 0x20u:
                        case 0x22u:
                        case 0x24u:
                        case 0x28u:
                        case 0x2Au:
                        case 0x2Bu:
                        case 0x2Du:
                        case 0x2Eu:
                        case 0x2Fu:
                        case 0x30u:
                        case 0x31u:
                        case 0x32u:
                        case 0x34u:
                        case 0x35u:
                        case 0x36u:
                        case 0x37u:
                        case 0x39u:
                        case 0x3Bu:
                        case 0x3Cu:
                        case 0x3Du:
                        case 0x3Eu:
                        case 0x3Fu:
                        case 0x40u:
                        case 0x42u:
                        case 0x4Bu:
                        case 0x52u:
                        case 0x56u:
                        case 0x57u:
                        case 0x59u:
                          goto LABEL_32;
                        case 3u:
                          goto LABEL_393;
                        case 5u:
                          goto LABEL_670;
                        case 7u:
                          goto LABEL_402;
                        case 0xAu:
                          goto LABEL_409;
                        case 0xBu:
                          goto LABEL_385;
                        case 0xDu:
                          goto LABEL_390;
                        case 0xEu:
                          continue;
                        case 0x10u:
                          goto LABEL_398;
                        case 0x11u:
                        case 0x12u:
                        case 0x13u:
                        case 0x14u:
                        case 0x15u:
                        case 0x16u:
                        case 0x17u:
                        case 0x18u:
                        case 0x19u:
                          goto LABEL_426;
                        case 0x21u:
                        case 0x41u:
                          goto LABEL_993;
                        case 0x23u:
                          goto LABEL_132;
                        case 0x25u:
                        case 0x26u:
                        case 0x27u:
                        case 0x45u:
                        case 0x46u:
                        case 0x47u:
                          goto LABEL_916;
                        case 0x29u:
                          goto LABEL_406;
                        case 0x2Cu:
                        case 0x4Au:
                        case 0x51u:
                          goto LABEL_661;
                        case 0x33u:
                        case 0x53u:
                          goto LABEL_1063;
                        case 0x38u:
                        case 0x58u:
                          goto LABEL_991;
                        case 0x3Au:
                        case 0x5Au:
                          goto LABEL_664;
                        case 0x43u:
                          goto LABEL_959;
                        case 0x44u:
                        case 0x49u:
                          goto LABEL_675;
                        case 0x48u:
                          goto LABEL_470;
                        case 0x4Cu:
                          goto LABEL_658;
                        case 0x4Du:
                          goto LABEL_922;
                        case 0x4Eu:
                          goto LABEL_912;
                        case 0x4Fu:
                          goto LABEL_833;
                        case 0x50u:
                          goto LABEL_910;
                        case 0x54u:
                          goto LABEL_666;
                        case 0x55u:
                          goto LABEL_893;
                        default:
                          v374 = 1;
                          goto LABEL_384;
                      }
                    }
                    break;
                  }
                  v151 = v394 + 2;
                  v164 = v394[2] - 48;
                  if ( v164 > 9 )
                    goto LABEL_439;
                  v167 = v394 + 2;
                  v403 = (unsigned int)v5;
                  while ( 1 )
                  {
                    v168 = *++v167;
                    if ( (unsigned int)(*v167 - 48) > 9 )
                      break;
                    v164 = v168 + 10 * v164 - 48;
                  }
                  v5 = (_DWORD *)v403;
                  if ( !v164 || v168 != 36 )
                  {
LABEL_439:
                    v165 = -1;
                    v394 = a5 + 1;
                    if ( *a5 >= 0 )
                      v165 = *a5;
                    HIDWORD(v383) = v165;
                    goto LABEL_442;
                  }
                  break;
                case 0x10u:
LABEL_398:
                  v153 = 48;
                  if ( v378 )
                    v153 = v377;
                  v154 = v394[1];
                  v151 = v394 + 1;
                  v377 = v153;
                  v152 = v154 - 32;
                  v392 = v154;
                  if ( (unsigned int)(v154 - 32) <= 0x5A )
                    v152 = (unsigned __int8)jump_table_10848[v152];
                  goto LABEL_384;
                case 0x11u:
                case 0x12u:
                case 0x13u:
                case 0x14u:
                case 0x15u:
                case 0x16u:
                case 0x17u:
                case 0x18u:
                case 0x19u:
LABEL_426:
                  v390 = *v394 - 48;
                  for ( i = v394; ; ++i )
                  {
                    v161 = i[1];
                    v151 = i + 1;
                    if ( (unsigned int)(v161 - 48) > 9 )
                      break;
                    v390 = v161 + 10 * v390 - 48;
                  }
                  v394 = i;
                  if ( v390 > 0x3FFFFFDE )
                    goto LABEL_480;
                  if ( v390 <= 0x3C7 )
                    goto LABEL_477;
                  v363 = 4 * v390 + 128;
                  if ( v363 <= 0x1000 || _libc_alloca_cutoff(4 * v390 + 128) )
                  {
                    v403 = v363 + 30;
                    v178 = alloca(16 * ((v363 + 30) / 0x10));
                    v396 = (int)&v355[v363];
                  }
                  else
                  {
                    malloc(a2, v363);
                    v402 = v180;
                    if ( !v180 )
                      goto LABEL_33;
                    v396 = v402 + v363;
                  }
LABEL_477:
                  v179 = v394[1];
                  if ( v179 == 36 )
                    break;
                  v392 = v394[1];
                  v152 = v179 - 32;
                  if ( v152 <= 0x5A )
                    v152 = (unsigned __int8)jump_table_10848[v152];
                  goto LABEL_384;
                case 0x21u:
                case 0x41u:
LABEL_993:
                  v396 = (int)v407;
                  memset(v407, 0, sizeof(v407));
                  BYTE1(v407[3]) = 4;
                  v407[2] = v392;
                  v407[0] = HIDWORD(v383);
                  v407[1] = v390;
                  LOBYTE(v407[3]) = ((_BYTE)v379 << 7) | ((v375 & 1) << 6) | (32 * (v378 & 1)) | (16 * (v374 & 1)) | (8 * (v373 & 1)) | (4 * (v389 & 1)) | (2 * (v383 & 1)) | (unsigned __int8)v385 & 1;
                  v407[4] = v377;
                  if ( v385 )
                  {
                    v331 = *(double *)a5;
                    v385 = a5 + 3;
                    v332 = a5[2];
                    v409 = v331;
                    v410 = v332;
                  }
                  else
                  {
                    a2 = *(double *)a5;
                    v385 = a5 + 2;
                    v409 = a2;
                  }
                  v416 = (long double *)&v409;
                  v257 = _printf_fphex(v5, v396, &v416);
                  if ( v257 < 0 )
                    goto LABEL_33;
                  if ( v11 > 0x7FFFFFFE )
                    goto LABEL_798;
                  if ( v257 > 0x7FFFFFFF - v11 )
                    goto LABEL_33;
                  goto LABEL_737;
                case 0x23u:
                  goto LABEL_132;
                case 0x25u:
                case 0x26u:
                case 0x27u:
                case 0x45u:
                case 0x46u:
                case 0x47u:
LABEL_916:
                  v396 = (int)v407;
                  memset(v407, 0, sizeof(v407));
                  v407[2] = v392;
                  v407[0] = HIDWORD(v383);
                  v407[1] = v390;
                  LOBYTE(v407[3]) = ((_BYTE)v379 << 7) | ((v375 & 1) << 6) | (32 * (v378 & 1)) | (16 * (v374 & 1)) | (8 * (v373 & 1)) | (4 * (v389 & 1)) | (2 * (v383 & 1)) | (unsigned __int8)v385 & 1;
                  v407[4] = v377;
                  BYTE1(v407[3]) = (8 * (v376 & 1)) | 4;
                  if ( v385 )
                  {
                    v306 = *(double *)a5;
                    v385 = a5 + 3;
                    v307 = a5[2];
                    v409 = v306;
                    v410 = v307;
                  }
                  else
                  {
                    a2 = *(double *)a5;
                    v385 = a5 + 2;
                    v409 = a2;
                  }
                  v416 = (long double *)&v409;
                  v257 = _printf_fp((int)v5, v396, &v416);
                  if ( v257 < 0 )
                    goto LABEL_33;
                  if ( v11 > 0x7FFFFFFE )
                    goto LABEL_798;
                  if ( v257 > 0x7FFFFFFF - v11 )
                    goto LABEL_33;
                  goto LABEL_737;
                case 0x29u:
LABEL_406:
                  v151 = v394 + 1;
                  v392 = v394[1];
                  v152 = v392 - 32;
                  if ( v392 - 32 <= 0x5A )
                    v152 = (unsigned __int8)jump_table_10848[v152];
                  v376 = 1;
                  goto LABEL_384;
                case 0x2Cu:
                case 0x4Au:
                case 0x51u:
LABEL_661:
                  v151 = v394 + 1;
                  v392 = v394[1];
                  v152 = v392 - 32;
                  if ( v392 - 32 <= 0x5A )
                    v152 = (unsigned __int8)jump_table_10848[v152];
                  v389 = 1;
                  v385 = (int *)1;
                  goto LABEL_384;
                case 0x33u:
                case 0x53u:
LABEL_1063:
                  v385 = a5 + 1;
                  v309 = (wchar_t *)*a5;
                  goto LABEL_923;
                case 0x38u:
                case 0x58u:
LABEL_991:
                  v389 = 16;
                  goto LABEL_834;
                case 0x3Au:
                case 0x5Au:
LABEL_664:
                  v151 = v394 + 1;
                  v152 = v394[1] - 32;
                  v392 = v394[1];
                  if ( v152 <= 0x5A )
                    goto LABEL_665;
                  goto LABEL_667;
                case 0x43u:
LABEL_959:
                  if ( v389 )
                  {
LABEL_132:
                    v74 = v390 - 1;
                    if ( !v378 && v74 > 0 )
                    {
                      v75 = IO_wpadn((int)v5, 32, v390 - 1);
                      if ( v11 > 0x7FFFFFFE )
                        goto LABEL_499;
                      if ( v75 > 0x7FFFFFFF - v11 )
                        goto LABEL_33;
                      v11 += v75;
                    }
                    v76 = *a5;
                    v77 = v5[22];
                    v385 = a5 + 1;
                    if ( v77 && (v78 = *(int **)(v77 + 16), (unsigned int)v78 < *(_DWORD *)(v77 + 20)) )
                    {
                      *v78 = v76;
                      *(_DWORD *)(v77 + 16) = v78 + 1;
                      if ( v76 == -1 )
                        goto LABEL_33;
                    }
                    else if ( _woverflow((int)v5, v76) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v11 == 0x7FFFFFFF )
                      goto LABEL_33;
                    ++v11;
                    if ( v378 && v74 > 0 )
                    {
                      v79 = IO_wpadn((int)v5, 32, v74);
                      if ( v11 > 0x7FFFFFFE )
                        goto LABEL_499;
                      if ( v79 > 0x7FFFFFFF - v11 )
                        goto LABEL_33;
                      goto LABEL_145;
                    }
                  }
                  else
                  {
                    v324 = v390 - 1;
                    if ( !v378 && v324 > 0 )
                    {
                      v325 = IO_wpadn((int)v5, 32, v390 - 1);
                      if ( v11 > 0x7FFFFFFE )
                        goto LABEL_499;
                      if ( v325 > 0x7FFFFFFF - v11 )
                        goto LABEL_33;
                      v11 += v325;
                    }
                    v385 = a5 + 1;
                    v326 = btowc(*(unsigned __int8 *)a5);
                    v327 = v5[22];
                    v328 = v326;
                    if ( v327 && (v329 = *(int **)(v327 + 16), (unsigned int)v329 < *(_DWORD *)(v327 + 20)) )
                    {
                      *v329 = v328;
                      *(_DWORD *)(v327 + 16) = v329 + 1;
                      if ( v328 == -1 )
                        goto LABEL_33;
                    }
                    else if ( _woverflow((int)v5, v328) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v11 == 0x7FFFFFFF )
                      goto LABEL_33;
                    ++v11;
                    if ( v378 && v324 > 0 )
                    {
                      v79 = IO_wpadn((int)v5, 32, v324);
                      if ( v11 > 0x7FFFFFFE )
                        goto LABEL_499;
                      if ( v79 > 0x7FFFFFFF - v11 )
                        goto LABEL_33;
                      goto LABEL_145;
                    }
                  }
                  goto LABEL_146;
                case 0x44u:
                case 0x49u:
LABEL_675:
                  if ( v385 )
                  {
                    v242 = *(double *)a5;
                    v385 = a5 + 2;
                    v403 = HIDWORD(v242) >> 31;
                    if ( v242 < 0.0 )
                      *(_QWORD *)&v242 = -*(_QWORD *)&v242;
                    v372 = HIDWORD(v242);
                    LODWORD(v383) = LODWORD(v242);
                    v389 = 10;
                    goto LABEL_679;
                  }
                  if ( v372 )
                  {
                    v385 = a5 + 1;
                    v303 = *(char *)a5;
                  }
                  else
                  {
                    v385 = a5 + 1;
                    if ( (_DWORD)v383 )
                      v303 = *(__int16 *)a5;
                    else
                      v303 = *a5;
                  }
                  v304 = (unsigned int)v303 >> 31;
                  if ( v303 < 0 )
                    v303 = -v303;
                  v403 = v304;
                  LODWORD(v383) = v303;
                  v389 = 10;
                  goto LABEL_838;
                case 0x48u:
LABEL_470:
                  v151 = v394 + 1;
                  v392 = v394[1];
                  v152 = v392 - 32;
                  if ( v392 - 32 <= 0x5A )
                    v152 = (unsigned __int8)jump_table_10848[v152];
                  LODWORD(v383) = 1;
                  goto LABEL_384;
                case 0x4Cu:
LABEL_658:
                  v151 = v394 + 1;
                  v152 = v394[1] - 32;
                  v392 = v394[1];
                  if ( v152 <= 0x5A )
                    v152 = (unsigned __int8)jump_table_10848[v152];
                  v389 = 1;
                  goto LABEL_384;
                case 0x4Du:
LABEL_922:
                  v308 = strerror_r(a2, v400, v405, 0xFA0u);
                  v389 = 0;
                  v385 = a5;
                  v309 = (wchar_t *)v308;
LABEL_923:
                  if ( v309 )
                    goto LABEL_924;
                  if ( SHIDWORD(v383) > 5 || HIDWORD(v383) == -1 )
                  {
                    v403 = 0;
                    v312 = 6;
                    v311 = "(";
                  }
                  else
                  {
                    v403 = 0;
                    v312 = 0;
                    v311 = (const char *)&unk_80DC970;
                  }
                  goto LABEL_928;
                case 0x4Eu:
LABEL_912:
                  if ( (v5[15] & 4) != 0 && !v380 )
                  {
                    v333 = wcslen(s);
                    v380 = _readonly_area((unsigned int)s, 4 * v333 + 4);
                    if ( v380 < 0 )
LABEL_1011:
                      _libc_fatal("*** %n in writable segment detected ***\n");
                  }
                  if ( v385 )
                  {
                    v385 = a5 + 1;
                    *(_QWORD *)*a5 = (int)v11;
                  }
                  else if ( v372 )
                  {
                    v385 = a5 + 1;
                    *(_BYTE *)*a5 = v11;
                  }
                  else if ( (_DWORD)v383 )
                  {
                    v334 = (_WORD *)*a5;
                    v385 = a5 + 1;
                    *v334 = v11;
                  }
                  else
                  {
                    v385 = a5 + 1;
                    *(_DWORD *)*a5 = v11;
                  }
                  goto LABEL_146;
                case 0x4Fu:
LABEL_833:
                  v389 = 8;
                  goto LABEL_834;
                case 0x50u:
LABEL_910:
                  v385 = a5 + 1;
                  if ( *a5 )
                  {
                    LODWORD(v383) = *a5;
                    v392 = 120;
                    v379 = 0;
                    v373 = 1;
                    v389 = 16;
                    v403 = 0;
                    goto LABEL_838;
                  }
                  if ( SHIDWORD(v383) <= 4 )
                    HIDWORD(v383) = 5;
                  v389 = 0;
                  v309 = (wchar_t *)"(";
LABEL_924:
                  if ( v392 == 83 || v389 )
                  {
                    v356 = (unsigned int)v309;
                    if ( HIDWORD(v383) == -1 )
                      v310 = wcslen(v309);
                    else
                      v310 = wcsnlen(v309, SHIDWORD(v383));
                    v311 = (const char *)v356;
                    v403 = 0;
                    v312 = v310;
                  }
                  else
                  {
                    v416 = (long double *)v309;
                    if ( HIDWORD(v383) == -1 )
                      v396 = strlen((const char *)v309);
                    else
                      v396 = strnlen(v309, HIDWORD(v383));
                    v318 = 4 * v396;
                    if ( (unsigned int)(4 * v396) <= 0x1000 || _libc_alloca_cutoff(4 * v396) )
                    {
                      v319 = alloca(v318 + 15);
                      v320 = v355;
                      v403 = 0;
                    }
                    else
                    {
                      malloc(a2, v318);
                      v320 = v322;
                      if ( !v322 )
                        goto LABEL_33;
                      v403 = 1;
                    }
                    v404 = v413;
                    memset(v413, 0, sizeof(v413));
                    v356 = (unsigned int)v320;
                    v321 = mbsrtowcs(a2, (int)v320, &v416, v396, v413);
                    v311 = (const char *)v356;
                    v312 = v321;
                    if ( v321 == -1 )
                      goto LABEL_33;
                  }
LABEL_928:
                  v313 = (int *)(v390 - v312);
                  if ( (int)(v390 - v312) < 0 )
                  {
                    if ( (v11 & 0x80000000) != 0 )
                      goto LABEL_986;
                    if ( v312 != (*(int (__cdecl **)(_DWORD *, const char *, unsigned int))(v5[37] + 28))(
                                   v5,
                                   v311,
                                   v312) )
                      goto LABEL_33;
                    v323 = 0x7FFFFFFF - v11;
                    v11 += v312;
                    if ( v312 > v323 )
                      goto LABEL_33;
                  }
                  else
                  {
                    if ( !v378 && v313 )
                    {
                      v356 = (unsigned int)v311;
                      v357 = (int *)(v390 - v312);
                      v314 = (int *)IO_wpadn((int)v5, 32, v390 - v312);
                      v311 = (const char *)v356;
                      v313 = v357;
                      v396 = (int)v314;
                      if ( v11 > 0x7FFFFFFE )
                        goto LABEL_499;
                      if ( v396 > 0x7FFFFFFF - v11 )
                        goto LABEL_33;
                      v11 += v396;
                    }
                    if ( (v11 & 0x80000000) != 0 )
LABEL_986:
                      _assert_fail(
                        (int)&savedregs,
                        a2,
                        (int)"(size_t) done <= (size_t) 2147483647",
                        (int)"vfprintf.c",
                        1630,
                        "_IO_vfwprintf");
                    v315 = v5[37];
                    v356 = (unsigned int)v311;
                    v357 = v313;
                    v316 = (*(int (__cdecl **)(_DWORD *, const char *, unsigned int))(v315 + 28))(v5, v311, v312);
                    v317 = v356;
                    if ( v312 != v316 || v312 > 0x7FFFFFFF - v11 )
                      goto LABEL_33;
                    v11 += v312;
                    if ( v378 && v357 )
                    {
                      v330 = IO_wpadn((int)v5, 32, (int)v357);
                      v317 = v356;
                      if ( v11 > 0x7FFFFFFE )
LABEL_499:
                        _assert_fail(
                          (int)&savedregs,
                          a2,
                          (int)"(unsigned int) done < (unsigned int) 2147483647",
                          (int)"vfprintf.c",
                          1630,
                          "_IO_vfwprintf");
                      if ( v330 > 0x7FFFFFFF - v11 )
                        goto LABEL_33;
                      v11 += v330;
                    }
                    if ( v403 )
                      free(v317);
                  }
                  goto LABEL_146;
                case 0x54u:
LABEL_666:
                  v151 = v394 + 1;
                  v152 = v394[1] - 32;
                  v392 = v394[1];
                  if ( v152 <= 0x5A )
                  {
LABEL_665:
                    v152 = (unsigned __int8)jump_table_10848[v152];
                    v389 = 0;
                    v385 = 0;
                  }
                  else
                  {
LABEL_667:
                    v389 = 0;
                    v385 = 0;
                  }
                  goto LABEL_384;
                case 0x55u:
LABEL_893:
                  v389 = 10;
LABEL_834:
                  if ( v385 )
                  {
                    v375 = 0;
                    v282 = *a5;
                    v283 = a5[1];
                    v385 = a5 + 2;
                    LODWORD(v383) = v282;
                    v372 = v283;
                    v374 = 0;
                    v403 = 0;
LABEL_679:
                    if ( v383 < 0 )
                    {
                      HIDWORD(v383) = 1;
                    }
                    else
                    {
                      v377 = 32;
                      if ( !HIDWORD(v383) && !((unsigned int)v383 | v372) )
                      {
                        v243 = (int *)v396;
                        if ( v373 && v389 == 8 )
                        {
                          v243 = (int *)(v396 - 4);
                          *(_DWORD *)(v396 - 4) = 48;
                        }
                        else
                        {
                          v377 = 32;
                        }
LABEL_685:
                        LODWORD(v383) = (v372 | (unsigned int)v383) != 0;
                        goto LABEL_686;
                      }
                    }
                    v305 = itowa(__PAIR64__(v372, v383), (int *)v396, v389, v392 == 88);
                    v243 = v305;
                    if ( v386 && v379 )
                      v243 = (int *)group_number_0(v305, (_BYTE *)v396, (_BYTE *)v386, v381);
                    if ( v389 == 10 && v376 )
                      v243 = (int *)i18n_number_rewrite_1(v243, v396, v396, a2);
                    goto LABEL_685;
                  }
                  if ( v372 )
                  {
                    v375 = 0;
                    v374 = 0;
                    v284 = *(unsigned __int8 *)a5;
                    v385 = a5 + 1;
                    v403 = 0;
                    LODWORD(v383) = v284;
                  }
                  else
                  {
                    v375 = 0;
                    v374 = 0;
                    if ( (_DWORD)v383 )
                    {
                      v293 = *(unsigned __int16 *)a5;
                      v385 = a5 + 1;
                      v403 = 0;
                      LODWORD(v383) = v293;
                    }
                    else
                    {
                      v292 = *a5;
                      v385 = a5 + 1;
                      v403 = 0;
                      LODWORD(v383) = v292;
                    }
                  }
LABEL_838:
                  if ( v383 < 0 )
                  {
                    HIDWORD(v383) = 1;
                  }
                  else
                  {
                    v377 = 32;
                    if ( v383 <= 0 )
                    {
                      v243 = (int *)v396;
                      if ( v373 && v389 == 8 )
                      {
                        v243 = (int *)(v396 - 4);
                        v389 = 8;
                        *(_DWORD *)(v396 - 4) = 48;
                      }
                      else
                      {
                        v377 = 32;
                      }
                      goto LABEL_686;
                    }
                  }
                  v285 = (int *)&itowa_upper_digits;
                  v286 = v383;
                  if ( v392 != 88 )
                    v285 = itowa_lower_digits;
                  if ( v389 == 10 )
                  {
                    v243 = (int *)v396;
                    v290 = v383;
                    v372 = (unsigned int)v5;
                    do
                    {
                      v291 = v290 % 0xA;
                      v290 /= 0xAu;
                      *--v243 = v285[v291];
                    }
                    while ( v290 );
                    v5 = (_DWORD *)v372;
                  }
                  else if ( v389 == 16 )
                  {
                    v243 = (int *)v396;
                    do
                    {
                      --v243;
                      v289 = v285[v286 & 0xF];
                      v286 >>= 4;
                      *v243 = v289;
                    }
                    while ( v286 );
                  }
                  else
                  {
                    v243 = (int *)v396;
                    do
                    {
                      --v243;
                      v288 = v285[v286 & 7];
                      v286 >>= 3;
                      *v243 = v288;
                    }
                    while ( v286 );
                  }
                  if ( v386 && v379 )
                    v243 = (int *)group_number_0(v243, (_BYTE *)v396, (_BYTE *)v386, v381);
                  if ( v389 == 10 && v376 )
                  {
                    v287 = (int *)i18n_number_rewrite_1(v243, v396, v396, a2);
                    v389 = 10;
                    v243 = v287;
                  }
LABEL_686:
                  if ( SHIDWORD(v383) <= (v396 - (int)v243) >> 2 && v373 && (_DWORD)v383 && v389 == 8 )
                    *--v243 = 48;
                  v379 = 0;
                  v396 -= (int)v243;
                  v244 = HIDWORD(v383) - (v396 >> 2);
                  if ( v244 < 0 )
                    v244 = v379;
                  v376 = -(v396 >> 2);
                  v379 = v244;
                  if ( !v378 )
                  {
                    v245 = v390 + -(v396 >> 2) - v379;
                    v390 = v245;
                    BYTE4(v383) = v373 != 0;
                    if ( v373 && (_DWORD)v383 )
                    {
                      v246 = v245 - 2;
                      if ( v389 != 16 )
                        v246 = v390;
                      v390 = v246;
                    }
                    v390 = ((v375 | v403 | v374) == 0) + v390 - 1;
                    if ( v377 == 32 )
                    {
                      if ( (int)v390 <= 0 )
                      {
                        v390 = 0;
                      }
                      else
                      {
                        v269 = IO_wpadn((int)v5, 32, v390);
                        if ( v11 > 0x7FFFFFFE )
LABEL_798:
                          _assert_fail(
                            (int)&savedregs,
                            a2,
                            (int)"(unsigned int) done < (unsigned int) 2147483647",
                            (int)"vfprintf.c",
                            1629,
                            "_IO_vfwprintf");
                        if ( v269 > 0x7FFFFFFF - v11 )
                          goto LABEL_33;
                        v11 += v269;
                        v390 = 0;
                      }
                    }
                    if ( v403 )
                    {
                      v247 = v5[22];
                      if ( v247 && (v248 = *(_DWORD **)(v247 + 16), (unsigned int)v248 < *(_DWORD *)(v247 + 20)) )
                      {
                        *v248 = 45;
                        *(_DWORD *)(v247 + 16) = v248 + 1;
                      }
                      else if ( _woverflow((int)v5, 45) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 0x7FFFFFFF )
                        goto LABEL_33;
                      goto LABEL_705;
                    }
                    if ( v375 )
                    {
                      v267 = v5[22];
                      if ( v267 && (v268 = *(_DWORD **)(v267 + 16), (unsigned int)v268 < *(_DWORD *)(v267 + 20)) )
                      {
                        *v268 = 43;
                        *(_DWORD *)(v267 + 16) = v268 + 1;
                      }
                      else if ( _woverflow((int)v5, 43) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 0x7FFFFFFF )
                        goto LABEL_33;
LABEL_705:
                      ++v11;
                    }
                    else if ( v374 )
                    {
                      v275 = v5[22];
                      if ( v275 && (v276 = *(_DWORD **)(v275 + 16), (unsigned int)v276 < *(_DWORD *)(v275 + 20)) )
                      {
                        *v276 = 32;
                        *(_DWORD *)(v275 + 16) = v276 + 1;
                      }
                      else if ( _woverflow((int)v5, 32) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 0x7FFFFFFF )
                        goto LABEL_33;
                      goto LABEL_705;
                    }
                    if ( BYTE4(v383) && (_DWORD)v383 && v389 == 16 )
                    {
                      v270 = v5[22];
                      if ( v270 && (v271 = *(_DWORD **)(v270 + 16), (unsigned int)v271 < *(_DWORD *)(v270 + 20)) )
                      {
                        *v271 = 48;
                        *(_DWORD *)(v270 + 16) = v271 + 1;
                      }
                      else if ( _woverflow((int)v5, 48) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 0x7FFFFFFF )
                        goto LABEL_33;
                      v272 = v5[22];
                      if ( v272 && (v273 = *(unsigned int **)(v272 + 16), (unsigned int)v273 < *(_DWORD *)(v272 + 20)) )
                      {
                        v274 = v392;
                        *v273 = v392;
                        *(_DWORD *)(v272 + 16) = v273 + 1;
                        if ( v274 == -1 )
                          goto LABEL_33;
                      }
                      else if ( _woverflow((int)v5, v392) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 2147483646 )
                        goto LABEL_33;
                      v11 += 2;
                    }
                    if ( (int)(v379 + v390) > 0 )
                    {
                      v249 = IO_wpadn((int)v5, 48, v379 + v390);
                      if ( v11 > 0x7FFFFFFE )
                        goto LABEL_798;
                      if ( v249 > 0x7FFFFFFF - v11 )
                        goto LABEL_33;
                      v11 += v249;
                    }
                    if ( (v11 & 0x80000000) != 0 )
                      goto LABEL_909;
                    v250 = v5[37];
                    v356 = v396 >> 2;
                    v251 = (*(int (__cdecl **)(_DWORD *, int *, int))(v250 + 28))(v5, v243, v396 >> 2);
                    v79 = v356;
                    if ( v356 != v251 || v356 > 0x7FFFFFFF - v11 )
                      goto LABEL_33;
LABEL_145:
                    v11 += v79;
                    goto LABEL_146;
                  }
                  if ( v403 )
                  {
                    v252 = v5[22];
                    if ( v252 && (v253 = *(_DWORD **)(v252 + 16), (unsigned int)v253 < *(_DWORD *)(v252 + 20)) )
                    {
                      *v253 = 45;
                      *(_DWORD *)(v252 + 16) = v253 + 1;
                    }
                    else if ( _woverflow((int)v5, 45) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v11 == 0x7FFFFFFF )
                      goto LABEL_33;
                    goto LABEL_721;
                  }
                  if ( v375 )
                  {
                    v258 = v5[22];
                    if ( v258 && (v259 = *(_DWORD **)(v258 + 16), (unsigned int)v259 < *(_DWORD *)(v258 + 20)) )
                    {
                      *v259 = 43;
                      *(_DWORD *)(v258 + 16) = v259 + 1;
                    }
                    else if ( _woverflow((int)v5, 43) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v11 == 0x7FFFFFFF )
                      goto LABEL_33;
                    goto LABEL_721;
                  }
                  if ( v374 )
                  {
                    v265 = v5[22];
                    if ( v265 && (v266 = *(_DWORD **)(v265 + 16), (unsigned int)v266 < *(_DWORD *)(v265 + 20)) )
                    {
                      *v266 = 32;
                      *(_DWORD *)(v265 + 16) = v266 + 1;
                    }
                    else if ( _woverflow((int)v5, 32) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v11 == 0x7FFFFFFF )
                      goto LABEL_33;
LABEL_721:
                    --v390;
                    ++v11;
                  }
                  if ( v373 && (_DWORD)v383 && v389 == 16 )
                  {
                    v260 = v5[22];
                    if ( v260 && (v261 = *(_DWORD **)(v260 + 16), (unsigned int)v261 < *(_DWORD *)(v260 + 20)) )
                    {
                      *v261 = 48;
                      *(_DWORD *)(v260 + 16) = v261 + 1;
                    }
                    else if ( _woverflow((int)v5, 48) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v11 == 0x7FFFFFFF )
                      goto LABEL_33;
                    v262 = v5[22];
                    if ( v262 && (v263 = *(unsigned int **)(v262 + 16), (unsigned int)v263 < *(_DWORD *)(v262 + 20)) )
                    {
                      v264 = v392;
                      *v263 = v392;
                      *(_DWORD *)(v262 + 16) = v263 + 1;
                      if ( v264 == -1 )
                        goto LABEL_33;
                    }
                    else if ( _woverflow((int)v5, v392) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v11 == 2147483646 )
                      goto LABEL_33;
                    v11 += 2;
                    v390 -= 2;
                  }
                  if ( v379 )
                  {
                    v254 = IO_wpadn((int)v5, 48, v379);
                    if ( v11 > 0x7FFFFFFE )
                      goto LABEL_798;
                    if ( v254 > 0x7FFFFFFF - v11 )
                      goto LABEL_33;
                    v11 += v254;
                  }
                  if ( (v11 & 0x80000000) != 0 )
LABEL_909:
                    _assert_fail(
                      (int)&savedregs,
                      a2,
                      (int)"(size_t) done <= (size_t) 2147483647",
                      (int)"vfprintf.c",
                      1629,
                      "_IO_vfwprintf");
                  v255 = v5[37];
                  v356 = v396 >> 2;
                  v256 = (*(int (__cdecl **)(_DWORD *, int *, int))(v255 + 28))(v5, v243, v396 >> 2);
                  if ( v356 != v256 || v356 > 0x7FFFFFFF - v11 )
                    goto LABEL_33;
                  v11 += v356;
                  if ( (int)(v390 + v376 - v379) > 0 )
                  {
                    v257 = IO_wpadn((int)v5, 32, v390 + v376 - v379);
                    if ( v11 > 0x7FFFFFFE )
                      goto LABEL_798;
                    if ( v257 > 0x7FFFFFFF - v11 )
                      goto LABEL_33;
LABEL_737:
                    v11 += v257;
                  }
LABEL_146:
                  if ( v402 )
                    free(v402);
                  v357 = v394 + 1;
                  v80 = wcschrnul(v394 + 1, 37);
                  v14 = v80;
                  if ( (v11 & 0x80000000) != 0 )
                    _assert_fail(
                      (int)&savedregs,
                      a2,
                      (int)"(size_t) done <= (size_t) 2147483647",
                      (int)"vfprintf.c",
                      1660,
                      "_IO_vfwprintf");
                  v81 = v80;
                  v82 = v5[37];
                  v356 = v81 - v357;
                  v83 = (*(int (__cdecl **)(_DWORD *, int *, unsigned int))(v82 + 28))(v5, v357, v356);
                  if ( v356 != v83 )
                  {
                    v402 = 0;
                    goto LABEL_33;
                  }
                  if ( v356 > 0x7FFFFFFF - v11 )
                  {
                    v402 = 0;
                    goto LABEL_33;
                  }
                  v11 += v356;
                  if ( !*v14 )
                  {
                    v402 = 0;
                    goto LABEL_33;
                  }
                  ++v384;
                  a5 = v385;
                  continue;
                default:
LABEL_32:
                  if ( !v392 )
                    goto LABEL_33;
                  goto LABEL_39;
              }
              break;
            }
          }
LABEL_39:
          src = v355;
          v417[0] = 0;
          free(v402);
          if ( v386 == -1 )
          {
            v50 = *(_DWORD *)__readgsdword(0xFFFFFFE4);
            v51 = *(_DWORD *)(v50 + 52);
            v52 = *(char **)(v50 + 44);
            v381 = v51;
            v386 = (int)v52;
            v53 = *v52;
            if ( v53 == 127 || !v53 )
              v386 = 0;
          }
          if ( *v401 )
          {
            v18 = 0;
            v402 = 0;
            v395 = 0;
            v396 = 1664;
            v394 = v401;
            v403 = (unsigned int)v5;
            while ( 1 )
            {
              v19 = (char *)src + v18;
              v20 = _parse_one_specwc(v394, v402, (int)v19, v417);
              v21 = (int *)*((_DWORD *)v19 + 6);
              ++v395;
              v402 += v20;
              v22 = *v21;
              v394 = v21;
              if ( !v22 )
                break;
              v18 = 52 * v395;
              if ( v396 <= 52 * v395 )
              {
                v23 = (int *)(2 * v396);
                if ( (unsigned int)(2 * v396) <= 0x1000
                  || (v357 = (int *)(2 * v396), v181 = _libc_alloca_cutoff(2 * v396), v23 = v357, v181) )
                {
                  v24 = ((unsigned int)v23 + 15) & 0xFFFFFFF0;
                  v25 = alloca(16 * ((v24 + 30) / 0x10));
                  v26 = v355;
                  if ( src == &v355[v24] )
                    v396 += v24;
                  else
                    v396 = v24;
                }
                else
                {
                  malloc(a2, (size_t)v357);
                  v396 = (int)v357;
                  v26 = v182;
                }
                v27 = src;
                v356 = (unsigned int)v26;
                memmove(v26, src, v18);
                v28 = (void *)v356;
                if ( v388 )
                {
                  free(v27);
                  v28 = (void *)v356;
                }
                if ( (unsigned int)v396 > 0x1000 )
                {
                  v149 = 1;
                  v356 = (unsigned int)v28;
                  v150 = _libc_alloca_cutoff(v396);
                  src = (void *)v356;
                  if ( v150 )
                    v149 = v388;
                  v388 = v149;
                }
                else
                {
                  src = v28;
                }
              }
            }
            v5 = (_DWORD *)v403;
          }
          else
          {
            v394 = v401;
            v402 = 0;
            v395 = 0;
          }
          v29 = v417[0];
          if ( v402 >= v417[0] )
            v29 = v402;
          v402 = v29;
          if ( v29 > 0xCCCCCCC )
          {
            v402 = 0;
            __writegsdword(0xFFFFFFE8, 0x22u);
            goto LABEL_33;
          }
          v30 = 20 * v402;
          if ( 20 * v402 <= 0x1000 || _libc_alloca_cutoff(20 * v402) )
          {
            v31 = alloca(v30 + 15);
            v32 = v355;
          }
          else
          {
            malloc(a2, v30);
            v398 = v32;
            if ( !v32 )
            {
              v402 = 0;
              goto LABEL_33;
            }
          }
          v391 = (double *)v32;
          v396 = (int)&v32[12 * v402];
          v33 = v5[15];
          v357 = (int *)(4 * v402 + v396);
          memset(v357, v33 << 29 >> 31, 4 * v402);
          v34 = v357;
          if ( v395 )
          {
            v35 = src;
            v387 = v11;
            v36 = v357;
            v382 = (unsigned int)v5;
            for ( j = 0; j != v395; ++j )
            {
              v39 = v35[8];
              if ( v39 != -1 )
                v36[v39] = 0;
              v40 = v35[7];
              if ( v40 != -1 )
                v36[v40] = 0;
              v41 = v35[11];
              if ( v41 )
              {
                if ( v41 == 1 )
                {
                  v42 = v396;
                  v36[v35[9]] = v35[10];
                  *(_DWORD *)(v42 + 4 * v35[9]) = v35[12];
                }
                else
                {
                  v38 = v35[9];
                  v354 = v35[11];
                  v393 = v35[2];
                  (*(void (__cdecl **)(_DWORD *, int, int *, int))(_printf_arginfo_table + 4 * v393))(
                    v35,
                    v354,
                    &v36[v38],
                    4 * v38 + v396);
                }
              }
              v35 += 13;
            }
            v34 = v36;
            v5 = (_DWORD *)v382;
            v11 = v387;
          }
          if ( v402 )
          {
            v43 = 0;
            v382 = (unsigned int)v5;
            v387 = v11;
            v44 = v391;
            while ( 1 )
            {
              v46 = v34[v43];
              if ( v46 <= 5 )
              {
                if ( v46 < 0 )
                {
                  if ( v46 == -1 )
                  {
                    if ( (*(_BYTE *)(v382 + 60) & 4) == 0 )
                      _assert_fail((int)&savedregs, a2, (int)"s->_flags2 & 4", (int)"vfprintf.c", 1874, "_IO_vfwprintf");
                    _libc_fatal("*** invalid %N$ use detected ***\n");
                  }
LABEL_78:
                  if ( (v46 & 0x800) == 0 )
                  {
                    if ( _printf_va_arg_table && *(_DWORD *)(_printf_va_arg_table + 4 * v46 - 32) )
                    {
                      v403 = *(_DWORD *)(v396 + 4 * v43) + 30;
                      v183 = alloca(16 * (v403 / 0x10));
                      *(_DWORD *)v44 = v355;
                      v184 = v34[v43];
                      v357 = v34;
                      (*(void (__cdecl **)(_BYTE *, double **))(_printf_va_arg_table + 4 * v184 - 32))(v355, &v415);
                      v34 = v357;
                    }
                    else
                    {
                      *(_DWORD *)v44 = 0;
                      *((_DWORD *)v44 + 1) = 0;
                      *((_DWORD *)v44 + 2) = 0;
                    }
                    goto LABEL_73;
                  }
                }
              }
              else
              {
                if ( v46 == 256 )
                {
                  v47 = v415++;
                  v48 = *((_DWORD *)v47 + 1);
                  v49 = *(_DWORD *)v47;
                  *((_DWORD *)v44 + 1) = v48;
                  *(_DWORD *)v44 = v49;
                  goto LABEL_73;
                }
                if ( v46 <= 256 )
                {
                  if ( v46 <= 7 )
                  {
                    a2 = *v415++;
                    *v44 = a2;
                    goto LABEL_73;
                  }
                  goto LABEL_78;
                }
                if ( v46 != 512 && v46 != 1024 )
                {
                  if ( v46 == 263 )
                  {
                    a2 = *(long double *)v415;
                    v415 = (double *)((char *)v415 + 12);
                    *(long double *)v44 = a2;
                    goto LABEL_73;
                  }
                  goto LABEL_78;
                }
              }
              v45 = v415;
              v415 = (double *)((char *)v415 + 4);
              *(_DWORD *)v44 = *(_DWORD *)v45;
LABEL_73:
              ++v43;
              v44 = (double *)((char *)v44 + 12);
              if ( v43 == v402 )
              {
                v5 = (_DWORD *)v382;
                v11 = v387;
                break;
              }
            }
          }
          while ( v395 > v384 )
          {
            v54 = (int *)((char *)src + 52 * v384);
            v55 = *((_BYTE *)v54 + 12);
            v362 = (v55 & 8) != 0;
            v366 = (v55 & 0x10) != 0;
            v364 = (v55 & 0x20) != 0;
            v365 = v55 >> 7;
            v371 = v55 & 1;
            v367 = (v55 & 0x40) != 0;
            v370 = (v55 & 2) != 0;
            v56 = *((_BYTE *)v54 + 13);
            v369 = (v56 & 2) != 0;
            v382 = (v55 & 4) != 0;
            v387 = v54[1];
            v393 = *v54;
            v57 = *((_BYTE *)v54 + 16);
            v359 = (v56 & 8) != 0;
            v58 = v54[2];
            v361 = v57;
            v59 = v54[8];
            v368 = v58;
            if ( v59 != -1 )
            {
              v60 = *((_DWORD *)v391 + 3 * v59);
              v54[1] = v60;
              if ( v60 < 0 )
              {
                *((_BYTE *)v54 + 12) = v55 | 0x20;
                v54[1] = -v60;
                v364 = 1;
              }
              v387 = v54[1];
            }
            v61 = v54[7];
            if ( v61 != -1 )
            {
              v62 = *((_DWORD *)v391 + 3 * v61);
              v63 = -1;
              if ( v62 >= 0 )
                v63 = v62;
              *v54 = v63;
              v393 = v63;
            }
            v64 = v387;
            if ( v393 >= v387 )
              v64 = v393;
            v396 = (int)v406;
            v402 = 0;
            if ( v64 > 968 )
            {
              v65 = 4 * v64 + 128;
              if ( v65 <= 0x1000 || (v357 = v54, v146 = _libc_alloca_cutoff(4 * v64 + 128), v54 = v357, v146) )
              {
                v66 = alloca(v65 + 15);
                v67 = 4 * v387 + 128;
                v402 = 0;
                v403 = 4 * v393 + 128;
                if ( v387 < v393 )
                  v67 = v403;
                v396 = (int)&v355[v67];
              }
              else
              {
                malloc(a2, v65);
                v54 = v357;
                v402 = v147;
                v148 = 4 * v393 + 128;
                if ( v387 >= v393 )
                  v148 = 4 * v387 + 128;
                v396 = v402 + v148;
              }
            }
            if ( v368 > 255 )
              goto LABEL_1103;
            v360 = (int *)_printf_function_table;
            if ( !_printf_function_table )
              goto LABEL_1103;
            v10 = *(_DWORD *)(_printf_function_table + 4 * v368) == 0;
            v358 = 4 * v368;
            if ( v10 )
              goto LABEL_1103;
            v68 = alloca(4 * v54[11] + 15);
            v363 = v54[11];
            if ( v363 )
            {
              v69 = (_DWORD *)v391 + 3 * v54[9];
              for ( k = 0; k != v363; ++k )
              {
                *(_DWORD *)&v355[4 * k] = v69;
                v69 += 3;
              }
            }
            v71 = ((int (__cdecl *)(_DWORD *, int *, _BYTE *))v360[v358 / 4])(v5, v54, v355);
            if ( v71 == -2 )
            {
LABEL_1103:
              v17 = v368 - 32;
              switch ( v368 )
              {
                case ' ':
                case '!':
                case '"':
                case '#':
                case '$':
                case '&':
                case '\'':
                case '(':
                case ')':
                case '*':
                case '+':
                case ',':
                case '-':
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'B':
                case 'D':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case '`':
                case 'b':
                case 'h':
                case 'j':
                case 'k':
                case 'l':
                case 'q':
                case 'r':
                case 't':
                case 'v':
                case 'w':
                case 'y':
                case 'z':
                  v200 = 0;
                  v201 = *((_DWORD *)src + 13 * v384 + 11);
                  v393 = (int)src + 52 * v384;
                  v202 = alloca(4 * v201 + 15);
                  v403 = v201;
                  while ( v200 != v403 )
                  {
                    *(_DWORD *)&v355[4 * v200] = (char *)v391 + 12 * *(_DWORD *)(v393 + 36) + 12 * v200;
                    ++v200;
                  }
                  v203 = v5[22];
                  if ( v203 && (v204 = *(_DWORD **)(v203 + 16), (unsigned int)v204 < *(_DWORD *)(v203 + 20)) )
                  {
                    *v204 = 37;
                    *(_DWORD *)(v203 + 16) = v204 + 1;
                  }
                  else if ( _woverflow((int)v5, 37) == -1 )
                  {
                    goto LABEL_33;
                  }
                  v189 = 1;
                  v205 = *(_BYTE *)(v393 + 12);
                  if ( (v205 & 8) == 0 )
                    goto LABEL_554;
                  v206 = v5[22];
                  if ( v206 && (v207 = *(_DWORD **)(v206 + 16), (unsigned int)v207 < *(_DWORD *)(v206 + 20)) )
                  {
                    *v207 = 35;
                    *(_DWORD *)(v206 + 16) = v207 + 1;
                  }
                  else if ( _woverflow((int)v5, 35) == -1 )
                  {
                    goto LABEL_33;
                  }
                  v189 = 2;
                  v205 = *(_BYTE *)(v393 + 12);
LABEL_554:
                  if ( v205 >= 0 )
                    goto LABEL_559;
                  v208 = v5[22];
                  if ( v208 && (v209 = *(_DWORD **)(v208 + 16), (unsigned int)v209 < *(_DWORD *)(v208 + 20)) )
                  {
                    *v209 = 39;
                    *(_DWORD *)(v208 + 16) = v209 + 1;
                  }
                  else if ( _woverflow((int)v5, 39) == -1 )
                  {
                    goto LABEL_33;
                  }
                  ++v189;
                  v205 = *(_BYTE *)(v393 + 12);
LABEL_559:
                  if ( (v205 & 0x40) != 0 )
                  {
                    v210 = v5[22];
                    if ( v210 && (v211 = *(_DWORD **)(v210 + 16), (unsigned int)v211 < *(_DWORD *)(v210 + 20)) )
                    {
                      *v211 = 43;
                      *(_DWORD *)(v210 + 16) = v211 + 1;
                    }
                    else if ( _woverflow((int)v5, 43) == -1 )
                    {
                      goto LABEL_33;
                    }
LABEL_563:
                    ++v189;
                    v205 = *(_BYTE *)(v393 + 12);
                    goto LABEL_564;
                  }
                  if ( (v205 & 0x10) != 0 )
                  {
                    v235 = v5[22];
                    if ( v235 && (v236 = *(_DWORD **)(v235 + 16), (unsigned int)v236 < *(_DWORD *)(v235 + 20)) )
                    {
                      *v236 = 32;
                      *(_DWORD *)(v235 + 16) = v236 + 1;
                    }
                    else if ( _woverflow((int)v5, 32) == -1 )
                    {
                      goto LABEL_33;
                    }
                    goto LABEL_563;
                  }
LABEL_564:
                  if ( (v205 & 0x20) != 0 )
                  {
                    v212 = v5[22];
                    if ( v212 && (v213 = *(_DWORD **)(v212 + 16), (unsigned int)v213 < *(_DWORD *)(v212 + 20)) )
                    {
                      *v213 = 45;
                      *(_DWORD *)(v212 + 16) = v213 + 1;
                    }
                    else if ( _woverflow((int)v5, 45) == -1 )
                    {
                      goto LABEL_33;
                    }
                    ++v189;
                  }
                  if ( *(_DWORD *)(v393 + 16) == 48 )
                  {
                    v233 = v5[22];
                    if ( v233 && (v234 = *(_DWORD **)(v233 + 16), (unsigned int)v234 < *(_DWORD *)(v233 + 20)) )
                    {
                      *v234 = 48;
                      *(_DWORD *)(v233 + 16) = v234 + 1;
                    }
                    else if ( _woverflow((int)v5, 48) == -1 )
                    {
                      goto LABEL_33;
                    }
                    ++v189;
                  }
                  if ( (*(_BYTE *)(v393 + 13) & 8) != 0 )
                  {
                    v214 = v5[22];
                    if ( v214 && (v215 = *(_DWORD **)(v214 + 16), (unsigned int)v215 < *(_DWORD *)(v214 + 20)) )
                    {
                      *v215 = 73;
                      *(_DWORD *)(v214 + 16) = v215 + 1;
                    }
                    else if ( _woverflow((int)v5, 73) == -1 )
                    {
                      goto LABEL_33;
                    }
                    ++v189;
                  }
                  v216 = *(_DWORD *)(v393 + 4);
                  if ( v216 )
                  {
                    v396 = (int)v407;
                    v217 = v407;
                    v403 = (unsigned int)v5;
                    do
                    {
                      v218 = v216 % 0xA;
                      v216 /= 0xAu;
                      *--v217 = itowa_lower_digits[v218];
                    }
                    while ( v216 );
                    v5 = (_DWORD *)v403;
                    v403 = v11;
                    while ( (unsigned int)v217 < v396 )
                    {
                      v219 = v5[22];
                      v387 = *v217;
                      if ( v219 && (v220 = *(_DWORD **)(v219 + 16), (unsigned int)v220 < *(_DWORD *)(v219 + 20)) )
                      {
                        v221 = v387;
                        *v220 = v387;
                        *(_DWORD *)(v219 + 16) = v220 + 1;
                        if ( v221 == -1 )
                          goto LABEL_33;
                      }
                      else
                      {
                        v357 = v217;
                        v237 = _woverflow((int)v5, v387);
                        v217 = v357;
                        if ( v237 == -1 )
                          goto LABEL_33;
                      }
                      ++v217;
                      ++v189;
                    }
                    v11 = v403;
                  }
                  if ( *(_DWORD *)v393 != -1 )
                  {
                    v222 = v5[22];
                    if ( v222 && (v223 = *(_DWORD **)(v222 + 16), (unsigned int)v223 < *(_DWORD *)(v222 + 20)) )
                    {
                      *v223 = 46;
                      *(_DWORD *)(v222 + 16) = v223 + 1;
                    }
                    else if ( _woverflow((int)v5, 46) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v189 == 0x7FFFFFFF )
                      goto LABEL_33;
                    ++v189;
                    v396 = (int)v407;
                    v403 = (unsigned int)v5;
                    v224 = *(_DWORD *)v393;
                    v225 = v407;
                    do
                    {
                      v226 = v224 % 0xA;
                      v224 /= 0xAu;
                      *--v225 = itowa_lower_digits[v226];
                    }
                    while ( v224 );
                    v5 = (_DWORD *)v403;
                    v403 = v11;
                    while ( (unsigned int)v225 < v396 )
                    {
                      v227 = v5[22];
                      v387 = *v225;
                      if ( v227 && (v228 = *(_DWORD **)(v227 + 16), (unsigned int)v228 < *(_DWORD *)(v227 + 20)) )
                      {
                        v229 = v387;
                        *v228 = v387;
                        *(_DWORD *)(v227 + 16) = v228 + 1;
                        if ( v229 == -1 )
                          goto LABEL_33;
                      }
                      else
                      {
                        v357 = v225;
                        v238 = _woverflow((int)v5, v387);
                        v225 = v357;
                        if ( v238 == -1 )
                          goto LABEL_33;
                      }
                      if ( v189 == 0x7FFFFFFF )
                        goto LABEL_33;
                      ++v225;
                      ++v189;
                    }
                    v11 = v403;
                  }
                  v230 = *(_DWORD *)(v393 + 8);
                  if ( v230 )
                  {
                    v231 = v5[22];
                    if ( v231 && (v232 = *(_DWORD **)(v231 + 16), (unsigned int)v232 < *(_DWORD *)(v231 + 20)) )
                    {
                      *v232 = v230;
                      *(_DWORD *)(v231 + 16) = v232 + 1;
                      if ( v230 == -1 )
                        goto LABEL_33;
                    }
                    else if ( _woverflow((int)v5, *(_DWORD *)(v393 + 8)) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v189 == 0x7FFFFFFF )
                      goto LABEL_33;
                    ++v189;
                  }
                  if ( v11 > 0x7FFFFFFE )
                    _assert_fail(
                      (int)&savedregs,
                      a2,
                      (int)"(unsigned int) done < (unsigned int) 2147483647",
                      (int)"vfprintf.c",
                      2034,
                      "_IO_vfwprintf");
                  if ( v189 > 0x7FFFFFFF - v11 )
                    goto LABEL_33;
LABEL_538:
                  v11 += v189;
                  goto LABEL_126;
                case '%':
                  v294 = v5[22];
                  if ( v294 && (v295 = *(_DWORD **)(v294 + 16), (unsigned int)v295 < *(_DWORD *)(v294 + 20)) )
                  {
                    *v295 = 37;
                    *(_DWORD *)(v294 + 16) = v295 + 1;
                  }
                  else if ( _woverflow((int)v5, 37) == -1 )
                  {
                    goto LABEL_33;
                  }
                  if ( v11 == 0x7FFFFFFF )
                    goto LABEL_33;
                  ++v11;
                  goto LABEL_126;
                case 'A':
                case 'a':
                  v277 = (char *)src + 52 * v384;
                  if ( v277 )
                  {
                    v416 = (long double *)((char *)v391 + 12 * *((_DWORD *)v277 + 9));
                    v71 = _printf_fphex(v5, (int)src + 52 * v384, &v416);
                  }
                  else
                  {
                    v396 = (int)v407;
                    memset(v407, 0, sizeof(v407));
                    BYTE1(v407[3]) = 4;
                    v407[2] = v368;
                    v407[0] = v393;
                    v407[1] = v387;
                    LOBYTE(v407[3]) = ((_BYTE)v365 << 7) | (v367 << 6) | (32 * v364) | (16 * v366) | (8 * v362) | (4 * (v382 & 1)) | (2 * v370) | v371 & 1;
                    v407[4] = v361;
                    if ( v371 )
                    {
                      v280 = *(double *)a5;
                      v281 = a5[2];
                      a5 += 3;
                      v411 = v280;
                      v412 = v281;
                    }
                    else
                    {
                      a2 = *(double *)a5;
                      v411 = *(double *)a5;
                      a5 += 2;
                    }
                    v416 = (long double *)&v411;
                    v71 = _printf_fphex(v5, v396, &v416);
                  }
                  if ( v71 < 0 )
                    goto LABEL_33;
                  if ( v11 > 0x7FFFFFFE )
                    goto LABEL_295;
                  if ( v71 > 0x7FFFFFFF - v11 )
                    goto LABEL_33;
                  break;
                case 'C':
                  goto LABEL_151;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  v131 = (char *)src + 52 * v384;
                  if ( v131 )
                  {
                    v416 = (long double *)((char *)v391 + 12 * *((_DWORD *)v131 + 9));
                    v71 = _printf_fp((int)v5, (int)src + 52 * v384, &v416);
                  }
                  else
                  {
                    v396 = (int)v407;
                    memset(v407, 0, sizeof(v407));
                    v407[2] = v368;
                    v407[0] = v393;
                    v407[1] = v387;
                    LOBYTE(v407[3]) = ((_BYTE)v365 << 7) | (v367 << 6) | (32 * v364) | (16 * v366) | (8 * v362) | (4 * (v382 & 1)) | (2 * v370) | v371 & 1;
                    BYTE1(v407[3]) = (8 * v359) | 4;
                    v407[4] = v361;
                    if ( v371 )
                    {
                      v132 = *(double *)a5;
                      v133 = a5[2];
                      a5 += 3;
                      v411 = v132;
                      v412 = v133;
                    }
                    else
                    {
                      a2 = *(double *)a5;
                      v411 = *(double *)a5;
                      a5 += 2;
                    }
                    v416 = (long double *)&v411;
                    v71 = _printf_fp((int)v5, v396, &v416);
                  }
                  if ( v71 < 0 )
                    goto LABEL_33;
                  if ( v11 > 0x7FFFFFFE )
                    goto LABEL_295;
                  if ( v71 > 0x7FFFFFFF - v11 )
                    goto LABEL_33;
                  break;
                case 'S':
                case 's':
                  v185 = (char *)src + 52 * v384;
                  if ( v185 )
                    v186 = (wchar_t *)*((_DWORD *)v391 + 3 * *((_DWORD *)v185 + 9));
                  else
                    v186 = (wchar_t *)*a5++;
                  goto LABEL_507;
                case 'X':
                case 'x':
                  v382 = 16;
                  goto LABEL_169;
                case 'c':
                  if ( v382 )
                  {
LABEL_151:
                    v84 = v387 - 1;
                    if ( !v364 && v84 > 0 )
                    {
                      v85 = IO_wpadn((int)v5, 32, v387 - 1);
                      if ( v11 > 0x7FFFFFFE )
                        goto LABEL_541;
                      if ( v85 > 0x7FFFFFFF - v11 )
                        goto LABEL_33;
                      v11 += v85;
                    }
                    v86 = (char *)src + 52 * v384;
                    if ( v86 )
                    {
                      v87 = *((_DWORD *)v391 + 3 * *((_DWORD *)v86 + 9));
                      v88 = v5[22];
                      if ( v88 && (v89 = *(int **)(v88 + 16), (unsigned int)v89 < *(_DWORD *)(v88 + 20)) )
                      {
                        *v89 = v87;
                        *(_DWORD *)(v88 + 16) = v89 + 1;
                        if ( v87 == -1 )
                          goto LABEL_33;
                      }
                      else if ( _woverflow((int)v5, v87) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 0x7FFFFFFF )
                        goto LABEL_33;
                      ++v11;
                    }
                    else
                    {
                      v342 = v5[22];
                      v396 = (int)(a5 + 1);
                      v343 = *a5;
                      if ( v342 && (v344 = *(int **)(v342 + 16), (unsigned int)v344 < *(_DWORD *)(v342 + 20)) )
                      {
                        *v344 = v343;
                        *(_DWORD *)(v342 + 16) = v344 + 1;
                        if ( v343 == -1 )
                          goto LABEL_33;
                      }
                      else if ( _woverflow((int)v5, *a5) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 0x7FFFFFFF )
                        goto LABEL_33;
                      ++v11;
                      a5 = (int *)v396;
                    }
                    if ( !v364 || v84 <= 0 )
                      goto LABEL_126;
                    v90 = IO_wpadn((int)v5, 32, v84);
                    if ( v11 > 0x7FFFFFFE )
                      goto LABEL_541;
                    if ( v90 > 0x7FFFFFFF - v11 )
                      goto LABEL_33;
                  }
                  else
                  {
                    v335 = v387 - 1;
                    if ( !v364 && v335 > 0 )
                    {
                      v336 = IO_wpadn((int)v5, 32, v387 - 1);
                      if ( v11 > 0x7FFFFFFE )
                        goto LABEL_541;
                      if ( v336 > 0x7FFFFFFF - v11 )
                        goto LABEL_33;
                      v11 += v336;
                    }
                    v337 = (char *)src + 52 * v384;
                    if ( v337 )
                    {
                      v338 = btowc(*((unsigned __int8 *)v391 + 12 * *((_DWORD *)v337 + 9)));
                      v339 = v5[22];
                      v340 = v338;
                      if ( v339 && (v341 = *(int **)(v339 + 16), (unsigned int)v341 < *(_DWORD *)(v339 + 20)) )
                      {
                        *v341 = v340;
                        *(_DWORD *)(v339 + 16) = v341 + 1;
                        if ( v340 == -1 )
                          goto LABEL_33;
                      }
                      else if ( _woverflow((int)v5, v340) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 0x7FFFFFFF )
                        goto LABEL_33;
                      ++v11;
                    }
                    else
                    {
                      v396 = (int)(a5 + 1);
                      v349 = btowc(*(unsigned __int8 *)a5);
                      v350 = v5[22];
                      v351 = v349;
                      if ( v350 && (v352 = *(int **)(v350 + 16), (unsigned int)v352 < *(_DWORD *)(v350 + 20)) )
                      {
                        *v352 = v351;
                        *(_DWORD *)(v350 + 16) = v352 + 1;
                        if ( v351 == -1 )
                          goto LABEL_33;
                      }
                      else if ( _woverflow((int)v5, v351) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 0x7FFFFFFF )
                        goto LABEL_33;
                      ++v11;
                      a5 = (int *)v396;
                    }
                    if ( !v364 || v335 <= 0 )
                      goto LABEL_126;
                    v90 = IO_wpadn((int)v5, 32, v335);
                    if ( v11 > 0x7FFFFFFE )
LABEL_541:
                      _assert_fail(
                        (int)&savedregs,
                        a2,
                        (int)"(unsigned int) done < (unsigned int) 2147483647",
                        (int)"vfprintf.c",
                        2008,
                        "_IO_vfwprintf");
                    if ( v90 > 0x7FFFFFFF - v11 )
                      goto LABEL_33;
                  }
                  goto LABEL_166;
                case 'd':
                case 'i':
                  v296 = 52 * v384;
                  if ( v371 )
                  {
                    v297 = (char *)src + v296;
                    if ( v297 )
                    {
                      v298 = *(double *)((char *)v391 + 12 * *((_DWORD *)v297 + 9));
                    }
                    else
                    {
                      v298 = *(double *)a5;
                      a5 += 2;
                    }
                    v370 = HIDWORD(v298) >> 31;
                    if ( v298 < 0.0 )
                      *(_QWORD *)&v298 = -*(_QWORD *)&v298;
                    v369 = HIDWORD(v298);
                    v371 = LODWORD(v298);
                    v382 = 10;
                    goto LABEL_172;
                  }
                  v299 = (char *)src + v296;
                  if ( v299 )
                  {
                    v300 = 12 * *((_DWORD *)v299 + 9);
                    if ( v369 )
                    {
                      v301 = *((char *)v391 + v300);
                    }
                    else if ( v370 )
                    {
                      v301 = *(__int16 *)((char *)v391 + v300);
                    }
                    else
                    {
                      v301 = *(_DWORD *)((char *)v391 + v300);
                    }
                  }
                  else if ( v369 )
                  {
                    v301 = *(char *)a5++;
                  }
                  else
                  {
                    if ( v370 )
                      v301 = *(__int16 *)a5;
                    else
                      v301 = *a5;
                    ++a5;
                  }
                  v302 = (unsigned int)v301 >> 31;
                  if ( v301 < 0 )
                    v301 = -v301;
                  v370 = v302;
                  v371 = v301;
                  v382 = 10;
                  goto LABEL_212;
                case 'm':
                  v353 = strerror_r(a2, v400, v405, 0xFA0u);
                  v382 = 0;
                  v186 = (wchar_t *)v353;
LABEL_507:
                  if ( v186 )
                    goto LABEL_508;
                  if ( v393 > 5 || v393 == -1 )
                  {
                    v396 = 0;
                    v189 = 6;
                    v188 = "(";
                  }
                  else
                  {
                    v396 = 0;
                    v189 = 0;
                    v188 = (const char *)&unk_80DC970;
                  }
                  goto LABEL_512;
                case 'n':
                  if ( (v5[15] & 4) != 0 && !v380 )
                  {
                    v347 = wcslen(s);
                    v380 = _readonly_area((unsigned int)s, 4 * v347 + 4);
                    if ( v380 < 0 )
                      goto LABEL_1011;
                  }
                  v345 = (char *)src + 52 * v384;
                  if ( v345 )
                  {
                    v346 = 12 * *((_DWORD *)v345 + 9);
                    if ( v371 )
                    {
                      *(_QWORD *)*(_DWORD *)((char *)v391 + v346) = (int)v11;
                    }
                    else if ( v369 )
                    {
                      **(_BYTE **)((char *)v391 + v346) = v11;
                    }
                    else if ( v370 )
                    {
                      **(_WORD **)((char *)v391 + v346) = v11;
                    }
                    else
                    {
                      **(_DWORD **)((char *)v391 + v346) = v11;
                    }
                  }
                  else
                  {
                    v348 = (_QWORD *)*a5;
                    if ( v371 )
                    {
                      *v348 = (int)v11;
                      ++a5;
                    }
                    else if ( v369 )
                    {
                      *(_BYTE *)v348 = v11;
                      ++a5;
                    }
                    else
                    {
                      if ( v370 )
                        *(_WORD *)v348 = v11;
                      else
                        *(_DWORD *)v348 = v11;
                      ++a5;
                    }
                  }
                  goto LABEL_126;
                case 'o':
                  v382 = 8;
                  goto LABEL_169;
                case 'p':
                  v278 = (char *)src + 52 * v384;
                  if ( v278 )
                    v279 = *((_DWORD *)v391 + 3 * *((_DWORD *)v278 + 9));
                  else
                    v279 = *a5++;
                  if ( v279 )
                  {
                    v371 = v279;
                    v368 = 120;
                    v365 = 0;
                    v362 = 1;
                    v382 = 16;
                    v370 = 0;
                    goto LABEL_212;
                  }
                  if ( v393 <= 4 )
                    v393 = 5;
                  v382 = 0;
                  v186 = (wchar_t *)"(";
LABEL_508:
                  if ( v368 == 83 || v382 )
                  {
                    v356 = (unsigned int)v186;
                    if ( v393 == -1 )
                      v187 = wcslen(v186);
                    else
                      v187 = wcsnlen(v186, v393);
                    v188 = (const char *)v356;
                    v396 = 0;
                    v189 = v187;
                  }
                  else
                  {
                    v416 = (long double *)v186;
                    if ( v393 == -1 )
                      v393 = strlen((const char *)v186);
                    else
                      v393 = strnlen(v186, v393);
                    v195 = 4 * v393;
                    if ( (unsigned int)(4 * v393) <= 0x1000 || _libc_alloca_cutoff(4 * v393) )
                    {
                      v196 = alloca(v195 + 15);
                      v197 = v355;
                      v396 = 0;
                    }
                    else
                    {
                      malloc(a2, v195);
                      v197 = v199;
                      if ( !v199 )
                        goto LABEL_33;
                      v396 = 1;
                    }
                    v404 = v414;
                    memset(v414, 0, sizeof(v414));
                    v356 = (unsigned int)v197;
                    v198 = mbsrtowcs(a2, (int)v197, &v416, v393, v414);
                    v188 = (const char *)v356;
                    v189 = v198;
                    if ( v198 == -1 )
                      goto LABEL_33;
                  }
LABEL_512:
                  v190 = (int *)(v387 - v189);
                  if ( (int)(v387 - v189) < 0 )
                  {
                    if ( (v11 & 0x80000000) != 0 )
LABEL_656:
                      _assert_fail(
                        (int)&savedregs,
                        a2,
                        (int)"(size_t) done <= (size_t) 2147483647",
                        (int)"vfprintf.c",
                        2008,
                        "_IO_vfwprintf");
                    if ( v189 != (*(int (__cdecl **)(_DWORD *, const char *, unsigned int))(v5[37] + 28))(
                                   v5,
                                   v188,
                                   v189)
                      || v189 > 0x7FFFFFFF - v11 )
                    {
                      goto LABEL_33;
                    }
                    goto LABEL_538;
                  }
                  if ( !v364 && v190 )
                  {
                    v356 = (unsigned int)v188;
                    v357 = (int *)(v387 - v189);
                    v191 = IO_wpadn((int)v5, 32, v387 - v189);
                    v188 = (const char *)v356;
                    v190 = v357;
                    v393 = v191;
                    if ( v11 > 0x7FFFFFFE )
                      goto LABEL_541;
                    if ( v393 > 0x7FFFFFFF - v11 )
                      goto LABEL_33;
                    v11 += v393;
                  }
                  if ( (v11 & 0x80000000) != 0 )
                    goto LABEL_656;
                  v192 = v5[37];
                  v356 = (unsigned int)v188;
                  v357 = v190;
                  v193 = (*(int (__cdecl **)(_DWORD *, const char *, unsigned int))(v192 + 28))(v5, v188, v189);
                  v194 = v356;
                  if ( v189 != v193 || v189 > 0x7FFFFFFF - v11 )
                    goto LABEL_33;
                  v11 += v189;
                  if ( v364 && v357 )
                  {
                    v239 = IO_wpadn((int)v5, 32, (int)v357);
                    v194 = v356;
                    if ( v11 > 0x7FFFFFFE )
                      goto LABEL_541;
                    if ( v239 > 0x7FFFFFFF - v11 )
                      goto LABEL_33;
                    v11 += v239;
                  }
                  if ( v396 )
                    free(v194);
                  goto LABEL_126;
                case 'u':
                  v382 = 10;
LABEL_169:
                  v91 = 52 * v384;
                  if ( v371 )
                  {
                    v92 = (char *)src + v91;
                    if ( v92 )
                    {
                      v93 = (unsigned int *)v391 + 3 * *((_DWORD *)v92 + 9);
                      v367 = 0;
                      v366 = 0;
                      v94 = *v93;
                      v95 = v93[1];
                      v370 = 0;
                      v371 = v94;
                      v369 = v95;
                    }
                    else
                    {
                      v367 = 0;
                      v366 = 0;
                      v129 = a5[1];
                      v130 = *a5;
                      v370 = 0;
                      v369 = v129;
                      v371 = v130;
                      a5 += 2;
                    }
LABEL_172:
                    if ( v393 < 0 )
                    {
                      v393 = 1;
                    }
                    else
                    {
                      v361 = 32;
                      if ( !v393 && !(v371 | v369) )
                      {
                        v96 = (int *)v396;
                        if ( v362 && v382 == 8 )
                        {
                          v96 = (int *)(v396 - 4);
                          *(_DWORD *)(v396 - 4) = 48;
                        }
                        else
                        {
                          v361 = 32;
                        }
LABEL_178:
                        v371 = (v369 | v371) != 0;
                        goto LABEL_179;
                      }
                    }
                    v128 = itowa(__PAIR64__(v369, v371), (int *)v396, v382, v368 == 88);
                    v96 = v128;
                    if ( v386 && v365 )
                      v96 = (int *)group_number_0(v128, (_BYTE *)v396, (_BYTE *)v386, v381);
                    if ( v382 == 10 && v359 )
                      v96 = (int *)i18n_number_rewrite_1(v96, v396, v396, a2);
                    goto LABEL_178;
                  }
                  v105 = (char *)src + v91;
                  if ( v105 )
                  {
                    v106 = 12 * *((_DWORD *)v105 + 9);
                    if ( v369 )
                    {
                      v367 = 0;
                      v366 = 0;
                      v370 = 0;
                      v371 = *((unsigned __int8 *)v391 + v106);
                    }
                    else
                    {
                      v367 = 0;
                      v366 = 0;
                      if ( v370 )
                      {
                        v370 = 0;
                        v136 = *(unsigned __int16 *)((char *)v391 + v106);
                      }
                      else
                      {
                        v370 = 0;
                        v136 = *(_DWORD *)((char *)v391 + v106);
                      }
                      v371 = v136;
                    }
                  }
                  else
                  {
                    if ( v369 )
                    {
                      v137 = *(unsigned __int8 *)a5;
                    }
                    else if ( v370 )
                    {
                      v137 = *(unsigned __int16 *)a5;
                    }
                    else
                    {
                      v137 = *a5;
                    }
                    v371 = v137;
                    v367 = 0;
                    v366 = 0;
                    ++a5;
                    v370 = 0;
                  }
LABEL_212:
                  if ( v393 < 0 )
                  {
                    v393 = 1;
                  }
                  else
                  {
                    v361 = 32;
                    if ( !v393 && !v371 )
                    {
                      v96 = (int *)v396;
                      if ( v362 && v382 == 8 )
                      {
                        v96 = (int *)(v396 - 4);
                        v382 = 8;
                        *(_DWORD *)(v396 - 4) = 48;
                      }
                      else
                      {
                        v361 = 32;
                      }
                      goto LABEL_179;
                    }
                  }
                  v112 = (int *)&itowa_upper_digits;
                  v113 = v371;
                  if ( v368 != 88 )
                    v112 = itowa_lower_digits;
                  if ( v382 == 10 )
                  {
                    v96 = (int *)v396;
                    v117 = v371;
                    v403 = (unsigned int)v5;
                    do
                    {
                      v118 = v117 % 0xA;
                      v117 /= 0xAu;
                      *--v96 = v112[v118];
                    }
                    while ( v117 );
                    v5 = (_DWORD *)v403;
                  }
                  else if ( v382 == 16 )
                  {
                    v96 = (int *)v396;
                    do
                    {
                      --v96;
                      v116 = v112[v113 & 0xF];
                      v113 >>= 4;
                      *v96 = v116;
                    }
                    while ( v113 );
                  }
                  else
                  {
                    v96 = (int *)v396;
                    do
                    {
                      --v96;
                      v115 = v112[v113 & 7];
                      v113 >>= 3;
                      *v96 = v115;
                    }
                    while ( v113 );
                  }
                  if ( v386 && v365 )
                    v96 = (int *)group_number_0(v96, (_BYTE *)v396, (_BYTE *)v386, v381);
                  if ( v382 == 10 && v359 )
                  {
                    v114 = (int *)i18n_number_rewrite_1(v96, v396, v396, a2);
                    v382 = 10;
                    v96 = v114;
                  }
LABEL_179:
                  if ( v393 <= (v396 - (int)v96) >> 2 && v362 && v371 && v382 == 8 )
                    *--v96 = 48;
                  v369 = 0;
                  v396 -= (int)v96;
                  v97 = v393 - (v396 >> 2);
                  if ( v97 < 0 )
                    v97 = v369;
                  v365 = -(v396 >> 2);
                  v369 = v97;
                  if ( !v364 )
                  {
                    v98 = v387 + -(v396 >> 2) - v369;
                    v393 = v98;
                    LOBYTE(v387) = v362;
                    if ( v362 && v371 )
                    {
                      v99 = v98 - 2;
                      if ( v382 != 16 )
                        v99 = v393;
                      v393 = v99;
                    }
                    v393 = (!v367 && !v370 && !v366) + v393 - 1;
                    if ( v361 == 32 )
                    {
                      if ( v393 <= 0 )
                      {
                        v393 = 0;
                      }
                      else
                      {
                        v143 = IO_wpadn((int)v5, 32, v393);
                        if ( v11 > 0x7FFFFFFE )
                          goto LABEL_295;
                        if ( v143 > 0x7FFFFFFF - v11 )
                          goto LABEL_33;
                        v11 += v143;
                        v393 = 0;
                      }
                    }
                    if ( v370 )
                    {
                      v100 = v5[22];
                      if ( v100 && (v101 = *(_DWORD **)(v100 + 16), (unsigned int)v101 < *(_DWORD *)(v100 + 20)) )
                      {
                        *v101 = 45;
                        *(_DWORD *)(v100 + 16) = v101 + 1;
                      }
                      else if ( _woverflow((int)v5, 45) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 0x7FFFFFFF )
                        goto LABEL_33;
                      goto LABEL_198;
                    }
                    if ( v367 )
                    {
                      v134 = v5[22];
                      if ( v134 && (v135 = *(_DWORD **)(v134 + 16), (unsigned int)v135 < *(_DWORD *)(v134 + 20)) )
                      {
                        *v135 = 43;
                        *(_DWORD *)(v134 + 16) = v135 + 1;
                      }
                      else if ( _woverflow((int)v5, 43) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 0x7FFFFFFF )
                        goto LABEL_33;
                      goto LABEL_198;
                    }
                    if ( v366 )
                    {
                      v144 = v5[22];
                      if ( v144 && (v145 = *(_DWORD **)(v144 + 16), (unsigned int)v145 < *(_DWORD *)(v144 + 20)) )
                      {
                        *v145 = 32;
                        *(_DWORD *)(v144 + 16) = v145 + 1;
                      }
                      else if ( _woverflow((int)v5, 32) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 0x7FFFFFFF )
                        goto LABEL_33;
LABEL_198:
                      ++v11;
                    }
                    if ( (_BYTE)v387 && v371 && v382 == 16 )
                    {
                      v138 = v5[22];
                      if ( v138 && (v139 = *(_DWORD **)(v138 + 16), (unsigned int)v139 < *(_DWORD *)(v138 + 20)) )
                      {
                        *v139 = 48;
                        *(_DWORD *)(v138 + 16) = v139 + 1;
                      }
                      else if ( _woverflow((int)v5, 48) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 0x7FFFFFFF )
                        goto LABEL_33;
                      v140 = v5[22];
                      if ( v140 && (v141 = *(_DWORD **)(v140 + 16), (unsigned int)v141 < *(_DWORD *)(v140 + 20)) )
                      {
                        v142 = v368;
                        *v141 = v368;
                        *(_DWORD *)(v140 + 16) = v141 + 1;
                        if ( v142 == -1 )
                          goto LABEL_33;
                      }
                      else if ( _woverflow((int)v5, v368) == -1 )
                      {
                        goto LABEL_33;
                      }
                      if ( v11 == 2147483646 )
                        goto LABEL_33;
                      v11 += 2;
                    }
                    if ( (int)(v369 + v393) > 0 )
                    {
                      v102 = IO_wpadn((int)v5, 48, v369 + v393);
                      if ( v11 > 0x7FFFFFFE )
                        goto LABEL_295;
                      if ( v102 > 0x7FFFFFFF - v11 )
                        goto LABEL_33;
                      v11 += v102;
                    }
                    if ( (v11 & 0x80000000) != 0 )
                      goto LABEL_314;
                    v103 = v5[37];
                    v356 = v396 >> 2;
                    v104 = (*(int (__cdecl **)(_DWORD *, int *, int))(v103 + 28))(v5, v96, v396 >> 2);
                    v90 = v356;
                    if ( v356 != v104 || v356 > 0x7FFFFFFF - v11 )
                      goto LABEL_33;
LABEL_166:
                    v11 += v90;
                    goto LABEL_126;
                  }
                  if ( v370 )
                  {
                    v107 = v5[22];
                    if ( v107 && (v108 = *(_DWORD **)(v107 + 16), (unsigned int)v108 < *(_DWORD *)(v107 + 20)) )
                    {
                      *v108 = 45;
                      *(_DWORD *)(v107 + 16) = v108 + 1;
                    }
                    else if ( _woverflow((int)v5, 45) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v11 == 0x7FFFFFFF )
                      goto LABEL_33;
LABEL_223:
                    --v387;
                    ++v11;
                    goto LABEL_224;
                  }
                  if ( v367 )
                  {
                    v119 = v5[22];
                    if ( v119 && (v120 = *(_DWORD **)(v119 + 16), (unsigned int)v120 < *(_DWORD *)(v119 + 20)) )
                    {
                      *v120 = 43;
                      *(_DWORD *)(v119 + 16) = v120 + 1;
                    }
                    else if ( _woverflow((int)v5, 43) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v11 == 0x7FFFFFFF )
                      goto LABEL_33;
                    goto LABEL_223;
                  }
                  if ( v366 )
                  {
                    v126 = v5[22];
                    if ( v126 && (v127 = *(_DWORD **)(v126 + 16), (unsigned int)v127 < *(_DWORD *)(v126 + 20)) )
                    {
                      *v127 = 32;
                      *(_DWORD *)(v126 + 16) = v127 + 1;
                    }
                    else if ( _woverflow((int)v5, 32) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v11 == 0x7FFFFFFF )
                      goto LABEL_33;
                    goto LABEL_223;
                  }
LABEL_224:
                  if ( v362 && v371 && v382 == 16 )
                  {
                    v121 = v5[22];
                    if ( v121 && (v122 = *(_DWORD **)(v121 + 16), (unsigned int)v122 < *(_DWORD *)(v121 + 20)) )
                    {
                      *v122 = 48;
                      *(_DWORD *)(v121 + 16) = v122 + 1;
                    }
                    else if ( _woverflow((int)v5, 48) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v11 == 0x7FFFFFFF )
                      goto LABEL_33;
                    v123 = v5[22];
                    if ( v123 && (v124 = *(_DWORD **)(v123 + 16), (unsigned int)v124 < *(_DWORD *)(v123 + 20)) )
                    {
                      v125 = v368;
                      *v124 = v368;
                      *(_DWORD *)(v123 + 16) = v124 + 1;
                      if ( v125 == -1 )
                        goto LABEL_33;
                    }
                    else if ( _woverflow((int)v5, v368) == -1 )
                    {
                      goto LABEL_33;
                    }
                    if ( v11 == 2147483646 )
                      goto LABEL_33;
                    v11 += 2;
                    v387 -= 2;
                  }
                  if ( v369 )
                  {
                    v109 = IO_wpadn((int)v5, 48, v369);
                    if ( v11 > 0x7FFFFFFE )
                      goto LABEL_295;
                    if ( v109 > 0x7FFFFFFF - v11 )
                      goto LABEL_33;
                    v11 += v109;
                  }
                  if ( (v11 & 0x80000000) != 0 )
LABEL_314:
                    _assert_fail(
                      (int)&savedregs,
                      a2,
                      (int)"(size_t) done <= (size_t) 2147483647",
                      (int)"vfprintf.c",
                      2007,
                      "_IO_vfwprintf");
                  v110 = v5[37];
                  v356 = v396 >> 2;
                  v111 = (*(int (__cdecl **)(_DWORD *, int *, int))(v110 + 28))(v5, v96, v396 >> 2);
                  if ( v356 != v111 || v356 > 0x7FFFFFFF - v11 )
                    goto LABEL_33;
                  v11 += v356;
                  if ( (int)(v387 + v365 - v369) <= 0 )
                    goto LABEL_126;
                  v71 = IO_wpadn((int)v5, 32, v387 + v365 - v369);
                  if ( v11 > 0x7FFFFFFE )
LABEL_295:
                    _assert_fail(
                      (int)&savedregs,
                      a2,
                      (int)"(unsigned int) done < (unsigned int) 2147483647",
                      (int)"vfprintf.c",
                      2007,
                      "_IO_vfwprintf");
                  if ( v71 > 0x7FFFFFFF - v11 )
                    goto LABEL_33;
                  break;
                default:
                  goto LABEL_37;
              }
            }
            else
            {
              if ( v71 < 0 )
                goto LABEL_33;
              if ( v11 > 0x7FFFFFFE )
                _assert_fail(
                  (int)&savedregs,
                  a2,
                  (int)"(unsigned int) done < (unsigned int) 2147483647",
                  (int)"vfprintf.c",
                  2000,
                  "_IO_vfwprintf");
              if ( v71 > 0x7FFFFFFF - v11 )
                goto LABEL_33;
            }
            v11 += v71;
LABEL_126:
            free(v402);
            if ( (v11 & 0x80000000) != 0 )
              _assert_fail(
                (int)&savedregs,
                a2,
                (int)"(size_t) done <= (size_t) 2147483647",
                (int)"vfprintf.c",
                2045,
                "_IO_vfwprintf");
            v72 = (char *)src + 52 * v384;
            v73 = (*(int (__cdecl **)(_DWORD *, _DWORD, int))(v5[37] + 28))(
                    v5,
                    *((_DWORD *)v72 + 5),
                    (*((_DWORD *)v72 + 6) - *((_DWORD *)v72 + 5)) >> 2);
            if ( v73 != (*((_DWORD *)v72 + 6) - *((_DWORD *)v72 + 5)) >> 2 )
            {
              v402 = 0;
              goto LABEL_33;
            }
            if ( v73 > 0x7FFFFFFF - v11 )
            {
              v402 = 0;
              goto LABEL_33;
            }
            ++v384;
            v11 += v73;
          }
          v402 = 0;
LABEL_33:
          if ( v388 )
            free(src);
        }
        else
        {
          v398 = 0;
          v402 = 0;
        }
        free(v398);
        free(v402);
        if ( (BYTE1(*v5) & 0x80u) != 0 )
          goto LABEL_20;
        v13 = (_DWORD *)v5[18];
        v10 = v13[1]-- == 1;
        if ( !v10 )
          goto LABEL_20;
        v13[2] = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v10 = (*v13)-- == 1;
        if ( !v10 )
        {
          L_unlock_696(v12, v13);
        }
        else
        {
LABEL_20:
          if ( v399 )
            MEMORY[0](v408, 0);
        }
      }
    }
  }
}
// 80A5B33: conditional instruction was optimized away because %var_10B4.4==8
// 80A846D: conditional instruction was optimized away because %var_1088.4==8
// 80A4E38: variable 'v32' is possibly undefined
// 80A6491: variable 'v147' is possibly undefined
// 80A6A5E: variable 'v169' is possibly undefined
// 80A6B3E: variable 'v176' is possibly undefined
// 80A6C93: variable 'v180' is possibly undefined
// 80A6D86: variable 'v182' is possibly undefined
// 80A7138: variable 'v199' is possibly undefined
// 80A8CA5: variable 'v322' is possibly undefined
// 80A49ED: variable 'v12' is possibly undefined
// 8048210: using guessed type int __cdecl strnlen(_DWORD, _DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80DC620: using guessed type int itowa_lower_digits[36];
// 80F129C: using guessed type int _printf_function_table;
// 80F12A0: using guessed type int _printf_modifier_table;
// 80F137C: using guessed type int _printf_arginfo_table;
// 80F1380: using guessed type int _printf_va_arg_table;
// 80A4870: using guessed type unsigned int var_1C[7];

//----- (080A9650) --------------------------------------------------------
void __usercall buffered_vfprintf_0(
        int a1@<ecx>,
        wchar_t *s@<edx>,
        _DWORD *a3@<eax>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  int v10; // edx
  unsigned int v13; // ebp
  bool v14; // zf
  int v15; // edx
  _DWORD *v16; // edx
  char v17[32768]; // [esp+1Ch] [ebp-8190h] BYREF
  int v18[22]; // [esp+801Ch] [ebp-190h] BYREF
  char *v19; // [esp+8074h] [ebp-138h]
  int v20; // [esp+8084h] [ebp-128h]
  void *v21; // [esp+80B0h] [ebp-FCh]
  char v22; // [esp+80B4h] [ebp-F8h] BYREF
  char *v23; // [esp+80C0h] [ebp-ECh]
  char *v24; // [esp+80C4h] [ebp-E8h]
  int *v25; // [esp+80C8h] [ebp-E4h]
  _DWORD *v26; // [esp+8170h] [ebp-3Ch]
  void (__cdecl *v27)(int); // [esp+8180h] [ebp-2Ch]
  _DWORD *v28; // [esp+8184h] [ebp-28h]
  int v29; // [esp+819Ch] [ebp-10h]
  int v30; // [esp+81A0h] [ebp-Ch]
  int v31; // [esp+81A4h] [ebp-8h]
  int v32; // [esp+81A8h] [ebp-4h]

  v29 = a4;
  v30 = a7;
  v31 = a6;
  v32 = a5;
  if ( IO_fwide((int)a3, 1) == 1 )
  {
    v19 = &v22;
    v24 = v17;
    v23 = v17;
    v10 = a3[15];
    v26 = a3;
    v25 = v18;
    v20 = 1;
    v18[0] = -72515580;
    v18[18] = 0;
    v18[15] = v10;
    v21 = &IO_helper_jumps_0;
    vfwprintf((int)v18, s, a1);
    v27 = funlockfile;
    v28 = a3;
    if ( (*a3 & 0x8000) == 0 )
    {
      _EDX = a3[18];
      v13 = __readgsdword(8u);
      if ( v13 != *(_DWORD *)(_EDX + 8) )
      {
        _ECX = 1;
        v14 = __readgsdword(0xCu) == 0;
        if ( !v14 )
          __asm { lock }
        __asm { cmpxchg [edx], ecx }
        if ( !v14 )
        {
          L_lock_12760(0, (volatile __int32 *)_EDX);
          return;
        }
        _EDX = a3[18];
        *(_DWORD *)(_EDX + 8) = v13;
      }
      ++*(_DWORD *)(_EDX + 4);
    }
    v15 = *((_DWORD *)v19 + 3);
    if ( (*((_DWORD *)v19 + 4) - v15) >> 2 > 0 )
      (*(int (__cdecl **)(_DWORD *, int, int))(a3[37] + 28))(a3, v15, (*((_DWORD *)v19 + 4) - v15) >> 2);
    if ( (BYTE1(*a3) & 0x80u) == 0 )
    {
      v16 = (_DWORD *)a3[18];
      v14 = v16[1]-- == 1;
      if ( v14 )
      {
        v16[2] = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v14 = (*v16)-- == 1;
        if ( !v14 )
          L_unlock_12810(_ECX, v16);
      }
    }
  }
}
// 80A97D5: variable '_ECX' is possibly undefined

//----- (080A9848) --------------------------------------------------------
void __usercall L_lock_612(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x80A4955);
}
// 80A984F: control flows out of bounds to 80A4955

//----- (080A9854) --------------------------------------------------------
void __fastcall L_unlock_696(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x80A49F3);
}
// 80A985B: control flows out of bounds to 80A49F3

//----- (080A9860) --------------------------------------------------------
void __usercall L_lock_12760(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x80A976B);
}
// 80A9867: control flows out of bounds to 80A976B

//----- (080A986C) --------------------------------------------------------
void __fastcall L_unlock_12810(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x80A97DB);
}
// 80A9873: control flows out of bounds to 80A97DB

//----- (080A9880) --------------------------------------------------------
int __cdecl _parse_one_specwc(int *a1, int a2, int a3, unsigned int *a4)
{
  int v4; // ebx
  int *v5; // edx
  char v6; // bp
  int v7; // ebp
  int v8; // edi
  unsigned int v9; // eax
  int v10; // esi
  _DWORD *v11; // ecx
  unsigned int v12; // esi
  int *v13; // ecx
  _DWORD *v14; // edx
  int v15; // edi
  int *v16; // eax
  unsigned int v17; // eax
  int v18; // esi
  int v19; // eax
  int v20; // ecx
  int *v21; // eax
  int v22; // eax
  int v23; // edi
  int *v24; // eax
  int v26; // ecx
  unsigned int v27; // ecx
  int *v28; // esi
  int v29; // ecx
  int *v30; // eax
  int v31; // eax
  int v32; // eax
  unsigned int v33; // eax
  int v34; // ecx
  unsigned int v35; // ecx
  int v36; // eax
  int *v37; // esi
  unsigned int v38; // eax
  int v39; // edi
  _DWORD *v40; // ecx
  unsigned int i; // edx
  int v42; // ebp
  char v43; // al
  char v44; // bp
  unsigned int *v45; // edi
  char v46; // al
  int v47; // eax
  int v48; // eax
  int *v49; // edi
  unsigned int v50; // eax
  int v51; // ebp
  _DWORD *v52; // ecx
  unsigned int j; // edx
  unsigned int *v54; // ebp
  int v55; // eax
  int v56; // edx
  unsigned int *v57; // edi
  int v58; // eax
  int (__cdecl *v59)(int, int, int, int); // eax
  int v60; // eax
  int *v61; // [esp+14h] [ebp-28h]
  int v62; // [esp+14h] [ebp-28h]
  int v63; // [esp+18h] [ebp-24h]
  int *v64; // [esp+1Ch] [ebp-20h]

  v4 = a3;
  v5 = a1 + 1;
  v61 = a1++;
  v6 = *(_BYTE *)(a3 + 12);
  *(_DWORD *)(a3 + 36) = -1;
  *(_DWORD *)(v4 + 16) = 32;
  v7 = v6 & 7;
  *(_BYTE *)(v4 + 12) = v7;
  *(_BYTE *)(v4 + 13) = *(_BYTE *)(v4 + 13) & 0xF2 | 4;
  v8 = v61[1];
  v9 = v8 - 48;
  if ( (unsigned int)(v8 - 48) <= 9 )
  {
    v10 = v61[2];
    v11 = v61 + 2;
    a1 = v61 + 2;
    v63 = v10;
    v12 = v10 - 48;
    if ( v12 <= 9 )
    {
      v13 = v61;
      v64 = v5;
      v62 = v8;
      v14 = v13 + 3;
      do
      {
        v15 = *v14;
        v11 = v14;
        v9 = v12 + 10 * v9;
        ++v14;
        v12 = v15 - 48;
      }
      while ( (unsigned int)(v15 - 48) <= 9 );
      v63 = v15;
      v5 = v64;
      v8 = v62;
    }
    if ( v9 && v63 == 36 )
    {
      v45 = a4;
      *(_DWORD *)(v4 + 36) = v9 - 1;
      v5 = v11 + 1;
      a1 = v11 + 1;
      if ( v9 < *v45 )
        v9 = *v45;
      *v45 = v9;
      v8 = v11[1];
      v7 = *(unsigned __int8 *)(v4 + 12);
    }
    else
    {
      a1 = v5;
    }
  }
  v16 = v5;
  while ( 2 )
  {
    switch ( v8 )
    {
      case ' ':
        v7 |= 0x10u;
        *(_BYTE *)(v4 + 12) = v7;
        goto LABEL_30;
      case '#':
        v7 |= 8u;
        *(_BYTE *)(v4 + 12) = v7;
        goto LABEL_30;
      case '\'':
        v7 |= 0xFFFFFF80;
        *(_BYTE *)(v4 + 12) = v7;
        goto LABEL_30;
      case '+':
        v7 |= 0x40u;
        *(_BYTE *)(v4 + 12) = v7;
        goto LABEL_30;
      case '-':
        v7 |= 0x20u;
        *(_BYTE *)(v4 + 12) = v7;
        goto LABEL_30;
      case '0':
        *(_DWORD *)(v4 + 16) = 48;
        v8 = v5[1];
        v16 = v5 + 1;
        if ( !v8 )
          goto LABEL_33;
        goto LABEL_31;
      case 'I':
        *(_BYTE *)(v4 + 13) |= 8u;
LABEL_30:
        v8 = v5[1];
        v16 = v5 + 1;
        if ( v8 )
        {
LABEL_31:
          v5 = v16;
          continue;
        }
LABEL_33:
        a1 = v16;
        v5 = v16;
LABEL_11:
        if ( (v7 & 0x20) != 0 )
          *(_DWORD *)(v4 + 16) = 32;
        *(_DWORD *)(v4 + 32) = -1;
        *(_DWORD *)(v4 + 4) = 0;
        if ( *v5 == 42 )
        {
          v36 = v5[1];
          v37 = v5 + 1;
          a1 = v5 + 1;
          v38 = v36 - 48;
          if ( v38 > 9 )
            goto LABEL_60;
          v39 = v5[2];
          v40 = v5 + 2;
          a1 = v5 + 2;
          for ( i = v39 - 48; i <= 9; i = *v40 - 48 )
          {
            v39 = *++v40;
            v38 = i + 10 * v38;
          }
          if ( !v38 || v39 != 36 )
            goto LABEL_60;
          v57 = a4;
          *(_DWORD *)(v4 + 32) = v38 - 1;
          if ( v38 < *v57 )
            v38 = *v57;
          *v57 = v38;
          v58 = *(_DWORD *)(v4 + 32);
          v5 = v40 + 1;
          a1 = v40 + 1;
          if ( v58 >= 0 )
          {
            v18 = 0;
          }
          else
          {
LABEL_60:
            v42 = a2;
            v5 = v37;
            a1 = v37;
            v18 = 1;
            *(_DWORD *)(v4 + 32) = a2;
            a2 = v42 + 1;
          }
        }
        else
        {
          v17 = *v5 - 48;
          v18 = 0;
          if ( v17 <= 9 )
          {
            v26 = v5[1];
            a1 = v5 + 1;
            v27 = v26 - 48;
            if ( v27 > 9 )
            {
              ++v5;
            }
            else
            {
              v28 = v5 + 2;
              do
              {
                v5 = v28;
                v17 = v27 + 10 * v17;
                v29 = *v28++;
                v27 = v29 - 48;
              }
              while ( v27 <= 9 );
              a1 = v5;
            }
            *(_DWORD *)(v4 + 4) = v17;
            v18 = 0;
          }
        }
        *(_DWORD *)(v4 + 28) = -1;
        *(_DWORD *)v4 = -1;
        if ( *v5 == 46 )
        {
          v32 = v5[1];
          a1 = v5 + 1;
          if ( v32 == 42 )
          {
            v48 = v5[2];
            v49 = v5 + 2;
            a1 = v5 + 2;
            v50 = v48 - 48;
            if ( v50 > 9 )
              goto LABEL_89;
            v51 = v5[3];
            v52 = v5 + 3;
            a1 = v5 + 3;
            for ( j = v51 - 48; j <= 9; j = *v52 - 48 )
            {
              v51 = *++v52;
              v50 = j + 10 * v50;
            }
            if ( !v50 || v51 != 36 )
              goto LABEL_89;
            v54 = a4;
            *(_DWORD *)(v4 + 28) = v50 - 1;
            if ( v50 < *v54 )
              v50 = *v54;
            *v54 = v50;
            v55 = *(_DWORD *)(v4 + 28);
            v5 = v52 + 1;
            a1 = v52 + 1;
            if ( v55 < 0 )
            {
LABEL_89:
              v56 = a2;
              ++v18;
              a1 = v49;
              *(_DWORD *)(v4 + 28) = a2;
              a2 = v56 + 1;
              v5 = v49;
            }
          }
          else
          {
            v33 = v32 - 48;
            if ( v33 > 9 )
            {
              *(_DWORD *)v4 = 0;
              ++v5;
            }
            else
            {
              v34 = v5[2];
              a1 = v5 + 2;
              v5 += 2;
              v35 = v34 - 48;
              if ( v35 <= 9 )
              {
                do
                {
                  ++v5;
                  v33 = v35 + 10 * v33;
                  v35 = *v5 - 48;
                }
                while ( v35 <= 9 );
                a1 = v5;
              }
              *(_DWORD *)v4 = v33;
            }
          }
        }
        *(_BYTE *)(v4 + 12) &= 0xF8u;
        *(_BYTE *)(v4 + 13) &= ~2u;
        v19 = _printf_modifier_table;
        *(_WORD *)(v4 + 14) = 0;
        if ( v19 && *(_DWORD *)(v19 + 4 * *v5) && (v22 = _handle_registered_modifier_wc(&a1, v4), v5 = a1, !v22) )
        {
          v20 = *a1;
          v21 = a1 + 1;
        }
        else
        {
          v20 = *v5;
          v21 = v5 + 1;
          a1 = v5 + 1;
          switch ( v20 )
          {
            case 'L':
            case 'q':
              v44 = *(_BYTE *)(v4 + 12);
              goto LABEL_68;
            case 'Z':
            case 't':
            case 'z':
              *(_BYTE *)(v4 + 12) &= 0xFAu;
              v20 = v5[1];
              v21 = v5 + 2;
              break;
            case 'h':
              if ( v5[1] == 104 )
              {
                *(_BYTE *)(v4 + 13) |= 2u;
                v20 = v5[2];
                v21 = v5 + 3;
              }
              else
              {
                *(_BYTE *)(v4 + 12) |= 2u;
                v20 = v5[1];
                v21 = v5 + 2;
              }
              break;
            case 'j':
              *(_BYTE *)(v4 + 12) |= 5u;
              v20 = v5[1];
              v21 = v5 + 2;
              break;
            case 'l':
              v43 = *(_BYTE *)(v4 + 12) | 4;
              *(_BYTE *)(v4 + 12) = v43;
              v20 = v5[1];
              v44 = v43;
              v21 = v5 + 2;
              if ( v20 == 108 )
              {
LABEL_68:
                *(_BYTE *)(v4 + 12) = v44 | 1;
                v20 = *v21++;
              }
              break;
            default:
              break;
          }
        }
        v23 = _printf_function_table;
        *(_DWORD *)(v4 + 8) = v20;
        a1 = v21;
        *(_DWORD *)(v4 + 48) = -1;
        if ( v23 && v20 <= 255 && (v59 = *(int (__cdecl **)(int, int, int, int))(_printf_arginfo_table + 4 * v20)) != 0 )
        {
          v60 = v59(v4, 1, v4 + 40, v4 + 48);
          *(_DWORD *)(v4 + 44) = v60;
          if ( v60 < 0 )
          {
            v20 = *(_DWORD *)(v4 + 8);
            goto LABEL_22;
          }
        }
        else
        {
LABEL_22:
          *(_DWORD *)(v4 + 44) = 1;
          switch ( v20 )
          {
            case 'A':
            case 'E':
            case 'F':
            case 'G':
            case 'a':
            case 'e':
            case 'f':
            case 'g':
              v47 = -((*(_BYTE *)(v4 + 12) & 1) == 0);
              LOBYTE(v47) = 0;
              *(_DWORD *)(v4 + 40) = v47 + 263;
              break;
            case 'C':
              *(_DWORD *)(v4 + 40) = 2;
              break;
            case 'S':
              *(_DWORD *)(v4 + 40) = 4;
              break;
            case 'X':
            case 'd':
            case 'i':
            case 'o':
            case 'u':
            case 'x':
              v46 = *(_BYTE *)(v4 + 12);
              if ( (v46 & 1) != 0 )
              {
                *(_DWORD *)(v4 + 40) = 256;
              }
              else if ( (v46 & 4) != 0 )
              {
                *(_DWORD *)(v4 + 40) = 512;
              }
              else if ( (v46 & 2) != 0 )
              {
                *(_DWORD *)(v4 + 40) = 1024;
              }
              else
              {
                *(_DWORD *)(v4 + 40) = (*(_BYTE *)(v4 + 13) & 2) != 0;
              }
              break;
            case 'c':
              *(_DWORD *)(v4 + 40) = 1;
              break;
            case 'n':
              *(_DWORD *)(v4 + 40) = 2048;
              break;
            case 'p':
              *(_DWORD *)(v4 + 40) = 5;
              break;
            case 's':
              *(_DWORD *)(v4 + 40) = 3;
              break;
            default:
              *(_DWORD *)(v4 + 44) = 0;
              break;
          }
        }
        if ( *(_DWORD *)(v4 + 36) == -1 )
        {
          v31 = *(_DWORD *)(v4 + 44);
          if ( v31 )
          {
            v18 += v31;
            *(_DWORD *)(v4 + 36) = a2;
          }
        }
        v24 = a1;
        if ( *(_DWORD *)(v4 + 8) )
        {
          *(_DWORD *)(v4 + 20) = a1;
          *(_DWORD *)(v4 + 24) = wcschrnul(v24, 37);
        }
        else
        {
          v30 = a1 - 1;
          *(_DWORD *)(v4 + 24) = a1 - 1;
          *(_DWORD *)(v4 + 20) = v30;
        }
        return v18;
      default:
        a1 = v16;
        goto LABEL_11;
    }
  }
}
// 80F129C: using guessed type int _printf_function_table;
// 80F12A0: using guessed type int _printf_modifier_table;
// 80F137C: using guessed type int _printf_arginfo_table;

//----- (080A9EE0) --------------------------------------------------------
int __cdecl IO_file_doallocate(_DWORD *a1)
{
  int v1; // esi
  int v2; // edi
  int v3; // eax
  unsigned int v5; // edi
  _BOOL4 v6; // eax
  char v7[16]; // [esp+20h] [ebp-6Ch] BYREF
  int v8; // [esp+30h] [ebp-5Ch]
  unsigned int v9; // [esp+40h] [ebp-4Ch]
  int v10; // [esp+44h] [ebp-48h]
  int v11; // [esp+54h] [ebp-38h]

  v1 = 0x2000;
  v2 = 0x2000;
  if ( (int)a1[14] >= 0 && (*(int (__cdecl **)(_DWORD *, char *))(a1[37] + 72))(a1, v7) >= 0 )
  {
    if ( (v8 & 0xF000) == 0x2000 )
    {
      if ( ((v9 >> 8) & 0xFFF | v10 & 0xFFFFF000) - 136 <= 7
        || (v5 = __readgsdword(0xFFFFFFE8), v6 = isatty(a1[14]), __writegsdword(0xFFFFFFE8, v5), v6) )
      {
        *a1 |= 0x200u;
      }
    }
    v1 = 0x2000;
    v2 = 0x2000;
    if ( v11 > 0 )
    {
      v2 = v11;
      v1 = (v11 + 4095) & 0xFFFFF000;
    }
  }
  v3 = mmap(0, v1, 3, 34, -1, 0);
  if ( v3 == -1 )
    return -1;
  IO_setb((int)a1, v3, v3 + v2, 1);
  return 1;
}
// 80A9EE0: using guessed type char var_6C[16];

//----- (080AA040) --------------------------------------------------------
void __cdecl getdelim(_BYTE **a1, unsigned int *a2, int c, int *a4)
{
  int v4; // eax
  int v5; // edx
  unsigned int v8; // esi
  int v9; // eax
  bool v10; // zf
  _BYTE *v11; // eax
  _BYTE *s; // ebp
  signed int n; // edi
  unsigned int v14; // ebp
  _BYTE *v15; // eax
  _BYTE *v16; // edx
  _BYTE *v17; // eax
  int v18; // esi
  _DWORD *v19; // edx
  unsigned int v20; // [esp+14h] [ebp-28h]
  _BYTE *v21; // [esp+18h] [ebp-24h]
  _BYTE *v22; // [esp+18h] [ebp-24h]
  int v23; // [esp+1Ch] [ebp-20h]

  if ( !a2 || !a1 )
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    return;
  }
  v4 = *a4;
  v5 = *a4;
  _ECX = *a4 & 0x8000;
  if ( !_ECX )
  {
    _EDX = a4[18];
    v8 = __readgsdword(8u);
    if ( v8 != *(_DWORD *)(_EDX + 8) )
    {
      v9 = *a4 & 0x8000;
      _ECX = 1;
      v10 = __readgsdword(0xCu) == 0;
      if ( !v10 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v10 )
      {
        L_lock_53(v9, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = a4[18];
      v4 = *a4;
      *(_DWORD *)(_EDX + 8) = v8;
    }
    ++*(_DWORD *)(_EDX + 4);
    BYTE1(v5) = BYTE1(v4);
  }
  if ( (v4 & 0x20) == 0 )
  {
    if ( *a1 && *a2 || (*a2 = 120, v11 = (_BYTE *)malloc(120), (*a1 = v11) != 0) )
    {
      s = (_BYTE *)a4[1];
      n = a4[2] - (_DWORD)s;
      if ( n > 0 )
        goto LABEL_15;
      if ( _underflow(a4) != -1 )
      {
        s = (_BYTE *)a4[1];
        n = a4[2] - (_DWORD)s;
LABEL_15:
        v23 = 0;
        while ( 1 )
        {
          v17 = memchr(s, c, n);
          v16 = v17;
          if ( v17 )
            n = v17 - s + 1;
          v18 = n + v23;
          if ( n + v23 < -1 )
            break;
          v20 = *a2;
          if ( v18 + 1 > *a2 )
          {
            v14 = 2 * v20;
            if ( v18 + 1 >= 2 * v20 )
              v14 = v18 + 1;
            v21 = v17;
            realloc(*a1, v14);
            v16 = v21;
            if ( !v15 )
              goto LABEL_36;
            *a1 = v15;
            *a2 = v14;
            s = (_BYTE *)a4[1];
          }
          else
          {
            v15 = *a1;
          }
          v22 = v16;
          memcpy(&v15[v23], s, n);
          a4[1] += n;
          if ( v22 || _underflow(a4) == -1 )
          {
            (*a1)[v18] = 0;
            v5 = *a4;
            goto LABEL_29;
          }
          s = (_BYTE *)a4[1];
          v23 += n;
          n = a4[2] - (_DWORD)s;
        }
        v5 = *a4;
        __writegsdword(0xFFFFFFE8, 0x4Bu);
        goto LABEL_29;
      }
    }
LABEL_36:
    v5 = *a4;
  }
LABEL_29:
  if ( (v5 & 0x8000) == 0 )
  {
    v19 = (_DWORD *)a4[18];
    v10 = v19[1]-- == 1;
    if ( v10 )
    {
      v19[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v10 = (*v19)-- == 1;
      if ( !v10 )
        L_unlock_262(_ECX, v19);
    }
  }
}
// 80AA12F: variable 'v15' is possibly undefined
// 80AA206: variable '_ECX' is possibly undefined
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);

//----- (080AA2A1) --------------------------------------------------------
void __usercall L_lock_53(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x80AA09B);
}
// 80AA2A8: control flows out of bounds to 80AA09B

//----- (080AA2AD) --------------------------------------------------------
void __fastcall L_unlock_262(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x80AA20C);
}
// 80AA2B4: control flows out of bounds to 80AA20C

//----- (080AA2B9) --------------------------------------------------------
#error "80AA29C: call analysis failed (funcsize=5)"

//----- (080AA2D0) --------------------------------------------------------
_BYTE *__cdecl IO_getline_info(int *a1, int a2, size_t a3, int c, int a5, _DWORD *a6)
{
  size_t v6; // esi
  _BYTE *result; // eax
  signed int n; // ebx
  char *v9; // eax
  _BYTE *s; // ebp
  int v11; // eax
  char *v12; // edx
  unsigned int v13; // ebx
  int v14; // [esp+18h] [ebp-24h]
  _BYTE *v15; // [esp+1Ch] [ebp-20h]

  v6 = a3;
  if ( a6 )
    *a6 = 0;
  if ( !a1[26] )
    a1[26] = -1;
  result = 0;
  if ( a3 )
  {
    v15 = (_BYTE *)a2;
    while ( 1 )
    {
      while ( 1 )
      {
        s = (_BYTE *)a1[1];
        n = a1[2] - (_DWORD)s;
        if ( n <= 0 )
          break;
        if ( n >= v6 )
          n = v6;
        v9 = (char *)memchr(s, c, n);
        if ( v9 )
        {
          v12 = v9;
          v13 = v9 - s;
          if ( a5 >= 0 )
          {
            v12 = v9 + 1;
            v13 -= (a5 == 0) - 1;
          }
          v14 = (int)v12;
          memcpy(v15, s, v13);
          result = &v15[v13 - a2];
          a1[1] = v14;
          return result;
        }
        v6 -= n;
        memcpy(v15, s, n);
        a1[1] += n;
        v15 += n;
        if ( !v6 )
          return &v15[-a2];
      }
      v11 = _uflow(a1);
      if ( v11 == -1 )
        break;
      if ( v11 == c )
      {
        if ( a5 <= 0 )
        {
          if ( a5 )
            IO_sputbackc(a1, c);
        }
        else
        {
          *v15++ = c;
        }
        return &v15[-a2];
      }
      --v6;
      *v15++ = v11;
      if ( !v6 )
        return &v15[-a2];
    }
    if ( a6 )
    {
      result = &v15[-a2];
      *a6 = -1;
      return result;
    }
    return &v15[-a2];
  }
  return result;
}

//----- (080AA450) --------------------------------------------------------
_BYTE *__cdecl IO_getline(int *a1, int a2, size_t a3, int a4, int a5)
{
  return IO_getline_info(a1, a2, a3, a4, a5, 0);
}

//----- (080AA490) --------------------------------------------------------
int __cdecl do_encoding(int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  v1 = *(_DWORD **)(a1 + 36);
  result = -1;
  if ( !v1[13] )
  {
    result = v1[9];
    if ( result != v1[10] )
      return 0;
  }
  return result;
}

//----- (080AA4C0) --------------------------------------------------------
int do_always_noconv()
{
  return 0;
}

//----- (080AA4D0) --------------------------------------------------------
int __cdecl do_max_length(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 36) + 40);
}

//----- (080AA4E0) --------------------------------------------------------
int __cdecl do_in(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8)
{
  _DWORD *v8; // edi
  int (__cdecl *v9)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD); // esi
  unsigned int v10; // eax
  int v11; // edx
  char v13[4]; // [esp+28h] [ebp-14h] BYREF
  int v14[4]; // [esp+2Ch] [ebp-10h] BYREF

  v14[0] = a3;
  v8 = (_DWORD *)a1[9];
  a1[10] = a6;
  a1[11] = a7;
  a1[15] = a2;
  v9 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))v8[5];
  if ( *v8 )
    v9 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v9, 9));
  dl_mcount_wrapper_check((int)v9);
  v10 = v9(v8, a1 + 10, v14, a4, 0, v13, 0, 0);
  *a5 = v14[0];
  *a8 = a1[10];
  v11 = 2;
  if ( v10 <= 7 )
    return CSWTCH_11[v10];
  return v11;
}
// 80DDF40: using guessed type int CSWTCH_11[8];
// 80AA4E0: using guessed type int var_10[4];
// 80AA4E0: using guessed type char var_14[4];

//----- (080AA590) --------------------------------------------------------
int __cdecl do_unshift(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5)
{
  _DWORD *v5; // edi
  int (__cdecl *v6)(_DWORD *, _DWORD *, _DWORD, _DWORD, _DWORD, char *, int, _DWORD); // esi
  unsigned int v7; // eax
  int v8; // edx
  char v10[4]; // [esp+2Ch] [ebp-10h] BYREF

  a1[21] = a3;
  v5 = (_DWORD *)a1[20];
  a1[22] = a4;
  a1[26] = a2;
  v6 = (int (__cdecl *)(_DWORD *, _DWORD *, _DWORD, _DWORD, _DWORD, char *, int, _DWORD))v5[5];
  if ( *v5 )
    v6 = (int (__cdecl *)(_DWORD *, _DWORD *, _DWORD, _DWORD, _DWORD, char *, int, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v6, 9));
  dl_mcount_wrapper_check((int)v6);
  v7 = v6(v5, a1 + 21, 0, 0, 0, v10, 1, 0);
  *a5 = a1[21];
  v8 = 2;
  if ( v7 <= 7 )
    return CSWTCH_13[v7];
  return v8;
}
// 80DDF60: using guessed type int CSWTCH_13[8];
// 80AA590: using guessed type char var_10[4];

//----- (080AA640) --------------------------------------------------------
int __cdecl do_out(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8)
{
  _DWORD *v8; // edi
  int (__cdecl *v9)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD); // esi
  unsigned int v10; // eax
  int v11; // edx
  char v13[4]; // [esp+28h] [ebp-14h] BYREF
  int v14[4]; // [esp+2Ch] [ebp-10h] BYREF

  v14[0] = a3;
  v8 = (_DWORD *)a1[20];
  a1[21] = a6;
  a1[22] = a7;
  a1[26] = a2;
  v9 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))v8[5];
  if ( *v8 )
    v9 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v9, 9));
  dl_mcount_wrapper_check((int)v9);
  v10 = v9(v8, a1 + 21, v14, a4, 0, v13, 0, 0);
  *a5 = v14[0];
  *a8 = a1[21];
  v11 = 2;
  if ( v10 <= 7 )
    return CSWTCH_15[v10];
  return v11;
}
// 80DDF80: using guessed type int CSWTCH_15[8];
// 80AA640: using guessed type int var_10[4];
// 80AA640: using guessed type char var_14[4];

//----- (080AA6F0) --------------------------------------------------------
int __cdecl do_length(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  void *v5; // esp
  _DWORD *v6; // edx
  void (__cdecl *v7)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD); // edi
  _DWORD v9[3]; // [esp+20h] [ebp-38h] BYREF
  _DWORD *v10; // [esp+2Ch] [ebp-2Ch]
  int v11; // [esp+38h] [ebp-20h] BYREF
  char v12[16]; // [esp+3Ch] [ebp-1Ch] BYREF

  v5 = alloca(4 * a5 + 15);
  v6 = (_DWORD *)a1[9];
  a1[10] = v9;
  a1[11] = &v9[a5];
  v11 = a3;
  a1[15] = a2;
  v7 = (void (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))v6[5];
  if ( *v6 )
    v7 = (void (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v7, 9));
  v10 = v6;
  dl_mcount_wrapper_check((int)v7);
  v7(v10, a1 + 10, &v11, a4, 0, v12, 0, 0);
  return v11 - a3;
}
// 80AA6F0: using guessed type char var_1C[16];

//----- (080AA7A0) --------------------------------------------------------
int __cdecl IO_fwide(int a1, int a2)
{
  bool v2; // dl
  int v3; // ebp
  int result; // eax
  _DWORD *v5; // ebx
  int v6; // eax
  int v7; // eax
  void *v8; // eax
  int v9; // eax
  void *v10; // eax
  int v11; // eax
  int v12; // eax
  void *v13[7]; // [esp+20h] [ebp-2Ch] BYREF

  v2 = 0;
  v3 = -1;
  if ( a2 >= 0 )
  {
    v3 = a2 != 0;
    v2 = a2 == 0;
  }
  result = *(_DWORD *)(a1 + 104);
  if ( !v2 && !result )
  {
    if ( v3 == 1 )
    {
      v5 = *(_DWORD **)(a1 + 88);
      v6 = v5[1];
      *(_DWORD *)(a1 + 84) = v5 + 15;
      v5[11] = 0;
      v5[12] = 0;
      *v5 = v6;
      v5[4] = v5[3];
      v7 = *(_DWORD *)(a1 + 88);
      *(_DWORD *)(v7 + 52) = 0;
      *(_DWORD *)(v7 + 56) = 0;
      _wcsmbs_clone_conv(v13);
      if ( v13[1] != (void *)1 )
        _assert_fail("fcts.towc_nsteps == 1", "iofwide.c", 139, "_IO_fwide");
      if ( v13[3] != (void *)1 )
        _assert_fail("fcts.tomb_nsteps == 1", "iofwide.c", 140, "_IO_fwide");
      memset(v5 + 15, 0, 0x78u);
      v5[23] = 1;
      v5[29] = 1;
      v8 = v13[0];
      v5[27] = 1;
      v5[16] = do_out;
      v5[17] = do_unshift;
      v5[24] = v8;
      v9 = *(_DWORD *)(a1 + 88);
      v5[34] = 1;
      v5[40] = 1;
      v5[38] = 1;
      v5[30] = v9 + 44;
      v10 = v13[2];
      v5[18] = do_in;
      v5[19] = do_encoding;
      v5[20] = do_always_noconv;
      v5[35] = v10;
      v11 = *(_DWORD *)(a1 + 88);
      v5[44] = &_libio_translit;
      v5[21] = do_length;
      v5[22] = do_max_length;
      v5[41] = v11 + 44;
      v12 = *(_DWORD *)(*(_DWORD *)(a1 + 88) + 184);
      *(_DWORD *)(a1 + 148) = v12;
      *(_QWORD *)(a1 + 76) = ((__int64 (__cdecl *)(int, _DWORD, _DWORD, int))*(_DWORD *)(v12 + 64))(a1, 0, 0, 1);
    }
    *(_DWORD *)(a1 + 104) = v3;
    return v3;
  }
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80DDEA0: using guessed type int (__cdecl *_libio_translit)(int, int, int, int, int, int, int, int);

//----- (080AA980) --------------------------------------------------------
int __cdecl fileno_unlocked(_DWORD *a1)
{
  int result; // eax

  if ( (*a1 & 0x2000) == 0 || (result = a1[14], result < 0) )
  {
    __writegsdword(0xFFFFFFE8, 9u);
    return -1;
  }
  return result;
}

//----- (080AA9B0) --------------------------------------------------------
void __cdecl fseek(int *a1, int a2, unsigned int a3)
{
  unsigned int v4; // esi
  bool v6; // zf
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  _DWORD *v10; // edx

  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v4 = __readgsdword(8u);
    if ( v4 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v6 = __readgsdword(0xCu) == 0;
      if ( !v6 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v6 )
      {
        L_lock_31(0, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v4;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  v7 = IO_seekoff_unlocked(a1, a2, a3, 3);
  v9 = -((v8 & v7) == -1);
  if ( (BYTE1(*a1) & 0x80u) == 0 )
  {
    v10 = (_DWORD *)a1[18];
    v6 = v10[1]-- == 1;
    if ( v6 )
    {
      v10[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*v10)-- == 1;
      if ( !v6 )
        L_unlock_89(v9, v10);
    }
  }
}
// 80AAA1D: variable 'v8' is possibly undefined

//----- (080AAA94) --------------------------------------------------------
void __usercall L_lock_31(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x80AA9EA);
}
// 80AAA9B: control flows out of bounds to 80AA9EA

//----- (080AAAA0) --------------------------------------------------------
void __fastcall L_unlock_89(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x80AAA54);
}
// 80AAAA7: control flows out of bounds to 80AAA54

//----- (080AAAA9) --------------------------------------------------------
#error "80AAA8F: call analysis failed (funcsize=5)"

//----- (080AAAC0) --------------------------------------------------------
void __cdecl ftello(int *a1)
{
  unsigned int v2; // edi
  bool v4; // zf
  int v5; // edi
  int v6; // edx
  __int64 v7; // rcx
  _DWORD *v8; // edx

  if ( (*a1 & 0x8000) == 0 )
  {
    _EDX = a1[18];
    v2 = __readgsdword(8u);
    if ( v2 != *(_DWORD *)(_EDX + 8) )
    {
      _ECX = 1;
      v4 = __readgsdword(0xCu) == 0;
      if ( !v4 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v4 )
      {
        L_lock_30_0(0, (volatile __int32 *)_EDX);
        return;
      }
      _EDX = a1[18];
      *(_DWORD *)(_EDX + 8) = v2;
    }
    ++*(_DWORD *)(_EDX + 4);
  }
  LODWORD(v7) = IO_seekoff_unlocked(a1, 0LL, 1u, 0);
  v5 = *a1;
  HIDWORD(v7) = v6;
  if ( (v6 & (unsigned int)v7) != -1 && (v5 & 0x100) != 0 && a1[26] <= 0 )
    v7 -= a1[11] - a1[9];
  if ( (v5 & 0x8000) != 0 )
    goto LABEL_12;
  v8 = (_DWORD *)a1[18];
  v4 = v8[1]-- == 1;
  if ( !v4 )
    goto LABEL_12;
  v8[2] = 0;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v4 = (*v8)-- == 1;
  if ( v4 )
  {
LABEL_12:
    if ( (HIDWORD(v7) & (unsigned int)v7) == -1 )
    {
      if ( !__readgsdword(0xFFFFFFE8) )
        __writegsdword(0xFFFFFFE8, 5u);
    }
    else if ( (int)v7 >> 31 != HIDWORD(v7) )
    {
      __writegsdword(0xFFFFFFE8, 0x4Bu);
    }
  }
  else
  {
    L_unlock_168_0(v7, v8);
  }
}
// 80AAB3F: variable 'v6' is possibly undefined

//----- (080AAC3E) --------------------------------------------------------
void __usercall L_lock_30_0(int a1@<eax>, volatile __int32 *a2@<edx>)
{
  _lll_lock_wait_private(a1, a2);
  JUMPOUT(0x80AAB04);
}
// 80AAC45: control flows out of bounds to 80AAB04

//----- (080AAC4A) --------------------------------------------------------
void __fastcall L_unlock_168_0(int a1, _DWORD *a2)
{
  _lll_unlock_wake_private(a2);
  JUMPOUT(0x80AABE7);
}
// 80AAC51: control flows out of bounds to 80AABE7

//----- (080AAC53) --------------------------------------------------------
#error "80AAC39: call analysis failed (funcsize=5)"

//----- (080AAC60) --------------------------------------------------------
int __cdecl fread_unlocked(int a1, unsigned int a2, int a3, int a4)
{
  int v4; // ebx
  unsigned int v6; // eax

  v4 = a3;
  if ( !(a2 * a3) )
    return 0;
  v6 = IO_sgetn(a4);
  if ( a2 * a3 != v6 )
    return v6 / a2;
  return v4;
}

//----- (080AACC0) --------------------------------------------------------
int __cdecl IO_wfile_doallocate(_DWORD *a1)
{
  int v1; // eax
  unsigned int v2; // ebx
  int v3; // eax

  v1 = a1[7];
  if ( !v1 )
  {
    IO_file_doallocate(a1);
    v1 = a1[7];
  }
  v2 = a1[8] - v1;
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v2 = (v2 + 3) >> 2;
  v3 = mmap(0, (4 * v2 + 4095) & 0xFFFFF000, 3, 34, -1, 0);
  if ( v3 == -1 )
    return -1;
  IO_wsetb((int)a1, v3, v3 + 4 * v2, 1);
  return 1;
}

//----- (080AAD60) --------------------------------------------------------
_BYTE *__usercall strndup@<eax>(long double a1@<st0>, _BYTE *a2, int a3)
{
  unsigned int v3; // ebx
  _BYTE *v4; // eax
  _BYTE *v5; // edx
  _BYTE *result; // eax

  v3 = strnlen(a2, a3);
  malloc(a1, v3 + 1);
  v5 = v4;
  result = 0;
  if ( v5 )
  {
    v5[v3] = 0;
    return memcpy(v5, a2, v3);
  }
  return result;
}
// 80AAD86: variable 'v4' is possibly undefined
// 8048210: using guessed type int __cdecl strnlen(_DWORD, _DWORD);

//----- (080AADB0) --------------------------------------------------------
const __m128i *__cdecl _strstr_sse42(const __m128i *a1, const __m128i *a2)
{
  const __m128i *result; // eax
  __m128i v3; // xmm1
  __m128i inserted; // xmm2
  int v5; // ecx
  int v6; // ebx
  int v7; // edi
  int v8; // ebp
  int v9; // esi
  int v10; // edx
  const __m128i *v11; // ebx
  const __m128i *v12; // edx
  __m128i v13; // xmm3
  int v14; // eax
  int v15; // edi
  int v16; // ecx
  int v17; // ecx
  int v18; // eax
  int v19; // edx
  int v20; // ecx
  int v21; // edx
  __m128i v22; // xmm0
  unsigned int v23; // edx
  int v24; // ecx
  __m128i v25; // xmm1
  int v26; // ecx
  __m128i v27; // xmm1
  __m128i v28; // xmm1
  int v29; // edi
  int v30; // edx
  __m128i v31; // xmm1
  int v32; // ecx
  __m128i v33; // xmm0
  int v34; // ecx
  __m128i v35; // xmm0
  int v36; // ecx
  __m128i v37; // xmm1
  int v38; // ecx
  __m128i v39; // xmm3
  int v40; // ecx
  __m128i v41; // xmm2
  int v42; // ecx
  __m128i v43; // xmm1
  int v44; // ecx
  __m128i si128; // xmm1
  __m128i v46; // xmm1
  __m128i v47; // xmm1
  int v48; // [esp+4h] [ebp-38h]
  int v49; // [esp+8h] [ebp-34h]
  const __m128i *v50; // [esp+8h] [ebp-34h]
  const __m128i *v51; // [esp+Ch] [ebp-30h]
  int v52; // [esp+10h] [ebp-2Ch]
  int v53; // [esp+14h] [ebp-28h]

  result = a1;
  if ( a2->m128i_i8[0] )
  {
    if ( !a1->m128i_i8[0] )
      return 0;
    if ( a1->m128i_i8[1] )
    {
      if ( ((unsigned __int16)a1 & 0xFFFu) > 0xFF0
        && (v44 = (unsigned __int8)a1 & 0xF,
            si128 = _mm_load_si128((const __m128i *)((char *)a1 - v44)),
            _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, si128)) >> v44) )
      {
        v3 = _mm_shuffle_epi8(si128, _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + v44)));
      }
      else
      {
        v3 = _mm_loadu_si128(a1);
      }
      if ( a2->m128i_i8[1] )
      {
        if ( ((unsigned __int16)a2 & 0xFFFu) > 0xFF0
          && (v40 = (unsigned __int8)a2 & 0xF,
              v41 = _mm_load_si128((const __m128i *)((char *)a2 - v40)),
              _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v41)) >> v40) )
        {
          inserted = _mm_shuffle_epi8(v41, _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + v40)));
        }
        else
        {
          inserted = _mm_loadu_si128(a2);
        }
      }
      else
      {
        inserted = _mm_insert_epi8((__m128i)0LL, a2->m128i_u8[0], 0);
      }
      v5 = _mm_cmpistri(inserted, v3, 12);
      v49 = _mm_cmpistrz(inserted, v3, 12);
      v6 = _mm_cmpistrc(inserted, v3, 12);
      v7 = _mm_cmpistrs(inserted, v3, 12);
      if ( (v6 & v7) != 0 )
      {
        result = (const __m128i *)((char *)a1 + v5);
        _BitScanForward((unsigned int *)&v8, _mm_movemask_epi8(_mm_cmpeq_epi8(inserted, (__m128i)0LL)));
        if ( v8 + v5 <= 16 )
          return result;
        if ( ((unsigned __int16)result & 0xFFFu) > 0xFF0
          && (v38 = (unsigned __int8)result & 0xF,
              v39 = _mm_load_si128((const __m128i *)((char *)result - v38)),
              _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v39)) >> v38) )
        {
          v31 = _mm_shuffle_epi8(v39, _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + v38)));
        }
        else
        {
          v31 = _mm_loadu_si128(result);
        }
        v5 = _mm_cmpistri(inserted, v31, 12);
        v6 = _mm_cmpistrc(inserted, v31, 12);
        v7 = _mm_cmpistrs(inserted, v31, 12);
        v49 = _mm_cmpistrz(inserted, v31, 12);
        if ( v5 + v8 <= 16 )
          return (const __m128i *)((char *)result + v5);
      }
      if ( v7 )
      {
        if ( !v49 )
        {
          do
          {
            result = (const __m128i *)((char *)result + v5);
            if ( ((unsigned __int16)result & 0xFFFu) > 0xFF0
              && (v36 = (unsigned __int8)result & 0xF,
                  v37 = _mm_load_si128((const __m128i *)((char *)result - v36)),
                  _mm_movemask_epi8(_mm_cmpeq_epi8(v37, (__m128i)0LL)) >> v36) )
            {
              v28 = _mm_shuffle_epi8(v37, _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + v36)));
            }
            else
            {
              v28 = _mm_loadu_si128(result);
            }
            v5 = _mm_cmpistri(inserted, v28, 12);
            v29 = _mm_cmpistrc(inserted, v28, 12);
            v30 = _mm_cmpistrz(inserted, v28, 12);
            if ( ((unsigned __int8)v29 & (v5 == 0)) != 0 )
            {
              v5 = 0;
              return (const __m128i *)((char *)result + v5);
            }
          }
          while ( !v30 );
          v6 = v29;
        }
        if ( v6 )
          return (const __m128i *)((char *)result + v5);
        return 0;
      }
      v9 = 0;
      v52 = (unsigned __int8)a2 & 0xF;
      v51 = a2 + 1;
      v53 = (unsigned int)&a2[1] & 0xF;
      v10 = v49;
      if ( !v6 )
        goto LABEL_44;
LABEL_13:
      if ( v5 )
      {
        v12 = (const __m128i *)((char *)result + v5);
        v11 = a2;
        v50 = (const __m128i *)((char *)result + v5);
        goto LABEL_18;
      }
      if ( !v10 )
      {
        v11 = a2 + 1;
        v12 = result + 1;
        if ( ((unsigned __int16)v51 & 0xFFFu) > 0xFF0
          && (v46 = _mm_load_si128((const __m128i *)((char *)a2 - v53 + 16)),
              _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v46)) >> v53) )
        {
          inserted = _mm_shuffle_epi8(v46, _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + v53)));
        }
        else
        {
          inserted = _mm_loadu_si128(v51);
        }
        v50 = result;
LABEL_18:
        if ( ((unsigned __int16)v12 & 0xFFFu) > 0xFF0
          && (v42 = (unsigned __int8)v12 & 0xF,
              v43 = _mm_load_si128((const __m128i *)((char *)v12 - v42)),
              _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v43)) >> v42) )
        {
          v13 = _mm_shuffle_epi8(v43, _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + v42)));
        }
        else
        {
          v13 = _mm_loadu_si128(v12);
        }
        v14 = _mm_cmpistri(inserted, v13, 12);
        v15 = _mm_cmpistrz(inserted, v13, 12);
        v16 = _mm_cmpistrs(inserted, v13, 12);
        if ( !(v16 | v15 | v14) )
        {
          do
          {
            ++v11;
            ++v12;
            if ( ((unsigned __int16)v11 & 0xFFFu) > 0xFF0
              && (v34 = (unsigned __int8)v11 & 0xF,
                  v35 = _mm_load_si128((const __m128i *)((char *)v11 - v34)),
                  _mm_movemask_epi8(_mm_cmpeq_epi8(v35, (__m128i)0LL)) >> v34) )
            {
              inserted = _mm_shuffle_epi8(v35, _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + v34)));
            }
            else
            {
              inserted = _mm_loadu_si128(v11);
            }
            if ( ((unsigned __int16)v12 & 0xFFFu) > 0xFF0
              && (v32 = (unsigned __int8)v12 & 0xF,
                  v33 = _mm_load_si128((const __m128i *)((char *)v12 - v32)),
                  _mm_movemask_epi8(_mm_cmpeq_epi8(v33, (__m128i)0LL)) >> v32) )
            {
              v13 = _mm_shuffle_epi8(v33, _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + v32)));
            }
            else
            {
              v13 = _mm_loadu_si128(v12);
            }
            v17 = _mm_cmpistri(inserted, v13, 12);
            v48 = _mm_cmpistrz(inserted, v13, 12);
            v18 = _mm_cmpistrs(inserted, v13, 12);
          }
          while ( !(v18 | v17 | v48) );
          v15 = v48;
          v19 = v18;
          v14 = v17;
          v16 = v19;
        }
        if ( ((unsigned __int8)v16 & (v14 == 0)) == 0 )
        {
          if ( v15 )
          {
            if ( v16 )
            {
              _BitScanForward((unsigned int *)&v20, _mm_movemask_epi8(_mm_cmpeq_epi8(inserted, (__m128i)0LL)));
              _BitScanForward((unsigned int *)&v21, _mm_movemask_epi8(_mm_cmpeq_epi8(v13, (__m128i)0LL)));
              if ( v20 < v21 )
              {
LABEL_31:
                if ( ((unsigned __int16)a2 & 0xFFFu) > 0xFF0
                  && (v47 = _mm_load_si128((const __m128i *)((char *)a2 - v52)),
                      _mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v47)) >> v52) )
                {
                  inserted = _mm_shuffle_epi8(
                               v47,
                               _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + v52)));
                }
                else
                {
                  inserted = _mm_loadu_si128(a2);
                }
                if ( !v9 )
                {
                  v22 = _mm_unpacklo_epi8(inserted, inserted);
                  v23 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_shuffle_epi32(_mm_unpacklo_epi8(v22, v22), 0), _mm_srli_si128(inserted, 1)));
                  LOWORD(v9) = 16;
                  _BitScanForward((unsigned int *)&v24, v23);
                  if ( v23 )
                  {
                    LOWORD(v9) = 1;
                    if ( v23 != 0x7FFF )
                    {
                      LOWORD(v9) = 3;
                      if ( v24 )
                        v9 = v24 + 1;
                    }
                  }
                }
                if ( v9 <= v14 )
                  v14 = v9;
                result = (const __m128i *)((char *)v50 + v14);
                if ( result->m128i_i8[0] )
                {
                  for ( ; ((unsigned __int16)result & 0xFFFu) > 0xFF0; ++result )
                  {
                    v26 = (unsigned __int8)result & 0xF;
                    v27 = _mm_load_si128((const __m128i *)((char *)result - v26));
                    if ( !(_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v27)) >> v26) )
                      break;
                    v25 = _mm_shuffle_epi8(v27, _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + v26)));
LABEL_43:
                    v5 = _mm_cmpistri(inserted, v25, 12);
                    v10 = _mm_cmpistrz(inserted, v25, 12);
                    if ( _mm_cmpistrc(inserted, v25, 12) )
                      goto LABEL_13;
LABEL_44:
                    if ( v10 )
                      return 0;
                  }
                  v25 = _mm_loadu_si128(result);
                  goto LABEL_43;
                }
              }
            }
            return 0;
          }
          if ( v14 )
            goto LABEL_31;
        }
        return v50;
      }
    }
    else
    {
      if ( a2->m128i_i8[1] )
        return 0;
      if ( a2->m128i_i8[0] != a1->m128i_i8[0] )
        return 0;
    }
  }
  return result;
}
// 80DDFA0: using guessed type __int128 __m128i_shift_right;

//----- (080AB3F0) --------------------------------------------------------
int __cdecl strsep(int *a1, char *a2)
{
  int v2; // ebx
  char v3; // dl
  _BYTE *v5; // eax

  v2 = *a1;
  if ( !*a1 )
    return v2;
  v3 = *a2;
  if ( !*a2 )
  {
LABEL_6:
    *a1 = 0;
    return v2;
  }
  if ( a2[1] )
  {
    v5 = strpbrk(v2, a2);
  }
  else
  {
    if ( v3 == *(_BYTE *)v2 )
    {
      v5 = (_BYTE *)*a1;
      goto LABEL_10;
    }
    if ( !*(_BYTE *)v2 )
      goto LABEL_6;
    v5 = strchr((const char *)(v2 + 1), v3);
  }
  if ( !v5 )
    goto LABEL_6;
LABEL_10:
  *v5 = 0;
  *a1 = (int)(v5 + 1);
  return v2;
}

//----- (080AB480) --------------------------------------------------------
int __usercall argz_create_sep@<eax>(long double a1@<st0>, char *a2, int a3, int *a4, int *a5)
{
  char *v5; // ebp
  int v6; // eax
  int v7; // ebx
  _BYTE *v8; // eax
  _BYTE *v9; // ecx
  bool v10; // zf
  int result; // eax
  char v12; // al

  v5 = a2;
  v6 = strlen(a2);
  v7 = v6 + 1;
  if ( (unsigned int)(v6 + 1) <= 1 )
  {
    *a4 = 0;
    *a5 = 0;
    return 0;
  }
  malloc(a1, v6 + 1);
  v9 = v8;
  v10 = v8 == 0;
  *a4 = (int)v8;
  result = 12;
  if ( !v10 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v12 = *v5;
        if ( *v5 == a3 )
          break;
        *v9++ = v12;
LABEL_5:
        ++v5;
        if ( !v12 )
          goto LABEL_10;
      }
      if ( (unsigned int)v9 <= *a4 || !*(v9 - 1) )
      {
        --v7;
        goto LABEL_5;
      }
      *v9 = 0;
      ++v5;
      ++v9;
      if ( !v12 )
      {
LABEL_10:
        if ( !v7 )
        {
          free(a1, *a4);
          *a4 = 0;
        }
        *a5 = v7;
        return 0;
      }
    }
  }
  return result;
}
// 80AB4BB: variable 'v8' is possibly undefined

//----- (080AB550) --------------------------------------------------------
int __cdecl argz_add_sep(_BYTE **a1, _DWORD *a2, char *a3, int a4)
{
  int v4; // eax
  int v5; // edx
  int v6; // ebx
  _BYTE *v7; // eax
  char *v8; // ecx
  _BYTE *v9; // eax
  char v10; // dl
  char v11; // dl

  v4 = strlen(a3);
  v5 = 0;
  v6 = v4 + 1;
  if ( (unsigned int)(v4 + 1) > 1 )
  {
    realloc(*a1, *a2 + v6);
    v5 = 12;
    *a1 = v7;
    if ( v7 )
    {
      v8 = a3;
      v9 = &v7[*a2];
      while ( 1 )
      {
        while ( 1 )
        {
          v10 = *v8;
          if ( *v8 == a4 )
            break;
          *v9 = v10;
          v10 = *v8;
          ++v9;
LABEL_5:
          ++v8;
          if ( !v10 )
            goto LABEL_10;
        }
        if ( v9 <= *a1 || !*(v9 - 1) )
        {
          --v6;
          goto LABEL_5;
        }
        *v9 = 0;
        v11 = *v8;
        ++v9;
        ++v8;
        if ( !v11 )
        {
LABEL_10:
          *a2 += v6;
          return 0;
        }
      }
    }
  }
  return v5;
}
// 80AB59E: variable 'v7' is possibly undefined

//----- (080AB610) --------------------------------------------------------
int __cdecl _strcasecmp_nonascii(int a1, int a2)
{
  unsigned int v2; // edx
  int result; // eax
  int v4; // ecx
  int v5; // edx
  unsigned __int8 v6; // si

  v2 = __readgsdword(0xFFFFFFD8);
  result = 0;
  if ( a1 != a2 )
  {
    v4 = *(_DWORD *)(v2 + 56);
    v5 = 0;
    do
    {
      v6 = *(_BYTE *)(a1 + v5);
      result = *(_DWORD *)(v4 + 4 * v6) - *(_DWORD *)(v4 + 4 * *(unsigned __int8 *)(a2 + v5));
      if ( result )
        break;
      ++v5;
    }
    while ( v6 );
  }
  return result;
}

//----- (080AB680) --------------------------------------------------------
int *(__cdecl *wcschr())(int *a1, int a2)
{
  int *(__cdecl *result)(int *, int); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = _wcschr_ia32;
  if ( (dword_80F1274 & 0x4000000) != 0 )
    return (int *(__cdecl *)(int *, int))_wcschr_sse2;
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1274: using guessed type int dword_80F1274;

//----- (080AB6C0) --------------------------------------------------------
unsigned int (__cdecl *wcslen())(_DWORD *a1)
{
  unsigned int (__cdecl *result)(_DWORD *); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (unsigned int (__cdecl *)(_DWORD *))_wcslen_ia32;
  if ( (dword_80F1274 & 0x4000000) != 0 )
    return _wcslen_sse2;
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1274: using guessed type int dword_80F1274;

//----- (080AB700) --------------------------------------------------------
int __cdecl btowc(int a1)
{
  int result; // eax
  _DWORD **v2; // eax
  int v3; // ebp
  void **v4; // esi
  int (__cdecl *v5)(void *, _DWORD); // ebp
  _DWORD *v6; // eax
  bool v7; // zf
  int (__cdecl *v8)(void *, int *, char **, char *, _DWORD, char *, _DWORD, int); // ebx
  int v9; // eax
  int v10[6]; // [esp+2Ch] [ebp-50h] BYREF
  char v11[8]; // [esp+44h] [ebp-38h] BYREF
  int v12; // [esp+4Ch] [ebp-30h]
  int v13; // [esp+50h] [ebp-2Ch] BYREF
  char *v14; // [esp+54h] [ebp-28h] BYREF
  char v15[7]; // [esp+58h] [ebp-24h] BYREF
  char v16; // [esp+5Fh] [ebp-1Dh] BYREF

  result = a1;
  if ( (unsigned int)(a1 + 128) > 0x17F || a1 == -1 )
    return -1;
  if ( (a1 & 0xFFFFFF80) != 0 )
  {
    v2 = (_DWORD **)__readgsdword(0xFFFFFFDC);
    v3 = (int)*v2;
    v4 = (void **)(*v2)[5];
    if ( !v4 )
    {
      v4 = &_wcsmbs_gconv_fcts_c;
      if ( (char **)v3 != &nl_C_LC_CTYPE )
      {
        _wcsmbs_load_conv(*v2);
        v4 = *(void ***)(v3 + 20);
      }
    }
    v5 = (int (__cdecl *)(void *, _DWORD))*((_DWORD *)*v4 + 6);
    if ( v4[1] == (void *)1 && v5 )
    {
      if ( *(_DWORD *)*v4 )
        v5 = (int (__cdecl *)(void *, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v5, 9));
      dl_mcount_wrapper_check((int)v5);
      return v5(*v4, (unsigned __int8)a1);
    }
    else
    {
      v14 = &v16;
      v10[0] = (int)&v13;
      memset(v11, 0, sizeof(v11));
      v16 = a1;
      v10[1] = (int)&v14;
      v6 = *v4;
      v10[3] = 0;
      v10[4] = 1;
      v10[2] = 1;
      v7 = *v6 == 0;
      v10[5] = (int)v11;
      v8 = (int (__cdecl *)(void *, int *, char **, char *, _DWORD, char *, _DWORD, int))v6[5];
      v12 = 0;
      if ( !v7 )
        v8 = (int (__cdecl *)(void *, int *, char **, char *, _DWORD, char *, _DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v8, 9));
      dl_mcount_wrapper_check((int)v8);
      v9 = v8(*v4, v10, &v14, v14 + 1, 0, v15, 0, 1);
      if ( v9 != 5 && v9 && v9 != 4 )
        return -1;
      return v13;
    }
  }
  return result;
}
// 80CAB80: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80CF3E0: using guessed type char *nl_C_LC_CTYPE;
// 80AB700: using guessed type char var_24[7];

//----- (080AB890) --------------------------------------------------------
int __cdecl mbrlen(_BYTE *a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax

  v3 = a3;
  if ( !a3 )
    v3 = &internal;
  return mbrtowc(0, a1, a2, v3);
}

//----- (080AB8D0) --------------------------------------------------------
int __cdecl mbrtowc(char *a1, _BYTE *a2, int a3, _DWORD *a4)
{
  char *v4; // esi
  _DWORD *v5; // eax
  _BYTE *v6; // ebx
  int v8; // ebp
  void **v9; // eax
  bool v10; // cf
  int v11; // edi
  _DWORD *v12; // edx
  int (__cdecl *v13)(void *, int *, _BYTE **, int, _DWORD, char *, _DWORD, int); // ebp
  int v14; // eax
  int v15; // edx
  int result; // eax
  void **v17; // [esp+2Ch] [ebp-50h]
  int v18[5]; // [esp+30h] [ebp-4Ch] BYREF
  _DWORD *v19; // [esp+44h] [ebp-38h]
  int v20; // [esp+50h] [ebp-2Ch]
  char v21; // [esp+54h] [ebp-28h] BYREF
  char v22[4]; // [esp+58h] [ebp-24h] BYREF
  _BYTE *v23; // [esp+5Ch] [ebp-20h] BYREF

  v4 = a1;
  v5 = a4;
  v6 = a2;
  if ( !a1 )
    v4 = &v21;
  if ( !a4 )
    v5 = &state_2;
  v18[3] = 0;
  v18[4] = 1;
  v18[2] = 1;
  v19 = v5;
  v20 = 0;
  if ( !a2 )
  {
    v4 = &v21;
    a3 = 1;
    v6 = &unk_80C86D9;
  }
  v18[1] = (int)(v4 + 4);
  v18[0] = (int)v4;
  v8 = *(_DWORD *)__readgsdword(0xFFFFFFDC);
  if ( *(_DWORD *)(v8 + 20) )
    goto LABEL_8;
  v9 = &_wcsmbs_gconv_fcts_c;
  if ( (char **)v8 != &nl_C_LC_CTYPE )
  {
    _wcsmbs_load_conv(&state_2);
LABEL_8:
    v9 = *(void ***)(v8 + 20);
  }
  v10 = __CFADD__(v6, a3);
  v11 = (int)&v6[a3];
  if ( v10 )
    v11 = -1;
  v12 = *v9;
  v23 = v6;
  v13 = (int (__cdecl *)(void *, int *, _BYTE **, int, _DWORD, char *, _DWORD, int))v12[5];
  if ( *v12 )
    v13 = (int (__cdecl *)(void *, int *, _BYTE **, int, _DWORD, char *, _DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v13, 9));
  v17 = v9;
  dl_mcount_wrapper_check((int)v13);
  v14 = v13(*v17, v18, &v23, v11, 0, v22, 0, 1);
  v15 = v14;
  if ( v14 != 4 && v14 && v14 != 7 && v14 != 6 )
  {
    if ( v14 != 5 )
      _assert_fail(
        "status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __GCONV_IN"
        "COMPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
        "mbrtowc.c",
        92,
        "__mbrtowc");
    goto LABEL_16;
  }
  if ( v14 == 4 || !v14 )
  {
LABEL_16:
    if ( (char *)v18[0] == v4 || *(_DWORD *)v4 )
      return v23 - v6;
    if ( *v19 )
      _assert_fail("((data.__statep)->__count == 0)", "mbrtowc.c", 101, "__mbrtowc");
    return 0;
  }
  result = -2;
  if ( v15 != 7 )
  {
    __writegsdword(0xFFFFFFE8, 0x54u);
    return -1;
  }
  return result;
}
// 80ABA47: conditional instruction was optimized away because eax.4 is in (6..7)
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 8080180: using guessed type int __fastcall _wcsmbs_load_conv(_DWORD);
// 80CAB80: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80CF3E0: using guessed type char *nl_C_LC_CTYPE;
// 80AB8D0: using guessed type char var_24[4];

//----- (080ABAD0) --------------------------------------------------------
int __usercall mbsrtowcs@<eax>(long double a1@<st0>, int a2, _DWORD *a3, int a4, void *a5)
{
  void *v5; // eax
  _DWORD **v6; // edx

  v5 = a5;
  v6 = (_DWORD **)__readgsdword(0xFFFFFFD8);
  if ( !a5 )
    v5 = &state_3;
  return _mbsrtowcs_l(a1, a2, a3, a4, (int)v5, v6);
}

//----- (080ABB20) --------------------------------------------------------
_DWORD *__cdecl wcschrnul(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  for ( result = a1; *result && *result != a2; ++result )
    ;
  return result;
}

//----- (080ABB60) --------------------------------------------------------
int __usercall _mbsrtowcs_l@<eax>(long double a1@<st0>, int a2, _DWORD *a3, int a4, int a5, _DWORD **a6)
{
  int v6; // ebx
  int v7; // esi
  void **v8; // eax
  int (__cdecl *v9)(void *, char **, _BYTE **, _BYTE *, _DWORD, char *, _DWORD, int); // edi
  _BYTE *v10; // esi
  int *v11; // ebp
  int v12; // edx
  _BYTE *v13; // ebx
  int v14; // eax
  bool v15; // cl
  int v16; // edx
  int v17; // ebx
  bool v18; // di
  bool v19; // si
  int v21; // edx
  int v22; // eax
  void *v23; // [esp+20h] [ebp-16Ch]
  _BYTE *v24; // [esp+2Ch] [ebp-160h]
  char v25[256]; // [esp+3Ch] [ebp-150h] BYREF
  char *v26; // [esp+13Ch] [ebp-50h] BYREF
  int *v27; // [esp+140h] [ebp-4Ch]
  int v28; // [esp+144h] [ebp-48h]
  int v29; // [esp+148h] [ebp-44h]
  int v30; // [esp+14Ch] [ebp-40h]
  int *v31; // [esp+150h] [ebp-3Ch]
  int v32; // [esp+15Ch] [ebp-30h]
  int v33[2]; // [esp+160h] [ebp-2Ch] BYREF
  char v34[4]; // [esp+168h] [ebp-24h] BYREF
  _BYTE *v35[8]; // [esp+16Ch] [ebp-20h] BYREF

  v32 = 0;
  v6 = a4;
  v29 = 0;
  v30 = 1;
  v31 = (int *)a5;
  v28 = 1;
  v7 = (int)*a6;
  if ( (*a6)[5] )
    goto LABEL_2;
  v8 = &_wcsmbs_gconv_fcts_c;
  if ( (char **)v7 != &nl_C_LC_CTYPE )
  {
    _wcsmbs_load_conv(*a6);
LABEL_2:
    v8 = *(void ***)(v7 + 20);
  }
  v23 = *v8;
  v9 = (int (__cdecl *)(void *, char **, _BYTE **, _BYTE *, _DWORD, char *, _DWORD, int))*((_DWORD *)*v8 + 5);
  if ( *(_DWORD *)*v8 )
    v9 = (int (__cdecl *)(void *, char **, _BYTE **, _BYTE *, _DWORD, char *, _DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v9, 9));
  if ( a2 )
  {
    v10 = (_BYTE *)*a3;
    v35[0] = *(_BYTE **)a3;
    v26 = (char *)a2;
    v27 = (int *)(a2 + 4 * a4);
    if ( !a4 )
      return 0;
    v11 = (int *)&v26;
    while ( 1 )
    {
      v13 = &v10[strnlen(v10, v6) + 1];
      dl_mcount_wrapper_check((int)v9);
      v14 = v9(v23, &v26, v35, v13, 0, v34, 0, 1);
      v15 = v14 != 4;
      if ( v14 != 7 && v14 != 4 )
        break;
      v10 = v35[0];
      v12 = (int)v26;
      if ( v35[0] == v13 )
      {
        if ( *(v13 - 1) )
        {
          v6 = ((char *)v27 - v26) >> 2;
          if ( v6 )
            continue;
        }
      }
      goto LABEL_14;
    }
    v12 = (int)v26;
    v15 = 1;
    v10 = v35[0];
LABEL_14:
    v16 = (v12 - a2) >> 2;
    *a3 = v10;
    v17 = v16;
    if ( v14 != 4 && v14 )
    {
      v18 = 1;
      if ( !v15 )
        goto LABEL_21;
      goto LABEL_29;
    }
    if ( !*(_DWORD *)(a2 + 4 * (v16 - 1)) )
    {
      if ( !v16 )
        _assert_fail((int)&v26, a1, (int)"result > 0", (int)"mbsrtowcs_l.c", 147, "__mbsrtowcs_l");
      if ( *v31 )
        _assert_fail((int)&v26, a1, (int)"((data.__statep)->__count == 0)", (int)"mbsrtowcs_l.c", 148, "__mbsrtowcs_l");
      *a3 = 0;
      v17 = v16 - 1;
    }
    v18 = v14 != 0;
    v19 = v15 && v14 != 0;
LABEL_20:
    if ( !v19 )
      goto LABEL_21;
    goto LABEL_29;
  }
  v11 = (int *)&v26;
  v35[0] = *(_BYTE **)a3;
  v17 = 0;
  v24 = &v35[0][strlen(v35[0]) + 1];
  v21 = v31[1];
  v22 = *v31;
  v27 = (int *)&v26;
  v33[1] = v21;
  v33[0] = v22;
  v31 = v33;
  do
  {
    v26 = v25;
    dl_mcount_wrapper_check((int)v9);
    v14 = v9(v23, &v26, v35, v24, 0, v34, 0, 1);
    v17 += (v26 - v25) >> 2;
  }
  while ( v14 == 5 );
  if ( v14 == 4 || (v18 = 1, v15 = 1, !v14) )
  {
    v11 = (int *)*((_DWORD *)v26 - 1);
    if ( v11 )
      _assert_fail(
        (int)v11,
        a1,
        (int)"((wchar_t *) data.__outbuf)[-1] == L'\\0'",
        (int)"mbsrtowcs_l.c",
        100,
        "__mbsrtowcs_l");
    --v17;
    v15 = v14 != 4;
    v18 = v14 != 0;
    v19 = v14 != 0 && v14 != 4;
    goto LABEL_20;
  }
LABEL_29:
  if ( v14 != 7 && v14 != 6 )
  {
    if ( v14 != 5 )
      _assert_fail(
        (int)v11,
        a1,
        (int)"status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __GCO"
             "NV_INCOMPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
        (int)"mbsrtowcs_l.c",
        159,
        "__mbsrtowcs_l");
    return v17;
  }
LABEL_21:
  if ( v14 != 5 && v18 && v14 != 7 && v15 )
  {
    v17 = -1;
    __writegsdword(0xFFFFFFE8, 0x54u);
  }
  return v17;
}
// 8048210: using guessed type int __cdecl strnlen(_DWORD, _DWORD);
// 80CAB80: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80CF3E0: using guessed type char *nl_C_LC_CTYPE;
// 80ABB60: using guessed type char var_24[4];

//----- (080ABF80) --------------------------------------------------------
unsigned int __cdecl _wcslen_sse2(_DWORD *a1)
{
  char *v1; // ecx
  __m128i *v2; // eax
  int v3; // edx
  __m128i *v4; // eax
  __m128i v5; // xmm3
  __m128i v6; // xmm1
  __m128i v7; // xmm6
  int v8; // edx
  __m128i v9; // xmm3
  __m128i v10; // xmm3
  __m128i v11; // xmm3
  unsigned int result; // eax

  if ( !*a1 )
    return 0;
  if ( !a1[1] )
    return 1;
  if ( !a1[2] )
    return 2;
  if ( !a1[3] )
    return 3;
  if ( !a1[4] )
    return 4;
  if ( !a1[5] )
    return 5;
  if ( !a1[6] )
    return 6;
  if ( !a1[7] )
    return 7;
  v1 = (char *)(a1 + 4);
  v2 = (__m128i *)((unsigned int)(a1 + 8) & 0xFFFFFFF0);
  v3 = _mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *v2));
  v4 = v2 + 1;
  if ( !v3 )
  {
    v3 = _mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *v4++));
    if ( !v3 )
    {
      v3 = _mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *v4++));
      if ( !v3 )
      {
        v5 = _mm_cmpeq_epi32((__m128i)0LL, *v4);
        v3 = _mm_movemask_epi8(v5);
        ++v4;
        if ( !v3 )
        {
          v4 = (__m128i *)((unsigned int)v4 & 0xFFFFFFC0);
          do
          {
            do
            {
              v6 = v4[1];
              v7 = v4[3];
              v8 = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_min_epu8(_mm_min_epu8(v4[2], v7), _mm_min_epu8(*v4, v6)), v5));
              v4 += 4;
            }
            while ( !v8 );
            v9 = _mm_cmpeq_epi32(v5, v4[-4]);
            v3 = _mm_movemask_epi8(v9);
            v1 += 48;
            if ( v3 )
              break;
            v10 = _mm_cmpeq_epi32(v9, v6);
            v3 = _mm_movemask_epi8(v10);
            v1 -= 16;
            if ( v3 )
              break;
            v11 = _mm_cmpeq_epi32(v10, v4[-2]);
            v3 = _mm_movemask_epi8(v11);
            v1 -= 16;
            if ( v3 )
              break;
            v5 = _mm_cmpeq_epi32(v11, v7);
            v3 = _mm_movemask_epi8(v5);
            v1 -= 16;
          }
          while ( !v3 );
        }
      }
    }
  }
  result = (unsigned int)((char *)v4 - v1) >> 2;
  if ( (_BYTE)v3 )
  {
    if ( (v3 & 0xF) == 0 )
      ++result;
  }
  else if ( (v3 & 0xF00) != 0 )
  {
    result += 2;
  }
  else
  {
    result += 3;
  }
  return result;
}

//----- (080AC180) --------------------------------------------------------
char __cdecl _wcslen_ia32(_DWORD *a1)
{
  int v1; // eax
  int i; // edx
  char v3; // dl

  LOBYTE(v1) = 0;
  if ( *a1 )
  {
    LOBYTE(v1) = 1;
    if ( a1[1] )
    {
      LOBYTE(v1) = 2;
      if ( a1[2] )
      {
        for ( i = 0; ; i = v1 )
        {
          LOBYTE(v1) = i + 3;
          if ( !a1[i + 3] )
            break;
          v1 = i + 4;
          if ( !a1[i + 4] )
            break;
          if ( !a1[v1 + 1] )
          {
            LOBYTE(v1) = i + 5;
            return v1;
          }
          v3 = i + 6;
          if ( !a1[v1 + 2] )
          {
            LOBYTE(v1) = v3;
            return v1;
          }
        }
      }
    }
  }
  return v1;
}

//----- (080AC1F0) --------------------------------------------------------
const __m128i *__cdecl _wcschr_sse2(const __m128i *a1, unsigned int a2)
{
  const __m128i *v2; // ecx
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  __m128i v5; // xmm1
  __m128i v6; // xmm0
  __m128i v7; // xmm2
  int v8; // eax
  __m128i si128; // xmm0
  int v10; // edx
  __m128i v12; // xmm0
  __m128i v13; // xmm0
  __m128i v14; // xmm0
  __m128i v15; // xmm0

  v2 = a1;
  v3 = _mm_cvtsi32_si128(a2);
  v4 = _mm_unpacklo_epi32(v3, v3);
  v5 = _mm_unpacklo_epi32(v4, v4);
  if ( ((unsigned __int8)a1 & 0x3Fu) > 0x30 )
  {
    si128 = _mm_load_si128((const __m128i *)((unsigned int)a1 & 0xFFFFFFF0));
    v10 = _mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, si128)) >> ((unsigned __int8)a1 & 0xF);
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi32(si128, v5)) >> ((unsigned __int8)a1 & 0xF);
    if ( v8 )
    {
      v2 = a1;
      if ( !v10 )
        goto LABEL_28;
      if ( !(_BYTE)v8 )
        goto LABEL_23;
      if ( (v8 & 0xF) != 0 )
        return v2;
      if ( (v10 & 0xF) == 0 )
        return (const __m128i *)&a1->m128i_i8[4];
    }
    else
    {
      v2 = (const __m128i *)((unsigned int)a1 & 0xFFFFFFF0);
      if ( !v10 )
      {
        v7 = 0LL;
        goto LABEL_12;
      }
    }
    return 0;
  }
  v6 = _mm_loadu_si128(a1);
  v7 = _mm_cmpeq_epi32((__m128i)0LL, v6);
  v8 = _mm_movemask_epi8(_mm_cmpeq_epi32(v6, v5));
  if ( v8 | _mm_movemask_epi8(v7) )
    goto LABEL_16;
  v2 = (const __m128i *)((unsigned int)a1 & 0xFFFFFFF0);
  do
  {
LABEL_12:
    v12 = _mm_load_si128(++v2);
    v7 = _mm_cmpeq_epi32(v7, v12);
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi32(v12, v5));
    if ( v8 | _mm_movemask_epi8(v7) )
      break;
    v13 = _mm_load_si128(++v2);
    v7 = _mm_cmpeq_epi32(v7, v13);
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi32(v13, v5));
    if ( v8 | _mm_movemask_epi8(v7) )
      break;
    v14 = _mm_load_si128(++v2);
    v7 = _mm_cmpeq_epi32(v7, v14);
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi32(v14, v5));
    if ( v8 | _mm_movemask_epi8(v7) )
      break;
    v15 = _mm_load_si128(++v2);
    v7 = _mm_cmpeq_epi32(v7, v15);
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi32(v15, v5));
  }
  while ( !(v8 | _mm_movemask_epi8(v7)) );
LABEL_16:
  v10 = _mm_movemask_epi8(v7);
  if ( !v8 )
    return 0;
  if ( v10 )
  {
    if ( (_BYTE)v8 )
    {
      if ( (v8 & 0xF) == 0 )
      {
        if ( (v10 & 0xF) == 0 )
          return (const __m128i *)&v2->m128i_i8[4];
        return 0;
      }
      return v2;
    }
LABEL_23:
    if ( !(_BYTE)v10 )
    {
      if ( (v8 & 0xF00) != 0 )
        return (const __m128i *)&v2->m128i_i8[8];
      if ( (v10 & 0xF00) == 0 )
        return (const __m128i *)&v2->m128i_i8[12];
    }
    return 0;
  }
LABEL_28:
  if ( (_BYTE)v8 )
  {
    if ( (v8 & 1) != 0 )
      return v2;
    else
      return (const __m128i *)&v2->m128i_i8[4];
  }
  else if ( (v8 & 0x100) != 0 )
  {
    return (const __m128i *)&v2->m128i_i8[8];
  }
  else
  {
    return (const __m128i *)&v2->m128i_i8[12];
  }
}

//----- (080AC3D0) --------------------------------------------------------
int *__cdecl _wcschr_ia32(int *a1, int a2)
{
  int *result; // eax
  int v3; // edx

  for ( result = a1; ; ++result )
  {
    v3 = *result;
    if ( *result == a2 )
      break;
    if ( !v3 )
      return 0;
  }
  return result;
}

//----- (080AC3F0) --------------------------------------------------------
int __cdecl _offtime(_DWORD *a1, int a2, int *a3)
{
  int v3; // ecx
  int v4; // ebx
  int v5; // ebx
  int v6; // edx
  signed int v7; // ebx
  unsigned int v8; // edi
  int v9; // ebp
  int v10; // eax
  int v11; // edx
  int v12; // esi
  int v13; // edx
  unsigned int v14; // edx
  int v15; // eax
  __int16 *v16; // eax
  int v17; // edx
  int i; // ebx
  int result; // eax
  unsigned int v20; // [esp+4h] [ebp-1Ch]
  int v21; // [esp+8h] [ebp-18h]
  unsigned int v22; // [esp+8h] [ebp-18h]

  v3 = *a1 / 86400;
  v4 = a2 + *a1 % 86400;
  if ( v4 >= 0 )
    goto LABEL_5;
  do
  {
    --v3;
    v4 += 86400;
  }
  while ( v4 < 0 );
  while ( v4 > 86399 )
  {
    v4 -= 86400;
    ++v3;
LABEL_5:
    ;
  }
  a3[2] = v4 / 3600;
  v5 = v4 % 3600;
  a3[1] = v5 / 60;
  *a3 = v5 % 60;
  v6 = (v3 + 4) % 7;
  a3[6] = v6;
  if ( v6 < 0 )
    a3[6] = v6 + 7;
  v7 = 1970;
  while ( 1 )
  {
    if ( v3 >= 0 )
    {
      v15 = 365;
      if ( (v7 & 3) == 0 )
      {
        v15 = 366;
        if ( v7 == 100 * (v7 / 100) )
          v15 = 366 - (v7 != 400 * (v7 / 400));
      }
      if ( v3 < v15 )
        break;
    }
    v8 = v3 / 365 + v7 - ((unsigned int)(v3 % 365) >> 31);
    v9 = v7 - 1;
    v10 = v7 + 2;
    v11 = v7 - 1;
    if ( v7 - 1 >= 0 )
      v10 = v7 - 1;
    v21 = v11 >> 31;
    v20 = (v10 >> 2)
        - (((((_BYTE)v9 + ((unsigned int)(v11 >> 31) >> 30)) & 3) - ((unsigned int)(v11 >> 31) >> 30)) >> 31);
    v12 = v8 - 1;
    v13 = ((int)((unsigned __int64)(1374389535LL * v9) >> 32) >> 7) - (v11 >> 31);
    v22 = v20
        + v21
        - ((int)((unsigned __int64)(1374389535LL * v9) >> 32) >> 5)
        + ((unsigned int)(v9 - 100 * (((int)((unsigned __int64)(1374389535LL * v9) >> 32) >> 5) - v21)) >> 31)
        + v13
        - ((unsigned int)(v9 - 400 * v13) >> 31);
    if ( (int)(v8 - 1) < 0 )
      v12 = v8 + 2;
    v14 = 365 * (v7 - v8)
        + (int)(v8 - 1) / -400
        + ((unsigned int)((int)(v8 - 1) % 400) >> 31)
        + ((unsigned int)((int)(v8 - 1) % 4) >> 31)
        - (v12 >> 2)
        + (int)(v8 - 1) / 100
        - ((unsigned int)((int)(v8 - 1) % 100) >> 31);
    v7 = v3 / 365 + v7 - ((unsigned int)(v3 % 365) >> 31);
    v3 += v22 + v14;
  }
  a3[5] = v7 - 1900;
  v16 = _mon_yday;
  a3[7] = v3;
  if ( (v7 & 3) == 0 )
  {
    v16 = (__int16 *)&unk_80DE03A;
    if ( v7 == 100 * (v7 / 100) && v7 != 400 * (v7 / 400) )
      v16 = _mon_yday;
  }
  v17 = (unsigned __int16)v16[11];
  for ( i = 11; v17 > v3; v17 = (unsigned __int16)v16[i] )
    --i;
  result = 1;
  a3[4] = i;
  a3[3] = v3 - v17 + 1;
  return result;
}
// 80DE020: using guessed type __int16 _mon_yday[13];

//----- (080AC700) --------------------------------------------------------
int __usercall ranged_convert@<eax>(int (__cdecl *a1)(int *, int)@<eax>, int *a2@<edx>, int a3@<ecx>)
{
  int result; // eax
  int v5; // esi
  int v6; // edi
  int v7; // ebp

  result = a1(a2, a3);
  if ( !result )
  {
    v5 = *a2;
    v6 = 0;
    if ( *a2 )
    {
      if ( ((v5 >> 31) | 1) != v5 )
      {
        do
        {
          if ( v5 >= 0 )
            v7 = v6 + ((v5 - v6) >> 1);
          else
            v7 = v5 + ((v6 - v5) >> 1);
          *a2 = v7;
          result = a1(a2, a3);
          if ( result )
            v6 = v7;
          else
            v5 = v7;
        }
        while ( v6 + ((v5 >> 31) | 1) != v5 );
      }
      if ( v6 )
      {
        if ( !result )
        {
          *a2 = v6;
          return a1(a2, a3);
        }
      }
    }
  }
  return result;
}

//----- (080AC7C0) --------------------------------------------------------
unsigned int __usercall guess_time_tm_isra_0@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4,
        int a5,
        int a6,
        _DWORD *a7)
{
  int v7; // esi
  int v8; // ebx
  signed int v9; // edx
  unsigned int result; // eax

  if ( !a7
    || (v7 = (__PAIR64__((a1 >> 2) + 475, a1 & 3) - 1) >> 32,
        v8 = ((int)a7[5] >> 2) + 475 - ((a7[5] & 3) == 0),
        v9 = a5
           + 60
           * (a4
            + 60
            * (a3
             + 24
             * (a2
              + 365 * (a1 - a7[5])
              - a7[7]
              + ((int)(v7 / 25 - ((unsigned int)(v7 % 25) >> 31)) >> 2)
              - ((int)(v8 / 25 - ((unsigned int)(v8 % 25) >> 31)) >> 2)
              + v8 / 25
              - ((unsigned int)(v8 % 25) >> 31)
              - (v7 / 25
               - ((unsigned int)(v7 % 25) >> 31))
              + v7
              - v8)
             - a7[2])
            - a7[1])
           - *a7,
        result = a6 + v9,
        a6 + v9 >= a6 == v9 < 0) )
  {
    if ( a6 < 0 )
    {
      result = 0x80000000;
      if ( a6 == 0x80000000 || a6 == -2147483647 )
        return a6 + 1;
    }
    else
    {
      result = 0x7FFFFFFF;
      if ( a6 >= 2147483646 )
        return a6 - 1;
    }
  }
  return result;
}

//----- (080AC900) --------------------------------------------------------
int __cdecl _mktime_internal(int *a1, int (__cdecl *a2)(int *, int), int *a3)
{
  int v3; // ebx
  int v4; // eax
  int v5; // ecx
  unsigned int v6; // ebx
  char v7; // bp
  _BOOL4 v8; // eax
  int v9; // ebp
  int v10; // edi
  int v11; // ecx
  int v12; // ecx
  int v13; // ebx
  int v14; // esi
  int v15; // ebp
  _DWORD *v16; // eax
  unsigned int v17; // eax
  int *v18; // esi
  _BOOL4 v19; // edx
  int v20; // edi
  int v21; // ebp
  int v22; // eax
  unsigned __int8 v23; // cl
  int v25; // ebp
  int v26; // eax
  int v27; // [esp+14h] [ebp-B8h]
  int v28; // [esp+18h] [ebp-B4h]
  int v29; // [esp+1Ch] [ebp-B0h]
  int v30; // [esp+1Ch] [ebp-B0h]
  int v31; // [esp+20h] [ebp-ACh]
  int v32; // [esp+24h] [ebp-A8h]
  int v33; // [esp+28h] [ebp-A4h]
  int v34; // [esp+2Ch] [ebp-A0h]
  int v35; // [esp+30h] [ebp-9Ch]
  int v36; // [esp+34h] [ebp-98h]
  int v37; // [esp+38h] [ebp-94h]
  int v38; // [esp+3Ch] [ebp-90h]
  int v39[8]; // [esp+4Ch] [ebp-80h] BYREF
  int v40; // [esp+6Ch] [ebp-60h]
  int v41; // [esp+70h] [ebp-5Ch]
  int v42; // [esp+74h] [ebp-58h]
  _DWORD v43[8]; // [esp+78h] [ebp-54h] BYREF
  int v44; // [esp+98h] [ebp-34h]
  int v45; // [esp+A4h] [ebp-28h] BYREF
  int v46; // [esp+A8h] [ebp-24h] BYREF
  int v47[8]; // [esp+ACh] [ebp-20h] BYREF

  v37 = *a1;
  v32 = a1[2];
  v31 = a1[1];
  v36 = a1[5];
  v29 = a1[3];
  v3 = a1[4];
  v35 = (a1[8] >> 31) | (a1[8] != 0);
  v4 = v3 / 12;
  v5 = v3 % 12;
  v6 = (unsigned int)(v3 % 12) >> 31;
  v28 = v36 + v4 - v6;
  v7 = v36 + v4 - v6;
  v8 = 0;
  v9 = v7 & 3;
  if ( !v9 )
  {
    v8 = 1;
    if ( v28 == 100 * (v28 / 100) )
      v8 = ((v28 / 100) & 3) == 1;
  }
  v10 = 0;
  v33 = v29 + (unsigned __int16)_mon_yday[13 * v8 + 12 * v6 + v5] - 1;
  v38 = *a3;
  if ( v37 >= 0 )
  {
    LOWORD(v10) = 59;
    if ( v37 <= 59 )
      v10 = *a1;
  }
  v11 = (__PAIR64__((v28 >> 2) + 475, v9) - 1) >> 32;
  v34 = v38
      + v10
      + 60
      * (v31
       + 60
       * (v32
        + 24
        * (v11
         - (v11 / 25
          - ((unsigned int)(v11 % 25) >> 31))
         + ((int)(v11 / 25 - ((unsigned int)(v11 % 25) >> 31)) >> 2)
         - 477
         + v33
         + 365 * (v28 - 70))));
  v12 = (v31 >> 20) + (v32 >> 14) + (v36 >> 1) + (v29 >> 10) - 35;
  if ( (int)abs32((v34 >> 26) - v12) > 21 )
  {
    v13 = -1;
    if ( (int)abs32((~v34 >> 26) - v12) > 21 )
      return v13;
    v38 += ~v34 - v34;
    v34 = ~v34;
  }
  v14 = 6;
  v30 = 0;
  v46 = v34;
  v15 = v34;
  v45 = v34;
  while ( 1 )
  {
    v16 = (_DWORD *)ranged_convert(a2, &v45, (int)v39);
    v13 = v45;
    v17 = guess_time_tm_isra_0(v28, v33, v32, v31, v10, v45, v16);
    if ( v13 == v17 )
    {
      v18 = a1;
      if ( v35 >= 0 && v40 != v35 )
      {
        v25 = 601200;
        if ( v40 >= 0 )
        {
          v26 = v13;
          while ( 1 )
          {
            v47[0] = v26 - v25;
            if ( v26 <= v26 - v25 )
            {
              v47[0] = v25 + v26;
              if ( v25 + v26 >= v26 )
                goto LABEL_39;
            }
            else
            {
              ranged_convert(a2, v47, (int)v43);
              if ( v44 == v35 )
                goto LABEL_41;
              v26 = v45;
              v47[0] = v25 + v45;
              if ( v25 + v45 >= v45 )
              {
LABEL_39:
                ranged_convert(a2, v47, (int)v43);
                if ( v44 == v35 )
                {
LABEL_41:
                  v18 = a1;
                  v45 = guess_time_tm_isra_0(v28, v33, v32, v31, v10, v47[0], v43);
                  ranged_convert(a2, &v45, (int)v39);
                  v13 = v45;
                  break;
                }
                v26 = v45;
              }
            }
            v25 += 601200;
            if ( v25 == 269337600 )
            {
              v18 = a1;
              v13 = v26;
              break;
            }
          }
        }
      }
LABEL_20:
      *a3 = v13 + v38 - v34;
      if ( v37 != v39[0] )
      {
        v19 = 0;
        if ( !v10 )
          v19 = v39[0] == 60;
        v27 = v19 - v10;
        v20 = v13 + v37;
        v21 = v13 + v37 + v27;
        v46 = v21;
        v22 = a2(&v46, (int)v39);
        v23 = (v37 < 0) ^ (v13 + v37 < v13);
        v13 = -1;
        if ( (v27 < 0) ^ (v20 > v21) | v23 | (v22 == 0) )
          return v13;
        v13 = v46;
      }
      *v18 = v39[0];
      v18[1] = v39[1];
      v18[2] = v39[2];
      v18[3] = v39[3];
      v18[4] = v39[4];
      v18[5] = v39[5];
      v18[6] = v39[6];
      v18[7] = v39[7];
      v18[8] = v40;
      v18[9] = v41;
      v18[10] = v42;
      return v13;
    }
    if ( v15 == v13 && v13 != v46 )
    {
      if ( v40 < 0 )
        goto LABEL_19;
      if ( v35 < 0 )
      {
        if ( v30 <= (v40 != 0) )
        {
LABEL_19:
          v18 = a1;
          goto LABEL_20;
        }
      }
      else if ( (v35 != 0) != (v40 != 0) )
      {
        goto LABEL_19;
      }
    }
    if ( !--v14 )
      return -1;
    v15 = v46;
    v46 = v13;
    v45 = v17;
    v30 = v40 != 0;
  }
}
// 80DE020: using guessed type __int16 _mon_yday[13];
// 80AC900: using guessed type _DWORD var_54[8];

//----- (080ACE20) --------------------------------------------------------
int __usercall timelocal@<eax>(long double a1@<st0>, int *a2)
{
  tzset(a1);
  return _mktime_internal(a2, (int (__cdecl *)(int *, int))localtime_r, &localtime_offset);
}
// 80F0ED8: using guessed type int localtime_offset;

//----- (080ACE50) --------------------------------------------------------
void __cdecl readdir(_DWORD *a1)
{
  bool v3; // zf
  unsigned int v4; // eax
  int v5; // ecx
  int v6; // ebp
  int v7; // ecx
  int v8; // eax
  unsigned int v9; // [esp+Ch] [ebp-20h]

  _ECX = 1;
  _EBX = a1;
  v9 = __readgsdword(0xFFFFFFE8);
  v3 = __readgsdword(0xCu) == 0;
  if ( !v3 )
    __asm { lock }
  __asm { cmpxchg [ebx+4], ecx }
  if ( !v3 )
  {
    L_lock_21_0(0, (int)a1);
    return;
  }
  v4 = a1[4];
  while ( v4 < a1[3] )
  {
LABEL_5:
    v5 = (int)a1 + v4 + 16;
    v4 += *(unsigned __int16 *)((char *)a1 + v4 + 32);
    v6 = *(_DWORD *)(v5 + 12);
    v7 = *(_DWORD *)(v5 + 8);
    a1[4] = v4;
    a1[5] = v6;
    if ( v7 )
      goto LABEL_11;
  }
  v8 = _getdents(a1[2], (unsigned int)(a1 + 6));
  if ( v8 > 0 )
  {
    a1[3] = v8;
    v4 = 0;
    goto LABEL_5;
  }
  if ( !v8 || __readgsdword(0xFFFFFFE8) == 2 )
    __writegsdword(0xFFFFFFE8, v9);
LABEL_11:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v3 = a1[1]-- == 1;
  if ( !v3 )
    L_unlock_92_0((int)a1);
}

//----- (080ACEFD) --------------------------------------------------------
void __usercall L_lock_21_0(int a1@<eax>, int a2@<ebx>)
{
  _lll_lock_wait_private(a1, (volatile __int32 *)(a2 + 4));
  JUMPOUT(0x80ACE80);
}
// 80ACF05: control flows out of bounds to 80ACE80

//----- (080ACF0A) --------------------------------------------------------
void __usercall L_unlock_92_0(int a1@<ebx>)
{
  _lll_unlock_wake_private((_DWORD *)(a1 + 4));
  JUMPOUT(0x80ACEE9);
}
// 80ACF12: control flows out of bounds to 80ACEE9

//----- (080ACF20) --------------------------------------------------------
void __cdecl rewinddir(int *a1)
{
  bool v3; // zf

  _ECX = 1;
  _EBX = a1;
  v3 = __readgsdword(0xCu) == 0;
  if ( !v3 )
    __asm { lock }
  __asm { cmpxchg [ebx+4], ecx }
  if ( v3 )
  {
    lseek(*a1, 0);
    a1[5] = 0;
    a1[4] = 0;
    a1[3] = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v3 = a1[1]-- == 1;
    if ( !v3 )
      L_unlock_28((int)a1);
  }
  else
  {
    L_lock_16(0, (int)a1);
  }
}

//----- (080ACF85) --------------------------------------------------------
void __usercall L_lock_16(int a1@<eax>, int a2@<ebx>)
{
  _lll_lock_wait_private(a1, (volatile __int32 *)(a2 + 4));
  JUMPOUT(0x80ACF40);
}
// 80ACF8D: control flows out of bounds to 80ACF40

//----- (080ACF8F) --------------------------------------------------------
void __usercall L_unlock_28(int a1@<ebx>)
{
  _lll_unlock_wake_private((_DWORD *)(a1 + 4));
  JUMPOUT(0x80ACF80);
}
// 80ACF97: control flows out of bounds to 80ACF80

//----- (080ACFA0) --------------------------------------------------------
int __fastcall _getdents(int a1, unsigned int a2)
{
  unsigned int v2; // esi
  unsigned int v3; // eax
  unsigned int v4; // edi
  int i; // ebp
  int v6; // eax
  int v7; // eax
  char v9; // [esp+1Ch] [ebp-20h]

  v2 = a2;
  v3 = dl_sysinfo(a2);
  if ( v3 > 0xFFFFF000 )
  {
    i = -1;
    __writegsdword(0xFFFFFFE8, -v3);
  }
  else
  {
    v4 = v2 + v3;
    for ( i = v3; v4 > v2; v2 += v7 )
    {
      v9 = *(_BYTE *)(v2 + *(unsigned __int16 *)(v2 + 8) - 1);
      v6 = strlen((_BYTE *)(v2 + 10));
      memmove((void *)(v2 + 11), (const void *)(v2 + 10), v6 + 1);
      v7 = *(unsigned __int16 *)(v2 + 8);
      *(_BYTE *)(v2 + 10) = v9;
    }
  }
  return i;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080AD030) --------------------------------------------------------
unsigned int __fastcall _getdents64(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080AD070) --------------------------------------------------------
int *__usercall fdopendir@<eax>(int a1@<ebp>, int a2)
{
  int v2; // eax
  char v4[16]; // [esp+10h] [ebp-6Ch] BYREF
  int v5; // [esp+20h] [ebp-5Ch]

  if ( (_fxstat64(3, a2, (int)v4) & 0x80000000) != 0 )
    return 0;
  if ( (v5 & 0xF000) != 0x4000 )
  {
    __writegsdword(0xFFFFFFE8, 0x14u);
    return 0;
  }
  v2 = fcntl(a1, a2, 3);
  if ( v2 == -1 )
    return 0;
  if ( (v2 & 3) != 1 )
    return _alloc_dir(a2, 0, v2, (int)v4);
  __writegsdword(0xFFFFFFE8, 0x16u);
  return 0;
}

//----- (080AD110) --------------------------------------------------------
unsigned int __cdecl execve(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080AD150) --------------------------------------------------------
unsigned int __cdecl _lxstat64(int a1, int a2, int a3)
{
  unsigned int result; // eax

  result = dl_sysinfo(a3);
  if ( result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080AD180) --------------------------------------------------------
int __cdecl _fxstatat64(int a1, int a2, int a3)
{
  unsigned int v3; // eax

  if ( a1 == 3 )
  {
    v3 = dl_sysinfo(a3);
    if ( v3 <= 0xFFFFF000 )
    {
      return 0;
    }
    else
    {
      __writegsdword(0xFFFFFFE8, -v3);
      return -1;
    }
  }
  else
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    return -1;
  }
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080AD1F0) --------------------------------------------------------
unsigned int __cdecl _openat64_nocancel(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -result);
    return -1;
  }
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080AD240) --------------------------------------------------------
int __usercall openat64@<eax>(int a1@<ebp>, int a2, int a3)
{
  unsigned int v3; // esi
  int v5; // edi

  if ( __readgsdword(0xCu) )
  {
    v5 = _libc_enable_asynccancel();
    v3 = dl_sysinfo(a3);
    if ( v3 > 0xFFFFF000 )
    {
      __writegsdword(0xFFFFFFE8, -v3);
      v3 = -1;
    }
    _libc_disable_asynccancel(v5, a1);
  }
  else
  {
    v3 = dl_sysinfo(a3);
    if ( v3 > 0xFFFFF000 )
    {
      __writegsdword(0xFFFFFFE8, -v3);
      return -1;
    }
  }
  return v3;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080AD2F0) --------------------------------------------------------
int __usercall _openat64_2@<eax>(int a1@<ebp>, long double a2@<st0>, int a3, int a4, char a5)
{
  if ( (a5 & 0x40) != 0 )
    _fortify_fail((int)"invalid openat64 call: O_CREAT without mode", a2);
  return openat64(a1, a3, a4);
}

//----- (080AD330) --------------------------------------------------------
unsigned int __cdecl lseek(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080AD360) --------------------------------------------------------
_BOOL4 __cdecl isatty(int a1)
{
  char v2[72]; // [esp+14h] [ebp-48h] BYREF

  return tcgetattr(a1, (int)v2) == 0;
}
// 80AD360: using guessed type char var_48[72];

//----- (080AD390) --------------------------------------------------------
int __cdecl tcgetattr(int a1, int a2)
{
  __int64 v2; // rax
  __int16 v3; // cx
  char v4; // dl
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  char v10; // [esp+1Ch] [ebp-1Ch]

  v2 = dl_sysinfo(21505);
  if ( (unsigned int)v2 > 0xFFFFF000 )
  {
    __writegsdword(0xFFFFFFE8, -(int)v2);
    LODWORD(v2) = -1;
  }
  else if ( !(_DWORD)v2 )
  {
    *(_DWORD *)(a2 + 36) = 0;
    *(_DWORD *)(a2 + 40) = 0;
    *(_DWORD *)a2 = v6;
    *(_DWORD *)(a2 + 12) = v9;
    *(_DWORD *)(a2 + 44) = 0;
    *(_BYTE *)(a2 + 48) = 0;
    *(_DWORD *)(a2 + 4) = v7;
    *(_BYTE *)(a2 + 16) = v10;
    *(_DWORD *)(a2 + 8) = v8;
    *(_DWORD *)(a2 + 52) = v8 & 0x100F;
    *(_DWORD *)(a2 + 56) = v8 & 0x100F;
    *(_QWORD *)(a2 + 17) = *(_QWORD *)(HIDWORD(v2) + 17);
    *(_QWORD *)(a2 + 25) = *(_QWORD *)(HIDWORD(v2) + 25);
    v3 = *(_WORD *)(HIDWORD(v2) + 33);
    v4 = *(_BYTE *)(HIDWORD(v2) + 35);
    *(_WORD *)(a2 + 33) = v3;
    *(_BYTE *)(a2 + 35) = v4;
  }
  return v2;
}
// 80AD3D2: variable 'v6' is possibly undefined
// 80AD3D8: variable 'v9' is possibly undefined
// 80AD3EB: variable 'v7' is possibly undefined
// 80AD3F2: variable 'v10' is possibly undefined
// 80AD3F5: variable 'v8' is possibly undefined
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080AD450) --------------------------------------------------------
int (*__usercall dl_fixup@<eax>(int (**a1)(void)@<eax>, int a2@<edx>))(void)
{
  int *v2; // edx
  unsigned int v3; // edi
  unsigned int v4; // esi
  int v5; // ecx
  int (*v6)(void); // edi
  int v7; // edx
  int v8; // esi
  int (**v9)(void); // esi
  int (*result)(void); // eax
  int (*v12)(void); // [esp+28h] [ebp-34h]
  int v13; // [esp+2Ch] [ebp-30h]
  int v14; // [esp+3Ch] [ebp-20h]

  v2 = (int *)(*((_DWORD *)a1[31] + 1) + a2);
  v3 = v2[1];
  v4 = v3 >> 8;
  v5 = *((_DWORD *)a1[14] + 1) + 16 * (v3 >> 8);
  v13 = *v2;
  v14 = v5;
  v12 = *a1;
  if ( (_BYTE)v3 != 7 )
    _assert_fail("((reloc->r_info) & 0xff) == 7", "dl-runtime.c", 87, "_dl_fixup");
  if ( (*(_BYTE *)(v5 + 13) & 3) != 0 )
  {
    result = *a1;
LABEL_12:
    result = (int (*)(void))((char *)result + *(_DWORD *)(v5 + 4));
    if ( (*(_BYTE *)(v5 + 12) & 0xF) == 10 )
      result = (int (*)(void))result();
    goto LABEL_14;
  }
  v6 = a1[57];
  v7 = 0;
  if ( v6 )
  {
    v7 = (int)a1[92] + 16 * (*(_WORD *)(*((_DWORD *)v6 + 1) + 2 * v4) & 0x7FFF);
    if ( !*(_DWORD *)(v7 + 4) )
      v7 = *(_BYTE *)(v5 + 13) & 3;
  }
  if ( __readgsdword(0xCu) )
  {
    __writegsdword(0x1Cu, 1u);
    v8 = 5;
  }
  else
  {
    v8 = 1;
  }
  v9 = (int (**)(void))dl_lookup_symbol_x(a1[115], v7, 1, v8, 0);
  if ( __readgsdword(0xCu) && _InterlockedExchange(MK_FP(__GS__, 28), 0) == 2 )
    dl_sysinfo(129);
  v5 = v14;
  result = 0;
  if ( v14 )
  {
    if ( v9 )
      result = *v9;
    goto LABEL_12;
  }
LABEL_14:
  if ( !dl_bind_not )
    *(_DWORD *)((char *)v12 + v13) = result;
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808B7D0: using guessed type _DWORD __stdcall dl_lookup_symbol_x(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80F11B0: using guessed type int dl_bind_not;

//----- (080AD5E0) --------------------------------------------------------
int (*__userpurge dl_profile_fixup@<eax>(
        _DWORD *a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        int a4,
        _DWORD *a5))(void)
{
  int (**v5)(void); // edi
  int (*v6)(void); // esi
  unsigned int v7; // edx
  unsigned int v8; // ebx
  int v9; // ecx
  int v10; // ebp
  int v11; // edx
  int v12; // ebp
  int *v13; // ebp
  int v14; // esi
  int v18; // [esp+3Ch] [ebp-20h]

  v5 = (int (**)(void))(a1[104] + 20 * (a2 >> 3));
  v6 = *v5;
  if ( *v5 )
    goto LABEL_16;
  v7 = *(_DWORD *)(a2 + *(_DWORD *)(a1[31] + 4) + 4);
  v8 = v7 >> 8;
  v9 = *(_DWORD *)(a1[14] + 4) + 16 * (v7 >> 8);
  v18 = v9;
  if ( (_BYTE)v7 != 7 )
    _assert_fail("((reloc->r_info) & 0xff) == 7", "dl-runtime.c", 192, "_dl_profile_fixup");
  if ( (*(_BYTE *)(v9 + 13) & 3) != 0 )
  {
    v6 = (int (*)(void))(*a1 + *(_DWORD *)(v9 + 4));
    if ( (*(_BYTE *)(v9 + 12) & 0xF) != 10 )
      goto LABEL_14;
  }
  else
  {
    v10 = a1[57];
    v11 = 0;
    if ( v10 )
    {
      v11 = a1[92] + 16 * (*(_WORD *)(*(_DWORD *)(v10 + 4) + 2 * v8) & 0x7FFF);
      if ( !*(_DWORD *)(v11 + 4) )
        v11 = 0;
    }
    if ( __readgsdword(0xCu) )
    {
      __writegsdword(0x1Cu, 1u);
      v12 = 5;
    }
    else
    {
      v12 = 1;
    }
    v13 = (int *)dl_lookup_symbol_x(a1[115], v11, 1, v12, 0);
    if ( __readgsdword(0xCu) && _InterlockedExchange(MK_FP(__GS__, 28), 0) == 2 )
      dl_sysinfo(129);
    if ( !v18 )
      goto LABEL_14;
    v14 = 0;
    if ( v13 )
      v14 = *v13;
    v6 = (int (*)(void))(*(_DWORD *)(v18 + 4) + v14);
    if ( (*(_BYTE *)(v18 + 12) & 0xF) != 10 )
      goto LABEL_14;
  }
  v6 = (int (*)(void))v6();
LABEL_14:
  if ( !dl_bind_not )
    *v5 = v6;
LABEL_16:
  *a5 = -1;
  dl_mcount(a3, (int)v6);
  return v6;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808B7D0: using guessed type _DWORD __stdcall dl_lookup_symbol_x(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80F11B0: using guessed type int dl_bind_not;

//----- (080AD7B0) --------------------------------------------------------
int __usercall dl_start_profile@<eax>(long double a1@<st0>)
{
  int *v1; // edi
  unsigned int v2; // eax
  unsigned int v3; // edx
  unsigned int v4; // esi
  unsigned int v5; // ebx
  int v6; // ecx
  int v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // esi
  unsigned int v10; // edx
  int v11; // ebx
  void *v12; // esp
  const char *v13; // ebx
  _BYTE *v14; // eax
  int v15; // edx
  int v16; // edi
  const char *v17; // esi
  void *v18; // edx
  char *v19; // eax
  int result; // eax
  void *v21; // eax
  _DWORD *v22; // edx
  int *v23; // edi
  int v24; // eax
  int v25; // eax
  int v26; // ebx
  int *v27; // eax
  int v28; // edx
  unsigned int v29; // ecx
  int v30; // esi
  int *v31; // edi
  _WORD *v32; // ecx
  int v33; // eax
  unsigned int v34; // esi
  unsigned int v35; // ecx
  void *v36; // esp
  unsigned int v37; // ebx
  void *v38; // esi
  int v39; // eax
  int v40; // eax
  int v41; // eax
  int v42; // [esp+0h] [ebp-298h] BYREF
  int v43; // [esp+8h] [ebp-290h]
  int v44; // [esp+20h] [ebp-278h] BYREF
  size_t n; // [esp+24h] [ebp-274h]
  int v46; // [esp+28h] [ebp-270h]
  int v47; // [esp+2Ch] [ebp-26Ch]
  void *s1; // [esp+38h] [ebp-260h]
  const char *v49; // [esp+3Ch] [ebp-25Ch]
  unsigned int v50; // [esp+40h] [ebp-258h]
  unsigned int v51; // [esp+44h] [ebp-254h]
  int v52; // [esp+48h] [ebp-250h]
  unsigned int v53; // [esp+4Ch] [ebp-24Ch]
  char v54[400]; // [esp+5Ch] [ebp-23Ch] BYREF
  char v55[16]; // [esp+1ECh] [ebp-ACh] BYREF
  int v56; // [esp+1FCh] [ebp-9Ch]
  __int64 v57; // [esp+218h] [ebp-80h]
  int v58; // [esp+24Ch] [ebp-4Ch] BYREF
  int v59; // [esp+250h] [ebp-48h]
  unsigned int v60; // [esp+254h] [ebp-44h]
  int v61; // [esp+258h] [ebp-40h]
  _DWORD v62[2]; // [esp+25Ch] [ebp-3Ch] BYREF
  int v63; // [esp+264h] [ebp-34h]
  int v64; // [esp+268h] [ebp-30h]
  int s2; // [esp+26Ch] [ebp-2Ch] BYREF
  int v66; // [esp+270h] [ebp-28h]
  int v67; // [esp+274h] [ebp-24h]
  int v68; // [esp+278h] [ebp-20h]
  int v69; // [esp+27Ch] [ebp-1Ch]
  int savedregs; // [esp+298h] [ebp+0h] BYREF

  v1 = (int *)dl_profile_map;
  v2 = *(_DWORD *)(dl_profile_map + 336);
  v3 = v2 + 32 * *(unsigned __int16 *)(dl_profile_map + 344);
  if ( v2 >= v3 )
  {
    v52 = 0;
    v6 = -1;
    v5 = 0;
    v4 = -1;
  }
  else
  {
    v4 = -1;
    v50 = dl_profile_map;
    v52 = -dl_pagesize;
    v5 = 0;
    v51 = dl_pagesize - 1;
    do
    {
      while ( *(_DWORD *)v2 != 1 || (*(_BYTE *)(v2 + 24) & 1) == 0 )
      {
        v2 += 32;
        if ( v2 >= v3 )
          goto LABEL_11;
      }
      if ( v4 > ((unsigned int)v52 & *(_DWORD *)(v2 + 8)) )
        v4 = v52 & *(_DWORD *)(v2 + 8);
      if ( (v52 & (*(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 8) + v51)) > v5 )
        v5 = v52 & (*(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 8) + v51);
      v2 += 32;
    }
    while ( v2 < v3 );
LABEL_11:
    v1 = (int *)v50;
    v6 = v4;
    v52 = v5;
  }
  v7 = *v1;
  running = 0;
  log_hashfraction = 4;
  v8 = (v4 + v7) & 0xFFFFFFFC;
  v9 = (v5 + v7 + 3) & 0xFFFFFFFC;
  lowpc = v8;
  textsize = v9 - v8;
  v53 = (v9 - v8) >> 1;
  v10 = 3 * (v9 - v8) / 0x64;
  fromlimit = v10;
  if ( v10 > 0x31 )
  {
    if ( v10 <= 0x100000 )
    {
      v50 = 8 * v10;
      v51 = 96 * v10 + 64;
    }
    else
    {
      fromlimit = 0x100000;
      v51 = 100663360;
      v50 = 0x800000;
    }
  }
  else
  {
    fromlimit = 50;
    v51 = 4864;
    v50 = 400;
  }
  v58 = v6;
  s2 = 1852796263;
  v59 = v52;
  v66 = 0x1FFFF;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v60 = v53 >> 1;
  strcpy((char *)v62, "seconds");
  v63 = 0;
  v64 = 1929379840;
  v61 = _profile_frequency();
  v11 = strlen((_BYTE *)dl_profile_output);
  v12 = alloca(v11 + strlen((_BYTE *)dl_profile) + 25);
  v13 = (const char *)&v44;
  v14 = (_BYTE *)stpcpy(&v44, dl_profile_output);
  v15 = dl_profile;
  *v14 = 47;
  strcpy((char *)stpcpy(v14 + 1, v15), ".profile");
  v43 = 438;
  v16 = open((int)&savedregs, (int)&v44, 131138);
  if ( v16 == -1 )
  {
    v17 = "%s: cannot open file: %s\n";
    v18 = (void *)__readgsdword(0xFFFFFFE8);
    goto LABEL_19;
  }
  if ( (_fxstat64(3, v16, (int)v55) & 0x80000000) != 0 || (v56 & 0xF000) != 0x8000 )
  {
    v17 = "%s: cannot stat file: %s\n";
LABEL_18:
    s1 = (void *)__readgsdword(0xFFFFFFE8);
    close((int)&savedregs, v16);
    v18 = s1;
LABEL_19:
    v19 = strerror_r(a1, (signed int)v18, v54, 0x190u);
    return dl_dprintf(2, (int)v17, v13, v19);
  }
  v52 = v53 + v51;
  v51 = v57;
  if ( v57 )
  {
    v46 = v52;
    v47 = v52 >> 31;
    if ( v52 != __PAIR64__(HIDWORD(v57), v51) )
    {
      close((int)&savedregs, v16);
      return dl_dprintf(2, (int)"%s: file is no correct profile data file for `%s'\n", v13, (const char *)dl_profile);
    }
  }
  else
  {
    v51 = (unsigned int)&v42;
    n = dl_pagesize;
    v49 = (const char *)(dl_pagesize + 30);
    v36 = alloca(16 * ((dl_pagesize + 30) / 0x10u));
    s1 = &v44;
    memset(&v44, 0, dl_pagesize);
    v43 = 0;
    if ( lseek(v16, v52 & -n) == -1 )
    {
LABEL_50:
      v17 = "%s: cannot create file: %s\n";
      goto LABEL_18;
    }
    v49 = (const char *)&v44;
    v37 = v9;
    v38 = s1;
    while ( 1 )
    {
      v39 = write((int)&savedregs, v16, (int)v38, v52 & (dl_pagesize - 1));
      if ( v39 != -1 )
        break;
      if ( __readgsdword(0xFFFFFFE8) != 4 )
      {
        v13 = v49;
        goto LABEL_50;
      }
    }
    v9 = v37;
    v13 = v49;
    if ( v39 < 0 )
      goto LABEL_50;
  }
  v21 = (void *)mmap(0, v52, 3, 1, v16, 0);
  if ( v21 == (void *)-1 )
  {
    v17 = "%s: cannot map file: %s\n";
    goto LABEL_18;
  }
  s1 = v21;
  close((int)&savedregs, v16);
  v22 = s1;
  v49 = (char *)s1 + 56;
  v23 = (int *)((char *)s1 + v53 + 60);
  data = (int)s1 + v53 + 64;
  narcsp = (int)v23;
  if ( v57 )
  {
    v40 = memcmp(s1, &s2, 0x14u);
    v22 = s1;
    if ( v40 || *((_DWORD *)s1 + 5) || (v41 = memcmp((char *)s1 + 24, &v58, 0x20u), v22 = s1, v41) || *(v23 - 1) != 1 )
    {
      if ( v22 )
        munmap((int)v22, v52);
      return dl_dprintf(2, (int)"%s: file is no correct profile data file for `%s'\n", v13, (const char *)dl_profile);
    }
  }
  else
  {
    v24 = s2;
    *((_DWORD *)s1 + 5) = 0;
    *v22 = v24;
    v22[1] = v66;
    v22[2] = v67;
    v22[3] = v68;
    v22[4] = v69;
    v22[6] = v58;
    v22[7] = v59;
    v22[8] = v60;
    v22[9] = v61;
    v22[10] = v62[0];
    v22[11] = v62[1];
    v22[12] = v63;
    v22[13] = v64;
    *(v23 - 1) = 1;
  }
  s1 = v22;
  calloc(v53 + v50, 1u);
  v51 = v25;
  tos = v25;
  if ( !v25 )
  {
    munmap((int)s1, v52);
    dl_dprintf(2, (int)"Out of memory while initializing profiler\n");
    exit(127);
  }
  fromidx = 0;
  v26 = fromlimit;
  v52 = v53 + v51;
  froms = v53 + v51;
  if ( *v23 < (unsigned int)fromlimit )
    v26 = *v23;
  narcs = v26;
  if ( v26 )
  {
    v27 = &v23[3 * v26 - 1];
    v50 = v9;
    do
    {
      v28 = fromidx;
      v29 = *v27;
      ++fromidx;
      v30 = v52 + 8 * v28;
      v31 = v27 - 1;
      v27 -= 3;
      *(_DWORD *)v30 = v31;
      --v26;
      v32 = (_WORD *)(v51 + 2 * (v29 >> 2));
      *(_WORD *)(v30 + 4) = *v32;
      *v32 = v28;
    }
    while ( v26 );
    v9 = v50;
  }
  v33 = 0x10000;
  v34 = v9 - lowpc;
  if ( v53 < v34 )
  {
    v35 = v34 / v53;
    v33 = 1;
    if ( v34 / v53 <= 0xFFFF )
    {
      if ( v35 <= 0xFF )
      {
        if ( v34 <= 0xFFFFFF )
          v33 = 0x1000000 / ((v34 << 8) / v53);
        else
          v33 = 0x1000000 / (v34 / (v53 >> 8));
      }
      else
      {
        v33 = 0x10000 / v35;
      }
    }
  }
  result = profil((int)v49, v53, lowpc, v33);
  running = 1;
  return result;
}
// 80ADC24: variable 'v25' is possibly undefined
// 80481F0: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 80EF5B8: using guessed type int dl_pagesize;
// 80F0EDC: using guessed type int fromidx;
// 80F0EE0: using guessed type int running;
// 80F0EE4: using guessed type int lowpc;
// 80F0EE8: using guessed type int textsize;
// 80F0EEC: using guessed type int log_hashfraction;
// 80F0EF0: using guessed type int fromlimit;
// 80F0EF4: using guessed type int narcsp;
// 80F0EF8: using guessed type int data;
// 80F0EFC: using guessed type int tos;
// 80F0F00: using guessed type int froms;
// 80F0F04: using guessed type int narcs;
// 80F1180: using guessed type int dl_profile_output;
// 80F11A4: using guessed type int dl_profile;
// 80F11E4: using guessed type int dl_profile_map;
// 80AD7B0: using guessed type char var_AC[16];
// 80AD7B0: using guessed type char var_23C[400];

//----- (080ADF60) --------------------------------------------------------
int __cdecl dl_mcount(int a1, int a2)
{
  int result; // eax
  int v3; // edx
  _DWORD *v4; // esi
  int v5; // edx
  int v6; // edi
  int v7; // ebp
  int v8; // edx
  int v9; // ecx
  __int16 v10; // bx
  int v11; // ecx
  _WORD *v12; // edx
  unsigned int v13; // edx
  __int16 v14; // cx
  int v15; // esi
  int v16; // edi
  int *v17; // ecx
  int v18; // ebx
  int v19; // edx
  unsigned __int16 v20; // bx
  _WORD *v21; // [esp+0h] [ebp-28h]
  int v22; // [esp+4h] [ebp-24h]

  result = running;
  if ( running )
  {
    result = a1 - lowpc;
    if ( a1 - lowpc >= (unsigned int)textsize )
      result = 0;
    v22 = a2 - lowpc;
    if ( textsize > (unsigned int)(a2 - lowpc) )
    {
      v21 = (_WORD *)(tos + 2 * ((unsigned int)(a2 - lowpc) >> log_hashfraction));
      v3 = (unsigned __int16)*v21;
      if ( *v21 )
        goto LABEL_29;
      while ( 1 )
      {
        v4 = (_DWORD *)narcsp;
        v5 = narcs;
        if ( *(_DWORD *)narcsp != narcs && narcs < (unsigned int)fromlimit )
        {
          v6 = data;
          do
          {
            v7 = 12 * v5;
            v8 = *(_DWORD *)(v6 + 12 * v5 + 4) >> 2;
            if ( __readgsdword(0xCu) )
              __asm { lock }
            v9 = fromidx++;
            v10 = v9 + 1;
            v11 = froms + 8 * (v9 + 1);
            *(_DWORD *)v11 = data + v7;
            v12 = (_WORD *)(tos + 2 * v8);
            *(_WORD *)(v11 + 4) = *v12;
            *v12 = v10;
            if ( __readgsdword(0xCu) )
              __asm { lock }
            v5 = ++narcs;
          }
          while ( *v4 != narcs && narcs < (unsigned int)fromlimit );
        }
        if ( !*v21 )
          break;
        v3 = (unsigned __int16)*v21;
LABEL_29:
        v19 = froms + 8 * v3;
        v17 = *(int **)v19;
        if ( **(_DWORD **)v19 == result )
          goto LABEL_24;
        v20 = *(_WORD *)(v19 + 4);
        if ( v20 )
        {
          do
          {
            v19 = froms + 8 * v20;
            v20 = *(_WORD *)(v19 + 4);
            v17 = *(int **)v19;
          }
          while ( v20 && *v17 != result );
        }
        if ( *v17 == result )
          goto LABEL_24;
        v21 = (_WORD *)(v19 + 4);
      }
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v13 = (*v4)++;
      if ( v13 < fromlimit )
      {
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v14 = fromidx++;
        v15 = froms;
        v16 = data;
        *v21 = v14 + 1;
        v17 = (int *)(v16 + 12 * v13);
        v18 = v15 + 8 * (unsigned __int16)*v21;
        *(_DWORD *)v18 = v17;
        *v17 = result;
        result = v22;
        v17[2] = 0;
        v17[1] = v22;
        *(_WORD *)(v18 + 4) = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        ++narcs;
LABEL_24:
        if ( __readgsdword(0xCu) )
          __asm { lock }
        ++v17[2];
      }
    }
  }
  return result;
}
// 80F0EDC: using guessed type int fromidx;
// 80F0EE0: using guessed type int running;
// 80F0EE4: using guessed type int lowpc;
// 80F0EE8: using guessed type int textsize;
// 80F0EEC: using guessed type int log_hashfraction;
// 80F0EF0: using guessed type int fromlimit;
// 80F0EF4: using guessed type int narcsp;
// 80F0EF8: using guessed type int data;
// 80F0EFC: using guessed type int tos;
// 80F0F00: using guessed type int froms;
// 80F0F04: using guessed type int narcs;

//----- (080AE180) --------------------------------------------------------
char __usercall dlerror_run@<al>(
        void (__cdecl *a1)(int)@<eax>,
        int a2@<edx>,
        int a3@<ebx>,
        int a4@<ebp>,
        int a5@<edi>,
        int a6@<esi>)
{
  int v6; // eax
  char v8; // [esp+1Ch] [ebp-20h]
  int v9; // [esp+24h] [ebp-18h] BYREF
  int v10; // [esp+28h] [ebp-14h] BYREF
  char v11[13]; // [esp+2Fh] [ebp-Dh] BYREF

  v10 = 0;
  v6 = dl_catch_error(&v9, &v10, v11, a3, a4, a5, a6, a1, a2);
  if ( !v6 )
  {
    if ( !v10 )
      return v6;
    LOBYTE(v6) = 1;
  }
  if ( v11[0] )
  {
    v8 = v6;
    free(v10);
    LOBYTE(v6) = v8;
  }
  return v6;
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 80AE180: using guessed type char var_D[13];
// 80AE180: using guessed type int var_14;

//----- (080AE1E0) --------------------------------------------------------
char __usercall _libc_dlclose@<al>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5)
{
  return dlerror_run((void (__cdecl *)(int))do_dlclose, a5, a1, a2, a3, a4);
}
// 80AE230: using guessed type int do_dlclose();

//----- (080AE1F0) --------------------------------------------------------
int __usercall _libc_dlsym@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5, int a6)
{
  int v6; // eax
  int v7; // edx
  int v9[2]; // [esp+0h] [ebp-1Ch] BYREF
  int *v10; // [esp+8h] [ebp-14h]
  int v11; // [esp+Ch] [ebp-10h]

  v9[0] = a5;
  v9[1] = a6;
  LOBYTE(v6) = dlerror_run((void (__cdecl *)(int))do_dlsym, (int)v9, a1, a2, a3, a4);
  v7 = 0;
  if ( !v6 )
  {
    if ( v10 )
      v7 = *v10;
    v7 += *(_DWORD *)(v11 + 4);
  }
  return v7;
}
// 80AE212: variable 'v6' is possibly undefined

//----- (080AE240) --------------------------------------------------------
int __usercall do_dlsym@<eax>(long double a1@<st0>, int *a2)
{
  int v2; // edx
  char *v3; // eax
  int result; // eax

  v2 = *a2;
  v3 = (char *)a2[1];
  a2[3] = 0;
  result = dl_lookup_symbol_x(v3, v2, a2 + 3, a1, (int **)(v2 + 464), 0, 0, 2, 0);
  a2[2] = result;
  return result;
}

//----- (080AE2A0) --------------------------------------------------------
int __cdecl do_dlsym_private(int *a1)
{
  int v1; // edx
  int v2; // esi
  int result; // eax
  int v4[7]; // [esp+20h] [ebp-1Ch] BYREF

  v4[0] = (int)"GLIBC_PRIVATE";
  v4[2] = 1;
  v4[1] = 157536133;
  v1 = *a1;
  a1[3] = 0;
  v2 = *(_DWORD *)(v1 + 460);
  v4[3] = 0;
  result = dl_lookup_symbol_x(v2, v4, 0, 0, 0);
  a1[2] = result;
  return result;
}
// 808B7D0: using guessed type _DWORD __stdcall dl_lookup_symbol_x(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080AE320) --------------------------------------------------------
int __cdecl do_dlopen(int *a1)
{
  int result; // eax

  result = dl_open(*a1, a1[1], a1[2], -2, _libc_argc, _libc_argv, (int)environ);
  a1[3] = result;
  return result;
}
// 80F1250: using guessed type int _libc_argc;
// 80F1254: using guessed type int _libc_argv;

//----- (080AE370) --------------------------------------------------------
int __usercall _libc_dlsym_private@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5, int a6)
{
  int v6; // eax
  int v7; // edx
  int v9[2]; // [esp+0h] [ebp-1Ch] BYREF
  int *v10; // [esp+8h] [ebp-14h]
  int v11; // [esp+Ch] [ebp-10h]

  v9[0] = a5;
  v9[1] = a6;
  LOBYTE(v6) = dlerror_run((void (__cdecl *)(int))do_dlsym_private, (int)v9, a1, a2, a3, a4);
  v7 = 0;
  if ( !v6 )
  {
    if ( v10 )
      v7 = *v10;
    v7 += *(_DWORD *)(v11 + 4);
  }
  return v7;
}
// 80AE392: variable 'v6' is possibly undefined

//----- (080AE3B0) --------------------------------------------------------
_DWORD *__usercall _libc_register_dl_open_hook@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5)
{
  _DWORD *result; // eax

  result = (_DWORD *)_libc_dlsym_private(a1, a2, a3, a4, a5, (int)"_dl_open_hook");
  if ( result )
    *result = dl_open_hook;
  return result;
}
// 80EFC34: using guessed type int (__cdecl *dl_open_hook[2])(int, int);

//----- (080AE3E0) --------------------------------------------------------
int __usercall _libc_dlopen_mode@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5, int a6)
{
  int v6; // eax
  int v7; // edx
  int v9[3]; // [esp+10h] [ebp-1Ch] BYREF
  int v10; // [esp+1Ch] [ebp-10h]
  int retaddr; // [esp+2Ch] [ebp+0h]

  v9[0] = a5;
  v9[1] = a6;
  v9[2] = retaddr;
  LOBYTE(v6) = dlerror_run((void (__cdecl *)(int))do_dlopen, (int)v9, a1, a2, a3, a4);
  v7 = 0;
  if ( !v6 )
  {
    _libc_register_dl_open_hook(a1, a2, a3, a4, v10);
    _libc_register_dlfcn_hook(a1, a2, a3, a4, v10);
    return v10;
  }
  return v7;
}
// 80AE40D: variable 'v6' is possibly undefined

//----- (080AE440) --------------------------------------------------------
char *__usercall dl_tlsdesc_resolve_abs_plus_addend_fixup@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // edi
  char *result; // eax
  unsigned int v6; // eax
  char *retaddr; // [esp+2Ch] [ebp+0h]

  v4 = *(_DWORD *)(a1 + 4);
  result = *(char **)a1;
  if ( &retaddr[-a3] == result )
  {
    if ( &retaddr[-a3] == *(char **)a1 )
    {
      *(_DWORD *)a1 = dl_tlsdesc_resolve_hold;
      v6 = *(_DWORD *)(a2 + 576);
      if ( v6 <= 1 )
      {
        dl_allocate_static_tls(a2);
        v6 = *(_DWORD *)(a2 + 576);
      }
      *(_DWORD *)(a1 + 4) = v4 - v6;
      *(_DWORD *)a1 = dl_tlsdesc_return;
    }
    return 0;
  }
  return result;
}

//----- (080AE4F0) --------------------------------------------------------
char *__usercall dl_tlsdesc_resolve_rel_fixup@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)
{
  int v4; // edi
  char *result; // eax
  int v6; // esi
  int v7; // ebp
  int v8; // eax
  int v9; // esi
  int v10; // ecx
  unsigned int v11; // edx
  int v12; // [esp+3Ch] [ebp-20h]
  char *retaddr; // [esp+5Ch] [ebp+0h]

  v4 = *(_DWORD *)(a1 + 4);
  result = *(char **)a1;
  if ( &retaddr[-a3] == result )
  {
    if ( &retaddr[-a3] == *(char **)a1 )
    {
      *(_DWORD *)a1 = dl_tlsdesc_resolve_hold;
      v6 = (int)a2;
      v7 = *(_DWORD *)(v4 + 4) >> 8;
      v8 = *(_DWORD *)(a2[14] + 4) + 16 * v7;
      v12 = v8;
      if ( *(_BYTE *)(v8 + 12) >> 4 && (*(_BYTE *)(v8 + 13) & 3) == 0 )
      {
        v9 = a2[57];
        v10 = 0;
        if ( v9 )
        {
          v10 = a2[92] + 16 * (*(_WORD *)(*(_DWORD *)(v9 + 4) + 2 * v7) & 0x7FFF);
          if ( !*(_DWORD *)(v10 + 4) )
            v10 = *(_BYTE *)(v8 + 13) & 3;
        }
        v6 = dl_lookup_symbol_x(a2[115], v10, 1, 1, 0);
        v8 = v12;
      }
      if ( v8 )
      {
        v11 = *(_DWORD *)(v6 + 576);
        if ( v11 <= 1 )
        {
          dl_allocate_static_tls(v6);
          v8 = v12;
          v11 = *(_DWORD *)(v6 + 576);
        }
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(v8 + 4) - v11;
        *(_DWORD *)a1 = dl_tlsdesc_return;
      }
      else
      {
        *(_DWORD *)(a1 + 4) = 0;
        *(_DWORD *)a1 = dl_tlsdesc_undefweak;
      }
    }
    return 0;
  }
  return result;
}
// 808B7D0: using guessed type _DWORD __stdcall dl_lookup_symbol_x(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080AE660) --------------------------------------------------------
char *__usercall dl_tlsdesc_resolve_rela_fixup@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>)
{
  int v5; // esi
  char *result; // eax
  int v7; // edi
  int v8; // eax
  unsigned __int8 v9; // cl
  int v10; // edi
  int v11; // ecx
  unsigned int v12; // ecx
  int v13; // [esp+28h] [ebp-34h]
  int v14; // [esp+2Ch] [ebp-30h]
  int v15[4]; // [esp+3Ch] [ebp-20h] BYREF
  char *retaddr; // [esp+5Ch] [ebp+0h]

  v5 = *(_DWORD *)(a1 + 4);
  result = *(char **)a1;
  if ( &retaddr[-a3] == result )
  {
    if ( &retaddr[-a3] == *(char **)a1 )
    {
      *(_DWORD *)a1 = dl_tlsdesc_resolve_hold;
      v7 = a2;
      v14 = *(_DWORD *)(*(_DWORD *)(a2 + 52) + 4);
      v13 = *(_DWORD *)(v5 + 4) >> 8;
      v8 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 4) + 16 * v13;
      v9 = *(_BYTE *)(v8 + 12);
      v15[0] = v8;
      if ( v9 >> 4 && (*(_BYTE *)(v8 + 13) & 3) == 0 )
      {
        v10 = *(_DWORD *)(a2 + 228);
        v11 = 0;
        if ( v10 )
        {
          v11 = *(_DWORD *)(a2 + 368) + 16 * (*(_WORD *)(*(_DWORD *)(v10 + 4) + 2 * v13) & 0x7FFF);
          if ( !*(_DWORD *)(v11 + 4) )
            v11 = *(_BYTE *)(v8 + 13) & 3;
        }
        v7 = dl_lookup_symbol_x((char *)(v14 + *(_DWORD *)v8), a2, v15, a4, *(int ***)(a2 + 460), v11, 1, 1, 0);
        v8 = v15[0];
      }
      if ( v8 )
      {
        v12 = *(_DWORD *)(v7 + 576);
        if ( v12 <= 1 )
        {
          dl_allocate_static_tls(v7);
          v8 = v15[0];
          v12 = *(_DWORD *)(v7 + 576);
        }
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(v8 + 4) + *(_DWORD *)(v5 + 8) - v12;
        *(_DWORD *)a1 = dl_tlsdesc_return;
      }
      else
      {
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)a1 = dl_tlsdesc_undefweak;
      }
    }
    return 0;
  }
  return result;
}
// 80AE660: using guessed type int var_20[4];

//----- (080AE7D0) --------------------------------------------------------
char *__usercall dl_tlsdesc_resolve_hold_fixup@<eax>(char **a1@<eax>, int a2@<ecx>)
{
  char *result; // eax
  char *retaddr; // [esp+1Ch] [ebp+0h]

  result = *a1;
  if ( result == &retaddr[-a2] )
    return 0;
  return result;
}

//----- (080AE820) --------------------------------------------------------
unsigned int __usercall dl_unmap@<eax>(int a1@<eax>)
{
  return munmap(*(_DWORD *)(a1 + 428), *(_DWORD *)(a1 + 432) - *(_DWORD *)(a1 + 428));
}

//----- (080AE850) --------------------------------------------------------
_BOOL4 __cdecl _mpn_add_n(_DWORD *a1, _DWORD *a2, _DWORD *a3, unsigned int a4)
{
  unsigned int v7; // ecx
  bool v8; // cf
  _BOOL4 v9; // ett
  int v10; // eax
  int v11; // eax
  _BOOL4 v12; // ett
  int v13; // eax
  int v14; // eax
  _BOOL4 v15; // ett
  int v16; // eax
  int v17; // eax
  _BOOL4 v18; // ett
  int v19; // eax
  int v20; // eax
  _BOOL4 v21; // ett
  int v22; // eax
  int v23; // eax
  _BOOL4 v24; // ett
  int v25; // eax
  int v26; // eax
  _BOOL4 v27; // ett
  int v28; // eax
  int v29; // eax
  _BOOL4 v30; // ett

  v7 = a4 >> 3;
  v8 = 0;
  if ( (-a4 & 7) != 0 )
    __asm { jmp     eax }
  do
  {
    v9 = v8;
    v8 = __CFADD__(v8, *a2) | __CFADD__(*a3, v8 + *a2);
    *a1 = *a3 + v9 + *a2;
    v10 = a2[1];
    v12 = v8;
    v8 = __CFADD__(v8, v10);
    v11 = v12 + v10;
    v8 |= __CFADD__(a3[1], v11);
    a1[1] = a3[1] + v11;
    v13 = a2[2];
    v15 = v8;
    v8 = __CFADD__(v8, v13);
    v14 = v15 + v13;
    v8 |= __CFADD__(a3[2], v14);
    a1[2] = a3[2] + v14;
    v16 = a2[3];
    v18 = v8;
    v8 = __CFADD__(v8, v16);
    v17 = v18 + v16;
    v8 |= __CFADD__(a3[3], v17);
    a1[3] = a3[3] + v17;
    v19 = a2[4];
    v21 = v8;
    v8 = __CFADD__(v8, v19);
    v20 = v21 + v19;
    v8 |= __CFADD__(a3[4], v20);
    a1[4] = a3[4] + v20;
    v22 = a2[5];
    v24 = v8;
    v8 = __CFADD__(v8, v22);
    v23 = v24 + v22;
    v8 |= __CFADD__(a3[5], v23);
    a1[5] = a3[5] + v23;
    v25 = a2[6];
    v27 = v8;
    v8 = __CFADD__(v8, v25);
    v26 = v27 + v25;
    v8 |= __CFADD__(a3[6], v26);
    a1[6] = a3[6] + v26;
    v28 = a2[7];
    v30 = v8;
    v8 = __CFADD__(v8, v28);
    v29 = v30 + v28;
    v8 |= __CFADD__(a3[7], v29);
    a1[7] = a3[7] + v29;
    a1 += 8;
    a2 += 8;
    a3 += 8;
    --v7;
  }
  while ( v7 );
  return v8;
}

//----- (080AE8E0) --------------------------------------------------------
int __cdecl _mpn_addmul_1(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // edi
  int v5; // ecx
  unsigned int v6; // ebp
  unsigned __int64 v7; // kr00_8

  v4 = a1 + 4 * a3;
  v5 = -a3;
  v6 = 0;
  do
  {
    v7 = v6 + a4 * (unsigned __int64)*(unsigned int *)(a2 + 4 * a3 + 4 * v5) + *(unsigned int *)(v4 + 4 * v5);
    *(_DWORD *)(v4 + 4 * v5) = v7;
    v6 = HIDWORD(v7);
    ++v5;
  }
  while ( v5 );
  return HIDWORD(v7);
}

//----- (080AE920) --------------------------------------------------------
unsigned __int64 __cdecl _strtoll_internal(char *a1, char **a2, int a3, int a4)
{
  return ___strtoll_l_internal(a1, a2, a3, a4, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (080AE960) --------------------------------------------------------
unsigned __int64 __cdecl strtoq(char *a1, char **a2, int a3)
{
  return ___strtoll_l_internal(a1, a2, a3, 0, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (080AE9A0) --------------------------------------------------------
__int64 __cdecl _strtoull_internal(char *a1, char **a2, int a3, int a4)
{
  return ___strtoull_l_internal(a1, a2, a3, a4, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (080AE9E0) --------------------------------------------------------
__int64 __cdecl strtouq(char *a1, char **a2, int a3)
{
  return ___strtoull_l_internal(a1, a2, a3, 0, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (080AEA20) --------------------------------------------------------
unsigned __int64 __cdecl ___strtoll_l_internal(char *a1, char **a2, int a3, int a4, _DWORD *a5)
{
  int v5; // eax
  _BYTE *v6; // esi
  int v7; // ebx
  char v8; // al
  char *i; // ebp
  char *v10; // ebp
  char v11; // cl
  int v12; // edx
  int v13; // edi
  unsigned __int8 v14; // al
  char *v15; // ecx
  unsigned int v16; // edx
  unsigned __int8 v17; // bl
  int v18; // ebx
  char *v19; // eax
  unsigned __int64 v20; // rax
  unsigned __int64 result; // rax
  int v22; // edx
  int v23; // ebp
  _BYTE *v24; // edi
  char *v25; // esi
  unsigned __int64 v26; // rax
  unsigned int v27; // kr00_4
  unsigned __int8 v28; // dl
  int v29; // eax
  int v30; // eax
  int v31; // eax
  unsigned __int8 v32; // al
  char *v33; // ecx
  int v34; // edx
  unsigned int v35; // eax
  char v36; // [esp+24h] [ebp-58h]
  unsigned int v37; // [esp+28h] [ebp-54h]
  unsigned __int64 v38; // [esp+28h] [ebp-54h]
  int v39; // [esp+28h] [ebp-54h]
  char *v40; // [esp+34h] [ebp-48h]
  char *v41; // [esp+34h] [ebp-48h]
  int v42; // [esp+38h] [ebp-44h]
  int v43; // [esp+3Ch] [ebp-40h]
  int v44; // [esp+3Ch] [ebp-40h]
  int v45; // [esp+40h] [ebp-3Ch]
  unsigned int v46; // [esp+44h] [ebp-38h]
  int v47; // [esp+48h] [ebp-34h]
  int v48; // [esp+4Ch] [ebp-30h]
  int v49; // [esp+58h] [ebp-24h]
  char *v50; // [esp+5Ch] [ebp-20h]

  v5 = a5[1];
  if ( !a4 || (v40 = *(char **)(v5 + 44), (unsigned __int8)(*v40 - 1) > 0x7Du) || (v6 = *(_BYTE **)(v5 + 40), !*v6) )
  {
    v40 = 0;
    v6 = 0;
  }
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    __writegsdword(0xFFFFFFE8, 0x16u);
    return 0LL;
  }
  v7 = a5[13];
  v8 = *a1;
  for ( i = a1; (*(_BYTE *)(v7 + 2 * *i + 1) & 0x20) != 0; v8 = *i )
    ++i;
  if ( !v8 )
  {
    v10 = a1;
    goto LABEL_80;
  }
  if ( v8 == 45 )
  {
    v10 = i + 1;
    v48 = 1;
  }
  else
  {
    v48 = 0;
    v10 = &i[v8 == 43];
  }
  v11 = *v10;
  if ( *v10 == 48 )
  {
    if ( a3 == 16 || !a3 )
    {
      if ( *(_DWORD *)(a5[15] + 4 * v10[1]) == 88 )
      {
        v11 = v10[2];
        v12 = 14;
        v10 += 2;
        a3 = 16;
        goto LABEL_14;
      }
      if ( !a3 )
      {
        v12 = 6;
        a3 = 8;
        goto LABEL_14;
      }
    }
  }
  else if ( !a3 )
  {
    goto LABEL_40;
  }
  if ( a3 != 10 )
  {
    v12 = a3 - 2;
LABEL_14:
    v13 = 0;
    v41 = 0;
    goto LABEL_15;
  }
LABEL_40:
  if ( v40 )
  {
    v36 = *v10;
    v30 = strlen(v6);
    v11 = *v10;
    v13 = v30;
    v39 = v30;
    if ( v30 )
    {
      if ( v36 != *v6 )
      {
LABEL_101:
        v32 = *v10;
        v33 = v10;
        if ( v36 )
        {
          do
          {
            if ( (unsigned __int8)(v32 - 48) > 9u )
            {
              if ( *v33 == *v6 )
              {
                v34 = 0;
                while ( ++v34 != v39 )
                {
                  if ( v6[v34] != v33[v34] )
                    goto LABEL_109;
                }
              }
              else
              {
LABEL_109:
                if ( (*(_BYTE *)(v7 + 2 * v32 + 1) & 4) == 0 || *(int *)(a5[15] + 4 * v32) > 64 )
                  break;
              }
            }
            v32 = *++v33;
          }
          while ( *v33 );
        }
        v35 = _correctly_grouped_prefixmb((unsigned int)v10, (unsigned int)v33, v6, v40);
        v11 = *v10;
        v12 = 8;
        a3 = 10;
        v41 = (char *)v35;
        goto LABEL_15;
      }
      v31 = 0;
      while ( ++v31 != v39 )
      {
        if ( v6[v31] != v10[v31] )
          goto LABEL_101;
      }
    }
    v41 = v10;
    v12 = 8;
    a3 = 10;
  }
  else
  {
    v12 = 8;
    v13 = 0;
    a3 = 10;
    v41 = 0;
  }
LABEL_15:
  v14 = v11;
  v15 = v10;
  v47 = _strtol_ull_max_tab[2 * v12];
  v45 = dword_80DE204[2 * v12];
  v46 = (unsigned __int8)_strtol_ull_rem_tab[v12];
  v37 = _strtol_ul_max_tab[v12];
  if ( v14 && v41 != v10 )
  {
    v16 = 0;
    while ( 1 )
    {
      v17 = v14 - 48;
      if ( (unsigned __int8)(v14 - 48) > 9u )
      {
        if ( v13 && *v6 == *v15 )
        {
          v18 = 0;
          do
          {
            if ( ++v18 == v13 )
              goto LABEL_24;
          }
          while ( v6[v18] == v15[v18] );
          if ( v13 == v18 )
          {
LABEL_24:
            v19 = &v15[v13 - 1];
            goto LABEL_25;
          }
        }
        if ( (*(_BYTE *)(a5[13] + 2 * v14 + 1) & 4) == 0 )
        {
LABEL_27:
          v38 = v16;
          goto LABEL_28;
        }
        v17 = *(_DWORD *)(a5[15] + 4 * v14) - 55;
      }
      if ( v17 >= a3 )
        goto LABEL_27;
      if ( v37 <= v16 )
        break;
      v16 = v17 + a3 * v16;
      v19 = v15;
LABEL_25:
      v15 = v19 + 1;
      v14 = v19[1];
      if ( !v14 || v41 == v15 )
        goto LABEL_27;
    }
    v38 = v16;
    v22 = v13 - 1;
    v50 = v10;
    v23 = v13;
    v24 = v6;
    v25 = v15;
    v42 = 0;
    v49 = v22;
LABEL_59:
    v43 = a3 * HIDWORD(v38) + v38 * (a3 >> 31);
    v26 = (unsigned int)a3 * (unsigned __int64)(unsigned int)v38;
    v27 = a3 * v38;
    v38 = a3 * v38 + v17;
    v44 = v47 ^ (v26 + v17) | v45 ^ ((__PAIR64__(v43 + HIDWORD(v26), v27) + v17) >> 32);
    while ( 1 )
    {
      v28 = v15[1];
      ++v25;
      if ( !v28 )
      {
LABEL_84:
        v15 = v25;
        v10 = v50;
        goto LABEL_29;
      }
      if ( v25 == v41 )
        break;
      v17 = v28 - 48;
      if ( (unsigned __int8)(v28 - 48) > 9u )
      {
        if ( v23 )
        {
          v29 = 0;
          if ( *v24 == v28 )
          {
            do
            {
              if ( ++v29 == v23 )
                goto LABEL_68;
            }
            while ( v24[v29] == v15[v29 + 1] );
            if ( v23 == v29 )
            {
LABEL_68:
              v25 += v49;
              v15 = v25;
              continue;
            }
          }
          if ( (*(_BYTE *)(a5[13] + 2 * v28 + 1) & 4) == 0 )
            goto LABEL_84;
          v17 = *(_DWORD *)(a5[15] + 4 * v28) - 55;
        }
        else
        {
          if ( (*(_BYTE *)(a5[13] + 2 * v28 + 1) & 4) == 0 )
            goto LABEL_84;
          v17 = *(_DWORD *)(a5[15] + 4 * v28) - 55;
        }
      }
      if ( v17 >= a3 )
        goto LABEL_84;
      if ( __PAIR64__(v45, v47) >= v38 )
      {
        if ( v44 )
          goto LABEL_88;
        if ( v46 >= v17 )
        {
          v38 = __PAIR64__(v45, v47);
LABEL_88:
          v15 = v25;
          goto LABEL_59;
        }
      }
      v42 = 1;
      v15 = v25;
    }
    v15 = v25;
    goto LABEL_30;
  }
  v38 = 0LL;
LABEL_28:
  v42 = 0;
LABEL_29:
  if ( v10 != v15 )
  {
LABEL_30:
    if ( a2 )
      *a2 = v15;
    if ( v42 )
      goto LABEL_36;
    v20 = 0x7FFFFFFFFFFFFFFFLL;
    if ( v48 )
      v20 = 0x8000000000000000LL;
    if ( v38 > v20 )
    {
LABEL_36:
      __writegsdword(0xFFFFFFE8, 0x22u);
      result = 0x7FFFFFFFFFFFFFFFLL;
      if ( v48 )
        return 0x8000000000000000LL;
    }
    else
    {
      if ( v48 )
        return -(__int64)v38;
      return v38;
    }
    return result;
  }
LABEL_80:
  result = 0LL;
  if ( a2 )
  {
    if ( v10 - a1 > 1 && *(_DWORD *)(a5[15] + 4 * *(v10 - 1)) == 88 && *(v10 - 2) == 48 )
    {
      *a2 = v10 - 1;
    }
    else
    {
      result = 0LL;
      *a2 = a1;
    }
  }
  return result;
}
// 80C9480: using guessed type int _strtol_ul_max_tab[34];
// 80DE200: using guessed type int _strtol_ull_max_tab[];
// 80DE204: using guessed type int dword_80DE204[69];

//----- (080AF0E0) --------------------------------------------------------
unsigned __int64 __cdecl strtoll_l(char *a1, char **a2, int a3, _DWORD *a4)
{
  return ___strtoll_l_internal(a1, a2, a3, 0, a4);
}

//----- (080AF120) --------------------------------------------------------
__int64 __cdecl ___strtoull_l_internal(char *a1, char **a2, int a3, int a4, _DWORD *a5)
{
  int v5; // eax
  char *v6; // esi
  _BYTE *v7; // edi
  int v8; // ebx
  char v9; // al
  char *v10; // edx
  char v11; // cl
  int v12; // eax
  int v13; // ebp
  unsigned __int8 v14; // dl
  char *v15; // ebx
  unsigned int v16; // eax
  int v17; // ecx
  int v18; // ecx
  char *v19; // edx
  unsigned __int8 v21; // si
  char *v22; // ecx
  unsigned __int8 v23; // al
  char *v24; // esi
  unsigned __int8 v25; // bl
  unsigned __int64 v26; // rax
  unsigned int v27; // kr00_4
  unsigned __int8 v28; // dl
  int v29; // eax
  char *v30; // ecx
  int v31; // eax
  int v32; // eax
  unsigned __int8 v33; // al
  char *v34; // ecx
  int v35; // edx
  unsigned int v36; // eax
  char v37; // [esp+24h] [ebp-58h]
  unsigned int v38; // [esp+28h] [ebp-54h]
  unsigned __int64 v39; // [esp+28h] [ebp-54h]
  char *v40; // [esp+34h] [ebp-48h]
  int v41; // [esp+34h] [ebp-48h]
  char *v42; // [esp+38h] [ebp-44h]
  char *v43; // [esp+38h] [ebp-44h]
  int v44; // [esp+3Ch] [ebp-40h]
  int v45; // [esp+40h] [ebp-3Ch]
  int v46; // [esp+44h] [ebp-38h]
  int v47; // [esp+44h] [ebp-38h]
  unsigned int v48; // [esp+48h] [ebp-34h]
  int v49; // [esp+4Ch] [ebp-30h]
  int v50; // [esp+58h] [ebp-24h]

  v5 = a5[1];
  if ( !a4 || (v6 = *(char **)(v5 + 44), (unsigned __int8)(*v6 - 1) > 0x7Du) || (v7 = *(_BYTE **)(v5 + 40), !*v7) )
  {
    v6 = 0;
    v7 = 0;
  }
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    v39 = 0LL;
    __writegsdword(0xFFFFFFE8, 0x16u);
    return v39;
  }
  v8 = a5[13];
  v9 = *a1;
  v42 = a1;
  if ( (*(_BYTE *)(v8 + 2 * *a1 + 1) & 0x20) != 0 )
  {
    v10 = a1;
    do
      v9 = *++v10;
    while ( (*(_BYTE *)(v8 + 2 * *v10 + 1) & 0x20) != 0 );
    v42 = v10;
  }
  if ( !v9 )
  {
    v30 = a1;
    goto LABEL_75;
  }
  if ( v9 == 45 )
  {
    v43 = v42 + 1;
    v50 = 1;
  }
  else
  {
    v43 = &v42[v9 == 43];
    v50 = 0;
  }
  v11 = *v43;
  if ( *v43 == 48 )
  {
    if ( a3 == 16 || !a3 )
    {
      if ( *(_DWORD *)(a5[15] + 4 * v43[1]) == 88 )
      {
        v12 = 14;
        a3 = 16;
        v11 = v43[2];
        v43 += 2;
        goto LABEL_16;
      }
      if ( !a3 )
      {
        v12 = 6;
        a3 = 8;
        goto LABEL_16;
      }
    }
  }
  else if ( !a3 )
  {
    goto LABEL_39;
  }
  if ( a3 != 10 )
  {
    v12 = a3 - 2;
LABEL_16:
    v13 = 0;
    v40 = 0;
    goto LABEL_17;
  }
LABEL_39:
  if ( !v6 )
  {
    v12 = 8;
    v13 = 0;
    a3 = 10;
    v40 = 0;
    goto LABEL_17;
  }
  v37 = *v43;
  v31 = strlen(v7);
  v11 = *v43;
  v13 = v31;
  v41 = v31;
  if ( !v31 )
  {
LABEL_97:
    v12 = 8;
    a3 = 10;
    v40 = v43;
    goto LABEL_17;
  }
  v32 = 0;
  if ( v37 == *v7 )
  {
    while ( ++v32 != v41 )
    {
      if ( v7[v32] != v43[v32] )
        goto LABEL_98;
    }
    goto LABEL_97;
  }
LABEL_98:
  v33 = *v43;
  v34 = v43;
  if ( v37 )
  {
    do
    {
      if ( (unsigned __int8)(v33 - 48) > 9u )
      {
        if ( *v34 == *v7 )
        {
          v35 = 0;
          while ( ++v35 != v41 )
          {
            if ( v7[v35] != v34[v35] )
              goto LABEL_106;
          }
        }
        else
        {
LABEL_106:
          if ( (*(_BYTE *)(v8 + 2 * v33 + 1) & 4) == 0 || *(int *)(a5[15] + 4 * v33) > 64 )
            break;
        }
      }
      v33 = *++v34;
    }
    while ( *v34 );
  }
  v36 = _correctly_grouped_prefixmb((unsigned int)v43, (unsigned int)v34, v7, v6);
  a3 = 10;
  v11 = *v43;
  v40 = (char *)v36;
  v12 = 8;
LABEL_17:
  v14 = v11;
  v49 = _strtol_ull_max_tab[2 * v12];
  v45 = dword_80DE204[2 * v12];
  v48 = (unsigned __int8)_strtol_ull_rem_tab[v12];
  v38 = _strtol_ul_max_tab[v12];
  if ( !v11 || v40 == v43 )
  {
    v15 = v43;
    v39 = 0LL;
LABEL_30:
    v44 = 0;
LABEL_31:
    if ( v43 != v15 )
      goto LABEL_32;
    v30 = v43;
LABEL_75:
    v39 = 0LL;
    if ( a2 )
    {
      if ( v30 - a1 > 1 && *(_DWORD *)(a5[15] + 4 * *(v30 - 1)) == 88 && *(v30 - 2) == 48 )
      {
        *a2 = v30 - 1;
      }
      else
      {
        v39 = 0LL;
        *a2 = a1;
      }
    }
    return v39;
  }
  v15 = v43;
  v16 = 0;
  while ( 1 )
  {
    LOBYTE(v17) = v14 - 48;
    if ( (unsigned __int8)(v14 - 48) > 9u )
    {
      if ( v13 && *v7 == *v15 )
      {
        v18 = 0;
        do
        {
          if ( ++v18 == v13 )
            goto LABEL_26;
        }
        while ( v7[v18] == v15[v18] );
        if ( v13 == v18 )
        {
LABEL_26:
          v19 = &v15[v13 - 1];
          goto LABEL_27;
        }
      }
      if ( (*(_BYTE *)(a5[13] + 2 * v14 + 1) & 4) == 0 )
      {
LABEL_29:
        v39 = v16;
        goto LABEL_30;
      }
      v17 = *(_DWORD *)(a5[15] + 4 * v14) - 55;
    }
    if ( (unsigned __int8)v17 >= a3 )
      goto LABEL_29;
    if ( v38 <= v16 )
      break;
    v16 = (unsigned __int8)v17 + a3 * v16;
    v19 = v15;
LABEL_27:
    v15 = v19 + 1;
    v14 = v19[1];
    if ( !v14 || v40 == v15 )
      goto LABEL_29;
  }
  v39 = v16;
  v21 = v17;
  v22 = v15;
  v44 = 0;
  v23 = v21;
  v24 = v15;
  v25 = v23;
LABEL_54:
  v46 = a3 * HIDWORD(v39) + v39 * (a3 >> 31);
  v26 = (unsigned int)a3 * (unsigned __int64)(unsigned int)v39;
  v27 = a3 * v39;
  v39 = a3 * v39 + v25;
  v47 = v49 ^ (v26 + v25) | v45 ^ ((__PAIR64__(v46 + HIDWORD(v26), v27) + v25) >> 32);
  while ( 1 )
  {
    v28 = v22[1];
    ++v24;
    if ( !v28 )
    {
LABEL_79:
      v15 = v24;
      goto LABEL_31;
    }
    if ( v24 == v40 )
      break;
    v25 = v28 - 48;
    if ( (unsigned __int8)(v28 - 48) > 9u )
    {
      if ( v13 )
      {
        v29 = 0;
        if ( v28 == *v7 )
        {
          do
          {
            if ( ++v29 == v13 )
              goto LABEL_63;
          }
          while ( v7[v29] == v22[v29 + 1] );
          if ( v13 == v29 )
          {
LABEL_63:
            v24 += v13 - 1;
            v22 = v24;
            continue;
          }
        }
        if ( (*(_BYTE *)(a5[13] + 2 * v28 + 1) & 4) == 0 )
          goto LABEL_79;
        v25 = *(_DWORD *)(a5[15] + 4 * v28) - 55;
      }
      else
      {
        if ( (*(_BYTE *)(a5[13] + 2 * v28 + 1) & 4) == 0 )
          goto LABEL_79;
        v25 = *(_DWORD *)(a5[15] + 4 * v28) - 55;
      }
    }
    if ( v25 >= a3 )
      goto LABEL_79;
    if ( __PAIR64__(v45, v49) >= v39 )
    {
      if ( v47 )
        goto LABEL_83;
      if ( v48 >= v25 )
      {
        v39 = __PAIR64__(v45, v49);
LABEL_83:
        v22 = v24;
        goto LABEL_54;
      }
    }
    v44 = 1;
    v22 = v24;
  }
  v15 = v24;
LABEL_32:
  if ( a2 )
    *a2 = v15;
  if ( v44 )
  {
    v39 = -1LL;
    __writegsdword(0xFFFFFFE8, 0x22u);
  }
  else if ( v50 )
  {
    return -(__int64)v39;
  }
  return v39;
}
// 80C9480: using guessed type int _strtol_ul_max_tab[34];
// 80DE200: using guessed type int _strtol_ull_max_tab[];
// 80DE204: using guessed type int dword_80DE204[69];

//----- (080AF800) --------------------------------------------------------
__int64 __cdecl strtoull_l(char *a1, char **a2, int a3, _DWORD *a4)
{
  return ___strtoull_l_internal(a1, a2, a3, 0, a4);
}

//----- (080AF840) --------------------------------------------------------
void __cdecl _strtof_internal(_BYTE *a1, unsigned int *a2, int a3)
{
  ___strtof_l_internal(a1, a2, a3, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (080AF870) --------------------------------------------------------
void __cdecl strtof(_BYTE *a1, unsigned int *a2)
{
  ___strtof_l_internal(a1, a2, 0, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (080AF8A0) --------------------------------------------------------
void __cdecl _strtod_internal(_BYTE *a1, unsigned int *a2, int a3)
{
  ___strtod_l_internal(a1, a2, a3, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (080AF8D0) --------------------------------------------------------
void __cdecl strtod(_BYTE *a1, unsigned int *a2)
{
  ___strtod_l_internal(a1, a2, 0, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (080AF900) --------------------------------------------------------
void __cdecl _strtold_internal(_BYTE *a1, unsigned int *a2, int a3)
{
  ___strtold_l_internal(a1, a2, a3, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (080AF930) --------------------------------------------------------
void __cdecl strtold(_BYTE *a1, unsigned int *a2)
{
  ___strtold_l_internal(a1, a2, 0, (_DWORD *)__readgsdword(0xFFFFFFD8));
}

//----- (080AF960) --------------------------------------------------------
long double __usercall round_and_return@<st0>(
        unsigned int *a1@<eax>,
        unsigned int a2@<edx>,
        unsigned int a3@<ecx>,
        int a4,
        unsigned int a5,
        unsigned int a6,
        int a7)
{
  __int64 v8; // rax
  unsigned int v9; // ecx
  unsigned int v10; // ebx
  int v11; // esi
  float v12; // eax
  int v14; // edx
  bool v15; // zf
  unsigned int v16; // esi
  __int64 v17; // kr00_8
  int v18; // eax
  unsigned int v19; // [esp+18h] [ebp-24h]

  v8 = __PAIR64__(a3, a2);
  v9 = a6;
  v10 = a5;
  v11 = a7;
  if ( SHIDWORD(v8) <= -1 )
  {
    if ( SHIDWORD(v8) >= -1 )
    {
      if ( (unsigned int)v8 >= 0xFFFFFF82 )
        goto LABEL_14;
      if ( (unsigned int)v8 >= 0xFFFFFF6A )
      {
        v14 = -126 - v8;
        v10 = *a1;
        v11 = ((a5 & ((1 << a6) - 1)) != 0) | a7;
        if ( (_DWORD)v8 == -150 )
        {
          v9 = 23;
          v11 |= v10 != 0;
          *a1 = 0;
        }
        else
        {
          v19 = v14 - 1;
          _mpn_rshift((int)a1, a1, 1, v14);
          v9 = v19;
        }
        __writegsdword(0xFFFFFFE8, 0x22u);
        v8 = -127LL;
        goto LABEL_12;
      }
    }
    __writegsdword(0xFFFFFFE8, 0x22u);
    return 0.0;
  }
LABEL_14:
  if ( v8 > 128 )
  {
LABEL_3:
    v12 = INFINITY;
    if ( a4 )
      return -INFINITY;
    return v12;
  }
LABEL_12:
  if ( !_bittest((const int *)&v10, v9) )
    return _mpn_construct_float(a1, v8, a4);
  v15 = v11 == 0;
  v16 = *a1;
  if ( v15 && (v16 & 1) == 0 && (v10 & ((1 << v9) - 1)) == 0 )
    return _mpn_construct_float(a1, v8, a4);
  *a1 = v16 + 1;
  if ( ((v16 + 1) & 0x1000000) == 0 )
  {
    if ( !((unsigned int)v8 ^ 0xFFFFFF81 | ~HIDWORD(v8)) )
      LOBYTE(v8) = -(((v16 + 1) & 0x800000) == 0) - 126;
    return _mpn_construct_float(a1, v8, a4);
  }
  v17 = v8 + 1;
  _mpn_rshift((int)a1, a1, 1, 1);
  v18 = v17;
  LOBYTE(v18) = v17 ^ 0x81;
  *a1 |= 0x800000u;
  if ( !(HIDWORD(v17) | v18) )
    goto LABEL_3;
  LOBYTE(v8) = v17;
  return _mpn_construct_float(a1, v8, a4);
}
// 80AF9D6: conditional instruction was optimized away because edx.4==FFFFFFFF
// 80AFA78: conditional instruction was optimized away because edx.4==FFFFFFFF

//----- (080AFB70) --------------------------------------------------------
_BYTE *__usercall str_to_mpn_isra_0@<eax>(
        _BYTE *a1@<eax>,
        int a2@<edx>,
        unsigned int *a3@<ecx>,
        int *a4,
        __int64 *a5,
        int a6,
        _BYTE *a7)
{
  int v8; // edi
  int v9; // ebp
  char v10; // al
  bool v11; // zf
  int v12; // ecx
  unsigned int v13; // eax
  _BYTE *result; // eax
  char v15; // al
  int v16; // eax
  char v17; // dl
  int v18; // ecx
  int v19; // eax
  int v20; // edx
  int v21; // ebp
  unsigned int v22; // ecx
  unsigned int v23; // edi
  int v24; // eax
  int *v25; // edi
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // edx
  int v30; // esi
  unsigned int v31; // ecx
  unsigned int v32; // edi
  int v33; // eax
  int *v34; // edi
  int v35; // eax
  int v36; // eax
  int v37; // edx
  int v38; // [esp+10h] [ebp-2Ch]
  int v40; // [esp+18h] [ebp-24h]
  int v41; // [esp+1Ch] [ebp-20h]

  v38 = a2;
  *a4 = 0;
  if ( a2 <= 0 )
    _assert_fail("digcnt > 0", "strtod_l.c", 294, "str_to_mpn");
  v40 = 0;
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    v10 = *a1;
    if ( (unsigned __int8)(*a1 - 48) <= 9u )
      goto LABEL_7;
    if ( !a7 || v10 != *a7 )
    {
LABEL_6:
      a1 += a6;
      v10 = *a1;
      goto LABEL_7;
    }
    v15 = a7[1];
    if ( v15 )
    {
      if ( a1[1] != v15 )
        goto LABEL_6;
      v16 = 1;
      while ( 1 )
      {
        v17 = a7[++v16];
        v18 = v16;
        if ( !v17 )
          break;
        if ( a1[v16] != v17 )
          goto LABEL_6;
      }
    }
    else
    {
      v18 = 1;
    }
    a1 += v18;
    v10 = *a1;
LABEL_7:
    ++a1;
    v11 = v38-- == 1;
    v8 = v10 + 10 * v8 - 48;
    v12 = v9 + 1;
    if ( v11 )
      break;
    if ( v9 == 8 )
    {
      if ( v40 )
      {
        v19 = _mpn_mul_1((int)a3, (int)a3, v40, 0x3B9ACA00u);
        v20 = *a4;
        v21 = v19;
        v22 = *a3;
        v23 = *a3 + v8;
        *a3 = v23;
        v24 = 0;
        if ( v22 > v23 )
        {
          v25 = (int *)(a3 + 1);
          while ( --v20 )
          {
            v26 = *v25 + 1;
            *v25++ = v26;
            if ( v26 )
            {
              v24 = 0;
              goto LABEL_27;
            }
          }
          v24 = 1;
        }
LABEL_27:
        v27 = v21 + v24;
        if ( v27 )
        {
          if ( *a4 > 7 )
            _assert_fail("*nsize < ((((128 + 2 * 24) + ((32) - 1)) / (32)) + 2)", "strtod_l.c", 311, "str_to_mpn");
          v8 = 0;
          a3[*a4] = v27;
          v9 = 0;
          v40 = *a4 + 1;
          *a4 = v40;
        }
        else
        {
          v8 = 0;
          v9 = 0;
          v40 = *a4;
        }
      }
      else
      {
        v40 = 1;
        *a3 = v8;
        v8 = 0;
        *a4 = 1;
        v9 = 0;
      }
    }
    else
    {
      ++v9;
    }
  }
  v41 = *(_DWORD *)a5;
  if ( *a5 <= 0 || *a5 > 8 - v9 )
  {
    v13 = tens_in_limb[v12];
    if ( v40 )
      goto LABEL_31;
    goto LABEL_14;
  }
  v8 *= tens_in_limb[v41];
  v13 = tens_in_limb[v41 + v12];
  *(_DWORD *)a5 = 0;
  *((_DWORD *)a5 + 1) = 0;
  if ( !v40 )
  {
LABEL_14:
    *a3 = v8;
    *a4 = 1;
    return a1;
  }
LABEL_31:
  v28 = _mpn_mul_1((int)a3, (int)a3, v40, v13);
  v29 = *a4;
  v30 = v28;
  v31 = *a3;
  v32 = *a3 + v8;
  *a3 = v32;
  v33 = 0;
  if ( v31 > v32 )
  {
    v34 = (int *)(a3 + 1);
    while ( --v29 )
    {
      v35 = *v34 + 1;
      *v34++ = v35;
      if ( v35 )
      {
        v33 = 0;
        goto LABEL_36;
      }
    }
    v33 = 1;
  }
LABEL_36:
  v36 = v30 + v33;
  if ( !v36 )
    return a1;
  v37 = *a4;
  if ( *a4 > 7 )
    _assert_fail("*nsize < ((((128 + 2 * 24) + ((32) - 1)) / (32)) + 2)", "strtod_l.c", 367, "str_to_mpn");
  a3[v37] = v36;
  result = a1;
  *a4 = v37 + 1;
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80DE7E0: using guessed type int tens_in_limb[10];

//----- (080AFED0) --------------------------------------------------------
long double __cdecl ___strtof_l_internal(_BYTE *a1, unsigned int *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // eax
  _BYTE *v5; // ebp
  _BYTE *i; // eax
  char v7; // bl
  _BYTE *v8; // esi
  char v9; // dl
  int v10; // eax
  char v11; // cl
  int v12; // edi
  char v13; // al
  int v14; // edi
  _BYTE *v15; // eax
  int v16; // eax
  char v17; // cl
  _BYTE *k; // eax
  int v19; // eax
  char v20; // dl
  int v21; // eax
  int v22; // esi
  char v23; // dl
  _BYTE *m; // ebx
  int v25; // edi
  bool v26; // cf
  int v27; // esi
  int v28; // edi
  __int64 v29; // rcx
  __int64 v30; // rax
  unsigned int v31; // esi
  _BYTE *v32; // ebp
  unsigned int v33; // ebx
  char v34; // cl
  float v35; // edx
  _BYTE *v36; // eax
  long double result; // fst7
  char v38; // al
  unsigned int v39; // eax
  long double v40; // fst6
  _BYTE *v41; // eax
  unsigned int v42; // edx
  char v43; // si
  _BYTE *v44; // eax
  char v45; // bl
  int v46; // edx
  char v47; // cl
  unsigned __int64 v48; // rcx
  __int64 v49; // rcx
  signed __int64 v50; // rax
  __int64 v51; // rcx
  long double v52; // fst6
  unsigned int v53; // eax
  _BYTE *v54; // edx
  unsigned int v55; // ecx
  unsigned int *v56; // edx
  int v57; // edi
  _DWORD *v58; // esi
  int v59; // ebx
  int v60; // ebp
  int v61; // eax
  unsigned int v62; // ebx
  signed int v63; // ebx
  int v64; // eax
  unsigned int v65; // ebp
  unsigned int v66; // ebx
  int v67; // eax
  int v68; // ecx
  int v69; // esi
  int jj; // eax
  unsigned int v71; // ecx
  unsigned int v72; // esi
  unsigned __int64 v73; // rtt
  unsigned int v74; // ecx
  unsigned __int64 ii; // rax
  unsigned int *v76; // eax
  unsigned int v77; // edi
  signed int v78; // edi
  int v79; // eax
  unsigned int v80; // ebx
  char v81; // al
  int v82; // esi
  int v83; // edx
  char *v84; // ecx
  char *v85; // edx
  int v86; // eax
  char *v87; // ebp
  __int64 v88; // rcx
  _BYTE *v89; // ebx
  _BYTE *v90; // esi
  _BYTE *v91; // ebp
  _BYTE *v92; // eax
  unsigned int v93; // esi
  unsigned int v94; // edi
  __int64 v96; // rcx
  int v97; // edx
  unsigned int v98; // edi
  unsigned int v99; // esi
  unsigned int v100; // edx
  unsigned int v101; // esi
  int v102; // eax
  char v103; // cl
  int v104; // ecx
  unsigned int v105; // ebx
  char *v106; // eax
  int v107; // ecx
  int v108; // ebp
  _DWORD *v109; // edi
  int v110; // esi
  int v111; // ebx
  int v112; // eax
  int *v113; // edx
  int v114; // edx
  int v115; // edx
  unsigned int v116; // esi
  int n; // ecx
  unsigned int v118; // eax
  unsigned int v119; // edx
  unsigned __int64 v120; // rtt
  unsigned int v121; // edi
  signed int v122; // edi
  unsigned int v123; // ebx
  int v124; // ebp
  unsigned int v125; // edx
  unsigned int v126; // ecx
  unsigned int v127; // eax
  unsigned int v128; // ebp
  int v129; // esi
  unsigned int v130; // edi
  int v131; // ecx
  unsigned int v132; // ebp
  unsigned int v133; // edi
  unsigned __int64 v134; // rax
  unsigned int v135; // ecx
  signed int v136; // ecx
  _BOOL4 v137; // eax
  unsigned int v138; // eax
  int v139; // eax
  int v140; // ebp
  int v141; // ebx
  int kk; // eax
  int v143; // eax
  int v144; // eax
  signed int v145; // edx
  int v146; // ecx
  bool v147; // cc
  int v148; // eax
  unsigned int *v149; // eax
  char v150; // cl
  unsigned int v151; // ebx
  _BYTE *j; // ebx
  char v153; // al
  __int64 v154; // rax
  int v155; // edi
  _BYTE *v156; // eax
  int v157; // ebx
  int v158; // eax
  int v159; // ebx
  int v160; // eax
  int v161; // eax
  int v162; // edx
  long double v163; // fst6
  int v164; // eax
  char v165; // cl
  int v166; // eax
  int v167; // ecx
  int v168; // ecx
  int v169; // [esp+Ch] [ebp-110h]
  unsigned int *v170; // [esp+20h] [ebp-FCh]
  unsigned int *v171; // [esp+20h] [ebp-FCh]
  int v172; // [esp+20h] [ebp-FCh]
  unsigned int v173; // [esp+38h] [ebp-E4h]
  unsigned int v174; // [esp+38h] [ebp-E4h]
  unsigned int *v175; // [esp+38h] [ebp-E4h]
  __int64 v176; // [esp+38h] [ebp-E4h]
  unsigned __int64 v177; // [esp+38h] [ebp-E4h]
  __int64 v178; // [esp+38h] [ebp-E4h]
  int v179; // [esp+38h] [ebp-E4h]
  char v180; // [esp+38h] [ebp-E4h]
  _BYTE *v181; // [esp+40h] [ebp-DCh]
  _BYTE *v182; // [esp+40h] [ebp-DCh]
  signed int v183; // [esp+40h] [ebp-DCh]
  int v184; // [esp+40h] [ebp-DCh]
  __int64 v185; // [esp+40h] [ebp-DCh]
  char *v186; // [esp+48h] [ebp-D4h]
  _BYTE *v187; // [esp+48h] [ebp-D4h]
  _BYTE *v188; // [esp+48h] [ebp-D4h]
  __int64 v189; // [esp+48h] [ebp-D4h]
  unsigned int v190; // [esp+48h] [ebp-D4h]
  int v191; // [esp+54h] [ebp-C8h]
  int v192; // [esp+54h] [ebp-C8h]
  int v193; // [esp+54h] [ebp-C8h]
  _BYTE *v194; // [esp+58h] [ebp-C4h]
  __int64 v195; // [esp+58h] [ebp-C4h]
  signed int v196; // [esp+58h] [ebp-C4h]
  int v197; // [esp+58h] [ebp-C4h]
  unsigned int v198; // [esp+58h] [ebp-C4h]
  int v199; // [esp+60h] [ebp-BCh]
  unsigned int *v200; // [esp+60h] [ebp-BCh]
  int v201; // [esp+60h] [ebp-BCh]
  unsigned int *v202; // [esp+60h] [ebp-BCh]
  int v203; // [esp+64h] [ebp-B8h]
  unsigned int v204; // [esp+64h] [ebp-B8h]
  int v205; // [esp+68h] [ebp-B4h]
  char v206; // [esp+68h] [ebp-B4h]
  __int64 v207; // [esp+68h] [ebp-B4h]
  char *v208; // [esp+68h] [ebp-B4h]
  int *v209; // [esp+70h] [ebp-ACh]
  int v210; // [esp+74h] [ebp-A8h]
  int v211; // [esp+74h] [ebp-A8h]
  char *v212; // [esp+78h] [ebp-A4h]
  unsigned int v213; // [esp+78h] [ebp-A4h]
  int v214; // [esp+7Ch] [ebp-A0h]
  int v215; // [esp+7Ch] [ebp-A0h]
  int v216; // [esp+80h] [ebp-9Ch]
  bool v217; // [esp+87h] [ebp-95h]
  int v218; // [esp+90h] [ebp-8Ch]
  _BYTE *v219; // [esp+94h] [ebp-88h]
  unsigned int v220[8]; // [esp+A8h] [ebp-74h] BYREF
  unsigned int v221; // [esp+C8h] [ebp-54h] BYREF
  unsigned int v222; // [esp+CCh] [ebp-50h]
  __int64 v223; // [esp+E8h] [ebp-34h] BYREF
  int v224; // [esp+F4h] [ebp-28h] BYREF
  unsigned int v225; // [esp+F8h] [ebp-24h] BYREF
  char *v226; // [esp+FCh] [ebp-20h] BYREF
  unsigned int v227; // [esp+120h] [ebp+4h]

  v4 = (_DWORD *)a4[1];
  if ( !a3 || (v186 = (char *)v4[11], (unsigned __int8)(*v186 - 1) > 0x7Du) || (v212 = (char *)v4[10], !*v212) )
  {
    v186 = 0;
    v212 = 0;
  }
  v5 = (_BYTE *)v4[9];
  v210 = strlen(v5);
  if ( !v210 )
    _assert_fail("decimal_len > 0", "strtod_l.c", 514, "____strtof_l_internal");
  v223 = 0LL;
  for ( i = a1 - 1; ; ++i )
  {
    v7 = i[1];
    v8 = i + 1;
    if ( (*(_BYTE *)(a4[13] + 2 * v7 + 1) & 0x20) == 0 )
      break;
  }
  if ( v7 == 45 )
  {
    v8 = i + 2;
    v7 = i[2];
    v216 = 1;
  }
  else
  {
    v216 = 0;
    if ( v7 == 43 )
    {
      v8 = i + 2;
      v7 = i[2];
    }
  }
  v9 = *v5;
  if ( !*v5 )
  {
    v12 = 0;
    goto LABEL_15;
  }
  v10 = 0;
  if ( v9 == *v8 )
  {
    while ( 1 )
    {
      v11 = v5[++v10];
      v12 = v10;
      if ( !v11 )
        break;
      if ( v11 != v8[v10] )
        goto LABEL_73;
    }
LABEL_15:
    v13 = v8[v12];
    if ( v13 > 47 && v13 <= 57 )
      goto LABEL_17;
  }
LABEL_73:
  if ( (unsigned __int8)(v7 - 48) > 9u )
  {
    v38 = dword_80CFDC0[v7];
    if ( v38 == 105 )
    {
      if ( !strncasecmp_l(v8, &unk_80C9C94, 3, nl_C_locobj) )
      {
        if ( a2 )
        {
          v89 = v8 + 3;
          v90 = v8 + 8;
          if ( !strncasecmp_l(v89, "inity", 5, nl_C_locobj) )
            v89 = v90;
          *a2 = (unsigned int)v89;
        }
        goto LABEL_139;
      }
    }
    else if ( v38 == 110 && !strncasecmp_l(v8, &unk_80C9C98, 3, nl_C_locobj) )
    {
      v91 = v8 + 3;
      result = NAN;
      if ( v8[3] == 40 )
      {
        for ( j = v8 + 3; ; ++j )
        {
          v153 = j[1];
          if ( (unsigned __int8)(v153 - 48) > 9u
            && (unsigned __int8)(*(_BYTE *)(a4[14] + 4 * v153) - 97) > 0x19u
            && v153 != 95 )
          {
            break;
          }
        }
        result = NAN;
        if ( v153 == 41 )
        {
          v154 = ___strtoull_l_internal(v8 + 4, &v226, 0, 0, a4);
          result = (float)NAN;
          if ( v226 == j + 1 )
          {
            v161 = v154 & 0x7FFFFF;
            v162 = 0x400000;
            if ( v161 )
              v162 = v161;
            result = COERCE_FLOAT(v162 | 0x7F800000);
          }
          v91 = j + 2;
        }
      }
      if ( a2 )
        *a2 = (unsigned int)v91;
      return result;
    }
    result = 0.0;
    if ( a2 )
      *a2 = (unsigned int)a1;
    return result;
  }
LABEL_17:
  if ( v7 == 48 )
  {
    v191 = 10;
    v14 = a4[14];
    if ( *(_DWORD *)(v14 + 4 * (char)v8[1]) == 120 )
    {
      v7 = v8[2];
      v8 += 2;
      v186 = 0;
      v191 = 16;
    }
  }
  else
  {
    v191 = 10;
    v14 = a4[14];
  }
  if ( v212 )
  {
    v194 = v8;
    v180 = *v212;
    while ( 1 )
    {
      if ( v7 != 48 )
      {
        if ( v180 )
        {
          if ( *v194 != v180 )
            goto LABEL_24;
          v164 = 0;
          while ( 1 )
          {
            v165 = v212[++v164];
            if ( !v165 )
              break;
            if ( v165 != v194[v164] )
              goto LABEL_24;
          }
          v166 = v164 - 1;
        }
        else
        {
          v166 = -1;
        }
        v194 += v166;
      }
      v7 = *++v194;
    }
  }
  v194 = v8;
  if ( v7 == 48 )
  {
    v15 = v8;
    do
      v7 = *++v15;
    while ( *v15 == 48 );
    v194 = v15;
  }
LABEL_24:
  v173 = 0;
  v181 = v194;
  v205 = *(_DWORD *)(v14 + 4 * v7);
  if ( (unsigned __int8)(v7 - 48) <= 9u || (char)v205 > 96 && v191 == 16 && (char)v205 <= 102 )
    goto LABEL_34;
  if ( !v9 )
  {
LABEL_31:
    if ( v8 != v194 || v191 != 16 )
    {
      v173 = 0;
      k = v194;
      goto LABEL_35;
    }
    v173 = 0;
    v181 = v194;
    if ( (unsigned __int8)(v194[v210] - 48) <= 9u
      || (unsigned __int8)(*(_BYTE *)(v14 + 4 * (char)v194[v210]) - 97) <= 5u )
    {
      goto LABEL_34;
    }
    goto LABEL_90;
  }
  if ( *v194 == v9 )
  {
    v16 = 0;
    do
    {
      v17 = v5[++v16];
      if ( !v17 )
        goto LABEL_31;
    }
    while ( v17 == v194[v16] );
  }
  if ( v191 != 16 || v8 == v194 || (v173 = 0, v181 = v194, (_BYTE)v205 != 112) )
  {
LABEL_90:
    if ( (_BYTE)v205 != 101 || (v173 = 0, v181 = v194, v191 == 16) )
    {
      v39 = _correctly_grouped_prefixmb((unsigned int)v8, (unsigned int)v194, v212, v186);
      if ( a2 )
      {
        if ( v8 == (_BYTE *)v39 )
        {
          v156 = v194 - 1;
          if ( v191 != 16 )
            v156 = a1;
          v227 = (unsigned int)v156;
        }
        else
        {
          v227 = v39;
        }
        *a2 = v227;
      }
      goto LABEL_96;
    }
  }
LABEL_34:
  for ( k = v181; ; ++k )
  {
LABEL_35:
    if ( (unsigned __int8)(v7 - 48) <= 9u || v191 == 16 && (unsigned __int8)(*(_BYTE *)(v14 + 4 * v7) - 97) <= 5u )
    {
      ++v173;
      goto LABEL_81;
    }
    if ( !v212 )
      goto LABEL_38;
    if ( *v212 )
      break;
    v168 = -1;
LABEL_475:
    k += v168;
LABEL_81:
    v7 = k[1];
  }
  if ( *v212 == *k )
  {
    v167 = 0;
    while ( v212[++v167] )
    {
      if ( v212[v167] != k[v167] )
        goto LABEL_38;
    }
    v168 = v167 - 1;
    goto LABEL_475;
  }
LABEL_38:
  v182 = k;
  if ( v8 >= k || !v186 )
  {
LABEL_39:
    v214 = -(v173 == 0);
    if ( v9 )
    {
      v19 = 0;
      if ( *v182 != v9 )
      {
        v150 = *(_BYTE *)(v14 + 4 * v7);
        v204 = v173;
        goto LABEL_143;
      }
      while ( 1 )
      {
        v20 = v5[++v19];
        if ( !v20 )
          break;
        if ( v20 != v182[v19] )
        {
          v150 = *(_BYTE *)(v14 + 4 * v7);
          v204 = v173;
          goto LABEL_143;
        }
      }
    }
    v21 = 0;
    v22 = -(v173 == 0);
    v23 = v182[v210];
    for ( m = &v182[v210]; ; v23 = *m )
    {
      if ( (unsigned __int8)(v23 - 48) > 9u )
      {
        if ( v191 != 16 )
        {
          v204 = v21 + v173;
          v214 = v22;
          v182 = m;
          v150 = *(_BYTE *)(v14 + 4 * v23);
          v187 = m;
          v217 = 0;
          goto LABEL_53;
        }
        if ( (unsigned __int8)(*(_BYTE *)(v14 + 4 * v23) - 97) > 5u )
          break;
      }
      if ( v22 == -1 && v23 != 48 )
        v22 = v21;
      ++m;
      ++v21;
    }
    v204 = v21 + v173;
    v214 = v22;
    v150 = *(_BYTE *)(v14 + 4 * v23);
    v182 = m;
LABEL_143:
    v217 = v191 == 16;
    if ( v150 == 112 && v191 == 16 )
    {
      v217 = 1;
    }
    else
    {
      v187 = v182;
LABEL_53:
      if ( v150 != 101 || v191 == 16 )
        goto LABEL_105;
    }
    v206 = v182[1];
    if ( v206 == 45 )
    {
      v218 = 1;
      v188 = v182 + 2;
      v206 = v182[2];
    }
    else
    {
      v218 = 0;
      if ( v206 == 43 )
      {
        v188 = v182 + 2;
        v206 = v182[2];
      }
      else
      {
        v188 = v182 + 1;
      }
    }
    if ( (unsigned __int8)(v206 - 48) > 9u )
    {
      v187 = v182;
LABEL_105:
      v41 = v182;
      if ( v204 > v173 )
      {
        if ( *(v182 - 1) == 48 )
        {
          v42 = v204;
          do
          {
            --v41;
            --v42;
          }
          while ( *(v41 - 1) == 48 );
          v204 = v42;
        }
        if ( v204 < v173 )
          _assert_fail("dig_no >= int_no", "strtod_l.c", 967, "____strtof_l_internal");
      }
      if ( v204 && v204 == v173 && v223 < 0 )
      {
        v92 = v41 - 1;
        v93 = v204;
        v94 = v173;
        while ( 1 )
        {
          if ( !(v217 ? (*(_BYTE *)(a4[13] + 2 * (char)*v92 + 1) & 0x10) == 0 : (unsigned int)((char)*v92 - 48) > 9) )
          {
            if ( *v92 != 48 )
              break;
            --v93;
            --v94;
            v96 = 4LL;
            if ( !v217 )
              v96 = 1LL;
            v223 += v96;
            if ( v223 >= 0 || !v93 )
              break;
          }
          --v92;
        }
        v204 = v93;
        v173 = v94;
      }
      goto LABEL_114;
    }
    if ( v217 )
    {
      if ( v218 )
      {
        v25 = (unsigned __int64)v173 >> 30;
        v26 = __CFADD__(4 * v173, 149);
        v27 = 4 * v173 + 149;
        goto LABEL_62;
      }
      if ( v173 )
      {
        if ( v214 )
          _assert_fail(
            "lead_zero == 0 && int_no <= (uintmax_t) (9223372036854775807LL) / 4",
            "strtod_l.c",
            860,
            "____strtof_l_internal");
        v28 = (4 * (32 - (unsigned __int64)v173) + 3) >> 32;
        v27 = 4 * (32 - v173) + 3;
      }
      else
      {
        v28 = 0;
        v29 = 13LL;
        v27 = 131;
        if ( v214 == -1 )
          goto LABEL_64;
        v28 = (4 * (unsigned __int64)(unsigned int)v214 + 131) >> 32;
        v27 = 4 * v214 + 131;
      }
    }
    else
    {
      if ( v218 )
      {
        v25 = 0;
        v26 = __CFADD__(v173, 61);
        v27 = v173 + 61;
LABEL_62:
        v28 = v26 + v25;
LABEL_63:
        v29 = __SPAIR64__(v28, v27) / 10;
        goto LABEL_64;
      }
      if ( v173 )
      {
        if ( v214 )
          _assert_fail(
            "lead_zero == 0 && int_no <= (uintmax_t) (9223372036854775807LL)",
            "strtod_l.c",
            892,
            "____strtof_l_internal");
        v28 = (39 - (unsigned __int64)v173) >> 32;
        v27 = 39 - v173;
      }
      else
      {
        v28 = 0;
        v29 = 3LL;
        v27 = 39;
        if ( v214 == -1 )
          goto LABEL_64;
        v28 = ((unsigned __int64)(unsigned int)v214 + 39) >> 32;
        v27 = v214 + 39;
      }
    }
    if ( v28 >= 0 )
      goto LABEL_63;
    v29 = 0LL;
    v27 = 0;
    v28 = 0;
LABEL_64:
    v30 = __SPAIR64__(v28, v27) % 10;
    v219 = v5;
    v31 = HIDWORD(v223);
    v32 = v188;
    v189 = v29;
    v33 = v223;
    v34 = v206;
    do
    {
      if ( v189 < __SPAIR64__(v31, v33) )
      {
LABEL_66:
        if ( v214 == -1 )
        {
          v35 = 0.0;
          v36 = v32;
          if ( v216 )
            v35 = -0.0;
        }
        else
        {
          __writegsdword(0xFFFFFFE8, 0x22u);
          if ( v218 )
          {
            v35 = 0.0;
            v36 = v32;
            if ( v216 )
              v35 = -0.0;
          }
          else
          {
            v35 = INFINITY;
            v36 = v32;
            if ( v216 )
              v35 = -INFINITY;
          }
        }
        do
          ++v36;
        while ( (unsigned __int8)(*v36 - 48) <= 9u );
        result = v35;
        if ( a2 )
          *a2 = (unsigned int)v36;
        return result;
      }
      if ( v189 == __PAIR64__(v31, v33) )
      {
        v207 = v34 - 48;
        if ( v207 > v30 )
          goto LABEL_66;
      }
      else
      {
        v207 = v34 - 48;
      }
      v31 = (v207 + __PAIR64__(10 * v31 + ((10 * (unsigned __int64)v33) >> 32), 10 * v33)) >> 32;
      v33 = v207 + 10 * v33;
      ++v32;
      v223 = __PAIR64__(v31, v33);
      v34 = *v32;
    }
    while ( (unsigned __int8)(*v32 - 48) <= 9u );
    v187 = v32;
    v5 = v219;
    if ( v218 )
      v223 = -__SPAIR64__(v31, v33);
    goto LABEL_105;
  }
  v53 = _correctly_grouped_prefixmb((unsigned int)v8, (unsigned int)k, v212, v186);
  if ( (_BYTE *)v53 == v182 )
  {
    v9 = *v5;
    v14 = a4[14];
    goto LABEL_39;
  }
  if ( v8 == (_BYTE *)v53 )
  {
    result = 0.0;
    if ( a2 )
      *a2 = (unsigned int)a1;
    return result;
  }
  if ( (unsigned int)v194 > v53 )
  {
    if ( a2 )
      *a2 = v53;
    goto LABEL_96;
  }
  v54 = v194;
  v204 = 0;
  if ( (unsigned int)v194 >= v53 )
  {
    v187 = (_BYTE *)v53;
    v214 = 0;
    v173 = 0;
  }
  else
  {
    v55 = 0;
    do
      v55 += (unsigned __int8)(*v54++ - 48) < 0xAu;
    while ( v54 != (_BYTE *)v53 );
    v204 = v55;
    v173 = v55;
    v187 = v54;
    v214 = 0;
  }
LABEL_114:
  if ( a2 )
    *a2 = (unsigned int)v187;
  if ( !v204 )
    goto LABEL_96;
  v208 = v194;
  if ( !v214 )
    goto LABEL_133;
  v43 = v5[1];
  v44 = v194;
  v45 = *v194;
  while ( 2 )
  {
    if ( *v5 != v45 )
    {
      v45 = v44[1];
LABEL_120:
      ++v44;
      continue;
    }
    break;
  }
  if ( !v43 )
    goto LABEL_127;
  v45 = v44[1];
  v46 = 1;
  if ( v45 != v43 )
    goto LABEL_120;
  while ( 1 )
  {
    v47 = v5[++v46];
    if ( !v47 )
      break;
    if ( v47 != v44[v46] )
      goto LABEL_120;
  }
LABEL_127:
  v48 = v223 + 0x8000000000000000LL;
  if ( v191 == 16 )
    v48 >>= 2;
  if ( v48 < (unsigned int)v214 )
    _assert_fail(
      "lead_zero <= (base == 16 ? ((uintmax_t) exponent - (uintmax_t) (-9223372036854775807LL-1)) / 4 : ((uintmax_t) expo"
      "nent - (uintmax_t) (-9223372036854775807LL-1)))",
      "strtod_l.c",
      1022,
      "____strtof_l_internal");
  v49 = (unsigned int)v214;
  if ( v191 == 16 )
    v49 = 4LL * (unsigned int)v214;
  v204 -= v214;
  v208 = &v44[v210 + v214];
  v223 -= v49;
LABEL_133:
  if ( v191 != 16 )
  {
    if ( v223 < 0 )
    {
      v50 = -(__int64)v173;
      if ( v50 < v223 )
        goto LABEL_136;
    }
    else
    {
      v50 = v204 - (unsigned __int64)v173;
      if ( v50 > v223 )
LABEL_136:
        v50 = v223;
    }
    v51 = v223 - v50;
    v195 = (unsigned int)v50 + v173;
    v174 = v195;
    v223 = v51;
    if ( v51 > 39 - v195 )
    {
      __writegsdword(0xFFFFFFE8, 0x22u);
LABEL_139:
      v52 = -INFINITY;
      if ( !v216 )
        return INFINITY;
      return v52;
    }
    if ( v51 < -44 )
    {
      __writegsdword(0xFFFFFFE8, 0x22u);
LABEL_96:
      v40 = -0.0;
      if ( !v216 )
        return 0.0;
      return v40;
    }
    v183 = 0;
    if ( !(_DWORD)v195 )
    {
LABEL_148:
      if ( v204 <= (unsigned int)v195 || v223 > 0 )
        _assert_fail("dig_no > int_no && exponent <= 0", "strtod_l.c", 1292, "____strtof_l_internal");
      if ( v204 > v195 + (26 - v183) / 3 + 2 )
      {
        v215 = 1;
        v204 = v195 + (26 - v183) / 3 + 2;
      }
      else
      {
        v215 = 0;
      }
      v56 = &v221;
      v57 = v204 - v195 - v223;
      v58 = &fpioconst_pow10;
      v175 = v220;
      v59 = 1;
      v60 = 0;
      v203 = v204 - v195;
      while ( 1 )
      {
        if ( (v59 & v57) == 0 )
          goto LABEL_164;
        v57 ^= v59;
        if ( v60 )
        {
          v171 = v56;
          v61 = _mpn_mul(v175, &dword_80DB7A8[*v58], v58[1] - 2, v56, v60);
          v60 = v60 + v58[1] - 2;
          if ( v61 )
          {
            v56 = v175;
            v175 = v171;
            goto LABEL_164;
          }
          --v60;
          v56 = v175;
          v59 *= 2;
          v58 += 4;
          v175 = v171;
          if ( !v57 )
          {
LABEL_169:
            v196 = v60;
            if ( v56 == v220 )
              memcpy(&v221, v220, 4 * v60);
            str_to_mpn_isra_0(v208, v203, v220, &v224, &v223, v210, v212);
            v199 = v60 - 1;
            _BitScanReverse(&v62, *(&v221 + v60 - 1));
            v63 = v62 ^ 0x1F;
            if ( v63 > 0 )
            {
              _mpn_lshift(&v221, (int)&v221, v60, v63);
              v64 = _mpn_lshift(v220, (int)v220, v224, v63);
              if ( v64 )
              {
                v97 = v224;
                v220[v224] = v64;
                v224 = v97 + 1;
              }
            }
            v223 = v183;
            if ( v60 == 1 )
            {
              if ( v220[0] >= v221 || v224 != 1 )
                _assert_fail("numsize == 1 && n < d", "strtod_l.c", 1395, "____strtof_l_internal");
              v116 = v220[0];
              for ( n = v183; ; n += 32 )
              {
                while ( 1 )
                {
                  LODWORD(v120) = 0;
                  HIDWORD(v120) = v116;
                  v118 = v120 / v221;
                  v119 = v120 % v221;
                  v116 = v119;
                  if ( n )
                    break;
                  if ( v118 )
                  {
                    _BitScanReverse(&v121, v118);
                    v122 = v121 ^ 0x1F;
                    v178 = v223 - v122;
                    v223 = v178;
                    n = 32 - v122;
                    if ( 32 - v122 > 24 )
                    {
                      v123 = v118;
                      v225 = v118 >> (8 - v122);
                      v124 = v122 + 24;
                      goto LABEL_310;
                    }
                  }
                  else
                  {
                    v223 -= 32LL;
                  }
                  v225 = v118;
                  if ( n > 24 )
                  {
                    v123 = v118;
                    v116 = v119;
                    v124 = 0;
                    goto LABEL_317;
                  }
                }
                if ( n >= -7 )
                {
                  v123 = v118;
                  v124 = 24 - n;
                  v116 = v119;
                  if ( 24 - n > 0 )
                  {
                    _mpn_lshift(&v225, (int)&v225, 1, 24 - n);
                    v225 |= v123 >> (32 - v124);
                  }
LABEL_317:
                  v178 = v223;
LABEL_310:
                  v126 = (unsigned __int64)(v178 - 1) >> 32;
                  v125 = v178 - 1;
                  v169 = v215 | (v116 != 0);
                  v127 = 31 - v124;
                  return round_and_return(&v225, v125, v126, v216, v123, v127, v169);
                }
                v225 = v118;
              }
            }
            if ( v60 != 2 )
            {
              v65 = *(&v221 + v199);
              v66 = *(&v221 + v196 - 2);
              v67 = _mpn_cmp((int)v220, (int)(&v221 + v196 - v224), v224);
              v68 = v224;
              if ( v67 > 0 )
              {
                v68 = v224 + 1;
                v220[v224] = 0;
                v224 = v68;
              }
              if ( v68 >= v196 )
              {
                if ( v68 != v196 )
                  _assert_fail("numsize == densize", "strtod_l.c", 1606, "____strtof_l_internal");
                v149 = &v220[v196];
                if ( v196 > 0 )
                {
                  do
                  {
                    *v149 = *(v149 - 1);
                    --v149;
                  }
                  while ( v149 != v220 );
                }
                v220[0] = 0;
                v211 = 0;
                *(&v221 + v196) = 0;
                v71 = v220[v196];
                while ( 1 )
                {
                  while ( 1 )
                  {
LABEL_190:
                    v72 = -1;
                    if ( v71 != v65 )
                    {
                      LODWORD(v73) = v220[v199];
                      HIDWORD(v73) = v71;
                      v72 = v73 / v65;
                      v74 = v73 % v65;
                      for ( ii = v72 * (unsigned __int64)v66; ii > __PAIR64__(v74, v220[v196 - 2]); ii -= v66 )
                      {
                        --v72;
                        v26 = __CFADD__(v65, v74);
                        v74 += v65;
                        if ( v26 )
                          break;
                      }
                    }
                    if ( v220[v196] != _mpn_submul_1((int)v220, (int)&v221, v196 + 1, v72) )
                    {
                      if ( !_mpn_add_n(v220, v220, &v221, v196) )
                        _assert_fail("cy != 0", "strtod_l.c", 1648, "____strtof_l_internal");
                      --v72;
                    }
                    v71 = v220[v199];
                    v220[v196] = v71;
                    if ( v199 > 0 )
                    {
                      v76 = &v220[v199];
                      do
                      {
                        *v76 = *(v76 - 1);
                        --v76;
                      }
                      while ( v76 != v220 );
                    }
                    v220[0] = 0;
                    if ( v183 )
                      break;
                    if ( v72 )
                    {
                      _BitScanReverse(&v77, v72);
                      v78 = v77 ^ 0x1F;
                      v176 = v223 - v78;
                      v223 = v176;
                      if ( 32 - v78 > 24 )
                      {
                        v211 = v78 + 24;
                        v225 = v72 >> (8 - v78);
                        v71 = v220[v196];
                        goto LABEL_205;
                      }
                      v183 = 32 - v78;
                    }
                    else
                    {
                      v223 -= 32LL;
                    }
                    v225 = v72;
                    if ( v183 > 24 )
                      goto LABEL_276;
                  }
                  if ( v183 >= -7 )
                    break;
                  v225 = v72;
                  v183 += 32;
                }
                v211 = 24 - v183;
                if ( v183 != 24 )
                {
                  _mpn_lshift(&v225, (int)&v225, 1, 24 - v183);
                  v225 |= v72 >> (32 - v211);
                }
LABEL_276:
                v176 = v223;
                v71 = v220[v196];
              }
              else
              {
                v69 = v196 - v68;
                if ( v183 <= 0 )
                {
                  v223 -= 32 * v69;
                  v211 = 0;
                }
                else
                {
                  if ( v183 + 32 * v69 > 24 )
                  {
                    v211 = 24 - v183;
                    if ( v183 != 24 )
                    {
                      _mpn_lshift(&v225, (int)&v225, 1, 24 - v183);
                      v68 = v224;
                    }
                  }
                  else
                  {
                    if ( v69 != 1 )
                      _assert_fail("empty == 1", "strtod_l.c", 1569, "____strtof_l_internal");
                    v225 = 0;
                    v211 = 0;
                  }
                  v183 += 32 * v69;
                }
                if ( v68 > 0 )
                {
                  do
                  {
                    v220[v69 + v68] = v220[v68 - 1];
                    --v68;
                  }
                  while ( v68 );
                }
                if ( v69 >= 0 )
                {
                  for ( jj = 0; jj <= v69; ++jj )
                    v220[jj] = 0;
                }
                *(&v221 + v196) = 0;
                v71 = v220[v196];
                if ( v183 <= 24 )
                  goto LABEL_190;
                v72 = 0;
                v176 = v223;
              }
LABEL_205:
              if ( v71 || v196 < 0 )
              {
                v80 = ~v196;
              }
              else
              {
                v79 = v196;
                do
                  v80 = ~--v79;
                while ( !v220[v79] && v79 >= 0 );
              }
              return round_and_return(
                       &v225,
                       (int)v176 - 1,
                       (unsigned __int64)(v176 - 1) >> 32,
                       v216,
                       v72,
                       31 - v211,
                       v215 | (v80 >> 31));
            }
            v128 = v221;
            v129 = v222;
            if ( v224 > 1 )
            {
              v130 = v220[1];
              v179 = v220[0];
            }
            else
            {
              v130 = 0;
              v179 = v220[0];
              if ( v222 > v220[0] )
              {
                if ( v183 <= 0 )
                {
                  LODWORD(v223) = v183 - 32;
                  HIDWORD(v223) = __CFADD__(v183, -32) + (v183 >> 31) - 1;
                  v193 = 0;
                }
                else
                {
                  v193 = 24 - v183;
                  if ( v183 != 24 )
                  {
                    _mpn_lshift(&v225, (int)&v225, 1, 24 - v183);
                    v179 = v220[0];
                  }
                  v183 += 32;
                }
                if ( v183 > 24 )
                {
                  v123 = 0;
                  v130 = v179;
                  v179 = 0;
                  v185 = v223;
                  goto LABEL_340;
                }
                v130 = v179;
                v179 = 0;
                goto LABEL_328;
              }
            }
            v193 = 0;
LABEL_328:
            v197 = -v128;
            v131 = v183;
            v201 = v128;
            while ( v130 == v129 )
            {
              while ( 1 )
              {
                v26 = __CFADD__(v179, v130);
                v133 = v179 + v130;
                if ( !v26 )
                {
                  v132 = v201;
                  v123 = -1;
                  HIDWORD(v134) = v201 - (v201 != 0);
                  LODWORD(v134) = v197;
                  goto LABEL_331;
                }
                v130 = ((unsigned int)v201 + __PAIR64__(v133 - v201, 0)) >> 32;
                v179 = v201;
                v123 = -1;
LABEL_336:
                if ( !v131 )
                  break;
                if ( v131 >= -7 )
                {
                  v193 = 24 - v131;
                  if ( v131 != 24 )
                  {
                    _mpn_lshift(&v225, (int)&v225, 1, 24 - v131);
                    v225 |= v123 >> (32 - v193);
                  }
                  goto LABEL_350;
                }
                v131 += 32;
                v225 = v123;
                if ( v130 != v129 )
                  goto LABEL_330;
              }
              if ( v123 )
              {
                _BitScanReverse(&v135, v123);
                v136 = v135 ^ 0x1F;
                v185 = v223 - v136;
                v223 = v185;
                if ( 32 - v136 > 24 )
                {
                  v193 = v136 + 24;
                  v225 = v123 >> (8 - v136);
LABEL_340:
                  v137 = v130 || v215 || v179 != 0;
                  v169 = v137;
                  v126 = (unsigned __int64)(v185 - 1) >> 32;
                  v125 = v185 - 1;
                  v127 = 31 - v193;
                  return round_and_return(&v225, v125, v126, v216, v123, v127, v169);
                }
                v131 = 32 - v136;
              }
              else
              {
                v223 -= 32LL;
              }
              v225 = v123;
              if ( v131 > 24 )
              {
LABEL_350:
                v185 = v223;
                goto LABEL_340;
              }
            }
LABEL_330:
            v132 = v201;
            v123 = __PAIR64__(v130, v179) / (unsigned int)v129;
            v133 = __PAIR64__(v130, v179) % (unsigned int)v129;
            v134 = v123 * (unsigned __int64)(unsigned int)v201;
            do
            {
LABEL_331:
              if ( HIDWORD(v134) <= v133 && (!(_DWORD)v134 || HIDWORD(v134) != v133) )
                break;
              --v123;
              v134 -= v132;
              v26 = __CFADD__(v129, v133);
              v133 += v129;
            }
            while ( !v26 );
            v201 = v132;
            v130 = (__PAIR64__(v133, 0) - v134) >> 32;
            v179 = -(int)v134;
            goto LABEL_336;
          }
        }
        else
        {
          v170 = v56;
          v60 = v58[1] - 2;
          memcpy(v56, &dword_80DB7A8[*v58], 4 * v60);
          v56 = v170;
LABEL_164:
          v59 *= 2;
          v58 += 4;
          if ( !v57 )
            goto LABEL_169;
        }
      }
    }
    v106 = str_to_mpn_isra_0(v208, v195, v220, &v224, &v223, v210, v212);
    v107 = HIDWORD(v223);
    v108 = v223;
    v208 = v106;
    if ( v223 > 0 )
    {
      v109 = &fpioconst_pow10;
      v110 = v224;
      v111 = 1;
      v209 = (int *)&v221;
      v200 = v220;
      do
      {
        if ( v108 & v111 | v107 & (v111 >> 31) )
        {
          v114 = v109[1];
          LODWORD(v223) = v111 ^ v108;
          v115 = v114 - 2;
          HIDWORD(v223) = (v111 >> 31) ^ v107;
          v172 = v115;
          if ( v115 <= v110 )
            v112 = _mpn_mul(v209, v200, v110, &dword_80DB7A8[*v109], v115);
          else
            v112 = _mpn_mul(v209, &dword_80DB7A8[*v109], v115, v200, v110);
          v110 = v172 + v224;
          v224 += v172;
          if ( !v112 )
            v224 = --v110;
          v113 = v209;
          v107 = HIDWORD(v223);
          v108 = v223;
          v209 = (int *)v200;
          v200 = (unsigned int *)v113;
        }
        v111 *= 2;
        v109 += 4;
      }
      while ( v108 | v107 );
      if ( v200 == &v221 )
        memcpy(v220, v200, 4 * v110);
    }
    else
    {
      v110 = v224;
    }
    _BitScanReverse(&v138, v220[v110 - 1]);
    v183 = 32 * v110 - (v138 ^ 0x1F);
    if ( !((v183 - 128 < 0) ^ __OFADD__(-128, v183) | (v183 == 128)) )
    {
      v163 = -INFINITY;
      __writegsdword(0xFFFFFFE8, 0x22u);
      if ( !v216 )
        return INFINITY;
      return v163;
    }
    if ( v183 <= 24 )
    {
      if ( v204 == (_DWORD)v195 )
      {
        v143 = (v183 - 1) % 32;
        if ( v143 == 23 )
        {
          memcpy((_BYTE *)&v225 + 4 * (1 - v110), v220, 4 * v110);
          v145 = v183 - 1;
          v159 = 1 - v224;
          if ( 1 - v224 > 0 )
          {
            v160 = 0;
            do
              *(&v225 + v160++) = 0;
            while ( v160 != v159 );
          }
        }
        else if ( v143 <= 22 )
        {
          _mpn_lshift(&v225 + 1 - v110, (int)v220, v110, 23 - v143);
          v145 = v183 - 1;
          v157 = 1 - v224;
          if ( 1 - v224 > 0 )
          {
            v158 = 0;
            do
              *(&v225 + v158++) = 0;
            while ( v158 != v157 );
          }
        }
        else
        {
          if ( v110 > 0 )
            _assert_fail("numsize < (((24) + ((32) - 1)) / (32))", "strtod_l.c", 1251, "____strtof_l_internal");
          v144 = _mpn_rshift((int)(&v225 + 1 - v110), v220, v110, v143 - 23);
          v145 = v183 - 1;
          v146 = -v224;
          v147 = -v224 < 0 || v224 == 0;
          *(&v225 - v224) = v144;
          if ( !v147 )
          {
            v148 = 0;
            do
              *(&v225 + v148++) = 0;
            while ( v148 != v146 );
          }
        }
        return round_and_return(&v225, v145, v145 >> 31, v216, 0, 0, 0);
      }
      memcpy(&v225, v220, 4 * v110);
      goto LABEL_148;
    }
    v139 = (v183 - 24) >> 5;
    v140 = (v183 - 24) & 0x1F;
    if ( v140 )
    {
      v190 = v140 - 1;
      if ( v110 - 1 > v139 )
      {
        v155 = v139 + 1;
        v198 = v220[v139];
        v151 = v198;
        v202 = &v225;
        do
        {
          v213 = v151 >> v140;
          v151 = v220[v155++];
          *v202++ = v213 | (v151 << (32 - v140));
        }
        while ( v155 != v110 );
        if ( v155 - 1 - v139 > 0 )
        {
          v141 = (v183 - 24) >> 5;
          goto LABEL_362;
        }
      }
      else
      {
        v151 = v220[v139];
        v198 = v151;
      }
      v225 = v151 >> v140;
      v141 = (v183 - 24) >> 5;
    }
    else
    {
      v141 = v139 - 1;
      v198 = v220[v139 - 1];
      v190 = 31;
      v225 = v220[v139];
    }
LABEL_362:
    for ( kk = 0; !v220[kk]; ++kk )
      ;
    return round_and_return(
             &v225,
             v183 - 1,
             (v183 - 1) >> 31,
             v216,
             v198,
             v190,
             (v174 < v204) | (unsigned int)(kk < v141));
  }
  v81 = *v208;
  v82 = a4[13];
  v83 = *v208;
  v184 = v82;
  if ( (*(_BYTE *)(v82 + 2 * v83 + 1) & 0x10) == 0 )
  {
    v84 = v208;
    do
    {
      v81 = *++v84;
      v83 = *v84;
    }
    while ( (*(_BYTE *)(v82 + 2 * v83 + 1) & 0x10) == 0 );
    v208 = v84;
  }
  if ( v81 == 48 )
  {
    v85 = v208;
    do
      ++v85;
    while ( *v85 == 48 );
    v208 = v85;
    v83 = *v85;
  }
  v86 = v83 - 48;
  v87 = v208 + 1;
  if ( (unsigned int)(v83 - 48) > 9 )
    v86 = *(_DWORD *)(a4[14] + 4 * v83) - 87;
  v192 = nbits_9430[v86];
  if ( !v192 )
    _assert_fail("bits != 0", "strtod_l.c", 1046, "____strtof_l_internal");
  v225 = v86 << (24 - v192);
  if ( v223 < 0 )
    v88 = 0x8000000000000000LL - v192;
  else
    v88 = 0x7FFFFFFFFFFFFFFFLL - v223 - v192 + 1;
  if ( v173 > (unsigned __int64)(v88 / 4) )
    _assert_fail(
      "int_no <= (uintmax_t) (exponent < 0 ? ((9223372036854775807LL) - bits + 1) / 4 : ((9223372036854775807LL) - expone"
      "nt - bits + 1) / 4)",
      "strtod_l.c",
      1067,
      "____strtof_l_internal");
  v98 = (v223 + 4 * ((unsigned __int64)v173 - 1) + v192 - 1) >> 32;
  v99 = v223 + 4 * (v173 - 1) + v192 - 1;
  v223 += 4 * (v173 - 1LL) + v192 - 1;
  if ( v204 != 1 )
  {
    v100 = v86 << (24 - v192);
    v177 = __PAIR64__(v98, v99);
    v101 = v204 - 1;
    v102 = 23 - v192;
    do
    {
      v104 = *v87;
      if ( (*(_BYTE *)(v184 + 2 * v104 + 1) & 0x10) == 0 )
      {
        v87 += v210;
        v104 = *v87;
      }
      v105 = v104 - 48;
      ++v87;
      if ( (unsigned int)(v104 - 48) > 9 )
        v105 = *(_DWORD *)(a4[14] + 4 * v104) - 87;
      if ( v102 <= 2 )
      {
        v225 = (v105 >> (3 - v102)) | v100;
        return round_and_return(&v225, v177, v98, v216, v105 << (v102 + 29), 0x1Fu, 1);
      }
      v103 = v102 - 3;
      v102 -= 4;
      v100 |= v105 << v103;
      --v101;
      v225 = v100;
    }
    while ( v101 );
    v98 = HIDWORD(v177);
    v99 = v177;
  }
  return round_and_return(&v225, v99, v98, v216, 0, 0, 0);
}
// 80482E0: using guessed type int __cdecl strncasecmp_l(_DWORD, _DWORD, _DWORD, _DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80C8380: using guessed type char **nl_C_locobj[6];
// 80CFDC0: using guessed type int dword_80CFDC0[];
// 80DB7A8: using guessed type unsigned int dword_80DB7A8[886];
// 80DE600: using guessed type int nbits_9430[16];

//----- (080B2500) --------------------------------------------------------
void __cdecl strtof_l(_BYTE *a1, unsigned int *a2, _DWORD *a3)
{
  ___strtof_l_internal(a1, a2, 0, a3);
}

//----- (080B2530) --------------------------------------------------------
long double __usercall round_and_return_0@<st0>(
        unsigned int *a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        int a4,
        unsigned int a5,
        int a6,
        int a7)
{
  __int64 v8; // rax
  int v9; // ebx
  unsigned int v10; // esi
  int v11; // ebp
  long double result; // fst7
  bool v13; // zf
  unsigned int v14; // ebx
  unsigned int v15; // ecx
  int v16; // eax
  unsigned int v17; // ebp
  __int64 v18; // kr00_8

  v8 = __PAIR64__(a3, a2);
  v9 = a7;
  v10 = a5;
  v11 = a6;
  if ( a3 <= -1 )
  {
    if ( SHIDWORD(v8) >= -1 )
    {
      if ( (unsigned int)v8 >= 0xFFFFFC02 )
        goto LABEL_15;
      if ( (unsigned int)v8 >= 0xFFFFFBCD )
      {
        HIDWORD(v8) = -1022 - v8;
        v9 = ((a5 & ((1 << a6) - 1)) != 0) | a7;
        if ( (_DWORD)v8 == -1075 )
        {
          v10 = a1[1];
          v17 = *a1;
          a1[1] = 0;
          *a1 = 0;
          v13 = v17 == 0;
          v11 = 20;
          v9 |= !v13 || v10 != 0;
        }
        else if ( SHIDWORD(v8) > 31 )
        {
          v16 = (HIDWORD(v8) - 1) >> 5;
          v10 = a1[v16];
          if ( v16 == 1 )
            v9 |= *a1 != 0;
          v11 = (BYTE4(v8) - 1) & 0x1F;
          v9 |= (((1 << v11) - 1) & v10) != 0;
          _mpn_rshift((int)a1, a1 + 1, 1, BYTE4(v8) & 0x1F);
          a1[1] = 0;
        }
        else
        {
          v10 = *a1;
          v11 = HIDWORD(v8) - 1;
          _mpn_rshift((int)a1, a1, 2, SBYTE4(v8));
        }
        __writegsdword(0xFFFFFFE8, 0x22u);
        v8 = -1023LL;
        goto LABEL_13;
      }
    }
    result = 0.0;
    __writegsdword(0xFFFFFFE8, 0x22u);
    return result;
  }
LABEL_15:
  if ( v8 <= 1024 )
  {
LABEL_13:
    if ( !_bittest((const int *)&v10, v11) )
      return _mpn_construct_double(a1, v8, a4);
    v13 = v9 == 0;
    v14 = *a1;
    if ( v13 && (v14 & 1) == 0 && (v10 & ((1 << v11) - 1)) == 0 )
      return _mpn_construct_double(a1, v8, a4);
    *a1 = v14 + 1;
    v15 = a1[1];
    if ( v14 > v14 + 1 )
      a1[1] = ++v15;
    if ( (v15 & 0x200000) == 0 )
    {
      if ( !((unsigned int)v8 ^ 0xFFFFFC01 | ~HIDWORD(v8)) )
        LOWORD(v8) = -((v15 & 0x100000) == 0) - 1022;
      return _mpn_construct_double(a1, v8, a4);
    }
    v18 = v8 + 1;
    _mpn_rshift((int)a1, a1, 2, 1);
    a1[1] |= 0x100000u;
    if ( v18 != 1025 )
    {
      LOWORD(v8) = v18;
      return _mpn_construct_double(a1, v8, a4);
    }
  }
  if ( a4 )
    return -INFINITY;
  else
    return INFINITY;
}
// 80B25A8: conditional instruction was optimized away because edx.4==FFFFFFFF
// 80B2658: conditional instruction was optimized away because edx.4==FFFFFFFF

//----- (080B27D0) --------------------------------------------------------
_BYTE *__usercall str_to_mpn_isra_0_0@<eax>(
        _BYTE *a1@<eax>,
        int a2@<edx>,
        unsigned int *a3@<ecx>,
        int *a4,
        __int64 *a5,
        int a6,
        _BYTE *a7)
{
  int v8; // edi
  int v9; // ebp
  char v10; // al
  bool v11; // zf
  int v12; // ecx
  unsigned int v13; // eax
  _BYTE *result; // eax
  char v15; // al
  int v16; // eax
  char v17; // dl
  int v18; // ecx
  int v19; // eax
  int v20; // edx
  int v21; // ebp
  unsigned int v22; // ecx
  unsigned int v23; // edi
  int v24; // eax
  int *v25; // edi
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // edx
  int v30; // esi
  unsigned int v31; // ecx
  unsigned int v32; // edi
  int v33; // eax
  int *v34; // edi
  int v35; // eax
  int v36; // eax
  int v37; // edx
  int v38; // [esp+10h] [ebp-2Ch]
  int v40; // [esp+18h] [ebp-24h]
  int v41; // [esp+1Ch] [ebp-20h]

  v38 = a2;
  *a4 = 0;
  if ( a2 <= 0 )
    _assert_fail("digcnt > 0", "strtod_l.c", 294, "str_to_mpn");
  v40 = 0;
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    v10 = *a1;
    if ( (unsigned __int8)(*a1 - 48) <= 9u )
      goto LABEL_7;
    if ( !a7 || v10 != *a7 )
    {
LABEL_6:
      a1 += a6;
      v10 = *a1;
      goto LABEL_7;
    }
    v15 = a7[1];
    if ( v15 )
    {
      if ( a1[1] != v15 )
        goto LABEL_6;
      v16 = 1;
      while ( 1 )
      {
        v17 = a7[++v16];
        v18 = v16;
        if ( !v17 )
          break;
        if ( a1[v16] != v17 )
          goto LABEL_6;
      }
    }
    else
    {
      v18 = 1;
    }
    a1 += v18;
    v10 = *a1;
LABEL_7:
    ++a1;
    v11 = v38-- == 1;
    v8 = v10 + 10 * v8 - 48;
    v12 = v9 + 1;
    if ( v11 )
      break;
    if ( v9 == 8 )
    {
      if ( v40 )
      {
        v19 = _mpn_mul_1((int)a3, (int)a3, v40, 0x3B9ACA00u);
        v20 = *a4;
        v21 = v19;
        v22 = *a3;
        v23 = *a3 + v8;
        *a3 = v23;
        v24 = 0;
        if ( v22 > v23 )
        {
          v25 = (int *)(a3 + 1);
          while ( --v20 )
          {
            v26 = *v25 + 1;
            *v25++ = v26;
            if ( v26 )
            {
              v24 = 0;
              goto LABEL_27;
            }
          }
          v24 = 1;
        }
LABEL_27:
        v27 = v21 + v24;
        if ( v27 )
        {
          if ( *a4 > 37 )
            _assert_fail("*nsize < ((((1024 + 2 * 53) + ((32) - 1)) / (32)) + 2)", "strtod_l.c", 311, "str_to_mpn");
          v8 = 0;
          a3[*a4] = v27;
          v9 = 0;
          v40 = *a4 + 1;
          *a4 = v40;
        }
        else
        {
          v8 = 0;
          v9 = 0;
          v40 = *a4;
        }
      }
      else
      {
        v40 = 1;
        *a3 = v8;
        v8 = 0;
        *a4 = 1;
        v9 = 0;
      }
    }
    else
    {
      ++v9;
    }
  }
  v41 = *(_DWORD *)a5;
  if ( *a5 <= 0 || *a5 > 8 - v9 )
  {
    v13 = tens_in_limb[v12];
    if ( v40 )
      goto LABEL_31;
    goto LABEL_14;
  }
  v8 *= tens_in_limb[v41];
  v13 = tens_in_limb[v41 + v12];
  *(_DWORD *)a5 = 0;
  *((_DWORD *)a5 + 1) = 0;
  if ( !v40 )
  {
LABEL_14:
    *a3 = v8;
    *a4 = 1;
    return a1;
  }
LABEL_31:
  v28 = _mpn_mul_1((int)a3, (int)a3, v40, v13);
  v29 = *a4;
  v30 = v28;
  v31 = *a3;
  v32 = *a3 + v8;
  *a3 = v32;
  v33 = 0;
  if ( v31 > v32 )
  {
    v34 = (int *)(a3 + 1);
    while ( --v29 )
    {
      v35 = *v34 + 1;
      *v34++ = v35;
      if ( v35 )
      {
        v33 = 0;
        goto LABEL_36;
      }
    }
    v33 = 1;
  }
LABEL_36:
  v36 = v30 + v33;
  if ( !v36 )
    return a1;
  v37 = *a4;
  if ( *a4 > 37 )
    _assert_fail("*nsize < ((((1024 + 2 * 53) + ((32) - 1)) / (32)) + 2)", "strtod_l.c", 367, "str_to_mpn");
  a3[v37] = v36;
  result = a1;
  *a4 = v37 + 1;
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80DE7E0: using guessed type int tens_in_limb[10];

//----- (080B2B30) --------------------------------------------------------
long double __cdecl ___strtod_l_internal(_BYTE *a1, unsigned int *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // eax
  _BYTE *v5; // ebp
  _BYTE *i; // eax
  char v7; // bl
  _BYTE *v8; // esi
  char v9; // dl
  int v10; // eax
  char v11; // cl
  int v12; // edi
  char v13; // al
  int v14; // edi
  _BYTE *v15; // eax
  int v16; // eax
  char v17; // cl
  _BYTE *k; // eax
  int v19; // eax
  char v20; // dl
  int v21; // eax
  int v22; // esi
  char v23; // dl
  _BYTE *m; // ebx
  char v25; // cl
  _BYTE *v26; // eax
  unsigned int v27; // edx
  char v28; // si
  _BYTE *v29; // eax
  char v30; // bl
  int v31; // edx
  char v32; // cl
  unsigned __int64 v33; // rcx
  __int64 v34; // rcx
  signed __int64 v35; // rax
  int v36; // esi
  __int64 v37; // rcx
  long double result; // fst7
  char v39; // al
  unsigned int v40; // eax
  int v41; // edi
  bool v42; // cf
  int v43; // esi
  int v44; // edi
  __int64 v45; // rcx
  __int64 v46; // rax
  unsigned int v47; // esi
  _BYTE *v48; // ebp
  unsigned int v49; // ebx
  char v50; // cl
  _BYTE *v51; // eax
  unsigned int v52; // eax
  _BYTE *v53; // edx
  unsigned int v54; // ecx
  int v55; // eax
  int *v56; // edx
  int v57; // edi
  _DWORD *v58; // esi
  int v59; // ebx
  int v60; // ebp
  int v61; // eax
  unsigned int v62; // ebx
  signed int v63; // ebx
  int v64; // eax
  unsigned int v65; // ebp
  unsigned int v66; // ebx
  int v67; // eax
  int v68; // ecx
  int v69; // esi
  int v70; // eax
  char *v71; // eax
  int *v72; // eax
  int v73; // ecx
  unsigned int v74; // esi
  unsigned __int64 v75; // rtt
  unsigned int v76; // ecx
  unsigned __int64 ii; // rax
  int *v78; // eax
  unsigned int v79; // edi
  signed int v80; // edi
  int v81; // edx
  unsigned int v82; // eax
  char v83; // dl
  int v84; // edi
  int v85; // eax
  char *v86; // ecx
  char *v87; // eax
  char *v88; // esi
  int v89; // eax
  int v90; // ebp
  __int64 v91; // rcx
  _BYTE *v92; // ebx
  _BYTE *v93; // esi
  _BYTE *v94; // ebp
  _BYTE *v95; // eax
  unsigned int v96; // esi
  unsigned int v97; // edi
  __int64 v99; // rcx
  int v100; // edx
  int v101; // eax
  int v102; // ebx
  int v103; // eax
  int v104; // ecx
  unsigned int v105; // edx
  char v106; // cl
  unsigned int v107; // edx
  char *v108; // eax
  int v109; // ecx
  int v110; // ebp
  _DWORD *v111; // edi
  int v112; // ebx
  int v113; // esi
  int v114; // eax
  int *v115; // edx
  int v116; // edx
  int v117; // edx
  unsigned int v118; // esi
  int n; // ecx
  unsigned int v120; // eax
  unsigned int v121; // edx
  unsigned __int64 v122; // rtt
  unsigned int v123; // edi
  signed int v124; // edi
  unsigned int v125; // ebx
  int v126; // ebp
  unsigned int v127; // edx
  int v128; // ecx
  int v129; // eax
  int v130; // edx
  unsigned int v131; // ebp
  int v132; // edi
  int v133; // esi
  int v134; // eax
  int v135; // ecx
  unsigned int v136; // ebp
  unsigned int v137; // esi
  unsigned __int64 v138; // rax
  unsigned int v139; // ecx
  signed int v140; // ecx
  _BOOL4 v141; // eax
  int v142; // eax
  unsigned int v143; // eax
  int v144; // eax
  int v145; // edi
  int v146; // ebx
  unsigned int v147; // ebp
  unsigned int *v148; // eax
  int v149; // eax
  int v150; // eax
  int v151; // eax
  signed int v152; // edx
  int v153; // ecx
  bool v154; // cc
  int v155; // eax
  int *v156; // eax
  unsigned int v157; // edx
  int v158; // esi
  _BYTE *j; // ebx
  char v160; // al
  __int64 v161; // rax
  int v162; // ecx
  bool v163; // zf
  unsigned int v164; // edx
  int v165; // esi
  int v166; // eax
  _BYTE *v167; // eax
  int v168; // esi
  int v169; // eax
  int v170; // ecx
  int v171; // ecx
  int v172; // eax
  char v173; // cl
  int v174; // eax
  int v175; // [esp+Ch] [ebp-1F0h]
  int *v176; // [esp+24h] [ebp-1D8h]
  int *v177; // [esp+24h] [ebp-1D8h]
  int v178; // [esp+24h] [ebp-1D8h]
  unsigned int v179; // [esp+28h] [ebp-1D4h]
  unsigned int v180; // [esp+28h] [ebp-1D4h]
  unsigned int *v181; // [esp+28h] [ebp-1D4h]
  __int64 v182; // [esp+28h] [ebp-1D4h]
  __int64 v183; // [esp+28h] [ebp-1D4h]
  int v184; // [esp+28h] [ebp-1D4h]
  char v185; // [esp+28h] [ebp-1D4h]
  unsigned int v186; // [esp+34h] [ebp-1C8h]
  int v187; // [esp+34h] [ebp-1C8h]
  int v188; // [esp+34h] [ebp-1C8h]
  int v189; // [esp+34h] [ebp-1C8h]
  _BYTE *v190; // [esp+38h] [ebp-1C4h]
  _BYTE *v191; // [esp+38h] [ebp-1C4h]
  signed int v192; // [esp+38h] [ebp-1C4h]
  __int64 v193; // [esp+38h] [ebp-1C4h]
  char *v194; // [esp+40h] [ebp-1BCh]
  _BYTE *v195; // [esp+40h] [ebp-1BCh]
  _BYTE *v196; // [esp+40h] [ebp-1BCh]
  __int64 v197; // [esp+40h] [ebp-1BCh]
  unsigned int *v198; // [esp+40h] [ebp-1BCh]
  int v199; // [esp+48h] [ebp-1B4h]
  __int64 v200; // [esp+48h] [ebp-1B4h]
  signed int v201; // [esp+48h] [ebp-1B4h]
  int v202; // [esp+48h] [ebp-1B4h]
  unsigned int v203; // [esp+48h] [ebp-1B4h]
  unsigned int *v204; // [esp+50h] [ebp-1ACh]
  _BYTE *v205; // [esp+54h] [ebp-1A8h]
  int v206; // [esp+54h] [ebp-1A8h]
  int v207; // [esp+58h] [ebp-1A4h]
  char v208; // [esp+58h] [ebp-1A4h]
  __int64 v209; // [esp+58h] [ebp-1A4h]
  int v210; // [esp+58h] [ebp-1A4h]
  int *v211; // [esp+58h] [ebp-1A4h]
  char *v212; // [esp+60h] [ebp-19Ch]
  int v213; // [esp+60h] [ebp-19Ch]
  int v214; // [esp+64h] [ebp-198h]
  int v215; // [esp+64h] [ebp-198h]
  char *v216; // [esp+68h] [ebp-194h]
  int v217; // [esp+68h] [ebp-194h]
  unsigned int v218; // [esp+68h] [ebp-194h]
  int v219; // [esp+6Ch] [ebp-190h]
  int v220; // [esp+70h] [ebp-18Ch]
  bool v221; // [esp+77h] [ebp-185h]
  int v222; // [esp+80h] [ebp-17Ch]
  _BYTE *v223; // [esp+84h] [ebp-178h]
  char v224; // [esp+94h] [ebp-168h] BYREF
  unsigned int v225; // [esp+98h] [ebp-164h] BYREF
  int v226[37]; // [esp+9Ch] [ebp-160h] BYREF
  unsigned int v227; // [esp+130h] [ebp-CCh] BYREF
  unsigned int v228; // [esp+134h] [ebp-C8h]
  __int64 v229; // [esp+1C8h] [ebp-34h] BYREF
  int v230; // [esp+1D0h] [ebp-2Ch] BYREF
  int v231; // [esp+1D4h] [ebp-28h] BYREF
  int v232; // [esp+1D8h] [ebp-24h] BYREF
  char *v233; // [esp+1DCh] [ebp-20h] BYREF
  unsigned int v234; // [esp+200h] [ebp+4h]

  v4 = (_DWORD *)a4[1];
  if ( !a3 || (v194 = (char *)v4[11], (unsigned __int8)(*v194 - 1) > 0x7Du) || (v216 = (char *)v4[10], !*v216) )
  {
    v194 = 0;
    v216 = 0;
  }
  v5 = (_BYTE *)v4[9];
  v214 = strlen(v5);
  if ( !v214 )
    _assert_fail("decimal_len > 0", "strtod_l.c", 514, "____strtod_l_internal");
  v229 = 0LL;
  for ( i = a1 - 1; ; ++i )
  {
    v7 = i[1];
    v8 = i + 1;
    if ( (*(_BYTE *)(a4[13] + 2 * v7 + 1) & 0x20) == 0 )
      break;
  }
  if ( v7 == 45 )
  {
    v8 = i + 2;
    v7 = i[2];
    v220 = 1;
  }
  else
  {
    v220 = 0;
    if ( v7 == 43 )
    {
      v8 = i + 2;
      v7 = i[2];
    }
  }
  v9 = *v5;
  if ( !*v5 )
  {
    v12 = 0;
    goto LABEL_15;
  }
  v10 = 0;
  if ( v9 == *v8 )
  {
    while ( 1 )
    {
      v11 = v5[++v10];
      v12 = v10;
      if ( !v11 )
        break;
      if ( v11 != v8[v10] )
        goto LABEL_91;
    }
LABEL_15:
    v13 = v8[v12];
    if ( v13 > 47 && v13 <= 57 )
      goto LABEL_17;
  }
LABEL_91:
  if ( (unsigned __int8)(v7 - 48) > 9u )
  {
    v39 = dword_80CFDC0[v7];
    if ( v39 != 105 )
    {
      if ( v39 == 110 && !strncasecmp_l(v8, &unk_80C9C98, 3, nl_C_locobj) )
      {
        v94 = v8 + 3;
        if ( v8[3] != 40 )
          goto LABEL_241;
        for ( j = v8 + 3; ; ++j )
        {
          v160 = j[1];
          if ( (unsigned __int8)(v160 - 48) > 9u
            && (unsigned __int8)(*(_BYTE *)(a4[14] + 4 * v160) - 97) > 0x19u
            && v160 != 95 )
          {
            break;
          }
        }
        if ( v160 == 41 )
        {
          v161 = ___strtoull_l_internal(v8 + 4, &v233, 0, 0, a4);
          result = NAN;
          if ( v233 == j + 1 )
          {
            HIDWORD(v161) &= 0xFFFFFu;
            v162 = 0x80000;
            v163 = v161 == 0;
            if ( v161 )
              v162 = HIDWORD(v161);
            v164 = 0;
            if ( !v163 )
              v164 = v161;
            result = COERCE_DOUBLE(__PAIR64__(v162 | 0x7FF00000u, v164));
          }
          v94 = j + 2;
        }
        else
        {
LABEL_241:
          result = NAN;
        }
        if ( a2 )
          *a2 = (unsigned int)v94;
        return result;
      }
      goto LABEL_94;
    }
    if ( strncasecmp_l(v8, &unk_80C9C94, 3, nl_C_locobj) )
    {
LABEL_94:
      if ( a2 )
      {
        result = 0.0;
        *a2 = (unsigned int)a1;
        return result;
      }
      return 0.0;
    }
    if ( a2 )
    {
      v92 = v8 + 3;
      v93 = v8 + 8;
      if ( !strncasecmp_l(v92, "inity", 5, nl_C_locobj) )
        v92 = v93;
      *a2 = (unsigned int)v92;
    }
LABEL_237:
    if ( !v220 )
      return INFINITY;
    return -INFINITY;
  }
LABEL_17:
  if ( v7 == 48 )
  {
    v199 = 10;
    v14 = a4[14];
    if ( *(_DWORD *)(v14 + 4 * (char)v8[1]) == 120 )
    {
      v7 = v8[2];
      v8 += 2;
      v194 = 0;
      v199 = 16;
    }
  }
  else
  {
    v199 = 10;
    v14 = a4[14];
  }
  if ( v216 )
  {
    v205 = v8;
    v185 = *v216;
    while ( 1 )
    {
      if ( v7 != 48 )
      {
        if ( v185 )
        {
          if ( *v205 != v185 )
            goto LABEL_24;
          v172 = 0;
          while ( 1 )
          {
            v173 = v216[++v172];
            if ( !v173 )
              break;
            if ( v173 != v205[v172] )
              goto LABEL_24;
          }
          v174 = v172 - 1;
        }
        else
        {
          v174 = -1;
        }
        v205 += v174;
      }
      v7 = *++v205;
    }
  }
  v205 = v8;
  if ( v7 == 48 )
  {
    v15 = v8;
    do
      v7 = *++v15;
    while ( *v15 == 48 );
    v205 = v15;
  }
LABEL_24:
  v179 = 0;
  v190 = v205;
  v207 = *(_DWORD *)(v14 + 4 * v7);
  if ( (unsigned __int8)(v7 - 48) <= 9u || (char)v207 > 96 && v199 == 16 && (char)v207 <= 102 )
    goto LABEL_34;
  if ( !v9 )
  {
LABEL_31:
    if ( v8 != v205 || v199 != 16 )
    {
      v179 = 0;
      k = v205;
      goto LABEL_35;
    }
    v179 = 0;
    v190 = v205;
    if ( (unsigned __int8)(v205[v214] - 48) <= 9u
      || (unsigned __int8)(*(_BYTE *)(v14 + 4 * (char)v205[v214]) - 97) <= 5u )
    {
      goto LABEL_34;
    }
    goto LABEL_108;
  }
  if ( *v205 == v9 )
  {
    v16 = 0;
    do
    {
      v17 = v5[++v16];
      if ( !v17 )
        goto LABEL_31;
    }
    while ( v17 == v205[v16] );
  }
  if ( v199 != 16 || v8 == v205 || (v179 = 0, v190 = v205, (_BYTE)v207 != 112) )
  {
LABEL_108:
    if ( (_BYTE)v207 != 101 || (v179 = 0, v190 = v205, v199 == 16) )
    {
      v40 = _correctly_grouped_prefixmb((unsigned int)v8, (unsigned int)v205, v216, v194);
      if ( a2 )
      {
        if ( v8 == (_BYTE *)v40 )
        {
          v167 = v205 - 1;
          if ( v199 != 16 )
            v167 = a1;
          v234 = (unsigned int)v167;
        }
        else
        {
          v234 = v40;
        }
        *a2 = v234;
      }
      goto LABEL_114;
    }
  }
LABEL_34:
  for ( k = v190; ; ++k )
  {
LABEL_35:
    if ( (unsigned __int8)(v7 - 48) <= 9u || v199 == 16 && (unsigned __int8)(*(_BYTE *)(v14 + 4 * v7) - 97) <= 5u )
    {
      ++v179;
      goto LABEL_99;
    }
    if ( !v216 )
      goto LABEL_38;
    if ( *v216 )
      break;
    v171 = -1;
LABEL_473:
    k += v171;
LABEL_99:
    v7 = k[1];
  }
  if ( *v216 == *k )
  {
    v170 = 0;
    while ( v216[++v170] )
    {
      if ( v216[v170] != k[v170] )
        goto LABEL_38;
    }
    v171 = v170 - 1;
    goto LABEL_473;
  }
LABEL_38:
  v191 = k;
  if ( v8 < k && v194 )
  {
    v52 = _correctly_grouped_prefixmb((unsigned int)v8, (unsigned int)k, v216, v194);
    if ( (_BYTE *)v52 != v191 )
    {
      if ( v8 != (_BYTE *)v52 )
      {
        if ( (unsigned int)v205 > v52 )
        {
          if ( a2 )
            *a2 = v52;
          goto LABEL_114;
        }
        v53 = v205;
        v186 = 0;
        if ( (unsigned int)v205 >= v52 )
        {
          v195 = (_BYTE *)v52;
          v219 = 0;
          v179 = 0;
        }
        else
        {
          v54 = 0;
          do
            v54 += (unsigned __int8)(*v53++ - 48) < 0xAu;
          while ( v53 != (_BYTE *)v52 );
          v186 = v54;
          v179 = v54;
          v195 = v53;
          v219 = 0;
        }
        goto LABEL_65;
      }
      if ( a2 )
      {
        result = 0.0;
        *a2 = (unsigned int)a1;
        return result;
      }
      return 0.0;
    }
    v9 = *v5;
    v14 = a4[14];
  }
  v219 = -(v179 == 0);
  if ( v9 )
  {
    v19 = 0;
    if ( *v191 == v9 )
    {
      while ( 1 )
      {
        v20 = v5[++v19];
        if ( !v20 )
          goto LABEL_44;
        if ( v20 != v191[v19] )
        {
          v25 = *(_BYTE *)(v14 + 4 * v7);
          v186 = v179;
          goto LABEL_117;
        }
      }
    }
    v25 = *(_BYTE *)(v14 + 4 * v7);
    v186 = v179;
  }
  else
  {
LABEL_44:
    v21 = 0;
    v22 = -(v179 == 0);
    v23 = v191[v214];
    for ( m = &v191[v214]; ; v23 = *m )
    {
      if ( (unsigned __int8)(v23 - 48) > 9u )
      {
        if ( v199 != 16 )
        {
          v186 = v21 + v179;
          v219 = v22;
          v191 = m;
          v25 = *(_BYTE *)(v14 + 4 * v23);
          v221 = 0;
          goto LABEL_53;
        }
        if ( (unsigned __int8)(*(_BYTE *)(v14 + 4 * v23) - 97) > 5u )
          break;
      }
      if ( v22 == -1 && v23 != 48 )
        v22 = v21;
      ++m;
      ++v21;
    }
    v186 = v21 + v179;
    v219 = v22;
    v25 = *(_BYTE *)(v14 + 4 * v23);
    v191 = m;
  }
LABEL_117:
  v221 = v199 == 16;
  if ( v25 == 112 && v199 == 16 )
  {
    v221 = 1;
  }
  else
  {
LABEL_53:
    if ( v25 != 101 || v199 == 16 )
    {
      v195 = v191;
      goto LABEL_56;
    }
  }
  v208 = v191[1];
  if ( v208 == 45 )
  {
    v222 = 1;
    v196 = v191 + 2;
    v208 = v191[2];
  }
  else
  {
    v222 = 0;
    if ( v208 == 43 )
    {
      v196 = v191 + 2;
      v208 = v191[2];
    }
    else
    {
      v196 = v191 + 1;
    }
  }
  if ( (unsigned __int8)(v208 - 48) > 9u )
  {
    v195 = v191;
    goto LABEL_56;
  }
  if ( v221 )
  {
    if ( v222 )
    {
      v41 = (unsigned __int64)v179 >> 30;
      v42 = __CFADD__(4 * v179, 1074);
      v43 = 4 * v179 + 1074;
LABEL_127:
      v44 = v42 + v41;
      goto LABEL_128;
    }
    if ( v179 )
    {
      if ( v219 )
        _assert_fail(
          "lead_zero == 0 && int_no <= (uintmax_t) (9223372036854775807LL) / 4",
          "strtod_l.c",
          860,
          "____strtod_l_internal");
      v44 = (4 * (256 - (unsigned __int64)v179) + 3) >> 32;
      v43 = 4 * (256 - v179) + 3;
    }
    else
    {
      v44 = 0;
      v45 = 102LL;
      v43 = 1027;
      if ( v219 == -1 )
        goto LABEL_129;
      v44 = (4 * (unsigned __int64)(unsigned int)v219 + 1027) >> 32;
      v43 = 4 * v219 + 1027;
    }
LABEL_249:
    if ( v44 < 0 )
    {
      v45 = 0LL;
      v43 = 0;
      v44 = 0;
      goto LABEL_129;
    }
LABEL_128:
    v45 = __SPAIR64__(v44, v43) / 10;
    goto LABEL_129;
  }
  if ( v222 )
  {
    v41 = 0;
    v42 = __CFADD__(v179, 360);
    v43 = v179 + 360;
    goto LABEL_127;
  }
  if ( v179 )
  {
    if ( v219 )
      _assert_fail(
        "lead_zero == 0 && int_no <= (uintmax_t) (9223372036854775807LL)",
        "strtod_l.c",
        892,
        "____strtod_l_internal");
    v44 = (309 - (unsigned __int64)v179) >> 32;
    v43 = 309 - v179;
    goto LABEL_249;
  }
  v44 = 0;
  v45 = 30LL;
  v43 = 309;
  if ( v219 != -1 )
  {
    v44 = ((unsigned __int64)(unsigned int)v219 + 309) >> 32;
    v43 = v219 + 309;
    goto LABEL_249;
  }
LABEL_129:
  v46 = __SPAIR64__(v44, v43) % 10;
  v223 = v5;
  v47 = HIDWORD(v229);
  v48 = v196;
  v197 = v45;
  v49 = v229;
  v50 = v208;
  while ( 2 )
  {
    if ( v197 < __SPAIR64__(v47, v49) )
    {
LABEL_131:
      if ( v219 == -1 )
      {
        result = 0.0;
        if ( v220 )
        {
          result = -0.0;
          v51 = v48;
          goto LABEL_135;
        }
      }
      else
      {
        __writegsdword(0xFFFFFFE8, 0x22u);
        if ( v222 )
        {
          result = 0.0;
          if ( v220 )
          {
            v51 = v48;
            result = -0.0;
            goto LABEL_135;
          }
        }
        else
        {
          if ( v220 )
          {
            result = -INFINITY;
            v51 = v48;
            do
LABEL_135:
              ++v51;
            while ( (unsigned __int8)(*v51 - 48) <= 9u );
            if ( a2 )
              *a2 = (unsigned int)v51;
            return result;
          }
          result = INFINITY;
        }
      }
      v51 = v48;
      goto LABEL_135;
    }
    if ( v197 == __PAIR64__(v47, v49) )
    {
      v209 = v50 - 48;
      if ( v209 > v46 )
        goto LABEL_131;
    }
    else
    {
      v209 = v50 - 48;
    }
    v47 = (v209 + __PAIR64__(10 * v47 + ((10 * (unsigned __int64)v49) >> 32), 10 * v49)) >> 32;
    v49 = v209 + 10 * v49;
    ++v48;
    v229 = __PAIR64__(v47, v49);
    v50 = *v48;
    if ( (unsigned __int8)(*v48 - 48) <= 9u )
      continue;
    break;
  }
  v195 = v48;
  v5 = v223;
  if ( v222 )
    v229 = -__SPAIR64__(v47, v49);
LABEL_56:
  v26 = v191;
  if ( v186 > v179 )
  {
    if ( *(v191 - 1) == 48 )
    {
      v27 = v186;
      do
      {
        --v26;
        --v27;
      }
      while ( *(v26 - 1) == 48 );
      v186 = v27;
    }
    if ( v186 < v179 )
      _assert_fail("dig_no >= int_no", "strtod_l.c", 967, "____strtod_l_internal");
  }
  if ( v186 && v186 == v179 && v229 < 0 )
  {
    v95 = v26 - 1;
    v96 = v186;
    v97 = v179;
    while ( 1 )
    {
      if ( !(v221 ? (*(_BYTE *)(a4[13] + 2 * (char)*v95 + 1) & 0x10) == 0 : (unsigned int)((char)*v95 - 48) > 9) )
      {
        if ( *v95 != 48 )
          break;
        --v96;
        --v97;
        v99 = 4LL;
        if ( !v221 )
          v99 = 1LL;
        v229 += v99;
        if ( v229 >= 0 || !v96 )
          break;
      }
      --v95;
    }
    v186 = v96;
    v179 = v97;
  }
LABEL_65:
  if ( a2 )
    *a2 = (unsigned int)v195;
  if ( !v186 )
    goto LABEL_114;
  v212 = v205;
  if ( !v219 )
    goto LABEL_84;
  v28 = v5[1];
  v29 = v205;
  v30 = *v205;
  while ( 2 )
  {
    if ( *v5 != v30 )
    {
      v30 = v29[1];
LABEL_71:
      ++v29;
      continue;
    }
    break;
  }
  if ( !v28 )
    goto LABEL_78;
  v30 = v29[1];
  v31 = 1;
  if ( v30 != v28 )
    goto LABEL_71;
  while ( 1 )
  {
    v32 = v5[++v31];
    if ( !v32 )
      break;
    if ( v32 != v29[v31] )
      goto LABEL_71;
  }
LABEL_78:
  v33 = v229 + 0x8000000000000000LL;
  if ( v199 == 16 )
    v33 >>= 2;
  if ( v33 < (unsigned int)v219 )
    _assert_fail(
      "lead_zero <= (base == 16 ? ((uintmax_t) exponent - (uintmax_t) (-9223372036854775807LL-1)) / 4 : ((uintmax_t) expo"
      "nent - (uintmax_t) (-9223372036854775807LL-1)))",
      "strtod_l.c",
      1022,
      "____strtod_l_internal");
  v34 = (unsigned int)v219;
  if ( v199 == 16 )
    v34 = 4LL * (unsigned int)v219;
  v186 -= v219;
  v212 = &v29[v214 + v219];
  v229 -= v34;
LABEL_84:
  if ( v199 == 16 )
  {
    v83 = *v212;
    v84 = a4[13];
    v85 = *v212;
    if ( (*(_BYTE *)(v84 + 2 * v85 + 1) & 0x10) == 0 )
    {
      v86 = v212;
      do
      {
        v83 = *++v86;
        v85 = *v86;
      }
      while ( (*(_BYTE *)(v84 + 2 * v85 + 1) & 0x10) == 0 );
      v212 = v86;
    }
    if ( v83 == 48 )
    {
      v87 = v212;
      do
        ++v87;
      while ( *v87 == 48 );
      v212 = v87;
      v85 = *v87;
    }
    if ( (unsigned int)(v85 - 48) <= 9 )
    {
      v89 = v85 - 48;
      v88 = v212 + 1;
    }
    else
    {
      v88 = v212 + 1;
      v89 = *(_DWORD *)(a4[14] + 4 * v85) - 87;
    }
    v90 = nbits_9419[v89];
    if ( !v90 )
      _assert_fail("bits != 0", "strtod_l.c", 1046, "____strtod_l_internal");
    v231 = v89 << (21 - v90);
    if ( v229 < 0 )
      v91 = 0x8000000000000000LL - v90;
    else
      v91 = 0x7FFFFFFFFFFFFFFFLL - v229 - v90 + 1;
    if ( v179 > (unsigned __int64)(v91 / 4) )
      _assert_fail(
        "int_no <= (uintmax_t) (exponent < 0 ? ((9223372036854775807LL) - bits + 1) / 4 : ((9223372036854775807LL) - expo"
        "nent - bits + 1) / 4)",
        "strtod_l.c",
        1067,
        "____strtod_l_internal");
    v102 = 20 - v90;
    v103 = 1;
    v229 += 4 * (v179 - 1LL) + v90 - 1;
    while ( --v186 )
    {
      while ( 1 )
      {
        v104 = *v88;
        if ( (*(_BYTE *)(v84 + 2 * v104 + 1) & 0x10) == 0 )
        {
          v88 += v214;
          v104 = *v88;
        }
        v105 = v104 - 48;
        ++v88;
        if ( (unsigned int)(v104 - 48) > 9 )
          v105 = *(_DWORD *)(a4[14] + 4 * v104) - 87;
        if ( v102 <= 2 )
          break;
        v106 = v102 - 3;
        v102 -= 4;
        *(&v230 + v103) |= v105 << v106;
        if ( !--v186 )
          goto LABEL_288;
      }
      *(&v230 + v103) |= v105 >> (3 - v102);
      v107 = v105 << (v102 + 29);
      if ( !v103 )
        return round_and_return_0((unsigned int *)&v230, v229, SHIDWORD(v229), v220, v107, 31, 1);
      v230 = v107;
      v102 += 28;
      v103 = 0;
    }
LABEL_288:
    if ( v103 == 1 )
      v230 = 0;
    return round_and_return_0((unsigned int *)&v230, v229, SHIDWORD(v229), v220, 0, 0, 0);
  }
  if ( v229 < 0 )
  {
    v35 = -(__int64)v179;
    if ( v35 < v229 )
      goto LABEL_87;
  }
  else
  {
    v35 = v186 - (unsigned __int64)v179;
    if ( v35 > v229 )
LABEL_87:
      v35 = v229;
  }
  v36 = v35 + v179;
  v37 = v229 - v35;
  v200 = (unsigned int)v35 + v179;
  v180 = v35 + v179;
  v229 = v37;
  if ( v37 > 309 - v200 )
  {
    __writegsdword(0xFFFFFFE8, 0x22u);
    if ( !v220 )
      return INFINITY;
    return -INFINITY;
  }
  if ( v37 < -323 )
  {
    __writegsdword(0xFFFFFFE8, 0x22u);
LABEL_114:
    result = 0.0;
    if ( v220 )
      return -0.0;
    return result;
  }
  v192 = 0;
  if ( v36 )
  {
    v108 = str_to_mpn_isra_0_0(v212, v36, &v225, &v232, &v229, v214, v216);
    v109 = HIDWORD(v229);
    v110 = v229;
    v212 = v108;
    if ( v229 > 0 )
    {
      v111 = &fpioconst_pow10;
      v112 = v232;
      v113 = 1;
      v211 = (int *)&v227;
      v204 = &v225;
      do
      {
        if ( v110 & v113 | v109 & (v113 >> 31) )
        {
          v116 = v111[1];
          LODWORD(v229) = v113 ^ v110;
          v117 = v116 - 2;
          HIDWORD(v229) = (v113 >> 31) ^ v109;
          v178 = v117;
          if ( v117 <= v112 )
            v114 = _mpn_mul(v211, v204, v112, &dword_80DB7A8[*v111], v117);
          else
            v114 = _mpn_mul(v211, &dword_80DB7A8[*v111], v117, v204, v112);
          v112 = v178 + v232;
          v232 += v178;
          if ( !v114 )
            v232 = --v112;
          v115 = v211;
          v109 = HIDWORD(v229);
          v110 = v229;
          v211 = (int *)v204;
          v204 = (unsigned int *)v115;
        }
        v113 *= 2;
        v111 += 4;
      }
      while ( v110 | v109 );
      if ( v204 == &v227 )
        memcpy(&v225, v204, 4 * v112);
    }
    else
    {
      v112 = v232;
    }
    _BitScanReverse(&v143, *(&v225 + v112 - 1));
    v192 = 32 * v112 - (v143 ^ 0x1F);
    if ( v192 <= 1024 )
    {
      if ( v192 > 53 )
      {
        v144 = (v192 - 53) >> 5;
        v145 = (v192 - 53) & 0x1F;
        if ( v145 )
        {
          v157 = v226[v144 - 1];
          v215 = v145 - 1;
          v203 = v157;
          if ( v112 - 1 <= v144 )
            goto LABEL_402;
          v158 = v144 + 1;
          v198 = (unsigned int *)&v230;
          v157 = v226[v144 - 1];
          do
          {
            v218 = v157 >> v145;
            v157 = v226[v158++ - 1];
            *v198++ = v218 | (v157 << (32 - v145));
          }
          while ( v158 != v112 );
          v146 = (v192 - 53) >> 5;
          if ( v158 - 1 - v144 <= 1 )
          {
LABEL_402:
            v146 = (v192 - 53) >> 5;
            v231 = v157 >> v145;
          }
        }
        else
        {
          v146 = v144 - 1;
          v147 = *(&v225 + v144 - 1);
          v148 = (unsigned int *)&v226[v144 - 1];
          v230 = *v148;
          v203 = v147;
          v215 = 31;
          v231 = v148[1];
        }
        v149 = 0;
        if ( !v225 )
        {
          do
            ++v149;
          while ( !v226[v149 - 1] );
        }
        return round_and_return_0(
                 (unsigned int *)&v230,
                 v192 - 1,
                 (v192 - 1) >> 31,
                 v220,
                 v203,
                 v215,
                 (v180 < v186) | (unsigned int)(v149 < v146));
      }
      if ( v186 == v180 )
      {
        v150 = (v192 - 1) % 32;
        if ( v150 == 20 )
        {
          memcpy((_BYTE *)&v230 + 4 * (2 - v112), &v225, 4 * v112);
          v152 = v192 - 1;
          v168 = 2 - v232;
          if ( 2 - v232 > 0 )
          {
            v169 = 0;
            do
              *(&v230 + v169++) = 0;
            while ( v169 != v168 );
          }
        }
        else if ( v150 <= 19 )
        {
          _mpn_lshift(&v230 + 2 - v112, (int)&v225, v112, 20 - v150);
          v152 = v192 - 1;
          v165 = 2 - v232;
          if ( 2 - v232 > 0 )
          {
            v166 = 0;
            do
              *(&v230 + v166++) = 0;
            while ( v166 != v165 );
          }
        }
        else
        {
          if ( v112 > 1 )
            _assert_fail("numsize < (((53) + ((32) - 1)) / (32))", "strtod_l.c", 1251, "____strtod_l_internal");
          v151 = _mpn_rshift((int)(&v230 + 2 - v112), &v225, v112, v150 - 20);
          v152 = v192 - 1;
          v153 = 1 - v232;
          v154 = 1 - v232 <= 0;
          *(&v230 + 1 - v232) = v151;
          if ( !v154 )
          {
            v155 = 0;
            do
              *(&v230 + v155++) = 0;
            while ( v155 != v153 );
          }
        }
        return round_and_return_0((unsigned int *)&v230, v152, v152 >> 31, v220, 0, 0, 0);
      }
      memcpy(&v230, &v225, 4 * v112);
      if ( v112 <= 1 )
        *(&v230 + v112) = 0;
      goto LABEL_154;
    }
    __writegsdword(0xFFFFFFE8, 0x22u);
    goto LABEL_237;
  }
LABEL_154:
  if ( v186 <= v180 || v229 > 0 )
    _assert_fail("dig_no > int_no && exponent <= 0", "strtod_l.c", 1292, "____strtod_l_internal");
  if ( v186 > v200 + (55 - v192) / 3 + 2 )
  {
    v210 = 1;
    v186 = v180 + (55 - v192) / 3 + 2;
  }
  else
  {
    v210 = 0;
  }
  v55 = v186 - v180;
  v56 = (int *)&v227;
  v57 = v186 - v180 - v229;
  v58 = &fpioconst_pow10;
  v181 = &v225;
  v59 = 1;
  v60 = 0;
  v187 = v55;
  while ( 2 )
  {
    while ( 2 )
    {
      if ( (v59 & v57) == 0 )
      {
LABEL_162:
        v59 *= 2;
        v58 += 4;
        if ( !v57 )
          goto LABEL_167;
        continue;
      }
      break;
    }
    v57 ^= v59;
    if ( !v60 )
    {
      v176 = v56;
      v60 = v58[1] - 2;
      memcpy(v56, &dword_80DB7A8[*v58], 4 * v60);
      v56 = v176;
      goto LABEL_162;
    }
    v177 = v56;
    v61 = _mpn_mul(v181, &dword_80DB7A8[*v58], v58[1] - 2, (unsigned int *)v56, v60);
    v60 = v60 + v58[1] - 2;
    if ( v61 )
    {
      v56 = (int *)v181;
      v181 = (unsigned int *)v177;
      goto LABEL_162;
    }
    --v60;
    v56 = (int *)v181;
    v59 *= 2;
    v58 += 4;
    v181 = (unsigned int *)v177;
    if ( v57 )
      continue;
    break;
  }
LABEL_167:
  v201 = v60;
  if ( v56 == (int *)&v225 )
    memcpy(&v227, &v225, 4 * v60);
  str_to_mpn_isra_0_0(v212, v187, &v225, &v232, &v229, v214, v216);
  v188 = v60 - 1;
  _BitScanReverse(&v62, *(&v227 + v60 - 1));
  v63 = v62 ^ 0x1F;
  if ( v63 > 0 )
  {
    _mpn_lshift(&v227, (int)&v227, v60, v63);
    v64 = _mpn_lshift(&v225, (int)&v225, v232, v63);
    if ( v64 )
    {
      v100 = v232;
      v226[v232 - 1] = v64;
      v232 = v100 + 1;
    }
  }
  v229 = v192;
  if ( v60 == 1 )
  {
    if ( v225 >= v227 || v232 != 1 )
      _assert_fail("numsize == 1 && n < d", "strtod_l.c", 1395, "____strtod_l_internal");
    v118 = v225;
    for ( n = v192; ; n += 32 )
    {
      while ( 1 )
      {
        LODWORD(v122) = 0;
        HIDWORD(v122) = v118;
        v120 = v122 / v227;
        v121 = v122 % v227;
        v118 = v121;
        if ( n )
          break;
        if ( v120 )
        {
          _BitScanReverse(&v123, v120);
          v124 = v123 ^ 0x1F;
          v183 = v229 - v124;
          v229 = v183;
          n = 32 - v124;
          if ( 32 - v124 > 53 )
          {
            v125 = v120;
            v230 = v120 >> (-21 - v124);
            v126 = v124 + 53;
            goto LABEL_315;
          }
        }
        else
        {
          v229 -= 32LL;
        }
        v231 = 0;
        v230 = v120;
        if ( n > 53 )
        {
          v125 = v120;
          v118 = v121;
          v126 = 0;
          goto LABEL_322;
        }
      }
      if ( n > 21 )
      {
        v125 = v120;
        v126 = 53 - n;
        v118 = v121;
        if ( 53 - n > 0 )
        {
          _mpn_lshift(&v230, (int)&v230, 2, 53 - n);
          v230 |= v125 >> (32 - v126);
        }
LABEL_322:
        v183 = v229;
LABEL_315:
        v128 = (unsigned __int64)(v183 - 1) >> 32;
        v127 = v183 - 1;
        v175 = v210 | (v118 != 0);
        v129 = 31 - v126;
        return round_and_return_0((unsigned int *)&v230, v127, v128, v220, v125, v129, v175);
      }
      v130 = v230;
      v230 = v120;
      v231 = v130;
    }
  }
  if ( v60 != 2 )
  {
    v65 = *(&v227 + v188);
    v217 = v201 - 2;
    v66 = *(&v227 + v201 - 2);
    v67 = _mpn_cmp((int)&v225, (int)(&v227 + v201 - v232), v232);
    v68 = v232;
    if ( v67 > 0 )
    {
      v68 = v232 + 1;
      v226[v232 - 1] = 0;
      v232 = v68;
    }
    if ( v68 >= v201 )
    {
      if ( v68 != v201 )
        _assert_fail("numsize == densize", "strtod_l.c", 1606, "____strtod_l_internal");
      v156 = &v226[v188 - 1];
      if ( v201 > 0 )
      {
        do
        {
          v156[1] = *v156;
          --v156;
        }
        while ( v156 != (int *)&v224 );
      }
      v225 = 0;
      v213 = 0;
      *(&v227 + v201) = 0;
      v73 = v226[v201 - 1];
      while ( 1 )
      {
        while ( 1 )
        {
LABEL_189:
          v74 = -1;
          if ( v73 != v65 )
          {
            LODWORD(v75) = v226[v188 - 1];
            HIDWORD(v75) = v73;
            v74 = v75 / v65;
            v76 = v75 % v65;
            for ( ii = v74 * (unsigned __int64)v66; ii > __PAIR64__(v76, v226[v217 - 1]); ii -= v66 )
            {
              --v74;
              v42 = __CFADD__(v65, v76);
              v76 += v65;
              if ( v42 )
                break;
            }
          }
          if ( v226[v201 - 1] != _mpn_submul_1((int)&v225, (int)&v227, v201 + 1, v74) )
          {
            if ( !_mpn_add_n(&v225, &v225, &v227, v201) )
              _assert_fail("cy != 0", "strtod_l.c", 1648, "____strtod_l_internal");
            --v74;
          }
          v73 = v226[v188 - 1];
          v226[v201 - 1] = v73;
          if ( v188 > 0 )
          {
            v78 = &v226[v217 - 1];
            do
            {
              v78[1] = *v78;
              --v78;
            }
            while ( v78 != (int *)&v224 );
          }
          v225 = 0;
          if ( v192 )
            break;
          if ( v74 )
          {
            _BitScanReverse(&v79, v74);
            v80 = v79 ^ 0x1F;
            v182 = v229 - v80;
            v229 = v182;
            if ( 32 - v80 > 53 )
            {
              v213 = v80 + 53;
              v230 = v74 >> (-21 - v80);
              v73 = v226[v201 - 1];
              goto LABEL_204;
            }
            v192 = 32 - v80;
          }
          else
          {
            v229 -= 32LL;
          }
          v231 = 0;
          v230 = v74;
          if ( v192 > 53 )
            goto LABEL_277;
        }
        if ( v192 > 21 )
          break;
        v101 = v230;
        v192 += 32;
        v230 = v74;
        v231 = v101;
      }
      v213 = 53 - v192;
      if ( v192 != 53 )
      {
        _mpn_lshift(&v230, (int)&v230, 2, 53 - v192);
        v230 |= v74 >> (32 - v213);
      }
LABEL_277:
      v73 = v226[v201 - 1];
      v182 = v229;
    }
    else
    {
      v69 = v201 - v68;
      if ( v192 <= 0 )
      {
        v229 -= 32 * v69;
        v213 = 0;
      }
      else
      {
        if ( v192 + 32 * v69 > 53 )
        {
          v213 = 53 - v192;
          if ( 53 - v192 > 31 )
          {
            _mpn_lshift(&v231, (int)&v230, 1, v213 & 0x1F);
            v68 = v232;
            v230 = 0;
          }
          else if ( v213 )
          {
            _mpn_lshift(&v230, (int)&v230, 2, v213);
            v68 = v232;
          }
        }
        else
        {
          if ( v69 != 1 )
            _assert_fail("empty == 1", "strtod_l.c", 1569, "____strtod_l_internal");
          v70 = v230;
          v213 = 0;
          v230 = 0;
          v231 = v70;
        }
        v192 += 32 * v69;
      }
      if ( v68 > 0 )
      {
        v71 = (char *)&v226[v68 - 2];
        do
        {
          *(_DWORD *)&v71[4 * v69 + 4] = *(_DWORD *)v71;
          v71 -= 4;
        }
        while ( v71 != &v224 );
      }
      if ( v69 >= 0 )
      {
        v72 = (int *)&v225;
        do
          *v72++ = 0;
        while ( v72 != &v226[v69] );
      }
      *(&v227 + v201) = 0;
      v73 = v226[v201 - 1];
      if ( v192 <= 53 )
        goto LABEL_189;
      v74 = 0;
      v182 = v229;
    }
LABEL_204:
    if ( v73 || v201 < 0 )
    {
      v82 = ~v201;
    }
    else
    {
      v81 = v201;
      do
        v82 = ~--v81;
      while ( !v226[v81 - 1] && v81 >= 0 );
    }
    return round_and_return_0(
             (unsigned int *)&v230,
             (int)v182 - 1,
             (unsigned __int64)(v182 - 1) >> 32,
             v220,
             v74,
             31 - v213,
             v210 | (v82 >> 31));
  }
  v131 = v227;
  v132 = v228;
  if ( v232 > 1 )
  {
    v133 = v226[0];
    v184 = v225;
    goto LABEL_371;
  }
  v184 = v225;
  v133 = 0;
  if ( v228 <= v225 )
  {
LABEL_371:
    v189 = 0;
    goto LABEL_333;
  }
  if ( v192 <= 0 )
  {
    v229 = v192 - 32LL;
    v189 = 0;
  }
  else
  {
    if ( v192 > 21 )
    {
      v189 = 53 - v192;
      if ( v192 != 53 )
      {
        _mpn_lshift(&v230, (int)&v230, 2, 53 - v192);
        v184 = v225;
      }
    }
    else
    {
      v134 = v230;
      v189 = 0;
      v230 = 0;
      v231 = v134;
    }
    v192 += 32;
  }
  if ( v192 > 53 )
  {
    v125 = 0;
    v133 = v184;
    v184 = 0;
    v193 = v229;
    goto LABEL_345;
  }
  v133 = v184;
  v184 = 0;
LABEL_333:
  v202 = -v131;
  v135 = v192;
  v206 = v131;
  while ( 2 )
  {
    if ( v133 != v132 )
    {
LABEL_335:
      v136 = v206;
      v125 = __PAIR64__(v133, v184) / (unsigned int)v132;
      v137 = __PAIR64__(v133, v184) % (unsigned int)v132;
      v138 = v125 * (unsigned __int64)(unsigned int)v206;
      do
      {
LABEL_336:
        if ( HIDWORD(v138) <= v137 && (!(_DWORD)v138 || HIDWORD(v138) != v137) )
          break;
        --v125;
        v138 -= v136;
        v42 = __CFADD__(v132, v137);
        v137 += v132;
      }
      while ( !v42 );
      v206 = v136;
      v133 = (__PAIR64__(v137, 0) - v138) >> 32;
      v184 = -(int)v138;
      goto LABEL_341;
    }
    while ( 1 )
    {
      v42 = __CFADD__(v184, v133);
      v137 = v184 + v133;
      if ( !v42 )
      {
        v136 = v206;
        v125 = -1;
        HIDWORD(v138) = v206 - (v206 != 0);
        LODWORD(v138) = v202;
        goto LABEL_336;
      }
      v133 = ((unsigned int)v206 + __PAIR64__(v137 - v206, 0)) >> 32;
      v184 = v206;
      v125 = -1;
LABEL_341:
      if ( !v135 )
        break;
      if ( v135 > 21 )
      {
        v189 = 53 - v135;
        if ( v135 != 53 )
        {
          _mpn_lshift(&v230, (int)&v230, 2, 53 - v135);
          v230 |= v125 >> (32 - v189);
        }
LABEL_355:
        v193 = v229;
        goto LABEL_345;
      }
      v142 = v230;
      v135 += 32;
      v230 = v125;
      v231 = v142;
      if ( v133 != v132 )
        goto LABEL_335;
    }
    if ( !v125 )
    {
      v229 -= 32LL;
      goto LABEL_354;
    }
    _BitScanReverse(&v139, v125);
    v140 = v139 ^ 0x1F;
    v193 = v229 - v140;
    v229 = v193;
    if ( 32 - v140 <= 53 )
    {
      v135 = 32 - v140;
LABEL_354:
      v231 = 0;
      v230 = v125;
      if ( v135 > 53 )
        goto LABEL_355;
      continue;
    }
    break;
  }
  v189 = v140 + 53;
  v230 = v125 >> (-21 - v140);
LABEL_345:
  v141 = v133 || v210 || v184 != 0;
  v175 = v141;
  v128 = (unsigned __int64)(v193 - 1) >> 32;
  v127 = v193 - 1;
  v129 = 31 - v189;
  return round_and_return_0((unsigned int *)&v230, v127, v128, v220, v125, v129, v175);
}
// 80482E0: using guessed type int __cdecl strncasecmp_l(_DWORD, _DWORD, _DWORD, _DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80C8380: using guessed type char **nl_C_locobj[6];
// 80CFDC0: using guessed type int dword_80CFDC0[];
// 80DB7A8: using guessed type unsigned int dword_80DB7A8[886];
// 80DE6E0: using guessed type int nbits_9419[16];
// 80B2B30: using guessed type int var_160[37];

//----- (080B5250) --------------------------------------------------------
void __cdecl strtod_l(_BYTE *a1, unsigned int *a2, _DWORD *a3)
{
  ___strtod_l_internal(a1, a2, 0, a3);
}

//----- (080B5280) --------------------------------------------------------
long double __usercall round_and_return_1@<st0>(
        unsigned int *a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        int a4,
        unsigned int a5,
        int a6,
        int a7)
{
  __int64 v8; // rax
  int v9; // esi
  unsigned int v10; // edi
  int v11; // ebp
  long double result; // fst7
  bool v13; // zf
  unsigned int v14; // esi
  int v15; // ecx
  __int64 v16; // kr00_8
  int v17; // eax
  unsigned int v18; // ebp

  v8 = __PAIR64__(a3, a2);
  v9 = a7;
  v10 = a5;
  v11 = a6;
  if ( a3 <= -1 )
  {
    if ( SHIDWORD(v8) >= -1 )
    {
      if ( (unsigned int)v8 >= 0xFFFFC002 )
        goto LABEL_15;
      if ( (unsigned int)v8 >= 0xFFFFBFC2 )
      {
        HIDWORD(v8) = -16382 - v8;
        v9 = ((a5 & ((1 << a6) - 1)) != 0) | a7;
        if ( (_DWORD)v8 == -16446 )
        {
          v10 = a1[1];
          v18 = *a1;
          a1[1] = 0;
          *a1 = 0;
          v13 = v18 == 0;
          v11 = 31;
          v9 |= !v13 || v10 != 0;
        }
        else if ( SHIDWORD(v8) > 31 )
        {
          v17 = (HIDWORD(v8) - 1) >> 5;
          v10 = a1[v17];
          if ( v17 == 1 )
            v9 |= *a1 != 0;
          v11 = (BYTE4(v8) - 1) & 0x1F;
          v9 |= (((1 << v11) - 1) & v10) != 0;
          _mpn_rshift((int)a1, a1 + 1, 1, BYTE4(v8) & 0x1F);
          a1[1] = 0;
        }
        else
        {
          v10 = *a1;
          v11 = HIDWORD(v8) - 1;
          _mpn_rshift((int)a1, a1, 2, SBYTE4(v8));
        }
        __writegsdword(0xFFFFFFE8, 0x22u);
        v8 = -16383LL;
        goto LABEL_13;
      }
    }
    result = 0.0;
    __writegsdword(0xFFFFFFE8, 0x22u);
    return result;
  }
LABEL_15:
  if ( v8 <= 0x4000 )
  {
LABEL_13:
    if ( !_bittest((const int *)&v10, v11) )
      return _mpn_construct_long_double(a1, v8, a4);
    v13 = v9 == 0;
    v14 = *a1;
    if ( v13 && (v14 & 1) == 0 && (v10 & ((1 << v11) - 1)) == 0 )
      return _mpn_construct_long_double(a1, v8, a4);
    *a1 = v14 + 1;
    if ( v14 <= v14 + 1 || (v15 = a1[1] + 1, (a1[1] = v15) != 0) )
    {
      if ( !((unsigned int)v8 ^ 0xFFFFC001 | ~HIDWORD(v8)) )
        LODWORD(v8) = -((int)a1[1] >> 31) - 0x3FFF;
      return _mpn_construct_long_double(a1, v8, a4);
    }
    v16 = v8 + 1;
    _mpn_rshift((int)a1, a1, 2, 1);
    a1[1] |= 0x80000000;
    if ( v16 != 16385 )
    {
      LOWORD(v8) = v16;
      return _mpn_construct_long_double(a1, v8, a4);
    }
  }
  if ( a4 )
    return -INFINITY;
  else
    return INFINITY;
}
// 80B52F8: conditional instruction was optimized away because edx.4==FFFFFFFF
// 80B53A8: conditional instruction was optimized away because edx.4==FFFFFFFF

//----- (080B5520) --------------------------------------------------------
_BYTE *__usercall str_to_mpn_isra_0_1@<eax>(
        _BYTE *a1@<eax>,
        int a2@<edx>,
        unsigned int *a3@<ecx>,
        int *a4,
        __int64 *a5,
        int a6,
        _BYTE *a7)
{
  int v8; // edi
  int v9; // ebp
  char v10; // al
  bool v11; // zf
  int v12; // ecx
  unsigned int v13; // eax
  _BYTE *result; // eax
  char v15; // al
  int v16; // eax
  char v17; // dl
  int v18; // ecx
  int v19; // eax
  int v20; // edx
  int v21; // ebp
  unsigned int v22; // ecx
  unsigned int v23; // edi
  int v24; // eax
  int *v25; // edi
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // edx
  int v30; // esi
  unsigned int v31; // ecx
  unsigned int v32; // edi
  int v33; // eax
  int *v34; // edi
  int v35; // eax
  int v36; // eax
  int v37; // edx
  int v38; // [esp+10h] [ebp-2Ch]
  int v40; // [esp+18h] [ebp-24h]
  int v41; // [esp+1Ch] [ebp-20h]

  v38 = a2;
  *a4 = 0;
  if ( a2 <= 0 )
    _assert_fail("digcnt > 0", &unk_80DE720, 294, "str_to_mpn");
  v40 = 0;
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    v10 = *a1;
    if ( (unsigned __int8)(*a1 - 48) <= 9u )
      goto LABEL_7;
    if ( !a7 || v10 != *a7 )
    {
LABEL_6:
      a1 += a6;
      v10 = *a1;
      goto LABEL_7;
    }
    v15 = a7[1];
    if ( v15 )
    {
      if ( a1[1] != v15 )
        goto LABEL_6;
      v16 = 1;
      while ( 1 )
      {
        v17 = a7[++v16];
        v18 = v16;
        if ( !v17 )
          break;
        if ( a1[v16] != v17 )
          goto LABEL_6;
      }
    }
    else
    {
      v18 = 1;
    }
    a1 += v18;
    v10 = *a1;
LABEL_7:
    ++a1;
    v11 = v38-- == 1;
    v8 = v10 + 10 * v8 - 48;
    v12 = v9 + 1;
    if ( v11 )
      break;
    if ( v9 == 8 )
    {
      if ( v40 )
      {
        v19 = _mpn_mul_1((int)a3, (int)a3, v40, 0x3B9ACA00u);
        v20 = *a4;
        v21 = v19;
        v22 = *a3;
        v23 = *a3 + v8;
        *a3 = v23;
        v24 = 0;
        if ( v22 > v23 )
        {
          v25 = (int *)(a3 + 1);
          while ( --v20 )
          {
            v26 = *v25 + 1;
            *v25++ = v26;
            if ( v26 )
            {
              v24 = 0;
              goto LABEL_27;
            }
          }
          v24 = 1;
        }
LABEL_27:
        v27 = v21 + v24;
        if ( v27 )
        {
          if ( *a4 > 517 )
            _assert_fail("*nsize < ((((16384 + 2 * 64) + ((32) - 1)) / (32)) + 2)", &unk_80DE720, 311, "str_to_mpn");
          v8 = 0;
          a3[*a4] = v27;
          v9 = 0;
          v40 = *a4 + 1;
          *a4 = v40;
        }
        else
        {
          v8 = 0;
          v9 = 0;
          v40 = *a4;
        }
      }
      else
      {
        v40 = 1;
        *a3 = v8;
        v8 = 0;
        *a4 = 1;
        v9 = 0;
      }
    }
    else
    {
      ++v9;
    }
  }
  v41 = *(_DWORD *)a5;
  if ( *a5 <= 0 || *a5 > 8 - v9 )
  {
    v13 = tens_in_limb[v12];
    if ( v40 )
      goto LABEL_31;
    goto LABEL_14;
  }
  v8 *= tens_in_limb[v41];
  v13 = tens_in_limb[v41 + v12];
  *(_DWORD *)a5 = 0;
  *((_DWORD *)a5 + 1) = 0;
  if ( !v40 )
  {
LABEL_14:
    *a3 = v8;
    *a4 = 1;
    return a1;
  }
LABEL_31:
  v28 = _mpn_mul_1((int)a3, (int)a3, v40, v13);
  v29 = *a4;
  v30 = v28;
  v31 = *a3;
  v32 = *a3 + v8;
  *a3 = v32;
  v33 = 0;
  if ( v31 > v32 )
  {
    v34 = (int *)(a3 + 1);
    while ( --v29 )
    {
      v35 = *v34 + 1;
      *v34++ = v35;
      if ( v35 )
      {
        v33 = 0;
        goto LABEL_36;
      }
    }
    v33 = 1;
  }
LABEL_36:
  v36 = v30 + v33;
  if ( !v36 )
    return a1;
  v37 = *a4;
  if ( *a4 > 517 )
    _assert_fail("*nsize < ((((16384 + 2 * 64) + ((32) - 1)) / (32)) + 2)", &unk_80DE720, 367, "str_to_mpn");
  a3[v37] = v36;
  result = a1;
  *a4 = v37 + 1;
  return result;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80DE7E0: using guessed type int tens_in_limb[10];

//----- (080B5880) --------------------------------------------------------
long double __cdecl ___strtold_l_internal(_BYTE *a1, unsigned int *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // eax
  _BYTE *v5; // ebp
  _BYTE *i; // eax
  char v7; // bl
  _BYTE *v8; // esi
  char v9; // dl
  int v10; // eax
  char v11; // cl
  int v12; // edi
  char v13; // al
  int v14; // edi
  _BYTE *v15; // eax
  int v16; // eax
  char v17; // cl
  _BYTE *k; // eax
  int v19; // eax
  char v20; // dl
  int v21; // eax
  int v22; // esi
  char v23; // dl
  _BYTE *m; // ebx
  char v25; // cl
  _BYTE *v26; // eax
  unsigned int v27; // edx
  _BYTE *v28; // eax
  char v29; // si
  char v30; // bl
  int v31; // edx
  char v32; // cl
  unsigned __int64 v33; // rcx
  __int64 v34; // rcx
  signed __int64 v35; // rax
  __int64 v36; // rcx
  long double result; // fst7
  char v38; // al
  unsigned int v39; // eax
  int v40; // edi
  bool v41; // cf
  int v42; // esi
  int v43; // edi
  __int64 v44; // rcx
  __int64 v45; // rax
  unsigned int v46; // esi
  _BYTE *v47; // ebp
  unsigned int v48; // ebx
  char v49; // cl
  _BYTE *v50; // eax
  unsigned int v51; // eax
  _BYTE *v52; // edx
  unsigned int v53; // ecx
  int *v54; // edx
  int v55; // edi
  _DWORD *v56; // esi
  int v57; // ebx
  int v58; // ebp
  int v59; // eax
  unsigned int v60; // ebx
  signed int v61; // ebx
  int v62; // eax
  unsigned int v63; // ebp
  unsigned int v64; // ebx
  int v65; // eax
  int v66; // ecx
  int v67; // esi
  int v68; // eax
  int *v69; // eax
  _QWORD *v70; // eax
  int v71; // edi
  int v72; // ecx
  unsigned int v73; // esi
  unsigned __int64 v74; // rtt
  unsigned int v75; // ecx
  unsigned __int64 ii; // rax
  int *v77; // eax
  unsigned int v78; // edi
  signed int v79; // edi
  int v80; // edx
  unsigned int v81; // eax
  _BYTE *v82; // ecx
  _BYTE *v83; // ebx
  _BYTE *v84; // esi
  char v85; // al
  int v86; // edi
  int v87; // edx
  char *v88; // ecx
  char *v89; // edx
  int v90; // eax
  char *v91; // esi
  int v92; // ebp
  __int64 v93; // rcx
  int v94; // ebx
  int v95; // eax
  int v96; // ecx
  unsigned int v97; // edx
  char v98; // cl
  unsigned int v99; // edx
  _BYTE *v100; // eax
  unsigned int v101; // esi
  unsigned int v102; // edi
  __int64 v104; // rcx
  unsigned int v105; // ebp
  unsigned int v106; // ecx
  unsigned __int64 v107; // rdi
  unsigned int v108; // ebx
  unsigned __int64 v109; // rax
  unsigned int v110; // eax
  __int64 v111; // rax
  int v112; // eax
  unsigned int v113; // edx
  int v114; // ecx
  int v115; // esi
  int n; // ecx
  unsigned int v117; // eax
  int v118; // edx
  unsigned __int64 v119; // rtt
  unsigned int v120; // edi
  unsigned int v121; // ebp
  unsigned int v122; // edi
  int v123; // edx
  char *v124; // eax
  int v125; // ecx
  int v126; // ebx
  _DWORD *v127; // esi
  int v128; // edi
  unsigned int *v129; // ebp
  int v130; // eax
  int *v131; // eax
  int v132; // edx
  int v133; // edx
  int v134; // eax
  int *v135; // eax
  unsigned int v136; // eax
  int v137; // eax
  int v138; // edi
  int v139; // ebx
  unsigned int v140; // edi
  unsigned int *v141; // eax
  int v142; // eax
  int v143; // eax
  int v144; // eax
  __int64 v145; // rdi
  int *v146; // eax
  int v147; // eax
  signed int v148; // edx
  int v149; // esi
  int v150; // eax
  unsigned int v151; // edx
  int v152; // esi
  _BYTE *j; // ebx
  char v154; // al
  __int64 v155; // rax
  int v156; // esi
  int v157; // eax
  _BYTE *v158; // eax
  int v159; // ecx
  int v160; // eax
  char v161; // cl
  int v162; // eax
  int v163; // ecx
  unsigned int v164; // ecx
  unsigned int v165; // esi
  int *v166; // [esp+28h] [ebp-10E4h]
  int *v167; // [esp+28h] [ebp-10E4h]
  int v168; // [esp+28h] [ebp-10E4h]
  unsigned int v169; // [esp+28h] [ebp-10E4h]
  unsigned int v170; // [esp+2Ch] [ebp-10E0h]
  int *v171; // [esp+2Ch] [ebp-10E0h]
  int v172; // [esp+2Ch] [ebp-10E0h]
  char v173; // [esp+2Ch] [ebp-10E0h]
  _BYTE *v174; // [esp+30h] [ebp-10DCh]
  _BYTE *v175; // [esp+30h] [ebp-10DCh]
  signed int v176; // [esp+30h] [ebp-10DCh]
  __int64 v177; // [esp+30h] [ebp-10DCh]
  __int64 v178; // [esp+30h] [ebp-10DCh]
  unsigned int v179; // [esp+30h] [ebp-10DCh]
  int *v180; // [esp+30h] [ebp-10DCh]
  _BYTE *v181; // [esp+38h] [ebp-10D4h]
  int v182; // [esp+38h] [ebp-10D4h]
  signed int v183; // [esp+38h] [ebp-10D4h]
  unsigned int v184; // [esp+38h] [ebp-10D4h]
  char *v185; // [esp+40h] [ebp-10CCh]
  _BYTE *v186; // [esp+40h] [ebp-10CCh]
  _BYTE *v187; // [esp+40h] [ebp-10CCh]
  __int64 v188; // [esp+40h] [ebp-10CCh]
  int v189; // [esp+40h] [ebp-10CCh]
  unsigned int v190; // [esp+48h] [ebp-10C4h]
  int v191; // [esp+48h] [ebp-10C4h]
  int v192; // [esp+48h] [ebp-10C4h]
  unsigned int v193; // [esp+48h] [ebp-10C4h]
  int v194; // [esp+4Ch] [ebp-10C0h]
  unsigned int v195; // [esp+50h] [ebp-10BCh]
  char *v196; // [esp+54h] [ebp-10B8h]
  int v197; // [esp+54h] [ebp-10B8h]
  unsigned int *v198; // [esp+54h] [ebp-10B8h]
  char v199; // [esp+58h] [ebp-10B4h]
  __int64 v200; // [esp+58h] [ebp-10B4h]
  char *v201; // [esp+60h] [ebp-10ACh]
  int v202; // [esp+60h] [ebp-10ACh]
  int v203; // [esp+64h] [ebp-10A8h]
  unsigned int v204; // [esp+64h] [ebp-10A8h]
  int v205; // [esp+68h] [ebp-10A4h]
  int v206; // [esp+68h] [ebp-10A4h]
  __int64 v207; // [esp+68h] [ebp-10A4h]
  int v208; // [esp+68h] [ebp-10A4h]
  int v209; // [esp+70h] [ebp-109Ch]
  bool v210; // [esp+77h] [ebp-1095h]
  int v211; // [esp+80h] [ebp-108Ch]
  _BYTE *v212; // [esp+8Ch] [ebp-1080h] BYREF
  _QWORD v213[259]; // [esp+90h] [ebp-107Ch] BYREF
  unsigned int v214; // [esp+8A8h] [ebp-864h] BYREF
  unsigned int v215; // [esp+8ACh] [ebp-860h]
  long double v216; // [esp+10C0h] [ebp-4Ch]
  __int64 v217; // [esp+10D8h] [ebp-34h] BYREF
  int v218; // [esp+10E0h] [ebp-2Ch] BYREF
  int v219; // [esp+10E4h] [ebp-28h] BYREF
  int v220; // [esp+10E8h] [ebp-24h] BYREF
  char *v221; // [esp+10ECh] [ebp-20h] BYREF
  unsigned int v222; // [esp+1110h] [ebp+4h]

  v4 = (_DWORD *)a4[1];
  if ( !a3 || (v185 = (char *)v4[11], (unsigned __int8)(*v185 - 1) > 0x7Du) || (v201 = (char *)v4[10], !*v201) )
  {
    v185 = 0;
    v201 = 0;
  }
  v5 = (_BYTE *)v4[9];
  v203 = strlen(v5);
  if ( !v203 )
    _assert_fail("decimal_len > 0", &unk_80DE720, 514, "____strtold_l_internal");
  v217 = 0LL;
  for ( i = a1 - 1; ; ++i )
  {
    v7 = i[1];
    v8 = i + 1;
    if ( (*(_BYTE *)(a4[13] + 2 * v7 + 1) & 0x20) == 0 )
      break;
  }
  if ( v7 == 45 )
  {
    v8 = i + 2;
    v7 = i[2];
    v209 = 1;
  }
  else
  {
    v209 = 0;
    if ( v7 == 43 )
    {
      v8 = i + 2;
      v7 = i[2];
    }
  }
  v9 = *v5;
  if ( !*v5 )
  {
    v12 = 0;
    goto LABEL_15;
  }
  v10 = 0;
  if ( v9 == *v8 )
  {
    while ( 1 )
    {
      v11 = v5[++v10];
      v12 = v10;
      if ( !v11 )
        break;
      if ( v11 != v8[v10] )
        goto LABEL_91;
    }
LABEL_15:
    v13 = v8[v12];
    if ( v13 > 47 && v13 <= 57 )
      goto LABEL_17;
  }
LABEL_91:
  if ( (unsigned __int8)(v7 - 48) > 9u )
  {
    v38 = dword_80CFDC0[v7];
    if ( v38 != 105 )
    {
      if ( v38 == 110 && !strncasecmp_l(v8, &unk_80C9C98, 3, nl_C_locobj) )
      {
        v82 = v8 + 3;
        if ( v8[3] != 40 )
          goto LABEL_218;
        for ( j = v8 + 3; ; ++j )
        {
          v154 = j[1];
          if ( (unsigned __int8)(v154 - 48) > 9u
            && (unsigned __int8)(*(_BYTE *)(a4[14] + 4 * v154) - 97) > 0x19u
            && v154 != 95 )
          {
            break;
          }
        }
        if ( v154 == 41 )
        {
          v155 = ___strtoull_l_internal(v8 + 4, &v221, 0, 0, a4);
          if ( v221 == j + 1 )
          {
            v164 = 0;
            v165 = -1073741824;
            *(_QWORD *)&v216 = 0xC000000000000000LL;
            HIDWORD(v216) = 0x7FFF;
            if ( (unsigned int)v155 | HIDWORD(v155) & 0x7FFFFFFF )
            {
              v164 = v155;
              v165 = HIDWORD(v155) | 0x80000000;
            }
            *(_QWORD *)&v216 = __PAIR64__(v165, v164);
            result = v216;
          }
          else
          {
            result = NAN;
          }
          v82 = j + 2;
        }
        else
        {
LABEL_218:
          result = NAN;
        }
        if ( a2 )
          *a2 = (unsigned int)v82;
        return result;
      }
      goto LABEL_94;
    }
    if ( strncasecmp_l(v8, &unk_80C9C94, 3, nl_C_locobj) )
    {
LABEL_94:
      if ( a2 )
      {
        result = 0.0;
        *a2 = (unsigned int)a1;
        return result;
      }
      return 0.0;
    }
    if ( a2 )
    {
      v83 = v8 + 3;
      v84 = v8 + 8;
      if ( !strncasecmp_l(v83, "inity", 5, nl_C_locobj) )
        v83 = v84;
      *a2 = (unsigned int)v83;
    }
LABEL_226:
    if ( !v209 )
      return INFINITY;
    return -INFINITY;
  }
LABEL_17:
  if ( v7 == 48 )
  {
    v194 = 10;
    v14 = a4[14];
    if ( *(_DWORD *)(v14 + 4 * (char)v8[1]) == 120 )
    {
      v7 = v8[2];
      v8 += 2;
      v185 = 0;
      v194 = 16;
    }
  }
  else
  {
    v194 = 10;
    v14 = a4[14];
  }
  if ( v201 )
  {
    v181 = v8;
    v173 = *v201;
    while ( 1 )
    {
      if ( v7 != 48 )
      {
        if ( v173 )
        {
          if ( *v181 != v173 )
            goto LABEL_24;
          v160 = 0;
          while ( 1 )
          {
            v161 = v201[++v160];
            if ( !v161 )
              break;
            if ( v161 != v181[v160] )
              goto LABEL_24;
          }
          v162 = v160 - 1;
        }
        else
        {
          v162 = -1;
        }
        v181 += v162;
      }
      v7 = *++v181;
    }
  }
  v181 = v8;
  if ( v7 == 48 )
  {
    v15 = v8;
    do
      v7 = *++v15;
    while ( *v15 == 48 );
    v181 = v15;
  }
LABEL_24:
  v170 = 0;
  v174 = v181;
  v205 = *(_DWORD *)(v14 + 4 * v7);
  if ( (unsigned __int8)(v7 - 48) <= 9u || (char)v205 > 96 && v194 == 16 && (char)v205 <= 102 )
    goto LABEL_34;
  if ( !v9 )
  {
LABEL_31:
    if ( v8 != v181 || v194 != 16 )
    {
      v170 = 0;
      k = v181;
      goto LABEL_35;
    }
    v170 = 0;
    v174 = v181;
    if ( (unsigned __int8)(v181[v203] - 48) <= 9u
      || (unsigned __int8)(*(_BYTE *)(v14 + 4 * (char)v181[v203]) - 97) <= 5u )
    {
      goto LABEL_34;
    }
    goto LABEL_108;
  }
  if ( *v181 == v9 )
  {
    v16 = 0;
    do
    {
      v17 = v5[++v16];
      if ( !v17 )
        goto LABEL_31;
    }
    while ( v17 == v181[v16] );
  }
  if ( v194 != 16 || v8 == v181 || (v170 = 0, v174 = v181, (_BYTE)v205 != 112) )
  {
LABEL_108:
    if ( (_BYTE)v205 != 101 || (v170 = 0, v174 = v181, v194 == 16) )
    {
      v39 = _correctly_grouped_prefixmb((unsigned int)v8, (unsigned int)v181, v201, v185);
      if ( a2 )
      {
        if ( v8 == (_BYTE *)v39 )
        {
          v158 = v181 - 1;
          if ( v194 != 16 )
            v158 = a1;
          v222 = (unsigned int)v158;
        }
        else
        {
          v222 = v39;
        }
        *a2 = v222;
      }
      goto LABEL_114;
    }
  }
LABEL_34:
  for ( k = v174; ; ++k )
  {
LABEL_35:
    if ( (unsigned __int8)(v7 - 48) <= 9u || v194 == 16 && (unsigned __int8)(*(_BYTE *)(v14 + 4 * v7) - 97) <= 5u )
    {
      ++v170;
      goto LABEL_99;
    }
    if ( !v201 )
      goto LABEL_38;
    if ( *v201 )
      break;
    v163 = -1;
LABEL_465:
    k += v163;
LABEL_99:
    v7 = k[1];
  }
  if ( *v201 == *k )
  {
    v159 = 0;
    while ( v201[++v159] )
    {
      if ( v201[v159] != k[v159] )
        goto LABEL_38;
    }
    v163 = v159 - 1;
    goto LABEL_465;
  }
LABEL_38:
  v175 = k;
  if ( v8 < k && v185 )
  {
    v51 = _correctly_grouped_prefixmb((unsigned int)v8, (unsigned int)k, v201, v185);
    if ( (_BYTE *)v51 != v175 )
    {
      if ( v8 != (_BYTE *)v51 )
      {
        if ( (unsigned int)v181 > v51 )
        {
          if ( a2 )
            *a2 = v51;
          goto LABEL_114;
        }
        v52 = v181;
        v190 = 0;
        if ( (unsigned int)v181 >= v51 )
        {
          v186 = (_BYTE *)v51;
          v206 = 0;
          v170 = 0;
        }
        else
        {
          v53 = 0;
          do
            v53 += (unsigned __int8)(*v52++ - 48) < 0xAu;
          while ( v52 != (_BYTE *)v51 );
          v190 = v53;
          v170 = v53;
          v186 = v52;
          v206 = 0;
        }
        goto LABEL_65;
      }
      if ( a2 )
      {
        result = 0.0;
        *a2 = (unsigned int)a1;
        return result;
      }
      return 0.0;
    }
    v9 = *v5;
    v14 = a4[14];
  }
  v206 = -(v170 == 0);
  if ( v9 )
  {
    v19 = 0;
    if ( *v175 == v9 )
    {
      while ( 1 )
      {
        v20 = v5[++v19];
        if ( !v20 )
          goto LABEL_44;
        if ( v20 != v175[v19] )
        {
          v25 = *(_BYTE *)(v14 + 4 * v7);
          v190 = v170;
          goto LABEL_117;
        }
      }
    }
    v25 = *(_BYTE *)(v14 + 4 * v7);
    v190 = v170;
  }
  else
  {
LABEL_44:
    v21 = 0;
    v22 = -(v170 == 0);
    v23 = v175[v203];
    for ( m = &v175[v203]; ; v23 = *m )
    {
      if ( (unsigned __int8)(v23 - 48) > 9u )
      {
        if ( v194 != 16 )
        {
          v190 = v21 + v170;
          v206 = v22;
          v175 = m;
          v25 = *(_BYTE *)(v14 + 4 * v23);
          v210 = 0;
          goto LABEL_53;
        }
        if ( (unsigned __int8)(*(_BYTE *)(v14 + 4 * v23) - 97) > 5u )
          break;
      }
      if ( v22 == -1 && v23 != 48 )
        v22 = v21;
      ++m;
      ++v21;
    }
    v190 = v21 + v170;
    v206 = v22;
    v25 = *(_BYTE *)(v14 + 4 * v23);
    v175 = m;
  }
LABEL_117:
  v210 = v194 == 16;
  if ( v25 == 112 && v194 == 16 )
  {
    v210 = 1;
  }
  else
  {
LABEL_53:
    if ( v25 != 101 || v194 == 16 )
    {
      v186 = v175;
      goto LABEL_56;
    }
  }
  v199 = v175[1];
  if ( v199 == 45 )
  {
    v211 = 1;
    v187 = v175 + 2;
    v199 = v175[2];
  }
  else
  {
    v211 = 0;
    if ( v199 == 43 )
    {
      v187 = v175 + 2;
      v199 = v175[2];
    }
    else
    {
      v187 = v175 + 1;
    }
  }
  if ( (unsigned __int8)(v199 - 48) > 9u )
  {
    v186 = v175;
    goto LABEL_56;
  }
  if ( v210 )
  {
    if ( v211 )
    {
      v40 = (unsigned __int64)v170 >> 30;
      v41 = __CFADD__(4 * v170, 16445);
      v42 = 4 * v170 + 16445;
LABEL_127:
      v43 = v41 + v40;
      goto LABEL_128;
    }
    if ( v170 )
    {
      if ( v206 )
        _assert_fail(
          "lead_zero == 0 && int_no <= (uintmax_t) (9223372036854775807LL) / 4",
          &unk_80DE720,
          860,
          "____strtold_l_internal");
      v43 = (4 * (4096 - (unsigned __int64)v170) + 3) >> 32;
      v42 = 4 * (4096 - v170) + 3;
    }
    else
    {
      v43 = 0;
      v44 = 1638LL;
      v42 = 16387;
      if ( v206 == -1 )
        goto LABEL_129;
      v43 = (4 * (unsigned __int64)(unsigned int)v206 + 16387) >> 32;
      v42 = 4 * v206 + 16387;
    }
LABEL_262:
    if ( v43 < 0 )
    {
      v44 = 0LL;
      v42 = 0;
      v43 = 0;
      goto LABEL_129;
    }
LABEL_128:
    v44 = __SPAIR64__(v43, v42) / 10;
    goto LABEL_129;
  }
  if ( v211 )
  {
    v40 = 0;
    v41 = __CFADD__(v170, 4995);
    v42 = v170 + 4995;
    goto LABEL_127;
  }
  if ( v170 )
  {
    if ( v206 )
      _assert_fail(
        "lead_zero == 0 && int_no <= (uintmax_t) (9223372036854775807LL)",
        &unk_80DE720,
        892,
        "____strtold_l_internal");
    v43 = (4933 - (unsigned __int64)v170) >> 32;
    v42 = 4933 - v170;
    goto LABEL_262;
  }
  v43 = 0;
  v44 = 493LL;
  v42 = 4933;
  if ( v206 != -1 )
  {
    v43 = ((unsigned __int64)(unsigned int)v206 + 4933) >> 32;
    v42 = v206 + 4933;
    goto LABEL_262;
  }
LABEL_129:
  v45 = __SPAIR64__(v43, v42) % 10;
  v212 = v5;
  v46 = HIDWORD(v217);
  v47 = v187;
  v188 = v44;
  v48 = v217;
  v49 = v199;
  while ( 2 )
  {
    if ( v188 < __SPAIR64__(v46, v48) )
    {
LABEL_131:
      if ( v206 == -1 )
      {
        result = 0.0;
        if ( v209 )
        {
          result = -0.0;
          v50 = v47;
          goto LABEL_135;
        }
      }
      else
      {
        __writegsdword(0xFFFFFFE8, 0x22u);
        if ( v211 )
        {
          result = 0.0;
          if ( v209 )
          {
            v50 = v47;
            result = -0.0;
            goto LABEL_135;
          }
        }
        else
        {
          if ( v209 )
          {
            result = -INFINITY;
            v50 = v47;
            do
LABEL_135:
              ++v50;
            while ( (unsigned __int8)(*v50 - 48) <= 9u );
            if ( a2 )
              *a2 = (unsigned int)v50;
            return result;
          }
          result = INFINITY;
        }
      }
      v50 = v47;
      goto LABEL_135;
    }
    if ( v188 == __PAIR64__(v46, v48) )
    {
      v200 = v49 - 48;
      if ( v200 > v45 )
        goto LABEL_131;
    }
    else
    {
      v200 = v49 - 48;
    }
    v46 = (v200 + __PAIR64__(10 * v46 + ((10 * (unsigned __int64)v48) >> 32), 10 * v48)) >> 32;
    v48 = v200 + 10 * v48;
    ++v47;
    v217 = __PAIR64__(v46, v48);
    v49 = *v47;
    if ( (unsigned __int8)(*v47 - 48) <= 9u )
      continue;
    break;
  }
  v186 = v47;
  v5 = v212;
  if ( v211 )
    v217 = -__SPAIR64__(v46, v48);
LABEL_56:
  v26 = v175;
  if ( v190 > v170 )
  {
    if ( *(v175 - 1) == 48 )
    {
      v27 = v190;
      do
      {
        --v26;
        --v27;
      }
      while ( *(v26 - 1) == 48 );
      v190 = v27;
    }
    if ( v190 < v170 )
      _assert_fail("dig_no >= int_no", &unk_80DE720, 967, "____strtold_l_internal");
  }
  if ( v190 && v190 == v170 && v217 < 0 )
  {
    v100 = v26 - 1;
    v101 = v190;
    v102 = v170;
    while ( 1 )
    {
      if ( !(v210 ? (*(_BYTE *)(a4[13] + 2 * (char)*v100 + 1) & 0x10) == 0 : (unsigned int)((char)*v100 - 48) > 9) )
      {
        if ( *v100 != 48 )
          break;
        --v101;
        --v102;
        v104 = 4LL;
        if ( !v210 )
          v104 = 1LL;
        v217 += v104;
        if ( v217 >= 0 || !v101 )
          break;
      }
      --v100;
    }
    v190 = v101;
    v170 = v102;
  }
LABEL_65:
  if ( a2 )
    *a2 = (unsigned int)v186;
  if ( !v190 )
    goto LABEL_114;
  v196 = v181;
  if ( !v206 )
    goto LABEL_84;
  v28 = v181;
  v29 = v5[1];
  v30 = *v181;
  while ( 2 )
  {
    if ( *v5 != v30 )
    {
      v30 = v28[1];
LABEL_71:
      ++v28;
      continue;
    }
    break;
  }
  if ( !v29 )
    goto LABEL_78;
  v30 = v28[1];
  v31 = 1;
  if ( v30 != v29 )
    goto LABEL_71;
  while ( 1 )
  {
    v32 = v5[++v31];
    if ( !v32 )
      break;
    if ( v32 != v28[v31] )
      goto LABEL_71;
  }
LABEL_78:
  v33 = v217 + 0x8000000000000000LL;
  if ( v194 == 16 )
    v33 >>= 2;
  if ( v33 < (unsigned int)v206 )
    _assert_fail(
      "lead_zero <= (base == 16 ? ((uintmax_t) exponent - (uintmax_t) (-9223372036854775807LL-1)) / 4 : ((uintmax_t) expo"
      "nent - (uintmax_t) (-9223372036854775807LL-1)))",
      &unk_80DE720,
      1022,
      "____strtold_l_internal");
  v34 = (unsigned int)v206;
  if ( v194 == 16 )
    v34 = 4LL * (unsigned int)v206;
  v190 -= v206;
  v196 = &v28[v203 + v206];
  v217 -= v34;
LABEL_84:
  if ( v194 == 16 )
  {
    v85 = *v196;
    v86 = a4[13];
    v87 = *v196;
    if ( (*(_BYTE *)(v86 + 2 * v87 + 1) & 0x10) == 0 )
    {
      v88 = v196;
      do
      {
        v85 = *++v88;
        v87 = *v88;
      }
      while ( (*(_BYTE *)(v86 + 2 * v87 + 1) & 0x10) == 0 );
      v196 = v88;
    }
    if ( v85 == 48 )
    {
      v89 = v196;
      do
        ++v89;
      while ( *v89 == 48 );
      v196 = v89;
      v87 = *v89;
    }
    v90 = v87 - 48;
    v91 = v196 + 1;
    if ( (unsigned int)(v87 - 48) > 9 )
      v90 = *(_DWORD *)(a4[14] + 4 * v87) - 87;
    v92 = nbits_9419_0[v90];
    if ( !v92 )
      _assert_fail("bits != 0", &unk_80DE720, 1046, "____strtold_l_internal");
    v219 = v90 << (32 - v92);
    if ( v217 < 0 )
      v93 = 0x8000000000000000LL - v92;
    else
      v93 = 0x7FFFFFFFFFFFFFFFLL - v217 - v92 + 1;
    if ( v170 > (unsigned __int64)(v93 / 4) )
      _assert_fail(
        "int_no <= (uintmax_t) (exponent < 0 ? ((9223372036854775807LL) - bits + 1) / 4 : ((9223372036854775807LL) - expo"
        "nent - bits + 1) / 4)",
        &unk_80DE720,
        1067,
        "____strtold_l_internal");
    v94 = 31 - v92;
    v95 = 1;
    v217 += 4 * (v170 - 1LL) + v92 - 1;
    while ( --v190 )
    {
      while ( 1 )
      {
        v96 = *v91;
        if ( (*(_BYTE *)(v86 + 2 * v96 + 1) & 0x10) == 0 )
        {
          v91 += v203;
          v96 = *v91;
        }
        v97 = v96 - 48;
        ++v91;
        if ( (unsigned int)(v96 - 48) > 9 )
          v97 = *(_DWORD *)(a4[14] + 4 * v96) - 87;
        if ( v94 <= 2 )
          break;
        v98 = v94 - 3;
        v94 -= 4;
        *(&v218 + v95) |= v97 << v98;
        if ( !--v190 )
          goto LABEL_254;
      }
      *(&v218 + v95) |= v97 >> (3 - v94);
      v99 = v97 << (v94 + 29);
      if ( !v95 )
        return round_and_return_1((unsigned int *)&v218, v217, SHIDWORD(v217), v209, v99, 31, 1);
      v218 = v99;
      v94 += 28;
      v95 = 0;
    }
LABEL_254:
    if ( v95 == 1 )
      v218 = 0;
    return round_and_return_1((unsigned int *)&v218, v217, SHIDWORD(v217), v209, 0, 0, 0);
  }
  if ( v217 < 0 )
  {
    v35 = -(__int64)v170;
    if ( v35 < v217 )
      goto LABEL_87;
  }
  else
  {
    v35 = v190 - (unsigned __int64)v170;
    if ( v35 > v217 )
LABEL_87:
      v35 = v217;
  }
  v36 = v217 - v35;
  v207 = (unsigned int)v35 + v170;
  v182 = v35 + v170;
  v217 -= v35;
  if ( v36 > 4933LL - ((unsigned int)v35 + v170) )
  {
    __writegsdword(0xFFFFFFE8, 0x22u);
    if ( !v209 )
      return INFINITY;
    return -INFINITY;
  }
  if ( v36 < -4950 )
  {
    __writegsdword(0xFFFFFFE8, 0x22u);
LABEL_114:
    result = 0.0;
    if ( v209 )
      return -0.0;
    return result;
  }
  v176 = 0;
  if ( (_DWORD)v207 )
  {
    v124 = str_to_mpn_isra_0_1(v196, v207, (unsigned int *)v213, &v220, &v217, v203, v201);
    v125 = HIDWORD(v217);
    v172 = v217;
    v196 = v124;
    if ( v217 > 0 )
    {
      v126 = v220;
      v127 = &fpioconst_pow10;
      v128 = 1;
      v180 = (int *)&v214;
      v129 = (unsigned int *)v213;
      do
      {
        if ( v128 & v172 | v125 & (v128 >> 31) )
        {
          v132 = v127[1] - 2;
          LODWORD(v217) = v128 ^ v172;
          HIDWORD(v217) = (v128 >> 31) ^ v125;
          v168 = v132;
          if ( v132 <= v126 )
            v130 = _mpn_mul(v180, v129, v126, &dword_80DB7A8[*v127], v132);
          else
            v130 = _mpn_mul(v180, &dword_80DB7A8[*v127], v132, v129, v126);
          v126 = v168 + v220;
          v220 += v168;
          if ( v130 )
          {
            v125 = HIDWORD(v217);
            v172 = v217;
            v131 = (int *)v129;
            v129 = (unsigned int *)v180;
            v180 = v131;
          }
          else
          {
            v146 = (int *)v129;
            --v126;
            v129 = (unsigned int *)v180;
            v220 = v126;
            v125 = HIDWORD(v217);
            v180 = v146;
            v172 = v217;
          }
        }
        v128 *= 2;
        v127 += 4;
      }
      while ( v125 | v172 );
      if ( v129 == &v214 )
        memcpy(v213, v129, 4 * v126);
    }
    else
    {
      v126 = v220;
    }
    _BitScanReverse(&v136, *((_DWORD *)v213 + v126 - 1));
    v176 = 32 * v126 - (v136 ^ 0x1F);
    if ( v176 <= 0x4000 )
    {
      if ( v176 > 64 )
      {
        v137 = (v176 - 64) >> 5;
        v138 = (v176 - 64) & 0x1F;
        if ( v138 )
        {
          v151 = *((_DWORD *)v213 + v137);
          v202 = v138 - 1;
          v195 = v151;
          if ( v126 - 1 <= v137 )
            goto LABEL_409;
          v152 = v137 + 1;
          v198 = (unsigned int *)&v218;
          v151 = *((_DWORD *)v213 + v137);
          do
          {
            v204 = v151 >> v138;
            v151 = *((_DWORD *)v213 + v152++);
            *v198++ = v204 | (v151 << (32 - v138));
          }
          while ( v152 != v126 );
          if ( v152 - 1 - v137 <= 1 )
          {
LABEL_409:
            v139 = (v176 - 64) >> 5;
            v219 = v151 >> v138;
          }
          else
          {
            v139 = (v176 - 64) >> 5;
          }
        }
        else
        {
          v139 = v137 - 1;
          v140 = *((_DWORD *)v213 + v137 - 1);
          v141 = (unsigned int *)v213 + v137;
          v218 = *v141;
          v195 = v140;
          v202 = 31;
          v219 = v141[1];
        }
        v142 = 0;
        if ( !LODWORD(v213[0]) )
        {
          do
            ++v142;
          while ( !*((_DWORD *)v213 + v142) );
        }
        return round_and_return_1(
                 (unsigned int *)&v218,
                 v176 - 1,
                 (v176 - 1) >> 31,
                 v209,
                 v195,
                 v202,
                 ((unsigned int)v207 < v190) | (unsigned int)(v142 < v139));
      }
      if ( v190 == (_DWORD)v207 )
      {
        v147 = (v176 - 1) % 32;
        if ( v147 == 31 )
        {
          memcpy((_BYTE *)&v218 + 4 * (2 - v126), v213, 4 * v126);
          v148 = v176 - 1;
          v156 = 2 - v220;
          if ( 2 - v220 > 0 )
          {
            v157 = 0;
            do
              *(&v218 + v157++) = 0;
            while ( v157 != v156 );
          }
        }
        else
        {
          _mpn_lshift(&v218 + 2 - v126, (int)v213, v126, 31 - v147);
          v148 = v176 - 1;
          v149 = 2 - v220;
          if ( 2 - v220 > 0 )
          {
            v150 = 0;
            do
              *(&v218 + v150++) = 0;
            while ( v150 != v149 );
          }
        }
        return round_and_return_1((unsigned int *)&v218, v148, v148 >> 31, v209, 0, 0, 0);
      }
      memcpy(&v218, v213, 4 * v126);
      if ( v126 <= 1 )
        *(&v218 + v126) = 0;
      goto LABEL_156;
    }
    __writegsdword(0xFFFFFFE8, 0x22u);
    goto LABEL_226;
  }
LABEL_156:
  if ( v190 <= (unsigned int)v207 || v217 > 0 )
    _assert_fail("dig_no > int_no && exponent <= 0", &unk_80DE720, 1292, "____strtold_l_internal");
  if ( v190 > v207 + (66 - v176) / 3 + 2 )
  {
    v208 = 1;
    v190 = v182 + (66 - v176) / 3 + 2;
  }
  else
  {
    v208 = 0;
  }
  v54 = (int *)&v214;
  v191 = v190 - v182;
  v55 = v191 - v217;
  v56 = &fpioconst_pow10;
  v171 = (int *)v213;
  v57 = 1;
  v58 = 0;
  while ( 2 )
  {
    while ( 2 )
    {
      if ( (v57 & v55) == 0 )
      {
LABEL_163:
        v57 *= 2;
        v56 += 4;
        if ( !v55 )
          goto LABEL_168;
        continue;
      }
      break;
    }
    v55 ^= v57;
    if ( !v58 )
    {
      v166 = v54;
      v58 = v56[1] - 2;
      memcpy(v54, &dword_80DB7A8[*v56], 4 * v58);
      v54 = v166;
      goto LABEL_163;
    }
    v167 = v54;
    v59 = _mpn_mul(v171, &dword_80DB7A8[*v56], v56[1] - 2, (unsigned int *)v54, v58);
    v58 = v58 + v56[1] - 2;
    if ( v59 )
    {
      v54 = v171;
      v171 = v167;
      goto LABEL_163;
    }
    --v58;
    v54 = v171;
    v57 *= 2;
    v56 += 4;
    v171 = v167;
    if ( v55 )
      continue;
    break;
  }
LABEL_168:
  v183 = v58;
  if ( v54 == (int *)v213 )
    memcpy(&v214, v213, 4 * v58);
  str_to_mpn_isra_0_1(v196, v191, (unsigned int *)v213, &v220, &v217, v203, v201);
  v192 = v58 - 1;
  _BitScanReverse(&v60, *(&v214 + v58 - 1));
  v61 = v60 ^ 0x1F;
  if ( v61 > 0 )
  {
    _mpn_lshift(&v214, (int)&v214, v58, v61);
    v62 = _mpn_lshift(v213, (int)v213, v220, v61);
    if ( v62 )
    {
      v133 = v220;
      *((_DWORD *)v213 + v220) = v62;
      v220 = v133 + 1;
    }
  }
  v217 = v176;
  if ( v58 == 1 )
  {
    if ( LODWORD(v213[0]) >= v214 || v220 != 1 )
      _assert_fail("numsize == 1 && n < d", &unk_80DE720, 1395, "____strtold_l_internal");
    v115 = v213[0];
    for ( n = v176; ; n += 32 )
    {
      while ( 1 )
      {
        LODWORD(v119) = 0;
        HIDWORD(v119) = v115;
        v117 = v119 / v214;
        v118 = v119 % v214;
        v115 = v118;
        if ( n )
          break;
        if ( v117 )
        {
          _BitScanReverse(&v120, v117);
          v179 = v120 ^ 0x1F;
          v121 = (unsigned __int64)(v217 - (int)(v120 ^ 0x1F)) >> 32;
          v122 = v217 - (v120 ^ 0x1F);
          n = 32 - v179;
          v217 = __PAIR64__(v121, v122);
          if ( (int)(32 - v179) > 64 )
          {
            v108 = v117;
            v218 = v117 >> (-32 - v179);
            v193 = v179 + 64;
            goto LABEL_308;
          }
        }
        else
        {
          v217 -= 32LL;
        }
        v219 = 0;
        v218 = v117;
        if ( n > 64 )
        {
          v108 = v117;
          v115 = v118;
          v193 = 0;
          goto LABEL_317;
        }
      }
      if ( n > 32 )
      {
        v115 = v118;
        v108 = v117;
        v193 = 64 - n;
        if ( 64 - n > 0 )
        {
          _mpn_lshift(&v218, (int)&v218, 2, v193);
          v218 |= v108 >> (32 - v193);
        }
LABEL_317:
        v121 = HIDWORD(v217);
        v122 = v217;
LABEL_308:
        v114 = (__PAIR64__(v121, v122) - 1) >> 32;
        v113 = v122 - 1;
        v112 = v208 | (v115 != 0);
        return round_and_return_1((unsigned int *)&v218, v113, v114, v209, v108, 31 - v193, v112);
      }
      v123 = v218;
      v218 = v117;
      v219 = v123;
    }
  }
  if ( v58 != 2 )
  {
    v63 = *(&v214 + v192);
    v64 = *(&v214 + v183 - 2);
    v189 = v183 - 2;
    v65 = _mpn_cmp((int)v213, (int)(&v214 + v183 - v220), v220);
    v66 = v220;
    if ( v65 > 0 )
    {
      v66 = v220 + 1;
      *((_DWORD *)v213 + v220) = 0;
      v220 = v66;
    }
    if ( v66 < v183 )
    {
      v67 = v183 - v66;
      if ( v176 <= 0 )
      {
        v217 -= 32 * v67;
        v197 = 0;
      }
      else
      {
        if ( v176 + 32 * v67 > 64 )
        {
          v197 = 64 - v176;
          if ( 64 - v176 > 31 )
          {
            _mpn_lshift(&v219, (int)&v218, 1, v197 & 0x1F);
            v66 = v220;
            v218 = 0;
          }
          else if ( v197 )
          {
            _mpn_lshift(&v218, (int)&v218, 2, v197);
            v66 = v220;
          }
        }
        else
        {
          if ( v67 != 1 )
            _assert_fail("empty == 1", &unk_80DE720, 1569, "____strtold_l_internal");
          v68 = v218;
          v197 = 0;
          v218 = 0;
          v219 = v68;
        }
        v176 += 32 * v67;
      }
      if ( v66 > 0 )
      {
        v69 = (int *)v213 + v66 - 1;
        do
        {
          v69[v67 + 1] = *v69;
          --v69;
        }
        while ( v69 != (int *)&v212 );
      }
      if ( v67 >= 0 )
      {
        v70 = v213;
        do
        {
          *(_DWORD *)v70 = 0;
          v70 = (_QWORD *)((char *)v70 + 4);
        }
        while ( v70 != (_QWORD *)((char *)v213 + 4 * v67 + 4) );
      }
      *(&v214 + v183) = 0;
      v71 = *((_DWORD *)v213 + v183);
      if ( v176 > 64 )
      {
        v73 = 0;
        v177 = v217;
      }
      else
      {
LABEL_190:
        v72 = v71;
        while ( 1 )
        {
          while ( 1 )
          {
            v73 = -1;
            if ( v72 != v63 )
            {
              LODWORD(v74) = *((_DWORD *)v213 + v192);
              HIDWORD(v74) = v72;
              v73 = v74 / v63;
              v75 = v74 % v63;
              for ( ii = v73 * (unsigned __int64)v64; ii > __PAIR64__(v75, *((_DWORD *)v213 + v189)); ii -= v64 )
              {
                --v73;
                v41 = __CFADD__(v63, v75);
                v75 += v63;
                if ( v41 )
                  break;
              }
            }
            if ( *((_DWORD *)v213 + v183) != _mpn_submul_1((int)v213, (int)&v214, v183 + 1, v73) )
            {
              if ( !_mpn_add_n(v213, v213, &v214, v183) )
                _assert_fail("cy != 0", &unk_80DE720, 1648, "____strtold_l_internal");
              --v73;
            }
            v72 = *((_DWORD *)v213 + v192);
            *((_DWORD *)v213 + v183) = v72;
            if ( v192 > 0 )
            {
              v77 = (int *)v213 + v189;
              do
              {
                v77[1] = *v77;
                --v77;
              }
              while ( v77 != (int *)&v212 );
            }
            LODWORD(v213[0]) = 0;
            if ( v176 )
              break;
            if ( v73 )
            {
              _BitScanReverse(&v78, v73);
              v79 = v78 ^ 0x1F;
              v177 = v217 - v79;
              v217 = v177;
              if ( 32 - v79 > 64 )
              {
                v197 = v79 + 64;
                v218 = v73 >> (-32 - v79);
                v71 = *((_DWORD *)v213 + v183);
                goto LABEL_206;
              }
              v176 = 32 - v79;
            }
            else
            {
              v217 -= 32LL;
            }
            v219 = 0;
            v218 = v73;
            if ( v176 > 64 )
              goto LABEL_364;
          }
          if ( v176 > 32 )
            break;
          v143 = v218;
          v176 += 32;
          v218 = v73;
          v219 = v143;
        }
        v197 = 64 - v176;
        if ( v176 != 64 )
        {
          _mpn_lshift(&v218, (int)&v218, 2, 64 - v176);
          v218 |= v73 >> (32 - v197);
        }
LABEL_364:
        v71 = *((_DWORD *)v213 + v183);
        v177 = v217;
      }
LABEL_206:
      if ( v71 || v183 < 0 )
      {
        v81 = ~v183;
      }
      else
      {
        v80 = v183;
        do
          v81 = ~--v80;
        while ( !*((_DWORD *)v213 + v80) && v80 >= 0 );
      }
      return round_and_return_1(
               (unsigned int *)&v218,
               (int)v177 - 1,
               (unsigned __int64)(v177 - 1) >> 32,
               v209,
               v73,
               31 - v197,
               v208 | (v81 >> 31));
    }
    if ( v66 != v183 )
      _assert_fail("numsize == densize", &unk_80DE720, 1606, "____strtold_l_internal");
    if ( v183 > 0 )
    {
      v135 = (int *)v213 + v192;
      do
      {
        v135[1] = *v135;
        --v135;
      }
      while ( v135 != (int *)&v212 );
    }
    LODWORD(v213[0]) = 0;
    v197 = 0;
    *(&v214 + v183) = 0;
    v71 = *((_DWORD *)v213 + v183);
    goto LABEL_190;
  }
  v105 = v214;
  v106 = v215;
  if ( v220 > 1 )
  {
    v107 = v213[0];
LABEL_285:
    v193 = 0;
    goto LABEL_286;
  }
  v107 = LODWORD(v213[0]);
  if ( v215 <= LODWORD(v213[0]) )
    goto LABEL_285;
  if ( v176 <= 0 )
  {
    v193 = 0;
    v217 = v176 - 32LL;
  }
  else
  {
    if ( v176 > 32 )
    {
      v193 = 64 - v176;
      if ( v176 != 64 )
      {
        v169 = v215;
        _mpn_lshift(&v218, (int)&v218, 2, 64 - v176);
        LODWORD(v107) = v213[0];
        v106 = v169;
      }
    }
    else
    {
      v134 = v218;
      v193 = 0;
      v218 = 0;
      v219 = v134;
    }
    v176 += 32;
  }
  if ( v176 > 64 )
  {
    v178 = v217;
    v108 = 0;
    HIDWORD(v107) = v107;
    LODWORD(v107) = 0;
    goto LABEL_297;
  }
  HIDWORD(v107) = v107;
  LODWORD(v107) = 0;
LABEL_286:
  while ( 2 )
  {
    if ( HIDWORD(v107) != v106 )
    {
LABEL_287:
      v108 = v107 / v106;
      HIDWORD(v107) = v107 % v106;
      v109 = v108 * (unsigned __int64)v105;
      do
      {
LABEL_288:
        if ( HIDWORD(v109) <= HIDWORD(v107) && (!(_DWORD)v109 || HIDWORD(v109) != HIDWORD(v107)) )
          break;
        --v108;
        v109 -= v105;
        v41 = __CFADD__(v106, HIDWORD(v107));
        HIDWORD(v107) += v106;
      }
      while ( !v41 );
      LODWORD(v107) = 0;
      v107 -= v109;
      goto LABEL_293;
    }
    while ( 1 )
    {
      v41 = __CFADD__((_DWORD)v107, HIDWORD(v107));
      HIDWORD(v107) += v107;
      if ( !v41 )
      {
        HIDWORD(v109) = v105 - (v105 != 0);
        v108 = -1;
        LODWORD(v109) = -v105;
        goto LABEL_288;
      }
      HIDWORD(v145) = HIDWORD(v107) - v105;
      LODWORD(v145) = 0;
      v108 = -1;
      v107 = v105 + v145;
LABEL_293:
      if ( !v176 )
        break;
      if ( v176 > 32 )
      {
        v193 = 64 - v176;
        if ( v176 != 64 )
        {
          _mpn_lshift(&v218, (int)&v218, 2, 64 - v176);
          v218 |= v108 >> (32 - v193);
        }
LABEL_373:
        v178 = v217;
        goto LABEL_297;
      }
      v144 = v218;
      v176 += 32;
      v218 = v108;
      v219 = v144;
      if ( HIDWORD(v107) != v106 )
        goto LABEL_287;
    }
    if ( !v108 )
    {
      v217 -= 32LL;
      goto LABEL_372;
    }
    _BitScanReverse(&v110, v108);
    v184 = v110 ^ 0x1F;
    LODWORD(v178) = v217 - (v110 ^ 0x1F);
    v111 = v217 - (int)(v110 ^ 0x1F);
    HIDWORD(v178) = HIDWORD(v111);
    v217 = v111;
    if ( (int)(32 - v184) <= 64 )
    {
      v176 = 32 - v184;
LABEL_372:
      v219 = 0;
      v218 = v108;
      if ( v176 > 64 )
        goto LABEL_373;
      continue;
    }
    break;
  }
  v193 = v184 + 64;
  v218 = v108 >> (-32 - v184);
LABEL_297:
  v112 = HIDWORD(v107) || v208 || v107 != 0;
  v114 = (unsigned __int64)(v178 - 1) >> 32;
  v113 = v178 - 1;
  return round_and_return_1((unsigned int *)&v218, v113, v114, v209, v108, 31 - v193, v112);
}
// 80482E0: using guessed type int __cdecl strncasecmp_l(_DWORD, _DWORD, _DWORD, _DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80C8380: using guessed type char **nl_C_locobj[6];
// 80CFDC0: using guessed type int dword_80CFDC0[];
// 80DB7A8: using guessed type unsigned int dword_80DB7A8[886];
// 80DE7A0: using guessed type int nbits_9419_0[16];

//----- (080B7EF0) --------------------------------------------------------
void __cdecl strtold_l(_BYTE *a1, unsigned int *a2, _DWORD *a3)
{
  ___strtold_l_internal(a1, a2, 0, a3);
}

//----- (080B7F20) --------------------------------------------------------
int init()
{
  int result; // eax

  result = 0;
  static_buf = (int)&last_result;
  return result;
}
// 80F0F24: using guessed type int static_buf;

//----- (080B7F60) --------------------------------------------------------
int __usercall _dlerror@<eax>(long double a1@<st0>)
{
  char *v1; // eax
  int result; // eax
  char *v3; // eax
  const char *v4; // edx
  char *v5; // esi
  char *v6; // eax
  const char *v7; // ecx
  const char *v8; // edx
  int v9[4]; // [esp+2Ch] [ebp-10h] BYREF

  v9[0] = 0;
  if ( !once )
  {
    init();
    once |= 2u;
  }
  v1 = (char *)*((_DWORD *)&last_result + 4);
  if ( *((_DWORD *)&last_result + 1) )
  {
    if ( v1 )
    {
      if ( strcmp(*((const char **)&last_result + 4), "out of memory") )
        free(a1, *((_DWORD *)&last_result + 4));
      *((_DWORD *)&last_result + 4) = 0;
    }
    return v9[0];
  }
  if ( !v1 )
    return v9[0];
  v9[0] = *((_DWORD *)&last_result + 4);
  if ( last_result )
  {
    v5 = strerror(a1, last_result);
    v6 = dcgettext(a1, "libc", *((char **)&last_result + 4), 5);
    v7 = (const char *)*((_DWORD *)&last_result + 3);
    v8 = (const char *)&unk_80C86D9;
    if ( *v7 )
      v8 = "undefined symbol: " + 16;
    if ( asprintf(a1, v9, (int)"%s%s%s: %s", v7, v8, v6, v5) != -1 )
      goto LABEL_13;
  }
  else
  {
    v3 = dcgettext(a1, "libc", v1, 5);
    v4 = (const char *)&unk_80C86D9;
    if ( **((_BYTE **)&last_result + 3) )
      v4 = "undefined symbol: " + 16;
    if ( asprintf(a1, v9, (int)"%s%s%s", *((const char **)&last_result + 3), v4, v3) != -1 )
    {
LABEL_13:
      if ( strcmp(*((const char **)&last_result + 4), "out of memory") )
        free(a1, *((_DWORD *)&last_result + 4));
      result = v9[0];
      *((_DWORD *)&last_result + 4) = v9[0];
      goto LABEL_16;
    }
  }
  result = v9[0];
LABEL_16:
  *((_DWORD *)&last_result + 1) = 1;
  return result;
}
// 80F0F08: using guessed type int once;

//----- (080B8130) --------------------------------------------------------
void __usercall check_free(long double a1@<st0>, int a2)
{
  const char *v2; // esi
  int v3[4]; // [esp+1Ch] [ebp-20h] BYREF
  int v4; // [esp+2Ch] [ebp-10h] BYREF

  v2 = *(const char **)(a2 + 16);
  if ( v2 )
  {
    if ( strcmp(v2, "out of memory") )
    {
      v4 = 0;
      if ( dl_addr((unsigned int)check_free, v3, &v4, 0) )
      {
        if ( v4 )
        {
          if ( !*(_DWORD *)(v4 + 24) )
            free(a1, *(_DWORD *)(a2 + 16));
        }
      }
    }
  }
}
// 80B8130: using guessed type int var_20[4];

//----- (080B81B0) --------------------------------------------------------
int __usercall free_key_mem@<eax>(long double a1@<st0>, int a2)
{
  check_free(a1, a2);
  free(a1, a2);
  return 0;
}

//----- (080B81F0) --------------------------------------------------------
_BOOL4 __usercall dlerror_run@<eax>(void (__cdecl *a1)(int)@<eax>, int a2@<edx>, long double a3@<st0>)
{
  int *v5; // ebx
  int v6; // eax
  int *v8; // eax

  if ( !once )
  {
    init();
    once |= 2u;
  }
  v5 = (int *)static_buf;
  if ( !static_buf )
  {
    calloc(1, 0x14u);
    v5 = v8;
    if ( !v8 )
      v5 = (int *)&last_result;
  }
  if ( v5[4] )
  {
    if ( *((_BYTE *)v5 + 8) )
      free(a3, v5[4]);
    v5[4] = 0;
  }
  *v5 = dl_catch_error(v5 + 3, v5 + 4, (_BYTE *)v5 + 8, (int)v5, a2, (int)a1, (int)(v5 + 3), a1, a2);
  v6 = v5[4];
  v5[1] = v6 == 0;
  return v6 != 0;
}
// 80B82D6: variable 'v8' is possibly undefined
// 80F0F08: using guessed type int once;
// 80F0F24: using guessed type int static_buf;

//----- (080B8330) --------------------------------------------------------
_DWORD *__usercall _libc_register_dlfcn_hook@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, int a5)
{
  _DWORD *result; // eax

  result = (_DWORD *)_libc_dlsym_private(a1, a2, a3, a4, a5, (int)"_dlfcn_hook");
  if ( result )
    *result = &dlfcn_hooks;
  return result;
}
// 80EFC40: using guessed type int (__cdecl *dlfcn_hooks)(int, int, int);

//----- (080B8360) --------------------------------------------------------
int __cdecl _dladdr(unsigned int a1, _DWORD *a2)
{
  return dl_addr(a1, a2, 0, 0);
}

//----- (080B8380) --------------------------------------------------------
int __cdecl _dladdr1(unsigned int a1, _DWORD *a2, int *a3, int a4)
{
  if ( a4 == 1 )
    return dl_addr(a1, a2, 0, a3);
  if ( a4 == 2 )
    return dl_addr(a1, a2, a3, 0);
  return dl_addr(a1, a2, 0, 0);
}

//----- (080B83D0) --------------------------------------------------------
void *__usercall dlinfo_doit@<eax>(long double a1@<st0>, int a2)
{
  void *result; // eax
  int addr_soft; // edx
  int v4; // edx
  _DWORD *v5; // edx

  result = *(void **)(a2 + 4);
  switch ( *(_DWORD *)(a2 + 8) )
  {
    case 1:
      v4 = *((_DWORD *)result + 6);
      result = *(void **)(a2 + 12);
      *(_DWORD *)result = v4;
      break;
    case 2:
      **(_DWORD **)(a2 + 12) = result;
      break;
    case 4:
      result = dl_rtld_di_serinfo((int)result, *(int **)(a2 + 12), 0);
      break;
    case 5:
      result = dl_rtld_di_serinfo((int)result, *(int **)(a2 + 12), 1);
      break;
    case 6:
      result = strcpy(*(char **)(a2 + 12), *((const char **)result + 106));
      break;
    case 9:
      v5 = *(_DWORD **)(a2 + 12);
      *v5 = 0;
      result = (void *)*((_DWORD *)result + 145);
      *v5 = result;
      break;
    case 0xA:
      addr_soft = 0;
      if ( *((_DWORD *)result + 145) )
        addr_soft = dl_tls_get_addr_soft(*(_DWORD *)(a2 + 4));
      result = *(void **)(a2 + 12);
      *(_DWORD *)result = addr_soft;
      break;
    default:
      dl_signal_error(0, 0, 0, a1, "unsupported dlinfo request");
  }
  return result;
}

//----- (080B84C0) --------------------------------------------------------
int __usercall _dlinfo@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5)
{
  int v6[7]; // [esp+0h] [ebp-1Ch] BYREF

  v6[0] = a5;
  v6[1] = a2;
  v6[2] = a3;
  v6[3] = a4;
  return -dlerror_run((void (__cdecl *)(int))dlinfo_doit, (int)v6, a1);
}

//----- (080B8500) --------------------------------------------------------
int __usercall dlmopen_doit@<eax>(long double a1@<st0>, _DWORD *a2)
{
  void *v2; // eax
  int result; // eax

  if ( *a2 )
    dl_signal_error(22, 0, 0, a1, "invalid namespace");
  v2 = (void *)a2[1];
  if ( !v2 )
    v2 = &unk_80C86D9;
  result = dl_open((int)v2, a2[2] | 0x80000000, a2[4], 0, _libc_argc, _libc_argv, (int)environ);
  a2[3] = result;
  return result;
}
// 80F1250: using guessed type int _libc_argc;
// 80F1254: using guessed type int _libc_argv;

//----- (080B8580) --------------------------------------------------------
int __usercall _dlmopen@<eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3@<edi>,
        int a4@<esi>,
        long double a5@<st0>,
        int a6,
        int a7,
        int a8,
        int a9)
{
  _BOOL4 v9; // eax
  int v10; // edx
  int v12[3]; // [esp+1Ch] [ebp-20h] BYREF
  int v13; // [esp+28h] [ebp-14h]
  int v14; // [esp+2Ch] [ebp-10h]

  v12[0] = a6;
  v12[1] = a7;
  v12[2] = a8;
  v14 = a9;
  v9 = dlerror_run((void (__cdecl *)(int))dlmopen_doit, (int)v12, a5);
  v10 = 0;
  if ( !v9 )
  {
    _libc_register_dl_open_hook(a1, a2, a3, a4, v13);
    _libc_register_dlfcn_hook(a1, a2, a3, a4, v13);
    return v13;
  }
  return v10;
}

//----- (080B85E0) --------------------------------------------------------
char *__usercall strerror@<eax>(long double a1@<st0>, signed int a2)
{
  char *result; // eax
  unsigned int v3; // edi
  _BYTE *v4; // eax
  int v5; // eax

  result = strerror_r(a1, a2, 0, 0);
  if ( !result )
  {
    v3 = __readgsdword(0xFFFFFFE8);
    if ( !buf )
    {
      malloc(a1, 0x400u);
      buf = v5;
    }
    v4 = (_BYTE *)buf;
    __writegsdword(0xFFFFFFE8, v3);
    if ( v4 )
      return strerror_r(a1, a2, v4, 0x400u);
    else
      return dcgettext(a1, "libc", "Unknown error", 5);
  }
  return result;
}
// 80B865F: variable 'v5' is possibly undefined
// 80F1388: using guessed type int buf;

//----- (080B8690) --------------------------------------------------------
_BYTE *__cdecl strpbrk(int a1, _BYTE *a2)
{
  int v3; // ecx
  _BYTE *result; // eax
  char v5[256]; // [esp+0h] [ebp-100h] BYREF

  v3 = 0;
  memset(v5, 0, sizeof(v5));
  do
  {
    if ( !*a2 )
      break;
    LOBYTE(v3) = *a2;
    v5[v3] = *a2;
    LOBYTE(v3) = a2[1];
    if ( !(_BYTE)v3 )
      break;
    v5[v3] = v3;
    LOBYTE(v3) = a2[2];
    if ( !(_BYTE)v3 )
      break;
    v5[v3] = v3;
    LOBYTE(v3) = a2[3];
    a2 += 4;
    v5[v3] = v3;
  }
  while ( (_BYTE)v3 );
  result = (_BYTE *)(a1 - 4);
  while ( 1 )
  {
    result += 4;
    LOBYTE(v3) = *result;
    if ( v5[v3] == *result )
      break;
    LOBYTE(v3) = result[1];
    if ( v5[v3] == (_BYTE)v3 )
      goto LABEL_13;
    LOBYTE(v3) = result[2];
    if ( v5[v3] == (_BYTE)v3 )
      goto LABEL_12;
    LOBYTE(v3) = result[3];
    if ( v5[v3] == (_BYTE)v3 )
    {
      ++result;
LABEL_12:
      ++result;
LABEL_13:
      ++result;
      break;
    }
  }
  if ( !(_BYTE)v3 )
    return 0;
  return result;
}
// 80B8690: using guessed type char var_100[256];

//----- (080B8750) --------------------------------------------------------
int (__cdecl *strncasecmp_l())(char *a1, unsigned __int8 *a2, int a3, int a4)
{
  int (__cdecl *result)(char *, unsigned __int8 *, int, int); // eax

  if ( !_cpu_features )
    _init_cpu_features();
  result = (int (__cdecl *)(char *, unsigned __int8 *, int, int))_strncasecmp_l_ia32;
  if ( (dword_80F1270 & 0x200) != 0 )
  {
    result = (int (__cdecl *)(char *, unsigned __int8 *, int, int))_strncasecmp_l_ssse3;
    if ( (dword_80F1270 & 0x100000) != 0 )
      return _strncasecmp_l_sse4_2;
  }
  return result;
}
// 80F1260: using guessed type int _cpu_features;
// 80F1270: using guessed type int dword_80F1270;

//----- (080B8790) --------------------------------------------------------
int __cdecl _strncasecmp_l_ia32(char *a1, _BYTE *a2)
{
  char v4; // al
  int result; // eax

  while ( 1 )
  {
    v4 = *a1;
    if ( *a1 != *a2 )
      break;
    ++a1;
    ++a2;
    if ( !v4 )
      return 0;
  }
  result = 1;
  if ( (unsigned __int8)*a1 < *a2 )
    return -1;
  return result;
}

//----- (080B87C0) --------------------------------------------------------
int __cdecl _strncasecmp_ssse3(char *a1, unsigned __int8 *a2, int a3)
{
  if ( (*(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFD8) + 320) & 1) == 0 )
    JUMPOUT(0x80B87F6);
  return _strncasecmp_nonascii(a1, a2, a3);
}
// 80B87D8: control flows out of bounds to 80B87F6

//----- (080B87E0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl _strncasecmp_l_ssse3(char *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // edx
  unsigned __int8 *v4; // eax
  unsigned int v5; // ebp
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm1
  int v9; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // edi
  const __m128i *v12; // eax
  const __m128i *v13; // edx
  const __m128i *v14; // et0
  unsigned int v15; // et1
  int v16; // edi
  bool v17; // zf
  __m128i si128; // xmm1
  __m128i v19; // xmm2
  unsigned int v20; // edi
  int v21; // esi
  int v22; // edi
  __m128i v23; // xmm0
  __m128i v24; // xmm1
  __m128i v25; // xmm2
  __m128i v26; // xmm1
  __m128i v27; // xmm1
  __m128i v28; // xmm2
  unsigned int v29; // edi
  __m128i v30; // xmm3
  __m128i v31; // xmm0
  int v32; // edi
  __m128i v33; // xmm1
  __m128i v34; // xmm4
  __m128i v35; // xmm2
  __m128i v36; // xmm1
  __m128i v37; // xmm1
  __m128i v38; // xmm4
  __m128i v39; // xmm2
  __m128i v40; // xmm1
  __m128i v41; // xmm0
  __m128i v42; // xmm1
  __m128i v43; // xmm0
  __m128i v44; // xmm3
  __m128i v45; // xmm1
  __m128i v46; // xmm2
  unsigned int v47; // edi
  __m128i v48; // xmm3
  __m128i v49; // xmm0
  int v50; // edi
  __m128i v51; // xmm1
  __m128i v52; // xmm4
  __m128i v53; // xmm2
  __m128i v54; // xmm1
  __m128i v55; // xmm1
  __m128i v56; // xmm4
  __m128i v57; // xmm2
  __m128i v58; // xmm1
  __m128i v59; // xmm0
  __m128i v60; // xmm1
  __m128i v61; // xmm2
  unsigned int v62; // edi
  __m128i v63; // xmm3
  __m128i v64; // xmm0
  int v65; // edi
  __m128i v66; // xmm1
  __m128i v67; // xmm4
  __m128i v68; // xmm2
  __m128i v69; // xmm1
  __m128i v70; // xmm1
  __m128i v71; // xmm4
  __m128i v72; // xmm2
  __m128i v73; // xmm1
  __m128i v74; // xmm0
  __m128i v75; // xmm1
  __m128i v76; // xmm2
  unsigned int v77; // edi
  __m128i v78; // xmm3
  __m128i v79; // xmm0
  int v80; // edi
  __m128i v81; // xmm1
  __m128i v82; // xmm4
  __m128i v83; // xmm2
  __m128i v84; // xmm1
  __m128i v85; // xmm1
  __m128i v86; // xmm4
  __m128i v87; // xmm2
  __m128i v88; // xmm1
  __m128i v89; // xmm0
  __m128i v90; // xmm1
  __m128i v91; // xmm2
  unsigned int v92; // edi
  __m128i v93; // xmm3
  __m128i v94; // xmm0
  int v95; // edi
  __m128i v96; // xmm1
  __m128i v97; // xmm4
  __m128i v98; // xmm2
  __m128i v99; // xmm1
  __m128i v100; // xmm1
  __m128i v101; // xmm4
  __m128i v102; // xmm2
  __m128i v103; // xmm1
  __m128i v104; // xmm0
  __m128i v105; // xmm1
  __m128i v106; // xmm2
  unsigned int v107; // edi
  __m128i v108; // xmm3
  __m128i v109; // xmm0
  int v110; // edi
  __m128i v111; // xmm1
  __m128i v112; // xmm4
  __m128i v113; // xmm2
  __m128i v114; // xmm1
  __m128i v115; // xmm1
  __m128i v116; // xmm4
  __m128i v117; // xmm2
  __m128i v118; // xmm1
  __m128i v119; // xmm0
  __m128i v120; // xmm1
  __m128i v121; // xmm2
  unsigned int v122; // edi
  __m128i v123; // xmm3
  __m128i v124; // xmm0
  int v125; // edi
  __m128i v126; // xmm1
  __m128i v127; // xmm4
  __m128i v128; // xmm2
  __m128i v129; // xmm1
  __m128i v130; // xmm1
  __m128i v131; // xmm4
  __m128i v132; // xmm2
  __m128i v133; // xmm1
  __m128i v134; // xmm0
  __m128i v135; // xmm1
  __m128i v136; // xmm2
  unsigned int v137; // edi
  __m128i v138; // xmm3
  __m128i v139; // xmm0
  int v140; // edi
  __m128i v141; // xmm1
  __m128i v142; // xmm4
  __m128i v143; // xmm2
  __m128i v144; // xmm1
  __m128i v145; // xmm1
  __m128i v146; // xmm4
  __m128i v147; // xmm2
  __m128i v148; // xmm1
  __m128i v149; // xmm0
  __m128i v150; // xmm1
  __m128i v151; // xmm2
  unsigned int v152; // edi
  __m128i v153; // xmm3
  __m128i v154; // xmm0
  int v155; // edi
  __m128i v156; // xmm1
  __m128i v157; // xmm4
  __m128i v158; // xmm2
  __m128i v159; // xmm1
  __m128i v160; // xmm1
  __m128i v161; // xmm4
  __m128i v162; // xmm2
  __m128i v163; // xmm1
  __m128i v164; // xmm0
  __m128i v165; // xmm1
  __m128i v166; // xmm2
  unsigned int v167; // edi
  __m128i v168; // xmm3
  __m128i v169; // xmm0
  int v170; // edi
  __m128i v171; // xmm1
  __m128i v172; // xmm4
  __m128i v173; // xmm2
  __m128i v174; // xmm1
  __m128i v175; // xmm1
  __m128i v176; // xmm4
  __m128i v177; // xmm2
  __m128i v178; // xmm1
  __m128i v179; // xmm0
  __m128i v180; // xmm1
  __m128i v181; // xmm2
  unsigned int v182; // edi
  __m128i v183; // xmm3
  __m128i v184; // xmm0
  int v185; // edi
  __m128i v186; // xmm1
  __m128i v187; // xmm4
  __m128i v188; // xmm2
  __m128i v189; // xmm1
  __m128i v190; // xmm1
  __m128i v191; // xmm4
  __m128i v192; // xmm2
  __m128i v193; // xmm1
  __m128i v194; // xmm0
  __m128i v195; // xmm1
  __m128i v196; // xmm2
  unsigned int v197; // edi
  __m128i v198; // xmm3
  __m128i v199; // xmm0
  int v200; // edi
  __m128i v201; // xmm1
  __m128i v202; // xmm4
  __m128i v203; // xmm2
  __m128i v204; // xmm1
  __m128i v205; // xmm1
  __m128i v206; // xmm4
  __m128i v207; // xmm2
  __m128i v208; // xmm1
  __m128i v209; // xmm0
  __m128i v210; // xmm1
  __m128i v211; // xmm2
  unsigned int v212; // edi
  __m128i v213; // xmm3
  __m128i v214; // xmm0
  int v215; // edi
  __m128i v216; // xmm1
  __m128i v217; // xmm4
  __m128i v218; // xmm2
  __m128i v219; // xmm1
  __m128i v220; // xmm1
  __m128i v221; // xmm4
  __m128i v222; // xmm2
  __m128i v223; // xmm1
  __m128i v224; // xmm0
  __m128i v225; // xmm1
  __m128i v226; // xmm2
  unsigned int v227; // edi
  __m128i v228; // xmm3
  __m128i v229; // xmm0
  int v230; // edi
  __m128i v231; // xmm1
  __m128i v232; // xmm4
  __m128i v233; // xmm2
  __m128i v234; // xmm1
  __m128i v235; // xmm1
  __m128i v236; // xmm4
  __m128i v237; // xmm2
  __m128i v238; // xmm1
  __m128i v239; // xmm0
  __m128i v240; // xmm1
  __m128i v241; // xmm2
  unsigned int v242; // edi
  __m128i v243; // xmm3
  __m128i v244; // xmm0
  int v245; // edi
  __m128i v246; // xmm1
  __m128i v247; // xmm4
  __m128i v248; // xmm2
  __m128i v249; // xmm1
  __m128i v250; // xmm1
  __m128i v251; // xmm4
  __m128i v252; // xmm2
  __m128i v253; // xmm1
  __m128i v254; // xmm0
  unsigned __int8 *v255; // et2
  int result; // eax
  unsigned int v257; // ecx
  unsigned int v258; // esi
  char v259; // cc
  unsigned int v260; // ecx
  unsigned int v261; // esi
  unsigned int v262; // ecx
  unsigned int v263; // esi
  unsigned int v264; // ecx
  unsigned int v265; // esi
  unsigned int v266; // ecx
  unsigned int v267; // esi
  unsigned int v268; // ecx
  unsigned int v269; // esi
  unsigned int v270; // ecx
  unsigned int v271; // esi
  unsigned int v272; // ecx
  unsigned int v273; // esi
  unsigned int v274; // ecx
  unsigned int v275; // esi
  unsigned int v276; // ecx
  unsigned int v277; // esi
  unsigned int v278; // ecx
  unsigned int v279; // esi
  unsigned int v280; // ecx
  unsigned int v281; // esi
  unsigned int v282; // ecx
  unsigned int v283; // esi
  unsigned int v284; // ecx
  unsigned int v285; // esi
  unsigned int v286; // ecx
  unsigned int v287; // esi
  char v288; // [esp-8h] [ebp-18h]
  unsigned __int8 *v289; // [esp+Ch] [ebp-4h]
  __int64 *retaddr; // [esp+10h] [ebp+0h]

  if ( (*(_DWORD *)(*(_DWORD *)a2 + 320) & 1) != 0 )
    return _strncasecmp_nonascii(a1, a2, a3);
  v3 = v289;
  v4 = (unsigned __int8 *)retaddr;
  v5 = (unsigned int)a1;
  if ( (unsigned int)a1 < 0x10 )
  {
    if ( !a1 )
      return 0;
    v257 = dword_80CFDC0[*(unsigned __int8 *)retaddr];
    v258 = dword_80CFDC0[*v289];
    v259 = v258 <= v257;
    if ( v258 != v257 )
      goto LABEL_328;
    if ( !(_BYTE)v257 )
      return 0;
    if ( a1 == (char *)1 )
      return 0;
    v260 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 1)];
    v261 = dword_80CFDC0[v289[1]];
    v259 = v261 <= v260;
    if ( v261 != v260 )
      goto LABEL_328;
    if ( !(_BYTE)v260 )
      return 0;
    if ( a1 == (char *)2 )
      return 0;
    v262 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 2)];
    v263 = dword_80CFDC0[v289[2]];
    v259 = v263 <= v262;
    if ( v263 != v262 )
      goto LABEL_328;
    if ( !(_BYTE)v262 )
      return 0;
    if ( a1 == (char *)3 )
      return 0;
    v264 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 3)];
    v265 = dword_80CFDC0[v289[3]];
    v259 = v265 <= v264;
    if ( v265 != v264 )
      goto LABEL_328;
    if ( !(_BYTE)v264 )
      return 0;
    if ( a1 == (char *)4 )
      return 0;
    v266 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 4)];
    v267 = dword_80CFDC0[v289[4]];
    v259 = v267 <= v266;
    if ( v267 != v266 )
      goto LABEL_328;
    if ( !(_BYTE)v266 )
      return 0;
    if ( a1 == (char *)5 )
      return 0;
    v268 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 5)];
    v269 = dword_80CFDC0[v289[5]];
    v259 = v269 <= v268;
    if ( v269 != v268 )
      goto LABEL_328;
    if ( !(_BYTE)v268 )
      return 0;
    if ( a1 == (char *)6 )
      return 0;
    v270 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 6)];
    v271 = dword_80CFDC0[v289[6]];
    v259 = v271 <= v270;
    if ( v271 != v270 )
      goto LABEL_328;
    if ( !(_BYTE)v270 )
      return 0;
    if ( a1 == (char *)7 )
      return 0;
    v272 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 7)];
    v273 = dword_80CFDC0[v289[7]];
    v259 = v273 <= v272;
    if ( v273 != v272 )
      goto LABEL_328;
    if ( !(_BYTE)v272 )
      return 0;
    if ( a1 == (char *)8 )
      return 0;
    v274 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 8)];
    v275 = dword_80CFDC0[v289[8]];
    v259 = v275 <= v274;
    if ( v275 != v274 )
      goto LABEL_328;
    if ( !(_BYTE)v274 )
      return 0;
    if ( a1 == (char *)9 )
      return 0;
    v276 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 9)];
    v277 = dword_80CFDC0[v289[9]];
    v259 = v277 <= v276;
    if ( v277 != v276 )
      goto LABEL_328;
    if ( !(_BYTE)v276 )
      return 0;
    if ( a1 == (char *)10 )
      return 0;
    v278 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 10)];
    v279 = dword_80CFDC0[v289[10]];
    v259 = v279 <= v278;
    if ( v279 != v278 )
      goto LABEL_328;
    if ( !(_BYTE)v278 )
      return 0;
    if ( a1 == (char *)11 )
      return 0;
    v280 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 11)];
    v281 = dword_80CFDC0[v289[11]];
    v259 = v281 <= v280;
    if ( v281 != v280 )
      goto LABEL_328;
    if ( !(_BYTE)v280 )
      return 0;
    if ( a1 == (char *)12 )
      return 0;
    v282 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 12)];
    v283 = dword_80CFDC0[v289[12]];
    v259 = v283 <= v282;
    if ( v283 != v282 )
      goto LABEL_328;
    if ( !(_BYTE)v282 )
      return 0;
    if ( a1 == (char *)13 )
      return 0;
    v284 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 13)];
    v285 = dword_80CFDC0[v289[13]];
    v259 = v285 <= v284;
    if ( v285 == v284 )
    {
      if ( !(_BYTE)v284 )
        return 0;
      if ( a1 == (char *)14 )
        return 0;
      v286 = dword_80CFDC0[*((unsigned __int8 *)retaddr + 14)];
      v287 = dword_80CFDC0[v289[14]];
      v259 = v287 <= v286;
      if ( v287 == v286 )
        return 0;
    }
LABEL_328:
    result = 1;
    if ( v259 )
      return -1;
    return result;
  }
  if ( ((unsigned __int16)v289 & 0xFFFu) <= 0xFF0 && ((unsigned __int16)retaddr & 0xFFFu) <= 0xFF0 )
  {
    v6.m128i_i64[0] = *retaddr;
    v7.m128i_i64[0] = *(__int64 *)v289;
    v6.m128i_i64[1] = retaddr[1];
    v7.m128i_i64[1] = *((__int64 *)v289 + 1);
    v8 = _mm_or_si128(
           v6,
           _mm_and_si128(
             _mm_and_si128(
               _mm_cmpgt_epi8(v6, (__m128i)xmmword_80CA9D0),
               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v6)),
             (__m128i)xmmword_80CA9F0));
    v9 = _mm_movemask_epi8(
           _mm_sub_epi8(
             _mm_cmpeq_epi8(
               v8,
               _mm_or_si128(
                 v7,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v7, (__m128i)xmmword_80CA9D0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v7)),
                   (__m128i)xmmword_80CA9F0))),
             _mm_cmpeq_epi8((__m128i)0LL, v8)))
       - 0xFFFF;
    if ( v9 )
      goto LABEL_248;
    v5 = (unsigned int)(a1 - 16);
    if ( (unsigned int)a1 <= 0x10 )
      return 0;
    v4 = (unsigned __int8 *)(retaddr + 2);
    v3 = v289 + 16;
  }
  v288 = 0;
  v10 = (unsigned __int8)v4 & 0xF;
  v11 = (unsigned __int8)v3 & 0xF;
  v12 = (const __m128i *)(v10 ^ (unsigned int)v4);
  v13 = (const __m128i *)(v11 ^ (unsigned int)v3);
  if ( v10 == v11 )
  {
LABEL_27:
    si128 = _mm_load_si128(v12);
    v19 = _mm_load_si128(v13);
    v20 = (unsigned int)_mm_movemask_epi8(
                          _mm_sub_epi8(
                            _mm_cmpeq_epi8(
                              _mm_or_si128(
                                si128,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(si128, (__m128i)xmmword_80CA9D0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), si128)),
                                  (__m128i)xmmword_80CA9F0)),
                              _mm_or_si128(
                                v19,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(v19, (__m128i)xmmword_80CA9D0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v19)),
                                  (__m128i)xmmword_80CA9F0))),
                            _mm_cmpeq_epi8((__m128i)0LL, si128))) >> v10;
    v21 = (0xFFFFu >> v10) - v20;
    v17 = 0xFFFFu >> v10 == v20;
    v22 = v10;
    if ( !v17 )
      goto LABEL_245;
    if ( v5 > 16 - v10 )
    {
      v5 -= 16 - v10;
      v288 = 16;
      v10 = 16;
      v23 = 0LL;
      while ( 1 )
      {
        v24 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
        v25 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
        v26 = _mm_or_si128(
                v24,
                _mm_and_si128(
                  _mm_and_si128(
                    _mm_cmpgt_epi8(v24, (__m128i)xmmword_80CA9D0),
                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v24)),
                  (__m128i)xmmword_80CA9F0));
        v23 = _mm_cmpeq_epi8(v23, v26);
        v21 = _mm_movemask_epi8(
                _mm_sub_epi8(
                  _mm_cmpeq_epi8(
                    v26,
                    _mm_or_si128(
                      v25,
                      _mm_and_si128(
                        _mm_and_si128(
                          _mm_cmpgt_epi8(v25, (__m128i)xmmword_80CA9D0),
                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v25)),
                        (__m128i)xmmword_80CA9F0))),
                  v23))
            - 0xFFFF;
        if ( v21 )
          break;
        v259 = v5 <= 0x10;
        v5 -= 16;
        if ( v259 )
          return 0;
        v10 += 16;
      }
      goto LABEL_244;
    }
    return 0;
  }
  if ( v10 <= v11 )
  {
    v288 = 32;
    v14 = v12;
    v12 = v13;
    v13 = v14;
    v15 = v10;
    v10 = v11;
    v11 = v15;
  }
  v16 = v11 + 15 - v10;
  v17 = v16 == 8;
  if ( v16 <= 8 )
    goto LABEL_18;
  if ( v16 != 14 )
  {
    if ( v16 != 13 )
    {
      if ( v16 != 12 )
      {
        if ( v16 != 11 )
        {
          if ( v16 != 10 )
          {
            v17 = v16 == 9;
            if ( v16 != 9 )
            {
LABEL_18:
              if ( !v17 )
              {
                if ( v16 != 7 )
                {
                  if ( v16 != 6 )
                  {
                    if ( v16 != 5 )
                    {
                      if ( v16 != 4 )
                      {
                        if ( v16 != 3 )
                        {
                          if ( v16 != 2 )
                          {
                            if ( v16 != 1 )
                            {
                              if ( v16 )
                                goto LABEL_27;
                              v27 = _mm_load_si128(v12);
                              v28 = _mm_slli_si128(_mm_load_si128(v13), 15);
                              v29 = (unsigned int)_mm_movemask_epi8(
                                                    _mm_sub_epi8(
                                                      _mm_cmpeq_epi8(
                                                        _mm_or_si128(
                                                          v28,
                                                          _mm_and_si128(
                                                            _mm_and_si128(
                                                              _mm_cmpgt_epi8(v28, (__m128i)xmmword_80CA9D0),
                                                              _mm_cmpgt_epi8(
                                                                _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                                v28)),
                                                            (__m128i)xmmword_80CA9F0)),
                                                        _mm_or_si128(
                                                          v27,
                                                          _mm_and_si128(
                                                            _mm_and_si128(
                                                              _mm_cmpgt_epi8(v27, (__m128i)xmmword_80CA9D0),
                                                              _mm_cmpgt_epi8(
                                                                _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                                v27)),
                                                            (__m128i)xmmword_80CA9F0))),
                                                      _mm_cmpeq_epi8((__m128i)0LL, v27))) >> v10;
                              v21 = (0xFFFFu >> v10) - v29;
                              v17 = 0xFFFFu >> v10 == v29;
                              v22 = v10 - 15;
                              if ( !v17 )
                                goto LABEL_245;
                              if ( v5 <= 16 - v10 )
                                return 0;
                              v5 -= 16 - v10;
                              v30 = _mm_load_si128(v13);
                              v31 = 0LL;
                              v10 = 16;
                              v288 |= 1u;
                              v32 = (((_WORD)v13 + 1) & 0xFFF) - 4096;
                              while ( 1 )
                              {
                                v259 = (v32 + 16 < 0) ^ __OFADD__(16, v32) | (v32 == -16);
                                v32 += 16;
                                if ( !v259 )
                                  goto LABEL_43;
                                while ( 1 )
                                {
                                  v33 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                                  v34 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                                  v35 = _mm_alignr_epi8(v34, v30, 1);
                                  v36 = _mm_or_si128(
                                          v33,
                                          _mm_and_si128(
                                            _mm_and_si128(
                                              _mm_cmpgt_epi8(v33, (__m128i)xmmword_80CA9D0),
                                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v33)),
                                            (__m128i)xmmword_80CA9F0));
                                  v31 = _mm_cmpeq_epi8(v31, v36);
                                  v21 = _mm_movemask_epi8(
                                          _mm_sub_epi8(
                                            _mm_cmpeq_epi8(
                                              v36,
                                              _mm_or_si128(
                                                v35,
                                                _mm_and_si128(
                                                  _mm_and_si128(
                                                    _mm_cmpgt_epi8(v35, (__m128i)xmmword_80CA9D0),
                                                    _mm_cmpgt_epi8(
                                                      _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                      v35)),
                                                  (__m128i)xmmword_80CA9F0))),
                                            v31))
                                      - 0xFFFF;
                                  if ( v21 )
                                    goto LABEL_244;
                                  v259 = v5 <= 0x10;
                                  v5 -= 16;
                                  if ( v259 )
                                    return 0;
                                  v10 += 16;
                                  v30 = v34;
                                  v259 = (v32 + 16 < 0) ^ __OFADD__(16, v32) | (v32 == -16);
                                  v32 += 16;
                                  if ( v259 )
                                    break;
LABEL_43:
                                  v41 = _mm_cmpeq_epi8(v31, v30);
                                  if ( (_mm_movemask_epi8(v41) & 0xFFFE) != 0 || v5 <= 0xF )
                                  {
                                    v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                                    v43 = _mm_srli_si128(v41, 1);
                                    v44 = _mm_srli_si128(v30, 1);
                                    goto LABEL_243;
                                  }
                                  v31 = 0LL;
                                  v32 -= 4096;
                                }
                                v37 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                                v38 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                                v39 = _mm_alignr_epi8(v38, v30, 1);
                                v40 = _mm_or_si128(
                                        v37,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v37, (__m128i)xmmword_80CA9D0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v37)),
                                          (__m128i)xmmword_80CA9F0));
                                v31 = _mm_cmpeq_epi8(v31, v40);
                                v21 = _mm_movemask_epi8(
                                        _mm_sub_epi8(
                                          _mm_cmpeq_epi8(
                                            v40,
                                            _mm_or_si128(
                                              v39,
                                              _mm_and_si128(
                                                _mm_and_si128(
                                                  _mm_cmpgt_epi8(v39, (__m128i)xmmword_80CA9D0),
                                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v39)),
                                                (__m128i)xmmword_80CA9F0))),
                                          v31))
                                    - 0xFFFF;
                                if ( v21 )
                                  goto LABEL_244;
                                v259 = v5 <= 0x10;
                                v5 -= 16;
                                if ( v259 )
                                  return 0;
                                v10 += 16;
                                v30 = v38;
                              }
                            }
                            v45 = _mm_load_si128(v12);
                            v46 = _mm_slli_si128(_mm_load_si128(v13), 14);
                            v47 = (unsigned int)_mm_movemask_epi8(
                                                  _mm_sub_epi8(
                                                    _mm_cmpeq_epi8(
                                                      _mm_or_si128(
                                                        v46,
                                                        _mm_and_si128(
                                                          _mm_and_si128(
                                                            _mm_cmpgt_epi8(v46, (__m128i)xmmword_80CA9D0),
                                                            _mm_cmpgt_epi8(
                                                              _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                              v46)),
                                                          (__m128i)xmmword_80CA9F0)),
                                                      _mm_or_si128(
                                                        v45,
                                                        _mm_and_si128(
                                                          _mm_and_si128(
                                                            _mm_cmpgt_epi8(v45, (__m128i)xmmword_80CA9D0),
                                                            _mm_cmpgt_epi8(
                                                              _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                              v45)),
                                                          (__m128i)xmmword_80CA9F0))),
                                                    _mm_cmpeq_epi8((__m128i)0LL, v45))) >> v10;
                            v21 = (0xFFFFu >> v10) - v47;
                            v17 = 0xFFFFu >> v10 == v47;
                            v22 = v10 - 14;
                            if ( !v17 )
                              goto LABEL_245;
                            if ( v5 <= 16 - v10 )
                              return 0;
                            v5 -= 16 - v10;
                            v48 = _mm_load_si128(v13);
                            v49 = 0LL;
                            v10 = 16;
                            v288 |= 2u;
                            v50 = (((_WORD)v13 + 2) & 0xFFF) - 4096;
                            while ( 1 )
                            {
                              v259 = (v50 + 16 < 0) ^ __OFADD__(16, v50) | (v50 == -16);
                              v50 += 16;
                              if ( !v259 )
                                goto LABEL_57;
                              while ( 1 )
                              {
                                v51 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                                v52 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                                v53 = _mm_alignr_epi8(v52, v48, 2);
                                v54 = _mm_or_si128(
                                        v51,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v51, (__m128i)xmmword_80CA9D0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v51)),
                                          (__m128i)xmmword_80CA9F0));
                                v49 = _mm_cmpeq_epi8(v49, v54);
                                v21 = _mm_movemask_epi8(
                                        _mm_sub_epi8(
                                          _mm_cmpeq_epi8(
                                            v54,
                                            _mm_or_si128(
                                              v53,
                                              _mm_and_si128(
                                                _mm_and_si128(
                                                  _mm_cmpgt_epi8(v53, (__m128i)xmmword_80CA9D0),
                                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v53)),
                                                (__m128i)xmmword_80CA9F0))),
                                          v49))
                                    - 0xFFFF;
                                if ( v21 )
                                  goto LABEL_244;
                                v259 = v5 <= 0x10;
                                v5 -= 16;
                                if ( v259 )
                                  return 0;
                                v10 += 16;
                                v48 = v52;
                                v259 = (v50 + 16 < 0) ^ __OFADD__(16, v50) | (v50 == -16);
                                v50 += 16;
                                if ( v259 )
                                  break;
LABEL_57:
                                v59 = _mm_cmpeq_epi8(v49, v48);
                                if ( (_mm_movemask_epi8(v59) & 0xFFFC) != 0 || v5 <= 0xE )
                                {
                                  v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                                  v43 = _mm_srli_si128(v59, 2);
                                  v44 = _mm_srli_si128(v48, 2);
                                  goto LABEL_243;
                                }
                                v49 = 0LL;
                                v50 -= 4096;
                              }
                              v55 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                              v56 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                              v57 = _mm_alignr_epi8(v56, v48, 2);
                              v58 = _mm_or_si128(
                                      v55,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v55, (__m128i)xmmword_80CA9D0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v55)),
                                        (__m128i)xmmword_80CA9F0));
                              v49 = _mm_cmpeq_epi8(v49, v58);
                              v21 = _mm_movemask_epi8(
                                      _mm_sub_epi8(
                                        _mm_cmpeq_epi8(
                                          v58,
                                          _mm_or_si128(
                                            v57,
                                            _mm_and_si128(
                                              _mm_and_si128(
                                                _mm_cmpgt_epi8(v57, (__m128i)xmmword_80CA9D0),
                                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v57)),
                                              (__m128i)xmmword_80CA9F0))),
                                        v49))
                                  - 0xFFFF;
                              if ( v21 )
                                goto LABEL_244;
                              v259 = v5 <= 0x10;
                              v5 -= 16;
                              if ( v259 )
                                return 0;
                              v10 += 16;
                              v48 = v56;
                            }
                          }
                          v60 = _mm_load_si128(v12);
                          v61 = _mm_slli_si128(_mm_load_si128(v13), 13);
                          v62 = (unsigned int)_mm_movemask_epi8(
                                                _mm_sub_epi8(
                                                  _mm_cmpeq_epi8(
                                                    _mm_or_si128(
                                                      v61,
                                                      _mm_and_si128(
                                                        _mm_and_si128(
                                                          _mm_cmpgt_epi8(v61, (__m128i)xmmword_80CA9D0),
                                                          _mm_cmpgt_epi8(
                                                            _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                            v61)),
                                                        (__m128i)xmmword_80CA9F0)),
                                                    _mm_or_si128(
                                                      v60,
                                                      _mm_and_si128(
                                                        _mm_and_si128(
                                                          _mm_cmpgt_epi8(v60, (__m128i)xmmword_80CA9D0),
                                                          _mm_cmpgt_epi8(
                                                            _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                            v60)),
                                                        (__m128i)xmmword_80CA9F0))),
                                                  _mm_cmpeq_epi8((__m128i)0LL, v60))) >> v10;
                          v21 = (0xFFFFu >> v10) - v62;
                          v17 = 0xFFFFu >> v10 == v62;
                          v22 = v10 - 13;
                          if ( !v17 )
                            goto LABEL_245;
                          if ( v5 <= 16 - v10 )
                            return 0;
                          v5 -= 16 - v10;
                          v63 = _mm_load_si128(v13);
                          v64 = 0LL;
                          v10 = 16;
                          v288 |= 3u;
                          v65 = (((_WORD)v13 + 3) & 0xFFF) - 4096;
                          while ( 1 )
                          {
                            v259 = (v65 + 16 < 0) ^ __OFADD__(16, v65) | (v65 == -16);
                            v65 += 16;
                            if ( !v259 )
                              goto LABEL_71;
                            while ( 1 )
                            {
                              v66 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                              v67 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                              v68 = _mm_alignr_epi8(v67, v63, 3);
                              v69 = _mm_or_si128(
                                      v66,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v66, (__m128i)xmmword_80CA9D0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v66)),
                                        (__m128i)xmmword_80CA9F0));
                              v64 = _mm_cmpeq_epi8(v64, v69);
                              v21 = _mm_movemask_epi8(
                                      _mm_sub_epi8(
                                        _mm_cmpeq_epi8(
                                          v69,
                                          _mm_or_si128(
                                            v68,
                                            _mm_and_si128(
                                              _mm_and_si128(
                                                _mm_cmpgt_epi8(v68, (__m128i)xmmword_80CA9D0),
                                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v68)),
                                              (__m128i)xmmword_80CA9F0))),
                                        v64))
                                  - 0xFFFF;
                              if ( v21 )
                                goto LABEL_244;
                              v259 = v5 <= 0x10;
                              v5 -= 16;
                              if ( v259 )
                                return 0;
                              v10 += 16;
                              v63 = v67;
                              v259 = (v65 + 16 < 0) ^ __OFADD__(16, v65) | (v65 == -16);
                              v65 += 16;
                              if ( v259 )
                                break;
LABEL_71:
                              v74 = _mm_cmpeq_epi8(v64, v63);
                              if ( (_mm_movemask_epi8(v74) & 0xFFF8) != 0 || v5 <= 0xD )
                              {
                                v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                                v43 = _mm_srli_si128(v74, 3);
                                v44 = _mm_srli_si128(v63, 3);
                                goto LABEL_243;
                              }
                              v64 = 0LL;
                              v65 -= 4096;
                            }
                            v70 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                            v71 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                            v72 = _mm_alignr_epi8(v71, v63, 3);
                            v73 = _mm_or_si128(
                                    v70,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v70, (__m128i)xmmword_80CA9D0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v70)),
                                      (__m128i)xmmword_80CA9F0));
                            v64 = _mm_cmpeq_epi8(v64, v73);
                            v21 = _mm_movemask_epi8(
                                    _mm_sub_epi8(
                                      _mm_cmpeq_epi8(
                                        v73,
                                        _mm_or_si128(
                                          v72,
                                          _mm_and_si128(
                                            _mm_and_si128(
                                              _mm_cmpgt_epi8(v72, (__m128i)xmmword_80CA9D0),
                                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v72)),
                                            (__m128i)xmmword_80CA9F0))),
                                      v64))
                                - 0xFFFF;
                            if ( v21 )
                              goto LABEL_244;
                            v259 = v5 <= 0x10;
                            v5 -= 16;
                            if ( v259 )
                              return 0;
                            v10 += 16;
                            v63 = v71;
                          }
                        }
                        v75 = _mm_load_si128(v12);
                        v76 = _mm_slli_si128(_mm_load_si128(v13), 12);
                        v77 = (unsigned int)_mm_movemask_epi8(
                                              _mm_sub_epi8(
                                                _mm_cmpeq_epi8(
                                                  _mm_or_si128(
                                                    v76,
                                                    _mm_and_si128(
                                                      _mm_and_si128(
                                                        _mm_cmpgt_epi8(v76, (__m128i)xmmword_80CA9D0),
                                                        _mm_cmpgt_epi8(
                                                          _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                          v76)),
                                                      (__m128i)xmmword_80CA9F0)),
                                                  _mm_or_si128(
                                                    v75,
                                                    _mm_and_si128(
                                                      _mm_and_si128(
                                                        _mm_cmpgt_epi8(v75, (__m128i)xmmword_80CA9D0),
                                                        _mm_cmpgt_epi8(
                                                          _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                          v75)),
                                                      (__m128i)xmmword_80CA9F0))),
                                                _mm_cmpeq_epi8((__m128i)0LL, v75))) >> v10;
                        v21 = (0xFFFFu >> v10) - v77;
                        v17 = 0xFFFFu >> v10 == v77;
                        v22 = v10 - 12;
                        if ( !v17 )
                          goto LABEL_245;
                        if ( v5 <= 16 - v10 )
                          return 0;
                        v5 -= 16 - v10;
                        v78 = _mm_load_si128(v13);
                        v79 = 0LL;
                        v10 = 16;
                        v288 |= 4u;
                        v80 = (((_WORD)v13 + 4) & 0xFFF) - 4096;
                        while ( 1 )
                        {
                          v259 = (v80 + 16 < 0) ^ __OFADD__(16, v80) | (v80 == -16);
                          v80 += 16;
                          if ( !v259 )
                            goto LABEL_85;
                          while ( 1 )
                          {
                            v81 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                            v82 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                            v83 = _mm_alignr_epi8(v82, v78, 4);
                            v84 = _mm_or_si128(
                                    v81,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v81, (__m128i)xmmword_80CA9D0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v81)),
                                      (__m128i)xmmword_80CA9F0));
                            v79 = _mm_cmpeq_epi8(v79, v84);
                            v21 = _mm_movemask_epi8(
                                    _mm_sub_epi8(
                                      _mm_cmpeq_epi8(
                                        v84,
                                        _mm_or_si128(
                                          v83,
                                          _mm_and_si128(
                                            _mm_and_si128(
                                              _mm_cmpgt_epi8(v83, (__m128i)xmmword_80CA9D0),
                                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v83)),
                                            (__m128i)xmmword_80CA9F0))),
                                      v79))
                                - 0xFFFF;
                            if ( v21 )
                              goto LABEL_244;
                            v259 = v5 <= 0x10;
                            v5 -= 16;
                            if ( v259 )
                              return 0;
                            v10 += 16;
                            v78 = v82;
                            v259 = (v80 + 16 < 0) ^ __OFADD__(16, v80) | (v80 == -16);
                            v80 += 16;
                            if ( v259 )
                              break;
LABEL_85:
                            v89 = _mm_cmpeq_epi8(v79, v78);
                            if ( (_mm_movemask_epi8(v89) & 0xFFF0) != 0 || v5 <= 0xC )
                            {
                              v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                              v43 = _mm_srli_si128(v89, 4);
                              v44 = _mm_srli_si128(v78, 4);
                              goto LABEL_243;
                            }
                            v79 = 0LL;
                            v80 -= 4096;
                          }
                          v85 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                          v86 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                          v87 = _mm_alignr_epi8(v86, v78, 4);
                          v88 = _mm_or_si128(
                                  v85,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v85, (__m128i)xmmword_80CA9D0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v85)),
                                    (__m128i)xmmword_80CA9F0));
                          v79 = _mm_cmpeq_epi8(v79, v88);
                          v21 = _mm_movemask_epi8(
                                  _mm_sub_epi8(
                                    _mm_cmpeq_epi8(
                                      v88,
                                      _mm_or_si128(
                                        v87,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v87, (__m128i)xmmword_80CA9D0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v87)),
                                          (__m128i)xmmword_80CA9F0))),
                                    v79))
                              - 0xFFFF;
                          if ( v21 )
                            goto LABEL_244;
                          v259 = v5 <= 0x10;
                          v5 -= 16;
                          if ( v259 )
                            return 0;
                          v10 += 16;
                          v78 = v86;
                        }
                      }
                      v90 = _mm_load_si128(v12);
                      v91 = _mm_slli_si128(_mm_load_si128(v13), 11);
                      v92 = (unsigned int)_mm_movemask_epi8(
                                            _mm_sub_epi8(
                                              _mm_cmpeq_epi8(
                                                _mm_or_si128(
                                                  v91,
                                                  _mm_and_si128(
                                                    _mm_and_si128(
                                                      _mm_cmpgt_epi8(v91, (__m128i)xmmword_80CA9D0),
                                                      _mm_cmpgt_epi8(
                                                        _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                        v91)),
                                                    (__m128i)xmmword_80CA9F0)),
                                                _mm_or_si128(
                                                  v90,
                                                  _mm_and_si128(
                                                    _mm_and_si128(
                                                      _mm_cmpgt_epi8(v90, (__m128i)xmmword_80CA9D0),
                                                      _mm_cmpgt_epi8(
                                                        _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                        v90)),
                                                    (__m128i)xmmword_80CA9F0))),
                                              _mm_cmpeq_epi8((__m128i)0LL, v90))) >> v10;
                      v21 = (0xFFFFu >> v10) - v92;
                      v17 = 0xFFFFu >> v10 == v92;
                      v22 = v10 - 11;
                      if ( !v17 )
                        goto LABEL_245;
                      if ( v5 <= 16 - v10 )
                        return 0;
                      v5 -= 16 - v10;
                      v93 = _mm_load_si128(v13);
                      v94 = 0LL;
                      v10 = 16;
                      v288 |= 5u;
                      v95 = (((_WORD)v13 + 5) & 0xFFF) - 4096;
                      while ( 1 )
                      {
                        v259 = (v95 + 16 < 0) ^ __OFADD__(16, v95) | (v95 == -16);
                        v95 += 16;
                        if ( !v259 )
                          goto LABEL_99;
                        while ( 1 )
                        {
                          v96 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                          v97 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                          v98 = _mm_alignr_epi8(v97, v93, 5);
                          v99 = _mm_or_si128(
                                  v96,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v96, (__m128i)xmmword_80CA9D0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v96)),
                                    (__m128i)xmmword_80CA9F0));
                          v94 = _mm_cmpeq_epi8(v94, v99);
                          v21 = _mm_movemask_epi8(
                                  _mm_sub_epi8(
                                    _mm_cmpeq_epi8(
                                      v99,
                                      _mm_or_si128(
                                        v98,
                                        _mm_and_si128(
                                          _mm_and_si128(
                                            _mm_cmpgt_epi8(v98, (__m128i)xmmword_80CA9D0),
                                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v98)),
                                          (__m128i)xmmword_80CA9F0))),
                                    v94))
                              - 0xFFFF;
                          if ( v21 )
                            goto LABEL_244;
                          v259 = v5 <= 0x10;
                          v5 -= 16;
                          if ( v259 )
                            return 0;
                          v10 += 16;
                          v93 = v97;
                          v259 = (v95 + 16 < 0) ^ __OFADD__(16, v95) | (v95 == -16);
                          v95 += 16;
                          if ( v259 )
                            break;
LABEL_99:
                          v104 = _mm_cmpeq_epi8(v94, v93);
                          if ( (_mm_movemask_epi8(v104) & 0xFFE0) != 0 || v5 <= 0xB )
                          {
                            v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                            v43 = _mm_srli_si128(v104, 5);
                            v44 = _mm_srli_si128(v93, 5);
                            goto LABEL_243;
                          }
                          v94 = 0LL;
                          v95 -= 4096;
                        }
                        v100 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                        v101 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                        v102 = _mm_alignr_epi8(v101, v93, 5);
                        v103 = _mm_or_si128(
                                 v100,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v100, (__m128i)xmmword_80CA9D0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v100)),
                                   (__m128i)xmmword_80CA9F0));
                        v94 = _mm_cmpeq_epi8(v94, v103);
                        v21 = _mm_movemask_epi8(
                                _mm_sub_epi8(
                                  _mm_cmpeq_epi8(
                                    v103,
                                    _mm_or_si128(
                                      v102,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v102, (__m128i)xmmword_80CA9D0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v102)),
                                        (__m128i)xmmword_80CA9F0))),
                                  v94))
                            - 0xFFFF;
                        if ( v21 )
                          goto LABEL_244;
                        v259 = v5 <= 0x10;
                        v5 -= 16;
                        if ( v259 )
                          return 0;
                        v10 += 16;
                        v93 = v101;
                      }
                    }
                    v105 = _mm_load_si128(v12);
                    v106 = _mm_slli_si128(_mm_load_si128(v13), 10);
                    v107 = (unsigned int)_mm_movemask_epi8(
                                           _mm_sub_epi8(
                                             _mm_cmpeq_epi8(
                                               _mm_or_si128(
                                                 v106,
                                                 _mm_and_si128(
                                                   _mm_and_si128(
                                                     _mm_cmpgt_epi8(v106, (__m128i)xmmword_80CA9D0),
                                                     _mm_cmpgt_epi8(
                                                       _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                       v106)),
                                                   (__m128i)xmmword_80CA9F0)),
                                               _mm_or_si128(
                                                 v105,
                                                 _mm_and_si128(
                                                   _mm_and_si128(
                                                     _mm_cmpgt_epi8(v105, (__m128i)xmmword_80CA9D0),
                                                     _mm_cmpgt_epi8(
                                                       _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                       v105)),
                                                   (__m128i)xmmword_80CA9F0))),
                                             _mm_cmpeq_epi8((__m128i)0LL, v105))) >> v10;
                    v21 = (0xFFFFu >> v10) - v107;
                    v17 = 0xFFFFu >> v10 == v107;
                    v22 = v10 - 10;
                    if ( !v17 )
                      goto LABEL_245;
                    if ( v5 <= 16 - v10 )
                      return 0;
                    v5 -= 16 - v10;
                    v108 = _mm_load_si128(v13);
                    v109 = 0LL;
                    v10 = 16;
                    v288 |= 6u;
                    v110 = (((_WORD)v13 + 6) & 0xFFF) - 4096;
                    while ( 1 )
                    {
                      v259 = (v110 + 16 < 0) ^ __OFADD__(16, v110) | (v110 == -16);
                      v110 += 16;
                      if ( !v259 )
                        goto LABEL_113;
                      while ( 1 )
                      {
                        v111 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                        v112 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                        v113 = _mm_alignr_epi8(v112, v108, 6);
                        v114 = _mm_or_si128(
                                 v111,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v111, (__m128i)xmmword_80CA9D0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v111)),
                                   (__m128i)xmmword_80CA9F0));
                        v109 = _mm_cmpeq_epi8(v109, v114);
                        v21 = _mm_movemask_epi8(
                                _mm_sub_epi8(
                                  _mm_cmpeq_epi8(
                                    v114,
                                    _mm_or_si128(
                                      v113,
                                      _mm_and_si128(
                                        _mm_and_si128(
                                          _mm_cmpgt_epi8(v113, (__m128i)xmmword_80CA9D0),
                                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v113)),
                                        (__m128i)xmmword_80CA9F0))),
                                  v109))
                            - 0xFFFF;
                        if ( v21 )
                          goto LABEL_244;
                        v259 = v5 <= 0x10;
                        v5 -= 16;
                        if ( v259 )
                          return 0;
                        v10 += 16;
                        v108 = v112;
                        v259 = (v110 + 16 < 0) ^ __OFADD__(16, v110) | (v110 == -16);
                        v110 += 16;
                        if ( v259 )
                          break;
LABEL_113:
                        v119 = _mm_cmpeq_epi8(v109, v108);
                        if ( (_mm_movemask_epi8(v119) & 0xFFC0) != 0 || v5 <= 0xA )
                        {
                          v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                          v43 = _mm_srli_si128(v119, 6);
                          v44 = _mm_srli_si128(v108, 6);
                          goto LABEL_243;
                        }
                        v109 = 0LL;
                        v110 -= 4096;
                      }
                      v115 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                      v116 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                      v117 = _mm_alignr_epi8(v116, v108, 6);
                      v118 = _mm_or_si128(
                               v115,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v115, (__m128i)xmmword_80CA9D0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v115)),
                                 (__m128i)xmmword_80CA9F0));
                      v109 = _mm_cmpeq_epi8(v109, v118);
                      v21 = _mm_movemask_epi8(
                              _mm_sub_epi8(
                                _mm_cmpeq_epi8(
                                  v118,
                                  _mm_or_si128(
                                    v117,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v117, (__m128i)xmmword_80CA9D0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v117)),
                                      (__m128i)xmmword_80CA9F0))),
                                v109))
                          - 0xFFFF;
                      if ( v21 )
                        goto LABEL_244;
                      v259 = v5 <= 0x10;
                      v5 -= 16;
                      if ( v259 )
                        return 0;
                      v10 += 16;
                      v108 = v116;
                    }
                  }
                  v120 = _mm_load_si128(v12);
                  v121 = _mm_slli_si128(_mm_load_si128(v13), 9);
                  v122 = (unsigned int)_mm_movemask_epi8(
                                         _mm_sub_epi8(
                                           _mm_cmpeq_epi8(
                                             _mm_or_si128(
                                               v121,
                                               _mm_and_si128(
                                                 _mm_and_si128(
                                                   _mm_cmpgt_epi8(v121, (__m128i)xmmword_80CA9D0),
                                                   _mm_cmpgt_epi8(
                                                     _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                     v121)),
                                                 (__m128i)xmmword_80CA9F0)),
                                             _mm_or_si128(
                                               v120,
                                               _mm_and_si128(
                                                 _mm_and_si128(
                                                   _mm_cmpgt_epi8(v120, (__m128i)xmmword_80CA9D0),
                                                   _mm_cmpgt_epi8(
                                                     _mm_load_si128((const __m128i *)&xmmword_80CA9E0),
                                                     v120)),
                                                 (__m128i)xmmword_80CA9F0))),
                                           _mm_cmpeq_epi8((__m128i)0LL, v120))) >> v10;
                  v21 = (0xFFFFu >> v10) - v122;
                  v17 = 0xFFFFu >> v10 == v122;
                  v22 = v10 - 9;
                  if ( !v17 )
                    goto LABEL_245;
                  if ( v5 <= 16 - v10 )
                    return 0;
                  v5 -= 16 - v10;
                  v123 = _mm_load_si128(v13);
                  v124 = 0LL;
                  v10 = 16;
                  v288 |= 7u;
                  v125 = (((_WORD)v13 + 8) & 0xFFF) - 4096;
                  while ( 1 )
                  {
                    v259 = (v125 + 16 < 0) ^ __OFADD__(16, v125) | (v125 == -16);
                    v125 += 16;
                    if ( !v259 )
                      goto LABEL_127;
                    while ( 1 )
                    {
                      v126 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                      v127 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                      v128 = _mm_alignr_epi8(v127, v123, 7);
                      v129 = _mm_or_si128(
                               v126,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v126, (__m128i)xmmword_80CA9D0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v126)),
                                 (__m128i)xmmword_80CA9F0));
                      v124 = _mm_cmpeq_epi8(v124, v129);
                      v21 = _mm_movemask_epi8(
                              _mm_sub_epi8(
                                _mm_cmpeq_epi8(
                                  v129,
                                  _mm_or_si128(
                                    v128,
                                    _mm_and_si128(
                                      _mm_and_si128(
                                        _mm_cmpgt_epi8(v128, (__m128i)xmmword_80CA9D0),
                                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v128)),
                                      (__m128i)xmmword_80CA9F0))),
                                v124))
                          - 0xFFFF;
                      if ( v21 )
                        goto LABEL_244;
                      v259 = v5 <= 0x10;
                      v5 -= 16;
                      if ( v259 )
                        return 0;
                      v10 += 16;
                      v123 = v127;
                      v259 = (v125 + 16 < 0) ^ __OFADD__(16, v125) | (v125 == -16);
                      v125 += 16;
                      if ( v259 )
                        break;
LABEL_127:
                      v134 = _mm_cmpeq_epi8(v124, v123);
                      if ( (_mm_movemask_epi8(v134) & 0xFF80) != 0 || v5 <= 9 )
                      {
                        v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                        v43 = _mm_srli_si128(v134, 7);
                        v44 = _mm_srli_si128(v123, 7);
                        goto LABEL_243;
                      }
                      v124 = 0LL;
                      v125 -= 4096;
                    }
                    v130 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                    v131 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                    v132 = _mm_alignr_epi8(v131, v123, 7);
                    v133 = _mm_or_si128(
                             v130,
                             _mm_and_si128(
                               _mm_and_si128(
                                 _mm_cmpgt_epi8(v130, (__m128i)xmmword_80CA9D0),
                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v130)),
                               (__m128i)xmmword_80CA9F0));
                    v124 = _mm_cmpeq_epi8(v124, v133);
                    v21 = _mm_movemask_epi8(
                            _mm_sub_epi8(
                              _mm_cmpeq_epi8(
                                v133,
                                _mm_or_si128(
                                  v132,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v132, (__m128i)xmmword_80CA9D0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v132)),
                                    (__m128i)xmmword_80CA9F0))),
                              v124))
                        - 0xFFFF;
                    if ( v21 )
                      goto LABEL_244;
                    v259 = v5 <= 0x10;
                    v5 -= 16;
                    if ( v259 )
                      return 0;
                    v10 += 16;
                    v123 = v131;
                  }
                }
                v135 = _mm_load_si128(v12);
                v136 = _mm_slli_si128(_mm_load_si128(v13), 8);
                v137 = (unsigned int)_mm_movemask_epi8(
                                       _mm_sub_epi8(
                                         _mm_cmpeq_epi8(
                                           _mm_or_si128(
                                             v136,
                                             _mm_and_si128(
                                               _mm_and_si128(
                                                 _mm_cmpgt_epi8(v136, (__m128i)xmmword_80CA9D0),
                                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v136)),
                                               (__m128i)xmmword_80CA9F0)),
                                           _mm_or_si128(
                                             v135,
                                             _mm_and_si128(
                                               _mm_and_si128(
                                                 _mm_cmpgt_epi8(v135, (__m128i)xmmword_80CA9D0),
                                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v135)),
                                               (__m128i)xmmword_80CA9F0))),
                                         _mm_cmpeq_epi8((__m128i)0LL, v135))) >> v10;
                v21 = (0xFFFFu >> v10) - v137;
                v17 = 0xFFFFu >> v10 == v137;
                v22 = v10 - 8;
                if ( !v17 )
                  goto LABEL_245;
                if ( v5 <= 16 - v10 )
                  return 0;
                v5 -= 16 - v10;
                v138 = _mm_load_si128(v13);
                v139 = 0LL;
                v10 = 16;
                v288 |= 8u;
                v140 = (((_WORD)v13 + 8) & 0xFFF) - 4096;
                while ( 1 )
                {
                  v259 = (v140 + 16 < 0) ^ __OFADD__(16, v140) | (v140 == -16);
                  v140 += 16;
                  if ( !v259 )
                    goto LABEL_141;
                  while ( 1 )
                  {
                    v141 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                    v142 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                    v143 = _mm_alignr_epi8(v142, v138, 8);
                    v144 = _mm_or_si128(
                             v141,
                             _mm_and_si128(
                               _mm_and_si128(
                                 _mm_cmpgt_epi8(v141, (__m128i)xmmword_80CA9D0),
                                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v141)),
                               (__m128i)xmmword_80CA9F0));
                    v139 = _mm_cmpeq_epi8(v139, v144);
                    v21 = _mm_movemask_epi8(
                            _mm_sub_epi8(
                              _mm_cmpeq_epi8(
                                v144,
                                _mm_or_si128(
                                  v143,
                                  _mm_and_si128(
                                    _mm_and_si128(
                                      _mm_cmpgt_epi8(v143, (__m128i)xmmword_80CA9D0),
                                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v143)),
                                    (__m128i)xmmword_80CA9F0))),
                              v139))
                        - 0xFFFF;
                    if ( v21 )
                      goto LABEL_244;
                    v259 = v5 <= 0x10;
                    v5 -= 16;
                    if ( v259 )
                      return 0;
                    v10 += 16;
                    v138 = v142;
                    v259 = (v140 + 16 < 0) ^ __OFADD__(16, v140) | (v140 == -16);
                    v140 += 16;
                    if ( v259 )
                      break;
LABEL_141:
                    v149 = _mm_cmpeq_epi8(v139, v138);
                    if ( (_mm_movemask_epi8(v149) & 0xFF00) != 0 || v5 <= 8 )
                    {
                      v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                      v43 = _mm_srli_si128(v149, 8);
                      v44 = _mm_srli_si128(v138, 8);
                      goto LABEL_243;
                    }
                    v139 = 0LL;
                    v140 -= 4096;
                  }
                  v145 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                  v146 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                  v147 = _mm_alignr_epi8(v146, v138, 8);
                  v148 = _mm_or_si128(
                           v145,
                           _mm_and_si128(
                             _mm_and_si128(
                               _mm_cmpgt_epi8(v145, (__m128i)xmmword_80CA9D0),
                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v145)),
                             (__m128i)xmmword_80CA9F0));
                  v139 = _mm_cmpeq_epi8(v139, v148);
                  v21 = _mm_movemask_epi8(
                          _mm_sub_epi8(
                            _mm_cmpeq_epi8(
                              v148,
                              _mm_or_si128(
                                v147,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(v147, (__m128i)xmmword_80CA9D0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v147)),
                                  (__m128i)xmmword_80CA9F0))),
                            v139))
                      - 0xFFFF;
                  if ( v21 )
                    goto LABEL_244;
                  v259 = v5 <= 0x10;
                  v5 -= 16;
                  if ( v259 )
                    return 0;
                  v10 += 16;
                  v138 = v146;
                }
              }
              v150 = _mm_load_si128(v12);
              v151 = _mm_slli_si128(_mm_load_si128(v13), 7);
              v152 = (unsigned int)_mm_movemask_epi8(
                                     _mm_sub_epi8(
                                       _mm_cmpeq_epi8(
                                         _mm_or_si128(
                                           v151,
                                           _mm_and_si128(
                                             _mm_and_si128(
                                               _mm_cmpgt_epi8(v151, (__m128i)xmmword_80CA9D0),
                                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v151)),
                                             (__m128i)xmmword_80CA9F0)),
                                         _mm_or_si128(
                                           v150,
                                           _mm_and_si128(
                                             _mm_and_si128(
                                               _mm_cmpgt_epi8(v150, (__m128i)xmmword_80CA9D0),
                                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v150)),
                                             (__m128i)xmmword_80CA9F0))),
                                       _mm_cmpeq_epi8((__m128i)0LL, v150))) >> v10;
              v21 = (0xFFFFu >> v10) - v152;
              v17 = 0xFFFFu >> v10 == v152;
              v22 = v10 - 7;
              if ( !v17 )
                goto LABEL_245;
              if ( v5 <= 16 - v10 )
                return 0;
              v5 -= 16 - v10;
              v153 = _mm_load_si128(v13);
              v154 = 0LL;
              v10 = 16;
              v288 |= 9u;
              v155 = (((_WORD)v13 + 9) & 0xFFF) - 4096;
              while ( 1 )
              {
                v259 = (v155 + 16 < 0) ^ __OFADD__(16, v155) | (v155 == -16);
                v155 += 16;
                if ( !v259 )
                  goto LABEL_155;
                while ( 1 )
                {
                  v156 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                  v157 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                  v158 = _mm_alignr_epi8(v157, v153, 9);
                  v159 = _mm_or_si128(
                           v156,
                           _mm_and_si128(
                             _mm_and_si128(
                               _mm_cmpgt_epi8(v156, (__m128i)xmmword_80CA9D0),
                               _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v156)),
                             (__m128i)xmmword_80CA9F0));
                  v154 = _mm_cmpeq_epi8(v154, v159);
                  v21 = _mm_movemask_epi8(
                          _mm_sub_epi8(
                            _mm_cmpeq_epi8(
                              v159,
                              _mm_or_si128(
                                v158,
                                _mm_and_si128(
                                  _mm_and_si128(
                                    _mm_cmpgt_epi8(v158, (__m128i)xmmword_80CA9D0),
                                    _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v158)),
                                  (__m128i)xmmword_80CA9F0))),
                            v154))
                      - 0xFFFF;
                  if ( v21 )
                    goto LABEL_244;
                  v259 = v5 <= 0x10;
                  v5 -= 16;
                  if ( v259 )
                    return 0;
                  v10 += 16;
                  v153 = v157;
                  v259 = (v155 + 16 < 0) ^ __OFADD__(16, v155) | (v155 == -16);
                  v155 += 16;
                  if ( v259 )
                    break;
LABEL_155:
                  v164 = _mm_cmpeq_epi8(v154, v153);
                  if ( (_mm_movemask_epi8(v164) & 0xFE00) != 0 || v5 <= 7 )
                  {
                    v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                    v43 = _mm_srli_si128(v164, 9);
                    v44 = _mm_srli_si128(v153, 9);
                    goto LABEL_243;
                  }
                  v154 = 0LL;
                  v155 -= 4096;
                }
                v160 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                v161 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                v162 = _mm_alignr_epi8(v161, v153, 9);
                v163 = _mm_or_si128(
                         v160,
                         _mm_and_si128(
                           _mm_and_si128(
                             _mm_cmpgt_epi8(v160, (__m128i)xmmword_80CA9D0),
                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v160)),
                           (__m128i)xmmword_80CA9F0));
                v154 = _mm_cmpeq_epi8(v154, v163);
                v21 = _mm_movemask_epi8(
                        _mm_sub_epi8(
                          _mm_cmpeq_epi8(
                            v163,
                            _mm_or_si128(
                              v162,
                              _mm_and_si128(
                                _mm_and_si128(
                                  _mm_cmpgt_epi8(v162, (__m128i)xmmword_80CA9D0),
                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v162)),
                                (__m128i)xmmword_80CA9F0))),
                          v154))
                    - 0xFFFF;
                if ( v21 )
                  goto LABEL_244;
                v259 = v5 <= 0x10;
                v5 -= 16;
                if ( v259 )
                  return 0;
                v10 += 16;
                v153 = v161;
              }
            }
            v165 = _mm_load_si128(v12);
            v166 = _mm_slli_si128(_mm_load_si128(v13), 6);
            v167 = (unsigned int)_mm_movemask_epi8(
                                   _mm_sub_epi8(
                                     _mm_cmpeq_epi8(
                                       _mm_or_si128(
                                         v166,
                                         _mm_and_si128(
                                           _mm_and_si128(
                                             _mm_cmpgt_epi8(v166, (__m128i)xmmword_80CA9D0),
                                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v166)),
                                           (__m128i)xmmword_80CA9F0)),
                                       _mm_or_si128(
                                         v165,
                                         _mm_and_si128(
                                           _mm_and_si128(
                                             _mm_cmpgt_epi8(v165, (__m128i)xmmword_80CA9D0),
                                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v165)),
                                           (__m128i)xmmword_80CA9F0))),
                                     _mm_cmpeq_epi8((__m128i)0LL, v165))) >> v10;
            v21 = (0xFFFFu >> v10) - v167;
            v17 = 0xFFFFu >> v10 == v167;
            v22 = v10 - 6;
            if ( !v17 )
              goto LABEL_245;
            if ( v5 <= 16 - v10 )
              return 0;
            v5 -= 16 - v10;
            v168 = _mm_load_si128(v13);
            v169 = 0LL;
            v10 = 16;
            v288 |= 0xAu;
            v170 = (((_WORD)v13 + 10) & 0xFFF) - 4096;
            while ( 1 )
            {
              v259 = (v170 + 16 < 0) ^ __OFADD__(16, v170) | (v170 == -16);
              v170 += 16;
              if ( !v259 )
                goto LABEL_169;
              while ( 1 )
              {
                v171 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                v172 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
                v173 = _mm_alignr_epi8(v172, v168, 10);
                v174 = _mm_or_si128(
                         v171,
                         _mm_and_si128(
                           _mm_and_si128(
                             _mm_cmpgt_epi8(v171, (__m128i)xmmword_80CA9D0),
                             _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v171)),
                           (__m128i)xmmword_80CA9F0));
                v169 = _mm_cmpeq_epi8(v169, v174);
                v21 = _mm_movemask_epi8(
                        _mm_sub_epi8(
                          _mm_cmpeq_epi8(
                            v174,
                            _mm_or_si128(
                              v173,
                              _mm_and_si128(
                                _mm_and_si128(
                                  _mm_cmpgt_epi8(v173, (__m128i)xmmword_80CA9D0),
                                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v173)),
                                (__m128i)xmmword_80CA9F0))),
                          v169))
                    - 0xFFFF;
                if ( v21 )
                  goto LABEL_244;
                v259 = v5 <= 0x10;
                v5 -= 16;
                if ( v259 )
                  return 0;
                v10 += 16;
                v168 = v172;
                v259 = (v170 + 16 < 0) ^ __OFADD__(16, v170) | (v170 == -16);
                v170 += 16;
                if ( v259 )
                  break;
LABEL_169:
                v179 = _mm_cmpeq_epi8(v169, v168);
                if ( (_mm_movemask_epi8(v179) & 0xFC00) != 0 || v5 <= 6 )
                {
                  v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                  v43 = _mm_srli_si128(v179, 10);
                  v44 = _mm_srli_si128(v168, 10);
                  goto LABEL_243;
                }
                v169 = 0LL;
                v170 -= 4096;
              }
              v175 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
              v176 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
              v177 = _mm_alignr_epi8(v176, v168, 10);
              v178 = _mm_or_si128(
                       v175,
                       _mm_and_si128(
                         _mm_and_si128(
                           _mm_cmpgt_epi8(v175, (__m128i)xmmword_80CA9D0),
                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v175)),
                         (__m128i)xmmword_80CA9F0));
              v169 = _mm_cmpeq_epi8(v169, v178);
              v21 = _mm_movemask_epi8(
                      _mm_sub_epi8(
                        _mm_cmpeq_epi8(
                          v178,
                          _mm_or_si128(
                            v177,
                            _mm_and_si128(
                              _mm_and_si128(
                                _mm_cmpgt_epi8(v177, (__m128i)xmmword_80CA9D0),
                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v177)),
                              (__m128i)xmmword_80CA9F0))),
                        v169))
                  - 0xFFFF;
              if ( v21 )
                goto LABEL_244;
              v259 = v5 <= 0x10;
              v5 -= 16;
              if ( v259 )
                return 0;
              v10 += 16;
              v168 = v176;
            }
          }
          v180 = _mm_load_si128(v12);
          v181 = _mm_slli_si128(_mm_load_si128(v13), 5);
          v182 = (unsigned int)_mm_movemask_epi8(
                                 _mm_sub_epi8(
                                   _mm_cmpeq_epi8(
                                     _mm_or_si128(
                                       v181,
                                       _mm_and_si128(
                                         _mm_and_si128(
                                           _mm_cmpgt_epi8(v181, (__m128i)xmmword_80CA9D0),
                                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v181)),
                                         (__m128i)xmmword_80CA9F0)),
                                     _mm_or_si128(
                                       v180,
                                       _mm_and_si128(
                                         _mm_and_si128(
                                           _mm_cmpgt_epi8(v180, (__m128i)xmmword_80CA9D0),
                                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v180)),
                                         (__m128i)xmmword_80CA9F0))),
                                   _mm_cmpeq_epi8((__m128i)0LL, v180))) >> v10;
          v21 = (0xFFFFu >> v10) - v182;
          v17 = 0xFFFFu >> v10 == v182;
          v22 = v10 - 5;
          if ( !v17 )
            goto LABEL_245;
          if ( v5 <= 16 - v10 )
            return 0;
          v5 -= 16 - v10;
          v183 = _mm_load_si128(v13);
          v184 = 0LL;
          v10 = 16;
          v288 |= 0xBu;
          v185 = (((_WORD)v13 + 11) & 0xFFF) - 4096;
          while ( 1 )
          {
            v259 = (v185 + 16 < 0) ^ __OFADD__(16, v185) | (v185 == -16);
            v185 += 16;
            if ( !v259 )
              goto LABEL_183;
            while ( 1 )
            {
              v186 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
              v187 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
              v188 = _mm_alignr_epi8(v187, v183, 11);
              v189 = _mm_or_si128(
                       v186,
                       _mm_and_si128(
                         _mm_and_si128(
                           _mm_cmpgt_epi8(v186, (__m128i)xmmword_80CA9D0),
                           _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v186)),
                         (__m128i)xmmword_80CA9F0));
              v184 = _mm_cmpeq_epi8(v184, v189);
              v21 = _mm_movemask_epi8(
                      _mm_sub_epi8(
                        _mm_cmpeq_epi8(
                          v189,
                          _mm_or_si128(
                            v188,
                            _mm_and_si128(
                              _mm_and_si128(
                                _mm_cmpgt_epi8(v188, (__m128i)xmmword_80CA9D0),
                                _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v188)),
                              (__m128i)xmmword_80CA9F0))),
                        v184))
                  - 0xFFFF;
              if ( v21 )
                goto LABEL_244;
              v259 = v5 <= 0x10;
              v5 -= 16;
              if ( v259 )
                return 0;
              v10 += 16;
              v183 = v187;
              v259 = (v185 + 16 < 0) ^ __OFADD__(16, v185) | (v185 == -16);
              v185 += 16;
              if ( v259 )
                break;
LABEL_183:
              v194 = _mm_cmpeq_epi8(v184, v183);
              if ( (_mm_movemask_epi8(v194) & 0xF800) != 0 || v5 <= 5 )
              {
                v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
                v43 = _mm_srli_si128(v194, 11);
                v44 = _mm_srli_si128(v183, 11);
                goto LABEL_243;
              }
              v184 = 0LL;
              v185 -= 4096;
            }
            v190 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
            v191 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
            v192 = _mm_alignr_epi8(v191, v183, 11);
            v193 = _mm_or_si128(
                     v190,
                     _mm_and_si128(
                       _mm_and_si128(
                         _mm_cmpgt_epi8(v190, (__m128i)xmmword_80CA9D0),
                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v190)),
                       (__m128i)xmmword_80CA9F0));
            v184 = _mm_cmpeq_epi8(v184, v193);
            v21 = _mm_movemask_epi8(
                    _mm_sub_epi8(
                      _mm_cmpeq_epi8(
                        v193,
                        _mm_or_si128(
                          v192,
                          _mm_and_si128(
                            _mm_and_si128(
                              _mm_cmpgt_epi8(v192, (__m128i)xmmword_80CA9D0),
                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v192)),
                            (__m128i)xmmword_80CA9F0))),
                      v184))
                - 0xFFFF;
            if ( v21 )
              goto LABEL_244;
            v259 = v5 <= 0x10;
            v5 -= 16;
            if ( v259 )
              return 0;
            v10 += 16;
            v183 = v191;
          }
        }
        v195 = _mm_load_si128(v12);
        v196 = _mm_slli_si128(_mm_load_si128(v13), 4);
        v197 = (unsigned int)_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(
                                   _mm_or_si128(
                                     v196,
                                     _mm_and_si128(
                                       _mm_and_si128(
                                         _mm_cmpgt_epi8(v196, (__m128i)xmmword_80CA9D0),
                                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v196)),
                                       (__m128i)xmmword_80CA9F0)),
                                   _mm_or_si128(
                                     v195,
                                     _mm_and_si128(
                                       _mm_and_si128(
                                         _mm_cmpgt_epi8(v195, (__m128i)xmmword_80CA9D0),
                                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v195)),
                                       (__m128i)xmmword_80CA9F0))),
                                 _mm_cmpeq_epi8((__m128i)0LL, v195))) >> v10;
        v21 = (0xFFFFu >> v10) - v197;
        v17 = 0xFFFFu >> v10 == v197;
        v22 = v10 - 4;
        if ( !v17 )
          goto LABEL_245;
        if ( v5 <= 16 - v10 )
          return 0;
        v5 -= 16 - v10;
        v198 = _mm_load_si128(v13);
        v199 = 0LL;
        v10 = 16;
        v288 |= 0xCu;
        v200 = (((_WORD)v13 + 12) & 0xFFF) - 4096;
        while ( 1 )
        {
          v259 = (v200 + 16 < 0) ^ __OFADD__(16, v200) | (v200 == -16);
          v200 += 16;
          if ( !v259 )
            goto LABEL_197;
          while ( 1 )
          {
            v201 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
            v202 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
            v203 = _mm_alignr_epi8(v202, v198, 12);
            v204 = _mm_or_si128(
                     v201,
                     _mm_and_si128(
                       _mm_and_si128(
                         _mm_cmpgt_epi8(v201, (__m128i)xmmword_80CA9D0),
                         _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v201)),
                       (__m128i)xmmword_80CA9F0));
            v199 = _mm_cmpeq_epi8(v199, v204);
            v21 = _mm_movemask_epi8(
                    _mm_sub_epi8(
                      _mm_cmpeq_epi8(
                        v204,
                        _mm_or_si128(
                          v203,
                          _mm_and_si128(
                            _mm_and_si128(
                              _mm_cmpgt_epi8(v203, (__m128i)xmmword_80CA9D0),
                              _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v203)),
                            (__m128i)xmmword_80CA9F0))),
                      v199))
                - 0xFFFF;
            if ( v21 )
              goto LABEL_244;
            v259 = v5 <= 0x10;
            v5 -= 16;
            if ( v259 )
              return 0;
            v10 += 16;
            v198 = v202;
            v259 = (v200 + 16 < 0) ^ __OFADD__(16, v200) | (v200 == -16);
            v200 += 16;
            if ( v259 )
              break;
LABEL_197:
            v209 = _mm_cmpeq_epi8(v199, v198);
            if ( (_mm_movemask_epi8(v209) & 0xF000) != 0 || v5 <= 4 )
            {
              v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
              v43 = _mm_srli_si128(v209, 12);
              v44 = _mm_srli_si128(v198, 12);
              goto LABEL_243;
            }
            v199 = 0LL;
            v200 -= 4096;
          }
          v205 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
          v206 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
          v207 = _mm_alignr_epi8(v206, v198, 12);
          v208 = _mm_or_si128(
                   v205,
                   _mm_and_si128(
                     _mm_and_si128(
                       _mm_cmpgt_epi8(v205, (__m128i)xmmword_80CA9D0),
                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v205)),
                     (__m128i)xmmword_80CA9F0));
          v199 = _mm_cmpeq_epi8(v199, v208);
          v21 = _mm_movemask_epi8(
                  _mm_sub_epi8(
                    _mm_cmpeq_epi8(
                      v208,
                      _mm_or_si128(
                        v207,
                        _mm_and_si128(
                          _mm_and_si128(
                            _mm_cmpgt_epi8(v207, (__m128i)xmmword_80CA9D0),
                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v207)),
                          (__m128i)xmmword_80CA9F0))),
                    v199))
              - 0xFFFF;
          if ( v21 )
            goto LABEL_244;
          v259 = v5 <= 0x10;
          v5 -= 16;
          if ( v259 )
            return 0;
          v10 += 16;
          v198 = v206;
        }
      }
      v210 = _mm_load_si128(v12);
      v211 = _mm_slli_si128(_mm_load_si128(v13), 3);
      v212 = (unsigned int)_mm_movemask_epi8(
                             _mm_sub_epi8(
                               _mm_cmpeq_epi8(
                                 _mm_or_si128(
                                   v211,
                                   _mm_and_si128(
                                     _mm_and_si128(
                                       _mm_cmpgt_epi8(v211, (__m128i)xmmword_80CA9D0),
                                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v211)),
                                     (__m128i)xmmword_80CA9F0)),
                                 _mm_or_si128(
                                   v210,
                                   _mm_and_si128(
                                     _mm_and_si128(
                                       _mm_cmpgt_epi8(v210, (__m128i)xmmword_80CA9D0),
                                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v210)),
                                     (__m128i)xmmword_80CA9F0))),
                               _mm_cmpeq_epi8((__m128i)0LL, v210))) >> v10;
      v21 = (0xFFFFu >> v10) - v212;
      v17 = 0xFFFFu >> v10 == v212;
      v22 = v10 - 3;
      if ( !v17 )
        goto LABEL_245;
      if ( v5 <= 16 - v10 )
        return 0;
      v5 -= 16 - v10;
      v213 = _mm_load_si128(v13);
      v214 = 0LL;
      v10 = 16;
      v288 |= 0xDu;
      v215 = (((_WORD)v13 + 13) & 0xFFF) - 4096;
      while ( 1 )
      {
        v259 = (v215 + 16 < 0) ^ __OFADD__(16, v215) | (v215 == -16);
        v215 += 16;
        if ( !v259 )
          goto LABEL_211;
        while ( 1 )
        {
          v216 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
          v217 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
          v218 = _mm_alignr_epi8(v217, v213, 13);
          v219 = _mm_or_si128(
                   v216,
                   _mm_and_si128(
                     _mm_and_si128(
                       _mm_cmpgt_epi8(v216, (__m128i)xmmword_80CA9D0),
                       _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v216)),
                     (__m128i)xmmword_80CA9F0));
          v214 = _mm_cmpeq_epi8(v214, v219);
          v21 = _mm_movemask_epi8(
                  _mm_sub_epi8(
                    _mm_cmpeq_epi8(
                      v219,
                      _mm_or_si128(
                        v218,
                        _mm_and_si128(
                          _mm_and_si128(
                            _mm_cmpgt_epi8(v218, (__m128i)xmmword_80CA9D0),
                            _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v218)),
                          (__m128i)xmmword_80CA9F0))),
                    v214))
              - 0xFFFF;
          if ( v21 )
            goto LABEL_244;
          v259 = v5 <= 0x10;
          v5 -= 16;
          if ( v259 )
            return 0;
          v10 += 16;
          v213 = v217;
          v259 = (v215 + 16 < 0) ^ __OFADD__(16, v215) | (v215 == -16);
          v215 += 16;
          if ( v259 )
            break;
LABEL_211:
          v224 = _mm_cmpeq_epi8(v214, v213);
          if ( (_mm_movemask_epi8(v224) & 0xE000) != 0 || v5 <= 3 )
          {
            v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
            v43 = _mm_srli_si128(v224, 13);
            v44 = _mm_srli_si128(v213, 13);
            goto LABEL_243;
          }
          v214 = 0LL;
          v215 -= 4096;
        }
        v220 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
        v221 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
        v222 = _mm_alignr_epi8(v221, v213, 13);
        v223 = _mm_or_si128(
                 v220,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v220, (__m128i)xmmword_80CA9D0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v220)),
                   (__m128i)xmmword_80CA9F0));
        v214 = _mm_cmpeq_epi8(v214, v223);
        v21 = _mm_movemask_epi8(
                _mm_sub_epi8(
                  _mm_cmpeq_epi8(
                    v223,
                    _mm_or_si128(
                      v222,
                      _mm_and_si128(
                        _mm_and_si128(
                          _mm_cmpgt_epi8(v222, (__m128i)xmmword_80CA9D0),
                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v222)),
                        (__m128i)xmmword_80CA9F0))),
                  v214))
            - 0xFFFF;
        if ( v21 )
          goto LABEL_244;
        v259 = v5 <= 0x10;
        v5 -= 16;
        if ( v259 )
          return 0;
        v10 += 16;
        v213 = v221;
      }
    }
    v225 = _mm_load_si128(v12);
    v226 = _mm_slli_si128(_mm_load_si128(v13), 2);
    v227 = (unsigned int)_mm_movemask_epi8(
                           _mm_sub_epi8(
                             _mm_cmpeq_epi8(
                               _mm_or_si128(
                                 v226,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v226, (__m128i)xmmword_80CA9D0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v226)),
                                   (__m128i)xmmword_80CA9F0)),
                               _mm_or_si128(
                                 v225,
                                 _mm_and_si128(
                                   _mm_and_si128(
                                     _mm_cmpgt_epi8(v225, (__m128i)xmmword_80CA9D0),
                                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v225)),
                                   (__m128i)xmmword_80CA9F0))),
                             _mm_cmpeq_epi8((__m128i)0LL, v225))) >> v10;
    v21 = (0xFFFFu >> v10) - v227;
    v17 = 0xFFFFu >> v10 == v227;
    v22 = v10 - 2;
    if ( !v17 )
      goto LABEL_245;
    if ( v5 <= 16 - v10 )
      return 0;
    v5 -= 16 - v10;
    v228 = _mm_load_si128(v13);
    v229 = 0LL;
    v10 = 16;
    v288 |= 0xEu;
    v230 = (((_WORD)v13 + 14) & 0xFFF) - 4096;
    while ( 1 )
    {
      v259 = (v230 + 16 < 0) ^ __OFADD__(16, v230) | (v230 == -16);
      v230 += 16;
      if ( !v259 )
        goto LABEL_225;
      while ( 1 )
      {
        v231 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
        v232 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
        v233 = _mm_alignr_epi8(v232, v228, 14);
        v234 = _mm_or_si128(
                 v231,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v231, (__m128i)xmmword_80CA9D0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v231)),
                   (__m128i)xmmword_80CA9F0));
        v229 = _mm_cmpeq_epi8(v229, v234);
        v21 = _mm_movemask_epi8(
                _mm_sub_epi8(
                  _mm_cmpeq_epi8(
                    v234,
                    _mm_or_si128(
                      v233,
                      _mm_and_si128(
                        _mm_and_si128(
                          _mm_cmpgt_epi8(v233, (__m128i)xmmword_80CA9D0),
                          _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v233)),
                        (__m128i)xmmword_80CA9F0))),
                  v229))
            - 0xFFFF;
        if ( v21 )
          goto LABEL_244;
        v259 = v5 <= 0x10;
        v5 -= 16;
        if ( v259 )
          return 0;
        v10 += 16;
        v228 = v232;
        v259 = (v230 + 16 < 0) ^ __OFADD__(16, v230) | (v230 == -16);
        v230 += 16;
        if ( v259 )
          break;
LABEL_225:
        v239 = _mm_cmpeq_epi8(v229, v228);
        if ( (_mm_movemask_epi8(v239) & 0xC000) != 0 || v5 <= 2 )
        {
          v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
          v43 = _mm_srli_si128(v239, 14);
          v44 = _mm_srli_si128(v228, 14);
          goto LABEL_243;
        }
        v229 = 0LL;
        v230 -= 4096;
      }
      v235 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
      v236 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
      v237 = _mm_alignr_epi8(v236, v228, 14);
      v238 = _mm_or_si128(
               v235,
               _mm_and_si128(
                 _mm_and_si128(
                   _mm_cmpgt_epi8(v235, (__m128i)xmmword_80CA9D0),
                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v235)),
                 (__m128i)xmmword_80CA9F0));
      v229 = _mm_cmpeq_epi8(v229, v238);
      v21 = _mm_movemask_epi8(
              _mm_sub_epi8(
                _mm_cmpeq_epi8(
                  v238,
                  _mm_or_si128(
                    v237,
                    _mm_and_si128(
                      _mm_and_si128(
                        _mm_cmpgt_epi8(v237, (__m128i)xmmword_80CA9D0),
                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v237)),
                      (__m128i)xmmword_80CA9F0))),
                v229))
          - 0xFFFF;
      if ( v21 )
        goto LABEL_244;
      v259 = v5 <= 0x10;
      v5 -= 16;
      if ( v259 )
        return 0;
      v10 += 16;
      v228 = v236;
    }
  }
  v240 = _mm_load_si128(v12);
  v241 = _mm_slli_si128(_mm_load_si128(v13), 1);
  v242 = (unsigned int)_mm_movemask_epi8(
                         _mm_sub_epi8(
                           _mm_cmpeq_epi8(
                             _mm_or_si128(
                               v241,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v241, (__m128i)xmmword_80CA9D0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v241)),
                                 (__m128i)xmmword_80CA9F0)),
                             _mm_or_si128(
                               v240,
                               _mm_and_si128(
                                 _mm_and_si128(
                                   _mm_cmpgt_epi8(v240, (__m128i)xmmword_80CA9D0),
                                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v240)),
                                 (__m128i)xmmword_80CA9F0))),
                           _mm_cmpeq_epi8((__m128i)0LL, v240))) >> v10;
  v21 = (0xFFFFu >> v10) - v242;
  v17 = 0xFFFFu >> v10 == v242;
  v22 = v10 - 1;
  if ( !v17 )
    goto LABEL_245;
  if ( v5 <= 16 - v10 )
    return 0;
  v5 -= 16 - v10;
  v243 = _mm_load_si128(v13);
  v244 = 0LL;
  v10 = 16;
  v288 |= 0xFu;
  v245 = (((_WORD)v13 + 15) & 0xFFF) - 4096;
LABEL_232:
  v259 = (v245 + 16 < 0) ^ __OFADD__(16, v245) | (v245 == -16);
  v245 += 16;
  if ( !v259 )
    goto LABEL_239;
  while ( 1 )
  {
    v246 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
    v247 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
    v248 = _mm_alignr_epi8(v247, v243, 15);
    v249 = _mm_or_si128(
             v246,
             _mm_and_si128(
               _mm_and_si128(
                 _mm_cmpgt_epi8(v246, (__m128i)xmmword_80CA9D0),
                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v246)),
               (__m128i)xmmword_80CA9F0));
    v244 = _mm_cmpeq_epi8(v244, v249);
    v21 = _mm_movemask_epi8(
            _mm_sub_epi8(
              _mm_cmpeq_epi8(
                v249,
                _mm_or_si128(
                  v248,
                  _mm_and_si128(
                    _mm_and_si128(
                      _mm_cmpgt_epi8(v248, (__m128i)xmmword_80CA9D0),
                      _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v248)),
                    (__m128i)xmmword_80CA9F0))),
              v244))
        - 0xFFFF;
    if ( v21 )
      goto LABEL_244;
    v259 = v5 <= 0x10;
    v5 -= 16;
    if ( v259 )
      return 0;
    v10 += 16;
    v243 = v247;
    v259 = (v245 + 16 < 0) ^ __OFADD__(16, v245) | (v245 == -16);
    v245 += 16;
    if ( v259 )
    {
      v250 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
      v251 = _mm_load_si128((const __m128i *)((char *)v13 + v10));
      v252 = _mm_alignr_epi8(v251, v243, 15);
      v253 = _mm_or_si128(
               v250,
               _mm_and_si128(
                 _mm_and_si128(
                   _mm_cmpgt_epi8(v250, (__m128i)xmmword_80CA9D0),
                   _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v250)),
                 (__m128i)xmmword_80CA9F0));
      v244 = _mm_cmpeq_epi8(v244, v253);
      v21 = _mm_movemask_epi8(
              _mm_sub_epi8(
                _mm_cmpeq_epi8(
                  v253,
                  _mm_or_si128(
                    v252,
                    _mm_and_si128(
                      _mm_and_si128(
                        _mm_cmpgt_epi8(v252, (__m128i)xmmword_80CA9D0),
                        _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v252)),
                      (__m128i)xmmword_80CA9F0))),
                v244))
          - 0xFFFF;
      if ( v21 )
        goto LABEL_244;
      v259 = v5 <= 0x10;
      v5 -= 16;
      if ( v259 )
        return 0;
      v10 += 16;
      v243 = v251;
      goto LABEL_232;
    }
LABEL_239:
    v254 = _mm_cmpeq_epi8(v244, v243);
    if ( (_mm_movemask_epi8(v254) & 0x8000) != 0 || v5 <= 1 )
      break;
    v244 = 0LL;
    v245 -= 4096;
  }
  v42 = _mm_load_si128((const __m128i *)((char *)v12 + v10));
  v43 = _mm_srli_si128(v254, 15);
  v44 = _mm_srli_si128(v243, 15);
LABEL_243:
  v21 = ~_mm_movemask_epi8(
           _mm_sub_epi8(
             _mm_cmpeq_epi8(
               _mm_or_si128(
                 v42,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v42, (__m128i)xmmword_80CA9D0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v42)),
                   (__m128i)xmmword_80CA9F0)),
               _mm_or_si128(
                 v44,
                 _mm_and_si128(
                   _mm_and_si128(
                     _mm_cmpgt_epi8(v44, (__m128i)xmmword_80CA9D0),
                     _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v44)),
                   (__m128i)xmmword_80CA9F0))),
             v43));
LABEL_244:
  v22 = (v288 & 0x1F) + v10 - 16;
LABEL_245:
  v3 = &v13->m128i_u8[v22];
  v4 = &v12->m128i_u8[v10];
  if ( (v288 & 0x20) != 0 )
  {
    v255 = v4;
    v4 = v3;
    v3 = v255;
  }
  LOWORD(v9) = v21;
LABEL_248:
  if ( !(_BYTE)v9 )
  {
    v4 += 8;
    v3 += 8;
    v259 = v5 <= 8;
    v5 -= 8;
    if ( v259 )
      return 0;
    if ( (v9 & 0x100) == 0 )
    {
      if ( (v9 & 0x200) == 0 )
      {
        if ( (v9 & 0x400) == 0 )
        {
          if ( (v9 & 0x800) == 0 )
          {
            if ( (v9 & 0x1000) == 0 )
            {
              if ( (v9 & 0x2000) == 0 )
              {
                if ( (v9 & 0x4000) == 0 )
                {
                  if ( v5 <= 7 )
                    return 0;
                  return dword_80CFDC0[v3[7]] - dword_80CFDC0[v4[7]];
                }
LABEL_270:
                if ( v5 <= 6 )
                  return 0;
                return dword_80CFDC0[v3[6]] - dword_80CFDC0[v4[6]];
              }
LABEL_268:
              if ( v5 <= 5 )
                return 0;
              return dword_80CFDC0[v3[5]] - dword_80CFDC0[v4[5]];
            }
LABEL_266:
            if ( v5 <= 4 )
              return 0;
            return dword_80CFDC0[v3[4]] - dword_80CFDC0[v4[4]];
          }
LABEL_264:
          if ( v5 <= 3 )
            return 0;
          return dword_80CFDC0[v3[3]] - dword_80CFDC0[v4[3]];
        }
LABEL_262:
        if ( v5 <= 2 )
          return 0;
        return dword_80CFDC0[v3[2]] - dword_80CFDC0[v4[2]];
      }
LABEL_260:
      if ( v5 <= 1 )
        return 0;
      return dword_80CFDC0[v3[1]] - dword_80CFDC0[v4[1]];
    }
LABEL_258:
    if ( !v5 )
      return 0;
    return dword_80CFDC0[*v3] - dword_80CFDC0[*v4];
  }
  if ( (v9 & 1) != 0 )
    goto LABEL_258;
  if ( (v9 & 2) != 0 )
    goto LABEL_260;
  if ( (v9 & 4) != 0 )
    goto LABEL_262;
  if ( (v9 & 8) != 0 )
    goto LABEL_264;
  if ( (v9 & 0x10) != 0 )
    goto LABEL_266;
  if ( (v9 & 0x20) != 0 )
    goto LABEL_268;
  if ( (v9 & 0x40) != 0 )
    goto LABEL_270;
  if ( v5 > 7 )
    return dword_80CFDC0[v3[7]] - dword_80CFDC0[v4[7]];
  return 0;
}
// 80BB01D: positive sp value 8 has been found
// 80BB2CE: conditional instruction was optimized away because %arg_0.4==F
// 80B87F7: variable 'v289' is possibly undefined
// 80CA9D0: using guessed type __int128 xmmword_80CA9D0;
// 80CA9E0: using guessed type __int128 xmmword_80CA9E0;
// 80CA9F0: using guessed type __int128 xmmword_80CA9F0;
// 80CFDC0: using guessed type int dword_80CFDC0[256];

//----- (080BB300) --------------------------------------------------------
int __cdecl _strncasecmp_sse4_2(char *a1, unsigned __int8 *a2, int a3)
{
  if ( (*(_DWORD *)(*(_DWORD *)__readgsdword(0xFFFFFFD8) + 320) & 1) == 0 )
    JUMPOUT(0x80BB336);
  return _strncasecmp_nonascii(a1, a2, a3);
}
// 80BB318: control flows out of bounds to 80BB336

//----- (080BB320) --------------------------------------------------------
int __cdecl _strncasecmp_l_sse4_2(char *a1, unsigned __int8 *a2, int a3, int a4)
{
  unsigned __int8 *v4; // edx
  unsigned __int8 *v5; // eax
  int v6; // ebp
  __m128i v7; // xmm2
  __m128i v8; // xmm1
  __m128i v9; // xmm2
  __m128i v10; // xmm1
  int v11; // ecx
  unsigned int v12; // ecx
  unsigned int v13; // edi
  char v14; // cc
  unsigned int v15; // ecx
  unsigned int v16; // edi
  unsigned int v17; // ecx
  unsigned int v18; // edi
  unsigned int v19; // ecx
  unsigned int v20; // edi
  unsigned int v21; // ecx
  unsigned int v22; // edi
  unsigned int v23; // ecx
  unsigned int v24; // edi
  unsigned int v25; // ecx
  unsigned int v26; // edi
  unsigned int v27; // ecx
  unsigned int v28; // edi
  unsigned int v29; // ebp
  unsigned __int8 *v30; // edi
  unsigned __int8 *v31; // esi
  int result; // eax
  int v33; // ecx
  int v34; // edx
  unsigned __int8 *v35; // edi
  unsigned __int8 *v36; // esi
  __m128i v37; // xmm2
  __m128i v38; // xmm1
  __m128i v39; // xmm2
  __m128i v40; // xmm1
  bool v41; // cf
  unsigned int v42; // ecx
  int v43; // ecx
  int v44; // ecx
  int v45; // ecx
  int v46; // edi
  int v47; // ecx
  unsigned int v48; // ecx
  unsigned int v49; // edi
  unsigned int v50; // ecx
  unsigned int v51; // edi
  unsigned int v52; // ecx
  unsigned int v53; // edi
  unsigned int v54; // ecx
  unsigned int v55; // edi
  unsigned int v56; // ecx
  unsigned int v57; // edi
  unsigned int v58; // ecx
  unsigned int v59; // edi
  unsigned int v60; // ecx
  unsigned int v61; // edi
  unsigned int v62; // ecx
  unsigned int v63; // edi

  if ( (*(_DWORD *)(*(_DWORD *)a4 + 320) & 1) != 0 )
    return _strncasecmp_nonascii(a1, a2, a3);
  v4 = (unsigned __int8 *)a1;
  v5 = a2;
  v6 = a3;
  if ( !a3 )
    return 0;
  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFF0 )
  {
    v7 = _mm_loadu_si128((const __m128i *)a1);
    if ( ((unsigned __int16)a2 & 0xFFFu) <= 0xFF0 )
    {
      v8 = _mm_loadu_si128((const __m128i *)a2);
      v9 = _mm_or_si128(
             v7,
             _mm_and_si128(
               _mm_and_si128(
                 _mm_cmpgt_epi8(v7, (__m128i)xmmword_80CA9D0),
                 _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v7)),
               (__m128i)xmmword_80CA9F0));
      v10 = _mm_or_si128(
              v8,
              _mm_and_si128(
                _mm_and_si128(
                  _mm_cmpgt_epi8(v8, (__m128i)xmmword_80CA9D0),
                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v8)),
                (__m128i)xmmword_80CA9F0));
      v11 = _mm_cvtsi128_si32(v9);
      if ( v11 == _mm_cvtsi128_si32(v10) )
      {
        if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(v10, v9))
          && _mm_testc_si128((__m128i)0LL, _mm_cmpeq_epi8(v9, (__m128i)0LL)) )
        {
          v6 = a3 - 16;
          if ( (unsigned int)a3 <= 0x10 )
            return 0;
          v4 = (unsigned __int8 *)(a1 + 16);
          v5 = a2 + 16;
          goto LABEL_10;
        }
        v41 = __CFADD__(v11, -16843009);
        v44 = v11 - 16843009;
        if ( v41 && (_mm_cvtsi128_si32(v9) ^ v44 | 0xFEFEFEFF) == -1 )
        {
          if ( (unsigned int)a3 <= 4 )
            return 0;
          v45 = _mm_cvtsi128_si32(_mm_srli_si128(v9, 4));
          v46 = v45;
          if ( v45 != _mm_cvtsi128_si32(_mm_srli_si128(v10, 4)) )
            goto LABEL_73;
          v41 = __CFADD__(v45, -16843009);
          v47 = v45 - 16843009;
          if ( !v41 || (v46 ^ v47 | 0xFEFEFEFF) != -1 )
            goto LABEL_73;
          v6 = a3 - 8;
          if ( (unsigned int)a3 <= 8 )
            return 0;
          v4 = (unsigned __int8 *)(a1 + 8);
          v5 = a2 + 8;
        }
      }
      v48 = dword_80CFDC0[*v5];
      v49 = dword_80CFDC0[*v4];
      v14 = v49 <= v48;
      if ( v49 != v48 )
        goto LABEL_51;
      if ( !v48 || v6 == 1 )
        return 0;
      v50 = dword_80CFDC0[v5[1]];
      v51 = dword_80CFDC0[v4[1]];
      v14 = v51 <= v50;
      if ( v51 != v50 )
        goto LABEL_51;
      if ( !v50 || v6 == 2 )
        return 0;
      v52 = dword_80CFDC0[v5[2]];
      v53 = dword_80CFDC0[v4[2]];
      v14 = v53 <= v52;
      if ( v53 != v52 )
        goto LABEL_51;
      if ( !v52 || v6 == 3 )
        return 0;
      v54 = dword_80CFDC0[v5[3]];
      v55 = dword_80CFDC0[v4[3]];
      v14 = v55 <= v54;
      if ( v55 != v54 )
      {
LABEL_51:
        result = 1;
        if ( v14 )
          return -1;
        return result;
      }
      if ( !v54 )
        return 0;
LABEL_73:
      if ( v6 == 4 )
        return 0;
      v56 = dword_80CFDC0[v5[4]];
      v57 = dword_80CFDC0[v4[4]];
      v14 = v57 <= v56;
      if ( v57 == v56 )
      {
        if ( !v56 )
          return 0;
        if ( v6 == 5 )
          return 0;
        v58 = dword_80CFDC0[v5[5]];
        v59 = dword_80CFDC0[v4[5]];
        v14 = v59 <= v58;
        if ( v59 == v58 )
        {
          if ( !v58 )
            return 0;
          if ( v6 == 6 )
            return 0;
          v60 = dword_80CFDC0[v5[6]];
          v61 = dword_80CFDC0[v4[6]];
          v14 = v61 <= v60;
          if ( v61 == v60 )
          {
            if ( !v60 )
              return 0;
            if ( v6 == 7 )
              return 0;
            v62 = dword_80CFDC0[v5[7]];
            v63 = dword_80CFDC0[v4[7]];
            v14 = v63 <= v62;
            if ( v63 == v62 )
              return 0;
          }
        }
      }
      goto LABEL_51;
    }
  }
LABEL_10:
  v12 = dword_80CFDC0[*v5];
  v13 = dword_80CFDC0[*v4];
  v14 = v13 <= v12;
  if ( v13 != v12 )
    goto LABEL_51;
  if ( !v12 || v6 == 1 )
    return 0;
  v15 = dword_80CFDC0[v5[1]];
  v16 = dword_80CFDC0[v4[1]];
  v14 = v16 <= v15;
  if ( v16 != v15 )
    goto LABEL_51;
  if ( !v15 || v6 == 2 )
    return 0;
  v17 = dword_80CFDC0[v5[2]];
  v18 = dword_80CFDC0[v4[2]];
  v14 = v18 <= v17;
  if ( v18 != v17 )
    goto LABEL_51;
  if ( !v17 || v6 == 3 )
    return 0;
  v19 = dword_80CFDC0[v5[3]];
  v20 = dword_80CFDC0[v4[3]];
  v14 = v20 <= v19;
  if ( v20 != v19 )
    goto LABEL_51;
  if ( !v19 || v6 == 4 )
    return 0;
  v21 = dword_80CFDC0[v5[4]];
  v22 = dword_80CFDC0[v4[4]];
  v14 = v22 <= v21;
  if ( v22 != v21 )
    goto LABEL_51;
  if ( !v21 || v6 == 5 )
    return 0;
  v23 = dword_80CFDC0[v5[5]];
  v24 = dword_80CFDC0[v4[5]];
  v14 = v24 <= v23;
  if ( v24 != v23 )
    goto LABEL_51;
  if ( !v23 || v6 == 6 )
    return 0;
  v25 = dword_80CFDC0[v5[6]];
  v26 = dword_80CFDC0[v4[6]];
  v14 = v26 <= v25;
  if ( v26 != v25 )
    goto LABEL_51;
  if ( !v25 || v6 == 7 )
    return 0;
  v27 = dword_80CFDC0[v5[7]];
  v28 = dword_80CFDC0[v4[7]];
  v14 = v28 <= v27;
  if ( v28 != v27 )
    goto LABEL_51;
  if ( !v27 )
    return 0;
  v29 = v6 - 8;
  if ( !v29 )
    return 0;
  v30 = v4 + 8;
  v31 = v5 + 8;
  result = 0;
LABEL_35:
  v33 = (unsigned __int16)v31 & 0xFFF;
  if ( v33 < ((unsigned __int16)v30 & 0xFFF) )
    v33 = (unsigned __int16)v30 & 0xFFF;
  v34 = v33 - 4080;
  v35 = &v30[-v33 + 4080];
  v36 = &v31[-v33 + 4080];
  if ( v33 - 4080 > 0 )
  {
LABEL_41:
    while ( 1 )
    {
      v43 = dword_80CFDC0[v36[v34]];
      result = dword_80CFDC0[v35[v34]] - v43;
      if ( result || !v43 )
        break;
      v14 = v29-- <= 1;
      if ( v14 )
        return 0;
      if ( ++v34 > 15 )
      {
        v30 = &v35[v34];
        v31 = &v36[v34];
        goto LABEL_35;
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v37 = _mm_loadu_si128((const __m128i *)&v36[v34]);
      v38 = _mm_loadu_si128((const __m128i *)&v35[v34]);
      v39 = _mm_or_si128(
              v37,
              _mm_and_si128(
                _mm_and_si128(
                  _mm_cmpgt_epi8(v37, (__m128i)xmmword_80CA9D0),
                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v37)),
                (__m128i)xmmword_80CA9F0));
      v40 = _mm_or_si128(
              v38,
              _mm_and_si128(
                _mm_and_si128(
                  _mm_cmpgt_epi8(v38, (__m128i)xmmword_80CA9D0),
                  _mm_cmpgt_epi8(_mm_load_si128((const __m128i *)&xmmword_80CA9E0), v38)),
                (__m128i)xmmword_80CA9F0));
      v42 = _mm_cmpistri(v40, v39, 26);
      v41 = _mm_cmpistrc(v40, v39, 26);
      if ( v41 | _mm_cmpistrz(v40, v39, 26) )
        break;
      v14 = v29 <= 0x10;
      v29 -= 16;
      if ( v14 )
        return 0;
      v14 = (v34 + 16 < 0) ^ __OFADD__(16, v34) | (v34 == -16);
      v34 += 16;
      if ( !v14 )
        goto LABEL_41;
    }
    if ( v41 )
    {
      if ( v29 > v42 )
        return dword_80CFDC0[v35[v42 + v34]] - dword_80CFDC0[v36[v42 + v34]];
      return 0;
    }
  }
  return result;
}
// 80CA9D0: using guessed type __int128 xmmword_80CA9D0;
// 80CA9E0: using guessed type __int128 xmmword_80CA9E0;
// 80CA9F0: using guessed type __int128 xmmword_80CA9F0;
// 80CFDC0: using guessed type int dword_80CFDC0[256];

//----- (080BB890) --------------------------------------------------------
unsigned int __cdecl profil_counter(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16)
{
  unsigned int result; // eax
  int v17; // edx

  result = ((unsigned int)pc_scale * (unsigned __int64)(unsigned int)((a16 - pc_offset) / 2)) >> 16;
  if ( result < nsamples )
  {
    result = samples;
    v17 = ((unsigned int)pc_scale * (unsigned __int64)(unsigned int)((a16 - pc_offset) / 2)) >> 16;
    ++*(_WORD *)(samples + 2 * v17);
  }
  return result;
}
// 80F0F40: using guessed type int samples;
// 80F0FEC: using guessed type int nsamples;
// 80F0FF0: using guessed type int pc_offset;
// 80F0FF4: using guessed type int pc_scale;

//----- (080BB8D0) --------------------------------------------------------
int __cdecl profil(int a1, unsigned int a2, int a3, int a4)
{
  int v4; // ebx
  int *v5; // eax
  unsigned int (__cdecl *v7)(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int); // [esp+14h] [ebp-A8h] BYREF
  char v8; // [esp+94h] [ebp-28h] BYREF
  int v9; // [esp+98h] [ebp-24h]
  int v10[2]; // [esp+A0h] [ebp-1Ch] BYREF
  int v11; // [esp+A8h] [ebp-14h]
  int v12; // [esp+ACh] [ebp-10h]

  if ( a1 )
  {
    if ( !samples || (v4 = -1, (setitimer(2, (int)&otimer_7293) & 0x80000000) == 0) && sigaction(27, oact_7292, 0) >= 0 )
    {
      samples = a1;
      v7 = profil_counter;
      v9 = 0x10000000;
      nsamples = a2 >> 1;
      pc_offset = a3;
      pc_scale = a4;
      v5 = (int *)&v8;
      do
        *v5-- = -1;
      while ( v5 != (int *)&v7 );
      v4 = -1;
      if ( sigaction(27, v5, oact_7292) >= 0 )
      {
        v11 = 0;
        v12 = 1000000 / _profile_frequency();
        v10[0] = v11;
        v10[1] = v12;
        return setitimer(2, (int)v10);
      }
    }
    return v4;
  }
  v4 = 0;
  if ( !samples )
    return v4;
  v4 = -1;
  if ( (setitimer(2, (int)&otimer_7293) & 0x80000000) != 0 )
    return v4;
  samples = 0;
  return sigaction(27, oact_7292, 0);
}
// 80F0F40: using guessed type int samples;
// 80F0F60: using guessed type int oact_7292[11];
// 80F0FEC: using guessed type int nsamples;
// 80F0FF0: using guessed type int pc_offset;
// 80F0FF4: using guessed type int pc_scale;

//----- (080BBA90) --------------------------------------------------------
int _profile_frequency()
{
  return dl_clktck;
}
// 80F11CC: using guessed type int dl_clktck;

//----- (080BBAA0) --------------------------------------------------------
int __usercall add_to_global@<eax>(_DWORD *a1@<eax>)
{
  int v2; // edx
  int v3; // eax
  int v4; // ecx
  int v5; // esi
  int v6; // esi
  unsigned int v7; // edi
  int v8; // ebp
  unsigned int v9; // edi
  int v10; // eax
  char v11; // dl
  int v13; // edi
  int v14; // ebp
  int v15; // eax
  _BYTE *v16; // eax
  _BYTE *v17; // eax
  int v18; // eax
  _BYTE *v19; // eax
  _BYTE *v20; // ebp
  _BYTE *v21; // [esp+14h] [ebp-28h]
  _DWORD *v22; // [esp+18h] [ebp-24h]
  int v23; // [esp+1Ch] [ebp-20h]

  v2 = a1[88];
  v3 = 0;
  if ( v2 )
  {
    v4 = 0;
    v5 = 0;
    do
      v5 += (*(_BYTE *)(*(_DWORD *)(a1[87] + 4 * v4++) + 404) & 0x10) == 0;
    while ( v4 != v2 );
    v3 = v5;
  }
  v6 = 76 * a1[6] + 135205376;
  v7 = dword_80F120C[19 * a1[6]];
  if ( !v7 )
  {
    v13 = dword_80F1208[19 * a1[6]];
    v14 = *(_DWORD *)(v13 + 4);
    v15 = v3 + v14 + 8;
    dword_80F120C[19 * a1[6]] = v15;
    v16 = (_BYTE *)malloc(4 * v15);
    if ( v16 )
    {
      v17 = memcpy(v16, *(_BYTE **)v13, 4 * v14);
      v2 = a1[88];
      *(_DWORD *)v13 = v17;
      v8 = *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4);
      goto LABEL_7;
    }
    *(_DWORD *)(v6 + 12) = 0;
LABEL_21:
    dl_signal_error("cannot extend global scope");
  }
  v22 = (_DWORD *)dword_80F1208[19 * a1[6]];
  v8 = v22[1];
  if ( v7 >= v3 + v8 )
    goto LABEL_7;
  v18 = v7 + v3;
  v21 = *(_BYTE **)dword_80F1208[19 * a1[6]];
  v23 = 2 * v18;
  v19 = (_BYTE *)malloc(8 * v18);
  v20 = v19;
  if ( !v19 )
    goto LABEL_21;
  memcpy(v19, v21, 4 * v7);
  *(_DWORD *)(v6 + 12) = v23;
  *v22 = v20;
  if ( __readgsdword(0xCu) )
    dl_wait_lookup_done();
  free(v21);
  v2 = a1[88];
  v8 = *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4);
LABEL_7:
  if ( v2 )
  {
    v9 = 0;
    do
    {
      v10 = *(_DWORD *)(a1[87] + 4 * v9);
      v11 = *(_BYTE *)(v10 + 404);
      if ( (v11 & 0x10) == 0 )
      {
        *(_BYTE *)(v10 + 404) = v11 | 0x10;
        *(_DWORD *)(**(_DWORD **)(v6 + 8) + 4 * v8++) = v10;
        if ( (dl_debug_mask & 0x200) != 0 )
          dl_debug_printf((int)"\nadd %s [%lu] to global scope\n", *(const char **)(v10 + 4), *(_DWORD *)(v10 + 24));
      }
      ++v9;
    }
    while ( a1[88] > v9 );
  }
  *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4) = v8;
  return 0;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 80F1190: using guessed type int dl_debug_mask;
// 80F11A0: using guessed type int (*dl_wait_lookup_done)(void);
// 80F1208: using guessed type int dword_80F1208[];
// 80F120C: using guessed type int dword_80F120C[];

//----- (080BBC70) --------------------------------------------------------
int __cdecl dl_open(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  unsigned int v8; // ebx
  void *v9; // esp
  unsigned int v10; // kr04_4
  void *v11; // esp
  _BYTE v12[12]; // [esp+10h] [ebp-58h] BYREF
  _BYTE *v13; // [esp+1Ch] [ebp-4Ch]
  int v14[4]; // [esp+20h] [ebp-48h] BYREF
  int v15; // [esp+30h] [ebp-38h]
  int v16; // [esp+34h] [ebp-34h]
  int v17; // [esp+38h] [ebp-30h]
  int v18; // [esp+3Ch] [ebp-2Ch]
  int v19; // [esp+40h] [ebp-28h]
  const char *v20; // [esp+44h] [ebp-24h] BYREF
  const char *v21; // [esp+48h] [ebp-20h] BYREF
  char v22[25]; // [esp+4Fh] [ebp-19h] BYREF
  int savedregs; // [esp+68h] [ebp+0h] BYREF
  int retaddr; // [esp+6Ch] [ebp+4h]

  if ( (a2 & 3) == 0 )
    dl_signal_error("invalid mode for dlopen()");
  if ( a4 == -1 )
    dl_signal_error("no more namespaces available for dlmopen()");
  if ( a4 != -2 && a4 && (!dword_80F1204[19 * a4] || (*(_BYTE *)(dl_ns[19 * a4] + 405) & 8) != 0) )
    dl_signal_error("invalid target namespace in dlmopen()");
  if ( (a4 == -2 || !a4) && !dl_ns[0] && !dl_nns )
    dl_nns = 1;
  v14[0] = a1;
  v14[1] = a2;
  v14[2] = a3;
  v15 = 0;
  v16 = a4;
  v14[3] = retaddr;
  v17 = a5;
  v18 = a6;
  v19 = a7;
  dl_catch_error(&v20, &v21, v22, a2, (int)&savedregs, a4, a1, (void (__cdecl *)(int))dl_open_worker, (int)v14);
  dl_unload_cache();
  if ( v21 )
  {
    if ( v15 )
    {
      if ( (a2 & 0x8000000) == 0 )
        dl_tls_dtv_gaps = 1;
      dl_close_worker(v15);
    }
    if ( !dl_debug_initialize(0, v16)[3] )
    {
      v13 = v21;
      v8 = strlen(v21) + 1;
      if ( &v21[v8] == v20 )
      {
        v10 = strlen(&v21[v8]) + 1;
        v11 = alloca(v8 + v10 + 15);
        memcpy(v12, v13, v8 + v10);
        v20 = &v12[v8];
      }
      else
      {
        v9 = alloca(v8 + 15);
        memcpy(v12, v13, v8);
      }
      if ( v22[0] )
        free(v21);
      dl_signal_error(v12);
    }
    _assert_fail("_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT", "dl-open.c", 667, "_dl_open");
  }
  if ( dl_debug_initialize(0, v16)[3] )
    _assert_fail("_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT", "dl-open.c", 696, "_dl_open");
  return v15;
}
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 80F1150: using guessed type char dl_tls_dtv_gaps;
// 80F11C0: using guessed type int dl_nns;
// 80F1200: using guessed type int dl_ns[];
// 80F1204: using guessed type int dword_80F1204[];
// 80BBC70: using guessed type const char *var_20;
// 80BBC70: using guessed type char var_19[25];

//----- (080BBF20) --------------------------------------------------------
__int64 __cdecl dl_show_scope(_DWORD *a1, int a2)
{
  const char *v2; // eax
  int v3; // eax
  int v4; // edi
  int v5; // ebp
  _DWORD *v6; // eax
  unsigned int v7; // ebx
  const char *v8; // eax
  int v10; // [esp+1Ch] [ebp-20h]

  v2 = (const char *)a1[1];
  if ( !*v2 )
    v2 = (const char *)program_invocation_short_name;
  dl_debug_printf((int)"object=%s [%lu]\n", v2, a1[6]);
  v3 = a1[115];
  if ( v3 )
  {
    v4 = 4 * a2;
    if ( *(_DWORD *)(v3 + 4 * a2) )
    {
      v5 = 4 * a2 + 4;
      v10 = a2;
      while ( 1 )
      {
        dl_debug_printf((int)" scope %u:", v10);
        v6 = *(_DWORD **)(a1[115] + v4);
        if ( v6[1] )
        {
          v7 = 0;
          do
          {
            v8 = *(const char **)(*(_DWORD *)(*v6 + 4 * v7) + 4);
            if ( !*v8 )
              v8 = (const char *)program_invocation_short_name;
            ++v7;
            dl_debug_printf_c(135129110, v8);
            v6 = *(_DWORD **)(a1[115] + v4);
          }
          while ( v6[1] > v7 );
        }
        dl_debug_printf_c((int)"\n");
        ++v10;
        if ( !*(_DWORD *)(a1[115] + v5) )
          break;
        v4 = v5;
        v5 += 4;
      }
    }
  }
  else
  {
    dl_debug_printf((int)" no scope\n");
  }
  return dl_debug_printf((int)"\n");
}
// 80EF56C: using guessed type void *program_invocation_short_name;

//----- (080BC030) --------------------------------------------------------
_DWORD *__cdecl dl_open_worker(int a1)
{
  int v1; // esi
  int v2; // edi
  unsigned int v3; // esi
  int v4; // ebx
  int v5; // ebx
  _DWORD *result; // eax
  int v7; // ebx
  int v8; // esi
  int v9; // eax
  unsigned int v10; // esi
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // edx
  size_t v15; // esi
  void *v16; // esp
  int v17; // eax
  unsigned int v18; // esi
  int v19; // edi
  _DWORD *v20; // ebx
  unsigned int v21; // esi
  size_t v22; // ecx
  int v23; // ebx
  int v24; // edx
  _BYTE *v25; // edi
  int v26; // eax
  int v27; // ebx
  bool v28; // zf
  int v29; // edx
  char *v30; // edi
  int v31; // esi
  int v32; // ebx
  unsigned int v33; // eax
  _BYTE *v34; // ebx
  _BYTE *v35; // eax
  int v36; // eax
  unsigned int v37; // edi
  void *v38; // esp
  size_t v39; // esi
  int v40; // edx
  int v41; // ebx
  bool v42; // cf
  unsigned int v43; // esi
  int *v44; // eax
  int v45; // ecx
  char *v46; // eax
  size_t v47; // ecx
  int v48; // ebx
  char *v49; // edi
  unsigned int v50[4]; // [esp+0h] [ebp-68h] BYREF
  _DWORD v51[3]; // [esp+10h] [ebp-58h] BYREF
  int v52; // [esp+1Ch] [ebp-4Ch]
  _DWORD *v53; // [esp+20h] [ebp-48h]
  size_t v54; // [esp+24h] [ebp-44h]
  unsigned int *v55; // [esp+28h] [ebp-40h]
  int v56; // [esp+2Ch] [ebp-3Ch]
  unsigned int *v57; // [esp+30h] [ebp-38h]
  unsigned int v58; // [esp+34h] [ebp-34h]
  int v59; // [esp+38h] [ebp-30h]
  int v60; // [esp+3Ch] [ebp-2Ch]
  unsigned int v61; // [esp+40h] [ebp-28h]
  size_t n; // [esp+44h] [ebp-24h]
  char *s; // [esp+48h] [ebp-20h]
  unsigned int v64; // [esp+4Ch] [ebp-1Ch]

  v1 = *(_DWORD *)(a1 + 4);
  s = *(char **)a1;
  v60 = v1;
  if ( strchr(s, 36) || (v48 = *(_DWORD *)(a1 + 20), v48 == -2) || (v2 = 0, !strchr(s, 47)) )
  {
    v2 = dl_ns[0];
    v3 = *(_DWORD *)(a1 + 8);
    if ( dl_nns )
    {
      v4 = dl_ns[0];
      v64 = 0;
      while ( 1 )
      {
        while ( !v4 )
        {
          if ( ++v64 >= dl_nns )
            goto LABEL_14;
          v4 = dl_ns[19 * v64];
        }
        if ( v3 >= *(_DWORD *)(v4 + 428)
          && v3 < *(_DWORD *)(v4 + 432)
          && ((*(_BYTE *)(v4 + 405) & 0x40) != 0 || dl_addr_inside_object(v4, v3)) )
        {
          break;
        }
        v4 = *(_DWORD *)(v4 + 12);
      }
      if ( *(_DWORD *)(v4 + 24) != v64 )
        _assert_fail("ns == l->l_ns", "dl-open.c", 203, "dl_open_worker");
      v2 = v4;
    }
LABEL_14:
    v5 = *(_DWORD *)(a1 + 20);
    if ( v5 == -2 )
    {
      if ( v2 )
      {
        v5 = *(_DWORD *)(v2 + 24);
        *(_DWORD *)(a1 + 20) = v5;
      }
      else
      {
        *(_DWORD *)(a1 + 20) = 0;
        v5 = 0;
      }
    }
    if ( dl_debug_initialize(0, v5)[3] )
LABEL_98:
      _assert_fail("_dl_debug_initialize (0, args->nsid)->r_state == RT_CONSISTENT", "dl-open.c", 221, "dl_open_worker");
  }
  else if ( dl_debug_initialize(0, v48)[3] )
  {
    goto LABEL_98;
  }
  result = (_DWORD *)dl_map_object(v2, s, 2, 0, v60 | 0x10000000, *(_DWORD *)(a1 + 20));
  v7 = (int)result;
  *(_DWORD *)(a1 + 16) = result;
  if ( result )
  {
    if ( (v60 & 0x40000000) != 0 )
      return result;
    v8 = result[87];
    v9 = result[100] + 1;
    *(_DWORD *)(v7 + 400) = v9;
    if ( !v8 )
    {
      dl_map_object_deps(v7, 0, 0, 0, v60 & 0x88000008);
      if ( *(_DWORD *)(v7 + 352) )
      {
        v10 = 0;
        do
        {
          v11 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 348) + 4 * v10) + 20);
          if ( !*(_DWORD *)(v11 + 368) )
            dl_check_map_versions(v11, 0, 0);
          ++v10;
        }
        while ( *(_DWORD *)(v7 + 352) > v10 );
      }
      dl_debug_initialize(0, *(_DWORD *)(a1 + 20))[3] = 0;
      dl_debug_state();
      if ( (dl_debug_mask & 0x200) != 0 )
        dl_show_scope((_DWORD *)v7, 0);
      v59 = v60 & 0x8000000;
      if ( dl_lazy )
        v59 = v60 & 0x8000001;
      v12 = v7;
      v13 = 0;
      do
      {
        v14 = *(_DWORD *)(v12 + 20);
        v12 = *(_DWORD *)(v12 + 12);
        v13 += (*(_BYTE *)(v14 + 404) & 4) == 0;
      }
      while ( v12 );
      v15 = 0;
      v55 = v50;
      v16 = alloca(4 * v13 + 15);
      v17 = v7;
      n = 0;
      do
      {
        if ( (*(_BYTE *)(*(_DWORD *)(v17 + 20) + 404) & 4) == 0 )
          v51[v15++] = v17;
        v17 = *(_DWORD *)(v17 + 12);
      }
      while ( v17 );
      n = v15;
      if ( v15 <= 1 )
      {
        v18 = v15 - 1;
        if ( n )
        {
          v64 = v7;
          v19 = v59;
          v20 = v51;
          goto LABEL_38;
        }
        goto LABEL_40;
      }
      v37 = 0;
      v57 = v50;
      v38 = alloca(n + 15);
      s = (char *)v51;
      v39 = n - 1;
      v53 = v51;
      memset(v51, 0, n);
      v40 = (int)v53;
      v61 = v39;
      v64 = 1;
      v56 = v7;
      while ( 1 )
      {
        while ( 1 )
        {
          v41 = *(_DWORD *)(v40 + 4 * v37);
          v42 = v37 < v61;
          LOBYTE(v58) = s[v37] + 1;
          s[v37] = v58;
          if ( v42 )
            break;
LABEL_90:
          v37 = v64;
          if ( v64 == n )
          {
            v18 = v61;
            v19 = v59;
            v64 = v56;
            v20 = (_DWORD *)v40;
LABEL_38:
            while ( 1 )
            {
              dl_relocate_object(v20[v18], *(_DWORD *)(v20[v18] + 460), v19, 0);
              if ( !v18 )
                break;
              --v18;
            }
            v7 = v64;
LABEL_40:
            v64 = *(_DWORD *)(v7 + 352);
            s = (char *)v64;
            if ( !v64 )
              goto LABEL_78;
            v21 = 0;
            LOBYTE(v57) = 0;
            v22 = v7;
            n = v7 + 348;
            while ( 2 )
            {
              while ( 2 )
              {
                v24 = *(_DWORD *)(*(_DWORD *)(v22 + 348) + 4 * v21);
                if ( (*(_BYTE *)(v24 + 404) & 0xB) == 10 )
                {
                  v25 = *(_BYTE **)(v24 + 460);
                  v26 = *(_DWORD *)v25;
                  if ( *(_DWORD *)v25 )
                  {
                    v52 = 0;
                    if ( v26 != n )
                    {
                      v61 = v22;
                      v27 = 0;
                      do
                      {
                        ++v27;
                        v26 = *(_DWORD *)&v25[4 * v27];
                        if ( !v26 )
                        {
                          v52 = v27;
                          v22 = v61;
                          v61 = v27 + 1;
                          goto LABEL_54;
                        }
                      }
                      while ( v26 != n );
                      v22 = v61;
                      v52 = v27;
                    }
                    if ( v26 )
                      goto LABEL_46;
                    v33 = *(_DWORD *)(v24 + 456);
                    v61 = v52 + 1;
                    v58 = v33;
                    if ( v33 <= v52 + 1 )
                    {
LABEL_71:
                      v34 = (_BYTE *)(v24 + 440);
                      v59 = v24 + 440;
                      if ( v25 == (_BYTE *)(v24 + 440) || (v56 = 4, v58 > 3) )
                      {
                        v56 = 2 * v58;
                        v53 = (_DWORD *)v24;
                        v54 = v22;
                        v35 = (_BYTE *)malloc(8 * v58);
                        v24 = (int)v53;
                        v22 = v54;
                        v34 = v35;
                        if ( !v35 )
                          dl_signal_error("cannot create scope list");
                      }
                      v58 = 4 * v52;
                      v53 = (_DWORD *)v24;
                      v54 = v22;
                      memcpy(v34, v25, 4 * v52);
                      v24 = (int)v53;
                      v22 = v54;
                      v36 = v53[115];
                      v28 = v59 == v36;
                      v53[115] = v34;
                      if ( !v28 )
                      {
                        v53 = (_DWORD *)v24;
                        v54 = v22;
                        dl_scope_free(v36);
                        v24 = (int)v53;
                        v22 = v54;
                        v34 = (_BYTE *)v53[115];
                      }
                      *(_DWORD *)(v24 + 456) = v56;
                      v25 = v34;
                      goto LABEL_56;
                    }
                  }
                  else
                  {
                    v61 = 1;
                    v52 = 0;
LABEL_54:
                    v58 = *(_DWORD *)(v24 + 456);
                    if ( v58 <= v61 )
                      goto LABEL_71;
                  }
                  v58 = 4 * v52;
LABEL_56:
                  *(_DWORD *)&v25[4 * v61] = 0;
                  v28 = (dl_debug_mask & 0x200) == 0;
                  *(_DWORD *)(*(_DWORD *)(v24 + 460) + v58) = n;
                  v23 = v52;
                  if ( v28 )
                    goto LABEL_45;
                }
                else
                {
                  v23 = 0;
                  if ( (*(_BYTE *)(v24 + 404) & 8) == 0 )
                  {
                    if ( *(_DWORD *)(v24 + 564) )
                    {
                      v50[0] = *(_DWORD *)(*(_DWORD *)(v22 + 348) + 4 * v21);
                      v53 = (_DWORD *)v24;
                      v54 = v22;
                      dl_add_to_slotinfo(v50[0]);
                      v24 = (int)v53;
                      LOBYTE(v57) = 1;
                      v22 = v54;
                      if ( (*((_BYTE *)v53 + 405) & 4) != 0 )
                      {
                        v49 = s;
                        if ( *(char **)(v54 + 352) == s )
                          v49 = (char *)v21;
                        s = v49;
                      }
                    }
                  }
                  if ( (dl_debug_mask & 0x200) == 0 )
                  {
LABEL_45:
                    v64 = *(_DWORD *)(v22 + 352);
LABEL_46:
                    if ( v64 <= ++v21 )
                      goto LABEL_58;
                    continue;
                  }
                }
                break;
              }
              ++v21;
              v54 = v22;
              dl_show_scope((_DWORD *)v24, v23);
              v22 = v54;
              v64 = *(_DWORD *)(v54 + 352);
              if ( v64 <= v21 )
              {
LABEL_58:
                v7 = v22;
                if ( (_BYTE)v57 )
                {
                  if ( !++dl_tls_generation )
                  {
                    dl_dprintf(2, (int)"TLS generation counter wrapped!  Please report this.");
                    exit(127);
                  }
                }
                v29 = v22;
                v30 = s;
                v31 = 4 * (_DWORD)s;
                if ( (unsigned int)s < v64 )
                {
                  do
                  {
                    v32 = *(_DWORD *)(*(_DWORD *)(v29 + 348) + v31);
                    if ( (*(_WORD *)(v32 + 404) & 0x408) == 1024 && *(_DWORD *)(v32 + 564) )
                    {
                      if ( __readgsdword(0xCu) && *(_DWORD *)(v32 + 580) > 0xEu )
                        dl_signal_error("cannot load any more object with static TLS");
                      *(_BYTE *)(v32 + 405) &= ~4u;
                      v53 = (_DWORD *)v29;
                      dl_init_static_tls(v32);
                      v29 = (int)v53;
                      if ( (*(_BYTE *)(v32 + 405) & 4) != 0 )
                        _assert_fail("imap->l_need_tls_init == 0", "dl-open.c", 544, "dl_open_worker");
                    }
                    ++v30;
                    v31 += 4;
                  }
                  while ( *(_DWORD *)(v29 + 352) > (unsigned int)v30 );
                  v7 = v29;
                }
LABEL_78:
                result = (_DWORD *)dl_init(
                                     (_DWORD *)v7,
                                     *(_DWORD *)(a1 + 24),
                                     *(_DWORD *)(a1 + 28),
                                     *(_DWORD *)(a1 + 32));
                if ( (v60 & 0x100) != 0 )
                {
                  result = (_DWORD *)add_to_global((_DWORD *)v7);
                  if ( result )
                    return result;
                  if ( (v60 & 0x1000) == 0 )
                    goto LABEL_80;
                }
                else if ( (v60 & 0x1000) == 0 )
                {
LABEL_80:
                  _libc_multiple_libcs = 1;
                  if ( (dl_debug_mask & 0x40) != 0 )
                    return (_DWORD *)dl_debug_printf(
                                       (int)"opening file=%s [%lu]; direct_opencount=%u\n\n",
                                       (const char *)*(_DWORD *)(v7 + 4),
                                       *(_DWORD *)(v7 + 24),
                                       *(_DWORD *)(v7 + 400));
                  return result;
                }
                *(_DWORD *)(v7 + 516) |= 8u;
                goto LABEL_80;
              }
              continue;
            }
          }
LABEL_91:
          v53 = (_DWORD *)v40;
          memset(&s[v64], 0, n - v64);
          v40 = (int)v53;
          ++v64;
        }
        v43 = v61;
        while ( 1 )
        {
          v44 = *(int **)(*(_DWORD *)(v40 + 4 * v43) + 496);
          if ( v44 )
            break;
LABEL_89:
          if ( v37 >= --v43 )
            goto LABEL_90;
        }
        do
        {
          v45 = *v44;
          if ( !*v44 )
            goto LABEL_89;
          ++v44;
        }
        while ( v41 != v45 );
        v53 = (_DWORD *)v40;
        v54 = v43 - v37;
        memmove((void *)(v40 + 4 * v37), (const void *)(v40 + 4 * v64), 4 * (v43 - v37));
        v40 = (int)v53;
        v46 = s;
        v47 = v54;
        v53[v43] = v41;
        if ( v46[v64] > 1 )
        {
          v37 = v64;
          goto LABEL_91;
        }
        v53 = (_DWORD *)v40;
        memmove(&s[v37], &s[v64], v47);
        s[v43] = v58;
        v40 = (int)v53;
      }
    }
    if ( (dl_debug_mask & 0x40) != 0 )
      dl_debug_printf(
        (int)"opening file=%s [%lu]; direct_opencount=%u\n\n",
        *(const char **)(v7 + 4),
        *(_DWORD *)(v7 + 24),
        v9);
    if ( (v60 & 0x100) != 0 && (*(_BYTE *)(v7 + 404) & 0x10) == 0 )
      add_to_global((_DWORD *)v7);
    result = dl_debug_initialize(0, *(_DWORD *)(a1 + 20));
    if ( result[3] )
      _assert_fail("_dl_debug_initialize (0, args->nsid)->r_state == RT_CONSISTENT", "dl-open.c", 256, "dl_open_worker");
  }
  else if ( (v60 & 4) == 0 )
  {
    _assert_fail("mode & 0x00004", "dl-open.c", 232, "dl_open_worker");
  }
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 808E620: using guessed type int dl_debug_state(void);
// 80EF5BC: using guessed type int (__cdecl *dl_init_static_tls)(_DWORD);
// 80EF5C4: using guessed type int _libc_multiple_libcs;
// 80F1154: using guessed type int dl_tls_generation;
// 80F1190: using guessed type int dl_debug_mask;
// 80F11B8: using guessed type int dl_lazy;
// 80F11C0: using guessed type int dl_nns;
// 80F1200: using guessed type int dl_ns[];

//----- (080BC9A0) --------------------------------------------------------
int __usercall remove_slotinfo@<eax>(int a1@<eax>, unsigned int *a2@<edx>, int a3@<ecx>, char a4)
{
  int v4; // edi
  unsigned int v5; // eax
  char v8; // dl
  int result; // eax
  unsigned int v10; // edx
  unsigned int v11; // eax
  unsigned int v12; // edx
  int v13; // edx

  v4 = a1;
  v5 = a1 - a3;
  if ( v5 < *a2 )
  {
    v12 = a2[2 * v5 + 3];
    if ( v12 )
    {
      if ( *(_DWORD *)(v12 + 580) != v4 )
        _assert_fail("old_map->l_tls_modid == idx", "dl-close.c", 78, "remove_slotinfo");
      v13 = dl_tls_generation;
      a2[2 * v5 + 3] = 0;
      a2[2 * v5 + 2] = v13 + 1;
    }
    result = 1;
    if ( v4 != dl_tls_max_dtv_idx )
      return result;
  }
  else if ( a2[1] )
  {
    v8 = remove_slotinfo(a4);
    result = 1;
    if ( v8 )
      return result;
    v4 = a3 + *a2;
  }
  else if ( a4 )
  {
    _assert_fail("! should_be_there", "dl-close.c", 57, "remove_slotinfo");
  }
  v10 = 0;
  if ( !a3 )
    v10 = dl_tls_static_nelem + 1;
  v11 = v4 - a3;
  do
  {
    if ( v10 >= v11 )
      return 0;
    --v11;
    --v4;
  }
  while ( !a2[2 * v11 + 3] );
  dl_tls_max_dtv_idx = v4;
  return 1;
}
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 80F1148: using guessed type int dl_tls_max_dtv_idx;
// 80F1154: using guessed type int dl_tls_generation;
// 80F1158: using guessed type int dl_tls_static_nelem;

//----- (080BCAD0) --------------------------------------------------------
int *__cdecl dl_close_worker(int a1)
{
  int *result; // eax
  int v2; // edx
  bool v3; // zf
  int v4; // eax
  void *v5; // esp
  void *v6; // esp
  void *v7; // esp
  int v8; // eax
  int v9; // edx
  int *v10; // ecx
  int v11; // edi
  int v12; // eax
  size_t v13; // eax
  _BYTE *v14; // ecx
  int v15; // eax
  int v16; // edx
  size_t v17; // ecx
  int *v18; // eax
  int v19; // edx
  int v20; // edx
  unsigned int *v21; // ecx
  unsigned int v22; // edx
  int v23; // eax
  unsigned int v24; // esi
  signed int v25; // eax
  int v26; // esi
  unsigned int v27; // edi
  int v28; // ebx
  char v29; // al
  int v30; // eax
  int v31; // edx
  int v32; // eax
  int v33; // esi
  int v34; // edi
  int v35; // ebx
  int v36; // eax
  int v37; // eax
  int *v38; // ecx
  int v39; // edx
  int v40; // eax
  unsigned int v41; // esi
  char v42; // di
  int v43; // edx
  int *v44; // ecx
  int v45; // eax
  int v46; // ebx
  int v47; // ecx
  int v48; // edi
  int v49; // edx
  int v50; // eax
  int v51; // eax
  char v52; // cl
  size_t v53; // ecx
  int v54; // ecx
  int v55; // edx
  int v56; // eax
  int v57; // eax
  int v58; // eax
  int v59; // ebx
  _DWORD *v60; // eax
  void *v61; // esi
  _DWORD *v62; // eax
  void *v63; // edi
  int v64; // ecx
  void *v65; // edx
  void *v66; // edi
  int v67; // eax
  size_t v68; // esi
  int v69; // edi
  int v70; // ebx
  char v71; // al
  int v72; // eax
  int v73; // edx
  int v74; // eax
  size_t v75; // edi
  int v76; // esi
  int v77; // ebx
  int v78; // ebx
  int v79; // eax
  int v80; // eax
  int v81; // edx
  int *v82; // esi
  int v83; // eax
  char *v84; // eax
  char *v85; // edx
  void *v86; // ecx
  int v87; // [esp+0h] [ebp-88h] BYREF
  _BYTE v88[4]; // [esp+10h] [ebp-78h] BYREF
  int *v89; // [esp+14h] [ebp-74h]
  int v90; // [esp+18h] [ebp-70h]
  int *v91; // [esp+1Ch] [ebp-6Ch]
  char v92; // [esp+20h] [ebp-68h]
  int v93; // [esp+30h] [ebp-58h]
  int *v94; // [esp+34h] [ebp-54h]
  unsigned int v95; // [esp+38h] [ebp-50h]
  int v96; // [esp+3Ch] [ebp-4Ch]
  int v97; // [esp+40h] [ebp-48h]
  int v98; // [esp+44h] [ebp-44h]
  int *v99; // [esp+48h] [ebp-40h]
  unsigned int v100; // [esp+4Ch] [ebp-3Ch]
  int v101; // [esp+50h] [ebp-38h]
  _DWORD *v102; // [esp+54h] [ebp-34h]
  _DWORD *v103; // [esp+58h] [ebp-30h]
  int v104; // [esp+5Ch] [ebp-2Ch]
  int *v105; // [esp+60h] [ebp-28h]
  void *s; // [esp+64h] [ebp-24h]
  size_t v107; // [esp+68h] [ebp-20h]
  size_t n; // [esp+6Ch] [ebp-1Ch]

  result = (int *)a1;
  v2 = *(_DWORD *)(a1 + 400) - 1;
  v3 = *(_DWORD *)(a1 + 400) == 1;
  *(_DWORD *)(a1 + 400) = v2;
  if ( !v3 || (*(_BYTE *)(a1 + 404) & 3) != 2 )
    goto LABEL_3;
  if ( dl_close_state_9537 )
  {
    dl_close_state_9537 = 2;
LABEL_3:
    if ( (dl_debug_mask & 0x40) != 0 )
      return (int *)dl_debug_printf(
                      (int)"\nclosing file=%s; direct_opencount=%u\n",
                      (const char *)*(_DWORD *)(a1 + 4),
                      v2);
    return result;
  }
  v93 = *(_DWORD *)(a1 + 24);
  v94 = (int *)(76 * v93 + 135205376);
  while ( 2 )
  {
    v91 = &v87;
    dl_close_state_9537 = 1;
    n = v94[1];
    v4 = 16 * ((n + 30) / 0x10);
    v5 = alloca(v4);
    v6 = alloca(v4);
    s = v88;
    v7 = alloca(16 * ((4 * n + 30) / 0x10));
    v105 = (int *)v88;
    v8 = *v94;
    v9 = 0;
    if ( *v94 )
    {
      v10 = v105;
      do
      {
        *(_DWORD *)(v8 + 524) = v9;
        v10[v9] = v8;
        v8 = *(_DWORD *)(v8 + 12);
        ++v9;
      }
      while ( v8 );
    }
    if ( n != v9 )
      _assert_fail("idx == nloaded", "dl-close.c", 154, "_dl_close_worker");
    v11 = -1;
    memset(v88, 0, n);
    memset(s, 0, n);
    while ( n > ++v11 )
    {
      v12 = v105[v11];
      v3 = *((_BYTE *)s + v11) == 0;
      v107 = v12;
      if ( v3
        && ((*(_BYTE *)(v12 + 404) & 3) != 2 || *(_DWORD *)(v12 + 400) || (*(_BYTE *)(v12 + 516) & 8) != 0 || v88[v11]) )
      {
        v13 = v107;
        v88[v11] = 1;
        v14 = s;
        *(_DWORD *)(v13 + 524) = -1;
        v15 = *(_DWORD *)(v13 + 496);
        v14[v11] = 1;
        if ( v15 )
        {
          v16 = *(_DWORD *)(v15 + 4);
          if ( v16 )
          {
            v17 = n;
            v18 = (int *)(v15 + 4);
            do
            {
              v19 = *(_DWORD *)(v16 + 524);
              if ( v19 != -1 )
              {
                if ( v19 < 0 || v17 <= v19 )
                  _assert_fail("(*lp)->l_idx >= 0 && (*lp)->l_idx < nloaded", "dl-close.c", 191, "_dl_close_worker");
                if ( !v88[v19] )
                {
                  v88[v19] = 1;
                  v20 = *(_DWORD *)(*v18 + 524);
                  if ( v20 <= v11 )
                    v11 = v20 - 1;
                }
              }
              v16 = *++v18;
            }
            while ( *v18 );
          }
        }
        v21 = *(unsigned int **)(v107 + 500);
        if ( v21 && *v21 )
        {
          v22 = 0;
          do
          {
            v24 = v21[v22 + 1];
            v25 = *(_DWORD *)(v24 + 524);
            if ( v25 != -1 )
            {
              if ( v25 < 0 || n <= v25 )
                _assert_fail("jmap->l_idx >= 0 && jmap->l_idx < nloaded", "dl-close.c", 212, "_dl_close_worker");
              if ( !v88[v25] )
              {
                v88[v25] = 1;
                v23 = *(_DWORD *)(v24 + 524);
                if ( v23 <= v11 )
                  v11 = v23 - 1;
                v21 = *(unsigned int **)(v107 + 500);
              }
            }
            ++v22;
          }
          while ( *v21 > v22 );
        }
      }
    }
    result = dl_sort_fini(v105, n, (int)v88, v93);
    if ( !n )
      goto LABEL_105;
    v26 = *v105;
    if ( *(_DWORD *)(*v105 + 24) != v93 )
LABEL_64:
      _assert_fail("imap->l_ns == nsid", "dl-close.c", 240, "_dl_close_worker");
    v103 = v88;
    v27 = 0;
    v28 = v93;
    v107 = -1;
    s = 0;
    v92 = 0;
    LOBYTE(v102) = 0;
    while ( 1 )
    {
      v29 = *(_BYTE *)(v26 + 404);
      if ( *((_BYTE *)v103 + v27) )
      {
        result = (int *)(v29 & 3);
        if ( (_BYTE)result == 2 )
        {
          v37 = *(_DWORD *)(v26 + 348);
          v97 = 0;
          v100 = 1;
          if ( !v37 )
          {
            v54 = *(_DWORD *)(v26 + 496);
            if ( v54 )
            {
              v55 = 8;
              v56 = 1;
              if ( *(_DWORD *)(v54 + 4) )
              {
                do
                  ++v56;
                while ( *(_DWORD *)(v54 + 4 * v56) );
                v55 = 4 * v56 + 4;
              }
              *(_DWORD *)(v26 + 348) = v54 + v55;
              *(_DWORD *)(v26 + 352) = v56;
              v97 = v26 + 348;
              v100 = 2;
            }
          }
          v38 = *(int **)(v26 + 460);
          v39 = *v38;
          v99 = v38;
          if ( !v39 )
            goto LABEL_89;
          v89 = v38;
          v40 = v39;
          v104 = v26 + 356;
          v98 = v26;
          v41 = v100;
          v96 = v39;
          v95 = v27;
          v42 = 0;
          LOBYTE(v101) = 0;
          do
          {
            while ( v40 != v104 )
            {
              if ( *(_DWORD *)(v40 - 324) != v28 )
                _assert_fail("tmap->l_ns == nsid", "dl-close.c", 344, "_dl_close_worker");
              if ( *(_DWORD *)(v40 + 176) == -1 )
                break;
              ++v38;
              v42 = 1;
              v40 = *v38;
              if ( !*v38 )
                goto LABEL_74;
            }
            ++v38;
            ++v41;
            v40 = *v38;
          }
          while ( *v38 );
LABEL_74:
          v43 = v96;
          v3 = v42 == 0;
          v27 = v95;
          v100 = v41;
          v26 = v98;
          if ( v3 )
          {
LABEL_89:
            if ( v97 )
            {
              *(_DWORD *)(v26 + 348) = 0;
              *(_DWORD *)(v26 + 352) = 0;
            }
          }
          else
          {
            v44 = (int *)(v98 + 440);
            v98 += 440;
            if ( v100 > 3 || (v101 = v26 + 440, v100 = 4, v44 == v99) )
            {
              v57 = 4 * *(_DWORD *)(v26 + 456);
              v100 = *(_DWORD *)(v26 + 456);
              v90 = v96;
              v58 = malloc(v57);
              v43 = v90;
              v101 = v58;
              if ( !v58 )
                dl_signal_error("cannot create scope list");
            }
            v99 = (int *)v28;
            v45 = 4;
            v46 = v97;
            v47 = 0;
            v97 = v27;
            v48 = v101;
            do
            {
              while ( v104 == v43 || *(_DWORD *)(v43 + 176) == -1 )
              {
                *(_DWORD *)(v48 + 4 * v47++) = v43;
                v43 = *(_DWORD *)(*(_DWORD *)(v26 + 460) + v45);
                v45 += 4;
                if ( !v43 )
                  goto LABEL_84;
              }
              if ( v46 )
              {
                *(_DWORD *)(v48 + 4 * v47++) = v46;
                v46 = 0;
              }
              v43 = *(_DWORD *)(*(_DWORD *)(v26 + 460) + v45);
              v45 += 4;
            }
            while ( v43 );
LABEL_84:
            v49 = v101;
            v28 = (int)v99;
            v27 = v97;
            *(_DWORD *)(v101 + 4 * v47) = 0;
            v50 = *(_DWORD *)(v26 + 460);
            v3 = v98 == v50;
            *(_DWORD *)(v26 + 460) = v49;
            if ( v3 )
            {
              v92 = 1;
            }
            else
            {
              v51 = dl_scope_free(v50);
              v52 = v92;
              if ( v51 )
                v52 = 0;
              v92 = v52;
            }
            *(_DWORD *)(v26 + 456) = v100;
          }
          result = *(int **)(v26 + 364);
          if ( result && result[131] != -1 )
            *(_DWORD *)(v26 + 364) = 0;
          v53 = v107;
          if ( v27 < v107 )
            v53 = v27;
          v107 = v53;
        }
      }
      else
      {
        if ( (v29 & 3) != 2 || (*(_BYTE *)(v26 + 516) & 8) != 0 )
          _assert_fail(
            "imap->l_type == lt_loaded && (imap->l_flags_1 & 0x00000008) == 0",
            "dl-close.c",
            245,
            "_dl_close_worker");
        if ( (v29 & 8) != 0 )
        {
          if ( (dl_debug_mask & 2) != 0 )
            dl_debug_printf((int)"\ncalling fini: %s [%lu]\n\n", *(const char **)(v26 + 4), v28);
          v30 = *(_DWORD *)(v26 + 136);
          if ( v30 )
          {
            v31 = *(_DWORD *)v26 + *(_DWORD *)(v30 + 4);
            v32 = *(_DWORD *)(*(_DWORD *)(v26 + 144) + 4) >> 2;
            if ( v32 )
            {
              v104 = v26;
              v33 = v31;
              v102 = (_DWORD *)v27;
              v34 = v28;
              v35 = v32;
              do
                (*(void (**)(void))(v33 + 4 * v35-- - 4))();
              while ( v35 );
              v28 = v34;
              v26 = v104;
              v27 = (unsigned int)v102;
            }
          }
          v36 = *(_DWORD *)(v26 + 84);
          if ( v36 )
            ((void (*)(void))(*(_DWORD *)(v36 + 4) + *(_DWORD *)v26))();
          v29 = *(_BYTE *)(v26 + 404);
        }
        *(_BYTE *)(v26 + 405) |= 0x20u;
        result = (int *)(v29 & 0x10);
        s = (char *)s - ((_BYTE)result == 0) + 1;
        if ( v27 < v107 )
          v107 = v27;
        LOBYTE(v102) = 1;
      }
      if ( ++v27 == n )
        break;
      v26 = v105[v27];
      if ( *(_DWORD *)(v26 + 24) != v28 )
        goto LABEL_64;
    }
    v59 = (int)v103;
    if ( !(_BYTE)v102 )
      goto LABEL_105;
    v60 = dl_debug_initialize(0, v93);
    v60[3] = 2;
    v102 = v60;
    dl_debug_state();
    if ( s )
    {
      v61 = 0;
      v62 = (_DWORD *)v94[2];
      v63 = (void *)v62[1];
      v103 = v62;
      if ( v63 )
      {
        v64 = *v62;
        v65 = v63;
        if ( (*(_BYTE *)(*(_DWORD *)(*v62 + 4 * (_DWORD)v63 - 4) + 405) & 0x20) != 0 )
        {
          do
            v65 = (char *)v65 - 1;
          while ( v65 && (*(_BYTE *)(*(_DWORD *)(v64 + 4 * (_DWORD)v65 - 4) + 405) & 0x20) != 0 );
        }
        v61 = v65;
        if ( v63 != (char *)s + (_DWORD)v65 )
        {
          v61 = 0;
          if ( v65 )
          {
            v66 = 0;
            while ( 1 )
            {
              v67 = *(_DWORD *)(v64 + 4 * (_DWORD)v66);
              if ( (*(_BYTE *)(v67 + 405) & 0x20) == 0 )
              {
                if ( v66 != v61 )
                  *(_DWORD *)(v64 + 4 * (_DWORD)v61) = v67;
                v61 = (char *)v61 + 1;
              }
              v66 = (char *)v66 + 1;
              if ( v66 == v65 )
                break;
              v64 = *v103;
            }
          }
        }
      }
      v103[1] = v61;
    }
    if ( __readgsdword(0xCu) && (s || v92 || dl_scope_free_list && *(_DWORD *)dl_scope_free_list) )
    {
      dl_wait_lookup_done();
      v82 = (int *)dl_scope_free_list;
      if ( dl_scope_free_list )
      {
        while ( *v82 )
        {
          v83 = *v82 - 1;
          *v82 = v83;
          free(v82[v83 + 1]);
        }
      }
    }
    if ( n <= v107 )
    {
      v107 = 0;
      s = 0;
      LOBYTE(v104) = 0;
      goto LABEL_154;
    }
    v68 = v107;
    v69 = v59;
    v107 = 0;
    s = 0;
    LOBYTE(v104) = 0;
    do
    {
      v70 = v105[v68];
      if ( *(_BYTE *)(v69 + v68) )
        goto LABEL_153;
      v71 = *(_BYTE *)(v70 + 404);
      if ( (v71 & 3) != 2 )
        _assert_fail("imap->l_type == lt_loaded", "dl-close.c", 527, "_dl_close_worker");
      if ( *(_DWORD *)(v70 + 564) )
      {
        if ( dl_tls_dtv_slotinfo_list )
        {
          v103 = *(_DWORD **)(v70 + 580);
          if ( !(unsigned __int8)remove_slotinfo((int)v103, (unsigned int *)dl_tls_dtv_slotinfo_list, 0, (v71 & 8) != 0) )
            dl_tls_max_dtv_idx = dl_tls_static_nelem;
        }
        v84 = *(char **)(v70 + 576);
        LOBYTE(v104) = 1;
        if ( (unsigned int)v84 > 1 )
        {
          v85 = &v84[-*(_DWORD *)(v70 + 564)];
          if ( !s || s == v84 )
          {
            s = &v84[-*(_DWORD *)(v70 + 564)];
            LOBYTE(v104) = 1;
            if ( v107 )
              v84 = (char *)v107;
            v107 = (size_t)v84;
          }
          else if ( v85 == (char *)v107 )
          {
            v107 = (size_t)v84;
          }
          else if ( v107 == dl_tls_static_used )
          {
            v86 = s;
            v107 = (size_t)v84;
            s = v85;
            dl_tls_static_used = (int)v86;
          }
          else if ( v84 == (char *)dl_tls_static_used )
          {
            dl_tls_static_used = (int)&v84[-*(_DWORD *)(v70 + 564)];
          }
          else if ( (unsigned int)v84 > v107 )
          {
            v107 = (size_t)v84;
            s = v85;
          }
        }
      }
      dl_unmap(v70);
      v72 = *(_DWORD *)(v70 + 16);
      v73 = *(_DWORD *)(v70 + 12);
      if ( v72 )
      {
        *(_DWORD *)(v72 + 12) = v73;
        v73 = *(_DWORD *)(v70 + 12);
      }
      else
      {
        *v94 = v73;
      }
      --v94[1];
      if ( v73 )
        *(_DWORD *)(v73 + 16) = v72;
      free(*(_DWORD *)(v70 + 368));
      if ( *(_DWORD *)(v70 + 424) != -1 )
        free(*(_DWORD *)(v70 + 424));
      free(*(_DWORD *)(v70 + 500));
      if ( (dl_debug_mask & 0x40) != 0 )
        dl_debug_printf(
          (int)"\nfile=%s [%lu];  destroying link map\n",
          *(const char **)(v70 + 4),
          *(_DWORD *)(v70 + 24));
      free(*(_DWORD *)(v70 + 4));
      v74 = *(_DWORD *)(v70 + 28);
      v103 = (_DWORD *)v69;
      v75 = v68;
      v76 = v70;
      while ( 1 )
      {
        v77 = *(_DWORD *)(v74 + 4);
        if ( !*(_DWORD *)(v74 + 8) )
          break;
        if ( !v77 )
          goto LABEL_144;
LABEL_141:
        v74 = v77;
      }
      free(v74);
      if ( v77 )
        goto LABEL_141;
LABEL_144:
      v78 = v76;
      v68 = v75;
      v69 = (int)v103;
      free(*(_DWORD *)(v78 + 496));
      v79 = *(_DWORD *)(v78 + 460);
      if ( v79 != v78 + 440 )
        free(v79);
      if ( *(char *)(v78 + 404) < 0 )
        free(*(_DWORD *)(v78 + 336));
      if ( *(_DWORD *)(v78 + 408) != -1 )
        free(*(_DWORD *)(v78 + 408));
      if ( *(_DWORD *)(v78 + 488) != -1 )
        free(*(_DWORD *)(v78 + 488));
      free(v78);
LABEL_153:
      ++v68;
    }
    while ( n > v68 );
LABEL_154:
    if ( (_BYTE)v104 )
    {
      if ( !++dl_tls_generation )
      {
        dl_dprintf(
          2,
          (int)"TLS generation counter wrapped!  Please report as described in <http://www.debian.org/Bugs/>.\n");
        exit(127);
      }
      if ( v107 == dl_tls_static_used )
        dl_tls_static_used = (int)s;
    }
    if ( !*v94 )
    {
      v80 = dl_nns - 1;
      if ( v93 == dl_nns - 1 )
      {
        v81 = 76 * (dl_nns - 2) + 135205376;
        while ( v80 )
        {
          v81 -= 76;
          if ( *(_DWORD *)(v81 + 76) )
          {
            dl_nns = v80;
            goto LABEL_159;
          }
          --v80;
        }
        dl_nns = 0;
      }
    }
LABEL_159:
    v102[3] = 0;
    result = (int *)dl_debug_state();
LABEL_105:
    if ( dl_close_state_9537 == 2 )
      continue;
    break;
  }
  dl_close_state_9537 = 0;
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 808E620: using guessed type int dl_debug_state(void);
// 80F0FF8: using guessed type int dl_close_state_9537;
// 80F1140: using guessed type int dl_tls_static_used;
// 80F1148: using guessed type int dl_tls_max_dtv_idx;
// 80F114C: using guessed type int dl_tls_dtv_slotinfo_list;
// 80F1154: using guessed type int dl_tls_generation;
// 80F1158: using guessed type int dl_tls_static_nelem;
// 80F1190: using guessed type int dl_debug_mask;
// 80F11A0: using guessed type int (*dl_wait_lookup_done)(void);
// 80F11C0: using guessed type int dl_nns;
// 80F11C4: using guessed type int dl_scope_free_list;

//----- (080BD680) --------------------------------------------------------
int __usercall dl_close@<eax>(int a1@<ebp>, long double a2@<st0>, int a3)
{
  int result; // eax

  if ( (*(_BYTE *)(a3 + 516) & 8) != 0 )
  {
    if ( (*(_BYTE *)(a3 + 404) & 8) == 0 )
      _assert_fail(a1, a2, (int)"map->l_init_called", (int)"dl-close.c", 759, "_dl_close");
  }
  else
  {
    if ( !*(_DWORD *)(a3 + 400) )
      dl_signal_error(0, *(_BYTE **)(a3 + 4), 0, a2, "shared object not open");
    dl_close_worker(a3);
    return 0;
  }
  return result;
}
// 80BD6CD: control flows out of bounds to 0

//----- (080BD720) --------------------------------------------------------
long double __cdecl _mpn_construct_float(_DWORD *a1, char a2, unsigned __int8 a3)
{
  return COERCE_FLOAT(*a1 & 0x7FFFFF | ((unsigned __int8)(a2 + 127) << 23) | (a3 << 31));
}

//----- (080BD760) --------------------------------------------------------
long double __cdecl _mpn_construct_double(_DWORD *a1, __int16 a2, unsigned __int8 a3)
{
  double v4; // [esp+0h] [ebp-Ch]

  LODWORD(v4) = *a1;
  HIDWORD(v4) = a1[1] & 0xFFFFF | (((a2 + 1023) & 0x7FF) << 20) | (a3 << 31);
  return v4;
}

//----- (080BD7D0) --------------------------------------------------------
long double __cdecl _mpn_construct_long_double(_QWORD *a1, __int16 a2, char a3)
{
  long double v4; // [esp+0h] [ebp-10h]

  BYTE9(v4) = (a3 << 7) | BYTE9(v4) & 0x7F;
  WORD4(v4) = (a2 + 0x3FFF) & 0x7FFF | WORD4(v4) & 0x8000;
  *(_QWORD *)&v4 = *a1;
  return v4;
}
// 80BD7E0: variable 'v4' is possibly undefined

//----- (080BD820) --------------------------------------------------------
int __usercall dlopen_doit@<eax>(long double a1@<st0>, int a2)
{
  void *v2; // eax
  int result; // eax
  char *v4; // eax

  if ( (*(_DWORD *)(a2 + 4) & 0xBFFFEEF0) != 0 )
  {
    v4 = dcgettext(a1, "libc", "invalid mode parameter", 5);
    dl_signal_error(0, 0, 0, a1, v4);
  }
  v2 = *(void **)a2;
  if ( !*(_DWORD *)a2 )
    v2 = &unk_80C86D9;
  result = dl_open(
             (int)v2,
             *(_DWORD *)(a2 + 4) | 0x80000000,
             *(_DWORD *)(a2 + 12),
             0,
             _libc_argc,
             _libc_argv,
             (int)environ);
  *(_DWORD *)(a2 + 8) = result;
  return result;
}
// 80F1250: using guessed type int _libc_argc;
// 80F1254: using guessed type int _libc_argv;

//----- (080BD8C0) --------------------------------------------------------
int __usercall _dlopen@<eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3@<edi>,
        int a4@<esi>,
        long double a5@<st0>,
        int a6,
        int a7,
        int a8)
{
  _BOOL4 v8; // eax
  int v9; // edx
  int v11[2]; // [esp+10h] [ebp-1Ch] BYREF
  int v12; // [esp+18h] [ebp-14h]
  int v13; // [esp+1Ch] [ebp-10h]

  v11[0] = a6;
  v11[1] = a7;
  v13 = a8;
  v8 = dlerror_run((void (__cdecl *)(int))dlopen_doit, (int)v11, a5);
  v9 = 0;
  if ( !v8 )
  {
    _libc_register_dl_open_hook(a1, a2, a3, a4, v12);
    _libc_register_dlfcn_hook(a1, a2, a3, a4, v12);
    return v12;
  }
  return v9;
}

//----- (080BD930) --------------------------------------------------------
int __usercall _dlclose@<eax>(long double a1@<st0>, int a2)
{
  return -dlerror_run((void (__cdecl *)(int))dlclose_doit, a2, a1);
}
// 80BD920: using guessed type int dlclose_doit();

//----- (080BD950) --------------------------------------------------------
int (*__usercall dlsym_doit@<eax>(int a1@<edi>, long double a2@<st0>, int a3))(void)
{
  int (*result)(void); // eax

  result = dl_sym(*(_DWORD *)a3, *(char **)(a3 + 4), *(_DWORD *)(a3 + 8), a3, a1, a2);
  *(_DWORD *)(a3 + 12) = result;
  return result;
}

//----- (080BD970) --------------------------------------------------------
int __usercall _dlsym@<eax>(long double a1@<st0>, int a2, int a3, int a4)
{
  int v4; // ebx
  int v6[7]; // [esp+10h] [ebp-1Ch] BYREF

  v6[2] = a4;
  v6[0] = a2;
  v6[1] = a3;
  v4 = 0;
  if ( !dlerror_run((void (__cdecl *)(int))dlsym_doit, (int)v6, a1) )
    return v6[3];
  return v4;
}

//----- (080BD9E0) --------------------------------------------------------
int (*__usercall dlvsym_doit@<eax>(int a1@<edi>, long double a2@<st0>, int a3))(void)
{
  int (*result)(void); // eax

  result = dl_vsym(*(_DWORD *)a3, *(char **)(a3 + 4), *(unsigned __int8 **)(a3 + 8), a1, a2, *(_DWORD *)(a3 + 12));
  *(_DWORD *)(a3 + 16) = result;
  return result;
}

//----- (080BDA10) --------------------------------------------------------
int __usercall _dlvsym@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5)
{
  int v5; // ebx
  int v7[8]; // [esp+1Ch] [ebp-20h] BYREF

  v7[0] = a2;
  v7[1] = a3;
  v7[3] = a5;
  v7[2] = a4;
  v5 = 0;
  if ( !dlerror_run((void (__cdecl *)(int))dlvsym_doit, (int)v7, a1) )
    return v7[4];
  return v5;
}

//----- (080BDA80) --------------------------------------------------------
int __cdecl _strncasecmp_nonascii(char *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // ecx
  char *v4; // esi
  unsigned int v5; // eax
  char v6; // bp
  int v7; // edi
  int v8; // edx

  v3 = a2;
  v4 = a1;
  v5 = __readgsdword(0xFFFFFFD8);
  if ( !a3 || a1 == (char *)a2 )
    return 0;
  do
  {
    v6 = *v4;
    v7 = *v3++;
    v8 = *(_DWORD *)(*(_DWORD *)(v5 + 56) + 4 * (unsigned __int8)*v4) - *(_DWORD *)(*(_DWORD *)(v5 + 56) + 4 * v7);
    if ( v8 )
      break;
    ++v4;
    if ( !v6 )
      break;
    --a3;
  }
  while ( a3 );
  return v8;
}

//----- (080BDB00) --------------------------------------------------------
unsigned int __cdecl setitimer(int a1, int a2)
{
  unsigned int result; // eax

  result = dl_sysinfo(a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);

//----- (080BDB30) --------------------------------------------------------
int __usercall dl_build_local_scope@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  _DWORD *v3; // esi
  int v4; // ebx
  int v5; // edx
  int *v6; // ebx
  int v7; // eax

  v3 = a1 + 1;
  *a1 = a2;
  v4 = *(_DWORD *)(a2 + 496);
  *(_BYTE *)(a2 + 404) = *(_BYTE *)(a2 + 404) & 0x9F | 0x20;
  if ( v4 )
  {
    v5 = *(_DWORD *)(v4 + 4);
    if ( v5 )
    {
      v6 = (int *)(v4 + 4);
      do
      {
        while ( (*(_BYTE *)(v5 + 404) & 0x60) != 0 )
        {
          v5 = *++v6;
          if ( !*v6 )
            return v3 - a1;
        }
        ++v6;
        v7 = dl_build_local_scope();
        v5 = *v6;
        v3 += v7;
      }
      while ( *v6 );
    }
  }
  return v3 - a1;
}

//----- (080BDBA0) --------------------------------------------------------
int __cdecl openaux(int a1)
{
  char v1; // cl
  int result; // eax

  v1 = 1;
  if ( (*(_BYTE *)(*(_DWORD *)a1 + 404) & 3) != 0 )
    v1 = *(_BYTE *)(*(_DWORD *)a1 + 404) & 3;
  result = dl_map_object(
             *(_DWORD *)a1,
             *(char **)(a1 + 16),
             v1,
             *(_DWORD *)(a1 + 4),
             *(_DWORD *)(a1 + 8),
             *(_DWORD *)(*(_DWORD *)a1 + 24));
  *(_DWORD *)(a1 + 20) = result;
  return result;
}

//----- (080BDC10) --------------------------------------------------------
_BYTE *__userpurge dl_map_object_deps@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5)
{
  void *v5; // esp
  _DWORD *v6; // esi
  int v7; // eax
  unsigned int *v8; // eax
  int v9; // ebx
  unsigned int v10; // esi
  int v11; // edi
  int v12; // eax
  int v13; // eax
  int *v14; // ebx
  int v15; // eax
  char *v16; // esi
  char *v17; // eax
  char *v18; // eax
  int v19; // eax
  int v20; // eax
  size_t v21; // esi
  size_t v22; // ebx
  size_t v23; // esi
  _BYTE *v24; // eax
  _BYTE *v25; // ebx
  unsigned int v26; // esi
  _DWORD *v27; // eax
  int v28; // eax
  _BYTE *v29; // ecx
  int v30; // edx
  unsigned int v31; // eax
  unsigned int v32; // ecx
  void *v33; // esp
  int v34; // eax
  unsigned __int16 v35; // ax
  unsigned int v36; // eax
  unsigned int v37; // eax
  void *v38; // esp
  bool v39; // al
  size_t v40; // ecx
  int v41; // edx
  _BYTE *v42; // eax
  int v43; // ebx
  int v44; // edx
  int v45; // eax
  _BYTE *v46; // eax
  _DWORD *v47; // esi
  int i; // ebx
  int v49; // ecx
  unsigned int v50; // ebx
  int v51; // edx
  int v52; // eax
  unsigned int *v53; // edi
  unsigned int v54; // ecx
  unsigned int v55; // eax
  unsigned int v56; // edx
  size_t v57; // eax
  int v58; // ebx
  int j; // edx
  int v60; // ecx
  void *v61; // esp
  unsigned int v62; // edx
  _BYTE *v63; // eax
  int v64; // ebx
  size_t v65; // esi
  _BYTE *v66; // edi
  int *v67; // eax
  int v68; // ecx
  int v69; // edx
  size_t v70; // ecx
  _BYTE *result; // eax
  int v72; // edx
  _DWORD *v73; // ecx
  char v74; // bl
  int v75; // eax
  void *v76; // esp
  _BYTE *v77; // esi
  int v78; // eax
  void *v79; // esp
  _BYTE *v80; // eax
  unsigned int v81; // edx
  char *v82; // eax
  char *v83; // edx
  bool v84; // zf
  _DWORD *v85; // esi
  size_t v86; // eax
  int v87; // edx
  size_t v88; // esi
  int *v89; // esi
  int v90; // esi
  int v91; // eax
  int v92; // esi
  int v93; // eax
  int v94; // eax
  _DWORD *v95; // esi
  int v96; // eax
  void *v97; // esp
  _BYTE *v98; // esi
  int v99; // eax
  void *v100; // esp
  size_t v101; // eax
  const char *v102; // eax
  _BYTE *origin; // eax
  unsigned int v104; // edx
  unsigned int v105; // eax
  void *v106; // esp
  unsigned int v107; // eax
  const char *v108; // eax
  int v109; // edi
  _DWORD *v110; // esi
  int v111; // ebx
  int v112; // eax
  unsigned int v113; // eax
  int v114; // edx
  int v115; // eax
  int v116; // eax
  int v117; // edx
  int v118; // [esp-10h] [ebp-B8h] BYREF
  int v119; // [esp-Ch] [ebp-B4h]
  int v120; // [esp-8h] [ebp-B0h]
  int v121; // [esp+0h] [ebp-A8h] BYREF
  _DWORD v122[3]; // [esp+10h] [ebp-98h] BYREF
  unsigned int v123; // [esp+1Ch] [ebp-8Ch] BYREF
  _DWORD *v124; // [esp+20h] [ebp-88h]
  unsigned int v125; // [esp+24h] [ebp-84h]
  unsigned int v126; // [esp+28h] [ebp-80h] BYREF
  size_t v127; // [esp+2Ch] [ebp-7Ch]
  int *v128; // [esp+30h] [ebp-78h]
  size_t v129; // [esp+34h] [ebp-74h]
  int v130; // [esp+38h] [ebp-70h]
  void *dest; // [esp+3Ch] [ebp-6Ch]
  _DWORD *v132; // [esp+40h] [ebp-68h]
  unsigned int v133; // [esp+44h] [ebp-64h]
  size_t v134; // [esp+48h] [ebp-60h]
  size_t v135; // [esp+4Ch] [ebp-5Ch]
  int v136; // [esp+50h] [ebp-58h]
  _DWORD *v137; // [esp+54h] [ebp-54h]
  size_t v138; // [esp+58h] [ebp-50h]
  size_t n; // [esp+5Ch] [ebp-4Ch]
  int v140[4]; // [esp+6Ch] [ebp-3Ch] BYREF
  char *v141; // [esp+7Ch] [ebp-2Ch]
  int v142; // [esp+80h] [ebp-28h]
  _BYTE *v143; // [esp+84h] [ebp-24h] BYREF
  _BYTE *v144; // [esp+88h] [ebp-20h] BYREF
  char v145[25]; // [esp+8Fh] [ebp-19h] BYREF
  int savedregs; // [esp+A8h] [ebp+0h] BYREF

  v130 = a1;
  v5 = alloca(12 * a3 + 39);
  v6 = v122;
  v124 = v122;
  v122[1] = a1;
  v122[0] = 0;
  v122[2] = &v123;
  *(_BYTE *)(a1 + 404) = *(_BYTE *)(a1 + 404) & 0x9F | 0x20;
  v7 = 0;
  v134 = 1;
  if ( a3 )
  {
    v8 = &v126;
    v9 = 0;
    n = (size_t)v122;
    do
    {
      v10 = *(_DWORD *)(a2 + 4 * v9++);
      *(v8 - 3) = 0;
      *(v8 - 1) = (unsigned int)v8;
      *(v8 - 2) = v10;
      v8 += 3;
      *(_BYTE *)(v10 + 404) = *(_BYTE *)(v10 + 404) & 0x9F | 0x20;
    }
    while ( v9 != a3 );
    v6 = (_DWORD *)n;
    v134 = v9 + 1;
    v7 = 3 * v9;
  }
  v135 = (size_t)&v6[v7];
  v6[v7 + 2] = 0;
  v143 = 0;
  v132 = v6;
  v126 = 0;
  v127 = 0;
  v125 = __readgsdword(0xFFFFFFE8);
  __writegsdword(0xFFFFFFE8, 0);
  do
  {
LABEL_6:
    v138 = 0;
    v11 = v132[1];
    *v132 = 1;
    if ( !*(_DWORD *)(v11 + 348) )
    {
      if ( v11 == v130 || *(_DWORD *)(v11 + 496) )
      {
        v138 = 0;
      }
      else
      {
        v35 = *(_WORD *)(v11 + 346);
        if ( v35 )
        {
          v36 = 4 * v35;
          v138 = v127;
          if ( v36 > v126 )
          {
            v37 = (v36 + 15) & 0xFFFFFFF0;
            v38 = alloca((v37 + 30) & 0xFFFF0);
            if ( (_DWORD *)v127 == (_DWORD *)((char *)v122 + v37) )
            {
              v126 += v37;
              v127 = (size_t)v122;
              v138 = (size_t)v122;
            }
            else
            {
              v138 = (size_t)v122;
              v126 = v37;
              v127 = (size_t)v122;
            }
          }
        }
      }
    }
    if ( *(_DWORD *)(v11 + 36) || *(_DWORD *)(v11 + 240) || *(_DWORD *)(v11 + 232) )
    {
      v12 = *(_DWORD *)(v11 + 52);
      v140[0] = v11;
      v13 = *(_DWORD *)(v12 + 4);
      v140[2] = a5;
      v14 = *(int **)(v11 + 8);
      v140[1] = a4;
      v137 = (_DWORD *)v13;
      v140[3] = v13;
      v15 = *v14;
      if ( *v14 )
      {
        n = 0;
        dest = v132;
        while ( v15 != 1 )
        {
          if ( v15 == 0x7FFFFFFF || v15 == 2147483645 )
          {
            v16 = (char *)v137 + v14[1];
            v82 = strchr(v16, 36);
            if ( !v82 || (v136 = dl_dst_count((int)v82, 0)) == 0 )
            {
              v83 = v16;
LABEL_115:
              v84 = *v14 == 2147483645;
              v141 = v83;
              if ( v84 )
              {
                if ( (dl_debug_mask & 1) != 0 )
                {
                  v108 = *(const char **)(v11 + 4);
                  if ( !*v108 )
                    v108 = (const char *)program_invocation_short_name;
                  dl_debug_printf((int)"load auxiliary object=%s requested by file=%s\n", v83, v108);
                }
                dl_catch_error(
                  &v144,
                  &v143,
                  v145,
                  (int)v14,
                  (int)&savedregs,
                  v11,
                  (int)v16,
                  (void (__cdecl *)(int))openaux,
                  (int)v140);
                if ( v143 )
                {
                  if ( v145[0] )
                    free(v143);
                  goto LABEL_18;
                }
              }
              else
              {
                if ( (dl_debug_mask & 1) != 0 )
                {
                  v102 = *(const char **)(v11 + 4);
                  if ( !*v102 )
                    v102 = (const char *)program_invocation_short_name;
                  dl_debug_printf((int)"load filtered object=%s requested by file=%s\n", v83, v102);
                }
                v133 = dl_catch_error(
                         &v144,
                         &v143,
                         v145,
                         (int)v14,
                         (int)&savedregs,
                         v11,
                         (int)v16,
                         (void (__cdecl *)(int))openaux,
                         (int)v140);
                if ( v143 )
                {
                  v96 = strlen(v143);
                  v97 = alloca(v96 + 16);
                  v98 = memcpy(v122, v143, v96 + 1);
                  v99 = strlen(v144);
                  v100 = alloca(v99 + 16);
                  v144 = memcpy(v122, v144, v99 + 1);
                  if ( v145[0] )
                    free(v143);
                  v143 = v98;
                  if ( v133 )
                  {
                    v39 = __readgsdword(0xFFFFFFE8) == 0;
                    goto LABEL_52;
                  }
LABEL_129:
                  v133 = -1;
                  v39 = __readgsdword(0xFFFFFFE8) == 0;
                  goto LABEL_52;
                }
              }
              v85 = dest;
              v118 = *(_DWORD *)dest;
              v119 = *((_DWORD *)dest + 1);
              v120 = *((_DWORD *)dest + 2);
              v86 = v138;
              v87 = v142;
              *(_DWORD *)dest = 0;
              v85[1] = v87;
              if ( v86 )
              {
                v88 = n;
                *(_DWORD *)(v138 + 4 * n) = v87;
                v87 = v142;
                n = v88 + 1;
              }
              v89 = &v118;
              if ( (*(_BYTE *)(v87 + 404) & 0x60) != 0 )
              {
                while ( 1 )
                {
                  v94 = v89[2];
                  if ( !v94 )
                  {
                    v95 = dest;
                    *(_DWORD *)dest = v118;
                    v95[1] = v119;
                    v95[2] = v120;
                    goto LABEL_18;
                  }
                  if ( *(_DWORD *)(v94 + 4) == v87 )
                    break;
                  v89 = (int *)v89[2];
                }
                *((_DWORD *)dest + 2) = &v118;
                v101 = v135;
                if ( v89[2] == v135 )
                  v101 = (size_t)v89;
                v135 = v101;
                v89[2] = *(_DWORD *)(v89[2] + 8);
                v90 = *(_DWORD *)(v87 + 16);
                if ( v90 )
LABEL_122:
                  *(_DWORD *)(v90 + 12) = *(_DWORD *)(v87 + 12);
              }
              else
              {
                ++v134;
                *((_DWORD *)dest + 2) = &v118;
                v90 = *(_DWORD *)(v87 + 16);
                *(_BYTE *)(v87 + 404) = *(_BYTE *)(v87 + 404) & 0x9F | 0x20;
                if ( v90 )
                  goto LABEL_122;
              }
              v91 = *(_DWORD *)(v87 + 12);
              if ( v91 )
                *(_DWORD *)(v91 + 16) = v90;
              v92 = v119;
              *(_DWORD *)(v87 + 16) = *(_DWORD *)(v119 + 16);
              *(_DWORD *)(v92 + 16) = v87;
              v93 = *(_DWORD *)(v87 + 16);
              if ( v93 )
                *(_DWORD *)(v93 + 12) = v87;
              *(_DWORD *)(v87 + 12) = v92;
              v84 = dest == (void *)v135;
              dest = &v118;
              if ( v84 )
                v135 = (size_t)&v118;
              goto LABEL_18;
            }
            if ( _libc_enable_secure )
LABEL_106:
              dl_signal_error("DST not allowed in SUID/SGID programs");
            v133 = strlen(v16);
            origin = *(_BYTE **)(v11 + 424);
            if ( origin )
            {
              v104 = 0;
              if ( origin != (_BYTE *)-1 )
                goto LABEL_154;
            }
            else
            {
              if ( **(_BYTE **)(v11 + 4) )
                _assert_fail("(l)->l_name[0] == '\\0' || 0", "dl-deps.c", 305, "_dl_map_object_deps");
              origin = (_BYTE *)dl_get_origin();
              v104 = 0;
              *(_DWORD *)(v11 + 424) = origin;
              if ( (unsigned int)(origin - 1) <= 0xFFFFFFFD )
LABEL_154:
                v104 = strlen(origin);
            }
            v105 = 5;
            if ( (unsigned int)dl_platformlen >= 5 )
              v105 = dl_platformlen;
            if ( v105 < v104 )
              v105 = v104;
            v106 = alloca(v133 + v136 * (v105 - 4) + 15);
            v83 = dl_dst_substitute(v11, v16, (char *)v122, 0);
            if ( *v83 )
              goto LABEL_115;
            if ( *v14 == 2147483645 )
              dl_signal_error("empty dynamic string token substitution");
LABEL_37:
            if ( (dl_debug_mask & 1) != 0 )
              dl_debug_printf(
                (int)"cannot load auxiliary `%s' because of empty dynamic string token substitution\n",
                v16);
          }
LABEL_18:
          v14 += 2;
          v15 = *v14;
          if ( !*v14 )
            goto LABEL_19;
        }
        v16 = (char *)v137 + v14[1];
        v17 = strchr(v16, 36);
        if ( !v17 || (v136 = dl_dst_count((int)v17, 0)) == 0 )
        {
          v18 = v16;
LABEL_13:
          v141 = v18;
          v19 = dl_catch_error(
                  &v144,
                  &v143,
                  v145,
                  (int)v14,
                  (int)&savedregs,
                  v11,
                  (int)v16,
                  (void (__cdecl *)(int))openaux,
                  (int)v140);
          if ( v143 )
          {
            v123 = v19;
            v75 = strlen(v143);
            v76 = alloca(v75 + 16);
            v77 = memcpy(v122, v143, v75 + 1);
            v78 = strlen(v144);
            v79 = alloca(v78 + 16);
            v80 = memcpy(v122, v144, v78 + 1);
            v81 = v123;
            v144 = v80;
            if ( v145[0] )
            {
              free(v143);
              v81 = v123;
            }
            v143 = v77;
            if ( v81 )
            {
              v133 = v81;
              v39 = __readgsdword(0xFFFFFFE8) == 0;
              goto LABEL_52;
            }
            goto LABEL_129;
          }
          v20 = v142;
          if ( (*(_BYTE *)(v142 + 404) & 0x60) == 0 )
          {
            ++v134;
            v120 = 0;
            v119 = v142;
            v118 = 0;
            *(_DWORD *)(v135 + 8) = &v118;
            *(_BYTE *)(v20 + 404) = *(_BYTE *)(v20 + 404) & 0x9F | 0x20;
            v135 = (size_t)&v118;
          }
          if ( v138 )
          {
            v21 = n;
            *(_DWORD *)(v138 + 4 * n) = v20;
            n = v21 + 1;
          }
          goto LABEL_18;
        }
        if ( _libc_enable_secure )
          goto LABEL_106;
        v28 = strlen(v16);
        v29 = *(_BYTE **)(v11 + 424);
        v30 = v28;
        if ( v29 )
        {
          v31 = 0;
          if ( v29 == (_BYTE *)-1 )
            goto LABEL_32;
        }
        else
        {
          if ( **(_BYTE **)(v11 + 4) )
            _assert_fail("(l)->l_name[0] == '\\0' || 0", "dl-deps.c", 253, "_dl_map_object_deps");
          v123 = v28;
          v34 = dl_get_origin();
          v30 = v123;
          v29 = (_BYTE *)v34;
          *(_DWORD *)(v11 + 424) = v34;
          v133 = v34 - 1;
          v31 = 0;
          if ( v133 > 0xFFFFFFFD )
          {
LABEL_32:
            v32 = 5;
            if ( (unsigned int)dl_platformlen >= 5 )
              v32 = dl_platformlen;
            if ( v32 >= v31 )
              v31 = v32;
            v33 = alloca(v30 + v136 * (v31 - 4) + 15);
            v18 = dl_dst_substitute(v11, v16, (char *)v122, 0);
            if ( !*v18 )
              goto LABEL_37;
            goto LABEL_13;
          }
        }
        v123 = v30;
        v31 = strlen(v29);
        v30 = v123;
        goto LABEL_32;
      }
    }
    n = 0;
LABEL_19:
    if ( v138 )
    {
      v22 = n;
      *(_DWORD *)(v138 + 4 * n) = 0;
      v23 = v22 + 1;
      v24 = (_BYTE *)malloc(8 * (v22 + 1) + 4);
      v25 = v24;
      if ( !v24 )
        dl_signal_error("cannot allocate dependency list");
      v26 = 4 * v23;
      *(_DWORD *)v24 = v11;
      memcpy(v24 + 4, (_BYTE *)v138, v26);
      memcpy(&v25[4 * n + 8], v25, v26);
      *(_BYTE *)(v11 + 406) |= 1u;
      *(_DWORD *)(v11 + 496) = v25;
    }
  }
  while ( !*v132 );
  v27 = v132;
  while ( 1 )
  {
    v27 = (_DWORD *)v27[2];
    if ( !v27 )
      break;
    if ( !*v27 )
    {
      v132 = v27;
      goto LABEL_6;
    }
  }
  v133 = 0;
  v39 = __readgsdword(0xFFFFFFE8) == 0;
LABEL_52:
  if ( v39 && v125 )
    __writegsdword(0xFFFFFFE8, v125);
  v132 = *(_DWORD **)(v130 + 496);
  if ( v132 )
  {
    if ( (*(_BYTE *)(v130 + 404) & 3) == 2 )
    {
      if ( *(_DWORD *)(v130 + 348) )
        _assert_fail("map->l_searchlist.r_list == ((void *)0)", "dl-deps.c", 511, "_dl_map_object_deps");
    }
    else
    {
      v132 = 0;
    }
  }
  v136 = malloc(8 * v134 + 4);
  if ( !v136 )
    dl_signal_error("cannot allocate symbol search list");
  v40 = 0;
  v41 = v130;
  n = 0;
  v42 = (_BYTE *)(v136 + 4 * v134 + 4);
  *(_DWORD *)(v130 + 352) = v134;
  v43 = v130;
  *(_DWORD *)(v41 + 348) = v42;
  v44 = (int)v124;
  do
  {
    v45 = *(_DWORD *)(v44 + 4);
    if ( a4 && (*(_BYTE *)(v45 + 405) & 2) != 0 )
    {
      --*(_DWORD *)(v43 + 352);
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)(v43 + 348) + 4 * v40) = v45;
      v45 = *(_DWORD *)(v44 + 4);
      ++v40;
    }
    *(_BYTE *)(v45 + 404) &= 0x9Fu;
    v44 = *(_DWORD *)(v44 + 8);
  }
  while ( v44 );
  n = v40;
  if ( (dl_debug_mask & 0x800) != 0 )
  {
    v109 = dl_ns[0];
    if ( dl_ns[0] == v130 )
    {
      if ( v40 )
      {
        v110 = (_DWORD *)v136;
        v138 = 0;
        do
        {
          v111 = *(_DWORD *)(*(_DWORD *)(v109 + 348) + 4 * v138);
          if ( v109 != v111 )
          {
            v112 = *(_DWORD *)(v111 + 464);
            if ( !v112 || !*(_DWORD *)(v112 + 4) )
            {
              if ( *(_DWORD *)(v111 + 240) || *(_DWORD *)(v111 + 232) )
                dl_signal_error("Filters not supported with LD_TRACE_PRELINKING");
              v113 = dl_build_local_scope(v110, v111);
              v114 = v113;
              if ( n < v113 )
                _assert_fail("cnt <= nlist", "dl-deps.c", 567, "_dl_map_object_deps");
              if ( v113 )
              {
                *(_BYTE *)(*v110 + 404) &= 0x9Fu;
                v115 = 0;
                while ( v114 != ++v115 )
                {
                  *(_BYTE *)(v110[v115] + 404) &= 0x9Fu;
                  if ( v115 && *(_DWORD *)(v110[v115] + 96) )
                    *(_BYTE *)(v111 + 405) |= 0x80u;
                }
              }
              v123 = v114;
              v116 = malloc(4 * v114 + 8);
              v117 = v123;
              *(_DWORD *)(v111 + 464) = v116;
              if ( !v116 )
                dl_signal_error("cannot allocate symbol search list");
              *(_DWORD *)(v116 + 4) = v117;
              *(_DWORD *)v116 = v116 + 8;
              memcpy((_BYTE *)(v116 + 8), v110, 4 * v117);
            }
          }
          ++v138;
        }
        while ( n != v138 );
      }
    }
  }
  v46 = *(_BYTE **)(v130 + 348);
  v135 = *(_DWORD *)v46;
  if ( v135 != v130 )
    _assert_fail("map->l_searchlist.r_list[0] == map", "dl-deps.c", 592, "_dl_map_object_deps");
  v47 = *(_DWORD **)(v130 + 500);
  if ( v47 )
  {
    if ( n > 1 )
    {
      for ( i = 1; i != n; ++i )
      {
        v49 = *(_DWORD *)&v46[4 * i];
        *(_BYTE *)(v49 + 404) = *(_BYTE *)(v49 + 404) & 0x9F | 0x20;
      }
    }
    v134 = (size_t)(v47 + 1);
    if ( *v47 )
    {
      v50 = 0;
      do
      {
        while ( 1 )
        {
          if ( (*(_BYTE *)(v47[v50 + 1] + 404) & 0x60) != 0 )
          {
            v52 = malloc(4 * *(_DWORD *)(v135 + 504) + 4);
            v53 = (unsigned int *)v52;
            if ( v52 )
              break;
          }
          v51 = v130;
          if ( **(_DWORD **)(v130 + 500) <= ++v50 )
            goto LABEL_81;
        }
        memcpy((_BYTE *)(v52 + 4), (_BYTE *)v134, 4 * v50);
        v137 = (_DWORD *)(v50 + 1);
        v54 = v50;
        v138 = **(_DWORD **)(v135 + 500);
        if ( v138 <= v50 + 1 )
        {
          v58 = (int)v137;
          *v53 = v54;
        }
        else
        {
          v55 = (unsigned int)v137;
          do
          {
            v56 = v47[v55 + 1];
            if ( (*(_BYTE *)(v56 + 404) & 0x60) == 0 )
              v53[++v54] = v56;
            ++v55;
          }
          while ( v138 > v55 );
          v57 = v138;
          *v53 = v54;
          v58 = (int)v137 + v57 - 1 - v50;
        }
        v51 = v130;
        v50 = v58 + 1;
      }
      while ( **(_DWORD **)(v130 + 500) > v50 );
LABEL_81:
      v46 = *(_BYTE **)(v51 + 348);
    }
    if ( n > 1 )
    {
      for ( j = 1; j != n; ++j )
      {
        v60 = *(_DWORD *)&v46[4 * j];
        *(_BYTE *)(v60 + 404) &= 0x9Fu;
      }
      v135 = 4 * n;
      memcpy((_BYTE *)v136, v46, 4 * n);
      goto LABEL_86;
    }
    v135 = 4 * n;
    memcpy((_BYTE *)v136, v46, 4 * n);
  }
  else
  {
    v135 = 4 * n;
    memcpy((_BYTE *)v136, v46, 4 * n);
    if ( n > 1 )
    {
LABEL_86:
      v128 = &v121;
      v61 = alloca(n + 15);
      v137 = v122;
      memset(v122, 0, n);
      v62 = 1;
      v138 = 2;
      v134 = n - 1;
      v129 = 4 * n - 4;
      while ( 1 )
      {
LABEL_87:
        v63 = (_BYTE *)v136;
        ++*((_BYTE *)v137 + v62);
        dest = &v63[4 * v62];
        v64 = *(_DWORD *)dest;
        if ( v62 < v134 )
        {
          v65 = v134;
          v66 = (_BYTE *)(v129 + v136);
          do
          {
            v67 = *(int **)(*(_DWORD *)v66 + 496);
            if ( v67 )
            {
              while ( 1 )
              {
                v68 = *v67;
                if ( !*v67 )
                  break;
                ++v67;
                if ( v64 == v68 )
                {
                  v127 = v65 - v62;
                  v123 = v62;
                  memmove(dest, (const void *)(v136 + 4 * v138), 4 * (v65 - v62));
                  v70 = v138;
                  *(_DWORD *)v66 = v64;
                  if ( *((char *)v137 + v70) > 1 )
                  {
                    v69 = v138;
                    goto LABEL_95;
                  }
                  v74 = *((_BYTE *)v137 + v123);
                  memmove((char *)v137 + v123, (char *)v137 + v138, v127);
                  *((_BYTE *)v137 + v65) = v74;
                  v62 = v123;
                  goto LABEL_87;
                }
              }
            }
            --v65;
            v66 -= 4;
          }
          while ( v62 < v65 );
        }
        v69 = v138;
        if ( n == v138 )
          break;
LABEL_95:
        v123 = v69;
        memset((char *)v137 + v138, 0, n - v138);
        v62 = v123;
        ++v138;
      }
    }
  }
  result = (_BYTE *)v136;
  *(_DWORD *)(v136 + v135) = 0;
  v72 = v130;
  *(_BYTE *)(v130 + 406) |= 1u;
  v73 = v132;
  *(_DWORD *)(v72 + 496) = result;
  if ( v73 )
    result = (_BYTE *)dl_scope_free((int)v132);
  if ( v133 )
  {
    v107 = 0;
    if ( v133 != -1 )
      v107 = v133;
    v133 = v107;
    dl_signal_error(v143);
  }
  return result;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 80EEFC8: using guessed type int _libc_enable_secure;
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80F118C: using guessed type int dl_platformlen;
// 80F1190: using guessed type int dl_debug_mask;
// 80F1200: using guessed type int dl_ns[];
// 80BDC10: using guessed type _BYTE *var_20;

//----- (080BEBB0) --------------------------------------------------------
int __usercall call_init@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  char v5; // dl
  const char *v6; // ecx
  char v7; // dl
  int v8; // edx
  int v9; // edx
  int v10; // ebp
  int v11; // edi
  int i; // esi
  int v13; // [esp+18h] [ebp-24h]
  int v14; // [esp+18h] [ebp-24h]

  v5 = *(_BYTE *)(result + 404);
  if ( (v5 & 8) == 0 )
  {
    v6 = *(const char **)(result + 4);
    v7 = v5 | 8;
    *(_BYTE *)(result + 404) = v7;
    if ( *v6 || (v7 & 3) != 0 )
    {
      v8 = *(_DWORD *)(result + 80);
      if ( v8 || *(_DWORD *)(result + 132) )
      {
        if ( (dl_debug_mask & 2) != 0 )
        {
          if ( !*v6 )
            v6 = (const char *)program_invocation_short_name;
          v14 = result;
          dl_debug_printf((int)"\ncalling init: %s\n\n", v6);
          result = v14;
          v8 = *(_DWORD *)(v14 + 80);
        }
        if ( v8 )
        {
          v13 = result;
          ((void (__cdecl *)(int, int, int))(*(_DWORD *)result + *(_DWORD *)(v8 + 4)))(a2, a3, a4);
          result = v13;
        }
        v9 = *(_DWORD *)(result + 132);
        if ( v9 )
        {
          v10 = *(_DWORD *)(v9 + 4) + *(_DWORD *)result;
          v11 = *(_DWORD *)(*(_DWORD *)(result + 140) + 4) >> 2;
          if ( v11 )
          {
            for ( i = 0; i != v11; ++i )
              result = (*(int (__cdecl **)(int, int, int))(v10 + 4 * i))(a2, a3, a4);
          }
        }
      }
    }
  }
  return result;
}
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80F1190: using guessed type int dl_debug_mask;

//----- (080BECE0) --------------------------------------------------------
int __userpurge dl_init@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  _DWORD *v4; // esi
  int v5; // edi
  int v6; // ebx
  int result; // eax
  int v8; // ebp
  int v9; // edi
  int v10; // ebx
  int v11; // eax
  int v12; // ebx
  int v13; // eax
  int v14; // edi
  int v15; // esi
  const char *v16; // eax
  _DWORD *v19; // [esp+1Ch] [ebp-20h]

  v4 = a1;
  v5 = a1[40];
  v6 = a1[41];
  result = dl_initfirst;
  v8 = a4;
  if ( dl_initfirst )
  {
    result = call_init(dl_initfirst, a2, a3, a4);
    dl_initfirst = 0;
  }
  if ( v6 )
  {
    if ( v5 )
    {
      v12 = *(_DWORD *)(v6 + 4) >> 2;
      if ( v12 )
      {
        if ( (dl_debug_mask & 2) != 0 )
        {
          v16 = (const char *)v4[1];
          if ( !*v16 )
            v16 = (const char *)program_invocation_short_name;
          dl_debug_printf((int)"\ncalling preinit: %s\n\n", v16);
        }
        v13 = *(_DWORD *)(v5 + 4) + *v4;
        v14 = 0;
        v19 = v4;
        v15 = v13;
        do
          result = (*(int (__cdecl **)(int, int, int))(v15 + 4 * v14++))(a2, a3, a4);
        while ( v14 != v12 );
        v4 = v19;
        v8 = a4;
      }
    }
  }
  v9 = v4[88];
  if ( v9 )
  {
    v10 = 4 * v9 - 4;
    do
    {
      v11 = *(_DWORD *)(v4[124] + v10);
      v10 -= 4;
      result = call_init(v11, a2, a3, v8);
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80F1190: using guessed type int dl_debug_mask;
// 80F11E8: using guessed type int dl_initfirst;

//----- (080BEDF0) --------------------------------------------------------
int *__userpurge dl_sort_fini@<eax>(int *result@<eax>, size_t a2@<edx>, int a3@<ecx>, int a4)
{
  void *v4; // esp
  size_t v5; // ecx
  char v6; // al
  int v7; // edx
  int v8; // ecx
  size_t v9; // ebx
  int *v10; // esi
  int v11; // edi
  int *v12; // eax
  int v13; // edx
  size_t v14; // edi
  bool v15; // zf
  char v16; // si
  int v17; // edx
  int v18; // edx
  int v19; // [esp+0h] [ebp-58h] BYREF
  int v20; // [esp+10h] [ebp-48h] BYREF
  size_t v21; // [esp+14h] [ebp-44h]
  int *v22; // [esp+18h] [ebp-40h]
  int v23; // [esp+1Ch] [ebp-3Ch]
  int *v24; // [esp+20h] [ebp-38h]
  void *dest; // [esp+24h] [ebp-34h]
  char v26; // [esp+2Bh] [ebp-2Dh]
  size_t n; // [esp+2Ch] [ebp-2Ch]
  int v28; // [esp+30h] [ebp-28h]
  int *v29; // [esp+34h] [ebp-24h]
  size_t v30; // [esp+38h] [ebp-20h]
  size_t v31; // [esp+3Ch] [ebp-1Ch]

  v24 = result;
  n = a2;
  v23 = a3;
  v22 = &v19;
  if ( a2 != 1 )
  {
    v31 = a4 == 0;
    v4 = alloca(n + 15);
    v29 = &v20;
    memset(&v20, 0, n);
    v30 = v31 + 1;
    v21 = 4 * n - 4;
    while ( 1 )
    {
LABEL_5:
      v5 = v31;
      v6 = *((_BYTE *)v29 + v31) + 1;
      *((_BYTE *)v29 + v31) = v6;
      v26 = v6;
      result = &v24[v5];
      v7 = *result;
      dest = result;
      v8 = *(_DWORD *)(v7 + 20);
      v28 = v7;
      if ( v8 != v7 || *(_DWORD *)(v8 + 524) == -1 || (v9 = n - 1, v31 >= n - 1) )
      {
        v31 = v30;
        if ( v30 == n )
          return result;
      }
      else
      {
        v10 = (int *)((char *)v24 + v21);
        do
        {
          v11 = *v10;
          v12 = *(int **)(*v10 + 496);
          if ( v12 )
          {
            while ( 1 )
            {
              v13 = *v12;
              if ( !*v12 )
                break;
              ++v12;
              if ( v8 == v13 )
              {
LABEL_17:
                v14 = v9 - v31;
                memmove(dest, &v24[v30], 4 * (v9 - v31));
                v15 = v23 == 0;
                *v10 = v28;
                if ( !v15 )
                {
                  v16 = *(_BYTE *)(v31 + v23);
                  memmove((void *)(v31 + v23), (const void *)(v30 + v23), v14);
                  *(_BYTE *)(v23 + v9) = v16;
                }
                if ( *((char *)v29 + v30) > 1 )
                {
                  v31 = v30;
                  goto LABEL_4;
                }
                memmove((char *)v29 + v31, (char *)v29 + v30, v14);
                *((_BYTE *)v29 + v9) = v26;
                goto LABEL_5;
              }
            }
          }
          result = *(int **)(v11 + 500);
          if ( result )
          {
            v17 = *result;
            while ( v17 )
            {
              if ( v8 == result[v17--] )
              {
                result = *(int **)(v8 + 496);
                if ( result )
                {
                  while ( 1 )
                  {
                    v18 = *result;
                    if ( !*result )
                      break;
                    ++result;
                    if ( v11 == v18 )
                      goto LABEL_14;
                  }
                }
                goto LABEL_17;
              }
            }
          }
LABEL_14:
          --v9;
          --v10;
        }
        while ( v31 < v9 );
        v31 = v30;
        if ( v30 == n )
          return result;
      }
LABEL_4:
      memset((char *)v29 + v30, 0, n - v30);
      ++v30;
    }
  }
  return result;
}

//----- (080BF010) --------------------------------------------------------
int __usercall dl_fini@<eax>(long double a1@<st0>)
{
  int result; // eax
  int *v2; // ebx
  size_t v3; // esi
  size_t v4; // ecx
  int v5; // esi
  void *v6; // esp
  _DWORD *i; // eax
  int v8; // esi
  char v9; // al
  int v10; // eax
  int v11; // ebx
  int j; // edi
  int v13; // eax
  const char *v14; // eax
  unsigned int v15; // esi
  void *v16; // esp
  _BYTE v17[8]; // [esp+10h] [ebp-38h] BYREF
  unsigned int v18; // [esp+18h] [ebp-30h]
  size_t *v19; // [esp+1Ch] [ebp-2Ch]
  int v20; // [esp+20h] [ebp-28h]
  int v21; // [esp+24h] [ebp-24h]
  int *v22; // [esp+28h] [ebp-20h]
  int v23; // [esp+2Ch] [ebp-1Ch]
  int savedregs; // [esp+48h] [ebp+0h] BYREF

  result = dl_nns - 1;
  v20 = dl_nns - 1;
  if ( dl_nns - 1 < 0 )
    return result;
  v2 = 0;
  v18 = 0;
  v19 = (size_t *)(76 * result + 135205380);
  do
  {
    v3 = 0;
    v4 = *v19;
    if ( *v19 )
    {
      v5 = 4 * v4;
      if ( 4 * v4 > v18 )
      {
        if ( v18 )
        {
          v15 = (v5 + 15) & 0xFFFFFFF0;
          v16 = alloca(16 * ((v15 + 30) / 0x10));
          if ( v2 == (int *)&v17[v15] )
            v18 += v15;
          else
            v18 = v15;
          v2 = (int *)v17;
        }
        else
        {
          v18 = 4 * v4;
          v6 = alloca(16 * ((v5 + 30) / 0x10u));
          v2 = (int *)v17;
        }
      }
      v3 = 0;
      for ( i = (_DWORD *)*(v19 - 1); i; i = (_DWORD *)i[3] )
      {
        while ( (_DWORD *)i[5] != i )
        {
          i = (_DWORD *)i[3];
          if ( !i )
            goto LABEL_13;
        }
        if ( v4 <= v3 )
          _assert_fail((int)&savedregs, a1, (int)"i < nloaded", (int)"dl-fini.c", 197, "_dl_fini");
        v2[v3] = (int)i;
        i[131] = v3++;
        ++i[100];
      }
LABEL_13:
      if ( v3 != v4 )
      {
        if ( !v20 )
          _assert_fail((int)&savedregs, a1, (int)"ns != 0 || i == nloaded", (int)"dl-fini.c", 207, "_dl_fini");
        if ( v4 - 1 != v3 )
          _assert_fail(
            (int)&savedregs,
            a1,
            (int)"ns == 0 || i == nloaded || i == nloaded - 1",
            (int)"dl-fini.c",
            208,
            "_dl_fini");
      }
      dl_sort_fini(v2, v3, 0, v20);
    }
    result = 0;
    if ( !v3 )
      goto LABEL_27;
    v23 = 0;
    v22 = v2;
    v21 = v3;
    do
    {
      v8 = v22[v23];
      v9 = *(_BYTE *)(v8 + 404);
      if ( (v9 & 8) == 0 )
        goto LABEL_25;
      *(_BYTE *)(v8 + 404) = v9 & 0xF7;
      v10 = *(_DWORD *)(v8 + 136);
      if ( v10 )
      {
        if ( (dl_debug_mask & 2) != 0 )
          goto LABEL_31;
      }
      else
      {
        if ( !*(_DWORD *)(v8 + 84) )
          goto LABEL_25;
        if ( (dl_debug_mask & 2) != 0 )
        {
LABEL_31:
          v14 = *(const char **)(v8 + 4);
          if ( !*v14 )
            v14 = (const char *)program_invocation_short_name;
          dl_debug_printf((int)"\ncalling fini: %s [%lu]\n\n", v14, v20);
          v10 = *(_DWORD *)(v8 + 136);
        }
      }
      if ( v10 )
      {
        v11 = *(_DWORD *)v8 + *(_DWORD *)(v10 + 4);
        for ( j = *(_DWORD *)(*(_DWORD *)(v8 + 144) + 4) >> 2; j; --j )
          (*(void (**)(void))(v11 + 4 * j - 4))();
      }
      v13 = *(_DWORD *)(v8 + 84);
      if ( v13 )
        ((void (*)(void))(*(_DWORD *)v8 + *(_DWORD *)(v13 + 4)))();
LABEL_25:
      ++v23;
      result = v21;
      --*(_DWORD *)(v8 + 400);
    }
    while ( v23 != result );
    v2 = v22;
LABEL_27:
    v19 -= 19;
    --v20;
  }
  while ( v20 >= 0 );
  return result;
}
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80F1190: using guessed type int dl_debug_mask;
// 80F11C0: using guessed type int dl_nns;

//----- (080BF2D0) --------------------------------------------------------
int __userpurge match_symbol@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char *s1, _DWORD *a5, int a6, int a7)
{
  int v8; // ecx
  int v9; // eax
  int v10; // esi
  unsigned __int16 *v11; // esi
  int v12; // ebx
  int v13; // eax
  char *v14; // eax
  void *v15; // esp
  int v16; // esi
  char *v17; // eax
  int v19; // esi
  int v20; // edi
  _BYTE *v21; // eax
  const char *v22; // edx
  int v23; // esi
  void *v24; // esp
  _DWORD *v25; // eax
  const char *v26; // eax
  int v27; // esi
  int v28; // edx
  const char *v29; // edi
  int v30; // edi
  void *v31; // esp
  _DWORD *v32; // eax
  const char *v33; // edx
  int v34; // esi
  int v35; // edx
  const char *v36; // edi
  int v37; // edi
  void *v38; // esp
  _DWORD *v39; // eax
  int v40; // edx
  _DWORD v41[6]; // [esp+20h] [ebp-48h] BYREF
  const char *v42; // [esp+38h] [ebp-30h]
  int v43; // [esp+3Ch] [ebp-2Ch]
  int v44; // [esp+40h] [ebp-28h] BYREF
  const char *v45; // [esp+44h] [ebp-24h]
  char *v46; // [esp+48h] [ebp-20h]
  char *src; // [esp+4Ch] [ebp-1Ch]

  v41[2] = a1;
  v8 = *(_DWORD *)(a5[13] + 4);
  if ( (dl_debug_mask & 0x10) != 0 )
  {
    v26 = (const char *)a5[1];
    v27 = a5[6];
    if ( !*v26 )
      v26 = (const char *)program_invocation_short_name;
    v41[1] = *(_DWORD *)(a5[13] + 4);
    dl_debug_printf(
      (int)"checking for version `%s' in file %s [%lu] required by file %s [%lu]\n",
      s1,
      v26,
      v27,
      (const char *)v41[2],
      a2);
    v8 = v41[1];
  }
  v9 = a5[45];
  if ( v9 )
  {
    v10 = *(_DWORD *)(v9 + 4);
    if ( !v10 )
      _assert_fail("def_offset != 0", "dl-version.c", 113, "match_symbol");
    v11 = (unsigned __int16 *)(*a5 + v10);
    if ( *v11 == 1 )
    {
      v41[3] = a5;
      v12 = v8;
      while ( 1 )
      {
        if ( *((_DWORD *)v11 + 2) == a3
          && !strcmp(s1, (const char *)(v12 + *(_DWORD *)((char *)v11 + *((_DWORD *)v11 + 3)))) )
        {
          return 0;
        }
        v13 = *((_DWORD *)v11 + 4);
        if ( !v13 )
          break;
        v11 = (unsigned __int16 *)((char *)v11 + v13);
        if ( *v11 != 1 )
          goto LABEL_9;
      }
      if ( a7 )
      {
        v16 = 0;
        if ( !a6 )
          return v16;
        v19 = 1;
        v41[4] = "weak version `";
        v42 = "' not found (required by ";
        v43 = v41[2];
        v20 = 15;
        v41[5] = s1;
        v44 = 135129283;
        do
        {
          v21 = (_BYTE *)v41[v19++ + 4];
          v20 += strlen(v21);
        }
        while ( v19 != 5 );
        v22 = "weak version `";
        v23 = 0;
        v24 = alloca(v20 + 15);
        v25 = v41;
        while ( 1 )
        {
          ++v23;
          v25 = (_DWORD *)stpcpy(v25, v22);
          if ( v23 == 5 )
            break;
          v22 = (const char *)v41[v23 + 4];
        }
        v16 = 0;
      }
      else
      {
        v34 = 1;
        v41[4] = 135131081;
        v42 = "' not found (required by ";
        v41[5] = s1;
        v35 = 0;
        v43 = v41[2];
        v44 = 135129283;
        do
        {
          v36 = (const char *)v41[v35++ + 4];
          v34 += strlen(v36);
        }
        while ( v35 != 5 );
        v37 = 0;
        v38 = alloca(v34 + 15);
        v39 = v41;
        do
        {
          v40 = v41[v37++ + 4];
          v39 = (_DWORD *)stpcpy(v39, v40);
        }
        while ( v37 != 5 );
        v16 = 1;
      }
    }
    else
    {
LABEL_9:
      HIBYTE(v44) = 0;
      v14 = itoa(*v11, (char *)&v44 + 3, 0xAu, 0);
      src = " of Verdef record";
      v46 = v14;
      v15 = alloca(strlen(v14) + 53);
      strcpy((char *)v41, "unsupported version ");
      v16 = 1;
      v17 = (char *)stpcpy(&v41[5], v46);
      strcpy(v17, src);
    }
  }
  else
  {
    v16 = 0;
    if ( !a6 )
      return v16;
    v28 = 0;
    LOWORD(v16) = 1;
    v45 = "no version information available (required by ";
    src = "invalid mode for dlopen()" + 24;
    v46 = (char *)v41[2];
    do
    {
      v29 = (&v45)[v28++];
      v16 += strlen(v29);
    }
    while ( v28 != 3 );
    v30 = 0;
    v31 = alloca(v16 + 15);
    v32 = v41;
    do
    {
      v33 = (&v45)[v30++];
      v32 = (_DWORD *)stpcpy(v32, v33);
    }
    while ( v30 != 3 );
    v16 = 0;
  }
  dl_signal_cerror(v41);
  return v16;
}
// 80481F0: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808E440: using guessed type _DWORD __stdcall dl_signal_cerror(_DWORD);
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80F1190: using guessed type int dl_debug_mask;

//----- (080BF630) --------------------------------------------------------
int __usercall dl_check_map_versions@<eax>(int a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>)
{
  char *v3; // edi
  int v4; // eax
  _DWORD *v5; // esi
  _DWORD *v6; // esi
  bool v7; // zf
  int v8; // esi
  char *i; // ebx
  int v10; // ecx
  int v11; // edx
  _BYTE *v12; // eax
  int v13; // esi
  unsigned int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // ebx
  int v18; // edx
  unsigned int v19; // eax
  int v20; // eax
  unsigned int v21; // ecx
  unsigned int v23; // esi
  unsigned int v24; // eax
  int v25; // eax
  _DWORD *v26; // ebx
  int v27; // ebx
  _DWORD *j; // esi
  char *k; // eax
  unsigned int v30; // edx
  int v31; // edi
  _DWORD *v32; // edx
  int v33; // ecx
  int v34; // edx
  int v35; // eax
  int v36; // eax
  int v37; // esi
  unsigned int v38; // edi
  int v39; // ecx
  int *v40; // edx
  int v41; // edx
  const char *v42; // ebx
  char *v43; // eax
  void *v44; // esp
  char *v45; // eax
  _DWORD *v46[6]; // [esp+20h] [ebp-68h] BYREF
  int v47; // [esp+38h] [ebp-50h]
  int v48; // [esp+3Ch] [ebp-4Ch]
  char *s1; // [esp+40h] [ebp-48h]
  int v50; // [esp+44h] [ebp-44h]
  char *v51; // [esp+48h] [ebp-40h]
  unsigned int v52; // [esp+4Ch] [ebp-3Ch]
  char v53[5]; // [esp+63h] [ebp-25h] BYREF
  char *v54; // [esp+68h] [ebp-20h]
  char *src; // [esp+6Ch] [ebp-1Ch]

  v3 = (char *)a1;
  v4 = *(_DWORD *)(a1 + 52);
  v46[5] = a2;
  v46[3] = a3;
  if ( !v4 )
  {
    v50 = 0;
    return 0;
  }
  v5 = (_DWORD *)*((_DWORD *)v3 + 43);
  v48 = *(_DWORD *)(v4 + 4);
  v46[2] = v5;
  v46[1] = *((_DWORD **)v3 + 45);
  if ( v5 )
  {
    v6 = (_DWORD *)(*(_DWORD *)v3 + v46[2][1]);
    v7 = *(_WORD *)v6 == 1;
    v46[4] = v6;
    if ( !v7 )
    {
      v53[0] = 0;
      v43 = itoa(*(unsigned __int16 *)v6, v53, 0xAu, 0);
      src = " of Verneed record\n";
      v54 = v43;
      v44 = alloca(strlen(v43) + 55);
      v42 = (const char *)v46;
      strcpy((char *)v46, "unsupported version ");
      v45 = (char *)stpcpy(&v46[5], v54);
      strcpy(v45, src);
LABEL_58:
      dl_signal_error(v42);
    }
    v52 = 0;
    v50 = 0;
    while ( 1 )
    {
      v51 = (char *)(v46[4][1] + v48);
      v8 = dl_ns[19 * *((_DWORD *)v3 + 6)];
      if ( v8 )
      {
        while ( !dl_name_match_p(v51, v8) )
        {
          v8 = *(_DWORD *)(v8 + 12);
          if ( !v8 )
            goto LABEL_21;
        }
      }
      else
      {
LABEL_21:
        if ( !*((_DWORD *)v3 + 88) )
LABEL_59:
          _assert_fail("needed != ((void *)0)", "dl-version.c", 230, "_dl_check_map_versions");
        v17 = 0;
        while ( !dl_name_match_p(v51, *(_DWORD *)(*((_DWORD *)v3 + 87) + 4 * v17)) )
        {
          if ( (unsigned int)++v17 >= *((_DWORD *)v3 + 88) )
            goto LABEL_59;
        }
        v8 = *(_DWORD *)(*((_DWORD *)v3 + 87) + 4 * v17);
      }
      if ( !v8 )
        goto LABEL_59;
      if ( !v46[3] || (*(_BYTE *)(v8 + 405) & 2) == 0 )
      {
        v47 = v8;
        v51 = v3;
        for ( i = (char *)v46[4] + v46[4][2]; ; i += v15 )
        {
          v10 = *(_DWORD *)i;
          v11 = *((_DWORD *)v51 + 6);
          v12 = (_BYTE *)*((_DWORD *)v51 + 1);
          v13 = *((_WORD *)i + 2) & 2;
          v46[0] = *(_DWORD **)(v47 + 20);
          v7 = *v12 == 0;
          s1 = (char *)(*((_DWORD *)i + 2) + v48);
          if ( v7 )
            v12 = program_invocation_short_name;
          v50 |= match_symbol((int)v12, v11, v10, s1, v46[0], (int)v46[5], v13);
          v14 = *((_WORD *)i + 3) & 0x7FFF;
          if ( v52 >= v14 )
            v14 = v52;
          v52 = v14;
          v15 = *((_DWORD *)i + 3);
          if ( !v15 )
            break;
        }
        v3 = v51;
      }
      v16 = v46[4][3];
      if ( !v16 )
        break;
      v46[4] = (_DWORD *)((char *)v46[4] + v16);
    }
  }
  else
  {
    v52 = 0;
    v50 = 0;
  }
  if ( v46[1] )
  {
    v18 = *(_DWORD *)v3 + v46[1][1];
    v19 = *(_WORD *)(v18 + 4) & 0x7FFF;
    if ( v52 >= v19 )
      v19 = v52;
    v52 = v19;
    v20 = *(_DWORD *)(v18 + 16);
    if ( v20 )
    {
      v21 = v52;
      do
      {
        v18 += v20;
        if ( v21 < (*(_WORD *)(v18 + 4) & 0x7FFFu) )
          v21 = *(_WORD *)(v18 + 4) & 0x7FFF;
        v20 = *(_DWORD *)(v18 + 16);
      }
      while ( v20 );
      v52 = v21;
    }
  }
  if ( !v52 )
    return v50;
  v23 = v52 + 1;
  v51 = (char *)(v52 + 1);
  calloc(v52 + 1, 0x10u);
  v52 = v24;
  *((_DWORD *)v3 + 92) = v24;
  if ( !v24 )
  {
    v42 = "cannot allocate version reference table";
    goto LABEL_58;
  }
  v25 = *((_DWORD *)v3 + 57);
  v26 = v46[2];
  *((_DWORD *)v3 + 93) = v23;
  *((_DWORD *)v3 + 105) = *(_DWORD *)(v25 + 4);
  if ( v26 )
  {
    v27 = v48;
    s1 = v3;
    for ( j = (_DWORD *)(*(_DWORD *)v3 + v46[2][1]); ; j = (_DWORD *)((char *)j + v35) )
    {
      for ( k = (char *)j + j[2]; ; k += v34 )
      {
        v30 = *((_WORD *)k + 3) & 0x7FFF;
        if ( (unsigned int)v51 > v30 )
        {
          v31 = *(_DWORD *)k;
          v32 = (_DWORD *)(v52 + 16 * v30);
          v32[2] = *((_WORD *)k + 3) & 0x8000;
          v33 = *((_DWORD *)k + 2);
          v32[1] = v31;
          *v32 = v27 + v33;
          v32[3] = v27 + j[1];
        }
        v34 = *((_DWORD *)k + 3);
        if ( !v34 )
          break;
      }
      v35 = j[3];
      if ( !v35 )
        break;
    }
    v3 = s1;
  }
  if ( !v46[1] )
    return v50;
  v36 = *(_DWORD *)v3 + v46[1][1];
  v37 = v48;
  v38 = v52;
  while ( 1 )
  {
    if ( (*(_BYTE *)(v36 + 2) & 1) == 0 )
    {
      v39 = v37 + *(_DWORD *)(v36 + *(_DWORD *)(v36 + 12));
      v40 = (int *)(v38 + 16 * (*(_WORD *)(v36 + 4) & 0x7FFF));
      v40[1] = *(_DWORD *)(v36 + 8);
      *v40 = v39;
      v40[3] = 0;
    }
    v41 = *(_DWORD *)(v36 + 16);
    if ( !v41 )
      break;
    v36 += v41;
  }
  return v50;
}
// 80BF85F: variable 'v24' is possibly undefined
// 80481F0: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 8056910: using guessed type void __cdecl __noreturn _assert_fail(_DWORD, _DWORD, _DWORD, _DWORD);
// 808E2C0: using guessed type void __cdecl __noreturn dl_signal_error(_DWORD);
// 80EF56C: using guessed type void *program_invocation_short_name;
// 80F1200: using guessed type int dl_ns[];
// 80BF630: using guessed type char var_25[5];

//----- (080BFA60) --------------------------------------------------------
int __usercall dl_check_all_versions@<eax>(int a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>)
{
  int v5; // esi
  int v6; // ebx
  int v7; // eax

  v5 = 0;
  if ( a1 )
  {
    v6 = a1;
    do
    {
      while ( (*(_BYTE *)(v6 + 405) & 2) != 0 )
      {
        v6 = *(_DWORD *)(v6 + 12);
        if ( !v6 )
          return v5;
      }
      v7 = dl_check_map_versions(v6, a2, a3);
      v6 = *(_DWORD *)(v6 + 12);
      v5 |= v7 != 0;
    }
    while ( v6 );
  }
  return v5;
}

//----- (080BFAC0) --------------------------------------------------------
int __usercall call_dl_lookup@<eax>(long double a1@<st0>, int a2)
{
  int result; // eax

  result = dl_lookup_symbol_x(
             *(char **)(a2 + 4),
             *(_DWORD *)a2,
             *(int **)(a2 + 20),
             a1,
             *(int ***)(*(_DWORD *)a2 + 460),
             *(_DWORD *)(a2 + 8),
             0,
             *(_DWORD *)(a2 + 12),
             0);
  *(_DWORD *)a2 = result;
  return result;
}

//----- (080BFB20) --------------------------------------------------------
int (*__userpurge do_sym@<eax>(
        __int32 a1@<eax>,
        char *a2@<edx>,
        unsigned int a3@<ecx>,
        int a4@<ebx>,
        int i@<edi>,
        long double a6@<st0>,
        int a7,
        int a8))(void)
{
  int *v9; // eax
  int v10; // ecx
  int (*result)(void); // eax
  int j; // edx
  int v13; // esi
  int v15; // eax
  void *v16; // esp
  char *v17; // edi
  int v18; // eax
  void *v19; // esp
  _BYTE *v20; // ebx
  char v21[4]; // [esp+20h] [ebp-58h] BYREF
  char *v22; // [esp+24h] [ebp-54h]
  int v23; // [esp+28h] [ebp-50h]
  __int32 v24; // [esp+2Ch] [ebp-4Ch]
  int v25[6]; // [esp+38h] [ebp-40h] BYREF
  int v26; // [esp+50h] [ebp-28h] BYREF
  _BYTE *v27; // [esp+54h] [ebp-24h] BYREF
  _BYTE *v28; // [esp+58h] [ebp-20h] BYREF
  char v29[25]; // [esp+5Fh] [ebp-19h] BYREF
  int savedregs; // [esp+78h] [ebp+0h] BYREF

  v22 = a2;
  v24 = a1;
  v26 = 0;
  v23 = dl_ns[0];
  if ( dl_nns )
  {
    a4 = dl_ns[0];
    for ( i = 0; ; a4 = dl_ns[19 * i] )
    {
      if ( a4 )
      {
        while ( a3 < *(_DWORD *)(a4 + 428)
             || a3 >= *(_DWORD *)(a4 + 432)
             || (*(_BYTE *)(a4 + 405) & 0x40) == 0 && !dl_addr_inside_object(a4, a3) )
        {
          a4 = *(_DWORD *)(a4 + 12);
          if ( !a4 )
            goto LABEL_9;
        }
        v23 = a4;
      }
LABEL_9:
      if ( ++i >= (unsigned int)dl_nns )
        break;
    }
  }
  if ( v24 )
  {
    if ( v24 == -1 )
    {
      if ( v23 == dl_ns[0] && (!v23 || a3 < *(_DWORD *)(v23 + 428) || a3 >= *(_DWORD *)(v23 + 432)) )
        dl_signal_error(0, 0, 0, a6, "RTLD_NEXT used in code not dynamically loaded");
      for ( j = v23; *(_DWORD *)(j + 364); j = *(_DWORD *)(j + 364) )
        ;
      v9 = (int *)dl_lookup_symbol_x(v22, v23, &v26, a6, (int **)(j + 464), a7, 0, 0, v23);
    }
    else
    {
      v9 = (int *)dl_lookup_symbol_x(v22, v24, &v26, a6, (int **)(v24 + 464), a7, 0, a8, 0);
    }
  }
  else if ( __readgsdword(0xCu) )
  {
    v25[2] = a7;
    v25[1] = (int)v22;
    v25[3] = a8 | 5;
    v25[0] = v23;
    v25[5] = (int)&v26;
    __writegsdword(0x1Cu, 1u);
    v28 = 0;
    v13 = dl_catch_error(&v27, &v28, v29, a4, (int)&savedregs, i, a3, (void (__cdecl *)(int))call_dl_lookup, (int)v25);
    if ( _InterlockedExchange(MK_FP(__GS__, 28), v24) == 2 )
      dl_sysinfo(129);
    if ( v28 )
    {
      v15 = strlen(v28);
      v16 = alloca(v15 + 16);
      v17 = memcpy(v21, v28, v15 + 1);
      v18 = strlen(v27);
      v19 = alloca(v18 + 16);
      v20 = memcpy(v21, v27, v18 + 1);
      if ( v29[0] )
        free(a6, (int)v28);
      dl_signal_error(v13, v20, 0, a6, v17);
    }
    v9 = (int *)v25[0];
  }
  else
  {
    v9 = (int *)dl_lookup_symbol_x(v22, v23, &v26, a6, *(int ***)(v23 + 460), a7, 0, a8 | 1, 0);
  }
  if ( !v26 )
    return 0;
  v10 = 0;
  if ( v9 )
    v10 = *v9;
  result = (int (*)(void))(v10 + *(_DWORD *)(v26 + 4));
  if ( (*(_BYTE *)(v26 + 12) & 0xF) == 10 )
    return (int (*)(void))result();
  return result;
}
// 80EF5A4: using guessed type __int64 (__fastcall *dl_sysinfo)(_DWORD);
// 80F11C0: using guessed type int dl_nns;
// 80F1200: using guessed type int dl_ns[];
// 80BFB20: using guessed type char var_19[25];
// 80BFB20: using guessed type _BYTE *var_20;
// 80BFB20: using guessed type char anonymous_0[4];

//----- (080BFE30) --------------------------------------------------------
int (*__userpurge dl_vsym@<eax>(
        __int32 a1@<eax>,
        char *a2@<edx>,
        unsigned __int8 *a3@<ecx>,
        int a4@<edi>,
        long double a5@<st0>,
        unsigned int a6))(void)
{
  int v6; // ebx
  int v8; // ecx
  int v9; // ecx
  _BYTE *v10; // esi
  int i; // ecx
  int v12; // ebx
  int v14[4]; // [esp+10h] [ebp-1Ch] BYREF

  v6 = 0;
  v14[0] = (int)a3;
  v14[2] = 1;
  v8 = *a3;
  if ( v8 )
  {
    v6 = v8;
    if ( a3[1] )
    {
      v6 = a3[1] + 16 * v8;
      if ( a3[2] )
      {
        v6 = a3[2] + 16 * v6;
        if ( a3[3] )
        {
          v6 = a3[3] + 16 * v6;
          v9 = a3[4];
          if ( a3[4] )
          {
            v10 = a3 + 5;
            v6 = v9 + 16 * v6;
            for ( i = (unsigned __int8)*v10; *v10; v6 = a4 ^ v12 & 0xFFFFFFF )
            {
              ++v10;
              v12 = i + 16 * v6;
              a4 = (v12 & 0xF0000000) >> 24;
              i = (unsigned __int8)*v10;
            }
          }
        }
      }
    }
  }
  v14[1] = v6;
  v14[3] = 0;
  return do_sym(a1, a2, a6, v6, a4, a5, (int)v14, 0);
}

//----- (080BFEF0) --------------------------------------------------------
int (*__usercall dl_sym@<eax>(
        __int32 a1@<eax>,
        char *a2@<edx>,
        unsigned int a3@<ecx>,
        int a4@<ebx>,
        int a5@<edi>,
        long double a6@<st0>))(void)
{
  return do_sym(a1, a2, a3, a4, a5, a6, 0, 2);
}

//----- (080C0250) --------------------------------------------------------
char *__usercall read_sleb128@<eax>(char *result@<eax>, _DWORD *a2@<edx>)
{
  unsigned int v2; // ecx
  int v3; // ebp
  char v4; // si
  int v5; // edx

  v2 = 0;
  v3 = 0;
  do
  {
    v4 = *result++;
    v5 = (v4 & 0x7F) << v2;
    v2 += 7;
    v3 |= v5;
  }
  while ( v4 < 0 );
  if ( v2 <= 0x1F && (v4 & 0x40) != 0 )
    v3 |= -1 << v2;
  *a2 = v3;
  return result;
}

//----- (080C02A0) --------------------------------------------------------
char *__usercall read_encoded_value_with_base@<eax>(char a1@<al>, char *a2@<edx>, char *a3, int *a4)
{
  char *v4; // esi
  char v5; // di
  char v6; // bp
  int v7; // edx
  char *result; // eax
  int v9; // ecx
  int v11; // esi
  char *v12; // edi
  char v13; // al
  int v14; // edx
  _DWORD *v15; // eax
  int v18[4]; // [esp+1Ch] [ebp-20h] BYREF

  v4 = a2;
  v5 = a1;
  if ( a1 == 80 )
  {
    v15 = (_DWORD *)((unsigned int)(a3 + 3) & 0xFFFFFFFC);
    v7 = *v15;
    result = (char *)(v15 + 1);
  }
  else
  {
    v6 = a1;
    switch ( a1 & 0xF )
    {
      case 0:
      case 3:
        v7 = *(_DWORD *)a3;
        result = a3 + 4;
        break;
      case 1:
        v9 = 0;
        v11 = 0;
        v12 = a3;
        do
        {
          v13 = *v12++;
          v14 = (v13 & 0x7F) << v9;
          v9 += 7;
          v11 |= v14;
        }
        while ( v13 < 0 );
        result = v12;
        v7 = v11;
        v4 = a2;
        v5 = a1;
        v6 = a1;
        break;
      case 2:
        v7 = *(unsigned __int16 *)a3;
        result = a3 + 2;
        break;
      case 4:
        v7 = *(_DWORD *)a3;
        result = a3 + 8;
        break;
      case 9:
        result = read_sleb128(a3, v18);
        v7 = v18[0];
        break;
      case 0xA:
        v7 = *(__int16 *)a3;
        result = a3 + 2;
        break;
      case 0xB:
        v7 = *(_DWORD *)a3;
        result = a3 + 4;
        break;
      case 0xC:
        v7 = *(_DWORD *)a3;
        result = a3 + 8;
        break;
      default:
        abort();
    }
    if ( v7 )
    {
      if ( (v6 & 0x70) == 16 )
        v4 = a3;
      v7 += (int)v4;
      if ( v5 < 0 )
        v7 = *(_DWORD *)v7;
    }
  }
  *a4 = v7;
  return result;
}
// 805ACB0: using guessed type void __noreturn abort(void);
// 80C02A0: using guessed type int var_20[4];

//----- (080C0430) --------------------------------------------------------
void init_dwarf_reg_size_table()
{
  dwarf_reg_size_table = 4;
  byte_80F0FFE = 4;
  byte_80F0FFD = 4;
  byte_80F0FFF = 4;
  byte_80F1002 = 4;
  byte_80F1003 = 4;
  byte_80F1001 = 4;
  byte_80F1000 = 4;
  byte_80F1007 = 12;
  byte_80F1008 = 12;
  byte_80F1009 = 12;
  byte_80F100A = 12;
  byte_80F100B = 12;
  byte_80F100C = 12;
  byte_80F1005 = 4;
  byte_80F1004 = 4;
}
// 80F0FFC: using guessed type char dwarf_reg_size_table;
// 80F0FFD: using guessed type char byte_80F0FFD;
// 80F0FFE: using guessed type char byte_80F0FFE;
// 80F0FFF: using guessed type char byte_80F0FFF;
// 80F1000: using guessed type char byte_80F1000;
// 80F1001: using guessed type char byte_80F1001;
// 80F1002: using guessed type char byte_80F1002;
// 80F1003: using guessed type char byte_80F1003;
// 80F1004: using guessed type char byte_80F1004;
// 80F1005: using guessed type char byte_80F1005;
// 80F1007: using guessed type char byte_80F1007;
// 80F1008: using guessed type char byte_80F1008;
// 80F1009: using guessed type char byte_80F1009;
// 80F100A: using guessed type char byte_80F100A;
// 80F100B: using guessed type char byte_80F100B;
// 80F100C: using guessed type char byte_80F100C;

//----- (080C04B0) --------------------------------------------------------
unsigned int __usercall execute_cfa_program@<eax>(
        unsigned int result@<eax>,
        unsigned int a2@<edx>,
        _DWORD *a3,
        unsigned int a4)
{
  char *encoded_value_with_base; // ecx
  unsigned int v5; // edi
  int v6; // edx
  int v7; // edi
  int v8; // ecx
  char *v9; // esi
  char v10; // dl
  int v11; // eax
  int v12; // edi
  int i; // edx
  int v14; // ecx
  char *v15; // esi
  int v16; // edi
  char v17; // al
  int v18; // edx
  int v19; // ecx
  char *v20; // edi
  int v21; // esi
  char v22; // dl
  int v23; // eax
  int v24; // edx
  int v25; // esi
  char v26; // cl
  int v27; // edx
  char *v28; // edx
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // ecx
  char *v33; // esi
  int v34; // edi
  char v35; // al
  int v36; // edx
  int v37; // ecx
  char *v38; // edi
  int v39; // esi
  char v40; // dl
  int v41; // eax
  int v42; // edx
  int v43; // esi
  int v44; // edi
  int v45; // ecx
  char *v46; // esi
  char v47; // dl
  int v48; // edi
  int v49; // ecx
  char *v50; // esi
  char v51; // dl
  int v52; // edi
  int v53; // ecx
  char *v54; // esi
  char v55; // dl
  int v56; // ecx
  char *v57; // esi
  int v58; // edi
  char v59; // al
  int v60; // edx
  int v61; // ecx
  char *v62; // edi
  int v63; // esi
  char v64; // dl
  int v65; // eax
  int *v66; // edx
  _DWORD *v67; // edx
  int v68; // ecx
  int v69; // edi
  int v70; // ecx
  char *v71; // esi
  char v72; // dl
  int v73; // eax
  int v74; // ecx
  int v75; // edi
  char v76; // dl
  int v77; // edi
  int v78; // ecx
  char *v79; // esi
  char v80; // dl
  int v81; // edi
  int v82; // ecx
  char *v83; // esi
  char v84; // dl
  int v85; // ecx
  char *v86; // edi
  int v87; // esi
  char v88; // dl
  int v89; // esi
  int v90; // ecx
  char *v91; // edi
  char v92; // dl
  int v93; // eax
  int v94; // ecx
  int v95; // esi
  char v96; // dl
  int v97; // edi
  int v98; // ecx
  char *v99; // esi
  char v100; // dl
  int v101; // eax
  int v102; // esi
  int v103; // ecx
  char *v104; // edi
  char v105; // dl
  int v106; // eax
  char *v107; // eax
  int v108; // ecx
  char *v109; // esi
  int v110; // edi
  char v111; // al
  int v112; // edx
  int v113; // ecx
  char *v114; // edi
  int v115; // esi
  char v116; // dl
  int v117; // eax
  int v118; // edx
  int v119; // esi
  int v120; // edi
  int v121; // ecx
  char *v122; // esi
  char v123; // dl
  int v124; // eax
  int v125; // esi
  int v126; // ecx
  char *v127; // edi
  char v128; // dl
  int v129; // eax
  int v130; // ecx
  int v131; // esi
  char v132; // dl
  int v133; // edi
  int v134; // ecx
  char *v135; // esi
  char v136; // dl
  int v137; // [esp-B0h] [ebp-F8h] BYREF
  int *v138; // [esp+14h] [ebp-34h]
  unsigned int v139; // [esp+18h] [ebp-30h]
  int v140; // [esp+1Ch] [ebp-2Ch]
  int v141; // [esp+28h] [ebp-20h] BYREF
  unsigned int v142[7]; // [esp+2Ch] [ebp-1Ch] BYREF

  encoded_value_with_base = (char *)result;
  v139 = a2;
  *(_DWORD *)(a4 + 144) = 0;
  if ( result < a2 )
  {
    v5 = *(_DWORD *)(a4 + 164);
    result = a3[19] + (a3[24] >> 31);
    if ( v5 < result )
    {
      v138 = 0;
      do
      {
        LOBYTE(v140) = *encoded_value_with_base;
        result = (unsigned int)(encoded_value_with_base + 1);
        v6 = v140 & 0xC0;
        switch ( v6 )
        {
          case 64:
            ++encoded_value_with_base;
            *(_DWORD *)(a4 + 164) = v5 + *(_DWORD *)(a4 + 176) * (v140 & 0x3F);
            break;
          case 128:
            v7 = 0;
            LOBYTE(v140) = v140 & 0x3F;
            v140 = (unsigned __int8)v140;
            v8 = 0;
            v9 = (char *)result;
            do
            {
              v10 = *v9++;
              v11 = (v10 & 0x7F) << v8;
              v8 += 7;
              v7 |= v11;
            }
            while ( v10 < 0 );
            encoded_value_with_base = v9;
            result = v140;
            v12 = *(_DWORD *)(a4 + 172) * v7;
            *(_DWORD *)(a4 + 8 * v140 + 4) = 1;
            *(_DWORD *)(a4 + 8 * result) = v12;
            break;
          case 192:
            ++encoded_value_with_base;
            *(_DWORD *)(a4 + 8 * (v140 & 0x3F) + 4) = 0;
            break;
          default:
            switch ( (char)v140 )
            {
              case 0:
                goto LABEL_20;
              case 1:
                v26 = *(_BYTE *)(a4 + 184);
                if ( v26 == -1 )
                  goto LABEL_30;
                v27 = v26 & 0x70;
                if ( v27 == 32 )
                {
                  v28 = (char *)a3[21];
                }
                else if ( (v26 & 0x70u) > 0x20 )
                {
                  switch ( v27 )
                  {
                    case '@':
                      v28 = (char *)a3[23];
                      break;
                    case 'P':
LABEL_30:
                      v28 = 0;
                      break;
                    case '0':
                      v28 = (char *)a3[22];
                      break;
                    default:
                      goto LABEL_8;
                  }
                }
                else
                {
                  if ( (v26 & 0x70) == 0 )
                    goto LABEL_30;
                  if ( v27 != 16 )
LABEL_8:
                    abort();
                  v28 = 0;
                }
                encoded_value_with_base = read_encoded_value_with_base(v26, v28, (char *)result, (int *)v142);
                result = v142[0];
                *(_DWORD *)(a4 + 164) = v142[0];
                break;
              case 2:
                v29 = (unsigned __int8)encoded_value_with_base[1];
                encoded_value_with_base += 2;
                result = v5 + *(_DWORD *)(a4 + 176) * v29;
                *(_DWORD *)(a4 + 164) = result;
                goto LABEL_10;
              case 3:
                v30 = *(unsigned __int16 *)(encoded_value_with_base + 1);
                encoded_value_with_base += 3;
                result = v5 + *(_DWORD *)(a4 + 176) * v30;
                *(_DWORD *)(a4 + 164) = result;
                goto LABEL_10;
              case 4:
                v31 = *(_DWORD *)(encoded_value_with_base + 1);
                encoded_value_with_base += 5;
                result = v5 + *(_DWORD *)(a4 + 176) * v31;
                *(_DWORD *)(a4 + 164) = result;
                goto LABEL_10;
              case 5:
                v140 = 0;
                v32 = 0;
                v33 = (char *)result;
                v34 = 0;
                do
                {
                  v35 = *v33++;
                  v36 = (v35 & 0x7F) << v32;
                  v32 += 7;
                  v34 |= v36;
                }
                while ( v35 < 0 );
                v140 = v34;
                v37 = 0;
                v38 = v33;
                v39 = 0;
                do
                {
                  v40 = *v38++;
                  v41 = (v40 & 0x7F) << v37;
                  v37 += 7;
                  v39 |= v41;
                }
                while ( v40 < 0 );
                result = a4;
                encoded_value_with_base = v38;
                v42 = v140;
                v43 = *(_DWORD *)(a4 + 172) * v39;
                *(_DWORD *)(a4 + 8 * v140 + 4) = 1;
                *(_DWORD *)(a4 + 8 * v42) = v43;
                goto LABEL_10;
              case 6:
                v44 = 0;
                v45 = 0;
                v46 = (char *)result;
                do
                {
                  v47 = *v46++;
                  result = (v47 & 0x7F) << v45;
                  v45 += 7;
                  v44 |= result;
                }
                while ( v47 < 0 );
                encoded_value_with_base = v46;
                *(_DWORD *)(a4 + 8 * v44 + 4) = 0;
                goto LABEL_10;
              case 7:
                v48 = 0;
                v49 = 0;
                v50 = (char *)result;
                do
                {
                  v51 = *v50++;
                  result = (v51 & 0x7F) << v49;
                  v49 += 7;
                  v48 |= result;
                }
                while ( v51 < 0 );
                encoded_value_with_base = v50;
                *(_DWORD *)(a4 + 8 * v48 + 4) = 6;
                goto LABEL_10;
              case 8:
                v52 = 0;
                v53 = 0;
                v54 = (char *)result;
                do
                {
                  v55 = *v54++;
                  result = (v55 & 0x7F) << v53;
                  v53 += 7;
                  v52 |= result;
                }
                while ( v55 < 0 );
                encoded_value_with_base = v54;
                *(_DWORD *)(a4 + 8 * v52 + 4) = 0;
                goto LABEL_10;
              case 9:
                v140 = 0;
                v56 = 0;
                v57 = (char *)result;
                v58 = 0;
                do
                {
                  v59 = *v57++;
                  v60 = (v59 & 0x7F) << v56;
                  v56 += 7;
                  v58 |= v60;
                }
                while ( v59 < 0 );
                v140 = v58;
                v61 = 0;
                v62 = v57;
                v63 = 0;
                do
                {
                  v64 = *v62++;
                  v65 = (v64 & 0x7F) << v61;
                  v61 += 7;
                  v63 |= v65;
                }
                while ( v64 < 0 );
                result = v140;
                encoded_value_with_base = v62;
                *(_DWORD *)(a4 + 8 * v140 + 4) = 2;
                *(_DWORD *)(a4 + 8 * result) = v63;
                goto LABEL_10;
              case 10:
                if ( v138 )
                {
                  v66 = v138;
                  v138 = (int *)v138[36];
                }
                else
                {
                  v66 = &v137;
                }
                qmemcpy(v66, (const void *)a4, 0xA4u);
                ++encoded_value_with_base;
                *(_DWORD *)(a4 + 144) = v66;
                goto LABEL_10;
              case 11:
                v67 = *(_DWORD **)(a4 + 144);
                qmemcpy((void *)a4, v67, 0xA4u);
                v68 = (int)v138;
                v138 = v67;
                v67[36] = v68;
                encoded_value_with_base = (char *)result;
                goto LABEL_10;
              case 12:
                v69 = 0;
                v70 = 0;
                v71 = (char *)result;
                do
                {
                  v72 = *v71++;
                  v73 = (v72 & 0x7F) << v70;
                  v70 += 7;
                  v69 |= v73;
                }
                while ( v72 < 0 );
                v74 = 0;
                *(_DWORD *)(a4 + 152) = v69;
                v75 = 0;
                do
                {
                  v76 = *v71++;
                  result = (v76 & 0x7F) << v74;
                  v74 += 7;
                  v75 |= result;
                }
                while ( v76 < 0 );
                encoded_value_with_base = v71;
                *(_DWORD *)(a4 + 148) = v75;
                *(_DWORD *)(a4 + 160) = 1;
                goto LABEL_10;
              case 13:
                v77 = 0;
                v78 = 0;
                v79 = (char *)result;
                do
                {
                  v80 = *v79++;
                  result = (v80 & 0x7F) << v78;
                  v78 += 7;
                  v77 |= result;
                }
                while ( v80 < 0 );
                encoded_value_with_base = v79;
                *(_DWORD *)(a4 + 152) = v77;
                *(_DWORD *)(a4 + 160) = 1;
                goto LABEL_10;
              case 14:
                v81 = 0;
                v82 = 0;
                v83 = (char *)result;
                do
                {
                  v84 = *v83++;
                  result = (v84 & 0x7F) << v82;
                  v82 += 7;
                  v81 |= result;
                }
                while ( v84 < 0 );
                encoded_value_with_base = v83;
                *(_DWORD *)(a4 + 148) = v81;
                goto LABEL_10;
              case 15:
                v85 = 0;
                v86 = (char *)result;
                *(_DWORD *)(a4 + 156) = result;
                *(_DWORD *)(a4 + 160) = 2;
                v87 = 0;
                do
                {
                  v88 = *v86++;
                  result = (v88 & 0x7F) << v85;
                  v85 += 7;
                  v87 |= result;
                }
                while ( v88 < 0 );
                encoded_value_with_base = &v86[v87];
                goto LABEL_10;
              case 16:
                v89 = 0;
                v90 = 0;
                v91 = (char *)result;
                do
                {
                  v92 = *v91++;
                  v93 = (v92 & 0x7F) << v90;
                  v90 += 7;
                  v89 |= v93;
                }
                while ( v92 < 0 );
                v94 = 0;
                *(_DWORD *)(a4 + 8 * v89 + 4) = 3;
                *(_DWORD *)(a4 + 8 * v89) = v91;
                v95 = 0;
                do
                {
                  v96 = *v91++;
                  result = (v96 & 0x7F) << v94;
                  v94 += 7;
                  v95 |= result;
                }
                while ( v96 < 0 );
                encoded_value_with_base = &v91[v95];
                goto LABEL_10;
              case 17:
                v97 = 0;
                v98 = 0;
                v99 = (char *)result;
                do
                {
                  v100 = *v99++;
                  v101 = (v100 & 0x7F) << v98;
                  v98 += 7;
                  v97 |= v101;
                }
                while ( v100 < 0 );
                encoded_value_with_base = read_sleb128(v99, &v141);
                result = v141 * *(_DWORD *)(a4 + 172);
                *(_DWORD *)(a4 + 8 * v97 + 4) = 1;
                *(_DWORD *)(a4 + 8 * v97) = result;
                goto LABEL_10;
              case 18:
                v102 = 0;
                v103 = 0;
                v104 = (char *)result;
                do
                {
                  v105 = *v104++;
                  v106 = (v105 & 0x7F) << v103;
                  v103 += 7;
                  v102 |= v106;
                }
                while ( v105 < 0 );
                *(_DWORD *)(a4 + 152) = v102;
                v107 = read_sleb128(v104, &v141);
                *(_DWORD *)(a4 + 160) = 1;
                encoded_value_with_base = v107;
                result = *(_DWORD *)(a4 + 172) * v141;
                *(_DWORD *)(a4 + 148) = result;
                goto LABEL_10;
              case 19:
                encoded_value_with_base = read_sleb128((char *)result, &v141);
                result = *(_DWORD *)(a4 + 172) * v141;
                *(_DWORD *)(a4 + 148) = result;
                goto LABEL_10;
              case 20:
                v140 = 0;
                v108 = 0;
                v109 = (char *)result;
                v110 = 0;
                do
                {
                  v111 = *v109++;
                  v112 = (v111 & 0x7F) << v108;
                  v108 += 7;
                  v110 |= v112;
                }
                while ( v111 < 0 );
                v140 = v110;
                v113 = 0;
                v114 = v109;
                v115 = 0;
                do
                {
                  v116 = *v114++;
                  v117 = (v116 & 0x7F) << v113;
                  v113 += 7;
                  v115 |= v117;
                }
                while ( v116 < 0 );
                result = a4;
                encoded_value_with_base = v114;
                v118 = v140;
                v119 = *(_DWORD *)(a4 + 172) * v115;
                *(_DWORD *)(a4 + 8 * v140 + 4) = 4;
                *(_DWORD *)(a4 + 8 * v118) = v119;
                goto LABEL_10;
              case 21:
                v120 = 0;
                v121 = 0;
                v122 = (char *)result;
                do
                {
                  v123 = *v122++;
                  v124 = (v123 & 0x7F) << v121;
                  v121 += 7;
                  v120 |= v124;
                }
                while ( v123 < 0 );
                encoded_value_with_base = read_sleb128(v122, &v141);
                result = v141 * *(_DWORD *)(a4 + 172);
                *(_DWORD *)(a4 + 8 * v120 + 4) = 4;
                *(_DWORD *)(a4 + 8 * v120) = result;
                goto LABEL_10;
              case 22:
                v125 = 0;
                v126 = 0;
                v127 = (char *)result;
                do
                {
                  v128 = *v127++;
                  v129 = (v128 & 0x7F) << v126;
                  v126 += 7;
                  v125 |= v129;
                }
                while ( v128 < 0 );
                v130 = 0;
                *(_DWORD *)(a4 + 8 * v125 + 4) = 5;
                *(_DWORD *)(a4 + 8 * v125) = v127;
                v131 = 0;
                do
                {
                  v132 = *v127++;
                  result = (v132 & 0x7F) << v130;
                  v130 += 7;
                  v131 |= result;
                }
                while ( v132 < 0 );
                encoded_value_with_base = &v127[v131];
                goto LABEL_10;
              case 45:
                for ( i = 0; i != 64; i += 4 )
                {
                  *(_DWORD *)(a4 + 2 * i + 132) = 1;
                  *(_DWORD *)(a4 + 2 * i + 128) = i;
                }
LABEL_20:
                ++encoded_value_with_base;
                goto LABEL_10;
              case 46:
                v133 = 0;
                v134 = 0;
                v135 = (char *)result;
                do
                {
                  v136 = *v135++;
                  result = (v136 & 0x7F) << v134;
                  v134 += 7;
                  v133 |= result;
                }
                while ( v136 < 0 );
                encoded_value_with_base = v135;
                a3[26] = v133;
                goto LABEL_10;
              case 47:
                v140 = 0;
                v14 = 0;
                v15 = (char *)result;
                v16 = 0;
                do
                {
                  v17 = *v15++;
                  v18 = (v17 & 0x7F) << v14;
                  v14 += 7;
                  v16 |= v18;
                }
                while ( v17 < 0 );
                v140 = v16;
                v19 = 0;
                v20 = v15;
                v21 = 0;
                do
                {
                  v22 = *v20++;
                  v23 = (v22 & 0x7F) << v19;
                  v19 += 7;
                  v21 |= v23;
                }
                while ( v22 < 0 );
                result = a4;
                encoded_value_with_base = v20;
                v24 = v140;
                v25 = *(_DWORD *)(a4 + 172) * v21;
                *(_DWORD *)(a4 + 8 * v140 + 4) = 1;
                *(_DWORD *)(a4 + 8 * v24) = -v25;
                goto LABEL_10;
              default:
                goto LABEL_8;
            }
            break;
        }
LABEL_10:
        if ( v139 <= (unsigned int)encoded_value_with_base )
          break;
        v5 = *(_DWORD *)(a4 + 164);
        result = a3[19] + (a3[24] >> 31);
      }
      while ( v5 < result );
    }
  }
  return result;
}
// 805ACB0: using guessed type void __noreturn abort(void);
// 80C04B0: using guessed type unsigned int var_1C[7];

//----- (080C0D30) --------------------------------------------------------
int __usercall execute_stack_op@<eax>(char *encoded_value_with_base@<eax>, unsigned int a2@<edx>, int a3, int a4)
{
  int v4; // edx
  int v5; // edi
  unsigned __int8 v6; // dl
  char *v7; // esi
  int v8; // ebp
  int v10; // ebp
  int v11; // ecx
  char v12; // dl
  int v13; // eax
  _DWORD *v14; // ecx
  _DWORD *v15; // ebp
  int v16; // ecx
  char v17; // dl
  int v18; // eax
  int v19; // edx
  int v20; // ebp
  char v21; // cl
  int v22; // edx
  char *v23; // edx
  int v24; // ebp
  int v25; // ecx
  int v26; // edi
  char v27; // dl
  int v28; // eax
  int v29; // edx
  int v30; // edx
  int v31; // eax
  char v32; // dl
  int v33; // edx
  int v34; // ecx
  char *v35; // edx
  int v36; // ecx
  int v37; // ebp
  int v38; // ebp
  int v39; // ecx
  char v40; // dl
  int v41; // ecx
  int v42; // ebp
  int v43; // edi
  char v44; // dl
  int v45; // eax
  int v46; // edx
  int v47; // [esp+14h] [ebp-138h]
  int v48; // [esp+14h] [ebp-138h]
  int v50[2]; // [esp+1Ch] [ebp-130h]
  int v51[64]; // [esp+24h] [ebp-128h]
  int v52; // [esp+124h] [ebp-28h] BYREF
  int v53; // [esp+128h] [ebp-24h] BYREF
  int v54[8]; // [esp+12Ch] [ebp-20h] BYREF

  v4 = a4;
  v51[0] = a4;
  if ( (unsigned int)encoded_value_with_base < a2 )
  {
    v5 = 1;
    while ( 2 )
    {
      v6 = *encoded_value_with_base;
      v7 = encoded_value_with_base + 1;
      v47 = (unsigned __int8)*encoded_value_with_base;
      switch ( *encoded_value_with_base )
      {
        case 3:
        case 12:
        case 13:
          v8 = *(_DWORD *)(encoded_value_with_base + 1);
          encoded_value_with_base += 5;
          goto LABEL_7;
        case 6:
        case 25:
        case 31:
        case 32:
        case 35:
        case -108:
          if ( !v5 )
            goto LABEL_4;
          v20 = v51[--v5];
          if ( v6 == 31 )
          {
            v8 = -v20;
            ++encoded_value_with_base;
          }
          else if ( v6 <= 0x1Fu )
          {
            if ( v6 == 6 )
            {
              v8 = *(_DWORD *)v20;
              ++encoded_value_with_base;
            }
            else
            {
              if ( v6 != 25 )
                goto LABEL_4;
              ++encoded_value_with_base;
              v8 = abs32(v20);
            }
          }
          else
          {
            switch ( v6 )
            {
              case 0x23u:
                v41 = 0;
                v50[0] = v51[v5];
                v42 = v5;
                v43 = 0;
                do
                {
                  v44 = *v7++;
                  v45 = (v44 & 0x7F) << v41;
                  v41 += 7;
                  v43 |= v45;
                }
                while ( v44 < 0 );
                v46 = v43;
                v5 = v42;
                encoded_value_with_base = v7;
                v8 = v46 + v50[0];
                break;
              case 0x94:
                v40 = encoded_value_with_base[1];
                encoded_value_with_base += 2;
                if ( v40 == 2 )
                {
                  v8 = *(unsigned __int16 *)v20;
                }
                else if ( (unsigned __int8)v40 <= 2u )
                {
                  if ( v40 != 1 )
                    goto LABEL_4;
                  v8 = *(unsigned __int8 *)v20;
                }
                else
                {
                  if ( v40 != 4 && v40 != 8 )
                    goto LABEL_4;
                  v8 = *(_DWORD *)v20;
                }
                break;
              case 0x20u:
                v8 = ~v20;
                ++encoded_value_with_base;
                break;
              default:
                goto LABEL_4;
            }
          }
          goto LABEL_7;
        case 8:
          v8 = (unsigned __int8)encoded_value_with_base[1];
          encoded_value_with_base += 2;
          goto LABEL_7;
        case 9:
          v8 = encoded_value_with_base[1];
          encoded_value_with_base += 2;
          goto LABEL_7;
        case 10:
          v8 = *(unsigned __int16 *)(encoded_value_with_base + 1);
          encoded_value_with_base += 3;
          goto LABEL_7;
        case 11:
          v8 = *(__int16 *)(encoded_value_with_base + 1);
          encoded_value_with_base += 3;
          goto LABEL_7;
        case 14:
        case 15:
          v8 = *(_DWORD *)(encoded_value_with_base + 1);
          encoded_value_with_base += 9;
          goto LABEL_7;
        case 16:
          v8 = 0;
          v16 = 0;
          do
          {
            v17 = *v7++;
            v18 = (v17 & 0x7F) << v16;
            v16 += 7;
            v8 |= v18;
          }
          while ( v17 < 0 );
          goto LABEL_26;
        case 17:
          encoded_value_with_base = read_sleb128(encoded_value_with_base + 1, &v53);
          v8 = v53;
          goto LABEL_7;
        case 18:
          if ( !v5 )
            goto LABEL_4;
          v8 = v50[v5 + 1];
          ++encoded_value_with_base;
          goto LABEL_7;
        case 19:
          if ( !v5 )
            goto LABEL_4;
          --v5;
          ++encoded_value_with_base;
          goto LABEL_9;
        case 20:
          if ( v5 <= 1 )
            goto LABEL_4;
          v8 = v50[v5];
          ++encoded_value_with_base;
          goto LABEL_7;
        case 21:
          v19 = (unsigned __int8)encoded_value_with_base[1];
          v52 = v19;
          if ( v19 >= v5 - 1 )
            goto LABEL_4;
          encoded_value_with_base += 2;
          v8 = v51[v5 - 1 - v19];
          goto LABEL_7;
        case 22:
          if ( v5 <= 1 )
            goto LABEL_4;
          v39 = v51[v5 - 1];
          v51[v5 - 1] = v51[v5 - 2];
          v51[v5 - 2] = v39;
          ++encoded_value_with_base;
          goto LABEL_9;
        case 23:
          if ( v5 <= 2 )
            goto LABEL_4;
          v50[0] = v51[v5 - 1];
          v48 = v51[v5 - 3];
          v51[v5 - 1] = v51[v5 - 2];
          v38 = v50[0];
          v51[v5 - 2] = v48;
          v51[v5 - 3] = v38;
          ++encoded_value_with_base;
          goto LABEL_9;
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 33:
        case 34:
        case 36:
        case 37:
        case 38:
        case 39:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
          if ( v5 > 1 )
          {
            v36 = v50[v5 + 1];
            v50[0] = v5 - 2;
            v37 = v51[v5 - 2];
            switch ( v6 )
            {
              case 0x1Au:
                v8 = v36 & v37;
                v5 = v50[0];
                ++encoded_value_with_base;
                goto LABEL_7;
              case 0x1Bu:
                v5 = v50[0];
                v8 = v37 / v36;
                ++encoded_value_with_base;
                goto LABEL_7;
              case 0x1Cu:
                v8 = v37 - v36;
                v5 = v50[0];
                ++encoded_value_with_base;
                goto LABEL_7;
              case 0x1Du:
                v5 = v50[0];
                ++encoded_value_with_base;
                v8 = v37 % (unsigned int)v36;
                goto LABEL_7;
              case 0x1Eu:
                v8 = v36 * v37;
                v5 = v50[0];
                ++encoded_value_with_base;
                goto LABEL_7;
              case 0x21u:
                v8 = v36 | v37;
                v5 = v50[0];
                ++encoded_value_with_base;
                goto LABEL_7;
              case 0x22u:
                v8 = v36 + v37;
                v5 = v50[0];
                ++encoded_value_with_base;
                goto LABEL_7;
              case 0x24u:
                v8 = v37 << v36;
                v5 = v50[0];
                ++encoded_value_with_base;
                goto LABEL_7;
              case 0x25u:
                v8 = (unsigned int)v37 >> v36;
                v5 = v50[0];
                ++encoded_value_with_base;
                goto LABEL_7;
              case 0x26u:
                v8 = v37 >> v36;
                v5 = v50[0];
                ++encoded_value_with_base;
                goto LABEL_7;
              case 0x27u:
                v8 = v36 ^ v37;
                v5 = v50[0];
                ++encoded_value_with_base;
                goto LABEL_7;
              case 0x29u:
                v5 = v50[0];
                ++encoded_value_with_base;
                v8 = v37 == v36;
                goto LABEL_7;
              case 0x2Au:
                v5 = v50[0];
                v8 = v37 >= v36;
                ++encoded_value_with_base;
                goto LABEL_7;
              case 0x2Bu:
                v5 = v50[0];
                v8 = v37 > v36;
                ++encoded_value_with_base;
                goto LABEL_7;
              case 0x2Cu:
                v5 = v50[0];
                ++encoded_value_with_base;
                v8 = v37 <= v36;
                goto LABEL_7;
              case 0x2Du:
                v5 = v50[0];
                ++encoded_value_with_base;
                v8 = v37 < v36;
                goto LABEL_7;
              case 0x2Eu:
                v5 = v50[0];
                ++encoded_value_with_base;
                v8 = v37 != v36;
                goto LABEL_7;
              default:
                goto LABEL_4;
            }
          }
          goto LABEL_4;
        case 40:
          if ( !v5 )
            goto LABEL_4;
          --v5;
          v33 = *(__int16 *)(encoded_value_with_base + 1);
          encoded_value_with_base += 3;
          v34 = v51[v5];
          v52 = v33;
          v35 = &encoded_value_with_base[v33];
          if ( v34 )
            encoded_value_with_base = v35;
          goto LABEL_9;
        case 47:
          v52 = *(__int16 *)(encoded_value_with_base + 1);
          encoded_value_with_base += v52 + 3;
          goto LABEL_9;
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
          ++encoded_value_with_base;
          v8 = v6 - 48;
          goto LABEL_7;
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
          v31 = v6 - 80;
          if ( v31 > 17 )
            goto LABEL_4;
          v32 = byte_80F0FAC[v6];
          v8 = *(_DWORD *)(a3 + 4 * v31);
          if ( (*(_BYTE *)(a3 + 99) & 0x40) != 0 && *(_BYTE *)(a3 + v31 + 108) )
            goto LABEL_26;
          if ( v32 == 4 )
            goto LABEL_60;
          goto LABEL_4;
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 127:
        case -128:
        case -127:
        case -126:
        case -125:
        case -124:
        case -123:
        case -122:
        case -121:
        case -120:
        case -119:
        case -118:
        case -117:
        case -116:
        case -115:
        case -114:
        case -113:
          encoded_value_with_base = read_sleb128(encoded_value_with_base + 1, &v52);
          v30 = v47 - 112;
          if ( v47 - 112 > 17 )
            goto LABEL_4;
          v15 = *(_DWORD **)(a3 + 4 * v30);
          if ( (*(_BYTE *)(a3 + 99) & 0x40) != 0 && *(_BYTE *)(a3 + v30 + 108) )
            goto LABEL_22;
          if ( byte_80F0F8C[v47] != 4 )
            goto LABEL_4;
          v15 = (_DWORD *)*v15;
          goto LABEL_22;
        case -112:
          v24 = v5;
          v25 = 0;
          v26 = 0;
          do
          {
            v27 = *v7++;
            v28 = (v27 & 0x7F) << v25;
            v25 += 7;
            v26 |= v28;
          }
          while ( v27 < 0 );
          v29 = v26;
          v5 = v24;
          if ( v29 > 17 )
            goto LABEL_4;
          v8 = *(_DWORD *)(a3 + 4 * v29);
          if ( (*(_BYTE *)(a3 + 99) & 0x40) != 0 && *(_BYTE *)(a3 + v29 + 108) )
          {
LABEL_26:
            encoded_value_with_base = v7;
          }
          else
          {
            if ( dwarf_reg_size_table[v29] != 4 )
              goto LABEL_4;
LABEL_60:
            v8 = *(_DWORD *)v8;
            encoded_value_with_base = v7;
          }
          goto LABEL_7;
        case -110:
          v10 = 0;
          v11 = 0;
          do
          {
            v12 = *v7++;
            v13 = (v12 & 0x7F) << v11;
            v11 += 7;
            v10 |= v13;
          }
          while ( v12 < 0 );
          encoded_value_with_base = read_sleb128(v7, &v52);
          if ( v10 > 17 )
            goto LABEL_4;
          v14 = *(_DWORD **)(a3 + 4 * v10);
          if ( (*(_BYTE *)(a3 + 99) & 0x40) != 0 && *(_BYTE *)(a3 + v10 + 108) )
            goto LABEL_21;
          if ( dwarf_reg_size_table[v10] != 4 )
            goto LABEL_4;
          v14 = (_DWORD *)*v14;
LABEL_21:
          v15 = v14;
LABEL_22:
          v8 = (int)v15 + v52;
          goto LABEL_7;
        case -106:
          ++encoded_value_with_base;
          goto LABEL_9;
        case -15:
          v21 = encoded_value_with_base[1];
          if ( v21 == -1 )
            goto LABEL_88;
          v22 = v21 & 0x70;
          if ( v22 == 32 )
          {
            v23 = *(char **)(a3 + 84);
          }
          else
          {
            if ( (v21 & 0x70u) <= 0x20 )
            {
              if ( (v21 & 0x70) != 0 && v22 != 16 )
                goto LABEL_4;
LABEL_88:
              v23 = 0;
              goto LABEL_89;
            }
            switch ( v22 )
            {
              case '@':
                v23 = *(char **)(a3 + 92);
                break;
              case 'P':
                goto LABEL_88;
              case '0':
                v23 = *(char **)(a3 + 88);
                break;
              default:
                goto LABEL_4;
            }
          }
LABEL_89:
          encoded_value_with_base = read_encoded_value_with_base(v21, v23, encoded_value_with_base + 2, v54);
          v8 = v54[0];
LABEL_7:
          if ( (unsigned int)v5 > 0x3F )
            goto LABEL_4;
          v51[v5++] = v8;
LABEL_9:
          if ( a2 > (unsigned int)encoded_value_with_base )
            continue;
          if ( !v5 )
LABEL_4:
            abort();
          v4 = v50[v5 + 1];
          break;
        default:
          goto LABEL_4;
      }
      break;
    }
  }
  return v4;
}
// 805ACB0: using guessed type void __noreturn abort(void);
// 80C0D30: using guessed type int var_128[64];
// 80C0D30: using guessed type int var_20[8];

//----- (080C1810) --------------------------------------------------------
int __usercall uw_update_context_1@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v2; // eax
  int *v3; // edx
  int v4; // edx
  int v5; // edx
  _DWORD *v6; // ecx
  int v7; // esi
  int v8; // ecx
  char *v9; // edi
  char v10; // dl
  int v11; // eax
  int v12; // edi
  _DWORD *v13; // esi
  int v14; // eax
  int v15; // eax
  int result; // eax
  int v17; // eax
  int v18; // ebp
  int v19; // ecx
  char *v20; // esi
  char v21; // al
  int v22; // edx
  char *v23; // eax
  unsigned int v24; // edx
  int v25; // eax
  int v26; // edx
  int v27; // ebp
  int v28; // ecx
  char *v29; // esi
  char v30; // al
  int v31; // edx
  char *v32; // eax
  unsigned int v33; // edx
  _DWORD *v34; // eax
  char v35; // dl
  int v37; // [esp+24h] [ebp-B8h]
  _DWORD *v38; // [esp+28h] [ebp-B4h]
  _DWORD *v39; // [esp+28h] [ebp-B4h]
  int v41[32]; // [esp+3Ch] [ebp-A0h] BYREF
  int v42; // [esp+BCh] [ebp-20h] BYREF

  qmemcpy(v41, (const void *)a1, sizeof(v41));
  v2 = v41[24];
  if ( (v41[24] & 0x40000000) == 0 || (v3 = &v41[4], !LOBYTE(v41[28])) )
    v3 = (int *)v41[4];
  if ( !v3 )
  {
    if ( byte_80F1000 != 4 )
      goto LABEL_8;
    v42 = *(_DWORD *)(a1 + 72);
    if ( (v41[24] & 0x40000000) != 0 )
      LOBYTE(v41[28]) = 0;
    v41[4] = (int)&v42;
  }
  if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 )
    *(_BYTE *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  v4 = *(_DWORD *)(a2 + 160);
  if ( v4 != 1 )
  {
    if ( v4 != 2 )
      goto LABEL_8;
    v7 = 0;
    v8 = 0;
    v9 = *(char **)(a2 + 156);
    do
    {
      v10 = *v9++;
      v11 = (v10 & 0x7F) << v8;
      v8 += 7;
      v7 |= v11;
    }
    while ( v10 < 0 );
    v37 = execute_stack_op(v9, (unsigned int)&v9[v7], (int)v41, 0);
    goto LABEL_19;
  }
  v5 = *(_DWORD *)(a2 + 152);
  if ( v5 > 17 )
    goto LABEL_8;
  v6 = (_DWORD *)v41[v5];
  if ( (v2 & 0x40000000) != 0 && *((_BYTE *)&v41[27] + v5) )
    goto LABEL_13;
  if ( dwarf_reg_size_table[v5] != 4 )
LABEL_8:
    abort();
  v6 = (_DWORD *)*v6;
LABEL_13:
  v37 = (int)v6 + *(_DWORD *)(a2 + 148);
LABEL_19:
  v12 = 0;
  *(_DWORD *)(a1 + 72) = v37;
  v13 = (_DWORD *)(a2 + 4);
  while ( 2 )
  {
    switch ( *v13 )
    {
      case 1:
        v26 = a1;
        v25 = *(v13 - 1) + v37;
        if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 )
          goto LABEL_35;
        goto LABEL_36;
      case 2:
        v14 = *(v13 - 1);
        if ( !*((_BYTE *)&v41[27] + v14) )
        {
          v15 = v41[v14];
          if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 )
            *(_BYTE *)(a1 + v12 + 108) = 0;
          *(_DWORD *)(a1 + 4 * v12) = v15;
LABEL_25:
          ++v12;
          v13 += 2;
          if ( v12 == 18 )
            goto LABEL_26;
          continue;
        }
        if ( v14 > 17 )
          goto LABEL_8;
        v35 = dwarf_reg_size_table[v14];
        v34 = (_DWORD *)v41[v14];
        if ( (v41[24] & 0x40000000) == 0 )
        {
          if ( v35 != 4 )
            goto LABEL_8;
          v34 = (_DWORD *)*v34;
        }
LABEL_43:
        if ( dwarf_reg_size_table[v12] != 4 )
          goto LABEL_8;
        v13 += 2;
        *(_BYTE *)(a1 + v12 + 108) = 1;
        *(_DWORD *)(a1 + 4 * v12++) = v34;
        if ( v12 != 18 )
          continue;
LABEL_26:
        if ( *(_BYTE *)(a2 + 187) )
        {
          result = *(_DWORD *)(a1 + 76);
          *(_DWORD *)(a1 + 96) |= 0x80000000;
          if ( *(_BYTE *)result != 0xB8 )
            return result;
LABEL_51:
          if ( *(_DWORD *)(result + 1) == 173 )
          {
            result = *(unsigned __int16 *)(result + 5);
            if ( (_WORD)result == 1295 || (_WORD)result == 0x80CD )
              *(_DWORD *)(a1 + 96) |= 0x80000000;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 96) &= ~0x80000000;
          result = *(_DWORD *)(a1 + 76);
          if ( *(_BYTE *)result == 0xB8 )
            goto LABEL_51;
        }
        return result;
      case 3:
        v18 = 0;
        v19 = 0;
        v38 = v13;
        v20 = (char *)*(v13 - 1);
        do
        {
          v21 = *v20++;
          v22 = (v21 & 0x7F) << v19;
          v19 += 7;
          v18 |= v22;
        }
        while ( v21 < 0 );
        v23 = v20;
        v24 = (unsigned int)&v20[v18];
        v13 = v38;
        v25 = execute_stack_op(v23, v24, (int)v41, v37);
        v26 = a1;
        if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 )
LABEL_35:
          *(_BYTE *)(v26 + v12 + 108) = 0;
LABEL_36:
        v13 += 2;
        *(_DWORD *)(a1 + 4 * v12++) = v25;
        if ( v12 == 18 )
          goto LABEL_26;
        continue;
      case 4:
        v17 = *(v13 - 1);
        if ( dwarf_reg_size_table[v12] != 4 )
          goto LABEL_8;
        v13 += 2;
        *(_BYTE *)(a1 + v12 + 108) = 1;
        *(_DWORD *)(a1 + 4 * v12++) = v37 + v17;
        if ( v12 == 18 )
          goto LABEL_26;
        continue;
      case 5:
        v27 = 0;
        v28 = 0;
        v39 = v13;
        v29 = (char *)*(v13 - 1);
        do
        {
          v30 = *v29++;
          v31 = (v30 & 0x7F) << v28;
          v28 += 7;
          v27 |= v31;
        }
        while ( v30 < 0 );
        v32 = v29;
        v33 = (unsigned int)&v29[v27];
        v13 = v39;
        v34 = (_DWORD *)execute_stack_op(v32, v33, (int)v41, v37);
        goto LABEL_43;
      default:
        goto LABEL_25;
    }
  }
}
// 805ACB0: using guessed type void __noreturn abort(void);
// 80F1000: using guessed type char byte_80F1000;

//----- (080C1BE0) --------------------------------------------------------
int __usercall uw_update_context@<eax>(int a1@<eax>, int a2@<edx>)
{
  int result; // eax

  uw_update_context_1(a1, a2);
  result = *(_DWORD *)(a2 + 180);
  if ( *(_DWORD *)(a2 + 8 * result + 4) == 6 )
  {
    *(_DWORD *)(a1 + 76) = 0;
  }
  else
  {
    if ( result > 17 )
      goto LABEL_6;
    if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 && *(_BYTE *)(a1 + result + 108) )
    {
      result = *(_DWORD *)(a1 + 4 * result);
    }
    else
    {
      if ( dwarf_reg_size_table[result] != 4 )
LABEL_6:
        abort();
      result = **(_DWORD **)(a1 + 4 * result);
    }
    *(_DWORD *)(a1 + 76) = result;
  }
  return result;
}
// 805ACB0: using guessed type void __noreturn abort(void);

//----- (080C1C70) --------------------------------------------------------
int __usercall uw_frame_state_for@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  _WORD *v2; // edi
  unsigned int v4; // edx
  _WORD *v5; // edi
  int v6; // eax
  int v7; // edx
  int v8; // eax
  char *v9; // ebp
  int v10; // edi
  int v11; // ecx
  char v12; // dl
  int v13; // eax
  int v14; // edi
  char *sleb128; // eax
  int v16; // ecx
  char *v17; // ebp
  char v18; // dl
  int v19; // eax
  char *v20; // eax
  unsigned int v21; // ebp
  char v22; // dl
  char *v23; // edi
  char v24; // dl
  char v25; // dl
  int result; // eax
  char v27; // cl
  int v28; // edx
  char v29; // al
  int v30; // eax
  int v31; // eax
  unsigned int v32; // edi
  char *v33; // eax
  int v34; // ecx
  char *v35; // ebp
  char v36; // al
  int v37; // edx
  char v38; // cl
  int v39; // edx
  char *v40; // edx
  int v41; // edx
  int v42; // ecx
  int v43; // eax
  int v44; // edi
  int v45; // ecx
  char *v46; // ebp
  char v47; // al
  int v48; // edx
  int v49; // edx
  int v50; // edi
  int v51; // ecx
  char *v53; // [esp+14h] [ebp-38h]
  _DWORD *FDE; // [esp+18h] [ebp-34h]
  char *v55; // [esp+1Ch] [ebp-30h]
  int v56; // [esp+28h] [ebp-24h] BYREF
  int v57[8]; // [esp+2Ch] [ebp-20h] BYREF

  v2 = (_WORD *)a2;
  v4 = 192;
  if ( (a2 & 1) != 0 )
  {
    v2 = (_WORD *)(a2 + 1);
    LOBYTE(v4) = -65;
    *(_BYTE *)a2 = 0;
    if ( ((a2 + 1) & 2) == 0 )
      goto LABEL_3;
LABEL_78:
    *v2 = 0;
    v4 -= 2;
    ++v2;
    goto LABEL_3;
  }
  if ( ((unsigned __int8)v2 & 2) != 0 )
    goto LABEL_78;
LABEL_3:
  memset(v2, 0, 4 * (v4 >> 2));
  v5 = &v2[2 * (v4 >> 2)];
  if ( (v4 & 2) != 0 )
    *v5++ = 0;
  if ( (v4 & 1) != 0 )
    *(_BYTE *)v5 = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  v6 = *(_DWORD *)(a1 + 76);
  if ( !v6 )
    return 5;
  FDE = (_DWORD *)Unwind_Find_FDE(v6 + (*(_DWORD *)(a1 + 96) >> 31) - 1, (_DWORD *)(a1 + 84));
  if ( !FDE )
  {
    v41 = *(_DWORD *)(a1 + 76);
    v42 = *(_DWORD *)(a1 + 72);
    if ( *(_WORD *)v41 != 0xB858 || *(_DWORD *)(v41 + 2) != 119 || (v43 = v42 + 4, *(_WORD *)(v41 + 6) != 0x80CD) )
    {
      result = 5;
      if ( *(_BYTE *)v41 != 0xB8 || *(_DWORD *)(v41 + 1) != 173 || *(_WORD *)(v41 + 5) != 0x80CD )
        return result;
      v43 = v42 + 160;
    }
    v49 = *(_DWORD *)(v43 + 28);
    *(_DWORD *)(a2 + 160) = 1;
    *(_DWORD *)(a2 + 152) = 4;
    *(_DWORD *)(a2 + 4) = 1;
    v50 = v49 - v42;
    *(_DWORD *)a2 = v43 + 44 - v49;
    *(_DWORD *)(a2 + 24) = v43 + 32 - v49;
    *(_DWORD *)(a2 + 8) = v43 + 40 - v49;
    *(_DWORD *)(a2 + 16) = v43 + 36 - v49;
    *(_DWORD *)(a2 + 48) = v43 + 20 - v49;
    *(_DWORD *)(a2 + 56) = v43 + 16 - v49;
    v51 = v43 + 24 - v49;
    *(_DWORD *)(a2 + 64) = v43 + 56 - v49;
    result = 0;
    *(_DWORD *)(a2 + 148) = v50;
    *(_DWORD *)(a2 + 28) = 1;
    *(_DWORD *)(a2 + 12) = 1;
    *(_DWORD *)(a2 + 20) = 1;
    *(_DWORD *)(a2 + 52) = 1;
    *(_DWORD *)(a2 + 60) = 1;
    *(_DWORD *)(a2 + 44) = 1;
    *(_DWORD *)(a2 + 40) = v51;
    *(_DWORD *)(a2 + 68) = 1;
    *(_DWORD *)(a2 + 180) = 8;
    *(_BYTE *)(a2 + 187) = 1;
    return result;
  }
  v7 = FDE[1];
  *(_DWORD *)(a2 + 164) = *(_DWORD *)(a1 + 92);
  v53 = (char *)FDE - v7 + 4;
  v55 = v53 + 9;
  v8 = (int)&v53[strlen(v53 + 9) + 1];
  v9 = (char *)(v8 + 9);
  if ( v53[9] == 101 && v53[10] == 104 )
  {
    v9 = (char *)(v8 + 13);
    v55 = v53 + 11;
    *(_DWORD *)(a2 + 188) = *(_DWORD *)(v8 + 9);
  }
  if ( (unsigned __int8)v53[8] > 3u )
  {
    if ( *v9 != 4 || v9[1] )
      return 3;
    v9 += 2;
  }
  v10 = 0;
  v11 = 0;
  do
  {
    v12 = *v9++;
    v13 = (v12 & 0x7F) << v11;
    v11 += 7;
    v10 |= v13;
  }
  while ( v12 < 0 );
  *(_DWORD *)(a2 + 176) = v10;
  v14 = 0;
  sleb128 = read_sleb128(v9, v57);
  v16 = 0;
  v17 = sleb128;
  *(_DWORD *)(a2 + 172) = v57[0];
  if ( v53[8] == 1 )
  {
    *(_DWORD *)(a2 + 180) = (unsigned __int8)*sleb128;
    v20 = sleb128 + 1;
  }
  else
  {
    do
    {
      v18 = *v17++;
      v19 = (v18 & 0x7F) << v16;
      v16 += 7;
      v14 |= v19;
    }
    while ( v18 < 0 );
    v20 = v17;
    *(_DWORD *)(a2 + 180) = v14;
  }
  v21 = 0;
  *(_BYTE *)(a2 + 185) = -1;
  v22 = *v55;
  if ( *v55 == 122 )
  {
    v44 = 0;
    v45 = 0;
    v46 = v20;
    do
    {
      v47 = *v46++;
      v48 = (v47 & 0x7F) << v45;
      v45 += 7;
      v44 |= v48;
    }
    while ( v47 < 0 );
    v20 = v46;
    v21 = (unsigned int)&v46[v44];
    *(_BYTE *)(a2 + 186) = 1;
    v22 = *++v55;
  }
  v23 = v55 + 1;
  while ( v22 )
  {
    switch ( v22 )
    {
      case 'L':
        v24 = *v20++;
        *(_BYTE *)(a2 + 185) = v24;
        goto LABEL_22;
      case 'R':
        v25 = *v20++;
        *(_BYTE *)(a2 + 184) = v25;
        goto LABEL_22;
      case 'P':
        v27 = *v20;
        if ( *v20 == -1 )
          goto LABEL_44;
        v28 = v27 & 0x70;
        if ( v28 == 32 )
        {
          v20 = read_encoded_value_with_base(v27, *(char **)(a1 + 84), v20 + 1, &v56);
        }
        else
        {
          if ( (v27 & 0x70u) <= 0x20 )
          {
            if ( (v27 & 0x70) != 0 && v28 != 16 )
              goto LABEL_35;
            goto LABEL_44;
          }
          switch ( v28 )
          {
            case '@':
              v20 = read_encoded_value_with_base(v27, *(char **)(a1 + 92), v20 + 1, &v56);
              break;
            case 'P':
LABEL_44:
              v20 = read_encoded_value_with_base(v27, 0, v20 + 1, &v56);
              break;
            case '0':
              v20 = read_encoded_value_with_base(v27, *(char **)(a1 + 88), v20 + 1, &v56);
              break;
            default:
              goto LABEL_35;
          }
        }
        *(_DWORD *)(a2 + 168) = v56;
        goto LABEL_22;
    }
    if ( v22 != 83 )
      goto LABEL_69;
    *(_BYTE *)(a2 + 187) = 1;
LABEL_22:
    v22 = *v23++;
  }
  if ( !v21 )
  {
    v21 = (unsigned int)v20;
LABEL_69:
    if ( !v21 )
      return 3;
  }
  execute_cfa_program(v21, (unsigned int)&v53[*(_DWORD *)v53 + 4], (_DWORD *)a1, a2);
  v29 = *(_BYTE *)(a2 + 184);
  if ( v29 == -1 )
  {
    v31 = 0;
  }
  else
  {
    v30 = v29 & 7;
    if ( v30 == 2 )
    {
      v31 = 1;
    }
    else
    {
      if ( v30 <= 2 )
      {
        if ( !v30 )
          goto LABEL_41;
LABEL_35:
        abort();
      }
      if ( v30 == 3 )
      {
LABEL_41:
        v31 = 2;
      }
      else
      {
        if ( v30 != 4 )
          goto LABEL_35;
        v31 = 4;
      }
    }
  }
  v32 = 0;
  v33 = (char *)&FDE[v31 + 2];
  if ( *(_BYTE *)(a2 + 186) )
  {
    v34 = 0;
    v35 = v33;
    do
    {
      v36 = *v35++;
      v37 = (v36 & 0x7F) << v34;
      v34 += 7;
      v32 |= v37;
    }
    while ( v36 < 0 );
    v33 = v35;
    v32 += (unsigned int)v35;
  }
  v38 = *(_BYTE *)(a2 + 185);
  if ( v38 == -1 )
    goto LABEL_59;
  v39 = v38 & 0x70;
  if ( v39 == 32 )
  {
    v40 = *(char **)(a1 + 84);
    goto LABEL_58;
  }
  if ( (v38 & 0x70u) <= 0x20 )
  {
    if ( (v38 & 0x70) != 0 && v39 != 16 )
      goto LABEL_35;
    goto LABEL_86;
  }
  if ( v39 == 64 )
  {
    v40 = *(char **)(a1 + 92);
    goto LABEL_58;
  }
  if ( v39 == 80 )
  {
LABEL_86:
    v40 = 0;
    goto LABEL_58;
  }
  if ( v39 != 48 )
    goto LABEL_35;
  v40 = *(char **)(a1 + 88);
LABEL_58:
  v33 = read_encoded_value_with_base(v38, v40, v33, &v56);
  *(_DWORD *)(a1 + 80) = v56;
LABEL_59:
  if ( !v32 )
    v32 = (unsigned int)v33;
  execute_cfa_program(v32, (unsigned int)FDE + *FDE + 4, (_DWORD *)a1, a2);
  return 0;
}
// 805ACB0: using guessed type void __noreturn abort(void);
// 80C1C70: using guessed type int var_20[8];

//----- (080C2270) --------------------------------------------------------
int __usercall uw_init_context_1@<eax>(int a1@<eax>, int a2@<edx>, int a3)
{
  _WORD *v4; // edi
  unsigned int v5; // edx
  _WORD *v6; // edi
  bool v7; // zf
  int result; // eax
  char v10[148]; // [esp+2Ch] [ebp-E0h] BYREF
  int v11; // [esp+C0h] [ebp-4Ch]
  int v12; // [esp+C4h] [ebp-48h]
  int v13; // [esp+CCh] [ebp-40h]
  int v14; // [esp+ECh] [ebp-20h] BYREF
  void *retaddr; // [esp+10Ch] [ebp+0h]

  v4 = (_WORD *)a1;
  v5 = 128;
  if ( (a1 & 1) != 0 )
  {
    *(_BYTE *)a1 = 0;
    v4 = (_WORD *)(a1 + 1);
    LOBYTE(v5) = 127;
  }
  if ( ((unsigned __int8)v4 & 2) != 0 )
  {
    *v4 = 0;
    v5 -= 2;
    ++v4;
  }
  memset(v4, 0, 4 * (v5 >> 2));
  v6 = &v4[2 * (v5 >> 2)];
  if ( (v5 & 2) != 0 )
    *v6++ = 0;
  if ( (v5 & 1) != 0 )
    *(_BYTE *)v6 = 0;
  *(_DWORD *)(a1 + 76) = retaddr;
  *(_DWORD *)(a1 + 96) = 0x40000000;
  if ( uw_frame_state_for(a1, (unsigned int)v10) )
LABEL_12:
    abort();
  if ( dwarf_reg_size_table[0] )
  {
    if ( byte_80F1000 != 4 )
      goto LABEL_12;
  }
  else
  {
    byte_80F1000 = 4;
    dwarf_reg_size_table[0] = 4;
    byte_80F0FFE = 4;
    byte_80F0FFD = 4;
    byte_80F0FFF = 4;
    byte_80F1002 = 4;
    byte_80F1003 = 4;
    byte_80F1001 = 4;
    byte_80F1007 = 12;
    byte_80F1008 = 12;
    byte_80F1009 = 12;
    byte_80F100A = 12;
    byte_80F100B = 12;
    byte_80F100C = 12;
    byte_80F1005 = 4;
    byte_80F1004 = 4;
  }
  v7 = (*(_BYTE *)(a1 + 99) & 0x40) == 0;
  v14 = a2;
  if ( !v7 )
    *(_BYTE *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 16) = &v14;
  v13 = 1;
  v12 = 4;
  v11 = 0;
  uw_update_context_1(a1, (int)v10);
  result = a3;
  *(_DWORD *)(a1 + 76) = a3;
  return result;
}
// 805ACB0: using guessed type void __noreturn abort(void);
// 80F0FFD: using guessed type char byte_80F0FFD;
// 80F0FFE: using guessed type char byte_80F0FFE;
// 80F0FFF: using guessed type char byte_80F0FFF;
// 80F1000: using guessed type char byte_80F1000;
// 80F1001: using guessed type char byte_80F1001;
// 80F1002: using guessed type char byte_80F1002;
// 80F1003: using guessed type char byte_80F1003;
// 80F1004: using guessed type char byte_80F1004;
// 80F1005: using guessed type char byte_80F1005;
// 80F1007: using guessed type char byte_80F1007;
// 80F1008: using guessed type char byte_80F1008;
// 80F1009: using guessed type char byte_80F1009;
// 80F100A: using guessed type char byte_80F100A;
// 80F100B: using guessed type char byte_80F100B;
// 80F100C: using guessed type char byte_80F100C;

//----- (080C2460) --------------------------------------------------------
int __usercall Unwind_ForcedUnwind_Phase2@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v4; // eax
  int v5; // eax
  int v6; // edi
  int v7; // eax
  int (__cdecl *v9)(int, int, _DWORD, _DWORD, _DWORD *, int, int); // [esp+28h] [ebp-D4h]
  int v10; // [esp+2Ch] [ebp-D0h]
  char v11[168]; // [esp+30h] [ebp-CCh] BYREF
  int (__cdecl *v12)(int, int, _DWORD, _DWORD, _DWORD *, int); // [esp+D8h] [ebp-24h]

  v9 = (int (__cdecl *)(int, int, _DWORD, _DWORD, _DWORD *, int, int))a1[3];
  v10 = a1[4];
  while ( 1 )
  {
    v7 = uw_frame_state_for(a2, (unsigned int)v11);
    v6 = v7;
    if ( v7 != 5 )
    {
      if ( v7 )
        break;
    }
    v4 = 10;
    if ( v6 == 5 )
      v4 = 26;
    if ( v9(1, v4, *a1, a1[1], a1, a2, v10) )
      break;
    if ( v6 == 5 )
      return v6;
    if ( v12 )
    {
      v5 = v12(1, 10, *a1, a1[1], a1, a2);
      v6 = v5;
      if ( v5 == 7 )
        return v6;
      if ( v5 != 8 )
        break;
    }
    uw_update_context(a2, (int)v11);
  }
  return 2;
}

//----- (080C2550) --------------------------------------------------------
int __usercall Unwind_RaiseException_Phase2@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int result; // eax
  int v5; // eax
  int v6; // edi
  char v7[168]; // [esp+20h] [ebp-DCh] BYREF
  int (__cdecl *v8)(int, int, _DWORD, _DWORD, _DWORD *, int); // [esp+C8h] [ebp-34h]

  while ( 1 )
  {
    v5 = uw_frame_state_for(a2, (unsigned int)v7);
    v6 = 4 * (a1[4] == *(_DWORD *)(a2 + 72) - (*(_DWORD *)(a2 + 96) >> 31));
    if ( v5 )
      break;
    if ( v8 )
    {
      result = v8(1, v6 | 2, *a1, a1[1], a1, a2);
      if ( result == 7 )
        return result;
      if ( result != 8 )
        break;
    }
    if ( v6 )
      abort();
    uw_update_context(a2, (int)v7);
  }
  return 2;
}
// 805ACB0: using guessed type void __noreturn abort(void);

//----- (080C2600) --------------------------------------------------------
int __usercall uw_install_context_1@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v5; // eax
  int v6; // edx
  int i; // edi
  int *v8; // eax
  int *v9; // edx
  int result; // eax
  int v11; // eax
  int v12[9]; // [esp+18h] [ebp-24h] BYREF

  v5 = *(_DWORD *)(a2 + 96);
  if ( (v5 & 0x40000000) == 0 || (v6 = a2 + 16, !*(_BYTE *)(a2 + 112)) )
    v6 = *(_DWORD *)(a2 + 16);
  if ( !v6 )
  {
    v9 = *(int **)(a2 + 72);
    if ( byte_80F1000 != 4 )
      goto LABEL_10;
    v12[0] = *(_DWORD *)(a2 + 72);
    if ( (v5 & 0x40000000) != 0 )
      *(_BYTE *)(a2 + 112) = 0;
    *(_DWORD *)(a2 + 16) = v12;
  }
  for ( i = 0; i != 17; ++i )
  {
    v8 = *(int **)(a1 + 4 * i);
    v9 = *(int **)(a2 + 4 * i);
    if ( *(_BYTE *)(a1 + i + 108) )
      goto LABEL_10;
    LOBYTE(a3) = v8 != 0;
    if ( v8 && *(_BYTE *)(a2 + i + 108) )
    {
      if ( dwarf_reg_size_table[i] != 4 )
        goto LABEL_10;
      v12[1] = *(_DWORD *)(a2 + 4 * i);
      *v8 = (int)v9;
    }
    else if ( v9 && v8 && v9 != v8 )
    {
      memcpy(v8, *(_BYTE **)(a2 + 4 * i), (unsigned __int8)dwarf_reg_size_table[i]);
    }
  }
  if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 && *(_BYTE *)(a1 + 112) )
  {
    result = 0;
    if ( a1 == -16 )
    {
LABEL_22:
      v9 = *(int **)(a2 + 16);
      if ( (*(_BYTE *)(a2 + 99) & 0x40) != 0 && *(_BYTE *)(a2 + 112) )
      {
        v11 = *(_DWORD *)(a2 + 16);
        return *(_DWORD *)(a2 + 104) + v11 - *(_DWORD *)(a1 + 72);
      }
      if ( byte_80F1000 == 4 )
      {
        v11 = *v9;
        return *(_DWORD *)(a2 + 104) + v11 - *(_DWORD *)(a1 + 72);
      }
LABEL_10:
      abort(a3, v9);
    }
  }
  else
  {
    result = 0;
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_22;
  }
  return result;
}
// 80C265E: variable 'a3' is possibly undefined
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);
// 80F1000: using guessed type char byte_80F1000;

//----- (080C2730) --------------------------------------------------------
int __cdecl Unwind_GetGR(int a1, int a2)
{
  if ( a2 > 17 )
    goto LABEL_4;
  if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 && *(_BYTE *)(a1 + a2 + 108) )
    return *(_DWORD *)(a1 + 4 * a2);
  if ( dwarf_reg_size_table[a2] != 4 )
LABEL_4:
    abort(a1, a2);
  return **(_DWORD **)(a1 + 4 * a2);
}
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);

//----- (080C27A0) --------------------------------------------------------
int __cdecl Unwind_GetCFA(int a1)
{
  return *(_DWORD *)(a1 + 72);
}

//----- (080C27B0) --------------------------------------------------------
_DWORD *__cdecl Unwind_SetGR(int a1, int a2, int a3)
{
  int v3; // ecx
  _DWORD *result; // eax

  result = (_DWORD *)a2;
  if ( a2 > 17 )
    goto LABEL_4;
  v3 = (unsigned __int8)dwarf_reg_size_table[a2];
  if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 && *(_BYTE *)(a1 + a2 + 108) )
  {
    *(_DWORD *)(a1 + 4 * a2) = a3;
    return result;
  }
  result = *(_DWORD **)(a1 + 4 * a2);
  if ( (_BYTE)v3 != 4 )
LABEL_4:
    abort(v3, a1);
  *result = a3;
  return result;
}
// 80C27ED: variable 'v3' is possibly undefined
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);

//----- (080C2820) --------------------------------------------------------
int __cdecl Unwind_GetIP(int a1)
{
  return *(_DWORD *)(a1 + 76);
}

//----- (080C2830) --------------------------------------------------------
int __cdecl Unwind_GetIPInfo(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 96) >> 31;
  return *(_DWORD *)(a1 + 76);
}

//----- (080C2850) --------------------------------------------------------
int __cdecl Unwind_SetIP(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 76) = a2;
  return result;
}

//----- (080C2860) --------------------------------------------------------
int __cdecl Unwind_GetLanguageSpecificData(int a1)
{
  return *(_DWORD *)(a1 + 80);
}

//----- (080C2870) --------------------------------------------------------
int __cdecl Unwind_GetRegionStart(int a1)
{
  return *(_DWORD *)(a1 + 92);
}

//----- (080C2880) --------------------------------------------------------
int __cdecl Unwind_FindEnclosingFunction(int a1)
{
  _DWORD v2[6]; // [esp+14h] [ebp-18h] BYREF

  if ( Unwind_Find_FDE(a1 - 1, v2) )
    return v2[2];
  else
    return 0;
}

//----- (080C28C0) --------------------------------------------------------
int __cdecl Unwind_GetDataRelBase(int a1)
{
  return *(_DWORD *)(a1 + 88);
}

//----- (080C28D0) --------------------------------------------------------
int __cdecl Unwind_GetTextRelBase(int a1)
{
  return *(_DWORD *)(a1 + 84);
}

//----- (080C28E0) --------------------------------------------------------
int __cdecl _frame_state_for(int a1, int a2)
{
  int v2; // eax
  int v3; // edx
  _DWORD v5[38]; // [esp+0h] [ebp-C0h] BYREF
  __int16 v6; // [esp+98h] [ebp-28h]
  int v7; // [esp+A0h] [ebp-20h]
  __int16 v8; // [esp+B4h] [ebp-Ch]
  int v9; // [esp+BCh] [ebp-4h]
  _DWORD v10[34]; // [esp+C0h] [ebp+0h] BYREF

  memset(v10, 0, 0x80u);
  v10[24] = 0x40000000;
  v10[19] = a1 + 1;
  v2 = uw_frame_state_for((int)v10, (unsigned int)v5);
  if ( v2 || v7 == 2 )
    return 0;
  do
  {
    while ( 1 )
    {
      v3 = v5[2 * v2 + 1];
      *(_BYTE *)(a2 + v2 + 92) = v3;
      if ( (_BYTE)v3 == 1 || (_BYTE)v3 == 2 )
        break;
      *(_DWORD *)(a2 + 4 * v2++ + 16) = 0;
      if ( v2 == 18 )
        goto LABEL_8;
    }
    *(_DWORD *)(a2 + 4 * v2 + 16) = v5[2 * v2];
    ++v2;
  }
  while ( v2 != 18 );
LABEL_8:
  *(_DWORD *)(a2 + 8) = v5[37];
  *(_WORD *)(a2 + 88) = v6;
  *(_WORD *)(a2 + 90) = v8;
  *(_DWORD *)(a2 + 12) = v10[26];
  *(_DWORD *)(a2 + 4) = v9;
  return a2;
}

//----- (080C29D0) --------------------------------------------------------
int __usercall Unwind_RaiseException@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3)
{
  int v3; // eax
  int result; // eax
  unsigned int v5; // edx
  int v6; // ecx
  int v7; // eax
  int v8; // edi
  int v9; // esi
  char v10[168]; // [esp+8h] [ebp-1D8h] BYREF
  int (__cdecl *v11)(int, int, _DWORD, _DWORD, _DWORD *, int *); // [esp+B0h] [ebp-130h]
  char v12[128]; // [esp+C8h] [ebp-118h] BYREF
  int v13[33]; // [esp+148h] [ebp-98h] BYREF
  int v14; // [esp+1CCh] [ebp-14h]
  int v15; // [esp+1D0h] [ebp-10h]
  int retaddr; // [esp+1E4h] [ebp+4h]

  v15 = a2;
  v14 = a1;
  uw_init_context_1((int)v12, (int)&a3, retaddr);
  qmemcpy(v13, v12, 0x80u);
  while ( 1 )
  {
    result = uw_frame_state_for((int)v13, (unsigned int)v10);
    if ( result == 5 )
      break;
    if ( result )
      return 3;
    if ( v11 )
    {
      v3 = v11(1, 1, *a3, a3[1], a3, v13);
      if ( v3 == 6 )
      {
        v5 = v13[24];
        a3[3] = 0;
        a3[4] = v13[18] - (v5 >> 31);
        qmemcpy(v13, v12, 0x80u);
        result = Unwind_RaiseException_Phase2(a3, (int)v13);
        if ( result == 7 )
        {
          v7 = uw_install_context_1((int)v12, (int)v13, v6);
          v8 = v13[19];
          v9 = v7;
          Unwind_DebugHook(v13[18], v13[19]);
          *(int *)((char *)&retaddr + v9) = v8;
          return v14;
        }
        return result;
      }
      if ( v3 != 8 )
        return 3;
    }
    uw_update_context((int)v13, (int)v10);
  }
  return result;
}
// 80C2AFD: variable 'v6' is possibly undefined
// 80C29C0: using guessed type int __cdecl Unwind_DebugHook(_DWORD, _DWORD);

//----- (080C2B40) --------------------------------------------------------
int __usercall Unwind_ForcedUnwind@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3, int a4, int a5)
{
  _DWORD *v5; // edx
  int result; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // edi
  int v10; // esi
  char v11[128]; // [esp+20h] [ebp-118h] BYREF
  int v12[33]; // [esp+A0h] [ebp-98h] BYREF
  int v13; // [esp+124h] [ebp-14h]
  int v14; // [esp+128h] [ebp-10h]
  int retaddr; // [esp+13Ch] [ebp+4h]

  v13 = a1;
  v14 = a2;
  uw_init_context_1((int)v11, (int)&a3, retaddr);
  qmemcpy(v12, v11, 0x80u);
  v5 = a3;
  a3[3] = a4;
  v5[4] = a5;
  result = Unwind_ForcedUnwind_Phase2(a3, (int)v12);
  if ( result == 7 )
  {
    v8 = uw_install_context_1((int)v11, (int)v12, v7);
    v9 = v12[19];
    v10 = v8;
    Unwind_DebugHook(v12[18], v12[19]);
    *(int *)((char *)&retaddr + v10) = v9;
    return v13;
  }
  return result;
}
// 80C2BC6: variable 'v7' is possibly undefined
// 80C29C0: using guessed type int __cdecl Unwind_DebugHook(_DWORD, _DWORD);

//----- (080C2C00) --------------------------------------------------------
void __usercall __noreturn Unwind_Resume(int a1@<eax>, int a2@<edx>, _DWORD *a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  int v7; // edi
  int v8; // esi
  char v9[128]; // [esp+8h] [ebp-118h] BYREF
  int v10[35]; // [esp+88h] [ebp-98h] BYREF
  int retaddr; // [esp+124h] [ebp+4h]

  v10[34] = a2;
  v10[33] = a1;
  uw_init_context_1((int)v9, (int)&a3, retaddr);
  qmemcpy(v10, v9, 0x80u);
  if ( a3[3] )
    v3 = Unwind_ForcedUnwind_Phase2(a3, (int)v10);
  else
    v3 = Unwind_RaiseException_Phase2(a3, (int)v10);
  if ( v3 != 7 )
    abort(v5, v4);
  v6 = uw_install_context_1((int)v9, (int)v10, v5);
  v7 = v10[19];
  v8 = v6;
  Unwind_DebugHook(v10[18], v10[19]);
  *(int *)((char *)&retaddr + v8) = v7;
}
// 80C2C70: variable 'v5' is possibly undefined
// 80C2C70: variable 'v4' is possibly undefined
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);
// 80C29C0: using guessed type int __cdecl Unwind_DebugHook(_DWORD, _DWORD);

//----- (080C2CD0) --------------------------------------------------------
void __usercall __noreturn Unwind_Resume_or_Rethrow(int a1@<eax>, int a2@<edx>, _DWORD *a3)
{
  int v3; // esi
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  int v7; // edi
  int v8; // esi
  char v9[128]; // [esp+20h] [ebp-118h] BYREF
  int v10[35]; // [esp+A0h] [ebp-98h] BYREF
  int retaddr; // [esp+13Ch] [ebp+4h]

  v10[33] = a1;
  v3 = a3[3];
  v10[34] = a2;
  if ( v3 )
  {
    uw_init_context_1((int)v9, (int)&a3, retaddr);
    qmemcpy(v10, v9, 0x80u);
    if ( Unwind_ForcedUnwind_Phase2(a3, (int)v10) != 7 )
      abort(v5, v4);
    v6 = uw_install_context_1((int)v9, (int)v10, v5);
    v7 = v10[19];
    v8 = v6;
    Unwind_DebugHook(v10[18], v10[19]);
    *(int *)((char *)&retaddr + v8) = v7;
  }
  else
  {
    Unwind_RaiseException((int)a3, a2, a3);
  }
}
// 80C2D5E: variable 'v5' is possibly undefined
// 80C2D5E: variable 'v4' is possibly undefined
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);
// 80C29C0: using guessed type int __cdecl Unwind_DebugHook(_DWORD, _DWORD);

//----- (080C2DB0) --------------------------------------------------------
int (__cdecl *__cdecl Unwind_DeleteException(int a1))(int, int)
{
  int (__cdecl *result)(int, int); // eax

  result = *(int (__cdecl **)(int, int))(a1 + 8);
  if ( result )
    return (int (__cdecl *)(int, int))result(1, a1);
  return result;
}

//----- (080C2DD0) --------------------------------------------------------
int __cdecl Unwind_Backtrace(int (__cdecl *a1)(char *, int), int a2)
{
  int v2; // edi
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v7; // [esp+1Ch] [ebp-14Ch]
  char v8[192]; // [esp+20h] [ebp-148h] BYREF
  char v9[136]; // [esp+E0h] [ebp-88h] BYREF
  int retaddr; // [esp+16Ch] [ebp+4h]

  v2 = a2;
  uw_init_context_1((int)v9, (int)&a1, retaddr);
  while ( 1 )
  {
    v5 = uw_frame_state_for((int)v9, (unsigned int)v8);
    if ( v5 != 5 )
    {
      if ( v5 )
        break;
    }
    v7 = v5;
    v3 = a1(v9, v2);
    v4 = v7;
    if ( v3 )
      break;
    if ( v7 == 5 )
      return v4;
    uw_update_context((int)v9, (int)v8);
  }
  return 3;
}

//----- (080C2E60) --------------------------------------------------------
int __usercall frame_downheap@<eax>(int result@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3, int a4, int a5)
{
  int v5; // ecx
  int v6; // edx
  int v7; // edi
  int i; // esi
  int *v9; // ebp
  int *v10; // edi
  int v11; // eax
  int v12; // [esp+10h] [ebp-1Ch]
  int v13; // [esp+10h] [ebp-1Ch]
  int v14; // [esp+14h] [ebp-18h]
  int v15; // [esp+18h] [ebp-14h]

  v5 = a4;
  v6 = a3;
  v15 = result;
  v7 = 2 * a4 + 1;
  if ( v7 < a5 )
  {
    i = 2 * a4 + 2;
    v9 = (int *)(a3 + 4 * v7);
    if ( a5 > i )
      goto LABEL_7;
LABEL_3:
    for ( i = v7; ; v9 = (int *)(v13 + 4 * i) )
    {
      v10 = (int *)(v6 + 4 * v5);
      v12 = v6;
      result = a2(v15, *v10, *v9);
      v6 = v12;
      if ( result >= 0 )
        break;
      result = *v10;
      *v10 = *v9;
      v7 = 2 * i + 1;
      *v9 = result;
      if ( a5 <= v7 )
        break;
      v5 = i;
      i = 2 * i + 2;
      v9 = (int *)(v12 + 4 * v7);
      if ( a5 <= v7 + 1 )
        goto LABEL_3;
LABEL_7:
      v13 = v6;
      v14 = v5;
      v11 = a2(v15, *v9, *(_DWORD *)(v6 + 4 * i));
      v6 = v13;
      v5 = v14;
      if ( v11 >= 0 )
        goto LABEL_3;
    }
  }
  return result;
}

//----- (080C2F20) --------------------------------------------------------
unsigned int __usercall frame_heapsort@<eax>(int a1@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3)
{
  int v3; // edi
  unsigned int result; // eax
  int v5; // ebp
  int v6; // esi
  int v7; // edi
  int i; // esi
  int v9; // eax
  int v10; // [esp+8h] [ebp-24h]
  unsigned int v13; // [esp+18h] [ebp-14h]

  v3 = a3;
  result = *(_DWORD *)(a3 + 4);
  v5 = a3 + 8;
  v6 = (result >> 1) - 1;
  v13 = result;
  if ( v6 >= 0 )
  {
    v7 = *(_DWORD *)(a3 + 4);
    do
      result = frame_downheap(a1, a2, v5, v6--, v7);
    while ( v6 >= 0 );
    v3 = a3;
  }
  for ( i = v13 - 1; i > 0; result = frame_downheap(a1, a2, v5, 0, v10) )
  {
    v9 = *(_DWORD *)(v3 + 8);
    *(_DWORD *)(v3 + 8) = *(_DWORD *)(v3 + 4 * i + 8);
    *(_DWORD *)(v3 + 4 * i + 8) = v9;
    v10 = i--;
  }
  return result;
}

//----- (080C2FC0) --------------------------------------------------------
int __usercall size_of_encoded_value@<eax>(char a1@<al>)
{
  int v1; // eax

  if ( a1 == -1 )
    return 0;
  v1 = a1 & 7;
  if ( v1 == 2 )
    return 2;
  if ( v1 <= 2 )
  {
    if ( v1 )
LABEL_6:
      abort();
    return 4;
  }
  if ( v1 == 3 )
    return 4;
  if ( v1 != 4 )
    goto LABEL_6;
  return 8;
}
// 805ACB0: using guessed type void __noreturn abort(void);

//----- (080C3030) --------------------------------------------------------
char *__usercall read_encoded_value_with_base_0@<eax>(char a1@<al>, char *a2@<edx>, char *a3, unsigned int *a4)
{
  unsigned int v4; // esi
  char *v5; // ebp
  unsigned int v7; // edi
  int v8; // ecx
  char v9; // si
  char v10; // dl
  int v11; // eax
  unsigned int v12; // ecx
  char v13; // dl
  char v14; // di
  int v15; // eax
  _DWORD *v16; // ebp
  char v17; // [esp+4h] [ebp-28h]
  unsigned __int16 *v18; // [esp+8h] [ebp-24h]
  char v19; // [esp+8h] [ebp-24h]
  unsigned __int16 *v20; // [esp+Ch] [ebp-20h]

  if ( a1 == 80 )
  {
    v16 = (_DWORD *)((unsigned int)(a3 + 3) & 0xFFFFFFFC);
    v4 = *v16;
    v5 = (char *)(v16 + 1);
  }
  else
  {
    v17 = a1;
    switch ( a1 & 0xF )
    {
      case 0:
      case 3:
      case 0xB:
        v4 = *(_DWORD *)a3;
        v5 = a3 + 4;
        break;
      case 1:
        v7 = 0;
        v8 = 0;
        v18 = (unsigned __int16 *)a2;
        v5 = a3;
        v9 = a1;
        do
        {
          v10 = *v5++;
          v11 = (v10 & 0x7F) << v8;
          v8 += 7;
          v7 |= v11;
        }
        while ( v10 < 0 );
        a1 = v9;
        a2 = (char *)v18;
        v4 = v7;
        break;
      case 2:
        v4 = *(unsigned __int16 *)a3;
        v5 = a3 + 2;
        break;
      case 4:
      case 0xC:
        v4 = *(_DWORD *)a3;
        v5 = a3 + 8;
        break;
      case 9:
        v4 = 0;
        v12 = 0;
        v19 = a1;
        v20 = (unsigned __int16 *)a2;
        v5 = a3;
        do
        {
          v13 = *v5++;
          v14 = v13;
          v15 = (v13 & 0x7F) << v12;
          v12 += 7;
          v4 |= v15;
        }
        while ( v13 < 0 );
        a1 = v19;
        a2 = (char *)v20;
        if ( v12 <= 0x1F && (v14 & 0x40) != 0 )
          v4 |= -1 << v12;
        break;
      case 0xA:
        v4 = *(__int16 *)a3;
        v5 = a3 + 2;
        break;
      default:
        abort();
    }
    if ( v4 )
    {
      if ( (v17 & 0x70) == 16 )
        a2 = a3;
      v4 += (unsigned int)a2;
      if ( a1 < 0 )
        v4 = *(_DWORD *)v4;
    }
  }
  *a4 = v4;
  return v5;
}
// 805ACB0: using guessed type void __noreturn abort(void);

//----- (080C31F0) --------------------------------------------------------
int __usercall get_cie_encoding@<eax>(_BYTE *a1@<eax>)
{
  char v2; // di
  int v3; // ecx
  char *v4; // edx
  int result; // eax
  char *v6; // eax
  char *v7; // ecx
  char *encoded_value_with_base_0; // eax
  char v10; // dl
  char *v11; // esi
  char *i; // edx
  unsigned int v13[8]; // [esp+1Ch] [ebp-20h] BYREF

  v2 = a1[8];
  v3 = strlen(a1 + 9) + 1;
  v4 = &a1[v3 + 9];
  if ( a1[8] > 3u )
  {
    result = 255;
    if ( a1[v3 + 9] != 4 || a1[v3 + 10] )
      return result;
    v4 = &a1[v3 + 11];
  }
  result = 0;
  if ( a1[9] == 122 )
  {
    while ( 1 )
    {
      v6 = v4 + 1;
      if ( *v4 >= 0 )
        break;
      ++v4;
    }
    v7 = v4 + 2;
    if ( *v6 < 0 )
    {
      do
        v6 = v7;
      while ( *v7++ < 0 );
    }
    if ( v2 == 1 )
    {
      for ( i = v6 + 2; ; i = encoded_value_with_base_0 )
      {
        encoded_value_with_base_0 = i + 1;
        if ( *i >= 0 )
          break;
LABEL_13:
        ;
      }
    }
    else
    {
      while ( *v7 < 0 )
        ++v7;
      encoded_value_with_base_0 = v7 + 2;
      if ( v7[1] < 0 )
        goto LABEL_13;
    }
    v10 = a1[10];
    v11 = a1 + 10;
    if ( v10 == 82 )
    {
      return (unsigned __int8)*encoded_value_with_base_0;
    }
    else
    {
      while ( 1 )
      {
        while ( v10 == 80 )
        {
          ++v11;
          encoded_value_with_base_0 = read_encoded_value_with_base_0(
                                        *encoded_value_with_base_0 & 0x7F,
                                        0,
                                        encoded_value_with_base_0 + 1,
                                        v13);
          v10 = *v11;
          if ( *v11 == 82 )
            return (unsigned __int8)*encoded_value_with_base_0;
        }
        if ( v10 != 76 )
          break;
        ++v11;
        ++encoded_value_with_base_0;
        v10 = *v11;
        if ( *v11 == 82 )
          return (unsigned __int8)*encoded_value_with_base_0;
      }
      return 0;
    }
  }
  return result;
}
// 80C31F0: using guessed type unsigned int var_20[8];

//----- (080C3330) --------------------------------------------------------
int __cdecl fde_unencoded_compare(int a1, int a2, int a3)
{
  int result; // eax

  result = 1;
  if ( *(_DWORD *)(a2 + 8) <= *(_DWORD *)(a3 + 8) )
    return -(*(_DWORD *)(a2 + 8) < *(_DWORD *)(a3 + 8));
  return result;
}

//----- (080C3370) --------------------------------------------------------
int __usercall base_from_object_isra_3@<eax>(char a1@<al>, int a2@<edx>, int a3)
{
  int v3; // eax

  if ( a1 == -1 )
    return 0;
  v3 = a1 & 0x70;
  if ( v3 == 32 )
    return *(_DWORD *)a2;
  if ( v3 <= 32 )
  {
    if ( v3 && v3 != 16 )
      abort();
    return 0;
  }
  if ( v3 != 48 )
  {
    if ( v3 != 80 )
      abort();
    return 0;
  }
  return *(_DWORD *)a3;
}
// 805ACB0: using guessed type void __noreturn abort(void);

//----- (080C33E0) --------------------------------------------------------
int __usercall classify_object_over_fdes@<eax>(int a1@<eax>, char *a2@<edx>)
{
  char *v3; // esi
  unsigned int v4; // eax
  int v5; // edx
  int v6; // eax
  char *v7; // edi
  int cie_encoding; // eax
  unsigned __int16 v9; // ax
  char *v11; // [esp+1Ch] [ebp-30h]
  unsigned __int8 v12; // [esp+1Ch] [ebp-30h]
  char v13; // [esp+20h] [ebp-2Ch]
  int v14; // [esp+24h] [ebp-28h]
  char *v15; // [esp+28h] [ebp-24h]
  int v16; // [esp+2Ch] [ebp-20h]
  unsigned int v17[4]; // [esp+3Ch] [ebp-10h] BYREF

  v3 = a2;
  v16 = 0;
  if ( *(_DWORD *)a2 )
  {
    v15 = 0;
    LOBYTE(v14) = 0;
    v11 = 0;
    do
    {
      v6 = *((_DWORD *)v3 + 1);
      if ( v6 )
      {
        v7 = &v3[-v6 + 4];
        if ( v11 == v7 )
        {
          v13 = v14;
          read_encoded_value_with_base_0(v14, v15, v3 + 8, v17);
        }
        else
        {
          cie_encoding = get_cie_encoding(&v3[-v6 + 4]);
          v14 = cie_encoding;
          if ( cie_encoding == 255 )
            return -1;
          v12 = cie_encoding;
          v13 = cie_encoding;
          v15 = (char *)base_from_object_isra_3(cie_encoding, a1 + 4, a1 + 8);
          v9 = *(_WORD *)(a1 + 16);
          if ( (v9 & 0x7F8) == 2040 )
          {
            *(_WORD *)(a1 + 16) = (8 * v12) | v9 & 0xF807;
            v11 = v7;
          }
          else
          {
            v11 = v7;
            if ( v14 != (unsigned __int8)(v9 >> 3) )
              *(_BYTE *)(a1 + 16) |= 4u;
          }
          read_encoded_value_with_base_0(v13, v15, v3 + 8, v17);
        }
        v4 = size_of_encoded_value(v13);
        v5 = -1;
        if ( v4 <= 3 )
          v5 = (1 << (8 * v4)) - 1;
        if ( (v17[0] & v5) != 0 )
        {
          ++v16;
          if ( v17[0] < *(_DWORD *)a1 )
            *(_DWORD *)a1 = v17[0];
        }
      }
      v3 += *(_DWORD *)v3 + 4;
    }
    while ( *(_DWORD *)v3 );
  }
  return v16;
}

//----- (080C3540) --------------------------------------------------------
int __usercall add_fdes@<eax>(int a1@<eax>, int *a2@<edx>, _DWORD *a3)
{
  _DWORD *v4; // esi
  __int16 v5; // ax
  int result; // eax
  int v7; // eax
  int v8; // edx
  int v9; // eax
  char *v10; // edi
  unsigned int v11; // eax
  int v12; // edx
  int cie_encoding; // [esp+18h] [ebp-34h]
  char *v14; // [esp+1Ch] [ebp-30h]
  char *v15; // [esp+20h] [ebp-2Ch]
  int v16; // [esp+28h] [ebp-24h]
  unsigned int v18[4]; // [esp+3Ch] [ebp-10h] BYREF

  v16 = a1 + 8;
  v4 = a3;
  v5 = *(_WORD *)(a1 + 16) >> 3;
  cie_encoding = (unsigned __int8)v5;
  v14 = (char *)base_from_object_isra_3(v5, a1 + 4, a1 + 8);
  result = *a3;
  if ( *a3 )
  {
    v15 = 0;
    while ( 1 )
    {
      v9 = v4[1];
      if ( !v9 )
        goto LABEL_6;
      if ( (*(_BYTE *)(a1 + 16) & 4) != 0 )
      {
        v10 = (char *)v4 - v9 + 4;
        if ( v15 != v10 )
        {
          cie_encoding = get_cie_encoding((_BYTE *)v4 - v9 + 4);
          v15 = v10;
          v14 = (char *)base_from_object_isra_3(cie_encoding, a1 + 4, v16);
        }
      }
      if ( cie_encoding )
      {
        read_encoded_value_with_base_0(cie_encoding, v14, (char *)v4 + 8, v18);
        v11 = size_of_encoded_value(cie_encoding);
        v12 = -1;
        if ( v11 <= 3 )
          v12 = (1 << (8 * v11)) - 1;
        if ( (v12 & v18[0]) != 0 )
        {
LABEL_4:
          v7 = *a2;
          if ( *a2 )
          {
            v8 = *(_DWORD *)(v7 + 4);
            *(_DWORD *)(v7 + 4 * v8 + 8) = v4;
            *(_DWORD *)(v7 + 4) = v8 + 1;
          }
          goto LABEL_6;
        }
        result = *v4;
        v4 = (_DWORD *)((char *)v4 + *v4 + 4);
        if ( !*v4 )
          return result;
      }
      else
      {
        v18[0] = v4[2];
        if ( v18[0] )
          goto LABEL_4;
LABEL_6:
        result = *v4;
        v4 = (_DWORD *)((char *)v4 + *v4 + 4);
        if ( !*v4 )
          return result;
      }
    }
  }
  return result;
}
// 80C3540: using guessed type unsigned int var_10[4];

//----- (080C3680) --------------------------------------------------------
int __cdecl fde_single_encoding_compare(int a1, int a2, int a3)
{
  char v3; // di
  char *v4; // ebp
  int result; // eax
  unsigned int v6; // [esp+18h] [ebp-14h] BYREF
  unsigned int v7; // [esp+1Ch] [ebp-10h] BYREF

  v3 = *(_WORD *)(a1 + 16) >> 3;
  v4 = (char *)base_from_object_isra_3(v3, a1 + 4, a1 + 8);
  read_encoded_value_with_base_0(v3, v4, (char *)(a2 + 8), &v6);
  read_encoded_value_with_base_0(*(_WORD *)(a1 + 16) >> 3, v4, (char *)(a3 + 8), &v7);
  result = 1;
  if ( v6 <= v7 )
    return -(v6 < v7);
  return result;
}

//----- (080C3720) --------------------------------------------------------
int __usercall linear_search_fdes@<eax>(int a1@<eax>, int a2@<edx>, int a3)
{
  int cie_encoding; // ebp
  unsigned int v5; // edx
  int v6; // eax
  int v7; // edi
  char *v8; // eax
  unsigned int v9; // eax
  int v10; // edx
  int v13; // [esp+20h] [ebp-2Ch]
  char *v14; // [esp+24h] [ebp-28h]
  int v15; // [esp+28h] [ebp-24h]
  int v16; // [esp+2Ch] [ebp-20h]
  unsigned int v17; // [esp+38h] [ebp-14h] BYREF
  unsigned int v18[4]; // [esp+3Ch] [ebp-10h] BYREF

  v15 = a1 + 4;
  cie_encoding = (unsigned __int8)(*(_WORD *)(a1 + 16) >> 3);
  v16 = a1 + 8;
  v14 = (char *)base_from_object_isra_3(*(_WORD *)(a1 + 16) >> 3, a1 + 4, a1 + 8);
  if ( *(_DWORD *)a2 )
  {
    v13 = 0;
    do
    {
      v6 = *(_DWORD *)(a2 + 4);
      if ( v6 )
      {
        if ( (*(_BYTE *)(a1 + 16) & 4) != 0 )
        {
          v7 = a2 + 4 - v6;
          if ( v13 != v7 )
          {
            cie_encoding = get_cie_encoding((_BYTE *)(a2 + 4 - v6));
            v13 = v7;
            v14 = (char *)base_from_object_isra_3(cie_encoding, v15, v16);
          }
        }
        if ( cie_encoding )
        {
          v8 = read_encoded_value_with_base_0(cie_encoding, v14, (char *)(a2 + 8), &v17);
          read_encoded_value_with_base_0(cie_encoding & 0xF, 0, v8, v18);
          v9 = size_of_encoded_value(cie_encoding);
          v10 = -1;
          if ( v9 <= 3 )
            v10 = (1 << (8 * v9)) - 1;
          if ( (v17 & v10) != 0 && a3 - v17 < v18[0] )
            return a2;
        }
        else
        {
          v5 = *(_DWORD *)(a2 + 12);
          v17 = *(_DWORD *)(a2 + 8);
          v18[0] = v5;
          if ( v17 && a3 - v17 < v5 )
            return a2;
        }
      }
      a2 += *(_DWORD *)a2 + 4;
    }
    while ( *(_DWORD *)a2 );
  }
  return 0;
}
// 80C3720: using guessed type unsigned int var_10[4];

//----- (080C3880) --------------------------------------------------------
int __usercall base_from_cb_data_isra_4@<eax>(char a1@<al>, int a2@<edx>, int a3)
{
  int v3; // eax

  if ( a1 == -1 )
    return 0;
  v3 = a1 & 0x70;
  if ( v3 == 32 )
    return *(_DWORD *)a2;
  if ( v3 <= 32 )
  {
    if ( v3 && v3 != 16 )
      abort();
    return 0;
  }
  if ( v3 != 48 )
  {
    if ( v3 != 80 )
      abort();
    return 0;
  }
  return *(_DWORD *)a3;
}
// 805ACB0: using guessed type void __noreturn abort(void);

//----- (080C38F0) --------------------------------------------------------
int __usercall search_object@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  char v2; // dl
  unsigned int v4; // eax
  _DWORD *v5; // eax
  int v6; // ebp
  int v7; // eax
  _DWORD **v8; // esi
  _DWORD *v9; // eax
  int (__cdecl *v10)(int, int, int); // eax
  int v11; // edi
  int v12; // eax
  int v13; // ecx
  int v14; // edx
  int v15; // ebp
  int *i; // esi
  int v17; // eax
  int v18; // eax
  int v19; // esi
  int v20; // edx
  int j; // eax
  int v22; // ecx
  _DWORD *v23; // ecx
  int v24; // eax
  _DWORD *v25; // ebp
  int v26; // edi
  int v27; // esi
  _DWORD *v28; // eax
  char **v29; // esi
  char *v30; // edx
  unsigned int v31; // edi
  int v32; // ebp
  int v33; // eax
  int v34; // esi
  int *v35; // edi
  int v36; // edx
  int v37; // eax
  unsigned int v39; // ecx
  unsigned int v40; // edi
  char cie_encoding; // bp
  char *v42; // eax
  char *v43; // eax
  unsigned __int16 v44; // ax
  int v45; // ebp
  unsigned int v46; // edx
  unsigned int v47; // ecx
  unsigned int v48; // eax
  int v49; // eax
  int v50; // eax
  unsigned int v51; // ebp
  unsigned int v52; // edi
  unsigned int v53; // esi
  char *v54; // eax
  int v55; // [esp+10h] [ebp-5Ch]
  unsigned int v56; // [esp+10h] [ebp-5Ch]
  int v57; // [esp+10h] [ebp-5Ch]
  int (__cdecl *v59)(int, int, int); // [esp+18h] [ebp-54h]
  unsigned int v60; // [esp+18h] [ebp-54h]
  char v61; // [esp+18h] [ebp-54h]
  int v62; // [esp+1Ch] [ebp-50h]
  int v63; // [esp+20h] [ebp-4Ch]
  _DWORD *v64; // [esp+20h] [ebp-4Ch]
  int v65; // [esp+20h] [ebp-4Ch]
  int v66; // [esp+20h] [ebp-4Ch]
  int v67; // [esp+24h] [ebp-48h]
  int v68; // [esp+24h] [ebp-48h]
  unsigned int v70; // [esp+2Ch] [ebp-40h]
  int v71; // [esp+2Ch] [ebp-40h]
  char *v72; // [esp+2Ch] [ebp-40h]
  _DWORD *v73; // [esp+3Ch] [ebp-30h] BYREF
  int v74; // [esp+40h] [ebp-2Ch]
  unsigned int v75; // [esp+44h] [ebp-28h] BYREF
  unsigned int v76; // [esp+48h] [ebp-24h] BYREF
  unsigned int v77; // [esp+4Ch] [ebp-20h]

  v2 = *(_BYTE *)(a1 + 16);
  if ( (v2 & 1) != 0 )
    goto LABEL_55;
  v4 = *(_DWORD *)(a1 + 16);
  v70 = v4 >> 11;
  if ( v4 >> 11 )
  {
LABEL_3:
    v5 = (_DWORD *)malloc(4 * v70 + 8);
    v6 = (int)v5;
    v73 = v5;
    if ( !v5 )
      goto LABEL_46;
    v5[1] = 0;
    v7 = malloc(4 * v70 + 8);
    v74 = v7;
    if ( v7 )
      *(_DWORD *)(v7 + 4) = 0;
    if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
    {
      v8 = *(_DWORD ***)(a1 + 12);
      v9 = *v8;
      if ( !*v8 )
        goto LABEL_10;
      do
      {
        ++v8;
        add_fdes(a1, (int *)&v73, v9);
        v9 = *v8;
      }
      while ( *v8 );
    }
    else
    {
      add_fdes(a1, (int *)&v73, *(_DWORD **)(a1 + 12));
    }
    v6 = (int)v73;
    if ( !v73 )
    {
LABEL_11:
      v59 = fde_mixed_encoding_compare;
      if ( (*(_BYTE *)(a1 + 16) & 4) == 0 )
      {
        v10 = fde_single_encoding_compare;
        if ( (*(_WORD *)(a1 + 16) & 0x7F8) == 0 )
          v10 = fde_unencoded_compare;
        v59 = v10;
      }
      v11 = v74;
      if ( !v74 )
      {
        frame_heapsort(a1, v59, v6);
LABEL_39:
        v28 = v73;
        *v73 = *(_DWORD *)(a1 + 12);
        *(_DWORD *)(a1 + 12) = v28;
        *(_BYTE *)(a1 + 16) |= 1u;
        goto LABEL_46;
      }
      v67 = *(_DWORD *)(v6 + 4);
      if ( v67 )
      {
        v12 = 0;
        v13 = v6 + 8;
        v14 = v6;
        v15 = 1;
        v63 = v13;
        for ( *(_DWORD *)(v74 + 8) = &marker_7846; v15 != v67; *(_DWORD *)(v11 + 4 * v12 + 8) = i )
        {
          for ( i = (int *)(v14 + 4 * v12 + 8); i != (int *)&marker_7846; *(_DWORD *)(v11 + 4 * v17 + 8) = 0 )
          {
            v55 = v14;
            v18 = v59(a1, *(_DWORD *)(v14 + 4 * v15 + 8), *i);
            v14 = v55;
            if ( v18 >= 0 )
              break;
            v17 = ((int)i - v63) >> 2;
            i = *(int **)(v11 + 4 * v17 + 8);
          }
          v12 = v15++;
        }
        v6 = v14;
        v19 = 0;
        v20 = 0;
        for ( j = 0; j != v67; ++j )
        {
          while ( 1 )
          {
            v22 = *(_DWORD *)(v6 + 4 * j + 8);
            if ( !*(_DWORD *)(v11 + 4 * j + 8) )
              break;
            *(_DWORD *)(v6 + 4 * v20 + 8) = v22;
            ++j;
            ++v20;
            if ( j == v67 )
              goto LABEL_27;
          }
          *(_DWORD *)(v11 + 4 * v19++ + 8) = v22;
        }
LABEL_27:
        v23 = v73;
        v24 = v74;
      }
      else
      {
        v24 = v74;
        v23 = (_DWORD *)v6;
        v19 = 0;
        v20 = 0;
      }
      *(_DWORD *)(v6 + 4) = v20;
      *(_DWORD *)(v11 + 4) = v19;
      if ( v70 == v23[1] + *(_DWORD *)(v24 + 4) )
      {
        frame_heapsort(a1, v59, v24);
        v25 = v73;
        v71 = v74;
        v68 = *(_DWORD *)(v74 + 4);
        if ( v68 )
        {
          v26 = v73[1];
          v64 = &v73[v68];
          do
          {
            --v68;
            v62 = *(_DWORD *)(v71 + 4 * v68 + 8);
            if ( v26 )
            {
              while ( v59(a1, v25[v26 + 1], v62) > 0 )
              {
                v64[v26 + 1] = v25[v26 + 1];
                if ( v26 == 1 )
                {
                  v26 = 0;
                  break;
                }
                --v26;
              }
            }
            --v64;
            v25[v26 + 2 + v68] = v62;
          }
          while ( v68 );
          v27 = v74;
          v25[1] += *(_DWORD *)(v71 + 4);
          v71 = v27;
        }
        free(v71);
        goto LABEL_39;
      }
LABEL_91:
      abort();
    }
LABEL_10:
    if ( v70 != *(_DWORD *)(v6 + 4) )
      goto LABEL_91;
    goto LABEL_11;
  }
  if ( (v2 & 2) != 0 )
  {
    v29 = *(char ***)(a1 + 12);
    v30 = *v29;
    if ( !*v29 )
    {
      *(_DWORD *)(a1 + 16) = v4 & 0x7FF;
      goto LABEL_46;
    }
    v31 = 0;
    v32 = a1;
    do
    {
      v33 = classify_object_over_fdes(v32, v30);
      if ( v33 == -1 )
        goto LABEL_45;
      ++v29;
      v31 += v33;
      v30 = *v29;
    }
    while ( *v29 );
    v70 = v31;
  }
  else
  {
    v70 = classify_object_over_fdes(a1, *(char **)(a1 + 12));
    if ( v70 == -1 )
    {
LABEL_45:
      *(_DWORD *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 16) = 2040;
      *(_DWORD *)(a1 + 12) = &terminator_7952;
      goto LABEL_46;
    }
  }
  v49 = (v70 << 11) | *(_DWORD *)(a1 + 16) & 0x7FF;
  *(_DWORD *)(a1 + 16) = v49;
  if ( v70 != (v70 & 0x1FFFFF) )
    *(_DWORD *)(a1 + 16) = v49 & 0x7FF;
  if ( v70 )
    goto LABEL_3;
LABEL_46:
  v34 = 0;
  if ( *(_DWORD *)a1 > a2 )
    return v34;
  v2 = *(_BYTE *)(a1 + 16);
  if ( (v2 & 1) == 0 )
  {
    if ( (*(_BYTE *)(a1 + 16) & 2) == 0 )
      return linear_search_fdes(a1, *(_DWORD *)(a1 + 12), a2);
    v35 = *(int **)(a1 + 12);
    v36 = *v35;
    if ( *v35 )
    {
      do
      {
        v37 = linear_search_fdes(a1, v36, a2);
        if ( v37 )
          break;
        v36 = *++v35;
      }
      while ( *v35 );
      return v37;
    }
    return v34;
  }
LABEL_55:
  if ( (v2 & 4) != 0 )
  {
    v34 = 0;
    v39 = *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4);
    v65 = *(_DWORD *)(a1 + 12);
    if ( !v39 )
      return v34;
    v60 = 0;
    do
    {
      while ( 1 )
      {
        v40 = (v39 + v60) >> 1;
        v34 = *(_DWORD *)(v65 + 4 * v40 + 8);
        v56 = v39;
        cie_encoding = get_cie_encoding((_BYTE *)(v34 + 4 - *(_DWORD *)(v34 + 4)));
        v42 = (char *)base_from_object_isra_3(cie_encoding, a1 + 4, a1 + 8);
        v43 = read_encoded_value_with_base_0(cie_encoding, v42, (char *)(v34 + 8), &v75);
        read_encoded_value_with_base_0(cie_encoding & 0xF, 0, v43, &v76);
        v39 = v56;
        if ( a2 >= v75 )
          break;
        v39 = v40;
        if ( v60 >= v40 )
          return 0;
      }
      if ( a2 < v76 + v75 )
        return v34;
      v60 = v40 + 1;
    }
    while ( v40 + 1 < v56 );
  }
  else
  {
    v44 = *(_WORD *)(a1 + 16);
    if ( (v44 & 0x7F8) != 0 )
    {
      v34 = 0;
      v61 = v44 >> 3;
      v66 = *(_DWORD *)(a1 + 12);
      v50 = base_from_object_isra_3(v61, a1 + 4, a1 + 8);
      v51 = *(_DWORD *)(v66 + 4);
      v72 = (char *)v50;
      if ( !v51 )
        return v34;
      v52 = 0;
      while ( 1 )
      {
        v53 = (v52 + v51) >> 1;
        v57 = *(_DWORD *)(v66 + 4 * v53 + 8);
        v54 = read_encoded_value_with_base_0(v61, v72, (char *)(v57 + 8), &v76);
        read_encoded_value_with_base_0(v61 & 0xF, 0, v54, &v75);
        if ( a2 >= v76 )
        {
          if ( a2 < v75 + v76 )
            return v57;
          v52 = v53 + 1;
        }
        else
        {
          v51 = (v52 + v51) >> 1;
        }
        if ( v52 >= v51 )
          return 0;
      }
    }
    v45 = *(_DWORD *)(a1 + 12);
    v34 = 0;
    v46 = *(_DWORD *)(v45 + 4);
    if ( !v46 )
      return v34;
    v47 = 0;
    do
    {
      v48 = (v46 + v47) >> 1;
      v34 = *(_DWORD *)(v45 + 4 * v48 + 8);
      v77 = *(_DWORD *)(v34 + 8);
      v76 = *(_DWORD *)(v34 + 12);
      if ( a2 >= v77 )
      {
        if ( a2 < v76 + v77 )
          return v34;
        v47 = v48 + 1;
      }
      else
      {
        v46 = (v46 + v47) >> 1;
      }
    }
    while ( v46 > v47 );
  }
  return 0;
}
// 804E3D0: using guessed type _DWORD __cdecl malloc(_DWORD);
// 804E820: using guessed type _DWORD __cdecl free(_DWORD);
// 805ACB0: using guessed type void __noreturn abort(void);

//----- (080C3FB0) --------------------------------------------------------
int __cdecl fde_mixed_encoding_compare(int a1, int a2, int a3)
{
  char cie_encoding; // bp
  char *v4; // eax
  char v5; // si
  char *v6; // eax
  int result; // eax
  unsigned int v8; // [esp+28h] [ebp-14h] BYREF
  unsigned int v9[4]; // [esp+2Ch] [ebp-10h] BYREF

  cie_encoding = get_cie_encoding((_BYTE *)(a2 + 4 - *(_DWORD *)(a2 + 4)));
  v4 = (char *)base_from_object_isra_3(cie_encoding, a1 + 4, a1 + 8);
  read_encoded_value_with_base_0(cie_encoding, v4, (char *)(a2 + 8), &v8);
  v5 = get_cie_encoding((_BYTE *)(a3 + 4 - *(_DWORD *)(a3 + 4)));
  v6 = (char *)base_from_object_isra_3(v5, a1 + 4, a1 + 8);
  read_encoded_value_with_base_0(v5, v6, (char *)(a3 + 8), v9);
  result = 1;
  if ( v8 <= v9[0] )
    return -(v8 < v9[0]);
  return result;
}
// 80C3FB0: using guessed type unsigned int var_10[4];

//----- (080C4060) --------------------------------------------------------
int __cdecl Unwind_IteratePhdrCallback(int *a1, unsigned int a2, int *a3)
{
  _DWORD *v3; // eax
  int v4; // edx
  _DWORD *v5; // ecx
  int v6; // edx
  int v7; // esi
  int v8; // edx
  _DWORD *v9; // ecx
  int v10; // esi
  unsigned int v11; // edi
  unsigned int v12; // ebp
  int v13; // esi
  int v14; // esi
  _BYTE *v15; // ebp
  int v17; // edx
  unsigned int v18; // ebp
  int v19; // eax
  char v20; // di
  char *v21; // eax
  char *encoded_value_with_base_0; // ecx
  char v23; // al
  int v24; // eax
  int v25; // eax
  int v26; // eax
  char cie_encoding; // di
  char *v28; // eax
  char v29; // di
  char *v30; // eax
  char *v31; // edi
  char *v32; // esi
  unsigned int v33; // ecx
  unsigned int v34; // edx
  unsigned int v35; // eax
  unsigned int v36; // eax
  int v37; // eax
  char v38; // al
  char v39; // di
  int v40; // eax
  _BYTE *v41; // ebp
  char *v42; // [esp+1Ch] [ebp-70h]
  _BYTE *v43; // [esp+1Ch] [ebp-70h]
  __int64 v44; // [esp+20h] [ebp-6Ch]
  int v45; // [esp+20h] [ebp-6Ch]
  int v46; // [esp+20h] [ebp-6Ch]
  int v47; // [esp+20h] [ebp-6Ch]
  _DWORD *v48; // [esp+24h] [ebp-68h]
  unsigned int v49; // [esp+28h] [ebp-64h]
  int v50; // [esp+28h] [ebp-64h]
  unsigned int v51; // [esp+28h] [ebp-64h]
  unsigned int v52; // [esp+2Ch] [ebp-60h]
  unsigned int v53; // [esp+30h] [ebp-5Ch]
  unsigned int *v54; // [esp+34h] [ebp-58h]
  int v55; // [esp+38h] [ebp-54h]
  int v56[4]; // [esp+4Ch] [ebp-40h] BYREF
  int v57; // [esp+5Ch] [ebp-30h]
  int v58; // [esp+64h] [ebp-28h] BYREF
  unsigned int v59; // [esp+68h] [ebp-24h] BYREF
  unsigned int v60[8]; // [esp+6Ch] [ebp-20h] BYREF

  v3 = (_DWORD *)a1[2];
  v49 = *a1;
  if ( a2 <= 0x1F || !a3[5] )
  {
    if ( a2 <= 0xD )
      return -1;
    goto LABEL_8;
  }
  v4 = a1[4];
  v44 = *((_QWORD *)a1 + 3);
  if ( *((_QWORD *)a1 + 2) != adds_8108 || subs_8109 != *((_QWORD *)a1 + 3) )
  {
    HIDWORD(adds_8108) = a1[5];
    LODWORD(adds_8108) = v4;
    subs_8109 = v44;
    v5 = &frame_hdr_cache;
    v6 = 1;
    do
    {
      v7 = 3 * v6++;
      *v5 = 0;
      v5[1] = 0;
      v5[5] = (char *)&frame_hdr_cache + 8 * v7;
      v5 += 6;
    }
    while ( v6 != 9 );
    dword_80F111C = 0;
    frame_hdr_cache_head = (int)&frame_hdr_cache;
    v54 = 0;
    a3[5] = 0;
    v55 = 0;
LABEL_9:
    v8 = *((unsigned __int16 *)a1 + 6) - 1;
    if ( !*((_WORD *)a1 + 6) )
      return 0;
    v53 = 0;
    v9 = 0;
    v52 = 0;
    v45 = 0;
    v48 = 0;
    while ( 1 )
    {
      v10 = *v3;
      if ( *v3 != 1 )
        break;
      v11 = v3[2] + v49;
      if ( v11 > *a3 )
      {
LABEL_14:
        --v8;
        v3 += 8;
        if ( v8 == -1 )
          goto LABEL_20;
      }
      else
      {
        v12 = v11 + v3[5];
        v13 = 1;
        if ( *a3 >= v12 )
        {
          v11 = v52;
          v13 = v45;
          v12 = v53;
        }
        --v8;
        v3 += 8;
        v52 = v11;
        v53 = v12;
        v45 = v13;
        if ( v8 == -1 )
        {
LABEL_20:
          if ( v45 )
          {
            if ( a2 > 0x1F )
            {
              if ( v55 && v54 )
              {
                *(_DWORD *)(v55 + 20) = v54[5];
                v19 = frame_hdr_cache_head;
                frame_hdr_cache_head = (int)v54;
                v54[5] = v19;
              }
              else
              {
                v54 = (unsigned int *)frame_hdr_cache_head;
              }
              v54[2] = v49;
              v54[3] = (unsigned int)v48;
              v54[4] = (unsigned int)v9;
              *v54 = v52;
              v54[1] = v53;
            }
            goto LABEL_26;
          }
          return 0;
        }
      }
    }
    if ( v10 == 1685382480 )
    {
      v48 = v3;
    }
    else if ( v10 == 2 )
    {
      v9 = v3;
    }
    goto LABEL_14;
  }
  v46 = frame_hdr_cache_head;
  if ( !frame_hdr_cache_head )
  {
LABEL_8:
    v54 = 0;
    v55 = 0;
    goto LABEL_9;
  }
  v17 = frame_hdr_cache_head;
  v55 = 0;
  v18 = *a3;
  while ( *(_DWORD *)v17 > v18 || *(_DWORD *)(v17 + 4) <= v18 )
  {
    if ( !*(_QWORD *)v17 || !*(_DWORD *)(v17 + 20) )
    {
      v54 = (unsigned int *)v17;
      goto LABEL_9;
    }
    v55 = v17;
    v17 = *(_DWORD *)(v17 + 20);
  }
  v49 = *(_DWORD *)(v17 + 8);
  v48 = *(_DWORD **)(v17 + 12);
  if ( frame_hdr_cache_head != v17 )
  {
    v37 = *(_DWORD *)(v17 + 20);
    frame_hdr_cache_head = v17;
    *(_DWORD *)(v55 + 20) = v37;
    *(_DWORD *)(v17 + 20) = v46;
  }
LABEL_26:
  if ( !v48 )
    return 0;
  v14 = 1;
  v15 = (_BYTE *)(v48[2] + v49);
  if ( *v15 != 1 )
    return v14;
  v20 = v15[1];
  v50 = (int)(a3 + 1);
  v47 = (int)(a3 + 2);
  v21 = (char *)base_from_cb_data_isra_4(v20, (int)(a3 + 1), (int)(a3 + 2));
  encoded_value_with_base_0 = read_encoded_value_with_base_0(v20, v21, v15 + 4, (unsigned int *)&v58);
  v23 = v15[2];
  if ( v23 == -1 || v15[3] != 59 )
    goto LABEL_43;
  v29 = v15[2];
  v42 = encoded_value_with_base_0;
  v30 = (char *)base_from_cb_data_isra_4(v23, v50, v47);
  v31 = read_encoded_value_with_base_0(v29, v30, v42, &v59);
  if ( !v59 )
    return v14;
  if ( ((unsigned __int8)v31 & 3) != 0 )
  {
LABEL_43:
    v14 = 1;
    v57 = 0;
    v56[0] = 0;
    v24 = a3[1];
    v56[3] = v58;
    v56[1] = v24;
    v25 = a3[2];
    LOBYTE(v57) = 4;
    v56[2] = v25;
    v26 = linear_search_fdes((int)v56, v58, *a3);
    a3[4] = v26;
    if ( v26 )
    {
      cie_encoding = get_cie_encoding((_BYTE *)(v26 + 4 - *(_DWORD *)(v26 + 4)));
      v28 = (char *)base_from_cb_data_isra_4(cie_encoding, v50, v47);
      read_encoded_value_with_base_0(cie_encoding, v28, (char *)(a3[4] + 8), v60);
      a3[3] = v60[0];
    }
    return v14;
  }
  v51 = *a3;
  if ( *a3 < (unsigned int)&v15[*(_DWORD *)v31] )
    return v14;
  v32 = &v31[8 * v59 - 8];
  if ( *a3 >= (unsigned int)&v15[*(_DWORD *)v32] )
    goto LABEL_59;
  if ( v59 == 1 )
    goto LABEL_63;
  v33 = v59 - 1;
  v34 = 0;
  while ( 1 )
  {
    v36 = (v34 + v33) >> 1;
    v32 = &v31[8 * v36];
    if ( v51 < (unsigned int)&v15[*(_DWORD *)v32] )
    {
      v33 = (v34 + v33) >> 1;
      goto LABEL_54;
    }
    v35 = v36 + 1;
    if ( v51 < (unsigned int)&v15[*(_DWORD *)&v31[8 * v35]] )
      break;
    v34 = v35;
LABEL_54:
    if ( v34 >= v33 )
      goto LABEL_63;
  }
  if ( v33 <= v34 )
LABEL_63:
    abort();
LABEL_59:
  v43 = &v15[*((_DWORD *)v32 + 1)];
  v38 = get_cie_encoding(&v43[-*((_DWORD *)v43 + 1) + 4]);
  v39 = v38 & 0xF;
  v40 = size_of_encoded_value(v38);
  read_encoded_value_with_base_0(v39, 0, &v43[v40 + 8], v60);
  v41 = &v15[*(_DWORD *)v32];
  if ( *a3 < (unsigned int)&v41[v60[0]] )
    a3[4] = (int)v43;
  v14 = 1;
  a3[3] = (int)v41;
  return v14;
}
// 805ACB0: using guessed type void __noreturn abort(void);
// 80EFC78: using guessed type __int64 adds_8108;
// 80F1040: using guessed type __int64 subs_8109;
// 80F1048: using guessed type int frame_hdr_cache_head;
// 80F111C: using guessed type int dword_80F111C;

//----- (080C45C0) --------------------------------------------------------
int __cdecl _register_frame_info_bases(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  int result; // eax

  result = (int)a1;
  if ( a1 )
  {
    if ( *a1 )
    {
      a2[4] = 0;
      *a2 = -1;
      a2[1] = a3;
      a2[3] = a1;
      *((_WORD *)a2 + 8) = 2040;
      a2[2] = a4;
      result = unseen_objects;
      unseen_objects = (int)a2;
      a2[5] = result;
    }
  }
  return result;
}
// 80F1038: using guessed type int unseen_objects;

//----- (080C4660) --------------------------------------------------------
int __cdecl _register_frame_info(_DWORD *a1, _DWORD *a2)
{
  return _register_frame_info_bases(a1, a2, 0, 0);
}

//----- (080C4690) --------------------------------------------------------
void __usercall _register_frame(long double a1@<st0>, _DWORD *a2)
{
  _DWORD *v2; // eax

  if ( *a2 )
  {
    malloc(a1, 0x18u);
    _register_frame_info(a2, v2);
  }
}
// 80C46C3: variable 'v2' is possibly undefined

//----- (080C46E0) --------------------------------------------------------
int __cdecl _register_frame_info_table_bases(int a1, _DWORD *a2, int a3, int a4)
{
  int result; // eax

  a2[1] = a3;
  a2[4] = 0;
  *a2 = -1;
  a2[2] = a4;
  *((_BYTE *)a2 + 16) = 2;
  *((_WORD *)a2 + 8) |= 0x7F8u;
  a2[3] = a1;
  result = unseen_objects;
  unseen_objects = (int)a2;
  a2[5] = result;
  return result;
}
// 80F1038: using guessed type int unseen_objects;

//----- (080C4780) --------------------------------------------------------
int __cdecl _register_frame_info_table(int a1, _DWORD *a2)
{
  return _register_frame_info_table_bases(a1, a2, 0, 0);
}

//----- (080C47B0) --------------------------------------------------------
int __usercall _register_frame_table@<eax>(long double a1@<st0>, int a2)
{
  _DWORD *v2; // eax

  malloc(a1, 0x18u);
  return _register_frame_info_table(a2, v2);
}
// 80C47D6: variable 'v2' is possibly undefined

//----- (080C47E0) --------------------------------------------------------
int __usercall _deregister_frame_info_bases@<eax>(_DWORD *a1@<edx>, int a2@<ecx>, long double a3@<st0>, _DWORD *a4)
{
  int v4; // esi
  int *v6; // eax

  if ( !a4 || !*a4 )
    return 0;
  v4 = unseen_objects;
  if ( unseen_objects )
  {
    if ( *(_DWORD **)(unseen_objects + 12) == a4 )
    {
      v6 = &unseen_objects;
LABEL_14:
      a1 = *(_DWORD **)(v4 + 20);
      *v6 = (int)a1;
      goto LABEL_15;
    }
    while ( 1 )
    {
      v6 = (int *)(v4 + 20);
      v4 = *(_DWORD *)(v4 + 20);
      if ( !v4 )
        break;
      if ( *(_DWORD **)(v4 + 12) == a4 )
        goto LABEL_14;
    }
  }
  v4 = seen_objects;
  if ( !seen_objects )
    goto LABEL_15;
  v6 = &seen_objects;
  while ( (*(_BYTE *)(v4 + 16) & 1) == 0 )
  {
    if ( *(_DWORD **)(v4 + 12) == a4 )
      goto LABEL_14;
LABEL_11:
    v6 = (int *)(v4 + 20);
    v4 = *(_DWORD *)(v4 + 20);
    if ( !v4 )
      goto LABEL_15;
  }
  a1 = *(_DWORD **)(v4 + 12);
  if ( (_DWORD *)*a1 != a4 )
    goto LABEL_11;
  *v6 = *(_DWORD *)(v4 + 20);
  free(a3, *(_DWORD *)(v4 + 12));
LABEL_15:
  if ( !v4 )
    abort(a2, a1);
  return v4;
}
// 80C48D2: variable 'a2' is possibly undefined
// 80C48D2: variable 'a1' is possibly undefined
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);
// 80F1038: using guessed type int unseen_objects;
// 80F103C: using guessed type int seen_objects;

//----- (080C48F0) --------------------------------------------------------
void __usercall _deregister_frame(int a1@<ecx>, long double a2@<st0>, _DWORD *a3)
{
  int v3; // eax

  if ( *a3 )
  {
    v3 = _deregister_frame_info_bases((_DWORD *)*a3, a1, a2, a3);
    free(a2, v3);
  }
}

//----- (080C4920) --------------------------------------------------------
int __cdecl Unwind_Find_FDE(unsigned int a1, _DWORD *a2)
{
  int v2; // esi
  int v3; // ebp
  char cie_encoding; // al
  char v5; // di
  char *v6; // eax
  int v8; // eax
  _DWORD *v9; // edx
  int *v10; // ecx
  unsigned int v11; // [esp+14h] [ebp-38h] BYREF
  int v12; // [esp+18h] [ebp-34h]
  int v13; // [esp+1Ch] [ebp-30h]
  int v14; // [esp+20h] [ebp-2Ch]
  int v15; // [esp+24h] [ebp-28h]
  int v16; // [esp+28h] [ebp-24h]
  unsigned int v17[8]; // [esp+2Ch] [ebp-20h] BYREF

  v2 = seen_objects;
  if ( !seen_objects )
    goto LABEL_12;
  while ( a1 < *(_DWORD *)v2 )
  {
    v2 = *(_DWORD *)(v2 + 20);
    if ( !v2 )
      goto LABEL_12;
  }
  v3 = search_object(v2, a1);
  if ( !v3 )
  {
LABEL_12:
    while ( 1 )
    {
      v2 = unseen_objects;
      if ( !unseen_objects )
        break;
      unseen_objects = *(_DWORD *)(unseen_objects + 20);
      v8 = search_object(v2, a1);
      v9 = (_DWORD *)seen_objects;
      v10 = &seen_objects;
      if ( seen_objects && *(_DWORD *)v2 <= *(_DWORD *)seen_objects )
      {
        while ( 1 )
        {
          v10 = v9 + 5;
          v9 = (_DWORD *)v9[5];
          if ( !v9 )
            break;
          if ( *(_DWORD *)v2 > *v9 )
            goto LABEL_11;
        }
        *(_DWORD *)(v2 + 20) = 0;
        *v10 = v2;
        if ( v8 )
        {
LABEL_19:
          v3 = v8;
          goto LABEL_6;
        }
      }
      else
      {
LABEL_11:
        *(_DWORD *)(v2 + 20) = v9;
        *v10 = v2;
        if ( v8 )
          goto LABEL_19;
      }
    }
    v3 = 0;
  }
LABEL_6:
  if ( v3 )
  {
    *a2 = *(_DWORD *)(v2 + 4);
    a2[1] = *(_DWORD *)(v2 + 8);
    cie_encoding = *(_WORD *)(v2 + 16) >> 3;
    if ( (*(_BYTE *)(v2 + 16) & 4) != 0 )
      cie_encoding = get_cie_encoding((_BYTE *)(v3 + 4 - *(_DWORD *)(v3 + 4)));
    v5 = cie_encoding;
    v6 = (char *)base_from_object_isra_3(cie_encoding, v2 + 4, v2 + 8);
    read_encoded_value_with_base_0(v5, v6, (char *)(v3 + 8), v17);
    a2[2] = v17[0];
  }
  else
  {
    v11 = a1;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 1;
    if ( dl_iterate_phdr((int (__cdecl *)(int *, int, int))Unwind_IteratePhdrCallback, (int)&v11) >= 0 )
    {
      v3 = v15;
      if ( v15 )
      {
        *a2 = v12;
        a2[1] = v13;
        a2[2] = v14;
      }
    }
  }
  return v3;
}
// 80F1038: using guessed type int unseen_objects;
// 80F103C: using guessed type int seen_objects;
// 80C4920: using guessed type unsigned int var_20[8];

//----- (080C4AF0) --------------------------------------------------------
char *__usercall read_encoded_value_with_base_1@<eax>(char a1@<al>, char *a2@<edx>, char *a3, unsigned int *a4)
{
  unsigned int v4; // esi
  char *v5; // ebp
  unsigned int v7; // edi
  int v8; // ecx
  char v9; // si
  char v10; // dl
  int v11; // eax
  unsigned int v12; // ecx
  char v13; // dl
  char v14; // di
  int v15; // eax
  _DWORD *v16; // ebp
  char v17; // [esp+4h] [ebp-28h]
  unsigned __int16 *v18; // [esp+8h] [ebp-24h]
  char v19; // [esp+8h] [ebp-24h]
  unsigned __int16 *v20; // [esp+Ch] [ebp-20h]

  if ( a1 == 80 )
  {
    v16 = (_DWORD *)((unsigned int)(a3 + 3) & 0xFFFFFFFC);
    v4 = *v16;
    v5 = (char *)(v16 + 1);
  }
  else
  {
    v17 = a1;
    switch ( a1 & 0xF )
    {
      case 0:
      case 3:
      case 0xB:
        v4 = *(_DWORD *)a3;
        v5 = a3 + 4;
        break;
      case 1:
        v7 = 0;
        v8 = 0;
        v18 = (unsigned __int16 *)a2;
        v5 = a3;
        v9 = a1;
        do
        {
          v10 = *v5++;
          v11 = (v10 & 0x7F) << v8;
          v8 += 7;
          v7 |= v11;
        }
        while ( v10 < 0 );
        a1 = v9;
        a2 = (char *)v18;
        v4 = v7;
        break;
      case 2:
        v4 = *(unsigned __int16 *)a3;
        v5 = a3 + 2;
        break;
      case 4:
      case 0xC:
        v4 = *(_DWORD *)a3;
        v5 = a3 + 8;
        break;
      case 9:
        v4 = 0;
        v12 = 0;
        v19 = a1;
        v20 = (unsigned __int16 *)a2;
        v5 = a3;
        do
        {
          v13 = *v5++;
          v14 = v13;
          v15 = (v13 & 0x7F) << v12;
          v12 += 7;
          v4 |= v15;
        }
        while ( v13 < 0 );
        a1 = v19;
        a2 = (char *)v20;
        if ( v12 <= 0x1F && (v14 & 0x40) != 0 )
          v4 |= -1 << v12;
        break;
      case 0xA:
        v4 = *(__int16 *)a3;
        v5 = a3 + 2;
        break;
      default:
        abort(a1 & 0xF, a2);
    }
    if ( v4 )
    {
      if ( (v17 & 0x70) == 16 )
        a2 = a3;
      v4 += (unsigned int)a2;
      if ( a1 < 0 )
        v4 = *(_DWORD *)v4;
    }
  }
  *a4 = v4;
  return v5;
}
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);

//----- (080C4CB0) --------------------------------------------------------
int __cdecl _gcc_personality_v0(int a1, char a2, int a3, int a4, int a5, int a6)
{
  int v6; // esi
  int v8; // ecx
  unsigned __int8 *LanguageSpecificData; // edi
  int RegionStart; // eax
  int v11; // edx
  char *encoded_value_with_base_1; // edi
  char v13; // si
  int v14; // eax
  char *TextRelBase; // edx
  char v16; // al
  char *v17; // edi
  int v18; // esi
  int v19; // ecx
  char v20; // dl
  int v21; // eax
  char v22; // al
  int v23; // esi
  char *v24; // edi
  int v25; // ecx
  char v26; // dl
  int v27; // eax
  char *v28; // ebp
  unsigned int i; // eax
  char v30; // si
  int v31; // eax
  char *DataRelBase; // edx
  char *v33; // ebp
  char v34; // si
  int v35; // eax
  char *v36; // edx
  char *v37; // ebp
  char v38; // si
  int v39; // eax
  char *v40; // edx
  char *j; // eax
  int v42; // edi
  unsigned int v43; // [esp+1Ch] [ebp-50h]
  int v44; // [esp+2Ch] [ebp-40h]
  int v45; // [esp+30h] [ebp-3Ch] BYREF
  char *v46; // [esp+38h] [ebp-34h]
  char *v47; // [esp+3Ch] [ebp-30h]
  char v48; // [esp+40h] [ebp-2Ch]
  char v49; // [esp+41h] [ebp-2Bh]
  unsigned int v50; // [esp+44h] [ebp-28h] BYREF
  unsigned int v51; // [esp+48h] [ebp-24h] BYREF
  unsigned int v52[4]; // [esp+4Ch] [ebp-20h] BYREF

  v6 = 3;
  if ( a1 != 1 )
    return v6;
  LOWORD(v6) = 8;
  if ( (a2 & 2) == 0 )
    return v6;
  LanguageSpecificData = (unsigned __int8 *)Unwind_GetLanguageSpecificData(a6);
  if ( !LanguageSpecificData )
    return v6;
  RegionStart = 0;
  if ( a6 )
    RegionStart = Unwind_GetRegionStart(a6);
  v44 = RegionStart;
  v11 = *LanguageSpecificData;
  encoded_value_with_base_1 = (char *)(LanguageSpecificData + 1);
  if ( (_BYTE)v11 != 0xFF )
  {
    v13 = v11;
    v14 = v11 & 0x70;
    if ( v14 == 32 )
    {
      TextRelBase = (char *)Unwind_GetTextRelBase(a6);
      goto LABEL_57;
    }
    if ( (v11 & 0x70u) > 0x20 )
    {
      switch ( v14 )
      {
        case '@':
          TextRelBase = (char *)Unwind_GetRegionStart(a6);
          goto LABEL_57;
        case 'P':
          goto LABEL_12;
        case '0':
          TextRelBase = (char *)Unwind_GetDataRelBase(a6);
          goto LABEL_57;
      }
    }
    else if ( (v11 & 0x70) == 0 || v14 == 16 )
    {
LABEL_12:
      TextRelBase = 0;
LABEL_57:
      encoded_value_with_base_1 = read_encoded_value_with_base_1(
                                    v13,
                                    TextRelBase,
                                    encoded_value_with_base_1,
                                    (unsigned int *)&v45);
      goto LABEL_14;
    }
LABEL_35:
    abort(v8, v11);
  }
  v45 = RegionStart;
LABEL_14:
  v16 = *encoded_value_with_base_1;
  v17 = encoded_value_with_base_1 + 1;
  v48 = v16;
  if ( v16 == -1 )
  {
    v46 = 0;
  }
  else
  {
    v18 = 0;
    v19 = 0;
    do
    {
      v20 = *v17++;
      v21 = (v20 & 0x7F) << v19;
      v19 += 7;
      v18 |= v21;
    }
    while ( v20 < 0 );
    v46 = &v17[v18];
  }
  v22 = *v17;
  v23 = 0;
  v24 = v17 + 1;
  v25 = 0;
  v49 = v22;
  do
  {
    v26 = *v24++;
    v27 = (v26 & 0x7F) << v25;
    v25 += 7;
    v23 |= v27;
  }
  while ( v26 < 0 );
  v28 = v24;
  v47 = &v24[v23];
  v43 = Unwind_GetIP(a6) - 1;
  for ( i = (unsigned int)v47; ; i = (unsigned int)v47 )
  {
    while ( 1 )
    {
      if ( (unsigned int)v28 >= i )
        return 8;
      v30 = v49;
      if ( v49 == -1 )
        goto LABEL_26;
      v31 = v49 & 0x70;
      if ( v31 == 32 )
      {
        DataRelBase = (char *)Unwind_GetTextRelBase(0);
      }
      else
      {
        if ( (v49 & 0x70u) <= 0x20 )
        {
          if ( (v49 & 0x70) != 0 && v31 != 16 )
            goto LABEL_35;
LABEL_26:
          DataRelBase = 0;
          goto LABEL_27;
        }
        switch ( v31 )
        {
          case '@':
            DataRelBase = (char *)Unwind_GetRegionStart(0);
            break;
          case 'P':
            goto LABEL_26;
          case '0':
            DataRelBase = (char *)Unwind_GetDataRelBase(0);
            break;
          default:
            goto LABEL_35;
        }
      }
LABEL_27:
      v33 = read_encoded_value_with_base_1(v30, DataRelBase, v28, &v50);
      v34 = v49;
      if ( v49 == -1 )
        goto LABEL_31;
      v35 = v49 & 0x70;
      if ( v35 == 32 )
      {
        v36 = (char *)Unwind_GetTextRelBase(0);
      }
      else if ( (v49 & 0x70u) > 0x20 )
      {
        switch ( v35 )
        {
          case '@':
            v36 = (char *)Unwind_GetRegionStart(0);
            break;
          case 'P':
LABEL_31:
            v36 = 0;
            break;
          case '0':
            v36 = (char *)Unwind_GetDataRelBase(0);
            break;
          default:
            goto LABEL_35;
        }
      }
      else
      {
        if ( (v49 & 0x70) == 0 )
          goto LABEL_31;
        if ( v35 != 16 )
          goto LABEL_35;
        v36 = 0;
      }
      v37 = read_encoded_value_with_base_1(v34, v36, v33, &v51);
      v38 = v49;
      if ( v49 == -1 )
        goto LABEL_45;
      v39 = v49 & 0x70;
      if ( v39 == 32 )
      {
        v40 = (char *)Unwind_GetTextRelBase(0);
        goto LABEL_46;
      }
      if ( (v49 & 0x70u) <= 0x20 )
      {
        if ( (v49 & 0x70) != 0 && v39 != 16 )
          goto LABEL_35;
LABEL_45:
        v40 = 0;
        goto LABEL_46;
      }
      if ( v39 == 64 )
      {
        v40 = (char *)Unwind_GetRegionStart(0);
        goto LABEL_46;
      }
      if ( v39 == 80 )
        goto LABEL_45;
      if ( v39 != 48 )
        goto LABEL_35;
      v40 = (char *)Unwind_GetDataRelBase(0);
LABEL_46:
      for ( j = read_encoded_value_with_base_1(v38, v40, v37, v52); ; ++j )
      {
        v28 = j + 1;
        if ( *j >= 0 )
          break;
      }
      if ( v43 >= v44 + v50 )
        break;
      v28 = v47;
      i = (unsigned int)v47;
    }
    if ( v43 < v51 + v44 + v50 )
      break;
  }
  v6 = 8;
  if ( v52[0] )
  {
    v42 = v45 + v52[0];
    if ( v45 + v52[0] )
    {
      v6 = 7;
      Unwind_SetGR(a6, 0, a5);
      Unwind_SetGR(a6, 2, 0);
      Unwind_SetIP(a6, v42);
    }
  }
  return v6;
}
// 80C4E78: variable 'v8' is possibly undefined
// 80C4E78: variable 'v11' is possibly undefined
// 805ACB0: using guessed type void __fastcall __noreturn abort(_DWORD, _DWORD);
// 80C4CB0: using guessed type unsigned int var_20[4];

//----- (080C5140) --------------------------------------------------------
int cancel_handler_0()
{
  return 0;
}
// 80C5151: control flows out of bounds to 0

//----- (080C5160) --------------------------------------------------------
int __cdecl _dl_iterate_phdr(int (__cdecl *a1)(int *, int, int), int a2)
{
  int v2; // ebx
  int v3; // esi
  int v4; // eax
  int v5; // eax
  int v6; // edx
  int v7; // edx
  __int64 v9; // [esp+18h] [ebp-54h]
  int v10[3]; // [esp+28h] [ebp-44h] BYREF
  __int16 v11; // [esp+34h] [ebp-38h]
  __int64 v12; // [esp+38h] [ebp-34h]
  __int64 v13; // [esp+40h] [ebp-2Ch]
  int addr_soft; // [esp+4Ch] [ebp-20h]

  v2 = dl_ns[0];
  v3 = 0;
  if ( dl_ns[0] )
  {
    v9 = (unsigned int)dword_80F1204[0];
    do
    {
      v5 = *(_DWORD *)(v2 + 20);
      v10[0] = *(_DWORD *)v5;
      v6 = *(_DWORD *)(v5 + 4);
      v12 = dl_load_adds;
      v10[1] = v6;
      v7 = *(_DWORD *)(v5 + 336);
      v13 = dl_load_adds - v9;
      addr_soft = 0;
      v10[2] = v7;
      v11 = *(_WORD *)(v5 + 344);
      if ( *(_DWORD *)(v5 + 580) )
        addr_soft = dl_tls_get_addr_soft(v5);
      v4 = a1(v10, 40, a2);
      if ( v4 )
        break;
      v2 = *(_DWORD *)(v2 + 12);
    }
    while ( v2 );
    return v4;
  }
  return v3;
}
// 80F1198: using guessed type __int64 dl_load_adds;
// 80F1200: using guessed type int dl_ns[];
// 80F1204: using guessed type int dword_80F1204[];

//----- (080C5270) --------------------------------------------------------
int __cdecl dl_iterate_phdr(int (__cdecl *a1)(int *, int, int), int a2)
{
  int result; // eax
  int v3[3]; // [esp+18h] [ebp-44h] BYREF
  __int16 v4; // [esp+24h] [ebp-38h]
  __int64 v5; // [esp+28h] [ebp-34h]
  __int64 v6; // [esp+30h] [ebp-2Ch]

  if ( !dl_phnum )
    return _dl_iterate_phdr(a1, a2);
  v4 = dl_phnum;
  v3[0] = 0;
  v3[2] = dl_phdr;
  v3[1] = (int)&unk_80C86D9;
  v5 = dl_load_adds;
  v6 = dl_load_adds - (unsigned int)dword_80F1204[0];
  result = a1(v3, 40, a2);
  if ( !result )
    return _dl_iterate_phdr(a1, a2);
  return result;
}
// 80F1198: using guessed type __int64 dl_load_adds;
// 80F11BC: using guessed type int dl_phdr;
// 80F11E0: using guessed type int dl_phnum;
// 80F1204: using guessed type int dword_80F1204[];

//----- (080C5320) --------------------------------------------------------
void (*_do_global_ctors_aux())(void)
{
  void (*result)(void); // eax
  void (**v1)(void); // ebx

  result = (void (*)(void))_CTOR_LIST__;
  if ( _CTOR_LIST__ != -1 )
  {
    v1 = (void (**)(void))&_CTOR_LIST__;
    do
    {
      --v1;
      result();
      result = *v1;
    }
    while ( *v1 != (void (*)(void))-1 );
  }
  return result;
}
// 80EEFA8: using guessed type int _CTOR_LIST__;

//----- (080C5350) --------------------------------------------------------
void arena_thread_freeres()
{
  unsigned int v0; // edx
  bool v2; // zf
  int v3; // eax

  v0 = __readgsdword(0xFFFFFFEC);
  __writegsdword(0xFFFFFFEC, 0);
  if ( v0 )
  {
    _ECX = 1;
    v2 = __readgsdword(0xCu) == 0;
    if ( !v2 )
      __asm { lock }
    __asm { cmpxchg ds:list_lock, ecx }
    if ( v2 )
    {
      v3 = free_list;
      free_list = v0;
      *(_DWORD *)(v0 + 1092) = v3;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --list_lock )
        L_unlock_151();
    }
    else
    {
      L_lock_145(0);
    }
  }
}
// 80F0594: using guessed type int free_list;
// 80F0598: using guessed type int list_lock;

//----- (080C53A5) --------------------------------------------------------
void __usercall L_lock_145(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &list_lock);
  JUMPOUT(0x80C537E);
}
// 80C53B0: control flows out of bounds to 80C537E
// 80F0598: using guessed type int list_lock;

//----- (080C53B2) --------------------------------------------------------
void L_unlock_151()
{
  _lll_unlock_wake_private(&list_lock);
  JUMPOUT(0x80C53A3);
}
// 80C53BD: control flows out of bounds to 80C53A3
// 80F0598: using guessed type int list_lock;

//----- (080C53C0) --------------------------------------------------------
void __usercall free_mem(long double a1@<st0>)
{
  bool v2; // zf
  _DWORD *v3; // ebx
  _DWORD *v4; // esi

  _ECX = 1;
  v2 = __readgsdword(0xCu) == 0;
  if ( !v2 )
    __asm { lock }
  __asm { cmpxchg ds:__fork_lock, ecx }
  if ( v2 )
  {
    v3 = (_DWORD *)fork_handler_pool;
    _fork_handlers = 0;
    memset(&fork_handler_pool, 0, 0x544u);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --_fork_lock )
    {
      L_unlock_30();
    }
    else if ( v3 )
    {
      while ( 1 )
      {
        v4 = (_DWORD *)*v3;
        free(a1, (int)v3);
        if ( !v4 )
          break;
        v3 = v4;
      }
    }
  }
  else
  {
    L_lock_19(0);
  }
}
// 80F0660: using guessed type int _fork_lock;
// 80F0680: using guessed type int fork_handler_pool;
// 80F12F8: using guessed type int _fork_handlers;

//----- (080C5437) --------------------------------------------------------
void __usercall L_lock_19(int a1@<eax>)
{
  _lll_lock_wait_private(a1, &_fork_lock);
  JUMPOUT(0x80C53E3);
}
// 80C5442: control flows out of bounds to 80C53E3
// 80F0660: using guessed type int _fork_lock;

//----- (080C5444) --------------------------------------------------------
void L_unlock_30()
{
  _lll_unlock_wake_private(&_fork_lock);
  JUMPOUT(0x80C5417);
}
// 80C544F: control flows out of bounds to 80C5417
// 80F0660: using guessed type int _fork_lock;

//----- (080C5460) --------------------------------------------------------
void __usercall free_mem_0(long double a1@<st0>)
{
  int *i; // ebx
  int *v2; // eax
  int v3; // ebx

  for ( i = (int *)nl_domain_bindings; nl_domain_bindings; i = (int *)nl_domain_bindings )
  {
    nl_domain_bindings = *i;
    if ( (char *)i[1] != "/usr/share/locale" )
      free(a1, i[1]);
    free(a1, i[2]);
    free(a1, (int)i);
  }
  if ( nl_current_default_domain[0] != "messages" )
    free(a1, (int)nl_current_default_domain[0]);
  tdestroy((_DWORD *)root, (long double (__cdecl *)(_DWORD))free);
  v2 = (int *)transmem_list;
  root = 0;
  if ( transmem_list )
  {
    while ( 1 )
    {
      transmem_list = *v2;
      v3 = transmem_list;
      free(a1, (int)v2);
      if ( !v3 )
        break;
      v2 = (int *)v3;
    }
  }
}
// 80EF5C8: using guessed type char *nl_current_default_domain[2];
// 80F0C40: using guessed type int root;
// 80F0C50: using guessed type int transmem_list;
// 80F1294: using guessed type int nl_domain_bindings;

//----- (080C5510) --------------------------------------------------------
void __usercall nl_finddomain_subfreeres(long double a1@<st0>)
{
  int *v1; // ebx
  int *v2; // eax
  int *v3; // esi

  v1 = (int *)nl_loaded_domains;
  if ( nl_loaded_domains )
  {
    while ( 1 )
    {
      v2 = (int *)v1[2];
      if ( v2 )
        nl_unload_domain(v2, a1);
      v3 = (int *)v1[3];
      free(a1, *v1);
      free(a1, (int)v1);
      if ( !v3 )
        break;
      v1 = v3;
    }
  }
}
// 80F0C80: using guessed type int nl_loaded_domains;

//----- (080C5560) --------------------------------------------------------
void __usercall nl_unload_domain(int *a1@<eax>, long double a2@<st0>)
{
  _DWORD *v3; // eax
  int v4; // esi
  unsigned int v5; // ebx
  int *v6; // eax
  int *v7; // ebp
  int v8; // eax

  v3 = (_DWORD *)a1[24];
  if ( v3 != (_DWORD *)&_gettext_germanic_plural )
    _gettext_free_exp(v3);
  if ( a1[15] )
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v7 = (int *)(v4 + a1[14]);
      free(a2, *v7);
      v8 = v7[2];
      if ( (unsigned int)(v8 - 1) <= 0xFFFFFFFD )
        free(a2, v8);
      v6 = (int *)v7[1];
      if ( v6 != (int *)-1 )
        _gconv_close(v6, a2);
      ++v5;
      v4 += 12;
    }
    while ( a1[15] > v5 );
  }
  free(a2, a1[14]);
  free(a2, a1[4]);
  if ( a1[1] )
    munmap(*a1, a1[2]);
  else
    free(a2, *a1);
  free(a2, (int)a1);
}

//----- (080C5640) --------------------------------------------------------
void __usercall free_mem_1(long double a1@<st0>)
{
  clearenv(a1);
  tdestroy((_DWORD *)known_values, (long double (__cdecl *)(_DWORD))free);
  known_values = 0;
}
// 80F0CC8: using guessed type int known_values;

//----- (080C5670) --------------------------------------------------------
void __usercall free_mem_2(long double a1@<st0>)
{
  int v1; // edx
  int i; // esi
  _DWORD *v3; // eax
  _DWORD *v4; // ebx

  v1 = _printf_modifier_table;
  if ( _printf_modifier_table )
  {
    for ( i = 0; i != 1020; i += 4 )
    {
      v3 = *(_DWORD **)(v1 + i);
      if ( v3 )
      {
        while ( 1 )
        {
          v4 = (_DWORD *)*v3;
          free(a1, (int)v3);
          if ( !v4 )
            break;
          v3 = v4;
        }
        v1 = _printf_modifier_table;
      }
    }
    free(a1, v1);
  }
}
// 80F12A0: using guessed type int _printf_modifier_table;

//----- (080C56D0) --------------------------------------------------------
int buffer_free()
{
  int result; // eax

  result = freeres_list;
  for ( dealloc_buffers = 1; freeres_list; result = freeres_list )
  {
    munmap(*(_DWORD *)(result + 96), (*(_DWORD *)(result + 100) + 4095) & 0xFFFFF000);
    freeres_list = *(_DWORD *)(freeres_list + 92);
  }
  return result;
}
// 80F0CF0: using guessed type char dealloc_buffers;
// 80F0CF4: using guessed type int freeres_list;

//----- (080C5720) --------------------------------------------------------
void __usercall free_mem_3(long double a1@<st0>)
{
  int *v1; // eax
  int v2; // ebx

  v1 = (int *)tzstring_list;
  if ( tzstring_list )
  {
    while ( 1 )
    {
      tzstring_list = *v1;
      v2 = tzstring_list;
      free(a1, (int)v1);
      if ( !v2 )
        break;
      v1 = (int *)v2;
    }
  }
  free(a1, (int)old_tz);
  old_tz = 0;
}
// 80F0D48: using guessed type int tzstring_list;

//----- (080C5770) --------------------------------------------------------
void __usercall free_modules_db(int a1@<eax>, long double a2@<st0>)
{
  int v2; // ebx
  int v3; // esi

  v2 = a1;
  if ( *(_DWORD *)(a1 + 20) )
    free_modules_db();
  if ( *(_DWORD *)(v2 + 28) )
    free_modules_db();
  while ( 1 )
  {
    v3 = *(_DWORD *)(v2 + 24);
    if ( **(_BYTE **)(v2 + 16) == 47 )
      free(a2, v2);
    if ( !v3 )
      break;
    v2 = v3;
  }
}

//----- (080C57C0) --------------------------------------------------------
void __usercall free_mem_4(int a1@<ebp>, long double a2@<st0>)
{
  nl_locale_subfreeres(a1, a2);
  nl_finddomain_subfreeres(a2);
  if ( _gconv_alias_db )
    tdestroy((_DWORD *)_gconv_alias_db, (long double (__cdecl *)(_DWORD))free);
  if ( _gconv_modules_db )
    free_modules_db(_gconv_modules_db, a2);
  if ( known_derivations )
    tdestroy((_DWORD *)known_derivations, (long double (__cdecl *)(_DWORD))free_derivation);
}
// 80F0DF8: using guessed type int known_derivations;
// 80F1310: using guessed type int _gconv_modules_db;
// 80F1318: using guessed type int _gconv_alias_db;

//----- (080C5820) --------------------------------------------------------
void __usercall free_derivation(long double a1@<st0>, int a2)
{
  int v2; // edx
  int v3; // ebx
  unsigned int v4; // edi
  _DWORD *v5; // eax
  int v6; // esi
  void (__cdecl *v7)(int); // esi

  v2 = *(_DWORD *)(a2 + 8);
  if ( *(_DWORD *)(a2 + 12) )
  {
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = (_DWORD *)(v2 + v3);
      if ( *(int *)(v2 + v3 + 8) > 0 )
      {
        v6 = v5[8];
        if ( v6 )
        {
          if ( !*v5 )
            _assert_fail(
              a2,
              a1,
              (int)"deriv->steps[cnt].__shlib_handle != ((void *)0)",
              (int)"gconv_db.c",
              188,
              "free_derivation");
          v7 = (void (__cdecl *)(int))(__readgsdword(0x18u) ^ __ROR4__(v6, 9));
          dl_mcount_wrapper_check((int)v7);
          v7(v3 + *(_DWORD *)(a2 + 8));
          v2 = *(_DWORD *)(a2 + 8);
        }
      }
      ++v4;
      v3 += 60;
    }
    while ( *(_DWORD *)(a2 + 12) > v4 );
  }
  free(a1, *(_DWORD *)(v2 + 12));
  free(a1, *(_DWORD *)(*(_DWORD *)(a2 + 8) + 60 * (*(_DWORD *)(a2 + 12) - 1) + 16));
  free(a1, *(_DWORD *)(a2 + 8));
  free(a1, a2);
}

//----- (080C58F0) --------------------------------------------------------
void __usercall free_mem_5(long double a1@<st0>)
{
  if ( _gconv_path_elem )
  {
    if ( (_UNKNOWN *)_gconv_path_elem != &empty_path_elem )
      free(a1, _gconv_path_elem);
  }
}
// 80F1324: using guessed type int _gconv_path_elem;

//----- (080C5910) --------------------------------------------------------
void __usercall free_mem_6(long double a1@<st0>)
{
  if ( cache_malloced )
  {
    free(a1, gconv_cache);
  }
  else if ( gconv_cache )
  {
    munmap(gconv_cache, cache_size);
  }
}
// 80F0E0C: using guessed type int gconv_cache;
// 80F0E10: using guessed type int cache_size;
// 80F0E14: using guessed type int cache_malloced;

//----- (080C5950) --------------------------------------------------------
void free_mem_7()
{
  tdestroy((_DWORD *)loaded, (long double (__cdecl *)(_DWORD))do_release_all);
  loaded = 0;
}
// 80F0E18: using guessed type int loaded;

//----- (080C5980) --------------------------------------------------------
void __usercall do_release_all(int a1@<ebp>, int a2@<edi>, int a3@<esi>, long double a4@<st0>, int a5)
{
  if ( *(_DWORD *)(a5 + 8) )
    _libc_dlclose(a5, a1, a2, a3, *(_DWORD *)(a5 + 8));
  free(a4, a5);
}

//----- (080C59B0) --------------------------------------------------------
void __usercall free_category(int a1@<eax>, char *a2@<edx>, char *a3@<ecx>, long double a4@<st0>)
{
  int *v5; // ebx
  void (__cdecl *v6)(); // edx
  int *v7; // edi
  int *v8; // eax
  int v9; // [esp+1Ch] [ebp-10h]

  v5 = (int *)nl_locale_file_list[a1];
  if ( a2 != a3 )
  {
    if ( nl_current_used[a1] )
    {
      v6 = (void (__cdecl *)())nl_category_postload[a1];
      (&nl_global_locale)[a1] = a3;
      if ( v6 )
      {
        v9 = a1;
        v6();
        a1 = v9;
      }
    }
    setname(a1, "C", a4);
  }
  if ( v5 )
  {
    while ( 1 )
    {
      v8 = (int *)v5[2];
      if ( v8 != (int *)a3 )
      {
        if ( v8 )
          nl_unload_locale(v8, a4);
      }
      v7 = (int *)v5[3];
      free(a4, *v5);
      free(a4, (int)v5);
      if ( !v7 )
        break;
      v5 = v7;
    }
  }
}
// 80CE780: using guessed type int nl_current_used[16];
// 80CE7C0: using guessed type int (*nl_category_postload[13])();
// 80F1340: using guessed type int nl_locale_file_list[13];

//----- (080C5A50) --------------------------------------------------------
void __usercall nl_locale_subfreeres(int a1@<ebp>, long double a2@<st0>)
{
  free_category(0, *(char **)__readgsdword(0xFFFFFFDC), (char *)&nl_C_LC_CTYPE, a2);
  free_category(4, *(char **)__readgsdword(0xFFFFFFE0), (char *)&nl_C_LC_MONETARY, a2);
  free_category(1, *(char **)__readgsdword(0xFFFFFFE4), (char *)&nl_C_LC_NUMERIC, a2);
  setname(6, "C", a2);
  nl_archive_subfreeres(a1, a2);
}
// 80C8440: using guessed type char *nl_C_LC_MONETARY;
// 80C8520: using guessed type char *nl_C_LC_NUMERIC;
// 80CF3E0: using guessed type char *nl_C_LC_CTYPE;

//----- (080C5C00) --------------------------------------------------------
void __usercall nl_archive_subfreeres(int a1@<ebp>, long double a2@<st0>)
{
  _DWORD *v2; // esi
  int v3; // ebx
  _DWORD *v4; // edi
  int v5; // eax
  void (*v6)(void); // edx
  int *v7; // eax
  int *v8; // ebx
  int *v9; // esi

  v2 = (_DWORD *)archloaded;
  if ( archloaded )
  {
    while ( 1 )
    {
      v3 = 1;
      v4 = (_DWORD *)*v2;
      free(a2, v2[1]);
      while ( 1 )
      {
        if ( v3 != 7 )
        {
          v5 = v2[v3 + 1];
          v6 = *(void (**)(void))(v5 + 16);
          if ( v6 )
          {
            v6();
            v5 = v2[v3 + 1];
          }
          free(a2, v5);
          if ( v3 == 13 )
            break;
        }
        ++v3;
      }
      free(a2, (int)v2);
      if ( !v4 )
        break;
      v2 = v4;
    }
  }
  v7 = (int *)archmapped;
  archloaded = 0;
  if ( archmapped )
  {
    if ( (int *)archmapped != &headmap )
      _assert_fail(a1, a2, (int)"archmapped == &headmap", (int)"loadarchive.c", 531, "_nl_archive_subfreeres");
    archmapped = 0;
    munmap(*v7, dword_80F0E50);
    v8 = (int *)dword_80F0E54;
    if ( dword_80F0E54 )
    {
      while ( 1 )
      {
        v9 = (int *)v8[3];
        munmap(*v8, v8[2]);
        free(a2, (int)v8);
        if ( !v9 )
          break;
        v8 = v9;
      }
    }
  }
}
// 80F0E40: using guessed type int archloaded;
// 80F0E44: using guessed type int archmapped;
// 80F0E48: using guessed type int headmap;
// 80F0E50: using guessed type int dword_80F0E50;
// 80F0E54: using guessed type int dword_80F0E54;

//----- (080C5D00) --------------------------------------------------------
int __usercall free_slotinfo@<eax>(int *a1@<eax>, long double a2@<st0>)
{
  int v2; // esi
  int v4; // edx
  int v5; // ecx
  int v6; // eax

  v2 = 1;
  if ( !*a1 )
    return v2;
  v2 = 0;
  if ( !(unsigned __int8)free_slotinfo() )
    return v2;
  v4 = *a1;
  v5 = *(_DWORD *)*a1;
  if ( !v5 )
    goto LABEL_8;
  if ( !*(_DWORD *)(v4 + 12) )
  {
    v6 = 0;
    while ( ++v6 != v5 )
    {
      if ( *(_DWORD *)(v4 + 8 * v6 + 12) )
        return 0;
    }
LABEL_8:
    v2 = 1;
    free(a2, *a1);
    *a1 = 0;
  }
  return v2;
}

//----- (080C5D80) --------------------------------------------------------
void __usercall free_mem_8(long double a1@<st0>)
{
  _DWORD *v1; // eax
  _DWORD *v2; // ebx
  int v3; // edi
  unsigned int v4; // ebp
  int i; // esi
  int v6; // edx
  int v7; // eax
  int v8; // ebx
  int v9; // eax
  int *v10; // eax
  int v11; // edx

  v1 = (_DWORD *)dl_all_dirs;
  if ( dl_all_dirs != dl_init_all_dirs )
  {
    while ( 1 )
    {
      v2 = (_DWORD *)*v1;
      free(a1, (int)v1);
      if ( (_DWORD *)dl_init_all_dirs == v2 )
        break;
      v1 = v2;
    }
  }
  if ( dl_nns )
  {
    v3 = 0;
    v4 = 0;
    do
    {
      for ( i = dl_ns[v3]; i; i = *(_DWORD *)(i + 12) )
      {
        v6 = *(_DWORD *)(i + 28);
        v7 = *(_DWORD *)(v6 + 4);
        *(_DWORD *)(v6 + 4) = 0;
        if ( v7 )
        {
          while ( 1 )
          {
            v8 = *(_DWORD *)(v7 + 4);
            if ( *(_DWORD *)(v7 + 8) )
            {
              if ( !v8 )
                break;
            }
            else
            {
              free(a1, v7);
              if ( !v8 )
                break;
            }
            v7 = v8;
          }
        }
        if ( (*(_BYTE *)(i + 406) & 1) != 0 )
          free(a1, *(_DWORD *)(i + 496));
      }
      if ( dword_80F120C[v3] )
      {
        v10 = (int *)dword_80F1208[v3];
        if ( v10[1] == dword_80F1188 )
        {
          v11 = *v10;
          *v10 = dl_initial_searchlist;
          dword_80F120C[v3] = 0;
          free(a1, v11);
        }
      }
      ++v4;
      v3 += 19;
    }
    while ( v4 < dl_nns );
  }
  free_slotinfo((int *)(dl_tls_dtv_slotinfo_list + 4), a1);
  v9 = dl_scope_free_list;
  dl_scope_free_list = 0;
  free(a1, v9);
}
// 80F114C: using guessed type int dl_tls_dtv_slotinfo_list;
// 80F1184: using guessed type int dl_initial_searchlist;
// 80F1188: using guessed type int dword_80F1188;
// 80F11C0: using guessed type int dl_nns;
// 80F11C4: using guessed type int dl_scope_free_list;
// 80F11D8: using guessed type int dl_init_all_dirs;
// 80F11EC: using guessed type int dl_all_dirs;
// 80F1200: using guessed type int dl_ns[];
// 80F1208: using guessed type int dword_80F1208[];
// 80F120C: using guessed type int dword_80F120C[];

//----- (080C5E90) --------------------------------------------------------
void term_proc()
{
  _do_global_dtors_aux();
}

// nfuncs=1169 queued=1138 decompiled=1138 lumina nreq=0 worse=0 better=0
#error "There were 14 decompilation failure(s) on 1138 function(s)"
