
Elf64_Sym struc ; (sizeof=0x18, align=0x8, mappedto_1)
                        ; XREF: LOAD:0000000000400300/r
                        ; LOAD:0000000000400318/r ...
st_name dd ?            ; offset (00400498)
st_info db ?
st_other db ?
st_shndx dw ?
st_value dq ?           ; offset (00000000)
st_size dq ?
Elf64_Sym ends


Elf64_Rela struc ; (sizeof=0x18, align=0x8, copyof_2)
                        ; XREF: LOAD:0000000000400588/r
                        ; LOAD:00000000004005A0/r ...
r_offset dq ?
r_info dq ?
r_addend dq ?
Elf64_Rela ends


Elf64_Dyn struc ; (sizeof=0x10, align=0x8, copyof_3)
                        ; XREF: LOAD:stru_601DB8/r
                        ; LOAD:0000000000601DC8/r ...
d_tag dq ?
d_un dq ?
Elf64_Dyn ends


Elf64_Verneed struc ; (sizeof=0x10, align=0x4, mappedto_4)
                        ; XREF: LOAD:0000000000400558/r
vn_version dw ?
vn_cnt dw ?
vn_file dd ?            ; offset (00400498)
vn_aux dd ?
vn_next dd ?
Elf64_Verneed ends


Elf64_Vernaux struc ; (sizeof=0x10, align=0x4, mappedto_5)
                        ; XREF: LOAD:0000000000400568/r
                        ; LOAD:0000000000400578/r
vna_hash dd ?
vna_flags dw ?
vna_other dw ?
vna_name dd ?           ; offset (00400498)
vna_next dd ?
Elf64_Vernaux ends


;
; +-------------------------------------------------------------------------+
; |      This file was generated by The Interactive Disassembler (IDA)      |
; |           Copyright (c) 2023 Hex-Rays, <support@hex-rays.com>           |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : 56276F9D14610A5E621ECB678129077A070A19715BC62A36D02694E70DAD52F9
; Input MD5    : 458B0163AAA54E90CF7AD70BBB304D34
; Input CRC32  : 80684233

; File Name   : D:\project\LLM4CTF\pwn\string\fmt-3\fmt3
; Format      : ELF64 for x86-64 (Executable)
; Imagebase   : 400000
; Interpreter '/lib64/ld-linux-x86-64.so.2'
; Needed Library 'libc.so.6'
;

.686p
.mmx
.model flat
.intel_syntax noprefix


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 400000h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
dword_400000 dd 464C457Fh ; File format: \x7FELF
db 2                    ; File class: 64-bit
db 1                    ; Data encoding: little-endian
db 1                    ; File version
db 0                    ; OS/ABI: UNIX System V ABI
db 0                    ; ABI Version
db 7 dup(0)             ; Padding
dw 2                    ; File type: Executable
dw 3Eh                  ; Machine: x86-64
dd 1                    ; File version
dq offset start         ; Entry point
dq 40h                  ; PHT file offset
dq 2128h                ; SHT file offset
dd 0                    ; Processor-specific flags
dw 40h                  ; ELF header size
dw 38h                  ; PHT entry size
dw 9                    ; Number of entries in PHT
dw 40h                  ; SHT entry size
dw 1Bh                  ; Number of entries in SHT
dw 1Ah                  ; SHT entry index for string table
; ELF64 Program Header
; PHT Entry 0
dword_400040 dd 6       ; Type: PHDR
dd 5                    ; Flags
dq 40h                  ; File offset
dq offset dword_400040  ; Virtual address
dq 400040h              ; Physical address
dq 1F8h                 ; Size in file image
dq 1F8h                 ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 1
dd 3                    ; Type: INTERP
dd 4                    ; Flags
dq 238h                 ; File offset
dq offset aLib64LdLinuxX8 ; Virtual address
dq 400238h              ; Physical address
dq 1Ch                  ; Size in file image
dq 1Ch                  ; Size in memory image
dq 1                    ; Alignment
; PHT Entry 2
dd 1                    ; Type: LOAD
dd 5                    ; Flags
dq 0                    ; File offset
dq offset dword_400000  ; Virtual address
dq 400000h              ; Physical address
dq 146Ch                ; Size in file image
dq 146Ch                ; Size in memory image
dq 200000h              ; Alignment
; PHT Entry 3
dd 1                    ; Type: LOAD
dd 6                    ; Flags
dq 1DA0h                ; File offset
dq offset off_601DA0    ; Virtual address
dq 601DA0h              ; Physical address
dq 270h                 ; Size in file image
dq 290h                 ; Size in memory image
dq 200000h              ; Alignment
; PHT Entry 4
dd 2                    ; Type: DYNAMIC
dd 6                    ; Flags
dq 1DB8h                ; File offset
dq offset stru_601DB8   ; Virtual address
dq 601DB8h              ; Physical address
dq 1C0h                 ; Size in file image
dq 1C0h                 ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 5
dd 4                    ; Type: NOTE
dd 4                    ; Flags
dq 254h                 ; File offset
dq offset dword_400254  ; Virtual address
dq 400254h              ; Physical address
dq 44h                  ; Size in file image
dq 44h                  ; Size in memory image
dq 4                    ; Alignment
; PHT Entry 6
dd 6474E550h            ; Type: EH_FRAME
dd 4                    ; Flags
dq 11D8h                ; File offset
dq offset unk_4011D8    ; Virtual address
dq 4011D8h              ; Physical address
dq 7Ch                  ; Size in file image
dq 7Ch                  ; Size in memory image
dq 4                    ; Alignment
; PHT Entry 7
dd 6474E551h            ; Type: STACK
dd 6                    ; Flags
dq 0                    ; File offset
dq 0                    ; Virtual address
dq 0                    ; Physical address
dq 0                    ; Size in file image
dq 0                    ; Size in memory image
dq 10h                  ; Alignment
; PHT Entry 8
dd 6474E552h            ; Type: RO-AFTER
dd 4                    ; Flags
dq 1DA0h                ; File offset
dq offset off_601DA0    ; Virtual address
dq 601DA0h              ; Physical address
dq 260h                 ; Size in file image
dq 260h                 ; Size in memory image
dq 1                    ; Alignment
aLib64LdLinuxX8 db '/lib64/ld-linux-x86-64.so.2',0
; ELF Note Entry
dword_400254 dd 4       ; Name Size
dd 10h                  ; Desc Size
dd 1                    ; Type: NT_GNU_ABI_TAG
aGnu db 'GNU',0         ; Name
dd 0, 2, 6, 20h         ; ABI: Linux 2.6.32
; ELF Note Entry
dd 4                    ; Name Size
dd 14h                  ; Desc Size
dd 3                    ; Type: NT_GNU_BUILD_ID
aGnu_0 db 'GNU',0       ; Name
db 0FCh, 0A1h, 0E2h, 92h, 10h, 0FFh, 0BEh ; Desc
db 4Ah, 0EAh, 1Eh, 56h, 55h, 93h, 6, 59h
db 0Dh, 0FEh, 0, 0C3h, 5Bh
; ELF GNU Hash Table
elf_gnu_hash_nbuckets dd 3
elf_gnu_hash_symbias dd 2
elf_gnu_hash_bitmask_nwords dd 2
elf_gnu_hash_shift dd 7
elf_gnu_hash_indexes dq 1541691030830600h, 120248004014402h
elf_gnu_hash_bucket dd 2, 6, 0Ch
elf_gnu_hash_chain dd 1C8C1D28h, 7C9C7B10h, 0D82B830h, 7C9D4D41h
dd 0CA90EEBCh, 10615566h, 10A8B550h, 1B853C4Eh
dd 156B2BB8h, 0FD40322Dh, 1C9396CAh, 1CEEE48Ah
dd 0F63D4E2Eh, 0D827590h, 7C943C75h
; ELF Symbol Table
Elf64_Sym <0>
Elf64_Sym <offset aGmonStart - offset byte_400498,\ ; "__gmon_start__"
           20h, 0, 0, 0, 0>
Elf64_Sym <offset aStdout - offset byte_400498,\ ; "stdout"
           11h, 0, 18h, offset stdout, \
           8>
Elf64_Sym <offset aPuts - offset byte_400498,\ ; "puts"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aMemset - offset byte_400498,\ ; "memset"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aRead - offset byte_400498,\ ; "read"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aPutchar - offset byte_400498,\ ; "putchar"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aStdin - offset byte_400498,\ ; "stdin"
           11h, 0, 18h, offset stdin, 8>
Elf64_Sym <offset aWrite - offset byte_400498,\ ; "write"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aSetbuf - offset byte_400498,\ ; "setbuf"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aPrintf - offset byte_400498,\ ; "printf"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aFflush - offset byte_400498,\ ; "fflush"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aStrcpy - offset byte_400498,\ ; "strcpy"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aSystem - offset byte_400498,\ ; "system"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aLibcStartMain - offset byte_400498,\ ; "__libc_start_main"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aMemcpy - offset byte_400498,\ ; "memcpy"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aAtol - offset byte_400498,\ ; "atol"
           12h, 0, 0, 0, 0>
; ELF String Table
byte_400498 db 0
aLibcSo6 db 'libc.so.6',0
aFflush db 'fflush',0
aStrcpy db 'strcpy',0
aPuts db 'puts',0
aPutchar db 'putchar',0
aStdin db 'stdin',0
aPrintf db 'printf',0
aMemset db 'memset',0
aRead db 'read',0
aStdout db 'stdout',0
aMemcpy db 'memcpy',0
aSystem db 'system',0
aAtol db 'atol',0
aSetbuf db 'setbuf',0
aLibcStartMain db '__libc_start_main',0
aWrite db 'write',0
aGmonStart db '__gmon_start__',0
aGlibc214 db 'GLIBC_2.14',0
aGlibc225 db 'GLIBC_2.2.5',0
; ELF GNU Symbol Version Table
dw 0
dw 0                    ; local  symbol: __gmon_start__
dw 2                    ; stdout@@GLIBC_2.2.5
dw 2                    ; puts@@GLIBC_2.2.5
dw 2                    ; memset@@GLIBC_2.2.5
dw 2                    ; read@@GLIBC_2.2.5
dw 2                    ; putchar@@GLIBC_2.2.5
dw 2                    ; stdin@@GLIBC_2.2.5
dw 2                    ; write@@GLIBC_2.2.5
dw 2                    ; setbuf@@GLIBC_2.2.5
dw 2                    ; printf@@GLIBC_2.2.5
dw 2                    ; fflush@@GLIBC_2.2.5
dw 2                    ; strcpy@@GLIBC_2.2.5
dw 2                    ; system@@GLIBC_2.2.5
dw 2                    ; __libc_start_main@@GLIBC_2.2.5
dw 3                    ; memcpy@@GLIBC_2.14
dw 2                    ; atol@@GLIBC_2.2.5
; ELF GNU Symbol Version Requirements
Elf64_Verneed <1, 2, \  ; "libc.so.6"
               offset aLibcSo6 - offset byte_400498,\
               10h, 0>
Elf64_Vernaux <6969194h, 0, 3, \ ; "GLIBC_2.14"
               offset aGlibc214 - offset byte_400498,\
               10h>
Elf64_Vernaux <9691A75h, 0, 2, \ ; "GLIBC_2.2.5"
               offset aGlibc225 - offset byte_400498,\
               0>
; ELF RELA Relocation Table
Elf64_Rela <601F90h, 600000006h, 0> ; R_X86_64_GLOB_DAT putchar
Elf64_Rela <601F98h, 0C00000006h, 0> ; R_X86_64_GLOB_DAT strcpy
Elf64_Rela <601FA0h, 300000006h, 0> ; R_X86_64_GLOB_DAT puts
Elf64_Rela <601FA8h, 800000006h, 0> ; R_X86_64_GLOB_DAT write
Elf64_Rela <601FB0h, 900000006h, 0> ; R_X86_64_GLOB_DAT setbuf
Elf64_Rela <601FB8h, 0D00000006h, 0> ; R_X86_64_GLOB_DAT system
Elf64_Rela <601FC0h, 0A00000006h, 0> ; R_X86_64_GLOB_DAT printf
Elf64_Rela <601FC8h, 400000006h, 0> ; R_X86_64_GLOB_DAT memset
Elf64_Rela <601FD0h, 500000006h, 0> ; R_X86_64_GLOB_DAT read
Elf64_Rela <601FD8h, 0E00000006h, 0> ; R_X86_64_GLOB_DAT __libc_start_main
Elf64_Rela <601FE0h, 100000006h, 0> ; R_X86_64_GLOB_DAT __gmon_start__
Elf64_Rela <601FE8h, 0F00000006h, 0> ; R_X86_64_GLOB_DAT memcpy
Elf64_Rela <601FF0h, 0B00000006h, 0> ; R_X86_64_GLOB_DAT fflush
Elf64_Rela <601FF8h, 1000000006h, 0> ; R_X86_64_GLOB_DAT atol
Elf64_Rela <602010h, 200000005h, 0> ; R_X86_64_COPY stdout
Elf64_Rela <602020h, 700000005h, 0> ; R_X86_64_COPY stdin
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_init segment dword public 'CODE' use64
assume cs:_init
;org 400708h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _init_proc
_init_proc proc near
sub     rsp, 8
mov     rax, cs:__gmon_start___ptr
test    rax, rax
jz      short loc_40071D
call    __gmon_start__

loc_40071D:
add     rsp, 8
retn
_init_proc endp

_init ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 400722h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 10h
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_plt segment para public 'CODE' use64
assume cs:_plt
;org 400730h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; __unwind {
push    cs:qword_601F80
jmp     cs:qword_601F88
align 20h
; } // starts at 400730
_plt ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_plt_got segment qword public 'CODE' use64
assume cs:_plt_got
;org 400740h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; [00000006 BYTES: COLLAPSED FUNCTION putchar. PRESS CTRL-NUMPAD+ TO EXPAND]
align 8
; [00000006 BYTES: COLLAPSED FUNCTION strcpy. PRESS CTRL-NUMPAD+ TO EXPAND]
align 10h
; [00000006 BYTES: COLLAPSED FUNCTION puts. PRESS CTRL-NUMPAD+ TO EXPAND]
align 8
; [00000006 BYTES: COLLAPSED FUNCTION write. PRESS CTRL-NUMPAD+ TO EXPAND]
align 20h
; [00000006 BYTES: COLLAPSED FUNCTION setbuf. PRESS CTRL-NUMPAD+ TO EXPAND]
align 8
; [00000006 BYTES: COLLAPSED FUNCTION system. PRESS CTRL-NUMPAD+ TO EXPAND]
align 10h
; [00000006 BYTES: COLLAPSED FUNCTION printf. PRESS CTRL-NUMPAD+ TO EXPAND]
align 8
; [00000006 BYTES: COLLAPSED FUNCTION memset. PRESS CTRL-NUMPAD+ TO EXPAND]
align 20h
; [00000006 BYTES: COLLAPSED FUNCTION read. PRESS CTRL-NUMPAD+ TO EXPAND]
align 8
; [00000006 BYTES: COLLAPSED FUNCTION __libc_start_main. PRESS CTRL-NUMPAD+ TO EXPAND]
align 10h
; [00000006 BYTES: COLLAPSED FUNCTION __gmon_start__. PRESS CTRL-NUMPAD+ TO EXPAND]
align 8
; [00000006 BYTES: COLLAPSED FUNCTION memcpy. PRESS CTRL-NUMPAD+ TO EXPAND]
align 20h
; [00000006 BYTES: COLLAPSED FUNCTION fflush. PRESS CTRL-NUMPAD+ TO EXPAND]
align 8
; [00000006 BYTES: COLLAPSED FUNCTION atol. PRESS CTRL-NUMPAD+ TO EXPAND]
align 10h
_plt_got ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_text segment para public 'CODE' use64
assume cs:_text
;org 4007B0h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing


; Attributes: noreturn fuzzy-sp

public start
start proc near
; __unwind {
xor     ebp, ebp
mov     r9, rdx         ; rtld_fini
pop     rsi             ; argc
mov     rdx, rsp        ; ubp_av
and     rsp, 0FFFFFFFFFFFFFFF0h
push    rax
push    rsp             ; stack_end
mov     r8, offset fini ; fini
mov     rcx, offset init ; init
mov     rdi, offset main ; main
call    __libc_start_main
hlt
; } // starts at 4007B0
start endp

align 20h


; Attributes: bp-based frame

sub_4007E0 proc near
mov     eax, 602017h
push    rbp
sub     rax, offset stdout
cmp     rax, 0Eh
mov     rbp, rsp
jbe     short loc_400810
mov     eax, 0
test    rax, rax
jz      short loc_400810
pop     rbp
mov     edi, offset stdout
jmp     rax
align 10h

loc_400810:
pop     rbp
retn
sub_4007E0 endp

align 20h


; Attributes: bp-based frame

sub_400820 proc near
mov     esi, offset stdout
push    rbp
sub     rsi, offset stdout
sar     rsi, 3
mov     rbp, rsp
mov     rax, rsi
shr     rax, 3Fh
add     rsi, rax
sar     rsi, 1
jz      short loc_400858
mov     eax, 0
test    rax, rax
jz      short loc_400858
pop     rbp
mov     edi, offset stdout
jmp     rax
align 8

loc_400858:
pop     rbp
retn
sub_400820 endp

align 20h



sub_400860 proc near
cmp     cs:byte_602028, 0
jnz     short locret_40087A
push    rbp
mov     rbp, rsp
call    sub_4007E0
pop     rbp
mov     cs:byte_602028, 1

locret_40087A:
rep retn
sub_400860 endp

align 20h



sub_400880 proc near
mov     edi, offset unk_601DB0
cmp     qword ptr [rdi], 0
jnz     short loc_400890

loc_40088B:
jmp     short sub_400820
align 10h

loc_400890:
mov     eax, 0
test    rax, rax
jz      short loc_40088B
push    rbp
mov     rbp, rsp
call    rax
pop     rbp
jmp     sub_400820
sub_400880 endp



; Attributes: bp-based frame

sub_4008A6 proc near
; __unwind {
push    rbp
mov     rbp, rsp
mov     edi, offset command ; "/bin/sh"
call    system
pop     rdi
pop     rsi
pop     rdx
retn
sub_4008A6 endp ; sp-analysis failed

db 90h
pop     rbp
retn
; } // starts at 4008A6


; Attributes: bp-based frame

sub_4008BB proc near
; __unwind {
push    rbp
mov     rbp, rsp
mov     edi, offset s   ; "***************************************"...
call    puts
mov     edi, offset asc_400F70 ; "*                                      "...
call    puts
mov     edi, offset aWelcomeToSange ; "*Welcome to sangebaimao,Pwnn me and hav"...
call    puts
mov     edi, offset asc_400F70 ; "*                                      "...
call    puts
mov     edi, offset s   ; "***************************************"...
call    puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
nop
pop     rbp
retn
; } // starts at 4008BB
sub_4008BB endp



; Attributes: bp-based frame

; __int64 __fastcall sub_400903(int, int, int, int, int, int, __int64 buf, __int64, __int64, __int64, __int64)
sub_400903 proc near

var_18= qword ptr -18h
var_2= byte ptr -2
var_1= byte ptr -1
buf= qword ptr  10h
arg_8= qword ptr  18h
arg_10= qword ptr  20h
arg_18= qword ptr  28h
arg_20= qword ptr  30h

; __unwind {
push    rbp
mov     rbp, rsp
sub     rsp, 20h
mov     [rbp+var_18], rdi
mov     edi, offset aRegisterAccoun ; "Register Account first!"
call    puts
mov     edi, offset aInputYourUsern ; "Input your username(max lenth:20): "
call    puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
mov     edx, 14h        ; nbytes
lea     rsi, [rbp+buf]  ; buf
mov     edi, 0          ; fd
call    read
mov     [rbp+var_1], al
cmp     [rbp+var_1], 0
jz      short loc_400954
cmp     [rbp+var_1], 14h
jbe     short loc_4009A7

loc_400954:
movzx   eax, cs:byte_40100C
mov     byte ptr [rbp+buf], al
mov     edi, offset aErrorLenthUser ; "error lenth(username)!try again"
call    puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
mov     rax, [rbp+var_18]
mov     rdx, [rbp+buf]
mov     [rax], rdx
mov     rdx, [rbp+arg_8]
mov     [rax+8], rdx
mov     rdx, [rbp+arg_10]
mov     [rax+10h], rdx
mov     rdx, [rbp+arg_18]
mov     [rax+18h], rdx
mov     rdx, [rbp+arg_20]
mov     [rax+20h], rdx
jmp     loc_400A6F

loc_4009A7:
mov     edi, offset aInputYourPassw ; "Input your password(max lenth:20): "
call    puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
lea     rax, [rbp+arg_10+4]
mov     edx, 14h        ; nbytes
mov     rsi, rax        ; buf
mov     edi, 0          ; fd
call    read
mov     [rbp+var_2], al
cmp     [rbp+var_2], 0
jnz     short loc_400A35
cmp     [rbp+var_2], 14h
jbe     short loc_400A35
movzx   eax, cs:byte_40100C
mov     byte ptr [rbp+buf], al
mov     edi, offset aErrorLenthPass ; "error lenth(password)!try again"
call    puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
mov     rax, [rbp+var_18]
mov     rdx, [rbp+buf]
mov     [rax], rdx
mov     rdx, [rbp+arg_8]
mov     [rax+8], rdx
mov     rdx, [rbp+arg_10]
mov     [rax+10h], rdx
mov     rdx, [rbp+arg_18]
mov     [rax+18h], rdx
mov     rdx, [rbp+arg_20]
mov     [rax+20h], rdx
jmp     short loc_400A6F

loc_400A35:
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
mov     rax, [rbp+var_18]
mov     rdx, [rbp+buf]
mov     [rax], rdx
mov     rdx, [rbp+arg_8]
mov     [rax+8], rdx
mov     rdx, [rbp+arg_10]
mov     [rax+10h], rdx
mov     rdx, [rbp+arg_18]
mov     [rax+18h], rdx
mov     rdx, [rbp+arg_20]
mov     [rax+20h], rdx

loc_400A6F:
mov     rax, [rbp+var_18]
leave
retn
; } // starts at 400903
sub_400903 endp



; Attributes: bp-based frame

sub_400A75 proc near

buf= dword ptr -8
var_4= dword ptr -4

; __unwind {
push    rbp
mov     rbp, rsp
sub     rsp, 10h
mov     [rbp+buf], 0
mov     edi, offset a1Sh0wAccountIn ; "1.Sh0w Account Infomation!"
call    puts
mov     edi, offset a2Ed1tAccountIn ; "2.Ed1t Account Inf0mation!"
call    puts
mov     edi, offset a3QuitSangebaim ; "3.QUit sangebaimao:("
call    puts
mov     edi, 3Eh ; '>'  ; c
call    putchar
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
lea     rax, [rbp+buf]
mov     edx, 5          ; nbytes
mov     rsi, rax        ; buf
mov     edi, 0          ; fd
call    read
lea     rax, [rbp+buf]
mov     rdi, rax        ; nptr
call    atol
mov     [rbp+var_4], eax
mov     eax, [rbp+var_4]
leave
retn
; } // starts at 400A75
sub_400A75 endp



; Attributes: bp-based frame

sub_400AE5 proc near

src= qword ptr -28h
dest= byte ptr -20h

; __unwind {
push    rbp
mov     rbp, rsp
sub     rsp, 30h
mov     [rbp+src], rdi
mov     rdx, [rbp+src]
lea     rax, [rbp+dest]
mov     rsi, rdx        ; src
mov     rdi, rax        ; dest
call    strcpy
nop
leave
retn
; } // starts at 400AE5
sub_400AE5 endp



; Attributes: bp-based frame

; __int64 __fastcall sub_400B07(int, int, int, int, int, int, char format, int, int)
sub_400B07 proc near

format= byte ptr  10h
arg_14= byte ptr  24h

; __unwind {
push    rbp
mov     rbp, rsp
mov     edx, 1Ah        ; n
mov     esi, offset aWelc0meToSange ; "Welc0me to sangebaimao!\n"
mov     edi, 0          ; fd
call    write
lea     rdi, [rbp+format] ; format
mov     eax, 0
call    printf
lea     rax, [rbp+arg_14]
mov     rdi, rax        ; format
mov     eax, 0
call    printf
nop
pop     rbp
retn
; } // starts at 400B07
sub_400B07 endp



; Attributes: bp-based frame

; __int64 __fastcall sub_400B41(int, int, int, int, int, int, __int64 s, __int64, __int64 dest, __int64, __int64)
sub_400B41 proc near

var_268= qword ptr -268h
buf= byte ptr -260h
src= byte ptr -130h
var_2= byte ptr -2
var_1= byte ptr -1
s= qword ptr  10h
arg_8= qword ptr  18h
dest= qword ptr  20h
arg_18= qword ptr  28h
arg_20= qword ptr  30h

; __unwind {
push    rbp
mov     rbp, rsp
sub     rsp, 270h
mov     [rbp+var_268], rdi
mov     edi, offset aPleaseInputNew ; "please input new username(max lenth:20)"...
call    puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
lea     rax, [rbp+buf]
mov     edx, 12Ch       ; nbytes
mov     rsi, rax        ; buf
mov     edi, 0          ; fd
call    read
mov     [rbp+var_1], al
cmp     [rbp+var_1], 0
jle     short loc_400BFA
cmp     [rbp+var_1], 14h
jg      short loc_400BFA
mov     edx, 14h        ; n
mov     esi, 0          ; c
lea     rdi, [rbp+s]    ; s
call    memset
lea     rax, [rbp+buf]
mov     rsi, rax        ; src
lea     rdi, [rbp+s]    ; dest
call    strcpy
mov     edi, offset aPleaseInputNew_0 ; "please input new password(max lenth:20)"...
call    puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
lea     rax, [rbp+src]
mov     edx, 12Ch       ; nbytes
mov     rsi, rax        ; buf
mov     edi, 0          ; fd
call    read
mov     [rbp+var_2], al
cmp     [rbp+var_2], 0
jnz     short loc_400C46
jmp     loc_400CCA

loc_400BFA:
mov     edi, offset aLenErrorMaxLen ; "len error(max lenth:20)!try again.."
call    puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
mov     rax, [rbp+var_268]
mov     rdx, [rbp+s]
mov     [rax], rdx
mov     rdx, [rbp+arg_8]
mov     [rax+8], rdx
mov     rdx, [rbp+dest]
mov     [rax+10h], rdx
mov     rdx, [rbp+arg_18]
mov     [rax+18h], rdx
mov     rdx, [rbp+arg_20]
mov     [rax+20h], rdx
jmp     loc_400D11

loc_400C46:
cmp     [rbp+var_2], 14h
ja      short loc_400CCA
lea     rax, [rbp+dest+4]
mov     edx, 14h        ; n
mov     esi, 0          ; c
mov     rdi, rax        ; s
call    memset
lea     rax, [rbp+src]
mov     rdi, rax
call    sub_400AE5
movzx   edx, [rbp+var_2] ; n
lea     rcx, [rbp+src]
lea     rax, [rbp+dest+4]
mov     rsi, rcx        ; src
mov     rdi, rax        ; dest
call    memcpy
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
mov     rax, [rbp+var_268]
mov     rdx, [rbp+s]
mov     [rax], rdx
mov     rdx, [rbp+arg_8]
mov     [rax+8], rdx
mov     rdx, [rbp+dest]
mov     [rax+10h], rdx
mov     rdx, [rbp+arg_18]
mov     [rax+18h], rdx
mov     rdx, [rbp+arg_20]
mov     [rax+20h], rdx
jmp     short loc_400D11

loc_400CCA:
mov     edi, offset aLenErrorMaxLen_0 ; "len error(max lenth:10)!try again.."
call    puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
mov     rax, [rbp+var_268]
mov     rdx, [rbp+s]
mov     [rax], rdx
mov     rdx, [rbp+arg_8]
mov     [rax+8], rdx
mov     rdx, [rbp+dest]
mov     [rax+10h], rdx
mov     rdx, [rbp+arg_18]
mov     [rax+18h], rdx
mov     rdx, [rbp+arg_20]
mov     [rax+20h], rdx

loc_400D11:
mov     rax, [rbp+var_268]
leave
retn
; } // starts at 400B41
sub_400B41 endp



; Attributes: bp-based frame

sub_400D1A proc near
; __unwind {
push    rbp
mov     rbp, rsp
mov     edi, offset aByebyetT ; "byebyeT.T"
call    puts
nop
pop     rbp
retn
; } // starts at 400D1A
sub_400D1A endp



; Attributes: bp-based frame

; __int64 __fastcall sub_400D2B(int, int, int, int, int, int, char format, __int64, __int64 dest, __int64, __int64)
sub_400D2B proc near

format= byte ptr  10h
arg_8= qword ptr  18h
dest= qword ptr  20h
arg_18= qword ptr  28h
arg_20= qword ptr  30h

; __unwind {
push    rbp
mov     rbp, rsp
mov     rax, cs:stdin
mov     esi, 0          ; buf
mov     rdi, rax        ; stream
call    setbuf

loc_400D43:
mov     eax, 0
call    sub_400A75
cmp     eax, 2
jz      short loc_400D7A
cmp     eax, 3
jz      short loc_400D9C
cmp     eax, 1
jnz     short loc_400DA8
sub     rsp, 8
push    [rbp+arg_20]
push    [rbp+arg_18]
push    [rbp+dest]      ; int
push    [rbp+arg_8]     ; int
push    qword ptr [rbp+format] ; format
call    sub_400B07
add     rsp, 30h
jmp     short loc_400DC2

loc_400D7A:
sub     rsp, 8
push    [rbp+arg_20]    ; __int64
push    [rbp+arg_18]    ; __int64
push    [rbp+dest]      ; dest
push    [rbp+arg_8]     ; __int64
push    qword ptr [rbp+format] ; s
lea     rdi, [rbp+format] ; int
call    sub_400B41
add     rsp, 30h
jmp     short loc_400DC2

loc_400D9C:
mov     eax, 0
call    sub_400D1A
jmp     short locret_400DD6

loc_400DA8:
mov     edi, offset aErrorOptions ; "error options"
call    puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
nop

loc_400DC2:
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
jmp     loc_400D43

locret_400DD6:
leave
retn
; } // starts at 400D2B
sub_400D2B endp



; Attributes: bp-based frame

; int __fastcall main(int, char **, char **)
main proc near

var_70= qword ptr -70h
var_64= dword ptr -64h
format= byte ptr -60h
var_58= qword ptr -58h
dest= qword ptr -50h
var_48= qword ptr -48h
var_40= qword ptr -40h
buf= qword ptr -30h
var_28= qword ptr -28h
var_20= qword ptr -20h
var_14= qword ptr -14h
var_C= dword ptr -0Ch

; __unwind {
push    rbp
mov     rbp, rsp
sub     rsp, 70h
mov     [rbp+var_64], edi
mov     [rbp+var_70], rsi
mov     [rbp+buf], 30h ; '0'
mov     [rbp+var_28], 0
mov     dword ptr [rbp+var_20], 0
mov     [rbp+var_20+4], 30h ; '0'
mov     [rbp+var_14], 0
mov     [rbp+var_C], 0
mov     eax, 0
call    sub_4008BB

loc_400E1F:
lea     rax, [rbp+format]
sub     rsp, 8
push    [rbp+var_14+4]  ; __int64
push    qword ptr [rbp-18h] ; __int64
push    [rbp+var_20]    ; __int64
push    [rbp+var_28]    ; __int64
push    [rbp+buf]       ; buf
mov     rdi, rax        ; int
call    sub_400903
add     rsp, 30h
movzx   eax, [rbp+format]
cmp     al, 30h ; '0'
jz      short loc_400E65
mov     edi, offset aRegisterSucces ; "Register Success!!"
call    puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
jmp     short loc_400E80

loc_400E65:
mov     edi, offset aRegisterFailur ; "Register failure,try again..."
call    puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    fflush
jmp     short loc_400E1F

loc_400E80:
sub     rsp, 8
push    [rbp+var_40]    ; __int64
push    [rbp+var_48]    ; __int64
push    [rbp+dest]      ; dest
push    [rbp+var_58]    ; __int64
push    qword ptr [rbp+format] ; format
call    sub_400D2B
add     rsp, 30h
mov     eax, 0
leave
retn
; } // starts at 400DD8
main endp

align 10h



; void init(void)
init proc near
; __unwind {
push    r15
push    r14
mov     r15d, edi
push    r13
push    r12
lea     r12, off_601DA0
push    rbp
lea     rbp, off_601DA8
push    rbx
mov     r14, rsi
mov     r13, rdx
xor     ebx, ebx
sub     rbp, r12
sub     rsp, 8
sar     rbp, 3
call    _init_proc
test    rbp, rbp
jz      short loc_400F06
nop     dword ptr [rax+rax+00000000h]

loc_400EF0:
mov     rdx, r13
mov     rsi, r14
mov     edi, r15d
call    qword ptr [r12+rbx*8]
add     rbx, 1
cmp     rbx, rbp
jnz     short loc_400EF0

loc_400F06:
add     rsp, 8
pop     rbx
pop     rbp
pop     r12
pop     r13
pop     r14
pop     r15
retn
; } // starts at 400EB0
init endp

align 20h
; [00000002 BYTES: COLLAPSED FUNCTION fini. PRESS CTRL-NUMPAD+ TO EXPAND]

; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 400F22h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 4
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_fini segment dword public 'CODE' use64
assume cs:_fini
;org 400F24h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _term_proc
_term_proc proc near
sub     rsp, 8
add     rsp, 8
retn
_term_proc endp

_fini ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 400F2Dh
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 10h
LOAD ends


; Segment type: Pure data
; Segment permissions: Read
_rodata segment qword public 'CONST' use64
assume cs:_rodata
;org 400F30h
db    1
db    0
db    2
db    0
db    0
db    0
db    0
db    0
; const char command[]
command db '/bin/sh',0
; const char s[]
s db '***********************************'
db '***********',0
align 10h
; const char asc_400F70[]
asc_400F70 db '*                                  '
db '          *',0
align 20h
; const char aWelcomeToSange[]
aWelcomeToSange db '*Welcome to sangebaimao,Pwnn me and'
db ' have fun!*',0
; const char aRegisterAccoun[]
aRegisterAccoun db 'Register Account first!',0
align 8
; const char aInputYourUsern[]
aInputYourUsern db 'Input your username(max lenth:20): '
db 0
byte_40100C db 30h
align 10h
; const char aErrorLenthUser[]
aErrorLenthUser db 'error lenth(username)!try again',0
; const char aInputYourPassw[]
aInputYourPassw db 'Input your password(max lenth:20): '
db 0
align 8
; const char aErrorLenthPass[]
aErrorLenthPass db 'error lenth(password)!try again',0
; const char a1Sh0wAccountIn[]
a1Sh0wAccountIn db '1.Sh0w Account Infomation!',0
; const char a2Ed1tAccountIn[]
a2Ed1tAccountIn db '2.Ed1t Account Inf0mation!',0
; const char a3QuitSangebaim[]
a3QuitSangebaim db '3.QUit sangebaimao:(',0
aWelc0meToSange db 'Welc0me to sangebaimao!',0Ah,0
align 20h
; const char aPleaseInputNew[]
aPleaseInputNew db 'please input new username(max lenth'
db ':20): ',0
align 10h
; const char aPleaseInputNew_0[]
aPleaseInputNew_0 db 'please input new password(max lenth'
db ':20): ',0
align 20h
; const char aLenErrorMaxLen[]
aLenErrorMaxLen db 'len error(max lenth:20)!try again..'
db 0
align 8
; const char aLenErrorMaxLen_0[]
aLenErrorMaxLen_0 db 'len error(max lenth:10)!try again..'
db 0
; const char aByebyetT[]
aByebyetT db 'byebyeT.T',0
; const char aErrorOptions[]
aErrorOptions db 'error options',0
; const char aRegisterSucces[]
aRegisterSucces db 'Register Success!!',0
; const char aRegisterFailur[]
aRegisterFailur db 'Register failure,try again...',0
_rodata ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 4011D5h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 8
LOAD ends


; Segment type: Pure data
; Segment permissions: Read
_eh_frame_hdr segment dword public 'CONST' use64
assume cs:_eh_frame_hdr
;org 4011D8h
unk_4011D8 db    1
db  1Bh
db    3
db  3Bh ; ;
db  7Ch ; |
db    0
db    0
db    0
db  0Eh
db    0
db    0
db    0
db  58h ; X
db 0F5h
db 0FFh
db 0FFh
db 0C8h
db    0
db    0
db    0
db 0D8h
db 0F5h
db 0FFh
db 0FFh
db  98h
db    0
db    0
db    0
db 0CEh
db 0F6h
db 0FFh
db 0FFh
db 0F0h
db    0
db    0
db    0
db 0E3h
db 0F6h
db 0FFh
db 0FFh
db  10h
db    1
db    0
db    0
db  2Bh ; +
db 0F7h
db 0FFh
db 0FFh
db  30h ; 0
db    1
db    0
db    0
db  9Dh
db 0F8h
db 0FFh
db 0FFh
db  50h ; P
db    1
db    0
db    0
db  0Dh
db 0F9h
db 0FFh
db 0FFh
db  70h ; p
db    1
db    0
db    0
db  2Fh ; /
db 0F9h
db 0FFh
db 0FFh
db  90h
db    1
db    0
db    0
db  69h ; i
db 0F9h
db 0FFh
db 0FFh
db 0B0h
db    1
db    0
db    0
db  42h ; B
db 0FBh
db 0FFh
db 0FFh
db 0D0h
db    1
db    0
db    0
db  53h ; S
db 0FBh
db 0FFh
db 0FFh
db 0F0h
db    1
db    0
db    0
db    0
db 0FCh
db 0FFh
db 0FFh
db  10h
db    2
db    0
db    0
db 0D8h
db 0FCh
db 0FFh
db 0FFh
db  30h ; 0
db    2
db    0
db    0
db  48h ; H
db 0FDh
db 0FFh
db 0FFh
db  78h ; x
db    2
db    0
db    0
_eh_frame_hdr ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 401254h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 8
LOAD ends


; Segment type: Pure data
; Segment permissions: Read
_eh_frame segment qword public 'CONST' use64
assume cs:_eh_frame
;org 401258h
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah ; z
db  52h ; R
db    0
db    1
db  78h ; x
db  10h
db    1
db  1Bh
db  0Ch
db    7
db    8
db  90h
db    1
db    7
db  10h
db  14h
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  38h ; 8
db 0F5h
db 0FFh
db 0FFh
db  2Ah ; *
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah ; z
db  52h ; R
db    0
db    1
db  78h ; x
db  10h
db    1
db  1Bh
db  0Ch
db    7
db    8
db  90h
db    1
db    0
db    0
db  24h ; $
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  88h
db 0F4h
db 0FFh
db 0FFh
db  10h
db    0
db    0
db    0
db    0
db  0Eh
db  10h
db  46h ; F
db  0Eh
db  18h
db  4Ah ; J
db  0Fh
db  0Bh
db  77h ; w
db    8
db  80h
db    0
db  3Fh ; ?
db  1Ah
db  3Bh ; ;
db  2Ah ; *
db  33h ; 3
db  24h ; $
db  22h ; "
db    0
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  44h ; D
db    0
db    0
db    0
db 0D6h
db 0F5h
db 0FFh
db 0FFh
db  15h
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db  50h ; P
db  0Ch
db    7
db    8
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  64h ; d
db    0
db    0
db    0
db 0CBh
db 0F5h
db 0FFh
db 0FFh
db  48h ; H
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    2
db  43h ; C
db  0Ch
db    7
db    8
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  84h
db    0
db    0
db    0
db 0F3h
db 0F5h
db 0FFh
db 0FFh
db  72h ; r
db    1
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    3
db  6Dh ; m
db    1
db  0Ch
db    7
db    8
db    0
db  1Ch
db    0
db    0
db    0
db 0A4h
db    0
db    0
db    0
db  45h ; E
db 0F7h
db 0FFh
db 0FFh
db  70h ; p
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    2
db  6Bh ; k
db  0Ch
db    7
db    8
db    0
db    0
db  1Ch
db    0
db    0
db    0
db 0C4h
db    0
db    0
db    0
db  95h
db 0F7h
db 0FFh
db 0FFh
db  22h ; "
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db  5Dh ; ]
db  0Ch
db    7
db    8
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db 0E4h
db    0
db    0
db    0
db  97h
db 0F7h
db 0FFh
db 0FFh
db  3Ah ; :
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db  75h ; u
db  0Ch
db    7
db    8
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db    4
db    1
db    0
db    0
db 0B1h
db 0F7h
db 0FFh
db 0FFh
db 0D9h
db    1
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    3
db 0D4h
db    1
db  0Ch
db    7
db    8
db    0
db  1Ch
db    0
db    0
db    0
db  24h ; $
db    1
db    0
db    0
db  6Ah ; j
db 0F9h
db 0FFh
db 0FFh
db  11h
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db  4Ch ; L
db  0Ch
db    7
db    8
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  44h ; D
db    1
db    0
db    0
db  5Bh ; [
db 0F9h
db 0FFh
db 0FFh
db 0ADh
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    2
db 0A8h
db  0Ch
db    7
db    8
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  64h ; d
db    1
db    0
db    0
db 0E8h
db 0F9h
db 0FFh
db 0FFh
db 0CBh
db    0
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    2
db 0C6h
db  0Ch
db    7
db    8
db    0
db    0
db  44h ; D
db    0
db    0
db    0
db  84h
db    1
db    0
db    0
db 0A0h
db 0FAh
db 0FFh
db 0FFh
db  65h ; e
db    0
db    0
db    0
db    0
db  42h ; B
db  0Eh
db  10h
db  8Fh
db    2
db  42h ; B
db  0Eh
db  18h
db  8Eh
db    3
db  45h ; E
db  0Eh
db  20h
db  8Dh
db    4
db  42h ; B
db  0Eh
db  28h ; (
db  8Ch
db    5
db  48h ; H
db  0Eh
db  30h ; 0
db  86h
db    6
db  48h ; H
db  0Eh
db  38h ; 8
db  83h
db    7
db  4Fh ; O
db  0Eh
db  40h ; @
db  70h ; p
db  0Eh
db  38h ; 8
db  41h ; A
db  0Eh
db  30h ; 0
db  41h ; A
db  0Eh
db  28h ; (
db  42h ; B
db  0Eh
db  20h
db  42h ; B
db  0Eh
db  18h
db  42h ; B
db  0Eh
db  10h
db  42h ; B
db  0Eh
db    8
db    0
db  14h
db    0
db    0
db    0
db 0CCh
db    1
db    0
db    0
db 0C8h
db 0FAh
db 0FFh
db 0FFh
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
_eh_frame ends

; ELF Initialization Function Table

; Segment type: Pure data
; Segment permissions: Read/Write
_init_array segment qword public 'DATA' use64
assume cs:_init_array
;org 601DA0h
off_601DA0 dq offset sub_400880
_init_array ends

; ELF Termination Function Table

; Segment type: Pure data
; Segment permissions: Read/Write
_fini_array segment qword public 'DATA' use64
assume cs:_fini_array
;org 601DA8h
off_601DA8 dq offset sub_400860
_fini_array ends


; Segment type: Pure data
; Segment permissions: Read/Write
_jcr segment qword public 'DATA' use64
assume cs:_jcr
;org 601DB0h
unk_601DB0 db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
_jcr ends

; ELF Dynamic Information

; Segment type: Pure data
; Segment permissions: Read/Write
LOAD segment byte public 'DATA' use64
assume cs:LOAD
;org 601DB8h
stru_601DB8 Elf64_Dyn <1, 1> ; DT_NEEDED libc.so.6
Elf64_Dyn <0Ch, 400708h> ; DT_INIT
Elf64_Dyn <0Dh, 400F24h> ; DT_FINI
Elf64_Dyn <19h, 601DA0h> ; DT_INIT_ARRAY
Elf64_Dyn <1Bh, 8>      ; DT_INIT_ARRAYSZ
Elf64_Dyn <1Ah, 601DA8h> ; DT_FINI_ARRAY
Elf64_Dyn <1Ch, 8>      ; DT_FINI_ARRAYSZ
Elf64_Dyn <6FFFFEF5h, 400298h> ; DT_GNU_HASH
Elf64_Dyn <5, 400498h>  ; DT_STRTAB
Elf64_Dyn <6, 400300h>  ; DT_SYMTAB
Elf64_Dyn <0Ah, 9Eh>    ; DT_STRSZ
Elf64_Dyn <0Bh, 18h>    ; DT_SYMENT
Elf64_Dyn <15h, 0>      ; DT_DEBUG
Elf64_Dyn <3, 601F78h>  ; DT_PLTGOT
Elf64_Dyn <7, 400588h>  ; DT_RELA
Elf64_Dyn <8, 180h>     ; DT_RELASZ
Elf64_Dyn <9, 18h>      ; DT_RELAENT
Elf64_Dyn <18h, 0>      ; DT_BIND_NOW
Elf64_Dyn <6FFFFFFBh, 1> ; DT_FLAGS_1
Elf64_Dyn <6FFFFFFEh, 400558h> ; DT_VERNEED
Elf64_Dyn <6FFFFFFFh, 1> ; DT_VERNEEDNUM
Elf64_Dyn <6FFFFFF0h, 400536h> ; DT_VERSYM
Elf64_Dyn <0>           ; DT_NULL
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
LOAD ends


; Segment type: Pure data
; Segment permissions: Read/Write
_got segment qword public 'DATA' use64
assume cs:_got
;org 601F78h
dq offset stru_601DB8
qword_601F80 dq 0
qword_601F88 dq 0
putchar_ptr dq offset __imp_putchar
strcpy_ptr dq offset __imp_strcpy
puts_ptr dq offset __imp_puts
write_ptr dq offset __imp_write
setbuf_ptr dq offset __imp_setbuf
system_ptr dq offset __imp_system
printf_ptr dq offset __imp_printf
memset_ptr dq offset __imp_memset
read_ptr dq offset __imp_read
__libc_start_main_ptr dq offset __imp___libc_start_main
__gmon_start___ptr dq offset __imp___gmon_start__
memcpy_ptr dq offset __imp_memcpy
fflush_ptr dq offset __imp_fflush
atol_ptr dq offset __imp_atol
_got ends


; Segment type: Pure data
; Segment permissions: Read/Write
_data segment qword public 'DATA' use64
assume cs:_data
;org 602000h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
_data ends


; Segment type: Uninitialized
; Segment permissions: Read/Write
_bss segment para public 'BSS' use64
assume cs:_bss
;org 602010h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
public stdout
; FILE *stdout
stdout dq ?             ; Copy of shared data
align 20h
public stdin
; FILE *stdin
stdin dq ?              ; Copy of shared data
byte_602028 db ?
align 10h
_bss ends


; Segment type: Externs
; extern
; int puts(const char *s)
extrn __imp_puts:near
; void *memset(void *s, int c, size_t n)
extrn __imp_memset:near
; ssize_t read(int fd, void *buf, size_t nbytes)
extrn __imp_read:near
; int putchar(int c)
extrn __imp_putchar:near
; ssize_t write(int fd, const void *buf, size_t n)
extrn __imp_write:near
; void setbuf(FILE *stream, char *buf)
extrn __imp_setbuf:near
; int printf(const char *format, ...)
extrn __imp_printf:near
; int fflush(FILE *stream)
extrn __imp_fflush:near
; char *strcpy(char *dest, const char *src)
extrn __imp_strcpy:near
; int system(const char *command)
extrn __imp_system:near
; int __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)
extrn __imp___libc_start_main:near
; void *memcpy(void *dest, const void *src, size_t n)
extrn __imp_memcpy:near
; __int64 atol(const char *nptr)
extrn __imp_atol:near
extrn __imp___gmon_start__:near ; weak


end start
