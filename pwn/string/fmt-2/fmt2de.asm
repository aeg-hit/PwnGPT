
Elf64_Sym struc ; (sizeof=0x18, align=0x8, mappedto_1)
                        ; XREF: LOAD:00000000004002C0/r
                        ; LOAD:00000000004002D8/r ...
st_name dd ?            ; offset (004003E0)
st_info db ?
st_other db ?
st_shndx dw ?
st_value dq ?           ; offset (00000000)
st_size dq ?
Elf64_Sym ends


Elf64_Rela struc ; (sizeof=0x18, align=0x8, copyof_2)
                        ; XREF: LOAD:00000000004004D8/r
                        ; LOAD:00000000004004F0/r ...
r_offset dq ?
r_info dq ?
r_addend dq ?
Elf64_Rela ends


Elf64_Dyn struc ; (sizeof=0x10, align=0x8, copyof_3)
                        ; XREF: LOAD:_DYNAMIC/r
                        ; LOAD:0000000000600E38/r ...
d_tag dq ?
d_un dq ?
Elf64_Dyn ends


Elf64_Verneed struc ; (sizeof=0x10, align=0x4, mappedto_4)
                        ; XREF: LOAD:0000000000400498/r
vn_version dw ?
vn_cnt dw ?
vn_file dd ?            ; offset (004003E0)
vn_aux dd ?
vn_next dd ?
Elf64_Verneed ends


Elf64_Vernaux struc ; (sizeof=0x10, align=0x4, mappedto_5)
                        ; XREF: LOAD:00000000004004A8/r
                        ; LOAD:00000000004004B8/r ...
vna_hash dd ?
vna_flags dw ?
vna_other dw ?
vna_name dd ?           ; offset (004003E0)
vna_next dd ?
Elf64_Vernaux ends


;
; +-------------------------------------------------------------------------+
; |      This file was generated by The Interactive Disassembler (IDA)      |
; |           Copyright (c) 2023 Hex-Rays, <support@hex-rays.com>           |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : 66DAF236FFEA0308652CB08AE3C59CA52F2C55BB775C0200E1D8614992AD4E26
; Input MD5    : E9D675555AB594DBA74E0554A305F92C
; Input CRC32  : 0B59362B

; File Name   : D:\project\LLM4CTF\pwn\string\fmt-2\fmt2
; Format      : ELF64 for x86-64 (Executable)
; Imagebase   : 400000
; Interpreter '/lib64/ld-linux-x86-64.so.2'
; Needed Library 'libc.so.6'
;
; Source File : 'crtstuff.c'
; Source File : 'goodluck.c'
; Source File : 'crtstuff.c'

.686p
.mmx
.model flat
.intel_syntax noprefix


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 400000h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
dword_400000 dd 464C457Fh ; File format: \x7FELF
db 2                    ; File class: 64-bit
db 1                    ; Data encoding: little-endian
db 1                    ; File version
db 0                    ; OS/ABI: UNIX System V ABI
db 0                    ; ABI Version
db 7 dup(0)             ; Padding
dw 2                    ; File type: Executable
dw 3Eh                  ; Machine: x86-64
dd 1                    ; File version
dq offset _start        ; Entry point
dq 40h                  ; PHT file offset
dq 1B88h                ; SHT file offset
dd 0                    ; Processor-specific flags
dw 40h                  ; ELF header size
dw 38h                  ; PHT entry size
dw 9                    ; Number of entries in PHT
dw 40h                  ; SHT entry size
dw 1Fh                  ; Number of entries in SHT
dw 1Ch                  ; SHT entry index for string table
; ELF64 Program Header
; PHT Entry 0
dword_400040 dd 6       ; Type: PHDR
dd 5                    ; Flags
dq 40h                  ; File offset
dq offset dword_400040  ; Virtual address
dq 400040h              ; Physical address
dq 1F8h                 ; Size in file image
dq 1F8h                 ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 1
dd 3                    ; Type: INTERP
dd 4                    ; Flags
dq 238h                 ; File offset
dq offset aLib64LdLinuxX8 ; Virtual address
dq 400238h              ; Physical address
dq 1Ch                  ; Size in file image
dq 1Ch                  ; Size in memory image
dq 1                    ; Alignment
; PHT Entry 2
dd 1                    ; Type: LOAD
dd 5                    ; Flags
dq 0                    ; File offset
dq offset dword_400000  ; Virtual address
dq 400000h              ; Physical address
dq 0B2Ch                ; Size in file image
dq 0B2Ch                ; Size in memory image
dq 200000h              ; Alignment
; PHT Entry 3
dd 1                    ; Type: LOAD
dd 6                    ; Flags
dq 0E10h                ; File offset
dq offset __frame_dummy_init_array_entry ; Virtual address
dq 600E10h              ; Physical address
dq 260h                 ; Size in file image
dq 270h                 ; Size in memory image
dq 200000h              ; Alignment
; PHT Entry 4
dd 2                    ; Type: DYNAMIC
dd 6                    ; Flags
dq 0E28h                ; File offset
dq offset _DYNAMIC      ; Virtual address
dq 600E28h              ; Physical address
dq 1D0h                 ; Size in file image
dq 1D0h                 ; Size in memory image
dq 8                    ; Alignment
; PHT Entry 5
dd 4                    ; Type: NOTE
dd 4                    ; Flags
dq 254h                 ; File offset
dq offset dword_400254  ; Virtual address
dq 400254h              ; Physical address
dq 44h                  ; Size in file image
dq 44h                  ; Size in memory image
dq 4                    ; Alignment
; PHT Entry 6
dd 6474E550h            ; Type: EH_FRAME
dd 4                    ; Flags
dq 0A00h                ; File offset
dq offset __GNU_EH_FRAME_HDR ; Virtual address
dq 400A00h              ; Physical address
dq 34h                  ; Size in file image
dq 34h                  ; Size in memory image
dq 4                    ; Alignment
; PHT Entry 7
dd 6474E551h            ; Type: STACK
dd 6                    ; Flags
dq 0                    ; File offset
dq 0                    ; Virtual address
dq 0                    ; Physical address
dq 0                    ; Size in file image
dq 0                    ; Size in memory image
dq 10h                  ; Alignment
; PHT Entry 8
dd 6474E552h            ; Type: RO-AFTER
dd 4                    ; Flags
dq 0E10h                ; File offset
dq offset __frame_dummy_init_array_entry ; Virtual address
dq 600E10h              ; Physical address
dq 1F0h                 ; Size in file image
dq 1F0h                 ; Size in memory image
dq 1                    ; Alignment
aLib64LdLinuxX8 db '/lib64/ld-linux-x86-64.so.2',0
; ELF Note Entry
dword_400254 dd 4       ; Name Size
dd 10h                  ; Desc Size
dd 1                    ; Type: NT_GNU_ABI_TAG
aGnu db 'GNU',0         ; Name
dd 0, 2, 6, 20h         ; ABI: Linux 2.6.32
; ELF Note Entry
dd 4                    ; Name Size
dd 14h                  ; Desc Size
dd 3                    ; Type: NT_GNU_BUILD_ID
aGnu_0 db 'GNU',0       ; Name
db 81h, 59h, 38h, 55h, 0A5h, 56h, 2Eh, 17h ; Desc
db 5Eh, 0C7h, 6Ch, 6Dh, 4Fh, 3Ah, 88h, 0CFh
db 2Eh, 85h, 0EBh, 0BBh
; ELF GNU Hash Table
elf_gnu_hash_nbuckets dd 2
elf_gnu_hash_symbias dd 0Bh
elf_gnu_hash_bitmask_nwords dd 1
elf_gnu_hash_shift dd 6
elf_gnu_hash_indexes dq 10010000000000h
elf_gnu_hash_bucket dd 0Bh, 0
elf_gnu_hash_chain dd 1C8C1D29h, 0
; ELF Symbol Table
Elf64_Sym <0>
Elf64_Sym <offset aPuts - offset byte_4003E0,\ ; "puts"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aFclose - offset byte_4003E0,\ ; "fclose"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aStackChkFail - offset byte_4003E0,\ ; "__stack_chk_fail"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aPrintf - offset byte_4003E0,\ ; "printf"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aLibcStartMain - offset byte_4003E0,\ ; "__libc_start_main"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aGmonStart - offset byte_4003E0,\ ; "__gmon_start__"
           20h, 0, 0, 0, 0>
Elf64_Sym <offset aFflush - offset byte_4003E0,\ ; "fflush"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aIoGetc - offset byte_4003E0,\ ; "_IO_getc"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aFopen - offset byte_4003E0,\ ; "fopen"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aIsoc99Scanf - offset byte_4003E0,\ ; "__isoc99_scanf"
           12h, 0, 0, 0, 0>
Elf64_Sym <offset aStdout - offset byte_4003E0,\ ; "stdout"
           11h, 0, 1Ah, \
           offset __bss_start, 8>
; ELF String Table
byte_4003E0 db 0
aLibcSo6 db 'libc.so.6',0
aFflush db 'fflush',0
aFopen db 'fopen',0
aIsoc99Scanf db '__isoc99_scanf',0
aPuts db 'puts',0
aStackChkFail db '__stack_chk_fail',0
aPrintf db 'printf',0
aStdout db 'stdout',0
aFclose db 'fclose',0
aIoGetc db '_IO_getc',0
aLibcStartMain db '__libc_start_main',0
aGmonStart db '__gmon_start__',0
aGlibc27 db 'GLIBC_2.7',0
aGlibc24 db 'GLIBC_2.4',0
aGlibc225 db 'GLIBC_2.2.5',0
; ELF GNU Symbol Version Table
dw 0
dw 2                    ; puts@@GLIBC_2.2.5
dw 2                    ; fclose@@GLIBC_2.2.5
dw 3                    ; __stack_chk_fail@@GLIBC_2.4
dw 2                    ; printf@@GLIBC_2.2.5
dw 2                    ; __libc_start_main@@GLIBC_2.2.5
dw 0                    ; local  symbol: __gmon_start__
dw 2                    ; fflush@@GLIBC_2.2.5
dw 2                    ; _IO_getc@@GLIBC_2.2.5
dw 2                    ; fopen@@GLIBC_2.2.5
dw 4                    ; __isoc99_scanf@@GLIBC_2.7
dw 2                    ; stdout@@GLIBC_2.2.5
dw 0
dw 0
; ELF GNU Symbol Version Requirements
Elf64_Verneed <1, 3, \  ; "libc.so.6"
               offset aLibcSo6 - offset byte_4003E0,\
               10h, 0>
Elf64_Vernaux <0D696917h, 0, 4, \ ; "GLIBC_2.7"
               offset aGlibc27 - offset byte_4003E0,\
               10h>
Elf64_Vernaux <0D696914h, 0, 3, \ ; "GLIBC_2.4"
               offset aGlibc24 - offset byte_4003E0,\
               10h>
Elf64_Vernaux <9691A75h, 0, 2, \ ; "GLIBC_2.2.5"
               offset aGlibc225 - offset byte_4003E0,\
               0>
; ELF RELA Relocation Table
Elf64_Rela <600FF8h, 600000006h, 0> ; R_X86_64_GLOB_DAT __gmon_start__
Elf64_Rela <601070h, 0B00000005h, 0> ; R_X86_64_COPY stdout
; ELF JMPREL Relocation Table
Elf64_Rela <601018h, 100000007h, 0> ; R_X86_64_JUMP_SLOT puts
Elf64_Rela <601020h, 200000007h, 0> ; R_X86_64_JUMP_SLOT fclose
Elf64_Rela <601028h, 300000007h, 0> ; R_X86_64_JUMP_SLOT __stack_chk_fail
Elf64_Rela <601030h, 400000007h, 0> ; R_X86_64_JUMP_SLOT printf
Elf64_Rela <601038h, 500000007h, 0> ; R_X86_64_JUMP_SLOT __libc_start_main
Elf64_Rela <601040h, 700000007h, 0> ; R_X86_64_JUMP_SLOT fflush
Elf64_Rela <601048h, 800000007h, 0> ; R_X86_64_JUMP_SLOT _IO_getc
Elf64_Rela <601050h, 900000007h, 0> ; R_X86_64_JUMP_SLOT fopen
Elf64_Rela <601058h, 0A00000007h, 0> ; R_X86_64_JUMP_SLOT __isoc99_scanf
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_init segment dword public 'CODE' use64
assume cs:_init
;org 4005E0h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _init_proc
_init_proc proc near
sub     rsp, 8          ; _init
mov     rax, cs:__gmon_start___ptr
test    rax, rax
jz      short loc_4005F5
call    __gmon_start__

loc_4005F5:
add     rsp, 8
retn
_init_proc endp

_init ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 4005FAh
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 20h
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_plt segment para public 'CODE' use64
assume cs:_plt
;org 400600h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



sub_400600 proc near
; __unwind {
push    cs:qword_601008
jmp     cs:qword_601010
sub_400600 endp

align 10h
; [00000006 BYTES: COLLAPSED FUNCTION _puts. PRESS CTRL-NUMPAD+ TO EXPAND]
push    0
jmp     sub_400600
; [00000006 BYTES: COLLAPSED FUNCTION _fclose. PRESS CTRL-NUMPAD+ TO EXPAND]
push    1
jmp     sub_400600
; [00000006 BYTES: COLLAPSED FUNCTION ___stack_chk_fail. PRESS CTRL-NUMPAD+ TO EXPAND]
push    2
jmp     sub_400600
; [00000006 BYTES: COLLAPSED FUNCTION _printf. PRESS CTRL-NUMPAD+ TO EXPAND]
push    3
jmp     sub_400600
; [00000006 BYTES: COLLAPSED FUNCTION ___libc_start_main. PRESS CTRL-NUMPAD+ TO EXPAND]
push    4
jmp     sub_400600
; [00000006 BYTES: COLLAPSED FUNCTION _fflush. PRESS CTRL-NUMPAD+ TO EXPAND]
push    5
jmp     sub_400600
; [00000006 BYTES: COLLAPSED FUNCTION __IO_getc. PRESS CTRL-NUMPAD+ TO EXPAND]
push    6
jmp     sub_400600
; [00000006 BYTES: COLLAPSED FUNCTION _fopen. PRESS CTRL-NUMPAD+ TO EXPAND]
push    7
jmp     sub_400600
; [00000006 BYTES: COLLAPSED FUNCTION ___isoc99_scanf. PRESS CTRL-NUMPAD+ TO EXPAND]
push    8
jmp     sub_400600
; } // starts at 400600
_plt ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_plt_got segment qword public 'CODE' use64
assume cs:_plt_got
;org 4006A0h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; [00000006 BYTES: COLLAPSED FUNCTION __gmon_start__. PRESS CTRL-NUMPAD+ TO EXPAND]
align 8
_plt_got ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 4006A8h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 10h
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_text segment para public 'CODE' use64
assume cs:_text
;org 4006B0h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing


; Attributes: noreturn fuzzy-sp

public _start
_start proc near
; __unwind {
xor     ebp, ebp
mov     r9, rdx         ; rtld_fini
pop     rsi             ; argc
mov     rdx, rsp        ; ubp_av
and     rsp, 0FFFFFFFFFFFFFFF0h
push    rax
push    rsp             ; stack_end
mov     r8, offset __libc_csu_fini ; fini
mov     rcx, offset __libc_csu_init ; init
mov     rdi, offset main ; main
call    ___libc_start_main
hlt
; } // starts at 4006B0
_start endp

align 20h


; Attributes: bp-based frame

deregister_tm_clones proc near
mov     eax, 601077h
push    rbp
sub     rax, offset __bss_start
cmp     rax, 0Eh
mov     rbp, rsp
jbe     short loc_400710
mov     eax, 0
test    rax, rax
jz      short loc_400710
pop     rbp
mov     edi, offset __bss_start
jmp     rax
align 10h

loc_400710:
pop     rbp
retn
deregister_tm_clones endp

align 20h


; Attributes: bp-based frame

register_tm_clones proc near
mov     esi, offset __bss_start
push    rbp
sub     rsi, offset __bss_start
sar     rsi, 3
mov     rbp, rsp
mov     rax, rsi
shr     rax, 3Fh
add     rsi, rax
sar     rsi, 1
jz      short loc_400758
mov     eax, 0
test    rax, rax
jz      short loc_400758
pop     rbp
mov     edi, offset __bss_start
jmp     rax
align 8

loc_400758:
pop     rbp
retn
register_tm_clones endp

align 20h



__do_global_dtors_aux proc near
cmp     cs:completed_7585, 0
jnz     short locret_40077A
push    rbp
mov     rbp, rsp
call    deregister_tm_clones
pop     rbp
mov     cs:completed_7585, 1

locret_40077A:
rep retn
__do_global_dtors_aux endp

align 20h



frame_dummy proc near
mov     edi, offset __JCR_LIST__
cmp     qword ptr [rdi], 0
jnz     short loc_400790

loc_40078B:
jmp     short register_tm_clones
align 10h

loc_400790:
mov     eax, 0
test    rax, rax
jz      short loc_40078B
push    rbp
mov     rbp, rsp
call    rax
pop     rbp
jmp     register_tm_clones
frame_dummy endp



; Attributes: bp-based frame

; int __fastcall main(int argc, const char **argv, const char **envp)
public main
main proc near

var_3D= byte ptr -3Dh
var_3C= dword ptr -3Ch
format= qword ptr -38h
fp= qword ptr -30h
var_28= qword ptr -28h
var_20= byte ptr -20h
var_8= qword ptr -8

; __unwind {
push    rbp
mov     rbp, rsp
sub     rsp, 40h
mov     rax, fs:28h
mov     [rbp+var_8], rax
xor     eax, eax
mov     esi, offset modes ; "r"
mov     edi, offset filename ; "flag.txt"
call    _fopen
mov     [rbp+fp], rax
mov     [rbp+var_3C], 0
jmp     short loc_4007F4

loc_4007D9:
mov     rax, [rbp+fp]
mov     rdi, rax        ; fp
call    __IO_getc
mov     edx, eax
mov     eax, [rbp+var_3C]
cdqe
mov     [rbp+rax+var_20], dl
add     [rbp+var_3C], 1

loc_4007F4:
cmp     [rbp+var_3C], 15h
jle     short loc_4007D9
mov     rax, [rbp+fp]
mov     rdi, rax        ; stream
call    _fclose
lea     rax, [rbp+var_20]
mov     [rbp+var_28], rax
mov     edi, offset s   ; "what's the flag"
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
mov     [rbp+format], 0
lea     rax, [rbp+format]
mov     rsi, rax
mov     edi, offset aMs ; "%ms"
mov     eax, 0
call    ___isoc99_scanf
mov     [rbp+var_3C], 0
jmp     short loc_4008B4

loc_40084E:
mov     rdx, [rbp+format]
mov     eax, [rbp+var_3C]
cdqe
add     rax, rdx
movzx   eax, byte ptr [rax]
mov     [rbp+var_3D], al
cmp     [rbp+var_3D], 0
jz      short loc_400875
mov     eax, [rbp+var_3C]
cdqe
movzx   eax, [rbp+rax+var_20]
cmp     al, [rbp+var_3D]
jz      short loc_4008B0

loc_400875:
mov     edi, offset aYouAnswered ; "You answered:"
call    _puts
mov     rax, [rbp+format]
mov     rdi, rax        ; format
mov     eax, 0
call    _printf
mov     edi, offset aButThatWasTota ; "\nBut that was totally wrong lol get re"...
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
mov     eax, 0
jmp     short loc_4008E4

loc_4008B0:
add     [rbp+var_3C], 1

loc_4008B4:
cmp     [rbp+var_3C], 15h
jle     short loc_40084E
mov     rax, [rbp+var_28]
mov     rsi, rax
mov     edi, offset format ; "That's right, the flag is %s\n"
mov     eax, 0
call    _printf
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
mov     eax, 0

loc_4008E4:
mov     rcx, [rbp+var_8]
xor     rcx, fs:28h
jz      short locret_4008F8
call    ___stack_chk_fail

locret_4008F8:
leave
retn
; } // starts at 4007A6
main endp

align 20h



; void _libc_csu_init(void)
public __libc_csu_init
__libc_csu_init proc near
; __unwind {
push    r15
push    r14
mov     r15d, edi
push    r13
push    r12
lea     r12, __frame_dummy_init_array_entry
push    rbp
lea     rbp, __do_global_dtors_aux_fini_array_entry
push    rbx
mov     r14, rsi
mov     r13, rdx
sub     rbp, r12
sub     rsp, 8
sar     rbp, 3
call    _init_proc
test    rbp, rbp
jz      short loc_400956
xor     ebx, ebx
nop     dword ptr [rax+rax+00000000h]

loc_400940:
mov     rdx, r13
mov     rsi, r14
mov     edi, r15d
call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]
add     rbx, 1
cmp     rbx, rbp
jnz     short loc_400940

loc_400956:
add     rsp, 8
pop     rbx
pop     rbp
pop     r12
pop     r13
pop     r14
pop     r15
retn
; } // starts at 400900
__libc_csu_init endp

align 10h



; void _libc_csu_fini(void)
public __libc_csu_fini
__libc_csu_fini proc near
; __unwind {
rep retn
; } // starts at 400970
__libc_csu_fini endp

_text ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 400972h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 4
LOAD ends


; Segment type: Pure code
; Segment permissions: Read/Execute
_fini segment dword public 'CODE' use64
assume cs:_fini
;org 400974h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing



public _term_proc
_term_proc proc near
sub     rsp, 8          ; _fini
add     rsp, 8
retn
_term_proc endp

_fini ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 40097Dh
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 20h
LOAD ends


; Segment type: Pure data
; Segment permissions: Read
_rodata segment qword public 'CONST' use64
assume cs:_rodata
;org 400980h
public _IO_stdin_used
_IO_stdin_used db    1
db    0
db    2
db    0
db    0
db    0
db    0
db    0
; const char modes[2]
modes db 'r',0
; const char filename[]
filename db 'flag.txt',0
; const char s[]
s db 'what',27h,'s the flag',0
aMs db '%ms',0
; const char aYouAnswered[]
aYouAnswered db 'You answered:',0
align 8
; const char aButThatWasTota[]
aButThatWasTota db 0Ah
db 'But that was totally wrong lol get '
db 'rekt',0
; const char format[]
format db 'That',27h,'s right, the flag is %s',0Ah
db 0
_rodata ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 4009FFh
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 20h
LOAD ends


; Segment type: Pure data
; Segment permissions: Read
_eh_frame_hdr segment dword public 'CONST' use64
assume cs:_eh_frame_hdr
;org 400A00h
__GNU_EH_FRAME_HDR db    1
db  1Bh
db    3
db  3Bh ; ;
db  34h ; 4
db    0
db    0
db    0
db    5
db    0
db    0
db    0
db    0
db 0FCh
db 0FFh
db 0FFh
db  80h
db    0
db    0
db    0
db 0B0h
db 0FCh
db 0FFh
db 0FFh
db  50h ; P
db    0
db    0
db    0
db 0A6h
db 0FDh
db 0FFh
db 0FFh
db 0A8h
db    0
db    0
db    0
db    0
db 0FFh
db 0FFh
db 0FFh
db 0C8h
db    0
db    0
db    0
db  70h ; p
db 0FFh
db 0FFh
db 0FFh
db  10h
db    1
db    0
db    0
_eh_frame_hdr ends


; Segment type: Pure code
; Segment permissions: Read/Execute
LOAD segment byte public 'CODE' use64
assume cs:LOAD
;org 400A34h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
align 8
LOAD ends


; Segment type: Pure data
; Segment permissions: Read
_eh_frame segment qword public 'CONST' use64
assume cs:_eh_frame
;org 400A38h
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah ; z
db  52h ; R
db    0
db    1
db  78h ; x
db  10h
db    1
db  1Bh
db  0Ch
db    7
db    8
db  90h
db    1
db    7
db  10h
db  14h
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  58h ; X
db 0FCh
db 0FFh
db 0FFh
db  2Ah ; *
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db  14h
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    1
db  7Ah ; z
db  52h ; R
db    0
db    1
db  78h ; x
db  10h
db    1
db  1Bh
db  0Ch
db    7
db    8
db  90h
db    1
db    0
db    0
db  24h ; $
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  78h ; x
db 0FBh
db 0FFh
db 0FFh
db 0A0h
db    0
db    0
db    0
db    0
db  0Eh
db  10h
db  46h ; F
db  0Eh
db  18h
db  4Ah ; J
db  0Fh
db  0Bh
db  77h ; w
db    8
db  80h
db    0
db  3Fh ; ?
db  1Ah
db  3Bh ; ;
db  2Ah ; *
db  33h ; 3
db  24h ; $
db  22h ; "
db    0
db    0
db    0
db    0
db  1Ch
db    0
db    0
db    0
db  44h ; D
db    0
db    0
db    0
db 0F6h
db 0FCh
db 0FFh
db 0FFh
db  54h ; T
db    1
db    0
db    0
db    0
db  41h ; A
db  0Eh
db  10h
db  86h
db    2
db  43h ; C
db  0Dh
db    6
db    3
db  4Fh ; O
db    1
db  0Ch
db    7
db    8
db    0
db  44h ; D
db    0
db    0
db    0
db  64h ; d
db    0
db    0
db    0
db  30h ; 0
db 0FEh
db 0FFh
db 0FFh
db  65h ; e
db    0
db    0
db    0
db    0
db  42h ; B
db  0Eh
db  10h
db  8Fh
db    2
db  42h ; B
db  0Eh
db  18h
db  8Eh
db    3
db  45h ; E
db  0Eh
db  20h
db  8Dh
db    4
db  42h ; B
db  0Eh
db  28h ; (
db  8Ch
db    5
db  48h ; H
db  0Eh
db  30h ; 0
db  86h
db    6
db  48h ; H
db  0Eh
db  38h ; 8
db  83h
db    7
db  4Dh ; M
db  0Eh
db  40h ; @
db  72h ; r
db  0Eh
db  38h ; 8
db  41h ; A
db  0Eh
db  30h ; 0
db  41h ; A
db  0Eh
db  28h ; (
db  42h ; B
db  0Eh
db  20h
db  42h ; B
db  0Eh
db  18h
db  42h ; B
db  0Eh
db  10h
db  42h ; B
db  0Eh
db    8
db    0
db  14h
db    0
db    0
db    0
db 0ACh
db    0
db    0
db    0
db  58h ; X
db 0FEh
db 0FFh
db 0FFh
db    2
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
__FRAME_END__ db    0
db    0
db    0
db    0
_eh_frame ends

; ELF Initialization Function Table

; Segment type: Pure data
; Segment permissions: Read/Write
_init_array segment qword public 'DATA' use64
assume cs:_init_array
;org 600E10h
__frame_dummy_init_array_entry dq offset frame_dummy ; Alternative name is '__init_array_start'
_init_array ends

; ELF Termination Function Table

; Segment type: Pure data
; Segment permissions: Read/Write
_fini_array segment qword public 'DATA' use64
assume cs:_fini_array
;org 600E18h
__do_global_dtors_aux_fini_array_entry dq offset __do_global_dtors_aux ; Alternative name is '__init_array_end'
_fini_array ends


; Segment type: Pure data
; Segment permissions: Read/Write
_jcr segment qword public 'DATA' use64
assume cs:_jcr
;org 600E20h
__JCR_LIST__ db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
_jcr ends

; ELF Dynamic Information

; Segment type: Pure data
; Segment permissions: Read/Write
LOAD segment byte public 'DATA' use64
assume cs:LOAD
;org 600E28h
_DYNAMIC Elf64_Dyn <1, 1> ; DT_NEEDED libc.so.6
Elf64_Dyn <0Ch, 4005E0h> ; DT_INIT
Elf64_Dyn <0Dh, 400974h> ; DT_FINI
Elf64_Dyn <19h, 600E10h> ; DT_INIT_ARRAY
Elf64_Dyn <1Bh, 8>      ; DT_INIT_ARRAYSZ
Elf64_Dyn <1Ah, 600E18h> ; DT_FINI_ARRAY
Elf64_Dyn <1Ch, 8>      ; DT_FINI_ARRAYSZ
Elf64_Dyn <6FFFFEF5h, 400298h> ; DT_GNU_HASH
Elf64_Dyn <5, 4003E0h>  ; DT_STRTAB
Elf64_Dyn <6, 4002C0h>  ; DT_SYMTAB
Elf64_Dyn <0Ah, 9Ch>    ; DT_STRSZ
Elf64_Dyn <0Bh, 18h>    ; DT_SYMENT
Elf64_Dyn <15h, 0>      ; DT_DEBUG
Elf64_Dyn <3, 601000h>  ; DT_PLTGOT
Elf64_Dyn <2, 0D8h>     ; DT_PLTRELSZ
Elf64_Dyn <14h, 7>      ; DT_PLTREL
Elf64_Dyn <17h, 400508h> ; DT_JMPREL
Elf64_Dyn <7, 4004D8h>  ; DT_RELA
Elf64_Dyn <8, 30h>      ; DT_RELASZ
Elf64_Dyn <9, 18h>      ; DT_RELAENT
Elf64_Dyn <6FFFFFFEh, 400498h> ; DT_VERNEED
Elf64_Dyn <6FFFFFFFh, 1> ; DT_VERNEEDNUM
Elf64_Dyn <6FFFFFF0h, 40047Ch> ; DT_VERSYM
Elf64_Dyn <0>           ; DT_NULL
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
LOAD ends


; Segment type: Pure data
; Segment permissions: Read/Write
_got segment qword public 'DATA' use64
assume cs:_got
;org 600FF8h
__gmon_start___ptr dq offset __imp___gmon_start__
_got ends


; Segment type: Pure data
; Segment permissions: Read/Write
_got_plt segment qword public 'DATA' use64
assume cs:_got_plt
;org 601000h
_GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC
qword_601008 dq 0
qword_601010 dq 0
off_601018 dq offset puts
off_601020 dq offset fclose
off_601028 dq offset __stack_chk_fail
off_601030 dq offset printf
off_601038 dq offset __libc_start_main
off_601040 dq offset fflush
off_601048 dq offset _IO_getc
off_601050 dq offset fopen
off_601058 dq offset __isoc99_scanf
_got_plt ends


; Segment type: Pure data
; Segment permissions: Read/Write
_data segment qword public 'DATA' use64
assume cs:_data
;org 601060h
public __data_start ; weak
__data_start db    0    ; Alternative name is '__data_start'
                        ; data_start
db    0
db    0
db    0
db    0
db    0
db    0
db    0
public __dso_handle
__dso_handle db    0
db    0
db    0
db    0
db    0
db    0
db    0
db    0
_data ends


; Segment type: Uninitialized
; Segment permissions: Read/Write
_bss segment qword public 'BSS' use64
assume cs:_bss
;org 601070h
assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
public __bss_start
; FILE *_bss_start
__bss_start dq ?        ; Alternative name is '__TMC_END__'
                        ; stdout@@GLIBC_2.2.5
                        ; _edata
                        ; Copy of shared data
completed_7585 db ?
align 20h
_bss ends


; Segment type: Zero-length
_prgend segment byte public '' use64
_end label byte
_prgend ends


; Segment type: Externs
; extern
; int puts(const char *s)
extrn puts:near
; int fclose(FILE *stream)
extrn fclose:near
extrn __stack_chk_fail:near
; int printf(const char *format, ...)
extrn printf:near
; int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)
extrn __libc_start_main:near
; int fflush(FILE *stream)
extrn fflush:near
; int IO_getc(_IO_FILE *fp)
extrn _IO_getc:near
; FILE *fopen(const char *filename, const char *modes)
extrn fopen:near
extrn __isoc99_scanf:near
extrn __imp___gmon_start__:near ; weak


end _start
