/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_D770();
// __int64 __fastcall gcry_mpi_get_nbits(_QWORD); weak
// char *getenv(const char *name);
// void globfree(glob_t *pglob);
// void free(void *ptr);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// __int64 __fastcall gcry_mpi_cmp(_QWORD, _QWORD); weak
// int strcasecmp(const char *s1, const char *s2);
// struct tm *localtime(const time_t *timer);
// __int64 __fastcall gcry_md_get_algo_dlen(_QWORD); weak
// void __noreturn abort(void);
// int *__errno_location(void);
// int unlink(const char *name);
// char *strncpy(char *dest, const char *src, size_t n);
// int strncmp(const char *s1, const char *s2, size_t n);
// __int64 __fastcall gcry_md_close(_QWORD); weak
// __int64 __fastcall inflate(_QWORD, _QWORD); weak
// int mkdir(const char *path, __mode_t mode);
// int ferror(FILE *stream);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// __int64 __fastcall gcry_md_read(_QWORD, _QWORD); weak
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// __int64 __fastcall gcry_mpi_randomize(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_cipher_setkey(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_mpi_print(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_sexp_release(_QWORD); weak
// int fcntl(int fd, int cmd, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// __int64 __fastcall gcry_cipher_setctr(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_md_open(_QWORD, _QWORD, _QWORD); weak
// int getpeername(int fd, struct sockaddr *addr, socklen_t *len);
// int fclose(FILE *stream);
// __int64 __fastcall gcry_mpi_powm(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_md_write(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_cipher_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// size_t strlen(const char *s);
// int getpwuid_r(__uid_t uid, struct passwd *resultbuf, char *buffer, size_t buflen, struct passwd **result);
// __int64 __fastcall gcry_strerror(_QWORD); weak
// __uid_t getuid(void);
// uint16_t htons(uint16_t hostshort);
// int dup2(int fd, int fd2);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// char *strchr(const char *s, int c);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// void argp_usage(const struct argp_state *state);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// const char *gai_strerror(int ecode);
// __int64 __fastcall gcry_sexp_nth_data(_QWORD, _QWORD, _QWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// void __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// __int64 __fastcall gcry_mpi_set_bit(_QWORD, _QWORD); weak
// __int64 __fastcall deflate(_QWORD, _QWORD); weak
// uint32_t htonl(uint32_t hostlong);
// void *memset(void *s, int c, size_t n);
// int ioctl(int fd, unsigned __int64 request, ...);
// char *strncat(char *dest, const char *src, size_t n);
// int close(int fd);
// __int64 __fastcall gcry_check_version(_QWORD); weak
// int pipe(int pipedes[2]);
// __int64 __fastcall gcry_pk_get_nbits(_QWORD); weak
// __int64 __fastcall gcry_pk_encrypt(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_sexp_find_token(_QWORD, _QWORD, _QWORD); weak
// size_t strcspn(const char *s, const char *reject);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int memcmp(const void *s1, const void *s2, size_t n);
// error_t argp_parse(const struct argp *argp, int argc, char **argv, unsigned int flags, int *arg_index, void *input);
// __int64 __fastcall gcry_mpi_new(_QWORD); weak
// char *fgets(char *s, int n, FILE *stream);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int glob(const char *pattern, int flags, int (*errfunc)(const char *, int), glob_t *pglob);
// void *calloc(size_t nmemb, size_t size);
// int strcmp(const char *s1, const char *s2);
// __int64 __fastcall deflateInit_(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_md_get_algo(_QWORD); weak
// struct passwd *getpwnam(const char *name);
// __int64 __fastcall gcry_cipher_open(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_sexp_nth_mpi(_QWORD, _QWORD, _QWORD); weak
// int fprintf(FILE *stream, const char *format, ...);
// int sigemptyset(sigset_t *set);
// int feof(FILE *stream);
// __int64 __fastcall gcry_pk_verify(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_sexp_extract_param(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// __int64 strtol(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// __int64 __fastcall gcry_mpi_set_ui(_QWORD, _QWORD); weak
// __int64 __fastcall gcry_mpi_ec_decode_point(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_mpi_point_snatch_get(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall inflateEnd(_QWORD); weak
// int inet_pton(int af, const char *cp, void *buf);
// int kill(__pid_t pid, int sig);
// int openpty(int *amaster, int *aslave, char *name, const struct termios *termp, const struct winsize *winp);
// __int64 __fastcall gcry_md_setkey(_QWORD, _QWORD, _QWORD); weak
// int fileno(FILE *stream);
// int tolower(int c);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int login_tty(int fd);
// __int64 __fastcall gcry_mpi_point_new(_QWORD); weak
// void *malloc(size_t size);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// __int64 __fastcall gcry_cipher_setiv(_QWORD, _QWORD, _QWORD); weak
// int __fxstat(int ver, int fildes, struct stat *stat_buf);
// int listen(int fd, int n);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// __int64 __fastcall gcry_mpi_release(_QWORD); weak
// __int64 __fastcall deflateEnd(_QWORD); weak
// __int64 __fastcall gcry_pk_sign(_QWORD, _QWORD, _QWORD); weak
// void *realloc(void *ptr, size_t size);
// __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...); weak
// uint16_t ntohs(uint16_t netshort);
// __int64 __fastcall inflateInit_(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_mpi_scan(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int poll(struct pollfd *fds, nfds_t nfds, int timeout);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// __int64 __fastcall gcry_md_hash_buffer(_QWORD, _QWORD, _QWORD, _QWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// __int64 __fastcall gcry_mpi_aprint(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_cipher_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// pthread_t pthread_self(void);
// __int64 __fastcall gcry_md_ctl(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int access(const char *name, int type);
// FILE *fopen(const char *filename, const char *modes);
// char *strtok(char *s, const char *delim);
// int getopt(int argc, char *const *argv, const char *shortopts);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// unsigned __int64 strtoul(const char *nptr, char **endptr, int base);
// int atoi(const char *nptr);
// __int64 __fastcall gcry_control(_QWORD); weak
// int gethostname(char *name, size_t len);
// void __noreturn exit(int status);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// __int64 __fastcall gcry_pk_genkey(_QWORD, _QWORD); weak
// __int64 __fastcall gcry_cipher_close(_QWORD); weak
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// uint32_t ntohl(uint32_t netlong);
// char *strdup(const char *s);
// __int64 __fastcall gcry_mpi_test_bit(_QWORD, _QWORD); weak
// char *strerror(int errnum);
// int execl(const char *path, const char *arg, ...);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int execv(const char *path, char *const argv[]);
// __pid_t fork(void);
// char *strstr(const char *haystack, const char *needle);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// __int64 __fastcall gcry_randomize(_QWORD, _QWORD, _QWORD); weak
// const unsigned __int16 **__ctype_b_loc(void);
// void freeaddrinfo(struct addrinfo *ai);
// int socket(int domain, int type, int protocol);
// int __fastcall _cxa_finalize(void *);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
__int64 (**deregister_tm_clones())(void);
__int64 register_tm_clones(void); // weak
__int64 (**_do_global_dtors_aux())(void);
__int64 __fastcall frame_dummy(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall set_default_keys(__int64 a1, int a2, int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall parse_opt(int a1, char *a2, const struct argp_state *a3, __int64 a4, __int64 a5, __int64 a6);
ssize_t __fastcall data_function(__int64 a1, __int64 a2, const void *a3, unsigned int a4, __int64 a5, __pid_t *a6);
__int64 __fastcall pty_request(__int64 a1, __int64 a2, __int64 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int64 a8);
int __fastcall pty_resize(__int64 a1, __int64 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int64 a7);
__int64 __fastcall exec_pty(__int64 a1, __int64 a2, __pid_t *a3);
__int64 __fastcall exec_nopty(__int64 a1, __pid_t *a2);
__int64 __fastcall exec_request(__int64 a1, __int64 a2, __int64 a3, __pid_t *a4);
__int64 __fastcall shell_request(__int64 a1, __int64 a2, __pid_t *a3);
__int64 __fastcall subsystem_request(__int64 a1, __int64 a2, const char *a3, __pid_t *a4);
__int64 __fastcall auth_password(__int64 a1, const char *a2, const char *a3, __int64 a4);
__int64 __fastcall channel_open(__int64 a1, __int64 a2);
__int64 __fastcall process_stdout(); // weak
__int64 __fastcall process_stderr(); // weak
int __fastcall handle_session(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__pid_t sigchld_handler();
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall ssh_legacy_log_callback(unsigned int a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall ssh_set_callbacks(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_add_set_channel_callbacks(__int64 *a1, _QWORD *a2, int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_set_channel_callbacks(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_add_channel_callbacks(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_remove_channel_callbacks(__int64 a1, __int64 a2);
__int64 __fastcall ssh_set_server_callbacks(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD *__fastcall ssh_channel_new(__int64 a1);
__int64 __fastcall ssh_channel_new_id(__int64 a1);
__int64 __fastcall ssh_packet_channel_open_conf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_channel_open_fail(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_BOOL8 __fastcall ssh_channel_open_termination(_DWORD *a1);
__int64 __fastcall channel_open_0(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_from_local(__int64 a1, int a2);
__int64 __fastcall grow_window(__int64 a1, unsigned int *a2, int a3);
__int64 __fastcall channel_from_msg(__int64 a1, __int64 a2);
__int64 __fastcall channel_rcv_change_window(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall channel_rcv_data(__int64 a1, char a2, __int64 a3, __int64 a4);
__int64 __fastcall channel_rcv_eof(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall channel_rcv_close(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall channel_rcv_request(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall channel_default_bufferize(__int64 *a1, const void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_open_session(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_open_auth_agent(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_open_forward(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall ssh_channel_free(__int64 *a1);
void __fastcall ssh_channel_do_free(__int64 *a1);
__int64 __fastcall ssh_channel_send_eof(__int64 a1);
__int64 __fastcall ssh_channel_close(__int64 a1);
_BOOL8 __fastcall ssh_channel_waitwindow_termination(_DWORD *a1);
_BOOL8 __fastcall ssh_waitsession_unblocked(__int64 a1);
__int64 __fastcall ssh_channel_flush(__int64 *a1);
__int64 __fastcall channel_write_common(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_window_size(__int64 a1);
__int64 __fastcall ssh_channel_write(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL8 __fastcall ssh_channel_is_open(_DWORD *a1);
__int64 __fastcall ssh_channel_is_closed(_DWORD *a1);
__int64 __fastcall ssh_channel_is_eof(__int64 a1);
__int64 __fastcall ssh_channel_set_blocking(__int64 *a1, int a2);
__int64 __fastcall ssh_packet_channel_success(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall ssh_packet_channel_failure(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_BOOL8 __fastcall ssh_channel_request_termination(_DWORD *a1);
__int64 __fastcall channel_request(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall ssh_channel_request_pty_size(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_request_pty(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_change_pty_size(__int64 *a1, unsigned int a2, unsigned int a3);
__int64 __fastcall ssh_channel_request_shell(__int64 a1);
__int64 __fastcall ssh_channel_request_subsystem(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_request_sftp(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
char *generate_cookie();
__int64 __fastcall ssh_channel_request_x11(__int64 a1, int a2, const char *a3, char *a4, unsigned int a5);
__int64 *__fastcall ssh_channel_accept(__int64 a1, int a2, int a3, _DWORD *a4, __int64 a5, __int64 a6);
__int64 *__fastcall ssh_channel_accept_x11(__int64 *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_request_auth_agent(__int64 a1);
__int64 __fastcall ssh_request_success(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_request_denied(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL8 __fastcall ssh_global_request_termination(__int64 a1);
__int64 __fastcall global_request(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall ssh_channel_listen_forward(__int64 a1, void *a2, unsigned int a3, _DWORD *a4);
__int64 __fastcall ssh_forward_listen(__int64 a1, void *a2, unsigned int a3, _DWORD *a4);
__int64 *__fastcall ssh_forward_accept(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 *__fastcall ssh_channel_accept_forward(__int64 a1, int a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_cancel_forward(__int64 a1, void *a2, unsigned int a3);
__int64 __fastcall ssh_forward_cancel(__int64 a1, void *a2, unsigned int a3);
__int64 __fastcall ssh_channel_request_env(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_request_exec(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_request_send_signal(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_request_send_break(__int64 *a1, unsigned int a2);
__int64 __fastcall channel_read_buffer(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL8 __fastcall ssh_channel_read_termination(__int64 a1);
__int64 __fastcall ssh_channel_read(__int64 a1, void *a2, unsigned int a3, unsigned int a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_read_timeout(__int64 a1, void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_read_nonblocking(__int64 *a1, void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_poll(__int64 a1, int a2);
__int64 __fastcall ssh_channel_poll_timeout(__int64 a1, unsigned int a2, int a3);
__int64 __fastcall ssh_channel_get_session(__int64 a1);
_BOOL8 __fastcall ssh_channel_exit_status_termination(_DWORD *a1);
__int64 __fastcall ssh_channel_get_exit_status(__int64 a1);
__int64 __fastcall channel_protocol_select(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall count_ptrs(__int64 a1);
__int64 __fastcall ssh_channel_select(__int64 *a1, __int64 *a2, __int64 *a3, _QWORD *a4);
__int64 __fastcall ssh_channel_set_counter(__int64 a1, __int64 a2);
__int64 __fastcall ssh_channel_write_stderr(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_open_reverse_forward(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_open_x11(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_channel_request_send_exit_status(__int64 *a1, unsigned int a2);
__int64 __fastcall ssh_channel_request_send_exit_signal(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall socket_callback_connected(unsigned int a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall callback_receive_banner(const char *a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_send_banner(__int64 a1, int a2);
__int64 __fastcall dh_handshake(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL8 __fastcall ssh_service_request_termination(__int64 a1);
__int64 __fastcall ssh_service_request(__int64 a1, __int64 a2);
__int64 __fastcall ssh_client_connection_callback(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL8 __fastcall ssh_connect_termination(__int64 a1);
__int64 __fastcall ssh_connect(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void *__fastcall ssh_get_issue_banner(__int64 a1);
__int64 __fastcall ssh_get_openssh_version(__int64 a1);
void __fastcall ssh_disconnect(__int64 a1);
const char *ssh_copyright();
__int64 __fastcall ssh_client_curve25519_init(__int64 a1);
__int64 __fastcall ssh_curve25519_build_k(__int64 a1);
__int64 __fastcall ssh_client_curve25519_reply(__int64 a1, __int64 a2);
__int64 __fastcall ssh_server_curve25519_init(__int64 a1, __int64 a2);
__int64 __fastcall select_p(int a1);
__int64 ssh_dh_init(void); // weak
__int64 ssh_dh_finalize(void); // weak
__int64 __fastcall ssh_dh_generate_x(__int64 a1);
__int64 __fastcall ssh_dh_generate_y(__int64 a1);
__int64 __fastcall ssh_dh_generate_e(__int64 a1);
__int64 __fastcall ssh_dh_generate_f(__int64 a1);
_BYTE *__fastcall ssh_dh_get_e(__int64 a1);
_BYTE *__fastcall ssh_dh_get_f(__int64 a1);
__int64 __fastcall ssh_dh_import_pubkey_blob(__int64 a1, uint32_t *a2);
__int64 __fastcall ssh_dh_import_next_pubkey_blob(__int64 a1, uint32_t *a2);
__int64 __fastcall ssh_dh_import_f(__int64 a1, uint32_t *a2);
__int64 __fastcall ssh_dh_import_e(__int64 a1, uint32_t *a2);
__int64 __fastcall ssh_dh_build_k(__int64 a1);
__int64 __fastcall ssh_client_dh_init(__int64 a1);
__int64 __fastcall ssh_client_dh_reply(__int64 a1, __int64 a2);
__int64 __fastcall ssh_make_sessionid(__int64 a1);
__int64 __fastcall ssh_hashbufout_add_cookie(__int64 a1);
__int64 __fastcall ssh_hashbufin_add_cookie(__int64 a1, const void *a2);
__int64 __fastcall generate_one_key(uint32_t *a1, __int64 a2, void **a3, char a4, unsigned __int64 a5);
__int64 __fastcall ssh_generate_session_keys(__int64 a1);
__int64 __fastcall ssh_get_pubkey_hash(__int64 a1, void **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void **__fastcall ssh_clean_pubkey_hash(void **a1);
__int64 __fastcall ssh_get_server_publickey(__int64 a1, _QWORD *a2);
__int64 __fastcall ssh_dh_get_current_server_publickey(__int64 a1);
__int64 __fastcall ssh_dh_get_current_server_publickey_blob(__int64 a1, uint32_t **a2);
__int64 __fastcall ssh_dh_get_next_server_publickey(__int64 a1);
__int64 __fastcall ssh_dh_get_next_server_publickey_blob(__int64 a1, uint32_t **a2);
__int64 __fastcall ssh_get_publickey(__int64 a1, _QWORD *a2);
__int64 __fastcall ssh_get_publickey_hash(__int64 a1, int a2, void **a3, _QWORD *a4);
_BYTE *__fastcall ssh_get_hexa(__int64 a1, unsigned __int64 a2);
void __fastcall ssh_print_hexa(const char *a1, __int64 a2, unsigned __int64 a3);
unsigned __int64 ssh_set_error(__int64 a1, int a2, const char *a3, const char *a4, __int64 a5, __int64 a6, ...);
__int64 __fastcall ssh_set_error_oom(__int64 a1, const char *a2);
unsigned __int64 __fastcall ssh_set_error_invalid(__int64 a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_get_error(__int64 a1);
__int64 __fastcall ssh_get_error_code(unsigned int *a1);
__int64 __fastcall ssh_init(int a1);
__int64 libssh_constructor(); // weak
__int64 ssh_init(void); // weak
__int64 __fastcall ssh_finalize(int a1);
__int64 libssh_destructor(); // weak
__int64 ssh_finalize(); // weak
_QWORD *__fastcall tokenize(const char *a1);
_QWORD *__fastcall ssh_space_tokenize(const char *a1);
char *__fastcall ssh_kex_get_supported_method(unsigned int a1);
char *__fastcall ssh_kex_get_description(unsigned int a1);
char *__fastcall ssh_find_matching(const char *a1, const char *a2);
_BYTE *__fastcall ssh_find_all_matching(const char *a1, const char *a2);
_BOOL8 __fastcall cmp_first_kex_algo(const char *a1, const char *a2);
__int64 __fastcall ssh_packet_kexinit(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
unsigned __int64 __fastcall ssh_list_kex(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
char *__fastcall ssh_client_select_hostkeys(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_set_client_kex(__int64 a1);
__int64 __fastcall ssh_kex_select_methods(__int64 a1);
__int64 __fastcall ssh_send_kex(__int64 *a1, int a2);
__int64 __fastcall ssh_verify_existing_algo(unsigned int a1, const char *a2);
_BYTE *__fastcall ssh_keep_known_algos(unsigned int a1, const char *a2);
__int64 __fastcall hash_hostname(const char *a1, __int64 a2, int a3, void **a4, _DWORD *a5);
__int64 __fastcall match_hashed_hostname(const char *a1, const char *a2);
void __fastcall ssh_knownhosts_entry_free(void **a1);
__int64 __fastcall known_hosts_read_line(FILE *a1, char *a2, int a3, size_t *a4, _QWORD *a5);
__int64 __fastcall ssh_known_hosts_read_entries(char *a1, const char *a2, _QWORD *a3);
char *__fastcall ssh_session_get_host_port(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD **__fastcall ssh_known_hosts_get_algorithms(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_known_hosts_parse_line(char *a1, const char *a2, void ***a3);
__int64 __fastcall ssh_session_has_known_hosts_entry(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_session_export_known_hosts_entry(__int64 a1, char **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_session_update_known_hosts(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_known_hosts_check_server_key(char *a1, const char *a2, unsigned int *a3, _QWORD *a4);
__int64 __fastcall ssh_session_get_known_hosts_entry(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_session_is_known_server(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall current_timestring(int a1, char *a2, size_t a3);
unsigned __int64 __fastcall ssh_log_stderr(unsigned int a1, const char *a2, const char *a3);
unsigned __int64 __fastcall ssh_log_function(unsigned int a1, const char *a2, const char *a3);
unsigned __int64 ssh_log(signed int a1, const char *a2, const char *a3, __int64 a4, __int64 a5, __int64 a6, ...);
unsigned __int64 ssh_log(__int64 a1, signed int a2, const char *a3, __int64 a4, __int64 a5, __int64 a6, ...);
unsigned __int64 ssh_log_common(__int64 a1, signed int a2, const char *a3, const char *a4, __int64 a5, __int64 a6, ...);
__int64 __fastcall ssh_set_log_level(int a1);
__int64 ssh_get_log_level(void); // weak
__int64 __fastcall ssh_set_log_callback(__int64 a1);
__int64 ssh_get_log_callback(void); // weak
__int64 ssh_get_log_userdata(void); // weak
__int64 __fastcall ssh_set_log_userdata(__int64 a1);
_BOOL8 __fastcall match_pattern(_BYTE *a1, _BYTE *a2);
__int64 __fastcall match_pattern_list(_BYTE *a1, __int64 a2, unsigned int a3, int a4);
__int64 __fastcall match_hostname(_BYTE *a1, __int64 a2, unsigned int a3);
_QWORD *__fastcall ssh_message_new(__int64 a1);
__int64 __fastcall ssh_execute_server_request(__int64 a1, __int64 a2);
__int64 __fastcall ssh_execute_client_request(__int64 a1, __int64 a2);
__int64 __fastcall ssh_execute_server_callbacks(__int64 a1, __int64 a2);
__int64 __fastcall ssh_execute_message_callback(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall ssh_message_queue(__int64 *a1, __int64 a2);
__int64 __fastcall ssh_message_pop_head(__int64 a1);
_BOOL8 __fastcall ssh_message_termination(__int64 a1);
__int64 __fastcall ssh_message_get(__int64 a1);
__int64 __fastcall ssh_message_type(__int64 a1);
__int64 __fastcall ssh_message_subtype(_DWORD *a1);
void __fastcall ssh_message_free(__int64 a1);
__int64 __fastcall ssh_packet_service_request(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
void *__fastcall ssh_msg_userauth_build_digest(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall ssh_packet_userauth_request(__int64 *a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall ssh_packet_userauth_info_response(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall ssh_packet_channel_open(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall ssh_message_channel_request_open_reply_accept_channel(__int64 a1, _DWORD *a2);
__int64 *__fastcall ssh_message_channel_request_open_reply_accept(__int64 *a1);
__int64 __fastcall ssh_message_handle_channel_request(__int64 *a1, __int64 a2, __int64 a3, const char *a4, unsigned __int8 a5);
__int64 __fastcall ssh_message_channel_request_reply_success(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_global_request(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
char *ssh_get_user_home_dir();
_BOOL8 __fastcall ssh_file_readaccess_ok(const char *a1);
char *ssh_get_local_username();
_BOOL8 __fastcall ssh_is_ipaddr_v4(const char *a1);
_BOOL8 __fastcall ssh_is_ipaddr(const char *a1);
char *__fastcall ssh_lowercase(const char *a1);
char *__fastcall ssh_hostport(const char *a1, unsigned int a2);
const char *__fastcall ssh_version(int a1);
_QWORD *ssh_list_new();
void __fastcall ssh_list_free(_QWORD **a1);
__int64 __fastcall ssh_list_get_iterator(__int64 a1);
_QWORD *__fastcall ssh_list_find(__int64 a1, __int64 a2);
__int64 __fastcall ssh_list_count(__int64 a1);
_QWORD *__fastcall ssh_iterator_new(__int64 a1);
__int64 __fastcall ssh_list_append(__int64 a1, __int64 a2);
__int64 __fastcall ssh_list_prepend(_QWORD *a1, __int64 a2);
void __fastcall ssh_list_remove(__int64 a1, _QWORD *a2);
__int64 __fastcall ssh_list_pop_head(__int64 a1);
char *__fastcall ssh_dirname(const char *a1);
char *__fastcall ssh_basename(const char *a1);
__int64 __fastcall ssh_mkdir(const char *a1, __mode_t a2);
char *__fastcall ssh_path_expand_tilde(const char *a1);
char *__fastcall ssh_path_expand_escape(__int64 a1, const char *a2);
__int64 __fastcall ssh_analyze_banner(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__time_t *__fastcall ssh_timestamp_init(__time_t *a1);
__int64 __fastcall ssh_timestamp_difference(_QWORD *a1, _QWORD *a2);
__int64 __fastcall ssh_make_milliseconds(int a1, __int64 a2);
_BOOL8 __fastcall ssh_timeout_elapsed(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_timeout_update(_QWORD *a1, int a2);
_BOOL8 __fastcall ssh_match_group(const char *a1, const char *a2);
void *__fastcall explicit_bzero(void *a1, size_t a2);
__int64 __fastcall ssh_options_copy(__int64 a1, __int64 **a2);
__int64 __fastcall ssh_options_set_algo(__int64 a1, unsigned int a2, const char *a3);
__int64 __fastcall ssh_options_set(__int64 a1, unsigned int a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_options_get_port(__int64 a1, _DWORD *a2);
__int64 __fastcall ssh_options_get(__int64 *a1, unsigned int a2, char **a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_options_getopt(__int64 a1, int *a2, char *const *a3);
__int64 __fastcall ssh_options_parse_config(__int64 a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_options_apply(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_bind_set_key(__int64 a1, void **a2, const char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_bind_options_set(__int64 a1, unsigned int a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall ssh_packet_socket_callback(_QWORD *a1, unsigned __int64 a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_socket_controlflow_callback(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_register_socket_callback(_QWORD *a1, __int64 a2);
__int64 __fastcall ssh_packet_set_callbacks(__int64 a1, __int64 a2);
__int64 __fastcall ssh_packet_set_default_callbacks(__int64 a1);
unsigned __int64 __fastcall ssh_packet_process(__int64 a1, unsigned __int8 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_send_unimplemented(__int64 a1, unsigned int a2);
__int64 __fastcall ssh_packet_unimplemented(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall ssh_packet_parse_type(__int64 *a1);
__int64 __fastcall ssh_packet_write(__int64 a1);
__int64 __fastcall packet_send2(__int64 a1);
__int64 __fastcall ssh_packet_send(__int64 a1);
__int64 __fastcall ssh_packet_disconnect_callback(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall ssh_packet_ignore_callback(__int64 a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_dh_reply(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_newkeys(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_service_accept(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
uint32_t __fastcall ssh_packet_decrypt_len(__int64 a1, uint32_t *a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_decrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_encrypt(__int64 a1, void *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_hmac_verify(__int64 a1, __int64 a2, const void *a3, int a4);
void *ssh_pcap_file_new();
__int64 __fastcall ssh_pcap_file_write(FILE **a1, __int64 a2);
__int64 __fastcall ssh_pcap_file_write_packet(FILE **a1, __int64 a2, uint32_t a3);
__int64 __fastcall ssh_pcap_file_open(FILE **a1, const char *a2);
__int64 __fastcall ssh_pcap_file_close(FILE **a1);
void __fastcall ssh_pcap_file_free(FILE **a1);
_QWORD *__fastcall ssh_pcap_context_new(__int64 a1);
void __fastcall ssh_pcap_context_free(void *a1);
__int64 __fastcall ssh_pcap_context_set_file(__int64 a1, __int64 a2);
__int64 __fastcall ssh_pcap_context_connect(__int64 a1);
__int64 __fastcall ssh_pcap_context_write(__int64 a1, int a2, __int64 a3, unsigned int a4, int a5);
__int64 __fastcall ssh_set_pcap_file(__int64 a1, __int64 a2);
__int64 __fastcall pki_privatekey_type_from_string(const char *a1);
const char *__fastcall ssh_pki_key_ecdsa_name(__int64 a1);
void *ssh_key_new();
_QWORD *__fastcall ssh_key_dup(__int64 a1);
__int64 __fastcall ssh_key_clean(__int64 a1);
void __fastcall ssh_key_free(void *a1);
__int64 __fastcall ssh_key_type(unsigned int *a1);
const char *__fastcall ssh_key_type_to_char(int a1);
__int64 __fastcall ssh_key_type_from_name(const char *a1);
_BOOL8 __fastcall ssh_key_is_public(__int64 a1);
_BOOL8 __fastcall ssh_key_is_private(__int64 a1);
__int64 __fastcall ssh_key_cmp(_DWORD *a1, _DWORD *a2, int a3, __int64 a4, __int64 a5, __int64 a6);
void *ssh_signature_new();
void __fastcall ssh_signature_free(void *a1);
__int64 __fastcall ssh_pki_import_privkey_base64(char *a1, char *a2, __int64 (__fastcall *a3)(const char *, char *, __int64, _QWORD, _QWORD, __int64), const char *a4, _QWORD *a5, __int64 a6);
__int64 __fastcall ssh_pki_import_privkey_file(const char *a1, char *a2, __int64 (__fastcall *a3)(const char *, char *, __int64, _QWORD, _QWORD, __int64), const char *a4, _QWORD *a5);
__int64 __fastcall ssh_pki_export_privkey_file(_DWORD *a1, char *a2, unsigned int (__fastcall *a3)(const char *, char *, __int64, _QWORD, _QWORD, __int64), __int64 a4, const char *a5);
_QWORD *__fastcall ssh_pki_convert_key_to_publickey(__int64 a1);
_QWORD *__fastcall ssh_pki_convert_key_to_privatekey(_QWORD *a1);
__int64 __fastcall pki_import_pubkey_buffer(__int64 a1, unsigned int a2, _QWORD *a3);
__int64 __fastcall pki_import_cert_buffer(__int64 a1, int a2, _QWORD *a3);
__int64 __fastcall ssh_pki_import_pubkey_base64(const char *a1, unsigned int a2, _QWORD *a3);
__int64 __fastcall ssh_pki_import_pubkey_blob(uint32_t *a1, _QWORD *a2);
__int64 __fastcall ssh_pki_import_pubkey_file(const char *a1, _QWORD *a2);
__int64 __fastcall ssh_pki_import_cert_base64(const char *a1, unsigned int a2, _QWORD *a3);
__int64 __fastcall ssh_pki_import_cert_blob(uint32_t *a1, _QWORD *a2);
__int64 __fastcall ssh_pki_import_cert_file(const char *a1, _QWORD *a2);
__int64 __fastcall ssh_pki_generate(unsigned int a1, unsigned int a2, _QWORD *a3);
__int64 __fastcall ssh_pki_export_privkey_to_pubkey(__int64 a1, _QWORD *a2);
__int64 __fastcall ssh_pki_export_pubkey_blob(__int64 a1, uint32_t **a2);
__int64 __fastcall ssh_pki_export_pubkey_base64(__int64 a1, _QWORD *a2);
__int64 __fastcall ssh_pki_export_pubkey_file(__int64 a1, const char *a2);
__int64 __fastcall ssh_pki_copy_cert_to_privkey(__int64 a1, __int64 a2);
__int64 __fastcall ssh_pki_export_signature_blob(__int64 a1, uint32_t **a2);
__int64 __fastcall ssh_pki_import_signature_blob(uint32_t *a1, __int64 a2, _QWORD *a3);
__int64 __fastcall ssh_pki_signature_verify_blob(__int64 a1, uint32_t *a2, _DWORD *a3, void *a4, __int64 a5);
uint32_t *__fastcall ssh_pki_do_sign(__int64 a1, __int64 a2, _DWORD *a3);
void *__fastcall ssh_pki_do_sign_agent(__int64 a1, __int64 a2, __int64 a3);
uint32_t *__fastcall ssh_srv_pki_do_sign_sessionid(__int64 a1, __int64 a2);
__int64 __fastcall pki_openssh_import_privkey_blob(__int64 a1, _QWORD *a2);
__int64 __fastcall pki_private_key_decrypt(uint32_t *a1, char *a2, const char *a3, const char *a4, uint32_t *a5, __int64 (__fastcall *a6)(const char *, char *, __int64, _QWORD, _QWORD, __int64), __int64 a7);
void *__fastcall ssh_pki_openssh_privkey_import(char *a1, char *a2, __int64 (__fastcall *a3)(const char *, char *, __int64, _QWORD, _QWORD, __int64), __int64 a4);
__int64 __fastcall pki_openssh_export_privkey_blob(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall pki_private_key_encrypt(__int64 a1, char *a2, const char *a3, const char *a4, unsigned int (__fastcall *a5)(const char *, char *, __int64, _QWORD, _QWORD, __int64), __int64 a6, unsigned int a7, uint32_t *a8);
_BYTE *__fastcall ssh_pki_openssh_privkey_export(__int64 a1, char *a2, unsigned int (__fastcall *a3)(const char *, char *, __int64, _QWORD, _QWORD, __int64), __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall pki_key_generate_ed25519(__int64 a1);
__int64 __fastcall pki_ed25519_sign(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall pki_ed25519_verify(__int64 a1, __int64 a2, const void *a3, size_t a4);
_BOOL8 __fastcall pki_ed25519_key_cmp(__int64 a1, __int64 a2, int a3);
__int64 __fastcall pki_ed25519_key_dup(__int64 a1, __int64 a2);
__int64 __fastcall pki_ed25519_public_key_to_blob(__int64 a1, __int64 a2);
uint32_t *__fastcall pki_ed25519_sig_to_blob(__int64 a1);
__int64 __fastcall pki_ed25519_sig_from_blob(__int64 a1, uint32_t *a2);
void ssh_poll_init();
void ssh_poll_cleanup();
int __fastcall ssh_poll(struct pollfd *a1, nfds_t a2, int a3);
void *__fastcall ssh_poll_new(int a1, __int16 a2, __int64 a3, __int64 a4);
void __fastcall ssh_poll_free(_QWORD *a1);
__int64 __fastcall ssh_poll_get_ctx(__int64 a1);
__int64 __fastcall ssh_poll_get_events(__int64 a1);
__int64 __fastcall ssh_poll_set_events(__int64 *a1, unsigned __int16 a2);
unsigned __int64 __fastcall ssh_poll_set_fd(_QWORD *a1, unsigned int a2);
__int64 __fastcall ssh_poll_add_events(__int64 *a1, __int16 a2);
__int64 __fastcall ssh_poll_remove_events(__int64 *a1, __int16 a2);
__int64 __fastcall ssh_poll_get_fd(_QWORD *a1);
__int64 __fastcall ssh_poll_set_callback(__int64 a1, __int64 a2, __int64 a3);
_QWORD *__fastcall ssh_poll_ctx_new(__int64 a1);
void __fastcall ssh_poll_ctx_free(__int64 a1);
__int64 __fastcall ssh_poll_ctx_resize(__int64 a1, __int64 a2);
__int64 __fastcall ssh_poll_ctx_add(_QWORD *a1, __int64 a2);
__int64 __fastcall ssh_poll_ctx_add_socket(_QWORD *a1, __int64 a2);
unsigned __int64 __fastcall ssh_poll_ctx_remove(_QWORD *a1, _QWORD *a2);
__int64 __fastcall ssh_poll_ctx_dopoll(__int64 a1, int a2);
__int64 __fastcall ssh_poll_get_default_ctx(__int64 a1);
_QWORD *ssh_event_new();
__int64 __fastcall ssh_event_fd_wrapper_callback(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4);
__int64 __fastcall ssh_event_add_fd(_QWORD **a1, int a2, __int16 a3, __int64 a4, __int64 a5);
__int64 __fastcall ssh_event_add_poll(_QWORD **a1, __int64 a2);
unsigned __int64 __fastcall ssh_event_remove_poll(_QWORD **a1, _QWORD *a2);
__int64 __fastcall ssh_event_add_session(__int64 a1, __int64 a2);
__int64 __fastcall ssh_event_add_connector(_QWORD **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_event_dopoll(__int64 *a1, int a2);
__int64 __fastcall ssh_event_remove_fd(__int64 a1, int a2);
__int64 __fastcall ssh_event_remove_session(__int64 *a1, __int64 a2);
__int64 __fastcall ssh_event_remove_connector(__int64 a1, __int64 a2);
void __fastcall ssh_event_free(_QWORD **a1);
__int64 *ssh_new();
void __fastcall ssh_free(__int64 a1);
__int64 __fastcall ssh_get_clientbanner(__int64 a1);
__int64 __fastcall ssh_get_serverbanner(__int64 a1);
const char *__fastcall ssh_get_kex_algo(__int64 a1);
__int64 __fastcall ssh_get_cipher_in(__int64 a1);
__int64 __fastcall ssh_get_cipher_out(__int64 a1);
char *__fastcall ssh_get_hmac_in(__int64 a1);
char *__fastcall ssh_get_hmac_out(__int64 a1);
void __fastcall ssh_silent_disconnect(__int64 a1);
__int64 __fastcall ssh_set_blocking(__int64 a1, int a2);
_BOOL8 __fastcall ssh_is_blocking(__int64 a1);
_BOOL8 __fastcall ssh_flush_termination(__int64 a1);
__int64 __fastcall ssh_blocking_flush(__int64 a1, unsigned int a2);
__int64 __fastcall ssh_is_connected(__int64 a1);
__int64 __fastcall ssh_get_fd(__int64 a1);
__int64 __fastcall ssh_set_fd_toread(__int64 a1);
__int64 __fastcall ssh_set_fd_towrite(__int64 a1);
__int64 __fastcall ssh_set_fd_except(__int64 a1);
__int64 __fastcall ssh_handle_packets(__int64 a1, int a2);
__int64 __fastcall ssh_handle_packets_termination(__int64 a1, unsigned int a2, unsigned int (__fastcall *a3)(__int64), __int64 a4);
__int64 __fastcall ssh_get_status(__int64 a1);
__int64 __fastcall ssh_get_poll_flags(__int64 a1);
__int64 __fastcall ssh_get_disconnect_message(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_get_version(__int64 a1);
__int64 __fastcall ssh_socket_exception_callback(unsigned int a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_send_ignore(__int64 a1, __int64 a2);
__int64 __fastcall ssh_send_debug(__int64 a1, __int64 a2, int a3);
__int64 __fastcall ssh_set_counters(__int64 a1, __int64 a2, __int64 a3);
__int64 ssh_socket_init(void); // weak
void ssh_socket_cleanup();
_QWORD *__fastcall ssh_socket_new(__int64 a1);
__int64 __fastcall ssh_socket_reset(__int64 a1);
__int64 __fastcall ssh_socket_set_callbacks(__int64 a1, __int64 a2);
__int64 __fastcall ssh_socket_pollcallback(__int64 *a1, unsigned int a2, char a3, int *a4);
__int64 __fastcall ssh_socket_get_poll_handle_in(__int64 a1);
__int64 __fastcall ssh_socket_get_poll_handle_out(__int64 a1);
void __fastcall ssh_socket_free(__int64 *a1);
__int64 __fastcall ssh_socket_unix(__int64 a1, const char *a2);
__int64 __fastcall ssh_socket_close(__int64 a1);
__int64 __fastcall ssh_socket_set_fd(__int64 a1, unsigned int a2);
unsigned __int64 __fastcall ssh_socket_set_fd_in(__int64 a1, unsigned int a2);
unsigned __int64 __fastcall ssh_socket_set_fd_out(__int64 a1, unsigned int a2);
__int64 __fastcall ssh_socket_get_fd_in(unsigned int *a1);
_BOOL8 __fastcall ssh_socket_is_open(_DWORD *a1);
__int64 __fastcall ssh_socket_unbuffered_read(int *a1, void *a2, unsigned int a3);
__int64 __fastcall ssh_socket_unbuffered_write(__int64 a1, const void *a2, unsigned int a3);
_BOOL8 __fastcall ssh_socket_fd_isset(_DWORD *a1, __int64 a2);
unsigned __int64 __fastcall ssh_socket_fd_set(int *a1, __int64 a2, int *a3);
__int64 __fastcall ssh_socket_write(__int64 a1, const void *a2, signed int a3);
__int64 __fastcall ssh_socket_nonblocking_flush(__int64 a1);
__int64 __fastcall ssh_socket_set_write_wontblock(__int64 a1);
__int64 __fastcall ssh_socket_set_read_wontblock(__int64 a1);
__int64 __fastcall ssh_socket_set_except(__int64 a1);
__int64 __fastcall ssh_socket_data_available(__int64 a1);
__int64 __fastcall ssh_socket_data_writable(__int64 a1);
__int64 __fastcall ssh_socket_buffered_write_bytes(__int64 a1);
__int64 __fastcall ssh_socket_get_status(__int64 a1);
__int64 __fastcall ssh_socket_get_poll_flags(__int64 a1);
int __fastcall ssh_socket_set_nonblocking(int a1);
int __fastcall ssh_socket_set_blocking(int a1);
__int64 __fastcall ssh_socket_connect(__int64 a1, const char *a2, unsigned int a3, const char *a4, __int64 a5, __int64 a6);
void __fastcall __noreturn ssh_execute_command(char *a1, int a2, int a3);
__int64 __fastcall ssh_socket_connect_proxycommand(__int64 a1, char *a2);
_BYTE *__fastcall ssh_string_new(unsigned __int64 a1);
__int64 __fastcall ssh_string_fill(uint32_t *a1, const void *a2, size_t a3);
_BYTE *__fastcall ssh_string_from_char(const char *a1);
__int64 __fastcall ssh_string_len(uint32_t *a1);
uint32_t *__fastcall ssh_string_get_char(uint32_t *a1);
void *__fastcall ssh_string_to_char(uint32_t *a1);
void __fastcall ssh_string_free_char(void *a1);
_BYTE *__fastcall ssh_string_copy(uint32_t *a1);
void __fastcall ssh_string_burn(uint32_t *a1);
__int64 __fastcall ssh_string_data(__int64 a1);
void __fastcall ssh_string_free(void *a1);
__int64 ssh_threads_init(void); // weak
void ssh_threads_finalize();
__int64 __fastcall ssh_threads_set_callbacks(__int64 a1);
__int64 ssh_threads_get_type(void); // weak
char **ssh_get_hmactab();
__int64 __fastcall hmac_digest_len(int a1);
char *__fastcall ssh_hmac_type_to_string(int a1);
void *__fastcall cipher_new(int a1);
__int64 __fastcall ssh_cipher_clear(__int64 a1);
void __fastcall cipher_free(void *a1);
void *crypto_new();
void __fastcall crypto_free(_QWORD *a1);
__int64 __fastcall crypt_set_algorithms2(__int64 a1);
__int64 __fastcall crypt_set_algorithms_client(__int64 a1);
__int64 __fastcall crypt_set_algorithms_server(__int64 a1);
unsigned __int64 __fastcall bcrypt_hash(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall bcrypt_pbkdf(__int64 a1, __int64 a2, const void *a3, size_t a4, __int64 a5, unsigned __int64 a6, unsigned int a7);
int *__fastcall Blowfish_encipher(_DWORD *a1, int *a2, int *a3);
int *__fastcall Blowfish_decipher(_DWORD *a1, int *a2, int *a3);
char *__fastcall Blowfish_initstate(char *a1);
__int64 __fastcall Blowfish_stream2word(__int64 a1, unsigned __int16 a2, _WORD *a3);
unsigned __int64 __fastcall Blowfish_expand0state(_DWORD *a1, __int64 a2, unsigned int a3);
unsigned __int64 __fastcall Blowfish_expandstate(_DWORD *a1, __int64 a2, unsigned int a3, __int64 a4, unsigned __int16 a5);
unsigned __int64 __fastcall ssh_blf_key(char *a1, __int64 a2, unsigned __int16 a3);
__int64 __fastcall ssh_blf_enc(_DWORD *a1, int *a2, unsigned __int16 a3);
__int64 __fastcall ssh_blf_dec(_DWORD *a1, int *a2, unsigned __int16 a3);
__int64 __fastcall ssh_blf_ecb_encrypt(_DWORD *a1, __int64 a2, unsigned int a3);
__int64 __fastcall ssh_blf_ecb_decrypt(_DWORD *a1, __int64 a2, unsigned int a3);
__int64 __fastcall ssh_blf_cbc_encrypt(_DWORD *a1, __int64 a2, __int64 a3, unsigned int a4);
_BYTE *__fastcall ssh_blf_cbc_decrypt(_DWORD *a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall crypto_verify_32(_BYTE *a1, _BYTE *a2);
__int64 __fastcall get_hram(void *a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5);
__int64 __fastcall crypto_sign_ed25519_keypair(__int64 a1, __int64 a2);
__int64 __fastcall crypto_sign_ed25519(__int64 a1, _QWORD *a2, __int64 a3, unsigned __int64 a4, __int64 a5);
__int64 __fastcall crypto_sign_ed25519_open(__int64 a1, _QWORD *a2, _BYTE *a3, unsigned __int64 a4, __int64 a5);
void __fastcall p1p1_to_p2(_DWORD *a1, __int64 a2);
void __fastcall p1p1_to_p3(_DWORD *a1, __int64 a2);
void __fastcall ge25519_mixadd2(_DWORD *a1, __int64 a2);
void __fastcall add_p1p1(_DWORD *a1, __int64 a2, __int64 a3);
void __fastcall dbl_p1p1(_DWORD *a1, __int64 a2);
__int64 __fastcall cmov_aff(__int64 a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall equal(char a1, char a2);
unsigned __int64 __fastcall negative(char a1);
__int64 __fastcall choose_t(_QWORD *a1, __int64 a2, char a3);
__int64 __fastcall setneutral(__int64 a1);
__int64 __fastcall crypto_sign_ed25519_ref_unpackneg_vartime(__int64 *a1, __int64 a2);
__int64 __fastcall crypto_sign_ed25519_ref_pack(__int64 a1, __int64 a2);
_BOOL8 __fastcall crypto_sign_ed25519_ref_isneutral_vartime(__int64 *a1);
unsigned __int64 __fastcall crypto_sign_ed25519_ref_double_scalarmult_vartime(__int64 a1, const void *a2, __int64 a3, const void *a4, __int64 a5);
unsigned __int64 __fastcall crypto_sign_ed25519_ref_scalarmult_base(__int64 a1, __int64 a2);
__int64 __fastcall lt(int a1, int a2);
unsigned __int64 __fastcall reduce_add_sub(__int64 a1);
unsigned __int64 __fastcall barrett_reduce(__int64 a1, __int64 a2);
unsigned __int64 __fastcall crypto_sign_ed25519_ref_sc25519_from32bytes(__int64 a1, __int64 a2);
__int64 __fastcall crypto_sign_ed25519_ref_shortsc25519_from16bytes(__int64 a1, __int64 a2);
unsigned __int64 __fastcall crypto_sign_ed25519_ref_sc25519_from64bytes(__int64 a1, __int64 a2);
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_from_shortsc(__int64 a1, __int64 a2);
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_to32bytes(__int64 a1, __int64 a2);
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_iszero_vartime(__int64 a1);
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_isshort_vartime(__int64 a1);
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_lt_vartime(__int64 a1, __int64 a2);
unsigned __int64 __fastcall crypto_sign_ed25519_ref_sc25519_add(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_sub_nored(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall crypto_sign_ed25519_ref_sc25519_mul(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall crypto_sign_ed25519_ref_sc25519_mul_shortsc(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_window3(__int64 a1, __int64 a2);
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_window5(__int64 a1, __int64 a2);
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_2interleave2(_BYTE *a1, __int64 a2, __int64 a3);
__int64 __fastcall ssh_pthread_mutex_init(pthread_mutex_t **a1);
__int64 __fastcall ssh_pthread_mutex_destroy(pthread_mutex_t **a1);
int __fastcall ssh_pthread_mutex_lock(pthread_mutex_t **a1);
int __fastcall ssh_pthread_mutex_unlock(pthread_mutex_t **a1);
pthread_t ssh_pthread_thread_id();
int __fastcall ssh_mutex_lock(pthread_mutex_t *a1);
int __fastcall ssh_mutex_unlock(pthread_mutex_t *a1);
char **ssh_threads_get_default();
char **ssh_threads_get_pthread();
__int64 __fastcall crypto_thread_init(_QWORD); // weak
void crypto_thread_finalize();
__int64 __fastcall alloc_key(__int64 a1);
void ssh_reseed();
__int64 __fastcall ssh_get_random(__int64 a1, int a2);
__int64 sha1_init(void); // weak
__int64 __fastcall sha1_update(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sha1_final(void *a1, __int64 a2);
__int64 __fastcall sha1(__int64 a1, int a2, __int64 a3);
__int64 __fastcall nid_to_md_algo(int a1);
_DWORD *__fastcall evp(int a1, __int64 a2, int a3, __int64 a4, _DWORD *a5);
__int64 __fastcall evp_init(int a1);
__int64 __fastcall evp_update(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall evp_final(__int64 a1, void *a2, _DWORD *a3);
__int64 sha256_init(); // weak
__int64 __fastcall sha256_update(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sha256_final(void *a1, __int64 a2);
__int64 __fastcall sha256(__int64 a1, int a2, __int64 a3);
__int64 sha384_init(); // weak
__int64 __fastcall sha384_update(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sha384_final(void *a1, __int64 a2);
__int64 __fastcall sha384(__int64 a1, int a2, __int64 a3);
__int64 sha512_init(void); // weak
__int64 __fastcall sha512_update(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sha512_final(void *a1, __int64 a2);
__int64 __fastcall sha512(__int64 a1, int a2, __int64 a3);
__int64 md5_init(void); // weak
__int64 __fastcall md5_update(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall md5_final(_QWORD *a1, __int64 a2);
_DWORD *__fastcall ssh_mac_ctx_init(unsigned int a1);
__int64 __fastcall ssh_mac_update(__int64 a1, __int64 a2, __int64 a3);
void __fastcall ssh_mac_final(void *a1, unsigned int *a2);
__int64 __fastcall hmac_init(__int64 a1, int a2, int a3);
__int64 __fastcall hmac_update(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall hmac_final(__int64 a1, void *a2, _DWORD *a3);
__int64 __fastcall blowfish_set_key(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall blowfish_encrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall blowfish_decrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall aes_set_key(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall aes_encrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall aes_decrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall des3_set_key(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall des3_encrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall des3_decrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char **ssh_get_ciphertab();
uint32_t *__fastcall ssh_sexp_extract_mpi(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4);
__int64 ssh_crypto_init(void); // weak
__int64 ssh_crypto_finalize(void); // weak
__int64 __fastcall gpg_err_code(unsigned __int16 a1);
__int64 __fastcall gcry_err_code(unsigned __int16 a1);
__int64 __fastcall load_iv(__int64 a1, void *a2, int a3);
__int64 __fastcall char_to_u32(__int64 a1, unsigned int a2);
__int64 __fastcall asn1_get_len(__int64 a1);
_BYTE *__fastcall asn1_get(__int64 a1, char a2);
_BYTE *__fastcall asn1_get_int(__int64 a1);
_BYTE *__fastcall asn1_get_bit_string(__int64 a1);
__int64 __fastcall asn1_check_sequence(__int64 a1);
__int64 __fastcall asn1_check_tag(__int64 a1, char a2);
__int64 __fastcall passphrase_to_key(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5);
__int64 __fastcall privatekey_decrypt(unsigned int a1, unsigned int a2, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, int (__fastcall *a7)(__int64, char *, __int64, _QWORD, _QWORD, const char *), const char *a8, __int64 a9);
__int64 __fastcall privatekey_dek_header(const char *a1, unsigned int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, void **a6, int *a7);
void *__fastcall privatekey_string_to_buffer(char *a1, int a2, int (__fastcall *a3)(__int64, char *, __int64, _QWORD, _QWORD, const char *), const char *a4, __int64 a5);
_BOOL8 __fastcall b64decode_rsa_privatekey(char *a1, __int64 a2, int (__fastcall *a3)(__int64, char *, __int64, _QWORD, _QWORD, const char *), const char *a4, __int64 a5);
_BOOL8 __fastcall b64decode_dsa_privatekey(char *a1, __int64 a2, int (__fastcall *a3)(__int64, char *, __int64, _QWORD, _QWORD, const char *), const char *a4, __int64 a5);
__int64 __fastcall pki_key_ecdsa_to_nid(__int64 a1);
const char *__fastcall pki_key_ecdsa_nid_to_gcrypt_name(int a1);
const char *__fastcall pki_key_ecdsa_nid_to_name(int a1);
const char *__fastcall pki_key_ecdsa_nid_to_char(int a1);
__int64 __fastcall pki_key_ecdsa_nid_from_name(const char *a1);
__int64 __fastcall asn1_oi_to_nid(uint32_t *a1);
_BOOL8 __fastcall b64decode_ecdsa_privatekey(char *a1, __int64 a2, int (__fastcall *a3)(__int64, char *, __int64, _QWORD, _QWORD, const char *), const char *a4, __int64 a5);
__int64 __fastcall pki_private_key_to_pem(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 *__fastcall pki_private_key_from_base64(char *a1, const char *a2, int (__fastcall *a3)(__int64, char *, __int64, _QWORD, _QWORD, const char *), const char *a4);
__int64 __fastcall pki_pubkey_build_dss(__int64 a1, uint32_t *a2, uint32_t *a3, uint32_t *a4, uint32_t *a5);
__int64 __fastcall pki_pubkey_build_rsa(__int64 a1, uint32_t *a2, uint32_t *a3);
__int64 __fastcall pki_pubkey_build_ecdsa(__int64 a1, int a2, uint32_t *a3);
_QWORD *__fastcall pki_key_dup(__int64 a1, int a2);
__int64 __fastcall pki_key_generate(__int64 a1, unsigned int a2, const char *a3, int a4);
__int64 __fastcall pki_key_generate_rsa(__int64 a1, unsigned int a2);
__int64 __fastcall pki_key_generate_dss(__int64 a1, unsigned int a2);
__int64 __fastcall pki_key_generate_ecdsa(__int64 a1, unsigned int a2);
__int64 __fastcall bignum_cmp(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall pki_key_compare(__int64 a1, __int64 a2, int a3);
uint32_t *__fastcall pki_publickey_to_blob(__int64 a1);
uint32_t *__fastcall pki_signature_to_blob(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_DWORD *__fastcall pki_signature_from_blob(__int64 a1, uint32_t *a2, unsigned int a3);
__int64 __fastcall pki_signature_verify(__int64 a1, _QWORD *a2, _DWORD *a3, void *a4, __int64 a5);
_QWORD *__fastcall pki_do_sign(__int64 a1, void *a2, size_t a3);
_QWORD *__fastcall pki_do_sign_sessionid(__int64 a1, void *a2, size_t a3);
const char *__fastcall ecdh_kex_type_to_curve(int a1);
__int64 __fastcall ssh_client_ecdh_init(__int64 a1);
__int64 __fastcall ecdh_build_k(__int64 a1);
__int64 __fastcall ssh_server_ecdh_init(__int64 a1, __int64 a2);
__int64 __fastcall server_set_kex(__int64 a1);
__int64 __fastcall ssh_server_init_kex(__int64 a1);
__int64 __fastcall ssh_server_kexdh_init(__int64 a1, __int64 a2);
__int64 __fastcall ssh_packet_kexdh_init(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_get_key_params(__int64 a1, __int64 *a2);
__int64 __fastcall dh_handshake_server(__int64 a1);
unsigned __int64 __fastcall ssh_server_connection_callback(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall callback_receive_banner_0(const char *a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_BOOL8 __fastcall ssh_server_kex_termination(__int64 a1);
__int64 __fastcall ssh_set_auth_methods(__int64 a1, char a2);
__int64 __fastcall ssh_handle_key_exchange(__int64 a1);
__int64 __fastcall ssh_auth_reply_default(__int64 a1, int a2);
__int64 __fastcall ssh_message_channel_request_open_reply_default(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_message_channel_request_reply_default(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_message_service_request_reply_default(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_message_service_reply_success(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_message_global_request_reply_success(__int64 a1, unsigned __int16 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_message_global_request_reply_default(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_message_reply_default(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_message_service_service(__int64 a1);
__int64 __fastcall ssh_message_auth_user(__int64 a1);
__int64 __fastcall ssh_message_auth_password(__int64 a1);
__int64 __fastcall ssh_message_auth_pubkey(__int64 a1);
_QWORD *__fastcall ssh_message_auth_publickey(__int64 a1);
__int64 __fastcall ssh_message_auth_publickey_state(__int64 a1);
__int64 __fastcall ssh_message_auth_kbdint_is_response(__int64 a1);
__int64 __fastcall ssh_message_auth_set_methods(__int64 a1, int a2);
__int64 __fastcall ssh_message_auth_interactive_request(__int64 *a1, const char *a2, const char *a3, unsigned int a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_auth_reply_success(__int64 a1, int a2);
__int64 __fastcall ssh_message_auth_reply_success(__int64 *a1, int a2);
__int64 __fastcall ssh_message_auth_reply_pk_ok(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall ssh_message_auth_reply_pk_ok_simple(__int64 *a1);
__int64 __fastcall ssh_message_channel_request_open_originator(__int64 a1);
__int64 __fastcall ssh_message_channel_request_open_originator_port(__int64 a1);
__int64 __fastcall ssh_message_channel_request_open_destination(__int64 a1);
__int64 __fastcall ssh_message_channel_request_open_destination_port(__int64 a1);
__int64 __fastcall ssh_message_channel_request_channel(__int64 a1);
__int64 __fastcall ssh_message_channel_request_pty_term(__int64 a1);
__int64 __fastcall ssh_message_channel_request_pty_width(__int64 a1);
__int64 __fastcall ssh_message_channel_request_pty_height(__int64 a1);
__int64 __fastcall ssh_message_channel_request_pty_pxwidth(__int64 a1);
__int64 __fastcall ssh_message_channel_request_pty_pxheight(__int64 a1);
__int64 __fastcall ssh_message_channel_request_env_name(__int64 a1);
__int64 __fastcall ssh_message_channel_request_env_value(__int64 a1);
__int64 __fastcall ssh_message_channel_request_command(__int64 a1);
__int64 __fastcall ssh_message_channel_request_subsystem(__int64 a1);
_BOOL8 __fastcall ssh_message_channel_request_x11_single_connection(__int64 a1);
__int64 __fastcall ssh_message_channel_request_x11_auth_protocol(__int64 a1);
__int64 __fastcall ssh_message_channel_request_x11_auth_cookie(__int64 a1);
__int64 __fastcall ssh_message_channel_request_x11_screen_number(__int64 a1);
__int64 __fastcall ssh_message_global_request_address(__int64 a1);
__int64 __fastcall ssh_message_global_request_port(__int64 a1);
__int64 __fastcall ssh_set_message_callback(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall ssh_execute_message_callbacks(__int64 a1);
__int64 __fastcall ssh_send_keepalive(__int64 a1);
__int64 __fastcall bind_socket(__int64 a1, const char *a2, unsigned int a3);
_DWORD *ssh_bind_new();
__int64 __fastcall ssh_bind_import_keys(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_bind_listen(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_bind_set_callbacks(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_bind_poll_callback(__int64 a1, __int64 a2, char a3, __int64 a4);
__int64 __fastcall ssh_bind_get_poll(__int64 a1);
__int64 __fastcall ssh_bind_set_blocking(__int64 a1, int a2);
__int64 __fastcall ssh_bind_get_fd(__int64 a1);
__int64 __fastcall ssh_bind_set_fd(__int64 a1, int a2);
__int64 __fastcall ssh_bind_fd_toaccept(__int64 a1);
void __fastcall ssh_bind_free(__int64 a1);
__int64 __fastcall ssh_bind_accept_fd(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_bind_accept(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void *__fastcall initcompress(__int64 a1, unsigned int a2);
void *__fastcall gzip_compress(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall compress_buffer(__int64 a1, __int64 a2);
void *__fastcall initdecompress(__int64 a1);
void *__fastcall gzip_decompress(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall decompress_buffer(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall crypto_scalarmult_base(__int64 a1, __int64 a2);
__int64 __fastcall add(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall squeeze(__int64 a1);
__int64 __fastcall freeze(__int64 a1);
__int64 __fastcall mult(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall mult121665(__int64 a1, __int64 a2);
__int64 __fastcall square(__int64 a1, __int64 a2);
__int64 __fastcall c_select(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5);
void __fastcall mainloop(__int64 a1, __int64 a2);
__int64 __fastcall recip(__int64 a1, __int64 a2);
__int64 __fastcall crypto_scalarmult(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall agent_get_u32(unsigned int *a1);
_BYTE *__fastcall agent_put_u32(_BYTE *a1, int a2);
unsigned __int64 __fastcall atomicio(__int64 a1, __int64 a2, unsigned __int64 a3, int a4, __int64 a5, __int64 a6);
_QWORD *__fastcall ssh_agent_new(__int64 a1);
__int64 __fastcall agent_set_channel(__int64 a1, __int64 a2);
__int64 __fastcall ssh_set_agent_channel(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_set_agent_socket(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_agent_close(__int64 *a1);
void __fastcall ssh_agent_free(__int64 *a1);
__int64 __fastcall agent_connect(__int64 a1);
__int64 __fastcall agent_talk(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall ssh_agent_get_ident_count(__int64 a1);
__int64 __fastcall ssh_agent_get_first_ident(__int64 a1, void **a2);
__int64 __fastcall ssh_agent_get_next_ident(__int64 a1, void **a2);
_BOOL8 __fastcall ssh_agent_is_running(__int64 a1);
void *__fastcall ssh_agent_sign_data(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall ssh_userauth_request_service(__int64 a1);
_BOOL8 __fastcall ssh_auth_response_termination(__int64 a1);
__int64 __fastcall ssh_userauth_get_response(__int64 a1);
__int64 __fastcall ssh_packet_userauth_banner(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall ssh_packet_userauth_failure(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall ssh_packet_userauth_success(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_userauth_pk_ok(__int64 a1, unsigned __int8 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_userauth_list(__int64 a1);
__int64 __fastcall ssh_userauth_none(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_userauth_try_publickey(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_userauth_publickey(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_userauth_agent_publickey(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall ssh_agent_state_free(void **a1);
__int64 __fastcall ssh_userauth_agent(__int64 a1, __int64 a2);
__int64 __fastcall ssh_userauth_publickey_auto(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_userauth_password(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_userauth_agent_pubkey(__int64 a1, __int64 a2, __int64 a3);
void *ssh_kbdint_new();
void __fastcall ssh_kbdint_free(void **a1);
void __fastcall ssh_kbdint_clean(void **a1);
__int64 __fastcall ssh_userauth_kbdint_init(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_userauth_kbdint_send(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_packet_userauth_info_request(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall ssh_userauth_kbdint(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_userauth_kbdint_getnprompts(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_userauth_kbdint_getname(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_userauth_kbdint_getinstruction(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_userauth_kbdint_getprompt(__int64 a1, unsigned int a2, _BYTE *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_userauth_kbdint_getnanswers(__int64 a1);
__int64 __fastcall ssh_userauth_kbdint_getanswer(__int64 a1, unsigned int a2);
__int64 __fastcall ssh_userauth_kbdint_setanswer(__int64 a1, unsigned int a2, const char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 ssh_userauth_gssapi(); // weak
void *__fastcall base64_to_bin(const char *a1);
__int64 __fastcall to_block4(_QWORD *a1, char *a2, int a3);
__int64 __fastcall base64_to_bin(_BYTE *a1, char *a2, int a3);
__int64 __fastcall get_equals(const char *a1);
unsigned __int64 __fastcall bin_to_base64(_BYTE *a1, _BYTE *a2, unsigned int a3);
_BYTE *__fastcall bin_to_base64(_BYTE *a1, int a2);
_BYTE *__fastcall ssh_make_bignum_string(__int64 a1);
__int64 __fastcall ssh_make_string_bn(uint32_t *a1);
__int64 __fastcall ssh_make_string_bn_inplace(uint32_t *a1);
void __fastcall ssh_print_bignum(const char *a1, __int64 a2);
void *ssh_buffer_new();
void __fastcall ssh_buffer_free(__int64 a1);
__int64 __fastcall ssh_buffer_set_secure(__int64 a1);
__int64 __fastcall realloc_buffer(__int64 a1, size_t a2);
unsigned __int64 __fastcall buffer_shift(__int64 a1);
__int64 __fastcall ssh_buffer_reinit(__int64 a1);
__int64 __fastcall ssh_buffer_add_data(__int64 a1, const void *a2, unsigned int a3);
__int64 __fastcall ssh_buffer_allocate_size(__int64 a1, unsigned int a2);
__int64 __fastcall ssh_buffer_allocate(__int64 a1, unsigned int a2);
__int64 __fastcall ssh_buffer_add_ssh_string(__int64 a1, uint32_t *a2);
__int64 __fastcall ssh_buffer_add_u32(__int64 a1, int a2);
__int64 __fastcall ssh_buffer_add_u16(__int64 a1, __int16 a2);
__int64 __fastcall ssh_buffer_add_u64(__int64 a1, __int64 a2);
__int64 __fastcall ssh_buffer_add_u8(__int64 a1, char a2);
__int64 __fastcall ssh_buffer_prepend_data(__int64 a1, const void *a2, unsigned int a3);
__int64 __fastcall ssh_buffer_add_buffer(__int64 a1, __int64 a2);
__int64 __fastcall ssh_buffer_get(__int64 a1);
__int64 __fastcall ssh_buffer_get_len(__int64 a1);
__int64 __fastcall ssh_buffer_pass_bytes(__int64 a1, unsigned int a2);
__int64 __fastcall ssh_buffer_pass_bytes_end(__int64 a1, unsigned int a2);
__int64 __fastcall ssh_buffer_get_data(__int64 a1, void *a2, unsigned int a3);
__int64 __fastcall ssh_buffer_get_u8(__int64 a1, void *a2);
__int64 __fastcall ssh_buffer_get_u32(__int64 a1, void *a2);
__int64 __fastcall ssh_buffer_get_u64(__int64 a1, void *a2);
__int64 __fastcall ssh_buffer_validate_length(__int64 a1, unsigned __int64 a2);
void *__fastcall ssh_buffer_get_ssh_string(__int64 a1);
__int64 __fastcall ssh_buffer_pack_va(__int64 a1, _BYTE *a2, int a3, unsigned int *a4, __int64 a5, __int64 a6);
__int64 ssh_buffer_pack(__int64 a1, _BYTE *a2, int a3, ...);
__int64 __fastcall ssh_buffer_unpack_va(__int64 a1, _BYTE *a2, int a3, __int64 *a4);
__int64 ssh_buffer_unpack(__int64 a1, _BYTE *a2, int a3, ...);
__int64 __fastcall ssh_config_get_opcode(const char *a1);
_BYTE *__fastcall ssh_config_get_cmd(_BYTE **a1);
_BYTE *__fastcall ssh_config_get_token(_BYTE **a1);
__int64 __fastcall ssh_config_get_long(_BYTE **a1, __int64 a2);
_BYTE *__fastcall ssh_config_get_str_tok(_BYTE **a1, __int64 a2);
__int64 __fastcall ssh_config_get_yesno(_BYTE **a1, unsigned int a2);
unsigned __int64 __fastcall local_parse_file(__int64 a1, const char *a2, __int64 a3, __int64 a4);
void __fastcall local_parse_glob(__int64 a1, const char *a2, __int64 a3, __int64 a4);
__int64 __fastcall ssh_config_parse_line(__int64 a1, const char *a2, unsigned int a3, _DWORD *a4, __int64 a5);
__int64 __fastcall ssh_config_parse_file(__int64 a1, const char *a2);
int __fastcall ssh_connect_socket_close(int a1);
int __fastcall getai(const char *a1, int a2, struct addrinfo **a3);
__int64 __fastcall ssh_connect_ai_timeout(__int64 a1, __int64 a2, unsigned int a3, struct addrinfo *a4, __int64 a5, __int64 a6, unsigned int fd);
int __fastcall set_tcp_nodelay(int a1);
__int64 __fastcall ssh_connect_host(__int64 a1, const char *a2, const char *a3, unsigned int a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_connect_host_nonblocking(__int64 a1, const char *a2, const char *a3, unsigned int a4);
__int64 __fastcall ssh_select_cb(int a1, char a2, __int64 a3);
__int64 __fastcall ssh_select(__int64 a1, _QWORD *a2, int a3, _QWORD *a4, _QWORD *a5);
_DWORD *__fastcall ssh_connector_new(__int64 a1);
void __fastcall ssh_connector_free(__int64 a1);
__int64 __fastcall ssh_connector_set_in_channel(__int64 a1, __int64 *a2, int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_connector_set_out_channel(__int64 a1, __int64 *a2, int a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_connector_set_in_fd(__int64 a1, int a2);
__int64 __fastcall ssh_connector_set_out_fd(__int64 a1, int a2);
void ssh_connector_except();
void ssh_connector_except_channel();
__int64 __fastcall ssh_connector_reset_pollevents(__int64 a1);
unsigned __int64 __fastcall ssh_connector_fd_in_cb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall ssh_connector_fd_out_cb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_connector_fd_cb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_connector_channel_data_cb(__int64 a1, __int64 a2, const void *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_connector_channel_write_wontblock_cb(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_connector_set_event(__int64 a1, _QWORD **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall ssh_connector_remove_event(__int64 a1);
__int64 __fastcall ssh_client_ecdh_reply(__int64 a1, __int64 a2);
__int64 __fastcall equal_0(unsigned int a1, int a2);
_BOOL8 __fastcall ge(int a1, int a2);
__int64 __fastcall times19(int a1);
__int64 __fastcall times38(int a1);
void __fastcall reduce_add_sub_0(_DWORD *a1);
void __fastcall reduce_mul(_DWORD *a1);
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_freeze(__int64 a1);
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_unpack(__int64 a1, __int64 a2);
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_pack(__int64 a1, __int64 *a2);
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_iszero(__int64 *a1);
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_iseq_vartime(__int64 *a1, __int64 *a2);
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_cmov(__int64 a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_getparity(__int64 *a1);
_DWORD *__fastcall crypto_sign_ed25519_ref_fe25519_setone(_DWORD *a1);
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_setzero(__int64 a1);
void __fastcall crypto_sign_ed25519_ref_fe25519_neg(_DWORD *a1, __int64 a2);
void __fastcall crypto_sign_ed25519_ref_fe25519_add(_DWORD *a1, __int64 a2, __int64 a3);
void __fastcall crypto_sign_ed25519_ref_fe25519_sub(_DWORD *a1, _DWORD *a2, __int64 a3);
void __fastcall crypto_sign_ed25519_ref_fe25519_mul(_DWORD *a1, __int64 a2, __int64 a3);
void __fastcall crypto_sign_ed25519_ref_fe25519_square(_DWORD *a1, __int64 a2);
void __fastcall crypto_sign_ed25519_ref_fe25519_invert(_DWORD *a1, __int64 a2);
void __fastcall crypto_sign_ed25519_ref_fe25519_pow2523(_DWORD *a1, __int64 a2);
__int64 __fastcall chacha20_set_encrypt_key(__int64 a1, unsigned __int16 *a2);
unsigned __int64 __fastcall chacha20_poly1305_aead_encrypt(__int64 a1, char *a2, char *a3, unsigned __int64 a4, _DWORD *a5, __int64 a6);
__int64 __fastcall chacha20_poly1305_aead_decrypt_length(__int64 a1, char *a2, char *a3, unsigned __int64 a4, __int64 a5);
__int64 __fastcall chacha20_poly1305_aead_decrypt(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5);
__int64 __fastcall chacha20_cleanup(__int64 a1);
char **ssh_get_chacha20poly1305_cipher();
int *__fastcall chacha_keysetup(int *a1, unsigned __int16 *a2, int a3);
_DWORD *__fastcall chacha_ivsetup(_DWORD *a1, unsigned __int16 *a2, unsigned __int16 *a3);
unsigned __int64 __fastcall chacha_encrypt_bytes(int *a1, char *a2, char *a3, unsigned int a4);
unsigned __int64 __fastcall poly1305_auth(_DWORD *a1, __int64 a2, unsigned __int64 a3, unsigned __int16 *a4);
void _libc_csu_fini(void); // idb
int __fastcall fstat(int fildes, struct stat *stat_buf);
void term_proc();
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __fastcall __cxa_finalize(void *);
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 _gmon_start__(void); weak
// __int64 Jv_RegisterClasses(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_40000; // weak
_UNKNOWN _libc_csu_init;
_UNKNOWN unk_532F6; // weak
_BYTE byte_53858[3] = { 115, 100, 0 }; // weak
const struct timespec ts_9323 = { 0LL, 50000000LL }; // idb
_BYTE byte_53F4C[4] = { 98, 115, 0, 0 }; // weak
_UNKNOWN unk_5414E; // weak
const char s[5] = { '\0', '\0', '\0', '\0', '\0' }; // idb
char byte_55082[30] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_UNKNOWN unk_56F83; // weak
_UNKNOWN unk_572E8; // weak
_QWORD initstate_2080[524] =
{
  -7431021106289374298LL,
  -3451200186548915493LL,
  7648940202947358701LL,
  -1068338713358200763LL,
  -5507501060570113721LL,
  -8822837448418397470LL,
  8167082663806050520LL,
  -823246692746199389LL,
  8254735656317973647LL,
  -9073263486300336808LL,
  -4442139446454475747LL,
  3094641531298043193LL,
  2909472628438839331LL,
  -5126441148289550056LL,
  6933881027089259696LL,
  -5756011273018012021LL,
  -4813983892198033471LL,
  6152018660399460314LL,
  -6172839058233547277LL,
  7199026270926575714LL,
  3074569545919904106LL,
  1243530946625166388LL,
  8967486628324214447LL,
  7165152423763121169LL,
  8365491241204958557LL,
  -7239656115454329322LL,
  7792581252251826739LL,
  2924391380756353921LL,
  7731477347581249688LL,
  7361170509481895963LL,
  -350812854081287732LL,
  6767925293483863136LL,
  -1619759083881734819LL,
  -1484750227525721342LL,
  -3200180522495426943LL,
  -8938446547584192525LL,
  -6592108752239115134LL,
  -7052747661634899894LL,
  -654872861558282174LL,
  -6065353707035517855LL,
  -2858607737966583598LL,
  -6102039242420017368LL,
  1403500086179072876LL,
  9149953903381180496LL,
  4156542590120977693LL,
  -9060382046336427714LL,
  5003393308839282201LL,
  4290627242243171779LL,
  -8808723714101250600LL,
  6251395020039537823LL,
  3908973870556883554LL,
  4799432289379344242LL,
  -3455929662670055644LL,
  5328251609783724755LL,
  -9180276150200208695LL,
  -655028592709436968LL,
  -5298119666512801766LL,
  342280970154336445LL,
  4656546937903337398LL,
  1831316207683018434LL,
  4498062166451777455LL,
  4274738958136095467LL,
  -7264142180892258017LL,
  -5809998619477981884LL,
  -2435520519787524092LL,
  1814470933760387079LL,
  5028396594967062615LL,
  -5056421035066564807LL,
  1900574062715453629LL,
  4624196785020141766LL,
  -351382147604470274LL,
  -2652018779627329032LL,
  -188751970420058401LL,
  -5979282035077800248LL,
  -206172310699395590LL,
  4467816581186026312LL,
  -3859711734153717829LL,
  -2371310289023445458LL,
  2918050825144281334LL,
  -8336350429937454394LL,
  -4915018425537189968LL,
  -5120573393636187299LL,
  -206739281300275816LL,
  3301652390892844396LL,
  -5262379861899221895LL,
  5475136420262595004LL,
  -6572020469919255846LL,
  -3538484705811033279LL,
  3924689171467258586LL,
  3166346874470702846LL,
  -5868030229928486323LL,
  7751774270743481969LL,
  -5780609949204819504LL,
  -8181469631962391761LL,
  -1003692056038153477LL,
  -8066527352210278382LL,
  7534455227977391776LL,
  -5500933992539491951LL,
  -4751834756169129448LL,
  -8430140772200403458LL,
  -5372947286795957233LL,
  -3564068482915175466LL,
  -210577677941714976LL,
  -3265768502719136895LL,
  -9181301401590979994LL,
  2385241456459412244LL,
  8626076118600720485LL,
  -316037232327376139LL,
  8880686839465094924LL,
  -5900139606216467501LL,
  2337846897892724269LL,
  6321049119815631035LL,
  -1150184690705746277LL,
  6476078039689302301LL,
  -2784821612623346807LL,
  208777214047378338LL,
  7103812314203554678LL,
  5652943600611760488LL,
  8868899704499809738LL,
  -7326466998172319662LL,
  -4856069087042775233LL,
  -9086447654096821130LL,
  6276866825170612149LL,
  3030316812577729643LL,
  -1749092417117395679LL,
  -4213866884556913362LL,
  -6224098236946174627LL,
  7963779668068943769LL,
  -5353890158712557335LL,
  -4316376832410318546LL,
  5307456416753034928LL,
  -8075602403016154952LL,
  7609420908350573681LL,
  -4417575068819500436LL,
  8433355516628304549LL,
  -2010793192968350912LL,
  6575991464094111898LL,
  -7352337676498901802LL,
  -1159623072507847673LL,
  -1142403845663672090LL,
  -8903357913580625786LL,
  152784143145691590LL,
  4520188822745017151LL,
  7740122747398199316LL,
  5954007774290457988LL,
  -6174427153239878907LL,
  9213993598847517724LL,
  6275470005265843436LL,
  -1130390253539239369LL,
  144313099902263044LL,
  4374530923833390362LL,
  -2591503014313100712LL,
  8982763668891571193LL,
  2518997638690522995LL,
  4018014456983709057LL,
  -7281232459831347660LL,
  1139414067228991814LL,
  -6596332810719934658LL,
  4317278791609666969LL,
  1747030729348397985LL,
  5723434146782808888LL,
  -717755970360308477LL,
  2636712966731862672LL,
  -4850506887491637134LL,
  -2768860477355559137LL,
  -2535738595372978670LL,
  3344891549112758815LL,
  -6952205943704986138LL,
  8361172502585034520LL,
  -1636075996205573444LL,
  -2628661843954308038LL,
  -4295092836232510618LL,
  3609029308801882183LL,
  2648884138211490615LL,
  3055063774724705603LL,
  1385671474560630786LL,
  1166799907355359390LL,
  6850284663893424086LL,
  -2908261671905175823LL,
  6423440427618211899LL,
  -7497934849365252371LL,
  2167705241455869740LL,
  -1519560590997895824LL,
  6502681862506176010LL,
  5637669981347899164LL,
  -7356879515330159431LL,
  5937653222125504982LL,
  -7201058535540733576LL,
  -7718349006919364934LL,
  2164593099684985939LL,
  3899320397442010791LL,
  1856179450077062671LL,
  -643149747512432888LL,
  -1530344921474662802LL,
  -6450341572491065963LL,
  111744641019099089LL,
  -4725302241027498513LL,
  7542289137019658629LL,
  -2652737570855803633LL,
  6588255549592141229LL,
  2956438814410782248LL,
  7034364305413588853LL,
  -1485697949780629456LL,
  -6195998921568485858LL,
  5508080713015188624LL,
  -3770957556904714741LL,
  6945162675136267964LL,
  -5551948305007944533LL,
  1854903373607411375LL,
  7303355700693133753LL,
  4335476273270250034LL,
  -4602193972367005227LL,
  -8692052174205351143LL,
  7078952352320297342LL,
  -7502102560980367206LL,
  1614560811973186399LL,
  -4042508611296589783LL,
  8671886251325841313LL,
  1955250959235253413LL,
  1928181203136136191LL,
  5993781294863157995LL,
  7907249096037583076LL,
  3803008317340250863LL,
  -1262067326687580831LL,
  -1701032572088609575LL,
  2323316311671725332LL,
  -6653316476802506058LL,
  -375118385502204139LL,
  -1194936361706916798LL,
  4741482289749244701LL,
  -8753504780004984418LL,
  4431931607876323178LL,
  6596971114736558578LL,
  -4483414088591309920LL,
  7623314966800835779LL,
  6238244719361821195LL,
  -5973663591426179328LL,
  2558622931804664180LL,
  888886888327449898LL,
  2539872277272327230LL,
  -8245107674284101486LL,
  7791856120684866801LL,
  -3751933481792424103LL,
  -3569328730557517145LL,
  1871334287493005444LL,
  7050832949422315605LL,
  -4248012915381524566LL,
  -9220052764359087108LL,
  -4376033718724953554LL,
  1017425156216547077LL,
  1176997295358729171LL,
  -2060604360607409543LL,
  8160022078523978853LL,
  -1049902624177325922LL,
  -8092901141991513625LL,
  -2629066477212033237LL,
  -7745838450586330520LL,
  -7752619976094374372LL,
  8503593204842832119LL,
  -3124934741594969298LL,
  3684213234850079857LL,
  5764714928417526967LL,
  -7555838107363707346LL,
  -4644468781905522828LL,
  -7586997815128753123LL,
  7394962563436699091LL,
  269538153415313900LL,
  3588107782499102160LL,
  6196171616199321523LL,
  -6068025887727204378LL,
  5981952333679982629LL,
  -1605975292136093990LL,
  -2933979706751708062LL,
  2855719693817135268LL,
  -1691192316917711198LL,
  8859942447162908678LL,
  -3227005137905115524LL,
  4641850307355648921LL,
  -2741700717969498571LL,
  4256550960722728875LL,
  5435027083452087031LL,
  -1521205457712880079LL,
  -2496327685439030668LL,
  -3857296816684800009LL,
  -2810611652099377842LL,
  -5023601388433680724LL,
  2342871843554409018LL,
  -3416379113690388041LL,
  -6839390754907330628LL,
  -7358359300623226525LL,
  4553462452413155926LL,
  -8058855647964004836LL,
  299260062587217922LL,
  371596324887008604LL,
  -1961760592364497592LL,
  -4102912454839692481LL,
  4684903661790939630LL,
  6739757888501676452LL,
  -3054635917514944021LL,
  4688587394754855311LL,
  6929522913422571572LL,
  2261770304847669411LL,
  207502712258081986LL,
  -3832139877778567215LL,
  3692550241353176544LL,
  -1243352890435433630LL,
  -1821128146293710322LL,
  3288462432836652172LL,
  -7658488823481731003LL,
  -1743748542872352670LL,
  -8683704266507312273LL,
  -919142110666556121LL,
  -7408703463124147391LL,
  -794606920585482581LL,
  -6779080754034713504LL,
  -2635051025817673396LL,
  7883318290800137488LL,
  -2535271485671091141LL,
  -3746713810381500985LL,
  7570530133173931922LL,
  -3541098571309015045LL,
  -2804231136101675253LL,
  5862469713221857160LL,
  8519639426980411839LL,
  -3742111438215762253LL,
  -851689208033123689LL,
  -4149456572516225625LL,
  8660124236351098060LL,
  -5219018963810106825LL,
  5475078967358766054LL,
  1282098702381158424LL,
  -2098180682296214056LL,
  725663957351798361LL,
  -3050086852862350226LL,
  -2700285798897457330LL,
  7270151197372180872LL,
  -1083185500954787753LL,
  6918479338018470904LL,
  -704778497385725114LL,
  -2938883751708086780LL,
  -1144288751283705037LL,
  4323559407351775623LL,
  -4762365134295246914LL,
  -4658922818937404775LL,
  -946321473136954225LL,
  -8680198161757311176LL,
  -3984684615026148925LL,
  5115202668405846613LL,
  -8422329968022051231LL,
  -7971488015305798023LL,
  2356604644751202702LL,
  -3962360301770943087LL,
  -4935375847628755743LL,
  8463576096102179400LL,
  -2258031803858216522LL,
  -4309304706868639327LL,
  716281853154828034LL,
  2120911820462596133LL,
  839258183707475229LL,
  2911842595078861327LL,
  6285062446666734211LL,
  5750392292102033051LL,
  -6411291908406944255LL,
  1001716835743348164LL,
  8592734230377172007LL,
  7036881795503115270LL,
  -4542576348474410456LL,
  3520826868563466410LL,
  2538036101246262999LL,
  -4412940270870274668LL,
  -8017332168876626346LL,
  -3577796032366608991LL,
  5439224135446553609LL,
  8976373502327261757LL,
  8236412713688068703LL,
  -3197915292466324556LL,
  647574647223899512LL,
  5597147250007309523LL,
  -5664992902920474786LL,
  7805040780355376345LL,
  6260371562618537959LL,
  -2466063606481240114LL,
  -7898326304039488972LL,
  4638708579993320078LL,
  -3171952717145190857LL,
  6540683630694528823LL,
  5738491108362577822LL,
  -7368843646390360256LL,
  -4679394950208450915LL,
  -4107066824008590210LL,
  2423376703608593259LL,
  7653426339129504190LL,
  -4858136630591444177LL,
  7298578838712448722LL,
  5083964184216991982LL,
  5535009458418289181LL,
  -6216579025528570917LL,
  -4729092949477611800LL,
  7650861066556724720LL,
  -7311895113516479262LL,
  4838043537029841592LL,
  -7137413053865393238LL,
  -7212116447101689414LL,
  -5015783107888605872LL,
  -6396735582010694919LL,
  -1200944971488062074LL,
  -625164879234338861LL,
  8645233813116710761LL,
  -8669281941672646379LL,
  4269101918917879469LL,
  -7046770469469356710LL,
  156371792836999129LL,
  107425024458468410LL,
  8970375686133858006LL,
  -5912460384394074673LL,
  6523733768536503410LL,
  -2298623723774038927LL,
  -1327441920314528515LL,
  2899007322734183565LL,
  8724367656655087145LL,
  -1336055794237505135LL,
  -2030175047471722940LL,
  -8578110744249930284LL,
  388700162461098277LL,
  4364084395505327637LL,
  -6252677253144569108LL,
  2189631180440038811LL,
  2800380361138005755LL,
  -5668345325300754136LL,
  -8450374976894782334LL,
  -4464516420732881135LL,
  -3698138779399466649LL,
  4048978568756598609LL,
  -7844996148780771230LL,
  -342700393006198590LL,
  8597299336992378468LL,
  -4383905388580904066LL,
  7211360867003028329LL,
  -2491139148448135152LL,
  650525394919042557LL,
  7225393235619366410LL,
  2026840483450117839LL,
  1970480144531257309LL,
  7761078453600911743LL,
  4204672402663303806LL,
  -4849024583015790012LL,
  -404052125934760280LL,
  -4666732760757038418LL,
  6066170159810995299LL,
  -698511556576381157LL,
  -1775804361737368179LL,
  -5813164851451521423LL,
  5671407197645490952LL,
  78161550905591402LL,
  -7667314465583397848LL,
  -3571741223247372364LL,
  3828248259965434754LL,
  2842378260948065611LL,
  -1759992813617585999LL,
  3766458160185506091LL,
  5894782327997348321LL,
  -6908597930120001097LL,
  -4843672015961536386LL,
  -6779981463858114109LL,
  -3148089144940394679LL,
  -3095421856306766133LL,
  -4138466766513126614LL,
  -2255974317651578500LL,
  4897026031772129719LL,
  2871402777816668671LL,
  1578225979973116460LL,
  -7236135452358345615LL,
  -3551478718794460319LL,
  1349576657218331737LL,
  -2088146249378101410LL,
  -3818027455423033243LL,
  1628292315517578766LL,
  3636913316092747966LL,
  -2246290299982736078LL,
  -8542780803931687893LL,
  5450257750402167873LL,
  -4362243282449829600LL,
  -7234699448034156659LL,
  1145023840998092615LL,
  2223327487189637716LL,
  -3657346828709234225LL,
  -203755975455755930LL,
  -649887678475545915LL,
  -6470979817769274537LL,
  6254599393461679409LL,
  6518375201211711842LL,
  -8587674217584642409LL,
  -9099160410688953710LL,
  8198334816854249499LL,
  3637241686109112253LL,
  -4327260389422018554LL,
  7108948507862127613LL,
  3872483211752095714LL,
  -5619364088102360827LL,
  -3641551537118130308LL,
  1603531964115140288LL,
  2686306950004325728LL,
  -628588088645902180LL,
  2338881548929966533LL,
  -8437337940781433266LL,
  5546651876284103088LL,
  214917741554483804LL,
  -2960023870473278748LL,
  -6459042984350123927LL,
  -4465065458906094291LL,
  -3569135296122560206LL,
  4234354408295489507LL,
  -8817193942522041720LL,
  247824715720788526LL,
  2999170649027065890LL,
  -1419077496771511656LL,
  4093793464262074854LL,
  3812592220735039183LL,
  -3928175861623412297LL,
  -5384324834043570763LL,
  -8540519122497776167LL,
  0LL,
  0LL,
  0LL
}; // weak
_UNKNOWN ge25519_ecd; // weak
_UNKNOWN ge25519_ec2d; // weak
_UNKNOWN ge25519_sqrtm1; // weak
_UNKNOWN crypto_sign_ed25519_ref_ge25519_base; // weak
_UNKNOWN ge25519_base_multiples_affine; // weak
_DWORD m[32] =
{
  237,
  211,
  245,
  92,
  26,
  99,
  18,
  88,
  214,
  156,
  247,
  162,
  222,
  249,
  222,
  20,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16
}; // weak
_DWORD mu[33] =
{
  27,
  19,
  44,
  10,
  163,
  229,
  156,
  237,
  167,
  41,
  99,
  8,
  93,
  33,
  6,
  33,
  235,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  15
}; // weak
_UNKNOWN unk_7392E; // weak
__int16 aQgyxendu[8] = { 113, 103, 121, 120, 101, 110, 100, 117 }; // weak
_UNKNOWN unk_73CE4; // weak
_UNKNOWN unk_73CE6; // weak
_UNKNOWN unk_7406D; // weak
_UNKNOWN unk_746A2; // weak
_UNKNOWN minusp; // weak
_UNKNOWN unk_757FC; // weak
unsigned __int16 zero_block_counter[4] = { 0u, 0u, 0u, 0u }; // weak
unsigned __int16 payload_block_counter[4] = { 1u, 0u, 0u, 0u }; // weak
_UNKNOWN sigma; // weak
_UNKNOWN tau; // weak
__int64 (__fastcall *_frame_dummy_init_array_entry[4])() = { &frame_dummy, &libssh_constructor, &_do_global_dtors_aux, &libssh_destructor }; // weak
__int64 (__fastcall *_do_global_dtors_aux_fini_array_entry[2])() = { &_do_global_dtors_aux, &libssh_destructor }; // weak
_UNKNOWN _JCR_LIST__; // weak
_UNKNOWN mapping_9072; // weak
char *chacha20poly1305_cipher = "chacha20-poly1305@openssh.com"; // weak
void *_dso_handle = &_dso_handle; // idb
struct argp argp =
{
  &options,
  &parse_opt,
  "BINDADDR",
  "libssh -- a Secure Shell protocol implementation",
  &dword_0,
  &dword_0,
  &dword_0
}; // idb
char *hex_9293 = "0123456789abcdef"; // weak
_UNKNOWN p_group1_value; // weak
_UNKNOWN p_group14_value; // weak
__int64 g_int = 2LL; // weak
char *default_methods[8] =
{
  "curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1",
  "ssh-ed25519,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,ssh-rsa,ssh-dss",
  "aes256-ctr,aes192-ctr,aes128-ctr,aes256-cbc,aes192-cbc,aes128-cbc,blowfish-cbc,3des-cbc",
  "aes256-ctr,aes192-ctr,aes128-ctr,aes256-cbc,aes192-cbc,aes128-cbc,blowfish-cbc,3des-cbc",
  "hmac-sha2-256,hmac-sha2-512,hmac-sha1",
  "hmac-sha2-256,hmac-sha2-512,hmac-sha1",
  "none",
  "none"
}; // weak
char *supported_methods[8] =
{
  "curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1",
  "ssh-ed25519,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,ssh-rsa,ssh-dss",
  "chacha20-poly1305@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr,aes256-cbc,aes192-cbc,aes128-cbc,blowfish-cbc,3des-cbc",
  "chacha20-poly1305@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr,aes256-cbc,aes192-cbc,aes128-cbc,blowfish-cbc,3des-cbc",
  "hmac-sha2-256,hmac-sha2-512,hmac-sha1",
  "hmac-sha2-256,hmac-sha2-512,hmac-sha1",
  "none,zlib,zlib@openssh.com",
  "none,zlib,zlib@openssh.com"
}; // weak
char *ssh_kex_descriptions[10] =
{
  "kex algos",
  "server host key algo",
  "encryption client->server",
  "encryption server->client",
  "mac algo client->server",
  "mac algo server->client",
  "compression algo client->server",
  "compression algo server->client",
  "languages client->server",
  "languages server->client"
}; // weak
char *preferred_hostkeys_8797[6] =
{
  "ssh-ed25519",
  "ecdsa-sha2-nistp521",
  "ecdsa-sha2-nistp384",
  "ecdsa-sha2-nistp256",
  "ssh-rsa",
  "ssh-dss"
}; // weak
__int64 (__fastcall *default_packet_handlers[6])() =
{
  &ssh_packet_disconnect_callback,
  &ssh_packet_ignore_callback,
  &ssh_packet_unimplemented,
  &ssh_packet_ignore_callback,
  &ssh_packet_service_request,
  &ssh_packet_service_accept
}; // weak
char *ssh_hmac_tab = "hmac-sha1"; // weak
char *ssh_threads_pthread = "threads_pthread"; // weak
char *ssh_ciphertab = "blowfish-cbc"; // weak
char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // idb
char *ssh_config_keyword_table = "host"; // weak
_UNKNOWN unk_2813A8; // weak
char _bss_start; // weak
int no_default_keys_6547; // weak
int dsa_already_set_6549; // weak
int rsa_already_set_6548; // weak
int ecdsa_already_set_6550; // weak
__int64 g; // weak
__int64 p_group1; // weak
__int64 p_group14; // weak
int dh_crypto_initialized; // weak
pthread_mutex_t ssh_init_mutex; // weak
int ssh_initialized; // weak
int ssh_init_ret; // weak
int sockets_initialized; // weak
__int64 user_callbacks; // weak
int threads_initialized_8492; // weak
int libgcrypt_initialized; // weak
__int64 e_9071; // weak
// extern int optind;
// extern char *optarg;
// extern int optopt;
// extern int opterr;
// extern struct _IO_FILE *stderr;


//----- (000000000000D758) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 281FB0: using guessed type __int64 _gmon_start__(void);

//----- (000000000000D770) ----------------------------------------------------
void sub_D770()
{
  JUMPOUT(0LL);
}
// D776: control flows out of bounds to 0

//----- (000000000000E140) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main(
    (int (__fastcall *)(int, char **, char **))main,
    v4,
    &retaddr,
    (void (*)(void))_libc_csu_init,
    _libc_csu_fini,
    a3,
    &v5);
  __halt();
}
// E146: positive sp value 8 has been found
// E14D: variable 'v3' is possibly undefined

//----- (000000000000E170) ----------------------------------------------------
__int64 (**deregister_tm_clones())(void)
{
  __int64 (**result)(void); // rax

  result = (__int64 (**)(void))((char *)&no_default_keys_6547 + 3 - &_bss_start);
  if ( (unsigned __int64)((char *)&no_default_keys_6547 + 3 - &_bss_start) > 0xE )
  {
    result = &ITM_deregisterTMCloneTable;
    if ( &ITM_deregisterTMCloneTable )
      return (__int64 (**)(void))ITM_deregisterTMCloneTable();
  }
  return result;
}
// 2819E0: using guessed type char _bss_start;
// 2819E4: using guessed type int no_default_keys_6547;
// 281FA8: using guessed type __int64 ITM_deregisterTMCloneTable(void);

//----- (000000000000E1B0) ----------------------------------------------------
__int64 register_tm_clones()
{
  return 0LL;
}
// E1B0: using guessed type __int64 register_tm_clones();

//----- (000000000000E200) ----------------------------------------------------
__int64 (**_do_global_dtors_aux())(void)
{
  __int64 (**result)(void); // rax

  if ( !_bss_start )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(_dso_handle);
    result = deregister_tm_clones();
    _bss_start = 1;
  }
  return result;
}
// 2819E0: using guessed type char _bss_start;

//----- (000000000000E240) ----------------------------------------------------
__int64 frame_dummy()
{
  if ( _JCR_LIST__ && &Jv_RegisterClasses )
    Jv_RegisterClasses();
  return register_tm_clones();
}
// E1B0: using guessed type __int64 register_tm_clones(void);
// E240: using guessed type __int64 frame_dummy();
// 281FB8: using guessed type __int64 Jv_RegisterClasses(void);

//----- (000000000000E270) ----------------------------------------------------
__int64 __fastcall set_default_keys(__int64 a1, int a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  int v7; // [rsp+Ch] [rbp-14h]

  v7 = a4;
  if ( !a2 )
    result = ssh_bind_options_set(a1, 5u, "/etc/ssh/ssh_host_rsa_key", a4, a5, a6);
  if ( !a3 )
    result = ssh_bind_options_set(a1, 4u, "/etc/ssh/ssh_host_dsa_key", a4, a5, a6);
  if ( !v7 )
    return ssh_bind_options_set(a1, 9u, "/etc/ssh/ssh_host_ecdsa_key", a4, a5, a6);
  return result;
}
// E2BC: variable 'a4' is possibly undefined
// E2BC: variable 'a5' is possibly undefined
// E2BC: variable 'a6' is possibly undefined

//----- (000000000000E2E2) ----------------------------------------------------
__int64 __fastcall parse_opt(int a1, char *a2, const struct argp_state *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 input; // [rsp+28h] [rbp-8h]

  input = (__int64)a3->input;
  if ( a1 == 110 )
  {
    no_default_keys_6547 = 1;
  }
  else if ( a1 > 110 )
  {
    if ( a1 == 114 )
    {
      ssh_bind_options_set(input, 5u, a2, a4, a5, a6);
      rsa_already_set_6548 = 1;
    }
    else if ( a1 > 114 )
    {
      if ( a1 == 118 )
      {
        ssh_bind_options_set(input, 8u, "3", a4, a5, a6);
      }
      else
      {
        if ( a1 != 16777217 )
          return 7LL;
        if ( !a3->arg_num )
          argp_usage(a3);
        if ( !no_default_keys_6547 )
          set_default_keys(
            input,
            rsa_already_set_6548,
            dsa_already_set_6549,
            (unsigned int)ecdsa_already_set_6550,
            a5,
            a6);
      }
    }
    else
    {
      if ( a1 != 112 )
        return 7LL;
      ssh_bind_options_set(input, 2u, a2, a4, a5, a6);
    }
  }
  else if ( a1 == 100 )
  {
    ssh_bind_options_set(input, 4u, a2, a4, a5, a6);
    dsa_already_set_6549 = 1;
  }
  else if ( a1 > 100 )
  {
    if ( a1 == 101 )
    {
      ssh_bind_options_set(input, 9u, a2, a4, a5, a6);
      ecdsa_already_set_6550 = 1;
    }
    else
    {
      if ( a1 != 107 )
        return 7LL;
      ssh_bind_options_set(input, 3u, a2, a4, a5, a6);
      no_default_keys_6547 = 1;
    }
  }
  else
  {
    if ( a1 )
      return 7LL;
    if ( a3->arg_num )
      argp_usage(a3);
    ssh_bind_options_set(input, 0, a2, a4, a5, a6);
  }
  return 0LL;
}
// E46B: variable 'a4' is possibly undefined
// E46B: variable 'a5' is possibly undefined
// E46B: variable 'a6' is possibly undefined
// 2819E4: using guessed type int no_default_keys_6547;
// 2819E8: using guessed type int dsa_already_set_6549;
// 2819EC: using guessed type int rsa_already_set_6548;
// 2819F0: using guessed type int ecdsa_already_set_6550;

//----- (000000000000E4C2) ----------------------------------------------------
ssize_t __fastcall data_function(__int64 a1, __int64 a2, const void *a3, unsigned int a4, __int64 a5, __pid_t *a6)
{
  if ( a4 && *a6 > 0 && kill(*a6, 0) >= 0 )
    return write(a6[3], a3, a4);
  else
    return 0LL;
}

//----- (000000000000E530) ----------------------------------------------------
__int64 __fastcall pty_request(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int16 a4,
        __int16 a5,
        __int16 a6,
        __int16 a7,
        __int64 a8)
{
  **(_WORD **)(a8 + 32) = a5;
  *(_WORD *)(*(_QWORD *)(a8 + 32) + 2LL) = a4;
  *(_WORD *)(*(_QWORD *)(a8 + 32) + 4LL) = a7;
  *(_WORD *)(*(_QWORD *)(a8 + 32) + 6LL) = a6;
  if ( !openpty((int *)(a8 + 4), (int *)(a8 + 8), 0LL, 0LL, *(const struct winsize **)(a8 + 32)) )
    return 0LL;
  fwrite("Failed to open pty\n", 1uLL, 0x13uLL, stderr);
  return 0xFFFFFFFFLL;
}

//----- (000000000000E5F4) ----------------------------------------------------
int __fastcall pty_resize(__int64 a1, __int64 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int64 a7)
{
  **(_WORD **)(a7 + 32) = a4;
  *(_WORD *)(*(_QWORD *)(a7 + 32) + 2LL) = a3;
  *(_WORD *)(*(_QWORD *)(a7 + 32) + 4LL) = a6;
  *(_WORD *)(*(_QWORD *)(a7 + 32) + 6LL) = a5;
  if ( *(_DWORD *)(a7 + 4) == -1 )
    return -1;
  else
    return ioctl(*(_DWORD *)(a7 + 4), 0x5414uLL, *(_QWORD *)(a7 + 32));
}

//----- (000000000000E68A) ----------------------------------------------------
__int64 __fastcall exec_pty(__int64 a1, __int64 a2, __pid_t *a3)
{
  *a3 = fork();
  if ( *a3 == -1 )
  {
    close(a3[1]);
    close(a3[2]);
    fwrite("Failed to fork\n", 1uLL, 0xFuLL, stderr);
    return 0xFFFFFFFFLL;
  }
  else
  {
    if ( !*a3 )
    {
      close(a3[1]);
      if ( login_tty(a3[2]) )
        exit(1);
      execl("/bin/sh", "sh", a1, a2, 0LL);
      exit(0);
    }
    close(a3[2]);
    a3[3] = a3[1];
    a3[4] = a3[3];
    return 0LL;
  }
}

//----- (000000000000E799) ----------------------------------------------------
__int64 __fastcall exec_nopty(__int64 a1, __pid_t *a2)
{
  int pipedes[2]; // [rsp+18h] [rbp-18h] BYREF
  int v4[2]; // [rsp+20h] [rbp-10h] BYREF
  int v5[2]; // [rsp+28h] [rbp-8h] BYREF

  if ( pipe(pipedes) )
    return 0xFFFFFFFFLL;
  if ( pipe(v4) )
  {
LABEL_10:
    close(pipedes[0]);
    close(pipedes[1]);
    return 0xFFFFFFFFLL;
  }
  if ( pipe(v5) )
  {
LABEL_9:
    close(v4[0]);
    close(v4[1]);
    goto LABEL_10;
  }
  *a2 = fork();
  if ( *a2 == -1 )
  {
    close(v5[0]);
    close(v5[1]);
    goto LABEL_9;
  }
  if ( !*a2 )
  {
    close(pipedes[1]);
    close(v4[0]);
    close(v5[0]);
    dup2(pipedes[0], 0);
    dup2(v4[1], 1);
    dup2(v5[1], 2);
    close(pipedes[0]);
    close(v4[1]);
    close(v5[1]);
    execl("/bin/sh", "sh", "-c", a1, 0LL);
    exit(0);
  }
  close(pipedes[0]);
  close(v4[1]);
  close(v5[1]);
  a2[3] = pipedes[1];
  a2[4] = v4[0];
  a2[5] = v5[0];
  return 0LL;
}

//----- (000000000000E938) ----------------------------------------------------
__int64 __fastcall exec_request(__int64 a1, __int64 a2, __int64 a3, __pid_t *a4)
{
  if ( *a4 > 0 )
    return 0xFFFFFFFFLL;
  if ( a4[1] == -1 || a4[2] == -1 )
    return exec_nopty(a3, a4);
  return exec_pty((__int64)"-c", a3, a4);
}

//----- (000000000000E9AF) ----------------------------------------------------
__int64 __fastcall shell_request(__int64 a1, __int64 a2, __pid_t *a3)
{
  if ( *a3 > 0 )
    return 0xFFFFFFFFLL;
  if ( a3[1] == -1 || a3[2] == -1 )
    return 0LL;
  return exec_pty((__int64)"-l", 0LL, a3);
}

//----- (000000000000EA15) ----------------------------------------------------
__int64 __fastcall subsystem_request(__int64 a1, __int64 a2, const char *a3, __pid_t *a4)
{
  if ( !strcmp(a3, "sftp") )
    return exec_request(a1, a2, (__int64)"/usr/lib/sftp-server", a4);
  else
    return 0xFFFFFFFFLL;
}

//----- (000000000000EA6B) ----------------------------------------------------
__int64 __fastcall auth_password(__int64 a1, const char *a2, const char *a3, __int64 a4)
{
  if ( !strcmp(a2, "myuser") && !strcmp(a3, "mypassword") )
  {
    *(_DWORD *)(a4 + 12) = 1;
    return 0LL;
  }
  else
  {
    ++*(_DWORD *)(a4 + 8);
    return 1LL;
  }
}

//----- (000000000000EAE3) ----------------------------------------------------
__int64 __fastcall channel_open(__int64 a1, __int64 a2)
{
  *(_QWORD *)a2 = ssh_channel_new(a1);
  return *(_QWORD *)a2;
}

//----- (000000000000EB1A) ----------------------------------------------------
#error "EB1A: stack frame is too big (funcsize=0)"

//----- (000000000000EBDC) ----------------------------------------------------
#error "EBDC: stack frame is too big (funcsize=0)"

//----- (000000000000EC9E) ----------------------------------------------------
int __fastcall handle_session(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char *error; // rax
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  int stat_loc; // [rsp+10h] [rbp-140h] BYREF
  int i; // [rsp+14h] [rbp-13Ch]
  __int16 v14[4]; // [rsp+18h] [rbp-138h] BYREF
  __int64 *v15; // [rsp+20h] [rbp-130h] BYREF
  int v16; // [rsp+28h] [rbp-128h]
  int v17; // [rsp+2Ch] [rbp-124h]
  __pid_t pid; // [rsp+30h] [rbp-120h] BYREF
  int fd; // [rsp+34h] [rbp-11Ch]
  int v20; // [rsp+38h] [rbp-118h]
  int v21; // [rsp+3Ch] [rbp-114h]
  int v22; // [rsp+40h] [rbp-110h]
  int v23; // [rsp+44h] [rbp-10Ch]
  __int64 *v24; // [rsp+48h] [rbp-108h]
  __int16 *v25; // [rsp+50h] [rbp-100h]
  __int64 v26[12]; // [rsp+60h] [rbp-F0h] BYREF
  __int64 v27[18]; // [rsp+C0h] [rbp-90h] BYREF

  v14[0] = 0;
  v14[1] = 0;
  v14[2] = 0;
  v14[3] = 0;
  pid = 0;
  fd = -1;
  v20 = -1;
  v21 = -1;
  v22 = -1;
  v23 = -1;
  v24 = 0LL;
  v25 = v14;
  v15 = 0LL;
  v16 = 0;
  v17 = 0;
  memset(v27, 0, 0x88uLL);
  v27[1] = (__int64)&pid;
  v27[2] = (__int64)data_function;
  v27[8] = (__int64)pty_request;
  v27[9] = (__int64)shell_request;
  v27[12] = (__int64)pty_resize;
  v27[13] = (__int64)exec_request;
  v27[15] = (__int64)subsystem_request;
  memset(v26, 0, 0x58uLL);
  v26[1] = (__int64)&v15;
  v26[2] = (__int64)auth_password;
  v26[7] = (__int64)channel_open;
  v26[0] = 88LL;
  v27[0] = 136LL;
  ssh_set_server_callbacks(a2, v26, (__int64)v26, 0LL, a5, a6);
  if ( (unsigned int)ssh_handle_key_exchange(a2) )
  {
LABEL_2:
    error = (const char *)ssh_get_error(a2);
    LODWORD(v7) = fprintf(stderr, "%s\n", error);
  }
  else
  {
    ssh_set_auth_methods(a2, 2);
    ssh_event_add_session((__int64)a1, a2);
    i = 0;
    while ( !v15 )
    {
      LODWORD(v7) = v16;
      if ( v16 > 2 || i > 99 )
        return v7;
      if ( (unsigned int)ssh_event_dopoll(a1, 100) == -1 )
        goto LABEL_2;
      ++i;
    }
    ssh_set_channel_callbacks(v15, v27, (__int64)v27, v8, v9, v10);
    do
    {
      if ( (unsigned int)ssh_event_dopoll(a1, -1) == -1 )
        ssh_channel_close((__int64)v15);
      if ( !v24 && pid )
      {
        v24 = a1;
        if ( v22 != -1 && (unsigned int)ssh_event_add_fd((_QWORD **)a1, v22, 1, (__int64)process_stdout, (__int64)v15) )
        {
          fwrite("Failed to register stdout to poll context\n", 1uLL, 0x2AuLL, stderr);
          ssh_channel_close((__int64)v15);
        }
        if ( v23 != -1 && (unsigned int)ssh_event_add_fd((_QWORD **)a1, v23, 1, (__int64)process_stderr, (__int64)v15) )
        {
          fwrite("Failed to register stderr to poll context\n", 1uLL, 0x2AuLL, stderr);
          ssh_channel_close((__int64)v15);
        }
      }
    }
    while ( ssh_channel_is_open(v15) && (!pid || !waitpid(pid, &stat_loc, 1)) );
    close(fd);
    close(v21);
    close(v22);
    close(v23);
    ssh_event_remove_fd((__int64)a1, v22);
    ssh_event_remove_fd((__int64)a1, v23);
    if ( kill(pid, 0) >= 0 || (stat_loc & 0x7F) != 0 )
    {
      if ( pid > 0 )
        kill(pid, 9);
    }
    else
    {
      stat_loc = BYTE1(stat_loc);
      ssh_channel_request_send_exit_status(v15, stat_loc);
    }
    ssh_channel_send_eof((__int64)v15);
    LODWORD(v7) = ssh_channel_close((__int64)v15);
    for ( i = 0; i <= 49; ++i )
    {
      v7 = ssh_get_status(a2) & 5;
      if ( (_DWORD)v7 )
        break;
      LODWORD(v7) = ssh_event_dopoll(a1, 100);
    }
  }
  return v7;
}
// EF38: variable 'v8' is possibly undefined
// EF38: variable 'v9' is possibly undefined
// EF38: variable 'v10' is possibly undefined
// EB1A: using guessed type __int64 __fastcall process_stdout();
// EBDC: using guessed type __int64 __fastcall process_stderr();

//----- (000000000000F1E6) ----------------------------------------------------
__pid_t sigchld_handler()
{
  __pid_t result; // eax

  do
    result = waitpid(-1, 0LL, 1);
  while ( result > 0 );
  return result;
}

//----- (000000000000F20D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  const char *v8; // rax
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __pid_t v12; // eax
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  const char *error; // rax
  _DWORD *input; // [rsp+18h] [rbp-B8h]
  __int64 *v18; // [rsp+20h] [rbp-B0h]
  __int64 *v19; // [rsp+28h] [rbp-A8h]
  struct sigaction v20; // [rsp+30h] [rbp-A0h] BYREF

  v20.sa_handler = (__sighandler_t)sigchld_handler;
  sigemptyset(&v20.sa_mask);
  v20.sa_flags = 268435457;
  if ( sigaction(17, &v20, 0LL) )
  {
    fwrite("Failed to register SIGCHLD handler\n", 1uLL, 0x23uLL, stderr);
    return 1;
  }
  else if ( (int)ssh_init() >= 0 )
  {
    input = ssh_bind_new();
    if ( input )
    {
      argp_parse(&argp, argc, (char **)argv, 0, 0LL, input);
      if ( (int)ssh_bind_listen((__int64)input, (unsigned int)argc, v4, v5, v6, v7) >= 0 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v18 = ssh_new();
            if ( v18 )
              break;
            fwrite("Failed to allocate session\n", 1uLL, 0x1BuLL, stderr);
          }
          if ( (unsigned int)ssh_bind_accept((__int64)input, (__int64)v18, (__int64)v18, v9, v10, v11) == -1 )
          {
            error = (const char *)ssh_get_error((__int64)input);
            fprintf(stderr, "%s\n", error);
          }
          else
          {
            v12 = fork();
            if ( v12 == -1 )
            {
              fwrite("Failed to fork\n", 1uLL, 0xFuLL, stderr);
            }
            else if ( !v12 )
            {
              v20.sa_handler = 0LL;
              sigaction(17, &v20, 0LL);
              ssh_bind_free((__int64)input);
              v19 = ssh_event_new();
              if ( v19 )
              {
                handle_session(v19, (__int64)v18, (__int64)v18, v13, v14, v15);
                ssh_event_free((_QWORD **)v19);
              }
              else
              {
                fwrite("Could not create polling context\n", 1uLL, 0x21uLL, stderr);
              }
              ssh_disconnect((__int64)v18);
              ssh_free((__int64)v18);
              exit(0);
            }
          }
          ssh_disconnect((__int64)v18);
          ssh_free((__int64)v18);
        }
      }
      v8 = (const char *)ssh_get_error((__int64)input);
      fprintf(stderr, "%s\n", v8);
      return 1;
    }
    else
    {
      fwrite("ssh_bind_new failed\n", 1uLL, 0x14uLL, stderr);
      return 1;
    }
  }
  else
  {
    fwrite("ssh_init failed\n", 1uLL, 0x10uLL, stderr);
    return 1;
  }
}
// F355: variable 'v4' is possibly undefined
// F355: variable 'v5' is possibly undefined
// F355: variable 'v6' is possibly undefined
// F355: variable 'v7' is possibly undefined
// F3EA: variable 'v9' is possibly undefined
// F3EA: variable 'v10' is possibly undefined
// F3EA: variable 'v11' is possibly undefined
// F46B: variable 'v13' is possibly undefined
// F46B: variable 'v14' is possibly undefined
// F46B: variable 'v15' is possibly undefined
// 1924F: using guessed type __int64 ssh_init(void);

//----- (000000000000F546) ----------------------------------------------------
__int64 __fastcall ssh_legacy_log_callback(unsigned int a1, __int64 a2, __int64 a3, __int64 a4)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(*(_QWORD *)(a4 + 1032) + 24LL))(
           a4,
           a1,
           a3,
           *(_QWORD *)(*(_QWORD *)(a4 + 1032) + 8LL));
}

//----- (000000000000F5A3) ----------------------------------------------------
__int64 __fastcall ssh_set_callbacks(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( !a1 || !a2 )
    return 0xFFFFFFFFLL;
  if ( *a2 && *a2 <= 0x2000uLL )
  {
    *(_QWORD *)(a1 + 1032) = a2;
    if ( !ssh_get_log_callback() )
    {
      if ( a2[3] )
      {
        ssh_set_log_callback((__int64)ssh_legacy_log_callback);
        ssh_set_log_userdata(a1);
      }
    }
    return 0LL;
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_set_callbacks", "Invalid callback passed in (badly initialized)", a5, a6, a2);
    return 0xFFFFFFFFLL;
  }
}
// 1CCC1: using guessed type __int64 ssh_get_log_callback(void);

//----- (000000000000F656) ----------------------------------------------------
__int64 __fastcall ssh_add_set_channel_callbacks(__int64 *a1, _QWORD *a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v9; // [rsp+28h] [rbp-8h]

  if ( !a1 || !a2 )
    return 0xFFFFFFFFLL;
  v9 = *a1;
  if ( *a2 && *a2 <= 0x2000uLL )
  {
    if ( a1[11] || (a1[11] = (__int64)ssh_list_new()) != 0 )
    {
      if ( a3 )
        return (unsigned int)ssh_list_prepend((_QWORD *)a1[11], (__int64)a2);
      else
        return (unsigned int)ssh_list_append(a1[11], (__int64)a2);
    }
    else
    {
      ssh_set_error_oom(v9, "ssh_add_set_channel_callbacks");
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error(v9, 2, "ssh_add_set_channel_callbacks", "Invalid callback passed in (badly initialized)", a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (000000000000F762) ----------------------------------------------------
__int64 __fastcall ssh_set_channel_callbacks(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return ssh_add_set_channel_callbacks(a1, a2, 1, (__int64)a2, a5, a6);
}

//----- (000000000000F78C) ----------------------------------------------------
__int64 __fastcall ssh_add_channel_callbacks(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return ssh_add_set_channel_callbacks(a1, a2, 0, (__int64)a2, a5, a6);
}

//----- (000000000000F7B6) ----------------------------------------------------
__int64 __fastcall ssh_remove_channel_callbacks(__int64 a1, __int64 a2)
{
  _QWORD *v3; // [rsp+18h] [rbp-8h]

  if ( !a1 || !*(_QWORD *)(a1 + 88) )
    return 0xFFFFFFFFLL;
  v3 = ssh_list_find(*(_QWORD *)(a1 + 88), a2);
  if ( !v3 )
    return 0xFFFFFFFFLL;
  ssh_list_remove(*(_QWORD *)(a1 + 88), v3);
  return 0LL;
}

//----- (000000000000F828) ----------------------------------------------------
__int64 __fastcall ssh_set_server_callbacks(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( !a1 || !a2 )
    return 0xFFFFFFFFLL;
  if ( *a2 && *a2 <= 0x2000uLL )
  {
    *(_QWORD *)(a1 + 1360) = a2;
    return 0LL;
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_set_server_callbacks", "Invalid callback passed in (badly initialized)", a5, a6, a2);
    return 0xFFFFFFFFLL;
  }
}

//----- (000000000000F8A9) ----------------------------------------------------
_QWORD *__fastcall ssh_channel_new(__int64 a1)
{
  _QWORD *s; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  s = malloc(0x68uLL);
  if ( s )
  {
    memset(s, 0, 0x68uLL);
    s[7] = ssh_buffer_new();
    if ( s[7] )
    {
      s[8] = ssh_buffer_new();
      if ( s[8] )
      {
        *s = a1;
        *((_DWORD *)s + 20) = -1;
        *((_DWORD *)s + 12) = 4;
        if ( !*(_QWORD *)(a1 + 1248) )
          *(_QWORD *)(a1 + 1248) = ssh_list_new();
        ssh_list_prepend(*(_QWORD **)(a1 + 1248), (__int64)s);
        return s;
      }
      else
      {
        ssh_set_error_oom(a1, "ssh_channel_new");
        ssh_buffer_free(s[7]);
        free(s);
        return 0LL;
      }
    }
    else
    {
      ssh_set_error_oom(a1, "ssh_channel_new");
      free(s);
      return 0LL;
    }
  }
  else
  {
    ssh_set_error_oom(a1, "ssh_channel_new");
    return 0LL;
  }
}
// F94B: conditional instruction was optimized away because %s.8!=0
// F9B0: conditional instruction was optimized away because %s.8!=0

//----- (000000000000FA31) ----------------------------------------------------
__int64 __fastcall ssh_channel_new_id(__int64 a1)
{
  return (unsigned int)++*(_DWORD *)(a1 + 1256);
}

//----- (000000000000FA5C) ----------------------------------------------------
__int64 __fastcall ssh_packet_channel_open_conf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r9
  __int64 v10; // r9
  unsigned int v12; // [rsp+20h] [rbp-10h] BYREF
  int v13; // [rsp+24h] [rbp-Ch]
  unsigned int *v14; // [rsp+28h] [rbp-8h]

  v12 = 0;
  ssh_log(3, "ssh_packet_channel_open_conf", "Received SSH2_MSG_CHANNEL_OPEN_CONFIRMATION", a4, a5, a6, a4);
  v13 = ssh_buffer_unpack(a3, "d", 1, &v12, 1332084403LL);
  if ( v13 )
    goto LABEL_6;
  v14 = (unsigned int *)ssh_channel_from_local(a1, v12);
  if ( !v14 )
  {
    ssh_set_error(a1, 2, "ssh_packet_channel_open_conf", "Unknown channel id %lu", v12, v8);
    return 1LL;
  }
  v13 = ssh_buffer_unpack(a3, "ddd", 3, v14 + 6, v14 + 7, v14 + 9, 1332084403LL);
  if ( v13 )
  {
LABEL_6:
    ssh_set_error(a1, 2, "ssh_packet_channel_open_conf", "Invalid packet", v6, v7);
    return 1LL;
  }
  else
  {
    ssh_log(
      2,
      "ssh_packet_channel_open_conf",
      "Received a CHANNEL_OPEN_CONFIRMATION for channel %d:%d",
      v14[2],
      v14[6],
      v7);
    ssh_log(2, "ssh_packet_channel_open_conf", "Remote window : %lu, maxpacket : %lu", v14[7], v14[9], v10);
    v14[10] = 3;
    v14[12] &= ~4u;
    return 1LL;
  }
}
// FB13: variable 'v8' is possibly undefined
// FBA5: variable 'v7' is possibly undefined
// FBDA: variable 'v10' is possibly undefined
// FC27: variable 'v6' is possibly undefined

//----- (000000000000FC33) ----------------------------------------------------
__int64 __fastcall ssh_packet_channel_open_fail(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v12; // [rsp+28h] [rbp-18h] BYREF
  void *ptr; // [rsp+30h] [rbp-10h] BYREF
  __int64 v15; // [rsp+38h] [rbp-8h]

  ptr = 0LL;
  v15 = channel_from_msg(a1, a3);
  if ( v15 )
  {
    if ( (unsigned int)ssh_buffer_unpack(a3, "ds", 2, &v12, &ptr, 1332084403LL, a4) )
    {
      ssh_set_error(a1, 2, "ssh_packet_channel_open_fail", "Invalid packet", v8, v9);
      return 1LL;
    }
    else
    {
      ssh_set_error(
        a1,
        1,
        "ssh_packet_channel_open_fail",
        "Channel opening failure: channel %u error (%lu) %s",
        *(unsigned int *)(v15 + 8),
        v12,
        ptr);
      if ( ptr )
      {
        free(ptr);
        ptr = 0LL;
      }
      *(_DWORD *)(v15 + 40) = 2;
      return 1LL;
    }
  }
  else
  {
    ssh_log(1, "ssh_packet_channel_open_fail", "Invalid channel in packet", v4, v5, v6, a4);
    return 1LL;
  }
}
// FC8A: variable 'v4' is possibly undefined
// FC8A: variable 'v5' is possibly undefined
// FC8A: variable 'v6' is possibly undefined
// FCF2: variable 'v8' is possibly undefined
// FCF2: variable 'v9' is possibly undefined

//----- (000000000000FD70) ----------------------------------------------------
_BOOL8 __fastcall ssh_channel_open_termination(_DWORD *a1)
{
  return a1[10] != 1 || *(_DWORD *)(*(_QWORD *)a1 + 1164LL) == 9;
}

//----- (000000000000FDAC) ----------------------------------------------------
__int64 __fastcall channel_open_0(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // eax
  __int64 v8; // r9
  unsigned int v12; // [rsp+20h] [rbp-10h]
  __int64 v13; // [rsp+28h] [rbp-8h]

  v13 = *(_QWORD *)a1;
  v12 = -1;
  v6 = *(_DWORD *)(a1 + 40);
  if ( v6 == 1 )
  {
LABEL_12:
    v12 = ssh_handle_packets_termination(
            v13,
            0xFFFFFFFD,
            (unsigned int (__fastcall *)(__int64))ssh_channel_open_termination,
            a1);
    if ( *(_DWORD *)(v13 + 1164) == 9 )
      v12 = -1;
    goto LABEL_14;
  }
  if ( !v6 )
  {
LABEL_5:
    *(_DWORD *)(a1 + 8) = ssh_channel_new_id(v13);
    *(_DWORD *)(a1 + 20) = a4;
    *(_DWORD *)(a1 + 12) = a3;
    ssh_log(
      2,
      "channel_open",
      "Creating a channel %d with %d window and %d max packet",
      *(unsigned int *)(a1 + 8),
      a3,
      a4);
    if ( (unsigned int)ssh_buffer_pack(
                         *(_QWORD *)(v13 + 1152),
                         "bsddd",
                         5,
                         90LL,
                         a2,
                         *(unsigned int *)(a1 + 8),
                         *(unsigned int *)(a1 + 12),
                         *(unsigned int *)(a1 + 20),
                         1332084403LL)
      || a5 && (int)ssh_buffer_add_buffer(*(_QWORD *)(v13 + 1152), a5) < 0 )
    {
      ssh_set_error_oom(v13, "channel_open");
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(a1 + 40) = 1;
    if ( (unsigned int)ssh_packet_send(v13) == -1 )
      return 0xFFFFFFFFLL;
    ssh_log(3, "channel_open", "Sent a SSH_MSG_CHANNEL_OPEN type %s for channel %d", a2, *(unsigned int *)(a1 + 8), v8);
    goto LABEL_12;
  }
  if ( v6 > 4 )
  {
    ssh_set_error(v13, 2, "channel_open", "Bad state in channel_open: %d", *(unsigned int *)(a1 + 40), a6);
    goto LABEL_5;
  }
LABEL_14:
  if ( *(_DWORD *)(a1 + 40) == 3 )
    return 0;
  return v12;
}
// FF88: variable 'v8' is possibly undefined

//----- (000000000000FFE0) ----------------------------------------------------
__int64 __fastcall ssh_channel_from_local(__int64 a1, int a2)
{
  _QWORD *i; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  for ( i = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(a1 + 1248)); i; i = (_QWORD *)*i )
  {
    v4 = i[1];
    if ( v4 && *(_DWORD *)(v4 + 8) == a2 )
      return i[1];
  }
  return 0LL;
}

//----- (0000000000010047) ----------------------------------------------------
__int64 __fastcall grow_window(__int64 a1, unsigned int *a2, int a3)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+28h] [rbp-8h]

  v3 = 1280000;
  if ( a3 >= 1280000 )
    v3 = a3;
  v5 = v3;
  if ( a2[3] >= v3 )
  {
    ssh_log(
      2,
      "grow_window",
      "growing window (channel %d:%d) to %d bytes : not needed (%d bytes)",
      a2[2],
      a2[6],
      v3,
      a2[3]);
    return 0LL;
  }
  if ( (unsigned int)ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "bdd", 3, 93LL, a2[6], v3 - a2[3], 1332084403LL) )
  {
    ssh_set_error_oom(a1, "grow_window");
  }
  else if ( (unsigned int)ssh_packet_send(a1) != -1 )
  {
    ssh_log(2, "grow_window", "growing window (channel %d:%d) to %d bytes", a2[2], a2[6], v5);
    a2[3] = v5;
    return 0LL;
  }
  ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
  return 0xFFFFFFFFLL;
}

//----- (00000000000101AB) ----------------------------------------------------
__int64 __fastcall channel_from_msg(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v5; // r9
  unsigned int v6; // [rsp+10h] [rbp-10h] BYREF
  __int64 v8; // [rsp+18h] [rbp-8h]

  if ( (unsigned int)ssh_buffer_unpack(a2, "d", 1, &v6, 1332084403LL) )
  {
    ssh_set_error(a1, 2, "channel_from_msg", "Getting channel from message: short read", v2, v3);
    return 0LL;
  }
  else
  {
    v8 = ssh_channel_from_local(a1, v6);
    if ( !v8 )
      ssh_set_error(a1, 2, "channel_from_msg", "Server specified invalid channel %lu", v6, v5);
    return v8;
  }
}
// 1020D: variable 'v2' is possibly undefined
// 1020D: variable 'v3' is possibly undefined
// 1025C: variable 'v5' is possibly undefined

//----- (0000000000010267) ----------------------------------------------------
__int64 __fastcall channel_rcv_change_window(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 error; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v11; // [rsp+0h] [rbp-30h]
  unsigned int v13; // [rsp+20h] [rbp-10h] BYREF
  int v14; // [rsp+24h] [rbp-Ch]
  unsigned int *v15; // [rsp+28h] [rbp-8h]

  v11 = a4;
  v15 = (unsigned int *)channel_from_msg(a1, a3);
  if ( !v15 )
  {
    error = ssh_get_error(a1);
    ssh_log(4, "channel_rcv_change_window", "%s", error, v5, v6, v11);
  }
  v14 = ssh_buffer_unpack(a3, "d", 1, &v13, 1332084403LL);
  if ( v15 && !v14 )
  {
    ssh_log(
      2,
      "channel_rcv_change_window",
      "Adding %d bytes to channel (%d:%d) (from %d bytes)",
      v13,
      v15[2],
      v15[6],
      v15[7]);
    v15[7] += v13;
    return 1LL;
  }
  else
  {
    ssh_log(3, "channel_rcv_change_window", "Error getting a window adjust message: invalid packet", v7, v8, v9, v11);
    return 1LL;
  }
}
// 102C5: variable 'v5' is possibly undefined
// 102C5: variable 'v6' is possibly undefined
// 1031C: variable 'v7' is possibly undefined
// 1031C: variable 'v8' is possibly undefined
// 1031C: variable 'v9' is possibly undefined
// 1031C: variable 'v11' is possibly undefined

//----- (0000000000010388) ----------------------------------------------------
__int64 __fastcall channel_rcv_data(__int64 a1, char a2, __int64 a3, __int64 a4)
{
  __int64 error; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r9
  unsigned int v12; // ebx
  const void *v13; // rax
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r9
  __int64 (__fastcall *v17)(_QWORD, __int64 *, __int64, _QWORD, _BOOL4, __int64); // rbx
  __int64 v18; // r12
  unsigned int len; // r13d
  __int64 v20; // rax
  int v21; // ebx
  __int64 v22; // [rsp+0h] [rbp-80h]
  char v24[4]; // [rsp+24h] [rbp-5Ch] BYREF
  _BOOL4 v25; // [rsp+28h] [rbp-58h]
  signed int v26; // [rsp+2Ch] [rbp-54h]
  __int64 v27; // [rsp+30h] [rbp-50h]
  __int64 *i; // [rsp+38h] [rbp-48h]
  __int64 *v29; // [rsp+40h] [rbp-40h]
  uint32_t *ssh_string; // [rsp+48h] [rbp-38h]
  unsigned __int64 v31; // [rsp+50h] [rbp-30h]
  _QWORD *v32; // [rsp+58h] [rbp-28h]

  v22 = a4;
  v25 = a2 != 94;
  v29 = (__int64 *)channel_from_msg(a1, a3);
  if ( v29 )
  {
    if ( v25 )
      ssh_buffer_get_u32(a3, v24);
    ssh_string = (uint32_t *)ssh_buffer_get_ssh_string(a3);
    if ( ssh_string )
    {
      v31 = ssh_string_len(ssh_string);
      ssh_log(
        3,
        "channel_rcv_data",
        "Channel receiving %zd bytes data in %d (local win=%d remote win=%d)",
        v31,
        v25,
        *((unsigned int *)v29 + 3),
        *((unsigned int *)v29 + 7));
      if ( *((unsigned int *)v29 + 3) < v31 )
        ssh_log(
          1,
          "channel_rcv_data",
          "Data packet too big for our window(%zd vs %d)",
          v31,
          *((unsigned int *)v29 + 3),
          v11,
          v22);
      v12 = v31;
      v13 = (const void *)ssh_string_data((__int64)ssh_string);
      if ( (int)channel_default_bufferize(v29, v13, v12, v25, v14, v15) >= 0 )
      {
        if ( *((unsigned int *)v29 + 3) < v31 )
          *((_DWORD *)v29 + 3) = 0;
        else
          *((_DWORD *)v29 + 3) -= v31;
        ssh_log(
          3,
          "channel_rcv_data",
          "Channel windows are now (local win=%d remote win=%d)",
          *((unsigned int *)v29 + 3),
          *((unsigned int *)v29 + 7),
          v16,
          v22);
        ssh_string_free(ssh_string);
        if ( v25 )
          v27 = v29[8];
        else
          v27 = v29[7];
        for ( i = (__int64 *)ssh_list_get_iterator(v29[11]); i; i = (__int64 *)*i )
        {
          v32 = (_QWORD *)i[1];
          if ( v32 && v32 + 2 < (_QWORD *)((char *)v32 + *v32) && v32[2] )
          {
            if ( !ssh_buffer_get(v27) )
              break;
            v17 = (__int64 (__fastcall *)(_QWORD, __int64 *, __int64, _QWORD, _BOOL4, __int64))v32[2];
            v18 = v32[1];
            len = ssh_buffer_get_len(v27);
            v20 = ssh_buffer_get(v27);
            v26 = v17(*v29, v29, v20, len, v25, v18);
            if ( v26 > 0 )
            {
              if ( v29[12] )
                *(_QWORD *)v29[12] += v26;
              ssh_buffer_pass_bytes(v27, v26);
            }
          }
        }
        v21 = *((_DWORD *)v29 + 3);
        if ( v21 + (unsigned int)ssh_buffer_get_len(v27) > 0x9C3FF || (int)grow_window(a1, (unsigned int *)v29, 0) >= 0 )
          return 1LL;
        else
          return 0xFFFFFFFFLL;
      }
      else
      {
        ssh_string_free(ssh_string);
        return 1LL;
      }
    }
    else
    {
      ssh_log(3, "channel_rcv_data", "Invalid data packet!", v8, v9, v10, v22);
      return 1LL;
    }
  }
  else
  {
    error = ssh_get_error(a1);
    ssh_log(4, "channel_rcv_data", "%s", error, v5, v6, v22);
    return 1LL;
  }
}
// 10401: variable 'v5' is possibly undefined
// 10401: variable 'v6' is possibly undefined
// 10458: variable 'v8' is possibly undefined
// 10458: variable 'v9' is possibly undefined
// 10458: variable 'v10' is possibly undefined
// 104F3: variable 'v11' is possibly undefined
// 1051B: variable 'v14' is possibly undefined
// 1051B: variable 'v15' is possibly undefined
// 10597: variable 'v16' is possibly undefined
// 10597: variable 'v22' is possibly undefined
// 10388: using guessed type char var_5C[4];

//----- (0000000000010738) ----------------------------------------------------
__int64 __fastcall channel_rcv_eof(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 error; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  _QWORD *i; // [rsp+28h] [rbp-18h]
  __int64 v12; // [rsp+30h] [rbp-10h]
  __int64 v13; // [rsp+38h] [rbp-8h]

  v12 = channel_from_msg(a1, a3);
  if ( v12 )
  {
    ssh_log(
      3,
      "channel_rcv_eof",
      "Received eof on channel (%d:%d)",
      *(unsigned int *)(v12 + 8),
      *(unsigned int *)(v12 + 24),
      v4,
      a4,
      a3);
    *(_DWORD *)(v12 + 32) = 1;
    for ( i = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(v12 + 88)); i; i = (_QWORD *)*i )
    {
      v13 = i[1];
      if ( v13 && v13 + 24 < (unsigned __int64)(*(_QWORD *)v13 + v13) )
      {
        if ( *(_QWORD *)(v13 + 24) )
          (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(v13 + 24))(*(_QWORD *)v12, v12, *(_QWORD *)(v13 + 8));
      }
    }
    return 1LL;
  }
  else
  {
    error = ssh_get_error(a1);
    ssh_log(4, "channel_rcv_eof", "%s", error, v6, v7, a4, a3);
    return 1LL;
  }
}
// 10796: variable 'v6' is possibly undefined
// 10796: variable 'v7' is possibly undefined
// 107D0: variable 'v4' is possibly undefined

//----- (000000000001086A) ----------------------------------------------------
__int64 __fastcall channel_rcv_close(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 error; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  _QWORD *i; // [rsp+28h] [rbp-18h]
  __int64 v15; // [rsp+30h] [rbp-10h]
  __int64 v16; // [rsp+38h] [rbp-8h]

  v15 = channel_from_msg(a1, a3);
  if ( v15 )
  {
    ssh_log(
      3,
      "channel_rcv_close",
      "Received close on channel (%d:%d)",
      *(unsigned int *)(v15 + 8),
      *(unsigned int *)(v15 + 24),
      v4,
      a4,
      a3);
    if ( *(_QWORD *)(v15 + 56) && (unsigned int)ssh_buffer_get_len(*(_QWORD *)(v15 + 56))
      || *(_QWORD *)(v15 + 64) && (unsigned int)ssh_buffer_get_len(*(_QWORD *)(v15 + 64)) )
    {
      *(_DWORD *)(v15 + 44) = 1;
    }
    else
    {
      *(_DWORD *)(v15 + 40) = 4;
    }
    if ( !*(_DWORD *)(v15 + 32) )
      ssh_log(3, "channel_rcv_close", "Remote host not polite enough to send an eof before close", v9, v10, v11);
    *(_DWORD *)(v15 + 32) = 1;
    for ( i = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(v15 + 88)); i; i = (_QWORD *)*i )
    {
      v16 = i[1];
      if ( v16 && v16 + 32 < (unsigned __int64)(*(_QWORD *)v16 + v16) && *(_QWORD *)(v16 + 32) )
        (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(v16 + 32))(*(_QWORD *)v15, v15, *(_QWORD *)(v16 + 8));
    }
    *(_DWORD *)(v15 + 48) |= 1u;
    if ( (*(_DWORD *)(v15 + 48) & 2) != 0 )
      ssh_channel_do_free((__int64 *)v15);
    return 1LL;
  }
  else
  {
    error = ssh_get_error(a1);
    ssh_log(4, "channel_rcv_close", "%s", error, v6, v7, a4, a3);
    return 1LL;
  }
}
// 108C8: variable 'v6' is possibly undefined
// 108C8: variable 'v7' is possibly undefined
// 10902: variable 'v4' is possibly undefined
// 10984: variable 'v9' is possibly undefined
// 10984: variable 'v10' is possibly undefined
// 10984: variable 'v11' is possibly undefined

//----- (0000000000010A4B) ----------------------------------------------------
__int64 __fastcall channel_rcv_request(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 error; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  unsigned __int8 v24; // [rsp+2Ah] [rbp-76h] BYREF
  unsigned __int8 v25; // [rsp+2Bh] [rbp-75h] BYREF
  int v26; // [rsp+2Ch] [rbp-74h]
  char *s1; // [rsp+30h] [rbp-70h] BYREF
  void *v28; // [rsp+38h] [rbp-68h] BYREF
  void *v29; // [rsp+40h] [rbp-60h] BYREF
  void *ptr; // [rsp+48h] [rbp-58h] BYREF
  __int64 *i; // [rsp+50h] [rbp-50h]
  __int64 *j; // [rsp+58h] [rbp-48h]
  const char *v33; // [rsp+60h] [rbp-40h]
  __int64 *k; // [rsp+68h] [rbp-38h]
  __int64 *m; // [rsp+70h] [rbp-30h]
  _QWORD *v36; // [rsp+78h] [rbp-28h]
  __int64 v37; // [rsp+80h] [rbp-20h]
  __int64 v38; // [rsp+88h] [rbp-18h]
  __int64 v39; // [rsp+90h] [rbp-10h]
  __int64 v40; // [rsp+98h] [rbp-8h]

  s1 = 0LL;
  v36 = (_QWORD *)channel_from_msg((__int64)a1, a3);
  if ( !v36 )
  {
    error = ssh_get_error((__int64)a1);
    ssh_log(4, "channel_rcv_request", "%s", error, v5, v6, a4);
    return 1LL;
  }
  v26 = ssh_buffer_unpack(a3, "sb", 2, &s1, &v24, 1332084403LL, a4);
  if ( v26 )
    goto LABEL_34;
  if ( !strcmp(s1, "exit-status") )
  {
    if ( s1 )
    {
      free(s1);
      s1 = 0LL;
    }
    v26 = ssh_buffer_unpack(a3, "d", 1, v36 + 10, 1332084403LL);
    ssh_log(3, "channel_rcv_request", "received exit-status %d", *((unsigned int *)v36 + 20), v11, v12);
    for ( i = (__int64 *)ssh_list_get_iterator(v36[11]); i; i = (__int64 *)*i )
    {
      v37 = i[1];
      if ( v37 && v37 + 48 < (unsigned __int64)(*(_QWORD *)v37 + v37) )
      {
        if ( *(_QWORD *)(v37 + 48) )
          (*(void (__fastcall **)(_QWORD, _QWORD *, _QWORD, _QWORD))(v37 + 48))(
            *v36,
            v36,
            *((unsigned int *)v36 + 20),
            *(_QWORD *)(v37 + 8));
      }
    }
    return 1LL;
  }
  if ( !strcmp(s1, "signal") )
  {
    ptr = 0LL;
    if ( s1 )
    {
      free(s1);
      s1 = 0LL;
    }
    ssh_log(3, "channel_rcv_request", "received signal", v13, v14, v15);
    v26 = ssh_buffer_unpack(a3, "s", 1, &ptr, 1332084403LL);
    if ( !v26 )
    {
      ssh_log(3, "channel_rcv_request", "Remote connection sent a signal SIG %s", (__int64)ptr, v9, v10);
      for ( j = (__int64 *)ssh_list_get_iterator(v36[11]); j; j = (__int64 *)*j )
      {
        v38 = j[1];
        if ( v38 && v38 + 40 < (unsigned __int64)(*(_QWORD *)v38 + v38) && *(_QWORD *)(v38 + 40) )
          (*(void (__fastcall **)(_QWORD, _QWORD *, void *, _QWORD))(v38 + 40))(*v36, v36, ptr, *(_QWORD *)(v38 + 8));
      }
      if ( ptr )
      {
        free(ptr);
        ptr = 0LL;
      }
      return 1LL;
    }
LABEL_34:
    ssh_log(3, "channel_rcv_request", "Invalid MSG_CHANNEL_REQUEST", v8, v9, v10);
    return 1LL;
  }
  if ( !strcmp(s1, "exit-signal") )
  {
    v33 = "(core dumped)";
    v28 = 0LL;
    v29 = 0LL;
    ptr = 0LL;
    if ( s1 )
    {
      free(s1);
      s1 = 0LL;
    }
    v26 = ssh_buffer_unpack(a3, "sbss", 4, &v28, &v25, &v29, &ptr, 1332084403LL);
    if ( v26 )
      goto LABEL_34;
    if ( !v25 )
      v33 = (const char *)&unk_532F6;
    ssh_log(3, "channel_rcv_request", "Remote connection closed by signal SIG %s %s", (__int64)v28, (__int64)v33, v10);
    for ( k = (__int64 *)ssh_list_get_iterator(v36[11]); k; k = (__int64 *)*k )
    {
      v39 = k[1];
      if ( v39 && v39 + 56 < (unsigned __int64)(*(_QWORD *)v39 + v39) && *(_QWORD *)(v39 + 56) )
        (*(void (__fastcall **)(_QWORD, _QWORD *, void *, _QWORD, void *, void *, _QWORD))(v39 + 56))(
          *v36,
          v36,
          v28,
          v25,
          v29,
          ptr,
          *(_QWORD *)(v39 + 8));
    }
    if ( ptr )
    {
      free(ptr);
      ptr = 0LL;
    }
    if ( v29 )
    {
      free(v29);
      v29 = 0LL;
    }
    if ( v28 )
    {
      free(v28);
      v28 = 0LL;
    }
    return 1LL;
  }
  else if ( !strcmp(s1, "keepalive@openssh.com") )
  {
    if ( s1 )
    {
      free(s1);
      s1 = 0LL;
    }
    ssh_log(2, "channel_rcv_request", "Responding to Openssh's keepalive", v16, v17, v18);
    v26 = ssh_buffer_pack(a1[144], "bd", 2, 100LL, *((unsigned int *)v36 + 6), 1332084403LL);
    if ( !v26 )
      ssh_packet_send((__int64)a1);
    return 1LL;
  }
  else if ( !strcmp(s1, "auth-agent-req@openssh.com") )
  {
    if ( s1 )
    {
      free(s1);
      s1 = 0LL;
    }
    ssh_log(2, "channel_rcv_request", "Received an auth-agent-req request", v19, v20, v21);
    for ( m = (__int64 *)ssh_list_get_iterator(v36[11]); m; m = (__int64 *)*m )
    {
      v40 = m[1];
      if ( v40 && v40 + 80 < (unsigned __int64)(*(_QWORD *)v40 + v40) && *(_QWORD *)(v40 + 80) )
        (*(void (__fastcall **)(_QWORD, _QWORD *, _QWORD))(v40 + 80))(*v36, v36, *(_QWORD *)(v40 + 8));
    }
    return 1LL;
  }
  else
  {
    ssh_message_handle_channel_request(a1, (__int64)v36, a3, s1, v24);
    if ( s1 )
    {
      free(s1);
      s1 = 0LL;
    }
    return 1LL;
  }
}
// 10AC9: variable 'v5' is possibly undefined
// 10AC9: variable 'v6' is possibly undefined
// 10BC9: variable 'v11' is possibly undefined
// 10BC9: variable 'v12' is possibly undefined
// 10CB7: variable 'v13' is possibly undefined
// 10CB7: variable 'v14' is possibly undefined
// 10CB7: variable 'v15' is possibly undefined
// 10D38: variable 'v9' is possibly undefined
// 10D38: variable 'v10' is possibly undefined
// 10EA7: variable 'v8' is possibly undefined
// 1104C: variable 'v16' is possibly undefined
// 1104C: variable 'v17' is possibly undefined
// 1104C: variable 'v18' is possibly undefined
// 11109: variable 'v19' is possibly undefined
// 11109: variable 'v20' is possibly undefined
// 11109: variable 'v21' is possibly undefined

//----- (00000000000111E4) ----------------------------------------------------
__int64 __fastcall channel_default_bufferize(
        __int64 *a1,
        const void *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  int v7; // [rsp+8h] [rbp-28h]
  unsigned int v8; // [rsp+Ch] [rbp-24h]
  __int64 v9; // [rsp+28h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  v9 = *a1;
  if ( !a2 )
  {
    ssh_set_error_invalid(v9, "channel_default_bufferize", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
  ssh_log(
    3,
    "channel_default_bufferize",
    "placing %d bytes into channel buffer (stderr=%d)",
    (unsigned int)a3,
    (unsigned int)a4,
    a6);
  if ( v7 )
  {
    if ( !a1[8] )
    {
      a1[8] = (__int64)ssh_buffer_new();
      if ( !a1[8] )
        goto LABEL_8;
    }
    if ( (int)ssh_buffer_add_data(a1[8], a2, v8) < 0 )
    {
      ssh_set_error_oom(v9, "channel_default_bufferize");
      ssh_buffer_free(a1[8]);
      a1[8] = 0LL;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if ( !a1[7] )
    {
      a1[7] = (__int64)ssh_buffer_new();
      if ( !a1[7] )
      {
LABEL_8:
        ssh_set_error_oom(v9, "channel_default_bufferize");
        return 0xFFFFFFFFLL;
      }
    }
    if ( (int)ssh_buffer_add_data(a1[7], a2, v8) < 0 )
    {
      ssh_set_error_oom(v9, "channel_default_bufferize");
      ssh_buffer_free(a1[7]);
      a1[7] = 0LL;
      return 0xFFFFFFFFLL;
    }
  }
  return 0LL;
}

//----- (00000000000113AD) ----------------------------------------------------
__int64 __fastcall ssh_channel_open_session(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( a1 )
    return channel_open_0(a1, (__int64)"session", 0xFA00u, 0x8000u, 0LL, a6);
  else
    return 0xFFFFFFFFLL;
}

//----- (00000000000113EC) ----------------------------------------------------
__int64 __fastcall ssh_channel_open_auth_agent(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( a1 )
    return channel_open_0(a1, (__int64)"auth-agent@openssh.com", 0xFA00u, 0x8000u, 0LL, a6);
  else
    return 0xFFFFFFFFLL;
}

//----- (000000000001142B) ----------------------------------------------------
__int64 __fastcall ssh_channel_open_forward(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r9
  unsigned int v9; // [rsp+8h] [rbp-38h]
  unsigned int v10; // [rsp+Ch] [rbp-34h]
  unsigned int v11; // [rsp+24h] [rbp-1Ch]
  void *v12; // [rsp+28h] [rbp-18h]
  __int64 v13; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v9 = a5;
  v11 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  v13 = *a1;
  if ( a2 && a4 )
  {
    v12 = ssh_buffer_new();
    if ( !v12 || (v11 = ssh_buffer_pack((__int64)v12, "sdsd", 4, a2, v10, a4, v9, 1332084403LL)) != 0 )
      ssh_set_error_oom(v13, "ssh_channel_open_forward");
    else
      v11 = channel_open_0((__int64)a1, (__int64)"direct-tcpip", 0xFA00u, 0x8000u, (__int64)v12, v7);
    ssh_buffer_free((__int64)v12);
    ssh_string_free(0LL);
    return v11;
  }
  else
  {
    ssh_set_error_invalid(v13, "ssh_channel_open_forward", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}
// 11543: variable 'v7' is possibly undefined

//----- (0000000000011568) ----------------------------------------------------
void __fastcall ssh_channel_free(__int64 *a1)
{
  if ( a1 )
  {
    if ( *(_DWORD *)(*a1 + 1100) && *((_DWORD *)a1 + 10) == 3 )
      ssh_channel_close((__int64)a1);
    *((_DWORD *)a1 + 12) |= 2u;
    if ( (a1[6] & 1) != 0 || (a1[6] & 4) != 0 )
      ssh_channel_do_free(a1);
  }
}

//----- (00000000000115EC) ----------------------------------------------------
void __fastcall ssh_channel_do_free(__int64 *a1)
{
  __int64 v1; // [rsp+10h] [rbp-10h]
  _QWORD *v2; // [rsp+18h] [rbp-8h]

  v1 = *a1;
  v2 = ssh_list_find(*(_QWORD *)(*a1 + 1248), (__int64)a1);
  if ( v2 )
    ssh_list_remove(*(_QWORD *)(v1 + 1248), v2);
  ssh_buffer_free(a1[7]);
  ssh_buffer_free(a1[8]);
  if ( a1[11] )
    ssh_list_free((_QWORD **)a1[11]);
  memset(a1, 88, 0x68uLL);
  if ( a1 )
    free(a1);
}

//----- (00000000000116B3) ----------------------------------------------------
__int64 __fastcall ssh_channel_send_eof(__int64 a1)
{
  __int64 v2; // r9
  unsigned int v3; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)a1;
  if ( (unsigned int)ssh_buffer_pack(
                       *(_QWORD *)(*(_QWORD *)a1 + 1152LL),
                       "bd",
                       2,
                       96LL,
                       *(unsigned int *)(a1 + 24),
                       1332084403LL) )
  {
    ssh_set_error_oom(v4, "ssh_channel_send_eof");
  }
  else
  {
    ssh_packet_send(v4);
    ssh_log(
      3,
      "ssh_channel_send_eof",
      "Sent a EOF on client channel (%d:%d)",
      *(unsigned int *)(a1 + 8),
      *(unsigned int *)(a1 + 24),
      v2);
    v3 = ssh_channel_flush((__int64 *)a1);
    if ( v3 != -1 )
    {
      *(_DWORD *)(a1 + 16) = 1;
      return v3;
    }
  }
  ssh_buffer_reinit(*(_QWORD *)(v4 + 1152));
  return 0xFFFFFFFFLL;
}
// 11771: variable 'v2' is possibly undefined

//----- (00000000000117B4) ----------------------------------------------------
__int64 __fastcall ssh_channel_close(__int64 a1)
{
  __int64 v2; // r9
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  unsigned int v4; // [rsp+14h] [rbp-Ch]
  int v5; // [rsp+14h] [rbp-Ch]
  __int64 v6; // [rsp+18h] [rbp-8h]

  v3 = 0;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  v6 = *(_QWORD *)a1;
  if ( !*(_DWORD *)(a1 + 16) )
    v3 = ssh_channel_send_eof(a1);
  if ( v3 )
    return v3;
  v4 = ssh_buffer_pack(*(_QWORD *)(v6 + 1152), "bd", 2, 97LL, *(unsigned int *)(a1 + 24), 1332084403LL);
  if ( v4 )
  {
    ssh_set_error_oom(v6, "ssh_channel_close");
  }
  else
  {
    v5 = ssh_packet_send(v6);
    ssh_log(
      3,
      "ssh_channel_close",
      "Sent a close on client channel (%d:%d)",
      *(unsigned int *)(a1 + 8),
      *(unsigned int *)(a1 + 24),
      v2);
    if ( !v5 )
      *(_DWORD *)(a1 + 40) = 4;
    v4 = ssh_channel_flush((__int64 *)a1);
    if ( v4 != -1 )
      return v4;
  }
  ssh_buffer_reinit(*(_QWORD *)(v6 + 1152));
  return v4;
}
// 1189C: variable 'v2' is possibly undefined

//----- (00000000000118E5) ----------------------------------------------------
_BOOL8 __fastcall ssh_channel_waitwindow_termination(_DWORD *a1)
{
  return a1[7] || *(_DWORD *)(*(_QWORD *)a1 + 1164LL) == 9 || a1[10] == 4;
}

//----- (000000000001192C) ----------------------------------------------------
_BOOL8 __fastcall ssh_waitsession_unblocked(__int64 a1)
{
  return (unsigned int)(*(_DWORD *)(a1 + 1164) - 4) > 2;
}

//----- (000000000001195C) ----------------------------------------------------
__int64 __fastcall ssh_channel_flush(__int64 *a1)
{
  return ssh_blocking_flush(*a1, 0xFFFFFFFD);
}

//----- (000000000001197E) ----------------------------------------------------
__int64 __fastcall channel_write_common(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned int v11; // eax
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  int v16; // [rsp+8h] [rbp-38h]
  unsigned int v17; // [rsp+Ch] [rbp-34h]
  __int64 v18; // [rsp+10h] [rbp-30h]
  int v19; // [rsp+20h] [rbp-20h]
  unsigned __int64 v20; // [rsp+28h] [rbp-18h]
  __int64 v21; // [rsp+28h] [rbp-18h]
  __int64 v22; // [rsp+30h] [rbp-10h]
  unsigned __int64 v23; // [rsp+38h] [rbp-8h]

  v18 = a2;
  v17 = a3;
  v16 = a4;
  v19 = a3;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  v22 = *(_QWORD *)a1;
  if ( !a2 )
  {
    ssh_set_error_invalid(v22, "channel_write_common", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
  if ( (int)a3 < 0 )
  {
    ssh_log(2, "channel_write_common", "Length (%u) is bigger than INT_MAX", (unsigned int)a3, a5, a6);
    return 0xFFFFFFFFLL;
  }
  v23 = (unsigned int)(*(_DWORD *)(a1 + 36) - 10);
  if ( *(_DWORD *)(a1 + 16) )
  {
    ssh_set_error(
      v22,
      1,
      "channel_write_common",
      "Can't write to channel %d:%d  after EOF was sent",
      *(unsigned int *)(a1 + 8),
      *(unsigned int *)(a1 + 24));
    return 0xFFFFFFFFLL;
  }
  if ( *(_DWORD *)(a1 + 40) != 3 || *(_DWORD *)(a1 + 44) )
  {
    ssh_set_error(v22, 1, "channel_write_common", "Remote channel is closed", a5, a6);
    return 0xFFFFFFFFLL;
  }
  if ( *(_DWORD *)(v22 + 1164) == 9 )
    return 0xFFFFFFFFLL;
  if ( !ssh_waitsession_unblocked(v22)
    && ((unsigned int)ssh_handle_packets_termination(
                        v22,
                        0xFFFFFFFD,
                        (unsigned int (__fastcall *)(__int64))ssh_waitsession_unblocked,
                        v22) == -1
     || !ssh_waitsession_unblocked(v22)) )
  {
    return v19 - v17;
  }
  while ( v17 )
  {
    if ( *(_DWORD *)(a1 + 28) >= v17 )
    {
      v20 = v17;
      goto LABEL_29;
    }
    ssh_log(
      2,
      "channel_write_common",
      "Remote window is %d bytes. going to write %d bytes",
      *(unsigned int *)(a1 + 28),
      v17,
      v7);
    if ( *(_DWORD *)(a1 + 28) )
    {
      v11 = v17;
      if ( *(_DWORD *)(a1 + 28) <= v17 )
        v11 = *(_DWORD *)(a1 + 28);
      v20 = v11;
LABEL_29:
      v12 = v20;
      if ( v23 <= v20 )
        v12 = v23;
      v21 = v12;
      if ( v16 )
        v13 = 95LL;
      else
        v13 = 94LL;
      if ( (unsigned int)ssh_buffer_pack(
                           *(_QWORD *)(v22 + 1152),
                           "bd",
                           2,
                           v13,
                           *(unsigned int *)(a1 + 24),
                           1332084403LL)
        || v16 && (unsigned int)ssh_buffer_pack(*(_QWORD *)(v22 + 1152), "d", 1, 1LL, 1332084403LL)
        || (unsigned int)ssh_buffer_pack(*(_QWORD *)(v22 + 1152), "dP", 3, v21, v21, v18, 1332084403LL) )
      {
        ssh_set_error_oom(v22, "channel_write_common");
        goto LABEL_47;
      }
      if ( (unsigned int)ssh_packet_send(v22) == -1 )
        return 0xFFFFFFFFLL;
      ssh_log(3, "channel_write_common", "channel_write wrote %ld bytes", v21, v14, v15);
      *(_DWORD *)(a1 + 28) -= v21;
      v17 -= v21;
      v18 += v21;
      if ( *(_QWORD *)(a1 + 96) )
        *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8LL) += v21;
    }
    else
    {
      ssh_log(2, "channel_write_common", "Wait for a growing window message...", v8, v9, v10);
      if ( (unsigned int)ssh_handle_packets_termination(
                           v22,
                           0xFFFFFFFD,
                           (unsigned int (__fastcall *)(__int64))ssh_channel_waitwindow_termination,
                           a1) == -1
        || !ssh_channel_waitwindow_termination((_DWORD *)a1)
        || *(_DWORD *)(v22 + 1164) == 9
        || *(_DWORD *)(a1 + 40) == 4 )
      {
        return v19 - v17;
      }
    }
  }
  if ( (unsigned int)ssh_channel_flush((__int64 *)a1) != -1 )
    return v19 - v17;
LABEL_47:
  ssh_buffer_reinit(*(_QWORD *)(v22 + 1152));
  return 0xFFFFFFFFLL;
}
// 11B58: variable 'v7' is possibly undefined
// 11B84: variable 'v8' is possibly undefined
// 11B84: variable 'v9' is possibly undefined
// 11B84: variable 'v10' is possibly undefined
// 11D82: variable 'v14' is possibly undefined
// 11D82: variable 'v15' is possibly undefined

//----- (0000000000011E1A) ----------------------------------------------------
__int64 __fastcall ssh_channel_window_size(__int64 a1)
{
  return *(unsigned int *)(a1 + 28);
}

//----- (0000000000011E2B) ----------------------------------------------------
__int64 __fastcall ssh_channel_write(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  return channel_write_common(a1, a2, a3, 0LL, a5, a6);
}

//----- (0000000000011E58) ----------------------------------------------------
_BOOL8 __fastcall ssh_channel_is_open(_DWORD *a1)
{
  if ( !a1 )
    return 0LL;
  return a1[10] == 3 && *(_DWORD *)(*(_QWORD *)a1 + 1100LL);
}

//----- (0000000000011E99) ----------------------------------------------------
__int64 __fastcall ssh_channel_is_closed(_DWORD *a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  return a1[10] != 3 || !*(_DWORD *)(*(_QWORD *)a1 + 1100LL);
}

//----- (0000000000011EDA) ----------------------------------------------------
__int64 __fastcall ssh_channel_is_eof(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 56) && (unsigned int)ssh_buffer_get_len(*(_QWORD *)(a1 + 56))
    || *(_QWORD *)(a1 + 64) && (unsigned int)ssh_buffer_get_len(*(_QWORD *)(a1 + 64)) )
  {
    return 0LL;
  }
  return *(_DWORD *)(a1 + 32) != 0;
}

//----- (0000000000011F4E) ----------------------------------------------------
__int64 __fastcall ssh_channel_set_blocking(__int64 *a1, int a2)
{
  __int64 result; // rax

  if ( a1 )
    return ssh_set_blocking(*a1, a2);
  return result;
}

//----- (0000000000011F7D) ----------------------------------------------------
__int64 __fastcall ssh_packet_channel_success(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 error; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned int *v13; // [rsp+28h] [rbp-8h]

  v13 = (unsigned int *)channel_from_msg(a1, a3);
  if ( v13 )
  {
    ssh_log(
      3,
      "ssh_packet_channel_success",
      "Received SSH_CHANNEL_SUCCESS on channel (%d:%d)",
      v13[2],
      v13[6],
      v4,
      a4,
      a3);
    if ( v13[21] == 1 )
      v13[21] = 2;
    else
      ssh_log(1, "ssh_packet_channel_success", "SSH_CHANNEL_SUCCESS received in incorrect state %d", v13[21], v9, v10);
    return 1LL;
  }
  else
  {
    error = ssh_get_error(a1);
    ssh_log(4, "ssh_packet_channel_success", "%s", error, v6, v7, a4, a3);
    return 1LL;
  }
}
// 11FDB: variable 'v6' is possibly undefined
// 11FDB: variable 'v7' is possibly undefined
// 12012: variable 'v4' is possibly undefined
// 12044: variable 'v9' is possibly undefined
// 12044: variable 'v10' is possibly undefined

//----- (000000000001205D) ----------------------------------------------------
__int64 __fastcall ssh_packet_channel_failure(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 error; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned int *v13; // [rsp+28h] [rbp-8h]

  v13 = (unsigned int *)channel_from_msg(a1, a3);
  if ( v13 )
  {
    ssh_log(
      3,
      "ssh_packet_channel_failure",
      "Received SSH_CHANNEL_FAILURE on channel (%d:%d)",
      v13[2],
      v13[6],
      v4,
      a4,
      a3);
    if ( v13[21] == 1 )
      v13[21] = 3;
    else
      ssh_log(1, "ssh_packet_channel_failure", "SSH_CHANNEL_FAILURE received in incorrect state %d", v13[21], v9, v10);
    return 1LL;
  }
  else
  {
    error = ssh_get_error(a1);
    ssh_log(4, "ssh_packet_channel_failure", "%s", error, v6, v7, a4, a3);
    return 1LL;
  }
}
// 120BB: variable 'v6' is possibly undefined
// 120BB: variable 'v7' is possibly undefined
// 120F2: variable 'v4' is possibly undefined
// 12124: variable 'v9' is possibly undefined
// 12124: variable 'v10' is possibly undefined

//----- (000000000001213D) ----------------------------------------------------
_BOOL8 __fastcall ssh_channel_request_termination(_DWORD *a1)
{
  return a1[21] != 1 || *(_DWORD *)(*(_QWORD *)a1 + 1164LL) == 9;
}

//----- (0000000000012179) ----------------------------------------------------
__int64 __fastcall channel_request(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  unsigned int len; // ebx
  const void *v5; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 result; // rax
  unsigned int v13; // [rsp+20h] [rbp-20h]
  __int64 v14; // [rsp+28h] [rbp-18h]

  v14 = *(_QWORD *)a1;
  if ( *(_DWORD *)(a1 + 84) )
    goto LABEL_10;
  if ( (unsigned int)ssh_buffer_pack(
                       *(_QWORD *)(v14 + 1152),
                       "bdsb",
                       4,
                       98LL,
                       *(unsigned int *)(a1 + 24),
                       a2,
                       a4 != 0,
                       1332084403LL)
    || a3
    && (len = ssh_buffer_get_len(a3),
        v5 = (const void *)ssh_buffer_get(a3),
        (int)ssh_buffer_add_data(*(_QWORD *)(v14 + 1152), v5, len) < 0) )
  {
    ssh_set_error_oom(v14, "channel_request");
    ssh_buffer_reinit(*(_QWORD *)(v14 + 1152));
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 84) = 1;
  if ( (unsigned int)ssh_packet_send(v14) == -1 )
    return 0xFFFFFFFFLL;
  ssh_log(3, "channel_request", "Sent a SSH_MSG_CHANNEL_REQUEST %s", a2, v6, v7);
  if ( a4 )
  {
LABEL_10:
    v13 = ssh_handle_packets_termination(
            v14,
            0xFFFFFFFD,
            (unsigned int (__fastcall *)(__int64))ssh_channel_request_termination,
            a1);
    if ( *(_DWORD *)(v14 + 1164) == 9 || v13 == -1 )
      *(_DWORD *)(a1 + 84) = 4;
    switch ( *(_DWORD *)(a1 + 84) )
    {
      case 0:
        ssh_set_error(v14, 2, "channel_request", "Invalid state in channel_request()", v8, v9);
        v13 = -1;
        goto LABEL_19;
      case 1:
        return 4294967294LL;
      case 2:
        ssh_log(2, "channel_request", "Channel request %s success", a2, v8, v9);
        v13 = 0;
        goto LABEL_19;
      case 3:
        ssh_set_error(v14, 1, "channel_request", "Channel request %s failed", a2, v9);
        v13 = -1;
        goto LABEL_19;
      case 4:
        v13 = -1;
        goto LABEL_19;
      default:
LABEL_19:
        *(_DWORD *)(a1 + 84) = 0;
        result = v13;
        break;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 84) = 0;
    return 0LL;
  }
  return result;
}
// 122BE: variable 'v6' is possibly undefined
// 122BE: variable 'v7' is possibly undefined
// 12385: variable 'v9' is possibly undefined
// 123B2: variable 'v8' is possibly undefined

//----- (0000000000012424) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_pty_size(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v7; // [rsp+8h] [rbp-38h]
  unsigned int v8; // [rsp+Ch] [rbp-34h]
  unsigned int v9; // [rsp+2Ch] [rbp-14h]
  void *v10; // [rsp+30h] [rbp-10h]
  __int64 v11; // [rsp+38h] [rbp-8h]

  v8 = a3;
  v7 = a4;
  v10 = 0LL;
  v9 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  v11 = *(_QWORD *)a1;
  if ( a2 )
  {
    if ( *(_DWORD *)(a1 + 84)
      || (v10 = ssh_buffer_new()) != 0LL
      && (v9 = ssh_buffer_pack((__int64)v10, "sdddddb", 7, a2, v8, v7, 0LL, 0LL, 1LL, 0LL, 1332084403LL)) == 0 )
    {
      v9 = channel_request(a1, (__int64)"pty-req", (__int64)v10, 1);
    }
    else
    {
      ssh_set_error_oom(v11, "ssh_channel_request_pty_size");
    }
    ssh_buffer_free((__int64)v10);
    return v9;
  }
  else
  {
    ssh_set_error_invalid(*(_QWORD *)a1, "ssh_channel_request_pty_size", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000012556) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_pty(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return ssh_channel_request_pty_size(a1, (__int64)"xterm", 80LL, 24LL, a5, a6);
}

//----- (0000000000012581) ----------------------------------------------------
__int64 __fastcall ssh_channel_change_pty_size(__int64 *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v5; // [rsp+1Ch] [rbp-14h]
  __int64 v6; // [rsp+20h] [rbp-10h]
  void *v7; // [rsp+28h] [rbp-8h]

  v6 = *a1;
  v5 = -1;
  v7 = ssh_buffer_new();
  if ( !v7 || (v5 = ssh_buffer_pack((__int64)v7, "dddd", 4, a2, a3, 0LL, 0LL, 1332084403LL)) != 0 )
    ssh_set_error_oom(v6, "ssh_channel_change_pty_size");
  else
    v5 = channel_request((__int64)a1, (__int64)"window-change", (__int64)v7, 0);
  ssh_buffer_free((__int64)v7);
  return v5;
}

//----- (0000000000012659) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_shell(__int64 a1)
{
  if ( a1 )
    return channel_request(a1, (__int64)"shell", 0LL, 1);
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000012692) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_subsystem(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned int v7; // [rsp+14h] [rbp-Ch]
  void *v8; // [rsp+18h] [rbp-8h]

  v8 = 0LL;
  v7 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    if ( *(_DWORD *)(a1 + 84)
      || (v8 = ssh_buffer_new()) != 0LL && (v7 = ssh_buffer_pack((__int64)v8, "s", 1, a2, 1332084403LL)) == 0 )
    {
      v7 = channel_request(a1, (__int64)"subsystem", (__int64)v8, 1);
    }
    else
    {
      ssh_set_error_oom(*(_QWORD *)a1, "ssh_channel_request_subsystem");
    }
    ssh_buffer_free((__int64)v8);
    return v7;
  }
  else
  {
    ssh_set_error_invalid(*(_QWORD *)a1, "ssh_channel_request_subsystem", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000012798) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_sftp(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( a1 )
    return ssh_channel_request_subsystem(a1, (__int64)"sftp", a3, a4, a5, a6);
  else
    return 0xFFFFFFFFLL;
}

//----- (00000000000127C7) ----------------------------------------------------
char *generate_cookie()
{
  int i; // [rsp+8h] [rbp-48h]
  char v2[16]; // [rsp+10h] [rbp-40h] BYREF
  char s[40]; // [rsp+20h] [rbp-30h] BYREF
  unsigned __int64 v4; // [rsp+48h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  if ( !(unsigned int)ssh_get_random((__int64)v2, 16) )
    return 0LL;
  for ( i = 0; i <= 15; ++i )
  {
    s[2 * i] = hex_9293[v2[i] & 0xF];
    s[2 * i + 1] = hex_9293[(unsigned __int8)v2[i] >> 4];
  }
  s[32] = 0;
  return strdup(s);
}
// 280758: using guessed type char *hex_9293;
// 127C7: using guessed type char var_40[16];

//----- (0000000000012893) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_x11(__int64 a1, int a2, const char *a3, char *a4, unsigned int a5)
{
  char *v6; // rdx
  char *v7; // rax
  unsigned int v11; // [rsp+2Ch] [rbp-14h]
  void *v12; // [rsp+30h] [rbp-10h]
  char *ptr; // [rsp+38h] [rbp-8h]

  v12 = 0LL;
  ptr = 0LL;
  v11 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_DWORD *)(a1 + 84) )
    goto LABEL_18;
  v12 = ssh_buffer_new();
  if ( !v12 )
    goto LABEL_8;
  if ( !a4 )
  {
    ptr = generate_cookie();
    if ( !ptr )
      goto LABEL_8;
  }
  v6 = a4 ? a4 : ptr;
  v7 = a3 ? (char *)a3 : "MIT-MAGIC-COOKIE-1";
  v11 = ssh_buffer_pack((__int64)v12, "bssd", 4, a2 != 0, v7, v6, a5, 1332084403LL);
  if ( ptr )
    free(ptr);
  if ( !v11 )
LABEL_18:
    v11 = channel_request(a1, (__int64)"x11-req", (__int64)v12, 1);
  else
LABEL_8:
    ssh_set_error_oom(*(_QWORD *)a1, "ssh_channel_request_x11");
  ssh_buffer_free((__int64)v12);
  return v11;
}

//----- (0000000000012A13) ----------------------------------------------------
__int64 *__fastcall ssh_channel_accept(__int64 a1, int a2, int a3, _DWORD *a4, __int64 a5, __int64 a6)
{
  int i; // [rsp+24h] [rbp-1Ch]
  _QWORD *j; // [rsp+28h] [rbp-18h]
  __int64 v11; // [rsp+30h] [rbp-10h]
  __int64 *v12; // [rsp+38h] [rbp-8h]

  for ( i = a3; i >= 0; i -= 100 )
  {
    if ( a3 )
      ssh_handle_packets(a1, 50);
    else
      ssh_handle_packets(a1, 0);
    if ( *(_QWORD *)(a1 + 1336) )
    {
      for ( j = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(a1 + 1336)); j; j = (_QWORD *)*j )
      {
        v11 = j[1];
        if ( (unsigned int)ssh_message_type(v11) == 2 && (unsigned int)ssh_message_subtype((_DWORD *)v11) == a2 )
        {
          ssh_list_remove(*(_QWORD *)(a1 + 1336), j);
          v12 = ssh_message_channel_request_open_reply_accept((__int64 *)v11);
          if ( a4 )
            *a4 = *(unsigned __int16 *)(v11 + 96);
          ssh_message_free(v11);
          return v12;
        }
      }
    }
    if ( i > 0 )
      nanosleep(&ts_9323, 0LL);
  }
  ssh_set_error(a1, 0, "ssh_channel_accept", "No channel request of this type from server", a5, a6);
  return 0LL;
}
// 12B7A: variable 'a5' is possibly undefined
// 12B7A: variable 'a6' is possibly undefined

//----- (0000000000012B86) ----------------------------------------------------
__int64 *__fastcall ssh_channel_accept_x11(__int64 *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return ssh_channel_accept(*a1, 4, a2, 0LL, a5, a6);
}

//----- (0000000000012BB3) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_auth_agent(__int64 a1)
{
  if ( a1 )
    return channel_request(a1, (__int64)"auth-agent-req@openssh.com", 0LL, 0);
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000012BEC) ----------------------------------------------------
__int64 __fastcall ssh_request_success(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9

  ssh_log(3, "ssh_request_success", "Received SSH_REQUEST_SUCCESS", a4, a5, a6, a4, a3);
  if ( *(_DWORD *)(a1 + 1184) == 1 )
    *(_DWORD *)(a1 + 1184) = 2;
  else
    ssh_log(
      1,
      "ssh_request_success",
      "SSH_REQUEST_SUCCESS received in incorrect state %d",
      *(unsigned int *)(a1 + 1184),
      v6,
      v7);
  return 1LL;
}
// 12C55: variable 'v6' is possibly undefined
// 12C55: variable 'v7' is possibly undefined

//----- (0000000000012C71) ----------------------------------------------------
__int64 __fastcall ssh_request_denied(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9

  ssh_log(3, "ssh_request_denied", "Received SSH_REQUEST_FAILURE", a4, a5, a6, a4, a3);
  if ( *(_DWORD *)(a1 + 1184) == 1 )
    *(_DWORD *)(a1 + 1184) = 3;
  else
    ssh_log(
      1,
      "ssh_request_denied",
      "SSH_REQUEST_DENIED received in incorrect state %d",
      *(unsigned int *)(a1 + 1184),
      v6,
      v7);
  return 1LL;
}
// 12CDA: variable 'v6' is possibly undefined
// 12CDA: variable 'v7' is possibly undefined

//----- (0000000000012CF6) ----------------------------------------------------
_BOOL8 __fastcall ssh_global_request_termination(__int64 a1)
{
  return *(_DWORD *)(a1 + 1184) != 1 || *(_DWORD *)(a1 + 1164) == 9;
}

//----- (0000000000012D32) ----------------------------------------------------
__int64 __fastcall global_request(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  unsigned int len; // ebx
  const void *v5; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 result; // rax
  unsigned int v14; // [rsp+2Ch] [rbp-14h]

  if ( *(_DWORD *)(a1 + 1184) )
    goto LABEL_10;
  if ( (unsigned int)ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "bsb", 3, 80LL, a2, a4 != 0, 1332084403LL)
    || a3
    && (len = ssh_buffer_get_len(a3),
        v5 = (const void *)ssh_buffer_get(a3),
        (int)ssh_buffer_add_data(*(_QWORD *)(a1 + 1152), v5, len) < 0) )
  {
    ssh_set_error_oom(a1, "global_request");
    ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 1184) = 1;
  if ( (unsigned int)ssh_packet_send(a1) == -1 )
    return 0xFFFFFFFFLL;
  ssh_log(3, "global_request", "Sent a SSH_MSG_GLOBAL_REQUEST %s", a2, v6, v7);
  if ( a4 )
  {
LABEL_10:
    v14 = ssh_handle_packets_termination(
            a1,
            0xFFFFFFFD,
            (unsigned int (__fastcall *)(__int64))ssh_global_request_termination,
            a1);
    if ( v14 == -1 || *(_DWORD *)(a1 + 1164) == 9 )
      *(_DWORD *)(a1 + 1184) = 4;
    switch ( *(_DWORD *)(a1 + 1184) )
    {
      case 0:
      case 4:
        v14 = -1;
        goto LABEL_18;
      case 1:
        return 4294967294LL;
      case 2:
        ssh_log(2, "global_request", "Global request %s success", a2, v8, v9);
        v14 = 0;
        goto LABEL_18;
      case 3:
        ssh_log(3, "global_request", "Global request %s failed", a2, v8, v9);
        ssh_set_error(a1, 1, "global_request", "Global request %s failed", a2, v10);
        v14 = -1;
        goto LABEL_18;
      default:
LABEL_18:
        *(_DWORD *)(a1 + 1184) = 0;
        result = v14;
        break;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 1184) = 0;
    return 0LL;
  }
  return result;
}
// 12E7E: variable 'v6' is possibly undefined
// 12E7E: variable 'v7' is possibly undefined
// 12F3B: variable 'v8' is possibly undefined
// 12F3B: variable 'v9' is possibly undefined
// 12F93: variable 'v10' is possibly undefined

//----- (0000000000012FE0) ----------------------------------------------------
__int64 __fastcall ssh_channel_listen_forward(__int64 a1, void *a2, unsigned int a3, _DWORD *a4)
{
  void *v4; // rax
  _DWORD *v6; // [rsp+0h] [rbp-30h]
  unsigned int v8; // [rsp+24h] [rbp-Ch]
  void *v9; // [rsp+28h] [rbp-8h]

  v6 = a4;
  v9 = 0LL;
  v8 = -1;
  if ( *(_DWORD *)(a1 + 1184)
    || (v9 = ssh_buffer_new()) != 0LL
    && (!a2 ? (v4 = &unk_532F6) : (v4 = a2),
        (v8 = ssh_buffer_pack((__int64)v9, byte_53858, 2, v4, a3, 1332084403LL, v6)) == 0) )
  {
    v8 = global_request(a1, (__int64)"tcpip-forward", (__int64)v9, 1);
    if ( !v8 && !a3 )
    {
      if ( v6 )
      {
        v8 = ssh_buffer_unpack(*(_QWORD *)(a1 + 1128), "d", 1, v6, 1332084403LL);
        if ( v8 )
          *v6 = 0;
      }
    }
  }
  else
  {
    ssh_set_error_oom(a1, "ssh_channel_listen_forward");
  }
  ssh_buffer_free((__int64)v9);
  return v8;
}
// 130CC: variable 'v6' is possibly undefined
// 53858: using guessed type _BYTE byte_53858[3];

//----- (0000000000013123) ----------------------------------------------------
__int64 __fastcall ssh_forward_listen(__int64 a1, void *a2, unsigned int a3, _DWORD *a4)
{
  return ssh_channel_listen_forward(a1, a2, a3, a4);
}

//----- (0000000000013153) ----------------------------------------------------
__int64 *__fastcall ssh_forward_accept(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return ssh_channel_accept(a1, 3, a2, 0LL, a5, a6);
}

//----- (000000000001317D) ----------------------------------------------------
__int64 *__fastcall ssh_channel_accept_forward(__int64 a1, int a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  return ssh_channel_accept(a1, 3, a2, a3, a5, a6);
}

//----- (00000000000131AA) ----------------------------------------------------
__int64 __fastcall ssh_channel_cancel_forward(__int64 a1, void *a2, unsigned int a3)
{
  void *v3; // rax
  unsigned int v6; // [rsp+24h] [rbp-Ch]
  void *v7; // [rsp+28h] [rbp-8h]

  v7 = 0LL;
  v6 = -1;
  if ( *(_DWORD *)(a1 + 1184)
    || (v7 = ssh_buffer_new()) != 0LL
    && (!a2 ? (v3 = &unk_532F6) : (v3 = a2),
        (v6 = ssh_buffer_pack((__int64)v7, byte_53858, 2, v3, a3, 1332084403LL)) == 0) )
  {
    v6 = global_request(a1, (__int64)"cancel-tcpip-forward", (__int64)v7, 1);
  }
  else
  {
    ssh_set_error_oom(a1, "ssh_channel_cancel_forward");
  }
  ssh_buffer_free((__int64)v7);
  return v6;
}
// 53858: using guessed type _BYTE byte_53858[3];

//----- (000000000001328F) ----------------------------------------------------
__int64 __fastcall ssh_forward_cancel(__int64 a1, void *a2, unsigned int a3)
{
  return ssh_channel_cancel_forward(a1, a2, a3);
}

//----- (00000000000132BA) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_env(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v8; // [rsp+24h] [rbp-Ch]
  void *v9; // [rsp+28h] [rbp-8h]

  v9 = 0LL;
  v8 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 && a3 )
  {
    if ( *(_DWORD *)(a1 + 84)
      || (v9 = ssh_buffer_new()) != 0LL && (v8 = ssh_buffer_pack((__int64)v9, "ss", 2, a2, a3, 1332084403LL)) == 0 )
    {
      v8 = channel_request(a1, (__int64)"env", (__int64)v9, 1);
    }
    else
    {
      ssh_set_error_oom(*(_QWORD *)a1, "ssh_channel_request_env");
    }
    ssh_buffer_free((__int64)v9);
    return v8;
  }
  else
  {
    ssh_set_error_invalid(*(_QWORD *)a1, "ssh_channel_request_env", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (00000000000133D2) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_exec(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v7; // [rsp+14h] [rbp-Ch]
  void *v8; // [rsp+18h] [rbp-8h]

  v8 = 0LL;
  v7 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    if ( *(_DWORD *)(a1 + 84)
      || (v8 = ssh_buffer_new()) != 0LL && (v7 = ssh_buffer_pack((__int64)v8, "s", 1, a2, 1332084403LL)) == 0 )
    {
      v7 = channel_request(a1, (__int64)"exec", (__int64)v8, 1);
    }
    else
    {
      ssh_set_error_oom(*(_QWORD *)a1, "ssh_channel_request_exec");
    }
    ssh_buffer_free((__int64)v8);
    return v7;
  }
  else
  {
    ssh_set_error_invalid(*(_QWORD *)a1, "ssh_channel_request_exec", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (00000000000134D8) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_send_signal(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned int v7; // [rsp+14h] [rbp-Ch]
  void *v8; // [rsp+18h] [rbp-8h]

  v7 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    v8 = ssh_buffer_new();
    if ( !v8 || (v7 = ssh_buffer_pack((__int64)v8, "s", 1, a2, 1332084403LL)) != 0 )
      ssh_set_error_oom(*a1, "ssh_channel_request_send_signal");
    else
      v7 = channel_request((__int64)a1, (__int64)"signal", (__int64)v8, 0);
    ssh_buffer_free((__int64)v8);
    return v7;
  }
  else
  {
    ssh_set_error_invalid(*a1, "ssh_channel_request_send_signal", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (00000000000135D0) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_send_break(__int64 *a1, unsigned int a2)
{
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  void *v4; // [rsp+18h] [rbp-8h]

  v3 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  v4 = ssh_buffer_new();
  if ( !v4 || (v3 = ssh_buffer_pack((__int64)v4, "d", 1, a2, 1332084403LL)) != 0 )
    ssh_set_error_oom(*a1, "ssh_channel_request_send_break");
  else
    v3 = channel_request((__int64)a1, (__int64)"break", (__int64)v4, 0);
  ssh_buffer_free((__int64)v4);
  return v3;
}

//----- (00000000000136A0) ----------------------------------------------------
__int64 __fastcall channel_read_buffer(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned int v11; // [rsp+8h] [rbp-2038h]
  unsigned int v12; // [rsp+Ch] [rbp-2034h]
  signed int v13; // [rsp+20h] [rbp-2020h]
  unsigned int v14; // [rsp+20h] [rbp-2020h]
  signed int v15; // [rsp+20h] [rbp-2020h]
  unsigned int v16; // [rsp+24h] [rbp-201Ch]
  __int64 v17; // [rsp+28h] [rbp-2018h]
  char v18[8200]; // [rsp+30h] [rbp-2010h] BYREF
  unsigned __int64 v19; // [rsp+2038h] [rbp-8h]

  v12 = a3;
  v11 = a4;
  v19 = __readfsqword(0x28u);
  v16 = 0;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  v17 = *a1;
  if ( a2 )
  {
    ssh_buffer_reinit(a2);
    if ( v12 )
    {
      while ( v16 < v12 )
      {
        v15 = ssh_channel_read((__int64)a1, v18, 0x2000u, v11, v7, v8);
        if ( v15 < 0 )
          return (unsigned int)v15;
        if ( !v15 )
          return v16;
        if ( (int)ssh_buffer_add_data(a2, v18, v15) < 0 )
        {
          ssh_set_error_oom(v17, "channel_read_buffer");
          return 0xFFFFFFFFLL;
        }
        v16 += v15;
      }
      return v16;
    }
    else
    {
      while ( 1 )
      {
        v13 = ssh_channel_poll((__int64)a1, v11);
        if ( v13 < 0 )
          return (unsigned int)v13;
        if ( v13 > 0 )
          break;
        if ( (unsigned int)ssh_channel_is_eof((__int64)a1) )
          return 0LL;
        ssh_handle_packets(*a1, -1);
      }
      v14 = ssh_channel_read((__int64)a1, v18, v13, v11, v9, v10);
      if ( (v14 & 0x80000000) == 0 )
      {
        if ( (int)ssh_buffer_add_data(a2, v18, v14) < 0 )
        {
          ssh_set_error_oom(v17, "channel_read_buffer");
          return (unsigned int)-1;
        }
        return v14;
      }
      else
      {
        return v14;
      }
    }
  }
  else
  {
    ssh_set_error_invalid(*a1, "channel_read_buffer", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}
// 1384F: conditional instruction was optimized away because %var_2020.4==0
// 137A7: variable 'v9' is possibly undefined
// 137A7: variable 'v10' is possibly undefined
// 13878: variable 'v7' is possibly undefined
// 13878: variable 'v8' is possibly undefined

//----- (000000000001391F) ----------------------------------------------------
_BOOL8 __fastcall ssh_channel_read_termination(__int64 a1)
{
  return (unsigned int)ssh_buffer_get_len(*(_QWORD *)(a1 + 16)) >= *(_DWORD *)(a1 + 8)
      || *(_DWORD *)(*(_QWORD *)a1 + 32LL)
      || *(_DWORD *)(**(_QWORD **)a1 + 1164LL) == 9;
}

//----- (0000000000013981) ----------------------------------------------------
__int64 __fastcall ssh_channel_read(__int64 a1, void *a2, unsigned int a3, unsigned int a4, __int64 a5, __int64 a6)
{
  return ssh_channel_read_timeout(a1, a2, a3, a4, 0xFFFFFFFFLL, a6);
}

//----- (00000000000139B5) ----------------------------------------------------
__int64 __fastcall ssh_channel_read_timeout(__int64 a1, void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v7; // ebx
  unsigned int len; // eax
  int v9; // eax
  unsigned int v10; // eax
  size_t v11; // rbx
  const void *v12; // rax
  signed int v13; // [rsp+4h] [rbp-6Ch]
  unsigned int v14; // [rsp+Ch] [rbp-64h]
  unsigned int n; // [rsp+2Ch] [rbp-44h]
  unsigned int na; // [rsp+2Ch] [rbp-44h]
  __int64 n_4; // [rsp+30h] [rbp-40h]
  __int64 v18; // [rsp+38h] [rbp-38h]
  __int64 v19; // [rsp+40h] [rbp-30h] BYREF
  int v20; // [rsp+48h] [rbp-28h]
  __int64 v21; // [rsp+50h] [rbp-20h]

  v14 = a3;
  v13 = a5;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    v18 = *(_QWORD *)a1;
    n_4 = *(_QWORD *)(a1 + 56);
    if ( (_DWORD)a3 )
    {
      if ( (_DWORD)a4 )
        n_4 = *(_QWORD *)(a1 + 64);
      v7 = *(_DWORD *)(a1 + 12);
      len = ssh_buffer_get_len(n_4);
      ssh_log(3, "ssh_channel_read_timeout", "Read (%d) buffered : %d bytes. Window: %d", v14, len, v7);
      if ( (unsigned int)ssh_buffer_get_len(n_4) + *(_DWORD *)(a1 + 12) >= v14
        || (v9 = ssh_buffer_get_len(n_4), (int)grow_window(v18, (unsigned int *)a1, v14 - v9) >= 0) )
      {
        v19 = a1;
        v21 = n_4;
        v20 = 1;
        if ( v13 < 0 )
          v13 = -3;
        if ( (unsigned int)ssh_handle_packets_termination(
                             v18,
                             v13,
                             (unsigned int (__fastcall *)(__int64))ssh_channel_read_termination,
                             (__int64)&v19) == -1 )
        {
          return 0xFFFFFFFFLL;
        }
        else if ( *(_DWORD *)(v18 + 1164) == 9 )
        {
          return 0xFFFFFFFFLL;
        }
        else if ( !*(_DWORD *)(a1 + 32) || (unsigned int)ssh_buffer_get_len(n_4) )
        {
          n = ssh_buffer_get_len(n_4);
          v10 = v14;
          if ( n <= v14 )
            v10 = n;
          na = v10;
          v11 = v10;
          v12 = (const void *)ssh_buffer_get(n_4);
          memcpy(a2, v12, v11);
          ssh_buffer_pass_bytes(n_4, na);
          if ( *(_QWORD *)(a1 + 96) )
            **(_QWORD **)(a1 + 96) += na;
          if ( *(_DWORD *)(a1 + 12) > 0x9C3FFu || (int)grow_window(v18, (unsigned int *)a1, 0) >= 0 )
            return na;
          else
            return 0xFFFFFFFFLL;
        }
        else
        {
          return 0LL;
        }
      }
      else
      {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 0LL;
    }
  }
  else
  {
    ssh_set_error_invalid(*(_QWORD *)a1, "ssh_channel_read_timeout", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000013C15) ----------------------------------------------------
__int64 __fastcall ssh_channel_read_nonblocking(__int64 *a1, void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // [rsp+8h] [rbp-38h]
  signed int v10; // [rsp+Ch] [rbp-34h]
  signed int v11; // [rsp+2Ch] [rbp-14h]
  int is_blocking; // [rsp+30h] [rbp-10h]
  unsigned int v13; // [rsp+34h] [rbp-Ch]
  __int64 v14; // [rsp+38h] [rbp-8h]

  v10 = a3;
  v9 = a4;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    v14 = *a1;
    v11 = ssh_channel_poll((__int64)a1, a4);
    if ( v11 > 0 )
    {
      if ( v11 > v10 )
        v11 = v10;
      is_blocking = ssh_is_blocking(v14);
      ssh_set_blocking(v14, 0);
      v13 = ssh_channel_read((__int64)a1, a2, v11, v9, v7, v8);
      ssh_set_blocking(v14, is_blocking);
      return v13;
    }
    else if ( *(_DWORD *)(v14 + 1164) == 9 )
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      return (unsigned int)v11;
    }
  }
  else
  {
    ssh_set_error_invalid(*a1, "ssh_channel_read_nonblocking", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}
// 13CE2: variable 'v7' is possibly undefined
// 13CE2: variable 'v8' is possibly undefined

//----- (0000000000013D00) ----------------------------------------------------
__int64 __fastcall ssh_channel_poll(__int64 a1, int a2)
{
  __int64 v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 56);
  if ( a2 )
    v3 = *(_QWORD *)(a1 + 64);
  if ( (unsigned int)ssh_buffer_get_len(v3) || *(_DWORD *)(a1 + 32) )
    goto LABEL_17;
  if ( *(_DWORD *)(*(_QWORD *)a1 + 1164LL) == 9 )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)ssh_handle_packets(*(_QWORD *)a1, 0) == -1 )
    return 0xFFFFFFFFLL;
LABEL_17:
  if ( (unsigned int)ssh_buffer_get_len(v3) || !*(_DWORD *)(a1 + 32) )
    return ssh_buffer_get_len(v3);
  return 4294967169LL;
}

//----- (0000000000013DD0) ----------------------------------------------------
__int64 __fastcall ssh_channel_poll_timeout(__int64 a1, unsigned int a2, int a3)
{
  int len; // [rsp+1Ch] [rbp-34h]
  __int64 v5; // [rsp+20h] [rbp-30h]
  __int64 v6; // [rsp+28h] [rbp-28h]
  __int64 v7; // [rsp+30h] [rbp-20h] BYREF
  int v8; // [rsp+38h] [rbp-18h]
  __int64 v9; // [rsp+40h] [rbp-10h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v6 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(a1 + 56);
  if ( a3 )
    v5 = *(_QWORD *)(a1 + 64);
  v9 = v5;
  v7 = a1;
  v8 = 1;
  if ( (unsigned int)ssh_handle_packets_termination(
                       *(_QWORD *)a1,
                       a2,
                       (unsigned int (__fastcall *)(__int64))ssh_channel_read_termination,
                       (__int64)&v7) == -1
    || *(_DWORD *)(v6 + 1164) == 9 )
  {
    return (unsigned int)-1;
  }
  else
  {
    len = ssh_buffer_get_len(v5);
    if ( len <= 0 )
    {
      if ( *(_DWORD *)(a1 + 32) )
        return (unsigned int)-127;
    }
  }
  return (unsigned int)len;
}

//----- (0000000000013EA3) ----------------------------------------------------
__int64 __fastcall ssh_channel_get_session(__int64 a1)
{
  if ( a1 )
    return *(_QWORD *)a1;
  else
    return 0LL;
}

//----- (0000000000013EC2) ----------------------------------------------------
_BOOL8 __fastcall ssh_channel_exit_status_termination(_DWORD *a1)
{
  return a1[20] != -1 || (a1[12] & 1) != 0 || *(_DWORD *)(*(_QWORD *)a1 + 1164LL) == 9;
}

//----- (0000000000013F0C) ----------------------------------------------------
__int64 __fastcall ssh_channel_get_exit_status(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)ssh_handle_packets_termination(
                       *(_QWORD *)a1,
                       0xFFFFFFFD,
                       (unsigned int (__fastcall *)(__int64))ssh_channel_exit_status_termination,
                       a1) == -1
    || *(_DWORD *)(*(_QWORD *)a1 + 1164LL) == 9 )
  {
    return 0xFFFFFFFFLL;
  }
  return *(unsigned int *)(a1 + 80);
}

//----- (0000000000013F73) ----------------------------------------------------
__int64 __fastcall channel_protocol_select(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _BOOL4 j; // eax
  int i; // [rsp+30h] [rbp-10h]
  int k; // [rsp+30h] [rbp-10h]
  int m; // [rsp+30h] [rbp-10h]
  int v15; // [rsp+34h] [rbp-Ch]
  int v16; // [rsp+34h] [rbp-Ch]
  int v17; // [rsp+34h] [rbp-Ch]
  __int64 v18; // [rsp+38h] [rbp-8h]
  _DWORD *v19; // [rsp+38h] [rbp-8h]
  _DWORD *v20; // [rsp+38h] [rbp-8h]

  v15 = 0;
  for ( i = 0; *(_QWORD *)(8LL * i + a1); ++i )
  {
    v18 = *(_QWORD *)(8LL * i + a1);
    for ( j = ssh_channel_is_open((_DWORD *)v18);
          j && (unsigned int)ssh_socket_data_available(*(_QWORD *)(*(_QWORD *)v18 + 1048LL));
          j = ssh_channel_is_open((_DWORD *)v18) )
    {
      ssh_handle_packets(*(_QWORD *)v18, 0);
    }
    if ( *(_QWORD *)(v18 + 56) && (unsigned int)ssh_buffer_get_len(*(_QWORD *)(v18 + 56))
      || *(_QWORD *)(v18 + 64) && (unsigned int)ssh_buffer_get_len(*(_QWORD *)(v18 + 64))
      || *(_DWORD *)(v18 + 32) )
    {
      *(_QWORD *)(a4 + 8LL * v15++) = v18;
    }
  }
  *(_QWORD *)(8LL * v15 + a4) = 0LL;
  v16 = 0;
  for ( k = 0; *(_QWORD *)(8LL * k + a2); ++k )
  {
    v19 = *(_DWORD **)(8LL * k + a2);
    if ( (unsigned int)ssh_socket_data_writable(*(_QWORD *)(*(_QWORD *)v19 + 1048LL))
      && ssh_channel_is_open(v19)
      && v19[7] )
    {
      *(_QWORD *)(a5 + 8LL * v16++) = v19;
    }
  }
  *(_QWORD *)(8LL * v16 + a5) = 0LL;
  v17 = 0;
  for ( m = 0; *(_QWORD *)(8LL * m + a3); ++m )
  {
    v20 = *(_DWORD **)(8LL * m + a3);
    if ( !ssh_socket_is_open(*(_DWORD **)(*(_QWORD *)v20 + 1048LL)) || (unsigned int)ssh_channel_is_closed(v20) )
      *(_QWORD *)(a6 + 8LL * v17++) = v20;
  }
  *(_QWORD *)(8LL * v17 + a6) = 0LL;
  return 0LL;
}

//----- (0000000000014224) ----------------------------------------------------
__int64 __fastcall count_ptrs(__int64 a1)
{
  unsigned int i; // [rsp+14h] [rbp-4h]

  for ( i = 0; *(_QWORD *)(8LL * (int)i + a1); ++i )
    ;
  return i;
}

//----- (000000000001425A) ----------------------------------------------------
__int64 __fastcall ssh_channel_select(__int64 *a1, __int64 *a2, __int64 *a3, _QWORD *a4)
{
  int v5; // eax
  int v6; // eax
  int v7; // eax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  int v11; // eax
  int v12; // eax
  int v13; // eax
  __int64 *v15; // [rsp+10h] [rbp-60h]
  __int64 *dest; // [rsp+18h] [rbp-58h]
  int i; // [rsp+24h] [rbp-4Ch]
  int j; // [rsp+24h] [rbp-4Ch]
  int k; // [rsp+24h] [rbp-4Ch]
  int v20; // [rsp+28h] [rbp-48h]
  unsigned int v21; // [rsp+2Ch] [rbp-44h]
  int v22; // [rsp+30h] [rbp-40h]
  unsigned int v23; // [rsp+34h] [rbp-3Ch]
  __int64 v24; // [rsp+38h] [rbp-38h] BYREF
  __int64 *v25; // [rsp+40h] [rbp-30h]
  void *ptr; // [rsp+48h] [rbp-28h]
  void *src; // [rsp+50h] [rbp-20h]
  void *v28; // [rsp+58h] [rbp-18h]
  __time_t v29[2]; // [rsp+60h] [rbp-10h] BYREF

  dest = a1;
  v15 = a2;
  v24 = 0LL;
  v25 = 0LL;
  v22 = 1;
  if ( a4 )
    v21 = 1000 * *a4 + a4[1] / 1000LL;
  else
    v21 = -1;
  ssh_timestamp_init(v29);
  v20 = v21;
  if ( !a1 )
    dest = &v24;
  if ( !a2 )
    v15 = &v24;
  if ( !a3 )
    a3 = &v24;
  if ( !*dest && !*v15 && !*a3 )
    return 0LL;
  v5 = count_ptrs((__int64)dest);
  ptr = calloc(v5 + 1, 8uLL);
  if ( !ptr )
    return 0xFFFFFFFFLL;
  v6 = count_ptrs((__int64)v15);
  src = calloc(v6 + 1, 8uLL);
  if ( src )
  {
    v7 = count_ptrs((__int64)a3);
    v28 = calloc(v7 + 1, 8uLL);
    if ( v28 )
    {
      while ( 1 )
      {
        channel_protocol_select((__int64)dest, (__int64)v15, (__int64)a3, (__int64)ptr, (__int64)src, (__int64)v28);
        if ( *(_QWORD *)ptr || *(_QWORD *)src || *(_QWORD *)v28 )
          break;
        if ( !v25 )
        {
          v25 = ssh_event_new();
          if ( !v25 )
          {
            if ( ptr )
            {
              free(ptr);
              ptr = 0LL;
            }
            if ( src )
            {
              free(src);
              src = 0LL;
            }
            if ( v28 )
            {
              free(v28);
              v28 = 0LL;
            }
            return 0xFFFFFFFFLL;
          }
          for ( i = 0; dest[i]; ++i )
          {
            ssh_poll_get_default_ctx(*(_QWORD *)dest[i]);
            ssh_event_add_session((__int64)v25, *(_QWORD *)dest[i]);
          }
          for ( j = 0; v15[j]; ++j )
          {
            ssh_poll_get_default_ctx(*(_QWORD *)v15[j]);
            ssh_event_add_session((__int64)v25, *(_QWORD *)v15[j]);
          }
          for ( k = 0; a3[k]; ++k )
          {
            ssh_poll_get_default_ctx(*(_QWORD *)a3[k]);
            ssh_event_add_session((__int64)v25, *(_QWORD *)a3[k]);
          }
        }
        if ( !v22 && ssh_timeout_elapsed(v29, v21, v21, v8, v9, v10) )
          break;
        v23 = ssh_event_dopoll(v25, v20);
        if ( v23 )
        {
          if ( ptr )
          {
            free(ptr);
            ptr = 0LL;
          }
          if ( src )
          {
            free(src);
            src = 0LL;
          }
          if ( v28 )
          {
            free(v28);
            v28 = 0LL;
          }
          ssh_event_free((_QWORD **)v25);
          return v23;
        }
        v20 = ssh_timeout_update(v29, v21);
        v22 = 0;
      }
      v11 = count_ptrs((__int64)ptr);
      memcpy(dest, ptr, 8LL * (v11 + 1));
      v12 = count_ptrs((__int64)src);
      memcpy(v15, src, 8LL * (v12 + 1));
      v13 = count_ptrs((__int64)v28);
      memcpy(a3, v28, 8LL * (v13 + 1));
      if ( ptr )
      {
        free(ptr);
        ptr = 0LL;
      }
      if ( src )
      {
        free(src);
        src = 0LL;
      }
      if ( v28 )
      {
        free(v28);
        v28 = 0LL;
      }
      if ( v25 )
        ssh_event_free((_QWORD **)v25);
      return 0LL;
    }
    else
    {
      if ( ptr )
      {
        free(ptr);
        ptr = 0LL;
      }
      if ( src )
      {
        free(src);
        src = 0LL;
      }
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if ( ptr )
    {
      free(ptr);
      ptr = 0LL;
    }
    return 0xFFFFFFFFLL;
  }
}
// 14665: variable 'v8' is possibly undefined
// 14665: variable 'v9' is possibly undefined
// 14665: variable 'v10' is possibly undefined
// 1425A: using guessed type __time_t var_10[2];

//----- (0000000000014801) ----------------------------------------------------
__int64 __fastcall ssh_channel_set_counter(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = a1;
    *(_QWORD *)(a1 + 96) = a2;
  }
  return result;
}

//----- (0000000000014823) ----------------------------------------------------
__int64 __fastcall ssh_channel_write_stderr(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  return channel_write_common(a1, a2, a3, 1LL, a5, a6);
}

//----- (0000000000014850) ----------------------------------------------------
__int64 __fastcall ssh_channel_open_reverse_forward(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned int v8; // [rsp+8h] [rbp-38h]
  unsigned int v9; // [rsp+Ch] [rbp-34h]
  unsigned int v10; // [rsp+2Ch] [rbp-14h]
  void *v11; // [rsp+30h] [rbp-10h]
  __int64 v12; // [rsp+38h] [rbp-8h]

  v9 = a3;
  v8 = a5;
  v11 = 0LL;
  v10 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 && a4 )
  {
    v12 = *(_QWORD *)a1;
    if ( *(_DWORD *)(a1 + 40)
      || (v11 = ssh_buffer_new()) != 0LL
      && (v10 = ssh_buffer_pack((__int64)v11, "sdsd", 4, a2, v9, a4, v8, 1332084403LL)) == 0 )
    {
      v10 = channel_open_0(a1, (__int64)"forwarded-tcpip", 0xFA00u, 0x8000u, (__int64)v11, a6);
    }
    else
    {
      ssh_set_error_oom(v12, "ssh_channel_open_reverse_forward");
    }
    ssh_buffer_free((__int64)v11);
    return v10;
  }
  else
  {
    ssh_set_error_invalid(*(_QWORD *)a1, "ssh_channel_open_reverse_forward", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}
// 14973: variable 'a6' is possibly undefined

//----- (000000000001498C) ----------------------------------------------------
__int64 __fastcall ssh_channel_open_x11(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v7; // [rsp+Ch] [rbp-34h]
  unsigned int v8; // [rsp+2Ch] [rbp-14h]
  void *v9; // [rsp+30h] [rbp-10h]
  __int64 v10; // [rsp+38h] [rbp-8h]

  v7 = a3;
  v9 = 0LL;
  v8 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    v10 = *(_QWORD *)a1;
    if ( *(_DWORD *)(a1 + 40)
      || (v9 = ssh_buffer_new()) != 0LL && (v8 = ssh_buffer_pack((__int64)v9, byte_53858, 2, a2, v7, 1332084403LL)) == 0 )
    {
      v8 = channel_open_0(a1, (__int64)"x11", 0xFA00u, 0x8000u, (__int64)v9, a6);
    }
    else
    {
      ssh_set_error_oom(v10, "ssh_channel_open_x11");
    }
    ssh_buffer_free((__int64)v9);
    return v8;
  }
  else
  {
    ssh_set_error_invalid(*(_QWORD *)a1, "ssh_channel_open_x11", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}
// 14A8B: variable 'a6' is possibly undefined
// 53858: using guessed type _BYTE byte_53858[3];

//----- (0000000000014AA4) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_send_exit_status(__int64 *a1, unsigned int a2)
{
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  void *v4; // [rsp+18h] [rbp-8h]

  v3 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  v4 = ssh_buffer_new();
  if ( !v4 || (v3 = ssh_buffer_pack((__int64)v4, "d", 1, a2, 1332084403LL)) != 0 )
    ssh_set_error_oom(*a1, "ssh_channel_request_send_exit_status");
  else
    v3 = channel_request((__int64)a1, (__int64)"exit-status", (__int64)v4, 0);
  ssh_buffer_free((__int64)v4);
  return v3;
}

//----- (0000000000014B74) ----------------------------------------------------
__int64 __fastcall ssh_channel_request_send_exit_signal(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  int v9; // [rsp+1Ch] [rbp-24h]
  unsigned int v10; // [rsp+34h] [rbp-Ch]
  void *v11; // [rsp+38h] [rbp-8h]

  v9 = a3;
  v10 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 && a4 && a5 )
  {
    v11 = ssh_buffer_new();
    if ( !v11 || (v10 = ssh_buffer_pack((__int64)v11, "sbss", 4, a2, v9 != 0, a4, a5, 1332084403LL)) != 0 )
      ssh_set_error_oom(*a1, "ssh_channel_request_send_exit_signal");
    else
      v10 = channel_request((__int64)a1, (__int64)"exit-signal", (__int64)v11, 0);
    ssh_buffer_free((__int64)v11);
    return v10;
  }
  else
  {
    ssh_set_error_invalid(*a1, "ssh_channel_request_send_exit_signal", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000014CA0) ----------------------------------------------------
unsigned __int64 __fastcall socket_callback_connected(
        unsigned int a1,
        unsigned int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  char *v7; // rax
  __int64 v8; // r9

  if ( *(_DWORD *)(a3 + 1164) != 1 && *(_DWORD *)(a3 + 1164) != 2 )
    return ssh_set_error(
             a3,
             2,
             "socket_callback_connected",
             "Wrong state in socket_callback_connected : %d",
             *(unsigned int *)(a3 + 1164),
             a6,
             a3);
  ssh_log(1, "socket_callback_connected", "Socket connection callback: %d (%d)", a1, a2, a6, a3);
  if ( a1 == 1 )
  {
    *(_DWORD *)(a3 + 1164) = 2;
  }
  else
  {
    *(_DWORD *)(a3 + 1164) = 9;
    v7 = strerror(a2);
    ssh_set_error(a3, 2, "socket_callback_connected", "%s", (__int64)v7, v8);
  }
  return (*(__int64 (__fastcall **)(__int64))(a3 + 1368))(a3);
}
// 14D89: variable 'v8' is possibly undefined

//----- (0000000000014DA4) ----------------------------------------------------
__int64 __fastcall callback_receive_banner(
        const char *a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned int v11; // [rsp+28h] [rbp-28h]
  unsigned __int64 i; // [rsp+30h] [rbp-20h]
  char *v14; // [rsp+48h] [rbp-8h]

  v11 = 0;
  if ( *(_DWORD *)(a3 + 1164) == 2 )
  {
    for ( i = 0LL; ; ++i )
    {
      if ( i >= a2 )
        return v11;
      if ( *(_QWORD *)(a3 + 1456) && a1[i] == 10 )
        ssh_pcap_context_write(*(_QWORD *)(a3 + 1456), 0, (__int64)a1, i + 1, i + 1);
      if ( a1[i] == 13 )
        a1[i] = 0;
      if ( a1[i] == 10 )
        break;
      if ( i > 0xFF )
      {
        *(_DWORD *)(a3 + 1164) = 9;
        ssh_set_error(a3, 2, "callback_receive_banner", "Receiving banner: too large banner", a5, a6);
        return 0LL;
      }
    }
    a1[i] = 0;
    if ( strncmp(a1, "SSH-", 4uLL) )
    {
      ssh_log(3, "callback_receive_banner", "ssh_protocol_version_exchange: %s", (__int64)a1, v7, v8);
      return (unsigned int)(i + 1);
    }
    v14 = strdup(a1);
    if ( v14 )
    {
      *(_QWORD *)(a3 + 1056) = v14;
      *(_DWORD *)(a3 + 1164) = 3;
      ssh_log(3, "callback_receive_banner", "Received banner: %s", (__int64)v14, v9, v10);
      (*(void (__fastcall **)(__int64))(a3 + 1368))(a3);
      return (unsigned int)(i + 1);
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error(
      a3,
      2,
      "callback_receive_banner",
      "Wrong state in callback_receive_banner : %d",
      *(unsigned int *)(a3 + 1164),
      a6);
    return 0xFFFFFFFFLL;
  }
}
// 14F4D: variable 'v9' is possibly undefined
// 14F4D: variable 'v10' is possibly undefined
// 14F8D: variable 'v7' is possibly undefined
// 14F8D: variable 'v8' is possibly undefined
// 14FD5: variable 'a5' is possibly undefined
// 14FD5: variable 'a6' is possibly undefined

//----- (0000000000014FF9) ----------------------------------------------------
__int64 __fastcall ssh_send_banner(__int64 a1, int a2)
{
  signed int v2; // eax
  int v3; // ebx
  unsigned int v4; // eax
  unsigned int v6; // [rsp+14h] [rbp-13Ch]
  size_t v7; // [rsp+28h] [rbp-128h]
  char v8[264]; // [rsp+30h] [rbp-120h] BYREF
  unsigned __int64 v9; // [rsp+138h] [rbp-18h]

  v9 = __readfsqword(0x28u);
  memset(v8, 0, 0x100uLL);
  v6 = -1;
  if ( a2 == 1 )
  {
    if ( *(_QWORD *)(a1 + 1608) )
    {
      v7 = strlen(*(const char **)(a1 + 1608));
      *(_QWORD *)(a1 + 1056) = malloc(v7 + 9);
      if ( !*(_QWORD *)(a1 + 1056) )
        return v6;
      snprintf(*(char **)(a1 + 1056), v7 + 9, "SSH-2.0-%s", *(const char **)(a1 + 1608));
    }
    else
    {
      strlen("SSH-2.0-libssh_0.8.1");
      *(_QWORD *)(a1 + 1056) = strdup("SSH-2.0-libssh_0.8.1");
      if ( !*(_QWORD *)(a1 + 1056) )
        return v6;
    }
    snprintf(v8, 0x100uLL, "%s%s", *(const char **)(a1 + 1056), "\r\n");
  }
  else
  {
    *(_QWORD *)(a1 + 1064) = strdup("SSH-2.0-libssh_0.8.1");
    if ( !*(_QWORD *)(a1 + 1064) )
      return v6;
    snprintf(v8, 0x100uLL, "%s%s", *(const char **)(a1 + 1064), "\r\n");
  }
  v2 = strlen(v8);
  v6 = ssh_socket_write(*(_QWORD *)(a1 + 1048), v8, v2);
  if ( v6 != -1 )
  {
    if ( *(_QWORD *)(a1 + 1456) )
    {
      v3 = strlen(v8);
      v4 = strlen(v8);
      ssh_pcap_context_write(*(_QWORD *)(a1 + 1456), 1, (__int64)v8, v4, v3);
    }
    return 0;
  }
  return v6;
}

//----- (00000000000152E6) ----------------------------------------------------
__int64 __fastcall dh_handshake(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  unsigned int v8; // [rsp+1Ch] [rbp-4h]

  v8 = -2;
  v6 = *(_DWORD *)(a1 + 1172);
  switch ( v6 )
  {
    case 1:
      return v8;
    case 0:
      switch ( *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) )
      {
        case 1:
        case 2:
          v8 = ssh_client_dh_init(a1);
          break;
        case 3:
        case 4:
        case 5:
          v8 = ssh_client_ecdh_init(a1);
          break;
        case 6:
        case 7:
          v8 = ssh_client_curve25519_init(a1);
          break;
        default:
          v8 = -1;
          break;
      }
      if ( v8 == -1 )
        return 0xFFFFFFFFLL;
      *(_DWORD *)(a1 + 1172) = 1;
      return v8;
    case 2:
      return v8;
    case 3:
      return 0LL;
  }
  ssh_set_error(a1, 2, "dh_handshake", "Invalid state in dh_handshake(): %d", *(unsigned int *)(a1 + 1172), a6);
  return 0xFFFFFFFFLL;
}

//----- (0000000000015400) ----------------------------------------------------
_BOOL8 __fastcall ssh_service_request_termination(__int64 a1)
{
  return *(_DWORD *)(a1 + 1164) == 9 || *(_DWORD *)(a1 + 1176) != 1;
}

//----- (000000000001543C) ----------------------------------------------------
__int64 __fastcall ssh_service_request(__int64 a1, __int64 a2)
{
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // r8
  __int64 v6; // r9
  int v7; // eax
  unsigned int v8; // [rsp+1Ch] [rbp-4h]

  if ( !*(_DWORD *)(a1 + 1176) )
  {
    if ( (unsigned int)ssh_buffer_pack(*(_QWORD *)(a1 + 1152), byte_53F4C, 2, 5LL, a2, 1332084403LL) )
    {
      ssh_set_error_oom(a1, "ssh_service_request");
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(a1 + 1176) = 1;
    if ( (unsigned int)ssh_packet_send(a1) == -1 )
    {
      ssh_set_error(a1, 2, "ssh_service_request", "Sending SSH2_MSG_SERVICE_REQUEST failed.", v3, v4);
      return 0xFFFFFFFFLL;
    }
    ssh_log(3, "ssh_service_request", "Sent SSH_MSG_SERVICE_REQUEST (service %s)", a2, v3, v4);
  }
  v8 = ssh_handle_packets_termination(
         a1,
         0xFFFFFFFE,
         (unsigned int (__fastcall *)(__int64))ssh_service_request_termination,
         a1);
  if ( v8 == -1 )
    return 0xFFFFFFFFLL;
  v7 = *(_DWORD *)(a1 + 1176);
  if ( v7 == 1 )
  {
    return (unsigned int)-2;
  }
  else if ( v7 )
  {
    if ( v7 == 2 )
    {
      return 0;
    }
    else if ( v7 == 3 )
    {
      ssh_set_error(a1, 2, "ssh_service_request", "ssh_auth_service request denied", v5, v6);
    }
  }
  else
  {
    return (unsigned int)-1;
  }
  return v8;
}
// 154FF: variable 'v3' is possibly undefined
// 154FF: variable 'v4' is possibly undefined
// 155A1: variable 'v5' is possibly undefined
// 155A1: variable 'v6' is possibly undefined
// 53F4C: using guessed type _BYTE byte_53F4C[4];

//----- (00000000000155C7) ----------------------------------------------------
__int64 __fastcall ssh_client_connection_callback(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9

  result = *(unsigned int *)(a1 + 1164);
  switch ( (int)result )
  {
    case 0:
    case 1:
    case 4:
    case 7:
      return result;
    case 2:
      ssh_set_fd_towrite(a1);
      result = ssh_send_banner(a1, 0);
      break;
    case 3:
      if ( !*(_QWORD *)(a1 + 1056) )
        goto LABEL_32;
      if ( *(_QWORD *)(a1 + 1032) && *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 32LL) )
        (*(void (__fastcall **)(_QWORD, float))(*(_QWORD *)(a1 + 1032) + 32LL))(
          *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL),
          0.40000001);
      ssh_log(1, "ssh_client_connection_callback", "SSH server banner: %s", *(_QWORD *)(a1 + 1056), a5, a6);
      if ( (int)ssh_analyze_banner(a1, 0, v7, v8, v9, v10) < 0 )
      {
        ssh_set_error(
          a1,
          2,
          "ssh_client_connection_callback",
          "No version of SSH protocol usable (banner: %s)",
          *(_QWORD *)(a1 + 1056),
          v11);
        goto LABEL_32;
      }
      ssh_packet_register_socket_callback((_QWORD *)a1, *(_QWORD *)(a1 + 1048));
      ssh_packet_set_default_callbacks(a1);
      *(_DWORD *)(a1 + 1164) = 4;
      result = *(_QWORD *)(a1 + 1032);
      if ( result )
      {
        result = *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 32LL);
        if ( result )
          result = (*(__int64 (__fastcall **)(_QWORD, float))(*(_QWORD *)(a1 + 1032) + 32LL))(
                     *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL),
                     0.5);
      }
      break;
    case 5:
      if ( *(_QWORD *)(a1 + 1032) && *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 32LL) )
        (*(void (__fastcall **)(_QWORD, float))(*(_QWORD *)(a1 + 1032) + 32LL))(
          *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL),
          0.60000002);
      ssh_list_kex(*(_QWORD *)(a1 + 1240) + 368LL, a2, a3, a4, a5, a6);
      if ( (int)ssh_set_client_kex(a1) < 0
        || (unsigned int)ssh_kex_select_methods(a1) == -1
        || (int)ssh_send_kex((__int64 *)a1, 0) < 0 )
      {
        goto LABEL_32;
      }
      if ( *(_QWORD *)(a1 + 1032) && *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 32LL) )
        (*(void (__fastcall **)(_QWORD, float))(*(_QWORD *)(a1 + 1032) + 32LL))(
          *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL),
          0.80000001);
      *(_DWORD *)(a1 + 1164) = 6;
      if ( (unsigned int)dh_handshake(a1, 0LL, v12, v13, v14, v15) == -1 )
        goto LABEL_32;
      goto LABEL_22;
    case 6:
LABEL_22:
      result = *(unsigned int *)(a1 + 1172);
      if ( (_DWORD)result == 3 )
      {
        if ( *(_QWORD *)(a1 + 1032) && *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 32LL) )
          (*(void (__fastcall **)(_QWORD, float))(*(_QWORD *)(a1 + 1032) + 32LL))(
            *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL),
            1.0);
        *(_DWORD *)(a1 + 1096) = 1;
        result = a1;
        if ( (*(_DWORD *)(a1 + 1104) & 2) != 0 )
          *(_DWORD *)(a1 + 1164) = 8;
        else
          *(_DWORD *)(a1 + 1164) = 7;
      }
      break;
    case 9:
LABEL_32:
      ssh_socket_close(*(_QWORD *)(a1 + 1048));
      *(_DWORD *)(a1 + 1100) = 0;
      result = a1;
      *(_DWORD *)(a1 + 1164) = 9;
      break;
    default:
      result = ssh_set_error(
                 a1,
                 2,
                 "ssh_client_connection_callback",
                 "Invalid state %d",
                 *(unsigned int *)(a1 + 1164),
                 a6);
      break;
  }
  return result;
}
// 156B4: variable 'a5' is possibly undefined
// 156B4: variable 'a6' is possibly undefined
// 156C5: variable 'v7' is possibly undefined
// 156C5: variable 'v8' is possibly undefined
// 156C5: variable 'v9' is possibly undefined
// 156C5: variable 'v10' is possibly undefined
// 15700: variable 'v11' is possibly undefined
// 157FD: variable 'a3' is possibly undefined
// 157FD: variable 'a4' is possibly undefined
// 158A8: variable 'v12' is possibly undefined
// 158A8: variable 'v13' is possibly undefined
// 158A8: variable 'v14' is possibly undefined
// 158A8: variable 'v15' is possibly undefined

//----- (00000000000159D4) ----------------------------------------------------
_BOOL8 __fastcall ssh_connect_termination(__int64 a1)
{
  unsigned int v1; // eax

  v1 = *(_DWORD *)(a1 + 1164);
  return v1 == 7 || v1 >= 7 && v1 - 9 <= 1;
}

//----- (0000000000015A0E) ----------------------------------------------------
__int64 __fastcall ssh_connect(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v7; // eax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 type; // rbx
  const char *v11; // rax
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  unsigned int v18; // edi
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // r9
  int v24; // [rsp+18h] [rbp-18h]
  int v25; // [rsp+18h] [rbp-18h]
  unsigned int v26; // [rsp+1Ch] [rbp-14h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v7 = *(_DWORD *)(a1 + 1160);
  if ( v7 )
  {
    if ( v7 != 1 )
    {
      ssh_set_error(a1, 2, "ssh_connect", "Bad call during pending SSH call in ssh_connect", a5, a6);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 1100) = 0;
    *(_DWORD *)(a1 + 1080) = 1;
    if ( *(_DWORD *)(a1 + 1636) == -1 && !*(_QWORD *)(a1 + 1480) && !*(_QWORD *)(a1 + 1600) )
    {
      ssh_set_error(a1, 2, "ssh_connect", "Hostname required", a5, a6);
      return 0xFFFFFFFFLL;
    }
    if ( (int)ssh_options_apply(a1, a2, a3, a4, a5, a6) < 0 )
    {
      ssh_set_error(a1, 2, "ssh_connect", "Couldn't apply options", v8, v9);
      return 0xFFFFFFFFLL;
    }
    type = ssh_threads_get_type();
    v11 = ssh_copyright();
    ssh_log(2, "ssh_connect", "libssh %s, using threading %s", (__int64)v11, type, v12);
    *(_QWORD *)(a1 + 1368) = ssh_client_connection_callback;
    *(_DWORD *)(a1 + 1164) = 1;
    ssh_socket_set_callbacks(*(_QWORD *)(a1 + 1048), a1 + 1408);
    *(_QWORD *)(a1 + 1440) = socket_callback_connected;
    *(_QWORD *)(a1 + 1416) = callback_receive_banner;
    *(_QWORD *)(a1 + 1432) = ssh_socket_exception_callback;
    *(_QWORD *)(a1 + 1408) = a1;
    if ( *(_DWORD *)(a1 + 1636) == -1 )
    {
      if ( *(_QWORD *)(a1 + 1600) )
      {
        v24 = ssh_socket_connect_proxycommand(*(_QWORD *)(a1 + 1048), *(char **)(a1 + 1600));
      }
      else
      {
        if ( *(_DWORD *)(a1 + 1632) )
          v18 = *(_DWORD *)(a1 + 1632);
        else
          v18 = 22;
        v24 = ssh_socket_connect(
                *(_QWORD *)(a1 + 1048),
                *(const char **)(a1 + 1480),
                v18,
                *(const char **)(a1 + 1488),
                v13,
                v14);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 1164) = 2;
      ssh_socket_set_fd(*(_QWORD *)(a1 + 1048), *(_DWORD *)(a1 + 1636));
      v24 = 0;
    }
    if ( v24 == -1 )
      return 0xFFFFFFFFLL;
    if ( *(_QWORD *)(a1 + 1032) && *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 32LL) )
      (*(void (__fastcall **)(_QWORD, float))(*(_QWORD *)(a1 + 1032) + 32LL))(
        *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL),
        0.2);
    *(_DWORD *)(a1 + 1100) = 1;
    ssh_log(2, "ssh_connect", "Socket connecting, now waiting for the callbacks to work", v15, v16, v17);
  }
  *(_DWORD *)(a1 + 1160) = 1;
  if ( ssh_is_blocking(a1) )
  {
    v26 = 1000 * *(_QWORD *)(a1 + 1616) + *(_QWORD *)(a1 + 1624) / 0x3E8uLL;
    if ( !v26 )
      v26 = 10000;
    ssh_log(3, "ssh_connect", "Actual timeout : %d", v26, v19, v20);
    v25 = ssh_handle_packets_termination(a1, v26, (unsigned int (__fastcall *)(__int64))ssh_connect_termination, a1);
    if ( *(_DWORD *)(a1 + 1164) != 9 && (v25 == -1 || !ssh_connect_termination(a1)) )
    {
      ssh_set_error(a1, 2, "ssh_connect", "Timeout connecting to %s", *(_QWORD *)(a1 + 1480), v22);
      *(_DWORD *)(a1 + 1164) = 9;
    }
  }
  else if ( (unsigned int)ssh_handle_packets_termination(
                            a1,
                            0,
                            (unsigned int (__fastcall *)(__int64))ssh_connect_termination,
                            a1) == -1 )
  {
    *(_DWORD *)(a1 + 1164) = 9;
  }
  ssh_log(3, "ssh_connect", "current state : %d", *(unsigned int *)(a1 + 1164), v21, v22);
  if ( !ssh_is_blocking(a1) && !ssh_connect_termination(a1) )
    return 4294967294LL;
  *(_DWORD *)(a1 + 1160) = 0;
  if ( *(_DWORD *)(a1 + 1164) == 9 || *(_DWORD *)(a1 + 1164) == 10 )
    return 0xFFFFFFFFLL;
  else
    return 0LL;
}
// 15B1F: variable 'v8' is possibly undefined
// 15B1F: variable 'v9' is possibly undefined
// 15B59: variable 'v12' is possibly undefined
// 15CAC: variable 'v13' is possibly undefined
// 15CAC: variable 'v14' is possibly undefined
// 15D39: variable 'v15' is possibly undefined
// 15D39: variable 'v16' is possibly undefined
// 15D39: variable 'v17' is possibly undefined
// 15DC6: variable 'v19' is possibly undefined
// 15DC6: variable 'v20' is possibly undefined
// 15E41: variable 'v22' is possibly undefined
// 15EB0: variable 'v21' is possibly undefined
// 30B51: using guessed type __int64 ssh_threads_get_type(void);

//----- (0000000000015F1B) ----------------------------------------------------
void *__fastcall ssh_get_issue_banner(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 1112) )
    return ssh_string_to_char(*(uint32_t **)(a1 + 1112));
  else
    return 0LL;
}

//----- (0000000000015F5A) ----------------------------------------------------
__int64 __fastcall ssh_get_openssh_version(__int64 a1)
{
  if ( a1 )
    return *(unsigned int *)(a1 + 1084);
  else
    return 0LL;
}

//----- (0000000000015F7C) ----------------------------------------------------
void __fastcall ssh_disconnect(__int64 a1)
{
  __int64 iterator; // [rsp+20h] [rbp-10h]
  __int64 v2; // [rsp+28h] [rbp-8h]

  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 1048) && ssh_socket_is_open(*(_DWORD **)(a1 + 1048)) )
    {
      if ( (unsigned int)ssh_buffer_pack(
                           *(_QWORD *)(a1 + 1152),
                           "bdss",
                           4,
                           1LL,
                           11LL,
                           "Bye Bye",
                           &unk_5414E,
                           1332084403LL) )
      {
        ssh_set_error_oom(a1, "ssh_disconnect");
      }
      else
      {
        ssh_packet_send(a1);
        ssh_socket_close(*(_QWORD *)(a1 + 1048));
      }
    }
    *(_DWORD *)(a1 + 1092) = 0;
    *(_DWORD *)(a1 + 1088) = 0;
    *(_DWORD *)(a1 + 1100) = 0;
    if ( *(_QWORD *)(a1 + 1048) )
      ssh_socket_reset(*(_QWORD *)(a1 + 1048));
    *(_DWORD *)(a1 + 1636) = -1;
    *(_DWORD *)(a1 + 1164) = 10;
    while ( 1 )
    {
      iterator = ssh_list_get_iterator(*(_QWORD *)(a1 + 1248));
      if ( !iterator )
        break;
      ssh_channel_do_free(*(__int64 **)(iterator + 8));
      ssh_list_remove(*(_QWORD *)(a1 + 1248), (_QWORD *)iterator);
    }
    if ( *(_QWORD *)(a1 + 1232) )
    {
      crypto_free(*(_QWORD **)(a1 + 1232));
      *(_QWORD *)(a1 + 1232) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1240) )
    {
      crypto_free(*(_QWORD **)(a1 + 1240));
      *(_QWORD *)(a1 + 1240) = crypto_new();
      if ( !*(_QWORD *)(a1 + 1240) )
        ssh_set_error_oom(a1, "ssh_disconnect");
    }
    if ( *(_QWORD *)(a1 + 1128) )
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1128));
    if ( *(_QWORD *)(a1 + 1152) )
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
    if ( *(_QWORD *)(a1 + 1216) )
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1216));
    if ( *(_QWORD *)(a1 + 1224) )
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1224));
    *(_DWORD *)(a1 + 1328) = 0;
    if ( *(_QWORD *)(a1 + 1056) )
    {
      free(*(void **)(a1 + 1056));
      *(_QWORD *)(a1 + 1056) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1064) )
    {
      free(*(void **)(a1 + 1064));
      *(_QWORD *)(a1 + 1064) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1336) )
    {
      while ( 1 )
      {
        v2 = ssh_list_pop_head(*(_QWORD *)(a1 + 1336));
        if ( !v2 )
          break;
        ssh_message_free(v2);
      }
      ssh_list_free(*(_QWORD ***)(a1 + 1336));
      *(_QWORD *)(a1 + 1336) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1400) )
    {
      ssh_list_free(*(_QWORD ***)(a1 + 1400));
      *(_QWORD *)(a1 + 1400) = 0LL;
    }
  }
}

//----- (0000000000016317) ----------------------------------------------------
const char *ssh_copyright()
{
  return "0.8.1 (c) 2003-2018 Aris Adamantiadis, Andreas Schneider and libssh contributors. Distributed under the LGPL, p"
         "lease refer to COPYING file for information about your rights";
}

//----- (0000000000016324) ----------------------------------------------------
__int64 __fastcall ssh_client_curve25519_init(__int64 a1)
{
  __int64 v1; // r8
  __int64 v2; // r9

  if ( (unsigned int)ssh_get_random(*(_QWORD *)(a1 + 1240) + 64LL, 32) )
  {
    crypto_scalarmult_base(*(_QWORD *)(a1 + 1240) + 96LL, *(_QWORD *)(a1 + 1240) + 64LL);
    if ( (unsigned int)ssh_buffer_pack(
                         *(_QWORD *)(a1 + 1152),
                         "bdP",
                         4,
                         30LL,
                         32LL,
                         32LL,
                         *(_QWORD *)(a1 + 1240) + 96LL,
                         1332084403LL) )
    {
      ssh_set_error_oom(a1, "ssh_client_curve25519_init");
      return 0xFFFFFFFFLL;
    }
    else
    {
      return (unsigned int)ssh_packet_send(a1);
    }
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_client_curve25519_init", "PRNG error", v1, v2);
    return 0xFFFFFFFFLL;
  }
}
// 16379: variable 'v1' is possibly undefined
// 16379: variable 'v2' is possibly undefined

//----- (0000000000016436) ----------------------------------------------------
__int64 __fastcall ssh_curve25519_build_k(__int64 a1)
{
  char v2[40]; // [rsp+10h] [rbp-30h] BYREF
  unsigned __int64 v3; // [rsp+38h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 1076) )
    crypto_scalarmult((__int64)v2, *(_QWORD *)(a1 + 1240) + 64LL, *(_QWORD *)(a1 + 1240) + 96LL);
  else
    crypto_scalarmult((__int64)v2, *(_QWORD *)(a1 + 1240) + 64LL, *(_QWORD *)(a1 + 1240) + 128LL);
  gcry_mpi_scan(*(_QWORD *)(a1 + 1240) + 24LL, 5LL, v2, 32LL, 0LL);
  return 0LL;
}
// DEA0: using guessed type __int64 __fastcall gcry_mpi_scan(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000016504) ----------------------------------------------------
__int64 __fastcall ssh_client_curve25519_reply(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  unsigned int v8; // eax
  __int64 v9; // r9
  const void *v10; // rax
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  int pubkey_blob; // [rsp+14h] [rbp-1Ch]
  unsigned int v20; // [rsp+14h] [rbp-1Ch]
  void *v21; // [rsp+18h] [rbp-18h]
  uint32_t *ssh_string; // [rsp+20h] [rbp-10h]
  void *v23; // [rsp+28h] [rbp-8h]

  ssh_string = (uint32_t *)ssh_buffer_get_ssh_string(a2);
  if ( ssh_string )
  {
    pubkey_blob = ssh_dh_import_next_pubkey_blob(a1, ssh_string);
    ssh_string_free(ssh_string);
    if ( pubkey_blob )
    {
      ssh_set_error(a1, 2, "ssh_client_curve25519_reply", "Failed to import next public key", v4, v5);
    }
    else
    {
      v21 = ssh_buffer_get_ssh_string(a2);
      if ( v21 )
      {
        if ( ssh_string_len((uint32_t *)v21) == 32 )
        {
          v10 = (const void *)ssh_string_data((__int64)v21);
          memcpy((void *)(*(_QWORD *)(a1 + 1240) + 128LL), v10, 0x20uLL);
          ssh_string_free(v21);
          v23 = ssh_buffer_get_ssh_string(a2);
          if ( v23 )
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 160LL) = v23;
            if ( (int)ssh_curve25519_build_k(a1) >= 0 )
            {
              if ( (int)ssh_buffer_add_u8(*(_QWORD *)(a1 + 1152), 21) >= 0 )
              {
                v20 = ssh_packet_send(a1);
                ssh_log(2, "ssh_client_curve25519_reply", "SSH_MSG_NEWKEYS sent", v15, v16, v17);
                return v20;
              }
            }
            else
            {
              ssh_set_error(a1, 2, "ssh_client_curve25519_reply", "Cannot build k number", v13, v14);
            }
          }
          else
          {
            ssh_set_error(a1, 2, "ssh_client_curve25519_reply", "No signature in packet", v11, v12);
          }
        }
        else
        {
          v8 = ssh_string_len((uint32_t *)v21);
          ssh_set_error(
            a1,
            2,
            "ssh_client_curve25519_reply",
            "Incorrect size for server Curve25519 public key: %d",
            v8,
            v9);
          ssh_string_free(v21);
        }
      }
      else
      {
        ssh_set_error(a1, 2, "ssh_client_curve25519_reply", "No Q_S ECC point in packet", v6, v7);
      }
    }
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_client_curve25519_reply", "No public key in packet", v2, v3);
  }
  return 0xFFFFFFFFLL;
}
// 16562: variable 'v2' is possibly undefined
// 16562: variable 'v3' is possibly undefined
// 165B3: variable 'v4' is possibly undefined
// 165B3: variable 'v5' is possibly undefined
// 165F3: variable 'v6' is possibly undefined
// 165F3: variable 'v7' is possibly undefined
// 1663F: variable 'v9' is possibly undefined
// 166C5: variable 'v11' is possibly undefined
// 166C5: variable 'v12' is possibly undefined
// 1671C: variable 'v13' is possibly undefined
// 1671C: variable 'v14' is possibly undefined
// 16766: variable 'v15' is possibly undefined
// 16766: variable 'v16' is possibly undefined
// 16766: variable 'v17' is possibly undefined

//----- (0000000000016778) ----------------------------------------------------
__int64 __fastcall ssh_server_curve25519_init(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  unsigned int v5; // eax
  __int64 v6; // r9
  const void *v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  int v24; // [rsp+14h] [rbp-2Ch]
  int v25; // [rsp+14h] [rbp-2Ch]
  int v26; // [rsp+14h] [rbp-2Ch]
  unsigned int v27; // [rsp+14h] [rbp-2Ch]
  uint32_t *v28; // [rsp+18h] [rbp-28h] BYREF
  __int64 v29; // [rsp+20h] [rbp-20h] BYREF
  uint32_t *v30; // [rsp+28h] [rbp-18h]
  uint32_t *ssh_string; // [rsp+30h] [rbp-10h]
  uint32_t *v32; // [rsp+38h] [rbp-8h]

  v28 = 0LL;
  v30 = 0LL;
  ssh_string = (uint32_t *)ssh_buffer_get_ssh_string(a2);
  if ( !ssh_string )
  {
    ssh_set_error(a1, 2, "ssh_server_curve25519_init", "No Q_C ECC point in packet", v2, v3, a2);
    return 0xFFFFFFFFLL;
  }
  if ( ssh_string_len(ssh_string) != 32 )
  {
    v5 = ssh_string_len(ssh_string);
    ssh_set_error(
      a1,
      2,
      "ssh_server_curve25519_init",
      "Incorrect size for server Curve25519 public key: %d",
      v5,
      v6,
      a2);
    ssh_string_free(ssh_string);
    return 0xFFFFFFFFLL;
  }
  v7 = (const void *)ssh_string_data((__int64)ssh_string);
  memcpy((void *)(*(_QWORD *)(a1 + 1240) + 96LL), v7, 0x20uLL);
  ssh_string_free(ssh_string);
  if ( !(unsigned int)ssh_get_random(*(_QWORD *)(a1 + 1240) + 64LL, 32) )
  {
    ssh_set_error(a1, 2, "ssh_server_curve25519_init", "PRNG error", v8, v9, a2);
    return 0xFFFFFFFFLL;
  }
  crypto_scalarmult_base(*(_QWORD *)(a1 + 1240) + 128LL, *(_QWORD *)(a1 + 1240) + 64LL);
  if ( (int)ssh_buffer_add_u8(*(_QWORD *)(a1 + 1152), 31) >= 0 )
  {
    if ( (int)ssh_curve25519_build_k(a1) >= 0 )
    {
      if ( (unsigned int)ssh_get_key_params(a1, &v29) != -1 )
      {
        if ( (unsigned int)ssh_make_sessionid(a1) )
        {
          ssh_set_error(a1, 2, "ssh_server_curve25519_init", "Could not create a session id", v12, v13, a2);
        }
        else if ( (unsigned int)ssh_dh_get_next_server_publickey_blob(a1, &v28) )
        {
          ssh_set_error(a1, 2, "ssh_server_curve25519_init", "Could not export server public key", v14, v15, a2);
        }
        else
        {
          v24 = ssh_buffer_add_ssh_string(*(_QWORD *)(a1 + 1152), v28);
          ssh_string_free(v28);
          if ( v24 < 0 )
            goto LABEL_23;
          v32 = (uint32_t *)ssh_string_new(0x20uLL);
          if ( !v32 )
            goto LABEL_28;
          ssh_string_fill(v32, (const void *)(*(_QWORD *)(a1 + 1240) + 128LL), 0x20uLL);
          v25 = ssh_buffer_add_ssh_string(*(_QWORD *)(a1 + 1152), v32);
          ssh_string_free(v32);
          if ( v25 < 0 )
            goto LABEL_23;
          v30 = ssh_srv_pki_do_sign_sessionid(a1, v29);
          if ( !v30 )
          {
            ssh_set_error(a1, 2, "ssh_server_curve25519_init", "Could not sign the session id", v16, v17, a2);
            goto LABEL_28;
          }
          v26 = ssh_buffer_add_ssh_string(*(_QWORD *)(a1 + 1152), v30);
          ssh_string_free(v30);
          if ( v26 < 0 )
          {
LABEL_23:
            ssh_set_error_oom(a1, "ssh_server_curve25519_init");
            goto LABEL_28;
          }
          ssh_log(2, "ssh_server_curve25519_init", "SSH_MSG_KEX_ECDH_REPLY sent", v18, v19, v20, a2);
          if ( (unsigned int)ssh_packet_send(a1) == -1 )
            return 0xFFFFFFFFLL;
          if ( (int)ssh_buffer_add_u8(*(_QWORD *)(a1 + 1152), 21) >= 0 )
          {
            *(_DWORD *)(a1 + 1172) = 2;
            v27 = ssh_packet_send(a1);
            ssh_log(2, "ssh_server_curve25519_init", "SSH_MSG_NEWKEYS sent", v21, v22, v23);
            return v27;
          }
        }
      }
    }
    else
    {
      ssh_set_error(a1, 2, "ssh_server_curve25519_init", "Cannot build k number", v10, v11, a2);
    }
  }
  else
  {
    ssh_set_error_oom(a1, "ssh_server_curve25519_init");
  }
LABEL_28:
  ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
  return 0xFFFFFFFFLL;
}
// 167CE: variable 'v2' is possibly undefined
// 167CE: variable 'v3' is possibly undefined
// 1681F: variable 'v6' is possibly undefined
// 168BD: variable 'v8' is possibly undefined
// 168BD: variable 'v9' is possibly undefined
// 16962: variable 'v10' is possibly undefined
// 16962: variable 'v11' is possibly undefined
// 169C0: variable 'v12' is possibly undefined
// 169C0: variable 'v13' is possibly undefined
// 16A05: variable 'v14' is possibly undefined
// 16A05: variable 'v15' is possibly undefined
// 16B19: variable 'v16' is possibly undefined
// 16B19: variable 'v17' is possibly undefined
// 16B82: variable 'v18' is possibly undefined
// 16B82: variable 'v19' is possibly undefined
// 16B82: variable 'v20' is possibly undefined
// 16BF9: variable 'v21' is possibly undefined
// 16BF9: variable 'v22' is possibly undefined
// 16BF9: variable 'v23' is possibly undefined

//----- (0000000000016C24) ----------------------------------------------------
__int64 __fastcall select_p(int a1)
{
  if ( a1 == 2 )
    return p_group14;
  else
    return p_group1;
}
// 281A00: using guessed type __int64 p_group1;
// 281A08: using guessed type __int64 p_group14;

//----- (0000000000016C43) ----------------------------------------------------
__int64 ssh_dh_init()
{
  if ( dh_crypto_initialized )
    return 0LL;
  g = gcry_mpi_new(0LL);
  if ( !g )
    return 0xFFFFFFFFLL;
  gcry_mpi_set_ui(g, g_int);
  gcry_mpi_scan(&p_group1, 5LL, &p_group1_value, 128LL, 0LL);
  if ( p_group1 )
  {
    gcry_mpi_scan(&p_group14, 5LL, &p_group14_value, 256LL, 0LL);
    if ( p_group14 )
    {
      dh_crypto_initialized = 1;
      return 0LL;
    }
    else
    {
      if ( g )
      {
        gcry_mpi_release(g);
        g = 0LL;
      }
      if ( p_group1 )
      {
        gcry_mpi_release(p_group1);
        p_group1 = 0LL;
      }
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if ( g )
    {
      gcry_mpi_release(g);
      g = 0LL;
    }
    return 0xFFFFFFFFLL;
  }
}
// DBD0: using guessed type __int64 __fastcall gcry_mpi_new(_QWORD);
// DD00: using guessed type __int64 __fastcall gcry_mpi_set_ui(_QWORD, _QWORD);
// DE30: using guessed type __int64 __fastcall gcry_mpi_release(_QWORD);
// DEA0: using guessed type __int64 __fastcall gcry_mpi_scan(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 16C43: using guessed type __int64 ssh_dh_init();
// 2808E0: using guessed type __int64 g_int;
// 2819F8: using guessed type __int64 g;
// 281A00: using guessed type __int64 p_group1;
// 281A08: using guessed type __int64 p_group14;
// 281A10: using guessed type int dh_crypto_initialized;

//----- (0000000000016D8D) ----------------------------------------------------
__int64 ssh_dh_finalize()
{
  __int64 result; // rax

  result = (unsigned int)dh_crypto_initialized;
  if ( dh_crypto_initialized )
  {
    if ( g )
    {
      gcry_mpi_release(g);
      g = 0LL;
    }
    if ( p_group1 )
    {
      gcry_mpi_release(p_group1);
      p_group1 = 0LL;
    }
    result = p_group14;
    if ( p_group14 )
    {
      result = gcry_mpi_release(p_group14);
      p_group14 = 0LL;
    }
    dh_crypto_initialized = 0;
  }
  return result;
}
// DE30: using guessed type __int64 __fastcall gcry_mpi_release(_QWORD);
// 16D8D: using guessed type __int64 ssh_dh_finalize();
// 2819F8: using guessed type __int64 g;
// 281A00: using guessed type __int64 p_group1;
// 281A08: using guessed type __int64 p_group14;
// 281A10: using guessed type int dh_crypto_initialized;

//----- (0000000000016E1C) ----------------------------------------------------
__int64 __fastcall ssh_dh_generate_x(__int64 a1)
{
  __int64 v1; // rbx
  unsigned int v3; // [rsp+1Ch] [rbp-14h]

  if ( *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) == 1 )
    v3 = 1023;
  else
    v3 = 2047;
  v1 = *(_QWORD *)(a1 + 1240);
  *(_QWORD *)(v1 + 16) = gcry_mpi_new(0LL);
  if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 16LL) )
    return 0xFFFFFFFFLL;
  gcry_mpi_randomize(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 16LL), v3, 1LL);
  gcry_mpi_set_bit(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 16LL), v3 - 1);
  gcry_mpi_set_bit(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 16LL), 0LL);
  return 0LL;
}
// D8F0: using guessed type __int64 __fastcall gcry_mpi_randomize(_QWORD, _QWORD, _QWORD);
// DAD0: using guessed type __int64 __fastcall gcry_mpi_set_bit(_QWORD, _QWORD);
// DBD0: using guessed type __int64 __fastcall gcry_mpi_new(_QWORD);

//----- (0000000000016EED) ----------------------------------------------------
__int64 __fastcall ssh_dh_generate_y(__int64 a1)
{
  __int64 v1; // rbx
  unsigned int v3; // [rsp+1Ch] [rbp-14h]

  if ( *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) == 1 )
    v3 = 1023;
  else
    v3 = 2047;
  v1 = *(_QWORD *)(a1 + 1240);
  *(_QWORD *)(v1 + 32) = gcry_mpi_new(0LL);
  if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 32LL) )
    return 0xFFFFFFFFLL;
  gcry_mpi_randomize(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 32LL), v3, 1LL);
  gcry_mpi_set_bit(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 32LL), v3 - 1);
  gcry_mpi_set_bit(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 32LL), 0LL);
  return 0LL;
}
// D8F0: using guessed type __int64 __fastcall gcry_mpi_randomize(_QWORD, _QWORD, _QWORD);
// DAD0: using guessed type __int64 __fastcall gcry_mpi_set_bit(_QWORD, _QWORD);
// DBD0: using guessed type __int64 __fastcall gcry_mpi_new(_QWORD);

//----- (0000000000016FBE) ----------------------------------------------------
__int64 __fastcall ssh_dh_generate_e(__int64 a1)
{
  _QWORD *v1; // rbx
  __int64 v3; // rax

  v1 = *(_QWORD **)(a1 + 1240);
  *v1 = gcry_mpi_new(0LL);
  if ( !**(_QWORD **)(a1 + 1240) )
    return 0xFFFFFFFFLL;
  v3 = select_p(*(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL));
  gcry_mpi_powm(**(_QWORD **)(a1 + 1240), g, *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 16LL), v3);
  return 0LL;
}
// D990: using guessed type __int64 __fastcall gcry_mpi_powm(_QWORD, _QWORD, _QWORD, _QWORD);
// DBD0: using guessed type __int64 __fastcall gcry_mpi_new(_QWORD);
// 2819F8: using guessed type __int64 g;

//----- (0000000000017050) ----------------------------------------------------
__int64 __fastcall ssh_dh_generate_f(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax

  v1 = *(_QWORD *)(a1 + 1240);
  *(_QWORD *)(v1 + 8) = gcry_mpi_new(0LL);
  if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8LL) )
    return 0xFFFFFFFFLL;
  v3 = select_p(*(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL));
  gcry_mpi_powm(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8LL), g, *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 32LL), v3);
  return 0LL;
}
// D990: using guessed type __int64 __fastcall gcry_mpi_powm(_QWORD, _QWORD, _QWORD, _QWORD);
// DBD0: using guessed type __int64 __fastcall gcry_mpi_new(_QWORD);
// 2819F8: using guessed type __int64 g;

//----- (00000000000170E5) ----------------------------------------------------
_BYTE *__fastcall ssh_dh_get_e(__int64 a1)
{
  return ssh_make_bignum_string(**(_QWORD **)(a1 + 1240));
}

//----- (0000000000017109) ----------------------------------------------------
_BYTE *__fastcall ssh_dh_get_f(__int64 a1)
{
  return ssh_make_bignum_string(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8LL));
}

//----- (000000000001712E) ----------------------------------------------------
__int64 __fastcall ssh_dh_import_pubkey_blob(__int64 a1, uint32_t *a2)
{
  return ssh_pki_import_pubkey_blob(a2, (_QWORD *)(*(_QWORD *)(a1 + 1232) + 328LL));
}

//----- (0000000000017161) ----------------------------------------------------
__int64 __fastcall ssh_dh_import_next_pubkey_blob(__int64 a1, uint32_t *a2)
{
  return ssh_pki_import_pubkey_blob(a2, (_QWORD *)(*(_QWORD *)(a1 + 1240) + 328LL));
}

//----- (0000000000017194) ----------------------------------------------------
__int64 __fastcall ssh_dh_import_f(__int64 a1, uint32_t *a2)
{
  __int64 v2; // rbx

  v2 = *(_QWORD *)(a1 + 1240);
  *(_QWORD *)(v2 + 8) = ssh_make_string_bn(a2);
  if ( *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8LL) )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (00000000000171E7) ----------------------------------------------------
__int64 __fastcall ssh_dh_import_e(__int64 a1, uint32_t *a2)
{
  __int64 *v2; // rbx

  v2 = *(__int64 **)(a1 + 1240);
  *v2 = ssh_make_string_bn(a2);
  if ( **(_QWORD **)(a1 + 1240) )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000017238) ----------------------------------------------------
__int64 __fastcall ssh_dh_build_k(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  __int64 v4; // rax

  v1 = *(_QWORD *)(a1 + 1240);
  *(_QWORD *)(v1 + 24) = gcry_mpi_new(0LL);
  if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 24LL) )
    return 0xFFFFFFFFLL;
  if ( *(_DWORD *)(a1 + 1080) )
  {
    v3 = select_p(*(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL));
    gcry_mpi_powm(
      *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 24LL),
      *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8LL),
      *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 16LL),
      v3);
  }
  else
  {
    v4 = select_p(*(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL));
    gcry_mpi_powm(
      *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 24LL),
      **(_QWORD **)(a1 + 1240),
      *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 32LL),
      v4);
  }
  return 0LL;
}
// D990: using guessed type __int64 __fastcall gcry_mpi_powm(_QWORD, _QWORD, _QWORD, _QWORD);
// DBD0: using guessed type __int64 __fastcall gcry_mpi_new(_QWORD);

//----- (0000000000017337) ----------------------------------------------------
__int64 __fastcall ssh_client_dh_init(__int64 a1)
{
  uint32_t *e; // [rsp+18h] [rbp-8h]

  e = 0LL;
  if ( (int)ssh_dh_generate_x(a1) < 0
    || (int)ssh_dh_generate_e(a1) < 0
    || (e = (uint32_t *)ssh_dh_get_e(a1)) == 0LL
    || (unsigned int)ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "bS", 2, 30LL, e, 1332084403LL) )
  {
    if ( e )
    {
      ssh_string_burn(e);
      ssh_string_free(e);
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    ssh_string_burn(e);
    ssh_string_free(e);
    return (unsigned int)ssh_packet_send(a1);
  }
}

//----- (000000000001742D) ----------------------------------------------------
__int64 __fastcall ssh_client_dh_reply(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  int pubkey_blob; // [rsp+14h] [rbp-1Ch]
  int v17; // [rsp+14h] [rbp-1Ch]
  unsigned int v18; // [rsp+14h] [rbp-1Ch]
  uint32_t *ssh_string; // [rsp+18h] [rbp-18h]
  void *v20; // [rsp+20h] [rbp-10h]
  uint32_t *v21; // [rsp+28h] [rbp-8h]

  ssh_string = (uint32_t *)ssh_buffer_get_ssh_string(a2);
  if ( ssh_string )
  {
    pubkey_blob = ssh_dh_import_next_pubkey_blob(a1, ssh_string);
    ssh_string_free(ssh_string);
    if ( !pubkey_blob )
    {
      v21 = (uint32_t *)ssh_buffer_get_ssh_string(a2);
      if ( v21 )
      {
        v17 = ssh_dh_import_f(a1, v21);
        ssh_string_burn(v21);
        ssh_string_free(v21);
        if ( v17 >= 0 )
        {
          v20 = ssh_buffer_get_ssh_string(a2);
          if ( v20 )
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 160LL) = v20;
            if ( (int)ssh_dh_build_k(a1) >= 0 )
            {
              if ( (int)ssh_buffer_add_u8(*(_QWORD *)(a1 + 1152), 21) >= 0 )
              {
                v18 = ssh_packet_send(a1);
                ssh_log(2, "ssh_client_dh_reply", "SSH_MSG_NEWKEYS sent", v12, v13, v14);
                return v18;
              }
            }
            else
            {
              ssh_set_error(a1, 2, "ssh_client_dh_reply", "Cannot build k number", v10, v11);
            }
          }
          else
          {
            ssh_set_error(a1, 2, "ssh_client_dh_reply", "No signature in packet", v8, v9);
          }
        }
        else
        {
          ssh_set_error(a1, 2, "ssh_client_dh_reply", "Cannot import f number", v6, v7);
        }
      }
      else
      {
        ssh_set_error(a1, 2, "ssh_client_dh_reply", "No F number in packet", v4, v5);
      }
    }
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_client_dh_reply", "No public key in packet", v2, v3);
  }
  return 0xFFFFFFFFLL;
}
// 17483: variable 'v2' is possibly undefined
// 17483: variable 'v3' is possibly undefined
// 174EF: variable 'v4' is possibly undefined
// 174EF: variable 'v5' is possibly undefined
// 1754C: variable 'v6' is possibly undefined
// 1754C: variable 'v7' is possibly undefined
// 1758C: variable 'v8' is possibly undefined
// 1758C: variable 'v9' is possibly undefined
// 175E3: variable 'v10' is possibly undefined
// 175E3: variable 'v11' is possibly undefined
// 1762D: variable 'v12' is possibly undefined
// 1762D: variable 'v13' is possibly undefined
// 1762D: variable 'v14' is possibly undefined

//----- (0000000000017642) ----------------------------------------------------
__int64 __fastcall ssh_make_sessionid(__int64 a1)
{
  uint32_t *v2; // rbx
  __int64 v3; // r14
  __int64 len; // r13
  __int64 v5; // r12
  unsigned int v6; // r15d
  unsigned int v7; // eax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rbx
  __int64 v12; // rbx
  int v13; // r12d
  __int64 v14; // rax
  __int64 v15; // rbx
  __int64 v16; // rbx
  int v17; // r12d
  __int64 v18; // rax
  __int64 v19; // rbx
  __int64 v20; // rbx
  int v21; // r12d
  __int64 v22; // rax
  __int64 v23; // rbx
  __int64 v24; // rbx
  int v25; // r12d
  __int64 v26; // rax
  __int64 v27; // rbx
  __int64 v28; // [rsp+0h] [rbp-70h]
  int next_server_publickey_blob; // [rsp+14h] [rbp-5Ch]
  uint32_t *v30; // [rsp+18h] [rbp-58h] BYREF
  __int64 v31; // [rsp+20h] [rbp-50h]
  __int64 v32; // [rsp+28h] [rbp-48h]
  void *v33; // [rsp+30h] [rbp-40h]
  void *v34; // [rsp+38h] [rbp-38h]

  v33 = 0LL;
  v31 = 0LL;
  v32 = 0LL;
  v30 = 0LL;
  v34 = ssh_buffer_new();
  if ( !v34 )
    return 0xFFFFFFFFLL;
  next_server_publickey_blob = ssh_buffer_pack(
                                 (__int64)v34,
                                 "ss",
                                 2,
                                 *(_QWORD *)(a1 + 1064),
                                 *(_QWORD *)(a1 + 1056),
                                 1332084403LL);
  if ( next_server_publickey_blob != -1 )
  {
    if ( *(_DWORD *)(a1 + 1080) )
    {
      v31 = *(_QWORD *)(a1 + 1216);
      v32 = *(_QWORD *)(a1 + 1224);
    }
    else
    {
      v31 = *(_QWORD *)(a1 + 1224);
      v32 = *(_QWORD *)(a1 + 1216);
    }
    next_server_publickey_blob = ssh_buffer_add_u8(v31, 0);
    if ( next_server_publickey_blob >= 0 )
    {
      next_server_publickey_blob = ssh_buffer_add_u32(v31, 0);
      if ( next_server_publickey_blob >= 0 )
      {
        if ( !*(_DWORD *)(a1 + 1080)
          || (next_server_publickey_blob = ssh_buffer_add_u8(v32, 0), next_server_publickey_blob >= 0)
          && (next_server_publickey_blob = ssh_buffer_add_u32(v32, 0), next_server_publickey_blob >= 0) )
        {
          next_server_publickey_blob = ssh_dh_get_next_server_publickey_blob(a1, &v30);
          if ( !next_server_publickey_blob )
          {
            v2 = v30;
            v3 = ssh_buffer_get(v31);
            len = (unsigned int)ssh_buffer_get_len(v31);
            v5 = (unsigned int)ssh_buffer_get_len(v31);
            v28 = ssh_buffer_get(v32);
            v6 = ssh_buffer_get_len(v32);
            v7 = ssh_buffer_get_len(v32);
            next_server_publickey_blob = ssh_buffer_pack(
                                           (__int64)v34,
                                           "dPdPS",
                                           7,
                                           v7,
                                           v6,
                                           v28,
                                           v5,
                                           len,
                                           v3,
                                           v2,
                                           1332084403LL);
            ssh_string_free(v30);
            if ( !next_server_publickey_blob )
            {
              switch ( *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) )
              {
                case 1:
                case 2:
                  next_server_publickey_blob = ssh_buffer_pack(
                                                 (__int64)v34,
                                                 "BB",
                                                 2,
                                                 **(_QWORD **)(a1 + 1240),
                                                 *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8LL),
                                                 1332084403LL,
                                                 v28);
                  if ( next_server_publickey_blob )
                    goto LABEL_46;
                  break;
                case 3:
                case 4:
                case 5:
                  if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 48LL) || !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 56LL) )
                  {
                    ssh_log(1, "ssh_make_sessionid", "ECDH parameted missing", v8, v9, v10, v28);
                    goto LABEL_46;
                  }
                  next_server_publickey_blob = ssh_buffer_pack(
                                                 (__int64)v34,
                                                 "SS",
                                                 2,
                                                 *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 48LL),
                                                 *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 56LL),
                                                 1332084403LL);
                  if ( next_server_publickey_blob )
                    goto LABEL_46;
                  break;
                case 7:
                case 6:
                  next_server_publickey_blob = ssh_buffer_pack(
                                                 (__int64)v34,
                                                 "dPdP",
                                                 6,
                                                 32LL,
                                                 32LL,
                                                 *(_QWORD *)(a1 + 1240) + 96LL,
                                                 32LL,
                                                 32LL,
                                                 *(_QWORD *)(a1 + 1240) + 128LL,
                                                 1332084403LL);
                  if ( next_server_publickey_blob )
                    goto LABEL_46;
                  break;
              }
              next_server_publickey_blob = ssh_buffer_pack(
                                             (__int64)v34,
                                             "B",
                                             1,
                                             *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 24LL),
                                             1332084403LL);
              if ( !next_server_publickey_blob )
              {
                switch ( *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) )
                {
                  case 1:
                  case 2:
                    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 168LL) = 20LL;
                    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 644LL) = 1;
                    v11 = *(_QWORD *)(a1 + 1240);
                    *(_QWORD *)(v11 + 184) = malloc(*(_QWORD *)(v11 + 168));
                    if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 184LL) )
                      goto LABEL_43;
                    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 184LL);
                    v13 = ssh_buffer_get_len((__int64)v34);
                    v14 = ssh_buffer_get((__int64)v34);
                    sha1(v14, v13, v12);
                    break;
                  case 3:
                  case 6:
                  case 7:
                    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 168LL) = 32LL;
                    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 644LL) = 2;
                    v15 = *(_QWORD *)(a1 + 1240);
                    *(_QWORD *)(v15 + 184) = malloc(*(_QWORD *)(v15 + 168));
                    if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 184LL) )
                      goto LABEL_43;
                    v16 = *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 184LL);
                    v17 = ssh_buffer_get_len((__int64)v34);
                    v18 = ssh_buffer_get((__int64)v34);
                    sha256(v18, v17, v16);
                    break;
                  case 4:
                    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 168LL) = 48LL;
                    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 644LL) = 3;
                    v19 = *(_QWORD *)(a1 + 1240);
                    *(_QWORD *)(v19 + 184) = malloc(*(_QWORD *)(v19 + 168));
                    if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 184LL) )
                      goto LABEL_43;
                    v20 = *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 184LL);
                    v21 = ssh_buffer_get_len((__int64)v34);
                    v22 = ssh_buffer_get((__int64)v34);
                    sha384(v22, v21, v20);
                    break;
                  case 5:
                    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 168LL) = 64LL;
                    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 644LL) = 4;
                    v23 = *(_QWORD *)(a1 + 1240);
                    *(_QWORD *)(v23 + 184) = malloc(*(_QWORD *)(v23 + 168));
                    if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 184LL) )
                      goto LABEL_43;
                    v24 = *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 184LL);
                    v25 = ssh_buffer_get_len((__int64)v34);
                    v26 = ssh_buffer_get((__int64)v34);
                    sha512(v26, v25, v24);
                    break;
                  default:
                    break;
                }
                if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 176LL) )
                {
                  v27 = *(_QWORD *)(a1 + 1240);
                  *(_QWORD *)(v27 + 176) = malloc(*(_QWORD *)(v27 + 168));
                  if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 176LL) )
                  {
LABEL_43:
                    ssh_set_error_oom(a1, "ssh_make_sessionid");
                    goto LABEL_46;
                  }
                  memcpy(
                    *(void **)(*(_QWORD *)(a1 + 1240) + 176LL),
                    *(const void **)(*(_QWORD *)(a1 + 1240) + 184LL),
                    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 168LL));
                }
                next_server_publickey_blob = 0;
              }
            }
          }
        }
      }
    }
  }
LABEL_46:
  ssh_buffer_free((__int64)v34);
  ssh_buffer_free(v32);
  ssh_buffer_free(v31);
  *(_QWORD *)(a1 + 1216) = 0LL;
  *(_QWORD *)(a1 + 1224) = 0LL;
  ssh_string_free(v33);
  return (unsigned int)next_server_publickey_blob;
}
// 17997: variable 'v8' is possibly undefined
// 17997: variable 'v9' is possibly undefined
// 17997: variable 'v10' is possibly undefined

//----- (0000000000017F56) ----------------------------------------------------
__int64 __fastcall ssh_hashbufout_add_cookie(__int64 a1)
{
  *(_QWORD *)(a1 + 1224) = ssh_buffer_new();
  if ( !*(_QWORD *)(a1 + 1224) )
    return 0xFFFFFFFFLL;
  if ( (int)ssh_buffer_allocate_size(*(_QWORD *)(a1 + 1224), 0x11u) < 0
    || (int)ssh_buffer_add_u8(*(_QWORD *)(a1 + 1224), 20) < 0 )
  {
    goto LABEL_10;
  }
  if ( *(_DWORD *)(a1 + 1076) )
  {
    if ( (int)ssh_buffer_add_data(*(_QWORD *)(a1 + 1224), (const void *)(*(_QWORD *)(a1 + 1240) + 368LL), 0x10u) < 0 )
      goto LABEL_10;
  }
  else if ( (int)ssh_buffer_add_data(*(_QWORD *)(a1 + 1224), (const void *)(*(_QWORD *)(a1 + 1240) + 464LL), 0x10u) < 0 )
  {
LABEL_10:
    ssh_buffer_reinit(*(_QWORD *)(a1 + 1224));
    return 0xFFFFFFFFLL;
  }
  return 0LL;
}

//----- (00000000000180B1) ----------------------------------------------------
__int64 __fastcall ssh_hashbufin_add_cookie(__int64 a1, const void *a2)
{
  *(_QWORD *)(a1 + 1216) = ssh_buffer_new();
  if ( !*(_QWORD *)(a1 + 1216) )
    return 0xFFFFFFFFLL;
  if ( (int)ssh_buffer_allocate_size(*(_QWORD *)(a1 + 1216), 0x25u) >= 0
    && (int)ssh_buffer_add_u8(*(_QWORD *)(a1 + 1216), 20) >= 0
    && (int)ssh_buffer_add_data(*(_QWORD *)(a1 + 1216), a2, 0x10u) >= 0 )
  {
    return 0LL;
  }
  ssh_buffer_reinit(*(_QWORD *)(a1 + 1216));
  return 0xFFFFFFFFLL;
}

//----- (00000000000181A3) ----------------------------------------------------
__int64 __fastcall generate_one_key(uint32_t *a1, __int64 a2, void **a3, char a4, unsigned __int64 a5)
{
  __int64 v6; // rax
  __int64 v7; // rax
  char v9[4]; // [rsp+14h] [rbp-3Ch] BYREF
  void **v10; // [rsp+18h] [rbp-38h]
  __int64 v11; // [rsp+20h] [rbp-30h]
  uint32_t *v12; // [rsp+28h] [rbp-28h]
  unsigned __int64 v13; // [rsp+38h] [rbp-18h]
  unsigned int *v14; // [rsp+40h] [rbp-10h]
  char *v15; // [rsp+48h] [rbp-8h]

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v9[0] = a4;
  v13 = *(_QWORD *)(a2 + 168);
  v14 = ssh_mac_ctx_init(*(_DWORD *)(a2 + 644));
  if ( !v14 )
    return 0xFFFFFFFFLL;
  v6 = ssh_string_len(v12);
  ssh_mac_update((__int64)v14, (__int64)v12, v6 + 4);
  ssh_mac_update((__int64)v14, *(_QWORD *)(v11 + 184), *(_QWORD *)(v11 + 168));
  ssh_mac_update((__int64)v14, (__int64)v9, 1LL);
  ssh_mac_update((__int64)v14, *(_QWORD *)(v11 + 176), *(_QWORD *)(v11 + 168));
  ssh_mac_final(*v10, v14);
  while ( a5 > v13 )
  {
    v15 = (char *)realloc(*v10, v13 + *(_QWORD *)(v11 + 168));
    if ( !v15 )
      return 0xFFFFFFFFLL;
    *v10 = v15;
    v14 = ssh_mac_ctx_init(*(_DWORD *)(v11 + 644));
    if ( !v14 )
      return 0xFFFFFFFFLL;
    v7 = ssh_string_len(v12);
    ssh_mac_update((__int64)v14, (__int64)v12, v7 + 4);
    ssh_mac_update((__int64)v14, *(_QWORD *)(v11 + 184), *(_QWORD *)(v11 + 168));
    ssh_mac_update((__int64)v14, (__int64)v15, v13);
    ssh_mac_final(&v15[v13], v14);
    v13 += *(_QWORD *)(v11 + 168);
  }
  return 0LL;
}
// 181A3: using guessed type char var_3C[4];

//----- (000000000001839C) ----------------------------------------------------
__int64 __fastcall ssh_generate_session_keys(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  int one_key; // [rsp+1Ch] [rbp-14h]
  uint32_t *bignum_string; // [rsp+20h] [rbp-10h]
  __int64 v8; // [rsp+28h] [rbp-8h]

  v8 = *(_QWORD *)(a1 + 1240);
  one_key = -1;
  bignum_string = (uint32_t *)ssh_make_bignum_string(*(_QWORD *)(v8 + 24));
  if ( !bignum_string
    || (*(_QWORD *)(v8 + 192) = malloc(*(_QWORD *)(v8 + 168)),
        *(_QWORD *)(v8 + 200) = malloc(*(_QWORD *)(v8 + 168)),
        *(_QWORD *)(v8 + 216) = malloc(*(_QWORD *)(v8 + 168)),
        *(_QWORD *)(v8 + 208) = malloc(*(_QWORD *)(v8 + 168)),
        *(_QWORD *)(v8 + 224) = malloc(*(_QWORD *)(v8 + 168)),
        *(_QWORD *)(v8 + 232) = malloc(*(_QWORD *)(v8 + 168)),
        !*(_QWORD *)(v8 + 192))
    || !*(_QWORD *)(v8 + 200)
    || !*(_QWORD *)(v8 + 216)
    || !*(_QWORD *)(v8 + 208)
    || !*(_QWORD *)(v8 + 224)
    || !*(_QWORD *)(v8 + 232) )
  {
    ssh_set_error_oom(a1, "ssh_generate_session_keys");
    goto LABEL_29;
  }
  if ( *(_DWORD *)(a1 + 1080) )
  {
    one_key = generate_one_key(bignum_string, v8, (void **)(v8 + 192), 65, *(_QWORD *)(v8 + 168));
    if ( one_key < 0 )
      goto LABEL_29;
    one_key = generate_one_key(bignum_string, v8, (void **)(v8 + 200), 66, *(_QWORD *)(v8 + 168));
    if ( one_key < 0 )
      goto LABEL_29;
LABEL_16:
    if ( *(_DWORD *)(a1 + 1080) )
    {
      one_key = generate_one_key(
                  bignum_string,
                  v8,
                  (void **)(v8 + 216),
                  67,
                  *(_DWORD *)(*(_QWORD *)(v8 + 312) + 48LL) >> 3);
      if ( one_key < 0 )
        goto LABEL_29;
      one_key = generate_one_key(
                  bignum_string,
                  v8,
                  (void **)(v8 + 208),
                  68,
                  *(_DWORD *)(*(_QWORD *)(v8 + 304) + 48LL) >> 3);
      if ( one_key < 0 )
        goto LABEL_29;
    }
    else
    {
      one_key = generate_one_key(
                  bignum_string,
                  v8,
                  (void **)(v8 + 208),
                  67,
                  *(_DWORD *)(*(_QWORD *)(v8 + 304) + 48LL) >> 3);
      if ( one_key < 0 )
        goto LABEL_29;
      one_key = generate_one_key(
                  bignum_string,
                  v8,
                  (void **)(v8 + 216),
                  68,
                  *(_DWORD *)(*(_QWORD *)(v8 + 312) + 48LL) >> 3);
      if ( one_key < 0 )
        goto LABEL_29;
    }
    if ( *(_DWORD *)(a1 + 1080) )
    {
      v1 = hmac_digest_len(*(_DWORD *)(v8 + 324));
      one_key = generate_one_key(bignum_string, v8, (void **)(v8 + 224), 69, v1);
      if ( one_key < 0 )
        goto LABEL_29;
      v2 = hmac_digest_len(*(_DWORD *)(v8 + 320));
      one_key = generate_one_key(bignum_string, v8, (void **)(v8 + 232), 70, v2);
      if ( one_key < 0 )
        goto LABEL_29;
    }
    else
    {
      v3 = hmac_digest_len(*(_DWORD *)(v8 + 320));
      one_key = generate_one_key(bignum_string, v8, (void **)(v8 + 232), 69, v3);
      if ( one_key < 0 )
        goto LABEL_29;
      v4 = hmac_digest_len(*(_DWORD *)(v8 + 324));
      one_key = generate_one_key(bignum_string, v8, (void **)(v8 + 224), 70, v4);
      if ( one_key < 0 )
        goto LABEL_29;
    }
    one_key = 0;
    goto LABEL_29;
  }
  one_key = generate_one_key(bignum_string, v8, (void **)(v8 + 200), 65, *(_QWORD *)(v8 + 168));
  if ( one_key >= 0 )
  {
    one_key = generate_one_key(bignum_string, v8, (void **)(v8 + 192), 66, *(_QWORD *)(v8 + 168));
    if ( one_key >= 0 )
      goto LABEL_16;
  }
LABEL_29:
  ssh_string_free(bignum_string);
  return (unsigned int)one_key;
}

//----- (00000000000188A7) ----------------------------------------------------
__int64 __fastcall ssh_get_pubkey_hash(__int64 a1, void **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // rbx
  __int64 v8; // rax
  int v9; // [rsp+1Ch] [rbp-34h]
  void *v10; // [rsp+20h] [rbp-30h] BYREF
  uint32_t *v11; // [rsp+28h] [rbp-28h] BYREF
  void *ptr; // [rsp+30h] [rbp-20h]
  __int64 v13; // [rsp+38h] [rbp-18h]

  v10 = 0LL;
  v11 = 0LL;
  if ( !a1 || !a2 )
    return 0xFFFFFFFFLL;
  *a2 = 0LL;
  if ( *(_QWORD *)(a1 + 1232) && *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 328LL) )
  {
    ptr = calloc(0x10uLL, 1uLL);
    if ( ptr )
    {
      v13 = md5_init();
      if ( v13 )
      {
        if ( (unsigned int)ssh_get_server_publickey(a1, &v10) )
        {
          md5_final(ptr, v13);
          if ( ptr )
          {
            free(ptr);
            ptr = 0LL;
          }
          return 0xFFFFFFFFLL;
        }
        else
        {
          v9 = ssh_pki_export_pubkey_blob((__int64)v10, &v11);
          ssh_key_free(v10);
          if ( v9 )
          {
            md5_final(ptr, v13);
            if ( ptr )
            {
              free(ptr);
              ptr = 0LL;
            }
            return 0xFFFFFFFFLL;
          }
          else
          {
            v7 = ssh_string_len(v11);
            v8 = ssh_string_data((__int64)v11);
            md5_update(v13, v8, v7);
            ssh_string_free(v11);
            md5_final(ptr, v13);
            *a2 = ptr;
            return 16LL;
          }
        }
      }
      else
      {
        free(ptr);
        ptr = 0LL;
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_get_pubkey_hash", "No current cryptographic context", a5, a6, a2);
    return 0xFFFFFFFFLL;
  }
}
// 18979: conditional instruction was optimized away because %ptr.8!=0
// 38701: using guessed type __int64 md5_init(void);

//----- (0000000000018AB0) ----------------------------------------------------
void **__fastcall ssh_clean_pubkey_hash(void **a1)
{
  void **result; // rax

  if ( *a1 )
  {
    free(*a1);
    *a1 = 0LL;
  }
  result = a1;
  *a1 = 0LL;
  return result;
}

//----- (0000000000018AF0) ----------------------------------------------------
__int64 __fastcall ssh_get_server_publickey(__int64 a1, _QWORD *a2)
{
  _QWORD *v3; // [rsp+18h] [rbp-8h]

  if ( !a1 || !*(_QWORD *)(a1 + 1232) || !*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 328LL) )
    return 0xFFFFFFFFLL;
  v3 = ssh_key_dup(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 328LL));
  if ( !v3 )
    return 0xFFFFFFFFLL;
  *a2 = v3;
  return 0LL;
}

//----- (0000000000018B7B) ----------------------------------------------------
__int64 __fastcall ssh_dh_get_current_server_publickey(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 328LL);
}

//----- (0000000000018B97) ----------------------------------------------------
__int64 __fastcall ssh_dh_get_current_server_publickey_blob(__int64 a1, uint32_t **a2)
{
  __int64 current_server_publickey; // [rsp+18h] [rbp-8h]

  current_server_publickey = ssh_dh_get_current_server_publickey(a1);
  return ssh_pki_export_pubkey_blob(current_server_publickey, a2);
}

//----- (0000000000018BCC) ----------------------------------------------------
__int64 __fastcall ssh_dh_get_next_server_publickey(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 328LL);
}

//----- (0000000000018BE8) ----------------------------------------------------
__int64 __fastcall ssh_dh_get_next_server_publickey_blob(__int64 a1, uint32_t **a2)
{
  __int64 next_server_publickey; // [rsp+18h] [rbp-8h]

  next_server_publickey = ssh_dh_get_next_server_publickey(a1);
  return ssh_pki_export_pubkey_blob(next_server_publickey, a2);
}

//----- (0000000000018C1D) ----------------------------------------------------
__int64 __fastcall ssh_get_publickey(__int64 a1, _QWORD *a2)
{
  return ssh_get_server_publickey(a1, a2);
}

//----- (0000000000018C42) ----------------------------------------------------
__int64 __fastcall ssh_get_publickey_hash(__int64 a1, int a2, void **a3, _QWORD *a4)
{
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  int v11; // [rsp+2Ch] [rbp-34h]
  unsigned int v12; // [rsp+2Ch] [rbp-34h]
  uint32_t *v13; // [rsp+30h] [rbp-30h] BYREF
  void *ptr; // [rsp+38h] [rbp-28h]
  __int64 v15; // [rsp+40h] [rbp-20h]
  __int64 v16; // [rsp+48h] [rbp-18h]

  v11 = ssh_pki_export_pubkey_blob(a1, &v13);
  if ( v11 < 0 )
    return (unsigned int)v11;
  if ( !a2 )
  {
    ptr = malloc(0x14uLL);
    if ( !ptr )
    {
      v12 = -1;
      goto LABEL_16;
    }
    v15 = sha1_init();
    if ( v15 )
    {
      v5 = ssh_string_len(v13);
      v6 = ssh_string_data((__int64)v13);
      sha1_update(v15, v6, v5);
      sha1_final(ptr, v15);
      *a4 = 20LL;
LABEL_15:
      *a3 = ptr;
      v12 = 0;
      goto LABEL_16;
    }
LABEL_9:
    free(ptr);
    v12 = -1;
    goto LABEL_16;
  }
  if ( a2 == 1 )
  {
    ptr = malloc(0x10uLL);
    if ( !ptr )
    {
      v12 = -1;
      goto LABEL_16;
    }
    v16 = md5_init();
    if ( v16 )
    {
      v7 = ssh_string_len(v13);
      v8 = ssh_string_data((__int64)v13);
      md5_update(v16, v8, v7);
      md5_final(ptr, v16);
      *a4 = 16LL;
      goto LABEL_15;
    }
    goto LABEL_9;
  }
  v12 = -1;
LABEL_16:
  ssh_string_free(v13);
  return v12;
}
// 381DB: using guessed type __int64 sha1_init(void);
// 38701: using guessed type __int64 md5_init(void);

//----- (0000000000018DF6) ----------------------------------------------------
_BYTE *__fastcall ssh_get_hexa(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 i; // [rsp+18h] [rbp-38h]
  __int64 v4; // [rsp+20h] [rbp-30h]
  _BYTE *v5; // [rsp+28h] [rbp-28h]
  char v6[24]; // [rsp+30h] [rbp-20h] BYREF
  unsigned __int64 v7; // [rsp+48h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  strcpy(v6, "0123456789abcdef");
  v4 = 3 * a2;
  if ( a2 > 0x55555554 )
    return 0LL;
  v5 = malloc(v4 + 1);
  if ( !v5 )
    return 0LL;
  for ( i = 0LL; i < a2; ++i )
  {
    v5[3 * i] = v6[(*(_BYTE *)(a1 + i) >> 4) & 0xF];
    v5[3 * i + 1] = v6[*(_BYTE *)(a1 + i) & 0xF];
    v5[3 * i + 2] = 58;
  }
  v5[v4 - 1] = 0;
  return v5;
}

//----- (0000000000018F4F) ----------------------------------------------------
void __fastcall ssh_print_hexa(const char *a1, __int64 a2, unsigned __int64 a3)
{
  char *ptr; // [rsp+28h] [rbp-8h]

  ptr = ssh_get_hexa(a2, a3);
  if ( ptr )
  {
    fprintf(stderr, "%s: %s\n", a1, ptr);
    free(ptr);
  }
}

//----- (0000000000018FB8) ----------------------------------------------------
unsigned __int64 ssh_set_error(__int64 a1, int a2, const char *a3, const char *a4, __int64 a5, __int64 a6, ...)
{
  unsigned __int64 result; // rax
  gcc_va_list arg; // [rsp+28h] [rbp-C8h] BYREF
  __int64 v9; // [rsp+60h] [rbp-90h]
  __int64 v10; // [rsp+68h] [rbp-88h]

  va_start(arg, a6);
  v9 = a5;
  v10 = a6;
  arg[0].gp_offset = 32;
  vsnprintf((char *)(a1 + 4), 0x400uLL, a4, arg);
  *(_DWORD *)a1 = a2;
  result = ssh_get_log_level();
  if ( (int)result > 0 )
    return ssh_log_function(1u, a3, (const char *)(a1 + 4));
  return result;
}
// 1CC6E: using guessed type __int64 ssh_get_log_level(void);

//----- (00000000000190AE) ----------------------------------------------------
__int64 __fastcall ssh_set_error_oom(__int64 a1, const char *a2)
{
  __int64 result; // rax

  snprintf((char *)(a1 + 4), 0x400uLL, "%s: Out of memory", a2);
  result = a1;
  *(_DWORD *)a1 = 2;
  return result;
}

//----- (00000000000190F8) ----------------------------------------------------
unsigned __int64 __fastcall ssh_set_error_invalid(
        __int64 a1,
        const char *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  return ssh_set_error(a1, 2, a2, "Invalid argument in %s", (__int64)a2, a6, a2, a1);
}

//----- (0000000000019133) ----------------------------------------------------
__int64 __fastcall ssh_get_error(__int64 a1)
{
  return a1 + 4;
}

//----- (000000000001914D) ----------------------------------------------------
__int64 __fastcall ssh_get_error_code(unsigned int *a1)
{
  return *a1;
}

//----- (0000000000019165) ----------------------------------------------------
__int64 __fastcall ssh_init(int a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-4h]

  if ( !a1 )
    ssh_mutex_lock(&ssh_init_mutex);
  if ( ++ssh_initialized <= 1 )
  {
    v2 = ssh_threads_init();
    if ( !v2 )
    {
      v2 = ssh_crypto_init();
      if ( !v2 )
      {
        v2 = ssh_dh_init();
        if ( !v2 )
          v2 = ssh_socket_init();
      }
    }
  }
  else
  {
    v2 = ssh_init_ret;
  }
  ssh_init_ret = v2;
  if ( !a1 )
    ssh_mutex_unlock(&ssh_init_mutex);
  return v2;
}
// 16C43: using guessed type __int64 ssh_dh_init(void);
// 2ED27: using guessed type __int64 ssh_socket_init(void);
// 30AAE: using guessed type __int64 ssh_threads_init(void);
// 39337: using guessed type __int64 ssh_crypto_init(void);
// 281A20: using guessed type pthread_mutex_t ssh_init_mutex;
// 281A48: using guessed type int ssh_initialized;
// 281A4C: using guessed type int ssh_init_ret;

//----- (000000000001920D) ----------------------------------------------------
__int64 libssh_constructor()
{
  __int64 result; // rax

  result = ssh_init(1);
  if ( (int)result < 0 )
    return fwrite("Error in auto_init()\n", 1uLL, 0x15uLL, stderr);
  return result;
}
// 1920D: using guessed type __int64 libssh_constructor();

//----- (000000000001924F) ----------------------------------------------------
__int64 ssh_init()
{
  return ssh_init(0);
}
// 1924F: using guessed type __int64 ssh_init();

//----- (000000000001925F) ----------------------------------------------------
__int64 __fastcall ssh_finalize(int a1)
{
  if ( a1 )
    goto LABEL_6;
  ssh_mutex_lock(&ssh_init_mutex);
  if ( ssh_initialized > 1 )
  {
    --ssh_initialized;
    goto LABEL_7;
  }
  if ( ssh_initialized != 1 || ssh_init_ret >= 0 )
  {
LABEL_6:
    ssh_dh_finalize();
    ssh_crypto_finalize();
    ssh_socket_cleanup();
    ssh_threads_finalize();
    ssh_initialized = 0;
  }
LABEL_7:
  if ( !a1 )
    ssh_mutex_unlock(&ssh_init_mutex);
  return 0LL;
}
// 16D8D: using guessed type __int64 ssh_dh_finalize(void);
// 39453: using guessed type __int64 ssh_crypto_finalize(void);
// 281A20: using guessed type pthread_mutex_t ssh_init_mutex;
// 281A48: using guessed type int ssh_initialized;
// 281A4C: using guessed type int ssh_init_ret;

//----- (00000000000192E7) ----------------------------------------------------
__int64 libssh_destructor()
{
  __int64 result; // rax

  result = ssh_finalize(1);
  if ( (int)result < 0 )
    return fwrite("Error in libssh_destructor()\n", 1uLL, 0x1DuLL, stderr);
  return result;
}
// 192E7: using guessed type __int64 libssh_destructor();

//----- (0000000000019328) ----------------------------------------------------
__int64 ssh_finalize()
{
  return ssh_finalize(0);
}
// 19328: using guessed type __int64 ssh_finalize();

//----- (0000000000019338) ----------------------------------------------------
_QWORD *__fastcall tokenize(const char *a1)
{
  int v2; // [rsp+10h] [rbp-20h]
  int j; // [rsp+14h] [rbp-1Ch]
  char *i; // [rsp+18h] [rbp-18h]
  char *v5; // [rsp+18h] [rbp-18h]
  char *ptr; // [rsp+20h] [rbp-10h]
  _QWORD *v7; // [rsp+28h] [rbp-8h]

  v2 = 1;
  ptr = strdup(a1);
  if ( !ptr )
    return 0LL;
  for ( i = ptr; *i; ++i )
  {
    if ( *i == 44 )
    {
      ++v2;
      *i = 0;
    }
  }
  v7 = calloc(v2 + 1, 8uLL);
  if ( v7 )
  {
    v5 = ptr;
    for ( j = 0; j < v2; ++j )
    {
      v7[j] = v5;
      while ( *v5 )
        ++v5;
      ++v5;
    }
    v7[j] = 0LL;
    return v7;
  }
  else
  {
    free(ptr);
    return 0LL;
  }
}
// 193C8: conditional instruction was optimized away because %ptr.8!=0

//----- (0000000000019455) ----------------------------------------------------
_QWORD *__fastcall ssh_space_tokenize(const char *a1)
{
  char *v2; // rax
  int v3; // [rsp+10h] [rbp-20h]
  int j; // [rsp+14h] [rbp-1Ch]
  char *i; // [rsp+18h] [rbp-18h]
  char *v6; // [rsp+18h] [rbp-18h]
  char *ptr; // [rsp+20h] [rbp-10h]
  _QWORD *v8; // [rsp+28h] [rbp-8h]

  v3 = 1;
  ptr = strdup(a1);
  if ( !ptr )
    return 0LL;
  for ( i = ptr; *i == 32; ++i )
    ;
  while ( *i )
  {
    if ( *i == 32 )
    {
      ++v3;
      *i = 0;
      while ( i[1] == 32 )
      {
        v2 = i++;
        *v2 = 0;
      }
    }
    ++i;
  }
  v8 = calloc(v3 + 1, 8uLL);
  if ( v8 )
  {
    v6 = ptr;
    for ( j = 0; j < v3; ++j )
    {
      v8[j] = v6;
      if ( v3 - 1 != j )
      {
        while ( *v6 )
          ++v6;
        while ( !v6[1] )
          ++v6;
        ++v6;
      }
    }
    v8[j] = 0LL;
    return v8;
  }
  else
  {
    free(ptr);
    return 0LL;
  }
}
// 19517: conditional instruction was optimized away because %ptr.8!=0

//----- (00000000000195C8) ----------------------------------------------------
char *__fastcall ssh_kex_get_supported_method(unsigned int a1)
{
  if ( a1 <= 9 )
    return supported_methods[a1];
  else
    return 0LL;
}
// 280960: using guessed type char *supported_methods[8];

//----- (00000000000195F4) ----------------------------------------------------
char *__fastcall ssh_kex_get_description(unsigned int a1)
{
  if ( a1 <= 9 )
    return ssh_kex_descriptions[a1];
  else
    return 0LL;
}
// 2809C0: using guessed type char *ssh_kex_descriptions[10];

//----- (0000000000019620) ----------------------------------------------------
char *__fastcall ssh_find_matching(const char *a1, const char *a2)
{
  int i; // [rsp+10h] [rbp-20h]
  int v4; // [rsp+14h] [rbp-1Ch]
  void **ptr; // [rsp+18h] [rbp-18h]
  void **v6; // [rsp+20h] [rbp-10h]
  char *v7; // [rsp+28h] [rbp-8h]

  if ( !a1 || !a2 )
    return 0LL;
  ptr = (void **)tokenize(a1);
  if ( !ptr )
    return 0LL;
  v6 = (void **)tokenize(a2);
  if ( v6 )
  {
    v4 = 0;
LABEL_21:
    if ( v6[v4] )
    {
      for ( i = 0; ; ++i )
      {
        if ( !ptr[i] )
        {
          ++v4;
          goto LABEL_21;
        }
        if ( !strcmp((const char *)ptr[i], (const char *)v6[v4]) )
          break;
      }
      v7 = strdup((const char *)ptr[i]);
      if ( *ptr )
      {
        free(*ptr);
        *ptr = 0LL;
      }
      if ( *v6 )
      {
        free(*v6);
        *v6 = 0LL;
      }
      free(ptr);
      free(v6);
      return v7;
    }
    else
    {
      if ( *ptr )
      {
        free(*ptr);
        *ptr = 0LL;
      }
      if ( *v6 )
      {
        free(*v6);
        *v6 = 0LL;
      }
      free(ptr);
      free(v6);
      return 0LL;
    }
  }
  else
  {
    if ( *ptr )
    {
      free(*ptr);
      *ptr = 0LL;
    }
    free(ptr);
    return 0LL;
  }
}
// 196AB: conditional instruction was optimized away because %ptr.8!=0
// 19798: conditional instruction was optimized away because %ptr.8!=0
// 197B3: conditional instruction was optimized away because %var_10.8!=0
// 1986B: conditional instruction was optimized away because %ptr.8!=0
// 19886: conditional instruction was optimized away because %var_10.8!=0

//----- (00000000000198A3) ----------------------------------------------------
_BYTE *__fastcall ssh_find_all_matching(const char *a1, const char *a2)
{
  size_t v3; // rbx
  int v4; // eax
  int j; // [rsp+10h] [rbp-40h]
  int i; // [rsp+14h] [rbp-3Ch]
  int v7; // [rsp+18h] [rbp-38h]
  unsigned int n; // [rsp+24h] [rbp-2Ch]
  _BYTE *n_4; // [rsp+28h] [rbp-28h]
  void **ptr; // [rsp+30h] [rbp-20h]
  void **v11; // [rsp+38h] [rbp-18h]

  v7 = 0;
  if ( !a1 || !a2 )
    return 0LL;
  v3 = strlen(a1);
  if ( v3 <= strlen(a2) )
    v4 = strlen(a2);
  else
    v4 = strlen(a1);
  n_4 = malloc((unsigned int)(v4 + 1));
  if ( !n_4 )
    return 0LL;
  *n_4 = 0;
  ptr = (void **)tokenize(a1);
  if ( ptr )
  {
    v11 = (void **)tokenize(a2);
    if ( v11 )
    {
      for ( i = 0; v11[i]; ++i )
      {
        for ( j = 0; ptr[j]; ++j )
        {
          if ( !strcmp((const char *)ptr[j], (const char *)v11[i]) )
          {
            if ( v7 )
              n_4[v7++] = 44;
            n = strlen((const char *)ptr[j]);
            memcpy(&n_4[v7], ptr[j], n);
            v7 += n;
            n_4[v7] = 0;
          }
        }
      }
      if ( !*n_4 )
      {
        free(n_4);
        n_4 = 0LL;
      }
      if ( *ptr )
      {
        free(*ptr);
        *ptr = 0LL;
      }
      if ( *v11 )
      {
        free(*v11);
        *v11 = 0LL;
      }
      free(ptr);
      free(v11);
      return n_4;
    }
    else
    {
      free(n_4);
      if ( *ptr )
      {
        free(*ptr);
        *ptr = 0LL;
      }
      free(ptr);
      return 0LL;
    }
  }
  else
  {
    free(n_4);
    return 0LL;
  }
}
// 19958: conditional instruction was optimized away because %n@4.8!=0
// 19994: conditional instruction was optimized away because %n@4.8!=0
// 199D5: conditional instruction was optimized away because %ptr.8!=0
// 19B22: conditional instruction was optimized away because %n@4.8!=0
// 19B91: conditional instruction was optimized away because %ptr.8!=0
// 19BAC: conditional instruction was optimized away because %var_18.8!=0

//----- (0000000000019BCD) ----------------------------------------------------
_BOOL8 __fastcall cmp_first_kex_algo(const char *a1, const char *a2)
{
  _BOOL4 v3; // [rsp+1Ch] [rbp-14h]
  const char **ptr; // [rsp+20h] [rbp-10h]
  const char **v5; // [rsp+28h] [rbp-8h]

  v3 = 1;
  if ( a1 )
  {
    if ( a2 )
    {
      v5 = (const char **)tokenize(a1);
      if ( v5 )
      {
        if ( *v5 )
        {
          ptr = (const char **)tokenize(a2);
          if ( ptr )
          {
            v3 = strcmp(*v5, *ptr) != 0;
            if ( *ptr )
            {
              free((void *)*ptr);
              *ptr = 0LL;
            }
            free(ptr);
          }
        }
        if ( *v5 )
        {
          free((void *)*v5);
          *v5 = 0LL;
        }
        free(v5);
      }
    }
  }
  return v3;
}
// 19C97: conditional instruction was optimized away because %ptr.8!=0
// 19CDE: conditional instruction was optimized away because %var_8.8!=0

//----- (0000000000019CFC) ----------------------------------------------------
__int64 __fastcall ssh_packet_kexinit(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  _BOOL4 v13; // edx
  __int64 v15; // rdx
  char v18; // [rsp+27h] [rbp-69h] BYREF
  int i; // [rsp+28h] [rbp-68h]
  int v20; // [rsp+2Ch] [rbp-64h]
  int data; // [rsp+30h] [rbp-60h]
  int v22; // [rsp+34h] [rbp-5Ch]
  uint32_t *ssh_string; // [rsp+38h] [rbp-58h]
  __int64 s[10]; // [rsp+40h] [rbp-50h] BYREF

  v20 = *(_DWORD *)(a1 + 1076);
  ssh_string = 0LL;
  data = -1;
  v18 = 0;
  v22 = 0;
  memset(s, 0, sizeof(s));
  if ( *(_DWORD *)(a1 + 1164) == 8 )
  {
    ssh_log(1, "ssh_packet_kexinit", "Other side initiating key re-exchange", v4, v5, v6, a4);
  }
  else if ( *(_DWORD *)(a1 + 1164) != 4 )
  {
    ssh_set_error(a1, 2, "ssh_packet_kexinit", "SSH_KEXINIT received in wrong state", v5, v6, a4);
    goto LABEL_39;
  }
  if ( v20 )
  {
    data = ssh_buffer_get_data(a3, (void *)(*(_QWORD *)(a1 + 1240) + 464LL), 0x10u);
    if ( data != 16 )
    {
LABEL_7:
      ssh_set_error(a1, 2, "ssh_packet_kexinit", "ssh_packet_kexinit: no cookie in packet", v7, v8);
      goto LABEL_39;
    }
    data = ssh_hashbufin_add_cookie(a1, (const void *)(*(_QWORD *)(a1 + 1240) + 464LL));
    if ( data < 0 )
      goto LABEL_9;
  }
  else
  {
    data = ssh_buffer_get_data(a3, (void *)(*(_QWORD *)(a1 + 1240) + 368LL), 0x10u);
    if ( data != 16 )
      goto LABEL_7;
    data = ssh_hashbufin_add_cookie(a1, (const void *)(*(_QWORD *)(a1 + 1240) + 368LL));
    if ( data < 0 )
    {
LABEL_9:
      ssh_set_error(a1, 2, "ssh_packet_kexinit", "ssh_packet_kexinit: adding cookie failed", v9, v10);
      goto LABEL_39;
    }
  }
  for ( i = 0; i <= 9; ++i )
  {
    ssh_string = (uint32_t *)ssh_buffer_get_ssh_string(a3);
    if ( !ssh_string )
      goto LABEL_39;
    data = ssh_buffer_add_ssh_string(*(_QWORD *)(a1 + 1216), ssh_string);
    if ( data < 0 )
    {
      ssh_set_error(a1, 2, "ssh_packet_kexinit", "Error adding string in hash buffer", v11, v12);
      goto LABEL_39;
    }
    s[i] = (__int64)ssh_string_to_char(ssh_string);
    if ( !s[i] )
    {
      ssh_set_error_oom(a1, "ssh_packet_kexinit");
      goto LABEL_39;
    }
    ssh_string_free(ssh_string);
    ssh_string = 0LL;
  }
  if ( v20 )
  {
    for ( i = 0; i <= 9; ++i )
      *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8 * (i + 60LL)) = s[i];
  }
  else
  {
    for ( i = 0; i <= 9; ++i )
      *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8 * (i + 48LL)) = s[i];
  }
  if ( !v20 )
  {
LABEL_38:
    *(_DWORD *)(a1 + 1164) = 5;
    *(_DWORD *)(a1 + 1172) = 0;
    (*(void (__fastcall **)(__int64))(a1 + 1368))(a1);
    return 1LL;
  }
  data = ssh_buffer_get_u8(a3, &v18);
  if ( data == 1 )
  {
    data = ssh_buffer_add_u8(*(_QWORD *)(a1 + 1216), v18);
    if ( data >= 0 )
    {
      data = ssh_buffer_add_u32(*(_QWORD *)(a1 + 1216), v22);
      if ( data >= 0 )
      {
        if ( v18 )
        {
          v13 = cmp_first_kex_algo(
                  *(const char **)(*(_QWORD *)(a1 + 1240) + 480LL),
                  *(const char **)(*(_QWORD *)(a1 + 1240) + 384LL))
             || cmp_first_kex_algo(
                  *(const char **)(*(_QWORD *)(a1 + 1240) + 488LL),
                  *(const char **)(*(_QWORD *)(a1 + 1240) + 392LL));
          *(_DWORD *)(a1 + 1208) = v13;
        }
        goto LABEL_38;
      }
    }
  }
LABEL_39:
  ssh_string_free(ssh_string);
  for ( i = 0; i <= 9; ++i )
  {
    if ( v20 )
      v15 = i + 60LL;
    else
      v15 = i + 48LL;
    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8 * v15) = 0LL;
    if ( s[i] )
    {
      free((void *)s[i]);
      s[i] = 0LL;
    }
  }
  *(_DWORD *)(a1 + 1164) = 9;
  return 1LL;
}
// 19D82: variable 'v4' is possibly undefined
// 19D82: variable 'v5' is possibly undefined
// 19D82: variable 'v6' is possibly undefined
// 19E1C: variable 'v7' is possibly undefined
// 19E1C: variable 'v8' is possibly undefined
// 19E73: variable 'v9' is possibly undefined
// 19E73: variable 'v10' is possibly undefined
// 19F97: variable 'v11' is possibly undefined
// 19F97: variable 'v12' is possibly undefined
// 19CFC: using guessed type __int64 s[10];

//----- (000000000001A261) ----------------------------------------------------
unsigned __int64 __fastcall ssh_list_kex(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i <= 9; ++i )
  {
    result = *(_QWORD *)(a1 + 8 * (i + 2LL));
    if ( result )
      result = ssh_log(
                 4,
                 "ssh_list_kex",
                 "%s: %s",
                 (__int64)ssh_kex_descriptions[i],
                 *(_QWORD *)(a1 + 8 * (i + 2LL)),
                 a6);
  }
  return result;
}
// 1A2DC: variable 'a6' is possibly undefined
// 2809C0: using guessed type char *ssh_kex_descriptions[10];

//----- (000000000001A2F1) ----------------------------------------------------
char *__fastcall ssh_client_select_hostkeys(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  size_t v7; // rax
  size_t v8; // rax
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  int v12; // [rsp+10h] [rbp-C0h]
  int i; // [rsp+14h] [rbp-BCh]
  _QWORD *j; // [rsp+20h] [rbp-B0h]
  _QWORD **algorithms; // [rsp+28h] [rbp-A8h]
  char *s2; // [rsp+38h] [rbp-98h]
  char s[136]; // [rsp+40h] [rbp-90h] BYREF
  unsigned __int64 v18; // [rsp+C8h] [rbp-8h]

  v18 = __readfsqword(0x28u);
  memset(s, 0, 0x80uLL);
  v12 = 0;
  algorithms = ssh_known_hosts_get_algorithms(a1, a2, (__int64)s, 0LL, a5, a6);
  if ( !algorithms )
    return 0LL;
  if ( ssh_list_count((__int64)algorithms) )
  {
    for ( i = 0; preferred_hostkeys_8797[i]; ++i )
    {
      for ( j = (_QWORD *)ssh_list_get_iterator((__int64)algorithms);
            j;
            j = (_QWORD *)ssh_list_get_iterator((__int64)algorithms) )
      {
        s2 = (char *)j[1];
        if ( !strcmp(preferred_hostkeys_8797[i], s2) && (unsigned int)ssh_verify_existing_algo(1u, s2) )
        {
          if ( v12 )
          {
            v7 = strlen(s);
            strncat(s, ",", 127 - v7);
          }
          v8 = strlen(s);
          strncat(s, s2, 127 - v8);
          v12 = 1;
        }
        ssh_list_remove((__int64)algorithms, j);
      }
    }
    ssh_list_free(algorithms);
    if ( s[0] )
    {
      ssh_log(3, "ssh_client_select_hostkeys", "Changing host key method to \"%s\"", (__int64)s, v10, v11);
      return strdup(s);
    }
    else
    {
      ssh_log(
        3,
        "ssh_client_select_hostkeys",
        "No supported kex method for existing key in known_hosts file",
        v9,
        v10,
        v11);
      return 0LL;
    }
  }
  else
  {
    ssh_list_free(algorithms);
    return 0LL;
  }
}
// 1A558: variable 'v9' is possibly undefined
// 1A558: variable 'v10' is possibly undefined
// 1A558: variable 'v11' is possibly undefined
// 280A20: using guessed type char *preferred_hostkeys_8797[6];

//----- (000000000001A5B0) ----------------------------------------------------
__int64 __fastcall ssh_set_client_kex(__int64 a1)
{
  __int64 v1; // r8
  __int64 v2; // r9
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  int i; // [rsp+18h] [rbp-18h]
  char *s; // [rsp+20h] [rbp-10h]
  __int64 v10; // [rsp+28h] [rbp-8h]

  v10 = *(_QWORD *)(a1 + 1240) + 464LL;
  if ( (unsigned int)ssh_get_random(v10, 16) )
  {
    memset((void *)(v10 + 16), 0, 0x50uLL);
    if ( !*(_QWORD *)(a1 + 1528) )
      *(_QWORD *)(a1 + 1528) = ssh_client_select_hostkeys(a1, 0LL, v4, v5, v6, v7);
    for ( i = 0; i <= 9; ++i )
    {
      s = *(char **)(a1 + 8 * (i + 188LL) + 16);
      if ( !s )
        s = default_methods[i];
      *(_QWORD *)(v10 + 8 * (i + 2LL)) = strdup(s);
      if ( !*(_QWORD *)(v10 + 8 * (i + 2LL)) )
      {
        ssh_set_error_oom(a1, "ssh_set_client_kex");
        return 0xFFFFFFFFLL;
      }
    }
    return 0LL;
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_set_client_kex", "PRNG error", v1, v2);
    return 0xFFFFFFFFLL;
  }
}
// 1A60F: variable 'v1' is possibly undefined
// 1A60F: variable 'v2' is possibly undefined
// 1A64F: variable 'v4' is possibly undefined
// 1A64F: variable 'v5' is possibly undefined
// 1A64F: variable 'v6' is possibly undefined
// 1A64F: variable 'v7' is possibly undefined
// 280900: using guessed type char *default_methods[8];

//----- (000000000001A712) ----------------------------------------------------
__int64 __fastcall ssh_kex_select_methods(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v3; // rbx
  int i; // [rsp+1Ch] [rbp-24h]
  __int64 v5; // [rsp+20h] [rbp-20h]
  __int64 v6; // [rsp+28h] [rbp-18h]

  v5 = *(_QWORD *)(a1 + 1240) + 368LL;
  v6 = *(_QWORD *)(a1 + 1240) + 464LL;
  for ( i = 0; i <= 9; ++i )
  {
    v1 = *(_QWORD *)(a1 + 1240);
    *(_QWORD *)(v1 + 8 * (i + 70LL)) = ssh_find_matching(
                                         *(const char **)(v5 + 8 * (i + 2LL)),
                                         *(const char **)(v6 + 8 * (i + 2LL)));
    if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8 * (i + 70LL)) && i <= 7 )
    {
      ssh_set_error(
        a1,
        2,
        "ssh_kex_select_methods",
        "kex error : no match for method %s: server [%s], client [%s]",
        (__int64)ssh_kex_descriptions[i],
        *(_QWORD *)(v5 + 8 * (i + 2LL)),
        *(_QWORD *)(v6 + 8 * (i + 2LL)));
      return 0xFFFFFFFFLL;
    }
    if ( i > 7 && !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8 * (i + 70LL)) )
    {
      v3 = *(_QWORD *)(a1 + 1240);
      *(_QWORD *)(v3 + 8 * (i + 70LL)) = strdup(s);
    }
  }
  if ( !strcmp(*(const char **)(*(_QWORD *)(a1 + 1240) + 560LL), "diffie-hellman-group1-sha1") )
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) = 1;
  }
  else if ( !strcmp(*(const char **)(*(_QWORD *)(a1 + 1240) + 560LL), "diffie-hellman-group14-sha1") )
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) = 2;
  }
  else if ( !strcmp(*(const char **)(*(_QWORD *)(a1 + 1240) + 560LL), "ecdh-sha2-nistp256") )
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) = 3;
  }
  else if ( !strcmp(*(const char **)(*(_QWORD *)(a1 + 1240) + 560LL), "ecdh-sha2-nistp384") )
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) = 4;
  }
  else if ( !strcmp(*(const char **)(*(_QWORD *)(a1 + 1240) + 560LL), "ecdh-sha2-nistp521") )
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) = 5;
  }
  else if ( !strcmp(*(const char **)(*(_QWORD *)(a1 + 1240) + 560LL), "curve25519-sha256@libssh.org") )
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) = 6;
  }
  else if ( !strcmp(*(const char **)(*(_QWORD *)(a1 + 1240) + 560LL), "curve25519-sha256") )
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) = 7;
  }
  ssh_log(
    2,
    "ssh_kex_select_methods",
    "Negotiated %s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 560LL),
    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 568LL),
    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 576LL),
    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 584LL),
    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 592LL),
    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 600LL),
    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 608LL),
    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 616LL),
    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 624LL),
    *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 632LL));
  return 0LL;
}
// 2809C0: using guessed type char *ssh_kex_descriptions[10];

//----- (000000000001AB3A) ----------------------------------------------------
__int64 __fastcall ssh_send_kex(__int64 *a1, int a2)
{
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  int i; // [rsp+18h] [rbp-18h]
  _BYTE v9[12]; // [rsp+1Ch] [rbp-14h]
  __int64 v10; // [rsp+28h] [rbp-8h]

  if ( a2 )
    v2 = a1[155] + 368;
  else
    v2 = a1[155] + 464;
  v10 = v2;
  *(_DWORD *)&v9[8] = 0;
  *(_QWORD *)v9 = (unsigned int)ssh_buffer_pack(a1[144], "bP", 3, 20LL, 16LL, v2, 1332084403LL);
  if ( *(_DWORD *)v9 || (int)ssh_hashbufout_add_cookie((__int64)a1) < 0 )
    goto LABEL_16;
  ssh_list_kex(v10, (__int64)"bP", v3, v4, v5, v6);
  for ( i = 0; i <= 9; ++i )
  {
    *(_QWORD *)&v9[4] = ssh_string_from_char(*(const char **)(v10 + 8 * (i + 2LL)));
    if ( !*(_QWORD *)&v9[4]
      || (int)ssh_buffer_add_ssh_string(a1[153], *(uint32_t **)&v9[4]) < 0
      || (int)ssh_buffer_add_ssh_string(a1[144], *(uint32_t **)&v9[4]) < 0 )
    {
      goto LABEL_16;
    }
    ssh_string_free(*(void **)&v9[4]);
    *(_QWORD *)&v9[4] = 0LL;
  }
  if ( (unsigned int)ssh_buffer_pack(a1[144], "bd", 2, 0LL, 0LL, 1332084403LL) )
  {
LABEL_16:
    ssh_buffer_reinit(a1[144]);
    ssh_buffer_reinit(a1[153]);
    ssh_string_free(*(void **)&v9[4]);
    return 0xFFFFFFFFLL;
  }
  else if ( (unsigned int)ssh_packet_send((__int64)a1) == -1 )
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 0LL;
  }
}
// 1ABEA: variable 'v3' is possibly undefined
// 1ABEA: variable 'v4' is possibly undefined
// 1ABEA: variable 'v5' is possibly undefined
// 1ABEA: variable 'v6' is possibly undefined

//----- (000000000001AD30) ----------------------------------------------------
__int64 __fastcall ssh_verify_existing_algo(unsigned int a1, const char *a2)
{
  char *ptr; // [rsp+18h] [rbp-8h]

  if ( a1 > 9 )
    return 0xFFFFFFFFLL;
  ptr = ssh_find_matching(supported_methods[a1], a2);
  if ( !ptr )
    return 0LL;
  free(ptr);
  return 1LL;
}
// 280960: using guessed type char *supported_methods[8];

//----- (000000000001AD96) ----------------------------------------------------
_BYTE *__fastcall ssh_keep_known_algos(unsigned int a1, const char *a2)
{
  if ( a1 <= 9 )
    return ssh_find_all_matching(supported_methods[a1], a2);
  else
    return 0LL;
}
// 280960: using guessed type char *supported_methods[8];

//----- (000000000001ADD9) ----------------------------------------------------
__int64 __fastcall hash_hostname(const char *a1, __int64 a2, int a3, void **a4, _DWORD *a5)
{
  __int64 v6; // rax
  __int64 v9; // [rsp+38h] [rbp-8h]

  v9 = hmac_init(a2, a3, 1);
  if ( !v9 )
    return 0xFFFFFFFFLL;
  v6 = strlen(a1);
  hmac_update(v9, (__int64)a1, v6);
  hmac_final(v9, *a4, a5);
  return 0LL;
}

//----- (000000000001AE5F) ----------------------------------------------------
__int64 __fastcall match_hashed_hostname(const char *a1, const char *a2)
{
  int len; // ebx
  __int64 v4; // rax
  int v5; // eax
  size_t v6; // rbx
  const void *v7; // rax
  size_t n; // [rsp+18h] [rbp-158h] BYREF
  int v9; // [rsp+20h] [rbp-150h]
  char *v11; // [rsp+28h] [rbp-148h] BYREF
  void *v12; // [rsp+30h] [rbp-140h]
  void *v13; // [rsp+38h] [rbp-138h]
  char *s; // [rsp+40h] [rbp-130h]
  char *v15; // [rsp+48h] [rbp-128h]
  char v16[264]; // [rsp+50h] [rbp-120h] BYREF
  unsigned __int64 v17; // [rsp+158h] [rbp-18h]

  v17 = __readfsqword(0x28u);
  v12 = 0LL;
  v13 = 0LL;
  memset(v16, 0, 0x100uLL);
  v11 = v16;
  n = 256LL;
  v9 = strncmp(a2, "|1|", 3uLL);
  if ( v9 )
    return 0LL;
  s = strdup(a2 + 3);
  if ( !s )
    return 0LL;
  v15 = strchr(s, 124);
  if ( v15 )
  {
    *v15++ = 0;
    v12 = base64_to_bin(s);
    if ( v12 )
    {
      v13 = base64_to_bin(v15);
      if ( v13 )
      {
        len = ssh_buffer_get_len((__int64)v12);
        v4 = ssh_buffer_get((__int64)v12);
        if ( !(unsigned int)hash_hostname(a1, v4, len, (void **)&v11, &n) )
        {
          v5 = ssh_buffer_get_len((__int64)v13);
          if ( v5 == (_DWORD)n )
          {
            v6 = (unsigned int)n;
            v7 = (const void *)ssh_buffer_get((__int64)v13);
            v9 = memcmp(v16, v7, v6);
            if ( !v9 )
              HIDWORD(n) = 1;
          }
        }
      }
    }
  }
  free(s);
  ssh_buffer_free((__int64)v12);
  ssh_buffer_free((__int64)v13);
  return HIDWORD(n);
}

//----- (000000000001B0D6) ----------------------------------------------------
void __fastcall ssh_knownhosts_entry_free(void **a1)
{
  if ( a1 )
  {
    if ( *a1 )
    {
      free(*a1);
      *a1 = 0LL;
    }
    if ( a1[1] )
    {
      free(a1[1]);
      a1[1] = 0LL;
    }
    ssh_key_free(a1[2]);
    if ( a1[3] )
    {
      free(a1[3]);
      a1[3] = 0LL;
    }
    free(a1);
  }
}
// 1B17A: conditional instruction was optimized away because rdi.8!=0

//----- (000000000001B195) ----------------------------------------------------
__int64 __fastcall known_hosts_read_line(FILE *a1, char *a2, int a3, size_t *a4, _QWORD *a5)
{
  char *i; // rax
  size_t v10; // [rsp+38h] [rbp-8h]

  for ( i = fgets(a2, a3, a1); ; i = fgets(a2, a3, a1) )
  {
    if ( !i )
      return 0xFFFFFFFFLL;
    if ( *a2 )
      break;
  }
  ++*a5;
  v10 = strlen(a2);
  if ( a4 )
    *a4 = v10;
  if ( a2[v10 - 1] == 10 || feof(a1) )
    return 0LL;
  *__errno_location() = 7;
  return 0xFFFFFFFFLL;
}

//----- (000000000001B25E) ----------------------------------------------------
__int64 __fastcall ssh_known_hosts_read_entries(char *a1, const char *a2, _QWORD *a3)
{
  int v5; // [rsp+2Ch] [rbp-2044h]
  __int64 v6; // [rsp+30h] [rbp-2040h] BYREF
  size_t v7; // [rsp+38h] [rbp-2038h] BYREF
  void **v8; // [rsp+40h] [rbp-2030h] BYREF
  char *i; // [rsp+48h] [rbp-2028h]
  FILE *stream; // [rsp+50h] [rbp-2020h]
  _QWORD **v11; // [rsp+58h] [rbp-2018h]
  char s[8200]; // [rsp+60h] [rbp-2010h] BYREF
  unsigned __int64 v13; // [rsp+2068h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v6 = 0LL;
  v7 = 0LL;
  stream = fopen(a2, "r");
  if ( !stream )
    return 0xFFFFFFFFLL;
  v11 = (_QWORD **)ssh_list_new();
  if ( v11 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( (unsigned int)known_hosts_read_line(stream, s, 0x2000, &v7, &v6) )
        {
          *a3 = v11;
          fclose(stream);
          return 0LL;
        }
        v8 = 0LL;
        if ( s[v7] != 10 )
          v7 = strcspn(s, "\n");
        s[v7] = 0;
        for ( i = s; ((*__ctype_b_loc())[*i] & 0x2000) != 0; ++i )
          ;
        if ( *i )
        {
          if ( *i != 35 )
          {
            v5 = ssh_known_hosts_parse_line(a1, s, &v8);
            if ( v5 != -2 )
              break;
          }
        }
      }
      if ( v5 )
        break;
      ssh_list_append((__int64)v11, (__int64)v8);
    }
    ssh_list_free(v11);
    fclose(stream);
    return 0xFFFFFFFFLL;
  }
  else
  {
    fclose(stream);
    return 0xFFFFFFFFLL;
  }
}
// 1B25E: using guessed type char s[8200];

//----- (000000000001B4E4) ----------------------------------------------------
char *__fastcall ssh_session_get_host_port(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *v7; // [rsp+10h] [rbp-10h]
  char *ptr; // [rsp+18h] [rbp-8h]

  if ( !*(_QWORD *)(a1 + 1480) )
  {
    ssh_set_error(
      a1,
      2,
      "ssh_session_get_host_port",
      "Can't verify server inn known hosts if the host we should connect to has not been set",
      a5,
      a6);
    return 0LL;
  }
  ptr = ssh_lowercase(*(const char **)(a1 + 1480));
  if ( !ptr )
    goto LABEL_4;
  if ( !*(_DWORD *)(a1 + 1632) || *(_DWORD *)(a1 + 1632) == 22 )
    return ptr;
  v7 = ssh_hostport(ptr, *(_DWORD *)(a1 + 1632));
  free(ptr);
  if ( !v7 )
  {
LABEL_4:
    ssh_set_error_oom(a1, "ssh_session_get_host_port");
    return 0LL;
  }
  return v7;
}
// 1B5B3: conditional instruction was optimized away because %ptr.8!=0

//----- (000000000001B5F0) ----------------------------------------------------
_QWORD **__fastcall ssh_known_hosts_get_algorithms(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  int v7; // [rsp+1Ch] [rbp-44h]
  int v8; // [rsp+20h] [rbp-40h]
  int v9; // [rsp+24h] [rbp-3Ch]
  _QWORD **v10; // [rsp+28h] [rbp-38h] BYREF
  _QWORD *i; // [rsp+30h] [rbp-30h]
  void *ptr; // [rsp+38h] [rbp-28h]
  _QWORD **v13; // [rsp+40h] [rbp-20h]
  void **v15; // [rsp+50h] [rbp-10h]
  const char *v16; // [rsp+58h] [rbp-8h]

  v10 = 0LL;
  i = 0LL;
  ptr = 0LL;
  v13 = 0LL;
  v7 = 0;
  if ( !*(_QWORD *)(a1 + 1504) && (int)ssh_options_apply(a1, a2, a3, a4, a5, a6) < 0 )
  {
    ssh_set_error(a1, 1, "ssh_known_hosts_get_algorithms", "Can't find a known_hosts file", a5, a6);
    return 0LL;
  }
  ptr = ssh_session_get_host_port(a1, a2, a3, a4, a5, a6);
  if ( !ptr )
    return 0LL;
  v13 = (_QWORD **)ssh_list_new();
  if ( !v13 )
  {
    free(ptr);
    ptr = 0LL;
    return 0LL;
  }
  v8 = ssh_known_hosts_read_entries((char *)ptr, *(const char **)(a1 + 1504), &v10);
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  if ( v8 )
    goto LABEL_20;
  if ( !ssh_list_count((__int64)v10) )
  {
    ssh_list_free(v13);
    ssh_list_free(v10);
    return 0LL;
  }
  for ( i = (_QWORD *)ssh_list_get_iterator((__int64)v10); i; i = (_QWORD *)ssh_list_get_iterator((__int64)v10) )
  {
    v15 = 0LL;
    v16 = 0LL;
    v15 = (void **)i[1];
    v9 = ssh_key_type((unsigned int *)v15[2]);
    v16 = ssh_key_type_to_char(v9);
    if ( (unsigned int)ssh_list_append((__int64)v13, (__int64)v16) )
      v7 = 1;
    ssh_knownhosts_entry_free(v15);
    ssh_list_remove((__int64)v10, i);
  }
  ssh_list_free(v10);
  if ( !v7 )
    return v13;
LABEL_20:
  ssh_list_free(v13);
  return 0LL;
}
// 1B6A7: conditional instruction was optimized away because %ptr.8!=0
// 1B662: variable 'a5' is possibly undefined
// 1B662: variable 'a6' is possibly undefined
// 1B678: variable 'a3' is possibly undefined
// 1B678: variable 'a4' is possibly undefined

//----- (000000000001B833) ----------------------------------------------------
__int64 __fastcall ssh_known_hosts_parse_line(char *a1, const char *a2, void ***a3)
{
  unsigned int v4; // eax
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rbx
  const char *v8; // rax
  __int64 v9; // r9
  int matched; // [rsp+28h] [rbp-48h]
  unsigned int v12; // [rsp+2Ch] [rbp-44h]
  unsigned int v13; // [rsp+34h] [rbp-3Ch]
  char *v14; // [rsp+38h] [rbp-38h]
  const char *i; // [rsp+40h] [rbp-30h]
  void **v16; // [rsp+48h] [rbp-28h]
  char *needle; // [rsp+50h] [rbp-20h]
  const char *needlea; // [rsp+50h] [rbp-20h]
  const char *needleb; // [rsp+50h] [rbp-20h]
  const char *needlec; // [rsp+50h] [rbp-20h]
  const char *needled; // [rsp+50h] [rbp-20h]
  const char *needlee; // [rsp+50h] [rbp-20h]

  matched = 0;
  v14 = strdup(a2);
  if ( !v14 )
    return 0xFFFFFFFFLL;
  needle = strtok(v14, " ");
  if ( !needle || (v16 = (void **)calloc(1uLL, 0x20uLL)) == 0LL )
  {
    free(v14);
    return 0xFFFFFFFFLL;
  }
  if ( a1 )
  {
    if ( *needle == 124 )
      matched = match_hashed_hostname(a1, needle);
    for ( i = strtok(needle, ","); i; i = strtok(0LL, ",") )
    {
      v4 = strlen(i);
      if ( (unsigned int)match_hostname(a1, (__int64)i, v4) == 1 )
      {
        matched = 1;
        break;
      }
    }
    if ( !matched )
    {
      v12 = -2;
      goto LABEL_37;
    }
    *v16 = strdup(a1);
    if ( !*v16 )
    {
      v12 = -1;
      goto LABEL_37;
    }
  }
  free(v14);
  v14 = strdup(a2);
  if ( v14 )
  {
    needlea = strtok(v14, " ");
    if ( needlea )
    {
      v16[1] = strdup(needlea);
      if ( v16[1] )
      {
        needleb = strtok(0LL, " ");
        if ( needleb )
        {
          v13 = ssh_key_type_from_name(needleb);
          if ( v13 )
          {
            needlec = strtok(0LL, " ");
            if ( needlec )
            {
              v12 = ssh_pki_import_pubkey_base64(needlec, v13, v16 + 2);
              if ( v12 )
              {
                v7 = (__int64)v16[1];
                v8 = ssh_key_type_to_char(v13);
                ssh_log(1, "ssh_known_hosts_parse_line", "Failed to parse %s key for entry: %s!", (__int64)v8, v7, v9);
              }
              else
              {
                needled = strtok(0LL, " ");
                if ( !needled || (needlee = strstr(a2, needled)) == 0LL || (v16[3] = strdup(needlee)) != 0LL )
                {
                  *a3 = v16;
                  free(v14);
                  return 0LL;
                }
                v12 = -1;
              }
            }
            else
            {
              v12 = -1;
            }
          }
          else
          {
            ssh_log(1, "ssh_known_hosts_parse_line", "key type '%s' unknown!", (__int64)needleb, v5, v6);
            v12 = -1;
          }
        }
        else
        {
          v12 = -1;
        }
      }
      else
      {
        v12 = -1;
      }
    }
    else
    {
      v12 = -1;
    }
  }
  else
  {
    v12 = -1;
  }
LABEL_37:
  if ( v14 )
    free(v14);
  ssh_knownhosts_entry_free(v16);
  return v12;
}
// 1B98C: conditional instruction was optimized away because %ptr.8==0
// 1B9E7: conditional instruction was optimized away because %var_38.8!=0
// 1BBE2: conditional instruction was optimized away because %var_38.8!=0
// 1BAD6: variable 'v5' is possibly undefined
// 1BAD6: variable 'v6' is possibly undefined
// 1BB61: variable 'v9' is possibly undefined

//----- (000000000001BC30) ----------------------------------------------------
__int64 __fastcall ssh_session_has_known_hosts_entry(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  int v7; // [rsp+1Ch] [rbp-24h]
  _QWORD **v8; // [rsp+20h] [rbp-20h] BYREF
  _QWORD *i; // [rsp+28h] [rbp-18h]
  void *ptr; // [rsp+30h] [rbp-10h]
  void **v11; // [rsp+38h] [rbp-8h]

  v8 = 0LL;
  i = 0LL;
  ptr = 0LL;
  if ( *(_QWORD *)(a1 + 1504) || (int)ssh_options_apply(a1, a2, a3, a4, a5, a6) >= 0 )
  {
    ptr = ssh_session_get_host_port(a1, a2, a3, a4, a5, a6);
    if ( ptr )
    {
      v7 = ssh_known_hosts_read_entries((char *)ptr, *(const char **)(a1 + 1504), &v8);
      if ( ptr )
      {
        free(ptr);
        ptr = 0LL;
      }
      if ( v7 )
      {
        return 0LL;
      }
      else if ( ssh_list_count((__int64)v8) )
      {
        for ( i = (_QWORD *)ssh_list_get_iterator((__int64)v8); i; i = (_QWORD *)ssh_list_get_iterator((__int64)v8) )
        {
          v11 = 0LL;
          v11 = (void **)i[1];
          ssh_knownhosts_entry_free(v11);
          ssh_list_remove((__int64)v8, i);
        }
        ssh_list_free(v8);
        return 1LL;
      }
      else
      {
        ssh_list_free(v8);
        return 0LL;
      }
    }
    else
    {
      return 4294967294LL;
    }
  }
  else
  {
    ssh_set_error(a1, 1, "ssh_session_has_known_hosts_entry", "Can't find a known_hosts file", a5, a6);
    return 0xFFFFFFFFLL;
  }
}
// 1BC93: variable 'a5' is possibly undefined
// 1BC93: variable 'a6' is possibly undefined
// 1BCA9: variable 'a3' is possibly undefined
// 1BCA9: variable 'a4' is possibly undefined

//----- (000000000001BDA2) ----------------------------------------------------
__int64 __fastcall ssh_session_export_known_hosts_entry(
        __int64 a1,
        char **a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  void *v11; // [rsp+18h] [rbp-1028h] BYREF
  __int64 current_server_publickey; // [rsp+20h] [rbp-1020h]
  void *ptr; // [rsp+28h] [rbp-1018h]
  char s[4104]; // [rsp+30h] [rbp-1010h] BYREF
  unsigned __int64 v15; // [rsp+1038h] [rbp-8h]

  v15 = __readfsqword(0x28u);
  current_server_publickey = 0LL;
  ptr = 0LL;
  memset(s, 0, 0x1000uLL);
  v11 = 0LL;
  if ( a2 )
  {
    if ( *(_QWORD *)(a1 + 1480) )
    {
      ptr = ssh_session_get_host_port(a1, (__int64)a2, (__int64)s, 0LL, a5, a6);
      if ( ptr )
      {
        if ( *(_QWORD *)(a1 + 1232) )
        {
          current_server_publickey = ssh_dh_get_current_server_publickey(a1);
          if ( current_server_publickey )
          {
            if ( (int)ssh_pki_export_pubkey_base64(current_server_publickey, &v11) >= 0 )
            {
              snprintf(
                s,
                0x1000uLL,
                "%s %s %s\n",
                (const char *)ptr,
                *(const char **)(current_server_publickey + 8),
                (const char *)v11);
              if ( ptr )
              {
                free(ptr);
                ptr = 0LL;
              }
              if ( v11 )
              {
                free(v11);
                v11 = 0LL;
              }
              *a2 = strdup(s);
              if ( *a2 )
                return 0LL;
              else
                return 0xFFFFFFFFLL;
            }
            else
            {
              if ( ptr )
              {
                free(ptr);
                ptr = 0LL;
              }
              return 0xFFFFFFFFLL;
            }
          }
          else
          {
            ssh_set_error(a1, 2, "ssh_session_export_known_hosts_entry", "No public key present", v9, v10);
            free(ptr);
            ptr = 0LL;
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          ssh_set_error(
            a1,
            2,
            "ssh_session_export_known_hosts_entry",
            "No current crypto context, please connnect first",
            v7,
            v8);
          free(ptr);
          ptr = 0LL;
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      ssh_set_error(
        a1,
        2,
        "ssh_session_export_known_hosts_entry",
        "Can't create known_hosts entry - hostname unknown",
        a5,
        a6);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error_invalid(a1, "ssh_session_export_known_hosts_entry", (__int64)s, 0LL, a5, a6);
    return 0xFFFFFFFFLL;
  }
}
// 1BEDC: conditional instruction was optimized away because %ptr.8!=0
// 1BF51: conditional instruction was optimized away because %ptr.8!=0
// 1BECF: variable 'v7' is possibly undefined
// 1BECF: variable 'v8' is possibly undefined
// 1BF44: variable 'v9' is possibly undefined
// 1BF44: variable 'v10' is possibly undefined

//----- (000000000001C0A6) ----------------------------------------------------
__int64 __fastcall ssh_session_update_known_hosts(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  int *v9; // rax
  char *v10; // rax
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  int *v16; // rax
  char *v17; // rax
  int *v18; // rax
  char *v19; // rax
  int v20; // [rsp+14h] [rbp-2Ch]
  unsigned int v21; // [rsp+14h] [rbp-2Ch]
  char *s; // [rsp+18h] [rbp-28h] BYREF
  void *ptr; // [rsp+20h] [rbp-20h]
  FILE *stream; // [rsp+28h] [rbp-18h]
  size_t n; // [rsp+30h] [rbp-10h]
  size_t v26; // [rsp+38h] [rbp-8h]

  stream = 0LL;
  s = 0LL;
  ptr = 0LL;
  if ( *(_QWORD *)(a1 + 1504) || !(unsigned int)ssh_options_apply(a1, a2, a3, a4, a5, a6) )
  {
    ptr = ssh_dirname(*(const char **)(a1 + 1504));
    if ( ptr )
    {
      if ( ssh_file_readaccess_ok((const char *)ptr) )
        v20 = 0;
      else
        v20 = ssh_mkdir((const char *)ptr, 0x1C0u);
      free(ptr);
      ptr = 0LL;
      if ( v20 )
      {
        ssh_set_error(a1, 2, "ssh_session_update_known_hosts", "Cannot create %s directory.", (__int64)ptr, v12);
        return 0xFFFFFFFFLL;
      }
      else
      {
        stream = fopen(*(const char **)(a1 + 1504), "a");
        if ( stream )
        {
          v21 = ssh_session_export_known_hosts_entry(a1, &s, (__int64)&s, v13, v14, v15);
          if ( v21 )
          {
            fclose(stream);
            return v21;
          }
          else
          {
            n = strlen(s);
            v26 = fwrite(s, 1uLL, n, stream);
            if ( s )
            {
              free(s);
              s = 0LL;
            }
            if ( v26 == n && !ferror(stream) )
            {
              fclose(stream);
              return 0LL;
            }
            else
            {
              v18 = __errno_location();
              v19 = strerror(*v18);
              ssh_set_error(
                a1,
                2,
                "ssh_session_update_known_hosts",
                "Couldn't append to known_hosts file %s: %s",
                *(_QWORD *)(a1 + 1504),
                (__int64)v19);
              fclose(stream);
              return 0xFFFFFFFFLL;
            }
          }
        }
        else
        {
          v16 = __errno_location();
          v17 = strerror(*v16);
          ssh_set_error(
            a1,
            2,
            "ssh_session_update_known_hosts",
            "Couldn't open known_hosts file %s for appending: %s",
            *(_QWORD *)(a1 + 1504),
            (__int64)v17);
          return 0xFFFFFFFFLL;
        }
      }
    }
    else
    {
      v9 = __errno_location();
      v10 = strerror(*v9);
      ssh_set_error(a1, 2, "ssh_session_update_known_hosts", "%s", (__int64)v10, v11);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_session_update_known_hosts", "Can't find a known_hosts file", v6, v7);
    return 0xFFFFFFFFLL;
  }
}
// 1C1B4: conditional instruction was optimized away because %ptr.8!=0
// 1C10E: variable 'v6' is possibly undefined
// 1C10E: variable 'v7' is possibly undefined
// 1C16E: variable 'v11' is possibly undefined
// 1C1F6: variable 'v12' is possibly undefined
// 1C288: variable 'v13' is possibly undefined
// 1C288: variable 'v14' is possibly undefined
// 1C288: variable 'v15' is possibly undefined

//----- (000000000001C37A) ----------------------------------------------------
__int64 __fastcall ssh_known_hosts_check_server_key(char *a1, const char *a2, unsigned int *a3, _QWORD *a4)
{
  __int64 v5; // r8
  __int64 v6; // r9
  int v7; // ebx
  unsigned int v10; // [rsp+24h] [rbp-3Ch]
  _QWORD **v11; // [rsp+30h] [rbp-30h] BYREF
  _QWORD *iterator; // [rsp+38h] [rbp-28h]
  __int64 v13; // [rsp+40h] [rbp-20h]
  void **v14; // [rsp+48h] [rbp-18h]

  v11 = 0LL;
  iterator = 0LL;
  v10 = 0;
  if ( (unsigned int)ssh_known_hosts_read_entries(a1, a2, &v11) )
    return 0LL;
  iterator = (_QWORD *)ssh_list_get_iterator((__int64)v11);
  if ( iterator )
  {
    while ( iterator )
    {
      v13 = 0LL;
      v13 = iterator[1];
      if ( !(unsigned int)ssh_key_cmp(a3, *(_DWORD **)(v13 + 16), 0, *(_QWORD *)(v13 + 16), v5, v6) )
      {
        v10 = 1;
        if ( a4 )
        {
          *a4 = v13;
          ssh_list_remove((__int64)v11, iterator);
        }
        break;
      }
      v7 = ssh_key_type(a3);
      if ( v7 == (unsigned int)ssh_key_type(*(unsigned int **)(v13 + 16)) )
      {
        v10 = 2;
      }
      else if ( v10 != 2 )
      {
        v10 = 3;
      }
      iterator = (_QWORD *)*iterator;
    }
    for ( iterator = (_QWORD *)ssh_list_get_iterator((__int64)v11);
          iterator;
          iterator = (_QWORD *)ssh_list_get_iterator((__int64)v11) )
    {
      v14 = 0LL;
      v14 = (void **)iterator[1];
      ssh_knownhosts_entry_free(v14);
      ssh_list_remove((__int64)v11, iterator);
    }
    ssh_list_free(v11);
    return v10;
  }
  else
  {
    ssh_list_free(v11);
    return 0LL;
  }
}
// 1C430: variable 'v5' is possibly undefined
// 1C430: variable 'v6' is possibly undefined

//----- (000000000001C52F) ----------------------------------------------------
__int64 __fastcall ssh_session_get_known_hosts_entry(
        __int64 a1,
        _QWORD *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  unsigned int v13; // [rsp+1Ch] [rbp-14h]
  unsigned int *current_server_publickey; // [rsp+20h] [rbp-10h]
  char *ptr; // [rsp+28h] [rbp-8h]

  if ( *(_QWORD *)(a1 + 1504) || (int)ssh_options_apply(a1, (__int64)a2, a3, a4, a5, a6) >= 0 )
  {
    current_server_publickey = (unsigned int *)ssh_dh_get_current_server_publickey(a1);
    if ( current_server_publickey )
    {
      ptr = ssh_session_get_host_port(a1, (__int64)a2, v9, v10, v11, v12);
      if ( ptr )
      {
        v13 = ssh_known_hosts_check_server_key(ptr, *(const char **)(a1 + 1504), current_server_publickey, a2);
        free(ptr);
        return v13;
      }
      else
      {
        return 4294967294LL;
      }
    }
    else
    {
      ssh_set_error(
        a1,
        2,
        "ssh_session_get_known_hosts_entry",
        "ssh_session_is_known_host called without a server_key!",
        v11,
        v12);
      return 4294967294LL;
    }
  }
  else
  {
    ssh_set_error(a1, 1, "ssh_session_get_known_hosts_entry", "Can't find a known_hosts file", v6, v7);
    return 0xFFFFFFFFLL;
  }
}
// 1C595: variable 'v6' is possibly undefined
// 1C595: variable 'v7' is possibly undefined
// 1C5DA: variable 'v11' is possibly undefined
// 1C5DA: variable 'v12' is possibly undefined
// 1C5ED: variable 'v9' is possibly undefined
// 1C5ED: variable 'v10' is possibly undefined

//----- (000000000001C646) ----------------------------------------------------
__int64 __fastcall ssh_session_is_known_server(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return ssh_session_get_known_hosts_entry(a1, 0LL, a3, a4, a5, a6);
}

//----- (000000000001C665) ----------------------------------------------------
__int64 __fastcall current_timestring(int a1, char *a2, size_t a3)
{
  time_t timer; // [rsp+20h] [rbp-70h] BYREF
  struct tm *tp; // [rsp+28h] [rbp-68h]
  struct timeval tv; // [rsp+30h] [rbp-60h] BYREF
  char s[72]; // [rsp+40h] [rbp-50h] BYREF
  unsigned __int64 v9; // [rsp+88h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  gettimeofday(&tv, 0LL);
  timer = tv.tv_sec;
  tp = localtime(&timer);
  if ( !tp )
    return 0xFFFFFFFFLL;
  strftime(s, 0x3FuLL, "%Y/%m/%d %H:%M:%S", tp);
  if ( a1 )
    snprintf(a2, a3, "%s.%06ld", s, tv.tv_usec);
  else
    snprintf(a2, a3, "%s", s);
  return 0LL;
}

//----- (000000000001C77B) ----------------------------------------------------
unsigned __int64 __fastcall ssh_log_stderr(unsigned int a1, const char *a2, const char *a3)
{
  char v5[72]; // [rsp+30h] [rbp-50h] BYREF
  unsigned __int64 v6; // [rsp+78h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  memset(v5, 0, 0x40uLL);
  if ( (unsigned int)current_timestring(1, v5, 0x40uLL) )
    fprintf(stderr, "[%d] %s", a1, a2);
  else
    fprintf(stderr, "[%s, %d] %s:", v5, a1, a2);
  fprintf(stderr, "  %s\n", a3);
  return __readfsqword(0x28u) ^ v6;
}

//----- (000000000001C85C) ----------------------------------------------------
unsigned __int64 __fastcall ssh_log_function(unsigned int a1, const char *a2, const char *a3)
{
  __int64 log_userdata; // rax
  void (__fastcall *log_callback)(_QWORD, const char *, char *, __int64); // [rsp+28h] [rbp-418h]
  char s[1032]; // [rsp+30h] [rbp-410h] BYREF
  unsigned __int64 v8; // [rsp+438h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  log_callback = (void (__fastcall *)(_QWORD, const char *, char *, __int64))ssh_get_log_callback();
  if ( log_callback )
  {
    snprintf(s, 0x400uLL, "%s: %s", a2, a3);
    log_userdata = ssh_get_log_userdata();
    log_callback(a1, a2, s, log_userdata);
  }
  else
  {
    ssh_log_stderr(a1, a2, a3);
  }
  return __readfsqword(0x28u) ^ v8;
}
// 1CCC1: using guessed type __int64 ssh_get_log_callback(void);
// 1CCDA: using guessed type __int64 ssh_get_log_userdata(void);

//----- (000000000001C930) ----------------------------------------------------
unsigned __int64 ssh_log(signed int a1, const char *a2, const char *a3, __int64 a4, __int64 a5, __int64 a6, ...)
{
  gcc_va_list arg; // [rsp+28h] [rbp-4D8h] BYREF
  char s[1032]; // [rsp+40h] [rbp-4C0h] BYREF
  unsigned __int64 v10; // [rsp+448h] [rbp-B8h]
  __int64 v11; // [rsp+468h] [rbp-98h]
  __int64 v12; // [rsp+470h] [rbp-90h]
  __int64 v13; // [rsp+478h] [rbp-88h]

  v11 = a4;
  v12 = a5;
  v13 = a6;
  v10 = __readfsqword(0x28u);
  if ( (int)ssh_get_log_level() >= a1 )
  {
    va_start(arg, a6);
    vsnprintf(s, 0x400uLL, a3, arg);
    ssh_log_function(a1, a2, s);
  }
  return __readfsqword(0x28u) ^ v10;
}
// 1CC6E: using guessed type __int64 ssh_get_log_level(void);

//----- (000000000001CA2E) ----------------------------------------------------
unsigned __int64 ssh_log(__int64 a1, signed int a2, const char *a3, __int64 a4, __int64 a5, __int64 a6, ...)
{
  gcc_va_list arg; // [rsp+28h] [rbp-4D8h] BYREF
  char s[1032]; // [rsp+40h] [rbp-4C0h] BYREF
  unsigned __int64 v9; // [rsp+448h] [rbp-B8h]
  __int64 v10; // [rsp+468h] [rbp-98h]
  __int64 v11; // [rsp+470h] [rbp-90h]
  __int64 v12; // [rsp+478h] [rbp-88h]

  v10 = a4;
  v11 = a5;
  v12 = a6;
  v9 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 1040) >= a2 )
  {
    va_start(arg, a6);
    vsnprintf(s, 0x400uLL, a3, arg);
    ssh_log_function(a2, byte_55082, s);
  }
  return __readfsqword(0x28u) ^ v9;
}

//----- (000000000001CB31) ----------------------------------------------------
unsigned __int64 ssh_log_common(__int64 a1, signed int a2, const char *a3, const char *a4, __int64 a5, __int64 a6, ...)
{
  gcc_va_list arg; // [rsp+28h] [rbp-4D8h] BYREF
  char s[1032]; // [rsp+40h] [rbp-4C0h] BYREF
  unsigned __int64 v10; // [rsp+448h] [rbp-B8h]
  __int64 v11; // [rsp+470h] [rbp-90h]
  __int64 v12; // [rsp+478h] [rbp-88h]

  v11 = a5;
  v12 = a6;
  v10 = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 1040) >= a2 )
  {
    va_start(arg, a6);
    vsnprintf(s, 0x400uLL, a4, arg);
    ssh_log_function(a2, a3, s);
  }
  return __readfsqword(0x28u) ^ v10;
}

//----- (000000000001CC37) ----------------------------------------------------
__int64 __fastcall ssh_set_log_level(int a1)
{
  if ( a1 < 0 )
    return 0xFFFFFFFFLL;
  *(_DWORD *)(__readfsqword(0) - 24) = a1;
  return 0LL;
}

//----- (000000000001CC6E) ----------------------------------------------------
__int64 ssh_get_log_level()
{
  return *(unsigned int *)(__readfsqword(0) - 24);
}
// 1CC6E: using guessed type __int64 ssh_get_log_level();

//----- (000000000001CC86) ----------------------------------------------------
__int64 __fastcall ssh_set_log_callback(__int64 a1)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  *(_QWORD *)(__readfsqword(0) - 16) = a1;
  return 0LL;
}

//----- (000000000001CCC1) ----------------------------------------------------
__int64 ssh_get_log_callback()
{
  return *(_QWORD *)(__readfsqword(0) - 16);
}
// 1CCC1: using guessed type __int64 ssh_get_log_callback();

//----- (000000000001CCDA) ----------------------------------------------------
__int64 ssh_get_log_userdata()
{
  if ( *(_QWORD *)(__readfsqword(0) - 8) )
    return *(_QWORD *)(__readfsqword(0) - 8);
  else
    return 0LL;
}
// 1CCDA: using guessed type __int64 ssh_get_log_userdata();

//----- (000000000001CD12) ----------------------------------------------------
__int64 __fastcall ssh_set_log_userdata(__int64 a1)
{
  *(_QWORD *)(__readfsqword(0) - 8) = a1;
  return 0LL;
}

//----- (000000000001CD3F) ----------------------------------------------------
_BOOL8 __fastcall match_pattern(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v3; // [rsp+0h] [rbp-10h]
  _BYTE *v4; // [rsp+0h] [rbp-10h]
  _BYTE *v5; // [rsp+8h] [rbp-8h]

  v5 = a1;
  v3 = a2;
  if ( !a1 || !a2 )
    return 0LL;
  while ( 1 )
  {
    if ( !*v3 )
      return *v5 == 0;
    if ( *v3 == 42 )
      break;
    if ( !*v5 )
      return 0LL;
    if ( *v3 != 63 && *v3 != *v5 )
      return 0LL;
    ++v5;
    ++v3;
  }
  v4 = v3 + 1;
  if ( !*v4 )
    return 1LL;
  if ( *v4 == 63 || *v4 == 42 )
  {
    while ( *v5 )
    {
      if ( (unsigned int)match_pattern(v5, v4) )
        return 1LL;
      ++v5;
    }
    return 0LL;
  }
  else
  {
    while ( *v5 )
    {
      if ( *v5 == *v4 && (unsigned int)match_pattern(v5 + 1, v4 + 1) )
        return 1LL;
      ++v5;
    }
    return 0LL;
  }
}

//----- (000000000001CE99) ----------------------------------------------------
__int64 __fastcall match_pattern_list(_BYTE *a1, __int64 a2, unsigned int a3, int a4)
{
  char v4; // al
  int v8; // [rsp+20h] [rbp-420h]
  unsigned int v9; // [rsp+24h] [rbp-41Ch]
  unsigned int v10; // [rsp+28h] [rbp-418h]
  unsigned int i; // [rsp+2Ch] [rbp-414h]
  char v12[1032]; // [rsp+30h] [rbp-410h] BYREF
  unsigned __int64 v13; // [rsp+438h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v9 = 0;
  v10 = 0;
  while ( v10 < a3 )
  {
    if ( *(_BYTE *)(v10 + a2) == 33 )
    {
      v8 = 1;
      ++v10;
    }
    else
    {
      v8 = 0;
    }
    for ( i = 0; v10 < a3 && i <= 0x3FE && *(_BYTE *)(v10 + a2) != 44; ++i )
    {
      if ( a4 && ((*__ctype_b_loc())[*(char *)(v10 + a2)] & 0x100) != 0 )
        v4 = tolower(*(char *)(v10 + a2));
      else
        v4 = *(_BYTE *)(v10 + a2);
      v12[i] = v4;
      ++v10;
    }
    if ( i > 0x3FE )
      return 0LL;
    if ( v10 < a3 && *(_BYTE *)(v10 + a2) == 44 )
      ++v10;
    v12[i] = 0;
    if ( match_pattern(a1, v12) )
    {
      if ( v8 )
        return 0xFFFFFFFFLL;
      v9 = 1;
    }
  }
  return v9;
}
// 1CE99: using guessed type char var_410[1032];

//----- (000000000001D09D) ----------------------------------------------------
__int64 __fastcall match_hostname(_BYTE *a1, __int64 a2, unsigned int a3)
{
  return match_pattern_list(a1, a2, a3, 1);
}

//----- (000000000001D0CA) ----------------------------------------------------
_QWORD *__fastcall ssh_message_new(__int64 a1)
{
  _QWORD *s; // [rsp+18h] [rbp-8h]

  s = malloc(0x100uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x100uLL);
  *s = a1;
  return s;
}

//----- (000000000001D120) ----------------------------------------------------
__int64 __fastcall ssh_execute_server_request(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rsi
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rsi
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // rdx
  __int64 v28; // rcx
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 v31; // rdx
  __int64 v32; // rcx
  __int64 v33; // r8
  __int64 v34; // r9
  __int64 v35; // rdx
  __int64 v36; // rcx
  __int64 v37; // r8
  __int64 v38; // r9
  __int64 v39; // rdx
  __int64 v40; // rcx
  __int64 v41; // r8
  __int64 v42; // r9
  __int64 v43; // rdx
  __int64 v44; // rcx
  __int64 v45; // r8
  __int64 v46; // r9
  __int64 v47; // rsi
  __int64 v48; // rdx
  __int64 v49; // rcx
  __int64 v50; // r8
  __int64 v51; // r9
  int v53; // [rsp+14h] [rbp-7Ch]
  int v54; // [rsp+14h] [rbp-7Ch]
  int v55; // [rsp+14h] [rbp-7Ch]
  _QWORD *i; // [rsp+18h] [rbp-78h]
  _QWORD *j; // [rsp+20h] [rbp-70h]
  _QWORD *k; // [rsp+28h] [rbp-68h]
  _QWORD *m; // [rsp+30h] [rbp-60h]
  _QWORD *n; // [rsp+38h] [rbp-58h]
  _QWORD *ii; // [rsp+40h] [rbp-50h]
  _QWORD *jj; // [rsp+48h] [rbp-48h]
  _DWORD *v63; // [rsp+50h] [rbp-40h]
  __int64 v64; // [rsp+50h] [rbp-40h]
  _QWORD *v65; // [rsp+58h] [rbp-38h]
  _QWORD *v66; // [rsp+60h] [rbp-30h]
  _QWORD *v67; // [rsp+68h] [rbp-28h]
  _QWORD *v68; // [rsp+70h] [rbp-20h]
  _QWORD *v69; // [rsp+78h] [rbp-18h]
  _QWORD *v70; // [rsp+80h] [rbp-10h]
  _QWORD *v71; // [rsp+88h] [rbp-8h]

  switch ( *(_DWORD *)(a2 + 8) )
  {
    case 1:
      if ( *(_DWORD *)(a2 + 24) == 2
        && *(_QWORD *)(a1 + 1360)
        && (unsigned __int64)(*(_QWORD *)(a1 + 1360) + 16LL) < *(_QWORD *)(a1 + 1360) + **(_QWORD **)(a1 + 1360)
        && *(_QWORD *)(*(_QWORD *)(a1 + 1360) + 16LL) )
      {
        v2 = *(_QWORD *)(a2 + 16);
        v53 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)(a1 + 1360) + 16LL))(
                a1,
                v2,
                *(_QWORD *)(a2 + 32),
                *(_QWORD *)(*(_QWORD *)(a1 + 1360) + 8LL));
        if ( v53 && v53 != 2 )
          ssh_message_reply_default(a2, v2, v3, v4, v5, v6);
        else
          ssh_message_auth_reply_success((__int64 *)a2, v53 == 2);
        return 0LL;
      }
      if ( *(_DWORD *)(a2 + 24) == 4
        && *(_QWORD *)(a1 + 1360)
        && (unsigned __int64)(*(_QWORD *)(a1 + 1360) + 40LL) < *(_QWORD *)(a1 + 1360) + **(_QWORD **)(a1 + 1360)
        && *(_QWORD *)(*(_QWORD *)(a1 + 1360) + 40LL) )
      {
        v8 = *(_QWORD *)(a2 + 16);
        v54 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 1360) + 40LL))(
                a1,
                v8,
                *(_QWORD *)(a2 + 40),
                (unsigned int)*(char *)(a2 + 48),
                *(_QWORD *)(*(_QWORD *)(a1 + 1360) + 8LL));
        if ( *(_BYTE *)(a2 + 48) )
        {
          if ( !v54 || v54 == 2 )
          {
            ssh_message_auth_reply_success((__int64 *)a2, v54 == 2);
            return 0LL;
          }
        }
        else if ( !v54 )
        {
          ssh_message_auth_reply_pk_ok_simple((__int64 *)a2);
          return 0LL;
        }
        ssh_message_reply_default(a2, v8, v9, v10, v11, v12);
        return 0LL;
      }
      if ( *(_DWORD *)(a2 + 24) != 1
        || !*(_QWORD *)(a1 + 1360)
        || (unsigned __int64)(*(_QWORD *)(a1 + 1360) + 24LL) >= *(_QWORD *)(a1 + 1360) + **(_QWORD **)(a1 + 1360)
        || !*(_QWORD *)(*(_QWORD *)(a1 + 1360) + 24LL) )
      {
        return 4294967294LL;
      }
      v13 = *(_QWORD *)(a2 + 16);
      v55 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)(a1 + 1360) + 24LL))(
              a1,
              v13,
              *(_QWORD *)(*(_QWORD *)(a1 + 1360) + 8LL));
      if ( v55 && v55 != 2 )
        ssh_message_reply_default(a2, v13, v14, v15, v16, v17);
      else
        ssh_message_auth_reply_success((__int64 *)a2, v55 == 2);
      return 0LL;
    case 2:
      if ( *(_DWORD *)(a2 + 56) != 1
        || !*(_QWORD *)(a1 + 1360)
        || (unsigned __int64)(*(_QWORD *)(a1 + 1360) + 56LL) >= *(_QWORD *)(a1 + 1360) + **(_QWORD **)(a1 + 1360)
        || !*(_QWORD *)(*(_QWORD *)(a1 + 1360) + 56LL) )
      {
        return 4294967294LL;
      }
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 1360) + 8LL);
      v63 = (_DWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 + 1360) + 56LL))(a1, v18);
      if ( v63 )
        ssh_message_channel_request_open_reply_accept_channel(a2, v63);
      else
        ssh_message_reply_default(a2, v18, v19, v20, v21, v22);
      return 0LL;
    case 3:
      v64 = *(_QWORD *)(a2 + 112);
      switch ( *(_DWORD *)(a2 + 104) )
      {
        case 1:
          for ( i = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(v64 + 88)); ; i = (_QWORD *)*i )
          {
            if ( !i )
              return 4294967294LL;
            v65 = (_QWORD *)i[1];
            if ( v65 )
            {
              if ( v65 + 8 < (_QWORD *)((char *)v65 + *v65) && v65[8] )
                break;
            }
          }
          if ( ((unsigned int (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v65[8])(
                 a1,
                 v64,
                 *(_QWORD *)(a2 + 128),
                 *(unsigned int *)(a2 + 136),
                 *(unsigned int *)(a2 + 140),
                 *(unsigned int *)(a2 + 144),
                 *(unsigned int *)(a2 + 148),
                 v65[1]) )
          {
            ssh_message_reply_default(a2, v64, v23, v24, v25, v26);
          }
          else
          {
            ssh_message_channel_request_reply_success(a2, v64, v23, v24, v25, v26);
          }
          return 0LL;
        case 3:
          for ( j = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(v64 + 88)); ; j = (_QWORD *)*j )
          {
            if ( !j )
              return 4294967294LL;
            v66 = (_QWORD *)j[1];
            if ( v66 )
            {
              if ( v66 + 9 < (_QWORD *)((char *)v66 + *v66) && v66[9] )
                break;
            }
          }
          if ( ((unsigned int (__fastcall *)(__int64, __int64, _QWORD))v66[9])(a1, v64, v66[1]) )
            ssh_message_reply_default(a2, v64, v27, v28, v29, v30);
          else
            ssh_message_channel_request_reply_success(a2, v64, v27, v28, v29, v30);
          return 0LL;
        case 7:
          for ( k = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(v64 + 88)); ; k = (_QWORD *)*k )
          {
            if ( !k )
              return 4294967294LL;
            v67 = (_QWORD *)k[1];
            if ( v67 )
            {
              if ( v67 + 11 < (_QWORD *)((char *)v67 + *v67) && v67[11] )
                break;
            }
          }
          ((void (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v67[11])(
            a1,
            v64,
            *(unsigned __int8 *)(a2 + 192),
            *(_QWORD *)(a2 + 200),
            *(_QWORD *)(a2 + 208),
            *(unsigned int *)(a2 + 216),
            v67[1]);
          ssh_message_channel_request_reply_success(a2, v64, v31, v32, v33, v34);
          return 0LL;
        case 6:
          for ( m = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(v64 + 88)); ; m = (_QWORD *)*m )
          {
            if ( !m )
              return 4294967294LL;
            v68 = (_QWORD *)m[1];
            if ( v68 )
            {
              if ( v68 + 12 < (_QWORD *)((char *)v68 + *v68) && v68[12] )
                break;
            }
          }
          ((void (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v68[12])(
            a1,
            v64,
            *(unsigned int *)(a2 + 136),
            *(unsigned int *)(a2 + 140),
            *(unsigned int *)(a2 + 144),
            *(unsigned int *)(a2 + 148),
            v68[1]);
          return 0LL;
        case 2:
          for ( n = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(v64 + 88)); ; n = (_QWORD *)*n )
          {
            if ( !n )
              return 4294967294LL;
            v69 = (_QWORD *)n[1];
            if ( v69 )
            {
              if ( v69 + 13 < (_QWORD *)((char *)v69 + *v69) && v69[13] )
                break;
            }
          }
          if ( ((unsigned int (__fastcall *)(__int64, __int64, _QWORD, _QWORD))v69[13])(
                 a1,
                 v64,
                 *(_QWORD *)(a2 + 176),
                 v69[1]) )
          {
            ssh_message_reply_default(a2, v64, v35, v36, v37, v38);
          }
          else
          {
            ssh_message_channel_request_reply_success(a2, v64, v35, v36, v37, v38);
          }
          return 0LL;
        case 4:
          for ( ii = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(v64 + 88)); ; ii = (_QWORD *)*ii )
          {
            if ( !ii )
              return 4294967294LL;
            v70 = (_QWORD *)ii[1];
            if ( v70 )
            {
              if ( v70 + 14 < (_QWORD *)((char *)v70 + *v70) && v70[14] )
                break;
            }
          }
          if ( ((unsigned int (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD))v70[14])(
                 a1,
                 v64,
                 *(_QWORD *)(a2 + 160),
                 *(_QWORD *)(a2 + 168),
                 v70[1]) )
          {
            ssh_message_reply_default(a2, v64, v39, v40, v41, v42);
          }
          else
          {
            ssh_message_channel_request_reply_success(a2, v64, v39, v40, v41, v42);
          }
          return 0LL;
        case 5:
          for ( jj = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(v64 + 88)); ; jj = (_QWORD *)*jj )
          {
            if ( !jj )
              return 4294967294LL;
            v71 = (_QWORD *)jj[1];
            if ( v71 )
            {
              if ( v71 + 15 < (_QWORD *)((char *)v71 + *v71) && v71[15] )
                break;
            }
          }
          if ( ((unsigned int (__fastcall *)(__int64, __int64, _QWORD, _QWORD))v71[15])(
                 a1,
                 v64,
                 *(_QWORD *)(a2 + 184),
                 v71[1]) )
          {
            ssh_message_reply_default(a2, v64, v43, v44, v45, v46);
          }
          else
          {
            ssh_message_channel_request_reply_success(a2, v64, v43, v44, v45, v46);
          }
          return 0LL;
        default:
          return 4294967294LL;
      }
    case 4:
      if ( !*(_QWORD *)(a1 + 1360)
        || (unsigned __int64)(*(_QWORD *)(a1 + 1360) + 48LL) >= *(_QWORD *)(a1 + 1360) + **(_QWORD **)(a1 + 1360)
        || !*(_QWORD *)(*(_QWORD *)(a1 + 1360) + 48LL) )
      {
        return 4294967294LL;
      }
      v47 = *(_QWORD *)(a2 + 224);
      if ( (*(unsigned int (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)(a1 + 1360) + 48LL))(
             a1,
             v47,
             *(_QWORD *)(*(_QWORD *)(a1 + 1360) + 8LL)) )
      {
        ssh_disconnect(a1);
      }
      else
      {
        ssh_message_reply_default(a2, v47, v48, v49, v50, v51);
      }
      return 0LL;
    default:
      return 4294967294LL;
  }
}
// 1D272: variable 'v3' is possibly undefined
// 1D272: variable 'v4' is possibly undefined
// 1D272: variable 'v5' is possibly undefined
// 1D272: variable 'v6' is possibly undefined
// 1D3C1: variable 'v9' is possibly undefined
// 1D3C1: variable 'v10' is possibly undefined
// 1D3C1: variable 'v11' is possibly undefined
// 1D3C1: variable 'v12' is possibly undefined
// 1D4C3: variable 'v14' is possibly undefined
// 1D4C3: variable 'v15' is possibly undefined
// 1D4C3: variable 'v16' is possibly undefined
// 1D4C3: variable 'v17' is possibly undefined
// 1D5BF: variable 'v19' is possibly undefined
// 1D5BF: variable 'v20' is possibly undefined
// 1D5BF: variable 'v21' is possibly undefined
// 1D5BF: variable 'v22' is possibly undefined
// 1D6DB: variable 'v23' is possibly undefined
// 1D6DB: variable 'v24' is possibly undefined
// 1D6DB: variable 'v25' is possibly undefined
// 1D6DB: variable 'v26' is possibly undefined
// 1D7B0: variable 'v27' is possibly undefined
// 1D7B0: variable 'v28' is possibly undefined
// 1D7B0: variable 'v29' is possibly undefined
// 1D7B0: variable 'v30' is possibly undefined
// 1D8C9: variable 'v31' is possibly undefined
// 1D8C9: variable 'v32' is possibly undefined
// 1D8C9: variable 'v33' is possibly undefined
// 1D8C9: variable 'v34' is possibly undefined
// 1DA9F: variable 'v35' is possibly undefined
// 1DA9F: variable 'v36' is possibly undefined
// 1DA9F: variable 'v37' is possibly undefined
// 1DA9F: variable 'v38' is possibly undefined
// 1DB91: variable 'v39' is possibly undefined
// 1DB91: variable 'v40' is possibly undefined
// 1DB91: variable 'v41' is possibly undefined
// 1DB91: variable 'v42' is possibly undefined
// 1DC75: variable 'v43' is possibly undefined
// 1DC75: variable 'v44' is possibly undefined
// 1DC75: variable 'v45' is possibly undefined
// 1DC75: variable 'v46' is possibly undefined
// 1DD6C: variable 'v48' is possibly undefined
// 1DD6C: variable 'v49' is possibly undefined
// 1DD6C: variable 'v50' is possibly undefined
// 1DD6C: variable 'v51' is possibly undefined

//----- (000000000001DD9E) ----------------------------------------------------
__int64 __fastcall ssh_execute_client_request(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  _DWORD *v9; // [rsp+18h] [rbp-8h]

  if ( *(_DWORD *)(a2 + 8) == 2
    && *(_DWORD *)(a2 + 56) == 4
    && *(_QWORD *)(a1 + 1032)
    && (unsigned __int64)(*(_QWORD *)(a1 + 1032) + 48LL) < *(_QWORD *)(a1 + 1032) + **(_QWORD **)(a1 + 1032)
    && *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 48LL) )
  {
    v2 = *(_QWORD *)(a2 + 72);
    v9 = (_DWORD *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)(a1 + 1032) + 48LL))(
                     a1,
                     v2,
                     *(unsigned __int16 *)(a2 + 80),
                     *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL));
    if ( v9 )
      return (unsigned int)ssh_message_channel_request_open_reply_accept_channel(a2, v9);
    goto LABEL_15;
  }
  if ( *(_DWORD *)(a2 + 8) == 2
    && *(_DWORD *)(a2 + 56) == 5
    && *(_QWORD *)(a1 + 1032)
    && (unsigned __int64)(*(_QWORD *)(a1 + 1032) + 56LL) < *(_QWORD *)(a1 + 1032) + **(_QWORD **)(a1 + 1032)
    && *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 56LL) )
  {
    v2 = *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL);
    v9 = (_DWORD *)(*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 + 1032) + 56LL))(a1, v2);
    if ( v9 )
      return (unsigned int)ssh_message_channel_request_open_reply_accept_channel(a2, v9);
LABEL_15:
    ssh_message_reply_default(a2, v2, v3, v4, v5, v6);
    return 0LL;
  }
  return 4294967294LL;
}
// 1DF7E: variable 'v3' is possibly undefined
// 1DF7E: variable 'v4' is possibly undefined
// 1DF7E: variable 'v5' is possibly undefined
// 1DF7E: variable 'v6' is possibly undefined

//----- (000000000001DF8F) ----------------------------------------------------
__int64 __fastcall ssh_execute_server_callbacks(__int64 a1, __int64 a2)
{
  unsigned int v3; // [rsp+1Ch] [rbp-4h]

  v3 = -2;
  if ( *(_QWORD *)(a1 + 1360) )
  {
    return (unsigned int)ssh_execute_server_request(a1, a2);
  }
  else if ( *(_QWORD *)(a1 + 1032) )
  {
    return (unsigned int)ssh_execute_client_request(a1, a2);
  }
  return v3;
}

//----- (000000000001DFF9) ----------------------------------------------------
__int64 __fastcall ssh_execute_message_callback(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v11; // [rsp+1Ch] [rbp-4h]
  unsigned int v12; // [rsp+1Ch] [rbp-4h]

  if ( *(_QWORD *)(a1 + 1344) )
  {
    if ( (*(unsigned int (__fastcall **)(__int64, __int64, _QWORD))(a1 + 1344))(a1, a2, *(_QWORD *)(a1 + 1352)) == 1 )
    {
      v11 = ssh_message_reply_default(a2, a2, v6, v7, v8, v9);
      ssh_message_free(a2);
      if ( v11 )
        return v11;
    }
    else
    {
      ssh_message_free(a2);
    }
  }
  else
  {
    v12 = ssh_message_reply_default(a2, a2, a3, a4, a5, a6);
    ssh_message_free(a2);
    if ( v12 )
      return v12;
  }
  return 0LL;
}
// 1E04C: variable 'v6' is possibly undefined
// 1E04C: variable 'v7' is possibly undefined
// 1E04C: variable 'v8' is possibly undefined
// 1E04C: variable 'v9' is possibly undefined

//----- (000000000001E0A6) ----------------------------------------------------
void __fastcall ssh_message_queue(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9

  if ( a2 )
  {
    if ( (unsigned int)ssh_execute_server_callbacks((__int64)a1, a2) )
    {
      if ( a1[168] )
      {
        ssh_execute_message_callback((__int64)a1, a2, a2, v3, v4, v5);
      }
      else if ( a1[170] )
      {
        ssh_message_reply_default(a2, a2, v2, v3, v4, v5);
        ssh_message_free(a2);
      }
      else
      {
        if ( !a1[167] )
          a1[167] = (__int64)ssh_list_new();
        if ( a1[167] )
          ssh_list_append(a1[167], a2);
      }
    }
    else
    {
      ssh_message_free(a2);
    }
  }
}
// 1E10C: variable 'v3' is possibly undefined
// 1E10C: variable 'v4' is possibly undefined
// 1E10C: variable 'v5' is possibly undefined
// 1E12A: variable 'v2' is possibly undefined

//----- (000000000001E18C) ----------------------------------------------------
__int64 __fastcall ssh_message_pop_head(__int64 a1)
{
  __int64 v2; // [rsp+10h] [rbp-10h]
  _QWORD *iterator; // [rsp+18h] [rbp-8h]

  v2 = 0LL;
  if ( !*(_QWORD *)(a1 + 1336) )
    return 0LL;
  iterator = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(a1 + 1336));
  if ( iterator )
  {
    v2 = iterator[1];
    ssh_list_remove(*(_QWORD *)(a1 + 1336), iterator);
  }
  return v2;
}

//----- (000000000001E201) ----------------------------------------------------
_BOOL8 __fastcall ssh_message_termination(__int64 a1)
{
  return *(_DWORD *)(a1 + 1164) == 9 || ssh_list_get_iterator(*(_QWORD *)(a1 + 1336)) != 0;
}

//----- (000000000001E257) ----------------------------------------------------
__int64 __fastcall ssh_message_get(__int64 a1)
{
  __int64 v2; // [rsp+18h] [rbp-8h]

  v2 = ssh_message_pop_head(a1);
  if ( v2 )
    return v2;
  if ( !*(_QWORD *)(a1 + 1336) )
    *(_QWORD *)(a1 + 1336) = ssh_list_new();
  if ( (unsigned int)ssh_handle_packets_termination(
                       a1,
                       0xFFFFFFFE,
                       (unsigned int (__fastcall *)(__int64))ssh_message_termination,
                       a1)
    || *(_DWORD *)(a1 + 1164) == 9 )
  {
    return 0LL;
  }
  else
  {
    return ssh_list_pop_head(*(_QWORD *)(a1 + 1336));
  }
}

//----- (000000000001E306) ----------------------------------------------------
__int64 __fastcall ssh_message_type(__int64 a1)
{
  if ( a1 )
    return *(unsigned int *)(a1 + 8);
  else
    return 0xFFFFFFFFLL;
}

//----- (000000000001E325) ----------------------------------------------------
__int64 __fastcall ssh_message_subtype(_DWORD *a1)
{
  int v2; // eax

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v2 = a1[2];
  if ( v2 == 2 )
    return (unsigned int)a1[14];
  if ( v2 > 2 )
  {
    if ( v2 == 3 )
      return (unsigned int)a1[26];
    if ( v2 == 5 )
      return (unsigned int)a1[58];
  }
  else if ( v2 == 1 )
  {
    return (unsigned int)a1[6];
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000001E38D) ----------------------------------------------------
void __fastcall ssh_message_free(__int64 a1)
{
  size_t v1; // rax

  if ( a1 )
  {
    switch ( *(_DWORD *)(a1 + 8) )
    {
      case 1:
        if ( *(_QWORD *)(a1 + 16) )
        {
          free(*(void **)(a1 + 16));
          *(_QWORD *)(a1 + 16) = 0LL;
        }
        if ( *(_QWORD *)(a1 + 32) )
        {
          v1 = strlen(*(const char **)(a1 + 32));
          explicit_bzero(*(void **)(a1 + 32), v1);
          if ( *(_QWORD *)(a1 + 32) )
          {
            free(*(void **)(a1 + 32));
            *(_QWORD *)(a1 + 32) = 0LL;
          }
        }
        ssh_key_free(*(void **)(a1 + 40));
        break;
      case 2:
        if ( *(_QWORD *)(a1 + 72) )
        {
          free(*(void **)(a1 + 72));
          *(_QWORD *)(a1 + 72) = 0LL;
        }
        if ( *(_QWORD *)(a1 + 88) )
        {
          free(*(void **)(a1 + 88));
          *(_QWORD *)(a1 + 88) = 0LL;
        }
        break;
      case 3:
        if ( *(_QWORD *)(a1 + 128) )
        {
          free(*(void **)(a1 + 128));
          *(_QWORD *)(a1 + 128) = 0LL;
        }
        if ( *(_QWORD *)(a1 + 152) )
        {
          free(*(void **)(a1 + 152));
          *(_QWORD *)(a1 + 152) = 0LL;
        }
        if ( *(_QWORD *)(a1 + 160) )
        {
          free(*(void **)(a1 + 160));
          *(_QWORD *)(a1 + 160) = 0LL;
        }
        if ( *(_QWORD *)(a1 + 168) )
        {
          free(*(void **)(a1 + 168));
          *(_QWORD *)(a1 + 168) = 0LL;
        }
        if ( *(_QWORD *)(a1 + 176) )
        {
          free(*(void **)(a1 + 176));
          *(_QWORD *)(a1 + 176) = 0LL;
        }
        if ( *(_QWORD *)(a1 + 184) )
        {
          free(*(void **)(a1 + 184));
          *(_QWORD *)(a1 + 184) = 0LL;
        }
        switch ( *(_DWORD *)(a1 + 104) )
        {
          case 1:
            if ( *(_QWORD *)(a1 + 128) )
            {
              free(*(void **)(a1 + 128));
              *(_QWORD *)(a1 + 128) = 0LL;
            }
            break;
          case 2:
            if ( *(_QWORD *)(a1 + 176) )
            {
              free(*(void **)(a1 + 176));
              *(_QWORD *)(a1 + 176) = 0LL;
            }
            break;
          case 4:
            if ( *(_QWORD *)(a1 + 160) )
            {
              free(*(void **)(a1 + 160));
              *(_QWORD *)(a1 + 160) = 0LL;
            }
            if ( *(_QWORD *)(a1 + 168) )
            {
              free(*(void **)(a1 + 168));
              *(_QWORD *)(a1 + 168) = 0LL;
            }
            break;
          case 5:
            if ( *(_QWORD *)(a1 + 184) )
            {
              free(*(void **)(a1 + 184));
              *(_QWORD *)(a1 + 184) = 0LL;
            }
            break;
          case 7:
            if ( *(_QWORD *)(a1 + 200) )
            {
              free(*(void **)(a1 + 200));
              *(_QWORD *)(a1 + 200) = 0LL;
            }
            if ( *(_QWORD *)(a1 + 208) )
            {
              free(*(void **)(a1 + 208));
              *(_QWORD *)(a1 + 208) = 0LL;
            }
            break;
          default:
            goto LABEL_49;
        }
        break;
      case 4:
        if ( *(_QWORD *)(a1 + 224) )
        {
          free(*(void **)(a1 + 224));
          *(_QWORD *)(a1 + 224) = 0LL;
        }
        break;
      case 5:
        if ( *(_QWORD *)(a1 + 240) )
        {
          free(*(void **)(a1 + 240));
          *(_QWORD *)(a1 + 240) = 0LL;
        }
        break;
      default:
        break;
    }
LABEL_49:
    memset((void *)a1, 0, 0x100uLL);
    free((void *)a1);
  }
}
// 1E832: conditional instruction was optimized away because rdi.8!=0

//----- (000000000001E86A) ----------------------------------------------------
__int64 __fastcall ssh_packet_service_request(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  _QWORD *v11; // [rsp+28h] [rbp-18h]
  uint32_t *ssh_string; // [rsp+30h] [rbp-10h]
  void *ptr; // [rsp+38h] [rbp-8h]

  v11 = 0LL;
  ssh_string = (uint32_t *)ssh_buffer_get_ssh_string(a3);
  if ( ssh_string )
  {
    ptr = ssh_string_to_char(ssh_string);
    if ( ptr )
    {
      ssh_log(
        3,
        "ssh_packet_service_request",
        "Received a SERVICE_REQUEST for service %s",
        (__int64)ptr,
        v6,
        v7,
        a4,
        a3);
      v11 = ssh_message_new((__int64)a1);
      if ( v11 )
      {
        *((_DWORD *)v11 + 2) = 4;
        v11[28] = ptr;
      }
      else
      {
        free(ptr);
      }
    }
  }
  else
  {
    ssh_set_error(
      (__int64)a1,
      2,
      "ssh_packet_service_request",
      "Invalid SSH_MSG_SERVICE_REQUEST packet",
      v4,
      v5,
      a4,
      a3);
  }
  ssh_string_free(ssh_string);
  if ( v11 )
    ssh_message_queue(a1, (__int64)v11);
  return 1LL;
}
// 1E932: conditional instruction was optimized away because %ptr.8!=0
// 1E8D1: variable 'v4' is possibly undefined
// 1E8D1: variable 'v5' is possibly undefined
// 1E911: variable 'v6' is possibly undefined
// 1E911: variable 'v7' is possibly undefined

//----- (000000000001E997) ----------------------------------------------------
void *__fastcall ssh_msg_userauth_build_digest(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  int v6; // [rsp+24h] [rbp-1Ch]
  uint32_t *v7; // [rsp+28h] [rbp-18h] BYREF
  __int64 v8; // [rsp+30h] [rbp-10h]
  void *v9; // [rsp+38h] [rbp-8h]

  if ( *(_QWORD *)(a1 + 1232) )
    v3 = *(_QWORD *)(a1 + 1232);
  else
    v3 = *(_QWORD *)(a1 + 1240);
  v8 = v3;
  v7 = 0LL;
  v9 = ssh_buffer_new();
  if ( !v9 )
    return 0LL;
  if ( (int)ssh_pki_export_pubkey_blob(*(_QWORD *)(a2 + 40), &v7) >= 0 )
  {
    v6 = ssh_buffer_pack(
           (__int64)v9,
           "dPbsssbsS",
           10,
           *(_QWORD *)(v8 + 168),
           *(_QWORD *)(v8 + 168),
           *(_QWORD *)(v8 + 176),
           50LL,
           *(_QWORD *)(a2 + 16),
           a3,
           "publickey",
           1LL,
           *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8LL),
           v7,
           1332084403LL);
    ssh_string_free(v7);
    if ( v6 )
    {
      ssh_set_error_oom(a1, "ssh_msg_userauth_build_digest");
      ssh_buffer_free((__int64)v9);
      return 0LL;
    }
    else
    {
      return v9;
    }
  }
  else
  {
    ssh_buffer_free((__int64)v9);
    return 0LL;
  }
}

//----- (000000000001EAE4) ----------------------------------------------------
__int64 __fastcall ssh_packet_userauth_request(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 len; // rbx
  void *v11; // rax
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  char v18; // [rsp+23h] [rbp-5Dh] BYREF
  int v19; // [rsp+24h] [rbp-5Ch]
  void *ptr; // [rsp+28h] [rbp-58h] BYREF
  char *s1; // [rsp+30h] [rbp-50h] BYREF
  void *v22; // [rsp+38h] [rbp-48h] BYREF
  uint32_t *v23; // [rsp+40h] [rbp-40h] BYREF
  _QWORD *v24; // [rsp+48h] [rbp-38h]
  void *ssh_string; // [rsp+50h] [rbp-30h]
  void *v26; // [rsp+58h] [rbp-28h]
  void *v27; // [rsp+60h] [rbp-20h]
  void *v28; // [rsp+68h] [rbp-18h]

  ptr = 0LL;
  s1 = 0LL;
  v24 = ssh_message_new((__int64)a1);
  if ( !v24 )
  {
    ssh_set_error_oom((__int64)a1, "ssh_packet_userauth_request");
LABEL_28:
    if ( ptr )
    {
      free(ptr);
      ptr = 0LL;
    }
    if ( s1 )
    {
      free(s1);
      s1 = 0LL;
    }
    ssh_message_free((__int64)v24);
    return 1LL;
  }
  *((_DWORD *)v24 + 2) = 1;
  v19 = ssh_buffer_unpack(a3, "sss", 3, v24 + 2, &ptr, &s1, 1332084403LL);
  if ( v19 )
    goto LABEL_28;
  ssh_log(
    3,
    "ssh_packet_userauth_request",
    "Auth request for service %s, method %s for user '%s'",
    (__int64)ptr,
    (__int64)s1,
    v24[2],
    a4);
  if ( !strcmp(s1, "none") )
  {
    *((_DWORD *)v24 + 6) = 1;
  }
  else if ( !strcmp(s1, "password") )
  {
    *((_DWORD *)v24 + 6) = 2;
    v19 = ssh_buffer_unpack(a3, "bs", 2, &v23, v24 + 4, 1332084403LL);
    if ( v19 )
      goto LABEL_28;
  }
  else if ( !strcmp(s1, "keyboard-interactive") )
  {
    ssh_string = 0LL;
    v26 = 0LL;
    *((_DWORD *)v24 + 6) = 16;
    ssh_string = ssh_buffer_get_ssh_string(a3);
    if ( !ssh_string )
      goto LABEL_28;
    ssh_string_free(ssh_string);
    v26 = ssh_buffer_get_ssh_string(a3);
    if ( !v26 )
      goto LABEL_28;
    ssh_string_free(v26);
  }
  else if ( !strcmp(s1, "publickey") )
  {
    v22 = 0LL;
    v23 = 0LL;
    *((_DWORD *)v24 + 6) = 4;
    if ( s1 )
    {
      free(s1);
      s1 = 0LL;
    }
    v19 = ssh_buffer_unpack(a3, "bSS", 3, &v18, &v22, &v23, 1332084403LL);
    if ( v19 )
      goto LABEL_28;
    ssh_string_free(v22);
    v22 = 0LL;
    v19 = ssh_pki_import_pubkey_blob(v23, v24 + 5);
    ssh_string_free(v23);
    v23 = 0LL;
    if ( v19 < 0 )
      goto LABEL_28;
    *((_BYTE *)v24 + 48) = 0;
    if ( v18 )
    {
      v27 = 0LL;
      v28 = 0LL;
      v27 = ssh_buffer_get_ssh_string(a3);
      if ( !v27 )
      {
        ssh_log(3, "ssh_packet_userauth_request", "Invalid signature packet from peer", v4, v5, v6);
        *((_BYTE *)v24 + 48) = -1;
        goto LABEL_28;
      }
      v28 = ssh_msg_userauth_build_digest((__int64)a1, (__int64)v24, (__int64)ptr);
      if ( !v28 )
      {
        ssh_string_free(v27);
        ssh_log(3, "ssh_packet_userauth_request", "Failed to get digest", v7, v8, v9);
        *((_BYTE *)v24 + 48) = 2;
        goto LABEL_28;
      }
      len = (unsigned int)ssh_buffer_get_len((__int64)v28);
      v11 = (void *)ssh_buffer_get((__int64)v28);
      v19 = ssh_pki_signature_verify_blob((__int64)a1, (uint32_t *)v27, (_DWORD *)v24[5], v11, len);
      ssh_string_free(v27);
      ssh_buffer_free((__int64)v28);
      if ( v19 < 0 )
      {
        ssh_log(3, "ssh_packet_userauth_request", "Received an invalid  signature from peer", v12, v13, v14);
        *((_BYTE *)v24 + 48) = 2;
        goto LABEL_28;
      }
      ssh_log(3, "ssh_packet_userauth_request", "Valid signature received", v12, v13, v14);
      *((_BYTE *)v24 + 48) = 1;
    }
  }
  else
  {
    *((_DWORD *)v24 + 6) = 0;
    if ( s1 )
    {
      free(s1);
      s1 = 0LL;
    }
  }
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  if ( s1 )
  {
    free(s1);
    s1 = 0LL;
  }
  ssh_message_queue(a1, (__int64)v24);
  return 1LL;
}
// 1EE29: variable 'v4' is possibly undefined
// 1EE29: variable 'v5' is possibly undefined
// 1EE29: variable 'v6' is possibly undefined
// 1EE81: variable 'v7' is possibly undefined
// 1EE81: variable 'v8' is possibly undefined
// 1EE81: variable 'v9' is possibly undefined
// 1EF04: variable 'v12' is possibly undefined
// 1EF04: variable 'v13' is possibly undefined
// 1EF04: variable 'v14' is possibly undefined

//----- (000000000001F021) ----------------------------------------------------
__int64 __fastcall ssh_packet_userauth_info_response(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  size_t v8; // rax
  __int64 v9; // r9
  __int64 v10; // rbx
  __int64 v11; // r8
  __int64 v12; // r9
  void **v13; // rbx
  __int64 v15; // [rsp+0h] [rbp-50h]
  unsigned int nmemb; // [rsp+20h] [rbp-30h] BYREF
  unsigned int nmemb_4; // [rsp+24h] [rbp-2Ch]
  unsigned int i; // [rsp+28h] [rbp-28h]
  _QWORD *v21; // [rsp+30h] [rbp-20h]
  uint32_t *ssh_string; // [rsp+38h] [rbp-18h]

  v15 = a4;
  v21 = ssh_message_new(a1);
  if ( !v21 )
  {
    ssh_set_error_oom(a1, "ssh_packet_userauth_info_response");
LABEL_31:
    ssh_message_free((__int64)v21);
    return 1LL;
  }
  *((_DWORD *)v21 + 2) = 1;
  *((_DWORD *)v21 + 6) = 16;
  *((_BYTE *)v21 + 49) = 1;
  if ( (unsigned int)ssh_buffer_unpack(a3, "d", 1, &nmemb, 1332084403LL) )
  {
    ssh_set_error_invalid(a1, "ssh_packet_userauth_info_response", v4, v5, v6, v7);
    goto LABEL_31;
  }
  if ( *(_QWORD *)(a1 + 1272) )
  {
    if ( *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL) )
    {
      for ( i = 0; *(_DWORD *)(*(_QWORD *)(a1 + 1272) + 4LL) > i; ++i )
      {
        v8 = strlen(*(const char **)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)));
        explicit_bzero(*(void **)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)), v8);
        if ( *(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)) )
        {
          free(*(void **)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)));
          *(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)) = 0LL;
        }
      }
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL) )
      {
        free(*(void **)(*(_QWORD *)(a1 + 1272) + 40LL));
        *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL) = 0LL;
      }
      *(_DWORD *)(*(_QWORD *)(a1 + 1272) + 4LL) = 0;
    }
  }
  else
  {
    ssh_log(
      2,
      "ssh_packet_userauth_info_response",
      "Warning: Got a keyboard-interactive response but it seems we didn't send the request.",
      v5,
      v6,
      v7,
      v15);
    *(_QWORD *)(a1 + 1272) = ssh_kbdint_new();
    if ( !*(_QWORD *)(a1 + 1272) )
    {
      ssh_set_error_oom(a1, "ssh_packet_userauth_info_response");
      goto LABEL_31;
    }
  }
  ssh_log(3, "ssh_packet_userauth_info_response", "kbdint: %d answers", nmemb, v6, v7, v15);
  if ( nmemb > 0x100 )
  {
    ssh_set_error(
      a1,
      2,
      "ssh_packet_userauth_info_response",
      "Too much answers received from client: %u (0x%.4x)",
      nmemb,
      nmemb);
    ssh_kbdint_free(*(void ***)(a1 + 1272));
    *(_QWORD *)(a1 + 1272) = 0LL;
    goto LABEL_31;
  }
  if ( **(_DWORD **)(a1 + 1272) != nmemb )
    ssh_log(
      2,
      "ssh_packet_userauth_info_response",
      "Warning: Number of prompts and answers mismatch: p=%u a=%u",
      **(unsigned int **)(a1 + 1272),
      nmemb,
      v9);
  *(_DWORD *)(*(_QWORD *)(a1 + 1272) + 4LL) = nmemb;
  v10 = *(_QWORD *)(a1 + 1272);
  *(_QWORD *)(v10 + 40) = calloc(nmemb, 8uLL);
  if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL) )
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 1272) + 4LL) = 0;
    ssh_set_error_oom(a1, "ssh_packet_userauth_info_response");
    ssh_kbdint_free(*(void ***)(a1 + 1272));
    *(_QWORD *)(a1 + 1272) = 0LL;
    goto LABEL_31;
  }
  for ( nmemb_4 = 0; nmemb_4 < nmemb; ++nmemb_4 )
  {
    ssh_string = (uint32_t *)ssh_buffer_get_ssh_string(a3);
    if ( !ssh_string )
    {
      ssh_set_error(a1, 2, "ssh_packet_userauth_info_response", "Short INFO_RESPONSE packet", v11, v12);
      *(_DWORD *)(*(_QWORD *)(a1 + 1272) + 4LL) = nmemb_4;
      ssh_kbdint_free(*(void ***)(a1 + 1272));
      *(_QWORD *)(a1 + 1272) = 0LL;
      goto LABEL_31;
    }
    v13 = (void **)(*(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL) + 8LL * nmemb_4);
    *v13 = ssh_string_to_char(ssh_string);
    ssh_string_free(ssh_string);
    if ( !*(_QWORD *)(8LL * nmemb_4 + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)) )
    {
      ssh_set_error_oom(a1, "ssh_packet_userauth_info_response");
      *(_DWORD *)(*(_QWORD *)(a1 + 1272) + 4LL) = nmemb_4;
      ssh_kbdint_free(*(void ***)(a1 + 1272));
      *(_QWORD *)(a1 + 1272) = 0LL;
      goto LABEL_31;
    }
  }
  ssh_message_queue((__int64 *)a1, (__int64)v21);
  return 1LL;
}
// 1F0D1: variable 'v4' is possibly undefined
// 1F0D1: variable 'v5' is possibly undefined
// 1F0D1: variable 'v6' is possibly undefined
// 1F0D1: variable 'v7' is possibly undefined
// 1F2A6: variable 'v15' is possibly undefined
// 1F34D: variable 'v9' is possibly undefined
// 1F426: variable 'v11' is possibly undefined
// 1F426: variable 'v12' is possibly undefined

//----- (000000000001F543) ----------------------------------------------------
__int64 __fastcall ssh_packet_channel_open(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  int v11; // [rsp+24h] [rbp-1Ch] BYREF
  int v12; // [rsp+28h] [rbp-18h] BYREF
  int v13; // [rsp+2Ch] [rbp-14h]
  char *s1; // [rsp+30h] [rbp-10h] BYREF
  _QWORD *v15; // [rsp+38h] [rbp-8h]

  s1 = 0LL;
  v15 = ssh_message_new(a1);
  if ( !v15 )
  {
    ssh_set_error_oom(a1, "ssh_packet_channel_open");
LABEL_21:
    ssh_message_free((__int64)v15);
    v15 = 0LL;
    goto LABEL_22;
  }
  *((_DWORD *)v15 + 2) = 2;
  v13 = ssh_buffer_unpack(a3, "s", 1, &s1, 1332084403LL);
  if ( v13 )
    goto LABEL_21;
  ssh_log(3, "ssh_packet_channel_open", "Clients wants to open a %s channel", (__int64)s1, v4, v5, a4);
  ssh_buffer_unpack(a3, "ddd", 3, (char *)v15 + 60, v15 + 8, (char *)v15 + 68, 1332084403LL);
  if ( *(_DWORD *)(a1 + 1164) != 8 )
  {
    ssh_set_error(
      a1,
      2,
      "ssh_packet_channel_open",
      "Invalid state when receiving channel open request (must be authenticated)",
      v6,
      v7);
    goto LABEL_21;
  }
  if ( !strcmp(s1, "session") )
  {
    *((_DWORD *)v15 + 14) = 1;
    if ( s1 )
    {
      free(s1);
      s1 = 0LL;
    }
  }
  else
  {
    if ( !strcmp(s1, "direct-tcpip") )
    {
      v13 = ssh_buffer_unpack(a3, "sdsd", 4, v15 + 11, &v12, v15 + 9, &v11, 1332084403LL);
      if ( !v13 )
      {
        *((_WORD *)v15 + 48) = v12;
        *((_WORD *)v15 + 40) = v11;
        *((_DWORD *)v15 + 14) = 2;
        goto LABEL_22;
      }
      goto LABEL_21;
    }
    if ( !strcmp(s1, "forwarded-tcpip") )
    {
      v13 = ssh_buffer_unpack(a3, "sdsd", 4, v15 + 11, &v12, v15 + 9, &v11, 1332084403LL);
      if ( !v13 )
      {
        *((_WORD *)v15 + 48) = v12;
        *((_WORD *)v15 + 40) = v11;
        *((_DWORD *)v15 + 14) = 3;
        goto LABEL_22;
      }
      goto LABEL_21;
    }
    if ( !strcmp(s1, "x11") )
    {
      v13 = ssh_buffer_unpack(a3, "sd", 2, v15 + 9, &v11, 1332084403LL);
      if ( !v13 )
      {
        *((_WORD *)v15 + 40) = v11;
        *((_DWORD *)v15 + 14) = 4;
        goto LABEL_22;
      }
      goto LABEL_21;
    }
    if ( !strcmp(s1, "auth-agent@openssh.com") )
      *((_DWORD *)v15 + 14) = 5;
    else
      *((_DWORD *)v15 + 14) = 0;
  }
LABEL_22:
  if ( s1 )
  {
    free(s1);
    s1 = 0LL;
  }
  if ( v15 )
    ssh_message_queue((__int64 *)a1, (__int64)v15);
  return 1LL;
}
// 1F5FC: variable 'v4' is possibly undefined
// 1F5FC: variable 'v5' is possibly undefined
// 1F67A: variable 'v6' is possibly undefined
// 1F67A: variable 'v7' is possibly undefined

//----- (000000000001F8F1) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_open_reply_accept_channel(__int64 a1, _DWORD *a2)
{
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v5 = *(_QWORD *)a1;
  a2[2] = ssh_channel_new_id(*(_QWORD *)a1);
  a2[5] = 35000;
  a2[3] = 32000;
  a2[6] = *(_DWORD *)(a1 + 60);
  a2[9] = *(_DWORD *)(a1 + 68);
  a2[7] = *(_DWORD *)(a1 + 64);
  a2[10] = 3;
  a2[12] &= ~4u;
  if ( (unsigned int)ssh_buffer_pack(
                       *(_QWORD *)(v5 + 1152),
                       "bdddd",
                       5,
                       91LL,
                       (unsigned int)a2[6],
                       (unsigned int)a2[2],
                       (unsigned int)a2[3],
                       (unsigned int)a2[5],
                       1332084403LL) )
  {
    ssh_set_error_oom(v5, "ssh_message_channel_request_open_reply_accept_channel");
    return 0xFFFFFFFFLL;
  }
  else
  {
    ssh_log(
      3,
      "ssh_message_channel_request_open_reply_accept_channel",
      "Accepting a channel request_open for chan %d",
      (unsigned int)a2[6],
      v3,
      v4);
    return (unsigned int)ssh_packet_send(v5);
  }
}
// 1FA2E: variable 'v3' is possibly undefined
// 1FA2E: variable 'v4' is possibly undefined

//----- (000000000001FA47) ----------------------------------------------------
__int64 *__fastcall ssh_message_channel_request_open_reply_accept(__int64 *a1)
{
  __int64 *v2; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  v2 = ssh_channel_new(*a1);
  if ( !v2 )
    return 0LL;
  if ( (int)ssh_message_channel_request_open_reply_accept_channel((__int64)a1, v2) < 0 )
  {
    ssh_channel_free(v2);
    return 0LL;
  }
  return v2;
}

//----- (000000000001FAB8) ----------------------------------------------------
__int64 __fastcall ssh_message_handle_channel_request(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        const char *a4,
        unsigned __int8 a5)
{
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  _QWORD *v14; // [rsp+38h] [rbp-8h]

  v14 = ssh_message_new((__int64)a1);
  if ( v14 )
  {
    ssh_log(
      3,
      "ssh_message_handle_channel_request",
      "Received a %s channel_request for channel (%d:%d) (want_reply=%hhd)",
      (__int64)a4,
      *(unsigned int *)(a2 + 8),
      *(unsigned int *)(a2 + 24),
      a5);
    *((_DWORD *)v14 + 2) = 3;
    v14[14] = a2;
    *((_BYTE *)v14 + 120) = a5;
    if ( !strcmp(a4, "pty-req") )
    {
      v5 = ssh_buffer_unpack(
             a3,
             "sddddS",
             6,
             v14 + 16,
             v14 + 17,
             (char *)v14 + 140,
             v14 + 18,
             (char *)v14 + 148,
             v14 + 19,
             1332084403LL);
      *((_DWORD *)v14 + 26) = 1;
      if ( v5 )
        goto LABEL_25;
    }
    else if ( !strcmp(a4, "window-change") )
    {
      *((_DWORD *)v14 + 26) = 6;
      if ( (unsigned int)ssh_buffer_unpack(
                           a3,
                           "dddd",
                           4,
                           v14 + 17,
                           (char *)v14 + 140,
                           v14 + 18,
                           (char *)v14 + 148,
                           1332084403LL) )
        goto LABEL_25;
    }
    else if ( !strcmp(a4, "subsystem") )
    {
      v6 = ssh_buffer_unpack(a3, "s", 1, v14 + 23, 1332084403LL);
      *((_DWORD *)v14 + 26) = 5;
      if ( v6 )
        goto LABEL_25;
    }
    else if ( !strcmp(a4, "shell") )
    {
      *((_DWORD *)v14 + 26) = 3;
    }
    else if ( !strcmp(a4, "exec") )
    {
      v7 = ssh_buffer_unpack(a3, "s", 1, v14 + 22, 1332084403LL);
      *((_DWORD *)v14 + 26) = 2;
      if ( v7 )
        goto LABEL_25;
    }
    else if ( !strcmp(a4, "env") )
    {
      v8 = ssh_buffer_unpack(a3, "ss", 2, v14 + 20, v14 + 21, 1332084403LL);
      *((_DWORD *)v14 + 26) = 4;
      if ( v8 )
        goto LABEL_25;
    }
    else if ( !strcmp(a4, "x11-req") )
    {
      v9 = ssh_buffer_unpack(a3, "bssd", 4, v14 + 24, v14 + 25, v14 + 26, v14 + 27, 1332084403LL);
      *((_DWORD *)v14 + 26) = 7;
      if ( v9 )
        goto LABEL_25;
    }
    else
    {
      *((_DWORD *)v14 + 26) = 0;
    }
    ssh_message_queue(a1, (__int64)v14);
    return 0LL;
  }
  ssh_set_error_oom((__int64)a1, "ssh_message_handle_channel_request");
LABEL_25:
  ssh_message_free((__int64)v14);
  return 0xFFFFFFFFLL;
}

//----- (000000000001FEE1) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_reply_success(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned int v7; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_BYTE *)(a1 + 120) )
  {
    v7 = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 24LL);
    ssh_log(
      3,
      "ssh_message_channel_request_reply_success",
      "Sending a channel_request success to channel %d",
      v7,
      a5,
      a6);
    if ( (unsigned int)ssh_buffer_pack(*(_QWORD *)(*(_QWORD *)a1 + 1152LL), "bd", 2, 99LL, v7, 1332084403LL) )
    {
      ssh_set_error_oom(*(_QWORD *)a1, "ssh_message_channel_request_reply_success");
      return 0xFFFFFFFFLL;
    }
    else
    {
      return ssh_packet_send(*(_QWORD *)a1);
    }
  }
  else
  {
    ssh_log(
      3,
      "ssh_message_channel_request_reply_success",
      "The client doesn't want to know the request succeeded",
      a4,
      a5,
      a6);
    return 0LL;
  }
}

//----- (000000000001FFD1) ----------------------------------------------------
__int64 __fastcall ssh_packet_global_request(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  _QWORD *v12; // rdx
  unsigned __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned __int8 v17; // [rsp+27h] [rbp-19h] BYREF
  unsigned int v18; // [rsp+28h] [rbp-18h]
  int v19; // [rsp+2Ch] [rbp-14h]
  char *s1; // [rsp+30h] [rbp-10h] BYREF
  void *ptr; // [rsp+38h] [rbp-8h]

  ptr = 0LL;
  s1 = 0LL;
  v18 = 1;
  ssh_log(2, "ssh_packet_global_request", "Received SSH_MSG_GLOBAL_REQUEST packet", a4, a5, a6, a4);
  v19 = ssh_buffer_unpack(a3, "sb", 2, &s1, &v17, 1332084403LL);
  if ( v19 )
    goto LABEL_33;
  ptr = ssh_message_new((__int64)a1);
  if ( !ptr )
  {
    ssh_set_error_oom((__int64)a1, "ssh_packet_global_request");
LABEL_33:
    if ( ptr )
    {
      free(ptr);
      ptr = 0LL;
    }
    if ( s1 )
    {
      free(s1);
      s1 = 0LL;
    }
    ssh_log(1, "ssh_packet_global_request", "Invalid SSH_MSG_GLOBAL_REQUEST packet", v6, v7, v8);
    return 2LL;
  }
  *((_DWORD *)ptr + 2) = 5;
  if ( strcmp(s1, "tcpip-forward") )
  {
    if ( !strcmp(s1, "cancel-tcpip-forward") )
    {
      v19 = ssh_buffer_unpack(a3, "sd", 2, (char *)ptr + 240, (char *)ptr + 248, 1332084403LL);
      if ( v19 )
        goto LABEL_33;
      *((_DWORD *)ptr + 58) = 2;
      *((_BYTE *)ptr + 236) = v17;
      ssh_log(
        2,
        "ssh_packet_global_request",
        "Received SSH_MSG_GLOBAL_REQUEST %s %d %s:%d",
        (__int64)s1,
        v17,
        *((_QWORD *)ptr + 30),
        *((unsigned __int16 *)ptr + 124));
      if ( !a1[129] || a1[129] + 40 >= (unsigned __int64)(a1[129] + *(_QWORD *)a1[129]) || !*(_QWORD *)(a1[129] + 40) )
      {
        if ( s1 )
        {
          free(s1);
          s1 = 0LL;
        }
        goto LABEL_12;
      }
    }
    else
    {
      if ( strcmp(s1, "keepalive@openssh.com") )
      {
        ssh_log(2, "ssh_packet_global_request", "UNKNOWN SSH_MSG_GLOBAL_REQUEST %s %d", (__int64)s1, v17, v11);
        v18 = 2;
        goto LABEL_28;
      }
      *((_DWORD *)ptr + 58) = 3;
      *((_BYTE *)ptr + 236) = v17;
      ssh_log(2, "ssh_packet_global_request", "Received keepalive@openssh.com %d", v17, v10, v11);
      if ( !a1[129]
        || (v13 = a1[129] + 40, v12 = (_QWORD *)a1[129], v13 >= (unsigned __int64)v12 + *v12)
        || !*(_QWORD *)(a1[129] + 40) )
      {
        ssh_message_global_request_reply_success((__int64)ptr, 0, (__int64)v12, v13, v14, v15);
        goto LABEL_28;
      }
    }
    (*(void (__fastcall **)(__int64 *, void *, _QWORD))(a1[129] + 40))(a1, ptr, *(_QWORD *)(a1[129] + 8));
    goto LABEL_28;
  }
  v19 = ssh_buffer_unpack(a3, "sd", 2, (char *)ptr + 240, (char *)ptr + 248, 1332084403LL);
  if ( v19 )
    goto LABEL_33;
  *((_DWORD *)ptr + 58) = 1;
  *((_BYTE *)ptr + 236) = v17;
  ssh_log(
    2,
    "ssh_packet_global_request",
    "Received SSH_MSG_GLOBAL_REQUEST %s %d %s:%d",
    (__int64)s1,
    v17,
    *((_QWORD *)ptr + 30),
    *((unsigned __int16 *)ptr + 124));
  if ( !a1[129] || a1[129] + 40 >= (unsigned __int64)(a1[129] + *(_QWORD *)a1[129]) || !*(_QWORD *)(a1[129] + 40) )
  {
    if ( s1 )
    {
      free(s1);
      s1 = 0LL;
    }
LABEL_12:
    ssh_message_queue(a1, (__int64)ptr);
    return v18;
  }
  ssh_log(
    2,
    "ssh_packet_global_request",
    "Calling callback for SSH_MSG_GLOBAL_REQUEST %s %d %s:%d",
    (__int64)s1,
    v17,
    *((_QWORD *)ptr + 30),
    *((unsigned __int16 *)ptr + 124));
  (*(void (__fastcall **)(__int64 *, void *, _QWORD))(a1[129] + 40))(a1, ptr, *(_QWORD *)(a1[129] + 8));
LABEL_28:
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  if ( s1 )
  {
    free(s1);
    s1 = 0LL;
  }
  return v18;
}
// 20471: variable 'v10' is possibly undefined
// 20471: variable 'v11' is possibly undefined
// 20503: variable 'v12' is possibly undefined
// 20503: variable 'v13' is possibly undefined
// 20503: variable 'v14' is possibly undefined
// 20503: variable 'v15' is possibly undefined
// 205D3: variable 'v6' is possibly undefined
// 205D3: variable 'v7' is possibly undefined
// 205D3: variable 'v8' is possibly undefined

//----- (00000000000205DF) ----------------------------------------------------
char *ssh_get_user_home_dir()
{
  __uid_t v0; // eax
  struct passwd *result; // [rsp+10h] [rbp-450h] BYREF
  char *v3; // [rsp+18h] [rbp-448h]
  struct passwd resultbuf; // [rsp+20h] [rbp-440h] BYREF
  char buffer[1032]; // [rsp+50h] [rbp-410h] BYREF
  unsigned __int64 v6; // [rsp+458h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v3 = 0LL;
  v0 = getuid();
  if ( !getpwuid_r(v0, &resultbuf, buffer, 0x400uLL, &result) )
    return strdup(resultbuf.pw_dir);
  v3 = getenv("HOME");
  if ( !v3 )
    return 0LL;
  memset(buffer, 0, 0x400uLL);
  snprintf(buffer, 0x400uLL, "%s", v3);
  return strdup(buffer);
}

//----- (00000000000206EA) ----------------------------------------------------
_BOOL8 __fastcall ssh_file_readaccess_ok(const char *a1)
{
  return access(a1, 4) >= 0;
}

//----- (0000000000020719) ----------------------------------------------------
char *ssh_get_local_username()
{
  __uid_t v0; // eax
  struct passwd *result; // [rsp+10h] [rbp-450h] BYREF
  char *v3; // [rsp+18h] [rbp-448h]
  struct passwd resultbuf; // [rsp+20h] [rbp-440h] BYREF
  char buffer[1032]; // [rsp+50h] [rbp-410h] BYREF
  unsigned __int64 v6; // [rsp+458h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v0 = getuid();
  if ( getpwuid_r(v0, &resultbuf, buffer, 0x400uLL, &result) )
    return 0LL;
  v3 = strdup(resultbuf.pw_name);
  if ( v3 )
    return v3;
  else
    return 0LL;
}
// 20719: using guessed type char buffer[1032];

//----- (00000000000207B9) ----------------------------------------------------
_BOOL8 __fastcall ssh_is_ipaddr_v4(const char *a1)
{
  char buf[4]; // [rsp+18h] [rbp-8h] BYREF
  int v3; // [rsp+1Ch] [rbp-4h]

  v3 = -1;
  return inet_pton(2, a1, buf) > 0;
}
// 207B9: using guessed type char buf[4];

//----- (00000000000207F8) ----------------------------------------------------
_BOOL8 __fastcall ssh_is_ipaddr(const char *a1)
{
  char buf[24]; // [rsp+20h] [rbp-20h] BYREF
  unsigned __int64 v3; // [rsp+38h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  return strchr(a1, 58) && inet_pton(10, a1, buf) > 0 || ssh_is_ipaddr_v4(a1);
}
// 207F8: using guessed type char buf[24];

//----- (0000000000020877) ----------------------------------------------------
char *__fastcall ssh_lowercase(const char *a1)
{
  char *i; // [rsp+10h] [rbp-10h]
  char *v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  v3 = strdup(a1);
  if ( !v3 )
    return 0LL;
  for ( i = v3; *i; ++i )
    *i = tolower(*i);
  return v3;
}

//----- (00000000000208E8) ----------------------------------------------------
char *__fastcall ssh_hostport(const char *a1, unsigned int a2)
{
  size_t size; // [rsp+10h] [rbp-10h]
  char *v4; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  size = strlen(a1) + 9;
  v4 = (char *)malloc(size);
  if ( !v4 )
    return 0LL;
  snprintf(v4, size, "[%s]:%d", a1, a2);
  return v4;
}

//----- (0000000000020966) ----------------------------------------------------
const char *__fastcall ssh_version(int a1)
{
  if ( a1 > 2049 )
    return 0LL;
  else
    return "0.8.1/gnutls/zlib";
}

//----- (0000000000020986) ----------------------------------------------------
_QWORD *ssh_list_new()
{
  _QWORD *v1; // [rsp+8h] [rbp-8h]

  v1 = malloc(0x10uLL);
  if ( !v1 )
    return 0LL;
  v1[1] = 0LL;
  *v1 = v1[1];
  return v1;
}

//----- (00000000000209CB) ----------------------------------------------------
void __fastcall ssh_list_free(_QWORD **a1)
{
  _QWORD *ptr; // [rsp+10h] [rbp-10h]
  _QWORD *v2; // [rsp+18h] [rbp-8h]

  if ( a1 )
  {
    for ( ptr = *a1; ptr; ptr = v2 )
    {
      v2 = (_QWORD *)*ptr;
      free(ptr);
    }
    free(a1);
  }
}
// 20A25: conditional instruction was optimized away because rdi.8!=0

//----- (0000000000020A40) ----------------------------------------------------
__int64 __fastcall ssh_list_get_iterator(__int64 a1)
{
  if ( a1 )
    return *(_QWORD *)a1;
  else
    return 0LL;
}

//----- (0000000000020A5F) ----------------------------------------------------
_QWORD *__fastcall ssh_list_find(__int64 a1, __int64 a2)
{
  _QWORD *i; // [rsp+18h] [rbp-8h]

  for ( i = (_QWORD *)ssh_list_get_iterator(a1); i; i = (_QWORD *)*i )
  {
    if ( i[1] == a2 )
      return i;
  }
  return 0LL;
}

//----- (0000000000020AAE) ----------------------------------------------------
__int64 __fastcall ssh_list_count(__int64 a1)
{
  int v2; // [rsp+14h] [rbp-Ch]
  _QWORD *i; // [rsp+18h] [rbp-8h]

  v2 = 0;
  for ( i = (_QWORD *)ssh_list_get_iterator(a1); i; i = (_QWORD *)*i )
    ++v2;
  return v2;
}

//----- (0000000000020AF8) ----------------------------------------------------
_QWORD *__fastcall ssh_iterator_new(__int64 a1)
{
  _QWORD *v2; // [rsp+18h] [rbp-8h]

  v2 = malloc(0x10uLL);
  if ( !v2 )
    return 0LL;
  *v2 = 0LL;
  v2[1] = a1;
  return v2;
}

//----- (0000000000020B3D) ----------------------------------------------------
__int64 __fastcall ssh_list_append(__int64 a1, __int64 a2)
{
  _QWORD *v3; // [rsp+18h] [rbp-8h]

  v3 = ssh_iterator_new(a2);
  if ( !v3 )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 8) )
  {
    **(_QWORD **)(a1 + 8) = v3;
    *(_QWORD *)(a1 + 8) = v3;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = v3;
    *(_QWORD *)a1 = *(_QWORD *)(a1 + 8);
  }
  return 0LL;
}

//----- (0000000000020BB7) ----------------------------------------------------
__int64 __fastcall ssh_list_prepend(_QWORD *a1, __int64 a2)
{
  _QWORD *v3; // [rsp+18h] [rbp-8h]

  v3 = ssh_iterator_new(a2);
  if ( !v3 )
    return 0xFFFFFFFFLL;
  if ( a1[1] )
  {
    *v3 = *a1;
    *a1 = v3;
  }
  else
  {
    a1[1] = v3;
    *a1 = a1[1];
  }
  return 0LL;
}

//----- (0000000000020C2F) ----------------------------------------------------
void __fastcall ssh_list_remove(__int64 a1, _QWORD *a2)
{
  _QWORD *i; // [rsp+10h] [rbp-10h]
  _QWORD *v3; // [rsp+18h] [rbp-8h]

  v3 = 0LL;
  for ( i = *(_QWORD **)a1; i && i != a2; i = (_QWORD *)*i )
    v3 = i;
  if ( i )
  {
    if ( v3 )
      *v3 = *i;
    if ( *(_QWORD **)a1 == a2 )
      *(_QWORD *)a1 = *a2;
    if ( *(_QWORD **)(a1 + 8) == a2 )
      *(_QWORD *)(a1 + 8) = v3;
    if ( a2 )
      free(a2);
  }
}

//----- (0000000000020CE9) ----------------------------------------------------
__int64 __fastcall ssh_list_pop_head(__int64 a1)
{
  _QWORD *ptr; // [rsp+10h] [rbp-10h]
  __int64 v3; // [rsp+18h] [rbp-8h]

  ptr = *(_QWORD **)a1;
  if ( !*(_QWORD *)a1 )
    return 0LL;
  v3 = ptr[1];
  *(_QWORD *)a1 = *ptr;
  if ( *(_QWORD **)(a1 + 8) == ptr )
    *(_QWORD *)(a1 + 8) = 0LL;
  if ( ptr )
    free(ptr);
  return v3;
}

//----- (0000000000020D68) ----------------------------------------------------
char *__fastcall ssh_dirname(const char *a1)
{
  size_t n; // [rsp+10h] [rbp-10h]
  char *dest; // [rsp+18h] [rbp-8h]

  if ( !a1 || !*a1 )
    return strdup(".");
  for ( n = strlen(a1); n && a1[n - 1] == 47; --n )
    ;
  if ( !n )
    return strdup("/");
  while ( n && a1[n - 1] != 47 )
    --n;
  if ( !n )
    return strdup(".");
  if ( n == 1 )
    return strdup("/");
  while ( n && a1[n - 1] == 47 )
    --n;
  dest = (char *)malloc(n + 1);
  if ( !dest )
    return 0LL;
  strncpy(dest, a1, n);
  dest[n] = 0;
  return dest;
}

//----- (0000000000020EA9) ----------------------------------------------------
char *__fastcall ssh_basename(const char *a1)
{
  size_t n; // [rsp+18h] [rbp-18h]
  size_t na; // [rsp+18h] [rbp-18h]
  char *dest; // [rsp+20h] [rbp-10h]
  char *src; // [rsp+28h] [rbp-8h]

  if ( !a1 || !*a1 )
    return strdup(".");
  for ( n = strlen(a1); n && a1[n - 1] == 47; --n )
    ;
  if ( !n )
    return strdup("/");
  while ( n && a1[n - 1] != 47 )
    --n;
  if ( !n )
    return strdup(a1);
  src = (char *)&a1[n];
  for ( na = strlen(&a1[n]); na && src[na - 1] == 47; --na )
    ;
  dest = (char *)malloc(na + 1);
  if ( !dest )
    return 0LL;
  strncpy(dest, src, na);
  dest[na] = 0;
  return dest;
}

//----- (0000000000020FF5) ----------------------------------------------------
__int64 __fastcall ssh_mkdir(const char *a1, __mode_t a2)
{
  return (unsigned int)mkdir(a1, a2);
}

//----- (000000000002101D) ----------------------------------------------------
char *__fastcall ssh_path_expand_tilde(const char *a1)
{
  char *s; // [rsp+8h] [rbp-D8h]
  char *user_home_dir; // [rsp+18h] [rbp-C8h]
  const char *v4; // [rsp+20h] [rbp-C0h]
  size_t v5; // [rsp+28h] [rbp-B8h]
  size_t v6; // [rsp+30h] [rbp-B0h]
  size_t n; // [rsp+38h] [rbp-A8h]
  struct passwd *v8; // [rsp+40h] [rbp-A0h]
  void *v9; // [rsp+48h] [rbp-98h]
  char dest[136]; // [rsp+50h] [rbp-90h] BYREF
  unsigned __int64 v11; // [rsp+D8h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  if ( *a1 != 126 )
    return strdup(a1);
  s = (char *)(a1 + 1);
  v4 = strchr(a1 + 1, 47);
  if ( v4 && v4 > s )
  {
    n = v4 - s;
    if ( (unsigned __int64)(v4 - s) > 0x7F )
      return 0LL;
    memcpy(dest, s, n);
    dest[n] = 0;
    v8 = getpwnam(dest);
    if ( !v8 )
      return 0LL;
    v5 = strlen(v4);
    user_home_dir = strdup(v8->pw_dir);
  }
  else
  {
    v5 = strlen(s);
    v4 = a1 + 1;
    user_home_dir = ssh_get_user_home_dir();
  }
  if ( !user_home_dir )
    return 0LL;
  v6 = strlen(user_home_dir);
  v9 = malloc(v5 + v6 + 1);
  if ( v9 )
  {
    if ( v6 )
      memcpy(v9, user_home_dir, v6);
    free(user_home_dir);
    memcpy((char *)v9 + v6, v4, v5 + 1);
    return (char *)v9;
  }
  else
  {
    free(user_home_dir);
    return 0LL;
  }
}
// 2120A: conditional instruction was optimized away because %var_C8.8!=0
// 21262: conditional instruction was optimized away because %var_C8.8!=0
// 2101D: using guessed type char dest[136];

//----- (00000000000212C9) ----------------------------------------------------
char *__fastcall ssh_path_expand_escape(__int64 a1, const char *a2)
{
  __int64 v3; // r8
  __int64 v4; // r9
  size_t v5; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  char v8[6]; // [rsp+12h] [rbp-144Eh] BYREF
  char *src; // [rsp+18h] [rbp-1448h]
  char *v10; // [rsp+20h] [rbp-1440h]
  unsigned __int64 v11; // [rsp+28h] [rbp-1438h]
  char *s; // [rsp+30h] [rbp-1430h]
  size_t v13; // [rsp+38h] [rbp-1428h]
  char name[1040]; // [rsp+40h] [rbp-1420h] BYREF
  char v15[4104]; // [rsp+450h] [rbp-1010h] BYREF
  unsigned __int64 v16; // [rsp+1458h] [rbp-8h]

  v16 = __readfsqword(0x28u);
  src = 0LL;
  s = ssh_path_expand_tilde(a2);
  if ( !s )
  {
    ssh_set_error_oom(a1, "ssh_path_expand_escape");
    return 0LL;
  }
  if ( strlen(s) > 0x1000 )
  {
    ssh_set_error(a1, 2, "ssh_path_expand_escape", "string to expand too long", v3, v4, a2);
    free(s);
    return 0LL;
  }
  v10 = s;
  v15[0] = 0;
  v11 = 0LL;
  while ( *v10 )
  {
    if ( *v10 == 37 )
    {
      if ( !*++v10 )
        break;
      switch ( *v10 )
      {
        case 'd':
          src = strdup(*(const char **)(a1 + 1496));
          goto LABEL_21;
        case 'h':
          src = strdup(*(const char **)(a1 + 1480));
          goto LABEL_21;
        case 'l':
          if ( gethostname(name, 0LL) )
            src = strdup(name);
          goto LABEL_21;
        case 'p':
          if ( *(_DWORD *)(a1 + 1632) <= 0xFFFFu )
          {
            snprintf(v8, 6uLL, "%u", *(unsigned int *)(a1 + 1632));
            src = strdup(v8);
          }
          goto LABEL_21;
        case 'r':
          src = strdup(*(const char **)(a1 + 1472));
          goto LABEL_21;
        case 'u':
          src = ssh_get_local_username();
LABEL_21:
          if ( !src )
          {
            ssh_set_error_oom(a1, "ssh_path_expand_escape");
            free(s);
            return 0LL;
          }
          v5 = strlen(src);
          v11 += v5;
          if ( v11 > 0xFFF )
          {
            ssh_set_error(a1, 2, "ssh_path_expand_escape", "String too long", v6, v7, a2);
            free(src);
            free(s);
            return 0LL;
          }
          v13 = strlen(v15);
          strncpy(&v15[v13], src, 4095 - v13);
          v15[v11] = 0;
          if ( src )
          {
            free(src);
            src = 0LL;
          }
          break;
        default:
          ssh_set_error(a1, 2, "ssh_path_expand_escape", "Wrong escape sequence detected", v3, v4, a2);
          free(s);
          return 0LL;
      }
    }
    else
    {
      v15[v11++] = *v10;
      if ( v11 > 0xFFF )
      {
        free(s);
        return 0LL;
      }
      v15[v11] = 0;
    }
    ++v10;
  }
  free(s);
  return strdup(v15);
}
// 21375: variable 'v3' is possibly undefined
// 21375: variable 'v4' is possibly undefined
// 2164F: variable 'v6' is possibly undefined
// 2164F: variable 'v7' is possibly undefined
// 212C9: using guessed type char var_1010[4104];

//----- (000000000002174D) ----------------------------------------------------
__int64 __fastcall ssh_analyze_banner(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r9
  __int64 v8; // r8
  int v9; // eax
  char *endptr; // [rsp+18h] [rbp-28h] BYREF
  char *s; // [rsp+20h] [rbp-20h]
  char *v12; // [rsp+28h] [rbp-18h]
  unsigned __int64 v13; // [rsp+30h] [rbp-10h]
  unsigned __int64 v14; // [rsp+38h] [rbp-8h]

  if ( a2 )
    s = *(char **)(a1 + 1064);
  else
    s = *(char **)(a1 + 1056);
  if ( !s )
  {
    ssh_set_error(a1, 2, "ssh_analyze_banner", "Invalid banner", a5, a6);
    return 0xFFFFFFFFLL;
  }
  if ( strlen(s) <= 5 || strncmp(s, "SSH-", 4uLL) )
    goto LABEL_8;
  ssh_log(1, "ssh_analyze_banner", "Analyzing banner: %s", (__int64)s, v8, v7);
  v9 = s[4];
  if ( v9 == 49 )
  {
    if ( strlen(s) <= 6 || s[6] != 57 )
      goto LABEL_8;
  }
  else if ( v9 != 50 )
  {
LABEL_8:
    ssh_set_error(a1, 2, "ssh_analyze_banner", "Protocol mismatch: %s", (__int64)s, v7);
    return 0xFFFFFFFFLL;
  }
  v12 = strstr(s, "OpenSSH");
  if ( v12 )
  {
    endptr = 0LL;
    v13 = 0LL;
    v14 = 0LL;
    if ( strlen(v12) > 9 )
    {
      v13 = strtoul(v12 + 8, &endptr, 10);
      if ( v12 + 8 != endptr && (*__errno_location() != 34 || v13 != -1LL) && (!*__errno_location() || v13) )
      {
        if ( v13 )
        {
          if ( v13 <= 0x64 )
          {
            v14 = strtoul(v12 + 10, &endptr, 10);
            if ( v12 + 10 != endptr
              && (*__errno_location() != 34 || v13 != -1LL)
              && (!*__errno_location() || v13)
              && v14 <= 0x64 )
            {
              *(_DWORD *)(a1 + 1084) = ((_DWORD)v14 << 8) | ((_DWORD)v13 << 16);
              ssh_log(
                1,
                "ssh_analyze_banner",
                "We are talking to an OpenSSH client version: %lu.%lu (%x)",
                v13,
                v14,
                *(unsigned int *)(a1 + 1084));
            }
          }
        }
      }
    }
  }
  return 0LL;
}
// 2180B: variable 'v7' is possibly undefined
// 21839: variable 'v8' is possibly undefined

//----- (0000000000021A36) ----------------------------------------------------
__time_t *__fastcall ssh_timestamp_init(__time_t *a1)
{
  __time_t *result; // rax
  struct timespec tp; // [rsp+10h] [rbp-10h] BYREF

  clock_gettime(1, &tp);
  a1[1] = tp.tv_nsec / 1000;
  result = a1;
  *a1 = tp.tv_sec;
  return result;
}

//----- (0000000000021A8B) ----------------------------------------------------
__int64 __fastcall ssh_timestamp_difference(_QWORD *a1, _QWORD *a2)
{
  __int64 v3; // [rsp+18h] [rbp-18h]
  __int64 v4; // [rsp+20h] [rbp-10h]

  v3 = *a2 - *a1;
  v4 = a2[1] - a1[1];
  if ( v4 < 0 )
  {
    --v3;
    v4 += 1000000LL;
  }
  return 1000 * v3 + v4 / 1000;
}

//----- (0000000000021B1A) ----------------------------------------------------
__int64 __fastcall ssh_make_milliseconds(int a1, __int64 a2)
{
  __int64 v2; // rax
  unsigned int v4; // [rsp+1Ch] [rbp-4h]

  if ( a2 )
    v2 = a2 / 1000;
  else
    LODWORD(v2) = 0;
  v4 = 1000 * a1 + v2;
  if ( !v4 )
    return 10000;
  return v4;
}

//----- (0000000000021B80) ----------------------------------------------------
_BOOL8 __fastcall ssh_timeout_elapsed(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __time_t v7[2]; // [rsp+10h] [rbp-10h] BYREF

  switch ( a2 )
  {
    case -1:
      return 0LL;
    case 0:
      return 1LL;
    case -2:
      ssh_log(
        1,
        "ssh_timeout_elapsed",
        "ssh_timeout_elapsed called with -2. this needs to be fixed. please set a breakpoint on %s:%d and fix the caller\n",
        (__int64)"/usr/src/src/misc.c",
        1006LL,
        a6);
      return 0LL;
    default:
      ssh_timestamp_init(v7);
      return (int)ssh_timestamp_difference(a1, v7) >= a2;
  }
}
// 21B80: using guessed type __time_t var_10[2];

//----- (0000000000021C0A) ----------------------------------------------------
__int64 __fastcall ssh_timeout_update(_QWORD *a1, int a2)
{
  __int64 result; // rax
  int v3; // [rsp+18h] [rbp-18h]
  __time_t v4[2]; // [rsp+20h] [rbp-10h] BYREF

  if ( a2 <= 0 )
    return (unsigned int)a2;
  ssh_timestamp_init(v4);
  v3 = ssh_timestamp_difference(a1, v4);
  if ( v3 < 0 )
    v3 = 0;
  result = 0LL;
  if ( a2 - v3 >= 0 )
    return (unsigned int)(a2 - v3);
  return result;
}
// 21C0A: using guessed type __time_t var_10[2];

//----- (0000000000021C6B) ----------------------------------------------------
_BOOL8 __fastcall ssh_match_group(const char *a1, const char *a2)
{
  char *i; // rax
  char *s; // [rsp+10h] [rbp-10h]
  char *v5; // [rsp+18h] [rbp-8h]

  s = (char *)a1;
  for ( i = strchr(a1, 44); ; i = strchr(v5 + 1, 44) )
  {
    v5 = i;
    if ( !i )
      return strcmp(s, a2) == 0;
    if ( !strncmp(s, a2, i - s) )
      break;
    s = v5 + 1;
  }
  return 1LL;
}

//----- (0000000000021D03) ----------------------------------------------------
void *__fastcall explicit_bzero(void *a1, size_t a2)
{
  return memset(a1, 0, a2);
}

//----- (0000000000021D2B) ----------------------------------------------------
__int64 __fastcall ssh_options_copy(__int64 a1, __int64 **a2)
{
  int j; // [rsp+10h] [rbp-20h]
  __int64 i; // [rsp+18h] [rbp-18h]
  __int64 *v5; // [rsp+20h] [rbp-10h]
  char *ptr; // [rsp+28h] [rbp-8h]

  if ( !a1 || !a2 )
    return 0xFFFFFFFFLL;
  v5 = ssh_new();
  if ( !v5 )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 1472) )
  {
    v5[184] = (__int64)strdup(*(const char **)(a1 + 1472));
    if ( !v5[184] )
      goto LABEL_31;
  }
  if ( *(_QWORD *)(a1 + 1480) )
  {
    v5[185] = (__int64)strdup(*(const char **)(a1 + 1480));
    if ( !v5[185] )
      goto LABEL_31;
  }
  if ( *(_QWORD *)(a1 + 1464) )
  {
    for ( i = ssh_list_get_iterator(*(_QWORD *)(a1 + 1464)); i; i = *(_QWORD *)i )
    {
      ptr = strdup(*(const char **)(i + 8));
      if ( !ptr )
        goto LABEL_31;
      if ( (int)ssh_list_append(v5[183], (__int64)ptr) < 0 )
      {
        free(ptr);
        ssh_free((__int64)v5);
        return 0xFFFFFFFFLL;
      }
    }
  }
  if ( *(_QWORD *)(a1 + 1496) )
  {
    v5[187] = (__int64)strdup(*(const char **)(a1 + 1496));
    if ( !v5[187] )
      goto LABEL_31;
  }
  if ( *(_QWORD *)(a1 + 1504) )
  {
    v5[188] = (__int64)strdup(*(const char **)(a1 + 1504));
    if ( !v5[188] )
      goto LABEL_31;
  }
  for ( j = 0; j <= 9; ++j )
  {
    if ( *(_QWORD *)(a1 + 8 * (j + 188LL) + 16) )
    {
      v5[j + 190] = (__int64)strdup(*(const char **)(a1 + 8 * (j + 188LL) + 16));
      if ( !v5[j + 190] )
        goto LABEL_31;
    }
  }
  if ( !*(_QWORD *)(a1 + 1600) || (v5[200] = (__int64)strdup(*(const char **)(a1 + 1600))) != 0 )
  {
    *((_DWORD *)v5 + 409) = *(_DWORD *)(a1 + 1636);
    *((_DWORD *)v5 + 408) = *(_DWORD *)(a1 + 1632);
    v5[202] = *(_QWORD *)(a1 + 1616);
    v5[203] = *(_QWORD *)(a1 + 1624);
    *((_BYTE *)v5 + 1644) = *(_BYTE *)(a1 + 1644);
    *((_DWORD *)v5 + 260) = *(_DWORD *)(a1 + 1040);
    v5[129] = *(_QWORD *)(a1 + 1032);
    *a2 = v5;
    return 0LL;
  }
  else
  {
LABEL_31:
    ssh_free((__int64)v5);
    return 0xFFFFFFFFLL;
  }
}

//----- (000000000002211E) ----------------------------------------------------
__int64 __fastcall ssh_options_set_algo(__int64 a1, unsigned int a2, const char *a3)
{
  char *description; // rax
  _BYTE *v6; // [rsp+28h] [rbp-8h]

  v6 = ssh_keep_known_algos(a2, a3);
  if ( v6 )
  {
    if ( *(_QWORD *)(a1 + 8 * (a2 + 188LL) + 16) )
    {
      free(*(void **)(a1 + 8 * (a2 + 188LL) + 16));
      *(_QWORD *)(a1 + 8 * (a2 + 188LL) + 16) = 0LL;
    }
    *(_QWORD *)(a1 + 8 * (a2 + 188LL) + 16) = v6;
    return 0LL;
  }
  else
  {
    description = ssh_kex_get_description(a2);
    ssh_set_error(
      a1,
      1,
      "ssh_options_set_algo",
      "Setting method: no algorithm for method \"%s\" (%s)",
      (__int64)description,
      (__int64)a3);
    return 0xFFFFFFFFLL;
  }
}

//----- (00000000000221FF) ----------------------------------------------------
__int64 __fastcall ssh_options_set(__int64 a1, unsigned int a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  int v11; // eax
  int v12; // edx
  char *endptr; // [rsp+30h] [rbp-60h] BYREF
  char *nptr; // [rsp+38h] [rbp-58h]
  char *s1; // [rsp+40h] [rbp-50h]
  char *v17; // [rsp+48h] [rbp-48h]
  __int64 v18; // [rsp+50h] [rbp-40h]
  char *v19; // [rsp+58h] [rbp-38h]
  char *v20; // [rsp+60h] [rbp-30h]
  char *v21; // [rsp+68h] [rbp-28h]
  char *v22; // [rsp+70h] [rbp-20h]
  int *v23; // [rsp+78h] [rbp-18h]
  char *v24; // [rsp+80h] [rbp-10h]
  char *v25; // [rsp+88h] [rbp-8h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  switch ( a2 )
  {
    case 0u:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      nptr = strdup(a3);
      if ( !nptr )
        goto LABEL_202;
      endptr = strchr(nptr, 64);
      if ( *(_QWORD *)(a1 + 1480) )
      {
        free(*(void **)(a1 + 1480));
        *(_QWORD *)(a1 + 1480) = 0LL;
      }
      if ( !endptr )
      {
        *(_QWORD *)(a1 + 1480) = nptr;
        return 0LL;
      }
      *endptr = 0;
      *(_QWORD *)(a1 + 1480) = strdup(endptr + 1);
      if ( !*(_QWORD *)(a1 + 1480) )
      {
        if ( nptr )
        {
          free(nptr);
          nptr = 0LL;
        }
        goto LABEL_202;
      }
      if ( *(_QWORD *)(a1 + 1472) )
      {
        free(*(void **)(a1 + 1472));
        *(_QWORD *)(a1 + 1472) = 0LL;
      }
      *(_QWORD *)(a1 + 1472) = strdup(nptr);
      if ( nptr )
      {
        free(nptr);
        nptr = 0LL;
      }
      if ( *(_QWORD *)(a1 + 1472) )
        return 0LL;
      goto LABEL_202;
    case 1u:
      if ( !a3 )
        goto LABEL_198;
      v17 = a3;
      if ( *(int *)a3 <= 0 )
        goto LABEL_198;
      *(_DWORD *)(a1 + 1632) = (unsigned __int16)*(_DWORD *)v17;
      return 0LL;
    case 2u:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      nptr = strdup(s1);
      if ( !nptr )
        goto LABEL_202;
      v18 = strtol(nptr, &endptr, 10);
      if ( nptr == endptr && nptr )
      {
        free(nptr);
        nptr = 0LL;
      }
      if ( nptr )
      {
        free(nptr);
        nptr = 0LL;
      }
      if ( v18 <= 0 )
        goto LABEL_36;
      *(_DWORD *)(a1 + 1632) = (unsigned __int16)v18;
      return 0LL;
    case 3u:
      if ( !a3 || (v19 = a3, *(int *)a3 < 0) )
      {
        *(_DWORD *)(a1 + 1636) = -1;
        ssh_set_error_invalid(a1, "ssh_options_set", (__int64)a3, a4, a5, a6);
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)(a1 + 1636) = (unsigned __int16)*(_DWORD *)v19;
      return 0LL;
    case 4u:
      s1 = a3;
      if ( *(_QWORD *)(a1 + 1472) )
      {
        free(*(void **)(a1 + 1472));
        *(_QWORD *)(a1 + 1472) = 0LL;
      }
      if ( !s1 )
      {
        nptr = ssh_get_local_username();
        if ( !nptr )
          goto LABEL_202;
        *(_QWORD *)(a1 + 1472) = nptr;
        return 0LL;
      }
      if ( !*s1 )
        goto LABEL_198;
      *(_QWORD *)(a1 + 1472) = strdup(a3);
      if ( !*(_QWORD *)(a1 + 1472) )
        goto LABEL_202;
      return 0LL;
    case 5u:
      s1 = a3;
      if ( *(_QWORD *)(a1 + 1496) )
      {
        free(*(void **)(a1 + 1496));
        *(_QWORD *)(a1 + 1496) = 0LL;
      }
      if ( !s1 )
      {
        *(_QWORD *)(a1 + 1496) = ssh_path_expand_tilde("~/.ssh");
        if ( *(_QWORD *)(a1 + 1496) )
          return 0LL;
        return 0xFFFFFFFFLL;
      }
      if ( !*s1 )
        goto LABEL_198;
      *(_QWORD *)(a1 + 1496) = ssh_path_expand_tilde(s1);
      if ( !*(_QWORD *)(a1 + 1496) )
        goto LABEL_202;
      return 0LL;
    case 6u:
    case 7u:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      nptr = strdup(s1);
      if ( !nptr )
        return 0xFFFFFFFFLL;
      if ( (int)ssh_list_prepend(*(_QWORD **)(a1 + 1464), (__int64)nptr) >= 0 )
        return 0LL;
      free(nptr);
      return 0xFFFFFFFFLL;
    case 8u:
      s1 = a3;
      if ( *(_QWORD *)(a1 + 1504) )
      {
        free(*(void **)(a1 + 1504));
        *(_QWORD *)(a1 + 1504) = 0LL;
      }
      if ( !s1 )
      {
        *(_QWORD *)(a1 + 1504) = ssh_path_expand_escape(a1, "%d/known_hosts");
        if ( *(_QWORD *)(a1 + 1504) )
          return 0LL;
        goto LABEL_202;
      }
      if ( !*s1 )
        goto LABEL_198;
      *(_QWORD *)(a1 + 1504) = strdup(s1);
      if ( !*(_QWORD *)(a1 + 1504) )
        goto LABEL_202;
      return 0LL;
    case 9u:
      if ( !a3 )
        goto LABEL_198;
      v20 = a3;
      if ( *(__int64 *)a3 < 0 )
        goto LABEL_198;
      *(_QWORD *)(a1 + 1616) = (unsigned int)*(_QWORD *)v20;
      return 0LL;
    case 0xAu:
      if ( !a3 )
        goto LABEL_198;
      v21 = a3;
      if ( *(__int64 *)a3 < 0 )
        goto LABEL_198;
      *(_QWORD *)(a1 + 1624) = (unsigned int)*(_QWORD *)v21;
      return 0LL;
    case 0xBu:
    case 0xCu:
      return 0LL;
    case 0xDu:
      if ( !a3 )
        goto LABEL_198;
      v22 = a3;
      if ( *(int *)a3 < 0 )
        goto LABEL_198;
      *(_DWORD *)(a1 + 1040) = (unsigned __int16)*(_DWORD *)v22;
      ssh_set_log_level((unsigned __int16)*(_DWORD *)v22);
      return 0LL;
    case 0xEu:
      s1 = a3;
      if ( !a3 || !*s1 )
      {
        *(_DWORD *)(a1 + 1040) = 0;
        ssh_set_error_invalid(a1, "ssh_options_set", (__int64)a3, a4, a5, a6);
        return 0xFFFFFFFFLL;
      }
      nptr = strdup(s1);
      if ( !nptr )
        goto LABEL_202;
      v18 = strtol(nptr, &endptr, 10);
      if ( nptr == endptr && nptr )
      {
        free(nptr);
        nptr = 0LL;
      }
      if ( nptr )
      {
        free(nptr);
        nptr = 0LL;
      }
      if ( v18 < 0 )
      {
LABEL_36:
        ssh_set_error_invalid(a1, "ssh_options_set", v7, v8, v9, v10);
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)(a1 + 1040) = (unsigned __int16)v18;
      ssh_set_log_level((unsigned __int16)v18);
      return 0LL;
    case 0xFu:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      if ( (int)ssh_options_set_algo(a1, 2u, s1) >= 0 )
        return 0LL;
      return 0xFFFFFFFFLL;
    case 0x10u:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      if ( (int)ssh_options_set_algo(a1, 3u, s1) >= 0 )
        return 0LL;
      return 0xFFFFFFFFLL;
    case 0x11u:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      if ( !strcasecmp(a3, "yes") )
      {
        if ( (int)ssh_options_set_algo(a1, 6u, "zlib@openssh.com,zlib") >= 0 )
          return 0LL;
        return 0xFFFFFFFFLL;
      }
      else if ( !strcasecmp(a3, "no") )
      {
        if ( (int)ssh_options_set_algo(a1, 6u, "none") >= 0 )
          return 0LL;
        return 0xFFFFFFFFLL;
      }
      else
      {
        if ( (int)ssh_options_set_algo(a1, 6u, s1) >= 0 )
          return 0LL;
        return 0xFFFFFFFFLL;
      }
    case 0x12u:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      if ( !strcasecmp(a3, "yes") )
      {
        if ( (int)ssh_options_set_algo(a1, 7u, "zlib@openssh.com,zlib") >= 0 )
          return 0LL;
        return 0xFFFFFFFFLL;
      }
      else if ( !strcasecmp(a3, "no") )
      {
        if ( (int)ssh_options_set_algo(a1, 7u, "none") >= 0 )
          return 0LL;
        return 0xFFFFFFFFLL;
      }
      else
      {
        if ( (int)ssh_options_set_algo(a1, 7u, s1) >= 0 )
          return 0LL;
        return 0xFFFFFFFFLL;
      }
    case 0x13u:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      if ( *(_QWORD *)(a1 + 1600) )
      {
        free(*(void **)(a1 + 1600));
        *(_QWORD *)(a1 + 1600) = 0LL;
      }
      if ( !strcasecmp(s1, "none") )
        return 0LL;
      nptr = strdup(s1);
      if ( !nptr )
        return 0xFFFFFFFFLL;
      *(_QWORD *)(a1 + 1600) = nptr;
      return 0LL;
    case 0x14u:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      nptr = strdup(s1);
      if ( !nptr )
        return 0xFFFFFFFFLL;
      if ( *(_QWORD *)(a1 + 1488) )
      {
        free(*(void **)(a1 + 1488));
        *(_QWORD *)(a1 + 1488) = 0LL;
      }
      *(_QWORD *)(a1 + 1488) = nptr;
      return 0LL;
    case 0x15u:
      if ( !a3 )
        goto LABEL_198;
      v24 = a3;
      *(_DWORD *)(a1 + 1640) = (unsigned __int8)*(_DWORD *)a3 != 0;
      *(_DWORD *)(a1 + 1640) = *(_DWORD *)a3;
      return 0LL;
    case 0x16u:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      if ( (int)ssh_options_set(a1, 17LL, s1) < 0 )
        return 0xFFFFFFFFLL;
      if ( (int)ssh_options_set(a1, 18LL, s1) >= 0 )
        return 0LL;
      return 0xFFFFFFFFLL;
    case 0x17u:
      if ( !a3 )
        goto LABEL_198;
      v23 = (int *)a3;
      if ( *(int *)a3 <= 0 || *v23 > 9 )
        goto LABEL_198;
      *(_BYTE *)(a1 + 1644) = *v23;
      return 0LL;
    case 0x18u:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      if ( (int)ssh_options_set_algo(a1, 0, s1) >= 0 )
        return 0LL;
      return 0xFFFFFFFFLL;
    case 0x19u:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      if ( (int)ssh_options_set_algo(a1, 1u, s1) >= 0 )
        return 0LL;
      return 0xFFFFFFFFLL;
    case 0x1Au:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      if ( *(_QWORD *)(a1 + 1648) )
      {
        free(*(void **)(a1 + 1648));
        *(_QWORD *)(a1 + 1648) = 0LL;
      }
      *(_QWORD *)(a1 + 1648) = strdup(s1);
      if ( !*(_QWORD *)(a1 + 1648) )
        goto LABEL_202;
      return 0LL;
    case 0x1Bu:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      if ( *(_QWORD *)(a1 + 1656) )
      {
        free(*(void **)(a1 + 1656));
        *(_QWORD *)(a1 + 1656) = 0LL;
      }
      *(_QWORD *)(a1 + 1656) = strdup(s1);
      if ( !*(_QWORD *)(a1 + 1656) )
        goto LABEL_202;
      return 0LL;
    case 0x1Cu:
      if ( !a3 )
        goto LABEL_219;
      *(_DWORD *)(a1 + 1664) = (unsigned __int8)*(_DWORD *)a3;
      return 0LL;
    case 0x1Du:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      if ( (int)ssh_options_set_algo(a1, 4u, s1) >= 0 )
        return 0LL;
      return 0xFFFFFFFFLL;
    case 0x1Eu:
      s1 = a3;
      if ( !a3 || !*s1 )
        goto LABEL_198;
      if ( (int)ssh_options_set_algo(a1, 5u, s1) >= 0 )
        return 0LL;
      return 0xFFFFFFFFLL;
    case 0x1Fu:
    case 0x20u:
    case 0x21u:
    case 0x22u:
      if ( !a3 )
        goto LABEL_219;
      switch ( a2 )
      {
        case 0x1Fu:
          v11 = 1;
          break;
        case 0x20u:
          v11 = 2;
          break;
        case 0x21u:
          v11 = 4;
          break;
        default:
          v11 = 8;
          break;
      }
      if ( *(_DWORD *)a3 )
        v12 = v11 | *(_DWORD *)(a1 + 1668);
      else
        v12 = *(_DWORD *)(a1 + 1668) & ~v11;
      *(_DWORD *)(a1 + 1668) = v12;
      return 0LL;
    case 0x23u:
      s1 = a3;
      if ( *(_QWORD *)(a1 + 1512) )
      {
        free(*(void **)(a1 + 1512));
        *(_QWORD *)(a1 + 1512) = 0LL;
      }
      if ( s1 )
      {
        if ( !*s1 )
        {
LABEL_198:
          ssh_set_error_invalid(a1, "ssh_options_set", (__int64)a3, a4, a5, a6);
          return 0xFFFFFFFFLL;
        }
        *(_QWORD *)(a1 + 1512) = strdup(s1);
        if ( *(_QWORD *)(a1 + 1512) )
          return 0LL;
      }
      else
      {
        *(_QWORD *)(a1 + 1512) = strdup("/etc/ssh/ssh_known_hosts");
        if ( *(_QWORD *)(a1 + 1512) )
          return 0LL;
      }
LABEL_202:
      ssh_set_error_oom(a1, "ssh_options_set");
      result = 0xFFFFFFFFLL;
      break;
    case 0x24u:
      if ( a3 )
      {
        v25 = a3;
        *(_DWORD *)(a1 + 1672) = (unsigned __int8)*(_DWORD *)a3 != 0;
        return 0LL;
      }
      else
      {
LABEL_219:
        ssh_set_error_invalid(a1, "ssh_options_set", 0LL, a4, a5, a6);
        return 0xFFFFFFFFLL;
      }
    default:
      ssh_set_error(a1, 1, "ssh_options_set", "Unknown ssh option %d", a2, a6);
      return 0xFFFFFFFFLL;
  }
  return result;
}
// 22585: variable 'v7' is possibly undefined
// 22585: variable 'v8' is possibly undefined
// 22585: variable 'v9' is possibly undefined
// 22585: variable 'v10' is possibly undefined
// 2350D: variable 'a3' is possibly undefined
// 2350D: variable 'a4' is possibly undefined
// 2350D: variable 'a5' is possibly undefined
// 2350D: variable 'a6' is possibly undefined

//----- (0000000000023750) ----------------------------------------------------
__int64 __fastcall ssh_options_get_port(__int64 a1, _DWORD *a2)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_DWORD *)(a1 + 1632) )
    *a2 = *(_DWORD *)(a1 + 1632);
  else
    *a2 = 22;
  return 0LL;
}

//----- (00000000000237A0) ----------------------------------------------------
__int64 __fastcall ssh_options_get(__int64 *a1, unsigned int a2, char **a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *s; // [rsp+20h] [rbp-10h]
  __int64 iterator; // [rsp+28h] [rbp-8h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !a3 )
  {
    ssh_set_error_invalid((__int64)a1, "ssh_options_get", 0LL, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
  if ( a2 == 4 )
  {
    s = (char *)a1[184];
  }
  else if ( a2 > 4 )
  {
    if ( a2 == 6 )
    {
      iterator = ssh_list_get_iterator(a1[183]);
      if ( !iterator )
        return 0xFFFFFFFFLL;
      s = *(char **)(iterator + 8);
    }
    else
    {
      if ( a2 != 19 )
        goto LABEL_18;
      s = (char *)a1[200];
    }
  }
  else
  {
    if ( a2 )
    {
LABEL_18:
      ssh_set_error((__int64)a1, 1, "ssh_options_get", "Unknown ssh option %d", a2, a6);
      return 0xFFFFFFFFLL;
    }
    s = (char *)a1[185];
  }
  if ( !s )
    return 0xFFFFFFFFLL;
  *a3 = strdup(s);
  if ( *a3 )
    return 0LL;
  ssh_set_error_oom((__int64)a1, "ssh_options_get");
  return 0xFFFFFFFFLL;
}

//----- (00000000000238FD) ----------------------------------------------------
__int64 __fastcall ssh_options_getopt(__int64 a1, int *a2, char *const *a3)
{
  char **v3; // rbx
  int v4; // eax
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  char s[2]; // [rsp+25h] [rbp-6Bh] BYREF
  char v13; // [rsp+27h] [rbp-69h]
  int i; // [rsp+28h] [rbp-68h]
  int v15; // [rsp+2Ch] [rbp-64h]
  int v16; // [rsp+30h] [rbp-60h]
  int v17; // [rsp+34h] [rbp-5Ch]
  int v18; // [rsp+38h] [rbp-58h]
  int v19; // [rsp+3Ch] [rbp-54h]
  int v20; // [rsp+40h] [rbp-50h]
  int argc; // [rsp+44h] [rbp-4Ch]
  int v22; // [rsp+48h] [rbp-48h]
  int v23; // [rsp+4Ch] [rbp-44h]
  char *v24; // [rsp+50h] [rbp-40h]
  char *v25; // [rsp+58h] [rbp-38h]
  char *v26; // [rsp+60h] [rbp-30h]
  char *v27; // [rsp+68h] [rbp-28h]
  void *ptr; // [rsp+70h] [rbp-20h]
  char *v29; // [rsp+78h] [rbp-18h]

  v24 = 0LL;
  v25 = 0LL;
  v26 = 0LL;
  v27 = 0LL;
  ptr = 0LL;
  v29 = 0LL;
  i = 0;
  argc = *a2;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 1;
  v20 = 0;
  v22 = optind;
  v23 = opterr;
  opterr = 0;
LABEL_21:
  while ( v19 )
  {
    i = getopt(argc, a3, "c:i:Cl:p:vb:rd12");
    if ( i == -1 )
      break;
    switch ( i )
    {
      case '1':
      case '2':
        goto LABEL_21;
      case 'C':
        ++v18;
        goto LABEL_21;
      case 'c':
        v25 = optarg;
        goto LABEL_21;
      case 'd':
        ++v17;
        goto LABEL_21;
      case 'i':
        v26 = optarg;
        goto LABEL_21;
      case 'l':
        v24 = optarg;
        goto LABEL_21;
      case 'p':
        v27 = optarg;
        goto LABEL_21;
      case 'r':
        ++v16;
        goto LABEL_21;
      case 'v':
        ++v15;
        goto LABEL_21;
      default:
        s[0] = 45;
        v13 = 0;
        s[1] = optopt;
        v29 = (char *)realloc(ptr, 8LL * (v20 + 1));
        if ( !v29 )
        {
          if ( ptr )
          {
            free(ptr);
            ptr = 0LL;
          }
          goto LABEL_31;
        }
        ptr = v29;
        v3 = (char **)&v29[8 * v20];
        *v3 = strdup(s);
        if ( !*((_QWORD *)ptr + v20) )
        {
          if ( ptr )
          {
            free(ptr);
            ptr = 0LL;
          }
          goto LABEL_31;
        }
        ++v20;
        if ( optarg )
        {
          v4 = v20++;
          *((char **)ptr + v4) = a3[optind + 1];
        }
        break;
    }
  }
  opterr = v23;
  v29 = (char *)realloc(ptr, 8LL * (argc - optind + v20));
  if ( v29 )
  {
    ptr = v29;
    while ( 1 )
    {
      if ( optind >= argc )
      {
        if ( v16 && v17 )
        {
          ssh_set_error(a1, 2, "ssh_options_getopt", "Either RSA or DSS must be chosen", v5, v6);
          v19 = 0;
        }
        ssh_set_log_level(v15);
        optind = v22;
        if ( v19 )
        {
          for ( i = 0; i < v20; ++i )
          {
            v8 = 8LL * i;
            a3[i + 1] = *(char *const *)((char *)ptr + v8);
          }
          a3[v20 + 1] = 0LL;
          *a2 = v20 + 1;
          if ( ptr )
          {
            free(ptr);
            ptr = 0LL;
          }
          if ( v18 && (int)ssh_options_set(a1, 0x16u, "yes", v8, v9, v10) < 0 )
            v19 = 0;
          if ( v19 && v25 )
          {
            if ( (int)ssh_options_set(a1, 0xFu, v25, v8, v9, v10) < 0 )
              v19 = 0;
            if ( v19 && (int)ssh_options_set(a1, 0x10u, v25, v8, v9, v10) < 0 )
              v19 = 0;
          }
          if ( v19 && v24 && (int)ssh_options_set(a1, 4u, v24, v8, v9, v10) < 0 )
            v19 = 0;
          if ( v19 && v26 && (int)ssh_options_set(a1, 6u, v26, v8, v9, v10) < 0 )
            v19 = 0;
          if ( v27 )
            ssh_options_set(a1, 2u, v27, v8, v9, v10);
          if ( v19 )
            return 0LL;
          else
            return 0xFFFFFFFFLL;
        }
        else
        {
          if ( ptr )
          {
            free(ptr);
            ptr = 0LL;
          }
          return 0xFFFFFFFFLL;
        }
      }
      v29 = (char *)realloc(ptr, 8LL * (v20 + 1));
      if ( !v29 )
        break;
      ptr = v29;
      *(char **)&v29[8 * v20++] = a3[optind++];
    }
    if ( ptr )
    {
      free(ptr);
      ptr = 0LL;
    }
  }
  else if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
LABEL_31:
  ssh_set_error_oom(a1, "ssh_options_getopt");
  return 0xFFFFFFFFLL;
}
// 23D47: variable 'v5' is possibly undefined
// 23D47: variable 'v6' is possibly undefined
// 23E40: variable 'v8' is possibly undefined
// 23E40: variable 'v9' is possibly undefined
// 23E40: variable 'v10' is possibly undefined

//----- (0000000000023F35) ----------------------------------------------------
__int64 __fastcall ssh_options_parse_config(__int64 a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v7; // [rsp+14h] [rbp-Ch]
  char *ptr; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 1480) )
  {
    if ( *(_QWORD *)(a1 + 1496) || (int)ssh_options_set(a1, 5u, 0LL, a4, a5, a6) >= 0 )
    {
      if ( a2 )
        ptr = ssh_path_expand_escape(a1, a2);
      else
        ptr = ssh_path_expand_escape(a1, "%d/config");
      if ( ptr )
      {
        v7 = ssh_config_parse_file(a1, ptr);
        if ( v7 >= 0 && !a2 )
          v7 = ssh_config_parse_file(a1, "/etc/ssh/ssh_config");
        free(ptr);
        return (unsigned int)v7;
      }
      else
      {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      ssh_set_error_oom(a1, "ssh_options_parse_config");
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error_invalid(a1, "ssh_options_parse_config", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000024061) ----------------------------------------------------
__int64 __fastcall ssh_options_apply(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *i; // [rsp+18h] [rbp-18h]
  char *v8; // [rsp+20h] [rbp-10h]
  char *v9; // [rsp+20h] [rbp-10h]
  char *v10; // [rsp+20h] [rbp-10h]
  char *ptr; // [rsp+28h] [rbp-8h]

  if ( !*(_QWORD *)(a1 + 1496) && (int)ssh_options_set(a1, 5u, 0LL, a4, a5, a6) < 0 )
    return 0xFFFFFFFFLL;
  if ( !*(_QWORD *)(a1 + 1472) && (int)ssh_options_set(a1, 4u, 0LL, a4, a5, a6) < 0 )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 1504) )
    v8 = ssh_path_expand_escape(a1, *(const char **)(a1 + 1504));
  else
    v8 = ssh_path_expand_escape(a1, "%d/known_hosts");
  if ( !v8 )
    return 0xFFFFFFFFLL;
  free(*(void **)(a1 + 1504));
  *(_QWORD *)(a1 + 1504) = v8;
  if ( *(_QWORD *)(a1 + 1600) )
  {
    v9 = ssh_path_expand_escape(a1, *(const char **)(a1 + 1600));
    if ( !v9 )
      return 0xFFFFFFFFLL;
    free(*(void **)(a1 + 1600));
    *(_QWORD *)(a1 + 1600) = v9;
  }
  for ( i = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(a1 + 1464)); i; i = (_QWORD *)*i )
  {
    ptr = (char *)i[1];
    v10 = ssh_path_expand_escape(a1, ptr);
    if ( !v10 )
      return 0xFFFFFFFFLL;
    free(ptr);
    i[1] = v10;
  }
  return 0LL;
}
// 240C7: variable 'a4' is possibly undefined
// 240C7: variable 'a5' is possibly undefined
// 240C7: variable 'a6' is possibly undefined

//----- (0000000000024235) ----------------------------------------------------
__int64 __fastcall ssh_bind_set_key(__int64 a1, void **a2, const char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( a3 )
  {
    if ( *a2 )
    {
      free(*a2);
      *a2 = 0LL;
    }
    *a2 = strdup(a3);
    if ( *a2 )
    {
      return 0LL;
    }
    else
    {
      ssh_set_error_oom(a1, "ssh_bind_set_key");
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error_invalid(a1, "ssh_bind_set_key", 0LL, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (00000000000242D3) ----------------------------------------------------
__int64 __fastcall ssh_bind_options_set(__int64 a1, unsigned int a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  int v7; // eax
  __int64 v8; // r8
  __int64 v9; // r9
  int v10; // eax
  __int64 v11; // r9
  unsigned __int16 v13; // [rsp+2Ch] [rbp-44h]
  unsigned __int16 v14; // [rsp+2Ch] [rbp-44h]
  char *endptr; // [rsp+30h] [rbp-40h] BYREF
  char *nptr; // [rsp+38h] [rbp-38h]
  void **v17; // [rsp+40h] [rbp-30h]
  void **v18; // [rsp+48h] [rbp-28h]
  void **v19; // [rsp+50h] [rbp-20h]
  char *v20; // [rsp+58h] [rbp-18h]
  char *v21; // [rsp+60h] [rbp-10h]
  char *v22; // [rsp+68h] [rbp-8h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  switch ( a2 )
  {
    case 0u:
      if ( !a3 )
        goto LABEL_76;
      if ( *(_QWORD *)(a1 + 1224) )
      {
        free(*(void **)(a1 + 1224));
        *(_QWORD *)(a1 + 1224) = 0LL;
      }
      *(_QWORD *)(a1 + 1224) = strdup(a3);
      if ( *(_QWORD *)(a1 + 1224) )
        goto LABEL_82;
      goto LABEL_62;
    case 1u:
      if ( !a3 )
        goto LABEL_76;
      v21 = a3;
      *(_DWORD *)(a1 + 1236) = (unsigned __int16)*(_DWORD *)a3;
      goto LABEL_82;
    case 2u:
      if ( !a3 )
      {
        *(_DWORD *)(a1 + 1236) = 22;
        goto LABEL_82;
      }
      nptr = strdup(a3);
      if ( !nptr )
        goto LABEL_62;
      v13 = strtol(nptr, &endptr, 10);
      if ( nptr == endptr && nptr )
      {
        free(nptr);
        nptr = 0LL;
      }
      if ( nptr )
      {
        free(nptr);
        nptr = 0LL;
      }
      *(_DWORD *)(a1 + 1236) = v13;
      goto LABEL_82;
    case 3u:
      if ( !a3 )
        goto LABEL_76;
      v17 = 0LL;
      if ( (unsigned int)ssh_pki_import_privkey_file(a3, 0LL, 0LL, 0LL, &endptr) )
        return 0xFFFFFFFFLL;
      v7 = ssh_key_type((unsigned int *)endptr);
      if ( v7 == 2 )
      {
        v17 = (void **)(a1 + 1208);
        v18 = (void **)(a1 + 1176);
        goto LABEL_20;
      }
      if ( v7 > 2 )
      {
        if ( v7 == 4 )
        {
          v17 = (void **)(a1 + 1192);
          v18 = (void **)(a1 + 1160);
          goto LABEL_20;
        }
        if ( v7 == 5 )
        {
          v17 = (void **)(a1 + 1216);
          v18 = (void **)(a1 + 1184);
          goto LABEL_20;
        }
      }
      else if ( v7 == 1 )
      {
        v17 = (void **)(a1 + 1200);
        v18 = (void **)(a1 + 1168);
        goto LABEL_20;
      }
      ssh_set_error(a1, 2, "ssh_bind_options_set", "Unsupported key type %d", (unsigned int)v7, v9);
LABEL_20:
      if ( !v17 || (int)ssh_bind_set_key(a1, v18, a3, (__int64)v18, v8, v9) < 0 )
      {
        ssh_key_free(endptr);
        return 0xFFFFFFFFLL;
      }
      ssh_key_free(*v17);
      *v17 = endptr;
      goto LABEL_82;
    case 4u:
      if ( (int)ssh_bind_set_key(a1, (void **)(a1 + 1168), a3, a1 + 1168, a5, a6) >= 0 )
        goto LABEL_82;
      return 0xFFFFFFFFLL;
    case 5u:
      if ( (int)ssh_bind_set_key(a1, (void **)(a1 + 1176), a3, a1 + 1176, a5, a6) >= 0 )
        goto LABEL_82;
      return 0xFFFFFFFFLL;
    case 6u:
      if ( !a3 )
        goto LABEL_76;
      if ( *(_QWORD *)(a1 + 1152) )
      {
        free(*(void **)(a1 + 1152));
        *(_QWORD *)(a1 + 1152) = 0LL;
      }
      *(_QWORD *)(a1 + 1152) = strdup(a3);
      if ( !*(_QWORD *)(a1 + 1152) )
        goto LABEL_62;
      goto LABEL_82;
    case 7u:
      if ( !a3 )
        goto LABEL_76;
      v22 = a3;
      ssh_set_log_level((unsigned __int16)*(_DWORD *)a3);
      goto LABEL_82;
    case 8u:
      if ( !a3 )
      {
        ssh_set_log_level(0);
        goto LABEL_82;
      }
      nptr = strdup(a3);
      if ( !nptr )
      {
LABEL_62:
        ssh_set_error_oom(a1, "ssh_bind_options_set");
        return 0xFFFFFFFFLL;
      }
      v14 = strtol(nptr, &endptr, 10);
      if ( nptr == endptr && nptr )
      {
        free(nptr);
        nptr = 0LL;
      }
      if ( nptr )
      {
        free(nptr);
        nptr = 0LL;
      }
      ssh_set_log_level(v14);
      goto LABEL_82;
    case 9u:
      if ( (int)ssh_bind_set_key(a1, (void **)(a1 + 1160), a3, a1 + 1160, a5, a6) >= 0 )
        goto LABEL_82;
      return 0xFFFFFFFFLL;
    case 0xAu:
      if ( !a3 )
      {
LABEL_76:
        ssh_set_error_invalid(a1, "ssh_bind_options_set", 0LL, a4, a5, a6);
        return 0xFFFFFFFFLL;
      }
      v19 = 0LL;
      v20 = a3;
      v10 = ssh_key_type((unsigned int *)a3);
      if ( v10 == 2 )
      {
        v19 = (void **)(a1 + 1208);
        goto LABEL_37;
      }
      if ( v10 > 2 )
      {
        if ( v10 == 4 )
        {
          v19 = (void **)(a1 + 1192);
          goto LABEL_37;
        }
        if ( v10 == 5 )
        {
          v19 = (void **)(a1 + 1216);
          goto LABEL_37;
        }
      }
      else if ( v10 == 1 )
      {
        v19 = (void **)(a1 + 1200);
        goto LABEL_37;
      }
      ssh_set_error(a1, 2, "ssh_bind_options_set", "Unsupported key type %d", (unsigned int)v10, v11);
LABEL_37:
      if ( v19 )
      {
        ssh_key_free(*v19);
        *v19 = v20;
LABEL_82:
        result = 0LL;
      }
      else
      {
        result = 0xFFFFFFFFLL;
      }
      break;
    default:
      ssh_set_error(a1, 1, "ssh_bind_options_set", "Unknown ssh option %d", a2, a6);
      return 0xFFFFFFFFLL;
  }
  return result;
}
// 24458: variable 'v9' is possibly undefined
// 2448C: variable 'v8' is possibly undefined
// 24597: variable 'v11' is possibly undefined

//----- (00000000000249E5) ----------------------------------------------------
unsigned __int64 __fastcall ssh_packet_socket_callback(
        _QWORD *a1,
        unsigned __int64 a2,
        __int64 *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  int v6; // eax
  int v7; // eax
  int v8; // eax
  __int64 v10; // r9
  unsigned __int64 v11; // rax
  __int64 v12; // r9
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  unsigned int v19; // ebx
  unsigned int len; // eax
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // r8
  __int64 v25; // r9
  unsigned __int8 v27; // [rsp+23h] [rbp-6Dh] BYREF
  unsigned int v28; // [rsp+24h] [rbp-6Ch]
  unsigned int v29; // [rsp+28h] [rbp-68h]
  int u8; // [rsp+2Ch] [rbp-64h]
  uint32_t v31; // [rsp+30h] [rbp-60h]
  unsigned int v32; // [rsp+34h] [rbp-5Ch]
  unsigned int v33; // [rsp+38h] [rbp-58h]
  unsigned int v34; // [rsp+3Ch] [rbp-54h]
  __int64 v35; // [rsp+40h] [rbp-50h]
  void *src; // [rsp+48h] [rbp-48h]
  unsigned __int64 v37; // [rsp+50h] [rbp-40h]
  __int64 *v38; // [rsp+58h] [rbp-38h]
  uint32_t *v39; // [rsp+60h] [rbp-30h]
  void *dest; // [rsp+68h] [rbp-28h]
  __int64 v41; // [rsp+70h] [rbp-20h]
  size_t n; // [rsp+78h] [rbp-18h]

  v38 = a3;
  if ( a3[154] )
    v6 = *(_DWORD *)(*(_QWORD *)(v38[154] + 304) + 8LL);
  else
    v6 = 8;
  v29 = v6;
  if ( v38[154] )
    v7 = *(_DWORD *)(*(_QWORD *)(v38[154] + 304) + 16LL);
  else
    v7 = 8;
  v28 = v7;
  v35 = 0LL;
  v39 = 0LL;
  dest = 0LL;
  src = 0LL;
  v41 = 0LL;
  v37 = 0LL;
  if ( v38[154] )
    v35 = hmac_digest_len(*(_DWORD *)(v38[154] + 320));
  if ( !v28 )
    v28 = v29;
  if ( !a1 || *((_DWORD *)v38 + 291) == 9 )
    goto LABEL_55;
  v8 = *((_DWORD *)v38 + 292);
  if ( v8 == 1 )
    goto LABEL_28;
  if ( v8 == 2 )
  {
    ssh_log(3, "ssh_packet_socket_callback", "Nested packet processing. Delaying.", a4, a5, a6);
    return 0LL;
  }
  if ( v8 )
  {
    ssh_set_error(
      (__int64)v38,
      2,
      "ssh_packet_socket_callback",
      "Invalid state into packet_read2(): %d",
      *((unsigned int *)v38 + 292),
      a6);
    goto LABEL_55;
  }
  if ( v28 > a2 )
    return 0LL;
  memset(v38 + 142, 0, 0xCuLL);
  if ( v38[141] )
  {
    u8 = ssh_buffer_reinit(v38[141]);
    if ( u8 < 0 )
      goto LABEL_55;
  }
  else
  {
    v38[141] = (__int64)ssh_buffer_new();
    if ( !v38[141] )
    {
LABEL_55:
      *((_DWORD *)v38 + 291) = 9;
      ssh_log(3, "ssh_packet_socket_callback", "Packet: processed %zd bytes", v37, a5, a6);
      return v37;
    }
  }
  v39 = (uint32_t *)ssh_buffer_allocate(v38[141], v28);
  if ( !v39 )
    goto LABEL_55;
  v37 += v28;
  v31 = ssh_packet_decrypt_len((__int64)v38, v39, a1, (__int64)v39, a5, a6);
  if ( v31 > (unsigned int)&loc_40000 )
  {
    ssh_set_error(
      (__int64)v38,
      2,
      "ssh_packet_socket_callback",
      "read_packet(): Packet len too high(%u %.4x)",
      v31,
      v31);
    goto LABEL_55;
  }
  v32 = v31 - v28 + 4;
  if ( (v32 & 0x80000000) != 0 )
  {
    ssh_set_error(
      (__int64)v38,
      2,
      "ssh_packet_socket_callback",
      "Given numbers of bytes left to be read < 0 (%d)!",
      v32,
      v10);
    goto LABEL_55;
  }
  *((_DWORD *)v38 + 285) = v31;
  *((_DWORD *)v38 + 292) = 1;
LABEL_28:
  v31 = *((_DWORD *)v38 + 285);
  v37 = v28;
  v32 = v35 + v31 + 4;
  if ( (_DWORD)v35 + v31 != -4 )
  {
    if ( v32 > a2 )
    {
      ssh_log(
        3,
        "ssh_packet_socket_callback",
        "packet: partial packet (read len) [len=%d, receivedlen=%d, to_be_read=%d]",
        v31,
        (unsigned int)a2,
        v32);
      return 0LL;
    }
    src = (char *)a1 + v28;
    v37 = (int)v32 - v35;
  }
  v11 = v31 - (unsigned __int64)v28;
  n = v11 + 4;
  dest = (void *)ssh_buffer_allocate(v38[141], (int)v11 + 4);
  if ( v38[154] )
  {
    if ( n )
    {
      u8 = ssh_packet_decrypt((__int64)v38, (__int64)dest, (__int64)a1, v28, v37 - v28, v12);
      if ( u8 < 0 )
      {
        ssh_set_error((__int64)v38, 2, "ssh_packet_socket_callback", "Decryption error", v13, v14);
        goto LABEL_55;
      }
    }
    v41 = (__int64)src + n;
    u8 = ssh_packet_hmac_verify((__int64)v38, v38[141], (char *)src + n, *(_DWORD *)(v38[154] + 320));
    if ( u8 < 0 )
    {
      ssh_set_error((__int64)v38, 2, "ssh_packet_socket_callback", "HMAC error", v15, v16);
      goto LABEL_55;
    }
    v37 += v35;
  }
  else
  {
    memcpy(dest, src, n);
  }
  ssh_buffer_pass_bytes(v38[141], 4u);
  u8 = ssh_buffer_get_u8(v38[141], &v27);
  if ( !u8 )
  {
    ssh_set_error((__int64)v38, 2, "ssh_packet_socket_callback", "Packet too short to read padding", v17, v18);
    goto LABEL_55;
  }
  v19 = v27;
  if ( v19 > (unsigned int)ssh_buffer_get_len(v38[141]) )
  {
    len = ssh_buffer_get_len(v38[141]);
    ssh_set_error((__int64)v38, 2, "ssh_packet_socket_callback", "Invalid padding: %d (%d left)", v27, len);
    goto LABEL_55;
  }
  ssh_buffer_pass_bytes_end(v38[141], v27);
  v33 = ssh_buffer_get_len(v38[141]);
  if ( v38[154] )
  {
    if ( *(_DWORD *)(v38[154] + 340) )
    {
      if ( (unsigned int)ssh_buffer_get_len(v38[141]) )
      {
        u8 = decompress_buffer((__int64)v38, v38[141], (unsigned __int64)&loc_40000);
        if ( u8 < 0 )
          goto LABEL_55;
      }
    }
  }
  v34 = ssh_buffer_get_len(v38[141]);
  ++*((_DWORD *)v38 + 273);
  if ( v38[211] )
  {
    *(_QWORD *)v38[211] += v34;
    ++*(_QWORD *)(v38[211] + 16);
  }
  *((_DWORD *)v38 + 292) = 2;
  ssh_packet_parse_type(v38);
  ssh_log(
    3,
    "ssh_packet_socket_callback",
    "packet: read type %hhd [len=%d,padding=%hhd,comp=%d,payload=%d]",
    *((unsigned __int8 *)v38 + 1144),
    v31,
    v27,
    v33,
    v34);
  ssh_packet_process((__int64)v38, *((_BYTE *)v38 + 1144), *((unsigned __int8 *)v38 + 1144), v21, v22, v23);
  *((_DWORD *)v38 + 292) = 0;
  if ( v37 < a2 )
  {
    ssh_log(3, "ssh_packet_socket_callback", "Processing %zd bytes left in socket buffer", a2 - v37, v24, v25);
    v39 = (uint32_t *)((char *)a1 + v37);
    u8 = ssh_packet_socket_callback((char *)a1 + v37, a2 - v37, a3);
    v37 += u8;
  }
  return v37;
}
// 24BDA: variable 'a5' is possibly undefined
// 24BDA: variable 'a6' is possibly undefined
// 24C57: variable 'v10' is possibly undefined
// 24D78: variable 'v12' is possibly undefined
// 24DA5: variable 'v13' is possibly undefined
// 24DA5: variable 'v14' is possibly undefined
// 24E12: variable 'v15' is possibly undefined
// 24E12: variable 'v16' is possibly undefined
// 24E97: variable 'v17' is possibly undefined
// 24E97: variable 'v18' is possibly undefined
// 25094: variable 'v21' is possibly undefined
// 25094: variable 'v22' is possibly undefined
// 25094: variable 'v23' is possibly undefined
// 250D4: variable 'v24' is possibly undefined
// 250D4: variable 'v25' is possibly undefined
// 25136: variable 'a4' is possibly undefined

//----- (00000000000251BE) ----------------------------------------------------
__int64 __fastcall ssh_packet_socket_controlflow_callback(
        int a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 result; // rax
  __int64 *i; // [rsp+18h] [rbp-28h]
  _QWORD *j; // [rsp+20h] [rbp-20h]
  __int64 v9; // [rsp+30h] [rbp-10h]
  __int64 v10; // [rsp+38h] [rbp-8h]

  result = a2;
  if ( a1 == 2 )
  {
    ssh_log(4, "ssh_packet_socket_controlflow_callback", "sending channel_write_wontblock callback", a4, a5, a6, a2);
    result = ssh_list_get_iterator(*(_QWORD *)(a2 + 1248));
    for ( i = (__int64 *)result; i; i = (__int64 *)*i )
    {
      v9 = i[1];
      for ( j = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(v9 + 88)); j; j = (_QWORD *)*j )
      {
        v10 = j[1];
        if ( v10 && v10 + 128 < (unsigned __int64)(*(_QWORD *)v10 + v10) )
        {
          if ( *(_QWORD *)(v10 + 128) )
            (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(v10 + 128))(
              a2,
              v9,
              *(unsigned int *)(v9 + 28),
              *(_QWORD *)(v10 + 8));
        }
      }
      result = *i;
    }
  }
  return result;
}

//----- (00000000000252D3) ----------------------------------------------------
__int64 __fastcall ssh_packet_register_socket_callback(_QWORD *a1, __int64 a2)
{
  a1[177] = ssh_packet_socket_callback;
  a1[180] = 0LL;
  a1[178] = ssh_packet_socket_controlflow_callback;
  a1[176] = a1;
  return ssh_socket_set_callbacks(a2, (__int64)(a1 + 176));
}

//----- (0000000000025342) ----------------------------------------------------
__int64 __fastcall ssh_packet_set_callbacks(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  if ( !*(_QWORD *)(a1 + 1400) )
    *(_QWORD *)(a1 + 1400) = ssh_list_new();
  result = *(_QWORD *)(a1 + 1400);
  if ( result )
    return ssh_list_append(*(_QWORD *)(a1 + 1400), a2);
  return result;
}

//----- (00000000000253A2) ----------------------------------------------------
__int64 __fastcall ssh_packet_set_default_callbacks(__int64 a1)
{
  *(_BYTE *)(a1 + 1376) = 1;
  *(_BYTE *)(a1 + 1377) = 100;
  *(_QWORD *)(a1 + 1392) = a1;
  *(_QWORD *)(a1 + 1384) = default_packet_handlers;
  return ssh_packet_set_callbacks(a1, a1 + 1376);
}
// 280A60: using guessed type __int64 (__fastcall *default_packet_handlers[6])();

//----- (0000000000025402) ----------------------------------------------------
unsigned __int64 __fastcall ssh_packet_process(
        __int64 a1,
        unsigned __int8 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned __int64 result; // rax
  __int64 v10; // r8
  __int64 v11; // r9
  int v12; // [rsp+1Ch] [rbp-14h]
  unsigned __int64 *v13; // [rsp+20h] [rbp-10h]
  unsigned __int8 *v14; // [rsp+28h] [rbp-8h]

  v12 = 2;
  ssh_log(3, "ssh_packet_process", "Dispatching handler for packet type %d", a2, a5, a6);
  if ( !*(_QWORD *)(a1 + 1400) )
    return ssh_log(1, "ssh_packet_process", "Packet callback is not initialized !", v6, v7, v8);
  result = ssh_list_get_iterator(*(_QWORD *)(a1 + 1400));
  v13 = (unsigned __int64 *)result;
  while ( v13 )
  {
    v14 = (unsigned __int8 *)v13[1];
    result = *v13;
    v13 = (unsigned __int64 *)*v13;
    if ( v14 )
    {
      result = *v14;
      if ( (unsigned __int8)result <= a2 )
      {
        result = a2;
        if ( v14[1] + *v14 > a2 )
        {
          result = *(_QWORD *)(*((_QWORD *)v14 + 1) + 8LL * (a2 - *v14));
          if ( result )
          {
            result = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD))(*((_QWORD *)v14 + 1)
                                                                                + 8LL * (a2 - *v14)))(
                       a1,
                       a2,
                       *(_QWORD *)(a1 + 1128),
                       *((_QWORD *)v14 + 2));
            v12 = result;
            if ( (_DWORD)result == 1 )
              break;
          }
        }
      }
    }
  }
  if ( v12 == 2 )
  {
    ssh_log(1, "ssh_packet_process", "Couldn't do anything with packet type %d", a2, v10, v11);
    return ssh_packet_send_unimplemented(a1, *(_DWORD *)(a1 + 1092) - 1);
  }
  return result;
}
// 25465: variable 'v6' is possibly undefined
// 25465: variable 'v7' is possibly undefined
// 25465: variable 'v8' is possibly undefined
// 2558B: variable 'v10' is possibly undefined
// 2558B: variable 'v11' is possibly undefined

//----- (00000000000255AD) ----------------------------------------------------
__int64 __fastcall ssh_packet_send_unimplemented(__int64 a1, unsigned int a2)
{
  if ( !(unsigned int)ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "bd", 2, 3LL, a2, 1332084403LL) )
    return (unsigned int)ssh_packet_send(a1);
  ssh_set_error_oom(a1, "ssh_packet_send_unimplemented");
  return 0xFFFFFFFFLL;
}

//----- (0000000000025628) ----------------------------------------------------
__int64 __fastcall ssh_packet_unimplemented(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  unsigned int v7; // [rsp+28h] [rbp-8h] BYREF

  if ( (unsigned int)ssh_buffer_unpack(a3, "d", 1, &v7, 1332084403LL) )
    ssh_log(1, "ssh_packet_unimplemented", "Could not unpack SSH_MSG_UNIMPLEMENTED packet", v3, v4, v5);
  ssh_log(1, "ssh_packet_unimplemented", "Received SSH_MSG_UNIMPLEMENTED (sequence number %d)", v7, v4, v5);
  return 1LL;
}
// 2568C: variable 'v3' is possibly undefined
// 2568C: variable 'v4' is possibly undefined
// 2568C: variable 'v5' is possibly undefined

//----- (00000000000256BA) ----------------------------------------------------
__int64 __fastcall ssh_packet_parse_type(__int64 *a1)
{
  __int64 v2; // r8
  __int64 v3; // r9

  memset(a1 + 142, 0, 0xCuLL);
  if ( !a1[141] )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)ssh_buffer_get_u8(a1[141], a1 + 143) )
  {
    *((_DWORD *)a1 + 284) = 1;
    return 0LL;
  }
  else
  {
    ssh_set_error((__int64)a1, 2, "ssh_packet_parse_type", "Packet too short to read type", v2, v3);
    return 0xFFFFFFFFLL;
  }
}
// 2573D: variable 'v2' is possibly undefined
// 2573D: variable 'v3' is possibly undefined

//----- (000000000002575E) ----------------------------------------------------
__int64 __fastcall ssh_packet_write(__int64 a1)
{
  signed int len; // ebx
  const void *v2; // rax

  len = ssh_buffer_get_len(*(_QWORD *)(a1 + 1152));
  v2 = (const void *)ssh_buffer_get(*(_QWORD *)(a1 + 1152));
  return (unsigned int)ssh_socket_write(*(_QWORD *)(a1 + 1048), v2, len);
}

//----- (00000000000257C2) ----------------------------------------------------
__int64 __fastcall packet_send2(__int64 a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  __int64 v4; // r8
  __int64 v5; // r9
  unsigned int v6; // ebx
  const void *v7; // rax
  int v8; // r12d
  unsigned int v9; // ebx
  __int64 v10; // rax
  unsigned int v11; // ebx
  void *v12; // rax
  __int64 v13; // r8
  __int64 v14; // r9
  unsigned int v15; // eax
  unsigned __int8 v17; // [rsp+1Bh] [rbp-75h]
  unsigned int len; // [rsp+1Ch] [rbp-74h]
  int v19; // [rsp+20h] [rbp-70h]
  unsigned int v20; // [rsp+24h] [rbp-6Ch]
  int v21; // [rsp+28h] [rbp-68h]
  int v22; // [rsp+2Ch] [rbp-64h]
  unsigned int v23; // [rsp+30h] [rbp-60h]
  unsigned int v24; // [rsp+3Ch] [rbp-54h]
  const void *v25; // [rsp+40h] [rbp-50h]
  void *v26; // [rsp+48h] [rbp-48h]
  __int64 v27[8]; // [rsp+50h] [rbp-40h] BYREF

  v27[5] = __readfsqword(0x28u);
  if ( *(_QWORD *)(a1 + 1232) )
    v1 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 312LL) + 8LL);
  else
    v1 = 8;
  v20 = v1;
  if ( *(_QWORD *)(a1 + 1232) )
    v2 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 312LL) + 16LL);
  else
    v2 = 0;
  v21 = v2;
  if ( *(_QWORD *)(a1 + 1232) )
    v3 = *(_DWORD *)(*(_QWORD *)(a1 + 1232) + 324LL);
  else
    v3 = *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 324LL);
  v22 = v3;
  len = ssh_buffer_get_len(*(_QWORD *)(a1 + 1152));
  memset(v27, 0, 32);
  v19 = -1;
  v26 = ssh_buffer_new();
  v23 = len;
  if ( *(_QWORD *)(a1 + 1232)
    && *(_DWORD *)(*(_QWORD *)(a1 + 1232) + 336LL)
    && (unsigned int)ssh_buffer_get_len(*(_QWORD *)(a1 + 1152)) )
  {
    if ( (int)compress_buffer(a1, *(_QWORD *)(a1 + 1152)) < 0 )
      goto LABEL_33;
    len = ssh_buffer_get_len(*(_QWORD *)(a1 + 1152));
  }
  v17 = v20 - (v20 - v21 + len + 5) % v20;
  if ( v17 <= 3u )
    v17 += v20;
  if ( !*(_QWORD *)(a1 + 1232) || (unsigned int)ssh_get_random((__int64)v27, v17) )
  {
    if ( v26 )
    {
      v24 = v17 + len + 1;
      v19 = ssh_buffer_pack((__int64)v26, "db", 2, v24, v17, 1332084403LL);
      if ( v19 != -1 )
      {
        v6 = ssh_buffer_get_len((__int64)v26);
        v7 = (const void *)ssh_buffer_get((__int64)v26);
        v19 = ssh_buffer_prepend_data(*(_QWORD *)(a1 + 1152), v7, v6);
        if ( v19 >= 0 )
        {
          v19 = ssh_buffer_add_data(*(_QWORD *)(a1 + 1152), v27, v17);
          if ( v19 >= 0 )
          {
            if ( *(_QWORD *)(a1 + 1456) )
            {
              v8 = ssh_buffer_get_len(*(_QWORD *)(a1 + 1152));
              v9 = ssh_buffer_get_len(*(_QWORD *)(a1 + 1152));
              v10 = ssh_buffer_get(*(_QWORD *)(a1 + 1152));
              ssh_pcap_context_write(*(_QWORD *)(a1 + 1456), 1, v10, v9, v8);
            }
            v11 = ssh_buffer_get_len(*(_QWORD *)(a1 + 1152));
            v12 = (void *)ssh_buffer_get(*(_QWORD *)(a1 + 1152));
            v25 = (const void *)ssh_packet_encrypt(a1, v12, v11, (__int64)v12, v13, v14);
            if ( !v25
              || (v15 = hmac_digest_len(v22), v19 = ssh_buffer_add_data(*(_QWORD *)(a1 + 1152), v25, v15), v19 >= 0) )
            {
              v19 = ssh_packet_write(a1);
              ++*(_DWORD *)(a1 + 1088);
              if ( *(_QWORD *)(a1 + 1688) )
              {
                *(_QWORD *)(*(_QWORD *)(a1 + 1688) + 8LL) += v23;
                ++*(_QWORD *)(*(_QWORD *)(a1 + 1688) + 24LL);
              }
              ssh_log(3, "packet_send2", "packet: wrote [len=%d,padding=%hhd,comp=%d,payload=%d]", v24, v17, len, v23);
              if ( (int)ssh_buffer_reinit(*(_QWORD *)(a1 + 1152)) < 0 )
                v19 = -1;
            }
          }
        }
      }
    }
    else
    {
      ssh_set_error_oom(a1, "packet_send2");
    }
  }
  else
  {
    ssh_set_error(a1, 2, "packet_send2", "PRNG error", v4, v5);
  }
LABEL_33:
  if ( v26 )
    ssh_buffer_free((__int64)v26);
  return (unsigned int)v19;
}
// 259F7: variable 'v4' is possibly undefined
// 259F7: variable 'v5' is possibly undefined
// 25B9E: variable 'v13' is possibly undefined
// 25B9E: variable 'v14' is possibly undefined

//----- (0000000000025D08) ----------------------------------------------------
__int64 __fastcall ssh_packet_send(__int64 a1)
{
  return packet_send2(a1);
}

//----- (0000000000025D22) ----------------------------------------------------
__int64 __fastcall ssh_packet_disconnect_callback(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  const char *v5; // rax
  uint32_t netlong; // [rsp+28h] [rbp-18h] BYREF
  void *ptr; // [rsp+30h] [rbp-10h]
  uint32_t *ssh_string; // [rsp+38h] [rbp-8h]

  netlong = 0;
  ptr = 0LL;
  if ( (unsigned int)ssh_buffer_get_u32(a3, &netlong) )
    netlong = ntohl(netlong);
  ssh_string = (uint32_t *)ssh_buffer_get_ssh_string(a3);
  if ( ssh_string )
  {
    ptr = ssh_string_to_char(ssh_string);
    ssh_string_free(ssh_string);
  }
  if ( ptr )
    v5 = (const char *)ptr;
  else
    v5 = "no error";
  ssh_log(3, "ssh_packet_disconnect_callback", "Received SSH_MSG_DISCONNECT %d:%s", netlong, (__int64)v5, v4, a4);
  if ( ptr )
    ssh_set_error(a1, 2, "ssh_packet_disconnect_callback", "Received SSH_MSG_DISCONNECT: %d:%s", netlong, (__int64)ptr);
  else
    ssh_set_error(
      a1,
      2,
      "ssh_packet_disconnect_callback",
      "Received SSH_MSG_DISCONNECT: %d:%s",
      netlong,
      (__int64)"no error");
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  ssh_socket_close(*(_QWORD *)(a1 + 1048));
  *(_DWORD *)(a1 + 1100) = 0;
  *(_DWORD *)(a1 + 1164) = 9;
  return 1LL;
}
// 25DDA: variable 'v4' is possibly undefined

//----- (0000000000025E6E) ----------------------------------------------------
__int64 __fastcall ssh_packet_ignore_callback(__int64 a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char *v6; // rax

  if ( a2 == 2 )
    v6 = "SSH_MSG_IGNORE";
  else
    v6 = "SSH_MSG_DEBUG";
  ssh_log(2, "ssh_packet_ignore_callback", "Received %s packet", (__int64)v6, a5, a6, a4, a3);
  return 1LL;
}

//----- (0000000000025EC4) ----------------------------------------------------
__int64 __fastcall ssh_packet_dh_reply(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  int v10; // [rsp+2Ch] [rbp-4h]

  ssh_log(2, "ssh_packet_dh_reply", "Received SSH_KEXDH_REPLY", a4, a5, a6, a4);
  if ( *(_DWORD *)(a1 + 1164) == 6 && *(_DWORD *)(a1 + 1172) == 1 )
  {
    switch ( *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) )
    {
      case 1:
      case 2:
        v10 = ssh_client_dh_reply(a1, a3);
        break;
      case 3:
      case 4:
      case 5:
        v10 = ssh_client_ecdh_reply(a1, a3);
        break;
      case 6:
      case 7:
        v10 = ssh_client_curve25519_reply(a1, a3);
        break;
      default:
        ssh_set_error(a1, 2, "ssh_packet_dh_reply", "Wrong kex type in ssh_packet_dh_reply", v6, v7);
        goto LABEL_11;
    }
    if ( !v10 )
    {
      *(_DWORD *)(a1 + 1172) = 2;
      return 1LL;
    }
  }
  else
  {
    ssh_set_error(
      a1,
      2,
      "ssh_packet_dh_reply",
      "ssh_packet_dh_reply called in wrong state : %d:%d",
      *(unsigned int *)(a1 + 1164),
      *(unsigned int *)(a1 + 1172));
  }
LABEL_11:
  *(_DWORD *)(a1 + 1164) = 9;
  return 1LL;
}
// 25FFB: variable 'v6' is possibly undefined
// 25FFB: variable 'v7' is possibly undefined

//----- (0000000000026032) ----------------------------------------------------
__int64 __fastcall ssh_packet_newkeys(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rbx
  int v11; // [rsp+2Ch] [rbp-24h]
  uint32_t *v12; // [rsp+30h] [rbp-20h]
  __int64 next_server_publickey; // [rsp+38h] [rbp-18h]

  ssh_log(2, "ssh_packet_newkeys", "Received SSH_MSG_NEWKEYS", a4, a5, a6, a4, a3);
  if ( *(_DWORD *)(a1 + 1164) == 6 && *(_DWORD *)(a1 + 1172) == 2 )
  {
    if ( *(_DWORD *)(a1 + 1076) )
    {
      *(_DWORD *)(a1 + 1172) = 3;
    }
    else
    {
      if ( (unsigned int)ssh_make_sessionid(a1)
        || (int)crypt_set_algorithms_client(a1) < 0
        || (int)ssh_generate_session_keys(a1) < 0 )
      {
        goto LABEL_23;
      }
      v12 = *(uint32_t **)(*(_QWORD *)(a1 + 1240) + 160LL);
      *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 160LL) = 0LL;
      next_server_publickey = ssh_dh_get_next_server_publickey(a1);
      if ( !next_server_publickey )
        return 0xFFFFFFFFLL;
      if ( *(_QWORD *)(a1 + 1528)
        && !ssh_match_group(*(const char **)(a1 + 1528), *(const char **)(next_server_publickey + 8)) )
      {
        ssh_set_error(
          a1,
          2,
          "ssh_packet_newkeys",
          "Public key from server (%s) doesn't match user preference (%s)",
          *(_QWORD *)(next_server_publickey + 8),
          *(_QWORD *)(a1 + 1528));
        return 0xFFFFFFFFLL;
      }
      v11 = ssh_pki_signature_verify_blob(
              a1,
              v12,
              (_DWORD *)next_server_publickey,
              *(void **)(*(_QWORD *)(a1 + 1240) + 184LL),
              *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 168LL));
      ssh_string_burn(v12);
      ssh_string_free(v12);
      if ( v11 == -1 )
        goto LABEL_23;
      ssh_log(2, "ssh_packet_newkeys", "Signature verified and valid", v7, v8, v9);
      if ( *(_QWORD *)(a1 + 1232) )
      {
        crypto_free(*(_QWORD **)(a1 + 1232));
        *(_QWORD *)(a1 + 1232) = 0LL;
      }
      *(_QWORD *)(a1 + 1232) = *(_QWORD *)(a1 + 1240);
      *(_QWORD *)(a1 + 1240) = crypto_new();
      if ( !*(_QWORD *)(a1 + 1240)
        || (v10 = *(_QWORD *)(a1 + 1240),
            *(_QWORD *)(v10 + 176) = malloc(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 168LL)),
            !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 176LL)) )
      {
        ssh_set_error_oom(a1, "ssh_packet_newkeys");
        goto LABEL_23;
      }
      memcpy(
        *(void **)(*(_QWORD *)(a1 + 1240) + 176LL),
        *(const void **)(*(_QWORD *)(a1 + 1232) + 176LL),
        *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 168LL));
      if ( (*(int (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 304LL) + 72LL))(
             *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 304LL),
             *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 208LL),
             *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 200LL)) < 0
        || (*(int (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 312LL) + 64LL))(
             *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 312LL),
             *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 216LL),
             *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 192LL)) < 0 )
      {
        goto LABEL_23;
      }
    }
    *(_DWORD *)(a1 + 1172) = 3;
    (*(void (__fastcall **)(__int64))(a1 + 1368))(a1);
    return 1LL;
  }
  ssh_set_error(
    a1,
    2,
    "ssh_packet_newkeys",
    "ssh_packet_newkeys called in wrong state : %d:%d",
    *(unsigned int *)(a1 + 1164),
    *(unsigned int *)(a1 + 1172));
LABEL_23:
  *(_DWORD *)(a1 + 1164) = 9;
  return 1LL;
}
// 2627F: variable 'v7' is possibly undefined
// 2627F: variable 'v8' is possibly undefined
// 2627F: variable 'v9' is possibly undefined

//----- (00000000000264A4) ----------------------------------------------------
__int64 __fastcall ssh_packet_service_accept(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  *(_DWORD *)(a1 + 1176) = 2;
  ssh_log(3, "ssh_packet_service_accept", "Received SSH_MSG_SERVICE_ACCEPT", a4, a5, a6, a4, a3);
  return 1LL;
}

//----- (00000000000264EF) ----------------------------------------------------
uint32_t __fastcall ssh_packet_decrypt_len(__int64 a1, uint32_t *a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( *(_QWORD *)(a1 + 1232) )
  {
    if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 304LL) + 104LL) )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD *, uint32_t *, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 304LL)
                                                                           + 104LL))(
        *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 304LL),
        a3,
        a2,
        *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 304LL) + 16LL),
        *(unsigned int *)(a1 + 1092));
    }
    else if ( (int)ssh_packet_decrypt(
                     a1,
                     (__int64)a2,
                     (__int64)a3,
                     0LL,
                     *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 304LL) + 8LL),
                     a6) < 0 )
    {
      return 0;
    }
  }
  else
  {
    *(_QWORD *)a2 = *a3;
  }
  return ntohl(*a2);
}

//----- (00000000000265F0) ----------------------------------------------------
__int64 __fastcall ssh_packet_decrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5, __int64 a6)
{
  __int64 v7; // [rsp+38h] [rbp-8h]

  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 304LL);
  if ( !a5 )
    return 0xFFFFFFFFLL;
  if ( a5 % *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 304LL) + 8LL) )
  {
    ssh_set_error(
      a1,
      2,
      "ssh_packet_decrypt",
      "Cryptographic functions must be used on multiple of blocksize (received %zd)",
      a5,
      a6);
    return 0xFFFFFFFFLL;
  }
  else if ( *(_QWORD *)(v7 + 112) )
  {
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64, unsigned __int64, _QWORD))(v7 + 112))(
             v7,
             a3,
             a2,
             a5,
             *(unsigned int *)(a1 + 1092));
  }
  else
  {
    (*(void (__fastcall **)(__int64, __int64, __int64, unsigned __int64))(v7 + 88))(v7, a3 + a4, a2, a5);
    return 0LL;
  }
}

//----- (00000000000266EF) ----------------------------------------------------
__int64 __fastcall ssh_packet_encrypt(__int64 a1, void *a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v7; // eax
  int v9; // [rsp+2Ch] [rbp-24h] BYREF
  uint32_t v10; // [rsp+30h] [rbp-20h] BYREF
  int v11; // [rsp+34h] [rbp-1Ch]
  __int64 v12; // [rsp+38h] [rbp-18h]
  __int64 v13; // [rsp+40h] [rbp-10h]
  void *ptr; // [rsp+48h] [rbp-8h]

  v12 = 0LL;
  v13 = 0LL;
  ptr = 0LL;
  if ( !a3 )
    __assert_fail("len", "/usr/src/src/packet_crypt.c", 0x84u, "ssh_packet_encrypt");
  if ( !*(_QWORD *)(a1 + 1232) )
    return 0LL;
  if ( (a3 - *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 312LL) + 16LL))
     % *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 312LL) + 8LL) )
  {
    ssh_set_error(
      a1,
      2,
      "ssh_packet_encrypt",
      "Cryptographic functions must be set on at least one blocksize (received %d)",
      a3,
      a6);
    return 0LL;
  }
  ptr = malloc(a3);
  if ( !ptr )
    return 0LL;
  v11 = *(_DWORD *)(*(_QWORD *)(a1 + 1232) + 324LL);
  v10 = ntohl(*(_DWORD *)(a1 + 1088));
  v12 = *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 312LL);
  if ( *(_QWORD *)(v12 + 96) )
  {
    (*(void (__fastcall **)(__int64, void *, void *, _QWORD, __int64, _QWORD))(v12 + 96))(
      v12,
      a2,
      ptr,
      a3,
      *(_QWORD *)(a1 + 1232) + 240LL,
      *(unsigned int *)(a1 + 1088));
  }
  else
  {
    v7 = hmac_digest_len(v11);
    v13 = hmac_init(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 224LL), v7, v11);
    if ( !v13 )
    {
      free(ptr);
      ptr = 0LL;
      return 0LL;
    }
    hmac_update(v13, (__int64)&v10, 4LL);
    hmac_update(v13, (__int64)a2, a3);
    hmac_final(v13, (void *)(*(_QWORD *)(a1 + 1232) + 240LL), &v9);
    (*(void (__fastcall **)(__int64, void *, void *, _QWORD))(v12 + 80))(v12, a2, ptr, a3);
  }
  memcpy(a2, ptr, a3);
  explicit_bzero(ptr, a3);
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  return *(_QWORD *)(a1 + 1232) + 240LL;
}
// 268AE: conditional instruction was optimized away because %ptr.8!=0

//----- (0000000000026990) ----------------------------------------------------
__int64 __fastcall ssh_packet_hmac_verify(__int64 a1, __int64 a2, const void *a3, int a4)
{
  int v5; // eax
  __int64 len; // rbx
  __int64 v7; // rax
  unsigned int n; // [rsp+20h] [rbp-70h] BYREF
  uint32_t n_4; // [rsp+24h] [rbp-6Ch] BYREF
  __int64 v12; // [rsp+28h] [rbp-68h]
  char s2[72]; // [rsp+30h] [rbp-60h] BYREF
  unsigned __int64 v14; // [rsp+78h] [rbp-18h]

  v14 = __readfsqword(0x28u);
  memset(s2, 0, 0x40uLL);
  if ( a4 == 6 )
    return 0LL;
  v5 = hmac_digest_len(a4);
  v12 = hmac_init(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 232LL), v5, a4);
  if ( !v12 )
    return 0xFFFFFFFFLL;
  n_4 = htonl(*(_DWORD *)(a1 + 1092));
  hmac_update(v12, (__int64)&n_4, 4LL);
  len = (unsigned int)ssh_buffer_get_len(a2);
  v7 = ssh_buffer_get(a2);
  hmac_update(v12, v7, len);
  hmac_final(v12, s2, &n);
  if ( !memcmp(a3, s2, n) )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000026AE8) ----------------------------------------------------
void *ssh_pcap_file_new()
{
  void *s; // [rsp+8h] [rbp-8h]

  s = malloc(0x10uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x10uLL);
  return s;
}

//----- (0000000000026B2F) ----------------------------------------------------
__int64 __fastcall ssh_pcap_file_write(FILE **a1, __int64 a2)
{
  FILE *v3; // r12
  const void *v4; // rax
  unsigned int size; // [rsp+18h] [rbp-18h]

  if ( !a1 || !*a1 )
    return 0xFFFFFFFFLL;
  size = ssh_buffer_get_len(a2);
  v3 = *a1;
  v4 = (const void *)ssh_buffer_get(a2);
  if ( (fwrite(v4, size, 1uLL, v3) & 0x80000000) == 0LL )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000026BB2) ----------------------------------------------------
__int64 __fastcall ssh_pcap_file_write_packet(FILE **a1, __int64 a2, uint32_t a3)
{
  int len; // eax
  int v5; // eax
  int v6; // eax
  uint32_t v7; // eax
  int v8; // eax
  int v9; // eax
  int size; // [rsp+24h] [rbp-1Ch]
  void *v12; // [rsp+28h] [rbp-18h]
  struct timeval tv; // [rsp+30h] [rbp-10h] BYREF

  v12 = ssh_buffer_new();
  if ( !v12 )
    return 0xFFFFFFFFLL;
  gettimeofday(&tv, 0LL);
  len = ssh_buffer_get_len(a2);
  size = ssh_buffer_allocate_size((__int64)v12, len + 16);
  if ( size >= 0 )
  {
    v5 = htonl(tv.tv_sec);
    size = ssh_buffer_add_u32((__int64)v12, v5);
    if ( size >= 0 )
    {
      v6 = htonl(tv.tv_usec);
      size = ssh_buffer_add_u32((__int64)v12, v6);
      if ( size >= 0 )
      {
        v7 = ssh_buffer_get_len(a2);
        v8 = htonl(v7);
        size = ssh_buffer_add_u32((__int64)v12, v8);
        if ( size >= 0 )
        {
          v9 = htonl(a3);
          size = ssh_buffer_add_u32((__int64)v12, v9);
          if ( size >= 0 )
          {
            size = ssh_buffer_add_buffer((__int64)v12, a2);
            if ( size >= 0 )
              size = ssh_pcap_file_write(a1, (__int64)v12);
          }
        }
      }
    }
  }
  ssh_buffer_free((__int64)v12);
  return (unsigned int)size;
}

//----- (0000000000026D0E) ----------------------------------------------------
__int64 __fastcall ssh_pcap_file_open(FILE **a1, const char *a2)
{
  int v3; // eax
  __int16 v4; // ax
  __int16 v5; // ax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int size; // [rsp+14h] [rbp-Ch]
  void *v11; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *a1 )
  {
    fclose(*a1);
    *a1 = 0LL;
  }
  *a1 = fopen(a2, "wb");
  if ( !*a1 )
    return 0xFFFFFFFFLL;
  v11 = ssh_buffer_new();
  if ( !v11 )
    return 0xFFFFFFFFLL;
  size = ssh_buffer_allocate_size((__int64)v11, 0x18u);
  if ( size >= 0 )
  {
    v3 = htonl(0xA1B2C3D4);
    size = ssh_buffer_add_u32((__int64)v11, v3);
    if ( size >= 0 )
    {
      v4 = htons(2u);
      size = ssh_buffer_add_u16((__int64)v11, v4);
      if ( size >= 0 )
      {
        v5 = htons(4u);
        size = ssh_buffer_add_u16((__int64)v11, v5);
        if ( size >= 0 )
        {
          v6 = htonl(0);
          size = ssh_buffer_add_u32((__int64)v11, v6);
          if ( size >= 0 )
          {
            v7 = htonl(0);
            size = ssh_buffer_add_u32((__int64)v11, v7);
            if ( size >= 0 )
            {
              v8 = htonl((uint32_t)&loc_40000);
              size = ssh_buffer_add_u32((__int64)v11, v8);
              if ( size >= 0 )
              {
                v9 = htonl(0xCu);
                size = ssh_buffer_add_u32((__int64)v11, v9);
                if ( size >= 0 )
                  size = ssh_pcap_file_write(a1, (__int64)v11);
              }
            }
          }
        }
      }
    }
  }
  ssh_buffer_free((__int64)v11);
  return (unsigned int)size;
}

//----- (0000000000026F06) ----------------------------------------------------
__int64 __fastcall ssh_pcap_file_close(FILE **a1)
{
  int v2; // [rsp+1Ch] [rbp-4h]

  if ( !a1 || !*a1 )
    return 0xFFFFFFFFLL;
  v2 = fclose(*a1);
  *a1 = 0LL;
  if ( v2 )
    return 0xFFFFFFFFLL;
  else
    return 0LL;
}

//----- (0000000000026F5D) ----------------------------------------------------
void __fastcall ssh_pcap_file_free(FILE **a1)
{
  ssh_pcap_file_close(a1);
  if ( a1 )
    free(a1);
}

//----- (0000000000026F93) ----------------------------------------------------
_QWORD *__fastcall ssh_pcap_context_new(__int64 a1)
{
  _QWORD *s; // [rsp+18h] [rbp-8h]

  s = malloc(0x28uLL);
  if ( s )
  {
    memset(s, 0, 0x28uLL);
    *s = a1;
    return s;
  }
  else
  {
    ssh_set_error_oom(a1, "ssh_pcap_context_new");
    return 0LL;
  }
}

//----- (0000000000026FFC) ----------------------------------------------------
void __fastcall ssh_pcap_context_free(void *a1)
{
  if ( a1 )
    free(a1);
}

//----- (0000000000027026) ----------------------------------------------------
__int64 __fastcall ssh_pcap_context_set_file(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a1;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

//----- (0000000000027041) ----------------------------------------------------
__int64 __fastcall ssh_pcap_context_connect(__int64 a1)
{
  int *v2; // rax
  char *v3; // rax
  __int64 v4; // r9
  __int64 v5; // r8
  __int64 v6; // r9
  int *v7; // rax
  char *v8; // rax
  __int64 v9; // r9
  socklen_t len; // [rsp+10h] [rbp-40h] BYREF
  int fd; // [rsp+14h] [rbp-3Ch]
  __int64 v12; // [rsp+18h] [rbp-38h]
  struct sockaddr addr; // [rsp+20h] [rbp-30h] BYREF
  struct sockaddr v14; // [rsp+30h] [rbp-20h] BYREF
  unsigned __int64 v15; // [rsp+48h] [rbp-8h]

  v15 = __readfsqword(0x28u);
  v12 = *(_QWORD *)a1;
  if ( !v12 )
    return 0xFFFFFFFFLL;
  if ( !*(_QWORD *)(v12 + 1048) )
    return 0xFFFFFFFFLL;
  fd = ssh_socket_get_fd_in(*(unsigned int **)(v12 + 1048));
  if ( fd < 0 )
    return 0xFFFFFFFFLL;
  len = 16;
  if ( getsockname(fd, &addr, &len) >= 0 )
  {
    len = 16;
    if ( getpeername(fd, &v14, &len) >= 0 )
    {
      if ( addr.sa_family == 2 )
      {
        *(_DWORD *)(a1 + 20) = *(_DWORD *)&addr.sa_data[2];
        *(_DWORD *)(a1 + 24) = *(_DWORD *)&v14.sa_data[2];
        *(_WORD *)(a1 + 28) = *(_WORD *)addr.sa_data;
        *(_WORD *)(a1 + 30) = *(_WORD *)v14.sa_data;
        *(_DWORD *)(a1 + 16) = 1;
        return 0LL;
      }
      else
      {
        ssh_set_error(v12, 1, "ssh_pcap_context_connect", "Only IPv4 supported for pcap logging", v5, v6);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      v7 = __errno_location();
      v8 = strerror(*v7);
      ssh_set_error(v12, 1, "ssh_pcap_context_connect", "Getting remote IP address: %s", (__int64)v8, v9);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v2 = __errno_location();
    v3 = strerror(*v2);
    ssh_set_error(v12, 1, "ssh_pcap_context_connect", "Getting local IP address: %s", (__int64)v3, v4);
    return 0xFFFFFFFFLL;
  }
}
// 2710B: variable 'v4' is possibly undefined
// 2716D: variable 'v9' is possibly undefined
// 271A2: variable 'v5' is possibly undefined
// 271A2: variable 'v6' is possibly undefined

//----- (000000000002720C) ----------------------------------------------------
__int64 __fastcall ssh_pcap_context_write(__int64 a1, int a2, __int64 a3, unsigned int a4, int a5)
{
  int v9; // [rsp+24h] [rbp-Ch]
  void *v10; // [rsp+28h] [rbp-8h]

  if ( !a1 || !*(_QWORD *)(a1 + 8) )
    return 0xFFFFFFFFLL;
  if ( !*(_DWORD *)(a1 + 16) && (unsigned int)ssh_pcap_context_connect(a1) == -1 )
    return 0xFFFFFFFFLL;
  v10 = ssh_buffer_new();
  if ( !v10 )
  {
    ssh_set_error_oom(*(_QWORD *)a1, "ssh_pcap_context_write");
    return 0xFFFFFFFFLL;
  }
  v9 = ssh_buffer_pack(
         (__int64)v10,
         "bbwwwbbw",
         8,
         69LL,
         0LL,
         (unsigned int)(a5 + 40),
         *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 8LL),
         0LL,
         64LL,
         6LL,
         0LL,
         1332084403LL);
  ++*(_WORD *)(*(_QWORD *)(a1 + 8) + 8LL);
  if ( !v9 )
  {
    if ( a2 == 1 )
    {
      v9 = ssh_buffer_add_u32((__int64)v10, *(_DWORD *)(a1 + 20));
      if ( v9 < 0 )
        goto LABEL_33;
      v9 = ssh_buffer_add_u32((__int64)v10, *(_DWORD *)(a1 + 24));
      if ( v9 < 0 )
        goto LABEL_33;
    }
    else
    {
      v9 = ssh_buffer_add_u32((__int64)v10, *(_DWORD *)(a1 + 24));
      if ( v9 < 0 )
        goto LABEL_33;
      v9 = ssh_buffer_add_u32((__int64)v10, *(_DWORD *)(a1 + 20));
      if ( v9 < 0 )
        goto LABEL_33;
    }
    if ( a2 == 1 )
    {
      v9 = ssh_buffer_add_u16((__int64)v10, *(_WORD *)(a1 + 28));
      if ( v9 < 0 )
        goto LABEL_33;
      v9 = ssh_buffer_add_u16((__int64)v10, *(_WORD *)(a1 + 30));
      if ( v9 < 0 )
        goto LABEL_33;
    }
    else
    {
      v9 = ssh_buffer_add_u16((__int64)v10, *(_WORD *)(a1 + 30));
      if ( v9 < 0 )
        goto LABEL_33;
      v9 = ssh_buffer_add_u16((__int64)v10, *(_WORD *)(a1 + 28));
      if ( v9 < 0 )
        goto LABEL_33;
    }
    if ( a2 == 1 )
    {
      v9 = ssh_buffer_pack((__int64)v10, "d", 1, *(unsigned int *)(a1 + 32), 1332084403LL);
      if ( v9 )
        goto LABEL_33;
      *(_DWORD *)(a1 + 32) += a5;
    }
    else
    {
      v9 = ssh_buffer_pack((__int64)v10, "d", 1, *(unsigned int *)(a1 + 36), 1332084403LL);
      if ( v9 )
        goto LABEL_33;
      *(_DWORD *)(a1 + 36) += a5;
    }
    if ( a2 == 1 )
    {
      v9 = ssh_buffer_pack((__int64)v10, "d", 1, *(unsigned int *)(a1 + 36), 1332084403LL);
      if ( v9 )
        goto LABEL_33;
LABEL_31:
      v9 = ssh_buffer_pack((__int64)v10, "bbwwwP", 7, 80LL, 24LL, 0xFFFFLL, 0LL, 0LL, a4, a3, 1332084403LL);
      if ( !v9 )
        v9 = ssh_pcap_file_write_packet(*(FILE ***)(a1 + 8), (__int64)v10, a5 + 40);
      goto LABEL_33;
    }
    v9 = ssh_buffer_pack((__int64)v10, "d", 1, *(unsigned int *)(a1 + 32), 1332084403LL);
    if ( !v9 )
      goto LABEL_31;
  }
LABEL_33:
  ssh_buffer_free((__int64)v10);
  return (unsigned int)v9;
}

//----- (00000000000275F4) ----------------------------------------------------
__int64 __fastcall ssh_set_pcap_file(__int64 a1, __int64 a2)
{
  _QWORD *v3; // [rsp+18h] [rbp-8h]

  v3 = ssh_pcap_context_new(a1);
  if ( v3 )
  {
    v3[1] = a2;
    if ( *(_QWORD *)(a1 + 1456) )
      ssh_pcap_context_free(*(void **)(a1 + 1456));
    *(_QWORD *)(a1 + 1456) = v3;
    return 0LL;
  }
  else
  {
    ssh_set_error_oom(a1, "ssh_set_pcap_file");
    return 0xFFFFFFFFLL;
  }
}

//----- (000000000002767A) ----------------------------------------------------
__int64 __fastcall pki_privatekey_type_from_string(const char *a1)
{
  if ( !strncmp(a1, "-----BEGIN DSA PRIVATE KEY-----", 0x1FuLL) )
    return 1LL;
  if ( !strncmp(a1, "-----BEGIN RSA PRIVATE KEY-----", 0x1FuLL) )
    return 2LL;
  if ( !strncmp(a1, "-----BEGIN EC PRIVATE KEY-----", 0x1EuLL) )
    return 4LL;
  return 0LL;
}

//----- (00000000000276F6) ----------------------------------------------------
const char *__fastcall ssh_pki_key_ecdsa_name(__int64 a1)
{
  return pki_key_ecdsa_nid_to_name(*(_DWORD *)(a1 + 16));
}

//----- (0000000000027712) ----------------------------------------------------
void *ssh_key_new()
{
  void *s; // [rsp+8h] [rbp-8h]

  s = malloc(0x50uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x50uLL);
  return s;
}

//----- (0000000000027759) ----------------------------------------------------
_QWORD *__fastcall ssh_key_dup(__int64 a1)
{
  if ( a1 )
    return pki_key_dup(a1, 0);
  else
    return 0LL;
}

//----- (0000000000027786) ----------------------------------------------------
__int64 __fastcall ssh_key_clean(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 24) )
      gcry_sexp_release(*(_QWORD *)(a1 + 24));
    if ( *(_QWORD *)(a1 + 32) )
      gcry_sexp_release(*(_QWORD *)(a1 + 32));
    if ( *(_QWORD *)(a1 + 40) )
      gcry_sexp_release(*(_QWORD *)(a1 + 40));
    if ( *(_QWORD *)(a1 + 56) )
    {
      explicit_bzero(*(void **)(a1 + 56), 0x40uLL);
      if ( *(_QWORD *)(a1 + 56) )
      {
        free(*(void **)(a1 + 56));
        *(_QWORD *)(a1 + 56) = 0LL;
      }
    }
    if ( *(_QWORD *)(a1 + 48) )
    {
      free(*(void **)(a1 + 48));
      *(_QWORD *)(a1 + 48) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 64) )
      ssh_buffer_free(*(_QWORD *)(a1 + 64));
    *(_DWORD *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 8) = 0LL;
    *(_QWORD *)(a1 + 24) = 0LL;
    *(_QWORD *)(a1 + 32) = 0LL;
    result = a1;
    *(_QWORD *)(a1 + 40) = 0LL;
  }
  return result;
}
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);

//----- (00000000000278E5) ----------------------------------------------------
void __fastcall ssh_key_free(void *a1)
{
  if ( a1 )
  {
    ssh_key_clean((__int64)a1);
    free(a1);
  }
}

//----- (0000000000027922) ----------------------------------------------------
__int64 __fastcall ssh_key_type(unsigned int *a1)
{
  if ( a1 )
    return *a1;
  else
    return 0LL;
}

//----- (0000000000027940) ----------------------------------------------------
const char *__fastcall ssh_key_type_to_char(int a1)
{
  const char *result; // rax

  switch ( a1 )
  {
    case 0:
    case 3:
      result = 0LL;
      break;
    case 1:
      result = "ssh-dss";
      break;
    case 2:
      result = "ssh-rsa";
      break;
    case 4:
      result = "ssh-ecdsa";
      break;
    case 5:
      result = "ssh-ed25519";
      break;
    case 6:
      result = "ssh-dss-cert-v01@openssh.com";
      break;
    case 7:
      result = "ssh-rsa-cert-v01@openssh.com";
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}

//----- (00000000000279B5) ----------------------------------------------------
__int64 __fastcall ssh_key_type_from_name(const char *a1)
{
  if ( !a1 )
    return 0LL;
  if ( !strcmp(a1, "rsa") )
    return 2LL;
  if ( !strcmp(a1, "dsa") )
    return 1LL;
  if ( !strcmp(a1, "ssh-rsa") )
    return 2LL;
  if ( !strcmp(a1, "ssh-dss") )
    return 1LL;
  if ( !strcmp(a1, "ssh-ecdsa")
    || !strcmp(a1, "ecdsa")
    || !strcmp(a1, "ecdsa-sha2-nistp256")
    || !strcmp(a1, "ecdsa-sha2-nistp384")
    || !strcmp(a1, "ecdsa-sha2-nistp521") )
  {
    return 4LL;
  }
  if ( !strcmp(a1, "ssh-ed25519") )
    return 5LL;
  if ( !strcmp(a1, "ssh-dss-cert-v01@openssh.com") )
    return 6LL;
  if ( !strcmp(a1, "ssh-rsa-cert-v01@openssh.com") )
    return 7LL;
  return 0LL;
}

//----- (0000000000027B31) ----------------------------------------------------
_BOOL8 __fastcall ssh_key_is_public(__int64 a1)
{
  return a1 && (*(_DWORD *)(a1 + 4) & 1) != 0;
}

//----- (0000000000027B5B) ----------------------------------------------------
_BOOL8 __fastcall ssh_key_is_private(__int64 a1)
{
  return a1 && (*(_DWORD *)(a1 + 4) & 2) != 0;
}

//----- (0000000000027B85) ----------------------------------------------------
__int64 __fastcall ssh_key_cmp(_DWORD *a1, _DWORD *a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( !a1 || !a2 )
    return 1LL;
  if ( *a1 == *a2 )
  {
    if ( a3 != 1 || ssh_key_is_private((__int64)a1) && ssh_key_is_private((__int64)a2) )
    {
      if ( *a1 == 5 )
        return pki_ed25519_key_cmp((__int64)a1, (__int64)a2, a3);
      else
        return pki_key_compare((__int64)a1, (__int64)a2, a3);
    }
    else
    {
      return 1LL;
    }
  }
  else
  {
    ssh_log(1, "ssh_key_cmp", "key types don't match!", a4, a5, a6);
    return 1LL;
  }
}

//----- (0000000000027C4C) ----------------------------------------------------
void *ssh_signature_new()
{
  void *s; // [rsp+8h] [rbp-8h]

  s = malloc(0x30uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x30uLL);
  return s;
}

//----- (0000000000027C93) ----------------------------------------------------
void __fastcall ssh_signature_free(void *a1)
{
  if ( a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 1:
        gcry_sexp_release(*((_QWORD *)a1 + 2));
        break;
      case 2:
        gcry_sexp_release(*((_QWORD *)a1 + 3));
        break;
      case 4:
        gcry_sexp_release(*((_QWORD *)a1 + 4));
        break;
      case 5:
        if ( *((_QWORD *)a1 + 5) )
        {
          free(*((void **)a1 + 5));
          *((_QWORD *)a1 + 5) = 0LL;
        }
        break;
      default:
        break;
    }
    free(a1);
  }
}
// 27D46: conditional instruction was optimized away because rdi.8!=0
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);

//----- (0000000000027D61) ----------------------------------------------------
__int64 __fastcall ssh_pki_import_privkey_base64(
        char *a1,
        char *a2,
        __int64 (__fastcall *a3)(const char *, char *, __int64, _QWORD, _QWORD, __int64),
        const char *a4,
        _QWORD *a5,
        __int64 a6)
{
  const char *v7; // rax
  void *v11; // [rsp+38h] [rbp-8h]

  if ( !a1 || !a5 )
    return 0xFFFFFFFFLL;
  if ( !*a1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
    v7 = "true";
  else
    v7 = "false";
  ssh_log(2, "ssh_pki_import_privkey_base64", "Trying to decode privkey passphrase=%s", (__int64)v7, (__int64)a5, a6);
  if ( !strncmp(a1, "-----BEGIN OPENSSH PRIVATE KEY-----", 0x23uLL) )
    v11 = ssh_pki_openssh_privkey_import(a1, a2, a3, (__int64)a4);
  else
    v11 = pki_private_key_from_base64(
            a1,
            a2,
            (int (__fastcall *)(__int64, char *, __int64, _QWORD, _QWORD, const char *))a3,
            a4);
  if ( !v11 )
    return 0xFFFFFFFFLL;
  *a5 = v11;
  return 0LL;
}
// 27D9A: conditional instruction was optimized away because rdi.8!=0

//----- (0000000000027E63) ----------------------------------------------------
__int64 __fastcall ssh_pki_import_privkey_file(
        const char *a1,
        char *a2,
        __int64 (__fastcall *a3)(const char *, char *, __int64, _QWORD, _QWORD, __int64),
        const char *a4,
        _QWORD *a5)
{
  int *v6; // rax
  char *v7; // rax
  __int64 v8; // r9
  int v9; // eax
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  int *v13; // rax
  char *v14; // rax
  __int64 v15; // r9
  int v16; // eax
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // r9
  int *v21; // rax
  char *v22; // rax
  __int64 v23; // r9
  unsigned int v27; // [rsp+34h] [rbp-ACh]
  FILE *stream; // [rsp+38h] [rbp-A8h]
  void *ptr; // [rsp+40h] [rbp-A0h]
  size_t v30; // [rsp+48h] [rbp-98h]
  struct stat stat_buf; // [rsp+50h] [rbp-90h] BYREF

  if ( !a5 || !a1 || !*a1 )
    return 0xFFFFFFFFLL;
  stream = fopen(a1, "rb");
  if ( stream )
  {
    v9 = fileno(stream);
    if ( fstat(v9, &stat_buf) >= 0 )
    {
      if ( stat_buf.st_size <= 0x400000 )
      {
        ptr = malloc(stat_buf.st_size + 1);
        if ( ptr )
        {
          v30 = fread(ptr, 1uLL, stat_buf.st_size, stream);
          fclose(stream);
          if ( stat_buf.st_size == v30 )
          {
            *((_BYTE *)ptr + v30) = 0;
            v27 = ssh_pki_import_privkey_base64((char *)ptr, a2, a3, a4, a5, v20);
            free(ptr);
            return v27;
          }
          else
          {
            free(ptr);
            v21 = __errno_location();
            v22 = strerror(*v21);
            ssh_log(1, "ssh_pki_import_privkey_file", "Error reading %s: %s", (__int64)a1, (__int64)v22, v23);
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          fclose(stream);
          ssh_log(1, "ssh_pki_import_privkey_file", "Out of memory!", v17, v18, v19);
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        ssh_log(1, "ssh_pki_import_privkey_file", "Private key is bigger than 4M.", v10, v11, v12);
        fclose(stream);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      fclose(stream);
      v13 = __errno_location();
      v14 = strerror(*v13);
      ssh_log(1, "ssh_pki_import_privkey_file", "Error getting stat of %s: %s", (__int64)a1, (__int64)v14, v15);
      v16 = *__errno_location();
      if ( v16 == 2 || v16 == 13 )
        return 4294967169LL;
      else
        return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v6 = __errno_location();
    v7 = strerror(*v6);
    ssh_log(1, "ssh_pki_import_privkey_file", "Error opening %s: %s", (__int64)a1, (__int64)v7, v8);
    return 4294967169LL;
  }
}
// 280B5: conditional instruction was optimized away because %ptr.8!=0
// 28163: conditional instruction was optimized away because %ptr.8!=0
// 27F1A: variable 'v8' is possibly undefined
// 27F9F: variable 'v15' is possibly undefined
// 27FED: variable 'v10' is possibly undefined
// 27FED: variable 'v11' is possibly undefined
// 27FED: variable 'v12' is possibly undefined
// 28053: variable 'v17' is possibly undefined
// 28053: variable 'v18' is possibly undefined
// 28053: variable 'v19' is possibly undefined
// 28107: variable 'v23' is possibly undefined
// 28150: variable 'v20' is possibly undefined

//----- (0000000000028187) ----------------------------------------------------
__int64 __fastcall ssh_pki_export_privkey_file(
        _DWORD *a1,
        char *a2,
        unsigned int (__fastcall *a3)(const char *, char *, __int64, _QWORD, _QWORD, __int64),
        __int64 a4,
        const char *a5)
{
  __int64 v6; // r8
  __int64 v7; // r9
  int *v8; // rax
  char *v9; // rax
  __int64 v10; // r9
  __int64 v11; // rbx
  const void *v12; // rax
  int v16; // [rsp+3Ch] [rbp-24h]
  uint32_t *v17; // [rsp+40h] [rbp-20h]
  FILE *stream; // [rsp+48h] [rbp-18h]

  if ( !a1 || !ssh_key_is_private((__int64)a1) )
    return 0xFFFFFFFFLL;
  stream = fopen(a5, "wb");
  if ( stream )
  {
    if ( *a1 == 5 )
      v17 = (uint32_t *)ssh_pki_openssh_privkey_export((__int64)a1, a2, a3, a4, v6, v7);
    else
      v17 = (uint32_t *)pki_private_key_to_pem(a1, a2, a3, a4);
    if ( v17 )
    {
      v11 = ssh_string_len(v17);
      v12 = (const void *)ssh_string_data((__int64)v17);
      v16 = fwrite(v12, v11, 1uLL, stream);
      ssh_string_free(v17);
      if ( v16 == 1 && !ferror(stream) )
      {
        fclose(stream);
        return 0LL;
      }
      else
      {
        fclose(stream);
        unlink(a5);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      fclose(stream);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v8 = __errno_location();
    v9 = strerror(*v8);
    ssh_log(4, "ssh_pki_export_privkey_file", "Error opening %s: %s", (__int64)a5, (__int64)v9, v10);
    return 4294967169LL;
  }
}
// 28216: variable 'v10' is possibly undefined
// 28243: variable 'v6' is possibly undefined
// 28243: variable 'v7' is possibly undefined
// 3B84C: using guessed type __int64 __fastcall pki_private_key_to_pem(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000028315) ----------------------------------------------------
_QWORD *__fastcall ssh_pki_convert_key_to_publickey(__int64 a1)
{
  _QWORD *v2; // [rsp+10h] [rbp-10h]
  _QWORD *s; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  v2 = ssh_key_dup(a1);
  if ( !v2 )
    return 0LL;
  s = malloc(0x20uLL);
  if ( s )
  {
    memset(s, 0, 0x20uLL);
    *(_DWORD *)s = *(_DWORD *)v2;
    s[1] = v2[1];
    s[2] = v2[3];
    v2[3] = 0LL;
    s[3] = v2[4];
    v2[4] = 0LL;
    ssh_key_free(v2);
    return s;
  }
  else
  {
    ssh_key_free(v2);
    return 0LL;
  }
}

//----- (0000000000028403) ----------------------------------------------------
_QWORD *__fastcall ssh_pki_convert_key_to_privatekey(_QWORD *a1)
{
  _QWORD *v2; // [rsp+18h] [rbp-8h]

  v2 = malloc(0x18uLL);
  if ( v2 )
  {
    *(_DWORD *)v2 = *(_DWORD *)a1;
    v2[1] = a1[3];
    v2[2] = a1[4];
    return v2;
  }
  else
  {
    ssh_key_free(a1);
    return 0LL;
  }
}

//----- (000000000002846B) ----------------------------------------------------
__int64 __fastcall pki_import_pubkey_buffer(__int64 a1, unsigned int a2, _QWORD *a3)
{
  __int64 v4; // r8
  __int64 v5; // r9
  uint32_t *v6; // rax
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  const void *v10; // rax
  int v12; // [rsp+28h] [rbp-58h]
  int v13; // [rsp+28h] [rbp-58h]
  int v14; // [rsp+28h] [rbp-58h]
  int v15; // [rsp+2Ch] [rbp-54h]
  void *v16; // [rsp+30h] [rbp-50h]
  uint32_t *v17; // [rsp+38h] [rbp-48h]
  uint32_t *v18; // [rsp+40h] [rbp-40h]
  uint32_t *v19; // [rsp+48h] [rbp-38h]
  uint32_t *v20; // [rsp+50h] [rbp-30h]
  uint32_t *ssh_string; // [rsp+58h] [rbp-28h]
  uint32_t *v22; // [rsp+60h] [rbp-20h]
  uint32_t *v23; // [rsp+68h] [rbp-18h]
  uint32_t *v24; // [rsp+70h] [rbp-10h]
  uint32_t *v25; // [rsp+78h] [rbp-8h]

  v16 = ssh_key_new();
  if ( !v16 )
    return 0xFFFFFFFFLL;
  *(_DWORD *)v16 = a2;
  *((_QWORD *)v16 + 1) = ssh_key_type_to_char(a2);
  *((_DWORD *)v16 + 1) = 1;
  if ( a2 == 2 )
  {
    ssh_string = (uint32_t *)ssh_buffer_get_ssh_string(a1);
    if ( !ssh_string )
      goto LABEL_36;
    v22 = (uint32_t *)ssh_buffer_get_ssh_string(a1);
    if ( !v22 )
    {
      ssh_string_burn(ssh_string);
      ssh_string_free(ssh_string);
      goto LABEL_36;
    }
    v13 = pki_pubkey_build_rsa((__int64)v16, ssh_string, v22);
    ssh_string_burn(ssh_string);
    ssh_string_free(ssh_string);
    ssh_string_burn(v22);
    ssh_string_free(v22);
    if ( v13 == -1 )
      goto LABEL_36;
    goto LABEL_35;
  }
  if ( a2 > 2 )
  {
    if ( a2 == 4 )
    {
      v23 = (uint32_t *)ssh_buffer_get_ssh_string(a1);
      if ( !v23 )
        goto LABEL_36;
      v6 = ssh_string_get_char(v23);
      v15 = pki_key_ecdsa_nid_from_name((const char *)v6);
      ssh_string_free(v23);
      if ( v15 == -1 )
        goto LABEL_36;
      v24 = (uint32_t *)ssh_buffer_get_ssh_string(a1);
      if ( !v24 )
        goto LABEL_36;
      v14 = pki_pubkey_build_ecdsa((__int64)v16, v15, v24);
      ssh_string_burn(v24);
      ssh_string_free(v24);
      if ( v14 < 0 )
        goto LABEL_36;
      *((_QWORD *)v16 + 1) = ssh_pki_key_ecdsa_name((__int64)v16);
    }
    else
    {
      if ( a2 != 5 )
        goto LABEL_34;
      v25 = (uint32_t *)ssh_buffer_get_ssh_string(a1);
      if ( ssh_string_len(v25) != 32 )
      {
        ssh_log(1, "pki_import_pubkey_buffer", "Invalid public key length", v7, v8, v9);
        ssh_string_burn(v25);
        ssh_string_free(v25);
        goto LABEL_36;
      }
      *((_QWORD *)v16 + 6) = malloc(0x20uLL);
      if ( !*((_QWORD *)v16 + 6) )
      {
        ssh_string_burn(v25);
        ssh_string_free(v25);
        goto LABEL_36;
      }
      v10 = (const void *)ssh_string_data((__int64)v25);
      memcpy(*((void **)v16 + 6), v10, 0x20uLL);
      ssh_string_burn(v25);
      ssh_string_free(v25);
    }
    goto LABEL_35;
  }
  if ( a2 != 1 )
  {
LABEL_34:
    ssh_log(1, "pki_import_pubkey_buffer", "Unknown public key protocol %d", a2, v4, v5);
    goto LABEL_36;
  }
  v17 = (uint32_t *)ssh_buffer_get_ssh_string(a1);
  if ( v17 )
  {
    v18 = (uint32_t *)ssh_buffer_get_ssh_string(a1);
    if ( !v18 )
    {
      ssh_string_burn(v17);
      ssh_string_free(v17);
      goto LABEL_36;
    }
    v19 = (uint32_t *)ssh_buffer_get_ssh_string(a1);
    if ( !v19 )
    {
      ssh_string_burn(v17);
      ssh_string_free(v17);
      ssh_string_burn(v18);
      ssh_string_free(v18);
      goto LABEL_36;
    }
    v20 = (uint32_t *)ssh_buffer_get_ssh_string(a1);
    if ( !v20 )
    {
      ssh_string_burn(v17);
      ssh_string_free(v17);
      ssh_string_burn(v18);
      ssh_string_free(v18);
      ssh_string_burn(v19);
      ssh_string_free(v19);
      goto LABEL_36;
    }
    v12 = pki_pubkey_build_dss((__int64)v16, v17, v18, v19, v20);
    ssh_string_burn(v17);
    ssh_string_free(v17);
    ssh_string_burn(v18);
    ssh_string_free(v18);
    ssh_string_burn(v19);
    ssh_string_free(v19);
    ssh_string_burn(v20);
    ssh_string_free(v20);
    if ( v12 == -1 )
      goto LABEL_36;
LABEL_35:
    *a3 = v16;
    return 0LL;
  }
LABEL_36:
  ssh_key_free(v16);
  return 0xFFFFFFFFLL;
}
// 2881E: variable 'v7' is possibly undefined
// 2881E: variable 'v8' is possibly undefined
// 2881E: variable 'v9' is possibly undefined
// 288DD: variable 'v4' is possibly undefined
// 288DD: variable 'v5' is possibly undefined

//----- (000000000002891D) ----------------------------------------------------
__int64 __fastcall pki_import_cert_buffer(__int64 a1, int a2, _QWORD *a3)
{
  int v5; // [rsp+24h] [rbp-1Ch]
  _QWORD *v6; // [rsp+28h] [rbp-18h]
  void *v7; // [rsp+30h] [rbp-10h]
  uint32_t *v8; // [rsp+38h] [rbp-8h]

  v6 = ssh_key_new();
  if ( !v6 )
    return 0xFFFFFFFFLL;
  v7 = ssh_buffer_new();
  if ( v7 )
  {
    *(_DWORD *)v6 = a2;
    v6[1] = ssh_key_type_to_char(a2);
    *((_DWORD *)v6 + 1) = 1;
    v8 = (uint32_t *)ssh_string_from_char((const char *)v6[1]);
    if ( !v8
      || (v5 = ssh_buffer_add_ssh_string((__int64)v7, v8), ssh_string_free(v8), v5)
      || (unsigned int)ssh_buffer_add_buffer((__int64)v7, a1) )
    {
      ssh_key_free(v6);
      ssh_buffer_free((__int64)v7);
      return 0xFFFFFFFFLL;
    }
    else
    {
      v6[8] = v7;
      *a3 = v6;
      return 0LL;
    }
  }
  else
  {
    ssh_key_free(v6);
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000028A3C) ----------------------------------------------------
__int64 __fastcall ssh_pki_import_pubkey_base64(const char *a1, unsigned int a2, _QWORD *a3)
{
  unsigned int v5; // [rsp+2Ch] [rbp-14h]
  void *v6; // [rsp+30h] [rbp-10h]
  void *ssh_string; // [rsp+38h] [rbp-8h]

  if ( !a1 || !a3 )
    return 0xFFFFFFFFLL;
  v6 = base64_to_bin(a1);
  if ( !v6 )
    return 0xFFFFFFFFLL;
  ssh_string = ssh_buffer_get_ssh_string((__int64)v6);
  if ( ssh_string )
  {
    ssh_string_free(ssh_string);
    if ( a2 == 7 || a2 == 6 )
      v5 = pki_import_cert_buffer((__int64)v6, a2, a3);
    else
      v5 = pki_import_pubkey_buffer((__int64)v6, a2, a3);
    ssh_buffer_free((__int64)v6);
    return v5;
  }
  else
  {
    ssh_buffer_free((__int64)v6);
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000028B0D) ----------------------------------------------------
__int64 __fastcall ssh_pki_import_pubkey_blob(uint32_t *a1, _QWORD *a2)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  unsigned int v6; // ebx
  const void *v7; // rax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  uint32_t *v11; // rax
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  unsigned int v15; // [rsp+18h] [rbp-28h]
  unsigned int v16; // [rsp+1Ch] [rbp-24h]
  void *ssh_string; // [rsp+20h] [rbp-20h]
  void *v18; // [rsp+28h] [rbp-18h]

  ssh_string = 0LL;
  if ( !a1 || !a2 )
    return 0xFFFFFFFFLL;
  v18 = ssh_buffer_new();
  if ( !v18 )
  {
    ssh_log(1, "ssh_pki_import_pubkey_blob", "Out of memory!", v3, v4, v5);
    return 0xFFFFFFFFLL;
  }
  v6 = ssh_string_len(a1);
  v7 = (const void *)ssh_string_data((__int64)a1);
  if ( (int)ssh_buffer_add_data((__int64)v18, v7, v6) < 0
    || (ssh_string = ssh_buffer_get_ssh_string((__int64)v18)) == 0LL )
  {
    ssh_log(1, "ssh_pki_import_pubkey_blob", "Out of memory!", v8, v9, v10);
LABEL_16:
    ssh_buffer_free((__int64)v18);
    ssh_string_free(ssh_string);
    return 0xFFFFFFFFLL;
  }
  v11 = ssh_string_get_char((uint32_t *)ssh_string);
  v16 = ssh_key_type_from_name((const char *)v11);
  if ( !v16 )
  {
    ssh_log(1, "ssh_pki_import_pubkey_blob", "Unknown key type found!", v12, v13, v14);
    goto LABEL_16;
  }
  ssh_string_free(ssh_string);
  if ( v16 == 7 || v16 == 6 )
    v15 = pki_import_cert_buffer((__int64)v18, v16, a2);
  else
    v15 = pki_import_pubkey_buffer((__int64)v18, v16, a2);
  ssh_buffer_free((__int64)v18);
  return v15;
}
// 28B66: variable 'v3' is possibly undefined
// 28B66: variable 'v4' is possibly undefined
// 28B66: variable 'v5' is possibly undefined
// 28BC4: variable 'v8' is possibly undefined
// 28BC4: variable 'v9' is possibly undefined
// 28BC4: variable 'v10' is possibly undefined
// 28C3C: variable 'v12' is possibly undefined
// 28C3C: variable 'v13' is possibly undefined
// 28C3C: variable 'v14' is possibly undefined

//----- (0000000000028CC2) ----------------------------------------------------
__int64 __fastcall ssh_pki_import_pubkey_file(const char *a1, _QWORD *a2)
{
  int *v3; // rax
  char *v4; // rax
  __int64 v5; // r9
  int v6; // eax
  int *v7; // rax
  char *v8; // rax
  __int64 v9; // r9
  int v10; // eax
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  int *v14; // rax
  char *v15; // rax
  __int64 v16; // r9
  unsigned int v17; // [rsp+10h] [rbp-D0h]
  unsigned int v18; // [rsp+14h] [rbp-CCh]
  size_t i; // [rsp+18h] [rbp-C8h]
  FILE *stream; // [rsp+20h] [rbp-C0h]
  char *ptr; // [rsp+28h] [rbp-B8h]
  size_t v22; // [rsp+30h] [rbp-B0h]
  size_t v23; // [rsp+38h] [rbp-A8h]
  const char *v24; // [rsp+48h] [rbp-98h]
  struct stat stat_buf; // [rsp+50h] [rbp-90h] BYREF

  if ( !a2 || !a1 || !*a1 )
    return 0xFFFFFFFFLL;
  stream = fopen(a1, "rb");
  if ( stream )
  {
    v6 = fileno(stream);
    if ( fstat(v6, &stat_buf) >= 0 )
    {
      if ( stat_buf.st_size <= 0x100000 )
      {
        ptr = (char *)malloc(stat_buf.st_size + 1);
        if ( ptr )
        {
          v22 = fread(ptr, 1uLL, stat_buf.st_size, stream);
          fclose(stream);
          if ( stat_buf.st_size == v22 )
          {
            ptr[v22] = 0;
            v23 = strlen(ptr);
            for ( i = 0LL; i < v23; ++i )
            {
              if ( ((*__ctype_b_loc())[ptr[i]] & 0x2000) != 0 )
              {
                ptr[i] = 0;
                break;
              }
            }
            v18 = ssh_key_type_from_name(ptr);
            if ( v18 )
            {
              v24 = &ptr[i + 1];
              while ( i < v23 )
              {
                if ( ((*__ctype_b_loc())[ptr[i]] & 0x2000) != 0 )
                {
                  ptr[i] = 0;
                  break;
                }
                ++i;
              }
              v17 = ssh_pki_import_pubkey_base64(v24, v18, a2);
              free(ptr);
              return v17;
            }
            else
            {
              free(ptr);
              return 0xFFFFFFFFLL;
            }
          }
          else
          {
            free(ptr);
            v14 = __errno_location();
            v15 = strerror(*v14);
            ssh_log(1, "ssh_pki_import_pubkey_file", "Error reading %s: %s", (__int64)a1, (__int64)v15, v16);
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          fclose(stream);
          ssh_log(1, "ssh_pki_import_pubkey_file", "Out of memory!", v11, v12, v13);
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        fclose(stream);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      fclose(stream);
      v7 = __errno_location();
      v8 = strerror(*v7);
      ssh_log(1, "ssh_pki_import_pubkey_file", "Error gettint stat of %s: %s", (__int64)a1, (__int64)v8, v9);
      v10 = *__errno_location();
      if ( v10 == 2 || v10 == 13 )
        return 4294967169LL;
      else
        return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v3 = __errno_location();
    v4 = strerror(*v3);
    ssh_log(1, "ssh_pki_import_pubkey_file", "Error opening %s: %s", (__int64)a1, (__int64)v4, v5);
    return 4294967169LL;
  }
}
// 28EE2: conditional instruction was optimized away because %ptr.8!=0
// 2901F: conditional instruction was optimized away because %ptr.8!=0
// 290F2: conditional instruction was optimized away because %ptr.8!=0
// 28D64: variable 'v5' is possibly undefined
// 28DE9: variable 'v9' is possibly undefined
// 28E80: variable 'v11' is possibly undefined
// 28E80: variable 'v12' is possibly undefined
// 28E80: variable 'v13' is possibly undefined
// 28F34: variable 'v16' is possibly undefined

//----- (0000000000029116) ----------------------------------------------------
__int64 __fastcall ssh_pki_import_cert_base64(const char *a1, unsigned int a2, _QWORD *a3)
{
  return ssh_pki_import_pubkey_base64(a1, a2, a3);
}

//----- (0000000000029140) ----------------------------------------------------
__int64 __fastcall ssh_pki_import_cert_blob(uint32_t *a1, _QWORD *a2)
{
  return ssh_pki_import_pubkey_blob(a1, a2);
}

//----- (0000000000029165) ----------------------------------------------------
__int64 __fastcall ssh_pki_import_cert_file(const char *a1, _QWORD *a2)
{
  return ssh_pki_import_pubkey_file(a1, a2);
}

//----- (000000000002918A) ----------------------------------------------------
__int64 __fastcall ssh_pki_generate(unsigned int a1, unsigned int a2, _QWORD *a3)
{
  _QWORD *v5; // [rsp+18h] [rbp-8h]

  v5 = ssh_key_new();
  if ( !v5 )
    return 0xFFFFFFFFLL;
  *(_DWORD *)v5 = a1;
  v5[1] = ssh_key_type_to_char(a1);
  *((_DWORD *)v5 + 1) = 3;
  if ( a1 == 2 )
  {
    if ( (unsigned int)pki_key_generate_rsa((__int64)v5, a2) != -1 )
      goto LABEL_17;
  }
  else
  {
    if ( a1 <= 2 )
    {
      if ( a1 != 1 || (unsigned int)pki_key_generate_dss((__int64)v5, a2) == -1 )
        goto LABEL_18;
LABEL_17:
      *a3 = v5;
      return 0LL;
    }
    if ( a1 != 4 )
    {
      if ( a1 != 5 || (unsigned int)pki_key_generate_ed25519((__int64)v5) == -1 )
        goto LABEL_18;
      goto LABEL_17;
    }
    if ( (unsigned int)pki_key_generate_ecdsa((__int64)v5, a2) != -1 )
    {
      v5[1] = ssh_pki_key_ecdsa_name((__int64)v5);
      goto LABEL_17;
    }
  }
LABEL_18:
  ssh_key_free(v5);
  return 0xFFFFFFFFLL;
}

//----- (00000000000292B7) ----------------------------------------------------
__int64 __fastcall ssh_pki_export_privkey_to_pubkey(__int64 a1, _QWORD *a2)
{
  _QWORD *v3; // [rsp+18h] [rbp-8h]

  if ( !a1 || !ssh_key_is_private(a1) )
    return 0xFFFFFFFFLL;
  v3 = pki_key_dup(a1, 1);
  if ( !v3 )
    return 0xFFFFFFFFLL;
  *a2 = v3;
  return 0LL;
}

//----- (000000000002931A) ----------------------------------------------------
__int64 __fastcall ssh_pki_export_pubkey_blob(__int64 a1, uint32_t **a2)
{
  uint32_t *v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  v3 = pki_publickey_to_blob(a1);
  if ( !v3 )
    return 0xFFFFFFFFLL;
  *a2 = v3;
  return 0LL;
}

//----- (0000000000029368) ----------------------------------------------------
__int64 __fastcall ssh_pki_export_pubkey_base64(__int64 a1, _QWORD *a2)
{
  int v3; // ebx
  _BYTE *v4; // rax
  uint32_t *v5; // [rsp+10h] [rbp-20h]
  _BYTE *v6; // [rsp+18h] [rbp-18h]

  if ( !a1 || !a2 )
    return 0xFFFFFFFFLL;
  v5 = pki_publickey_to_blob(a1);
  if ( !v5 )
    return 0xFFFFFFFFLL;
  v3 = ssh_string_len(v5);
  v4 = (_BYTE *)ssh_string_data((__int64)v5);
  v6 = bin_to_base64(v4, v3);
  ssh_string_free(v5);
  if ( !v6 )
    return 0xFFFFFFFFLL;
  *a2 = v6;
  return 0LL;
}

//----- (0000000000029405) ----------------------------------------------------
__int64 __fastcall ssh_pki_export_pubkey_file(__int64 a1, const char *a2)
{
  size_t v3; // rax
  int v4; // [rsp+14h] [rbp-112Ch]
  void *v5; // [rsp+18h] [rbp-1128h] BYREF
  void *ptr; // [rsp+20h] [rbp-1120h]
  FILE *stream; // [rsp+28h] [rbp-1118h]
  char name[256]; // [rsp+30h] [rbp-1110h] BYREF
  char s[4104]; // [rsp+130h] [rbp-1010h] BYREF
  unsigned __int64 v10; // [rsp+1138h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  if ( !a1 || !a2 || !*a2 )
    return 0xFFFFFFFFLL;
  ptr = ssh_get_local_username();
  if ( !ptr )
    return 0xFFFFFFFFLL;
  if ( gethostname(name, 0x100uLL) >= 0 )
  {
    if ( (int)ssh_pki_export_pubkey_base64(a1, &v5) >= 0 )
    {
      v4 = snprintf(s, 0x1000uLL, "%s %s %s@%s\n", *(const char **)(a1 + 8), (const char *)v5, (const char *)ptr, name);
      free(ptr);
      free(v5);
      if ( v4 >= 0 )
      {
        stream = fopen(a2, "wb+");
        if ( stream )
        {
          v3 = strlen(s);
          if ( (unsigned int)fwrite(s, v3, 1uLL, stream) == 1 && !ferror(stream) )
          {
            fclose(stream);
            return 0LL;
          }
          else
          {
            fclose(stream);
            unlink(a2);
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      free(ptr);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    free(ptr);
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000029651) ----------------------------------------------------
__int64 __fastcall ssh_pki_copy_cert_to_privkey(__int64 a1, __int64 a2)
{
  void *v3; // [rsp+18h] [rbp-8h]

  if ( !a1 || !a2 )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a2 + 64) )
    return 0xFFFFFFFFLL;
  if ( !*(_QWORD *)(a1 + 64) )
    return 0xFFFFFFFFLL;
  v3 = ssh_buffer_new();
  if ( !v3 )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)ssh_buffer_add_buffer((__int64)v3, *(_QWORD *)(a1 + 64)) )
  {
    ssh_buffer_free((__int64)v3);
    return 0xFFFFFFFFLL;
  }
  else
  {
    *(_QWORD *)(a2 + 64) = v3;
    *(_DWORD *)(a2 + 72) = *(_DWORD *)a1;
    return 0LL;
  }
}

//----- (000000000002970B) ----------------------------------------------------
__int64 __fastcall ssh_pki_export_signature_blob(__int64 a1, uint32_t **a2)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  unsigned int v7; // eax
  size_t len; // rbx
  const void *v9; // rax
  int v10; // [rsp+1Ch] [rbp-24h]
  int v11; // [rsp+1Ch] [rbp-24h]
  void *v12; // [rsp+20h] [rbp-20h]
  uint32_t *v13; // [rsp+28h] [rbp-18h]
  uint32_t *v14; // [rsp+28h] [rbp-18h]
  uint32_t *v15; // [rsp+28h] [rbp-18h]

  if ( !a1 || !a2 )
    return 0xFFFFFFFFLL;
  v12 = ssh_buffer_new();
  if ( !v12 )
    return 0xFFFFFFFFLL;
  v13 = (uint32_t *)ssh_string_from_char(*(const char **)(a1 + 8));
  if ( v13
    && (v10 = ssh_buffer_add_ssh_string((__int64)v12, v13), ssh_string_free(v13), v10 >= 0)
    && (v14 = pki_signature_to_blob((unsigned int *)a1, (__int64)v13, v3, v4, v5, v6)) != 0LL
    && (v11 = ssh_buffer_add_ssh_string((__int64)v12, v14), ssh_string_free(v14), v11 >= 0)
    && (v7 = ssh_buffer_get_len((__int64)v12), (v15 = (uint32_t *)ssh_string_new(v7)) != 0LL) )
  {
    len = (unsigned int)ssh_buffer_get_len((__int64)v12);
    v9 = (const void *)ssh_buffer_get((__int64)v12);
    ssh_string_fill(v15, v9, len);
    ssh_buffer_free((__int64)v12);
    *a2 = v15;
    return 0LL;
  }
  else
  {
    ssh_buffer_free((__int64)v12);
    return 0xFFFFFFFFLL;
  }
}
// 297CC: variable 'v3' is possibly undefined
// 297CC: variable 'v4' is possibly undefined
// 297CC: variable 'v5' is possibly undefined
// 297CC: variable 'v6' is possibly undefined

//----- (00000000000298B3) ----------------------------------------------------
__int64 __fastcall ssh_pki_import_signature_blob(uint32_t *a1, __int64 a2, _QWORD *a3)
{
  unsigned int v4; // ebx
  const void *v5; // rax
  uint32_t *v6; // rax
  unsigned int v8; // [rsp+24h] [rbp-2Ch]
  void *v9; // [rsp+28h] [rbp-28h]
  uint32_t *v10; // [rsp+30h] [rbp-20h]
  uint32_t *ssh_string; // [rsp+30h] [rbp-20h]
  _DWORD *v12; // [rsp+38h] [rbp-18h]

  if ( !a1 || !a3 )
    return 0xFFFFFFFFLL;
  v9 = ssh_buffer_new();
  if ( !v9 )
    return 0xFFFFFFFFLL;
  v4 = ssh_string_len(a1);
  v5 = (const void *)ssh_string_data((__int64)a1);
  if ( (int)ssh_buffer_add_data((__int64)v9, v5, v4) >= 0
    && (v10 = (uint32_t *)ssh_buffer_get_ssh_string((__int64)v9)) != 0LL )
  {
    v6 = ssh_string_get_char(v10);
    v8 = ssh_key_type_from_name((const char *)v6);
    ssh_string_free(v10);
    ssh_string = (uint32_t *)ssh_buffer_get_ssh_string((__int64)v9);
    ssh_buffer_free((__int64)v9);
    if ( ssh_string )
    {
      v12 = pki_signature_from_blob(a2, ssh_string, v8);
      ssh_string_free(ssh_string);
      if ( v12 )
      {
        *a3 = v12;
        return 0LL;
      }
      else
      {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_buffer_free((__int64)v9);
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000029A0C) ----------------------------------------------------
__int64 __fastcall ssh_pki_signature_verify_blob(__int64 a1, uint32_t *a2, _DWORD *a3, void *a4, __int64 a5)
{
  __int64 v5; // r8
  __int64 v6; // r9
  unsigned int v11; // [rsp+30h] [rbp-60h] BYREF
  unsigned int v12; // [rsp+34h] [rbp-5Ch]
  _QWORD *v13; // [rsp+38h] [rbp-58h] BYREF
  __int64 v14[10]; // [rsp+40h] [rbp-50h] BYREF

  v14[9] = __readfsqword(0x28u);
  v12 = ssh_pki_import_signature_blob(a2, (__int64)a3, &v13);
  if ( (v12 & 0x80000000) != 0 )
    return 0xFFFFFFFFLL;
  ssh_log(4, "ssh_pki_signature_verify_blob", "Going to verify a %s type signature", v13[1], v5, v6);
  if ( *a3 == 4 )
  {
    memset(v14, 0, 0x40uLL);
    evp(a3[4], (__int64)a4, a5, (__int64)v14, &v11);
    v12 = pki_signature_verify(a1, v13, a3, v14, v11);
  }
  else if ( *a3 == 5 )
  {
    v12 = pki_signature_verify(a1, v13, a3, a4, a5);
  }
  else
  {
    memset(v14, 0, 20);
    sha1((__int64)a4, a5, (__int64)v14);
    v12 = pki_signature_verify(a1, v13, a3, v14, 20LL);
  }
  ssh_signature_free(v13);
  return v12;
}
// 29A8A: variable 'v5' is possibly undefined
// 29A8A: variable 'v6' is possibly undefined

//----- (0000000000029BAB) ----------------------------------------------------
uint32_t *__fastcall ssh_pki_do_sign(__int64 a1, __int64 a2, _DWORD *a3)
{
  __int64 v3; // rax
  __int64 v5; // rax
  __int64 len; // rbx
  __int64 v7; // rax
  __int64 v8; // rbx
  unsigned int v9; // eax
  size_t v10; // rbx
  void *v11; // rax
  __int64 v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rax
  int v16; // [rsp+24h] [rbp-9Ch]
  uint32_t *v17; // [rsp+28h] [rbp-98h] BYREF
  _QWORD *v18; // [rsp+30h] [rbp-90h]
  __int64 v19; // [rsp+38h] [rbp-88h]
  uint32_t *v20; // [rsp+40h] [rbp-80h]
  __int64 v21; // [rsp+48h] [rbp-78h]
  void *v22; // [rsp+50h] [rbp-70h]
  __int64 v23; // [rsp+58h] [rbp-68h]
  __int64 v24[11]; // [rsp+60h] [rbp-60h] BYREF

  v24[9] = __readfsqword(0x28u);
  if ( *(_QWORD *)(a1 + 1232) )
    v3 = *(_QWORD *)(a1 + 1232);
  else
    v3 = *(_QWORD *)(a1 + 1240);
  v19 = v3;
  v18 = 0LL;
  if ( !a3 || !ssh_key_is_private((__int64)a3) )
    return 0LL;
  v20 = (uint32_t *)ssh_string_new(*(_QWORD *)(v19 + 168));
  if ( !v20 )
    return 0LL;
  ssh_string_fill(v20, *(const void **)(v19 + 176), *(_QWORD *)(v19 + 168));
  if ( *a3 == 4 )
  {
    memset(v24, 0, 0x40uLL);
    v21 = evp_init(a3[4]);
    if ( !v21 )
    {
      ssh_string_free(v20);
      return 0LL;
    }
    v5 = ssh_string_len(v20);
    evp_update(v21, (__int64)v20, v5 + 4);
    len = (unsigned int)ssh_buffer_get_len(a2);
    v7 = ssh_buffer_get(a2);
    evp_update(v21, v7, len);
    evp_final(v21, v24, &v17);
    v18 = pki_do_sign((__int64)a3, v24, (unsigned int)v17);
    goto LABEL_21;
  }
  if ( *a3 == 5 )
  {
    v22 = ssh_buffer_new();
    if ( !v22 )
    {
LABEL_15:
      ssh_string_free(v20);
      return 0LL;
    }
    ssh_buffer_set_secure((__int64)v22);
    v8 = ssh_buffer_get(a2);
    v9 = ssh_buffer_get_len(a2);
    if ( (unsigned int)ssh_buffer_pack((__int64)v22, "SP", 3, v20, v9, v8, 1332084403LL) )
    {
      ssh_string_free(v20);
      ssh_buffer_free((__int64)v22);
      return 0LL;
    }
    v10 = (unsigned int)ssh_buffer_get_len((__int64)v22);
    v11 = (void *)ssh_buffer_get((__int64)v22);
    v18 = pki_do_sign((__int64)a3, v11, v10);
    ssh_buffer_free((__int64)v22);
  }
  else
  {
    memset(v24, 0, 20);
    v23 = sha1_init();
    if ( !v23 )
      goto LABEL_15;
    v12 = ssh_string_len(v20);
    sha1_update(v23, (__int64)v20, v12 + 4);
    v13 = (unsigned int)ssh_buffer_get_len(a2);
    v14 = ssh_buffer_get(a2);
    sha1_update(v23, v14, v13);
    sha1_final(v24, v23);
    v18 = pki_do_sign((__int64)a3, v24, 0x14uLL);
  }
LABEL_21:
  ssh_string_free(v20);
  if ( !v18 )
    return 0LL;
  v16 = ssh_pki_export_signature_blob((__int64)v18, &v17);
  ssh_signature_free(v18);
  if ( v16 >= 0 )
    return v17;
  else
    return 0LL;
}
// 381DB: using guessed type __int64 sha1_init(void);

//----- (0000000000029FEE) ----------------------------------------------------
void *__fastcall ssh_pki_do_sign_agent(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // [rsp+30h] [rbp-20h]
  uint32_t *v6; // [rsp+38h] [rbp-18h]
  void *v7; // [rsp+40h] [rbp-10h]
  void *v8; // [rsp+48h] [rbp-8h]

  if ( *(_QWORD *)(a1 + 1232) )
    v5 = *(_QWORD *)(a1 + 1232);
  else
    v5 = *(_QWORD *)(a1 + 1240);
  v6 = (uint32_t *)ssh_string_new(*(_QWORD *)(v5 + 168));
  if ( !v6 )
    return 0LL;
  ssh_string_fill(v6, *(const void **)(v5 + 176), *(_QWORD *)(v5 + 168));
  v7 = ssh_buffer_new();
  if ( v7 )
  {
    if ( (int)ssh_buffer_add_ssh_string((__int64)v7, v6) >= 0 )
    {
      ssh_string_free(v6);
      if ( (int)ssh_buffer_add_buffer((__int64)v7, a2) >= 0 )
      {
        v8 = ssh_agent_sign_data(a1, a3, (__int64)v7);
        ssh_buffer_free((__int64)v7);
        return v8;
      }
      else
      {
        ssh_buffer_free((__int64)v7);
        return 0LL;
      }
    }
    else
    {
      ssh_string_free(v6);
      ssh_buffer_free((__int64)v7);
      return 0LL;
    }
  }
  else
  {
    ssh_string_free(v6);
    return 0LL;
  }
}

//----- (000000000002A143) ----------------------------------------------------
uint32_t *__fastcall ssh_srv_pki_do_sign_sessionid(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v5; // rax
  int v6; // [rsp+1Ch] [rbp-74h]
  uint32_t *v7; // [rsp+20h] [rbp-70h] BYREF
  _QWORD *v8; // [rsp+28h] [rbp-68h]
  __int64 v9; // [rsp+30h] [rbp-60h]
  __int64 v10; // [rsp+38h] [rbp-58h]
  __int64 v11[10]; // [rsp+40h] [rbp-50h] BYREF

  v11[9] = __readfsqword(0x28u);
  v8 = 0LL;
  if ( !a1 || !a2 || !ssh_key_is_private(a2) )
    return 0LL;
  if ( *(_QWORD *)(a1 + 1240) )
    v5 = *(_QWORD *)(a1 + 1240);
  else
    v5 = *(_QWORD *)(a1 + 1232);
  v9 = v5;
  if ( !*(_QWORD *)(v5 + 184) )
  {
    ssh_set_error(a1, 2, "ssh_srv_pki_do_sign_sessionid", "Missing secret_hash", v2, v3);
    return 0LL;
  }
  if ( *(_DWORD *)a2 == 4 )
  {
    memset(v11, 0, 0x40uLL);
    evp(*(_DWORD *)(a2 + 16), *(_QWORD *)(v9 + 184), *(_QWORD *)(v9 + 168), (__int64)v11, &v7);
    v8 = pki_do_sign_sessionid(a2, v11, (unsigned int)v7);
    if ( !v8 )
      return 0LL;
  }
  else if ( *(_DWORD *)a2 == 5 )
  {
    v8 = ssh_signature_new();
    if ( !v8 )
      return 0LL;
    *(_DWORD *)v8 = *(_DWORD *)a2;
    v8[1] = *(_QWORD *)(a2 + 8);
    if ( (unsigned int)pki_ed25519_sign(a2, (__int64)v8, *(_QWORD *)(v9 + 184), *(_QWORD *)(v9 + 168)) )
    {
      ssh_signature_free(v8);
      v8 = 0LL;
    }
  }
  else
  {
    memset(v11, 0, 20);
    v10 = sha1_init();
    if ( !v10 )
      return 0LL;
    sha1_update(v10, *(_QWORD *)(v9 + 184), *(_QWORD *)(v9 + 168));
    sha1_final(v11, v10);
    v8 = pki_do_sign_sessionid(a2, v11, 0x14uLL);
    if ( !v8 )
      return 0LL;
  }
  v6 = ssh_pki_export_signature_blob((__int64)v8, &v7);
  ssh_signature_free(v8);
  if ( v6 >= 0 )
    return v7;
  else
    return 0LL;
}
// 2A20B: variable 'v2' is possibly undefined
// 2A20B: variable 'v3' is possibly undefined
// 381DB: using guessed type __int64 sha1_init(void);

//----- (000000000002A429) ----------------------------------------------------
__int64 __fastcall pki_openssh_import_privkey_blob(__int64 a1, _QWORD *a2)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  const void *v20; // rax
  const void *v21; // rax
  void *v22; // rax
  __int64 v23; // rbx
  void *v24; // rax
  int v25; // [rsp+1Ch] [rbp-34h]
  void *ptr; // [rsp+20h] [rbp-30h] BYREF
  void *v27; // [rsp+28h] [rbp-28h] BYREF
  void *v28; // [rsp+30h] [rbp-20h] BYREF
  void *v29; // [rsp+38h] [rbp-18h]

  ptr = 0LL;
  v29 = 0LL;
  v27 = 0LL;
  v28 = 0LL;
  if ( !a2 )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)ssh_buffer_unpack(a1, "s", 1, &ptr, 1332084403LL) == -1 )
  {
    ssh_log(1, "pki_openssh_import_privkey_blob", "Unpack error", v3, v4, v5);
    return 0xFFFFFFFFLL;
  }
  v25 = ssh_key_type_from_name((const char *)ptr);
  if ( !v25 )
  {
    ssh_log(1, "pki_openssh_import_privkey_blob", "Unknown key type found!", v6, v7, v8);
    return 0xFFFFFFFFLL;
  }
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  v29 = ssh_key_new();
  if ( !v29 )
  {
    ssh_log(1, "pki_openssh_import_privkey_blob", "Out of memory", v9, v10, v11);
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)v29 = v25;
  *((_QWORD *)v29 + 1) = ssh_key_type_to_char(v25);
  *((_DWORD *)v29 + 1) = 3;
  switch ( v25 )
  {
    case 0:
    case 3:
      ssh_log(1, "pki_openssh_import_privkey_blob", "Unknown private key protocol %s", *((_QWORD *)v29 + 1), v12, v13);
      goto LABEL_26;
    case 1:
    case 2:
    case 4:
    case 6:
    case 7:
      ssh_log(1, "pki_openssh_import_privkey_blob", "Unsupported private key method %s", *((_QWORD *)v29 + 1), v12, v13);
      goto LABEL_26;
    case 5:
      if ( (unsigned int)ssh_buffer_unpack(a1, "SS", 2, &v27, &v28, 1332084403LL) )
      {
        ssh_log(1, "pki_openssh_import_privkey_blob", "Unpack error", v14, v15, v16);
LABEL_26:
        ssh_key_free(v29);
        if ( v28 )
        {
          v23 = ssh_string_len((uint32_t *)v28);
          v24 = (void *)ssh_string_data((__int64)v28);
          memset(v24, 0, v23);
        }
        if ( v27 )
        {
          free(v27);
          v27 = 0LL;
        }
        if ( v28 )
        {
          free(v28);
          v28 = 0LL;
        }
        return 0xFFFFFFFFLL;
      }
      if ( ssh_string_len((uint32_t *)v27) != 32 || ssh_string_len((uint32_t *)v28) != 64 )
      {
        ssh_log(1, "pki_openssh_import_privkey_blob", "Invalid ed25519 key len", v17, v18, v19, a2);
        goto LABEL_26;
      }
      *((_QWORD *)v29 + 7) = malloc(0x40uLL);
      *((_QWORD *)v29 + 6) = malloc(0x20uLL);
      if ( !*((_QWORD *)v29 + 7) || !*((_QWORD *)v29 + 6) )
        goto LABEL_26;
      v20 = (const void *)ssh_string_data((__int64)v28);
      memcpy(*((void **)v29 + 7), v20, 0x40uLL);
      v21 = (const void *)ssh_string_data((__int64)v27);
      memcpy(*((void **)v29 + 6), v21, 0x20uLL);
      v22 = (void *)ssh_string_data((__int64)v28);
      explicit_bzero(v22, 0x40uLL);
      if ( v28 )
      {
        free(v28);
        v28 = 0LL;
      }
      if ( v27 )
      {
        free(v27);
        v27 = 0LL;
      }
LABEL_25:
      *a2 = v29;
      return 0LL;
    default:
      goto LABEL_25;
  }
}
// 2A4B6: variable 'v3' is possibly undefined
// 2A4B6: variable 'v4' is possibly undefined
// 2A4B6: variable 'v5' is possibly undefined
// 2A4F2: variable 'v6' is possibly undefined
// 2A4F2: variable 'v7' is possibly undefined
// 2A4F2: variable 'v8' is possibly undefined
// 2A546: variable 'v9' is possibly undefined
// 2A546: variable 'v10' is possibly undefined
// 2A546: variable 'v11' is possibly undefined
// 2A5FE: variable 'v14' is possibly undefined
// 2A5FE: variable 'v15' is possibly undefined
// 2A5FE: variable 'v16' is possibly undefined
// 2A644: variable 'v17' is possibly undefined
// 2A644: variable 'v18' is possibly undefined
// 2A644: variable 'v19' is possibly undefined
// 2A760: variable 'v12' is possibly undefined
// 2A760: variable 'v13' is possibly undefined

//----- (000000000002A82A) ----------------------------------------------------
__int64 __fastcall pki_private_key_decrypt(
        uint32_t *a1,
        char *a2,
        const char *a3,
        const char *a4,
        uint32_t *a5,
        __int64 (__fastcall *a6)(const char *, char *, __int64, _QWORD, _QWORD, __int64),
        __int64 a7)
{
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  unsigned __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned int v16; // ebx
  const void *v17; // rax
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rax
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  unsigned int v25; // ebx
  __int64 v26; // r13
  const void *v27; // r12
  __int64 v28; // rax
  void (__fastcall *v29)(char *, __int64, __int64, __int64); // rbx
  __int64 v30; // r13
  __int64 v31; // r12
  __int64 v32; // rax
  char *s; // [rsp+30h] [rbp-1F0h]
  unsigned int v38; // [rsp+40h] [rbp-1E0h] BYREF
  int v39; // [rsp+44h] [rbp-1DCh]
  int i; // [rsp+48h] [rbp-1D8h]
  int v41; // [rsp+4Ch] [rbp-1D4h]
  void *ptr; // [rsp+50h] [rbp-1D0h] BYREF
  char **ciphertab; // [rsp+58h] [rbp-1C8h]
  void *v44; // [rsp+60h] [rbp-1C0h]
  unsigned __int64 v45; // [rsp+68h] [rbp-1B8h]
  char dest[8]; // [rsp+70h] [rbp-1B0h] BYREF
  unsigned int v47; // [rsp+78h] [rbp-1A8h]
  unsigned int v48; // [rsp+A0h] [rbp-180h]
  void (__fastcall *v49)(char *, char *, char *); // [rsp+B8h] [rbp-168h]
  void (__fastcall *v50)(char *, __int64, __int64, __int64); // [rsp+C8h] [rbp-158h]
  char v51[128]; // [rsp+F0h] [rbp-130h] BYREF
  char v52[136]; // [rsp+170h] [rbp-B0h] BYREF
  unsigned __int64 v53; // [rsp+1F8h] [rbp-28h]

  s = a2;
  v53 = __readfsqword(0x28u);
  ciphertab = ssh_get_ciphertab();
  v41 = strcmp(a3, "none");
  if ( !v41 )
    return 0LL;
  for ( i = 0; ciphertab[16 * (__int64)i]; ++i )
  {
    v41 = strcmp(a3, ciphertab[16 * (__int64)i]);
    if ( !v41 )
    {
      memcpy(dest, &ciphertab[16 * (__int64)i], 0x80uLL);
      break;
    }
  }
  if ( !ciphertab[16 * (__int64)i] )
  {
    ssh_log(1, "pki_private_key_decrypt", "Unsupported cipher %s", (__int64)a3, v7, v8);
    return 0xFFFFFFFFLL;
  }
  v41 = strcmp(a4, "bcrypt");
  if ( v41 )
  {
    ssh_log(1, "pki_private_key_decrypt", "Unsupported KDF %s", (__int64)a4, v10, v11);
    return 0xFFFFFFFFLL;
  }
  v12 = ssh_string_len(a1);
  if ( v12 % v47 )
  {
    v13 = ssh_string_len(a1);
    ssh_log(1, "pki_private_key_decrypt", "Encrypted string not multiple of blocksize: %zu", v13, v14, v15);
    return 0xFFFFFFFFLL;
  }
  v44 = ssh_buffer_new();
  if ( !v44 )
    return 0xFFFFFFFFLL;
  v16 = ssh_string_len(a5);
  v17 = (const void *)ssh_string_data((__int64)a5);
  v39 = ssh_buffer_add_data((__int64)v44, v17, v16);
  if ( v39 != -1 )
    v39 = ssh_buffer_unpack((__int64)v44, "Sd", 2, &ptr, &v38, 1332084403LL);
  ssh_buffer_free((__int64)v44);
  if ( v39 == -1 )
    return 0xFFFFFFFFLL;
  v45 = (v48 >> 3) + v47;
  if ( v45 > 0x80 )
  {
    ssh_log(1, "pki_private_key_decrypt", "Key material too big", v18, v19, v20);
    return 0xFFFFFFFFLL;
  }
  v21 = ssh_string_len((uint32_t *)ptr);
  ssh_log(3, "pki_private_key_decrypt", "Decryption: %d key, %d IV, %d rounds, %zu bytes salt", v48 >> 3, v47, v38, v21);
  if ( !a2 )
  {
    if ( !a6 )
    {
      if ( ptr )
      {
        free(ptr);
        ptr = 0LL;
      }
      ssh_log(1, "pki_private_key_decrypt", "No passphrase provided", v22, v23, v24);
      return 0xFFFFFFFFLL;
    }
    v39 = a6("Passphrase", v52, 128LL, 0LL, 0LL, a7);
    if ( v39 )
    {
      if ( ptr )
      {
        free(ptr);
        ptr = 0LL;
      }
      return 0xFFFFFFFFLL;
    }
    s = v52;
  }
  v25 = v38;
  v26 = ssh_string_len((uint32_t *)ptr);
  v27 = (const void *)ssh_string_data((__int64)ptr);
  v28 = strlen(s);
  v39 = bcrypt_pbkdf((__int64)s, v28, v27, v26, (__int64)v51, v45, v25);
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  if ( v39 < 0 )
    return 0xFFFFFFFFLL;
  explicit_bzero(v52, 0x80uLL);
  v49(dest, v51, &v51[v48 >> 3]);
  v29 = v50;
  v30 = ssh_string_len(a1);
  v31 = ssh_string_data((__int64)a1);
  v32 = ssh_string_data((__int64)a1);
  v29(dest, v32, v31, v30);
  ssh_cipher_clear((__int64)dest);
  return 0LL;
}
// 2A9A4: variable 'v7' is possibly undefined
// 2A9A4: variable 'v8' is possibly undefined
// 2A9FA: variable 'v10' is possibly undefined
// 2A9FA: variable 'v11' is possibly undefined
// 2AA5A: variable 'v14' is possibly undefined
// 2AA5A: variable 'v15' is possibly undefined
// 2AB72: variable 'v18' is possibly undefined
// 2AB72: variable 'v19' is possibly undefined
// 2AB72: variable 'v20' is possibly undefined
// 2AC2C: variable 'v22' is possibly undefined
// 2AC2C: variable 'v23' is possibly undefined
// 2AC2C: variable 'v24' is possibly undefined
// 2A82A: using guessed type char dest[8];
// 2A82A: using guessed type char var_130[128];

//----- (000000000002AE2B) ----------------------------------------------------
void *__fastcall ssh_pki_openssh_privkey_import(
        char *a1,
        char *a2,
        __int64 (__fastcall *a3)(const char *, char *, __int64, _QWORD, _QWORD, __int64),
        __int64 a4)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // r8
  __int64 v20; // r9
  unsigned int v21; // ebx
  const void *v22; // rax
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // rcx
  __int64 v27; // r8
  __int64 v28; // r9
  unsigned __int8 v32; // [rsp+2Fh] [rbp-91h] BYREF
  unsigned int v33; // [rsp+30h] [rbp-90h] BYREF
  int v34; // [rsp+34h] [rbp-8Ch] BYREF
  int v35; // [rsp+38h] [rbp-88h] BYREF
  int v36; // [rsp+3Ch] [rbp-84h]
  int v37; // [rsp+40h] [rbp-80h]
  int v38; // [rsp+44h] [rbp-7Ch]
  char *v39; // [rsp+48h] [rbp-78h] BYREF
  void *v40; // [rsp+50h] [rbp-70h] BYREF
  void *v41; // [rsp+58h] [rbp-68h] BYREF
  void *v42; // [rsp+60h] [rbp-60h] BYREF
  void *v43; // [rsp+68h] [rbp-58h] BYREF
  void *v44; // [rsp+70h] [rbp-50h] BYREF
  void *v45; // [rsp+78h] [rbp-48h] BYREF
  char *s1; // [rsp+80h] [rbp-40h]
  void *v47; // [rsp+88h] [rbp-38h]
  void *v48; // [rsp+90h] [rbp-30h]
  void *ssh_string; // [rsp+98h] [rbp-28h]
  char *v50; // [rsp+A0h] [rbp-20h]
  void *ptr; // [rsp+A8h] [rbp-18h]

  s1 = a1;
  v47 = 0LL;
  v48 = 0LL;
  v39 = 0LL;
  v40 = 0LL;
  v41 = 0LL;
  v33 = 0;
  v34 = 0;
  v35 = 0xFFFF;
  v42 = 0LL;
  v43 = 0LL;
  v44 = 0LL;
  ssh_string = 0LL;
  v45 = 0LL;
  v37 = strncmp(a1, "-----BEGIN OPENSSH PRIVATE KEY-----", 0x23uLL);
  if ( v37 )
  {
    ssh_log(1, "ssh_pki_openssh_privkey_import", "Not an OpenSSH private key (no header)", v4, v5, v6);
  }
  else
  {
    for ( s1 += 35; *s1 && ((*__ctype_b_loc())[*s1] & 0x2000) == 0; ++s1 )
      ;
    v50 = strstr(s1, "-----END OPENSSH PRIVATE KEY-----");
    if ( v50 )
    {
      ptr = malloc(v50 - s1 + 1);
      if ( ptr )
      {
        v36 = 0;
        while ( s1 < v50 )
        {
          if ( ((*__ctype_b_loc())[*s1] & 0x2000) == 0 )
            *((_BYTE *)ptr + v36++) = *s1;
          ++s1;
        }
        *((_BYTE *)ptr + v36) = 0;
        v47 = base64_to_bin((const char *)ptr);
        if ( ptr )
        {
          free(ptr);
          ptr = 0LL;
        }
        if ( v47 )
        {
          v38 = ssh_buffer_unpack(
                  (__int64)v47,
                  "PssSdSS",
                  8,
                  15LL,
                  &v39,
                  &v40,
                  &v41,
                  &v42,
                  &v33,
                  &v43,
                  &v44,
                  1332084403LL);
          if ( v38 == -1 )
          {
            ssh_log(1, "ssh_pki_openssh_privkey_import", "Not an OpenSSH private key (unpack error)", v13, v14, v15);
          }
          else
          {
            v37 = strncmp(v39, "openssh-key-v1", 0xEuLL);
            if ( v37 )
            {
              ssh_log(1, "ssh_pki_openssh_privkey_import", "Not an OpenSSH private key (bad magic)", v16, v17, v18);
            }
            else
            {
              ssh_log(
                2,
                "ssh_pki_openssh_privkey_import",
                "Opening OpenSSH private key: ciphername: %s, kdf: %s, nkeys: %d\n",
                (__int64)v40,
                (__int64)v41,
                v33);
              if ( v33 == 1 )
              {
                v38 = pki_private_key_decrypt(
                        (uint32_t *)v44,
                        a2,
                        (const char *)v40,
                        (const char *)v41,
                        (uint32_t *)v42,
                        a3,
                        a4);
                if ( v38 != -1 )
                {
                  v48 = ssh_buffer_new();
                  if ( v48 )
                  {
                    ssh_buffer_set_secure((__int64)v48);
                    v21 = ssh_string_len((uint32_t *)v44);
                    v22 = (const void *)ssh_string_data((__int64)v44);
                    ssh_buffer_add_data((__int64)v48, v22, v21);
                    v38 = ssh_buffer_unpack((__int64)v48, "dd", 2, &v34, &v35, 1332084403LL);
                    if ( v38 != -1 && v34 == v35 )
                    {
                      v38 = pki_openssh_import_privkey_blob((__int64)v48, &v45);
                      if ( v38 != -1 )
                      {
                        ssh_string = ssh_buffer_get_ssh_string((__int64)v48);
                        if ( ssh_string )
                        {
                          free(ssh_string);
                          ssh_string = 0LL;
                        }
                        v36 = 1;
                        while ( (unsigned int)ssh_buffer_get_len((__int64)v48) )
                        {
                          ssh_buffer_get_u8((__int64)v48, &v32);
                          if ( v32 != v36 )
                          {
                            ssh_key_free(v45);
                            v45 = 0LL;
                            ssh_log(1, "ssh_pki_openssh_privkey_import", "Invalid padding", v26, v27, v28);
                            break;
                          }
                          ++v36;
                        }
                      }
                    }
                    else
                    {
                      ssh_log(
                        1,
                        "ssh_pki_openssh_privkey_import",
                        "OpenSSH private key unpack error (correct password?)",
                        v23,
                        v24,
                        v25,
                        a4,
                        a3,
                        a2,
                        a1);
                    }
                  }
                  else
                  {
                    v38 = -1;
                  }
                }
              }
              else
              {
                ssh_log(
                  1,
                  "ssh_pki_openssh_privkey_import",
                  "Opening OpenSSH private key: only 1 key supported (%d available)",
                  v33,
                  v19,
                  v20);
              }
            }
          }
        }
        else
        {
          ssh_log(1, "ssh_pki_openssh_privkey_import", "Not an OpenSSH private key (base64 error)", v10, v11, v12);
        }
      }
    }
    else
    {
      ssh_log(1, "ssh_pki_openssh_privkey_import", "Not an OpenSSH private key (no footer)", v7, v8, v9);
    }
  }
  if ( v47 )
  {
    ssh_buffer_free((__int64)v47);
    v47 = 0LL;
  }
  if ( v48 )
  {
    ssh_buffer_free((__int64)v48);
    v48 = 0LL;
  }
  if ( v39 )
  {
    free(v39);
    v39 = 0LL;
  }
  if ( v40 )
  {
    free(v40);
    v40 = 0LL;
  }
  if ( v41 )
  {
    free(v41);
    v41 = 0LL;
  }
  if ( v42 )
  {
    free(v42);
    v42 = 0LL;
  }
  if ( v43 )
  {
    free(v43);
    v43 = 0LL;
  }
  if ( v44 )
  {
    free(v44);
    v44 = 0LL;
  }
  return v45;
}
// 2AF05: variable 'v4' is possibly undefined
// 2AF05: variable 'v5' is possibly undefined
// 2AF05: variable 'v6' is possibly undefined
// 2AF84: variable 'v7' is possibly undefined
// 2AF84: variable 'v8' is possibly undefined
// 2AF84: variable 'v9' is possibly undefined
// 2B077: variable 'v10' is possibly undefined
// 2B077: variable 'v11' is possibly undefined
// 2B077: variable 'v12' is possibly undefined
// 2B0F7: variable 'v13' is possibly undefined
// 2B0F7: variable 'v14' is possibly undefined
// 2B0F7: variable 'v15' is possibly undefined
// 2B13A: variable 'v16' is possibly undefined
// 2B13A: variable 'v17' is possibly undefined
// 2B13A: variable 'v18' is possibly undefined
// 2B1A3: variable 'v19' is possibly undefined
// 2B1A3: variable 'v20' is possibly undefined
// 2B2B2: variable 'v23' is possibly undefined
// 2B2B2: variable 'v24' is possibly undefined
// 2B2B2: variable 'v25' is possibly undefined
// 2B367: variable 'v26' is possibly undefined
// 2B367: variable 'v27' is possibly undefined
// 2B367: variable 'v28' is possibly undefined

//----- (000000000002B47C) ----------------------------------------------------
__int64 __fastcall pki_openssh_export_privkey_blob(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  if ( *(_DWORD *)a1 == 5 )
  {
    if ( *(_QWORD *)(a1 + 56) && *(_QWORD *)(a1 + 48) )
      return (unsigned int)ssh_buffer_pack(
                             a2,
                             "sdPdP",
                             7,
                             *(_QWORD *)(a1 + 8),
                             32LL,
                             32LL,
                             *(_QWORD *)(a1 + 48),
                             64LL,
                             64LL,
                             *(_QWORD *)(a1 + 56),
                             1332084403LL);
    else
      return 0xFFFFFFFFLL;
  }
  else
  {
    ssh_log(1, "pki_openssh_export_privkey_blob", "Type %s not supported", *(_QWORD *)(a1 + 8), a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (000000000002B546) ----------------------------------------------------
__int64 __fastcall pki_private_key_encrypt(
        __int64 a1,
        char *a2,
        const char *a3,
        const char *a4,
        unsigned int (__fastcall *a5)(const char *, char *, __int64, _QWORD, _QWORD, __int64),
        __int64 a6,
        unsigned int a7,
        uint32_t *a8)
{
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  unsigned int len; // eax
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rax
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // r12
  const void *v21; // rbx
  __int64 v22; // rax
  void (__fastcall *v23)(char *, __int64, __int64, __int64); // rbx
  __int64 v24; // r13
  __int64 v25; // r12
  __int64 v26; // rax
  char *s; // [rsp+30h] [rbp-1E0h]
  char v32; // [rsp+43h] [rbp-1CDh]
  int i; // [rsp+44h] [rbp-1CCh]
  char **ciphertab; // [rsp+50h] [rbp-1C0h]
  unsigned __int64 v35; // [rsp+58h] [rbp-1B8h]
  char dest[8]; // [rsp+60h] [rbp-1B0h] BYREF
  unsigned int v37; // [rsp+68h] [rbp-1A8h]
  unsigned int v38; // [rsp+90h] [rbp-180h]
  void (__fastcall *v39)(char *, char *, char *); // [rsp+A0h] [rbp-170h]
  void (__fastcall *v40)(char *, __int64, __int64, __int64); // [rsp+B0h] [rbp-160h]
  char v41[128]; // [rsp+E0h] [rbp-130h] BYREF
  char v42[136]; // [rsp+160h] [rbp-B0h] BYREF
  unsigned __int64 v43; // [rsp+1E8h] [rbp-28h]

  s = a2;
  v43 = __readfsqword(0x28u);
  ciphertab = ssh_get_ciphertab();
  v32 = 1;
  if ( !strcmp(a3, "none") )
    return 0LL;
  for ( i = 0; ciphertab[16 * (__int64)i]; ++i )
  {
    if ( !strcmp(a3, ciphertab[16 * (__int64)i]) )
    {
      memcpy(dest, &ciphertab[16 * (__int64)i], 0x80uLL);
      break;
    }
  }
  if ( !ciphertab[16 * (__int64)i] )
  {
    ssh_log(1, "pki_private_key_encrypt", "Unsupported cipher %s", (__int64)a3, v8, v9);
    return 0xFFFFFFFFLL;
  }
  if ( strcmp(a4, "bcrypt") )
  {
    ssh_log(1, "pki_private_key_encrypt", "Unsupported KDF %s", (__int64)a4, v11, v12);
    return 0xFFFFFFFFLL;
  }
  while ( 1 )
  {
    len = ssh_buffer_get_len(a1);
    if ( !(len % v37) )
      break;
    if ( (int)ssh_buffer_add_u8(a1, v32) < 0 )
      return 0xFFFFFFFFLL;
    ++v32;
  }
  v35 = (v38 >> 3) + v37;
  if ( v35 > 0x80 )
  {
    ssh_log(1, "pki_private_key_encrypt", "Key material too big", v37, v14, v15);
    return 0xFFFFFFFFLL;
  }
  v16 = ssh_string_len(a8);
  ssh_log(1, "pki_private_key_encrypt", "Encryption: %d key, %d IV, %d rounds, %zu bytes salt", v38 >> 3, v37, a7, v16);
  if ( !a2 )
  {
    if ( !a5 )
    {
      ssh_log(1, "pki_private_key_encrypt", "No passphrase provided", v17, v18, v19);
      return 0xFFFFFFFFLL;
    }
    if ( a5("Passphrase", v42, 128LL, 0LL, 0LL, a6) )
      return 0xFFFFFFFFLL;
    s = v42;
  }
  v20 = ssh_string_len(a8);
  v21 = (const void *)ssh_string_data((__int64)a8);
  v22 = strlen(s);
  if ( (int)bcrypt_pbkdf((__int64)s, v22, v21, v20, (__int64)v41, v35, a7) < 0 )
    return 0xFFFFFFFFLL;
  v39(dest, v41, &v41[v38 >> 3]);
  v23 = v40;
  v24 = (unsigned int)ssh_buffer_get_len(a1);
  v25 = ssh_buffer_get(a1);
  v26 = ssh_buffer_get(a1);
  v23(dest, v26, v25, v24);
  ssh_cipher_clear((__int64)dest);
  explicit_bzero(v42, 0x80uLL);
  return 0LL;
}
// 2B6C7: variable 'v8' is possibly undefined
// 2B6C7: variable 'v9' is possibly undefined
// 2B71D: variable 'v11' is possibly undefined
// 2B71D: variable 'v12' is possibly undefined
// 2B7D0: variable 'v14' is possibly undefined
// 2B7D0: variable 'v15' is possibly undefined
// 2B85F: variable 'v17' is possibly undefined
// 2B85F: variable 'v18' is possibly undefined
// 2B85F: variable 'v19' is possibly undefined
// 2B546: using guessed type char dest[8];
// 2B546: using guessed type char var_130[128];

//----- (000000000002BA12) ----------------------------------------------------
_BYTE *__fastcall ssh_pki_openssh_privkey_export(
        __int64 a1,
        char *a2,
        unsigned int (__fastcall *a3)(const char *, char *, __int64, _QWORD, _QWORD, __int64),
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rax
  unsigned int len; // eax
  size_t v12; // r12
  const void *v13; // rbx
  void *v14; // rax
  __int64 v15; // rbx
  __int64 v16; // r12
  __int64 v17; // rcx
  const char *v18; // rax
  const char *v19; // rdx
  int v20; // ebx
  _BYTE *v21; // rax
  size_t v22; // rax
  unsigned int v23; // eax
  void *v24; // rax
  unsigned int v25; // eax
  __int64 v26; // [rsp+0h] [rbp-A0h]
  unsigned int v28; // [rsp+2Ch] [rbp-74h] BYREF
  int v29; // [rsp+30h] [rbp-70h]
  unsigned int v30; // [rsp+34h] [rbp-6Ch]
  int random; // [rsp+38h] [rbp-68h]
  int v32; // [rsp+3Ch] [rbp-64h]
  unsigned int v33; // [rsp+40h] [rbp-60h]
  int data; // [rsp+44h] [rbp-5Ch]
  _BYTE *v35; // [rsp+48h] [rbp-58h]
  void *v36; // [rsp+50h] [rbp-50h]
  void *v37; // [rsp+58h] [rbp-48h]
  void *v38; // [rsp+60h] [rbp-40h]
  void *ptr; // [rsp+68h] [rbp-38h]
  void *v40; // [rsp+70h] [rbp-30h]
  void *v41; // [rsp+78h] [rbp-28h]
  char *s; // [rsp+80h] [rbp-20h]
  void *v43; // [rsp+88h] [rbp-18h]

  v26 = a4;
  v35 = 0LL;
  ptr = 0LL;
  v36 = 0LL;
  v30 = 16;
  v37 = 0LL;
  v38 = 0LL;
  v29 = 0;
  if ( !a1 )
    return 0LL;
  if ( *(_DWORD *)a1 != 5 )
  {
    ssh_log(1, "ssh_pki_openssh_privkey_export", "Unsupported key type %s", *(_QWORD *)(a1 + 8), a5, a6);
    return 0LL;
  }
  if ( a2 || a3 )
  {
    ssh_log(2, "ssh_pki_openssh_privkey_export", "Enabling encryption for private key export", a4, a5, a6, a4);
    v29 = 1;
  }
  v40 = ssh_buffer_new();
  ptr = pki_publickey_to_blob(a1);
  if ( v40 )
  {
    if ( ptr )
    {
      random = ssh_get_random((__int64)&v28, 4);
      if ( random )
      {
        v36 = ssh_buffer_new();
        if ( v36 )
        {
          v32 = ssh_buffer_pack((__int64)v36, "dd", 2, v28, v28, 1332084403LL);
          if ( v32 != -1 )
          {
            v32 = pki_openssh_export_privkey_blob(a1, (__int64)v36, (__int64)v36, v7, v8, v9);
            if ( v32 != -1 )
            {
              v32 = ssh_buffer_pack((__int64)v36, "s", 1, &unk_56F83, 1332084403LL);
              if ( v32 != -1 )
              {
                if ( !v29 )
                {
                  v38 = ssh_string_new(0LL);
                  goto LABEL_25;
                }
                v41 = ssh_buffer_new();
                if ( v41 )
                {
                  v37 = ssh_string_new(0x10uLL);
                  if ( !v37
                    || (v10 = ssh_string_data((__int64)v37), (random = ssh_get_random(v10, 16)) == 0)
                    || (ssh_buffer_pack((__int64)v41, "Sd", 2, v37, v30, 1332084403LL),
                        len = ssh_buffer_get_len((__int64)v41),
                        (v38 = ssh_string_new(len)) == 0LL) )
                  {
                    ssh_buffer_free((__int64)v41);
                    goto LABEL_39;
                  }
                  v12 = (unsigned int)ssh_buffer_get_len((__int64)v41);
                  v13 = (const void *)ssh_buffer_get((__int64)v41);
                  v14 = (void *)ssh_string_data((__int64)v38);
                  memcpy(v14, v13, v12);
                  ssh_buffer_free((__int64)v41);
                  v32 = pki_private_key_encrypt((__int64)v36, a2, "aes128-cbc", "bcrypt", a3, v26, v30, (uint32_t *)v37);
                  if ( v32 )
                    goto LABEL_39;
LABEL_25:
                  v15 = ssh_buffer_get((__int64)v36);
                  v16 = (unsigned int)ssh_buffer_get_len((__int64)v36);
                  v17 = (unsigned int)ssh_buffer_get_len((__int64)v36);
                  if ( v29 )
                    v18 = "bcrypt";
                  else
                    v18 = "none";
                  if ( v29 )
                    v19 = "aes128-cbc";
                  else
                    v19 = "none";
                  v32 = ssh_buffer_pack(
                          (__int64)v40,
                          "PssSdSdP",
                          10,
                          15LL,
                          "openssh-key-v1",
                          v19,
                          v18,
                          v38,
                          1LL,
                          ptr,
                          v17,
                          v16,
                          v15,
                          1332084403LL);
                  if ( !v32 )
                  {
                    v20 = ssh_buffer_get_len((__int64)v40);
                    v21 = (_BYTE *)ssh_buffer_get((__int64)v40);
                    s = bin_to_base64(v21, v20);
                    if ( s )
                    {
                      ssh_buffer_reinit((__int64)v40);
                      v32 = ssh_buffer_pack(
                              (__int64)v40,
                              "tttttt",
                              6,
                              "-----BEGIN OPENSSH PRIVATE KEY-----",
                              "\n",
                              s,
                              "\n",
                              "-----END OPENSSH PRIVATE KEY-----",
                              "\n",
                              1332084403LL);
                      v22 = strlen(s);
                      explicit_bzero(s, v22);
                      if ( s )
                      {
                        free(s);
                        s = 0LL;
                      }
                      if ( !v32 )
                      {
                        v23 = ssh_buffer_get_len((__int64)v40);
                        v35 = ssh_string_new(v23);
                        if ( v35 )
                        {
                          v33 = ssh_buffer_get_len((__int64)v40);
                          v24 = (void *)ssh_string_data((__int64)v35);
                          data = ssh_buffer_get_data((__int64)v40, v24, v33);
                          if ( v33 != data )
                          {
                            ssh_string_free(v35);
                            v35 = 0LL;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_39:
  if ( v36 )
  {
    v43 = (void *)ssh_buffer_get((__int64)v36);
    v25 = ssh_buffer_get_len((__int64)v36);
    explicit_bzero(v43, v25);
    ssh_buffer_free((__int64)v36);
  }
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  if ( v38 )
  {
    free(v38);
    v38 = 0LL;
  }
  if ( v37 )
  {
    free(v37);
    v37 = 0LL;
  }
  if ( v40 )
    ssh_buffer_free((__int64)v40);
  return v35;
}
// 2BBB6: variable 'v7' is possibly undefined
// 2BBB6: variable 'v8' is possibly undefined
// 2BBB6: variable 'v9' is possibly undefined
// 2BD58: variable 'v26' is possibly undefined

//----- (000000000002C038) ----------------------------------------------------
__int64 __fastcall pki_key_generate_ed25519(__int64 a1)
{
  *(_QWORD *)(a1 + 56) = malloc(0x40uLL);
  if ( *(_QWORD *)(a1 + 56) )
  {
    *(_QWORD *)(a1 + 48) = malloc(0x20uLL);
    if ( *(_QWORD *)(a1 + 48) )
    {
      if ( !(unsigned int)crypto_sign_ed25519_keypair(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56)) )
        return 0LL;
    }
  }
  if ( *(_QWORD *)(a1 + 56) )
  {
    free(*(void **)(a1 + 56));
    *(_QWORD *)(a1 + 56) = 0LL;
  }
  if ( *(_QWORD *)(a1 + 48) )
  {
    free(*(void **)(a1 + 48));
    *(_QWORD *)(a1 + 48) = 0LL;
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000002C113) ----------------------------------------------------
__int64 __fastcall pki_ed25519_sign(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v7; // [rsp+30h] [rbp-10h] BYREF
  void *src; // [rsp+38h] [rbp-8h]

  v7 = 0LL;
  src = malloc(a4 + 64);
  if ( !src )
    return 0xFFFFFFFFLL;
  if ( !(unsigned int)crypto_sign_ed25519((__int64)src, &v7, a3, a4, *(_QWORD *)(a1 + 56))
    && v7 - a4 == 64
    && (*(_QWORD *)(a2 + 40) = malloc(0x40uLL)) != 0LL )
  {
    memcpy(*(void **)(a2 + 40), src, 0x40uLL);
    if ( src )
    {
      free(src);
      src = 0LL;
    }
    return 0LL;
  }
  else
  {
    if ( src )
    {
      free(src);
      src = 0LL;
    }
    return 0xFFFFFFFFLL;
  }
}

//----- (000000000002C21B) ----------------------------------------------------
__int64 __fastcall pki_ed25519_verify(__int64 a1, __int64 a2, const void *a3, size_t a4)
{
  int v7; // [rsp+24h] [rbp-1Ch]
  __int64 v8; // [rsp+28h] [rbp-18h] BYREF
  void *dest; // [rsp+30h] [rbp-10h]
  void *ptr; // [rsp+38h] [rbp-8h]

  v8 = 0LL;
  if ( !a1 || !a2 || !a3 || !*(_QWORD *)(a2 + 40) )
    return 0xFFFFFFFFLL;
  dest = malloc(a4 + 64);
  if ( !dest )
    return 0xFFFFFFFFLL;
  ptr = malloc(a4 + 64);
  if ( ptr )
  {
    memcpy(dest, *(const void **)(a2 + 40), 0x40uLL);
    memcpy((char *)dest + 64, a3, a4);
    v7 = crypto_sign_ed25519_open((__int64)ptr, &v8, dest, a4 + 64, *(_QWORD *)(a1 + 48));
    explicit_bzero(dest, a4 + 64);
    explicit_bzero(ptr, a4);
    if ( dest )
    {
      free(dest);
      dest = 0LL;
    }
    if ( ptr )
    {
      free(ptr);
      ptr = 0LL;
    }
    if ( v7 )
      return 0xFFFFFFFFLL;
    else
      return 0LL;
  }
  else
  {
    free(dest);
    return 0xFFFFFFFFLL;
  }
}
// 2C3A1: conditional instruction was optimized away because %ptr.8==0
// 2C386: conditional instruction was optimized away because %dest.8!=0

//----- (000000000002C3BE) ----------------------------------------------------
_BOOL8 __fastcall pki_ed25519_key_cmp(__int64 a1, __int64 a2, int a3)
{
  if ( a3 )
  {
    if ( a3 != 1 )
      return 0LL;
    if ( !*(_QWORD *)(a1 + 56) || !*(_QWORD *)(a2 + 56) )
      return 1LL;
    if ( memcmp(*(const void **)(a1 + 56), *(const void **)(a2 + 56), 0x40uLL) )
      return 1LL;
  }
  if ( !*(_QWORD *)(a1 + 48) || !*(_QWORD *)(a2 + 48) )
    return 1LL;
  return memcmp(*(const void **)(a1 + 48), *(const void **)(a2 + 48), 0x20uLL) != 0;
}

//----- (000000000002C48D) ----------------------------------------------------
__int64 __fastcall pki_ed25519_key_dup(__int64 a1, __int64 a2)
{
  if ( !*(_QWORD *)(a2 + 56) && !*(_QWORD *)(a2 + 48) )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a2 + 56) )
  {
    *(_QWORD *)(a1 + 56) = malloc(0x40uLL);
    if ( !*(_QWORD *)(a1 + 56) )
      return 0xFFFFFFFFLL;
    memcpy(*(void **)(a1 + 56), *(const void **)(a2 + 56), 0x40uLL);
  }
  if ( !*(_QWORD *)(a2 + 48) )
    return 0LL;
  *(_QWORD *)(a1 + 48) = malloc(0x20uLL);
  if ( *(_QWORD *)(a1 + 48) )
  {
    memcpy(*(void **)(a1 + 48), *(const void **)(a2 + 48), 0x20uLL);
    return 0LL;
  }
  if ( *(_QWORD *)(a1 + 56) )
  {
    free(*(void **)(a1 + 56));
    *(_QWORD *)(a1 + 56) = 0LL;
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000002C5A0) ----------------------------------------------------
__int64 __fastcall pki_ed25519_public_key_to_blob(__int64 a1, __int64 a2)
{
  if ( *(_QWORD *)(a2 + 48) )
    return (unsigned int)ssh_buffer_pack(a1, "dP", 3, 32LL, 32LL, *(_QWORD *)(a2 + 48), 1332084403LL);
  else
    return 0xFFFFFFFFLL;
}

//----- (000000000002C60C) ----------------------------------------------------
uint32_t *__fastcall pki_ed25519_sig_to_blob(__int64 a1)
{
  uint32_t *v2; // [rsp+18h] [rbp-8h]

  if ( !*(_QWORD *)(a1 + 40) )
    return 0LL;
  v2 = (uint32_t *)ssh_string_new(0x40uLL);
  if ( !v2 )
    return 0LL;
  ssh_string_fill(v2, *(const void **)(a1 + 40), 0x40uLL);
  return v2;
}

//----- (000000000002C66A) ----------------------------------------------------
__int64 __fastcall pki_ed25519_sig_from_blob(__int64 a1, uint32_t *a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  const void *v5; // rax
  __int64 v6; // [rsp+18h] [rbp-8h]

  v6 = ssh_string_len(a2);
  if ( v6 == 64 )
  {
    *(_QWORD *)(a1 + 40) = malloc(0x40uLL);
    if ( *(_QWORD *)(a1 + 40) )
    {
      v5 = (const void *)ssh_string_data((__int64)a2);
      memcpy(*(void **)(a1 + 40), v5, 0x40uLL);
      return 0LL;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_log(1, "pki_ed25519_sig_from_blob", "Invalid ssh-ed25519 signature len: %zu", v6, v2, v3);
    return 0xFFFFFFFFLL;
  }
}
// 2C6B0: variable 'v2' is possibly undefined
// 2C6B0: variable 'v3' is possibly undefined

//----- (000000000002C713) ----------------------------------------------------
void ssh_poll_init()
{
  ;
}

//----- (000000000002C71A) ----------------------------------------------------
void ssh_poll_cleanup()
{
  ;
}

//----- (000000000002C721) ----------------------------------------------------
int __fastcall ssh_poll(struct pollfd *a1, nfds_t a2, int a3)
{
  return poll(a1, a2, a3);
}

//----- (000000000002C74C) ----------------------------------------------------
void *__fastcall ssh_poll_new(int a1, __int16 a2, __int64 a3, __int64 a4)
{
  void *s; // [rsp+28h] [rbp-8h]

  s = malloc(0x30uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x30uLL);
  *((_DWORD *)s + 4) = a1;
  *((_WORD *)s + 12) = a2;
  *((_QWORD *)s + 4) = a3;
  *((_QWORD *)s + 5) = a4;
  return s;
}

//----- (000000000002C7D2) ----------------------------------------------------
void __fastcall ssh_poll_free(_QWORD *a1)
{
  if ( *a1 )
  {
    ssh_poll_ctx_remove((_QWORD *)*a1, a1);
    *a1 = 0LL;
  }
  if ( a1 )
    free(a1);
}

//----- (000000000002C829) ----------------------------------------------------
__int64 __fastcall ssh_poll_get_ctx(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000000002C83A) ----------------------------------------------------
__int64 __fastcall ssh_poll_get_events(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 24);
}

//----- (000000000002C84C) ----------------------------------------------------
__int64 __fastcall ssh_poll_set_events(__int64 *a1, unsigned __int16 a2)
{
  __int64 result; // rax

  *((_WORD *)a1 + 12) = a2;
  result = *a1;
  if ( *a1 )
  {
    result = *((unsigned int *)a1 + 7);
    if ( !(_DWORD)result )
    {
      result = a2;
      *(_WORD *)(8 * a1[2] + *(_QWORD *)(*a1 + 8) + 4) = a2;
    }
  }
  return result;
}

//----- (000000000002C8A2) ----------------------------------------------------
unsigned __int64 __fastcall ssh_poll_set_fd(_QWORD *a1, unsigned int a2)
{
  unsigned __int64 result; // rax

  if ( *a1 )
  {
    result = a2;
    *(_DWORD *)(8LL * a1[2] + *(_QWORD *)(*a1 + 8LL)) = a2;
  }
  else
  {
    result = (unsigned __int64)a1;
    *((_DWORD *)a1 + 4) = a2;
  }
  return result;
}

//----- (000000000002C8E7) ----------------------------------------------------
__int64 __fastcall ssh_poll_add_events(__int64 *a1, __int16 a2)
{
  __int16 events; // ax

  events = ssh_poll_get_events((__int64)a1);
  return ssh_poll_set_events(a1, a2 | events);
}

//----- (000000000002C91D) ----------------------------------------------------
__int64 __fastcall ssh_poll_remove_events(__int64 *a1, __int16 a2)
{
  __int16 events; // ax

  events = ssh_poll_get_events((__int64)a1);
  return ssh_poll_set_events(a1, events & (unsigned __int16)~a2);
}

//----- (000000000002C959) ----------------------------------------------------
__int64 __fastcall ssh_poll_get_fd(_QWORD *a1)
{
  if ( *a1 )
    return *(unsigned int *)(*(_QWORD *)(*a1 + 8LL) + 8LL * a1[2]);
  else
    return *((unsigned int *)a1 + 4);
}

//----- (000000000002C994) ----------------------------------------------------
__int64 __fastcall ssh_poll_set_callback(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  if ( a2 )
  {
    *(_QWORD *)(a1 + 32) = a2;
    result = a1;
    *(_QWORD *)(a1 + 40) = a3;
  }
  return result;
}

//----- (000000000002C9C6) ----------------------------------------------------
_QWORD *__fastcall ssh_poll_ctx_new(__int64 a1)
{
  __int64 v2; // [rsp+8h] [rbp-18h]
  _QWORD *s; // [rsp+18h] [rbp-8h]

  v2 = a1;
  s = malloc(0x28uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x28uLL);
  if ( !a1 )
    v2 = 5LL;
  s[4] = v2;
  return s;
}

//----- (000000000002CA2C) ----------------------------------------------------
void __fastcall ssh_poll_ctx_free(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 16) )
  {
    while ( *(_QWORD *)(a1 + 24) )
      ssh_poll_free(**(_QWORD ***)a1);
    if ( *(_QWORD *)a1 )
    {
      free(*(void **)a1);
      *(_QWORD *)a1 = 0LL;
    }
    if ( *(_QWORD *)(a1 + 8) )
    {
      free(*(void **)(a1 + 8));
      *(_QWORD *)(a1 + 8) = 0LL;
    }
  }
  if ( a1 )
    free((void *)a1);
}

//----- (000000000002CADB) ----------------------------------------------------
__int64 __fastcall ssh_poll_ctx_resize(__int64 a1, __int64 a2)
{
  void *v3; // [rsp+10h] [rbp-10h]
  void *v4; // [rsp+10h] [rbp-10h]
  void *v5; // [rsp+18h] [rbp-8h]

  v3 = realloc(*(void **)a1, 8 * a2);
  if ( !v3 )
    return 0xFFFFFFFFLL;
  *(_QWORD *)a1 = v3;
  v5 = realloc(*(void **)(a1 + 8), 8 * a2);
  if ( v5 )
  {
    *(_QWORD *)(a1 + 8) = v5;
    *(_QWORD *)(a1 + 16) = a2;
    return 0LL;
  }
  else
  {
    v4 = realloc(*(void **)a1, 8LL * *(_QWORD *)(a1 + 16));
    if ( v4 )
      *(_QWORD *)a1 = v4;
    return 0xFFFFFFFFLL;
  }
}

//----- (000000000002CBB8) ----------------------------------------------------
__int64 __fastcall ssh_poll_ctx_add(_QWORD *a1, __int64 a2)
{
  __int64 v3; // rax
  int v4; // [rsp+1Ch] [rbp-4h]

  if ( *(_QWORD *)a2 )
    return 0xFFFFFFFFLL;
  if ( a1[3] == a1[2] && (int)ssh_poll_ctx_resize((__int64)a1, a1[4] + a1[2]) < 0 )
    return 0xFFFFFFFFLL;
  v4 = *(_DWORD *)(a2 + 16);
  v3 = a1[3];
  a1[3] = v3 + 1;
  *(_QWORD *)(a2 + 16) = v3;
  *(_QWORD *)(8LL * *(_QWORD *)(a2 + 16) + *a1) = a2;
  *(_DWORD *)(8LL * *(_QWORD *)(a2 + 16) + a1[1]) = v4;
  *(_WORD *)(8LL * *(_QWORD *)(a2 + 16) + a1[1] + 4) = *(_WORD *)(a2 + 24);
  *(_WORD *)(a1[1] + 8LL * *(_QWORD *)(a2 + 16) + 6) = 0;
  *(_QWORD *)a2 = a1;
  return 0LL;
}

//----- (000000000002CCD4) ----------------------------------------------------
__int64 __fastcall ssh_poll_ctx_add_socket(_QWORD *a1, __int64 a2)
{
  unsigned int v3; // [rsp+1Ch] [rbp-14h]
  __int64 poll_handle_in; // [rsp+20h] [rbp-10h]
  __int64 poll_handle_out; // [rsp+28h] [rbp-8h]

  poll_handle_in = ssh_socket_get_poll_handle_in(a2);
  if ( !poll_handle_in )
    return 0xFFFFFFFFLL;
  v3 = ssh_poll_ctx_add(a1, poll_handle_in);
  if ( v3 )
    return v3;
  poll_handle_out = ssh_socket_get_poll_handle_out(a2);
  if ( poll_handle_in != poll_handle_out )
    return (unsigned int)ssh_poll_ctx_add(a1, poll_handle_out);
  return v3;
}

//----- (000000000002CD58) ----------------------------------------------------
unsigned __int64 __fastcall ssh_poll_ctx_remove(_QWORD *a1, _QWORD *a2)
{
  unsigned __int64 result; // rax
  __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = a2[2];
  *((_DWORD *)a2 + 4) = *(_DWORD *)(8 * v3 + a1[1]);
  *a2 = 0LL;
  if ( --a1[3] && a1[3] != v3 )
  {
    *(_QWORD *)(a1[1] + 8 * v3) = *(_QWORD *)(a1[1] + 8LL * a1[3]);
    *(_QWORD *)(*a1 + 8 * v3) = *(_QWORD *)(*a1 + 8LL * a1[3]);
    *(_QWORD *)(*(_QWORD *)(8 * v3 + *a1) + 16LL) = v3;
  }
  result = a1[4];
  if ( a1[2] - a1[3] > result )
    return ssh_poll_ctx_resize((__int64)a1, a1[2] - a1[4]);
  return result;
}

//----- (000000000002CE8E) ----------------------------------------------------
__int64 __fastcall ssh_poll_ctx_dopoll(__int64 a1, int a2)
{
  int v3; // [rsp+1Ch] [rbp-34h]
  int v4; // [rsp+20h] [rbp-30h]
  int v5; // [rsp+24h] [rbp-2Ch]
  int v6; // [rsp+28h] [rbp-28h]
  unsigned int v7; // [rsp+2Ch] [rbp-24h]
  unsigned int v8; // [rsp+30h] [rbp-20h]
  int v9; // [rsp+34h] [rbp-1Ch]
  __int64 v10; // [rsp+38h] [rbp-18h]
  __time_t v11[2]; // [rsp+40h] [rbp-10h] BYREF

  if ( !*(_QWORD *)(a1 + 24) )
    return 0xFFFFFFFFLL;
  ssh_timestamp_init(v11);
  do
  {
    v6 = ssh_timeout_update(v11, a2);
    v3 = ssh_poll(*(struct pollfd **)(a1 + 8), *(_QWORD *)(a1 + 24), v6);
  }
  while ( v3 == -1 && *__errno_location() == 4 );
  if ( v3 < 0 )
    return 0xFFFFFFFFLL;
  if ( !v3 )
    return 4294967294LL;
  v5 = *(_QWORD *)(a1 + 24);
  v4 = 0;
  while ( v4 < v5 && v3 > 0 )
  {
    if ( *(_WORD *)(8LL * v4 + *(_QWORD *)(a1 + 8) + 6) && !*(_DWORD *)(*(_QWORD *)(8LL * v4 + *(_QWORD *)a1) + 28LL) )
    {
      v10 = *(_QWORD *)(8LL * v4 + *(_QWORD *)a1);
      v7 = *(_DWORD *)(8LL * v4 + *(_QWORD *)(a1 + 8));
      v8 = *(__int16 *)(8LL * v4 + *(_QWORD *)(a1 + 8) + 6);
      *(_WORD *)(8LL * v4 + *(_QWORD *)(a1 + 8) + 4) = 0;
      *(_DWORD *)(v10 + 28) = 1;
      if ( *(_QWORD *)(v10 + 32)
        && (v9 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD))(v10 + 32))(
                   v10,
                   v7,
                   v8,
                   *(_QWORD *)(v10 + 40)),
            v9 < 0) )
      {
        if ( v9 == -2 )
          return 0xFFFFFFFFLL;
        v5 = *(_QWORD *)(a1 + 24);
        v4 = 0;
      }
      else
      {
        *(_WORD *)(8LL * v4 + *(_QWORD *)(a1 + 8) + 6) = 0;
        *(_WORD *)(*(_QWORD *)(a1 + 8) + 8LL * v4 + 4) = *(_WORD *)(v10 + 24);
        *(_DWORD *)(v10 + 28) = 0;
        ++v4;
      }
      --v3;
    }
    else
    {
      ++v4;
    }
  }
  return (unsigned int)v3;
}
// 2CE8E: using guessed type __time_t var_10[2];

//----- (000000000002D0B4) ----------------------------------------------------
__int64 __fastcall ssh_poll_get_default_ctx(__int64 a1)
{
  if ( !*(_QWORD *)(a1 + 1448) )
    *(_QWORD *)(a1 + 1448) = ssh_poll_ctx_new(2LL);
  return *(_QWORD *)(a1 + 1448);
}

//----- (000000000002D102) ----------------------------------------------------
_QWORD *ssh_event_new()
{
  _QWORD *s; // [rsp+8h] [rbp-8h]

  s = malloc(0x10uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x10uLL);
  *s = ssh_poll_ctx_new(2LL);
  if ( *s )
  {
    s[1] = ssh_list_new();
    if ( s[1] )
    {
      return s;
    }
    else
    {
      ssh_poll_ctx_free(*s);
      free(s);
      return 0LL;
    }
  }
  else
  {
    free(s);
    return 0LL;
  }
}

//----- (000000000002D1BE) ----------------------------------------------------
__int64 __fastcall ssh_event_fd_wrapper_callback(__int64 a1, unsigned int a2, unsigned int a3, __int64 a4)
{
  if ( *(_QWORD *)a4 )
    return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))a4)(a2, a3, *(_QWORD *)(a4 + 8));
  else
    return 0LL;
}

//----- (000000000002D20A) ----------------------------------------------------
__int64 __fastcall ssh_event_add_fd(_QWORD **a1, int a2, __int16 a3, __int64 a4, __int64 a5)
{
  _QWORD *ptr; // [rsp+20h] [rbp-10h]
  _QWORD *v10; // [rsp+28h] [rbp-8h]

  if ( !a1 || !*a1 || !a4 || a2 == -1 )
    return 0xFFFFFFFFLL;
  ptr = malloc(0x10uLL);
  if ( !ptr )
    return 0xFFFFFFFFLL;
  *ptr = a4;
  ptr[1] = a5;
  v10 = ssh_poll_new(a2, a3, (__int64)ssh_event_fd_wrapper_callback, (__int64)ptr);
  if ( v10 )
  {
    if ( (int)ssh_poll_ctx_add(*a1, (__int64)v10) >= 0 )
    {
      return 0LL;
    }
    else
    {
      free(ptr);
      ssh_poll_free(v10);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    free(ptr);
    return 0xFFFFFFFFLL;
  }
}

//----- (000000000002D301) ----------------------------------------------------
__int64 __fastcall ssh_event_add_poll(_QWORD **a1, __int64 a2)
{
  return ssh_poll_ctx_add(*a1, a2);
}

//----- (000000000002D329) ----------------------------------------------------
unsigned __int64 __fastcall ssh_event_remove_poll(_QWORD **a1, _QWORD *a2)
{
  return ssh_poll_ctx_remove(*a1, a2);
}

//----- (000000000002D352) ----------------------------------------------------
__int64 __fastcall ssh_event_add_session(__int64 a1, __int64 a2)
{
  _QWORD *i; // [rsp+10h] [rbp-10h]
  _QWORD *v4; // [rsp+18h] [rbp-8h]

  if ( !a1 || !*(_QWORD *)a1 || !a2 )
    return 0xFFFFFFFFLL;
  if ( !*(_QWORD *)(a2 + 1448) )
    return 0xFFFFFFFFLL;
  while ( *(_QWORD *)(*(_QWORD *)(a2 + 1448) + 24LL) )
  {
    v4 = ***(_QWORD ****)(a2 + 1448);
    ssh_poll_ctx_remove(*(_QWORD **)(a2 + 1448), v4);
    ssh_poll_ctx_add(*(_QWORD **)a1, (__int64)v4);
    v4[1] = a2;
  }
  for ( i = (_QWORD *)ssh_list_get_iterator(*(_QWORD *)(a1 + 8)); i; i = (_QWORD *)*i )
  {
    if ( i[1] == a2 )
      return 0LL;
  }
  if ( (unsigned int)ssh_list_append(*(_QWORD *)(a1 + 8), a2) == -1 )
    return 0xFFFFFFFFLL;
  else
    return 0LL;
}

//----- (000000000002D46C) ----------------------------------------------------
__int64 __fastcall ssh_event_add_connector(_QWORD **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return ssh_connector_set_event(a2, a1, (__int64)a1, a4, a5, a6);
}

//----- (000000000002D491) ----------------------------------------------------
__int64 __fastcall ssh_event_dopoll(__int64 *a1, int a2)
{
  if ( a1 && *a1 )
    return (unsigned int)ssh_poll_ctx_dopoll(*a1, a2);
  else
    return 0xFFFFFFFFLL;
}

//----- (000000000002D4D6) ----------------------------------------------------
__int64 __fastcall ssh_event_remove_fd(__int64 a1, int a2)
{
  unsigned __int64 v3; // r12
  unsigned __int64 i; // rbx
  unsigned int v5; // [rsp+1Ch] [rbp-24h]
  __int64 v6; // [rsp+20h] [rbp-20h]
  void *ptr; // [rsp+28h] [rbp-18h]

  v5 = -1;
  if ( !a1 || !*(_QWORD *)a1 )
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 24LL);
  for ( i = 0LL; i < v3; ++i )
  {
    if ( *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + 8 * i) == a2 )
    {
      v6 = *(_QWORD *)(**(_QWORD **)a1 + 8 * i);
      if ( !*(_QWORD *)(v6 + 8) )
      {
        if ( *(__int64 (__fastcall **)(__int64, unsigned int, unsigned int, __int64))(v6 + 32) == ssh_event_fd_wrapper_callback )
        {
          ptr = *(void **)(v6 + 40);
          if ( ptr )
            free(ptr);
        }
        ssh_poll_free((_QWORD *)v6);
        v5 = 0;
        v3 = *(_QWORD *)(*(_QWORD *)a1 + 24LL);
        i = 0LL;
      }
    }
  }
  return v5;
}

//----- (000000000002D5E5) ----------------------------------------------------
__int64 __fastcall ssh_event_remove_session(__int64 *a1, __int64 a2)
{
  unsigned __int64 v3; // r12
  unsigned __int64 i; // rbx
  unsigned int v5; // [rsp+1Ch] [rbp-24h]
  _QWORD *j; // [rsp+20h] [rbp-20h]
  _QWORD *v7; // [rsp+28h] [rbp-18h]

  v5 = -1;
  if ( !a1 || !*a1 || !a2 )
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(*a1 + 24);
  for ( i = 0LL; i < v3; ++i )
  {
    v7 = *(_QWORD **)(*(_QWORD *)*a1 + 8 * i);
    if ( v7[1] == a2 )
    {
      ssh_poll_ctx_remove((_QWORD *)*a1, v7);
      v7[1] = 0LL;
      ssh_poll_ctx_add(*(_QWORD **)(a2 + 1448), (__int64)v7);
      v5 = 0;
      v3 = *(_QWORD *)(*a1 + 24);
      i = 0LL;
    }
  }
  for ( j = (_QWORD *)ssh_list_get_iterator(a1[1]); j; j = (_QWORD *)*j )
  {
    if ( j[1] == a2 )
    {
      ssh_list_remove(a1[1], j);
      return v5;
    }
  }
  return v5;
}

//----- (000000000002D71D) ----------------------------------------------------
__int64 __fastcall ssh_event_remove_connector(__int64 a1, __int64 a2)
{
  return ssh_connector_remove_event(a2);
}

//----- (000000000002D73B) ----------------------------------------------------
void __fastcall ssh_event_free(_QWORD **a1)
{
  int v1; // [rsp+10h] [rbp-10h]
  int i; // [rsp+14h] [rbp-Ch]
  _QWORD *v3; // [rsp+18h] [rbp-8h]

  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = (*a1)[3];
      for ( i = 0; i < v1; ++i )
      {
        v3 = *(_QWORD **)(8LL * i + **a1);
        if ( v3[1] )
        {
          ssh_poll_ctx_remove(*a1, v3);
          ssh_poll_ctx_add(*(_QWORD **)(v3[1] + 1448LL), (__int64)v3);
          v3[1] = 0LL;
          v1 = 0;
        }
      }
      ssh_poll_ctx_free((__int64)*a1);
    }
    if ( a1[1] )
      ssh_list_free((_QWORD **)a1[1]);
    free(a1);
  }
}

//----- (000000000002D834) ----------------------------------------------------
__int64 *ssh_new()
{
  char *ptr; // [rsp+10h] [rbp-10h]
  __int64 *s; // [rsp+18h] [rbp-8h]

  ptr = 0LL;
  s = (__int64 *)malloc(0x6A0uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x6A0uLL);
  s[155] = (__int64)crypto_new();
  if ( s[155] )
  {
    s[131] = (__int64)ssh_socket_new((__int64)s);
    if ( s[131] )
    {
      s[144] = (__int64)ssh_buffer_new();
      if ( s[144] )
      {
        s[141] = (__int64)ssh_buffer_new();
        if ( s[141] )
        {
          *((_DWORD *)s + 275) = 0;
          *((_DWORD *)s + 332) = 0;
          ssh_set_blocking((__int64)s, 1);
          *((_DWORD *)s + 314) = 42;
          s[158] = (__int64)ssh_agent_new((__int64)s);
          if ( s[158] )
          {
            *((_DWORD *)s + 410) = 1;
            *((_DWORD *)s + 408) = 0;
            *((_DWORD *)s + 409) = -1;
            *((_BYTE *)s + 1644) = 7;
            *((_DWORD *)s + 418) = 0;
            *((_DWORD *)s + 417) = 15;
            s[183] = (__int64)ssh_list_new();
            if ( s[183] )
            {
              ptr = strdup("%d/id_ed25519");
              if ( ptr )
              {
                if ( (unsigned int)ssh_list_append(s[183], (__int64)ptr) != -1 )
                {
                  ptr = strdup("%d/id_ecdsa");
                  if ( ptr )
                  {
                    if ( (unsigned int)ssh_list_append(s[183], (__int64)ptr) != -1 )
                    {
                      ptr = strdup("%d/id_rsa");
                      if ( ptr )
                      {
                        if ( (unsigned int)ssh_list_append(s[183], (__int64)ptr) != -1 )
                        {
                          ptr = strdup("%d/id_dsa");
                          if ( ptr )
                          {
                            if ( (unsigned int)ssh_list_append(s[183], (__int64)ptr) != -1 )
                              return s;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  free(ptr);
  ssh_free((__int64)s);
  return 0LL;
}

//----- (000000000002DB4D) ----------------------------------------------------
void __fastcall ssh_free(__int64 a1)
{
  int k; // [rsp+14h] [rbp-1Ch]
  __int64 i; // [rsp+18h] [rbp-18h]
  __int64 j; // [rsp+20h] [rbp-10h]
  void *ptr; // [rsp+28h] [rbp-8h]

  if ( a1 )
  {
    for ( i = ssh_list_get_iterator(*(_QWORD *)(a1 + 1248)); i; i = ssh_list_get_iterator(*(_QWORD *)(a1 + 1248)) )
    {
      ssh_channel_do_free(*(__int64 **)(i + 8));
      ssh_list_remove(*(_QWORD *)(a1 + 1248), (_QWORD *)i);
    }
    ssh_list_free(*(_QWORD ***)(a1 + 1248));
    *(_QWORD *)(a1 + 1248) = 0LL;
    if ( *(_QWORD *)(a1 + 1456) )
    {
      ssh_pcap_context_free(*(void **)(a1 + 1456));
      *(_QWORD *)(a1 + 1456) = 0LL;
    }
    ssh_socket_free(*(__int64 **)(a1 + 1048));
    *(_QWORD *)(a1 + 1048) = 0LL;
    if ( *(_QWORD *)(a1 + 1448) )
      ssh_poll_ctx_free(*(_QWORD *)(a1 + 1448));
    ssh_buffer_free(*(_QWORD *)(a1 + 1128));
    ssh_buffer_free(*(_QWORD *)(a1 + 1152));
    *(_QWORD *)(a1 + 1152) = 0LL;
    *(_QWORD *)(a1 + 1128) = *(_QWORD *)(a1 + 1152);
    if ( *(_QWORD *)(a1 + 1216) )
      ssh_buffer_free(*(_QWORD *)(a1 + 1216));
    if ( *(_QWORD *)(a1 + 1224) )
      ssh_buffer_free(*(_QWORD *)(a1 + 1224));
    crypto_free(*(_QWORD **)(a1 + 1232));
    crypto_free(*(_QWORD **)(a1 + 1240));
    ssh_agent_free(*(__int64 **)(a1 + 1264));
    ssh_key_free(*(void **)(a1 + 1296));
    *(_QWORD *)(a1 + 1296) = 0LL;
    ssh_key_free(*(void **)(a1 + 1288));
    *(_QWORD *)(a1 + 1288) = 0LL;
    ssh_key_free(*(void **)(a1 + 1304));
    *(_QWORD *)(a1 + 1304) = 0LL;
    ssh_key_free(*(void **)(a1 + 1312));
    *(_QWORD *)(a1 + 1312) = 0LL;
    if ( *(_QWORD *)(a1 + 1336) )
    {
      for ( j = ssh_list_pop_head(*(_QWORD *)(a1 + 1336)); j; j = ssh_list_pop_head(*(_QWORD *)(a1 + 1336)) )
        ssh_message_free(j);
      ssh_list_free(*(_QWORD ***)(a1 + 1336));
    }
    if ( *(_QWORD *)(a1 + 1272) )
      ssh_kbdint_free(*(void ***)(a1 + 1272));
    if ( *(_QWORD *)(a1 + 1400) )
      ssh_list_free(*(_QWORD ***)(a1 + 1400));
    if ( *(_QWORD *)(a1 + 1464) )
    {
      for ( ptr = (void *)ssh_list_pop_head(*(_QWORD *)(a1 + 1464));
            ptr;
            ptr = (void *)ssh_list_pop_head(*(_QWORD *)(a1 + 1464)) )
      {
        free(ptr);
      }
      ssh_list_free(*(_QWORD ***)(a1 + 1464));
    }
    ssh_agent_state_free(*(void ***)(a1 + 1192));
    *(_QWORD *)(a1 + 1192) = 0LL;
    if ( *(_QWORD *)(a1 + 1200) )
    {
      free(*(void **)(a1 + 1200));
      *(_QWORD *)(a1 + 1200) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1056) )
    {
      free(*(void **)(a1 + 1056));
      *(_QWORD *)(a1 + 1056) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1064) )
    {
      free(*(void **)(a1 + 1064));
      *(_QWORD *)(a1 + 1064) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1112) )
    {
      free(*(void **)(a1 + 1112));
      *(_QWORD *)(a1 + 1112) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1488) )
    {
      free(*(void **)(a1 + 1488));
      *(_QWORD *)(a1 + 1488) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1608) )
    {
      free(*(void **)(a1 + 1608));
      *(_QWORD *)(a1 + 1608) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1472) )
    {
      free(*(void **)(a1 + 1472));
      *(_QWORD *)(a1 + 1472) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1480) )
    {
      free(*(void **)(a1 + 1480));
      *(_QWORD *)(a1 + 1480) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1496) )
    {
      free(*(void **)(a1 + 1496));
      *(_QWORD *)(a1 + 1496) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1504) )
    {
      free(*(void **)(a1 + 1504));
      *(_QWORD *)(a1 + 1504) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1512) )
    {
      free(*(void **)(a1 + 1512));
      *(_QWORD *)(a1 + 1512) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1600) )
    {
      free(*(void **)(a1 + 1600));
      *(_QWORD *)(a1 + 1600) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1648) )
    {
      free(*(void **)(a1 + 1648));
      *(_QWORD *)(a1 + 1648) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1656) )
    {
      free(*(void **)(a1 + 1656));
      *(_QWORD *)(a1 + 1656) = 0LL;
    }
    for ( k = 0; k <= 9; ++k )
    {
      if ( *(_QWORD *)(a1 + 8 * (k + 188LL) + 16) )
      {
        free(*(void **)(a1 + 8 * (k + 188LL) + 16));
        *(_QWORD *)(a1 + 8 * (k + 188LL) + 16) = 0LL;
      }
    }
    explicit_bzero((void *)a1, 0x6A0uLL);
    free((void *)a1);
  }
}
// 2E246: conditional instruction was optimized away because rdi.8!=0

//----- (000000000002E261) ----------------------------------------------------
__int64 __fastcall ssh_get_clientbanner(__int64 a1)
{
  if ( a1 )
    return *(_QWORD *)(a1 + 1064);
  else
    return 0LL;
}

//----- (000000000002E284) ----------------------------------------------------
__int64 __fastcall ssh_get_serverbanner(__int64 a1)
{
  if ( a1 )
    return *(_QWORD *)(a1 + 1056);
  else
    return 0LL;
}

//----- (000000000002E2A7) ----------------------------------------------------
const char *__fastcall ssh_get_kex_algo(__int64 a1)
{
  const char *result; // rax

  if ( !a1 || !*(_QWORD *)(a1 + 1232) )
    return 0LL;
  switch ( *(_DWORD *)(*(_QWORD *)(a1 + 1232) + 640LL) )
  {
    case 1:
      result = "diffie-hellman-group1-sha1";
      break;
    case 2:
      result = "diffie-hellman-group14-sha1";
      break;
    case 3:
      result = "ecdh-sha2-nistp256";
      break;
    case 4:
      result = "ecdh-sha2-nistp384";
      break;
    case 5:
      result = "ecdh-sha2-nistp521";
      break;
    case 6:
      result = "curve25519-sha256@libssh.org";
      break;
    case 7:
      result = "curve25519-sha256";
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}

//----- (000000000002E34D) ----------------------------------------------------
__int64 __fastcall ssh_get_cipher_in(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 1232) && *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 304LL) )
    return **(_QWORD **)(*(_QWORD *)(a1 + 1232) + 304LL);
  else
    return 0LL;
}

//----- (000000000002E3A1) ----------------------------------------------------
__int64 __fastcall ssh_get_cipher_out(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 1232) && *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 312LL) )
    return **(_QWORD **)(*(_QWORD *)(a1 + 1232) + 312LL);
  else
    return 0LL;
}

//----- (000000000002E3F5) ----------------------------------------------------
char *__fastcall ssh_get_hmac_in(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 1232) )
    return ssh_hmac_type_to_string(*(_DWORD *)(*(_QWORD *)(a1 + 1232) + 320LL));
  else
    return 0LL;
}

//----- (000000000002E439) ----------------------------------------------------
char *__fastcall ssh_get_hmac_out(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 1232) )
    return ssh_hmac_type_to_string(*(_DWORD *)(*(_QWORD *)(a1 + 1232) + 324LL));
  else
    return 0LL;
}

//----- (000000000002E47D) ----------------------------------------------------
void __fastcall ssh_silent_disconnect(__int64 a1)
{
  if ( a1 )
  {
    ssh_socket_close(*(_QWORD *)(a1 + 1048));
    *(_DWORD *)(a1 + 1100) = 0;
    ssh_disconnect(a1);
  }
}

//----- (000000000002E4C2) ----------------------------------------------------
__int64 __fastcall ssh_set_blocking(__int64 a1, int a2)
{
  __int64 result; // rax

  if ( a1 )
  {
    *(_DWORD *)(a1 + 1104) &= ~1u;
    result = a1;
    *(_DWORD *)(a1 + 1104) |= a2 != 0;
  }
  return result;
}

//----- (000000000002E512) ----------------------------------------------------
_BOOL8 __fastcall ssh_is_blocking(__int64 a1)
{
  return (*(_DWORD *)(a1 + 1104) & 1) != 0;
}

//----- (000000000002E531) ----------------------------------------------------
_BOOL8 __fastcall ssh_flush_termination(__int64 a1)
{
  return !(unsigned int)ssh_socket_buffered_write_bytes(*(_QWORD *)(a1 + 1048)) || *(_DWORD *)(a1 + 1164) == 9;
}

//----- (000000000002E579) ----------------------------------------------------
__int64 __fastcall ssh_blocking_flush(__int64 a1, unsigned int a2)
{
  unsigned int v3; // [rsp+1Ch] [rbp-4h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v3 = ssh_handle_packets_termination(a1, a2, (unsigned int (__fastcall *)(__int64))ssh_flush_termination, a1);
  if ( v3 == -1 )
    return 0xFFFFFFFFLL;
  if ( !ssh_flush_termination(a1) )
    return (unsigned int)-2;
  return v3;
}

//----- (000000000002E5DD) ----------------------------------------------------
__int64 __fastcall ssh_is_connected(__int64 a1)
{
  if ( a1 )
    return *(unsigned int *)(a1 + 1100);
  else
    return 0LL;
}

//----- (000000000002E5FF) ----------------------------------------------------
__int64 __fastcall ssh_get_fd(__int64 a1)
{
  if ( a1 )
    return ssh_socket_get_fd_in(*(unsigned int **)(a1 + 1048));
  else
    return 0xFFFFFFFFLL;
}

//----- (000000000002E62E) ----------------------------------------------------
__int64 __fastcall ssh_set_fd_toread(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    return ssh_socket_set_read_wontblock(*(_QWORD *)(a1 + 1048));
  return result;
}

//----- (000000000002E659) ----------------------------------------------------
__int64 __fastcall ssh_set_fd_towrite(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    return ssh_socket_set_write_wontblock(*(_QWORD *)(a1 + 1048));
  return result;
}

//----- (000000000002E684) ----------------------------------------------------
__int64 __fastcall ssh_set_fd_except(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    return ssh_socket_set_except(*(_QWORD *)(a1 + 1048));
  return result;
}

//----- (000000000002E6AF) ----------------------------------------------------
__int64 __fastcall ssh_handle_packets(__int64 a1, int a2)
{
  __int64 result; // rax
  int v3; // [rsp+10h] [rbp-20h]
  int milliseconds; // [rsp+10h] [rbp-20h]
  _QWORD *ctx; // [rsp+18h] [rbp-18h]
  __int64 *poll_handle_in; // [rsp+20h] [rbp-10h]
  __int64 poll_handle_out; // [rsp+28h] [rbp-8h]

  v3 = a2;
  if ( !a1 || !*(_QWORD *)(a1 + 1048) )
    return 0xFFFFFFFFLL;
  poll_handle_in = (__int64 *)ssh_socket_get_poll_handle_in(*(_QWORD *)(a1 + 1048));
  poll_handle_out = ssh_socket_get_poll_handle_out(*(_QWORD *)(a1 + 1048));
  ssh_poll_add_events(poll_handle_in, 1);
  ctx = (_QWORD *)ssh_poll_get_ctx((__int64)poll_handle_in);
  if ( !ctx )
  {
    ctx = (_QWORD *)ssh_poll_get_default_ctx(a1);
    ssh_poll_ctx_add(ctx, (__int64)poll_handle_in);
    if ( poll_handle_in != (__int64 *)poll_handle_out )
      ssh_poll_ctx_add(ctx, poll_handle_out);
  }
  if ( a2 != -2 )
    goto LABEL_11;
  if ( !ssh_is_blocking(a1) )
  {
    v3 = 0;
LABEL_11:
    LODWORD(result) = ssh_poll_ctx_dopoll((__int64)ctx, v3);
    goto LABEL_12;
  }
  milliseconds = ssh_make_milliseconds(*(_QWORD *)(a1 + 1616), *(_QWORD *)(a1 + 1624));
  LODWORD(result) = ssh_poll_ctx_dopoll((__int64)ctx, milliseconds);
LABEL_12:
  if ( (_DWORD)result == -1 )
    *(_DWORD *)(a1 + 1164) = 9;
  return (unsigned int)result;
}

//----- (000000000002E7EE) ----------------------------------------------------
__int64 __fastcall ssh_handle_packets_termination(
        __int64 a1,
        unsigned int a2,
        unsigned int (__fastcall *a3)(__int64),
        __int64 a4)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  unsigned int milliseconds; // [rsp+14h] [rbp-2Ch]
  unsigned int v12; // [rsp+28h] [rbp-18h]
  int i; // [rsp+2Ch] [rbp-14h]
  __time_t v14[2]; // [rsp+30h] [rbp-10h] BYREF

  milliseconds = a2;
  v12 = 0;
  if ( a2 == -2 )
  {
    if ( ssh_is_blocking(a1) )
      milliseconds = ssh_make_milliseconds(*(_QWORD *)(a1 + 1616), *(_QWORD *)(a1 + 1624));
    else
      milliseconds = 0;
  }
  else if ( a2 == -3 )
  {
    if ( ssh_is_blocking(a1) )
      milliseconds = -1;
    else
      milliseconds = 0;
  }
  if ( milliseconds )
    ssh_timestamp_init(v14);
  for ( i = milliseconds; !a3(a4); i = ssh_timeout_update(v14, milliseconds) )
  {
    v12 = ssh_handle_packets(a1, i);
    if ( v12 == -1 )
      break;
    if ( ssh_timeout_elapsed(v14, milliseconds, milliseconds, v4, v5, v6) )
    {
      if ( a3(a4) )
        return 0;
      else
        return (unsigned int)-2;
    }
  }
  return v12;
}
// 2E8BA: variable 'v4' is possibly undefined
// 2E8BA: variable 'v5' is possibly undefined
// 2E8BA: variable 'v6' is possibly undefined
// 2E7EE: using guessed type __time_t var_10[2];

//----- (000000000002E912) ----------------------------------------------------
__int64 __fastcall ssh_get_status(__int64 a1)
{
  unsigned int v2; // [rsp+18h] [rbp-8h]
  char status; // [rsp+1Ch] [rbp-4h]

  if ( !a1 )
    return 0LL;
  status = ssh_socket_get_status(*(_QWORD *)(a1 + 1048));
  v2 = *(_DWORD *)(a1 + 1164) == 10;
  if ( (status & 2) != 0 )
    v2 |= 2u;
  if ( (status & 8) != 0 )
    v2 |= 8u;
  if ( *(_DWORD *)(a1 + 1164) == 10 && (status & 4) != 0 || *(_DWORD *)(a1 + 1164) == 9 )
    v2 |= 4u;
  return v2;
}

//----- (000000000002E9A9) ----------------------------------------------------
__int64 __fastcall ssh_get_poll_flags(__int64 a1)
{
  if ( a1 )
    return ssh_socket_get_poll_flags(*(_QWORD *)(a1 + 1048));
  else
    return 0LL;
}

//----- (000000000002E9D8) ----------------------------------------------------
__int64 __fastcall ssh_get_disconnect_message(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( !a1 )
    return 0LL;
  if ( *(_DWORD *)(a1 + 1164) == 10 )
  {
    if ( *(_QWORD *)(a1 + 1120) )
      return *(_QWORD *)(a1 + 1120);
    ssh_set_error(a1, 2, "ssh_get_disconnect_message", "Connection correctly closed but no disconnect message", a5, a6);
  }
  else
  {
    ssh_set_error(a1, 1, "ssh_get_disconnect_message", "Connection not closed yet", a5, a6);
  }
  return 0LL;
}

//----- (000000000002EA71) ----------------------------------------------------
__int64 __fastcall ssh_get_version(__int64 a1)
{
  if ( a1 )
    return 2LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (000000000002EA8E) ----------------------------------------------------
__int64 __fastcall ssh_socket_exception_callback(
        unsigned int a1,
        unsigned int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  char *v8; // rax
  __int64 v9; // r9

  ssh_log(1, "ssh_socket_exception_callback", "Socket exception callback: %d (%d)", a1, a2, a6, a3);
  *(_DWORD *)(a3 + 1164) = 9;
  if ( a2 || a1 != 1 )
  {
    v8 = strerror(a2);
    ssh_set_error(a3, 2, "ssh_socket_exception_callback", "Socket error: %s", (__int64)v8, v9);
  }
  else
  {
    ssh_set_error(a3, 2, "ssh_socket_exception_callback", "Socket error: disconnected", v6, v7);
  }
  return (*(__int64 (__fastcall **)(__int64))(a3 + 1368))(a3);
}
// 2EB09: variable 'v6' is possibly undefined
// 2EB09: variable 'v7' is possibly undefined
// 2EB3F: variable 'v9' is possibly undefined

//----- (000000000002EB5B) ----------------------------------------------------
__int64 __fastcall ssh_send_ignore(__int64 a1, __int64 a2)
{
  if ( ssh_socket_is_open(*(_DWORD **)(a1 + 1048)) )
  {
    if ( (unsigned int)ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "bs", 2, 2LL, a2, 1332084403LL) )
    {
      ssh_set_error_oom(a1, "ssh_send_ignore");
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
      return 0xFFFFFFFFLL;
    }
    ssh_packet_send(a1);
    ssh_handle_packets(a1, 0);
  }
  return 0LL;
}

//----- (000000000002EC1E) ----------------------------------------------------
__int64 __fastcall ssh_send_debug(__int64 a1, __int64 a2, int a3)
{
  if ( ssh_socket_is_open(*(_DWORD **)(a1 + 1048)) )
  {
    if ( (unsigned int)ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "bbsd", 4, 4LL, a3 != 0, a2, 0LL, 1332084403LL) )
    {
      ssh_set_error_oom(a1, "ssh_send_debug");
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
      return 0xFFFFFFFFLL;
    }
    ssh_packet_send(a1);
    ssh_handle_packets(a1, 0);
  }
  return 0LL;
}

//----- (000000000002ECEF) ----------------------------------------------------
__int64 __fastcall ssh_set_counters(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  if ( a1 )
  {
    *(_QWORD *)(a1 + 1680) = a2;
    result = a1;
    *(_QWORD *)(a1 + 1688) = a3;
  }
  return result;
}

//----- (000000000002ED27) ----------------------------------------------------
__int64 ssh_socket_init()
{
  if ( !sockets_initialized )
  {
    ssh_poll_init();
    sockets_initialized = 1;
  }
  return 0LL;
}
// 2ED27: using guessed type __int64 ssh_socket_init();
// 281A50: using guessed type int sockets_initialized;

//----- (000000000002ED4B) ----------------------------------------------------
void ssh_socket_cleanup()
{
  if ( sockets_initialized == 1 )
  {
    ssh_poll_cleanup();
    sockets_initialized = 0;
  }
}
// 281A50: using guessed type int sockets_initialized;

//----- (000000000002ED6C) ----------------------------------------------------
_QWORD *__fastcall ssh_socket_new(__int64 a1)
{
  _QWORD *ptr; // [rsp+18h] [rbp-8h]

  ptr = malloc(0x50uLL);
  if ( ptr )
  {
    *(_DWORD *)ptr = -1;
    *((_DWORD *)ptr + 1) = -1;
    *((_DWORD *)ptr + 3) = -1;
    *((_DWORD *)ptr + 2) = 1;
    ptr[6] = a1;
    ptr[5] = ssh_buffer_new();
    if ( ptr[5] )
    {
      ptr[4] = ssh_buffer_new();
      if ( ptr[4] )
      {
        *((_DWORD *)ptr + 4) = 0;
        *((_DWORD *)ptr + 5) = 0;
        *((_DWORD *)ptr + 6) = 0;
        ptr[9] = 0LL;
        ptr[8] = ptr[9];
        *((_DWORD *)ptr + 7) = 0;
        return ptr;
      }
      else
      {
        ssh_set_error_oom(a1, "ssh_socket_new");
        ssh_buffer_free(ptr[5]);
        free(ptr);
        return 0LL;
      }
    }
    else
    {
      ssh_set_error_oom(a1, "ssh_socket_new");
      free(ptr);
      return 0LL;
    }
  }
  else
  {
    ssh_set_error_oom(a1, "ssh_socket_new");
    return 0LL;
  }
}
// 2EE16: conditional instruction was optimized away because %ptr.8!=0
// 2EE7B: conditional instruction was optimized away because %ptr.8!=0

//----- (000000000002EEE6) ----------------------------------------------------
__int64 __fastcall ssh_socket_reset(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)a1 = -1;
  *(_DWORD *)(a1 + 4) = -1;
  *(_DWORD *)(a1 + 12) = -1;
  *(_DWORD *)(a1 + 8) = 1;
  ssh_buffer_reinit(*(_QWORD *)(a1 + 40));
  ssh_buffer_reinit(*(_QWORD *)(a1 + 32));
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a1 + 72);
  result = a1;
  *(_DWORD *)(a1 + 28) = 0;
  return result;
}

//----- (000000000002EF88) ----------------------------------------------------
__int64 __fastcall ssh_socket_set_callbacks(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a1;
  *(_QWORD *)(a1 + 56) = a2;
  return result;
}

//----- (000000000002EFA3) ----------------------------------------------------
__int64 __fastcall ssh_socket_pollcallback(__int64 *a1, unsigned int a2, char a3, int *a4)
{
  __int64 len; // rdi
  const char *v6; // rax
  const char *v7; // rcx
  const char *v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 (__fastcall *v12)(__int64, __int64, __int64); // rbx
  __int64 v13; // r12
  __int64 v14; // r13
  __int64 v15; // rax
  int fd_in; // eax
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  unsigned int optval; // [rsp+2Ch] [rbp-1044h] BYREF
  socklen_t optlen; // [rsp+30h] [rbp-1040h] BYREF
  signed int v24; // [rsp+34h] [rbp-103Ch]
  int *v25; // [rsp+38h] [rbp-1038h]
  char v26[4104]; // [rsp+40h] [rbp-1030h] BYREF
  unsigned __int64 v27; // [rsp+1048h] [rbp-28h]

  v27 = __readfsqword(0x28u);
  v25 = a4;
  optval = 0;
  optlen = 4;
  if ( !ssh_socket_is_open(a4) )
    return 0xFFFFFFFFLL;
  len = (unsigned int)ssh_buffer_get_len(*((_QWORD *)v25 + 4));
  if ( (a3 & 8) != 0 )
    v6 = "POLLERR";
  else
    v6 = (const char *)&unk_572E8;
  if ( (a3 & 4) != 0 )
    v7 = "POLLOUT ";
  else
    v7 = (const char *)&unk_572E8;
  if ( (a3 & 1) != 0 )
    v8 = "POLLIN ";
  else
    v8 = (const char *)&unk_572E8;
  ssh_log(
    4,
    "ssh_socket_pollcallback",
    "Poll callback on socket %d (%s%s%s), out buffer %d",
    a2,
    (__int64)v8,
    (__int64)v7,
    v6,
    len);
  if ( (a3 & 8) != 0 || (a3 & 0x10) != 0 )
  {
    if ( v25[7] == 1 )
    {
      v25[7] = 4;
      v24 = getsockopt(a2, 1, 4, &optval, &optlen);
      if ( v24 < 0 )
        optval = *__errno_location();
      v25[3] = optval;
      ssh_socket_close((__int64)v25);
      if ( *((_QWORD *)v25 + 7) )
      {
        if ( *(_QWORD *)(*((_QWORD *)v25 + 7) + 32LL) )
          (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*((_QWORD *)v25 + 7) + 32LL))(
            2LL,
            optval,
            **((_QWORD **)v25 + 7));
      }
      return 0xFFFFFFFFLL;
    }
    a3 |= 1u;
  }
  if ( (a3 & 1) != 0 && v25[7] == 2 )
  {
    v25[4] = 1;
    v24 = ssh_socket_unbuffered_read(v25, v26, 0x1000u);
    if ( v24 < 0 )
    {
      if ( a1 )
        ssh_poll_remove_events(a1, 1);
      if ( *((_QWORD *)v25 + 7) && *(_QWORD *)(*((_QWORD *)v25 + 7) + 24LL) )
      {
        (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*((_QWORD *)v25 + 7) + 24LL))(
          2LL,
          (unsigned int)v25[3],
          **((_QWORD **)v25 + 7));
        return 4294967294LL;
      }
    }
    if ( !v24 )
    {
      if ( a1 )
      {
        ssh_poll_remove_events(a1, 1);
        ssh_poll_remove_events(a1, 1);
      }
      if ( *((_QWORD *)v25 + 7) && *(_QWORD *)(*((_QWORD *)v25 + 7) + 24LL) )
      {
        (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*((_QWORD *)v25 + 7) + 24LL))(
          1LL,
          0LL,
          **((_QWORD **)v25 + 7));
        return 4294967294LL;
      }
    }
    if ( v24 > 0 )
    {
      if ( *(_QWORD *)(*((_QWORD *)v25 + 6) + 1680LL) )
        **(_QWORD **)(*((_QWORD *)v25 + 6) + 1680LL) += v24;
      v24 = ssh_buffer_add_data(*((_QWORD *)v25 + 5), v26, v24);
      if ( v24 < 0 )
        return 0xFFFFFFFFLL;
      if ( *((_QWORD *)v25 + 7) && *(_QWORD *)(*((_QWORD *)v25 + 7) + 8LL) )
      {
        do
        {
          v12 = *(__int64 (__fastcall **)(__int64, __int64, __int64))(*((_QWORD *)v25 + 7) + 8LL);
          v13 = **((_QWORD **)v25 + 7);
          v14 = (unsigned int)ssh_buffer_get_len(*((_QWORD *)v25 + 5));
          v15 = ssh_buffer_get(*((_QWORD *)v25 + 5));
          v24 = v12(v15, v14, v13);
          ssh_buffer_pass_bytes(*((_QWORD *)v25 + 5), v24);
        }
        while ( v24 > 0 && v25[7] == 2 );
        a1 = 0LL;
      }
    }
  }
  if ( (a3 & 4) == 0 )
  {
LABEL_63:
    if ( *((_QWORD *)v25 + 8) && *((_QWORD *)v25 + 9) )
      return 0LL;
    else
      return 0xFFFFFFFFLL;
  }
  if ( v25[7] != 1 )
  {
    v25[5] = 1;
    if ( a1 )
      ssh_poll_remove_events(a1, 4);
    if ( (unsigned int)ssh_buffer_get_len(*((_QWORD *)v25 + 4)) )
    {
      ssh_socket_nonblocking_flush((__int64)v25);
    }
    else if ( *((_QWORD *)v25 + 7) && *(_QWORD *)(*((_QWORD *)v25 + 7) + 16LL) )
    {
      ssh_log(4, "ssh_socket_pollcallback", "sending control flow event", v17, v18, v19);
      (*(void (__fastcall **)(__int64, _QWORD))(*((_QWORD *)v25 + 7) + 16LL))(2LL, **((_QWORD **)v25 + 7));
    }
    goto LABEL_63;
  }
  ssh_log(3, "ssh_socket_pollcallback", "Received POLLOUT in connecting state", v9, v10, v11);
  v25[7] = 2;
  if ( a1 )
    ssh_poll_set_events(a1, 5u);
  fd_in = ssh_socket_get_fd_in((unsigned int *)v25);
  v24 = ssh_socket_set_blocking(fd_in);
  if ( v24 < 0 )
    return 0xFFFFFFFFLL;
  if ( *((_QWORD *)v25 + 7) && *(_QWORD *)(*((_QWORD *)v25 + 7) + 32LL) )
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*((_QWORD *)v25 + 7) + 32LL))(1LL, 0LL, **((_QWORD **)v25 + 7));
  return 0LL;
}
// 2F4EA: variable 'v9' is possibly undefined
// 2F4EA: variable 'v10' is possibly undefined
// 2F4EA: variable 'v11' is possibly undefined
// 2F631: variable 'v17' is possibly undefined
// 2F631: variable 'v18' is possibly undefined
// 2F631: variable 'v19' is possibly undefined

//----- (000000000002F6A8) ----------------------------------------------------
__int64 __fastcall ssh_socket_get_poll_handle_in(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 64) )
    return *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = ssh_poll_new(*(_DWORD *)a1, 0, (__int64)ssh_socket_pollcallback, a1);
  if ( *(_DWORD *)a1 == *(_DWORD *)(a1 + 4) && !*(_QWORD *)(a1 + 72) )
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a1 + 64);
  return *(_QWORD *)(a1 + 64);
}

//----- (000000000002F72E) ----------------------------------------------------
__int64 __fastcall ssh_socket_get_poll_handle_out(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 72) )
    return *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = ssh_poll_new(*(_DWORD *)(a1 + 4), 0, (__int64)ssh_socket_pollcallback, a1);
  if ( *(_DWORD *)a1 == *(_DWORD *)(a1 + 4) && !*(_QWORD *)(a1 + 64) )
    *(_QWORD *)(a1 + 64) = *(_QWORD *)(a1 + 72);
  return *(_QWORD *)(a1 + 72);
}

//----- (000000000002F7B5) ----------------------------------------------------
void __fastcall ssh_socket_free(__int64 *a1)
{
  if ( a1 )
  {
    ssh_socket_close((__int64)a1);
    ssh_buffer_free(a1[5]);
    ssh_buffer_free(a1[4]);
    free(a1);
  }
}

//----- (000000000002F814) ----------------------------------------------------
__int64 __fastcall ssh_socket_unix(__int64 a1, const char *a2)
{
  int *v2; // rax
  char *v3; // rax
  __int64 v4; // r9
  int *v6; // rax
  char *v7; // rax
  __int64 v8; // r9
  int *v9; // rax
  char *v10; // rax
  __int64 v11; // r9
  int fd; // [rsp+1Ch] [rbp-84h]
  struct sockaddr addr; // [rsp+20h] [rbp-80h] BYREF
  unsigned __int64 v14; // [rsp+98h] [rbp-8h]

  v14 = __readfsqword(0x28u);
  addr.sa_family = 1;
  snprintf(addr.sa_data, 0x6CuLL, "%s", a2);
  fd = socket(1, 1, 0);
  if ( fd == -1 )
  {
    v2 = __errno_location();
    v3 = strerror(*v2);
    ssh_set_error(
      *(_QWORD *)(a1 + 48),
      2,
      "ssh_socket_unix",
      "Error from socket(AF_UNIX, SOCK_STREAM, 0): %s",
      (__int64)v3,
      v4);
    return 0xFFFFFFFFLL;
  }
  else if ( fcntl(fd, 2, 1LL) == -1 )
  {
    v6 = __errno_location();
    v7 = strerror(*v6);
    ssh_set_error(*(_QWORD *)(a1 + 48), 2, "ssh_socket_unix", "Error from fcntl(fd, F_SETFD, 1): %s", (__int64)v7, v8);
    close(fd);
    return 0xFFFFFFFFLL;
  }
  else if ( connect(fd, &addr, 0x6Eu) >= 0 )
  {
    ssh_socket_set_fd(a1, fd);
    return 0LL;
  }
  else
  {
    v9 = __errno_location();
    v10 = strerror(*v9);
    ssh_set_error(*(_QWORD *)(a1 + 48), 2, "ssh_socket_unix", "Error from connect(): %s", (__int64)v10, v11);
    close(fd);
    return 0xFFFFFFFFLL;
  }
}
// 2F8C7: variable 'v4' is possibly undefined
// 2F931: variable 'v8' is possibly undefined
// 2F9A4: variable 'v11' is possibly undefined

//----- (000000000002F9EF) ----------------------------------------------------
__int64 __fastcall ssh_socket_close(__int64 a1)
{
  __int64 result; // rax

  if ( ssh_socket_is_open((_DWORD *)a1) )
  {
    if ( *(_DWORD *)(a1 + 4) != *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) != -1 )
    {
      close(*(_DWORD *)(a1 + 4));
      *(_DWORD *)(a1 + 4) = -1;
    }
    if ( *(_DWORD *)a1 != -1 )
    {
      close(*(_DWORD *)a1);
      *(_DWORD *)a1 = -1;
    }
    *(_DWORD *)(a1 + 12) = *__errno_location();
  }
  if ( *(_QWORD *)(a1 + 64) )
  {
    if ( *(_QWORD *)(a1 + 72) == *(_QWORD *)(a1 + 64) )
      *(_QWORD *)(a1 + 72) = 0LL;
    ssh_poll_free(*(_QWORD **)(a1 + 64));
    *(_QWORD *)(a1 + 64) = 0LL;
  }
  if ( *(_QWORD *)(a1 + 72) )
  {
    ssh_poll_free(*(_QWORD **)(a1 + 72));
    *(_QWORD *)(a1 + 72) = 0LL;
  }
  result = a1;
  *(_DWORD *)(a1 + 28) = 5;
  return result;
}

//----- (000000000002FAFE) ----------------------------------------------------
__int64 __fastcall ssh_socket_set_fd(__int64 a1, unsigned int a2)
{
  __int64 *poll_handle_in; // rax

  *(_DWORD *)(a1 + 4) = a2;
  *(_DWORD *)a1 = *(_DWORD *)(a1 + 4);
  if ( *(_QWORD *)(a1 + 64) )
    return ssh_poll_set_fd(*(_QWORD **)(a1 + 64), a2);
  *(_DWORD *)(a1 + 28) = 1;
  poll_handle_in = (__int64 *)ssh_socket_get_poll_handle_in(a1);
  return ssh_poll_set_events(poll_handle_in, 4u);
}

//----- (000000000002FB6F) ----------------------------------------------------
unsigned __int64 __fastcall ssh_socket_set_fd_in(__int64 a1, unsigned int a2)
{
  unsigned __int64 result; // rax

  *(_DWORD *)a1 = a2;
  result = *(_QWORD *)(a1 + 64);
  if ( result )
    return ssh_poll_set_fd(*(_QWORD **)(a1 + 64), a2);
  return result;
}

//----- (000000000002FBAC) ----------------------------------------------------
unsigned __int64 __fastcall ssh_socket_set_fd_out(__int64 a1, unsigned int a2)
{
  unsigned __int64 result; // rax

  *(_DWORD *)(a1 + 4) = a2;
  result = *(_QWORD *)(a1 + 72);
  if ( result )
    return ssh_poll_set_fd(*(_QWORD **)(a1 + 72), a2);
  return result;
}

//----- (000000000002FBEA) ----------------------------------------------------
__int64 __fastcall ssh_socket_get_fd_in(unsigned int *a1)
{
  return *a1;
}

//----- (000000000002FBFA) ----------------------------------------------------
_BOOL8 __fastcall ssh_socket_is_open(_DWORD *a1)
{
  return *a1 != -1;
}

//----- (000000000002FC13) ----------------------------------------------------
__int64 __fastcall ssh_socket_unbuffered_read(int *a1, void *a2, unsigned int a3)
{
  int v4; // [rsp+2Ch] [rbp-4h]

  if ( a1[6] )
    return 0xFFFFFFFFLL;
  if ( a1[2] )
    v4 = recv(*a1, a2, a3, 0);
  else
    v4 = read(*a1, a2, a3);
  a1[3] = *__errno_location();
  a1[4] = 0;
  if ( v4 < 0 )
    a1[6] = 1;
  return (unsigned int)v4;
}

//----- (000000000002FCB1) ----------------------------------------------------
__int64 __fastcall ssh_socket_unbuffered_write(__int64 a1, const void *a2, unsigned int a3)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int16 events; // ax
  int v8; // [rsp+2Ch] [rbp-4h]

  if ( *(_DWORD *)(a1 + 24) )
    return 0xFFFFFFFFLL;
  if ( *(_DWORD *)(a1 + 8) )
    v8 = send(*(_DWORD *)(a1 + 4), a2, a3, 0);
  else
    v8 = write(*(_DWORD *)(a1 + 4), a2, a3);
  *(_DWORD *)(a1 + 12) = *__errno_location();
  *(_DWORD *)(a1 + 20) = 0;
  if ( *(_QWORD *)(a1 + 72) )
  {
    ssh_log(3, "ssh_socket_unbuffered_write", "Enabling POLLOUT for socket", v4, v5, v6);
    events = ssh_poll_get_events(*(_QWORD *)(a1 + 72));
    ssh_poll_set_events(*(__int64 **)(a1 + 72), events | 4);
  }
  if ( v8 < 0 )
    *(_DWORD *)(a1 + 24) = 1;
  return (unsigned int)v8;
}
// 2FD63: variable 'v4' is possibly undefined
// 2FD63: variable 'v5' is possibly undefined
// 2FD63: variable 'v6' is possibly undefined

//----- (000000000002FDA6) ----------------------------------------------------
_BOOL8 __fastcall ssh_socket_fd_isset(_DWORD *a1, __int64 a2)
{
  if ( *a1 == -1 )
    return 0LL;
  return (*(_QWORD *)(a2 + 8LL * (*a1 / 64)) & (1LL << (*a1 % 64))) != 0
      || (*(_QWORD *)(a2 + 8LL * (a1[1] / 64)) & (1LL << (a1[1] % 64))) != 0;
}

//----- (000000000002FE5F) ----------------------------------------------------
unsigned __int64 __fastcall ssh_socket_fd_set(int *a1, __int64 a2, int *a3)
{
  unsigned __int64 result; // rax

  result = (unsigned int)*a1;
  if ( (_DWORD)result != -1 )
  {
    *(_QWORD *)(a2 + 8LL * (*a1 / 64)) |= 1LL << (*a1 % 64);
    *(_QWORD *)(a2 + 8LL * (a1[1] / 64)) |= 1LL << (a1[1] % 64);
    if ( *a1 >= 0 && *a1 >= *a3 && *a1 != -1 )
      *a3 = *a1 + 1;
    result = (unsigned int)a1[1];
    if ( (result & 0x80000000) == 0LL )
    {
      result = (unsigned int)*a3;
      if ( a1[1] >= (int)result )
      {
        result = (unsigned int)a1[1];
        if ( (_DWORD)result != -1 )
        {
          result = (unsigned __int64)a3;
          *a3 = a1[1] + 1;
        }
      }
    }
  }
  return result;
}

//----- (000000000002FF8B) ----------------------------------------------------
__int64 __fastcall ssh_socket_write(__int64 a1, const void *a2, signed int a3)
{
  if ( a3 > 0 )
  {
    if ( (int)ssh_buffer_add_data(*(_QWORD *)(a1 + 32), a2, a3) < 0 )
    {
      ssh_set_error_oom(*(_QWORD *)(a1 + 48), "ssh_socket_write");
      return 0xFFFFFFFFLL;
    }
    ssh_socket_nonblocking_flush(a1);
  }
  return 0LL;
}

//----- (000000000002FFF3) ----------------------------------------------------
__int64 __fastcall ssh_socket_nonblocking_flush(__int64 a1)
{
  char *v1; // rax
  __int64 v2; // r9
  const void *v4; // rax
  char *v5; // rax
  __int64 v6; // r9
  unsigned int len; // [rsp+10h] [rbp-10h]
  int v8; // [rsp+10h] [rbp-10h]
  signed int v9; // [rsp+14h] [rbp-Ch]
  __int64 v10; // [rsp+18h] [rbp-8h]

  v10 = *(_QWORD *)(a1 + 48);
  if ( !ssh_socket_is_open((_DWORD *)a1) )
  {
    *(_DWORD *)(v10 + 1100) = 0;
    if ( *(_QWORD *)(a1 + 56) && *(_QWORD *)(*(_QWORD *)(a1 + 56) + 24LL) )
    {
      (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)(a1 + 56) + 24LL))(
        2LL,
        *(unsigned int *)(a1 + 12),
        **(_QWORD **)(a1 + 56));
    }
    else
    {
      v1 = strerror(*(_DWORD *)(a1 + 12));
      ssh_set_error(
        v10,
        2,
        "ssh_socket_nonblocking_flush",
        "Writing packet: error on socket (or connection closed): %s",
        (__int64)v1,
        v2);
    }
    return 0xFFFFFFFFLL;
  }
  len = ssh_buffer_get_len(*(_QWORD *)(a1 + 32));
  if ( !*(_DWORD *)(a1 + 20) && *(_QWORD *)(a1 + 72) && len )
  {
LABEL_10:
    ssh_poll_add_events(*(__int64 **)(a1 + 72), 4);
    return 4294967294LL;
  }
  if ( !*(_DWORD *)(a1 + 20) || !len )
  {
LABEL_21:
    v8 = ssh_buffer_get_len(*(_QWORD *)(a1 + 32));
    if ( !*(_QWORD *)(a1 + 72) || !v8 )
      return 0LL;
    goto LABEL_10;
  }
  v4 = (const void *)ssh_buffer_get(*(_QWORD *)(a1 + 32));
  v9 = ssh_socket_unbuffered_write(a1, v4, len);
  if ( v9 >= 0 )
  {
    ssh_buffer_pass_bytes(*(_QWORD *)(a1 + 32), v9);
    if ( *(_QWORD *)(*(_QWORD *)(a1 + 48) + 1680LL) )
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 1680LL) + 8LL) += v9;
    goto LABEL_21;
  }
  *(_DWORD *)(v10 + 1100) = 0;
  ssh_socket_close(a1);
  if ( *(_QWORD *)(a1 + 56) && *(_QWORD *)(*(_QWORD *)(a1 + 56) + 24LL) )
  {
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)(a1 + 56) + 24LL))(
      2LL,
      *(unsigned int *)(a1 + 12),
      **(_QWORD **)(a1 + 56));
  }
  else
  {
    v5 = strerror(*(_DWORD *)(a1 + 12));
    ssh_set_error(
      v10,
      2,
      "ssh_socket_nonblocking_flush",
      "Writing packet: error on socket (or connection closed): %s",
      (__int64)v5,
      v6);
  }
  return 0xFFFFFFFFLL;
}
// 300A7: variable 'v2' is possibly undefined
// 301E5: variable 'v6' is possibly undefined

//----- (0000000000030295) ----------------------------------------------------
__int64 __fastcall ssh_socket_set_write_wontblock(__int64 a1)
{
  __int64 result; // rax

  result = a1;
  *(_DWORD *)(a1 + 20) = 1;
  return result;
}

//----- (00000000000302AB) ----------------------------------------------------
__int64 __fastcall ssh_socket_set_read_wontblock(__int64 a1)
{
  __int64 result; // rax

  result = a1;
  *(_DWORD *)(a1 + 16) = 1;
  return result;
}

//----- (00000000000302C1) ----------------------------------------------------
__int64 __fastcall ssh_socket_set_except(__int64 a1)
{
  __int64 result; // rax

  result = a1;
  *(_DWORD *)(a1 + 24) = 1;
  return result;
}

//----- (00000000000302D7) ----------------------------------------------------
__int64 __fastcall ssh_socket_data_available(__int64 a1)
{
  return *(unsigned int *)(a1 + 16);
}

//----- (00000000000302E8) ----------------------------------------------------
__int64 __fastcall ssh_socket_data_writable(__int64 a1)
{
  return *(unsigned int *)(a1 + 20);
}

//----- (00000000000302F9) ----------------------------------------------------
__int64 __fastcall ssh_socket_buffered_write_bytes(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 32) )
    return ssh_buffer_get_len(*(_QWORD *)(a1 + 32));
  else
    return 0LL;
}

//----- (0000000000030332) ----------------------------------------------------
__int64 __fastcall ssh_socket_get_status(__int64 a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-4h]

  v2 = 0;
  if ( (unsigned int)ssh_buffer_get_len(*(_QWORD *)(a1 + 40)) )
    v2 = 2;
  if ( (unsigned int)ssh_buffer_get_len(*(_QWORD *)(a1 + 32)) )
    v2 |= 8u;
  if ( *(_DWORD *)(a1 + 24) )
    v2 |= 4u;
  return v2;
}

//----- (0000000000030389) ----------------------------------------------------
__int64 __fastcall ssh_socket_get_poll_flags(__int64 a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-4h]

  v2 = 0;
  if ( *(_QWORD *)(a1 + 64) && (ssh_poll_get_events(*(_QWORD *)(a1 + 64)) & 1) != 0 )
    v2 = 2;
  if ( *(_QWORD *)(a1 + 72) && (ssh_poll_get_events(*(_QWORD *)(a1 + 72)) & 4) != 0 )
    v2 |= 8u;
  return v2;
}

//----- (00000000000303F3) ----------------------------------------------------
int __fastcall ssh_socket_set_nonblocking(int a1)
{
  return fcntl(a1, 4, 2048LL);
}

//----- (0000000000030419) ----------------------------------------------------
int __fastcall ssh_socket_set_blocking(int a1)
{
  return fcntl(a1, 4, 0LL);
}

//----- (000000000003043F) ----------------------------------------------------
__int64 __fastcall ssh_socket_connect(
        __int64 a1,
        const char *a2,
        unsigned int a3,
        const char *a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // [rsp+2Ch] [rbp-4h]

  if ( *(_DWORD *)(a1 + 28) )
  {
    ssh_set_error(
      *(_QWORD *)(a1 + 48),
      2,
      "ssh_socket_connect",
      "ssh_socket_connect called on socket not unconnected",
      a5,
      a6);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v9 = ssh_connect_host_nonblocking(*(_QWORD *)(a1 + 48), a2, a4, a3);
    ssh_log(2, "ssh_socket_connect", "Nonblocking connection socket: %d", v9, v7, v8);
    if ( v9 == -1 )
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      ssh_socket_set_fd(a1, v9);
      return 0LL;
    }
  }
}
// 304CB: variable 'v7' is possibly undefined
// 304CB: variable 'v8' is possibly undefined

//----- (00000000000304F5) ----------------------------------------------------
void __fastcall __noreturn ssh_execute_command(char *a1, int a2, int a3)
{
  char *path[4]; // [rsp+10h] [rbp-20h] BYREF

  path[0] = "/bin/sh";
  path[1] = "-c";
  path[2] = a1;
  path[3] = 0LL;
  dup2(a2, 0);
  dup2(a3, 1);
  dup2(a3, 2);
  close(a2);
  close(a3);
  execv("/bin/sh", path);
  exit(1);
}

//----- (000000000003058B) ----------------------------------------------------
__int64 __fastcall ssh_socket_connect_proxycommand(__int64 a1, char *a2)
{
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 *poll_handle_in; // rax
  __int64 *poll_handle_out; // rax
  int pipedes[2]; // [rsp+20h] [rbp-10h] BYREF
  int v9[2]; // [rsp+28h] [rbp-8h] BYREF

  if ( *(_DWORD *)(a1 + 28) )
    return 0xFFFFFFFFLL;
  if ( pipe(pipedes) < 0 )
    return 0xFFFFFFFFLL;
  if ( pipe(v9) < 0 )
    return 0xFFFFFFFFLL;
  ssh_log(2, "ssh_socket_connect_proxycommand", "Executing proxycommand '%s'", (__int64)a2, v3, v4);
  if ( !fork() )
    ssh_execute_command(a2, v9[0], pipedes[1]);
  close(pipedes[1]);
  close(v9[0]);
  ssh_log(
    2,
    "ssh_socket_connect_proxycommand",
    "ProxyCommand connection pipe: [%d,%d]",
    (unsigned int)pipedes[0],
    (unsigned int)v9[1],
    v5);
  ssh_socket_set_fd_in(a1, pipedes[0]);
  ssh_socket_set_fd_out(a1, v9[1]);
  *(_DWORD *)(a1 + 28) = 2;
  *(_DWORD *)(a1 + 8) = 0;
  poll_handle_in = (__int64 *)ssh_socket_get_poll_handle_in(a1);
  ssh_poll_set_events(poll_handle_in, 1u);
  poll_handle_out = (__int64 *)ssh_socket_get_poll_handle_out(a1);
  ssh_poll_set_events(poll_handle_out, 4u);
  if ( *(_QWORD *)(a1 + 56) )
  {
    if ( *(_QWORD *)(*(_QWORD *)(a1 + 56) + 32LL) )
      (*(void (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)(a1 + 56) + 32LL))(1LL, 0LL, **(_QWORD **)(a1 + 56));
  }
  return 0LL;
}
// 3060D: variable 'v3' is possibly undefined
// 3060D: variable 'v4' is possibly undefined
// 3066B: variable 'v5' is possibly undefined

//----- (0000000000030722) ----------------------------------------------------
_BYTE *__fastcall ssh_string_new(unsigned __int64 a1)
{
  _BYTE *v2; // [rsp+18h] [rbp-8h]

  if ( a1 > 0xFFFFFFFA )
    return 0LL;
  v2 = malloc(a1 + 5);
  if ( !v2 )
    return 0LL;
  *(_DWORD *)v2 = htonl(a1);
  v2[4] = 0;
  return v2;
}

//----- (000000000003078B) ----------------------------------------------------
__int64 __fastcall ssh_string_fill(uint32_t *a1, const void *a2, size_t a3)
{
  if ( !a1 || !a2 || !a3 || ssh_string_len(a1) < a3 )
    return 0xFFFFFFFFLL;
  memcpy(a1 + 1, a2, a3);
  return 0LL;
}

//----- (00000000000307EF) ----------------------------------------------------
_BYTE *__fastcall ssh_string_from_char(const char *a1)
{
  unsigned __int64 n; // [rsp+10h] [rbp-10h]
  _BYTE *v3; // [rsp+18h] [rbp-8h]

  if ( a1 )
  {
    n = strlen(a1);
    v3 = ssh_string_new(n);
    if ( v3 )
    {
      memcpy(v3 + 4, a1, n);
      return v3;
    }
    else
    {
      return 0LL;
    }
  }
  else
  {
    *__errno_location() = 22;
    return 0LL;
  }
}

//----- (0000000000030863) ----------------------------------------------------
__int64 __fastcall ssh_string_len(uint32_t *a1)
{
  __int64 result; // rax

  if ( !a1 )
    return 0LL;
  LODWORD(result) = ntohl(*a1);
  if ( !(_DWORD)result || (unsigned int)result == 0xFFFFFFFFLL )
    return 0LL;
  else
    return (unsigned int)result;
}

//----- (00000000000308AF) ----------------------------------------------------
uint32_t *__fastcall ssh_string_get_char(uint32_t *a1)
{
  if ( !a1 )
    return 0LL;
  *((_BYTE *)a1 + ssh_string_len(a1) + 4) = 0;
  return a1 + 1;
}

//----- (00000000000308EB) ----------------------------------------------------
void *__fastcall ssh_string_to_char(uint32_t *a1)
{
  unsigned __int64 n; // [rsp+10h] [rbp-10h]
  void *dest; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  n = ssh_string_len(a1);
  if ( n + 1 < n )
    return 0LL;
  dest = malloc(n + 1);
  if ( !dest )
    return 0LL;
  memcpy(dest, a1 + 1, n);
  *((_BYTE *)dest + n) = 0;
  return dest;
}

//----- (000000000003097B) ----------------------------------------------------
void __fastcall ssh_string_free_char(void *a1)
{
  if ( a1 )
    free(a1);
}

//----- (00000000000309A5) ----------------------------------------------------
_BYTE *__fastcall ssh_string_copy(uint32_t *a1)
{
  __int64 n; // [rsp+10h] [rbp-10h]
  _BYTE *v3; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0LL;
  n = ssh_string_len(a1);
  if ( !n )
    return 0LL;
  v3 = ssh_string_new(n);
  if ( !v3 )
    return 0LL;
  memcpy(v3 + 4, a1 + 1, n);
  return v3;
}

//----- (0000000000030A20) ----------------------------------------------------
void __fastcall ssh_string_burn(uint32_t *a1)
{
  __int64 v1; // rax

  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = ssh_string_len(a1);
      explicit_bzero(a1 + 1, v1);
    }
  }
}

//----- (0000000000030A64) ----------------------------------------------------
__int64 __fastcall ssh_string_data(__int64 a1)
{
  if ( a1 )
    return a1 + 4;
  else
    return 0LL;
}

//----- (0000000000030A84) ----------------------------------------------------
void __fastcall ssh_string_free(void *a1)
{
  if ( a1 )
    free(a1);
}

//----- (0000000000030AAE) ----------------------------------------------------
__int64 ssh_threads_init()
{
  unsigned int v1; // [rsp+Ch] [rbp-4h]

  if ( threads_initialized_8492 )
    return 0LL;
  if ( !user_callbacks )
    user_callbacks = (__int64)ssh_threads_get_default();
  v1 = crypto_thread_init(user_callbacks);
  if ( !v1 )
    threads_initialized_8492 = 1;
  return v1;
}
// 30AAE: using guessed type __int64 ssh_threads_init();
// 38149: using guessed type __int64 __fastcall crypto_thread_init(_QWORD);
// 281A58: using guessed type __int64 user_callbacks;
// 281A60: using guessed type int threads_initialized_8492;

//----- (0000000000030B06) ----------------------------------------------------
void ssh_threads_finalize()
{
  crypto_thread_finalize();
}

//----- (0000000000030B12) ----------------------------------------------------
__int64 __fastcall ssh_threads_set_callbacks(__int64 a1)
{
  if ( user_callbacks )
    crypto_thread_finalize();
  user_callbacks = a1;
  return (unsigned int)crypto_thread_init(a1);
}
// 38149: using guessed type __int64 __fastcall crypto_thread_init(_QWORD);
// 281A58: using guessed type __int64 user_callbacks;

//----- (0000000000030B51) ----------------------------------------------------
__int64 ssh_threads_get_type()
{
  if ( user_callbacks )
    return *(_QWORD *)user_callbacks;
  else
    return 0LL;
}
// 30B51: using guessed type __int64 ssh_threads_get_type();
// 281A58: using guessed type __int64 user_callbacks;

//----- (0000000000030B74) ----------------------------------------------------
char **ssh_get_hmactab()
{
  return &ssh_hmac_tab;
}
// 280D80: using guessed type char *ssh_hmac_tab;

//----- (0000000000030B81) ----------------------------------------------------
__int64 __fastcall hmac_digest_len(int a1)
{
  __int64 result; // rax

  switch ( a1 )
  {
    case 1:
      result = 20LL;
      break;
    case 2:
      result = 32LL;
      break;
    case 3:
      result = 48LL;
      break;
    case 4:
      result = 64LL;
      break;
    case 5:
      result = 16LL;
      break;
    case 6:
      result = 16LL;
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}

//----- (0000000000030BE3) ----------------------------------------------------
char *__fastcall ssh_hmac_type_to_string(int a1)
{
  int v2; // [rsp+14h] [rbp-Ch]
  char **hmactab; // [rsp+18h] [rbp-8h]

  v2 = 0;
  hmactab = ssh_get_hmactab();
  while ( hmactab[2 * v2] && LODWORD(hmactab[2 * v2 + 1]) != a1 )
    ++v2;
  return hmactab[2 * v2];
}

//----- (0000000000030C52) ----------------------------------------------------
void *__fastcall cipher_new(int a1)
{
  char **ciphertab; // rax
  void *dest; // [rsp+18h] [rbp-8h]

  dest = malloc(0x80uLL);
  if ( !dest )
    return 0LL;
  ciphertab = ssh_get_ciphertab();
  memcpy(dest, &ciphertab[16 * (__int64)a1], 0x80uLL);
  return dest;
}

//----- (0000000000030CB0) ----------------------------------------------------
__int64 __fastcall ssh_cipher_clear(__int64 a1)
{
  __int64 result; // rax
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 32) )
    {
      for ( i = 0; (unsigned __int64)i < *(_QWORD *)(a1 + 24) >> 3; ++i )
        gcry_cipher_close(*(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 32)));
      if ( *(_QWORD *)(a1 + 32) )
      {
        free(*(void **)(a1 + 32));
        *(_QWORD *)(a1 + 32) = 0LL;
      }
    }
    result = *(_QWORD *)(a1 + 120);
    if ( result )
      return (*(__int64 (__fastcall **)(__int64))(a1 + 120))(a1);
  }
  return result;
}
// E030: using guessed type __int64 __fastcall gcry_cipher_close(_QWORD);

//----- (0000000000030D5E) ----------------------------------------------------
void __fastcall cipher_free(void *a1)
{
  ssh_cipher_clear((__int64)a1);
  if ( a1 )
    free(a1);
}

//----- (0000000000030D94) ----------------------------------------------------
void *crypto_new()
{
  void *s; // [rsp+8h] [rbp-8h]

  s = malloc(0x288uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x288uLL);
  return s;
}

//----- (0000000000030DDB) ----------------------------------------------------
void __fastcall crypto_free(_QWORD *a1)
{
  int i; // [rsp+1Ch] [rbp-4h]

  if ( a1 )
  {
    ssh_key_free((void *)a1[41]);
    cipher_free((void *)a1[38]);
    cipher_free((void *)a1[39]);
    if ( *a1 )
    {
      gcry_mpi_release(*a1);
      *a1 = 0LL;
    }
    if ( a1[1] )
    {
      gcry_mpi_release(a1[1]);
      a1[1] = 0LL;
    }
    if ( a1[2] )
    {
      gcry_mpi_release(a1[2]);
      a1[2] = 0LL;
    }
    if ( a1[4] )
    {
      gcry_mpi_release(a1[4]);
      a1[4] = 0LL;
    }
    if ( a1[3] )
    {
      gcry_mpi_release(a1[3]);
      a1[3] = 0LL;
    }
    if ( a1[6] )
    {
      free((void *)a1[6]);
      a1[6] = 0LL;
    }
    if ( a1[7] )
    {
      free((void *)a1[7]);
      a1[7] = 0LL;
    }
    if ( a1[5] )
    {
      gcry_sexp_release(a1[5]);
      a1[5] = 0LL;
    }
    if ( a1[22] )
    {
      memset((void *)a1[22], 0, a1[21]);
      if ( a1[22] )
      {
        free((void *)a1[22]);
        a1[22] = 0LL;
      }
    }
    if ( a1[23] )
    {
      memset((void *)a1[23], 0, a1[21]);
      if ( a1[23] )
      {
        free((void *)a1[23]);
        a1[23] = 0LL;
      }
    }
    if ( a1[44] && (unsigned int)deflateEnd(a1[44]) )
      inflateEnd(a1[44]);
    if ( a1[44] )
    {
      free((void *)a1[44]);
      a1[44] = 0LL;
    }
    if ( a1[45] && (unsigned int)deflateEnd(a1[45]) )
      inflateEnd(a1[45]);
    if ( a1[45] )
    {
      free((void *)a1[45]);
      a1[45] = 0LL;
    }
    if ( a1[24] )
    {
      free((void *)a1[24]);
      a1[24] = 0LL;
    }
    if ( a1[25] )
    {
      free((void *)a1[25]);
      a1[25] = 0LL;
    }
    if ( a1[28] )
    {
      free((void *)a1[28]);
      a1[28] = 0LL;
    }
    if ( a1[29] )
    {
      free((void *)a1[29]);
      a1[29] = 0LL;
    }
    if ( a1[27] )
    {
      memset((void *)a1[27], 0, a1[21]);
      if ( a1[27] )
      {
        free((void *)a1[27]);
        a1[27] = 0LL;
      }
    }
    if ( a1[26] )
    {
      memset((void *)a1[26], 0, a1[21]);
      if ( a1[26] )
      {
        free((void *)a1[26]);
        a1[26] = 0LL;
      }
    }
    for ( i = 0; i <= 9; ++i )
    {
      if ( a1[i + 60] )
      {
        free((void *)a1[i + 60]);
        a1[i + 60] = 0LL;
      }
      if ( a1[i + 48] )
      {
        free((void *)a1[i + 48]);
        a1[i + 48] = 0LL;
      }
      if ( a1[i + 70] )
      {
        free((void *)a1[i + 70]);
        a1[i + 70] = 0LL;
      }
    }
    explicit_bzero(a1, 0x288uLL);
    free(a1);
  }
}
// 313E9: conditional instruction was optimized away because rdi.8!=0
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// DD30: using guessed type __int64 __fastcall inflateEnd(_QWORD);
// DE30: using guessed type __int64 __fastcall gcry_mpi_release(_QWORD);
// DE40: using guessed type __int64 __fastcall deflateEnd(_QWORD);

//----- (0000000000031404) ----------------------------------------------------
__int64 __fastcall crypt_set_algorithms2(__int64 a1)
{
  __int64 v1; // r8
  __int64 v2; // r9
  __int64 v4; // rbx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rbx
  __int64 v10; // r8
  int v11; // [rsp+10h] [rbp-30h]
  int i; // [rsp+10h] [rbp-30h]
  int j; // [rsp+10h] [rbp-30h]
  int k; // [rsp+10h] [rbp-30h]
  char *s1; // [rsp+18h] [rbp-28h]
  char *s1a; // [rsp+18h] [rbp-28h]
  char *s1b; // [rsp+18h] [rbp-28h]
  char **ciphertab; // [rsp+20h] [rbp-20h]
  char **hmactab; // [rsp+28h] [rbp-18h]

  v11 = 0;
  ciphertab = ssh_get_ciphertab();
  hmactab = ssh_get_hmactab();
  s1 = *(char **)(*(_QWORD *)(a1 + 1240) + 576LL);
  while ( ciphertab[16 * (__int64)v11] && strcmp(s1, ciphertab[16 * (__int64)v11]) )
    ++v11;
  if ( !ciphertab[16 * (__int64)v11] )
  {
    ssh_set_error(
      a1,
      2,
      "crypt_set_algorithms2",
      "crypt_set_algorithms2: no crypto algorithm function found for %s",
      (__int64)s1,
      v2);
    return 0xFFFFFFFFLL;
  }
  ssh_log(3, "crypt_set_algorithms2", "Set output algorithm to %s", (__int64)s1, v1, v2);
  v4 = *(_QWORD *)(a1 + 1240);
  *(_QWORD *)(v4 + 312) = cipher_new(v11);
  if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 312LL) )
    goto LABEL_8;
  if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 312LL) + 96LL) )
    s1a = "aead-poly1305";
  else
    s1a = *(char **)(*(_QWORD *)(a1 + 1240) + 592LL);
  for ( i = 0; hmactab[2 * i] && strcmp(s1a, hmactab[2 * i]); ++i )
    ;
  if ( !hmactab[2 * i] )
  {
LABEL_17:
    ssh_set_error(
      a1,
      2,
      "crypt_set_algorithms2",
      "crypt_set_algorithms2: no hmac algorithm function found for %s",
      (__int64)s1a,
      v6);
    return 0xFFFFFFFFLL;
  }
  ssh_log(3, "crypt_set_algorithms2", "Set HMAC output algorithm to %s", (__int64)s1a, v5, v6);
  *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 324LL) = hmactab[2 * i + 1];
  s1b = *(char **)(*(_QWORD *)(a1 + 1240) + 584LL);
  for ( j = 0; ciphertab[16 * (__int64)j] && strcmp(s1b, ciphertab[16 * (__int64)j]); ++j )
    ;
  if ( ciphertab[16 * (__int64)j] )
  {
    ssh_log(3, "crypt_set_algorithms2", "Set input algorithm to %s", (__int64)s1b, v7, v8);
    v9 = *(_QWORD *)(a1 + 1240);
    *(_QWORD *)(v9 + 304) = cipher_new(j);
    if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 304LL) )
    {
LABEL_8:
      ssh_set_error_oom(a1, "crypt_set_algorithms2");
      return 0xFFFFFFFFLL;
    }
    if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 304LL) + 96LL) )
      s1a = "aead-poly1305";
    else
      s1a = *(char **)(*(_QWORD *)(a1 + 1240) + 600LL);
    for ( k = 0; hmactab[2 * k] && strcmp(s1a, hmactab[2 * k]); ++k )
      ;
    if ( !hmactab[2 * k] )
      goto LABEL_17;
    ssh_log(3, "crypt_set_algorithms2", "Set HMAC input algorithm to %s", (__int64)s1a, v10, v6);
    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 320LL) = hmactab[2 * k + 1];
    if ( !strcmp(*(const char **)(*(_QWORD *)(a1 + 1240) + 608LL), "zlib") )
      *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 336LL) = 1;
    if ( !strcmp(*(const char **)(*(_QWORD *)(a1 + 1240) + 616LL), "zlib") )
      *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 340LL) = 1;
    if ( !strcmp(*(const char **)(*(_QWORD *)(a1 + 1240) + 608LL), "zlib@openssh.com") )
      *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 348LL) = 1;
    if ( !strcmp(*(const char **)(*(_QWORD *)(a1 + 1240) + 616LL), "zlib@openssh.com") )
      *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 344LL) = 1;
    return 0LL;
  }
  else
  {
    ssh_set_error(
      a1,
      2,
      "crypt_set_algorithms2",
      "Crypt_set_algorithms: no crypto algorithm function found for %s",
      (__int64)s1b,
      v8);
    return 0xFFFFFFFFLL;
  }
}
// 314CB: variable 'v2' is possibly undefined
// 314F9: variable 'v1' is possibly undefined
// 3162D: variable 'v6' is possibly undefined
// 3165B: variable 'v5' is possibly undefined
// 31738: variable 'v8' is possibly undefined
// 31766: variable 'v7' is possibly undefined
// 318C1: variable 'v10' is possibly undefined

//----- (00000000000319E9) ----------------------------------------------------
__int64 __fastcall crypt_set_algorithms_client(__int64 a1)
{
  return crypt_set_algorithms2(a1);
}

//----- (0000000000031A03) ----------------------------------------------------
__int64 __fastcall crypt_set_algorithms_server(__int64 a1)
{
  __int64 v1; // r8
  __int64 v2; // r9
  __int64 v4; // rbx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rbx
  __int64 v10; // r8
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  int i; // [rsp+18h] [rbp-38h]
  int v24; // [rsp+18h] [rbp-38h]
  int j; // [rsp+18h] [rbp-38h]
  int k; // [rsp+18h] [rbp-38h]
  char *s1; // [rsp+28h] [rbp-28h]
  char *s1a; // [rsp+28h] [rbp-28h]
  char *s1b; // [rsp+28h] [rbp-28h]
  char *s1c; // [rsp+28h] [rbp-28h]
  char *s1d; // [rsp+28h] [rbp-28h]
  char **ciphertab; // [rsp+30h] [rbp-20h]
  char **hmactab; // [rsp+38h] [rbp-18h]

  ciphertab = ssh_get_ciphertab();
  hmactab = ssh_get_hmactab();
  if ( !a1 )
    return 0xFFFFFFFFLL;
  s1 = *(char **)(*(_QWORD *)(a1 + 1240) + 584LL);
  for ( i = 0; ciphertab[16 * (__int64)i] && strcmp(s1, ciphertab[16 * (__int64)i]); ++i )
    ;
  if ( !ciphertab[16 * (__int64)i] )
  {
    ssh_set_error(
      a1,
      2,
      "crypt_set_algorithms_server",
      "crypt_set_algorithms_server : no crypto algorithm function found for %s",
      (__int64)s1,
      v2);
    return 0xFFFFFFFFLL;
  }
  ssh_log(3, "crypt_set_algorithms_server", "Set output algorithm %s", (__int64)s1, v1, v2);
  v4 = *(_QWORD *)(a1 + 1240);
  *(_QWORD *)(v4 + 312) = cipher_new(i);
  if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 312LL) )
    goto LABEL_10;
  v24 = 0;
  if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 312LL) + 96LL) )
    s1a = "aead-poly1305";
  else
    s1a = *(char **)(*(_QWORD *)(a1 + 1240) + 600LL);
  while ( hmactab[2 * v24] && strcmp(s1a, hmactab[2 * v24]) )
    ++v24;
  if ( !hmactab[2 * v24] )
  {
LABEL_18:
    ssh_set_error(
      a1,
      2,
      "crypt_set_algorithms_server",
      "crypt_set_algorithms_server: no hmac algorithm function found for %s",
      (__int64)s1a,
      v6);
    return 0xFFFFFFFFLL;
  }
  ssh_log(3, "crypt_set_algorithms_server", "Set HMAC output algorithm to %s", (__int64)s1a, v5, v6);
  *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 324LL) = hmactab[2 * v24 + 1];
  s1b = *(char **)(*(_QWORD *)(a1 + 1240) + 576LL);
  for ( j = 0; ciphertab[16 * (__int64)j] && strcmp(s1b, ciphertab[16 * (__int64)j]); ++j )
    ;
  if ( ciphertab[16 * (__int64)j] )
  {
    ssh_log(3, "crypt_set_algorithms_server", "Set input algorithm %s", (__int64)s1b, v7, v8);
    v9 = *(_QWORD *)(a1 + 1240);
    *(_QWORD *)(v9 + 304) = cipher_new(j);
    if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 304LL) )
    {
LABEL_10:
      ssh_set_error_oom(a1, "crypt_set_algorithms_server");
      return 0xFFFFFFFFLL;
    }
    if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 304LL) + 96LL) )
      s1a = "aead-poly1305";
    else
      s1a = *(char **)(*(_QWORD *)(a1 + 1240) + 592LL);
    for ( k = 0; hmactab[2 * k] && strcmp(s1a, hmactab[2 * k]); ++k )
      ;
    if ( !hmactab[2 * k] )
      goto LABEL_18;
    ssh_log(3, "crypt_set_algorithms_server", "Set HMAC input algorithm to %s", (__int64)s1a, v10, v6);
    *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 320LL) = hmactab[2 * k + 1];
    s1c = *(char **)(*(_QWORD *)(a1 + 1240) + 608LL);
    if ( !strcmp(s1c, "zlib") )
    {
      ssh_log(3, "crypt_set_algorithms_server", "enabling C->S compression", v11, v12, v13);
      *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 340LL) = 1;
    }
    if ( !strcmp(s1c, "zlib@openssh.com") )
    {
      ssh_log(3, "crypt_set_algorithms_server", "enabling C->S delayed compression", v14, v15, v16);
      if ( (*(_DWORD *)(a1 + 1104) & 2) != 0 )
        *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 340LL) = 1;
      else
        *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 344LL) = 1;
    }
    s1d = *(char **)(*(_QWORD *)(a1 + 1240) + 616LL);
    if ( !strcmp(s1d, "zlib") )
    {
      ssh_log(3, "crypt_set_algorithms_server", "enabling S->C compression", v17, v18, v19);
      *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 336LL) = 1;
    }
    if ( !strcmp(s1d, "zlib@openssh.com") )
    {
      ssh_log(3, "crypt_set_algorithms_server", "enabling S->C delayed compression", v20, v21, v22);
      if ( (*(_DWORD *)(a1 + 1104) & 2) != 0 )
        *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 336LL) = 1;
      else
        *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 348LL) = 1;
    }
    *(_DWORD *)(a1 + 1320) = ssh_key_type_from_name(*(const char **)(*(_QWORD *)(a1 + 1240) + 568LL));
    return 0LL;
  }
  else
  {
    ssh_set_error(
      a1,
      2,
      "crypt_set_algorithms_server",
      "Crypt_set_algorithms_server :no crypto algorithm function found for %s",
      (__int64)s1b,
      v8);
    return 0xFFFFFFFFLL;
  }
}
// 31AF2: variable 'v2' is possibly undefined
// 31B20: variable 'v1' is possibly undefined
// 31C45: variable 'v6' is possibly undefined
// 31C73: variable 'v5' is possibly undefined
// 31D57: variable 'v8' is possibly undefined
// 31D85: variable 'v7' is possibly undefined
// 31EE7: variable 'v10' is possibly undefined
// 31F60: variable 'v11' is possibly undefined
// 31F60: variable 'v12' is possibly undefined
// 31F60: variable 'v13' is possibly undefined
// 31FA9: variable 'v14' is possibly undefined
// 31FA9: variable 'v15' is possibly undefined
// 31FA9: variable 'v16' is possibly undefined
// 32030: variable 'v17' is possibly undefined
// 32030: variable 'v18' is possibly undefined
// 32030: variable 'v19' is possibly undefined
// 32079: variable 'v20' is possibly undefined
// 32079: variable 'v21' is possibly undefined
// 32079: variable 'v22' is possibly undefined

//----- (00000000000320F5) ----------------------------------------------------
unsigned __int64 __fastcall bcrypt_hash(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // eax
  __int16 v6; // [rsp+28h] [rbp-10A8h] BYREF
  unsigned __int16 v7; // [rsp+2Ah] [rbp-10A6h]
  int i; // [rsp+2Ch] [rbp-10A4h]
  int v9[8]; // [rsp+30h] [rbp-10A0h] BYREF
  _DWORD s[1044]; // [rsp+50h] [rbp-1080h] BYREF
  __int64 v11[5]; // [rsp+10A0h] [rbp-30h] BYREF
  unsigned __int64 v12; // [rsp+10C8h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  qmemcpy(v11, "OxychromaticBlowfishSwatDynamite", 32);
  v7 = 64;
  Blowfish_initstate((char *)s);
  Blowfish_expandstate(s, a2, 0x40u, a1, 0x40u);
  for ( i = 0; i <= 63; ++i )
  {
    Blowfish_expand0state(s, a2, v7);
    Blowfish_expand0state(s, a1, v7);
  }
  v6 = 0;
  for ( i = 0; i <= 7; ++i )
  {
    v3 = Blowfish_stream2word((__int64)v11, 0x20u, &v6);
    v9[i] = v3;
  }
  for ( i = 0; i <= 63; ++i )
    ssh_blf_enc(s, v9, 4u);
  for ( i = 0; i <= 7; ++i )
  {
    *(_BYTE *)(a3 + 4 * i + 3LL) = HIBYTE(v9[i]);
    *(_BYTE *)(a3 + 4 * i + 2LL) = BYTE2(v9[i]);
    *(_WORD *)(a3 + 4 * i) = v9[i];
  }
  explicit_bzero(v11, 0x20uLL);
  explicit_bzero(v9, 0x20uLL);
  memset(s, 0, 0x1048uLL);
  return __readfsqword(0x28u) ^ v12;
}
// 320F5: using guessed type int var_10A0[8];

//----- (00000000000323AC) ----------------------------------------------------
__int64 __fastcall bcrypt_pbkdf(
        __int64 a1,
        __int64 a2,
        const void *a3,
        size_t a4,
        __int64 a5,
        unsigned __int64 a6,
        unsigned int a7)
{
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // [rsp+0h] [rbp-150h]
  int v13; // [rsp+3Ch] [rbp-114h]
  unsigned __int64 i; // [rsp+40h] [rbp-110h]
  unsigned __int64 k; // [rsp+40h] [rbp-110h]
  unsigned __int64 j; // [rsp+48h] [rbp-108h]
  unsigned __int64 v17; // [rsp+50h] [rbp-100h]
  void *dest; // [rsp+60h] [rbp-F0h]
  unsigned __int64 v20; // [rsp+68h] [rbp-E8h]
  __int64 v21; // [rsp+70h] [rbp-E0h]
  __int64 v22; // [rsp+70h] [rbp-E0h]
  __int64 v23; // [rsp+70h] [rbp-E0h]
  __int64 v24[4]; // [rsp+80h] [rbp-D0h] BYREF
  __int64 v25[4]; // [rsp+A0h] [rbp-B0h] BYREF
  char v26[64]; // [rsp+C0h] [rbp-90h] BYREF
  char v27[72]; // [rsp+100h] [rbp-50h] BYREF
  unsigned __int64 v28; // [rsp+148h] [rbp-8h]

  v9 = a6;
  v28 = __readfsqword(0x28u);
  if ( !a7 )
    return 0xFFFFFFFFLL;
  if ( !a2 || !a4 || !a6 || a6 > 0x400 || a4 > 0x100000 )
    return 0xFFFFFFFFLL;
  dest = calloc(1uLL, a4 + 4);
  if ( !dest )
    return 0xFFFFFFFFLL;
  v20 = (v9 + 31) >> 5;
  v17 = (v9 + v20 - 1) / v20;
  memcpy(dest, a3, a4);
  v21 = sha512_init();
  sha512_update(v21, a1, a2);
  sha512_final(v26, v21);
  v13 = 1;
  while ( v9 )
  {
    *((_BYTE *)dest + a4) = HIBYTE(v13);
    *((_BYTE *)dest + a4 + 1) = BYTE2(v13);
    *((_BYTE *)dest + a4 + 2) = BYTE1(v13);
    *((_BYTE *)dest + a4 + 3) = v13;
    v22 = sha512_init();
    sha512_update(v22, (__int64)dest, a4 + 4);
    sha512_final(v27, v22);
    bcrypt_hash((__int64)v26, (__int64)v27, (__int64)v25);
    v24[0] = v25[0];
    v24[1] = v25[1];
    v24[2] = v25[2];
    v24[3] = v25[3];
    for ( i = 1LL; a7 > i; ++i )
    {
      v23 = sha512_init();
      sha512_update(v23, (__int64)v25, 32LL);
      sha512_final(v27, v23);
      bcrypt_hash((__int64)v26, (__int64)v27, (__int64)v25);
      for ( j = 0LL; j <= 0x1F; ++j )
        *((_BYTE *)v24 + j) ^= *((_BYTE *)v25 + j);
    }
    v8 = v17;
    if ( v9 <= v17 )
      v8 = v9;
    v17 = v8;
    for ( k = 0LL; k < v8 && (unsigned int)(v13 - 1) + v20 * k < a6; ++k )
      *(_BYTE *)((unsigned int)(v13 - 1) + v20 * k + a5) = *((_BYTE *)v24 + k);
    v9 -= k;
    ++v13;
  }
  explicit_bzero(v24, 0x20uLL);
  free(dest);
  return 0LL;
}
// 38614: using guessed type __int64 sha512_init(void);

//----- (000000000003282B) ----------------------------------------------------
int *__fastcall Blowfish_encipher(_DWORD *a1, int *a2, int *a3)
{
  int *result; // rax
  int v4; // [rsp+20h] [rbp-18h]
  int v5; // [rsp+20h] [rbp-18h]
  int v6; // [rsp+20h] [rbp-18h]
  int v7; // [rsp+20h] [rbp-18h]
  int v8; // [rsp+20h] [rbp-18h]
  int v9; // [rsp+20h] [rbp-18h]
  int v10; // [rsp+20h] [rbp-18h]
  int v11; // [rsp+20h] [rbp-18h]
  int v12; // [rsp+20h] [rbp-18h]
  int v13; // [rsp+24h] [rbp-14h]
  int v14; // [rsp+24h] [rbp-14h]
  int v15; // [rsp+24h] [rbp-14h]
  int v16; // [rsp+24h] [rbp-14h]
  int v17; // [rsp+24h] [rbp-14h]
  int v18; // [rsp+24h] [rbp-14h]
  int v19; // [rsp+24h] [rbp-14h]
  int v20; // [rsp+24h] [rbp-14h]

  v4 = a1[1024] ^ *a2;
  v13 = (a1[(unsigned __int8)v4 + 768] + (a1[BYTE1(v4) + 512] ^ (a1[BYTE2(v4) + 256] + a1[HIBYTE(v4)]))) ^ a1[1025] ^ *a3;
  v5 = (a1[(unsigned __int8)v13 + 768] + (a1[BYTE1(v13) + 512] ^ (a1[BYTE2(v13) + 256] + a1[HIBYTE(v13)]))) ^ a1[1026] ^ v4;
  v14 = (a1[(unsigned __int8)v5 + 768] + (a1[BYTE1(v5) + 512] ^ (a1[BYTE2(v5) + 256] + a1[HIBYTE(v5)]))) ^ a1[1027] ^ v13;
  v6 = (a1[(unsigned __int8)v14 + 768] + (a1[BYTE1(v14) + 512] ^ (a1[BYTE2(v14) + 256] + a1[HIBYTE(v14)]))) ^ a1[1028] ^ v5;
  v15 = (a1[(unsigned __int8)v6 + 768] + (a1[BYTE1(v6) + 512] ^ (a1[BYTE2(v6) + 256] + a1[HIBYTE(v6)]))) ^ a1[1029] ^ v14;
  v7 = (a1[(unsigned __int8)v15 + 768] + (a1[BYTE1(v15) + 512] ^ (a1[BYTE2(v15) + 256] + a1[HIBYTE(v15)]))) ^ a1[1030] ^ v6;
  v16 = (a1[(unsigned __int8)v7 + 768] + (a1[BYTE1(v7) + 512] ^ (a1[BYTE2(v7) + 256] + a1[HIBYTE(v7)]))) ^ a1[1031] ^ v15;
  v8 = (a1[(unsigned __int8)v16 + 768] + (a1[BYTE1(v16) + 512] ^ (a1[BYTE2(v16) + 256] + a1[HIBYTE(v16)]))) ^ a1[1032] ^ v7;
  v17 = (a1[(unsigned __int8)v8 + 768] + (a1[BYTE1(v8) + 512] ^ (a1[BYTE2(v8) + 256] + a1[HIBYTE(v8)]))) ^ a1[1033] ^ v16;
  v9 = (a1[(unsigned __int8)v17 + 768] + (a1[BYTE1(v17) + 512] ^ (a1[BYTE2(v17) + 256] + a1[HIBYTE(v17)]))) ^ a1[1034] ^ v8;
  v18 = (a1[(unsigned __int8)v9 + 768] + (a1[BYTE1(v9) + 512] ^ (a1[BYTE2(v9) + 256] + a1[HIBYTE(v9)]))) ^ a1[1035] ^ v17;
  v10 = (a1[(unsigned __int8)v18 + 768] + (a1[BYTE1(v18) + 512] ^ (a1[BYTE2(v18) + 256] + a1[HIBYTE(v18)]))) ^ a1[1036] ^ v9;
  v19 = (a1[(unsigned __int8)v10 + 768] + (a1[BYTE1(v10) + 512] ^ (a1[BYTE2(v10) + 256] + a1[HIBYTE(v10)]))) ^ a1[1037] ^ v18;
  v11 = (a1[(unsigned __int8)v19 + 768] + (a1[BYTE1(v19) + 512] ^ (a1[BYTE2(v19) + 256] + a1[HIBYTE(v19)]))) ^ a1[1038] ^ v10;
  v20 = (a1[(unsigned __int8)v11 + 768] + (a1[BYTE1(v11) + 512] ^ (a1[BYTE2(v11) + 256] + a1[HIBYTE(v11)]))) ^ a1[1039] ^ v19;
  v12 = (a1[(unsigned __int8)v20 + 768] + (a1[BYTE1(v20) + 512] ^ (a1[BYTE2(v20) + 256] + a1[HIBYTE(v20)]))) ^ a1[1040] ^ v11;
  *a2 = v20 ^ a1[1041];
  result = a3;
  *a3 = v12;
  return result;
}

//----- (000000000003319D) ----------------------------------------------------
int *__fastcall Blowfish_decipher(_DWORD *a1, int *a2, int *a3)
{
  int *result; // rax
  int v4; // [rsp+20h] [rbp-18h]
  int v5; // [rsp+20h] [rbp-18h]
  int v6; // [rsp+20h] [rbp-18h]
  int v7; // [rsp+20h] [rbp-18h]
  int v8; // [rsp+20h] [rbp-18h]
  int v9; // [rsp+20h] [rbp-18h]
  int v10; // [rsp+20h] [rbp-18h]
  int v11; // [rsp+20h] [rbp-18h]
  int v12; // [rsp+20h] [rbp-18h]
  int v13; // [rsp+24h] [rbp-14h]
  int v14; // [rsp+24h] [rbp-14h]
  int v15; // [rsp+24h] [rbp-14h]
  int v16; // [rsp+24h] [rbp-14h]
  int v17; // [rsp+24h] [rbp-14h]
  int v18; // [rsp+24h] [rbp-14h]
  int v19; // [rsp+24h] [rbp-14h]
  int v20; // [rsp+24h] [rbp-14h]

  v4 = a1[1041] ^ *a2;
  v13 = (a1[(unsigned __int8)v4 + 768] + (a1[BYTE1(v4) + 512] ^ (a1[BYTE2(v4) + 256] + a1[HIBYTE(v4)]))) ^ a1[1040] ^ *a3;
  v5 = (a1[(unsigned __int8)v13 + 768] + (a1[BYTE1(v13) + 512] ^ (a1[BYTE2(v13) + 256] + a1[HIBYTE(v13)]))) ^ a1[1039] ^ v4;
  v14 = (a1[(unsigned __int8)v5 + 768] + (a1[BYTE1(v5) + 512] ^ (a1[BYTE2(v5) + 256] + a1[HIBYTE(v5)]))) ^ a1[1038] ^ v13;
  v6 = (a1[(unsigned __int8)v14 + 768] + (a1[BYTE1(v14) + 512] ^ (a1[BYTE2(v14) + 256] + a1[HIBYTE(v14)]))) ^ a1[1037] ^ v5;
  v15 = (a1[(unsigned __int8)v6 + 768] + (a1[BYTE1(v6) + 512] ^ (a1[BYTE2(v6) + 256] + a1[HIBYTE(v6)]))) ^ a1[1036] ^ v14;
  v7 = (a1[(unsigned __int8)v15 + 768] + (a1[BYTE1(v15) + 512] ^ (a1[BYTE2(v15) + 256] + a1[HIBYTE(v15)]))) ^ a1[1035] ^ v6;
  v16 = (a1[(unsigned __int8)v7 + 768] + (a1[BYTE1(v7) + 512] ^ (a1[BYTE2(v7) + 256] + a1[HIBYTE(v7)]))) ^ a1[1034] ^ v15;
  v8 = (a1[(unsigned __int8)v16 + 768] + (a1[BYTE1(v16) + 512] ^ (a1[BYTE2(v16) + 256] + a1[HIBYTE(v16)]))) ^ a1[1033] ^ v7;
  v17 = (a1[(unsigned __int8)v8 + 768] + (a1[BYTE1(v8) + 512] ^ (a1[BYTE2(v8) + 256] + a1[HIBYTE(v8)]))) ^ a1[1032] ^ v16;
  v9 = (a1[(unsigned __int8)v17 + 768] + (a1[BYTE1(v17) + 512] ^ (a1[BYTE2(v17) + 256] + a1[HIBYTE(v17)]))) ^ a1[1031] ^ v8;
  v18 = (a1[(unsigned __int8)v9 + 768] + (a1[BYTE1(v9) + 512] ^ (a1[BYTE2(v9) + 256] + a1[HIBYTE(v9)]))) ^ a1[1030] ^ v17;
  v10 = (a1[(unsigned __int8)v18 + 768] + (a1[BYTE1(v18) + 512] ^ (a1[BYTE2(v18) + 256] + a1[HIBYTE(v18)]))) ^ a1[1029] ^ v9;
  v19 = (a1[(unsigned __int8)v10 + 768] + (a1[BYTE1(v10) + 512] ^ (a1[BYTE2(v10) + 256] + a1[HIBYTE(v10)]))) ^ a1[1028] ^ v18;
  v11 = (a1[(unsigned __int8)v19 + 768] + (a1[BYTE1(v19) + 512] ^ (a1[BYTE2(v19) + 256] + a1[HIBYTE(v19)]))) ^ a1[1027] ^ v10;
  v20 = (a1[(unsigned __int8)v11 + 768] + (a1[BYTE1(v11) + 512] ^ (a1[BYTE2(v11) + 256] + a1[HIBYTE(v11)]))) ^ a1[1026] ^ v19;
  v12 = (a1[(unsigned __int8)v20 + 768] + (a1[BYTE1(v20) + 512] ^ (a1[BYTE2(v20) + 256] + a1[HIBYTE(v20)]))) ^ a1[1025] ^ v11;
  *a2 = v20 ^ a1[1024];
  result = a3;
  *a3 = v12;
  return result;
}

//----- (0000000000033B0F) ----------------------------------------------------
char *__fastcall Blowfish_initstate(char *a1)
{
  _BYTE *v2; // rdi
  signed __int64 v3; // rdx
  char *result; // rax

  *(_QWORD *)a1 = initstate_2080[0];
  *((_QWORD *)a1 + 520) = initstate_2080[520];
  v2 = (_BYTE *)((unsigned __int64)(a1 + 8) & 0xFFFFFFFFFFFFFFF8LL);
  v3 = a1 - v2;
  result = (char *)initstate_2080 - v3;
  qmemcpy(v2, (char *)initstate_2080 - v3, 8LL * ((((_DWORD)v3 + 4168) & 0xFFFFFFF8) >> 3));
  return result;
}
// 57980: using guessed type _QWORD initstate_2080[524];

//----- (0000000000033B70) ----------------------------------------------------
__int64 __fastcall Blowfish_stream2word(__int64 a1, unsigned __int16 a2, _WORD *a3)
{
  unsigned __int8 i; // [rsp+21h] [rbp-7h]
  _BYTE v5[6]; // [rsp+22h] [rbp-6h]

  *(_WORD *)&v5[4] = 0;
  *(_DWORD *)v5 = (unsigned __int16)*a3;
  for ( i = 0; i <= 3u; ++i )
  {
    if ( *(_WORD *)v5 >= a2 )
      *(_WORD *)v5 = 0;
    *(_DWORD *)&v5[2] = (*(_DWORD *)&v5[2] << 8) | *(unsigned __int8 *)(*(unsigned __int16 *)v5 + a1);
    ++*(_WORD *)v5;
  }
  *a3 = *(_WORD *)v5;
  return *(unsigned int *)&v5[2];
}

//----- (0000000000033BF3) ----------------------------------------------------
unsigned __int64 __fastcall Blowfish_expand0state(_DWORD *a1, __int64 a2, unsigned int a3)
{
  unsigned __int64 result; // rax
  unsigned __int16 v4; // [rsp+Ch] [rbp-34h]
  __int16 v5; // [rsp+2Eh] [rbp-12h] BYREF
  unsigned __int16 i; // [rsp+30h] [rbp-10h]
  unsigned __int16 j; // [rsp+32h] [rbp-Eh]
  int v8; // [rsp+34h] [rbp-Ch] BYREF
  int v9; // [rsp+38h] [rbp-8h] BYREF
  int v10; // [rsp+3Ch] [rbp-4h]

  result = a3;
  v4 = a3;
  v5 = 0;
  for ( i = 0; i <= 0x11u; ++i )
  {
    v10 = Blowfish_stream2word(a2, v4, &v5);
    a1[i + 1024] ^= v10;
    result = (unsigned int)i + 1;
  }
  v5 = 0;
  v8 = 0;
  v9 = 0;
  for ( i = 0; i <= 0x11u; i += 2 )
  {
    Blowfish_encipher(a1, &v8, &v9);
    a1[i + 1024] = v8;
    result = (unsigned __int64)a1;
    a1[i + 1025] = v9;
  }
  for ( i = 0; i <= 3u; ++i )
  {
    for ( j = 0; j <= 0xFFu; j += 2 )
    {
      Blowfish_encipher(a1, &v8, &v9);
      a1[256 * (unsigned __int64)i + j] = v8;
      a1[256 * (unsigned __int64)i + 1 + j] = v9;
    }
    result = (unsigned int)i + 1;
  }
  return result;
}

//----- (0000000000033D6D) ----------------------------------------------------
unsigned __int64 __fastcall Blowfish_expandstate(
        _DWORD *a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        unsigned __int16 a5)
{
  unsigned __int64 result; // rax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  unsigned __int16 v12; // [rsp+Ch] [rbp-34h]
  __int16 v13; // [rsp+2Eh] [rbp-12h] BYREF
  unsigned __int16 i; // [rsp+30h] [rbp-10h]
  unsigned __int16 j; // [rsp+32h] [rbp-Eh]
  int v16; // [rsp+34h] [rbp-Ch] BYREF
  int v17; // [rsp+38h] [rbp-8h] BYREF
  int v18; // [rsp+3Ch] [rbp-4h]

  result = a3;
  v12 = a3;
  v13 = 0;
  for ( i = 0; i <= 0x11u; ++i )
  {
    v18 = Blowfish_stream2word(a4, a5, &v13);
    a1[i + 1024] ^= v18;
    result = (unsigned int)i + 1;
  }
  v13 = 0;
  v16 = 0;
  v17 = 0;
  for ( i = 0; i <= 0x11u; i += 2 )
  {
    v6 = Blowfish_stream2word(a2, v12, &v13);
    v16 ^= v6;
    v7 = Blowfish_stream2word(a2, v12, &v13);
    v17 ^= v7;
    Blowfish_encipher(a1, &v16, &v17);
    a1[i + 1024] = v16;
    result = (unsigned __int64)a1;
    a1[i + 1025] = v17;
  }
  for ( i = 0; i <= 3u; ++i )
  {
    for ( j = 0; j <= 0xFFu; j += 2 )
    {
      v8 = Blowfish_stream2word(a2, v12, &v13);
      v16 ^= v8;
      v9 = Blowfish_stream2word(a2, v12, &v13);
      v17 ^= v9;
      Blowfish_encipher(a1, &v16, &v17);
      a1[256 * (unsigned __int64)i + j] = v16;
      a1[256 * (unsigned __int64)i + 1 + j] = v17;
    }
    result = (unsigned int)i + 1;
  }
  return result;
}

//----- (0000000000033F87) ----------------------------------------------------
unsigned __int64 __fastcall ssh_blf_key(char *a1, __int64 a2, unsigned __int16 a3)
{
  Blowfish_initstate(a1);
  return Blowfish_expand0state(a1, a2, a3);
}

//----- (0000000000033FC3) ----------------------------------------------------
__int64 __fastcall ssh_blf_enc(_DWORD *a1, int *a2, unsigned __int16 a3)
{
  __int64 result; // rax
  unsigned __int16 i; // [rsp+26h] [rbp-Ah]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    Blowfish_encipher(a1, a2, a2 + 1);
    a2 += 2;
  }
  return result;
}

//----- (0000000000034021) ----------------------------------------------------
__int64 __fastcall ssh_blf_dec(_DWORD *a1, int *a2, unsigned __int16 a3)
{
  __int64 result; // rax
  unsigned __int16 i; // [rsp+26h] [rbp-Ah]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    Blowfish_decipher(a1, a2, a2 + 1);
    a2 += 2;
  }
  return result;
}

//----- (000000000003407F) ----------------------------------------------------
__int64 __fastcall ssh_blf_ecb_encrypt(_DWORD *a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax
  unsigned int v6; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int v7; // [rsp+28h] [rbp-8h] BYREF
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  for ( i = 0; ; i += 8 )
  {
    result = i;
    if ( i >= a3 )
      break;
    v6 = _byteswap_ulong(*(_DWORD *)a2);
    v7 = _byteswap_ulong(*(_DWORD *)(a2 + 4));
    Blowfish_encipher(a1, (int *)&v6, (int *)&v7);
    *(_BYTE *)a2 = HIBYTE(v6);
    *(_BYTE *)(a2 + 1) = BYTE2(v6);
    *(_BYTE *)(a2 + 2) = BYTE1(v6);
    *(_BYTE *)(a2 + 3) = v6;
    *(_BYTE *)(a2 + 4) = HIBYTE(v7);
    *(_BYTE *)(a2 + 5) = BYTE2(v7);
    *(_BYTE *)(a2 + 6) = BYTE1(v7);
    *(_BYTE *)(a2 + 7) = v7;
    a2 += 8LL;
  }
  return result;
}

//----- (00000000000341D9) ----------------------------------------------------
__int64 __fastcall ssh_blf_ecb_decrypt(_DWORD *a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax
  unsigned int v6; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int v7; // [rsp+28h] [rbp-8h] BYREF
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  for ( i = 0; ; i += 8 )
  {
    result = i;
    if ( i >= a3 )
      break;
    v6 = _byteswap_ulong(*(_DWORD *)a2);
    v7 = _byteswap_ulong(*(_DWORD *)(a2 + 4));
    Blowfish_decipher(a1, (int *)&v6, (int *)&v7);
    *(_BYTE *)a2 = HIBYTE(v6);
    *(_BYTE *)(a2 + 1) = BYTE2(v6);
    *(_BYTE *)(a2 + 2) = BYTE1(v6);
    *(_BYTE *)(a2 + 3) = v6;
    *(_BYTE *)(a2 + 4) = HIBYTE(v7);
    *(_BYTE *)(a2 + 5) = BYTE2(v7);
    *(_BYTE *)(a2 + 6) = BYTE1(v7);
    *(_BYTE *)(a2 + 7) = v7;
    a2 += 8LL;
  }
  return result;
}

//----- (0000000000034333) ----------------------------------------------------
__int64 __fastcall ssh_blf_cbc_encrypt(_DWORD *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 result; // rax
  unsigned int v8; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v9; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int j; // [rsp+2Ch] [rbp-4h]

  for ( i = 0; ; i += 8 )
  {
    result = i;
    if ( i >= a4 )
      break;
    for ( j = 0; j <= 7; ++j )
      *(_BYTE *)(j + a3) ^= *(_BYTE *)(j + a2);
    v8 = _byteswap_ulong(*(_DWORD *)a3);
    v9 = _byteswap_ulong(*(_DWORD *)(a3 + 4));
    Blowfish_encipher(a1, (int *)&v8, (int *)&v9);
    *(_BYTE *)a3 = HIBYTE(v8);
    *(_BYTE *)(a3 + 1) = BYTE2(v8);
    *(_BYTE *)(a3 + 2) = BYTE1(v8);
    *(_BYTE *)(a3 + 3) = v8;
    *(_BYTE *)(a3 + 4) = HIBYTE(v9);
    *(_BYTE *)(a3 + 5) = BYTE2(v9);
    *(_BYTE *)(a3 + 6) = BYTE1(v9);
    *(_BYTE *)(a3 + 7) = v9;
    a2 = a3;
    a3 += 8LL;
  }
  return result;
}

//----- (00000000000344D4) ----------------------------------------------------
_BYTE *__fastcall ssh_blf_cbc_decrypt(_DWORD *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  _BYTE *result; // rax
  __int64 v5; // [rsp+8h] [rbp-38h]
  unsigned int v6; // [rsp+28h] [rbp-18h] BYREF
  unsigned int v7; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int i; // [rsp+30h] [rbp-10h]
  unsigned int j; // [rsp+34h] [rbp-Ch]
  __int64 v10; // [rsp+38h] [rbp-8h]

  v10 = a4 - 16LL + a3;
  v5 = a4 - 8LL + a3;
  for ( i = a4 - 8; i > 7; i -= 8 )
  {
    v6 = _byteswap_ulong(*(_DWORD *)v5);
    v7 = _byteswap_ulong(*(_DWORD *)(v5 + 4));
    Blowfish_decipher(a1, (int *)&v6, (int *)&v7);
    *(_BYTE *)v5 = HIBYTE(v6);
    *(_BYTE *)(v5 + 1) = BYTE2(v6);
    *(_BYTE *)(v5 + 2) = BYTE1(v6);
    *(_BYTE *)(v5 + 3) = v6;
    *(_BYTE *)(v5 + 4) = HIBYTE(v7);
    *(_BYTE *)(v5 + 5) = BYTE2(v7);
    *(_BYTE *)(v5 + 6) = BYTE1(v7);
    *(_BYTE *)(v5 + 7) = v7;
    for ( j = 0; j <= 7; ++j )
      *(_BYTE *)(j + v5) ^= *(_BYTE *)(j + v10);
    v10 -= 8LL;
    v5 -= 8LL;
  }
  v6 = _byteswap_ulong(*(_DWORD *)v5);
  v7 = _byteswap_ulong(*(_DWORD *)(v5 + 4));
  Blowfish_decipher(a1, (int *)&v6, (int *)&v7);
  *(_BYTE *)v5 = HIBYTE(v6);
  *(_BYTE *)(v5 + 1) = BYTE2(v6);
  *(_BYTE *)(v5 + 2) = BYTE1(v6);
  *(_BYTE *)(v5 + 3) = v6;
  *(_BYTE *)(v5 + 4) = HIBYTE(v7);
  *(_BYTE *)(v5 + 5) = BYTE2(v7);
  *(_BYTE *)(v5 + 6) = BYTE1(v7);
  result = (_BYTE *)(v5 + 7);
  *(_BYTE *)(v5 + 7) = v7;
  for ( j = 0; j <= 7; ++j )
  {
    result = (_BYTE *)(j + v5);
    *result ^= *(_BYTE *)(j + a2);
  }
  return result;
}

//----- (00000000000347ED) ----------------------------------------------------
__int64 __fastcall crypto_verify_32(_BYTE *a1, _BYTE *a2)
{
  int v3; // [rsp+1Ch] [rbp-4h]

  v3 = (unsigned __int8)(a1[17] ^ a2[17]) | (unsigned __int8)(a1[16] ^ a2[16]) | (unsigned __int8)(a1[15] ^ a2[15]) | (unsigned __int8)(a1[14] ^ a2[14]) | (unsigned __int8)(a1[13] ^ a2[13]) | (unsigned __int8)(a1[12] ^ a2[12]) | (unsigned __int8)(a1[11] ^ a2[11]) | (unsigned __int8)(a1[10] ^ a2[10]) | (unsigned __int8)(a1[9] ^ a2[9]) | (unsigned __int8)(a1[8] ^ a2[8]) | (unsigned __int8)(a1[7] ^ a2[7]) | (unsigned __int8)(a1[6] ^ a2[6]) | (unsigned __int8)(a1[5] ^ a2[5]) | (unsigned __int8)(a1[4] ^ a2[4]) | (unsigned __int8)(a1[3] ^ a2[3]) | (unsigned __int8)(a1[2] ^ a2[2]) | (unsigned __int8)(a1[1] ^ a2[1]) | (unsigned __int8)(*a1 ^ *a2);
  return (((((unsigned __int8)(a1[31] ^ a2[31]) | (unsigned __int8)(a1[30] ^ a2[30]) | (unsigned __int8)(a1[29] ^ a2[29]) | (unsigned __int8)(a1[28] ^ a2[28]) | (unsigned __int8)(a1[27] ^ a2[27]) | (unsigned __int8)(a1[26] ^ a2[26]) | (unsigned __int8)(a1[25] ^ a2[25]) | (unsigned __int8)(a1[24] ^ a2[24]) | (unsigned __int8)(a1[23] ^ a2[23]) | (unsigned __int8)(a1[22] ^ a2[22]) | (unsigned __int8)(a1[21] ^ a2[21]) | (unsigned __int8)(a1[20] ^ a2[20]) | (unsigned __int8)(a1[19] ^ a2[19]) | (unsigned __int8)(a1[18] ^ a2[18]) | (unsigned int)v3)
          - 1) >> 8) & 1)
       - 1;
}

//----- (0000000000034BC9) ----------------------------------------------------
__int64 __fastcall get_hram(void *a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5)
{
  unsigned __int64 i; // [rsp+30h] [rbp-10h]
  unsigned __int64 j; // [rsp+30h] [rbp-10h]
  unsigned __int64 k; // [rsp+30h] [rbp-10h]
  __int64 v11; // [rsp+38h] [rbp-8h]

  for ( i = 0LL; i <= 0x1F; ++i )
    *(_BYTE *)(i + a4) = *(_BYTE *)(a2 + i);
  for ( j = 32LL; j <= 0x3F; ++j )
    *(_BYTE *)(j + a4) = *(_BYTE *)(j - 32 + a3);
  for ( k = 64LL; k < a5; ++k )
    *(_BYTE *)(k + a4) = *(_BYTE *)(a2 + k);
  v11 = sha512_init();
  sha512_update(v11, a4, a5);
  return sha512_final(a1, v11);
}
// 38614: using guessed type __int64 sha512_init(void);

//----- (0000000000034CB5) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_keypair(__int64 a1, __int64 a2)
{
  int i; // [rsp+10h] [rbp-2E0h]
  __int64 v4; // [rsp+18h] [rbp-2D8h]
  char v5[128]; // [rsp+20h] [rbp-2D0h] BYREF
  char v6[512]; // [rsp+A0h] [rbp-250h] BYREF
  char v7[31]; // [rsp+2A0h] [rbp-50h] BYREF
  char v8; // [rsp+2BFh] [rbp-31h]
  unsigned __int64 v9; // [rsp+2E8h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  if ( !(unsigned int)ssh_get_random(a2, 32) )
    return 0xFFFFFFFFLL;
  v4 = sha512_init();
  sha512_update(v4, a2, 32LL);
  sha512_final(v7, v4);
  v7[0] &= 0xF8u;
  v8 &= ~0x80u;
  v8 |= 0x40u;
  crypto_sign_ed25519_ref_sc25519_from32bytes((__int64)v5, (__int64)v7);
  crypto_sign_ed25519_ref_scalarmult_base((__int64)v6, (__int64)v5);
  crypto_sign_ed25519_ref_pack(a1, (__int64)v6);
  for ( i = 0; i <= 31; ++i )
    *(_BYTE *)(a2 + i + 32) = *(_BYTE *)(i + a1);
  return 0LL;
}
// 38614: using guessed type __int64 sha512_init(void);

//----- (0000000000034E1A) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519(__int64 a1, _QWORD *a2, __int64 a3, unsigned __int64 a4, __int64 a5)
{
  unsigned __int64 i; // [rsp+30h] [rbp-4A0h]
  unsigned __int64 j; // [rsp+30h] [rbp-4A0h]
  unsigned __int64 k; // [rsp+30h] [rbp-4A0h]
  unsigned __int64 m; // [rsp+30h] [rbp-4A0h]
  __int64 v13; // [rsp+38h] [rbp-498h]
  __int64 v14; // [rsp+38h] [rbp-498h]
  char v15[128]; // [rsp+40h] [rbp-490h] BYREF
  char v16[128]; // [rsp+C0h] [rbp-410h] BYREF
  char v17[128]; // [rsp+140h] [rbp-390h] BYREF
  char v18[512]; // [rsp+1C0h] [rbp-310h] BYREF
  char v19[32]; // [rsp+3C0h] [rbp-110h] BYREF
  char v20[32]; // [rsp+3E0h] [rbp-F0h] BYREF
  char v21[31]; // [rsp+400h] [rbp-D0h] BYREF
  char v22; // [rsp+41Fh] [rbp-B1h]
  char v23[64]; // [rsp+440h] [rbp-90h] BYREF
  char v24[72]; // [rsp+480h] [rbp-50h] BYREF
  unsigned __int64 v25; // [rsp+4C8h] [rbp-8h]

  v25 = __readfsqword(0x28u);
  v13 = sha512_init();
  sha512_update(v13, a5, 32LL);
  sha512_final(v21, v13);
  v21[0] &= 0xF8u;
  v22 &= ~0x80u;
  v22 |= 0x40u;
  *a2 = a4 + 64;
  for ( i = 0LL; i < a4; ++i )
    *(_BYTE *)(a1 + i + 64) = *(_BYTE *)(a3 + i);
  for ( j = 0LL; j <= 0x1F; ++j )
    *(_BYTE *)(a1 + j + 32) = v21[j + 32];
  v14 = sha512_init();
  sha512_update(v14, a1 + 32, a4 + 32);
  sha512_final(v23, v14);
  crypto_sign_ed25519_ref_sc25519_from64bytes((__int64)v15, (__int64)v23);
  crypto_sign_ed25519_ref_scalarmult_base((__int64)v18, (__int64)v15);
  crypto_sign_ed25519_ref_pack((__int64)v19, (__int64)v18);
  for ( k = 0LL; k <= 0x1F; ++k )
    *(_BYTE *)(k + a1) = v19[k];
  get_hram(v24, a1, a5 + 32, a1, a4 + 64);
  crypto_sign_ed25519_ref_sc25519_from64bytes((__int64)v16, (__int64)v24);
  crypto_sign_ed25519_ref_sc25519_from32bytes((__int64)v17, (__int64)v21);
  crypto_sign_ed25519_ref_sc25519_mul((__int64)v16, (__int64)v16, (__int64)v17);
  crypto_sign_ed25519_ref_sc25519_add((__int64)v16, (__int64)v16, (__int64)v15);
  crypto_sign_ed25519_ref_sc25519_to32bytes((__int64)v20, (__int64)v16);
  for ( m = 0LL; m <= 0x1F; ++m )
    *(_BYTE *)(a1 + m + 32) = v20[m];
  return 0LL;
}
// 38614: using guessed type __int64 sha512_init(void);
// 34E1A: using guessed type char var_110[32];
// 34E1A: using guessed type char var_F0[32];

//----- (000000000003517C) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_open(__int64 a1, _QWORD *a2, _BYTE *a3, unsigned __int64 a4, __int64 a5)
{
  unsigned int i; // [rsp+38h] [rbp-578h]
  unsigned int j; // [rsp+38h] [rbp-578h]
  unsigned int v11; // [rsp+3Ch] [rbp-574h]
  char v12[128]; // [rsp+40h] [rbp-570h] BYREF
  char v13[128]; // [rsp+C0h] [rbp-4F0h] BYREF
  __int64 v14[64]; // [rsp+140h] [rbp-470h] BYREF
  char v15[512]; // [rsp+340h] [rbp-270h] BYREF
  char v16[32]; // [rsp+540h] [rbp-70h] BYREF
  char v17[72]; // [rsp+560h] [rbp-50h] BYREF
  unsigned __int64 v18; // [rsp+5A8h] [rbp-8h]

  v18 = __readfsqword(0x28u);
  *a2 = -1LL;
  if ( a4 <= 0x3F )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)crypto_sign_ed25519_ref_unpackneg_vartime(v14, a5) )
    return 0xFFFFFFFFLL;
  get_hram(v17, (__int64)a3, a5, a1, a4);
  crypto_sign_ed25519_ref_sc25519_from64bytes((__int64)v12, (__int64)v17);
  crypto_sign_ed25519_ref_sc25519_from32bytes((__int64)v13, (__int64)(a3 + 32));
  crypto_sign_ed25519_ref_double_scalarmult_vartime(
    (__int64)v15,
    v14,
    (__int64)v12,
    &crypto_sign_ed25519_ref_ge25519_base,
    (__int64)v13);
  crypto_sign_ed25519_ref_pack((__int64)v16, (__int64)v15);
  v11 = crypto_verify_32(a3, v16);
  if ( v11 )
  {
    for ( i = 0; i < a4 - 64; ++i )
      *(_BYTE *)(a1 + i) = a3[i + 64];
    *a2 = a4 - 64;
  }
  else
  {
    for ( j = 0; j < a4 - 64; ++j )
      *(_BYTE *)(j + a1) = 0;
  }
  return v11;
}
// 3517C: using guessed type __int64 var_470[64];

//----- (000000000003538B) ----------------------------------------------------
void __fastcall p1p1_to_p2(_DWORD *a1, __int64 a2)
{
  crypto_sign_ed25519_ref_fe25519_mul(a1, a2, a2 + 384);
  crypto_sign_ed25519_ref_fe25519_mul(a1 + 32, a2 + 256, a2 + 128);
  crypto_sign_ed25519_ref_fe25519_mul(a1 + 64, a2 + 128, a2 + 384);
}

//----- (0000000000035410) ----------------------------------------------------
void __fastcall p1p1_to_p3(_DWORD *a1, __int64 a2)
{
  p1p1_to_p2(a1, a2);
  crypto_sign_ed25519_ref_fe25519_mul(a1 + 96, a2, a2 + 256);
}

//----- (000000000003545B) ----------------------------------------------------
void __fastcall ge25519_mixadd2(_DWORD *a1, __int64 a2)
{
  _DWORD v4[32]; // [rsp+10h] [rbp-580h] BYREF
  _DWORD v5[32]; // [rsp+90h] [rbp-500h] BYREF
  _DWORD v6[32]; // [rsp+110h] [rbp-480h] BYREF
  _DWORD v7[32]; // [rsp+190h] [rbp-400h] BYREF
  _DWORD v8[32]; // [rsp+210h] [rbp-380h] BYREF
  _DWORD v9[32]; // [rsp+290h] [rbp-300h] BYREF
  _DWORD v10[32]; // [rsp+310h] [rbp-280h] BYREF
  _DWORD v11[32]; // [rsp+390h] [rbp-200h] BYREF
  _DWORD v12[32]; // [rsp+410h] [rbp-180h] BYREF
  _DWORD v13[32]; // [rsp+490h] [rbp-100h] BYREF
  _DWORD v14[32]; // [rsp+510h] [rbp-80h] BYREF

  crypto_sign_ed25519_ref_fe25519_mul(v14, a2, a2 + 128);
  crypto_sign_ed25519_ref_fe25519_sub(v4, a1 + 32, (__int64)a1);
  crypto_sign_ed25519_ref_fe25519_add(v5, (__int64)(a1 + 32), (__int64)a1);
  crypto_sign_ed25519_ref_fe25519_sub(v6, (_DWORD *)(a2 + 128), a2);
  crypto_sign_ed25519_ref_fe25519_add(v7, a2 + 128, a2);
  crypto_sign_ed25519_ref_fe25519_mul(v4, (__int64)v4, (__int64)v6);
  crypto_sign_ed25519_ref_fe25519_mul(v5, (__int64)v5, (__int64)v7);
  crypto_sign_ed25519_ref_fe25519_sub(v10, v5, (__int64)v4);
  crypto_sign_ed25519_ref_fe25519_add(v13, (__int64)v5, (__int64)v4);
  crypto_sign_ed25519_ref_fe25519_mul(v8, (__int64)(a1 + 96), (__int64)v14);
  crypto_sign_ed25519_ref_fe25519_mul(v8, (__int64)v8, (__int64)&ge25519_ec2d);
  crypto_sign_ed25519_ref_fe25519_add(v9, (__int64)(a1 + 64), (__int64)(a1 + 64));
  crypto_sign_ed25519_ref_fe25519_sub(v11, v9, (__int64)v8);
  crypto_sign_ed25519_ref_fe25519_add(v12, (__int64)v9, (__int64)v8);
  crypto_sign_ed25519_ref_fe25519_mul(a1, (__int64)v10, (__int64)v11);
  crypto_sign_ed25519_ref_fe25519_mul(a1 + 32, (__int64)v13, (__int64)v12);
  crypto_sign_ed25519_ref_fe25519_mul(a1 + 64, (__int64)v12, (__int64)v11);
  crypto_sign_ed25519_ref_fe25519_mul(a1 + 96, (__int64)v10, (__int64)v13);
}
// 3545B: using guessed type _DWORD var_80[32];
// 3545B: using guessed type _DWORD var_580[32];
// 3545B: using guessed type _DWORD var_500[32];
// 3545B: using guessed type _DWORD var_480[32];
// 3545B: using guessed type _DWORD var_400[32];
// 3545B: using guessed type _DWORD var_280[32];
// 3545B: using guessed type _DWORD var_100[32];
// 3545B: using guessed type _DWORD var_380[32];
// 3545B: using guessed type _DWORD var_300[32];
// 3545B: using guessed type _DWORD var_200[32];
// 3545B: using guessed type _DWORD var_180[32];

//----- (00000000000356FE) ----------------------------------------------------
void __fastcall add_p1p1(_DWORD *a1, __int64 a2, __int64 a3)
{
  _DWORD v4[32]; // [rsp+20h] [rbp-280h] BYREF
  _DWORD v5[32]; // [rsp+A0h] [rbp-200h] BYREF
  _DWORD v6[32]; // [rsp+120h] [rbp-180h] BYREF
  _DWORD v7[32]; // [rsp+1A0h] [rbp-100h] BYREF
  _DWORD v8[32]; // [rsp+220h] [rbp-80h] BYREF

  crypto_sign_ed25519_ref_fe25519_sub(v4, (_DWORD *)(a2 + 128), a2);
  crypto_sign_ed25519_ref_fe25519_sub(v8, (_DWORD *)(a3 + 128), a3);
  crypto_sign_ed25519_ref_fe25519_mul(v4, (__int64)v4, (__int64)v8);
  crypto_sign_ed25519_ref_fe25519_add(v5, a2, a2 + 128);
  crypto_sign_ed25519_ref_fe25519_add(v8, a3, a3 + 128);
  crypto_sign_ed25519_ref_fe25519_mul(v5, (__int64)v5, (__int64)v8);
  crypto_sign_ed25519_ref_fe25519_mul(v6, a2 + 384, a3 + 384);
  crypto_sign_ed25519_ref_fe25519_mul(v6, (__int64)v6, (__int64)&ge25519_ec2d);
  crypto_sign_ed25519_ref_fe25519_mul(v7, a2 + 256, a3 + 256);
  crypto_sign_ed25519_ref_fe25519_add(v7, (__int64)v7, (__int64)v7);
  crypto_sign_ed25519_ref_fe25519_sub(a1, v5, (__int64)v4);
  crypto_sign_ed25519_ref_fe25519_sub(a1 + 96, v7, (__int64)v6);
  crypto_sign_ed25519_ref_fe25519_add(a1 + 32, (__int64)v7, (__int64)v6);
  crypto_sign_ed25519_ref_fe25519_add(a1 + 64, (__int64)v5, (__int64)v4);
}
// 356FE: using guessed type _DWORD var_280[32];
// 356FE: using guessed type _DWORD var_80[32];
// 356FE: using guessed type _DWORD var_200[32];
// 356FE: using guessed type _DWORD var_180[32];
// 356FE: using guessed type _DWORD var_100[32];

//----- (0000000000035922) ----------------------------------------------------
void __fastcall dbl_p1p1(_DWORD *a1, __int64 a2)
{
  _DWORD v3[32]; // [rsp+10h] [rbp-200h] BYREF
  _DWORD v4[32]; // [rsp+90h] [rbp-180h] BYREF
  _DWORD v5[32]; // [rsp+110h] [rbp-100h] BYREF
  _DWORD v6[32]; // [rsp+190h] [rbp-80h] BYREF

  crypto_sign_ed25519_ref_fe25519_square(v3, a2);
  crypto_sign_ed25519_ref_fe25519_square(v4, a2 + 128);
  crypto_sign_ed25519_ref_fe25519_square(v5, a2 + 256);
  crypto_sign_ed25519_ref_fe25519_add(v5, (__int64)v5, (__int64)v5);
  crypto_sign_ed25519_ref_fe25519_neg(v6, (__int64)v3);
  crypto_sign_ed25519_ref_fe25519_add(a1, a2, a2 + 128);
  crypto_sign_ed25519_ref_fe25519_square(a1, (__int64)a1);
  crypto_sign_ed25519_ref_fe25519_sub(a1, a1, (__int64)v3);
  crypto_sign_ed25519_ref_fe25519_sub(a1, a1, (__int64)v4);
  crypto_sign_ed25519_ref_fe25519_add(a1 + 32, (__int64)v6, (__int64)v4);
  crypto_sign_ed25519_ref_fe25519_sub(a1 + 96, a1 + 32, (__int64)v5);
  crypto_sign_ed25519_ref_fe25519_sub(a1 + 64, v6, (__int64)v4);
}
// 35922: using guessed type _DWORD var_200[32];
// 35922: using guessed type _DWORD var_180[32];
// 35922: using guessed type _DWORD var_100[32];
// 35922: using guessed type _DWORD var_80[32];

//----- (0000000000035AC3) ----------------------------------------------------
__int64 __fastcall cmov_aff(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  crypto_sign_ed25519_ref_fe25519_cmov(a1, a2, a3);
  return crypto_sign_ed25519_ref_fe25519_cmov(a1 + 128, a2 + 128, a3);
}

//----- (0000000000035B16) ----------------------------------------------------
__int64 __fastcall equal(char a1, char a2)
{
  return ((unsigned int)(unsigned __int8)(a2 ^ a1) - 1) >> 31;
}

//----- (0000000000035B50) ----------------------------------------------------
unsigned __int64 __fastcall negative(char a1)
{
  return (unsigned __int64)a1 >> 63;
}

//----- (0000000000035B6D) ----------------------------------------------------
__int64 __fastcall choose_t(_QWORD *a1, __int64 a2, char a3)
{
  char *v3; // rax
  char v4; // bl
  char v5; // al
  char v6; // bl
  char v7; // al
  char v8; // bl
  char v9; // al
  unsigned __int8 v10; // al
  unsigned __int8 v11; // al
  _DWORD v14[36]; // [rsp+20h] [rbp-90h] BYREF

  v3 = (char *)&ge25519_base_multiples_affine + 1280 * a2;
  *a1 = *(_QWORD *)v3;
  a1[31] = *((_QWORD *)v3 + 31);
  qmemcpy(
    (void *)((unsigned __int64)(a1 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    (const void *)(v3 - ((char *)a1 - ((unsigned __int64)(a1 + 1) & 0xFFFFFFFFFFFFFFF8LL))),
    8LL * ((((_DWORD)a1 - (((_DWORD)a1 + 8) & 0xFFFFFFF8) + 256) & 0xFFFFFFF8) >> 3));
  v4 = equal(a3, 1);
  v5 = equal(a3, -1);
  cmov_aff((__int64)a1, (__int64)&ge25519_base_multiples_affine + 1280 * a2 + 256, v4 | v5);
  v6 = equal(a3, 2);
  v7 = equal(a3, -2);
  cmov_aff((__int64)a1, (__int64)&ge25519_base_multiples_affine + 1280 * a2 + 512, v6 | v7);
  v8 = equal(a3, 3);
  v9 = equal(a3, -3);
  cmov_aff((__int64)a1, (__int64)&ge25519_base_multiples_affine + 1280 * a2 + 768, v8 | v9);
  v10 = equal(a3, -4);
  cmov_aff((__int64)a1, (__int64)&ge25519_base_multiples_affine + 1280 * a2 + 1024, v10);
  crypto_sign_ed25519_ref_fe25519_neg(v14, (__int64)a1);
  v11 = negative(a3);
  return crypto_sign_ed25519_ref_fe25519_cmov((__int64)a1, (__int64)v14, v11);
}
// 35B6D: using guessed type _DWORD var_90[36];

//----- (0000000000035DCB) ----------------------------------------------------
__int64 __fastcall setneutral(__int64 a1)
{
  crypto_sign_ed25519_ref_fe25519_setzero(a1);
  crypto_sign_ed25519_ref_fe25519_setone((_DWORD *)(a1 + 128));
  crypto_sign_ed25519_ref_fe25519_setone((_DWORD *)(a1 + 256));
  return crypto_sign_ed25519_ref_fe25519_setzero(a1 + 384);
}

//----- (0000000000035E1A) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_unpackneg_vartime(__int64 *a1, __int64 a2)
{
  unsigned __int8 v3; // [rsp+1Fh] [rbp-381h]
  _DWORD v4[32]; // [rsp+20h] [rbp-380h] BYREF
  __int64 v5[16]; // [rsp+A0h] [rbp-300h] BYREF
  __int64 v6[16]; // [rsp+120h] [rbp-280h] BYREF
  _DWORD v7[32]; // [rsp+1A0h] [rbp-200h] BYREF
  _DWORD v8[32]; // [rsp+220h] [rbp-180h] BYREF
  _DWORD v9[32]; // [rsp+2A0h] [rbp-100h] BYREF
  _DWORD v10[32]; // [rsp+320h] [rbp-80h] BYREF

  crypto_sign_ed25519_ref_fe25519_setone((_DWORD *)a1 + 64);
  v3 = *(_BYTE *)(a2 + 31) >> 7;
  crypto_sign_ed25519_ref_fe25519_unpack((__int64)(a1 + 16), a2);
  crypto_sign_ed25519_ref_fe25519_square(v6, (__int64)(a1 + 16));
  crypto_sign_ed25519_ref_fe25519_mul(v7, (__int64)v6, (__int64)&ge25519_ecd);
  crypto_sign_ed25519_ref_fe25519_sub(v6, v6, (__int64)(a1 + 32));
  crypto_sign_ed25519_ref_fe25519_add(v7, (__int64)(a1 + 32), (__int64)v7);
  crypto_sign_ed25519_ref_fe25519_square(v8, (__int64)v7);
  crypto_sign_ed25519_ref_fe25519_square(v9, (__int64)v8);
  crypto_sign_ed25519_ref_fe25519_mul(v10, (__int64)v9, (__int64)v8);
  crypto_sign_ed25519_ref_fe25519_mul(v4, (__int64)v10, (__int64)v6);
  crypto_sign_ed25519_ref_fe25519_mul(v4, (__int64)v4, (__int64)v7);
  crypto_sign_ed25519_ref_fe25519_pow2523(v4, (__int64)v4);
  crypto_sign_ed25519_ref_fe25519_mul(v4, (__int64)v4, (__int64)v6);
  crypto_sign_ed25519_ref_fe25519_mul(v4, (__int64)v4, (__int64)v7);
  crypto_sign_ed25519_ref_fe25519_mul(v4, (__int64)v4, (__int64)v7);
  crypto_sign_ed25519_ref_fe25519_mul(a1, (__int64)v4, (__int64)v7);
  crypto_sign_ed25519_ref_fe25519_square(v5, (__int64)a1);
  crypto_sign_ed25519_ref_fe25519_mul(v5, (__int64)v5, (__int64)v7);
  if ( !(unsigned int)crypto_sign_ed25519_ref_fe25519_iseq_vartime(v5, v6) )
    crypto_sign_ed25519_ref_fe25519_mul(a1, (__int64)a1, (__int64)&ge25519_sqrtm1);
  crypto_sign_ed25519_ref_fe25519_square(v5, (__int64)a1);
  crypto_sign_ed25519_ref_fe25519_mul(v5, (__int64)v5, (__int64)v7);
  if ( !(unsigned int)crypto_sign_ed25519_ref_fe25519_iseq_vartime(v5, v6) )
    return 0xFFFFFFFFLL;
  if ( (unsigned __int8)crypto_sign_ed25519_ref_fe25519_getparity(a1) != 1 - v3 )
    crypto_sign_ed25519_ref_fe25519_neg(a1, (__int64)a1);
  crypto_sign_ed25519_ref_fe25519_mul((_DWORD *)a1 + 96, (__int64)a1, (__int64)(a1 + 16));
  return 0LL;
}
// 35E1A: using guessed type __int64 var_280[16];
// 35E1A: using guessed type _DWORD var_200[32];
// 35E1A: using guessed type _DWORD var_180[32];
// 35E1A: using guessed type _DWORD var_100[32];
// 35E1A: using guessed type _DWORD var_80[32];
// 35E1A: using guessed type _DWORD var_380[32];
// 35E1A: using guessed type __int64 var_300[16];

//----- (0000000000036179) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_pack(__int64 a1, __int64 a2)
{
  char v2; // cl
  __int64 result; // rax
  __int64 v4[16]; // [rsp+10h] [rbp-180h] BYREF
  __int64 v5[16]; // [rsp+90h] [rbp-100h] BYREF
  _DWORD v6[32]; // [rsp+110h] [rbp-80h] BYREF

  crypto_sign_ed25519_ref_fe25519_invert(v6, a2 + 256);
  crypto_sign_ed25519_ref_fe25519_mul(v4, a2, (__int64)v6);
  crypto_sign_ed25519_ref_fe25519_mul(v5, a2 + 128, (__int64)v6);
  crypto_sign_ed25519_ref_fe25519_pack(a1, v5);
  v2 = (unsigned __int8)crypto_sign_ed25519_ref_fe25519_getparity(v4) << 7;
  result = a1 + 31;
  *(_BYTE *)(a1 + 31) ^= v2;
  return result;
}
// 36179: using guessed type _DWORD var_80[32];
// 36179: using guessed type __int64 var_180[16];
// 36179: using guessed type __int64 var_100[16];

//----- (0000000000036244) ----------------------------------------------------
_BOOL8 __fastcall crypto_sign_ed25519_ref_isneutral_vartime(__int64 *a1)
{
  _BOOL4 v2; // [rsp+1Ch] [rbp-4h]

  v2 = crypto_sign_ed25519_ref_fe25519_iszero(a1) != 0;
  if ( !(unsigned int)crypto_sign_ed25519_ref_fe25519_iseq_vartime(a1 + 16, a1 + 32) )
    return 0;
  return v2;
}

//----- (000000000003629C) ----------------------------------------------------
unsigned __int64 __fastcall crypto_sign_ed25519_ref_double_scalarmult_vartime(
        __int64 a1,
        const void *a2,
        __int64 a3,
        const void *a4,
        __int64 a5)
{
  char *v5; // rdx
  int i; // [rsp+3Ch] [rbp-2294h]
  _DWORD v11[128]; // [rsp+40h] [rbp-2290h] BYREF
  char v12[512]; // [rsp+240h] [rbp-2090h] BYREF
  char v13[512]; // [rsp+440h] [rbp-1E90h] BYREF
  _DWORD v14[128]; // [rsp+640h] [rbp-1C90h] BYREF
  _DWORD v15[128]; // [rsp+840h] [rbp-1A90h] BYREF
  char v16[512]; // [rsp+A40h] [rbp-1890h] BYREF
  _DWORD v17[128]; // [rsp+C40h] [rbp-1690h] BYREF
  int v18[128]; // [rsp+E40h] [rbp-1490h] BYREF
  int v19[128]; // [rsp+1040h] [rbp-1290h] BYREF
  _DWORD v20[128]; // [rsp+1240h] [rbp-1090h] BYREF
  int v21[128]; // [rsp+1440h] [rbp-E90h] BYREF
  int v22[128]; // [rsp+1640h] [rbp-C90h] BYREF
  int v23[128]; // [rsp+1840h] [rbp-A90h] BYREF
  _DWORD v24[128]; // [rsp+1A40h] [rbp-890h] BYREF
  int v25[128]; // [rsp+1C40h] [rbp-690h] BYREF
  int v26[128]; // [rsp+1E40h] [rbp-490h] BYREF
  int v27[128]; // [rsp+2040h] [rbp-290h] BYREF
  char v28[136]; // [rsp+2240h] [rbp-90h] BYREF
  unsigned __int64 v29; // [rsp+22C8h] [rbp-8h]

  v29 = __readfsqword(0x28u);
  setneutral((__int64)v12);
  qmemcpy(v13, a2, sizeof(v13));
  dbl_p1p1(v11, (__int64)a2);
  p1p1_to_p3(v14, (__int64)v11);
  add_p1p1(v11, (__int64)v13, (__int64)v14);
  p1p1_to_p3(v15, (__int64)v11);
  qmemcpy(v16, a4, sizeof(v16));
  add_p1p1(v11, (__int64)v13, (__int64)v16);
  p1p1_to_p3(v17, (__int64)v11);
  add_p1p1(v11, (__int64)v14, (__int64)v16);
  p1p1_to_p3(v18, (__int64)v11);
  add_p1p1(v11, (__int64)v15, (__int64)v16);
  p1p1_to_p3(v19, (__int64)v11);
  dbl_p1p1(v11, (__int64)a4);
  p1p1_to_p3(v20, (__int64)v11);
  add_p1p1(v11, (__int64)v13, (__int64)v20);
  p1p1_to_p3(v21, (__int64)v11);
  dbl_p1p1(v11, (__int64)v17);
  p1p1_to_p3(v22, (__int64)v11);
  add_p1p1(v11, (__int64)v15, (__int64)v20);
  p1p1_to_p3(v23, (__int64)v11);
  add_p1p1(v11, (__int64)v16, (__int64)v20);
  p1p1_to_p3(v24, (__int64)v11);
  add_p1p1(v11, (__int64)v13, (__int64)v24);
  p1p1_to_p3(v25, (__int64)v11);
  add_p1p1(v11, (__int64)v14, (__int64)v24);
  p1p1_to_p3(v26, (__int64)v11);
  add_p1p1(v11, (__int64)v15, (__int64)v24);
  p1p1_to_p3(v27, (__int64)v11);
  crypto_sign_ed25519_ref_sc25519_2interleave2(v28, a3, a5);
  v5 = &v12[512 * (unsigned __int64)(unsigned __int8)v28[126]];
  *(_QWORD *)a1 = *(_QWORD *)v5;
  *(_QWORD *)(a1 + 504) = *((_QWORD *)v5 + 63);
  qmemcpy(
    (void *)((a1 + 8) & 0xFFFFFFFFFFFFFFF8LL),
    &v5[-(a1 - ((a1 + 8) & 0xFFFFFFFFFFFFFFF8LL))],
    8LL * ((((_DWORD)a1 - (((_DWORD)a1 + 8) & 0xFFFFFFF8) + 512) & 0xFFFFFFF8) >> 3));
  for ( i = 125; i >= 0; --i )
  {
    dbl_p1p1(v11, a1);
    p1p1_to_p2((_DWORD *)a1, (__int64)v11);
    dbl_p1p1(v11, a1);
    if ( v28[i] )
    {
      p1p1_to_p3((_DWORD *)a1, (__int64)v11);
      add_p1p1(v11, a1, (__int64)&v12[512 * (unsigned __int64)(unsigned __int8)v28[i]]);
    }
    if ( i )
      p1p1_to_p2((_DWORD *)a1, (__int64)v11);
    else
      p1p1_to_p3((_DWORD *)a1, (__int64)v11);
  }
  return __readfsqword(0x28u) ^ v29;
}
// 3629C: using guessed type _DWORD var_2290[128];
// 3629C: using guessed type int anonymous_0[128];
// 3629C: using guessed type int anonymous_1[128];
// 3629C: using guessed type int anonymous_2[128];
// 3629C: using guessed type int anonymous_3[128];
// 3629C: using guessed type int anonymous_4[128];
// 3629C: using guessed type int anonymous_5[128];
// 3629C: using guessed type int anonymous_6[128];
// 3629C: using guessed type int anonymous_7[128];

//----- (0000000000036897) ----------------------------------------------------
unsigned __int64 __fastcall crypto_sign_ed25519_ref_scalarmult_base(__int64 a1, __int64 a2)
{
  int i; // [rsp+1Ch] [rbp-164h]
  _QWORD v4[32]; // [rsp+20h] [rbp-160h] BYREF
  char v5[88]; // [rsp+120h] [rbp-60h] BYREF
  unsigned __int64 v6; // [rsp+178h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  crypto_sign_ed25519_ref_sc25519_window3((__int64)v5, a2);
  choose_t((_QWORD *)a1, 0LL, v5[0]);
  crypto_sign_ed25519_ref_fe25519_setone((_DWORD *)(a1 + 256));
  crypto_sign_ed25519_ref_fe25519_mul((_DWORD *)(a1 + 384), a1, a1 + 128);
  for ( i = 1; i <= 84; ++i )
  {
    choose_t(v4, i, v5[i]);
    ge25519_mixadd2((_DWORD *)a1, (__int64)v4);
  }
  return __readfsqword(0x28u) ^ v6;
}
// 36897: using guessed type char var_60[88];
// 36897: using guessed type _QWORD var_160[32];

//----- (00000000000369AA) ----------------------------------------------------
__int64 __fastcall lt(int a1, int a2)
{
  return (unsigned int)(a1 - a2) >> 31;
}

//----- (00000000000369C9) ----------------------------------------------------
unsigned __int64 __fastcall reduce_add_sub(__int64 a1)
{
  int v2; // [rsp+10h] [rbp-40h]
  int v3; // [rsp+10h] [rbp-40h]
  int v4; // [rsp+14h] [rbp-3Ch]
  int i; // [rsp+18h] [rbp-38h]
  int j; // [rsp+18h] [rbp-38h]
  char v7[40]; // [rsp+20h] [rbp-30h]
  unsigned __int64 v8; // [rsp+48h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  v2 = 0;
  for ( i = 0; i <= 31; ++i )
  {
    v3 = m[i] + v2;
    v4 = lt(*(_DWORD *)(a1 + 4LL * i), v3);
    v7[i] = *(_BYTE *)(a1 + 4LL * i) - v3;
    v2 = v4;
  }
  for ( j = 0; j <= 31; ++j )
    *(_DWORD *)(a1 + 4LL * j) ^= (v4 - 1) & (*(_DWORD *)(a1 + 4LL * j) ^ (unsigned __int8)v7[j]);
  return __readfsqword(0x28u) ^ v8;
}
// 36A5D: variable 'v4' is possibly undefined
// 73660: using guessed type _DWORD m[32];
// 369C9: using guessed type char var_30[40];

//----- (0000000000036AC5) ----------------------------------------------------
unsigned __int64 __fastcall barrett_reduce(__int64 a1, __int64 a2)
{
  int i; // [rsp+14h] [rbp-24Ch]
  int j; // [rsp+14h] [rbp-24Ch]
  int k; // [rsp+14h] [rbp-24Ch]
  int n; // [rsp+14h] [rbp-24Ch]
  int ii; // [rsp+14h] [rbp-24Ch]
  int kk; // [rsp+14h] [rbp-24Ch]
  int mm; // [rsp+14h] [rbp-24Ch]
  int m; // [rsp+18h] [rbp-248h]
  int jj; // [rsp+18h] [rbp-248h]
  int v12; // [rsp+1Ch] [rbp-244h]
  int v13; // [rsp+1Ch] [rbp-244h]
  int v14; // [rsp+24h] [rbp-23Ch]
  int v15[104]; // [rsp+30h] [rbp-230h]
  unsigned int v16; // [rsp+1D0h] [rbp-90h]
  int v17[35]; // [rsp+1D4h] [rbp-8Ch] BYREF

  v12 = 0;
  for ( i = 0; i <= 65; ++i )
    v15[i + 72] = 0;
  for ( j = 0; j <= 32; ++j )
    v15[j + 36] = 0;
  for ( k = 0; k <= 32; ++k )
  {
    for ( m = 0; m <= 32; ++m )
    {
      if ( k + m > 30 )
        v15[k + 72 + m] += mu[k] * *(_DWORD *)(4 * (m + 31LL) + a2);
    }
  }
  v16 += (unsigned int)v15[103] >> 8;
  v17[0] += v16 >> 8;
  for ( n = 0; n <= 32; ++n )
    v15[n] = *(_DWORD *)(4LL * n + a2);
  for ( ii = 0; ii <= 31; ++ii )
  {
    for ( jj = 0; jj <= 32; ++jj )
    {
      if ( ii + jj <= 32 )
        v15[ii + 36 + jj] += ::m[ii] * v17[jj];
    }
  }
  for ( kk = 0; kk <= 31; ++kk )
  {
    v15[kk + 37] += (unsigned int)v15[kk + 36] >> 8;
    v15[kk + 36] = (unsigned __int8)v15[kk + 36];
  }
  for ( mm = 0; mm <= 31; ++mm )
  {
    v13 = v15[mm + 36] + v12;
    v14 = lt(v15[mm], v13);
    *(_DWORD *)(a1 + 4LL * mm) = v15[mm] - v13 + (v14 << 8);
    v12 = v14;
  }
  reduce_add_sub(a1);
  return reduce_add_sub(a1);
}
// 73660: using guessed type _DWORD m[32];
// 736E0: using guessed type _DWORD mu[33];
// 36AC5: using guessed type int var_8C[35];

//----- (0000000000036EB2) ----------------------------------------------------
unsigned __int64 __fastcall crypto_sign_ed25519_ref_sc25519_from32bytes(__int64 a1, __int64 a2)
{
  int i; // [rsp+1Ch] [rbp-104h]
  int j; // [rsp+1Ch] [rbp-104h]
  int v5[64]; // [rsp+20h] [rbp-100h] BYREF

  for ( i = 0; i <= 31; ++i )
    v5[i] = *(unsigned __int8 *)(i + a2);
  for ( j = 32; j <= 63; ++j )
    v5[j] = 0;
  return barrett_reduce(a1, (__int64)v5);
}
// 36EB2: using guessed type int var_100[64];

//----- (0000000000036F5A) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_shortsc25519_from16bytes(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i <= 15; ++i )
  {
    result = a1;
    *(_DWORD *)(a1 + 4LL * i) = *(unsigned __int8 *)(i + a2);
  }
  return result;
}

//----- (0000000000036F9C) ----------------------------------------------------
unsigned __int64 __fastcall crypto_sign_ed25519_ref_sc25519_from64bytes(__int64 a1, __int64 a2)
{
  int i; // [rsp+1Ch] [rbp-104h]
  int v4[64]; // [rsp+20h] [rbp-100h] BYREF

  for ( i = 0; i <= 63; ++i )
    v4[i] = *(unsigned __int8 *)(i + a2);
  return barrett_reduce(a1, (__int64)v4);
}
// 36F9C: using guessed type int var_100[64];

//----- (0000000000037015) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_from_shortsc(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-4h]
  int j; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i <= 15; ++i )
  {
    result = a1;
    *(_DWORD *)(a1 + 4LL * i) = *(_DWORD *)(a2 + 4LL * i);
  }
  for ( j = 0; j <= 15; ++j )
  {
    result = a1;
    *(_DWORD *)(a1 + 4LL * (j + 16)) = 0;
  }
  return result;
}

//----- (0000000000037078) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_to32bytes(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i <= 31; ++i )
  {
    result = *(unsigned int *)(a2 + 4LL * i);
    *(_BYTE *)(i + a1) = result;
  }
  return result;
}

//----- (00000000000370B7) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_iszero_vartime(__int64 a1)
{
  int i; // [rsp+14h] [rbp-4h]

  for ( i = 0; i <= 31; ++i )
  {
    if ( *(_DWORD *)(a1 + 4LL * i) )
      return 0LL;
  }
  return 1LL;
}

//----- (00000000000370F1) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_isshort_vartime(__int64 a1)
{
  int i; // [rsp+14h] [rbp-4h]

  for ( i = 31; i > 15; --i )
  {
    if ( *(_DWORD *)(a1 + 4LL * i) )
      return 0LL;
  }
  return 1LL;
}

//----- (000000000003712B) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_lt_vartime(__int64 a1, __int64 a2)
{
  int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 31; i >= 0; --i )
  {
    if ( *(_DWORD *)(a1 + 4LL * i) < *(_DWORD *)(a2 + 4LL * i) )
      return 1LL;
    if ( *(_DWORD *)(a1 + 4LL * i) > *(_DWORD *)(a2 + 4LL * i) )
      return 0LL;
  }
  return 0LL;
}

//----- (000000000003719B) ----------------------------------------------------
unsigned __int64 __fastcall crypto_sign_ed25519_ref_sc25519_add(__int64 a1, __int64 a2, __int64 a3)
{
  int i; // [rsp+28h] [rbp-8h]
  int j; // [rsp+28h] [rbp-8h]

  for ( i = 0; i <= 31; ++i )
    *(_DWORD *)(a1 + 4LL * i) = *(_DWORD *)(a3 + 4LL * i) + *(_DWORD *)(a2 + 4LL * i);
  for ( j = 0; j <= 30; ++j )
  {
    *(_DWORD *)(a1 + 4LL * (j + 1)) += *(_DWORD *)(a1 + 4LL * j) >> 8;
    *(_DWORD *)(a1 + 4LL * j) = (unsigned __int8)*(_DWORD *)(a1 + 4LL * j);
  }
  return reduce_add_sub(a1);
}

//----- (0000000000037263) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_sub_nored(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  int v4; // [rsp+1Ch] [rbp-Ch]
  int i; // [rsp+20h] [rbp-8h]
  unsigned int v6; // [rsp+24h] [rbp-4h]

  v4 = 0;
  for ( i = 0; i <= 31; ++i )
  {
    v6 = *(_DWORD *)(a2 + 4LL * i) - *(_DWORD *)(a3 + 4LL * i) - v4;
    *(_DWORD *)(a1 + 4LL * i) = (unsigned __int8)v6;
    result = (v6 >> 8) & 1;
    v4 = (v6 >> 8) & 1;
  }
  return result;
}

//----- (00000000000372D3) ----------------------------------------------------
unsigned __int64 __fastcall crypto_sign_ed25519_ref_sc25519_mul(__int64 a1, __int64 a2, __int64 a3)
{
  int i; // [rsp+24h] [rbp-10Ch]
  int j; // [rsp+24h] [rbp-10Ch]
  int m; // [rsp+24h] [rbp-10Ch]
  int k; // [rsp+28h] [rbp-108h]
  int v8[64]; // [rsp+30h] [rbp-100h] BYREF

  for ( i = 0; i <= 63; ++i )
    v8[i] = 0;
  for ( j = 0; j <= 31; ++j )
  {
    for ( k = 0; k <= 31; ++k )
      v8[j + k] += *(_DWORD *)(a2 + 4LL * j) * *(_DWORD *)(a3 + 4LL * k);
  }
  for ( m = 0; m <= 62; ++m )
  {
    v8[m + 1] += (unsigned int)v8[m] >> 8;
    v8[m] = (unsigned __int8)v8[m];
  }
  return barrett_reduce(a1, (__int64)v8);
}
// 372D3: using guessed type int var_100[64];

//----- (0000000000037458) ----------------------------------------------------
unsigned __int64 __fastcall crypto_sign_ed25519_ref_sc25519_mul_shortsc(__int64 a1, __int64 a2, __int64 a3)
{
  char v4[128]; // [rsp+20h] [rbp-80h] BYREF

  crypto_sign_ed25519_ref_sc25519_from_shortsc((__int64)v4, a3);
  return crypto_sign_ed25519_ref_sc25519_mul(a1, a2, (__int64)v4);
}

//----- (00000000000374AE) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_window3(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  char v3; // [rsp+1Bh] [rbp-5h]
  int i; // [rsp+1Ch] [rbp-4h]
  int j; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i <= 9; ++i )
  {
    *(_BYTE *)(8 * i + a1) = *(_DWORD *)(a2 + 12LL * i) & 7;
    *(_BYTE *)(8 * i + 1LL + a1) = (*(_DWORD *)(a2 + 12LL * i) >> 3) & 7;
    *(_BYTE *)(8 * i + 2LL + a1) = (*(_DWORD *)(a2 + 12LL * i) >> 6) & 7;
    *(_BYTE *)(8 * i + 2LL + a1) ^= (4 * *(_DWORD *)(a2 + 4LL * (3 * i + 1))) & 7;
    *(_BYTE *)(8 * i + 3LL + a1) = (*(_DWORD *)(a2 + 4LL * (3 * i + 1)) >> 1) & 7;
    *(_BYTE *)(8 * i + 4LL + a1) = (*(_DWORD *)(a2 + 4LL * (3 * i + 1)) >> 4) & 7;
    *(_BYTE *)(8 * i + 5LL + a1) = (*(_DWORD *)(a2 + 4LL * (3 * i + 1)) >> 7) & 7;
    *(_BYTE *)(8 * i + 5LL + a1) ^= (2 * *(_DWORD *)(a2 + 4LL * (3 * i + 2))) & 7;
    *(_BYTE *)(8 * i + 6LL + a1) = (*(_DWORD *)(a2 + 4LL * (3 * i + 2)) >> 2) & 7;
    *(_BYTE *)(8 * i + 7LL + a1) = (*(_DWORD *)(a2 + 4LL * (3 * i + 2)) >> 5) & 7;
  }
  *(_BYTE *)(8 * i + a1) = *(_DWORD *)(a2 + 12LL * i) & 7;
  *(_BYTE *)(8 * i + 1LL + a1) = (*(_DWORD *)(a2 + 12LL * i) >> 3) & 7;
  *(_BYTE *)(8 * i + 2LL + a1) = (*(_DWORD *)(a2 + 12LL * i) >> 6) & 7;
  *(_BYTE *)(8 * i + 2LL + a1) ^= (4 * *(_DWORD *)(a2 + 4LL * (3 * i + 1))) & 7;
  *(_BYTE *)(8 * i + 3LL + a1) = (*(_DWORD *)(a2 + 4LL * (3 * i + 1)) >> 1) & 7;
  *(_BYTE *)(8 * i + 4LL + a1) = (*(_DWORD *)(a2 + 4LL * (3 * i + 1)) >> 4) & 7;
  v3 = 0;
  for ( j = 0; j <= 83; ++j )
  {
    *(_BYTE *)(j + a1) += v3;
    *(_BYTE *)(j + 1LL + a1) += *(char *)(j + a1) >> 3;
    *(_BYTE *)(j + a1) &= 7u;
    v3 = *(char *)(j + a1) >> 2;
    *(_BYTE *)(j + a1) -= 8 * v3;
  }
  result = a1 + 84;
  *(_BYTE *)(a1 + 84) += v3;
  return result;
}

//----- (0000000000037927) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_window5(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  char v3; // [rsp+1Bh] [rbp-5h]
  int i; // [rsp+1Ch] [rbp-4h]
  int j; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i <= 5; ++i )
  {
    *(_BYTE *)(8 * i + a1) = *(_DWORD *)(a2 + 20LL * i) & 0x1F;
    *(_BYTE *)(8 * i + 1LL + a1) = (*(_DWORD *)(a2 + 20LL * i) >> 5) & 0x1F;
    *(_BYTE *)(8 * i + 1LL + a1) ^= (8 * *(_DWORD *)(a2 + 4LL * (5 * i + 1))) & 0x1F;
    *(_BYTE *)(8 * i + 2LL + a1) = (*(_DWORD *)(a2 + 4LL * (5 * i + 1)) >> 2) & 0x1F;
    *(_BYTE *)(8 * i + 3LL + a1) = (*(_DWORD *)(a2 + 4LL * (5 * i + 1)) >> 7) & 0x1F;
    *(_BYTE *)(8 * i + 3LL + a1) ^= (2 * *(_DWORD *)(a2 + 4LL * (5 * i + 2))) & 0x1F;
    *(_BYTE *)(8 * i + 4LL + a1) = (*(_DWORD *)(a2 + 4LL * (5 * i + 2)) >> 4) & 0x1F;
    *(_BYTE *)(8 * i + 4LL + a1) ^= (16 * *(_DWORD *)(a2 + 4LL * (5 * i + 3))) & 0x1F;
    *(_BYTE *)(8 * i + 5LL + a1) = (*(_DWORD *)(a2 + 4LL * (5 * i + 3)) >> 1) & 0x1F;
    *(_BYTE *)(8 * i + 6LL + a1) = (*(_DWORD *)(a2 + 4LL * (5 * i + 3)) >> 6) & 0x1F;
    *(_BYTE *)(8 * i + 6LL + a1) ^= (4 * *(_DWORD *)(a2 + 4LL * (5 * i + 4))) & 0x1F;
    *(_BYTE *)(8 * i + 7LL + a1) = (*(_DWORD *)(a2 + 4LL * (5 * i + 4)) >> 3) & 0x1F;
  }
  *(_BYTE *)(8 * i + a1) = *(_DWORD *)(a2 + 20LL * i) & 0x1F;
  *(_BYTE *)(8 * i + 1LL + a1) = (*(_DWORD *)(a2 + 20LL * i) >> 5) & 0x1F;
  *(_BYTE *)(8 * i + 1LL + a1) ^= (8 * *(_DWORD *)(a2 + 4LL * (5 * i + 1))) & 0x1F;
  *(_BYTE *)(8 * i + 2LL + a1) = (*(_DWORD *)(a2 + 4LL * (5 * i + 1)) >> 2) & 0x1F;
  v3 = 0;
  for ( j = 0; j <= 49; ++j )
  {
    *(_BYTE *)(j + a1) += v3;
    *(_BYTE *)(j + 1LL + a1) += *(char *)(j + a1) >> 5;
    *(_BYTE *)(j + a1) &= 0x1Fu;
    v3 = *(char *)(j + a1) >> 4;
    *(_BYTE *)(j + a1) -= 32 * v3;
  }
  result = a1 + 50;
  *(_BYTE *)(a1 + 50) += v3;
  return result;
}

//----- (0000000000037DEB) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_sc25519_2interleave2(_BYTE *a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  int i; // [rsp+24h] [rbp-4h]

  for ( i = 0; i <= 30; ++i )
  {
    a1[4 * i] = *(_DWORD *)(a2 + 4LL * i) & 3 | (4 * *(_DWORD *)(a3 + 4LL * i)) & 0xC;
    a1[4 * i + 1] = (*(_DWORD *)(a2 + 4LL * i) >> 2) & 3 | (4 * (*(_DWORD *)(a3 + 4LL * i) >> 2)) & 0xC;
    a1[4 * i + 2] = (*(_DWORD *)(a2 + 4LL * i) >> 4) & 3 | (4 * (*(_DWORD *)(a3 + 4LL * i) >> 4)) & 0xC;
    a1[4 * i + 3] = (*(_DWORD *)(a2 + 4LL * i) >> 6) & 3 | (4 * (*(_DWORD *)(a3 + 4LL * i) >> 6)) & 0xC;
  }
  a1[124] = *(_DWORD *)(a2 + 124) & 3 | (4 * *(_DWORD *)(a3 + 124)) & 0xC;
  a1[125] = (*(_DWORD *)(a2 + 124) >> 2) & 3 | (4 * (*(_DWORD *)(a3 + 124) >> 2)) & 0xC;
  result = (*(_DWORD *)(a2 + 124) >> 4) & 3 | (4 * (unsigned __int8)(*(_DWORD *)(a3 + 124) >> 4)) & 0xCu;
  a1[126] = (*(_DWORD *)(a2 + 124) >> 4) & 3 | (4 * (*(_DWORD *)(a3 + 124) >> 4)) & 0xC;
  return result;
}

//----- (0000000000037F96) ----------------------------------------------------
__int64 __fastcall ssh_pthread_mutex_init(pthread_mutex_t **a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-4h]

  if ( !a1 )
    return 22LL;
  *a1 = (pthread_mutex_t *)malloc(0x28uLL);
  if ( !*a1 )
    return 12LL;
  v2 = pthread_mutex_init(*a1, 0LL);
  if ( v2 )
  {
    free(*a1);
    *a1 = 0LL;
  }
  return v2;
}

//----- (000000000003801A) ----------------------------------------------------
__int64 __fastcall ssh_pthread_mutex_destroy(pthread_mutex_t **a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-4h]

  if ( !a1 )
    return 22LL;
  v2 = pthread_mutex_destroy(*a1);
  free(*a1);
  *a1 = 0LL;
  return v2;
}

//----- (000000000003806C) ----------------------------------------------------
int __fastcall ssh_pthread_mutex_lock(pthread_mutex_t **a1)
{
  return pthread_mutex_lock(*a1);
}

//----- (0000000000038089) ----------------------------------------------------
int __fastcall ssh_pthread_mutex_unlock(pthread_mutex_t **a1)
{
  return pthread_mutex_unlock(*a1);
}

//----- (00000000000380A6) ----------------------------------------------------
pthread_t ssh_pthread_thread_id()
{
  return pthread_self();
}

//----- (00000000000380B1) ----------------------------------------------------
int __fastcall ssh_mutex_lock(pthread_mutex_t *a1)
{
  int result; // eax

  if ( !a1 )
    exit(22);
  result = pthread_mutex_lock(a1);
  if ( result )
    exit(result);
  return result;
}

//----- (00000000000380F0) ----------------------------------------------------
int __fastcall ssh_mutex_unlock(pthread_mutex_t *a1)
{
  int result; // eax

  if ( !a1 )
    exit(22);
  result = pthread_mutex_unlock(a1);
  if ( result )
    exit(result);
  return result;
}

//----- (000000000003812F) ----------------------------------------------------
char **ssh_threads_get_default()
{
  return &ssh_threads_pthread;
}
// 280E00: using guessed type char *ssh_threads_pthread;

//----- (000000000003813C) ----------------------------------------------------
char **ssh_threads_get_pthread()
{
  return &ssh_threads_pthread;
}
// 280E00: using guessed type char *ssh_threads_pthread;

//----- (0000000000038149) ----------------------------------------------------
__int64 crypto_thread_init()
{
  return 0LL;
}
// 38149: using guessed type __int64 crypto_thread_init();

//----- (0000000000038158) ----------------------------------------------------
void crypto_thread_finalize()
{
  ;
}

//----- (000000000003815F) ----------------------------------------------------
__int64 __fastcall alloc_key(__int64 a1)
{
  *(_QWORD *)(a1 + 32) = malloc(*(_QWORD *)(a1 + 24));
  if ( *(_QWORD *)(a1 + 32) )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (00000000000381A1) ----------------------------------------------------
void ssh_reseed()
{
  ;
}

//----- (00000000000381A8) ----------------------------------------------------
__int64 __fastcall ssh_get_random(__int64 a1, int a2)
{
  gcry_randomize(a1, a2, 1LL);
  return 1LL;
}
// E0F0: using guessed type __int64 __fastcall gcry_randomize(_QWORD, _QWORD, _QWORD);

//----- (00000000000381DB) ----------------------------------------------------
__int64 sha1_init()
{
  __int64 v1; // [rsp+8h] [rbp-8h] BYREF

  v1 = 0LL;
  gcry_md_open(&v1, 2LL, 0LL);
  return v1;
}
// D960: using guessed type __int64 __fastcall gcry_md_open(_QWORD, _QWORD, _QWORD);
// 381DB: using guessed type __int64 sha1_init();

//----- (0000000000038207) ----------------------------------------------------
__int64 __fastcall sha1_update(__int64 a1, __int64 a2, __int64 a3)
{
  return gcry_md_write(a1, a2, a3);
}
// D9A0: using guessed type __int64 __fastcall gcry_md_write(_QWORD, _QWORD, _QWORD);

//----- (0000000000038235) ----------------------------------------------------
__int64 __fastcall sha1_final(void *a1, __int64 a2)
{
  const void *v2; // rax

  gcry_md_ctl(a2, 5LL, 0LL, 0LL);
  v2 = (const void *)gcry_md_read(a2, 0LL);
  memcpy(a1, v2, 0x14uLL);
  return gcry_md_close(a2);
}
// D860: using guessed type __int64 __fastcall gcry_md_close(_QWORD);
// D8C0: using guessed type __int64 __fastcall gcry_md_read(_QWORD, _QWORD);
// DF30: using guessed type __int64 __fastcall gcry_md_ctl(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000038297) ----------------------------------------------------
__int64 __fastcall sha1(__int64 a1, int a2, __int64 a3)
{
  return gcry_md_hash_buffer(2LL, a3, a1, a2);
}
// DEE0: using guessed type __int64 __fastcall gcry_md_hash_buffer(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000382C8) ----------------------------------------------------
__int64 __fastcall nid_to_md_algo(int a1)
{
  if ( a1 == 1 )
    return 9LL;
  if ( a1 == 2 )
    return 10LL;
  if ( a1 )
    return 0LL;
  return 8LL;
}

//----- (00000000000382FC) ----------------------------------------------------
_DWORD *__fastcall evp(int a1, __int64 a2, int a3, __int64 a4, _DWORD *a5)
{
  int algo_dlen; // edx
  _DWORD *result; // rax
  unsigned int v10; // [rsp+2Ch] [rbp-4h]

  v10 = nid_to_md_algo(a1);
  gcry_md_hash_buffer(v10, a4, a2, a3);
  algo_dlen = gcry_md_get_algo_dlen(v10);
  result = a5;
  *a5 = algo_dlen;
  return result;
}
// D800: using guessed type __int64 __fastcall gcry_md_get_algo_dlen(_QWORD);
// DEE0: using guessed type __int64 __fastcall gcry_md_hash_buffer(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000038350) ----------------------------------------------------
__int64 __fastcall evp_init(int a1)
{
  unsigned int v2; // [rsp+10h] [rbp-10h]
  __int64 v3; // [rsp+18h] [rbp-8h] BYREF

  v2 = nid_to_md_algo(a1);
  if ( (unsigned int)gcry_md_open(&v3, v2, 0LL) )
    return 0LL;
  else
    return v3;
}
// D960: using guessed type __int64 __fastcall gcry_md_open(_QWORD, _QWORD, _QWORD);

//----- (0000000000038394) ----------------------------------------------------
__int64 __fastcall evp_update(__int64 a1, __int64 a2, __int64 a3)
{
  return gcry_md_write(a1, a2, a3);
}
// D9A0: using guessed type __int64 __fastcall gcry_md_write(_QWORD, _QWORD, _QWORD);

//----- (00000000000383C2) ----------------------------------------------------
__int64 __fastcall evp_final(__int64 a1, void *a2, _DWORD *a3)
{
  size_t v3; // rbx
  const void *v4; // rax
  unsigned int algo; // [rsp+2Ch] [rbp-14h]

  algo = gcry_md_get_algo(a1);
  *a3 = gcry_md_get_algo_dlen(algo);
  v3 = (unsigned int)*a3;
  v4 = (const void *)gcry_md_read(a1, algo);
  memcpy(a2, v4, v3);
  return gcry_md_close(a1);
}
// D800: using guessed type __int64 __fastcall gcry_md_get_algo_dlen(_QWORD);
// D860: using guessed type __int64 __fastcall gcry_md_close(_QWORD);
// D8C0: using guessed type __int64 __fastcall gcry_md_read(_QWORD, _QWORD);
// DC50: using guessed type __int64 __fastcall gcry_md_get_algo(_QWORD);

//----- (000000000003843A) ----------------------------------------------------
__int64 sha256_init()
{
  __int64 v1; // [rsp+8h] [rbp-8h] BYREF

  v1 = 0LL;
  gcry_md_open(&v1, 8LL, 0LL);
  return v1;
}
// D960: using guessed type __int64 __fastcall gcry_md_open(_QWORD, _QWORD, _QWORD);
// 3843A: using guessed type __int64 sha256_init();

//----- (0000000000038466) ----------------------------------------------------
__int64 __fastcall sha256_update(__int64 a1, __int64 a2, __int64 a3)
{
  return gcry_md_write(a1, a2, a3);
}
// D9A0: using guessed type __int64 __fastcall gcry_md_write(_QWORD, _QWORD, _QWORD);

//----- (0000000000038494) ----------------------------------------------------
__int64 __fastcall sha256_final(void *a1, __int64 a2)
{
  const void *v2; // rax

  gcry_md_ctl(a2, 5LL, 0LL, 0LL);
  v2 = (const void *)gcry_md_read(a2, 0LL);
  memcpy(a1, v2, 0x20uLL);
  return gcry_md_close(a2);
}
// D860: using guessed type __int64 __fastcall gcry_md_close(_QWORD);
// D8C0: using guessed type __int64 __fastcall gcry_md_read(_QWORD, _QWORD);
// DF30: using guessed type __int64 __fastcall gcry_md_ctl(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000384F6) ----------------------------------------------------
__int64 __fastcall sha256(__int64 a1, int a2, __int64 a3)
{
  return gcry_md_hash_buffer(8LL, a3, a1, a2);
}
// DEE0: using guessed type __int64 __fastcall gcry_md_hash_buffer(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000038527) ----------------------------------------------------
__int64 sha384_init()
{
  __int64 v1; // [rsp+8h] [rbp-8h] BYREF

  v1 = 0LL;
  gcry_md_open(&v1, 9LL, 0LL);
  return v1;
}
// D960: using guessed type __int64 __fastcall gcry_md_open(_QWORD, _QWORD, _QWORD);
// 38527: using guessed type __int64 sha384_init();

//----- (0000000000038553) ----------------------------------------------------
__int64 __fastcall sha384_update(__int64 a1, __int64 a2, __int64 a3)
{
  return gcry_md_write(a1, a2, a3);
}
// D9A0: using guessed type __int64 __fastcall gcry_md_write(_QWORD, _QWORD, _QWORD);

//----- (0000000000038581) ----------------------------------------------------
__int64 __fastcall sha384_final(void *a1, __int64 a2)
{
  const void *v2; // rax

  gcry_md_ctl(a2, 5LL, 0LL, 0LL);
  v2 = (const void *)gcry_md_read(a2, 0LL);
  memcpy(a1, v2, 0x30uLL);
  return gcry_md_close(a2);
}
// D860: using guessed type __int64 __fastcall gcry_md_close(_QWORD);
// D8C0: using guessed type __int64 __fastcall gcry_md_read(_QWORD, _QWORD);
// DF30: using guessed type __int64 __fastcall gcry_md_ctl(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000385E3) ----------------------------------------------------
__int64 __fastcall sha384(__int64 a1, int a2, __int64 a3)
{
  return gcry_md_hash_buffer(9LL, a3, a1, a2);
}
// DEE0: using guessed type __int64 __fastcall gcry_md_hash_buffer(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000038614) ----------------------------------------------------
__int64 sha512_init()
{
  __int64 v1; // [rsp+8h] [rbp-8h] BYREF

  v1 = 0LL;
  gcry_md_open(&v1, 10LL, 0LL);
  return v1;
}
// D960: using guessed type __int64 __fastcall gcry_md_open(_QWORD, _QWORD, _QWORD);
// 38614: using guessed type __int64 sha512_init();

//----- (0000000000038640) ----------------------------------------------------
__int64 __fastcall sha512_update(__int64 a1, __int64 a2, __int64 a3)
{
  return gcry_md_write(a1, a2, a3);
}
// D9A0: using guessed type __int64 __fastcall gcry_md_write(_QWORD, _QWORD, _QWORD);

//----- (000000000003866E) ----------------------------------------------------
__int64 __fastcall sha512_final(void *a1, __int64 a2)
{
  const void *v2; // rax

  gcry_md_ctl(a2, 5LL, 0LL, 0LL);
  v2 = (const void *)gcry_md_read(a2, 0LL);
  memcpy(a1, v2, 0x40uLL);
  return gcry_md_close(a2);
}
// D860: using guessed type __int64 __fastcall gcry_md_close(_QWORD);
// D8C0: using guessed type __int64 __fastcall gcry_md_read(_QWORD, _QWORD);
// DF30: using guessed type __int64 __fastcall gcry_md_ctl(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000386D0) ----------------------------------------------------
__int64 __fastcall sha512(__int64 a1, int a2, __int64 a3)
{
  return gcry_md_hash_buffer(10LL, a3, a1, a2);
}
// DEE0: using guessed type __int64 __fastcall gcry_md_hash_buffer(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000038701) ----------------------------------------------------
__int64 md5_init()
{
  __int64 v1; // [rsp+8h] [rbp-8h] BYREF

  v1 = 0LL;
  gcry_md_open(&v1, 1LL, 0LL);
  return v1;
}
// D960: using guessed type __int64 __fastcall gcry_md_open(_QWORD, _QWORD, _QWORD);
// 38701: using guessed type __int64 md5_init();

//----- (000000000003872D) ----------------------------------------------------
__int64 __fastcall md5_update(__int64 a1, __int64 a2, __int64 a3)
{
  return gcry_md_write(a1, a2, a3);
}
// D9A0: using guessed type __int64 __fastcall gcry_md_write(_QWORD, _QWORD, _QWORD);

//----- (000000000003875B) ----------------------------------------------------
__int64 __fastcall md5_final(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rax
  __int64 v3; // rdx

  gcry_md_ctl(a2, 5LL, 0LL, 0LL);
  v2 = (_QWORD *)gcry_md_read(a2, 0LL);
  v3 = v2[1];
  *a1 = *v2;
  a1[1] = v3;
  return gcry_md_close(a2);
}
// D860: using guessed type __int64 __fastcall gcry_md_close(_QWORD);
// D8C0: using guessed type __int64 __fastcall gcry_md_read(_QWORD, _QWORD);
// DF30: using guessed type __int64 __fastcall gcry_md_ctl(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000387B8) ----------------------------------------------------
_DWORD *__fastcall ssh_mac_ctx_init(unsigned int a1)
{
  _DWORD *ptr; // [rsp+18h] [rbp-8h]

  ptr = malloc(0x10uLL);
  if ( !ptr )
    return 0LL;
  *ptr = a1;
  if ( a1 == 2 )
  {
    gcry_md_open(ptr + 2, 8LL, 0LL);
  }
  else if ( a1 > 2 )
  {
    if ( a1 == 3 )
    {
      gcry_md_open(ptr + 2, 9LL, 0LL);
    }
    else
    {
      if ( a1 != 4 )
        goto LABEL_14;
      gcry_md_open(ptr + 2, 10LL, 0LL);
    }
  }
  else
  {
    if ( a1 != 1 )
    {
LABEL_14:
      free(ptr);
      return 0LL;
    }
    gcry_md_open(ptr + 2, 2LL, 0LL);
  }
  return ptr;
}
// 38880: conditional instruction was optimized away because %ptr.8!=0
// D960: using guessed type __int64 __fastcall gcry_md_open(_QWORD, _QWORD, _QWORD);

//----- (00000000000388A3) ----------------------------------------------------
__int64 __fastcall ssh_mac_update(__int64 a1, __int64 a2, __int64 a3)
{
  return gcry_md_write(*(_QWORD *)(a1 + 8), a2, a3);
}
// D9A0: using guessed type __int64 __fastcall gcry_md_write(_QWORD, _QWORD, _QWORD);

//----- (00000000000388D5) ----------------------------------------------------
void __fastcall ssh_mac_final(void *a1, unsigned int *a2)
{
  unsigned int v2; // eax
  const void *v3; // rax
  size_t n; // [rsp+18h] [rbp-8h]

  n = 0LL;
  v2 = *a2;
  if ( *a2 == 2 )
  {
    n = 32LL;
  }
  else if ( v2 > 2 )
  {
    if ( v2 == 3 )
    {
      n = 48LL;
    }
    else if ( v2 == 4 )
    {
      n = 64LL;
    }
  }
  else if ( v2 == 1 )
  {
    n = 20LL;
  }
  gcry_md_ctl(*((_QWORD *)a2 + 1), 5LL, 0LL, 0LL);
  v3 = (const void *)gcry_md_read(*((_QWORD *)a2 + 1), 0LL);
  memcpy(a1, v3, n);
  gcry_md_close(*((_QWORD *)a2 + 1));
  if ( a2 )
    free(a2);
}
// D860: using guessed type __int64 __fastcall gcry_md_close(_QWORD);
// D8C0: using guessed type __int64 __fastcall gcry_md_read(_QWORD, _QWORD);
// DF30: using guessed type __int64 __fastcall gcry_md_ctl(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000389AF) ----------------------------------------------------
__int64 __fastcall hmac_init(__int64 a1, int a2, int a3)
{
  __int64 v4; // [rsp+18h] [rbp-8h] BYREF

  v4 = 0LL;
  switch ( a3 )
  {
    case 1:
      gcry_md_open(&v4, 2LL, 2LL);
      break;
    case 2:
      gcry_md_open(&v4, 8LL, 2LL);
      break;
    case 3:
      gcry_md_open(&v4, 9LL, 2LL);
      break;
    case 4:
      gcry_md_open(&v4, 10LL, 2LL);
      break;
    case 5:
      gcry_md_open(&v4, 1LL, 2LL);
      break;
    default:
      v4 = 0LL;
      break;
  }
  gcry_md_setkey(v4, a1, a2);
  return v4;
}
// D960: using guessed type __int64 __fastcall gcry_md_open(_QWORD, _QWORD, _QWORD);
// DD70: using guessed type __int64 __fastcall gcry_md_setkey(_QWORD, _QWORD, _QWORD);

//----- (0000000000038A96) ----------------------------------------------------
__int64 __fastcall hmac_update(__int64 a1, __int64 a2, __int64 a3)
{
  return gcry_md_write(a1, a2, a3);
}
// D9A0: using guessed type __int64 __fastcall gcry_md_write(_QWORD, _QWORD, _QWORD);

//----- (0000000000038AC4) ----------------------------------------------------
__int64 __fastcall hmac_final(__int64 a1, void *a2, _DWORD *a3)
{
  unsigned int algo; // eax
  size_t v4; // rbx
  const void *v5; // rax

  algo = gcry_md_get_algo(a1);
  *a3 = gcry_md_get_algo_dlen(algo);
  v4 = (unsigned int)*a3;
  v5 = (const void *)gcry_md_read(a1, 0LL);
  memcpy(a2, v5, v4);
  return gcry_md_close(a1);
}
// D800: using guessed type __int64 __fastcall gcry_md_get_algo_dlen(_QWORD);
// D860: using guessed type __int64 __fastcall gcry_md_close(_QWORD);
// D8C0: using guessed type __int64 __fastcall gcry_md_read(_QWORD, _QWORD);
// DC50: using guessed type __int64 __fastcall gcry_md_get_algo(_QWORD);

//----- (0000000000038B36) ----------------------------------------------------
__int64 __fastcall blowfish_set_key(__int64 a1, __int64 a2, __int64 a3)
{
  if ( *(_QWORD *)(a1 + 32) )
    return 0LL;
  if ( (int)alloc_key(a1) < 0 )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)gcry_cipher_open(*(_QWORD *)(a1 + 32), 4LL, 3LL, 0LL) )
  {
    if ( *(_QWORD *)(a1 + 32) )
    {
      free(*(void **)(a1 + 32));
      *(_QWORD *)(a1 + 32) = 0LL;
    }
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned int)gcry_cipher_setkey(**(_QWORD **)(a1 + 32), a2, 16LL) )
  {
    if ( *(_QWORD *)(a1 + 32) )
    {
      free(*(void **)(a1 + 32));
      *(_QWORD *)(a1 + 32) = 0LL;
    }
    return 0xFFFFFFFFLL;
  }
  if ( !(unsigned int)gcry_cipher_setiv(**(_QWORD **)(a1 + 32), a3, 8LL) )
    return 0LL;
  if ( *(_QWORD *)(a1 + 32) )
  {
    free(*(void **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0LL;
  }
  return 0xFFFFFFFFLL;
}
// D900: using guessed type __int64 __fastcall gcry_cipher_setkey(_QWORD, _QWORD, _QWORD);
// DC70: using guessed type __int64 __fastcall gcry_cipher_open(_QWORD, _QWORD, _QWORD, _QWORD);
// DDF0: using guessed type __int64 __fastcall gcry_cipher_setiv(_QWORD, _QWORD, _QWORD);

//----- (0000000000038C78) ----------------------------------------------------
__int64 __fastcall blowfish_encrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return gcry_cipher_encrypt(**(_QWORD **)(a1 + 32), a3, a4, a2, a4);
}
// D9B0: using guessed type __int64 __fastcall gcry_cipher_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000038CB9) ----------------------------------------------------
__int64 __fastcall blowfish_decrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return gcry_cipher_decrypt(**(_QWORD **)(a1 + 32), a3, a4, a2, a4);
}
// DF10: using guessed type __int64 __fastcall gcry_cipher_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000038CFA) ----------------------------------------------------
__int64 __fastcall aes_set_key(__int64 a1, __int64 a2, __int64 a3)
{
  int v4; // eax
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  v6 = 3;
  if ( *(_QWORD *)(a1 + 32) )
    return 0LL;
  if ( (int)alloc_key(a1) < 0 )
    return 0xFFFFFFFFLL;
  if ( strstr(*(const char **)a1, "-ctr") )
    v6 = 6;
  v4 = *(_DWORD *)(a1 + 48);
  if ( v4 == 192 )
  {
    if ( (unsigned int)gcry_cipher_open(*(_QWORD *)(a1 + 32), 8LL, v6, 0LL) )
    {
      if ( *(_QWORD *)(a1 + 32) )
      {
        free(*(void **)(a1 + 32));
        *(_QWORD *)(a1 + 32) = 0LL;
      }
      return 0xFFFFFFFFLL;
    }
  }
  else if ( v4 == 256 )
  {
    if ( (unsigned int)gcry_cipher_open(*(_QWORD *)(a1 + 32), 9LL, v6, 0LL) )
    {
      if ( *(_QWORD *)(a1 + 32) )
      {
        free(*(void **)(a1 + 32));
        *(_QWORD *)(a1 + 32) = 0LL;
      }
      return 0xFFFFFFFFLL;
    }
  }
  else if ( v4 == 128 && (unsigned int)gcry_cipher_open(*(_QWORD *)(a1 + 32), 7LL, v6, 0LL) )
  {
    if ( *(_QWORD *)(a1 + 32) )
    {
      free(*(void **)(a1 + 32));
      *(_QWORD *)(a1 + 32) = 0LL;
    }
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned int)gcry_cipher_setkey(**(_QWORD **)(a1 + 32), a2, *(_DWORD *)(a1 + 48) >> 3) )
  {
    if ( *(_QWORD *)(a1 + 32) )
    {
      free(*(void **)(a1 + 32));
      *(_QWORD *)(a1 + 32) = 0LL;
    }
    return 0xFFFFFFFFLL;
  }
  if ( v6 == 3 )
  {
    if ( (unsigned int)gcry_cipher_setiv(**(_QWORD **)(a1 + 32), a3, 16LL) )
    {
      if ( *(_QWORD *)(a1 + 32) )
      {
        free(*(void **)(a1 + 32));
        *(_QWORD *)(a1 + 32) = 0LL;
      }
      return 0xFFFFFFFFLL;
    }
    return 0LL;
  }
  if ( !(unsigned int)gcry_cipher_setctr(**(_QWORD **)(a1 + 32), a3, 16LL) )
    return 0LL;
  if ( *(_QWORD *)(a1 + 32) )
  {
    free(*(void **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0LL;
  }
  return 0xFFFFFFFFLL;
}
// D900: using guessed type __int64 __fastcall gcry_cipher_setkey(_QWORD, _QWORD, _QWORD);
// D950: using guessed type __int64 __fastcall gcry_cipher_setctr(_QWORD, _QWORD, _QWORD);
// DC70: using guessed type __int64 __fastcall gcry_cipher_open(_QWORD, _QWORD, _QWORD, _QWORD);
// DDF0: using guessed type __int64 __fastcall gcry_cipher_setiv(_QWORD, _QWORD, _QWORD);

//----- (0000000000038FA5) ----------------------------------------------------
__int64 __fastcall aes_encrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return gcry_cipher_encrypt(**(_QWORD **)(a1 + 32), a3, a4, a2, a4);
}
// D9B0: using guessed type __int64 __fastcall gcry_cipher_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000038FE6) ----------------------------------------------------
__int64 __fastcall aes_decrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return gcry_cipher_decrypt(**(_QWORD **)(a1 + 32), a3, a4, a2, a4);
}
// DF10: using guessed type __int64 __fastcall gcry_cipher_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000039027) ----------------------------------------------------
__int64 __fastcall des3_set_key(__int64 a1, __int64 a2, __int64 a3)
{
  if ( *(_QWORD *)(a1 + 32) )
    return 0LL;
  if ( (int)alloc_key(a1) < 0 )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)gcry_cipher_open(*(_QWORD *)(a1 + 32), 2LL, 3LL, 0LL) )
  {
    if ( *(_QWORD *)(a1 + 32) )
    {
      free(*(void **)(a1 + 32));
      *(_QWORD *)(a1 + 32) = 0LL;
    }
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned int)gcry_cipher_setkey(**(_QWORD **)(a1 + 32), a2, 24LL) )
  {
    if ( *(_QWORD *)(a1 + 32) )
    {
      free(*(void **)(a1 + 32));
      *(_QWORD *)(a1 + 32) = 0LL;
    }
    return 0xFFFFFFFFLL;
  }
  if ( !(unsigned int)gcry_cipher_setiv(**(_QWORD **)(a1 + 32), a3, 8LL) )
    return 0LL;
  if ( *(_QWORD *)(a1 + 32) )
  {
    free(*(void **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0LL;
  }
  return 0xFFFFFFFFLL;
}
// D900: using guessed type __int64 __fastcall gcry_cipher_setkey(_QWORD, _QWORD, _QWORD);
// DC70: using guessed type __int64 __fastcall gcry_cipher_open(_QWORD, _QWORD, _QWORD, _QWORD);
// DDF0: using guessed type __int64 __fastcall gcry_cipher_setiv(_QWORD, _QWORD, _QWORD);

//----- (0000000000039169) ----------------------------------------------------
__int64 __fastcall des3_encrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return gcry_cipher_encrypt(**(_QWORD **)(a1 + 32), a3, a4, a2, a4);
}
// D9B0: using guessed type __int64 __fastcall gcry_cipher_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000391AA) ----------------------------------------------------
__int64 __fastcall des3_decrypt(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return gcry_cipher_decrypt(**(_QWORD **)(a1 + 32), a3, a4, a2, a4);
}
// DF10: using guessed type __int64 __fastcall gcry_cipher_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000391EB) ----------------------------------------------------
char **ssh_get_ciphertab()
{
  return &ssh_ciphertab;
}
// 280E40: using guessed type char *ssh_ciphertab;

//----- (00000000000391F8) ----------------------------------------------------
uint32_t *__fastcall ssh_sexp_extract_mpi(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  unsigned __int64 v9; // [rsp+30h] [rbp-30h] BYREF
  uint32_t *v10; // [rsp+38h] [rbp-28h]
  __int64 v11; // [rsp+40h] [rbp-20h]
  __int64 token; // [rsp+48h] [rbp-18h]

  v10 = 0LL;
  v11 = 0LL;
  token = gcry_sexp_find_token(a1, a2, 0LL);
  if ( token )
  {
    v11 = gcry_sexp_nth_mpi(token, 1LL, a3);
    if ( v11 )
    {
      if ( !(unsigned int)gcry_mpi_print(a4, 0LL, 0LL, &v9, v11) )
      {
        v10 = (uint32_t *)ssh_string_new(v9);
        if ( v10 )
        {
          v4 = v9;
          v5 = ssh_string_data((__int64)v10);
          if ( (unsigned int)gcry_mpi_print(a4, v5, v4, 0LL, v11) )
          {
            ssh_string_burn(v10);
            ssh_string_free(v10);
            v10 = 0LL;
          }
        }
      }
    }
  }
  gcry_sexp_release(token);
  gcry_mpi_release(v11);
  return v10;
}
// D910: using guessed type __int64 __fastcall gcry_mpi_print(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// DB80: using guessed type __int64 __fastcall gcry_sexp_find_token(_QWORD, _QWORD, _QWORD);
// DC80: using guessed type __int64 __fastcall gcry_sexp_nth_mpi(_QWORD, _QWORD, _QWORD);
// DE30: using guessed type __int64 __fastcall gcry_mpi_release(_QWORD);

//----- (0000000000039337) ----------------------------------------------------
__int64 ssh_crypto_init()
{
  char **chacha20poly1305_cipher; // rax
  __int64 i; // [rsp+8h] [rbp-8h]

  if ( libgcrypt_initialized )
    return 0LL;
  gcry_check_version(0LL);
  gcry_control(28LL);
  if ( !(unsigned int)gcry_control(39LL) )
  {
    gcry_control(24LL);
    gcry_control(38LL);
  }
  gcry_control(29LL);
  for ( i = 0LL; (&ssh_ciphertab)[16 * i]; ++i )
  {
    if ( !strcmp((&ssh_ciphertab)[16 * i], "chacha20-poly1305@openssh.com") )
    {
      chacha20poly1305_cipher = ssh_get_chacha20poly1305_cipher();
      memcpy(&(&ssh_ciphertab)[16 * i], chacha20poly1305_cipher, 0x80uLL);
      break;
    }
  }
  libgcrypt_initialized = 1;
  return 0LL;
}
// DB40: using guessed type __int64 __fastcall gcry_check_version(_QWORD);
// DFD0: using guessed type __int64 __fastcall gcry_control(_QWORD);
// 39337: using guessed type __int64 ssh_crypto_init();
// 280E40: using guessed type char *ssh_ciphertab;
// 281A64: using guessed type int libgcrypt_initialized;

//----- (0000000000039453) ----------------------------------------------------
__int64 ssh_crypto_finalize()
{
  __int64 result; // rax

  result = (unsigned int)libgcrypt_initialized;
  if ( libgcrypt_initialized )
  {
    result = gcry_control(25LL);
    libgcrypt_initialized = 0;
  }
  return result;
}
// DFD0: using guessed type __int64 __fastcall gcry_control(_QWORD);
// 39453: using guessed type __int64 ssh_crypto_finalize();
// 281A64: using guessed type int libgcrypt_initialized;

//----- (000000000003947F) ----------------------------------------------------
__int64 __fastcall gpg_err_code(unsigned __int16 a1)
{
  return a1;
}

//----- (000000000003948E) ----------------------------------------------------
__int64 __fastcall gcry_err_code(unsigned __int16 a1)
{
  return gpg_err_code(a1);
}

//----- (00000000000394A5) ----------------------------------------------------
__int64 __fastcall load_iv(__int64 a1, void *a2, int a3)
{
  int i; // [rsp+24h] [rbp-Ch]
  char v6; // [rsp+28h] [rbp-8h]
  char v7; // [rsp+2Ch] [rbp-4h]

  memset(a2, 0, a3);
  for ( i = 0; i < a3; ++i )
  {
    if ( *(char *)(2 * i + a1) <= 47 || *(char *)(2 * i + a1) > 57 )
    {
      if ( *(char *)(2 * i + a1) <= 64 || *(char *)(2 * i + a1) > 70 )
      {
        if ( *(char *)(2 * i + a1) <= 96 || *(char *)(2 * i + a1) > 102 )
          return 0xFFFFFFFFLL;
        v6 = *(_BYTE *)(2 * i + a1) - 87;
      }
      else
      {
        v6 = *(_BYTE *)(2 * i + a1) - 55;
      }
    }
    else
    {
      v6 = *(_BYTE *)(2 * i + a1) - 48;
    }
    if ( *(char *)(2 * i + 1LL + a1) <= 47 || *(char *)(2 * i + 1LL + a1) > 57 )
    {
      if ( *(char *)(2 * i + 1LL + a1) <= 64 || *(char *)(2 * i + 1LL + a1) > 70 )
      {
        if ( *(char *)(2 * i + 1LL + a1) <= 96 || *(char *)(2 * i + 1LL + a1) > 102 )
          return 0xFFFFFFFFLL;
        v7 = *(_BYTE *)(2 * i + 1LL + a1) - 87;
      }
      else
      {
        v7 = *(_BYTE *)(2 * i + 1LL + a1) - 55;
      }
    }
    else
    {
      v7 = *(_BYTE *)(2 * i + 1LL + a1) - 48;
    }
    *((_BYTE *)a2 + i) = 16 * v6 + v7;
  }
  return 0LL;
}

//----- (00000000000396F6) ----------------------------------------------------
__int64 __fastcall char_to_u32(__int64 a1, unsigned int a2)
{
  unsigned int v2; // eax
  unsigned int v4; // [rsp+14h] [rbp-8h]
  unsigned int v5; // [rsp+18h] [rbp-4h]

  v5 = 0;
  v4 = 0;
  while ( v5 < a2 )
  {
    v2 = v5++;
    v4 = *(unsigned __int8 *)(v2 + a1) + (v4 << 8);
  }
  return v4;
}

//----- (000000000003973D) ----------------------------------------------------
__int64 __fastcall asn1_get_len(__int64 a1)
{
  unsigned int v2; // [rsp+18h] [rbp-8h]
  char v4[4]; // [rsp+1Ch] [rbp-4h] BYREF

  if ( !(unsigned int)ssh_buffer_get_data(a1, v4, 1u) )
    return 0LL;
  if ( v4[0] >= 0 )
  {
    return (unsigned int)char_to_u32((__int64)v4, 1u);
  }
  else
  {
    v2 = v4[0] & 0x7F;
    if ( v2 > 4 )
      return 0LL;
    if ( !(unsigned int)ssh_buffer_get_data(a1, v4, v2) )
      return 0LL;
    return (unsigned int)char_to_u32((__int64)v4, v2);
  }
}

//----- (00000000000397DE) ----------------------------------------------------
_BYTE *__fastcall asn1_get(__int64 a1, char a2)
{
  void *v3; // rax
  char v4; // [rsp+13h] [rbp-Dh] BYREF
  unsigned int len; // [rsp+14h] [rbp-Ch]
  _BYTE *v6; // [rsp+18h] [rbp-8h]

  if ( !(unsigned int)ssh_buffer_get_data(a1, &v4, 1u) || v4 != a2 )
    return 0LL;
  len = asn1_get_len(a1);
  if ( !len )
    return 0LL;
  v6 = ssh_string_new(len);
  if ( !v6 )
    return 0LL;
  v3 = (void *)ssh_string_data((__int64)v6);
  if ( (unsigned int)ssh_buffer_get_data(a1, v3, len) )
    return v6;
  ssh_string_free(v6);
  return 0LL;
}

//----- (0000000000039892) ----------------------------------------------------
_BYTE *__fastcall asn1_get_int(__int64 a1)
{
  return asn1_get(a1, 2);
}

//----- (00000000000398B1) ----------------------------------------------------
_BYTE *__fastcall asn1_get_bit_string(__int64 a1)
{
  void *v2; // rax
  char v3; // [rsp+14h] [rbp-1Ch] BYREF
  char v4; // [rsp+15h] [rbp-1Bh] BYREF
  unsigned __int8 v5; // [rsp+16h] [rbp-1Ah] BYREF
  char v6; // [rsp+17h] [rbp-19h]
  unsigned int len; // [rsp+18h] [rbp-18h]
  int data; // [rsp+1Ch] [rbp-14h]
  _BYTE *v9; // [rsp+20h] [rbp-10h]
  _BYTE *v10; // [rsp+28h] [rbp-8h]

  data = ssh_buffer_get_data(a1, &v3, 1u);
  if ( !data || v3 != 3 )
    return 0LL;
  len = asn1_get_len(a1);
  if ( !len )
    return 0LL;
  v10 = ssh_string_new(--len);
  if ( !v10 )
    return 0LL;
  data = ssh_buffer_get_data(a1, &v4, 1u);
  if ( !data )
    goto LABEL_12;
  if ( v4 )
  {
    v9 = (_BYTE *)ssh_string_data((__int64)v10);
    v6 = 0;
    while ( len )
    {
      data = ssh_buffer_get_data(a1, &v5, 1u);
      if ( !data )
        goto LABEL_12;
      *v9 = ((int)v5 >> v4) | v6;
      v6 = v5 << (8 - v4);
      --len;
      ++v9;
    }
    return v10;
  }
  else
  {
    v2 = (void *)ssh_string_data((__int64)v10);
    data = ssh_buffer_get_data(a1, v2, len);
    if ( !data )
    {
LABEL_12:
      ssh_string_free(v10);
      return 0LL;
    }
    return v10;
  }
}

//----- (0000000000039A65) ----------------------------------------------------
__int64 __fastcall asn1_check_sequence(__int64 a1)
{
  int v2; // eax
  int v3; // eax
  __int64 v4; // rax
  char v5; // [rsp+1Bh] [rbp-15h] BYREF
  int v6; // [rsp+1Ch] [rbp-14h]
  unsigned int len; // [rsp+20h] [rbp-10h]
  int v8; // [rsp+24h] [rbp-Ch]
  unsigned __int8 *v9; // [rsp+28h] [rbp-8h]

  v9 = 0LL;
  if ( !(unsigned int)ssh_buffer_get_data(a1, &v5, 1u) || v5 != 48 )
    return 0LL;
  len = asn1_get_len(a1);
  v2 = ssh_buffer_get_len(a1);
  v8 = v2 - len;
  if ( v2 != len )
  {
    v3 = ssh_buffer_get_len(a1);
    v6 = v3 - len;
    v4 = ssh_buffer_get(a1);
    v9 = (unsigned __int8 *)(v4 + len);
    while ( v6 )
    {
      if ( *v9 != v8 )
        return 0LL;
      --v6;
      ++v9;
    }
  }
  return 1LL;
}

//----- (0000000000039B24) ----------------------------------------------------
__int64 __fastcall asn1_check_tag(__int64 a1, char a2)
{
  char v3; // [rsp+1Bh] [rbp-5h] BYREF
  int data; // [rsp+1Ch] [rbp-4h]

  data = ssh_buffer_get_data(a1, &v3, 1u);
  if ( !data || v3 != a2 )
    return 0LL;
  asn1_get_len(a1);
  return 1LL;
}

//----- (0000000000039B79) ----------------------------------------------------
__int64 __fastcall passphrase_to_key(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5)
{
  unsigned int i; // [rsp+2Ch] [rbp-34h]
  unsigned int v10; // [rsp+30h] [rbp-30h]
  int v11; // [rsp+34h] [rbp-2Ch]
  __int64 v12; // [rsp+38h] [rbp-28h]
  __int64 v13[4]; // [rsp+40h] [rbp-20h] BYREF

  v13[3] = __readfsqword(0x28u);
  v13[0] = 0LL;
  v13[1] = 0LL;
  v10 = 0;
  v11 = 0;
  while ( v10 < a5 )
  {
    v12 = md5_init();
    if ( !v12 )
      return 0xFFFFFFFFLL;
    if ( v11 )
      md5_update(v12, (__int64)v13, 16LL);
    else
      v11 = 1;
    md5_update(v12, a1, a2);
    if ( a3 )
      md5_update(v12, a3, 8LL);
    md5_final(v13, v12);
    for ( i = 0; v10 < a5 && i <= 0xF; ++i )
    {
      if ( a4 )
        *(_BYTE *)(a4 + v10) = *((_BYTE *)v13 + i);
      ++v10;
    }
  }
  return 0LL;
}
// 38701: using guessed type __int64 md5_init(void);

//----- (0000000000039CB0) ----------------------------------------------------
__int64 __fastcall privatekey_decrypt(
        unsigned int a1,
        unsigned int a2,
        unsigned int a3,
        __int64 a4,
        unsigned int a5,
        __int64 a6,
        int (__fastcall *a7)(__int64, char *, __int64, _QWORD, _QWORD, const char *),
        const char *a8,
        __int64 a9)
{
  unsigned int v10; // eax
  unsigned int v11; // eax
  __int64 v12; // r12
  __int64 v13; // rbx
  unsigned int v14; // eax
  size_t len; // rbx
  void *v16; // rax
  __int64 v21; // [rsp+50h] [rbp-450h] BYREF
  void *src; // [rsp+58h] [rbp-448h]
  __int64 v23[4]; // [rsp+60h] [rbp-440h] BYREF
  char s[1032]; // [rsp+80h] [rbp-420h] BYREF
  unsigned __int64 v25; // [rsp+488h] [rbp-18h]

  v25 = __readfsqword(0x28u);
  memset(s, 0, 0x400uLL);
  memset(v23, 0, sizeof(v23));
  src = 0LL;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a7 )
  {
    if ( a7(a9, s, 1024LL, 0LL, 0LL, a8) < 0 )
      return 0xFFFFFFFFLL;
  }
  else if ( a8 )
  {
    snprintf(s, 0x400uLL, "%s", a8);
  }
  v10 = strlen(s);
  if ( (int)passphrase_to_key((__int64)s, v10, a4, (__int64)v23, a3) < 0 )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)gcry_cipher_open(&v21, a1, a2, 0LL)
    || (unsigned int)gcry_cipher_setkey(v21, v23, a3)
    || (unsigned int)gcry_cipher_setiv(v21, a4, a5)
    || (v11 = ssh_buffer_get_len(a6), (src = calloc(v11, 1uLL)) == 0LL)
    || (v12 = (unsigned int)ssh_buffer_get_len(a6),
        v13 = ssh_buffer_get(a6),
        v14 = ssh_buffer_get_len(a6),
        (unsigned int)gcry_cipher_decrypt(v21, src, v14, v13, v12)) )
  {
    gcry_cipher_close(v21);
    return 0xFFFFFFFFLL;
  }
  else
  {
    len = (unsigned int)ssh_buffer_get_len(a6);
    v16 = (void *)ssh_buffer_get(a6);
    memcpy(v16, src, len);
    if ( src )
    {
      free(src);
      src = 0LL;
    }
    gcry_cipher_close(v21);
    return 0LL;
  }
}
// D900: using guessed type __int64 __fastcall gcry_cipher_setkey(_QWORD, _QWORD, _QWORD);
// DC70: using guessed type __int64 __fastcall gcry_cipher_open(_QWORD, _QWORD, _QWORD, _QWORD);
// DDF0: using guessed type __int64 __fastcall gcry_cipher_setiv(_QWORD, _QWORD, _QWORD);
// DF10: using guessed type __int64 __fastcall gcry_cipher_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// E030: using guessed type __int64 __fastcall gcry_cipher_close(_QWORD);

//----- (0000000000039FF9) ----------------------------------------------------
__int64 __fastcall privatekey_dek_header(
        const char *a1,
        unsigned int a2,
        _DWORD *a3,
        _DWORD *a4,
        _DWORD *a5,
        void **a6,
        int *a7)
{
  unsigned int v12; // [rsp+3Ch] [rbp-4h]

  if ( a2 > 0xD && !strncmp("DES-EDE3-CBC", a1, 0xCuLL) )
  {
    *a3 = 2;
    v12 = 13;
    *a4 = 3;
    *a5 = 24;
    *a7 = 8;
  }
  else if ( a2 > 8 && !strncmp("DES-CBC", a1, 7uLL) )
  {
    *a3 = 302;
    v12 = 8;
    *a4 = 3;
    *a5 = 8;
    *a7 = 8;
  }
  else if ( a2 > 0xC && !strncmp("AES-128-CBC", a1, 0xBuLL) )
  {
    *a3 = 7;
    v12 = 12;
    *a4 = 3;
    *a5 = 16;
    *a7 = 16;
  }
  else if ( a2 > 0xC && !strncmp("AES-192-CBC", a1, 0xBuLL) )
  {
    *a3 = 8;
    v12 = 12;
    *a4 = 3;
    *a5 = 24;
    *a7 = 16;
  }
  else
  {
    if ( a2 <= 0xC || strncmp("AES-256-CBC", a1, 0xBuLL) )
      return 0xFFFFFFFFLL;
    *a3 = 9;
    v12 = 12;
    *a4 = 3;
    *a5 = 32;
    *a7 = 16;
  }
  *a6 = malloc((unsigned int)*a7);
  if ( *a6 )
    return load_iv((__int64)&a1[v12], *a6, *a7);
  else
    return 0xFFFFFFFFLL;
}

//----- (000000000003A21C) ----------------------------------------------------
void *__fastcall privatekey_string_to_buffer(
        char *a1,
        int a2,
        int (__fastcall *a3)(__int64, char *, __int64, _QWORD, _QWORD, const char *),
        const char *a4,
        __int64 a5)
{
  const char *v6; // rax
  unsigned int v10; // [rsp+34h] [rbp-4Ch] BYREF
  unsigned int v11; // [rsp+38h] [rbp-48h] BYREF
  unsigned int v12; // [rsp+3Ch] [rbp-44h] BYREF
  unsigned int v13; // [rsp+40h] [rbp-40h] BYREF
  signed int i; // [rsp+44h] [rbp-3Ch]
  unsigned int n; // [rsp+48h] [rbp-38h]
  unsigned int n_4; // [rsp+4Ch] [rbp-34h]
  void *ptr; // [rsp+50h] [rbp-30h] BYREF
  char *s1; // [rsp+58h] [rbp-28h]
  char *s; // [rsp+60h] [rbp-20h]
  char *s2; // [rsp+68h] [rbp-18h]
  void *v21; // [rsp+70h] [rbp-10h]
  void *v22; // [rsp+78h] [rbp-8h]

  v22 = 0LL;
  ptr = 0LL;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v21 = ssh_buffer_new();
  if ( !v21 )
    return 0LL;
  switch ( a2 )
  {
    case 2:
      s = "-----BEGIN RSA PRIVATE KEY-----";
      s2 = "-----END RSA PRIVATE KEY-----";
      break;
    case 4:
      s = "-----BEGIN EC PRIVATE KEY-----";
      s2 = "-----END EC PRIVATE KEY-----";
      break;
    case 1:
      s = "-----BEGIN DSA PRIVATE KEY-----";
      s2 = "-----END DSA PRIVATE KEY-----";
      break;
    default:
      goto LABEL_80;
  }
  n = strlen(s);
  n_4 = strlen(s2);
  s1 = a1;
  for ( i = 0; s1[i] == 10 || s1[i] == 13; ++i )
    ;
  if ( s1[i] )
  {
    s1 += i;
    for ( i = 0; s1[i] && s1[i] != 10 && s1[i] != 13; ++i )
      ;
  }
  else
  {
    i = -1;
  }
  while ( i > 0 && strncmp(s1, s, n) )
  {
    while ( s1[i] == 10 || s1[i] == 13 )
      ++i;
    if ( s1[i] )
    {
      s1 += i;
      for ( i = 0; s1[i] && s1[i] != 10 && s1[i] != 13; ++i )
        ;
    }
    else
    {
      i = -1;
    }
  }
  if ( i < 0 )
    return 0LL;
  while ( s1[i] == 10 || s1[i] == 13 )
    ++i;
  if ( s1[i] )
  {
    s1 += i;
    for ( i = 0; s1[i] && s1[i] != 10 && s1[i] != 13; ++i )
      ;
  }
  else
  {
    i = -1;
  }
  if ( i <= 11 || strncmp("Proc-Type: 4,ENCRYPTED", s1, 0xBuLL) )
  {
    if ( i <= 0 || (int)ssh_buffer_add_data((__int64)v21, s1, i) >= 0 )
      goto LABEL_82;
LABEL_80:
    ssh_buffer_free((__int64)v21);
    return 0LL;
  }
  while ( s1[i] == 10 || s1[i] == 13 )
    ++i;
  if ( s1[i] )
  {
    s1 += i;
    for ( i = 0; s1[i] && s1[i] != 10 && s1[i] != 13; ++i )
      ;
  }
  else
  {
    i = -1;
  }
  if ( i <= 10 || strncmp("DEK-Info: ", s1, 0xAuLL) )
    goto LABEL_80;
  s1 += 10;
  for ( i = 0; s1[i] == 10 || s1[i] == 13; ++i )
    ;
  if ( s1[i] )
  {
    s1 += i;
    for ( i = 0; s1[i] && s1[i] != 10 && s1[i] != 13; ++i )
      ;
  }
  else
  {
    i = -1;
  }
  if ( (int)privatekey_dek_header(s1, i, &v12, &v13, &v10, &ptr, (int *)&v11) < 0 )
  {
    ssh_buffer_free((__int64)v21);
    if ( ptr )
    {
      free(ptr);
      ptr = 0LL;
    }
    return 0LL;
  }
LABEL_82:
  while ( s1[i] == 10 || s1[i] == 13 )
    ++i;
  if ( s1[i] )
  {
    s1 += i;
    for ( i = 0; s1[i] && s1[i] != 10 && s1[i] != 13; ++i )
      ;
  }
  else
  {
    i = -1;
  }
  while ( 1 )
  {
    if ( i <= 0 || !strncmp(s1, s2, n_4) )
    {
      if ( i != -1 && !strncmp(s1, s2, n_4) )
      {
        if ( (int)ssh_buffer_add_data((__int64)v21, &unk_7392E, 1u) >= 0 )
        {
          v6 = (const char *)ssh_buffer_get((__int64)v21);
          v22 = base64_to_bin(v6);
          ssh_buffer_free((__int64)v21);
          if ( v22 )
          {
            if ( v12 && (int)privatekey_decrypt(v12, v13, v10, (__int64)ptr, v11, (__int64)v22, a3, a4, a5) < 0 )
            {
              ssh_buffer_free((__int64)v22);
              if ( ptr )
              {
                free(ptr);
                ptr = 0LL;
              }
              return 0LL;
            }
            else
            {
              if ( ptr )
              {
                free(ptr);
                ptr = 0LL;
              }
              return v22;
            }
          }
          else
          {
            if ( ptr )
            {
              free(ptr);
              ptr = 0LL;
            }
            return 0LL;
          }
        }
        else
        {
          ssh_buffer_free((__int64)v21);
          if ( ptr )
          {
            free(ptr);
            ptr = 0LL;
          }
          return 0LL;
        }
      }
      else
      {
        ssh_buffer_free((__int64)v21);
        if ( ptr )
        {
          free(ptr);
          ptr = 0LL;
        }
        return 0LL;
      }
    }
    if ( (int)ssh_buffer_add_data((__int64)v21, s1, i) < 0 )
      break;
    while ( s1[i] == 10 || s1[i] == 13 )
      ++i;
    if ( s1[i] )
    {
      s1 += i;
      for ( i = 0; s1[i] && s1[i] != 10 && s1[i] != 13; ++i )
        ;
    }
    else
    {
      i = -1;
    }
  }
  ssh_buffer_free((__int64)v21);
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  return 0LL;
}
// 3A749: conditional instruction was optimized away because %ptr.8==0
// 3A79E: conditional instruction was optimized away because %ptr.8==0

//----- (000000000003AAFB) ----------------------------------------------------
_BOOL8 __fastcall b64decode_rsa_privatekey(
        char *a1,
        __int64 a2,
        int (__fastcall *a3)(__int64, char *, __int64, _QWORD, _QWORD, const char *),
        const char *a4,
        __int64 a5)
{
  __int64 v6; // r15
  __int64 v7; // r14
  __int64 v8; // r13
  __int64 v9; // r12
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // [rsp+8h] [rbp-E8h]
  __int64 v13; // [rsp+10h] [rbp-E0h]
  __int64 v14; // [rsp+18h] [rbp-D8h]
  __int64 v15; // [rsp+20h] [rbp-D0h]
  __int64 v16; // [rsp+28h] [rbp-C8h]
  __int64 v17; // [rsp+30h] [rbp-C0h]
  _BOOL4 v18; // [rsp+64h] [rbp-8Ch]
  uint32_t *v19; // [rsp+68h] [rbp-88h]
  uint32_t *v20; // [rsp+70h] [rbp-80h]
  uint32_t *v21; // [rsp+78h] [rbp-78h]
  uint32_t *v22; // [rsp+80h] [rbp-70h]
  uint32_t *v23; // [rsp+88h] [rbp-68h]
  _BYTE *v24; // [rsp+90h] [rbp-60h]
  _BYTE *v25; // [rsp+98h] [rbp-58h]
  uint32_t *v26; // [rsp+A0h] [rbp-50h]
  _BYTE *v27; // [rsp+A8h] [rbp-48h]
  void *v28; // [rsp+B0h] [rbp-40h]
  _BYTE *v29; // [rsp+B8h] [rbp-38h]

  v28 = privatekey_string_to_buffer(a1, 2, a3, a4, a5);
  if ( !v28 )
    return 0LL;
  if ( (unsigned int)asn1_check_sequence((__int64)v28) && (v27 = asn1_get_int((__int64)v28)) != 0LL )
  {
    v29 = (_BYTE *)ssh_string_data((__int64)v27);
    if ( ssh_string_len((uint32_t *)v27) == 1 && !*v29 )
    {
      v19 = (uint32_t *)asn1_get_int((__int64)v28);
      v20 = (uint32_t *)asn1_get_int((__int64)v28);
      v21 = (uint32_t *)asn1_get_int((__int64)v28);
      v23 = (uint32_t *)asn1_get_int((__int64)v28);
      v22 = (uint32_t *)asn1_get_int((__int64)v28);
      v24 = asn1_get_int((__int64)v28);
      v25 = asn1_get_int((__int64)v28);
      v26 = (uint32_t *)asn1_get_int((__int64)v28);
      ssh_buffer_free((__int64)v28);
      if ( v19 && v20 && v21 && v22 && v23 && v24 && v25 && v26 )
      {
        v17 = ssh_string_data((__int64)v26);
        v16 = ssh_string_len(v26);
        v15 = ssh_string_data((__int64)v23);
        v14 = ssh_string_len(v23);
        v6 = ssh_string_data((__int64)v22);
        v7 = ssh_string_len(v22);
        v8 = ssh_string_data((__int64)v21);
        v9 = ssh_string_len(v21);
        v10 = ssh_string_data((__int64)v20);
        v13 = ssh_string_len(v20);
        v12 = ssh_string_data((__int64)v19);
        v11 = ssh_string_len(v19);
        v18 = gcry_sexp_build(
                a2,
                0LL,
                "(private-key(rsa(n %b)(e %b)(d %b)(p %b)(q %b)(u %b)))",
                v11,
                v12,
                v13,
                v10,
                v9,
                v8,
                v7,
                v6,
                v14,
                v15,
                v16,
                v17) == 0;
      }
      else
      {
        v18 = 0;
      }
      ssh_string_burn(v19);
      ssh_string_free(v19);
      ssh_string_burn(v20);
      ssh_string_free(v20);
      ssh_string_burn(v21);
      ssh_string_free(v21);
      ssh_string_burn(v22);
      ssh_string_free(v22);
      ssh_string_burn(v23);
      ssh_string_free(v23);
      ssh_string_free(v24);
      ssh_string_free(v25);
      ssh_string_burn(v26);
      ssh_string_free(v26);
      ssh_string_free(v27);
      return v18;
    }
    else
    {
      ssh_string_free(v27);
      ssh_buffer_free((__int64)v28);
      return 0LL;
    }
  }
  else
  {
    ssh_buffer_free((__int64)v28);
    return 0LL;
  }
}
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);

//----- (000000000003AF54) ----------------------------------------------------
_BOOL8 __fastcall b64decode_dsa_privatekey(
        char *a1,
        __int64 a2,
        int (__fastcall *a3)(__int64, char *, __int64, _QWORD, _QWORD, const char *),
        const char *a4,
        __int64 a5)
{
  __int64 v6; // r15
  __int64 v7; // r14
  __int64 v8; // r13
  __int64 v9; // r12
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // [rsp+8h] [rbp-C8h]
  __int64 v13; // [rsp+10h] [rbp-C0h]
  __int64 v14; // [rsp+18h] [rbp-B8h]
  __int64 v15; // [rsp+20h] [rbp-B0h]
  _BOOL4 v16; // [rsp+5Ch] [rbp-74h]
  void *v17; // [rsp+60h] [rbp-70h]
  uint32_t *v18; // [rsp+68h] [rbp-68h]
  uint32_t *v19; // [rsp+70h] [rbp-60h]
  uint32_t *v20; // [rsp+78h] [rbp-58h]
  uint32_t *v21; // [rsp+80h] [rbp-50h]
  uint32_t *v22; // [rsp+88h] [rbp-48h]
  _BYTE *v23; // [rsp+90h] [rbp-40h]
  _BYTE *v24; // [rsp+98h] [rbp-38h]

  v17 = privatekey_string_to_buffer(a1, 1, a3, a4, a5);
  if ( !v17 )
    return 0LL;
  if ( (unsigned int)asn1_check_sequence((__int64)v17) && (v23 = asn1_get_int((__int64)v17)) != 0LL )
  {
    v24 = (_BYTE *)ssh_string_data((__int64)v23);
    if ( ssh_string_len((uint32_t *)v23) == 1 && !*v24 )
    {
      v18 = (uint32_t *)asn1_get_int((__int64)v17);
      v19 = (uint32_t *)asn1_get_int((__int64)v17);
      v20 = (uint32_t *)asn1_get_int((__int64)v17);
      v21 = (uint32_t *)asn1_get_int((__int64)v17);
      v22 = (uint32_t *)asn1_get_int((__int64)v17);
      ssh_buffer_free((__int64)v17);
      if ( v18 && v19 && v20 && v21 && v22 )
      {
        v15 = ssh_string_data((__int64)v22);
        v14 = ssh_string_len(v22);
        v6 = ssh_string_data((__int64)v21);
        v7 = ssh_string_len(v21);
        v8 = ssh_string_data((__int64)v20);
        v9 = ssh_string_len(v20);
        v10 = ssh_string_data((__int64)v19);
        v13 = ssh_string_len(v19);
        v12 = ssh_string_data((__int64)v18);
        v11 = ssh_string_len(v18);
        v16 = gcry_sexp_build(
                a2,
                0LL,
                "(private-key(dsa(p %b)(q %b)(g %b)(y %b)(x %b)))",
                v11,
                v12,
                v13,
                v10,
                v9,
                v8,
                v7,
                v6,
                v14,
                v15) == 0;
      }
      else
      {
        v16 = 0;
      }
      ssh_string_burn(v18);
      ssh_string_free(v18);
      ssh_string_burn(v19);
      ssh_string_free(v19);
      ssh_string_burn(v20);
      ssh_string_free(v20);
      ssh_string_burn(v21);
      ssh_string_free(v21);
      ssh_string_burn(v22);
      ssh_string_free(v22);
      ssh_string_free(v23);
      return v16;
    }
    else
    {
      ssh_string_free(v23);
      ssh_buffer_free((__int64)v17);
      return 0LL;
    }
  }
  else
  {
    ssh_buffer_free((__int64)v17);
    return 0LL;
  }
}
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);

//----- (000000000003B2CD) ----------------------------------------------------
__int64 __fastcall pki_key_ecdsa_to_nid(__int64 a1)
{
  size_t n; // [rsp+18h] [rbp-18h] BYREF
  __int64 token; // [rsp+20h] [rbp-10h]
  void *s2; // [rsp+28h] [rbp-8h]

  token = gcry_sexp_find_token(a1, "curve", 0LL);
  if ( !token )
    return 0xFFFFFFFFLL;
  s2 = (void *)gcry_sexp_nth_data(token, 1LL, &n);
  if ( n != 10 )
    goto LABEL_10;
  if ( !memcmp("NIST P-256", s2, 0xAuLL) )
  {
    gcry_sexp_release(token);
    return 0LL;
  }
  if ( !memcmp("NIST P-384", s2, n) )
  {
    gcry_sexp_release(token);
    return 1LL;
  }
  if ( !memcmp("NIST P-521", s2, n) )
  {
    gcry_sexp_release(token);
    return 2LL;
  }
  else
  {
LABEL_10:
    gcry_sexp_release(token);
    return 0xFFFFFFFFLL;
  }
}
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// DAA0: using guessed type __int64 __fastcall gcry_sexp_nth_data(_QWORD, _QWORD, _QWORD);
// DB80: using guessed type __int64 __fastcall gcry_sexp_find_token(_QWORD, _QWORD, _QWORD);

//----- (000000000003B3D9) ----------------------------------------------------
const char *__fastcall pki_key_ecdsa_nid_to_gcrypt_name(int a1)
{
  if ( a1 == 1 )
    return "NIST P-384";
  if ( a1 == 2 )
    return "NIST P-521";
  if ( a1 )
    return "unknown";
  return "NIST P-256";
}

//----- (000000000003B415) ----------------------------------------------------
const char *__fastcall pki_key_ecdsa_nid_to_name(int a1)
{
  if ( a1 == 1 )
    return "ecdsa-sha2-nistp384";
  if ( a1 == 2 )
    return "ecdsa-sha2-nistp521";
  if ( a1 )
    return "unknown";
  return "ecdsa-sha2-nistp256";
}

//----- (000000000003B451) ----------------------------------------------------
const char *__fastcall pki_key_ecdsa_nid_to_char(int a1)
{
  if ( a1 == 1 )
    return "nistp384";
  if ( a1 == 2 )
    return "nistp521";
  if ( a1 )
    return "unknown";
  return "nistp256";
}

//----- (000000000003B48E) ----------------------------------------------------
__int64 __fastcall pki_key_ecdsa_nid_from_name(const char *a1)
{
  if ( !strcmp(a1, "nistp256") )
    return 0LL;
  if ( !strcmp(a1, "nistp384") )
    return 1LL;
  if ( !strcmp(a1, "nistp521") )
    return 2LL;
  return 0xFFFFFFFFLL;
}

//----- (000000000003B50A) ----------------------------------------------------
__int64 __fastcall asn1_oi_to_nid(uint32_t *a1)
{
  const void *v1; // rbx
  const void *v2; // rax
  __int64 n; // [rsp+18h] [rbp-18h]

  n = ssh_string_len(a1);
  for ( e_9071 = (__int64)&mapping_9072; *(_QWORD *)(e_9071 + 8); e_9071 += 24LL )
  {
    if ( *(_QWORD *)(e_9071 + 8) == n )
    {
      v1 = *(const void **)(e_9071 + 16);
      v2 = (const void *)ssh_string_data((__int64)a1);
      if ( !memcmp(v2, v1, n) )
        return *(unsigned int *)e_9071;
    }
  }
  return 0xFFFFFFFFLL;
}
// 281A68: using guessed type __int64 e_9071;

//----- (000000000003B5B1) ----------------------------------------------------
_BOOL8 __fastcall b64decode_ecdsa_privatekey(
        char *a1,
        __int64 a2,
        int (__fastcall *a3)(__int64, char *, __int64, _QWORD, _QWORD, const char *),
        const char *a4,
        __int64 a5)
{
  __int64 v5; // r12
  __int64 v6; // rbx
  __int64 v7; // r14
  __int64 v8; // r13
  const char *v9; // rax
  _BOOL4 v11; // [rsp+30h] [rbp-60h]
  int v12; // [rsp+3Ch] [rbp-54h]
  uint32_t *v13; // [rsp+40h] [rbp-50h]
  uint32_t *v14; // [rsp+48h] [rbp-48h]
  uint32_t *v15; // [rsp+50h] [rbp-40h]
  uint32_t *bit_string; // [rsp+58h] [rbp-38h]
  void *v17; // [rsp+60h] [rbp-30h]
  _BYTE *v18; // [rsp+68h] [rbp-28h]

  v13 = 0LL;
  v14 = 0LL;
  v15 = 0LL;
  bit_string = 0LL;
  v11 = 0;
  v17 = privatekey_string_to_buffer(a1, 4, a3, a4, a5);
  if ( v17 )
  {
    if ( (unsigned int)asn1_check_sequence((__int64)v17) )
    {
      v13 = (uint32_t *)asn1_get_int((__int64)v17);
      if ( v13 )
      {
        v18 = (_BYTE *)ssh_string_data((__int64)v13);
        if ( ssh_string_len(v13) == 1 && *v18 == 1 )
        {
          v14 = (uint32_t *)asn1_get((__int64)v17, 4);
          if ( (unsigned int)asn1_check_tag((__int64)v17, 160) )
          {
            v15 = (uint32_t *)asn1_get((__int64)v17, 6);
            v12 = asn1_oi_to_nid(v15);
            if ( (unsigned int)asn1_check_tag((__int64)v17, 161) )
            {
              bit_string = (uint32_t *)asn1_get_bit_string((__int64)v17);
              if ( v14 )
              {
                if ( v15 && v12 != -1 && bit_string )
                {
                  v5 = ssh_string_data((__int64)bit_string);
                  v6 = ssh_string_len(bit_string);
                  v7 = ssh_string_data((__int64)v14);
                  v8 = ssh_string_len(v14);
                  v9 = pki_key_ecdsa_nid_to_gcrypt_name(v12);
                  v11 = gcry_sexp_build(a2, 0LL, "(private-key(ecdsa(curve %s)(d %b)(q %b)))", v9, v8, v7, v6, v5) == 0;
                }
              }
            }
          }
        }
      }
    }
  }
  ssh_buffer_free((__int64)v17);
  ssh_string_free(v13);
  ssh_string_burn(v14);
  ssh_string_free(v14);
  ssh_string_free(v15);
  ssh_string_burn(bit_string);
  ssh_string_free(bit_string);
  return v11;
}
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);

//----- (000000000003B84C) ----------------------------------------------------
__int64 pki_private_key_to_pem()
{
  return 0LL;
}
// 3B84C: using guessed type __int64 pki_private_key_to_pem();

//----- (000000000003B867) ----------------------------------------------------
__int64 *__fastcall pki_private_key_from_base64(
        char *a1,
        const char *a2,
        int (__fastcall *a3)(__int64, char *, __int64, _QWORD, _QWORD, const char *),
        const char *a4)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  int v17; // eax
  const char *v18; // rax
  _BOOL4 v21; // [rsp+28h] [rbp-28h]
  _BOOL4 v22; // [rsp+28h] [rbp-28h]
  _BOOL4 v23; // [rsp+28h] [rbp-28h]
  _BYTE v24[12]; // [rsp+2Ch] [rbp-24h] BYREF
  __int64 v25; // [rsp+38h] [rbp-18h] BYREF
  __int64 v26; // [rsp+40h] [rbp-10h] BYREF
  __int64 *v27; // [rsp+48h] [rbp-8h]

  *(_DWORD *)&v24[8] = 0;
  v25 = 0LL;
  v26 = 0LL;
  v27 = 0LL;
  *(_QWORD *)v24 = (unsigned int)pki_privatekey_type_from_string(a1);
  switch ( *(_DWORD *)v24 )
  {
    case 0:
      ssh_log(1, "pki_private_key_from_base64", "Unknown or invalid private key.", v4, v5, v6);
      return 0LL;
    case 2:
      if ( a2 )
      {
        v22 = b64decode_rsa_privatekey(a1, (__int64)&v25, 0LL, a2, 0LL);
      }
      else if ( a3 )
      {
        v22 = b64decode_rsa_privatekey(a1, (__int64)&v25, a3, a4, (__int64)"Passphrase for private key:");
      }
      else
      {
        v22 = b64decode_rsa_privatekey(a1, (__int64)&v25, 0LL, 0LL, 0LL);
      }
      if ( !v22 )
      {
        ssh_log(1, "pki_private_key_from_base64", "Parsing private key", v11, v12, v13);
        goto LABEL_32;
      }
      break;
    case 4:
      if ( a2 )
      {
        v23 = b64decode_ecdsa_privatekey(a1, (__int64)&v26, 0LL, a2, 0LL);
      }
      else if ( a3 )
      {
        v23 = b64decode_ecdsa_privatekey(a1, (__int64)&v26, a3, a4, (__int64)"Passphrase for private key:");
      }
      else
      {
        v23 = b64decode_ecdsa_privatekey(a1, (__int64)&v26, 0LL, 0LL, 0LL);
      }
      if ( !v23 )
      {
        ssh_log(1, "pki_private_key_from_base64", "Parsing private key", v14, v15, v16);
        goto LABEL_32;
      }
      break;
    case 1:
      if ( a2 )
      {
        v21 = b64decode_dsa_privatekey(a1, (__int64)&v24[4], 0LL, a2, 0LL);
      }
      else if ( a3 )
      {
        v21 = b64decode_dsa_privatekey(a1, (__int64)&v24[4], a3, a4, (__int64)"Passphrase for private key:");
      }
      else
      {
        v21 = b64decode_dsa_privatekey(a1, (__int64)&v24[4], 0LL, 0LL, 0LL);
      }
      if ( !v21 )
      {
        ssh_log(1, "pki_private_key_from_base64", "Parsing private key", v8, v9, v10);
LABEL_32:
        ssh_key_free(v27);
        gcry_sexp_release(*(_QWORD *)&v24[4]);
        gcry_sexp_release(v25);
        gcry_sexp_release(v26);
        return 0LL;
      }
      break;
    default:
      ssh_log(1, "pki_private_key_from_base64", "Unkown or invalid private key type %d", *(unsigned int *)v24, v5, v6);
      return 0LL;
  }
  v27 = (__int64 *)ssh_key_new();
  if ( !v27 )
    goto LABEL_32;
  *(_DWORD *)v27 = *(_DWORD *)v24;
  v27[1] = (__int64)ssh_key_type_to_char(*(int *)v24);
  *((_DWORD *)v27 + 1) = 3;
  v27[3] = *(_QWORD *)&v24[4];
  v27[4] = v25;
  v27[5] = v26;
  if ( *(_DWORD *)v27 == 4 )
  {
    v17 = pki_key_ecdsa_to_nid(v27[5]);
    *((_DWORD *)v27 + 4) = v17;
    v18 = pki_key_ecdsa_nid_to_name(*((_DWORD *)v27 + 4));
    v27[1] = (__int64)v18;
  }
  return v27;
}
// 3B8CC: variable 'v4' is possibly undefined
// 3B8CC: variable 'v5' is possibly undefined
// 3B8CC: variable 'v6' is possibly undefined
// 3B997: variable 'v8' is possibly undefined
// 3B997: variable 'v9' is possibly undefined
// 3B997: variable 'v10' is possibly undefined
// 3BA3F: variable 'v11' is possibly undefined
// 3BA3F: variable 'v12' is possibly undefined
// 3BA3F: variable 'v13' is possibly undefined
// 3BAE3: variable 'v14' is possibly undefined
// 3BAE3: variable 'v15' is possibly undefined
// 3BAE3: variable 'v16' is possibly undefined
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);

//----- (000000000003BBFC) ----------------------------------------------------
__int64 __fastcall pki_pubkey_build_dss(__int64 a1, uint32_t *a2, uint32_t *a3, uint32_t *a4, uint32_t *a5)
{
  __int64 v5; // r15
  __int64 v6; // r14
  __int64 v7; // r13
  __int64 v8; // r12
  __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v12; // [rsp+8h] [rbp-68h]
  __int64 v13; // [rsp+10h] [rbp-60h]

  v5 = ssh_string_data((__int64)a5);
  v6 = ssh_string_len(a5);
  v7 = ssh_string_data((__int64)a4);
  v8 = ssh_string_len(a4);
  v9 = ssh_string_data((__int64)a3);
  v13 = ssh_string_len(a3);
  v12 = ssh_string_data((__int64)a2);
  v10 = ssh_string_len(a2);
  gcry_sexp_build(a1 + 24, 0LL, "(public-key(dsa(p %b)(q %b)(g %b)(y %b)))", v10, v12, v13, v9, v8, v7, v6, v5);
  if ( *(_QWORD *)(a1 + 24) )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);

//----- (000000000003BD00) ----------------------------------------------------
__int64 __fastcall pki_pubkey_build_rsa(__int64 a1, uint32_t *a2, uint32_t *a3)
{
  __int64 v3; // rbx
  __int64 v4; // r13
  __int64 v5; // r12
  __int64 v6; // rax

  v3 = ssh_string_data((__int64)a2);
  v4 = ssh_string_len(a2);
  v5 = ssh_string_data((__int64)a3);
  v6 = ssh_string_len(a3);
  gcry_sexp_build(a1 + 32, 0LL, "(public-key(rsa(n %b)(e %b)))", v6, v5, v4, v3);
  if ( *(_QWORD *)(a1 + 32) )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);

//----- (000000000003BDAC) ----------------------------------------------------
__int64 __fastcall pki_pubkey_build_ecdsa(__int64 a1, int a2, uint32_t *a3)
{
  __int64 v3; // r12
  __int64 v4; // rbx
  const char *v5; // rax

  *(_DWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 8) = pki_key_ecdsa_nid_to_name(a2);
  v3 = ssh_string_data((__int64)a3);
  v4 = ssh_string_len(a3);
  v5 = pki_key_ecdsa_nid_to_gcrypt_name(a2);
  if ( (unsigned int)gcry_sexp_build(a1 + 40, 0LL, "(public-key(ecdsa(curve %s)(q %b)))", v5, v4, v3) )
    return 0xFFFFFFFFLL;
  else
    return 0LL;
}
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);

//----- (000000000003BE54) ----------------------------------------------------
_QWORD *__fastcall pki_key_dup(__int64 a1, int a2)
{
  unsigned int v3; // eax
  int v4; // [rsp+10h] [rbp-60h]
  __int64 v5; // [rsp+18h] [rbp-58h] BYREF
  __int64 v6; // [rsp+20h] [rbp-50h] BYREF
  __int64 v7; // [rsp+28h] [rbp-48h] BYREF
  __int64 v8; // [rsp+30h] [rbp-40h]
  __int64 v9; // [rsp+38h] [rbp-38h]
  __int64 v10; // [rsp+40h] [rbp-30h] BYREF
  __int64 v11; // [rsp+48h] [rbp-28h] BYREF
  __int64 v12; // [rsp+50h] [rbp-20h] BYREF
  __int64 v13; // [rsp+58h] [rbp-18h]
  _QWORD *v14; // [rsp+60h] [rbp-10h]
  const wchar_t *token; // [rsp+68h] [rbp-8h]

  v4 = 0;
  v5 = 0LL;
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  v11 = 0LL;
  v12 = 0LL;
  v13 = 0LL;
  token = 0LL;
  v14 = ssh_key_new();
  if ( !v14 )
    return 0LL;
  *(_DWORD *)v14 = *(_DWORD *)a1;
  v14[1] = *(_QWORD *)(a1 + 8);
  if ( a2 )
    *((_DWORD *)v14 + 1) = 1;
  else
    *((_DWORD *)v14 + 1) = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 2 )
  {
    v4 = gcry_sexp_extract_param(*(_QWORD *)(a1 + 32), 0LL, "ned?p?q?u?", &v11, &v10, &v12);
    if ( !v4 )
    {
      if ( a2 || (*(_DWORD *)(a1 + 4) & 2) == 0 )
        v4 = gcry_sexp_build(v14 + 4, 0LL, "(public-key(rsa(n %m)(e %m)))", v11, v10);
      else
        v4 = gcry_sexp_build(
               v14 + 4,
               0LL,
               "(private-key(rsa(n %m)(e %m)(d %m)(p %m)(q %m)(u %m)))",
               v11,
               v10,
               v12,
               v5,
               v6,
               v13);
    }
  }
  else if ( v3 > 2 )
  {
    if ( v3 == 4 )
    {
      *((_DWORD *)v14 + 4) = *(_DWORD *)(a1 + 16);
      v4 = gcry_sexp_extract_param(*(_QWORD *)(a1 + 40), 0LL, "qd?", &v6, &v12, 0LL);
      if ( !v4 )
      {
        token = (const wchar_t *)gcry_sexp_find_token(*(_QWORD *)(a1 + 40), "curve", 0LL);
        if ( token )
        {
          if ( a2 || (*(_DWORD *)(a1 + 4) & 2) == 0 )
            v4 = gcry_sexp_build(v14 + 5, 0LL, "(private-key(ecdsa %S (q %m)))", token);
          else
            v4 = gcry_sexp_build(v14 + 5, 0LL, "(private-key(ecdsa %S (d %m)(q %m)))", token);
        }
      }
    }
    else if ( v3 != 5 || (unsigned int)pki_ed25519_key_dup((__int64)v14, a1) )
    {
      goto LABEL_24;
    }
  }
  else
  {
    if ( v3 != 1 )
    {
LABEL_24:
      ssh_key_free(v14);
      return 0LL;
    }
    v4 = gcry_sexp_extract_param(*(_QWORD *)(a1 + 24), 0LL, "pqgyx?", &v5, &v6, &v7);
    if ( !v4 )
    {
      if ( a2 || (*(_DWORD *)(a1 + 4) & 2) == 0 )
        v4 = gcry_sexp_build(v14 + 3, 0LL, "(public-key(dsa(p %m)(q %m)(g %m)(y %m)))", v5, v6, v7, v8);
      else
        v4 = gcry_sexp_build(v14 + 3, 0LL, "(private-key(dsa(p %m)(q %m)(g %m)(y %m)(x %m)))", v5, v6, v7, v8, v9);
    }
  }
  if ( v4 )
  {
    ssh_key_free(v14);
    v14 = 0LL;
  }
  gcry_mpi_release(v5);
  gcry_mpi_release(v6);
  gcry_mpi_release(v7);
  gcry_mpi_release(v8);
  gcry_mpi_release(v9);
  gcry_mpi_release(v10);
  gcry_mpi_release(v11);
  gcry_mpi_release(v12);
  gcry_mpi_release(v13);
  gcry_sexp_release(token);
  return v14;
}
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// DB80: using guessed type __int64 __fastcall gcry_sexp_find_token(_QWORD, _QWORD, _QWORD);
// DE30: using guessed type __int64 __fastcall gcry_mpi_release(_QWORD);
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);

//----- (000000000003C317) ----------------------------------------------------
__int64 __fastcall pki_key_generate(__int64 a1, unsigned int a2, const char *a3, int a4)
{
  int v6; // [rsp+24h] [rbp-Ch]
  __int64 v7; // [rsp+28h] [rbp-8h] BYREF

  if ( (unsigned int)gcry_sexp_build(&v7, 0LL, "(genkey(%s(nbits %d)(transient-key)))", a3, a2) )
    return 0xFFFFFFFFLL;
  switch ( a4 )
  {
    case 2:
      v6 = gcry_pk_genkey(a1 + 32, v7);
      break;
    case 4:
      v6 = gcry_pk_genkey(a1 + 40, v7);
      break;
    case 1:
      v6 = gcry_pk_genkey(a1 + 24, v7);
      break;
    default:
      __assert_fail("! \"reached\"", "/usr/src/src/pki_gcrypt.c", 0x4EEu, "pki_key_generate");
  }
  gcry_sexp_release(v7);
  if ( v6 )
    return 0xFFFFFFFFLL;
  else
    return 0LL;
}
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);
// E020: using guessed type __int64 __fastcall gcry_pk_genkey(_QWORD, _QWORD);

//----- (000000000003C411) ----------------------------------------------------
__int64 __fastcall pki_key_generate_rsa(__int64 a1, unsigned int a2)
{
  return pki_key_generate(a1, a2, "rsa", 2);
}

//----- (000000000003C43D) ----------------------------------------------------
__int64 __fastcall pki_key_generate_dss(__int64 a1, unsigned int a2)
{
  return pki_key_generate(a1, a2, "dsa", 1);
}

//----- (000000000003C469) ----------------------------------------------------
__int64 __fastcall pki_key_generate_ecdsa(__int64 a1, unsigned int a2)
{
  int v3; // [rsp+1Ch] [rbp-4h]

  if ( a2 == 384 )
  {
    v3 = 1;
  }
  else if ( a2 == 512 )
  {
    v3 = 2;
  }
  else
  {
    v3 = 0;
  }
  *(_DWORD *)(a1 + 16) = v3;
  return pki_key_generate(a1, a2, "ecdsa", 4);
}

//----- (000000000003C4CB) ----------------------------------------------------
__int64 __fastcall bignum_cmp(__int64 a1, __int64 a2, __int64 a3)
{
  _BOOL4 v5; // [rsp+24h] [rbp-1Ch]
  __int64 token; // [rsp+28h] [rbp-18h]
  __int64 v7; // [rsp+28h] [rbp-18h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  __int64 v9; // [rsp+38h] [rbp-8h]

  token = gcry_sexp_find_token(a1, a3, 0LL);
  if ( !token )
    return 1LL;
  v8 = gcry_sexp_nth_mpi(token, 1LL, 5LL);
  gcry_sexp_release(token);
  if ( !v8 )
    return 1LL;
  v7 = gcry_sexp_find_token(a2, a3, 0LL);
  if ( v7 && (v9 = gcry_sexp_nth_mpi(v7, 1LL, 5LL), gcry_sexp_release(v7), v9) )
  {
    v5 = gcry_mpi_cmp(v8, v9) != 0;
    gcry_mpi_release(v8);
    gcry_mpi_release(v9);
    return v5;
  }
  else
  {
    gcry_mpi_release(v8);
    return 1LL;
  }
}
// 3C56B: conditional instruction was optimized away because %var_10.8!=0
// 3C5BD: conditional instruction was optimized away because %var_10.8!=0
// 3C5FD: conditional instruction was optimized away because %var_10.8!=0
// 3C618: conditional instruction was optimized away because %var_8.8!=0
// D7D0: using guessed type __int64 __fastcall gcry_mpi_cmp(_QWORD, _QWORD);
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// DB80: using guessed type __int64 __fastcall gcry_sexp_find_token(_QWORD, _QWORD, _QWORD);
// DC80: using guessed type __int64 __fastcall gcry_sexp_nth_mpi(_QWORD, _QWORD, _QWORD);
// DE30: using guessed type __int64 __fastcall gcry_mpi_release(_QWORD);

//----- (000000000003C633) ----------------------------------------------------
__int64 __fastcall pki_key_compare(__int64 a1, __int64 a2, int a3)
{
  __int64 result; // rax

  switch ( *(_DWORD *)a1 )
  {
    case 0:
    case 3:
    case 6:
    case 7:
      result = 1LL;
      break;
    case 1:
      if ( (unsigned int)bignum_cmp(*(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 24), (__int64)"p") )
      {
        result = 1LL;
      }
      else if ( (unsigned int)bignum_cmp(*(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 24), (__int64)aQgyxendu) )
      {
        result = 1LL;
      }
      else if ( (unsigned int)bignum_cmp(*(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 24), (__int64)&aQgyxendu[1]) )
      {
        result = 1LL;
      }
      else if ( (unsigned int)bignum_cmp(*(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 24), (__int64)&aQgyxendu[2]) )
      {
        result = 1LL;
      }
      else
      {
        if ( a3 != 1 || !(unsigned int)bignum_cmp(*(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 24), (__int64)&aQgyxendu[3]) )
          goto LABEL_34;
        result = 1LL;
      }
      break;
    case 2:
      if ( (unsigned int)bignum_cmp(*(_QWORD *)(a1 + 32), *(_QWORD *)(a2 + 32), (__int64)&aQgyxendu[4]) )
      {
        result = 1LL;
      }
      else if ( (unsigned int)bignum_cmp(*(_QWORD *)(a1 + 32), *(_QWORD *)(a2 + 32), (__int64)&aQgyxendu[5]) )
      {
        result = 1LL;
      }
      else
      {
        if ( a3 != 1 )
          goto LABEL_34;
        if ( (unsigned int)bignum_cmp(*(_QWORD *)(a1 + 32), *(_QWORD *)(a2 + 32), (__int64)&aQgyxendu[6]) )
        {
          result = 1LL;
        }
        else if ( (unsigned int)bignum_cmp(*(_QWORD *)(a1 + 32), *(_QWORD *)(a2 + 32), (__int64)"p") )
        {
          result = 1LL;
        }
        else if ( (unsigned int)bignum_cmp(*(_QWORD *)(a1 + 32), *(_QWORD *)(a2 + 32), (__int64)aQgyxendu) )
        {
          result = 1LL;
        }
        else
        {
          if ( !(unsigned int)bignum_cmp(*(_QWORD *)(a1 + 32), *(_QWORD *)(a2 + 32), (__int64)&aQgyxendu[7]) )
            goto LABEL_34;
          result = 1LL;
        }
      }
      break;
    case 4:
      if ( *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16) )
      {
        if ( (unsigned int)bignum_cmp(*(_QWORD *)(a1 + 40), *(_QWORD *)(a2 + 40), (__int64)aQgyxendu) )
        {
          result = 1LL;
        }
        else
        {
          if ( !(unsigned int)bignum_cmp(*(_QWORD *)(a1 + 40), *(_QWORD *)(a2 + 40), (__int64)&aQgyxendu[6]) )
            goto LABEL_34;
          result = 1LL;
        }
      }
      else
      {
        result = 1LL;
      }
      break;
    case 5:
      result = 0LL;
      break;
    default:
LABEL_34:
      result = 0LL;
      break;
  }
  return result;
}
// 73CB4: using guessed type __int16 aQgyxendu[8];

//----- (000000000003C936) ----------------------------------------------------
uint32_t *__fastcall pki_publickey_to_blob(__int64 a1)
{
  unsigned int v2; // eax
  const char *v3; // rax
  unsigned int len; // eax
  size_t v5; // rbx
  const void *v6; // rax
  int v7; // [rsp+1Ch] [rbp-54h]
  int v8; // [rsp+1Ch] [rbp-54h]
  uint32_t *v9; // [rsp+20h] [rbp-50h]
  uint32_t *mpi; // [rsp+28h] [rbp-48h]
  uint32_t *v11; // [rsp+30h] [rbp-40h]
  uint32_t *v12; // [rsp+38h] [rbp-38h]
  uint32_t *v13; // [rsp+40h] [rbp-30h]
  uint32_t *v14; // [rsp+48h] [rbp-28h]
  void *v15; // [rsp+50h] [rbp-20h]
  uint32_t *v16; // [rsp+58h] [rbp-18h]
  uint32_t *v17; // [rsp+58h] [rbp-18h]

  v9 = 0LL;
  mpi = 0LL;
  v11 = 0LL;
  v12 = 0LL;
  v13 = 0LL;
  v14 = 0LL;
  v15 = ssh_buffer_new();
  if ( !v15 )
    return 0LL;
  if ( *(_QWORD *)(a1 + 64) )
  {
    if ( (int)ssh_buffer_add_buffer((__int64)v15, *(_QWORD *)(a1 + 64)) < 0 )
    {
LABEL_35:
      ssh_buffer_free((__int64)v15);
      return 0LL;
    }
  }
  else
  {
    v16 = (uint32_t *)ssh_string_from_char(*(const char **)(a1 + 8));
    if ( !v16 )
      goto LABEL_35;
    v7 = ssh_buffer_add_ssh_string((__int64)v15, v16);
    ssh_string_free(v16);
    if ( v7 < 0 )
      goto LABEL_35;
    v2 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 == 2 )
    {
      mpi = ssh_sexp_extract_mpi(*(_QWORD *)(a1 + 32), (__int64)&aQgyxendu[4], 5u, 1u);
      if ( !mpi )
        goto LABEL_41;
      v11 = ssh_sexp_extract_mpi(*(_QWORD *)(a1 + 32), (__int64)&aQgyxendu[5], 5u, 1u);
      if ( !v11
        || (int)ssh_buffer_add_ssh_string((__int64)v15, mpi) < 0
        || (int)ssh_buffer_add_ssh_string((__int64)v15, v11) < 0 )
      {
        goto LABEL_41;
      }
      ssh_string_burn(mpi);
      ssh_string_free(mpi);
      ssh_string_burn(v11);
      ssh_string_free(v11);
    }
    else if ( v2 > 2 )
    {
      if ( v2 == 4 )
      {
        v3 = pki_key_ecdsa_nid_to_char(*(_DWORD *)(a1 + 16));
        v17 = (uint32_t *)ssh_string_from_char(v3);
        if ( !v17 )
          goto LABEL_35;
        v8 = ssh_buffer_add_ssh_string((__int64)v15, v17);
        ssh_string_free(v17);
        if ( v8 < 0 )
          goto LABEL_35;
        mpi = ssh_sexp_extract_mpi(*(_QWORD *)(a1 + 40), (__int64)aQgyxendu, 1u, 1u);
        if ( !mpi )
          goto LABEL_35;
        if ( (int)ssh_buffer_add_ssh_string((__int64)v15, mpi) < 0 )
          goto LABEL_41;
        ssh_string_burn(mpi);
        ssh_string_free(mpi);
        mpi = 0LL;
      }
      else if ( v2 != 5 || (unsigned int)pki_ed25519_public_key_to_blob((__int64)v15, a1) )
      {
        goto LABEL_41;
      }
    }
    else
    {
      if ( v2 != 1 )
        goto LABEL_41;
      v12 = ssh_sexp_extract_mpi(*(_QWORD *)(a1 + 24), (__int64)"p", 5u, 1u);
      if ( !v12 )
        goto LABEL_41;
      v14 = ssh_sexp_extract_mpi(*(_QWORD *)(a1 + 24), (__int64)aQgyxendu, 5u, 1u);
      if ( !v14 )
        goto LABEL_41;
      v13 = ssh_sexp_extract_mpi(*(_QWORD *)(a1 + 24), (__int64)&aQgyxendu[1], 5u, 1u);
      if ( !v13 )
        goto LABEL_41;
      v11 = ssh_sexp_extract_mpi(*(_QWORD *)(a1 + 24), (__int64)&aQgyxendu[2], 5u, 1u);
      if ( !v11
        || (int)ssh_buffer_add_ssh_string((__int64)v15, v12) < 0
        || (int)ssh_buffer_add_ssh_string((__int64)v15, v14) < 0
        || (int)ssh_buffer_add_ssh_string((__int64)v15, v13) < 0
        || (int)ssh_buffer_add_ssh_string((__int64)v15, v11) < 0 )
      {
        goto LABEL_41;
      }
      ssh_string_burn(v12);
      ssh_string_free(v12);
      ssh_string_burn(v13);
      ssh_string_free(v13);
      ssh_string_burn(v14);
      ssh_string_free(v14);
      ssh_string_burn(v11);
      ssh_string_free(v11);
    }
  }
  len = ssh_buffer_get_len((__int64)v15);
  v9 = (uint32_t *)ssh_string_new(len);
  if ( v9 )
  {
    v5 = (unsigned int)ssh_buffer_get_len((__int64)v15);
    v6 = (const void *)ssh_buffer_get((__int64)v15);
    if ( (int)ssh_string_fill(v9, v6, v5) >= 0 )
    {
      ssh_buffer_free((__int64)v15);
      return v9;
    }
  }
LABEL_41:
  ssh_buffer_free((__int64)v15);
  ssh_string_burn(v9);
  ssh_string_free(v9);
  ssh_string_burn(mpi);
  ssh_string_free(mpi);
  ssh_string_burn(v12);
  ssh_string_free(v12);
  ssh_string_burn(v13);
  ssh_string_free(v13);
  ssh_string_burn(v14);
  ssh_string_free(v14);
  ssh_string_burn(v11);
  ssh_string_free(v11);
  return 0LL;
}
// 73CB4: using guessed type __int16 aQgyxendu[8];

//----- (000000000003CF55) ----------------------------------------------------
uint32_t *__fastcall pki_signature_to_blob(
        unsigned int *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned int v6; // eax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  unsigned int len; // eax
  size_t v13; // rbx
  const void *v14; // rax
  int v15; // [rsp+1Ch] [rbp-B4h]
  int v16; // [rsp+1Ch] [rbp-B4h]
  unsigned __int64 v17; // [rsp+20h] [rbp-B0h] BYREF
  _BYTE *v18; // [rsp+28h] [rbp-A8h]
  char *v19; // [rsp+30h] [rbp-A0h]
  uint32_t *v20; // [rsp+38h] [rbp-98h]
  __int64 token; // [rsp+40h] [rbp-90h]
  unsigned __int64 v22; // [rsp+48h] [rbp-88h]
  __int64 v23; // [rsp+50h] [rbp-80h]
  __int64 v24; // [rsp+58h] [rbp-78h]
  unsigned __int64 v25; // [rsp+60h] [rbp-70h]
  __int64 v26; // [rsp+68h] [rbp-68h]
  __int64 v27; // [rsp+70h] [rbp-60h]
  void *v28; // [rsp+78h] [rbp-58h]
  uint32_t *mpi; // [rsp+80h] [rbp-50h]
  uint32_t *v30; // [rsp+88h] [rbp-48h]
  __int64 v31[8]; // [rsp+90h] [rbp-40h] BYREF

  v31[5] = __readfsqword(0x28u);
  memset(v31, 0, 40);
  v18 = 0LL;
  v19 = 0LL;
  v17 = 0LL;
  v20 = 0LL;
  v6 = *a1;
  if ( *a1 == 2 )
  {
    token = gcry_sexp_find_token(*((_QWORD *)a1 + 3), &unk_73CE6, 0LL);
    if ( !token )
      return 0LL;
    v19 = (char *)gcry_sexp_nth_data(token, 1LL, &v17);
    if ( !*v19 )
    {
      --v17;
      ++v19;
    }
    v20 = (uint32_t *)ssh_string_new(v17);
    if ( !v20 )
      return 0LL;
    ssh_string_fill(v20, v19, v17);
    gcry_sexp_release(token);
  }
  else if ( v6 > 2 )
  {
    if ( v6 == 4 )
    {
      v28 = ssh_buffer_new();
      if ( !v28 )
        return 0LL;
      mpi = ssh_sexp_extract_mpi(*((_QWORD *)a1 + 4), (__int64)&unk_73CE4, 5u, 1u);
      if ( !mpi
        || (v15 = ssh_buffer_add_ssh_string((__int64)v28, mpi), ssh_string_free(mpi), v15 < 0)
        || (v30 = ssh_sexp_extract_mpi(*((_QWORD *)a1 + 4), (__int64)&unk_73CE6, 5u, 1u)) == 0LL
        || (v16 = ssh_buffer_add_ssh_string((__int64)v28, v30), ssh_string_free(v30), v16 < 0)
        || (len = ssh_buffer_get_len((__int64)v28), (v20 = (uint32_t *)ssh_string_new(len)) == 0LL) )
      {
        ssh_buffer_free((__int64)v28);
        return 0LL;
      }
      v13 = (unsigned int)ssh_buffer_get_len((__int64)v28);
      v14 = (const void *)ssh_buffer_get((__int64)v28);
      ssh_string_fill(v20, v14, v13);
      ssh_buffer_free((__int64)v28);
    }
    else
    {
      if ( v6 != 5 )
        goto LABEL_50;
      return pki_ed25519_sig_to_blob((__int64)a1);
    }
  }
  else
  {
    if ( v6 != 1 )
    {
LABEL_50:
      ssh_log(1, "pki_signature_to_blob", "Unknown signature key type: %d", *a1, a5, a6);
      return 0LL;
    }
    token = gcry_sexp_find_token(*((_QWORD *)a1 + 2), &unk_73CE4, 0LL);
    if ( !token )
      return 0LL;
    v18 = (_BYTE *)gcry_sexp_nth_data(token, 1LL, &v17);
    if ( !*v18 )
    {
      --v17;
      ++v18;
    }
    v22 = v17;
    if ( v17 <= 0x14 )
      v8 = 0LL;
    else
      v8 = v22 - 20;
    v23 = v8;
    if ( v22 > 0x13 )
      v9 = 0LL;
    else
      v9 = 20 - v22;
    v24 = v9;
    memcpy((char *)v31 + v9, &v18[v23], v22 - v23);
    gcry_sexp_release(token);
    token = gcry_sexp_find_token(*((_QWORD *)a1 + 2), &unk_73CE6, 0LL);
    if ( !token )
      return 0LL;
    v19 = (char *)gcry_sexp_nth_data(token, 1LL, &v17);
    if ( !*v19 )
    {
      --v17;
      ++v19;
    }
    v25 = v17;
    if ( v17 <= 0x14 )
      v10 = 0LL;
    else
      v10 = v25 - 20;
    v26 = v10;
    if ( v25 > 0x13 )
      v11 = 0LL;
    else
      v11 = 20 - v25;
    v27 = v11;
    memcpy((char *)&v31[2] + v11 + 4, &v19[v26], v25 - v26);
    gcry_sexp_release(token);
    v20 = (uint32_t *)ssh_string_new(0x28uLL);
    if ( !v20 )
      return 0LL;
    ssh_string_fill(v20, v31, 0x28uLL);
  }
  return v20;
}
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// DAA0: using guessed type __int64 __fastcall gcry_sexp_nth_data(_QWORD, _QWORD, _QWORD);
// DB80: using guessed type __int64 __fastcall gcry_sexp_find_token(_QWORD, _QWORD, _QWORD);

//----- (000000000003D555) ----------------------------------------------------
_DWORD *__fastcall pki_signature_from_blob(__int64 a1, uint32_t *a2, unsigned int a3)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rbx
  __int64 v12; // rax
  unsigned int v13; // ebx
  const void *v14; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rbx
  __int64 v18; // r13
  __int64 v19; // r12
  __int64 v20; // rax
  int v22; // [rsp+24h] [rbp-5Ch]
  unsigned int len; // [rsp+2Ch] [rbp-54h]
  _DWORD *v24; // [rsp+30h] [rbp-50h]
  unsigned __int64 v25; // [rsp+38h] [rbp-48h]
  unsigned __int64 v26; // [rsp+40h] [rbp-40h]
  void *v27; // [rsp+48h] [rbp-38h]
  uint32_t *ssh_string; // [rsp+50h] [rbp-30h]
  uint32_t *v29; // [rsp+58h] [rbp-28h]

  v24 = ssh_signature_new();
  if ( !v24 )
    return 0LL;
  *v24 = a3;
  v25 = ssh_string_len(a2);
  if ( a3 == 2 )
  {
    v26 = ((unsigned int)gcry_pk_get_nbits(*(_QWORD *)(a1 + 32)) + 7) >> 3;
    if ( v25 > v26 )
    {
      ssh_log(1, "pki_signature_from_blob", "Signature is to big size: %lu", v25, v9, v10);
      ssh_signature_free(v24);
      return 0LL;
    }
    if ( v25 < v26 )
      ssh_log(3, "pki_signature_from_blob", "RSA signature len %lu < %lu", v25, v26, v10);
    v11 = ssh_string_data((__int64)a2);
    v12 = ssh_string_len(a2);
    if ( (unsigned int)gcry_sexp_build(v24 + 6, 0LL, "(sig-val(rsa(s %b)))", v12, v11) )
      goto LABEL_23;
  }
  else if ( a3 > 2 )
  {
    if ( a3 == 4 )
    {
      v27 = ssh_buffer_new();
      if ( !v27 )
        goto LABEL_23;
      v13 = ssh_string_len(a2);
      v14 = (const void *)ssh_string_data((__int64)a2);
      if ( (int)ssh_buffer_add_data((__int64)v27, v14, v13) < 0
        || (ssh_string = (uint32_t *)ssh_buffer_get_ssh_string((__int64)v27)) == 0LL )
      {
        ssh_buffer_free((__int64)v27);
        ssh_signature_free(v24);
        return 0LL;
      }
      v29 = (uint32_t *)ssh_buffer_get_ssh_string((__int64)v27);
      len = ssh_buffer_get_len((__int64)v27);
      ssh_buffer_free((__int64)v27);
      if ( !v29 )
      {
        ssh_string_burn(ssh_string);
        ssh_string_free(ssh_string);
        ssh_signature_free(v24);
        return 0LL;
      }
      if ( len )
      {
        ssh_log(1, "pki_signature_from_blob", "Signature has remaining bytes in inner sigblob: %lu", len, v15, v16);
        ssh_string_burn(ssh_string);
        ssh_string_free(ssh_string);
        ssh_string_burn(v29);
        ssh_string_free(v29);
        ssh_signature_free(v24);
        return 0LL;
      }
      v17 = ssh_string_data((__int64)v29);
      v18 = ssh_string_len(v29);
      v19 = ssh_string_data((__int64)ssh_string);
      v20 = ssh_string_len(ssh_string);
      v22 = gcry_sexp_build(v24 + 8, 0LL, "(sig-val(ecdsa(r %b)(s %b)))", v20, v19, v18, v17);
      ssh_string_burn(ssh_string);
      ssh_string_free(ssh_string);
      ssh_string_burn(v29);
      ssh_string_free(v29);
      if ( v22 )
        goto LABEL_23;
    }
    else
    {
      if ( a3 != 5 )
        goto LABEL_33;
      if ( (unsigned int)pki_ed25519_sig_from_blob((__int64)v24, a2) )
        goto LABEL_23;
    }
  }
  else
  {
    if ( a3 != 1 )
    {
LABEL_33:
      ssh_log(1, "pki_signature_from_blob", "Unknown signature type", v4, v5, v6);
      return 0LL;
    }
    if ( v25 != 40 )
    {
      ssh_log(1, "pki_signature_from_blob", "Signature has wrong size: %lu", v25, v5, v6);
      ssh_signature_free(v24);
      return 0LL;
    }
    v7 = ssh_string_data((__int64)a2) + 20;
    v8 = ssh_string_data((__int64)a2);
    if ( (unsigned int)gcry_sexp_build(v24 + 4, 0LL, "(sig-val(dsa(r %b)(s %b)))", 20LL, v8, 20LL, v7) )
    {
LABEL_23:
      ssh_signature_free(v24);
      return 0LL;
    }
  }
  return v24;
}
// 3D5F8: variable 'v5' is possibly undefined
// 3D5F8: variable 'v6' is possibly undefined
// 3D6D2: variable 'v9' is possibly undefined
// 3D6D2: variable 'v10' is possibly undefined
// 3D8FC: variable 'v15' is possibly undefined
// 3D8FC: variable 'v16' is possibly undefined
// 3DA1A: variable 'v4' is possibly undefined
// DB60: using guessed type __int64 __fastcall gcry_pk_get_nbits(_QWORD);
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);

//----- (000000000003DA3F) ----------------------------------------------------
__int64 __fastcall pki_signature_verify(__int64 a1, _QWORD *a2, _DWORD *a3, void *a4, __int64 a5)
{
  __int64 v5; // r9
  void *v6; // rsp
  unsigned int v7; // eax
  __int64 v8; // rax
  __int64 v9; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // r9
  __int64 v15; // rax
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rax
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rax
  __int64 v24; // r9
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // [rsp+0h] [rbp-70h] BYREF
  size_t n; // [rsp+8h] [rbp-68h]
  void *src; // [rsp+10h] [rbp-60h]
  _QWORD *v30; // [rsp+18h] [rbp-58h]
  _QWORD *v31; // [rsp+20h] [rbp-50h]
  __int64 v32; // [rsp+28h] [rbp-48h]
  unsigned int v33; // [rsp+3Ch] [rbp-34h]
  __int64 v34[2]; // [rsp+40h] [rbp-30h] BYREF
  __int64 *v35; // [rsp+50h] [rbp-20h]
  unsigned __int64 v36; // [rsp+58h] [rbp-18h]

  v32 = a1;
  v31 = a2;
  v30 = a3;
  src = a4;
  n = a5;
  v36 = __readfsqword(0x28u);
  v34[1] = a5;
  v5 = a5 + 1;
  v6 = alloca(16 * ((a5 + 16) / 0x10uLL));
  v35 = &v27;
  v7 = *a3;
  if ( *a3 != 2 )
  {
    if ( v7 > 2 )
    {
      if ( v7 == 4 )
      {
        v33 = gcry_sexp_build(v34, 0LL, "(data(flags raw)(value %b))", n, src, v5);
        if ( v33 )
        {
          v23 = gcry_strerror(v33);
          ssh_set_error(v32, 2, "pki_signature_verify", "ECDSA hash error: %s", v23, v24);
          return 0xFFFFFFFFLL;
        }
        v33 = gcry_pk_verify(v31[4], v34[0], v30[5]);
        gcry_sexp_release(v34[0]);
        if ( v33 )
        {
          ssh_set_error(v32, 2, "pki_signature_verify", "Invalid ECDSA signature", v25, v26);
          abort();
        }
      }
      else
      {
        if ( v7 != 5 )
          goto LABEL_28;
        v33 = pki_ed25519_verify((__int64)v30, (__int64)v31, src, n);
        if ( v33 )
        {
          ssh_set_error(v32, 2, "pki_signature_verify", "ed25519 signature verification error", v21, v22);
          return 0xFFFFFFFFLL;
        }
      }
    }
    else
    {
      if ( v7 != 1 )
      {
LABEL_28:
        ssh_set_error(v32, 2, "pki_signature_verify", "Unknown public key type", a5, v5);
        return 0xFFFFFFFFLL;
      }
      if ( *(char *)src < 0 )
      {
        memcpy((char *)v35 + 1, src, n);
        *(_BYTE *)v35 = 0;
        src = v35;
        ++n;
      }
      v33 = gcry_sexp_build(v34, 0LL, "%b", n, src, v5);
      if ( v33 )
      {
        v8 = gcry_strerror(v33);
        ssh_set_error(v32, 2, "pki_signature_verify", "DSA hash error: %s", v8, v9);
        return 0xFFFFFFFFLL;
      }
      v33 = gcry_pk_verify(v31[2], v34[0], v30[3]);
      gcry_sexp_release(v34[0]);
      if ( v33 )
      {
        ssh_set_error(v32, 2, "pki_signature_verify", "Invalid DSA signature", v11, v12);
        if ( (unsigned int)gcry_err_code(v33) != 8 )
        {
          v13 = gcry_strerror(v33);
          ssh_set_error(v32, 2, "pki_signature_verify", "DSA verify error: %s", v13, v14);
        }
        return 0xFFFFFFFFLL;
      }
    }
    return 0LL;
  }
  v33 = gcry_sexp_build(v34, 0LL, "(data(flags pkcs1)(hash sha1 %b))", n, src, v5);
  if ( v33 )
  {
    v15 = gcry_strerror(v33);
    ssh_set_error(v32, 2, "pki_signature_verify", "RSA hash error: %s", v15, v16);
    return 0xFFFFFFFFLL;
  }
  v33 = gcry_pk_verify(v31[3], v34[0], v30[4]);
  gcry_sexp_release(v34[0]);
  if ( !v33 )
    return 0LL;
  ssh_set_error(v32, 2, "pki_signature_verify", "Invalid RSA signature", v17, v18);
  if ( (unsigned int)gcry_err_code(v33) != 8 )
  {
    v19 = gcry_strerror(v33);
    ssh_set_error(v32, 2, "pki_signature_verify", "RSA verify error: %s", v19, v20);
  }
  return 0xFFFFFFFFLL;
}
// 3DB58: variable 'v5' is possibly undefined
// 3DB95: variable 'v9' is possibly undefined
// 3DBFB: variable 'v11' is possibly undefined
// 3DBFB: variable 'v12' is possibly undefined
// 3DC3E: variable 'v14' is possibly undefined
// 3DCB0: variable 'v16' is possibly undefined
// 3DD16: variable 'v17' is possibly undefined
// 3DD16: variable 'v18' is possibly undefined
// 3DD59: variable 'v20' is possibly undefined
// 3DDAC: variable 'v21' is possibly undefined
// 3DDAC: variable 'v22' is possibly undefined
// 3DE1E: variable 'v24' is possibly undefined
// 3DE80: variable 'v25' is possibly undefined
// 3DE80: variable 'v26' is possibly undefined
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// D9F0: using guessed type __int64 __fastcall gcry_strerror(_QWORD);
// DCC0: using guessed type __int64 __fastcall gcry_pk_verify(_QWORD, _QWORD, _QWORD);
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);

//----- (000000000003DEE4) ----------------------------------------------------
_QWORD *__fastcall pki_do_sign(__int64 a1, void *a2, size_t a3)
{
  void *v3; // rsp
  unsigned int v5; // eax
  __int64 v6; // [rsp+0h] [rbp-60h] BYREF
  size_t n; // [rsp+8h] [rbp-58h]
  void *src; // [rsp+10h] [rbp-50h]
  __int64 v9; // [rsp+18h] [rbp-48h]
  int v10; // [rsp+24h] [rbp-3Ch]
  __int64 v11[2]; // [rsp+28h] [rbp-38h] BYREF
  __int64 *v12; // [rsp+38h] [rbp-28h]
  _QWORD *v13; // [rsp+40h] [rbp-20h]
  unsigned __int64 v14; // [rsp+48h] [rbp-18h]

  v9 = a1;
  src = a2;
  n = a3;
  v14 = __readfsqword(0x28u);
  v11[1] = a3;
  v3 = alloca(16 * ((a3 + 16) / 0x10));
  v12 = &v6;
  v13 = ssh_signature_new();
  if ( !v13 )
    return 0LL;
  *(_DWORD *)v13 = *(_DWORD *)v9;
  v13[1] = *(_QWORD *)(v9 + 8);
  v5 = *(_DWORD *)v9;
  if ( *(_DWORD *)v9 == 2 )
  {
    v10 = gcry_sexp_build(v11, 0LL, "(data(flags pkcs1)(hash sha1 %b))", n, src);
    if ( !v10 )
    {
      v10 = gcry_pk_sign(v13 + 3, v11[0], *(_QWORD *)(v9 + 32));
      gcry_sexp_release(v11[0]);
      if ( !v10 )
        return v13;
    }
    goto LABEL_23;
  }
  if ( v5 > 2 )
  {
    if ( v5 == 4 )
    {
      v10 = gcry_sexp_build(v11, 0LL, "(data(flags raw)(value %b))", n, src);
      if ( !v10 )
      {
        v10 = gcry_pk_sign(v13 + 4, v11[0], *(_QWORD *)(v9 + 40));
        gcry_sexp_release(v11[0]);
        if ( !v10 )
          return v13;
      }
    }
    else if ( v5 == 5 )
    {
      v10 = pki_ed25519_sign(v9, (__int64)v13, (__int64)src, n);
      if ( !v10 )
        return v13;
    }
LABEL_23:
    ssh_signature_free(v13);
    return 0LL;
  }
  if ( v5 != 1 )
    goto LABEL_23;
  if ( *(char *)src < 0 )
  {
    memcpy((char *)v12 + 1, src, n);
    *(_BYTE *)v12 = 0;
    src = v12;
    ++n;
  }
  v10 = gcry_sexp_build(v11, 0LL, "%b", n, src);
  if ( v10 )
    goto LABEL_23;
  v10 = gcry_pk_sign(v13 + 2, v11[0], *(_QWORD *)(v9 + 24));
  gcry_sexp_release(v11[0]);
  if ( v10 )
    goto LABEL_23;
  return v13;
}
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// DE50: using guessed type __int64 __fastcall gcry_pk_sign(_QWORD, _QWORD, _QWORD);
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);

//----- (000000000003E23A) ----------------------------------------------------
_QWORD *__fastcall pki_do_sign_sessionid(__int64 a1, void *a2, size_t a3)
{
  void *v3; // rsp
  unsigned int v5; // eax
  int v6; // eax
  __int64 v7; // [rsp+0h] [rbp-60h] BYREF
  size_t n; // [rsp+8h] [rbp-58h]
  void *src; // [rsp+10h] [rbp-50h]
  __int64 v10; // [rsp+18h] [rbp-48h]
  int v11; // [rsp+24h] [rbp-3Ch]
  __int64 v12[2]; // [rsp+28h] [rbp-38h] BYREF
  __int64 *v13; // [rsp+38h] [rbp-28h]
  _QWORD *v14; // [rsp+40h] [rbp-20h]
  unsigned __int64 v15; // [rsp+48h] [rbp-18h]

  v10 = a1;
  src = a2;
  n = a3;
  v15 = __readfsqword(0x28u);
  v12[1] = a3;
  v3 = alloca(16 * ((a3 + 16) / 0x10));
  v13 = &v7;
  v14 = ssh_signature_new();
  if ( !v14 )
    return 0LL;
  *(_DWORD *)v14 = *(_DWORD *)v10;
  v14[1] = *(_QWORD *)(v10 + 8);
  v5 = *(_DWORD *)v10;
  if ( *(_DWORD *)v10 == 2 )
  {
    v11 = gcry_sexp_build(v12, 0LL, "(data(flags pkcs1)(hash sha1 %b))", n, src);
    if ( v11 )
      goto LABEL_20;
    v11 = gcry_pk_sign(v14 + 3, v12[0], *(_QWORD *)(v10 + 32));
    gcry_sexp_release(v12[0]);
    if ( v11 )
      goto LABEL_20;
  }
  else if ( v5 > 2 )
  {
    if ( v5 - 4 > 1 )
      return 0LL;
    v6 = gcry_sexp_build(v12, 0LL, "(data(flags raw)(value %b))", n, src);
    v11 = v6;
    if ( v6 || (v11 = gcry_pk_sign(v14 + 4, v12[0], *(_QWORD *)(v10 + 40)), gcry_sexp_release(v12[0]), v11) )
    {
LABEL_20:
      ssh_signature_free(v14);
      return 0LL;
    }
  }
  else
  {
    if ( v5 != 1 )
      return 0LL;
    if ( *(char *)src < 0 )
    {
      memcpy((char *)v13 + 1, src, n);
      *(_BYTE *)v13 = 0;
      src = v13;
      ++n;
    }
    v11 = gcry_sexp_build(v12, 0LL, "%b", n, src);
    if ( v11 )
      goto LABEL_20;
    v11 = gcry_pk_sign(v14 + 2, v12[0], *(_QWORD *)(v10 + 24));
    gcry_sexp_release(v12[0]);
    if ( v11 )
      goto LABEL_20;
  }
  return v14;
}
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// DE50: using guessed type __int64 __fastcall gcry_pk_sign(_QWORD, _QWORD, _QWORD);
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);

//----- (000000000003E540) ----------------------------------------------------
const char *__fastcall ecdh_kex_type_to_curve(int a1)
{
  switch ( a1 )
  {
    case 3:
      return "NIST P-256";
    case 4:
      return "NIST P-384";
    case 5:
      return "NIST P-521";
  }
  return 0LL;
}

//----- (000000000003E57B) ----------------------------------------------------
__int64 __fastcall ssh_client_ecdh_init(__int64 a1)
{
  unsigned int v2; // [rsp+18h] [rbp-28h]
  __int64 v3; // [rsp+20h] [rbp-20h] BYREF
  __int64 v4; // [rsp+28h] [rbp-18h] BYREF
  uint32_t *mpi; // [rsp+30h] [rbp-10h]
  const char *v6; // [rsp+38h] [rbp-8h]

  mpi = 0LL;
  v3 = 0LL;
  v4 = 0LL;
  v6 = 0LL;
  v6 = ecdh_kex_type_to_curve(*(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL));
  if ( v6 )
  {
    if ( (int)ssh_buffer_add_u8(*(_QWORD *)(a1 + 1152), 30) >= 0 )
    {
      if ( (unsigned int)gcry_sexp_build(&v3, 0LL, "(genkey(ecdh(curve %s)))", v6) )
      {
        v2 = -1;
      }
      else if ( (unsigned int)gcry_pk_genkey(&v4, v3) )
      {
        v2 = -1;
      }
      else
      {
        mpi = ssh_sexp_extract_mpi(v4, (__int64)"q", 5u, 1u);
        if ( mpi )
        {
          if ( (int)ssh_buffer_add_ssh_string(*(_QWORD *)(a1 + 1152), mpi) >= 0 )
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 40LL) = v4;
            v4 = 0LL;
            *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 48LL) = mpi;
            mpi = 0LL;
            v2 = ssh_packet_send(a1);
          }
          else
          {
            v2 = -1;
          }
        }
        else
        {
          v2 = -1;
        }
      }
    }
    else
    {
      v2 = -1;
    }
  }
  else
  {
    v2 = -1;
  }
  gcry_sexp_release(v3);
  gcry_sexp_release(v4);
  ssh_string_free(mpi);
  return v2;
}
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);
// E020: using guessed type __int64 __fastcall gcry_pk_genkey(_QWORD, _QWORD);

//----- (000000000003E72F) ----------------------------------------------------
__int64 __fastcall ecdh_build_k(__int64 a1)
{
  uint32_t *v1; // rax
  __int64 v2; // rbx
  __int64 v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // r9
  __int64 v7; // rbx
  unsigned int v9; // [rsp+18h] [rbp-58h]
  int v10; // [rsp+1Ch] [rbp-54h]
  __int64 v11; // [rsp+20h] [rbp-50h] BYREF
  __int64 v12; // [rsp+28h] [rbp-48h] BYREF
  __int64 v13; // [rsp+30h] [rbp-40h] BYREF
  __int64 v14; // [rsp+38h] [rbp-38h] BYREF
  uint32_t *mpi; // [rsp+40h] [rbp-30h]
  const char *v16; // [rsp+48h] [rbp-28h]
  uint32_t *v17; // [rsp+50h] [rbp-20h]
  __int64 v18; // [rsp+58h] [rbp-18h]

  v11 = 0LL;
  v12 = 0LL;
  v13 = 0LL;
  v14 = 0LL;
  mpi = 0LL;
  v9 = -1;
  v16 = 0LL;
  v16 = ecdh_kex_type_to_curve(*(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL));
  if ( v16 )
  {
    v1 = *(_DWORD *)(a1 + 1076)
       ? *(uint32_t **)(*(_QWORD *)(a1 + 1240) + 48LL)
       : *(uint32_t **)(*(_QWORD *)(a1 + 1240) + 56LL);
    v17 = v1;
    v2 = ssh_string_data((__int64)v1);
    v3 = ssh_string_len(v17);
    if ( !(unsigned int)gcry_sexp_build(&v14, 0LL, "(key-data(public-key(ecdh(curve %s)(q %b))))", v16, v3, v2) )
    {
      mpi = ssh_sexp_extract_mpi(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 40LL), (__int64)"d", 5u, 1u);
      if ( mpi )
      {
        v4 = ssh_string_data((__int64)mpi);
        v5 = ssh_string_len(mpi);
        if ( !(unsigned int)gcry_sexp_build(&v11, 0LL, "(data(flags raw)(value %b))", v5, v4)
          && !(unsigned int)gcry_pk_encrypt(&v12, v11, v14)
          && !(unsigned int)gcry_sexp_extract_param(v12, &unk_7406D, "s", &v13, 0LL, v6) )
        {
          v18 = gcry_mpi_point_new(0LL);
          if ( v18 )
          {
            v10 = gcry_mpi_ec_decode_point(v18, v13, 0LL);
            gcry_mpi_release(v13);
            if ( !v10 )
            {
              v7 = *(_QWORD *)(a1 + 1240);
              *(_QWORD *)(v7 + 24) = gcry_mpi_new(0LL);
              gcry_mpi_point_snatch_get(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 24LL), 0LL, 0LL, v18);
              v9 = 0;
              gcry_sexp_release(*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 40LL));
              *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 40LL) = 0LL;
            }
          }
          else
          {
            gcry_mpi_release(v13);
          }
        }
      }
    }
  }
  gcry_sexp_release(v14);
  gcry_sexp_release(v11);
  gcry_sexp_release(v12);
  ssh_string_burn(mpi);
  ssh_string_free(mpi);
  return v9;
}
// 3E8F1: variable 'v6' is possibly undefined
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// DB70: using guessed type __int64 __fastcall gcry_pk_encrypt(_QWORD, _QWORD, _QWORD);
// DBD0: using guessed type __int64 __fastcall gcry_mpi_new(_QWORD);
// DD10: using guessed type __int64 __fastcall gcry_mpi_ec_decode_point(_QWORD, _QWORD, _QWORD);
// DD20: using guessed type __int64 __fastcall gcry_mpi_point_snatch_get(_QWORD, _QWORD, _QWORD, _QWORD);
// DDC0: using guessed type __int64 __fastcall gcry_mpi_point_new(_QWORD);
// DE30: using guessed type __int64 __fastcall gcry_mpi_release(_QWORD);
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);

//----- (000000000003EA27) ----------------------------------------------------
__int64 __fastcall ssh_server_ecdh_init(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  unsigned int key_params; // [rsp+18h] [rbp-48h]
  __int64 v20; // [rsp+20h] [rbp-40h] BYREF
  __int64 v21; // [rsp+28h] [rbp-38h] BYREF
  __int64 v22; // [rsp+30h] [rbp-30h] BYREF
  uint32_t *v23; // [rsp+38h] [rbp-28h] BYREF
  uint32_t *v24; // [rsp+40h] [rbp-20h]
  const char *v25; // [rsp+48h] [rbp-18h]
  void *ssh_string; // [rsp+50h] [rbp-10h]
  uint32_t *mpi; // [rsp+58h] [rbp-8h]

  v20 = 0LL;
  v21 = 0LL;
  v24 = 0LL;
  v23 = 0LL;
  key_params = -1;
  v25 = 0LL;
  v25 = ecdh_kex_type_to_curve(*(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL));
  if ( v25 )
  {
    ssh_string = ssh_buffer_get_ssh_string(a2);
    if ( ssh_string )
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 48LL) = ssh_string;
      if ( !(unsigned int)gcry_sexp_build(&v20, 0LL, "(genkey(ecdh(curve %s)))", v25)
        && !(unsigned int)gcry_pk_genkey(&v21, v20) )
      {
        mpi = ssh_sexp_extract_mpi(v21, (__int64)"q", 5u, 1u);
        if ( mpi )
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 40LL) = v21;
          v21 = 0LL;
          *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 56LL) = mpi;
          key_params = ecdh_build_k(a1);
          if ( key_params )
          {
            ssh_set_error(a1, 2, "ssh_server_ecdh_init", "Cannot build k number", v4, v5);
          }
          else
          {
            key_params = ssh_get_key_params(a1, &v22);
            if ( !key_params )
            {
              key_params = ssh_make_sessionid(a1);
              if ( key_params )
              {
                ssh_set_error(a1, 2, "ssh_server_ecdh_init", "Could not create a session id", v6, v7);
              }
              else
              {
                v24 = ssh_srv_pki_do_sign_sessionid(a1, v22);
                if ( v24 )
                {
                  key_params = ssh_dh_get_next_server_publickey_blob(a1, &v23);
                  if ( key_params )
                  {
                    ssh_set_error(a1, 2, "ssh_server_ecdh_init", "Could not export server public key", v10, v11);
                    ssh_string_free(v24);
                  }
                  else
                  {
                    key_params = ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "bSSS", 4, 31LL, v23, mpi, v24, 1332084403LL);
                    ssh_string_free(v24);
                    ssh_string_free(v23);
                    if ( key_params )
                    {
                      ssh_set_error_oom(a1, "ssh_server_ecdh_init");
                    }
                    else
                    {
                      ssh_log(2, "ssh_server_ecdh_init", "SSH_MSG_KEXDH_REPLY sent", v12, v13, v14);
                      key_params = ssh_packet_send(a1);
                      if ( !key_params )
                      {
                        key_params = ssh_buffer_add_u8(*(_QWORD *)(a1 + 1152), 21);
                        if ( !key_params )
                        {
                          *(_DWORD *)(a1 + 1172) = 2;
                          key_params = ssh_packet_send(a1);
                          ssh_log(2, "ssh_server_ecdh_init", "SSH_MSG_NEWKEYS sent", v15, v16, v17);
                        }
                      }
                    }
                  }
                }
                else
                {
                  ssh_set_error(a1, 2, "ssh_server_ecdh_init", "Could not sign the session id", v8, v9);
                  key_params = -1;
                }
              }
            }
          }
        }
      }
    }
    else
    {
      ssh_set_error(a1, 2, "ssh_server_ecdh_init", "No Q_C ECC point in packet", v2, v3);
    }
  }
  gcry_sexp_release(v20);
  gcry_sexp_release(v21);
  return key_params;
}
// 3EAC3: variable 'v2' is possibly undefined
// 3EAC3: variable 'v3' is possibly undefined
// 3EBBF: variable 'v4' is possibly undefined
// 3EBBF: variable 'v5' is possibly undefined
// 3EC1D: variable 'v6' is possibly undefined
// 3EC1D: variable 'v7' is possibly undefined
// 3EC64: variable 'v8' is possibly undefined
// 3EC64: variable 'v9' is possibly undefined
// 3ECB0: variable 'v10' is possibly undefined
// 3ECB0: variable 'v11' is possibly undefined
// 3ED5A: variable 'v12' is possibly undefined
// 3ED5A: variable 'v13' is possibly undefined
// 3ED5A: variable 'v14' is possibly undefined
// 3EDCA: variable 'v15' is possibly undefined
// 3EDCA: variable 'v16' is possibly undefined
// 3EDCA: variable 'v17' is possibly undefined
// D920: using guessed type __int64 __fastcall gcry_sexp_release(_QWORD);
// DE70: using guessed type __int64 gcry_sexp_build(_QWORD, _QWORD, const char *, ...);
// E020: using guessed type __int64 __fastcall gcry_pk_genkey(_QWORD, _QWORD);

//----- (000000000003EE01) ----------------------------------------------------
__int64 __fastcall server_set_kex(__int64 a1)
{
  __int64 v1; // r8
  __int64 v2; // r9
  int v4; // eax
  const char *v5; // rax
  size_t v6; // rax
  const char *v7; // rax
  const char *v8; // rax
  char *v9; // rax
  signed int i; // [rsp+14h] [rbp-7Ch]
  signed int j; // [rsp+18h] [rbp-78h]
  int v12; // [rsp+20h] [rbp-70h]
  int v13; // [rsp+20h] [rbp-70h]
  const char *supported_method; // [rsp+28h] [rbp-68h]
  void *s; // [rsp+30h] [rbp-60h]
  size_t v16; // [rsp+38h] [rbp-58h]
  size_t v17; // [rsp+38h] [rbp-58h]
  char v18[72]; // [rsp+40h] [rbp-50h] BYREF
  unsigned __int64 v19; // [rsp+88h] [rbp-8h]

  v19 = __readfsqword(0x28u);
  s = (void *)(*(_QWORD *)(a1 + 1240) + 368LL);
  memset(v18, 0, 0x40uLL);
  if ( s )
    memset(s, 0, 0x60uLL);
  if ( (unsigned int)ssh_get_random((__int64)s, 16) )
  {
    if ( *(_QWORD *)(a1 + 1312) )
    {
      v4 = ssh_key_type(*(unsigned int **)(a1 + 1312));
      v5 = ssh_key_type_to_char(v4);
      snprintf(v18, 0x40uLL, "%s", v5);
    }
    if ( *(_QWORD *)(a1 + 1304) )
    {
      v6 = strlen(v18);
      snprintf(&v18[v6], 64 - v6, ",%s", *(const char **)(*(_QWORD *)(a1 + 1304) + 8LL));
    }
    if ( *(_QWORD *)(a1 + 1296) )
    {
      v16 = strlen(v18);
      v12 = ssh_key_type(*(unsigned int **)(a1 + 1296));
      v7 = ssh_key_type_to_char(v12);
      snprintf(&v18[v16], 64 - v16, ",%s", v7);
    }
    if ( *(_QWORD *)(a1 + 1288) )
    {
      v17 = strlen(v18);
      v13 = ssh_key_type(*(unsigned int **)(a1 + 1288));
      v8 = ssh_key_type_to_char(v13);
      snprintf(&v18[v17], 64 - v17, ",%s", v8);
    }
    if ( v18[0] )
    {
      if ( v18[0] == 44 )
        v9 = &v18[1];
      else
        v9 = v18;
      if ( (int)ssh_options_set_algo(a1, 1u, v9) >= 0 )
      {
        for ( i = 0; ; ++i )
        {
          if ( i > 9 )
            return 0LL;
          supported_method = *(const char **)(a1 + 8 * (i + 188LL) + 16);
          if ( !supported_method )
            supported_method = ssh_kex_get_supported_method(i);
          *((_QWORD *)s + i + 2) = strdup(supported_method);
          if ( !*((_QWORD *)s + i + 2) )
            break;
        }
        for ( j = 0; j < i; ++j )
        {
          if ( *((_QWORD *)s + j + 2) )
          {
            free(*((void **)s + j + 2));
            *((_QWORD *)s + j + 2) = 0LL;
          }
        }
        return 0xFFFFFFFFLL;
      }
      else
      {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error(a1, 2, "server_set_kex", "PRNG error", v1, v2);
    return 0xFFFFFFFFLL;
  }
}
// 3EEAC: variable 'v1' is possibly undefined
// 3EEAC: variable 'v2' is possibly undefined
// 3EE01: using guessed type char var_50[72];

//----- (000000000003F1B0) ----------------------------------------------------
__int64 __fastcall ssh_server_init_kex(__int64 a1)
{
  int i; // [rsp+1Ch] [rbp-4h]

  if ( *(_DWORD *)(a1 + 1164) > 3u )
    return 0xFFFFFFFFLL;
  for ( i = 0; i <= 9; ++i )
  {
    if ( *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8 * (i + 48LL)) )
    {
      free(*(void **)(*(_QWORD *)(a1 + 1240) + 8 * (i + 48LL)));
      *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8 * (i + 48LL)) = 0LL;
    }
  }
  return server_set_kex(a1);
}

//----- (000000000003F24F) ----------------------------------------------------
__int64 __fastcall ssh_server_kexdh_init(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v5; // r8
  __int64 v6; // r9
  uint32_t *ssh_string; // [rsp+18h] [rbp-8h]

  ssh_string = (uint32_t *)ssh_buffer_get_ssh_string(a2);
  if ( ssh_string )
  {
    if ( (int)ssh_dh_import_e(a1, ssh_string) >= 0 )
    {
      *(_DWORD *)(a1 + 1172) = 1;
      dh_handshake_server(a1);
    }
    else
    {
      ssh_set_error(a1, 2, "ssh_server_kexdh_init", "Cannot import e number", v5, v6, a2);
      *(_DWORD *)(a1 + 1164) = 9;
    }
    ssh_string_free(ssh_string);
    return 0LL;
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_server_kexdh_init", "No e number in client request", v2, v3, a2);
    return 0xFFFFFFFFLL;
  }
}
// 3F295: variable 'v2' is possibly undefined
// 3F295: variable 'v3' is possibly undefined
// 3F2D7: variable 'v5' is possibly undefined
// 3F2D7: variable 'v6' is possibly undefined

//----- (000000000003F319) ----------------------------------------------------
__int64 __fastcall ssh_packet_kexdh_init(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  int v11; // [rsp+2Ch] [rbp-4h]

  v11 = -1;
  ssh_log(3, "ssh_packet_kexdh_init", "Received SSH_MSG_KEXDH_INIT", a4, a5, a6, a4);
  if ( *(_DWORD *)(a1 + 1172) )
  {
    ssh_log(1, "ssh_packet_kexdh_init", "Invalid state for SSH_MSG_KEXDH_INIT", v6, v7, v8);
  }
  else if ( *(_DWORD *)(a1 + 1208) )
  {
    ssh_log(
      1,
      "ssh_packet_kexdh_init",
      "first_kex_packet_follows guess was wrong, ignoring first SSH_MSG_KEXDH_INIT message",
      v6,
      v7,
      v8);
    *(_DWORD *)(a1 + 1208) = 0;
    v11 = 0;
  }
  else
  {
    switch ( *(_DWORD *)(*(_QWORD *)(a1 + 1240) + 640LL) )
    {
      case 1:
      case 2:
        v11 = ssh_server_kexdh_init(a1, a3);
        break;
      case 3:
      case 4:
      case 5:
        v11 = ssh_server_ecdh_init(a1, a3);
        break;
      case 6:
      case 7:
        v11 = ssh_server_curve25519_init(a1, a3);
        break;
      default:
        ssh_set_error(a1, 2, "ssh_packet_kexdh_init", "Wrong kex type in ssh_packet_kexdh_init", v7, v8);
        v11 = -1;
        break;
    }
  }
  if ( v11 == -1 )
    *(_DWORD *)(a1 + 1164) = 9;
  return 1LL;
}
// 3F37C: variable 'v6' is possibly undefined
// 3F37C: variable 'v7' is possibly undefined
// 3F37C: variable 'v8' is possibly undefined

//----- (000000000003F492) ----------------------------------------------------
__int64 __fastcall ssh_get_key_params(__int64 a1, __int64 *a2)
{
  unsigned int v2; // eax
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  int v8; // [rsp+1Ch] [rbp-14h]
  int pubkey_blob; // [rsp+1Ch] [rbp-14h]
  void *v10; // [rsp+20h] [rbp-10h] BYREF
  uint32_t *v11; // [rsp+28h] [rbp-8h] BYREF

  v2 = *(_DWORD *)(a1 + 1320);
  if ( v2 == 2 )
  {
    *a2 = *(_QWORD *)(a1 + 1288);
    goto LABEL_13;
  }
  if ( v2 > 2 )
  {
    if ( v2 == 4 )
    {
      *a2 = *(_QWORD *)(a1 + 1304);
      goto LABEL_13;
    }
    if ( v2 == 5 )
    {
      *a2 = *(_QWORD *)(a1 + 1312);
      goto LABEL_13;
    }
  }
  else if ( v2 == 1 )
  {
    *a2 = *(_QWORD *)(a1 + 1296);
    goto LABEL_13;
  }
  *a2 = 0LL;
LABEL_13:
  if ( (int)ssh_pki_export_privkey_to_pubkey(*a2, &v10) >= 0 )
  {
    v8 = ssh_pki_export_pubkey_blob((__int64)v10, &v11);
    ssh_key_free(v10);
    if ( v8 >= 0 )
    {
      pubkey_blob = ssh_dh_import_next_pubkey_blob(a1, v11);
      ssh_string_free(v11);
      if ( pubkey_blob )
      {
        ssh_set_error(a1, 2, "ssh_get_key_params", "Could not import server public key", v6, v7);
        return 0xFFFFFFFFLL;
      }
      else
      {
        return 0LL;
      }
    }
    else
    {
      ssh_set_error_oom(a1, "ssh_get_key_params");
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_get_key_params", "Could not get the public key from the private key", v3, v4);
    return 0xFFFFFFFFLL;
  }
}
// 3F562: variable 'v3' is possibly undefined
// 3F562: variable 'v4' is possibly undefined
// 3F5FA: variable 'v6' is possibly undefined
// 3F5FA: variable 'v7' is possibly undefined

//----- (000000000003F60D) ----------------------------------------------------
__int64 __fastcall dh_handshake_server(__int64 a1)
{
  __int64 v1; // r8
  __int64 v2; // r9
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  int v17; // [rsp+1Ch] [rbp-24h]
  __int64 v18; // [rsp+20h] [rbp-20h] BYREF
  uint32_t *v19; // [rsp+28h] [rbp-18h] BYREF
  _BYTE *f; // [rsp+30h] [rbp-10h]
  uint32_t *v21; // [rsp+38h] [rbp-8h]

  v19 = 0LL;
  if ( (int)ssh_dh_generate_y(a1) >= 0 )
  {
    if ( (int)ssh_dh_generate_f(a1) >= 0 )
    {
      f = ssh_dh_get_f(a1);
      if ( f )
      {
        if ( (unsigned int)ssh_get_key_params(a1, &v18) )
        {
          ssh_string_free(f);
          return 0xFFFFFFFFLL;
        }
        else if ( (int)ssh_dh_build_k(a1) >= 0 )
        {
          if ( (unsigned int)ssh_make_sessionid(a1) )
          {
            ssh_set_error(a1, 2, "dh_handshake_server", "Could not create a session id", v10, v11);
            ssh_string_free(f);
            return 0xFFFFFFFFLL;
          }
          else
          {
            v21 = ssh_srv_pki_do_sign_sessionid(a1, v18);
            if ( v21 )
            {
              if ( (unsigned int)ssh_dh_get_next_server_publickey_blob(a1, &v19) )
              {
                ssh_set_error_oom(a1, "dh_handshake_server");
                ssh_string_free(f);
                ssh_string_free(v21);
                return 0xFFFFFFFFLL;
              }
              else
              {
                v17 = ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "bSSS", 4, 31LL, v19, f, v21, 1332084403LL);
                ssh_string_free(f);
                ssh_string_free(v21);
                ssh_string_free(v19);
                if ( v17 )
                {
                  ssh_set_error_oom(a1, "dh_handshake_server");
                  ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
                  return 0xFFFFFFFFLL;
                }
                else if ( (unsigned int)ssh_packet_send(a1) == -1 )
                {
                  return 0xFFFFFFFFLL;
                }
                else if ( (int)ssh_buffer_add_u8(*(_QWORD *)(a1 + 1152), 21) >= 0 )
                {
                  if ( (unsigned int)ssh_packet_send(a1) == -1 )
                  {
                    return 0xFFFFFFFFLL;
                  }
                  else
                  {
                    ssh_log(3, "dh_handshake_server", "SSH_MSG_NEWKEYS sent", v14, v15, v16);
                    *(_DWORD *)(a1 + 1172) = 2;
                    return 0LL;
                  }
                }
                else
                {
                  ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
                  return 0xFFFFFFFFLL;
                }
              }
            }
            else
            {
              ssh_set_error(a1, 2, "dh_handshake_server", "Could not sign the session id", v12, v13);
              ssh_string_free(f);
              return 0xFFFFFFFFLL;
            }
          }
        }
        else
        {
          ssh_set_error(a1, 2, "dh_handshake_server", "Could not import the public key", v8, v9);
          ssh_string_free(f);
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        ssh_set_error(a1, 2, "dh_handshake_server", "Could not get the f number", v6, v7);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      ssh_set_error(a1, 2, "dh_handshake_server", "Could not create f number", v4, v5);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error(a1, 2, "dh_handshake_server", "Could not create y number", v1, v2);
    return 0xFFFFFFFFLL;
  }
}
// 3F650: variable 'v1' is possibly undefined
// 3F650: variable 'v2' is possibly undefined
// 3F68E: variable 'v4' is possibly undefined
// 3F68E: variable 'v5' is possibly undefined
// 3F6D3: variable 'v6' is possibly undefined
// 3F6D3: variable 'v7' is possibly undefined
// 3F73E: variable 'v8' is possibly undefined
// 3F73E: variable 'v9' is possibly undefined
// 3F788: variable 'v10' is possibly undefined
// 3F788: variable 'v11' is possibly undefined
// 3F7E0: variable 'v12' is possibly undefined
// 3F7E0: variable 'v13' is possibly undefined
// 3F96A: variable 'v14' is possibly undefined
// 3F96A: variable 'v15' is possibly undefined
// 3F96A: variable 'v16' is possibly undefined

//----- (000000000003F984) ----------------------------------------------------
unsigned __int64 __fastcall ssh_server_connection_callback(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // rbx

  result = *(unsigned int *)(a1 + 1164);
  switch ( (int)result )
  {
    case 0:
    case 1:
    case 2:
    case 4:
    case 7:
      return result;
    case 3:
      if ( !*(_QWORD *)(a1 + 1064) )
        goto LABEL_42;
      if ( *(_QWORD *)(a1 + 1032) && *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 32LL) )
        (*(void (__fastcall **)(_QWORD, float))(*(_QWORD *)(a1 + 1032) + 32LL))(
          *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL),
          0.40000001);
      ssh_log(1, "ssh_server_connection_callback", "SSH client banner: %s", *(_QWORD *)(a1 + 1064), a5, a6);
      if ( (int)ssh_analyze_banner(a1, 1, v7, v8, v9, v10) < 0 )
      {
        ssh_set_error(
          a1,
          2,
          "ssh_server_connection_callback",
          "No version of SSH protocol usable (banner: %s)",
          *(_QWORD *)(a1 + 1064),
          v11);
        goto LABEL_42;
      }
      *(_QWORD *)(a1 + 1416) = ssh_packet_socket_callback;
      ssh_packet_set_default_callbacks(a1);
      if ( *(_QWORD *)(a1 + 1032) )
      {
        if ( *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 32LL) )
          (*(void (__fastcall **)(_QWORD, float))(*(_QWORD *)(a1 + 1032) + 32LL))(
            *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL),
            0.5);
      }
      *(_DWORD *)(a1 + 1164) = 4;
      result = ssh_send_kex((__int64 *)a1, 1);
      if ( (result & 0x80000000) != 0LL )
        goto LABEL_42;
      break;
    case 5:
      if ( *(_QWORD *)(a1 + 1032) && *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 32LL) )
        (*(void (__fastcall **)(_QWORD, float))(*(_QWORD *)(a1 + 1032) + 32LL))(
          *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL),
          0.60000002);
      if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 384LL) )
      {
        if ( (unsigned int)server_set_kex(a1) == -1 )
          goto LABEL_42;
        a2 = 1LL;
        if ( (int)ssh_send_kex((__int64 *)a1, 1) < 0 )
          goto LABEL_42;
      }
      ssh_list_kex(*(_QWORD *)(a1 + 1240) + 464LL, a2, a3, a4, a5, a6);
      if ( (int)ssh_kex_select_methods(a1) < 0 || (unsigned int)crypt_set_algorithms_server(a1) == -1 )
        goto LABEL_42;
      if ( *(_QWORD *)(a1 + 1032) && *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 32LL) )
        (*(void (__fastcall **)(_QWORD, float))(*(_QWORD *)(a1 + 1032) + 32LL))(
          *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL),
          0.80000001);
      result = a1;
      *(_DWORD *)(a1 + 1164) = 6;
      break;
    case 6:
      result = *(unsigned int *)(a1 + 1172);
      if ( (_DWORD)result == 3 )
      {
        if ( (int)ssh_generate_session_keys(a1) < 0 )
          goto LABEL_42;
        if ( *(_QWORD *)(a1 + 1232) )
          crypto_free(*(_QWORD **)(a1 + 1232));
        *(_QWORD *)(a1 + 1232) = *(_QWORD *)(a1 + 1240);
        *(_QWORD *)(a1 + 1240) = crypto_new();
        if ( !*(_QWORD *)(a1 + 1240) )
          goto LABEL_42;
        v12 = *(_QWORD *)(a1 + 1240);
        *(_QWORD *)(v12 + 176) = malloc(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 168LL));
        if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1240) + 176LL) )
        {
          ssh_set_error_oom(a1, "ssh_server_connection_callback");
          goto LABEL_42;
        }
        memcpy(
          *(void **)(*(_QWORD *)(a1 + 1240) + 176LL),
          *(const void **)(*(_QWORD *)(a1 + 1232) + 176LL),
          *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 168LL));
        if ( (*(int (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 304LL) + 72LL))(
               *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 304LL),
               *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 208LL),
               *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 200LL)) < 0
          || (*(int (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 1232) + 312LL) + 64LL))(
               *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 312LL),
               *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 216LL),
               *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 192LL)) < 0 )
        {
          goto LABEL_42;
        }
        if ( *(_QWORD *)(a1 + 1032) && *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 32LL) )
          (*(void (__fastcall **)(_QWORD, float))(*(_QWORD *)(a1 + 1032) + 32LL))(
            *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8LL),
            1.0);
        *(_DWORD *)(a1 + 1096) = 1;
        *(_DWORD *)(a1 + 1164) = 7;
        result = *(_DWORD *)(a1 + 1104) & 2;
        if ( (_DWORD)result )
        {
          result = a1;
          *(_DWORD *)(a1 + 1164) = 8;
        }
      }
      break;
    case 9:
LABEL_42:
      ssh_socket_close(*(_QWORD *)(a1 + 1048));
      *(_DWORD *)(a1 + 1100) = 0;
      result = a1;
      *(_DWORD *)(a1 + 1164) = 9;
      break;
    default:
      result = ssh_set_error(
                 a1,
                 2,
                 "ssh_server_connection_callback",
                 "Invalid state %d",
                 *(unsigned int *)(a1 + 1164),
                 a6);
      break;
  }
  return result;
}
// 3FA50: variable 'a5' is possibly undefined
// 3FA50: variable 'a6' is possibly undefined
// 3FA61: variable 'v7' is possibly undefined
// 3FA61: variable 'v8' is possibly undefined
// 3FA61: variable 'v9' is possibly undefined
// 3FA61: variable 'v10' is possibly undefined
// 3FA9C: variable 'v11' is possibly undefined
// 3FBE7: variable 'a3' is possibly undefined
// 3FBE7: variable 'a4' is possibly undefined

//----- (000000000003FF66) ----------------------------------------------------
__int64 __fastcall callback_receive_banner_0(
        const char *a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  unsigned __int64 i; // [rsp+30h] [rbp-20h]
  char *v11; // [rsp+48h] [rbp-8h]

  for ( i = 0LL; i < a2; ++i )
  {
    if ( *(_QWORD *)(a3 + 1456) && a1[i] == 10 )
      ssh_pcap_context_write(*(_QWORD *)(a3 + 1456), 0, (__int64)a1, i + 1, i + 1);
    if ( a1[i] == 13 )
      a1[i] = 0;
    if ( a1[i] == 10 )
    {
      a1[i] = 0;
      v11 = strdup(a1);
      *(_QWORD *)(a3 + 1064) = v11;
      *(_DWORD *)(a3 + 1164) = 3;
      ssh_log(3, "callback_receive_banner", "Received banner: %s", (__int64)v11, v6, v7);
      (*(void (__fastcall **)(__int64))(a3 + 1368))(a3);
      return (unsigned int)(i + 1);
    }
    if ( i > 0x7F )
    {
      *(_DWORD *)(a3 + 1164) = 9;
      ssh_set_error(a3, 2, "callback_receive_banner", "Receiving banner: too large banner", a5, a6);
      return 0LL;
    }
  }
  return 0LL;
}
// 4008F: variable 'v6' is possibly undefined
// 4008F: variable 'v7' is possibly undefined
// 400E1: variable 'a5' is possibly undefined
// 400E1: variable 'a6' is possibly undefined

//----- (0000000000040105) ----------------------------------------------------
_BOOL8 __fastcall ssh_server_kex_termination(__int64 a1)
{
  return *(_DWORD *)(a1 + 1164) == 9 || *(_DWORD *)(a1 + 1164) == 7 || *(_DWORD *)(a1 + 1164) == 10;
}

//----- (0000000000040150) ----------------------------------------------------
__int64 __fastcall ssh_set_auth_methods(__int64 a1, char a2)
{
  __int64 result; // rax

  result = a1;
  *(_DWORD *)(a1 + 1328) = a2 & 0x3F;
  return result;
}

//----- (0000000000040170) ----------------------------------------------------
__int64 __fastcall ssh_handle_key_exchange(__int64 a1)
{
  __int64 v2; // r8
  __int64 v3; // r9
  unsigned int v4; // [rsp+1Ch] [rbp-4h]

  if ( *(_DWORD *)(a1 + 1164) )
    goto LABEL_6;
  if ( (int)ssh_send_banner(a1, 1) < 0 )
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 1100) = 1;
  *(_QWORD *)(a1 + 1368) = ssh_server_connection_callback;
  *(_DWORD *)(a1 + 1164) = 2;
  ssh_socket_set_callbacks(*(_QWORD *)(a1 + 1048), a1 + 1408);
  *(_QWORD *)(a1 + 1416) = callback_receive_banner_0;
  *(_QWORD *)(a1 + 1432) = ssh_socket_exception_callback;
  *(_QWORD *)(a1 + 1408) = a1;
  if ( (int)server_set_kex(a1) < 0 )
    return 0xFFFFFFFFLL;
LABEL_6:
  v4 = ssh_handle_packets_termination(
         a1,
         0xFFFFFFFE,
         (unsigned int (__fastcall *)(__int64))ssh_server_kex_termination,
         a1);
  ssh_log(
    3,
    "ssh_handle_key_exchange",
    "ssh_handle_key_exchange: current state : %d",
    *(unsigned int *)(a1 + 1164),
    v2,
    v3);
  if ( v4 )
    return v4;
  if ( *(_DWORD *)(a1 + 1164) == 9 || *(_DWORD *)(a1 + 1164) == 10 )
    return 0xFFFFFFFFLL;
  return 0LL;
}
// 4029A: variable 'v2' is possibly undefined
// 4029A: variable 'v3' is possibly undefined

//----- (00000000000402D6) ----------------------------------------------------
__int64 __fastcall ssh_auth_reply_default(__int64 a1, int a2)
{
  size_t v2; // rax
  size_t v3; // rax
  size_t v4; // rax
  size_t v5; // rax
  size_t v6; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  int v10; // [rsp+1Ch] [rbp-94h]
  char s[136]; // [rsp+20h] [rbp-90h] BYREF
  unsigned __int64 v12; // [rsp+A8h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  memset(s, 0, 0x80uLL);
  HIBYTE(v10) = -1;
  if ( !*(_DWORD *)(a1 + 1328) )
    *(_DWORD *)(a1 + 1328) = 6;
  if ( (*(_DWORD *)(a1 + 1328) & 4) != 0 )
  {
    v2 = strlen(s);
    strncat(s, "publickey,", 127 - v2);
  }
  if ( (*(_DWORD *)(a1 + 1328) & 0x20) != 0 )
  {
    v3 = strlen(s);
    strncat(s, "gssapi-with-mic,", 127 - v3);
  }
  if ( (*(_DWORD *)(a1 + 1328) & 0x10) != 0 )
  {
    v4 = strlen(s);
    strncat(s, "keyboard-interactive,", 127 - v4);
  }
  if ( (*(_DWORD *)(a1 + 1328) & 2) != 0 )
  {
    v5 = strlen(s);
    strncat(s, "password,", 127 - v5);
  }
  if ( (*(_DWORD *)(a1 + 1328) & 8) != 0 )
  {
    v6 = strlen(s);
    strncat(s, "hostbased,", 127 - v6);
  }
  if ( !s[0] || s[strlen(s) - 1] != 44 )
    return 0xFFFFFFFFLL;
  s[strlen(s) - 1] = 0;
  ssh_log(3, "ssh_auth_reply_default", "Sending a auth failure. methods that can continue: %s", (__int64)s, v8, v9);
  v10 = ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "bsb", 3, 51LL, s, a2 != 0, 1332084403LL);
  if ( !v10 )
    return (unsigned int)ssh_packet_send(a1);
  ssh_set_error_oom(a1, "ssh_auth_reply_default");
  return 0xFFFFFFFFLL;
}
// 404F6: variable 'v8' is possibly undefined
// 404F6: variable 'v9' is possibly undefined
// 402D6: using guessed type char s[136];

//----- (00000000000405AB) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_open_reply_default(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  ssh_log(4, "ssh_message_channel_request_open_reply_default", "Refusing a channel", a4, a5, a6);
  if ( !(unsigned int)ssh_buffer_pack(
                        *(_QWORD *)(*(_QWORD *)a1 + 1152LL),
                        "bdddd",
                        5,
                        92LL,
                        *(unsigned int *)(a1 + 60),
                        1LL,
                        0LL,
                        0LL,
                        1332084403LL) )
    return (unsigned int)ssh_packet_send(*(_QWORD *)a1);
  ssh_set_error_oom(*(_QWORD *)a1, "ssh_message_channel_request_open_reply_default");
  return 0xFFFFFFFFLL;
}

//----- (000000000004065E) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_reply_default(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned int v7; // [rsp+18h] [rbp-8h]

  if ( *(_BYTE *)(a1 + 120) )
  {
    v7 = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 24LL);
    ssh_log(
      3,
      "ssh_message_channel_request_reply_default",
      "Sending a default channel_request denied to channel %d",
      v7,
      a5,
      a6);
    if ( (unsigned int)ssh_buffer_pack(*(_QWORD *)(*(_QWORD *)a1 + 1152LL), "bd", 2, 100LL, v7, 1332084403LL) )
    {
      ssh_set_error_oom(*(_QWORD *)a1, "ssh_message_channel_request_reply_default");
      return 0xFFFFFFFFLL;
    }
    else
    {
      return ssh_packet_send(*(_QWORD *)a1);
    }
  }
  else
  {
    ssh_log(
      3,
      "ssh_message_channel_request_reply_default",
      "The client doesn't want to know the request failed!",
      a4,
      a5,
      a6);
    return 0LL;
  }
}

//----- (000000000004073D) ----------------------------------------------------
__int64 __fastcall ssh_message_service_request_reply_default(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  return ssh_message_service_reply_success(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000040757) ----------------------------------------------------
__int64 __fastcall ssh_message_service_reply_success(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v7; // [rsp+18h] [rbp-8h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  v7 = *a1;
  ssh_log(3, "ssh_message_service_reply_success", "Sending a SERVICE_ACCEPT for service %s", a1[28], a5, a6);
  if ( !(unsigned int)ssh_buffer_pack(*(_QWORD *)(v7 + 1152), "bs", 2, 6LL, a1[28], 1332084403LL) )
    return (unsigned int)ssh_packet_send(*a1);
  ssh_set_error_oom(v7, "ssh_message_service_reply_success");
  return 0xFFFFFFFFLL;
}

//----- (0000000000040821) ----------------------------------------------------
__int64 __fastcall ssh_message_global_request_reply_success(
        __int64 a1,
        unsigned __int16 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9

  ssh_log(4, "ssh_message_global_request_reply_success", "Accepting a global request", a4, a5, a6);
  if ( *(_BYTE *)(a1 + 236) )
  {
    if ( (int)ssh_buffer_add_u8(*(_QWORD *)(*(_QWORD *)a1 + 1152LL), 81) >= 0 )
    {
      if ( *(_DWORD *)(a1 + 232) != 1
        || *(_WORD *)(a1 + 248)
        || !(unsigned int)ssh_buffer_pack(*(_QWORD *)(*(_QWORD *)a1 + 1152LL), "d", 1, a2, 1332084403LL) )
      {
        return ssh_packet_send(*(_QWORD *)a1);
      }
      ssh_set_error_oom(*(_QWORD *)a1, "ssh_message_global_request_reply_success");
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 232) == 1 && !*(_WORD *)(a1 + 248) )
      ssh_log(
        3,
        "ssh_message_global_request_reply_success",
        "The client doesn't want to know the remote port!",
        v6,
        v7,
        v8);
    return 0LL;
  }
}
// 40941: variable 'v6' is possibly undefined
// 40941: variable 'v7' is possibly undefined
// 40941: variable 'v8' is possibly undefined

//----- (0000000000040955) ----------------------------------------------------
__int64 __fastcall ssh_message_global_request_reply_default(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9

  ssh_log(4, "ssh_message_global_request_reply_default", "Refusing a global request", a4, a5, a6);
  if ( *(_BYTE *)(a1 + 236) )
  {
    if ( (int)ssh_buffer_add_u8(*(_QWORD *)(*(_QWORD *)a1 + 1152LL), 82) < 0 )
      return 0xFFFFFFFFLL;
    else
      return ssh_packet_send(*(_QWORD *)a1);
  }
  else
  {
    ssh_log(
      3,
      "ssh_message_global_request_reply_default",
      "The client doesn't want to know the request failed!",
      v6,
      v7,
      v8);
    return 0LL;
  }
}
// 409D5: variable 'v6' is possibly undefined
// 409D5: variable 'v7' is possibly undefined
// 409D5: variable 'v8' is possibly undefined

//----- (00000000000409E9) ----------------------------------------------------
__int64 __fastcall ssh_message_reply_default(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax

  if ( !a1 )
    return 0xFFFFFFFFLL;
  switch ( *(_DWORD *)(a1 + 8) )
  {
    case 1:
      result = ssh_auth_reply_default(*(_QWORD *)a1, 0);
      break;
    case 2:
      result = ssh_message_channel_request_open_reply_default(a1, a2, a3, a4, a5, a6);
      break;
    case 3:
      result = ssh_message_channel_request_reply_default(a1, a2, a3, a4, a5, a6);
      break;
    case 4:
      result = ssh_message_service_request_reply_default((__int64 *)a1, a2, a3, a4, a5, a6);
      break;
    case 5:
      result = ssh_message_global_request_reply_default(a1, a2, a3, a4, a5, a6);
      break;
    default:
      ssh_log(
        3,
        "ssh_message_reply_default",
        "Don't know what to default reply to %d type",
        *(unsigned int *)(a1 + 8),
        a5,
        a6);
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

//----- (0000000000040AB1) ----------------------------------------------------
__int64 __fastcall ssh_message_service_service(__int64 a1)
{
  if ( a1 )
    return *(_QWORD *)(a1 + 224);
  else
    return 0LL;
}

//----- (0000000000040AD4) ----------------------------------------------------
__int64 __fastcall ssh_message_auth_user(__int64 a1)
{
  if ( a1 )
    return *(_QWORD *)(a1 + 16);
  else
    return 0LL;
}

//----- (0000000000040AF4) ----------------------------------------------------
__int64 __fastcall ssh_message_auth_password(__int64 a1)
{
  if ( a1 )
    return *(_QWORD *)(a1 + 32);
  else
    return 0LL;
}

//----- (0000000000040B14) ----------------------------------------------------
__int64 __fastcall ssh_message_auth_pubkey(__int64 a1)
{
  if ( a1 )
    return *(_QWORD *)(a1 + 40);
  else
    return 0LL;
}

//----- (0000000000040B34) ----------------------------------------------------
_QWORD *__fastcall ssh_message_auth_publickey(__int64 a1)
{
  if ( a1 )
    return ssh_pki_convert_key_to_publickey(*(_QWORD *)(a1 + 40));
  else
    return 0LL;
}

//----- (0000000000040B60) ----------------------------------------------------
__int64 __fastcall ssh_message_auth_publickey_state(__int64 a1)
{
  if ( a1 )
    return (unsigned int)*(char *)(a1 + 48);
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000040B83) ----------------------------------------------------
__int64 __fastcall ssh_message_auth_kbdint_is_response(__int64 a1)
{
  if ( a1 )
    return *(_BYTE *)(a1 + 49) != 0;
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000040BAB) ----------------------------------------------------
__int64 __fastcall ssh_message_auth_set_methods(__int64 a1, int a2)
{
  if ( !a1 || !*(_QWORD *)a1 )
    return 0xFFFFFFFFLL;
  *(_DWORD *)(*(_QWORD *)a1 + 1328LL) = a2;
  return 0LL;
}

//----- (0000000000040BE7) ----------------------------------------------------
__int64 __fastcall ssh_message_auth_interactive_request(
        __int64 *a1,
        const char *a2,
        const char *a3,
        unsigned int a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rbx
  __int64 v13; // rbx
  __int64 v14; // rbx
  char **v15; // rbx
  unsigned int i; // [rsp+38h] [rbp-18h]
  unsigned int j; // [rsp+38h] [rbp-18h]
  unsigned int v22; // [rsp+3Ch] [rbp-14h]

  if ( !a2 || !a3 )
    return 0xFFFFFFFFLL;
  if ( a4 && (!a5 || !a6) )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)ssh_buffer_pack(*(_QWORD *)(*a1 + 1152), "bsssd", 5, 60LL, a2, a3, &unk_746A2, a4, 1332084403LL) )
    goto LABEL_16;
  for ( i = 0; i < a4; ++i )
  {
    if ( (unsigned int)ssh_buffer_pack(
                         *(_QWORD *)(*a1 + 1152),
                         "sb",
                         2,
                         *(_QWORD *)(8LL * i + a5),
                         *(_BYTE *)(i + a6) != 0,
                         1332084403LL) )
      goto LABEL_16;
  }
  v22 = ssh_packet_send(*a1);
  if ( *(_QWORD *)(*a1 + 1272) )
  {
    ssh_kbdint_clean(*(void ***)(*a1 + 1272));
  }
  else
  {
    ssh_log(
      2,
      "ssh_message_auth_interactive_request",
      "Warning: Got a keyboard-interactive response but it seems we didn't send the request.",
      v7,
      v8,
      v9);
    v10 = *a1;
    *(_QWORD *)(v10 + 1272) = ssh_kbdint_new();
    if ( !*(_QWORD *)(*a1 + 1272) )
    {
LABEL_16:
      ssh_set_error_oom(*a1, "ssh_message_auth_interactive_request");
      return 0xFFFFFFFFLL;
    }
  }
  v11 = *(_QWORD *)(*a1 + 1272);
  *(_QWORD *)(v11 + 8) = strdup(a2);
  if ( !*(_QWORD *)(*(_QWORD *)(*a1 + 1272) + 8LL)
    || (v12 = *(_QWORD *)(*a1 + 1272), *(_QWORD *)(v12 + 16) = strdup(a3), !*(_QWORD *)(*(_QWORD *)(*a1 + 1272) + 16LL)) )
  {
    ssh_set_error_oom(*a1, "ssh_message_auth_interactive_request");
    ssh_kbdint_free(*(void ***)(*a1 + 1272));
    *(_QWORD *)(*a1 + 1272) = 0LL;
    return 1LL;
  }
  **(_DWORD **)(*a1 + 1272) = a4;
  if ( a4 )
  {
    v13 = *(_QWORD *)(*a1 + 1272);
    *(_QWORD *)(v13 + 24) = calloc(a4, 8uLL);
    if ( !*(_QWORD *)(*(_QWORD *)(*a1 + 1272) + 24LL) )
    {
      **(_DWORD **)(*a1 + 1272) = 0;
      ssh_set_error_oom(*a1, "ssh_message_auth_interactive_request");
      ssh_kbdint_free(*(void ***)(*a1 + 1272));
      *(_QWORD *)(*a1 + 1272) = 0LL;
      return 0xFFFFFFFFLL;
    }
    v14 = *(_QWORD *)(*a1 + 1272);
    *(_QWORD *)(v14 + 32) = calloc(a4, 1uLL);
    if ( !*(_QWORD *)(*(_QWORD *)(*a1 + 1272) + 32LL) )
    {
      ssh_set_error_oom(*a1, "ssh_message_auth_interactive_request");
      ssh_kbdint_free(*(void ***)(*a1 + 1272));
      *(_QWORD *)(*a1 + 1272) = 0LL;
      return 0xFFFFFFFFLL;
    }
    for ( j = 0; j < a4; ++j )
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*a1 + 1272) + 32LL) + j) = *(_BYTE *)(j + a6);
      v15 = (char **)(*(_QWORD *)(*(_QWORD *)(*a1 + 1272) + 24LL) + 8LL * j);
      *v15 = strdup(*(const char **)(8LL * j + a5));
      if ( !*(_QWORD *)(8LL * j + *(_QWORD *)(*(_QWORD *)(*a1 + 1272) + 24LL)) )
      {
        ssh_set_error_oom(*a1, "ssh_message_auth_interactive_request");
        **(_DWORD **)(*a1 + 1272) = j;
        ssh_kbdint_free(*(void ***)(*a1 + 1272));
        *(_QWORD *)(*a1 + 1272) = 0LL;
        return 1LL;
      }
    }
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(*a1 + 1272) + 24LL) = 0LL;
    *(_QWORD *)(*(_QWORD *)(*a1 + 1272) + 32LL) = 0LL;
  }
  return v22;
}
// 40D9F: variable 'v7' is possibly undefined
// 40D9F: variable 'v8' is possibly undefined
// 40D9F: variable 'v9' is possibly undefined

//----- (0000000000041160) ----------------------------------------------------
__int64 __fastcall ssh_auth_reply_success(__int64 a1, int a2)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  unsigned int v6; // [rsp+1Ch] [rbp-4h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
    return ssh_auth_reply_default(a1, a2);
  *(_DWORD *)(a1 + 1164) = 8;
  *(_DWORD *)(a1 + 1104) |= 2u;
  if ( (int)ssh_buffer_add_u8(*(_QWORD *)(a1 + 1152), 52) < 0 )
    return 0xFFFFFFFFLL;
  v6 = ssh_packet_send(a1);
  if ( *(_QWORD *)(a1 + 1232) && *(_DWORD *)(*(_QWORD *)(a1 + 1232) + 348LL) )
  {
    ssh_log(2, "ssh_auth_reply_success", "Enabling delayed compression OUT", v3, v4, v5);
    *(_DWORD *)(*(_QWORD *)(a1 + 1232) + 336LL) = 1;
  }
  if ( *(_QWORD *)(a1 + 1232) )
  {
    if ( *(_DWORD *)(*(_QWORD *)(a1 + 1232) + 344LL) )
    {
      ssh_log(2, "ssh_auth_reply_success", "Enabling delayed compression IN", v3, v4, v5);
      *(_DWORD *)(*(_QWORD *)(a1 + 1232) + 340LL) = 1;
    }
  }
  return v6;
}
// 41235: variable 'v3' is possibly undefined
// 41235: variable 'v4' is possibly undefined
// 41235: variable 'v5' is possibly undefined

//----- (00000000000412AB) ----------------------------------------------------
__int64 __fastcall ssh_message_auth_reply_success(__int64 *a1, int a2)
{
  if ( a1 )
    return ssh_auth_reply_success(*a1, a2);
  else
    return 0xFFFFFFFFLL;
}

//----- (00000000000412DE) ----------------------------------------------------
__int64 __fastcall ssh_message_auth_reply_pk_ok(__int64 *a1, __int64 a2, __int64 a3)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !(unsigned int)ssh_buffer_pack(*(_QWORD *)(*a1 + 1152), "bSS", 3, 60LL, a2, a3, 1332084403LL) )
    return (unsigned int)ssh_packet_send(*a1);
  ssh_set_error_oom(*a1, "ssh_message_auth_reply_pk_ok");
  return 0xFFFFFFFFLL;
}

//----- (0000000000041387) ----------------------------------------------------
__int64 __fastcall ssh_message_auth_reply_pk_ok_simple(__int64 *a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-14h]
  uint32_t *v3; // [rsp+20h] [rbp-10h] BYREF
  _BYTE *v4; // [rsp+28h] [rbp-8h]

  v3 = 0LL;
  v4 = ssh_string_from_char(*(const char **)(a1[5] + 8));
  if ( !v4 )
    return 0xFFFFFFFFLL;
  if ( (int)ssh_pki_export_pubkey_blob(a1[5], &v3) >= 0 )
  {
    v2 = ssh_message_auth_reply_pk_ok(a1, (__int64)v4, (__int64)v3);
    ssh_string_free(v4);
    ssh_string_free(v3);
    return v2;
  }
  else
  {
    ssh_string_free(v4);
    return 0xFFFFFFFFLL;
  }
}

//----- (000000000004142B) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_open_originator(__int64 a1)
{
  return *(_QWORD *)(a1 + 72);
}

//----- (000000000004143D) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_open_originator_port(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 80);
}

//----- (0000000000041452) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_open_destination(__int64 a1)
{
  return *(_QWORD *)(a1 + 88);
}

//----- (0000000000041464) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_open_destination_port(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 96);
}

//----- (0000000000041479) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_channel(__int64 a1)
{
  return *(_QWORD *)(a1 + 112);
}

//----- (000000000004148B) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_pty_term(__int64 a1)
{
  return *(_QWORD *)(a1 + 128);
}

//----- (00000000000414A0) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_pty_width(__int64 a1)
{
  return *(unsigned int *)(a1 + 136);
}

//----- (00000000000414B4) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_pty_height(__int64 a1)
{
  return *(unsigned int *)(a1 + 140);
}

//----- (00000000000414C8) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_pty_pxwidth(__int64 a1)
{
  return *(unsigned int *)(a1 + 144);
}

//----- (00000000000414DC) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_pty_pxheight(__int64 a1)
{
  return *(unsigned int *)(a1 + 148);
}

//----- (00000000000414F0) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_env_name(__int64 a1)
{
  return *(_QWORD *)(a1 + 160);
}

//----- (0000000000041505) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_env_value(__int64 a1)
{
  return *(_QWORD *)(a1 + 168);
}

//----- (000000000004151A) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_command(__int64 a1)
{
  return *(_QWORD *)(a1 + 176);
}

//----- (000000000004152F) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_subsystem(__int64 a1)
{
  return *(_QWORD *)(a1 + 184);
}

//----- (0000000000041544) ----------------------------------------------------
_BOOL8 __fastcall ssh_message_channel_request_x11_single_connection(__int64 a1)
{
  return *(_BYTE *)(a1 + 192) != 0;
}

//----- (0000000000041561) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_x11_auth_protocol(__int64 a1)
{
  return *(_QWORD *)(a1 + 200);
}

//----- (0000000000041576) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_x11_auth_cookie(__int64 a1)
{
  return *(_QWORD *)(a1 + 208);
}

//----- (000000000004158B) ----------------------------------------------------
__int64 __fastcall ssh_message_channel_request_x11_screen_number(__int64 a1)
{
  return *(unsigned int *)(a1 + 216);
}

//----- (000000000004159F) ----------------------------------------------------
__int64 __fastcall ssh_message_global_request_address(__int64 a1)
{
  return *(_QWORD *)(a1 + 240);
}

//----- (00000000000415B4) ----------------------------------------------------
__int64 __fastcall ssh_message_global_request_port(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 248);
}

//----- (00000000000415CC) ----------------------------------------------------
__int64 __fastcall ssh_set_message_callback(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 1344) = a2;
  result = a1;
  *(_QWORD *)(a1 + 1352) = a3;
  return result;
}

//----- (00000000000415FD) ----------------------------------------------------
__int64 __fastcall ssh_execute_message_callbacks(__int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // [rsp+14h] [rbp-Ch]
  unsigned int v11; // [rsp+14h] [rbp-Ch]
  __int64 v12; // [rsp+18h] [rbp-8h]
  __int64 v13; // [rsp+18h] [rbp-8h]

  ssh_handle_packets(a1, 0);
  if ( !*(_QWORD *)(a1 + 1336) )
    return 0LL;
  if ( *(_QWORD *)(a1 + 1344) )
  {
    while ( 1 )
    {
      v12 = ssh_message_pop_head(a1);
      if ( !v12 )
        break;
      if ( (*(unsigned int (__fastcall **)(__int64, __int64, _QWORD))(a1 + 1344))(a1, v12, *(_QWORD *)(a1 + 1352)) == 1 )
      {
        v10 = ssh_message_reply_default(v12, v12, v2, v3, v4, v5);
        ssh_message_free(v12);
        if ( v10 )
          return v10;
      }
      else
      {
        ssh_message_free(v12);
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v13 = ssh_message_pop_head(a1);
      if ( !v13 )
        break;
      v11 = ssh_message_reply_default(v13, 0LL, v6, v7, v8, v9);
      ssh_message_free(v13);
      if ( v11 )
        return v11;
    }
  }
  return 0LL;
}
// 41685: variable 'v2' is possibly undefined
// 41685: variable 'v3' is possibly undefined
// 41685: variable 'v4' is possibly undefined
// 41685: variable 'v5' is possibly undefined
// 416D0: variable 'v6' is possibly undefined
// 416D0: variable 'v7' is possibly undefined
// 416D0: variable 'v8' is possibly undefined
// 416D0: variable 'v9' is possibly undefined

//----- (000000000004170D) ----------------------------------------------------
__int64 __fastcall ssh_send_keepalive(__int64 a1)
{
  __int64 v1; // rcx
  __int64 v2; // r8
  __int64 v3; // r9

  if ( (unsigned int)ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "bsb", 3, 80LL, "keepalive@openssh.com", 1LL, 1332084403LL)
    || (unsigned int)ssh_packet_send(a1) == -1 )
  {
    ssh_set_error_oom(a1, "ssh_send_keepalive");
    ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
    return 0xFFFFFFFFLL;
  }
  else
  {
    ssh_handle_packets(a1, 0);
    ssh_log(3, "ssh_send_keepalive", "Sent a keepalive", v1, v2, v3);
    return 0LL;
  }
}
// 4179F: variable 'v1' is possibly undefined
// 4179F: variable 'v2' is possibly undefined
// 4179F: variable 'v3' is possibly undefined

//----- (00000000000417DC) ----------------------------------------------------
__int64 __fastcall bind_socket(__int64 a1, const char *a2, unsigned int a3)
{
  const char *v3; // rax
  int *v5; // rax
  char *v6; // rax
  __int64 v7; // r9
  int *v8; // rax
  char *v9; // rax
  __int64 v10; // r9
  int *v11; // rax
  char *v12; // rax
  int optval; // [rsp+24h] [rbp-4Ch] BYREF
  int ecode; // [rsp+28h] [rbp-48h]
  int fd; // [rsp+2Ch] [rbp-44h]
  char service[6]; // [rsp+32h] [rbp-3Eh] BYREF
  struct addrinfo *pai; // [rsp+38h] [rbp-38h] BYREF
  struct addrinfo s; // [rsp+40h] [rbp-30h] BYREF

  optval = 1;
  memset(&s, 0, sizeof(s));
  s.ai_flags = 1;
  s.ai_socktype = 1;
  snprintf(service, 6uLL, "%d", a3);
  ecode = getaddrinfo(a2, service, &s, &pai);
  if ( ecode )
  {
    v3 = gai_strerror(ecode);
    ssh_set_error(a1, 2, "bind_socket", "Resolving %s: %s", (__int64)a2, (__int64)v3);
    return 0xFFFFFFFFLL;
  }
  else
  {
    fd = socket(pai->ai_family, pai->ai_socktype, pai->ai_protocol);
    if ( fd == -1 )
    {
      v5 = __errno_location();
      v6 = strerror(*v5);
      ssh_set_error(a1, 2, "bind_socket", "%s", (__int64)v6, v7);
      freeaddrinfo(pai);
      return 0xFFFFFFFFLL;
    }
    else if ( setsockopt(fd, 1, 2, &optval, 4u) >= 0 )
    {
      if ( bind(fd, pai->ai_addr, pai->ai_addrlen) )
      {
        v11 = __errno_location();
        v12 = strerror(*v11);
        ssh_set_error(a1, 2, "bind_socket", "Binding to %s:%d: %s", (__int64)a2, a3, v12);
        freeaddrinfo(pai);
        if ( fd != -1 )
        {
          close(fd);
          fd = -1;
        }
        return 0xFFFFFFFFLL;
      }
      else
      {
        freeaddrinfo(pai);
        return (unsigned int)fd;
      }
    }
    else
    {
      v8 = __errno_location();
      v9 = strerror(*v8);
      ssh_set_error(a1, 2, "bind_socket", "Setting socket options failed: %s", (__int64)v9, v10);
      freeaddrinfo(pai);
      if ( fd != -1 )
      {
        close(fd);
        fd = -1;
      }
      return 0xFFFFFFFFLL;
    }
  }
}
// 418FC: variable 'v7' is possibly undefined
// 4196F: variable 'v10' is possibly undefined

//----- (0000000000041A47) ----------------------------------------------------
_DWORD *ssh_bind_new()
{
  _DWORD *s; // [rsp+8h] [rbp-8h]

  s = malloc(0x4E0uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x4E0uLL);
  s[308] = -1;
  s[309] = 22;
  s[260] = 0;
  return s;
}

//----- (0000000000041AB8) ----------------------------------------------------
__int64 __fastcall ssh_bind_import_keys(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  unsigned int v13; // eax
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // r9
  int v23; // [rsp+1Ch] [rbp-4h]
  int v24; // [rsp+1Ch] [rbp-4h]
  int v25; // [rsp+1Ch] [rbp-4h]
  int v26; // [rsp+1Ch] [rbp-4h]

  if ( !*(_QWORD *)(a1 + 1160) && !*(_QWORD *)(a1 + 1168) && !*(_QWORD *)(a1 + 1176) && !*(_QWORD *)(a1 + 1184) )
  {
    ssh_set_error(a1, 2, "ssh_bind_import_keys", "ECDSA, ED25519, DSA, or RSA host key file must be set", a5, a6);
    return 0xFFFFFFFFLL;
  }
  if ( !*(_QWORD *)(a1 + 1192) && *(_QWORD *)(a1 + 1160) )
  {
    v23 = ssh_pki_import_privkey_file(*(const char **)(a1 + 1160), 0LL, 0LL, 0LL, (_QWORD *)(a1 + 1192));
    if ( v23 == -1 || v23 == -127 )
    {
      ssh_set_error(a1, 2, "ssh_bind_import_keys", "Failed to import private ECDSA host key", v7, v8);
      return 0xFFFFFFFFLL;
    }
    if ( (unsigned int)ssh_key_type(*(unsigned int **)(a1 + 1192)) != 4 )
    {
      ssh_set_error(a1, 2, "ssh_bind_import_keys", "The ECDSA host key has the wrong type", v9, v10);
      ssh_key_free(*(void **)(a1 + 1192));
      *(_QWORD *)(a1 + 1192) = 0LL;
      return 0xFFFFFFFFLL;
    }
  }
  if ( !*(_QWORD *)(a1 + 1200) && *(_QWORD *)(a1 + 1168) )
  {
    v24 = ssh_pki_import_privkey_file(*(const char **)(a1 + 1168), 0LL, 0LL, 0LL, (_QWORD *)(a1 + 1200));
    if ( v24 == -1 || v24 == -127 )
    {
      ssh_set_error(a1, 2, "ssh_bind_import_keys", "Failed to import private DSA host key", v11, v12);
      return 0xFFFFFFFFLL;
    }
    if ( (unsigned int)ssh_key_type(*(unsigned int **)(a1 + 1200)) != 1 )
    {
      v13 = ssh_key_type(*(unsigned int **)(a1 + 1200));
      ssh_set_error(a1, 2, "ssh_bind_import_keys", "The DSA host key has the wrong type: %d", v13, v14);
      ssh_key_free(*(void **)(a1 + 1200));
      *(_QWORD *)(a1 + 1200) = 0LL;
      return 0xFFFFFFFFLL;
    }
  }
  if ( !*(_QWORD *)(a1 + 1208) && *(_QWORD *)(a1 + 1176) )
  {
    v25 = ssh_pki_import_privkey_file(*(const char **)(a1 + 1176), 0LL, 0LL, 0LL, (_QWORD *)(a1 + 1208));
    if ( v25 == -1 || v25 == -127 )
    {
      ssh_set_error(a1, 2, "ssh_bind_import_keys", "Failed to import private RSA host key", v15, v16);
      return 0xFFFFFFFFLL;
    }
    if ( (unsigned int)ssh_key_type(*(unsigned int **)(a1 + 1208)) != 2 )
    {
      ssh_set_error(a1, 2, "ssh_bind_import_keys", "The RSA host key has the wrong type", v17, v18);
      ssh_key_free(*(void **)(a1 + 1208));
      *(_QWORD *)(a1 + 1208) = 0LL;
      return 0xFFFFFFFFLL;
    }
  }
  if ( *(_QWORD *)(a1 + 1216) || !*(_QWORD *)(a1 + 1184) )
    return 0LL;
  v26 = ssh_pki_import_privkey_file(*(const char **)(a1 + 1184), 0LL, 0LL, 0LL, (_QWORD *)(a1 + 1216));
  if ( v26 == -1 || v26 == -127 )
  {
    ssh_set_error(a1, 2, "ssh_bind_import_keys", "Failed to import private ED25519 host key", v19, v20);
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned int)ssh_key_type(*(unsigned int **)(a1 + 1216)) == 5 )
    return 0LL;
  ssh_set_error(a1, 2, "ssh_bind_import_keys", "The ED25519 host key has the wrong type", v21, v22);
  ssh_key_free(*(void **)(a1 + 1216));
  *(_QWORD *)(a1 + 1216) = 0LL;
  return 0xFFFFFFFFLL;
}
// 41BB8: variable 'v7' is possibly undefined
// 41BB8: variable 'v8' is possibly undefined
// 41BFE: variable 'v9' is possibly undefined
// 41BFE: variable 'v10' is possibly undefined
// 41CB5: variable 'v11' is possibly undefined
// 41CB5: variable 'v12' is possibly undefined
// 41D13: variable 'v14' is possibly undefined
// 41DCA: variable 'v15' is possibly undefined
// 41DCA: variable 'v16' is possibly undefined
// 41E10: variable 'v17' is possibly undefined
// 41E10: variable 'v18' is possibly undefined
// 41EC7: variable 'v19' is possibly undefined
// 41EC7: variable 'v20' is possibly undefined
// 41F0A: variable 'v21' is possibly undefined
// 41F0A: variable 'v22' is possibly undefined

//----- (0000000000041F3F) ----------------------------------------------------
__int64 __fastcall ssh_bind_listen(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int *v7; // rax
  char *v8; // rax
  unsigned int fd; // [rsp+14h] [rbp-Ch]
  const char *v10; // [rsp+18h] [rbp-8h]

  if ( !*(_QWORD *)(a1 + 1208)
    && !*(_QWORD *)(a1 + 1200)
    && !*(_QWORD *)(a1 + 1192)
    && !*(_QWORD *)(a1 + 1216)
    && (unsigned int)ssh_bind_import_keys(a1, a2, a3, a4, a5, a6) )
  {
    return 0xFFFFFFFFLL;
  }
  if ( *(_DWORD *)(a1 + 1232) == -1 )
  {
    v10 = *(const char **)(a1 + 1224);
    if ( !v10 )
      v10 = "0.0.0.0";
    fd = bind_socket(a1, v10, *(_DWORD *)(a1 + 1236));
    if ( fd == -1 )
      goto LABEL_11;
    if ( listen(fd, 10) < 0 )
    {
      v7 = __errno_location();
      v8 = strerror(*v7);
      ssh_set_error(a1, 2, "ssh_bind_listen", "Listening to socket %d: %s", fd, (__int64)v8);
      close(fd);
LABEL_11:
      ssh_key_free(*(void **)(a1 + 1200));
      *(_QWORD *)(a1 + 1200) = 0LL;
      ssh_key_free(*(void **)(a1 + 1208));
      *(_QWORD *)(a1 + 1208) = 0LL;
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(a1 + 1232) = fd;
  }
  else
  {
    ssh_log(2, "ssh_bind_listen", "Using app-provided bind socket", a4, a5, a6);
  }
  return 0LL;
}
// 420AD: conditional instruction was optimized away because %fd.4!=FFFFFFFF
// 42132: variable 'a4' is possibly undefined
// 42132: variable 'a5' is possibly undefined
// 42132: variable 'a6' is possibly undefined

//----- (000000000004213E) ----------------------------------------------------
__int64 __fastcall ssh_bind_set_callbacks(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a2 )
  {
    if ( *a2 && *a2 <= 0x2000uLL )
    {
      *(_QWORD *)(a1 + 1048) = a2;
      *(_QWORD *)(a1 + 1056) = a3;
      return 0LL;
    }
    else
    {
      ssh_set_error(a1, 2, "ssh_bind_set_callbacks", "Invalid callback passed in (badly initialized)", a5, a6);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error_invalid(a1, "ssh_bind_set_callbacks", a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (00000000000421EF) ----------------------------------------------------
__int64 __fastcall ssh_bind_poll_callback(__int64 a1, __int64 a2, char a3, __int64 a4)
{
  if ( (a3 & 1) != 0
    && *(_QWORD *)(a4 + 1048)
    && (unsigned __int64)(*(_QWORD *)(a4 + 1048) + 8LL) < *(_QWORD *)(a4 + 1048) + **(_QWORD **)(a4 + 1048)
    && *(_QWORD *)(*(_QWORD *)(a4 + 1048) + 8LL) )
  {
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a4 + 1048) + 8LL))(a4, *(_QWORD *)(a4 + 1056));
  }
  return 0LL;
}

//----- (0000000000042298) ----------------------------------------------------
__int64 __fastcall ssh_bind_get_poll(__int64 a1)
{
  if ( !*(_QWORD *)(a1 + 1064) )
    *(_QWORD *)(a1 + 1064) = ssh_poll_new(*(_DWORD *)(a1 + 1232), 1, (__int64)ssh_bind_poll_callback, a1);
  return *(_QWORD *)(a1 + 1064);
}

//----- (0000000000042300) ----------------------------------------------------
__int64 __fastcall ssh_bind_set_blocking(__int64 a1, int a2)
{
  __int64 result; // rax

  result = a1;
  *(_DWORD *)(a1 + 1240) = a2 != 0;
  return result;
}

//----- (0000000000042322) ----------------------------------------------------
__int64 __fastcall ssh_bind_get_fd(__int64 a1)
{
  return *(unsigned int *)(a1 + 1232);
}

//----- (0000000000042336) ----------------------------------------------------
__int64 __fastcall ssh_bind_set_fd(__int64 a1, int a2)
{
  __int64 result; // rax

  result = a1;
  *(_DWORD *)(a1 + 1232) = a2;
  return result;
}

//----- (0000000000042351) ----------------------------------------------------
__int64 __fastcall ssh_bind_fd_toaccept(__int64 a1)
{
  __int64 result; // rax

  result = a1;
  *(_DWORD *)(a1 + 1244) = 1;
  return result;
}

//----- (000000000004236A) ----------------------------------------------------
void __fastcall ssh_bind_free(__int64 a1)
{
  int i; // [rsp+1Ch] [rbp-4h]

  if ( a1 )
  {
    if ( *(int *)(a1 + 1232) >= 0 )
    {
      close(*(_DWORD *)(a1 + 1232));
      *(_DWORD *)(a1 + 1232) = -1;
    }
    *(_DWORD *)(a1 + 1232) = -1;
    if ( *(_QWORD *)(a1 + 1152) )
    {
      free(*(void **)(a1 + 1152));
      *(_QWORD *)(a1 + 1152) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1224) )
    {
      free(*(void **)(a1 + 1224));
      *(_QWORD *)(a1 + 1224) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1168) )
    {
      free(*(void **)(a1 + 1168));
      *(_QWORD *)(a1 + 1168) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1176) )
    {
      free(*(void **)(a1 + 1176));
      *(_QWORD *)(a1 + 1176) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1160) )
    {
      free(*(void **)(a1 + 1160));
      *(_QWORD *)(a1 + 1160) = 0LL;
    }
    if ( *(_QWORD *)(a1 + 1184) )
    {
      free(*(void **)(a1 + 1184));
      *(_QWORD *)(a1 + 1184) = 0LL;
    }
    ssh_key_free(*(void **)(a1 + 1200));
    *(_QWORD *)(a1 + 1200) = 0LL;
    ssh_key_free(*(void **)(a1 + 1208));
    *(_QWORD *)(a1 + 1208) = 0LL;
    ssh_key_free(*(void **)(a1 + 1192));
    *(_QWORD *)(a1 + 1192) = 0LL;
    ssh_key_free(*(void **)(a1 + 1216));
    *(_QWORD *)(a1 + 1216) = 0LL;
    for ( i = 0; i <= 9; ++i )
    {
      if ( *(_QWORD *)(a1 + 8 * (i + 134LL)) )
      {
        free(*(void **)(a1 + 8 * (i + 134LL)));
        *(_QWORD *)(a1 + 8 * (i + 134LL)) = 0LL;
      }
    }
    free((void *)a1);
  }
}
// 42601: conditional instruction was optimized away because rdi.8!=0

//----- (000000000004261C) ----------------------------------------------------
__int64 __fastcall ssh_bind_accept_fd(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  int i; // [rsp+28h] [rbp-8h]

  if ( !a2 )
  {
    ssh_set_error(a1, 2, "ssh_bind_accept_fd", "session is null", a5, a6);
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a2 + 1076) = 1;
  for ( i = 0; i <= 9; ++i )
  {
    if ( *(_QWORD *)(a1 + 8 * (i + 134LL)) )
    {
      *(_QWORD *)(a2 + 8 * (i + 188LL) + 16) = strdup(*(const char **)(a1 + 8 * (i + 134LL)));
      if ( !*(_QWORD *)(a2 + 8 * (i + 188LL) + 16) )
        return 0xFFFFFFFFLL;
    }
  }
  if ( *(_QWORD *)(a1 + 1224) )
  {
    if ( *(_QWORD *)(a2 + 1488) )
    {
      free(*(void **)(a2 + 1488));
      *(_QWORD *)(a2 + 1488) = 0LL;
    }
    *(_QWORD *)(a2 + 1488) = strdup(*(const char **)(a1 + 1224));
    if ( !*(_QWORD *)(a2 + 1488) )
      return 0xFFFFFFFFLL;
  }
  else
  {
    *(_QWORD *)(a2 + 1488) = 0LL;
  }
  *(_DWORD *)(a2 + 1040) = *(_DWORD *)(a1 + 1040);
  if ( *(_QWORD *)(a1 + 1152) )
    *(_QWORD *)(a2 + 1608) = strdup(*(const char **)(a1 + 1152));
  ssh_socket_free(*(__int64 **)(a2 + 1048));
  *(_QWORD *)(a2 + 1048) = ssh_socket_new(a2);
  if ( !*(_QWORD *)(a2 + 1048) )
    goto LABEL_34;
  ssh_socket_set_fd(*(_QWORD *)(a2 + 1048), a3);
  ssh_socket_get_poll_handle_out(*(_QWORD *)(a2 + 1048));
  if ( !*(_QWORD *)(a1 + 1208)
    && !*(_QWORD *)(a1 + 1200)
    && !*(_QWORD *)(a1 + 1192)
    && !*(_QWORD *)(a1 + 1216)
    && (unsigned int)ssh_bind_import_keys(a1, a3, v7, v8, v9, v10) )
  {
    return 0xFFFFFFFFLL;
  }
  if ( (!*(_QWORD *)(a1 + 1192) || (*(_QWORD *)(a2 + 1304) = ssh_key_dup(*(_QWORD *)(a1 + 1192))) != 0LL)
    && (!*(_QWORD *)(a1 + 1200) || (*(_QWORD *)(a2 + 1296) = ssh_key_dup(*(_QWORD *)(a1 + 1200))) != 0LL)
    && (!*(_QWORD *)(a1 + 1208) || (*(_QWORD *)(a2 + 1288) = ssh_key_dup(*(_QWORD *)(a1 + 1208))) != 0LL)
    && (!*(_QWORD *)(a1 + 1216) || (*(_QWORD *)(a2 + 1312) = ssh_key_dup(*(_QWORD *)(a1 + 1216))) != 0LL) )
  {
    ssh_reseed();
    return 0LL;
  }
  else
  {
LABEL_34:
    ssh_set_error_oom(a1, "ssh_bind_accept_fd");
    return 0xFFFFFFFFLL;
  }
}
// 42899: variable 'v7' is possibly undefined
// 42899: variable 'v8' is possibly undefined
// 42899: variable 'v9' is possibly undefined
// 42899: variable 'v10' is possibly undefined

//----- (0000000000042A2F) ----------------------------------------------------
__int64 __fastcall ssh_bind_accept(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r8
  __int64 v8; // r9
  int *v9; // rax
  char *v10; // rax
  __int64 v11; // r9
  int fd; // [rsp+18h] [rbp-8h]
  unsigned int v13; // [rsp+1Ch] [rbp-4h]

  if ( *(_DWORD *)(a1 + 1232) == -1 )
  {
    ssh_set_error(a1, 2, "ssh_bind_accept", "Can't accept new clients on a not bound socket.", a5, a6);
    return 0xFFFFFFFFLL;
  }
  else if ( a2 )
  {
    fd = accept(*(_DWORD *)(a1 + 1232), 0LL, 0LL);
    if ( fd == -1 )
    {
      v9 = __errno_location();
      v10 = strerror(*v9);
      ssh_set_error(a1, 2, "ssh_bind_accept", "Accepting a new connection: %s", (__int64)v10, v11);
      return 0xFFFFFFFFLL;
    }
    else
    {
      v13 = ssh_bind_accept_fd(a1, a2, fd, a2, v7, v8);
      if ( v13 == -1 )
      {
        close(fd);
        ssh_socket_free(*(__int64 **)(a2 + 1048));
      }
      return v13;
    }
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_bind_accept", "session is null", a5, a6);
    return 0xFFFFFFFFLL;
  }
}
// 42B3E: conditional instruction was optimized away because %fd.4!=FFFFFFFF
// 42B0F: variable 'v11' is possibly undefined
// 42B2C: variable 'v7' is possibly undefined
// 42B2C: variable 'v8' is possibly undefined

//----- (0000000000042B69) ----------------------------------------------------
void *__fastcall initcompress(__int64 a1, unsigned int a2)
{
  __int64 v3; // r9
  unsigned int v4; // [rsp+14h] [rbp-Ch]
  void *s; // [rsp+18h] [rbp-8h]

  s = malloc(0x70uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x70uLL);
  v4 = deflateInit_(s, a2, "1.2.8", 112LL);
  if ( !v4 )
    return s;
  free(s);
  ssh_set_error(a1, 2, "initcompress", "status %d inititalising zlib deflate", v4, v3);
  return 0LL;
}
// 42BDE: conditional instruction was optimized away because %s.8!=0
// 42C19: variable 'v3' is possibly undefined
// DC40: using guessed type __int64 __fastcall deflateInit_(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000042C2B) ----------------------------------------------------
void *__fastcall gzip_compress(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rbx
  __int64 v5; // r9
  unsigned int v7; // [rsp+24h] [rbp-104Ch]
  __int64 v8; // [rsp+28h] [rbp-1048h]
  __int64 v9; // [rsp+30h] [rbp-1040h]
  int len; // [rsp+38h] [rbp-1038h]
  void *v11; // [rsp+40h] [rbp-1030h]
  char v12[4088]; // [rsp+50h] [rbp-1020h] BYREF
  int v13; // [rsp+1048h] [rbp-28h]
  unsigned __int64 v14; // [rsp+1058h] [rbp-18h]

  v14 = __readfsqword(0x28u);
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 352LL);
  v9 = ssh_buffer_get(a2);
  len = ssh_buffer_get_len(a2);
  memset(v12, 0, sizeof(v12));
  v13 = 0;
  if ( !v8 )
  {
    v3 = *(_QWORD *)(a1 + 1232);
    *(_QWORD *)(v3 + 352) = initcompress(a1, a3);
    v8 = *(_QWORD *)(v3 + 352);
    if ( !v8 )
      return 0LL;
  }
  v11 = ssh_buffer_new();
  if ( !v11 )
    return 0LL;
  *(_QWORD *)(v8 + 24) = v12;
  *(_QWORD *)v8 = v9;
  *(_DWORD *)(v8 + 8) = len;
  do
  {
    *(_DWORD *)(v8 + 32) = 4092;
    v7 = deflate(v8, 1LL);
    if ( v7 )
    {
      ssh_buffer_free((__int64)v11);
      ssh_set_error(a1, 2, "gzip_compress", "status %d deflating zlib packet", v7, v5);
      return 0LL;
    }
    if ( (int)ssh_buffer_add_data((__int64)v11, v12, 4092 - *(_DWORD *)(v8 + 32)) < 0 )
    {
      ssh_buffer_free((__int64)v11);
      return 0LL;
    }
    *(_QWORD *)(v8 + 24) = v12;
  }
  while ( !*(_DWORD *)(v8 + 32) );
  return v11;
}
// 42DE8: variable 'v5' is possibly undefined
// DAE0: using guessed type __int64 __fastcall deflate(_QWORD, _QWORD);

//----- (0000000000042E98) ----------------------------------------------------
__int64 __fastcall compress_buffer(__int64 a1, __int64 a2)
{
  unsigned int len; // ebx
  const void *v4; // rax
  void *v5; // [rsp+18h] [rbp-18h]

  v5 = gzip_compress(a1, a2, *(char *)(a1 + 1644));
  if ( !v5 )
    return 0xFFFFFFFFLL;
  if ( (int)ssh_buffer_reinit(a2) < 0
    || (len = ssh_buffer_get_len((__int64)v5),
        v4 = (const void *)ssh_buffer_get((__int64)v5),
        (int)ssh_buffer_add_data(a2, v4, len) < 0) )
  {
    ssh_buffer_free((__int64)v5);
    return 0xFFFFFFFFLL;
  }
  else
  {
    ssh_buffer_free((__int64)v5);
    return 0LL;
  }
}

//----- (0000000000042F64) ----------------------------------------------------
void *__fastcall initdecompress(__int64 a1)
{
  __int64 v2; // r9
  unsigned int v3; // [rsp+14h] [rbp-Ch]
  void *s; // [rsp+18h] [rbp-8h]

  s = malloc(0x70uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x70uLL);
  v3 = inflateInit_(s, "1.2.8", 112LL);
  if ( !v3 )
    return s;
  free(s);
  ssh_set_error(a1, 2, "initdecompress", "Status = %d initiating inflate context!", v3, v2);
  return 0LL;
}
// 42FD3: conditional instruction was optimized away because %s.8!=0
// 4300E: variable 'v2' is possibly undefined
// DE90: using guessed type __int64 __fastcall inflateInit_(_QWORD, _QWORD, _QWORD);

//----- (0000000000043020) ----------------------------------------------------
void *__fastcall gzip_decompress(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rbx
  __int64 v5; // r9
  unsigned int v7; // [rsp+24h] [rbp-104Ch]
  __int64 v8; // [rsp+28h] [rbp-1048h]
  __int64 v9; // [rsp+30h] [rbp-1040h]
  int len; // [rsp+38h] [rbp-1038h]
  void *v11; // [rsp+40h] [rbp-1030h]
  char v12[4088]; // [rsp+50h] [rbp-1020h] BYREF
  int v13; // [rsp+1048h] [rbp-28h]
  unsigned __int64 v14; // [rsp+1058h] [rbp-18h]

  v14 = __readfsqword(0x28u);
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 1232) + 360LL);
  v9 = ssh_buffer_get(a2);
  len = ssh_buffer_get_len(a2);
  memset(v12, 0, sizeof(v12));
  v13 = 0;
  if ( !v8 )
  {
    v3 = *(_QWORD *)(a1 + 1232);
    *(_QWORD *)(v3 + 360) = initdecompress(a1);
    v8 = *(_QWORD *)(v3 + 360);
    if ( !v8 )
      return 0LL;
  }
  v11 = ssh_buffer_new();
  if ( !v11 )
    return 0LL;
  *(_QWORD *)(v8 + 24) = v12;
  *(_QWORD *)v8 = v9;
  *(_DWORD *)(v8 + 8) = len;
  do
  {
    *(_DWORD *)(v8 + 32) = 4092;
    v7 = inflate(v8, 1LL);
    if ( v7 && v7 != -5 )
    {
      ssh_set_error(a1, 2, "gzip_decompress", "status %d inflating zlib packet", v7, v5);
      ssh_buffer_free((__int64)v11);
      return 0LL;
    }
    if ( (int)ssh_buffer_add_data((__int64)v11, v12, 4092 - *(_DWORD *)(v8 + 32)) < 0
      || (unsigned int)ssh_buffer_get_len((__int64)v11) > a3 )
    {
      ssh_buffer_free((__int64)v11);
      return 0LL;
    }
    *(_QWORD *)(v8 + 24) = v12;
  }
  while ( !*(_DWORD *)(v8 + 32) );
  return v11;
}
// 431D0: variable 'v5' is possibly undefined
// D870: using guessed type __int64 __fastcall inflate(_QWORD, _QWORD);

//----- (00000000000432BF) ----------------------------------------------------
__int64 __fastcall decompress_buffer(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned int len; // ebx
  const void *v5; // rax
  void *v6; // [rsp+28h] [rbp-18h]

  v6 = gzip_decompress(a1, a2, a3);
  if ( !v6 )
    return 0xFFFFFFFFLL;
  if ( (int)ssh_buffer_reinit(a2) < 0
    || (len = ssh_buffer_get_len((__int64)v6),
        v5 = (const void *)ssh_buffer_get((__int64)v6),
        (int)ssh_buffer_add_data(a2, v5, len) < 0) )
  {
    ssh_buffer_free((__int64)v6);
    return 0xFFFFFFFFLL;
  }
  else
  {
    ssh_buffer_free((__int64)v6);
    return 0LL;
  }
}

//----- (0000000000043385) ----------------------------------------------------
__int64 __fastcall crypto_scalarmult_base(__int64 a1, __int64 a2)
{
  return crypto_scalarmult(a1, a2, (__int64)"\t");
}

//----- (00000000000433B1) ----------------------------------------------------
__int64 __fastcall add(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  unsigned int i; // [rsp+20h] [rbp-8h]
  unsigned int v5; // [rsp+24h] [rbp-4h]
  unsigned int v6; // [rsp+24h] [rbp-4h]
  unsigned int v7; // [rsp+24h] [rbp-4h]

  v5 = 0;
  for ( i = 0; i <= 0x1E; ++i )
  {
    v6 = *(_DWORD *)(4LL * i + a2) + *(_DWORD *)(4LL * i + a3) + v5;
    *(_DWORD *)(a1 + 4LL * i) = (unsigned __int8)v6;
    v5 = v6 >> 8;
  }
  v7 = *(_DWORD *)(a2 + 124) + *(_DWORD *)(a3 + 124) + v5;
  result = v7;
  *(_DWORD *)(a1 + 124) = v7;
  return result;
}

//----- (000000000004344F) ----------------------------------------------------
__int64 __fastcall sub(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  unsigned int i; // [rsp+20h] [rbp-8h]
  int v5; // [rsp+24h] [rbp-4h]
  unsigned int v6; // [rsp+24h] [rbp-4h]
  unsigned int v7; // [rsp+24h] [rbp-4h]

  v5 = 218;
  for ( i = 0; i <= 0x1E; ++i )
  {
    v6 = *(_DWORD *)(4LL * i + a2) - *(_DWORD *)(4LL * i + a3) + v5 + 65280;
    *(_DWORD *)(a1 + 4LL * i) = (unsigned __int8)v6;
    v5 = v6 >> 8;
  }
  v7 = *(_DWORD *)(a2 + 124) - *(_DWORD *)(a3 + 124) + v5;
  result = v7;
  *(_DWORD *)(a1 + 124) = v7;
  return result;
}

//----- (00000000000434F9) ----------------------------------------------------
__int64 __fastcall squeeze(__int64 a1)
{
  __int64 result; // rax
  unsigned int i; // [rsp+10h] [rbp-8h]
  unsigned int j; // [rsp+10h] [rbp-8h]
  unsigned int v4; // [rsp+14h] [rbp-4h]
  unsigned int v5; // [rsp+14h] [rbp-4h]
  unsigned int v6; // [rsp+14h] [rbp-4h]
  int v7; // [rsp+14h] [rbp-4h]
  unsigned int v8; // [rsp+14h] [rbp-4h]
  unsigned int v9; // [rsp+14h] [rbp-4h]

  v4 = 0;
  for ( i = 0; i <= 0x1E; ++i )
  {
    v5 = *(_DWORD *)(4LL * i + a1) + v4;
    *(_DWORD *)(a1 + 4LL * i) = (unsigned __int8)v5;
    v4 = v5 >> 8;
  }
  v6 = *(_DWORD *)(a1 + 124) + v4;
  *(_DWORD *)(a1 + 124) = v6 & 0x7F;
  v7 = 19 * (v6 >> 7);
  for ( j = 0; j <= 0x1E; ++j )
  {
    v8 = *(_DWORD *)(4LL * j + a1) + v7;
    *(_DWORD *)(a1 + 4LL * j) = (unsigned __int8)v8;
    v7 = v8 >> 8;
  }
  v9 = *(_DWORD *)(a1 + 124) + v7;
  result = v9;
  *(_DWORD *)(a1 + 124) = v9;
  return result;
}

//----- (00000000000435E8) ----------------------------------------------------
__int64 __fastcall freeze(__int64 a1)
{
  __int64 result; // rax
  unsigned int i; // [rsp+10h] [rbp-88h]
  unsigned int j; // [rsp+10h] [rbp-88h]
  int v4; // [rsp+14h] [rbp-84h]
  int v5[32]; // [rsp+18h] [rbp-80h]

  for ( i = 0; i <= 0x1F; ++i )
    v5[i] = *(_DWORD *)(4LL * i + a1);
  add(a1, a1, (__int64)&minusp);
  result = -((*(_DWORD *)(a1 + 124) >> 7) & 1);
  v4 = -((*(_DWORD *)(a1 + 124) >> 7) & 1);
  for ( j = 0; j <= 0x1F; ++j )
  {
    result = *(_DWORD *)(4LL * j + a1) ^ v4 & ((unsigned int)v5[j] ^ *(_DWORD *)(4LL * j + a1));
    *(_DWORD *)(a1 + 4LL * j) = result;
  }
  return result;
}
// 435E8: using guessed type int var_80[32];

//----- (00000000000436F6) ----------------------------------------------------
__int64 __fastcall mult(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int i; // [rsp+1Ch] [rbp-Ch]
  unsigned int j; // [rsp+20h] [rbp-8h]
  unsigned int k; // [rsp+20h] [rbp-8h]
  int v7; // [rsp+24h] [rbp-4h]

  for ( i = 0; i <= 0x1F; ++i )
  {
    v7 = 0;
    for ( j = 0; j <= i; ++j )
      v7 += *(_DWORD *)(4LL * j + a2) * *(_DWORD *)(4LL * (i - j) + a3);
    for ( k = i + 1; k <= 0x1F; ++k )
      v7 += 38 * *(_DWORD *)(4LL * k + a2) * *(_DWORD *)(4LL * (i - k + 32) + a3);
    *(_DWORD *)(a1 + 4LL * i) = v7;
  }
  return squeeze(a1);
}

//----- (00000000000437E7) ----------------------------------------------------
__int64 __fastcall mult121665(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  unsigned int i; // [rsp+18h] [rbp-8h]
  unsigned int j; // [rsp+18h] [rbp-8h]
  unsigned int v5; // [rsp+1Ch] [rbp-4h]
  unsigned int v6; // [rsp+1Ch] [rbp-4h]
  unsigned int v7; // [rsp+1Ch] [rbp-4h]
  int v8; // [rsp+1Ch] [rbp-4h]
  unsigned int v9; // [rsp+1Ch] [rbp-4h]
  unsigned int v10; // [rsp+1Ch] [rbp-4h]

  v5 = 0;
  for ( i = 0; i <= 0x1E; ++i )
  {
    v6 = 121665 * *(_DWORD *)(4LL * i + a2) + v5;
    *(_DWORD *)(a1 + 4LL * i) = (unsigned __int8)v6;
    v5 = v6 >> 8;
  }
  v7 = 121665 * *(_DWORD *)(a2 + 124) + v5;
  *(_DWORD *)(a1 + 124) = v7 & 0x7F;
  v8 = 19 * (v7 >> 7);
  for ( j = 0; j <= 0x1E; ++j )
  {
    v9 = *(_DWORD *)(4LL * j + a1) + v8;
    *(_DWORD *)(a1 + 4LL * j) = (unsigned __int8)v9;
    v8 = v9 >> 8;
  }
  v10 = *(_DWORD *)(4LL * j + a1) + v8;
  result = v10;
  *(_DWORD *)(a1 + 4LL * j) = v10;
  return result;
}

//----- (00000000000438FA) ----------------------------------------------------
__int64 __fastcall square(__int64 a1, __int64 a2)
{
  unsigned int i; // [rsp+14h] [rbp-Ch]
  unsigned int j; // [rsp+18h] [rbp-8h]
  unsigned int k; // [rsp+18h] [rbp-8h]
  int v6; // [rsp+1Ch] [rbp-4h]
  int v7; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i <= 0x1F; ++i )
  {
    v6 = 0;
    for ( j = 0; i - j > j; ++j )
      v6 += *(_DWORD *)(4LL * j + a2) * *(_DWORD *)(4LL * (i - j) + a2);
    for ( k = i + 1; i - k + 32 > k; ++k )
      v6 += 38 * *(_DWORD *)(4LL * k + a2) * *(_DWORD *)(4LL * (i - k + 32) + a2);
    v7 = 2 * v6;
    if ( (i & 1) == 0 )
      v7 += 38 * *(_DWORD *)(4LL * ((i >> 1) + 16) + a2) * *(_DWORD *)(4LL * ((i >> 1) + 16) + a2)
          + *(_DWORD *)(4LL * (i >> 1) + a2) * *(_DWORD *)(4LL * (i >> 1) + a2);
    *(_DWORD *)(a1 + 4LL * i) = v7;
  }
  return squeeze(a1);
}

//----- (0000000000043A74) ----------------------------------------------------
__int64 __fastcall c_select(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  __int64 result; // rax
  unsigned int i; // [rsp+28h] [rbp-Ch]
  int v7; // [rsp+30h] [rbp-4h]

  result = (unsigned int)(a5 - 1);
  for ( i = 0; i <= 0x3F; ++i )
  {
    v7 = (a5 - 1) & (*(_DWORD *)(4LL * i + a3) ^ *(_DWORD *)(4LL * i + a4));
    *(_DWORD *)(a1 + 4LL * i) = v7 ^ *(_DWORD *)(4LL * i + a4);
    result = (unsigned int)v7 ^ *(_DWORD *)(4LL * i + a3);
    *(_DWORD *)(a2 + 4LL * i) = result;
  }
  return result;
}

//----- (0000000000043B38) ----------------------------------------------------
void __fastcall mainloop(__int64 a1, __int64 a2)
{
  unsigned int i; // [rsp+14h] [rbp-D0Ch]
  unsigned int j; // [rsp+14h] [rbp-D0Ch]
  unsigned int k; // [rsp+14h] [rbp-D0Ch]
  unsigned int n; // [rsp+14h] [rbp-D0Ch]
  int m; // [rsp+18h] [rbp-D08h]
  int v7; // [rsp+1Ch] [rbp-D04h]
  char v8[128]; // [rsp+20h] [rbp-D00h] BYREF
  char v9[128]; // [rsp+A0h] [rbp-C80h] BYREF
  char v10[128]; // [rsp+120h] [rbp-C00h] BYREF
  char v11[128]; // [rsp+1A0h] [rbp-B80h] BYREF
  int v12[64]; // [rsp+220h] [rbp-B00h] BYREF
  int v13[64]; // [rsp+320h] [rbp-A00h] BYREF
  char v14[128]; // [rsp+420h] [rbp-900h] BYREF
  _BYTE v15[128]; // [rsp+4A0h] [rbp-880h] BYREF
  char v16[128]; // [rsp+520h] [rbp-800h] BYREF
  _BYTE v17[128]; // [rsp+5A0h] [rbp-780h] BYREF
  char v18[128]; // [rsp+620h] [rbp-700h] BYREF
  __int64 v19; // [rsp+6A0h] [rbp-680h] BYREF
  char v20[128]; // [rsp+720h] [rbp-600h] BYREF
  __int64 v21; // [rsp+7A0h] [rbp-580h] BYREF
  char v22[128]; // [rsp+820h] [rbp-500h] BYREF
  _BYTE v23[128]; // [rsp+8A0h] [rbp-480h] BYREF
  char v24[128]; // [rsp+920h] [rbp-400h] BYREF
  _BYTE v25[128]; // [rsp+9A0h] [rbp-380h] BYREF
  char v26[128]; // [rsp+A20h] [rbp-300h] BYREF
  _BYTE v27[128]; // [rsp+AA0h] [rbp-280h] BYREF
  char v28[128]; // [rsp+B20h] [rbp-200h] BYREF
  _BYTE v29[128]; // [rsp+BA0h] [rbp-180h] BYREF
  char v30[128]; // [rsp+C20h] [rbp-100h] BYREF
  _BYTE v31[128]; // [rsp+CA0h] [rbp-80h] BYREF

  for ( i = 0; i <= 0x1F; ++i )
    v12[i] = *(_DWORD *)(4LL * i + a1);
  v12[32] = 1;
  for ( j = 33; j <= 0x3F; ++j )
    v12[j] = 0;
  v13[0] = 1;
  for ( k = 1; k <= 0x3F; ++k )
    v13[k] = 0;
  for ( m = 254; m >= 0; --m )
  {
    v7 = ((int)*(unsigned __int8 *)((m >> 3) + a2) >> (m & 7)) & 1;
    c_select((__int64)v14, (__int64)v16, (__int64)v13, (__int64)v12, v7);
    add((__int64)v22, (__int64)v14, (__int64)v15);
    sub((__int64)v23, (__int64)v14, (__int64)v15);
    add((__int64)v24, (__int64)v16, (__int64)v17);
    sub((__int64)v25, (__int64)v16, (__int64)v17);
    square((__int64)v26, (__int64)v22);
    square((__int64)v27, (__int64)v23);
    mult((__int64)v28, (__int64)v24, (__int64)v23);
    mult((__int64)v29, (__int64)v25, (__int64)v22);
    add((__int64)v30, (__int64)v28, (__int64)v29);
    sub((__int64)v31, (__int64)v28, (__int64)v29);
    square((__int64)v8, (__int64)v31);
    sub((__int64)v9, (__int64)v26, (__int64)v27);
    mult121665((__int64)v10, (__int64)v9);
    add((__int64)v11, (__int64)v10, (__int64)v26);
    mult((__int64)v18, (__int64)v26, (__int64)v27);
    mult((__int64)&v19, (__int64)v9, (__int64)v11);
    square((__int64)v20, (__int64)v30);
    mult((__int64)&v21, (__int64)v8, a1);
    c_select((__int64)v13, (__int64)v12, (__int64)v18, (__int64)v20, v7);
  }
  for ( n = 0; n <= 0x3F; ++n )
    *(_DWORD *)(a1 + 4LL * n) = v13[n];
}
// 43B38: using guessed type int var_A00[64];

//----- (0000000000043F6E) ----------------------------------------------------
__int64 __fastcall recip(__int64 a1, __int64 a2)
{
  int i; // [rsp+1Ch] [rbp-504h]
  int j; // [rsp+1Ch] [rbp-504h]
  int k; // [rsp+1Ch] [rbp-504h]
  int m; // [rsp+1Ch] [rbp-504h]
  int n; // [rsp+1Ch] [rbp-504h]
  int ii; // [rsp+1Ch] [rbp-504h]
  char v9[128]; // [rsp+20h] [rbp-500h] BYREF
  char v10[128]; // [rsp+A0h] [rbp-480h] BYREF
  char v11[128]; // [rsp+120h] [rbp-400h] BYREF
  char v12[128]; // [rsp+1A0h] [rbp-380h] BYREF
  char v13[128]; // [rsp+220h] [rbp-300h] BYREF
  char v14[128]; // [rsp+2A0h] [rbp-280h] BYREF
  char v15[128]; // [rsp+320h] [rbp-200h] BYREF
  char v16[128]; // [rsp+3A0h] [rbp-180h] BYREF
  char v17[128]; // [rsp+420h] [rbp-100h] BYREF
  char v18[128]; // [rsp+4A0h] [rbp-80h] BYREF

  square((__int64)v9, a2);
  square((__int64)v18, (__int64)v9);
  square((__int64)v17, (__int64)v18);
  mult((__int64)v10, (__int64)v17, a2);
  mult((__int64)v11, (__int64)v10, (__int64)v9);
  square((__int64)v17, (__int64)v11);
  mult((__int64)v12, (__int64)v17, (__int64)v10);
  square((__int64)v17, (__int64)v12);
  square((__int64)v18, (__int64)v17);
  square((__int64)v17, (__int64)v18);
  square((__int64)v18, (__int64)v17);
  square((__int64)v17, (__int64)v18);
  mult((__int64)v13, (__int64)v17, (__int64)v12);
  square((__int64)v17, (__int64)v13);
  square((__int64)v18, (__int64)v17);
  for ( i = 2; i <= 9; i += 2 )
  {
    square((__int64)v17, (__int64)v18);
    square((__int64)v18, (__int64)v17);
  }
  mult((__int64)v14, (__int64)v18, (__int64)v13);
  square((__int64)v17, (__int64)v14);
  square((__int64)v18, (__int64)v17);
  for ( j = 2; j <= 19; j += 2 )
  {
    square((__int64)v17, (__int64)v18);
    square((__int64)v18, (__int64)v17);
  }
  mult((__int64)v17, (__int64)v18, (__int64)v14);
  square((__int64)v18, (__int64)v17);
  square((__int64)v17, (__int64)v18);
  for ( k = 2; k <= 9; k += 2 )
  {
    square((__int64)v18, (__int64)v17);
    square((__int64)v17, (__int64)v18);
  }
  mult((__int64)v15, (__int64)v17, (__int64)v13);
  square((__int64)v17, (__int64)v15);
  square((__int64)v18, (__int64)v17);
  for ( m = 2; m <= 49; m += 2 )
  {
    square((__int64)v17, (__int64)v18);
    square((__int64)v18, (__int64)v17);
  }
  mult((__int64)v16, (__int64)v18, (__int64)v15);
  square((__int64)v18, (__int64)v16);
  square((__int64)v17, (__int64)v18);
  for ( n = 2; n <= 99; n += 2 )
  {
    square((__int64)v18, (__int64)v17);
    square((__int64)v17, (__int64)v18);
  }
  mult((__int64)v18, (__int64)v17, (__int64)v16);
  square((__int64)v17, (__int64)v18);
  square((__int64)v18, (__int64)v17);
  for ( ii = 2; ii <= 49; ii += 2 )
  {
    square((__int64)v17, (__int64)v18);
    square((__int64)v18, (__int64)v17);
  }
  mult((__int64)v17, (__int64)v18, (__int64)v15);
  square((__int64)v18, (__int64)v17);
  square((__int64)v17, (__int64)v18);
  square((__int64)v18, (__int64)v17);
  square((__int64)v17, (__int64)v18);
  square((__int64)v18, (__int64)v17);
  return mult(a1, (__int64)v18, (__int64)v11);
}

//----- (00000000000444D6) ----------------------------------------------------
__int64 __fastcall crypto_scalarmult(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int i; // [rsp+2Ch] [rbp-1B4h]
  unsigned int j; // [rsp+2Ch] [rbp-1B4h]
  unsigned int k; // [rsp+2Ch] [rbp-1B4h]
  int v7[32]; // [rsp+30h] [rbp-1B0h] BYREF
  _BYTE v8[128]; // [rsp+B0h] [rbp-130h] BYREF
  _BYTE v9[128]; // [rsp+130h] [rbp-B0h] BYREF
  char v10[31]; // [rsp+1B0h] [rbp-30h] BYREF
  char v11; // [rsp+1CFh] [rbp-11h]
  unsigned __int64 v12; // [rsp+1D8h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  for ( i = 0; i <= 0x1F; ++i )
    v10[i] = *(_BYTE *)(i + a2);
  v10[0] &= 0xF8u;
  v11 &= ~0x80u;
  v11 |= 0x40u;
  for ( j = 0; j <= 0x1F; ++j )
    v7[j] = *(unsigned __int8 *)(j + a3);
  mainloop((__int64)v7, (__int64)v10);
  recip((__int64)v8, (__int64)v8);
  mult((__int64)v9, (__int64)v7, (__int64)v8);
  freeze((__int64)v9);
  for ( k = 0; k <= 0x1F; ++k )
    *(_BYTE *)(k + a1) = v7[k + 64];
  return 0LL;
}
// 444D6: using guessed type char var_30[31];

//----- (000000000004466C) ----------------------------------------------------
__int64 __fastcall agent_get_u32(unsigned int *a1)
{
  return _byteswap_ulong(*a1);
}

//----- (00000000000446CA) ----------------------------------------------------
_BYTE *__fastcall agent_put_u32(_BYTE *a1, int a2)
{
  _BYTE *result; // rax

  *a1 = HIBYTE(a2);
  a1[1] = BYTE2(a2);
  a1[2] = BYTE1(a2);
  result = a1 + 3;
  a1[3] = a2;
  return result;
}

//----- (000000000004471B) ----------------------------------------------------
unsigned __int64 __fastcall atomicio(__int64 a1, __int64 a2, unsigned __int64 a3, int a4, __int64 a5, __int64 a6)
{
  __int16 v6; // ax
  int *v8; // rax
  int v9; // edx
  int fd; // [rsp+24h] [rbp-2Ch]
  unsigned __int64 v13; // [rsp+28h] [rbp-28h]
  ssize_t v14; // [rsp+30h] [rbp-20h]
  __int64 v15; // [rsp+30h] [rbp-20h]
  __int64 v16; // [rsp+40h] [rbp-10h]
  struct pollfd v17; // [rsp+48h] [rbp-8h] BYREF

  v13 = 0LL;
  v16 = *(_QWORD *)(a1 + 24);
  if ( v16 )
  {
    while ( a3 > v13 )
    {
      if ( a4 )
        v15 = (int)ssh_channel_read(v16, (void *)(a2 + v13), (int)a3 - (int)v13, 0, a5, a6);
      else
        v15 = (int)ssh_channel_write(v16, v13 + a2, (int)a3 - (int)v13, v13 + a2, a5, a6);
      if ( v15 != -2 )
      {
        if ( v15 == -1 )
          return 0LL;
        v13 += v15;
      }
    }
    return v13;
  }
  else
  {
    fd = ssh_socket_get_fd_in(*(unsigned int **)a1);
    v17.fd = fd;
    if ( a4 )
      v6 = 1;
    else
      v6 = 4;
    v17.events = v6;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( a3 <= v13 )
          return v13;
        v14 = a4 ? read(fd, (void *)(v13 + a2), a3 - v13) : write(fd, (const void *)(v13 + a2), a3 - v13);
        if ( v14 != -1 )
          break;
        if ( *__errno_location() != 4 )
        {
          if ( *__errno_location() != 11 && *__errno_location() != 11 )
            return 0LL;
          ssh_poll(&v17, 1uLL, -1);
        }
      }
      if ( !v14 )
        break;
      v13 += v14;
    }
    v8 = __errno_location();
    if ( a4 )
      v9 = 0;
    else
      v9 = 32;
    *v8 = v9;
    return v13;
  }
}
// 448A6: variable 'a5' is possibly undefined
// 448A6: variable 'a6' is possibly undefined

//----- (0000000000044912) ----------------------------------------------------
_QWORD *__fastcall ssh_agent_new(__int64 a1)
{
  _QWORD *s; // [rsp+18h] [rbp-8h]

  s = malloc(0x20uLL);
  if ( !s )
    return 0LL;
  memset(s, 0, 0x20uLL);
  *((_DWORD *)s + 4) = 0;
  *s = ssh_socket_new(a1);
  if ( *s )
  {
    s[3] = 0LL;
    return s;
  }
  else
  {
    free(s);
    return 0LL;
  }
}
// 44991: conditional instruction was optimized away because %s.8!=0

//----- (00000000000449C0) ----------------------------------------------------
__int64 __fastcall agent_set_channel(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = a1;
  *(_QWORD *)(a1 + 24) = a2;
  return result;
}

//----- (00000000000449DB) ----------------------------------------------------
__int64 __fastcall ssh_set_agent_channel(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 1264) )
  {
    agent_set_channel(*(_QWORD *)(a1 + 1264), a2);
    return 0LL;
  }
  else
  {
    ssh_set_error(a1, 1, "ssh_set_agent_channel", "Session has no active agent", a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000044A55) ----------------------------------------------------
__int64 __fastcall ssh_set_agent_socket(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 1264) )
  {
    ssh_socket_set_fd(**(_QWORD **)(a1 + 1264), a2);
    return 0LL;
  }
  else
  {
    ssh_set_error(a1, 1, "ssh_set_agent_socket", "Session has no active agent", a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000044ACF) ----------------------------------------------------
__int64 __fastcall ssh_agent_close(__int64 *a1)
{
  __int64 result; // rax

  if ( a1 )
    return ssh_socket_close(*a1);
  return result;
}

//----- (0000000000044AF6) ----------------------------------------------------
void __fastcall ssh_agent_free(__int64 *a1)
{
  if ( a1 )
  {
    if ( a1[1] )
      ssh_buffer_free(a1[1]);
    if ( *a1 )
    {
      ssh_agent_close(a1);
      ssh_socket_free((__int64 *)*a1);
    }
    free(a1);
  }
}
// 44B52: conditional instruction was optimized away because rdi.8!=0

//----- (0000000000044B6B) ----------------------------------------------------
__int64 __fastcall agent_connect(__int64 a1)
{
  char *v2; // [rsp+18h] [rbp-8h]

  if ( !a1 || !*(_QWORD *)(a1 + 1264) )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(*(_QWORD *)(a1 + 1264) + 24LL) )
    return 0LL;
  v2 = getenv("SSH_AUTH_SOCK");
  if ( !v2 || !*v2 )
    return 0xFFFFFFFFLL;
  if ( (int)ssh_socket_unix(**(_QWORD **)(a1 + 1264), v2) >= 0 )
    return 0LL;
  return 0xFFFFFFFFLL;
}

//----- (0000000000044C10) ----------------------------------------------------
__int64 __fastcall agent_talk(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  int *v12; // rax
  char *v13; // rax
  __int64 v14; // r8
  __int64 v15; // r9
  int *v17; // rax
  char *v18; // rax
  __int64 v19; // r8
  __int64 v20; // r9
  int *v21; // rax
  char *v22; // rax
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // r8
  __int64 v28; // r9
  __int64 v29; // rcx
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // rcx
  unsigned int len; // [rsp+24h] [rbp-42Ch]
  unsigned int u32; // [rsp+24h] [rbp-42Ch]
  __int64 v36; // [rsp+28h] [rbp-428h]
  unsigned int v37[258]; // [rsp+30h] [rbp-420h] BYREF
  unsigned __int64 v38; // [rsp+438h] [rbp-18h]

  v38 = __readfsqword(0x28u);
  memset(v37, 0, 0x400uLL);
  len = ssh_buffer_get_len(a2);
  ssh_log(4, "agent_talk", "Request length: %u", len, v3, v4);
  agent_put_u32(v37, len);
  if ( atomicio(*(_QWORD *)(a1 + 1264), (__int64)v37, 4uLL, 0, v5, v6) == 4 )
  {
    v7 = ssh_buffer_get(a2);
    if ( atomicio(*(_QWORD *)(a1 + 1264), v7, len, 0, v8, v9) == len )
    {
      if ( atomicio(*(_QWORD *)(a1 + 1264), (__int64)v37, 4uLL, 1, v10, v11) == 4 )
      {
        u32 = agent_get_u32(v37);
        if ( u32 <= (unsigned int)&loc_40000 )
        {
          ssh_log(4, "agent_talk", "Response length: %u", u32, v25, v26);
          while ( u32 )
          {
            v36 = u32;
            if ( u32 > 0x400uLL )
              v36 = 1024LL;
            if ( atomicio(*(_QWORD *)(a1 + 1264), (__int64)v37, v36, 1, v27, v28) != v36 )
            {
              ssh_log(1, "agent_talk", "Error reading response from authentication socket.", v29, v30, v31);
              return 0xFFFFFFFFLL;
            }
            if ( (int)ssh_buffer_add_data(a3, v37, v36) < 0 )
            {
              ssh_log(1, "agent_talk", "Not enough space", v32, v27, v28);
              return 0xFFFFFFFFLL;
            }
            u32 -= v36;
          }
          return 0LL;
        }
        else
        {
          ssh_set_error(a1, 2, "agent_talk", "Authentication response too long: %u", u32, v26);
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        v21 = __errno_location();
        v22 = strerror(*v21);
        ssh_log(1, "agent_talk", "atomicio read response length failed: %s", (__int64)v22, v23, v24);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      v12 = __errno_location();
      v13 = strerror(*v12);
      ssh_log(1, "agent_talk", "atomicio sending request failed: %s", (__int64)v13, v14, v15);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v17 = __errno_location();
    v18 = strerror(*v17);
    ssh_log(1, "agent_talk", "atomicio sending request length failed: %s", (__int64)v18, v19, v20);
    return 0xFFFFFFFFLL;
  }
}
// 44C96: variable 'v3' is possibly undefined
// 44C96: variable 'v4' is possibly undefined
// 44CD4: variable 'v5' is possibly undefined
// 44CD4: variable 'v6' is possibly undefined
// 44D10: variable 'v8' is possibly undefined
// 44D10: variable 'v9' is possibly undefined
// 44D4C: variable 'v14' is possibly undefined
// 44D4C: variable 'v15' is possibly undefined
// 44D84: variable 'v19' is possibly undefined
// 44D84: variable 'v20' is possibly undefined
// 44DB5: variable 'v10' is possibly undefined
// 44DB5: variable 'v11' is possibly undefined
// 44DE9: variable 'v23' is possibly undefined
// 44DE9: variable 'v24' is possibly undefined
// 44E44: variable 'v26' is possibly undefined
// 44E73: variable 'v25' is possibly undefined
// 44EC6: variable 'v27' is possibly undefined
// 44EC6: variable 'v28' is possibly undefined
// 44EEC: variable 'v29' is possibly undefined
// 44EEC: variable 'v30' is possibly undefined
// 44EEC: variable 'v31' is possibly undefined
// 44F36: variable 'v32' is possibly undefined
// 44C10: using guessed type unsigned int var_420[258];

//----- (0000000000044F7F) ----------------------------------------------------
__int64 __fastcall ssh_agent_get_ident_count(__int64 a1)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v6; // rbx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r9
  unsigned int v10; // [rsp+14h] [rbp-2Ch] BYREF
  unsigned int u8; // [rsp+18h] [rbp-28h]
  unsigned int v12; // [rsp+1Ch] [rbp-24h] BYREF
  void *v13; // [rsp+20h] [rbp-20h]
  void *v14; // [rsp+28h] [rbp-18h]

  v14 = 0LL;
  v10 = 0;
  v12 = 0;
  v13 = ssh_buffer_new();
  if ( v13 )
  {
    if ( (int)ssh_buffer_add_u8((__int64)v13, 11) >= 0 )
    {
      v14 = ssh_buffer_new();
      if ( v14 )
      {
        if ( (int)agent_talk(a1, (__int64)v13, (__int64)v14) >= 0 )
        {
          ssh_buffer_free((__int64)v13);
          u8 = ssh_buffer_get_u8((__int64)v14, &v10);
          if ( u8 == 1 )
          {
            ssh_log(1, "ssh_agent_get_ident_count", "Answer type: %d, expected answer: %d", v10, 12LL, v4);
            if ( v10 == 5 || v10 == 102 || v10 == 30 )
            {
              ssh_buffer_free((__int64)v14);
              return 0LL;
            }
            else if ( v10 == 12 )
            {
              ssh_buffer_get_u32((__int64)v14, &v12);
              v6 = *(_QWORD *)(a1 + 1264);
              *(_DWORD *)(v6 + 16) = agent_get_u32(&v12);
              ssh_log(
                3,
                "ssh_agent_get_ident_count",
                "Agent count: %d",
                *(unsigned int *)(*(_QWORD *)(a1 + 1264) + 16LL),
                v7,
                v8);
              if ( *(_DWORD *)(*(_QWORD *)(a1 + 1264) + 16LL) <= 0x400u )
              {
                if ( *(_QWORD *)(*(_QWORD *)(a1 + 1264) + 8LL) )
                  ssh_buffer_reinit(*(_QWORD *)(*(_QWORD *)(a1 + 1264) + 8LL));
                *(_QWORD *)(*(_QWORD *)(a1 + 1264) + 8LL) = v14;
                return *(unsigned int *)(*(_QWORD *)(a1 + 1264) + 16LL);
              }
              else
              {
                ssh_set_error(
                  a1,
                  2,
                  "ssh_agent_get_ident_count",
                  "Too many identities in authentication reply: %d",
                  *(unsigned int *)(*(_QWORD *)(a1 + 1264) + 16LL),
                  v9);
                ssh_buffer_free((__int64)v14);
                return 0xFFFFFFFFLL;
              }
            }
            else
            {
              ssh_set_error(a1, 2, "ssh_agent_get_ident_count", "Bad authentication reply message type: %u", v10, v5);
              ssh_buffer_free((__int64)v14);
              return 0xFFFFFFFFLL;
            }
          }
          else
          {
            ssh_set_error(a1, 2, "ssh_agent_get_ident_count", "Bad authentication reply size: %d", u8, v4);
            ssh_buffer_free((__int64)v14);
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          ssh_buffer_free((__int64)v13);
          ssh_buffer_free((__int64)v14);
          return 0LL;
        }
      }
      else
      {
        ssh_buffer_free((__int64)v13);
        ssh_set_error(a1, 2, "ssh_agent_get_ident_count", "Not enough space", v2, v3);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      ssh_set_error_oom(a1, "ssh_agent_get_ident_count");
      ssh_buffer_free((__int64)v13);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error_oom(a1, "ssh_agent_get_ident_count");
    return 0xFFFFFFFFLL;
  }
}
// 45050: variable 'v2' is possibly undefined
// 45050: variable 'v3' is possibly undefined
// 450E9: variable 'v4' is possibly undefined
// 45187: variable 'v5' is possibly undefined
// 451F7: variable 'v7' is possibly undefined
// 451F7: variable 'v8' is possibly undefined
// 45241: variable 'v9' is possibly undefined

//----- (00000000000452AC) ----------------------------------------------------
__int64 __fastcall ssh_agent_get_first_ident(__int64 a1, void **a2)
{
  if ( (int)ssh_agent_get_ident_count(a1) <= 0 )
    return 0LL;
  else
    return ssh_agent_get_next_ident(a1, a2);
}

//----- (00000000000452E8) ----------------------------------------------------
__int64 __fastcall ssh_agent_get_next_ident(__int64 a1, void **a2)
{
  int v3; // [rsp+14h] [rbp-1Ch]
  __int64 v4; // [rsp+18h] [rbp-18h] BYREF
  uint32_t *ssh_string; // [rsp+20h] [rbp-10h]
  uint32_t *v6; // [rsp+28h] [rbp-8h]

  ssh_string = 0LL;
  v6 = 0LL;
  if ( !*(_DWORD *)(*(_QWORD *)(a1 + 1264) + 16LL) )
    return 0LL;
  ssh_string = (uint32_t *)ssh_buffer_get_ssh_string(*(_QWORD *)(*(_QWORD *)(a1 + 1264) + 8LL));
  if ( !ssh_string )
    return 0LL;
  v6 = (uint32_t *)ssh_buffer_get_ssh_string(*(_QWORD *)(*(_QWORD *)(a1 + 1264) + 8LL));
  if ( v6 )
  {
    if ( a2 )
    {
      *a2 = ssh_string_to_char(v6);
      ssh_string_free(v6);
      v3 = ssh_pki_import_pubkey_blob(ssh_string, &v4);
      if ( v3 == -1 )
        v3 = ssh_pki_import_cert_blob(ssh_string, &v4);
      ssh_string_free(ssh_string);
      if ( v3 == -1 )
        return 0LL;
      else
        return v4;
    }
    else
    {
      ssh_string_free(ssh_string);
      ssh_string_free(v6);
      return 0LL;
    }
  }
  else
  {
    ssh_string_free(ssh_string);
    return 0LL;
  }
}

//----- (0000000000045423) ----------------------------------------------------
_BOOL8 __fastcall ssh_agent_is_running(__int64 a1)
{
  if ( !a1 || !*(_QWORD *)(a1 + 1264) )
    return 0LL;
  if ( ssh_socket_is_open(**(_DWORD ***)(a1 + 1264)) )
    return 1LL;
  return (int)agent_connect(a1) >= 0;
}

//----- (000000000004548C) ----------------------------------------------------
void *__fastcall ssh_agent_sign_data(__int64 a1, __int64 a2, __int64 a3)
{
  int v4; // eax
  int v5; // eax
  const void *v6; // rax
  int v7; // eax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned int v12; // [rsp+20h] [rbp-30h] BYREF
  uint32_t v13; // [rsp+24h] [rbp-2Ch]
  int v14; // [rsp+28h] [rbp-28h]
  uint32_t hostlong; // [rsp+2Ch] [rbp-24h]
  uint32_t *v16; // [rsp+30h] [rbp-20h] BYREF
  void *v17; // [rsp+38h] [rbp-18h]
  void *v18; // [rsp+40h] [rbp-10h]
  void *ssh_string; // [rsp+48h] [rbp-8h]

  v12 = 0;
  v13 = 0;
  v17 = ssh_buffer_new();
  if ( !v17 )
    return 0LL;
  if ( (int)ssh_buffer_add_u8((__int64)v17, 13) >= 0 )
  {
    if ( (int)ssh_pki_export_pubkey_blob(a2, &v16) < 0 )
      goto LABEL_15;
    v4 = ssh_string_len(v16);
    if ( (int)ssh_buffer_allocate_size((__int64)v17, v4 + 10) < 0 )
      goto LABEL_15;
    v14 = ssh_buffer_add_ssh_string((__int64)v17, v16);
    ssh_string_free(v16);
    if ( v14 >= 0
      && (hostlong = ssh_buffer_get_len(a3), v5 = htonl(hostlong), (int)ssh_buffer_add_u32((__int64)v17, v5) >= 0)
      && (v6 = (const void *)ssh_buffer_get(a3), (int)ssh_buffer_add_data((__int64)v17, v6, hostlong) >= 0)
      && (v7 = htonl(v13), (int)ssh_buffer_add_u32((__int64)v17, v7) >= 0)
      && (v18 = ssh_buffer_new()) != 0LL )
    {
      if ( (int)agent_talk(a1, (__int64)v17, (__int64)v18) >= 0 )
      {
        ssh_buffer_free((__int64)v17);
        if ( (unsigned int)ssh_buffer_get_u8((__int64)v18, &v12) == 1 )
        {
          if ( v12 == 5 || v12 == 102 || v12 == 30 )
          {
            ssh_log(1, "ssh_agent_sign_data", "Agent reports failure in signing the key", v8, v9, v10);
            ssh_buffer_free((__int64)v18);
            return 0LL;
          }
          else if ( v12 == 14 )
          {
            ssh_string = ssh_buffer_get_ssh_string((__int64)v18);
            ssh_buffer_free((__int64)v18);
            return ssh_string;
          }
          else
          {
            ssh_set_error(a1, 2, "ssh_agent_sign_data", "Bad authentication response: %u", v12, v10);
            ssh_buffer_free((__int64)v18);
            return 0LL;
          }
        }
        else
        {
          ssh_buffer_free((__int64)v18);
          return 0LL;
        }
      }
      else
      {
        ssh_buffer_free((__int64)v17);
        ssh_buffer_free((__int64)v18);
        return 0LL;
      }
    }
    else
    {
LABEL_15:
      ssh_buffer_free((__int64)v17);
      return 0LL;
    }
  }
  else
  {
    ssh_buffer_free((__int64)v17);
    return 0LL;
  }
}
// 4571E: variable 'v8' is possibly undefined
// 4571E: variable 'v9' is possibly undefined
// 4571E: variable 'v10' is possibly undefined

//----- (000000000004579D) ----------------------------------------------------
__int64 __fastcall ssh_userauth_request_service(__int64 a1)
{
  __int64 v1; // rcx
  __int64 v2; // r8
  __int64 v3; // r9
  unsigned int v5; // [rsp+1Ch] [rbp-4h]

  v5 = ssh_service_request(a1, (__int64)"ssh-userauth");
  if ( v5 )
    ssh_log(1, "ssh_userauth_request_service", "Failed to request \"ssh-userauth\" service", v1, v2, v3);
  return v5;
}
// 457DD: variable 'v1' is possibly undefined
// 457DD: variable 'v2' is possibly undefined
// 457DD: variable 'v3' is possibly undefined

//----- (00000000000457E7) ----------------------------------------------------
_BOOL8 __fastcall ssh_auth_response_termination(__int64 a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 1180);
  return v1 && (unsigned int)(v1 - 7) > 3;
}

//----- (000000000004581B) ----------------------------------------------------
__int64 __fastcall ssh_userauth_get_response(__int64 a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-4h]

  v2 = ssh_handle_packets_termination(
         a1,
         0xFFFFFFFE,
         (unsigned int (__fastcall *)(__int64))ssh_auth_response_termination,
         a1);
  if ( v2 == -1 )
    return 0xFFFFFFFFLL;
  if ( !ssh_auth_response_termination(a1) )
    return 4LL;
  switch ( *(_DWORD *)(a1 + 1180) )
  {
    case 0:
    case 7:
    case 8:
    case 9:
    case 0xA:
      v2 = -1;
      break;
    case 1:
      v2 = 2;
      break;
    case 2:
    case 6:
      v2 = 0;
      break;
    case 3:
      v2 = 1;
      break;
    case 4:
      v2 = -1;
      break;
    case 5:
      v2 = 3;
      break;
    default:
      return v2;
  }
  return v2;
}

//----- (00000000000458E3) ----------------------------------------------------
__int64 __fastcall ssh_packet_userauth_banner(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  void *ssh_string; // [rsp+28h] [rbp-8h]

  ssh_string = ssh_buffer_get_ssh_string(a3);
  if ( ssh_string )
  {
    ssh_log(3, "ssh_packet_userauth_banner", "Received SSH_USERAUTH_BANNER packet", v4, v5, v6, a4, a3);
    if ( *(_QWORD *)(a1 + 1112) )
      ssh_string_free(*(void **)(a1 + 1112));
    *(_QWORD *)(a1 + 1112) = ssh_string;
  }
  else
  {
    ssh_log(1, "ssh_packet_userauth_banner", "Invalid SSH_USERAUTH_BANNER packet", v4, v5, v6, a4, a3);
  }
  return 1LL;
}
// 4592B: variable 'v4' is possibly undefined
// 4592B: variable 'v5' is possibly undefined
// 4592B: variable 'v6' is possibly undefined

//----- (0000000000045988) ----------------------------------------------------
__int64 __fastcall ssh_packet_userauth_failure(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r9
  char v8; // [rsp+23h] [rbp-Dh] BYREF
  char *haystack; // [rsp+28h] [rbp-8h] BYREF

  haystack = 0LL;
  v8 = 0;
  if ( (unsigned int)ssh_buffer_unpack(a3, "sb", 2, &haystack, &v8, 1332084403LL, a4, a3) )
  {
    ssh_set_error(a1, 2, "ssh_packet_userauth_failure", "Invalid SSH_MSG_USERAUTH_FAILURE message", v4, v5);
    *(_DWORD *)(a1 + 1180) = 4;
  }
  else
  {
    if ( v8 )
    {
      *(_DWORD *)(a1 + 1180) = 1;
      ssh_log(
        2,
        "ssh_packet_userauth_failure",
        "Partial success. Authentication that can continue: %s",
        (__int64)haystack,
        v4,
        v5);
    }
    else
    {
      *(_DWORD *)(a1 + 1180) = 3;
      ssh_log(
        2,
        "ssh_packet_userauth_failure",
        "Access denied. Authentication that can continue: %s",
        (__int64)haystack,
        v4,
        v5);
      ssh_set_error(
        a1,
        1,
        "ssh_packet_userauth_failure",
        "Access denied. Authentication that can continue: %s",
        (__int64)haystack,
        v6);
    }
    *(_DWORD *)(a1 + 1328) = 0;
    if ( strstr(haystack, "password") )
      *(_DWORD *)(a1 + 1328) |= 2u;
    if ( strstr(haystack, "keyboard-interactive") )
      *(_DWORD *)(a1 + 1328) |= 0x10u;
    if ( strstr(haystack, "publickey") )
      *(_DWORD *)(a1 + 1328) |= 4u;
    if ( strstr(haystack, "hostbased") )
      *(_DWORD *)(a1 + 1328) |= 8u;
    if ( strstr(haystack, "gssapi-with-mic") )
      *(_DWORD *)(a1 + 1328) |= 0x20u;
  }
  if ( haystack )
  {
    free(haystack);
    haystack = 0LL;
  }
  return 1LL;
}
// 45A06: variable 'v4' is possibly undefined
// 45A06: variable 'v5' is possibly undefined
// 45AB2: variable 'v6' is possibly undefined

//----- (0000000000045BDE) ----------------------------------------------------
__int64 __fastcall ssh_packet_userauth_success(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9

  ssh_log(3, "ssh_packet_userauth_success", "Authentication successful", a4, a5, a6, a4, a3);
  ssh_log(4, "ssh_packet_userauth_success", "Received SSH_USERAUTH_SUCCESS", v6, v7, v8);
  *(_DWORD *)(a1 + 1180) = 2;
  *(_DWORD *)(a1 + 1164) = 8;
  *(_DWORD *)(a1 + 1104) |= 2u;
  if ( *(_QWORD *)(a1 + 1232) && *(_DWORD *)(*(_QWORD *)(a1 + 1232) + 348LL) )
  {
    ssh_log(3, "ssh_packet_userauth_success", "Enabling delayed compression OUT", v9, v10, v11);
    *(_DWORD *)(*(_QWORD *)(a1 + 1232) + 336LL) = 1;
  }
  if ( *(_QWORD *)(a1 + 1232) && *(_DWORD *)(*(_QWORD *)(a1 + 1232) + 344LL) )
  {
    ssh_log(3, "ssh_packet_userauth_success", "Enabling delayed compression IN", v9, v10, v11);
    *(_DWORD *)(*(_QWORD *)(a1 + 1232) + 340LL) = 1;
  }
  return 1LL;
}
// 45C2C: variable 'v6' is possibly undefined
// 45C2C: variable 'v7' is possibly undefined
// 45C2C: variable 'v8' is possibly undefined
// 45CA3: variable 'v9' is possibly undefined
// 45CA3: variable 'v10' is possibly undefined
// 45CA3: variable 'v11' is possibly undefined

//----- (0000000000045D1B) ----------------------------------------------------
__int64 __fastcall ssh_packet_userauth_pk_ok(
        __int64 a1,
        unsigned __int8 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9

  ssh_log(4, "ssh_packet_userauth_pk_ok", "Received SSH_USERAUTH_PK_OK/INFO_REQUEST/GSSAPI_RESPONSE", a4, a5, a6);
  if ( *(_DWORD *)(a1 + 1180) == 7 )
  {
    ssh_log(
      4,
      "ssh_packet_userauth_pk_ok",
      "keyboard-interactive context, assuming SSH_USERAUTH_INFO_REQUEST",
      v6,
      v7,
      v8);
    return (unsigned int)ssh_packet_userauth_info_request(a1, a2, a3, a4);
  }
  else
  {
    *(_DWORD *)(a1 + 1180) = 6;
    ssh_log(4, "ssh_packet_userauth_pk_ok", "Assuming SSH_USERAUTH_PK_OK", v6, v7, v8);
    return 1;
  }
}
// 45D78: variable 'v6' is possibly undefined
// 45D78: variable 'v7' is possibly undefined
// 45D78: variable 'v8' is possibly undefined

//----- (0000000000045DD1) ----------------------------------------------------
__int64 __fastcall ssh_userauth_list(__int64 a1)
{
  if ( a1 )
    return *(unsigned int *)(a1 + 1328);
  else
    return 0LL;
}

//----- (0000000000045DF7) ----------------------------------------------------
__int64 __fastcall ssh_userauth_none(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  __int64 v8; // rax
  int v9; // [rsp+1Ch] [rbp-4h]
  unsigned int response; // [rsp+1Ch] [rbp-4h]

  v6 = *(_DWORD *)(a1 + 1160);
  if ( v6 )
  {
    if ( v6 != 2 )
    {
      ssh_set_error(
        a1,
        2,
        "ssh_userauth_none",
        "Wrong state (%d) during pending SSH call",
        *(unsigned int *)(a1 + 1160),
        a6);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v9 = ssh_userauth_request_service(a1);
    if ( v9 == -2 )
      return 4LL;
    if ( v9 == -1 )
      return 0xFFFFFFFFLL;
    if ( a2 )
      v8 = a2;
    else
      v8 = *(_QWORD *)(a1 + 1472);
    if ( (int)ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "bsss", 4, 50LL, v8, "ssh-connection", "none", 1332084403LL) < 0 )
    {
      ssh_set_error_oom(a1, "ssh_userauth_none");
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(a1 + 1180) = 0;
    *(_DWORD *)(a1 + 1160) = 2;
    if ( (unsigned int)ssh_packet_send(a1) == -1 )
      return 0xFFFFFFFFLL;
  }
  response = ssh_userauth_get_response(a1);
  if ( response != 4 )
    *(_DWORD *)(a1 + 1160) = 0;
  return response;
}

//----- (0000000000045F7A) ----------------------------------------------------
__int64 __fastcall ssh_userauth_try_publickey(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v7; // eax
  __int64 v8; // rax
  int v10; // [rsp+24h] [rbp-Ch]
  unsigned int response; // [rsp+24h] [rbp-Ch]
  uint32_t *v12; // [rsp+28h] [rbp-8h] BYREF

  v12 = 0LL;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !a3 || !ssh_key_is_public(a3) )
  {
    ssh_set_error(a1, 2, "ssh_userauth_try_publickey", "Invalid pubkey", a5, a6);
    return 0xFFFFFFFFLL;
  }
  v7 = *(_DWORD *)(a1 + 1160);
  if ( v7 )
  {
    if ( v7 != 4 )
    {
      ssh_set_error(
        a1,
        2,
        "ssh_userauth_try_publickey",
        "Wrong state (%d) during pending SSH call",
        *(unsigned int *)(a1 + 1160),
        a6);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v10 = ssh_userauth_request_service(a1);
    if ( v10 == -2 )
      return 4LL;
    if ( v10 == -1 )
      return 0xFFFFFFFFLL;
    if ( (int)ssh_pki_export_pubkey_blob(a3, &v12) < 0
      || (a2 ? (v8 = a2) : (v8 = *(_QWORD *)(a1 + 1472)),
          (int)ssh_buffer_pack(
                 *(_QWORD *)(a1 + 1152),
                 "bsssbsS",
                 7,
                 50LL,
                 v8,
                 "ssh-connection",
                 "publickey",
                 0LL,
                 *(_QWORD *)(a3 + 8),
                 v12,
                 1332084403LL) < 0) )
    {
      ssh_string_free(v12);
      ssh_set_error_oom(a1, "ssh_userauth_try_publickey");
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
      return 0xFFFFFFFFLL;
    }
    ssh_string_free(v12);
    *(_DWORD *)(a1 + 1180) = 0;
    *(_DWORD *)(a1 + 1160) = 4;
    if ( (unsigned int)ssh_packet_send(a1) == -1 )
      return 0xFFFFFFFFLL;
  }
  response = ssh_userauth_get_response(a1);
  if ( response != 4 )
    *(_DWORD *)(a1 + 1160) = 0;
  return response;
}
// 45FDD: variable 'a5' is possibly undefined
// 45FDD: variable 'a6' is possibly undefined

//----- (00000000000461AE) ----------------------------------------------------
__int64 __fastcall ssh_userauth_publickey(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v7; // eax
  int v8; // eax
  __int64 v9; // rax
  int v11; // [rsp+28h] [rbp-18h]
  int v12; // [rsp+28h] [rbp-18h]
  unsigned int response; // [rsp+28h] [rbp-18h]
  uint32_t *v14; // [rsp+30h] [rbp-10h] BYREF
  const char *v15; // [rsp+38h] [rbp-8h]

  v14 = 0LL;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !a3 || !ssh_key_is_private(a3) )
  {
    ssh_set_error(a1, 2, "ssh_userauth_publickey", "Invalid private key", a5, a6);
    return 0xFFFFFFFFLL;
  }
  v7 = *(_DWORD *)(a1 + 1160);
  if ( v7 )
  {
    if ( v7 != 5 )
    {
      ssh_set_error(
        a1,
        2,
        "ssh_userauth_publickey",
        "Bad call during pending SSH call in ssh_userauth_try_publickey",
        a5,
        a6);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v11 = ssh_userauth_request_service(a1);
    if ( v11 == -2 )
      return 4LL;
    if ( v11 == -1 )
      return 0xFFFFFFFFLL;
    if ( *(_QWORD *)(a3 + 64) )
      v8 = *(_DWORD *)(a3 + 72);
    else
      v8 = *(_DWORD *)a3;
    v15 = ssh_key_type_to_char(v8);
    if ( (int)ssh_pki_export_pubkey_blob(a3, &v14) < 0
      || (a2 ? (v9 = a2) : (v9 = *(_QWORD *)(a1 + 1472)),
          (int)ssh_buffer_pack(
                 *(_QWORD *)(a1 + 1152),
                 "bsssbsS",
                 7,
                 50LL,
                 v9,
                 "ssh-connection",
                 "publickey",
                 1LL,
                 v15,
                 v14,
                 1332084403LL) < 0
       || (ssh_string_free(v14), (v14 = ssh_pki_do_sign(a1, *(_QWORD *)(a1 + 1152), (_DWORD *)a3)) == 0LL)
       || (v12 = ssh_buffer_add_ssh_string(*(_QWORD *)(a1 + 1152), v14), ssh_string_free(v14), v14 = 0LL, v12 < 0)) )
    {
      ssh_string_free(v14);
      ssh_set_error_oom(a1, "ssh_userauth_publickey");
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(a1 + 1180) = 0;
    *(_DWORD *)(a1 + 1160) = 5;
    if ( (unsigned int)ssh_packet_send(a1) == -1 )
      return 0xFFFFFFFFLL;
  }
  response = ssh_userauth_get_response(a1);
  if ( response != 4 )
    *(_DWORD *)(a1 + 1160) = 0;
  return response;
}
// 46211: variable 'a5' is possibly undefined
// 46211: variable 'a6' is possibly undefined

//----- (000000000004646C) ----------------------------------------------------
__int64 __fastcall ssh_userauth_agent_publickey(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  __int64 v8; // rax
  int v10; // [rsp+24h] [rbp-Ch]
  int v11; // [rsp+24h] [rbp-Ch]
  unsigned int response; // [rsp+24h] [rbp-Ch]
  uint32_t *v13; // [rsp+28h] [rbp-8h] BYREF

  v13 = 0LL;
  v6 = *(_DWORD *)(a1 + 1160);
  if ( v6 )
  {
    if ( v6 != 6 )
    {
      ssh_set_error(
        a1,
        2,
        "ssh_userauth_agent_publickey",
        "Bad call during pending SSH call in ssh_userauth_try_publickey",
        a5,
        a6);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v10 = ssh_userauth_request_service(a1);
    if ( v10 == -2 )
      return 4LL;
    if ( v10 == -1 )
      return 0xFFFFFFFFLL;
    if ( (int)ssh_pki_export_pubkey_blob(a3, &v13) < 0
      || (a2 ? (v8 = a2) : (v8 = *(_QWORD *)(a1 + 1472)),
          (int)ssh_buffer_pack(
                 *(_QWORD *)(a1 + 1152),
                 "bsssbsS",
                 7,
                 50LL,
                 v8,
                 "ssh-connection",
                 "publickey",
                 1LL,
                 *(_QWORD *)(a3 + 8),
                 v13,
                 1332084403LL) < 0
       || (ssh_string_free(v13), (v13 = (uint32_t *)ssh_pki_do_sign_agent(a1, *(_QWORD *)(a1 + 1152), a3)) == 0LL)
       || (v11 = ssh_buffer_add_ssh_string(*(_QWORD *)(a1 + 1152), v13), ssh_string_free(v13), v13 = 0LL, v11 < 0)) )
    {
      ssh_set_error_oom(a1, "ssh_userauth_agent_publickey");
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
      ssh_string_free(v13);
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(a1 + 1180) = 0;
    *(_DWORD *)(a1 + 1160) = 6;
    if ( (unsigned int)ssh_packet_send(a1) == -1 )
      return 0xFFFFFFFFLL;
  }
  response = ssh_userauth_get_response(a1);
  if ( response != 4 )
    *(_DWORD *)(a1 + 1160) = 0;
  return response;
}

//----- (00000000000466AD) ----------------------------------------------------
void __fastcall ssh_agent_state_free(void **a1)
{
  if ( a1 )
  {
    ssh_string_free_char(a1[2]);
    ssh_key_free(a1[1]);
    free(a1);
  }
}

//----- (00000000000466F7) ----------------------------------------------------
__int64 __fastcall ssh_userauth_agent(__int64 a1, __int64 a2)
{
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // [rsp+14h] [rbp-Ch]
  __int64 v11; // [rsp+18h] [rbp-8h]

  v10 = -1;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( !ssh_agent_is_running(a1) )
    return 1LL;
  if ( !*(_QWORD *)(a1 + 1192) )
  {
    *(_QWORD *)(a1 + 1192) = malloc(0x18uLL);
    if ( !*(_QWORD *)(a1 + 1192) )
    {
      ssh_set_error_oom(a1, "ssh_userauth_agent");
      return 0xFFFFFFFFLL;
    }
    memset(*(void **)(a1 + 1192), 0, 0x18uLL);
    **(_DWORD **)(a1 + 1192) = 0;
  }
  v11 = *(_QWORD *)(a1 + 1192);
  if ( !*(_QWORD *)(v11 + 8) )
    *(_QWORD *)(v11 + 8) = ssh_agent_get_first_ident(a1, (void **)(v11 + 16));
  if ( !*(_QWORD *)(v11 + 8) )
    return 1LL;
  while ( *(_QWORD *)(v11 + 8) )
  {
    if ( !*(_DWORD *)v11 )
      ssh_log(3, "ssh_userauth_agent", "Trying identity %s", *(_QWORD *)(v11 + 16), v3, v4);
    if ( *(_DWORD *)v11 > 1u )
      goto LABEL_23;
    v10 = ssh_userauth_try_publickey(a1, a2, *(_QWORD *)(v11 + 8), a2, v3, v4);
    if ( v10 == -1 )
    {
      ssh_agent_state_free((void **)v11);
      *(_QWORD *)(a1 + 1192) = 0LL;
      return 0xFFFFFFFFLL;
    }
    if ( v10 == 4 )
    {
      *(_DWORD *)v11 = 1;
      return 4LL;
    }
    if ( v10 )
    {
      ssh_log(3, "ssh_userauth_agent", "Public key of %s refused by server", *(_QWORD *)(v11 + 16), v5, v6);
      ssh_string_free_char(*(void **)(v11 + 16));
      *(_QWORD *)(v11 + 16) = 0LL;
      ssh_key_free(*(void **)(v11 + 8));
      *(_QWORD *)(v11 + 8) = ssh_agent_get_next_ident(a1, (void **)(v11 + 16));
      *(_DWORD *)v11 = 0;
    }
    else
    {
      ssh_log(3, "ssh_userauth_agent", "Public key of %s accepted by server", *(_QWORD *)(v11 + 16), v5, v6);
      *(_DWORD *)v11 = 2;
LABEL_23:
      if ( *(_DWORD *)v11 == 2 )
      {
        v10 = ssh_userauth_agent_publickey(a1, a2, *(_QWORD *)(v11 + 8), a2, v3, v4);
        if ( v10 == 4 )
          return 4LL;
        ssh_string_free_char(*(void **)(v11 + 16));
        *(_QWORD *)(v11 + 16) = 0LL;
        if ( v10 == -1 || v10 == 2 )
          break;
        if ( !v10 )
        {
          ssh_agent_state_free(*(void ***)(a1 + 1192));
          *(_QWORD *)(a1 + 1192) = 0LL;
          return 0LL;
        }
        ssh_log(2, "ssh_userauth_agent", "Server accepted public key but refused the signature", v7, v8, v9);
        ssh_key_free(*(void **)(v11 + 8));
        *(_QWORD *)(v11 + 8) = ssh_agent_get_next_ident(a1, (void **)(v11 + 16));
        *(_DWORD *)v11 = 0;
      }
    }
  }
  ssh_agent_state_free(*(void ***)(a1 + 1192));
  *(_QWORD *)(a1 + 1192) = 0LL;
  return v10;
}
// 46856: variable 'v3' is possibly undefined
// 46856: variable 'v4' is possibly undefined
// 46900: variable 'v5' is possibly undefined
// 46900: variable 'v6' is possibly undefined
// 46A3F: variable 'v7' is possibly undefined
// 46A3F: variable 'v8' is possibly undefined
// 46A3F: variable 'v9' is possibly undefined

//----- (0000000000046AE3) ----------------------------------------------------
__int64 __fastcall ssh_userauth_publickey_auto(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // r9
  unsigned int v18; // [rsp+2Ch] [rbp-434h]
  int v19; // [rsp+2Ch] [rbp-434h]
  int v20; // [rsp+2Ch] [rbp-434h]
  int v21; // [rsp+2Ch] [rbp-434h]
  int v22; // [rsp+2Ch] [rbp-434h]
  unsigned int v23; // [rsp+2Ch] [rbp-434h]
  __int64 (__fastcall *v24)(const char *, char *, __int64, _QWORD, _QWORD, __int64); // [rsp+30h] [rbp-430h]
  const char *v25; // [rsp+38h] [rbp-428h]
  __int64 v26; // [rsp+40h] [rbp-420h]
  const char *v27; // [rsp+48h] [rbp-418h]
  char s[1032]; // [rsp+50h] [rbp-410h] BYREF
  unsigned __int64 v29; // [rsp+458h] [rbp-8h]

  v29 = __readfsqword(0x28u);
  v24 = 0LL;
  v25 = 0LL;
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( (*(_DWORD *)(a1 + 1668) & 2) == 0 )
  {
    *(_DWORD *)(a1 + 1328) &= ~4u;
    return 1LL;
  }
  if ( *(_QWORD *)(a1 + 1032) )
  {
    v24 = *(__int64 (__fastcall **)(const char *, char *, __int64, _QWORD, _QWORD, __int64))(*(_QWORD *)(a1 + 1032)
                                                                                           + 16LL);
    v25 = *(const char **)(*(_QWORD *)(a1 + 1032) + 8LL);
  }
  if ( !*(_QWORD *)(a1 + 1200) )
  {
    *(_QWORD *)(a1 + 1200) = malloc(0x20uLL);
    if ( !*(_QWORD *)(a1 + 1200) )
    {
      ssh_set_error_oom(a1, "ssh_userauth_publickey_auto");
      return 0xFFFFFFFFLL;
    }
    memset(*(void **)(a1 + 1200), 0, 0x20uLL);
  }
  v26 = *(_QWORD *)(a1 + 1200);
  if ( !*(_DWORD *)v26 )
  {
    v18 = ssh_userauth_agent(a1, a2);
    if ( !v18 || v18 == 2 || v18 == 4 )
      return v18;
    *(_DWORD *)v26 = 1;
  }
  if ( !*(_QWORD *)(v26 + 8) )
    *(_QWORD *)(v26 + 8) = ssh_list_get_iterator(*(_QWORD *)(a1 + 1464));
  while ( 1 )
  {
    while ( 1 )
    {
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            if ( !*(_QWORD *)(v26 + 8) )
            {
              ssh_log(2, "ssh_userauth_publickey_auto", "Tried every public key, none matched", a4, a5, a6);
              if ( *(_QWORD *)(a1 + 1200) )
              {
                free(*(void **)(a1 + 1200));
                *(_QWORD *)(a1 + 1200) = 0LL;
              }
              return 1LL;
            }
            v27 = *(const char **)(*(_QWORD *)(v26 + 8) + 8LL);
            memset(s, 0, 0x400uLL);
            a4 = 0LL;
            if ( *(_DWORD *)v26 != 1 )
              break;
            ssh_log(3, "ssh_userauth_publickey_auto", "Trying to authenticate with %s", (__int64)v27, a5, a6);
            *(_QWORD *)(v26 + 16) = 0LL;
            *(_QWORD *)(v26 + 24) = 0LL;
            snprintf(s, 0x400uLL, "%s.pub", v27);
            v19 = ssh_pki_import_pubkey_file(s, (_QWORD *)(v26 + 24));
            if ( v19 == -1 )
            {
              ssh_set_error(a1, 2, "ssh_userauth_publickey_auto", "Failed to import public key: %s", (__int64)s, a6);
              if ( *(_QWORD *)(a1 + 1200) )
              {
                free(*(void **)(a1 + 1200));
                *(_QWORD *)(a1 + 1200) = 0LL;
              }
              return 0xFFFFFFFFLL;
            }
            if ( v19 != -127 )
              goto LABEL_35;
            v20 = ssh_pki_import_privkey_file(v27, a3, v24, v25, (_QWORD *)(v26 + 16));
            if ( v20 == -1 )
            {
              ssh_set_error(a1, 2, "ssh_userauth_publickey_auto", "Failed to read private key: %s", (__int64)v27, v8);
              *(_QWORD *)(v26 + 8) = **(_QWORD **)(v26 + 8);
            }
            else
            {
              if ( v20 != -127 )
              {
                if ( (unsigned int)ssh_pki_export_privkey_to_pubkey(*(_QWORD *)(v26 + 16), (_QWORD *)(v26 + 24)) == -1 )
                {
                  ssh_key_free(*(void **)(v26 + 16));
                  if ( *(_QWORD *)(a1 + 1200) )
                  {
                    free(*(void **)(a1 + 1200));
                    *(_QWORD *)(a1 + 1200) = 0LL;
                  }
                  return 0xFFFFFFFFLL;
                }
                if ( (unsigned int)ssh_pki_export_pubkey_file(*(_QWORD *)(v26 + 24), s) == -1 )
                  ssh_log(
                    1,
                    "ssh_userauth_publickey_auto",
                    "Could not write public key to file: %s",
                    (__int64)s,
                    a5,
                    a6);
LABEL_35:
                *(_DWORD *)v26 = 2;
                break;
              }
              ssh_log(3, "ssh_userauth_publickey_auto", "Private key %s doesn't exist.", (__int64)v27, v7, v8);
              *(_QWORD *)(v26 + 8) = **(_QWORD **)(v26 + 8);
            }
          }
          if ( *(_DWORD *)v26 != 2 )
            goto LABEL_46;
          v21 = ssh_userauth_try_publickey(a1, a2, *(_QWORD *)(v26 + 24), a2, a5, a6);
          if ( v21 == -1 )
          {
            ssh_log(1, "ssh_userauth_publickey_auto", "Public key authentication error for %s", (__int64)v27, a5, a6);
            ssh_key_free(*(void **)(v26 + 16));
            ssh_key_free(*(void **)(v26 + 24));
            if ( *(_QWORD *)(a1 + 1200) )
            {
              free(*(void **)(a1 + 1200));
              *(_QWORD *)(a1 + 1200) = 0LL;
            }
            return 0xFFFFFFFFLL;
          }
          if ( v21 == 4 )
            return 4LL;
          if ( !v21 )
            break;
          ssh_log(3, "ssh_userauth_publickey_auto", "Public key for %s refused by server", (__int64)v27, a5, a6);
          ssh_key_free(*(void **)(v26 + 16));
          *(_QWORD *)(v26 + 16) = 0LL;
          ssh_key_free(*(void **)(v26 + 24));
          *(_QWORD *)(v26 + 24) = 0LL;
          *(_QWORD *)(v26 + 8) = **(_QWORD **)(v26 + 8);
          *(_DWORD *)v26 = 1;
        }
        *(_DWORD *)v26 = 3;
LABEL_46:
        ;
      }
      while ( *(_DWORD *)v26 != 3 );
      if ( *(_QWORD *)(v26 + 16) )
        break;
      v22 = ssh_pki_import_privkey_file(v27, a3, v24, v25, (_QWORD *)(v26 + 16));
      if ( v22 == -1 )
      {
        ssh_key_free(*(void **)(v26 + 24));
        *(_QWORD *)(v26 + 24) = 0LL;
        ssh_set_error(a1, 2, "ssh_userauth_publickey_auto", "Failed to read private key: %s", (__int64)v27, v9);
        *(_QWORD *)(v26 + 8) = **(_QWORD **)(v26 + 8);
        *(_DWORD *)v26 = 1;
      }
      else
      {
        if ( v22 != -127 )
          break;
        ssh_key_free(*(void **)(v26 + 24));
        *(_QWORD *)(v26 + 24) = 0LL;
        ssh_log(2, "ssh_userauth_publickey_auto", "Private key %s doesn't exist.", (__int64)v27, v10, v11);
        *(_QWORD *)(v26 + 8) = **(_QWORD **)(v26 + 8);
        *(_DWORD *)v26 = 1;
      }
    }
    v23 = ssh_userauth_publickey(a1, a2, *(_QWORD *)(v26 + 16), a2, a5, a6);
    if ( v23 != 4 && v23 != 1 )
      break;
    if ( v23 == 4 )
      return 4LL;
    ssh_log(
      1,
      "ssh_userauth_publickey_auto",
      "The server accepted the public key but refused the signature",
      v12,
      v13,
      v14);
    *(_QWORD *)(v26 + 8) = **(_QWORD **)(v26 + 8);
    *(_DWORD *)v26 = 1;
  }
  ssh_key_free(*(void **)(v26 + 16));
  ssh_key_free(*(void **)(v26 + 24));
  if ( *(_QWORD *)(a1 + 1200) )
  {
    free(*(void **)(a1 + 1200));
    *(_QWORD *)(a1 + 1200) = 0LL;
  }
  if ( !v23 )
    ssh_log(2, "ssh_userauth_publickey_auto", "Successfully authenticated using %s", (__int64)v27, v15, v16);
  return v23;
}
// 46D68: variable 'a5' is possibly undefined
// 46D68: variable 'a6' is possibly undefined
// 46ED1: variable 'v8' is possibly undefined
// 46F1F: variable 'v7' is possibly undefined
// 4727F: variable 'v9' is possibly undefined
// 472FC: variable 'v10' is possibly undefined
// 472FC: variable 'v11' is possibly undefined
// 473FC: variable 'v15' is possibly undefined
// 473FC: variable 'v16' is possibly undefined
// 47438: variable 'v12' is possibly undefined
// 47438: variable 'v13' is possibly undefined
// 47438: variable 'v14' is possibly undefined
// 4748F: variable 'a4' is possibly undefined

//----- (00000000000474EA) ----------------------------------------------------
__int64 __fastcall ssh_userauth_password(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  __int64 v8; // rax
  int v10; // [rsp+2Ch] [rbp-4h]
  unsigned int response; // [rsp+2Ch] [rbp-4h]

  v6 = *(_DWORD *)(a1 + 1160);
  if ( v6 )
  {
    if ( v6 != 4 )
    {
      ssh_set_error(
        a1,
        2,
        "ssh_userauth_password",
        "Wrong state (%d) during pending SSH call",
        *(unsigned int *)(a1 + 1160),
        a6);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v10 = ssh_userauth_request_service(a1);
    if ( v10 == -2 )
      return 4LL;
    if ( v10 == -1 )
      return 0xFFFFFFFFLL;
    if ( a2 )
      v8 = a2;
    else
      v8 = *(_QWORD *)(a1 + 1472);
    if ( (int)ssh_buffer_pack(
                *(_QWORD *)(a1 + 1152),
                "bsssbs",
                6,
                50LL,
                v8,
                "ssh-connection",
                "password",
                0LL,
                a3,
                1332084403LL) < 0 )
    {
      ssh_set_error_oom(a1, "ssh_userauth_password");
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(a1 + 1180) = 0;
    *(_DWORD *)(a1 + 1160) = 4;
    if ( (unsigned int)ssh_packet_send(a1) == -1 )
      return 0xFFFFFFFFLL;
  }
  response = ssh_userauth_get_response(a1);
  if ( response != 4 )
    *(_DWORD *)(a1 + 1160) = 0;
  return response;
}

//----- (0000000000047676) ----------------------------------------------------
__int64 __fastcall ssh_userauth_agent_pubkey(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // r8
  __int64 v5; // r9
  unsigned int v7; // [rsp+24h] [rbp-Ch]
  _QWORD *v8; // [rsp+28h] [rbp-8h]

  v8 = ssh_key_new();
  if ( !v8 )
    return 0xFFFFFFFFLL;
  *(_DWORD *)v8 = *(_DWORD *)a3;
  v8[1] = ssh_key_type_to_char(*(_DWORD *)v8);
  *((_DWORD *)v8 + 1) = 1;
  v8[3] = *(_QWORD *)(a3 + 16);
  v8[4] = *(_QWORD *)(a3 + 24);
  v7 = ssh_userauth_agent_publickey(a1, a2, (__int64)v8, a2, v4, v5);
  v8[3] = 0LL;
  v8[4] = 0LL;
  ssh_key_free(v8);
  return v7;
}
// 47707: variable 'v4' is possibly undefined
// 47707: variable 'v5' is possibly undefined

//----- (0000000000047738) ----------------------------------------------------
void *ssh_kbdint_new()
{
  void *v1; // [rsp+8h] [rbp-8h]

  v1 = calloc(1uLL, 0x30uLL);
  if ( v1 )
    return v1;
  else
    return 0LL;
}

//----- (0000000000047767) ----------------------------------------------------
void __fastcall ssh_kbdint_free(void **a1)
{
  size_t v1; // rax
  size_t v2; // rax
  int i; // [rsp+18h] [rbp-8h]
  int j; // [rsp+18h] [rbp-8h]
  int v5; // [rsp+1Ch] [rbp-4h]
  int v6; // [rsp+1Ch] [rbp-4h]

  if ( a1 )
  {
    if ( a1[1] )
    {
      free(a1[1]);
      a1[1] = 0LL;
    }
    if ( a1[2] )
    {
      free(a1[2]);
      a1[2] = 0LL;
    }
    if ( a1[4] )
    {
      free(a1[4]);
      a1[4] = 0LL;
    }
    v5 = *(_DWORD *)a1;
    if ( a1[3] )
    {
      for ( i = 0; i < v5; ++i )
      {
        v1 = strlen(*((const char **)a1[3] + i));
        explicit_bzero(*((void **)a1[3] + i), v1);
        if ( *((_QWORD *)a1[3] + i) )
        {
          free(*((void **)a1[3] + i));
          *((_QWORD *)a1[3] + i) = 0LL;
        }
      }
      if ( a1[3] )
      {
        free(a1[3]);
        a1[3] = 0LL;
      }
    }
    v6 = *((_DWORD *)a1 + 1);
    if ( a1[5] )
    {
      for ( j = 0; j < v6; ++j )
      {
        v2 = strlen(*((const char **)a1[5] + j));
        explicit_bzero(*((void **)a1[5] + j), v2);
        if ( *((_QWORD *)a1[5] + j) )
        {
          free(*((void **)a1[5] + j));
          *((_QWORD *)a1[5] + j) = 0LL;
        }
      }
      if ( a1[5] )
      {
        free(a1[5]);
        a1[5] = 0LL;
      }
    }
    free(a1);
  }
}
// 479FB: conditional instruction was optimized away because rdi.8!=0

//----- (0000000000047A16) ----------------------------------------------------
void __fastcall ssh_kbdint_clean(void **a1)
{
  size_t v1; // rax
  size_t v2; // rax
  int i; // [rsp+18h] [rbp-8h]
  int j; // [rsp+18h] [rbp-8h]
  int v5; // [rsp+1Ch] [rbp-4h]
  int v6; // [rsp+1Ch] [rbp-4h]

  if ( a1 )
  {
    if ( a1[1] )
    {
      free(a1[1]);
      a1[1] = 0LL;
    }
    if ( a1[2] )
    {
      free(a1[2]);
      a1[2] = 0LL;
    }
    if ( a1[4] )
    {
      free(a1[4]);
      a1[4] = 0LL;
    }
    v5 = *(_DWORD *)a1;
    if ( a1[3] )
    {
      for ( i = 0; i < v5; ++i )
      {
        v1 = strlen(*((const char **)a1[3] + i));
        explicit_bzero(*((void **)a1[3] + i), v1);
        if ( *((_QWORD *)a1[3] + i) )
        {
          free(*((void **)a1[3] + i));
          *((_QWORD *)a1[3] + i) = 0LL;
        }
      }
      if ( a1[3] )
      {
        free(a1[3]);
        a1[3] = 0LL;
      }
    }
    v6 = *((_DWORD *)a1 + 1);
    if ( a1[5] )
    {
      for ( j = 0; j < v6; ++j )
      {
        v2 = strlen(*((const char **)a1[5] + j));
        explicit_bzero(*((void **)a1[5] + j), v2);
        if ( *((_QWORD *)a1[5] + j) )
        {
          free(*((void **)a1[5] + j));
          *((_QWORD *)a1[5] + j) = 0LL;
        }
      }
      if ( a1[5] )
      {
        free(a1[5]);
        a1[5] = 0LL;
      }
    }
    *(_DWORD *)a1 = 0;
    *((_DWORD *)a1 + 1) = 0;
  }
}

//----- (0000000000047CBF) ----------------------------------------------------
__int64 __fastcall ssh_userauth_kbdint_init(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  void *v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  int v13; // [rsp+2Ch] [rbp-4h]
  unsigned int response; // [rsp+2Ch] [rbp-4h]

  if ( *(_DWORD *)(a1 + 1160) != 7 )
  {
    if ( *(_DWORD *)(a1 + 1160) )
    {
      ssh_set_error_invalid(a1, "ssh_userauth_kbdint_init", a3, a4, a5, a6);
      return 0xFFFFFFFFLL;
    }
    v13 = ssh_userauth_request_service(a1);
    if ( v13 == -2 )
      return 4LL;
    if ( v13 )
      return 0xFFFFFFFFLL;
    if ( a3 )
      v7 = (void *)a3;
    else
      v7 = &unk_757FC;
    if ( a2 )
      v8 = a2;
    else
      v8 = *(_QWORD *)(a1 + 1472);
    if ( (int)ssh_buffer_pack(
                *(_QWORD *)(a1 + 1152),
                "bsssss",
                6,
                50LL,
                v8,
                "ssh-connection",
                "keyboard-interactive",
                &unk_757FC,
                v7,
                1332084403LL) < 0 )
    {
      ssh_set_error_oom(a1, "ssh_userauth_kbdint_init");
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(a1 + 1180) = 7;
    *(_DWORD *)(a1 + 1160) = 7;
    ssh_log(3, "ssh_userauth_kbdint_init", "Sending keyboard-interactive init request", v9, v10, v11);
    if ( (unsigned int)ssh_packet_send(a1) == -1 )
      return 0xFFFFFFFFLL;
  }
  response = ssh_userauth_get_response(a1);
  if ( response != 4 )
    *(_DWORD *)(a1 + 1160) = 0;
  return response;
}
// 47DF3: variable 'v9' is possibly undefined
// 47DF3: variable 'v10' is possibly undefined
// 47DF3: variable 'v11' is possibly undefined

//----- (0000000000047E6B) ----------------------------------------------------
__int64 __fastcall ssh_userauth_kbdint_send(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  void *v7; // rax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned int i; // [rsp+18h] [rbp-8h]
  unsigned int response; // [rsp+1Ch] [rbp-4h]

  if ( *(_DWORD *)(a1 + 1160) != 8 )
  {
    if ( *(_DWORD *)(a1 + 1160) )
    {
      ssh_set_error_invalid(a1, "ssh_userauth_kbdint_send", a3, a4, a5, a6);
      return 0xFFFFFFFFLL;
    }
    if ( (int)ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "bd", 2, 61LL, **(unsigned int **)(a1 + 1272), 1332084403LL) < 0 )
    {
LABEL_18:
      ssh_set_error_oom(a1, "ssh_userauth_kbdint_send");
      ssh_buffer_reinit(*(_QWORD *)(a1 + 1152));
      return 0xFFFFFFFFLL;
    }
    for ( i = 0; **(_DWORD **)(a1 + 1272) > i; ++i )
    {
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)
        && *(_QWORD *)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)) )
      {
        v7 = *(void **)(8LL * i + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL));
      }
      else
      {
        v7 = &unk_757FC;
      }
      if ( (int)ssh_buffer_pack(*(_QWORD *)(a1 + 1152), "s", 1, v7, 1332084403LL) < 0 )
        goto LABEL_18;
    }
    *(_DWORD *)(a1 + 1180) = 7;
    *(_DWORD *)(a1 + 1160) = 8;
    ssh_kbdint_free(*(void ***)(a1 + 1272));
    *(_QWORD *)(a1 + 1272) = 0LL;
    ssh_log(3, "ssh_userauth_kbdint_send", "Sending keyboard-interactive response packet", v8, v9, v10);
    if ( (unsigned int)ssh_packet_send(a1) == -1 )
      return 0xFFFFFFFFLL;
  }
  response = ssh_userauth_get_response(a1);
  if ( response != 4 )
    *(_DWORD *)(a1 + 1160) = 0;
  return response;
}
// 4800E: variable 'v8' is possibly undefined
// 4800E: variable 'v9' is possibly undefined
// 4800E: variable 'v10' is possibly undefined

//----- (0000000000048089) ----------------------------------------------------
__int64 __fastcall ssh_packet_userauth_info_request(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned int nmemb; // [rsp+2Ch] [rbp-24h] BYREF
  unsigned int nmemb_4; // [rsp+30h] [rbp-20h]
  int v15; // [rsp+34h] [rbp-1Ch]
  void *v16; // [rsp+38h] [rbp-18h] BYREF

  v16 = 0LL;
  if ( *(_QWORD *)(a1 + 1272) )
  {
    ssh_kbdint_clean(*(void ***)(a1 + 1272));
  }
  else
  {
    *(_QWORD *)(a1 + 1272) = ssh_kbdint_new();
    if ( !*(_QWORD *)(a1 + 1272) )
    {
      ssh_set_error_oom(a1, "ssh_packet_userauth_info_request");
      return 1LL;
    }
  }
  v15 = ssh_buffer_unpack(
          a3,
          "ssSd",
          4,
          *(_QWORD *)(a1 + 1272) + 8LL,
          *(_QWORD *)(a1 + 1272) + 16LL,
          &v16,
          &nmemb,
          1332084403LL);
  ssh_string_free(v16);
  if ( v15 )
  {
    ssh_set_error(a1, 2, "ssh_packet_userauth_info_request", "Invalid USERAUTH_INFO_REQUEST msg", v5, v6, a4);
    ssh_kbdint_free(*(void ***)(a1 + 1272));
    *(_QWORD *)(a1 + 1272) = 0LL;
    return 1LL;
  }
  else
  {
    ssh_log(3, "ssh_packet_userauth_info_request", "%d keyboard-interactive prompts", nmemb, v5, v6, a4);
    if ( nmemb <= 0x100 )
    {
      **(_DWORD **)(a1 + 1272) = nmemb;
      *(_DWORD *)(*(_QWORD *)(a1 + 1272) + 4LL) = nmemb;
      v7 = *(_QWORD *)(a1 + 1272);
      *(_QWORD *)(v7 + 24) = calloc(nmemb, 8uLL);
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 24LL)
        && (v8 = *(_QWORD *)(a1 + 1272), *(_QWORD *)(v8 + 32) = malloc(nmemb),
                                         *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 32LL)) )
      {
        memset(*(void **)(*(_QWORD *)(a1 + 1272) + 32LL), 0, nmemb);
        for ( nmemb_4 = 0; nmemb_4 < nmemb; ++nmemb_4 )
        {
          v15 = ssh_buffer_unpack(
                  a3,
                  "sb",
                  2,
                  *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 24LL) + 8LL * nmemb_4,
                  *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 32LL) + nmemb_4,
                  1332084403LL);
          if ( v15 == -1 )
          {
            ssh_set_error(a1, 2, "ssh_packet_userauth_info_request", "Short INFO_REQUEST packet", v9, v10);
            ssh_kbdint_free(*(void ***)(a1 + 1272));
            *(_QWORD *)(a1 + 1272) = 0LL;
            return 1LL;
          }
        }
        *(_DWORD *)(a1 + 1180) = 5;
        return 1LL;
      }
      else
      {
        **(_DWORD **)(a1 + 1272) = 0;
        ssh_set_error_oom(a1, "ssh_packet_userauth_info_request");
        ssh_kbdint_free(*(void ***)(a1 + 1272));
        *(_QWORD *)(a1 + 1272) = 0LL;
        return 1LL;
      }
    }
    else
    {
      ssh_set_error(
        a1,
        2,
        "ssh_packet_userauth_info_request",
        "Too much prompts requested by the server: %u (0x%.4x)",
        nmemb,
        nmemb);
      ssh_kbdint_free(*(void ***)(a1 + 1272));
      *(_QWORD *)(a1 + 1272) = 0LL;
      return 1LL;
    }
  }
}
// 48195: variable 'v5' is possibly undefined
// 48195: variable 'v6' is possibly undefined
// 48421: variable 'v9' is possibly undefined
// 48421: variable 'v10' is possibly undefined

//----- (0000000000048478) ----------------------------------------------------
__int64 __fastcall ssh_userauth_kbdint(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( (*(_DWORD *)(a1 + 1160) || *(_QWORD *)(a1 + 1272)) && *(_DWORD *)(a1 + 1160) != 7 )
  {
    if ( *(_DWORD *)(a1 + 1160) == 8 || *(_QWORD *)(a1 + 1272) )
    {
      return (unsigned int)ssh_userauth_kbdint_send(a1, a2, a3, a4, a5, a6);
    }
    else
    {
      v7 = -1;
      ssh_set_error(a1, 2, "ssh_userauth_kbdint", "Invalid state in %s", (__int64)"ssh_userauth_kbdint", a6);
    }
  }
  else
  {
    return (unsigned int)ssh_userauth_kbdint_init(a1, a2, a3, a2, a5, a6);
  }
  return v7;
}

//----- (0000000000048554) ----------------------------------------------------
__int64 __fastcall ssh_userauth_kbdint_getnprompts(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( *(_QWORD *)(a1 + 1272) )
    return **(unsigned int **)(a1 + 1272);
  ssh_set_error_invalid(a1, "ssh_userauth_kbdint_getnprompts", a3, a4, a5, a6);
  return 0xFFFFFFFFLL;
}

//----- (00000000000485A7) ----------------------------------------------------
__int64 __fastcall ssh_userauth_kbdint_getname(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( !a1 )
    return 0LL;
  if ( *(_QWORD *)(a1 + 1272) )
    return *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 8LL);
  ssh_set_error_invalid(a1, "ssh_userauth_kbdint_getname", a3, a4, a5, a6);
  return 0LL;
}

//----- (00000000000485FC) ----------------------------------------------------
__int64 __fastcall ssh_userauth_kbdint_getinstruction(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  if ( !a1 )
    return 0LL;
  if ( *(_QWORD *)(a1 + 1272) )
    return *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 16LL);
  ssh_set_error_invalid(a1, "ssh_userauth_kbdint_getinstruction", a3, a4, a5, a6);
  return 0LL;
}

//----- (0000000000048651) ----------------------------------------------------
__int64 __fastcall ssh_userauth_kbdint_getprompt(
        __int64 a1,
        unsigned int a2,
        _BYTE *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  if ( !a1 )
    return 0LL;
  if ( *(_QWORD *)(a1 + 1272) && **(_DWORD **)(a1 + 1272) >= a2 )
  {
    if ( a3 )
      *a3 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 1272) + 32LL) + a2);
    return *(_QWORD *)(8LL * a2 + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 24LL));
  }
  else
  {
    ssh_set_error_invalid(a1, "ssh_userauth_kbdint_getprompt", (__int64)a3, a4, a5, a6);
    return 0LL;
  }
}

//----- (0000000000048710) ----------------------------------------------------
__int64 __fastcall ssh_userauth_kbdint_getnanswers(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 1272) )
    return *(unsigned int *)(*(_QWORD *)(a1 + 1272) + 4LL);
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000048746) ----------------------------------------------------
__int64 __fastcall ssh_userauth_kbdint_getanswer(__int64 a1, unsigned int a2)
{
  if ( !a1 || !*(_QWORD *)(a1 + 1272) || !*(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL) )
    return 0LL;
  if ( *(_DWORD *)(*(_QWORD *)(a1 + 1272) + 4LL) > a2 )
    return *(_QWORD *)(8LL * a2 + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL));
  return 0LL;
}

//----- (00000000000487BB) ----------------------------------------------------
__int64 __fastcall ssh_userauth_kbdint_setanswer(
        __int64 a1,
        unsigned int a2,
        const char *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned int *v7; // rbx
  size_t v8; // rax
  char **v9; // rbx

  if ( !a1 )
    return 0xFFFFFFFFLL;
  if ( a3 && *(_QWORD *)(a1 + 1272) && **(_DWORD **)(a1 + 1272) > a2 )
  {
    if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL) )
    {
      v7 = *(unsigned int **)(a1 + 1272);
      *((_QWORD *)v7 + 5) = calloc(*v7, 8uLL);
      if ( !*(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL) )
        goto LABEL_9;
    }
    if ( *(_QWORD *)(8LL * a2 + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)) )
    {
      v8 = strlen(*(const char **)(8LL * a2 + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)));
      explicit_bzero(*(void **)(8LL * a2 + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)), v8);
      if ( *(_QWORD *)(8LL * a2 + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)) )
      {
        free(*(void **)(8LL * a2 + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)));
        *(_QWORD *)(8LL * a2 + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)) = 0LL;
      }
    }
    v9 = (char **)(*(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL) + 8LL * a2);
    *v9 = strdup(a3);
    if ( *(_QWORD *)(8LL * a2 + *(_QWORD *)(*(_QWORD *)(a1 + 1272) + 40LL)) )
    {
      return 0LL;
    }
    else
    {
LABEL_9:
      ssh_set_error_oom(a1, "ssh_userauth_kbdint_setanswer");
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error_invalid(a1, "ssh_userauth_kbdint_setanswer", (__int64)a3, a4, a5, a6);
    return 0xFFFFFFFFLL;
  }
}

//----- (00000000000489DE) ----------------------------------------------------
__int64 ssh_userauth_gssapi()
{
  return 1LL;
}
// 489DE: using guessed type __int64 ssh_userauth_gssapi();

//----- (00000000000489F2) ----------------------------------------------------
void *__fastcall base64_to_bin(const char *a1)
{
  char v2[3]; // [rsp+19h] [rbp-27h] BYREF
  int equals; // [rsp+1Ch] [rbp-24h]
  char *v4; // [rsp+20h] [rbp-20h]
  size_t v5; // [rsp+28h] [rbp-18h]
  void *v6; // [rsp+30h] [rbp-10h]
  void *ptr; // [rsp+38h] [rbp-8h]

  v6 = 0LL;
  ptr = strdup(a1);
  if ( !ptr )
    return 0LL;
  v4 = (char *)ptr;
  equals = get_equals((const char *)ptr);
  if ( equals > 2 || (v6 = ssh_buffer_new()) == 0LL )
  {
    free(ptr);
    ptr = 0LL;
    return 0LL;
  }
  ssh_buffer_set_secure((__int64)v6);
  v5 = strlen(v4);
  while ( v5 > 4 )
  {
    if ( (int)base64_to_bin(v2, v4, 3) < 0 || (int)ssh_buffer_add_data((__int64)v6, v2, 3u) < 0 )
      goto LABEL_33;
    v5 -= 4LL;
    v4 += 4;
  }
  if ( v5 == 3 )
  {
    if ( equals != 1 || (int)base64_to_bin(v2, v4, 2) < 0 || (int)ssh_buffer_add_data((__int64)v6, v2, 2u) < 0 )
      goto LABEL_33;
    if ( ptr )
    {
      free(ptr);
      ptr = 0LL;
    }
    return v6;
  }
  else
  {
    if ( v5 != 4 )
    {
      if ( v5 == 2
        && equals == 2
        && (int)base64_to_bin(v2, v4, 1) >= 0
        && (int)ssh_buffer_add_data((__int64)v6, v2, 1u) >= 0 )
      {
        if ( ptr )
        {
          free(ptr);
          ptr = 0LL;
        }
        return v6;
      }
LABEL_33:
      if ( ptr )
      {
        free(ptr);
        ptr = 0LL;
      }
      ssh_buffer_free((__int64)v6);
      return 0LL;
    }
    if ( equals || (int)base64_to_bin(v2, v4, 3) < 0 || (int)ssh_buffer_add_data((__int64)v6, v2, 3u) < 0 )
      goto LABEL_33;
    if ( ptr )
    {
      free(ptr);
      ptr = 0LL;
    }
    return v6;
  }
}
// 48A7E: conditional instruction was optimized away because %ptr.8!=0
// 48A49: conditional instruction was optimized away because %ptr.8!=0

//----- (0000000000048CB4) ----------------------------------------------------
__int64 __fastcall to_block4(_QWORD *a1, char *a2, int a3)
{
  char *v5; // [rsp+28h] [rbp-8h]
  char *v6; // [rsp+28h] [rbp-8h]
  char *v7; // [rsp+28h] [rbp-8h]
  char *v8; // [rsp+28h] [rbp-8h]

  *a1 = 0LL;
  if ( a3 <= 0 )
    return 0LL;
  v5 = strchr(alphabet, *a2);
  if ( !v5 )
    return 0xFFFFFFFFLL;
  *a1 |= (((_DWORD)v5 - (unsigned int)alphabet) << 18) & 0xFC0000;
  v6 = strchr(alphabet, a2[1]);
  if ( !v6 )
    return 0xFFFFFFFFLL;
  *a1 |= (((_DWORD)v6 - (unsigned int)alphabet) << 12) & 0x3F000;
  if ( a3 <= 1 )
    return 0LL;
  v7 = strchr(alphabet, a2[2]);
  if ( !v7 )
    return 0xFFFFFFFFLL;
  *a1 |= (((_WORD)v7 - (unsigned __int16)alphabet) << 6) & 0xFC0;
  if ( a3 <= 2 )
    return 0LL;
  v8 = strchr(alphabet, a2[3]);
  if ( !v8 )
    return 0xFFFFFFFFLL;
  *a1 |= ((_BYTE)v8 - (unsigned __int8)alphabet) & 0x3F;
  return 0LL;
}

//----- (0000000000048E87) ----------------------------------------------------
__int64 __fastcall base64_to_bin(_BYTE *a1, char *a2, int a3)
{
  __int64 v4; // [rsp+28h] [rbp-8h] BYREF

  if ( (int)to_block4(&v4, a2, a3) < 0 )
    return 0xFFFFFFFFLL;
  *a1 = BYTE2(v4);
  a1[1] = BYTE1(v4);
  a1[2] = v4;
  return 0LL;
}

//----- (0000000000048EF2) ----------------------------------------------------
__int64 __fastcall get_equals(const char *a1)
{
  char *i; // rax
  unsigned int v3; // [rsp+14h] [rbp-Ch]

  v3 = 0;
  for ( i = strchr(a1, 61); i; i = strchr(i + 1, 61) )
  {
    ++v3;
    *i = 0;
  }
  return v3;
}

//----- (0000000000048F40) ----------------------------------------------------
unsigned __int64 __fastcall bin_to_base64(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  unsigned __int64 result; // rax

  result = a3;
  switch ( a3 )
  {
    case 2u:
      *a1 = alphabet[*a2 >> 2];
      a1[1] = alphabet[(a2[1] >> 4) | (16 * *a2) & 0x30];
      a1[2] = alphabet[(4 * a2[1]) & 0x3C];
      result = (unsigned __int64)(a1 + 3);
      a1[3] = 61;
      break;
    case 3u:
      *a1 = alphabet[*a2 >> 2];
      a1[1] = alphabet[(a2[1] >> 4) | (16 * *a2) & 0x30];
      a1[2] = alphabet[(4 * a2[1]) & 0x3C | (a2[2] >> 6)];
      result = (unsigned __int8)alphabet[a2[2] & 0x3F];
      a1[3] = result;
      break;
    case 1u:
      *a1 = alphabet[*a2 >> 2];
      a1[1] = alphabet[(16 * *a2) & 0x30];
      a1[2] = 61;
      result = (unsigned __int64)(a1 + 3);
      a1[3] = 61;
      break;
  }
  return result;
}

//----- (0000000000049134) ----------------------------------------------------
_BYTE *__fastcall bin_to_base64(_BYTE *a1, int a2)
{
  unsigned int v3; // eax
  int v4; // [rsp+4h] [rbp-2Ch]
  _BYTE *v6; // [rsp+20h] [rbp-10h]
  _BYTE *v7; // [rsp+28h] [rbp-8h]

  v4 = a2;
  v7 = malloc(4 * (3 - a2 % 3 + a2) / 3 + 1);
  if ( !v7 )
    return 0LL;
  v6 = v7;
  while ( v4 > 0 )
  {
    v3 = 3;
    if ( v4 <= 3 )
      v3 = v4;
    bin_to_base64(v6, a1, v3);
    v6 += 4;
    a1 += 3;
    v4 -= 3;
  }
  *v6 = 0;
  return v7;
}

//----- (00000000000491FF) ----------------------------------------------------
_BYTE *__fastcall ssh_make_bignum_string(__int64 a1)
{
  _BOOL4 v2; // [rsp+1Ch] [rbp-14h]
  unsigned int v3; // [rsp+20h] [rbp-10h]
  __int64 nbits; // [rsp+24h] [rbp-Ch]
  _BYTE *v5; // [rsp+28h] [rbp-8h]

  v2 = 0;
  v3 = ((unsigned int)gcry_mpi_get_nbits(a1) + 7) >> 3;
  nbits = (unsigned int)gcry_mpi_get_nbits(a1);
  if ( !v3 )
    return 0LL;
  if ( (nbits & 7) == 0 )
    v2 = gcry_mpi_test_bit(a1, (unsigned int)(nbits - 1)) != 0;
  v5 = ssh_string_new(v2 + v3);
  if ( !v5 )
    return 0LL;
  if ( v2 )
    v5[4] = 0;
  gcry_mpi_print(5LL, &v5[v2 + 4], v3, 0LL, a1);
  return v5;
}
// D780: using guessed type __int64 __fastcall gcry_mpi_get_nbits(_QWORD);
// D910: using guessed type __int64 __fastcall gcry_mpi_print(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// E070: using guessed type __int64 __fastcall gcry_mpi_test_bit(_QWORD, _QWORD);

//----- (00000000000492DA) ----------------------------------------------------
__int64 __fastcall ssh_make_string_bn(uint32_t *a1)
{
  _BYTE v2[12]; // [rsp+14h] [rbp-Ch] BYREF

  *(_DWORD *)&v2[8] = 0;
  *(_QWORD *)v2 = (unsigned int)ssh_string_len(a1);
  gcry_mpi_scan(&v2[4], 5LL, a1 + 1, *(unsigned int *)v2, 0LL);
  return *(_QWORD *)&v2[4];
}
// DEA0: using guessed type __int64 __fastcall gcry_mpi_scan(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000004932B) ----------------------------------------------------
__int64 __fastcall ssh_make_string_bn_inplace(uint32_t *a1)
{
  return ssh_string_len(a1);
}

//----- (000000000004934D) ----------------------------------------------------
void __fastcall ssh_print_bignum(const char *a1, __int64 a2)
{
  const char *v2; // rax
  void *ptr; // [rsp+18h] [rbp-8h] BYREF

  ptr = 0LL;
  gcry_mpi_aprint(4LL, &ptr, 0LL, a2);
  fprintf(stderr, "%s value: ", a1);
  if ( ptr )
    v2 = (const char *)ptr;
  else
    v2 = "(null)";
  fprintf(stderr, "%s\n", v2);
  if ( ptr )
    free(ptr);
}
// DF00: using guessed type __int64 __fastcall gcry_mpi_aprint(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000493FB) ----------------------------------------------------
void *ssh_buffer_new()
{
  void *v1; // [rsp+8h] [rbp-8h]

  v1 = calloc(1uLL, 0x18uLL);
  if ( v1 )
    return v1;
  else
    return 0LL;
}

//----- (000000000004942A) ----------------------------------------------------
void __fastcall ssh_buffer_free(__int64 a1)
{
  if ( a1 )
  {
    if ( *(_QWORD *)a1 )
    {
      explicit_bzero(*(void **)a1, *(unsigned int *)(a1 + 12));
      if ( *(_QWORD *)a1 )
      {
        free(*(void **)a1);
        *(_QWORD *)a1 = 0LL;
      }
    }
    explicit_bzero((void *)a1, 0x18uLL);
    free((void *)a1);
  }
}
// 494A0: conditional instruction was optimized away because rdi.8!=0

//----- (00000000000494BB) ----------------------------------------------------
__int64 __fastcall ssh_buffer_set_secure(__int64 a1)
{
  __int64 result; // rax

  result = a1;
  *(_DWORD *)(a1 + 20) = 1;
  return result;
}

//----- (00000000000494D1) ----------------------------------------------------
__int64 __fastcall realloc_buffer(__int64 a1, size_t a2)
{
  size_t i; // [rsp+10h] [rbp-10h]
  void *dest; // [rsp+18h] [rbp-8h]

  for ( i = 1LL; i <= a2; i *= 2LL )
  {
    if ( !i )
      return 0xFFFFFFFFLL;
  }
  if ( *(_DWORD *)(a1 + 20) )
  {
    dest = malloc(i);
    if ( !dest )
      return 0xFFFFFFFFLL;
    if ( *(_DWORD *)(a1 + 8) )
    {
      memcpy(dest, *(const void **)a1, *(unsigned int *)(a1 + 8));
      explicit_bzero(*(void **)a1, *(unsigned int *)(a1 + 8));
      if ( *(_QWORD *)a1 )
      {
        free(*(void **)a1);
        *(_QWORD *)a1 = 0LL;
      }
    }
  }
  else
  {
    dest = realloc(*(void **)a1, i);
    if ( !dest )
    {
      *(_QWORD *)a1 = 0LL;
      return 0xFFFFFFFFLL;
    }
  }
  *(_QWORD *)a1 = dest;
  *(_DWORD *)(a1 + 12) = i;
  return 0LL;
}

//----- (0000000000049605) ----------------------------------------------------
unsigned __int64 __fastcall buffer_shift(__int64 a1)
{
  unsigned __int64 result; // rax
  unsigned int v2; // [rsp+14h] [rbp-Ch]

  v2 = *(_DWORD *)(a1 + 16);
  result = v2;
  if ( v2 )
  {
    memmove(
      *(void **)a1,
      (const void *)(*(_QWORD *)a1 + *(unsigned int *)(a1 + 16)),
      (unsigned int)(*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 16)));
    *(_DWORD *)(a1 + 8) -= *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = 0;
    result = *(unsigned int *)(a1 + 20);
    if ( (_DWORD)result )
      return (unsigned __int64)explicit_bzero((void *)(*(_QWORD *)a1 + *(unsigned int *)(a1 + 8)), v2);
  }
  return result;
}

//----- (00000000000496C2) ----------------------------------------------------
__int64 __fastcall ssh_buffer_reinit(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 8) )
    explicit_bzero(*(void **)a1, *(unsigned int *)(a1 + 8));
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  if ( *(_DWORD *)(a1 + 12) <= 0x7Fu || (int)realloc_buffer(a1, 0x7FuLL) >= 0 )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000049739) ----------------------------------------------------
__int64 __fastcall ssh_buffer_add_data(__int64 a1, const void *a2, unsigned int a3)
{
  if ( !a2 )
    return 0xFFFFFFFFLL;
  if ( *(_DWORD *)(a1 + 8) + a3 < a3 )
    return 0xFFFFFFFFLL;
  if ( *(_DWORD *)(a1 + 12) < *(_DWORD *)(a1 + 8) + a3 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      buffer_shift(a1);
    if ( (int)realloc_buffer(a1, *(_DWORD *)(a1 + 8) + a3) < 0 )
      return 0xFFFFFFFFLL;
  }
  memcpy((void *)(*(unsigned int *)(a1 + 8) + *(_QWORD *)a1), a2, a3);
  *(_DWORD *)(a1 + 8) += a3;
  return 0LL;
}

//----- (000000000004980D) ----------------------------------------------------
__int64 __fastcall ssh_buffer_allocate_size(__int64 a1, unsigned int a2)
{
  if ( *(_DWORD *)(a1 + 12) >= a2 )
    return 0LL;
  if ( *(_DWORD *)(a1 + 16) )
    buffer_shift(a1);
  if ( (int)realloc_buffer(a1, a2) >= 0 )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000049863) ----------------------------------------------------
__int64 __fastcall ssh_buffer_allocate(__int64 a1, unsigned int a2)
{
  __int64 v3; // [rsp+18h] [rbp-8h]

  if ( *(_DWORD *)(a1 + 8) + a2 < a2 )
    return 0LL;
  if ( *(_DWORD *)(a1 + 12) < *(_DWORD *)(a1 + 8) + a2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      buffer_shift(a1);
    if ( (int)realloc_buffer(a1, *(_DWORD *)(a1 + 8) + a2) < 0 )
      return 0LL;
  }
  v3 = *(_QWORD *)a1 + *(unsigned int *)(a1 + 8);
  *(_DWORD *)(a1 + 8) += a2;
  return v3;
}

//----- (0000000000049913) ----------------------------------------------------
__int64 __fastcall ssh_buffer_add_ssh_string(__int64 a1, uint32_t *a2)
{
  int v3; // [rsp+1Ch] [rbp-4h]

  if ( !a2 )
    return 0xFFFFFFFFLL;
  v3 = ssh_string_len(a2);
  if ( (int)ssh_buffer_add_data(a1, a2, v3 + 4) >= 0 )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000049972) ----------------------------------------------------
__int64 __fastcall ssh_buffer_add_u32(__int64 a1, int a2)
{
  int v3; // [rsp+4h] [rbp-1Ch] BYREF
  __int64 v4; // [rsp+8h] [rbp-18h]
  int v5; // [rsp+1Ch] [rbp-4h]

  v4 = a1;
  v3 = a2;
  v5 = ssh_buffer_add_data(a1, &v3, 4u);
  if ( v5 >= 0 )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (00000000000499B0) ----------------------------------------------------
__int64 __fastcall ssh_buffer_add_u16(__int64 a1, __int16 a2)
{
  __int16 v3; // [rsp+4h] [rbp-1Ch] BYREF
  __int64 v4; // [rsp+8h] [rbp-18h]
  int v5; // [rsp+1Ch] [rbp-4h]

  v4 = a1;
  v3 = a2;
  v5 = ssh_buffer_add_data(a1, &v3, 2u);
  if ( v5 >= 0 )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (00000000000499F1) ----------------------------------------------------
__int64 __fastcall ssh_buffer_add_u64(__int64 a1, __int64 a2)
{
  __int64 v3[3]; // [rsp+0h] [rbp-20h] BYREF
  int v4; // [rsp+1Ch] [rbp-4h]

  v3[1] = a1;
  v3[0] = a2;
  v4 = ssh_buffer_add_data(a1, v3, 8u);
  if ( v4 >= 0 )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000049A30) ----------------------------------------------------
__int64 __fastcall ssh_buffer_add_u8(__int64 a1, char a2)
{
  char v3[4]; // [rsp+4h] [rbp-1Ch] BYREF
  __int64 v4; // [rsp+8h] [rbp-18h]
  int v5; // [rsp+1Ch] [rbp-4h]

  v4 = a1;
  v3[0] = a2;
  v5 = ssh_buffer_add_data(a1, v3, 1u);
  if ( v5 >= 0 )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}
// 49A30: using guessed type char var_1C[4];

//----- (0000000000049A70) ----------------------------------------------------
__int64 __fastcall ssh_buffer_prepend_data(__int64 a1, const void *a2, unsigned int a3)
{
  if ( *(_DWORD *)(a1 + 16) < a3 )
  {
    if ( *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 16) + a3 >= a3 )
    {
      if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 16) + a3
        || (int)realloc_buffer(a1, *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 16) + a3) >= 0 )
      {
        memmove(
          (void *)(*(_QWORD *)a1 + a3),
          (const void *)(*(_QWORD *)a1 + *(unsigned int *)(a1 + 16)),
          (unsigned int)(*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 16)));
        memcpy(*(void **)a1, a2, a3);
        *(_DWORD *)(a1 + 8) += a3 - *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 16) = 0;
        return 0LL;
      }
      else
      {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    memcpy((void *)(*(_DWORD *)(a1 + 16) - a3 + *(_QWORD *)a1), a2, a3);
    *(_DWORD *)(a1 + 16) -= a3;
    return 0LL;
  }
}

//----- (0000000000049BD8) ----------------------------------------------------
__int64 __fastcall ssh_buffer_add_buffer(__int64 a1, __int64 a2)
{
  unsigned int len; // ebx
  const void *v3; // rax

  len = ssh_buffer_get_len(a2);
  v3 = (const void *)ssh_buffer_get(a2);
  if ( (int)ssh_buffer_add_data(a1, v3, len) >= 0 )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000049C33) ----------------------------------------------------
__int64 __fastcall ssh_buffer_get(__int64 a1)
{
  return *(_QWORD *)a1 + *(unsigned int *)(a1 + 16);
}

//----- (0000000000049C50) ----------------------------------------------------
__int64 __fastcall ssh_buffer_get_len(__int64 a1)
{
  return (unsigned int)(*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 16));
}

//----- (0000000000049C6C) ----------------------------------------------------
__int64 __fastcall ssh_buffer_pass_bytes(__int64 a1, unsigned int a2)
{
  if ( *(_DWORD *)(a1 + 16) + a2 < a2 || *(_DWORD *)(a1 + 8) < *(_DWORD *)(a1 + 16) + a2 )
    return 0LL;
  *(_DWORD *)(a1 + 16) += a2;
  if ( *(_DWORD *)(a1 + 16) == *(_DWORD *)(a1 + 8) )
  {
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return a2;
}

//----- (0000000000049CE6) ----------------------------------------------------
__int64 __fastcall ssh_buffer_pass_bytes_end(__int64 a1, unsigned int a2)
{
  if ( *(_DWORD *)(a1 + 8) < a2 )
    return 0LL;
  *(_DWORD *)(a1 + 8) -= a2;
  return a2;
}

//----- (0000000000049D1C) ----------------------------------------------------
__int64 __fastcall ssh_buffer_get_data(__int64 a1, void *a2, unsigned int a3)
{
  if ( (unsigned int)ssh_buffer_validate_length(a1, a3) )
    return 0LL;
  memcpy(a2, (const void *)(*(unsigned int *)(a1 + 16) + *(_QWORD *)a1), a3);
  *(_DWORD *)(a1 + 16) += a3;
  return a3;
}

//----- (0000000000049D8E) ----------------------------------------------------
__int64 __fastcall ssh_buffer_get_u8(__int64 a1, void *a2)
{
  return ssh_buffer_get_data(a1, a2, 1u);
}

//----- (0000000000049DB8) ----------------------------------------------------
__int64 __fastcall ssh_buffer_get_u32(__int64 a1, void *a2)
{
  return ssh_buffer_get_data(a1, a2, 4u);
}

//----- (0000000000049DE2) ----------------------------------------------------
__int64 __fastcall ssh_buffer_get_u64(__int64 a1, void *a2)
{
  return ssh_buffer_get_data(a1, a2, 8u);
}

//----- (0000000000049E0C) ----------------------------------------------------
__int64 __fastcall ssh_buffer_validate_length(__int64 a1, unsigned __int64 a2)
{
  if ( *(unsigned int *)(a1 + 16) + a2 >= a2 && a2 + *(unsigned int *)(a1 + 16) <= *(unsigned int *)(a1 + 8) )
    return 0LL;
  else
    return 0xFFFFFFFFLL;
}

//----- (0000000000049E5A) ----------------------------------------------------
void *__fastcall ssh_buffer_get_ssh_string(__int64 a1)
{
  void *v2; // rax
  int data; // eax
  uint32_t netlong; // [rsp+1Ch] [rbp-14h] BYREF
  uint32_t v5; // [rsp+20h] [rbp-10h]
  void *ptr; // [rsp+28h] [rbp-8h]

  ptr = 0LL;
  if ( !(unsigned int)ssh_buffer_get_u32(a1, &netlong) )
    return 0LL;
  v5 = ntohl(netlong);
  if ( (unsigned int)ssh_buffer_validate_length(a1, v5) )
    return 0LL;
  ptr = ssh_string_new(v5);
  if ( !ptr )
    return 0LL;
  v2 = (void *)ssh_string_data((__int64)ptr);
  data = ssh_buffer_get_data(a1, v2, v5);
  if ( data == v5 )
    return ptr;
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  return 0LL;
}

//----- (0000000000049F29) ----------------------------------------------------
__int64 __fastcall ssh_buffer_pack_va(__int64 a1, _BYTE *a2, int a3, unsigned int *a4, __int64 a5, __int64 a6)
{
  _DWORD *v7; // rax
  _DWORD *v8; // rax
  uint32_t *v9; // rax
  __int64 *v10; // rax
  unsigned __int64 v11; // rbx
  uint32_t **v12; // rax
  const char **v13; // rax
  int v14; // eax
  __int64 *v15; // rax
  const void **v16; // rax
  __int64 *v17; // rax
  const char **v18; // rax
  _DWORD *v19; // rax
  unsigned int v22; // [rsp+2Ch] [rbp-44h]
  int i; // [rsp+30h] [rbp-40h]
  __int16 hostlonga; // [rsp+38h] [rbp-38h]
  int hostlongb; // [rsp+38h] [rbp-38h]
  __int64 hostlongc; // [rsp+38h] [rbp-38h]
  __int64 hostlongd; // [rsp+38h] [rbp-38h]
  uint32_t *hostlong; // [rsp+38h] [rbp-38h]
  char *s; // [rsp+48h] [rbp-28h]
  char *sa; // [rsp+48h] [rbp-28h]
  uint32_t v32; // [rsp+50h] [rbp-20h]
  __int64 v33; // [rsp+50h] [rbp-20h]
  unsigned int v34; // [rsp+50h] [rbp-20h]

  v22 = -1;
  for ( i = 0; *a2; ++i )
  {
    if ( a3 != -1 && i > a3 )
      return 0xFFFFFFFFLL;
    switch ( *a2 )
    {
      case 'B':
        if ( *a4 > 0x2F )
        {
          v17 = (__int64 *)*((_QWORD *)a4 + 1);
          *((_QWORD *)a4 + 1) = v17 + 1;
        }
        else
        {
          v17 = (__int64 *)(*((_QWORD *)a4 + 2) + *a4);
          *a4 += 8;
        }
        hostlong = (uint32_t *)ssh_make_bignum_string(*v17);
        if ( hostlong )
        {
          v22 = ssh_buffer_add_ssh_string(a1, hostlong);
          free(hostlong);
        }
        else
        {
          v22 = -1;
        }
        break;
      case 'P':
        if ( *a4 > 0x2F )
        {
          v15 = (__int64 *)*((_QWORD *)a4 + 1);
          *((_QWORD *)a4 + 1) = v15 + 1;
        }
        else
        {
          v15 = (__int64 *)(*((_QWORD *)a4 + 2) + *a4);
          *a4 += 8;
        }
        v33 = *v15;
        if ( *a4 > 0x2F )
        {
          v16 = (const void **)*((_QWORD *)a4 + 1);
          *((_QWORD *)a4 + 1) = v16 + 1;
        }
        else
        {
          v16 = (const void **)(*((_QWORD *)a4 + 2) + *a4);
          *a4 += 8;
        }
        ++i;
        v22 = ssh_buffer_add_data(a1, *v16, v33);
        break;
      case 'S':
        if ( *a4 > 0x2F )
        {
          v12 = (uint32_t **)*((_QWORD *)a4 + 1);
          *((_QWORD *)a4 + 1) = v12 + 1;
        }
        else
        {
          v12 = (uint32_t **)(*((_QWORD *)a4 + 2) + *a4);
          *a4 += 8;
        }
        v22 = ssh_buffer_add_ssh_string(a1, *v12);
        break;
      case 'b':
        if ( *a4 > 0x2F )
        {
          v7 = (_DWORD *)*((_QWORD *)a4 + 1);
          *((_QWORD *)a4 + 1) = v7 + 2;
        }
        else
        {
          v7 = (_DWORD *)(*((_QWORD *)a4 + 2) + *a4);
          *a4 += 8;
        }
        v22 = ssh_buffer_add_u8(a1, *v7);
        break;
      case 'd':
        if ( *a4 > 0x2F )
        {
          v9 = (uint32_t *)*((_QWORD *)a4 + 1);
          *((_QWORD *)a4 + 1) = v9 + 2;
        }
        else
        {
          v9 = (uint32_t *)(*((_QWORD *)a4 + 2) + *a4);
          *a4 += 8;
        }
        hostlongb = htonl(*v9);
        v22 = ssh_buffer_add_u32(a1, hostlongb);
        break;
      case 'q':
        if ( *a4 > 0x2F )
        {
          v10 = (__int64 *)*((_QWORD *)a4 + 1);
          *((_QWORD *)a4 + 1) = v10 + 1;
        }
        else
        {
          v10 = (__int64 *)(*((_QWORD *)a4 + 2) + *a4);
          *a4 += 8;
        }
        hostlongc = *v10;
        v11 = (unsigned __int64)htonl(*v10) << 32;
        hostlongd = v11 | htonl(HIDWORD(hostlongc));
        v22 = ssh_buffer_add_u64(a1, hostlongd);
        break;
      case 's':
        if ( *a4 > 0x2F )
        {
          v13 = (const char **)*((_QWORD *)a4 + 1);
          *((_QWORD *)a4 + 1) = v13 + 1;
        }
        else
        {
          v13 = (const char **)(*((_QWORD *)a4 + 2) + *a4);
          *a4 += 8;
        }
        s = (char *)*v13;
        v32 = strlen(*v13);
        v14 = htonl(v32);
        v22 = ssh_buffer_add_u32(a1, v14);
        if ( !v22 )
          v22 = ssh_buffer_add_data(a1, s, v32);
        break;
      case 't':
        if ( *a4 > 0x2F )
        {
          v18 = (const char **)*((_QWORD *)a4 + 1);
          *((_QWORD *)a4 + 1) = v18 + 1;
        }
        else
        {
          v18 = (const char **)(*((_QWORD *)a4 + 2) + *a4);
          *a4 += 8;
        }
        sa = (char *)*v18;
        v34 = strlen(*v18);
        v22 = ssh_buffer_add_data(a1, sa, v34);
        break;
      case 'w':
        if ( *a4 > 0x2F )
        {
          v8 = (_DWORD *)*((_QWORD *)a4 + 1);
          *((_QWORD *)a4 + 1) = v8 + 2;
        }
        else
        {
          v8 = (_DWORD *)(*((_QWORD *)a4 + 2) + *a4);
          *a4 += 8;
        }
        hostlonga = htons(*v8);
        v22 = ssh_buffer_add_u16(a1, hostlonga);
        break;
      default:
        ssh_log(1, "ssh_buffer_pack_va", "Invalid buffer format %c", (unsigned int)(char)*a2, a5, a6);
        v22 = -1;
        break;
    }
    if ( v22 )
      break;
    ++a2;
  }
  if ( a3 != -1 && a3 != i )
    return 0xFFFFFFFFLL;
  if ( v22 == -1 )
    return v22;
  if ( *a4 > 0x2F )
  {
    v19 = (_DWORD *)*((_QWORD *)a4 + 1);
    *((_QWORD *)a4 + 1) = v19 + 2;
  }
  else
  {
    v19 = (_DWORD *)(*((_QWORD *)a4 + 2) + *a4);
    *a4 += 8;
  }
  if ( *v19 == 1332084403 )
    return v22;
  if ( a3 != -1 )
    abort();
  return 0xFFFFFFFFLL;
}
// 4A4AD: variable 'a5' is possibly undefined
// 4A4AD: variable 'a6' is possibly undefined

//----- (000000000004A565) ----------------------------------------------------
__int64 ssh_buffer_pack(__int64 a1, _BYTE *a2, int a3, ...)
{
  gcc_va_list va; // [rsp+28h] [rbp-C8h] BYREF
  __int64 v5; // [rsp+58h] [rbp-98h]
  __int64 v6; // [rsp+60h] [rbp-90h]
  __int64 v7; // [rsp+68h] [rbp-88h]

  va_start(va, a3);
  v5 = va_arg(va, _QWORD);
  v6 = va_arg(va, _QWORD);
  v7 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a3);
  return (unsigned int)ssh_buffer_pack_va(a1, a2, a3, &va[0].gp_offset, v6, v7);
}

//----- (000000000004A61B) ----------------------------------------------------
__int64 __fastcall ssh_buffer_unpack_va(__int64 a1, _BYTE *a2, int a3, __int64 *a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  void ***v7; // rax
  unsigned int v8; // eax
  void ***v9; // rax
  void **v10; // rbx
  unsigned int v11; // eax
  void ***v12; // rax
  void **v13; // rbx
  unsigned int v14; // eax
  void ***v15; // rax
  void **v16; // rbx
  unsigned __int64 v17; // r12
  unsigned int v18; // eax
  void ***v19; // rax
  void **v20; // rbx
  unsigned int v21; // eax
  void ***v22; // rax
  void **v23; // rbx
  size_t *v24; // rax
  void ***v25; // rax
  void **v26; // rbx
  int *v27; // rax
  void ***v28; // rax
  void ***v29; // rax
  void ***v30; // rax
  uint32_t netlong; // [rsp+28h] [rbp-68h] BYREF
  unsigned int u32; // [rsp+2Ch] [rbp-64h]
  int i; // [rsp+30h] [rbp-60h]
  int v36; // [rsp+34h] [rbp-5Ch]
  void **v37; // [rsp+38h] [rbp-58h]
  _BYTE *j; // [rsp+40h] [rbp-50h]
  __int64 len; // [rsp+48h] [rbp-48h]
  __int64 data; // [rsp+50h] [rbp-40h]
  size_t size; // [rsp+58h] [rbp-38h]
  _BYTE *v42; // [rsp+60h] [rbp-30h]
  __int64 v43; // [rsp+68h] [rbp-28h]
  void ***v44; // [rsp+70h] [rbp-20h]
  __int64 v45; // [rsp+78h] [rbp-18h]

  u32 = -1;
  len = (unsigned int)ssh_buffer_get_len(a1);
  v43 = *a4;
  v44 = (void ***)a4[1];
  v45 = a4[2];
  j = a2;
  for ( i = 0; *j; ++i )
  {
    if ( a3 != -1 && i > a3 )
      return 0xFFFFFFFFLL;
    switch ( *j )
    {
      case 'P':
        if ( *(_DWORD *)a4 > 0x2Fu )
        {
          v24 = (size_t *)a4[1];
          a4[1] = (__int64)(v24 + 1);
        }
        else
        {
          v24 = (size_t *)(a4[2] + *(unsigned int *)a4);
          *(_DWORD *)a4 += 8;
        }
        size = *v24;
        if ( len - 1 >= size )
        {
          u32 = ssh_buffer_validate_length(a1, size);
          if ( !u32 )
          {
            if ( *(_DWORD *)a4 > 0x2Fu )
            {
              v25 = (void ***)a4[1];
              a4[1] = (__int64)(v25 + 1);
            }
            else
            {
              v25 = (void ***)(a4[2] + *(unsigned int *)a4);
              *(_DWORD *)a4 += 8;
            }
            v37 = *v25;
            ++i;
            v26 = v37;
            *v26 = malloc(size);
            if ( *v37 )
            {
              data = (unsigned int)ssh_buffer_get_data(a1, *v37, size);
              if ( data == size )
              {
                v37 = 0LL;
                u32 = 0;
              }
              else
              {
                if ( *v37 )
                {
                  free(*v37);
                  *v37 = 0LL;
                }
                u32 = -1;
              }
            }
            else
            {
              u32 = -1;
            }
          }
        }
        else
        {
          u32 = -1;
        }
        break;
      case 'S':
        if ( *(_DWORD *)a4 > 0x2Fu )
        {
          v19 = (void ***)a4[1];
          a4[1] = (__int64)(v19 + 1);
        }
        else
        {
          v19 = (void ***)(a4[2] + *(unsigned int *)a4);
          *(_DWORD *)a4 += 8;
        }
        v37 = *v19;
        v20 = v37;
        *v20 = ssh_buffer_get_ssh_string(a1);
        if ( *v37 )
          v21 = 0;
        else
          v21 = -1;
        u32 = v21;
        v37 = 0LL;
        break;
      case 'b':
        if ( *(_DWORD *)a4 > 0x2Fu )
        {
          v7 = (void ***)a4[1];
          a4[1] = (__int64)(v7 + 1);
        }
        else
        {
          v7 = (void ***)(a4[2] + *(unsigned int *)a4);
          *(_DWORD *)a4 += 8;
        }
        v37 = *v7;
        data = (int)ssh_buffer_get_u8(a1, v37);
        if ( data == 1 )
          v8 = 0;
        else
          v8 = -1;
        u32 = v8;
        break;
      case 'd':
        if ( *(_DWORD *)a4 > 0x2Fu )
        {
          v12 = (void ***)a4[1];
          a4[1] = (__int64)(v12 + 1);
        }
        else
        {
          v12 = (void ***)(a4[2] + *(unsigned int *)a4);
          *(_DWORD *)a4 += 8;
        }
        v37 = *v12;
        data = (int)ssh_buffer_get_u32(a1, v37);
        v13 = v37;
        *(_DWORD *)v13 = ntohl(*(_DWORD *)v37);
        if ( data == 4 )
          v14 = 0;
        else
          v14 = -1;
        u32 = v14;
        break;
      case 'q':
        if ( *(_DWORD *)a4 > 0x2Fu )
        {
          v15 = (void ***)a4[1];
          a4[1] = (__int64)(v15 + 1);
        }
        else
        {
          v15 = (void ***)(a4[2] + *(unsigned int *)a4);
          *(_DWORD *)a4 += 8;
        }
        v37 = *v15;
        data = (int)ssh_buffer_get_u64(a1, v37);
        v16 = v37;
        v17 = (unsigned __int64)ntohl((uint32_t)*v37) << 32;
        *v16 = (void *)(v17 | ntohl(HIDWORD(*v37)));
        if ( data == 8 )
          v18 = 0;
        else
          v18 = -1;
        u32 = v18;
        break;
      case 's':
        netlong = 0;
        if ( *(_DWORD *)a4 > 0x2Fu )
        {
          v22 = (void ***)a4[1];
          a4[1] = (__int64)(v22 + 1);
        }
        else
        {
          v22 = (void ***)(a4[2] + *(unsigned int *)a4);
          *(_DWORD *)a4 += 8;
        }
        v37 = *v22;
        *v37 = 0LL;
        u32 = ssh_buffer_get_u32(a1, &netlong);
        if ( u32 == 4 )
        {
          size = ntohl(netlong);
          if ( len - 1 >= size )
          {
            u32 = ssh_buffer_validate_length(a1, size);
            if ( !u32 )
            {
              v23 = v37;
              *v23 = malloc(size + 1);
              if ( *v37 )
              {
                data = (unsigned int)ssh_buffer_get_data(a1, *v37, size);
                if ( data == size )
                {
                  *((_BYTE *)*v37 + size) = 0;
                  v37 = 0LL;
                  u32 = 0;
                }
                else
                {
                  if ( *v37 )
                  {
                    free(*v37);
                    *v37 = 0LL;
                  }
                  u32 = -1;
                }
              }
              else
              {
                u32 = -1;
              }
            }
          }
          else
          {
            u32 = -1;
          }
        }
        else
        {
          u32 = -1;
        }
        break;
      case 'w':
        if ( *(_DWORD *)a4 > 0x2Fu )
        {
          v9 = (void ***)a4[1];
          a4[1] = (__int64)(v9 + 1);
        }
        else
        {
          v9 = (void ***)(a4[2] + *(unsigned int *)a4);
          *(_DWORD *)a4 += 8;
        }
        v37 = *v9;
        data = (unsigned int)ssh_buffer_get_data(a1, v37, 2u);
        v10 = v37;
        *(_WORD *)v10 = ntohs(*(_WORD *)v37);
        if ( data == 2 )
          v11 = 0;
        else
          v11 = -1;
        u32 = v11;
        break;
      default:
        ssh_log(1, "ssh_buffer_unpack_va", "Invalid buffer format %c", (unsigned int)(char)*j, v4, v5);
        u32 = -1;
        break;
    }
    if ( u32 )
      break;
    ++j;
  }
  if ( a3 != -1 && a3 != i )
    u32 = -1;
  if ( u32 != -1 )
  {
    if ( *(_DWORD *)a4 > 0x2Fu )
    {
      v27 = (int *)a4[1];
      a4[1] = (__int64)(v27 + 2);
    }
    else
    {
      v27 = (int *)(a4[2] + *(unsigned int *)a4);
      *(_DWORD *)a4 += 8;
    }
    v36 = *v27;
    if ( v36 != 1332084403 )
    {
      if ( a3 != -1 )
        abort();
      u32 = -1;
    }
  }
  if ( u32 )
  {
    v42 = j;
    for ( j = a2; j < v42; ++j )
    {
      switch ( *j )
      {
        case 'P':
          if ( (unsigned int)v43 > 0x2F )
            ++v44;
          else
            LODWORD(v43) = v43 + 8;
          if ( (unsigned int)v43 > 0x2F )
          {
            v30 = v44++;
          }
          else
          {
            v30 = (void ***)((unsigned int)v43 + v45);
            LODWORD(v43) = v43 + 8;
          }
          v37 = *v30;
          if ( *v37 )
            goto LABEL_110;
          break;
        case 'S':
          if ( (unsigned int)v43 > 0x2F )
          {
            v28 = v44++;
          }
          else
          {
            v28 = (void ***)((unsigned int)v43 + v45);
            LODWORD(v43) = v43 + 8;
          }
          v37 = *v28;
          if ( *v37 )
            goto LABEL_110;
          break;
        case 'b':
        case 'd':
        case 'q':
        case 'w':
          if ( (unsigned int)v43 > 0x2F )
            ++v44;
          else
            LODWORD(v43) = v43 + 8;
          break;
        case 's':
          if ( (unsigned int)v43 > 0x2F )
          {
            v29 = v44++;
          }
          else
          {
            v29 = (void ***)((unsigned int)v43 + v45);
            LODWORD(v43) = v43 + 8;
          }
          v37 = *v29;
          if ( *v37 )
          {
LABEL_110:
            free(*v37);
            *v37 = 0LL;
          }
          break;
        default:
          if ( (unsigned int)v43 > 0x2F )
            ++v44;
          else
            LODWORD(v43) = v43 + 8;
          break;
      }
    }
  }
  return u32;
}
// 4AD78: variable 'v4' is possibly undefined
// 4AD78: variable 'v5' is possibly undefined

//----- (000000000004B04A) ----------------------------------------------------
__int64 ssh_buffer_unpack(__int64 a1, _BYTE *a2, int a3, ...)
{
  gcc_va_list va; // [rsp+28h] [rbp-C8h] BYREF

  va_start(va, a3);
  return (unsigned int)ssh_buffer_unpack_va(a1, a2, a3, (__int64 *)va);
}

//----- (000000000004B100) ----------------------------------------------------
__int64 __fastcall ssh_config_get_opcode(const char *a1)
{
  int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; (&ssh_config_keyword_table)[2 * i]; ++i )
  {
    if ( !strcasecmp(a1, (&ssh_config_keyword_table)[2 * i]) )
      return *((unsigned int *)&unk_2813A8 + 4 * i);
  }
  return 4294967293LL;
}
// 2813A0: using guessed type char *ssh_config_keyword_table;

//----- (000000000004B17E) ----------------------------------------------------
_BYTE *__fastcall ssh_config_get_cmd(_BYTE **a1)
{
  _BYTE *i; // rbx
  _BYTE *v3; // [rsp+18h] [rbp-18h]

  for ( i = *a1; *i && ((*__ctype_b_loc())[(char)*i] & 1) != 0; ++i )
    ;
  if ( *i == 34 )
  {
    v3 = ++i;
    while ( *i )
    {
      if ( *i == 34 )
      {
        *i = 0;
        goto LABEL_16;
      }
      ++i;
    }
  }
  v3 = i;
  while ( *i )
  {
    if ( *i == 10 )
    {
      *i = 0;
      break;
    }
    ++i;
  }
LABEL_16:
  *a1 = i + 1;
  return v3;
}

//----- (000000000004B21F) ----------------------------------------------------
_BYTE *__fastcall ssh_config_get_token(_BYTE **a1)
{
  _BYTE *cmd; // rbx
  _BYTE *v3; // [rsp+18h] [rbp-18h]

  cmd = ssh_config_get_cmd(a1);
  v3 = cmd;
  while ( *cmd )
  {
    if ( ((*__ctype_b_loc())[(char)*cmd] & 1) != 0 || *cmd == 61 )
    {
      *cmd = 0;
      break;
    }
    ++cmd;
  }
  *a1 = cmd + 1;
  return v3;
}

//----- (000000000004B290) ----------------------------------------------------
__int64 __fastcall ssh_config_get_long(_BYTE **a1, __int64 a2)
{
  char *endptr; // [rsp+18h] [rbp-18h] BYREF
  char *nptr; // [rsp+20h] [rbp-10h]
  __int64 v5; // [rsp+28h] [rbp-8h]

  nptr = ssh_config_get_token(a1);
  if ( !nptr || !*nptr )
    return a2;
  v5 = strtol(nptr, &endptr, 10);
  if ( nptr == endptr )
    return a2;
  else
    return v5;
}

//----- (000000000004B2FA) ----------------------------------------------------
_BYTE *__fastcall ssh_config_get_str_tok(_BYTE **a1, __int64 a2)
{
  _BYTE *token; // [rsp+18h] [rbp-8h]

  token = ssh_config_get_token(a1);
  if ( token && *token )
    return token;
  else
    return (_BYTE *)a2;
}

//----- (000000000004B338) ----------------------------------------------------
__int64 __fastcall ssh_config_get_yesno(_BYTE **a1, unsigned int a2)
{
  char *s1; // [rsp+18h] [rbp-8h]

  s1 = ssh_config_get_str_tok(a1, 0LL);
  if ( !s1 )
    return a2;
  if ( !strncasecmp(s1, "yes", 3uLL) )
    return 1LL;
  if ( !strncasecmp(s1, "no", 2uLL) )
    return 0LL;
  return a2;
}

//----- (000000000004B3B3) ----------------------------------------------------
unsigned __int64 __fastcall local_parse_file(__int64 a1, const char *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  unsigned int v9; // [rsp+24h] [rbp-41Ch]
  FILE *stream; // [rsp+28h] [rbp-418h]
  char s[1032]; // [rsp+30h] [rbp-410h] BYREF
  unsigned __int64 v12; // [rsp+438h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  memset(s, 0, 0x400uLL);
  v9 = 0;
  stream = fopen(a2, "r");
  if ( stream )
  {
    ssh_log(3, "local_parse_file", "Reading additional configuration data from %s", (__int64)a2, v4, v5);
    do
    {
      if ( !fgets(s, 1024, stream) )
        break;
      ++v9;
    }
    while ( (int)ssh_config_parse_line(a1, s, v9, a3, a4) >= 0 );
    fclose(stream);
  }
  else
  {
    ssh_log(1, "local_parse_file", "Cannot find file %s to load", (__int64)a2, v4, v5);
  }
  return __readfsqword(0x28u) ^ v12;
}
// 4B453: variable 'v4' is possibly undefined
// 4B453: variable 'v5' is possibly undefined
// 4B5FC: using guessed type __int64 __fastcall ssh_config_parse_line(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000004B515) ----------------------------------------------------
void __fastcall local_parse_glob(__int64 a1, const char *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r8
  __int64 v5; // r9
  unsigned int i; // [rsp+28h] [rbp-58h]
  int v9; // [rsp+2Ch] [rbp-54h]
  glob_t pglob; // [rsp+30h] [rbp-50h] BYREF

  memset(&pglob, 0, sizeof(pglob));
  v9 = glob(a2, 4096, 0LL, &pglob);
  if ( v9 != 3 )
  {
    if ( v9 )
    {
      ssh_log(1, "local_parse_glob", "Glob error: %s", (__int64)a2, v4, v5, a4, a3);
      globfree(&pglob);
      return;
    }
    for ( i = 0; i < pglob.gl_pathc; ++i )
      local_parse_file(a1, pglob.gl_pathv[i], a3, a4);
  }
  globfree(&pglob);
}
// 4B59D: variable 'v4' is possibly undefined
// 4B59D: variable 'v5' is possibly undefined

//----- (000000000004B5FC) ----------------------------------------------------
__int64 __fastcall ssh_config_parse_line(__int64 a1, const char *a2, unsigned int a3, _DWORD *a4, __int64 a5)
{
  __int64 result; // rax
  __int64 v6; // r9
  char *v7; // rax
  unsigned int v8; // eax
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // rcx
  __int64 v28; // r8
  __int64 v29; // r9
  __int64 v30; // rcx
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 v33; // rcx
  __int64 v34; // r8
  __int64 v35; // r9
  __int64 v36; // rcx
  __int64 v37; // r8
  __int64 v38; // r9
  __int64 v39; // rcx
  __int64 v40; // r8
  __int64 v41; // r9
  __int64 v42; // rcx
  __int64 v43; // r8
  __int64 v44; // r9
  __int64 v45; // rcx
  __int64 v46; // r8
  __int64 v47; // r9
  __int64 v48; // rcx
  __int64 v49; // r8
  __int64 v50; // r9
  __int64 v51; // rcx
  __int64 v52; // r8
  __int64 v53; // r9
  __int64 v54; // rcx
  __int64 v55; // r8
  __int64 v56; // r9
  __int64 v57; // rcx
  __int64 v58; // r8
  __int64 v59; // r9
  __int64 v60; // rcx
  __int64 v61; // r8
  __int64 v62; // r9
  __int64 v63; // rcx
  __int64 v64; // r8
  __int64 v65; // r9
  __int64 v66; // rcx
  __int64 v67; // r8
  __int64 v68; // r9
  __int64 v69; // rcx
  __int64 v70; // r8
  __int64 v71; // r9
  __int64 v72; // rcx
  __int64 v73; // r8
  __int64 v74; // r9
  __int64 v75; // rcx
  __int64 v76; // r8
  __int64 v77; // r9
  __int64 v78; // rcx
  __int64 v79; // r8
  __int64 v80; // r9
  int yesno; // [rsp+34h] [rbp-5Ch] BYREF
  int matched; // [rsp+38h] [rbp-58h]
  unsigned int opcode; // [rsp+3Ch] [rbp-54h]
  char *v87; // [rsp+40h] [rbp-50h] BYREF
  __int64 v88; // [rsp+48h] [rbp-48h] BYREF
  char *s1; // [rsp+50h] [rbp-40h]
  size_t i; // [rsp+58h] [rbp-38h]
  void *v91; // [rsp+60h] [rbp-30h]
  char *nptr; // [rsp+68h] [rbp-28h]
  void *ptr; // [rsp+70h] [rbp-20h]
  const char *token; // [rsp+78h] [rbp-18h]
  char *v95; // [rsp+80h] [rbp-10h]
  void *v96; // [rsp+88h] [rbp-8h]

  v87 = strdup(a2);
  ptr = v87;
  if ( !v87 )
  {
    ssh_set_error_oom(a1, "ssh_config_parse_line");
    return 0xFFFFFFFFLL;
  }
  for ( i = strlen(v87) - 1; i && ((*__ctype_b_loc())[v87[i]] & 0x2000) != 0; --i )
    v87[i] = 0;
  token = ssh_config_get_token(&v87);
  if ( !token || *token == 35 || !*token || *token == 10 )
  {
    if ( ptr )
    {
      free(ptr);
      ptr = 0LL;
    }
    return 0LL;
  }
  opcode = ssh_config_get_opcode(token);
  if ( *a4 == 1 && opcode && opcode != -1 && opcode != 17 )
  {
    if ( *(_DWORD *)(4LL * (int)opcode + a5) )
    {
      if ( ptr )
      {
        free(ptr);
        ptr = 0LL;
      }
      return 0LL;
    }
    *(_DWORD *)(4LL * (int)opcode + a5) = 1;
  }
  switch ( opcode )
  {
    case 0xFFFFFFFD:
      ssh_log(1, "ssh_config_parse_line", "Unknown option: %s, line: %d\n", (__int64)token, a3, v6);
      goto LABEL_150;
    case 0xFFFFFFFE:
      ssh_log(2, "ssh_config_parse_line", "Unapplicable option: %s, line: %d\n", (__int64)token, a3, v6);
      goto LABEL_150;
    case 0xFFFFFFFF:
      ssh_log(1, "ssh_config_parse_line", "Unsupported option: %s, line: %d", (__int64)token, a3, v6);
      goto LABEL_150;
    case 0u:
      matched = 0;
      *a4 = 0;
      if ( *(_QWORD *)(a1 + 1480) )
        v7 = ssh_lowercase(*(const char **)(a1 + 1480));
      else
        v7 = 0LL;
      v96 = v7;
      for ( s1 = ssh_config_get_str_tok(&v87, 0LL); s1 && *s1; s1 = ssh_config_get_str_tok(&v87, 0LL) )
      {
        if ( matched >= 0 )
        {
          v8 = strlen(s1);
          matched = match_hostname(v96, (__int64)s1, v8);
          if ( matched >= 0 )
          {
            if ( matched > 0 )
              *a4 = 1;
          }
          else
          {
            *a4 = 0;
          }
        }
      }
      if ( v96 )
      {
        free(v96);
        v96 = 0LL;
      }
      goto LABEL_150;
    case 2u:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
      {
        v91 = ssh_path_expand_escape(a1, s1);
        if ( !v91 )
          v91 = strdup(s1);
        ssh_options_set(a1, 0, (char *)v91, v9, v10, v11);
        free(v91);
      }
      goto LABEL_150;
    case 3u:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
        ssh_options_set(a1, 2u, s1, v12, v13, v14);
      goto LABEL_150;
    case 4u:
      if ( !*(_QWORD *)(a1 + 1472) )
      {
        s1 = ssh_config_get_str_tok(&v87, 0LL);
        if ( s1 )
        {
          if ( *a4 )
            ssh_options_set(a1, 4u, s1, v15, v16, v17);
        }
      }
      goto LABEL_150;
    case 5u:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
        ssh_options_set(a1, 7u, s1, v18, v19, v20);
      goto LABEL_150;
    case 6u:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
      {
        ssh_options_set(a1, 0xFu, s1, v21, v22, v23);
        ssh_options_set(a1, 0x10u, s1, v24, v25, v26);
      }
      goto LABEL_150;
    case 7u:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
      {
        ssh_options_set(a1, 0x1Du, s1, v27, v28, v29);
        ssh_options_set(a1, 0x1Eu, s1, v30, v31, v32);
      }
      goto LABEL_150;
    case 8u:
      yesno = ssh_config_get_yesno(&v87, 0xFFFFFFFF);
      if ( yesno >= 0 && *a4 )
      {
        if ( yesno )
          ssh_options_set(a1, 0x16u, "yes", v33, v34, v35);
        else
          ssh_options_set(a1, 0x16u, "no", v33, v34, v35);
      }
      goto LABEL_150;
    case 9u:
      v88 = ssh_config_get_long(&v87, -1LL);
      if ( v88 >= 0 && *a4 )
        ssh_options_set(a1, 9u, (char *)&v88, v42, v43, v44);
      goto LABEL_150;
    case 0xAu:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( !s1 || !*a4 )
        goto LABEL_150;
      v95 = strdup(s1);
      if ( v95 )
      {
        yesno = 0;
        ssh_options_set(a1, 0xCu, (char *)&yesno, v36, v37, v38);
        for ( nptr = strtok(v95, ","); nptr; nptr = strtok(0LL, ",") )
        {
          if ( atoi(nptr) == 2 )
          {
            yesno = 1;
            ssh_options_set(a1, 0xCu, (char *)&yesno, v39, v40, v41);
          }
        }
        if ( v95 )
        {
          free(v95);
          v95 = 0LL;
        }
LABEL_150:
        if ( ptr )
        {
          free(ptr);
          ptr = 0LL;
        }
        result = 0LL;
      }
      else
      {
        if ( ptr )
        {
          free(ptr);
          ptr = 0LL;
        }
        ssh_set_error_oom(a1, "ssh_config_parse_line");
        result = 0xFFFFFFFFLL;
      }
      break;
    case 0xBu:
      yesno = ssh_config_get_yesno(&v87, 0xFFFFFFFF);
      if ( yesno >= 0 && *a4 )
        ssh_options_set(a1, 0x15u, (char *)&yesno, v45, v46, v47);
      goto LABEL_150;
    case 0xCu:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
        ssh_options_set(a1, 8u, s1, v48, v49, v50);
      goto LABEL_150;
    case 0xDu:
      s1 = ssh_config_get_cmd(&v87);
      if ( s1 && *a4 )
        ssh_options_set(a1, 0x13u, s1, v51, v52, v53);
      goto LABEL_150;
    case 0xEu:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
        ssh_options_set(a1, 0x1Au, s1, v54, v55, v56);
      goto LABEL_150;
    case 0xFu:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
        ssh_options_set(a1, 0x1Bu, s1, v57, v58, v59);
      goto LABEL_150;
    case 0x10u:
      yesno = ssh_config_get_yesno(&v87, 0xFFFFFFFF);
      if ( yesno >= 0 && *a4 )
        ssh_options_set(a1, 0x1Cu, (char *)&yesno, v60, v61, v62);
      goto LABEL_150;
    case 0x11u:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
        local_parse_glob(a1, s1, (__int64)a4, a5);
      goto LABEL_150;
    case 0x12u:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
        ssh_options_set(a1, 0x14u, s1, v63, v64, v65);
      goto LABEL_150;
    case 0x13u:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
        ssh_options_set(a1, 0x23u, s1, v66, v67, v68);
      goto LABEL_150;
    case 0x14u:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
      {
        LODWORD(v88) = -1;
        if ( !strcasecmp(s1, "quiet") )
        {
          LODWORD(v88) = 0;
        }
        else if ( !strcasecmp(s1, "fatal") || !strcasecmp(s1, "error") || !strcasecmp(s1, "info") )
        {
          LODWORD(v88) = 1;
        }
        else if ( !strcasecmp(s1, "verbose") )
        {
          LODWORD(v88) = 2;
        }
        else if ( !strcasecmp(s1, "DEBUG") || !strcasecmp(s1, "DEBUG1") )
        {
          LODWORD(v88) = 3;
        }
        else if ( !strcasecmp(s1, "DEBUG2") || !strcasecmp(s1, "DEBUG3") )
        {
          LODWORD(v88) = 4;
        }
        if ( (_DWORD)v88 != -1 )
          ssh_options_set(a1, 0xDu, (char *)&v88, v69, v70, v71);
      }
      goto LABEL_150;
    case 0x15u:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
        ssh_options_set(a1, 0x19u, s1, v72, v73, v74);
      goto LABEL_150;
    case 0x16u:
      s1 = ssh_config_get_str_tok(&v87, 0LL);
      if ( s1 && *a4 )
        ssh_options_set(a1, 0x18u, s1, v75, v76, v77);
      goto LABEL_150;
    case 0x17u:
    case 0x18u:
    case 0x19u:
    case 0x1Au:
      yesno = ssh_config_get_yesno(&v87, 0);
      if ( yesno >= 0 && *a4 )
      {
        if ( opcode == 24 )
        {
          ssh_options_set(a1, 0x21u, (char *)&yesno, v78, v79, v80);
        }
        else if ( (int)opcode > 24 )
        {
          if ( opcode == 25 )
          {
            ssh_options_set(a1, 0x1Fu, (char *)&yesno, v78, v79, v80);
          }
          else if ( opcode == 26 )
          {
            ssh_options_set(a1, 0x20u, (char *)&yesno, v78, v79, v80);
          }
        }
        else if ( opcode == 23 )
        {
          ssh_options_set(a1, 0x22u, (char *)&yesno, v78, v79, v80);
        }
      }
      goto LABEL_150;
    default:
      ssh_set_error(a1, 2, "ssh_config_parse_line", "ERROR - unimplemented opcode: %d", opcode, v6);
      if ( ptr )
      {
        free(ptr);
        ptr = 0LL;
      }
      return 0xFFFFFFFFLL;
  }
  return result;
}
// 4B97E: variable 'v9' is possibly undefined
// 4B97E: variable 'v10' is possibly undefined
// 4B97E: variable 'v11' is possibly undefined
// 4B9D2: variable 'v12' is possibly undefined
// 4B9D2: variable 'v13' is possibly undefined
// 4B9D2: variable 'v14' is possibly undefined
// 4BA2E: variable 'v15' is possibly undefined
// 4BA2E: variable 'v16' is possibly undefined
// 4BA2E: variable 'v17' is possibly undefined
// 4BA76: variable 'v18' is possibly undefined
// 4BA76: variable 'v19' is possibly undefined
// 4BA76: variable 'v20' is possibly undefined
// 4BABE: variable 'v21' is possibly undefined
// 4BABE: variable 'v22' is possibly undefined
// 4BABE: variable 'v23' is possibly undefined
// 4BAD3: variable 'v24' is possibly undefined
// 4BAD3: variable 'v25' is possibly undefined
// 4BAD3: variable 'v26' is possibly undefined
// 4BB1B: variable 'v27' is possibly undefined
// 4BB1B: variable 'v28' is possibly undefined
// 4BB1B: variable 'v29' is possibly undefined
// 4BB30: variable 'v30' is possibly undefined
// 4BB30: variable 'v31' is possibly undefined
// 4BB30: variable 'v32' is possibly undefined
// 4BB81: variable 'v33' is possibly undefined
// 4BB81: variable 'v34' is possibly undefined
// 4BB81: variable 'v35' is possibly undefined
// 4BC3C: variable 'v36' is possibly undefined
// 4BC3C: variable 'v37' is possibly undefined
// 4BC3C: variable 'v38' is possibly undefined
// 4BC89: variable 'v39' is possibly undefined
// 4BC89: variable 'v40' is possibly undefined
// 4BC89: variable 'v41' is possibly undefined
// 4BD13: variable 'v42' is possibly undefined
// 4BD13: variable 'v43' is possibly undefined
// 4BD13: variable 'v44' is possibly undefined
// 4BD5A: variable 'v45' is possibly undefined
// 4BD5A: variable 'v46' is possibly undefined
// 4BD5A: variable 'v47' is possibly undefined
// 4BDA2: variable 'v48' is possibly undefined
// 4BDA2: variable 'v49' is possibly undefined
// 4BDA2: variable 'v50' is possibly undefined
// 4BDE5: variable 'v51' is possibly undefined
// 4BDE5: variable 'v52' is possibly undefined
// 4BDE5: variable 'v53' is possibly undefined
// 4BE2D: variable 'v54' is possibly undefined
// 4BE2D: variable 'v55' is possibly undefined
// 4BE2D: variable 'v56' is possibly undefined
// 4BE75: variable 'v57' is possibly undefined
// 4BE75: variable 'v58' is possibly undefined
// 4BE75: variable 'v59' is possibly undefined
// 4BEBC: variable 'v60' is possibly undefined
// 4BEBC: variable 'v61' is possibly undefined
// 4BEBC: variable 'v62' is possibly undefined
// 4BF04: variable 'v63' is possibly undefined
// 4BF04: variable 'v64' is possibly undefined
// 4BF04: variable 'v65' is possibly undefined
// 4BF4C: variable 'v66' is possibly undefined
// 4BF4C: variable 'v67' is possibly undefined
// 4BF4C: variable 'v68' is possibly undefined
// 4C0A7: variable 'v69' is possibly undefined
// 4C0A7: variable 'v70' is possibly undefined
// 4C0A7: variable 'v71' is possibly undefined
// 4C0EF: variable 'v72' is possibly undefined
// 4C0EF: variable 'v73' is possibly undefined
// 4C0EF: variable 'v74' is possibly undefined
// 4C137: variable 'v75' is possibly undefined
// 4C137: variable 'v76' is possibly undefined
// 4C137: variable 'v77' is possibly undefined
// 4C19E: variable 'v78' is possibly undefined
// 4C19E: variable 'v79' is possibly undefined
// 4C19E: variable 'v80' is possibly undefined
// 4C213: variable 'v6' is possibly undefined

//----- (000000000004C32C) ----------------------------------------------------
__int64 __fastcall ssh_config_parse_file(__int64 a1, const char *a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  int v5; // [rsp+10h] [rbp-490h] BYREF
  unsigned int v6; // [rsp+14h] [rbp-48Ch]
  FILE *stream; // [rsp+18h] [rbp-488h]
  char v8[112]; // [rsp+20h] [rbp-480h] BYREF
  char s[1032]; // [rsp+90h] [rbp-410h] BYREF
  unsigned __int64 v10; // [rsp+498h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  memset(s, 0, 0x400uLL);
  v6 = 0;
  memset(v8, 0, sizeof(v8));
  stream = fopen(a2, "r");
  if ( !stream )
    return 0LL;
  ssh_log(3, "ssh_config_parse_file", "Reading configuration data from %s", (__int64)a2, v2, v3);
  v5 = 1;
  while ( fgets(s, 1024, stream) )
  {
    if ( (int)ssh_config_parse_line(a1, s, ++v6, &v5, (__int64)v8) < 0 )
    {
      fclose(stream);
      return 0xFFFFFFFFLL;
    }
  }
  fclose(stream);
  return 0LL;
}
// 4C3DF: variable 'v2' is possibly undefined
// 4C3DF: variable 'v3' is possibly undefined

//----- (000000000004C488) ----------------------------------------------------
int __fastcall ssh_connect_socket_close(int a1)
{
  return close(a1);
}

//----- (000000000004C49F) ----------------------------------------------------
int __fastcall getai(const char *a1, int a2, struct addrinfo **a3)
{
  __int64 v3; // r8
  __int64 v4; // r9
  const char *service; // [rsp+28h] [rbp-58h]
  struct addrinfo s; // [rsp+30h] [rbp-50h] BYREF
  char v9[10]; // [rsp+6Eh] [rbp-12h] BYREF
  unsigned __int64 v10; // [rsp+78h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  service = 0LL;
  memset(&s, 0, sizeof(s));
  s.ai_protocol = 6;
  s.ai_family = 0;
  s.ai_socktype = 1;
  if ( a2 )
  {
    snprintf(v9, 0xAuLL, "%hu", (unsigned __int16)a2);
    service = v9;
    s.ai_flags = 1024;
  }
  else
  {
    s.ai_flags = 1;
  }
  if ( ssh_is_ipaddr(a1) )
  {
    ssh_log(3, "getai", "host %s matches an IP address", (__int64)a1, v3, v4);
    s.ai_flags |= 4u;
  }
  return getaddrinfo(a1, service, &s, a3);
}
// 4C566: variable 'v3' is possibly undefined
// 4C566: variable 'v4' is possibly undefined

//----- (000000000004C5A2) ----------------------------------------------------
__int64 __fastcall ssh_connect_ai_timeout(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        struct addrinfo *a4,
        __int64 a5,
        __int64 a6,
        unsigned int fd)
{
  int *v8; // rax
  char *v9; // rax
  __int64 v10; // r9
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  char *v14; // rax
  int *v15; // rax
  char *v16; // rax
  int optval; // [rsp+38h] [rbp-18h] BYREF
  socklen_t optlen; // [rsp+3Ch] [rbp-14h] BYREF
  unsigned int v23; // [rsp+40h] [rbp-10h]
  int v24; // [rsp+44h] [rbp-Ch]
  struct pollfd v25; // [rsp+48h] [rbp-8h] BYREF

  optlen = 4;
  v23 = 1000 * a5 + a6 / 1000;
  optval = ssh_socket_set_nonblocking(fd);
  if ( optval >= 0 )
  {
    ssh_log(1, "ssh_connect_ai_timeout", "Trying to connect to host: %s:%d with timeout %d ms", a2, a3, v23, a6, a5);
    connect(fd, a4->ai_addr, a4->ai_addrlen);
    freeaddrinfo(a4);
    v25.fd = fd;
    v25.revents = 0;
    v25.events = 4;
    optval = ssh_poll(&v25, 1uLL, v23);
    if ( optval )
    {
      if ( optval >= 0 )
      {
        optval = -1;
        v24 = getsockopt(fd, 1, 4, &optval, &optlen);
        if ( v24 < 0 || optval )
        {
          v14 = strerror(optval);
          ssh_set_error(a1, 2, "ssh_connect_ai_timeout", "Connect to %s:%d failed: %s", a2, a3, v14);
          ssh_connect_socket_close(fd);
          return 0xFFFFFFFFLL;
        }
        else
        {
          ssh_log(3, "ssh_connect_ai_timeout", "Socket connected with timeout", v11, v12, v13);
          v24 = ssh_socket_set_blocking(fd);
          if ( v24 >= 0 )
          {
            return fd;
          }
          else
          {
            v15 = __errno_location();
            v16 = strerror(*v15);
            ssh_set_error(
              a1,
              2,
              "ssh_connect_ai_timeout",
              "Failed to set socket as blocking connecting to %s:%d failed: %s",
              a2,
              a3,
              v16);
            ssh_connect_socket_close(fd);
            return 0xFFFFFFFFLL;
          }
        }
      }
      else
      {
        v8 = __errno_location();
        v9 = strerror(*v8);
        ssh_set_error(a1, 2, "ssh_connect_ai_timeout", "poll error: %s", (__int64)v9, v10);
        ssh_connect_socket_close(fd);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      ssh_set_error(a1, 2, "ssh_connect_ai_timeout", "Timeout while connecting to %s:%d", a2, a3);
      ssh_connect_socket_close(fd);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_connect_ai_timeout", "Failed to set socket non-blocking for %s:%d", a2, a3, a6, a5, a4);
    ssh_connect_socket_close(fd);
    return 0xFFFFFFFFLL;
  }
}
// 4C75B: variable 'v10' is possibly undefined
// 4C81A: variable 'v11' is possibly undefined
// 4C81A: variable 'v12' is possibly undefined
// 4C81A: variable 'v13' is possibly undefined

//----- (000000000004C88F) ----------------------------------------------------
int __fastcall set_tcp_nodelay(int a1)
{
  int optval; // [rsp+1Ch] [rbp-4h] BYREF

  optval = 1;
  return setsockopt(a1, 6, 1, &optval, 4u);
}

//----- (000000000004C8C4) ----------------------------------------------------
__int64 __fastcall ssh_connect_host(
        __int64 a1,
        const char *a2,
        const char *a3,
        unsigned int a4,
        __int64 a5,
        __int64 a6)
{
  const char *v6; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  int *v10; // rax
  char *v11; // rax
  __int64 v12; // r9
  const char *v13; // rax
  int *v14; // rax
  char *v15; // rax
  __int64 v16; // r9
  int *v17; // rax
  char *v18; // rax
  __int64 v19; // r9
  int fd; // [rsp+34h] [rbp-2Ch]
  int ecode; // [rsp+38h] [rbp-28h]
  int ecodea; // [rsp+38h] [rbp-28h]
  unsigned int v27; // [rsp+3Ch] [rbp-24h]
  struct addrinfo *ai; // [rsp+40h] [rbp-20h] BYREF
  struct addrinfo *v29; // [rsp+48h] [rbp-18h] BYREF
  int v30[2]; // [rsp+50h] [rbp-10h]
  struct addrinfo *i; // [rsp+58h] [rbp-8h]

  fd = -1;
  ecode = getai(a2, a4, &ai);
  if ( ecode )
  {
    v6 = gai_strerror(ecode);
    ssh_set_error(a1, 2, "ssh_connect_host", "Failed to resolve hostname %s (%s)", (__int64)a2, (__int64)v6);
    return 0xFFFFFFFFLL;
  }
  else
  {
    for ( *(_QWORD *)v30 = ai; *(_QWORD *)v30; *(_QWORD *)v30 = *(_QWORD *)(*(_QWORD *)v30 + 40LL) )
    {
      fd = socket(
             *(_DWORD *)(*(_QWORD *)v30 + 4LL),
             *(_DWORD *)(*(_QWORD *)v30 + 8LL),
             *(_DWORD *)(*(_QWORD *)v30 + 12LL));
      if ( fd >= 0 )
      {
        if ( !a3 )
          goto LABEL_16;
        ssh_log(3, "ssh_connect_host", "Resolving %s", (__int64)a3, v8, v9);
        ecodea = getai(a3, 0, &v29);
        if ( ecodea )
        {
          v13 = gai_strerror(ecodea);
          ssh_set_error(a1, 2, "ssh_connect_host", "Failed to resolve bind address %s (%s)", (__int64)a3, (__int64)v13);
          freeaddrinfo(ai);
          close(fd);
          return 0xFFFFFFFFLL;
        }
        for ( i = v29; i && bind(fd, i->ai_addr, i->ai_addrlen) < 0; i = i->ai_next )
        {
          v14 = __errno_location();
          v15 = strerror(*v14);
          ssh_set_error(a1, 2, "ssh_connect_host", "Binding local address: %s", (__int64)v15, v16);
        }
        freeaddrinfo(v29);
        if ( i )
        {
LABEL_16:
          if ( a5 || a6 )
          {
            v27 = ssh_connect_ai_timeout(a1, (__int64)a2, a4, *(struct addrinfo **)v30, a5, a6, fd);
            freeaddrinfo(ai);
            return v27;
          }
          if ( connect(fd, *(const struct sockaddr **)(*(_QWORD *)v30 + 24LL), *(_DWORD *)(*(_QWORD *)v30 + 16LL)) >= 0 )
            break;
          v17 = __errno_location();
          v18 = strerror(*v17);
          ssh_set_error(a1, 2, "ssh_connect_host", "Connect failed: %s", (__int64)v18, v19);
          ssh_connect_socket_close(fd);
          fd = -1;
        }
        else
        {
          ssh_connect_socket_close(fd);
          fd = -1;
        }
      }
      else
      {
        v10 = __errno_location();
        v11 = strerror(*v10);
        ssh_set_error(a1, 2, "ssh_connect_host", "Socket create failed: %s", (__int64)v11, v12);
      }
    }
    freeaddrinfo(ai);
    return (unsigned int)fd;
  }
}
// 4C9B4: variable 'v12' is possibly undefined
// 4C9E8: variable 'v8' is possibly undefined
// 4C9E8: variable 'v9' is possibly undefined
// 4CAC3: variable 'v16' is possibly undefined
// 4CBAA: variable 'v19' is possibly undefined

//----- (000000000004CBEC) ----------------------------------------------------
__int64 __fastcall ssh_connect_host_nonblocking(__int64 a1, const char *a2, const char *a3, unsigned int a4)
{
  const char *v4; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  int *v8; // rax
  char *v9; // rax
  __int64 v10; // r9
  const char *v11; // rax
  int *v12; // rax
  char *v13; // rax
  __int64 v14; // r9
  int *v15; // rax
  char *v16; // rax
  __int64 v17; // r9
  int *v18; // rax
  char *v19; // rax
  __int64 v20; // r9
  int fd; // [rsp+28h] [rbp-28h]
  int ecode; // [rsp+2Ch] [rbp-24h]
  int ecodea; // [rsp+2Ch] [rbp-24h]
  struct addrinfo *v26; // [rsp+30h] [rbp-20h] BYREF
  struct addrinfo *ai; // [rsp+38h] [rbp-18h] BYREF
  struct addrinfo *i; // [rsp+40h] [rbp-10h]
  struct addrinfo *j; // [rsp+48h] [rbp-8h]

  fd = -1;
  ecode = getai(a2, a4, &v26);
  if ( ecode )
  {
    v4 = gai_strerror(ecode);
    ssh_set_error(a1, 2, "ssh_connect_host_nonblocking", "Failed to resolve hostname %s (%s)", (__int64)a2, (__int64)v4);
    return 0xFFFFFFFFLL;
  }
  else
  {
    for ( i = v26; i; i = i->ai_next )
    {
      fd = socket(i->ai_family, i->ai_socktype, i->ai_protocol);
      if ( fd >= 0 )
      {
        if ( !a3 )
          goto LABEL_15;
        ssh_log(3, "ssh_connect_host_nonblocking", "Resolving %s", (__int64)a3, v6, v7);
        ecodea = getai(a3, 0, &ai);
        if ( ecodea )
        {
          v11 = gai_strerror(ecodea);
          ssh_set_error(
            a1,
            2,
            "ssh_connect_host_nonblocking",
            "Failed to resolve bind address %s (%s)",
            (__int64)a3,
            (__int64)v11);
          ssh_connect_socket_close(fd);
          fd = -1;
          break;
        }
        for ( j = ai; j && bind(fd, j->ai_addr, j->ai_addrlen) < 0; j = j->ai_next )
        {
          v12 = __errno_location();
          v13 = strerror(*v12);
          ssh_set_error(a1, 2, "ssh_connect_host_nonblocking", "Binding local address: %s", (__int64)v13, v14);
        }
        freeaddrinfo(ai);
        if ( j )
        {
LABEL_15:
          if ( ssh_socket_set_nonblocking(fd) >= 0 )
          {
            if ( *(_DWORD *)(a1 + 1672) && set_tcp_nodelay(fd) < 0 )
            {
              v15 = __errno_location();
              v16 = strerror(*v15);
              ssh_set_error(
                a1,
                2,
                "ssh_connect_host_nonblocking",
                "Failed to set TCP_NODELAY on socket: %s",
                (__int64)v16,
                v17);
              ssh_connect_socket_close(fd);
              fd = -1;
            }
            else
            {
              *__errno_location() = 0;
              if ( connect(fd, i->ai_addr, i->ai_addrlen) != -1 || !*__errno_location() || *__errno_location() == 115 )
                break;
              v18 = __errno_location();
              v19 = strerror(*v18);
              ssh_set_error(a1, 2, "ssh_connect_host_nonblocking", "Failed to connect: %s", (__int64)v19, v20);
              ssh_connect_socket_close(fd);
              fd = -1;
            }
          }
          else
          {
            ssh_set_error(
              a1,
              2,
              "ssh_connect_host_nonblocking",
              "Failed to set socket non-blocking for %s:%d",
              (__int64)a2,
              a4);
            ssh_connect_socket_close(fd);
            fd = -1;
          }
        }
        else
        {
          ssh_connect_socket_close(fd);
          fd = -1;
        }
      }
      else
      {
        v8 = __errno_location();
        v9 = strerror(*v8);
        ssh_set_error(a1, 2, "ssh_connect_host_nonblocking", "Socket create failed: %s", (__int64)v9, v10);
      }
    }
    freeaddrinfo(v26);
    return (unsigned int)fd;
  }
}
// 4CCD4: variable 'v10' is possibly undefined
// 4CD08: variable 'v6' is possibly undefined
// 4CD08: variable 'v7' is possibly undefined
// 4CDD9: variable 'v14' is possibly undefined
// 4CECB: variable 'v17' is possibly undefined
// 4CF60: variable 'v20' is possibly undefined

//----- (000000000004CFA2) ----------------------------------------------------
__int64 __fastcall ssh_select_cb(int a1, char a2, __int64 a3)
{
  if ( (a2 & 1) != 0 )
    *(_QWORD *)(a3 + 8LL * (a1 / 64)) |= 1LL << (a1 % 64);
  return 0LL;
}

//----- (000000000004D010) ----------------------------------------------------
__int64 __fastcall ssh_select(__int64 a1, _QWORD *a2, int a3, _QWORD *a4, _QWORD *a5)
{
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  int j; // [rsp+3Ch] [rbp-C4h]
  int m; // [rsp+3Ch] [rbp-C4h]
  int n; // [rsp+3Ch] [rbp-C4h]
  int i; // [rsp+40h] [rbp-C0h]
  int k; // [rsp+40h] [rbp-C0h]
  int v17; // [rsp+44h] [rbp-BCh]
  int v18; // [rsp+48h] [rbp-B8h]
  int v19; // [rsp+4Ch] [rbp-B4h]
  unsigned int v20; // [rsp+50h] [rbp-B0h]
  _QWORD *v21; // [rsp+68h] [rbp-98h]
  __time_t v22[2]; // [rsp+70h] [rbp-90h] BYREF
  __int64 v23[16]; // [rsp+80h] [rbp-80h] BYREF

  v21 = ssh_event_new();
  v19 = 1;
  v18 = 1000 * *a5 + a5[1] / 1000LL;
  v20 = v18;
  for ( i = 0; *(_QWORD *)(8LL * i + a1); ++i )
    ssh_event_add_session((__int64)v21, **(_QWORD **)(8LL * i + a1));
  memset(v23, 0, sizeof(v23));
  for ( j = 0; j < a3; ++j )
  {
    if ( (a4[j / 64] & (1LL << (j % 64))) != 0 )
    {
      ssh_event_add_fd((_QWORD **)v21, j, 1, (__int64)ssh_select_cb, (__int64)a4);
      v23[j / 64] |= 1LL << (j % 64);
    }
  }
  *a2 = 0LL;
  memset(a4, 0, 0x80uLL);
  ssh_timestamp_init(v22);
  while ( 1 )
  {
    v17 = 0;
    for ( k = 0; *(_QWORD *)(8LL * k + a1); ++k )
    {
      if ( (unsigned int)ssh_channel_poll(*(_QWORD *)(8LL * k + a1), 0) )
      {
        v5 = 8LL * k;
        a2[v17++] = *(_QWORD *)(v5 + a1);
      }
      else if ( (unsigned int)ssh_channel_poll(*(_QWORD *)(8LL * k + a1), 1) )
      {
        v5 = 8LL * k;
        a2[v17++] = *(_QWORD *)(v5 + a1);
      }
    }
    a2[v17] = 0LL;
    if ( v17 )
      break;
    for ( m = 0; m < a3; ++m )
    {
      v5 = (unsigned int)(m % 64);
      if ( (a4[m / 64] & (1LL << v5)) != 0 )
        goto LABEL_26;
    }
    if ( !v19 && ssh_timeout_elapsed(v22, v20, v20, v5, v6, v7) || (unsigned int)ssh_event_dopoll(v21, v18) == -1 )
      break;
    v18 = ssh_timeout_update(v22, v20);
    v19 = 0;
  }
LABEL_26:
  for ( n = 0; n < a3; ++n )
  {
    if ( (v23[n / 64] & (1LL << (n % 64))) != 0 )
      ssh_event_remove_fd((__int64)v21, n);
  }
  ssh_event_free((_QWORD **)v21);
  return 0LL;
}
// 4D430: variable 'v5' is possibly undefined
// 4D430: variable 'v6' is possibly undefined
// 4D430: variable 'v7' is possibly undefined
// 4D010: using guessed type __int64 var_80[16];
// 4D010: using guessed type __time_t var_90[2];

//----- (000000000004D521) ----------------------------------------------------
_DWORD *__fastcall ssh_connector_new(__int64 a1)
{
  _DWORD *v2; // [rsp+18h] [rbp-8h]

  v2 = calloc(1uLL, 0x158uLL);
  if ( v2 )
  {
    *(_QWORD *)v2 = a1;
    v2[6] = -1;
    v2[7] = -1;
    *((_QWORD *)v2 + 8) = 136LL;
    *((_QWORD *)v2 + 25) = 136LL;
    *((_QWORD *)v2 + 9) = v2;
    *((_QWORD *)v2 + 10) = ssh_connector_channel_data_cb;
    *((_QWORD *)v2 + 26) = v2;
    *((_QWORD *)v2 + 41) = ssh_connector_channel_write_wontblock_cb;
    return v2;
  }
  else
  {
    ssh_set_error_oom(a1, "ssh_connector_new");
    return 0LL;
  }
}

//----- (000000000004D5DF) ----------------------------------------------------
void __fastcall ssh_connector_free(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 8) )
    ssh_remove_channel_callbacks(*(_QWORD *)(a1 + 8), a1 + 64);
  if ( *(_QWORD *)(a1 + 16) )
    ssh_remove_channel_callbacks(*(_QWORD *)(a1 + 16), a1 + 200);
  if ( *(_QWORD *)(a1 + 48) )
    ssh_connector_remove_event(a1);
  if ( *(_QWORD *)(a1 + 32) )
  {
    ssh_poll_free(*(_QWORD **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0LL;
  }
  if ( *(_QWORD *)(a1 + 40) )
  {
    ssh_poll_free(*(_QWORD **)(a1 + 40));
    *(_QWORD *)(a1 + 40) = 0LL;
  }
  free((void *)a1);
}

//----- (000000000004D6B8) ----------------------------------------------------
__int64 __fastcall ssh_connector_set_in_channel(__int64 a1, __int64 *a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  *(_QWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 24) = -1;
  *(_DWORD *)(a1 + 336) = a3;
  if ( (a3 & 1) == 0 && (a3 & 2) == 0 )
    *(_DWORD *)(a1 + 336) = 1;
  return ssh_add_channel_callbacks(a2, (_QWORD *)(a1 + 64), a1 + 64, a4, a5, a6);
}

//----- (000000000004D72A) ----------------------------------------------------
__int64 __fastcall ssh_connector_set_out_channel(__int64 a1, __int64 *a2, int a3, __int64 a4, __int64 a5, __int64 a6)
{
  *(_QWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 28) = -1;
  *(_DWORD *)(a1 + 340) = a3;
  if ( (a3 & 1) == 0 && (a3 & 2) == 0 )
    *(_DWORD *)(a1 + 336) = 1;
  return ssh_add_channel_callbacks(a2, (_QWORD *)(a1 + 200), a1 + 200, a4, a5, a6);
}

//----- (000000000004D79F) ----------------------------------------------------
__int64 __fastcall ssh_connector_set_in_fd(__int64 a1, int a2)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 24) = a2;
  result = a1;
  *(_QWORD *)(a1 + 8) = 0LL;
  return result;
}

//----- (000000000004D7C3) ----------------------------------------------------
__int64 __fastcall ssh_connector_set_out_fd(__int64 a1, int a2)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 28) = a2;
  result = a1;
  *(_QWORD *)(a1 + 16) = 0LL;
  return result;
}

//----- (000000000004D7E7) ----------------------------------------------------
void ssh_connector_except()
{
  ;
}

//----- (000000000004D7F5) ----------------------------------------------------
void ssh_connector_except_channel()
{
  ;
}

//----- (000000000004D804) ----------------------------------------------------
__int64 __fastcall ssh_connector_reset_pollevents(__int64 a1)
{
  __int64 result; // rax

  if ( *(_DWORD *)(a1 + 24) != -1 )
  {
    if ( *(_DWORD *)(a1 + 56) )
      ssh_poll_remove_events(*(__int64 **)(a1 + 32), 1);
    else
      ssh_poll_add_events(*(__int64 **)(a1 + 32), 1);
  }
  result = *(unsigned int *)(a1 + 28);
  if ( (_DWORD)result != -1 )
  {
    if ( *(_DWORD *)(a1 + 60) )
      return ssh_poll_remove_events(*(__int64 **)(a1 + 40), 4);
    else
      return ssh_poll_add_events(*(__int64 **)(a1 + 40), 4);
  }
  return result;
}

//----- (000000000004D899) ----------------------------------------------------
unsigned __int64 __fastcall ssh_connector_fd_in_cb(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  int v6; // eax
  __int64 v7; // r8
  __int64 v8; // r9
  int v10; // [rsp+14h] [rbp-102Ch]
  int v11; // [rsp+18h] [rbp-1028h]
  int v12; // [rsp+18h] [rbp-1028h]
  int v13; // [rsp+1Ch] [rbp-1024h]
  int v14; // [rsp+20h] [rbp-1020h]
  unsigned __int64 v15; // [rsp+28h] [rbp-1018h]
  char buf[4104]; // [rsp+30h] [rbp-1010h] BYREF
  unsigned __int64 v17; // [rsp+1038h] [rbp-8h]

  v17 = __readfsqword(0x28u);
  v10 = 4096;
  v13 = 0;
  ssh_log(4, "ssh_connector_fd_in_cb", "connector POLLIN event for fd %d", *(unsigned int *)(a1 + 24), a5, a6);
  if ( !*(_DWORD *)(a1 + 60) )
  {
    *(_DWORD *)(a1 + 56) = 1;
    return __readfsqword(0x28u) ^ v17;
  }
  if ( *(_QWORD *)(a1 + 16) )
  {
    v15 = (unsigned int)ssh_channel_window_size(*(_QWORD *)(a1 + 16));
    v6 = 4096;
    if ( v15 <= 0x1000 )
      v6 = v15;
    v10 = v6;
  }
  v14 = read(*(_DWORD *)(a1 + 24), buf, v10);
  if ( v14 >= 0 )
  {
    if ( *(_QWORD *)(a1 + 16) )
    {
      if ( v14 )
      {
        while ( v13 != v14 )
        {
          if ( (*(_DWORD *)(a1 + 340) & 1) != 0 )
            v11 = ssh_channel_write(*(_QWORD *)(a1 + 16), (__int64)&buf[v13], v14 - v13, (__int64)&buf[v13], v7, v8);
          else
            v11 = ssh_channel_write_stderr(
                    *(_QWORD *)(a1 + 16),
                    (__int64)&buf[v13],
                    v14 - v13,
                    (__int64)&buf[v13],
                    v7,
                    v8);
          if ( v11 == -1 )
            return __readfsqword(0x28u) ^ v17;
          v13 += v11;
        }
      }
      else
      {
        ssh_channel_send_eof(*(_QWORD *)(a1 + 16));
      }
    }
    else
    {
      if ( *(_DWORD *)(a1 + 28) == -1 )
      {
        ssh_set_error(*(_QWORD *)a1, 2, "ssh_connector_fd_in_cb", "output socket or channel closed", v7, v8);
        return __readfsqword(0x28u) ^ v17;
      }
      if ( v14 )
      {
        while ( v13 != v14 )
        {
          v12 = write(*(_DWORD *)(a1 + 28), &buf[v13], v14 - v13);
          if ( v12 < 0 )
            goto LABEL_7;
          v13 += v12;
        }
      }
      else
      {
        close(*(_DWORD *)(a1 + 28));
        *(_DWORD *)(a1 + 28) = -1;
      }
    }
    *(_DWORD *)(a1 + 60) = 0;
    *(_DWORD *)(a1 + 56) = 0;
    return __readfsqword(0x28u) ^ v17;
  }
LABEL_7:
  ssh_connector_except();
  return __readfsqword(0x28u) ^ v17;
}
// 4D9E8: conditional instruction was optimized away because %var_1020.4>=1
// 4DA3B: variable 'v7' is possibly undefined
// 4DA3B: variable 'v8' is possibly undefined

//----- (000000000004DBE9) ----------------------------------------------------
unsigned __int64 __fastcall ssh_connector_fd_out_cb(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  int v11; // [rsp+14h] [rbp-101Ch]
  int nonblocking; // [rsp+18h] [rbp-1018h]
  int v13; // [rsp+1Ch] [rbp-1014h]
  char v14[4104]; // [rsp+20h] [rbp-1010h] BYREF
  unsigned __int64 v15; // [rsp+1028h] [rbp-8h]

  v15 = __readfsqword(0x28u);
  v11 = 0;
  ssh_log(4, "ssh_connector_fd_out_cb", "connector POLLOUT event for fd %d", *(unsigned int *)(a1 + 28), a5, a6);
  if ( !*(_DWORD *)(a1 + 56) )
  {
    *(_DWORD *)(a1 + 60) = 1;
    return __readfsqword(0x28u) ^ v15;
  }
  if ( !*(_QWORD *)(a1 + 8) )
  {
    if ( *(_DWORD *)(a1 + 24) == -1 )
    {
      ssh_set_error(*(_QWORD *)a1, 2, "ssh_connector_fd_out_cb", "Output socket or channel closed", v8, v9);
      return __readfsqword(0x28u) ^ v15;
    }
    *(_DWORD *)(a1 + 60) = 1;
    ssh_connector_fd_in_cb(a1, (__int64)"ssh_connector_fd_out_cb", v6, v7, v8, v9);
    goto LABEL_18;
  }
  nonblocking = ssh_channel_read_nonblocking(*(__int64 **)(a1 + 8), v14, 4096LL, 0LL, v8, v9);
  if ( nonblocking != -1 )
  {
    if ( !nonblocking && (unsigned int)ssh_channel_is_eof(*(_QWORD *)(a1 + 8)) )
    {
      close(*(_DWORD *)(a1 + 28));
      *(_DWORD *)(a1 + 28) = -1;
      return __readfsqword(0x28u) ^ v15;
    }
    if ( nonblocking > 0 )
    {
      while ( v11 != nonblocking )
      {
        v13 = write(*(_DWORD *)(a1 + 28), &v14[v11], nonblocking - v11);
        if ( v13 < 0 )
        {
          ssh_connector_except();
          return __readfsqword(0x28u) ^ v15;
        }
        v11 += v13;
      }
    }
LABEL_18:
    *(_DWORD *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 60) = 0;
    return __readfsqword(0x28u) ^ v15;
  }
  ssh_connector_except_channel();
  return __readfsqword(0x28u) ^ v15;
}
// 4DC82: variable 'v8' is possibly undefined
// 4DC82: variable 'v9' is possibly undefined
// 4DDB2: variable 'v6' is possibly undefined
// 4DDB2: variable 'v7' is possibly undefined

//----- (000000000004DE27) ----------------------------------------------------
__int64 __fastcall ssh_connector_fd_cb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  if ( (a3 & 8) != 0 )
  {
    ssh_connector_except();
  }
  else if ( (a3 & 0x11) != 0 && *(_DWORD *)(a4 + 24) == (_DWORD)a2 )
  {
    ssh_connector_fd_in_cb(a4, a2, a3, a4, a5, a6);
  }
  else if ( ((a3 & 4) != 0 || (a3 & 0x10) != 0) && *(_DWORD *)(a4 + 28) == (_DWORD)a2 )
  {
    ssh_connector_fd_out_cb(a4, a2, a3, a4, a5, a6);
  }
  ssh_connector_reset_pollevents(a4);
  return 0LL;
}

//----- (000000000004DEC5) ----------------------------------------------------
__int64 __fastcall ssh_connector_channel_data_cb(
        __int64 a1,
        __int64 a2,
        const void *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // r9
  unsigned int v9; // eax
  __int64 v10; // r8
  __int64 v11; // r9
  int v12; // [rsp+10h] [rbp-40h]
  unsigned int n; // [rsp+14h] [rbp-3Ch]
  int v15; // [rsp+38h] [rbp-18h]

  n = a4;
  v12 = a5;
  ssh_log(4, "ssh_connector_channel_data_cb", "connector data on channel", a4, a5, a6);
  if ( v12 && (*(_DWORD *)(a6 + 336) & 2) == 0 )
    return 0LL;
  if ( !v12 && (*(_DWORD *)(a6 + 336) & 1) == 0 )
    return 0LL;
  if ( *(_DWORD *)(a6 + 60) )
  {
    if ( *(_QWORD *)(a6 + 16) )
    {
      v9 = ssh_channel_window_size(*(_QWORD *)(a6 + 16));
      if ( n <= (unsigned __int64)v9 )
        v9 = n;
      if ( v12 && (*(_DWORD *)(a6 + 340) & 2) != 0
        || (v12 || (*(_DWORD *)(a6 + 340) & 1) == 0) && (*(_DWORD *)(a6 + 340) & 1) == 0 )
      {
        v15 = ssh_channel_write_stderr(*(_QWORD *)(a6 + 16), (__int64)a3, v9, (__int64)a3, v10, v11);
      }
      else
      {
        v15 = ssh_channel_write(*(_QWORD *)(a6 + 16), (__int64)a3, v9, (__int64)a3, v10, v11);
      }
      if ( v15 == -1 )
        ssh_connector_except_channel();
    }
    else
    {
      if ( *(_DWORD *)(a6 + 28) == -1 )
      {
        ssh_set_error(a1, 2, "ssh_connector_channel_data_cb", "output socket or channel closed", v6, v7);
        return 0xFFFFFFFFLL;
      }
      v15 = write(*(_DWORD *)(a6 + 28), a3, n);
      if ( v15 < 0 )
        ssh_connector_except();
    }
    *(_DWORD *)(a6 + 60) = 0;
    *(_DWORD *)(a6 + 56) = 0;
    if ( v15 < n )
      *(_DWORD *)(a6 + 56) = 1;
    ssh_connector_reset_pollevents(a6);
    return (unsigned int)v15;
  }
  else
  {
    *(_DWORD *)(a6 + 56) = 1;
    return 0LL;
  }
}
// 4DFF7: variable 'v10' is possibly undefined
// 4DFF7: variable 'v11' is possibly undefined
// 4E0D4: variable 'v6' is possibly undefined
// 4E0D4: variable 'v7' is possibly undefined

//----- (000000000004E12C) ----------------------------------------------------
__int64 __fastcall ssh_connector_channel_write_wontblock_cb(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // eax
  __int64 v11; // r8
  __int64 v12; // r9
  signed int nonblocking; // [rsp+28h] [rbp-1028h]
  char v17[4104]; // [rsp+40h] [rbp-1010h] BYREF
  unsigned __int64 v18; // [rsp+1048h] [rbp-8h]

  v18 = __readfsqword(0x28u);
  ssh_log(4, "ssh_connector_channel_write_wontblock_cb", "Channel write won't block", a4, a5, a6, a4);
  if ( !*(_DWORD *)(a4 + 56) )
  {
    *(_DWORD *)(a4 + 60) = 1;
    return 0LL;
  }
  if ( !*(_QWORD *)(a4 + 8) )
  {
    if ( *(_DWORD *)(a4 + 24) == -1 )
    {
      ssh_set_error(a1, 2, "ssh_connector_channel_write_wontblock_cb", "Output socket or channel closed", v8, v9);
      return 0LL;
    }
    *(_DWORD *)(a4 + 60) = 1;
    ssh_connector_fd_in_cb(a4, (__int64)"ssh_connector_channel_write_wontblock_cb", v6, v7, v8, v9);
    ssh_connector_reset_pollevents(a4);
    goto LABEL_16;
  }
  v10 = 4096;
  if ( a3 <= 0x1000 )
    v10 = a3;
  nonblocking = ssh_channel_read_nonblocking(*(__int64 **)(a4 + 8), v17, v10, 0LL, v8, v9);
  if ( nonblocking != -1 )
  {
    if ( !nonblocking && (unsigned int)ssh_channel_is_eof(*(_QWORD *)(a4 + 8)) )
    {
      ssh_channel_send_eof(*(_QWORD *)(a4 + 16));
      goto LABEL_16;
    }
    if ( nonblocking <= 0
      || (unsigned int)ssh_channel_write(*(_QWORD *)(a4 + 16), (__int64)v17, nonblocking, (__int64)v17, v11, v12) != -1 )
    {
      goto LABEL_16;
    }
  }
  ssh_connector_except_channel();
LABEL_16:
  *(_DWORD *)(a4 + 56) = 0;
  *(_DWORD *)(a4 + 60) = 0;
  return 0LL;
}
// 4E1F5: variable 'v8' is possibly undefined
// 4E1F5: variable 'v9' is possibly undefined
// 4E28E: variable 'v11' is possibly undefined
// 4E28E: variable 'v12' is possibly undefined
// 4E2EC: variable 'v6' is possibly undefined
// 4E2EC: variable 'v7' is possibly undefined

//----- (000000000004E377) ----------------------------------------------------
__int64 __fastcall ssh_connector_set_event(__int64 a1, _QWORD **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 session; // rax
  unsigned int v8; // [rsp+14h] [rbp-Ch]
  __int64 v9; // [rsp+18h] [rbp-8h]

  v8 = 0;
  if ( (*(_DWORD *)(a1 + 24) != -1 || *(_QWORD *)(a1 + 8)) && (*(_DWORD *)(a1 + 28) != -1 || *(_QWORD *)(a1 + 16)) )
  {
    *(_QWORD *)(a1 + 48) = a2;
    if ( *(_DWORD *)(a1 + 24) == -1 )
      goto LABEL_25;
    if ( !*(_QWORD *)(a1 + 32) )
      *(_QWORD *)(a1 + 32) = ssh_poll_new(*(_DWORD *)(a1 + 24), 9, (__int64)ssh_connector_fd_cb, a1);
    v8 = ssh_event_add_poll(a2, *(_QWORD *)(a1 + 32));
    if ( !v8 )
    {
LABEL_25:
      if ( *(_DWORD *)(a1 + 28) == -1 )
        goto LABEL_26;
      if ( !*(_QWORD *)(a1 + 40) )
        *(_QWORD *)(a1 + 40) = ssh_poll_new(*(_DWORD *)(a1 + 28), 12, (__int64)ssh_connector_fd_cb, a1);
      v8 = ssh_event_add_poll(a2, *(_QWORD *)(a1 + 40));
      if ( !v8 )
      {
LABEL_26:
        if ( *(_QWORD *)(a1 + 8) )
        {
          session = ssh_channel_get_session(*(_QWORD *)(a1 + 8));
          v8 = ssh_event_add_session((__int64)a2, session);
          if ( v8 )
            return v8;
          if ( (int)ssh_channel_poll_timeout(*(_QWORD *)(a1 + 8), 0, 0) > 0 )
            *(_DWORD *)(a1 + 56) = 1;
        }
        if ( *(_QWORD *)(a1 + 16) )
        {
          v9 = ssh_channel_get_session(*(_QWORD *)(a1 + 16));
          v8 = ssh_event_add_session((__int64)a2, v9);
          if ( !v8 )
          {
            if ( (unsigned int)ssh_channel_window_size(*(_QWORD *)(a1 + 16)) )
              *(_DWORD *)(a1 + 60) = 1;
          }
        }
      }
    }
  }
  else
  {
    v8 = -1;
    ssh_set_error(*(_QWORD *)a1, 2, "ssh_connector_set_event", "Connector not complete", a5, a6, a2);
  }
  return v8;
}

//----- (000000000004E5A3) ----------------------------------------------------
__int64 __fastcall ssh_connector_remove_event(__int64 a1)
{
  __int64 session; // [rsp+18h] [rbp-8h]
  __int64 v3; // [rsp+18h] [rbp-8h]

  if ( *(_QWORD *)(a1 + 32) )
  {
    ssh_event_remove_poll(*(_QWORD ***)(a1 + 48), *(_QWORD **)(a1 + 32));
    ssh_poll_free(*(_QWORD **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0LL;
  }
  if ( *(_QWORD *)(a1 + 40) )
  {
    ssh_event_remove_poll(*(_QWORD ***)(a1 + 48), *(_QWORD **)(a1 + 40));
    ssh_poll_free(*(_QWORD **)(a1 + 40));
    *(_QWORD *)(a1 + 40) = 0LL;
  }
  if ( *(_QWORD *)(a1 + 8) )
  {
    session = ssh_channel_get_session(*(_QWORD *)(a1 + 8));
    ssh_event_remove_session(*(__int64 **)(a1 + 48), session);
    *(_QWORD *)(a1 + 8) = 0LL;
  }
  if ( *(_QWORD *)(a1 + 16) )
  {
    v3 = ssh_channel_get_session(*(_QWORD *)(a1 + 16));
    ssh_event_remove_session(*(__int64 **)(a1 + 48), v3);
    *(_QWORD *)(a1 + 16) = 0LL;
  }
  *(_QWORD *)(a1 + 48) = 0LL;
  return 0LL;
}

//----- (000000000004E6D2) ----------------------------------------------------
__int64 __fastcall ssh_client_ecdh_reply(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  int pubkey_blob; // [rsp+14h] [rbp-1Ch]
  unsigned int v15; // [rsp+14h] [rbp-1Ch]
  void *v16; // [rsp+18h] [rbp-18h]
  uint32_t *ssh_string; // [rsp+20h] [rbp-10h]
  void *v18; // [rsp+28h] [rbp-8h]

  ssh_string = (uint32_t *)ssh_buffer_get_ssh_string(a2);
  if ( ssh_string )
  {
    pubkey_blob = ssh_dh_import_next_pubkey_blob(a1, ssh_string);
    ssh_string_free(ssh_string);
    if ( !pubkey_blob )
    {
      v16 = ssh_buffer_get_ssh_string(a2);
      if ( v16 )
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 56LL) = v16;
        v18 = ssh_buffer_get_ssh_string(a2);
        if ( v18 )
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 160LL) = v18;
          if ( (int)ecdh_build_k(a1) >= 0 )
          {
            if ( (int)ssh_buffer_add_u8(*(_QWORD *)(a1 + 1152), 21) >= 0 )
            {
              v15 = ssh_packet_send(a1);
              ssh_log(2, "ssh_client_ecdh_reply", "SSH_MSG_NEWKEYS sent", v10, v11, v12);
              return v15;
            }
          }
          else
          {
            ssh_set_error(a1, 2, "ssh_client_ecdh_reply", "Cannot build k number", v8, v9);
          }
        }
        else
        {
          ssh_set_error(a1, 2, "ssh_client_ecdh_reply", "No signature in packet", v6, v7);
        }
      }
      else
      {
        ssh_set_error(a1, 2, "ssh_client_ecdh_reply", "No Q_S ECC point in packet", v4, v5);
      }
    }
  }
  else
  {
    ssh_set_error(a1, 2, "ssh_client_ecdh_reply", "No public key in packet", v2, v3);
  }
  return 0xFFFFFFFFLL;
}
// 4E730: variable 'v2' is possibly undefined
// 4E730: variable 'v3' is possibly undefined
// 4E79C: variable 'v4' is possibly undefined
// 4E79C: variable 'v5' is possibly undefined
// 4E7EF: variable 'v6' is possibly undefined
// 4E7EF: variable 'v7' is possibly undefined
// 4E846: variable 'v8' is possibly undefined
// 4E846: variable 'v9' is possibly undefined
// 4E890: variable 'v10' is possibly undefined
// 4E890: variable 'v11' is possibly undefined
// 4E890: variable 'v12' is possibly undefined

//----- (000000000004E8A5) ----------------------------------------------------
__int64 __fastcall equal_0(unsigned int a1, int a2)
{
  return ((a2 ^ a1) - 1) >> 31;
}

//----- (000000000004E8C5) ----------------------------------------------------
_BOOL8 __fastcall ge(int a1, int a2)
{
  return a1 - a2 >= 0;
}

//----- (000000000004E8E8) ----------------------------------------------------
__int64 __fastcall times19(int a1)
{
  return (unsigned int)(19 * a1);
}

//----- (000000000004E905) ----------------------------------------------------
__int64 __fastcall times38(int a1)
{
  return (unsigned int)(38 * a1);
}

//----- (000000000004E925) ----------------------------------------------------
void __fastcall reduce_add_sub_0(_DWORD *a1)
{
  int j; // [rsp+Ch] [rbp-Ch]
  int i; // [rsp+10h] [rbp-8h]
  int v3; // [rsp+14h] [rbp-4h]

  for ( i = 0; i <= 3; ++i )
  {
    v3 = a1[31] >> 7;
    a1[31] &= 0x7Fu;
    *a1 += times19(v3);
    for ( j = 0; j <= 30; ++j )
    {
      a1[j + 1] += a1[j] >> 8;
      a1[j] = (unsigned __int8)a1[j];
    }
  }
}

//----- (000000000004E9F5) ----------------------------------------------------
void __fastcall reduce_mul(_DWORD *a1)
{
  int j; // [rsp+Ch] [rbp-Ch]
  int i; // [rsp+10h] [rbp-8h]
  int v3; // [rsp+14h] [rbp-4h]

  for ( i = 0; i <= 1; ++i )
  {
    v3 = a1[31] >> 7;
    a1[31] &= 0x7Fu;
    *a1 += times19(v3);
    for ( j = 0; j <= 30; ++j )
    {
      a1[j + 1] += a1[j] >> 8;
      a1[j] = (unsigned __int8)a1[j];
    }
  }
}

//----- (000000000004EAC5) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_freeze(__int64 a1)
{
  __int64 result; // rax
  int i; // [rsp+10h] [rbp-8h]
  int j; // [rsp+10h] [rbp-8h]
  int v4; // [rsp+14h] [rbp-4h]
  _BOOL4 v5; // [rsp+14h] [rbp-4h]

  v4 = equal_0(*(_DWORD *)(a1 + 124), 127);
  for ( i = 30; i > 0; --i )
    v4 &= equal_0(*(_DWORD *)(a1 + 4LL * i), 255);
  v5 = -(ge(*(_DWORD *)a1, 237) & v4);
  *(_DWORD *)(a1 + 124) -= v5 & 0x7F;
  for ( j = 30; j > 0; --j )
    *(_DWORD *)(a1 + 4LL * j) -= v5;
  result = a1;
  *(_DWORD *)a1 -= v5 & 0xED;
  return result;
}

//----- (000000000004EB99) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_unpack(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i <= 31; ++i )
    *(_DWORD *)(a1 + 4LL * i) = *(unsigned __int8 *)(i + a2);
  result = a1;
  *(_DWORD *)(a1 + 124) &= 0x7Fu;
  return result;
}

//----- (000000000004EBEE) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_pack(__int64 a1, __int64 *a2)
{
  __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-84h]
  __int64 v4[16]; // [rsp+20h] [rbp-80h] BYREF

  v4[0] = *a2;
  v4[1] = a2[1];
  v4[2] = a2[2];
  v4[3] = a2[3];
  v4[4] = a2[4];
  v4[5] = a2[5];
  v4[6] = a2[6];
  v4[7] = a2[7];
  v4[8] = a2[8];
  v4[9] = a2[9];
  v4[10] = a2[10];
  v4[11] = a2[11];
  v4[12] = a2[12];
  v4[13] = a2[13];
  v4[14] = a2[14];
  v4[15] = a2[15];
  result = crypto_sign_ed25519_ref_fe25519_freeze((__int64)v4);
  for ( i = 0; i <= 31; ++i )
  {
    result = *((unsigned int *)v4 + i);
    *(_BYTE *)(a1 + i) = result;
  }
  return result;
}

//----- (000000000004ECD9) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_iszero(__int64 *a1)
{
  int i; // [rsp+18h] [rbp-88h]
  unsigned int v3; // [rsp+1Ch] [rbp-84h]
  __int64 v4[16]; // [rsp+20h] [rbp-80h] BYREF

  v4[0] = *a1;
  v4[1] = a1[1];
  v4[2] = a1[2];
  v4[3] = a1[3];
  v4[4] = a1[4];
  v4[5] = a1[5];
  v4[6] = a1[6];
  v4[7] = a1[7];
  v4[8] = a1[8];
  v4[9] = a1[9];
  v4[10] = a1[10];
  v4[11] = a1[11];
  v4[12] = a1[12];
  v4[13] = a1[13];
  v4[14] = a1[14];
  v4[15] = a1[15];
  crypto_sign_ed25519_ref_fe25519_freeze((__int64)v4);
  v3 = equal_0(v4[0], 0);
  for ( i = 1; i <= 31; ++i )
    v3 &= equal_0(*((_DWORD *)v4 + i), 0);
  return v3;
}

//----- (000000000004EDDE) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_iseq_vartime(__int64 *a1, __int64 *a2)
{
  int i; // [rsp+1Ch] [rbp-104h]
  __int64 v4[16]; // [rsp+20h] [rbp-100h] BYREF
  __int64 v5[16]; // [rsp+A0h] [rbp-80h] BYREF

  v4[0] = *a1;
  v4[1] = a1[1];
  v4[2] = a1[2];
  v4[3] = a1[3];
  v4[4] = a1[4];
  v4[5] = a1[5];
  v4[6] = a1[6];
  v4[7] = a1[7];
  v4[8] = a1[8];
  v4[9] = a1[9];
  v4[10] = a1[10];
  v4[11] = a1[11];
  v4[12] = a1[12];
  v4[13] = a1[13];
  v4[14] = a1[14];
  v4[15] = a1[15];
  v5[0] = *a2;
  v5[1] = a2[1];
  v5[2] = a2[2];
  v5[3] = a2[3];
  v5[4] = a2[4];
  v5[5] = a2[5];
  v5[6] = a2[6];
  v5[7] = a2[7];
  v5[8] = a2[8];
  v5[9] = a2[9];
  v5[10] = a2[10];
  v5[11] = a2[11];
  v5[12] = a2[12];
  v5[13] = a2[13];
  v5[14] = a2[14];
  v5[15] = a2[15];
  crypto_sign_ed25519_ref_fe25519_freeze((__int64)v4);
  crypto_sign_ed25519_ref_fe25519_freeze((__int64)v5);
  for ( i = 0; i <= 31; ++i )
  {
    if ( *((_DWORD *)v4 + i) != *((_DWORD *)v5 + i) )
      return 0LL;
  }
  return 1LL;
}

//----- (000000000004EF97) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_cmov(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 result; // rax
  int i; // [rsp+1Ch] [rbp-8h]

  result = a3;
  for ( i = 0; i <= 31; ++i )
  {
    result = a1;
    *(_DWORD *)(a1 + 4LL * i) ^= -a3 & (*(_DWORD *)(a2 + 4LL * i) ^ *(_DWORD *)(a1 + 4LL * i));
  }
  return result;
}

//----- (000000000004F003) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_getparity(__int64 *a1)
{
  __int64 v2[16]; // [rsp+10h] [rbp-80h] BYREF

  v2[0] = *a1;
  v2[1] = a1[1];
  v2[2] = a1[2];
  v2[3] = a1[3];
  v2[4] = a1[4];
  v2[5] = a1[5];
  v2[6] = a1[6];
  v2[7] = a1[7];
  v2[8] = a1[8];
  v2[9] = a1[9];
  v2[10] = a1[10];
  v2[11] = a1[11];
  v2[12] = a1[12];
  v2[13] = a1[13];
  v2[14] = a1[14];
  v2[15] = a1[15];
  crypto_sign_ed25519_ref_fe25519_freeze((__int64)v2);
  return v2[0] & 1;
}

//----- (000000000004F0AF) ----------------------------------------------------
_DWORD *__fastcall crypto_sign_ed25519_ref_fe25519_setone(_DWORD *a1)
{
  _DWORD *result; // rax
  int i; // [rsp+14h] [rbp-4h]

  result = a1;
  *a1 = 1;
  for ( i = 1; i <= 31; ++i )
  {
    result = a1;
    a1[i] = 0;
  }
  return result;
}

//----- (000000000004F0E8) ----------------------------------------------------
__int64 __fastcall crypto_sign_ed25519_ref_fe25519_setzero(__int64 a1)
{
  __int64 result; // rax
  int i; // [rsp+14h] [rbp-4h]

  for ( i = 0; i <= 31; ++i )
  {
    result = a1;
    *(_DWORD *)(a1 + 4LL * i) = 0;
  }
  return result;
}

//----- (000000000004F117) ----------------------------------------------------
void __fastcall crypto_sign_ed25519_ref_fe25519_neg(_DWORD *a1, __int64 a2)
{
  int i; // [rsp+1Ch] [rbp-84h]
  int v3[32]; // [rsp+20h] [rbp-80h] BYREF

  for ( i = 0; i <= 31; ++i )
    v3[i] = *(_DWORD *)(a2 + 4LL * i);
  crypto_sign_ed25519_ref_fe25519_setzero((__int64)a1);
  crypto_sign_ed25519_ref_fe25519_sub(a1, a1, (__int64)v3);
}
// 4F117: using guessed type int var_80[32];

//----- (000000000004F19A) ----------------------------------------------------
void __fastcall crypto_sign_ed25519_ref_fe25519_add(_DWORD *a1, __int64 a2, __int64 a3)
{
  int i; // [rsp+24h] [rbp-4h]

  for ( i = 0; i <= 31; ++i )
    a1[i] = *(_DWORD *)(a3 + 4LL * i) + *(_DWORD *)(a2 + 4LL * i);
  reduce_add_sub_0(a1);
}

//----- (000000000004F1F9) ----------------------------------------------------
void __fastcall crypto_sign_ed25519_ref_fe25519_sub(_DWORD *a1, _DWORD *a2, __int64 a3)
{
  int i; // [rsp+24h] [rbp-84h]
  int j; // [rsp+24h] [rbp-84h]
  int v5[32]; // [rsp+28h] [rbp-80h]

  v5[0] = *a2 + 474;
  v5[31] = a2[31] + 254;
  for ( i = 1; i <= 30; ++i )
    v5[i] = a2[i] + 510;
  for ( j = 0; j <= 31; ++j )
    a1[j] = v5[j] - *(_DWORD *)(a3 + 4LL * j);
  reduce_add_sub_0(a1);
}

//----- (000000000004F2DF) ----------------------------------------------------
void __fastcall crypto_sign_ed25519_ref_fe25519_mul(_DWORD *a1, __int64 a2, __int64 a3)
{
  int v3; // ebx
  int i; // [rsp+20h] [rbp-118h]
  int j; // [rsp+20h] [rbp-118h]
  int m; // [rsp+20h] [rbp-118h]
  int k; // [rsp+24h] [rbp-114h]
  int v8[68]; // [rsp+28h] [rbp-110h]

  for ( i = 0; i <= 62; ++i )
    v8[i] = 0;
  for ( j = 0; j <= 31; ++j )
  {
    for ( k = 0; k <= 31; ++k )
      v8[j + k] += *(_DWORD *)(a2 + 4LL * j) * *(_DWORD *)(a3 + 4LL * k);
  }
  for ( m = 32; m <= 62; ++m )
  {
    v3 = v8[m - 32];
    a1[m - 32] = v3 + times38(v8[m]);
  }
  a1[31] = v8[31];
  reduce_mul(a1);
}

//----- (000000000004F453) ----------------------------------------------------
void __fastcall crypto_sign_ed25519_ref_fe25519_square(_DWORD *a1, __int64 a2)
{
  crypto_sign_ed25519_ref_fe25519_mul(a1, a2, a2);
}

//----- (000000000004F47D) ----------------------------------------------------
void __fastcall crypto_sign_ed25519_ref_fe25519_invert(_DWORD *a1, __int64 a2)
{
  int i; // [rsp+1Ch] [rbp-504h]
  int j; // [rsp+1Ch] [rbp-504h]
  int k; // [rsp+1Ch] [rbp-504h]
  int m; // [rsp+1Ch] [rbp-504h]
  int n; // [rsp+1Ch] [rbp-504h]
  int ii; // [rsp+1Ch] [rbp-504h]
  _DWORD v8[32]; // [rsp+20h] [rbp-500h] BYREF
  _DWORD v9[32]; // [rsp+A0h] [rbp-480h] BYREF
  _DWORD v10[32]; // [rsp+120h] [rbp-400h] BYREF
  _DWORD v11[32]; // [rsp+1A0h] [rbp-380h] BYREF
  _DWORD v12[32]; // [rsp+220h] [rbp-300h] BYREF
  _DWORD v13[32]; // [rsp+2A0h] [rbp-280h] BYREF
  _DWORD v14[32]; // [rsp+320h] [rbp-200h] BYREF
  _DWORD v15[32]; // [rsp+3A0h] [rbp-180h] BYREF
  _DWORD v16[32]; // [rsp+420h] [rbp-100h] BYREF
  _DWORD v17[32]; // [rsp+4A0h] [rbp-80h] BYREF

  crypto_sign_ed25519_ref_fe25519_square(v8, a2);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v8);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_mul(v9, (__int64)v16, a2);
  crypto_sign_ed25519_ref_fe25519_mul(v10, (__int64)v9, (__int64)v8);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v10);
  crypto_sign_ed25519_ref_fe25519_mul(v11, (__int64)v16, (__int64)v9);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v11);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_mul(v12, (__int64)v16, (__int64)v11);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v12);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  for ( i = 2; i <= 9; i += 2 )
  {
    crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  }
  crypto_sign_ed25519_ref_fe25519_mul(v13, (__int64)v17, (__int64)v12);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v13);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  for ( j = 2; j <= 19; j += 2 )
  {
    crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  }
  crypto_sign_ed25519_ref_fe25519_mul(v16, (__int64)v17, (__int64)v13);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
  for ( k = 2; k <= 9; k += 2 )
  {
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
    crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
  }
  crypto_sign_ed25519_ref_fe25519_mul(v14, (__int64)v16, (__int64)v12);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v14);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  for ( m = 2; m <= 49; m += 2 )
  {
    crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  }
  crypto_sign_ed25519_ref_fe25519_mul(v15, (__int64)v17, (__int64)v14);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v15);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
  for ( n = 2; n <= 99; n += 2 )
  {
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
    crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
  }
  crypto_sign_ed25519_ref_fe25519_mul(v17, (__int64)v16, (__int64)v15);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  for ( ii = 2; ii <= 49; ii += 2 )
  {
    crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  }
  crypto_sign_ed25519_ref_fe25519_mul(v16, (__int64)v17, (__int64)v14);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  crypto_sign_ed25519_ref_fe25519_square(v16, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  crypto_sign_ed25519_ref_fe25519_mul(a1, (__int64)v17, (__int64)v10);
}
// 4F47D: using guessed type _DWORD var_500[32];
// 4F47D: using guessed type _DWORD var_80[32];
// 4F47D: using guessed type _DWORD var_100[32];
// 4F47D: using guessed type _DWORD var_480[32];
// 4F47D: using guessed type _DWORD var_400[32];
// 4F47D: using guessed type _DWORD var_380[32];
// 4F47D: using guessed type _DWORD var_300[32];
// 4F47D: using guessed type _DWORD var_280[32];
// 4F47D: using guessed type _DWORD var_200[32];
// 4F47D: using guessed type _DWORD var_180[32];

//----- (000000000004F9E5) ----------------------------------------------------
void __fastcall crypto_sign_ed25519_ref_fe25519_pow2523(_DWORD *a1, __int64 a2)
{
  int i; // [rsp+1Ch] [rbp-484h]
  int j; // [rsp+1Ch] [rbp-484h]
  int k; // [rsp+1Ch] [rbp-484h]
  int m; // [rsp+1Ch] [rbp-484h]
  int n; // [rsp+1Ch] [rbp-484h]
  int ii; // [rsp+1Ch] [rbp-484h]
  int jj; // [rsp+1Ch] [rbp-484h]
  _DWORD v9[32]; // [rsp+20h] [rbp-480h] BYREF
  _DWORD v10[32]; // [rsp+A0h] [rbp-400h] BYREF
  _DWORD v11[32]; // [rsp+120h] [rbp-380h] BYREF
  _DWORD v12[32]; // [rsp+1A0h] [rbp-300h] BYREF
  _DWORD v13[32]; // [rsp+220h] [rbp-280h] BYREF
  _DWORD v14[32]; // [rsp+2A0h] [rbp-200h] BYREF
  _DWORD v15[32]; // [rsp+320h] [rbp-180h] BYREF
  _DWORD v16[32]; // [rsp+3A0h] [rbp-100h] BYREF
  _DWORD v17[32]; // [rsp+420h] [rbp-80h] BYREF

  crypto_sign_ed25519_ref_fe25519_square(v9, a2);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v9);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_mul(v10, (__int64)v17, a2);
  crypto_sign_ed25519_ref_fe25519_mul(v11, (__int64)v10, (__int64)v9);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v11);
  crypto_sign_ed25519_ref_fe25519_mul(v12, (__int64)v17, (__int64)v10);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v12);
  for ( i = 1; i <= 4; ++i )
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_mul(v13, (__int64)v17, (__int64)v12);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v13);
  for ( j = 1; j <= 9; ++j )
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_mul(v14, (__int64)v17, (__int64)v13);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v14);
  for ( k = 1; k <= 19; ++k )
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_mul(v17, (__int64)v17, (__int64)v14);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v17);
  for ( m = 1; m <= 9; ++m )
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_mul(v15, (__int64)v17, (__int64)v13);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v15);
  for ( n = 1; n <= 49; ++n )
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_mul(v16, (__int64)v17, (__int64)v15);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v16);
  for ( ii = 1; ii <= 99; ++ii )
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_mul(v17, (__int64)v17, (__int64)v16);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v17);
  for ( jj = 1; jj <= 49; ++jj )
    crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_mul(v17, (__int64)v17, (__int64)v15);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_square(v17, (__int64)v17);
  crypto_sign_ed25519_ref_fe25519_mul(a1, (__int64)v17, a2);
}
// 4F9E5: using guessed type _DWORD var_480[32];
// 4F9E5: using guessed type _DWORD var_80[32];
// 4F9E5: using guessed type _DWORD var_400[32];
// 4F9E5: using guessed type _DWORD var_380[32];
// 4F9E5: using guessed type _DWORD var_300[32];
// 4F9E5: using guessed type _DWORD var_280[32];
// 4F9E5: using guessed type _DWORD var_200[32];
// 4F9E5: using guessed type _DWORD var_180[32];
// 4F9E5: using guessed type _DWORD var_100[32];

//----- (000000000004FD95) ----------------------------------------------------
__int64 __fastcall chacha20_set_encrypt_key(__int64 a1, unsigned __int16 *a2)
{
  int *v3; // [rsp+20h] [rbp-10h]

  if ( *(_QWORD *)(a1 + 40) )
  {
    v3 = *(int **)(a1 + 40);
  }
  else
  {
    v3 = (int *)malloc(0x80uLL);
    if ( !v3 )
      return 0xFFFFFFFFLL;
  }
  chacha_keysetup(v3 + 16, a2, 256);
  chacha_keysetup(v3, a2 + 16, 256);
  *(_QWORD *)(a1 + 40) = v3;
  return 0LL;
}

//----- (000000000004FE31) ----------------------------------------------------
unsigned __int64 __fastcall chacha20_poly1305_aead_encrypt(
        __int64 a1,
        char *a2,
        char *a3,
        unsigned __int64 a4,
        _DWORD *a5,
        __int64 a6)
{
  unsigned __int64 v6; // rbx
  uint32_t hostlong[2]; // [rsp+0h] [rbp-90h] BYREF
  _DWORD *v9; // [rsp+8h] [rbp-88h]
  unsigned __int64 v10; // [rsp+10h] [rbp-80h]
  char *v11; // [rsp+18h] [rbp-78h]
  char *v12; // [rsp+20h] [rbp-70h]
  __int64 v13; // [rsp+28h] [rbp-68h]
  char *v14; // [rsp+38h] [rbp-58h]
  char *v15; // [rsp+40h] [rbp-50h]
  int *v16; // [rsp+48h] [rbp-48h]
  __int64 v17[5]; // [rsp+50h] [rbp-40h] BYREF
  unsigned __int64 v18; // [rsp+78h] [rbp-18h]

  v13 = a1;
  v12 = a2;
  v11 = a3;
  v10 = a4;
  v9 = a5;
  *(_QWORD *)hostlong = a6;
  v18 = __readfsqword(0x28u);
  v14 = a2;
  v15 = a3;
  memset(v17, 0, 32);
  v16 = *(int **)(a1 + 40);
  v6 = (unsigned __int64)htonl(a6) << 32;
  *(_QWORD *)hostlong = v6 | htonl(hostlong[1]);
  chacha_ivsetup(v16 + 16, (unsigned __int16 *)hostlong, zero_block_counter);
  chacha_encrypt_bytes(v16 + 16, (char *)v17, (char *)v17, 0x20u);
  chacha_ivsetup(v16, (unsigned __int16 *)hostlong, zero_block_counter);
  chacha_encrypt_bytes(v16, v14, v15, 4u);
  chacha_ivsetup(v16 + 16, (unsigned __int16 *)hostlong, payload_block_counter);
  chacha_encrypt_bytes(v16 + 16, v14 + 4, v15 + 4, v10 - 4);
  poly1305_auth(v9, (__int64)v15, v10, (unsigned __int16 *)v17);
  return __readfsqword(0x28u) ^ v18;
}
// 76C10: using guessed type unsigned __int16 zero_block_counter[4];
// 76C18: using guessed type unsigned __int16 payload_block_counter[4];

//----- (000000000004FFD1) ----------------------------------------------------
__int64 __fastcall chacha20_poly1305_aead_decrypt_length(
        __int64 a1,
        char *a2,
        char *a3,
        unsigned __int64 a4,
        __int64 a5)
{
  unsigned __int64 v6; // rbx
  uint32_t hostlong[2]; // [rsp+8h] [rbp-48h] BYREF
  unsigned __int64 v8; // [rsp+10h] [rbp-40h]
  char *v9; // [rsp+18h] [rbp-38h]
  char *v10; // [rsp+20h] [rbp-30h]
  __int64 v11; // [rsp+28h] [rbp-28h]
  int *v12; // [rsp+38h] [rbp-18h]

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v8 = a4;
  *(_QWORD *)hostlong = a5;
  v12 = *(int **)(a1 + 40);
  if ( a4 <= 3 )
    return 0xFFFFFFFFLL;
  v6 = (unsigned __int64)htonl(hostlong[0]) << 32;
  *(_QWORD *)hostlong = v6 | htonl(hostlong[1]);
  chacha_ivsetup(v12, (unsigned __int16 *)hostlong, zero_block_counter);
  chacha_encrypt_bytes(v12, v10, v9, 4u);
  return 0LL;
}
// 76C10: using guessed type unsigned __int16 zero_block_counter[4];

//----- (0000000000050073) ----------------------------------------------------
__int64 __fastcall chacha20_poly1305_aead_decrypt(__int64 a1, __int64 a2, char *a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // rbx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  uint32_t hostlong[2]; // [rsp+8h] [rbp-98h] BYREF
  __int64 v11; // [rsp+10h] [rbp-90h]
  char *v12; // [rsp+18h] [rbp-88h]
  __int64 v13; // [rsp+20h] [rbp-80h]
  __int64 v14; // [rsp+28h] [rbp-78h]
  __int64 v16; // [rsp+40h] [rbp-60h]
  void *s2; // [rsp+48h] [rbp-58h]
  __int64 s1[2]; // [rsp+50h] [rbp-50h] BYREF
  __int64 s[8]; // [rsp+60h] [rbp-40h] BYREF

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11 = a4;
  *(_QWORD *)hostlong = a5;
  s[5] = __readfsqword(0x28u);
  memset(s, 0, 32);
  s1[0] = 0LL;
  s1[1] = 0LL;
  v16 = *(_QWORD *)(a1 + 40);
  s2 = (void *)(a4 + 4 + a2);
  v5 = (unsigned __int64)htonl(a5) << 32;
  *(_QWORD *)hostlong = v5 | htonl(hostlong[1]);
  memset(s, 0, 0x20uLL);
  chacha_ivsetup((_DWORD *)(v16 + 64), (unsigned __int16 *)hostlong, zero_block_counter);
  chacha_encrypt_bytes((int *)(v16 + 64), (char *)s, (char *)s, 0x20u);
  poly1305_auth(s1, v13, v11 + 4, (unsigned __int16 *)s);
  if ( memcmp(s1, s2, 0x10uLL) )
  {
    ssh_log(3, "chacha20_poly1305_aead_decrypt", "poly1305 verify error", v6, v7, v8);
    return 0xFFFFFFFFLL;
  }
  else
  {
    chacha_ivsetup((_DWORD *)(v16 + 64), (unsigned __int16 *)hostlong, payload_block_counter);
    chacha_encrypt_bytes((int *)(v16 + 64), (char *)(v13 + 4), v12, v11);
    return 0LL;
  }
}
// 501E4: variable 'v6' is possibly undefined
// 501E4: variable 'v7' is possibly undefined
// 501E4: variable 'v8' is possibly undefined
// 76C10: using guessed type unsigned __int16 zero_block_counter[4];
// 76C18: using guessed type unsigned __int16 payload_block_counter[4];

//----- (000000000005025E) ----------------------------------------------------
__int64 __fastcall chacha20_cleanup(__int64 a1)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 40);
  if ( result )
  {
    free(*(void **)(a1 + 40));
    result = a1;
    *(_QWORD *)(a1 + 40) = 0LL;
  }
  return result;
}

//----- (0000000000050296) ----------------------------------------------------
char **ssh_get_chacha20poly1305_cipher()
{
  return &chacha20poly1305_cipher;
}
// 27FCC0: using guessed type char *chacha20poly1305_cipher;

//----- (00000000000502A3) ----------------------------------------------------
int *__fastcall chacha_keysetup(int *a1, unsigned __int16 *a2, int a3)
{
  int *result; // rax
  unsigned __int16 *v4; // [rsp+4h] [rbp-20h]
  char *v5; // [rsp+1Ch] [rbp-8h]

  v4 = a2;
  a1[4] = (*((unsigned __int8 *)a2 + 3) << 24) | (*((unsigned __int8 *)a2 + 2) << 16) | *a2;
  a1[5] = (*((unsigned __int8 *)a2 + 7) << 24) | (*((unsigned __int8 *)a2 + 6) << 16) | a2[2];
  a1[6] = (*((unsigned __int8 *)a2 + 11) << 24) | (*((unsigned __int8 *)a2 + 10) << 16) | a2[4];
  a1[7] = (*((unsigned __int8 *)a2 + 15) << 24) | (*((unsigned __int8 *)a2 + 14) << 16) | a2[6];
  if ( a3 == 256 )
  {
    v4 = a2 + 8;
    v5 = (char *)&sigma;
  }
  else
  {
    v5 = (char *)&tau;
  }
  a1[8] = (*((unsigned __int8 *)v4 + 3) << 24) | (*((unsigned __int8 *)v4 + 2) << 16) | *v4;
  a1[9] = (*((unsigned __int8 *)v4 + 7) << 24) | (*((unsigned __int8 *)v4 + 6) << 16) | v4[2];
  a1[10] = (*((unsigned __int8 *)v4 + 11) << 24) | (*((unsigned __int8 *)v4 + 10) << 16) | v4[4];
  a1[11] = (*((unsigned __int8 *)v4 + 15) << 24) | (*((unsigned __int8 *)v4 + 14) << 16) | v4[6];
  *a1 = (v5[3] << 24) | (v5[2] << 16) | *v5 | (v5[1] << 8);
  a1[1] = (v5[7] << 24) | (v5[6] << 16) | v5[4] | (v5[5] << 8);
  a1[2] = (v5[11] << 24) | (v5[10] << 16) | v5[8] | (v5[9] << 8);
  result = a1;
  a1[3] = (v5[15] << 24) | (v5[14] << 16) | v5[12] | (v5[13] << 8);
  return result;
}

//----- (0000000000050676) ----------------------------------------------------
_DWORD *__fastcall chacha_ivsetup(_DWORD *a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  int v3; // edx
  int v4; // edx
  _DWORD *result; // rax

  if ( a3 )
    v3 = (*((unsigned __int8 *)a3 + 3) << 24) | (*((unsigned __int8 *)a3 + 2) << 16) | *a3;
  else
    v3 = 0;
  a1[12] = v3;
  if ( a3 )
    v4 = (*((unsigned __int8 *)a3 + 7) << 24) | (*((unsigned __int8 *)a3 + 6) << 16) | a3[2];
  else
    v4 = 0;
  a1[13] = v4;
  a1[14] = (*((unsigned __int8 *)a2 + 3) << 24) | (*((unsigned __int8 *)a2 + 2) << 16) | *a2;
  result = a1;
  a1[15] = (*((unsigned __int8 *)a2 + 7) << 24) | (*((unsigned __int8 *)a2 + 6) << 16) | a2[2];
  return result;
}

//----- (00000000000507D5) ----------------------------------------------------
unsigned __int64 __fastcall chacha_encrypt_bytes(int *a1, char *a2, char *a3, unsigned int a4)
{
  unsigned int v5; // [rsp+4h] [rbp-FCh]
  int v8; // [rsp+24h] [rbp-DCh]
  int v9; // [rsp+24h] [rbp-DCh]
  int v10; // [rsp+24h] [rbp-DCh]
  int v11; // [rsp+24h] [rbp-DCh]
  int v12; // [rsp+24h] [rbp-DCh]
  int v13; // [rsp+28h] [rbp-D8h]
  int v14; // [rsp+28h] [rbp-D8h]
  int v15; // [rsp+28h] [rbp-D8h]
  int v16; // [rsp+28h] [rbp-D8h]
  int v17; // [rsp+28h] [rbp-D8h]
  int v18; // [rsp+2Ch] [rbp-D4h]
  int v19; // [rsp+2Ch] [rbp-D4h]
  int v20; // [rsp+2Ch] [rbp-D4h]
  int v21; // [rsp+2Ch] [rbp-D4h]
  int v22; // [rsp+2Ch] [rbp-D4h]
  int v23; // [rsp+30h] [rbp-D0h]
  int v24; // [rsp+30h] [rbp-D0h]
  int v25; // [rsp+30h] [rbp-D0h]
  int v26; // [rsp+30h] [rbp-D0h]
  int v27; // [rsp+30h] [rbp-D0h]
  int v28; // [rsp+34h] [rbp-CCh]
  int v29; // [rsp+34h] [rbp-CCh]
  int v30; // [rsp+34h] [rbp-CCh]
  int v31; // [rsp+34h] [rbp-CCh]
  int v32; // [rsp+34h] [rbp-CCh]
  int v33; // [rsp+38h] [rbp-C8h]
  int v34; // [rsp+38h] [rbp-C8h]
  int v35; // [rsp+38h] [rbp-C8h]
  int v36; // [rsp+38h] [rbp-C8h]
  int v37; // [rsp+38h] [rbp-C8h]
  int v38; // [rsp+3Ch] [rbp-C4h]
  int v39; // [rsp+3Ch] [rbp-C4h]
  int v40; // [rsp+3Ch] [rbp-C4h]
  int v41; // [rsp+3Ch] [rbp-C4h]
  int v42; // [rsp+3Ch] [rbp-C4h]
  int v43; // [rsp+40h] [rbp-C0h]
  int v44; // [rsp+40h] [rbp-C0h]
  int v45; // [rsp+40h] [rbp-C0h]
  int v46; // [rsp+40h] [rbp-C0h]
  int v47; // [rsp+40h] [rbp-C0h]
  int v48; // [rsp+44h] [rbp-BCh]
  int v49; // [rsp+44h] [rbp-BCh]
  int v50; // [rsp+44h] [rbp-BCh]
  int v51; // [rsp+44h] [rbp-BCh]
  int v52; // [rsp+44h] [rbp-BCh]
  int v53; // [rsp+48h] [rbp-B8h]
  int v54; // [rsp+48h] [rbp-B8h]
  int v55; // [rsp+48h] [rbp-B8h]
  int v56; // [rsp+48h] [rbp-B8h]
  int v57; // [rsp+48h] [rbp-B8h]
  int v58; // [rsp+4Ch] [rbp-B4h]
  int v59; // [rsp+4Ch] [rbp-B4h]
  int v60; // [rsp+4Ch] [rbp-B4h]
  int v61; // [rsp+4Ch] [rbp-B4h]
  int v62; // [rsp+4Ch] [rbp-B4h]
  int v63; // [rsp+50h] [rbp-B0h]
  int v64; // [rsp+50h] [rbp-B0h]
  int v65; // [rsp+50h] [rbp-B0h]
  int v66; // [rsp+50h] [rbp-B0h]
  int v67; // [rsp+50h] [rbp-B0h]
  int v68; // [rsp+54h] [rbp-ACh]
  int v69; // [rsp+54h] [rbp-ACh]
  int v70; // [rsp+54h] [rbp-ACh]
  int v71; // [rsp+54h] [rbp-ACh]
  int v72; // [rsp+54h] [rbp-ACh]
  int v73; // [rsp+58h] [rbp-A8h]
  int v74; // [rsp+58h] [rbp-A8h]
  int v75; // [rsp+58h] [rbp-A8h]
  int v76; // [rsp+58h] [rbp-A8h]
  int v77; // [rsp+58h] [rbp-A8h]
  int v78; // [rsp+5Ch] [rbp-A4h]
  int v79; // [rsp+5Ch] [rbp-A4h]
  int v80; // [rsp+5Ch] [rbp-A4h]
  int v81; // [rsp+5Ch] [rbp-A4h]
  int v82; // [rsp+5Ch] [rbp-A4h]
  int v83; // [rsp+60h] [rbp-A0h]
  int v84; // [rsp+60h] [rbp-A0h]
  int v85; // [rsp+60h] [rbp-A0h]
  int v86; // [rsp+60h] [rbp-A0h]
  int v87; // [rsp+60h] [rbp-A0h]
  int v88; // [rsp+64h] [rbp-9Ch]
  int v89; // [rsp+68h] [rbp-98h]
  unsigned int i; // [rsp+6Ch] [rbp-94h]
  int j; // [rsp+6Ch] [rbp-94h]
  unsigned int k; // [rsp+6Ch] [rbp-94h]
  int v93; // [rsp+70h] [rbp-90h]
  int v94; // [rsp+74h] [rbp-8Ch]
  int v95; // [rsp+78h] [rbp-88h]
  int v96; // [rsp+7Ch] [rbp-84h]
  int v97; // [rsp+80h] [rbp-80h]
  int v98; // [rsp+84h] [rbp-7Ch]
  int v99; // [rsp+88h] [rbp-78h]
  int v100; // [rsp+8Ch] [rbp-74h]
  int v101; // [rsp+90h] [rbp-70h]
  int v102; // [rsp+94h] [rbp-6Ch]
  int v103; // [rsp+98h] [rbp-68h]
  int v104; // [rsp+9Ch] [rbp-64h]
  int v105; // [rsp+A0h] [rbp-60h]
  int v106; // [rsp+A4h] [rbp-5Ch]
  char *v107; // [rsp+A8h] [rbp-58h]
  char v108[72]; // [rsp+B0h] [rbp-50h] BYREF
  unsigned __int64 v109; // [rsp+F8h] [rbp-8h]

  v5 = a4;
  v109 = __readfsqword(0x28u);
  v107 = 0LL;
  if ( a4 )
  {
    v93 = *a1;
    v94 = a1[1];
    v95 = a1[2];
    v96 = a1[3];
    v97 = a1[4];
    v98 = a1[5];
    v99 = a1[6];
    v100 = a1[7];
    v101 = a1[8];
    v102 = a1[9];
    v103 = a1[10];
    v104 = a1[11];
    v88 = a1[12];
    v89 = a1[13];
    v105 = a1[14];
    v106 = a1[15];
    while ( 1 )
    {
      if ( v5 <= 0x3F )
      {
        for ( i = 0; i < v5; ++i )
          v108[i] = a2[i];
        a2 = v108;
        v107 = a3;
        a3 = v108;
      }
      v8 = v93;
      v13 = v94;
      v18 = v95;
      v23 = v96;
      v28 = v97;
      v33 = v98;
      v38 = v99;
      v43 = v100;
      v48 = v101;
      v53 = v102;
      v58 = v103;
      v63 = v104;
      v68 = v88;
      v73 = v89;
      v78 = v105;
      v83 = v106;
      for ( j = 20; j; j -= 2 )
      {
        v9 = v28 + v8;
        v69 = __ROL4__(v9 ^ v68, 16);
        v49 = v69 + v48;
        v29 = __ROL4__(v49 ^ v28, 12);
        v10 = v29 + v9;
        v70 = __ROL4__(v10 ^ v69, 8);
        v50 = v70 + v49;
        v30 = __ROL4__(v50 ^ v29, 7);
        v14 = v33 + v13;
        v74 = __ROL4__(v14 ^ v73, 16);
        v54 = v74 + v53;
        v34 = __ROL4__(v54 ^ v33, 12);
        v15 = v34 + v14;
        v75 = __ROL4__(v15 ^ v74, 8);
        v55 = v75 + v54;
        v35 = __ROL4__(v55 ^ v34, 7);
        v19 = v38 + v18;
        v79 = __ROL4__(v19 ^ v78, 16);
        v59 = v79 + v58;
        v39 = __ROL4__(v59 ^ v38, 12);
        v20 = v39 + v19;
        v80 = __ROL4__(v20 ^ v79, 8);
        v60 = v80 + v59;
        v40 = __ROL4__(v60 ^ v39, 7);
        v24 = v43 + v23;
        v84 = __ROL4__(v24 ^ v83, 16);
        v64 = v84 + v63;
        v44 = __ROL4__(v64 ^ v43, 12);
        v25 = v44 + v24;
        v85 = __ROL4__(v25 ^ v84, 8);
        v65 = v85 + v64;
        v45 = __ROL4__(v65 ^ v44, 7);
        v11 = v35 + v10;
        v86 = __ROL4__(v11 ^ v85, 16);
        v61 = v86 + v60;
        v36 = __ROL4__(v61 ^ v35, 12);
        v8 = v36 + v11;
        v83 = __ROL4__(v8 ^ v86, 8);
        v58 = v83 + v61;
        v33 = __ROL4__(v58 ^ v36, 7);
        v16 = v40 + v15;
        v71 = __ROL4__(v16 ^ v70, 16);
        v66 = v71 + v65;
        v41 = __ROL4__(v66 ^ v40, 12);
        v13 = v41 + v16;
        v68 = __ROL4__(v13 ^ v71, 8);
        v63 = v68 + v66;
        v38 = __ROL4__(v63 ^ v41, 7);
        v21 = v45 + v20;
        v76 = __ROL4__(v21 ^ v75, 16);
        v51 = v76 + v50;
        v46 = __ROL4__(v51 ^ v45, 12);
        v18 = v46 + v21;
        v73 = __ROL4__(v18 ^ v76, 8);
        v48 = v73 + v51;
        v43 = __ROL4__(v48 ^ v46, 7);
        v26 = v30 + v25;
        v81 = __ROL4__(v26 ^ v80, 16);
        v56 = v81 + v55;
        v31 = __ROL4__(v56 ^ v30, 12);
        v23 = v31 + v26;
        v78 = __ROL4__(v23 ^ v81, 8);
        v53 = v78 + v56;
        v28 = __ROL4__(v53 ^ v31, 7);
      }
      v12 = (((unsigned __int8)a2[2] << 16) | *(unsigned __int16 *)a2 | ((unsigned __int8)a2[3] << 24)) ^ (v93 + v8);
      v17 = (((unsigned __int8)a2[6] << 16) | *((unsigned __int16 *)a2 + 2) | ((unsigned __int8)a2[7] << 24)) ^ (v94 + v13);
      v22 = (((unsigned __int8)a2[10] << 16) | *((unsigned __int16 *)a2 + 4) | ((unsigned __int8)a2[11] << 24)) ^ (v95 + v18);
      v27 = (((unsigned __int8)a2[14] << 16) | *((unsigned __int16 *)a2 + 6) | ((unsigned __int8)a2[15] << 24)) ^ (v96 + v23);
      v32 = (((unsigned __int8)a2[18] << 16) | *((unsigned __int16 *)a2 + 8) | ((unsigned __int8)a2[19] << 24)) ^ (v97 + v28);
      v37 = (((unsigned __int8)a2[22] << 16) | *((unsigned __int16 *)a2 + 10) | ((unsigned __int8)a2[23] << 24)) ^ (v98 + v33);
      v42 = (((unsigned __int8)a2[26] << 16) | *((unsigned __int16 *)a2 + 12) | ((unsigned __int8)a2[27] << 24)) ^ (v99 + v38);
      v47 = (((unsigned __int8)a2[30] << 16) | *((unsigned __int16 *)a2 + 14) | ((unsigned __int8)a2[31] << 24)) ^ (v100 + v43);
      v52 = (((unsigned __int8)a2[34] << 16) | *((unsigned __int16 *)a2 + 16) | ((unsigned __int8)a2[35] << 24)) ^ (v101 + v48);
      v57 = (((unsigned __int8)a2[38] << 16) | *((unsigned __int16 *)a2 + 18) | ((unsigned __int8)a2[39] << 24)) ^ (v102 + v53);
      v62 = (((unsigned __int8)a2[42] << 16) | *((unsigned __int16 *)a2 + 20) | ((unsigned __int8)a2[43] << 24)) ^ (v103 + v58);
      v67 = (((unsigned __int8)a2[46] << 16) | *((unsigned __int16 *)a2 + 22) | ((unsigned __int8)a2[47] << 24)) ^ (v104 + v63);
      v72 = (((unsigned __int8)a2[50] << 16) | *((unsigned __int16 *)a2 + 24) | ((unsigned __int8)a2[51] << 24)) ^ (v88 + v68);
      v77 = (((unsigned __int8)a2[54] << 16) | *((unsigned __int16 *)a2 + 26) | ((unsigned __int8)a2[55] << 24)) ^ (v89 + v73);
      v82 = (((unsigned __int8)a2[58] << 16) | *((unsigned __int16 *)a2 + 28) | ((unsigned __int8)a2[59] << 24)) ^ (v105 + v78);
      v87 = (((unsigned __int8)a2[62] << 16) | *((unsigned __int16 *)a2 + 30) | ((unsigned __int8)a2[63] << 24)) ^ (v106 + v83);
      if ( !++v88 )
        ++v89;
      *(_DWORD *)a3 = v12;
      *((_DWORD *)a3 + 1) = v17;
      *((_DWORD *)a3 + 2) = v22;
      *((_DWORD *)a3 + 3) = v27;
      *((_DWORD *)a3 + 4) = v32;
      *((_DWORD *)a3 + 5) = v37;
      *((_DWORD *)a3 + 6) = v42;
      *((_DWORD *)a3 + 7) = v47;
      *((_DWORD *)a3 + 8) = v52;
      *((_DWORD *)a3 + 9) = v57;
      *((_DWORD *)a3 + 10) = v62;
      *((_DWORD *)a3 + 11) = v67;
      *((_DWORD *)a3 + 12) = v72;
      *((_DWORD *)a3 + 13) = v77;
      *((_DWORD *)a3 + 14) = v82;
      *((_DWORD *)a3 + 15) = v87;
      if ( v5 <= 0x40 )
        break;
      v5 -= 64;
      a3 += 64;
      a2 += 64;
    }
    if ( v5 <= 0x3F )
    {
      for ( k = 0; k < v5; ++k )
        v107[k] = a3[k];
    }
    a1[12] = v88;
    a1[13] = v89;
  }
  return __readfsqword(0x28u) ^ v109;
}
// 507D5: using guessed type char var_50[72];

//----- (0000000000051A8A) ----------------------------------------------------
unsigned __int64 __fastcall poly1305_auth(_DWORD *a1, __int64 a2, unsigned __int64 a3, unsigned __int16 *a4)
{
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rax
  unsigned __int64 v8; // [rsp+8h] [rbp-108h]
  unsigned int v10; // [rsp+2Ch] [rbp-E4h]
  unsigned int v11; // [rsp+2Ch] [rbp-E4h]
  int v12; // [rsp+2Ch] [rbp-E4h]
  unsigned int v13; // [rsp+2Ch] [rbp-E4h]
  int v14; // [rsp+30h] [rbp-E0h]
  unsigned int v15; // [rsp+30h] [rbp-E0h]
  unsigned int v16; // [rsp+30h] [rbp-E0h]
  unsigned int v17; // [rsp+30h] [rbp-E0h]
  unsigned int v18; // [rsp+30h] [rbp-E0h]
  int v19; // [rsp+34h] [rbp-DCh]
  unsigned int v20; // [rsp+34h] [rbp-DCh]
  unsigned int v21; // [rsp+34h] [rbp-DCh]
  unsigned int v22; // [rsp+34h] [rbp-DCh]
  int v23; // [rsp+38h] [rbp-D8h]
  unsigned int v24; // [rsp+38h] [rbp-D8h]
  unsigned int v25; // [rsp+38h] [rbp-D8h]
  unsigned int v26; // [rsp+38h] [rbp-D8h]
  int v27; // [rsp+3Ch] [rbp-D4h]
  unsigned int i; // [rsp+3Ch] [rbp-D4h]
  unsigned int v29; // [rsp+3Ch] [rbp-D4h]
  __int128 v30; // [rsp+40h] [rbp-D0h]
  __int128 v31; // [rsp+40h] [rbp-D0h]
  unsigned int v32; // [rsp+50h] [rbp-C0h]
  unsigned int v33; // [rsp+54h] [rbp-BCh]
  unsigned int v34; // [rsp+58h] [rbp-B8h]
  unsigned int v35; // [rsp+5Ch] [rbp-B4h]
  unsigned int v36; // [rsp+60h] [rbp-B0h]
  unsigned int v37; // [rsp+64h] [rbp-ACh]
  unsigned int v38; // [rsp+68h] [rbp-A8h]
  unsigned int v39; // [rsp+6Ch] [rbp-A4h]
  unsigned int v40; // [rsp+70h] [rbp-A0h]
  unsigned int v41; // [rsp+74h] [rbp-9Ch]
  unsigned int v42; // [rsp+74h] [rbp-9Ch]
  unsigned int v43; // [rsp+74h] [rbp-9Ch]
  unsigned int v44; // [rsp+74h] [rbp-9Ch]
  int v45; // [rsp+74h] [rbp-9Ch]
  unsigned int v46; // [rsp+80h] [rbp-90h]
  unsigned int v47; // [rsp+84h] [rbp-8Ch]
  unsigned int v48; // [rsp+88h] [rbp-88h]
  unsigned __int64 j; // [rsp+90h] [rbp-80h]
  unsigned __int64 v50; // [rsp+90h] [rbp-80h]
  unsigned __int64 v51; // [rsp+A0h] [rbp-70h]
  unsigned __int64 v52; // [rsp+A8h] [rbp-68h]
  unsigned __int64 v53; // [rsp+A8h] [rbp-68h]
  unsigned __int64 v54; // [rsp+B0h] [rbp-60h]
  unsigned __int64 v55; // [rsp+B0h] [rbp-60h]
  int v56; // [rsp+B8h] [rbp-58h]
  unsigned __int64 v57; // [rsp+C0h] [rbp-50h]
  unsigned __int64 v58; // [rsp+C8h] [rbp-48h]
  unsigned __int64 v59; // [rsp+C8h] [rbp-48h]
  unsigned __int64 v60; // [rsp+D0h] [rbp-40h]
  unsigned __int64 v61; // [rsp+D0h] [rbp-40h]
  unsigned __int64 v62; // [rsp+D8h] [rbp-38h]
  unsigned __int64 v63; // [rsp+D8h] [rbp-38h]
  unsigned __int64 v64; // [rsp+E0h] [rbp-30h]
  unsigned __int16 v65; // [rsp+F0h] [rbp-20h]
  unsigned __int8 v66; // [rsp+F2h] [rbp-1Eh]
  unsigned __int8 v67; // [rsp+F3h] [rbp-1Dh]
  unsigned __int16 v68; // [rsp+F4h] [rbp-1Ch]
  unsigned __int8 v69; // [rsp+F6h] [rbp-1Ah]
  unsigned __int8 v70; // [rsp+F7h] [rbp-19h]
  unsigned __int16 v71; // [rsp+F8h] [rbp-18h]
  unsigned __int8 v72; // [rsp+FAh] [rbp-16h]
  unsigned __int8 v73; // [rsp+FBh] [rbp-15h]
  unsigned __int16 v74; // [rsp+FCh] [rbp-14h]
  unsigned __int8 v75; // [rsp+FEh] [rbp-12h]
  unsigned __int8 v76; // [rsp+FFh] [rbp-11h]
  unsigned __int64 v77; // [rsp+108h] [rbp-8h]

  v8 = a3;
  v77 = __readfsqword(0x28u);
  LODWORD(v30) = (*((unsigned __int8 *)a4 + 2) << 16) | *a4 | (*((unsigned __int8 *)a4 + 3) << 24);
  DWORD1(v30) = (*((unsigned __int8 *)a4 + 6) << 16) | a4[2] | (*((unsigned __int8 *)a4 + 7) << 24);
  DWORD2(v30) = (*((unsigned __int8 *)a4 + 10) << 16) | a4[4] | (*((unsigned __int8 *)a4 + 11) << 24);
  HIDWORD(v30) = (*((unsigned __int8 *)a4 + 14) << 16) | a4[6] | (*((unsigned __int8 *)a4 + 15) << 24);
  v32 = v30 & 0x3FFFFFF;
  v33 = ((__int64)v30 >> 26) & 0x3FFFF03;
  v34 = (*(__int64 *)((char *)&v30 + 4) >> 20) & 0x3FFC0FF;
  v35 = (*((__int64 *)&v30 + 1) >> 14) & 0x3F03FFF;
  v36 = (HIDWORD(v30) >> 8) & 0xFFFFF;
  v37 = 5 * v33;
  v38 = 5 * v34;
  v39 = 5 * v35;
  v40 = 5 * v36;
  v10 = 0;
  v14 = 0;
  v19 = 0;
  v23 = 0;
  v27 = 0;
  if ( a3 <= 0xF )
    goto LABEL_4;
LABEL_2:
  a2 += 16LL;
  v8 -= 16LL;
  LODWORD(v31) = (*(unsigned __int8 *)(a2 - 14) << 16) | *(unsigned __int16 *)(a2 - 16) | (*(unsigned __int8 *)(a2 - 13) << 24);
  DWORD1(v31) = (*(unsigned __int8 *)(a2 - 10) << 16) | *(unsigned __int16 *)(a2 - 12) | (*(unsigned __int8 *)(a2 - 9) << 24);
  DWORD2(v31) = (*(unsigned __int8 *)(a2 - 6) << 16) | *(unsigned __int16 *)(a2 - 8) | (*(unsigned __int8 *)(a2 - 5) << 24);
  HIDWORD(v31) = (*(unsigned __int8 *)(a2 - 2) << 16) | *(unsigned __int16 *)(a2 - 4) | (*(unsigned __int8 *)(a2 - 1) << 24);
  v11 = (v31 & 0x3FFFFFF) + v10;
  v15 = (((unsigned __int64)v31 >> 26) & 0x3FFFFFF) + v14;
  v20 = ((*(_QWORD *)((char *)&v31 + 4) >> 20) & 0x3FFFFFF) + v19;
  v24 = ((*((_QWORD *)&v31 + 1) >> 14) & 0x3FFFFFF) + v23;
  for ( i = ((HIDWORD(v31) >> 8) | 0x1000000) + v27; ; i = ((unsigned int)((v75 << 16) | v74 | (v76 << 24)) >> 8) + v27 )
  {
    v57 = v32 * (unsigned __int64)v11
        + v15 * (unsigned __int64)v40
        + v38 * (unsigned __int64)v24
        + v20 * (unsigned __int64)v39
        + i * (unsigned __int64)v37;
    v58 = v33 * (unsigned __int64)v11
        + v15 * (unsigned __int64)v32
        + v39 * (unsigned __int64)v24
        + v20 * (unsigned __int64)v40
        + i * (unsigned __int64)v38;
    v60 = v34 * (unsigned __int64)v11
        + v15 * (unsigned __int64)v33
        + v40 * (unsigned __int64)v24
        + v20 * (unsigned __int64)v32
        + i * (unsigned __int64)v39;
    v62 = v35 * (unsigned __int64)v11
        + v15 * (unsigned __int64)v34
        + v32 * (unsigned __int64)v24
        + v20 * (unsigned __int64)v33
        + i * (unsigned __int64)v40;
    v4 = v36 * (unsigned __int64)v11
       + v15 * (unsigned __int64)v35
       + v33 * (unsigned __int64)v24
       + v20 * (unsigned __int64)v34;
    v12 = (v32 * v11 + v15 * v40 + v38 * v24 + v20 * v39 + i * v37) & 0x3FFFFFF;
    v59 = v58 + (v57 >> 26);
    v14 = v59 & 0x3FFFFFF;
    v61 = v60 + (unsigned int)(v59 >> 26);
    v19 = v61 & 0x3FFFFFF;
    v63 = v62 + (unsigned int)(v61 >> 26);
    v23 = v63 & 0x3FFFFFF;
    v64 = v4 + i * (unsigned __int64)v32 + (unsigned int)(v63 >> 26);
    v27 = (v4 + i * v32 + (v63 >> 26)) & 0x3FFFFFF;
    v10 = 5 * (v64 >> 26) + v12;
    if ( v8 > 0xF )
      goto LABEL_2;
LABEL_4:
    if ( !v8 )
      break;
    for ( j = 0LL; j < v8; ++j )
      *((_BYTE *)&v65 + j) = *(_BYTE *)(a2 + j);
    v5 = j;
    v50 = j + 1;
    *((_BYTE *)&v65 + v5) = 1;
    while ( v50 <= 0xF )
      *((_BYTE *)&v65 + v50++) = 0;
    v8 = 0LL;
    v11 = (((v66 << 16) | v65 | (v67 << 24)) & 0x3FFFFFF) + v10;
    v15 = (((((unsigned __int64)((v69 << 16) | v68 | (v70 << 24)) << 32) | (v66 << 16) | v65 | (v67 << 24)) >> 26) & 0x3FFFFFF)
        + v14;
    v20 = (((((unsigned __int64)((v72 << 16) | v71 | (v73 << 24)) << 32) | (v69 << 16) | v68 | (v70 << 24)) >> 20) & 0x3FFFFFF)
        + v19;
    v24 = (((((unsigned __int64)((v75 << 16) | v74 | (v76 << 24)) << 32) | (v72 << 16) | v71 | (v73 << 24)) >> 14) & 0x3FFFFFF)
        + v23;
  }
  v16 = (v10 >> 26) + v14;
  v21 = (v16 >> 26) + v19;
  v41 = v21 >> 26;
  v21 &= 0x3FFFFFFu;
  v25 = v41 + v23;
  v42 = v25 >> 26;
  v25 &= 0x3FFFFFFu;
  v29 = v42 + v27;
  v43 = v29 >> 26;
  v29 &= 0x3FFFFFFu;
  v13 = 5 * v43 + (v10 & 0x3FFFFFF);
  v44 = v13 >> 26;
  v13 &= 0x3FFFFFFu;
  v17 = v44 + (v16 & 0x3FFFFFF);
  v46 = (v21 + ((v17 + ((v13 + 5) >> 26)) >> 26)) & 0x3FFFFFF;
  v47 = (v25 + ((v21 + ((v17 + ((v13 + 5) >> 26)) >> 26)) >> 26)) & 0x3FFFFFF;
  v48 = v29 + ((v25 + ((v21 + ((v17 + ((v13 + 5) >> 26)) >> 26)) >> 26)) >> 26) - 0x4000000;
  v45 = (v48 >> 31) - 1;
  v18 = ~v45 & v17 | v45 & (v17 + ((v13 + 5) >> 26)) & 0x3FFFFFF;
  v22 = ~v45 & v21 | v45 & v46;
  v26 = ~v45 & v25 | v45 & v47;
  v51 = (~v45 & v13 | v45 & (v13 + 5) & 0x3FFFFFF | (v18 << 26))
      + (unsigned __int64)((*((unsigned __int8 *)a4 + 18) << 16) | a4[8] | (*((unsigned __int8 *)a4 + 19) << 24));
  v52 = ((v18 >> 6) | (v22 << 20))
      + (unsigned __int64)((*((unsigned __int8 *)a4 + 22) << 16) | a4[10] | (*((unsigned __int8 *)a4 + 23) << 24));
  v54 = ((v22 >> 12) | (v26 << 14))
      + (unsigned __int64)((*((unsigned __int8 *)a4 + 26) << 16) | a4[12] | (*((unsigned __int8 *)a4 + 27) << 24));
  v56 = ((v26 >> 18) | ((~v45 & v29 | v45 & v48) << 8))
      + ((*((unsigned __int8 *)a4 + 30) << 16) | a4[14] | (*((unsigned __int8 *)a4 + 31) << 24));
  *a1 = v51;
  v53 = HIDWORD(v51) + v52;
  a1[1] = v53;
  v55 = HIDWORD(v53) + v54;
  a1[2] = v55;
  a1[3] = HIDWORD(v55) + v56;
  return __readfsqword(0x28u) ^ v77;
}

//----- (00000000000529D0) ----------------------------------------------------
void __fastcall _libc_csu_init(unsigned int a1, __int64 a2, __int64 a3)
{
  signed __int64 v4; // rbp
  __int64 i; // rbx

  v4 = _do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry;
  init_proc();
  if ( v4 )
  {
    for ( i = 0LL; i != v4; ++i )
      ((void (__fastcall *)(_QWORD, __int64, __int64))_frame_dummy_init_array_entry[i])(a1, a2, a3);
  }
}
// E240: using guessed type __int64 __fastcall frame_dummy(_QWORD, _QWORD, _QWORD);
// 27FC38: using guessed type __int64 (__fastcall *_frame_dummy_init_array_entry[4])();
// 27FC48: using guessed type __int64 (__fastcall *_do_global_dtors_aux_fini_array_entry[2])();

//----- (0000000000052A50) ----------------------------------------------------
int __fastcall fstat(int fildes, struct stat *stat_buf)
{
  return __fxstat(1, fildes, stat_buf);
}

//----- (0000000000052A60) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=1202 queued=887 decompiled=887 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 887 function(s)"
